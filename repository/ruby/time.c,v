head	1.69;
access;
symbols
	v1_6_7:1.31.2.9
	v1_6_6:1.31.2.8
	v1_6_5:1.31.2.4
	v1_6_4:1.31.2.4
	v1_7_1:1.41
	v1_6_4_preview4:1.31.2.4
	v1_6_4_preview3:1.31.2.4
	v1_6_4_preview2:1.31.2.3
	v1_6_4_preview1:1.31.2.3
	v1_6_3:1.31
	ruby_m17n:1.31.0.4
	ruby_1_6:1.31.0.2
	v1_6_2:1.31
	v1_6_1:1.26
	v1_6_0:1.25
	v1_4_6:1.4.2.5
	v1_4_5:1.4.2.4
	v1_4_4:1.4.2.2
	ruby_1_4_3:1.4
	ruby1_4_3:1.4
	v1_4_3:1.4
	v1_5_0:1.5
	ruby_1_4_3_pre1:1.4
	ruby_1_4:1.4.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.11
	v1_3_6_repack:1.1.1.3.2.11
	v1_3_6:1.1.1.3.2.11
	v1_3_5:1.1.1.3.2.10
	v1_2_6repack:1.1.1.2.2.20
	v1_3_4_990625:1.1.1.3.2.9
	v1_3_4_990624:1.1.1.3.2.9
	v1_2_6:1.1.1.2.2.20
	v1_3_4_990611:1.1.1.3.2.9
	v1_3_4_990531:1.1.1.3.2.8
	v1_3_3_990518:1.1.1.3.2.8
	v1_3_3_990513:1.1.1.3.2.7
	v1_3_3_990507:1.1.1.3.2.7
	v1_2_5:1.1.1.2.2.19
	v1_2_4:1.1.1.2.2.19
	v1_3_1_990225:1.1.1.3.2.3
	v1_3_1_990224:1.1.1.3.2.2
	v1_3_1_990215:1.1.1.3.2.1
	v1_3_1_990212:1.1.1.3.2.1
	v1_3_1_990210:1.1.1.3.2.1
	v1_3_1_:1.1.1.3.2.1
	v1_3_1_990209:1.1.1.3.2.1
	v1_3_1_990205:1.1.1.3.2.1
	v1_3_1_990203:1.1.1.3.2.1
	v1_3_1_990201:1.1.1.3.2.1
	v1_3_1"_990201:1.1.1.3.2.1
	v1_3_1_990128:1.1.1.3.2.1
	v1_3_1_990127:1.1.1.3.2.1
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.18
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.18
	v1_2_1repack:1.1.1.2.2.17
	v1_2_1:1.1.1.2.2.17
	v1_2_stable:1.1.1.2.2.17
	v1_1d1:1.1.1.2.2.14.2.3
	v1_1d0:1.1.1.2.2.14.2.3
	v1_1c9_1:1.1.1.2.2.17
	v1_1c9:1.1.1.2.2.17
	v1_1c8:1.1.1.2.2.16
	v1_1c7:1.1.1.2.2.15
	v1_1c6:1.1.1.2.2.14
	v1_1d-start:1.1.1.2.2.14.2.1
	v1_1c5:1.1.1.2.2.14
	v1_1dev:1.1.1.2.2.14.0.2
	v1_1c4:1.1.1.2.2.14
	v1_1c3:1.1.1.2.2.14
	v1_1c2:1.1.1.2.2.14
	v1_1c1:1.1.1.2.2.14
	v1_1c0:1.1.1.2.2.14
	v1_1b9_31:1.1.1.2.2.14
	v1_1b9_30:1.1.1.2.2.14
	v1_1b9_28:1.1.1.2.2.14
	v1_1b9_27:1.1.1.2.2.13
	v1_1b9_26:1.1.1.2.2.13
	r1_1b9_25:1.1.1.2.2.13
	r1_1b9_24:1.1.1.2.2.13
	v1_1b9_23:1.1.1.2.2.12
	v1_1b9_22:1.1.1.2.2.11
	v1_1b9_20:1.1.1.2.2.11
	v1_1b9_18:1.1.1.2.2.10
	v1_1b9_16:1.1.1.2.2.9
	v1_1b9_15:1.1.1.2.2.9
	v1_1b9_13:1.1.1.2.2.8
	v1_1b9_12:1.1.1.2.2.8
	v1_1b9_11:1.1.1.2.2.7
	v1_1b9_08:1.1.1.2.2.7
	v1_1b9_07:1.1.1.2.2.7
	r1_1b9:1.1.1.2.2.6
	v1_1b8:1.1.1.2.2.6
	v1_1b7:1.1.1.2.2.4
	v1_1b6:1.1.1.2.2.1
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.69
date	2002.09.17.13.52.45;	author michal;	state Exp;
branches;
next	1.68;

1.68
date	2002.09.08.12.59.07;	author eban;	state Exp;
branches;
next	1.67;

1.67
date	2002.09.08.10.06.40;	author usa;	state Exp;
branches;
next	1.66;

1.66
date	2002.09.03.05.20.07;	author matz;	state Exp;
branches;
next	1.65;

1.65
date	2002.08.28.08.05.23;	author michal;	state Exp;
branches;
next	1.64;

1.64
date	2002.08.27.08.31.06;	author matz;	state Exp;
branches;
next	1.63;

1.63
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.62;

1.62
date	2002.08.19.05.56.05;	author matz;	state Exp;
branches;
next	1.61;

1.61
date	2002.07.31.05.18.43;	author matz;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.30.06.12.27;	author matz;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.29.08.42.18;	author eban;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.29.05.20.33;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2002.04.24.04.54.14;	author matz;	state Exp;
branches;
next	1.56;

1.56
date	2002.04.18.08.46.18;	author matz;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.22.07.26.35;	author matz;	state Exp;
branches;
next	1.54;

1.54
date	2002.03.08.07.03.03;	author matz;	state Exp;
branches;
next	1.53;

1.53
date	2002.02.01.10.23.22;	author nobu;	state Exp;
branches;
next	1.52;

1.52
date	2001.12.22.16.58.16;	author matz;	state Exp;
branches;
next	1.51;

1.51
date	2001.12.22.02.51.00;	author matz;	state Exp;
branches;
next	1.50;

1.50
date	2001.12.21.09.23.21;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.18.08.46.56;	author matz;	state Exp;
branches;
next	1.48;

1.48
date	2001.12.17.06.45.37;	author akr;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.13.08.19.07;	author matz;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.10.07.18.12;	author matz;	state Exp;
branches;
next	1.45;

1.45
date	2001.12.03.10.07.46;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2001.10.29.05.07.18;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2001.10.03.07.19.11;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2001.10.02.04.31.19;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.30.09.12.34;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.24.06.10.32;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.16.09.05.50;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.02.04.22.11;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.26.14.29.57;	author eban;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.21.03.41.41;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2001.02.27.07.52.11;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.20.07.42.03;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2001.02.16.07.53.19;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2001.02.14.05.51.58;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.22.03.22.05;	author matz;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2000.12.18.09.46.06;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.12.12.07.42.35;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.08.05.29.25;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.17.18.13.59;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.07.06.59.37;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.31.05.29.54;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.24.06.21.35;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.15.06.22.43;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.07.03.20.53;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.06.07.21.14;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.22.08.29.47;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.19.08.38.11;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.16.07.44.06;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.14.05.50.32;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.14.05.11.55;	author eban;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.13.02.48.49;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.12.14.46.44;	author eban;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.12.07.48.23;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.12.09.07.46;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.01.09.41.30;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.07.08.37.49;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.29.08.05.28;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.17.07.11.18;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.01.03.12.14;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.05.04.37.13;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.10.29.09.25.32;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.10.04.04.51.06;	author matz;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.09.16.09.40.33;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.15;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.13;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.30;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.17;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.24.04.31.26;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.25.06.39.11;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.03.24.08.52.34;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.04.09.17.57.43;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.04.16.09.45.14;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.04.16.10.12.06;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.05.14.08.56.12;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.06.11.06.29.59;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.07.15.07.59.57;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.07.22.10.37.23;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.30.10.18.25;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.02.03.10.02.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.02.09.10.56.23;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.02.16.06.05.30;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.02.18.01.56.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.04.02.10.03.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.04.20.06.20.35;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.04.22.08.57.35;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.04.30.07.41.18;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.05.13.07.26.38;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.05.25.04.57.58;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.06.02.10.05.35;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.06.26.09.44.43;	author matz;	state Exp;
branches
	1.1.1.2.2.14.2.1;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.11.09.09.11.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.11.17.09.12.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.11.26.08.25.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	99.01.18.09.08.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	99.04.08.10.14.35;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	99.06.21.06.31.11;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.14.2.1
date	98.09.08.07.09.22;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14.2.2;

1.1.1.2.2.14.2.2
date	98.11.25.03.31.18;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14.2.3;

1.1.1.2.2.14.2.3
date	98.12.16.07.30.34;	author matz;	state Exp;
branches;
next	;

1.4.2.1
date	2000.01.17.08.24.13;	author matz;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2000.02.17.08.29.04;	author matz;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2000.06.13.09.50.49;	author matz;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2000.06.20.06.08.41;	author matz;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2000.06.23.16.06.50;	author matz;	state Exp;
branches;
next	;

1.31.2.1
date	2001.03.26.14.29.44;	author eban;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2001.04.03.05.43.49;	author matz;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2001.04.06.05.42.40;	author matz;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2001.05.15.08.49.21;	author matz;	state Exp;
branches;
next	1.31.2.5;

1.31.2.5
date	2001.10.29.05.04.41;	author matz;	state Exp;
branches;
next	1.31.2.6;

1.31.2.6
date	2001.12.03.10.06.39;	author matz;	state Exp;
branches;
next	1.31.2.7;

1.31.2.7
date	2001.12.04.04.53.31;	author matz;	state Exp;
branches;
next	1.31.2.8;

1.31.2.8
date	2001.12.13.08.12.59;	author matz;	state Exp;
branches;
next	1.31.2.9;

1.31.2.9
date	2001.12.30.09.10.28;	author akr;	state Exp;
branches;
next	1.31.2.10;

1.31.2.10
date	2002.07.31.05.17.28;	author matz;	state Exp;
branches;
next	;


desc
@@


1.69
log
@move struct timeval to missing.h
@
text
@/**********************************************************************

  time.c -

  $Author: eban $
  $Date: 2002/09/08 12:59:07 $
  created at: Tue Dec 28 14:31:59 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto

**********************************************************************/

#include "ruby.h"
#include <sys/types.h>
#include <time.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <math.h>

VALUE rb_cTime;

struct time_object {
    struct timeval tv;
    struct tm tm;
    int gmt;
    int tm_got;
};

#define GetTimeval(obj, tobj) \
    Data_Get_Struct(obj, struct time_object, tobj)

static void time_free _((void *));

static void
time_free(tobj)
    void *tobj;
{
    if (tobj) free(tobj);
}

static VALUE
time_s_alloc(klass)
    VALUE klass;
{
    VALUE obj;
    struct time_object *tobj;

    obj = Data_Make_Struct(klass, struct time_object, 0, time_free, tobj);
    tobj->tm_got=0;
    if (gettimeofday(&tobj->tv, 0) < 0) {
	rb_sys_fail("gettimeofday");
    }

    return obj;
}

static VALUE
time_s_now(klass)
    VALUE klass;
{
    return rb_obj_alloc(klass);
}


#define NDIV(x,y) (-(-((x)+1)/(y))-1)
#define NMOD(x,y) ((y)-(-((x)+1)%(y))-1)

static VALUE
time_new_internal(klass, sec, usec)
    VALUE klass;
    time_t sec, usec;
{
    VALUE obj;
    time_t tmp;
    struct time_object *tobj;

    if (usec >= 1000000) {	/* usec positive overflow */
	tmp = sec + usec / 1000000;
	usec %= 1000000;
	if (sec > 0 && tmp < 0) {
	    rb_raise(rb_eRangeError, "out of Time range");
	}
	sec = tmp;
    }
    if (usec < 0) {		/* usec negative overflow */
	tmp = sec + NDIV(usec,1000000); /* negative div */
	usec = NMOD(usec,1000000);      /* negative mod */
	if (sec < 0 && tmp > 0) {
	    rb_raise(rb_eRangeError, "out of Time range");
	}
	sec = tmp;
    }
#ifndef NEGATIVE_TIME_T
    if (sec < 0 || (sec == 0 && usec < 0))
	rb_raise(rb_eArgError, "time must be positive");
#endif

    obj = Data_Make_Struct(klass, struct time_object, 0, time_free, tobj);
    tobj->tm_got = 0;
    tobj->tv.tv_sec = sec;
    tobj->tv.tv_usec = usec;

    return obj;
}

VALUE
rb_time_new(sec, usec)
    time_t sec, usec;
{
    return time_new_internal(rb_cTime, sec, usec);
}

static struct timeval
time_timeval(time, interval)
    VALUE time;
    int interval;
{
    struct timeval t;
    char *tstr = interval ? "time interval" : "time";

#ifndef NEGATIVE_TIME_T
    interval = 1;
#endif

    switch (TYPE(time)) {
      case T_FIXNUM:
	t.tv_sec = FIX2LONG(time);
	if (interval && t.tv_sec < 0)
	    rb_raise(rb_eArgError, "%s must be positive", tstr);
	t.tv_usec = 0;
	break;

      case T_FLOAT:
	if (interval && RFLOAT(time)->value < 0.0)
	    rb_raise(rb_eArgError, "%s must be positive", tstr);
	else {
	    double f, d;

	    d = modf(RFLOAT(time)->value, &f);
	    t.tv_sec = (time_t)f;
	    if (f != t.tv_sec) {
		rb_raise(rb_eRangeError, "%f out of Time range", RFLOAT(time)->value);
	    }
	    t.tv_usec = (time_t)(d*1e6);
	}
	break;

      case T_BIGNUM:
	t.tv_sec = NUM2LONG(time);
	if (interval && t.tv_sec < 0)
	    rb_raise(rb_eArgError, "%s must be positive", tstr);
	t.tv_usec = 0;
	break;

      default:
	rb_raise(rb_eTypeError, "can't convert %s into %s",
		 rb_class2name(CLASS_OF(time)), tstr);
	break;
    }
    return t;
}

struct timeval
rb_time_interval(time)
    VALUE time;
{
    return time_timeval(time, Qtrue);
}

struct timeval
rb_time_timeval(time)
    VALUE time;
{
    struct time_object *tobj;
    struct timeval t;

    if (TYPE(time) == T_DATA && RDATA(time)->dfree == time_free) {
	GetTimeval(time, tobj);
	t = tobj->tv;
	return t;
    }
    return time_timeval(time, Qfalse);
}

static VALUE
time_s_at(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    struct timeval tv;
    VALUE time, t;

    if (rb_scan_args(argc, argv, "11", &time, &t) == 2) {
	tv.tv_sec = NUM2LONG(time);
	tv.tv_usec = NUM2LONG(t);
    }
    else {
	tv = rb_time_timeval(time);
    }
    t = time_new_internal(klass, tv.tv_sec, tv.tv_usec);
    if (TYPE(time) == T_DATA && RDATA(time)->dfree == time_free) {
	struct time_object *tobj, *tobj2;

	GetTimeval(time, tobj);
	GetTimeval(t, tobj2);
	tobj2->gmt = tobj->gmt;
    }
    return t;
}

static char *months [12] = {
    "jan", "feb", "mar", "apr", "may", "jun",
    "jul", "aug", "sep", "oct", "nov", "dec",
};

static long
obj2long(obj)
    VALUE obj;
{
    if (TYPE(obj) == T_STRING) {
	obj = rb_str_to_inum(obj, 10, Qfalse);
    }

    return NUM2LONG(obj);
}

static void
time_arg(argc, argv, tm, usec)
    int argc;
    VALUE *argv;
    struct tm *tm;
    time_t *usec;
{
    VALUE v[7];
    int i;
    long year;

    MEMZERO(tm, struct tm, 1);
    if (argc == 10) {
	v[0] = argv[5];
	v[1] = argv[4];
	v[2] = argv[3];
	v[3] = argv[2];
	v[4] = argv[1];
	v[5] = argv[0];
	*usec = 0;
	tm->tm_isdst = RTEST(argv[8]) ? 1 : 0;
    }
    else {
	rb_scan_args(argc, argv, "16", &v[0],&v[1],&v[2],&v[3],&v[4],&v[5],&v[6]);
	*usec = NIL_P(v[6]) ? 0 : obj2long(v[6]);
	tm->tm_isdst = -1;
    }

    year = obj2long(v[0]);

    if (0 <= year && year < 39) {
	year += 100;
	rb_warning("2 digits year is used");
    }
    else if (69 <= year && year < 139) {
	rb_warning("2 or 3 digits year is used");
    }
    else {
	year -= 1900;
    }

    tm->tm_year = year;

    if (NIL_P(v[1])) {
	tm->tm_mon = 0;
    }
    else if (TYPE(v[1]) == T_STRING) {
	tm->tm_mon = -1;
	for (i=0; i<12; i++) {
	    if (RSTRING(v[1])->len == 3 &&
		strcasecmp(months[i], RSTRING(v[1])->ptr) == 0) {
		tm->tm_mon = i;
		break;
	    }
	}
	if (tm->tm_mon == -1) {
	    char c = RSTRING(v[1])->ptr[0];

	    if ('0' <= c && c <= '9') {
		tm->tm_mon = obj2long(v[1])-1;
	    }
	}
    }
    else {
	tm->tm_mon = obj2long(v[1]) - 1;
    }
    if (NIL_P(v[2])) {
	tm->tm_mday = 1;
    }
    else {
	tm->tm_mday = obj2long(v[2]);
    }
    tm->tm_hour = NIL_P(v[3])?0:obj2long(v[3]);
    tm->tm_min  = NIL_P(v[4])?0:obj2long(v[4]);
    tm->tm_sec  = NIL_P(v[5])?0:obj2long(v[5]);

    /* value validation */
    if (
           tm->tm_year != year ||
#ifndef NEGATIVE_TIME_T
           tm->tm_year < 69 ||
#endif
	   tm->tm_mon  < 0 || tm->tm_mon  > 11
	|| tm->tm_mday < 1 || tm->tm_mday > 31
	|| tm->tm_hour < 0 || tm->tm_hour > 23
	|| tm->tm_min  < 0 || tm->tm_min  > 59
	|| tm->tm_sec  < 0 || tm->tm_sec  > 60)
	rb_raise(rb_eArgError, "argument out of range");
}

static VALUE time_gmtime _((VALUE));
static VALUE time_localtime _((VALUE));
static VALUE time_get_tm _((VALUE, int));

#if !defined HAVE_TIMEGM
static int
tmcmp(a, b)
    struct tm *a;
    struct tm *b;
{
    if (a->tm_year != b->tm_year)
        return a->tm_year < b->tm_year ? -1 : 1;
    else if (a->tm_mon != b->tm_mon)
        return a->tm_mon < b->tm_mon ? -1 : 1;
    else if (a->tm_mday != b->tm_mday)
        return a->tm_mday < b->tm_mday ? -1 : 1;
    else if (a->tm_hour != b->tm_hour)
        return a->tm_hour < b->tm_hour ? -1 : 1;
    else if (a->tm_min != b->tm_min)
        return a->tm_min < b->tm_min ? -1 : 1;
    else if (a->tm_sec != b->tm_sec)
        return a->tm_sec < b->tm_sec ? -1 : 1;
    else
        return 0;
}

static time_t
search_time_t(tptr, utc_p)
    struct tm *tptr;
    int utc_p;
{
    time_t guess, guess_lo, guess_hi;
    struct tm *tm, tm_lo, tm_hi;
    int d, have_guess;
    int find_dst;

    find_dst = 0 < tptr->tm_isdst;

#ifdef NEGATIVE_TIME_T
    guess_lo = 1L << (8 * sizeof(time_t) - 1);
#else
    guess_lo = 0;
#endif
    guess_hi = ((time_t)-1) < ((time_t)0) ?
               (1UL << (8 * sizeof(time_t) - 1)) - 1 :
	       ~(time_t)0;

    tm = (utc_p ? gmtime : localtime)(&guess_lo);
    if (!tm) goto error;
    d = tmcmp(tptr, tm);
    if (d < 0) goto out_of_range;
    if (d == 0) return guess_lo;
    tm_lo = *tm;

    tm = (utc_p ? gmtime : localtime)(&guess_hi);
    if (!tm) goto error;
    d = tmcmp(tptr, tm);
    if (d > 0) goto out_of_range;
    if (d == 0) return guess_hi;
    tm_hi = *tm;

    have_guess = 0;

    while (guess_lo + 1 < guess_hi) {
      /* there is a gap between guess_lo and guess_hi. */
      unsigned long range = 0;
      if (!have_guess) {
	int a, b;
	/*
	  Try precious guess by a linear interpolation at first.
	  `a' and `b' is a coefficient of guess_lo and guess_hi as:

	    guess = (guess_lo * a + guess_hi * b) / (a + b)

	  However this causes overflow in most cases, following assignment
	  is used instead:

	    guess = guess_lo / d * a + (guess_lo % d) * a / d
		  + guess_hi / d * b + (guess_hi % d) * b / d
	      where d = a + b

	  To avoid overflow in this assignment, `d' is restricted to less than
	  sqrt(2**31).  By this restriction and other reasons, the guess is
	  not accurate and some error is expected.  `range' approximates 
	  the maximum error.

	  When these parameters are not suitable, i.e. guess is not within
	  guess_lo and guess_hi, simple guess by binary search is used.
	*/
	range = 366 * 24 * 60 * 60;
	a = (tm_hi.tm_year - tptr->tm_year);
	b = (tptr->tm_year - tm_lo.tm_year);
	/* 46000 is selected as `some big number less than sqrt(2**31)'. */
	if (a + b <= 46000 / 12) {
	  range = 31 * 24 * 60 * 60;
	  a *= 12;
	  b *= 12;
	  a += tm_hi.tm_mon - tptr->tm_mon;
	  b += tptr->tm_mon - tm_lo.tm_mon;
	  if (a + b <= 46000 / 31) {
	    range = 24 * 60 * 60;
	    a *= 31;
	    b *= 31;
	    a += tm_hi.tm_mday - tptr->tm_mday;
	    b += tptr->tm_mday - tm_lo.tm_mday;
	    if (a + b <= 46000 / 24) {
	      range = 60 * 60;
	      a *= 24;
	      b *= 24;
	      a += tm_hi.tm_hour - tptr->tm_hour;
	      b += tptr->tm_hour - tm_lo.tm_hour;
	      if (a + b <= 46000 / 60) {
		range = 60;
		a *= 60;
		b *= 60;
		a += tm_hi.tm_min - tptr->tm_min;
		b += tptr->tm_min - tm_lo.tm_min;
		if (a + b <= 46000 / 60) {
		  range = 1;
		  a *= 60;
		  b *= 60;
		  a += tm_hi.tm_sec - tptr->tm_sec;
		  b += tptr->tm_sec - tm_lo.tm_sec;
		}
	      }
	    }
	  }
	}
	if (a <= 0) a = 1;
	if (b <= 0) b = 1;
	d = a + b;
	/*
	  Although `/' and `%' may produce unexpected result with negative
	  argument, it doesn't cause serious problem because there is a
	  fail safe.
	*/
	guess = guess_lo / d * a + (guess_lo % d) * a / d
	      + guess_hi / d * b + (guess_hi % d) * b / d;
	have_guess = 1;
      }

      if (guess <= guess_lo || guess_hi <= guess) {
	/* Precious guess is invalid. try binary search. */ 
	guess = guess_lo / 2 + guess_hi / 2;
	if (guess <= guess_lo)
	  guess = guess_lo + 1;
	else if (guess >= guess_hi)
	  guess = guess_hi - 1;
	range = 0;
      }

      tm = (utc_p ? gmtime : localtime)(&guess);
      if (!tm) goto error;
      have_guess = 0;

      d = tmcmp(tptr, tm);
      if (d < 0) {
        guess_hi = guess;
	tm_hi = *tm;
	if (range) {
	  guess = guess - range;
	  range = 0;
	  if (guess_lo < guess && guess < guess_hi)
	    have_guess = 1;
	}
      }
      else if (d > 0) {
        guess_lo = guess;
	tm_lo = *tm;
	if (range) {
	  guess = guess + range;
	  range = 0;
	  if (guess_lo < guess && guess < guess_hi)
	    have_guess = 1;
	}
      }
      else {
	if (!utc_p) {
	  /* If localtime is nonmonotonic, another result may exist. */
	  time_t guess2;
	  if (find_dst) {
	    guess2 = guess - 2 * 60 * 60;
	    tm = localtime(&guess2);
	    if (tm) {
	      if (tptr->tm_hour != (tm->tm_hour + 2) % 24 ||
		  tptr->tm_min != tm->tm_min ||
		  tptr->tm_sec != tm->tm_sec) {
		guess2 -= (tm->tm_hour - tptr->tm_hour) * 60 * 60 +
			  (tm->tm_min - tptr->tm_min) * 60 +
			  (tm->tm_sec - tptr->tm_sec);
		if (tptr->tm_mday != tm->tm_mday)
		  guess2 += 24 * 60 * 60;
		if (guess != guess2) {
		  tm = localtime(&guess2);
		  if (tmcmp(tptr, tm) == 0) {
		    if (guess < guess2)
		      return guess;
		    else
		      return guess2;
		  }
		}
	      }
	    }
	  }
	  else {
	    guess2 = guess + 2 * 60 * 60;
	    tm = localtime(&guess2);
	    if (tm) {
	      if ((tptr->tm_hour + 2) % 24 != tm->tm_hour ||
		  tptr->tm_min != tm->tm_min ||
		  tptr->tm_sec != tm->tm_sec) {
		guess2 -= (tm->tm_hour - tptr->tm_hour) * 60 * 60 +
			  (tm->tm_min - tptr->tm_min) * 60 +
			  (tm->tm_sec - tptr->tm_sec);
		if (tptr->tm_mday != tm->tm_mday)
		  guess2 -= 24 * 60 * 60;
		if (guess != guess2) {
		  tm = localtime(&guess2);
		  if (tmcmp(tptr, tm) == 0) {
		    if (guess < guess2)
		      return guess2;
		    else
		      return guess;
		  }
		}
	      }
	    }
	  }
	}
	return guess;
      }
    }
    /* Given argument has no corresponding time_t. Let's outerpolation. */
    if (tm_lo.tm_year == tptr->tm_year && tm_lo.tm_mon == tptr->tm_mon) {
      return guess_lo +
        (tptr->tm_mday - tm_lo.tm_mday) * 24 * 60 * 60 +
        (tptr->tm_hour - tm_lo.tm_hour) * 60 * 60 +
        (tptr->tm_min - tm_lo.tm_min) * 60 +
        (tptr->tm_sec - tm_lo.tm_sec);
    }
    else if (tm_hi.tm_year == tptr->tm_year && tm_hi.tm_mon == tptr->tm_mon) {
      return guess_hi +
        (tptr->tm_mday - tm_hi.tm_mday) * 24 * 60 * 60 +
        (tptr->tm_hour - tm_hi.tm_hour) * 60 * 60 +
        (tptr->tm_min - tm_hi.tm_min) * 60 +
        (tptr->tm_sec - tm_hi.tm_sec);
    }

  out_of_range:
    rb_raise(rb_eArgError, "time out of range");

  error:
    rb_raise(rb_eArgError, "gmtime/localtime error");
    return 0;			/* not reached */
}
#endif

static time_t
make_time_t(tptr, utc_p)
    struct tm *tptr;
    int utc_p;
{
    time_t t;
    struct tm *tmp, buf;
    buf = *tptr;
    if (utc_p) {
#if defined(HAVE_TIMEGM)
	t = timegm(&buf);
	if (t == -1) {
#ifdef NEGATIVE_TIME_T
	    if (!(tmp = gmtime(&t)) ||
	        tptr->tm_year != tmp->tm_year ||
		tptr->tm_mon != tmp->tm_mon ||
		tptr->tm_mday != tmp->tm_mday ||
		tptr->tm_hour != tmp->tm_hour ||
		tptr->tm_min != tmp->tm_min ||
		tptr->tm_sec != tmp->tm_sec)
#endif
	    rb_raise(rb_eArgError, "gmtime error");
        }
#else
	t = search_time_t(&buf, utc_p);
#endif
    }
    else {
#if defined(HAVE_MKTIME)
	t = mktime(&buf);
	if (t == -1) {
#ifdef NEGATIVE_TIME_T
	    if (!(tmp = localtime(&t)) ||
	        tptr->tm_year != tmp->tm_year ||
		tptr->tm_mon != tmp->tm_mon ||
		tptr->tm_mday != tmp->tm_mday ||
		tptr->tm_hour != tmp->tm_hour ||
		tptr->tm_min != tmp->tm_min ||
		tptr->tm_sec != tmp->tm_sec)
#endif
	    rb_raise(rb_eArgError, "localtime error");
        }
#else
	t = search_time_t(&buf, utc_p);
#endif
    }
    return t;
}

static VALUE
time_utc_or_local(argc, argv, utc_p, klass)
    int argc;
    VALUE *argv;
    int utc_p;
    VALUE klass;
{
    struct tm tm;
    VALUE time;
    time_t usec;

    time_arg(argc, argv, &tm, &usec);
    time = time_new_internal(klass, make_time_t(&tm, utc_p), usec);
    if (utc_p) return time_gmtime(time);
    return time_localtime(time);
}

static VALUE
time_s_mkutc(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    return time_utc_or_local(argc, argv, Qtrue, klass);
}

static VALUE
time_s_mktime(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    return time_utc_or_local(argc, argv, Qfalse, klass);
}

static VALUE
time_to_i(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return LONG2NUM(tobj->tv.tv_sec);
}

static VALUE
time_to_f(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return rb_float_new((double)tobj->tv.tv_sec+(double)tobj->tv.tv_usec/1e6);
}

static VALUE
time_usec(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return LONG2NUM(tobj->tv.tv_usec);
}

static VALUE
time_cmp(time1, time2)
    VALUE time1, time2;
{
    struct time_object *tobj1, *tobj2;
    long i;

    GetTimeval(time1, tobj1);
    switch (TYPE(time2)) {
      case T_FIXNUM:
	i = FIX2LONG(time2);
	if (tobj1->tv.tv_sec == i) {
	    if (tobj1->tv.tv_usec == 0)
		return INT2FIX(0);
	    if (tobj1->tv.tv_usec > 0)
		return INT2FIX(1);
	    return INT2FIX(-1);
	}
	if (tobj1->tv.tv_sec > i) return INT2FIX(1);
	return INT2FIX(-1);
	
      case T_FLOAT:
	return rb_dbl_cmp((double)tobj1->tv.tv_sec + (double)tobj1->tv.tv_usec*1e-6,
			  RFLOAT(time2)->value);
    }

    if (TYPE(time2) == T_DATA && RDATA(time2)->dfree == time_free) {
	GetTimeval(time2, tobj2);
	if (tobj1->tv.tv_sec == tobj2->tv.tv_sec) {
	    if (tobj1->tv.tv_usec == tobj2->tv.tv_usec) return INT2FIX(0);
	    if (tobj1->tv.tv_usec > tobj2->tv.tv_usec) return INT2FIX(1);
	    return INT2FIX(-1);
	}
	if (tobj1->tv.tv_sec > tobj2->tv.tv_sec) return INT2FIX(1);
	return INT2FIX(-1);
    }
    if (TYPE(time2) == T_BIGNUM) {
	double a = (double)tobj1->tv.tv_sec+(double)tobj1->tv.tv_usec/1e6;
	double b = rb_big2dbl(time2);

	if (a == b) return INT2FIX(0);
	if (a > b) return INT2FIX(1);
	if (a < b) return INT2FIX(-1);
    }
    i = NUM2LONG(time2);
    if (tobj1->tv.tv_sec == i) {
	if (tobj1->tv.tv_usec == 0)
	    return INT2FIX(0);
	if (tobj1->tv.tv_usec > 0)
	    return INT2FIX(1);
	return INT2FIX(-1);
    }
    if (tobj1->tv.tv_sec > i) return INT2FIX(1);
    return INT2FIX(-1);
}

static VALUE
time_eql(time1, time2)
    VALUE time1, time2;
{
    struct time_object *tobj1, *tobj2;

    GetTimeval(time1, tobj1);
    if (TYPE(time2) == T_DATA && RDATA(time2)->dfree == time_free) {
	GetTimeval(time2, tobj2);
	if (tobj1->tv.tv_sec == tobj2->tv.tv_sec) {
	    if (tobj1->tv.tv_usec == tobj2->tv.tv_usec) return Qtrue;
	}
    }
    return Qfalse;
}

static VALUE
time_utc_p(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->gmt) return Qtrue;
    return Qfalse;
}

static VALUE
time_hash(time)
    VALUE time;
{
    struct time_object *tobj;
    long hash;

    GetTimeval(time, tobj);
    hash = tobj->tv.tv_sec ^ tobj->tv.tv_usec;
    return LONG2FIX(hash);
}

static void
time_modify(time)
    VALUE time;
{
    rb_check_frozen(time);
    if (!OBJ_TAINTED(time) && rb_safe_level() >= 4)
	rb_raise(rb_eSecurityError, "Insecure: can't modify Time");
}

static VALUE
time_become(copy, time)
    VALUE copy, time;
{
    struct time_object *tobj, *tcopy;

    if (copy == time) return copy;
    time_modify(copy);
    if (TYPE(time) != T_DATA || RDATA(time)->dfree != time_free) {
	rb_raise(rb_eTypeError, "wrong argument type");
    }
    GetTimeval(time, tobj);
    GetTimeval(copy, tcopy);
    MEMCPY(tcopy, tobj, struct time_object, 1);

    return copy;
}

static VALUE
time_dup(time)
    VALUE time;
{
    VALUE dup = time_s_alloc(rb_cTime);
    time_become(dup, time);
    return dup;
}

static VALUE
time_localtime(time)
    VALUE time;
{
    struct time_object *tobj;
    struct tm *tm_tmp;
    time_t t;

    GetTimeval(time, tobj);
    if (!tobj->gmt) {
	if (tobj->tm_got)
	    return time;
    }
    else {
	time_modify(time);
    }
    t = tobj->tv.tv_sec;
    tm_tmp = localtime(&t);
    if (!tm_tmp)
	rb_raise(rb_eArgError, "localtime error");
    tobj->tm = *tm_tmp;
    tobj->tm_got = 1;
    tobj->gmt = 0;
    return time;
}

static VALUE
time_gmtime(time)
    VALUE time;
{
    struct time_object *tobj;
    struct tm *tm_tmp;
    time_t t;

    GetTimeval(time, tobj);
    if (tobj->gmt) {
	if (tobj->tm_got)
	    return time;
    }
    else {
	time_modify(time);
    }
    t = tobj->tv.tv_sec;
    tm_tmp = gmtime(&t);
    if (!tm_tmp)
	rb_raise(rb_eArgError, "gmtime error");
    tobj->tm = *tm_tmp;
    tobj->tm_got = 1;
    tobj->gmt = 1;
    return time;
}

static VALUE
time_getlocaltime(time)
    VALUE time;
{
    return time_localtime(time_dup(time));
}

static VALUE
time_getgmtime(time)
    VALUE time;
{
    return time_gmtime(time_dup(time));
}

static VALUE
time_get_tm(time, gmt)
    VALUE time;
    int gmt;
{
    if (gmt) return time_gmtime(time);
    return time_localtime(time);
}

static VALUE
time_asctime(time)
    VALUE time;
{
    struct time_object *tobj;
    char *s;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    s = asctime(&tobj->tm);
    if (s[24] == '\n') s[24] = '\0';

    return rb_str_new2(s);
}

static VALUE
time_to_s(time)
    VALUE time;
{
    struct time_object *tobj;
    char buf[128];
    int len;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    if (tobj->gmt == 1) {
	len = strftime(buf, 128, "%a %b %d %H:%M:%S UTC %Y", &tobj->tm);
    }
    else {
	len = strftime(buf, 128, "%a %b %d %H:%M:%S %Z %Y", &tobj->tm);
    }
    return rb_str_new(buf, len);
}

static VALUE
time_plus(time1, time2)
    VALUE time1, time2;
{
    struct time_object *tobj;
    time_t sec, usec;
    double f, d, v;

    GetTimeval(time1, tobj);

    if (TYPE(time2) == T_DATA && RDATA(time2)->dfree == time_free) {
	rb_raise(rb_eTypeError, "time + time?");
    }
    v = NUM2DBL(time2);
    d = modf(v, &f);
    sec = (time_t)f;
    if (f != (double)sec) {
	rb_raise(rb_eRangeError, "time + %f out of Time range", v);
    }
#ifndef NEGATIVE_TIME_T
    if (f < 0 && -f >= tobj->tv.tv_sec) {
	rb_raise(rb_eArgError, "time must be positive");
    }
#endif
    usec = tobj->tv.tv_usec + (time_t)(d*1e6);
    sec = tobj->tv.tv_sec + (time_t)f;

#ifdef NEGATIVE_TIME_T
    if ((tobj->tv.tv_sec >= 0 && f >= 0 && sec < 0) ||
	(tobj->tv.tv_sec <= 0 && f <= 0 && sec > 0)) {
	rb_raise(rb_eRangeError, "time + %f out of Time range", v);
    }
#endif
    time2 = rb_time_new(sec, usec);
    if (tobj->gmt) {
	GetTimeval(time2, tobj);
	tobj->gmt = 1;
    }
    return time2;
}

static VALUE
time_minus(time1, time2)
    VALUE time1, time2;
{
    struct time_object *tobj;
    time_t sec, usec;
    double f, d, v;

    GetTimeval(time1, tobj);
    if (TYPE(time2) == T_DATA && RDATA(time2)->dfree == time_free) {
	struct time_object *tobj2;

	GetTimeval(time2, tobj2);
	f = (double)tobj->tv.tv_sec - (double)tobj2->tv.tv_sec;
	f += ((double)tobj->tv.tv_usec - (double)tobj2->tv.tv_usec)*1e-6;
	/* XXX: should check float overflow on 64bit time_t platforms */

	return rb_float_new(f);
    }
    v = NUM2DBL(time2);
    d = modf(v, &f);
    sec = (time_t)f;
    if (f != (double)sec) {
	rb_raise(rb_eRangeError, "time - %f out of Time range", v);
    }
#ifndef NEGATIVE_TIME_T
    if (f > 0 && f >= tobj->tv.tv_sec) {
	rb_raise(rb_eArgError, "time must be positive");
    }
#endif
    usec = tobj->tv.tv_usec - (time_t)(d*1e6);
    sec = tobj->tv.tv_sec - (time_t)f;
#ifdef NEGATIVE_TIME_T
    if ((tobj->tv.tv_sec <= 0 && f >= 0 && sec > 0) ||
	(tobj->tv.tv_sec >= 0 && f <= 0 && sec < 0)) {
	rb_raise(rb_eRangeError, "time - %f out of Time range", v);
    }
#endif

    time2 = rb_time_new(sec, usec);
    if (tobj->gmt) {
	GetTimeval(time2, tobj);
	tobj->gmt = 1;
    }
    return time2;
}

static VALUE
time_sec(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    return INT2FIX(tobj->tm.tm_sec);
}

static VALUE
time_min(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    return INT2FIX(tobj->tm.tm_min);
}

static VALUE
time_hour(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    return INT2FIX(tobj->tm.tm_hour);
}

static VALUE
time_mday(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    return INT2FIX(tobj->tm.tm_mday);
}

static VALUE
time_mon(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    return INT2FIX(tobj->tm.tm_mon+1);
}

static VALUE
time_year(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    return LONG2NUM((long)tobj->tm.tm_year+1900);
}

static VALUE
time_wday(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    return INT2FIX(tobj->tm.tm_wday);
}

static VALUE
time_yday(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    return INT2FIX(tobj->tm.tm_yday+1);
}

static VALUE
time_isdst(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    return tobj->tm.tm_isdst?Qtrue:Qfalse;
}

static VALUE
time_zone(time)
    VALUE time;
{
    struct time_object *tobj;
#if !defined(HAVE_TM_ZONE) && (!defined(HAVE_TZNAME) || !defined(HAVE_DAYLIGHT))
    char buf[64];
    int len;
#endif
    
    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }

    if (tobj->gmt == 1) {
	return rb_str_new2("UTC");
    }
#if defined(HAVE_TM_ZONE)
    return rb_str_new2(tobj->tm.tm_zone);
#elif defined(HAVE_TZNAME) && defined(HAVE_DAYLIGHT)
    return rb_str_new2(tzname[daylight && tobj->tm.tm_isdst]);
#else
    len = strftime(buf, 64, "%Z", &tobj->tm);
    return rb_str_new(buf, len);
#endif
}

static VALUE
time_utc_offset(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }

    if (tobj->gmt == 1) {
	return INT2FIX(0);
    }
    else {
#if defined(HAVE_STRUCT_TM_TM_GMTOFF)
	return INT2NUM(tobj->tm.tm_gmtoff);
#else
	struct tm *u, *l;
	time_t t;
	long off;
	l = &tobj->tm;
	t = tobj->tv.tv_sec;
	u = gmtime(&t);
	if (!u)
	    rb_raise(rb_eArgError, "gmtime error");
	if (l->tm_year != u->tm_year)
	    off = l->tm_year < u->tm_year ? -1 : 1;
	else if (l->tm_mon != u->tm_mon)
	    off = l->tm_mon < u->tm_mon ? -1 : 1;
	else if (l->tm_mday != u->tm_mday)
	    off = l->tm_mday < u->tm_mday ? -1 : 1;
	else
	    off = 0;
	off = off * 24 + l->tm_hour - u->tm_hour;
	off = off * 60 + l->tm_min - u->tm_min;
	off = off * 60 + l->tm_sec - u->tm_sec;
	return LONG2FIX(off);
#endif
    }
}

static VALUE
time_to_a(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    return rb_ary_new3(10,
		    INT2FIX(tobj->tm.tm_sec),
		    INT2FIX(tobj->tm.tm_min),
		    INT2FIX(tobj->tm.tm_hour),
		    INT2FIX(tobj->tm.tm_mday),
		    INT2FIX(tobj->tm.tm_mon+1),
		    LONG2NUM((long)tobj->tm.tm_year+1900),
		    INT2FIX(tobj->tm.tm_wday),
		    INT2FIX(tobj->tm.tm_yday+1),
		    tobj->tm.tm_isdst?Qtrue:Qfalse,
		    time_zone(time));
}

#define SMALLBUF 100
static int
rb_strftime(buf, format, time)
    char ** volatile buf;
    char * volatile format;
    struct tm * volatile time;
{
    volatile int size;
    int len, flen;

    (*buf)[0] = '\0';
    flen = strlen(format);
    if (flen == 0) {
	return 0;
    }
    len = strftime(*buf, SMALLBUF, format, time);
    if (len != 0 || **buf == '\0') return len;
    for (size=1024; ; size*=2) {
	*buf = xmalloc(size);
	(*buf)[0] = '\0';
	len = strftime(*buf, size, format, time);
	/*
	 * buflen can be zero EITHER because there's not enough
	 * room in the string, or because the control command
	 * goes to the empty string. Make a reasonable guess that
	 * if the buffer is 1024 times bigger than the length of the
	 * format string, it's not failing for lack of room.
	 */
	if (len > 0 || size >= 1024 * flen) return len;
	free(*buf);
    }
    /* not reached */
}

static VALUE
time_strftime(time, format)
    VALUE time, format;
{
    struct time_object *tobj;
    char buffer[SMALLBUF];
    char *fmt, *buf = buffer;
    long len;
    VALUE str;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_get_tm(time, tobj->gmt);
    }
    StringValue(format);
    fmt = RSTRING(format)->ptr;
    len = RSTRING(format)->len;
    if (len == 0) {
	rb_warning("strftime called with empty format string");
    }
    if (strlen(fmt) < len) {
	/* Ruby string may contain \0's. */
	char *p = fmt, *pe = fmt + len;

	str = rb_str_new(0, 0);
	while (p < pe) {
	    len = rb_strftime(&buf, p, &tobj->tm);
	    rb_str_cat(str, buf, len);
	    p += strlen(p) + 1;
	    if (p <= pe)
		rb_str_cat(str, "\0", 1);
	    if (buf != buffer) {
		free(buf);
		buf = buffer;
	    }
	}
	return str;
    }
    len = rb_strftime(&buf, RSTRING(format)->ptr, &tobj->tm);
    str = rb_str_new(buf, len);
    if (buf != buffer) free(buf);
    return str;
}

static VALUE
time_s_times(obj)
    VALUE obj;
{
    rb_warn("obsolete method Time::times; use Process::times");
    return rb_proc_times(obj);
}

static VALUE
time_dump(argc, argv, time)
    int argc;
    VALUE *argv;
    VALUE time;
{
    VALUE dummy;
    struct time_object *tobj;
    struct tm *tm;
    unsigned long p, s;
    unsigned char buf[8];
    time_t t;
    int i;

    rb_scan_args(argc, argv, "01", &dummy);
    GetTimeval(time, tobj);

    t = tobj->tv.tv_sec;
    tm = gmtime(&t);

    if ((tm->tm_year & 0x1ffff) != tm->tm_year)
	rb_raise(rb_eArgError, "too big year to marshal");

    p = 0x1          << 31 | /*  1 */
	tm->tm_year  << 14 | /* 17 */
	tm->tm_mon   << 10 | /*  4 */
	tm->tm_mday  <<  5 | /*  5 */
	tm->tm_hour;         /*  5 */
    s = tm->tm_min   << 26 | /*  6 */
	tm->tm_sec   << 20 | /*  6 */
	tobj->tv.tv_usec;    /* 20 */

    for (i=0; i<4; i++) {
	buf[i] = p & 0xff;
	p = RSHIFT(p, 8);
    }
    for (i=4; i<8; i++) {
	buf[i] = s & 0xff;
	s = RSHIFT(s, 8);
    }

    return rb_str_new(buf, 8);
}

static VALUE
time_load(klass, str)
    VALUE klass, str;
{
    unsigned long p, s;
    time_t sec, usec;
    unsigned char *buf;
    struct tm tm;
    int i;

    StringValue(str);
    buf = (unsigned char *)RSTRING(str)->ptr;
    if (RSTRING(str)->len != 8) {
	rb_raise(rb_eTypeError, "marshaled time format differ");
    }

    p = s = 0;
    for (i=0; i<4; i++) {
	p |= buf[i]<<(8*i);
    }
    for (i=4; i<8; i++) {
	s |= buf[i]<<(8*(i-4));
    }

    if ((p & (1<<31)) == 0) {
	return time_new_internal(klass, p, s);
    }
    p &= ~(1<<31);
    tm.tm_year = (p >> 14) & 0x1ffff;
    tm.tm_mon  = (p >> 10) & 0xf;
    tm.tm_mday = (p >>  5) & 0x1f;
    tm.tm_hour =  p        & 0x1f;
    tm.tm_min  = (s >> 26) & 0x3f;
    tm.tm_sec  = (s >> 20) & 0x3f;
    tm.tm_isdst = 0;

    sec = make_time_t(&tm, Qtrue);
    usec = (time_t)(s & 0xfffff);

    return time_new_internal(klass, sec, usec);
}

void
Init_Time()
{
    rb_cTime = rb_define_class("Time", rb_cObject);
    rb_include_module(rb_cTime, rb_mComparable);

    rb_define_singleton_method(rb_cTime, "now", time_s_now, 0);
    rb_define_singleton_method(rb_cTime, "allocate", time_s_alloc, 0);
    rb_define_singleton_method(rb_cTime, "at", time_s_at, -1);
    rb_define_singleton_method(rb_cTime, "utc", time_s_mkutc, -1);
    rb_define_singleton_method(rb_cTime, "gm", time_s_mkutc, -1);
    rb_define_singleton_method(rb_cTime, "local", time_s_mktime, -1);
    rb_define_singleton_method(rb_cTime, "mktime", time_s_mktime, -1);

    rb_define_singleton_method(rb_cTime, "times", time_s_times, 0);

    rb_define_method(rb_cTime, "to_i", time_to_i, 0);
    rb_define_method(rb_cTime, "to_f", time_to_f, 0);
    rb_define_method(rb_cTime, "<=>", time_cmp, 1);
    rb_define_method(rb_cTime, "eql?", time_eql, 1);
    rb_define_method(rb_cTime, "hash", time_hash, 0);
    rb_define_method(rb_cTime, "become", time_become, 1);

    rb_define_method(rb_cTime, "localtime", time_localtime, 0);
    rb_define_method(rb_cTime, "gmtime", time_gmtime, 0);
    rb_define_method(rb_cTime, "utc", time_gmtime, 0);
    rb_define_method(rb_cTime, "getlocal", time_getlocaltime, 0);
    rb_define_method(rb_cTime, "getgm", time_getgmtime, 0);
    rb_define_method(rb_cTime, "getutc", time_getgmtime, 0);

    rb_define_method(rb_cTime, "ctime", time_asctime, 0);
    rb_define_method(rb_cTime, "asctime", time_asctime, 0);
    rb_define_method(rb_cTime, "to_s", time_to_s, 0);
    rb_define_method(rb_cTime, "inspect", time_to_s, 0);
    rb_define_method(rb_cTime, "to_a", time_to_a, 0);

    rb_define_method(rb_cTime, "+", time_plus, 1);
    rb_define_method(rb_cTime, "-", time_minus, 1);

    rb_define_method(rb_cTime, "sec", time_sec, 0);
    rb_define_method(rb_cTime, "min", time_min, 0);
    rb_define_method(rb_cTime, "hour", time_hour, 0);
    rb_define_method(rb_cTime, "mday", time_mday, 0);
    rb_define_method(rb_cTime, "day", time_mday, 0);
    rb_define_method(rb_cTime, "mon", time_mon, 0);
    rb_define_method(rb_cTime, "month", time_mon, 0);
    rb_define_method(rb_cTime, "year", time_year, 0);
    rb_define_method(rb_cTime, "wday", time_wday, 0);
    rb_define_method(rb_cTime, "yday", time_yday, 0);
    rb_define_method(rb_cTime, "isdst", time_isdst, 0);
    rb_define_method(rb_cTime, "dst?", time_isdst, 0);
    rb_define_method(rb_cTime, "zone", time_zone, 0);
    rb_define_method(rb_cTime, "gmtoff", time_utc_offset, 0);
    rb_define_method(rb_cTime, "gmt_offset", time_utc_offset, 0);
    rb_define_method(rb_cTime, "utc_offset", time_utc_offset, 0);

    rb_define_method(rb_cTime, "utc?", time_utc_p, 0);
    rb_define_method(rb_cTime, "gmt?", time_utc_p, 0);

    rb_define_method(rb_cTime, "tv_sec", time_to_i, 0);
    rb_define_method(rb_cTime, "tv_usec", time_usec, 0);
    rb_define_method(rb_cTime, "usec", time_usec, 0);

    rb_define_method(rb_cTime, "strftime", time_strftime, 1);

    /* methods for marshaling */
    rb_define_method(rb_cTime, "_dump", time_dump, -1);
    rb_define_singleton_method(rb_cTime, "_load", time_load, 1);
}
@


1.68
log
@* time.c (time_free): prototype; struct time_object -> void *.
  avoid GCC warnings.
* lib/mkmf.rb, ext/extmk.rb ($LINK, $CPP): move to lib/mkmf.rb.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2002/09/08 10:06:40 $
a14 1

a15 11
#ifndef NT
#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
#else
#define time_t long
struct timeval {
        time_t tv_sec;		/* seconds */
        time_t tv_usec;		/* and microseconds */
};
#endif
#endif /* NT */
d20 1
@


1.67
log
@* time.c: prototype; time_free() to avoid VC++ warnings.

* win32/win32.c (rb_w32_stat): remove S_IWGRP and S_IWOTH bits from
  st_mode.

* win32/win32.h (S_I*): define if not defined.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/03 05:20:07 $
d46 1
a46 1
static void time_free _((struct time_object *));
d50 1
a50 1
    struct time_object *tobj;
@


1.66
log
@	* variable.c (rb_copy_generic_ivar): remove old generic instance
	  variable table if it existes.

	* class.c (rb_make_metaclass): metaclass of a metaclass is a
	  metaclass itself.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/28 08:05:23 $
d45 2
@


1.65
log
@Int vs Long cleanup #3 (ruby-core:352)
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/27 08:31:06 $
d796 9
d811 2
a829 9
}

static void
time_modify(time)
    VALUE time;
{
    if (OBJ_FROZEN(time)) rb_error_frozen("Time");
    if (!OBJ_TAINTED(time) && rb_safe_level() >= 4)
	rb_raise(rb_eSecurityError, "Insecure: can't modify Time");
@


1.64
log
@* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.

* class.c (rb_mod_dup): need to preserve metaclass and flags.

* object.c (rb_cstr_to_dbl): had a buffer overrun.

* marshal.c (w_class): integrate singleton check into a funciton
  to follow DRY principle.

* marshal.c (w_uclass): should check singleton method.

* object.c (rb_obj_dup): dmark and dfree functions must be match
  for T_DATA type.

* object.c (rb_obj_dup): class of the duped object must be match
  to the class of the original.

* re.c (rb_reg_quote): do not escape \t, \f, \r, \n, for they are
  not regular expression metacharacters.

* time.c (time_s_alloc): use time_free instead of free (null check,
  also serves for type mark).

* time.c (time_s_at): check dfree function too.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/21 15:47:54 $
d1196 1
a1196 1
	int off;
d1213 1
a1213 1
	return INT2FIX(off);
@


1.63
log
@*.c: Int vs Long cleanup
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/19 05:56:05 $
d46 7
d60 1
a60 1
    obj = Data_Make_Struct(klass, struct time_object, 0, free, tobj);
d110 1
a110 1
    obj = Data_Make_Struct(klass, struct time_object, 0, free, tobj);
d189 1
a189 1
    if (rb_obj_is_kind_of(time, rb_cTime)) {
d214 1
a214 1
    if (TYPE(time) == T_DATA) {
d727 1
a727 1
    if (rb_obj_is_kind_of(time2, rb_cTime)) {
d764 1
a764 1
    if (rb_obj_is_kind_of(time2, rb_cTime)) {
d797 2
a798 2
time_clone(time)
    VALUE time;
d800 1
a800 2
    VALUE clone;
    struct time_object *tobj, *tclone;
d802 3
d806 5
a810 3
    clone = Data_Make_Struct(0, struct time_object, 0, free, tclone);
    CLONESETUP(clone, time);
    MEMCPY(tclone, tobj, struct time_object, 1);
d812 7
a818 1
    return clone;
a882 15
time_dup(time)
    VALUE time;
{
    VALUE clone;
    struct time_object *tobj, *tclone;

    GetTimeval(time, tobj);
    clone = Data_Make_Struct(0, struct time_object, 0, free, tclone);
    DUPSETUP(clone, time);
    MEMCPY(tclone, tobj, struct time_object, 1);

    return clone;
}

static VALUE
d953 1
a953 1
    if (rb_obj_is_kind_of(time2, rb_cTime)) {
d993 1
a993 1
    if (rb_obj_is_kind_of(time2, rb_cTime)) {
d1434 1
a1434 2
    rb_define_method(rb_cTime, "clone", time_clone, 0);
    rb_define_method(rb_cTime, "dup", time_dup, 0);
@


1.62
log
@* array.c (sort_2): *a - *b may overflow.

* array.c (ary_new): len*sizeof(VALUE) may be a positive value.

* array.c (rb_ary_initialize): ditto.

* object.c (rb_class_allocate_instance): move singleton class
  check from rb_obj_alloc().

* re.c (rb_reg_initialize): should not modify frozen Regexp.

* ext/tcltklib/tcltklib.c (ip_init): allocation framework.
@
text
@d6 1
a6 1
  $Date: 2002/07/31 05:18:43 $
d691 1
a691 1
    return INT2NUM(tobj->tv.tv_usec);
d786 1
a786 1
    return INT2FIX(hash);
d1279 2
a1280 3
    char *fmt;
    char *buf = buffer;
    int len;
@


1.61
log
@* eval.c (rb_undef): undef should be done for klass, not ruby_class.
@
text
@d6 1
a6 1
  $Date: 2002/05/30 06:12:27 $
d716 2
a717 10
	{
	    double t;

	    t = (double)tobj1->tv.tv_sec + (double)tobj1->tv.tv_usec*1e-6;
	    if (t > RFLOAT(time2)->value)
		return INT2FIX(1);
	    if (t < RFLOAT(time2)->value)
		return INT2FIX(-1);
	    return INT2FIX(0);
	}
@


1.60
log
@* range.c (range_step): iteration done using "+" if elements are
  Numeric.  Otherwise using "succ".

* range.c (range_each): iteration done using "succ".  If the
  elements does not respond to "succ", raise TypeError.  As a
  result, all Enumerable methods, e.g. collect, require elements
  to respond to "succ'.

* range.c (range_member): comparison done using "each", if
  elements are non-Numeric or no-"succ" objects.  Otherwise
  compare using "<=>".

* range.c (Init_Range): remove "size" and "length".
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/05/29 08:42:18 $
d264 1
a264 1
	year += 2000;
a267 1
	year += 1900;
d270 3
a273 1
    year -= 1900;
@


1.59
log
@* time.c (tmcmp, search_time_t): activate unless HAVE_TIMEGM.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/29 05:20:33 $
a693 10
time_succ(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return rb_time_new(tobj->tv.tv_sec + 1, tobj->tv.tv_usec);
}

static VALUE
a1441 2
    rb_define_method(rb_cTime, "succ", time_succ, 0);
    rb_define_method(rb_cTime, "next", time_succ, 0);
@


1.58
log
@* parse.y: yyparse #defines moved from intern.h

* ruby.c (proc_options): access prefixed "ruby_yydebug".

* applied modifies to pacify some of gcc -Wall warnings.

* parse.y (arg): no more ugly hack for "**", so that "-2**2" to be
  parsed as "(-2)**2", whereas "- 2**2" or "-(2)**2" to be parsed
  as "-(2**2)".

* parse.y (yylex): '-2' to be literal fixnum. [new]

* time.c (time_succ): new method for Range support.

* time.c (time_arg): nil test against v[6] (usec).
@
text
@d6 1
a6 1
  $Date: 2002/04/24 04:54:14 $
d326 1
d577 1
@


1.57
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d6 1
a6 1
  $Date: 2002/04/18 08:46:18 $
d257 1
a257 1
	*usec = (argc == 7) ? NUM2INT(v[6]) : 0;
d692 10
d1450 2
@


1.56
log
@* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* io.c: complete off_t handling; missing argument for
  fptr_finalize(); polished rb_scan_args call.

* dir.c: wrap multi-statment macro by do { } while (0)

* eval.c, numeric,c, sprintf.c, util.c: ditto.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.
@
text
@d6 1
a6 1
  $Date: 2002/03/22 07:26:35 $
d1156 1
d1159 2
a1160 1

@


1.55
log
@* the VMS support patch submitted by Akiyoshi, Masamichi
  <Masamichi.Akiyoshi@@jp.compaq.com> is merged.

* eval.c (exec_under): changing ruby_class is OK, but should not
  alter cbase.

* eval.c (yield_under_i): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/08 07:03:03 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
d43 2
a44 3
#define GetTimeval(obj, tobj) {\
    Data_Get_Struct(obj, struct time_object, tobj);\
}
@


1.54
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.

* class.c (rb_mod_clone): should not call rb_obj_clone(), since
  Module does not provide "allocate".

* class.c (rb_singleton_class): should crate new singleton class
  if obj is a class or module and attached object is different,
  which means metaclass of singleton class is sought.

* time.c (time_s_alloc): now follows allocation framework.

* eval.c (rb_eval): should initialize outer class variables from
  methods in singleton class definitions.

* eval.c (assign): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/02/01 10:23:22 $
d1385 1
a1385 1
    buf = RSTRING(str)->ptr;
@


1.53
log
@* intern.h: prototypes for new functions; rb_cstr_to_inum(),
  rb_str_to_inum(), rb_cstr_to_dbl(), rb_str_to_dbl()

* bignum.c (rb_cstr_to_inum): changed from rb_cstr2inum(), and
  added argument badcheck to be consistent with parser. [new]

* bignum.c (rb_str_to_inum): ditto.

* bignum.c (rb_cstr2inum): wapper of rb_cstr_to_inum() now.

* bignum.c (rb_str2inum): ditto.

* object.c (rb_cstr_to_dbl): float number parser. [new]

* object.c (rb_str_to_dbl): ditto.

* object.c (rb_Float): use rb_cstr_to_dbl() for strict check.

* object.c (rb_Integer): use rb_str_to_inum() for strict check.

* string.c (rb_str_to_f): use rb_str_to_dbl() with less check.

* string.c (rb_str_to_i): use rb_str_to_inum() with less check.

* string.c (rb_str_hex): ditto.

* string.c (rb_str_oct): ditto.

* sprintf.c (rb_f_sprintf): ditto.

* time.c (obj2long): ditto.

* parse.y (yylex): use rb_cstr_to_inum() for strict check.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/12/22 16:58:16 $
d48 1
a48 1
time_s_now(klass)
a55 1

d63 8
d1423 1
a1423 1
    rb_define_singleton_method(rb_cTime, "allocate", time_s_now, 0);
@


1.52
log
@* time.c (time_timeval): wrong cast to time_t.

* time.c (time_plus): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/12/22 02:51:00 $
d221 1
a221 1
	obj = rb_str2inum(obj, 10);
@


1.51
log
@* parse.y (str_extend): make up "#$;" handling.
@
text
@d6 1
a6 1
  $Date: 2001/12/21 09:23:21 $
d143 1
a143 1
	    t.tv_usec = (time_t)d*1e6;
d956 1
a956 1
    if (f != (double)sec || d >= 1.0 || d <= -1.0) {
d964 1
a964 1
    usec = tobj->tv.tv_usec + (time_t)d*1e6;
d1003 1
a1003 1
    if (f != (double)sec || d >= 1.0 || d <= -1.0) {
d1404 1
a1404 1
    usec = (time_t) s & 0xfffff;
@


1.50
log
@* time.c (time_plus): result should not be negative unless
  NEGATIVE_TIME_T is defined.

* time.c (time_new_internal): should check tv_sec overflow too.

* time.c (time_timeval): should check time_t range when time is
  initialized from float.

* time.c (time_plus): uses modf(3).

* variable.c (rb_cvar_set): add frozen class/module check.

* variable.c (rb_cvar_declare): add frozen class/module check.

* re.c (match_to_a): should propagate taint.

* re.c (rb_reg_s_quote): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/12/18 08:46:56 $
d955 1
d1002 1
@


1.49
log
@* string.c (rb_str_replace): swap arguments of OBJ_INFECT.

* eval.c (rb_thread_schedule): should not select a thread which is
  not yet initialized.

* time.c (time_plus): wrong boundary check.

* time.c (time_minus): ditto.
@
text
@d5 2
a6 2
  $Author: akr $
  $Date: 2001/12/17 06:45:37 $
d32 1
d73 1
d77 1
a77 1
	sec += usec / 1000000;
d79 4
d85 6
a90 2
	sec += NDIV(usec,1000000); /* negative div */
	usec = NMOD(usec,1000000); /* negative mod */
d135 10
a144 2
	t.tv_sec = (time_t)RFLOAT(time)->value;
	t.tv_usec = (time_t)((RFLOAT(time)->value - (double)t.tv_sec)*1e6);
d946 1
a946 1
    double f, d;
d953 4
a956 5
    f = NUM2DBL(time2);
    sec = (time_t)f;
    d = f - (double)sec;
    if (d >= 1.0 || d <= -1.0) {
	rb_raise(rb_eRangeError, "time + %f out of Time range", f);
d958 7
a964 2
    usec = tobj->tv.tv_usec + (time_t)(d*1e6);
    sec = tobj->tv.tv_sec + sec;
d969 1
a969 1
	rb_raise(rb_eRangeError, "time + %f out of Time range", f);
d986 1
a986 1
    double f, d;
d995 1
d999 8
a1006 5
    f = NUM2DBL(time2);
    sec = (time_t)f;
    d = f - (double)sec;
    if (d >= 1.0 || d <= -1.0) {
	rb_raise(rb_eRangeError, "time - %f out of Time range", f);
d1008 1
d1010 1
a1010 1
    sec = tobj->tv.tv_sec - sec;
d1014 1
a1014 1
	rb_raise(rb_eRangeError, "time - %f out of Time range", f);
@


1.48
log
@* time.c: new method `gmtoff', `gmt_offset' and `utc_offset'.
(time_utc_offset): new function.
(Init_Time): bind above methods to `time_utc_offset'.

* time.c: 64bit time_t support.
(time_s_at): use NUM2LONG instead of NUM2INT for tv_sec.
(time_arg): initialize tm_isdst correctly.
use long to initialize tm_year.
(search_time_t): renamed from `make_time_t'.
(make_time_t): call `timegm' and `mktime' instead of `search_time_t'
if availabe.
(time_to_i): use LONG2NUM instead of INT2NUM.
(time_localtime): check localtime failure.
(time_gmtime): check gmtime failure.
(time_year): use LONG2NUM instead of INT2FIX.
(time_to_a): use long for tm_year.
(time_dump): check tm_year which is not representable with 17bit.
(time_load): initialize tm_isdst.

* configure.in: check existence of `mktime' and `timegm'.
check existence of tm_gmtoff field of struct tm.
fix negative time_t for 64bit time_t.

* missing/strftime.c: fix overflow by tm_year + 1900.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/12/10 07:18:12 $
d177 1
a177 1
	tv.tv_usec = NUM2INT(t);
d928 1
a928 1
    double f;
d937 2
a938 1
    if (f != (double)sec) {
d941 1
a941 1
    usec = tobj->tv.tv_usec + (time_t)((f - (double)sec)*1e6);
d964 1
a964 1
    double f;
d978 2
a979 1
    if (f != (double)sec) {
d982 1
a982 1
    usec = tobj->tv.tv_usec - (time_t)((f - (double)sec)*1e6);
@


1.47
log
@* time.c (time_new_internal): avoid loop to calculate negative
  div, mod.

* time.c (time_cmp): should handle Bignums.

* array.c (rb_ary_pop): should ELTS_SHARED flag check before
  REALLOC.
@
text
@d176 1
a176 1
	tv.tv_sec = NUM2INT(time);
d218 1
d229 1
a229 1
	tm->tm_isdst = RTEST(argv[9]) ? 1 : 0;
d234 1
d237 14
a250 3
    tm->tm_year = obj2long(v[0]);
    if (0 <= tm->tm_year && tm->tm_year < 69) tm->tm_year += 100;
    if (tm->tm_year >= 1900) tm->tm_year -= 1900;
d286 1
d324 1
a324 1
make_time_t(tptr, utc_p)
d333 1
a333 1
    find_dst = 1;
d336 1
a336 1
    guess_lo = 1 << (8 * sizeof(time_t) - 1);
d553 49
d644 1
a644 1
    return INT2NUM(tobj->tv.tv_sec);
d812 2
d838 2
d1072 1
a1072 1
    return INT2FIX(tobj->tm.tm_year+1900);
d1141 42
d1198 1
a1198 1
		    INT2FIX(tobj->tm.tm_year+1900),
d1312 3
d1370 1
d1372 1
a1372 1
    sec = make_time_t(&tm, gmtime);
d1431 3
@


1.46
log
@* array.c (rb_ary_modify): should copy the internal buffer if the
  modifying buffer is shared.

* array.c (ary_make_shared): make an internal buffer of an array
  to be shared.

* array.c (rb_ary_shift): avoid sliding an internal buffer by
  using shared buffer.

* array.c (rb_ary_subseq): avoid copying the buffer.

* parse.y (gettable): should freeze __LINE__ string.

* io.c (rb_io_puts): old behavoir restored.  rationale: a) if you
  want to call to_s for arrays, you can just call print a, "\n".
  b) to_s wastes memory if array (and sum of its contents) is
  huge.  c) now any object that has to_ary is treated as an array,
  using rb_check_convert_type().

* hash.c (rb_hash_initialize): now accepts a block to calculate
  the default value. [new]

* hash.c (rb_hash_aref): call "default" method to get the value
  corrensponding to the non existing key.

* hash.c (rb_hash_default): get the default value based on the
  block given to 'new'.  Now it takes an optinal "key" argument.
  "default" became the method to get the value for non existing
  key.  Users may override "default" method to change the hash
  behavior.

* hash.c (rb_hash_set_default): clear the flag if a block is given
  to 'new'

* object.c (Init_Object): undef Data.allocate, left Data.new.

* ext/curses/curses.c (window_scrollok): use RTEST().

* ext/curses/curses.c (window_idlok): ditto.

* ext/curses/curses.c (window_keypad): ditto.

* ext/curses/curses.c (window_idlok): idlok() may return void on
  some platforms; so don't use return value.

* ext/curses/curses.c (window_scrollok): ditto for consistency.

* ext/curses/curses.c: replace FIX2INT() by typechecking NUM2INT().

* parse.y (str_extend): should not process immature #$x and
  #@@x interpolation, e.g #@@#@@ etc.

* enum.c (enum_sort_by): sort_by does not have to be stable always.

* enum.c (enum_sort_by): call qsort directly to gain performance.

* util.c (ruby_qsort): ruby_qsort(qs6) is now native thread safe.

* error.c (rb_sys_fail): it must be a bug if it's called when
  errno == 0.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@d6 1
a6 1
  $Date: 2001/12/03 10:07:46 $
d63 3
d74 1
a74 1
    if (usec >= 1000000) {	/* usec overflow */
d78 3
a80 3
    while (usec < 0) {		/* usec underflow */
	sec--;
	usec += 1000000;
d648 8
d870 3
d877 2
a878 2
    if ((tobj->tv.tv_sec > 0 && f > 0 && sec < 0) ||
	(tobj->tv.tv_sec < 0 && f < 0 && sec > 0)) {
d908 4
a911 5
    else {
	f = NUM2DBL(time2);
	sec = (time_t)f;
	usec = tobj->tv.tv_usec - (time_t)((f - (double)sec)*1e6);
	sec = tobj->tv.tv_sec - sec;
d913 2
d916 2
a917 2
    if ((tobj->tv.tv_sec < 0 && f > 0 && sec > 0) ||
	(tobj->tv.tv_sec > 0 && f < 0 && sec < 0)) {
@


1.45
log
@* time.c (time_plus): must detect result overflow.

* time.c (time_minus): ditto.

* time.c (time_new_internal): round usec overflow and underflow
  here.

* time.c (time_plus): move operand overflow/underflow check to
  time_new_internal().

* time.c (time_minus): ditto.

* time.c (time_cmp): should consider tv_usec too.

* time.c (time_gmtime): time_modify() should be called even if tm
  struct is not calculated yet.
@
text
@d6 1
a6 1
  $Date: 2001/10/29 05:07:18 $
d75 3
a77 3
    if (usec < 0) {		/* usec underflow */
	sec -= (-usec) / 1000000;
	usec %= 1000000;
d646 7
a652 1
    if (tobj1->tv.tv_sec == i) return INT2FIX(0);
d769 29
d1109 1
a1109 1
	if (len > 0 || len >= 1024 * flen) return len;
d1147 4
a1150 1
	    if (len > SMALLBUF) free(buf);
d1272 1
d1277 4
@


1.44
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* variable.c (rb_cvar_set): empty iv_tbl may cause infinite loop.

* variable.c (rb_cvar_get): ditto.

* variable.c (cvar_override_check): ditto.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.

* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.
@
text
@d6 1
a6 1
  $Date: 2001/10/03 07:19:11 $
d71 8
d612 7
a618 1
	if (tobj1->tv.tv_sec == i) return INT2FIX(0);
d723 5
a727 2
    if (tobj->tm_got) {
	if (!tobj->gmt) return time;
d747 5
a751 2
    if (tobj->tm_got) {
	if (tobj->gmt) return time;
d827 4
a830 7
    if (usec >= 1000000) {	/* usec overflow */
	sec++;
	usec -= 1000000;
    }
    if (usec < 0) {		/* usec underflow */
	sec--;
	usec += 1000000;
d832 1
d854 2
a855 2
	f = tobj->tv.tv_sec - tobj2->tv.tv_sec;
	f += (tobj->tv.tv_usec - tobj2->tv.tv_usec)*1e-6;
d865 6
d872 1
a872 9
    if (usec >= 1000000) {	/* usec overflow */
	sec++;
	usec -= 1000000;
    }
    if (usec < 0) {		/* usec underflow */
	sec--;
	usec += 1000000;
    }
    time2 = time_new_internal(rb_obj_class(time1), sec, usec);
@


1.43
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/10/02 04:31:19 $
d709 3
a711 2
    if (tobj->tm_got && !tobj->gmt) {
	return time;
a712 1
    time_modify(time);
d730 3
a732 2
    if (tobj->tm_got && tobj->gmt) {
	return time;
a733 1
    time_modify(time);
@


1.42
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* string.c (rb_str_subpat_set): support function for new argument
  pattern String#[re,offset] = val. [new]

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_aref_m): new argument pattern
  String#[re,offset]. [new]

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* array.c (rb_ary_initialize): Array.new([1,2,3]) => [1,2,3]. [new]

* string.c (rb_str_reverse): should return an instance of
  receiver's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.

* eval.c (eval): retrieves file, line information from binding.

* eval.c (intersect_fds): counts intersecting fds.

* eval.c (rb_thread_schedule): only fds requested by
  each thread count as select_value.
@
text
@d6 1
a6 1
  $Date: 2001/05/30 09:12:34 $
a63 12
time_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE obj = time_s_now(klass);

    rb_obj_call_init(obj, argc, argv);
    return obj;
}

static VALUE
d1203 1
a1203 1
    rb_define_singleton_method(rb_cTime, "new", time_s_new, -1);
@


1.41
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d6 1
a6 1
  $Date: 2001/05/24 06:10:32 $
d868 1
a868 1
    time2 = rb_time_new(sec, usec);
@


1.40
log
@* eval.c (rb_yield_0): need argument adjustment for C defined
  blocks too.
@
text
@d6 1
a6 1
  $Date: 2001/05/16 09:05:50 $
d317 4
a320 1
    int d;
d328 1
a328 1
               (1U << (8 * sizeof(time_t) - 1)) - 1 :
d345 78
a422 45
    while (guess_lo + 1 < guess_hi) { /* there is a gap between lo and hi. */
      unsigned long range;
      int a, b;
      /*
        Try precious guess by a linear interpolation at first.
	`a' and `b' is a coefficient of guess_lo and guess_hi.
	`range' is approximation of maximum error by the interpolation.
	(a + b)**2 should be less than 2**31 to avoid overflow.
	When these parameter is wrong, binary search is used.
      */
      a = (tm_hi.tm_year - tptr->tm_year);
      b = (tptr->tm_year - tm_lo.tm_year);
      range = 366 * 24 * 3600;
      if (a + b < 46000 / 366) {
        /* 46000 is selected as `some big number less than sqrt(2**31)'. */
	/* The distinction between leap/non-leap year is not important here. */
	static int days[] = {
	  0,
	  0 + 31,
	  0 + 31 + 29,
	  0 + 31 + 29 + 31,
	  0 + 31 + 29 + 31 + 30,
	  0 + 31 + 29 + 31 + 30 + 31,
	  0 + 31 + 29 + 31 + 30 + 31 + 30,
	  0 + 31 + 29 + 31 + 30 + 31 + 30 + 31,
	  0 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31,
	  0 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
	  0 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
	  0 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30
	  /* Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov */
	};
	a *= 366;
	b *= 366;
	d = days[tptr->tm_mon] + tptr->tm_mday;
	a += days[tm_hi.tm_mon] + tm_hi.tm_mday - d;
	b += d - (days[tm_lo.tm_mon] + tm_lo.tm_mday);
	range = 2 * 24 * 3600;
      }
      if (a + b <= 1) {
	range = 2;
	a *= 24 * 3600;
	b *= 24 * 3600;
	d = tptr->tm_hour * 3600 + tptr->tm_min * 60 + tptr->tm_sec;
        a += tm_hi.tm_hour * 3600 + tm_hi.tm_min * 60 + tm_hi.tm_sec - d;
        b += d - (tm_lo.tm_hour * 3600 + tm_lo.tm_min * 60 + tm_lo.tm_sec);
a423 7
      if (a <= 0) a = 1;
      if (b <= 0) b = 1;
      d = a + b;
      guess = guess_lo / d * a + guess_hi / d * b;
      /* Although `%' may not work with negative value,
         it doesn't cause serious problem because there is a fail safe. */
      guess += ((guess_lo % d) * a + (guess_hi % d) * b) / d;
d425 1
a425 2
      fixguess:
      if (guess <= guess_lo || guess >= guess_hi) {
d437 1
d440 1
a440 14
      if (d == 0) {
	if (!utc_p && !tm->tm_isdst) {
	  /* When leaving DST, there may be two time corresponding to given
	     argument.  make_time_t returns DST in such cases. */
	  /* xxx this assumes a difference in time as 3600 seconds. */
	  time_t guess2 = guess - 3600;
	  tm = localtime(&guess2);
	  if (!tm) return guess;
	  if (tmcmp(tptr, tm) == 0)
	    return guess2;
	}
	return guess;
      }
      else if (d < 0) {
d443 1
a443 1
	if (range && range < (unsigned long)(guess_hi - guess_lo)) {
d446 2
a447 1
	  goto fixguess;
d450 1
a450 1
      else {
d453 1
a453 1
	if (range && range < (unsigned long)(guess_hi - guess_lo)) {
d456 2
a457 1
	  goto fixguess;
d460 55
d516 14
a529 13
    /* given time is not found. */
    if (guess_lo + 1 == guess_hi) {
      /* given argument is invalid: 04/29 at non-leap year for example. */
      return guess_hi;
    }
    else {
      /* given argument is in a gap.  When it enters DST, for example. */
      d = tptr->tm_sec - tm_lo.tm_sec;
      d += (tptr->tm_min - tm_lo.tm_min) * 60;
      d += (tptr->tm_hour - tm_lo.tm_hour) * 3600;
      if (d < 0)
	d += 24 * 3600;
      return guess_hi + d - 1;
@


1.39
log
@* array.c (rb_ary_and): should not push frozen key string.

* array.c (rb_ary_or): ditto.

* eval.c (rb_thread_schedule): should save context before raising
  deadlock, saved context for current thread might be obsolete.

* time.c (make_time_t): non DST timezone shift supported (hopefully).

* time.c (make_time_t): strict range detection for negative time_t.

* signal.c: SIGINFO added.

* eval.c (rb_ensure): should not SEGV when prot_tag is NULL.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:11 $
d289 21
d315 3
a317 4
    struct timeval tv;
    time_t oguess, guess;
    struct tm *tm;
    long t, diff, i;
d319 8
a326 4
    if (gettimeofday(&tv, 0) < 0) {
	rb_sys_fail("gettimeofday");
    }
    guess = tv.tv_sec;
d328 1
a328 1
    tm = gmtime(&guess);
d330 4
a333 26
    t = tptr->tm_year;
#ifndef NEGATIVE_TIME_T
    if (t < 69) goto out_of_range;
#endif
    i = 0;
    while (diff = t - tm->tm_year) {
	guess += diff * 363 * 24 * 3600;
	if (i++ > 255) goto out_of_range;
	tm = gmtime(&guess);
	if (!tm) goto error;
    }
    t = tptr->tm_mon;
    while (diff = t - tm->tm_mon) {
	guess += diff * 27 * 24 * 3600;
	tm = gmtime(&guess);
	if (!tm) goto error;
	if (tptr->tm_year != tm->tm_year) goto out_of_range;
    }
    oguess = guess;
    guess += (tptr->tm_mday - tm->tm_mday) * 24 * 3600;
    guess += (tptr->tm_hour - tm->tm_hour) * 3600;
    guess += (tptr->tm_min - tm->tm_min) * 60;
    guess += (tptr->tm_sec - tm->tm_sec);
#ifndef NEGATIVE_TIME_T
    if (guess < 0) goto out_of_range;
#endif
d335 86
a420 15
    if (!utc_p) {	/* localtime zone adjust */
	struct tm gt, lt;
	long tzsec;

	t = 0;
	tm = gmtime(&guess);
	if (!tm) goto error;
	gt = *tm;
	tm = localtime(&guess);
	if (!tm) goto error;
	lt = *tm;
	tzsec = (gt.tm_min-lt.tm_min)*60 + (gt.tm_hour-lt.tm_hour)*3600;

	if (lt.tm_year > gt.tm_year) {
	    tzsec -= 24*3600;
d422 9
a430 2
	else if(gt.tm_year > lt.tm_year) {
	    tzsec += 24*3600;
d432 8
a439 2
	else {
	    tzsec += (gt.tm_yday - lt.tm_yday)*24*3600;
d441 15
a455 29
	if (lt.tm_isdst) guess += 3600;
	guess += tzsec;
#ifndef NEGATIVE_TIME_T
	if (guess < 0) goto out_of_range;
#endif
	tm = localtime(&guess);
	if (!tm) goto error;
	if (lt.tm_isdst != tm->tm_isdst || tptr->tm_hour != tm->tm_hour) {
	    time_t tmp = guess - 3600;
	    tm = localtime(&tmp);
	    if (!tm) goto error;
	    if (tptr->tm_hour == tm->tm_hour) {
		guess = tmp;
	    }
	    else if (lt.tm_isdst == tm->tm_isdst) {
		tmp = guess + 3600;
		tm = localtime(&tmp);
		if (!tm) goto error;
		if (tptr->tm_hour == tm->tm_hour) {
		    guess = tmp;
		}
	    }
	}
	if (tptr->tm_min != tm->tm_min) {
	    guess += (tptr->tm_min - tm->tm_min) * 60;
	}
#ifndef NEGATIVE_TIME_T
	if (guess < 0) goto out_of_range;
#endif
a456 6
#ifdef NEGATIVE_TIME_T
    if (oguess > 365 * 24 * 3600 && guess < 0) goto out_of_range;
    if (guess > 365 * 24 * 3600 && oguess < 0) goto out_of_range;
#endif

    return guess;
@


1.38
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/03/26 14:29:57 $
a330 2
#else
    if (oguess > 365 * 24 * 3600 && guess < 0) goto out_of_range;
d363 2
a364 2
	    oguess = guess - 3600;
	    tm = localtime(&oguess);
d367 9
a375 1
		guess = oguess;
d378 3
d385 4
@


1.37
log
@* time.c (rb_strftime): check whether strftime returns empty string.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/03/21 03:41:41 $
d273 5
a277 2
    if (   tm->tm_year < 69
	|| tm->tm_mon  < 0 || tm->tm_mon  > 11
d290 1
a290 1
make_time_t(tptr, utc_or_local)
d292 1
a292 1
    int utc_or_local;
d297 1
a297 1
    long t, diff;
d307 1
d309 2
a311 1
	oguess = guess;
d313 1
a313 1
	if (diff > 0 && guess <= oguess) goto out_of_range;
d324 1
d329 1
d331 3
d335 1
a335 6
    if (!utc_or_local) {	/* localtime zone adjust */
#if defined(HAVE_TM_ZONE)
	tm = localtime(&guess);
	if (!tm) goto error;
	guess -= tm->tm_gmtoff;
#else
d359 3
a361 3
	if (guess < 0) {
	    goto out_of_range;
	}
d364 7
a370 2
	if (lt.tm_isdst != tm->tm_isdst) {
	    guess -= 3600;
d372 2
a374 3
	if (guess < 0) {
	    goto out_of_range;
	}
d938 3
a940 1
    fmt = rb_str2cstr(format, &len);
d1024 3
a1026 2
    buf = rb_str2cstr(str, &i);
    if (i != 8) {
@


1.36
log
@* gc.c (id2ref): sometimes confused symbol and reference.

* dir.c (glob_helper): breaks loop after calling recusive
  glob_helper; all wild cards should be consumed; no need for
  further match.

* dir.c (dir_s_glob): gives warning if no match found.

* object.c (sym_inspect): did allocate extra byte space.

* marshal.c (shortlen): shortlen should return number of bytes
  written.

* eval.c (ev_const_defined): need not to check if cbase->nd_class
  is rb_cObject.

* eval.c (ev_const_get): ditto.

* time.c (time_zone): return "UTC" for UTC time objects.

* eval.c (THREAD_ALLOC): flags should be initialized.

* signal.c (rb_f_kill): should use FIX2INT, not FIX2UINT.
@
text
@d6 1
a6 1
  $Date: 2001/02/27 07:52:11 $
d896 1
a896 1
    if (len != 0) return len;
@


1.35
log
@* time.c (time_timeval): negative time interval shoule not be
  allowed.

* eval.c (proc_call): ignore block to `call' always, despite of
  being orphan or not.
@
text
@d6 1
a6 1
  $Date: 2001/02/20 07:42:03 $
d844 3
@


1.34
log
@* configure.in: add check for negative time_t for gmtime(3).

* time.c (time_new_internal): no positive check if gmtime(3) can
  handle negative time_t.

* time.c (time_timeval): ditto.

* bignum.c (rb_big2long): should not raise RangeError for Bignum
  LONG_MIN value.
@
text
@d6 1
a6 1
  $Date: 2001/02/16 07:53:19 $
d109 5
d118 2
a119 4
#ifndef NEGATIVE_TIME_T
	if (t.tv_sec < 0)
	    rb_raise(rb_eArgError, "time must be positive");
#endif
d124 2
a125 4
#ifndef NEGATIVE_TIME_T
	if (RFLOAT(time)->value < 0.0)
	    rb_raise(rb_eArgError, "time must be positive");
#endif
d132 2
a133 4
#ifndef NEGATIVE_TIME_T
	if (t.tv_sec < 0)
	    rb_raise(rb_eArgError, "time must be positive");
#endif
d138 2
a139 3
	rb_raise(rb_eTypeError, "can't convert %s into Time%s",
		 rb_class2name(CLASS_OF(time)),
		 interval ? " interval" : "");
@


1.33
log
@* io.c (set_outfile): f should be the FILE* from the assigning value.

* ext/socket/socket.c (tcp_s_open): should not give default value
  to local_host.

* time.c (time_s_times): move to Process::times.

* file.c (rb_file_s_lchmod): new method File::lchmod.

* file.c (rb_file_s_lchown): new method File::lchown.
@
text
@d6 1
a6 1
  $Date: 2001/02/14 05:51:58 $
d83 1
d86 1
d113 1
d116 1
d121 1
d124 1
d131 1
d134 1
@


1.32
log
@* dir.c (dir_s_glob): supprt backslash escape of metacharacters
  and delimiters.

* dir.c (remove_backslases): remove backslashes from path before
  calling stat(2).

* dir.c (dir_s_glob): call rb_yield directly (via push_pattern) if
  block is given to the method.

* dir.c (push_pattern): do not call rb_ary_push; yield directly.

* eval.c (blk_copy_prev): reduced ALLOC_N too much.

* eval.c (frame_dup): ditto.
@
text
@d6 1
a6 1
  $Date: 2000/12/22 03:22:05 $
a28 4
#ifdef HAVE_SYS_TIMES_H
#include <sys/times.h>
#endif

a33 3
#if defined(HAVE_TIMES) || defined(NT)
static VALUE S_Tms;
#endif
d949 2
a950 19
#if defined(HAVE_TIMES) && !defined(__CHECKER__)
#ifndef HZ
# ifdef CLK_TCK
#   define HZ CLK_TCK
# else
#   define HZ 60
# endif
#endif /* HZ */
    struct tms buf;

    if (times(&buf) == -1) rb_sys_fail(0);
    return rb_struct_new(S_Tms,
			 rb_float_new((double)buf.tms_utime / HZ),
			 rb_float_new((double)buf.tms_stime / HZ),
			 rb_float_new((double)buf.tms_cutime / HZ),
			 rb_float_new((double)buf.tms_cstime / HZ));
#else
    rb_notimplement();
#endif
a1090 4

#if defined(HAVE_TIMES) || defined(NT)
    S_Tms = rb_struct_define("Tms", "utime", "stime", "cutime", "cstime", 0);
#endif
@


1.31
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/18 09:46:06 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.31.2.1
log
@* time.c (rb_strftime): check whether strftime returns empty string.
@
text
@d6 1
a6 1
  $Date: 2000/12/22 03:22:05 $
d894 1
a894 1
    if (len != 0 || **buf == '\0') return len;
@


1.31.2.2
log
@* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* class.c (rb_include_module): module inclusion should be check
  taints.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/03/26 14:29:44 $
d327 5
d360 1
a360 1
	if (tptr->tm_hour != tm->tm_hour) {
d363 1
@


1.31.2.3
log
@* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE SUMMER TIME!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/04/03 05:43:49 $
d355 2
a356 7
	if (lt.tm_isdst != tm->tm_isdst || tptr->tm_hour != tm->tm_hour) {
	    oguess = guess - 3600;
	    tm = localtime(&oguess);
	    if (!tm) goto error;
	    if (tptr->tm_hour == tm->tm_hour) {
		guess = oguess;
	    }
@


1.31.2.4
log
@* array.c (rb_ary_and): should not push frozen key string.

* array.c (rb_ary_or): ditto.

* eval.c (rb_thread_schedule): should save context before raising
  deadlock, saved context for current thread might be obsolete.

* time.c (make_time_t): non DST timezone shift supported (hopefully).

* signal.c: SIGINFO added.

* eval.c (rb_ensure): should not SEGV when prot_tag is NULL.
@
text
@d6 1
a6 1
  $Date: 2001/04/06 05:42:40 $
d356 2
a357 2
	    time_t tmp = guess - 3600;
	    tm = localtime(&tmp);
d360 1
a360 9
		guess = tmp;
	    }
	    else if (lt.tm_isdst == tm->tm_isdst) {
		tmp = guess + 3600;
		tm = localtime(&tmp);
		if (!tm) goto error;
		if (tptr->tm_hour == tm->tm_hour) {
		    guess = tmp;
		}
@


1.31.2.5
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.
@
text
@d6 1
a6 1
  $Date: 2001/05/15 08:49:21 $
d567 2
a568 3
    if (tobj->tm_got) {
	if (!tobj->gmt) return time;
	time_modify(time);
d570 1
d588 2
a589 3
    if (tobj->tm_got) {
	if (tobj->gmt) return time;
	time_modify(time);
d591 1
@


1.31.2.6
log
@* time.c (time_new_internal): round usec overflow and underflow
  here.

* time.c (time_plus): remove overflow/underflow check.

* time.c (time_minus): ditto.

* time.c (time_cmp): should consider tv_usec too.

* time.c (time_gmtime): time_modify() should be called even if tm
  struct is not calculated yet.

* string.c (rb_str_equal): object with to_str must be treated as a
  string.
@
text
@d6 1
a6 1
  $Date: 2001/10/29 05:04:41 $
a89 8
    if (usec >= 1000000) {	/* usec overflow */
	sec += usec / 1000000;
	usec %= 1000000;
    }
    if (usec < 0) {		/* usec underflow */
	sec -= (-usec) / 1000000;
	usec %= 1000000;
    }
d462 1
a462 7
	if (tobj1->tv.tv_sec == i) {
	    if (tobj1->tv.tv_usec == 0)
		return INT2FIX(0);
	    if (tobj1->tv.tv_usec > 0)
		return INT2FIX(1);
	    return INT2FIX(-1);
	}
d567 2
a568 5
    if (!tobj->gmt) {
	if (tobj->tm_got)
	    return time;
    }
    else {
d588 2
a589 5
    if (tobj->gmt) {
	if (tobj->tm_got)
	    return time;
    }
    else {
d665 8
d706 8
@


1.31.2.7
log
@* io.c (io_fread): EAGAIN/EWOULDBLOCK should not terminate and
  throw away the input.

* time.c (time_new_internal): underflow adjustment must not use
  negative div/mod.

* time.c (time_cmp): should consider tv_usec on non Fixnum number
  comparison.
@
text
@d6 1
a6 1
  $Date: 2001/12/03 10:06:39 $
d94 3
a96 3
    while (usec < 0) {		/* usec underflow */
	sec--;
	usec += 1000000;
d504 1
a504 7
    if (tobj1->tv.tv_sec == i) {
	if (tobj1->tv.tv_usec == 0)
	    return INT2FIX(0);
	if (tobj1->tv.tv_usec > 0)
	    return INT2FIX(1);
	return INT2FIX(-1);
    }
d917 1
a917 1
	if (len > 0 || size >= 1024 * flen) return len;
d953 1
a953 4
	    if (buf != buffer) {
		free(buf);
		buf = buffer;
	    }
@


1.31.2.8
log
@* time.c (time_cmp): should handle Bignums.
@
text
@d6 1
a6 1
  $Date: 2001/12/04 04:53:31 $
a501 8
    }
    if (TYPE(time2) == T_BIGNUM) {
	double a = (double)tobj1->tv.tv_sec+(double)tobj1->tv.tv_usec/1e6;
	double b = rb_big2dbl(time2);

	if (a == b) return INT2FIX(0);
	if (a > b) return INT2FIX(1);
	if (a < b) return INT2FIX(-1);
@


1.31.2.9
log
@* time.c (time_utc_offset): new function.

* time.c (Init_Time): new method gmtoff, gmt_offset and utc_offset.

* lib/time.rb: new file.
@
text
@a880 42
time_utc_offset(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
        time_get_tm(time, tobj->gmt);
    }

    if (tobj->gmt == 1) {
        return INT2FIX(0);
    }
    else {
#if defined(HAVE_STRUCT_TM_TM_GMTOFF)
        return INT2NUM(tobj->tm.tm_gmtoff);
#else
        struct tm *u, *l;
        time_t t;
        int off;
        l = &tobj->tm;
        t = tobj->tv.tv_sec;
        u = gmtime(&t);
        if (!u)
            rb_raise(rb_eArgError, "gmtime error");
        if (l->tm_year != u->tm_year)
            off = l->tm_year < u->tm_year ? -1 : 1;
        else if (l->tm_mon != u->tm_mon)
            off = l->tm_mon < u->tm_mon ? -1 : 1;
        else if (l->tm_mday != u->tm_mday)
            off = l->tm_mday < u->tm_mday ? -1 : 1;
        else
            off = 0;
        off = off * 24 + l->tm_hour - u->tm_hour;
        off = off * 60 + l->tm_min - u->tm_min;
        off = off * 60 + l->tm_sec - u->tm_sec;
        return INT2FIX(off);
#endif
    }
}

static VALUE
a1133 3
    rb_define_method(rb_cTime, "gmtoff", time_utc_offset, 0);
    rb_define_method(rb_cTime, "gmt_offset", time_utc_offset, 0);
    rb_define_method(rb_cTime, "utc_offset", time_utc_offset, 0);
@


1.31.2.10
log
@* eval.c (rb_undef): undef should be done for klass, not ruby_class.

* eval.c (error_handle): should handle TAG_THROW as well.
@
text
@d5 2
a6 2
  $Author: akr $
  $Date: 2001/12/30 09:10:28 $
d238 1
a238 1
	tm->tm_isdst = RTEST(argv[8]) ? 1 : 0;
d242 1
a242 2
	*usec = NIL_P(v[6]) ? 0 : obj2long(v[6]);
	tm->tm_isdst = -1;
@


1.30
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/12 07:42:35 $
d699 4
@


1.29
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/08 05:29:25 $
d661 4
@


1.28
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/17 18:13:59 $
d472 1
a472 1
    if (rb_obj_is_instance_of(time2, rb_cTime)) {
d495 1
a495 1
    if (rb_obj_is_instance_of(time2, rb_cTime)) {
d679 1
a679 1
    if (rb_obj_is_instance_of(time2, rb_cTime)) {
d948 1
a948 1
#ifdef HAVE_TIMES
@


1.27
log
@1.6.2 (to be)
@
text
@d6 1
a6 1
  $Date: 2000/09/07 06:59:37 $
a330 5
	tm = localtime(&guess);
	if (!tm) goto error;
	if (tm->tm_hour != tptr->tm_hour) {
	    guess += (tptr->tm_hour - tm->tm_hour)*3600;
	}
@


1.26
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/31 05:29:54 $
d1101 1
@


1.25
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/24 06:21:35 $
a635 1
#ifndef HAVE_TM_ZONE
d637 1
a637 1
	len = strftime(buf, 128, "%a %b %d %H:%M:%S GMT %Y", &tobj->tm);
d639 1
a639 3
    else
#endif
    {
@


1.24
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/15 06:22:43 $
d108 2
a109 2
struct timeval
rb_time_interval(time)
d111 1
d138 3
a140 2
	rb_raise(rb_eTypeError, "can't convert %s into Time interval",
		 rb_class2name(CLASS_OF(time)));
d147 7
d165 1
a165 1
    return rb_time_interval(time);
@


1.23
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/07 03:20:53 $
d949 5
a953 1
#define HZ 60 /* Universal constant :-) */
@


1.22
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/06 07:21:14 $
a959 12
#ifdef NT
    FILETIME create, exit, kernel, user;
    HANDLE hProc;

    hProc = GetCurrentProcess();
    GetProcessTimes(hProc,&create, &exit, &kernel, &user);
    return rb_struct_new(S_Tms,
      rb_float_new((double)(kernel.dwHighDateTime*2e32+kernel.dwLowDateTime)/2e6),
      rb_float_new((double)(user.dwHighDateTime*2e32+user.dwLowDateTime)/2e6),
      rb_float_new((double)0),
      rb_float_new((double)0));
#else
a960 1
#endif
@


1.21
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/22 08:29:47 $
d538 9
d559 1
d580 1
@


1.20
log
@2000-06-22
@
text
@d6 1
a6 1
  $Date: 2000/06/19 08:38:11 $
d203 1
a203 1
time_arg(argc, argv, tm)
d207 1
d209 1
a209 1
    VALUE v[6];
d220 1
d224 2
a225 1
	rb_scan_args(argc, argv, "15", &v[0],&v[1],&v[2],&v[3],&v[4],&v[5]);
d376 1
a376 1
time_utc_or_local(argc, argv, utc_or_local, klass)
d379 1
a379 1
    int utc_or_local;
d384 1
d386 3
a388 3
    time_arg(argc, argv, &tm);
    time = time_new_internal(klass, make_time_t(&tm, utc_or_local), 0);
    if (utc_or_local) return time_gmtime(time);
d427 1
a427 1
    return rb_float_new((double)tobj->tv.tv_sec+(double)tobj->tv.tv_usec/1000000);
d1072 1
@


1.19
log
@2000-06-19
@
text
@d6 1
a6 1
  $Date: 2000/06/16 07:44:06 $
d319 5
a345 1

a350 1
#endif
d353 1
a353 1
	if (tm->tm_hour != tptr->tm_hour) {
d356 1
@


1.18
log
@2000-06-16
@
text
@d6 1
a6 1
  $Date: 2000/06/14 05:50:32 $
d493 1
a493 1
time_gmt_p(time)
d539 3
d559 3
d1086 2
a1087 1
    rb_define_method(rb_cTime, "gmt?", time_gmt_p, 0);
@


1.17
log
@2000-06-14
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/06/14 05:11:55 $
d317 1
d324 6
a329 2
	gt = *gmtime(&guess);
	lt = *localtime(&guess);
d332 1
a332 1
	if(lt.tm_year > gt.tm_year) {
d342 1
a342 2
	if (lt.tm_isdst) tzsec += 3600;
    
d347 1
a352 1
#endif
@


1.16
log
@2000-06-14
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/06/13 02:48:49 $
d317 1
a317 1
	guess += tm->tm_gmtoff;
@


1.15
log
@subtle daylight bug
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/06/12 14:46:44 $
a273 5

#if defined(HAVE_DAYLIGHT) && !defined(__MINGW32__)
extern int daylight;
extern long timezone;
#endif
@


1.14
log
@2000-06-12
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/06/12 07:48:23 $
d275 1
a275 1
#if defined(HAVE_DAYLIGHT) && !defined __MINGW32__
d320 3
a322 3
#if defined(HAVE_DAYLIGHT)
	localtime(&guess);
	guess += timezone + daylight;
d812 3
a814 1
#if defined HAVE_TZNAME && defined HAVE_DAYLIGHT
@


1.13
log
@2000-06-12
@
text
@d6 1
a6 1
  $Date: 2000/05/12 09:07:46 $
d275 5
a320 3
	extern int daylight;
	extern long timezone;

d812 2
a813 2
#ifdef HAVE_TZNAME
    return rb_str_new2(tobj->tm.tm_zone);
@


1.12
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:30 $
d211 1
d219 1
d276 1
a276 1
make_time_t(tptr, fn)
d278 1
a278 1
    struct tm *(*fn)();
d290 1
a290 1
    tm = (*fn)(&guess);
d296 1
a296 1
	guess += diff * 364 * 24 * 3600;
d298 1
a298 1
	tm = (*fn)(&guess);
d304 1
a304 1
	tm = (*fn)(&guess);
d308 1
a308 1
    guess += (tptr->tm_mday - tm->tm_mday) * 3600 * 24;
d314 43
d368 1
a368 1
time_gm_or_local(argc, argv, gm_or_local, klass)
d371 1
a371 1
    int gm_or_local;
a374 1
    struct tm *(*fn)();
a376 1
    fn = (gm_or_local) ? gmtime : localtime;
d378 2
a379 3

    time = time_new_internal(klass, make_time_t(&tm, fn), 0);
    if (gm_or_local) return time_gmtime(time);
d384 1
a384 1
time_s_timegm(argc, argv, klass)
d389 1
a389 1
    return time_gm_or_local(argc, argv, 1, klass);
d393 1
a393 1
time_s_timelocal(argc, argv, klass)
d398 1
a398 1
    return time_gm_or_local(argc, argv, 0, klass);
d810 3
d815 1
d1039 4
a1042 3
    rb_define_singleton_method(rb_cTime, "gm", time_s_timegm, -1);
    rb_define_singleton_method(rb_cTime, "local", time_s_timelocal, -1);
    rb_define_singleton_method(rb_cTime, "mktime", time_s_timelocal, -1);
@


1.11
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/03/07 08:37:49 $
a79 6
}

static VALUE
time_initialize()
{
    return Qnil;
@


1.10
log
@2000-03-07
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/02/29 08:05:28 $
d11 1
a11 1
************************************************/
@


1.9
log
@2000-02-29
@
text
@d6 1
a6 1
  $Date: 2000/02/17 07:11:18 $
a32 6
#ifdef USE_CWGUSI
#define time_t long
int gettimeofday(struct timeval*, struct timezone*);
int strcasecmp(char*, char*);
#endif

a95 1
#ifndef USE_CWGUSI
d98 1
a98 1
#endif
@


1.8
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:12:14 $
d77 18
d1004 1
a1004 1
    rb_define_singleton_method(rb_cTime, "new", time_s_now, 0);
@


1.7
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:37:13 $
d397 1
a397 1
	return FIX2INT(-1);
d417 1
a417 1
	    return FIX2INT(-1);
d420 1
a420 1
	return FIX2INT(-1);
d425 1
a425 1
    return FIX2INT(-1);
@


1.6
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/10/29 09:25:32 $
a402 2
	    if (tobj1->tv.tv_sec == (time_t)RFLOAT(time2)->value)
		return INT2FIX(0);
d404 1
a404 3
	    if (tobj1->tv.tv_sec == (time_t)RFLOAT(time2)->value)
		return INT2FIX(0);
	    if (tobj1->tv.tv_sec > (time_t)RFLOAT(time2)->value)
d406 3
a408 1
	    return FIX2INT(-1);
@


1.5
log
@19991029
@
text
@d6 1
a6 1
  $Date: 1999/10/04 04:51:06 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d191 1
a191 1
	obj = rb_str2inum(RSTRING(obj)->ptr, 10);
d473 2
a474 2
    VALUE obj;
    struct time_object *tobj, *newtobj;
d477 3
a479 3
    obj = Data_Make_Struct(0, struct time_object, 0, free, newtobj);
    CLONESETUP(obj, time);
    MEMCPY(newtobj, tobj, struct time_object, 1);
d481 1
a481 1
    return obj;
d841 1
a841 1
    fmt = str2cstr(format, &len);
d951 1
a951 1
    buf = str2cstr(str, &i);
@


1.4
log
@19991004
@
text
@d6 1
a6 1
  $Date: 1999/09/16 09:40:33 $
d155 4
a158 2
time_s_at(klass, time)
    VALUE klass, time;
d161 1
a161 1
    VALUE t;
d163 7
a169 1
    tv = rb_time_timeval(time);
d989 1
a989 1
    rb_define_singleton_method(rb_cTime, "at", time_s_at, 1);
@


1.4.2.1
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 1999/10/04 04:51:06 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.4.2.2
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:24:13 $
d389 1
a389 1
	return INT2FIX(-1);
d402 1
a402 1
	    return INT2FIX(-1);
d411 1
a411 1
	    return INT2FIX(-1);
d414 1
a414 1
	return INT2FIX(-1);
d419 1
a419 1
    return INT2FIX(-1);
@


1.4.2.3
log
@2000-06-13
@
text
@d6 1
a6 1
  $Date: 2000/02/17 08:29:04 $
a197 1
    MEMZERO(tm, struct tm, 1);
a204 1
	tm->tm_isdst = RTEST(argv[9]) ? 1 : 0;
d261 1
a261 1
make_time_t(tptr, utc_or_local)
d263 1
a263 1
    int utc_or_local;
d275 1
a275 1
    tm = gmtime(&guess);
d281 1
a281 1
	guess += diff * 363 * 24 * 3600;
d283 1
a283 1
	tm = gmtime(&guess);
d289 1
a289 1
	tm = gmtime(&guess);
a297 43

    if (!utc_or_local) {	/* localtime zone adjust */
#if defined(HAVE_DAYLIGHT)
	extern int daylight;
	extern long timezone;

	localtime(&guess);
	guess += timezone + daylight;
#else
	struct tm gt, lt;
	long tzsec;

	t = 0;
	gt = *gmtime(&guess);
	lt = *localtime(&guess);
	tzsec = (gt.tm_min-lt.tm_min)*60 + (gt.tm_hour-lt.tm_hour)*3600;

	if(lt.tm_year > gt.tm_year) {
	    tzsec -= 24*3600;
	}
	else if(gt.tm_year > lt.tm_year) {
	    tzsec += 24*3600;
	}
	else {
	    tzsec += (gt.tm_yday - lt.tm_yday)*24*3600;
	}

	if (lt.tm_isdst) tzsec += 3600;
    
	guess += tzsec;
	if (guess < 0) {
	    goto out_of_range;
	}
	tm = localtime(&guess);
	if (!tm) goto error;
	if (tm->tm_hour != tptr->tm_hour) {
	    guess -= 3600;
	}
#endif
	if (guess < 0) {
	    goto out_of_range;
	}
    }
@


1.4.2.4
log
@2000-06-20
@
text
@d6 1
a6 1
  $Date: 2000/06/13 09:50:49 $
d295 1
a295 1
    guess += (tptr->tm_mday - tm->tm_mday) * 24 * 3600;
d302 6
a307 3
#if defined(HAVE_TM_ZONE)
	tm = localtime(&guess);
	guess -= tm->tm_gmtoff;
a801 5
#if defined(HAVE_TM_ZONE)
    return rb_str_new2(tobj->tm.tm_zone);
#elif defined(HAVE_TZNAME) && defined(HAVE_DAYLIGHT)
    return rb_str_new2(tzname[daylight && tobj->tm.tm_isdst]);
#else
a803 1
#endif
@


1.4.2.5
log
@2000-06-24
@
text
@d6 1
a6 1
  $Date: 2000/06/20 06:08:41 $
a303 1
	if (!tm) goto error;
a304 5
	tm = localtime(&guess);
	if (!tm) goto error;
	if (tm->tm_hour != tptr->tm_hour) {
	    guess += (tptr->tm_hour - tm->tm_hour)*3600;
	}
d310 2
a311 6
	tm = gmtime(&guess);
	if (!tm) goto error;
	gt = *tm;
	tm = localtime(&guess);
	if (!tm) goto error;
	lt = *tm;
d314 1
a314 1
	if (lt.tm_year > gt.tm_year) {
d323 3
a325 1
	if (lt.tm_isdst) guess += 3600;
d332 1
a332 1
	if (lt.tm_isdst != tm->tm_isdst) {
d365 1
a365 1
    time = time_new_internal(klass, make_time_t(&tm, gm_or_local), 0);
d437 2
d440 3
a442 1
	    if (t > RFLOAT(time2)->value)
d444 1
a444 3
	    if (t < RFLOAT(time2)->value)
		return INT2FIX(-1);
	    return INT2FIX(0);
d507 2
a508 2
    VALUE clone;
    struct time_object *tobj, *tclone;
d511 3
a513 3
    clone = Data_Make_Struct(0, struct time_object, 0, free, tclone);
    CLONESETUP(clone, time);
    MEMCPY(tclone, tobj, struct time_object, 1);
d515 1
a515 1
    return clone;
a526 3
    if (tobj->tm_got && !tobj->gmt) {
	return time;
    }
a543 3
    if (tobj->tm_got && tobj->gmt) {
	return time;
    }
@


1.3
log
@1.4.1
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:15 $
d211 1
a211 1
    if (0 < tm->tm_year && tm->tm_year < 69) tm->tm_year += 100;
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/07/22 10:37:23 $
d211 2
a212 2
    if (tm->tm_year < 69) tm->tm_year += 100;
    if (tm->tm_year >= 1000) tm->tm_year -= 1900;
d266 1
a266 1
    time_t guess, t;
d268 1
a268 1
    long diff;
d279 2
a280 1
    while (diff = t - (tm->tm_year)) {
d282 1
a282 1
	if (diff > 0 && guess < 0) goto out_of_range;
d296 1
a296 1
    guess +=  tptr->tm_sec - tm->tm_sec;
d306 1
a306 1
    return Qnil;		/* not reached */
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1996/12/25 09:30:28 $
d9 1
a9 1
  Copyright (C) 1993-1996 Yukihiro Matsumoto
a15 4
#ifdef HAVE_STRING_H
# include <string.h>
#endif

d21 1
d23 2
a24 2
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
a31 1
#include <math.h>
d33 11
a43 1
static VALUE cTime;
a46 1
extern VALUE mComparable;
a50 1
#ifndef HAVE_TM_ZONE
a51 1
#endif
d60 2
a61 2
time_s_now(class)
    VALUE class;
d66 1
a66 1
    obj = Data_Make_Struct(class, struct time_object, 0, 0, tobj);
d69 1
a69 1
    if (gettimeofday(&(tobj->tv), 0) == -1) {
d77 3
a79 3
time_new_internal(class, sec, usec)
    VALUE class;
    int sec, usec;
d84 5
a88 1
    obj = Data_Make_Struct(class, struct time_object, 0, 0, tobj);
d97 2
a98 2
time_new(sec, usec)
    int sec, usec;
d100 1
a100 1
    return time_new_internal(cTime, sec, usec);
d104 1
a104 1
time_timeval(time)
a106 1
    struct time_object *tobj;
d111 1
a111 1
	t.tv_sec = FIX2UINT(time);
d113 1
a113 1
	    ArgError("time must be positive");
d118 4
a121 10
	{
	    double seconds, microseconds;

	    if (RFLOAT(time)->value < 0.0)
		ArgError("time must be positive");
	    seconds = floor(RFLOAT(time)->value);
	    microseconds = (RFLOAT(time)->value - seconds) * 1000000.0;
	    t.tv_sec = seconds;
	    t.tv_usec = microseconds;
	}
d125 3
a127 1
	t.tv_sec = NUM2INT(time);
d132 15
a146 4
	if (!obj_is_kind_of(time, cTime)) {
	    TypeError("Can't convert %s into Time",
		      rb_class2name(CLASS_OF(time)));
	}
d149 1
a149 1
	break;
d151 1
a151 1
    return t;
d155 2
a156 2
time_s_at(class, time)
    VALUE class, time;
d159 1
d161 10
a170 2
    tv = time_timeval(time);
    return time_new_internal(class, tv.tv_sec, tv.tv_usec);
d178 11
d190 1
a190 1
time_arg(argc, argv, args)
d193 1
a193 1
    int *args;
d198 11
a208 1
    rb_scan_args(argc, argv, "15", &v[0], &v[1], &v[2], &v[3], &v[4], &v[5]);
d210 5
a214 5
    args[0] = NUM2INT(v[0]);
    if (args[0] < 70) args[0] += 100;
    if (args[0] > 1900) args[0] -= 1900;
    if (v[1] == Qnil) {
	args[1] = 0;
d217 1
a217 1
	args[1] = -1;
d219 3
a221 2
	    if (strcasecmp(months[i], RSTRING(v[1])->ptr) == 0) {
		args[1] = i;
d225 1
a225 1
	if (args[1] == -1) {
d229 1
a229 1
		args[1] = NUM2INT(v[1])-1;
d234 1
a234 1
	args[1] = NUM2INT(v[1]);
d236 2
a237 2
    if (v[2] == Qnil) {
	args[2] = 1;
d240 1
a240 9
	args[2] = NUM2INT(v[2]);
    }
    for (i=3;i<6;i++) {
	if (v[i] == Qnil) {
	    args[i] = 0;
	}
	else {
	    args[i] = NUM2INT(v[i]);
	}
d242 3
d247 17
a263 15
    if (   args[0] < 70|| args[1] > 137
	|| args[1] < 0 || args[1] > 11
	|| args[2] < 1 || args[2] > 31
	|| args[3] < 0 || args[3] > 23
	|| args[4] < 0 || args[4] > 60
	|| args[5] < 0 || args[5] > 61)
	ArgError("argument out of range");
}

static VALUE
time_gm_or_local(argc, argv, gm_or_local, class)
    int argc;
    VALUE *argv;
    int gm_or_local;
    VALUE class;
a264 1
    int args[6];
d266 1
d268 1
a268 3
    time_t guess, t;
    int diff;
    struct tm *(*fn)();
d270 3
a272 4
    fn = (gm_or_local) ? gmtime : localtime;
    time_arg(argc, argv, args);

    gettimeofday(&tv, 0);
d277 3
a279 2
    t = args[0];
    while (diff = t - tm->tm_year) {
d281 1
a281 1
	if (guess < 0) ArgError("too far future");
d285 1
a285 1
    t = args[1];
d290 1
d292 7
a298 4
    guess += (args[2] - tm->tm_mday) * 3600 * 24;
    guess += (args[3] - tm->tm_hour) * 3600;
    guess += (args[4] - tm->tm_min) * 60;
    guess += args[5] - tm->tm_sec;
d300 2
a301 1
    return time_new_internal(class, guess, 0);
d304 2
a305 1
    ArgError("gmtime error");
d309 1
a309 1
time_s_timegm(argc, argv, class)
d312 2
a313 1
    VALUE class;
d315 10
a324 1
    return time_gm_or_local(argc, argv, 1, class);
d328 1
a328 1
time_s_timelocal(argc, argv, class)
d331 1
a331 1
    VALUE class;
d333 10
a342 1
    return time_gm_or_local(argc, argv, 0, class);
d352 1
a352 1
    return int2inum(tobj->tv.tv_sec);
d362 1
a362 1
    return float_new((double)tobj->tv.tv_sec+(double)tobj->tv.tv_usec/1000000);
d372 1
a372 1
    return INT2FIX(tobj->tv.tv_usec);
d380 1
a380 1
    int i;
d385 1
a385 1
	i = FIX2INT(time2);
d394 2
a395 1
	    if (tobj1->tv.tv_sec == (int)RFLOAT(time2)->value) return INT2FIX(0);
d397 4
a400 2
	    if (tobj1->tv.tv_sec == RFLOAT(time2)->value) return INT2FIX(0);
	    if (tobj1->tv.tv_sec > RFLOAT(time2)->value) return INT2FIX(1);
d405 1
a405 1
    if (obj_is_instance_of(time2, cTime)) {
d415 1
a415 1
    i = NUM2INT(time2);
d428 1
a428 1
    if (obj_is_instance_of(time2, cTime)) {
d431 1
a431 1
	    if (tobj1->tv.tv_usec == tobj2->tv.tv_usec) return TRUE;
d434 12
a445 1
    return FALSE;
d453 1
a453 1
    int hash;
d461 15
d481 1
d484 2
a485 1
    tm_tmp = localtime((const time_t*)&tobj->tv.tv_sec);
a487 1
#ifndef HAVE_TM_ZONE
a488 1
#endif
d498 1
d501 2
a502 1
    tm_tmp = gmtime((const time_t*)&tobj->tv.tv_sec);
a504 1
#ifndef HAVE_TM_ZONE
a505 1
#endif
d510 9
d523 18
a540 1
    char buf[64];
d545 1
a545 1
	time_localtime(time);
d549 1
a549 1
	len = strftime(buf, 64, "%a %b %d %H:%M:%S GMT %Y", &(tobj->tm));
d554 1
a554 1
	len = strftime(buf, 64, "%a %b %d %H:%M:%S %Z %Y", &(tobj->tm));
d556 1
a556 1
    return str_new(buf, len);
d560 1
a560 1
time_coerce(time1, time2)
d563 3
a565 9
    if (TYPE(time2) == T_FLOAT) {
	double d = RFLOAT(time2)->value;
	unsigned int i = (unsigned int) d;

	return assoc_new(time_new(i, (int)((d - (double)i)*1e6)),time1);
    }

    return assoc_new(time_new(NUM2INT(time2), 0), time1);
}
d567 1
a567 6
static VALUE
time_plus(time1, time2)
    VALUE time1, time2;
{
    struct time_object *tobj1, *tobj2;
    int sec, usec;
d569 2
a570 14
    GetTimeval(time1, tobj1);
    if (TYPE(time2) == T_FLOAT) {
	unsigned int nsec = (unsigned int)RFLOAT(time2)->value;
	sec = tobj1->tv.tv_sec + nsec;
	usec = tobj1->tv.tv_usec + (RFLOAT(time2)->value - (double)nsec)*1e6;
    }
    else if (obj_is_instance_of(time2, cTime)) {
	GetTimeval(time2, tobj2);
	sec = tobj1->tv.tv_sec + tobj2->tv.tv_sec;
	usec = tobj1->tv.tv_usec + tobj2->tv.tv_usec;
    }
    else {
	sec = tobj1->tv.tv_sec + NUM2INT(time2);
	usec = tobj1->tv.tv_usec;
d572 4
d581 6
a586 1
    return time_new(sec, usec);
d593 3
a595 2
    struct time_object *tobj1, *tobj2;
    int sec, usec;
d597 3
a599 3
    GetTimeval(time1, tobj1);
    if (obj_is_instance_of(time2, cTime)) {
	double f;
d602 2
a603 1
	f = tobj1->tv.tv_sec - tobj2->tv.tv_sec;
d605 1
a605 7
	f += (tobj1->tv.tv_usec - tobj2->tv.tv_usec)*1e-6;

	return float_new(f);
    }
    else if (TYPE(time2) == T_FLOAT) {
	sec = tobj1->tv.tv_sec - (int)RFLOAT(time2)->value;
	usec = tobj1->tv.tv_usec - (RFLOAT(time2)->value - (double)sec)*1e6;
d608 4
a611 2
	sec = tobj1->tv.tv_sec - NUM2INT(time2);
	usec = tobj1->tv.tv_usec;
d618 6
a623 1
    return time_new(sec, usec);
d634 1
a634 1
	time_localtime(time);
d647 1
a647 1
	time_localtime(time);
d660 1
a660 1
	time_localtime(time);
d673 1
a673 1
	time_localtime(time);
d686 1
a686 1
	time_localtime(time);
d688 1
a688 1
    return INT2FIX(tobj->tm.tm_mon);
d699 1
a699 1
	time_localtime(time);
d701 1
a701 1
    return INT2FIX(tobj->tm.tm_year);
d712 1
a712 1
	time_localtime(time);
d725 1
a725 1
	time_localtime(time);
d727 1
a727 1
    return INT2FIX(tobj->tm.tm_yday);
d738 1
a738 1
	time_localtime(time);
d740 1
a740 1
    return INT2FIX(tobj->tm.tm_isdst);
d748 1
a748 1
    char buf[10];
d753 1
a753 1
	time_localtime(time);
d756 2
a757 2
    len = strftime(buf, 10, "%Z", &(tobj->tm));
    return str_new(buf, len);
a764 1
    VALUE ary;
d768 45
a812 1
	time_localtime(time);
d814 1
a814 11
    ary = ary_new3(9,
		   INT2FIX(tobj->tm.tm_sec),
		   INT2FIX(tobj->tm.tm_min),
		   INT2FIX(tobj->tm.tm_hour),
		   INT2FIX(tobj->tm.tm_mday),
		   INT2FIX(tobj->tm.tm_mon),
		   INT2FIX(tobj->tm.tm_year),
		   INT2FIX(tobj->tm.tm_wday),
		   INT2FIX(tobj->tm.tm_yday),
		   INT2FIX(tobj->tm.tm_isdst));
    return ary;
d822 3
a824 1
    char buf[100];
d826 1
a827 1
    Check_Type(format, T_STRING);
d830 5
a834 1
	time_localtime(time);
d836 3
a838 5
    if (strlen(RSTRING(format)->ptr) < RSTRING(format)->len) {
	/* Ruby string contains \0. */
	VALUE str;
	int l;
	char *p = RSTRING(format)->ptr, *pe = p + RSTRING(format)->len;
d840 1
a840 1
	str = str_new(0, 0);
d842 6
a847 4
	    len = strftime(buf, 100, p, &(tobj->tm));
	    str_cat(str, buf, len);
	    l = strlen(p);
	    p += l + 1;
d851 4
a854 2
    len = strftime(buf, 100, RSTRING(format)->ptr, &(tobj->tm));
    return str_new(buf, len);
d868 5
a872 5
    return struct_new(S_Tms,
		      float_new((double)buf.tms_utime / HZ),
		      float_new((double)buf.tms_stime / HZ),
		      float_new((double)buf.tms_cutime / HZ),
		      float_new((double)buf.tms_cstime / HZ));
d880 5
a884 5
    return struct_new(S_Tms,
      float_new((double)(kernel.dwHighDateTime*2e32+kernel.dwLowDateTime)/2e6),
      float_new((double)(user.dwHighDateTime*2e32+user.dwLowDateTime)/2e6),
      float_new((double)0),
      float_new((double)0));
d891 81
d975 2
a976 2
    cTime = rb_define_class("Time", cObject);
    rb_include_module(cTime, mComparable);
d978 45
a1022 41
    rb_define_singleton_method(cTime, "now", time_s_now, 0);
    rb_define_singleton_method(cTime, "new", time_s_now, 0);
    rb_define_singleton_method(cTime, "at", time_s_at, 1);
    rb_define_singleton_method(cTime, "gm", time_s_timegm, -1);
    rb_define_singleton_method(cTime, "local", time_s_timelocal, -1);
    rb_define_singleton_method(cTime, "mktime", time_s_timelocal, -1);

    rb_define_singleton_method(cTime, "times", time_s_times, 0);

    rb_define_method(cTime, "to_i", time_to_i, 0);
    rb_define_method(cTime, "to_f", time_to_f, 0);
    rb_define_method(cTime, "<=>", time_cmp, 1);
    rb_define_method(cTime, "eql?", time_eql, 0);
    rb_define_method(cTime, "hash", time_hash, 0);

    rb_define_method(cTime, "localtime", time_localtime, 0);
    rb_define_method(cTime, "gmtime", time_gmtime, 0);
    rb_define_method(cTime, "ctime", time_asctime, 0);
    rb_define_method(cTime, "asctime", time_asctime, 0);
    rb_define_method(cTime, "to_s", time_asctime, 0);
    rb_define_method(cTime, "inspect", time_asctime, 0);
    rb_define_method(cTime, "to_a", time_to_a, 0);
    rb_define_method(cTime, "coerce", time_coerce, 1);

    rb_define_method(cTime, "+", time_plus, 1);
    rb_define_method(cTime, "-", time_minus, 1);

    rb_define_method(cTime, "sec", time_sec, 0);
    rb_define_method(cTime, "min", time_min, 0);
    rb_define_method(cTime, "hour", time_hour, 0);
    rb_define_method(cTime, "mday", time_mday, 0);
    rb_define_method(cTime, "mon", time_mon, 0);
    rb_define_method(cTime, "year", time_year, 0);
    rb_define_method(cTime, "wday", time_wday, 0);
    rb_define_method(cTime, "yday", time_yday, 0);
    rb_define_method(cTime, "isdst", time_isdst, 0);
    rb_define_method(cTime, "zone", time_zone, 0);

    rb_define_method(cTime, "tv_sec", time_to_i, 0);
    rb_define_method(cTime, "tv_usec", time_usec, 0);
    rb_define_method(cTime, "usec", time_usec, 0);
d1024 1
a1024 1
    rb_define_method(cTime, "strftime", time_strftime, 1);
d1027 1
a1027 1
    S_Tms = struct_define("Tms", "utime", "stime", "cutime", "cstime", 0);
d1029 4
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d16 4
d441 14
a675 25
#define SMALLBUF 100
static int
rb_strftime(buf, format, time)
    char ** volatile buf;
    char * volatile format;
    struct tm * volatile time;
{
    volatile int i;
    int len;

    len = strftime(*buf, SMALLBUF, format, time);
    if (len != 0) return len;
    for (i=1024; i<8192; i+=1024) {
	*buf = xmalloc(i);
	len = strftime(*buf, i-1, format, time);
	if (len == 0) {
	    free(*buf);
	    continue;
	}
	return len;
    }

    ArgError("bad strftime format or result too long");
}

d681 1
a681 2
    char buffer[SMALLBUF];
    char *buf = buffer;
a682 1
    VALUE str;
d690 2
a691 1
	/* Ruby string may contain \0's. */
d697 1
a697 1
	    len = rb_strftime(&buf, p, &(tobj->tm));
d699 2
a700 2
	    p += strlen(p) + 1;
	    if (len > SMALLBUF) free(buf);
d704 2
a705 4
    len = rb_strftime(&buf, RSTRING(format)->ptr, &(tobj->tm));
    str = str_new(buf, len);
    if (len > SMALLBUF) free(buf);
    return str;
d770 1
a778 1
    rb_define_method(cTime, "day", time_mday, 0);
a779 1
    rb_define_method(cTime, "month", time_mon, 0);
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/12/16 07:30:34 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
a15 5
#ifdef USE_CWGUSI
int gettimeofday(struct timeval*, struct timezone*);
int strcasecmp(char*, char*);
#endif

d33 1
a33 1
VALUE rb_cTime;
d37 1
d53 2
a54 2
time_s_now(klass)
    VALUE klass;
d59 1
a59 1
    obj = Data_Make_Struct(klass, struct time_object, 0, free, tobj);
a64 1
    rb_obj_call_init(obj);
d70 2
a71 2
time_new_internal(klass, sec, usec)
    VALUE klass;
d77 1
a77 3
    if (sec < 0 || (sec == 0 && usec < 0))
	rb_raise(rb_eArgError, "time must be positive");
    obj = Data_Make_Struct(klass, struct time_object, 0, free, tobj);
d86 1
a86 1
rb_time_new(sec, usec)
d89 1
a89 1
    return time_new_internal(rb_cTime, sec, usec);
d93 1
a93 1
rb_time_timeval(time)
d101 1
a101 1
	t.tv_sec = FIX2INT(time);
d103 1
a103 1
	    rb_raise(rb_eArgError, "time must be positive");
d108 10
a117 4
	if (RFLOAT(time)->value < 0.0)
	    rb_raise(rb_eArgError, "time must be positive");
	t.tv_sec = (long)floor(RFLOAT(time)->value);
	t.tv_usec = (long)((RFLOAT(time)->value - t.tv_sec) * 1000000.0);
a121 2
	if (t.tv_sec < 0)
	    rb_raise(rb_eArgError, "time must be positive");
d126 3
a128 3
	if (!rb_obj_is_kind_of(time, rb_cTime)) {
	    rb_raise(rb_eTypeError, "Can't convert %s into Time",
		     rb_class2name(CLASS_OF(time)));
d138 2
a139 2
time_s_at(klass, time)
    VALUE klass, time;
d143 2
a144 2
    tv = rb_time_timeval(time);
    return time_new_internal(klass, tv.tv_sec, tv.tv_usec);
a151 11
static int
obj2int(obj)
    VALUE obj;
{
    if (TYPE(obj) == T_STRING) {
	obj = rb_str2inum(RSTRING(obj)->ptr, 10);
    }

    return NUM2INT(obj);
}

d161 1
a161 11
    if (argc == 10) {
	v[0] = argv[5];
	v[1] = argv[4];
	v[2] = argv[3];
	v[3] = argv[2];
	v[4] = argv[1];
	v[5] = argv[0];
    }
    else {
	rb_scan_args(argc, argv, "15", &v[0],&v[1],&v[2],&v[3],&v[4],&v[5]);
    }
d163 1
a163 1
    args[0] = obj2int(v[0]);
d166 1
a166 1
    if (NIL_P(v[1])) {
d181 1
a181 1
		args[1] = obj2int(v[1])-1;
d186 1
a186 1
	args[1] = obj2int(v[1]) - 1;
d188 1
a188 1
    if (NIL_P(v[2])) {
d192 1
a192 1
	args[2] = obj2int(v[2]);
d195 1
a195 1
	if (NIL_P(v[i])) {
d199 1
a199 1
	    args[i] = obj2int(v[i]);
d204 1
a204 1
    if (   args[0] < 70|| args[0] > 137
d208 3
a210 3
	|| args[4] < 0 || args[4] > 59
	|| args[5] < 0 || args[5] > 60)
	rb_raise(rb_eArgError, "argument out of range");
a212 2
static VALUE time_gmtime _((VALUE));
static VALUE time_localtime _((VALUE));
d214 1
a214 1
time_gm_or_local(argc, argv, gm_or_local, klass)
d218 1
a218 1
    VALUE klass;
a225 1
    VALUE time;
d236 1
a236 1
    while (diff = t - (tm->tm_year)) {
d238 1
a238 1
	if (guess < 0) rb_raise(rb_eArgError, "too far future");
d253 1
a253 3
    time = time_new_internal(klass, guess, 0);
    if (gm_or_local) return time_gmtime(time);
    return time_localtime(time);
d256 1
a256 2
    rb_raise(rb_eArgError, "gmtime/localtime error");
    return Qnil;		/* not reached */
d260 1
a260 1
time_s_timegm(argc, argv, klass)
d263 1
a263 1
    VALUE klass;
d265 1
a265 1
    return time_gm_or_local(argc, argv, 1, klass);
d269 1
a269 1
time_s_timelocal(argc, argv, klass)
d272 1
a272 1
    VALUE klass;
d274 1
a274 1
    return time_gm_or_local(argc, argv, 0, klass);
d284 1
a284 1
    return rb_int2inum(tobj->tv.tv_sec);
d294 1
a294 1
    return rb_float_new((double)tobj->tv.tv_sec+(double)tobj->tv.tv_usec/1000000);
d334 1
a334 1
    if (rb_obj_is_instance_of(time2, rb_cTime)) {
d357 1
a357 1
    if (rb_obj_is_instance_of(time2, rb_cTime)) {
d360 1
a360 1
	    if (tobj1->tv.tv_usec == tobj2->tv.tv_usec) return Qtrue;
d363 1
a363 1
    return Qfalse;
a416 17
    char *s;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_localtime(time);
    }
    s = asctime(&(tobj->tm));
    if (s[24] == '\n') s[24] = '\0';

    return rb_str_new2(s);
}

static VALUE
time_to_s(time)
    VALUE time;
{
    struct time_object *tobj;
d433 1
a433 1
    return rb_str_new(buf, len);
d441 1
a441 1
    long sec, usec;
d447 1
a447 1
	usec = tobj1->tv.tv_usec + (long)(RFLOAT(time2)->value-(double)nsec)*1e6;
d449 1
a449 1
    else if (rb_obj_is_instance_of(time2, rb_cTime)) {
d463 1
a463 1
    return rb_time_new(sec, usec);
d474 1
a474 1
    if (rb_obj_is_instance_of(time2, rb_cTime)) {
d482 1
a482 1
	return rb_float_new(f);
d497 1
a497 1
    return rb_time_new(sec, usec);
d562 1
a562 1
    return INT2FIX(tobj->tm.tm_mon+1);
d575 1
a575 1
    return INT2FIX(tobj->tm.tm_year+1900);
d614 1
a614 1
    return tobj->tm.tm_isdst?Qtrue:Qfalse;
d631 1
a631 1
    return rb_str_new(buf, len);
d639 1
d645 11
a655 11
    return rb_ary_new3(10,
		    INT2FIX(tobj->tm.tm_sec),
		    INT2FIX(tobj->tm.tm_min),
		    INT2FIX(tobj->tm.tm_hour),
		    INT2FIX(tobj->tm.tm_mday),
		    INT2FIX(tobj->tm.tm_mon+1),
		    INT2FIX(tobj->tm.tm_year+1900),
		    INT2FIX(tobj->tm.tm_wday),
		    INT2FIX(tobj->tm.tm_yday),
		    tobj->tm.tm_isdst?Qtrue:Qfalse,
		    time_zone(time));
d680 1
a680 2
    rb_raise(rb_eArgError, "bad strftime format or result too long");
    return Qnil;		/* not reached */
a688 1
    char *fmt;
d693 1
d698 1
a698 2
    fmt = str2cstr(format, &len);
    if (strlen(fmt) < len) {
d700 2
a701 1
	char *p = fmt, *pe = fmt + len;
d703 1
a703 1
	str = rb_str_new(0, 0);
d706 1
a706 1
	    rb_str_cat(str, buf, len);
d713 2
a714 2
    str = rb_str_new(buf, len);
    if (buf != buffer) free(buf);
d729 5
a733 5
    return rb_struct_new(S_Tms,
			 rb_float_new((double)buf.tms_utime / HZ),
			 rb_float_new((double)buf.tms_stime / HZ),
			 rb_float_new((double)buf.tms_cutime / HZ),
			 rb_float_new((double)buf.tms_cstime / HZ));
d741 5
a745 5
    return rb_struct_new(S_Tms,
      rb_float_new((double)(kernel.dwHighDateTime*2e32+kernel.dwLowDateTime)/2e6),
      rb_float_new((double)(user.dwHighDateTime*2e32+user.dwLowDateTime)/2e6),
      rb_float_new((double)0),
      rb_float_new((double)0));
a751 48
static VALUE
time_dump(time, limit)
    VALUE time, limit;
{
    struct time_object *tobj;
    int sec, usec;
    unsigned char buf[8];
    int i;

    GetTimeval(time, tobj);
    sec = tobj->tv.tv_sec;
    usec = tobj->tv.tv_usec;

    for (i=0; i<4; i++) {
	buf[i] = sec & 0xff;
	sec = RSHIFT(sec, 8);
    }
    for (i=4; i<8; i++) {
	buf[i] = usec & 0xff;
	usec = RSHIFT(usec, 8);
    }
    return rb_str_new(buf, 8);
}

static VALUE
time_load(klass, str)
    VALUE klass, str;
{
    int sec, usec;
    unsigned char *buf;
    int i;

    buf = str2cstr(str, &i);
    if (i != 8) {
	rb_raise(rb_eTypeError, "marshaled time format differ");
    }

    sec = usec = 0;
    for (i=0; i<4; i++) {
	sec |= buf[i]<<(8*i);
    }
    for (i=4; i<8; i++) {
	usec |= buf[i]<<(8*(i-4));
    }

    return time_new_internal(klass, sec, usec);
}

d755 2
a756 2
    rb_cTime = rb_define_class("Time", rb_cObject);
    rb_include_module(rb_cTime, rb_mComparable);
d758 42
a799 42
    rb_define_singleton_method(rb_cTime, "now", time_s_now, 0);
    rb_define_singleton_method(rb_cTime, "new", time_s_now, 0);
    rb_define_singleton_method(rb_cTime, "at", time_s_at, 1);
    rb_define_singleton_method(rb_cTime, "gm", time_s_timegm, -1);
    rb_define_singleton_method(rb_cTime, "local", time_s_timelocal, -1);
    rb_define_singleton_method(rb_cTime, "mktime", time_s_timelocal, -1);

    rb_define_singleton_method(rb_cTime, "times", time_s_times, 0);

    rb_define_method(rb_cTime, "to_i", time_to_i, 0);
    rb_define_method(rb_cTime, "to_f", time_to_f, 0);
    rb_define_method(rb_cTime, "<=>", time_cmp, 1);
    rb_define_method(rb_cTime, "eql?", time_eql, 1);
    rb_define_method(rb_cTime, "hash", time_hash, 0);

    rb_define_method(rb_cTime, "localtime", time_localtime, 0);
    rb_define_method(rb_cTime, "gmtime", time_gmtime, 0);
    rb_define_method(rb_cTime, "ctime", time_asctime, 0);
    rb_define_method(rb_cTime, "asctime", time_asctime, 0);
    rb_define_method(rb_cTime, "to_s", time_to_s, 0);
    rb_define_method(rb_cTime, "inspect", time_to_s, 0);
    rb_define_method(rb_cTime, "to_a", time_to_a, 0);

    rb_define_method(rb_cTime, "+", time_plus, 1);
    rb_define_method(rb_cTime, "-", time_minus, 1);

    rb_define_method(rb_cTime, "sec", time_sec, 0);
    rb_define_method(rb_cTime, "min", time_min, 0);
    rb_define_method(rb_cTime, "hour", time_hour, 0);
    rb_define_method(rb_cTime, "mday", time_mday, 0);
    rb_define_method(rb_cTime, "day", time_mday, 0);
    rb_define_method(rb_cTime, "mon", time_mon, 0);
    rb_define_method(rb_cTime, "month", time_mon, 0);
    rb_define_method(rb_cTime, "year", time_year, 0);
    rb_define_method(rb_cTime, "wday", time_wday, 0);
    rb_define_method(rb_cTime, "yday", time_yday, 0);
    rb_define_method(rb_cTime, "isdst", time_isdst, 0);
    rb_define_method(rb_cTime, "zone", time_zone, 0);

    rb_define_method(rb_cTime, "tv_sec", time_to_i, 0);
    rb_define_method(rb_cTime, "tv_usec", time_usec, 0);
    rb_define_method(rb_cTime, "usec", time_usec, 0);
d801 1
a801 1
    rb_define_method(rb_cTime, "strftime", time_strftime, 1);
d804 1
a804 1
    S_Tms = rb_struct_define("Tms", "utime", "stime", "cutime", "cstime", 0);
a805 4

    /* methods for marshaling */
    rb_define_singleton_method(rb_cTime, "_load", time_load, 1);
    rb_define_method(rb_cTime, "_dump", time_dump, 1);
@


1.1.1.3.2.1
log
@990126
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:30 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
a81 1
#ifndef USE_CWGUSI
a83 1
#endif
@


1.1.1.3.2.2
log
@990224
@
text
@d6 1
a6 1
  $Date: 1999/01/26 10:08:17 $
d16 5
a35 8

#ifdef USE_CWGUSI
typedef int time_t;
time_t gettimeofday(struct timeval*, struct timezone*);
time_t strcasecmp(char*, char*);
#endif

#if 0
a36 1
#endif
d66 1
a66 1
    if (gettimeofday(&(tobj->tv), 0) < 0) {
d77 1
a77 1
    time_t sec, usec;
d96 1
a96 1
    time_t sec, usec;
d110 1
a110 1
	t.tv_sec = FIX2LONG(time);
d124 1
a124 1
	t.tv_sec = NUM2LONG(time);
d157 2
a158 2
static long
obj2long(obj)
d165 1
a165 1
    return NUM2LONG(obj);
d169 1
a169 1
time_arg(argc, argv, tm)
d172 1
a172 1
    struct tm *tm;
d189 3
a191 3
    tm->tm_year = obj2long(v[0]);
    if (tm->tm_year < 69) tm->tm_year += 100;
    if (tm->tm_year > 1900) tm->tm_year -= 1900;
d193 1
a193 1
	tm->tm_mon = 0;
d196 1
a196 1
	tm->tm_mon = -1;
d198 2
a199 3
	    if (RSTRING(v[1])->len == 3 &&
		strcasecmp(months[i], RSTRING(v[1])->ptr) == 0) {
		tm->tm_mon = i;
d203 1
a203 1
	if (tm->tm_mon == -1) {
d207 1
a207 1
		tm->tm_mon = obj2long(v[1])-1;
d212 1
a212 1
	tm->tm_mon = obj2long(v[1]) - 1;
d215 1
a215 1
	tm->tm_mday = 1;
d218 9
a226 1
	tm->tm_mday = obj2long(v[2]);
a227 3
    tm->tm_hour = NIL_P(v[3])?0:obj2long(v[3]);
    tm->tm_min  = NIL_P(v[4])?0:obj2long(v[4]);
    tm->tm_sec  = NIL_P(v[5])?0:obj2long(v[5]);
d230 6
a235 6
    if (   tm->tm_year < 69
	|| tm->tm_mon  < 0 || tm->tm_mon  > 11
	|| tm->tm_mday < 1 || tm->tm_mday > 31
	|| tm->tm_hour < 0 || tm->tm_hour > 23
	|| tm->tm_min  < 0 || tm->tm_min  > 59
	|| tm->tm_sec  < 0 || tm->tm_sec  > 60)
d241 6
a246 5

static time_t
make_time_t(tptr, fn)
    struct tm *tptr;
    struct tm *(*fn)();
d248 1
d250 1
d252 6
a257 2
    struct tm *tm;
    long diff;
d259 1
a259 3
    if (gettimeofday(&tv, 0) < 0) {
	rb_sys_fail("gettimeofday");
    }
d264 1
a264 1
    t = tptr->tm_year;
d267 1
d271 1
a271 1
    t = tptr->tm_mon;
d277 4
a280 5
    guess += (tptr->tm_mday - tm->tm_mday) * 3600 * 24;
    guess += (tptr->tm_hour - tm->tm_hour) * 3600;
    guess += (tptr->tm_min - tm->tm_min) * 60;
    guess += tptr->tm_sec - tm->tm_sec;
    if (guess < 0) rb_raise(rb_eArgError, "too far future");
d282 3
a284 1
    return guess;
a291 19
time_gm_or_local(argc, argv, gm_or_local, klass)
    int argc;
    VALUE *argv;
    int gm_or_local;
    VALUE klass;
{
    struct tm tm;
    struct tm *(*fn)();
    VALUE time;

    fn = (gm_or_local) ? gmtime : localtime;
    time_arg(argc, argv, &tm);

    time = time_new_internal(klass, make_time_t(&tm, fn), 0);
    if (gm_or_local) return time_gmtime(time);
    return time_localtime(time);
}

static VALUE
d316 1
a316 1
    return INT2NUM(tobj->tv.tv_sec);
d336 1
a336 1
    return INT2NUM(tobj->tv.tv_usec);
d344 1
a344 1
    long i;
d349 1
a349 1
	i = FIX2LONG(time2);
d358 1
a358 1
	    if (tobj1->tv.tv_sec == (long)RFLOAT(time2)->value) return INT2FIX(0);
d376 1
a376 1
    i = NUM2LONG(time2);
d403 1
a403 1
    long hash;
d466 1
a466 1
    char buf[128];
d475 1
a475 1
	len = strftime(buf, 128, "%a %b %d %H:%M:%S GMT %Y", &(tobj->tm));
d480 1
a480 1
	len = strftime(buf, 128, "%a %b %d %H:%M:%S %Z %Y", &(tobj->tm));
a490 1
    double f;
d493 14
a506 5

    f = NUM2DBL(time2);
    sec = (long)f;
    usec = tobj1->tv.tv_usec + (long)((f - (double)sec)*1e6);
    sec = tobj1->tv.tv_sec + sec;
d520 1
a520 2
    long sec, usec;
    double f;
d524 1
d528 1
d533 4
d538 2
a539 4
	f = NUM2DBL(time2);
	sec = (long)f;
	usec = tobj1->tv.tv_usec - (long)((f - (double)sec)*1e6);
	sec = tobj1->tv.tv_sec - sec;
d650 1
a650 1
    return INT2FIX(tobj->tm.tm_yday+1);
d671 1
a671 1
    char buf[64];
d679 1
a679 1
    len = strftime(buf, 64, "%Z", &(tobj->tm));
d701 1
a701 1
		    INT2FIX(tobj->tm.tm_yday+1),
d713 2
a714 2
    volatile int size;
    int len, flen;
a715 5
    buf[0] = '\0';
    flen = strlen(format);
    if (flen == 0) {
	return 0;
    }
d718 8
a725 13
    for (size=1024; ; size*=2) {
	*buf = xmalloc(size);
	buf[0] = '\0';
	len = strftime(*buf, size, format, time);
	/*
	 * buflen can be zero EITHER because there's not enough
	 * room in the string, or because the control command
	 * goes to the empty string. Make a reasonable guess that
	 * if the buffer is 1024 times bigger than the length of the
	 * format string, it's not failing for lack of room.
	 */
	if (len > 0 || len >= 1024 * flen) return len;
	free(*buf);
d727 3
a729 1
    /* not reached */
a747 3
    if (len == 0) {
	rb_warning("strftime called with empty format string");
    }
a756 2
	    if (p <= pe)
		rb_str_cat(str, "\0", 1);
d802 2
a803 4
time_dump(argc, argv, time)
    int argc;
    VALUE *argv;
    VALUE time;
a804 1
    VALUE dummy;
d806 2
a807 3
    time_t sec, usec;
    struct tm *tm;
    unsigned char buf[11];
a809 1
    rb_scan_args(argc, argv, "01", &dummy);
a813 29
    tm = gmtime(&sec);

    i = tm->tm_year;
    buf[0] = i & 0xff;
    i = RSHIFT(i, 8);
    buf[1] = i & 0xff;

    buf[2] = tm->tm_mon;
    buf[3] = tm->tm_mday;
    buf[4] = tm->tm_hour;
    buf[5] = tm->tm_min;
    buf[6] = tm->tm_sec;

    for (i=7; i<11; i++) {
	buf[i] = usec & 0xff;
	usec = RSHIFT(usec, 8);
    }
    return rb_str_new(buf, 11);
}

static VALUE
time_old_load(klass, buf)
    VALUE klass;
    unsigned char *buf;
{
    time_t sec, usec;
    int i;

    sec = usec = 0;
d815 2
a816 1
	sec |= buf[i]<<(8*i);
d819 2
a820 1
	usec |= buf[i]<<(8*(i-4));
d822 1
a822 2

    return time_new_internal(klass, sec, usec);
d829 1
a829 1
    time_t sec, usec;
a830 1
    struct tm tm;
d834 1
a834 4
    if (i == 8) {
	return time_old_load(klass, buf);
    }
    if (i != 11) {
d838 1
a838 11
    tm.tm_year = buf[0];
    tm.tm_year |= buf[1]<<8;
    tm.tm_mon = buf[2];
    tm.tm_mday = buf[3];
    tm.tm_hour = buf[4];
    tm.tm_min = buf[5];
    tm.tm_sec = buf[6];

    sec = make_time_t(&tm, gmtime);

    usec = 0;
d840 4
a843 1
	usec |= buf[i+7]<<(8*i);
a904 1
    rb_define_method(rb_cTime, "_dump", time_dump, -1);
d906 1
@


1.1.1.3.2.3
log
@990225
@
text
@d6 1
a6 1
  $Date: 1999/02/24 04:31:26 $
a20 1
#define time_t long
d22 2
a23 2
        time_t tv_sec;		/* seconds */
        time_t tv_usec;		/* and microseconds */
d33 3
a35 3
#define time_t long
int gettimeofday(struct timeval*, struct timezone*);
int strcasecmp(char*, char*);
d73 1
a73 1
    rb_obj_call_init(obj, 0, 0);
d123 2
a124 2
	t.tv_sec = (time_t)RFLOAT(time)->value;
	t.tv_usec = (time_t)((RFLOAT(time)->value - (double)t.tv_sec)*1e6);
d136 1
a136 1
	    rb_raise(rb_eTypeError, "can't convert %s into Time",
a261 1
	if (guess < 0) goto too_future;
a267 1
	if (guess < 0) goto too_future;
d275 1
a275 1
    if (guess < 0) goto too_future;
a278 3
  too_future:
    rb_raise(rb_eArgError, "too far future");

d370 1
a370 2
	    if (tobj1->tv.tv_sec == (time_t)RFLOAT(time2)->value)
		return INT2FIX(0);
d372 2
a373 4
	    if (tobj1->tv.tv_sec == (time_t)RFLOAT(time2)->value)
		return INT2FIX(0);
	    if (tobj1->tv.tv_sec > (time_t)RFLOAT(time2)->value)
		return INT2FIX(1);
d502 1
a502 1
    time_t sec, usec;
a506 5
#if 0
    if (rb_obj_is_kind_of(time2, rb_cTime)) {
	rb_raise(rb_eTypeError, "time + time?");
    }
#endif
d508 2
a509 2
    sec = (time_t)f;
    usec = tobj1->tv.tv_usec + (time_t)((f - (double)sec)*1e6);
d524 1
a524 1
    time_t sec, usec;
d538 2
a539 2
	sec = (time_t)f;
	usec = tobj1->tv.tv_usec - (time_t)((f - (double)sec)*1e6);
d717 1
a717 1
    (*buf)[0] = '\0';
d726 1
a726 1
	(*buf)[0] = '\0';
d823 1
d825 1
a825 2
    unsigned long p, s;
    unsigned char buf[8];
d830 2
d833 1
a833 1
    tm = gmtime(&tobj->tv.tv_sec);
d835 25
a859 8
    p = 0x1          << 31 | /*  1 */
	tm->tm_year  << 14 | /* 17 */
	tm->tm_mon   << 10 | /*  4 */
	tm->tm_mday  <<  5 | /*  5 */
	tm->tm_hour;         /*  5 */
    s = tm->tm_min   << 26 | /*  6 */
	tm->tm_sec   << 20 | /*  6 */
	tobj->tv.tv_usec;    /* 20 */
d861 1
d863 1
a863 2
	buf[i] = p & 0xff;
	p = RSHIFT(p, 8);
d866 1
a866 2
	buf[i] = s & 0xff;
	s = RSHIFT(s, 8);
d869 1
a869 1
    return rb_str_new(buf, 8);
a875 1
    unsigned long p, s;
d882 4
a885 1
    if (i != 8) {
d889 11
a899 1
    p = s = 0;
d901 1
a901 4
	p |= buf[i]<<(8*i);
    }
    for (i=4; i<8; i++) {
	s |= buf[i]<<(8*(i-4));
a902 14

    if ((p & (1<<31)) == 0) {
	return time_new_internal(klass, sec, usec);
    }
    p &= ~(1<<31);
    tm.tm_year = (p >> 14) & 0x3ffff;
    tm.tm_mon  = (p >> 10) & 0xf;
    tm.tm_mday = (p >>  5) & 0x1f;
    tm.tm_hour =  p        & 0x1f;
    tm.tm_min  = (s >> 26) & 0x3f;
    tm.tm_sec  = (s >> 20) & 0x3f;

    sec = make_time_t(&tm, gmtime);
    usec = (time_t) s & 0xfffff;
@


1.1.1.3.2.4
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/25 06:39:11 $
d51 1
d53 1
d196 1
a196 1
    if (tm->tm_year >= 1000) tm->tm_year -= 1900;
a241 1
static VALUE time_get_tm _((VALUE, int));
a260 1
    if (t < 69) goto out_of_range;
d263 1
a263 1
	if (diff > 0 && guess < 0) goto out_of_range;
d270 1
a272 1
	if (tptr->tm_year != tm->tm_year) goto out_of_range;
d277 2
a278 2
    guess +=  tptr->tm_sec - tm->tm_sec;
    if (guess < 0) goto out_of_range;
d282 2
a283 2
  out_of_range:
    rb_raise(rb_eArgError, "time out of range");
a419 11
time_gmt_p(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj->gmt) return Qtrue;
    return Qfalse;
}

static VALUE
a431 15
time_clone(time)
    VALUE time;
{
    VALUE obj;
    struct time_object *tobj, *newtobj;

    GetTimeval(time, tobj);
    obj = Data_Make_Struct(0, struct time_object, 0, free, newtobj);
    CLONESETUP(obj, time);
    MEMCPY(newtobj, tobj, struct time_object, 1);

    return obj;
}

static VALUE
d442 1
d444 1
d459 1
d461 1
a465 9
time_get_tm(time, gmt)
    VALUE time;
    int gmt;
{
    if (gmt) return time_gmtime(time);
    return time_localtime(time);
}

static VALUE
d474 1
a474 1
	time_get_tm(time, tobj->gmt);
d492 1
a492 1
	time_get_tm(time, tobj->gmt);
d510 1
a510 1
    struct time_object *tobj;
d514 1
a514 1
    GetTimeval(time1, tobj);
d516 1
d520 1
d523 2
a524 2
    usec = tobj->tv.tv_usec + (time_t)((f - (double)sec)*1e6);
    sec = tobj->tv.tv_sec + sec;
d530 1
a530 6
    time2 = rb_time_new(sec, usec);
    if (tobj->gmt) {
	GetTimeval(time2, tobj);
	tobj->gmt = 1;
    }
    return time2;
d537 1
a537 1
    struct time_object *tobj;
d541 1
a541 1
    GetTimeval(time1, tobj);
a542 1
	struct time_object *tobj2;
d545 2
a546 2
	f = tobj->tv.tv_sec - tobj2->tv.tv_sec;
	f += (tobj->tv.tv_usec - tobj2->tv.tv_usec)*1e-6;
d553 2
a554 2
	usec = tobj->tv.tv_usec - (time_t)((f - (double)sec)*1e6);
	sec = tobj->tv.tv_sec - sec;
d561 1
a561 6
    time2 = rb_time_new(sec, usec);
    if (tobj->gmt) {
	GetTimeval(time2, tobj);
	tobj->gmt = 1;
    }
    return time2;
d572 1
a572 1
	time_get_tm(time, tobj->gmt);
d585 1
a585 1
	time_get_tm(time, tobj->gmt);
d598 1
a598 1
	time_get_tm(time, tobj->gmt);
d611 1
a611 1
	time_get_tm(time, tobj->gmt);
d624 1
a624 1
	time_get_tm(time, tobj->gmt);
d637 1
a637 1
	time_get_tm(time, tobj->gmt);
d650 1
a650 1
	time_get_tm(time, tobj->gmt);
d663 1
a663 1
	time_get_tm(time, tobj->gmt);
d676 1
a676 1
	time_get_tm(time, tobj->gmt);
d691 1
a691 1
	time_get_tm(time, tobj->gmt);
d706 1
a706 1
	time_get_tm(time, tobj->gmt);
d768 1
a768 1
	time_get_tm(time, tobj->gmt);
d845 1
a845 1
  tm = gmtime((const time_t*)&tobj->tv.tv_sec);
d895 1
a895 1
    tm.tm_year = (p >> 14) & 0x1ffff;
a927 1
    rb_define_method(rb_cTime, "clone", time_clone, 0);
a951 2

    rb_define_method(rb_cTime, "gmt?", time_gmt_p, 0);
@


1.1.1.3.2.5
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:34 $
a149 1
    VALUE t;
d152 1
a152 9
    t = time_new_internal(klass, tv.tv_sec, tv.tv_usec);
    if (TYPE(time) == T_DATA) {
	struct time_object *tobj, *tobj2;

	GetTimeval(time, tobj);
	GetTimeval(t, tobj2);
	tobj2->gmt = tobj->gmt;
    }
    return t;
@


1.1.1.3.2.6
log
@I thins tv_sec should be time_t. hmm
@
text
@d6 1
a6 1
  $Date: 1999/04/09 17:57:43 $
d69 1
a69 1
    if (gettimeofday(&tobj->tv, 0) < 0) {
a471 1
    time_t t = tobj->tv.tv_sec;
d474 1
a474 1
    tm_tmp = localtime(&t);
a486 1
    time_t t = tobj->tv.tv_sec;
d489 1
a489 1
    tm_tmp = gmtime(&t);
d516 1
a516 1
    s = asctime(&tobj->tm);
a888 1
    time_t t = tobj->tv.tv_sec;
d894 1
a894 1
    tm = gmtime(&t);
@


1.1.1.3.2.7
log
@gettimeofday buf on alpha
@
text
@d6 1
a6 1
  $Date: 1999/04/16 09:45:14 $
d39 2
a40 2
#ifdef HAVE_UNISTD_H
#include <unistd.h>
d472 1
a472 1
    time_t t;
a474 1
    t = tobj->tv.tv_sec;
d488 1
a488 1
    time_t t;
a490 1
    t = tobj->tv.tv_sec;
d538 1
a538 1
	len = strftime(buf, 128, "%a %b %d %H:%M:%S GMT %Y", &tobj->tm);
d543 1
a543 1
	len = strftime(buf, 128, "%a %b %d %H:%M:%S %Z %Y", &tobj->tm);
d745 1
a745 1
    len = strftime(buf, 64, "%Z", &tobj->tm);
d831 1
a831 1
	    len = rb_strftime(&buf, p, &tobj->tm);
d840 1
a840 1
    len = rb_strftime(&buf, RSTRING(format)->ptr, &tobj->tm);
d891 1
a891 1
    time_t t;
a896 1
    t = tobj->tv.tv_sec;
@


1.1.1.3.2.8
log
@moving
@
text
@d6 1
a6 1
  $Date: 1999/04/16 10:12:06 $
d947 1
a947 1
	return time_new_internal(klass, p, s);
@


1.1.1.3.2.9
log
@990611
@
text
@d6 1
a6 1
  $Date: 1999/05/14 08:56:12 $
d72 1
@


1.1.1.3.2.10
log
@990715
@
text
@d6 1
a6 1
  $Date: 1999/06/11 06:29:59 $
d104 1
a104 1
rb_time_interval(time)
d133 6
a138 2
	rb_raise(rb_eTypeError, "can't convert %s into Time interval",
		 rb_class2name(CLASS_OF(time)));
a141 15
}

struct timeval
rb_time_timeval(time)
    VALUE time;
{
    struct time_object *tobj;
    struct timeval t;

    if (rb_obj_is_kind_of(time, rb_cTime)) {
	GetTimeval(time, tobj);
	t = tobj->tv;
	return t;
    }
    return rb_time_interval(time);
@


1.1.1.3.2.11
log
@backtrace may be Qnil
@
text
@d6 1
a6 1
  $Date: 1999/07/15 07:59:57 $
d107 1
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:04:58 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:48 $
d204 1
a204 1
    if (   args[0] < 70|| args[0] > 137
@


1.1.1.2.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/30 10:18:25 $
a423 17
    len = strftime(buf, 64, "%c", &(tobj->tm));

    return str_new(buf, len);
}

static VALUE
time_to_s(time)
    VALUE time;
{
    struct time_object *tobj;
    char buf[64];
    int len;

    GetTimeval(time, tobj);
    if (tobj->tm_got == 0) {
	time_localtime(time);
    }
d777 2
a778 2
    rb_define_method(cTime, "to_s", time_to_s, 0);
    rb_define_method(cTime, "inspect", time_to_s, 0);
@


1.1.1.2.2.4
log
@1.1b7 pre
@
text
@d6 1
a6 1
  $Date: 1998/02/03 10:02:56 $
d417 2
a418 1
    char *s;
d424 1
a424 2
    s = asctime(&(tobj->tm));
    if (s[24] == '\n') s[24] = '\0';
d426 1
a426 1
    return str_new2(s);
@


1.1.1.2.2.5
log
@year 19xx; month starts from 1
@
text
@d6 1
a6 1
  $Date: 1998/02/09 10:56:23 $
d236 1
a236 1
    while (diff = t - (tm->tm_year)) {
d256 1
a256 1
    ArgError("gmtime/localtime error");
d579 1
a579 1
    return INT2FIX(tobj->tm.tm_mon+1);
d592 1
a592 1
    return INT2FIX(tobj->tm.tm_year+1900);
d667 2
a668 2
		   INT2FIX(tobj->tm.tm_mon+1),
		   INT2FIX(tobj->tm.tm_year+1900),
@


1.1.1.2.2.6
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/02/16 06:05:30 $
d53 2
a54 2
time_s_now(klass)
    VALUE klass;
d59 1
a59 1
    obj = Data_Make_Struct(klass, struct time_object, 0, 0, tobj);
d70 2
a71 2
time_new_internal(klass, sec, usec)
    VALUE klass;
d77 1
a77 1
    obj = Data_Make_Struct(klass, struct time_object, 0, 0, tobj);
d138 2
a139 2
time_s_at(klass, time)
    VALUE klass, time;
d144 1
a144 1
    return time_new_internal(klass, tv.tv_sec, tv.tv_usec);
d161 1
a161 11
    if (argc == 10) {
	v[0] = argv[5];
	v[1] = argv[4];
	v[2] = argv[3];
	v[3] = argv[2];
	v[4] = argv[1];
	v[5] = argv[0];
    }
    else {
	rb_scan_args(argc, argv, "15", &v[0],&v[1],&v[2],&v[3],&v[4],&v[5]);
    }
d186 1
a186 1
	args[1] = NUM2INT(v[1]) - 1;
d214 1
a214 1
time_gm_or_local(argc, argv, gm_or_local, klass)
d218 1
a218 1
    VALUE klass;
d253 1
a253 1
    return time_new_internal(klass, guess, 0);
d260 1
a260 1
time_s_timegm(argc, argv, klass)
d263 1
a263 1
    VALUE klass;
d265 1
a265 1
    return time_gm_or_local(argc, argv, 1, klass);
d269 1
a269 1
time_s_timelocal(argc, argv, klass)
d272 1
a272 1
    VALUE klass;
d274 1
a274 1
    return time_gm_or_local(argc, argv, 0, klass);
a578 1
    Warning("Time#month now start from 1 for January");
a591 1
    Warning("Time#year now returns 19xx");
d631 1
a631 2
    Warning("Time#isdst now returns boolean value");
    return tobj->tm.tm_isdst?TRUE:FALSE;
d662 11
a672 12
    Warning("Time#to_a's return values are now changed");
    return ary_new3(10,
		    INT2FIX(tobj->tm.tm_sec),
		    INT2FIX(tobj->tm.tm_min),
		    INT2FIX(tobj->tm.tm_hour),
		    INT2FIX(tobj->tm.tm_mday),
		    INT2FIX(tobj->tm.tm_mon+1),
		    INT2FIX(tobj->tm.tm_year+1900),
		    INT2FIX(tobj->tm.tm_wday),
		    INT2FIX(tobj->tm.tm_yday),
		    tobj->tm.tm_isdst?TRUE:FALSE,
		    time_zone(time));
d731 1
a731 1
    if (buf != buffer) free(buf);
@


1.1.1.2.2.7
log
@call initialize
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:42 $
a64 1
    obj_call_init(obj);
@


1.1.1.2.2.8
log
@1.1b9_12
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:03:51 $
d174 1
a174 1
    args[0] = rb_obj2int(v[0]);
d177 1
a177 1
    if (NIL_P(v[1])) {
d192 1
a192 1
		args[1] = rb_obj2int(v[1])-1;
d197 1
a197 1
	args[1] = rb_obj2int(v[1]) - 1;
d199 1
a199 1
    if (NIL_P(v[2])) {
d203 1
a203 1
	args[2] = rb_obj2int(v[2]);
d206 1
a206 1
	if (NIL_P(v[i])) {
d210 1
a210 1
	    args[i] = rb_obj2int(v[i]);
@


1.1.1.2.2.9
log
@1.1b9_14
@
text
@d6 1
a6 1
  $Date: 1998/04/20 06:20:35 $
a152 11
static int
obj2int(obj)
    VALUE obj;
{
    if (TYPE(obj) == T_STRING) {
	obj = str2inum(RSTRING(obj)->ptr, 10);
    }

    return NUM2INT(obj);
}

d174 1
a174 1
    args[0] = obj2int(v[0]);
d192 1
a192 1
		args[1] = obj2int(v[1])-1;
d197 1
a197 1
	args[1] = obj2int(v[1]) - 1;
d203 1
a203 1
	args[2] = obj2int(v[2]);
d210 1
a210 1
	    args[i] = obj2int(v[i]);
@


1.1.1.2.2.10
log
@new exception model
@
text
@d6 1
a6 1
  $Date: 1998/04/22 08:57:35 $
a234 2
static VALUE time_gmtime _((VALUE));
static VALUE time_localtime _((VALUE));
a247 1
    VALUE time;
d275 1
a275 3
    time = time_new_internal(klass, guess, 0);
    if (gm_or_local) return time_gmtime(time);
    return time_localtime(time);
@


1.1.1.2.2.11
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/04/30 07:41:18 $
a14 5

#ifdef USE_CWGUSI
int gettimeofday(struct timeval*, struct timezone*);
int strcasecmp(char*, char*);
#endif
@


1.1.1.2.2.12
log
@remove unused variables
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:38 $
d691 1
d753 1
@


1.1.1.2.2.13
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 04:57:58 $
d42 1
@


1.1.1.2.2.14
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/02 10:05:35 $
a739 1
    char *fmt;
d744 1
d749 1
a749 2
    fmt = str2cstr(format, &len);
    if (strlen(fmt) < len) {
d751 1
a751 1
	char *p = fmt, *pe = fmt + len;
@


1.1.1.2.2.15
log
@1.1c7
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:43 $
d106 3
a108 1
	t.tv_sec = FIX2INT(time);
d113 10
a122 2
	t.tv_sec = RFLOAT(time)->value;
	t.tv_usec = (RFLOAT(time)->value - t.tv_sec) * 1000000.0;
d234 2
a235 2
	|| args[4] < 0 || args[4] > 59
	|| args[5] < 0 || args[5] > 60)
a802 49
static VALUE
time_dump(time, limit)
    VALUE time, limit;
{
    struct time_object *tobj;
    int sec, usec;
    unsigned char buf[8];
    int i;

    GetTimeval(time, tobj);
    sec = tobj->tv.tv_sec;
    usec = tobj->tv.tv_usec;

    for (i=0; i<4; i++) {
	buf[i] = sec & 0xff;
	sec = RSHIFT(sec, 8);
    }
    printf("::");
    for (i=4; i<8; i++) {
	buf[i] = usec & 0xff;
	usec = RSHIFT(usec, 8);
    }
    return str_new(buf, 8);
}

static VALUE
time_load(klass, str)
    VALUE klass, str;
{
    int sec, usec;
    unsigned char *buf;
    int i;

    buf = str2cstr(str, &i);
    if (i != 8) {
	TypeError("marshaled time format differ");
    }

    sec = usec = 0;
    for (i=0; i<4; i++) {
	sec |= buf[i]<<(8*i);
    }
    for (i=4; i<8; i++) {
	usec |= buf[i]<<(8*(i-4));
    }

    return time_new_internal(klass, sec, usec);
}

a856 4

    /* methods for marshaling */
    rb_define_singleton_method(cTime, "_load", time_load, 1);
    rb_define_method(cTime, "_dump", time_dump, 1);
@


1.1.1.2.2.16
log
@1.1c8
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:51 $
d810 1
@


1.1.1.2.2.17
log
@1.1c9 - 1.1c final, hopefully
@
text
@d6 1
a6 1
  $Date: 1998/11/17 09:12:40 $
d63 1
a63 1
    obj = Data_Make_Struct(klass, struct time_object, 0, free, tobj);
d82 1
a82 1
    obj = Data_Make_Struct(klass, struct time_object, 0, free, tobj);
@


1.1.1.2.2.18
log
@1.2.2 PR1
@
text
@d6 1
a6 1
  $Date: 1998/11/26 08:25:46 $
d859 1
a859 1
    rb_define_method(cTime, "eql?", time_eql, 1);
@


1.1.1.2.2.19
log
@1.2.4
@
text
@d6 1
a6 1
  $Date: 1999/01/18 09:08:51 $
a396 15
}

static VALUE
time_clone(time)
    VALUE time;
{
    VALUE obj;
    struct time_object *tobj, *newtobj;

    GetTimeval(time, tobj);
    obj = Data_Make_Struct(0, struct time_object, 0, free, newtobj);
    CLONESETUP(obj, time);
    MEMCPY(newtobj, tobj, struct time_object, 1);

    return obj;
@


1.1.1.2.2.20
log
@1.2.6
@
text
@d6 1
a6 1
  $Date: 1999/04/08 10:14:35 $
a875 1
    rb_define_method(cTime, "clone", time_clone, 0);
@


1.1.1.2.2.14.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:43 $
d38 1
a38 1
VALUE rb_cTime;
d69 1
a69 1
    rb_obj_call_init(obj);
d91 1
a91 1
rb_time_new(sec, usec)
d94 1
a94 1
    return time_new_internal(rb_cTime, sec, usec);
d98 1
a98 1
rb_time_timeval(time)
d108 1
a108 1
	    rb_raise(rb_eArgError, "time must be positive");
d117 1
a117 1
		rb_raise(rb_eArgError, "time must be positive");
d131 3
a133 3
	if (!rb_obj_is_kind_of(time, rb_cTime)) {
	    rb_raise(rb_eTypeError, "Can't convert %s into Time",
		     rb_class2name(CLASS_OF(time)));
d148 1
a148 1
    tv = rb_time_timeval(time);
d162 1
a162 1
	obj = rb_str2inum(RSTRING(obj)->ptr, 10);
d236 1
a236 1
	rb_raise(rb_eArgError, "argument out of range");
d267 1
a267 1
	if (guess < 0) rb_raise(rb_eArgError, "too far future");
d287 1
a287 1
    rb_raise(rb_eArgError, "gmtime/localtime error");
d315 1
a315 1
    return rb_int2inum(tobj->tv.tv_sec);
d325 1
a325 1
    return rb_float_new((double)tobj->tv.tv_sec+(double)tobj->tv.tv_usec/1000000);
d365 1
a365 1
    if (rb_obj_is_instance_of(time2, rb_cTime)) {
d388 1
a388 1
    if (rb_obj_is_instance_of(time2, rb_cTime)) {
d391 1
a391 1
	    if (tobj1->tv.tv_usec == tobj2->tv.tv_usec) return Qtrue;
d394 1
a394 1
    return Qfalse;
d457 1
a457 1
    return rb_str_new2(s);
d481 1
a481 1
    return rb_str_new(buf, len);
d497 1
a497 1
    else if (rb_obj_is_instance_of(time2, rb_cTime)) {
d511 1
a511 1
    return rb_time_new(sec, usec);
d522 1
a522 1
    if (rb_obj_is_instance_of(time2, rb_cTime)) {
d530 1
a530 1
	return rb_float_new(f);
d545 1
a545 1
    return rb_time_new(sec, usec);
d610 1
d624 1
d664 2
a665 1
    return tobj->tm.tm_isdst?Qtrue:Qfalse;
d682 1
a682 1
    return rb_str_new(buf, len);
d695 2
a696 1
    return rb_ary_new3(10,
d705 1
a705 1
		    tobj->tm.tm_isdst?Qtrue:Qfalse,
d731 1
a731 1
    rb_raise(rb_eArgError, "bad strftime format or result too long");
d754 1
a754 1
	str = rb_str_new(0, 0);
d757 1
a757 1
	    rb_str_cat(str, buf, len);
d764 1
a764 1
    str = rb_str_new(buf, len);
d780 5
a784 5
    return rb_struct_new(S_Tms,
			 rb_float_new((double)buf.tms_utime / HZ),
			 rb_float_new((double)buf.tms_stime / HZ),
			 rb_float_new((double)buf.tms_cutime / HZ),
			 rb_float_new((double)buf.tms_cstime / HZ));
d792 5
a796 5
    return rb_struct_new(S_Tms,
      rb_float_new((double)(kernel.dwHighDateTime*2e32+kernel.dwLowDateTime)/2e6),
      rb_float_new((double)(user.dwHighDateTime*2e32+user.dwLowDateTime)/2e6),
      rb_float_new((double)0),
      rb_float_new((double)0));
d806 2
a807 2
    rb_cTime = rb_define_class("Time", rb_cObject);
    rb_include_module(rb_cTime, rb_mComparable);
d809 42
a850 42
    rb_define_singleton_method(rb_cTime, "now", time_s_now, 0);
    rb_define_singleton_method(rb_cTime, "new", time_s_now, 0);
    rb_define_singleton_method(rb_cTime, "at", time_s_at, 1);
    rb_define_singleton_method(rb_cTime, "gm", time_s_timegm, -1);
    rb_define_singleton_method(rb_cTime, "local", time_s_timelocal, -1);
    rb_define_singleton_method(rb_cTime, "mktime", time_s_timelocal, -1);

    rb_define_singleton_method(rb_cTime, "times", time_s_times, 0);

    rb_define_method(rb_cTime, "to_i", time_to_i, 0);
    rb_define_method(rb_cTime, "to_f", time_to_f, 0);
    rb_define_method(rb_cTime, "<=>", time_cmp, 1);
    rb_define_method(rb_cTime, "eql?", time_eql, 0);
    rb_define_method(rb_cTime, "hash", time_hash, 0);

    rb_define_method(rb_cTime, "localtime", time_localtime, 0);
    rb_define_method(rb_cTime, "gmtime", time_gmtime, 0);
    rb_define_method(rb_cTime, "ctime", time_asctime, 0);
    rb_define_method(rb_cTime, "asctime", time_asctime, 0);
    rb_define_method(rb_cTime, "to_s", time_to_s, 0);
    rb_define_method(rb_cTime, "inspect", time_to_s, 0);
    rb_define_method(rb_cTime, "to_a", time_to_a, 0);

    rb_define_method(rb_cTime, "+", time_plus, 1);
    rb_define_method(rb_cTime, "-", time_minus, 1);

    rb_define_method(rb_cTime, "sec", time_sec, 0);
    rb_define_method(rb_cTime, "min", time_min, 0);
    rb_define_method(rb_cTime, "hour", time_hour, 0);
    rb_define_method(rb_cTime, "mday", time_mday, 0);
    rb_define_method(rb_cTime, "day", time_mday, 0);
    rb_define_method(rb_cTime, "mon", time_mon, 0);
    rb_define_method(rb_cTime, "month", time_mon, 0);
    rb_define_method(rb_cTime, "year", time_year, 0);
    rb_define_method(rb_cTime, "wday", time_wday, 0);
    rb_define_method(rb_cTime, "yday", time_yday, 0);
    rb_define_method(rb_cTime, "isdst", time_isdst, 0);
    rb_define_method(rb_cTime, "zone", time_zone, 0);

    rb_define_method(rb_cTime, "tv_sec", time_to_i, 0);
    rb_define_method(rb_cTime, "tv_usec", time_usec, 0);
    rb_define_method(rb_cTime, "usec", time_usec, 0);
d852 1
a852 1
    rb_define_method(rb_cTime, "strftime", time_strftime, 1);
d855 1
a855 1
    S_Tms = rb_struct_define("Tms", "utime", "stime", "cutime", "cstime", 0);
@


1.1.1.2.2.14.2.2
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/11/17 09:12:40 $
d63 1
a63 1
    obj = Data_Make_Struct(klass, struct time_object, 0, free, tobj);
d82 1
a82 3
    if (sec < 0 || (sec == 0 && usec < 0))
	rb_raise(rb_eArgError, "time must be positive");
    obj = Data_Make_Struct(klass, struct time_object, 0, free, tobj);
d106 1
a106 1
	t.tv_sec = FIX2INT(time);
d113 10
a122 4
	if (RFLOAT(time)->value < 0.0)
	    rb_raise(rb_eArgError, "time must be positive");
	t.tv_sec = floor(RFLOAT(time)->value);
	t.tv_usec = (RFLOAT(time)->value - t.tv_sec) * 1000000.0;
a126 2
	if (t.tv_sec < 0)
	    rb_raise(rb_eArgError, "time must be positive");
d234 2
a235 2
	|| args[4] < 0 || args[4] > 59
	|| args[5] < 0 || args[5] > 60)
a798 48
static VALUE
time_dump(time, limit)
    VALUE time, limit;
{
    struct time_object *tobj;
    int sec, usec;
    unsigned char buf[8];
    int i;

    GetTimeval(time, tobj);
    sec = tobj->tv.tv_sec;
    usec = tobj->tv.tv_usec;

    for (i=0; i<4; i++) {
	buf[i] = sec & 0xff;
	sec = RSHIFT(sec, 8);
    }
    for (i=4; i<8; i++) {
	buf[i] = usec & 0xff;
	usec = RSHIFT(usec, 8);
    }
    return rb_str_new(buf, 8);
}

static VALUE
time_load(klass, str)
    VALUE klass, str;
{
    int sec, usec;
    unsigned char *buf;
    int i;

    buf = str2cstr(str, &i);
    if (i != 8) {
	rb_raise(rb_eTypeError, "marshaled time format differ");
    }

    sec = usec = 0;
    for (i=0; i<4; i++) {
	sec |= buf[i]<<(8*i);
    }
    for (i=4; i<8; i++) {
	usec |= buf[i]<<(8*(i-4));
    }

    return time_new_internal(klass, sec, usec);
}

a852 4

    /* methods for marshaling */
    rb_define_singleton_method(rb_cTime, "_load", time_load, 1);
    rb_define_method(rb_cTime, "_dump", time_dump, 1);
@


1.1.1.2.2.14.2.3
log
@first public release of 1.1d (pre1.2) series
@
text
@d6 1
a6 1
  $Date: 1998/11/26 08:25:46 $
@
