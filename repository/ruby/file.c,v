head	1.114;
access;
symbols
	v1_6_7:1.41.2.26
	v1_6_6:1.41.2.26
	v1_6_5:1.41.2.24
	v1_6_4:1.41.2.12
	v1_7_1:1.57
	v1_6_4_preview4:1.41.2.11
	v1_6_4_preview3:1.41.2.11
	v1_6_4_preview2:1.41.2.10
	v1_6_4_preview1:1.41.2.9
	v1_6_3:1.41.2.4
	ruby_m17n:1.41.0.4
	ruby_1_6:1.41.0.2
	v1_6_2:1.41
	v1_6_1:1.37
	v1_6_0:1.32
	v1_4_6:1.4.2.7
	v1_4_5:1.4.2.6
	v1_4_4:1.4.2.5
	ruby_1_4_3:1.4.2.2
	ruby1_4_3:1.4.2.2
	v1_4_3:1.4.2.2
	v1_5_0:1.8
	ruby_1_4_3_pre1:1.4
	ruby_1_4:1.4.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.10
	v1_3_6_repack:1.1.1.3.2.9
	v1_3_6:1.1.1.3.2.9
	v1_3_5:1.1.1.3.2.8
	v1_2_6repack:1.1.1.2.2.30
	v1_3_4_990625:1.1.1.3.2.7
	v1_3_4_990624:1.1.1.3.2.7
	v1_2_6:1.1.1.2.2.30
	v1_3_4_990611:1.1.1.3.2.7
	v1_3_4_990531:1.1.1.3.2.7
	v1_3_3_990518:1.1.1.3.2.7
	v1_3_3_990513:1.1.1.3.2.7
	v1_3_3_990507:1.1.1.3.2.7
	v1_2_5:1.1.1.2.2.30
	v1_2_4:1.1.1.2.2.30
	v1_3_1_990225:1.1.1.3.2.5
	v1_3_1_990224:1.1.1.3.2.4
	v1_3_1_990215:1.1.1.3.2.3
	v1_3_1_990212:1.1.1.3.2.3
	v1_3_1_990210:1.1.1.3.2.2
	v1_3_1_:1.1.1.3.2.2
	v1_3_1_990209:1.1.1.3.2.2
	v1_3_1_990205:1.1.1.3.2.1
	v1_3_1_990203:1.1.1.3.2.1
	v1_3_1_990201:1.1.1.3.2.1
	v1_3_1"_990201:1.1.1.3.2.1
	v1_3_1_990128:1.1.1.3.2.1
	v1_3_1_990127:1.1.1.3.2.1
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.30
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.30
	v1_2_1repack:1.1.1.2.2.30
	v1_2_1:1.1.1.2.2.30
	v1_2_stable:1.1.1.2.2.30
	v1_1d1:1.1.1.2.2.30.2.3
	v1_1d0:1.1.1.2.2.30.2.3
	v1_1c9_1:1.1.1.2.2.30
	v1_1c9:1.1.1.2.2.30
	v1_1c8:1.1.1.2.2.30
	v1_1c7:1.1.1.2.2.30
	v1_1c6:1.1.1.2.2.30
	v1_1d-start:1.1.1.2.2.30.2.1
	v1_1c5:1.1.1.2.2.30
	v1_1dev:1.1.1.2.2.30.0.2
	v1_1c4:1.1.1.2.2.30
	v1_1c3:1.1.1.2.2.29
	v1_1c2:1.1.1.2.2.29
	v1_1c1:1.1.1.2.2.29
	v1_1c0:1.1.1.2.2.29
	v1_1b9_31:1.1.1.2.2.29
	v1_1b9_30:1.1.1.2.2.28
	v1_1b9_28:1.1.1.2.2.28
	v1_1b9_27:1.1.1.2.2.26
	v1_1b9_26:1.1.1.2.2.25
	r1_1b9_25:1.1.1.2.2.23
	r1_1b9_24:1.1.1.2.2.23
	v1_1b9_23:1.1.1.2.2.22
	v1_1b9_22:1.1.1.2.2.20
	v1_1b9_20:1.1.1.2.2.18
	v1_1b9_18:1.1.1.2.2.16
	v1_1b9_16:1.1.1.2.2.15
	v1_1b9_15:1.1.1.2.2.14
	v1_1b9_13:1.1.1.2.2.14
	v1_1b9_12:1.1.1.2.2.14
	v1_1b9_11:1.1.1.2.2.12
	v1_1b9_08:1.1.1.2.2.10
	v1_1b9_07:1.1.1.2.2.10
	r1_1b9:1.1.1.2.2.6
	v1_1b8:1.1.1.2.2.6
	v1_1b7:1.1.1.2.2.5
	v1_1b6:1.1.1.2.2.2
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.114
date	2002.10.29.21.35.27;	author knu;	state Exp;
branches;
next	1.113;

1.113
date	2002.09.06.08.59.38;	author matz;	state Exp;
branches;
next	1.112;

1.112
date	2002.09.05.20.52.48;	author nobu;	state Exp;
branches;
next	1.111;

1.111
date	2002.09.03.05.20.06;	author matz;	state Exp;
branches;
next	1.110;

1.110
date	2002.09.02.08.02.56;	author michal;	state Exp;
branches;
next	1.109;

1.109
date	2002.08.29.09.08.15;	author matz;	state Exp;
branches;
next	1.108;

1.108
date	2002.08.28.09.25.07;	author michal;	state Exp;
branches;
next	1.107;

1.107
date	2002.08.28.08.05.23;	author michal;	state Exp;
branches;
next	1.106;

1.106
date	2002.08.27.08.31.05;	author matz;	state Exp;
branches;
next	1.105;

1.105
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.104;

1.104
date	2002.08.20.10.42.33;	author eban;	state Exp;
branches;
next	1.103;

1.103
date	2002.08.12.07.39.07;	author matz;	state Exp;
branches;
next	1.102;

1.102
date	2002.06.11.01.27.46;	author H_Konishi;	state Exp;
branches;
next	1.101;

1.101
date	2002.05.29.05.20.32;	author matz;	state Exp;
branches;
next	1.100;

1.100
date	2002.05.14.06.22.25;	author matz;	state Exp;
branches;
next	1.99;

1.99
date	2002.05.01.09.41.49;	author matz;	state Exp;
branches;
next	1.98;

1.98
date	2002.04.24.04.54.13;	author matz;	state Exp;
branches;
next	1.97;

1.97
date	2002.04.18.08.46.17;	author matz;	state Exp;
branches;
next	1.96;

1.96
date	2002.04.10.08.45.22;	author matz;	state Exp;
branches;
next	1.95;

1.95
date	2002.03.20.09.43.15;	author matz;	state Exp;
branches;
next	1.94;

1.94
date	2002.03.14.06.23.43;	author matz;	state Exp;
branches;
next	1.93;

1.93
date	2002.02.22.10.28.45;	author matz;	state Exp;
branches;
next	1.92;

1.92
date	2002.02.19.08.13.26;	author nobu;	state Exp;
branches;
next	1.91;

1.91
date	2002.02.19.07.47.05;	author matz;	state Exp;
branches;
next	1.90;

1.90
date	2002.02.19.06.50.22;	author matz;	state Exp;
branches;
next	1.89;

1.89
date	2002.02.19.06.43.57;	author matz;	state Exp;
branches;
next	1.88;

1.88
date	2002.02.05.07.56.29;	author matz;	state Exp;
branches;
next	1.87;

1.87
date	2002.02.04.13.49.05;	author nobu;	state Exp;
branches;
next	1.86;

1.86
date	2002.02.04.08.07.01;	author matz;	state Exp;
branches;
next	1.85;

1.85
date	2002.02.01.06.02.59;	author matz;	state Exp;
branches;
next	1.84;

1.84
date	2002.01.29.09.15.59;	author akr;	state Exp;
branches;
next	1.83;

1.83
date	2002.01.29.07.16.04;	author matz;	state Exp;
branches;
next	1.82;

1.82
date	2002.01.23.07.30.39;	author matz;	state Exp;
branches;
next	1.81;

1.81
date	2001.12.18.08.46.56;	author matz;	state Exp;
branches;
next	1.80;

1.80
date	2001.11.19.05.03.03;	author matz;	state Exp;
branches;
next	1.79;

1.79
date	2001.11.13.08.19.51;	author matz;	state Exp;
branches;
next	1.78;

1.78
date	2001.11.08.09.21.59;	author matz;	state Exp;
branches;
next	1.77;

1.77
date	2001.11.08.06.43.08;	author matz;	state Exp;
branches;
next	1.76;

1.76
date	2001.10.29.05.07.17;	author matz;	state Exp;
branches;
next	1.75;

1.75
date	2001.10.10.08.21.13;	author matz;	state Exp;
branches;
next	1.74;

1.74
date	2001.10.03.07.19.10;	author matz;	state Exp;
branches;
next	1.73;

1.73
date	2001.09.19.06.54.10;	author matz;	state Exp;
branches;
next	1.72;

1.72
date	2001.09.08.14.17.09;	author matz;	state Exp;
branches;
next	1.71;

1.71
date	2001.09.05.22.31.07;	author nobu;	state Exp;
branches;
next	1.70;

1.70
date	2001.09.03.05.37.42;	author matz;	state Exp;
branches;
next	1.69;

1.69
date	2001.08.23.06.02.14;	author matz;	state Exp;
branches;
next	1.68;

1.68
date	2001.08.01.16.49.11;	author nobu;	state Exp;
branches;
next	1.67;

1.67
date	2001.07.31.06.24.42;	author matz;	state Exp;
branches;
next	1.66;

1.66
date	2001.07.30.22.41.59;	author nobu;	state Exp;
branches;
next	1.65;

1.65
date	2001.07.27.09.12.12;	author matz;	state Exp;
branches;
next	1.64;

1.64
date	2001.07.26.03.54.34;	author eban;	state Exp;
branches;
next	1.63;

1.63
date	2001.07.24.15.11.02;	author nobu;	state Exp;
branches;
next	1.62;

1.62
date	2001.07.24.09.07.33;	author matz;	state Exp;
branches;
next	1.61;

1.61
date	2001.07.18.05.55.20;	author matz;	state Exp;
branches;
next	1.60;

1.60
date	2001.07.16.04.22.46;	author usa;	state Exp;
branches;
next	1.59;

1.59
date	2001.07.14.15.17.18;	author matz;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.19.04.35.13;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.01.06.47.30;	author matz;	state Exp;
branches;
next	1.56;

1.56
date	2001.05.30.09.12.34;	author matz;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.11.05.24.54;	author matz;	state Exp;
branches;
next	1.54;

1.54
date	2001.05.02.04.22.10;	author matz;	state Exp;
branches;
next	1.53;

1.53
date	2001.03.28.08.43.24;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2001.03.26.08.57.09;	author matz;	state Exp;
branches;
next	1.51;

1.51
date	2001.03.21.03.51.23;	author matz;	state Exp;
branches;
next	1.50;

1.50
date	2001.03.21.03.41.41;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2001.03.19.03.20.21;	author matz;	state Exp;
branches;
next	1.48;

1.48
date	2001.02.24.17.51.02;	author eban;	state Exp;
branches;
next	1.47;

1.47
date	2001.02.16.07.53.19;	author matz;	state Exp;
branches;
next	1.46;

1.46
date	2001.02.09.15.02.14;	author usa;	state Exp;
branches;
next	1.45;

1.45
date	2001.02.08.09.19.17;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2001.01.29.05.10.41;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2001.01.10.07.52.45;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2001.01.09.08.04.39;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2000.11.13.05.39.32;	author matz;	state Exp;
branches
	1.41.2.1
	1.41.4.1;
next	1.40;

1.40
date	2000.10.17.18.13.55;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.13.09.01.54;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.10.07.03.17;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.25.09.14.59;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.22.03.37.26;	author eban;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.22.02.37.11;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.21.09.30.55;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.18.08.47.06;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.24.06.21.29;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.07.05.01.48;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.19.08.38.05;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.12.07.48.19;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.07.15.49.36;	author eban;	state Exp;
branches;
next	1.27;

1.27
date	2000.05.31.03.10.01;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.05.30.04.23.55;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.25.05.55.00;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.24.04.33.56;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.17.04.38.10;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.13.16.12.15;	author eban;	state Exp;
branches;
next	1.21;

1.21
date	2000.05.12.09.07.35;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.09.04.52.55;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.01.09.41.17;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.10.05.44.07;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.17.08.58.11;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.13.07.18.34;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.07.08.37.30;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.17.07.11.08;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.01.03.12.02;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.17.08.37.40;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.08.05.00.18;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.05.04.37.00;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	99.12.14.06.49.42;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.12.07.09.23.24;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.12.06.09.03.51;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.12.01.09.24.12;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.11.25.09.03.05;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.10.12.04.53.33;	author matz;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.09.16.09.40.32;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.05;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.10;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.23;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.12;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.09.06.08.20;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.12.11.17.03;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.02.24.04.31.20;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.02.25.06.39.07;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.03.24.08.52.28;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.04.09.17.57.39;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.07.15.07.59.45;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.07.28.09.26.39;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.08.06.06.48.17;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.08.06.13.23.18;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.45;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.20.06.10.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.01.29.03.22.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.02.09.10.56.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.02.10.08.44.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.02.18.01.56.39;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.03.11.07.32.55;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.03.30.09.32.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.03.30.09.41.15;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.04.02.10.03.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.04.14.04.55.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.04.16.07.42.43;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.04.17.09.29.33;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.04.20.05.55.36;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.04.27.10.03.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.05.12.08.38.39;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.05.13.05.57.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.05.13.07.26.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.05.18.04.56.02;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.05.18.05.57.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.05.25.09.42.24;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.05.26.08.24.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.06.02.10.05.21;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.06.16.04.23.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	98.06.18.07.46.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.26;

1.1.1.2.2.26
date	98.06.19.09.32.04;	author matz;	state Exp;
branches;
next	1.1.1.2.2.27;

1.1.1.2.2.27
date	98.06.24.04.37.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.28;

1.1.1.2.2.28
date	98.06.26.09.44.18;	author matz;	state Exp;
branches;
next	1.1.1.2.2.29;

1.1.1.2.2.29
date	98.07.13.04.37.36;	author matz;	state Exp;
branches;
next	1.1.1.2.2.30;

1.1.1.2.2.30
date	98.09.03.07.43.31;	author matz;	state Exp;
branches
	1.1.1.2.2.30.2.1;
next	;

1.1.1.2.2.30.2.1
date	98.09.08.07.08.44;	author matz;	state Exp;
branches;
next	1.1.1.2.2.30.2.2;

1.1.1.2.2.30.2.2
date	98.10.06.03.28.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.30.2.3;

1.1.1.2.2.30.2.3
date	98.11.25.03.31.13;	author matz;	state Exp;
branches;
next	;

1.4.2.1
date	99.12.01.09.24.45;	author matz;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	99.12.06.09.03.29;	author matz;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	99.12.08.00.37.33;	author matz;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2000.01.17.08.23.58;	author matz;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2000.02.01.03.11.20;	author matz;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2000.03.24.09.37.25;	author matz;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2000.07.24.07.16.04;	author matz;	state Exp;
branches;
next	;

1.41.2.1
date	2001.01.09.08.02.46;	author matz;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2001.02.08.09.17.57;	author matz;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2001.02.09.15.07.52;	author usa;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2001.02.24.17.50.14;	author eban;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2001.04.06.05.42.39;	author matz;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	2001.04.09.04.56.39;	author matz;	state Exp;
branches;
next	1.41.2.7;

1.41.2.7
date	2001.04.09.05.52.44;	author matz;	state Exp;
branches;
next	1.41.2.8;

1.41.2.8
date	2001.04.09.06.05.33;	author eban;	state Exp;
branches;
next	1.41.2.9;

1.41.2.9
date	2001.04.09.06.31.44;	author matz;	state Exp;
branches;
next	1.41.2.10;

1.41.2.10
date	2001.04.16.06.54.36;	author matz;	state Exp;
branches;
next	1.41.2.11;

1.41.2.11
date	2001.05.08.08.29.51;	author matz;	state Exp;
branches;
next	1.41.2.12;

1.41.2.12
date	2001.06.01.06.46.09;	author matz;	state Exp;
branches;
next	1.41.2.13;

1.41.2.13
date	2001.06.19.04.36.34;	author matz;	state Exp;
branches;
next	1.41.2.14;

1.41.2.14
date	2001.07.06.06.36.58;	author matz;	state Exp;
branches;
next	1.41.2.15;

1.41.2.15
date	2001.07.16.04.01.42;	author matz;	state Exp;
branches;
next	1.41.2.16;

1.41.2.16
date	2001.07.19.07.59.47;	author matz;	state Exp;
branches;
next	1.41.2.17;

1.41.2.17
date	2001.07.24.09.02.49;	author matz;	state Exp;
branches;
next	1.41.2.18;

1.41.2.18
date	2001.07.26.03.54.48;	author eban;	state Exp;
branches;
next	1.41.2.19;

1.41.2.19
date	2001.07.27.08.54.49;	author matz;	state Exp;
branches;
next	1.41.2.20;

1.41.2.20
date	2001.07.31.04.00.44;	author nobu;	state Exp;
branches;
next	1.41.2.21;

1.41.2.21
date	2001.08.23.06.00.30;	author matz;	state Exp;
branches;
next	1.41.2.22;

1.41.2.22
date	2001.09.03.05.29.18;	author matz;	state Exp;
branches;
next	1.41.2.23;

1.41.2.23
date	2001.09.06.03.05.02;	author nobu;	state Exp;
branches;
next	1.41.2.24;

1.41.2.24
date	2001.09.18.03.47.03;	author matz;	state Exp;
branches;
next	1.41.2.25;

1.41.2.25
date	2001.10.29.05.04.40;	author matz;	state Exp;
branches;
next	1.41.2.26;

1.41.2.26
date	2001.11.07.09.01.31;	author matz;	state Exp;
branches;
next	1.41.2.27;

1.41.2.27
date	2002.03.20.09.42.30;	author matz;	state Exp;
branches;
next	1.41.2.28;

1.41.2.28
date	2002.03.26.19.46.18;	author knu;	state Exp;
branches;
next	1.41.2.29;

1.41.2.29
date	2002.05.01.09.37.58;	author matz;	state Exp;
branches;
next	1.41.2.30;

1.41.2.30
date	2002.05.29.05.22.02;	author matz;	state Exp;
branches;
next	1.41.2.31;

1.41.2.31
date	2002.08.20.10.42.57;	author eban;	state Exp;
branches;
next	1.41.2.32;

1.41.2.32
date	2002.09.05.20.53.31;	author nobu;	state Exp;
branches;
next	1.41.2.33;

1.41.2.33
date	2002.09.25.07.07.37;	author matz;	state Exp;
branches;
next	1.41.2.34;

1.41.2.34
date	2002.10.26.15.57.23;	author knu;	state Exp;
branches;
next	;

1.41.4.1
date	2001.01.12.04.36.00;	author matz;	state Exp;
branches;
next	;


desc
@@


1.114
log
@* eval.c, file.c, gc.c, io.c, object.c, ruby.c, ruby.h, struct.c,
  ext/socket/socket.c: differentiate long and int; use proper
  printf type specifiers and do casts where appropriate.
@
text
@/**********************************************************************

  file.c -

  $Author: matz $
  $Date: 2002/09/06 08:59:38 $
  created at: Mon Nov 15 12:24:34 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#ifdef NT
#include "missing/file.h"
#endif

#include "ruby.h"
#include "rubyio.h"
#include "rubysig.h"
#include "util.h"
#include "dln.h"

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef HAVE_SYS_FILE_H
# include <sys/file.h>
#else
int flock _((int, int));
#endif

#ifdef HAVE_SYS_PARAM_H
# include <sys/param.h>
#else
# define MAXPATHLEN 1024
#endif

#include <time.h>
#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
#else
#ifndef NT
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};
#endif /* NT */
#endif

VALUE rb_time_new _((time_t, time_t));

#ifdef HAVE_UTIME_H
#include <utime.h>
#endif

#ifdef HAVE_PWD_H
#include <pwd.h>
#endif

#ifndef HAVE_STRING_H
char *strrchr _((const char*,const char));
#endif

#include <sys/types.h>
#include <sys/stat.h>

#ifdef HAVE_SYS_MKDEV_H
#include <sys/mkdev.h>
#endif

#ifndef HAVE_LSTAT
#define lstat(path,st) stat(path,st)
#endif

VALUE rb_cFile;
VALUE rb_mFileTest;
static VALUE rb_cStat;

static long
apply2files(func, vargs, arg)
    void (*func)();
    VALUE vargs;
    void *arg;
{
    long i;
    VALUE path;
    struct RArray *args = RARRAY(vargs);

    for (i=0; i<args->len; i++) {
	path = args->ptr[i];
	SafeStringValue(path);
	(*func)(RSTRING(path)->ptr, arg);
    }

    return args->len;
}

static VALUE
rb_file_path(obj)
    VALUE obj;
{
    OpenFile *fptr;

    GetOpenFile(obj, fptr);
    if (!fptr->path) return Qnil;
    return rb_str_new2(fptr->path);
}

#ifdef NT
#include "missing/file.h"
#endif

static VALUE
stat_new_0(klass, st)
    VALUE klass;
    struct stat *st;
{
    struct stat *nst = 0;

    if (st) {
	nst = ALLOC(struct stat);
	*nst = *st;
    }
    return Data_Wrap_Struct(klass, NULL, free, nst);
}

static VALUE
stat_new(st)
    struct stat *st;
{
    return stat_new_0(rb_cStat, st);
}

static struct stat*
get_stat(self)
    VALUE self;
{
    struct stat* st;
    Data_Get_Struct(self, struct stat, st);
    if (!st) rb_raise(rb_eTypeError, "uninitialized File::Stat");
    return st;
}

static VALUE
rb_stat_cmp(self, other)
    VALUE self, other;
{
    if (rb_obj_is_kind_of(other, rb_obj_class(self))) {
	time_t t1 = get_stat(self)->st_mtime;
	time_t t2 = get_stat(other)->st_mtime;
	if (t1 == t2)
	    return INT2FIX(0);
	else if (t1 < t2)
	    return INT2FIX(-1);
	else
	    return INT2FIX(1);
    }
    rb_raise(rb_eTypeError, "operand is not File::Stat");
}

static VALUE
rb_stat_dev(self)
    VALUE self;
{
    return INT2NUM(get_stat(self)->st_dev);
}

static VALUE
rb_stat_ino(self)
    VALUE self;
{
    return ULONG2NUM(get_stat(self)->st_ino);
}

static VALUE
rb_stat_mode(self)
    VALUE self;
{
#ifdef __BORLANDC__
    return UINT2NUM((unsigned short)(get_stat(self)->st_mode));
#else
     return UINT2NUM(get_stat(self)->st_mode);
#endif
}

static VALUE
rb_stat_nlink(self)
    VALUE self;
{
    return UINT2NUM(get_stat(self)->st_nlink);
}

static VALUE
rb_stat_uid(self)
    VALUE self;
{
    return UINT2NUM(get_stat(self)->st_uid);
}

static VALUE
rb_stat_gid(self)
    VALUE self;
{
    return UINT2NUM(get_stat(self)->st_gid);
}

static VALUE
rb_stat_rdev(self)
    VALUE self;
{
#ifdef HAVE_ST_RDEV
    return ULONG2NUM(get_stat(self)->st_rdev);
#else
    return Qnil;
#endif
}

static VALUE
rb_stat_rdev_major(self)
    VALUE self;
{
#if defined(HAVE_ST_RDEV) && defined(major)
    long rdev = get_stat(self)->st_rdev;
    return ULONG2NUM(major(rdev));
#else
    return Qnil;
#endif
}

static VALUE
rb_stat_rdev_minor(self)
    VALUE self;
{
#if defined(HAVE_ST_RDEV) && defined(minor)
    long rdev = get_stat(self)->st_rdev;
    return ULONG2NUM(minor(rdev));
#else
    return Qnil;
#endif
}

static VALUE
rb_stat_size(self)
    VALUE self;
{
    return OFFT2NUM(get_stat(self)->st_size);
}

static VALUE
rb_stat_blksize(self)
    VALUE self;
{
#ifdef HAVE_ST_BLKSIZE
    return ULONG2NUM(get_stat(self)->st_blksize);
#else
    return Qnil;
#endif
}

static VALUE
rb_stat_blocks(self)
    VALUE self;
{
#ifdef HAVE_ST_BLOCKS
    return ULONG2NUM(get_stat(self)->st_blocks);
#else
    return Qnil;
#endif
}

static VALUE
rb_stat_atime(self)
    VALUE self;
{
    return rb_time_new(get_stat(self)->st_atime, 0);
}

static VALUE
rb_stat_mtime(self)
    VALUE self;
{
    return rb_time_new(get_stat(self)->st_mtime, 0);
}

static VALUE
rb_stat_ctime(self)
    VALUE self;
{
    return rb_time_new(get_stat(self)->st_ctime, 0);
}

static VALUE
rb_stat_inspect(self)
    VALUE self;
{
    VALUE str;
    int i;
    static struct {
        char *name;
        VALUE (*func)();
    } member[] = {
        {"dev",     rb_stat_dev},
        {"ino",     rb_stat_ino},
        {"mode",    rb_stat_mode},
        {"nlink",   rb_stat_nlink},
        {"uid",     rb_stat_uid},
        {"gid",     rb_stat_gid},
        {"rdev",    rb_stat_rdev},
        {"size",    rb_stat_size},
        {"blksize", rb_stat_blksize},
        {"blocks",  rb_stat_blocks},
        {"atime",   rb_stat_atime},
        {"mtime",   rb_stat_mtime},
        {"ctime",   rb_stat_ctime},
    };

    str = rb_str_buf_new2("#<");
    rb_str_buf_cat2(str, rb_class2name(CLASS_OF(self)));
    rb_str_buf_cat2(str, " ");

    for (i = 0; i < sizeof(member)/sizeof(member[0]); i++) {
	VALUE v;

	if (i > 0) {
	    rb_str_buf_cat2(str, ", ");
	}
	rb_str_buf_cat2(str, member[i].name);
	rb_str_buf_cat2(str, "=");
	v = (*member[i].func)(self);
	if (i == 2) {		/* mode */
	    char buf[32];

	    sprintf(buf, "0%o", NUM2INT(v));
	    rb_str_buf_cat2(str, buf);
	}
	else if (i == 0 || i == 6) { /* dev/rdev */
	    char buf[32];

	    sprintf(buf, "0x%lx", NUM2ULONG(v));
	    rb_str_buf_cat2(str, buf);
	}
	else {
	    rb_str_append(str, rb_inspect(v));
	}
    }
    rb_str_buf_cat2(str, ">");
    OBJ_INFECT(str, self);

    return str;
}

static int
rb_stat(file, st)
    VALUE file;
    struct stat *st;
{
    if (TYPE(file) == T_FILE) {
	OpenFile *fptr;

	rb_secure(2);
	GetOpenFile(file, fptr);
	return fstat(fileno(fptr->f), st);
    }
    SafeStringValue(file);
#if defined DJGPP
    if (RSTRING(file)->len == 0) return -1;
#endif
    return stat(RSTRING(file)->ptr, st);
}

static VALUE
rb_file_s_stat(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    SafeStringValue(fname);
    if (stat(RSTRING(fname)->ptr, &st) == -1) {
	rb_sys_fail(RSTRING(fname)->ptr);
    }
    return stat_new(&st);
}

static VALUE
rb_io_stat(obj)
    VALUE obj;
{
    OpenFile *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fileno(fptr->f), &st) == -1) {
	rb_sys_fail(fptr->path);
    }
    return stat_new(&st);
}

static VALUE
rb_file_s_lstat(klass, fname)
    VALUE klass, fname;
{
#ifdef HAVE_LSTAT
    struct stat st;

    SafeStringValue(fname);
    if (lstat(RSTRING(fname)->ptr, &st) == -1) {
	rb_sys_fail(RSTRING(fname)->ptr);
    }
    return stat_new(&st);
#else
    return rb_file_s_stat(klass, fname);
#endif
}

static VALUE
rb_file_lstat(obj)
    VALUE obj;
{
#ifdef HAVE_LSTAT
    OpenFile *fptr;
    struct stat st;

    rb_secure(2);
    GetOpenFile(obj, fptr);
    if (!fptr->path) return Qnil;
    if (lstat(fptr->path, &st) == -1) {
	rb_sys_fail(fptr->path);
    }
    return stat_new(&st);
#else
    return rb_io_stat(obj);
#endif
}

static int
group_member(gid)
    GETGROUPS_T gid;
{
#if !defined(NT)
    if (getgid() ==  gid)
	return Qtrue;

# ifdef HAVE_GETGROUPS
#  ifndef NGROUPS
#   ifdef NGROUPS_MAX
#    define NGROUPS NGROUPS_MAX
#   else
#    define NGROUPS 32
#   endif
#  endif
    {
	GETGROUPS_T gary[NGROUPS];
	int anum;

	anum = getgroups(NGROUPS, gary);
	while (--anum >= 0)
	    if (gary[anum] == gid)
		return Qtrue;
    }
# endif
#endif
    return Qfalse;
}

#ifndef S_IXUGO
#  define S_IXUGO		(S_IXUSR | S_IXGRP | S_IXOTH)
#endif

int
eaccess(path, mode)
     const char *path;
     int mode;
{
#ifdef S_IXGRP
    struct stat st;
    int euid;

    if (stat(path, &st) < 0) return -1;

    euid = geteuid();

    if (euid == 0) {
	/* Root can read or write any file. */
	if (!(mode & X_OK))
	    return 0;

	/* Root can execute any file that has any one of the execute
	   bits set. */
	if (st.st_mode & S_IXUGO)
	    return 0;

	return -1;
    }

    if (st.st_uid == euid)        /* owner */
	mode <<= 6;
    else if (getegid() == st.st_gid || group_member(st.st_gid))
	mode <<= 3;

    if ((st.st_mode & mode) == mode) return 0;

    return -1;
#else
    return access(path, mode);
#endif
}

static VALUE
test_d(obj, fname)
    VALUE obj, fname;
{
#ifndef S_ISDIR
#   define S_ISDIR(m) ((m & S_IFMT) == S_IFDIR)
#endif

    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISDIR(st.st_mode)) return Qtrue;
    return Qfalse;
}

static VALUE
test_p(obj, fname)
    VALUE obj, fname;
{
#ifdef S_IFIFO
#  ifndef S_ISFIFO
#    define S_ISFIFO(m) ((m & S_IFMT) == S_IFIFO)
#  endif

    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISFIFO(st.st_mode)) return Qtrue;

#endif
    return Qfalse;
}

static VALUE
test_l(obj, fname)
    VALUE obj, fname;
{
#ifndef S_ISLNK
#  ifdef _S_ISLNK
#    define S_ISLNK(m) _S_ISLNK(m)
#  elif defined __BORLANDC__
#    ifdef _S_IFLNK
#      define S_ISLNK(m) (((unsigned short)(m) & S_IFMT) == _S_IFLNK)
#    else
#      ifdef S_IFLNK
#        define S_ISLNK(m) (((unsigned short)(m) & S_IFMT) == S_IFLNK)
#      endif
#    endif
#  else
#    ifdef _S_IFLNK
#      define S_ISLNK(m) ((m & S_IFMT) == _S_IFLNK)
#    else
#      ifdef S_IFLNK
#	 define S_ISLNK(m) ((m & S_IFMT) == S_IFLNK)
#      endif
#    endif
#  endif
#endif

#ifdef S_ISLNK
    struct stat st;

    SafeStringValue(fname);
    if (lstat(RSTRING(fname)->ptr, &st) < 0) return Qfalse;
    if (S_ISLNK(st.st_mode)) return Qtrue;
#endif

    return Qfalse;
}

static VALUE
test_S(obj, fname)
    VALUE obj, fname;
{
#ifndef S_ISSOCK
#  ifdef _S_ISSOCK
#    define S_ISSOCK(m) _S_ISSOCK(m)
#  elif defined __BORLANDC__
#    ifdef _S_IFSOCK
#      define S_ISSOCK(m) (((unsigned short)(m) & S_IFMT) == _S_IFSOCK)
#    else
#      ifdef S_IFSOCK
#        define S_ISSOCK(m) (((unsigned short)(m) & S_IFMT) == S_IFSOCK)
#      endif
#    endif
#  else
#    ifdef _S_IFSOCK
#      define S_ISSOCK(m) ((m & S_IFMT) == _S_IFSOCK)
#    else
#      ifdef S_IFSOCK
#	 define S_ISSOCK(m) ((m & S_IFMT) == S_IFSOCK)
#      endif
#    endif
#  endif
#endif

#ifdef S_ISSOCK
    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISSOCK(st.st_mode)) return Qtrue;

#endif
    return Qfalse;
}

static VALUE
test_b(obj, fname)
    VALUE obj, fname;
{
#ifndef S_ISBLK
#   ifdef S_IFBLK
#	define S_ISBLK(m) ((m & S_IFMT) == S_IFBLK)
#   else
#	define S_ISBLK(m) (0)  /* anytime false */
#   endif
#endif

#ifdef S_ISBLK
    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISBLK(st.st_mode)) return Qtrue;

#endif
    return Qfalse;
}

static VALUE
test_c(obj, fname)
    VALUE obj, fname;
{
#ifndef S_ISCHR
#   define S_ISCHR(m) ((m & S_IFMT) == S_IFCHR)
#endif

    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISCHR(st.st_mode)) return Qtrue;

    return Qfalse;
}

static VALUE
test_e(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qfalse;
    return Qtrue;
}

static VALUE
test_r(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (eaccess(RSTRING(fname)->ptr, R_OK) < 0) return Qfalse;
    return Qtrue;
}

static VALUE
test_R(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (access(RSTRING(fname)->ptr, R_OK) < 0) return Qfalse;
    return Qtrue;
}

static VALUE
test_w(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (eaccess(RSTRING(fname)->ptr, W_OK) < 0) return Qfalse;
    return Qtrue;
}

static VALUE
test_W(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (access(RSTRING(fname)->ptr, W_OK) < 0) return Qfalse;
    return Qtrue;
}

static VALUE
test_x(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (eaccess(RSTRING(fname)->ptr, X_OK) < 0) return Qfalse;
    return Qtrue;
}

static VALUE
test_X(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (access(RSTRING(fname)->ptr, X_OK) < 0) return Qfalse;
    return Qtrue;
}

#ifndef S_ISREG
#   define S_ISREG(m) ((m & S_IFMT) == S_IFREG)
#endif

static VALUE
test_f(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISREG(st.st_mode)) return Qtrue;
    return Qfalse;
}

static VALUE
test_z(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_size == 0) return Qtrue;
    return Qfalse;
}

static VALUE
test_s(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qnil;
    if (st.st_size == 0) return Qnil;
    return OFFT2NUM(st.st_size);
}

static VALUE
test_owned(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_uid == geteuid()) return Qtrue;
    return Qfalse;
}

static VALUE
test_rowned(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_uid == getuid()) return Qtrue;
    return Qfalse;
}

static VALUE
test_grpowned(obj, fname)
    VALUE obj, fname;
{
#ifndef NT
    struct stat st;

    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_gid == getegid()) return Qtrue;
#endif
    return Qfalse;
}

#if defined(S_ISUID) || defined(S_ISGID) || defined(S_ISVTX)
static VALUE
check3rdbyte(fname, mode)
    VALUE fname;
    int mode;
{
    struct stat st;

    SafeStringValue(fname);
    if (stat(RSTRING(fname)->ptr, &st) < 0) return Qfalse;
    if (st.st_mode & mode) return Qtrue;
    return Qfalse;
}
#endif

static VALUE
test_suid(obj, fname)
    VALUE obj, fname;
{
#ifdef S_ISUID
    return check3rdbyte(fname, S_ISUID);
#else
    return Qfalse;
#endif
}

static VALUE
test_sgid(obj, fname)
    VALUE obj, fname;
{
#ifdef S_ISGID
    return check3rdbyte(fname, S_ISGID);
#else
    return Qfalse;
#endif
}

static VALUE
test_sticky(obj, fname)
    VALUE obj, fname;
{
#ifdef S_ISVTX
    return check3rdbyte(fname, S_ISVTX);
#else
    return Qnil;
#endif
}

static VALUE
rb_file_s_size(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    if (rb_stat(fname, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
    return OFFT2NUM(st.st_size);
}

static VALUE
rb_file_ftype(st)
    struct stat *st;
{
    char *t;

    if (S_ISREG(st->st_mode)) {
	t = "file";
    }
    else if (S_ISDIR(st->st_mode)) {
	t = "directory";
    }
    else if (S_ISCHR(st->st_mode)) {
	t = "characterSpecial";
    }
#ifdef S_ISBLK
    else if (S_ISBLK(st->st_mode)) {
	t = "blockSpecial";
    }
#endif
#ifdef S_ISFIFO
    else if (S_ISFIFO(st->st_mode)) {
	t = "fifo";
    }
#endif
#ifdef S_ISLNK
    else if (S_ISLNK(st->st_mode)) {
	t = "link";
    }
#endif
#ifdef S_ISSOCK
    else if (S_ISSOCK(st->st_mode)) {
	t = "socket";
    }
#endif
    else {
	t = "unknown";
    }

    return rb_str_new2(t);
}

static VALUE
rb_file_s_ftype(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    SafeStringValue(fname);
    if (lstat(RSTRING(fname)->ptr, &st) == -1) {
	rb_sys_fail(RSTRING(fname)->ptr);
    }

    return rb_file_ftype(&st);
}

static VALUE
rb_file_s_atime(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    if (rb_stat(fname, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
    return rb_time_new(st.st_atime, 0);
}

static VALUE
rb_file_atime(obj)
    VALUE obj;
{
    OpenFile *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fileno(fptr->f), &st) == -1) {
	rb_sys_fail(fptr->path);
    }
    return rb_time_new(st.st_atime, 0);
}

static VALUE
rb_file_s_mtime(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    if (rb_stat(fname, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
    return rb_time_new(st.st_mtime, 0);
}

static VALUE
rb_file_mtime(obj)
    VALUE obj;
{
    OpenFile *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fileno(fptr->f), &st) == -1) {
	rb_sys_fail(fptr->path);
    }
    return rb_time_new(st.st_mtime, 0);
}

static VALUE
rb_file_s_ctime(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    if (rb_stat(fname, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
    return rb_time_new(st.st_ctime, 0);
}

static VALUE
rb_file_ctime(obj)
    VALUE obj;
{
    OpenFile *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fileno(fptr->f), &st) == -1) {
	rb_sys_fail(fptr->path);
    }
    return rb_time_new(st.st_ctime, 0);
}

static void
chmod_internal(path, mode)
    const char *path;
    int mode;
{
    if (chmod(path, mode) < 0)
	rb_sys_fail(path);
}

static VALUE
rb_file_s_chmod(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE vmode;
    VALUE rest;
    int mode;
    long n;

    rb_secure(2);
    rb_scan_args(argc, argv, "1*", &vmode, &rest);
    mode = NUM2INT(vmode);

    n = apply2files(chmod_internal, rest, mode);
    return LONG2FIX(n);
}

static VALUE
rb_file_chmod(obj, vmode)
    VALUE obj, vmode;
{
    OpenFile *fptr;
    int mode;

    rb_secure(2);
    mode = NUM2INT(vmode);

    GetOpenFile(obj, fptr);
#ifdef HAVE_FCHMOD
    if (fchmod(fileno(fptr->f), mode) == -1)
	rb_sys_fail(fptr->path);
#else
    if (!fptr->path) return Qnil;
    if (chmod(fptr->path, mode) == -1)
	rb_sys_fail(fptr->path);
#endif

    return INT2FIX(0);
}

#if defined(HAVE_LCHMOD)
static void
lchmod_internal(path, mode)
    const char *path;
    int mode;
{
    if (lchmod(path, mode) < 0)
	rb_sys_fail(path);
}

static VALUE
rb_file_s_lchmod(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE vmode;
    VALUE rest;
    int mode;
    long n;

    rb_secure(2);
    rb_scan_args(argc, argv, "1*", &vmode, &rest);
    mode = NUM2INT(vmode);

    n = apply2files(lchmod_internal, rest, mode);
    return LONG2FIX(n);
}
#else
static VALUE
rb_file_s_lchmod(argc, argv)
    int argc;
    VALUE *argv;
{
    rb_notimplement();
}
#endif

struct chown_args {
    int owner, group;
};

static void
chown_internal(path, args)
    const char *path;
    struct chown_args *args;
{
    if (chown(path, args->owner, args->group) < 0)
	rb_sys_fail(path);
}

static VALUE
rb_file_s_chown(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE o, g, rest;
    struct chown_args arg;
    long n;

    rb_secure(2);
    rb_scan_args(argc, argv, "2*", &o, &g, &rest);
    if (NIL_P(o)) {
	arg.owner = -1;
    }
    else {
	arg.owner = NUM2INT(o);
    }
    if (NIL_P(g)) {
	arg.group = -1;
    }
    else {
	arg.group = NUM2INT(g);
    }

    n = apply2files(chown_internal, rest, &arg);
    return LONG2FIX(n);
}

static VALUE
rb_file_chown(obj, owner, group)
    VALUE obj, owner, group;
{
    OpenFile *fptr;

    rb_secure(2);
    GetOpenFile(obj, fptr);
#if defined(DJGPP) || defined(__CYGWIN32__) || defined(NT) || defined(__EMX__)
    if (!fptr->path) return Qnil;
    if (chown(fptr->path, NUM2INT(owner), NUM2INT(group)) == -1)
	rb_sys_fail(fptr->path);
#else
    if (fchown(fileno(fptr->f), NUM2INT(owner), NUM2INT(group)) == -1)
	rb_sys_fail(fptr->path);
#endif

    return INT2FIX(0);
}

#if defined(HAVE_LCHOWN) && !defined(__CHECKER__)
static void
lchown_internal(path, args)
    const char *path;
    struct chown_args *args;
{
    if (lchown(path, args->owner, args->group) < 0)
	rb_sys_fail(path);
}

static VALUE
rb_file_s_lchown(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE o, g, rest;
    struct chown_args arg;
    long n;

    rb_secure(2);
    rb_scan_args(argc, argv, "2*", &o, &g, &rest);
    if (NIL_P(o)) {
	arg.owner = -1;
    }
    else {
	arg.owner = NUM2INT(o);
    }
    if (NIL_P(g)) {
	arg.group = -1;
    }
    else {
	arg.group = NUM2INT(g);
    }

    n = apply2files(lchown_internal, rest, &arg);
    return LONG2FIX(n);
}
#else
static VALUE
rb_file_s_lchown(argc, argv)
    int argc;
    VALUE *argv;
{
    rb_notimplement();
}
#endif

struct timeval rb_time_timeval();

#if defined(HAVE_UTIMES) && !defined(__CHECKER__)

static void
utime_internal(path, tvp)
    char *path;
    struct timeval tvp[];
{
    if (utimes(path, tvp) < 0)
	rb_sys_fail(path);
}

static VALUE
rb_file_s_utime(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE atime, mtime, rest;
    struct timeval tvp[2];
    long n;

    rb_scan_args(argc, argv, "2*", &atime, &mtime, &rest);

    tvp[0] = rb_time_timeval(atime);
    tvp[1] = rb_time_timeval(mtime);

    n = apply2files(utime_internal, rest, tvp);
    return LONG2FIX(n);
}

#else

#ifndef HAVE_UTIME_H
# ifdef NT
#   if defined(__BORLANDC__)
#     include <utime.h>
#   else
#  include <sys/utime.h>
#   endif
#   if defined(_MSC_VER) || defined __MINGW32__
#  define utimbuf _utimbuf
#   endif
# else
struct utimbuf {
    long actime;
    long modtime;
};
# endif
#endif

static void
utime_internal(path, utp)
    const char *path;
    struct utimbuf *utp;
{
    if (utime(path, utp) < 0)
	rb_sys_fail(path);
}

static VALUE
rb_file_s_utime(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE atime, mtime, rest;
    long n;
    struct timeval tv;
    struct utimbuf utbuf;

    rb_scan_args(argc, argv, "2*", &atime, &mtime, &rest);

    tv = rb_time_timeval(atime);
    utbuf.actime = tv.tv_sec;
    tv = rb_time_timeval(mtime);
    utbuf.modtime = tv.tv_sec;

    n = apply2files(utime_internal, rest, &utbuf);
    return LONG2FIX(n);
}

#endif

static VALUE
rb_file_s_link(klass, from, to)
    VALUE klass, from, to;
{
    SafeStringValue(from);
    SafeStringValue(to);

    if (link(RSTRING(from)->ptr, RSTRING(to)->ptr) < 0)
	rb_sys_fail(RSTRING(from)->ptr);
    return INT2FIX(0);
}

static VALUE
rb_file_s_symlink(klass, from, to)
    VALUE klass, from, to;
{
#ifdef HAVE_SYMLINK
    SafeStringValue(from);
    SafeStringValue(to);

    if (symlink(RSTRING(from)->ptr, RSTRING(to)->ptr) < 0)
	rb_sys_fail(RSTRING(from)->ptr);
    return INT2FIX(0);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

static VALUE
rb_file_s_readlink(klass, path)
    VALUE klass, path;
{
#ifdef HAVE_READLINK
    char *buf;
    int size = 100;
    int rv;
    VALUE v;

    SafeStringValue(path);
    buf = xmalloc(size);
    if ((rv = readlink(RSTRING(path)->ptr, buf, size)) == size) {
	size *= 2;
	buf = xrealloc(buf, size);
    }
    if (rv < 0) {
	free(buf);
	rb_sys_fail(RSTRING(path)->ptr);
    }
    v = rb_tainted_str_new(buf, rv);
    free(buf);

    return v;
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

static void
unlink_internal(path)
    const char *path;
{
    if (unlink(path) < 0)
	rb_sys_fail(path);
}

static VALUE
rb_file_s_unlink(klass, args)
    VALUE klass, args;
{
    long n;

    rb_secure(2);
    n = apply2files(unlink_internal, args, 0);
    return LONG2FIX(n);
}

static VALUE
rb_file_s_rename(klass, from, to)
    VALUE klass, from, to;
{
    SafeStringValue(from);
    SafeStringValue(to);

    if (rename(RSTRING(from)->ptr, RSTRING(to)->ptr) < 0) {
#if defined __CYGWIN__
	extern unsigned long __attribute__((stdcall)) GetLastError();
	errno = GetLastError(); /* This is a Cygwin bug */
#endif
	rb_sys_fail(RSTRING(from)->ptr);
    }

    return INT2FIX(0);
}

static VALUE
rb_file_s_umask(argc, argv)
    int argc;
    VALUE *argv;
{
    int omask = 0;

    rb_secure(2);
    if (argc == 0) {
	omask = umask(0);
	umask(omask);
    }
    else if (argc == 1) {
	omask = umask(NUM2INT(argv[0]));
    }
    else {
	rb_raise(rb_eArgError, "wrong number of argument");
    }
    return INT2FIX(omask);
}

#if defined DOSISH
#define isdirsep(x) ((x) == '/' || (x) == '\\')
#else
#define isdirsep(x) ((x) == '/')
#endif
#ifndef CharNext		/* defined as CharNext[AW] on Windows. */
# if defined(DJGPP)
#   define CharNext(p) ((p) + mblen(p, MB_CUR_MAX))
# else
#   define CharNext(p) ((p) + 1)
# endif
#endif

static char *
strrdirsep(path)
    char *path;
{
    char *last = NULL;
    while (*path) {
	if (isdirsep(*path)) {
	    last = path++;
	}
	else {
	    path = CharNext(path);
	}
    }
    return last;
}

#define BUFCHECK(cond) while (cond) {\
    long bdiff = p - buf;\
    buflen *= 2;\
    rb_str_resize(result, buflen);\
    buf = RSTRING(result)->ptr;\
    p = buf + bdiff;\
    pend = buf + buflen;\
}

VALUE
rb_file_s_expand_path(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE fname, dname, result;
    char *s, *buf, *b, *p, *pend;
    long buflen = MAXPATHLEN;
    int tainted;

    rb_scan_args(argc, argv, "11", &fname, &dname);
    result = rb_str_new(0, buflen + 2);

    s = StringValuePtr(fname);
    p = buf = RSTRING(result)->ptr;
    pend = p + buflen;
    tainted = OBJ_TAINTED(fname);

    if (s[0] == '~') {
	if (isdirsep(s[1]) || s[1] == '\0') {
	    char *dir = getenv("HOME");

	    if (!dir) {
		rb_raise(rb_eArgError, "couldn't find HOME environment -- expanding `%s'", s);
	    }
	    BUFCHECK (strlen(dir) > buflen);
	    strcpy(buf, dir);
	    p = buf + strlen(dir);
	    s++;
	    tainted = 1;
	}
	else {
#ifdef HAVE_PWD_H
	    struct passwd *pwPtr;
	    s++;
#endif
	    b = s;
	    while (*s && !isdirsep(*s)) {
		s = CharNext(s);
	    }
	    BUFCHECK (p + (s-b) >= pend);
	    memcpy(p, b, s-b);
	    p += s-b;
	    *p = '\0';
#ifdef HAVE_PWD_H
	    pwPtr = getpwnam(buf);
	    if (!pwPtr) {
		endpwent();
		rb_raise(rb_eArgError, "user %s doesn't exist", buf);
	    }
	    BUFCHECK (strlen(pwPtr->pw_dir) > buflen);
	    strcpy(buf, pwPtr->pw_dir);
	    p = buf + strlen(pwPtr->pw_dir);
	    endpwent();
#endif
	}
    }
#if defined DOSISH || defined __CYGWIN__
    /* skip drive letter */
    else if (ISALPHA(s[0]) && s[1] == ':' && isdirsep(s[2])) {
	b = s;
	while (*s && !isdirsep(*s)) {
	    s = CharNext(s);
	}
	BUFCHECK (p + (s-b) >= pend);
	memcpy(p, b, s-b);
	p += s-b;
    }
#endif
    else if (!isdirsep(*s)) {
	if (!NIL_P(dname)) {
	    dname = rb_file_s_expand_path(1, &dname);
	    if (OBJ_TAINTED(dname)) tainted = 1;
	    BUFCHECK (RSTRING(dname)->len > buflen);
	    memcpy(buf, RSTRING(dname)->ptr, RSTRING(dname)->len);
	    p += RSTRING(dname)->len;
	}
	else {
	    char *dir = my_getcwd();

	    tainted = 1;
	    BUFCHECK (strlen(dir) > buflen);
	    strcpy(buf, dir);
	    free(dir);
	    p = &buf[strlen(buf)];
	}
	while (p > buf && *(p - 1) == '/') p--;
    }
    else {
	while (*s && isdirsep(*s)) {
	    *p++ = '/';
	    BUFCHECK (p >= pend);
	    s++;
	}
	if (p > buf && *s) p--;
    }
    *p = '/';

    b = s;
    while (*s) {
	switch (*s) {
	  case '.':
	    if (b == s++) {	/* beginning of path element */
		switch (*s) {
		  case '\0':
		    b = s;
		    break;
		  case '.':
		    if (*(s+1) == '\0' || isdirsep(*(s+1))) {
			/* We must go back to the parent */
			*p = '\0';
			if (!(b = strrdirsep(buf))) {
			    *p = '/';
			}
			else {
			    p = b;
			}
			b = ++s;
		    }
		    break;
		  case '/':
#if defined DOSISH
		  case '\\':
#endif
		    b = ++s;
		    break;
		  default:
		    /* ordinary path element, beginning don't move */
		    break;
		}
	    }
	    break;
	  case '/':
#if defined DOSISH
	  case '\\':
#endif
	    if (s > b) {
		BUFCHECK (p + (s-b+1) >= pend);
		memcpy(++p, b, s-b);
		p += s-b;
		*p = '/';
	    }
	    b = ++s;
	    break;
	  default:
	    s = CharNext(s);
	    break;
	}
    }

    if (s > b) {
	BUFCHECK (p + (s-b) >= pend);
	memcpy(++p, b, s-b);
	p += s-b;
    }
#if defined DOSISH || defined __CYGWIN__
    else if (ISALPHA(buf[0]) && (buf[1] == ':') && isdirsep(buf[2])) {
	/* root directory needs a trailing backslash,
	   otherwise it mean the current directory of the drive */
	if (p == (buf+2)) p++;
    }
    else if (isdirsep(buf[0]) && isdirsep(buf[1])) {
	if (p == (buf+1)) p++;
    }
#endif

    if (tainted) OBJ_TAINT(result);
    RSTRING(result)->len = p - buf;
    *p = '\0';
    return result;
}

static int
rmext(p, e)
    const char *p, *e;
{
    int l1, l2;

    if (!e) return 0;

    l1 = strlen(p);
    l2 = strlen(e);
    if (l2 == 2 && e[1] == '*') {
	e = strrchr(p, *e);
	if (!e) return 0;
	return e - p;
    }
    if (l1 < l2) return l1;

    if (strcmp(p+l1-l2, e) == 0) {
	return l1-l2;
    }
    return 0;
}

static VALUE
rb_file_s_basename(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE fname, fext, basename;
    char *name, *p, *ext = NULL;
    int f;

    if (rb_scan_args(argc, argv, "11", &fname, &fext) == 2) {
	ext = StringValuePtr(fext);
    }
    name = StringValuePtr(fname);
    p = strrdirsep(name);
    if (!p) {
	if (NIL_P(fext) || !(f = rmext(name, ext)))
	    return fname;
	basename = rb_str_new(name, f);
    }
    else {
	p++;			/* skip last / */
	if (NIL_P(fext) || !(f = rmext(p, ext))) {
	    basename = rb_str_new2(p);
	}
	else {
	    basename = rb_str_new(p, f);
	}
    }
    OBJ_INFECT(basename, fname);
    return basename;
}

static VALUE
rb_file_s_dirname(klass, fname)
    VALUE klass, fname;
{
    char *name, *p;
    VALUE dirname;

    name = StringValuePtr(fname);
    p = strrdirsep(name);
    if (!p) {
	return rb_str_new2(".");
    }
    if (p == name)
	p++;
    dirname = rb_str_new(name, p - name);
    OBJ_INFECT(dirname, fname);
    return dirname;
}

static VALUE
rb_file_s_extname(klass, fname)
    VALUE klass, fname;
{
    char *name, *p, *e;
    VALUE extname;

    name = StringValuePtr(fname);
    p = strrdirsep(name);	/* get the last path component */
    if (!p)
 	p = name;
    else
 	p++;
 
     e = strrchr(p, '.');	/* get the last dot of the last component */
     if (!e || e == p)		/* no dot, or the only dot is first? */
	 return rb_str_new2("");
     extname = rb_str_new2(e);	/* keep the dot, too! */
     OBJ_INFECT(extname, fname);
     return extname;
}

static VALUE
rb_file_s_split(klass, path)
    VALUE klass, path;
{
    return rb_assoc_new(rb_file_s_dirname(Qnil, path), rb_file_s_basename(1,&path));
}

static VALUE separator;

static VALUE
rb_file_s_join(klass, args)
    VALUE klass, args;
{
    return rb_ary_join(args, separator);
}

static VALUE
rb_file_s_truncate(klass, path, len)
    VALUE klass, path, len;
{
    rb_secure(2);
    SafeStringValue(path);

#ifdef HAVE_TRUNCATE
    if (truncate(RSTRING(path)->ptr, NUM2OFFT(len)) < 0)
	rb_sys_fail(RSTRING(path)->ptr);
#else
# ifdef HAVE_CHSIZE
    {
	int tmpfd;

#  if defined(NT)
	if ((tmpfd = open(RSTRING(path)->ptr, O_RDWR)) < 0) {
	    rb_sys_fail(RSTRING(path)->ptr);
	}
#  else
	if ((tmpfd = open(RSTRING(path)->ptr, 0)) < 0) {
	    rb_sys_fail(RSTRING(path)->ptr);
	}
#  endif
	if (chsize(tmpfd, NUM2OFFT(len)) < 0) {
	    close(tmpfd);
	    rb_sys_fail(RSTRING(path)->ptr);
	}
	close(tmpfd);
    }
# else
    rb_notimplement();
# endif
#endif
    return INT2FIX(0);
}

static VALUE
rb_file_truncate(obj, len)
    VALUE obj, len;
{
    OpenFile *fptr;

    rb_secure(2);
    GetOpenFile(obj, fptr);
    if (!(fptr->mode & FMODE_WRITABLE)) {
	rb_raise(rb_eIOError, "not opened for writing");
    }
#ifdef HAVE_TRUNCATE
    if (ftruncate(fileno(fptr->f), NUM2OFFT(len)) < 0)
	rb_sys_fail(fptr->path);
#else
# ifdef HAVE_CHSIZE
    if (chsize(fileno(fptr->f), NUM2OFFT(len)) < 0)
	rb_sys_fail(fptr->path);
# else
    rb_notimplement();
# endif
#endif
    return INT2FIX(0);
}

# ifndef LOCK_SH
#  define LOCK_SH 1
# endif
# ifndef LOCK_EX
#  define LOCK_EX 2
# endif
# ifndef LOCK_NB
#  define LOCK_NB 4
# endif
# ifndef LOCK_UN
#  define LOCK_UN 8
# endif

#if 0
static int
rb_thread_flock(fd, op, fptr)
    int fd, op;
    OpenFile *fptr;
{
    if (rb_thread_alone() || (op & LOCK_NB)) {
	return flock(fd, op);
    }
    op |= LOCK_NB;
    while (flock(fd, op) < 0) {
	switch (errno) {
          case EAGAIN:
          case EACCES:
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
	  case EWOULDBLOCK:
#endif
	    rb_thread_polling();	/* busy wait */
	    rb_io_check_closed(fptr);
            continue;
	  default:
	    return -1;
	}
    }
    return 0;
}
#define flock(fd, op) rb_thread_flock(fd, op, fptr)
#endif

static VALUE
rb_file_flock(obj, operation)
    VALUE obj;
    VALUE operation;
{
#ifndef __CHECKER__
    OpenFile *fptr;
    int ret;

    rb_secure(2);
    GetOpenFile(obj, fptr);

    if (fptr->mode & FMODE_WRITABLE) {
	fflush(GetWriteFile(fptr));
    }
    TRAP_BEG;
    ret = flock(fileno(fptr->f), NUM2INT(operation));
    TRAP_END;
    if (ret < 0) {
        switch (errno) {
          case EAGAIN:
          case EACCES:
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
          case EWOULDBLOCK:
#endif
              return Qfalse;
        }
	rb_sys_fail(fptr->path);
    }
#endif
    return INT2FIX(0);
}
#undef flock

static void
test_check(n, argc, argv)
    int n, argc;
    VALUE *argv;
{
    int i;

    n+=1;
    if (n != argc) rb_raise(rb_eArgError, "wrong number of arguments(%d for %d)", argc, n);
    for (i=1; i<n; i++) {
	switch (TYPE(argv[i])) {
	  case T_STRING:
	    SafeStringValue(argv[i]);
	    break;
	  case T_FILE:
	    break;
	  default:
	    Check_Type(argv[i], T_STRING);
	    break;
	}
    }
}

#define CHECK(n) test_check((n), argc, argv)

static VALUE
rb_f_test(argc, argv)
    int argc;
    VALUE *argv;
{
    int cmd;

    if (argc == 0) rb_raise(rb_eArgError, "wrong number of arguments");
#if 0 /* 1.7 behavior? */
    if (argc == 1) {
	return RTEST(argv[0]) ? Qtrue : Qfalse;
    }
#endif
    cmd = NUM2CHR(argv[0]);
    if (cmd == 0) return Qfalse;
    if (strchr("bcdefgGkloOprRsSuwWxXz", cmd)) {
	CHECK(1);
	switch (cmd) {
	  case 'b':
	    return test_b(0, argv[1]);

	  case 'c':
	    return test_c(0, argv[1]);

	  case 'd':
	    return test_d(0, argv[1]);

	  case 'a':
	  case 'e':
	    return test_e(0, argv[1]);

	  case 'f':
	    return test_f(0, argv[1]);

	  case 'g':
	    return test_sgid(0, argv[1]);

	  case 'G':
	    return test_grpowned(0, argv[1]);

	  case 'k':
	    return test_sticky(0, argv[1]);

	  case 'l':
	    return test_l(0, argv[1]);

	  case 'o':
	    return test_owned(0, argv[1]);

	  case 'O':
	    return test_rowned(0, argv[1]);

	  case 'p':
	    return test_p(0, argv[1]);

	  case 'r':
	    return test_r(0, argv[1]);

	  case 'R':
	    return test_R(0, argv[1]);

	  case 's':
	    return test_s(0, argv[1]);

	  case 'S':
	    return test_S(0, argv[1]);

	  case 'u':
	    return test_suid(0, argv[1]);

	  case 'w':
	    return test_w(0, argv[1]);

	  case 'W':
	    return test_W(0, argv[1]);

	  case 'x':
	    return test_x(0, argv[1]);

	  case 'X':
	    return test_X(0, argv[1]);

	  case 'z':
	    return test_z(0, argv[1]);
	}
    }

    if (strchr("MAC", cmd)) {
	struct stat st;

	CHECK(1);
	if (rb_stat(argv[1], &st) == -1) {
	    rb_sys_fail(RSTRING(argv[1])->ptr);
	}

	switch (cmd) {
	  case 'A':
	    return rb_time_new(st.st_atime, 0);
	  case 'M':
	    return rb_time_new(st.st_mtime, 0);
	  case 'C':
	    return rb_time_new(st.st_ctime, 0);
	}
    }

    if (strchr("-=<>", cmd)) {
	struct stat st1, st2;

	CHECK(2);
	if (rb_stat(argv[1], &st1) < 0) return Qfalse;
	if (rb_stat(argv[2], &st2) < 0) return Qfalse;

	switch (cmd) {
	  case '-':
	    if (st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino)
		return Qtrue;
            return Qfalse;

	  case '=':
	    if (st1.st_mtime == st2.st_mtime) return Qtrue;
	    return Qfalse;

	  case '>':
	    if (st1.st_mtime > st2.st_mtime) return Qtrue;
	    return Qfalse;

	  case '<':
	    if (st1.st_mtime < st2.st_mtime) return Qtrue;
	    return Qfalse;
        }
    }
    /* unknown command */
    rb_raise(rb_eArgError, "unknown command ?%c", cmd);
    return Qnil;		/* not reached */
}

static VALUE
rb_stat_s_alloc(klass)
    VALUE klass;
{
    return stat_new_0(klass, 0);
}

static VALUE
rb_stat_init(obj, fname)
    VALUE obj, fname;
{
    struct stat st, *nst;

    SafeStringValue(fname);

    if (stat(RSTRING(fname)->ptr, &st) == -1) {
	rb_sys_fail(RSTRING(fname)->ptr);
    }
    if (DATA_PTR(obj)) {
	free(DATA_PTR(obj));
	DATA_PTR(obj) = NULL;
    }
    nst = ALLOC(struct stat);
    *nst = st;
    DATA_PTR(obj) = nst;

    return Qnil;
}

static VALUE
rb_stat_become(copy, orig)
    VALUE copy, orig;
{
    struct stat *nst;

    if (copy == orig) return orig;
    rb_check_frozen(copy);
    /* need better argument type check */
    if (!rb_obj_is_instance_of(orig, rb_obj_class(copy))) {
	rb_raise(rb_eTypeError, "wrong argument class");
    }
    if (DATA_PTR(copy)) {
	free(DATA_PTR(copy));
	DATA_PTR(copy) = 0;
    }
    if (DATA_PTR(orig)) {
	nst = ALLOC(struct stat);
	*nst = *(struct stat*)DATA_PTR(orig);
	DATA_PTR(copy) = nst;
    }

    return copy;
}

static VALUE
rb_stat_ftype(obj)
    VALUE obj;
{
    return rb_file_ftype(get_stat(obj));
}

static VALUE
rb_stat_d(obj)
    VALUE obj;
{
    if (S_ISDIR(get_stat(obj)->st_mode)) return Qtrue;
    return Qfalse;
}

static VALUE
rb_stat_p(obj)
    VALUE obj;
{
#ifdef S_IFIFO
    if (S_ISFIFO(get_stat(obj)->st_mode)) return Qtrue;

#endif
    return Qfalse;
}

static VALUE
rb_stat_l(obj)
    VALUE obj;
{
#ifdef S_ISLNK
    if (S_ISLNK(get_stat(obj)->st_mode)) return Qtrue;
#endif
    return Qfalse;
}

static VALUE
rb_stat_S(obj)
    VALUE obj;
{
#ifdef S_ISSOCK
    if (S_ISSOCK(get_stat(obj)->st_mode)) return Qtrue;

#endif
    return Qfalse;
}

static VALUE
rb_stat_b(obj)
    VALUE obj;
{
#ifdef S_ISBLK
    if (S_ISBLK(get_stat(obj)->st_mode)) return Qtrue;

#endif
    return Qfalse;
}

static VALUE
rb_stat_c(obj)
    VALUE obj;
{
    if (S_ISCHR(get_stat(obj)->st_mode)) return Qtrue;

    return Qfalse;
}

static VALUE
rb_stat_owned(obj)
    VALUE obj;
{
    if (get_stat(obj)->st_uid == geteuid()) return Qtrue;
    return Qfalse;
}

static VALUE
rb_stat_rowned(obj)
    VALUE obj;
{
    if (get_stat(obj)->st_uid == getuid()) return Qtrue;
    return Qfalse;
}

static VALUE
rb_stat_grpowned(obj)
    VALUE obj;
{
#ifndef NT
    if (get_stat(obj)->st_gid == getegid()) return Qtrue;
#endif
    return Qfalse;
}

static VALUE
rb_stat_r(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef S_IRUSR
    if (rb_stat_owned(obj))
	return st->st_mode & S_IRUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IRGRP
    if (rb_stat_grpowned(obj))
	return st->st_mode & S_IRGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IROTH
    if (!(st->st_mode & S_IROTH)) return Qfalse;
#endif
    return Qtrue;
}

static VALUE
rb_stat_R(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef S_IRUSR
    if (rb_stat_rowned(obj))
	return st->st_mode & S_IRUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IRGRP
    if (group_member(get_stat(obj)->st_gid))
	return st->st_mode & S_IRGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IROTH
    if (!(st->st_mode & S_IROTH)) return Qfalse;
#endif
    return Qtrue;
}

static VALUE
rb_stat_w(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef S_IWUSR
    if (rb_stat_owned(obj))
	return st->st_mode & S_IWUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IWGRP
    if (rb_stat_grpowned(obj))
	return st->st_mode & S_IWGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IWOTH
    if (!(st->st_mode & S_IWOTH)) return Qfalse;
#endif
    return Qtrue;
}

static VALUE
rb_stat_W(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef S_IWUSR
    if (rb_stat_rowned(obj))
	return st->st_mode & S_IWUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IWGRP
    if (group_member(get_stat(obj)->st_gid))
	return st->st_mode & S_IWGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IWOTH
    if (!(st->st_mode & S_IWOTH)) return Qfalse;
#endif
    return Qtrue;
}

static VALUE
rb_stat_x(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef S_IXUSR
    if (rb_stat_owned(obj))
	return st->st_mode & S_IXUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IXGRP
    if (rb_stat_grpowned(obj))
	return st->st_mode & S_IXGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IXOTH
    if (!(st->st_mode & S_IXOTH)) return Qfalse;
#endif
    return Qtrue;
}

static VALUE
rb_stat_X(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef S_IXUSR
    if (rb_stat_rowned(obj))
	return st->st_mode & S_IXUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IXGRP
    if (group_member(get_stat(obj)->st_gid))
	return st->st_mode & S_IXGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IXOTH
    if (!(st->st_mode & S_IXOTH)) return Qfalse;
#endif
    return Qtrue;
}

static VALUE
rb_stat_f(obj)
    VALUE obj;
{
    if (S_ISREG(get_stat(obj)->st_mode)) return Qtrue;
    return Qfalse;
}

static VALUE
rb_stat_z(obj)
    VALUE obj;
{
    if (get_stat(obj)->st_size == 0) return Qtrue;
    return Qfalse;
}

static VALUE
rb_stat_s(obj)
    VALUE obj;
{
    off_t size = get_stat(obj)->st_size;

    if (size == 0) return Qnil;
    return OFFT2NUM(size);
}

static VALUE
rb_stat_suid(obj)
    VALUE obj;
{
#ifdef S_ISUID
    if (get_stat(obj)->st_mode & S_ISUID) return Qtrue;
#endif
    return Qfalse;
}

static VALUE
rb_stat_sgid(obj)
    VALUE obj;
{
#ifdef S_ISGID
    if (get_stat(obj)->st_mode & S_ISGID) return Qtrue;
#endif
    return Qfalse;
}

static VALUE
rb_stat_sticky(obj)
    VALUE obj;
{
#ifdef S_ISVTX
    if (get_stat(obj)->st_mode & S_ISVTX) return Qtrue;
#endif
    return Qfalse;
}

static VALUE rb_mFConst;

void
rb_file_const(name, value)
    const char *name;
    VALUE value;
{
    rb_define_const(rb_mFConst, name, value);
    rb_define_const(rb_cIO, name, value);
    rb_define_const(rb_cFile, name, value);
}

static int
is_absolute_path(path)
    const char *path;
{
#if defined DOSISH || defined __CYGWIN__
    if (ISALPHA(path[0]) && path[1] == ':' && isdirsep(path[2])) return 1;
    if (isdirsep(path[0]) && isdirsep(path[1])) return 1;
#endif
#ifndef DOSISH
    if (path[0] == '/') return 1;
#endif
    return 0;
}

#ifndef DOSISH
static int
path_check_1(path)
     VALUE path;
{
    struct stat st;
    char *p0 = RSTRING(path)->ptr;
    char *p = 0, *s;

    if (!is_absolute_path(p0)) {
	char *buf = my_getcwd();
	VALUE newpath;

	newpath = rb_str_new2(buf);
	free(buf);

	rb_str_cat2(newpath, "/");
	rb_str_cat2(newpath, p0);
	return path_check_1(newpath);
    }
    for (;;) {
#ifndef S_IWOTH
# define S_IWOTH 002
#endif
	if (stat(p0, &st) == 0 && S_ISDIR(st.st_mode) && (st.st_mode & S_IWOTH)
#ifdef S_ISVTX
	    && (!p || !(st.st_mode & S_ISVTX))
#endif
	    ) {
	    rb_warn("Insecure world writable dir %s, mode 0%o", p0, st.st_mode);
	    if (p) *p = '/';
	    return 0;
	}
	s = strrdirsep(p0);
	if (p) *p = '/';
	if (!s || s == p0) return 1;
	p = s;
	*p = '\0';
    }
}
#endif

int
rb_path_check(path)
    char *path;
{
#ifndef DOSISH
    char *p0, *p, *pend;
    const char sep = PATH_SEP_CHAR;

    if (!path) return 1;

    pend = path + strlen(path);
    p0 = path;
    p = strchr(path, sep);
    if (!p) p = pend;

    for (;;) {
	if (!path_check_1(rb_str_new(p0, p - p0))) {
	    return 0;		/* not safe */
	}
	p0 = p + 1;
	if (p0 > pend) break;
	p = strchr(p0, sep);
	if (!p) p = pend;
    }
#endif
    return 1;
}

#if defined(__MACOS__) || defined(riscos)
static int
is_macos_native_path(path)
    const char *path;
{
    if (strchr(path, ':')) return 1;
    return 0;
}
#endif

static int
file_load_ok(file)
    char *file;
{
    FILE *f;

    if (!file) return 0;
    f = fopen(file, "r");
    if (f == NULL) return 0;
    fclose(f);
    return 1;
}

extern VALUE rb_load_path;

int
rb_find_file_ext(filep, ext)
    VALUE *filep;
    const char * const *ext;
{
    char *path, *found;
    char *f = RSTRING(*filep)->ptr;
    VALUE fname;
    long i, j;

    if (f[0] == '~') {
	fname = rb_file_s_expand_path(1, filep);
	if (rb_safe_level() >= 2 && OBJ_TAINTED(fname)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", f);
	}
	f = StringValuePtr(fname);
	*filep = fname;
    }

    if (is_absolute_path(f)) {
	for (i=0; ext[i]; i++) {
	    fname = rb_str_dup(*filep);
	    rb_str_cat2(fname, ext[i]);
	    if (file_load_ok(RSTRING(fname)->ptr)) {
		*filep = fname;
		return i+1;
	    }
	}
	return 0;
    }

    if (!rb_load_path) return 0;

    Check_Type(rb_load_path, T_ARRAY);
    for (i=0;i<RARRAY(rb_load_path)->len;i++) {
	VALUE str = RARRAY(rb_load_path)->ptr[i];

	SafeStringValue(str);
	if (RSTRING(str)->len == 0) return 0;
	path = RSTRING(str)->ptr;
	for (j=0; ext[j]; j++) {
	    fname = rb_str_dup(*filep);
	    rb_str_cat2(fname, ext[j]);
	    found = dln_find_file(RSTRING(fname)->ptr, path);
	    if (found && file_load_ok(found)) {
		*filep = fname;
		return j+1;
	    }
	}
    }
    return 0;
}

VALUE
rb_find_file(path)
    VALUE path;
{
    VALUE tmp;
    char *f = RSTRING(path)->ptr;
    char *lpath;

    if (f[0] == '~') {
	path = rb_file_s_expand_path(1, &path);
	if (rb_safe_level() >= 2 && OBJ_TAINTED(path)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", f);
	}
	f = StringValuePtr(path);
    }

#if defined(__MACOS__) || defined(riscos)
    if (is_macos_native_path(f)) {
	if (rb_safe_level() >= 2 && !rb_path_check(f)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", f);
	}
	if (file_load_ok(f)) return path;
    }
#endif

    if (is_absolute_path(f)) {
	if (rb_safe_level() >= 2 && !rb_path_check(f)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", f);
	}
	if (file_load_ok(f)) return path;
    }

    if (rb_safe_level() >= 4) {
	rb_raise(rb_eSecurityError, "loading from non-absolute path %s", f);
    }

    if (rb_load_path) {
	long i;

	Check_Type(rb_load_path, T_ARRAY);
	tmp = rb_ary_new();
	for (i=0;i<RARRAY(rb_load_path)->len;i++) {
	    VALUE str = RARRAY(rb_load_path)->ptr[i];
	    SafeStringValue(str);
	    if (RSTRING(str)->len > 0) {
		rb_ary_push(tmp, str);
	    }
	}
	tmp = rb_ary_join(tmp, rb_str_new2(PATH_SEP));
	if (RSTRING(tmp)->len == 0) {
	    lpath = 0;
	}
	else {
	    lpath = RSTRING(tmp)->ptr;
	    if (rb_safe_level() >= 2 && !rb_path_check(lpath)) {
		rb_raise(rb_eSecurityError, "loading from unsafe path %s", lpath);
	    }
	}
    }
    else {
	lpath = 0;
    }

    if (!lpath) {
	return 0;		/* no path, no load */
    }
    f = dln_find_file(f, lpath);
    if (file_load_ok(f)) {
	return rb_str_new2(f);
    }
    return 0;
}

static void
define_filetest_function(name, func, argc)
    const char *name;
    VALUE (*func)();
    int argc;
{
    rb_define_module_function(rb_mFileTest, name, func, argc);
    rb_define_singleton_method(rb_cFile, name, func, argc);
}

void
Init_File()
{
    rb_mFileTest = rb_define_module("FileTest");
    rb_cFile = rb_define_class("File", rb_cIO);

    define_filetest_function("directory?", test_d, 1);
    define_filetest_function("exist?", test_e, 1);
    define_filetest_function("exists?", test_e, 1); /* temporary */
    define_filetest_function("readable?", test_r, 1);
    define_filetest_function("readable_real?", test_R, 1);
    define_filetest_function("writable?", test_w, 1);
    define_filetest_function("writable_real?", test_W, 1);
    define_filetest_function("executable?", test_x, 1);
    define_filetest_function("executable_real?", test_X, 1);
    define_filetest_function("file?", test_f, 1);
    define_filetest_function("zero?", test_z, 1);
    define_filetest_function("size?", test_s, 1);
    define_filetest_function("size", rb_file_s_size, 1);
    define_filetest_function("owned?", test_owned, 1);
    define_filetest_function("grpowned?", test_grpowned, 1);

    define_filetest_function("pipe?", test_p, 1);
    define_filetest_function("symlink?", test_l, 1);
    define_filetest_function("socket?", test_S, 1);

    define_filetest_function("blockdev?", test_b, 1);
    define_filetest_function("chardev?", test_c, 1);

    define_filetest_function("setuid?", test_suid, 1);
    define_filetest_function("setgid?", test_sgid, 1);
    define_filetest_function("sticky?", test_sticky, 1);

    rb_define_singleton_method(rb_cFile, "stat",  rb_file_s_stat, 1);
    rb_define_singleton_method(rb_cFile, "lstat", rb_file_s_lstat, 1);
    rb_define_singleton_method(rb_cFile, "ftype", rb_file_s_ftype, 1);

    rb_define_singleton_method(rb_cFile, "atime", rb_file_s_atime, 1);
    rb_define_singleton_method(rb_cFile, "mtime", rb_file_s_mtime, 1);
    rb_define_singleton_method(rb_cFile, "ctime", rb_file_s_ctime, 1);

    rb_define_singleton_method(rb_cFile, "utime", rb_file_s_utime, -1);
    rb_define_singleton_method(rb_cFile, "chmod", rb_file_s_chmod, -1);
    rb_define_singleton_method(rb_cFile, "chown", rb_file_s_chown, -1);
    rb_define_singleton_method(rb_cFile, "lchmod", rb_file_s_lchmod, -1);
    rb_define_singleton_method(rb_cFile, "lchown", rb_file_s_lchown, -1);

    rb_define_singleton_method(rb_cFile, "link", rb_file_s_link, 2);
    rb_define_singleton_method(rb_cFile, "symlink", rb_file_s_symlink, 2);
    rb_define_singleton_method(rb_cFile, "readlink", rb_file_s_readlink, 1);

    rb_define_singleton_method(rb_cFile, "unlink", rb_file_s_unlink, -2);
    rb_define_singleton_method(rb_cFile, "delete", rb_file_s_unlink, -2);
    rb_define_singleton_method(rb_cFile, "rename", rb_file_s_rename, 2);
    rb_define_singleton_method(rb_cFile, "umask", rb_file_s_umask, -1);
    rb_define_singleton_method(rb_cFile, "truncate", rb_file_s_truncate, 2);
    rb_define_singleton_method(rb_cFile, "expand_path", rb_file_s_expand_path, -1);
    rb_define_singleton_method(rb_cFile, "basename", rb_file_s_basename, -1);
    rb_define_singleton_method(rb_cFile, "dirname", rb_file_s_dirname, 1);
    rb_define_singleton_method(rb_cFile, "extname", rb_file_s_extname, 1);

    separator = rb_obj_freeze(rb_str_new2("/"));
    rb_define_const(rb_cFile, "Separator", separator);
    rb_define_const(rb_cFile, "SEPARATOR", separator);
    rb_define_singleton_method(rb_cFile, "split",  rb_file_s_split, 1);
    rb_define_singleton_method(rb_cFile, "join",   rb_file_s_join, -2);

#if defined DOSISH && !defined __CYGWIN__
    rb_define_const(rb_cFile, "ALT_SEPARATOR", rb_obj_freeze(rb_str_new2("\\")));
#else
    rb_define_const(rb_cFile, "ALT_SEPARATOR", Qnil);
#endif
    rb_define_const(rb_cFile, "PATH_SEPARATOR", rb_obj_freeze(rb_str_new2(PATH_SEP)));

    rb_define_method(rb_cIO, "stat",  rb_io_stat, 0); /* this is IO's method */
    rb_define_method(rb_cFile, "lstat",  rb_file_lstat, 0);

    rb_define_method(rb_cFile, "atime", rb_file_atime, 0);
    rb_define_method(rb_cFile, "mtime", rb_file_mtime, 0);
    rb_define_method(rb_cFile, "ctime", rb_file_ctime, 0);

    rb_define_method(rb_cFile, "chmod", rb_file_chmod, 1);
    rb_define_method(rb_cFile, "chown", rb_file_chown, 2);
    rb_define_method(rb_cFile, "truncate", rb_file_truncate, 1);

    rb_define_method(rb_cFile, "flock", rb_file_flock, 1);

    rb_mFConst = rb_define_module_under(rb_cFile, "Constants");
    rb_include_module(rb_cFile, rb_mFConst);
    rb_file_const("LOCK_SH", INT2FIX(LOCK_SH));
    rb_file_const("LOCK_EX", INT2FIX(LOCK_EX));
    rb_file_const("LOCK_UN", INT2FIX(LOCK_UN));
    rb_file_const("LOCK_NB", INT2FIX(LOCK_NB));

    rb_define_method(rb_cFile, "path",  rb_file_path, 0);
    rb_define_global_function("test", rb_f_test, -1);

    rb_cStat = rb_define_class_under(rb_cFile, "Stat", rb_cObject);
    rb_define_singleton_method(rb_cStat, "allocate",  rb_stat_s_alloc, 0);
    rb_define_method(rb_cStat, "initialize", rb_stat_init, 1);
    rb_define_method(rb_cStat, "become", rb_stat_become, 1);

    rb_include_module(rb_cStat, rb_mComparable);

    rb_define_method(rb_cStat, "<=>", rb_stat_cmp, 1);

    rb_define_method(rb_cStat, "dev", rb_stat_dev, 0);
    rb_define_method(rb_cStat, "ino", rb_stat_ino, 0);
    rb_define_method(rb_cStat, "mode", rb_stat_mode, 0);
    rb_define_method(rb_cStat, "nlink", rb_stat_nlink, 0);
    rb_define_method(rb_cStat, "uid", rb_stat_uid, 0);
    rb_define_method(rb_cStat, "gid", rb_stat_gid, 0);
    rb_define_method(rb_cStat, "rdev", rb_stat_rdev, 0);
    rb_define_method(rb_cStat, "rdev_major", rb_stat_rdev_major, 0);
    rb_define_method(rb_cStat, "rdev_minor", rb_stat_rdev_minor, 0);
    rb_define_method(rb_cStat, "size", rb_stat_size, 0);
    rb_define_method(rb_cStat, "blksize", rb_stat_blksize, 0);
    rb_define_method(rb_cStat, "blocks", rb_stat_blocks, 0);
    rb_define_method(rb_cStat, "atime", rb_stat_atime, 0);
    rb_define_method(rb_cStat, "mtime", rb_stat_mtime, 0);
    rb_define_method(rb_cStat, "ctime", rb_stat_ctime, 0);

    rb_define_method(rb_cStat, "inspect", rb_stat_inspect, 0);

    rb_define_method(rb_cStat, "ftype", rb_stat_ftype, 0);

    rb_define_method(rb_cStat, "directory?",  rb_stat_d, 0);
    rb_define_method(rb_cStat, "readable?",  rb_stat_r, 0);
    rb_define_method(rb_cStat, "readable_real?",  rb_stat_R, 0);
    rb_define_method(rb_cStat, "writable?",  rb_stat_w, 0);
    rb_define_method(rb_cStat, "writable_real?",  rb_stat_W, 0);
    rb_define_method(rb_cStat, "executable?",  rb_stat_x, 0);
    rb_define_method(rb_cStat, "executable_real?",  rb_stat_X, 0);
    rb_define_method(rb_cStat, "file?",  rb_stat_f, 0);
    rb_define_method(rb_cStat, "zero?",  rb_stat_z, 0);
    rb_define_method(rb_cStat, "size?",  rb_stat_s, 0);
    rb_define_method(rb_cStat, "owned?",  rb_stat_owned, 0);
    rb_define_method(rb_cStat, "grpowned?",  rb_stat_grpowned, 0);

    rb_define_method(rb_cStat, "pipe?",  rb_stat_p, 0);
    rb_define_method(rb_cStat, "symlink?",  rb_stat_l, 0);
    rb_define_method(rb_cStat, "socket?",  rb_stat_S, 0);

    rb_define_method(rb_cStat, "blockdev?",  rb_stat_b, 0);
    rb_define_method(rb_cStat, "chardev?",  rb_stat_c, 0);

    rb_define_method(rb_cStat, "setuid?",  rb_stat_suid, 0);
    rb_define_method(rb_cStat, "setgid?",  rb_stat_sgid, 0);
    rb_define_method(rb_cStat, "sticky?",  rb_stat_sticky, 0);
}
@


1.113
log
@* gc.c (ruby_xmalloc): remove MALLOC_LIMIT to avoid frequent
  garabage collection.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/09/05 20:52:48 $
d336 1
a336 1
	    sprintf(buf, "0%lo", NUM2INT(v));
@


1.112
log
@* file.c (rb_path_check): nothing to check under DOSISH.
  [ruby-list:35772]
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/03 05:20:06 $
d2375 1
a2375 1
	    rb_warn("Insecure world writable dir %s , mode 0%o", p0, st.st_mode);
@


1.111
log
@	* variable.c (rb_copy_generic_ivar): remove old generic instance
	  variable table if it existes.

	* class.c (rb_make_metaclass): metaclass of a metaclass is a
	  metaclass itself.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/09/02 08:02:56 $
d2346 1
d2375 1
a2375 1
	    rb_warn("Unsecure world writeable dir %s , mode 0%o", p0, st.st_mode);
d2386 1
d2392 1
d2412 1
@


1.110
log
@fix mem leak in rb_file_s_readlink() (ruby-core:394)
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/29 09:08:15 $
d2027 2
a2028 2
rb_stat_become(obj, orig)
    VALUE obj, orig;
d2032 2
d2035 1
a2035 1
    if (!rb_obj_is_instance_of(orig, rb_obj_class(obj))) {
d2038 3
a2040 3
    if (DATA_PTR(obj)) {
	free(DATA_PTR(obj));
	DATA_PTR(obj) = 0;
d2045 1
a2045 1
	DATA_PTR(obj) = nst;
d2048 1
a2048 1
    return obj;
@


1.109
log
@* array.c (rb_ary_become): should not free ptr if it's shared.

* eval.c (rb_alias): prohibit making an alias named "allocate" if
  klass is a metaclass.

* string.c (rb_string_value_ptr): StringValuePtr() should never
  return NULL pointer.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/28 09:25:07 $
d1304 4
a1307 1
    if (rv < 0) rb_sys_fail(RSTRING(path)->ptr);
@


1.108
log
@file.c: fix mem leak in rb_stat_init
@
text
@d6 1
a6 1
  $Date: 2002/08/28 08:05:23 $
d2030 6
a2035 2
    if (!rb_obj_is_kind_of(orig, rb_obj_class(obj))) {
	rb_raise(rb_eTypeError, "wrong argument type");
@


1.107
log
@Int vs Long cleanup #3 (ruby-core:352)
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/27 08:31:05 $
d2011 4
@


1.106
log
@* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.

* class.c (rb_mod_dup): need to preserve metaclass and flags.

* object.c (rb_cstr_to_dbl): had a buffer overrun.

* marshal.c (w_class): integrate singleton check into a funciton
  to follow DRY principle.

* marshal.c (w_uclass): should check singleton method.

* object.c (rb_obj_dup): dmark and dfree functions must be match
  for T_DATA type.

* object.c (rb_obj_dup): class of the duped object must be match
  to the class of the original.

* re.c (rb_reg_quote): do not escape \t, \f, \r, \n, for they are
  not regular expression metacharacters.

* time.c (time_s_alloc): use time_free instead of free (null check,
  also serves for type mark).

* time.c (time_s_at): check dfree function too.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/21 15:47:54 $
d82 1
a82 1
static int
d847 1
a847 1
    return rb_int2inum(st.st_size);
d997 2
a998 1
    int mode, n;
d1005 1
a1005 1
    return INT2FIX(n);
d1048 2
a1049 1
    int mode, n;
d1056 1
a1056 1
    return INT2FIX(n);
d1088 1
a1088 1
    int n;
d1106 1
a1106 1
    return INT2FIX(n);
d1146 1
a1146 1
    int n;
d1164 1
a1164 1
    return INT2FIX(n);
d1196 1
a1196 1
    int n;
d1204 1
a1204 1
    return INT2FIX(n);
d1242 1
a1242 1
    int n;
d1254 1
a1254 1
    return INT2FIX(n);
d1327 1
a1327 1
    int n;
d1331 1
a1331 1
    return INT2FIX(n);
d2271 1
a2271 1
    int size = get_stat(obj)->st_size;
d2274 1
a2274 1
    return INT2FIX(size);
@


1.105
log
@*.c: Int vs Long cleanup
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/08/20 10:42:33 $
d2018 2
a2019 2
rb_stat_clone(obj)
    VALUE obj;
d2023 5
a2027 5
    VALUE clone;

    clone = rb_obj_alloc(RBASIC(obj)->klass);
    CLONESETUP(clone,obj);
    if (DATA_PTR(obj)) {
d2029 2
a2030 2
	*nst = *(struct stat*)DATA_PTR(obj);
	DATA_PTR(clone) = nst;
d2033 1
a2033 1
    return clone;
d2460 1
d2524 8
a2531 3
	lpath = StringValuePtr(tmp);
	if (rb_safe_level() >= 2 && !rb_path_check(lpath)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe path %s", lpath);
d2538 3
d2658 1
a2658 1
    rb_define_method(rb_cStat, "clone", rb_stat_clone, 0);
@


1.104
log
@* file.c (rb_file_s_expand_path): accept drive letter on Cygwin.
* file.c (is_absolute_path): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/12 07:39:07 $
d88 1
a88 1
    int i;
d2430 1
a2430 1
    int i, j;
d2511 1
a2511 1
	int i;
@


1.103
log
@* bignum.c (rb_big_cmp): use dbl2big() for Floats, instead of
  big2dbl().

* bignum.c (Init_Bignum): rb_big_zero_p() removed.  There may be
  Bignum zero.

* eval.c (rb_call0): new argument added for original method name.
  preserve original method name in frame->orig_func.

* eval.c (is_defined): use frame->orig_func, not last_func.

* eval.c (rb_eval): ditto.

* eval.c (method_call): supply data->oid also to rb_call0().

* object.c (rb_class_allocate_instance): call rb_obj_alloc() when
  called from alias, thus invoke original "allocate".

* eval.c (remove_method): removing allocate from classes should
  cause NameError.

* hash.c (rb_hash_equal): should check default values.

* ext/socket/socket.c (s_recvfrom): update RSTRING len.
@
text
@d5 2
a6 2
  $Author: H_Konishi $
  $Date: 2002/06/11 01:27:46 $
d1466 1
a1466 1
#if defined DOSISH
d1564 1
a1564 1
#if defined(DOSISH)
d2321 1
a2321 1
#ifdef DOSISH
d2324 2
a2325 1
#else
@


1.102
log
@new platform [bccwin32] merged.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/29 05:20:32 $
d217 1
a217 1
    return INT2FIX(0);
d229 1
a229 1
    return INT2FIX(0);
d241 1
a241 1
    return INT2FIX(0);
d259 1
a259 1
    return INT2FIX(0);
d270 1
a270 1
    return INT2FIX(0);
@


1.101
log
@* parse.y: yyparse #defines moved from intern.h

* ruby.c (proc_options): access prefixed "ruby_yydebug".

* applied modifies to pacify some of gcc -Wall warnings.

* parse.y (arg): no more ugly hack for "**", so that "-2**2" to be
  parsed as "(-2)**2", whereas "- 2**2" or "-(2)**2" to be parsed
  as "-(2**2)".

* parse.y (yylex): '-2' to be literal fixnum. [new]

* time.c (time_succ): new method for Range support.

* time.c (time_arg): nil test against v[6] (usec).
@
text
@d6 1
a6 1
  $Date: 2002/05/14 06:22:25 $
d182 5
a186 1
    return UINT2NUM(get_stat(self)->st_mode);
d551 8
d588 8
@


1.100
log
@* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* numeric.c (flo_to_s): default format precision to be "%.16g".

* util.c (ruby_strtod): use own strtod(3) implementation to avoid
  locale hell.  Due to this change "0xff".to_f no longer returns 255.0

* eval.c (avalue_to_yvalue): new function to distinguish yvalue
  (no-arg == Qundef) from svalue (no-arg == Qnil).

* eval.c (rb_yield_0): use avalue_to_yvalue().

* eval.c (assign): warn if val == Qundef where it means rhs is
  void (e.g. yield without value or call without argument).

* parse.y (value_expr): need not to warn for WHILE and UNTIL,
  since they can have return value (via valued break).
@
text
@d6 1
a6 1
  $Date: 2002/05/01 09:41:49 $
d297 1
a297 1
    struct {
d332 1
a332 1
	    sprintf(buf, "0%o", NUM2INT(v));
d338 1
a338 1
	    sprintf(buf, "0x%x", NUM2ULONG(v));
@


1.99
log
@* numeric.c (num_step): better iteration condition for float
  values;  suggested by Masahiro TANAKA <masa@@ir.isas.ac.jp>.

* range.c (range_step): step (for Range#step method) <= 0 makes no
  sence, thus ArgError will be raised.

* range.c (range_each): Range#each method is special case for
  Range#step(1)

* file.c (rb_find_file): load must be done from an abolute path if
  $SAFE >= 4.

* enum.c (enum_partition): new method. [new]

* re.c (rb_reg_s_quote): quote whitespaces for /x cases.
@
text
@d6 1
a6 1
  $Date: 2002/04/24 04:54:13 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
@


1.98
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d6 1
a6 1
  $Date: 2002/04/18 08:46:17 $
d2483 4
@


1.97
log
@* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* io.c: complete off_t handling; missing argument for
  fptr_finalize(); polished rb_scan_args call.

* dir.c: wrap multi-statment macro by do { } while (0)

* eval.c, numeric,c, sprintf.c, util.c: ditto.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.
@
text
@d6 1
a6 1
  $Date: 2002/04/10 08:45:22 $
d1590 1
a1590 1
    char *name, *p, *ext;
d2001 1
a2001 1
    struct stat st, *nst;
d2406 1
a2406 1
    char *path, *e, *found;
d2457 1
a2457 1
    VALUE tmp, fname;
a2459 1
    struct stat st;
@


1.96
log
@* variable.c (rb_obj_remove_instance_variable): raise NameError if
  specified instance variable is not defined.

* variable.c (generic_ivar_remove): modified to check ivar
  existence.

* file.c (rb_file_s_extname): new method based on the proposal
  (and patch) from Mike Hall. [new]

* eval.c (error_handle): default to 1 unless status is set.

* eval.c (ruby_options): guard error_handle() with PROT_NONE.

* eval.c (ruby_stop): ditto.

* math.c (math_acosh): added. [new]

* math.c (math_asinh): ditto.

* math.c (math_atanh): ditto.

* struct.c (rb_struct_each_pair): method added. [new]

* class.c (rb_singleton_class): wrong condition; was creating
  unnecessary singleton class.
@
text
@d6 1
a6 1
  $Date: 2002/03/20 09:43:15 $
d1681 1
a1681 1
    if (truncate(RSTRING(path)->ptr, NUM2INT(len)) < 0)
d1697 1
a1697 1
	if (chsize(tmpfd, NUM2INT(len)) < 0) {
d1722 1
a1722 1
    if (ftruncate(fileno(fptr->f), NUM2INT(len)) < 0)
d1726 1
a1726 1
    if (chsize(fileno(fptr->f), NUM2INT(len)) < 0)
@


1.95
log
@* eval.c (is_defined): should check receiver only once.

* eval.c (is_defined): should handle NODE_NEWLINE.

* file.c (rb_file_s_expand_path): memory leak fixed.
@
text
@d6 1
a6 1
  $Date: 2002/03/14 06:23:43 $
a1566 1
    l1 = strlen(p);
d1569 1
d1631 1
a1631 1
    if (OBJ_TAINTED(fname)) OBJ_TAINT(dirname);
d1636 22
d2584 1
@


1.94
log
@* re.c (rb_reg_match): should clear $~ if operand is nil.

* re.c (rb_reg_match2): ditto.

* configure: merge Jonathan Baker's large file support patch
  [ruby-talk:35316], with read_all patch in [ruby-talk:35470].

* eval.c (rb_f_abort): optional message argument that be printed
  on termination. [new]
@
text
@d6 1
a6 1
  $Date: 2002/02/22 10:28:45 $
d1472 1
@


1.93
log
@* bignum.c (get2comp): need to specify to carry or not.

* io.c (rb_io_inspect): embed path info.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/02/19 08:13:26 $
d245 1
a245 1
    return LONG2NUM(get_stat(self)->st_size);
d733 1
a733 1
    return rb_int2inum(st.st_size);
@


1.92
log
@* file.c (path_check_1): do not fail on world writable *parent*
  directories too.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/19 07:47:05 $
a2595 1

@


1.91
log
@* file.c (path_check_1): do not warn on world writable *parent*
  directories.

* class.c (rb_include_module): should preserve ancestor order in
  the included class/module.
@
text
@d6 1
a6 1
  $Date: 2002/02/19 06:50:22 $
d2310 1
a2310 1
	if (stat(p0, &st) == 0 && S_ISDIR(st.st_mode) && (st.st_mode & S_IWOTH)) {
d2312 1
a2312 1
	    if (!p || !(st.st_mode & S_ISVTX))
d2314 2
a2315 1
		rb_warn("Unsecure world writeable dir %s , mode 0%o", p0, st.st_mode);
@


1.90
log
@file.c (path_check_1): typo
@
text
@d6 1
a6 1
  $Date: 2002/02/19 06:43:57 $
d2310 1
a2310 1
	if (stat(p0, &st) == 0 && S_ISDIR(st.st_mode) && (st.st_mode & S_IWOTH)
d2312 1
a2312 1
	    && !(st.st_mode & S_ISVTX)
d2314 1
a2314 1
	    ) {
a2315 1
	    rb_warn("Unsecure world writeable dir %s , mode 0%o", p0, st.st_mode);
@


1.89
log
@* file.c (path_check_1): should check directory sticky bits.

* process.c (security): need not to warn twice.

* marshal.c (r_object): complete restoration before calling
  r_regist().
@
text
@d6 1
a6 1
  $Date: 2002/02/05 07:56:29 $
d2310 1
a2310 1
	if (stat(p0, &st) == 0 && S_ISDIR(st->st_mode) && (st.st_mode & S_IWOTH)
@


1.88
log
@* io.c (fptr_finalize): should raise error when fclose fails.

* eval.c (method_inspect): proper output format to distinguish
  methods and singleton methods.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/02/04 13:49:05 $
d2307 8
a2314 1
	if (stat(p0, &st) == 0 && (st.st_mode & 002)) {
@


1.87
log
@* file.c (rb_file_s_expand_path): should terminate.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/04 08:07:01 $
d1462 3
a1464 2
	    BUFCHECK (strlen(RSTRING(dname)->ptr) > buflen);
	    strcpy(buf, RSTRING(dname)->ptr);
d1472 1
a1473 1
	p = &buf[strlen(buf)];
a1542 3
    else if (p == buf) {
	p++;
    }
d1555 1
a1556 1
    RSTRING(result)->len = p - buf;
d2309 1
a2309 1
	    rb_warn("Bad mode 0%o on %s", st.st_mode, p0);
@


1.86
log
@* object.c (rb_class_real): should not follow ICLASS link

* variable.c (classname): should follow ICLASS link explicitly.
@
text
@d6 1
a6 1
  $Date: 2002/02/01 06:02:59 $
d1557 1
@


1.85
log
@* file.c (rb_stat_inspect): print dev, rdev in hexadecimal.
@
text
@d5 2
a6 2
  $Author: akr $
  $Date: 2002/01/29 09:15:59 $
d1380 9
d1394 3
a1396 4
    VALUE fname, dname;
    char *s, *p, *b;
    char buf[MAXPATHLEN+2];
    char *bend = buf + sizeof(buf) - 2;
d1400 1
d1402 3
d1406 1
a1406 2
    s = StringValuePtr(fname);
    p = buf;
d1414 1
a1414 1
	    if (strlen(dir) > MAXPATHLEN) goto toolong;
d1416 1
a1416 1
	    p = &buf[strlen(buf)];
d1429 1
a1429 1
	    if (p + (s-b) >= bend) goto toolong;
d1439 1
a1439 1
	    if (strlen(pwPtr->pw_dir) > MAXPATHLEN) goto toolong;
d1441 1
a1441 1
	    p = &buf[strlen(buf)];
d1453 1
a1453 1
	if (p + (s-b) >= bend) goto toolong;
d1462 1
a1462 1
	    if (strlen(RSTRING(dname)->ptr) > MAXPATHLEN) goto toolong;
d1466 2
d1469 2
a1470 1
	    getcwd(buf, MAXPATHLEN);
d1478 1
a1478 1
	    if (p >= bend) goto toolong;
d1524 1
a1524 1
		if (p + (s-b+1) >= bend) goto toolong;
d1538 1
a1538 1
	if (p + (s-b) >= bend) goto toolong;
d1556 3
a1558 7
    fname = rb_str_new(buf, p - buf);
    if (tainted) OBJ_TAINT(fname);
    return fname;

  toolong:
    rb_raise(rb_eArgError, "argument too long (size=%d)", RSTRING(fname)->len);
    return Qnil;		/* not reached */
d2310 1
@


1.84
log
@* file.c: `major' and `minor' macro needs sys/mkdev.h on SunOS 5.x.

* configure.in: add check for `sys/mkdev.h'.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/23 07:30:39 $
d333 6
@


1.83
log
@* file.c (rb_stat_rdev_major): added. [new]

* file.c (rb_stat_rdev_minor): added. [new]

* file.c (rb_stat_inspect): print mode in octal.
@
text
@d70 4
@


1.82
log
@* array.c (Init_Array): remove Array#filter.

* object.c (rb_mod_initialize): should accept zero argument.

* object.c (rb_mod_cmp): should raise ArgumentError if
  inheritance/inclusion relation between two classes/modules is
  not defined. [new]

* io.c (rb_io_fsync): new method. [new]
@
text
@d6 1
a6 1
  $Date: 2001/12/18 08:46:56 $
d214 24
d317 1
a317 1
	VALUE str2;
d324 10
a333 2
	str2 = rb_inspect((*member[i].func)(self));
	rb_str_append(str, str2);
d2588 2
@


1.81
log
@* string.c (rb_str_replace): swap arguments of OBJ_INFECT.

* eval.c (rb_thread_schedule): should not select a thread which is
  not yet initialized.

* time.c (time_plus): wrong boundary check.

* time.c (time_minus): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 05:03:03 $
d1552 1
a1552 1
	p++;			/* skip last `/' */
d2219 2
@


1.80
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* massages: replace "wrong #" by "wrong number".

* marshal.c (w_float): output Infinity and NaN explicitly.

* marshal.c (r_object): support new explicit float format.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.

* array.c (rb_ary_join): dumped core if sep is not T_STRING nor T_NIL.

* array.c (rb_ary_join): buffer size calculattion was wrong.

* array.c (rb_ary_to_s): if rb_output_fs is nil, insert newlines
  between array elements (use rb_default_rs as newline litral)
  [experimental].

* gc.c (init_mark_stack): no need to clear mark_stack.

* gc.c (gc_mark_all): need to handle finalizer mark.

* gc.c (gc_mark_rest): use MEMCPY instead of memcpy.

* gc.c (rb_gc_mark): earlier const check to avoid pusing special
  constants into mark stack.

* numeric.c (fix_to_s): 'to_s' now takes optional argument to
  specify radix. [new]

* bignum.c (rb_big_to_s): ditto. [new]
@
text
@d6 1
a6 1
  $Date: 2001/11/13 08:19:51 $
d1911 1
a1911 1
    Check_SafeStr(fname);
@


1.79
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* eval.c (rb_eval_cmd): should not upgrade safe level unless
  explicitly specified by argument newly added.

* signal.c (sig_trap): should not allow tainted trap closure.

* variable.c (rb_f_trace_var): should not allow trace_var on safe
  level higher than 3.

* variable.c (rb_f_trace_var): should not allow tainted trace
  closure.

* gc.c: do not use static stack until system stack overflows.

* eval.c (eval): should call Exception#exception instead of
  calling rb_exc_new3() directly.

* error.c (exc_exception): set "mesg" directly to the clone.  it
  might be better to set mesg via some method for flexibility.

* variable.c (cvar_override_check): should print original module
  name, if 'a' is T_ICLASS.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/11/08 09:21:59 $
d1304 1
a1304 1
	rb_raise(rb_eArgError, "wrong # of argument");
d1745 1
a1745 1
    if (n != argc) rb_raise(rb_eArgError, "wrong # of arguments(%d for %d)", argc, n);
d1769 1
a1769 1
    if (argc == 0) rb_raise(rb_eArgError, "wrong # of arguments");
@


1.78
log
@* file.c (path_check_1): forgot to initialize 'p'.

* mkconfig.rb: use String#dump to generate Ruby string literal.

* range.c (range_eql): should override 'eql?'

* array.c (rb_ary_hash): should override 'hash' too.
@
text
@d6 1
a6 1
  $Date: 2001/11/08 06:43:08 $
d2328 1
a2328 2
	fname = *filep;
	fname = rb_file_s_expand_path(1, &fname);
@


1.77
log
@* process.c (security): always give warning for insecure PATH.

* dir.c (my_getcwd): do not rely on MAXPATHLEN.

* file.c (rb_file_s_readlink): ditto.

* file.c (path_check_1): ditto.

* eval.c (rb_yield_0): should not call rb_f_block_given_p().

* string.c (rb_str_chomp_bang): should terminate string by NUL.

* eval.c (rb_yield_0): better error message.
@
text
@d6 1
a6 1
  $Date: 2001/10/29 05:07:17 $
d2240 1
a2240 1
    char *p, *s;
d2284 1
a2285 1
	p0 = p + 1;
@


1.76
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* variable.c (rb_cvar_set): empty iv_tbl may cause infinite loop.

* variable.c (rb_cvar_get): ditto.

* variable.c (cvar_override_check): ditto.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.

* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.
@
text
@d6 1
a6 1
  $Date: 2001/10/10 08:21:13 $
d22 1
d1229 4
a1232 2
    char buf[MAXPATHLEN];
    int cc;
d1235 8
a1242 2
    if ((cc = readlink(RSTRING(path)->ptr, buf, MAXPATHLEN)) < 0)
	rb_sys_fail(RSTRING(path)->ptr);
d1244 1
a1244 1
    return rb_tainted_str_new(buf, cc);
a1308 4
#ifndef HAVE_GETCWD
#define getcwd(buf, len) ((void)(len), getwd(buf))
#endif

d2236 1
a2236 1
    char *path;
d2239 2
a2240 2
    char *p = 0;
    char *s;
d2242 3
a2244 2
    if (!is_absolute_path(path)) {
	char buf[MAXPATHLEN+1];
d2246 6
a2251 5
	if (getcwd(buf, MAXPATHLEN) == 0) return 0;
	strncat(buf, "/", MAXPATHLEN);
	strncat(buf, path, MAXPATHLEN);
	buf[MAXPATHLEN] = '\0';
	return path_check_1(buf);
d2254 1
a2254 1
	if (stat(path, &st) == 0 && (st.st_mode & 002)) {
d2258 1
a2258 1
	s = strrdirsep(path);
d2260 1
a2260 1
	if (!s || s == path) return 1;
d2270 1
a2270 1
    char *p, *pend;
d2275 4
a2278 2
    p = path;
    pend = strchr(path, sep);
d2281 7
a2287 12
	int safe;

	if (pend) *pend = '\0';
	safe = path_check_1(p);
       if (!safe) {
           if (pend) *pend = sep;
           return 0;
       }
	if (!pend) break;
	*pend = sep;
	p = pend + 1;
	pend = strchr(p, sep);
@


1.75
log
@* file.c (rb_stat_clone): should copy internal data too.

* numeric.c (num_clone): Numeric should not be copied by clone.

* object.c (rb_obj_clone): should check immediate values.

* parse.y (command): `yield' should take command_args.

* parse.y (parse_quotedwords): %w(...) is not a string.
@
text
@d6 1
a6 1
  $Date: 2001/10/03 07:19:10 $
d146 11
a156 8
    time_t t1 = get_stat(self)->st_mtime;
    time_t t2 = get_stat(other)->st_mtime;
    if (t1 == t2)
	return INT2FIX(0);
    else if (t1 < t2)
	return INT2FIX(-1);
    else
	return INT2FIX(1);
d2498 1
a2498 1
    separator = rb_str_new2("/");
d2505 1
a2505 1
    rb_define_const(rb_cFile, "ALT_SEPARATOR", rb_str_new2("\\"));
d2509 1
a2509 1
    rb_define_const(rb_cFile, "PATH_SEPARATOR", rb_str_new2(PATH_SEP));
@


1.74
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/09/19 06:54:10 $
d398 3
d402 1
d1916 19
d2535 1
@


1.73
log
@* string.c (rb_str_init): String.new() => ""

* dir.c (dir_path): new method.

* dir.c (dir_initialize): wrap DIR into struct, along with path
  information.
@
text
@d6 1
a6 1
  $Date: 2001/09/08 14:17:09 $
d116 1
a116 2
    struct stat *nst;
    if (!st) rb_bug("stat_new() called with bad value");
d118 4
a121 2
    nst = ALLOC(struct stat);
    *nst = *st;
d138 1
a138 1
    if (!st) rb_bug("collapsed File::Stat");
d1887 9
a1895 2
rb_stat_s_new(klass, fname)
    VALUE klass, fname;
d1897 1
a1897 2
    VALUE s;
    struct stat st;
d1900 1
d1904 3
a1906 4
    s = stat_new_0(klass, &st);
    rb_obj_call_init(s, 1, &fname);
    return s;
}
a1907 5
static VALUE
rb_stat_init(klass, fname)
    VALUE klass, fname;
{
    /* do nothing */
d2510 1
a2510 1
    rb_define_singleton_method(rb_cStat, "new",  rb_stat_s_new, 1);
@


1.72
log
@* eval.c (rb_thread_restore_context): save current value of
  lastline and lastmatch in the thread struct for later restore.

* eval.c (rb_thread_save_context): restore lastline and lastmatch.

* numeric.c (flo_to_s): should handle negative float value.

* class.c (rb_include_module): should check whole ancestors to
  avoid duplicate module inclusion.

* string.c (trnext): should check backslash before updating "now"
  position.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/09/05 22:31:07 $
d79 1
a79 1
    int (*func)();
d90 1
a90 2
	if ((*func)(RSTRING(path)->ptr, arg) < 0)
	    rb_sys_fail(RSTRING(path)->ptr);
d915 1
a915 1
    if (chmod(path, mode) == -1)
d965 1
a965 1
    if (lchmod(path, mode) == -1)
@


1.71
log
@* file.c (rb_find_file_ext): add const qualifiers to ext.

* intern.h (rb_find_file_ext): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/09/03 05:37:42 $
d2289 1
a2289 1
    const char *const *ext;
@


1.70
log
@* ruby.c (proc_options): should not alter origargv[].

* ruby.c (set_arg0): long strings for $0 dumped core.

* ruby.c (set_arg0): use setprogtitle() if it's available.

* io.c (rb_io_popen): accept integer flags as mode.

* file.c (rb_find_file_ext): extension table can be supplied from
  outside.  renamed.

* eval.c (rb_f_require): replace rb_find_file_noext by
  rb_find_file_ext.

* eval.c (rb_provided): should also check feature without
  extension.

* numeric.c (flo_to_s): do not rely on decimal point to be '.'
@
text
@d6 1
a6 1
  $Date: 2001/08/23 06:02:14 $
d2289 1
a2289 1
    char **ext;
@


1.69
log
@* eval.c (is_defined): should not dump core for "defined?(())".

* eval.c (umethod_bind): recv can be an instance of descender of
  oklass if oklass is a Module.

* hash.c (rb_hash_equal): check identiry equality first.

* file.c (group_member): should check real gid only.

* file.c (eaccess): do not cache euid, since effective euid may be
  changed via Process.euid=().

* file.c (eaccess): return -1 unless every specified access mode
  is permitted.

* eval.c (rb_eval): while/until returns the value which is given
  to break.

* parse.y (value_expr): using while/until/class/def as an
  expression is now gives a warning, not an error.

* range.c (range_eqq): should compare strings based on magical
  increment (using String#upto), not dictionary order.

* enum.c (enum_sort_by): new method for Schewartzian transformed
  stable sort.

* variable.c (mod_av_set): detect constant overriding for built-in
  classes/modules.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/08/01 16:49:11 $
d2287 1
a2287 1
rb_find_file_noext(filep)
d2289 1
a2294 8

    static char *ext[] = {
	".rb", DLEXT,
#ifdef DLEXT2
	DLEXT2,
#endif
	0
    };
@


1.68
log
@* file.c (strrdirsep): removed meaningless code.

* file.c (rb_file_s_expand_path): return to 1.66.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/07/31 06:24:42 $
d393 1
a393 1
    if (getgid() ==  gid || getegid() == gid)
d424 4
a427 2
  struct stat st;
  static int euid = -1;
d429 1
a429 1
  if (stat(path, &st) < 0) return (-1);
d431 4
a434 2
  if (euid == -1)
    euid = geteuid ();
d436 6
a441 10
  if (euid == 0)
    {
      /* Root can read or write any file. */
      if (mode != X_OK)
	return 0;

      /* Root can execute any file that has any one of the execute
	 bits set. */
      if (st.st_mode & S_IXUGO)
	return 0;
d444 4
a447 4
  if (st.st_uid == euid)        /* owner */
    mode <<= 6;
  else if (group_member (st.st_gid))
    mode <<= 3;
d449 1
a449 1
  if (st.st_mode & mode) return 0;
d451 1
a451 1
  return -1;
d453 1
a453 1
  return access(path, mode);
@


1.67
log
@* marshal.c (Init_marshal): new constant Marshal::MAJOR_VERSION
  and Marshal::MINOR_VERSION.

* marshal.c (marshal_load): ruby_verbose test should be wrapped by
  RTEST().

* hash.c (rb_hash_index): should return nil (not the default
  value) if value is not in the hash.

* numeric.c (num_div): new method added.  alias to '/' which
  should be preserved even if '/' is redefined (e.g. by
  mathn). [new]

* bignum.c (rb_cstr2inum): "0 ff".hex should return 0, not 255.

* file.c (rb_file_s_expand_path): fixed using CharNext().
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/07/30 22:41:59 $
a1314 3
#ifdef DOSISH
    if (ISALPHA(path[0]) && path[1] == ':') path += 2;
#endif
a1436 6
		    }
		    else {
			p = CharNext(p);
			*p++ = '.';
			*p = '.';
			if (p >= bend) goto toolong;
@


1.66
log
@* file.c (rb_file_s_expand_path): scans per path element not per
  byte/character, including fix of [ruby-talk:18152] and
  multi-byte pathname support.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/07/27 09:12:12 $
d1440 6
@


1.65
log
@* eval.c (rb_provided): extension should be guessed using
  rb_find_file_noext().

* eval.c (rb_f_require): should call rb_feature_p() after
  extension completion.

* eval.c (rb_eval): add CHECK_INTS before next, redo, retry to
  avoid potential uninterruptable infinite loop.

* file.c (rb_file_s_expand_path): use CharNext() to expand.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/07/26 03:54:34 $
d1335 1
a1335 1
    char *s, *p, *sbeg, *b;
d1343 1
a1343 1
    s = sbeg = StringValuePtr(fname);
d1420 1
d1424 5
a1428 2
           if (*(s+1) && (s == sbeg || isdirsep(*(s - 1)))) {
		switch (*++s) {
d1432 8
a1439 10
			if (isdirsep(*p) && p > buf) p--;
			while (p > buf && !isdirsep(*p)) p--;
		    }
		    else {
			*++p = '.';
			do {
			    *++p = '.';
			    if (p >= bend) goto toolong;
			} while (*++s == '.');
			--s;
d1446 1
a1446 1
		    if (!isdirsep(*p)) *++p = '/';
d1449 2
a1450 1
		    *++p = '.'; *++p = *s; break;
a1451 3
           }
           else {
               *++p = '.';
d1458 8
a1465 1
	    if (!isdirsep(*p)) *++p = '/'; break;
a1466 1
	    b = s;
d1468 1
a1468 4
	    p = CharNext(p);
	    if (p + (s-b) >= bend) goto toolong;
	    memcpy(p, b, s-b);
	    continue;
a1469 1
	s = CharNext(s);
d1472 18
a1489 3
    /* Place a \0 at end. If path ends with a "/", delete it */
    if (p == buf || !isdirsep(*p)) p++;
    *p = '\0';
d1491 1
a1491 1
    fname = rb_str_new2(buf);
@


1.64
log
@* file.c (rb_find_file_noext, rb_find_file): fix tilde expansion
  problem.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/07/24 15:11:02 $
d1335 1
a1335 1
    char *s, *p;
d1343 1
a1343 1
    s = StringValuePtr(fname);
d1363 1
d1365 1
a1365 2
		*p++ = *s++;
		if (p >= bend) goto toolong;
d1367 3
d1387 1
d1389 1
a1389 2
	    *p++ = *s++;
	    if (p >= bend) goto toolong;
d1391 3
d1420 1
a1420 1
    for ( ; *s; s++) {
d1423 1
a1423 1
	    if (*(s+1)) {
d1449 3
d1460 6
a1465 2
	    *++p = *s;
	    if (p >= bend) goto toolong;
d1467 1
d2295 1
a2295 1
	f = STR2CSTR(fname);
d2346 1
a2346 1
	f = STR2CSTR(path);
@


1.63
log
@* file.c (strrdirsep): multi-byte pathname and DOSish separater
  supprot. originally comes from Patrick Cheng. [new]

* file.c (rb_file_s_basename, rb_file_s_dirname): use
  strrdirsep(). comes from Patrick Cheng.

* file.c (is_absolute_path): restricted in DOSish absolute path
  with drive letter, and UNC support. originally comes from
  Patrick Cheng.

* file.c (getcwd): define macro using getwd() unless provided.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/07/24 09:07:33 $
d2281 2
d2328 2
a2329 2
	tmp = rb_file_s_expand_path(1, &path);
	if (rb_safe_level() >= 2 && OBJ_TAINTED(tmp)) {
d2332 1
@


1.62
log
@* eval.c (rb_provide_feature): should not tweak extension used for
  loading.

* io.c (io_fread): use fread(3) if PENDING_COUND is available.

* class.c (rb_mod_include_p): Module#include? added. [new]

* re.c (ignorecase_setter): give warning on modifying $=.

* string.c (rb_str_casecmp): new method. [new]

* string.c (rb_str_eql): separated from rb_str_equal(), make it
  always be case sensitive. [new]

* string.c (rb_str_hash): made it always be case sensitive.

* eval.c (rb_f_require): should not include path in $" value

* file.c (rb_find_file): should return 0 explicitly on failure.
@
text
@d6 1
a6 1
  $Date: 2001/07/18 05:55:20 $
d1293 4
d1302 26
a1398 1
#ifdef HAVE_GETCWD
a1399 3
#else
	    getwd(buf);
#endif
d1505 1
a1505 1
    p = strrchr(name, '/');
d1532 1
a1532 1
    p = strrchr(name, '/');
d2165 4
d2170 1
a2170 4
# if defined DOSISH
    if (path[0] == '\\') return 1;
    if (strlen(path) > 2 && path[1] == ':') return 1;
# endif
a2184 1
#ifdef HAVE_GETCWD
a2185 3
#else
	if (getwd(buf) == 0) return 0;
#endif
d2193 1
a2193 1
           if (p) *p = '/';
d2196 1
a2196 1
	s = strrchr(path, '/');
@


1.61
log
@* regex.c (NUM_FAILURE_ITEMS): was confusing NUM_REG_ITEMS and
  NUM_NONREG_ITEMS, which have happened to be same value.

* class.c (rb_class_new): subclass check moved to this function.

* class.c (rb_class_boot): check less version of rb_class_new().

* eval.c (proc_invoke): should preserve iter status for embedded
  frame in the block.

* file.c (rb_file_s_expand_path): may overrun buffer on stack.

* string.c (rb_str_insert): forgot to call rb_str_modify().
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/07/16 04:22:46 $
d2351 1
@


1.60
log
@* file.c (file_load_ok): fix typo.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/07/14 15:17:18 $
d1307 1
d1322 1
d1335 1
d1344 1
d1356 1
d1364 1
d1381 1
d1401 4
a1404 1
			do *++p = '.'; while (*++s == '.');
d1426 1
d1437 4
@


1.59
log
@* regex.c (re_search): should consider reverse search.

* dir.c (dir_s_chdir): warn only when invoked from multiple
  threads or block is not given.

* object.c (rb_convert_type): should use rb_rescue(), not rb_rescue2().

* range.c (range_init): ditto.

* object.c (rb_obj_dup): should free generic_ivar if original owns
  them.

* string.c (rb_str_each_line): should propagate taint mark.

* ext/nkf/nkf.c (rb_nkf_kconv): ditto.

* eval.c (rb_f_require): revamp for simpler implementation.

* file.c (rb_find_file_noext): use String object, instead of
  passing char* around.

* file.c (rb_find_file): ditto.

* dln.c (dln_load): should use NSLINKMODULE_OPTION_BINDNOW.

* ruby.c (load_file): local variables 'c' remain uninitialized on
  xflag.

* regex.c (re_match): prefetched escaped character too early.

* eval.c (rb_call0): add argument check for attr_readers.
@
text
@d6 1
a6 1
  $Date: 2001/06/19 04:35:13 $
d72 1
a72 1
 
d1387 1
a1387 1
		    if (*(s+1) == '\0' || isdirsep(*(s+1))) { 
d1402 1
a1402 1
		    if (!isdirsep(*p)) *++p = '/'; 
d1418 1
a1418 1
  
d1798 1
a1798 1
                        
d1802 1
a1802 1
                        
d1806 1
a1806 1
            
d2177 1
a2177 1
    
d2211 1
a2211 1
    if (!f) return 0;
@


1.58
log
@* eval.c (rb_f_require): searches ".rb" and ".so" at the same
  time.  previous behavior (search ".rb", then ".so") has a
  security risk (ruby-bugs#PR140).

* array.c (rb_ary_to_ary): new function to replace internal
  rb_Array(), which never calls to_a, but to_ary (rb_Array() might
  call both). [new]

* regex.c (PUSH_FAILURE_POINT): push option status again.

* regex.c (re_compile_pattern): avoid pushing unnecessary
  option_set.

* eval.c (rb_load): tainted string is OK if wrapped *and*
  $SAFE >= 4.

* eval.c (rb_thread_start_0): should not nail down higher blocks
  before preserving original context (i.e. should not alter
  original context).

* eval.c (proc_yield): new method equivalent to Proc#call but no
  check for number of arguments. [new]
@
text
@d6 1
a6 1
  $Date: 2001/06/01 06:47:30 $
d2205 1
a2205 1
static char*
d2211 1
d2215 1
a2215 1
    return file;
d2221 2
a2222 2
rb_find_file_noext(file)
    char *file;
d2225 1
a2225 1
    char *fend = file + strlen(file);
d2237 2
a2238 2
    if (file[0] == '~') {
	fname = rb_str_new2(file);
d2240 3
a2242 1
	file = StringValuePtr(fname);
d2245 1
a2245 1
    if (is_absolute_path(file)) {
d2247 6
a2252 2
	    strcpy(fend, ext[i]);
	    if (file_load_ok(file)) return i+1;
d2266 7
a2272 3
	    strcpy(fend, ext[j]);
	    found = dln_find_file(file, path);
	    if (found && file_load_ok(found)) return j+1;
d2278 3
a2280 3
char*
rb_find_file(file)
    char *file;
d2282 3
a2284 2
    VALUE vpath, fname;
    char *path;
d2287 4
a2290 5
    if (file[0] == '~') {
	fname = rb_str_new2(file);
	fname = rb_file_s_expand_path(1, &fname);
	if (rb_safe_level() >= 2 && OBJ_TAINTED(fname)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", file);
a2291 1
	file = StringValuePtr(fname);
d2295 3
a2297 3
    if (is_macos_native_path(file)) {
	if (rb_safe_level() >= 2 && !rb_path_check(file)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", file);
d2299 1
a2299 1
	return file_load_ok(file);
d2303 3
a2305 3
    if (is_absolute_path(file)) {
	if (rb_safe_level() >= 2 && !rb_path_check(file)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", file);
d2307 1
a2307 1
	return file_load_ok(file);
d2314 1
a2314 1
	vpath = rb_ary_new();
d2319 1
a2319 1
		rb_ary_push(vpath, str);
d2322 4
a2325 4
	vpath = rb_ary_join(vpath, rb_str_new2(PATH_SEP));
	path = StringValuePtr(vpath);
	if (rb_safe_level() >= 2 && !rb_path_check(path)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe path %s", path);
d2329 1
a2329 1
	path = 0;
d2332 4
a2335 2
    path = dln_find_file(file, path);
    return file_load_ok(path);
@


1.57
log
@* parse.y (yylex): fixed 'print CGI::bar() {}, "\n"' syntax
  breakage, adding new lex_state status.  sigh. [new]

* file.c (rb_file_s_unlink): should not allow if $SAFE >= 2.

* range.c (Init_Range): define "to_ary".
@
text
@d6 1
a6 1
  $Date: 2001/05/30 09:12:34 $
d2205 62
a2270 1
    extern VALUE rb_load_path;
d2275 9
a2285 2
	FILE *f;

d2289 1
a2289 4
	f= fopen(file, "r");
	if (f == NULL) return 0;
	fclose(f);
	return file;
a2293 2
	FILE *f;

d2297 1
a2297 13
	f = fopen(file, "r");
	if (f == NULL) return 0;
	fclose(f);
	return file;
    }

    if (file[0] == '~') {
	fname = rb_str_new2(file);
	fname = rb_file_s_expand_path(1, &fname);
	if (rb_safe_level() >= 2 && OBJ_TAINTED(fname)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", file);
	}
	file = StringValuePtr(fname);
d2323 1
a2323 4
    if (path && stat(path, &st) == 0) {
	return path;
    }
    return 0;
@


1.56
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d6 1
a6 1
  $Date: 2001/05/11 05:24:54 $
d1249 1
@


1.55
log
@* bignum.c (bigdivrem): access boundary bug.

* marshal.c (w_object): prohibit dumping out singleton classes.

* object.c (rb_mod_to_s): distinguish singleton classes.

* variable.c (rb_class2name): it's ok to reveal NilClass,
  TrueClass, FalseClass.

* eval.c (rb_yield_0): preserve and restore ruby_cref as well.

* eval.c (is_defined): core dumped during instance_eval for
  special constants.

* eval.c (rb_eval): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:10 $
d284 3
a286 3
    str = rb_str_new2("#<");
    rb_str_cat2(str, rb_class2name(CLASS_OF(self)));
    rb_str_cat2(str, " ");
d292 1
a292 1
	    rb_str_cat2(str, ", ");
d294 2
a295 2
	rb_str_cat2(str, member[i].name);
	rb_str_cat2(str, "=");
d299 1
a299 1
    rb_str_cat2(str, ">");
d452 1
a452 1
#else  /* !NT */
@


1.54
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d6 1
a6 1
  $Date: 2001/03/28 08:43:24 $
d2209 1
a2209 2
    volatile VALUE vpath;
    VALUE fname;
d2217 1
a2217 1
	if (safe_level >= 2 && !rb_path_check(file)) {
@


1.53
log
@* object.c (rb_str2cstr): warn if string contains \0 and length
  value is ignored.

* class.c (rb_singleton_class_clone): should copy class constant
  table as well.

* class.c (rb_include_module): sometimes cache was mistakenly left
  uncleared - based on the patch by K.Kosako.

* ruby.h: all Check_SafeStr()'s are replaced by SafeStr() to
  ensure 'to_str' be always effective.
@
text
@d6 1
a6 1
  $Date: 2001/03/26 08:57:09 $
d89 1
a89 1
	SafeStr(path);
d113 2
a114 1
stat_new(st)
d122 8
a129 1
    return Data_Wrap_Struct(rb_cStat, NULL, free, nst);
d160 1
a160 1
    return INT2FIX((int)get_stat(self)->st_dev);
d167 1
a167 1
    return INT2FIX((int)get_stat(self)->st_ino);
d174 1
a174 1
    return INT2FIX((int)get_stat(self)->st_mode);
d181 1
a181 1
    return INT2FIX((int)get_stat(self)->st_nlink);
d188 1
a188 1
    return INT2FIX((int)get_stat(self)->st_uid);
d195 1
a195 1
    return INT2FIX((int)get_stat(self)->st_gid);
d203 1
a203 1
    return INT2FIX((int)get_stat(self)->st_rdev);
d213 1
a213 1
    return INT2FIX((int)get_stat(self)->st_size);
d221 1
a221 1
    return INT2FIX((int)get_stat(self)->st_blksize);
d232 1
a232 1
    return INT2FIX((int)get_stat(self)->st_blocks);
d317 1
a317 1
    SafeStr(file);
d325 2
a326 2
rb_file_s_stat(obj, fname)
    VALUE obj, fname;
d330 1
a330 1
    SafeStr(fname);
d352 2
a353 2
rb_file_s_lstat(obj, fname)
    VALUE obj, fname;
d358 1
a358 1
    SafeStr(fname);
d364 1
a364 1
    return rb_file_s_stat(obj, fname);
d511 1
a511 1
    SafeStr(fname);
d599 1
a599 1
    SafeStr(fname);
d608 1
a608 1
    SafeStr(fname);
d617 1
a617 1
    SafeStr(fname);
d626 1
a626 1
    SafeStr(fname);
d635 1
a635 1
    SafeStr(fname);
d644 1
a644 1
    SafeStr(fname);
d723 2
a724 2
check3rdbyte(file, mode)
    const char *file;
d729 2
a730 1
    if (stat(file, &st) < 0) return Qfalse;
d741 1
a741 2
    SafeStr(fname);
    return check3rdbyte(RSTRING(fname)->ptr, S_ISUID);
d752 1
a752 2
    SafeStr(fname);
    return check3rdbyte(RSTRING(fname)->ptr, S_ISGID);
d763 1
a763 1
    return check3rdbyte(STR2CSTR(fname), S_ISVTX);
d770 2
a771 2
rb_file_s_size(obj, fname)
    VALUE obj, fname;
d788 2
a789 1
    } else if (S_ISDIR(st->st_mode)) {
d791 2
a792 1
    } else if (S_ISCHR(st->st_mode)) {
d823 2
a824 2
rb_file_s_ftype(obj, fname)
    VALUE obj, fname;
d828 1
a828 1
    SafeStr(fname);
d837 2
a838 2
rb_file_s_atime(obj, fname)
    VALUE obj, fname;
d862 2
a863 2
rb_file_s_mtime(obj, fname)
    VALUE obj, fname;
d887 2
a888 2
rb_file_s_ctime(obj, fname)
    VALUE obj, fname;
d1057 1
a1057 1
#if defined(HAVE_LCHOWN)
d1188 2
a1189 2
rb_file_s_link(obj, from, to)
    VALUE obj, from, to;
d1191 2
a1192 2
    SafeStr(from);
    SafeStr(to);
d1200 2
a1201 2
rb_file_s_symlink(obj, from, to)
    VALUE obj, from, to;
d1204 2
a1205 2
    SafeStr(from);
    SafeStr(to);
d1217 2
a1218 2
rb_file_s_readlink(obj, path)
    VALUE obj, path;
d1224 1
a1224 1
    SafeStr(path);
d1244 2
a1245 2
rb_file_s_unlink(obj, args)
    VALUE obj, args;
d1254 2
a1255 2
rb_file_s_rename(obj, from, to)
    VALUE obj, from, to;
d1257 2
a1258 2
    SafeStr(from);
    SafeStr(to);
d1311 1
a1311 1
    s = STR2CSTR(fname);
d1460 1
a1460 1
	ext = STR2CSTR(fext);
d1462 1
a1462 1
    name = STR2CSTR(fname);
d1483 2
a1484 2
rb_file_s_dirname(obj, fname)
    VALUE obj, fname;
d1489 1
a1489 1
    name = STR2CSTR(fname);
d1502 2
a1503 2
rb_file_s_split(obj, path)
    VALUE obj, path;
d1511 2
a1512 2
rb_file_s_join(obj, args)
    VALUE obj, args;
d1518 2
a1519 2
rb_file_s_truncate(obj, path, len)
    VALUE obj, path, len;
d1522 1
a1522 1
    SafeStr(path);
d1667 1
a1667 1
	    SafeStr(argv[i]);
d1817 24
d2246 1
a2246 1
	file = STR2CSTR(fname);
d2256 1
a2256 1
	    SafeStr(str);
d2262 1
a2262 1
	path = STR2CSTR(vpath);
d2386 2
@


1.52
log
@* eval.c: remove TMP_PROTECT_END to prevent C_ALLOCA crash.

* file.c (rb_file_flock): do not trap EINTR.

* missing/flock.c (flock): returns the value from lockf(2)
  directly.

* eval.c (ev_const_defined): should ignore toplevel cbase (Object).

* eval.c (ev_const_get): ditto.

* ext/md5/md5.h: replace by independent md5 implementation
  contributed by L. Peter Deutsch (thanks).

* ext/md5/md5init.c: adopted to Deutsch's md5 implementation.

* pack.c (pack_unpack): string from P/p should be tainted.

* ext/curses/curses.c: curses on Mac OS X public beta does not
  have _maxx etc.

* marshal.c (w_object): should truncate trailing zero short for
  bignums.

* object.c (sym_intern): new method.
@
text
@d6 1
a6 1
  $Date: 2001/03/21 03:51:23 $
a87 4
	Check_SafeStr(args->ptr[i]);
    }

    for (i=0; i<args->len; i++) {
d89 1
d309 1
a309 1
    Check_SafeStr(file);
d322 1
a322 1
    Check_SafeStr(fname);
d350 1
a350 1
    Check_SafeStr(fname);
d503 1
a503 1
    Check_SafeStr(fname);
d591 1
a591 1
    Check_SafeStr(fname);
d600 1
a600 1
    Check_SafeStr(fname);
d609 1
a609 1
    Check_SafeStr(fname);
d618 1
a618 1
    Check_SafeStr(fname);
d627 1
a627 1
    Check_SafeStr(fname);
d636 1
a636 1
    Check_SafeStr(fname);
d732 1
a732 1
    Check_SafeStr(fname);
d744 1
a744 1
    Check_SafeStr(fname);
d819 1
a819 1
    Check_SafeStr(fname);
d1182 2
a1183 2
    Check_SafeStr(from);
    Check_SafeStr(to);
d1195 2
a1196 2
    Check_SafeStr(from);
    Check_SafeStr(to);
d1215 1
a1215 2
    Check_SafeStr(path);

d1248 2
a1249 2
    Check_SafeStr(from);
    Check_SafeStr(to);
d1513 1
a1513 1
    Check_SafeStr(path);
d1658 1
a1658 1
	    Check_SafeStr(argv[i]);
d2223 1
a2223 1
	    Check_SafeStr(str);
@


1.51
log
@* ruby.h: rb_sys_stat -> stat
@
text
@d6 1
a6 1
  $Date: 2001/03/21 03:41:41 $
d1587 1
a1587 1
#if defined(EWOULDBLOCK) && 0
d1599 3
a1601 1
	  case EINTR:			/* can be happen? */
d1603 1
d1606 1
a1606 1
	    break;
d1635 5
a1639 4
#ifdef EWOULDBLOCK
	if (errno == EWOULDBLOCK) {
	    return Qfalse;
	}
d1641 2
@


1.50
log
@* gc.c (id2ref): sometimes confused symbol and reference.

* dir.c (glob_helper): breaks loop after calling recusive
  glob_helper; all wild cards should be consumed; no need for
  further match.

* dir.c (dir_s_glob): gives warning if no match found.

* object.c (sym_inspect): did allocate extra byte space.

* marshal.c (shortlen): shortlen should return number of bytes
  written.

* eval.c (ev_const_defined): need not to check if cbase->nd_class
  is rb_cObject.

* eval.c (ev_const_get): ditto.

* time.c (time_zone): return "UTC" for UTC time objects.

* eval.c (THREAD_ALLOC): flags should be initialized.

* signal.c (rb_f_kill): should use FIX2INT, not FIX2UINT.
@
text
@d6 1
a6 1
  $Date: 2001/03/19 03:20:21 $
d70 1
a70 1
#define lstat stat
d316 1
a316 1
    return rb_sys_stat(RSTRING(file)->ptr, st);
d326 1
a326 1
    if (rb_sys_stat(RSTRING(fname)->ptr, &st) == -1) {
d422 1
a422 1
  if (rb_sys_stat(path, &st) < 0) return (-1);
d724 1
a724 1
    if (rb_sys_stat(file, &st) < 0) return Qfalse;
d2118 1
a2118 1
	if (rb_sys_stat(path, &st) == 0 && (st.st_mode & 002)) {
d2237 1
a2237 1
    if (path && rb_sys_stat(path, &st) == 0) {
@


1.49
log
@* dir.c (glob_helper): replace lstat() by stat() to follow symlink
  in the case like 'symlink/*'.

* dir.c (glob_helper): gave warning too much.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/02/24 17:51:02 $
d316 1
a316 1
    return stat(RSTRING(file)->ptr, st);
d326 1
a326 1
    if (stat(RSTRING(fname)->ptr, &st) == -1) {
d422 1
a422 1
  if (stat(path, &st) < 0) return (-1);
d724 1
a724 1
    if (stat(file, &st) < 0) return Qfalse;
d2118 1
a2118 1
	if (stat(path, &st) == 0 && (st.st_mode & 002)) {
d2237 1
a2237 1
    if (path && stat(path, &st) == 0) {
@


1.48
log
@* file.c (rb_file_s_rename): avoid Cygwin's bug.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/02/16 07:53:19 $
d70 1
a70 1
#define lstat rb_sys_stat
d316 1
a316 1
    return rb_sys_stat(RSTRING(file)->ptr, st);
d326 1
a326 1
    if (rb_sys_stat(RSTRING(fname)->ptr, &st) == -1) {
d422 1
a422 1
  if (rb_sys_stat(path, &st) < 0) return (-1);
d724 1
a724 1
    if (rb_sys_stat(file, &st) < 0) return Qfalse;
@


1.47
log
@* io.c (set_outfile): f should be the FILE* from the assigning value.

* ext/socket/socket.c (tcp_s_open): should not give default value
  to local_host.

* time.c (time_s_times): move to Process::times.

* file.c (rb_file_s_lchmod): new method File::lchmod.

* file.c (rb_file_s_lchown): new method File::lchown.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/02/09 15:02:14 $
d1255 5
a1259 1
    if (rename(RSTRING(from)->ptr, RSTRING(to)->ptr) < 0)
d1261 1
@


1.46
log
@* win32/win32.c (win32_stat): replace stat for enable when pathname
  ends with '/' or '\' for mswin32 on Win9X / Win2k.

* win32/win32.h: ditto.

* ruby.h: ditto.

* dir.c (rb_glob_helper): ditto.

* file.c (rb_stat, rb_file_s_stat, eaccess, check3rdbyte): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/02/08 09:19:17 $
d954 36
d1051 47
d2292 2
@


1.45
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_options): new method to give an option values.

* parse.y (cond0): disable special treating of integer literal in
  conditional unless option -e is supplied.  changes current
  behavior.  experimental.

* parse.y (cond0): give warning for string/integer literals and
  dot operators in conditionals unless option -e is supplied.

* re.c (rb_reg_equal): all option flags should be same to be equal.

* error.c (Init_Exception): make Interrupt a subclass of
  SignalException.
@
text
@d6 1
a6 1
  $Date: 2001/01/29 05:10:41 $
d70 1
a70 1
#define lstat stat
d316 1
a316 1
    return stat(RSTRING(file)->ptr, st);
d326 1
a326 1
    if (stat(RSTRING(fname)->ptr, &st) == -1) {
d422 1
a422 1
  if (stat(path, &st) < 0) return (-1);
d724 1
a724 1
    if (stat(file, &st) < 0) return Qfalse;
@


1.44
log
@* string.c (str_independent): should not clear str->orig here.
  it's too early.
@
text
@d6 1
a6 1
  $Date: 2001/01/10 07:52:45 $
d1255 1
a1255 1
    else if (isalpha(s[0]) && s[1] == ':' && isdirsep(s[2])) {
@


1.43
log
@* m17n baseline.
@
text
@d6 1
a6 1
  $Date: 2001/01/09 08:04:39 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.42
log
@* file.c (path_check_1): should restore modified path.
@
text
@d6 1
a6 1
  $Date: 2000/11/13 05:39:32 $
a284 1
	char *p;
d2165 1
@


1.41
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/17 18:13:55 $
d2032 1
d2060 4
a2063 1
	if (!safe) return 0;
@


1.41.4.1
log
@m17n fix
@
text
@d6 1
a6 1
  $Date: 2000/11/13 05:39:32 $
d285 1
a2161 1
void
@


1.41.2.1
log
@* file.c (path_check_1): should restore modified path.
@
text
@d6 1
a6 1
  $Date: 2000/11/13 05:39:32 $
a2031 1
           if (p) *p = '/';
d2059 1
a2059 4
       if (!safe) {
           if (pend) *pend = sep;
           return 0;
       }
@


1.41.2.2
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_equal): all option flags should be same to be equal.
@
text
@d6 1
a6 1
  $Date: 2001/01/09 08:02:46 $
d1256 1
a1256 1
    else if (ISALPHA(s[0]) && s[1] == ':' && isdirsep(s[2])) {
@


1.41.2.3
log
@* win32/win32.c (win32_stat): replace stat for enable when pathname
  ends with '/' or '\' for mswin32 on Win9X / Win2k.

* win32/win32.h: ditto.

* ruby.h: ditto.

* dir.c (rb_glob_helper): ditto.

* file.c (rb_stat, rb_file_s_stat, eaccess, check3rdbyte): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/02/08 09:17:57 $
d70 1
a70 1
#define lstat rb_sys_stat
d317 1
a317 1
    return rb_sys_stat(RSTRING(file)->ptr, st);
d327 1
a327 1
    if (rb_sys_stat(RSTRING(fname)->ptr, &st) == -1) {
d423 1
a423 1
  if (rb_sys_stat(path, &st) < 0) return (-1);
d725 1
a725 1
    if (rb_sys_stat(file, &st) < 0) return Qfalse;
@


1.41.2.4
log
@* file.c (rb_file_s_rename): avoid Cygwin's bug.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/02/09 15:07:52 $
d1173 1
a1173 5
    if (rename(RSTRING(from)->ptr, RSTRING(to)->ptr) < 0) {
#if defined __CYGWIN__
	extern unsigned long __attribute__((stdcall)) GetLastError();
	errno = GetLastError(); /* This is a Cygwin bug */
#endif
a1174 1
    }
@


1.41.2.5
log
@* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE SUMMER TIME!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/02/24 17:50:14 $
d760 1
a760 2
    Check_SafeStr(fname);
    return check3rdbyte(RSTRING(fname)->ptr, S_ISVTX);
@


1.41.2.6
log
@* file.c (Init_File): should redifine "new" class method.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/04/06 05:42:39 $
d116 1
a116 2
stat_new_0(klass, st)
    VALUE klass;
d124 1
a124 8
    return Data_Wrap_Struct(klass, NULL, free, nst);
}

static VALUE
stat_new(st)
    struct stat *st;
{
    return stat_new_0(rb_cStat, st);
d321 2
a322 2
rb_file_s_stat(klass, fname)
    VALUE klass, fname;
d330 1
a330 1
    return stat_new_0(klass, &st);
d348 2
a349 2
rb_file_s_lstat(klass, fname)
    VALUE klass, fname;
d358 1
a358 1
    return stat_new_0(klass, &st);
d360 1
a360 1
    return rb_file_s_stat(klass, fname);
d768 2
a769 2
rb_file_s_size(klass, fname)
    VALUE klass, fname;
d819 2
a820 2
rb_file_s_ftype(klass, fname)
    VALUE klass, fname;
d833 2
a834 2
rb_file_s_atime(klass, fname)
    VALUE klass, fname;
d858 2
a859 2
rb_file_s_mtime(klass, fname)
    VALUE klass, fname;
d883 2
a884 2
rb_file_s_ctime(klass, fname)
    VALUE klass, fname;
d1101 2
a1102 2
rb_file_s_link(klass, from, to)
    VALUE klass, from, to;
d1113 2
a1114 2
rb_file_s_symlink(klass, from, to)
    VALUE klass, from, to;
d1130 2
a1131 2
rb_file_s_readlink(klass, path)
    VALUE klass, path;
d1158 2
a1159 2
rb_file_s_unlink(klass, args)
    VALUE klass, args;
d1168 2
a1169 2
rb_file_s_rename(klass, from, to)
    VALUE klass, from, to;
d1397 2
a1398 2
rb_file_s_dirname(klass, fname)
    VALUE klass, fname;
d1416 2
a1417 2
rb_file_s_split(klass, path)
    VALUE klass, path;
d1425 2
a1426 2
rb_file_s_join(klass, args)
    VALUE klass, args;
d1432 2
a1433 2
rb_file_s_truncate(klass, path, len)
    VALUE klass, path, len;
a1724 10
rb_stat_s_new(klass, fname)
    VALUE klass, fname;
{
    VALUE stat = rb_file_s_stat(klass, fname);

    rb_obj_call_init(stat, 1, &fname);
    return stat;
}

static VALUE
a2266 1
    rb_define_singleton_method(rb_cStat, "new",  rb_stat_s_new, 1);
@


1.41.2.7
log
@* file.c (Init_File): should redifine "new" class method.
@
text
@d6 1
a6 1
  $Date: 2001/04/09 04:56:39 $
d338 1
a338 1
    return stat_new(&st);
d1736 1
a1736 2
    VALUE s;
    struct stat st;
d1738 2
a1739 15
    Check_SafeStr(fname);
    if (rb_sys_stat(RSTRING(fname)->ptr, &st) == -1) {
	rb_sys_fail(RSTRING(fname)->ptr);
    }
    s = stat_new_0(klass, &st);
    rb_obj_call_init(s, 1, &fname);
    return s;
}

static VALUE
rb_stat_init(klass, fname)
    VALUE klass, fname;
{
    /* do nothing */
    return Qnil;
a2285 1
    rb_define_method(rb_cStat, "initialize", rb_stat_init, 1);
@


1.41.2.8
log
@* file.c (rb_file_s_lstat): stat_new_0 -> stat_new
@
text
@d6 1
a6 1
  $Date: 2001/04/09 05:52:44 $
d366 1
a366 1
    return stat_new(klass, &st);
@


1.41.2.9
log
@* file.c (rb_file_lstat): stat_new_0 -> stat_new
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/04/09 06:05:33 $
d366 1
a366 1
    return stat_new(&st);
@


1.41.2.10
log
@* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/04/09 06:31:44 $
d163 1
a163 1
    return INT2NUM(get_stat(self)->st_dev);
d170 1
a170 1
    return UINT2NUM(get_stat(self)->st_ino);
d177 1
a177 1
    return UINT2NUM(get_stat(self)->st_mode);
d184 1
a184 1
    return UINT2NUM(get_stat(self)->st_nlink);
d191 1
a191 1
    return UINT2NUM(get_stat(self)->st_uid);
d198 1
a198 1
    return UINT2NUM(get_stat(self)->st_gid);
d206 1
a206 1
    return INT2NUM(get_stat(self)->st_rdev);
d216 1
a216 1
    return INT2NUM(get_stat(self)->st_size);
d224 1
a224 1
    return UINT2NUM(get_stat(self)->st_blksize);
d235 1
a235 1
    return UINT2NUM(get_stat(self)->st_blocks);
d1526 1
a1526 3
          case EAGAIN:
          case EACCES:
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
a1527 1
#endif
d1530 1
a1530 1
            continue;
d1559 4
a1562 5
        switch (errno) {
          case EAGAIN:
          case EACCES:
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
          case EWOULDBLOCK:
a1563 2
              return Qfalse;
        }
a2203 1
void
@


1.41.2.11
log
@* eval.c (is_defined): core dumped during instance_eval for
  special constants.

* eval.c (rb_eval): ditto
@
text
@d6 1
a6 1
  $Date: 2001/04/16 06:54:36 $
d2140 1
a2140 1
	if (rb_safe_level() >= 2 && !rb_path_check(file)) {
@


1.41.2.12
log
@* file.c (rb_file_s_unlink): should not allow if $SAFE >= 2.

* object.c (rb_obj_taint): backport from 1.7.

* object.c (rb_obj_untaint): add frozen status check (backport from 1.7).

* ruby.c (proc_options): unexpected SecurityError happens when -T4.
@
text
@d6 1
a6 1
  $Date: 2001/05/08 08:29:51 $
a1170 1
    rb_secure(2);
@


1.41.2.13
log
@* eval.c (rb_f_require): searches ".rb" and ".so" at the same
  time.  previous behavior (search ".rb", then ".so") has a
  security risk (ruby-bugs#PR140).

* regex.c (re_compile_pattern): avoid pushing unnecessary
  option_set.

* eval.c (rb_load): tainted string is OK if wrapped *and*
  $SAFE >= 4.

* eval.c (rb_thread_start_0): should not nail down higher blocks
  before preserving original context (i.e. should not alter
  original context).
@
text
@d6 1
a6 1
  $Date: 2001/06/01 06:46:09 $
a2126 62
static char*
file_load_ok(file)
    char *file;
{
    FILE *f;

    f = fopen(file, "r");
    if (f == NULL) return 0;
    fclose(f);
    return file;
}

extern VALUE rb_load_path;

int
rb_find_file_noext(file)
    char *file;
{
    char *path, *e, *found;
    char *fend = file + strlen(file);
    VALUE fname;
    int i, j;

    static char *ext[] = {
	".rb", DLEXT,
#ifdef DLEXT2
	DLEXT2,
#endif
	0
    };

    if (file[0] == '~') {
	fname = rb_str_new2(file);
	fname = rb_file_s_expand_path(1, &fname);
	file = STR2CSTR(fname);
    }

    if (is_absolute_path(file)) {
	for (i=0; ext[i]; i++) {
	    strcpy(fend, ext[i]);
	    if (file_load_ok(file)) return i+1;
	}
	return 0;
    }

    if (!rb_load_path) return 0;

    Check_Type(rb_load_path, T_ARRAY);
    for (i=0;i<RARRAY(rb_load_path)->len;i++) {
	VALUE str = RARRAY(rb_load_path)->ptr[i];

	Check_SafeStr(str);
	path = RSTRING(str)->ptr;
	for (j=0; ext[j]; j++) {
	    strcpy(fend, ext[j]);
	    found = dln_find_file(file, path);
	    if (found && file_load_ok(found)) return j+1;
	}
    }
    return 0;
}

d2131 1
a2136 9
    if (file[0] == '~') {
	fname = rb_str_new2(file);
	fname = rb_file_s_expand_path(1, &fname);
	if (rb_safe_level() >= 2 && OBJ_TAINTED(fname)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", file);
	}
	file = STR2CSTR(fname);
    }

d2139 2
d2144 4
a2147 1
	return file_load_ok(file);
d2152 2
d2157 4
a2160 1
	return file_load_ok(file);
d2195 4
a2198 1
    return file_load_ok(path);
@


1.41.2.14
log
@* eval.c (rb_f_require): move rb_file_s_expand_path from
  rb_find_file_noext().

* file.c (rb_find_file_noext): move rb_file_s_expand_path to
  rb_f_require().

* string.c (rb_str_each_line): should propagate taint mark.

* ext/nkf/nkf.c (rb_nkf_kconv): ditto.

* ruby.c (load_file): local variables 'c' remain uninitialized on
  xflag.

* regex.c (re_match): prefetched escaped character too early.

* eval.c (rb_call0): add argument check for attr_readers.
@
text
@d6 1
a6 1
  $Date: 2001/06/19 04:36:34 $
d2157 6
@


1.41.2.15
log
@* eval.c (proc_invoke): should preserve iter status for embedded
  frame in the block.

* file.c (rb_file_s_expand_path): may overrun buffer on stack.

* regex.c (re_search): should consider reverse search.
@
text
@d6 1
a6 1
  $Date: 2001/07/06 06:36:58 $
a1228 1
    char *bend = buf + sizeof(buf) - 2;
a1242 1
	    if (strlen(dir) > MAXPATHLEN) goto toolong;
a1254 1
		if (p >= bend) goto toolong;
a1262 1
	    if (strlen(pwPtr->pw_dir) > MAXPATHLEN) goto toolong;
a1273 1
	    if (p >= bend) goto toolong;
a1280 1
	    if (strlen(RSTRING(dname)->ptr) > MAXPATHLEN) goto toolong;
a1296 1
	    if (p >= bend) goto toolong;
d1316 1
a1316 4
			do {
			    *++p = '.';
			    if (p >= bend) goto toolong;
			} while (*++s == '.');
a1337 1
	    if (p >= bend) goto toolong;
a1347 4

  toolong:
    rb_raise(rb_eArgError, "argument too long (size=%d)", RSTRING(fname)->len);
    return Qnil;		/* not reached */
@


1.41.2.16
log
@back port from 1.7
@
text
@d6 1
a6 1
  $Date: 2001/07/16 04:01:42 $
d2142 1
a2142 1
static int
a2147 1
    if (!file) return 0;
d2151 1
a2151 1
    return 1;
d2157 2
a2158 2
rb_find_file_noext(filep)
    VALUE *filep;
d2161 1
a2161 1
    char *f = RSTRING(*filep)->ptr;
d2173 1
a2173 9
    if (f[0] == '~') {
	fname = *filep;
	fname = rb_file_s_expand_path(1, &fname);
	if (rb_safe_level() >= 2 && OBJ_TAINTED(fname)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", f);
	}
    }

    if (is_absolute_path(f)) {
d2175 2
a2176 6
	    fname = rb_str_dup(*filep);
	    rb_str_cat2(fname, ext[i]);
	    if (file_load_ok(RSTRING(fname)->ptr)) {
		*filep = fname;
		return i+1;
	    }
d2190 3
a2192 7
	    fname = rb_str_dup(*filep);
	    rb_str_cat2(fname, ext[j]);
	    found = dln_find_file(RSTRING(fname)->ptr, path);
	    if (found && file_load_ok(found)) {
		*filep = fname;
		return j+1;
	    }
d2198 3
a2200 3
VALUE
rb_find_file(path)
    VALUE path;
d2202 3
a2204 3
    VALUE tmp, fname;
    char *f = RSTRING(path)->ptr;
    char *lpath;
d2207 5
a2211 4
    if (f[0] == '~') {
	tmp = rb_file_s_expand_path(1, &path);
	if (rb_safe_level() >= 2 && OBJ_TAINTED(tmp)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", f);
d2213 1
d2217 3
a2219 3
    if (is_macos_native_path(f)) {
	if (rb_safe_level() >= 2 && !rb_path_check(f)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", f);
d2221 1
a2221 1
	if (file_load_ok(f)) return path;
d2225 3
a2227 3
    if (is_absolute_path(f)) {
	if (rb_safe_level() >= 2 && !rb_path_check(f)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe file %s", f);
d2229 10
a2238 1
	if (file_load_ok(f)) return path;
d2245 1
a2245 1
	tmp = rb_ary_new();
d2250 1
a2250 1
		rb_ary_push(tmp, str);
d2253 4
a2256 4
	tmp = rb_ary_join(tmp, rb_str_new2(PATH_SEP));
	lpath = STR2CSTR(tmp);
	if (rb_safe_level() >= 2 && !rb_path_check(lpath)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe path %s", lpath);
d2260 1
a2260 1
	lpath = 0;
d2263 2
a2264 4
    f = dln_find_file(f, lpath);
    if (file_load_ok(f)) {
	return rb_str_new2(f);
    }
@


1.41.2.17
log
@* eval.c (rb_provide_feature): should not tweak extension used for
  loading.

* eval.c (rb_f_require): should not include path in $" value

* file.c (rb_find_file): should return 0 explicitly on failure.
@
text
@d6 1
a6 1
  $Date: 2001/07/19 07:59:47 $
a2272 1
    return 0;
@


1.41.2.18
log
@* file.c (rb_find_file_noext, rb_find_file): fix tilde expansion
  problem.
@
text
@d6 1
a6 1
  $Date: 2001/07/24 09:02:49 $
a2179 2
	f = STR2CSTR(fname);
	*filep = fname;
d2225 2
a2226 2
	path = rb_file_s_expand_path(1, &path);
	if (rb_safe_level() >= 2 && OBJ_TAINTED(path)) {
a2228 1
	f = STR2CSTR(path);
@


1.41.2.19
log
@* eval.c (rb_eval): add CHECK_INTS before next, redo, retry to
  avoid potential uninterruptable infinite loop.

* file.c (rb_file_s_expand_path): should not expand "." and ".."
  not following dirsep.

* eval.c (rb_provide_feature): should not tweak extension used for
  loading.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/07/26 03:54:48 $
d1227 1
a1227 1
    char *s, *p, *sbeg;
d1235 1
a1235 1
    sbeg = s = STR2CSTR(fname);
d1313 1
a1313 1
           if (*(s+1) && (s == sbeg || isdirsep(*(s - 1)))) {
a1338 3
           }
           else {
               *++p = '.';
@


1.41.2.20
log
@* file.c (rb_file_s_expand_path): expanded path should not end
  with "/.".
  removed meaningless code.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/07/27 08:54:49 $
d1227 1
a1227 1
    char *s, *p;
d1235 1
a1235 1
    s = STR2CSTR(fname);
d1313 1
a1313 4
	    if (!isdirsep(*p)) {
		*++p = '.';
	    }
	    else if (*(s+1)) {
d1323 5
a1327 2
			*++p = *s;
			if (p >= bend) goto toolong;
d1339 3
@


1.41.2.21
log
@* eval.c (is_defined): should not dump core for "defined?(())".

* eval.c (umethod_bind): recv can be an instance of descender of
  oklass if oklass is a Module.

* hash.c (rb_hash_equal): check identiry equality first.

* variable.c (mod_av_set): detect constant overriding for built-in
  classes/modules.

* marshal.c (w_object): should retrieve __member__ data from
  non-singleton class.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/07/31 04:00:44 $
d397 1
a397 1
    if (getgid() ==  gid)
d429 1
a429 1
  int euid;
d433 5
a437 2
  euid = geteuid();
  if (euid == 0) {
d439 1
a439 1
      if (!(mode & X_OK))
d446 1
a446 3

      return -1;
  }
d449 3
a451 3
      mode <<= 6;
  else if (getegid() == st.st_gid || group_member(st.st_gid))
      mode <<= 3;
d453 1
a453 1
  if ((st.st_mode & mode) == mode) return 0;
@


1.41.2.22
log
@* io.c (rb_io_popen): accept integer flags as mode.

* file.c (rb_find_file_ext): extension table can be supplied from
  outside.  renamed.

* eval.c (rb_f_require): replace rb_find_file_noext by
  rb_find_file_ext.

* eval.c (rb_provided): should also check feature without
  extension.

* numeric.c (flo_to_s): do not rely on decimal point to be '.'

* parse.y (yylex): ternary ? can be followed by newline.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/08/23 06:00:30 $
d2157 1
a2157 1
rb_find_file_ext(filep, ext)
a2158 1
    char **ext;
d2164 8
@


1.41.2.23
log
@* file.c (rb_find_file_ext): add const qualifiers to ext.

* intern.h (rb_find_file_ext): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/09/03 05:29:18 $
d2159 1
a2159 1
    const char *const *ext;
@


1.41.2.24
log
@small last minute changes (eval.c, file.c)
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/09/06 03:05:02 $
d79 1
a79 1
    void (*func)();
d93 2
a94 1
	(*func)(RSTRING(path)->ptr, arg);
@


1.41.2.25
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/09/18 03:47:03 $
d148 8
a155 11
    if (rb_obj_is_kind_of(other, rb_obj_class(self))) {
	time_t t1 = get_stat(self)->st_mtime;
	time_t t2 = get_stat(other)->st_mtime;
	if (t1 == t2)
	    return INT2FIX(0);
	else if (t1 < t2)
	    return INT2FIX(-1);
	else
	    return INT2FIX(1);
    }
    rb_raise(rb_eTypeError, "operand is not File::Stat");
d2338 1
a2338 1
    separator = rb_obj_freeze(rb_str_new2("/"));
d2345 1
a2345 1
    rb_define_const(rb_cFile, "ALT_SEPARATOR", rb_obj_freeze(rb_str_new2("\\")));
d2349 1
a2349 1
    rb_define_const(rb_cFile, "PATH_SEPARATOR", rb_obj_freeze(rb_str_new2(PATH_SEP)));
@


1.41.2.26
log
@* dir.c (my_getcwd): do not rely on MAXPATHLEN.

* eval.c (rb_yield_0): should not call rb_f_block_given_p().
@
text
@d6 1
a6 1
  $Date: 2001/10/29 05:04:40 $
d2121 4
a2124 4
	if (!safe) {
	    if (pend) *pend = sep;
	    return 0;
	}
@


1.41.2.27
log
@* eval.c (is_defined): should check receiver only once.

* eval.c (is_defined): should handle NODE_NEWLINE.

* file.c (rb_file_s_expand_path): memory leak fixed.
@
text
@d6 1
a6 1
  $Date: 2001/11/07 09:01:31 $
a1246 1
	    free(dir);
@


1.41.2.28
log
@* file.c (rb_file_s_expand_path): Do not free the pointer obtained
  from getenv().
@
text
@d6 1
a6 1
  $Date: 2002/03/20 09:42:30 $
d1247 1
@


1.41.2.29
log
@* file.c (rb_find_file): load must be done from an abolute path if
  $SAFE >= 4.

* re.c (rb_reg_s_quote): quote whitespaces for /x cases.

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* eval.c (rb_thread_cleanup): current thread may be THREAD_STOPPED,
  for example when terminated from signal handler.

* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.

* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* marshal.c (w_uclass): should check based on rb_obj_class(), not
  CLASS_OF().

* io.c (io_write): check error if written data is less than
  specified size to detect EPIPE.

* eval.c (assign): ruby_verbose should be surrounded by RTEST().

* object.c (rb_str2cstr): ditto.

* parse.y (void_expr): ditto.

* parse.y (void_stmts): ditto.

* variable.c (rb_ivar_get): ditto.

* variable.c (rb_cvar_set): ditto.

* variable.c (rb_cvar_get): ditto.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2002/03/26 19:46:18 $
a2241 4
    }

    if (rb_safe_level() >= 4) {
	rb_raise(rb_eSecurityError, "loading from non-absolute path %s", f);
@


1.41.2.30
log
@* time.c (time_arg): nil test against v[6] (usec).
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/01 09:37:58 $
d270 1
a270 1
    static struct {
@


1.41.2.31
log
@* file.c (rb_file_s_expand_path): accept drive letter on Cygwin.
* file.c (is_absolute_path): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/05/29 05:22:02 $
d1274 1
a1274 1
#if defined DOSISH || __CYGWIN__
d2063 1
a2063 1
# if defined DOSISH || defined __CYGWIN__
@


1.41.2.32
log
@* file.c (rb_path_check): nothing to check under DOSISH.
  [ruby-list:35772]
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/08/20 10:42:57 $
a2069 1
#ifndef DOSISH
d2094 1
a2094 1
	   return 0;
a2102 1
#endif
a2107 1
#ifndef DOSISH
a2129 1
#endif
@


1.41.2.33
log
@* eval.c (ruby_run): should set toplevel visibility again here.

* eval.c (rb_eval): should not rely on ruby_class == rb_cObject
  check.   Besides allow implicit publicity for attribute set
  methods.

* parse.y (primary): need not to check class_nest, just set
  whether method is an attrset or not.

* string.c (rb_str_each_line): p might be at the top of the
  string.

* variable.c (rb_path2class): should not use rb_eval_string().

* parse.y (str_extend): expression substitution can contain string
  terminator again.

* parse.y (yylex): the warning message "invalid
  character syntax" was never issued.

* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/09/05 20:53:31 $
a2200 1
	if (RSTRING(str)->len == 0) return 0;
d2265 3
a2267 8
	if (RSTRING(tmp)->len == 0) {
	    lpath = 0;
	}
	else {
	    lpath = STR2CSTR(tmp);
	    if (rb_safe_level() >= 2 && !rb_path_check(lpath)) {
		rb_raise(rb_eSecurityError, "loading from unsafe path %s", lpath);
	    }
a2273 3
    if (!lpath) {
	return 0;		/* no path, no load */
    }
@


1.41.2.34
log
@* array.c, class.c, eval.c, file.c, gc.c, node.h, numeric.c,
  object.c, parse.y, range.c, re.c, string.c, struct.c, util.c,
  ext/socket/socket.c: merge from 1.7: treat long values as long
  instead of int.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/25 07:07:37 $
d1362 1
a1362 1
    rb_raise(rb_eArgError, "argument too long (size=%ld)", RSTRING(fname)->len);
@


1.40
log
@1.6.2 (to be)
@
text
@d6 1
a6 1
  $Date: 2000/10/13 09:01:54 $
d943 4
a946 1
#if defined(DJGPP) || defined(NT) || defined(__BEOS__) || defined(__EMX__)
a948 3
	rb_sys_fail(fptr->path);
#else
    if (fchmod(fileno(fptr->f), mode) == -1)
@


1.39
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/10 07:03:17 $
d1533 1
d1541 4
a1544 1
    if (flock(fileno(fptr->f), NUM2INT(operation)) < 0) {
@


1.38
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/25 09:14:59 $
d1263 1
a1263 1
	if (argc == 2) {
@


1.37
log
@matz
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/09/22 03:37:26 $
d2175 1
a2175 1
    define_filetest_function("size", test_s, 1);
a2196 1
    rb_define_singleton_method(rb_cFile, "size",  rb_file_s_size, 1);
@


1.36
log
@eban
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/09/22 02:37:11 $
d1983 1
a1983 1
static VALUE rb_mConst;
d1990 1
a1990 2
    rb_define_const(rb_cFile, name, value);
    rb_define_const(rb_mConst, name, value);
d2242 2
a2243 1
    rb_mConst = rb_define_module_under(rb_cFile, "Constants");
@


1.35
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/21 09:30:55 $
d1132 1
a1132 1
#ifdef HAVE_READLINK_VOID
@


1.34
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/18 08:47:06 $
d1132 1
a1132 1
#ifdef READLINK
@


1.33
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/24 06:21:29 $
d69 1
a69 1
#ifdef __EMX__
d351 1
a351 1
#if !defined(MSDOS) && !defined(NT) && !defined(__EMX__)
d360 1
a360 2
    rb_notimplement();
    return Qnil;		/* not reached */
d368 1
a368 1
#if !defined(MSDOS) && !defined(NT)
d380 1
a380 2
    rb_notimplement();
    return Qnil;		/* not reached */
a822 4
#if defined(MSDOS) || defined(NT)
    if (rb_stat(fname, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
#else
a826 1
#endif
d1115 1
a1115 1
#if !defined(MSDOS) && !defined(NT) && !defined(__EMX__) && !defined(riscos)
d1132 1
a1132 1
#if !defined(MSDOS) && !defined(NT) && !defined(__EMX__) && !defined(riscos)
@


1.32
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/07 05:01:48 $
d2156 10
a2165 1
void
d2169 1
d2171 26
a2196 29
    rb_define_module_function(rb_mFileTest, "directory?",  test_d, 1);
    rb_define_module_function(rb_mFileTest, "exist?",  test_e, 1);
    rb_define_module_function(rb_mFileTest, "exists?",  test_e, 1); /* temporary */
    rb_define_module_function(rb_mFileTest, "readable?",  test_r, 1);
    rb_define_module_function(rb_mFileTest, "readable_real?",  test_R, 1);
    rb_define_module_function(rb_mFileTest, "writable?",  test_w, 1);
    rb_define_module_function(rb_mFileTest, "writable_real?",  test_W, 1);
    rb_define_module_function(rb_mFileTest, "executable?",  test_x, 1);
    rb_define_module_function(rb_mFileTest, "executable_real?",  test_X, 1);
    rb_define_module_function(rb_mFileTest, "file?",  test_f, 1);
    rb_define_module_function(rb_mFileTest, "zero?",  test_z, 1);
    rb_define_module_function(rb_mFileTest, "size?",  test_s, 1);
    rb_define_module_function(rb_mFileTest, "size",   test_s, 1);
    rb_define_module_function(rb_mFileTest, "owned?",  test_owned, 1);
    rb_define_module_function(rb_mFileTest, "grpowned?",  test_grpowned, 1);

    rb_define_module_function(rb_mFileTest, "pipe?",  test_p, 1);
    rb_define_module_function(rb_mFileTest, "symlink?",  test_l, 1);
    rb_define_module_function(rb_mFileTest, "socket?",  test_S, 1);

    rb_define_module_function(rb_mFileTest, "blockdev?",  test_b, 1);
    rb_define_module_function(rb_mFileTest, "chardev?",  test_c, 1);

    rb_define_module_function(rb_mFileTest, "setuid?",  test_suid, 1);
    rb_define_module_function(rb_mFileTest, "setgid?",  test_sgid, 1);
    rb_define_module_function(rb_mFileTest, "sticky?",  test_sticky, 1);

    rb_cFile = rb_define_class("File", rb_cIO);
    rb_extend_object(rb_cFile, CLASS_OF(rb_mFileTest));
@


1.31
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/19 08:38:05 $
d1593 5
@


1.30
log
@2000-06-19
@
text
@d6 1
a6 1
  $Date: 2000/06/12 07:48:19 $
d1025 1
a1025 1
#ifdef HAVE_UTIMES
d1507 1
a1507 1
#if defined(EWOULDBLOCK)
d1538 1
d1555 1
@


1.29
log
@2000-06-12
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/06/07 15:49:36 $
d254 47
d2265 2
@


1.28
log
@2000-06-08
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/05/31 03:10:01 $
d1333 1
a1333 1
	if (NIL_P(fext) || !(f = rmext(p, ext)))
d1335 1
a1335 1
	basename = rb_str_new(p, f);
a1698 1

d1933 1
a1933 1
    return Qnil;
@


1.27
log
@2000-05-31
@
text
@d6 1
a6 1
  $Date: 2000/05/30 04:23:55 $
d2170 1
a2170 1
#ifdef DOSISH
@


1.26
log
@2000-05-30
@
text
@d6 1
a6 1
  $Date: 2000/05/25 05:55:00 $
d1953 1
a1953 1
# if defined(MSDOS) || defined(NT) || defined(__human68k__) || defined(__EMX__)
@


1.25
log
@2000-05-25
@
text
@d6 1
a6 1
  $Date: 2000/05/24 04:33:56 $
d1333 11
a1343 3
	if (!NIL_P(fext)) {
	    f = rmext(name, ext);
	    if (f) return rb_str_new(name, f);
a1344 6
	return fname;
    }
    p++;			/* skip last `/' */
    if (!NIL_P(fext)) {
	f = rmext(p, ext);
	if (f) return rb_str_new(p, f);
d1346 1
a1346 2
    basename = rb_str_new2(p);
    if (OBJ_TAINTED(fname)) OBJ_TAINT(basename);
@


1.24
log
@2000-05-24
@
text
@d6 1
a6 1
  $Date: 2000/05/17 04:38:10 $
d2096 1
a2096 1
    if (stat(path, &st) == 0) {
@


1.23
log
@2000-05-17
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/05/13 16:12:15 $
d2036 1
d2095 5
a2099 1
    return dln_find_file(file, path);
@


1.22
log
@support mingw32.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/05/12 09:07:35 $
d1471 1
a1471 1
	  case EINTR:		/* can be happen? */
d1473 1
a1473 1
	    rb_thread_schedule();	/* busy wait */
@


1.21
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/09 04:52:55 $
d374 1
a374 1
#ifndef NT
d702 1
a702 1
#ifndef NT
d1016 1
a1016 1
#   if defined(_MSC_VER)
d1920 1
a1920 1
#ifndef NT
@


1.20
log
@2000-05-09
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:17 $
d28 6
d884 1
d937 1
d1388 1
@


1.19
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:44:07 $
d11 1
a11 1
  Copyright (C) 2000  Information-technology Promotion Agancy, Japan
@


1.18
log
@2000-04-10
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/03/17 08:58:11 $
d10 2
d13 1
a13 1
************************************************/
@


1.17
log
@2000-03-17
@
text
@d6 1
a6 1
  $Date: 2000/03/13 07:18:34 $
d1507 1
a1507 1
    if (n < argc) rb_raise(rb_eArgError, "wrong # of arguments(%d for %d)", argc, n);
@


1.16
log
@2000-03-13
@
text
@d6 1
a6 1
  $Date: 2000/03/07 08:37:30 $
d1964 1
@


1.15
log
@2000-03-07
@
text
@d6 1
a6 1
  $Date: 2000/02/17 07:11:08 $
d1960 1
a1960 1
	if (getcwd(path, sizeof(path)) == 0) return 0;
d1962 1
a1962 1
	if (getwd(path) == 0) return 0;
@


1.14
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:12:02 $
a60 7
#ifdef USE_CWGUSI
 #include "macruby_missing.h"
 extern int fileno(FILE *stream);
 extern int utimes();
 char* strdup(char*);
#endif

d103 1
a103 5
#ifndef NT
# ifndef USE_CWGUSI
#  include <sys/file.h>
# endif
#else
d335 1
a335 1
#if !defined(NT) && !defined(USE_CWGUSI)
d894 1
a894 1
#if defined(DJGPP) || defined(NT) || defined(USE_CWGUSI) || defined(__BEOS__) || defined(__EMX__)
d954 1
a954 1
#if defined(DJGPP) || defined(__CYGWIN32__) || defined(NT) || defined(USE_CWGUSI) || defined(__EMX__)
a1052 3
#if defined(USE_CWGUSI)
        rb_notimplement();
#else
a1058 1
#endif /* USE_CWGUSI */
a1133 3
#ifdef USE_CWGUSI
    rb_notimplement();
#else
a1147 1
#endif /* USE_CWGUSI */
a1478 3
#ifdef USE_CWGUSI
    rb_notimplement();
#else
a1495 1
#endif /* USE_CWGUSI */
@


1.13
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:37:40 $
d1080 1
a1080 1
#if !defined(MSDOS) && !defined(NT) && !defined(__EMX__)
d1097 1
a1097 1
#if !defined(MSDOS) && !defined(NT) && !defined(__EMX__)
d2029 1
a2029 1
#ifdef __MACOS__
d2048 1
a2048 1
#ifdef __MACOS__
@


1.12
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/08 05:00:18 $
d534 1
a534 1
    if (S_ISBLK(st.st_mode)) return Qtrue;
d1741 1
a1741 1
    if (S_ISBLK(get_stat(obj)->st_mode)) return Qtrue;
@


1.11
log
@2000-01-08
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:37:00 $
d1248 1
a1248 1
    else if (isdirsep(*s)) {
d1270 2
a1271 1
			*++p = '.';
@


1.10
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:49:42 $
d406 2
a407 2
#else  /* !NT*/
	return 0;
d1505 3
@


1.9
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/12/07 09:23:24 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d20 1
d1183 1
a1183 1
    int tainted = 0;
d1187 1
d1953 149
@


1.8
log
@991207
@
text
@d6 1
a6 1
  $Date: 1999/12/06 09:03:51 $
d105 1
a105 1
    if (fptr->path == NULL) return Qnil;
d264 1
a264 1
	rb_secure(4);
d328 1
a328 1
    rb_secure(4);
d330 1
d467 1
a468 1
#endif
d900 1
a900 1
    rb_secure(4);
d905 1
d962 1
a962 1
    rb_secure(4);
d965 1
d1153 1
a1153 1
    rb_secure(4);
d1432 1
a1432 1
    rb_secure(4);
d1500 1
a1500 1
    rb_secure(4);
@


1.7
log
@19991206
@
text
@d6 1
a6 1
  $Date: 1999/12/01 09:24:12 $
d734 2
a735 2
rb_file_ftype(mode)
    mode_t mode;
d739 1
a739 1
    if (S_ISREG(mode)) {
d741 1
a741 1
    } else if (S_ISDIR(mode)) {
d743 1
a743 1
    } else if (S_ISCHR(mode)) {
d747 1
a747 1
    else if (S_ISBLK(mode)) {
d752 1
a752 1
    else if (S_ISFIFO(mode)) {
d757 1
a757 1
    else if (S_ISLNK(mode)) {
d762 1
a762 1
    else if (S_ISSOCK(mode)) {
d789 1
a789 1
    return rb_file_ftype(st.st_mode);
a1185 1
	tainted = 1;
d1195 1
d1673 1
a1673 1
    return rb_file_ftype(get_stat(obj)->st_mode);
@


1.6
log
@19991201
@
text
@d6 1
a6 1
  $Date: 1999/11/25 09:03:05 $
d1179 1
d1186 1
d1229 1
d1233 1
d1293 3
a1295 1
    return rb_tainted_str_new2(buf);
d1767 1
a1767 1
    mode_t mode = get_stat(obj)->st_mode;
d1771 1
a1771 1
	return mode & S_IRUSR ? Qtrue : Qfalse;
d1775 1
a1775 1
	return mode & S_IRGRP ? Qtrue : Qfalse;
d1778 1
a1778 1
    if (!(mode & S_IROTH)) return Qfalse;
d1787 1
a1787 1
    mode_t mode = get_stat(obj)->st_mode;
d1791 1
a1791 1
	return mode & S_IRUSR ? Qtrue : Qfalse;
d1795 1
a1795 1
	return mode & S_IRGRP ? Qtrue : Qfalse;
d1798 1
a1798 1
    if (!(mode & S_IROTH)) return Qfalse;
d1807 1
a1807 1
    mode_t mode = get_stat(obj)->st_mode;
d1809 1
a1809 1
#ifdef S_IRUSR
d1811 1
a1811 1
	return mode & S_IWUSR ? Qtrue : Qfalse;
d1813 1
a1813 1
#ifdef S_IRGRP
d1815 1
a1815 1
	return mode & S_IWGRP ? Qtrue : Qfalse;
d1817 2
a1818 2
#ifdef S_IROTH
    if (!(mode & S_IWOTH)) return Qfalse;
d1827 1
a1827 1
    mode_t mode = get_stat(obj)->st_mode;
d1829 1
a1829 1
#ifdef S_IRUSR
d1831 1
a1831 1
	return mode & S_IWUSR ? Qtrue : Qfalse;
d1833 1
a1833 1
#ifdef S_IRGRP
d1835 1
a1835 1
	return mode & S_IWGRP ? Qtrue : Qfalse;
d1837 2
a1838 2
#ifdef S_IROTH
    if (!(mode & S_IWOTH)) return Qfalse;
d1847 1
a1847 1
    mode_t mode = get_stat(obj)->st_mode;
d1849 1
a1849 1
#ifdef S_IRUSR
d1851 1
a1851 1
	return mode & S_IXUSR ? Qtrue : Qfalse;
d1853 1
a1853 1
#ifdef S_IRGRP
d1855 1
a1855 1
	return mode & S_IXGRP ? Qtrue : Qfalse;
d1857 2
a1858 2
#ifdef S_IROTH
    if (!(mode & S_IXOTH)) return Qfalse;
d1867 1
a1867 1
    mode_t mode = get_stat(obj)->st_mode;
d1869 1
a1869 1
#ifdef S_IRUSR
d1871 1
a1871 1
	return mode & S_IXUSR ? Qtrue : Qfalse;
d1873 1
a1873 1
#ifdef S_IRGRP
d1875 1
a1875 1
	return mode & S_IXGRP ? Qtrue : Qfalse;
d1877 2
a1878 2
#ifdef S_IROTH
    if (!(mode & S_IXOTH)) return Qfalse;
@


1.5
log
@19991125
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:33 $
d73 1
a73 1
static VALUE sStat;
d121 1
d123 76
a198 7
    return rb_struct_new(sStat,
			 INT2FIX((int)st->st_dev),
			 INT2FIX((int)st->st_ino),
			 INT2FIX((int)st->st_mode),
			 INT2FIX((int)st->st_nlink),
			 INT2FIX((int)st->st_uid),
			 INT2FIX((int)st->st_gid),
d200 1
a200 1
			 INT2FIX((int)st->st_rdev),
d202 1
a202 1
			 INT2FIX(0),
d204 13
a216 1
			 INT2FIX((int)st->st_size),
d218 1
a218 1
			 INT2FIX((int)st->st_blksize),
d220 1
a220 1
			 INT2FIX(0),
d222 6
d229 1
a229 1
			 INT2FIX((int)st->st_blocks),
d231 1
a231 1
			 INT2FIX(0),
d233 21
a253 3
			 rb_time_new(st->st_atime, 0),
			 rb_time_new(st->st_mtime, 0),
			 rb_time_new(st->st_ctime, 0));
d1320 1
a1320 1
    VALUE fname, fext;
d1341 3
a1343 1
    return rb_tainted_str_new2(p);
d1351 1
d1360 3
a1362 1
    return rb_tainted_str_new(name, p - name);
a1662 7
static ID rb_st_mode;
static ID rb_st_size;
static ID rb_st_uid;
static ID rb_st_gid;

#define ST_MODE(obj) FIX2INT(rb_funcall3((obj), rb_st_mode, 0, 0))

d1667 1
a1667 1
    return rb_file_ftype(ST_MODE(obj));
d1674 1
a1674 1
    if (S_ISDIR(ST_MODE(obj))) return Qtrue;
d1683 1
a1683 1
    if (S_ISFIFO(ST_MODE(obj))) return Qtrue;
d1694 1
a1694 1
    if (S_ISLNK(ST_MODE(obj))) return Qtrue;
d1705 1
a1705 1
    if (S_ISSOCK(ST_MODE(obj))) return Qtrue;
d1716 1
a1716 1
    if (S_ISBLK(ST_MODE(obj))) return Qtrue;
d1726 1
a1726 1
    if (S_ISBLK(ST_MODE(obj))) return Qtrue;
d1735 1
a1735 1
    if (FIX2INT(rb_funcall3(obj, rb_st_uid, 0, 0)) == geteuid()) return Qtrue;
d1743 1
a1743 1
    if (FIX2INT(rb_funcall3(obj, rb_st_uid, 0, 0)) == getuid()) return Qtrue;
d1752 1
a1752 1
    if (FIX2INT(rb_funcall3(obj, rb_st_gid, 0, 0)) == getegid()) return Qtrue;
d1761 1
a1761 1
    mode_t mode = ST_MODE(obj);
d1781 1
a1781 1
    mode_t mode = ST_MODE(obj);
d1788 1
a1788 1
    if (group_member(FIX2INT(rb_funcall3(obj, rb_st_gid, 0, 0))))
d1801 1
a1801 1
    mode_t mode = ST_MODE(obj);
d1821 1
a1821 1
    mode_t mode = ST_MODE(obj);
d1828 1
a1828 1
    if (group_member(FIX2INT(rb_funcall3(obj, rb_st_gid, 0, 0))))
d1841 1
a1841 1
    mode_t mode = ST_MODE(obj);
d1861 1
a1861 1
    mode_t mode = ST_MODE(obj);
d1868 1
a1868 1
    if (group_member(FIX2INT(rb_funcall3(obj, rb_st_gid, 0, 0))))
d1881 1
a1881 1
    if (S_ISREG(ST_MODE(obj))) return Qtrue;
d1889 1
a1889 1
    if (rb_funcall3(obj, rb_st_size, 0, 0) == INT2FIX(0)) return Qtrue;
d1897 1
a1897 1
    VALUE size = rb_funcall3(obj, rb_st_size, 0, 0);
d1899 2
a1900 2
    if (size == INT2FIX(0)) return Qnil;
    return size;
d1908 1
a1908 1
    if (ST_MODE(obj) & S_ISUID) return Qtrue;
d1918 1
a1918 1
    if (ST_MODE(obj) & S_ISGID) return Qtrue;
d1928 1
a1928 1
    if (ST_MODE(obj) & S_ISVTX) return Qtrue;
d2041 45
a2085 35
    sStat = rb_struct_define("Stat", "dev", "ino", "mode",
			     "nlink", "uid", "gid", "rdev",
			     "size", "blksize", "blocks", 
			     "atime", "mtime", "ctime", 0);

    rb_st_mode = rb_intern("mode");
    rb_st_size = rb_intern("size");
    rb_st_uid = rb_intern("uid");
    rb_st_gid = rb_intern("gid");

    rb_define_method(sStat, "ftype",  rb_stat_ftype, 0);

    rb_define_method(sStat, "directory?",  rb_stat_d, 0);
    rb_define_method(sStat, "readable?",  rb_stat_r, 0);
    rb_define_method(sStat, "readable_real?",  rb_stat_R, 0);
    rb_define_method(sStat, "writable?",  rb_stat_w, 0);
    rb_define_method(sStat, "writable_real?",  rb_stat_W, 0);
    rb_define_method(sStat, "executable?",  rb_stat_x, 0);
    rb_define_method(sStat, "executable_real?",  rb_stat_X, 0);
    rb_define_method(sStat, "file?",  rb_stat_f, 0);
    rb_define_method(sStat, "zero?",  rb_stat_z, 0);
    rb_define_method(sStat, "size?",  rb_stat_s, 0);
    rb_define_method(sStat, "owned?",  rb_stat_owned, 0);
    rb_define_method(sStat, "grpowned?",  rb_stat_grpowned, 0);

    rb_define_method(sStat, "pipe?",  rb_stat_p, 0);
    rb_define_method(sStat, "symlink?",  rb_stat_l, 0);
    rb_define_method(sStat, "socket?",  rb_stat_S, 0);

    rb_define_method(sStat, "blockdev?",  rb_stat_b, 0);
    rb_define_method(sStat, "chardev?",  rb_stat_c, 0);

    rb_define_method(sStat, "setuid?",  rb_stat_suid, 0);
    rb_define_method(sStat, "setgid?",  rb_stat_sgid, 0);
    rb_define_method(sStat, "sticky?",  rb_stat_sticky, 0);
@


1.4
log
@19991012
@
text
@d6 1
a6 1
  $Date: 1999/09/16 09:40:32 $
d628 2
a629 2
rb_file_s_ftype(obj, fname)
    VALUE obj, fname;
a630 1
    struct stat st;
d633 1
a633 11
#if defined(MSDOS) || defined(NT)
    if (rb_stat(fname, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
#else
    Check_SafeStr(fname);
    if (lstat(RSTRING(fname)->ptr, &st) == -1) {
	rb_sys_fail(RSTRING(fname)->ptr);
    }
#endif

    if (S_ISREG(st.st_mode)) {
d635 1
a635 1
    } else if (S_ISDIR(st.st_mode)) {
d637 1
a637 1
    } else if (S_ISCHR(st.st_mode)) {
d641 1
a641 1
    else if (S_ISBLK(st.st_mode)) {
d646 1
a646 1
    else if (S_ISFIFO(st.st_mode)) {
d651 1
a651 1
    else if (S_ISLNK(st.st_mode)) {
d656 1
a656 1
    else if (S_ISSOCK(st.st_mode)) {
d668 19
d1552 277
d1941 31
@


1.4.2.1
log
@19991201
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:33 $
d1206 1
a1206 1
    VALUE fname, fext, basename;
d1227 1
a1227 3
    basename = rb_str_new2(p);
    if (OBJ_TAINTED(fname)) OBJ_TAINT(basename);
    return basename;
a1234 1
    VALUE dirname;
d1243 1
a1243 3
    dirname = rb_str_new(name, p - name);
    if (OBJ_TAINTED(fname)) OBJ_TAINT(dirname);
    return dirname;
@


1.4.2.2
log
@19991206
@
text
@d6 1
a6 1
  $Date: 1999/12/01 09:24:45 $
a1064 1
    int tainted = 0;
a1070 1
	tainted = 1;
a1112 1
	    if (OBJ_TAINTED(dname)) tainted = 1;
a1115 1
	    tainted = 1;
d1175 1
a1175 3
    fname = rb_str_new2(buf);
    if (tainted) OBJ_TAINT(fname);
    return fname;
@


1.4.2.3
log
@991208-repack
@
text
@d6 1
a6 1
  $Date: 1999/12/06 09:03:29 $
d298 2
a299 2
#else  /* !NT */
  return access(path, mode);
@


1.4.2.4
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 1999/12/08 00:37:33 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
d1129 1
a1129 1
    else {
d1151 1
a1151 2
			do *++p = '.'; while (*++s == '.');
			--s;
@


1.4.2.5
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:23:58 $
d426 1
a426 1
    if (S_ISCHR(st.st_mode)) return Qtrue;
@


1.4.2.6
log
@2000-03-24
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:11:20 $
d1408 1
a1408 1
    if (n != argc) rb_raise(rb_eArgError, "wrong # of arguments(%d for %d)", argc, n);
@


1.4.2.7
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/03/24 09:37:25 $
d61 4
a64 7
#include "macruby_missing.h"
extern int fileno(FILE *stream);
extern int utimes();
#endif

#ifndef strdup
char *strdup();
@


1.3
log
@1.4.1
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:05 $
d1524 2
a1525 2
	    break;

d1528 2
a1529 2
	    break;

d1532 2
a1533 2
	    break;

d1536 2
a1537 2
	    break;
	}
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/06 13:23:18 $
d1110 1
a1110 1
    else if (s[0] != '/') {
d1124 7
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1996/12/25 10:42:36 $
d9 1
a9 1
  Copyright (C) 1993-1996 Yukihiro Matsumoto
d13 4
d18 2
a19 1
#include "io.h"
d31 1
d43 2
d53 2
a54 4
#ifdef HAVE_STRING_H
# include <string.h>
#else
char *strrchr();
d57 1
a57 1
#ifdef NT
a58 1
#endif
d60 5
a64 3
#ifndef NT
char *strdup();
char *getenv();
d67 6
a72 3
extern VALUE cIO;
VALUE cFile;
VALUE mFileTest;
a74 92
VALUE time_new();

VALUE
file_open(fname, mode)
    char *fname, *mode;
{
    OpenFile *fptr;
    NEWOBJ(port, struct RFile);
    OBJSETUP(port, cFile, T_FILE);
    MakeOpenFile(port, fptr);

    fptr->mode = io_mode_flags(mode);
    fptr->f = rb_fopen(fname, mode);
    fptr->path = strdup(fname);

    return (VALUE)port;
}

static VALUE
file_s_open(argc, argv, class)
    int argc;
    VALUE *argv;
    VALUE class;
{
    VALUE fname, vmode, file;
    char *mode;

    rb_scan_args(argc, argv, "11", &fname, &vmode);
    Check_SafeStr(fname);
    if (!NIL_P(vmode)) {
	Check_Type(vmode, T_STRING);
	mode = RSTRING(vmode)->ptr;
    }
    else {
	mode = "r";
    }
    file = file_open(RSTRING(fname)->ptr, mode);

    RBASIC(file)->class = class;
    return file;
}

static VALUE
file_reopen(argc, argv, file)
    int argc;
    VALUE *argv;
    VALUE file;
{
    VALUE fname, nmode;
    char *mode;
    OpenFile *fptr;

    if (rb_scan_args(argc, argv, "11", &fname, &nmode) == 1) {
	if (TYPE(fname) == T_FILE) { /* fname must be IO */
	    return io_reopen(file, fname);
	}
    }

    Check_SafeStr(fname);
    if (!NIL_P(nmode)) {
	Check_Type(nmode, T_STRING);
	mode = RSTRING(nmode)->ptr;
    }
    else {
	mode = "r";
    }

    GetOpenFile(file, fptr);
    if (fptr->path) free(fptr->path);
    fptr->path = strdup(RSTRING(fname)->ptr);
    fptr->mode = io_mode_flags(mode);
    if (!fptr->f) {
	fptr->f = rb_fopen(RSTRING(fname)->ptr, mode);
	if (fptr->f2) {
	    fclose(fptr->f2);
	    fptr->f2 = NULL;
	}
	return file;
    }

    if (freopen(RSTRING(fname)->ptr, mode, fptr->f) == NULL) {
	rb_sys_fail(fptr->path);
    }
    if (fptr->f2) {
	if (freopen(RSTRING(fname)->ptr, "w", fptr->f2) == NULL) {
	    rb_sys_fail(fptr->path);
	}
    }

    return file;
}

d76 1
a76 1
apply2files(func, args, arg)
d78 1
a78 1
    struct RArray *args;
d83 1
d99 1
a99 47
file_tell(obj)
    VALUE obj;
{
    OpenFile *fptr;
    long pos;

    GetOpenFile(obj, fptr);

    pos = ftell(fptr->f);
    if (ferror(fptr->f) != 0) rb_sys_fail(0);

    return int2inum(pos);
}

static VALUE
file_seek(obj, offset, ptrname)
    VALUE obj, offset, ptrname;
{
    OpenFile *fptr;
    long pos;

    GetOpenFile(obj, fptr);

    pos = fseek(fptr->f, NUM2INT(offset), NUM2INT(ptrname));
    if (pos != 0) rb_sys_fail(0);
    clearerr(fptr->f);

    return obj;
}

static VALUE
file_set_pos(obj, offset)
    VALUE obj, offset;
{
    OpenFile *fptr;
    long pos;

    GetOpenFile(obj, fptr);
    pos = fseek(fptr->f, NUM2INT(offset), 0);
    if (pos != 0) rb_sys_fail(0);
    clearerr(fptr->f);

    return obj;
}

static VALUE
file_rewind(obj)
d105 2
a106 4
    if (fseek(fptr->f, 0L, 0) != 0) rb_sys_fail(0);
    clearerr(fptr->f);

    return obj;
a108 29
static VALUE
file_eof(obj)
    VALUE obj;
{
    OpenFile *fptr;

    GetOpenFile(obj, fptr);
    if (feof(fptr->f) == 0) return FALSE;
    return TRUE;
}

static VALUE
file_path(obj)
    VALUE obj;
{
    OpenFile *fptr;

    GetOpenFile(obj, fptr);
    return str_new2(fptr->path);
}

static VALUE
file_isatty(obj)
    VALUE obj;
{
    return FALSE;
}

#include <sys/types.h>
d110 3
a112 1
#include <sys/file.h>
a115 1
#include <sys/stat.h>
d121 8
a128 8
    if (!st) Bug("stat_new() called with bad value");
    return struct_new(sStat,
		      INT2FIX((int)st->st_dev),
		      INT2FIX((int)st->st_ino),
		      INT2FIX((int)st->st_mode),
		      INT2FIX((int)st->st_nlink),
		      INT2FIX((int)st->st_uid),
		      INT2FIX((int)st->st_gid),
d130 1
a130 1
		      INT2FIX((int)st->st_rdev),
d132 1
a132 1
		      INT2FIX(0),
d134 1
a134 1
		      INT2FIX((int)st->st_size),
d136 1
a136 1
		      INT2FIX((int)st->st_blksize),
d138 1
a138 1
		      INT2FIX(0),
d141 1
a141 1
		      INT2FIX((int)st->st_blocks),
d143 22
a164 1
		      INT2FIX(0),
d166 1
a166 3
		      time_new(st->st_atime, 0),
		      time_new(st->st_mtime, 0),
		      time_new(st->st_ctime, 0));
d170 2
a171 3
file_s_stat(obj, fname)
    VALUE obj;
    struct RString *fname;
d176 2
a177 2
    if (stat(fname->ptr, &st) == -1) {
	rb_sys_fail(fname->ptr);
d183 1
a183 1
file_stat(obj)
d197 2
a198 3
file_s_lstat(obj, fname)
    VALUE obj;
    struct RString *fname;
d200 1
a200 1
#if !defined(MSDOS) && !defined(NT)
d204 2
a205 2
    if (lstat(fname->ptr, &st) == -1) {
	rb_sys_fail(fname->ptr);
d209 2
a210 1
        rb_notimplement();
d215 1
a215 1
file_lstat(obj)
d218 1
a218 1
#if !defined(MSDOS) && !defined(NT) 
d222 1
d229 2
a230 1
        rb_notimplement();
d238 1
a238 1
#ifndef NT
d240 1
a240 1
	return TRUE;
d253 1
a253 1
		return TRUE;
d257 1
a257 1
    return FALSE;
d266 1
a266 1
     char *path;
a289 13
#if defined(DJGPP)
  {
    int stat_mode = 0;
    if (mode & X_OK)
      stat_mode |= S_IXOTH;
    if (mode & W_OK)
      stat_mode |= S_IWOTH;
    if (mode & R_OK)
      stat_mode |= S_IROTH;
    mode = stat_mode;
  }
#endif

d305 1
a305 2
    VALUE obj;
    struct RString *fname;
d313 3
a315 4
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    if (S_ISDIR(st.st_mode)) return TRUE;
    return FALSE;
d320 1
a320 2
    VALUE obj;
    struct RString *fname;
d329 2
a330 3
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    if (S_ISFIFO(st.st_mode)) return TRUE;
d333 1
a333 1
    return FALSE;
d338 1
a338 2
    VALUE obj;
    struct RString *fname;
d358 2
a359 2
    if (lstat(fname->ptr, &st) < 0) return FALSE;
    if (S_ISLNK(st.st_mode)) return TRUE;
d362 1
a362 1
    return FALSE;
d367 1
a367 2
    VALUE obj;
    struct RString *fname;
d386 2
a387 3
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    if (S_ISSOCK(st.st_mode)) return TRUE;
d390 1
a390 1
    return FALSE;
d395 1
a395 2
    VALUE obj;
    struct RString *fname;
d408 2
a409 3
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    if (S_ISBLK(st.st_mode)) return TRUE;
d412 1
a412 1
    return FALSE;
d417 1
a417 2
    VALUE obj;
    struct RString *fname;
d425 2
a426 3
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    if (S_ISBLK(st.st_mode)) return TRUE;
d428 1
a428 1
    return FALSE;
d433 1
a433 2
    VALUE obj;
    struct RString *fname;
d437 2
a438 3
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    return TRUE;
d443 1
a443 2
    VALUE obj;
    struct RString *fname;
d446 2
a447 2
    if (eaccess(fname->ptr, R_OK) < 0) return FALSE;
    return TRUE;
d452 1
a452 2
    VALUE obj;
    struct RString *fname;
d455 2
a456 2
    if (access(fname->ptr, R_OK) < 0) return FALSE;
    return TRUE;
d461 1
a461 2
    VALUE obj;
    struct RString *fname;
d464 2
a465 2
    if (eaccess(fname->ptr, W_OK) < 0) return FALSE;
    return TRUE;
d470 1
a470 2
    VALUE obj;
    struct RString *fname;
d473 2
a474 2
    if (access(fname->ptr, W_OK) < 0) return FALSE;
    return TRUE;
d479 1
a479 2
    VALUE obj;
    struct RString *fname;
d482 2
a483 2
    if (eaccess(fname->ptr, X_OK) < 0) return FALSE;
    return TRUE;
d488 1
a488 2
    VALUE obj;
    struct RString *fname;
d491 2
a492 2
    if (access(fname->ptr, X_OK) < 0) return FALSE;
    return TRUE;
d501 1
a501 2
    VALUE obj;
    struct RString *fname;
d505 3
a507 4
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    if (S_ISREG(st.st_mode)) return TRUE;
    return FALSE;
d512 1
a512 2
    VALUE obj;
    struct RString *fname;
d516 3
a518 4
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    if (st.st_size == 0) return TRUE;
    return FALSE;
d523 1
a523 2
    VALUE obj;
    struct RString *fname;
d527 3
a529 4
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    if (st.st_size == 0) return FALSE;
    return int2inum(st.st_size);
d534 1
a534 2
    VALUE obj;
    struct RString *fname;
d538 3
a540 4
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    if (st.st_uid == geteuid()) return TRUE;
    return FALSE;
d545 1
a545 2
    VALUE obj;
    struct RString *fname;
d549 3
a551 4
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    if (st.st_uid == getuid()) return TRUE;
    return FALSE;
d556 1
a556 2
    VALUE obj;
    struct RString *fname;
d561 2
a562 3
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) return FALSE;
    if (st.st_gid == getegid()) return TRUE;
d564 1
a564 1
    return FALSE;
d570 1
a570 1
    char *file;
d575 3
a577 3
    if (stat(file, &st) < 0) return FALSE;
    if (st.st_mode & mode) return TRUE;
    return FALSE;
d583 1
a583 2
    VALUE obj;
    struct RString *fname;
d587 1
a587 1
    return check3rdbyte(fname->ptr, S_ISUID);
d589 1
a589 1
    return FALSE;
d595 1
a595 2
    VALUE obj;
    struct RString *fname;
d599 1
a599 1
    return check3rdbyte(fname->ptr, S_ISGID);
d601 1
a601 1
    return FALSE;
d607 1
a607 2
    VALUE obj;
    struct RString *fname;
a608 1
    Check_Type(fname, T_STRING);
d610 1
a610 1
    return check3rdbyte(fname->ptr, S_ISVTX);
d612 1
a612 1
    return FALSE;
d617 2
a618 3
file_s_size(obj, fname)
    VALUE obj;
    struct RString *fname;
d622 3
a624 3
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) rb_sys_fail(fname->ptr);
    return int2inum(st.st_size);
d628 2
a629 3
file_s_ftype(obj, fname)
    VALUE obj;
    struct RString *fname;
d634 4
d639 4
a642 1
    if (stat(fname->ptr, &st) < 0) rb_sys_fail(fname->ptr);
d675 1
a675 1
    return str_new2(t);
d679 2
a680 3
file_s_atime(obj, fname)
    VALUE obj;
    struct RString *fname;
d684 3
a686 3
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) rb_sys_fail(fname->ptr);
    return time_new(st.st_atime, 0);
d690 1
a690 1
file_atime(obj)
d700 1
a700 1
    return time_new(st.st_atime, 0);
d704 2
a705 3
file_s_mtime(obj, fname)
    VALUE obj;
    struct RString *fname;
d709 3
a711 3
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) rb_sys_fail(fname->ptr);
    return time_new(st.st_mtime, 0);
d715 1
a715 1
file_mtime(obj)
d725 1
a725 1
    return time_new(st.st_mtime, 0);
d729 2
a730 3
file_s_ctime(obj, fname)
    VALUE obj;
    struct RString *fname;
d734 3
a736 3
    Check_SafeStr(fname);
    if (stat(fname->ptr, &st) < 0) rb_sys_fail(fname->ptr);
    return time_new(st.st_ctime, 0);
d740 1
a740 1
file_ctime(obj)
d750 1
a750 1
    return time_new(st.st_ctime, 0);
d755 1
a755 1
    char *path;
d763 1
a763 1
file_s_chmod(argc, argv)
d779 1
a779 1
file_chmod(obj, vmode)
d785 1
a785 1
    rb_secure(2);
d789 1
a789 1
#if defined(DJGPP) || defined(__CYGWIN32__) || defined(NT)
d806 1
a806 1
    char *path;
d814 1
a814 1
file_s_chown(argc, argv)
d841 1
a841 1
file_chown(obj, owner, group)
d846 1
a846 1
    rb_secure(2);
d848 1
a848 1
#if defined(DJGPP) || defined(__CYGWIN32__) || defined(NT)
d859 1
a859 1
struct timeval time_timeval();
d873 1
a873 1
file_s_utime(argc, argv)
d883 2
a884 2
    tvp[0] = time_timeval(atime);
    tvp[1] = time_timeval(mtime);
d894 3
d898 2
d901 1
d912 1
a912 1
    char *path;
d920 1
a920 1
file_s_utime(argc, argv)
d931 1
a931 1
    tv = time_timeval(atime);
d933 1
a933 1
    tv = time_timeval(mtime);
d943 2
a944 3
file_s_link(obj, from, to)
    VALUE obj;
    struct RString *from, *to;
d946 3
a948 1
#ifndef __human68k__
d952 2
a953 2
    if (link(from->ptr, to->ptr) < 0)
	rb_sys_fail(from->ptr);
d955 1
a955 3
#else
    rb_notimplement();
#endif
d959 2
a960 3
file_s_symlink(obj, from, to)
    VALUE obj;
    struct RString *from, *to;
d962 1
a962 1
#if !defined(MSDOS) && !defined(NT)
d966 3
a968 3
    if (symlink(from->ptr, to->ptr) < 0)
	rb_sys_fail(from->ptr);
    return TRUE;
d970 2
a971 1
        rb_notimplement();
d976 2
a977 3
file_s_readlink(obj, path)
    VALUE obj;
    struct RString *path;
d979 1
a979 1
#if !defined(MSDOS) && !defined(NT)
d985 2
a986 2
    if ((cc = readlink(path->ptr, buf, MAXPATHLEN)) < 0)
	rb_sys_fail(path->ptr);
d988 1
a988 1
    return str_new(buf, cc);
d991 1
d997 1
a997 1
    char *path;
d1004 2
a1005 3
file_s_unlink(obj, args)
    VALUE obj;
    struct RArray *args;
d1014 2
a1015 3
file_s_rename(obj, from, to)
    VALUE obj;
    struct RString *from, *to;
d1020 2
a1021 2
    if (rename(from->ptr, to->ptr) == -1)
	rb_sys_fail(from->ptr);
d1027 1
a1027 1
file_s_umask(argc, argv)
d1031 3
d1036 1
d1038 1
a1038 1
	int omask = umask(0);
d1045 1
a1045 1
	ArgError("wrong # of argument");
d1048 1
d1051 6
d1058 3
a1060 3
file_s_expand_path(obj, fname)
    VALUE obj;
    struct RString *fname;
d1062 1
d1064 1
a1064 1
    char buf[MAXPATHLEN];
d1066 1
a1066 2
    Check_Type(fname, T_STRING);
    s = fname->ptr;
d1068 1
d1071 1
a1071 1
	if (s[1] == '/' || s[1] == '\0') {
d1075 1
a1075 1
		Fail("couldn't find HOME environment -- expanding `%s'", s);
d1086 1
a1086 2

	    while (*s && *s != '/') {
d1094 1
a1094 1
		Fail("user %s doesn't exist", buf);
d1102 8
d1111 5
d1117 1
a1117 1
	getcwd(buf, MAXPATHLEN);
d1119 1
a1119 1
	getwd(buf);
d1121 1
d1123 1
d1133 1
a1133 1
		    if (*(s+1) == '\0' || *(s+1) == '/') { 
d1135 2
a1136 2
			if (*p == '/' && p > buf) p--;
			while (p > buf && *p != '/') p--;
d1144 4
a1147 1
		    if (*p != '/') *++p = '/'; 
d1155 4
a1158 1
	    if (*p != '/') *++p = '/'; break;
d1165 1
a1165 1
    if (p == buf || *p != '/') p++;
d1168 1
a1168 1
    return str_taint(str_new2(buf));
d1173 1
a1173 1
    char *p, *e;
d1181 5
d1195 1
a1195 1
file_s_basename(argc, argv)
d1199 2
a1200 3
    struct RString *fname;
    struct RString *ext;
    char *p;
d1203 5
a1207 4
    rb_scan_args(argc, argv, "11", &fname, &ext);
    Check_Type(fname, T_STRING);
    if (!NIL_P(ext)) Check_Type(ext, T_STRING);
    p = strrchr(fname->ptr, '/');
d1209 3
a1211 3
	if (!NIL_P(ext)) {
	    f = rmext(fname->ptr, ext->ptr);
	    if (f) return str_new(fname->ptr, f);
d1213 1
a1213 1
	return (VALUE)fname;
d1216 3
a1218 3
    if (!NIL_P(ext)) {
	f = rmext(p, ext->ptr);
	if (f) return str_new(p, f);
d1220 1
a1220 1
    return str_taint(str_new2(p));
d1224 2
a1225 3
file_s_dirname(obj, fname)
    VALUE obj;
    struct RString *fname;
d1227 1
a1227 1
    UCHAR *p;
d1229 2
a1230 2
    Check_Type(fname, T_STRING);
    p = strrchr(fname->ptr, '/');
d1232 1
a1232 1
	return str_new2(".");
d1234 1
a1234 1
    if (p == fname->ptr)
d1236 1
a1236 1
    return str_taint(str_new(fname->ptr, p - fname->ptr));
d1240 1
a1240 1
file_s_split(obj, path)
d1243 1
a1243 1
    return assoc_new(file_s_dirname(Qnil, path), file_s_basename(1,&path));
d1249 1
a1249 1
file_s_join(obj, args)
d1252 1
a1252 1
    return ary_join(args, separator);
d1256 2
a1257 3
file_s_truncate(obj, path, len)
    VALUE obj, len;
    struct RString *path;
d1262 2
a1263 2
    if (truncate(path->ptr, NUM2INT(len)) < 0)
	rb_sys_fail(path->ptr);
d1270 2
a1271 2
	if ((tmpfd = open(path->ptr, O_RDWR)) < 0) {
	    rb_sys_fail(path->ptr);
d1274 2
a1275 2
	if ((tmpfd = open(path->ptr, 0)) < 0) {
	    rb_sys_fail(path->ptr);
d1280 1
a1280 1
	    rb_sys_fail(path->ptr);
d1288 1
a1288 1
    return TRUE;
d1292 1
a1292 1
file_truncate(obj, len)
d1297 1
a1298 2

    rb_secure(2);
d1300 1
a1300 1
	Fail("not opened for writing");
d1313 38
a1350 1
    return TRUE;
d1352 2
d1356 1
a1356 1
file_flock(obj, operation)
d1360 3
d1365 1
a1367 1
    rb_secure(2);
d1371 1
a1371 1
	    return FALSE;
d1376 2
a1377 1
    return obj;
d1379 1
d1389 1
a1389 1
    if (n < argc) ArgError("Wrong # of arguments(%d for %d)", argc, n);
d1391 10
a1400 1
	Check_SafeStr(argv[i]);
d1407 1
a1407 1
f_test(argc, argv)
d1413 3
a1415 8
    if (argc == 0) ArgError("Wrong # of arguments");
    if (TYPE(argv[0]) == T_STRING && RSTRING(argv[0])->len == 1) {
	cmd = RSTRING(argv[0])->ptr[0];
    }
    else {
	cmd = NUM2INT(argv[0]);
    }
    if (cmd == 0) return FALSE;
d1492 1
a1492 1
	if (stat(RSTRING(argv[1])->ptr, &st) == -1) {
d1498 1
a1498 1
	    return time_new(st.st_atime, 0);
d1500 1
a1500 1
	    return time_new(st.st_mtime, 0);
d1502 1
a1502 1
	    return time_new(st.st_ctime, 0);
d1510 2
a1511 2
	if (stat(RSTRING(argv[1])->ptr, &st1) < 0) return FALSE;
	if (stat(RSTRING(argv[2])->ptr, &st2) < 0) return FALSE;
d1516 1
a1516 1
		return TRUE;
d1520 1
a1520 1
	    if (st1.st_mtime == st2.st_mtime) return TRUE;
d1524 1
a1524 1
	    if (st1.st_mtime > st2.st_mtime) return TRUE;
d1528 1
a1528 1
	    if (st1.st_mtime < st2.st_mtime) return TRUE;
d1532 3
a1534 1
    return FALSE;
d1537 10
a1546 1
extern VALUE mKernel;
d1551 1
a1551 104
    mFileTest = rb_define_module("FileTest");

    rb_define_module_function(mFileTest, "directory?",  test_d, 1);
    rb_define_module_function(mFileTest, "exist?",  test_e, 1);
    rb_define_module_function(mFileTest, "exists?",  test_e, 1); /* temporary */
    rb_define_module_function(mFileTest, "readable?",  test_r, 1);
    rb_define_module_function(mFileTest, "readable_real?",  test_R, 1);
    rb_define_module_function(mFileTest, "writable?",  test_w, 1);
    rb_define_module_function(mFileTest, "writable_real?",  test_W, 1);
    rb_define_module_function(mFileTest, "executable?",  test_x, 1);
    rb_define_module_function(mFileTest, "executable_real?",  test_X, 1);
    rb_define_module_function(mFileTest, "file?",  test_f, 1);
    rb_define_module_function(mFileTest, "zero?",  test_z, 1);
    rb_define_module_function(mFileTest, "size?",  test_s, 1);
    rb_define_module_function(mFileTest, "owned?",  test_owned, 1);
    rb_define_module_function(mFileTest, "grpowned?",  test_grpowned, 1);

    rb_define_module_function(mFileTest, "pipe?",  test_p, 1);
    rb_define_module_function(mFileTest, "symlink?",  test_l, 1);
    rb_define_module_function(mFileTest, "socket?",  test_S, 1);

    rb_define_module_function(mFileTest, "blockdev?",  test_b, 1);
    rb_define_module_function(mFileTest, "chardev?",  test_c, 1);

    rb_define_module_function(mFileTest, "setuid?",  test_suid, 1);
    rb_define_module_function(mFileTest, "setgid?",  test_sgid, 1);
    rb_define_module_function(mFileTest, "sticky?",  test_sticky, 1);

    cFile = rb_define_class("File", cIO);
    rb_extend_object(cFile, CLASS_OF(mFileTest));

    rb_define_singleton_method(cFile, "new",  file_s_open, -1);
    rb_define_singleton_method(cFile, "open",  file_s_open, -1);

    rb_define_singleton_method(cFile, "stat",  file_s_stat, 1);
    rb_define_singleton_method(cFile, "lstat", file_s_lstat, 1);
    rb_define_singleton_method(cFile, "ftype", file_s_ftype, 1);

    rb_define_singleton_method(cFile, "atime", file_s_atime, 1);
    rb_define_singleton_method(cFile, "mtime", file_s_mtime, 1);
    rb_define_singleton_method(cFile, "ctime", file_s_ctime, 1);
    rb_define_singleton_method(cFile, "size",  file_s_size, 1);

    rb_define_singleton_method(cFile, "utime", file_s_utime, -1);
    rb_define_singleton_method(cFile, "chmod", file_s_chmod, -1);
    rb_define_singleton_method(cFile, "chown", file_s_chown, -1);

    rb_define_singleton_method(cFile, "link", file_s_link, 2);
    rb_define_singleton_method(cFile, "symlink", file_s_symlink, 2);
    rb_define_singleton_method(cFile, "readlink", file_s_readlink, 1);

    rb_define_singleton_method(cFile, "unlink", file_s_unlink, -2);
    rb_define_singleton_method(cFile, "delete", file_s_unlink, -2);
    rb_define_singleton_method(cFile, "rename", file_s_rename, 2);
    rb_define_singleton_method(cFile, "umask", file_s_umask, -1);
    rb_define_singleton_method(cFile, "truncate", file_s_truncate, 2);
    rb_define_singleton_method(cFile, "expand_path", file_s_expand_path, 1);
    rb_define_singleton_method(cFile, "basename", file_s_basename, -1);
    rb_define_singleton_method(cFile, "dirname", file_s_dirname, 1);

    separator = str_new2("/");
    rb_define_const(cFile, "Separator", separator);
    rb_define_singleton_method(cFile, "split",  file_s_split, 1);
    rb_define_singleton_method(cFile, "join",   file_s_join, -2);

    rb_define_method(cFile, "reopen",  file_reopen, -1);

    rb_define_method(cFile, "stat",  file_stat, 0);
    rb_define_method(cFile, "lstat",  file_lstat, 0);

    rb_define_method(cFile, "atime", file_atime, 0);
    rb_define_method(cFile, "mtime", file_mtime, 0);
    rb_define_method(cFile, "ctime", file_ctime, 0);

    rb_define_method(cFile, "chmod", file_chmod, 1);
    rb_define_method(cFile, "chown", file_chown, 2);
    rb_define_method(cFile, "truncate", file_truncate, 1);

    rb_define_method(cFile, "tell",  file_tell, 0);
    rb_define_method(cFile, "seek",  file_seek, 2);

    rb_define_method(cFile, "pos",  file_tell, 0);
    rb_define_method(cFile, "pos=", file_set_pos, 1);

    rb_define_method(cFile, "rewind", file_rewind, 0);
    rb_define_method(cFile, "isatty", file_isatty, 0);
    rb_define_method(cFile, "tty?",  file_isatty, 0);
    rb_define_method(cFile, "eof", file_eof, 0);
    rb_define_method(cFile, "eof?", file_eof, 0);

    rb_define_method(cFile, "flock", file_flock, 1);

# ifndef LOCK_SH
#  define LOCK_SH 1
# endif
# ifndef LOCK_EX
#  define LOCK_EX 2
# endif
# ifndef LOCK_NB
#  define LOCK_NB 4
# endif
# ifndef LOCK_UN
#  define LOCK_UN 8
# endif
d1553 96
a1648 13
    rb_define_const(cFile, "LOCK_SH", INT2FIX(LOCK_SH));
    rb_define_const(cFile, "LOCK_EX", INT2FIX(LOCK_EX));
    rb_define_const(cFile, "LOCK_UN", INT2FIX(LOCK_UN));
    rb_define_const(cFile, "LOCK_NB", INT2FIX(LOCK_NB));

    rb_define_method(cFile, "path",  file_path, 0);

    rb_define_global_function("test", f_test, -1);

    sStat = struct_define("Stat", "dev", "ino", "mode",
			  "nlink", "uid", "gid", "rdev",
			  "size", "blksize", "blocks", 
			  "atime", "mtime", "ctime", 0);
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d45 3
a47 1
#ifndef HAVE_STRING_H
d51 1
d53 1
a103 4
    if (iterator_p()) {
	rb_ensure(rb_yield, file, io_close, file);
    }

d139 1
a139 2
	    if (fileno(fptr->f2) < 3)	/* need to keep stdio */
		fclose(fptr->f2);
d158 1
a158 1
apply2files(func, vargs, arg)
d160 1
a160 1
    VALUE vargs;
a164 1
    struct RArray *args = RARRAY(vargs);
d272 1
d309 2
a310 1
    VALUE obj, fname;
d315 2
a316 2
    if (stat(RSTRING(fname)->ptr, &st) == -1) {
	rb_sys_fail(RSTRING(fname)->ptr);
d337 2
a338 1
    VALUE obj, fname;
d344 2
a345 2
    if (lstat(RSTRING(fname)->ptr, &st) == -1) {
	rb_sys_fail(RSTRING(fname)->ptr);
d427 13
d455 2
a456 1
    VALUE obj, fname;
d465 1
a465 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d472 2
a473 1
    VALUE obj, fname;
d483 1
a483 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d492 2
a493 1
    VALUE obj, fname;
d513 1
a513 1
    if (lstat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d522 2
a523 1
    VALUE obj, fname;
d543 1
a543 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d552 2
a553 1
    VALUE obj, fname;
d567 1
a567 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d576 2
a577 1
    VALUE obj, fname;
d586 1
a586 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d594 2
a595 1
    VALUE obj, fname;
d600 1
a600 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d606 2
a607 1
    VALUE obj, fname;
d610 1
a610 1
    if (eaccess(RSTRING(fname)->ptr, R_OK) < 0) return FALSE;
d616 2
a617 1
    VALUE obj, fname;
d620 1
a620 1
    if (access(RSTRING(fname)->ptr, R_OK) < 0) return FALSE;
d626 2
a627 1
    VALUE obj, fname;
d630 1
a630 1
    if (eaccess(RSTRING(fname)->ptr, W_OK) < 0) return FALSE;
d636 2
a637 1
    VALUE obj, fname;
d640 1
a640 1
    if (access(RSTRING(fname)->ptr, W_OK) < 0) return FALSE;
d646 2
a647 1
    VALUE obj, fname;
d650 1
a650 1
    if (eaccess(RSTRING(fname)->ptr, X_OK) < 0) return FALSE;
d656 2
a657 1
    VALUE obj, fname;
d660 1
a660 1
    if (access(RSTRING(fname)->ptr, X_OK) < 0) return FALSE;
d670 2
a671 1
    VALUE obj, fname;
d676 1
a676 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d683 2
a684 1
    VALUE obj, fname;
d689 1
a689 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d696 2
a697 1
    VALUE obj, fname;
d702 1
a702 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d709 2
a710 1
    VALUE obj, fname;
d715 1
a715 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d722 2
a723 1
    VALUE obj, fname;
d728 1
a728 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d735 2
a736 1
    VALUE obj, fname;
d742 1
a742 1
    if (stat(RSTRING(fname)->ptr, &st) < 0) return FALSE;
d764 2
a765 1
    VALUE obj, fname;
d769 1
a769 1
    return check3rdbyte(RSTRING(fname)->ptr, S_ISUID);
d777 2
a778 1
    VALUE obj, fname;
d782 1
a782 1
    return check3rdbyte(RSTRING(fname)->ptr, S_ISGID);
d790 2
a791 1
    VALUE obj, fname;
d795 1
a795 1
    return check3rdbyte(RSTRING(fname)->ptr, S_ISVTX);
d803 2
a804 1
    VALUE obj, fname;
d809 1
a809 2
    if (stat(RSTRING(fname)->ptr, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
d815 2
a816 1
    VALUE obj, fname;
d822 1
a822 2
    if (stat(RSTRING(fname)->ptr, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
d860 2
a861 1
    VALUE obj, fname;
d866 1
a866 2
    if (stat(RSTRING(fname)->ptr, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
d886 2
a887 1
    VALUE obj, fname;
d892 1
a892 2
    if (stat(RSTRING(fname)->ptr, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
d912 2
a913 1
    VALUE obj, fname;
d918 1
a918 2
    if (stat(RSTRING(fname)->ptr, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
d1121 2
a1122 1
    VALUE obj, from, to;
d1124 1
d1128 2
a1129 2
    if (link(RSTRING(from)->ptr, RSTRING(to)->ptr) < 0)
	rb_sys_fail(RSTRING(from)->ptr);
d1131 3
d1138 2
a1139 1
    VALUE obj, from, to;
d1145 2
a1146 2
    if (symlink(RSTRING(from)->ptr, RSTRING(to)->ptr) < 0)
	rb_sys_fail(RSTRING(from)->ptr);
d1155 2
a1156 1
    VALUE obj, path;
d1164 2
a1165 2
    if ((cc = readlink(RSTRING(path)->ptr, buf, MAXPATHLEN)) < 0)
	rb_sys_fail(RSTRING(path)->ptr);
d1183 2
a1184 1
    VALUE obj, args;
d1194 2
a1195 1
    VALUE obj, from, to;
d1200 2
a1201 2
    if (rename(RSTRING(from)->ptr, RSTRING(to)->ptr) < 0)
	rb_sys_fail(RSTRING(from)->ptr);
d1228 2
a1229 1
    VALUE obj, fname;
d1235 1
a1235 1
    s = RSTRING(fname)->ptr;
a1328 5
    if (l2 == 2 && e[1] == '*') {
	e = strrchr(p, *e);
	if (!e) return 0;
	return e - p;
    }
d1342 2
a1343 1
    VALUE fname, ext;
d1350 1
a1350 1
    p = strrchr(RSTRING(fname)->ptr, '/');
d1353 2
a1354 2
	    f = rmext(RSTRING(fname)->ptr, RSTRING(ext)->ptr);
	    if (f) return str_new(RSTRING(fname)->ptr, f);
d1360 1
a1360 1
	f = rmext(p, RSTRING(ext)->ptr);
d1368 2
a1369 1
    VALUE obj, fname;
d1374 1
a1374 1
    p = strrchr(RSTRING(fname)->ptr, '/');
d1378 1
a1378 1
    if (p == RSTRING(fname)->ptr)
d1380 1
a1380 1
    return str_taint(str_new(RSTRING(fname)->ptr, p - RSTRING(fname)->ptr));
d1401 2
a1402 1
    VALUE obj, path, len;
d1407 2
a1408 2
    if (truncate(RSTRING(path)->ptr, NUM2INT(len)) < 0)
	rb_sys_fail(RSTRING(path)->ptr);
d1415 2
a1416 2
	if ((tmpfd = open(RSTRING(path)->ptr, O_RDWR)) < 0) {
	    rb_sys_fail(RSTRING(path)->ptr);
d1419 2
a1420 2
	if ((tmpfd = open(RSTRING(path)->ptr, 0)) < 0) {
	    rb_sys_fail(RSTRING(path)->ptr);
d1425 1
a1425 1
	    rb_sys_fail(RSTRING(path)->ptr);
a1637 2
    VALUE mConst;

a1651 1
    rb_define_module_function(mFileTest, "size",   test_s, 1);
a1742 1
    mConst = rb_define_module_under(cFile, "Constants");
a1746 5

    rb_define_const(mConst, "LOCK_SH", INT2FIX(LOCK_SH));
    rb_define_const(mConst, "LOCK_EX", INT2FIX(LOCK_EX));
    rb_define_const(mConst, "LOCK_UN", INT2FIX(LOCK_UN));
    rb_define_const(mConst, "LOCK_NB", INT2FIX(LOCK_NB));
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/11/25 03:31:13 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
a12 4
#ifdef NT
#include "missing/file.h"
#endif

d14 1
a14 2
#include "rubyio.h"
#include "rubysig.h"
d46 1
a46 1
char *strrchr _((char*,char));
a48 1
#include <sys/types.h>
d51 3
a53 4
#ifdef USE_CWGUSI
 #include "macruby_missing.h"
 extern int fileno(FILE *stream);
 extern int utimes();
d56 3
a58 2
VALUE rb_cFile;
VALUE rb_mFileTest;
d61 2
d64 1
a64 1
rb_file_open(fname, mode)
d69 1
a69 1
    OBJSETUP(port, rb_cFile, T_FILE);
d72 1
a72 1
    fptr->mode = rb_io_mode_flags(mode);
a74 1
    rb_obj_call_init((VALUE)port);
d80 1
a80 1
rb_file_s_open(argc, argv, klass)
d83 1
a83 1
    VALUE klass;
d91 2
a92 1
	mode = STR2CSTR(vmode);
d97 1
a97 1
    file = rb_file_open(RSTRING(fname)->ptr, mode);
d99 3
a101 4
    RBASIC(file)->klass = klass;
    rb_obj_call_init(file);
    if (rb_iterator_p()) {
	return rb_ensure(rb_yield, file, rb_io_close, file);
d108 1
a108 1
rb_file_reopen(argc, argv, file)
a116 1
    rb_secure(4);
d119 1
a119 1
	    return rb_io_reopen(file, fname);
d125 2
a126 1
	mode = STR2CSTR(nmode);
d135 1
a135 1
    fptr->mode = rb_io_mode_flags(mode);
d139 2
a140 1
	    fclose(fptr->f2);
d182 60
a241 1
rb_file_path(obj)
d247 2
a248 2
    if (fptr->path == NULL) return Qnil;
    return rb_str_new2(fptr->path);
d251 18
d270 1
a270 3
# ifndef USE_CWGUSI
#  include <sys/file.h>
# endif
d279 8
a286 8
    if (!st) rb_bug("stat_new() called with bad value");
    return rb_struct_new(sStat,
			 INT2FIX((int)st->st_dev),
			 INT2FIX((int)st->st_ino),
			 INT2FIX((int)st->st_mode),
			 INT2FIX((int)st->st_nlink),
			 INT2FIX((int)st->st_uid),
			 INT2FIX((int)st->st_gid),
d288 1
a288 1
			 INT2FIX((int)st->st_rdev),
d290 1
a290 1
			 INT2FIX(0),
d292 1
a292 1
			 INT2FIX((int)st->st_size),
d294 1
a294 1
			 INT2FIX((int)st->st_blksize),
d296 1
a296 1
			 INT2FIX(0),
d299 1
a299 1
			 INT2FIX((int)st->st_blocks),
d301 1
a301 1
			 INT2FIX(0),
d303 3
a305 19
			 rb_time_new(st->st_atime, 0),
			 rb_time_new(st->st_mtime, 0),
			 rb_time_new(st->st_ctime, 0));
}

static int
rb_stat(file, st)
    VALUE file;
    struct stat *st;
{
    if (TYPE(file) == T_FILE) {
	OpenFile *fptr;

	rb_secure(4);
	GetOpenFile(file, fptr);
	return fstat(fileno(fptr->f), st);
    }
    Check_SafeStr(file);
    return stat(RSTRING(file)->ptr, st);
d309 1
a309 1
rb_file_s_stat(obj, fname)
d322 1
a322 1
rb_io_stat(obj)
d336 1
a336 1
rb_file_s_lstat(obj, fname)
d348 1
a348 2
    rb_notimplement();
    return Qnil;		/* not reached */
d353 1
a353 1
rb_file_lstat(obj)
a359 1
    rb_secure(4);
d366 1
a366 2
    rb_notimplement();
    return Qnil;		/* not reached */
d374 1
a374 1
#if !defined(NT) && !defined(USE_CWGUSI)
d376 1
a376 1
	return Qtrue;
d389 1
a389 1
		return Qtrue;
d393 1
a393 1
    return Qfalse;
d449 4
a452 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISDIR(st.st_mode)) return Qtrue;
    return Qfalse;
d466 3
a468 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISFIFO(st.st_mode)) return Qtrue;
d471 1
a471 1
    return Qfalse;
d496 2
a497 2
    if (lstat(RSTRING(fname)->ptr, &st) < 0) return Qfalse;
    if (S_ISLNK(st.st_mode)) return Qtrue;
d500 1
a500 1
    return Qfalse;
d524 3
a526 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISSOCK(st.st_mode)) return Qtrue;
d529 1
a529 1
    return Qfalse;
d547 3
a549 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISBLK(st.st_mode)) return Qtrue;
d552 1
a552 1
    return Qfalse;
d565 3
a567 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISBLK(st.st_mode)) return Qtrue;
d569 1
a569 1
    return Qfalse;
d578 3
a580 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    return Qtrue;
d588 2
a589 2
    if (eaccess(RSTRING(fname)->ptr, R_OK) < 0) return Qfalse;
    return Qtrue;
d597 2
a598 2
    if (access(RSTRING(fname)->ptr, R_OK) < 0) return Qfalse;
    return Qtrue;
d606 2
a607 2
    if (eaccess(RSTRING(fname)->ptr, W_OK) < 0) return Qfalse;
    return Qtrue;
d615 2
a616 2
    if (access(RSTRING(fname)->ptr, W_OK) < 0) return Qfalse;
    return Qtrue;
d624 2
a625 2
    if (eaccess(RSTRING(fname)->ptr, X_OK) < 0) return Qfalse;
    return Qtrue;
d633 2
a634 2
    if (access(RSTRING(fname)->ptr, X_OK) < 0) return Qfalse;
    return Qtrue;
d647 4
a650 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISREG(st.st_mode)) return Qtrue;
    return Qfalse;
d659 4
a662 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_size == 0) return Qtrue;
    return Qfalse;
d671 4
a674 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_size == 0) return Qfalse;
    return rb_int2inum(st.st_size);
d683 4
a686 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_uid == geteuid()) return Qtrue;
    return Qfalse;
d695 4
a698 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_uid == getuid()) return Qtrue;
    return Qfalse;
d708 3
a710 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_gid == getegid()) return Qtrue;
d712 1
a712 1
    return Qfalse;
d723 3
a725 3
    if (stat(file, &st) < 0) return Qfalse;
    if (st.st_mode & mode) return Qtrue;
    return Qfalse;
d737 1
a737 1
    return Qfalse;
d749 1
a749 1
    return Qfalse;
d757 1
d759 1
a759 1
    return check3rdbyte(STR2CSTR(fname), S_ISVTX);
d761 1
a761 1
    return Qfalse;
d766 1
a766 1
rb_file_s_size(obj, fname)
d771 2
a772 1
    if (rb_stat(fname, &st) < 0)
d774 1
a774 1
    return rb_int2inum(st.st_size);
d778 1
a778 1
rb_file_s_ftype(obj, fname)
a783 4
#if defined(MSDOS) || defined(NT)
    if (rb_stat(fname, &st) < 0)
	rb_sys_fail(RSTRING(fname)->ptr);
#else
d785 1
a785 1
    if (lstat(RSTRING(fname)->ptr, &st) == -1) {
a786 2
    }
#endif
d819 1
a819 1
    return rb_str_new2(t);
d823 1
a823 1
rb_file_s_atime(obj, fname)
d828 2
a829 1
    if (rb_stat(fname, &st) < 0)
d831 1
a831 1
    return rb_time_new(st.st_atime, 0);
d835 1
a835 1
rb_file_atime(obj)
d845 1
a845 1
    return rb_time_new(st.st_atime, 0);
d849 1
a849 1
rb_file_s_mtime(obj, fname)
d854 2
a855 1
    if (rb_stat(fname, &st) < 0)
d857 1
a857 1
    return rb_time_new(st.st_mtime, 0);
d861 1
a861 1
rb_file_mtime(obj)
d871 1
a871 1
    return rb_time_new(st.st_mtime, 0);
d875 1
a875 1
rb_file_s_ctime(obj, fname)
d880 2
a881 1
    if (rb_stat(fname, &st) < 0)
d883 1
a883 1
    return rb_time_new(st.st_ctime, 0);
d887 1
a887 1
rb_file_ctime(obj)
d897 1
a897 1
    return rb_time_new(st.st_ctime, 0);
d910 1
a910 1
rb_file_s_chmod(argc, argv)
d926 1
a926 1
rb_file_chmod(obj, vmode)
d932 1
a932 1
    rb_secure(4);
d936 1
a936 1
#if defined(DJGPP) || defined(NT) || defined(USE_CWGUSI) || defined(__BEOS__)
d961 1
a961 1
rb_file_s_chown(argc, argv)
d988 1
a988 1
rb_file_chown(obj, owner, group)
d993 1
a993 1
    rb_secure(4);
d995 1
a995 1
#if defined(DJGPP) || defined(__CYGWIN32__) || defined(NT) || defined(USE_CWGUSI)
d1006 1
a1006 1
struct timeval rb_time_timeval();
d1020 1
a1020 1
rb_file_s_utime(argc, argv)
d1030 2
a1031 2
    tvp[0] = rb_time_timeval(atime);
    tvp[1] = rb_time_timeval(mtime);
a1040 3
#   if defined(__BORLANDC__)
#     include <utime.h>
#   else
a1041 2
#   endif
#   if defined(_MSC_VER)
a1042 1
#   endif
d1061 1
a1061 1
rb_file_s_utime(argc, argv)
d1072 1
a1072 1
    tv = rb_time_timeval(atime);
d1074 1
a1074 1
    tv = rb_time_timeval(mtime);
d1084 1
a1084 1
rb_file_s_link(obj, from, to)
a1086 3
#if defined(USE_CWGUSI)
        rb_notimplement();
#else
a1092 1
#endif /* USE_CWGUSI */
d1096 1
a1096 1
rb_file_s_symlink(obj, from, to)
d1105 1
a1105 1
    return INT2FIX(0);
d1107 1
a1107 2
    rb_notimplement();
    return Qnil;		/* not reached */
d1112 1
a1112 1
rb_file_s_readlink(obj, path)
d1124 1
a1124 1
    return rb_tainted_str_new(buf, cc);
a1126 1
    return Qnil;		/* not reached */
d1139 1
a1139 1
rb_file_s_unlink(obj, args)
d1149 1
a1149 1
rb_file_s_rename(obj, from, to)
d1162 1
a1162 1
rb_file_s_umask(argc, argv)
a1165 3
#ifdef USE_CWGUSI
    rb_notimplement();
#else
a1167 1
    rb_secure(4);
d1169 1
a1169 1
	omask = umask(0);
d1176 1
a1176 1
	rb_raise(rb_eArgError, "wrong # of argument");
a1178 1
#endif /* USE_CWGUSI */
d1182 2
a1183 3
rb_file_s_expand_path(argc, argv)
    int argc;
    VALUE *argv;
a1184 1
    VALUE fname, dname;
d1186 1
a1186 1
    char buf[MAXPATHLEN+2];
d1188 2
a1189 1
    rb_scan_args(argc, argv, "11", &fname, &dname);
a1190 1
    s = STR2CSTR(fname);
d1193 1
a1193 5
	if (s[1] == '/' || 
#if defined(MSDOS) || defined(NT) || defined(__human68k__)
	    s[1] == '\\' || 
#endif
	    s[1] == '\0') {
d1197 1
a1197 1
		rb_raise(rb_eArgError, "couldn't find HOME environment -- expanding `%s'", s);
d1208 1
d1217 1
a1217 1
		rb_raise(rb_eArgError, "user %s doesn't exist", buf);
a1225 5
	if (argc == 2) {
	    dname = rb_file_s_expand_path(1, &dname);
	    strcpy(buf, RSTRING(dname)->ptr);
	}
	else {
d1227 1
a1227 1
	    getcwd(buf, MAXPATHLEN);
d1229 1
a1229 1
	    getwd(buf);
a1230 1
	}
a1231 1
	while (p > buf && *(p - 1) == '/') p--;
d1270 1
a1270 1
    return rb_tainted_str_new2(buf);
d1297 1
a1297 1
rb_file_s_basename(argc, argv)
d1301 2
a1302 2
    VALUE fname, fext;
    char *name, *p, *ext;
d1305 4
a1308 5
    if (rb_scan_args(argc, argv, "11", &fname, &fext) == 2) {
	ext = STR2CSTR(fext);
    }
    name = STR2CSTR(fname);
    p = strrchr(name, '/');
d1310 3
a1312 3
	if (!NIL_P(fext)) {
	    f = rmext(name, ext);
	    if (f) return rb_str_new(name, f);
d1314 1
a1314 1
	return fname;
d1317 3
a1319 3
    if (!NIL_P(fext)) {
	f = rmext(p, ext);
	if (f) return rb_str_new(p, f);
d1321 1
a1321 1
    return rb_tainted_str_new2(p);
d1325 1
a1325 1
rb_file_s_dirname(obj, fname)
d1328 1
a1328 1
    char *name, *p;
d1330 2
a1331 2
    name = STR2CSTR(fname);
    p = strrchr(name, '/');
d1333 1
a1333 1
	return rb_str_new2(".");
d1335 1
a1335 1
    if (p == name)
d1337 1
a1337 1
    return rb_tainted_str_new(name, p - name);
d1341 1
a1341 1
rb_file_s_split(obj, path)
d1344 1
a1344 1
    return rb_assoc_new(rb_file_s_dirname(Qnil, path), rb_file_s_basename(1,&path));
d1350 1
a1350 1
rb_file_s_join(obj, args)
d1353 1
a1353 1
    return rb_ary_join(args, separator);
d1357 1
a1357 1
rb_file_s_truncate(obj, path, len)
d1389 1
a1389 1
    return INT2FIX(0);
d1393 1
a1393 1
rb_file_truncate(obj, len)
a1397 1
    rb_secure(4);
d1399 2
d1402 1
a1402 1
	rb_raise(rb_eIOError, "not opened for writing");
d1415 1
a1415 36
    return INT2FIX(0);
}

# ifndef LOCK_SH
#  define LOCK_SH 1
# endif
# ifndef LOCK_EX
#  define LOCK_EX 2
# endif
# ifndef LOCK_NB
#  define LOCK_NB 4
# endif
# ifndef LOCK_UN
#  define LOCK_UN 8
# endif

#if defined(USE_THREAD) && defined(EWOULDBLOCK)
static int
rb_thread_flock(fd, op)
    int fd, op;
{
    if (rb_thread_alone() || (op & LOCK_NB)) {
	return flock(fd, op);
    }
    op |= LOCK_NB;
    while (flock(fd, op) < 0) {
	switch (errno) {
	  case EINTR:		/* can be happen? */
	  case EWOULDBLOCK:
	    rb_thread_schedule();	/* busy wait */
	    break;
	  default:
	    return -1;
	}
    }
    return 0;
a1416 2
#define flock rb_thread_flock
#endif
d1419 1
a1419 1
rb_file_flock(obj, operation)
a1422 3
#ifdef USE_CWGUSI
    rb_notimplement();
#else
a1424 1
    rb_secure(4);
d1427 1
d1431 1
a1431 1
	    return Qfalse;
d1436 1
a1436 2
    return INT2FIX(0);
#endif /* USE_CWGUSI */
a1437 1
#undef flock
d1447 1
a1447 1
    if (n < argc) rb_raise(rb_eArgError, "Wrong # of arguments(%d for %d)", argc, n);
d1449 1
a1449 10
	switch (TYPE(argv[i])) {
	  case T_STRING:
	    Check_SafeStr(argv[i]);
	    break;
	  case T_FILE:
	    break;
	  default:
	    Check_Type(argv[i], T_STRING);
	    break;
	}
d1456 1
a1456 1
rb_f_test(argc, argv)
d1462 8
a1469 3
    if (argc == 0) rb_raise(rb_eArgError, "Wrong # of arguments");
    cmd = NUM2CHR(argv[0]);
    if (cmd == 0) return Qfalse;
d1546 1
a1546 1
	if (rb_stat(argv[1], &st) == -1) {
d1552 1
a1552 1
	    return rb_time_new(st.st_atime, 0);
d1554 1
a1554 1
	    return rb_time_new(st.st_mtime, 0);
d1556 1
a1556 1
	    return rb_time_new(st.st_ctime, 0);
d1564 2
a1565 2
	if (rb_stat(argv[1], &st1) < 0) return Qfalse;
	if (rb_stat(argv[2], &st2) < 0) return Qfalse;
d1570 1
a1570 1
		return Qtrue;
d1574 1
a1574 1
	    if (st1.st_mtime == st2.st_mtime) return Qtrue;
d1578 1
a1578 1
	    if (st1.st_mtime > st2.st_mtime) return Qtrue;
d1582 1
a1582 1
	    if (st1.st_mtime < st2.st_mtime) return Qtrue;
d1586 1
a1586 3
    /* unknown command */
    rb_raise(rb_eArgError, "unknow command ?%c", cmd);
    return Qnil;		/* not reached */
d1589 2
d1594 1
a1594 1
    VALUE rb_mConst;
d1596 105
a1700 1
    rb_mFileTest = rb_define_module("FileTest");
d1702 19
a1720 98
    rb_define_module_function(rb_mFileTest, "directory?",  test_d, 1);
    rb_define_module_function(rb_mFileTest, "exist?",  test_e, 1);
    rb_define_module_function(rb_mFileTest, "exists?",  test_e, 1); /* temporary */
    rb_define_module_function(rb_mFileTest, "readable?",  test_r, 1);
    rb_define_module_function(rb_mFileTest, "readable_real?",  test_R, 1);
    rb_define_module_function(rb_mFileTest, "writable?",  test_w, 1);
    rb_define_module_function(rb_mFileTest, "writable_real?",  test_W, 1);
    rb_define_module_function(rb_mFileTest, "executable?",  test_x, 1);
    rb_define_module_function(rb_mFileTest, "executable_real?",  test_X, 1);
    rb_define_module_function(rb_mFileTest, "file?",  test_f, 1);
    rb_define_module_function(rb_mFileTest, "zero?",  test_z, 1);
    rb_define_module_function(rb_mFileTest, "size?",  test_s, 1);
    rb_define_module_function(rb_mFileTest, "size",   test_s, 1);
    rb_define_module_function(rb_mFileTest, "owned?",  test_owned, 1);
    rb_define_module_function(rb_mFileTest, "grpowned?",  test_grpowned, 1);

    rb_define_module_function(rb_mFileTest, "pipe?",  test_p, 1);
    rb_define_module_function(rb_mFileTest, "symlink?",  test_l, 1);
    rb_define_module_function(rb_mFileTest, "socket?",  test_S, 1);

    rb_define_module_function(rb_mFileTest, "blockdev?",  test_b, 1);
    rb_define_module_function(rb_mFileTest, "chardev?",  test_c, 1);

    rb_define_module_function(rb_mFileTest, "setuid?",  test_suid, 1);
    rb_define_module_function(rb_mFileTest, "setgid?",  test_sgid, 1);
    rb_define_module_function(rb_mFileTest, "sticky?",  test_sticky, 1);

    rb_cFile = rb_define_class("File", rb_cIO);
    rb_extend_object(rb_cFile, CLASS_OF(rb_mFileTest));

    rb_define_singleton_method(rb_cFile, "new",  rb_file_s_open, -1);
    rb_define_singleton_method(rb_cFile, "open",  rb_file_s_open, -1);

    rb_define_singleton_method(rb_cFile, "stat",  rb_file_s_stat, 1);
    rb_define_singleton_method(rb_cFile, "lstat", rb_file_s_lstat, 1);
    rb_define_singleton_method(rb_cFile, "ftype", rb_file_s_ftype, 1);

    rb_define_singleton_method(rb_cFile, "atime", rb_file_s_atime, 1);
    rb_define_singleton_method(rb_cFile, "mtime", rb_file_s_mtime, 1);
    rb_define_singleton_method(rb_cFile, "ctime", rb_file_s_ctime, 1);
    rb_define_singleton_method(rb_cFile, "size",  rb_file_s_size, 1);

    rb_define_singleton_method(rb_cFile, "utime", rb_file_s_utime, -1);
    rb_define_singleton_method(rb_cFile, "chmod", rb_file_s_chmod, -1);
    rb_define_singleton_method(rb_cFile, "chown", rb_file_s_chown, -1);

    rb_define_singleton_method(rb_cFile, "link", rb_file_s_link, 2);
    rb_define_singleton_method(rb_cFile, "symlink", rb_file_s_symlink, 2);
    rb_define_singleton_method(rb_cFile, "readlink", rb_file_s_readlink, 1);

    rb_define_singleton_method(rb_cFile, "unlink", rb_file_s_unlink, -2);
    rb_define_singleton_method(rb_cFile, "delete", rb_file_s_unlink, -2);
    rb_define_singleton_method(rb_cFile, "rename", rb_file_s_rename, 2);
    rb_define_singleton_method(rb_cFile, "umask", rb_file_s_umask, -1);
    rb_define_singleton_method(rb_cFile, "truncate", rb_file_s_truncate, 2);
    rb_define_singleton_method(rb_cFile, "expand_path", rb_file_s_expand_path, -1);
    rb_define_singleton_method(rb_cFile, "basename", rb_file_s_basename, -1);
    rb_define_singleton_method(rb_cFile, "dirname", rb_file_s_dirname, 1);

    separator = rb_str_new2("/");
    rb_define_const(rb_cFile, "Separator", separator);
    rb_define_singleton_method(rb_cFile, "split",  rb_file_s_split, 1);
    rb_define_singleton_method(rb_cFile, "join",   rb_file_s_join, -2);

    rb_define_method(rb_cFile, "reopen",  rb_file_reopen, -1);

    rb_define_method(rb_cIO, "stat",  rb_io_stat, 0); /* this is IO's method */
    rb_define_method(rb_cFile, "lstat",  rb_file_lstat, 0);

    rb_define_method(rb_cFile, "atime", rb_file_atime, 0);
    rb_define_method(rb_cFile, "mtime", rb_file_mtime, 0);
    rb_define_method(rb_cFile, "ctime", rb_file_ctime, 0);

    rb_define_method(rb_cFile, "chmod", rb_file_chmod, 1);
    rb_define_method(rb_cFile, "chown", rb_file_chown, 2);
    rb_define_method(rb_cFile, "truncate", rb_file_truncate, 1);

    rb_define_method(rb_cFile, "flock", rb_file_flock, 1);

    rb_mConst = rb_define_module_under(rb_cFile, "Constants");
    rb_define_const(rb_cFile, "LOCK_SH", INT2FIX(LOCK_SH));
    rb_define_const(rb_cFile, "LOCK_EX", INT2FIX(LOCK_EX));
    rb_define_const(rb_cFile, "LOCK_UN", INT2FIX(LOCK_UN));
    rb_define_const(rb_cFile, "LOCK_NB", INT2FIX(LOCK_NB));

    rb_define_const(rb_mConst, "LOCK_SH", INT2FIX(LOCK_SH));
    rb_define_const(rb_mConst, "LOCK_EX", INT2FIX(LOCK_EX));
    rb_define_const(rb_mConst, "LOCK_UN", INT2FIX(LOCK_UN));
    rb_define_const(rb_mConst, "LOCK_NB", INT2FIX(LOCK_NB));

    rb_define_method(rb_cFile, "path",  rb_file_path, 0);

    rb_define_global_function("test", rb_f_test, -1);

    sStat = rb_struct_define("Stat", "dev", "ino", "mode",
			     "nlink", "uid", "gid", "rdev",
			     "size", "blksize", "blocks", 
			     "atime", "mtime", "ctime", 0);
@


1.1.1.3.2.1
log
@990126
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:23 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
a60 1
 char* strdup(char*);
@


1.1.1.3.2.2
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/01/26 10:08:12 $
d68 95
a1603 2
static VALUE rb_mConst;

d1605 1
a1605 3
rb_file_const(name, value)
    char *name;
    VALUE value;
d1607 1
a1607 3
    rb_define_const(rb_cFile, name, value);
    rb_define_const(rb_mConst, name, value);
}
a1608 3
void
Init_File()
{
d1641 3
d1675 2
d1691 9
a1699 4
    rb_file_const("LOCK_SH", INT2FIX(LOCK_SH));
    rb_file_const("LOCK_EX", INT2FIX(LOCK_EX));
    rb_file_const("LOCK_UN", INT2FIX(LOCK_UN));
    rb_file_const("LOCK_NB", INT2FIX(LOCK_NB));
@


1.1.1.3.2.3
log
@990212
@
text
@d6 1
a6 1
  $Date: 1999/02/09 06:08:20 $
d1305 1
a1305 1
rb_thread_flock(fd, op, fptr)
a1306 1
    OpenFile *fptr;
a1316 1
	    rb_io_check_closed(fptr);
d1324 1
a1324 1
#define flock(fd, op) rb_thread_flock(fd, op, fptr)
@


1.1.1.3.2.4
log
@990224
@
text
@d6 1
a6 1
  $Date: 1999/02/12 11:17:03 $
a30 1
#include <time.h>
a40 2

VALUE rb_time_new _((time_t, time_t));
@


1.1.1.3.2.5
log
@990225
@
text
@d6 1
a6 1
  $Date: 1999/02/24 04:31:20 $
d1366 1
a1366 1
    if (n < argc) rb_raise(rb_eArgError, "wrong # of arguments(%d for %d)", argc, n);
d1390 1
a1390 1
    if (argc == 0) rb_raise(rb_eArgError, "wrong # of arguments");
@


1.1.1.3.2.6
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/25 06:39:07 $
d54 1
a54 1
char *strrchr _((const char*,const char));
d259 1
a259 1
     const char *path;
d563 1
a563 1
    const char *file;
d748 1
a748 1
    const char *path;
d799 1
a799 1
    const char *path;
d905 1
a905 1
    const char *path;
d990 1
a990 1
    const char *path;
d1150 1
a1150 1
    const char *p, *e;
d1306 1
a1306 1
#if defined(EWOULDBLOCK)
d1518 1
a1518 1
    const char *name;
@


1.1.1.3.2.7
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:28 $
a66 4
#ifdef __EMX__
#define lstat stat
#endif
 
d193 1
a193 1
#if !defined(MSDOS) && !defined(NT) && !defined(__EMX__)
d211 1
a211 1
#if !defined(MSDOS) && !defined(NT)
d782 1
a782 1
#if defined(DJGPP) || defined(NT) || defined(USE_CWGUSI) || defined(__BEOS__) || defined(__EMX__)
d841 1
a841 1
#if defined(DJGPP) || defined(__CYGWIN32__) || defined(NT) || defined(USE_CWGUSI) || defined(__EMX__)
d955 1
a955 1
#if !defined(MSDOS) && !defined(NT) && !defined(__EMX__)
d972 1
a972 1
#if !defined(MSDOS) && !defined(NT) && !defined(__EMX__)
a1587 1
    rb_define_const(rb_cFile, "SEPARATOR", separator);
a1589 2

    rb_define_const(rb_cFile, "PATH_SEPARATOR", rb_str_new2(RUBY_PATH_SEP));
@


1.1.1.3.2.8
log
@990715
@
text
@d6 1
a6 1
  $Date: 1999/04/09 17:57:39 $
d524 2
a525 2
    if (rb_stat(fname, &st) < 0) return Qnil;
    if (st.st_size == 0) return Qnil;
d609 1
a609 1
    return Qnil;
d1514 1
a1514 1
    rb_raise(rb_eArgError, "unknown command ?%c", cmd);
@


1.1.1.3.2.9
log
@990728
@
text
@d6 1
a6 1
  $Date: 1999/07/15 07:59:45 $
a1047 10
#if defined(MSDOS) || defined(_WIN32) || defined(__human68k__)
#define DOSISH 1
#endif

#if defined DOSISH
#define ispathsep(x) ((x) == '/' || (x) == '\\')
#else
#define ispathsep(x) ((x) == '/')
#endif

d1062 5
a1066 1
	if (ispathsep(s[1]) || s[1] == '\0') {
d1081 1
a1081 1
	    while (*s && !ispathsep(*s)) {
a1096 7
#if defined DOSISH
    else if (isalpha(s[0]) && s[1] == ':' && ispathsep(s[2])) {
	while (*s && !ispathsep(*s)) {
	    *p++ = *s++;
	}
    }
#endif
d1120 1
a1120 1
		    if (*(s+1) == '\0' || ispathsep(*(s+1))) { 
d1122 2
a1123 2
			if (ispathsep(*p) && p > buf) p--;
			while (p > buf && !ispathsep(*p)) p--;
d1131 1
a1131 4
#if defined DOSISH
		  case '\\':
#endif
		    if (!ispathsep(*p)) *++p = '/'; 
d1139 1
a1139 4
#if defined DOSISH
	  case '\\':
#endif
	    if (!ispathsep(*p)) *++p = '/'; break;
d1146 1
a1146 1
    if (p == buf || !ispathsep(*p)) p++;
@


1.1.1.3.2.10
log
@990806
@
text
@d6 1
a6 1
  $Date: 1999/07/28 09:26:39 $
a162 3
#if defined DJGPP
    if (RSTRING(file)->len == 0) return -1;
#endif
d1048 4
d1053 1
a1053 1
#define isdirsep(x) ((x) == '/' || (x) == '\\')
d1055 1
a1055 1
#define isdirsep(x) ((x) == '/')
d1072 1
a1072 1
	if (isdirsep(s[1]) || s[1] == '\0') {
d1087 1
a1087 1
	    while (*s && !isdirsep(*s)) {
d1104 2
a1105 3
    /* skip drive letter */
    else if (isalpha(s[0]) && s[1] == ':' && isdirsep(s[2])) {
	while (*s && !isdirsep(*s)) {
d1133 1
a1133 1
		    if (*(s+1) == '\0' || isdirsep(*(s+1))) { 
d1135 2
a1136 2
			if (isdirsep(*p) && p > buf) p--;
			while (p > buf && !isdirsep(*p)) p--;
d1147 1
a1147 1
		    if (!isdirsep(*p)) *++p = '/'; 
d1158 1
a1158 1
	    if (!isdirsep(*p)) *++p = '/'; break;
d1165 1
a1165 1
    if (p == buf || !isdirsep(*p)) p++;
d1615 1
a1615 6
#ifdef DOSISH
    rb_define_const(rb_cFile, "ALT_SEPARATOR", rb_str_new2("\\");
#else
    rb_define_const(rb_cFile, "ALT_SEPARATOR", Qnil);
#endif
    rb_define_const(rb_cFile, "PATH_SEPARATOR", rb_str_new2(PATH_SEP));
@


1.1.1.3.2.11
log
@990806-repack
@
text
@d6 1
a6 1
  $Date: 1999/08/06 06:48:17 $
d1616 1
a1616 1
    rb_define_const(rb_cFile, "ALT_SEPARATOR", rb_str_new2("\\"));
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:04:56 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@Tue Jan 20 15:08:03 JST 1998
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:45 $
a307 22
static int
rb_stat(file, st)
    VALUE file;
    struct stat *st;
{
    OpenFile *fptr;

    switch (TYPE(file)) {
      case T_STRING:
	Check_SafeStr(file);
	return stat(RSTRING(file)->ptr, st);
	break;
      case T_FILE:
	GetOpenFile(file, fptr);
	return fstat(fileno(fptr->f), st);
	break;
      default:
	Check_Type(file, T_STRING); 
    }
    return -1;			/* not reached */
}

d348 1
a348 1
    rb_notimplement();
d366 1
a366 1
    rb_notimplement();
d449 2
a450 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d466 2
a467 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d524 2
a525 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d547 2
a548 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d565 2
a566 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d578 2
a579 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d647 2
a648 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d659 2
a660 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d671 2
a672 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d683 2
a684 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d695 2
a696 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d708 2
a709 1
    if (rb_stat(fname, &st) < 0) return FALSE;
d771 2
a772 1
    if (rb_stat(fname, &st) < 0)
d784 2
a785 1
    if (rb_stat(fname, &st) < 0)
d828 2
a829 1
    if (rb_stat(fname, &st) < 0)
d854 2
a855 1
    if (rb_stat(fname, &st) < 0)
d880 2
a881 1
    if (rb_stat(fname, &st) < 0)
d1107 1
a1107 1
    rb_notimplement();
d1449 1
a1449 10
	switch (TYPE(argv[i])) {
	  case T_STRING:
	    Check_SafeStr(argv[i]);
	    break;
	  case T_FILE:
	    break;
	  default:
	    Check_Type(argv[i], T_STRING);
	    break;
	}
d1546 1
a1546 1
	if (rb_stat(argv[1], &st) == -1) {
d1564 2
a1565 2
	if (rb_stat(argv[1], &st1) < 0) return FALSE;
	if (rb_stat(argv[2], &st2) < 0) return FALSE;
@


1.1.1.2.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/20 06:10:10 $
d139 2
a140 1
	    fclose(fptr->f2);
@


1.1.1.2.2.4
log
@1.1b7 pre
@
text
@d6 1
a6 1
  $Date: 1998/01/29 03:22:53 $
d80 1
a80 1
file_s_open(argc, argv, klass)
d83 1
a83 1
    VALUE klass;
d99 1
a99 1
    RBASIC(file)->klass = klass;
d188 1
a188 1
    io_check_closed(fptr);
d203 1
a203 1
    io_check_closed(fptr);
a218 1
    io_check_closed(fptr);
a232 1
    io_check_closed(fptr);
a245 1
    io_check_closed(fptr);
a256 1
    if (fptr->path == NULL) return Qnil;
d260 7
a381 1
    io_check_closed(fptr);
a940 1
    io_check_closed(fptr);
a999 1
    io_check_closed(fptr);
d1318 1
a1318 1
	return fname;
a1690 2
    rb_define_method(cFile, "rewind", file_rewind, 0);

d1694 3
@


1.1.1.2.2.5
log
@1.1b7 pre3
@
text
@d6 1
a6 1
  $Date: 1998/02/09 10:56:19 $
a48 1
#include <sys/types.h>
d264 1
@


1.1.1.2.2.6
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/02/10 08:44:05 $
d1190 1
a1190 1
    char buf[MAXPATHLEN+2];
@


1.1.1.2.2.7
log
@gets speed up patch
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:39 $
d189 1
d204 1
d220 1
d235 1
d249 1
d379 1
d939 1
d999 1
d1402 2
a1404 1
    GetOpenFile(obj, fptr);
a1428 1
    rb_secure(2);
d1431 1
@


1.1.1.2.2.8
log
@gw32 b19 patch
@
text
@d6 1
a6 1
  $Date: 1998/03/11 07:32:55 $
d932 1
a932 1
#if defined(DJGPP) || defined(NT)
d1165 1
a1165 1
	omask = umask(0);
@


1.1.1.2.2.9
log
@instance_eva/module_eval
@
text
@d6 1
a6 1
  $Date: 1998/03/30 09:32:47 $
d1467 6
a1472 1
    cmd = NUM2CHR(argv[0]);
d1590 1
a1590 3
    /* unknown command */
    ArgError("unknow command ?%c", cmd);
    return Qnil;		/* not reached */
@


1.1.1.2.2.10
log
@call initialize
@
text
@d6 1
a6 1
  $Date: 1998/03/30 09:41:15 $
a103 1
    obj_call_init(file);
@


1.1.1.2.2.11
log
@signal delivered to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:03:49 $
a75 1
    obj_call_init((VALUE)port);
@


1.1.1.2.2.12
log
@flock,flatten,signal to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/14 04:55:48 $
d192 1
a192 1
    if (ferror(fptr->f) != 0) rb_sys_fail(fptr->path);
d206 1
a206 1
    if (pos != 0) rb_sys_fail(fptr->path);
d209 1
a209 1
    return INT2FIX(0);
d221 1
a221 1
    if (pos != 0) rb_sys_fail(fptr->path);
d224 1
a224 1
    return INT2NUM(pos);
d234 1
a234 1
    if (fseek(fptr->f, 0L, 0) != 0) rb_sys_fail(fptr->path);
d237 1
a237 1
    return INT2FIX(0);
d1103 1
a1103 1
    return INT2FIX(0);
d1387 1
a1387 1
    return INT2FIX(0);
d1412 1
a1412 23
    return INT2FIX(0);
}

#if defined(THREAD) && defined(EWOULDBLOCK)
static int
thread_flock(fd, op)
    int fd, op;
{
    if (thread_alone() || (op & LOCK_NB)) {
	return flock(fd, op);
    }
    op |= LOCK_NB;
    while (flock(fd, op) < 0) {
	switch (errno) {
	  case EINTR:		/* can be happen? */
	  case EWOULDBLOCK:
	    thread_schedule();	/* busy wait */
	    break;
	  default:
	    return -1;
	}
    }
    return 0;
a1413 2
#define flock thread_flock
#endif
d1433 1
a1433 1
    return INT2FIX(0);
a1434 1
#undef flock
@


1.1.1.2.2.13
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/04/16 07:42:43 $
a1414 13
# ifndef LOCK_SH
#  define LOCK_SH 1
# endif
# ifndef LOCK_EX
#  define LOCK_EX 2
# endif
# ifndef LOCK_NB
#  define LOCK_NB 4
# endif
# ifndef LOCK_UN
#  define LOCK_UN 8
# endif

d1715 13
@


1.1.1.2.2.14
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/04/17 09:29:33 $
d1191 1
a1191 5
	if (s[1] == '/' || 
#if defined(MSDOS) || defined(NT) || defined(__human68k__)
	    s[1] == '\\' || 
#endif
	    s[1] == '\0') {
@


1.1.1.2.2.15
log
@tcltklib/gtk
@
text
@d6 1
a6 1
  $Date: 1998/04/20 05:55:36 $
d93 2
a94 1
	mode = STR2CSTR(vmode);
d128 2
a129 1
	mode = STR2CSTR(nmode);
d308 6
a313 1
    if (TYPE(file) == T_FILE) {
d316 3
d320 1
a320 2
    Check_SafeStr(file);
    return stat(RSTRING(file)->ptr, st);
d760 1
d762 1
a762 1
    return check3rdbyte(STR2CSTR(fname), S_ISVTX);
d1186 3
a1188 1
    s = STR2CSTR(fname);
d1303 2
a1304 2
    VALUE fname, fext;
    char *name, *p, *ext;
d1307 4
a1310 4
    rb_scan_args(argc, argv, "11", &fname, &fext);
    name = STR2CSTR(fname);
    if (!NIL_P(fext)) ext = STR2CSTR(fext);
    p = strrchr(name, '/');
d1312 3
a1314 3
	if (!NIL_P(fext)) {
	    f = rmext(name, ext);
	    if (f) return str_new(name, f);
d1319 2
a1320 2
    if (!NIL_P(fext)) {
	f = rmext(p, ext);
d1330 1
a1330 1
    UCHAR *name, *p;
d1332 2
a1333 2
    name = STR2CSTR(fname);
    p = strrchr(name, '/');
d1337 1
a1337 1
    if (p == name)
d1339 1
a1339 1
    return str_taint(str_new(name, p - name));
@


1.1.1.2.2.16
log
@1.1b9_18
@
text
@d6 1
a6 1
  $Date: 1998/04/27 10:03:53 $
d182 68
d328 1
a328 1
io_stat(obj)
d1697 1
a1697 1
    rb_define_method(cIO, "stat",  io_stat, 0); /* this is IO's method */
d1707 11
@


1.1.1.2.2.17
log
@no INT,UINT
@
text
@d6 1
a6 1
  $Date: 1998/05/12 08:38:39 $
d1250 1
a1250 1
    char *name, *p;
@


1.1.1.2.2.18
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/05/13 05:57:56 $
a56 6
#ifdef USE_CWGUSI
 #include "macruby_missing.h"
 extern int fileno(FILE *stream);
 extern int utimes();
#endif

d193 1
a193 3
# ifndef USE_CWGUSI
#  include <sys/file.h>
# endif
d312 1
a312 1
#if !defined(NT) && !defined(USE_CWGUSI)
d856 1
a856 1
#if defined(DJGPP) || defined(NT) || defined(USE_CWGUSI) || defined(__BEOS__)
d915 1
a915 1
#if defined(DJGPP) || defined(__CYGWIN32__) || defined(NT) || defined(USE_CWGUSI)
a1006 3
#if defined(USE_CWGUSI)
        rb_notimplement();
#else
a1012 1
#endif /* USE_CWGUSI */
a1085 3
#ifdef USE_CWGUSI
    rb_notimplement();
#else
a1098 1
#endif /* USE_CWGUSI */
a1380 3
#ifdef USE_CWGUSI
    rb_notimplement();
#else
a1394 1
#endif /* USE_CWGUSI */
@


1.1.1.2.2.19
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:13 $
d46 1
a46 1
char *strrchr _((char*,char));
d52 5
d67 2
@


1.1.1.2.2.20
log
@1.1b9_21
@
text
@d6 1
a6 1
  $Date: 1998/05/18 04:56:02 $
d1111 2
a1112 3
file_s_expand_path(argc, argv)
    int argc;
    VALUE *argv;
a1113 1
    VALUE fname, dname;
a1116 2
    rb_scan_args(argc, argv, "11", &fname, &dname);

d1139 1
a1156 4
	if (argc == 2) {
	    strcpy(buf, STR2CSTR(dname));
	}
	else {
d1158 1
a1158 1
	    getcwd(buf, MAXPATHLEN);
d1160 1
a1160 1
	    getwd(buf);
a1161 1
	}
a1162 1
	while (p > buf && *(p - 1) == '/') p--;
d1631 1
a1631 1
    rb_define_singleton_method(cFile, "expand_path", file_s_expand_path, -1);
@


1.1.1.2.2.21
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/18 05:57:41 $
d1161 1
a1161 2
	    dname = file_s_expand_path(1, &dname);
	    strcpy(buf, RSTRING(dname)->ptr);
@


1.1.1.2.2.22
log
@1.1b9_23
@
text
@d6 1
a6 1
  $Date: 1998/05/25 09:42:24 $
a99 1
    obj_call_init(file);
d101 1
a101 1
	return rb_ensure(rb_yield, file, io_close, file);
d103 1
@


1.1.1.2.2.23
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/26 08:24:42 $
d58 1
d1576 2
@


1.1.1.2.2.24
log
@baseline
@
text
@d6 1
a6 1
  $Date: 1998/06/02 10:05:21 $
d14 1
a14 1
#include "rubyio.h"
@


1.1.1.2.2.25
log
@1.1b9_26
@
text
@d6 1
a6 1
  $Date: 1998/06/16 04:23:29 $
a707 1
#if defined(MSDOS) || defined(NT)
a708 4
	rb_sys_fail(RSTRIN(fname)->ptr);
#else
    Check_SafeStr(fname);
    if (lstat(RSTRING(fname)->ptr, &st) == -1) {
a709 2
    }
#endif
@


1.1.1.2.2.26
log
@1.1b9_27
@
text
@d6 1
a6 1
  $Date: 1998/06/18 07:46:47 $
d710 1
a710 1
	rb_sys_fail(RSTRING(fname)->ptr);
@


1.1.1.2.2.27
log
@thread->thred
@
text
@d6 1
a6 1
  $Date: 1998/06/19 09:32:04 $
d1379 1
a1379 1
thred_flock(fd, op)
d1382 1
a1382 1
    if (thred_alone() || (op & LOCK_NB)) {
d1390 1
a1390 1
	    thred_schedule();	/* busy wait */
d1398 1
a1398 1
#define flock thred_flock
@


1.1.1.2.2.28
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/24 04:37:56 $
a14 1
#include "rubysig.h"
d1379 1
a1379 1
thread_flock(fd, op)
d1382 1
a1382 1
    if (thread_alone() || (op & LOCK_NB)) {
d1390 1
a1390 1
	    thread_schedule();	/* busy wait */
d1398 1
a1398 1
#define flock thread_flock
@


1.1.1.2.2.29
log
@str2cstr
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:18 $
d1253 1
a1253 3
    if (rb_scan_args(argc, argv, "11", &fname, &fext) == 2) {
	ext = STR2CSTR(fext);
    }
d1255 1
@


1.1.1.2.2.30
log
@1.1c4
@
text
@d6 1
a6 1
  $Date: 1998/07/13 04:37:36 $
a968 3
#   if defined(__BORLANDC__)
#     include <utime.h>
#   else
a969 2
#   endif
#   if defined(_MSC_VER)
a970 1
#   endif
@


1.1.1.2.2.30.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/09/03 07:43:31 $
d59 2
a60 2
VALUE rb_cFile;
VALUE rb_mFileTest;
d64 1
a64 1
rb_file_open(fname, mode)
d69 1
a69 1
    OBJSETUP(port, rb_cFile, T_FILE);
d72 1
a72 1
    fptr->mode = rb_io_mode_flags(mode);
d75 1
a75 1
    rb_obj_call_init((VALUE)port);
d81 1
a81 1
rb_file_s_open(argc, argv, klass)
d97 1
a97 1
    file = rb_file_open(RSTRING(fname)->ptr, mode);
d100 3
a102 3
    rb_obj_call_init(file);
    if (rb_iterator_p()) {
	return rb_ensure(rb_yield, file, rb_io_close, file);
d109 1
a109 1
rb_file_reopen(argc, argv, file)
d120 1
a120 1
	    return rb_io_reopen(file, fname);
d135 1
a135 1
    fptr->mode = rb_io_mode_flags(mode);
d181 1
a181 1
rb_file_path(obj)
d188 1
a188 1
    return rb_str_new2(fptr->path);
d203 8
a210 8
    if (!st) rb_bug("stat_new() called with bad value");
    return rb_struct_new(sStat,
			 INT2FIX((int)st->st_dev),
			 INT2FIX((int)st->st_ino),
			 INT2FIX((int)st->st_mode),
			 INT2FIX((int)st->st_nlink),
			 INT2FIX((int)st->st_uid),
			 INT2FIX((int)st->st_gid),
d212 1
a212 1
			 INT2FIX((int)st->st_rdev),
d214 1
a214 1
			 INT2FIX(0),
d216 1
a216 1
			 INT2FIX((int)st->st_size),
d218 1
a218 1
			 INT2FIX((int)st->st_blksize),
d220 1
a220 1
			 INT2FIX(0),
d223 1
a223 1
			 INT2FIX((int)st->st_blocks),
d225 1
a225 1
			 INT2FIX(0),
d227 3
a229 3
			 rb_time_new(st->st_atime, 0),
			 rb_time_new(st->st_mtime, 0),
			 rb_time_new(st->st_ctime, 0));
d248 1
a248 1
rb_file_s_stat(obj, fname)
d261 1
a261 1
rb_io_stat(obj)
d275 1
a275 1
rb_file_s_lstat(obj, fname)
d292 1
a292 1
rb_file_lstat(obj)
d315 1
a315 1
	return Qtrue;
d328 1
a328 1
		return Qtrue;
d332 1
a332 1
    return Qfalse;
d388 3
a390 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISDIR(st.st_mode)) return Qtrue;
    return Qfalse;
d404 2
a405 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISFIFO(st.st_mode)) return Qtrue;
d408 1
a408 1
    return Qfalse;
d433 2
a434 2
    if (lstat(RSTRING(fname)->ptr, &st) < 0) return Qfalse;
    if (S_ISLNK(st.st_mode)) return Qtrue;
d437 1
a437 1
    return Qfalse;
d461 2
a462 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISSOCK(st.st_mode)) return Qtrue;
d465 1
a465 1
    return Qfalse;
d483 2
a484 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISBLK(st.st_mode)) return Qtrue;
d487 1
a487 1
    return Qfalse;
d500 2
a501 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISBLK(st.st_mode)) return Qtrue;
d503 1
a503 1
    return Qfalse;
d512 2
a513 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    return Qtrue;
d521 2
a522 2
    if (eaccess(RSTRING(fname)->ptr, R_OK) < 0) return Qfalse;
    return Qtrue;
d530 2
a531 2
    if (access(RSTRING(fname)->ptr, R_OK) < 0) return Qfalse;
    return Qtrue;
d539 2
a540 2
    if (eaccess(RSTRING(fname)->ptr, W_OK) < 0) return Qfalse;
    return Qtrue;
d548 2
a549 2
    if (access(RSTRING(fname)->ptr, W_OK) < 0) return Qfalse;
    return Qtrue;
d557 2
a558 2
    if (eaccess(RSTRING(fname)->ptr, X_OK) < 0) return Qfalse;
    return Qtrue;
d566 2
a567 2
    if (access(RSTRING(fname)->ptr, X_OK) < 0) return Qfalse;
    return Qtrue;
d580 3
a582 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (S_ISREG(st.st_mode)) return Qtrue;
    return Qfalse;
d591 3
a593 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_size == 0) return Qtrue;
    return Qfalse;
d602 3
a604 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_size == 0) return Qfalse;
    return rb_int2inum(st.st_size);
d613 3
a615 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_uid == geteuid()) return Qtrue;
    return Qfalse;
d624 3
a626 3
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_uid == getuid()) return Qtrue;
    return Qfalse;
d636 2
a637 2
    if (rb_stat(fname, &st) < 0) return Qfalse;
    if (st.st_gid == getegid()) return Qtrue;
d639 1
a639 1
    return Qfalse;
d650 3
a652 3
    if (stat(file, &st) < 0) return Qfalse;
    if (st.st_mode & mode) return Qtrue;
    return Qfalse;
d664 1
a664 1
    return Qfalse;
d676 1
a676 1
    return Qfalse;
d687 1
a687 1
    return Qfalse;
d692 1
a692 1
rb_file_s_size(obj, fname)
d699 1
a699 1
    return rb_int2inum(st.st_size);
d703 1
a703 1
rb_file_s_ftype(obj, fname)
d750 1
a750 1
    return rb_str_new2(t);
d754 1
a754 1
rb_file_s_atime(obj, fname)
d761 1
a761 1
    return rb_time_new(st.st_atime, 0);
d765 1
a765 1
rb_file_atime(obj)
d775 1
a775 1
    return rb_time_new(st.st_atime, 0);
d779 1
a779 1
rb_file_s_mtime(obj, fname)
d786 1
a786 1
    return rb_time_new(st.st_mtime, 0);
d790 1
a790 1
rb_file_mtime(obj)
d800 1
a800 1
    return rb_time_new(st.st_mtime, 0);
d804 1
a804 1
rb_file_s_ctime(obj, fname)
d811 1
a811 1
    return rb_time_new(st.st_ctime, 0);
d815 1
a815 1
rb_file_ctime(obj)
d825 1
a825 1
    return rb_time_new(st.st_ctime, 0);
d838 1
a838 1
rb_file_s_chmod(argc, argv)
d854 1
a854 1
rb_file_chmod(obj, vmode)
d889 1
a889 1
rb_file_s_chown(argc, argv)
d916 1
a916 1
rb_file_chown(obj, owner, group)
d934 1
a934 1
struct timeval rb_time_timeval();
d948 1
a948 1
rb_file_s_utime(argc, argv)
d958 2
a959 2
    tvp[0] = rb_time_timeval(atime);
    tvp[1] = rb_time_timeval(mtime);
d995 1
a995 1
rb_file_s_utime(argc, argv)
d1006 1
a1006 1
    tv = rb_time_timeval(atime);
d1008 1
a1008 1
    tv = rb_time_timeval(mtime);
d1018 1
a1018 1
rb_file_s_link(obj, from, to)
d1034 1
a1034 1
rb_file_s_symlink(obj, from, to)
d1050 1
a1050 1
rb_file_s_readlink(obj, path)
d1062 1
a1062 1
    return rb_str_new(buf, cc);
d1077 1
a1077 1
rb_file_s_unlink(obj, args)
d1087 1
a1087 1
rb_file_s_rename(obj, from, to)
d1100 1
a1100 1
rb_file_s_umask(argc, argv)
d1117 1
a1117 1
	rb_raise(rb_eArgError, "wrong # of argument");
d1124 1
a1124 1
rb_file_s_expand_path(argc, argv)
d1145 1
a1145 1
		rb_raise(rb_eArgError, "couldn't find HOME environment -- expanding `%s'", s);
d1164 1
a1164 1
		rb_raise(rb_eArgError, "user %s doesn't exist", buf);
d1174 1
a1174 1
	    dname = rb_file_s_expand_path(1, &dname);
d1224 1
a1224 1
    return rb_str_taint(rb_str_new2(buf));
d1251 1
a1251 1
rb_file_s_basename(argc, argv)
d1267 1
a1267 1
	    if (f) return rb_str_new(name, f);
d1274 1
a1274 1
	if (f) return rb_str_new(p, f);
d1276 1
a1276 1
    return rb_str_taint(rb_str_new2(p));
d1280 1
a1280 1
rb_file_s_dirname(obj, fname)
d1288 1
a1288 1
	return rb_str_new2(".");
d1292 1
a1292 1
    return rb_str_taint(rb_str_new(name, p - name));
d1296 1
a1296 1
rb_file_s_split(obj, path)
d1299 1
a1299 1
    return rb_assoc_new(rb_file_s_dirname(Qnil, path), rb_file_s_basename(1,&path));
d1305 1
a1305 1
rb_file_s_join(obj, args)
d1308 1
a1308 1
    return rb_ary_join(args, separator);
d1312 1
a1312 1
rb_file_s_truncate(obj, path, len)
d1348 1
a1348 1
rb_file_truncate(obj, len)
d1356 1
a1356 1
	rb_raise(rb_eIOError, "not opened for writing");
d1387 1
a1387 1
rb_thread_flock(fd, op)
d1390 1
a1390 1
    if (rb_thread_alone() || (op & LOCK_NB)) {
d1398 1
a1398 1
	    rb_thread_schedule();	/* busy wait */
d1406 1
a1406 1
#define flock rb_thread_flock
d1410 1
a1410 1
rb_file_flock(obj, operation)
d1425 1
a1425 1
	    return Qfalse;
d1443 1
a1443 1
    if (n < argc) rb_raise(rb_eArgError, "Wrong # of arguments(%d for %d)", argc, n);
d1461 1
a1461 1
rb_f_test(argc, argv)
d1467 1
a1467 1
    if (argc == 0) rb_raise(rb_eArgError, "Wrong # of arguments");
d1469 1
a1469 1
    if (cmd == 0) return Qfalse;
d1552 1
a1552 1
	    return rb_time_new(st.st_atime, 0);
d1554 1
a1554 1
	    return rb_time_new(st.st_mtime, 0);
d1556 1
a1556 1
	    return rb_time_new(st.st_ctime, 0);
d1564 2
a1565 2
	if (rb_stat(argv[1], &st1) < 0) return Qfalse;
	if (rb_stat(argv[2], &st2) < 0) return Qfalse;
d1570 1
a1570 1
		return Qtrue;
d1574 1
a1574 1
	    if (st1.st_mtime == st2.st_mtime) return Qtrue;
d1578 1
a1578 1
	    if (st1.st_mtime > st2.st_mtime) return Qtrue;
d1582 1
a1582 1
	    if (st1.st_mtime < st2.st_mtime) return Qtrue;
d1587 1
a1587 1
    rb_raise(rb_eArgError, "unknow command ?%c", cmd);
d1594 1
a1594 1
    VALUE rb_mConst;
d1596 1
a1596 1
    rb_mFileTest = rb_define_module("FileTest");
d1598 98
a1695 98
    rb_define_module_function(rb_mFileTest, "directory?",  test_d, 1);
    rb_define_module_function(rb_mFileTest, "exist?",  test_e, 1);
    rb_define_module_function(rb_mFileTest, "exists?",  test_e, 1); /* temporary */
    rb_define_module_function(rb_mFileTest, "readable?",  test_r, 1);
    rb_define_module_function(rb_mFileTest, "readable_real?",  test_R, 1);
    rb_define_module_function(rb_mFileTest, "writable?",  test_w, 1);
    rb_define_module_function(rb_mFileTest, "writable_real?",  test_W, 1);
    rb_define_module_function(rb_mFileTest, "executable?",  test_x, 1);
    rb_define_module_function(rb_mFileTest, "executable_real?",  test_X, 1);
    rb_define_module_function(rb_mFileTest, "file?",  test_f, 1);
    rb_define_module_function(rb_mFileTest, "zero?",  test_z, 1);
    rb_define_module_function(rb_mFileTest, "size?",  test_s, 1);
    rb_define_module_function(rb_mFileTest, "size",   test_s, 1);
    rb_define_module_function(rb_mFileTest, "owned?",  test_owned, 1);
    rb_define_module_function(rb_mFileTest, "grpowned?",  test_grpowned, 1);

    rb_define_module_function(rb_mFileTest, "pipe?",  test_p, 1);
    rb_define_module_function(rb_mFileTest, "symlink?",  test_l, 1);
    rb_define_module_function(rb_mFileTest, "socket?",  test_S, 1);

    rb_define_module_function(rb_mFileTest, "blockdev?",  test_b, 1);
    rb_define_module_function(rb_mFileTest, "chardev?",  test_c, 1);

    rb_define_module_function(rb_mFileTest, "setuid?",  test_suid, 1);
    rb_define_module_function(rb_mFileTest, "setgid?",  test_sgid, 1);
    rb_define_module_function(rb_mFileTest, "sticky?",  test_sticky, 1);

    rb_cFile = rb_define_class("File", rb_cIO);
    rb_extend_object(rb_cFile, CLASS_OF(rb_mFileTest));

    rb_define_singleton_method(rb_cFile, "new",  rb_file_s_open, -1);
    rb_define_singleton_method(rb_cFile, "open",  rb_file_s_open, -1);

    rb_define_singleton_method(rb_cFile, "stat",  rb_file_s_stat, 1);
    rb_define_singleton_method(rb_cFile, "lstat", rb_file_s_lstat, 1);
    rb_define_singleton_method(rb_cFile, "ftype", rb_file_s_ftype, 1);

    rb_define_singleton_method(rb_cFile, "atime", rb_file_s_atime, 1);
    rb_define_singleton_method(rb_cFile, "mtime", rb_file_s_mtime, 1);
    rb_define_singleton_method(rb_cFile, "ctime", rb_file_s_ctime, 1);
    rb_define_singleton_method(rb_cFile, "size",  rb_file_s_size, 1);

    rb_define_singleton_method(rb_cFile, "utime", rb_file_s_utime, -1);
    rb_define_singleton_method(rb_cFile, "chmod", rb_file_s_chmod, -1);
    rb_define_singleton_method(rb_cFile, "chown", rb_file_s_chown, -1);

    rb_define_singleton_method(rb_cFile, "link", rb_file_s_link, 2);
    rb_define_singleton_method(rb_cFile, "symlink", rb_file_s_symlink, 2);
    rb_define_singleton_method(rb_cFile, "readlink", rb_file_s_readlink, 1);

    rb_define_singleton_method(rb_cFile, "unlink", rb_file_s_unlink, -2);
    rb_define_singleton_method(rb_cFile, "delete", rb_file_s_unlink, -2);
    rb_define_singleton_method(rb_cFile, "rename", rb_file_s_rename, 2);
    rb_define_singleton_method(rb_cFile, "umask", rb_file_s_umask, -1);
    rb_define_singleton_method(rb_cFile, "truncate", rb_file_s_truncate, 2);
    rb_define_singleton_method(rb_cFile, "expand_path", rb_file_s_expand_path, -1);
    rb_define_singleton_method(rb_cFile, "basename", rb_file_s_basename, -1);
    rb_define_singleton_method(rb_cFile, "dirname", rb_file_s_dirname, 1);

    separator = rb_str_new2("/");
    rb_define_const(rb_cFile, "Separator", separator);
    rb_define_singleton_method(rb_cFile, "split",  rb_file_s_split, 1);
    rb_define_singleton_method(rb_cFile, "join",   rb_file_s_join, -2);

    rb_define_method(rb_cFile, "reopen",  rb_file_reopen, -1);

    rb_define_method(rb_cIO, "stat",  rb_io_stat, 0); /* this is IO's method */
    rb_define_method(rb_cFile, "lstat",  rb_file_lstat, 0);

    rb_define_method(rb_cFile, "atime", rb_file_atime, 0);
    rb_define_method(rb_cFile, "mtime", rb_file_mtime, 0);
    rb_define_method(rb_cFile, "ctime", rb_file_ctime, 0);

    rb_define_method(rb_cFile, "chmod", rb_file_chmod, 1);
    rb_define_method(rb_cFile, "chown", rb_file_chown, 2);
    rb_define_method(rb_cFile, "truncate", rb_file_truncate, 1);

    rb_define_method(rb_cFile, "flock", rb_file_flock, 1);

    rb_mConst = rb_define_module_under(rb_cFile, "Constants");
    rb_define_const(rb_cFile, "LOCK_SH", INT2FIX(LOCK_SH));
    rb_define_const(rb_cFile, "LOCK_EX", INT2FIX(LOCK_EX));
    rb_define_const(rb_cFile, "LOCK_UN", INT2FIX(LOCK_UN));
    rb_define_const(rb_cFile, "LOCK_NB", INT2FIX(LOCK_NB));

    rb_define_const(rb_mConst, "LOCK_SH", INT2FIX(LOCK_SH));
    rb_define_const(rb_mConst, "LOCK_EX", INT2FIX(LOCK_EX));
    rb_define_const(rb_mConst, "LOCK_UN", INT2FIX(LOCK_UN));
    rb_define_const(rb_mConst, "LOCK_NB", INT2FIX(LOCK_NB));

    rb_define_method(rb_cFile, "path",  rb_file_path, 0);

    rb_define_global_function("test", rb_f_test, -1);

    sStat = rb_struct_define("Stat", "dev", "ino", "mode",
			     "nlink", "uid", "gid", "rdev",
			     "size", "blksize", "blocks", 
			     "atime", "mtime", "ctime", 0);
@


1.1.1.2.2.30.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/09/08 07:08:44 $
a117 1
    rb_secure(2);
d237 2
a239 3
	OpenFile *fptr;

	rb_secure(2);
a298 1
    rb_secure(2);
a1108 1
    rb_secure(2);
d1385 1
a1385 1
#if defined(USE_THREAD) && defined(EWOULDBLOCK)
@


1.1.1.2.2.30.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/10/06 03:28:10 $
d118 1
a118 1
    rb_secure(4);
d241 1
a241 1
	rb_secure(4);
d301 1
a301 1
    rb_secure(4);
d863 1
a863 1
    rb_secure(4);
d924 1
a924 1
    rb_secure(4);
d1065 1
a1065 1
    return rb_tainted_str_new(buf, cc);
d1112 1
a1112 1
    rb_secure(4);
d1228 1
a1228 1
    return rb_tainted_str_new2(buf);
d1280 1
a1280 1
    return rb_tainted_str_new2(p);
d1296 1
a1296 1
    return rb_tainted_str_new(name, p - name);
d1357 1
a1357 1
    rb_secure(4);
d1423 1
a1423 1
    rb_secure(4);
@
