head	1.58;
access;
symbols
	v1_6_7:1.25.2.8
	v1_6_6:1.25.2.3
	v1_6_5:1.25.2.1
	v1_6_4:1.25.2.1
	v1_7_1:1.28
	v1_6_4_preview4:1.25.2.1
	v1_6_4_preview3:1.25.2.1
	v1_6_4_preview2:1.25.2.1
	v1_6_4_preview1:1.25.2.1
	v1_6_3:1.25.2.1
	ruby_m17n:1.25.0.4
	ruby_1_6:1.25.0.2
	v1_6_2:1.25
	v1_6_1:1.19
	v1_6_0:1.16
	v1_4_6:1.5.2.5
	v1_4_5:1.5.2.4
	v1_4_4:1.5.2.3
	ruby_1_4_3:1.5.2.2
	ruby1_4_3:1.5.2.2
	v1_4_3:1.5.2.2
	v1_5_0:1.7
	ruby_1_4_3_pre1:1.5.2.1
	ruby_1_4:1.5.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.9
	v1_3_6_repack:1.1.1.1.2.8
	v1_3_6:1.1.1.1.2.8
	v1_3_5:1.1.1.1.2.8
	v1_3_4_990625:1.1.1.1.2.7
	v1_3_4_990624:1.1.1.1.2.7
	v1_3_4_990611:1.1.1.1.2.6
	v1_3_4_990531:1.1.1.1.2.5
	v1_3_3_990518:1.1.1.1.2.4
	v1_3_3_990513:1.1.1.1.2.4
	v1_3_3_990507:1.1.1.1.2.4
	v1_3_1_990225:1.1.1.1.2.2
	v1_3_1_990224:1.1.1.1.2.1
	v1_3_1_990215:1.1.1.1
	v1_3_1_990212:1.1.1.1
	v1_3_1_990210:1.1.1.1
	v1_3_1_:1.1.1.1
	v1_3_1_990209:1.1.1.1
	v1_3_1_990205:1.1.1.1
	v1_3_1_990203:1.1.1.1
	v1_3_1_990201:1.1.1.1
	v1_3_1"_990201:1.1.1.1
	v1_3_1_990128:1.1.1.1
	v1_3_1_990127:1.1.1.1
	v1_3_1_990126:1.1.1.1
	ruby_1_3:1.1.1.1.0.2
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_1d1:1.1.2.1
	v1_1d0:1.1.2.1
	v1_1dev:1.1.0.2;
locks; strict;
comment	@; @;


1.58
date	2002.07.30.11.11.53;	author nobu;	state Exp;
branches;
next	1.57;

1.57
date	2002.07.30.10.54.33;	author nobu;	state Exp;
branches;
next	1.56;

1.56
date	2002.07.30.08.23.31;	author nobu;	state Exp;
branches;
next	1.55;

1.55
date	2002.07.26.09.33.39;	author nobu;	state Exp;
branches;
next	1.54;

1.54
date	2002.07.25.00.08.56;	author nobu;	state Exp;
branches;
next	1.53;

1.53
date	2002.06.28.14.40.54;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2002.05.23.05.35.32;	author matz;	state Exp;
branches;
next	1.51;

1.51
date	2002.05.21.04.35.23;	author nobu;	state Exp;
branches;
next	1.50;

1.50
date	2002.05.14.06.22.29;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2002.04.10.05.22.46;	author nobu;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.18.05.17.53;	author nobu;	state Exp;
branches;
next	1.47;

1.47
date	2002.02.17.15.31.37;	author nobu;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.01.06.03.03;	author matz;	state Exp;
branches;
next	1.45;

1.45
date	2002.01.25.08.22.11;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2002.01.23.07.30.43;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.18.14.24.01;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2002.01.09.17.50.44;	author nobu;	state Exp;
branches;
next	1.41;

1.41
date	2002.01.05.03.22.41;	author nobu;	state Exp;
branches;
next	1.40;

1.40
date	2002.01.04.14.15.33;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.21.09.23.28;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.18.08.47.06;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.28.14.56.32;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.30.08.43.28;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.16.03.27.23;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.29.06.28.51;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.14.08.13.31;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2001.08.06.03.05.23;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.23.15.14.25;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.19.04.35.17;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.06.06.42.23;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.30.09.10.28;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.06.15.05.19;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.08.09.19.25;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.25.06.29.27;	author matz;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2000.12.05.09.36.54;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.20.07.31.55;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.11.06.29.16;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.10.07.03.34;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.02.07.48.39;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.12.05.37.38;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.07.06.59.46;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.01.07.25.25;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.04.04.17.24;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.12.07.48.31;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.24.04.34.25;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.01.09.41.42;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.06.04.15.42;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.08.08.49.01;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.18.06.09.04;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.05.04.37.23;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.12.14.06.49.58;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.11.26.09.07.26;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.10.29.09.25.32;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.10.04.04.51.08;	author matz;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.09.20.07.14.18;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.08.24.08.21.56;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.18;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.12.16.07.30.36;	author matz;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	99.01.20.04.59.36;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.02.24.04.31.29;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.02.25.06.39.12;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.03.24.08.52.35;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.04.27.05.11.13;	author matz;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.05.25.08.26.20;	author matz;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	99.06.09.09.21.36;	author matz;	state Exp;
branches;
next	1.1.1.1.2.7;

1.1.1.1.2.7
date	99.06.24.04.24.08;	author matz;	state Exp;
branches;
next	1.1.1.1.2.8;

1.1.1.1.2.8
date	99.07.14.05.40.31;	author matz;	state Exp;
branches;
next	1.1.1.1.2.9;

1.1.1.1.2.9
date	99.08.06.06.48.24;	author matz;	state Exp;
branches;
next	;

1.1.2.1
date	98.12.16.07.30.36;	author matz;	state Exp;
branches;
next	;

1.5.2.1
date	99.10.25.05.09.13;	author matz;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	99.11.29.06.31.06;	author matz;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2000.01.24.03.46.14;	author matz;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2000.06.13.09.51.02;	author matz;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2000.07.10.08.01.48;	author matz;	state Exp;
branches;
next	;

1.25.2.1
date	2001.02.08.09.18.02;	author matz;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2001.10.22.06.46.09;	author matz;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2001.12.18.08.40.33;	author matz;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2002.01.04.14.20.35;	author matz;	state Exp;
branches;
next	1.25.2.5;

1.25.2.5
date	2002.01.05.03.25.02;	author nobu;	state Exp;
branches;
next	1.25.2.6;

1.25.2.6
date	2002.01.09.17.52.12;	author nobu;	state Exp;
branches;
next	1.25.2.7;

1.25.2.7
date	2002.02.04.08.09.14;	author matz;	state Exp;
branches;
next	1.25.2.8;

1.25.2.8
date	2002.02.22.11.24.27;	author nobu;	state Exp;
branches;
next	1.25.2.9;

1.25.2.9
date	2002.04.10.05.23.59;	author nobu;	state Exp;
branches;
next	1.25.2.10;

1.25.2.10
date	2002.05.21.04.35.01;	author nobu;	state Exp;
branches;
next	;


desc
@@


1.58
log
@sorry, ditto
@
text
@;;;
;;;  ruby-mode.el -
;;;
;;;  $Author: nobu $
;;;  $Date: 2002/07/30 10:54:33 $
;;;  created at: Fri Feb  4 14:49:13 JST 1994
;;;

(defconst ruby-mode-revision "$Revision: 1.57 $")

(defconst ruby-mode-version
  (progn
   (string-match "[0-9.]+" ruby-mode-revision)
   (substring ruby-mode-revision (match-beginning 0) (match-end 0))))

(defconst ruby-block-beg-re
  "class\\|module\\|def\\|if\\|unless\\|case\\|while\\|until\\|for\\|begin\\|do"
  )

(defconst ruby-non-block-do-re
  "\\(while\\|until\\|for\\|rescue\\)\\>"
  )

(defconst ruby-indent-beg-re
  "\\(\\s *\\(class\\|module\\|def\\)\\)\\|if\\|unless\\|case\\|while\\|until\\|for\\|begin"
    )

(defconst ruby-modifier-beg-re
  "if\\|unless\\|while\\|until"
  )

(defconst ruby-modifier-re
  (concat ruby-modifier-beg-re "\\|rescue")
  )

(defconst ruby-block-mid-re
  "then\\|else\\|elsif\\|when\\|rescue\\|ensure"
  )

(defconst ruby-block-op-re
  "and\\|or\\|not"
  )

(defconst ruby-block-hanging-re
  (concat ruby-modifier-beg-re "\\|" ruby-block-op-re)
  )

(defconst ruby-block-end-re "end")

(defconst ruby-delimiter
  (concat "[?$/%(){}#\"'`.:]\\|<<\\|\\[\\|\\]\\|\\<\\("
	  ruby-block-beg-re
	  "\\|" ruby-block-end-re
	  "\\)\\>\\|^=begin")
  )

(defconst ruby-negative
  (concat "^[ \t]*\\(\\(" ruby-block-mid-re "\\)\\>\\|\\("
	    ruby-block-end-re "\\)\\>\\|}\\|\\]\\)")
  )

(defconst ruby-operator-chars "-,.+*/%&|^~=<>:")
(defconst ruby-operator-re (concat "[" ruby-operator-chars "]"))

(defconst ruby-symbol-chars "a-zA-Z0-9_")
(defconst ruby-symbol-re (concat "[" ruby-symbol-chars "]"))

(defvar ruby-mode-abbrev-table nil
  "Abbrev table in use in ruby-mode buffers.")

(define-abbrev-table 'ruby-mode-abbrev-table ())

(defvar ruby-mode-map nil "Keymap used in ruby mode.")

(if ruby-mode-map
    nil
  (setq ruby-mode-map (make-sparse-keymap))
  (define-key ruby-mode-map "{" 'ruby-electric-brace)
  (define-key ruby-mode-map "}" 'ruby-electric-brace)
  (define-key ruby-mode-map "\e\C-a" 'ruby-beginning-of-defun)
  (define-key ruby-mode-map "\e\C-e" 'ruby-end-of-defun)
  (define-key ruby-mode-map "\e\C-b" 'ruby-beginning-of-block)
  (define-key ruby-mode-map "\e\C-f" 'ruby-end-of-block)
  (define-key ruby-mode-map "\e\C-p" 'ruby-beginning-of-block)
  (define-key ruby-mode-map "\e\C-n" 'ruby-end-of-block)
  (define-key ruby-mode-map "\e\C-h" 'ruby-mark-defun)
  (define-key ruby-mode-map "\t" 'ruby-indent-command)
  (define-key ruby-mode-map "\C-c\C-e" 'ruby-insert-end)
  (define-key ruby-mode-map "\C-j" 'ruby-reindent-then-newline-and-indent)
  (define-key ruby-mode-map "\C-m" 'newline))

(defvar ruby-mode-syntax-table nil
  "Syntax table in use in ruby-mode buffers.")

(if ruby-mode-syntax-table
    ()
  (setq ruby-mode-syntax-table (make-syntax-table))
  (modify-syntax-entry ?\' "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?\" "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?\` "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?# "<" ruby-mode-syntax-table)
  (modify-syntax-entry ?\n ">" ruby-mode-syntax-table)
  (modify-syntax-entry ?\\ "\\" ruby-mode-syntax-table)
  (modify-syntax-entry ?$ "." ruby-mode-syntax-table)
  (modify-syntax-entry ?? "_" ruby-mode-syntax-table)
  (modify-syntax-entry ?_ "_" ruby-mode-syntax-table)
  (modify-syntax-entry ?< "." ruby-mode-syntax-table)
  (modify-syntax-entry ?> "." ruby-mode-syntax-table)
  (modify-syntax-entry ?& "." ruby-mode-syntax-table)
  (modify-syntax-entry ?| "." ruby-mode-syntax-table)
  (modify-syntax-entry ?% "." ruby-mode-syntax-table)
  (modify-syntax-entry ?= "." ruby-mode-syntax-table)
  (modify-syntax-entry ?/ "." ruby-mode-syntax-table)
  (modify-syntax-entry ?+ "." ruby-mode-syntax-table)
  (modify-syntax-entry ?* "." ruby-mode-syntax-table)
  (modify-syntax-entry ?- "." ruby-mode-syntax-table)
  (modify-syntax-entry ?\; "." ruby-mode-syntax-table)
  (modify-syntax-entry ?\( "()" ruby-mode-syntax-table)
  (modify-syntax-entry ?\) ")(" ruby-mode-syntax-table)
  (modify-syntax-entry ?\{ "(}" ruby-mode-syntax-table)
  (modify-syntax-entry ?\} "){" ruby-mode-syntax-table)
  (modify-syntax-entry ?\[ "(]" ruby-mode-syntax-table)
  (modify-syntax-entry ?\] ")[" ruby-mode-syntax-table)
  )

(defvar ruby-indent-level 2
  "*Indentation of ruby statements.")

(defvar ruby-deep-arglist t
  "*Deep indent argument lists when non-nil.
Also ignores spaces after parenthesis when 'space.")

(eval-when-compile (require 'cl))
(defun ruby-imenu-create-index-in-block (prefix beg end)
  (let ((index-alist '()) (nest '()) (case-fold-search nil)
	name next pos decl sing)
    (goto-char beg)
    (while (re-search-forward "^\\s *\\(\\(class\\>\\(\\s *<<\\)?\\|module\\>\\)\\s *\\([^\(<\n ]+\\)\\|\\(def\\|alias\\)\\>\\s *\\([^\(\n ]+\\)\\)" end t)
      (setq sing (match-beginning 3))
      (setq decl (match-string 5))
      (setq next (match-end 0))
      (setq name (or (match-string 4) (match-string 6)))
      (setq pos (match-beginning 0))
      (cond
       ((string= "alias" decl)
	(if prefix (setq name (concat prefix name)))
	(push (cons name pos) index-alist))
       ((string= "def" decl)
	(if prefix
	    (setq name
		  (cond
		   ((string-match "^self\." name)
		    (concat (substring prefix 0 -1) (substring name 4)))
		  (t (concat prefix name)))))
	(push (cons name pos) index-alist)
	(ruby-accurate-end-of-block end))
       (t
	(if (string= "self" name)
	    (if prefix (setq name (substring prefix 0 -1)))
	  (if prefix (setq name (concat (substring prefix 0 -1) "::" name)))
	  (push (cons name pos) index-alist))
	(ruby-accurate-end-of-block end)
	(setq beg (point))
	(setq index-alist
	      (nconc (ruby-imenu-create-index-in-block
		      (concat name (if sing "." "#"))
		      next beg) index-alist))
	(goto-char beg))))
    index-alist))

(defun ruby-imenu-create-index ()
  (nreverse (ruby-imenu-create-index-in-block nil (point-min) nil)))

(defun ruby-accurate-end-of-block (&optional end)
  (let (state)
    (or end (setq end (point-max)))
    (while (and (setq state (apply 'ruby-parse-partial end state))
		(>= (nth 2 state) 0) (< (point) end)))))

(defun ruby-mode-variables ()
  (set-syntax-table ruby-mode-syntax-table)
  (setq local-abbrev-table ruby-mode-abbrev-table)
  (make-local-variable 'indent-line-function)
  (setq indent-line-function 'ruby-indent-line)
  (make-local-variable 'require-final-newline)
  (setq require-final-newline t)
  (make-variable-buffer-local 'comment-start)
  (setq comment-start "# ")
  (make-variable-buffer-local 'comment-end)
  (setq comment-end "")
  (make-variable-buffer-local 'comment-column)
  (setq comment-column 32)
  (make-variable-buffer-local 'comment-start-skip)
  (setq comment-start-skip "\\(^\\|\\s-\\);?#+ *")
  (make-local-variable 'parse-sexp-ignore-comments)
  (setq parse-sexp-ignore-comments t)
  (make-local-variable 'paragraph-start)
  (setq paragraph-start (concat "$\\|" page-delimiter))
  (make-local-variable 'paragraph-separate)
  (setq paragraph-separate paragraph-start)
  (make-local-variable 'paragraph-ignore-fill-prefix)
  (setq paragraph-ignore-fill-prefix t))

(defun ruby-mode ()
  "Major mode for editing ruby scripts.
\\[ruby-indent-command] properly indents subexpressions of multi-line
class, module, def, if, while, for, do, and case statements, taking
nesting into account.

The variable ruby-indent-level controls the amount of indentation.
\\{ruby-mode-map}"
  (interactive)
  (kill-all-local-variables)
  (use-local-map ruby-mode-map)
  (setq mode-name "Ruby")
  (setq major-mode 'ruby-mode)
  (ruby-mode-variables)

  (make-local-variable 'imenu-create-index-function)
  (setq imenu-create-index-function 'ruby-imenu-create-index)

  (make-local-variable 'add-log-current-defun-function)
  (setq add-log-current-defun-function 'ruby-add-log-current-method)

  (run-hooks 'ruby-mode-hook))

(defun ruby-current-indentation ()
  (save-excursion
    (beginning-of-line)
    (back-to-indentation)
    (current-column)))

(defun ruby-indent-line (&optional flag)
  "Correct indentation of the current ruby line."
  (ruby-indent-to (ruby-calculate-indent)))

(defun ruby-indent-command ()
  (interactive)
  (ruby-indent-line t))

(defun ruby-indent-to (x)
  (if x
      (let (shift top beg)
	(and (< x 0) (error "invalid nest"))
	(setq shift (current-column))
	(beginning-of-line)
	(setq beg (point))
	(back-to-indentation)
	(setq top (current-column))
	(skip-chars-backward " \t")
	(if (>= shift top) (setq shift (- shift top))
	  (setq shift 0))
	(if (and (bolp)
		 (= x top))
	    (move-to-column (+ x shift))
	  (move-to-column top)
	  (delete-region beg (point))
	  (beginning-of-line)
	  (indent-to x)
	  (move-to-column (+ x shift))))))

(defun ruby-expr-beg (&optional option)
  (save-excursion
    (store-match-data nil)
    (let ((space (skip-chars-backward " \t")))
      (cond
       ((bolp) t)
       ((looking-at "\\?")
	(or (bolp) (forward-char -1))
	(not (looking-at "\\sw")))
       (t
	(forward-char -1)
	(or (looking-at ruby-operator-re)
	    (looking-at "[\\[({,;]")
	    (and (or (not (eq option 'heredoc))
		     (< space 0))
		 (looking-at "[!?]")
		 (or (not (eq option 'modifier))
		     (bolp)
		     (save-excursion (forward-char -1) (looking-at "\\Sw"))))
	    (and (looking-at ruby-symbol-re)
		 (skip-chars-backward ruby-symbol-chars)
		 (cond
		  ((or (looking-at ruby-block-beg-re)
		       (looking-at ruby-block-op-re)
		       (looking-at ruby-block-mid-re))
		   (goto-char (match-end 0))
		   (looking-at "\\>"))
		  ((eq option 'expr-qstr)
		   (looking-at "[a-zA-Z][a-zA-z0-9_]* +%[^ \t]"))
		  ((eq option 'expr-re)
		   (looking-at "[a-zA-Z][a-zA-z0-9_]* +/[^ \t]"))
		  (t nil)))))))))

(defun ruby-forward-string (term &optional end no-error expand)
  (let ((n 1) (c (string-to-char term))
	(re (if expand
		(concat "[^\\]\\(\\\\\\\\\\)*\\([" term "]\\|\\(#{\\)\\)")
	      (concat "[^\\]\\(\\\\\\\\\\)*[" term "]"))))
    (while (and (re-search-forward re end no-error)
		(if (match-beginning 3)
		    (ruby-forward-string "}{" end no-error nil)
		  (> (setq n (if (eq (char-before (point)) c)
				     (1- n) (1+ n))) 0)))
      (forward-char -1))
    (cond ((zerop n))
	  (no-error nil)
	  (error "unterminated string"))))

(defun ruby-parse-partial (&optional end in-string nest depth pcol indent)
  (or depth (setq depth 0))
  (or indent (setq indent 0))
  (when (re-search-forward ruby-delimiter end 'move)
    (let ((pnt (point)) w re expand)
      (goto-char (match-beginning 0))
      (cond
       ((or (looking-at "\"")		;skip string
	    (looking-at "`"))
	(cond
	 ((and (not (eobp))
	       (ruby-forward-string (buffer-substring (point) (1+ (point))) end t t))
	  nil)
	 (t
	  (setq in-string (point))
	  (goto-char end))))
       ((looking-at "'")
	(cond
	 ((and (not (eobp))
	       (re-search-forward "[^\\]\\(\\\\\\\\\\)*'" end t))
	  nil)
	 (t
	  (setq in-string (point))
	  (goto-char end))))
       ((looking-at "/")
	(cond
	 ((and (not (eobp)) (ruby-expr-beg 'expr-re))
	  (if (ruby-forward-string "/" end t t)
	      nil
	    (setq in-string (point))
	    (goto-char end)))
	 (t
	  (goto-char pnt))))
       ((looking-at "%")
	(cond
	 ((and (not (eobp))
	       (ruby-expr-beg 'expr-qstr)
	       (not (looking-at "%="))
	       (looking-at "%[QqrxWw]?\\(.\\)"))
	  (goto-char (match-beginning 1))
	  (setq expand (not (memq (char-before) '(?q ?w))))
	  (setq w (match-string 1))
	  (cond
	   ((string= w "[") (setq re "]["))
	   ((string= w "{") (setq re "}{"))
	   ((string= w "(") (setq re ")("))
	   ((string= w "<") (setq re "><"))
	   ((and expand (string= w "\\"))
	    (setq w (concat "\\" w))))
	  (unless (cond (re (ruby-forward-string re end t expand))
			(expand (ruby-forward-string w end t t))
			(t (re-search-forward
			    (if (string= w "\\")
				"\\\\[^\\]*\\\\"
			      (concat "[^\\]\\(\\\\\\\\\\)*" w))
			    end t)))
	    (setq in-string (point))
	    (goto-char end)))
	 (t
	  (goto-char pnt))))
       ((looking-at "\\?")		;skip ?char
	(cond
	 ((and (ruby-expr-beg)
	       (looking-at "?\\(\\\\C-\\|\\\\M-\\)*."))
	  (goto-char (match-end 0)))
	 (t
	  (goto-char pnt))))
       ((looking-at "\\$")		;skip $char
	(goto-char pnt)
	(forward-char 1))
       ((looking-at "#")		;skip comment
	(forward-line 1)
	(goto-char (point))
	)
       ((and (looking-at "(") ruby-deep-arglist)
	(and (eq ruby-deep-arglist 'space) (looking-at ".\\s +")
	     (setq pnt (match-end 0)))
	(setq nest (cons (cons (char-after (point)) pnt) nest))
	(setq pcol (cons (cons pnt depth) pcol))
	(setq depth 0)
	(goto-char pnt)
	)
       ((looking-at "[\\[{(]")
	(setq nest (cons (cons (char-after (point)) pnt) nest))
	(setq depth (1+ depth))
	(goto-char pnt)
	)
       ((and (looking-at ")") ruby-deep-arglist)
	(setq nest (cdr nest))
	(setq depth (cdr (car pcol)))
	(setq pcol (cdr pcol))
	(goto-char pnt))
       ((looking-at "[])}]")
	(setq nest (cdr nest))
	(setq depth (1- depth))
	(goto-char pnt))
       ((looking-at ruby-block-end-re)
	(if (or (and (not (bolp))
		     (progn
		       (forward-char -1)
		       (setq w (char-after (point)))
		       (or (eq ?_ w)
			   (eq ?. w))))
		(progn
		  (goto-char pnt)
		  (setq w (char-after (point)))
		  (or (eq ?_ w)
		      (eq ?! w)
		      (eq ?? w))))
	    nil
	  (setq nest (cdr nest))
	  (setq depth (1- depth)))
	(goto-char pnt))
       ((looking-at "def\\s +[^(\n;]*")
	(if (or (bolp)
		(progn
		  (forward-char -1)
		  (not (eq ?_ (char-after (point))))))
	    (progn
	      (setq nest (cons (cons nil pnt) nest))
	      (setq depth (1+ depth))))
	(goto-char (match-end 0)))
       ((looking-at ruby-block-beg-re)
	(and
	 (save-match-data
	   (or (not (looking-at "do\\>[^_]"))
	       (save-excursion
		 (back-to-indentation)
		 (not (looking-at ruby-non-block-do-re)))))
	 (or (bolp)
	     (progn
	       (forward-char -1)
	       (setq w (char-after (point)))
	       (not (or (eq ?_ w)
			(eq ?. w)))))
	 (goto-char pnt)
	 (setq w (char-after (point)))
	 (not (eq ?_ w))
	 (not (eq ?! w))
	 (not (eq ?? w))
	 (skip-chars-forward " \t")
	 (goto-char (match-beginning 0))
	 (or (not (looking-at ruby-modifier-re))
	     (ruby-expr-beg 'modifier))
	 (goto-char pnt)
	 (setq nest (cons (cons nil pnt) nest))
	 (setq depth (1+ depth)))
	(goto-char pnt))
       ((looking-at ":\\([a-zA-Z_][a-zA-Z_0-9]*\\)?")
	(goto-char (match-end 0)))
       ((or (looking-at "\\.\\.\\.?")
	    (looking-at "\\.[0-9]+")
	    (looking-at "\\.[a-zA-Z_0-9]+")
	    (looking-at "\\."))
	(goto-char (match-end 0)))
       ((looking-at "^=begin")
	(if (re-search-forward "^=end" end t)
	    (forward-line 1)
	  (setq in-string (match-end 0))
	  (goto-char end)))
       ((looking-at "<<")
	(cond
	 ((and (ruby-expr-beg 'heredoc)
	       (looking-at "<<\\(-\\)?\\(\\([\"'`]\\)\\([^\n]+?\\)\\3\\|\\sw+\\)"))
	  (setq re (regexp-quote (or (match-string 4) (match-string 2))))
	  (if (match-beginning 1) (setq re (concat "\\s *" re)))
	  (if (re-search-forward (concat "^" re "$") end 'move)
	      (forward-line 1)
	    (setq in-string (match-end 0))
	    (goto-char end)))
	 (t
	  (goto-char pnt))))
       ((looking-at "^__END__$")
	(goto-char pnt))
       (t
	(error (format "bad string %s"
		       (buffer-substring (point) pnt)
		       ))))))
  (list in-string nest depth pcol))

(defun ruby-parse-region (start end)
  (let (state)
    (save-excursion
      (if start
	  (goto-char start)
	(ruby-beginning-of-indent))
      (save-restriction
	(narrow-to-region (point) end)
	(while (and (> end (point))
		    (setq state (apply 'ruby-parse-partial end state))))))
    (list (nth 0 state)			; in-string
	  (car (nth 1 state))		; nest
	  (nth 2 state)			; depth
	  (car (car (nth 3 state)))	; pcol
	  ;(car (nth 5 state))		; indent
	  )))

(defun ruby-indent-size (pos nest)
  (+ pos (* (if nest nest 1) ruby-indent-level)))

(defun ruby-calculate-indent (&optional parse-start)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
	    (case-fold-search nil)
	    state bol eol
	    (indent 0))
	(if parse-start
	    (goto-char parse-start)
	  (ruby-beginning-of-indent)
	  (setq parse-start (point)))
	(back-to-indentation)
	(setq indent (current-column))
	(setq state (ruby-parse-region parse-start indent-point))
	(cond
	 ((nth 0 state)			; within string
	  (setq indent nil))		;  do nothing
	 ((car (nth 1 state))		; in paren
	  (goto-char (cdr (nth 1 state)))
	  (if (and (eq (car (nth 1 state)) ?\( ) ruby-deep-arglist)
	      (let ((column (current-column))
		    (s (ruby-parse-region (point) indent-point)))
		(cond
		 ((and (nth 2 s) (> (nth 2 s) 0))
		  (goto-char (cdr (nth 1 s)))
		  (forward-word -1)
		  (setq indent (ruby-indent-size (current-column) (nth 2 state))))
		 (t
		  (setq indent (current-column)))))
	    (cond
	     ((nth 3 state)
	      (goto-char (nth 3 state))
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))
	     (t
	      (goto-char parse-start)
	      (back-to-indentation)
	      (setq indent (ruby-indent-size (current-column) (nth 2 state)))))
	    ))
	 ((and (nth 2 state)(> (nth 2 state) 0)) ; in nest
	  (if (null (cdr (nth 1 state)))
	      (error "invalid nest"))
	  (goto-char (cdr (nth 1 state)))
	  (forward-word -1)		; skip back a keyword
	  (cond
	   ((looking-at "do\\>[^_]")	; iter block is a special case
	    (cond
	     ((nth 3 state)
	      (goto-char (nth 3 state))
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))
	     (t
	      (goto-char parse-start)
	      (back-to-indentation)
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))))
	   (t
	    (setq indent (+ (current-column) ruby-indent-level)))))

	 ((and (nth 2 state) (< (nth 2 state) 0)) ; in negative nest
	  (setq indent (ruby-indent-size (current-column) (nth 2 state)))))

	(cond
	 (indent
	  (goto-char indent-point)
	  (end-of-line)
	  (setq eol (point))
	  (beginning-of-line)
	  (cond
	   ((re-search-forward ruby-negative eol t)
	    (and (not (eq ?_ (char-after (match-end 0))))
		 (setq indent (- indent ruby-indent-level))))
	   ;;operator terminated lines
	   ((and
	     (save-excursion
	       (beginning-of-line)
	       (not (bobp)))
	     (or (null (car (nth 1 state))) ;not in parens
		 (and (eq (car (nth 1 state)) ?\{)
		      (save-excursion	;except non-block braces
			(goto-char (cdr (nth 1 state)))
			(or (bobp) (forward-char -1))
			(not (ruby-expr-beg))))))
	    ;; goto beginning of non-empty no-comment line
	    (let (end done)
	      (while (not done)
		(skip-chars-backward " \t\n")
		(setq end (point))
		(beginning-of-line)
		(if (re-search-forward "^\\s *#" end t)
		    (beginning-of-line)
		  (setq done t))))
	    (setq bol (point))
	    (end-of-line)
	    (skip-chars-backward " \t")
	    (let ((pos (point)))
	      (while (and (re-search-backward "#" bol t)
			  (eq (char-before) ??))
		(forward-char -1))
	      (skip-chars-backward " \t")
	      (and
	       (setq state (ruby-parse-region parse-start (point)))
	       (nth 0 state)
	       (goto-char pos)))
	    (or (bobp) (forward-char -1))
	    (and
	     (or (and (looking-at ruby-symbol-re)
		      (skip-chars-backward ruby-symbol-chars)
		      (looking-at ruby-block-hanging-re)
		      (not (eq (point) (nth 3 state)))
		      (save-excursion
			(goto-char (match-end 0))
			(not (looking-at "[a-z_]"))))
		 (and (looking-at ruby-operator-re)
		      (not (eq (char-after (1- (point))) ??))
		      (not (eq (char-after (1- (point))) ?$))
		      (or (not (eq ?/ (char-after (point))))
			  (null (nth 0 (ruby-parse-region parse-start (point)))))
		      (or (not (eq ?| (char-after (point))))
			  (save-excursion
			    (or (eolp) (forward-char -1))
			    (cond
			     ((search-backward "|" nil t)
			      (skip-chars-backward " \t\n")
			      (and (not (eolp))
				   (progn
				     (forward-char -1)
				     (not (looking-at "{")))
				   (progn
				     (forward-word -1)
				     (not (looking-at "do\\>[^_]")))))
			     (t t))))))
	     (setq indent (+ indent ruby-indent-level)))))))
	indent)))

(defun ruby-electric-brace (arg)
  (interactive "P")
  (self-insert-command (prefix-numeric-value arg))
  (ruby-indent-line t))

(defun ruby-beginning-of-defun (&optional arg)
  "Move backward to next beginning-of-defun.
With argument, do this that many times.
Returns t unless search stops due to end of buffer."
  (interactive "p")
  (and (re-search-backward (concat "^\\(" ruby-block-beg-re "\\)\\b")
			   nil 'move (or arg 1))
       (progn (beginning-of-line) t)))

(defun ruby-beginning-of-indent ()
  (and (re-search-backward (concat "^\\(" ruby-indent-beg-re "\\)\\b")
			   nil 'move)
       (progn
	 (beginning-of-line)
	 t)))

(defun ruby-end-of-defun (&optional arg)
  "Move forward to next end of defun.
An end of a defun is found by moving forward from the beginning of one."
  (interactive "p")
  (and (re-search-forward (concat "^\\(" ruby-block-end-re "\\)\\($\\|\\b[^_]\\)")
			  nil 'move (or arg 1))
       (progn (beginning-of-line) t))
  (forward-line 1))

(defun ruby-move-to-block (n)
  (let (start pos done down)
    (setq start (ruby-calculate-indent))
    (setq down (looking-at (if (< n 0) ruby-block-end-re ruby-block-beg-re)))
    (while (and (not done) (not (if (< n 0) (bobp) (eobp))))
      (forward-line n)
      (cond
       ((looking-at "^\\s *$"))
       ((looking-at "^\\s *#"))
       ((and (> n 0) (looking-at "^=begin\\>"))
	(re-search-forward "^=end\\>"))
       ((and (< n 0) (looking-at "^=end\\>"))
	(re-search-backward "^=begin\\>"))
       (t
	(setq pos (current-indentation))
	(cond
	 ((< start pos)
	  (setq down t))
	 ((and down (= pos start))
	  (setq done t))
	 ((> start pos)
	  (setq done t)))))
      (if done
	  (progn
	    (back-to-indentation)
	    (if (looking-at ruby-block-mid-re)
		(setq done nil))))))
  (back-to-indentation))

(defun ruby-beginning-of-block ()
  "Move backward to next beginning-of-block"
  (interactive)
  (ruby-move-to-block -1))

(defun ruby-end-of-block ()
  "Move forward to next beginning-of-block"
  (interactive)
  (ruby-move-to-block 1))

(defun ruby-reindent-then-newline-and-indent ()
  (interactive "*")
  (newline)
  (save-excursion
    (end-of-line 0)
    (indent-according-to-mode)
    (delete-region (point) (progn (skip-chars-backward " \t") (point))))
  (indent-according-to-mode))

(fset 'ruby-encomment-region (symbol-function 'comment-region))

(defun ruby-decomment-region (beg end)
  (interactive "r")
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "^\\([ \t]*\\)#" end t)
      (replace-match "\\1" nil nil)
      (save-excursion
	(ruby-indent-line)))))

(defun ruby-insert-end ()
  (interactive)
  (insert "end")
  (ruby-indent-line t)
  (end-of-line))

(defun ruby-mark-defun ()
  "Put mark at end of this Ruby function, point at beginning."
  (interactive)
  (push-mark (point))
  (ruby-end-of-defun)
  (push-mark (point) nil t)
  (ruby-beginning-of-defun)
  (re-search-backward "^\n" (- (point) 1) t))

(defun ruby-add-log-current-method ()
  "Return current method string."
  (condition-case nil
      (save-excursion
	(let ((mlist nil) (indent 0))
	  ;; get current method (or class/module)
	  (if (re-search-backward
	       (concat "^[ \t]*\\(def\\|class\\|module\\)[ \t]+"
		       "\\(" ruby-symbol-re "+\\)")
	       nil t)
	      (progn
		(setq mlist (list (match-string 2)))
		(goto-char (match-beginning 1))
		(setq indent (current-column))
		(beginning-of-line)))
	  ;; nest class/module
	  (while (and (> indent 0)
		      (re-search-backward
		       (concat
			"^[ \t]*\\(class\\|module\\)[ \t]+"
			"\\([A-Z]" ruby-symbol-re "+\\)")
		       nil t))
	    (goto-char (match-beginning 1))
	    (if (< (current-column) indent)
		(progn
		  (setq mlist (cons (match-string 2) mlist))
		  (setq indent (current-column))
		  (beginning-of-line))))
	  ;; generate string
	  (if (consp mlist)
	      (mapconcat (function identity) mlist "::")
	    nil)))))

(cond
 ((featurep 'font-lock)
  (or (boundp 'font-lock-variable-name-face)
      (setq font-lock-variable-name-face font-lock-type-face))

  (setq ruby-font-lock-syntactic-keywords
	'(
	  ;; #{ }, #$hoge, #@@foo are not comments
	  ("\\(#\\)[{$@@]" 1 (1 . nil))
	  ;; the last $' in the string ,'...$' is not variable
	  ;; the last ?' in the string ,'...?' is not ascii code
	  ("\\(^\\|[[\\s <+(,=]\\)\\('\\)[^'\n\\\\]*\\(\\\\.[^'\n\\\\]*\\)*[?$]\\('\\)"
	   (2 (7 . nil))
	   (4 (7 . nil)))
	  ;; the last $` in the string ,`...$` is not variable
	  ;; the last ?` in the string ,`...?` is not ascii code
	  ("\\(^\\|[[\\s <+(,=]\\)\\(`\\)[^`\n\\\\]*\\(\\\\.[^`\n\\\\]*\\)*[?$]\\(`\\)"
	   (2 (7 . nil))
	   (4 (7 . nil)))
	  ;; the last $" in the string ,"...$" is not variable
	  ;; the last ?" in the string ,"...?" is not ascii code
	  ("\\(^\\|[[\\s <+(,=]\\)\\(\"\\)[^\"\n\\\\]*\\(\\\\.[^\"\n\\\\]*\\)*[?$]\\(\"\\)"
	   (2 (7 . nil))
	   (4 (7 . nil)))
	  ;; $' $" $` .... are variables
	  ;; ?' ?" ?` are ascii codes
	  ("[?$][#\"'`]" 0 (1 . nil))
	  ;; regexps
	  ("\\(^\\|[=(,~?:;]\\|\\(^\\|\\s \\)\\(if\\|elsif\\|unless\\|while\\|until\\|when\\|and\\|or\\|&&\\|||\\)\\|g?sub!?\\|scan\\|split!?\\)\\s *\\(/\\)[^/\n\\\\]*\\(\\\\.[^/\n\\\\]*\\)*\\(/\\)"
	   (4 (7 . ?/))
	   (6 (7 . ?/)))
	  ;; %Q!...!
	  ("\\(^\\|[[\\s <+(,=]\\)%[xrqQ]?\\([^a-zA-Z0-9 \n]\\)[^\n\\\\]*\\(\\\\.[^\n\\\\]*\\)*\\(\\2\\)"
	   (2 (7 . nil))
	   (4 (7 . nil)))
	  ("^\\(=\\)begin\\(\\s \\|$\\)" 1 (7 . nil))
	  ("^\\(=\\)end\\(\\s \\|$\\)" 1 (7 . nil))))

  (cond ((featurep 'xemacs)
	 (put 'ruby-mode 'font-lock-defaults
	      '((ruby-font-lock-keywords)
		nil nil nil
		beginning-of-line
		(font-lock-syntactic-keywords
		 . ruby-font-lock-syntactic-keywords))))
	(t
	 (add-hook 'ruby-mode-hook
	    '(lambda ()
	       (make-local-variable 'font-lock-defaults)
	       (make-local-variable 'font-lock-keywords)
	       (make-local-variable 'font-lock-syntax-table)
	       (make-local-variable 'font-lock-syntactic-keywords)
	       (setq font-lock-defaults '((ruby-font-lock-keywords) nil nil))
	       (setq font-lock-keywords ruby-font-lock-keywords)
	       (setq font-lock-syntax-table ruby-font-lock-syntax-table)
	       (setq font-lock-syntactic-keywords ruby-font-lock-syntactic-keywords)))))

  (defun ruby-font-lock-docs (limit)
    (if (re-search-forward "^=begin\\(\\s \\|$\\)" limit t)
	(let (beg)
	  (beginning-of-line)
	  (setq beg (point))
	  (forward-line 1)
	  (if (re-search-forward "^=end\\(\\s \\|$\\)" limit t)
	      (progn
		(set-match-data (list beg (point)))
		t)))))

  (defun ruby-font-lock-maybe-docs (limit)
    (let (beg)
      (save-excursion
	(if (and (re-search-backward "^=\\(begin\\|end\\)\\(\\s \\|$\\)" nil t)
		 (string= (match-string 1) "begin"))
	    (progn
	      (beginning-of-line)
	      (setq beg (point)))))
      (if (and beg (and (re-search-forward "^=\\(begin\\|end\\)\\(\\s \\|$\\)" nil t)
			(string= (match-string 1) "end")))
	  (progn
	    (set-match-data (list beg (point)))
	    t)
	nil)))

  (defvar ruby-font-lock-syntax-table
    (let* ((tbl (copy-syntax-table ruby-mode-syntax-table)))
      (modify-syntax-entry ?_ "w" tbl)
      tbl))

  (defvar ruby-font-lock-keywords
    (list
     (cons (concat
	    "\\(^\\|[^_:.@@$]\\|\\.\\.\\)\\b\\("
	    (mapconcat
	     'identity
	     '("alias"
	       "and"
	       "begin"
	       "break"
	       "case"
	       "catch"
	       "class"
	       "def"
	       "do"
	       "elsif"
	       "else"
	       "fail"
	       "ensure"
	       "for"
	       "end"
	       "if"
	       "in"
	       "module"
	       "next"
	       "not"
	       "or"
	       "raise"
	       "redo"
	       "rescue"
	       "retry"
	       "return"
	       "then"
	       "throw"
	       "super"
	       "unless"
	       "undef"
	       "until"
	       "when"
	       "while"
	       "yield"
	       )
	     "\\|")
	    "\\)\\>")
	   2)
     ;; variables
     '("\\(^\\|[^_:.@@$]\\|\\.\\.\\)\\b\\(nil\\|self\\|true\\|false\\)\\>"
       2 font-lock-variable-name-face)
     ;; variables
     '("\\(\\$\\([^a-zA-Z0-9 \n]\\|[0-9]\\)\\)\\W"
       1 font-lock-variable-name-face)
     '("\\(\\$\\|@@\\|@@@@\\)\\(\\w\\|_\\)+"
       0 font-lock-variable-name-face)
     ;; embedded document
     '(ruby-font-lock-docs
       0 font-lock-comment-face t)
     '(ruby-font-lock-maybe-docs
       0 font-lock-comment-face t)
     ;; constants
     '("\\(^\\|[^_]\\)\\b\\([A-Z]+\\(\\w\\|_\\)*\\)"
       2 font-lock-type-face)
     ;; functions
     '("^\\s *def\\s +\\([^( ]+\\)"
       1 font-lock-function-name-face)
     ;; symbols
     '("\\(^\\|[^:]\\)\\(:\\([-+~]@@?\\|[/%&|^`]\\|\\*\\*?\\|<\\(<\\|=>?\\)?\\|>[>=]?\\|===?\\|=~\\|\\[\\]=?\\|\\(\\w\\|_\\)+\\([!?=]\\|\\b_*\\)\\|#{[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}\\)\\)"
       2 font-lock-reference-face)
     ;; expression expansion
     '("#\\({[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}\\|\\(\\$\\|@@\\|@@@@\\)\\(\\w\\|_\\)+\\)"
       0 font-lock-variable-name-face t))
    "*Additional expressions to highlight in ruby mode."))

 ((featurep 'hilit19)
  (hilit-set-mode-patterns
   'ruby-mode
   '(("[^$\\?]\\(\"[^\\\"]*\\(\\\\\\(.\\|\n\\)[^\\\"]*\\)*\"\\)" 1 string)
     ("[^$\\?]\\('[^\\']*\\(\\\\\\(.\\|\n\\)[^\\']*\\)*'\\)" 1 string)
     ("[^$\\?]\\(`[^\\`]*\\(\\\\\\(.\\|\n\\)[^\\`]*\\)*`\\)" 1 string)
     ("^\\s *#.*$" nil comment)
     ("[^$@@?\\]\\(#[^$@@{\n].*$\\)" 1 comment)
     ("[^a-zA-Z_]\\(\\?\\(\\\\[CM]-\\)*.\\)" 1 string)
     ("^\\s *\\(require\\|load\\).*$" nil include)
     ("^\\s *\\(include\\|alias\\|undef\\).*$" nil decl)
     ("^\\s *\\<\\(class\\|def\\|module\\)\\>" "[)\n;]" defun)
     ("[^_]\\<\\(begin\\|case\\|else\\|elsif\\|end\\|ensure\\|for\\|if\\|unless\\|rescue\\|then\\|when\\|while\\|until\\|do\\|yield\\)\\>\\([^_]\\|$\\)" 1 defun)
     ("[^_]\\<\\(and\\|break\\|next\\|raise\\|fail\\|in\\|not\\|or\\|redo\\|retry\\|return\\|super\\|yield\\|catch\\|throw\\|self\\|nil\\)\\>\\([^_]\\|$\\)" 1 keyword)
     ("\\$\\(.\\|\\sw+\\)" nil type)
     ("[$@@].[a-zA-Z_0-9]*" nil struct)
     ("^__END__" nil label))))
 )


(provide 'ruby-mode)
@


1.57
log
@* misc/ruby-mode.el (ruby-accurate-end-of-block): restrict search
  region.

* misc/ruby-mode.el (ruby-parse-partial): reversed wrong patch.
@
text
@d5 1
a5 1
;;;  $Date: 2002/07/30 08:23:31 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.56 $")
d156 1
a156 1
	(ruby-accurate-end-of-block))
d162 1
a162 1
	(ruby-accurate-end-of-block)
@


1.56
log
@* misc/ruby-mode.el (ruby-accurate-end-of-block): incomplete block
  caused infinite loop.

* misc/ruby-mode.el (ruby-parse-partial): returns nil unless
  delimiters found.
@
text
@d5 1
a5 1
;;;  $Date: 2002/07/26 09:33:39 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.55 $")
d176 1
d178 1
a178 1
		(>= (nth 2 state) 0)))))
d487 2
a488 2
		       )))))
    (list in-string nest depth pcol)))
@


1.55
log
@* misc/ruby-mode.el (ruby-expr-beg): wrong indent at modifiers
  after ?.
@
text
@d5 1
a5 1
;;;  $Date: 2002/07/25 00:08:56 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.54 $")
d174 1
a174 1
(defun ruby-accurate-end-of-block ()
d176 2
a177 1
    (while (>= (nth 2 (setq state (apply 'ruby-parse-partial end state))) 0))))
d486 2
a487 2
		       ))))))
  (list in-string nest depth pcol))
@


1.54
log
@* misc/ruby-mode.el (ruby-delimiter): include here document.

* misc/ruby-mode.el (ruby-deep-arglist): skips spaces after
  parenthesis when 'space.

* misc/ruby-mode.el (ruby-imenu-create-index): fix for nested
  classes.

* misc/ruby-mode.el (ruby-accurate-end-of-block): added.  scan a
  block in the order.

* misc/ruby-mode.el (ruby-expr-beg): support for here document.

* misc/ruby-mode.el (ruby-parse-partial): splitted from
  ruby-parse-region.

* misc/ruby-mode.el (ruby-move-to-block): skips RD style comments.
@
text
@d4 2
a5 2
;;;  $Author: matz $
;;;  $Date: 2002/06/28 14:40:54 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.53 $")
d273 1
a273 2
	    (and (or (eq option 'modifier)
		     (not (eq option 'heredoc))
d275 4
a278 1
		 (looking-at "[!?]"))
@


1.53
log
@* re.c (rb_reg_expr_str): need to process backslashes properly.

* object.c (rb_any_to_a): declare Object#to_a to be obsolete.

* object.c (rb_Array): do not convert nil into [] automagically.

* object.c (rb_Integer): use "to_int" instead of
  "to_i". [experimental]

* object.c (nil_to_f): new method.

* object.c (rb_Integer): Symbols and nil should cause error.

* object.c (rb_Float): nil should cause error.
@
text
@d5 1
a5 1
;;;  $Date: 2002/05/23 05:35:32 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.52 $")
d51 1
a51 1
  (concat "[?$/%(){}#\"'`.:]\\|\\[\\|\\]\\|\\<\\("
d130 2
a131 1
  "*Deep indent argument lists when non-nil.")
d134 10
a143 6
(defun ruby-imenu-create-index ()
  (let ((index-alist '())
	class-name class-begin method-name method-begin decl)
    (goto-char (point-min))
    (while (re-search-forward "^\\s *\\(class\\|def\\)\\s *\\([^(\n ]+\\)" nil t)
      (setq decl (buffer-substring (match-beginning 1) (match-end 1)))
d145 3
a147 11
       ((string= "class" decl)
	(setq class-begin (match-beginning 2))
	(setq class-name (buffer-substring class-begin (match-end 2)))
	(push (cons class-name (match-beginning 0)) index-alist)
	(ruby-mark-defun)
	(save-restriction
	  (narrow-to-region (region-beginning) (region-end))
         (while (re-search-forward "^\\s *def\\s *\\([^(\n ]+\\)" nil 'move)
	    (setq method-begin (match-beginning 1))
	    (setq method-name (buffer-substring method-begin (match-end 1)))
	    (push (cons (concat class-name "#" method-name) (match-beginning 0)) index-alist))))
d149 20
a168 3
	(setq method-begin (match-beginning 2))
	(setq method-name (buffer-substring method-begin (match-end 2)))
	(push (cons method-name (match-beginning 0)) index-alist))))
d171 7
d263 27
a289 25
    (skip-chars-backward " \t")
    (cond
     ((bolp) t)
     ((looking-at "\\?")
      (or (bolp) (forward-char -1))
      (not (looking-at "\\sw")))
     (t
      (forward-char -1)
      (or (looking-at ruby-operator-re)
	  (looking-at "[\\[({,;]")
	  (and (not (eq option 'modifier))
	       (looking-at "[!?]"))
	  (and (looking-at ruby-symbol-re)
	       (skip-chars-backward ruby-symbol-chars)
	       (cond
		((or (looking-at ruby-block-beg-re)
		     (looking-at ruby-block-op-re)
		     (looking-at ruby-block-mid-re))
		 (goto-char (match-end 0))
		 (looking-at "\\>"))
		((eq option 'expr-qstr)
		 (looking-at "[a-zA-Z][a-zA-z0-9_]* +%[^ \t]"))
		((eq option 'expr-re)
		 (looking-at "[a-zA-Z][a-zA-z0-9_]* +/[^ \t]"))
		(t nil))))))))
d306 98
a403 143
(defun ruby-parse-region (start end)
  (let ((indent-point end)
	  (indent 0)
	  (in-string nil)
	  (in-paren nil)
	  (depth 0)
	  (nest nil)
	  (pcol nil))
    (save-excursion
	(if start
	    (goto-char start)
	  (ruby-beginning-of-indent))
	(save-restriction
	  (narrow-to-region (point) end)
	  (while (and (> indent-point (point))
		      (re-search-forward ruby-delimiter indent-point t))
	    (or depth (setq depth 0))
	    (let ((pnt (point)) w re expand)
	      (goto-char (match-beginning 0))
	      (cond
	       ((or (looking-at "\"")	;skip string
		    (looking-at "`"))
		(cond
		 ((and (not (eobp))
		       (ruby-forward-string (buffer-substring (point) (1+ (point))) indent-point t t))
		  nil)
		 (t
		  (setq in-string (point))
		  (goto-char indent-point))))
	       ((looking-at "'")
		(cond
		 ((and (not (eobp))
		       (re-search-forward "[^\\]\\(\\\\\\\\\\)*'" indent-point t))
		  nil)
		 (t
		  (setq in-string (point))
		  (goto-char indent-point))))
	       ((looking-at "/")
		(cond
		 ((and (not (eobp)) (ruby-expr-beg 'expr-re))
		  (if (ruby-forward-string "/" indent-point t t)
		      nil
		    (setq in-string (point))
		    (goto-char indent-point)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "%")
		(cond
		 ((and (not (eobp))
		       (ruby-expr-beg 'expr-qstr)
		       (not (looking-at "%="))
		       (looking-at "%[Qqrxw]?\\(.\\)"))
		  (goto-char (match-beginning 1))
		  (setq expand (not (eq (char-before) ?q)))
		  (setq w (buffer-substring (match-beginning 1)
					    (match-end 1)))
		  (cond
		   ((string= w "[") (setq re "]["))
		   ((string= w "{") (setq re "}{"))
		   ((string= w "(") (setq re ")("))
		   ((string= w "<") (setq re "><"))
		   ((or (and expand (string= w "\\"))
			(member w '("*" "." "+" "?" "^" "$")))
		    (setq w (concat "\\" w))))
		  (unless (cond (re (ruby-forward-string re indent-point t expand))
				(expand (ruby-forward-string w indent-point t t))
				(t (re-search-forward
				    (if (string= w "\\")
					"\\\\[^\\]*\\\\"
				      (concat "[^\\]\\(\\\\\\\\\\)*" w))
				    indent-point t)))
		    (setq in-string (point))
		    (goto-char indent-point)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "\\?")	;skip ?char
		(cond
		 ((ruby-expr-beg)
		  (looking-at "?\\(\\\\C-\\|\\\\M-\\)*.")
		  (goto-char (match-end 0)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "\\$")	;skip $char
		(goto-char pnt)
		(forward-char 1))
	       ((looking-at "#")	;skip comment
		(forward-line 1)
		(goto-char (point))
		)
	       ((and (looking-at "(") ruby-deep-arglist)
		(setq nest (cons (cons (char-after (point)) pnt) nest))
		(setq pcol (cons (cons pnt depth) pcol))
		(setq depth 0)
		(goto-char pnt)
		)
	       ((looking-at "[\\[{(]")
		(setq nest (cons (cons (char-after (point)) pnt) nest))
		(setq depth (1+ depth))
		(goto-char pnt)
		)
	       ((and (looking-at ")") ruby-deep-arglist)
		(setq nest (cdr nest))
		(setq depth (cdr (car pcol)))
		(setq pcol (cdr pcol))
		(goto-char pnt))
	       ((looking-at "[])}]")
		(setq nest (cdr nest))
		(setq depth (1- depth))
		(goto-char pnt))
	       ((looking-at ruby-block-end-re)
		(if (or (and (not (bolp))
			     (progn
			       (forward-char -1)
			       (setq w (char-after (point)))
			       (or (eq ?_ w)
				   (eq ?. w))))
			(progn
			  (goto-char pnt)
			  (setq w (char-after (point)))
			  (or (eq ?_ w)
			      (eq ?! w)
			      (eq ?? w))))
		    nil
		  (setq nest (cdr nest))
		  (setq depth (1- depth)))
		(goto-char pnt))
	       ((looking-at "def\\s +[^(\n;]*")
		(if (or (bolp)
			(progn
			  (forward-char -1)
			  (not (eq ?_ (char-after (point))))))
		    (progn
		      (setq nest (cons (cons nil pnt) nest))
		      (setq depth (1+ depth))))
		(goto-char (match-end 0)))
	       ((looking-at ruby-block-beg-re)
		(and
		 (save-match-data
                   (or (not (looking-at "do\\>[^_]"))
                       (save-excursion
                         (back-to-indentation)
			 (not (looking-at ruby-non-block-do-re)))))
		 (or (bolp)
d407 95
a501 32
		       (not (or (eq ?_ w)
				(eq ?. w)))))
		 (goto-char pnt)
		 (setq w (char-after (point)))
		 (not (eq ?_ w))
		 (not (eq ?! w))
		 (not (eq ?? w))
		 (skip-chars-forward " \t")
		 (goto-char (match-beginning 0))
		 (or (not (looking-at ruby-modifier-re))
		     (ruby-expr-beg 'modifier))
		 (goto-char pnt)
		 (setq nest (cons (cons nil pnt) nest))
		 (setq depth (1+ depth)))
		(goto-char pnt))
	       ((looking-at ":\\([a-zA-Z_][a-zA-Z_0-9]*\\)?")
		(goto-char (match-end 0)))
	       ((or (looking-at "\\.")
		    (looking-at "\\.\\.\\.?")
		    (looking-at "\\.[0-9]+")
		    (looking-at "\\.[a-zA-Z_0-9]+"))
		(goto-char (match-end 0)))
	       ((looking-at "^=begin")
		(if (re-search-forward "^=end" indent-point t)
		    (forward-line 1)
		  (setq in-string (match-end 0))
		  (goto-char indent-point)))
	       (t
		(error (format "bad string %s"
			       (buffer-substring (point) pnt)
			       )))))))
	(list in-string (car nest) depth (car (car pcol))))))
d671 12
a682 4
    (if (eobp)
	nil
      (while (and (not (bobp)) (not (eobp)) (not done))
	(forward-line n)
d684 11
a694 16
	 ((looking-at "^$"))
	 ((looking-at "^\\s *#"))
	 (t
	  (setq pos (current-indentation))
	  (cond
	   ((< start pos)
	    (setq down t))
	   ((and down (= pos start))
	    (setq done t))
	   ((> start pos)
	    (setq done t)))))
	(if done
	    (progn
	      (back-to-indentation)
	      (if (looking-at ruby-block-mid-re)
		  (setq done nil)))))))
d753 1
a753 2
		(setq mlist (list (buffer-substring
				   (match-beginning 2) (match-end 2))))
d767 1
a767 3
		  (setq mlist
			(cons (buffer-substring
			       (match-beginning 2) (match-end 2)) mlist))
@


1.52
log
@* ruby.c (proc_options): removed "-*-" support for #! line.

* io.c (rb_io_s_sysopen): new method to get a raw file
  descriptor. [new]

* ext/socket/socket.c (tcp_sysaccept): new method to return an
  accepted socket fd (integer). [new]

* ext/socket/socket.c (unix_sysaccept,sock_sysaccept): ditto.
@
text
@d4 2
a5 2
;;;  $Author: nobu $
;;;  $Date: 2002/05/21 04:35:23 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.51 $")
d785 1
@


1.51
log
@* misc/ruby-mode.el (ruby-font-lock-keywords): symbols end with '_'.
@
text
@d4 2
a5 2
;;;  $Author: matz $
;;;  $Date: 2002/05/14 06:22:29 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.50 $")
d784 1
a784 1
	       (make-local-variable 'font-lock-syntactic-keywords)
d787 1
d816 5
d864 1
a864 1
	    "\\)\\>\\([^_]\\|$\\)")
d867 1
a867 1
     '("\\(^\\|[^_:.@@$]\\|\\.\\.\\)\\b\\(nil\\|self\\|true\\|false\\)\\b\\([^_]\\|$\\)"
@


1.50
log
@* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* numeric.c (flo_to_s): default format precision to be "%.16g".

* util.c (ruby_strtod): use own strtod(3) implementation to avoid
  locale hell.  Due to this change "0xff".to_f no longer returns 255.0

* eval.c (avalue_to_yvalue): new function to distinguish yvalue
  (no-arg == Qundef) from svalue (no-arg == Qnil).

* eval.c (rb_yield_0): use avalue_to_yvalue().

* eval.c (assign): warn if val == Qundef where it means rhs is
  void (e.g. yield without value or call without argument).

* parse.y (value_expr): need not to warn for WHILE and UNTIL,
  since they can have return value (via valued break).
@
text
@d4 2
a5 2
;;;  $Author: nobu $
;;;  $Date: 2002/04/10 05:22:46 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.49 $")
d880 1
a880 1
     '("\\(^\\|[^:]\\)\\(:\\([-+~]@@?\\|[/%&|^`]\\|\\*\\*?\\|<\\(<\\|=>?\\)?\\|>[>=]?\\|===?\\|=~\\|\\[\\]=?\\|\\(\\w\\|_\\)+\\([!?=]\\|\\b\\)\\|#{[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}\\)\\)"
@


1.49
log
@* misc/ruby-mode.el (ruby-font-lock-keywords): fontify symbols for
  unary operators and aset.
@
text
@d5 1
a5 1
;;;  $Date: 2002/02/18 05:17:53 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.48 $")
d129 3
d372 1
a372 1
	       ((looking-at "(")
d378 1
a378 1
	       ((looking-at "[\\[{]")
d383 1
a383 1
	       ((looking-at ")")
d484 1
a484 1
	  (if (eq (car (nth 1 state)) ?\( )
@


1.48
log
@* misc/ruby-mode.el (ruby-block-hanging-re): rescue block was too
  indented.
@
text
@d5 1
a5 1
;;;  $Date: 2002/02/17 15:31:37 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.47 $")
d877 1
a877 1
     '("\\(^\\|[^:]\\)\\(:\\([-+/%&|^~`]\\|\\*\\*?\\|<\\(<\\|=>?\\)?\\|>[>=]?\\|===?\\|=~\\|\\[\\]\\|\\(\\w\\|_\\)+\\([!?=]\\|\\b\\)\\|#{[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}\\)\\)"
@


1.47
log
@* misc/ruby-mode.el (ruby-font-lock-keywords): fontify
  instance/class/global variables start with '_'.
@
text
@d4 2
a5 2
;;;  $Author: matz $
;;;  $Date: 2002/02/01 06:03:03 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.46 $")
d28 4
d33 1
a33 1
  "if\\|unless\\|while\\|until\\|rescue"
d45 1
a45 1
  (concat ruby-modifier-re "\\|" ruby-block-op-re)
@


1.46
log
@* file.c (rb_stat_inspect): print dev, rdev in hexadecimal.
@
text
@d5 1
a5 1
;;;  $Date: 2002/01/25 08:22:11 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.45 $")
d29 1
a29 1
  "if\\|unless\\|while\\|until"
d859 1
a859 1
     '("\\(\\$\\|@@\\|@@@@\\)\\(\\w\\(\\w\\|_\\)*\\|#{\\)"
d876 1
a876 1
     '("#{[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}" 
@


1.45
log
@* class.c (rb_include_module): detect cyclic module inclusion.

* eval.c (rb_thread_cleanup): need not to free thread stacks at
  process termination.

* array.c (rb_ary_fetch): use the block to get the default value
  if the block is given.

* eval.c (rb_thread_schedule): should check time only if BOTH
  WAIT_SELECT and WAIT_TIME.

* eval.c (umethod_bind): should update rklass field.

* hash.c (rb_hash_update): if a block is given, yields [key,
  value1, value2] to the block to resolve conflict.

* string.c (rb_str_split_m): no need to consider KANJI
characters, if the length of separator is 1 (byte).
@
text
@d5 1
a5 1
;;;  $Date: 2002/01/23 07:30:43 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.44 $")
d776 2
@


1.44
log
@* array.c (Init_Array): remove Array#filter.

* object.c (rb_mod_initialize): should accept zero argument.

* object.c (rb_mod_cmp): should raise ArgumentError if
  inheritance/inclusion relation between two classes/modules is
  not defined. [new]

* io.c (rb_io_fsync): new method. [new]
@
text
@d5 1
a5 1
;;;  $Date: 2002/01/18 14:24:01 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.43 $")
d259 1
a259 2
		(t
		 (looking-at "[a-zA-Z][a-zA-z0-9_]* +")))))))))
@


1.43
log
@* io.c (rb_io_s_new): block check moved from initialize to this
  method.

* io.c (rb_io_s_open): open should call initialize too. IO#for_fd
  also calls initialize. [new]

* error.c (rb_sys_fail): replace INT2FIX() by INT2NUM() since
  errno value may not fit in Fixnum size on Hurd.

* error.c (set_syserr): ditto.

* dir.c (dir_s_glob): returns nil if block given.

* io.c (rb_io_each_byte): should return self.

* io.c (rb_io_close_m): close check added.

* dir.c (dir_seek): should return pos.

* parse.y (fixpos): orig may be (NODE*)1, which should not be
  dereferenced.
@
text
@d4 2
a5 2
;;;  $Author: nobu $
;;;  $Date: 2002/01/09 17:50:44 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.42 $")
d255 4
d260 1
a260 2
		 (and (not (eq option 'expr-arg))
		      (looking-at "[a-zA-Z][a-zA-z0-9_]* +/[^ \t]"))))))))))
d316 1
a316 1
		 ((and (not (eobp)) (ruby-expr-beg))
d325 2
a326 1
		 ((and (not (eobp)) (ruby-expr-beg 'expr-arg)
@


1.42
log
@* misc/ruby-mode.el (ruby-calculate-indent): indentation after
  comment at beginning of buffer failed.

* misc/ruby-mode.el (font-lock-defaults): unless XEmacs, set
  font-lock variables in ruby-mode-hook.
@
text
@d5 1
a5 1
;;;  $Date: 2002/01/05 03:22:41 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.41 $")
d192 3
d687 36
@


1.41
log
@* misc/ruby-mode.el (ruby-forward-string): forward a string. [new]

* misc/ruby-mode.el (ruby-parse-region): handle nested parentheses
  in a string and terminators in #{}.

* misc/ruby-mode.el (ruby-calculate-indent): ditto.

* misc/ruby-mode.el (ruby-font-lock-syntactic-keywords):
  fix font-lock problem [ruby-talk:29296].
@
text
@d4 2
a5 2
;;;  $Author: matz $
;;;  $Date: 2002/01/04 14:15:33 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.40 $")
d546 1
a546 1
			  (= (char-before) ??))
d723 14
a736 6
  (put 'ruby-mode 'font-lock-defaults
       '((ruby-font-lock-keywords)
         nil nil nil
         beginning-of-line
         (font-lock-syntactic-keywords
          . ruby-font-lock-syntactic-keywords)))
@


1.40
log
@* process.c (rb_f_system): abandon vfork.

* io.c (pipe_open): ditto.

* defines.h: sparc linux needs different FLUSH_REGISTER_WINDOWS

* regex.c (re_search): abandon stclass optimization.

* bignum.c (rb_cstr2inum): deny "0_".

* bignum.c (rb_cstr2inum): allow "0\n" and so on.

* error.c (rb_invalid_str): utility function to show inspect()'ed
  string.

* bignum.c (rb_cstr2inum): prints invalid strings in inspect()'ed
  format.

* object.c (rb_Float): ditto.

* object.c (rb_convert_type): no longer use rb_rescue().

* re.c (rb_reg_search): initialize taint status of match object.
@
text
@d5 1
a5 1
;;;  $Date: 2001/12/21 09:23:28 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.39 $")
d256 15
d288 1
a288 1
	    (let ((pnt (point)) w re)
a291 1
		    (looking-at "'")
a292 1
		(setq w (char-after (point)))
d295 9
a303 1
		       (re-search-forward (format "[^\\]\\(\\\\\\\\\\)*%c" w) indent-point t))
d311 1
a311 1
		  (if (re-search-forward "[^\\]\\(\\\\\\\\\\)*/" indent-point t)
d323 1
d331 2
a332 1
		   ((member w '("*" "." "+" "?" "^" "$"))
d334 7
a340 16
		  (if (if re
			  (let ((n 1))
			    (setq re (concat "[^\\]\\(\\\\\\\\\\)*[" re "]"))
			    (while (and (re-search-forward re indent-point t)
					(> (setq n (if (eq (char-before (point))
							   (string-to-char w))
						       (1+ n) (1- n)))
					   0))
			      (forward-char -1))
			    (zerop n))
			(re-search-forward
			 (if (string= w "\\")
			     "\\\\[^\\]*\\\\"
			   (concat "[^\\]\\(\\\\\\\\\\)*" w))
			 indent-point t))
		      nil
d479 1
a479 1
		 (t 
d489 1
a489 1
	    ))	  
d517 1
a517 1
	  (cond 
d545 5
a549 13
	      (and 
	       (re-search-backward "#" (save-excursion
					 (beginning-of-line)
					 (point)) t)
	       (if (not (= (point) (point-min)))
		   (save-excursion
		     (forward-char -1)
		     (not (looking-at "\\?"))))
	       (skip-chars-backward " \t")
	       (if (save-excursion
		     (forward-char -1)
		     (looking-at "\\?"))
		   (skip-chars-forward " \t"))
d690 39
a728 39

  (add-hook 'ruby-mode-hook
	    '(lambda ()
	       (make-local-variable 'ruby-font-lock-syntactic-keywords)
	       (setq ruby-font-lock-syntactic-keywords
		     '(
		       ;; #{ }, #$hoge, #@@foo are not comments
		       ("\\(#\\)[{$@@]" 1 (1 . nil))
		       ;; the last $' in the string ,'...$' is not variable 
		       ;; the last ?' in the string ,'...?' is not ascii code 
		       ("\\(^\\|[[\\s <+(,=]\\)\\('\\)[^'\n\\\\]*\\(\\\\.[^'\n\\\\]*\\)*[?$]\\('\\)"
			(2 (7 . nil))
			(4 (7 . nil)))	
		       ;; the last $` in the string ,`...$` is not variable
		       ;; the last ?` in the string ,`...?` is not ascii code
		       ("\\(^\\|[[\\s <+(,=]\\)\\(`\\)[^`\n\\\\]*\\(\\\\.[^`\n\\\\]*\\)*[?$]\\(`\\)"
			(2 (7 . nil))
			(4 (7 . nil)))
		       ;; the last $" in the string ,"...$" is not variable
		       ;; the last ?" in the string ,"...?" is not ascii code
		       ("\\(^\\|[[\\s <+(,=]\\)\\(\"\\)[^\"\n\\\\]*\\(\\\\.[^\"\n\\\\]*\\)*[?$]\\(\"\\)"
			(2 (7 . nil))
			(4 (7 . nil)))
		       ;; $' $" $` .... are variables
		       ;; ?' ?" ?` are ascii codes
		       ("[?$][#\"'`]" 0 (1 . nil))
		       ;; regexps 
		       ("\\(^\\|[=(,~?:;]\\|\\(^\\|\\s \\)\\(if\\|elsif\\|unless\\|while\\|until\\|when\\|and\\|or\\|&&\\|||\\)\\|g?sub!?\\|scan\\|split!?\\)\\s *\\(/\\)[^/\n\\\\]*\\(\\\\.[^/\n\\\\]*\\)*\\(/\\)"
			(4 (7 . ?/))
			(6 (7 . ?/)))
		       ;; %Q!...! 
		       ("\\(^\\|[[\\s <+(,=]\\)%[xrqQ]?\\([^a-zA-Z0-9 \n]\\)[^\n\\\\]*\\(\\\\.[^\n\\\\]*\\)*\\(\\2\\)" 
			(2 (7 . nil))
			(4 (7 . nil)))		       
		       ("^\\(=\\)begin\\(\\s \\|$\\)" 1 (7 . nil))
		       ("^\\(=\\)end\\(\\s \\|$\\)" 1 (7 . nil))))
	       (make-local-variable 'font-lock-defaults)
	       (setq font-lock-defaults '((ruby-font-lock-keywords) nil nil))
	       (setq font-lock-keywords ruby-font-lock-keywords)))
d806 1
a806 1
       1 font-lock-variable-name-face)     
@


1.39
log
@* time.c (time_plus): result should not be negative unless
  NEGATIVE_TIME_T is defined.

* time.c (time_new_internal): should check tv_sec overflow too.

* time.c (time_timeval): should check time_t range when time is
  initialized from float.

* time.c (time_plus): uses modf(3).

* variable.c (rb_cvar_set): add frozen class/module check.

* variable.c (rb_cvar_declare): add frozen class/module check.

* re.c (match_to_a): should propagate taint.

* re.c (rb_reg_s_quote): ditto.
@
text
@d5 1
a5 1
;;;  $Date: 2001/12/18 08:47:06 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.38 $")
d273 1
a273 1
	    (let ((pnt (point)) w)
d305 4
a308 4
		   ((string= w "[") (setq w "\\]"))
		   ((string= w "{") (setq w "}"))
		   ((string= w "(") (setq w ")"))
		   ((string= w "<") (setq w ">"))
d311 15
a325 5
		  (if (re-search-forward
		       (if (string= w "\\")
			   "\\\\[^\\]*\\\\"
			 (concat "[^\\]\\(\\\\\\\\\\)*" w))
		       indent-point t)
d687 2
a688 2
	       (make-local-variable 'font-lock-syntactic-keywords)
	       (setq font-lock-syntactic-keywords
@


1.38
log
@* string.c (rb_str_replace): swap arguments of OBJ_INFECT.

* eval.c (rb_thread_schedule): should not select a thread which is
  not yet initialized.

* time.c (time_plus): wrong boundary check.

* time.c (time_minus): ditto.
@
text
@d5 1
a5 1
;;;  $Date: 2001/11/28 14:56:32 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.37 $")
d525 4
a528 3
	       (save-excursion
		 (forward-char -1)
		 (not (looking-at "\\?")))
@


1.37
log
@* eval.c (rb_thread_select): should subtract timeofday() from
  limit, not reverse.

* util.c (scan_hex): x is not a hexadecimal digit.

* eval.c (rb_thread_schedule): should treat the case that
  select(2) returns 0, if a thread is under both WAIT_SELECT and
  WAIT_TIME.  Jakub Travnik <J.Travnik@@sh.cvut.cz> actually fixed
  this bug.
@
text
@d5 1
a5 1
;;;  $Date: 2001/10/30 08:43:28 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.36 $")
d683 1
a683 1
		       ("\\(^\\|[[\\s <+(,=]\\)\\('\\)[^'\n\\\\]*\\(\\\\.[^'\n\\\\]*\\)*[\\?\\$]\\('\\)"
d688 1
a688 1
		       ("\\(^\\|[[\\s <+(,=]\\)\\(`\\)[^`\n\\\\]*\\(\\\\.[^`\n\\\\]*\\)*[\\?\\$]\\(`\\)"
d693 1
a693 1
		       ("\\(^\\|[[\\s <+(,=]\\)\\(\"\\)[^\"\n\\\\]*\\(\\\\.[^\"\n\\\\]*\\)*[\\?\\$]\\(\"\\)"
d698 1
a698 1
		       ("[\\?\\$][#\"'`]" 0 (1 . nil))
@


1.36
log
@* string.c (rb_str_chomp_bang): do smart chomp if $/ == '\n'.

* io.c (rb_io_puts): don't treat Array specially.

* bignum.c (rb_big_cmp): should convert bignum to float.

* eval.c (rb_f_eval): can't modify untainted binding.

* regex.c (re_compile_pattern): should preverve p0 value.
@
text
@d5 1
a5 1
;;;  $Date: 2001/10/16 03:27:23 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.35 $")
d525 3
d529 4
@


1.35
log
@* string.c (rb_str_index): wrong increment for non alphanumeric
  string.
@
text
@d5 1
a5 1
;;;  $Date: 2001/08/29 06:28:51 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.34 $")
d674 3
a676 2
		       ;; the last $' in the string ,'...$' is not variable    
		       ("\\(^\\|[[\\s <+(,]\\)\\('\\)[^'\n\\\\]*\\(\\\\.[^'\n\\\\]*\\)*[\\?\\$]\\('\\)"
d679 3
a681 2
		       ;; the last $` in the string ,`...$` is not variable   
		       ("\\(^\\|[[\\s <+(,]\\)\\(`\\)[^`\n\\\\]*\\(\\\\.[^`\n\\\\]*\\)*[\\?\\$]\\(`\\)"
d684 3
a686 2
		       ;; the last $" in the string ,"...$" is not variable   
		       ("\\(^\\|[[\\s <+(,]\\)\\(\"\\)[^\"\n\\\\]*\\(\\\\.[^\"\n\\\\]*\\)*[\\?\\$]\\(\"\\)"
d690 1
d697 1
a697 1
		       ("\\(^\\|[[\\s <+(,]\\)%[xrqQ]?\\([^a-zA-Z0-9 \n]\\)[^\n\\\\]*\\(\\\\.[^\n\\\\]*\\)*\\(\\2\\)" 
@


1.34
log
@* parse.y (yylex): ternary ? can be followed by newline.

* eval.c (rb_f_require): should check static linked libraries
  before raising exception.

* array.c (rb_ary_equal): check identiry equality first.

* string.c (rb_str_equal): ditto.

* struct.c (rb_struct_equal): ditto.

* numeric.c (Init_Numeric): undef Integer::new.

* eval.c (rb_eval): NODE_WHILE should update result for each
  conditional evaluation.

* eval.c (rb_eval): NODE_UNTIL should return last evaluated value
  (or value given to break).
@
text
@d5 1
a5 1
;;;  $Date: 2001/08/14 08:13:31 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.33 $")
d140 1
a140 1
	  (while (re-search-forward "^\\s *def\\s *\\([^(\n ]+\\)" nil t)
@


1.33
log
@* range.c (range_step): new method.

* string.c (rb_str_cmp): remove needless conditional.

* string.c (rb_str_lstrip_bang) `return Qnil' was missing.
@
text
@d5 1
a5 1
;;;  $Date: 2001/08/06 03:05:23 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.32 $")
d675 1
a675 1
		       ("\\(^\\|[[\\s <+(,]\\)\\('\\)[^'\n\\\\]*\\(\\\\.[^'\n\\\\]*\\)*\\$\\('\\)"
d679 1
a679 1
		       ("\\(^\\|[[\\s <+(,]\\)\\(`\\)[^`\n\\\\]*\\(\\\\.[^`\n\\\\]*\\)*\\$\\(`\\)"
d683 1
a683 1
		       ("\\(^\\|[[\\s <+(,]\\)\\(\"\\)[^\"\n\\\\]*\\(\\\\.[^\"\n\\\\]*\\)*\\$\\(\"\\)"
d687 1
a687 1
		       ("\\$[#\"'`$\\]" 0 (1 . nil))
d717 1
a717 1
		 (string= (match-string-no-properties 1) "begin"))
d722 1
a722 1
			(string= (match-string-no-properties 1) "end")))
@


1.32
log
@* string.c (rb_str_lstrip_bang): new method.

* string.c (rb_str_rstrip_bang): new method.

* string.c (rb_str_associate): should consider STR_ASSOC too.

* eval.c (rb_undefined): do not recurse if method_missing is
  undefined.

* process.c (proc_waitpid): now all arguments are optional.

* process.c (Init_process): waitpid is now alias to wait.

* process.c (Init_process): waitpid2 is now alias to wait2.

* process.c (rb_waitpid): made public.

* ext/pty/pty.c (pty_getpty): avoid disturbing SIGCHLD using
  thread and rb_waitpid.

* process.c (proc_getpgrp): now takes no argument on all
  platforms.

* process.c (proc_setpgrp): ditto.

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::pack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::pack_sockaddr_un(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::unpack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::unpack_sockaddr_un(). [new]
@
text
@d5 1
a5 1
;;;  $Date: 2001/06/23 15:14:25 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.31 $")
d671 2
a672 1
		     '(("\\$\\([#\"'`$\\]\\)" 1 (1 . nil))
d674 22
a695 3
		       ("\\(/\\)\\([^/\n]\\|\\/\\)*\\(/\\)"
			(1 (7 . ?'))
			(3 (7 . ?')))
a729 3
     ;; trick
     '("\\s-+" 0 nil t)
     '("\\S-+" 0 nil t)
d777 4
a780 4
     '("\\(\\$\\(\\W\\|[0-9]\\)\\)\\W"
       1 font-lock-variable-name-face t)     
     '("\\($\\|@@\\|@@@@\\)\\(\\w\\(\\w\\|_\\)*\\|#{\\)"
       0 font-lock-variable-name-face t)
a794 22
     ;; strings
     ;; %Q!   !
     '("[[\\s <+(,]%[rqQ]?\\(\\([^a-zA-Z0-9 \n]\\)[^\\2\n\\\\]*\\(\\\\.[^\\2\n\\\\]*\\)*\\2\\)" 
       1 font-lock-string-face t)
     ;; '...'
     '("[[\\s <+(,]\\('[^'\n\\\\]*\\(\\\\.[^'\n\\\\]*\\)*'\\)" 
       1 font-lock-string-face t)
     ;; "..."
     '("[[\\s <+(,]\\(\"[^\"\n\\\\]*\\(\\\\.[^\"\n\\\\]*\\)*\"\\)" 
       1 font-lock-string-face t)
     ;; `...`
     '("[\\s <+(,]\\(`[^`\n\\\\]*\\(\\\\.[^`\n\\\\]*\\)*`\\)" 
       1 font-lock-warning-face t)
     ;; %x!...!
     '("[\\s <+(,]%x\\(\\([^a-zA-Z0-9 \n]\\)[^\\2\n\\]*\\(\\\\.[^\\2\n\\]*\\)*\\2\\)" 
       1 font-lock-warning-face t)
     ;; regexps
     '("\\(^\\|[=(,~?:]\\|\\(^\\|\\s \\)\\(if\\|elsif\\|unless\\|while\\|until\\|when\\|and\\|or\\|&&\\|||\\)\\|\\.g?sub!?\\)\\s *\\(/[^/\n\\\\]*\\(\\\\.[^/\n\\\\]*\\)*/\\([iop]*\\)\\)"  
       (4 font-lock-string-face t)
       (6 font-lock-constant-face t))
     '("\\(/[^/\n\\\\]*\\(\\\\.[^/\n\\\\]*\\)*/\\)\\s *[=!][=~]"
       1 font-lock-string-face t)
d797 1
a797 4
       0 font-lock-variable-name-face t)
    ;; comment
     '("^\\s *\\([^#\n'\"%/]\\|'[^'\n\\]*\\(\\\\.[^'\n\\]*\\)*'\\|\"[^\"\n\\]*\\(\\\\.[^\"\n\\]*\\)*\"\\|%[rqQx]?\\([^a-zA-Z0-9 \n]\\)[^\\4\n\\]*\\(\\\\.[^\\4\n\\]*\\)*\\4\\|/[^/\n\\]*\\(\\\\.[^/\n\\]\\)*/\\|#{[^}\\\\]*\\(\\\\.[^}\\\\]*\\)*}\\)*\\(#\\([^{\n].*\\|$\\)\\)"
       8 font-lock-comment-face t))
@


1.31
log
@* eval.c (svalue_to_avalue): new conversion scheme between single
  value and array values.

* eval.c (avalue_to_svalue): ditto.

* eval.c (rb_eval): REXPAND now uses avalue_to_svalue(), return
  and yield too.

* eval.c (rb_yield_0): use avalue_to_svalue().

* eval.c (proc_invoke): Proc#call gives avaules, whereas
  Proc#yield gives mvalues.

* eval.c (bmcall): convert given value (svalue) to avalue.
@
text
@d5 1
a5 1
;;;  $Date: 2001/06/19 04:35:17 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.30 $")
d710 3
a755 4
     ;; regexps
     '("/\\(\\(\\\\/\\|[^/\n]\\)*\\)/\\([iop]*\\)"
       (1 font-lock-string-face)
       (3 font-lock-constant-face))
d760 4
a763 2
     '("[$@@].\\(\\w\\|_\\)*"
       0 font-lock-variable-name-face)
d776 30
a805 2
     '("\\(^\\|[^:]\\)\\(:\\([-+/%&|^~`]\\|\\*\\*?\\|<\\(<\\|=>?\\)?\\|>[>=]?\\|===?\\|=~\\|\\[\\]\\|\\(\\w\\|_\\)+\\([!?=]\\|\\b\\)\\)\\)"
       2 font-lock-reference-face))
@


1.30
log
@* eval.c (rb_f_require): searches ".rb" and ".so" at the same
  time.  previous behavior (search ".rb", then ".so") has a
  security risk (ruby-bugs#PR140).

* array.c (rb_ary_to_ary): new function to replace internal
  rb_Array(), which never calls to_a, but to_ary (rb_Array() might
  call both). [new]

* regex.c (PUSH_FAILURE_POINT): push option status again.

* regex.c (re_compile_pattern): avoid pushing unnecessary
  option_set.

* eval.c (rb_load): tainted string is OK if wrapped *and*
  $SAFE >= 4.

* eval.c (rb_thread_start_0): should not nail down higher blocks
  before preserving original context (i.e. should not alter
  original context).

* eval.c (proc_yield): new method equivalent to Proc#call but no
  check for number of arguments. [new]
@
text
@d5 1
a5 1
;;;  $Date: 2001/05/30 09:10:28 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.28 $")
d753 4
@


1.29
log
@* parse.y (aref_args): "*arg" should always be expanded by REXPAND.

* variable.c (fc_i): removed vast string allocation.
@
text
@d663 2
d666 15
a680 14
  (setq ruby-font-lock-syntactic-keywords
 	'(("\\$\\([#\"'`$\\]\\)" 1 (1 . nil))
 	  ("\\(#\\)[{$@@]" 1 (1 . nil))
 	  ("\\(/\\)\\([^/\n]\\|\\/\\)*\\(/\\)"
 	   (1 (7 . ?'))
 	   (3 (7 . ?')))
	  ("^\\(=\\)begin\\(\\s \\|$\\)" 1 (7 . nil))
	  ("^\\(=\\)end\\(\\s \\|$\\)" 1 (7 . nil))))
  (put major-mode 'font-lock-defaults
       '((ruby-font-lock-keywords)
	 nil nil nil
	 beginning-of-line
	 (font-lock-syntactic-keywords
	  . ruby-font-lock-syntactic-keywords)))
d693 15
d761 2
@


1.28
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_finish): removed.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* string.c (rb_str_buf_finish): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d5 1
a5 1
;;;  $Date: 2001/05/06 15:05:19 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.27 $")
a662 2
  (or (boundp 'font-lock-variable-name-face)
      (setq font-lock-variable-name-face font-lock-type-face))
d664 14
a677 15

  (add-hook 'ruby-mode-hook
	    '(lambda ()
	       (make-local-variable 'font-lock-syntactic-keywords)
	       (setq font-lock-syntactic-keywords
		     '(("\\$\\([#\"'`$\\]\\)" 1 (1 . nil))
		       ("\\(#\\)[{$@@]" 1 (1 . nil))
		       ("\\(/\\)\\([^/\n]\\|\\/\\)*\\(/\\)"
			(1 (7 . ?'))
			(3 (7 . ?')))
		       ("^\\(=\\)begin\\(\\s \\|$\\)" 1 (7 . nil))
		       ("^\\(=\\)end\\(\\s \\|$\\)" 1 (7 . nil))))
	       (make-local-variable 'font-lock-defaults)
	       (setq font-lock-defaults '((ruby-font-lock-keywords) nil nil))
	       (setq font-lock-keywords ruby-font-lock-keywords)))
@


1.27
log
@forgot some checkins.
@
text
@d5 1
a5 1
;;;  $Date: 2001/02/08 09:19:25 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.26 $")
d675 3
a677 1
			(3 (7 . ?')))))
@


1.26
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_options): new method to give an option values.

* parse.y (cond0): disable special treating of integer literal in
  conditional unless option -e is supplied.  changes current
  behavior.  experimental.

* parse.y (cond0): give warning for string/integer literals and
  dot operators in conditionals unless option -e is supplied.

* re.c (rb_reg_equal): all option flags should be same to be equal.

* error.c (Init_Exception): make Interrupt a subclass of
  SignalException.
@
text
@d5 1
a5 1
;;;  $Date: 2000/12/25 06:29:27 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.25 $")
d673 1
a673 1
		       ("\\(/\\)\\([^/\n]\\|\\\\/\\)*\\(/\\)"
@


1.25
log
@001225
@
text
@d5 1
a5 1
;;;  $Date: 2000/12/05 09:36:54 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.24 $")
d752 1
a752 1
     '("\\(^\\|[^:]\\)\\(:\\(\\w\\|_\\)+\\??\\)\\b"
@


1.25.2.1
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_equal): all option flags should be same to be equal.
@
text
@d5 1
a5 1
;;;  $Date: 2000/12/25 06:29:27 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.25 $")
d752 1
a752 1
     '("\\(^\\|[^:]\\)\\(:\\([-+/%&|^~`]\\|\\*\\*?\\|<\\(<\\|=>?\\)?\\|>[>=]?\\|===?\\|=~\\|\\[\\]\\|\\(\\w\\|_\\)+\\([!?=]\\|\\b\\)\\)\\)"
@


1.25.2.2
log
@* string.c (rb_str_index): wrong increment for non alphanumeric
  string.
@
text
@d5 1
a5 1
;;;  $Date: 2001/02/08 09:18:02 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.25.2.1 $")
d140 1
a140 1
         (while (re-search-forward "^\\s *def\\s *\\([^(\n ]+\\)" nil 'move)
@


1.25.2.3
log
@* eval.c (rb_thread_schedule): should not select a thread which is
  not yet initialized.

* variable.c (find_class_path): should initialize iv_tbl if it's
  NULL.

* class.c (rb_define_class): should return the existing class if
  the class is already defined and its superclass is ideintical to
  the specified superclass.

* class.c (rb_define_class_under): ditto.

* class.c (rb_define_module): should return the existing module if
  the module is already defined.
@
text
@d5 1
a5 1
;;;  $Date: 2001/11/28 14:56:32 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.37 $")
a524 3
	       (save-excursion
		 (forward-char -1)
		 (not (looking-at "\\?")))
a525 4
	       (if (save-excursion
		     (forward-char -1)
		     (looking-at "\\?"))
		   (skip-chars-forward " \t"))
d671 1
a671 2
		     '(
		       ;; #{ }, #$hoge, #@@foo are not comments
d673 3
a675 28
		       ;; the last $' in the string ,'...$' is not variable 
		       ;; the last ?' in the string ,'...?' is not ascii code 
		       ("\\(^\\|[[\\s <+(,=]\\)\\('\\)[^'\n\\\\]*\\(\\\\.[^'\n\\\\]*\\)*[?$]\\('\\)"
			(2 (7 . nil))
			(4 (7 . nil)))	
		       ;; the last $` in the string ,`...$` is not variable
		       ;; the last ?` in the string ,`...?` is not ascii code
		       ("\\(^\\|[[\\s <+(,=]\\)\\(`\\)[^`\n\\\\]*\\(\\\\.[^`\n\\\\]*\\)*[?$]\\(`\\)"
			(2 (7 . nil))
			(4 (7 . nil)))
		       ;; the last $" in the string ,"...$" is not variable
		       ;; the last ?" in the string ,"...?" is not ascii code
		       ("\\(^\\|[[\\s <+(,=]\\)\\(\"\\)[^\"\n\\\\]*\\(\\\\.[^\"\n\\\\]*\\)*[?$]\\(\"\\)"
			(2 (7 . nil))
			(4 (7 . nil)))
		       ;; $' $" $` .... are variables
		       ;; ?' ?" ?` are ascii codes
		       ("[?$][#\"'`]" 0 (1 . nil))
		       ;; regexps 
		       ("\\(^\\|[=(,~?:;]\\|\\(^\\|\\s \\)\\(if\\|elsif\\|unless\\|while\\|until\\|when\\|and\\|or\\|&&\\|||\\)\\|g?sub!?\\|scan\\|split!?\\)\\s *\\(/\\)[^/\n\\\\]*\\(\\\\.[^/\n\\\\]*\\)*\\(/\\)"
			(4 (7 . ?/))
			(6 (7 . ?/)))
		       ;; %Q!...! 
		       ("\\(^\\|[[\\s <+(,=]\\)%[xrqQ]?\\([^a-zA-Z0-9 \n]\\)[^\n\\\\]*\\(\\\\.[^\n\\\\]*\\)*\\(\\2\\)" 
			(2 (7 . nil))
			(4 (7 . nil)))		       
		       ("^\\(=\\)begin\\(\\s \\|$\\)" 1 (7 . nil))
		       ("^\\(=\\)end\\(\\s \\|$\\)" 1 (7 . nil))))
a690 15
  (defun ruby-font-lock-maybe-docs (limit)
    (let (beg)
      (save-excursion
	(if (and (re-search-backward "^=\\(begin\\|end\\)\\(\\s \\|$\\)" nil t)
		 (string= (match-string 1) "begin"))
	    (progn
	      (beginning-of-line)
	      (setq beg (point)))))
      (if (and beg (and (re-search-forward "^=\\(begin\\|end\\)\\(\\s \\|$\\)" nil t)
			(string= (match-string 1) "end")))
	  (progn
	    (set-match-data (list beg (point)))
	    t)
	nil)))

d740 1
a740 3
     '("\\(\\$\\([^a-zA-Z0-9 \n]\\|[0-9]\\)\\)\\W"
       1 font-lock-variable-name-face)     
     '("\\(\\$\\|@@\\|@@@@\\)\\(\\w\\(\\w\\|_\\)*\\|#{\\)"
a744 2
     '(ruby-font-lock-maybe-docs
       0 font-lock-comment-face t)
d752 2
a753 5
     '("\\(^\\|[^:]\\)\\(:\\([-+/%&|^~`]\\|\\*\\*?\\|<\\(<\\|=>?\\)?\\|>[>=]?\\|===?\\|=~\\|\\[\\]\\|\\(\\w\\|_\\)+\\([!?=]\\|\\b\\)\\|#{[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}\\)\\)"
       2 font-lock-reference-face)
     ;; expression expansion
     '("#{[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}" 
       0 font-lock-variable-name-face t))
@


1.25.2.4
log
@forgot to commit everything bug ChangeLog
@
text
@d5 1
a5 1
;;;  $Date: 2001/12/18 08:40:33 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.25.2.3 $")
d676 2
a677 2
	       (make-local-variable 'ruby-font-lock-syntactic-keywords)
	       (setq ruby-font-lock-syntactic-keywords
@


1.25.2.5
log
@* misc/ruby-mode.el (ruby-forward-string): forward a string. [new]

* misc/ruby-mode.el (ruby-parse-region): handle nested parentheses
  in a string and terminators in #{}.

* misc/ruby-mode.el (ruby-calculate-indent): ditto.

* misc/ruby-mode.el (ruby-font-lock-syntactic-keywords):
  fix font-lock problem [ruby-talk:29296].
@
text
@d5 1
a5 1
;;;  $Date: 2002/01/04 14:20:35 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.25.2.4 $")
a255 15
(defun ruby-forward-string (term &optional end no-error expand)
  (let ((n 1) (c (string-to-char term))
	(re (if expand
		(concat "[^\\]\\(\\\\\\\\\\)*\\([" term "]\\|\\(#{\\)\\)")
	      (concat "[^\\]\\(\\\\\\\\\\)*[" term "]"))))
    (while (and (re-search-forward re end no-error)
		(if (match-beginning 3)
		    (ruby-forward-string "}{" end no-error nil)
		  (> (setq n (if (eq (char-before (point)) c)
				     (1- n) (1+ n))) 0)))
      (forward-char -1))
    (cond ((zerop n))
	  (no-error nil)
	  (error "unterminated string"))))

d273 1
a273 1
	    (let ((pnt (point)) w re expand)
d277 1
d279 1
d282 1
a282 9
		       (ruby-forward-string (buffer-substring (point) (1+ (point))) indent-point t t))
		  nil)
		 (t
		  (setq in-string (point))
		  (goto-char indent-point))))
	       ((looking-at "'")
		(cond
		 ((and (not (eobp))
		       (re-search-forward "[^\\]\\(\\\\\\\\\\)*'" indent-point t))
d290 1
a290 1
		  (if (ruby-forward-string "/" indent-point t t)
a301 1
		  (setq expand (not (eq (char-before) ?q)))
d305 5
a309 6
		   ((string= w "[") (setq re "]["))
		   ((string= w "{") (setq re "}{"))
		   ((string= w "(") (setq re ")("))
		   ((string= w "<") (setq re "><"))
		   ((or (and expand (string= w "\\"))
			(member w '("*" "." "+" "?" "^" "$")))
d311 6
a316 7
		  (unless (cond (re (ruby-forward-string re indent-point t expand))
				(expand (ruby-forward-string w indent-point t t))
				(t (re-search-forward
				    (if (string= w "\\")
					"\\\\[^\\]*\\\\"
				      (concat "[^\\]\\(\\\\\\\\\\)*" w))
				    indent-point t)))
d455 1
a455 1
		 (t
d465 1
a465 1
	    ))
d493 1
a493 1
	  (cond
d521 12
a532 5
	      (while (and (re-search-backward "#" bol t)
			  (= (char-before) ??))
		(forward-char -1))
	      (skip-chars-backward " \t")
	      (and
d673 39
a711 39
  (setq ruby-font-lock-syntactic-keywords
	'(
	  ;; #{ }, #$hoge, #@@foo are not comments
	  ("\\(#\\)[{$@@]" 1 (1 . nil))
	  ;; the last $' in the string ,'...$' is not variable
	  ;; the last ?' in the string ,'...?' is not ascii code
	  ("\\(^\\|[[\\s <+(,=]\\)\\('\\)[^'\n\\\\]*\\(\\\\.[^'\n\\\\]*\\)*[?$]\\('\\)"
	   (2 (7 . nil))
	   (4 (7 . nil)))
	  ;; the last $` in the string ,`...$` is not variable
	  ;; the last ?` in the string ,`...?` is not ascii code
	  ("\\(^\\|[[\\s <+(,=]\\)\\(`\\)[^`\n\\\\]*\\(\\\\.[^`\n\\\\]*\\)*[?$]\\(`\\)"
	   (2 (7 . nil))
	   (4 (7 . nil)))
	  ;; the last $" in the string ,"...$" is not variable
	  ;; the last ?" in the string ,"...?" is not ascii code
	  ("\\(^\\|[[\\s <+(,=]\\)\\(\"\\)[^\"\n\\\\]*\\(\\\\.[^\"\n\\\\]*\\)*[?$]\\(\"\\)"
	   (2 (7 . nil))
	   (4 (7 . nil)))
	  ;; $' $" $` .... are variables
	  ;; ?' ?" ?` are ascii codes
	  ("[?$][#\"'`]" 0 (1 . nil))
	  ;; regexps
	  ("\\(^\\|[=(,~?:;]\\|\\(^\\|\\s \\)\\(if\\|elsif\\|unless\\|while\\|until\\|when\\|and\\|or\\|&&\\|||\\)\\|g?sub!?\\|scan\\|split!?\\)\\s *\\(/\\)[^/\n\\\\]*\\(\\\\.[^/\n\\\\]*\\)*\\(/\\)"
	   (4 (7 . ?/))
	   (6 (7 . ?/)))
	  ;; %Q!...!
	  ("\\(^\\|[[\\s <+(,=]\\)%[xrqQ]?\\([^a-zA-Z0-9 \n]\\)[^\n\\\\]*\\(\\\\.[^\n\\\\]*\\)*\\(\\2\\)"
	   (2 (7 . nil))
	   (4 (7 . nil)))
	  ("^\\(=\\)begin\\(\\s \\|$\\)" 1 (7 . nil))
	  ("^\\(=\\)end\\(\\s \\|$\\)" 1 (7 . nil))))

  (put 'ruby-mode 'font-lock-defaults
       '((ruby-font-lock-keywords)
         nil nil nil
         beginning-of-line
         (font-lock-syntactic-keywords
          . ruby-font-lock-syntactic-keywords)))
d789 1
a789 1
       1 font-lock-variable-name-face)
@


1.25.2.6
log
@* misc/ruby-mode.el (ruby-calculate-indent): indentation after
  comment at beginning of buffer failed.

* misc/ruby-mode.el (font-lock-defaults): unless XEmacs, set
  font-lock variables in ruby-mode-hook.
@
text
@d4 2
a5 2
;;;  $Author: nobu $
;;;  $Date: 2002/01/05 03:25:02 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.25.2.5 $")
d546 1
a546 1
			  (eq (char-before) ??))
d723 6
a728 14
  (cond ((featurep 'xemacs)
	 (put 'ruby-mode 'font-lock-defaults
	      '((ruby-font-lock-keywords)
		nil nil nil
		beginning-of-line
		(font-lock-syntactic-keywords
		 . ruby-font-lock-syntactic-keywords))))
	(t
	 (add-hook 'ruby-mode-hook
	    '(lambda ()
	       (make-local-variable 'font-lock-defaults)
	       (setq font-lock-defaults '((ruby-font-lock-keywords) nil nil))
	       (setq font-lock-keywords ruby-font-lock-keywords)
	       (setq font-lock-syntactic-keywords ruby-font-lock-syntactic-keywords)))))
@


1.25.2.7
log
@* object.c (rb_class_real): should not follow ICLASS link

* variable.c (classname): should follow ICLASS link explicitly.
@
text
@d5 1
a5 1
;;;  $Date: 2002/01/09 17:52:12 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.25.2.6 $")
a733 2
	       (make-local-variable 'font-lock-keywords)
	       (make-local-variable 'font-lock-syntactic-keywords)
@


1.25.2.8
log
@* misc/ruby-mode.el (ruby-modifier-re): add rescue modifier.

* misc/ruby-mode.el (ruby-font-lock-keywords): fontify
  instance/class/global variables start with '_'.
@
text
@d4 2
a5 2
;;;  $Author: matz $
;;;  $Date: 2002/02/04 08:09:14 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.25.2.7 $")
d28 1
a28 1
(defconst ruby-modifier-beg-re
a31 4
(defconst ruby-modifier-re
  (concat ruby-modifier-beg-re "\\|rescue")
  )

d41 1
a41 1
  (concat ruby-modifier-beg-re "\\|" ruby-block-op-re)
d817 1
a817 1
     '("\\(\\$\\|@@\\|@@@@\\)\\(\\w\\|_\\)+"
d834 1
a834 1
     '("#\\({[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}\\|\\(\\$\\|@@\\|@@@@\\)\\(\\w\\|_\\)+\\)"
@


1.25.2.9
log
@* misc/ruby-mode.el (ruby-font-lock-keywords): fontify symbols for
  unary operators and aset.
@
text
@d4 2
a5 2
;;;  $Author: nobu $
;;;  $Date: 2002/02/22 11:24:27 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.25.2.8 $")
d835 1
a835 1
     '("\\(^\\|[^:]\\)\\(:\\([-+~]@@?\\|[/%&|^`]\\|\\*\\*?\\|<\\(<\\|=>?\\)?\\|>[>=]?\\|===?\\|=~\\|\\[\\]=?\\|\\(\\w\\|_\\)+\\([!?=]\\|\\b\\)\\|#{[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}\\)\\)"
@


1.25.2.10
log
@* misc/ruby-mode.el (ruby-font-lock-keywords): symbols end with '_'.
@
text
@d5 1
a5 1
;;;  $Date: 2002/04/10 05:23:59 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.25.2.9 $")
d835 1
a835 1
     '("\\(^\\|[^:]\\)\\(:\\([-+~]@@?\\|[/%&|^`]\\|\\*\\*?\\|<\\(<\\|=>?\\)?\\|>[>=]?\\|===?\\|=~\\|\\[\\]=?\\|\\(\\w\\|_\\)+\\([!?=]\\|\\b_*\\)\\|#{[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}\\)\\)"
@


1.24
log
@matz
@
text
@d5 1
a5 1
;;;  $Date: 2000/11/20 07:31:55 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.23 $")
d666 1
d673 1
a673 1
		       ("\\(/\\)\\([^/]\\|\\\\/\\)*\\(/\\)"
@


1.23
log
@matz
@
text
@d5 1
a5 1
;;;  $Date: 2000/10/11 06:29:16 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.22 $")
d55 1
a55 1
	    ruby-block-end-re "\\)\\>\\|\\}\\|\\]\\)")
d552 1
a552 1
				     (not (looking-at "\\{")))
@


1.22
log
@matz
@
text
@d5 1
a5 1
;;;  $Date: 2000/10/10 07:03:34 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.21 $")
d595 1
a595 1
      (while (and (not (bobp)) (not done))
@


1.21
log
@matz
@
text
@d5 1
a5 1
;;;  $Date: 2000/10/02 07:48:39 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.20 $")
d515 1
a515 1
		    (forward-line 1)
@


1.20
log
@matz
@
text
@d5 1
a5 1
;;;  $Date: 2000/09/12 05:37:38 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.19 $")
a444 1

d465 1
a465 2
	    ))
	  
d486 1
a486 1
	 
d515 1
a515 1
		    (beginning-of-line)
d539 2
a542 1
		      (not (eq (char-after (1- (point))) ?$))
@


1.19
log
@matz: 1.6.0 final (hopufully)
@
text
@d5 1
a5 1
;;;  $Date: 2000/09/07 06:59:46 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.18 $")
d673 1
a673 1
		       ("\\(/\\).*\\(/\\)"
d675 1
a675 1
			(2 (7 . ?')))))
@


1.18
log
@matz
@
text
@d5 1
a5 1
;;;  $Date: 2000/09/01 07:25:25 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.17 $")
d547 11
a557 9
			    (and (search-backward "|")
				 (skip-chars-backward " \t\n")
				 (and (not (eolp))
				      (progn
					(forward-char -1)
					(not (looking-at "\\{")))
				      (progn
					(forward-word -1)
					(not (looking-at "do\\>[^_]")))))))))
d560 1
a560 1
 
@


1.17
log
@matz
@
text
@d5 1
a5 1
;;;  $Date: 2000/07/04 04:17:24 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.16 $")
d40 4
d231 5
a235 6
    (if (looking-at "\\?")
	(progn
	  (or (bolp) (forward-char -1))
	  (not (looking-at "\\sw")))
      (store-match-data nil)
      (skip-chars-backward " \t")
d237 5
a241 3
      (or (bolp)
	  (looking-at ruby-operator-re)
	  (looking-at "[\\[({]")
d246 9
a254 10
	       (if (and (not (eq option 'modifier)) (bolp))
		   t
		 (if (or (looking-at ruby-block-beg-re)
			 (looking-at ruby-block-op-re)
			 (looking-at ruby-block-mid-re))
		     (progn
		       (goto-char (match-end 0))
		       (looking-at "\\>"))
		   (and (not (eq option 'expr-arg))
			(looking-at "[a-zA-Z][a-zA-z0-9_]* +/[^ \t]")))))))))
d382 6
a387 34
		(and 
		 (or (not (looking-at "do\\>[^_]"))
		     (save-excursion
		       (back-to-indentation)
		       (not (looking-at ruby-non-block-do-re))))
		 (or (bolp)
		     (progn
		       (forward-char -1)
		       (setq w (char-after (point)))
		       (not (or (eq ?_ w)
				(eq ?. w)))))
		 (goto-char pnt)
		 (setq w (char-after (point)))
		 (not (eq ?_ w))
		 (not (eq ?! w))
		 (not (eq ?? w))
		 (skip-chars-forward " \t")
		 (if (not (eolp))
		     (progn
		       (goto-char (match-beginning 0))
		       (if (looking-at ruby-modifier-re)
			   (ruby-expr-beg 'modifier)
			 t))
		   t)
		 (goto-char pnt)
		 (setq nest (cons (cons nil pnt) nest))
		 (setq depth (1+ depth)))
		(goto-char pnt))
	       ((looking-at ruby-block-beg-re)
		(and 
		 (or (not (looking-at "do\\>[^_]"))
		     (save-excursion
		       (back-to-indentation)
		       (not (looking-at ruby-non-block-do-re))))
d400 3
a402 7
		 (if (not (eolp))
		     (progn
		       (goto-char (match-beginning 0))
		       (if (looking-at ruby-modifier-re)
			   (ruby-expr-beg 'modifier)
			 t))
		   t)
d535 2
a536 1
		      (looking-at ruby-block-op-re)
@


1.16
log
@matz
@
text
@d5 1
a5 1
;;;  $Date: 2000/06/12 07:48:31 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.15 $")
d697 4
a700 1
		       ("\\(#\\)[{$@@]" 1 (1 . nil))))
@


1.15
log
@2000-06-12
@
text
@d5 1
a5 1
;;;  $Date: 2000/05/24 04:34:25 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.14 $")
d550 9
a558 6
	    (and (re-search-backward "#" (save-excursion
					   (beginning-of-line)
					   (point)) t)
		 (setq state (ruby-parse-region parse-start (point)))
		 (nth 0 state)
		 (goto-char (nth 0 state)))
@


1.14
log
@2000-05-24
@
text
@d5 1
a5 1
;;;  $Date: 2000/05/01 09:41:42 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.13 $")
d17 1
a17 1
  "class\\|module\\|def\\|if\\|unless\\|case\\|while\\|until\\|for\\|begin"
d21 1
a21 1
  "while\\|until\\|for\\|rescue"
@


1.13
log
@2000-05-01
@
text
@d5 1
a5 1
;;;  $Date: 2000/03/06 04:15:42 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.12 $")
d17 5
a21 1
  "class\\|module\\|def\\|if\\|unless\\|case\\|while\\|until\\|for\\|begin\\|do"
d379 33
d502 1
a502 1
	   ((looking-at "do")		; iter block is a special case
@


1.12
log
@2000-03-06
@
text
@d5 1
a5 1
;;;  $Date: 2000/02/08 08:49:01 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.11 $")
d117 25
d181 3
d281 2
a282 2
		 ((and (not (eobp)) (ruby-expr-beg 'expr-arg))
		  (if (re-search-forward "[^\\]/" indent-point t)
d293 1
d297 1
a297 1
		   ((string= w "[") (setq w "]"))
d300 8
a307 3
		   ((string= w "<") (setq w ">")))
		  (goto-char (match-end 0))
		  (if (search-forward w indent-point t)
@


1.11
log
@2000-02-08
@
text
@d5 1
a5 1
;;;  $Date: 2000/01/18 06:09:04 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.10 $")
d317 3
a319 1
			       (eq ?_ (char-after (point)))))
d344 3
a346 1
		       (not (eq ?_ (char-after (point))))))
d629 1
a629 1
    (if (re-search-forward "^=begin\\s *$" limit t)
d634 1
a634 1
	  (if (re-search-forward "^=end\\s *$" limit t)
d679 1
d682 1
a682 1
	    "\\)\\>[^_]")
d685 1
a685 1
     '("\\(^\\|[^_:.@@$]\\|\\.\\.\\)\\b\\(nil\\|self\\|true\\|false\\)\\b[^_]"
d716 2
a717 2
     ("[^_]\\<\\(begin\\|case\\|else\\|elsif\\|end\\|ensure\\|for\\|if\\|unless\\|rescue\\|then\\|when\\|while\\|until\\|do\\)\\>[^_]" 1 defun)
     ("[^_]\\<\\(and\\|break\\|next\\|raise\\|fail\\|in\\|not\\|or\\|redo\\|retry\\|return\\|super\\|yield\\|catch\\|throw\\|self\\|nil\\)\\>[^_]" 1 keyword)
@


1.10
log
@2000-01-18
@
text
@d5 1
a5 1
;;;  $Date: 2000/01/05 04:37:23 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.9 $")
d692 1
a692 1
     '("^\\s *def\\s *\\([^( ]+\\)"
@


1.9
log
@20000105
@
text
@d5 1
a5 1
;;;  $Date: 1999/12/14 06:49:58 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.8 $")
d182 2
a183 1
	(if (>= shift top) (setq shift (- shift top)))
@


1.8
log
@19991214
@
text
@d5 1
a5 1
;;;  $Date: 1999/11/26 09:07:26 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.7 $")
d192 1
a192 1
(defun ruby-expr-beg (&optional modifier)
d204 2
a205 1
	  (and (not modifier) (looking-at "[!?]"))
d207 2
a208 7
	       (save-restriction
		 (let ((p (point)))
		   (beginning-of-line)
		   (narrow-to-region (point) p)
		   (goto-char p)
		   (forward-word -1)))
	       (if (and (not modifier) (bolp))
d216 2
a217 1
		   (looking-at "[a-zA-Z][a-zA-z0-9_]* +/[^ \t]"))))))))
d252 1
a252 1
		 ((and (not (eobp)) (ruby-expr-beg))
d261 1
a261 1
		 ((and (not (eobp)) (ruby-expr-beg)
d352 1
a352 1
			   (ruby-expr-beg t)
@


1.7
log
@mark_end_proc
@
text
@d5 1
a5 1
;;;  $Date: 1999/10/29 09:25:32 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.6 $")
d206 6
a211 1
	       (forward-word -1)
@


1.6
log
@19991029
@
text
@d5 1
a5 1
;;;  $Date: 1999/10/04 04:51:08 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.5 $")
a665 1
	       "self"
d677 2
a678 2
     '("\\b\\(nil\\|self\\|true\\|false\\)\\b"
       1 font-lock-variable-name-face)
@


1.5
log
@19991004
@
text
@d5 1
a5 1
;;;  $Date: 1999/09/20 07:14:18 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.4 $")
d175 1
a175 2
	(and (< x 0)
	     (error "invalid nest"))
d182 1
a182 6
	(cond
	 ((>= x shift)
	  (setq shift 0))
	 ((>= shift top)
	  (setq shift (- shift top)))
	 (t (setq shift 0)))
@


1.5.2.1
log
@19991025
@
text
@d5 1
a5 1
;;;  $Date: 1999/10/04 04:51:08 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.5 $")
d183 6
a188 1
	(if (>= shift top) (setq shift (- shift top)))
@


1.5.2.2
log
@19991129
@
text
@d5 1
a5 1
;;;  $Date: 1999/10/25 05:09:13 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.5.2.1 $")
d667 1
d679 2
a680 2
     '("\\(^\\|[^_:.@@$]\\|\\.\\.\\)\\b\\(nil\\|self\\|true\\|false\\)\\b[^_]"
       2 font-lock-variable-name-face)
@


1.5.2.3
log
@2000-01-24
@
text
@d5 1
a5 1
;;;  $Date: 1999/11/29 06:31:06 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.5.2.2 $")
d183 1
a183 2
	(if (>= shift top) (setq shift (- shift top))
	  (setq shift 0))
@


1.5.2.4
log
@2000-06-13
@
text
@d5 1
a5 1
;;;  $Date: 2000/05/24 04:34:25 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.14 $")
a19 4
(defconst ruby-non-block-do-re
  "\\(while\\|until\\|for\\|rescue\\)\\>"
  )

a116 25
(eval-when-compile (require 'cl))
(defun ruby-imenu-create-index ()
  (let ((index-alist '())
	class-name class-begin method-name method-begin decl)
    (goto-char (point-min))
    (while (re-search-forward "^\\s *\\(class\\|def\\)\\s *\\([^(\n ]+\\)" nil t)
      (setq decl (buffer-substring (match-beginning 1) (match-end 1)))
      (cond
       ((string= "class" decl)
	(setq class-begin (match-beginning 2))
	(setq class-name (buffer-substring class-begin (match-end 2)))
	(push (cons class-name (match-beginning 0)) index-alist)
	(ruby-mark-defun)
	(save-restriction
	  (narrow-to-region (region-beginning) (region-end))
	  (while (re-search-forward "^\\s *def\\s *\\([^(\n ]+\\)" nil t)
	    (setq method-begin (match-beginning 1))
	    (setq method-name (buffer-substring method-begin (match-end 1)))
	    (push (cons (concat class-name "#" method-name) (match-beginning 0)) index-alist))))
       ((string= "def" decl)
	(setq method-begin (match-beginning 2))
	(setq method-name (buffer-substring method-begin (match-end 2)))
	(push (cons method-name (match-beginning 0)) index-alist))))
    index-alist))

a155 3
  (make-local-variable 'imenu-create-index-function)
  (setq imenu-create-index-function 'ruby-imenu-create-index)

d175 2
a176 1
	(and (< x 0) (error "invalid nest"))
d194 1
a194 1
(defun ruby-expr-beg (&optional option)
d206 1
a206 2
	  (and (not (eq option 'modifier))
	       (looking-at "[!?]"))
d208 2
a209 2
	       (skip-chars-backward ruby-symbol-chars)
	       (if (and (not (eq option 'modifier)) (bolp))
d217 1
a217 2
		   (and (not (eq option 'expr-arg))
			(looking-at "[a-zA-Z][a-zA-z0-9_]* +/[^ \t]")))))))))
d253 1
a253 1
		  (if (re-search-forward "[^\\]\\(\\\\\\\\\\)*/" indent-point t)
d261 1
a261 1
		 ((and (not (eobp)) (ruby-expr-beg 'expr-arg)
a263 1
		  (goto-char (match-beginning 1))
d267 1
a267 1
		   ((string= w "[") (setq w "\\]"))
d270 3
a272 8
		   ((string= w "<") (setq w ">"))
		   ((member w '("*" "." "+" "?" "^" "$"))
		    (setq w (concat "\\" w))))
		  (if (re-search-forward
		       (if (string= w "\\")
			   "\\\\[^\\]*\\\\"
			 (concat "[^\\]\\(\\\\\\\\\\)*" w))
		       indent-point t)
d316 1
a316 3
			       (setq w (char-after (point)))
			       (or (eq ?_ w)
				   (eq ?. w))))
a337 33
		 (or (not (looking-at "do\\>[^_]"))
		     (save-excursion
		       (back-to-indentation)
		       (not (looking-at ruby-non-block-do-re))))
		 (or (bolp)
		     (progn
		       (forward-char -1)
		       (setq w (char-after (point)))
		       (not (or (eq ?_ w)
				(eq ?. w)))))
		 (goto-char pnt)
		 (setq w (char-after (point)))
		 (not (eq ?_ w))
		 (not (eq ?! w))
		 (not (eq ?? w))
		 (skip-chars-forward " \t")
		 (if (not (eolp))
		     (progn
		       (goto-char (match-beginning 0))
		       (if (looking-at ruby-modifier-re)
			   (ruby-expr-beg 'modifier)
			 t))
		   t)
		 (goto-char pnt)
		 (setq nest (cons (cons nil pnt) nest))
		 (setq depth (1+ depth)))
		(goto-char pnt))
	       ((looking-at ruby-block-beg-re)
		(and 
		 (or (not (looking-at "do\\>[^_]"))
		     (save-excursion
		       (back-to-indentation)
		       (not (looking-at ruby-non-block-do-re))))
d341 1
a341 3
		       (setq w (char-after (point)))
		       (not (or (eq ?_ w)
				(eq ?. w)))))
d352 1
a352 1
			   (ruby-expr-beg 'modifier)
d426 1
a426 1
	   ((looking-at "do\\>[^_]")	; iter block is a special case
d624 1
a624 1
    (if (re-search-forward "^=begin\\(\\s \\|$\\)" limit t)
d629 1
a629 1
	  (if (re-search-forward "^=end\\(\\s \\|$\\)" limit t)
a673 1
	       "yield"
d676 1
a676 1
	    "\\)\\>\\([^_]\\|$\\)")
d679 1
a679 1
     '("\\(^\\|[^_:.@@$]\\|\\.\\.\\)\\b\\(nil\\|self\\|true\\|false\\)\\b\\([^_]\\|$\\)"
d691 1
a691 1
     '("^\\s *def\\s +\\([^( ]+\\)"
d710 2
a711 2
     ("[^_]\\<\\(begin\\|case\\|else\\|elsif\\|end\\|ensure\\|for\\|if\\|unless\\|rescue\\|then\\|when\\|while\\|until\\|do\\|yield\\)\\>\\([^_]\\|$\\)" 1 defun)
     ("[^_]\\<\\(and\\|break\\|next\\|raise\\|fail\\|in\\|not\\|or\\|redo\\|retry\\|return\\|super\\|yield\\|catch\\|throw\\|self\\|nil\\)\\>\\([^_]\\|$\\)" 1 keyword)
@


1.5.2.5
log
@matz
@
text
@d5 1
a5 1
;;;  $Date: 2000/06/13 09:51:02 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.5.2.4 $")
d550 6
a555 9
	    (let ((pos (point)))
	      (and 
	       (re-search-backward "#" (save-excursion
					 (beginning-of-line)
					 (point)) t)
	       (skip-chars-backward " \t")
	       (setq state (ruby-parse-region parse-start (point)))
	       (nth 0 state)
	       (goto-char pos)))
@


1.4
log
@19990920
@
text
@d5 1
a5 1
;;;  $Date: 1999/08/24 08:21:56 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.3 $")
d579 1
d581 2
a583 4
  (newline)
  (save-excursion
    (forward-line -1)
    (indent-according-to-mode))
@


1.3
log
@1.4.1 to be
@
text
@d5 1
a5 1
;;;  $Date: 1999/08/13 05:45:18 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.2 $")
d50 1
a50 1
(defconst ruby-operator-chars ",.+*/%-&|^~=<>:")
@


1.2
log
@1.4.0
@
text
@d5 1
a5 1
;;;  $Date: 1999/08/06 06:48:24 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.1.2.9 $")
d697 2
a698 2
     '("^\\s *def\\s *\\<\\(\\(\\w\\|_\\)+\\(\\.\\|::\\)\\)?\\(\\(\\w\\|_\\)+\\??\\)\\>"
       4 font-lock-function-name-face t)
@


1.1
log
@file ruby-mode.el was initially added on branch v1_1dev.
@
text
@d1 724
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@a0 699
;;;
;;;  ruby-mode.el -
;;;
;;;  $Author: matz $
;;;  $Date: 1998/12/16 07:30:36 $
;;;  created at: Fri Feb  4 14:49:13 JST 1994
;;;

(defconst ruby-mode-revision "$Revision: 1.1.2.1 $")

(defconst ruby-mode-version
  (progn
   (string-match "[0-9.]+" ruby-mode-revision)
   (substring ruby-mode-revision (match-beginning 0) (match-end 0))))

(defconst ruby-block-beg-re
  "class\\|module\\|def\\|if\\|unless\\|case\\|while\\|until\\|for\\|begin\\|do"
  )

(defconst ruby-indent-beg-re
  "\\(\\s *\\(class\\|module\\|def\\)\\)\\|if\\|unless\\|case\\|while\\|until\\|for\\|begin"
    )

(defconst ruby-modifier-re
  "if\\|unless\\|while\\|until"
  )

(defconst ruby-block-mid-re
  "then\\|else\\|elsif\\|when\\|rescue\\|ensure"
  )

(defconst ruby-block-op-re
  "and\\|or\\|not"
  )

(defconst ruby-block-end-re "end")

(defconst ruby-delimiter
  (concat "[?$/%(){}#\"'`.:]\\|\\[\\|\\]\\|\\<\\("
	  ruby-block-beg-re
	  "\\|" ruby-block-end-re
	  "\\)\\>\\|^=begin")
  )

(defconst ruby-negative
  (concat "^[ \t]*\\(\\(" ruby-block-mid-re "\\)\\>\\|\\("
	    ruby-block-end-re "\\)\\>\\|\\}\\|\\]\\)")
  )

(defconst ruby-operator-chars ",.+*/%-&|^~=<>:")
(defconst ruby-operator-re (concat "[" ruby-operator-chars "]"))

(defconst ruby-symbol-chars "a-zA-Z0-9_")
(defconst ruby-symbol-re (concat "[" ruby-symbol-chars "]"))

(defvar ruby-mode-abbrev-table nil
  "Abbrev table in use in ruby-mode buffers.")

(define-abbrev-table 'ruby-mode-abbrev-table ())

(defvar ruby-mode-map nil "Keymap used in ruby mode.")

(if ruby-mode-map
    nil
  (setq ruby-mode-map (make-sparse-keymap))
  (define-key ruby-mode-map "{" 'ruby-electric-brace)
  (define-key ruby-mode-map "}" 'ruby-electric-brace)
  (define-key ruby-mode-map "\e\C-a" 'ruby-beginning-of-defun)
  (define-key ruby-mode-map "\e\C-e" 'ruby-end-of-defun)
  (define-key ruby-mode-map "\e\C-b" 'ruby-beginning-of-block)
  (define-key ruby-mode-map "\e\C-f" 'ruby-end-of-block)
  (define-key ruby-mode-map "\e\C-p" 'ruby-beginning-of-block)
  (define-key ruby-mode-map "\e\C-n" 'ruby-end-of-block)
  (define-key ruby-mode-map "\e\C-h" 'ruby-mark-defun)
  (define-key ruby-mode-map "\t" 'ruby-indent-command)
  (define-key ruby-mode-map "\C-c\C-e" 'ruby-insert-end)
  (define-key ruby-mode-map "\C-j" 'ruby-reindent-then-newline-and-indent)
  (define-key ruby-mode-map "\C-m" 'newline))

(defvar ruby-mode-syntax-table nil
  "Syntax table in use in ruby-mode buffers.")

(if ruby-mode-syntax-table
    ()
  (setq ruby-mode-syntax-table (make-syntax-table))
  (modify-syntax-entry ?\' "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?\" "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?\` "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?# "<" ruby-mode-syntax-table)
  (modify-syntax-entry ?\n ">" ruby-mode-syntax-table)
  (modify-syntax-entry ?\\ "\\" ruby-mode-syntax-table)
  (modify-syntax-entry ?$ "/" ruby-mode-syntax-table)
  (modify-syntax-entry ?? "_" ruby-mode-syntax-table)
  (modify-syntax-entry ?_ "_" ruby-mode-syntax-table)
  (modify-syntax-entry ?< "." ruby-mode-syntax-table)
  (modify-syntax-entry ?> "." ruby-mode-syntax-table)
  (modify-syntax-entry ?& "." ruby-mode-syntax-table)
  (modify-syntax-entry ?| "." ruby-mode-syntax-table)
  (modify-syntax-entry ?% "." ruby-mode-syntax-table)
  (modify-syntax-entry ?= "." ruby-mode-syntax-table)
  (modify-syntax-entry ?/ "." ruby-mode-syntax-table)
  (modify-syntax-entry ?+ "." ruby-mode-syntax-table)
  (modify-syntax-entry ?* "." ruby-mode-syntax-table)
  (modify-syntax-entry ?- "." ruby-mode-syntax-table)
  (modify-syntax-entry ?\; "." ruby-mode-syntax-table)
  (modify-syntax-entry ?\( "()" ruby-mode-syntax-table)
  (modify-syntax-entry ?\) ")(" ruby-mode-syntax-table)
  (modify-syntax-entry ?\{ "(}" ruby-mode-syntax-table)
  (modify-syntax-entry ?\} "){" ruby-mode-syntax-table)
  (modify-syntax-entry ?\[ "(]" ruby-mode-syntax-table)
  (modify-syntax-entry ?\] ")[" ruby-mode-syntax-table)
  )

(defvar ruby-indent-level 2
  "*Indentation of ruby statements.")

(defun ruby-mode-variables ()
  (set-syntax-table ruby-mode-syntax-table)
  (setq local-abbrev-table ruby-mode-abbrev-table)
  (make-local-variable 'indent-line-function)
  (setq indent-line-function 'ruby-indent-line)
  (make-local-variable 'require-final-newline)
  (setq require-final-newline t)
  (make-variable-buffer-local 'comment-start)
  (setq comment-start "# ")
  (make-variable-buffer-local 'comment-end)
  (setq comment-end "")
  (make-variable-buffer-local 'comment-column)
  (setq comment-column 32)
  (make-variable-buffer-local 'comment-start-skip)
  (setq comment-start-skip "\\(^\\|\\s-\\);?#+ *")
  (make-local-variable 'parse-sexp-ignore-comments)
  (setq parse-sexp-ignore-comments t)
  (make-local-variable 'paragraph-start)
  (setq paragraph-start (concat "$\\|" page-delimiter))
  (make-local-variable 'paragraph-separate)
  (setq paragraph-separate paragraph-start)
  (make-local-variable 'paragraph-ignore-fill-prefix)
  (setq paragraph-ignore-fill-prefix t))

(defun ruby-mode ()
  "Major mode for editing ruby scripts.
\\[ruby-indent-command] properly indents subexpressions of multi-line
class, module, def, if, while, for, do, and case statements, taking
nesting into account.

The variable ruby-indent-level controls the amount of indentation.
\\{ruby-mode-map}"
  (interactive)
  (kill-all-local-variables)
  (use-local-map ruby-mode-map)
  (setq mode-name "Ruby")
  (setq major-mode 'ruby-mode)
  (ruby-mode-variables)
  (run-hooks 'ruby-mode-hook))

(defun ruby-current-indentation ()
  (save-excursion
    (beginning-of-line)
    (back-to-indentation)
    (current-column)))

(defun ruby-indent-line (&optional flag)
  "Correct indentation of the current ruby line."
  (ruby-indent-to (ruby-calculate-indent)))

(defun ruby-indent-command ()
  (interactive)
  (ruby-indent-line t))

(defun ruby-indent-to (x)
  (if x
      (let (shift top beg)
	(and (< x 0)
	     (error "invalid nest"))
	(setq shift (current-column))
	(beginning-of-line)
	(setq beg (point))
	(back-to-indentation)
	(setq top (current-column))
	(skip-chars-backward " \t")
	(cond
	 ((>= x shift)
	  (setq shift 0))
	 ((>= shift top)
	  (setq shift (- shift top)))
	 (t (setq shift 0)))
	(if (and (bolp)
		 (= x top))
	    (move-to-column (+ x shift))
	  (move-to-column top)
	  (delete-region beg (point))
	  (beginning-of-line)
	  (indent-to x)
	  (move-to-column (+ x shift))))))

(defun ruby-expr-beg (&optional modifier pnt)
  (save-excursion
    (if (looking-at "\\?")
	(progn
	  (or (bolp) (forward-char -1))
	  (not (looking-at "\\sw")))
      (store-match-data nil)
      (skip-chars-backward " \t")
      (or (bolp) (forward-char -1))
      (or (bolp)
	  (looking-at ruby-operator-re)
	  (looking-at "[\\[({]")
	  (and (not modifier) (looking-at "[!?]"))
	  (and (looking-at ruby-symbol-re)
	       (forward-word -1)
	       (if (and (not modifier) (bolp))
		   t
		 (if (or (looking-at ruby-block-beg-re)
			 (looking-at ruby-block-op-re)
			 (looking-at ruby-block-mid-re))
		     (progn
		       (goto-char (match-end 0))
		       (looking-at "\\>")))))))))

(defun ruby-parse-region (start end)
  (let ((indent-point end)
	  (indent 0)
	  (in-string nil)
	  (in-paren nil)
	  (depth 0)
	  (nest nil)
	  (pcol nil))
    (save-excursion
	(if start
	    (goto-char start)
	  (ruby-beginning-of-indent))
	(save-restriction
	  (narrow-to-region (point) end)
	  (while (and (> indent-point (point))
		      (re-search-forward ruby-delimiter indent-point t))
	    (let ((pnt (point)) w)
	      (goto-char (match-beginning 0))
	      (cond
	       ((or (looking-at "\"")	;skip string
		    (looking-at "'")
		    (looking-at "`"))
		(setq w (char-after (point)))
		(cond
		 ((and (not (eobp))
		       (re-search-forward (format "[^\\]\\(\\\\\\\\\\)*%c" w) indent-point t))
		  nil)
		 (t
		  (setq in-string (point))
		  (goto-char indent-point))))
	       ((looking-at "/")
		(cond
		 ((and (not (eobp)) (ruby-expr-beg))
		  (if (re-search-forward "[^\\]/" indent-point t)
		      nil
		    (setq in-string (point))
		    (goto-char indent-point)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "%")
		(cond
		 ((and (not (eobp)) (ruby-expr-beg)
		       (looking-at "%[Qqrxw]?\\(.\\)"))
		  (setq w (buffer-substring (match-beginning 1)
					    (match-end 1)))
		  (cond
		   ((string= w "[") (setq w "]"))
		   ((string= w "{") (setq w "}"))
		   ((string= w "(") (setq w ")"))
		   ((string= w "<") (setq w ">")))
		  (goto-char (match-end 0))
		  (if (search-forward w indent-point t)
		      nil
		    (setq in-string (point))
		    (goto-char indent-point)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "\\?")	;skip ?char
		(cond
		 ((ruby-expr-beg)
		  (looking-at "?\\(\\\\C-\\|\\\\M-\\)*.")
		  (goto-char (match-end 0)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "\\$")	;skip $char
		(goto-char pnt)
		(forward-char 1))
	       ((looking-at "#")	;skip comment
		(forward-line 1)
		(goto-char (point))
		)
	       ((looking-at "(")
		(setq nest (cons (cons (char-after (point)) pnt) nest))
		(setq pcol (cons (cons pnt depth) pcol))
		(setq depth 0)
		(goto-char pnt)
		)
	       ((looking-at "[\\[{]")
		(setq nest (cons (cons (char-after (point)) pnt) nest))
		(setq depth (1+ depth))
		(goto-char pnt)
		)
	       ((looking-at ")")
		(setq nest (cdr nest))
		(setq depth (cdr (car pcol)))
		(setq pcol (cdr pcol))
		(goto-char pnt))
	       ((looking-at "[])}]")
		(setq nest (cdr nest))
		(setq depth (1- depth))
		(goto-char pnt))
	       ((looking-at ruby-block-end-re)
		(if (or (and (not (bolp))
			     (progn
			       (forward-char -1)
			       (eq ?_ (char-after (point)))))
			(progn
			  (goto-char pnt)
			  (setq w (char-after (point)))
			  (or (eq ?_ w)
			      (eq ?! w)
			      (eq ?? w))))
		    nil
		  (setq nest (cdr nest))
		  (setq depth (1- depth)))
		(goto-char pnt))
	       ((looking-at "def\\s +[^(\n;]*")
		(if (or (bolp)
			(progn
			  (forward-char -1)
			  (not (eq ?_ (char-after (point))))))
		    (progn
		      (setq nest (cons (cons nil pnt) nest))
		      (setq depth (1+ depth))))
		(goto-char (match-end 0)))
	       ((looking-at ruby-block-beg-re)
		(and 
		 (or (bolp)
		     (progn
		       (forward-char -1)
		       (not (eq ?_ (char-after (point))))))
		 (goto-char pnt)
		 (setq w (char-after (point)))
		 (not (eq ?_ w))
		 (not (eq ?! w))
		 (not (eq ?? w))
		 (skip-chars-forward " \t")
		 (if (not (eolp))
		     (progn
		       (goto-char (match-beginning 0))
		       (if (looking-at ruby-modifier-re)
			   (ruby-expr-beg t)
			 t))
		   t)
		 (goto-char pnt)
		 (setq nest (cons (cons nil pnt) nest))
		 (setq depth (1+ depth)))
		(goto-char pnt))
	       ((looking-at ":\\([a-zA-Z_][a-zA-Z_0-9]*\\)?")
		(goto-char (match-end 0)))
	       ((or (looking-at "\\.")
		    (looking-at "\\.\\.\\.?")
		    (looking-at "\\.[0-9]+")
		    (looking-at "\\.[a-zA-Z_0-9]+"))
		(goto-char (match-end 0)))
	       ((looking-at "^=begin")
		(if (re-search-forward "^=end" indent-point t)
		    (forward-line 1)
		  (setq in-string (match-end 0))
		  (goto-char indent-point)))
	       (t
		(error (format "bad string %s"
			       (buffer-substring (point) pnt)
			       )))))))
	(list in-string (car nest) depth (car (car pcol))))))

(defun ruby-indent-size (pos nest)
  (+ pos (* (if nest nest 1) ruby-indent-level)))

(defun ruby-calculate-indent (&optional parse-start)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
	    (case-fold-search nil)
	    state bol eol
	    (indent 0))
	(if parse-start
	    (goto-char parse-start)
	  (ruby-beginning-of-indent)
	  (setq parse-start (point)))
	(back-to-indentation)
	(setq indent (current-column))
	(setq state (ruby-parse-region parse-start indent-point))
	(cond
	 ((nth 0 state)			; within string
	  (setq indent nil))		;  do nothing

	 ((car (nth 1 state))		; in paren
	  (goto-char (cdr (nth 1 state)))
	  (if (eq (car (nth 1 state)) ?\( )
	      (let ((column (current-column))
		    (s (ruby-parse-region (point) indent-point)))
		(cond
		 ((and (nth 2 s) (> (nth 2 s) 0))
		  (goto-char (cdr (nth 1 s)))
		  (forward-word -1)
		  (setq indent (ruby-indent-size (current-column) (nth 2 state))))
		 (t 
		  (setq indent (current-column)))))
	    (cond
	     ((nth 3 state)
	      (goto-char (nth 3 state))
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))
	     (t
	      (goto-char parse-start)
	      (back-to-indentation)
	      (setq indent (ruby-indent-size (current-column) (nth 2 state)))))
	    ))
	  
	 ((and (nth 2 state)(> (nth 2 state) 0)) ; in nest
	  (if (null (cdr (nth 1 state)))
	      (error "invalid nest"))
	  (goto-char (cdr (nth 1 state)))
	  (forward-word -1)		; skip back a keyword
	  (cond
	   ((looking-at "do")		; iter block is a special case
	    (cond
	     ((nth 3 state)
	      (goto-char (nth 3 state))
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))
	     (t
	      (goto-char parse-start)
	      (back-to-indentation)
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))))
	   (t
	    (setq indent (+ (current-column) ruby-indent-level)))))

	 ((and (nth 2 state) (< (nth 2 state) 0)) ; in negative nest
	  (setq indent (ruby-indent-size (current-column) (nth 2 state)))))
	 
	(cond
	 (indent
	  (goto-char indent-point)
	  (end-of-line)
	  (setq eol (point))
	  (beginning-of-line)
	  (cond 
	   ((re-search-forward ruby-negative eol t)
	    (and (not (eq ?_ (char-after (match-end 0))))
		 (setq indent (- indent ruby-indent-level))))
	   ;;operator terminated lines
	   ((and
	     (save-excursion
	       (beginning-of-line)
	       (not (bobp)))
	     (or (null (car (nth 1 state))) ;not in parens
		 (and (eq (car (nth 1 state)) ?\{)
		      (save-excursion	;except non-block braces
			(goto-char (cdr (nth 1 state)))
			(or (bobp) (forward-char -1))
			(not (ruby-expr-beg))))))
	    ;; goto beginning of non-empty no-comment line
	    (let (end done)
	      (while (not done)
		(skip-chars-backward " \t\n")
		(setq end (point))
		(beginning-of-line)
		(if (re-search-forward "^\\s *#" end t)
		    (beginning-of-line)
		  (setq done t))))
	    (setq bol (point))
	    (end-of-line)
	    (skip-chars-backward " \t")
	    (and (re-search-backward "#" (save-excursion
					   (beginning-of-line)
					   (point)) t)
		 (setq state (ruby-parse-region parse-start (point)))
		 (nth 0 state)
		 (goto-char (nth 0 state)))
	    (or (bobp) (forward-char -1))
	    (and
	     (or (and (looking-at ruby-symbol-re)
		      (skip-chars-backward ruby-symbol-chars)
		      (looking-at ruby-block-op-re)
		      (save-excursion
			(goto-char (match-end 0))
			(not (looking-at "[a-z_]"))))
		 (and (looking-at ruby-operator-re)
		      (or (not (eq ?/ (char-after (point))))
			  (null (nth 0 (ruby-parse-region parse-start (point)))))
		      (not (eq (char-after (1- (point))) ?$))
		      (or (not (eq ?| (char-after (point))))
			  (save-excursion
			    (or (eolp) (forward-char -1))
			    (and (search-backward "|")
				 (skip-chars-backward " \t\n")
				 (and (not (eolp))
				      (progn
					(forward-char -1)
					(not (looking-at "\\{")))
				      (progn
					(forward-word -1)
					(not (looking-at "do\\>[^_]")))))))))
	     (setq indent (+ indent ruby-indent-level)))))))
	indent)))
 
(defun ruby-electric-brace (arg)
  (interactive "P")
  (self-insert-command (prefix-numeric-value arg))
  (ruby-indent-line t))

(defun ruby-beginning-of-defun (&optional arg)
  "Move backward to next beginning-of-defun.
With argument, do this that many times.
Returns t unless search stops due to end of buffer."
  (interactive "p")
  (and (re-search-backward (concat "^\\(" ruby-block-beg-re "\\)\\b")
			   nil 'move (or arg 1))
       (progn (beginning-of-line) t)))

(defun ruby-beginning-of-indent ()
  (and (re-search-backward (concat "^\\(" ruby-indent-beg-re "\\)\\b")
			   nil 'move)
       (progn
	 (beginning-of-line)
	 t)))

(defun ruby-end-of-defun (&optional arg)
  "Move forward to next end of defun.
An end of a defun is found by moving forward from the beginning of one."
  (interactive "p")
  (and (re-search-forward (concat "^\\(" ruby-block-end-re "\\)\\($\\|\\b[^_]\\)")
			  nil 'move (or arg 1))
       (progn (beginning-of-line) t))
  (forward-line 1))

(defun ruby-move-to-block (n)
  (let (start pos done down)
    (setq start (ruby-calculate-indent))
    (if (eobp)
	nil
      (while (and (not (bobp)) (not done))
	(forward-line n)
	(cond
	 ((looking-at "^$"))
	 ((looking-at "^\\s *#"))
	 (t
	  (setq pos (current-indentation))
	  (cond
	   ((< start pos)
	    (setq down t))
	   ((and down (= pos start))
	    (setq done t))
	   ((> start pos)
	    (setq done t)))))
	(if done
	    (progn
	      (back-to-indentation)
	      (if (looking-at ruby-block-mid-re)
		  (setq done nil)))))))
  (back-to-indentation))

(defun ruby-beginning-of-block ()
  "Move backward to next beginning-of-block"
  (interactive)
  (ruby-move-to-block -1))

(defun ruby-end-of-block ()
  "Move forward to next beginning-of-block"
  (interactive)
  (ruby-move-to-block 1))

(defun ruby-reindent-then-newline-and-indent ()
  (interactive "*")
  (save-excursion
    (delete-region (point) (progn (skip-chars-backward " \t") (point))))
  (newline)
  (save-excursion
    (forward-line -1)
    (indent-according-to-mode))
  (indent-according-to-mode))

(fset 'ruby-encomment-region (symbol-function 'comment-region))

(defun ruby-decomment-region (beg end)
  (interactive "r")
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "^\\([ \t]*\\)#" end t)
      (replace-match "\\1" nil nil)
      (save-excursion
	(ruby-indent-line)))))

(defun ruby-insert-end ()
  (interactive)
  (insert "end")
  (ruby-indent-line t)
  (end-of-line))

(defun ruby-mark-defun ()
  "Put mark at end of this Ruby function, point at beginning."
  (interactive)
  (push-mark (point))
  (ruby-end-of-defun)
  (push-mark (point) nil t)
  (ruby-beginning-of-defun)
  (re-search-backward "^\n" (- (point) 1) t))

(cond
 ((featurep 'hilit19)
  (hilit-set-mode-patterns
   'ruby-mode
   '(("[^$\\?]\\(\"[^\\\"]*\\(\\\\\\(.\\|\n\\)[^\\\"]*\\)*\"\\)" 1 string)
     ("[^$\\?]\\('[^\\']*\\(\\\\\\(.\\|\n\\)[^\\']*\\)*'\\)" 1 string)
     ("[^$\\?]\\(`[^\\`]*\\(\\\\\\(.\\|\n\\)[^\\`]*\\)*`\\)" 1 string)
     ("^\\s *#.*$" nil comment)
     ("[^$@@?\\]\\(#[^$@@{\n].*$\\)" 1 comment)
     ("[^a-zA-Z_]\\(\\?\\(\\\\[CM]-\\)*.\\)" 1 string)
     ("^\\s *\\(require\\|load\\).*$" nil include)
     ("^\\s *\\(include\\|alias\\|undef\\).*$" nil decl)
     ("^\\s *\\<\\(class\\|def\\|module\\)\\>" "[)\n;]" defun)
     ("[^_]\\<\\(begin\\|case\\|else\\|elsif\\|end\\|ensure\\|for\\|if\\|unless\\|rescue\\|then\\|when\\|while\\|until\\|do\\)\\>[^_]" 1 defun)
     ("[^_]\\<\\(and\\|break\\|next\\|raise\\|fail\\|in\\|not\\|or\\|redo\\|retry\\|return\\|super\\|yield\\|self\\|nil\\)\\>[^_]" 1 keyword)
     ("\\$\\(.\\|\\sw+\\)" nil type)
     ("[$@@].[a-zA-Z_0-9]*" nil struct)
     ("^__END__" nil label))))

 ((featurep 'font-lock)
  (or (boundp 'font-lock-variable-name-face)
      (setq font-lock-variable-name-face font-lock-type-face))
  (defvar ruby-font-lock-keywords
    (list
     (cons (concat
	    "\\(^\\|[^_:.]\\|\\.\\.\\)\\b\\("
	    (mapconcat
	     'identity
	     '("alias"
	       "and"
	       "begin"
	       "break"
	       "case"
	       "class"
	       "def"
	       "do"
	       "elsif"
	       "else"
	       "fail"
	       "ensure"
	       "for"
	       "end"
	       "if"
	       "in"
	       "module"
	       "next"
	       "not"
	       "or"
	       "raise"
	       "redo"
	       "rescue"
	       "retry"
	       "return"
	       "then"
	       "self"
	       "super"
	       "unless"
	       "undef"
	       "until"
	       "when"
	       "while"
	       )
	     "\\|")
	    "\\)\\b")
	   2)
     ;; variables
     '("\\b\\(nil\\|self\\|true\\|false\\)\\b"
       1 font-lock-variable-name-face)
     ;; variables
     '("[$@@].[a-zA-Z0-9_]*"
       0 font-lock-variable-name-face)
     ;; constants
     '("\\(^\\|[^_]\\)\\b\\([A-Z]+[a-zA-Z0-9_]*\\)"
       2 font-lock-type-face)
     ;; functions
     '("^\\s *def\\s *\\<\\(\\(\\w\\|\\s_\\)+\\.\\)?\\(\\(\\w\\|\\s_\\)+\\)\\>"
       3 font-lock-function-name-face t))
    "*Additional expressions to highlight in ruby mode.")
  (if (and (>= (string-to-int emacs-version) 19)
          (not (featurep 'xemacs)))
      (add-hook
       'ruby-mode-hook
       (lambda ()
        (make-local-variable 'font-lock-defaults)
        (setq font-lock-defaults 
              '((ruby-font-lock-keywords) nil nil ((?\_ . "w"))))))
    (add-hook 'ruby-mode-hook
             (lambda ()
               (setq font-lock-keywords ruby-font-lock-keywords))))))

(provide 'ruby-mode)
@


1.1.1.1.2.1
log
@990224
@
text
@d5 1
a5 1
;;;  $Date: 1999/01/20 04:59:36 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.1 $")
d92 1
a92 1
  (modify-syntax-entry ?$ "." ruby-mode-syntax-table)
d197 1
a197 1
(defun ruby-expr-beg (&optional modifier)
d219 1
a219 2
		       (looking-at "\\>"))
		   (looking-at "[a-zA-Z][a-zA-z0-9_]* /[^ \t]"))))))))
a251 1
		(echo "here %s" (ruby-expr-beg))
a691 4
        (make-local-variable 'font-lock-syntactic-keywords)
	(setq font-lock-syntactic-keywords
	      '(("\\$\\([#\"'$\\]\\)" 1 (1 . nil))
                ("\\(#\\)[{$@@]" 1 (1 . nil))))
d694 1
a694 1
              '((ruby-font-lock-keywords) nil nil ((?\_ . "w") (?$ . "/"))))))
@


1.1.1.1.2.2
log
@990225
@
text
@d220 1
a220 1
		   (looking-at "[a-zA-Z][a-zA-z0-9_]* +/[^ \t]"))))))))
d253 1
d689 15
a703 10
  (add-hook
   'ruby-mode-hook
   (lambda ()
     (make-local-variable 'font-lock-syntactic-keywords)
     (setq font-lock-syntactic-keywords
	   '(("\\$\\([#\"'$\\]\\)" 1 (1 . nil))
	     ("\\(#\\)[{$@@]" 1 (1 . nil))))
     (make-local-variable 'font-lock-defaults)
     (setq font-lock-defaults '((ruby-font-lock-keywords) nil nil))
     (setq font-lock-keywords ruby-font-lock-keywords)))))
@


1.1.1.1.2.3
log
@990324
@
text
@d5 1
a5 1
;;;  $Date: 1999/02/25 06:39:12 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.1.2.2 $")
a263 1
		       (not (looking-at "%="))
@


1.1.1.1.2.4
log
@--with-xxx=yyy
@
text
@d5 1
a5 1
;;;  $Date: 1999/03/24 08:52:35 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.1.2.3 $")
d694 1
a694 1
	   '(("\\$\\([#\"'`$\\]\\)" 1 (1 . nil))
@


1.1.1.1.2.5
log
@regexp null pattern
@
text
@d5 1
a5 1
;;;  $Date: 1999/04/27 05:11:13 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.1.2.4 $")
a237 1
	    (or depth (setq depth 0))
@


1.1.1.1.2.6
log
@thread bugs
@
text
@d5 1
a5 1
;;;  $Date: 1999/05/25 08:26:20 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.1.2.5 $")
a154 9
  ;; for font-lock
  (make-local-variable 'font-lock-syntactic-keywords)
  (setq font-lock-syntactic-keywords
	'(("\\$\\([#\"'`$\\]\\)" 1 (1 . nil))
	  ("\\(#\\)[{$@@]" 1 (1 . nil))))
  (make-local-variable 'font-lock-defaults)
  (setq font-lock-defaults '((ruby-font-lock-keywords) nil nil))
  (setq font-lock-keywords ruby-font-lock-keywords)

d630 2
a631 1
 )
d690 10
@


1.1.1.1.2.7
log
@990624
@
text
@d5 1
a5 1
;;;  $Date: 1999/06/09 09:21:36 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.1.2.6 $")
d635 1
a635 1
     ("[^_]\\<\\(and\\|break\\|next\\|raise\\|fail\\|in\\|not\\|or\\|redo\\|retry\\|return\\|super\\|yield\\|catch\\|throw\\|self\\|nil\\)\\>[^_]" 1 keyword)
d640 6
a645 19

(or (boundp 'font-lock-variable-name-face)
    (setq font-lock-variable-name-face font-lock-type-face))

(defun ruby-font-lock-docs (limit)
  (if (re-search-forward "^=begin\\s *" limit t)
      (let (beg)
	(beginning-of-line)
	(setq beg (point))
	(forward-line 1)
	(if (re-search-forward "^=end\\s *" limit t)
	    (progn
	      (set-match-data (list beg (point)))
	      t)))))

(defvar ruby-font-lock-keywords
  (list
   (cons (concat
	  "\\(^\\|[^_:.]\\|\\.\\.\\)\\b\\("
a652 1
	       "catch"
a673 1
	       "throw"
d684 14
a697 20
	 2)
   ;; variables
   '("\\b\\(nil\\|self\\|true\\|false\\)\\b"
     1 font-lock-variable-name-face)
   ;; variables
   '("[$@@].\\(\\w\\|_\\)*"
     0 font-lock-variable-name-face)
   ;; embedded document
   '(ruby-font-lock-docs
     0 font-lock-comment-face t)
   ;; constants
   '("\\(^\\|[^_]\\)\\b\\([A-Z]+\\(\\w\\|_\\)*\\)"
     2 font-lock-type-face)
   ;; functions
   '("^\\s *def\\s *\\<\\(\\(\\w\\|_\\)+\\(\\.\\|::\\)\\)?\\(\\(\\w\\|_\\)+\\??\\)\\>"
     4 font-lock-function-name-face t)
   ;; symbols
   '("\\(^\\|[^:]\\)\\(:\\(\\w\\|_\\)+\\??\\)\\b"
     2 font-lock-reference-face t))
  "*Additional expressions to highlight in ruby mode.")
@


1.1.1.1.2.8
log
@do not depend on font-lock.
@
text
@d5 1
a5 1
;;;  $Date: 1999/06/24 04:24:08 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.1.2.7 $")
d155 8
d622 37
a658 29
 ((featurep 'font-lock)
  (or (boundp 'font-lock-variable-name-face)
      (setq font-lock-variable-name-face font-lock-type-face))

  (add-hook 'ruby-mode-hook
	    '(lambda ()
	       (make-local-variable 'font-lock-syntactic-keywords)
	       (setq font-lock-syntactic-keywords
		     '(("\\$\\([#\"'`$\\]\\)" 1 (1 . nil))
		       ("\\(#\\)[{$@@]" 1 (1 . nil))))
	       (make-local-variable 'font-lock-defaults)
	       (setq font-lock-defaults '((ruby-font-lock-keywords) nil nil))
	       (setq font-lock-keywords ruby-font-lock-keywords)))

  (defun ruby-font-lock-docs (limit)
    (if (re-search-forward "^=begin\\s *$" limit t)
	(let (beg)
	  (beginning-of-line)
	  (setq beg (point))
	  (forward-line 1)
	  (if (re-search-forward "^=end\\s *$" limit t)
	      (progn
		(set-match-data (list beg (point)))
		t)))))

  (defvar ruby-font-lock-keywords
    (list
     (cons (concat
	    "\\(^\\|[^_:.]\\|\\.\\.\\)\\b\\("
d699 20
a718 40
	   2)
     ;; variables
     '("\\b\\(nil\\|self\\|true\\|false\\)\\b"
       1 font-lock-variable-name-face)
     ;; variables
     '("[$@@].\\(\\w\\|_\\)*"
       0 font-lock-variable-name-face)
     ;; embedded document
     '(ruby-font-lock-docs
       0 font-lock-comment-face t)
     ;; constants
     '("\\(^\\|[^_]\\)\\b\\([A-Z]+\\(\\w\\|_\\)*\\)"
       2 font-lock-type-face)
     ;; functions
     '("^\\s *def\\s *\\<\\(\\(\\w\\|_\\)+\\(\\.\\|::\\)\\)?\\(\\(\\w\\|_\\)+\\??\\)\\>"
       4 font-lock-function-name-face t)
     ;; symbols
     '("\\(^\\|[^:]\\)\\(:\\(\\w\\|_\\)+\\??\\)\\b"
       2 font-lock-reference-face))
    "*Additional expressions to highlight in ruby mode."))

 ((featurep 'hilit19)
  (hilit-set-mode-patterns
   'ruby-mode
   '(("[^$\\?]\\(\"[^\\\"]*\\(\\\\\\(.\\|\n\\)[^\\\"]*\\)*\"\\)" 1 string)
     ("[^$\\?]\\('[^\\']*\\(\\\\\\(.\\|\n\\)[^\\']*\\)*'\\)" 1 string)
     ("[^$\\?]\\(`[^\\`]*\\(\\\\\\(.\\|\n\\)[^\\`]*\\)*`\\)" 1 string)
     ("^\\s *#.*$" nil comment)
     ("[^$@@?\\]\\(#[^$@@{\n].*$\\)" 1 comment)
     ("[^a-zA-Z_]\\(\\?\\(\\\\[CM]-\\)*.\\)" 1 string)
     ("^\\s *\\(require\\|load\\).*$" nil include)
     ("^\\s *\\(include\\|alias\\|undef\\).*$" nil decl)
     ("^\\s *\\<\\(class\\|def\\|module\\)\\>" "[)\n;]" defun)
     ("[^_]\\<\\(begin\\|case\\|else\\|elsif\\|end\\|ensure\\|for\\|if\\|unless\\|rescue\\|then\\|when\\|while\\|until\\|do\\)\\>[^_]" 1 defun)
     ("[^_]\\<\\(and\\|break\\|next\\|raise\\|fail\\|in\\|not\\|or\\|redo\\|retry\\|return\\|super\\|yield\\|catch\\|throw\\|self\\|nil\\)\\>[^_]" 1 keyword)
     ("\\$\\(.\\|\\sw+\\)" nil type)
     ("[$@@].[a-zA-Z_0-9]*" nil struct)
     ("^__END__" nil label))))
 )

@


1.1.1.1.2.9
log
@990806
@
text
@d5 1
a5 1
;;;  $Date: 1999/07/14 05:40:31 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.1.2.8 $")
d642 1
a642 1
	    "\\(^\\|[^_:.@@$]\\|\\.\\.\\)\\b\\("
d682 1
a682 1
	    "\\)\\>[^_]")
@


1.1.2.1
log
@first public release of 1.1d (pre1.2) series
@
text
@a0 691
;;;
;;;  ruby-mode.el -
;;;
;;;  $Author: matz $
<<<<<<< ruby-mode.el
;;;  $Date: 1998/11/25 03:31:19 $
=======
;;;  $Date: 1998/11/26 08:25:51 $
>>>>>>> 1.1.1.2.2.23
;;;  created at: Fri Feb  4 14:49:13 JST 1994
;;;

<<<<<<< ruby-mode.el
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.20.2.2 $")
=======
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.23 $")
>>>>>>> 1.1.1.2.2.23

(defconst ruby-mode-version
  (progn
   (string-match "[0-9.]+" ruby-mode-revision)
   (substring ruby-mode-revision (match-beginning 0) (match-end 0))))

(defconst ruby-block-beg-re
  "class\\|module\\|def\\|if\\|unless\\|case\\|while\\|until\\|for\\|begin\\|do"
  )

(defconst ruby-indent-beg-re
  "\\(\\s *\\(class\\|module\\|def\\)\\)\\|if\\|unless\\|case\\|while\\|until\\|for\\|begin"
    )

(defconst ruby-modifier-re
  "if\\|unless\\|while\\|until"
  )

(defconst ruby-block-mid-re
  "then\\|else\\|elsif\\|when\\|rescue\\|ensure"
  )

(defconst ruby-block-op-re
  "and\\|or\\|not"
  )

(defconst ruby-block-end-re "end")

(defconst ruby-delimiter
  (concat "[?$/%(){}#\"'`.:]\\|\\[\\|\\]\\|\\<\\("
	  ruby-block-beg-re
	  "\\|" ruby-block-end-re
	  "\\)\\>\\|^=begin")
  )

(defconst ruby-negative
  (concat "^[ \t]*\\(\\(" ruby-block-mid-re "\\)\\>\\|\\("
	    ruby-block-end-re "\\)\\>\\|\\}\\|\\]\\)")
  )

(defconst ruby-operator-chars ",.+*/%-&|^~=<>:")
(defconst ruby-operator-re (concat "[" ruby-operator-chars "]"))

(defconst ruby-symbol-chars "a-zA-Z0-9_")
(defconst ruby-symbol-re (concat "[" ruby-symbol-chars "]"))

(defvar ruby-mode-abbrev-table nil
  "Abbrev table in use in ruby-mode buffers.")

(define-abbrev-table 'ruby-mode-abbrev-table ())

(defvar ruby-mode-map nil "Keymap used in ruby mode.")

(if ruby-mode-map
    nil
  (setq ruby-mode-map (make-sparse-keymap))
  (define-key ruby-mode-map "{" 'ruby-electric-brace)
  (define-key ruby-mode-map "}" 'ruby-electric-brace)
  (define-key ruby-mode-map "\e\C-a" 'ruby-beginning-of-defun)
  (define-key ruby-mode-map "\e\C-e" 'ruby-end-of-defun)
  (define-key ruby-mode-map "\e\C-b" 'ruby-beginning-of-block)
  (define-key ruby-mode-map "\e\C-f" 'ruby-end-of-block)
  (define-key ruby-mode-map "\e\C-p" 'ruby-beginning-of-block)
  (define-key ruby-mode-map "\e\C-n" 'ruby-end-of-block)
  (define-key ruby-mode-map "\t" 'ruby-indent-command)
  (define-key ruby-mode-map "\C-c\C-e" 'ruby-insert-end)
  (define-key ruby-mode-map "\C-j" 'ruby-reindent-then-newline-and-indent)
  (define-key ruby-mode-map "\C-m" 'newline))

(defvar ruby-mode-syntax-table nil
  "Syntax table in use in ruby-mode buffers.")

(if ruby-mode-syntax-table
    ()
  (setq ruby-mode-syntax-table (make-syntax-table))
  (modify-syntax-entry ?\' "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?\" "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?\` "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?# "<" ruby-mode-syntax-table)
  (modify-syntax-entry ?\n ">" ruby-mode-syntax-table)
  (modify-syntax-entry ?\\ "\\" ruby-mode-syntax-table)
  (modify-syntax-entry ?$ "/" ruby-mode-syntax-table)
  (modify-syntax-entry ?? "_" ruby-mode-syntax-table)
  (modify-syntax-entry ?_ "_" ruby-mode-syntax-table)
  (modify-syntax-entry ?< "." ruby-mode-syntax-table)
  (modify-syntax-entry ?> "." ruby-mode-syntax-table)
  (modify-syntax-entry ?& "." ruby-mode-syntax-table)
  (modify-syntax-entry ?| "." ruby-mode-syntax-table)
  (modify-syntax-entry ?% "." ruby-mode-syntax-table)
  (modify-syntax-entry ?= "." ruby-mode-syntax-table)
  (modify-syntax-entry ?/ "." ruby-mode-syntax-table)
  (modify-syntax-entry ?+ "." ruby-mode-syntax-table)
  (modify-syntax-entry ?* "." ruby-mode-syntax-table)
  (modify-syntax-entry ?- "." ruby-mode-syntax-table)
  (modify-syntax-entry ?\; "." ruby-mode-syntax-table)
  (modify-syntax-entry ?\( "()" ruby-mode-syntax-table)
  (modify-syntax-entry ?\) ")(" ruby-mode-syntax-table)
  (modify-syntax-entry ?\{ "(}" ruby-mode-syntax-table)
  (modify-syntax-entry ?\} "){" ruby-mode-syntax-table)
  (modify-syntax-entry ?\[ "(]" ruby-mode-syntax-table)
  (modify-syntax-entry ?\] ")[" ruby-mode-syntax-table)
  )

(defvar ruby-indent-level 2
  "*Indentation of ruby statements.")

(defun ruby-mode-variables ()
  (set-syntax-table ruby-mode-syntax-table)
  (setq local-abbrev-table ruby-mode-abbrev-table)
  (make-local-variable 'indent-line-function)
  (setq indent-line-function 'ruby-indent-line)
  (make-local-variable 'require-final-newline)
  (setq require-final-newline t)
  (make-variable-buffer-local 'comment-start)
  (setq comment-start "# ")
  (make-variable-buffer-local 'comment-end)
  (setq comment-end "")
  (make-variable-buffer-local 'comment-column)
  (setq comment-column 32)
  (make-variable-buffer-local 'comment-start-skip)
  (setq comment-start-skip "\\(^\\|\\s-\\);?#+ *")
  (make-local-variable 'parse-sexp-ignore-comments)
  (setq parse-sexp-ignore-comments t))

(defun ruby-mode ()
  "Major mode for editing ruby scripts.
\\[ruby-indent-command] properly indents subexpressions of multi-line
class, module, def, if, while, for, do, and case statements, taking
nesting into account.

The variable ruby-indent-level controls the amount of indentation.
\\{ruby-mode-map}"
  (interactive)
  (kill-all-local-variables)
  (use-local-map ruby-mode-map)
  (setq mode-name "Ruby")
  (setq major-mode 'ruby-mode)
  (ruby-mode-variables)
  (run-hooks 'ruby-mode-hook))

(defun ruby-current-indentation ()
  (save-excursion
    (beginning-of-line)
    (back-to-indentation)
    (current-column)))

(defun ruby-indent-line (&optional flag)
  "Correct indentation of the current ruby line."
  (ruby-indent-to (ruby-calculate-indent)))

(defun ruby-indent-command ()
  (interactive)
  (ruby-indent-line t))

(defun ruby-indent-to (x)
  (if x
      (let (shift top beg)
	(and (< x 0)
	     (error "invalid nest"))
	(setq shift (current-column))
	(beginning-of-line)
	(setq beg (point))
	(back-to-indentation)
	(setq top (current-column))
	(skip-chars-backward " \t")
	(cond
	 ((>= x shift)
	  (setq shift 0))
	 ((>= shift top)
	  (setq shift (- shift top)))
	 (t (setq shift 0)))
	(if (and (bolp)
		 (= x top))
	    (move-to-column (+ x shift))
	  (move-to-column top)
	  (delete-region beg (point))
	  (beginning-of-line)
	  (indent-to x)
	  (move-to-column (+ x shift))))))

(defun ruby-expr-beg (&optional modifier pnt)
  (save-excursion
    (if (looking-at "\\?")
	(progn
	  (or (bolp) (forward-char -1))
	  (not (looking-at "\\sw")))
      (store-match-data nil)
      (skip-chars-backward " \t")
      (or (bolp) (forward-char -1))
      (or (bolp)
	  (looking-at ruby-operator-re)
	  (looking-at "[\\[({]")
	  (and (not modifier) (looking-at "[!?]"))
	  (and (looking-at ruby-symbol-re)
	       (forward-word -1)
	       (if (and (not modifier) (bolp))
		   t
		 (if (or (looking-at ruby-block-beg-re)
			 (looking-at ruby-block-op-re)
			 (looking-at ruby-block-mid-re))
		     (progn
		       (goto-char (match-end 0))
		       (looking-at "\\>")))))))))

(defun ruby-parse-region (start end)
  (let ((indent-point end)
	  (indent 0)
	  (in-string nil)
	  (in-paren nil)
	  (depth 0)
	  (nest nil)
	  (pcol nil))
    (save-excursion
	(if start
	    (goto-char start)
	  (ruby-beginning-of-indent))
	(save-restriction
	  (narrow-to-region (point) end)
	  (while (and (> indent-point (point))
		      (re-search-forward ruby-delimiter indent-point t))
	    (let ((pnt (point)) w)
	      (goto-char (match-beginning 0))
	      (cond
	       ((or (looking-at "\"")	;skip string
		    (looking-at "'")
		    (looking-at "`"))
		(setq w (char-after (point)))
		(cond
		 ((and (not (eobp))
		       (re-search-forward (format "[^\\]\\(\\\\\\\\\\)*%c" w) indent-point t))
		  nil)
		 (t
		  (setq in-string (point))
		  (goto-char indent-point))))
	       ((looking-at "/")
		(cond
		 ((and (not (eobp)) (ruby-expr-beg))
		  (if (re-search-forward "[^\\]/" indent-point t)
		      nil
		    (setq in-string (point))
		    (goto-char indent-point)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "%")
		(cond
		 ((and (not (eobp)) (ruby-expr-beg)
		       (looking-at "%[Qqrxw]?\\(.\\)"))
		  (setq w (buffer-substring (match-beginning 1)
					    (match-end 1)))
		  (cond
		   ((string= w "[") (setq w "]"))
		   ((string= w "{") (setq w "}"))
		   ((string= w "(") (setq w ")"))
		   ((string= w "<") (setq w ">")))
		  (goto-char (match-end 0))
		  (if (search-forward w indent-point t)
		      nil
		    (setq in-string (point))
		    (goto-char indent-point)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "\\?")	;skip ?char
		(cond
		 ((ruby-expr-beg)
		  (looking-at "?\\(\\\\C-\\|\\\\M-\\)*.")
		  (goto-char (match-end 0)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "\\$")	;skip $char
		(goto-char pnt)
		(forward-char 1))
	       ((looking-at "#")	;skip comment
		(forward-line 1)
		(goto-char (point))
		)
	       ((looking-at "(")
		(setq nest (cons (cons (char-after (point)) pnt) nest))
		(setq pcol (cons (cons pnt depth) pcol))
		(setq depth 0)
		(goto-char pnt)
		)
	       ((looking-at "[\\[{]")
		(setq nest (cons (cons (char-after (point)) pnt) nest))
		(setq depth (1+ depth))
		(goto-char pnt)
		)
	       ((looking-at ")")
		(setq nest (cdr nest))
		(setq depth (cdr (car pcol)))
		(setq pcol (cdr pcol))
		(goto-char pnt))
	       ((looking-at "[])}]")
		(setq nest (cdr nest))
		(setq depth (1- depth))
		(goto-char pnt))
	       ((looking-at ruby-block-end-re)
		(if (or (and (not (bolp))
			     (progn
			       (forward-char -1)
			       (eq ?_ (char-after (point)))))
			(progn
			  (goto-char pnt)
			  (setq w (char-after (point)))
			  (or (eq ?_ w)
			      (eq ?! w)
			      (eq ?? w))))
		    nil
		  (setq nest (cdr nest))
		  (setq depth (1- depth)))
		(goto-char pnt))
	       ((looking-at "def\\s +[^(\n;]*")
		(if (or (bolp)
			(progn
			  (forward-char -1)
			  (not (eq ?_ (char-after (point))))))
		    (progn
		      (setq nest (cons (cons nil pnt) nest))
		      (setq depth (1+ depth))))
		(goto-char (match-end 0)))
	       ((looking-at ruby-block-beg-re)
		(and 
		 (or (bolp)
		     (progn
		       (forward-char -1)
		       (not (eq ?_ (char-after (point))))))
		 (goto-char pnt)
		 (setq w (char-after (point)))
		 (not (eq ?_ w))
		 (not (eq ?! w))
		 (not (eq ?? w))
		 (skip-chars-forward " \t")
		 (if (not (eolp))
		     (progn
		       (goto-char (match-beginning 0))
		       (if (looking-at ruby-modifier-re)
			   (ruby-expr-beg t)
			 t))
		   t)
		 (goto-char pnt)
		 (setq nest (cons (cons nil pnt) nest))
		 (setq depth (1+ depth)))
		(goto-char pnt))
	       ((looking-at ":\\([a-zA-Z_][a-zA-Z_0-9]*\\)?")
		(goto-char (match-end 0)))
	       ((or (looking-at "\\.")
		    (looking-at "\\.\\.\\.?")
		    (looking-at "\\.[0-9]+")
		    (looking-at "\\.[a-zA-Z_0-9]+"))
		(goto-char (match-end 0)))
	       ((looking-at "^=begin")
		(if (re-search-forward "^=end" indent-point t)
		    (forward-line 1)
		  (setq in-string (match-end 0))
		  (goto-char indent-point)))
	       (t
		(error (format "bad string %s"
			       (buffer-substring (point) pnt)
			       )))))))
	(list in-string (car nest) depth (car (car pcol))))))

(defun ruby-indent-size (pos nest)
  (+ pos (* (if nest nest 1) ruby-indent-level)))

(defun ruby-calculate-indent (&optional parse-start)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
	    (case-fold-search nil)
	    state bol eol
	    (indent 0))
	(if parse-start
	    (goto-char parse-start)
	  (ruby-beginning-of-indent)
	  (setq parse-start (point)))
	(back-to-indentation)
	(setq indent (current-column))
	(setq state (ruby-parse-region parse-start indent-point))
	(cond
	 ((nth 0 state)			; within string
	  (setq indent nil))		;  do nothing

	 ((car (nth 1 state))		; in paren
	  (goto-char (cdr (nth 1 state)))
	  (if (eq (car (nth 1 state)) ?\( )
	      (let ((column (current-column))
		    (s (ruby-parse-region (point) indent-point)))
		(cond
		 ((and (nth 2 s) (> (nth 2 s) 0))
		  (goto-char (cdr (nth 1 s)))
		  (forward-word -1)
		  (setq indent (ruby-indent-size (current-column) (nth 2 state))))
		 (t 
		  (setq indent (current-column)))))
	    (cond
	     ((nth 3 state)
	      (goto-char (nth 3 state))
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))
	     (t
	      (goto-char parse-start)
	      (back-to-indentation)
	      (setq indent (ruby-indent-size (current-column) (nth 2 state)))))
	    ))
	  
	 ((and (nth 2 state)(> (nth 2 state) 0)) ; in nest
	  (if (null (cdr (nth 1 state)))
	      (error "invalid nest"))
	  (goto-char (cdr (nth 1 state)))
	  (forward-word -1)		; skip back a keyword
	  (cond
	   ((looking-at "do")		; iter block is a special case
	    (cond
	     ((nth 3 state)
	      (goto-char (nth 3 state))
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))
	     (t
	      (goto-char parse-start)
	      (back-to-indentation)
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))))
	   (t
	    (setq indent (+ (current-column) ruby-indent-level)))))

	 ((and (nth 2 state) (< (nth 2 state) 0)) ; in negative nest
	  (setq indent (ruby-indent-size (current-column) (nth 2 state)))))
	 
	(cond
	 (indent
	  (goto-char indent-point)
	  (end-of-line)
	  (setq eol (point))
	  (beginning-of-line)
	  (cond 
	   ((re-search-forward ruby-negative eol t)
	    (and (not (eq ?_ (char-after (match-end 0))))
		 (setq indent (- indent ruby-indent-level))))
	   ;;operator terminated lines
	   ((and
	     (save-excursion
	       (beginning-of-line)
	       (not (bobp)))
	     (or (null (car (nth 1 state))) ;not in parens
		 (and (eq (car (nth 1 state)) ?\{)
		      (save-excursion	;except non-block braces
			(goto-char (cdr (nth 1 state)))
			(or (bobp) (forward-char -1))
			(not (ruby-expr-beg))))))
	    ;; goto beginning of non-empty no-comment line
	    (let (end done)
	      (while (not done)
		(skip-chars-backward " \t\n")
		(setq end (point))
		(beginning-of-line)
		(if (re-search-forward "^\\s *#" end t)
		    (beginning-of-line)
		  (setq done t))))
	    (setq bol (point))
	    (end-of-line)
	    (skip-chars-backward " \t")
	    (and (re-search-backward "#" (save-excursion
					   (beginning-of-line)
					   (point)) t)
		 (setq state (ruby-parse-region parse-start (point)))
		 (nth 0 state)
		 (goto-char (nth 0 state)))
	    (or (bobp) (forward-char -1))
	    (and
	     (or (and (looking-at ruby-symbol-re)
		      (skip-chars-backward ruby-symbol-chars)
		      (looking-at ruby-block-op-re)
		      (save-excursion
			(goto-char (match-end 0))
			(not (looking-at "[a-z_]"))))
		 (and (looking-at ruby-operator-re)
		      (or (not (eq ?/ (char-after (point))))
			  (null (nth 0 (ruby-parse-region parse-start (point)))))
		      (not (eq (char-after (1- (point))) ?$))
		      (or (not (eq ?| (char-after (point))))
			  (save-excursion
			    (or (eolp) (forward-char -1))
			    (and (search-backward "|")
				 (skip-chars-backward " \t\n")
				 (and (not (eolp))
				      (progn
					(forward-char -1)
					(not (looking-at "\\{")))
				      (progn
					(forward-word -1)
					(not (looking-at "do\\>[^_]")))))))))
	     (setq indent (+ indent ruby-indent-level)))))))
	indent)))
 
(defun ruby-electric-brace (arg)
  (interactive "P")
  (self-insert-command (prefix-numeric-value arg))
  (ruby-indent-line t))

(defun ruby-beginning-of-defun (&optional arg)
  "Move backward to next beginning-of-defun.
With argument, do this that many times.
Returns t unless search stops due to end of buffer."
  (interactive "p")
  (and (re-search-backward (concat "^\\(" ruby-block-beg-re "\\)\\b")
			   nil 'move (or arg 1))
       (progn (beginning-of-line) t)))

(defun ruby-beginning-of-indent ()
  (and (re-search-backward (concat "^\\(" ruby-indent-beg-re "\\)\\b")
			   nil 'move)
       (progn
	 (beginning-of-line)
	 t)))

(defun ruby-end-of-defun (&optional arg)
  "Move forward to next end of defun.
An end of a defun is found by moving forward from the beginning of one."
  (interactive "p")
  (and (re-search-forward (concat "^\\(" ruby-block-end-re "\\)\\b[^_]")
			  nil 'move (or arg 1))
       (progn (beginning-of-line) t))
  (forward-line 1))

(defun ruby-move-to-block (n)
  (let (start pos done down)
    (setq start (ruby-calculate-indent))
    (if (eobp)
	nil
      (while (and (not (bobp)) (not done))
	(forward-line n)
	(cond
	 ((looking-at "^$"))
	 ((looking-at "^\\s *#"))
	 (t
	  (setq pos (current-indentation))
	  (cond
	   ((< start pos)
	    (setq down t))
	   ((and down (= pos start))
	    (setq done t))
	   ((> start pos)
	    (setq done t)))))
	(if done
	    (progn
	      (back-to-indentation)
	      (if (looking-at ruby-block-mid-re)
		  (setq done nil)))))))
  (back-to-indentation))

(defun ruby-beginning-of-block ()
  "Move backward to next beginning-of-block"
  (interactive)
  (ruby-move-to-block -1))

(defun ruby-end-of-block ()
  "Move forward to next beginning-of-block"
  (interactive)
  (ruby-move-to-block 1))

(defun ruby-reindent-then-newline-and-indent ()
  (interactive "*")
  (save-excursion
    (delete-region (point) (progn (skip-chars-backward " \t") (point))))
  (newline)
  (save-excursion
    (forward-line -1)
    (indent-according-to-mode))
  (indent-according-to-mode))

(fset 'ruby-encomment-region (symbol-function 'comment-region))

(defun ruby-decomment-region (beg end)
  (interactive "r")
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "^\\([ \t]*\\)#" end t)
      (replace-match "\\1" nil nil)
      (save-excursion
	(ruby-indent-line)))))

(defun ruby-insert-end ()
  (interactive)
  (insert "end")
  (ruby-indent-line t)
  (end-of-line))

(cond
 ((featurep 'hilit19)
  (hilit-set-mode-patterns
   'ruby-mode
   '(("[^$\\?]\\(\"[^\\\"]*\\(\\\\\\(.\\|\n\\)[^\\\"]*\\)*\"\\)" 1 string)
     ("[^$\\?]\\('[^\\']*\\(\\\\\\(.\\|\n\\)[^\\']*\\)*'\\)" 1 string)
     ("[^$\\?]\\(`[^\\`]*\\(\\\\\\(.\\|\n\\)[^\\`]*\\)*`\\)" 1 string)
     ("^\\s *#.*$" nil comment)
     ("[^$@@?\\]\\(#[^$@@{\n].*$\\)" 1 comment)
     ("[^a-zA-Z_]\\(\\?\\(\\\\[CM]-\\)*.\\)" 1 string)
     ("^\\s *\\(require\\|load\\).*$" nil include)
     ("^\\s *\\(include\\|alias\\|undef\\).*$" nil decl)
     ("^\\s *\\<\\(class\\|def\\|module\\)\\>" "[)\n;]" defun)
     ("[^_]\\<\\(begin\\|case\\|else\\|elsif\\|end\\|ensure\\|for\\|if\\|unless\\|rescue\\|then\\|when\\|while\\|until\\|do\\)\\>[^_]" 1 defun)
     ("[^_]\\<\\(and\\|break\\|next\\|raise\\|fail\\|in\\|not\\|or\\|redo\\|retry\\|return\\|super\\|yield\\|self\\|nil\\)\\>[^_]" 1 keyword)
     ("\\$\\(.\\|\\sw+\\)" nil type)
     ("[$@@].[a-zA-Z_0-9]*" nil struct)
     ("^__END__" nil label))))

 ((featurep 'font-lock)
  (or (boundp 'font-lock-variable-name-face)
      (setq font-lock-variable-name-face font-lock-type-face))
  (defvar ruby-font-lock-keywords
    (list
     (cons (concat
	    "\\(^\\|[^_:.]\\|\\.\\.\\)\\b\\("
	    (mapconcat
	     'identity
	     '("alias"
	       "and"
	       "begin"
	       "break"
	       "case"
	       "class"
	       "def"
	       "do"
	       "elsif"
	       "else"
	       "fail"
	       "ensure"
	       "for"
	       "end"
	       "if"
	       "in"
	       "module"
	       "next"
	       "not"
	       "or"
	       "raise"
	       "redo"
	       "rescue"
	       "retry"
	       "return"
	       "then"
	       "self"
	       "super"
	       "unless"
	       "undef"
	       "until"
	       "when"
	       "while"
	       )
	     "\\|")
	    "\\)\\b")
	   2)
     ;; variables
     '("\\(^\\|[^_]\\)\\b\\(nil\\|self\\|true\\|false\\)\\b\\([^_]\\|$\\)"
       2 font-lock-variable-name-face)
     ;; variables
     '("[$@@].[a-zA-Z0-9_]*"
       0 font-lock-variable-name-face)
     ;; constants
     '("\\(^\\|[^_]\\)\\b\\([A-Z]+[a-zA-Z0-9_]*\\)"
       2 font-lock-type-face)
     ;; functions
     '("^\\s *def[ \t]+\\([^ \t(]*\\)"
       1 font-lock-function-name-face t))
    "*Additional expressions to highlight in ruby mode.")
  (if (and (>= (string-to-int emacs-version) 19)
          (not (featurep 'xemacs)))
      (add-hook
       'ruby-mode-hook
       (lambda ()
        (make-local-variable 'font-lock-defaults)
        (setq font-lock-defaults 
              '((ruby-font-lock-keywords) nil nil ((?\_ . "w"))))))
    (add-hook 'ruby-mode-hook
             (lambda ()
               (setq font-lock-keywords ruby-font-lock-keywords))))))

(provide 'ruby-mode)
@
