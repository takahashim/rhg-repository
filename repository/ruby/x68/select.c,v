head	1.1;
branch	1.1.1;
access;
symbols
	v1_6_7:1.1.1.2
	v1_6_6:1.1.1.2
	v1_6_5:1.1.1.2
	v1_6_4:1.1.1.2
	v1_7_1:1.1.1.2
	v1_6_4_preview4:1.1.1.2
	v1_6_4_preview3:1.1.1.2
	v1_6_4_preview2:1.1.1.2
	v1_6_4_preview1:1.1.1.2
	v1_6_3:1.1.1.2
	ruby_m17n:1.1.1.2.0.8
	ruby_1_6:1.1.1.2.0.6
	v1_6_2:1.1.1.2
	v1_6_1:1.1.1.2
	v1_6_0:1.1.1.2
	v1_4_6:1.1.1.2
	v1_4_5:1.1.1.2
	v1_4_4:1.1.1.2
	ruby_1_4_3:1.1.1.2
	ruby1_4_3:1.1.1.2
	v1_4_3:1.1.1.2
	v1_5_0:1.1.1.2
	ruby_1_4_3_pre1:1.1.1.2
	ruby_1_4:1.1.1.2.0.4
	v1_4_2:1.1.1.2
	v1_4_1:1.1.1.2
	v1_4_0:1.1.1.2
	v1_3_7:1.1.1.2
	v1_3_6_repack:1.1.1.2
	v1_3_6:1.1.1.2
	v1_3_5:1.1.1.2
	v1_2_6repack:1.1.1.1.4.1
	v1_3_4_990625:1.1.1.2
	v1_3_4_990624:1.1.1.2
	v1_2_6:1.1.1.1.4.1
	v1_3_4_990611:1.1.1.2
	v1_3_4_990531:1.1.1.2
	v1_3_3_990518:1.1.1.2
	v1_3_3_990513:1.1.1.2
	v1_3_3_990507:1.1.1.2
	v1_2_5:1.1.1.1.4.1
	v1_2_4:1.1.1.1.4.1
	v1_3_1_990225:1.1.1.2
	v1_3_1_990224:1.1.1.2
	v1_3_1_990215:1.1.1.2
	v1_3_1_990212:1.1.1.2
	v1_3_1_990210:1.1.1.2
	v1_3_1_:1.1.1.2
	v1_3_1_990209:1.1.1.2
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.4.1
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.4.1
	v1_2_1repack:1.1.1.1.4.1
	v1_2_1:1.1.1.1.4.1
	v1_2_stable:1.1.1.1.4.1
	v1_1d1:1.1.1.1.4.1
	v1_1d0:1.1.1.1.4.1
	v1_1c9_1:1.1.1.1.4.1
	v1_1c9:1.1.1.1.4.1
	v1_1c8:1.1.1.1.4.1
	v1_1c7:1.1.1.1.4.1
	v1_1c6:1.1.1.1.4.1
	v1_1d-start:1.1.1.1.4.1
	v1_1c5:1.1.1.1.4.1
	v1_1dev:1.1.1.1.4.1.0.2
	v1_1c4:1.1.1.1.4.1
	v1_1c3:1.1.1.1.4.1
	v1_1c2:1.1.1.1.4.1
	v1_1c1:1.1.1.1.4.1
	v1_1c0:1.1.1.1.4.1
	v1_1b9_31:1.1.1.1.4.1
	v1_1b9_30:1.1.1.1.4.1
	v1_1b9_28:1.1.1.1.4.1
	v1_1b9_27:1.1.1.1.4.1
	v1_1b9_26:1.1.1.1.4.1
	r1_1b9_25:1.1.1.1.4.1
	r1_1b9_24:1.1.1.1.4.1
	v1_1b9_23:1.1.1.1.4.1
	v1_1b9_22:1.1.1.1.4.1
	v1_1b9_20:1.1.1.1.4.1
	v1_1b9_18:1.1.1.1.4.1
	v1_1b9_16:1.1.1.1.4.1
	v1_1b9_15:1.1.1.1.4.1
	v1_1b9_13:1.1.1.1.4.1
	v1_1b9_12:1.1.1.1.4.1
	v1_1b9_11:1.1.1.1.4.1
	v1_1b9_08:1.1.1.1.4.1
	v1_1b9_07:1.1.1.1.4.1
	r1_1b9:1.1.1.1.4.1
	v1_1b8:1.1.1.1.4.1
	v1_1b7:1.1.1.1.4.1
	v1_1b6:1.1.1.1.4.1
	v1_1r:1.1.1.1.0.4
	v1_1:1.1.1.1
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	98.01.16.12.13.08;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.08;	author matz;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.39;	author matz;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	98.01.16.12.36.14;	author matz;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * PROJECT C Library, X68000 PROGRAMMING INTERFACE DEFINITION
 * --------------------------------------------------------------------
 * This file is written by the Project C Library Group,  and completely
 * in public domain. You can freely use, copy, modify, and redistribute
 * the whole contents, without this notice.
 * --------------------------------------------------------------------
 * $Id$
 */

#ifndef __IOCS_INLINE__
#define __IOCS_INLINE__
#define __DOS_INLINE__
#define __DOS_DOSCALL__
#endif

/* System headers */
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <sys/dos.h>
#include <sys/iocs.h>
#include <sys/time.h>
#include <sys/types.h>
#if 0
#include <sys/select.h>
#include <sys/xsocket.h>
#endif
#include <sys/xunistd.h>

/* Macros */
#define XFD_ISSET(fd,fds) ((fds) && FD_ISSET ((fd), (fds)))
#define isreadable(mode)  ((mode) == O_RDONLY || (mode) == O_RDWR)
#define iswritable(mode)  ((mode) == O_WRONLY || (mode) == O_RDWR)
#ifndef _POSIX_FD_SETSIZE
#define _POSIX_FD_SETSIZE OPEN_MAX
#endif

/* Functions */
int
select (int fds, fd_set *rfds, fd_set *wfds, fd_set *efds, struct timeval *timeout)
{
  fd_set oread, owrite, oexcept;
  int ticks, start;
  int nfds;

  if (fds > _POSIX_FD_SETSIZE)
    {
      errno = EINVAL;
      return -1;
    }

  FD_ZERO (&oread);
  FD_ZERO (&owrite);
  FD_ZERO (&oexcept);

  nfds = 0;
  ticks = -1;

  if (timeout)
    {
      ticks = timeout->tv_sec * 100 + timeout->tv_usec / 10000;
      if (ticks < 0)
	{
	  errno = EINVAL;
	  return -1;
	}
    }

  start = _iocs_ontime ();
  for (;;)
    {
      {
	int fd;
	
	for (fd = 0; fd < fds; fd++)
	  {
	    int accmode;
	    
	    if (_fddb[fd].inuse == _FD_NOTUSED)
	      continue;
	    
	    accmode = _fddb[fd].oflag & O_ACCMODE;
	    
	    if (isatty (fd))
	      {
		if (XFD_ISSET (fd, rfds) && isreadable (accmode) && _dos_k_keysns ())
		  {
		    FD_SET (fd, &oread);
		    nfds++;
		  }
		
		if (XFD_ISSET (fd, wfds) && iswritable (accmode))
		  {
		    FD_SET (fd, &owrite);
		    nfds++;
		  }
	      }
#if 0
	    else if (_fddb[fd].sockno >= 0)
	      {
		if (XFD_ISSET (fd, rfds) && _socklen (_fddb[fd].sockno, 0))
		  {
		    FD_SET (fd, &oread);
		    nfds++;
		  }

		if (XFD_ISSET (fd, wfds) /* && _socklen (_fddb[fd].sockno, 1) == 0 */)
		  {
		    FD_SET (fd, &owrite);
		    nfds++;
		  }
	      }
#endif
	    else
	      {
		if (XFD_ISSET (fd, rfds) && isreadable (accmode) && _dos_ioctrlis (fd))
		  {
		    FD_SET (fd, &oread);
		    nfds++;
		  }
		
		if (XFD_ISSET (fd, wfds) && iswritable (accmode) && _dos_ioctrlos (fd))
		  {
		    FD_SET (fd, &owrite);
		    nfds++;
		  }
	      }
	  }
      }

      {
	int rest;
	
	if ((rest = (_iocs_ontime () - start) % 8640000) < 0)
	  rest += 8640000;
	
	if (nfds != 0)
	  {
	    if (ticks >= 0)
	      {
		int left;
		
		if ((left = ticks - rest) < 0)
		  left = 0;
		
		timeout->tv_sec = left / 100;
		timeout->tv_usec = (left % 100) * 10000;
	      }
	    
	    if (rfds)
	      *rfds = oread;
	    if (wfds)
	      *wfds = owrite;
	    if (efds)
	      *efds = oexcept;
	    
	    return nfds;
	  }
	
	if (ticks >= 0 && rest > ticks)
	  return 0;
      }

      _dos_change_pr ();
    }
}
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@d8 1
a8 1
 * $Id: select.c,v 1.1.1.1.4.1 1998/01/16 12:36:14 matz Exp $
@


1.1.1.1.4.1
log
@*** empty log message ***
@
text
@d8 1
a8 1
 * $Id: select.c,v 1.1.1.1 1998/01/16 04:05:52 matz Exp $
@
