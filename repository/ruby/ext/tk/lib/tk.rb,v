head	1.35;
access;
symbols
	v1_6_7:1.20.2.11
	v1_6_6:1.20.2.8
	v1_6_5:1.20.2.6
	v1_6_4:1.20.2.5
	v1_7_1:1.24
	v1_6_4_preview4:1.20.2.3
	v1_6_4_preview3:1.20.2.3
	v1_6_4_preview2:1.20.2.2
	v1_6_4_preview1:1.20.2.2
	v1_6_3:1.20
	ruby_m17n:1.20.0.4
	ruby_1_6:1.20.0.2
	v1_6_2:1.20
	v1_6_1:1.17
	v1_6_0:1.17
	v1_4_6:1.3.2.12
	v1_4_5:1.3.2.10
	v1_4_4:1.3.2.5
	ruby_1_4_3:1.3.2.1
	ruby1_4_3:1.3.2.1
	v1_4_3:1.3.2.1
	v1_5_0:1.4
	ruby_1_4_3_pre1:1.3
	ruby_1_4:1.3.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.6
	v1_3_6_repack:1.1.1.1.2.6
	v1_3_6:1.1.1.1.2.6
	v1_3_5:1.1.1.1.2.6
	v1_2_6repack:1.1.2.3
	v1_3_4_990625:1.1.1.1.2.5
	v1_3_4_990624:1.1.1.1.2.5
	v1_2_6:1.1.2.3
	v1_3_4_990611:1.1.1.1.2.4
	v1_3_4_990531:1.1.1.1.2.4
	v1_3_3_990518:1.1.1.1.2.3
	v1_3_3_990513:1.1.1.1.2.3
	v1_3_3_990507:1.1.1.1.2.3
	v1_2_5:1.1.2.2
	v1_2_4:1.1.2.2
	v1_3_1_990225:1.1.1.1.2.2
	v1_3_1_990224:1.1.1.1.2.2
	v1_3_1_990215:1.1.1.1.2.1
	v1_3_1_990212:1.1.1.1.2.1
	v1_3_1_990210:1.1.1.1.2.1
	v1_3_1_:1.1.1.1.2.1
	v1_3_1_990209:1.1.1.1.2.1
	v1_3_1_990205:1.1.1.1.2.1
	v1_3_1_990203:1.1.1.1.2.1
	v1_3_1_990201:1.1.1.1.2.1
	v1_3_1"_990201:1.1.1.1.2.1
	v1_3_1_990128:1.1.1.1.2.1
	v1_3_1_990127:1.1.1.1.2.1
	v1_3_1_990126:1.1.1.1.2.1
	ruby_1_3:1.1.1.1.0.2
	v1_2_2:1.1.2.1
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_2_2_pr1:1.1.2.1
	v1_2_1repack:1.1.2.1
	v1_2_1:1.1.2.1
	v1_2_stable:1.1.2.1
	v1_1c9_1:1.1.2.1
	v1_1c9:1.1.2.1
	v1_1c8:1.1.2.1
	v1_1r:1.1.0.2;
locks; strict;
comment	@# @;


1.35
date	2002.10.02.06.02.16;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2002.09.12.06.27.15;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.28.14.40.25;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.04.07.03.33;	author nagai;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.11.08.02.04;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.08.07.03.07;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.28.06.53.33;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.28.08.44.43;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.19.05.02.17;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2001.10.29.05.07.24;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.05.06.54.57;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.01.06.47.32;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.30.09.10.23;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.06.15.04.27;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.27.07.09.27;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.27.09.23.34;	author matz;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2000.11.20.07.31.51;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.11.17.09.09.03;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.02.04.54.20;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.14.04.34.41;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.06.07.21.20;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.13.09.57.03;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.12.07.48.26;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.24.04.34.21;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.10.06.05.19;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.10.05.57.37;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.17.08.58.17;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.01.03.12.18;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.17.08.37.50;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.05.04.37.19;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.12.14.06.49.57;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.12.06.09.04.00;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.08.24.08.21.54;	author matz;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.08.13.05.37.51;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.11.17.09.12.44;	author matz;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	99.01.20.04.59.34;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.01.26.10.08.17;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.02.24.04.31.28;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.03.24.08.52.34;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.05.31.09.13.32;	author matz;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.06.24.04.24.07;	author matz;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	99.07.15.07.59.58;	author matz;	state Exp;
branches;
next	;

1.1.2.1
date	98.11.17.09.12.44;	author matz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	99.02.16.03.42.20;	author matz;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	99.06.21.06.31.12;	author matz;	state Exp;
branches;
next	;

1.3.2.1
date	99.12.06.09.03.37;	author matz;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	99.12.14.06.50.40;	author matz;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2000.01.05.04.41.15;	author matz;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2000.01.17.08.24.17;	author matz;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2000.02.01.03.11.27;	author matz;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2000.03.23.04.14.27;	author matz;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2000.04.10.05.56.58;	author matz;	state Exp;
branches;
next	1.3.2.8;

1.3.2.8
date	2000.04.10.06.01.29;	author matz;	state Exp;
branches;
next	1.3.2.9;

1.3.2.9
date	2000.06.13.09.50.56;	author matz;	state Exp;
branches;
next	1.3.2.10;

1.3.2.10
date	2000.06.13.09.57.39;	author matz;	state Exp;
branches;
next	1.3.2.11;

1.3.2.11
date	2000.07.10.08.01.45;	author matz;	state Exp;
branches;
next	1.3.2.12;

1.3.2.12
date	2000.07.14.04.33.28;	author matz;	state Exp;
branches;
next	1.3.2.13;

1.3.2.13
date	2000.08.07.05.04.58;	author matz;	state Exp;
branches;
next	;

1.20.2.1
date	2001.03.27.07.10.58;	author matz;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.04.06.05.42.42;	author matz;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.05.01.08.45.20;	author matz;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2001.05.29.08.59.39;	author matz;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2001.06.01.06.46.12;	author matz;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2001.09.05.06.53.31;	author matz;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2001.10.29.05.04.45;	author matz;	state Exp;
branches;
next	1.20.2.8;

1.20.2.8
date	2001.11.19.04.58.07;	author matz;	state Exp;
branches;
next	1.20.2.9;

1.20.2.9
date	2002.01.28.08.42.40;	author matz;	state Exp;
branches;
next	1.20.2.10;

1.20.2.10
date	2002.02.28.06.52.49;	author matz;	state Exp;
branches;
next	1.20.2.11;

1.20.2.11
date	2002.03.01.14.12.05;	author matz;	state Exp;
branches;
next	1.20.2.12;

1.20.2.12
date	2002.03.08.06.59.55;	author matz;	state Exp;
branches;
next	1.20.2.13;

1.20.2.13
date	2002.03.12.09.27.29;	author matz;	state Exp;
branches;
next	;


desc
@@


1.35
log
@* commit miss;  and tcltklib fix too.
@
text
@#
#		tk.rb - Tk interface module using tcltklib
#			$Date: 2002/09/12 06:27:15 $
#			by Yukihiro Matsumoto <matz@@netlab.jp>

# use Shigehiro's tcltklib
require "tcltklib"
require "tkutil"

module TkComm
  WidgetClassNames = {}

  None = Object.new
  def None.to_s
    'None'
  end

  Tk_CMDTBL = {}
  Tk_WINDOWS = {}

  def error_at
    frames = caller()
    frames.delete_if do |c|
      c =~ %r!/tk(|core|thcore|canvas|text|entry|scrollbox)\.rb:\d+!
    end
    frames
  end
  private :error_at

  def _genobj_for_tkwidget(path)
    return TkRoot.new if path == '.'

    begin
      tk_class = TkCore::INTERP._invoke('winfo', 'class', path)
    rescue
      return path
    end

    ruby_class = WidgetClassNames[tk_class]
    gen_class_name = ruby_class.name + 'GeneratedOnTk'
    unless Object.const_defined? gen_class_name
      eval "class #{gen_class_name}<#{ruby_class.name}
              def initialize(path)
                @@path=path
                Tk_WINDOWS[@@path] = self
              end
            end"
    end
    eval "#{gen_class_name}.new('#{path}')"
  end

  def tk_tcl2ruby(val)
    if val =~ /^rb_out (c\d+)/
      return Tk_CMDTBL[$1]
    end
    if val.include? ?\s
      return val.split.collect{|v| tk_tcl2ruby(v)}
    end
    case val
    when /^@@font/
      TkFont.get_obj(val)
    when /^-?\d+$/
      val.to_i
    when /^\./
      Tk_WINDOWS[val] ? Tk_WINDOWS[val] : _genobj_for_tkwidget(val)
    when / /
      val.split.collect{|elt|
	tk_tcl2ruby(elt)
      }
    when /^-?\d+\.\d*$/
      val.to_f
    else
      val
    end
  end

  def tk_split_list(str)
    return [] if str == ""
    idx = str.index('{')
    while idx and idx > 0 and str[idx-1] == ?\\
      idx = str.index('{', idx+1)
    end
    return tk_tcl2ruby(str) unless idx

    list = tk_tcl2ruby(str[0,idx])
    list = [] if list == ""
    str = str[idx+1..-1]
    i = -1
    brace = 1
    str.each_byte {|c|
      i += 1
      brace += 1 if c == ?{
      brace -= 1 if c == ?}
      break if brace == 0
    }
    if str[0, i] == ' '
      list.push ' '
    else
      list.push tk_split_list(str[0, i])
    end
    list += tk_split_list(str[i+1..-1])
    list
  end

  def tk_split_simplelist(str)
    return [] if str == ""
    idx = str.index('{')
    while idx and idx > 0 and str[idx-1] == ?\\
      idx = str.index('{', idx+1)
    end
    return str.split unless idx

    list = str[0,idx].split
    str = str[idx+1..-1]
    i = -1
    brace = 1
    str.each_byte {|c|
      i += 1
      brace += 1 if c == ?{
      brace -= 1 if c == ?}
      break if brace == 0
    }
    if i == 0
      list.push ''
    elsif str[0, i] == ' '
      list.push ' '
    else
      list.push str[0..i-1]
    end
    list += tk_split_simplelist(str[i+1..-1])
    list
  end
  private :tk_tcl2ruby, :tk_split_list, :tk_split_simplelist

  def _symbolkey2str(keys)
    h = {}
    keys.each{|key,value| h[key.to_s] = value}
    h
  end
  private :_symbolkey2str

  def hash_kv(keys)
    conf = []
    if keys and keys != None
      for k, v in keys
	 conf.push("-#{k}")
	 conf.push(v)
      end
    end
    conf
  end
  private :hash_kv

  def array2tk_list(ary)
    ary.collect{|e|
      if e.kind_of? Array
	"{#{array2tk_list(e)}}"
      elsif e.kind_of? Hash
	"{#{e.to_a.collect{|ee| array2tk_list(ee)}.join(' ')}}"
      else
	s = _get_eval_string(e)
	(s.index(/\s/))? "{#{s}}": s
      end
    }.join(" ")
  end
  private :array2tk_list

  def bool(val)
    case val
    when "1", 1, 'yes', 'true'
      TRUE
    else
      FALSE
    end
  end
  def number(val)
    case val
    when /^-?\d+$/
      val.to_i
    when /^-?\d+\.\d*$/
      val.to_f
    else
      val
    end
  end
  def string(val)
    if val == "{}"
      ''
    elsif val[0] == ?{
      val[1..-2]
    else
      val
    end
  end
  def list(val)
    tk_split_list(val).to_a
  end
  def window(val)
    Tk_WINDOWS[val]
  end
  def procedure(val)
    if val =~ /^rb_out (c\d+)/
      Tk_CMDTBL[$1]
    else
      nil
    end
  end
  private :bool, :number, :string, :list, :window, :procedure

  def _get_eval_string(str)
    return nil if str == None
    if str.kind_of?(String)
      # do nothing
    elsif str.kind_of?(Symbol)
      str = str.id2name
    elsif str.kind_of?(Hash)
      str = hash_kv(str).join(" ")
    elsif str.kind_of?(Array)
      str = array2tk_list(str)
    elsif str.kind_of?(Proc)
      str = install_cmd(str)
    elsif str == nil
      str = ""
    elsif str == false
      str = "0"
    elsif str == true
      str = "1"
    elsif (str.respond_to?(:to_eval))
      str = str.to_eval()
    else
      str = str.to_s()
    end
    return str
  end
  private :_get_eval_string

  def ruby2tcl(v)
    if v.kind_of?(Hash)
      v = hash_kv(v)
      v.flatten!
      v.collect{|e|ruby2tcl(e)}
    else
      _get_eval_string(v)
    end
  end
  private :ruby2tcl

  Tk_IDs = [0, 0]		# [0]-cmdid, [1]-winid
  def _curr_cmd_id
    id = format("c%.4d", Tk_IDs[0])
  end
  def _next_cmd_id
    id = _curr_cmd_id
    Tk_IDs[0] += 1
    id
  end
  def install_cmd(cmd)
    return '' if cmd == ''
    id = _next_cmd_id
    Tk_CMDTBL[id] = cmd
    @@cmdtbl = [] unless @@cmdtbl
    @@cmdtbl.push id
    return format("rb_out %s", id);
  end
  def uninstall_cmd(id)
    id = $1 if /rb_out (c\d+)/ =~ id
    Tk_CMDTBL.delete(id)
  end
  private :install_cmd, :uninstall_cmd

  def install_win(ppath,name=nil)
    if !name or name == ''
      name = format("w%.4d", Tk_IDs[1])
      Tk_IDs[1] += 1
    end
    if !ppath or ppath == "."
      @@path = format(".%s", name);
    else
      @@path = format("%s.%s", ppath, name)
    end
    Tk_WINDOWS[@@path] = self
  end

  def uninstall_win()
    Tk_WINDOWS.delete(@@path)
  end

  class Event
    def initialize(seq,a,b,c,d,f,h,k,m,o,p,s,t,w,x,y,
	           aa,bb,dd,ee,kk,nn,rr,ss,tt,ww,xx,yy)
      @@serial = seq
      @@above = a
      @@num = b
      @@count = c
      @@detail = d
      @@focus = (f == 1)
      @@height = h
      @@keycode = k
      @@mode = m
      @@override = (o == 1)
      @@place = p
      @@state = s
      @@time = t
      @@width = w
      @@x = x
      @@y = y
      @@char = aa
      @@borderwidth = bb
      @@wheel_delta = dd
      @@send_event = (ee == 1)
      @@keysym = kk
      @@keysym_num = nn
      @@rootwin_id = rr
      @@subwindow = ss
      @@type = tt
      @@widget = ww
      @@x_root = xx
      @@y_root = yy
    end
    attr :serial
    attr :above
    attr :num
    attr :count
    attr :detail
    attr :focus
    attr :height
    attr :keycode
    attr :mode
    attr :override
    attr :place
    attr :state
    attr :time
    attr :width
    attr :x
    attr :y
    attr :char
    attr :borderwidth
    attr :wheel_delta
    attr :send_event
    attr :keysym
    attr :keysym_num
    attr :rootwin_id
    attr :subwindow
    attr :type
    attr :widget
    attr :x_root
    attr :y_root
  end

  def install_bind(cmd, args=nil)
    if args
      id = install_cmd(proc{|*arg|
	TkUtil.eval_cmd cmd, *arg
      })
      id + " " + args
    else
      id = install_cmd(proc{|arg|
	TkUtil.eval_cmd cmd, Event.new(*arg)
      })
      id + ' %# %a %b %c %d %f %h %k %m %o %p %s %t %w %x %y' + 
	   ' %A %B %D %E %K %N %R %S %T %W %X %Y'
    end
  end

  def tk_event_sequence(context)
    if context.kind_of? TkVirtualEvent
      context = context.path
    end
    if context.kind_of? Array
      context = context.collect{|ev|
	if ev.kind_of? TkVirtualEvent
	  ev.path
	else
	  ev
	end
      }.join("><")
    end
    if /,/ =~ context
      context = context.split(/\s*,\s*/).join("><")
    else
      context
    end
  end

  def _bind_core(mode, what, context, cmd, args=nil)
    id = install_bind(cmd, args) if cmd
    begin
      tk_call(*(what + ["<#{tk_event_sequence(context)}>", mode + id]))
    rescue
      uninstall_cmd(id) if cmd
      fail
    end
  end

  def _bind(what, context, cmd, args=nil)
    _bind_core('', what, context, cmd, args)
  end

  def _bind_append(what, context, cmd, args=nil)
    _bind_core('+', what, context, cmd, args)
  end

  def _bind_remove(what, context)
    tk_call(*(what + ["<#{tk_event_sequence(context)}>", '']))
  end

  def _bindinfo(what, context=nil)
    if context
      tk_call(*what+["<#{tk_event_sequence(context)}>"]).collect {|cmdline|
	if cmdline =~ /^rb_out (c\d+)\s+(.*)$/
	  [Tk_CMDTBL[$1], $2]
	else
	  cmdline
	end
      }
    else
      tk_split_simplelist(tk_call(*what)).collect!{|seq|
	l = seq.scan(/<*[^<>]+>*/).collect!{|subseq|
	  case (subseq)
	  when /^<<[^<>]+>>$/
	    TkVirtualEvent.getobj(subseq[1..-2])
	  when /^<[^<>]+>$/
	    subseq[1..-2]
	  else
	    subseq.split('')
	  end
	}.flatten
	(l.size == 1) ? l[0] : l
      }
    end
  end
  private :install_bind, :tk_event_sequence, 
          :_bind_core, :_bind, :_bind_append, :_bind_remove, :_bindinfo

  def bind(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind(["bind", tagOrClass], context, cmd, args)
  end

  def bind_append(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind_append(["bind", tagOrClass], context, cmd, args)
  end

  def bind_remove(tagOrClass, context)
    _bind_remove(['bind', tagOrClass], context)
  end

  def bindinfo(tagOrClass, context=nil)
    _bindinfo(['bind', tagOrClass], context)
  end

  def bind_all(context, cmd=Proc.new, args=nil)
    _bind(['bind', 'all'], context, cmd, args)
  end

  def bind_append_all(context, cmd=Proc.new, args=nil)
    _bind_append(['bind', 'all'], context, cmd, args)
  end

  def bindinfo_all(context=nil)
    _bindinfo(['bind', 'all'], context)
  end

  def pack(*args)
    TkPack.configure(*args)
  end

  def grid(*args)
    TkGrid.configure(*args)
  end

  def update(idle=nil)
    if idle
      tk_call 'update', 'idletasks'
    else
      tk_call 'update'
    end
  end

end

module TkCore
  include TkComm
  extend TkComm

  INTERP = TclTkIp.new

  INTERP._invoke("proc", "rb_out", "args", <<-'EOL')
    regsub -all {!} $args {\\!} args
    regsub -all "{" $args "\\{" args
    if {[set st [catch {ruby [format "TkCore.callback %%Q!%s!" $args]} ret]] != 0} {
	return -code $st $ret
    } {
	return $ret
    }
  EOL

  EventFlag = TclTkLib::EventFlag

  def callback_break
    fail TkCallbackBreak, "Tk callback returns 'break' status"
  end

  def callback_continue
    fail TkCallbackContinue, "Tk callback returns 'continue' status"
  end

  def after(ms, cmd=Proc.new)
    myid = _curr_cmd_id
    cmdid = install_cmd(cmd)
    tk_call("after",ms,cmdid)
#    return
#    if false #defined? Thread
#      Thread.start do
#	ms = Float(ms)/1000
#	ms = 10 if ms == 0
#	sleep ms/1000
#	cmd.call
#      end
#    else
#      cmdid = install_cmd(cmd)
#      tk_call("after",ms,cmdid)
#    end
  end

  def after_idle(cmd=Proc.new)
    myid = _curr_cmd_id
    cmdid = install_cmd(cmd)
    tk_call('after','idle',cmdid)
  end

  def clock_clicks(ms=nil)
    if ms
      tk_call('clock','clicks','-milliseconds').to_i
    else
      tk_call('clock','clicks').to_i
    end
  end

  def clock_format(clk, form=nil)
    if form
      tk_call('clock','format',clk,'-format',form).to_i
    else
      tk_call('clock','format',clk).to_i
    end
  end

  def clock_formatGMT(clk, form=nil)
    if form
      tk_call('clock','format',clk,'-format',form,'-gmt','1').to_i
    else
      tk_call('clock','format',clk,'-gmt','1').to_i
    end
  end

  def clock_scan(str, base=nil)
    if base
      tk_call('clock','scan',str,'-base',base).to_i
    else
      tk_call('clock','scan',str).to_i
    end
  end

  def clock_scanGMT(str, base=nil)
    if base
      tk_call('clock','scan',str,'-base',base,'-gmt','1').to_i
    else
      tk_call('clock','scan',str,'-gmt','1').to_i
    end
  end

  def clock_seconds
    tk_call('clock','seconds').to_i
  end

  def TkCore.callback(arg)
    arg = Array(tk_split_list(arg))
    _get_eval_string(TkUtil.eval_cmd(Tk_CMDTBL[arg.shift], *arg))
  end

  def scaling(scale=nil)
    if scale
      tk_call('tk', 'scaling', scale)
    else
      Float(number(tk_call('tk', 'scaling')))
    end
  end
  def scaling_displayof(win, scale=nil)
    if scale
      tk_call('tk', 'scaling', '-displayof', win, scale)
    else
      Float(number(tk_call('tk', '-displayof', win, 'scaling')))
    end
  end

  def appname(name=None)
    tk_call('tk', 'appname', name)
  end

  def appsend(interp, async, *args)
    if async
      tk_call('send', '-async', '--', interp, *args)
    else
      tk_call('send', '--', interp, *args)
    end
  end

  def rb_appsend(interp, async, *args)
    args = args.collect!{|c| _get_eval_string(c).gsub(/[][$"]/, '\\\\\&')}
    args.push(').to_s"')
    appsend(interp, async, 'ruby "(', *args)
  end

  def appsend_displayof(interp, win, async, *args)
    win = '.' if win == nil
    if async
      tk_call('send', '-async', '-displayof', win, '--', interp, *args)
    else
      tk_call('send', '-displayor', win, '--', interp, *args)
    end
  end

  def rb_appsend_displayof(interp, win, async, *args)
    args = args.collect!{|c| _get_eval_string(c).gsub(/[][$"]/, '\\\\\&')}
    args.push(').to_s"')
    appsend_displayof(interp, win, async, 'ruby "(', *args)
  end

  def info(*args)
    tk_call('info', *args)
  end

  def mainloop(check_root = true)
    TclTkLib.mainloop(check_root)
  end

  def mainloop_watchdog(check_root = true)
    TclTkLib.mainloop_watchdog(check_root)
  end

  def do_one_event(flag = 0)
    TclTkLib.do_one_event(flag)
  end

  def set_eventloop_tick(timer_tick)
    TclTkLib.set_eventloop_tick(timer_tick)
  end

  def get_eventloop_tick()
    TclTkLib.get_eventloop_tick
  end

  def set_eventloop_weight(loop_max, no_event_tick)
    TclTkLib.set_eventloop_weight(loop_max, no_event_tick)
  end

  def get_eventloop_weight()
    TclTkLib.get_eventloop_weight
  end

  def restart(app_name = nil, use = nil)
    tk_call('set', 'argv0', app_name) if app_name
    if use
      tk_call('set', 'argc', 2)
      tk_call('set', 'argv', "-use #{use}")
    end
    TkCore::INTERP.restart
    TkComm::Tk_CMDTBL.clear
    TkComm::Tk_WINDOWS.clear
    nil
  end

  def event_generate(window, context, keys=nil)
    window = window.path if window.kind_of? TkObject
    if keys
      tk_call('event', 'generate', window, 
	      "<#{tk_event_sequence(context)}>", *hash_kv(keys))
    else
      tk_call('event', 'generate', window, "<#{tk_event_sequence(context)}>")
    end
  end

  def messageBox(keys)
    tk_call 'tk_messageBox', *hash_kv(keys)
  end

  def getOpenFile(keys = nil)
    tk_call 'tk_getOpenFile', *hash_kv(keys)
  end

  def getSaveFile(keys = nil)
    tk_call 'tk_getSaveFile', *hash_kv(keys)
  end

  def chooseColor(keys = nil)
    tk_call 'tk_chooseColor', *hash_kv(keys)
  end

  def chooseDirectory(keys = nil)
    tk_call 'tk_chooseDirectory', *hash_kv(keys)
  end

  def tk_call(*args)
    puts args.inspect if $DEBUG
    args.collect! {|x|ruby2tcl(x)}
    args.compact!
    args.flatten!
    print "=> ", args.join(" ").inspect, "\n" if $DEBUG
    begin
      res = INTERP._invoke(*args)
    rescue NameError
      err = $!
      begin
        args.unshift "unknown"
        res = INTERP._invoke(*args)
      rescue
	fail unless /^invalid command/ =~ $!
	fail err
      end
    end
    if  INTERP._return_value() != 0
      fail RuntimeError, res, error_at
    end
    print "==> ", res.inspect, "\n" if $DEBUG
    return res
  end
end

module TkPackage
  include TkCore
  extend TkPackage

  def add_path(path)
    Tk::AUTO_PATH.value = Tk::AUTO_PATH.to_a << path
  end

  def forget(package)
    tk_call('package', 'forget', package)
    nil
  end

  def names
    tk_split_simplelist(tk_call('package', 'names'))
  end

  def provide(package, version=nil)
    if version
      tk_call('package', 'provide', package, version)
      nil
    else
      tk_call('package', 'provide', package)
    end
  end

  def present(package, version=None)
    tk_call('package', 'present', package, version)
  end

  def present_exact(package, version)
    tk_call('package', 'present', '-exact', package, version)
  end

  def require(package, version=None)
    tk_call('package', 'require', package, version)
  end

  def require_exact(package, version)
    tk_call('package', 'require', '-exact', package, version)
  end

  def versions(package)
    tk_split_simplelist(tk_call('package', 'versions', package))
  end

  def vcompare(version1, version2)
    Integer(tk_call('package', 'vcompare', version1, version2))
  end

  def vsatisfies(version1, version2)
    bool(tk_call('package', 'vsatisfies', version1, version2))
  end
end

module Tk
  include TkCore
  extend Tk

  TCL_VERSION = INTERP._invoke("info", "tclversion")
  TK_VERSION  = INTERP._invoke("set", "tk_version")

  TCL_PATCHLEVEL = INTERP._invoke("info", "patchlevel")
  TK_PATCHLEVEL  = INTERP._invoke("set", "tk_patchLevel")

  TCL_LIBRARY = INTERP._invoke("set", "tcl_library")
  TK_LIBRARY  = INTERP._invoke("set", "tk_library")
  LIBRARY     = INTERP._invoke("info", "library")

  PLATFORM = Hash[*tk_split_simplelist(INTERP._eval('array get tcl_platform'))]

  JAPANIZED_TK = (INTERP._invoke("info", "commands", "kanji") != "")

  def root
    TkRoot.new
  end

  def bell
    tk_call 'bell'
  end

  def Tk.focus(display=nil)
    if display == nil
      r = tk_call('focus')
    else
      r = tk_call('focus', '-displayof', display)
    end
    tk_tcl2ruby(r)
  end

  def Tk.focus_lastfor(win)
    tk_tcl2ruby(tk_call('focus', '-lastfor', win))
  end

  def Tk.strictMotif(bool=None)
    bool(tk_call('set', 'tk_strictMotif', bool))
  end

  def Tk.show_kinsoku(mode='both')
    begin
      if /^8\.*/ === TK_VERSION  && JAPANIZED_TK
        tk_split_simplelist(tk_call('kinsoku', 'show', mode))
      end
    rescue
    end
  end
  def Tk.add_kinsoku(chars, mode='both')
    begin
      if /^8\.*/ === TK_VERSION  && JAPANIZED_TK
        tk_split_simplelist(tk_call('kinsoku', 'add', mode, 
                                    *(chars.split(''))))
      else
        []
      end
    rescue
      []
    end
  end
  def Tk.delete_kinsoku(chars, mode='both')
    begin
      if /^8\.*/ === TK_VERSION  && JAPANIZED_TK
        tk_split_simplelist(tk_call('kinsoku', 'delete', mode, 
                            *(chars.split(''))))
      end
    rescue
    end
  end

  def Tk.toUTF8(str,encoding)
    INTERP._toUTF8(str,encoding)
  end
  
  def Tk.fromUTF8(str,encoding)
    INTERP._fromUTF8(str,encoding)
  end

  module Scrollable
    def xscrollcommand(cmd=Proc.new)
      configure_cmd 'xscrollcommand', cmd
    end
    def yscrollcommand(cmd=Proc.new)
      configure_cmd 'yscrollcommand', cmd
    end
    def xview(*index)
      v = tk_send('xview', *index)
      list(v) if index.size == 0
    end
    def yview(*index)
      v = tk_send('yview', *index)
      list(v) if index.size == 0
    end
    def xscrollbar(bar=nil)
      if bar
	@@xscrollbar = bar
	@@xscrollbar.orient 'horizontal'
	self.xscrollcommand {|arg| @@xscrollbar.set(*arg)}
	@@xscrollbar.command {|arg| self.xview(*arg)}
      end
      @@xscrollbar
    end
    def yscrollbar(bar=nil)
      if bar
	@@yscrollbar = bar
	@@yscrollbar.orient 'vertical'
	self.yscrollcommand {|arg| @@yscrollbar.set(*arg)}
	@@yscrollbar.command {|arg| self.yview(*arg)}
      end
      @@yscrollbar
    end
  end

  module Wm
    include TkComm
    def aspect(*args)
      w = tk_call('wm', 'aspect', path, *args)
      list(w) if args.length == 0
    end
    def client(name=None)
      tk_call 'wm', 'client', path, name
    end
    def colormapwindows(*args)
      list(tk_call('wm', 'colormapwindows', path, *args))
    end
    def wm_command(value=None)
      string(tk_call('wm', 'command', path, value))
    end
    def deiconify
      tk_call 'wm', 'deiconify', path
    end
    def focusmodel(*args)
      tk_call 'wm', 'focusmodel', path, *args
    end
    def frame
      tk_call('wm', 'frame', path)
    end
    def geometry(*args)
      tk_call('wm', 'geometry', path, *args)
    end
    def grid(*args)
      w = tk_call('wm', 'grid', path, *args)
      list(w) if args.size == 0
    end
    def group(*args)
      w = tk_call 'wm', 'group', path, *args
      window(w) if args.size == 0
    end
    def iconbitmap(*args)
      tk_call 'wm', 'iconbitmap', path, *args
    end
    def iconify
      tk_call 'wm', 'iconify', path
    end
    def iconmask(*args)
      tk_call 'wm', 'iconmask', path, *args
    end
    def iconname(*args)
      tk_call 'wm', 'iconname', path, *args
    end
    def iconposition(*args)
      w = tk_call('wm', 'iconposition', path, *args)
      list(w) if args.size == 0
    end
    def iconwindow(*args)
      w = tk_call('wm', 'iconwindow', path, *args)
      window(w) if args.size == 0
    end
    def maxsize(*args)
      w = tk_call('wm', 'maxsize', path, *args)
      list(w) if args.size == 0
    end
    def minsize(*args)
      w = tk_call('wm', 'minsize', path, *args)
      list(w) if args.size == 0
    end
    def overrideredirect(bool=None)
      if bool == None
	bool(tk_call('wm', 'overrideredirect', path))
      else
	tk_call 'wm', 'overrideredirect', path, bool
      end
    end
    def positionfrom(*args)
      tk_call 'wm', 'positionfrom', path, *args
    end
    def protocol(name=nil, cmd=nil)
      if cmd
	tk_call('wm', 'protocol', path, name, cmd)
      elsif name
	result = tk_call('wm', 'protocol', path, name)
	(result == "")? nil : tk_tcl2ruby(result)
      else
	tk_split_simplelist(tk_call('wm', 'protocol', path))
      end
    end
    def resizable(*args)
      w = tk_call('wm', 'resizable', path, *args)
      if args.length == 0
	list(w).collect{|e| bool(e)}
      end
    end
    def sizefrom(*args)
      tk_call('wm', 'sizefrom', path, *args)
    end
    def state(state=None)
      tk_call 'wm', 'state', path, state
    end
    def title(*args)
      tk_call 'wm', 'title', path, *args
    end
    def transient(*args)
      window(tk_call('wm', 'transient', path, *args))
    end
    def withdraw
      tk_call 'wm', 'withdraw', path
    end
  end
end

###########################################
#  convert kanji string to/from utf-8
###########################################
if /^8\.[1-9]/ =~ Tk::TCL_VERSION && !Tk::JAPANIZED_TK
  class TclTkIp
    # from tkencoding.rb by ttate@@jaist.ac.jp
    alias __eval _eval
    alias __invoke _invoke
    private :__eval
    private :__invoke
    
    attr_accessor :encoding
    
    def _eval(cmd)
      if @@encoding
	_fromUTF8(__eval(_toUTF8(cmd, @@encoding)), @@encoding)
      else
	__eval(cmd)
      end
    end
    
    def _invoke(*cmds)
      if @@encoding
	cmds = cmds.collect{|cmd| _toUTF8(cmd, @@encoding)}
	_fromUTF8(__invoke(*cmds), @@encoding)
      else
	__invoke(*cmds)
	end
    end
  end

  module Tk
    def encoding=(name)
      INTERP.encoding = name
    end

    def encoding
      INTERP.encoding
    end

    def encoding_names
      tk_split_simplelist(tk_call('encoding', 'names'))
    end

    def encoding_system
      tk_call('encoding', 'system')
    end

    def encoding_system=(enc)
      tk_call('encoding', 'system', enc)
    end
  end

  # estimate encoding
  case $KCODE
  when /^e/i  # EUC
    Tk.encoding = 'euc-jp'
  when /^s/i  # SJIS
    Tk.encoding = 'shiftjis'
  when /^u/i  # UTF8
    Tk.encoding = 'utf-8'
  else        # NONE
    begin
      Tk.encoding = Tk.encoding_system
    rescue StandardError, NameError
      Tk.encoding = 'utf-8'
    end
  end

else
  # dummy methods
  module Tk
    def encoding=(name)
      nil
    end
    def encoding
      nil
    end
    def encoding_names
      nil
    end
    def encoding_system
      nil
    end
    def encoding_system=(enc)
      nil
    end
  end
end

module TkBindCore
  def bind(context, cmd=Proc.new, args=nil)
    Tk.bind(to_eval, context, cmd, args)
  end

  def bind_append(context, cmd=Proc.new, args=nil)
    Tk.bind_append(to_eval, context, cmd, args)
  end

  def bind_remove(context)
    Tk.bind_remove(to_eval, context)
  end

  def bindinfo(context=nil)
    Tk.bindinfo(to_eval, context)
  end
end

class TkBindTag
  include TkBindCore

  BTagID_TBL = {}
  Tk_BINDTAG_ID = ["btag00000"]

  def TkBindTag.id2obj(id)
    BTagID_TBL[id]? BTagID_TBL[id]: id
  end

  ALL = self.new
  ALL.instance_eval {
    @@id = 'all'
    BTagID_TBL[@@id] = self
  }

  def initialize(*args)
    @@id = Tk_BINDTAG_ID[0]
    Tk_BINDTAG_ID[0] = Tk_BINDTAG_ID[0].succ
    BTagID_TBL[@@id] = self
    bind(*args) if args != []
  end

  def to_eval
    @@id
  end

  def inspect
    format "#<TkBindTag: %s>", @@id
  end
end

class TkBindTagAll<TkBindTag
  def TkBindTagAll.new(*args)
    $stderr.puts "Warning: TkBindTagALL is obsolete. Use TkBindTag::ALL\n"

    TkBindTag::ALL.bind(*args) if args != []
    TkBindTag::ALL
  end
end

class TkVariable
  include Tk
  extend TkCore

  TkVar_CB_TBL = {}
  Tk_VARIABLE_ID = ["v00000"]

  INTERP._invoke("proc", "rb_var", "args", "ruby [format \"TkVariable.callback %%Q!%s!\" $args]")

  def TkVariable.callback(args)
    name1,name2,op = tk_split_list(args)
    if TkVar_CB_TBL[name1]
      _get_eval_string(TkVar_CB_TBL[name1].trace_callback(name2,op))
    else
      ''
    end
  end

  def initialize(val="")
    @@id = Tk_VARIABLE_ID[0]
    Tk_VARIABLE_ID[0] = Tk_VARIABLE_ID[0].succ
    if val == []
      INTERP._eval(format('global %s; set %s(0) 0; unset %s(0)', 
			  @@id, @@id, @@id))
    elsif val.kind_of?(Array)
      a = []
      val.each_with_index{|e,i| a.push(i); a.push(array2tk_list(e))}
      s = '"' + a.join(" ").gsub(/[][$"]/, '\\\\\&') + '"'
      INTERP._eval(format('global %s; array set %s %s', @@id, @@id, s))
    elsif  val.kind_of?(Hash)
      s = '"' + val.to_a.collect{|e| array2tk_list(e)}.join(" ")\
                   .gsub(/[][$"]/, '\\\\\&') + '"'
      INTERP._eval(format('global %s; array set %s %s', @@id, @@id, s))
    else
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"'
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
    end
  end

  def wait
    INTERP._eval("tkwait variable #{@@id}")
  end

  def id
    @@id
  end

  def value
    begin
      INTERP._eval(format('global %s; set %s', @@id, @@id))
    rescue
      if INTERP._eval(format('global %s; array exists %s', @@id, @@id)) != "1"
	fail
      else
	Hash[*tk_split_simplelist(INTERP._eval(format('global %s; array get %s', 
						      @@id, @@id)))]
      end
    end
  end

  def value=(val)
    begin
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"'
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
    rescue
      if INTERP._eval(format('global %s; array exists %s', @@id, @@id)) != "1"
	fail
      else
	if val == []
	  INTERP._eval(format('global %s; unset %s; set %s(0) 0; unset %s(0)', 
			      @@id, @@id, @@id, @@id))
	elsif val.kind_of?(Array)
	  a = []
	  val.each_with_index{|e,i| a.push(i); a.push(array2tk_list(e))}
	  s = '"' + a.join(" ").gsub(/[][$"]/, '\\\\\&') + '"'
	  INTERP._eval(format('global %s; unset %s; array set %s %s', 
			      @@id, @@id, @@id, s))
	elsif  val.kind_of?(Hash)
	  s = '"' + val.to_a.collect{|e| array2tk_list(e)}.join(" ")\
	                        .gsub(/[][$"]/, '\\\\\&') + '"'
	  INTERP._eval(format('global %s; unset %s; array set %s %s', 
			      @@id, @@id, @@id, s))
	else
	  fail
	end
      end
    end
  end

  def [](index)
    INTERP._eval(format('global %s; set %s(%s)', 
			@@id, @@id, _get_eval_string(index)))
  end

  def []=(index,val)
    INTERP._eval(format('global %s; set %s(%s) %s', @@id, @@id, 
			_get_eval_string(index), _get_eval_string(val)))
  end

  def to_i
    number(value).to_i
  end

  def to_f
    number(value).to_f
  end

  def to_s
    string(value).to_s
  end

  def inspect
    format "#<TkVariable: %s>", @@id
  end

  def ==(other)
    case other
    when TkVariable
      self.equal(self)
    when String
      self.to_s == other
    when Integer
      self.to_i == other
    when Float
      self.to_f == other
    when Array
      self.to_a == other
    else
      false
    end
  end

  def to_a
    list(value)
  end

  def to_eval
    @@id
  end

  def unset(elem=nil)
    if elem
      INTERP._eval(format('global %s; unset %s(%s)', 
			  @@id, @@id, tk_tcl2ruby(elem)))
    else
      INTERP._eval(format('global %s; unset %s', @@id, @@id))
    end
  end
  alias remove unset

  def trace_callback(elem, op)
    if @@trace_var.kind_of? Array
      @@trace_var.each{|m,e| e.call(self,elem,op) if m.index(op)}
    end
    if elem.kind_of? String
      if @@trace_elem[elem].kind_of? Array
	@@trace_elem[elem].each{|m,e| e.call(self,elem,op) if m.index(op)}
      end
    end
  end

  def trace(opts, cmd)
    @@trace_var = [] if @@trace_var == nil
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    @@trace_var.unshift([opts,cmd])
    if @@trace_opts == nil
      TkVar_CB_TBL[@@id] = self
      @@trace_opts = opts
      Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
    else
      newopts = @@trace_opts.dup
      opts.each_byte{|c| newopts += c.chr unless newopts.index(c)}
      if newopts != @@trace_opts
	Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
	@@trace_opts.replace(newopts)
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_element(elem, opts, cmd)
    @@trace_elem = {} if @@trace_elem == nil
    @@trace_elem[elem] = [] if @@trace_elem[elem] == nil
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    @@trace_elem[elem].unshift([opts,cmd])
    if @@trace_opts == nil
      TkVar_CB_TBL[@@id] = self
      @@trace_opts = opts
      Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
    else
      newopts = @@trace_opts.dup
      opts.each_byte{|c| newopts += c.chr unless newopts.index(c)}
      if newopts != @@trace_opts
	Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
	@@trace_opts.replace(newopts)
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_vinfo
    return [] unless @@trace_var
    @@trace_var.dup
  end
  def trace_vinfo_for_element(elem)
    return [] unless @@trace_elem
    return [] unless @@trace_elem[elem]
    @@trace_elem[elem].dup
  end

  def trace_vdelete(opts,cmd)
    return unless @@trace_var.kind_of? Array
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    idx = -1
    newopts = ''
    @@trace_var.each_with_index{|e,i| 
      if idx < 0 && e[0] == opts && e[1] == cmd
	idx = i
	next
      end
      e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
    }
    if idx >= 0
      @@trace_var.delete_at(idx) 
    else
      return
    end

    @@trace_elem.each{|elem|
      @@trace_elem[elem].each{|e|
	e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
      }
    }

    newopts = ['r','w','u'].find_all{|c| newopts.index(c)}.join('')
    if newopts != @@trace_opts
      Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
      @@trace_opts.replace(newopts)
      if @@trace_opts != ''
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_vdelete_for_element(elem,opts,cmd)
    return unless @@trace_elem.kind_of? Hash
    return unless @@trace_elem[elem].kind_of? Array
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    idx = -1
    @@trace_elem[elem].each_with_index{|e,i| 
      if idx < 0 && e[0] == opts && e[1] == cmd
	idx = i
	next
      end
    }
    if idx >= 0
      @@trace_elem[elem].delete_at(idx)
    else
      return
    end

    newopts = ''
    @@trace_var.each{|e| 
      e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
    }
    @@trace_elem.each{|elem|
      @@trace_elem[elem].each{|e|
	e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
      }
    }

    newopts = ['r','w','u'].find_all{|c| newopts.index(c)}.join('')
    if newopts != @@trace_opts
      Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
      @@trace_opts.replace(newopts)
      if @@trace_opts != ''
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end
end

class TkVarAccess<TkVariable
  def initialize(varname, val=nil)
    @@id = varname
    if val
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"' #"
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
    end
  end
end

module Tk
  begin
    auto_path = INTERP._invoke('set', 'auto_path')
  rescue
    begin
      auto_path = INTERP._invoke('set', 'env(TCLLIBPATH)')
    rescue
      auto_path = Tk::LIBRARY
    end
  end
  AUTO_PATH = TkVarAccess.new('auto_path', auto_path)

  TCL_PACKAGE_PATH = TkVarAccess.new('tcl_pkgPath')
end

module TkSelection
  include Tk
  extend Tk
  def clear(win=Tk.root)
    tk_call 'selection', 'clear', win.path
  end
  def get(type=None)
    tk_call 'selection', 'get', type
  end
  def TkSelection.handle(win, func, type=None, format=None)
    tk_call 'selection', 'handle', win.path, func, type, format
  end
  def handle(func, type=None, format=None)
    TkSelection.handle self, func, type, format
  end
  def TkSelection.own(win=None, func=None)
    window(tk_call('selection', 'own', win, func))
  end
  def own(func=None)
    TkSelection.own self, func
  end

  module_function :clear, :get
end

module TkKinput
  include Tk
  extend Tk

  def TkKinput.start(window, style=None)
    tk_call 'kinput_start', window.path, style
  end
  def kinput_start(style=None)
    TkKinput.start(self, style)
  end

  def TkKinput.send_spot(window)
    tk_call 'kinput_send_spot', window.path
  end
  def kinput_send_spot
    TkKinput.send_spot(self)
  end

  def TkKinput.input_start(window, keys=nil)
    tk_call 'kanjiInput', 'start', window.path, *hash_kv(keys)
  end
  def kanji_input_start(keys=nil)
    TkKinput.input_start(self, keys)
  end

  def TkKinput.attribute_config(window, slot, value=None)
    if slot.kind_of? Hash
      tk_call 'kanjiInput', 'attribute', window.path, *hash_kv(slot)
    else
      tk_call 'kanjiInput', 'attribute', window.path, "-#{slot}", value
    end
  end
  def kinput_attribute_config(slot, value=None)
    TkKinput.attribute_config(self, slot, value)
  end

  def TkKinput.attribute_info(window, slot=nil)
    if slot
      conf = tk_split_list(tk_call('kanjiInput', 'attribute', 
				   window.path, "-#{slot}"))
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_call('kanjiInput', 'attribute', 
			    window.path)).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end
  def kinput_attribute_info(slot=nil)
    TkKinput.attribute_info(self, slot)
  end

  def TkKinput.input_end(window)
    tk_call 'kanjiInput', 'end', window.path
  end
  def kanji_input_end
    TkKinput.input_end(self)
  end
end

module TkXIM
  include Tk
  extend Tk

  def TkXIM.useinputmethods(window=nil, value=nil)
    if window
      if value
        tk_call 'tk', 'useinputmethods', '-displayof', window.path, value
      else
        tk_call 'tk', 'useinputmethods', '-displayof', window.path
      end
    else
      if value
        tk_call 'tk', 'useinputmethods', value
      else
        tk_call 'tk', 'useinputmethods'
      end
    end
  end

  def TkXIM.configure(window, slot, value=None)
    begin
      if /^8\.*/ === Tk::TK_VERSION  && JAPANIZED_TK
        if slot.kind_of? Hash
          tk_call 'imconfigure', window.path, *hash_kv(slot)
        else
          tk_call 'imconfigure', window.path, "-#{slot}", value
        end
      end
    rescue
    end
  end

  def TkXIM.configinfo(window, slot=nil)
    begin
      if /^8\.*/ === Tk::TK_VERSION  && JAPANIZED_TK
        if slot
          conf = tk_split_list(tk_call('imconfigure', window.path, "-#{slot}"))
          conf[0] = conf[0][1..-1]
          conf
        else
          tk_split_list(tk_call('imconfigure', window.path)).collect{|conf|
            conf[0] = conf[0][1..-1]
            conf
          }
        end
      else
        []
      end
    rescue
      []
    end
  end

  def useinputmethods(value=nil)
    TkXIM.useinputmethods(self, value)
  end

  def imconfigure(window, slot, value=None)
    TkXIM.configinfo(window, slot, value)
  end

  def imconfiginfo(slot=nil)
    TkXIM.configinfo(window, slot)
  end
end

module TkWinfo
  include Tk
  extend Tk
  def TkWinfo.atom(name)
    number(tk_call('winfo', 'atom', name))
  end
  def winfo_atom(name)
    TkWinfo.atom name
  end
  def TkWinfo.atomname(id)
    tk_call 'winfo', 'atomname', id
  end
  def winfo_atomname(id)
    TkWinfo.atomname id
  end
  def TkWinfo.cells(window)
    number(tk_call('winfo', 'cells', window.path))
  end
  def winfo_cells
    TkWinfo.cells self
  end
  def TkWinfo.children(window)
    c = tk_call('winfo', 'children', window.path)
    list(c)
  end
  def winfo_children
    TkWinfo.children self
  end
  def TkWinfo.classname(window)
    tk_call 'winfo', 'class', window.path
  end
  def winfo_classname
    TkWinfo.classname self
  end
  def TkWinfo.colormapfull(window)
     bool(tk_call('winfo', 'colormapfull', window.path))
  end
  def winfo_colormapfull
    TkWinfo.colormapfull self
  end
  def TkWinfo.containing(rootX, rootY)
    path = tk_call('winfo', 'containing', rootX, rootY)
    window(path)
  end
  def winfo_containing(x, y)
    TkWinfo.containing x, y
  end
  def TkWinfo.depth(window)
    number(tk_call('winfo', 'depth', window.path))
  end
  def winfo_depth
    TkWinfo.depth self
  end
  def TkWinfo.exist?(window)
    bool(tk_call('winfo', 'exists', window.path))
  end
  def winfo_exist?
    TkWinfo.exist? self
  end
  def TkWinfo.fpixels(window, number)
    number(tk_call('winfo', 'fpixels', window.path, number))
  end
  def winfo_fpixels(number)
    TkWinfo.fpixels self, number
  end
  def TkWinfo.geometry(window)
    tk_call('winfo', 'geometry', window.path)
  end
  def winfo_geometry
    TkWinfo.geometry self
  end
  def TkWinfo.height(window)
    number(tk_call('winfo', 'height', window.path))
  end
  def winfo_height
    TkWinfo.height self
  end
  def TkWinfo.id(window)
    tk_call('winfo', 'id', window.path)
  end
  def winfo_id
    TkWinfo.id self
  end
  def TkWinfo.interps(window=nil)
    if window
      tk_split_simplelist(tk_call('winfo', 'interps',
				  '-displayof', window.path))
    else
      tk_split_simplelist(tk_call('winfo', 'interps'))
    end
  end
  def winfo_interps
    TkWinfo.interps self
  end
  def TkWinfo.mapped?(window)
    bool(tk_call('winfo', 'ismapped', window.path))
  end
  def winfo_mapped?
    TkWinfo.mapped? self
  end
  def TkWinfo.manager(window)
    tk_call('winfo', 'manager', window.path)
  end
  def winfo_manager
    TkWinfo.manager self
  end
  def TkWinfo.appname(window)
    tk_call('winfo', 'name', window.path)
  end
  def winfo_appname
    TkWinfo.appname self
  end
  def TkWinfo.parent(window)
    window(tk_call('winfo', 'parent', window.path))
  end
  def winfo_parent
    TkWinfo.parent self
  end
  def TkWinfo.widget(id)
    window(tk_call('winfo', 'pathname', id))
  end
  def winfo_widget(id)
    TkWinfo.widget id
  end
  def TkWinfo.pixels(window, number)
    number(tk_call('winfo', 'pixels', window.path, number))
  end
  def winfo_pixels(number)
    TkWinfo.pixels self, number
  end
  def TkWinfo.reqheight(window)
    number(tk_call('winfo', 'reqheight', window.path))
  end
  def winfo_reqheight
    TkWinfo.reqheight self
  end
  def TkWinfo.reqwidth(window)
    number(tk_call('winfo', 'reqwidth', window.path))
  end
  def winfo_reqwidth
    TkWinfo.reqwidth self
  end
  def TkWinfo.rgb(window, color)
    list(tk_call('winfo', 'rgb', window.path, color))
  end
  def winfo_rgb(color)
    TkWinfo.rgb self, color
  end
  def TkWinfo.rootx(window)
    number(tk_call('winfo', 'rootx', window.path))
  end
  def winfo_rootx
    TkWinfo.rootx self
  end
  def TkWinfo.rooty(window)
    number(tk_call('winfo', 'rooty', window.path))
  end
  def winfo_rooty
    TkWinfo.rooty self
  end
  def TkWinfo.screen(window)
    tk_call 'winfo', 'screen', window.path
  end
  def winfo_screen
    TkWinfo.screen self
  end
  def TkWinfo.screencells(window)
    number(tk_call('winfo', 'screencells', window.path))
  end
  def winfo_screencells
    TkWinfo.screencells self
  end
  def TkWinfo.screendepth(window)
    number(tk_call('winfo', 'screendepth', window.path))
  end
  def winfo_screendepth
    TkWinfo.screendepth self
  end
  def TkWinfo.screenheight (window)
    number(tk_call('winfo', 'screenheight', window.path))
  end
  def winfo_screenheight
    TkWinfo.screenheight self
  end
  def TkWinfo.screenmmheight(window)
    number(tk_call('winfo', 'screenmmheight', window.path))
  end
  def winfo_screenmmheight
    TkWinfo.screenmmheight self
  end
  def TkWinfo.screenmmwidth(window)
    number(tk_call('winfo', 'screenmmwidth', window.path))
  end
  def winfo_screenmmwidth
    TkWinfo.screenmmwidth self
  end
  def TkWinfo.screenvisual(window)
    tk_call 'winfo', 'screenvisual', window.path
  end
  def winfo_screenvisual
    TkWinfo.screenvisual self
  end
  def TkWinfo.screenwidth(window)
    number(tk_call('winfo', 'screenwidth', window.path))
  end
  def winfo_screenwidth
    TkWinfo.screenwidth self
  end
  def TkWinfo.server(window)
    tk_call 'winfo', 'server', window.path
  end
  def winfo_server
    TkWinfo.server self
  end
  def TkWinfo.toplevel(window)
    window(tk_call('winfo', 'toplevel', window.path))
  end
  def winfo_toplevel
    TkWinfo.toplevel self
  end
  def TkWinfo.visual(window)
    tk_call 'winfo', 'visual', window.path
  end
  def winfo_visual
    TkWinfo.visual self
  end
  def TkWinfo.visualid(window)
    tk_call 'winfo', 'visualid', window.path
  end
  def winfo_visualid
    TkWinfo.visualid self
  end
  def TkWinfo.visualsavailable(window, includeids=false)
    if includeids
      v = tk_call('winfo', 'visualsavailable', window.path, "includeids")
    else
      v = tk_call('winfo', 'visualsavailable', window.path)
    end
    list(v)
  end
  def winfo_visualsavailable(includeids=false)
    TkWinfo.visualsavailable self, includeids
  end
  def TkWinfo.vrootheight(window)
    number(tk_call('winfo', 'vrootheight', window.path))
  end
  def winfo_vrootheight
    TkWinfo.vrootheight self
  end
  def TkWinfo.vrootwidth(window)
    number(tk_call('winfo', 'vrootwidth', window.path))
  end
  def winfo_vrootwidth
    TkWinfo.vrootwidth self
  end
  def TkWinfo.vrootx(window)
    number(tk_call('winfo', 'vrootx', window.path))
  end
  def winfo_vrootx
    TkWinfo.vrootx self
  end
  def TkWinfo.vrooty(window)
    number(tk_call('winfo', 'vrooty', window.path))
  end
  def winfo_vrooty
    TkWinfo.vrooty self
  end
  def TkWinfo.width(window)
    number(tk_call('winfo', 'width', window.path))
  end
  def winfo_width
    TkWinfo.width self
  end
  def TkWinfo.x(window)
    number(tk_call('winfo', 'x', window.path))
  end
  def winfo_x
    TkWinfo.x self
  end
  def TkWinfo.y(window)
    number(tk_call('winfo', 'y', window.path))
  end
  def winfo_y
    TkWinfo.y self
  end
  def TkWinfo.viewable(window)
    bool(tk_call('winfo', 'viewable', window.path))
  end
  def winfo_viewable
    TkWinfo.viewable self
  end
  def TkWinfo.pointerx(window)
    number(tk_call('winfo', 'pointerx', window.path))
  end
  def winfo_pointerx
    TkWinfo.pointerx self
  end
  def TkWinfo.pointery(window)
    number(tk_call('winfo', 'pointery', window.path))
  end
  def winfo_pointery
    TkWinfo.pointery self
  end
  def TkWinfo.pointerxy(window)
    list(tk_call('winfo', 'pointerxy', window.path))
  end
  def winfo_pointerxy
    TkWinfo.pointerxy self
  end
end

module TkPack
  include Tk
  extend Tk
  def configure(win, *args)
    if args[-1].kind_of?(Hash)
      keys = args.pop
    end
    wins = [win.epath]
    for i in args
      wins.push i.epath
    end
    tk_call "pack", 'configure', *(wins+hash_kv(keys))
  end

  def forget(*args)
    tk_call 'pack', 'forget' *args
  end

  def info(slave)
    ilist = list(tk_call('pack', 'info', slave.epath))
    info = {}
    while key = ilist.shift
      info[key[1..-1]] = ilist.shift
    end
    return info
  end

  def propagate(master, bool=None)
    if bool == None
      bool(tk_call('pack', 'propagate', master.epath))
    else
      tk_call('pack', 'propagate', master.epath, bool)
    end
  end

  def slaves(master)
    list(tk_call('pack', 'slaves', master.epath))
  end

  module_function :configure, :forget, :info, :propagate, :slaves
end

module TkGrid
  include Tk
  extend Tk

  def bbox(*args)
    list(tk_call('grid', 'bbox', *args))
  end

  def configure(widget, *args)
    if args[-1].kind_of?(Hash)
      keys = args.pop
    end
    wins = [widget.epath]
    for i in args
      wins.push i.epath
    end
    tk_call "grid", 'configure', *(wins+hash_kv(keys))
  end

  def columnconfigure(master, index, args)
    tk_call "grid", 'columnconfigure', master, index, *hash_kv(args)
  end

  def rowconfigure(master, index, args)
    tk_call "grid", 'rowconfigure', master, index, *hash_kv(args)
  end

  def columnconfiginfo(master, index, slot=nil)
    if slot
      tk_call 'grid', 'columnconfigure', master, index, "-#{slot}"
    else
      ilist = list(tk_call('grid', 'columnconfigure', master, index))
      info = {}
      while key = ilist.shift
	info[key[1..-1]] = ilist.shift
      end
      info
    end
  end

  def rowconfiginfo(master, index, slot=nil)
    if slot
      tk_call 'grid', 'rowconfigure', master, index, "-#{slot}"
    else
      ilist = list(tk_call('grid', 'rowconfigure', master, index))
      info = {}
      while key = ilist.shift
	info[key[1..-1]] = ilist.shift
      end
      info
    end
  end

  def add(widget, *args)
    configure(widget, *args)
  end

  def forget(*args)
    tk_call 'grid', 'forget', *args
  end

  def info(slave)
    list(tk_call('grid', 'info', slave))
  end

  def location(master, x, y)
    list(tk_call('grid', 'location', master, x, y))
  end

  def propagate(master, bool=None)
    if bool == None
      bool(tk_call('grid', 'propagate', master.epath))
    else
      tk_call('grid', 'propagate', master.epath, bool)
    end
  end

  def remove(*args)
    tk_call 'grid', 'remove', *args
  end

  def size(master)
    tk_call 'grid', 'size', master
  end

  def slaves(master, args)
    list(tk_call('grid', 'slaves', master, *hash_kv(args)))
  end

  module_function :bbox, :forget, :propagate, :info
  module_function :remove, :size, :slaves, :location
  module_function :configure, :columnconfigure, :rowconfigure
  module_function :columnconfiginfo, :rowconfiginfo
end

module TkPlace
  include Tk
  extend Tk

  def configure(win, slot, value=None)
    if slot.kind_of? Hash
      tk_call 'place', 'configure', win.epath, *hash_kv(slot)
    else
      tk_call 'place', 'configure', win.epath, "-#{slot}", value
    end
  end

  def configinfo(win, slot = nil)
    # for >= Tk8.4a2 ?
    if slot
      conf = tk_split_list(tk_call('place', 'configure', 
				   win.epath, "-#{slot}") )
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_simplelist(tk_call('place', 'configure', 
				  win.epath)).collect{|conflist|
	conf = tk_split_simplelist(conflist)
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end

  def forget(win)
    tk_call 'place', 'forget', win
  end

  def info(win)
    ilist = list(tk_call('place', 'info', win.epath))
    info = {}
    while key = ilist.shift
      info[key[1..-1]] = ilist.shift
    end
    return info
  end

  def slaves(master)
    list(tk_call('place', 'slaves', master.epath))
  end

  module_function :configure, :configinfo, :forget, :info, :slaves
end

module TkOption
  include Tk
  extend Tk
  def add pat, value, pri=None
    tk_call 'option', 'add', pat, value, pri
  end
  def clear
    tk_call 'option', 'clear'
  end
  def get win, name, klass
    tk_call('option', 'get', win ,name, klass).taint
  end
  def readfile file, pri=None
    tk_call 'option', 'readfile', file, pri
  end
  module_function :add, :clear, :get, :readfile

  # support procs on the resource database
  @@@@resource_proc_class = Class.new
  class << @@@@resource_proc_class
    private :new

    CARRIER    = '.'.freeze
    METHOD_TBL = {}
    ADD_METHOD = false
    SAFE_MODE  = 4

    def __check_proc_string__(str)
      # If you want to check the proc_string, do it in this method.
      str
    end

    def method_missing(id, *args)
      res_proc = self::METHOD_TBL[id]
      unless res_proc.kind_of? Proc
        if id == :new || (!self::METHOD_TBL.has_key?(id) && !self::ADD_METHOD)
          raise NoMethodError, 
                "not support resource-proc '#{id.id2name}' for #{self.name}"
        end
        proc_str = TkOption.get(self::CARRIER, id.id2name, '')
        proc_str = '{' + proc_str + '}' unless /\A\{.*\}\Z/ =~ proc_str
        proc_str = __check_proc_string__(proc_str)
        res_proc = eval 'Proc.new' + proc_str
        self::METHOD_TBL[id] = res_proc
      end
      proc{
         $SAFE = self::SAFE_MODE
         res_proc.call(*args)
      }.call
    end

    private :__check_proc_string__, :method_missing
  end

  def new_proc_class(klass, func, safe = 4, add = false, parent = nil)
    klass = klass.to_s if klass.kind_of? Symbol
    unless (?A..?Z) === klass[0]
      fail ArgumentError, "bad string '#{klass}' for class name"
    end
    unless func.kind_of? Array
      fail ArgumentError, "method-list must be Array"
    end
    func_str = func.join(' ')
    if parent == nil
      install_win(parent)
    elsif parent <= @@@@resource_proc_class
      install_win(parent::CARRIER)
    else
      fail ArgumentError, "parent must be Resource-Proc class"
    end
    carrier = Tk.tk_call('frame', @@path, '-class', klass)

    body = <<-"EOD"
      class #{klass} < TkOption.module_eval('@@@@resource_proc_class')
        CARRIER    = '#{carrier}'.freeze
        METHOD_TBL = {}
        ADD_METHOD = #{add}
        SAFE_MODE  = #{safe}
        %w(#{func_str}).each{|f| METHOD_TBL.delete(f.intern) }
      end
    EOD

    if parent.kind_of?(Class) && parent <= @@@@resource_proc_class
      parent.class_eval body
      eval parent.name + '::' + klass
    else
      eval body
      eval 'TkOption::' + klass
    end
  end
  module_function :new_proc_class
end

module TkTreatFont
  def font_configinfo
    ret = TkFont.used_on(self.path)
    if ret == nil
      ret = TkFont.init_widget_font(self.path, self.path, 'configure')
    end
    ret
  end
  alias fontobj font_configinfo

  def font_configure(slot)
    slot = _symbolkey2str(slot)
    if (fnt = slot.delete('font'))
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(self.path, self.path,'configure',slot)
      else
	latinfont_configure(fnt) if fnt
      end
    end
    if (ltn = slot.delete('latinfont'))
      latinfont_configure(ltn) if ltn
    end
    if (ltn = slot.delete('asciifont'))
      latinfont_configure(ltn) if ltn
    end
    if (knj = slot.delete('kanjifont'))
      kanjifont_configure(knj) if knj
    end

    tk_call(self.path, 'configure', *hash_kv(slot)) if slot != {}
    self
  end

  def latinfont_configure(ltn, keys=nil)
    fobj = fontobj
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val}
      if keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciifont_configure latinfont_configure

  def kanjifont_configure(knj, keys=nil)
    fobj = fontobj
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val}
      if keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(cond)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def font_copy(window, tag=nil)
    if tag
      window.tagfontobj(tag).configinfo.each{|key,value|
	fontobj.configure(key,value)
      }
      fontobj.replace(window.tagfontobj(tag).latin_font, 
		      window.tagfontobj(tag).kanji_font)
    else
      window.fontobj.configinfo.each{|key,value|
	fontobj.configure(key,value)
      }
      fontobj.replace(window.fontobj.latin_font, window.fontobj.kanji_font)
    end
  end

  def latinfont_copy(window, tag=nil)
    if tag
      fontobj.latin_replace(window.tagfontobj(tag).latin_font)
    else
      fontobj.latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciifont_copy latinfont_copy

  def kanjifont_copy(window, tag=nil)
    if tag
      fontobj.kanji_replace(window.tagfontobj(tag).kanji_font)
    else
      fontobj.kanji_replace(window.fontobj.kanji_font)
    end
  end
end

module TkTreatItemFont
  def __conf_cmd(idx)
    raise NotImplementError, "need to define `__conf_cmd'"
  end
  def __item_pathname(tagOrId)
    raise NotImplementError, "need to define `__item_pathname'"
  end
  private :__conf_cmd, :__item_pathname

  def tagfont_configinfo(tagOrId)
    pathname = __item_pathname(tagOrId)
    ret = TkFont.used_on(pathname)
    if ret == nil
      ret = TkFont.init_widget_font(pathname, self.path, 
				    __conf_cmd(0), __conf_cmd(1), tagOrId)
    end
    ret
  end
  alias tagfontobj tagfont_configinfo

  def tagfont_configure(tagOrId, slot)
    pathname = __item_pathname(tagOrId)
    slot = _symbolkey2str(slot)
    if (fnt = slot.delete('font'))
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(pathname, self.path, 
				       __conf_cmd(0), __conf_cmd(1), 
				       tagOrId, slot)
      else
	latintagfont_configure(tagOrId, fnt) if fnt
      end
    end
    if (ltn = slot.delete('latinfont'))
      latintagfont_configure(tagOrId, ltn) if ltn
    end
    if (ltn = slot.delete('asciifont'))
      latintagfont_configure(tagOrId, ltn) if ltn
    end
    if (knj = slot.delete('kanjifont'))
      kanjitagfont_configure(tagOrId, knj) if knj
    end

    tk_call(self.path, __conf_cmd(0), __conf_cmd(1), 
	    tagOrId, *hash_kv(slot)) if slot != {}
    self
  end

  def latintagfont_configure(tagOrId, ltn, keys=nil)
    fobj = tagfontobj(tagOrId)
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.latin_replace(ltn)
	fobj.latin_configure(keys) if keys
      elsif keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciitagfont_configure latintagfont_configure

  def kanjitagfont_configure(tagOrId, knj, keys=nil)
    fobj = tagfontobj(tagOrId)
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.kanji_replace(knj)
	fobj.kanji_configure(keys) if keys
      elsif keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(conf)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def tagfont_copy(tagOrId, window, wintag=nil)
    if wintag
      window.tagfontobj(wintag).configinfo.each{|key,value|
	tagfontobj(tagOrId).configure(key,value)
      }
      tagfontobj(tagOrId).replace(window.tagfontobj(wintag).latin_font, 
				window.tagfontobj(wintag).kanji_font)
    else
      window.tagfont(wintag).configinfo.each{|key,value|
	tagfontobj(tagOrId).configure(key,value)
      }
      tagfontobj(tagOrId).replace(window.fontobj.latin_font, 
				window.fontobj.kanji_font)
    end
  end

  def latintagfont_copy(tagOrId, window, wintag=nil)
    if wintag
      tagfontobj(tagOrId).latin_replace(window.tagfontobj(wintag).latin_font)
    else
      tagfontobj(tagOrId).latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciitagfont_copy latintagfont_copy

  def kanjitagfont_copy(tagOrId, window, wintag=nil)
    if wintag
      tagfontobj(tagOrId).kanji_replace(window.tagfontobj(wintag).kanji_font)
    else
      tagfontobj(tagOrId).kanji_replace(window.fontobj.kanji_font)
    end
  end
end

class TkObject<TkKernel
  include Tk
  include TkTreatFont
  include TkBindCore

  def path
    return @@path
  end

  def epath
    return @@path
  end

  def to_eval
    @@path
  end

  def tk_send(cmd, *rest)
    tk_call path, cmd, *rest
  end
  private :tk_send

  def method_missing(id, *args)
    name = id.id2name
    case args.length
    when 1
      configure name, args[0]
    when 0
      begin
	cget name
      rescue
	fail NameError, "undefined local variable or method `#{name}' for #{self.to_s}", error_at
      end
    else
      fail NameError, "undefined method `#{name}' for #{self.to_s}", error_at
    end
  end

  def [](id)
    cget id
  end

  def []=(id, val)
    configure id, val
  end

  def cget(slot)
    case slot.to_s
    when 'text', 'label', 'show', 'data', 'file'
      tk_call path, 'cget', "-#{slot}"
    else
      tk_tcl2ruby tk_call(path, 'cget', "-#{slot}")
    end
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      if (slot['font'] || slot[:font] || 
          slot['kanjifont'] || slot[:kanjifont] || 
	  slot['latinfont'] || slot[:latinfont] || 
          slot['asciifont'] || slot[:asciifont] )
	font_configure(slot)
      else
	tk_call path, 'configure', *hash_kv(slot)
      end

    else
      if (slot == 'font' || slot == :font || 
          slot == 'kanjifont' || slot == :kanjifont || 
	  slot == 'latinfont' || slot == :latinfont || 
          slot == 'asciifont' || slot == :asciifont )
	if value == None
	  fontobj
	else
	  font_configure({slot=>value})
	end
      else
	tk_call path, 'configure', "-#{slot}", value
      end
    end
  end

  def configure_cmd(slot, value)
    configure slot, install_cmd(value)
  end

  def configinfo(slot = nil)
    if slot == 'font' || slot == :font || 
       slot == 'kanjifont' || slot == :kanjifont
      fontobj
    else
      if slot
	case slot.to_s
	when 'text', 'label', 'show', 'data', 'file'
	  conf = tk_split_simplelist(tk_send('configure', "-#{slot}") )
	else
	  conf = tk_split_list(tk_send('configure', "-#{slot}") )
	end
	conf[0] = conf[0][1..-1]
	conf
      else
	ret = tk_split_simplelist(tk_send('configure') ).collect{|conflist|
	  conf = tk_split_simplelist(conflist)
	  conf[0] = conf[0][1..-1]
	  case conf[0]
	  when 'text', 'label', 'show', 'data', 'file'
	  else
	    if conf[3]
	      if conf[3].index('{')
		conf[3] = tk_split_list(conf[3]) 
	      else
		conf[3] = tk_tcl2ruby(conf[3]) 
	      end
	    end
	    if conf[4]
	      if conf[4].index('{')
		conf[4] = tk_split_list(conf[4]) 
	      else
		conf[4] = tk_tcl2ruby(conf[4]) 
	      end
	    end
	  end
	  conf
	}
	fontconf = ret.assoc('font')
	if fontconf
	  ret.delete_if{|item| item[0] == 'font' || item[0] == 'kanjifont'}
	  fontconf[4] = fontobj
	  ret.push(fontconf)
	else
	  ret
	end
      end
    end
  end

  def event_generate(context, keys=nil)
    if keys
      tk_call('event', 'generate', path, 
	      "<#{tk_event_sequence(context)}>", *hash_kv(keys))
    else
      tk_call('event', 'generate', path, "<#{tk_event_sequence(context)}>")
    end
  end

  def tk_trace_variable(v)
    unless v.kind_of?(TkVariable)
      fail ArgumentError, format("requires TkVariable given %s", v.type)
    end
    v
  end
  private :tk_trace_variable

  def destroy
    tk_call 'trace', 'vdelete', @@tk_vn, 'w', @@var_id if @@var_id
  end
end

class TkWindow<TkObject
  extend TkBindCore

  def initialize(parent=nil, keys=nil)
    if parent.kind_of? Hash
      keys = _symbolkey2str(parent)
      keydup = true
      parent = keys.delete('parent')
      widgetname = keys.delete('widgetname')
      install_win(if parent then parent.path end, widgetname)
    elsif keys
      keys = _symbolkey2str(keys)
      widgetname = keys.delete('widgetname')
      install_win(if parent then parent.path end, widgetname)
    else
      install_win(if parent then parent.path end)
    end
    if self.method(:create_self).arity == 0
      p 'create_self has no arg' if $DEBUG
      create_self
      if keys
	# tk_call @@path, 'configure', *hash_kv(keys)
	configure(keys)
      end
    else
      p 'create_self has args' if $DEBUG
      fontkeys = {}
      if keys
	['font', 'kanjifont', 'latinfont', 'asciifont'].each{|key|
	  fontkeys[key] = keys.delete(key) if keys.key?(key)
	}
      end
      create_self(keys)
      font_configure(fontkeys) unless fontkeys.empty?
    end
  end

  def create_self
  end
  private :create_self

  def pack(keys = nil)
    tk_call 'pack', epath, *hash_kv(keys)
    self
  end

  def unpack
    tk_call 'pack', 'forget', epath
    self
  end
  alias pack_forget unpack

  def pack_config(slot, value=None)
    if slot.kind_of? Hash
      tk_call 'pack', 'configure', epath, *hash_kv(slot)
    else
      tk_call 'pack', 'configure', epath, "-#{slot}", value
    end
  end

  def pack_info()
    ilist = list(tk_call('pack', 'info', epath))
    info = {}
    while key = ilist.shift
      info[key[1..-1]] = ilist.shift
    end
    return info
  end

  def pack_propagate(mode = nil)
    if mode
      tk_call('pack', 'propagate', epath, mode)
    else
      bool(tk_call('pack', 'propagate', epath))
    end
  end

  def pack_slaves()
    list(tk_call('pack', 'slaves', epath))
  end

  def grid(keys = nil)
    tk_call 'grid', epath, *hash_kv(keys)
    self
  end

  def ungrid
    tk_call 'grid', 'forget', epath
    self
  end
  alias grid_forget ungrid

  def grid_bbox(*args)
    list(tk_call('grid', 'bbox', epath, *args))
  end

  def grid_config(slot, value=None)
    if slot.kind_of? Hash
      tk_call 'grid', 'configure', epath, *hash_kv(slot)
    else
      tk_call 'grid', 'configure', epath, "-#{slot}", value
    end
  end

  def grid_columnconfig(index, keys)
    tk_call('grid', 'columnconfigure', epath, index, *hash_kv(keys))
  end

  def grid_rowconfig(index, keys)
    tk_call('grid', 'rowconfigure', epath, index, *hash_kv(keys))
  end

  def grid_columnconfiginfo(index, slot=nil)
    if slot
      tk_call('grid', 'columnconfigure', epath, index, "-#{slot}")
    else
      ilist = list(tk_call('grid', 'columnconfigure', epath, index))
      info = {}
      while key = ilist.shift
	info[key[1..-1]] = ilist.shift
      end
      info
    end
  end

  def grid_rowconfiginfo(index, slot=nil)
    if slot
      tk_call('grid', 'rowconfigure', epath, index, "-#{slot}")
    else
      ilist = list(tk_call('grid', 'rowconfigure', epath, index))
      info = {}
      while key = ilist.shift
	info[key[1..-1]] = ilist.shift
      end
      info
    end
  end

  def grid_info()
    list(tk_call('grid', 'info', epath))
  end

  def grid_location(x, y)
    list(tk_call('grid', 'location', epath, x, y))
  end

  def grid_propagate(mode=nil)
    if mode
      tk_call('grid', 'propagate', epath, mode)
    else
      bool(tk_call('grid', 'propagate', epath))
    end
  end

  def grid_remove()
    tk_call 'grid', 'remove', epath
  end

  def grid_size()
    tk_call 'grid', 'size', epath
  end

  def grid_slaves(args)
    list(tk_call('grid', 'slaves', epath, *hash_kv(args)))
  end

  def place(keys = nil)
    tk_call 'place', epath, *hash_kv(keys)
    self
  end

  def unplace
    tk_call 'place', 'forget', epath
    self
  end
  alias place_forget unplace

  def place_config(slot, value=None)
    if slot.kind_of? Hash
      tk_call 'place', 'configure', epath, *hash_kv(slot)
    else
      tk_call 'place', 'configure', epath, "-#{slot}", value
    end
  end

  def place_configinfo(slot = nil)
    # for >= Tk8.4a2 ?
    if slot
      conf = tk_split_list(tk_call('place', 'configure', epath, "-#{slot}") )
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_simplelist(tk_call('place', 
				  'configure', epath)).collect{|conflist|
	conf = tk_split_simplelist(conflist)
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end

  def place_info()
    ilist = list(tk_call('place', 'info', epath))
    info = {}
    while key = ilist.shift
      info[key[1..-1]] = ilist.shift
    end
    return info
  end

  def place_slaves()
    list(tk_call('place', 'slaves', epath))
  end

  def focus(force=false)
    if force
      tk_call 'focus', '-force', path
    else
      tk_call 'focus', path
    end
    self
  end

  def grab(*args)
    if !args or args.length == 0
      tk_call 'grab', 'set', path
    elsif args.length == 1
      case args[0]
      when 'global', :global
	return(tk_call('grab', 'set', '-global', path))
      when 'release', :release
	return tk_call('grab', 'release', path)
      else
	val = tk_call('grab', args[0], path)
      end
      case args[0]
      when 'current', :current
	return window(val)
      when 'status', :status
	return val
      end
    else
      fail ArgumentError, 'wrong # of args'
    end
  end

  def lower(below=None)
    tk_call 'lower', epath, below
    self
  end
  def raise(above=None)
    tk_call 'raise', epath, above
    self
  end

  def command(cmd=Proc.new)
    configure_cmd 'command', cmd
  end

  def colormodel model=None
    tk_call 'tk', 'colormodel', path, model
    self
  end

  def destroy
    super
    tk_call 'destroy', epath
    if @@cmdtbl
      for id in @@cmdtbl
	uninstall_cmd id
      end
    end
    uninstall_win
  end

  def wait_visibility
    tk_call 'tkwait', 'visibility', path
  end
  alias wait wait_visibility

  def wait_destroy
    tk_call 'tkwait', 'window', epath
  end

  def bindtags(taglist=nil)
    if taglist
      fail ArgumentError unless taglist.kind_of? Array
      tk_call('bindtags', path, taglist)
    else
      list(tk_call('bindtags', path)).collect{|tag|
	if tag.kind_of?(String) 
	  if cls = WidgetClassNames[tag]
	    cls
	  elsif btag = TkBindTag.id2obj(tag)
	    btag
	  else
	    tag
	  end
	else
	  tag
	end
      }
    end
  end
end

class TkRoot<TkWindow
  include Wm
  ROOT = []
  def TkRoot.new
    return ROOT[0] if ROOT[0]
    new = super
    ROOT[0] = new
    Tk_WINDOWS["."] = new
  end

  WidgetClassName = 'Tk'.freeze
  WidgetClassNames[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def create_self
    @@path = '.'
  end
  def path
    "."
  end
end

class TkToplevel<TkWindow
  include Wm

  WidgetClassName = 'Toplevel'.freeze
  WidgetClassNames[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

################# old version
#  def initialize(parent=nil, screen=nil, classname=nil, keys=nil)
#    if screen.kind_of? Hash
#      keys = screen.dup
#    else
#      @@screen = screen
#    end
#    @@classname = classname
#    if keys.kind_of? Hash
#      keys = keys.dup
#      @@classname = keys.delete('classname') if keys.key?('classname')
#      @@colormap  = keys.delete('colormap')  if keys.key?('colormap')
#      @@container = keys.delete('container') if keys.key?('container')
#      @@screen    = keys.delete('screen')    if keys.key?('screen')
#      @@use       = keys.delete('use')       if keys.key?('use')
#      @@visual    = keys.delete('visual')    if keys.key?('visual')
#    end
#    super(parent, keys)
#  end
#
#  def create_self
#    s = []
#    s << "-class"     << @@classname if @@classname
#    s << "-colormap"  << @@colormap  if @@colormap
#    s << "-container" << @@container if @@container
#    s << "-screen"    << @@screen    if @@screen 
#    s << "-use"       << @@use       if @@use
#    s << "-visual"    << @@visual    if @@visual
#    tk_call 'toplevel', @@path, *s
#  end
#################

  def initialize(parent=nil, screen=nil, classname=nil, keys=nil)
    if parent.kind_of? Hash
      keys = _symbolkey2str(parent)
      @@screen    = keys['screen']
      @@classname = keys['class']
      @@colormap  = keys['colormap']
      @@container = keys['container']
      @@screen    = keys['screen']
      @@use       = keys['use']
      @@visual    = keys['visual']
      super(keys)
      return
    end
    if screen.kind_of? Hash
      keys = _symbolkey2str(screen)
    else
      @@screen = screen
    end
    @@classname = classname
    if keys.kind_of? Hash
      keys = _symbolkey2str(keys)
      if keys.key?(:classname) || keys.key?('classname')
	keys['class'] = keys.delete('classname')
      end
      @@classname = keys['class']
      @@colormap  = keys['colormap']
      @@container = keys['container']
      @@screen    = keys['screen']
      @@use       = keys['use']
      @@visual    = keys['visual']
    end
    super(parent, keys)
  end

  def create_self(keys)
    if keys and keys != None
      tk_call 'toplevel', @@path, *hash_kv(keys)
    else
      tk_call 'toplevel', @@path
    end
  end

  def specific_class
    @@classname
  end
end

class TkFrame<TkWindow
  WidgetClassName = 'Frame'.freeze
  WidgetClassNames[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

################# old version
#  def initialize(parent=nil, keys=nil)
#    if keys.kind_of? Hash
#      keys = keys.dup
#      @@classname = keys.delete('classname') if keys.key?('classname')
#      @@colormap  = keys.delete('colormap')  if keys.key?('colormap')
#      @@container = keys.delete('container') if keys.key?('container')
#      @@visual    = keys.delete('visual')    if keys.key?('visual')
#    end
#    super(parent, keys)
#  end
#
#  def create_self
#    s = []
#    s << "-class"     << @@classname if @@classname
#    s << "-colormap"  << @@colormap  if @@colormap
#    s << "-container" << @@container if @@container
#    s << "-visual"    << @@visual    if @@visual
#    tk_call 'frame', @@path, *s
#  end
#################

  def initialize(parent=nil, keys=nil)
    if parent.kind_of? Hash
      keys = _symbolkey2str(parent)
    else
      if keys
        keys = _symbolkey2str(keys)
        keys['parent'] = parent
      else
        keys = {'parent'=>parent}
      end
    end
    if keys.key?('classname')
       keys['class'] = keys.delete('classname')
    end
    @@classname = keys['class']
    @@colormap  = keys['colormap']
    @@container = keys['container']
    @@visual    = keys['visual']
    super(keys)
  end

  def create_self(keys)
    if keys and keys != None
      tk_call 'frame', @@path, *hash_kv(keys)
    else
      tk_call 'frame', @@path
    end
  end
end

class TkLabel<TkWindow
  WidgetClassName = 'Label'.freeze
  WidgetClassNames[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end
  def create_self(keys)
    if keys and keys != None
      tk_call 'label', @@path, *hash_kv(keys)
    else
      tk_call 'label', @@path
    end
  end
  def textvariable(v)
    configure 'textvariable', tk_trace_variable(v)
  end
end

class TkButton<TkLabel
  WidgetClassNames['Button'] = self
  def TkButton.to_eval
    'Button'
  end
  def create_self(keys)
    if keys and keys != None
      tk_call 'button', @@path, *hash_kv(keys)
    else
      tk_call 'button', @@path
    end
  end
  def invoke
    tk_send 'invoke'
  end
  def flash
    tk_send 'flash'
  end
end

class TkRadioButton<TkButton
  WidgetClassNames['Radiobutton'] = self
  def TkRadioButton.to_eval
    'Radiobutton'
  end
  def create_self(keys)
    if keys and keys != None
      tk_call 'radiobutton', @@path, *hash_kv(keys)
    else
      tk_call 'radiobutton', @@path
    end
  end
  def deselect
    tk_send 'deselect'
  end
  def select
    tk_send 'select'
  end
  def variable(v)
    configure 'variable', tk_trace_variable(v)
  end
end
TkRadiobutton = TkRadioButton

class TkCheckButton<TkRadioButton
  WidgetClassNames['Checkbutton'] = self
  def TkCheckButton.to_eval
    'Checkbutton'
  end
  def create_self(keys)
    if keys and keys != None
      tk_call 'checkbutton', @@path, *hash_kv(keys)
    else
      tk_call 'checkbutton', @@path
    end
  end
  def toggle
    tk_send 'toggle'
  end
end
TkCheckbutton = TkCheckButton

class TkMessage<TkLabel
  WidgetClassNames['Message'] = self
  def TkMessage.to_eval
    'Message'
  end
  def create_self(keys)
    if keys and keys != None
      tk_call 'message', @@path, *hash_kv(keys)
    else
      tk_call 'message', @@path
    end
  end
end

class TkScale<TkWindow
  WidgetClassName = 'Scale'.freeze
  WidgetClassNames[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def create_self(keys)
    if keys and keys != None
      tk_call 'scale', @@path, *hash_kv(keys)
    else
      tk_call 'scale', @@path
    end
  end

  def get(x=None, y=None)
    number(tk_send('get', x, y))
  end

  def coords(val=None)
    tk_split_list(tk_send('coords', val))
  end

  def identify(x, y)
    tk_send('identify', x, y)
  end

  def set(val)
    tk_send "set", val
  end

  def value
    get
  end

  def value= (val)
    set val
  end
end

class TkScrollbar<TkWindow
  WidgetClassName = 'Scrollbar'.freeze
  WidgetClassNames[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def create_self(keys)
    if keys and keys != None
      tk_call 'scrollbar', @@path, *hash_kv(keys)
    else
      tk_call 'scrollbar', @@path
    end
  end

  def delta(deltax=None, deltay=None)
    number(tk_send('delta', deltax, deltay))
  end

  def fraction(x=None, y=None)
    number(tk_send('fraction', x, y))
  end

  def identify(x, y)
    tk_send('identify', x, y)
  end

  def get
    ary1 = tk_send('get').split
    ary2 = []
    for i in ary1
      ary2.push number(i)
    end
    ary2
  end

  def set(first, last)
    tk_send "set", first, last
  end

  def activate(element=None)
    tk_send('activate', element)
  end
end

class TkTextWin<TkWindow
  def create_self
    fail TypeError, "TkTextWin is abstract class"
  end

  def bbox(index)
    tk_send 'bbox', index
  end
  def delete(first, last=None)
    tk_send 'delete', first, last
  end
  def get(*index)
    tk_send 'get', *index
  end
  def index(index)
    tk_send 'index', index
  end
  def insert(index, chars, *args)
    tk_send 'insert', index, chars, *args
  end
  def scan_mark(x, y)
    tk_send 'scan', 'mark', x, y
  end
  def scan_dragto(x, y)
    tk_send 'scan', 'dragto', x, y
  end
  def see(index)
    tk_send 'see', index
  end
end

module TkTreatListItemFont
  include TkTreatItemFont

  ItemCMD = ['itemconfigure', TkComm::None]
  def __conf_cmd(idx)
    ItemCMD[idx]
  end

  def __item_pathname(tagOrId)
    self.path + ';' + tagOrId.to_s
  end
end

class TkListbox<TkTextWin
  include TkTreatListItemFont
  include Scrollable

  WidgetClassNames['Listbox'] = self
  def TkListbox.to_eval
    'Listbox'
  end
  def create_self(keys)
    if keys and keys != None
      tk_call 'listbox', @@path, *hash_kv(keys)
    else
      tk_call 'listbox', @@path
    end
  end

  def activate(y)
    tk_send 'activate', y
  end
  def curselection
    list(tk_send('curselection'))
  end
  def get(*index)
    v = tk_send('get', *index)
    if index.size == 1
      v
    else
      tk_split_simplelist(v)
    end
  end
  def nearest(y)
    tk_send('nearest', y).to_i
  end
  def size
    tk_send('size').to_i
  end
  def selection_anchor(index)
    tk_send 'selection', 'anchor', index
  end
  def selection_clear(first, last=None)
    tk_send 'selection', 'clear', first, last
  end
  def selection_includes(index)
    bool(tk_send('selection', 'includes', index))
  end
  def selection_set(first, last=None)
    tk_send 'selection', 'set', first, last
  end

  def itemcget(index, key)
    case key.to_s
    when 'text', 'label', 'show'
      tk_send 'itemcget', index, "-#{key}"
    else
      tk_tcl2ruby tk_send('itemcget', index, "-#{key}")
    end
  end
  def itemconfigure(index, key, val=None)
    if key.kind_of? Hash
      if (key['font'] || key[:font] || 
          key['kanjifont'] || key[:kanjifont] || 
	  key['latinfont'] || key[:latinfont] || 
          key['asciifont'] || key[:asciifont] )
	tagfont_configure(index, _symbolkey2str(key))
      else
	tk_send 'itemconfigure', index, *hash_kv(key)
      end

    else
      if (key == 'font' || key == :font || 
          key == 'kanjifont' || key == :kanjifont || 
	  key == 'latinfont' || key == :latinfont || 
          key == 'asciifont' || key == :asciifont )
	tagfont_configure(index, {key=>val})
      else
	tk_call 'itemconfigure', index, "-#{key}", val
      end
    end
  end

  def itemconfiginfo(index, key=nil)
    if key
      case key.to_s
      when 'text', 'label', 'show'
	conf = tk_split_simplelist(tk_send('itemconfigure',index,"-#{key}"))
      else
	conf = tk_split_list(tk_send('itemconfigure',index,"-#{key}"))
      end
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_simplelist(tk_send('itemconfigure', index)).collect{|conflist|
	conf = tk_split_simplelist(conflist)
	conf[0] = conf[0][1..-1]
	case conf[0]
	when 'text', 'label', 'show'
	else
	  if conf[3]
	    if conf[3].index('{')
	      conf[3] = tk_split_list(conf[3]) 
	    else
	      conf[3] = tk_tcl2ruby(conf[3]) 
	    end
	  end
	  if conf[4]
	    if conf[4].index('{')
	      conf[4] = tk_split_list(conf[4]) 
	    else
	      conf[4] = tk_tcl2ruby(conf[4]) 
	    end
	  end
	end
	conf
      }
    end
  end
end

module TkTreatMenuEntryFont
  include TkTreatItemFont

  ItemCMD = ['entryconfigure', TkComm::None]
  def __conf_cmd(idx)
    ItemCMD[idx]
  end
  
  def __item_pathname(tagOrId)
    self.path + ';' + tagOrId.to_s
  end
end

class TkMenu<TkWindow
  include TkTreatMenuEntryFont

  WidgetClassName = 'Menu'.freeze
  WidgetClassNames[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end
  def create_self(keys)
    if keys and keys != None
      tk_call 'menu', @@path, *hash_kv(keys)
    else
      tk_call 'menu', @@path
    end
  end
  def activate(index)
    tk_send 'activate', index
  end
  def add(type, keys=nil)
    tk_send 'add', type, *hash_kv(keys)
  end
  def index(index)
    tk_send 'index', index
  end
  def invoke(index)
    tk_send 'invoke', index
  end
  def insert(index, type, keys=nil)
    tk_send 'insert', index, type, *hash_kv(keys)
  end
  def delete(index, last=None)
    tk_send 'delete', index, last
  end
  def popup(x, y, index=None)
    tk_call 'tk_popup', path, x, y, index
  end
  def post(x, y)
    tk_send 'post', x, y
  end
  def postcascade(index)
    tk_send 'postcascade', index
  end
  def postcommand(cmd=Proc.new)
    configure_cmd 'postcommand', cmd
  end
  def tearoffcommand(cmd=Proc.new)
    configure_cmd 'tearoffcommand', cmd
  end
  def menutype(index)
    tk_send 'type', index
  end
  def unpost
    tk_send 'unpost'
  end
  def yposition(index)
    number(tk_send('yposition', index))
  end
  def entrycget(index, key)
    case key.to_s
    when 'text', 'label', 'show'
      tk_send 'entrycget', index, "-#{key}"
    else
      tk_tcl2ruby tk_send('entrycget', index, "-#{key}")
    end
  end
  def entryconfigure(index, key, val=None)
    if key.kind_of? Hash
      if (key['font'] || key[:font] || 
          key['kanjifont'] || key[:kanjifont] || 
	  key['latinfont'] || key[:latinfont] || 
          key['asciifont'] || key[:asciifont])
	tagfont_configure(index, _symbolkey2str(key))
      else
	tk_send 'entryconfigure', index, *hash_kv(key)
      end

    else
      if (key == 'font' || key == :font || 
          key == 'kanjifont' || key == :kanjifont || 
	  key == 'latinfont' || key == :latinfont || 
          key == 'asciifont' || key == :asciifont )
	tagfont_configure({key=>val})
      else
	tk_call 'entryconfigure', index, "-#{key}", val
      end
    end
  end

  def entryconfiginfo(index, key=nil)
    if key
      case key.to_s
      when 'text', 'label', 'show'
	conf = tk_split_simplelist(tk_send('entryconfigure',index,"-#{key}"))
      else
	conf = tk_split_list(tk_send('entryconfigure',index,"-#{key}"))
      end
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_simplelist(tk_send('entryconfigure', index)).collect{|conflist|
	conf = tk_split_simplelist(conflist)
	conf[0] = conf[0][1..-1]
	case conf[0]
	when 'text', 'label', 'show'
	else
	  if conf[3]
	    if conf[3].index('{')
	      conf[3] = tk_split_list(conf[3]) 
	    else
	      conf[3] = tk_tcl2ruby(conf[3]) 
	    end
	  end
	  if conf[4]
	    if conf[4].index('{')
	      conf[4] = tk_split_list(conf[4]) 
	    else
	      conf[4] = tk_tcl2ruby(conf[4]) 
	    end
	  end
	end
	conf
      }
    end
  end
end

class TkMenuClone<TkMenu
  def initialize(parent, type=None)
    widgetname = nil
    if parent.kind_of? Hash
      keys = _symbolkey2str(parent)
      parent = keys.delete('parent')
      widgetname = keys.delete('widgetname')
      type = keys.delete('type'); type = None unless type
    end
    unless parent.kind_of?(TkMenu)
      fail ArgumentError, "parent must be TkMenu"
    end
    @@parent = parent
    install_win(@@parent.path, widgetname)
    tk_call @@parent.path, 'clone', @@path, type
  end
end

module TkSystemMenu
  def initialize(parent, keys=nil)
    if parent.kind_of? Hash
      keys = _symbolkey2str(parent)
      parent = keys.delete('parent')
    end
    fail unless parent.kind_of? TkMenu
    @@path = format("%s.%s", parent.path, self.type::SYSMENU_NAME)
    TkComm::Tk_WINDOWS[@@path] = self
    if self.method(:create_self).arity == 0
      p 'create_self has no arg' if $DEBUG
      create_self
      configure(keys) if keys
    else
      p 'create_self has an arg' if $DEBUG
      create_self(keys)
    end
  end
end

class TkSysMenu_Help<TkMenu
  # for all platform
  include TkSystemMenu
  SYSMENU_NAME = 'help'
end

class TkSysMenu_System<TkMenu
  # for Windows
  include TkSystemMenu
  SYSMENU_NAME = 'system'
end

class TkSysMenu_Apple<TkMenu
  # for Machintosh
  include TkSystemMenu
  SYSMENU_NAME = 'apple'
end

class TkMenubutton<TkLabel
  WidgetClassNames['Menubutton'] = self
  def TkMenubutton.to_eval
    'Menubutton'
  end
  def create_self(keys)
    if keys and keys != None
      tk_call 'menubutton', @@path, *hash_kv(keys)
    else
      tk_call 'menubutton', @@path
    end
  end
end

class TkOptionMenubutton<TkMenubutton
  class OptionMenu<TkMenu
    def initialize(parent)
      @@path = parent.path + '.menu'
      TkComm::Tk_WINDOWS[@@path] = self
    end
  end

  def initialize(parent=nil, var=TkVariable.new, firstval=nil, *vals)
    if parent.kind_of Hash
       keys = _symbolkey2str(parent)
       parent = keys['parent']
       var = keys['variable'] if keys['variable']
       firstval, *vals = keys['values']
    end
    fail unless var.kind_of? TkVariable
    @@variable = var
    firstval = @@variable.value unless firstval
    @@variable.value = firstval
    install_win(if parent then parent.path end)
    @@menu = OptionMenu.new(self)
    tk_call 'tk_optionMenu', @@path, @@variable.id, firstval, *vals
  end

  def value
    @@variable.value
  end

  def activate(index)
    @@menu.activate(index)
  end
  def add(value)
    @@menu.add('radiobutton', 'variable'=>@@variable, 
	      'label'=>value, 'value'=>value)
  end
  def index(index)
    @@menu.index(index)
  end
  def invoke(index)
    @@menu.invoke(index)
  end
  def insert(index, value)
    @@menu.add(index, 'radiobutton', 'variable'=>@@variable, 
	      'label'=>value, 'value'=>value)
  end
  def delete(index, last=None)
    @@menu.delete(index, last)
  end
  def yposition(index)
    @@menu.yposition(index)
  end
  def menucget(index, key)
    @@menu.cget(index, key)
  end
  def menuconfigure(index, key, val=None)
    @@menu.configure(index, key, val)
  end
  def menuconfiginfo(index, key=nil)
    @@menu.configinfo(index, key)
  end
  def entrycget(index, key)
    @@menu.entrycget(index, key)
  end
  def entryconfigure(index, key, val=None)
    @@menu.entryconfigure(index, key, val)
  end
  def entryconfiginfo(index, key=nil)
    @@menu.entryconfiginfo(index, key)
  end
end

module TkComposite
  include Tk
  extend Tk

  def initialize(parent=nil, *args)
    if parent.kind_of? Hash
      keys = _symbolkey2str(parent)
      parent = keys['parent']
      keys['parent'] = @@frame = TkFrame.new(parent)
      @@path = @@epath = @@frame.path
      initialize_composite(keys)
    else
      @@frame = TkFrame.new(parent)
      @@path = @@epath = @@frame.path
      initialize_composite(*args)
    end
  end

  def epath
    @@epath
  end

  def initialize_composite(*args) end
  private :initialize_composite

  def delegate(option, *wins)
    unless @@delegates
      @@delegates = {} 
      @@delegates['DEFAULT'] = @@frame
    end
    if @@delegates[option].kind_of?(Array)
      for i in wins
	@@delegates[option].push(i)
      end
    else
      @@delegates[option] = wins
    end
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      slot.each{|slot,value| configure slot, value}
    else
      if @@delegates and @@delegates[slot]
	for i in @@delegates[slot]
	  if not i
	    i = @@delegates['DEFALUT']
	    redo
	  else
	    last = i.configure(slot, value)
	  end
	end
	last
      else
	super
      end
    end
  end
end

module TkClipboard
  include Tk
  extend Tk

  def clear
    tk_call 'clipboard', 'clear'
  end
  def get
    begin
      tk_call 'selection', 'get', '-selection', 'CLIPBOARD'
    rescue
      ''
    end
  end
  def set(data)
    clear
    append(data)
  end
  def append(data)
    tk_call 'clipboard', 'append', data
  end

  module_function :clear, :set, :get, :append
end

autoload :TkCanvas, 'tkcanvas'
autoload :TkImage, 'tkcanvas'
autoload :TkBitmapImage, 'tkcanvas'
autoload :TkPhotoImage, 'tkcanvas'
autoload :TkEntry, 'tkentry'
autoload :TkSpinbox, 'tkentry'
autoload :TkText, 'tktext'
autoload :TkDialog, 'tkdialog'
autoload :TkWarning, 'tkdialog'
autoload :TkMenubar, 'tkmenubar'
autoload :TkAfter, 'tkafter'
autoload :TkPalette, 'tkpalette'
autoload :TkFont, 'tkfont'
autoload :TkVirtualEvent, 'tkvirtevent'
autoload :TkBgError, 'tkbgerror'
autoload :TkManageFocus, 'tkmngfocus'
autoload :TkPalette, 'tkpalette'
autoload :TkWinDDE, 'tkwinpkg'
autoload :TkWinRegistry, 'tkwinpkg'
autoload :TkMacResource, 'tkmacpkg'
@


1.34
log
@* dir.c (glob_helper): prevent memory leak using rb_protect().

* string.c (rb_str_associate): no need to check freeze flag.

* string.c (rb_str_resize): should honor STR_ASSOC flag on
  resize.

* string.c (rb_str_resize): proper STR_ASSOC handling.  pointed
  out by Michal Rokos.

* string.c (rb_str_buf_cat): ditto.

* string.c (rb_str_cat): ditto.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_append): ditto.
@
text
@d3 1
a3 1
#			$Date: 2002/06/28 14:40:25 $
d267 1
a267 1
    Tk_CMDTBL[id] = nil
d285 1
a285 1
    Tk_WINDOWS[@@path] = nil
d2191 1
a2191 1
        %w(#{func_str}).each{|f| METHOD_TBL[f.intern] = nil }
@


1.33
log
@* re.c (rb_reg_expr_str): need to process backslashes properly.

* object.c (rb_any_to_a): declare Object#to_a to be obsolete.

* object.c (rb_Array): do not convert nil into [] automagically.

* object.c (rb_Integer): use "to_int" instead of
  "to_i". [experimental]

* object.c (nil_to_f): new method.

* object.c (rb_Integer): Symbols and nil should cause error.

* object.c (rb_Float): nil should cause error.
@
text
@d3 1
a3 1
#			$Date: 2002/06/04 07:03:33 $
d2844 1
@


1.32
log
@* tkfont.rb:  Fix bugs on TkFont.init_widget_font for Tk8.x.

* tkafter.rb: Add self to 1st argument of interval- and loop-proc
    TkAfter#current_interval returns an interval (sleep) time value
    TkAfter#current_args returns an array of arguments
    TkAfter#return_value returns a return value of last loop-proc
      e.g.
         TkAfter.new(
           proc{|obj| 500 - obj.current_interval}, 10,
           [proc{|obj| p obj.current_args}, 'proc', 1],
           proc{|obj| p obj.current_args; ['return', 2]},
           [proc{|obj|
              p obj.return_value
              p ['proc', obj.current_args[0].call(obj.return_value[1],
                                                  obj.current_args[1])]},
            proc{|*args| args[0] + args[1]}, 1],
           proc{p ['proc', 4]} ).start(100)

* tk*.rb: Allow to use Symbols for parameters.
    Allow new notation of constructor (also allow old notation).
      e.g.
        TkFrame.new('classname'=>'User'){|base|
          pack
          f = TkFrame.new(base, :classname=>'ButtonFrame').pack
          TkButton.new(
             :parent     => f,
             :text       => 'Quit',
             :command    => proc{exit}
          ).pack(
             :fill => :x,
             :pady => 2
          )
        }

* tkcanvas.rb: (TkcItem) Add 'coords' parameter to the canvas item
    constructor (for new notation of constructor).
      e.g.
        c = TkCanvas.new.pack
        l = TkcLine.new(c, :coords=>[[0,0], [100,100]])

* tcltklib.c: New 'mainloop' and 'mainloop_watchdog'.
    The priority of their event-loop can be controlled.
    They accept an optional argument.
    If it false, they don't exit although the root widget is destroyed.
    This function is sometimes useful, if it is used with 'restart'.
    'mainloop' can't treat Thread#join/value in a callback routine.
    (e.g. TkButton.new(:command=>proc{p Thread.new{button.invoke}.value}) )
    'mainloop_watchdog' can treat them, but watchdog thread is always running
    (so, a little heavier than 'mainloop').
    If the purpose of using Thread#join/value is to do something under some
    safe-level, please use Proc object.
    (e.g. :command=>proc{$SAFE=1;proc{$SAFE=2;button.invoke}.call;p $SAFE})

* tk.rb: Support functions of new 'mainloop' and 'mainloop_watchdog'.

* tk.rb: (Tk.restart) Add 'app-name' paramater and 'use' parameter.
    'app-name' specifies the name and the resource class of the
    application. If 'app-name' is specified to 'xxx', the application
    class on the resource database is set to 'Xxx' and the application
    name is changed by the same rule of Tk.appname method.  'use'
    specifies the main window for embedding the root widget instead of
    generating a new window.

* tk.rb: Add new parameter 'widgetname' to the widget constructor to
    support effective use of Resource Database.  For example, the
    resource 'Xxx*quit.text: QUIT' can set the text of the button
    generated by the following code.
      e.g.
        Tk.restart('Xxx')
        TkButton.new(nil, 'widgetname'=>'quit', 'command'=>proc{exit}).pack
        Tk.mainloop

* tk.rb: TkOption::get always returns a tainted string.
    Add TkOption::new_proc_class.
    It generates a class to import procedures defined on the resource
    database. For example, there is a following resource file.
      ----< resource-test >------------
      *CMD.foo: {|*args| p [$SAFE, :foo, args]}
      *CMD.XXX.bar: {|*args| p [$SAFE, :bar, args]}
      *Button.command: ruby {p self; p $SAFE; TkOption::CMD::XXX.bar(1,2,3)}
      ---------------------------------
    The following code is a sample of use of the resource file.
      e.g.
        require 'tk'
        TkOption.readfile 'resource-test'
        p TkOption.new_proc_class(:CMD, [:foo], 1)
        p TkOption.new_proc_class(:XXX, [:bar], 2, false, TkOption::CMD)
        TkButton.new(:text=>'test').pack
        Tk.mainloop
@
text
@d3 1
a3 1
#			$Date: 2002/03/11 08:02:04 $
d998 1
a998 1
      window(tk_call 'wm', 'transient', path, *args)
d1478 1
a1478 1
    window(tk_call 'selection', 'own', win, func)
d1620 1
a1620 1
    number(tk_call 'winfo', 'atom', name)
d1902 1
a1902 1
    bool(tk_call 'winfo', 'viewable', window.path)
d2472 1
a2472 1
      tk_tcl2ruby tk_call path, 'cget', "-#{slot}"
d2808 1
a2808 1
	return(tk_call 'grab', 'set', '-global', path)
d2810 1
a2810 1
	return(tk_call 'grab', 'release', path)
d3332 1
a3332 1
      tk_tcl2ruby tk_send 'itemcget', index, "-#{key}"
d3471 1
a3471 1
      tk_tcl2ruby tk_send 'entrycget', index, "-#{key}"
@


1.31
log
@* marshal.c (w_object): module inclusion using extend() should
  also be detected.

* eval.c (rb_eval_cmd): cbase should not be NULL; it should be
  either ruby_wrapper or Object.

* enum.c (enum_each_with_index): should return self.

* process.c (proc_setpgrp): should return value for non-void function.

* process.c (proc_getpgid): should raise exception if getpgid() return -1.

* string.c (rb_str_ljust): should return a duplicated string.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d3 1
a3 1
#			$Date: 2002/03/08 07:03:07 $
d135 7
d214 2
d271 5
a275 3
  def install_win(ppath)
    id = format("w%.4d", Tk_IDs[1])
    Tk_IDs[1] += 1
d277 1
a277 1
      @@path = format(".%s", id);
d279 1
a279 1
      @@path = format("%s.%s", ppath, id)
d497 2
d632 26
a657 2
  def mainloop
    TclTkLib.mainloop
d660 6
a665 1
  def restart
d667 1
d2123 1
a2123 1
    tk_call 'option', 'get', win ,name, klass
d2129 75
d2217 1
d2325 1
d2468 1
a2468 1
    case slot
d2478 5
a2482 3
      if (slot['font'] || slot['kanjifont'] ||
	  slot['latinfont'] || slot['asciifont'] )
	font_configure(slot.dup)
d2488 4
a2491 2
      if (slot == 'font' || slot == 'kanjifont' ||
	  slot == 'latinfont' || slot == 'asciifont')
d2508 2
a2509 1
    if slot == 'font' || slot == 'kanjifont'
d2513 1
a2513 1
	case slot
d2583 13
a2595 1
    install_win(if parent then parent.path end)
d2604 1
a2604 1
      p 'create_self has an arg' if $DEBUG
a2606 1
	keys = keys.dup
d2807 1
a2807 1
      when 'global'
d2809 1
a2809 1
      when 'release'
d2815 1
a2815 1
      when 'current'
d2817 1
a2817 1
      when 'status'
d2950 12
d2963 1
a2963 1
      keys = screen
d2969 2
a2970 2
      if keys.key?('classname')
	keys = keys.dup
d3026 8
a3033 4
    if keys.kind_of? Hash
      if keys.key?('classname')
	keys = keys.dup
	keys['class'] = keys.delete('classname')
a3034 4
      @@classname = keys['class']
      @@colormap  = keys['colormap']
      @@container = keys['container']
      @@visual    = keys['visual']
d3036 8
a3043 1
    super(parent, keys)
d3328 1
a3328 1
    case key
d3337 5
a3341 3
      if (key['font'] || key['kanjifont'] ||
	  key['latinfont'] || key['asciifont'])
	tagfont_configure(index, key.dup)
d3347 4
a3350 2
      if (key == 'font' || key == 'kanjifont' ||
	  key == 'latinfont' || key == 'asciifont' )
d3360 1
a3360 1
      case key
d3467 1
a3467 1
    case key
d3476 5
a3480 3
      if (key['font'] || key['kanjifont'] ||
	  key['latinfont'] || key['asciifont'])
	tagfont_configure(index, key.dup)
d3486 4
a3489 2
      if (key == 'font' || key == 'kanjifont' ||
	  key == 'latinfont' || key == 'asciifont' )
d3499 1
a3499 1
      case key
d3537 7
d3548 1
a3548 1
    install_win(@@parent.path)
d3555 4
d3614 6
d3681 11
a3691 3
    @@frame = TkFrame.new(parent)
    @@path = @@epath = @@frame.path
    initialize_composite(*args)
@


1.30
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.

* class.c (rb_mod_clone): should not call rb_obj_clone(), since
  Module does not provide "allocate".

* class.c (rb_singleton_class): should crate new singleton class
  if obj is a class or module and attached object is different,
  which means metaclass of singleton class is sought.

* time.c (time_s_alloc): now follows allocation framework.

* eval.c (rb_eval): should initialize outer class variables from
  methods in singleton class definitions.

* eval.c (assign): ditto.
@
text
@d3 1
a3 1
#			$Date: 2002/02/28 06:53:33 $
d948 2
a949 2
    def state
      tk_call 'wm', 'state', path
@


1.29
log
@* eval.c (rb_mod_include): load modules in argument order.

* st.c (st_init_table_with_size): num_bins should be prime numbers
  (no decrement).

* st.c (rehash): ditto.
@
text
@d3 1
a3 1
#			$Date: 2002/01/28 08:44:43 $
d453 1
a453 1
    TkPack.configure *args
d457 1
a457 1
    TkGrid.configure *args
d498 12
a509 12
    return
    if false #defined? Thread
      Thread.start do
	ms = Float(ms)/1000
	ms = 10 if ms == 0
	sleep ms/1000
	cmd.call
      end
    else
      cmdid = install_cmd(cmd)
      tk_call("after",ms,cmdid)
    end
d623 6
d660 1
a660 1
    print args.join(" "), "\n" if $DEBUG
d664 1
d680 1
a680 1
    print "==> ", res, "\n" if $DEBUG
d840 2
a841 2
	self.xscrollcommand {|arg| @@xscrollbar.set *arg}
	@@xscrollbar.command {|arg| self.xview *arg}
d849 2
a850 2
	self.yscrollcommand {|arg| @@yscrollbar.set *arg}
	@@yscrollbar.command {|arg| self.yview *arg}
@


1.28
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.

* object.c (Init_Object): remove dup and clone from TrueClass,
  FalseClass, and NilClass.

* array.c (rb_ary_fill): Array#fill takes block to get the value to
  fill.

* string.c (rb_str_to_i): to_i(0) auto-detects base radix.

* array.c (rb_ary_initialize): fill by the block evaluation value
  if block is given.
@
text
@d3 1
a3 1
#			$Date: 2001/11/19 05:02:17 $
d2177 117
d2452 18
a2469 4
    create_self
    if keys
      # tk_call @@path, 'configure', *hash_kv(keys)
      configure(keys)
d2541 1
a2541 1
    tk_call('grid', 'columnconfigure', epath, index, hash_kv(keys))
d2545 1
a2545 1
    tk_call('grid', 'rowconfigure', epath, index, hash_kv(keys))
d2774 32
d2808 1
a2808 1
      keys = screen.dup
d2814 10
a2823 7
      keys = keys.dup
      @@classname = keys.delete('classname') if keys.key?('classname')
      @@colormap  = keys.delete('colormap')  if keys.key?('colormap')
      @@container = keys.delete('container') if keys.key?('container')
      @@screen    = keys.delete('screen')    if keys.key?('screen')
      @@use       = keys.delete('use')       if keys.key?('use')
      @@visual    = keys.delete('visual')    if keys.key?('visual')
d2828 6
a2833 9
  def create_self
    s = []
    s << "-class"     << @@classname if @@classname
    s << "-colormap"  << @@colormap  if @@colormap
    s << "-container" << @@container if @@container
    s << "-screen"    << @@screen    if @@screen 
    s << "-use"       << @@use       if @@use
    s << "-visual"    << @@visual    if @@visual
    tk_call 'toplevel', @@path, *s
d2848 22
d2872 8
a2879 5
      keys = keys.dup
      @@classname = keys.delete('classname') if keys.key?('classname')
      @@colormap  = keys.delete('colormap')  if keys.key?('colormap')
      @@container = keys.delete('container') if keys.key?('container')
      @@visual    = keys.delete('visual')    if keys.key?('visual')
d2884 6
a2889 7
  def create_self
    s = []
    s << "-class"     << @@classname if @@classname
    s << "-colormap"  << @@colormap  if @@colormap
    s << "-container" << @@container if @@container
    s << "-visual"    << @@visual    if @@visual
    tk_call 'frame', @@path, *s
d2899 6
a2904 2
  def create_self
    tk_call 'label', @@path
d2916 6
a2921 2
  def create_self
    tk_call 'button', @@path
d2936 6
a2941 2
  def create_self
    tk_call 'radiobutton', @@path
d2960 6
a2965 2
  def create_self
    tk_call 'checkbutton', @@path
d2978 6
a2983 2
  def create_self
    tk_call 'message', @@path
d2994 6
a2999 2
  def create_self
    tk_call 'scale', path
d3034 6
a3039 2
  def create_self
    tk_call 'scrollbar', path
d3103 13
d3117 1
d3124 6
a3129 2
  def create_self
    tk_call 'listbox', path
d3185 1
a3185 1
	tagfont_configure({key=>val})
d3231 1
a3231 10
  def tagfont_configinfo(index)
    pathname = self.path + ';' + index
    ret = TkFont.used_on(pathname)
    if ret == nil
      ret = TkFont.init_widget_font(pathname, 
				    self.path, 'entryconfigure', index)
    end
    ret
  end
  alias tagfontobj tagfont_configinfo
d3233 3
a3235 22
  def tagfont_configure(index, slot)
    pathname = self.path + ';' + index
    if (fnt = slot.delete('font'))
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(pathname, 
				       self.path,'entryconfigure',index,slot)
      else
	latintagfont_configure(index, fnt) if fnt
      end
    end
    if (ltn = slot.delete('latinfont'))
      latintagfont_configure(index, ltn) if ltn
    end
    if (ltn = slot.delete('asciifont'))
      latintagfont_configure(index, ltn) if ltn
    end
    if (knj = slot.delete('kanjifont'))
      kanjitagfont_configure(index, knj) if knj
    end

    tk_call(self.path, 'entryconfigure', index, *hash_kv(slot)) if slot != {}
    self
d3237 3
a3239 69

  def latintagfont_configure(index, ltn, keys=nil)
    fobj = tagfontobj(index)
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.latin_replace(ltn)
	fobj.latin_configure(keys) if keys
      elsif keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciitagfont_configure latintagfont_configure

  def kanjitagfont_configure(index, knj, keys=nil)
    fobj = tagfontobj(index)
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.kanji_replace(knj)
	fobj.kanji_configure(keys) if keys
      elsif keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(conf)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def tagfont_copy(index, window, wintag=nil)
    if wintag
      window.tagfontobj(wintag).configinfo.each{|key,value|
	tagfontobj(index).configure(key,value)
      }
      tagfontobj(index).replace(window.tagfontobj(wintag).latin_font, 
			      window.tagfontobj(wintag).kanji_font)
    else
      window.tagfont(wintag).configinfo.each{|key,value|
	tagfontobj(index).configure(key,value)
      }
      tagfontobj(index).replace(window.fontobj.latin_font, 
			      window.fontobj.kanji_font)
    end
  end

  def latintagfont_copy(index, window, wintag=nil)
    if wintag
      tagfontobj(index).latin_replace(window.tagfontobj(wintag).latin_font)
    else
      tagfontobj(index).latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciitagfont_copy latintagfont_copy

  def kanjitagfont_copy(index, window, wintag=nil)
    if wintag
      tagfontobj(index).kanji_replace(window.tagfontobj(wintag).kanji_font)
    else
      tagfontobj(index).kanji_replace(window.fontobj.kanji_font)
    end
d3251 6
a3256 2
  def create_self
    tk_call 'menu', path
d3381 8
a3388 2
    create_self
    configure(keys) if keys
d3415 6
a3420 2
  def create_self
    tk_call 'menubutton', path
@


1.27
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* massages: replace "wrong #" by "wrong number".

* marshal.c (w_float): output Infinity and NaN explicitly.

* marshal.c (r_object): support new explicit float format.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.

* array.c (rb_ary_join): dumped core if sep is not T_STRING nor T_NIL.

* array.c (rb_ary_join): buffer size calculattion was wrong.

* array.c (rb_ary_to_s): if rb_output_fs is nil, insert newlines
  between array elements (use rb_default_rs as newline litral)
  [experimental].

* gc.c (init_mark_stack): no need to clear mark_stack.

* gc.c (gc_mark_all): need to handle finalizer mark.

* gc.c (gc_mark_rest): use MEMCPY instead of memcpy.

* gc.c (rb_gc_mark): earlier const check to avoid pusing special
  constants into mark stack.

* numeric.c (fix_to_s): 'to_s' now takes optional argument to
  specify radix. [new]

* bignum.c (rb_big_to_s): ditto. [new]
@
text
@d3 1
a3 1
#			$Date: 2001/10/29 05:07:24 $
a95 1
    p str[0,i]
d1320 1
a1320 1
    @@trace_var.each_with_index{|i,e| 
d1354 1
a1354 1
    @@trace_elem[elem].each_with_index{|i,e| 
@


1.26
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* variable.c (rb_cvar_set): empty iv_tbl may cause infinite loop.

* variable.c (rb_cvar_get): ditto.

* variable.c (cvar_override_check): ditto.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.

* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.
@
text
@d3 1
a3 1
#			$Date: 2001/09/05 06:54:57 $
a1563 25
  end
end

module TkXIM
  include Tk
  extend Tk

  def TkXIM.useinputmethods(window=nil,value=nil)
    if window
      if value
        tk_call 'tk', 'useinputmethods', '-displayof', window.path, value
      else
        tk_call 'tk', 'useinputmethods', '-displayof', window.path
      end
    else
      if value
        tk_call 'tk', 'useinputmethods', value
      else
        tk_call 'tk', 'useinputmethods'
      end
    end
  end

  def useinputmethods(value=nil)
    TkXIM.useinputmethods(self,value)
@


1.25
log
@* re.c (Init_Regexp): to_s to be alias to inspect.

* parse.y (yylex): should support 'keyword='.

* ruby.c (proc_options): should not adjust argc/argv if -e option
  is supplied.
@
text
@d3 1
a3 1
#			$Date: 2001/06/01 06:47:32 $
d80 3
d96 1
d109 3
d477 9
a485 1
  INTERP._invoke("proc", "rb_out", "args", "if {[set st [catch {ruby [format \"TkCore.callback %%Q!%s!\" $args]} ret]] != 0} {if {[regsub -all {!} $args {\\!} newargs] == 0} {return -code $st $ret} {if {[set st [catch {ruby [format \"TkCore.callback %%Q!%s!\" $newargs]} ret]] != 0} {return -code $st $ret} {return $ret}}} {return $ret}")
@


1.24
log
@* parse.y (yylex): fixed 'print CGI::bar() {}, "\n"' syntax
  breakage, adding new lex_state status.  sigh. [new]

* file.c (rb_file_s_unlink): should not allow if $SAFE >= 2.

* range.c (Init_Range): define "to_ary".
@
text
@d3 1
a3 1
#			$Date: 2001/05/30 09:10:23 $
d2236 1
a2236 1
    when 'text', 'label', 'show', 'data', 'flie'
d2276 1
a2276 1
	when 'text', 'label', 'show', 'data', 'flie'
d2288 1
a2288 1
	  when 'text', 'label', 'show', 'data', 'flie'
@


1.23
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_finish): removed.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* string.c (rb_str_buf_finish): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d3 1
a3 1
#			$Date: 2001/05/06 15:04:27 $
d1191 1
a1191 1
    Integer(number(value))
d1195 1
a1195 1
    Float(number(value))
d1199 1
a1199 1
    String(string(value))
@


1.22
log
@forgot some checkins.
@
text
@d3 1
a3 1
#			$Date: 2001/03/27 07:09:27 $
d668 4
a732 3
  TCL_PACKAGE_PATH = INTERP._invoke("set", "tcl_pkgPath")
  AUTO_PATH = tk_split_simplelist(INTERP._invoke("set", "auto_path"))

d1381 15
@


1.21
log
@* eval.c (rb_mod_define_method): should have clear method cache.

* eval.c (rb_mod_define_method): should have raised exception for
  type error.

* ruby.h: changed "extern INLINE" to "static inline".
@
text
@d2 3
a4 3
#		tk.rb - Tk interface modue using tcltklib
#			$Date: 2000/11/27 09:23:34 $
#			by Yukihiro Matsumoto <matz@@netlab.co.jp>
d354 1
a354 1
	if context.kind_of? TkVirtualEvent
d400 12
a411 2
      tk_split_list(tk_call(*what)).collect{|seq|
	seq[1..-2].gsub(/></,',')
d1059 6
a1081 1
  BindTagALL = []
d1083 1
a1083 8
    if BindTagALL[0]
      BindTagALL[0].bind(*args) if args != []
    else
      new = super()
      BindTagALL[0] = new
    end
    BindTagALL[0]
  end
d1085 2
a1086 3
  def initialize(*args)
    @@id = 'all'
    BindTagALL[0].bind(*args) if args != []
d2585 1
a2585 1
      fail unless taglist.kind_of? Array
@


1.20
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/08/02 04:54:20 $
d654 51
d711 13
d747 4
d781 1
a781 1
  def toUTF8(str,encoding)
d785 1
a785 1
  def fromUTF8(str,encoding)
d1517 1
a1517 1
    TkXIM.useinputmethods(self, value=nil)
d2441 1
a2441 1
      tk_call('grid', 'propagate', epath, bool)
d2779 10
a2788 2
  def get
    number(tk_send('get'))
d2823 2
a2824 2
  def identify(x=None, y=None)
    tk_send('fraction', x, y)
d2839 4
d3116 1
a3116 1
    tk_send 'add', index, type, *hash_kv(keys)
d3121 1
a3121 1
  def popup(x, y, index=nil)
d3211 1
a3211 1
  def initialize(parent, type=nil)
d3216 1
a3216 1
    install_win(@@parent)
@


1.20.2.1
log
@* eval.c (rb_mod_define_method): should have clear method cache.

* eval.c (rb_mod_define_method): should have raised exception for
  type error.

* ruby.h: changed "extern INLINE" to "static inline".
@
text
@d3 1
a3 1
#			$Date: 2000/11/27 09:23:34 $
a653 51
module TkPackage
  include TkCore
  extend TkPackage

  def forget(package)
    tk_call('package', 'forget', package)
    nil
  end

  def names
    tk_split_simplelist(tk_call('package', 'names'))
  end

  def provide(package, version=nil)
    if version
      tk_call('package', 'provide', package, version)
      nil
    else
      tk_call('package', 'provide', package)
    end
  end

  def present(package, version=None)
    tk_call('package', 'present', package, version)
  end

  def present_exact(package, version)
    tk_call('package', 'present', '-exact', package, version)
  end

  def require(package, version=None)
    tk_call('package', 'require', package, version)
  end

  def require_exact(package, version)
    tk_call('package', 'require', '-exact', package, version)
  end

  def versions(package)
    tk_split_simplelist(tk_call('package', 'versions', package))
  end

  def vcompare(version1, version2)
    Integer(tk_call('package', 'vcompare', version1, version2))
  end

  def vsatisfies(version1, version2)
    bool(tk_call('package', 'vsatisfies', version1, version2))
  end
end

a659 13

  TCL_PATCHLEVEL = INTERP._invoke("info", "patchlevel")
  TK_PATCHLEVEL  = INTERP._invoke("set", "tk_patchLevel")

  TCL_LIBRARY = INTERP._invoke("set", "tcl_library")
  TK_LIBRARY  = INTERP._invoke("set", "tk_library")
  LIBRARY     = INTERP._invoke("info", "library")

  TCL_PACKAGE_PATH = INTERP._invoke("set", "tcl_pkgPath")
  AUTO_PATH = tk_split_simplelist(INTERP._invoke("set", "auto_path"))

  PLATFORM = Hash[*tk_split_simplelist(INTERP._eval('array get tcl_platform'))]

a682 4
  def Tk.strictMotif(bool=None)
    bool(tk_call('set', 'tk_strictMotif', bool))
  end

d713 1
a713 1
  def Tk.toUTF8(str,encoding)
d717 1
a717 1
  def Tk.fromUTF8(str,encoding)
d1449 1
a1449 1
    TkXIM.useinputmethods(self, value)
d2373 1
a2373 1
      tk_call('grid', 'propagate', epath, mode)
d2711 2
a2712 10
  def get(x=None, y=None)
    number(tk_send('get', x, y))
  end

  def coords(val=None)
    tk_split_list(tk_send('coords', val))
  end

  def identify(x, y)
    tk_send('identify', x, y)
d2747 2
a2748 2
  def identify(x, y)
    tk_send('identify', x, y)
a2762 4

  def activate(element=None)
    tk_send('activate', element)
  end
d3036 1
a3036 1
    tk_send 'insert', index, type, *hash_kv(keys)
d3041 1
a3041 1
  def popup(x, y, index=None)
d3131 1
a3131 1
  def initialize(parent, type=None)
d3136 1
a3136 1
    install_win(@@parent.path)
@


1.20.2.2
log
@* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE SUMMER TIME!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.
@
text
@d3 1
a3 1
#			$Date: 2001/03/27 07:10:58 $
d354 1
a354 1
	if ev.kind_of? TkVirtualEvent
d400 2
a401 12
      tk_split_simplelist(tk_call(*what)).collect!{|seq|
	l = seq.scan(/<*[^<>]+>*/).collect!{|subseq|
	  case (subseq)
	  when /^<<[^<>]+>>$/
	    TkVirtualEvent.getobj(subseq[1..-2])
	  when /^<[^<>]+>$/
	    subseq[1..-2]
	  else
	    subseq.split('')
	  end
	}.flatten
	(l.size == 1) ? l[0] : l
a1048 6
  ALL = self.new
  ALL.instance_eval {
    @@id = 'all'
    BTagID_TBL[@@id] = self
  }

d1066 1
d1068 8
a1075 1
    $stderr.puts "Warning: TkBindTagALL is obsolete. Use TkBindTag::ALL\n"
d1077 3
a1079 2
    TkBindTag::ALL.bind(*args) if args != []
    TkBindTag::ALL
d2578 1
a2578 1
      fail ArgumentError unless taglist.kind_of? Array
@


1.20.2.3
log
@* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): inifinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe leve 4.
@
text
@d2 2
a3 2
#		tk.rb - Tk interface module using tcltklib
#			$Date: 2001/04/06 05:42:42 $
@


1.20.2.4
log
@* regex.c (re_compile_pattern): no back reference to a
  subexpression if inside of it.

* eval.c (rb_yield_0): preserve and restore ruby_cref as well.
@
text
@d3 1
a3 1
#			$Date: 2001/05/01 08:45:20 $
a667 4
  def add_path(path)
    Tk::AUTO_PATH.value = Tk::AUTO_PATH.to_a << path
  end

d729 3
a1379 15
end

module Tk
  begin
    auto_path = INTERP._invoke('set', 'auto_path')
  rescue
    begin
      auto_path = INTERP._invoke('set', 'env(TCLLIBPATH)')
    rescue
      auto_path = Tk::LIBRARY
    end
  end
  AUTO_PATH = TkVarAccess.new('auto_path', auto_path)

  TCL_PACKAGE_PATH = TkVarAccess.new('tcl_pkgPath')
@


1.20.2.5
log
@* file.c (rb_file_s_unlink): should not allow if $SAFE >= 2.

* object.c (rb_obj_taint): backport from 1.7.

* object.c (rb_obj_untaint): add frozen status check (backport from 1.7).

* ruby.c (proc_options): unexpected SecurityError happens when -T4.
@
text
@d3 1
a3 1
#			$Date: 2001/05/29 08:59:39 $
d1191 1
a1191 1
    number(value).to_i
d1195 1
a1195 1
    number(value).to_f
d1199 1
a1199 1
    string(value).to_s
@


1.20.2.6
log
@* ruby.c (proc_options): should not adjust argc/argv if -e option
  is supplied.
@
text
@d3 1
a3 1
#			$Date: 2001/06/01 06:46:12 $
d2236 1
a2236 1
    when 'text', 'label', 'show', 'data', 'file'
d2276 1
a2276 1
	when 'text', 'label', 'show', 'data', 'file'
d2288 1
a2288 1
	  when 'text', 'label', 'show', 'data', 'file'
@


1.20.2.7
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.
@
text
@d3 1
a3 1
#			$Date: 2001/09/05 06:53:31 $
a79 3
    while idx and idx > 0 and str[idx-1] == ?\\
      idx = str.index('{', idx+1)
    end
a104 3
    while idx and idx > 0 and str[idx-1] == ?\\
      idx = str.index('{', idx+1)
    end
d470 1
a470 9
  INTERP._invoke("proc", "rb_out", "args", <<-'EOL')
    regsub -all {!} $args {\\!} args
    regsub -all "{" $args "\\{" args
    if {[set st [catch {ruby [format "TkCore.callback %%Q!%s!" $args]} ret]] != 0} {
	return -code $st $ret
    } {
	return $ret
    }
  EOL
@


1.20.2.8
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.
@
text
@d3 1
a3 1
#			$Date: 2001/10/29 05:04:45 $
d1563 25
@


1.20.2.9
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.
@
text
@d3 1
a3 1
#			$Date: 2001/11/19 04:58:07 $
d1320 1
a1320 1
    @@trace_var.each_with_index{|e,i| 
d1354 1
a1354 1
    @@trace_elem[elem].each_with_index{|e,i| 
@


1.20.2.10
log
@* st.c (st_init_table_with_size): num_bins should be prime numbers
  (no decrement).

* st.c (rehash): ditto.
@
text
@d3 1
a3 1
#			$Date: 2002/01/28 08:42:40 $
a2176 117
module TkTreatItemFont
  def __conf_cmd(idx)
    raise NotImplementError, "need to define `__conf_cmd'"
  end
  def __item_pathname(tagOrId)
    raise NotImplementError, "need to define `__item_pathname'"
  end
  private :__conf_cmd, :__item_pathname

  def tagfont_configinfo(tagOrId)
    pathname = __item_pathname(tagOrId)
    ret = TkFont.used_on(pathname)
    if ret == nil
      ret = TkFont.init_widget_font(pathname, self.path, 
				    __conf_cmd(0), __conf_cmd(1), tagOrId)
    end
    ret
  end
  alias tagfontobj tagfont_configinfo

  def tagfont_configure(tagOrId, slot)
    pathname = __item_pathname(tagOrId)
    if (fnt = slot.delete('font'))
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(pathname, self.path, 
				       __conf_cmd(0), __conf_cmd(1), 
				       tagOrId, slot)
      else
	latintagfont_configure(tagOrId, fnt) if fnt
      end
    end
    if (ltn = slot.delete('latinfont'))
      latintagfont_configure(tagOrId, ltn) if ltn
    end
    if (ltn = slot.delete('asciifont'))
      latintagfont_configure(tagOrId, ltn) if ltn
    end
    if (knj = slot.delete('kanjifont'))
      kanjitagfont_configure(tagOrId, knj) if knj
    end

    tk_call(self.path, __conf_cmd(0), __conf_cmd(1), 
	    tagOrId, *hash_kv(slot)) if slot != {}
    self
  end

  def latintagfont_configure(tagOrId, ltn, keys=nil)
    fobj = tagfontobj(tagOrId)
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.latin_replace(ltn)
	fobj.latin_configure(keys) if keys
      elsif keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciitagfont_configure latintagfont_configure

  def kanjitagfont_configure(tagOrId, knj, keys=nil)
    fobj = tagfontobj(tagOrId)
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.kanji_replace(knj)
	fobj.kanji_configure(keys) if keys
      elsif keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(conf)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def tagfont_copy(tagOrId, window, wintag=nil)
    if wintag
      window.tagfontobj(wintag).configinfo.each{|key,value|
	tagfontobj(tagOrId).configure(key,value)
      }
      tagfontobj(tagOrId).replace(window.tagfontobj(wintag).latin_font, 
				window.tagfontobj(wintag).kanji_font)
    else
      window.tagfont(wintag).configinfo.each{|key,value|
	tagfontobj(tagOrId).configure(key,value)
      }
      tagfontobj(tagOrId).replace(window.fontobj.latin_font, 
				window.fontobj.kanji_font)
    end
  end

  def latintagfont_copy(tagOrId, window, wintag=nil)
    if wintag
      tagfontobj(tagOrId).latin_replace(window.tagfontobj(wintag).latin_font)
    else
      tagfontobj(tagOrId).latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciitagfont_copy latintagfont_copy

  def kanjitagfont_copy(tagOrId, window, wintag=nil)
    if wintag
      tagfontobj(tagOrId).kanji_replace(window.tagfontobj(wintag).kanji_font)
    else
      tagfontobj(tagOrId).kanji_replace(window.fontobj.kanji_font)
    end
  end
end

d2335 4
a2338 18
    if self.method(:create_self).arity == 0
      p 'create_self has no arg' if $DEBUG
      create_self
      if keys
	# tk_call @@path, 'configure', *hash_kv(keys)
	configure(keys)
      end
    else
      p 'create_self has an arg' if $DEBUG
      fontkeys = {}
      if keys
	keys = keys.dup
	['font', 'kanjifont', 'latinfont', 'asciifont'].each{|key|
	  fontkeys[key] = keys.delete(key) if keys.key?(key)
	}
      end
      create_self(keys)
      font_configure(fontkeys) unless fontkeys.empty?
d2410 1
a2410 1
    tk_call('grid', 'columnconfigure', epath, index, *hash_kv(keys))
d2414 1
a2414 1
    tk_call('grid', 'rowconfigure', epath, index, *hash_kv(keys))
a2642 32
################# old version
#  def initialize(parent=nil, screen=nil, classname=nil, keys=nil)
#    if screen.kind_of? Hash
#      keys = screen.dup
#    else
#      @@screen = screen
#    end
#    @@classname = classname
#    if keys.kind_of? Hash
#      keys = keys.dup
#      @@classname = keys.delete('classname') if keys.key?('classname')
#      @@colormap  = keys.delete('colormap')  if keys.key?('colormap')
#      @@container = keys.delete('container') if keys.key?('container')
#      @@screen    = keys.delete('screen')    if keys.key?('screen')
#      @@use       = keys.delete('use')       if keys.key?('use')
#      @@visual    = keys.delete('visual')    if keys.key?('visual')
#    end
#    super(parent, keys)
#  end
#
#  def create_self
#    s = []
#    s << "-class"     << @@classname if @@classname
#    s << "-colormap"  << @@colormap  if @@colormap
#    s << "-container" << @@container if @@container
#    s << "-screen"    << @@screen    if @@screen 
#    s << "-use"       << @@use       if @@use
#    s << "-visual"    << @@visual    if @@visual
#    tk_call 'toplevel', @@path, *s
#  end
#################

d2645 1
a2645 1
      keys = screen
d2651 7
a2657 10
      if keys.key?('classname')
	keys = keys.dup
	keys['class'] = keys.delete('classname')
      end
      @@classname = keys['class']
      @@colormap  = keys['colormap']
      @@container = keys['container']
      @@screen    = keys['screen']
      @@use       = keys['use']
      @@visual    = keys['visual']
d2662 9
a2670 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'toplevel', @@path, *hash_kv(keys)
    else
      tk_call 'toplevel', @@path
    end
a2684 22
################# old version
#  def initialize(parent=nil, keys=nil)
#    if keys.kind_of? Hash
#      keys = keys.dup
#      @@classname = keys.delete('classname') if keys.key?('classname')
#      @@colormap  = keys.delete('colormap')  if keys.key?('colormap')
#      @@container = keys.delete('container') if keys.key?('container')
#      @@visual    = keys.delete('visual')    if keys.key?('visual')
#    end
#    super(parent, keys)
#  end
#
#  def create_self
#    s = []
#    s << "-class"     << @@classname if @@classname
#    s << "-colormap"  << @@colormap  if @@colormap
#    s << "-container" << @@container if @@container
#    s << "-visual"    << @@visual    if @@visual
#    tk_call 'frame', @@path, *s
#  end
#################

d2687 5
a2691 8
      if keys.key?('classname')
	keys = keys.dup
	keys['class'] = keys.delete('classname')
      end
      @@classname = keys['class']
      @@colormap  = keys['colormap']
      @@container = keys['container']
      @@visual    = keys['visual']
d2696 7
a2702 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'frame', @@path, *hash_kv(keys)
    else
      tk_call 'frame', @@path
    end
d2712 2
a2713 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'label', @@path, *hash_kv(keys)
    else
      tk_call 'label', @@path
    end
d2725 2
a2726 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'button', @@path, *hash_kv(keys)
    else
      tk_call 'button', @@path
    end
d2741 2
a2742 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'radiobutton', @@path, *hash_kv(keys)
    else
      tk_call 'radiobutton', @@path
    end
d2761 2
a2762 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'checkbutton', @@path, *hash_kv(keys)
    else
      tk_call 'checkbutton', @@path
    end
d2775 2
a2776 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'message', @@path, *hash_kv(keys)
    else
      tk_call 'message', @@path
    end
d2787 2
a2788 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'scale', @@path, *hash_kv(keys)
    else
      tk_call 'scale', @@path
    end
d2823 2
a2824 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'scrollbar', @@path, *hash_kv(keys)
    else
      tk_call 'scrollbar', @@path
    end
a2887 13
module TkTreatListItemFont
  include TkTreatItemFont

  ItemCMD = ['itemconfigure', TkComm::None]
  def __conf_cmd(idx)
    ItemCMD[idx]
  end

  def __item_pathname(tagOrId)
    self.path + ';' + tagOrId.to_s
  end
end

a2888 1
  include TkTreatListItemFont
d2895 2
a2896 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'listbox', @@path, *hash_kv(keys)
    else
      tk_call 'listbox', @@path
    end
d2952 1
a2952 1
	tagfont_configure(index, {key=>val})
d2998 10
a3007 1
  include TkTreatItemFont
d3009 22
a3030 3
  ItemCMD = ['entryconfigure', TkComm::None]
  def __conf_cmd(idx)
    ItemCMD[idx]
d3033 68
a3100 2
  def __item_pathname(tagOrId)
    self.path + ';' + tagOrId.to_s
d3112 2
a3113 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'menu', @@path, *hash_kv(keys)
    else
      tk_call 'menu', @@path
    end
d3177 1
a3177 1
	tagfont_configure(index, {key=>val})
d3238 2
a3239 8
    if self.method(:create_self).arity == 0
      p 'create_self has no arg' if $DEBUG
      create_self
      configure(keys) if keys
    else
      p 'create_self has an arg' if $DEBUG
      create_self(keys)
    end
d3266 2
a3267 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'menubutton', @@path, *hash_kv(keys)
    else
      tk_call 'menubutton', @@path
    end
@


1.20.2.11
log
@* stable version 1.6.7 released.
@
text
@d3 1
a3 1
#			$Date: 2002/02/28 06:52:49 $
a620 6
  end

  def restart
    TkCore::INTERP.restart
    TkComm::Tk_WINDOWS.clear
    nil
@


1.20.2.12
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.
@
text
@d3 1
a3 1
#			$Date: 2002/03/01 14:12:05 $
d453 1
a453 1
    TkPack.configure(*args)
d457 1
a457 1
    TkGrid.configure(*args)
d498 12
a509 12
#    return
#    if false #defined? Thread
#      Thread.start do
#	ms = Float(ms)/1000
#	ms = 10 if ms == 0
#	sleep ms/1000
#	cmd.call
#      end
#    else
#      cmdid = install_cmd(cmd)
#      tk_call("after",ms,cmdid)
#    end
d660 1
a660 1
    puts args.inspect if $DEBUG
a663 1
    print "=> ", args.join(" ").inspect, "\n" if $DEBUG
d679 1
a679 1
    print "==> ", res.inspect, "\n" if $DEBUG
d839 2
a840 2
	self.xscrollcommand {|arg| @@xscrollbar.set(*arg)}
	@@xscrollbar.command {|arg| self.xview(*arg)}
d848 2
a849 2
	self.yscrollcommand {|arg| @@yscrollbar.set(*arg)}
	@@yscrollbar.command {|arg| self.yview(*arg)}
@


1.20.2.13
log
@* regex.c (re_compile_pattern): '\0111' should be '\011' plus '1',
  since octal literals are formed by three digits at most.

* eval.c (rb_eval_cmd): cbase should not be NULL; it should be
  either ruby_wrapper or Object.

* enum.c (enum_each_with_index): should return self.

* process.c (proc_setpgrp): should return value for non-void function.

* process.c (proc_getpgid): should raise exception if getpgid() return -1.

* string.c (rb_str_ljust): should return a duplicated string.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d3 1
a3 1
#			$Date: 2002/03/08 06:59:55 $
d948 2
a949 2
    def state(state=None)
      tk_call 'wm', 'state', path, state
@


1.19
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/11/17 09:09:03 $
d488 50
d1815 9
d1825 9
a1833 1
    bool(tk_call('pack', 'propagate', master.epath, bool))
d1835 2
a1836 1
  module_function :configure, :forget, :propagate
d1866 26
d1909 5
a1913 1
    bool(tk_call('grid', 'propagate', master.epath, bool))
d1924 2
a1925 2
  def slaves(args)
    list(tk_call('grid', 'slaves', *hash_kv(args)))
d1931 50
d2144 6
a2149 1
    tk_tcl2ruby tk_call path, 'cget', "-#{slot}"
d2184 6
a2189 1
	conf = tk_split_list(tk_send('configure', "-#{slot}") )
d2193 2
a2194 1
	ret = tk_split_list(tk_send('configure') ).collect{|conf|
d2196 18
d2216 2
a2217 1
	if ret.assoc('font')
d2219 2
a2220 1
	  ret.push(['font', fontobj])
d2275 30
d2315 75
d2402 6
a2407 2
  def place_config(keys)
    tk_call "place", 'configure', epath, *hash_kv(keys)
d2410 13
a2422 5
  def place_info()
    ilist = list(tk_call('place', 'info', epath))
    info = {}
    while key = ilist.shift
      info[key[1..-1]] = ilist.shift
a2423 1
    return info
d2426 2
a2427 6
  def pack_slaves()
    list(tk_call('pack', 'slaves', epath))
  end

  def pack_info()
    ilist = list(tk_call('pack', 'info', epath))
d2454 3
a2456 1
	tk_call 'grab', 'set', '-global', path
d2656 1
a2656 1
class TkRadiobutton<TkButton
d2658 1
a2658 1
  def TkRadiobutton.to_eval
d2674 1
a2674 1
TkRadioButton = TkRadiobutton
d2676 1
a2676 1
class TkCheckbutton<TkRadiobutton
d2678 1
a2678 1
  def TkCheckbutton.to_eval
d2688 1
a2688 1
TkCheckButton = TkCheckbutton
a2698 1
TkRadiobutton = TkRadioButton
a2726 1
TkCheckbutton = TkCheckButton
d2841 6
a2846 1
    tk_tcl2ruby tk_send 'itemcget', index, "-#{key}"
d2869 6
a2874 1
      conf = tk_split_list(tk_send('itemconfigure',index,"-#{key}"))
d2878 2
a2879 1
      tk_split_list(tk_send('itemconfigure', index)).collect{|conf|
d2881 18
d3066 6
a3071 1
    tk_tcl2ruby tk_send 'entrycget', index, "-#{key}"
d3094 6
a3099 1
      conf = tk_split_list(tk_send('entryconfigure',index,"-#{key}"))
d3103 2
a3104 1
      tk_split_list(tk_send('entryconfigure', index)).collect{|conf|
d3106 18
d3329 1
d3335 6
@


1.18
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/08/02 04:54:20 $
d272 2
a273 1
    def initialize(seq,b,f,h,k,s,t,w,x,y,aa,ee,kk,nn,ww,tt,xx,yy)
d275 1
d277 2
d282 3
d291 2
d296 2
d304 1
d306 2
d311 3
d320 2
d325 2
d343 2
a344 1
      id + ' %# %b %f %h %k %s %t %w %x %y %A %E %K %N %W %T %X %Y'
d575 4
d2381 1
a2381 1
tkRadioButton = TkRadiobutton
d2406 1
d2435 1
d2733 3
d2781 11
d2977 1
@


1.17
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/07/14 04:34:41 $
d2337 1
a2337 1
class TkRadioButton<TkButton
d2339 1
a2339 1
  def TkRadioButton.to_eval
d2355 1
d2357 1
a2357 1
class TkCheckButton<TkRadioButton
d2359 1
a2359 1
  def TkCheckButton.to_eval
d2369 1
@


1.16
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/07/06 07:21:20 $
d314 1
a314 1
      id = install_cmd(proc{|arg|
d783 90
@


1.15
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/06/13 09:57:03 $
d222 11
d555 1
a555 1
    args.collect! {|x|_get_eval_string(x)}
@


1.14
log
@tk font patch
@
text
@d3 1
a3 1
#			$Date: 2000/06/12 07:48:26 $
d530 1
a530 1
  def getOpenFile(keys)
d534 1
a534 1
  def getSaveFile(keys)
d538 1
a538 1
  def chooseColor(keys)
@


1.13
log
@2000-06-12
@
text
@d3 1
a3 1
#			$Date: 2000/05/24 04:34:21 $
d596 30
d1214 67
@


1.12
log
@2000-05-24
@
text
@d3 1
a3 1
#			$Date: 2000/04/10 06:05:19 $
d460 15
d790 18
d1187 25
d1868 1
a1868 1
  def unpack(keys = nil)
d1878 1
a1878 1
  def ungrid(keys = nil)
d1888 2
a1889 2
  def unplace(keys = nil)
    tk_call 'place', 'forget', epath, *hash_kv(keys)
d1955 1
a1955 1
    tk_call 'lower', path, below
d1959 1
a1959 1
    tk_call 'raise', path, above
d1973 1
a1973 1
    tk_call 'destroy', path
d1988 1
a1988 1
    tk_call 'tkwait', 'window', path
d2320 35
d2493 3
d2550 28
d2585 65
@


1.11
log
@2000-04-10
@
text
@d3 1
a3 1
#			$Date: 2000/04/10 05:57:37 $
d473 1
a473 1
    args = args.filter{|c| _get_eval_string(c).gsub(/[][$"]/, '\\\\\&')}
d488 1
a488 1
    args = args.filter{|c| _get_eval_string(c).gsub(/[][$"]/, '\\\\\&')}
d529 1
a529 1
    args.filter {|x|_get_eval_string(x)}
@


1.10
log
@2000-04-10
@
text
@d3 1
a3 1
#			$Date: 2000/03/17 08:58:17 $
d373 1
a373 1
          :_bind_core, :_bind, :_bind_append, ,:_bind_remove, :_bindinfo
@


1.9
log
@2000-03-17
@
text
@d3 1
a3 1
#			$Date: 2000/02/01 03:12:18 $
d353 4
d373 1
a373 1
          :_bind_core, :_bind, :_bind_append, :_bindinfo
d383 4
d738 4
@


1.8
log
@2000-02-01
@
text
@d3 1
a3 1
#			$Date: 2000/01/17 08:37:50 $
d1065 1
a1065 2
    id = install_cmd(func)
    tk_call 'selection', 'handle', win.path, id, type, format
d1070 2
a1071 3
  def TkSelection.own(win, func=None)
    id = install_cmd(func)
    tk_call 'selection', 'own', win.path, id
@


1.7
log
@2000-01-17
@
text
@d3 1
a3 1
#			$Date: 2000/01/05 04:37:19 $
d199 3
a201 1
    if str.kind_of?(Hash)
d422 1
a422 1
    raise TkCallbackBreak, "Tk callback returns 'break' status"
d426 1
a426 1
    raise TkCallbackContinue, "Tk callback returns 'continue' status"
d532 2
a533 2
	raise unless /^invalid command/ =~ $!
	raise err
d588 26
d815 1
a815 1
	raise
d829 1
a829 1
	raise
d846 1
a846 1
	  raise
d2180 1
a2180 1
    raise TypeError, "TkTextWin is abstract class"
d2226 8
a2250 8
  end
  def xview(cmd, *more)
    v = tk_send('xview', cmd, *more)
    v.to_i if more.size == 0
  end
  def yview(cmd, *more)
    v = tk_send('yview', cmd, *more)
    v.to_i if more.size == 0
@


1.6
log
@20000105
@
text
@d3 1
a3 1
#			$Date: 1999/12/14 06:49:57 $
d238 1
a238 1
    id = $1 if /rb_out (c\d+)/
a349 9
  private :install_bind, :tk_event_sequence, :_bind_core, :_bind, :_bind_append

  def bind_all(context, cmd=Proc.new, args=nil)
    _bind(['bind', 'all'], context, cmd, args)
  end

  def bind_append_all(context, cmd=Proc.new, args=nil)
    _bind_append(['bind', 'all'], context, cmd, args)
  end
d366 10
d381 12
d417 1
a417 1
  INTERP._invoke("proc", "rb_out", "args", "if {[set st [catch {ruby [format \"TkCore.callback %%Q!%s!\" $args]} ret]] != 0} {return -code $st $ret} {return $ret}")
d591 2
a592 2
      w = window(tk_call('wm', 'grid', path, *args))
      w.split.collect{|s|s.to_i} if args.length == 0
d610 1
a610 1
      tk_call 'wm', 'frame', path
d613 1
a613 1
      list(tk_call('wm', 'geometry', path, *args))
d620 2
a621 1
      tk_call 'wm', 'group', path, *args
d645 1
a645 1
      list(w) if not args.size == 0
d678 1
a678 1
      list(tk_call('wm', 'sizefrom', path, *args))
d687 1
a687 1
      tk_call 'wm', 'transient', path, *args
d695 40
d847 1
a847 1
    format "<TkVariable: %s>", @@id
d1120 1
a1120 1
    tk_call 'winfo', name
d1126 1
a1126 1
    tk_call 'winfo', id
d1132 1
a1132 1
    number(tk_call('winfo', window.path))
d1150 6
d1182 1
a1182 1
    list(tk_call('winfo', 'geometry', window.path))
d1194 1
a1194 1
    number(tk_call('winfo', 'id', window.path))
d1201 2
a1202 2
      tk_split_simplelist(tk_call('winfo', '-displayof', window.path, 
				  'interps'))
d1216 6
d1223 1
a1223 1
    bool(tk_call('winfo', 'name', window.path))
d1324 6
d1342 18
a1359 1
  def TkWinfo.vrootheigh(window)
d1632 1
a1728 12
  def bind(context, cmd=Proc.new, args=nil)
    _bind(["bind", to_eval], context, cmd, args)
  end

  def bind_append(context, cmd=Proc.new, args=nil)
    _bind_append(["bind", to_eval], context, cmd, args)
  end

  def bindinfo(context=nil)
    _bindinfo(['bind', to_eval], context)
  end

d1752 1
a1752 1
#  extend TkClassBind
d1900 9
a1908 5
      tk_split_list(tk_call('bindtags', path)).collect{|tag|
	if tag == nil
	  '.'
	elsif tag.kind_of?(String) && (cls = WidgetClassNames[tag])
	  cls
d1959 6
a1964 6
      @@classname = keys.delete('classname')
      @@colormap  = keys.delete('colormap')
      @@container = keys.delete('container')
      @@screen    = keys.delete('screen')
      @@use       = keys.delete('use')
      @@visual    = keys.delete('visual')
d1995 4
a1998 4
      @@classname = keys.delete('classname')
      @@colormap  = keys.delete('colormap')
      @@container = keys.delete('container')
      @@visual    = keys.delete('visual')
@


1.5
log
@19991214
@
text
@d3 1
a3 1
#			$Date: 1999/12/06 09:04:00 $
d1455 1
a1455 2
    if (fnt = slot['font'])
      slot['font'] = nil
d1462 1
a1462 2
    if (ltn = slot['latinfont'])
      slot['latinfont'] = nil
d1465 1
a1465 2
    if (ltn = slot['asciifont'])
      slot['asciifont'] = nil
d1468 1
a1468 2
    if (knj = slot['kanjifont'])
      slot['kanjifont'] = nil
d1877 6
a1882 24
      if keys['classname']
	@@classname = keys['classname']
	keys['classname'] = nil
      end
      if keys['colormap']
	@@colormap = keys['colormap']
	keys['colormap'] = nil
      end
      if keys['container']
	@@classname = keys['container']
	keys['classname'] = nil
      end
      if keys['screen']
	@@screen = keys['screen']
	keys['screen'] = nil
      end
      if keys['use']
	@@use = keys['use']
	keys['use'] = nil
      end
      if keys['visual']
	@@screen = keys['visual']
	keys['visual'] = nil
      end
d1889 6
a1894 6
    s.push << "-class"     << @@classname if @@classname
    s.push << "-colormap"  << @@colormap  if @@colormap
    s.push << "-container" << @@container if @@container
    s.push << "-screen"    << @@screen    if @@screen 
    s.push << "-use"       << @@use       if @@use
    s.push << "-visual"    << @@visual    if @@visual
d1913 4
a1916 16
      if keys['classname']
	@@classname = keys['classname']
	keys['classname'] = nil
      end
      if keys['colormap']
	@@colormap = keys['colormap']
	keys['colormap'] = nil
      end
      if keys['container']
      @@classname = keys['container']
	keys['classname'] = nil
      end
      if keys['visual']
	@@screen = keys['visual']
	keys['visual'] = nil
      end
d1923 4
a1926 4
    s.push << "-class"     << @@classname if @@classname
    s.push << "-colormap"  << @@colormap  if @@colormap
    s.push << "-container" << @@container if @@container
    s.push << "-visual"    << @@visual    if @@visual
d2158 1
a2158 2
    if (fnt = slot['font'])
      slot['font'] = nil
d2166 1
a2166 2
    if (ltn = slot['latinfont'])
      slot['latinfont'] = nil
d2169 1
a2169 2
    if (ltn = slot['asciifont'])
      slot['asciifont'] = nil
d2172 1
a2172 2
    if (knj = slot['kanjifont'])
      slot['kanjifont'] = nil
@


1.4
log
@19991206
@
text
@d3 1
a3 1
#			$Date: 1999/08/24 08:21:54 $
d2153 1
a2153 1
  def size(y)
d2162 2
a2163 2
  def selection_includes
    bool(tk_send('selection', 'includes'))
@


1.3
log
@1.4.1 to be
@
text
@d3 1
a3 1
#			$Date: 1999/08/13 05:37:51 $
d2134 2
@


1.3.2.1
log
@19991206
@
text
@d3 1
a3 1
#			$Date: 1999/08/24 08:21:54 $
a2133 2
  include Scrollable

@


1.3.2.2
log
@19991214
@
text
@d3 1
a3 1
#			$Date: 1999/12/06 09:03:37 $
d2153 1
a2153 1
  def size
d2162 2
a2163 2
  def selection_includes(index)
    bool(tk_send('selection', 'includes', index))
@


1.3.2.3
log
@20000105
@
text
@d3 1
a3 1
#			$Date: 1999/12/14 06:50:40 $
d1455 2
a1456 1
    if (fnt = slot.delete('font'))
d1463 2
a1464 1
    if (ltn = slot.delete('latinfont'))
d1467 2
a1468 1
    if (ltn = slot.delete('asciifont'))
d1471 2
a1472 1
    if (knj = slot.delete('kanjifont'))
d1881 24
a1904 6
      @@classname = keys.delete('classname')
      @@colormap  = keys.delete('colormap')
      @@container = keys.delete('container')
      @@screen    = keys.delete('screen')
      @@use       = keys.delete('use')
      @@visual    = keys.delete('visual')
d1911 6
a1916 6
    s << "-class"     << @@classname if @@classname
    s << "-colormap"  << @@colormap  if @@colormap
    s << "-container" << @@container if @@container
    s << "-screen"    << @@screen    if @@screen 
    s << "-use"       << @@use       if @@use
    s << "-visual"    << @@visual    if @@visual
d1935 16
a1950 4
      @@classname = keys.delete('classname')
      @@colormap  = keys.delete('colormap')
      @@container = keys.delete('container')
      @@visual    = keys.delete('visual')
d1957 4
a1960 4
    s << "-class"     << @@classname if @@classname
    s << "-colormap"  << @@colormap  if @@colormap
    s << "-container" << @@container if @@container
    s << "-visual"    << @@visual    if @@visual
d2192 2
a2193 1
    if (fnt = slot.delete('font'))
d2201 2
a2202 1
    if (ltn = slot.delete('latinfont'))
d2205 2
a2206 1
    if (ltn = slot.delete('asciifont'))
d2209 2
a2210 1
    if (knj = slot.delete('kanjifont'))
@


1.3.2.4
log
@2000-01-17
@
text
@d3 1
a3 1
#			$Date: 2000/01/05 04:41:15 $
d238 1
a238 1
    id = $1 if /rb_out (c\d+)/ =~ id
d350 9
a374 10
  private :install_bind, :tk_event_sequence, 
          :_bind_core, :_bind, :_bind_append, :_bindinfo

  def bind(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind(["bind", tagOrClass], context, cmd, args)
  end

  def bind_append(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind_append(["bind", tagOrClass], context, cmd, args)
  end
a379 12
  def bind_all(context, cmd=Proc.new, args=nil)
    _bind(['bind', 'all'], context, cmd, args)
  end

  def bind_append_all(context, cmd=Proc.new, args=nil)
    _bind_append(['bind', 'all'], context, cmd, args)
  end

  def bindinfo_all(context=nil)
    _bindinfo(['bind', 'all'], context)
  end

d404 1
a404 1
  INTERP._invoke("proc", "rb_out", "args", "if {[set st [catch {ruby [format \"TkCore.callback %%Q!%s!\" $args]} ret]] != 0} {if {[regsub -all {!} $args {\\!} newargs] == 0} {return -code $st $ret} {if {[set st [catch {ruby [format \"TkCore.callback %%Q!%s!\" $newargs]} ret]] != 0} {return -code $st $ret} {return $ret}}} {return $ret}")
d578 2
a579 2
      w = tk_call('wm', 'aspect', path, *args)
      list(w) if args.length == 0
d597 1
a597 1
      tk_call('wm', 'frame', path)
d600 1
a600 1
      tk_call('wm', 'geometry', path, *args)
d607 1
a607 2
      w = tk_call 'wm', 'group', path, *args
      window(w) if args.size == 0
d631 1
a631 1
      list(w) if args.size == 0
d664 1
a664 1
      tk_call('wm', 'sizefrom', path, *args)
d673 1
a673 1
      window(tk_call 'wm', 'transient', path, *args)
a680 40
module TkBindCore
  def bind(context, cmd=Proc.new, args=nil)
    Tk.bind(to_eval, context, cmd, args)
  end

  def bind_append(context, cmd=Proc.new, args=nil)
    Tk.bind_append(to_eval, context, cmd, args)
  end

  def bindinfo(context=nil)
    Tk.bindinfo(to_eval, context)
  end
end

class TkBindTag
  include TkBindCore

  BTagID_TBL = {}
  Tk_BINDTAG_ID = ["btag00000"]

  def TkBindTag.id2obj(id)
    BTagID_TBL[id]? BTagID_TBL[id]: id
  end

  def initialize(*args)
    @@id = Tk_BINDTAG_ID[0]
    Tk_BINDTAG_ID[0] = Tk_BINDTAG_ID[0].succ
    BTagID_TBL[@@id] = self
    bind(*args) if args != []
  end

  def to_eval
    @@id
  end

  def inspect
    format "#<TkBindTag: %s>", @@id
  end
end

d793 1
a793 1
    format "#<TkVariable: %s>", @@id
d1066 1
a1066 1
    number(tk_call 'winfo', 'atom', name)
d1072 1
a1072 1
    tk_call 'winfo', 'atomname', id
d1078 1
a1078 1
    number(tk_call('winfo', 'cells', window.path))
a1095 6
  def TkWinfo.colormapfull(window)
     bool(tk_call('winfo', 'colormapfull', window.path))
  end
  def winfo_colormapfull
    TkWinfo.colormapfull self
  end
d1122 1
a1122 1
    tk_call('winfo', 'geometry', window.path)
d1134 1
a1134 1
    tk_call('winfo', 'id', window.path)
d1141 2
a1142 2
      tk_split_simplelist(tk_call('winfo', 'interps',
				  '-displayof', window.path))
a1155 6
  def TkWinfo.manager(window)
    tk_call('winfo', 'manager', window.path)
  end
  def winfo_manager
    TkWinfo.manager self
  end
d1157 1
a1157 1
    tk_call('winfo', 'name', window.path)
a1257 6
  def TkWinfo.server(window)
    tk_call 'winfo', 'server', window.path
  end
  def winfo_server
    TkWinfo.server self
  end
d1270 1
a1270 18
  def TkWinfo.visualid(window)
    tk_call 'winfo', 'visualid', window.path
  end
  def winfo_visualid
    TkWinfo.visualid self
  end
  def TkWinfo.visualsavailable(window, includeids=false)
    if includeids
      v = tk_call('winfo', 'visualsavailable', window.path, "includeids")
    else
      v = tk_call('winfo', 'visualsavailable', window.path)
    end
    list(v)
  end
  def winfo_visualsavailable(includeids=false)
    TkWinfo.visualsavailable self, includeids
  end
  def TkWinfo.vrootheight(window)
a1542 1
  include TkBindCore
d1639 12
d1674 1
a1674 1
  extend TkBindCore
d1822 5
a1826 9
      list(tk_call('bindtags', path)).collect{|tag|
	if tag.kind_of?(String) 
	  if cls = WidgetClassNames[tag]
	    cls
	  elsif btag = TkBindTag.id2obj(tag)
	    btag
	  else
	    tag
	  end
d1877 6
a1882 6
      @@classname = keys.delete('classname') if keys.key?('classname')
      @@colormap  = keys.delete('colormap')  if keys.key?('colormap')
      @@container = keys.delete('container') if keys.key?('container')
      @@screen    = keys.delete('screen')    if keys.key?('screen')
      @@use       = keys.delete('use')       if keys.key?('use')
      @@visual    = keys.delete('visual')    if keys.key?('visual')
d1913 4
a1916 4
      @@classname = keys.delete('classname') if keys.key?('classname')
      @@colormap  = keys.delete('colormap')  if keys.key?('colormap')
      @@container = keys.delete('container') if keys.key?('container')
      @@visual    = keys.delete('visual')    if keys.key?('visual')
@


1.3.2.5
log
@2000-02-01
@
text
@d3 1
a3 1
#			$Date: 2000/01/17 08:24:17 $
d199 1
a199 3
    if str.kind_of?(String)
      # do nothing
    elsif str.kind_of?(Hash)
d420 1
a420 1
    fail TkCallbackBreak, "Tk callback returns 'break' status"
d424 1
a424 1
    fail TkCallbackContinue, "Tk callback returns 'continue' status"
d530 2
a531 2
	fail unless /^invalid command/ =~ $!
	fail err
a585 26
    def xview(*index)
      v = tk_send('xview', *index)
      list(v) if index.size == 0
    end
    def yview(*index)
      v = tk_send('yview', *index)
      list(v) if index.size == 0
    end
    def xscrollbar(bar=nil)
      if bar
	@@xscrollbar = bar
	@@xscrollbar.orient 'horizontal'
	self.xscrollcommand {|arg| @@xscrollbar.set *arg}
	@@xscrollbar.command {|arg| self.xview *arg}
      end
      @@xscrollbar
    end
    def yscrollbar(bar=nil)
      if bar
	@@yscrollbar = bar
	@@yscrollbar.orient 'vertical'
	self.yscrollcommand {|arg| @@yscrollbar.set *arg}
	@@yscrollbar.command {|arg| self.yview *arg}
      end
      @@yscrollbar
    end
d787 1
a787 1
	fail
d801 1
a801 1
	fail
d818 1
a818 1
	  fail
d2152 1
a2152 1
    fail TypeError, "TkTextWin is abstract class"
a2197 8
  def get(*index)
    v = tk_send('get', *index)
    if index.size == 1
      v
    else
      tk_split_simplelist(v)
    end
  end
d2215 8
@


1.3.2.6
log
@2000-03-23
@
text
@d3 1
a3 1
#			$Date: 2000/02/01 03:11:27 $
d1065 2
a1066 1
    tk_call 'selection', 'handle', win.path, func, type, format
d1071 3
a1073 2
  def TkSelection.own(win=None, func=None)
    window(tk_call 'selection', 'own', win, func)
@


1.3.2.7
log
@2000-04-10
@
text
@d3 1
a3 1
#			$Date: 2000/03/17 08:58:17 $
a352 4
  def _bind_remove(what, context)
    tk_call(*(what + ["<#{tk_event_sequence(context)}>", '']))
  end

d369 1
a369 1
          :_bind_core, :_bind, :_bind_append, ,:_bind_remove, :_bindinfo
a378 4
  def bind_remove(tagOrClass, context)
    _bind_remove(['bind', tagOrClass], context)
  end

a729 4
  end

  def bind_remove(context)
    Tk.bind_remove(to_eval, context)
@


1.3.2.8
log
@2000-04-10
@
text
@d3 1
a3 1
#			$Date: 2000/04/10 05:57:37 $
d373 1
a373 1
          :_bind_core, :_bind, :_bind_append, :_bind_remove, :_bindinfo
@


1.3.2.9
log
@2000-06-13
@
text
@d3 1
a3 1
#			$Date: 2000/04/10 06:01:29 $
a459 15
  def scaling(scale=nil)
    if scale
      tk_call('tk', 'scaling', scale)
    else
      Float(number(tk_call('tk', 'scaling')))
    end
  end
  def scaling_displayof(win, scale=nil)
    if scale
      tk_call('tk', 'scaling', '-displayof', win, scale)
    else
      Float(number(tk_call('tk', '-displayof', win, 'scaling')))
    end
  end

d529 1
a529 1
    args.filter{|x|_get_eval_string(x)}
a774 18
class TkBindTagAll<TkBindTag
  BindTagALL = []
  def TkBindTagAll.new(*args)
    if BindTagALL[0]
      BindTagALL[0].bind(*args) if args != []
    else
      new = super()
      BindTagALL[0] = new
    end
    BindTagALL[0]
  end

  def initialize(*args)
    @@id = 'all'
    BindTagALL[0].bind(*args) if args != []
  end
end

a1153 25
module TkXIM
  include Tk
  extend Tk

  def TkXIM.useinputmethods(window=nil,value=nil)
    if window
      if value
        tk_call 'tk', 'useinputmethods', '-displayof', window.path, value
      else
        tk_call 'tk', 'useinputmethods', '-displayof', window.path
      end
    else
      if value
        tk_call 'tk', 'useinputmethods', value
      else
        tk_call 'tk', 'useinputmethods'
      end
    end
  end

  def useinputmethods(value=nil)
    TkXIM.useinputmethods(self,value)
  end
end

d1810 1
a1810 1
  def unpack
d1820 1
a1820 1
  def ungrid
d1830 2
a1831 2
  def unplace
    tk_call 'place', 'forget', epath
d1897 1
a1897 1
    tk_call 'lower', epath, below
d1901 1
a1901 1
    tk_call 'raise', epath, above
d1915 1
a1915 1
    tk_call 'destroy', epath
d1930 1
a1930 1
    tk_call 'tkwait', 'window', epath
a2261 35

  def itemcget(index, key)
    tk_tcl2ruby tk_send 'itemcget', index, "-#{key}"
  end
  def itemconfigure(index, key, val=None)
    if key.kind_of? Hash
      if (key['font'] || key['kanjifont'] ||
	  key['latinfont'] || key['asciifont'])
	tagfont_configure(index, key.dup)
      else
	tk_send 'itemconfigure', index, *hash_kv(key)
      end

    else
      if (key == 'font' || key == 'kanjifont' ||
	  key == 'latinfont' || key == 'asciifont' )
	tagfont_configure({key=>val})
      else
	tk_call 'itemconfigure', index, "-#{key}", val
      end
    end
  end

  def itemconfiginfo(index, key=nil)
    if key
      conf = tk_split_list(tk_send('itemconfigure',index,"-#{key}"))
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_send('itemconfigure', index)).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end
a2399 3
  def popup(x, y, index=nil)
    tk_call 'tk_popup', path, x, y, index
  end
a2453 28
module TkSystemMenu
  def initialize(parent, keys=nil)
    fail unless parent.kind_of? TkMenu
    @@path = format("%s.%s", parent.path, self.type::SYSMENU_NAME)
    TkComm::Tk_WINDOWS[@@path] = self
    create_self
    configure(keys) if keys
  end
end

class TkSysMenu_Help<TkMenu
  # for all platform
  include TkSystemMenu
  SYSMENU_NAME = 'help'
end

class TkSysMenu_System<TkMenu
  # for Windows
  include TkSystemMenu
  SYSMENU_NAME = 'system'
end

class TkSysMenu_Apple<TkMenu
  # for Machintosh
  include TkSystemMenu
  SYSMENU_NAME = 'apple'
end

a2460 65
  end
end

class TkOptionMenubutton<TkMenubutton
  class OptionMenu<TkMenu
    def initialize(parent)
      @@path = parent.path + '.menu'
      TkComm::Tk_WINDOWS[@@path] = self
    end
  end

  def initialize(parent=nil, var=TkVariable.new, firstval=nil, *vals)
    fail unless var.kind_of? TkVariable
    @@variable = var
    firstval = @@variable.value unless firstval
    @@variable.value = firstval
    install_win(if parent then parent.path end)
    @@menu = OptionMenu.new(self)
    tk_call 'tk_optionMenu', @@path, @@variable.id, firstval, *vals
  end

  def value
    @@variable.value
  end

  def activate(index)
    @@menu.activate(index)
  end
  def add(value)
    @@menu.add('radiobutton', 'variable'=>@@variable, 
	      'label'=>value, 'value'=>value)
  end
  def index(index)
    @@menu.index(index)
  end
  def invoke(index)
    @@menu.invoke(index)
  end
  def insert(index, value)
    @@menu.add(index, 'radiobutton', 'variable'=>@@variable, 
	      'label'=>value, 'value'=>value)
  end
  def delete(index, last=None)
    @@menu.delete(index, last)
  end
  def yposition(index)
    @@menu.yposition(index)
  end
  def menucget(index, key)
    @@menu.cget(index, key)
  end
  def menuconfigure(index, key, val=None)
    @@menu.configure(index, key, val)
  end
  def menuconfiginfo(index, key=nil)
    @@menu.configinfo(index, key)
  end
  def entrycget(index, key)
    @@menu.entrycget(index, key)
  end
  def entryconfigure(index, key, val=None)
    @@menu.entryconfigure(index, key, val)
  end
  def entryconfiginfo(index, key=nil)
    @@menu.entryconfiginfo(index, key)
@


1.3.2.10
log
@tk font patch
@
text
@d3 1
a3 1
#			$Date: 2000/06/13 09:50:56 $
a595 30
  def Tk.show_kinsoku(mode='both')
    begin
      if /^8\.*/ === TK_VERSION  && JAPANIZED_TK
        tk_split_simplelist(tk_call('kinsoku', 'show', mode))
      end
    rescue
    end
  end
  def Tk.add_kinsoku(chars, mode='both')
    begin
      if /^8\.*/ === TK_VERSION  && JAPANIZED_TK
        tk_split_simplelist(tk_call('kinsoku', 'add', mode, 
                                    *(chars.split(''))))
      else
        []
      end
    rescue
      []
    end
  end
  def Tk.delete_kinsoku(chars, mode='both')
    begin
      if /^8\.*/ === TK_VERSION  && JAPANIZED_TK
        tk_split_simplelist(tk_call('kinsoku', 'delete', mode, 
                            *(chars.split(''))))
      end
    rescue
    end
  end

a1183 67
  end
end

module TkXIM
  include Tk
  extend Tk

  def TkXIM.useinputmethods(window=nil, value=nil)
    if window
      if value
        tk_call 'tk', 'useinputmethods', '-displayof', window.path, value
      else
        tk_call 'tk', 'useinputmethods', '-displayof', window.path
      end
    else
      if value
        tk_call 'tk', 'useinputmethods', value
      else
        tk_call 'tk', 'useinputmethods'
      end
    end
  end

  def TkXIM.configure(window, slot, value=None)
    begin
      if /^8\.*/ === Tk::TK_VERSION  && JAPANIZED_TK
        if slot.kind_of? Hash
          tk_call 'imconfigure', window.path, *hash_kv(slot)
        else
          tk_call 'imconfigure', window.path, "-#{slot}", value
        end
      end
    rescue
    end
  end

  def TkXIM.configinfo(window, slot=nil)
    begin
      if /^8\.*/ === Tk::TK_VERSION  && JAPANIZED_TK
        if slot
          conf = tk_split_list(tk_call('imconfigure', window.path, "-#{slot}"))
          conf[0] = conf[0][1..-1]
          conf
        else
          tk_split_list(tk_call('imconfigure', window.path)).collect{|conf|
            conf[0] = conf[0][1..-1]
            conf
          }
        end
      else
        []
      end
    rescue
      []
    end
  end

  def useinputmethods(value=nil)
    TkXIM.useinputmethods(self, value=nil)
  end

  def imconfigure(window, slot, value=None)
    TkXIM.configinfo(window, slot, value)
  end

  def imconfiginfo(slot=nil)
    TkXIM.configinfo(window, slot)
@


1.3.2.11
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/06/13 09:57:39 $
d530 1
a530 1
  def getOpenFile(keys = nil)
d534 1
a534 1
  def getSaveFile(keys = nil)
d538 1
a538 1
  def chooseColor(keys = nil)
@


1.3.2.12
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/07/10 08:01:45 $
a221 11
  def ruby2tcl(v)
    if v.kind_of?(Hash)
      v = hash_kv(v)
      v.flatten!
      v.collect{|e|ruby2tcl(e)}
    else
      _get_eval_string(v)
    end
  end
  private :ruby2tcl

d544 1
a544 1
    args.filter {|x|ruby2tcl(x)}
@


1.3.2.13
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/07/14 04:33:28 $
d314 1
a314 1
      id = install_cmd(proc{|*arg|
a782 90
    end
  end
end

###########################################
#  convert kanji string to/from utf-8
###########################################
if /^8\.[1-9]/ =~ Tk::TCL_VERSION && !Tk::JAPANIZED_TK
  class TclTkIp
    # from tkencoding.rb by ttate@@jaist.ac.jp
    alias __eval _eval
    alias __invoke _invoke
    private :__eval
    private :__invoke
    
    attr_accessor :encoding
    
    def _eval(cmd)
      if @@encoding
	_fromUTF8(__eval(_toUTF8(cmd, @@encoding)), @@encoding)
      else
	__eval(cmd)
      end
    end
    
    def _invoke(*cmds)
      if @@encoding
	cmds = cmds.collect{|cmd| _toUTF8(cmd, @@encoding)}
	_fromUTF8(__invoke(*cmds), @@encoding)
      else
	__invoke(*cmds)
	end
    end
  end

  module Tk
    def encoding=(name)
      INTERP.encoding = name
    end

    def encoding
      INTERP.encoding
    end

    def encoding_names
      tk_split_simplelist(tk_call('encoding', 'names'))
    end

    def encoding_system
      tk_call('encoding', 'system')
    end

    def encoding_system=(enc)
      tk_call('encoding', 'system', enc)
    end
  end

  # estimate encoding
  case $KCODE
  when /^e/i  # EUC
    Tk.encoding = 'euc-jp'
  when /^s/i  # SJIS
    Tk.encoding = 'shiftjis'
  when /^u/i  # UTF8
    Tk.encoding = 'utf-8'
  else        # NONE
    begin
      Tk.encoding = Tk.encoding_system
    rescue StandardError, NameError
      Tk.encoding = 'utf-8'
    end
  end

else
  # dummy methods
  module Tk
    def encoding=(name)
      nil
    end
    def encoding
      nil
    end
    def encoding_names
      nil
    end
    def encoding_system
      nil
    end
    def encoding_system=(enc)
      nil
@


1.2
log
@remove marshal/gtk/kconv
@
text
@d3 1
a3 1
#			$Date: 1999/07/15 07:59:58 $
d11 2
d39 1
a39 1
    ruby_class = TkClassBind::WidgetClassNameTBL[tk_class]
d333 2
a334 2
  def _bind_core(mode, path, context, cmd, args=nil)
    id = install_bind(cmd, args)
d336 1
a336 1
      tk_call 'bind', path, "<#{tk_event_sequence(context)}>", mode + id
d338 1
a338 1
      uninstall_cmd(id)
d343 2
a344 2
  def _bind(path, context, cmd, args=nil)
    _bind_core('', path, context, cmd, args)
d347 2
a348 2
  def _bind_append(path, context, cmd, args=nil)
    _bind_core('+', path, context, cmd, args)
d353 1
a353 1
    _bind 'all', context, cmd, args
d357 1
a357 9
    _bind_append 'all', context, cmd, args
  end

  def bind(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind tagOrClass, context, cmd, args
  end

  def bind_append(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind_append tagOrClass, context, cmd, args
d360 1
a360 1
  def _bindinfo(tagOrClass, context=nil)
d362 1
a362 2
      (tk_call('bind', tagOrClass, 
	       "<#{tk_event_sequence(context)}>")).collect{|cmdline|
d370 1
a370 1
      tk_split_list(tk_call 'bind', tagOrClass).collect{|seq|
d377 1
a377 1
    _bindinfo tagOrClass, context
d967 1
a967 1
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"'
d1644 1
a1644 1
    _bind path, context, cmd, args
d1648 1
a1648 1
    _bind_append path, context, cmd, args
d1652 1
a1652 1
    _bindinfo path, context
a1676 20
module TkClassBind
  WidgetClassNameTBL = {}

  def TkClassBind.name2class(name)
    WidgetClassNameTBL[name]
  end

  def bind(context, cmd=Proc.new, args=nil)
    Tk.bind to_eval, context, cmd, args
  end

  def bind_append(context, cmd=Proc.new, args=nil)
    Tk.bind_append to_eval, context, cmd, args
  end

  def bindinfo(context=nil)
    Tk.bindinfo to_eval, context
  end
end

d1678 1
a1678 1
  extend TkClassBind
d1829 1
a1829 1
	elsif tag.kind_of?(String) && (cls = TkClassBind.name2class(tag))
d1850 1
a1850 1
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
d1867 1
a1867 1
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
d1927 1
a1927 1
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
d1967 1
a1967 1
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
d1980 1
a1980 1
  TkClassBind::WidgetClassNameTBL['Button'] = self
d1996 1
a1996 1
  TkClassBind::WidgetClassNameTBL['Radiobutton'] = self
d2015 1
a2015 1
  TkClassBind::WidgetClassNameTBL['Checkbutton'] = self
d2028 1
a2028 1
  TkClassBind::WidgetClassNameTBL['Message'] = self
d2039 1
a2039 1
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
d2067 1
a2067 1
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
d2134 1
a2134 1
  TkClassBind::WidgetClassNameTBL['Listbox'] = self
d2291 1
a2291 1
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
d2371 1
a2371 1
  TkClassBind::WidgetClassNameTBL['Menubutton'] = self
@


1.1
log
@file tk.rb was initially added on branch v1_1r.
@
text
@d1 2495
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@a0 2499
#
#		tk.rb - Tk interface modue using tcltklib
#			$Date: 1998/11/17 09:12:44 $
#			by Yukihiro Matsumoto <matz@@netlab.co.jp>

# use Shigehiro's tcltklib
require "tcltklib"
require "tkutil"

module TkComm
  None = Object.new
  def None.to_s
    'None'
  end

  Tk_CMDTBL = {}
  Tk_WINDOWS = {}

  def error_at
    frames = caller()
    frames.delete_if do |c|
      c =~ %r!/tk(|core|thcore|canvas|text|entry|scrollbox)\.rb:\d+!
    end
    frames
  end
  private :error_at

  def _genobj_for_tkwidget(path)
    return TkRoot.new if path == '.'

    begin
      tk_class = TkCore::INTERP._invoke('winfo', 'class', path)
    rescue
      return path
    end

    ruby_class = TkClassBind::WidgetClassNameTBL[tk_class]
    gen_class_name = ruby_class.name + 'GeneratedOnTk'
    unless Object.const_defined? gen_class_name
      eval "class #{gen_class_name}<#{ruby_class.name}
              def initialize(path)
                @@path=path
                Tk_WINDOWS[@@path] = self
              end
            end"
    end
    eval "#{gen_class_name}.new('#{path}')"
  end

  def tk_tcl2ruby(val)
    if val =~ /^rb_out (c\d+)/
      return Tk_CMDTBL[$1]
    end
    if val.include? ?\s
      return val.split.collect{|v| tk_tcl2ruby(v)}
    end
    case val
    when /^@@font/
      TkFont.get_obj(val)
    when /^-?\d+$/
      val.to_i
    when /^\./
      Tk_WINDOWS[val] ? Tk_WINDOWS[val] : _genobj_for_tkwidget(val)
    when / /
      val.split.collect{|elt|
	tk_tcl2ruby(elt)
      }
    when /^-?\d+\.\d*$/
      val.to_f
    else
      val
    end
  end

  def tk_split_list(str)
    return [] if str == ""
    idx = str.index('{')
    return tk_tcl2ruby(str) unless idx

    list = tk_tcl2ruby(str[0,idx])
    list = [] if list == ""
    str = str[idx+1..-1]
    i = -1
    brace = 1
    str.each_byte {|c|
      i += 1
      brace += 1 if c == ?{
      brace -= 1 if c == ?}
      break if brace == 0
    }
    if str[0, i] == ' '
      list.push ' '
    else
      list.push tk_split_list(str[0, i])
    end
    list += tk_split_list(str[i+1..-1])
    list
  end

  def tk_split_simplelist(str)
    return [] if str == ""
    idx = str.index('{')
    return str.split unless idx

    list = str[0,idx].split
    str = str[idx+1..-1]
    i = -1
    brace = 1
    str.each_byte {|c|
      i += 1
      brace += 1 if c == ?{
      brace -= 1 if c == ?}
      break if brace == 0
    }
    if i == 0
      list.push ''
    elsif str[0, i] == ' '
      list.push ' '
    else
      list.push str[0..i-1]
    end
    list += tk_split_simplelist(str[i+1..-1])
    list
  end
  private :tk_tcl2ruby, :tk_split_list, :tk_split_simplelist

  def hash_kv(keys)
    conf = []
    if keys and keys != None
      for k, v in keys
	 conf.push("-#{k}")
	 conf.push(v)
      end
    end
    conf
  end
  private :hash_kv

  def array2tk_list(ary)
    ary.collect{|e|
      if e.kind_of? Array
	"{#{array2tk_list(e)}}"
      elsif e.kind_of? Hash
	"{#{e.to_a.collect{|ee| array2tk_list(ee)}.join(' ')}}"
      else
	s = _get_eval_string(e)
	(s.index(/\s/))? "{#{s}}": s
      end
    }.join(" ")
  end
  private :array2tk_list

  def bool(val)
    case val
    when "1", 1, 'yes', 'true'
      TRUE
    else
      FALSE
    end
  end
  def number(val)
    case val
    when /^-?\d+$/
      val.to_i
    when /^-?\d+\.\d*$/
      val.to_f
    else
      val
    end
  end
  def string(val)
    if val == "{}"
      ''
    elsif val[0] == ?{
      val[1..-2]
    else
      val
    end
  end
  def list(val)
    tk_split_list(val).to_a
  end
  def window(val)
    Tk_WINDOWS[val]
  end
  def procedure(val)
    if val =~ /^rb_out (c\d+)/
      Tk_CMDTBL[$1]
    else
      nil
    end
  end
  private :bool, :number, :string, :list, :window, :procedure

  def _get_eval_string(str)
    return nil if str == None
    if str.kind_of?(Hash)
      str = hash_kv(str).join(" ")
    elsif str.kind_of?(Array)
      str = array2tk_list(str)
    elsif str.kind_of?(Proc)
      str = install_cmd(str)
    elsif str == nil
      str = ""
    elsif str == false
      str = "0"
    elsif str == true
      str = "1"
    elsif (str.respond_to?(:to_eval))
      str = str.to_eval()
    else
      str = str.to_s()
    end
    return str
  end
  private :_get_eval_string

  Tk_IDs = [0, 0]		# [0]-cmdid, [1]-winid
  def _curr_cmd_id
    id = format("c%.4d", Tk_IDs[0])
  end
  def _next_cmd_id
    id = _curr_cmd_id
    Tk_IDs[0] += 1
    id
  end
  def install_cmd(cmd)
    return '' if cmd == ''
    id = _next_cmd_id
    Tk_CMDTBL[id] = cmd
    @@cmdtbl = [] if not @@cmdtbl
    @@cmdtbl.push id
    return format("rb_out %s", id);
  end
  def uninstall_cmd(id)
    Tk_CMDTBL[id] = nil
  end
  private :install_cmd, :uninstall_cmd

  def install_win(ppath)
    id = format("w%.4d", Tk_IDs[1])
    Tk_IDs[1] += 1
    if !ppath or ppath == "."
      @@path = format(".%s", id);
    else
      @@path = format("%s.%s", ppath, id)
    end
    Tk_WINDOWS[@@path] = self
  end

  def uninstall_win()
    Tk_WINDOWS[@@path] = nil
  end

  class Event
    def initialize(seq,b,f,h,k,s,t,w,x,y,aa,ee,kk,nn,ww,tt,xx,yy)
      @@serial = seq
      @@num = b
      @@focus = (f == 1)
      @@height = h
      @@keycode = k
      @@state = s
      @@time = t
      @@width = w
      @@x = x
      @@y = y
      @@char = aa
      @@send_event = (ee == 1)
      @@keysym = kk
      @@keysym_num = nn
      @@type = tt
      @@widget = ww
      @@x_root = xx
      @@y_root = yy
    end
    attr :serial
    attr :num
    attr :focus
    attr :height
    attr :keycode
    attr :state
    attr :time
    attr :width
    attr :x
    attr :y
    attr :char
    attr :send_event
    attr :keysym
    attr :keysym_num
    attr :type
    attr :widget
    attr :x_root
    attr :y_root
  end

  def install_bind(cmd, args=nil)
    if args
      id = install_cmd(proc{|arg|
	TkUtil.eval_cmd cmd, *arg
      })
      id + " " + args
    else
      id = install_cmd(proc{|arg|
	TkUtil.eval_cmd cmd, Event.new(*arg)
      })
      id + ' %# %b %f %h %k %s %t %w %x %y %A %E %K %N %W %T %X %Y'
    end
  end

  def tk_event_sequence(context)
    if context.kind_of? TkVirtualEvent
      context = context.path
    end
    if context.kind_of? Array
      context = context.collect{|ev|
	if context.kind_of? TkVirtualEvent
	  ev.path
	else
	  ev
	end
      }.join("><")
    end
    if /,/ =~ context
      context = context.split(/\s*,\s*/).join("><")
    else
      context
    end
  end

  def _bind_core(mode, path, context, cmd, args=nil)
    id = install_bind(cmd, args)
    begin
      tk_call 'bind', path, "<#{tk_event_sequence(context)}>", mode + id
    rescue
      uninstall_cmd(id)
      fail
    end
  end

  def _bind(path, context, cmd, args=nil)
    _bind_core('', path, context, cmd, args)
  end

  def _bind_append(path, context, cmd, args=nil)
    _bind_core('+', path, context, cmd, args)
  end
  private :install_bind, :tk_event_sequence, :_bind_core, :_bind, :_bind_append

  def bind_all(context, cmd=Proc.new, args=nil)
    _bind 'all', context, cmd, args
  end

  def bind_append_all(context, cmd=Proc.new, args=nil)
    _bind_append 'all', context, cmd, args
  end

  def bind(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind tagOrClass, context, cmd, args
  end

  def bind_append(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind_append tagOrClass, context, cmd, args
  end

  def _bindinfo(tagOrClass, context=nil)
    if context
      (tk_call('bind', tagOrClass, 
	       "<#{tk_event_sequence(context)}>")).collect{|cmdline|
	if cmdline =~ /^rb_out (c\d+)\s+(.*)$/
	  [Tk_CMDTBL[$1], $2]
	else
	  cmdline
	end
      }
    else
      tk_split_list(tk_call 'bind', tagOrClass).collect{|seq|
	seq[1..-2].gsub(/></,',')
      }
    end
  end

  def bindinfo(tagOrClass, context=nil)
    _bindinfo tagOrClass, context
  end

  def pack(*args)
    TkPack.configure *args
  end

  def grid(*args)
    TkGrid.configure *args
  end

  def update(idle=nil)
    if idle
      tk_call 'update', 'idletasks'
    else
      tk_call 'update'
    end
  end

end

module TkCore
  include TkComm
  extend TkComm

  INTERP = TclTkIp.new

  INTERP._invoke("proc", "rb_out", "args", "if {[set st [catch {ruby [format \"TkCore.callback %%Q!%s!\" $args]} ret]] != 0} {return -code $st $ret} {return $ret}")

  def callback_break
    raise TkCallbackBreak, "Tk callback returns 'break' status"
  end

  def callback_continue
    raise TkCallbackContinue, "Tk callback returns 'continue' status"
  end

  def after(ms, cmd=Proc.new)
    myid = _curr_cmd_id
    cmdid = install_cmd(cmd)
    tk_call("after",ms,cmdid)
    return
    if false #defined? Thread
      Thread.start do
	ms = Float(ms)/1000
	ms = 10 if ms == 0
	sleep ms/1000
	cmd.call
      end
    else
      cmdid = install_cmd(cmd)
      tk_call("after",ms,cmdid)
    end
  end

  def TkCore.callback(arg)
    arg = Array(tk_split_list(arg))
    _get_eval_string(TkUtil.eval_cmd(Tk_CMDTBL[arg.shift], *arg))
  end

  def appname(name=None)
    tk_call('tk', 'appname', name)
  end

  def appsend(interp, async, *args)
    if async
      tk_call('send', '-async', '--', interp, *args)
    else
      tk_call('send', '--', interp, *args)
    end
  end

  def rb_appsend(interp, async, *args)
    args = args.filter{|c| _get_eval_string(c).gsub(/[][$"]/, '\\\\\&')}
    args.push(').to_s"')
    appsend(interp, async, 'ruby "(', *args)
  end

  def appsend_displayof(interp, win, async, *args)
    win = '.' if win == nil
    if async
      tk_call('send', '-async', '-displayof', win, '--', interp, *args)
    else
      tk_call('send', '-displayor', win, '--', interp, *args)
    end
  end

  def rb_appsend_displayof(interp, win, async, *args)
    args = args.filter{|c| _get_eval_string(c).gsub(/[][$"]/, '\\\\\&')}
    args.push(').to_s"')
    appsend_displayof(interp, win, async, 'ruby "(', *args)
  end

  def info(*args)
    tk_call('info', *args)
  end

  def mainloop
    TclTkLib.mainloop
  end

  def event_generate(window, context, keys=nil)
    window = window.path if window.kind_of? TkObject
    if keys
      tk_call('event', 'generate', window, 
	      "<#{tk_event_sequence(context)}>", *hash_kv(keys))
    else
      tk_call('event', 'generate', window, "<#{tk_event_sequence(context)}>")
    end
  end

  def messageBox(keys)
    tk_call 'tk_messageBox', *hash_kv(keys)
  end

  def getOpenFile(keys)
    tk_call 'tk_getOpenFile', *hash_kv(keys)
  end

  def getSaveFile(keys)
    tk_call 'tk_getSaveFile', *hash_kv(keys)
  end

  def chooseColor(keys)
    tk_call 'tk_chooseColor', *hash_kv(keys)
  end

  def tk_call(*args)
    print args.join(" "), "\n" if $DEBUG
    args.filter {|x|_get_eval_string(x)}
    args.compact!
    args.flatten!
    begin
      res = INTERP._invoke(*args)
    rescue NameError
      err = $!
      begin
        args.unshift "unknown"
        res = INTERP._invoke(*args)
      rescue
	raise unless /^invalid command/ =~ $!
	raise err
      end
    end
    if  INTERP._return_value() != 0
      fail RuntimeError, res, error_at
    end
    print "==> ", res, "\n" if $DEBUG
    return res
  end
end

module Tk
  include TkCore
  extend Tk

  TCL_VERSION = INTERP._invoke("info", "tclversion")
  TK_VERSION  = INTERP._invoke("set", "tk_version")
  JAPANIZED_TK = (INTERP._invoke("info", "commands", "kanji") != "")

  def root
    TkRoot.new
  end

  def bell
    tk_call 'bell'
  end

  def Tk.focus(display=nil)
    if display == nil
      r = tk_call('focus')
    else
      r = tk_call('focus', '-displayof', display)
    end
    tk_tcl2ruby(r)
  end

  def Tk.focus_lastfor(win)
    tk_tcl2ruby(tk_call('focus', '-lastfor', win))
  end

  def toUTF8(str,encoding)
    INTERP._toUTF8(str,encoding)
  end
  
  def fromUTF8(str,encoding)
    INTERP._fromUTF8(str,encoding)
  end

  module Scrollable
    def xscrollcommand(cmd=Proc.new)
      configure_cmd 'xscrollcommand', cmd
    end
    def yscrollcommand(cmd=Proc.new)
      configure_cmd 'yscrollcommand', cmd
    end
  end

  module Wm
    def aspect(*args)
      w = window(tk_call('wm', 'grid', path, *args))
      w.split.collect{|s|s.to_i} if args.length == 0
    end
    def client(name=None)
      tk_call 'wm', 'client', path, name
    end
    def colormapwindows(*args)
      list(tk_call('wm', 'colormapwindows', path, *args))
    end
    def wm_command(value=None)
      string(tk_call('wm', 'command', path, value))
    end
    def deiconify
      tk_call 'wm', 'deiconify', path
    end
    def focusmodel(*args)
      tk_call 'wm', 'focusmodel', path, *args
    end
    def frame
      tk_call 'wm', 'frame', path
    end
    def geometry(*args)
      list(tk_call('wm', 'geometry', path, *args))
    end
    def grid(*args)
      w = tk_call('wm', 'grid', path, *args)
      list(w) if args.size == 0
    end
    def group(*args)
      tk_call 'wm', 'group', path, *args
    end
    def iconbitmap(*args)
      tk_call 'wm', 'iconbitmap', path, *args
    end
    def iconify
      tk_call 'wm', 'iconify', path
    end
    def iconmask(*args)
      tk_call 'wm', 'iconmask', path, *args
    end
    def iconname(*args)
      tk_call 'wm', 'iconname', path, *args
    end
    def iconposition(*args)
      w = tk_call('wm', 'iconposition', path, *args)
      list(w) if args.size == 0
    end
    def iconwindow(*args)
      w = tk_call('wm', 'iconwindow', path, *args)
      window(w) if args.size == 0
    end
    def maxsize(*args)
      w = tk_call('wm', 'maxsize', path, *args)
      list(w) if not args.size == 0
    end
    def minsize(*args)
      w = tk_call('wm', 'minsize', path, *args)
      list(w) if args.size == 0
    end
    def overrideredirect(bool=None)
      if bool == None
	bool(tk_call('wm', 'overrideredirect', path))
      else
	tk_call 'wm', 'overrideredirect', path, bool
      end
    end
    def positionfrom(*args)
      tk_call 'wm', 'positionfrom', path, *args
    end
    def protocol(name=nil, cmd=nil)
      if cmd
	tk_call('wm', 'protocol', path, name, cmd)
      elsif name
	result = tk_call('wm', 'protocol', path, name)
	(result == "")? nil : tk_tcl2ruby(result)
      else
	tk_split_simplelist(tk_call('wm', 'protocol', path))
      end
    end
    def resizable(*args)
      w = tk_call('wm', 'resizable', path, *args)
      if args.length == 0
	list(w).collect{|e| bool(e)}
      end
    end
    def sizefrom(*args)
      list(tk_call('wm', 'sizefrom', path, *args))
    end
    def state
      tk_call 'wm', 'state', path
    end
    def title(*args)
      tk_call 'wm', 'title', path, *args
    end
    def transient(*args)
      tk_call 'wm', 'transient', path, *args
    end
    def withdraw
      tk_call 'wm', 'withdraw', path
    end
  end
end

class TkVariable
  include Tk
  extend TkCore

  TkVar_CB_TBL = {}
  Tk_VARIABLE_ID = ["v00000"]

  INTERP._invoke("proc", "rb_var", "args", "ruby [format \"TkVariable.callback %%Q!%s!\" $args]")

  def TkVariable.callback(args)
    name1,name2,op = tk_split_list(args)
    if TkVar_CB_TBL[name1]
      _get_eval_string(TkVar_CB_TBL[name1].trace_callback(name2,op))
    else
      ''
    end
  end

  def initialize(val="")
    @@id = Tk_VARIABLE_ID[0]
    Tk_VARIABLE_ID[0] = Tk_VARIABLE_ID[0].succ
    if val == []
      INTERP._eval(format('global %s; set %s(0) 0; unset %s(0)', 
			  @@id, @@id, @@id))
    elsif val.kind_of?(Array)
      a = []
      val.each_with_index{|e,i| a.push(i); a.push(array2tk_list(e))}
      s = '"' + a.join(" ").gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; array set %s %s', @@id, @@id, s))
    elsif  val.kind_of?(Hash)
      s = '"' + val.to_a.collect{|e| array2tk_list(e)}.join(" ")\
                   .gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; array set %s %s', @@id, @@id, s))
    else
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
    end
  end

  def wait
    INTERP._eval("tkwait variable #{@@id}")
  end

  def id
    @@id
  end

  def value
    begin
      INTERP._eval(format('global %s; set %s', @@id, @@id))
    rescue
      if INTERP._eval(format('global %s; array exists %s', @@id, @@id)) != "1"
	raise
      else
	Hash[*tk_split_simplelist(INTERP\
				  ._eval(format('global %s; array get %s', 
						@@id, @@id)))]
      end
    end
  end

  def value=(val)
    begin
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
    rescue
      if INTERP._eval(format('global %s; array exists %s', @@id, @@id)) != "1"
	raise
      else
	INTERP._eval(format('global %s; unset %s'), @@id, @@id)
	if val == []
	  INTERP._eval(format('global %s; set %s(0) 0; unset %s(0)', 
			      @@id, @@id, @@id))
	elsif val.kind_of?(Array)
	  a = []
	  val.each_with_index{|e,i| a.push(i); a.push(array2tk_list(e))}
	  s = '"' + a.join(" ").gsub(/[][$"]/, '\\\\\&') + '"' #'
	  INTERP._eval(format('global %s; unset %s; array set %s %s', 
			      @@id, @@id, @@id, s))
	elsif  val.kind_of?(Hash)
	  s = '"' + val.to_a.collect{|e| array2tk_list(e)}.join(" ")\
	                        .gsub(/[][$"]/, '\\\\\&') + '"' #'
	  INTERP._eval(format('global %s; unset %s; array set %s %s', 
			      @@id, @@id, @@id, s))
	else
	  raise
	end
      end
    end
  end

  def [](index)
    INTERP._eval(format('global %s; set %s(%s)', 
			@@id, @@id, _get_eval_string(index)))
  end

  def []=(index,val)
    INTERP._eval(format('global %s; set %s(%s) %s', @@id, @@id, 
			_get_eval_string(index), _get_eval_string(val)))
  end

  def to_i
    Integer(number(value))
  end

  def to_f
    Float(number(value))
  end

  def to_s
    String(string(value))
  end

  def inspect
    format "<TkVariable: %s>", @@id
  end

  def ==(other)
    case other
    when TkVariable
      self.equal(self)
    when String
      self.to_s == other
    when Integer
      self.to_i == other
    when Float
      self.to_f == other
    when Array
      self.to_a == other
    else
      false
    end
  end

  def to_a
    list(value)
  end

  def to_eval
    @@id
  end

  def unset(elem=nil)
    if elem
      INTERP._eval(format('global %s; unset %s(%s)', 
			  @@id, @@id, tk_tcl2ruby(elem)))
    else
      INTERP._eval(format('global %s; unset %s', @@id, @@id))
    end
  end
  alias remove unset

  def trace_callback(elem, op)
    if @@trace_var.kind_of? Array
      @@trace_var.each{|m,e| e.call(self,elem,op) if m.index(op)}
    end
    if elem.kind_of? String
      if @@trace_elem[elem].kind_of? Array
	@@trace_elem[elem].each{|m,e| e.call(self,elem,op) if m.index(op)}
      end
    end
  end

  def trace(opts, cmd)
    @@trace_var = [] if @@trace_var == nil
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    @@trace_var.unshift([opts,cmd])
    if @@trace_opts == nil
      TkVar_CB_TBL[@@id] = self
      @@trace_opts = opts
      Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
    else
      newopts = @@trace_opts.dup
      opts.each_byte{|c| newopts += c.chr unless @@newopts.index(c)}
      if newopts != @@trace_opts
	Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
	@@trace_opts.replace(newopts)
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_element(elem, opts, cmd)
    @@trace_elem = {} if @@trace_elem == nil
    @@trace_elem[elem] = [] if @@trace_elem[elem] == nil
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    @@trace_elem[elem].unshift([opts,cmd])
    if @@trace_opts == nil
      TkVar_CB_TBL[@@id] = self
      @@trace_opts = opts
      Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
    else
      newopts = @@trace_opts.dup
      opts.each_byte{|c| newopts += c.chr unless @@newopts.index(c)}
      if newopts != @@trace_opts
	Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
	@@trace_opts.replace(newopts)
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_vinfo
    return [] unless @@trace_var
    @@trace_var.dup
  end
  def trace_vinfo_for_element(elem)
    return [] unless @@trace_elem
    return [] unless @@trace_elem[elem]
    @@trace_elem[elem].dup
  end

  def trace_vdelete(opts,cmd)
    return unless @@trace_var.kind_of? Array
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    idx = -1
    newopts = ''
    @@trace_var.each_with_index{|i,e| 
      if idx < 0 && e[0] == opts && e[1] == cmd
	idx = i
	next
      end
      e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
    }
    if idx >= 0
      @@trace_var.delete_at(idx) 
    else
      return
    end

    @@trace_elem.each{|elem|
      @@trace_elem[elem].each{|e|
	e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
      }
    }

    newopts = ['r','w','u'].find_all{|c| newopts.index(c)}.join('')
    if newopts != @@trace_opts
      Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
      @@trace_opts.replace(newopts)
      if @@trace_opts != ''
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_vdelete_for_element(elem,opts,cmd)
    return unless @@trace_elem.kind_of? Hash
    return unless @@trace_elem[elem].kind_of? Array
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    idx = -1
    @@trace_elem[elem].each_with_index{|i,e| 
      if idx < 0 && e[0] == opts && e[1] == cmd
	idx = i
	next
      end
    }
    if idx >= 0
      @@trace_elem[elem].delete_at(idx)
    else
      return
    end

    newopts = ''
    @@trace_var.each{|e| 
      e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
    }
    @@trace_elem.each{|elem|
      @@trace_elem[elem].each{|e|
	e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
      }
    }

    newopts = ['r','w','u'].find_all{|c| newopts.index(c)}.join('')
    if newopts != @@trace_opts
      Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
      @@trace_opts.replace(newopts)
      if @@trace_opts != ''
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end
end

class TkVarAccess<TkVariable
  def initialize(varname, val=nil)
    @@id = varname
    if val
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
    end
  end
end

module TkSelection
  include Tk
  extend Tk
  def clear(win=Tk.root)
    tk_call 'selection', 'clear', win.path
  end
  def get(type=None)
    tk_call 'selection', 'get', type
  end
  def TkSelection.handle(win, func, type=None, format=None)
    id = install_cmd(func)
    tk_call 'selection', 'handle', win.path, id, type, format
  end
  def handle(func, type=None, format=None)
    TkSelection.handle self, func, type, format
  end
  def TkSelection.own(win, func=None)
    id = install_cmd(func)
    tk_call 'selection', 'own', win.path, id
  end
  def own(func=None)
    TkSelection.own self, func
  end

  module_function :clear, :get
end

module TkKinput
  include Tk
  extend Tk

  def TkKinput.start(window, style=None)
    tk_call 'kinput_start', window.path, style
  end
  def kinput_start(style=None)
    TkKinput.start(self, style)
  end

  def TkKinput.send_spot(window)
    tk_call 'kinput_send_spot', window.path
  end
  def kinput_send_spot
    TkKinput.send_spot(self)
  end

  def TkKinput.input_start(window, keys=nil)
    tk_call 'kanjiInput', 'start', window.path, *hash_kv(keys)
  end
  def kanji_input_start(keys=nil)
    TkKinput.input_start(self, keys)
  end

  def TkKinput.attribute_config(window, slot, value=None)
    if slot.kind_of? Hash
      tk_call 'kanjiInput', 'attribute', window.path, *hash_kv(slot)
    else
      tk_call 'kanjiInput', 'attribute', window.path, "-#{slot}", value
    end
  end
  def kinput_attribute_config(slot, value=None)
    TkKinput.attribute_config(self, slot, value)
  end

  def TkKinput.attribute_info(window, slot=nil)
    if slot
      conf = tk_split_list(tk_call('kanjiInput', 'attribute', 
				   window.path, "-#{slot}"))
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_call('kanjiInput', 'attribute', 
			    window.path)).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end
  def kinput_attribute_info(slot=nil)
    TkKinput.attribute_info(self, slot)
  end

  def TkKinput.input_end(window)
    tk_call 'kanjiInput', 'end', window.path
  end
  def kanji_input_end
    TkKinput.input_end(self)
  end
end

module TkWinfo
  include Tk
  extend Tk
  def TkWinfo.atom(name)
    tk_call 'winfo', name
  end
  def winfo_atom(name)
    TkWinfo.atom name
  end
  def TkWinfo.atomname(id)
    tk_call 'winfo', id
  end
  def winfo_atomname(id)
    TkWinfo.atomname id
  end
  def TkWinfo.cells(window)
    number(tk_call('winfo', window.path))
  end
  def winfo_cells
    TkWinfo.cells self
  end
  def TkWinfo.children(window)
    c = tk_call('winfo', 'children', window.path)
    list(c)
  end
  def winfo_children
    TkWinfo.children self
  end
  def TkWinfo.classname(window)
    tk_call 'winfo', 'class', window.path
  end
  def winfo_classname
    TkWinfo.classname self
  end
  def TkWinfo.containing(rootX, rootY)
    path = tk_call('winfo', 'containing', rootX, rootY)
    window(path)
  end
  def winfo_containing(x, y)
    TkWinfo.containing x, y
  end
  def TkWinfo.depth(window)
    number(tk_call('winfo', 'depth', window.path))
  end
  def winfo_depth
    TkWinfo.depth self
  end
  def TkWinfo.exist?(window)
    bool(tk_call('winfo', 'exists', window.path))
  end
  def winfo_exist?
    TkWinfo.exist? self
  end
  def TkWinfo.fpixels(window, number)
    number(tk_call('winfo', 'fpixels', window.path, number))
  end
  def winfo_fpixels(number)
    TkWinfo.fpixels self, number
  end
  def TkWinfo.geometry(window)
    list(tk_call('winfo', 'geometry', window.path))
  end
  def winfo_geometry
    TkWinfo.geometry self
  end
  def TkWinfo.height(window)
    number(tk_call('winfo', 'height', window.path))
  end
  def winfo_height
    TkWinfo.height self
  end
  def TkWinfo.id(window)
    number(tk_call('winfo', 'id', window.path))
  end
  def winfo_id
    TkWinfo.id self
  end
  def TkWinfo.interps(window=nil)
    if window
      tk_split_simplelist(tk_call('winfo', '-displayof', window.path, 
				  'interps'))
    else
      tk_split_simplelist(tk_call('winfo', 'interps'))
    end
  end
  def winfo_interps
    TkWinfo.interps self
  end
  def TkWinfo.mapped?(window)
    bool(tk_call('winfo', 'ismapped', window.path))
  end
  def winfo_mapped?
    TkWinfo.mapped? self
  end
  def TkWinfo.appname(window)
    bool(tk_call('winfo', 'name', window.path))
  end
  def winfo_appname
    TkWinfo.appname self
  end
  def TkWinfo.parent(window)
    window(tk_call('winfo', 'parent', window.path))
  end
  def winfo_parent
    TkWinfo.parent self
  end
  def TkWinfo.widget(id)
    window(tk_call('winfo', 'pathname', id))
  end
  def winfo_widget(id)
    TkWinfo.widget id
  end
  def TkWinfo.pixels(window, number)
    number(tk_call('winfo', 'pixels', window.path, number))
  end
  def winfo_pixels(number)
    TkWinfo.pixels self, number
  end
  def TkWinfo.reqheight(window)
    number(tk_call('winfo', 'reqheight', window.path))
  end
  def winfo_reqheight
    TkWinfo.reqheight self
  end
  def TkWinfo.reqwidth(window)
    number(tk_call('winfo', 'reqwidth', window.path))
  end
  def winfo_reqwidth
    TkWinfo.reqwidth self
  end
  def TkWinfo.rgb(window, color)
    list(tk_call('winfo', 'rgb', window.path, color))
  end
  def winfo_rgb(color)
    TkWinfo.rgb self, color
  end
  def TkWinfo.rootx(window)
    number(tk_call('winfo', 'rootx', window.path))
  end
  def winfo_rootx
    TkWinfo.rootx self
  end
  def TkWinfo.rooty(window)
    number(tk_call('winfo', 'rooty', window.path))
  end
  def winfo_rooty
    TkWinfo.rooty self
  end
  def TkWinfo.screen(window)
    tk_call 'winfo', 'screen', window.path
  end
  def winfo_screen
    TkWinfo.screen self
  end
  def TkWinfo.screencells(window)
    number(tk_call('winfo', 'screencells', window.path))
  end
  def winfo_screencells
    TkWinfo.screencells self
  end
  def TkWinfo.screendepth(window)
    number(tk_call('winfo', 'screendepth', window.path))
  end
  def winfo_screendepth
    TkWinfo.screendepth self
  end
  def TkWinfo.screenheight (window)
    number(tk_call('winfo', 'screenheight', window.path))
  end
  def winfo_screenheight
    TkWinfo.screenheight self
  end
  def TkWinfo.screenmmheight(window)
    number(tk_call('winfo', 'screenmmheight', window.path))
  end
  def winfo_screenmmheight
    TkWinfo.screenmmheight self
  end
  def TkWinfo.screenmmwidth(window)
    number(tk_call('winfo', 'screenmmwidth', window.path))
  end
  def winfo_screenmmwidth
    TkWinfo.screenmmwidth self
  end
  def TkWinfo.screenvisual(window)
    tk_call 'winfo', 'screenvisual', window.path
  end
  def winfo_screenvisual
    TkWinfo.screenvisual self
  end
  def TkWinfo.screenwidth(window)
    number(tk_call('winfo', 'screenwidth', window.path))
  end
  def winfo_screenwidth
    TkWinfo.screenwidth self
  end
  def TkWinfo.toplevel(window)
    window(tk_call('winfo', 'toplevel', window.path))
  end
  def winfo_toplevel
    TkWinfo.toplevel self
  end
  def TkWinfo.visual(window)
    tk_call 'winfo', 'visual', window.path
  end
  def winfo_visual
    TkWinfo.visual self
  end
  def TkWinfo.vrootheigh(window)
    number(tk_call('winfo', 'vrootheight', window.path))
  end
  def winfo_vrootheight
    TkWinfo.vrootheight self
  end
  def TkWinfo.vrootwidth(window)
    number(tk_call('winfo', 'vrootwidth', window.path))
  end
  def winfo_vrootwidth
    TkWinfo.vrootwidth self
  end
  def TkWinfo.vrootx(window)
    number(tk_call('winfo', 'vrootx', window.path))
  end
  def winfo_vrootx
    TkWinfo.vrootx self
  end
  def TkWinfo.vrooty(window)
    number(tk_call('winfo', 'vrooty', window.path))
  end
  def winfo_vrooty
    TkWinfo.vrooty self
  end
  def TkWinfo.width(window)
    number(tk_call('winfo', 'width', window.path))
  end
  def winfo_width
    TkWinfo.width self
  end
  def TkWinfo.x(window)
    number(tk_call('winfo', 'x', window.path))
  end
  def winfo_x
    TkWinfo.x self
  end
  def TkWinfo.y(window)
    number(tk_call('winfo', 'y', window.path))
  end
  def winfo_y
    TkWinfo.y self
  end
  def TkWinfo.viewable(window)
    bool(tk_call 'winfo', 'viewable', window.path)
  end
  def winfo_viewable
    TkWinfo.viewable self
  end
  def TkWinfo.pointerx(window)
    number(tk_call('winfo', 'pointerx', window.path))
  end
  def winfo_pointerx
    TkWinfo.pointerx self
  end
  def TkWinfo.pointery(window)
    number(tk_call('winfo', 'pointery', window.path))
  end
  def winfo_pointery
    TkWinfo.pointery self
  end
  def TkWinfo.pointerxy(window)
    list(tk_call('winfo', 'pointerxy', window.path))
  end
  def winfo_pointerxy
    TkWinfo.pointerxy self
  end
end

module TkPack
  include Tk
  extend Tk
  def configure(win, *args)
    if args[-1].kind_of?(Hash)
      keys = args.pop
    end
    wins = [win.epath]
    for i in args
      wins.push i.epath
    end
    tk_call "pack", 'configure', *(wins+hash_kv(keys))
  end

  def forget(*args)
    tk_call 'pack', 'forget' *args
  end

  def propagate(master, bool=None)
    bool(tk_call('pack', 'propagate', master.epath, bool))
  end
  module_function :configure, :forget, :propagate
end

module TkGrid
  include Tk
  extend Tk

  def bbox(*args)
    list(tk_call('grid', 'bbox', *args))
  end

  def configure(widget, *args)
    if args[-1].kind_of?(Hash)
      keys = args.pop
    end
    wins = [widget.epath]
    for i in args
      wins.push i.epath
    end
    tk_call "grid", 'configure', *(wins+hash_kv(keys))
  end

  def columnconfigure(master, index, args)
    tk_call "grid", 'columnconfigure', master, index, *hash_kv(args)
  end

  def rowconfigure(master, index, args)
    tk_call "grid", 'rowconfigure', master, index, *hash_kv(args)
  end

  def add(widget, *args)
    configure(widget, *args)
  end

  def forget(*args)
    tk_call 'grid', 'forget', *args
  end

  def info(slave)
    list(tk_call('grid', 'info', slave))
  end

  def location(master, x, y)
    list(tk_call('grid', 'location', master, x, y))
  end

  def propagate(master, bool=None)
    bool(tk_call('grid', 'propagate', master.epath, bool))
  end

  def remove(*args)
    tk_call 'grid', 'remove', *args
  end

  def size(master)
    tk_call 'grid', 'size', master
  end

  def slaves(args)
    list(tk_call('grid', 'slaves', *hash_kv(args)))
  end

  module_function :bbox, :forget, :propagate, :info
  module_function :remove, :size, :slaves, :location
  module_function :configure, :columnconfigure, :rowconfigure
end

module TkOption
  include Tk
  extend Tk
  def add pat, value, pri=None
    tk_call 'option', 'add', pat, value, pri
  end
  def clear
    tk_call 'option', 'clear'
  end
  def get win, name, klass
    tk_call 'option', 'get', win ,name, klass
  end
  def readfile file, pri=None
    tk_call 'option', 'readfile', file, pri
  end
  module_function :add, :clear, :get, :readfile
end

module TkTreatFont
  def font_configinfo
    ret = TkFont.used_on(self.path)
    if ret == nil
      ret = TkFont.init_widget_font(self.path, self.path, 'configure')
    end
    ret
  end
  alias fontobj font_configinfo

  def font_configure(slot)
    if (fnt = slot['font'])
      slot['font'] = nil
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(self.path, self.path,'configure',slot)
      else
	latinfont_configure(fnt) if fnt
      end
    end
    if (ltn = slot['latinfont'])
      slot['latinfont'] = nil
      latinfont_configure(ltn) if ltn
    end
    if (ltn = slot['asciifont'])
      slot['asciifont'] = nil
      latinfont_configure(ltn) if ltn
    end
    if (knj = slot['kanjifont'])
      slot['kanjifont'] = nil
      kanjifont_configure(knj) if knj
    end

    tk_call(self.path, 'configure', *hash_kv(slot)) if slot != {}
    self
  end

  def latinfont_configure(ltn, keys=nil)
    fobj = fontobj
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val}
      if keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciifont_configure latinfont_configure

  def kanjifont_configure(knj, keys=nil)
    fobj = fontobj
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val}
      if keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(cond)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def font_copy(window, tag=nil)
    if tag
      window.tagfontobj(tag).configinfo.each{|key,value|
	fontobj.configure(key,value)
      }
      fontobj.replace(window.tagfontobj(tag).latin_font, 
		      window.tagfontobj(tag).kanji_font)
    else
      window.fontobj.configinfo.each{|key,value|
	fontobj.configure(key,value)
      }
      fontobj.replace(window.fontobj.latin_font, window.fontobj.kanji_font)
    end
  end

  def latinfont_copy(window, tag=nil)
    if tag
      fontobj.latin_replace(window.tagfontobj(tag).latin_font)
    else
      fontobj.latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciifont_copy latinfont_copy

  def kanjifont_copy(window, tag=nil)
    if tag
      fontobj.kanji_replace(window.tagfontobj(tag).kanji_font)
    else
      fontobj.kanji_replace(window.fontobj.kanji_font)
    end
  end
end

class TkObject<TkKernel
  include Tk
  include TkTreatFont

  def path
    return @@path
  end

  def epath
    return @@path
  end

  def to_eval
    @@path
  end

  def tk_send(cmd, *rest)
    tk_call path, cmd, *rest
  end
  private :tk_send

  def method_missing(id, *args)
    name = id.id2name
    case args.length
    when 1
      configure name, args[0]
    when 0
      begin
	cget name
      rescue
	fail NameError, "undefined local variable or method `#{name}' for #{self.to_s}", error_at
      end
    else
      fail NameError, "undefined method `#{name}' for #{self.to_s}", error_at
    end
  end

  def [](id)
    cget id
  end

  def []=(id, val)
    configure id, val
  end

  def cget(slot)
    tk_tcl2ruby tk_call path, 'cget', "-#{slot}"
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      if ( slot['font'] || slot['kanjifont'] \
	  || slot['latinfont'] || slot['asciifont'] )
	font_configure(slot.dup)
      else
	tk_call path, 'configure', *hash_kv(slot)
      end

    else
      if ( slot == 'font' || slot == 'kanjifont' \
	  || slot == 'latinfont' || slot == 'asciifont' )
	font_configure({slot=>value})
      else
	tk_call path, 'configure', "-#{slot}", value
      end
    end
  end

  def configure_cmd(slot, value)
    configure slot, install_cmd(value)
  end

  def configinfo(slot = nil)
    if slot == 'font' || slot == 'kanjifont'
      fontobj

    else
      if slot
	conf = tk_split_list(tk_send('configure', "-#{slot}") )
	conf[0] = conf[0][1..-1]
	conf

      else
	ret = tk_split_list(tk_send('configure') ).collect{|conf|
	  conf[0] = conf[0][1..-1]
	  conf
	}
	if ret.assoc('font')
	  ret.delete_if{|item| item[0] == 'font' || item[0] == 'kanjifont'}
	  ret.push(['font', fontobj])
	else
	  ret
	end
      end
    end
  end

  def bind(context, cmd=Proc.new, args=nil)
    _bind path, context, cmd, args
  end

  def bind_append(context, cmd=Proc.new, args=nil)
    _bind_append path, context, cmd, args
  end

  def bindinfo(context=nil)
    _bindinfo path, context
  end

  def event_generate(context, keys=nil)
    if keys
      tk_call('event', 'generate', path, 
	      "<#{tk_event_sequence(context)}>", *hash_kv(keys))
    else
      tk_call('event', 'generate', path, "<#{tk_event_sequence(context)}>")
    end
  end

  def tk_trace_variable(v)
    unless v.kind_of?(TkVariable)
      fail ArgumentError, format("requires TkVariable given %s", v.type)
    end
    v
  end
  private :tk_trace_variable

  def destroy
    tk_call 'trace', 'vdelete', @@tk_vn, 'w', @@var_id if @@var_id
  end
end

module TkClassBind
  WidgetClassNameTBL = {}

  def TkClassBind.name2class(name)
    WidgetClassNameTBL[name]
  end

  def bind(context, cmd=Proc.new, args=nil)
    Tk.bind to_eval, context, cmd, args
  end

  def bind_append(context, cmd=Proc.new, args=nil)
    Tk.bind_append to_eval, context, cmd, args
  end

  def bindinfo(context=nil)
    Tk.bindinfo to_eval, context
  end
end

class TkWindow<TkObject
  extend TkClassBind

  def initialize(parent=nil, keys=nil)
    install_win(if parent then parent.path end)
    create_self
    if keys
      # tk_call @@path, 'configure', *hash_kv(keys)
      configure(keys)
    end
  end

  def create_self
  end
  private :create_self

  def pack(keys = nil)
    tk_call 'pack', epath, *hash_kv(keys)
    self
  end

  def unpack(keys = nil)
    tk_call 'pack', 'forget', epath
    self
  end

  def grid(keys = nil)
    tk_call 'grid', epath, *hash_kv(keys)
    self
  end

  def ungrid(keys = nil)
    tk_call 'grid', 'forget', epath
    self
  end

  def place(keys = nil)
    tk_call 'place', epath, *hash_kv(keys)
    self
  end

  def unplace(keys = nil)
    tk_call 'place', 'forget', epath, *hash_kv(keys)
    self
  end
  alias place_forget unplace

  def place_config(keys)
    tk_call "place", 'configure', epath, *hash_kv(keys)
  end

  def place_info()
    ilist = list(tk_call('place', 'info', epath))
    info = {}
    while key = ilist.shift
      info[key[1..-1]] = ilist.shift
    end
    return info
  end

  def pack_slaves()
    list(tk_call('pack', 'slaves', epath))
  end

  def pack_info()
    ilist = list(tk_call('pack', 'info', epath))
    info = {}
    while key = ilist.shift
      info[key[1..-1]] = ilist.shift
    end
    return info
  end

  def place_slaves()
    list(tk_call('place', 'slaves', epath))
  end

  def focus(force=false)
    if force
      tk_call 'focus', '-force', path
    else
      tk_call 'focus', path
    end
    self
  end

  def grab(*args)
    if !args or args.length == 0
      tk_call 'grab', 'set', path
    elsif args.length == 1
      case args[0]
      when 'global'
	tk_call 'grab', 'set', '-global', path
      else
	val = tk_call('grab', args[0], path)
      end
      case args[0]
      when 'current'
	return window(val)
      when 'status'
	return val
      end
    else
      fail ArgumentError, 'wrong # of args'
    end
  end

  def lower(below=None)
    tk_call 'lower', path, below
    self
  end
  def raise(above=None)
    tk_call 'raise', path, above
    self
  end

  def command(cmd=Proc.new)
    configure_cmd 'command', cmd
  end

  def colormodel model=None
    tk_call 'tk', 'colormodel', path, model
    self
  end

  def destroy
    tk_call 'destroy', path
    if @@cmdtbl
      for id in @@cmdtbl
	uninstall_cmd id
      end
    end
    uninstall_win
  end

  def wait_visibility
    tk_call 'tkwait', 'visibility', path
  end
  alias wait wait_visibility

  def wait_destroy
    tk_call 'tkwait', 'window', path
  end

  def bindtags(taglist=nil)
    if taglist
      fail unless taglist.kind_of? Array
      tk_call('bindtags', path, taglist)
    else
      tk_split_list(tk_call('bindtags', path)).collect{|tag|
	if tag == nil
	  '.'
	elsif tag.kind_of?(String) && (cls = TkClassBind.name2class(tag))
	  cls
	else
	  tag
	end
      }
    end
  end
end

class TkRoot<TkWindow
  include Wm
  ROOT = []
  def TkRoot.new
    return ROOT[0] if ROOT[0]
    new = super
    ROOT[0] = new
    Tk_WINDOWS["."] = new
  end

  WidgetClassName = 'Tk'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def create_self
    @@path = '.'
  end
  def path
    "."
  end
end

class TkToplevel<TkWindow
  include Wm

  WidgetClassName = 'Toplevel'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def initialize(parent=nil, screen=nil, classname=nil, keys=nil)
    if screen.kind_of? Hash
      keys = screen.dup
    else
      @@screen = screen
    end
    @@classname = classname
    if keys.kind_of? Hash
      keys = keys.dup
      if keys['classname']
	@@classname = keys['classname']
	keys['classname'] = nil
      end
      if keys['colormap']
	@@colormap = keys['colormap']
	keys['colormap'] = nil
      end
      if keys['container']
	@@classname = keys['container']
	keys['classname'] = nil
      end
      if keys['screen']
	@@screen = keys['screen']
	keys['screen'] = nil
      end
      if keys['use']
	@@use = keys['use']
	keys['use'] = nil
      end
      if keys['visual']
	@@screen = keys['visual']
	keys['visual'] = nil
      end
    end
    super(parent, keys)
  end

  def create_self
    s = []
    s.push << "-class"     << @@classname if @@classname
    s.push << "-colormap"  << @@colormap  if @@colormap
    s.push << "-container" << @@container if @@container
    s.push << "-screen"    << @@screen    if @@screen 
    s.push << "-use"       << @@use       if @@use
    s.push << "-visual"    << @@visual    if @@visual
    tk_call 'toplevel', @@path, *s
  end

  def specific_class
    @@classname
  end
end

class TkFrame<TkWindow
  WidgetClassName = 'Frame'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def initialize(parent=nil, keys=nil)
    if keys.kind_of? Hash
      keys = keys.dup
      if keys['classname']
	@@classname = keys['classname']
	keys['classname'] = nil
      end
      if keys['colormap']
	@@colormap = keys['colormap']
	keys['colormap'] = nil
      end
      if keys['container']
      @@classname = keys['container']
	keys['classname'] = nil
      end
      if keys['visual']
	@@screen = keys['visual']
	keys['visual'] = nil
      end
    end
    super(parent, keys)
  end

  def create_self
    s = []
    s.push << "-class"     << @@classname if @@classname
    s.push << "-colormap"  << @@colormap  if @@colormap
    s.push << "-container" << @@container if @@container
    s.push << "-visual"    << @@visual    if @@visual
    tk_call 'frame', @@path, *s
  end
end

class TkLabel<TkWindow
  WidgetClassName = 'Label'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end
  def create_self
    tk_call 'label', @@path
  end
  def textvariable(v)
    configure 'textvariable', tk_trace_variable(v)
  end
end

class TkButton<TkLabel
  WidgetClassName = 'Button'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
#  def TkButton.to_eval
  def self.to_eval
    WidgetClassName
  end
  def create_self
    tk_call 'button', @@path
  end
  def invoke
    tk_send 'invoke'
  end
  def flash
    tk_send 'flash'
  end
end

class TkRadioButton<TkButton
  WidgetClassName = 'Radiobutton'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def TkRadioButton.to_eval
    WidgetClassName
  end
  def create_self
    tk_call 'radiobutton', @@path
  end
  def deselect
    tk_send 'deselect'
  end
  def select
    tk_send 'select'
  end
  def variable(v)
    configure 'variable', tk_trace_variable(v)
  end
end

class TkCheckButton<TkRadioButton
  TkClassBind::WidgetClassNameTBL['Checkbutton'] = self
  def TkCheckButton.to_eval
    'Checkbutton'
  end
  def create_self
    tk_call 'checkbutton', @@path
  end
  def toggle
    tk_send 'toggle'
  end
end

class TkMessage<TkLabel
  TkClassBind::WidgetClassNameTBL['Message'] = self
  def TkMessage.to_eval
    'Message'
  end
  def create_self
    tk_call 'message', @@path
  end
end

class TkScale<TkWindow
  WidgetClassName = 'Scale'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def create_self
    tk_call 'scale', path
  end

  def get
    number(tk_send('get'))
  end

  def set(val)
    tk_send "set", val
  end

  def value
    get
  end

  def value= (val)
    set val
  end
end

class TkScrollbar<TkWindow
  WidgetClassName = 'Scrollbar'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def create_self
    tk_call 'scrollbar', path
  end

  def delta(deltax=None, deltay=None)
    number(tk_send('delta', deltax, deltay))
  end

  def fraction(x=None, y=None)
    number(tk_send('fraction', x, y))
  end

  def identify(x=None, y=None)
    tk_send('fraction', x, y)
  end

  def get
    ary1 = tk_send('get', path).split
    ary2 = []
    for i in ary1
      ary2.push number(i)
    end
    ary2
  end

  def set(first, last)
    tk_send "set", first, last
  end
end

class TkTextWin<TkWindow
  def create_self
    raise TypeError, "TkTextWin is abstract class"
  end

  def bbox(index)
    tk_send 'bbox', index
  end
  def delete(first, last=None)
    tk_send 'delete', first, last
  end
  def get(*index)
    tk_send 'get', *index
  end
  def index(index)
    tk_send 'index', index
  end
  def insert(index, chars, *args)
    tk_send 'insert', index, chars, *args
  end
  def scan_mark(x, y)
    tk_send 'scan', 'mark', x, y
  end
  def scan_dragto(x, y)
    tk_send 'scan', 'dragto', x, y
  end
  def see(index)
    tk_send 'see', index
  end
end

class TkListbox<TkTextWin
  TkClassBind::WidgetClassNameTBL['Listbox'] = self
  def TkListbox.to_eval
    'Listbox'
  end
  def create_self
    tk_call 'listbox', path
  end

  def activate(y)
    tk_send 'activate', y
  end
  def curselection
    list(tk_send('curselection'))
  end
  def nearest(y)
    tk_send('nearest', y).to_i
  end
  def size(y)
    tk_send('size').to_i
  end
  def selection_anchor(index)
    tk_send 'selection', 'anchor', index
  end
  def selection_clear(first, last=None)
    tk_send 'selection', 'clear', first, last
  end
  def selection_includes
    bool(tk_send('selection', 'includes'))
  end
  def selection_set(first, last=None)
    tk_send 'selection', 'set', first, last
  end
  def xview(cmd, index, *more)
    v = tk_send('xview', cmd, index, *more)
    v.to_i if more.size == 0
  end
  def yview(cmd, index, *more)
    v = tk_send('yview', cmd, index, *more)
    v.to_i if more.size == 0
  end
end

module TkTreatMenuEntryFont
  def tagfont_configinfo(index)
    pathname = self.path + ';' + index
    ret = TkFont.used_on(pathname)
    if ret == nil
      ret = TkFont.init_widget_font(pathname, 
				    self.path, 'entryconfigure', index)
    end
    ret
  end
  alias tagfontobj tagfont_configinfo

  def tagfont_configure(index, slot)
    pathname = self.path + ';' + index
    if (fnt = slot['font'])
      slot['font'] = nil
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(pathname, 
				       self.path,'entryconfigure',index,slot)
      else
	latintagfont_configure(index, fnt) if fnt
      end
    end
    if (ltn = slot['latinfont'])
      slot['latinfont'] = nil
      latintagfont_configure(index, ltn) if ltn
    end
    if (ltn = slot['asciifont'])
      slot['asciifont'] = nil
      latintagfont_configure(index, ltn) if ltn
    end
    if (knj = slot['kanjifont'])
      slot['kanjifont'] = nil
      kanjitagfont_configure(index, knj) if knj
    end

    tk_call(self.path, 'entryconfigure', index, *hash_kv(slot)) if slot != {}
    self
  end

  def latintagfont_configure(index, ltn, keys=nil)
    fobj = tagfontobj(index)
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.latin_replace(ltn)
	fobj.latin_configure(keys) if keys
      elsif keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciitagfont_configure latintagfont_configure

  def kanjitagfont_configure(index, knj, keys=nil)
    fobj = tagfontobj(index)
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.kanji_replace(knj)
	fobj.kanji_configure(keys) if keys
      elsif keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(conf)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def tagfont_copy(index, window, wintag=nil)
    if wintag
      window.tagfontobj(wintag).configinfo.each{|key,value|
	tagfontobj(index).configure(key,value)
      }
      tagfontobj(index).replace(window.tagfontobj(wintag).latin_font, 
			      window.tagfontobj(wintag).kanji_font)
    else
      window.tagfont(wintag).configinfo.each{|key,value|
	tagfontobj(index).configure(key,value)
      }
      tagfontobj(index).replace(window.fontobj.latin_font, 
			      window.fontobj.kanji_font)
    end
  end

  def latintagfont_copy(index, window, wintag=nil)
    if wintag
      tagfontobj(index).latin_replace(window.tagfontobj(wintag).latin_font)
    else
      tagfontobj(index).latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciitagfont_copy latintagfont_copy

  def kanjitagfont_copy(index, window, wintag=nil)
    if wintag
      tagfontobj(index).kanji_replace(window.tagfontobj(wintag).kanji_font)
    else
      tagfontobj(index).kanji_replace(window.fontobj.kanji_font)
    end
  end
end

class TkMenu<TkWindow
  include TkTreatMenuEntryFont

  WidgetClassName = 'Menu'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end
  def create_self
    tk_call 'menu', path
  end
  def activate(index)
    tk_send 'activate', index
  end
  def add(type, keys=nil)
    tk_send 'add', type, *hash_kv(keys)
  end
  def index(index)
    tk_send 'index', index
  end
  def invoke(index)
    tk_send 'invoke', index
  end
  def insert(index, type, keys=nil)
    tk_send 'add', index, type, *hash_kv(keys)
  end
  def delete(index, last=None)
    tk_send 'delete', index, last
  end
  def post(x, y)
    tk_send 'post', x, y
  end
  def postcascade(index)
    tk_send 'postcascade', index
  end
  def postcommand(cmd=Proc.new)
    configure_cmd 'postcommand', cmd
  end
  def menutype(index)
    tk_send 'type', index
  end
  def unpost
    tk_send 'unpost'
  end
  def yposition(index)
    number(tk_send('yposition', index))
  end
  def entryconfigure(index, keys=nil)
    tk_send 'entryconfigure', index, *hash_kv(keys)
  end
#  def entryconfigure(index, keys=nil)
#    tk_send 'entryconfigure', index, *hash_kv(keys)
#  end
  def entrycget(index, key)
    tk_tcl2ruby tk_send 'entrycget', index, "-#{key}"
  end
  def entryconfigure(index, key, val=None)
    if key.kind_of? Hash
      if ( key['font'] || key['kanjifont'] \
	  || key['latinfont'] || key['asciifont'] )
	tagfont_configure(index, key.dup)
      else
	tk_send 'entryconfigure', index, *hash_kv(key)
      end

    else
      if ( key == 'font' || key == 'kanjifont' \
	  || key == 'latinfont' || key == 'asciifont' )
	tagfont_configure({key=>val})
      else
	tk_call 'entryconfigure', index, "-#{key}", val
      end
    end
  end

  def entryconfiginfo(index, key=nil)
    if key
      conf = tk_split_list(tk_send('entryconfigure',index,"-#{key}"))
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_send('entryconfigure', index)).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end
end

class TkMenubutton<TkLabel
  TkClassBind::WidgetClassNameTBL['Menubutton'] = self
  def TkMenubutton.to_eval
    'Menubutton'
  end
  def create_self
    tk_call 'menubutton', path
  end
end

module TkComposite
  def initialize(parent=nil, *args)
    @@frame = TkFrame.new(parent)
    @@path = @@epath = @@frame.path
    initialize_composite(*args)
  end

  def epath
    @@epath
  end

  def initialize_composite(*args) end
  private :initialize_composite

  def delegate(option, *wins)
    unless @@delegates
      @@delegates = {} 
      @@delegates['DEFAULT'] = @@frame
    end
    if @@delegates[option].kind_of?(Array)
      for i in wins
	@@delegates[option].push(i)
      end
    else
      @@delegates[option] = wins
    end
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      slot.each{|slot,value| configure slot, value}
    else
      if @@delegates and @@delegates[slot]
	for i in @@delegates[slot]
	  if not i
	    i = @@delegates['DEFALUT']
	    redo
	  else
	    last = i.configure(slot, value)
	  end
	end
	last
      else
	super
      end
    end
  end
end

module TkClipboard
  include Tk
  extend Tk

  def clear
    tk_call 'clipboard', 'clear'
  end
  def get
    begin
      tk_call 'selection', 'get', '-selection', 'CLIPBOARD'
    rescue
      ''
    end
  end
  def set(data)
    clear
    append(data)
  end
  def append(data)
    tk_call 'clipboard', 'append', data
  end

  module_function :clear, :set, :get, :append
end

autoload :TkCanvas, 'tkcanvas'
autoload :TkImage, 'tkcanvas'
autoload :TkBitmapImage, 'tkcanvas'
autoload :TkPhotoImage, 'tkcanvas'
autoload :TkEntry, 'tkentry'
autoload :TkText, 'tktext'
autoload :TkDialog, 'tkdialog'
autoload :TkMenubar, 'tkmenubar'
autoload :TkAfter, 'tkafter'
autoload :TkPalette, 'tkpalette'
autoload :TkFont, 'tkfont'
autoload :TkVirtualEvent, 'tkvirtevent'
@


1.1.1.1.2.1
log
@990126
@
text
@d3 1
a3 1
#			$Date: 1999/01/20 04:59:34 $
a2414 3
  include Tk
  extend Tk

@


1.1.1.1.2.2
log
@990224
@
text
@d3 1
a3 1
#			$Date: 1999/01/26 10:08:17 $
a581 1
    include TkComm
@


1.1.1.1.2.3
log
@990324
@
text
@d3 1
a3 1
#			$Date: 1999/02/24 04:31:28 $
d231 1
a231 1
    @@cmdtbl = [] unless @@cmdtbl
d714 1
a714 1
      s = '"' + a.join(" ").gsub(/[][$"]/, '\\\\\&') + '"'
d718 1
a718 1
                   .gsub(/[][$"]/, '\\\\\&') + '"'
d721 1
a721 1
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"'
d741 3
a743 2
	Hash[*tk_split_simplelist(INTERP._eval(format('global %s; array get %s', 
						      @@id, @@id)))]
d750 1
a750 1
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"'
d763 1
a763 1
	  s = '"' + a.join(" ").gsub(/[][$"]/, '\\\\\&') + '"'
d768 1
a768 1
	                        .gsub(/[][$"]/, '\\\\\&') + '"'
d975 1
a975 1
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"'
d1603 2
a1604 2
      if (slot['font'] || slot['kanjifont'] ||
	  slot['latinfont'] || slot['asciifont'] )
d1611 3
a1613 7
      if (slot == 'font' || slot == 'kanjifont' ||
	  slot == 'latinfont' || slot == 'asciifont')
	if value == None
	  fontobj
	else
	  font_configure({slot=>value})
	end
d1627 1
d1633 1
d2363 6
d2374 2
a2375 2
      if (key['font'] || key['kanjifont'] ||
	  key['latinfont'] || key['asciifont'])
d2382 2
a2383 2
      if (key == 'font' || key == 'kanjifont' ||
	  key == 'latinfont' || key == 'asciifont' )
@


1.1.1.1.2.4
log
@990531
@
text
@d3 1
a3 1
#			$Date: 1999/03/24 08:52:34 $
a235 1
    id = $1 if /rb_out (c\d+)/
d2119 1
a2119 1
    ary1 = tk_send('get').split
@


1.1.1.1.2.5
log
@990624
@
text
@d3 1
a3 1
#			$Date: 1999/05/31 09:13:32 $
d2008 5
a2012 3
  TkClassBind::WidgetClassNameTBL['Button'] = self
  def TkButton.to_eval
    'Button'
d2026 2
a2027 1
  TkClassBind::WidgetClassNameTBL['Radiobutton'] = self
d2029 1
a2029 1
    'Radiobutton'
@


1.1.1.1.2.6
log
@990715
@
text
@d3 1
a3 1
#			$Date: 1999/06/24 04:24:07 $
d756 1
d758 2
a759 2
	  INTERP._eval(format('global %s; unset %s; set %s(0) 0; unset %s(0)', 
			      @@id, @@id, @@id, @@id))
d860 1
a860 1
      opts.each_byte{|c| newopts += c.chr unless newopts.index(c)}
d880 1
a880 1
      opts.each_byte{|c| newopts += c.chr unless newopts.index(c)}
d2194 2
a2195 2
  def xview(cmd, *more)
    v = tk_send('xview', cmd, *more)
d2198 2
a2199 2
  def yview(cmd, *more)
    v = tk_send('yview', cmd, *more)
@


1.1.2.1
log
@1.1c8
@
text
@a0 2499
#
#		tk.rb - Tk interface modue using tcltklib
#			$Date: 1998/10/06 02:45:14 $
#			by Yukihiro Matsumoto <matz@@netlab.co.jp>

# use Shigehiro's tcltklib
require "tcltklib"
require "tkutil"

module TkComm
  None = Object.new
  def None.to_s
    'None'
  end

  Tk_CMDTBL = {}
  Tk_WINDOWS = {}

  def error_at
    frames = caller()
    frames.delete_if do |c|
      c =~ %r!/tk(|core|thcore|canvas|text|entry|scrollbox)\.rb:\d+!
    end
    frames
  end
  private :error_at

  def _genobj_for_tkwidget(path)
    return TkRoot.new if path == '.'

    begin
      tk_class = TkCore::INTERP._invoke('winfo', 'class', path)
    rescue
      return path
    end

    ruby_class = TkClassBind::WidgetClassNameTBL[tk_class]
    gen_class_name = ruby_class.name + 'GeneratedOnTk'
    unless Object.const_defined? gen_class_name
      eval "class #{gen_class_name}<#{ruby_class.name}
              def initialize(path)
                @@path=path
                Tk_WINDOWS[@@path] = self
              end
            end"
    end
    eval "#{gen_class_name}.new('#{path}')"
  end

  def tk_tcl2ruby(val)
    if val =~ /^rb_out (c\d+)/
      return Tk_CMDTBL[$1]
    end
    if val.include? ?\s
      return val.split.collect{|v| tk_tcl2ruby(v)}
    end
    case val
    when /^@@font/
      TkFont.get_obj(val)
    when /^-?\d+$/
      val.to_i
    when /^\./
      Tk_WINDOWS[val] ? Tk_WINDOWS[val] : _genobj_for_tkwidget(val)
    when / /
      val.split.collect{|elt|
	tk_tcl2ruby(elt)
      }
    when /^-?\d+\.\d*$/
      val.to_f
    else
      val
    end
  end

  def tk_split_list(str)
    return [] if str == ""
    idx = str.index('{')
    return tk_tcl2ruby(str) unless idx

    list = tk_tcl2ruby(str[0,idx])
    list = [] if list == ""
    str = str[idx+1..-1]
    i = -1
    brace = 1
    str.each_byte {|c|
      i += 1
      brace += 1 if c == ?{
      brace -= 1 if c == ?}
      break if brace == 0
    }
    if str[0, i] == ' '
      list.push ' '
    else
      list.push tk_split_list(str[0, i])
    end
    list += tk_split_list(str[i+1..-1])
    list
  end

  def tk_split_simplelist(str)
    return [] if str == ""
    idx = str.index('{')
    return str.split unless idx

    list = str[0,idx].split
    str = str[idx+1..-1]
    i = -1
    brace = 1
    str.each_byte {|c|
      i += 1
      brace += 1 if c == ?{
      brace -= 1 if c == ?}
      break if brace == 0
    }
    if i == 0
      list.push ''
    elsif str[0, i] == ' '
      list.push ' '
    else
      list.push str[0..i-1]
    end
    list += tk_split_simplelist(str[i+1..-1])
    list
  end
  private :tk_tcl2ruby, :tk_split_list, :tk_split_simplelist

  def hash_kv(keys)
    conf = []
    if keys and keys != None
      for k, v in keys
	 conf.push("-#{k}")
	 conf.push(v)
      end
    end
    conf
  end
  private :hash_kv

  def array2tk_list(ary)
    ary.collect{|e|
      if e.kind_of? Array
	"{#{array2tk_list(e)}}"
      elsif e.kind_of? Hash
	"{#{e.to_a.collect{|ee| array2tk_list(ee)}.join(' ')}}"
      else
	s = _get_eval_string(e)
	(s.index(/\s/))? "{#{s}}": s
      end
    }.join(" ")
  end
  private :array2tk_list

  def bool(val)
    case val
    when "1", 1, 'yes', 'true'
      TRUE
    else
      FALSE
    end
  end
  def number(val)
    case val
    when /^-?\d+$/
      val.to_i
    when /^-?\d+\.\d*$/
      val.to_f
    else
      val
    end
  end
  def string(val)
    if val == "{}"
      ''
    elsif val[0] == ?{
      val[1..-2]
    else
      val
    end
  end
  def list(val)
    tk_split_list(val).to_a
  end
  def window(val)
    Tk_WINDOWS[val]
  end
  def procedure(val)
    if val =~ /^rb_out (c\d+)/
      Tk_CMDTBL[$1]
    else
      nil
    end
  end
  private :bool, :number, :string, :list, :window, :procedure

  def _get_eval_string(str)
    return nil if str == None
    if str.kind_of?(Hash)
      str = hash_kv(str).join(" ")
    elsif str.kind_of?(Array)
      str = array2tk_list(str)
    elsif str.kind_of?(Proc)
      str = install_cmd(str)
    elsif str == nil
      str = ""
    elsif str == false
      str = "0"
    elsif str == true
      str = "1"
    elsif (str.respond_to?(:to_eval))
      str = str.to_eval()
    else
      str = str.to_s()
    end
    return str
  end
  private :_get_eval_string

  Tk_IDs = [0, 0]		# [0]-cmdid, [1]-winid
  def _curr_cmd_id
    id = format("c%.4d", Tk_IDs[0])
  end
  def _next_cmd_id
    id = _curr_cmd_id
    Tk_IDs[0] += 1
    id
  end
  def install_cmd(cmd)
    return '' if cmd == ''
    id = _next_cmd_id
    Tk_CMDTBL[id] = cmd
    @@cmdtbl = [] if not @@cmdtbl
    @@cmdtbl.push id
    return format("rb_out %s", id);
  end
  def uninstall_cmd(id)
    Tk_CMDTBL[id] = nil
  end
  private :install_cmd, :uninstall_cmd

  def install_win(ppath)
    id = format("w%.4d", Tk_IDs[1])
    Tk_IDs[1] += 1
    if !ppath or ppath == "."
      @@path = format(".%s", id);
    else
      @@path = format("%s.%s", ppath, id)
    end
    Tk_WINDOWS[@@path] = self
  end

  def uninstall_win()
    Tk_WINDOWS[@@path] = nil
  end

  class Event
    def initialize(seq,b,f,h,k,s,t,w,x,y,aa,ee,kk,nn,ww,tt,xx,yy)
      @@serial = seq
      @@num = b
      @@focus = (f == 1)
      @@height = h
      @@keycode = k
      @@state = s
      @@time = t
      @@width = w
      @@x = x
      @@y = y
      @@char = aa
      @@send_event = (ee == 1)
      @@keysym = kk
      @@keysym_num = nn
      @@type = tt
      @@widget = ww
      @@x_root = xx
      @@y_root = yy
    end
    attr :serial
    attr :num
    attr :focus
    attr :height
    attr :keycode
    attr :state
    attr :time
    attr :width
    attr :x
    attr :y
    attr :char
    attr :send_event
    attr :keysym
    attr :keysym_num
    attr :type
    attr :widget
    attr :x_root
    attr :y_root
  end

  def install_bind(cmd, args=nil)
    if args
      id = install_cmd(proc{|arg|
	TkUtil.eval_cmd cmd, *arg
      })
      id + " " + args
    else
      id = install_cmd(proc{|arg|
	TkUtil.eval_cmd cmd, Event.new(*arg)
      })
      id + ' %# %b %f %h %k %s %t %w %x %y %A %E %K %N %W %T %X %Y'
    end
  end

  def tk_event_sequence(context)
    if context.kind_of? TkVirtualEvent
      context = context.path
    end
    if context.kind_of? Array
      context = context.collect{|ev|
	if context.kind_of? TkVirtualEvent
	  ev.path
	else
	  ev
	end
      }.join("><")
    end
    if /,/ =~ context
      context = context.split(/\s*,\s*/).join("><")
    else
      context
    end
  end

  def _bind_core(mode, path, context, cmd, args=nil)
    id = install_bind(cmd, args)
    begin
      tk_call 'bind', path, "<#{tk_event_sequence(context)}>", mode + id
    rescue
      uninstall_cmd(id)
      fail
    end
  end

  def _bind(path, context, cmd, args=nil)
    _bind_core('', path, context, cmd, args)
  end

  def _bind_append(path, context, cmd, args=nil)
    _bind_core('+', path, context, cmd, args)
  end
  private :install_bind, :tk_event_sequence, :_bind_core, :_bind, :_bind_append

  def bind_all(context, cmd=Proc.new, args=nil)
    _bind 'all', context, cmd, args
  end

  def bind_append_all(context, cmd=Proc.new, args=nil)
    _bind_append 'all', context, cmd, args
  end

  def bind(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind tagOrClass, context, cmd, args
  end

  def bind_append(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind_append tagOrClass, context, cmd, args
  end

  def _bindinfo(tagOrClass, context=nil)
    if context
      (tk_call('bind', tagOrClass, 
	       "<#{tk_event_sequence(context)}>")).collect{|cmdline|
	if cmdline =~ /^rb_out (c\d+)\s+(.*)$/
	  [Tk_CMDTBL[$1], $2]
	else
	  cmdline
	end
      }
    else
      tk_split_list(tk_call 'bind', tagOrClass).collect{|seq|
	seq[1..-2].gsub(/></,',')
      }
    end
  end

  def bindinfo(tagOrClass, context=nil)
    _bindinfo tagOrClass, context
  end

  def pack(*args)
    TkPack.configure *args
  end

  def grid(*args)
    TkGrid.configure *args
  end

  def update(idle=nil)
    if idle
      tk_call 'update', 'idletasks'
    else
      tk_call 'update'
    end
  end

end

module TkCore
  include TkComm
  extend TkComm

  INTERP = TclTkIp.new

  INTERP._invoke("proc", "rb_out", "args", "if {[set st [catch {ruby [format \"TkCore.callback %%Q!%s!\" $args]} ret]] != 0} {return -code $st $ret} {return $ret}")

  def callback_break
    raise TkCallbackBreak, "Tk callback returns 'break' status"
  end

  def callback_continue
    raise TkCallbackContinue, "Tk callback returns 'continue' status"
  end

  def after(ms, cmd=Proc.new)
    myid = _curr_cmd_id
    cmdid = install_cmd(cmd)
    tk_call("after",ms,cmdid)
    return
    if false #defined? Thread
      Thread.start do
	ms = Float(ms)/1000
	ms = 10 if ms == 0
	sleep ms/1000
	cmd.call
      end
    else
      cmdid = install_cmd(cmd)
      tk_call("after",ms,cmdid)
    end
  end

  def TkCore.callback(arg)
    arg = Array(tk_split_list(arg))
    _get_eval_string(TkUtil.eval_cmd(Tk_CMDTBL[arg.shift], *arg))
  end

  def appname(name=None)
    tk_call('tk', 'appname', name)
  end

  def appsend(interp, async, *args)
    if async
      tk_call('send', '-async', '--', interp, *args)
    else
      tk_call('send', '--', interp, *args)
    end
  end

  def rb_appsend(interp, async, *args)
    args = args.filter{|c| _get_eval_string(c).gsub(/[][$"]/, '\\\\\&')}
    args.push(').to_s"')
    appsend(interp, async, 'ruby "(', *args)
  end

  def appsend_displayof(interp, win, async, *args)
    win = '.' if win == nil
    if async
      tk_call('send', '-async', '-displayof', win, '--', interp, *args)
    else
      tk_call('send', '-displayor', win, '--', interp, *args)
    end
  end

  def rb_appsend_displayof(interp, win, async, *args)
    args = args.filter{|c| _get_eval_string(c).gsub(/[][$"]/, '\\\\\&')}
    args.push(').to_s"')
    appsend_displayof(interp, win, async, 'ruby "(', *args)
  end

  def info(*args)
    tk_call('info', *args)
  end

  def mainloop
    TclTkLib.mainloop
  end

  def event_generate(window, context, keys=nil)
    window = window.path if window.kind_of? TkObject
    if keys
      tk_call('event', 'generate', window, 
	      "<#{tk_event_sequence(context)}>", *hash_kv(keys))
    else
      tk_call('event', 'generate', window, "<#{tk_event_sequence(context)}>")
    end
  end

  def messageBox(keys)
    tk_call 'tk_messageBox', *hash_kv(keys)
  end

  def getOpenFile(keys)
    tk_call 'tk_getOpenFile', *hash_kv(keys)
  end

  def getSaveFile(keys)
    tk_call 'tk_getSaveFile', *hash_kv(keys)
  end

  def chooseColor(keys)
    tk_call 'tk_chooseColor', *hash_kv(keys)
  end

  def tk_call(*args)
    print args.join(" "), "\n" if $DEBUG
    args.filter {|x|_get_eval_string(x)}
    args.compact!
    args.flatten!
    begin
      res = INTERP._invoke(*args)
    rescue NameError
      err = $!
      begin
        args.unshift "unknown"
        res = INTERP._invoke(*args)
      rescue
	raise unless /^invalid command/ =~ $!
	raise err
      end
    end
    if  INTERP._return_value() != 0
      fail RuntimeError, res, error_at
    end
    print "==> ", res, "\n" if $DEBUG
    return res
  end
end

module Tk
  include TkCore
  extend Tk

  TCL_VERSION = INTERP._invoke("info", "tclversion")
  TK_VERSION  = INTERP._invoke("set", "tk_version")
  JAPANIZED_TK = (INTERP._invoke("info", "commands", "kanji") != "")

  def root
    TkRoot.new
  end

  def bell
    tk_call 'bell'
  end

  def Tk.focus(display=nil)
    if display == nil
      r = tk_call('focus')
    else
      r = tk_call('focus', '-displayof', display)
    end
    tk_tcl2ruby(r)
  end

  def Tk.focus_lastfor(win)
    tk_tcl2ruby(tk_call('focus', '-lastfor', win))
  end

  def toUTF8(str,encoding)
    INTERP._toUTF8(str,encoding)
  end
  
  def fromUTF8(str,encoding)
    INTERP._fromUTF8(str,encoding)
  end

  module Scrollable
    def xscrollcommand(cmd=Proc.new)
      configure_cmd 'xscrollcommand', cmd
    end
    def yscrollcommand(cmd=Proc.new)
      configure_cmd 'yscrollcommand', cmd
    end
  end

  module Wm
    def aspect(*args)
      w = window(tk_call('wm', 'grid', path, *args))
      w.split.collect{|s|s.to_i} if args.length == 0
    end
    def client(name=None)
      tk_call 'wm', 'client', path, name
    end
    def colormapwindows(*args)
      list(tk_call('wm', 'colormapwindows', path, *args))
    end
    def wm_command(value=None)
      string(tk_call('wm', 'command', path, value))
    end
    def deiconify
      tk_call 'wm', 'deiconify', path
    end
    def focusmodel(*args)
      tk_call 'wm', 'focusmodel', path, *args
    end
    def frame
      tk_call 'wm', 'frame', path
    end
    def geometry(*args)
      list(tk_call('wm', 'geometry', path, *args))
    end
    def grid(*args)
      w = tk_call('wm', 'grid', path, *args)
      list(w) if args.size == 0
    end
    def group(*args)
      tk_call 'wm', 'group', path, *args
    end
    def iconbitmap(*args)
      tk_call 'wm', 'iconbitmap', path, *args
    end
    def iconify
      tk_call 'wm', 'iconify', path
    end
    def iconmask(*args)
      tk_call 'wm', 'iconmask', path, *args
    end
    def iconname(*args)
      tk_call 'wm', 'iconname', path, *args
    end
    def iconposition(*args)
      w = tk_call('wm', 'iconposition', path, *args)
      list(w) if args.size == 0
    end
    def iconwindow(*args)
      w = tk_call('wm', 'iconwindow', path, *args)
      window(w) if args.size == 0
    end
    def maxsize(*args)
      w = tk_call('wm', 'maxsize', path, *args)
      list(w) if not args.size == 0
    end
    def minsize(*args)
      w = tk_call('wm', 'minsize', path, *args)
      list(w) if args.size == 0
    end
    def overrideredirect(bool=None)
      if bool == None
	bool(tk_call('wm', 'overrideredirect', path))
      else
	tk_call 'wm', 'overrideredirect', path, bool
      end
    end
    def positionfrom(*args)
      tk_call 'wm', 'positionfrom', path, *args
    end
    def protocol(name=nil, cmd=nil)
      if cmd
	tk_call('wm', 'protocol', path, name, cmd)
      elsif name
	result = tk_call('wm', 'protocol', path, name)
	(result == "")? nil : tk_tcl2ruby(result)
      else
	tk_split_simplelist(tk_call('wm', 'protocol', path))
      end
    end
    def resizable(*args)
      w = tk_call('wm', 'resizable', path, *args)
      if args.length == 0
	list(w).collect{|e| bool(e)}
      end
    end
    def sizefrom(*args)
      list(tk_call('wm', 'sizefrom', path, *args))
    end
    def state
      tk_call 'wm', 'state', path
    end
    def title(*args)
      tk_call 'wm', 'title', path, *args
    end
    def transient(*args)
      tk_call 'wm', 'transient', path, *args
    end
    def withdraw
      tk_call 'wm', 'withdraw', path
    end
  end
end

class TkVariable
  include Tk
  extend TkCore

  TkVar_CB_TBL = {}
  Tk_VARIABLE_ID = ["v00000"]

  INTERP._invoke("proc", "rb_var", "args", "ruby [format \"TkVariable.callback %%Q!%s!\" $args]")

  def TkVariable.callback(args)
    name1,name2,op = tk_split_list(args)
    if TkVar_CB_TBL[name1]
      _get_eval_string(TkVar_CB_TBL[name1].trace_callback(name2,op))
    else
      ''
    end
  end

  def initialize(val="")
    @@id = Tk_VARIABLE_ID[0]
    Tk_VARIABLE_ID[0] = Tk_VARIABLE_ID[0].succ
    if val == []
      INTERP._eval(format('global %s; set %s(0) 0; unset %s(0)', 
			  @@id, @@id, @@id))
    elsif val.kind_of?(Array)
      a = []
      val.each_with_index{|e,i| a.push(i); a.push(array2tk_list(e))}
      s = '"' + a.join(" ").gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; array set %s %s', @@id, @@id, s))
    elsif  val.kind_of?(Hash)
      s = '"' + val.to_a.collect{|e| array2tk_list(e)}.join(" ")\
                   .gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; array set %s %s', @@id, @@id, s))
    else
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
    end
  end

  def wait
    INTERP._eval("tkwait variable #{@@id}")
  end

  def id
    @@id
  end

  def value
    begin
      INTERP._eval(format('global %s; set %s', @@id, @@id))
    rescue
      if INTERP._eval(format('global %s; array exists %s', @@id, @@id)) != "1"
	raise
      else
	Hash[*tk_split_simplelist(INTERP\
				  ._eval(format('global %s; array get %s', 
						@@id, @@id)))]
      end
    end
  end

  def value=(val)
    begin
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
    rescue
      if INTERP._eval(format('global %s; array exists %s', @@id, @@id)) != "1"
	raise
      else
	INTERP._eval(format('global %s; unset %s'), @@id, @@id)
	if val == []
	  INTERP._eval(format('global %s; set %s(0) 0; unset %s(0)', 
			      @@id, @@id, @@id))
	elsif val.kind_of?(Array)
	  a = []
	  val.each_with_index{|e,i| a.push(i); a.push(array2tk_list(e))}
	  s = '"' + a.join(" ").gsub(/[][$"]/, '\\\\\&') + '"' #'
	  INTERP._eval(format('global %s; unset %s; array set %s %s', 
			      @@id, @@id, @@id, s))
	elsif  val.kind_of?(Hash)
	  s = '"' + val.to_a.collect{|e| array2tk_list(e)}.join(" ")\
	                        .gsub(/[][$"]/, '\\\\\&') + '"' #'
	  INTERP._eval(format('global %s; unset %s; array set %s %s', 
			      @@id, @@id, @@id, s))
	else
	  raise
	end
      end
    end
  end

  def [](index)
    INTERP._eval(format('global %s; set %s(%s)', 
			@@id, @@id, _get_eval_string(index)))
  end

  def []=(index,val)
    INTERP._eval(format('global %s; set %s(%s) %s', @@id, @@id, 
			_get_eval_string(index), _get_eval_string(val)))
  end

  def to_i
    Integer(number(value))
  end

  def to_f
    Float(number(value))
  end

  def to_s
    String(string(value))
  end

  def inspect
    format "<TkVariable: %s>", @@id
  end

  def ==(other)
    case other
    when TkVariable
      self.equal(self)
    when String
      self.to_s == other
    when Integer
      self.to_i == other
    when Float
      self.to_f == other
    when Array
      self.to_a == other
    else
      false
    end
  end

  def to_a
    list(value)
  end

  def to_eval
    @@id
  end

  def unset(elem=nil)
    if elem
      INTERP._eval(format('global %s; unset %s(%s)', 
			  @@id, @@id, tk_tcl2ruby(elem)))
    else
      INTERP._eval(format('global %s; unset %s', @@id, @@id))
    end
  end
  alias remove unset

  def trace_callback(elem, op)
    if @@trace_var.kind_of? Array
      @@trace_var.each{|m,e| e.call(self,elem,op) if m.index(op)}
    end
    if elem.kind_of? String
      if @@trace_elem[elem].kind_of? Array
	@@trace_elem[elem].each{|m,e| e.call(self,elem,op) if m.index(op)}
      end
    end
  end

  def trace(opts, cmd)
    @@trace_var = [] if @@trace_var == nil
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    @@trace_var.unshift([opts,cmd])
    if @@trace_opts == nil
      TkVar_CB_TBL[@@id] = self
      @@trace_opts = opts
      Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
    else
      newopts = @@trace_opts.dup
      opts.each_byte{|c| newopts += c.chr unless @@newopts.index(c)}
      if newopts != @@trace_opts
	Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
	@@trace_opts.replace(newopts)
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_element(elem, opts, cmd)
    @@trace_elem = {} if @@trace_elem == nil
    @@trace_elem[elem] = [] if @@trace_elem[elem] == nil
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    @@trace_elem[elem].unshift([opts,cmd])
    if @@trace_opts == nil
      TkVar_CB_TBL[@@id] = self
      @@trace_opts = opts
      Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
    else
      newopts = @@trace_opts.dup
      opts.each_byte{|c| newopts += c.chr unless @@newopts.index(c)}
      if newopts != @@trace_opts
	Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
	@@trace_opts.replace(newopts)
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_vinfo
    return [] unless @@trace_var
    @@trace_var.dup
  end
  def trace_vinfo_for_element(elem)
    return [] unless @@trace_elem
    return [] unless @@trace_elem[elem]
    @@trace_elem[elem].dup
  end

  def trace_vdelete(opts,cmd)
    return unless @@trace_var.kind_of? Array
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    idx = -1
    newopts = ''
    @@trace_var.each_with_index{|i,e| 
      if idx < 0 && e[0] == opts && e[1] == cmd
	idx = i
	next
      end
      e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
    }
    if idx >= 0
      @@trace_var.delete_at(idx) 
    else
      return
    end

    @@trace_elem.each{|elem|
      @@trace_elem[elem].each{|e|
	e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
      }
    }

    newopts = ['r','w','u'].find_all{|c| newopts.index(c)}.join('')
    if newopts != @@trace_opts
      Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
      @@trace_opts.replace(newopts)
      if @@trace_opts != ''
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_vdelete_for_element(elem,opts,cmd)
    return unless @@trace_elem.kind_of? Hash
    return unless @@trace_elem[elem].kind_of? Array
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    idx = -1
    @@trace_elem[elem].each_with_index{|i,e| 
      if idx < 0 && e[0] == opts && e[1] == cmd
	idx = i
	next
      end
    }
    if idx >= 0
      @@trace_elem[elem].delete_at(idx)
    else
      return
    end

    newopts = ''
    @@trace_var.each{|e| 
      e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
    }
    @@trace_elem.each{|elem|
      @@trace_elem[elem].each{|e|
	e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
      }
    }

    newopts = ['r','w','u'].find_all{|c| newopts.index(c)}.join('')
    if newopts != @@trace_opts
      Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
      @@trace_opts.replace(newopts)
      if @@trace_opts != ''
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end
end

class TkVarAccess<TkVariable
  def initialize(varname, val=nil)
    @@id = varname
    if val
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
    end
  end
end

module TkSelection
  include Tk
  extend Tk
  def clear(win=Tk.root)
    tk_call 'selection', 'clear', win.path
  end
  def get(type=None)
    tk_call 'selection', 'get', type
  end
  def TkSelection.handle(win, func, type=None, format=None)
    id = install_cmd(func)
    tk_call 'selection', 'handle', win.path, id, type, format
  end
  def handle(func, type=None, format=None)
    TkSelection.handle self, func, type, format
  end
  def TkSelection.own(win, func=None)
    id = install_cmd(func)
    tk_call 'selection', 'own', win.path, id
  end
  def own(func=None)
    TkSelection.own self, func
  end

  module_function :clear, :get
end

module TkKinput
  include Tk
  extend Tk

  def TkKinput.start(window, style=None)
    tk_call 'kinput_start', window.path, style
  end
  def kinput_start(style=None)
    TkKinput.start(self, style)
  end

  def TkKinput.send_spot(window)
    tk_call 'kinput_send_spot', window.path
  end
  def kinput_send_spot
    TkKinput.send_spot(self)
  end

  def TkKinput.input_start(window, keys=nil)
    tk_call 'kanjiInput', 'start', window.path, *hash_kv(keys)
  end
  def kanji_input_start(keys=nil)
    TkKinput.input_start(self, keys)
  end

  def TkKinput.attribute_config(window, slot, value=None)
    if slot.kind_of? Hash
      tk_call 'kanjiInput', 'attribute', window.path, *hash_kv(slot)
    else
      tk_call 'kanjiInput', 'attribute', window.path, "-#{slot}", value
    end
  end
  def kinput_attribute_config(slot, value=None)
    TkKinput.attribute_config(self, slot, value)
  end

  def TkKinput.attribute_info(window, slot=nil)
    if slot
      conf = tk_split_list(tk_call('kanjiInput', 'attribute', 
				   window.path, "-#{slot}"))
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_call('kanjiInput', 'attribute', 
			    window.path)).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end
  def kinput_attribute_info(slot=nil)
    TkKinput.attribute_info(self, slot)
  end

  def TkKinput.input_end(window)
    tk_call 'kanjiInput', 'end', window.path
  end
  def kanji_input_end
    TkKinput.input_end(self)
  end
end

module TkWinfo
  include Tk
  extend Tk
  def TkWinfo.atom(name)
    tk_call 'winfo', name
  end
  def winfo_atom(name)
    TkWinfo.atom name
  end
  def TkWinfo.atomname(id)
    tk_call 'winfo', id
  end
  def winfo_atomname(id)
    TkWinfo.atomname id
  end
  def TkWinfo.cells(window)
    number(tk_call('winfo', window.path))
  end
  def winfo_cells
    TkWinfo.cells self
  end
  def TkWinfo.children(window)
    c = tk_call('winfo', 'children', window.path)
    list(c)
  end
  def winfo_children
    TkWinfo.children self
  end
  def TkWinfo.classname(window)
    tk_call 'winfo', 'class', window.path
  end
  def winfo_classname
    TkWinfo.classname self
  end
  def TkWinfo.containing(rootX, rootY)
    path = tk_call('winfo', 'containing', rootX, rootY)
    window(path)
  end
  def winfo_containing(x, y)
    TkWinfo.containing x, y
  end
  def TkWinfo.depth(window)
    number(tk_call('winfo', 'depth', window.path))
  end
  def winfo_depth
    TkWinfo.depth self
  end
  def TkWinfo.exist?(window)
    bool(tk_call('winfo', 'exists', window.path))
  end
  def winfo_exist?
    TkWinfo.exist? self
  end
  def TkWinfo.fpixels(window, number)
    number(tk_call('winfo', 'fpixels', window.path, number))
  end
  def winfo_fpixels(number)
    TkWinfo.fpixels self, number
  end
  def TkWinfo.geometry(window)
    list(tk_call('winfo', 'geometry', window.path))
  end
  def winfo_geometry
    TkWinfo.geometry self
  end
  def TkWinfo.height(window)
    number(tk_call('winfo', 'height', window.path))
  end
  def winfo_height
    TkWinfo.height self
  end
  def TkWinfo.id(window)
    number(tk_call('winfo', 'id', window.path))
  end
  def winfo_id
    TkWinfo.id self
  end
  def TkWinfo.interps(window=nil)
    if window
      tk_split_simplelist(tk_call('winfo', '-displayof', window.path, 
				  'interps'))
    else
      tk_split_simplelist(tk_call('winfo', 'interps'))
    end
  end
  def winfo_interps
    TkWinfo.interps self
  end
  def TkWinfo.mapped?(window)
    bool(tk_call('winfo', 'ismapped', window.path))
  end
  def winfo_mapped?
    TkWinfo.mapped? self
  end
  def TkWinfo.appname(window)
    bool(tk_call('winfo', 'name', window.path))
  end
  def winfo_appname
    TkWinfo.appname self
  end
  def TkWinfo.parent(window)
    window(tk_call('winfo', 'parent', window.path))
  end
  def winfo_parent
    TkWinfo.parent self
  end
  def TkWinfo.widget(id)
    window(tk_call('winfo', 'pathname', id))
  end
  def winfo_widget(id)
    TkWinfo.widget id
  end
  def TkWinfo.pixels(window, number)
    number(tk_call('winfo', 'pixels', window.path, number))
  end
  def winfo_pixels(number)
    TkWinfo.pixels self, number
  end
  def TkWinfo.reqheight(window)
    number(tk_call('winfo', 'reqheight', window.path))
  end
  def winfo_reqheight
    TkWinfo.reqheight self
  end
  def TkWinfo.reqwidth(window)
    number(tk_call('winfo', 'reqwidth', window.path))
  end
  def winfo_reqwidth
    TkWinfo.reqwidth self
  end
  def TkWinfo.rgb(window, color)
    list(tk_call('winfo', 'rgb', window.path, color))
  end
  def winfo_rgb(color)
    TkWinfo.rgb self, color
  end
  def TkWinfo.rootx(window)
    number(tk_call('winfo', 'rootx', window.path))
  end
  def winfo_rootx
    TkWinfo.rootx self
  end
  def TkWinfo.rooty(window)
    number(tk_call('winfo', 'rooty', window.path))
  end
  def winfo_rooty
    TkWinfo.rooty self
  end
  def TkWinfo.screen(window)
    tk_call 'winfo', 'screen', window.path
  end
  def winfo_screen
    TkWinfo.screen self
  end
  def TkWinfo.screencells(window)
    number(tk_call('winfo', 'screencells', window.path))
  end
  def winfo_screencells
    TkWinfo.screencells self
  end
  def TkWinfo.screendepth(window)
    number(tk_call('winfo', 'screendepth', window.path))
  end
  def winfo_screendepth
    TkWinfo.screendepth self
  end
  def TkWinfo.screenheight (window)
    number(tk_call('winfo', 'screenheight', window.path))
  end
  def winfo_screenheight
    TkWinfo.screenheight self
  end
  def TkWinfo.screenmmheight(window)
    number(tk_call('winfo', 'screenmmheight', window.path))
  end
  def winfo_screenmmheight
    TkWinfo.screenmmheight self
  end
  def TkWinfo.screenmmwidth(window)
    number(tk_call('winfo', 'screenmmwidth', window.path))
  end
  def winfo_screenmmwidth
    TkWinfo.screenmmwidth self
  end
  def TkWinfo.screenvisual(window)
    tk_call 'winfo', 'screenvisual', window.path
  end
  def winfo_screenvisual
    TkWinfo.screenvisual self
  end
  def TkWinfo.screenwidth(window)
    number(tk_call('winfo', 'screenwidth', window.path))
  end
  def winfo_screenwidth
    TkWinfo.screenwidth self
  end
  def TkWinfo.toplevel(window)
    window(tk_call('winfo', 'toplevel', window.path))
  end
  def winfo_toplevel
    TkWinfo.toplevel self
  end
  def TkWinfo.visual(window)
    tk_call 'winfo', 'visual', window.path
  end
  def winfo_visual
    TkWinfo.visual self
  end
  def TkWinfo.vrootheigh(window)
    number(tk_call('winfo', 'vrootheight', window.path))
  end
  def winfo_vrootheight
    TkWinfo.vrootheight self
  end
  def TkWinfo.vrootwidth(window)
    number(tk_call('winfo', 'vrootwidth', window.path))
  end
  def winfo_vrootwidth
    TkWinfo.vrootwidth self
  end
  def TkWinfo.vrootx(window)
    number(tk_call('winfo', 'vrootx', window.path))
  end
  def winfo_vrootx
    TkWinfo.vrootx self
  end
  def TkWinfo.vrooty(window)
    number(tk_call('winfo', 'vrooty', window.path))
  end
  def winfo_vrooty
    TkWinfo.vrooty self
  end
  def TkWinfo.width(window)
    number(tk_call('winfo', 'width', window.path))
  end
  def winfo_width
    TkWinfo.width self
  end
  def TkWinfo.x(window)
    number(tk_call('winfo', 'x', window.path))
  end
  def winfo_x
    TkWinfo.x self
  end
  def TkWinfo.y(window)
    number(tk_call('winfo', 'y', window.path))
  end
  def winfo_y
    TkWinfo.y self
  end
  def TkWinfo.viewable(window)
    bool(tk_call 'winfo', 'viewable', window.path)
  end
  def winfo_viewable
    TkWinfo.viewable self
  end
  def TkWinfo.pointerx(window)
    number(tk_call('winfo', 'pointerx', window.path))
  end
  def winfo_pointerx
    TkWinfo.pointerx self
  end
  def TkWinfo.pointery(window)
    number(tk_call('winfo', 'pointery', window.path))
  end
  def winfo_pointery
    TkWinfo.pointery self
  end
  def TkWinfo.pointerxy(window)
    list(tk_call('winfo', 'pointerxy', window.path))
  end
  def winfo_pointerxy
    TkWinfo.pointerxy self
  end
end

module TkPack
  include Tk
  extend Tk
  def configure(win, *args)
    if args[-1].kind_of?(Hash)
      keys = args.pop
    end
    wins = [win.epath]
    for i in args
      wins.push i.epath
    end
    tk_call "pack", 'configure', *(wins+hash_kv(keys))
  end

  def forget(*args)
    tk_call 'pack', 'forget' *args
  end

  def propagate(master, bool=None)
    bool(tk_call('pack', 'propagate', master.epath, bool))
  end
  module_function :configure, :forget, :propagate
end

module TkGrid
  include Tk
  extend Tk

  def bbox(*args)
    list(tk_call('grid', 'bbox', *args))
  end

  def configure(widget, *args)
    if args[-1].kind_of?(Hash)
      keys = args.pop
    end
    wins = [widget.epath]
    for i in args
      wins.push i.epath
    end
    tk_call "grid", 'configure', *(wins+hash_kv(keys))
  end

  def columnconfigure(master, index, args)
    tk_call "grid", 'columnconfigure', master, index, *hash_kv(args)
  end

  def rowconfigure(master, index, args)
    tk_call "grid", 'rowconfigure', master, index, *hash_kv(args)
  end

  def add(widget, *args)
    configure(widget, *args)
  end

  def forget(*args)
    tk_call 'grid', 'forget', *args
  end

  def info(slave)
    list(tk_call('grid', 'info', slave))
  end

  def location(master, x, y)
    list(tk_call('grid', 'location', master, x, y))
  end

  def propagate(master, bool=None)
    bool(tk_call('grid', 'propagate', master.epath, bool))
  end

  def remove(*args)
    tk_call 'grid', 'remove', *args
  end

  def size(master)
    tk_call 'grid', 'size', master
  end

  def slaves(args)
    list(tk_call('grid', 'slaves', *hash_kv(args)))
  end

  module_function :bbox, :forget, :propagate, :info
  module_function :remove, :size, :slaves, :location
  module_function :configure, :columnconfigure, :rowconfigure
end

module TkOption
  include Tk
  extend Tk
  def add pat, value, pri=None
    tk_call 'option', 'add', pat, value, pri
  end
  def clear
    tk_call 'option', 'clear'
  end
  def get win, name, klass
    tk_call 'option', 'get', win ,name, klass
  end
  def readfile file, pri=None
    tk_call 'option', 'readfile', file, pri
  end
  module_function :add, :clear, :get, :readfile
end

module TkTreatFont
  def font_configinfo
    ret = TkFont.used_on(self.path)
    if ret == nil
      ret = TkFont.init_widget_font(self.path, self.path, 'configure')
    end
    ret
  end
  alias fontobj font_configinfo

  def font_configure(slot)
    if (fnt = slot['font'])
      slot['font'] = nil
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(self.path, self.path,'configure',slot)
      else
	latinfont_configure(fnt) if fnt
      end
    end
    if (ltn = slot['latinfont'])
      slot['latinfont'] = nil
      latinfont_configure(ltn) if ltn
    end
    if (ltn = slot['asciifont'])
      slot['asciifont'] = nil
      latinfont_configure(ltn) if ltn
    end
    if (knj = slot['kanjifont'])
      slot['kanjifont'] = nil
      kanjifont_configure(knj) if knj
    end

    tk_call(self.path, 'configure', *hash_kv(slot)) if slot != {}
    self
  end

  def latinfont_configure(ltn, keys=nil)
    fobj = fontobj
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val}
      if keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciifont_configure latinfont_configure

  def kanjifont_configure(knj, keys=nil)
    fobj = fontobj
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val}
      if keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(cond)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def font_copy(window, tag=nil)
    if tag
      window.tagfontobj(tag).configinfo.each{|key,value|
	fontobj.configure(key,value)
      }
      fontobj.replace(window.tagfontobj(tag).latin_font, 
		      window.tagfontobj(tag).kanji_font)
    else
      window.fontobj.configinfo.each{|key,value|
	fontobj.configure(key,value)
      }
      fontobj.replace(window.fontobj.latin_font, window.fontobj.kanji_font)
    end
  end

  def latinfont_copy(window, tag=nil)
    if tag
      fontobj.latin_replace(window.tagfontobj(tag).latin_font)
    else
      fontobj.latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciifont_copy latinfont_copy

  def kanjifont_copy(window, tag=nil)
    if tag
      fontobj.kanji_replace(window.tagfontobj(tag).kanji_font)
    else
      fontobj.kanji_replace(window.fontobj.kanji_font)
    end
  end
end

class TkObject<TkKernel
  include Tk
  include TkTreatFont

  def path
    return @@path
  end

  def epath
    return @@path
  end

  def to_eval
    @@path
  end

  def tk_send(cmd, *rest)
    tk_call path, cmd, *rest
  end
  private :tk_send

  def method_missing(id, *args)
    name = id.id2name
    case args.length
    when 1
      configure name, args[0]
    when 0
      begin
	cget name
      rescue
	fail NameError, "undefined local variable or method `#{name}' for #{self.to_s}", error_at
      end
    else
      fail NameError, "undefined method `#{name}' for #{self.to_s}", error_at
    end
  end

  def [](id)
    cget id
  end

  def []=(id, val)
    configure id, val
  end

  def cget(slot)
    tk_tcl2ruby tk_call path, 'cget', "-#{slot}"
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      if ( slot['font'] || slot['kanjifont'] \
	  || slot['latinfont'] || slot['asciifont'] )
	font_configure(slot.dup)
      else
	tk_call path, 'configure', *hash_kv(slot)
      end

    else
      if ( slot == 'font' || slot == 'kanjifont' \
	  || slot == 'latinfont' || slot == 'asciifont' )
	font_configure({slot=>value})
      else
	tk_call path, 'configure', "-#{slot}", value
      end
    end
  end

  def configure_cmd(slot, value)
    configure slot, install_cmd(value)
  end

  def configinfo(slot = nil)
    if slot == 'font' || slot == 'kanjifont'
      fontobj

    else
      if slot
	conf = tk_split_list(tk_send('configure', "-#{slot}") )
	conf[0] = conf[0][1..-1]
	conf

      else
	ret = tk_split_list(tk_send('configure') ).collect{|conf|
	  conf[0] = conf[0][1..-1]
	  conf
	}
	if ret.assoc('font')
	  ret.delete_if{|item| item[0] == 'font' || item[0] == 'kanjifont'}
	  ret.push(['font', fontobj])
	else
	  ret
	end
      end
    end
  end

  def bind(context, cmd=Proc.new, args=nil)
    _bind path, context, cmd, args
  end

  def bind_append(context, cmd=Proc.new, args=nil)
    _bind_append path, context, cmd, args
  end

  def bindinfo(context=nil)
    _bindinfo path, context
  end

  def event_generate(context, keys=nil)
    if keys
      tk_call('event', 'generate', path, 
	      "<#{tk_event_sequence(context)}>", *hash_kv(keys))
    else
      tk_call('event', 'generate', path, "<#{tk_event_sequence(context)}>")
    end
  end

  def tk_trace_variable(v)
    unless v.kind_of?(TkVariable)
      fail ArgumentError, format("requires TkVariable given %s", v.type)
    end
    v
  end
  private :tk_trace_variable

  def destroy
    tk_call 'trace', 'vdelete', @@tk_vn, 'w', @@var_id if @@var_id
  end
end

module TkClassBind
  WidgetClassNameTBL = {}

  def TkClassBind.name2class(name)
    WidgetClassNameTBL[name]
  end

  def bind(context, cmd=Proc.new, args=nil)
    Tk.bind to_eval, context, cmd, args
  end

  def bind_append(context, cmd=Proc.new, args=nil)
    Tk.bind_append to_eval, context, cmd, args
  end

  def bindinfo(context=nil)
    Tk.bindinfo to_eval, context
  end
end

class TkWindow<TkObject
  extend TkClassBind

  def initialize(parent=nil, keys=nil)
    install_win(if parent then parent.path end)
    create_self
    if keys
      # tk_call @@path, 'configure', *hash_kv(keys)
      configure(keys)
    end
  end

  def create_self
  end
  private :create_self

  def pack(keys = nil)
    tk_call 'pack', epath, *hash_kv(keys)
    self
  end

  def unpack(keys = nil)
    tk_call 'pack', 'forget', epath
    self
  end

  def grid(keys = nil)
    tk_call 'grid', epath, *hash_kv(keys)
    self
  end

  def ungrid(keys = nil)
    tk_call 'grid', 'forget', epath
    self
  end

  def place(keys = nil)
    tk_call 'place', epath, *hash_kv(keys)
    self
  end

  def unplace(keys = nil)
    tk_call 'place', 'forget', epath, *hash_kv(keys)
    self
  end
  alias place_forget unplace

  def place_config(keys)
    tk_call "place", 'configure', epath, *hash_kv(keys)
  end

  def place_info()
    ilist = list(tk_call('place', 'info', epath))
    info = {}
    while key = ilist.shift
      info[key[1..-1]] = ilist.shift
    end
    return info
  end

  def pack_slaves()
    list(tk_call('pack', 'slaves', epath))
  end

  def pack_info()
    ilist = list(tk_call('pack', 'info', epath))
    info = {}
    while key = ilist.shift
      info[key[1..-1]] = ilist.shift
    end
    return info
  end

  def place_slaves()
    list(tk_call('place', 'slaves', epath))
  end

  def focus(force=false)
    if force
      tk_call 'focus', '-force', path
    else
      tk_call 'focus', path
    end
    self
  end

  def grab(*args)
    if !args or args.length == 0
      tk_call 'grab', 'set', path
    elsif args.length == 1
      case args[0]
      when 'global'
	tk_call 'grab', 'set', '-global', path
      else
	val = tk_call('grab', args[0], path)
      end
      case args[0]
      when 'current'
	return window(val)
      when 'status'
	return val
      end
    else
      fail ArgumentError, 'wrong # of args'
    end
  end

  def lower(below=None)
    tk_call 'lower', path, below
    self
  end
  def raise(above=None)
    tk_call 'raise', path, above
    self
  end

  def command(cmd=Proc.new)
    configure_cmd 'command', cmd
  end

  def colormodel model=None
    tk_call 'tk', 'colormodel', path, model
    self
  end

  def destroy
    tk_call 'destroy', path
    if @@cmdtbl
      for id in @@cmdtbl
	uninstall_cmd id
      end
    end
    uninstall_win
  end

  def wait_visibility
    tk_call 'tkwait', 'visibility', path
  end
  alias wait wait_visibility

  def wait_destroy
    tk_call 'tkwait', 'window', path
  end

  def bindtags(taglist=nil)
    if taglist
      fail unless taglist.kind_of? Array
      tk_call('bindtags', path, taglist)
    else
      tk_split_list(tk_call('bindtags', path)).collect{|tag|
	if tag == nil
	  '.'
	elsif tag.kind_of?(String) && (cls = TkClassBind.name2class(tag))
	  cls
	else
	  tag
	end
      }
    end
  end
end

class TkRoot<TkWindow
  include Wm
  ROOT = []
  def TkRoot.new
    return ROOT[0] if ROOT[0]
    new = super
    ROOT[0] = new
    Tk_WINDOWS["."] = new
  end

  WidgetClassName = 'Tk'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def create_self
    @@path = '.'
  end
  def path
    "."
  end
end

class TkToplevel<TkWindow
  include Wm

  WidgetClassName = 'Toplevel'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def initialize(parent=nil, screen=nil, classname=nil, keys=nil)
    if screen.kind_of? Hash
      keys = screen.dup
    else
      @@screen = screen
    end
    @@classname = classname
    if keys.kind_of? Hash
      keys = keys.dup
      if keys['classname']
	@@classname = keys['classname']
	keys['classname'] = nil
      end
      if keys['colormap']
	@@colormap = keys['colormap']
	keys['colormap'] = nil
      end
      if keys['container']
	@@classname = keys['container']
	keys['classname'] = nil
      end
      if keys['screen']
	@@screen = keys['screen']
	keys['screen'] = nil
      end
      if keys['use']
	@@use = keys['use']
	keys['use'] = nil
      end
      if keys['visual']
	@@screen = keys['visual']
	keys['visual'] = nil
      end
    end
    super(parent, keys)
  end

  def create_self
    s = []
    s.push << "-class"     << @@classname if @@classname
    s.push << "-colormap"  << @@colormap  if @@colormap
    s.push << "-container" << @@container if @@container
    s.push << "-screen"    << @@screen    if @@screen 
    s.push << "-use"       << @@use       if @@use
    s.push << "-visual"    << @@visual    if @@visual
    tk_call 'toplevel', @@path, *s
  end

  def specific_class
    @@classname
  end
end

class TkFrame<TkWindow
  WidgetClassName = 'Frame'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def initialize(parent=nil, keys=nil)
    if keys.kind_of? Hash
      keys = keys.dup
      if keys['classname']
	@@classname = keys['classname']
	keys['classname'] = nil
      end
      if keys['colormap']
	@@colormap = keys['colormap']
	keys['colormap'] = nil
      end
      if keys['container']
      @@classname = keys['container']
	keys['classname'] = nil
      end
      if keys['visual']
	@@screen = keys['visual']
	keys['visual'] = nil
      end
    end
    super(parent, keys)
  end

  def create_self
    s = []
    s.push << "-class"     << @@classname if @@classname
    s.push << "-colormap"  << @@colormap  if @@colormap
    s.push << "-container" << @@container if @@container
    s.push << "-visual"    << @@visual    if @@visual
    tk_call 'frame', @@path, *s
  end
end

class TkLabel<TkWindow
  WidgetClassName = 'Label'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end
  def create_self
    tk_call 'label', @@path
  end
  def textvariable(v)
    configure 'textvariable', tk_trace_variable(v)
  end
end

class TkButton<TkLabel
  WidgetClassName = 'Button'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
#  def TkButton.to_eval
  def self.to_eval
    WidgetClassName
  end
  def create_self
    tk_call 'button', @@path
  end
  def invoke
    tk_send 'invoke'
  end
  def flash
    tk_send 'flash'
  end
end

class TkRadioButton<TkButton
  WidgetClassName = 'Radiobutton'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def TkRadioButton.to_eval
    WidgetClassName
  end
  def create_self
    tk_call 'radiobutton', @@path
  end
  def deselect
    tk_send 'deselect'
  end
  def select
    tk_send 'select'
  end
  def variable(v)
    configure 'variable', tk_trace_variable(v)
  end
end

class TkCheckButton<TkRadioButton
  TkClassBind::WidgetClassNameTBL['Checkbutton'] = self
  def TkCheckButton.to_eval
    'Checkbutton'
  end
  def create_self
    tk_call 'checkbutton', @@path
  end
  def toggle
    tk_send 'toggle'
  end
end

class TkMessage<TkLabel
  TkClassBind::WidgetClassNameTBL['Message'] = self
  def TkMessage.to_eval
    'Message'
  end
  def create_self
    tk_call 'message', @@path
  end
end

class TkScale<TkWindow
  WidgetClassName = 'Scale'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def create_self
    tk_call 'scale', path
  end

  def get
    number(tk_send('get'))
  end

  def set(val)
    tk_send "set", val
  end

  def value
    get
  end

  def value= (val)
    set val
  end
end

class TkScrollbar<TkWindow
  WidgetClassName = 'Scrollbar'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

  def create_self
    tk_call 'scrollbar', path
  end

  def delta(deltax=None, deltay=None)
    number(tk_send('delta', deltax, deltay))
  end

  def fraction(x=None, y=None)
    number(tk_send('fraction', x, y))
  end

  def identify(x=None, y=None)
    tk_send('fraction', x, y)
  end

  def get
    ary1 = tk_send('get', path).split
    ary2 = []
    for i in ary1
      ary2.push number(i)
    end
    ary2
  end

  def set(first, last)
    tk_send "set", first, last
  end
end

class TkTextWin<TkWindow
  def create_self
    raise TypeError, "TkTextWin is abstract class"
  end

  def bbox(index)
    tk_send 'bbox', index
  end
  def delete(first, last=None)
    tk_send 'delete', first, last
  end
  def get(*index)
    tk_send 'get', *index
  end
  def index(index)
    tk_send 'index', index
  end
  def insert(index, chars, *args)
    tk_send 'insert', index, chars, *args
  end
  def scan_mark(x, y)
    tk_send 'scan', 'mark', x, y
  end
  def scan_dragto(x, y)
    tk_send 'scan', 'dragto', x, y
  end
  def see(index)
    tk_send 'see', index
  end
end

class TkListbox<TkTextWin
  TkClassBind::WidgetClassNameTBL['Listbox'] = self
  def TkListbox.to_eval
    'Listbox'
  end
  def create_self
    tk_call 'listbox', path
  end

  def activate(y)
    tk_send 'activate', y
  end
  def curselection
    list(tk_send('curselection'))
  end
  def nearest(y)
    tk_send('nearest', y).to_i
  end
  def size(y)
    tk_send('size').to_i
  end
  def selection_anchor(index)
    tk_send 'selection', 'anchor', index
  end
  def selection_clear(first, last=None)
    tk_send 'selection', 'clear', first, last
  end
  def selection_includes
    bool(tk_send('selection', 'includes'))
  end
  def selection_set(first, last=None)
    tk_send 'selection', 'set', first, last
  end
  def xview(cmd, index, *more)
    v = tk_send('xview', cmd, index, *more)
    v.to_i if more.size == 0
  end
  def yview(cmd, index, *more)
    v = tk_send('yview', cmd, index, *more)
    v.to_i if more.size == 0
  end
end

module TkTreatMenuEntryFont
  def tagfont_configinfo(index)
    pathname = self.path + ';' + index
    ret = TkFont.used_on(pathname)
    if ret == nil
      ret = TkFont.init_widget_font(pathname, 
				    self.path, 'entryconfigure', index)
    end
    ret
  end
  alias tagfontobj tagfont_configinfo

  def tagfont_configure(index, slot)
    pathname = self.path + ';' + index
    if (fnt = slot['font'])
      slot['font'] = nil
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(pathname, 
				       self.path,'entryconfigure',index,slot)
      else
	latintagfont_configure(index, fnt) if fnt
      end
    end
    if (ltn = slot['latinfont'])
      slot['latinfont'] = nil
      latintagfont_configure(index, ltn) if ltn
    end
    if (ltn = slot['asciifont'])
      slot['asciifont'] = nil
      latintagfont_configure(index, ltn) if ltn
    end
    if (knj = slot['kanjifont'])
      slot['kanjifont'] = nil
      kanjitagfont_configure(index, knj) if knj
    end

    tk_call(self.path, 'entryconfigure', index, *hash_kv(slot)) if slot != {}
    self
  end

  def latintagfont_configure(index, ltn, keys=nil)
    fobj = tagfontobj(index)
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.latin_replace(ltn)
	fobj.latin_configure(keys) if keys
      elsif keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciitagfont_configure latintagfont_configure

  def kanjitagfont_configure(index, knj, keys=nil)
    fobj = tagfontobj(index)
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.kanji_replace(knj)
	fobj.kanji_configure(keys) if keys
      elsif keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(conf)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def tagfont_copy(index, window, wintag=nil)
    if wintag
      window.tagfontobj(wintag).configinfo.each{|key,value|
	tagfontobj(index).configure(key,value)
      }
      tagfontobj(index).replace(window.tagfontobj(wintag).latin_font, 
			      window.tagfontobj(wintag).kanji_font)
    else
      window.tagfont(wintag).configinfo.each{|key,value|
	tagfontobj(index).configure(key,value)
      }
      tagfontobj(index).replace(window.fontobj.latin_font, 
			      window.fontobj.kanji_font)
    end
  end

  def latintagfont_copy(index, window, wintag=nil)
    if wintag
      tagfontobj(index).latin_replace(window.tagfontobj(wintag).latin_font)
    else
      tagfontobj(index).latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciitagfont_copy latintagfont_copy

  def kanjitagfont_copy(index, window, wintag=nil)
    if wintag
      tagfontobj(index).kanji_replace(window.tagfontobj(wintag).kanji_font)
    else
      tagfontobj(index).kanji_replace(window.fontobj.kanji_font)
    end
  end
end

class TkMenu<TkWindow
  include TkTreatMenuEntryFont

  WidgetClassName = 'Menu'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end
  def create_self
    tk_call 'menu', path
  end
  def activate(index)
    tk_send 'activate', index
  end
  def add(type, keys=nil)
    tk_send 'add', type, *hash_kv(keys)
  end
  def index(index)
    tk_send 'index', index
  end
  def invoke(index)
    tk_send 'invoke', index
  end
  def insert(index, type, keys=nil)
    tk_send 'add', index, type, *hash_kv(keys)
  end
  def delete(index, last=None)
    tk_send 'delete', index, last
  end
  def post(x, y)
    tk_send 'post', x, y
  end
  def postcascade(index)
    tk_send 'postcascade', index
  end
  def postcommand(cmd=Proc.new)
    configure_cmd 'postcommand', cmd
  end
  def menutype(index)
    tk_send 'type', index
  end
  def unpost
    tk_send 'unpost'
  end
  def yposition(index)
    number(tk_send('yposition', index))
  end
  def entryconfigure(index, keys=nil)
    tk_send 'entryconfigure', index, *hash_kv(keys)
  end
#  def entryconfigure(index, keys=nil)
#    tk_send 'entryconfigure', index, *hash_kv(keys)
#  end
  def entrycget(index, key)
    tk_tcl2ruby tk_send 'entrycget', index, "-#{key}"
  end
  def entryconfigure(index, key, val=None)
    if key.kind_of? Hash
      if ( key['font'] || key['kanjifont'] \
	  || key['latinfont'] || key['asciifont'] )
	tagfont_configure(index, key.dup)
      else
	tk_send 'entryconfigure', index, *hash_kv(key)
      end

    else
      if ( key == 'font' || key == 'kanjifont' \
	  || key == 'latinfont' || key == 'asciifont' )
	tagfont_configure({key=>val})
      else
	tk_call 'entryconfigure', index, "-#{key}", val
      end
    end
  end

  def entryconfiginfo(index, key=nil)
    if key
      conf = tk_split_list(tk_send('entryconfigure',index,"-#{key}"))
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_send('entryconfigure', index)).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end
end

class TkMenubutton<TkLabel
  TkClassBind::WidgetClassNameTBL['Menubutton'] = self
  def TkMenubutton.to_eval
    'Menubutton'
  end
  def create_self
    tk_call 'menubutton', path
  end
end

module TkComposite
  def initialize(parent=nil, *args)
    @@frame = TkFrame.new(parent)
    @@path = @@epath = @@frame.path
    initialize_composite(*args)
  end

  def epath
    @@epath
  end

  def initialize_composite(*args) end
  private :initialize_composite

  def delegate(option, *wins)
    unless @@delegates
      @@delegates = {} 
      @@delegates['DEFAULT'] = @@frame
    end
    if @@delegates[option].kind_of?(Array)
      for i in wins
	@@delegates[option].push(i)
      end
    else
      @@delegates[option] = wins
    end
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      slot.each{|slot,value| configure slot, value}
    else
      if @@delegates and @@delegates[slot]
	for i in @@delegates[slot]
	  if not i
	    i = @@delegates['DEFALUT']
	    redo
	  else
	    last = i.configure(slot, value)
	  end
	end
	last
      else
	super
      end
    end
  end
end

module TkClipboard
  include Tk
  extend Tk

  def clear
    tk_call 'clipboard', 'clear'
  end
  def get
    begin
      tk_call 'selection', 'get', '-selection', 'CLIPBOARD'
    rescue
      ''
    end
  end
  def set(data)
    clear
    append(data)
  end
  def append(data)
    tk_call 'clipboard', 'append', data
  end

  module_function :clear, :set, :get, :append
end

autoload :TkCanvas, 'tkcanvas'
autoload :TkImage, 'tkcanvas'
autoload :TkBitmapImage, 'tkcanvas'
autoload :TkPhotoImage, 'tkcanvas'
autoload :TkEntry, 'tkentry'
autoload :TkText, 'tktext'
autoload :TkDialog, 'tkdialog'
autoload :TkMenubar, 'tkmenubar'
autoload :TkAfter, 'tkafter'
autoload :TkPalette, 'tkpalette'
autoload :TkFont, 'tkfont'
autoload :TkVirtualEvent, 'tkvirtevent'
@


1.1.2.2
log
@1.2.3
@
text
@d3 1
a3 1
#			$Date: 1998/11/17 09:12:44 $
a581 1
    include TkComm
@


1.1.2.3
log
@1.2.6
@
text
@d3 1
a3 1
#			$Date: 1999/02/16 03:42:20 $
a235 1
    id = $1 if /rb_out (c\d+)/
d2118 1
a2118 1
    ary1 = tk_send('get').split
@
