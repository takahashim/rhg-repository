head	1.21;
access;
symbols
	v1_6_7:1.13.2.4
	v1_6_6:1.13.2.2
	v1_6_5:1.13.2.2
	v1_6_4:1.13.2.1
	v1_7_1:1.14
	v1_6_4_preview4:1.13.2.1
	v1_6_4_preview3:1.13.2.1
	v1_6_4_preview2:1.13.2.1
	v1_6_4_preview1:1.13.2.1
	v1_6_3:1.13
	ruby_m17n:1.13.0.4
	ruby_1_6:1.13.0.2
	v1_6_2:1.13
	v1_6_1:1.12
	v1_6_0:1.12
	v1_4_6:1.3.2.7
	v1_4_5:1.3.2.6
	v1_4_4:1.3.2.2
	ruby_1_4_3:1.3
	ruby1_4_3:1.3
	v1_4_3:1.3
	v1_5_0:1.3
	ruby_1_4_3_pre1:1.3
	ruby_1_4:1.3.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.5
	v1_3_6_repack:1.1.1.1.2.5
	v1_3_6:1.1.1.1.2.5
	v1_3_5:1.1.1.1.2.5
	v1_2_6repack:1.1.2.2
	v1_3_4_990625:1.1.1.1.2.5
	v1_3_4_990624:1.1.1.1.2.5
	v1_2_6:1.1.2.2
	v1_3_4_990611:1.1.1.1.2.3
	v1_3_4_990531:1.1.1.1.2.2
	v1_3_3_990518:1.1.1.1.2.1
	v1_3_3_990513:1.1.1.1.2.1
	v1_3_3_990507:1.1.1.1.2.1
	v1_2_5:1.1.2.1
	v1_2_4:1.1.2.1
	v1_3_1_990225:1.1.1.1
	v1_3_1_990224:1.1.1.1
	v1_3_1_990215:1.1.1.1
	v1_3_1_990212:1.1.1.1
	v1_3_1_990210:1.1.1.1
	v1_3_1_:1.1.1.1
	v1_3_1_990209:1.1.1.1
	v1_3_1_990205:1.1.1.1
	v1_3_1_990203:1.1.1.1
	v1_3_1_990201:1.1.1.1
	v1_3_1"_990201:1.1.1.1
	v1_3_1_990128:1.1.1.1
	v1_3_1_990127:1.1.1.1
	v1_3_1_990126:1.1.1.1
	ruby_1_3:1.1.1.1.0.2
	v1_2_2:1.1.2.1
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_2_2_pr1:1.1.2.1
	v1_2_1repack:1.1.2.1
	v1_2_1:1.1.2.1
	v1_2_stable:1.1.2.1
	v1_1c9_1:1.1.2.1
	v1_1c9:1.1.2.1
	v1_1c8:1.1.2.1
	v1_1r:1.1.0.2;
locks; strict;
comment	@# @;


1.21
date	2002.10.02.06.02.17;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.28.14.40.25;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.04.07.03.33;	author nagai;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.08.07.03.07;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.28.06.53.33;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.28.08.44.43;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.05.06.54.57;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.27.07.09.27;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.27.09.23.36;	author matz;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.08.02.04.54.21;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.01.09.25.36;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.24.04.34.22;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.01.09.41.37;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.10.05.57.37;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.10.05.44.25;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.17.08.58.18;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.17.08.37.52;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.05.04.37.21;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.08.24.08.21.56;	author matz;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.08.13.05.37.52;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.11.17.09.12.44;	author matz;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	99.01.20.04.59.34;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.04.26.09.42.43;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.05.31.09.13.32;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.06.09.09.21.36;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.06.11.07.07.06;	author matz;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.06.24.04.24.07;	author matz;	state Exp;
branches;
next	;

1.1.2.1
date	98.11.17.09.12.44;	author matz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	99.06.21.06.31.12;	author matz;	state Exp;
branches;
next	;

1.3.2.1
date	2000.01.05.04.41.17;	author matz;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2000.01.17.08.24.19;	author matz;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2000.03.23.04.14.28;	author matz;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2000.04.10.05.48.42;	author matz;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2000.04.10.05.56.59;	author matz;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2000.05.01.09.42.37;	author matz;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2000.06.23.08.38.45;	author matz;	state Exp;
branches;
next	1.3.2.8;

1.3.2.8
date	2000.08.01.06.27.35;	author matz;	state Exp;
branches;
next	1.3.2.9;

1.3.2.9
date	2000.08.07.05.05.01;	author matz;	state Exp;
branches;
next	;

1.13.2.1
date	2001.03.27.07.10.58;	author matz;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.09.05.06.53.31;	author matz;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2002.01.28.08.42.40;	author matz;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2002.02.28.06.52.49;	author matz;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2002.03.08.06.59.55;	author matz;	state Exp;
branches;
next	;


desc
@@


1.21
log
@* commit miss;  and tcltklib fix too.
@
text
@#
#		tktext.rb - Tk text classes
#			$Date: 2002/06/28 14:40:25 $
#			by Yukihiro Matsumoto <matz@@caelum.co.jp>

require 'tk.rb'
require 'tkfont'

module TkTreatTextTagFont
  include TkTreatItemFont

  ItemCMD = ['tag', 'configure']
  def __conf_cmd(idx)
    ItemCMD[idx]
  end

  def __item_pathname(tagOrId)
    if tagOrId.kind_of?(TkTextTag)
      self.path + ';' + tagOrId.id
    else
      self.path + ';' + tagOrId
    end
  end
end

class TkText<TkTextWin
  ItemConfCMD = ['tag', 'configure']
  include TkTreatTextTagFont
  include Scrollable

  WidgetClassName = 'Text'.freeze
  WidgetClassNames[WidgetClassName] = self

  def self.to_eval
    WidgetClassName
  end

  def self.new(*args, &block)
    obj = super(*args){}
    obj.init_instance_variable
    obj.instance_eval(&block) if defined? yield
    obj
  end

  def init_instance_variable
    @@tags = {}
  end

  def create_self(keys)
    if keys and keys != None
      tk_call 'text', @@path, *hash_kv(keys)
    else
      tk_call 'text', @@path
    end
    init_instance_variable
  end

  def index(index)
    tk_send 'index', index
  end

  def value
    tk_send 'get', "1.0", "end - 1 char"
  end

  def value= (val)
    tk_send 'delete', "1.0", 'end'
    tk_send 'insert', "1.0", val
  end

  def _addcmd(cmd)
    @@cmdtbl.push cmd
  end

  def _addtag(name, obj)
    @@tags[name] = obj
  end

  def tagid2obj(tagid)
    if not @@tags[tagid]
      tagid
    else
      @@tags[tagid]
    end
  end

  def tag_names(index=None)
    tk_split_list(tk_send('tag', 'names', index)).collect{|elt|
      tagid2obj(elt)
    }
  end

  def mark_names
    tk_split_list(tk_send('mark', 'names')).collect{|elt|
      tagid2obj(elt)
    }
  end

  def mark_next(index)
    tagid2obj(tk_send('mark', 'next', index))
  end

  def mark_previous(index)
    tagid2obj(tk_send('mark', 'previous', index))
  end

  def window_names
    tk_send('window', 'names').collect{|elt|
      tagid2obj(elt)
    }
  end

  def image_names
    tk_send('image', 'names').collect{|elt|
      tagid2obj(elt)
    }
  end

  def set_insert(index)
    tk_send 'mark', 'set', 'insert', index
  end

  def set_current(index)
    tk_send 'mark', 'set', 'current', index
  end

  def insert(index, chars, *tags)
    super index, chars, tags.collect{|x|_get_eval_string(x)}.join(' ')
  end

  def destroy
    @@tags = {} unless @@tags
    @@tags.each_value do |t|
      t.destroy
    end
    super
  end

  def backspace
    self.delete 'insert'
  end

  def compare(idx1, op, idx2)
    bool(tk_send('compare', idx1, op, idx2))
  end

  def debug
    bool(tk_send('debug'))
  end
  def debug=(boolean)
    tk_send 'debug', boolean
  end

  def bbox(index)
    inf = tk_send('bbox', index)
    (inf == "")?  [0,0,0,0]: inf
  end
  def dlineinfo(index)
    inf = tk_send('dlineinfo', index)
    (inf == "")?  [0,0,0,0,0]: inf
  end

  def yview_pickplace(*what)
    tk_send 'yview', '-pickplace', *what
  end

  def xview_pickplace(*what)
    tk_send 'xview', '-pickplace', *what
  end

  def tag_add(tag, index1, index2=None)
    tk_send 'tag', 'add', tag, index1, index2
  end

  def tag_bind(tag, seq, cmd=Proc.new, args=nil)
    _bind(['tag', 'bind', tag], seq, cmd, args)
  end

  def tag_bind_append(tag, seq, cmd=Proc.new, args=nil)
    _bind_append(['tag', 'bind', tag], seq, cmd, args)
  end

  def tag_bindinfo(tag, context=nil)
    _bindinfo(['tag', 'bind', tag], context)
  end

  def tag_cget(tag, key)
    case key.to_s
    when 'text', 'label', 'show', 'data', 'file'
      tk_call @@path, 'tag', 'cget', tag, "-#{key}"
    else
      tk_tcl2ruby tk_call(@@path, 'tag', 'cget', tag, "-#{key}")
    end
  end

  def tag_configure(tag, key, val=None)
    if key.kind_of? Hash
      key = _symbolkey2str(key)
      if ( key['font'] || key['kanjifont'] \
	  || key['latinfont'] || key['asciifont'] )
	tagfont_configure(tag, key)
      else
	tk_send 'tag', 'configure', tag, *hash_kv(key)
      end

    else
      if  key == 'font' || key == :font || 
          key == 'kanjifont' || key == :kanjifont ||
	  key == 'latinfont' || key == :latinfont || 
          key == 'asciifont' || key == :asciifont
	tagfont_configure(tag, {key=>val})
      else
	tk_send 'tag', 'configure', tag, "-#{key}", val
      end
    end
  end

  def tag_configinfo(tag, key=nil)
    if key
      case key.to_s
      when 'text', 'label', 'show', 'data', 'file'
	conf = tk_split_simplelist(tk_send('tag','configure',tag,"-#{key}"))
      else
	conf = tk_split_list(tk_send('tag','configure',tag,"-#{key}"))
      end
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_simplelist(tk_send('tag', 'configure', tag)).collect{|conflist|
	conf = tk_split_simplelist(conflist)
	conf[0] = conf[0][1..-1]
	case conf[0]
	when 'text', 'label', 'show', 'data', 'file'
	else
	  if conf[3]
	    if conf[3].index('{')
	      conf[3] = tk_split_list(conf[3]) 
	    else
	      conf[3] = tk_tcl2ruby(conf[3]) 
	    end
	  end
	  if conf[4]
	    if conf[4].index('{')
	      conf[4] = tk_split_list(conf[4]) 
	    else
	      conf[4] = tk_tcl2ruby(conf[4]) 
	    end
	  end
	end
	conf
      }
    end
  end

  def tag_raise(tag, above=None)
    tk_send 'tag', 'raise', tag, above
  end

  def tag_lower(tag, below=None)
    tk_send 'tag', 'lower', tag, below
  end

  def tag_remove(tag, *index)
    tk_send 'tag', 'remove', tag, *index
  end

  def tag_ranges(tag)
    l = tk_split_simplelist(tk_send('tag', 'ranges', tag))
    r = []
    while key=l.shift
      r.push [key, l.shift]
    end
    r
  end

  def tag_nextrange(tag, first, last=None)
    tk_split_simplelist(tk_send('tag', 'nextrange', tag, first, last))
  end

  def tag_prevrange(tag, first, last=None)
    tk_split_simplelist(tk_send('tag', 'prevrange', tag, first, last))
  end

  def _ktext_length(txt)
    if $KCODE !~ /n/i
      return txt.gsub(/[^\Wa-zA-Z_\d]/, ' ').length
    end

    # $KCODE == 'NONE'
    if JAPANIZED_TK
      tk_call('kstring', 'length', txt).to_i
    else
      begin
	tk_call('encoding', 'convertto', 'ascii', txt).length
      rescue StandardError, NameError
	# sorry, I have no plan
	txt.length
      end
    end
  end
  private :_ktext_length

  def search_with_length(pat,start,stop=None)
    pat = pat.chr if pat.kind_of? Integer
    if stop != None
      return ["", 0] if compare(start,'>=',stop)
      txt = get(start,stop)
      if (pos = txt.index(pat))
	match = $&
	#pos = txt[0..(pos-1)].split('').length if pos > 0
	pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
	if pat.kind_of? String
	  #return [index(start + " + #{pos} chars"), pat.split('').length]
	  return [index(start + " + #{pos} chars"), 
		  _ktext_length(pat), pat.dup]
	else
	  #return [index(start + " + #{pos} chars"), $&.split('').length]
	  return [index(start + " + #{pos} chars"), 
		  _ktext_length(match), match]
	end
      else
	return ["", 0]
      end
    else
      txt = get(start,'end - 1 char')
      if (pos = txt.index(pat))
	match = $&
	#pos = txt[0..(pos-1)].split('').length if pos > 0
	pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
	if pat.kind_of? String
	  #return [index(start + " + #{pos} chars"), pat.split('').length]
	  return [index(start + " + #{pos} chars"), 
		  _ktext_length(pat), pat.dup]
	else
	  #return [index(start + " + #{pos} chars"), $&.split('').length]
	  return [index(start + " + #{pos} chars"), 
		  _ktext_length(match), match]
	end
      else
	txt = get('1.0','end - 1 char')
	if (pos = txt.index(pat))
	  match = $&
	  #pos = txt[0..(pos-1)].split('').length if pos > 0
	  pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
	  if pat.kind_of? String
	    #return [index("1.0 + #{pos} chars"), pat.split('').length]
	    return [index("1.0 + #{pos} chars"), 
		    _ktext_length(pat), pat.dup]
	  else
	    #return [index("1.0 + #{pos} chars"), $&.split('').length]
	    return [index("1.0 + #{pos} chars"), _ktext_length(match), match]
	  end
	else
	  return ["", 0]
	end
      end
    end
  end

  def search(pat,start,stop=None)
    search_with_length(pat,start,stop)[0]
  end

  def rsearch_with_length(pat,start,stop=None)
    pat = pat.chr if pat.kind_of? Integer
    if stop != None
      return ["", 0] if compare(start,'<=',stop)
      txt = get(stop,start)
      if (pos = txt.rindex(pat))
	match = $&
	#pos = txt[0..(pos-1)].split('').length if pos > 0
	pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
	if pat.kind_of? String
	  #return [index(stop + " + #{pos} chars"), pat.split('').length]
	  return [index(stop + " + #{pos} chars"), _ktext_length(pat), pat.dup]
	else
	  #return [index(stop + " + #{pos} chars"), $&.split('').length]
	  return [index(stop + " + #{pos} chars"), _ktext_length(match), match]
	end
      else
	return ["", 0]
      end
    else
      txt = get('1.0',start)
      if (pos = txt.rindex(pat))
	match = $&
	#pos = txt[0..(pos-1)].split('').length if pos > 0
	pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
	if pat.kind_of? String
	  #return [index("1.0 + #{pos} chars"), pat.split('').length]
	  return [index("1.0 + #{pos} chars"), _ktext_length(pat), pat.dup]
	else
	  #return [index("1.0 + #{pos} chars"), $&.split('').length]
	  return [index("1.0 + #{pos} chars"), _ktext_length(match), match]
	end
      else
	txt = get('1.0','end - 1 char')
	if (pos = txt.rindex(pat))
	  match = $&
	  #pos = txt[0..(pos-1)].split('').length if pos > 0
	  pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
	  if pat.kind_of? String
	    #return [index("1.0 + #{pos} chars"), pat.split('').length]
	    return [index("1.0 + #{pos} chars"), _ktext_length(pat), pat.dup]
	  else
	    #return [index("1.0 + #{pos} chars"), $&.split('').length]
	    return [index("1.0 + #{pos} chars"), _ktext_length(match), match]
	  end
	else
	  return ["", 0]
	end
      end
    end
  end

  def rsearch(pat,start,stop=None)
    rsearch_with_length(pat,start,stop)[0]
  end

  def dump(type_info, *index, &block)
    args = type_info.collect{|inf| '-' + inf}
    args << '-command' << Proc.new(&block) if iterator?
    str = tk_send('dump', *(args + index))
    result = []
    sel = nil
    i = 0
    while i < str.size
      # retrieve key
      idx = str.index(/ /, i)
      result.push str[i..(idx-1)]
      i = idx + 1
      
      # retrieve value
      case result[-1]
      when 'text'
	if str[i] == ?{
	  # text formed as {...}
	  val, i = _retrieve_braced_text(str, i)
	  result.push val
	else
	  # text which may contain backslahes
	  val, i = _retrieve_backslashed_text(str, i)
	  result.push val
	end
      else
	idx = str.index(/ /, i)
	val = str[i..(idx-1)]
	case result[-1]
	when 'mark'
	  case val
	  when 'insert'
	    result.push TkTextMarkInsert.new(self)
	  when 'current'
	    result.push TkTextMarkCurrent.new(self)
	  when 'anchor'
	    result.push TkTextMarkAnchor.new(self)
	  else
	    result.push tk_tcl2ruby(val)
	  end
	when 'tagon'
	  if val == 'sel'
	    if sel
	      result.push sel
	    else
	      result.push TkTextTagSel.new(self)
	    end
	  else
	    result.push tk_tcl2ruby(val)
	  end
	when 'tagoff'
	    result.push tk_tcl2ruby(sel)
	when 'window'
	  result.push tk_tcl2ruby(val)
	end
	i = idx + 1
      end

      # retrieve index
      idx = str.index(/ /, i)
      if idx
	result.push str[i..(idx-1)]
	i = idx + 1
      else
	result.push str[i..-1]
	break
      end
    end
    
    kvis = []
    until result.empty?
      kvis.push [result.shift, result.shift, result.shift]
    end
    kvis  # result is [[key1, value1, index1], [key2, value2, index2], ...]
  end

  def _retrieve_braced_text(str, i)
    cnt = 0
    idx = i
    while idx < str.size
      case str[idx]
      when ?{
	cnt += 1
      when ?}
	cnt -= 1
	if cnt == 0
	  break
	end
      end
      idx += 1
    end
    return str[i+1..idx-1], idx + 2
  end
  private :_retrieve_braced_text

  def _retrieve_backslashed_text(str, i)
    j = i
    idx = nil
    loop {
      idx = str.index(/ /, j)
      if str[idx-1] == ?\\
	j += 1
      else
	break
      end
    }
    val = str[i..(idx-1)]
    val.gsub!(/\\( |\{|\})/, '\1')
    return val, idx + 1
  end
  private :_retrieve_backslashed_text

  def dump_all(*index, &block)
    dump(['all'], *index, &block)
  end
  def dump_mark(*index, &block)
    dump(['mark'], *index, &block)
  end
  def dump_tag(*index, &block)
    dump(['tag'], *index, &block)
  end
  def dump_text(*index, &block)
    dump(['text'], *index, &block)
  end
  def dump_window(*index, &block)
    dump(['window'], *index, &block)
  end
  def dump_image(*index, &block)
    dump(['image'], *index, &block)
  end
end

class TkTextTag<TkObject
  include TkTreatTagFont

  TTagID_TBL = {}
  Tk_TextTag_ID = ['tag0000']

  def TkTextTag.id2obj(text, id)
    tpath = text.path
    return id unless TTagID_TBL[tpath]
    TTagID_TBL[tpath][id]? TTagID_TBL[tpath][id]: id
  end

  def initialize(parent, *args)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@parent = @@t = parent
    @@tpath = parent.path
    @@path = @@id = Tk_TextTag_ID[0]
    TTagID_TBL[@@id] = self
    TTagID_TBL[@@tpath] = {} unless TTagID_TBL[@@tpath]
    TTagID_TBL[@@tpath][@@id] = self
    Tk_TextTag_ID[0] = Tk_TextTag_ID[0].succ
    #tk_call @@t.path, "tag", "configure", @@id, *hash_kv(keys)
    if args != [] then
      keys = args.pop
      if keys.kind_of? Hash then
	add(*args) if args != []
	configure(keys)
      else
	args.push keys
	add(*args)
      end
    end
    @@t._addtag id, self
  end

  def id
    return @@id
  end

  def first
    @@id + '.first'
  end

  def last
    @@id + '.last'
  end

  def add(*index)
    tk_call @@t.path, 'tag', 'add', @@id, *index
  end

  def remove(*index)
    tk_call @@t.path, 'tag', 'remove', @@id, *index
  end

  def ranges
    l = tk_split_simplelist(tk_call(@@t.path, 'tag', 'ranges', @@id))
    r = []
    while key=l.shift
      r.push [key, l.shift]
    end
    r
  end

  def nextrange(first, last=None)
    tk_split_simplelist(tk_call(@@t.path, 'tag', 'nextrange', @@id, first, last))
  end

  def prevrange(first, last=None)
    tk_split_simplelist(tk_call(@@t.path, 'tag', 'prevrange', @@id, first, last))
  end

  def [](key)
    cget key
  end

  def []=(key,val)
    configure key, val
  end

  def cget(key)
    case key.to_s
    when 'text', 'label', 'show', 'data', 'file'
      tk_call @@t.path, 'tag', 'cget', @@id, "-#{key}"
    else
      tk_tcl2ruby tk_call(@@t.path, 'tag', 'cget', @@id, "-#{key}")
    end
  end

  def configure(key, val=None)
    @@t.tag_configure @@id, key, val
  end
#  def configure(key, val=None)
#    if key.kind_of? Hash
#      tk_call @@t.path, 'tag', 'configure', @@id, *hash_kv(key)
#    else
#      tk_call @@t.path, 'tag', 'configure', @@id, "-#{key}", val
#    end
#  end
#  def configure(key, value)
#    if value == FALSE
#      value = "0"
#    elsif value.kind_of? Proc
#      value = install_cmd(value)
#    end
#    tk_call @@t.path, 'tag', 'configure', @@id, "-#{key}", value
#  end

  def configinfo(key=nil)
    @@t.tag_configinfo @@id, key
  end

  def bind(seq, cmd=Proc.new, args=nil)
    _bind([@@t.path, 'tag', 'bind', @@id], seq, cmd, args)
  end

  def bind_append(seq, cmd=Proc.new, args=nil)
    _bind_append([@@t.path, 'tag', 'bind', @@id], seq, cmd, args)
  end

  def bindinfo(context=nil)
    _bindinfo([@@t.path, 'tag', 'bind', @@id], context)
  end

  def raise(above=None)
    tk_call @@t.path, 'tag', 'raise', @@id, above
  end

  def lower(below=None)
    tk_call @@t.path, 'tag', 'lower', @@id, below
  end

  def destroy
    tk_call @@t.path, 'tag', 'delete', @@id
    TTagID_TBL[@@tpath].delete(@@id) if CTagID_TBL[@@tpath]
  end
end

class TkTextNamedTag<TkTextTag
  def self.new(parent, name, *args)
    if TTagID_TBL[parent.path] && TTagID_TBL[parent.path][name]
      return TTagID_TBL[parent.path][name]
    else
      super(parent, name, *args)
    end
  end

  def initialize(parent, name, *args)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@tpath = parent.path
    @@path = @@id = name
    TTagID_TBL[@@tpath] = {} unless TTagID_TBL[@@tpath]
    TTagID_TBL[@@tpath][@@id] = self
    if mode
      tk_call @@t.path, "addtag", @@id, *args
    end
  end
end

class TkTextTagSel<TkTextTag
  def initialize(parent, keys=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'sel'
    #tk_call @@t.path, "tag", "configure", @@id, *hash_kv(keys)
    configure(keys) if keys
    @@t._addtag id, self
  end
end

class TkTextMark<TkObject
  Tk_TextMark_ID = ['mark0000']
  def initialize(parent, index)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = Tk_TextMark_ID[0]
    Tk_TextMark_ID[0] = Tk_TextMark_ID[0].succ
    tk_call @@t.path, 'mark', 'set', @@id, index
    @@t._addtag id, self
  end
  def id
    return @@id
  end

  def set(where)
    tk_call @@t.path, 'mark', 'set', @@id, where
  end

  def unset
    tk_call @@t.path, 'mark', 'unset', @@id
  end
  alias destroy unset

  def gravity
    tk_call @@t.path, 'mark', 'gravity', @@id
  end

  def gravity=(direction)
    tk_call @@t.path, 'mark', 'gravity', @@id, direction
  end

  def next(index = nil)
    if index
      @@t.tagid2obj(tk_call(@@t.path, 'mark', 'next', index))
    else
      @@t.tagid2obj(tk_call(@@t.path, 'mark', 'next', @@id))
    end
  end

  def previous(index = nil)
    if index
      @@t.tagid2obj(tk_call(@@t.path, 'mark', 'previous', index))
    else
      @@t.tagid2obj(tk_call(@@t.path, 'mark', 'previous', @@id))
    end
  end
end

class TkTextMarkInsert<TkTextMark
  def initialize(parent, index=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'insert'
    tk_call @@t.path, 'mark', 'set', @@id, index if index
    @@t._addtag id, self
  end
end

class TkTextMarkCurrent<TkTextMark
  def initialize(parent,index=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'current'
    tk_call @@t.path, 'mark', 'set', @@id, index if index
    @@t._addtag id, self
  end
end

class TkTextMarkAnchor<TkTextMark
  def initialize(parent,index=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'anchor'
    tk_call @@t.path, 'mark', 'set', @@id, index if index
    @@t._addtag id, self
  end
end

class TkTextWindow<TkObject
  def initialize(parent, index, keys)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    if index == 'end'
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
    elsif index.kind_of? TkTextMark
      if tk_call(@@t.path,'index',index.path) == tk_call(@@t.path,'index','end')
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
      else
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index.path))
      end
    else
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index))
    end
    @@path.gravity = 'left'
    @@index = @@path.path
    keys = _symbolkey2str(keys)
    @@id = keys['window']
    if keys['create']
      @@p_create = keys['create']
      if @@p_create.kind_of? Proc
	keys['create'] = install_cmd(proc{@@id = @@p_create.call; @@id.path})
      end
    end
    tk_call @@t.path, 'window', 'create', @@index, *hash_kv(keys)
  end

  def [](slot)
    cget(slot)
  end
  def []=(slot, value)
    configure(slot, value)
  end

  def cget(slot)
    case slot.to_s
    when 'text', 'label', 'show', 'data', 'file'
      tk_call @@t.path, 'window', 'cget', @@index, "-#{slot}"
    else
      tk_tcl2ruby tk_call(@@t.path, 'window', 'cget', @@index, "-#{slot}")
    end
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      slot = _symbolkey2str(slot)
      @@id = slot['window'] if slot['window']
      if slot['create']
	self.create=value
	slot['create']=nil
      end
      if slot.size > 0
	tk_call @@t.path, 'window', 'configure', @@index, *hash_kv(slot)
      end
    else
      @@id = value if slot == 'window' || slot == :window
      if slot == 'create' || slot == :create
	self.create=value
      else
	tk_call @@t.path, 'window', 'configure', @@index, "-#{slot}", value
      end
    end
  end

  def window
    @@id
  end

  def window=(value)
    tk_call @@t.path, 'window', 'configure', @@index, '-window', value
    @@id = value
  end

  def create
    @@p_create
  end

  def create=(value)
    @@p_create = value
    if @@p_create.kind_of? Proc
      value = install_cmd(proc{@@id = @@p_create.call})
    end
    tk_call @@t.path, 'window', 'configure', @@index, '-create', value
  end

  def configinfo(slot = nil)
    if slot
      case slot.to_s
      when 'text', 'label', 'show', 'data', 'file'
	conf = tk_split_simplelist(tk_call(@@t.path, 'window', 'configure', 
					   @@index, "-#{slot}"))
      else
	conf = tk_split_list(tk_call(@@t.path, 'window', 'configure', 
				     @@index, "-#{slot}"))
      end
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_simplelist(tk_call(@@t.path, 'window', 'configure', 
				  @@index)).collect{|conflist|
	conf = tk_split_simplelist(conflist)
	conf[0] = conf[0][1..-1]
	case conf[0]
	when 'text', 'label', 'show', 'data', 'file'
	else
	  if conf[3]
	    if conf[3].index('{')
	      conf[3] = tk_split_list(conf[3]) 
	    else
	      conf[3] = tk_tcl2ruby(conf[3]) 
	    end
	  end
	  if conf[4]
	    if conf[4].index('{')
	      conf[4] = tk_split_list(conf[4]) 
	    else
	      conf[4] = tk_tcl2ruby(conf[4]) 
	    end
	  end
	end
	conf
      }
    end
  end

end

class TkTextImage<TkObject
  def initialize(parent, index, keys)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    if index == 'end'
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
    elsif index.kind_of? TkTextMark
      if tk_call(@@t.path,'index',index.path) == tk_call(@@t.path,'index','end')
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
      else
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index.path))
      end
    else
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index))
    end
    @@path.gravity = 'left'
    @@index = @@path.path
    @@id = tk_call(@@t.path, 'image', 'create', @@index, *hash_kv(keys))
  end

  def [](slot)
    cget(slot)
  end
  def []=(slot, value)
    configure(slot, value)
  end

  def cget(slot)
    case slot.to_s
    when 'text', 'label', 'show', 'data', 'file'
      tk_call @@t.path, 'image', 'cget', @@index, "-#{slot}"
    else
      tk_tcl2ruby tk_call(@@t.path, 'image', 'cget', @@index, "-#{slot}")
    end
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      tk_call @@t.path, 'image', 'configure', @@index, *hash_kv(slot)
    else
      tk_call @@t.path, 'image', 'configure', @@index, "-#{slot}", value
    end
  end
#  def configure(slot, value)
#    tk_call @@t.path, 'image', 'configure', @@index, "-#{slot}", value
#  end

  def image
    tk_call @@t.path, 'image', 'configure', @@index, '-image'
  end

  def image=(value)
    tk_call @@t.path, 'image', 'configure', @@index, '-image', value
  end

  def configinfo(slot = nil)
    if slot
      case slot.to_s
      when 'text', 'label', 'show', 'data', 'file'
	conf = tk_split_simplelist(tk_call(@@t.path, 'image', 'configure', 
					   @@index, "-#{slot}"))
      else
	conf = tk_split_list(tk_call(@@t.path, 'image', 'configure', 
				     @@index, "-#{slot}"))
      end
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_simplelist(tk_call(@@t.path, 'image', 'configure', 
				  @@index)).collect{|conflist|
	conf = tk_split_simplelist(conflist)
	conf[0] = conf[0][1..-1]
	case conf[0]
	when 'text', 'label', 'show', 'data', 'file'
	else
	  if conf[3]
	    if conf[3].index('{')
	      conf[3] = tk_split_list(conf[3]) 
	    else
	      conf[3] = tk_tcl2ruby(conf[3]) 
	    end
	  end
	  if conf[4]
	    if conf[4].index('{')
	      conf[4] = tk_split_list(conf[4]) 
	    else
	      conf[4] = tk_tcl2ruby(conf[4]) 
	    end
	  end
	end
	conf
      }
    end
  end
end
@


1.20
log
@* re.c (rb_reg_expr_str): need to process backslashes properly.

* object.c (rb_any_to_a): declare Object#to_a to be obsolete.

* object.c (rb_Array): do not convert nil into [] automagically.

* object.c (rb_Integer): use "to_int" instead of
  "to_i". [experimental]

* object.c (nil_to_f): new method.

* object.c (rb_Integer): Symbols and nil should cause error.

* object.c (rb_Float): nil should cause error.
@
text
@d3 1
a3 1
#			$Date: 2002/06/04 07:03:33 $
d688 1
a688 1
    TTagID_TBL[@@tpath][@@id] = nil if CTagID_TBL[@@tpath]
@


1.19
log
@* tkfont.rb:  Fix bugs on TkFont.init_widget_font for Tk8.x.

* tkafter.rb: Add self to 1st argument of interval- and loop-proc
    TkAfter#current_interval returns an interval (sleep) time value
    TkAfter#current_args returns an array of arguments
    TkAfter#return_value returns a return value of last loop-proc
      e.g.
         TkAfter.new(
           proc{|obj| 500 - obj.current_interval}, 10,
           [proc{|obj| p obj.current_args}, 'proc', 1],
           proc{|obj| p obj.current_args; ['return', 2]},
           [proc{|obj|
              p obj.return_value
              p ['proc', obj.current_args[0].call(obj.return_value[1],
                                                  obj.current_args[1])]},
            proc{|*args| args[0] + args[1]}, 1],
           proc{p ['proc', 4]} ).start(100)

* tk*.rb: Allow to use Symbols for parameters.
    Allow new notation of constructor (also allow old notation).
      e.g.
        TkFrame.new('classname'=>'User'){|base|
          pack
          f = TkFrame.new(base, :classname=>'ButtonFrame').pack
          TkButton.new(
             :parent     => f,
             :text       => 'Quit',
             :command    => proc{exit}
          ).pack(
             :fill => :x,
             :pady => 2
          )
        }

* tkcanvas.rb: (TkcItem) Add 'coords' parameter to the canvas item
    constructor (for new notation of constructor).
      e.g.
        c = TkCanvas.new.pack
        l = TkcLine.new(c, :coords=>[[0,0], [100,100]])

* tcltklib.c: New 'mainloop' and 'mainloop_watchdog'.
    The priority of their event-loop can be controlled.
    They accept an optional argument.
    If it false, they don't exit although the root widget is destroyed.
    This function is sometimes useful, if it is used with 'restart'.
    'mainloop' can't treat Thread#join/value in a callback routine.
    (e.g. TkButton.new(:command=>proc{p Thread.new{button.invoke}.value}) )
    'mainloop_watchdog' can treat them, but watchdog thread is always running
    (so, a little heavier than 'mainloop').
    If the purpose of using Thread#join/value is to do something under some
    safe-level, please use Proc object.
    (e.g. :command=>proc{$SAFE=1;proc{$SAFE=2;button.invoke}.call;p $SAFE})

* tk.rb: Support functions of new 'mainloop' and 'mainloop_watchdog'.

* tk.rb: (Tk.restart) Add 'app-name' paramater and 'use' parameter.
    'app-name' specifies the name and the resource class of the
    application. If 'app-name' is specified to 'xxx', the application
    class on the resource database is set to 'Xxx' and the application
    name is changed by the same rule of Tk.appname method.  'use'
    specifies the main window for embedding the root widget instead of
    generating a new window.

* tk.rb: Add new parameter 'widgetname' to the widget constructor to
    support effective use of Resource Database.  For example, the
    resource 'Xxx*quit.text: QUIT' can set the text of the button
    generated by the following code.
      e.g.
        Tk.restart('Xxx')
        TkButton.new(nil, 'widgetname'=>'quit', 'command'=>proc{exit}).pack
        Tk.mainloop

* tk.rb: TkOption::get always returns a tainted string.
    Add TkOption::new_proc_class.
    It generates a class to import procedures defined on the resource
    database. For example, there is a following resource file.
      ----< resource-test >------------
      *CMD.foo: {|*args| p [$SAFE, :foo, args]}
      *CMD.XXX.bar: {|*args| p [$SAFE, :bar, args]}
      *Button.command: ruby {p self; p $SAFE; TkOption::CMD::XXX.bar(1,2,3)}
      ---------------------------------
    The following code is a sample of use of the resource file.
      e.g.
        require 'tk'
        TkOption.readfile 'resource-test'
        p TkOption.new_proc_class(:CMD, [:foo], 1)
        p TkOption.new_proc_class(:XXX, [:bar], 2, false, TkOption::CMD)
        TkButton.new(:text=>'test').pack
        Tk.mainloop
@
text
@d3 1
a3 1
#			$Date: 2002/03/08 07:03:07 $
d192 1
a192 1
      tk_tcl2ruby tk_call @@path, 'tag', 'cget', tag, "-#{key}"
d639 1
a639 1
      tk_tcl2ruby tk_call @@t.path, 'tag', 'cget', @@id, "-#{key}"
d857 1
a857 1
      tk_tcl2ruby tk_call @@t.path, 'window', 'cget', @@index, "-#{slot}"
d907 2
a908 2
	conf = tk_split_simplelist(tk_call @@t.path, 'window', 'configure', 
				   @@index, "-#{slot}")
d910 2
a911 2
	conf = tk_split_list(tk_call @@t.path, 'window', 'configure', 
			     @@index, "-#{slot}")
d916 2
a917 2
      tk_split_simplelist(tk_call @@t.path, 'window', 'configure', 
			  @@index).collect{|conflist|
d979 1
a979 1
      tk_tcl2ruby tk_call @@t.path, 'image', 'cget', @@index, "-#{slot}"
d1006 2
a1007 2
	conf = tk_split_simplelist(tk_call @@t.path, 'image', 'configure', 
				   @@index, "-#{slot}")
d1009 2
a1010 2
	conf = tk_split_list(tk_call @@t.path, 'image', 'configure', 
			     @@index, "-#{slot}")
d1015 2
a1016 2
      tk_split_simplelist(tk_call @@t.path, 'image', 'configure', 
			  @@index).collect{|conflist|
@


1.18
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.

* class.c (rb_mod_clone): should not call rb_obj_clone(), since
  Module does not provide "allocate".

* class.c (rb_singleton_class): should crate new singleton class
  if obj is a class or module and attached object is different,
  which means metaclass of singleton class is sought.

* time.c (time_s_alloc): now follows allocation framework.

* eval.c (rb_eval): should initialize outer class variables from
  methods in singleton class definitions.

* eval.c (assign): ditto.
@
text
@d3 1
a3 1
#			$Date: 2002/02/28 06:53:33 $
d188 1
a188 1
    case key
d198 1
d201 1
a201 1
	tagfont_configure(tag, key.dup)
d207 4
a210 2
      if  key == 'font' || key == 'kanjifont' ||
	  key == 'latinfont' || key == 'asciifont'
d220 1
a220 1
      case key
d555 1
d558 6
d569 1
d571 3
d635 1
a635 1
    case key
d688 25
d834 1
d853 1
a853 1
    case slot
d863 1
d873 2
a874 2
      @@id = value if slot == 'window'
      if slot == 'create'
d905 1
a905 1
      case slot
d975 1
a975 1
    case slot
d1004 1
a1004 1
      case slot
@


1.17
log
@* eval.c (rb_mod_include): load modules in argument order.

* st.c (st_init_table_with_size): num_bins should be prime numbers
  (no decrement).

* st.c (rehash): ditto.
@
text
@d3 1
a3 1
#			$Date: 2002/01/28 08:44:43 $
d41 1
a41 1
    obj.instance_eval &block if defined? yield
@


1.16
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.

* object.c (Init_Object): remove dup and clone from TrueClass,
  FalseClass, and NilClass.

* array.c (rb_ary_fill): Array#fill takes block to get the value to
  fill.

* string.c (rb_str_to_i): to_i(0) auto-detects base radix.

* array.c (rb_ary_initialize): fill by the block evaluation value
  if block is given.
@
text
@d3 1
a3 1
#			$Date: 2001/09/05 06:54:57 $
d10 1
a10 38
  def tagfont_configinfo(tag)
    if tag.kind_of? TkTextTag
      pathname = self.path + ';' + tag.id
    else
      pathname = self.path + ';' + tag
    end
    ret = TkFont.used_on(pathname)
    if ret == nil
      ret = TkFont.init_widget_font(pathname, 
				    self.path, 'tag', 'configure', tag)
    end
    ret
  end
  alias tagfontobj tagfont_configinfo

  def tagfont_configure(tag, slot)
    if tag.kind_of? TkTextTag
      pathname = self.path + ';' + tag.id
    else
      pathname = self.path + ';' + tag
    end
    if (fnt = slot.delete('font'))
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(pathname, 
				       self.path,'tag','configure',tag,slot)
      else
	latintagfont_configure(tag, fnt) if fnt
      end
    end
    if (ltn = slot.delete('latinfont'))
      latintagfont_configure(tag, ltn) if ltn
    end
    if (ltn = slot.delete('asciifont'))
      latintagfont_configure(tag, ltn) if ltn
    end
    if (knj = slot.delete('kanjifont'))
      kanjitagfont_configure(tag, knj) if knj
    end
d12 3
a14 2
    tk_call(self.path, 'tag', 'configure', tag, *hash_kv(slot)) if slot != {}
    self
d17 3
a19 13
  def latintagfont_configure(tag, ltn, keys=nil)
    fobj = tagfontobj(tag)
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.latin_replace(ltn)
	fobj.latin_configure(keys) if keys
      elsif keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
d21 1
a21 53
      fobj.latin_replace(ltn)
    end
  end
  alias asciitagfont_configure latintagfont_configure

  def kanjitagfont_configure(tag, knj, keys=nil)
    fobj = tagfontobj(tag)
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.kanji_replace(knj)
	fobj.kanji_configure(keys) if keys
      elsif keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(conf)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def tagfont_copy(tag, window, wintag=nil)
    if wintag
      window.tagfontobj(wintag).configinfo.each{|key,value|
	tagfontobj(tag).configure(key,value)
      }
      tagfontobj(tag).replace(window.tagfontobj(wintag).latin_font, 
			      window.tagfontobj(wintag).kanji_font)
    else
      window.tagfont(wintag).configinfo.each{|key,value|
	tagfontobj(tag).configure(key,value)
      }
      tagfontobj(tag).replace(window.fontobj.latin_font, 
			      window.fontobj.kanji_font)
    end
  end

  def latintagfont_copy(tag, window, wintag=nil)
    if wintag
      tagfontobj(tag).latin_replace(window.tagfontobj(wintag).latin_font)
    else
      tagfontobj(tag).latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciitagfont_copy latintagfont_copy

  def kanjitagfont_copy(tag, window, wintag=nil)
    if wintag
      tagfontobj(tag).kanji_replace(window.tagfontobj(wintag).kanji_font)
    else
      tagfontobj(tag).kanji_replace(window.fontobj.kanji_font)
d27 1
d49 6
a54 2
  def create_self
    tk_call 'text', @@path
d208 1
a208 1
	tagfont_configure({key=>val})
@


1.15
log
@* re.c (Init_Regexp): to_s to be alias to inspect.

* parse.y (yylex): should support 'keyword='.

* ruby.c (proc_options): should not adjust argc/argv if -e option
  is supplied.
@
text
@d3 1
a3 1
#			$Date: 2001/03/27 07:09:27 $
d816 6
a821 2
  def next(index)
    @@t.tagid2obj(tk_call(@@t.path, 'mark', 'next', index))
d824 6
a829 2
  def previous(index)
    @@t.tagid2obj(tk_call(@@t.path, 'mark', 'previous', index))
@


1.14
log
@* eval.c (rb_mod_define_method): should have clear method cache.

* eval.c (rb_mod_define_method): should have raised exception for
  type error.

* ruby.h: changed "extern INLINE" to "static inline".
@
text
@d3 1
a3 1
#			$Date: 2000/11/27 09:23:36 $
d282 1
a282 1
    when 'text', 'label', 'show', 'data', 'flie'
d311 1
a311 1
      when 'text', 'label', 'show', 'data', 'flie'
d323 1
a323 1
	when 'text', 'label', 'show', 'data', 'flie'
d715 1
a715 1
    when 'text', 'label', 'show', 'data', 'flie'
d899 1
a899 1
    when 'text', 'label', 'show', 'data', 'flie'
d950 1
a950 1
      when 'text', 'label', 'show', 'data', 'flie'
d965 1
a965 1
	when 'text', 'label', 'show', 'data', 'flie'
d1020 1
a1020 1
    when 'text', 'label', 'show', 'data', 'flie'
d1049 1
a1049 1
      when 'text', 'label', 'show', 'data', 'flie'
d1064 1
a1064 1
	when 'text', 'label', 'show', 'data', 'flie'
@


1.13
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/08/02 04:54:21 $
d190 8
@


1.13.2.1
log
@* eval.c (rb_mod_define_method): should have clear method cache.

* eval.c (rb_mod_define_method): should have raised exception for
  type error.

* ruby.h: changed "extern INLINE" to "static inline".
@
text
@d3 1
a3 1
#			$Date: 2000/11/27 09:23:36 $
a189 8
  end

  def mark_next(index)
    tagid2obj(tk_send('mark', 'next', index))
  end

  def mark_previous(index)
    tagid2obj(tk_send('mark', 'previous', index))
@


1.13.2.2
log
@* ruby.c (proc_options): should not adjust argc/argv if -e option
  is supplied.
@
text
@d3 1
a3 1
#			$Date: 2001/03/27 07:10:58 $
d282 1
a282 1
    when 'text', 'label', 'show', 'data', 'file'
d311 1
a311 1
      when 'text', 'label', 'show', 'data', 'file'
d323 1
a323 1
	when 'text', 'label', 'show', 'data', 'file'
d715 1
a715 1
    when 'text', 'label', 'show', 'data', 'file'
d899 1
a899 1
    when 'text', 'label', 'show', 'data', 'file'
d950 1
a950 1
      when 'text', 'label', 'show', 'data', 'file'
d965 1
a965 1
	when 'text', 'label', 'show', 'data', 'file'
d1020 1
a1020 1
    when 'text', 'label', 'show', 'data', 'file'
d1049 1
a1049 1
      when 'text', 'label', 'show', 'data', 'file'
d1064 1
a1064 1
	when 'text', 'label', 'show', 'data', 'file'
@


1.13.2.3
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.
@
text
@d3 1
a3 1
#			$Date: 2001/09/05 06:53:31 $
d816 2
a817 6
  def next(index = nil)
    if index
      @@t.tagid2obj(tk_call(@@t.path, 'mark', 'next', index))
    else
      @@t.tagid2obj(tk_call(@@t.path, 'mark', 'next', @@id))
    end
d820 2
a821 6
  def previous(index = nil)
    if index
      @@t.tagid2obj(tk_call(@@t.path, 'mark', 'previous', index))
    else
      @@t.tagid2obj(tk_call(@@t.path, 'mark', 'previous', @@id))
    end
@


1.13.2.4
log
@* st.c (st_init_table_with_size): num_bins should be prime numbers
  (no decrement).

* st.c (rehash): ditto.
@
text
@d3 1
a3 1
#			$Date: 2002/01/28 08:42:40 $
d10 38
a47 1
  include TkTreatItemFont
d49 2
a50 3
  ItemCMD = ['tag', 'configure']
  def __conf_cmd(idx)
    ItemCMD[idx]
d53 13
a65 3
  def __item_pathname(tagOrId)
    if tagOrId.kind_of?(TkTextTag)
      self.path + ';' + tagOrId.id
d67 53
a119 1
      self.path + ';' + tagOrId
a124 1
  ItemConfCMD = ['tag', 'configure']
d146 2
a147 6
  def create_self(keys)
    if keys and keys != None
      tk_call 'text', @@path, *hash_kv(keys)
    else
      tk_call 'text', @@path
    end
d301 1
a301 1
	tagfont_configure(tag, {key=>val})
@


1.13.2.5
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.
@
text
@d3 1
a3 1
#			$Date: 2002/02/28 06:52:49 $
d41 1
a41 1
    obj.instance_eval(&block) if defined? yield
@


1.12
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/08/01 09:25:36 $
d273 6
a278 1
    tk_tcl2ruby tk_call @@path, 'tag', 'cget', tag, "-#{key}"
d302 6
a307 1
      conf = tk_split_list(tk_send('tag','configure',tag,"-#{key}"))
d311 2
a312 1
      tk_split_list(tk_send('tag', 'configure', tag)).collect{|conf|
d314 18
d706 6
a711 1
    tk_tcl2ruby tk_call @@t.path, 'tag', 'cget', @@id, "-#{key}"
d890 6
a895 1
    tk_tcl2ruby tk_call @@t.path, 'window', 'cget', @@index, "-#{slot}"
d941 8
a948 2
      conf = tk_split_list(tk_call @@t.path, 'window', 'configure', 
			   @@index, "-#{slot}")
d952 3
a954 2
      tk_split_list(tk_call @@t.path, 'window', 'configure', 
		    @@index).collect{|conf|
d956 18
d1011 6
a1016 1
    tk_tcl2ruby tk_call @@t.path, 'image', 'cget', @@index, "-#{slot}"
d1040 8
a1047 2
      conf = tk_split_list(tk_call @@t.path, 'image', 'configure', 
			   @@index, "-#{slot}")
d1051 3
a1053 2
      tk_split_list(tk_call @@t.path, 'image', 'configure', 
		    @@index).collect{|conf|
d1055 18
@


1.11
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/05/24 04:34:22 $
d337 19
d357 1
a357 1
    pat = pat.char if pat.kind_of? Integer
d362 3
a364 1
	pos = txt[0..(pos-1)].split('').length if pos > 0
d366 3
a368 1
	  return [index(start + " + #{pos} chars"), pat.split('').length]
d370 3
a372 1
	  return [index(start + " + #{pos} chars"), $&.split('').length]
d380 3
a382 1
	pos = txt[0..(pos-1)].split('').length if pos > 0
d384 3
a386 1
	  return [index(start + " + #{pos} chars"), pat.split('').length]
d388 3
a390 1
	  return [index(start + " + #{pos} chars"), $&.split('').length]
d395 3
a397 1
	  pos = txt[0..(pos-1)].split('').length if pos > 0
d399 3
a401 1
	    return [index("1.0 + #{pos} chars"), pat.split('').length]
d403 2
a404 1
	    return [index("1.0 + #{pos} chars"), $&.split('').length]
d418 1
a418 1
    pat = pat.char if pat.kind_of? Integer
d423 3
a425 1
	pos = txt[0..(pos-1)].split('').length if pos > 0
d427 2
a428 1
	  return [index(stop + " + #{pos} chars"), pat.split('').length]
d430 2
a431 1
	  return [index(stop + " + #{pos} chars"), $&.split('').length]
d439 3
a441 1
	pos = txt[0..(pos-1)].split('').length if pos > 0
d443 2
a444 1
	  return [index("1.0 + #{pos} chars"), pat.split('').length]
d446 2
a447 1
	  return [index("1.0 + #{pos} chars"), $&.split('').length]
d452 3
a454 1
	  pos = txt[0..(pos-1)].split('').length if pos > 0
d456 2
a457 1
	    return [index("1.0 + #{pos} chars"), pat.split('').length]
d459 2
a460 1
	    return [index("1.0 + #{pos} chars"), $&.split('').length]
@


1.10
log
@2000-05-24
@
text
@d3 1
a3 1
#			$Date: 2000/05/01 09:41:37 $
d463 1
a463 1
	    result.push tk_tcl2rb(val)
d473 1
a473 1
	    result.push tk_tcl2rb val
d476 1
a476 1
	    result.push tk_tcl2rb sel
d478 1
a478 1
	  result.push tk_tcl2rb val
@


1.9
log
@2000-05-01
@
text
@d3 1
a3 1
#			$Date: 2000/04/10 05:57:37 $
a247 3
  def yview(*what)
    tk_send 'yview', *what
  end
a251 3
  def xview(*what)
    tk_send 'xview', *what
  end
@


1.8
log
@2000-04-10
@
text
@d3 1
a3 1
#			$Date: 2000/04/10 05:44:25 $
d431 3
a433 9
  def dump(type_info, *index)
    args = type_info.collect{|inf|
                 if inf.kind_of? Array
                   inf[0] = '-' + inf[0]
                   inf
                 else
                   '-' + inf
                 end
               }.flatten
d543 2
a544 2
  def dump_all(*index)
    dump(['all'], *index)
d546 2
a547 2
  def dump_command(cmd, *index)
    dump([['command', cmd]], *index)
d549 2
a550 2
  def dump_mark(*index)
    dump(['mark'], *index)
d552 2
a553 2
  def dump_tag(*index)
    dump(['tag'], *index)
d555 2
a556 2
  def dump_text(*index)
    dump(['text'], *index)
d558 2
a559 5
  def dump_window(*index)
    dump(['window'], *index)
  end
  def dump_image(*index)
    dump(['image'], *index)
@


1.7
log
@2000-04-10
@
text
@d3 1
a3 1
#			$Date: 2000/03/23 04:14:28 $
d431 10
a440 2
  def _dump(type, *index)
    str = tk_send('dump', type, *index)
d512 36
a547 1
  private :_dump
d550 4
a553 1
    _dump('-all', *index)
d556 1
a556 1
    _dump('-mark', *index)
d559 1
a559 1
    _dump('-tag', *index)
d562 1
a562 1
    _dump('-text', *index)
d565 4
a568 1
    _dump('-window', *index)
a569 1

a880 36

  def _retrieve_braced_text(str, i)
    cnt = 0
    idx = i
    while idx < str.size
      case str[idx]
      when ?{
	cnt += 1
      when ?}
	cnt -= 1
	if cnt == 0
	  break
	end
      end
      idx += 1
    end
    return str[i+1..idx-1], idx + 2
  end
  private :_retrieve_braced_text

  def _retrieve_backslashed_text(str, i)
    j = i
    idx = nil
    loop {
      idx = str.index(/ /, j)
      if str[idx-1] == ?\\
	j += 1
      else
	break
      end
    }
    val = str[i..(idx-1)]
    val.gsub!(/\\( |\{|\})/, '\1')
    return val, idx + 1
  end
  private :_retrieve_backslashed_text
@


1.6
log
@2000-03-17
@
text
@d3 1
a3 1
#			$Date: 2000/01/17 08:37:52 $
d430 92
a833 75
  def _dump(type, *index)
    str = tk_send('dump', type, *index)
    result = []
    sel = nil
    i = 0
    while i < str.size
      # retrieve key
      idx = str.index(/ /, i)
      result.push str[i..(idx-1)]
      i = idx + 1
      
      # retrieve value
      case result[-1]
      when 'text'
	if str[i] == ?{
	  # text formed as {...}
	  val, i = _retrieve_braced_text(str, i)
	  result.push val
	else
	  # text which may contain backslahes
	  val, i = _retrieve_backslashed_text(str, i)
	  result.push val
	end
      else
	idx = str.index(/ /, i)
	val = str[i..(idx-1)]
	case result[-1]
	when 'mark'
	  case val
	  when 'insert'
	    result.push TkTextMarkInsert.new(self)
	  when 'current'
	    result.push TkTextMarkCurrent.new(self)
	  when 'anchor'
	    result.push TkTextMarkAnchor.new(self)
	  else
	    result.push tk_tcl2rb(val)
	  end
	when 'tagon'
	  if val == 'sel'
	    if sel
	      result.push sel
	    else
	      result.push TkTextTagSel.new(self)
	    end
	  else
	    result.push tk_tcl2rb val
	  end
	when 'tagoff'
	    result.push tk_tcl2rb sel
	when 'window'
	  result.push tk_tcl2rb val
	end
	i = idx + 1
      end

      # retrieve index
      idx = str.index(/ /, i)
      if idx
	result.push str[i..(idx-1)]
	i = idx + 1
      else
	result.push str[i..-1]
	break
      end
    end
    
    kvis = []
    until result.empty?
      kvis.push [result.shift, result.shift, result.shift]
    end
    kvis  # result is [[key1, value1, index1], [key2, value2, index2], ...]
  end
  private :_dump

a869 15
  def dump_all(*index)
    _dump('-all', *index)
  end
  def dump_mark(*index)
    _dump('-mark', *index)
  end
  def dump_tag(*index)
    _dump('-tag', *index)
  end
  def dump_text(*index)
    _dump('-text', *index)
  end
  def dump_window(*index)
    _dump('-window', *index)
  end
@


1.5
log
@2000-01-17
@
text
@d3 1
a3 1
#			$Date: 2000/01/05 04:37:21 $
d135 1
a135 1
  def self.new(*args)
@


1.4
log
@20000105
@
text
@d3 1
a3 1
#			$Date: 1999/08/24 08:21:56 $
d126 1
d130 1
d134 12
a145 1
  include Scrollable
d148 1
a148 1
    @@tags = {}
d150 1
d154 1
d158 1
d163 1
d167 1
d185 7
d197 1
d207 1
d217 1
d435 2
a436 1
  $tk_text_tag = 'tag0000'
d442 2
a443 2
    @@path = @@id = $tk_text_tag
    $tk_text_tag = $tk_text_tag.succ
d569 1
a569 1
  $tk_text_mark = 'mark0000'
d575 2
a576 2
    @@path = @@id = $tk_text_mark
    $tk_text_mark = $tk_text_mark.succ
d599 8
@


1.3
log
@1.4.1 to be
@
text
@d3 1
a3 1
#			$Date: 1999/08/13 05:37:52 $
d31 1
a31 2
    if (fnt = slot['font'])
      slot['font'] = nil
d39 1
a39 2
    if (ltn = slot['latinfont'])
      slot['latinfont'] = nil
d42 1
a42 2
    if (ltn = slot['asciifont'])
      slot['asciifont'] = nil
d45 1
a45 2
    if (knj = slot['kanjifont'])
      slot['kanjifont'] = nil
@


1.3.2.1
log
@20000105
@
text
@d3 1
a3 1
#			$Date: 1999/08/24 08:21:56 $
d31 2
a32 1
    if (fnt = slot.delete('font'))
d40 2
a41 1
    if (ltn = slot.delete('latinfont'))
d44 2
a45 1
    if (ltn = slot.delete('asciifont'))
d48 2
a49 1
    if (knj = slot.delete('kanjifont'))
@


1.3.2.2
log
@2000-01-17
@
text
@d3 1
a3 1
#			$Date: 2000/01/05 04:37:21 $
a125 1
  include Scrollable
a128 1

d132 1
a132 12

  def self.new(*args)
    obj = super(*args){}
    obj.init_instance_variable
    obj.instance_eval &block if defined? yield
    obj
  end

  def init_instance_variable
    @@tags = {}
  end

d135 1
a135 1
    init_instance_variable
a136 1

a139 1

a142 1

a146 1

a149 1

a166 7

  def mark_names
    tk_split_list(tk_send('mark', 'names')).collect{|elt|
      tagid2obj(elt)
    }
  end

a171 1

a180 1

a189 1
    @@tags = {} unless @@tags
d407 1
a407 2
  Tk_TextTag_ID = ['tag0000']

d413 2
a414 2
    @@path = @@id = Tk_TextTag_ID[0]
    Tk_TextTag_ID[0] = Tk_TextTag_ID[0].succ
d540 1
a540 1
  Tk_TextMark_ID = ['mark0000']
d546 2
a547 2
    @@path = @@id = Tk_TextMark_ID[0]
    Tk_TextMark_ID[0] = Tk_TextMark_ID[0].succ
a569 8
  end

  def next(index)
    @@t.tagid2obj(tk_call(@@t.path, 'mark', 'next', index))
  end

  def previous(index)
    @@t.tagid2obj(tk_call(@@t.path, 'mark', 'previous', index))
@


1.3.2.3
log
@2000-03-23
@
text
@d3 1
a3 1
#			$Date: 2000/01/17 08:24:19 $
d135 1
a135 1
  def self.new(*args, &block)
@


1.3.2.4
log
@2000-04-10
@
text
@d3 1
a3 1
#			$Date: 2000/03/23 04:14:28 $
a429 92

  def _dump(type, *index)
    str = tk_send('dump', type, *index)
    result = []
    sel = nil
    i = 0
    while i < str.size
      # retrieve key
      idx = str.index(/ /, i)
      result.push str[i..(idx-1)]
      i = idx + 1
      
      # retrieve value
      case result[-1]
      when 'text'
	if str[i] == ?{
	  # text formed as {...}
	  val, i = _retrieve_braced_text(str, i)
	  result.push val
	else
	  # text which may contain backslahes
	  val, i = _retrieve_backslashed_text(str, i)
	  result.push val
	end
      else
	idx = str.index(/ /, i)
	val = str[i..(idx-1)]
	case result[-1]
	when 'mark'
	  case val
	  when 'insert'
	    result.push TkTextMarkInsert.new(self)
	  when 'current'
	    result.push TkTextMarkCurrent.new(self)
	  when 'anchor'
	    result.push TkTextMarkAnchor.new(self)
	  else
	    result.push tk_tcl2rb(val)
	  end
	when 'tagon'
	  if val == 'sel'
	    if sel
	      result.push sel
	    else
	      result.push TkTextTagSel.new(self)
	    end
	  else
	    result.push tk_tcl2rb val
	  end
	when 'tagoff'
	    result.push tk_tcl2rb sel
	when 'window'
	  result.push tk_tcl2rb val
	end
	i = idx + 1
      end

      # retrieve index
      idx = str.index(/ /, i)
      if idx
	result.push str[i..(idx-1)]
	i = idx + 1
      else
	result.push str[i..-1]
	break
      end
    end
    
    kvis = []
    until result.empty?
      kvis.push [result.shift, result.shift, result.shift]
    end
    kvis  # result is [[key1, value1, index1], [key2, value2, index2], ...]
  end
  private :_dump

  def dump_all(*index)
    _dump('-all', *index)
  end
  def dump_mark(*index)
    _dump('-mark', *index)
  end
  def dump_tag(*index)
    _dump('-tag', *index)
  end
  def dump_text(*index)
    _dump('-text', *index)
  end
  def dump_window(*index)
    _dump('-window', *index)
  end

d742 75
d853 15
@


1.3.2.5
log
@2000-04-10
@
text
@d3 1
a3 1
#			$Date: 2000/04/10 05:44:25 $
d431 2
a432 10
  def dump(type_info, *index)
    args = type_info.collect{|inf|
                 if inf.kind_of? Array
                   inf[0] = '-' + inf[0]
                   inf
                 else
                   '-' + inf
                 end
               }.flatten
    str = tk_send('dump', *(args + index))
d504 1
a504 36

  def _retrieve_braced_text(str, i)
    cnt = 0
    idx = i
    while idx < str.size
      case str[idx]
      when ?{
	cnt += 1
      when ?}
	cnt -= 1
	if cnt == 0
	  break
	end
      end
      idx += 1
    end
    return str[i+1..idx-1], idx + 2
  end
  private :_retrieve_braced_text

  def _retrieve_backslashed_text(str, i)
    j = i
    idx = nil
    loop {
      idx = str.index(/ /, j)
      if str[idx-1] == ?\\
	j += 1
      else
	break
      end
    }
    val = str[i..(idx-1)]
    val.gsub!(/\\( |\{|\})/, '\1')
    return val, idx + 1
  end
  private :_retrieve_backslashed_text
d507 1
a507 4
    dump(['all'], *index)
  end
  def dump_command(cmd, *index)
    dump([['command', cmd]], *index)
d510 1
a510 1
    dump(['mark'], *index)
d513 1
a513 1
    dump(['tag'], *index)
d516 1
a516 1
    dump(['text'], *index)
d519 1
a519 4
    dump(['window'], *index)
  end
  def dump_image(*index)
    dump(['image'], *index)
d521 1
d833 36
@


1.3.2.6
log
@2000-05-01
@
text
@d3 1
a3 1
#			$Date: 2000/04/10 05:56:59 $
d431 9
a439 3
  def dump(type_info, *index, &block)
    args = type_info.collect{|inf| '-' + inf}
    args << '-command' << Proc.new(&block) if iterator?
d549 2
a550 2
  def dump_all(*index, &block)
    dump(['all'], *index, &block)
d552 2
a553 2
  def dump_mark(*index, &block)
    dump(['mark'], *index, &block)
d555 2
a556 2
  def dump_tag(*index, &block)
    dump(['tag'], *index, &block)
d558 2
a559 2
  def dump_text(*index, &block)
    dump(['text'], *index, &block)
d561 2
a562 2
  def dump_window(*index, &block)
    dump(['window'], *index, &block)
d564 5
a568 2
  def dump_image(*index, &block)
    dump(['image'], *index, &block)
@


1.3.2.7
log
@000623
@
text
@d3 1
a3 1
#			$Date: 2000/05/01 09:42:37 $
d248 3
d255 3
@


1.3.2.8
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/06/23 08:38:45 $
d463 1
a463 1
	    result.push tk_tcl2ruby(val)
d473 1
a473 1
	    result.push tk_tcl2ruby(val)
d476 1
a476 1
	    result.push tk_tcl2ruby(sel)
d478 1
a478 1
	  result.push tk_tcl2ruby(val)
@


1.3.2.9
log
@matz
@
text
@d3 1
a3 1
#			$Date: 2000/08/01 06:27:35 $
a336 19
  def _ktext_length(txt)
    if $KCODE !~ /n/i
      return txt.gsub(/[^\Wa-zA-Z_\d]/, ' ').length
    end

    # $KCODE == 'NONE'
    if JAPANIZED_TK
      tk_call('kstring', 'length', txt).to_i
    else
      begin
	tk_call('encoding', 'convertto', 'ascii', txt).length
      rescue StandardError, NameError
	# sorry, I have no plan
	txt.length
      end
    end
  end
  private :_ktext_length

d338 1
a338 1
    pat = pat.chr if pat.kind_of? Integer
d343 1
a343 3
	match = $&
	#pos = txt[0..(pos-1)].split('').length if pos > 0
	pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
d345 1
a345 3
	  #return [index(start + " + #{pos} chars"), pat.split('').length]
	  return [index(start + " + #{pos} chars"), 
		  _ktext_length(pat), pat.dup]
d347 1
a347 3
	  #return [index(start + " + #{pos} chars"), $&.split('').length]
	  return [index(start + " + #{pos} chars"), 
		  _ktext_length(match), match]
d355 1
a355 3
	match = $&
	#pos = txt[0..(pos-1)].split('').length if pos > 0
	pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
d357 1
a357 3
	  #return [index(start + " + #{pos} chars"), pat.split('').length]
	  return [index(start + " + #{pos} chars"), 
		  _ktext_length(pat), pat.dup]
d359 1
a359 3
	  #return [index(start + " + #{pos} chars"), $&.split('').length]
	  return [index(start + " + #{pos} chars"), 
		  _ktext_length(match), match]
d364 1
a364 3
	  match = $&
	  #pos = txt[0..(pos-1)].split('').length if pos > 0
	  pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
d366 1
a366 3
	    #return [index("1.0 + #{pos} chars"), pat.split('').length]
	    return [index("1.0 + #{pos} chars"), 
		    _ktext_length(pat), pat.dup]
d368 1
a368 2
	    #return [index("1.0 + #{pos} chars"), $&.split('').length]
	    return [index("1.0 + #{pos} chars"), _ktext_length(match), match]
d382 1
a382 1
    pat = pat.chr if pat.kind_of? Integer
d387 1
a387 3
	match = $&
	#pos = txt[0..(pos-1)].split('').length if pos > 0
	pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
d389 1
a389 2
	  #return [index(stop + " + #{pos} chars"), pat.split('').length]
	  return [index(stop + " + #{pos} chars"), _ktext_length(pat), pat.dup]
d391 1
a391 2
	  #return [index(stop + " + #{pos} chars"), $&.split('').length]
	  return [index(stop + " + #{pos} chars"), _ktext_length(match), match]
d399 1
a399 3
	match = $&
	#pos = txt[0..(pos-1)].split('').length if pos > 0
	pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
d401 1
a401 2
	  #return [index("1.0 + #{pos} chars"), pat.split('').length]
	  return [index("1.0 + #{pos} chars"), _ktext_length(pat), pat.dup]
d403 1
a403 2
	  #return [index("1.0 + #{pos} chars"), $&.split('').length]
	  return [index("1.0 + #{pos} chars"), _ktext_length(match), match]
d408 1
a408 3
	  match = $&
	  #pos = txt[0..(pos-1)].split('').length if pos > 0
	  pos = _ktext_length(txt[0..(pos-1)]) if pos > 0
d410 1
a410 2
	    #return [index("1.0 + #{pos} chars"), pat.split('').length]
	    return [index("1.0 + #{pos} chars"), _ktext_length(pat), pat.dup]
d412 1
a412 2
	    #return [index("1.0 + #{pos} chars"), $&.split('').length]
	    return [index("1.0 + #{pos} chars"), _ktext_length(match), match]
@


1.2
log
@remove marshal/gtk/kconv
@
text
@d3 1
a3 1
#			$Date: 1999/06/24 04:24:07 $
d132 1
a132 1
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
d238 1
a238 1
  def tag_add(tag,index1,index2=None)
a241 7
  def _tag_bind_core(mode, tag, seq, cmd=Proc.new, args=nil)
    id = install_bind(cmd, args)
    tk_send 'tag', 'bind', tag, "<#{tk_event_sequence(seq)}>", mode + id
    # _addcmd cmd
  end
  private :_tag_bind_core

d243 1
a243 1
    _tag_bind_core('', tag, seq, cmd, args=nil)
d247 1
a247 1
    _tag_bind_core('+', tag, seq, cmd, args=nil)
d251 1
a251 14
    if context
      (tk_send('tag', 'bind', tag, 
	       "<#{tk_event_sequence(context)}>")).collect{|cmdline|
	if cmdline =~ /^rb_out (c\d+)\s+(.*)$/
	  [Tk_CMDTBL[$1], $2]
	else
	  cmdline
	end
      }
    else
      tk_split_list(tk_send('tag', 'bind', tag)).filter{|seq|
	seq[1..-2].gsub(/></,',')
      }
    end
a503 12
#  def configinfo(key=nil)
#    if key
#      conf = tk_split_list(tk_call(@@t.path, 'tag','configure',@@id,"-#{key}"))
#      conf[0] = conf[0][1..-1]
#      conf
#    else
#      tk_split_list(tk_call(@@t.path, 'tag', 'configure', @@id)).collect{|conf|
#	conf[0] = conf[0][1..-1]
#	conf
#      }
#    end
#  end
d506 5
a510 3
    id = install_bind(cmd, args)
    tk_call @@t.path, 'tag', 'bind', @@id, "<#{tk_event_sequence(seq)}>", id
    # @@t._addcmd cmd
d514 1
a514 14
    if context
      (tk_call(@@t.path, 'tag', 'bind', @@id, 
	       "<#{tk_event_sequence(context)}>")).collect{|cmdline|
	if cmdline =~ /^rb_out (c\d+)\s+(.*)$/
	  [Tk_CMDTBL[$1], $2]
	else
	  cmdline
	end
      }
    else
      tk_split_list(tk_call(@@t.path, 'tag', 'bind', @@id)).filter{|seq|
	seq[1..-2].gsub(/></,',')
      }
    end
@


1.1
log
@file tktext.rb was initially added on branch v1_1r.
@
text
@d1 946
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@a0 797
#
#		tktext.rb - Tk text classes
#			$Date: 1998/11/17 09:12:44 $
#			by Yukihiro Matsumoto <matz@@caelum.co.jp>

require 'tk.rb'
require 'tkfont'

module TkTreatTextTagFont
  def tagfont_configinfo(tag)
    if tag.kind_of? TkTextTag
      pathname = self.path + ';' + tag.id
    else
      pathname = self.path + ';' + tag
    end
    ret = TkFont.used_on(pathname)
    if ret == nil
      ret = TkFont.init_widget_font(pathname, 
				    self.path, 'tag', 'configure', tag)
    end
    ret
  end
  alias tagfontobj tagfont_configinfo

  def tagfont_configure(tag, slot)
    if tag.kind_of? TkTextTag
      pathname = self.path + ';' + tag.id
    else
      pathname = self.path + ';' + tag
    end
    if (fnt = slot['font'])
      slot['font'] = nil
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(pathname, 
				       self.path,'tag','configure',tag,slot)
      else
	latintagfont_configure(tag, fnt) if fnt
      end
    end
    if (ltn = slot['latinfont'])
      slot['latinfont'] = nil
      latintagfont_configure(tag, ltn) if ltn
    end
    if (ltn = slot['asciifont'])
      slot['asciifont'] = nil
      latintagfont_configure(tag, ltn) if ltn
    end
    if (knj = slot['kanjifont'])
      slot['kanjifont'] = nil
      kanjitagfont_configure(tag, knj) if knj
    end

    tk_call(self.path, 'tag', 'configure', tag, *hash_kv(slot)) if slot != {}
    self
  end

  def latintagfont_configure(tag, ltn, keys=nil)
    fobj = tagfontobj(tag)
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.latin_replace(ltn)
	fobj.latin_configure(keys) if keys
      elsif keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciitagfont_configure latintagfont_configure

  def kanjitagfont_configure(tag, knj, keys=nil)
    fobj = tagfontobj(tag)
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.kanji_replace(knj)
	fobj.kanji_configure(keys) if keys
      elsif keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(conf)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def tagfont_copy(tag, window, wintag=nil)
    if wintag
      window.tagfontobj(wintag).configinfo.each{|key,value|
	tagfontobj(tag).configure(key,value)
      }
      tagfontobj(tag).replace(window.tagfontobj(wintag).latin_font, 
			      window.tagfontobj(wintag).kanji_font)
    else
      window.tagfont(wintag).configinfo.each{|key,value|
	tagfontobj(tag).configure(key,value)
      }
      tagfontobj(tag).replace(window.fontobj.latin_font, 
			      window.fontobj.kanji_font)
    end
  end

  def latintagfont_copy(tag, window, wintag=nil)
    if wintag
      tagfontobj(tag).latin_replace(window.tagfontobj(wintag).latin_font)
    else
      tagfontobj(tag).latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciitagfont_copy latintagfont_copy

  def kanjitagfont_copy(tag, window, wintag=nil)
    if wintag
      tagfontobj(tag).kanji_replace(window.tagfontobj(wintag).kanji_font)
    else
      tagfontobj(tag).kanji_replace(window.fontobj.kanji_font)
    end
  end
end

class TkText<TkTextWin
  include TkTreatTextTagFont

  WidgetClassName = 'Text'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end
  include Scrollable
  def create_self
    tk_call 'text', @@path
    @@tags = {}
  end
  def index(index)
    tk_send 'index', index
  end
  def value
    tk_send 'get', "1.0", "end - 1 char"
  end
  def value= (val)
    tk_send 'delete', "1.0", 'end'
    tk_send 'insert', "1.0", val
  end
  def _addcmd(cmd)
    @@cmdtbl.push cmd
  end
  def _addtag(name, obj)
    @@tags[name] = obj
  end

  def tagid2obj(tagid)
    if not @@tags[tagid]
      tagid
    else
      @@tags[tagid]
    end
  end

  def tag_names(index=None)
    tk_split_list(tk_send('tag', 'names', index)).collect{|elt|
      tagid2obj(elt)
    }
  end
  def window_names
    tk_send('window', 'names').collect{|elt|
      tagid2obj(elt)
    }
  end
  def image_names
    tk_send('image', 'names').collect{|elt|
      tagid2obj(elt)
    }
  end

  def set_insert(index)
    tk_send 'mark', 'set', 'insert', index
  end
  def set_current(index)
    tk_send 'mark', 'set', 'current', index
  end

  def insert(index, chars, *tags)
    super index, chars, tags.collect{|x|_get_eval_string(x)}.join(' ')
  end

  def destroy
    @@tags.each_value do |t|
      t.destroy
    end
    super
  end

  def backspace
    self.delete 'insert'
  end

  def compare(idx1, op, idx2)
    bool(tk_send('compare', idx1, op, idx2))
  end

  def debug
    bool(tk_send('debug'))
  end
  def debug=(boolean)
    tk_send 'debug', boolean
  end

  def bbox(index)
    inf = tk_send('bbox', index)
    (inf == "")?  [0,0,0,0]: inf
  end
  def dlineinfo(index)
    inf = tk_send('dlineinfo', index)
    (inf == "")?  [0,0,0,0,0]: inf
  end

  def yview(*what)
    tk_send 'yview', *what
  end
  def yview_pickplace(*what)
    tk_send 'yview', '-pickplace', *what
  end

  def xview(*what)
    tk_send 'xview', *what
  end
  def xview_pickplace(*what)
    tk_send 'xview', '-pickplace', *what
  end

  def tag_add(tag,index1,index2=None)
    tk_send 'tag', 'add', tag, index1, index2
  end

  def _tag_bind_core(mode, tag, seq, cmd=Proc.new, args=nil)
    id = install_bind(cmd, args)
    tk_send 'tag', 'bind', tag, "<#{tk_event_sequence(seq)}>", mode + id
    # _addcmd cmd
  end
  private :_tag_bind_core

  def tag_bind(tag, seq, cmd=Proc.new, args=nil)
    _tag_bind_core('', tag, seq, cmd=Proc.new, args=nil)
  end

  def tag_bind_append(tag, seq, cmd=Proc.new, args=nil)
    _tag_bind_core('+', tag, seq, cmd=Proc.new, args=nil)
  end

  def tag_bindinfo(tag, context=nil)
    if context
      (tk_send('tag', 'bind', tag, 
	       "<#{tk_event_sequence(context)}>")).collect{|cmdline|
	if cmdline =~ /^rb_out (c\d+)\s+(.*)$/
	  [Tk_CMDTBL[$1], $2]
	else
	  cmdline
	end
      }
    else
      tk_split_list(tk_send('tag', 'bind', tag)).filter{|seq|
	seq[1..-2].gsub(/></,',')
      }
    end
  end

  def tag_cget(tag, key)
    tk_tcl2ruby tk_call @@t.path, 'tag', 'cget', tag, "-#{key}"
  end

  def tag_configure(tag, key, val=None)
    if key.kind_of? Hash
      if ( key['font'] || key['kanjifont'] \
	  || key['latinfont'] || key['asciifont'] )
	tagfont_configure(tag, key.dup)
      else
	tk_send 'tag', 'configure', tag, *hash_kv(key)
      end

    else
      if ( key == 'font' || key == 'kanjifont' \
	  || key == 'latinfont' || key == 'asciifont' )
	tagfont_configure({key=>val})
      else
	tk_call 'tag', 'configure', tag, "-#{key}", val
      end
    end
  end

  def tag_configinfo(tag, key=nil)
    if key
      conf = tk_split_list(tk_send('tag','configure',tag,"-#{key}"))
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_send('tag', 'configure', tag)).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end

  def tag_raise(tag, above=None)
    tk_send 'tag', 'raise', tag, above
  end

  def tag_lower(tag, below=None)
    tk_send 'tag', 'lower', tag, below
  end

  def tag_remove(tag, *index)
    tk_send 'tag', 'remove', tag, *index
  end

  def tag_ranges(tag)
    l = tk_split_list(tk_send('tag', 'ranges', tag))
    r = []
    while key=l.shift
      r.push [key, l.shift]
    end
    r
  end

  def tag_nextrange(tag, first, last=None)
    tk_split_list(tk_send('tag', 'nextrange', tag, first, last))
  end

  def tag_prevrange(tag, first, last=None)
    tk_split_list(tk_send('tag', 'prevrange', tag, first, last))
  end

  def search_with_length(pat,start,stop=None)
    pat = pat.char if pat.kind_of? Integer
    if stop != None
      return ["", 0] if compare(start,'>=',stop)
      txt = get(start,stop)
      if (pos = txt.index(pat))
	pos = txt[0..(pos-1)].split('').length if pos > 0
	if pat.kind_of? String
	  return [index(start + " + #{pos} chars"), pat.split('').length]
	else
	  return [index(start + " + #{pos} chars"), $&.split('').length]
	end
      else
	return ["", 0]
      end
    else
      txt = get(start,'end - 1 char')
      if (pos = txt.index(pat))
	pos = txt[0..(pos-1)].split('').length if pos > 0
	if pat.kind_of? String
	  return [index(start + " + #{pos} chars"), pat.split('').length]
	else
	  return [index(start + " + #{pos} chars"), $&.split('').length]
	end
      else
	txt = get('1.0','end - 1 char')
	if (pos = txt.index(pat))
	  pos = txt[0..(pos-1)].split('').length if pos > 0
	  if pat.kind_of? String
	    return [index("1.0 + #{pos} chars"), pat.split('').length]
	  else
	    return [index("1.0 + #{pos} chars"), $&.split('').length]
	  end
	else
	  return ["", 0]
	end
      end
    end
  end

  def search(pat,start,stop=None)
    search_with_length(pat,start,stop)[0]
  end

  def rsearch_with_length(pat,start,stop=None)
    pat = pat.char if pat.kind_of? Integer
    if stop != None
      return ["", 0] if compare(start,'<=',stop)
      txt = get(stop,start)
      if (pos = txt.rindex(pat))
	pos = txt[0..(pos-1)].split('').length if pos > 0
	if pat.kind_of? String
	  return [index(stop + " + #{pos} chars"), pat.split('').length]
	else
	  return [index(stop + " + #{pos} chars"), $&.split('').length]
	end
      else
	return ["", 0]
      end
    else
      txt = get('1.0',start)
      if (pos = txt.rindex(pat))
	pos = txt[0..(pos-1)].split('').length if pos > 0
	if pat.kind_of? String
	  return [index("1.0 + #{pos} chars"), pat.split('').length]
	else
	  return [index("1.0 + #{pos} chars"), $&.split('').length]
	end
      else
	txt = get('1.0','end - 1 char')
	if (pos = txt.rindex(pat))
	  pos = txt[0..(pos-1)].split('').length if pos > 0
	  if pat.kind_of? String
	    return [index("1.0 + #{pos} chars"), pat.split('').length]
	  else
	    return [index("1.0 + #{pos} chars"), $&.split('').length]
	  end
	else
	  return ["", 0]
	end
      end
    end
  end

  def rsearch(pat,start,stop=None)
    rsearch_with_length(pat,start,stop)[0]
  end
end

class TkTextTag<TkObject
  include TkTreatTagFont

  $tk_text_tag = 'tag0000'
  def initialize(parent, keys=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@parent = @@t = parent
    @@path = @@id = $tk_text_tag
    $tk_text_tag = $tk_text_tag.succ
    #tk_call @@t.path, "tag", "configure", @@id, *hash_kv(keys)
    configure(keys) if keys
    @@t._addtag id, self
  end
  def id
    return @@id
  end

  def first
    @@id + '.first'
  end

  def last
    @@id + '.last'
  end

  def add(*index)
    tk_call @@t.path, 'tag', 'add', @@id, *index
  end

  def remove(*index)
    tk_call @@t.path, 'tag', 'remove', @@id, *index
  end

  def ranges
    l = tk_split_list(tk_call(@@t.path, 'tag', 'ranges', @@id))
    r = []
    while key=l.shift
      r.push [key, l.shift]
    end
    r
  end

  def nextrange(first, last=None)
    tk_split_list(tk_call(@@t.path, 'tag', 'nextrange', @@id, first, last))
  end

  def prevrange(first, last=None)
    tk_split_list(tk_call(@@t.path, 'tag', 'prevrange', @@id, first, last))
  end

  def [](key)
    cget key
  end

  def []=(key,val)
    configure key, val
  end

  def cget(key)
    tk_tcl2ruby tk_call @@t.path, 'tag', 'cget', @@id, "-#{key}"
  end

  def configure(key, val=None)
    @@t.tag_configure @@id, key, val
  end
#  def configure(key, val=None)
#    if key.kind_of? Hash
#      tk_call @@t.path, 'tag', 'configure', @@id, *hash_kv(key)
#    else
#      tk_call @@t.path, 'tag', 'configure', @@id, "-#{key}", val
#    end
#  end
#  def configure(key, value)
#    if value == FALSE
#      value = "0"
#    elsif value.kind_of? Proc
#      value = install_cmd(value)
#    end
#    tk_call @@t.path, 'tag', 'configure', @@id, "-#{key}", value
#  end

  def configinfo(key=nil)
    @@t.tag_configinfo @@id, key
  end
#  def configinfo(key=nil)
#    if key
#      conf = tk_split_list(tk_call(@@t.path, 'tag','configure',@@id,"-#{key}"))
#      conf[0] = conf[0][1..-1]
#      conf
#    else
#      tk_split_list(tk_call(@@t.path, 'tag', 'configure', @@id)).collect{|conf|
#	conf[0] = conf[0][1..-1]
#	conf
#      }
#    end
#  end

  def bind(seq, cmd=Proc.new, args=nil)
    id = install_bind(cmd, args)
    tk_call @@t.path, 'tag', 'bind', @@id, "<#{tk_event_sequence(seq)}>", id
    # @@t._addcmd cmd
  end

  def bindinfo(context=nil)
    if context
      (tk_call(@@t.path, 'tag', 'bind', @@id, 
	       "<#{tk_event_sequence(context)}>")).collect{|cmdline|
	if cmdline =~ /^rb_out (c\d+)\s+(.*)$/
	  [Tk_CMDTBL[$1], $2]
	else
	  cmdline
	end
      }
    else
      tk_split_list(tk_call(@@t.path, 'tag', 'bind', @@id)).filter{|seq|
	seq[1..-2].gsub(/></,',')
      }
    end
  end

  def raise(above=None)
    tk_call @@t.path, 'tag', 'raise', @@id, above
  end

  def lower(below=None)
    tk_call @@t.path, 'tag', 'lower', @@id, below
  end

  def destroy
    tk_call @@t.path, 'tag', 'delete', @@id
  end
end

class TkTextTagSel<TkTextTag
  def initialize(parent, keys=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'sel'
    #tk_call @@t.path, "tag", "configure", @@id, *hash_kv(keys)
    configure(keys) if keys
    @@t._addtag id, self
  end
end

class TkTextMark<TkObject
  $tk_text_mark = 'mark0000'
  def initialize(parent, index)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = $tk_text_mark
    $tk_text_mark = $tk_text_mark.succ
    tk_call @@t.path, 'mark', 'set', @@id, index
    @@t._addtag id, self
  end
  def id
    return @@id
  end

  def set(where)
    tk_call @@t.path, 'mark', 'set', @@id, where
  end

  def unset
    tk_call @@t.path, 'mark', 'unset', @@id
  end
  alias destroy unset

  def gravity
    tk_call @@t.path, 'mark', 'gravity', @@id
  end

  def gravity=(direction)
    tk_call @@t.path, 'mark', 'gravity', @@id, direction
  end
end

class TkTextMarkInsert<TkTextMark
  def initialize(parent, index=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'insert'
    tk_call @@t.path, 'mark', 'set', @@id, index if index
    @@t._addtag id, self
  end
end

class TkTextMarkCurrent<TkTextMark
  def initialize(parent,index=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'current'
    tk_call @@t.path, 'mark', 'set', @@id, index if index
    @@t._addtag id, self
  end
end

class TkTextWindow<TkObject
  def initialize(parent, index, keys)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    if index == 'end'
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
    elsif index.kind_of? TkTextMark
      if tk_call(@@t.path,'index',index.path) == tk_call(@@t.path,'index','end')
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
      else
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index.path))
      end
    else
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index))
    end
    @@path.gravity = 'left'
    @@index = @@path.path
    @@id = keys['window']
    if keys['create']
      @@p_create = keys['create']
      if @@p_create.kind_of? Proc
	keys['create'] = install_cmd(proc{@@id = @@p_create.call; @@id.path})
      end
    end
    tk_call @@t.path, 'window', 'create', @@index, *hash_kv(keys)
  end

  def [](slot)
    cget(slot)
  end
  def []=(slot, value)
    configure(slot, value)
  end

  def cget(slot)
    tk_tcl2ruby tk_call @@t.path, 'window', 'cget', @@index, "-#{slot}"
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      @@id = slot['window'] if slot['window']
      if slot['create']
	self.create=value
	slot['create']=nil
      end
      if slot.size > 0
	tk_call @@t.path, 'window', 'configure', @@index, *hash_kv(slot)
      end
    else
      @@id = value if slot == 'window'
      if slot == 'create'
	self.create=value
      else
	tk_call @@t.path, 'window', 'configure', @@index, "-#{slot}", value
      end
    end
  end

  def window
    @@id
  end

  def window=(value)
    tk_call @@t.path, 'window', 'configure', @@index, '-window', value
    @@id = value
  end

  def create
    @@p_create
  end

  def create=(value)
    @@p_create = value
    if @@p_create.kind_of? Proc
      value = install_cmd(proc{@@id = @@p_create.call})
    end
    tk_call @@t.path, 'window', 'configure', @@index, '-create', value
  end

  def configinfo(slot = nil)
    if slot
      conf = tk_split_list(tk_call @@t.path, 'window', 'configure', 
			   @@index, "-#{slot}")
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_call @@t.path, 'window', 'configure', 
		    @@index).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end
end

class TkTextImage<TkObject
  def initialize(parent, index, keys)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    if index == 'end'
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
    elsif index.kind_of? TkTextMark
      if tk_call(@@t.path,'index',index.path) == tk_call(@@t.path,'index','end')
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
      else
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index.path))
      end
    else
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index))
    end
    @@path.gravity = 'left'
    @@index = @@path.path
    @@id = tk_call(@@t.path, 'image', 'create', @@index, *hash_kv(keys))
  end

  def [](slot)
    cget(slot)
  end
  def []=(slot, value)
    configure(slot, value)
  end

  def cget(slot)
    tk_tcl2ruby tk_call @@t.path, 'image', 'cget', @@index, "-#{slot}"
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      tk_call @@t.path, 'image', 'configure', @@index, *hash_kv(slot)
    else
      tk_call @@t.path, 'image', 'configure', @@index, "-#{slot}", value
    end
  end
#  def configure(slot, value)
#    tk_call @@t.path, 'image', 'configure', @@index, "-#{slot}", value
#  end

  def image
    tk_call @@t.path, 'image', 'configure', @@index, '-image'
  end

  def image=(value)
    tk_call @@t.path, 'image', 'configure', @@index, '-image', value
  end

  def configinfo(slot = nil)
    if slot
      conf = tk_split_list(tk_call @@t.path, 'image', 'configure', 
			   @@index, "-#{slot}")
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_call @@t.path, 'image', 'configure', 
		    @@index).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end
end
@


1.1.1.1.2.1
log
@aix shlib link
@
text
@d3 1
a3 1
#			$Date: 1999/01/20 04:59:34 $
d250 1
a250 1
    _tag_bind_core('', tag, seq, cmd, args=nil)
d254 1
a254 1
    _tag_bind_core('+', tag, seq, cmd, args=nil)
@


1.1.1.1.2.2
log
@990531
@
text
@d3 1
a3 1
#			$Date: 1999/04/26 09:42:43 $
d275 1
a275 1
    tk_tcl2ruby tk_call @@path, 'tag', 'cget', tag, "-#{key}"
d292 1
a292 1
	tk_send 'tag', 'configure', tag, "-#{key}", val
@


1.1.1.1.2.3
log
@thread bugs
@
text
@d3 1
a3 1
#			$Date: 1999/05/31 09:13:32 $
d288 2
a289 2
      if  key == 'font' || key == 'kanjifont' ||
	  key == 'latinfont' || key == 'asciifont'
d323 1
a323 1
    l = tk_split_simplelist(tk_send('tag', 'ranges', tag))
d332 1
a332 1
    tk_split_simplelist(tk_send('tag', 'nextrange', tag, first, last))
d336 1
a336 1
    tk_split_simplelist(tk_send('tag', 'prevrange', tag, first, last))
d440 1
a440 10
    if args != [] then
      keys = args.pop
      if keys.kind_of? Hash then
	add(*args) if args != []
	configure(keys)
      else
	args.push keys
	add(*args)
      end
    end
a442 1

d473 1
a473 1
    tk_split_simplelist(tk_call(@@t.path, 'tag', 'nextrange', @@id, first, last))
d477 1
a477 1
    tk_split_simplelist(tk_call(@@t.path, 'tag', 'prevrange', @@id, first, last))
a633 12
class TkTextMarkAnchor<TkTextMark
  def initialize(parent,index=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'anchor'
    tk_call @@t.path, 'mark', 'set', @@id, index if index
    @@t._addtag id, self
  end
end

a727 127
  end

  def _dump(type, *index)
    str = tk_send('dump', type, *index)
    result = []
    sel = nil
    i = 0
    while i < str.size
      # retrieve key
      idx = str.index(/ /, i)
      result.push str[i..(idx-1)]
      i = idx + 1
      
      # retrieve value
      case result[-1]
      when 'text'
	if str[i] == ?{
	  # text formed as {...}
	  val, i = _retrieve_braced_text(str, i)
	  result.push val
	else
	  # text which may contain backslahes
	  val, i = _retrieve_backslashed_text(str, i)
	  result.push val
	end
      else
	idx = str.index(/ /, i)
	val = str[i..(idx-1)]
	case result[-1]
	when 'mark'
	  case val
	  when 'insert'
	    result.push TkTextMarkInsert.new(self)
	  when 'current'
	    result.push TkTextMarkCurrent.new(self)
	  when 'anchor'
	    result.push TkTextMarkAnchor.new(self)
	  else
	    result.push tk_tcl2rb(val)
	  end
	when 'tagon'
	  if val == 'sel'
	    if sel
	      result.push sel
	    else
	      result.push TkTextTagSel.new(self)
	    end
	  else
	    result.push tk_tcl2rb val
	  end
	when 'tagoff'
	    result.push tk_tcl2rb sel
	when 'window'
	  result.push tk_tcl2rb val
	end
	i = idx + 1
      end

      # retrieve index
      idx = str.index(/ /, i)
      if idx
	result.push str[i..(idx-1)]
	i = idx + 1
      else
	result.push str[i..-1]
	break
      end
    end
    
    kvis = []
    until result.empty?
      kvis.push [result.shift, result.shift, result.shift]
    end
    kvis  # result is [[key1, value1, index1], [key2, value2, index2], ...]
  end
  private :_dump

  def _retrieve_braced_text(str, i)
    cnt = 0
    idx = i
    while idx < str.size
      case str[idx]
      when ?{
	cnt += 1
      when ?}
	cnt -= 1
	if cnt == 0
	  break
	end
      end
      idx += 1
    end
    return str[i+1..idx-1], idx + 2
  end
  private :_retrieve_braced_text

  def _retrieve_backslashed_text(str, i)
    j = i
    idx = nil
    loop {
      idx = str.index(/ /, j)
      if str[idx-1] == ?\\
	j += 1
      else
	break
      end
    }
    val = str[i..(idx-1)]
    val.gsub!(/\\( |\{|\})/, '\1')
    return val, idx + 1
  end
  private :_retrieve_backslashed_text

  def dump_all(*index)
    _dump('-all', *index)
  end
  def dump_mark(*index)
    _dump('-mark', *index)
  end
  def dump_tag(*index)
    _dump('-tag', *index)
  end
  def dump_text(*index)
    _dump('-text', *index)
  end
  def dump_window(*index)
    _dump('-window', *index)
@


1.1.1.1.2.4
log
@tktext.rb
@
text
@d3 1
a3 1
#			$Date: 1999/06/09 09:21:36 $
d474 1
a474 1
    l = tk_split_simplelist(tk_call(@@t.path, 'tag', 'ranges', @@id))
@


1.1.1.1.2.5
log
@990624
@
text
@d3 1
a3 1
#			$Date: 1999/06/11 07:07:06 $
d432 1
a432 1
  def initialize(parent, *args)
@


1.1.2.1
log
@1.1c8
@
text
@a0 797
#
#		tktext.rb - Tk text classes
#			$Date: 1998/07/21 09:18:05 $
#			by Yukihiro Matsumoto <matz@@caelum.co.jp>

require 'tk.rb'
require 'tkfont'

module TkTreatTextTagFont
  def tagfont_configinfo(tag)
    if tag.kind_of? TkTextTag
      pathname = self.path + ';' + tag.id
    else
      pathname = self.path + ';' + tag
    end
    ret = TkFont.used_on(pathname)
    if ret == nil
      ret = TkFont.init_widget_font(pathname, 
				    self.path, 'tag', 'configure', tag)
    end
    ret
  end
  alias tagfontobj tagfont_configinfo

  def tagfont_configure(tag, slot)
    if tag.kind_of? TkTextTag
      pathname = self.path + ';' + tag.id
    else
      pathname = self.path + ';' + tag
    end
    if (fnt = slot['font'])
      slot['font'] = nil
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(pathname, 
				       self.path,'tag','configure',tag,slot)
      else
	latintagfont_configure(tag, fnt) if fnt
      end
    end
    if (ltn = slot['latinfont'])
      slot['latinfont'] = nil
      latintagfont_configure(tag, ltn) if ltn
    end
    if (ltn = slot['asciifont'])
      slot['asciifont'] = nil
      latintagfont_configure(tag, ltn) if ltn
    end
    if (knj = slot['kanjifont'])
      slot['kanjifont'] = nil
      kanjitagfont_configure(tag, knj) if knj
    end

    tk_call(self.path, 'tag', 'configure', tag, *hash_kv(slot)) if slot != {}
    self
  end

  def latintagfont_configure(tag, ltn, keys=nil)
    fobj = tagfontobj(tag)
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.latin_replace(ltn)
	fobj.latin_configure(keys) if keys
      elsif keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciitagfont_configure latintagfont_configure

  def kanjitagfont_configure(tag, knj, keys=nil)
    fobj = tagfontobj(tag)
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.kanji_replace(knj)
	fobj.kanji_configure(keys) if keys
      elsif keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(conf)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def tagfont_copy(tag, window, wintag=nil)
    if wintag
      window.tagfontobj(wintag).configinfo.each{|key,value|
	tagfontobj(tag).configure(key,value)
      }
      tagfontobj(tag).replace(window.tagfontobj(wintag).latin_font, 
			      window.tagfontobj(wintag).kanji_font)
    else
      window.tagfont(wintag).configinfo.each{|key,value|
	tagfontobj(tag).configure(key,value)
      }
      tagfontobj(tag).replace(window.fontobj.latin_font, 
			      window.fontobj.kanji_font)
    end
  end

  def latintagfont_copy(tag, window, wintag=nil)
    if wintag
      tagfontobj(tag).latin_replace(window.tagfontobj(wintag).latin_font)
    else
      tagfontobj(tag).latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciitagfont_copy latintagfont_copy

  def kanjitagfont_copy(tag, window, wintag=nil)
    if wintag
      tagfontobj(tag).kanji_replace(window.tagfontobj(wintag).kanji_font)
    else
      tagfontobj(tag).kanji_replace(window.fontobj.kanji_font)
    end
  end
end

class TkText<TkTextWin
  include TkTreatTextTagFont

  WidgetClassName = 'Text'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end
  include Scrollable
  def create_self
    tk_call 'text', @@path
    @@tags = {}
  end
  def index(index)
    tk_send 'index', index
  end
  def value
    tk_send 'get', "1.0", "end - 1 char"
  end
  def value= (val)
    tk_send 'delete', "1.0", 'end'
    tk_send 'insert', "1.0", val
  end
  def _addcmd(cmd)
    @@cmdtbl.push cmd
  end
  def _addtag(name, obj)
    @@tags[name] = obj
  end

  def tagid2obj(tagid)
    if not @@tags[tagid]
      tagid
    else
      @@tags[tagid]
    end
  end

  def tag_names(index=None)
    tk_split_list(tk_send('tag', 'names', index)).collect{|elt|
      tagid2obj(elt)
    }
  end
  def window_names
    tk_send('window', 'names').collect{|elt|
      tagid2obj(elt)
    }
  end
  def image_names
    tk_send('image', 'names').collect{|elt|
      tagid2obj(elt)
    }
  end

  def set_insert(index)
    tk_send 'mark', 'set', 'insert', index
  end
  def set_current(index)
    tk_send 'mark', 'set', 'current', index
  end

  def insert(index, chars, *tags)
    super index, chars, tags.collect{|x|_get_eval_string(x)}.join(' ')
  end

  def destroy
    @@tags.each_value do |t|
      t.destroy
    end
    super
  end

  def backspace
    self.delete 'insert'
  end

  def compare(idx1, op, idx2)
    bool(tk_send('compare', idx1, op, idx2))
  end

  def debug
    bool(tk_send('debug'))
  end
  def debug=(boolean)
    tk_send 'debug', boolean
  end

  def bbox(index)
    inf = tk_send('bbox', index)
    (inf == "")?  [0,0,0,0]: inf
  end
  def dlineinfo(index)
    inf = tk_send('dlineinfo', index)
    (inf == "")?  [0,0,0,0,0]: inf
  end

  def yview(*what)
    tk_send 'yview', *what
  end
  def yview_pickplace(*what)
    tk_send 'yview', '-pickplace', *what
  end

  def xview(*what)
    tk_send 'xview', *what
  end
  def xview_pickplace(*what)
    tk_send 'xview', '-pickplace', *what
  end

  def tag_add(tag,index1,index2=None)
    tk_send 'tag', 'add', tag, index1, index2
  end

  def _tag_bind_core(mode, tag, seq, cmd=Proc.new, args=nil)
    id = install_bind(cmd, args)
    tk_send 'tag', 'bind', tag, "<#{tk_event_sequence(seq)}>", mode + id
    # _addcmd cmd
  end
  private :_tag_bind_core

  def tag_bind(tag, seq, cmd=Proc.new, args=nil)
    _tag_bind_core('', tag, seq, cmd=Proc.new, args=nil)
  end

  def tag_bind_append(tag, seq, cmd=Proc.new, args=nil)
    _tag_bind_core('+', tag, seq, cmd=Proc.new, args=nil)
  end

  def tag_bindinfo(tag, context=nil)
    if context
      (tk_send('tag', 'bind', tag, 
	       "<#{tk_event_sequence(context)}>")).collect{|cmdline|
	if cmdline =~ /^rb_out (c\d+)\s+(.*)$/
	  [Tk_CMDTBL[$1], $2]
	else
	  cmdline
	end
      }
    else
      tk_split_list(tk_send('tag', 'bind', tag)).filter{|seq|
	seq[1..-2].gsub(/></,',')
      }
    end
  end

  def tag_cget(tag, key)
    tk_tcl2ruby tk_call @@t.path, 'tag', 'cget', tag, "-#{key}"
  end

  def tag_configure(tag, key, val=None)
    if key.kind_of? Hash
      if ( key['font'] || key['kanjifont'] \
	  || key['latinfont'] || key['asciifont'] )
	tagfont_configure(tag, key.dup)
      else
	tk_send 'tag', 'configure', tag, *hash_kv(key)
      end

    else
      if ( key == 'font' || key == 'kanjifont' \
	  || key == 'latinfont' || key == 'asciifont' )
	tagfont_configure({key=>val})
      else
	tk_call 'tag', 'configure', tag, "-#{key}", val
      end
    end
  end

  def tag_configinfo(tag, key=nil)
    if key
      conf = tk_split_list(tk_send('tag','configure',tag,"-#{key}"))
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_send('tag', 'configure', tag)).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end

  def tag_raise(tag, above=None)
    tk_send 'tag', 'raise', tag, above
  end

  def tag_lower(tag, below=None)
    tk_send 'tag', 'lower', tag, below
  end

  def tag_remove(tag, *index)
    tk_send 'tag', 'remove', tag, *index
  end

  def tag_ranges(tag)
    l = tk_split_list(tk_send('tag', 'ranges', tag))
    r = []
    while key=l.shift
      r.push [key, l.shift]
    end
    r
  end

  def tag_nextrange(tag, first, last=None)
    tk_split_list(tk_send('tag', 'nextrange', tag, first, last))
  end

  def tag_prevrange(tag, first, last=None)
    tk_split_list(tk_send('tag', 'prevrange', tag, first, last))
  end

  def search_with_length(pat,start,stop=None)
    pat = pat.char if pat.kind_of? Integer
    if stop != None
      return ["", 0] if compare(start,'>=',stop)
      txt = get(start,stop)
      if (pos = txt.index(pat))
	pos = txt[0..(pos-1)].split('').length if pos > 0
	if pat.kind_of? String
	  return [index(start + " + #{pos} chars"), pat.split('').length]
	else
	  return [index(start + " + #{pos} chars"), $&.split('').length]
	end
      else
	return ["", 0]
      end
    else
      txt = get(start,'end - 1 char')
      if (pos = txt.index(pat))
	pos = txt[0..(pos-1)].split('').length if pos > 0
	if pat.kind_of? String
	  return [index(start + " + #{pos} chars"), pat.split('').length]
	else
	  return [index(start + " + #{pos} chars"), $&.split('').length]
	end
      else
	txt = get('1.0','end - 1 char')
	if (pos = txt.index(pat))
	  pos = txt[0..(pos-1)].split('').length if pos > 0
	  if pat.kind_of? String
	    return [index("1.0 + #{pos} chars"), pat.split('').length]
	  else
	    return [index("1.0 + #{pos} chars"), $&.split('').length]
	  end
	else
	  return ["", 0]
	end
      end
    end
  end

  def search(pat,start,stop=None)
    search_with_length(pat,start,stop)[0]
  end

  def rsearch_with_length(pat,start,stop=None)
    pat = pat.char if pat.kind_of? Integer
    if stop != None
      return ["", 0] if compare(start,'<=',stop)
      txt = get(stop,start)
      if (pos = txt.rindex(pat))
	pos = txt[0..(pos-1)].split('').length if pos > 0
	if pat.kind_of? String
	  return [index(stop + " + #{pos} chars"), pat.split('').length]
	else
	  return [index(stop + " + #{pos} chars"), $&.split('').length]
	end
      else
	return ["", 0]
      end
    else
      txt = get('1.0',start)
      if (pos = txt.rindex(pat))
	pos = txt[0..(pos-1)].split('').length if pos > 0
	if pat.kind_of? String
	  return [index("1.0 + #{pos} chars"), pat.split('').length]
	else
	  return [index("1.0 + #{pos} chars"), $&.split('').length]
	end
      else
	txt = get('1.0','end - 1 char')
	if (pos = txt.rindex(pat))
	  pos = txt[0..(pos-1)].split('').length if pos > 0
	  if pat.kind_of? String
	    return [index("1.0 + #{pos} chars"), pat.split('').length]
	  else
	    return [index("1.0 + #{pos} chars"), $&.split('').length]
	  end
	else
	  return ["", 0]
	end
      end
    end
  end

  def rsearch(pat,start,stop=None)
    rsearch_with_length(pat,start,stop)[0]
  end
end

class TkTextTag<TkObject
  include TkTreatTagFont

  $tk_text_tag = 'tag0000'
  def initialize(parent, keys=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@parent = @@t = parent
    @@path = @@id = $tk_text_tag
    $tk_text_tag = $tk_text_tag.succ
    #tk_call @@t.path, "tag", "configure", @@id, *hash_kv(keys)
    configure(keys) if keys
    @@t._addtag id, self
  end
  def id
    return @@id
  end

  def first
    @@id + '.first'
  end

  def last
    @@id + '.last'
  end

  def add(*index)
    tk_call @@t.path, 'tag', 'add', @@id, *index
  end

  def remove(*index)
    tk_call @@t.path, 'tag', 'remove', @@id, *index
  end

  def ranges
    l = tk_split_list(tk_call(@@t.path, 'tag', 'ranges', @@id))
    r = []
    while key=l.shift
      r.push [key, l.shift]
    end
    r
  end

  def nextrange(first, last=None)
    tk_split_list(tk_call(@@t.path, 'tag', 'nextrange', @@id, first, last))
  end

  def prevrange(first, last=None)
    tk_split_list(tk_call(@@t.path, 'tag', 'prevrange', @@id, first, last))
  end

  def [](key)
    cget key
  end

  def []=(key,val)
    configure key, val
  end

  def cget(key)
    tk_tcl2ruby tk_call @@t.path, 'tag', 'cget', @@id, "-#{key}"
  end

  def configure(key, val=None)
    @@t.tag_configure @@id, key, val
  end
#  def configure(key, val=None)
#    if key.kind_of? Hash
#      tk_call @@t.path, 'tag', 'configure', @@id, *hash_kv(key)
#    else
#      tk_call @@t.path, 'tag', 'configure', @@id, "-#{key}", val
#    end
#  end
#  def configure(key, value)
#    if value == FALSE
#      value = "0"
#    elsif value.kind_of? Proc
#      value = install_cmd(value)
#    end
#    tk_call @@t.path, 'tag', 'configure', @@id, "-#{key}", value
#  end

  def configinfo(key=nil)
    @@t.tag_configinfo @@id, key
  end
#  def configinfo(key=nil)
#    if key
#      conf = tk_split_list(tk_call(@@t.path, 'tag','configure',@@id,"-#{key}"))
#      conf[0] = conf[0][1..-1]
#      conf
#    else
#      tk_split_list(tk_call(@@t.path, 'tag', 'configure', @@id)).collect{|conf|
#	conf[0] = conf[0][1..-1]
#	conf
#      }
#    end
#  end

  def bind(seq, cmd=Proc.new, args=nil)
    id = install_bind(cmd, args)
    tk_call @@t.path, 'tag', 'bind', @@id, "<#{tk_event_sequence(seq)}>", id
    # @@t._addcmd cmd
  end

  def bindinfo(context=nil)
    if context
      (tk_call(@@t.path, 'tag', 'bind', @@id, 
	       "<#{tk_event_sequence(context)}>")).collect{|cmdline|
	if cmdline =~ /^rb_out (c\d+)\s+(.*)$/
	  [Tk_CMDTBL[$1], $2]
	else
	  cmdline
	end
      }
    else
      tk_split_list(tk_call(@@t.path, 'tag', 'bind', @@id)).filter{|seq|
	seq[1..-2].gsub(/></,',')
      }
    end
  end

  def raise(above=None)
    tk_call @@t.path, 'tag', 'raise', @@id, above
  end

  def lower(below=None)
    tk_call @@t.path, 'tag', 'lower', @@id, below
  end

  def destroy
    tk_call @@t.path, 'tag', 'delete', @@id
  end
end

class TkTextTagSel<TkTextTag
  def initialize(parent, keys=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'sel'
    #tk_call @@t.path, "tag", "configure", @@id, *hash_kv(keys)
    configure(keys) if keys
    @@t._addtag id, self
  end
end

class TkTextMark<TkObject
  $tk_text_mark = 'mark0000'
  def initialize(parent, index)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = $tk_text_mark
    $tk_text_mark = $tk_text_mark.succ
    tk_call @@t.path, 'mark', 'set', @@id, index
    @@t._addtag id, self
  end
  def id
    return @@id
  end

  def set(where)
    tk_call @@t.path, 'mark', 'set', @@id, where
  end

  def unset
    tk_call @@t.path, 'mark', 'unset', @@id
  end
  alias destroy unset

  def gravity
    tk_call @@t.path, 'mark', 'gravity', @@id
  end

  def gravity=(direction)
    tk_call @@t.path, 'mark', 'gravity', @@id, direction
  end
end

class TkTextMarkInsert<TkTextMark
  def initialize(parent, index=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'insert'
    tk_call @@t.path, 'mark', 'set', @@id, index if index
    @@t._addtag id, self
  end
end

class TkTextMarkCurrent<TkTextMark
  def initialize(parent,index=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'current'
    tk_call @@t.path, 'mark', 'set', @@id, index if index
    @@t._addtag id, self
  end
end

class TkTextWindow<TkObject
  def initialize(parent, index, keys)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    if index == 'end'
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
    elsif index.kind_of? TkTextMark
      if tk_call(@@t.path,'index',index.path) == tk_call(@@t.path,'index','end')
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
      else
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index.path))
      end
    else
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index))
    end
    @@path.gravity = 'left'
    @@index = @@path.path
    @@id = keys['window']
    if keys['create']
      @@p_create = keys['create']
      if @@p_create.kind_of? Proc
	keys['create'] = install_cmd(proc{@@id = @@p_create.call; @@id.path})
      end
    end
    tk_call @@t.path, 'window', 'create', @@index, *hash_kv(keys)
  end

  def [](slot)
    cget(slot)
  end
  def []=(slot, value)
    configure(slot, value)
  end

  def cget(slot)
    tk_tcl2ruby tk_call @@t.path, 'window', 'cget', @@index, "-#{slot}"
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      @@id = slot['window'] if slot['window']
      if slot['create']
	self.create=value
	slot['create']=nil
      end
      if slot.size > 0
	tk_call @@t.path, 'window', 'configure', @@index, *hash_kv(slot)
      end
    else
      @@id = value if slot == 'window'
      if slot == 'create'
	self.create=value
      else
	tk_call @@t.path, 'window', 'configure', @@index, "-#{slot}", value
      end
    end
  end

  def window
    @@id
  end

  def window=(value)
    tk_call @@t.path, 'window', 'configure', @@index, '-window', value
    @@id = value
  end

  def create
    @@p_create
  end

  def create=(value)
    @@p_create = value
    if @@p_create.kind_of? Proc
      value = install_cmd(proc{@@id = @@p_create.call})
    end
    tk_call @@t.path, 'window', 'configure', @@index, '-create', value
  end

  def configinfo(slot = nil)
    if slot
      conf = tk_split_list(tk_call @@t.path, 'window', 'configure', 
			   @@index, "-#{slot}")
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_call @@t.path, 'window', 'configure', 
		    @@index).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end
end

class TkTextImage<TkObject
  def initialize(parent, index, keys)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    if index == 'end'
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
    elsif index.kind_of? TkTextMark
      if tk_call(@@t.path,'index',index.path) == tk_call(@@t.path,'index','end')
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', 'end - 1 chars'))
      else
	@@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index.path))
      end
    else
      @@path = TkTextMark.new(@@t, tk_call(@@t.path, 'index', index))
    end
    @@path.gravity = 'left'
    @@index = @@path.path
    @@id = tk_call(@@t.path, 'image', 'create', @@index, *hash_kv(keys))
  end

  def [](slot)
    cget(slot)
  end
  def []=(slot, value)
    configure(slot, value)
  end

  def cget(slot)
    tk_tcl2ruby tk_call @@t.path, 'image', 'cget', @@index, "-#{slot}"
  end

  def configure(slot, value=None)
    if slot.kind_of? Hash
      tk_call @@t.path, 'image', 'configure', @@index, *hash_kv(slot)
    else
      tk_call @@t.path, 'image', 'configure', @@index, "-#{slot}", value
    end
  end
#  def configure(slot, value)
#    tk_call @@t.path, 'image', 'configure', @@index, "-#{slot}", value
#  end

  def image
    tk_call @@t.path, 'image', 'configure', @@index, '-image'
  end

  def image=(value)
    tk_call @@t.path, 'image', 'configure', @@index, '-image', value
  end

  def configinfo(slot = nil)
    if slot
      conf = tk_split_list(tk_call @@t.path, 'image', 'configure', 
			   @@index, "-#{slot}")
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_call @@t.path, 'image', 'configure', 
		    @@index).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end
end
@


1.1.2.2
log
@1.2.6
@
text
@d3 1
a3 1
#			$Date: 1999/06/09 09:21:36 $
d250 1
a250 1
    _tag_bind_core('', tag, seq, cmd, args=nil)
d254 1
a254 1
    _tag_bind_core('+', tag, seq, cmd, args=nil)
d275 1
a275 1
    tk_tcl2ruby tk_call @@path, 'tag', 'cget', tag, "-#{key}"
d288 2
a289 2
      if  key == 'font' || key == 'kanjifont' ||
	  key == 'latinfont' || key == 'asciifont'
d292 1
a292 1
	tk_send 'tag', 'configure', tag, "-#{key}", val
d323 1
a323 1
    l = tk_split_simplelist(tk_send('tag', 'ranges', tag))
d332 1
a332 1
    tk_split_simplelist(tk_send('tag', 'nextrange', tag, first, last))
d336 1
a336 1
    tk_split_simplelist(tk_send('tag', 'prevrange', tag, first, last))
d440 1
a440 10
    if args != [] then
      keys = args.pop
      if keys.kind_of? Hash then
	add(*args) if args != []
	configure(keys)
      else
	args.push keys
	add(*args)
      end
    end
a442 1

d464 1
a464 1
    l = tk_split_simplelist(tk_call(@@t.path, 'tag', 'ranges', @@id))
d473 1
a473 1
    tk_split_simplelist(tk_call(@@t.path, 'tag', 'nextrange', @@id, first, last))
d477 1
a477 1
    tk_split_simplelist(tk_call(@@t.path, 'tag', 'prevrange', @@id, first, last))
a633 12
class TkTextMarkAnchor<TkTextMark
  def initialize(parent,index=nil)
    if not parent.kind_of?(TkText)
      fail format("%s need to be TkText", parent.inspect)
    end
    @@t = parent
    @@path = @@id = 'anchor'
    tk_call @@t.path, 'mark', 'set', @@id, index if index
    @@t._addtag id, self
  end
end

a727 127
  end

  def _dump(type, *index)
    str = tk_send('dump', type, *index)
    result = []
    sel = nil
    i = 0
    while i < str.size
      # retrieve key
      idx = str.index(/ /, i)
      result.push str[i..(idx-1)]
      i = idx + 1
      
      # retrieve value
      case result[-1]
      when 'text'
	if str[i] == ?{
	  # text formed as {...}
	  val, i = _retrieve_braced_text(str, i)
	  result.push val
	else
	  # text which may contain backslahes
	  val, i = _retrieve_backslashed_text(str, i)
	  result.push val
	end
      else
	idx = str.index(/ /, i)
	val = str[i..(idx-1)]
	case result[-1]
	when 'mark'
	  case val
	  when 'insert'
	    result.push TkTextMarkInsert.new(self)
	  when 'current'
	    result.push TkTextMarkCurrent.new(self)
	  when 'anchor'
	    result.push TkTextMarkAnchor.new(self)
	  else
	    result.push tk_tcl2rb(val)
	  end
	when 'tagon'
	  if val == 'sel'
	    if sel
	      result.push sel
	    else
	      result.push TkTextTagSel.new(self)
	    end
	  else
	    result.push tk_tcl2rb val
	  end
	when 'tagoff'
	    result.push tk_tcl2rb sel
	when 'window'
	  result.push tk_tcl2rb val
	end
	i = idx + 1
      end

      # retrieve index
      idx = str.index(/ /, i)
      if idx
	result.push str[i..(idx-1)]
	i = idx + 1
      else
	result.push str[i..-1]
	break
      end
    end
    
    kvis = []
    until result.empty?
      kvis.push [result.shift, result.shift, result.shift]
    end
    kvis  # result is [[key1, value1, index1], [key2, value2, index2], ...]
  end
  private :_dump

  def _retrieve_braced_text(str, i)
    cnt = 0
    idx = i
    while idx < str.size
      case str[idx]
      when ?{
	cnt += 1
      when ?}
	cnt -= 1
	if cnt == 0
	  break
	end
      end
      idx += 1
    end
    return str[i+1..idx-1], idx + 2
  end
  private :_retrieve_braced_text

  def _retrieve_backslashed_text(str, i)
    j = i
    idx = nil
    loop {
      idx = str.index(/ /, j)
      if str[idx-1] == ?\\
	j += 1
      else
	break
      end
    }
    val = str[i..(idx-1)]
    val.gsub!(/\\( |\{|\})/, '\1')
    return val, idx + 1
  end
  private :_retrieve_backslashed_text

  def dump_all(*index)
    _dump('-all', *index)
  end
  def dump_mark(*index)
    _dump('-mark', *index)
  end
  def dump_tag(*index)
    _dump('-tag', *index)
  end
  def dump_text(*index)
    _dump('-text', *index)
  end
  def dump_window(*index)
    _dump('-window', *index)
@
