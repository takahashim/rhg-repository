head	1.13;
access;
symbols
	v1_6_7:1.5.2.5
	v1_6_6:1.5.2.4
	v1_6_5:1.5.2.2
	v1_6_4:1.5.2.2
	v1_7_1:1.6
	v1_6_4_preview4:1.5.2.2
	v1_6_4_preview3:1.5.2.2
	v1_6_4_preview2:1.5
	v1_6_4_preview1:1.5
	v1_6_3:1.5
	ruby_m17n:1.5.0.4
	ruby_1_6:1.5.0.2
	v1_6_2:1.5
	v1_6_1:1.5
	v1_6_0:1.5
	v1_4_6:1.2.2.2
	v1_4_5:1.2.2.2
	v1_4_4:1.2.2.1
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.2
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.2.8
	v1_3_6_repack:1.1.2.8
	v1_3_6:1.1.2.8
	v1_3_5:1.1.2.7
	v1_3_4_990625:1.1.2.6
	v1_3_4_990624:1.1.2.6
	v1_3_4_990611:1.1.2.6
	v1_3_4_990531:1.1.2.4
	v1_3_3_990518:1.1.2.3
	v1_3_3_990513:1.1.2.2
	v1_3_3_990507:1.1.2.1
	ruby_1_3:1.1.0.2;
locks; strict;
comment	@ * @;


1.13
date	2002.01.28.08.44.41;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.27.10.00.33;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.21.15.42.03;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.05.02.15;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.13.08.14.21;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.03.07.19.15;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.06.03.05.17;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.06.15.03.15;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.25.05.55.10;	author matz;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.05.24.04.34.16;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.08.08.48.57;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.37.50;	author matz;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.05.07.08.24.36;	author matz;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	99.05.07.08.24.36;	author matz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	99.05.13.10.01.09;	author matz;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	99.05.17.09.54.19;	author matz;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	99.05.25.08.26.19;	author matz;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	99.06.09.09.21.34;	author matz;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	99.06.11.06.30.00;	author matz;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	99.07.15.07.59.58;	author matz;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	99.07.22.10.37.23;	author matz;	state Exp;
branches;
next	;

1.2.2.1
date	2000.02.08.08.53.59;	author matz;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.06.05.09.01.04;	author matz;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.07.06.51.37;	author eban;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.05.07.06.55.42;	author eban;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.11.13.08.22.29;	author matz;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2001.11.21.15.36.28;	author matz;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2002.01.28.08.42.38;	author matz;	state Exp;
branches;
next	;


desc
@@


1.13
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.

* object.c (Init_Object): remove dup and clone from TrueClass,
  FalseClass, and NilClass.

* array.c (rb_ary_fill): Array#fill takes block to get the value to
  fill.

* string.c (rb_str_to_i): to_i(0) auto-detects base radix.

* array.c (rb_ary_initialize): fill by the block evaluation value
  if block is given.
@
text
@#include	"config.h"
#include	<stdio.h>
#include	<sys/types.h>
#include	<sys/stat.h>
#include	<sys/file.h>
#include	<fcntl.h>
#include	<errno.h>
#include	<pwd.h>
#if !defined(HAVE_OPENPTY) && !defined(HAVE__GETPTY)
#include	<sys/ioctl.h>
#endif
#ifdef HAVE_LIBUTIL_H
#include	<libutil.h>
#endif
#ifdef HAVE_PTY_H
#include	<pty.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#else
#define WIFSTOPPED(status)    (((status) & 0xff) == 0x7f)
#endif
#include <ctype.h>

#include "ruby.h"
#include "rubyio.h"

#include <signal.h>
#ifdef HAVE_SYS_STROPTS_H
#include <sys/stropts.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#define	DEVICELEN	16

#if !defined(HAVE_OPENPTY)
#ifdef __hpux
static
char	*MasterDevice = "/dev/ptym/pty%s",
	*SlaveDevice =  "/dev/pty/tty%s",
	*deviceNo[] = {
		"p0","p1","p2","p3","p4","p5","p6","p7",
		"p8","p9","pa","pb","pc","pd","pe","pf",
		"q0","q1","q2","q3","q4","q5","q6","q7",
		"q8","q9","qa","qb","qc","qd","qe","qf",
		"r0","r1","r2","r3","r4","r5","r6","r7",
		"r8","r9","ra","rb","rc","rd","re","rf",
		"s0","s1","s2","s3","s4","s5","s6","s7",
		"s8","s9","sa","sb","sc","sd","se","sf",
		"t0","t1","t2","t3","t4","t5","t6","t7",
		"t8","t9","ta","tb","tc","td","te","tf",
		"u0","u1","u2","u3","u4","u5","u6","u7",
		"u8","u9","ua","ub","uc","ud","ue","uf",
		"v0","v1","v2","v3","v4","v5","v6","v7",
		"v8","v9","va","vb","vc","vd","ve","vf",
		"w0","w1","w2","w3","w4","w5","w6","w7",
		"w8","w9","wa","wb","wc","wd","we","wf",
		0,
	};
#else  /* NOT HPUX */
#ifdef _IBMESA  /* AIX/ESA */
static 
char	*MasterDevice = "/dev/ptyp%s",
  	*SlaveDevice = "/dev/ttyp%s",
	*deviceNo[] = {
"00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f",
"10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f",
"20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f",
"30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f",
"40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f",
"50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f",
"60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f",
"70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f",
"80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f",
"90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f",
"a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af",
"b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf",
"c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf",
"d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df",
"e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef",
"f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff",
		};
#else
static 
char	*MasterDevice = "/dev/pty%s",
	*SlaveDevice = "/dev/tty%s",
	*deviceNo[] = {
		"p0","p1","p2","p3","p4","p5","p6","p7",
		"p8","p9","pa","pb","pc","pd","pe","pf",
		"q0","q1","q2","q3","q4","q5","q6","q7",
		"q8","q9","qa","qb","qc","qd","qe","qf",
		"r0","r1","r2","r3","r4","r5","r6","r7",
		"r8","r9","ra","rb","rc","rd","re","rf",
		"s0","s1","s2","s3","s4","s5","s6","s7",
		"s8","s9","sa","sb","sc","sd","se","sf",
		0,
	};
#endif /* _IBMESA */
#endif /* HPUX */
#endif /* !defined(HAVE_OPENPTY) */

static char SlaveName[DEVICELEN];

extern int errno;

#ifndef HAVE_SETEUID
# ifdef HAVE_SETREUID
#  define seteuid(e)	setreuid(-1, (e))
# else /* NOT HAVE_SETREUID */
#  ifdef HAVE_SETRESUID
#   define seteuid(e)	setresuid(-1, (e), -1)
#  else /* NOT HAVE_SETRESUID */
    /* I can't set euid. (;_;) */
#  endif /* HAVE_SETRESUID */
# endif /* HAVE_SETREUID */
#endif /* NO_SETEUID */

static VALUE eChildExited;

static VALUE
echild_status(self)
    VALUE self;
{
    return rb_ivar_get(self, rb_intern("status"));
}

struct pty_info {
    int fd;
    pid_t child_pid;
    VALUE thread;
};

static VALUE
pty_syswait(info)
    struct pty_info *info;
{
    extern VALUE rb_last_status;
    int cpid, status;
    char buf[1024];
    VALUE exc, st;
    char *state = "changed";

    cpid = rb_waitpid(info->child_pid, &status, WUNTRACED);
    st = rb_last_status;
    
    if (cpid == 0 || cpid == -1)
	return Qnil;

#ifdef IF_STOPPED
    if (IF_STOPPED(status)) { /* suspend */
	state = "stopped";
    }
#else
#ifdef WIFSTOPPED
    if (WIFSTOPPED(status)) { /* suspend */
	state = "stopped";
    }
#else
---->> Either IF_STOPPED or WIFSTOPPED is needed <<----
#endif /* WIFSTOPPED */
#endif /* IF_STOPPED */
    if (WIFEXITED(status)) {
	state = "exit";
    }
    
    snprintf(buf, sizeof(buf), "pty - %s: %d", state, cpid);
    exc = rb_exc_new2(eChildExited, buf);
    rb_iv_set(exc, "status", st);
    rb_funcall(info->thread, rb_intern("raise"), 1, exc);
    return Qnil;
}

static void getDevice _((int*, int*));

struct exec_info {
    int argc;
    VALUE *argv;
};

static VALUE
pty_exec(arg)
    struct exec_info *arg;
{
    return rb_f_exec(arg->argc, arg->argv);
}

static void
establishShell(argc, argv, info)
    int argc;
    VALUE *argv;
    struct pty_info *info;
{	
    static int		i,master,slave,currentPid;
    char		*p,*getenv();
    struct passwd	*pwent;
    VALUE		v;
    struct exec_info	arg;
    int			status;

    if (argc == 0) {
	char *shellname;

	if ((p = getenv("SHELL")) != NULL) {
	    shellname = p;
	}
	else {
	    pwent = getpwuid(getuid());
	    if (pwent && pwent->pw_shell)
		shellname = pwent->pw_shell;
	    else
		shellname = "/bin/sh";
	}
	v = rb_str_new2(shellname);
	argc = 1;
	argv = &v;
    }
    getDevice(&master,&slave);

    info->thread = rb_thread_current();
    currentPid = getpid();
    if((i = fork()) < 0) {
	rb_sys_fail("fork failed");
    }

    if(i == 0) {	/* child */
	currentPid = getpid();	

	/*
	 * Set free from process group and controlling terminal
	 */
#ifdef HAVE_SETSID
	(void) setsid();
#else /* HAS_SETSID */
# ifdef HAVE_SETPGRP
#  ifdef SETGRP_VOID
	if (setpgrp() == -1)
	    perror("setpgrp()");
#  else /* SETGRP_VOID */
	if (setpgrp(0, currentPid) == -1)
	    rb_sys_fail("setpgrp()");
	if ((i = open("/dev/tty", O_RDONLY)) < 0)
	    rb_sys_fail("/dev/tty");
	else {
	    if (ioctl(i, TIOCNOTTY, (char *)0))
		perror("ioctl(TIOCNOTTY)");
	    close(i);
	}
#  endif /* SETGRP_VOID */
# endif /* HAVE_SETPGRP */
#endif /* HAS_SETSID */

	/*
	 * obtain new controlling terminal
	 */
#if defined(TIOCSCTTY)
	close(master);
	(void) ioctl(slave, TIOCSCTTY, (char *)0);
	/* errors ignored for sun */
#else
	close(slave);
	slave = open(SlaveName, O_RDWR);
	if (slave < 0) {
	    perror("open: pty slave");
	    _exit(1);
	}
	close(master);
#endif
	dup2(slave,0);
	dup2(slave,1);
	dup2(slave,2);
	close(slave);
#if defined(HAVE_SETEUID) || defined(HAVE_SETREUID) || defined(HAVE_SETRESUID)
	seteuid(getuid());
#endif

	arg.argc = argc;
	arg.argv = argv;
	rb_protect(pty_exec, (VALUE)&arg, &status);
	sleep(1);
	_exit(1);
    }

    close(slave);

    info->child_pid = i;
    info->fd = master;
}

static VALUE
pty_kill_child(info)
    struct pty_info *info;
{
    if (rb_funcall(info->thread, rb_intern("alive?"), 0, 0) == Qtrue &&
	kill(info->child_pid, 0) == 0) {
	rb_thread_schedule();
	if (kill(info->child_pid, SIGTERM) == 0) {
	    rb_thread_schedule();
	    if (kill(info->child_pid, 0) == 0) {
		kill(info->child_pid, SIGINT);
		rb_thread_schedule();
		if (kill(info->child_pid, 0) == 0)
		    kill(info->child_pid, SIGKILL);
	    }
	}
    }
    rb_funcall(info->thread, rb_intern("join"), 0, 0);
    return Qnil;
}


#ifdef HAVE_OPENPTY
/*
 * Use openpty(3) of 4.3BSD Reno and later,
 * or the same interface function.
 */
static void
getDevice(master,slave)
    int	*master,*slave;
{
    if (openpty(master, slave, SlaveName,
		(struct termios *)0, (struct winsize *)0) == -1) {
	rb_raise(rb_eRuntimeError, "openpty() failed");
    }
}
#else /* HAVE_OPENPTY */
#ifdef HAVE__GETPTY
static void
getDevice(master,slave)
    int	*master,*slave;
{
    char *name;

    if (!(name = _getpty(master, O_RDWR, 0622, 0))) {
	rb_raise(rb_eRuntimeError, "_getpty() failed");
    }

    *slave = open(name, O_RDWR);
    strcpy(SlaveName, name);
}
#else /* HAVE__GETPTY */
static void
getDevice(master,slave)
    int	*master,*slave;
{
    char **p;
    int	 i,j;
    char MasterName[DEVICELEN];

#ifdef HAVE_PTSNAME
    char *pn;
    void (*s)();

    extern char *ptsname(int);
    extern int unlockpt(int);
    extern int grantpt(int);

    if((i = open("/dev/ptmx", O_RDWR, 0)) != -1) {
	s = signal(SIGCHLD, SIG_DFL);
	if(grantpt(i) != -1) {
	    signal(SIGCHLD, s);
	    if(unlockpt(i) != -1) {
		if((pn = ptsname(i)) != NULL) {
		    if((j = open(pn, O_RDWR, 0)) != -1) {
#if defined I_PUSH && !defined linux
			if(ioctl(j, I_PUSH, "ptem") != -1) {
			    if(ioctl(j, I_PUSH, "ldterm") != -1) {
#endif
				*master = i;
				*slave = j;
				strcpy(SlaveName, pn);
				return;
#if defined I_PUSH && !defined linux
			    }
			}
#endif
		    }
		}
	    }
	}
	close(i);
    }
    rb_raise(rb_eRuntimeError, "Cannot get Master/Slave device");
#else
    for (p = deviceNo; *p != NULL; p++) {
	sprintf(MasterName,MasterDevice,*p);
	if ((i = open(MasterName,O_RDWR,0)) >= 0) {
	    *master = i;
	    sprintf(SlaveName,SlaveDevice,*p);
	    if ((j = open(SlaveName,O_RDWR,0)) >= 0) {
		*slave = j;
		chown(SlaveName, getuid(), getgid());
		chmod(SlaveName, 0622);
		return;
	    }
	    close(i);
	}
    }
    rb_raise(rb_eRuntimeError, "Cannot get %s", SlaveName);
#endif
}
#endif /* HAVE__GETPTY */
#endif /* HAVE_OPENPTY */

static void
freeDevice()
{
    chmod(SlaveName, 0666);
    chown(SlaveName, 0, 0);
}

/* ruby function: getpty */
static VALUE
pty_getpty(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE res, th;
    struct pty_info info, thinfo;
    OpenFile *wfptr,*rfptr;
    VALUE rport = rb_obj_alloc(rb_cFile);
    VALUE wport = rb_obj_alloc(rb_cFile);
  
    MakeOpenFile(rport, rfptr);
    MakeOpenFile(wport, wfptr);

    establishShell(argc, argv, &info);

    rfptr->mode = rb_io_mode_flags("r");
    rfptr->f = fdopen(info.fd, "r");
    rfptr->path = strdup(SlaveName);

    wfptr->mode = rb_io_mode_flags("w") | FMODE_SYNC;
    wfptr->f = fdopen(dup(info.fd), "w");
    wfptr->path = strdup(SlaveName);

    res = rb_ary_new2(3);
    rb_ary_store(res,0,(VALUE)rport);
    rb_ary_store(res,1,(VALUE)wport);
    rb_ary_store(res,2,INT2FIX(info.child_pid));

    th = rb_thread_create(pty_syswait, (void*)&info);
    thinfo.thread = th;
    thinfo.child_pid = info.child_pid;

    if (rb_block_given_p()) {
	rb_ensure(rb_yield, res, pty_kill_child, (VALUE)&thinfo);
	return Qnil;
    }
    return res;
}

/* ruby function: protect_signal - obsolete */
static VALUE
pty_protect(self)
    VALUE self;
{
    rb_warn("PTY::protect_signal is no longer needed");
    rb_yield(Qnil);
    return self;
}

/* ruby function: reset_signal - obsolete */
static VALUE
pty_reset_signal(self)
    VALUE self;
{
    rb_warn("PTY::reset_signal is no longer needed");
    return self;
}

static VALUE cPTY;

void
Init_pty()
{
    cPTY = rb_define_module("PTY");
    rb_define_module_function(cPTY,"getpty",pty_getpty,-1);
    rb_define_module_function(cPTY,"spawn",pty_getpty,-1);
    rb_define_module_function(cPTY,"protect_signal",pty_protect,0);
    rb_define_module_function(cPTY,"reset_signal",pty_reset_signal,0);

    eChildExited = rb_define_class_under(cPTY,"ChildExited",rb_eRuntimeError);
    rb_define_method(eChildExited,"status",echild_status,0);
}
@


1.12
log
@* marshal.c (w_float): must distinguish -0.0 from 0.0.

* gc.c (gc_mark_all): tweak mark order for little bit better scan.

* gc.c (rb_gc_mark): ditto.

* gc.c (rb_gc): ditto.

* enum.c (sort_by_i): slight performance boost.

* gc.c (gc_mark_rest): should call gc_mark_children(), not gc_mark().

* gc.c (rb_gc_mark): may cause infinite looop.
@
text
@d436 1
a436 1
    wfptr->mode = rb_io_mode_flags("w");
@


1.11
log
@* parse.y (str_extend): should check nesting parentheses in #{}.

* process.c (pst_wstopsig): returns nil unless WIFSTOPPED() is
  non-zero.

* process.c (pst_wtermsig): returns nil unless WIFSIGNALED() is
  non-zero.

* process.c (pst_wexitstatus): returns nil unless WIFEXITED() is
  non-zero.

* eval.c (rb_thread_select): tv_sec and tv_usec should not be
  negative.

* signal.c (posix_signal): do not set SA_RESTART for SIGVTALRM.

* parse.y (call_args2): block_arg may follow the first argument in
  call_args2.

* eval.c (stack_check): should avoid stack length check during
  raising SystemStackError exception.
@
text
@d352 1
a352 1
#ifdef HAVE_DEV_PTMX
d367 1
a367 1
#if defined I_PUSH
d375 1
a375 1
#if defined I_PUSH
d388 1
a388 1
	sprintf(MasterName ,MasterDevice,*p);
d391 1
a391 1
	    sprintf(SlaveName ,SlaveDevice,*p);
@


1.10
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* massages: replace "wrong #" by "wrong number".

* marshal.c (w_float): output Infinity and NaN explicitly.

* marshal.c (r_object): support new explicit float format.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.

* array.c (rb_ary_join): dumped core if sep is not T_STRING nor T_NIL.

* array.c (rb_ary_join): buffer size calculattion was wrong.

* array.c (rb_ary_to_s): if rb_output_fs is nil, insert newlines
  between array elements (use rb_default_rs as newline litral)
  [experimental].

* gc.c (init_mark_stack): no need to clear mark_stack.

* gc.c (gc_mark_all): need to handle finalizer mark.

* gc.c (gc_mark_rest): use MEMCPY instead of memcpy.

* gc.c (rb_gc_mark): earlier const check to avoid pusing special
  constants into mark stack.

* numeric.c (fix_to_s): 'to_s' now takes optional argument to
  specify radix. [new]

* bignum.c (rb_big_to_s): ditto. [new]
@
text
@d12 6
d97 2
d121 9
a135 12
static void
pty_raise(thread, cpid, stop)
    VALUE thread;
    int cpid;
    int stop;
{
    char buf[1024];

    snprintf(buf, sizeof(buf), "pty - %s: %d", stop ? "stopped" : "changed", cpid);
    rb_funcall(thread, rb_intern("raise"), 1, rb_str_new2(buf));
}

d140 1
d142 3
d147 1
a147 1
    printf("cpid: %d (%d)\n", cpid, status);
d154 1
a154 1
	pty_raise(info->thread, cpid, Qtrue);
d159 1
a159 1
	pty_raise(info->thread, cpid, Qtrue);
d165 3
d169 4
a172 1
    pty_raise(info->thread, cpid, Qfalse);
d178 12
d199 3
a201 1
    VALUE v;
d222 1
a228 2
	/* int argc;
	   char *argv[1024]; */
d279 3
a281 1
	rb_f_exec(argc, argv);
d292 22
d401 1
a401 1
    rb_raise(rb_eRuntimeError, "Cannot get %s\n", SlaveDevice);
d422 1
a422 1
    struct pty_info info;
d434 1
a434 1
    rfptr->path = 0; /*strdup(RSTRING(command)->ptr); */
d438 1
a438 1
    wfptr->path = 0; /* strdup(RSTRING(command)->ptr); */
a444 1
    info.thread = rb_thread_current();
d446 3
d450 2
a451 2
	res = rb_yield((VALUE)res);
	rb_funcall(th, rb_intern("kill"), 0, 0);
d485 3
@


1.9
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* eval.c (rb_eval_cmd): should not upgrade safe level unless
  explicitly specified by argument newly added.

* signal.c (sig_trap): should not allow tainted trap closure.

* variable.c (rb_f_trace_var): should not allow trace_var on safe
  level higher than 3.

* variable.c (rb_f_trace_var): should not allow tainted trace
  closure.

* gc.c: do not use static stack until system stack overflows.

* eval.c (eval): should call Exception#exception instead of
  calling rb_exc_new3() directly.

* error.c (exc_exception): set "mesg" directly to the clone.  it
  might be better to set mesg via some method for flexibility.

* variable.c (cvar_override_check): should print original module
  name, if 'a' is T_ICLASS.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.
@
text
@d4 1
d35 1
d59 1
d81 1
d97 1
a97 1
char	SlaveName[DEVICELEN];
d114 3
a116 2
  int fd;
  pid_t child_pid;
d120 2
a121 1
pty_raise(cpid)
d123 1
d127 2
a128 4
    snprintf(buf, sizeof(buf),
	     "eval %%Q{Thread.main.raise 'pty - stopped: %d'}, nil, \"%s\", %d",
	     cpid, ruby_sourcefile, ruby_sourceline);
    rb_eval_string(buf);
d132 2
a133 2
pty_syswait(pid)
    int pid;
d137 3
a139 3
    cpid = rb_waitpid(pid, &status, WUNTRACED);

    printf("PTY command (%d) finished (%d:%d)\n", pid, cpid, status);
d145 1
a145 1
	pty_raise(cpid);
d150 1
a150 1
	pty_raise(cpid);
d157 1
d164 3
a166 2
establishShell(shellname, info)
    char *shellname;
d169 1
a169 1
    static int		i,j,master,slave,currentPid;
d172 5
a176 3
    RETSIGTYPE		chld_changed();
    
    if (shellname[0] == '\0') {
d187 3
d194 1
a194 1
    if((i = vfork()) < 0) {
d199 2
a200 2
	int argc;
	char *argv[1024];
a246 1

d251 1
a251 12
	argc = 0;
	for (i = 0; shellname[i];) {
	    while (isspace(shellname[i])) i++;
	    for (j = i; shellname[j] && !isspace(shellname[j]); j++);
	    argv[argc] = (char*)xmalloc(j-i+1);
	    strncpy(argv[argc],&shellname[i],j-i);
	    argv[argc][j-i] = 0;
	    i = j;
	    argc++;
	}
	argv[argc] = NULL;
	execvp(argv[0],argv);
d364 4
a367 2
pty_getpty(self, command)
    VALUE self, command;
d378 1
a378 5
    if (TYPE(command) == T_ARRAY)
	command = rb_ary_join(command,rb_str_new2(" "));
    Check_SafeStr(command);

    establishShell(RSTRING(command)->ptr,&info);
d382 1
a382 1
    rfptr->path = strdup(RSTRING(command)->ptr);
d386 1
a386 1
    wfptr->path = strdup(RSTRING(command)->ptr);
d393 2
a394 2
    printf("start watching PTY command (%d)\n", info.child_pid);
    th = rb_thread_create(pty_syswait, (void*)info.child_pid);
a397 4
	return res;
    }
    else {
	return res;
d399 1
d427 2
a428 2
    rb_define_module_function(cPTY,"getpty",pty_getpty,1);
    rb_define_module_function(cPTY,"spawn",pty_getpty,1);
@


1.8
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d364 2
a365 2
pty_getpty(self, shell)
    VALUE self, shell;
d376 5
a380 1
    establishShell(RSTRING(shell)->ptr,&info);
d384 1
a384 1
    rfptr->path = strdup(RSTRING(shell)->ptr);
d388 1
a388 1
    wfptr->path = strdup(RSTRING(shell)->ptr);
@


1.7
log
@* string.c (rb_str_lstrip_bang): new method.

* string.c (rb_str_rstrip_bang): new method.

* string.c (rb_str_associate): should consider STR_ASSOC too.

* eval.c (rb_undefined): do not recurse if method_missing is
  undefined.

* process.c (proc_waitpid): now all arguments are optional.

* process.c (Init_process): waitpid is now alias to wait.

* process.c (Init_process): waitpid2 is now alias to wait2.

* process.c (rb_waitpid): made public.

* ext/pty/pty.c (pty_getpty): avoid disturbing SIGCHLD using
  thread and rb_waitpid.

* process.c (proc_getpgrp): now takes no argument on all
  platforms.

* process.c (proc_setpgrp): ditto.

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::pack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::pack_sockaddr_un(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::unpack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::unpack_sockaddr_un(). [new]
@
text
@d370 2
a371 2
    NEWOBJ(rport, struct RFile);
    NEWOBJ(wport, struct RFile);
a372 1
    OBJSETUP(rport, rb_cFile, T_FILE);
a373 2

    OBJSETUP(wport, rb_cFile, T_FILE);
d399 1
a399 1
	return (VALUE)res;
@


1.6
log
@forgot some checkins.
@
text
@a96 4
#define MAX_PTY 16
static int n_pty,last_pty;
static int chld_pid[MAX_PTY];

d115 2
a116 2
set_signal_action(action)
    RETSIGTYPE (*action)();
d118 1
a118 25
#ifdef __hpux
    struct sigvec sv;
    /*
     * signal SIGCHLD should be delivered on stop of the child
     */
    sv.sv_handler = action;
    sv.sv_mask = sigmask(SIGCHLD);
    sv.sv_flags = SV_BSDSIG;
    sigvector(SIGCHLD, &sv, (struct sigvec *) 0);
#else	/* not HPUX */
#if defined(SA_NOCLDSTOP)
    struct sigaction sa;
    /*
     * signal SIGCHLD should be delivered on stop of the child
     * (for SVR4)
     */
    sa.sa_handler = action;
    sigemptyset(&sa.sa_mask);
    sigaddset(&sa.sa_mask, SIGCHLD);
    sa.sa_flags = 0;	/* SA_NOCLDSTOP flag is removed */
    sigaction(SIGCHLD, &sa, (struct sigaction *) 0);
#else
    signal(SIGCHLD,action);
#endif
#endif /* not HPUX */
d120 4
d126 3
a128 2
static void
reset_signal_action()
d130 1
a130 2
    set_signal_action(SIG_DFL);
}
d132 1
a132 6
static RETSIGTYPE
chld_changed()
{
    int cpid;
    int i,n = -1;
    int statusp;
d134 3
a136 17
    for (;;) {
#ifdef HAVE_WAITPID
	cpid = waitpid(-1, &statusp, WUNTRACED|WNOHANG);
#else
	cpid = wait3(&statusp, WUNTRACED|WNOHANG, 0);
#endif
	if (cpid == 0 || cpid == -1)
	    return;
        for (i = 0; i < last_pty; i++) {
	    if (chld_pid[i] == cpid) {
		n = i;
		goto catched;
	    }
	}
        rb_raise(rb_eRuntimeError, "fork: %d", cpid);
    }
  catched:
d139 2
a140 2
    if (IF_STOPPED(statusp)) { /* suspend */
	rb_raise(rb_eRuntimeError, "Stopped: %d",cpid);
d144 2
a145 2
    if (WIFSTOPPED(statusp)) { /* suspend */
	rb_raise(rb_eRuntimeError, "Stopped: %d",cpid);
d151 2
a152 7
    if (n >= 0) {
	chld_pid[n] = 0;
	n_pty--;
	if (n_pty == 0)
	    reset_signal_action();
    }
    rb_raise(rb_eRuntimeError, "Child_changed: %d",cpid);
a181 1
    set_signal_action(chld_changed);
a257 13
    if (n_pty == last_pty) {
	chld_pid[n_pty] = i;
	n_pty++;
	last_pty++;
    }
    else {
	for (j = 0; j < last_pty; j++) {
	    if (chld_pid[j] == 0) {
		chld_pid[j] = i;
		n_pty++;
	    }
	}
    }
d367 1
a367 1
    VALUE res;
a372 4
    if (n_pty == MAX_PTY+1) {
	rb_raise(rb_eRuntimeError, "Too many ptys are open");
    }

d394 2
d397 3
a399 3
	rb_yield((VALUE)res);
	reset_signal_action();
	return Qnil;
d406 1
a406 1
/* ruby function: protect_signal */
d411 1
a411 1
    reset_signal_action();
a412 1
    set_signal_action(chld_changed);
d416 1
d421 1
a421 1
    reset_signal_action();
@


1.5
log
@2000-05-25
@
text
@d455 1
a455 1
    res = rb_ary_new2(2);
@


1.5.2.1
log
@* lib/ftools.rb (syscopy): chmod destination file only if
  it does not exist.
@
text
@d362 1
a362 1
#ifdef HAVE_PTSNAME
d377 1
a377 1
#if defined I_PUSH && !defined linux
d385 1
a385 1
#if defined I_PUSH && !defined linux
@


1.5.2.2
log
@revert
@
text
@d362 1
a362 1
#ifdef HAVE_DEV_PTMX
@


1.5.2.3
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.

* mkconfig.rb: use String#dump to generate Ruby string literal.

* range.c (range_eql): should override 'eql?'
@
text
@d426 2
a427 2
pty_getpty(self, command)
    VALUE self, command;
d445 1
a445 5
    if (TYPE(command) == T_ARRAY)
	command = rb_ary_join(command,rb_str_new2(" "));
    Check_SafeStr(command);

    establishShell(RSTRING(command)->ptr,&info);
d449 1
a449 1
    rfptr->path = strdup(RSTRING(command)->ptr);
d453 1
a453 1
    wfptr->path = strdup(RSTRING(command)->ptr);
d461 2
a462 1
	rb_ensure(rb_yield, (VALUE)res, (VALUE (*)())reset_signal_action, Qnil);
@


1.5.2.4
log
@* parse.y (str_extend): should check nesting parentheses in #{}.

* eval.c (rb_thread_select): tv_sec and tv_usec should not be
  negative.

* signal.c (posix_signal): do not set SA_RESTART for SIGVTALRM.
@
text
@d459 1
a459 1
    res = rb_ary_new2(4);
a462 1
    rb_ary_store(res,3,rb_str_new2(SlaveName));
@


1.5.2.5
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.
@
text
@d455 1
a455 1
    wfptr->mode = rb_io_mode_flags("w") | FMODE_SYNC;
@


1.4
log
@2000-05-24
@
text
@d18 2
a19 2
#include <ruby.h>
#include <rubyio.h>
@


1.3
log
@2000-02-08
@
text
@d460 1
a460 1
    if (rb_iterator_p()) {
@


1.2
log
@remove marshal/gtk/kconv
@
text
@d285 1
d287 1
@


1.2.2.1
log
@2000-02-08
@
text
@a284 1
#if defined(HAVE_SETEUID) || defined(HAVE_SETREUID) || defined(HAVE_SETRESUID)
a285 1
#endif
@


1.2.2.2
log
@2000-06-05
@
text
@d18 2
a19 2
#include "ruby.h"
#include "rubyio.h"
@


1.1
log
@file pty.c was initially added on branch ruby_1_3.
@
text
@d1 497
@


1.1.2.1
log
@990507
@
text
@a0 485
#include	"config.h"
#include	<stdio.h>
#include	<sys/types.h>
#include	<sys/file.h>
#include	<fcntl.h>
#include	<errno.h>
#include	<pwd.h>
#if !defined(HAVE_OPENPTY) && !defined(HAVE__GETPTY)
#include	<sys/ioctl.h>
#endif
#include <sys/wait.h>
#include <ctype.h>

#include <ruby.h>
#include <rubyio.h>

#include <signal.h>
#ifdef HAVE_SYS_STROPTS_H
#include <sys/stropts.h>
#endif

#define	DEVICELEN	16

#if !defined(HAVE_OPENPTY)
#ifdef hpux
char	*MasterDevice = "/dev/ptym/pty%s",
	*SlaveDevice =  "/dev/pty/tty%s",
	*deviceNo[] = {
		"p0","p1","p2","p3","p4","p5","p6","p7",
		"p8","p9","pa","pb","pc","pd","pe","pf",
		"q0","q1","q2","q3","q4","q5","q6","q7",
		"q8","q9","qa","qb","qc","qd","qe","qf",
		"r0","r1","r2","r3","r4","r5","r6","r7",
		"r8","r9","ra","rb","rc","rd","re","rf",
		"s0","s1","s2","s3","s4","s5","s6","s7",
		"s8","s9","sa","sb","sc","sd","se","sf",
		"t0","t1","t2","t3","t4","t5","t6","t7",
		"t8","t9","ta","tb","tc","td","te","tf",
		"u0","u1","u2","u3","u4","u5","u6","u7",
		"u8","u9","ua","ub","uc","ud","ue","uf",
		"v0","v1","v2","v3","v4","v5","v6","v7",
		"v8","v9","va","vb","vc","vd","ve","vf",
		"w0","w1","w2","w3","w4","w5","w6","w7",
		"w8","w9","wa","wb","wc","wd","we","wf",
		0,
	};
#else  /* NOT HPUX */
#ifdef _IBMESA  /* AIX/ESA */
char	*MasterDevice = "/dev/ptyp%s",
  	*SlaveDevice = "/dev/ttyp%s",
	*deviceNo[] = {
"00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f",
"10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f",
"20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f",
"30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f",
"40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f",
"50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f",
"60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f",
"70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f",
"80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f",
"90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f",
"a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af",
"b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf",
"c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf",
"d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df",
"e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef",
"f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff",
		};
#else
char	*MasterDevice = "/dev/pty%s",
	*SlaveDevice = "/dev/tty%s",
	*deviceNo[] = {
		"p0","p1","p2","p3","p4","p5","p6","p7",
		"p8","p9","pa","pb","pc","pd","pe","pf",
		"q0","q1","q2","q3","q4","q5","q6","q7",
		"q8","q9","qa","qb","qc","qd","qe","qf",
		"r0","r1","r2","r3","r4","r5","r6","r7",
		"r8","r9","ra","rb","rc","rd","re","rf",
		0,
	};
#endif /* _IBMESA */
#endif /* HPUX */
#endif /* !defined(HAVE_OPENPTY) */

char	SlaveName[DEVICELEN];

extern int errno;

#define MAX_PTY 16
static int n_pty,last_pty;
static int chld_pid[MAX_PTY];

#ifndef HAVE_SETEUID
# ifdef HAVE_SETREUID
#  define seteuid(e)	setreuid(-1, (e))
# else /* NOT HAVE_SETREUID */
#  ifdef HAVE_SETRESUID
#   define seteuid(e)	setresuid(-1, (e), -1)
#  else /* NOT HAVE_SETRESUID */
    /* I can't set euid. (;_;) */
#  endif /* HAVE_SETRESUID */
# endif /* HAVE_SETREUID */
#endif /* NO_SETEUID */

struct pty_info {
  int fd;
  pid_t child_pid;
};

static void
set_signal_action(RETSIGTYPE (*action)())
{
#ifdef hpux
    struct sigvec sv;
    /*
     * signal SIGCHLD should be delivered on stop of the child
     */
    sv.sv_handler = action;
    sv.sv_mask = sigmask(SIGCHLD);
    sv.sv_flags = SV_BSDSIG;
    sigvector(SIGCHLD, &sv, (struct sigvec *) 0);
#else	/* not HPUX */
#if defined(SA_NOCLDSTOP)
    struct sigaction sa;
    /*
     * signal SIGCHLD should be delivered on stop of the child
     * (for SVR4)
     */
    sa.sa_handler = action;
    sigemptyset(&sa.sa_mask);
    sigaddset(&sa.sa_mask, SIGCHLD);
    sa.sa_flags = 0;	/* SA_NOCLDSTOP flag is removed */
    sigaction(SIGCHLD, &sa, (struct sigaction *) 0);
#else
    signal(SIGCHLD,action);
#endif
#endif /* not HPUX */

}

static void
reset_signal_action()
{
    set_signal_action(SIG_DFL);
}

static RETSIGTYPE
chld_changed()
{
    int cpid;
    int i,n = -1;
    int statusp;

    for (;;) {
#ifdef HAVE_WAITPID
	cpid = waitpid(-1, &statusp, WUNTRACED|WNOHANG);
#else
	cpid = wait3((int *) &statusp, WUNTRACED|WNOHANG, 0);
#endif
	if (cpid == 0 || cpid == -1)
	    return;
        for (i = 0; i < last_pty; i++) {
	    if (chld_pid[i] == cpid) {
		n = i;
		goto catched;
	    }
	}
        rb_raise(rb_eRuntimeError, "fork: %d", cpid);
    }
  catched:

#ifdef IF_STOPPED
    if (IF_STOPPED(statusp)) { /* suspend */
	rb_raise(rb_eRuntimeError, "Stopped: %d",cpid);
    }
#else
#ifdef WIFSTOPPED
    if (WIFSTOPPED(statusp)) { /* suspend */
	rb_raise(rb_eRuntimeError, "Stopped: %d",cpid);
    }
#else
#error "Either IF_STOPPED or WIFSTOPPED is needed"
#endif /* WIFSTOPPED */
#endif /* IF_STOPPED */
    if (n >= 0) {
	chld_pid[n] = 0;
	n_pty--;
	if (n_pty == 0)
	    reset_signal_action();
    }
    rb_raise(rb_eRuntimeError, "Child_changed: %d",cpid);
}

static void getDevice _((int*, int*));

static void
establishShell(char *shellname, struct pty_info *info)
{	
    static int		i,j,master,slave,currentPid;
    static char		procName[32];
    char		*p,*getenv();
    struct passwd	*pwent;
    RETSIGTYPE		chld_changed();
    
    if (shellname[0] == '\0') {
	if ((p = getenv("SHELL")) != NULL) {
	    shellname = p;
	}
	else {
	    pwent = getpwuid(getuid());
	    if (pwent && pwent->pw_shell)
		shellname = pwent->pw_shell;
	    else
		shellname = "/bin/sh";
	}
    }
    getDevice(&master,&slave);

    currentPid = getpid();
    set_signal_action(chld_changed);
    if((i = vfork()) < 0) {
	rb_sys_fail("fork failed");
    }

    if(i == 0) {	/* child */
	int argc;
	char *argv[1024];
	currentPid = getpid();	

	/*
	 * Set free from process group and controlling terminal
	 */
#ifdef HAVE_SETSID
	(void) setsid();
#else /* HAS_SETSID */
# ifdef HAVE_SETPGRP
#  ifdef SETGRP_VOID
	if (setpgrp() == -1)
	    perror("setpgrp()");
#  else /* SETGRP_VOID */
	if (setpgrp(0, currentPid) == -1)
	    rb_sys_fail("setpgrp()");
	if ((i = open("/dev/tty", O_RDONLY)) < 0)
	    rb_sys_fail("/dev/tty");
	else {
	    if (ioctl(i, TIOCNOTTY, (char *)0))
		perror("ioctl(TIOCNOTTY)");
	    close(i);
	}
#  endif /* SETGRP_VOID */
# endif /* HAVE_SETPGRP */
#endif /* HAS_SETSID */

	/*
	 * obtain new controlling terminal
	 */
#if defined(TIOCSCTTY)
	close(master);
	(void) ioctl(slave, TIOCSCTTY, (char *)0);
	/* errors ignored for sun */
#else
	close(slave);
	slave = open(SlaveName, O_RDWR);
	if (slave < 0) {
	    perror("open: pty slave");
	    _exit(1);
	}
	close(master);
#endif
	dup2(slave,0);
	dup2(slave,1);
	dup2(slave,2);
	close(slave);

	seteuid(getuid());

	argc = 0;
	for (i = 0; shellname[i];) {
	    while (isspace(shellname[i])) i++;
	    for (j = i; shellname[j] && !isspace(shellname[j]); j++);
	    argv[argc] = (char*)xmalloc(j-i+1);
	    strncpy(argv[argc],&shellname[i],j-i);
	    argv[argc][j-i] = 0;
	    i = j;
	    argc++;
	}
	argv[argc] = NULL;
	execvp(argv[0],argv);
	sleep(1);
	_exit(1);
    }

    close(slave);

    if (n_pty == last_pty) {
	chld_pid[n_pty] = i;
	n_pty++;
	last_pty++;
    }
    else {
	for (j = 0; j < last_pty; j++) {
	    if (chld_pid[j] == 0) {
		chld_pid[j] = i;
		n_pty++;
	    }
	}
    }
    info->child_pid = i;
    info->fd = master;
}

#ifdef HAVE_OPENPTY
/*
 * Use openpty(3) of 4.3BSD Reno and later,
 * or the same interface function.
 */
static void
getDevice(master,slave)
    int	*master,*slave;
{
    if (openpty(master, slave, SlaveName,
		(struct termios *)0, (struct winsize *)0) == -1) {
	rb_raise(rb_eRuntimeError, "openpty() failed");
    }
}
#else /* HAVE_OPENPTY */
#ifdef HAVE__GETPTY
static void
getDevice(master,slave)
    int	*master,*slave;
{
    char *name;

    if (!(name = _getpty(master, O_RDWR, 0622, 0))) {
	rb_raise(rb_eRuntimeError, "_getpty() failed");
    }

    *slave = open(name, O_RDWR);
    strcpy(SlaveName, name);
}
#else /* HAVE__GETPTY */
static void
getDevice(master,slave)
    int	*master,*slave;
{
    char **p;
    int	 i,j;
    char MasterName[DEVICELEN];

#ifdef HAVE_DEV_PTMX
    char *pn;
    void (*s)();

    extern char *ptsname(int);
    extern int unlockpt(int);
    extern int grantpt(int);

    if((i = open("/dev/ptmx", O_RDWR, 0)) != -1) {
	s = signal(SIGCHLD, SIG_DFL);
	if(grantpt(i) != -1) {
	    signal(SIGCHLD, s);
	    if(unlockpt(i) != -1) {
		if((pn = ptsname(i)) != NULL) {
		    if((j = open(pn, O_RDWR, 0)) != -1) {
			if(ioctl(j, I_PUSH, "ptem") != -1) {
			    if(ioctl(j, I_PUSH, "ldterm") != -1) {
				*master = i;
				*slave = j;
				strcpy(SlaveName, pn);
				return;
			    }
			}
		    }
		}
	    }
	}
	close(i);
    }
    rb_raise(rb_eRuntimeError, "Cannot get Master/Slave device");
#else
    for (p = deviceNo; *p != NULL; p++) {
	sprintf(MasterName ,MasterDevice,*p);
	if ((i = open(MasterName,O_RDWR,0)) >= 0) {
	    *master = i;
	    sprintf(SlaveName ,SlaveDevice,*p);
	    if ((j = open(SlaveName,O_RDWR,0)) >= 0) {
		*slave = j;
		chown(SlaveName, getuid(), getgid());
		chmod(SlaveName, 0622);
		return;
	    }
	    close(i);
	}
    }
    rb_raise(rb_eRuntimeError, "Cannot get %s\n", SlaveDevice);
#endif
}
#endif /* HAVE__GETPTY */
#endif /* HAVE_OPENPTY */

static void
freeDevice()
{
    chmod(SlaveName, 0666);
    chown(SlaveName, 0, 0);
}

/* ruby function: getpty */
static VALUE
pty_getpty(self, shell)
    VALUE self, shell;
{
    VALUE res;
    struct pty_info info;
    OpenFile *wfptr,*rfptr;
    NEWOBJ(rport, struct RFile);
    NEWOBJ(wport, struct RFile);
  
    if (n_pty == MAX_PTY+1) {
	rb_raise(rb_eRuntimeError, "Too many ptys are open");
    }

    OBJSETUP(rport, rb_cFile, T_FILE);
    MakeOpenFile(rport, rfptr);

    OBJSETUP(wport, rb_cFile, T_FILE);
    MakeOpenFile(wport, wfptr);

    establishShell(RSTRING(shell)->ptr,&info);

    rfptr->mode = rb_io_mode_flags("r");
    rfptr->f = fdopen(info.fd, "r");
    rfptr->path = strdup(RSTRING(shell)->ptr);
    rb_obj_call_init((VALUE)rport, 1, &shell);

    wfptr->mode = rb_io_mode_flags("w");
    wfptr->f = fdopen(dup(info.fd), "w");
    wfptr->path = strdup(RSTRING(shell)->ptr);
    rb_obj_call_init((VALUE)wport, 1, &shell);

    res = rb_ary_new2(2);
    rb_ary_store(res,0,(VALUE)rport);
    rb_ary_store(res,1,(VALUE)wport);
    rb_ary_store(res,2,INT2FIX(info.child_pid));

    if (rb_iterator_p()) {
	rb_yield((VALUE)res);
	reset_signal_action();
	return Qnil;
    }
    else {
	return (VALUE)res;
    }
}

/* ruby function: protect_signal */
static VALUE
pty_protect(self)
    VALUE self;
{
    reset_signal_action();
    rb_yield(Qnil);
    set_signal_action(chld_changed);
    return self;
}

static VALUE
pty_reset_signal(self)
    VALUE self;
{
    reset_signal_action();
    return self;
}

static VALUE cPTY;

void
Init_pty()
{
    cPTY = rb_define_module("PTY");
    rb_define_module_function(cPTY,"getpty",pty_getpty,1);
    rb_define_module_function(cPTY,"spawn",pty_getpty,1);
    rb_define_module_function(cPTY,"protect_signal",pty_protect,0);
    rb_define_module_function(cPTY,"reset_signal",pty_reset_signal,0);
}
@


1.1.2.2
log
@990513
@
text
@d25 1
a25 1
#ifdef __hpux
d111 1
a111 2
set_signal_action(action)
    RETSIGTYPE (*action)();
d113 1
a113 1
#ifdef __hpux
d197 1
a197 3
establishShell(shellname, info)
    char *shellname;
    struct pty_info *info;
@


1.1.2.3
log
@arity/strict yield
@
text
@d183 1
a183 1
---->> Either IF_STOPPED or WIFSTOPPED is needed <<----
@


1.1.2.4
log
@regexp null pattern
@
text
@a367 1
#if defined I_PUSH
a369 1
#endif
a373 1
#if defined I_PUSH
a375 1
#endif
@


1.1.2.5
log
@thread bugs
@
text
@a21 4
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

@


1.1.2.6
log
@990611
@
text
@d445 1
d450 1
@


1.1.2.7
log
@990715
@
text
@a10 1
#ifdef HAVE_SYS_WAIT_H
a11 3
#else
#define WIFSTOPPED(status)    (((status) & 0xff) == 0x7f)
#endif
d163 1
a163 1
	cpid = wait3(&statusp, WUNTRACED|WNOHANG, 0);
@


1.1.2.8
log
@backtrace may be Qnil
@
text
@d211 1
@


