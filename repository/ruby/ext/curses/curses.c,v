head	1.15;
access;
symbols
	v1_6_7:1.4.2.1
	v1_6_6:1.4.2.1
	v1_6_5:1.4.2.1
	v1_6_4:1.4.2.1
	v1_7_1:1.6
	v1_6_4_preview4:1.4.2.1
	v1_6_4_preview3:1.4.2.1
	v1_6_4_preview2:1.4.2.1
	v1_6_4_preview1:1.4.2.1
	v1_6_3:1.4
	ruby_m17n:1.4.0.4
	ruby_1_6:1.4.0.2
	v1_6_2:1.4
	v1_6_1:1.4
	v1_6_0:1.4
	v1_4_6:1.2.2.1
	v1_4_5:1.2.2.1
	v1_4_4:1.2.2.1
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.2
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.4
	v1_3_6_repack:1.1.1.3.2.4
	v1_3_6:1.1.1.3.2.4
	v1_3_5:1.1.1.3.2.4
	v1_2_6repack:1.1.1.2.2.11
	v1_3_4_990625:1.1.1.3.2.4
	v1_3_4_990624:1.1.1.3.2.4
	v1_2_6:1.1.1.2.2.11
	v1_3_4_990611:1.1.1.3.2.4
	v1_3_4_990531:1.1.1.3.2.3
	v1_3_3_990518:1.1.1.3.2.3
	v1_3_3_990513:1.1.1.3.2.3
	v1_3_3_990507:1.1.1.3.2.3
	v1_2_5:1.1.1.2.2.11
	v1_2_4:1.1.1.2.2.11
	v1_3_1_990225:1.1.1.3.2.2
	v1_3_1_990224:1.1.1.3.2.1
	v1_3_1_990215:1.1.1.3
	v1_3_1_990212:1.1.1.3
	v1_3_1_990210:1.1.1.3
	v1_3_1_:1.1.1.3
	v1_3_1_990209:1.1.1.3
	v1_3_1_990205:1.1.1.3
	v1_3_1_990203:1.1.1.3
	v1_3_1_990201:1.1.1.3
	v1_3_1"_990201:1.1.1.3
	v1_3_1_990128:1.1.1.3
	v1_3_1_990127:1.1.1.3
	v1_3_1_990126:1.1.1.3
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.11
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.11
	v1_2_1repack:1.1.1.2.2.11
	v1_2_1:1.1.1.2.2.11
	v1_2_stable:1.1.1.2.2.11
	v1_1d1:1.1.1.2.2.10.2.3
	v1_1d0:1.1.1.2.2.10.2.2
	v1_1c9_1:1.1.1.2.2.11
	v1_1c9:1.1.1.2.2.11
	v1_1c8:1.1.1.2.2.11
	v1_1c7:1.1.1.2.2.11
	v1_1c6:1.1.1.2.2.10
	v1_1d-start:1.1.1.2.2.10.2.1
	v1_1c5:1.1.1.2.2.10
	v1_1dev:1.1.1.2.2.10.0.2
	v1_1c4:1.1.1.2.2.10
	v1_1c3:1.1.1.2.2.10
	v1_1c2:1.1.1.2.2.10
	v1_1c1:1.1.1.2.2.10
	v1_1c0:1.1.1.2.2.10
	v1_1b9_31:1.1.1.2.2.10
	v1_1b9_30:1.1.1.2.2.9
	v1_1b9_28:1.1.1.2.2.9
	v1_1b9_27:1.1.1.2.2.9
	v1_1b9_26:1.1.1.2.2.9
	r1_1b9_25:1.1.1.2.2.9
	r1_1b9_24:1.1.1.2.2.9
	v1_1b9_23:1.1.1.2.2.9
	v1_1b9_22:1.1.1.2.2.8
	v1_1b9_20:1.1.1.2.2.8
	v1_1b9_18:1.1.1.2.2.8
	v1_1b9_16:1.1.1.2.2.7
	v1_1b9_15:1.1.1.2.2.7
	v1_1b9_13:1.1.1.2.2.7
	v1_1b9_12:1.1.1.2.2.7
	v1_1b9_11:1.1.1.2.2.7
	v1_1b9_08:1.1.1.2.2.7
	v1_1b9_07:1.1.1.2.2.7
	r1_1b9:1.1.1.2.2.1
	v1_1b8:1.1.1.2.2.1
	v1_1b7:1.1.1.2
	v1_1b6:1.1.1.2
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2002.09.24.06.00.02;	author michal;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.04.13.32.01;	author nobu;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.29.19.24.43;	author ttate;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.10.07.18.14;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.29.23.59.15;	author ttate;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.23.09.53.54;	author ttate;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.16.07.24.20;	author ttate;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.13.02.13.06;	author ttate;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.12.23.42.44;	author ttate;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.02.04.22.14;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.26.08.57.12;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.06.04.15.35;	author matz;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.02.02.08.10.31;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.37.47;	author matz;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.14;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.32;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.02.24.04.31.27;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.25.06.39.12;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.05.06.08.31.48;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.06.11.06.29.59;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.02.18.01.56.43;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.03.03.10.16.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.03.06.10.07.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.03.09.07.57.00;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.03.26.06.38.33;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.03.26.09.07.27;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.04.02.10.03.52;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.05.08.09.38.16;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.05.25.09.42.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.07.13.04.38.01;	author matz;	state Exp;
branches
	1.1.1.2.2.10.2.1;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.11.09.09.11.51;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.10.2.1
date	98.09.08.07.09.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10.2.2;

1.1.1.2.2.10.2.2
date	98.11.25.03.31.18;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10.2.3;

1.1.1.2.2.10.2.3
date	98.12.22.09.01.54;	author matz;	state Exp;
branches;
next	;

1.2.2.1
date	2000.02.02.08.09.43;	author matz;	state Exp;
branches;
next	;

1.4.2.1
date	2001.03.26.08.56.06;	author matz;	state Exp;
branches;
next	;


desc
@@


1.15
log
@cleanup for curses, gdbm [ruby-core:502], [ruby-core:503]
@
text
@/* -*- C -*-
 * $Id: curses.c,v 1.14 2002/08/04 13:32:01 nobu Exp $
 *
 * ext/curses/curses.c
 * 
 * by MAEDA Shugo (ender@@pic-internet.or.jp)
 * modified by Yukihiro Matsumoto (matz@@netlab.co.jp),
 *         Toki Yoshinori,
 *         Hitoshi Takahashi,
 *         and Takaaki Tateishi (ttate@@kt.jaist.ac.jp)
 *
 * maintainers:
 * - Takaaki Tateishi (ttate@@kt.jaist.ac.jp)
 */

#if defined(HAVE_NCURSES_H)
# include <ncurses.h>
#elif defined(HAVE_NCURSES_CURSES_H)
# include <ncurses/curses.h>
#elif defined(HAVE_CURSES_COLR_CURSES_H)
# include <varargs.h>
# include <curses_colr/curses.h>
#else
# include <curses.h>
# if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__)) && !defined(_maxx)
#  define _maxx maxx
# endif
# if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__)) && !defined(_maxy)
#  define _maxy maxy
# endif
# if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__)) && !defined(_begx)
#  define _begx begx
# endif
# if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__)) && !defined(_begy)
#  define _begy begy
# endif
#endif

#ifdef HAVE_INIT_COLOR
# define USE_COLOR 1
#endif

/* supports only ncurses mouse routines */
#ifdef NCURSES_MOUSE_VERSION
# define USE_MOUSE 1
#endif

#include <stdio.h>
#include "ruby.h"
#include "rubyio.h"

static VALUE mCurses;
static VALUE mKey;
static VALUE cWindow;
#ifdef USE_MOUSE
static VALUE cMouseEvent;
#endif

static VALUE rb_stdscr;

struct windata {
    WINDOW *window;
};

#define CHECK(c) c

static VALUE window_attroff();
static VALUE window_attron();
static VALUE window_attrset();

static void
no_window()
{
    rb_raise(rb_eRuntimeError, "already closed window");
}

#define GetWINDOW(obj, winp) do {\
    Data_Get_Struct(obj, struct windata, winp);\
    if (winp->window == 0) no_window();\
} while (0)

static void
free_window(winp)
    struct windata *winp;
{
    if (winp->window && winp->window != stdscr) delwin(winp->window);
    winp->window = 0;
    free(winp);
}

static VALUE
prep_window(class, window)
    VALUE class;
    WINDOW *window;
{
    VALUE obj;
    struct windata *winp;

    if (window == NULL) {
	rb_raise(rb_eRuntimeError, "failed to create window");
    }

    obj = rb_obj_alloc(class);
    Data_Get_Struct(obj, struct windata, winp);
    winp->window = window;
    
    return obj;    
}

/*-------------------------- module Curses --------------------------*/

/* def init_screen */
static VALUE
curses_init_screen()
{
    if (rb_stdscr) return rb_stdscr;
    initscr();
    if (stdscr == 0) {
	rb_raise(rb_eRuntimeError, "cannot initialize curses");
    }
    clear();
    rb_stdscr = prep_window(cWindow, stdscr);
    return rb_stdscr;
}

/* def stdscr */
#define curses_stdscr curses_init_screen

/* def close_screen */
static VALUE
curses_close_screen()
{
#ifdef HAVE_ISENDWIN
    if (!isendwin())
#endif
	endwin();
    rb_stdscr = 0;
    return Qnil;
}

static void
curses_finalize()
{
    if (stdscr
#ifdef HAVE_ISENDWIN
	&& !isendwin()
#endif
	)
	endwin();
    rb_stdscr = 0;
    rb_gc_unregister_address(&rb_stdscr);
}

/* def closed? */
static VALUE
curses_closed()
{
#ifdef HAVE_ISENDWIN
    if (isendwin()) {
	return Qtrue;
    }
    return Qfalse;
#else
    rb_notimplement();
#endif
}

/* def clear */
static VALUE
curses_clear(obj)
    VALUE obj;
{
    wclear(stdscr);
    return Qnil;
}

/* def refresh */
static VALUE
curses_refresh(obj)
    VALUE obj;
{
    refresh();
    return Qnil;
}

/* def doupdate */
static VALUE
curses_doupdate(obj)
    VALUE obj;
{
#ifdef HAVE_DOUPDATE
    doupdate();
#else
    refresh();
#endif
    return Qnil;
}

/* def echo */
static VALUE
curses_echo(obj)
    VALUE obj;
{
    echo();
    return Qnil;
}

/* def noecho */
static VALUE
curses_noecho(obj)
    VALUE obj;
{
    noecho();
    return Qnil;
}

/* def raw */
static VALUE
curses_raw(obj)
    VALUE obj;
{
    raw();
    return Qnil;
}

/* def noraw */
static VALUE
curses_noraw(obj)
    VALUE obj;
{
    noraw();
    return Qnil;
}

/* def cbreak */
static VALUE
curses_cbreak(obj)
    VALUE obj;
{
    cbreak();
    return Qnil;
}

/* def nocbreak */
static VALUE
curses_nocbreak(obj)
    VALUE obj;
{
    nocbreak();
    return Qnil;
}

/* def nl */
static VALUE
curses_nl(obj)
    VALUE obj;
{
    nl();
    return Qnil;
}

/* def nonl */
static VALUE
curses_nonl(obj)
    VALUE obj;
{
    nonl();
    return Qnil;
}

/* def beep */
static VALUE
curses_beep(obj)
    VALUE obj;
{
#ifdef HAVE_BEEP
    beep();
#endif
    return Qnil;
}

/* def flash */
static VALUE
curses_flash(obj)
    VALUE obj;
{
#ifdef HAVE_FLASH
    flash();
#endif
    return Qnil;
}

/* def ungetch */
static VALUE
curses_ungetch(obj, ch)
    VALUE obj;
    VALUE ch;
{
#ifdef HAVE_UNGETCH
    ungetch(NUM2INT(ch));
#else
    rb_notimplement();
#endif
    return Qnil;
}

/* def setpos(y, x) */
static VALUE
curses_setpos(obj, y, x)
    VALUE obj;
    VALUE y;
    VALUE x;
{
    move(NUM2INT(y), NUM2INT(x));
    return Qnil;
}

/* def standout */
static VALUE
curses_standout(obj)
    VALUE obj;
{
    standout();
    return Qnil;
}

/* def standend */
static VALUE
curses_standend(obj)
    VALUE obj;
{
    standend();
    return Qnil;
}

/* def inch */
static VALUE
curses_inch(obj)
    VALUE obj;
{
    return CHR2FIX(inch());
}

/* def addch(ch) */
static VALUE
curses_addch(obj, ch)
    VALUE obj;
    VALUE ch;
{
    addch(NUM2CHR(ch));
    return Qnil;
}

/* def insch(ch) */
static VALUE
curses_insch(obj, ch)
    VALUE obj;
    VALUE ch;
{
    insch(NUM2CHR(ch));
    return Qnil;
}

/* def addstr(str) */
static VALUE
curses_addstr(obj, str)
    VALUE obj;
    VALUE str;
{
    if (!NIL_P(str)) {
	addstr(STR2CSTR(str));
    }
    return Qnil;
}

/* def getch */
static VALUE
curses_getch(obj)
    VALUE obj;
{
    rb_read_check(stdin);
    return UINT2NUM(getch());
}

/* def getstr */
static VALUE
curses_getstr(obj)
    VALUE obj;
{
    char rtn[1024]; /* This should be big enough.. I hope */

    rb_read_check(stdin);
#if defined(HAVE_GETNSTR)
    getnstr(rtn,1023);
#else
    getstr(rtn);
#endif
    return rb_tainted_str_new2(rtn);
}

/* def delch */
static VALUE
curses_delch(obj)
    VALUE obj;
{
    delch();
    return Qnil;
}

/* def delelteln */
static VALUE
curses_deleteln(obj)
    VALUE obj;
{
#if defined(HAVE_DELETELN) || defined(deleteln)
    deleteln();
#endif
    return Qnil;
}

/* def keyname */
static VALUE
curses_keyname(obj, c)
    VALUE obj;
    VALUE c;
{
#ifdef HAVE_KEYNAME
  const char *name;

  name = keyname(NUM2INT(c));
  if (name) {
    return rb_str_new2(name);
  } else {
    return Qnil;
  }
#else
  return Qnil;
#endif
}

static VALUE
curses_lines()
{
    return INT2FIX(LINES);
}

static VALUE
curses_cols()
{
    return INT2FIX(COLS);
}

static VALUE
curses_curs_set(VALUE obj, VALUE visibility)
{
  int n;
  return (n = curs_set(NUM2INT(visibility)) != ERR) ? INT2FIX(n) : Qnil;
}

static VALUE
curses_scrl(VALUE obj, VALUE n)
{
  /* may have to raise exception on ERR */
  return (scrl(NUM2INT(n)) == OK) ? Qtrue : Qfalse;
}

static VALUE
curses_setscrreg(VALUE obj, VALUE top, VALUE bottom)
{
  /* may have to raise exception on ERR */
  return (setscrreg(NUM2INT(top), NUM2INT(bottom)) == OK) ? Qtrue : Qfalse;
}

static VALUE
curses_attroff(VALUE obj, VALUE attrs)
{
  return window_attroff(rb_stdscr,attrs);  
  /* return INT2FIX(attroff(NUM2INT(attrs))); */
}

static VALUE
curses_attron(VALUE obj, VALUE attrs)
{
  return window_attron(rb_stdscr,attrs);
  /* return INT2FIX(attroff(NUM2INT(attrs))); */
}

static VALUE
curses_attrset(VALUE obj, VALUE attrs)
{
  return window_attrset(rb_stdscr,attrs);
  /* return INT2FIX(attroff(NUM2INT(attrs))); */
}

static VALUE
curses_bkgdset(VALUE obj, VALUE ch)
{
  bkgdset(NUM2CHR(ch));
  return Qnil;
}

static VALUE
curses_bkgd(VALUE obj, VALUE ch)
{
  return CHR2FIX(bkgd(NUM2CHR(ch)));
}

static VALUE
curses_resizeterm(VALUE obj, VALUE lines, VALUE columns)
{
#if defined(HAVE_RESIZETERM)
  return (resizeterm(NUM2INT(lines),NUM2INT(columns)) == OK) ? Qtrue : Qfalse;
#else
  return Qnil;
#endif
}

#ifdef USE_COLOR
static VALUE
curses_start_color(VALUE obj)
{
  /* may have to raise exception on ERR */
  return (start_color() == OK) ? Qtrue : Qfalse;
}

static VALUE
curses_init_pair(VALUE obj, VALUE pair, VALUE f, VALUE b)
{
  /* may have to raise exception on ERR */
  return (init_pair(NUM2INT(pair),NUM2INT(f),NUM2INT(b)) == OK) ? Qtrue : Qfalse;
}

static VALUE
curses_init_color(VALUE obj, VALUE color, VALUE r, VALUE g, VALUE b)
{
  /* may have to raise exception on ERR */
  return (init_color(NUM2INT(color),NUM2INT(r),
		     NUM2INT(g),NUM2INT(b)) == OK) ? Qtrue : Qfalse;
}

static VALUE
curses_has_colors(VALUE obj)
{
  return has_colors() ? Qtrue : Qfalse;
}

static VALUE
curses_can_change_color(VALUE obj)
{
  return can_change_color() ? Qtrue : Qfalse;
}

static VALUE
curses_color_content(VALUE obj, VALUE color)
{
  short r,g,b;

  color_content(NUM2INT(color),&r,&g,&b);
  return rb_ary_new3(3,INT2FIX(r),INT2FIX(g),INT2FIX(b));
}

static VALUE
curses_pair_content(VALUE obj, VALUE pair)
{
  short f,b;

  pair_content(NUM2INT(pair),&f,&b);
  return rb_ary_new3(2,INT2FIX(f),INT2FIX(b));
}

static VALUE
curses_color_pair(VALUE obj, VALUE attrs)
{
  return INT2FIX(COLOR_PAIR(NUM2INT(attrs)));
}

static VALUE
curses_pair_number(VALUE obj, VALUE attrs)
{
  return INT2FIX(PAIR_NUMBER(NUM2INT(attrs)));
}
#endif

#ifdef USE_MOUSE
struct mousedata {
  MEVENT *mevent;
};

static void
no_mevent()
{
  rb_raise(rb_eRuntimeError, "no such mouse event");
}

#define GetMOUSE(obj, data) do {\
    Data_Get_Struct(obj, struct mousedata, data);\
    if (data->mevent == 0) no_mevent();\
} while (0)

static void
curses_mousedata_free(struct mousedata *mdata)
{
  if (mdata->mevent)
    free(mdata->mevent);
}

static VALUE
curses_getmouse(VALUE obj)
{
  struct mousedata *mdata;
  VALUE val;

  val = Data_Make_Struct(cMouseEvent,struct mousedata,
			 0,curses_mousedata_free,mdata);
  mdata->mevent = (MEVENT*)malloc(sizeof(MEVENT));
  return (getmouse(mdata->mevent) == OK) ? val : Qnil;
}

static VALUE
curses_ungetmouse(VALUE obj, VALUE mevent)
{
  struct mousedata *mdata;

  GetMOUSE(mevent,mdata);
  return (ungetmouse(mdata->mevent) == OK) ? Qtrue : Qfalse;
}

static VALUE
curses_mouseinterval(VALUE obj, VALUE interval)
{
  return mouseinterval(NUM2INT(interval)) ? Qtrue : Qfalse;
}

static VALUE
curses_mousemask(VALUE obj, VALUE mask)
{
  return INT2NUM(mousemask(NUM2UINT(mask),NULL));
}

#define DEFINE_MOUSE_GET_MEMBER(func_name,mem) \
static VALUE func_name (VALUE mouse) \
{ \
  struct mousedata *mdata; \
  GetMOUSE(mouse, mdata); \
  return (UINT2NUM(mdata->mevent -> mem)); \
}

DEFINE_MOUSE_GET_MEMBER(curs_mouse_id, id)
DEFINE_MOUSE_GET_MEMBER(curs_mouse_x, x)
DEFINE_MOUSE_GET_MEMBER(curs_mouse_y, y)
DEFINE_MOUSE_GET_MEMBER(curs_mouse_z, z)
DEFINE_MOUSE_GET_MEMBER(curs_mouse_bstate, bstate)
#undef define_curs_mouse_member
#endif /* USE_MOUSE */

/*-------------------------- class Window --------------------------*/

/* def self.allocate */
static VALUE
window_s_allocate(class)
    VALUE class;
{
    struct windata *winp;

    return Data_Make_Struct(class, struct windata, 0, free_window, winp);
}

/* def initialize(h, w, top, left) */
static VALUE
window_initialize(obj, h, w, top, left)
    VALUE obj;
    VALUE h;
    VALUE w;
    VALUE top;
    VALUE left;
{
    struct windata *winp;
    WINDOW *window;

    curses_init_screen();
    Data_Get_Struct(obj, struct windata, winp);
    if (winp->window) delwin(winp->window);
    window = newwin(NUM2INT(h), NUM2INT(w), NUM2INT(top), NUM2INT(left));
    wclear(window);
    winp->window = window;

    return obj;
}

/* def subwin(h, w, top, left) */
static VALUE
window_subwin(obj, h, w, top, left)
    VALUE obj;
    VALUE h;
    VALUE w;
    VALUE top;
    VALUE left;
{
    struct windata *winp;
    WINDOW *window;
    VALUE win;

    GetWINDOW(obj, winp);
    window = subwin(winp->window, NUM2INT(h), NUM2INT(w),
		                  NUM2INT(top), NUM2INT(left));
    win = prep_window(rb_obj_class(obj), window);

    return win;
}

/* def close */
static VALUE
window_close(obj)
    VALUE obj;
{
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    delwin(winp->window);
    winp->window = 0;

    return Qnil;
}

/* def clear */
static VALUE
window_clear(obj)
    VALUE obj;
{
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    wclear(winp->window);
    
    return Qnil;
}

/* def refresh */
static VALUE
window_refresh(obj)
    VALUE obj;
{
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    wrefresh(winp->window);
    
    return Qnil;
}

/* def noutrefresh */
static VALUE
window_noutrefresh(obj)
    VALUE obj;
{
    struct windata *winp;

    GetWINDOW(obj, winp);
#ifdef HAVE_DOUPDATE
    wnoutrefresh(winp->window);
#else
    wrefresh(winp->window);
#endif

    return Qnil;
}

/* def move(y, x) */
static VALUE
window_move(obj, y, x)
    VALUE obj;
    VALUE y;
    VALUE x;
{
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    mvwin(winp->window, NUM2INT(y), NUM2INT(x));

    return Qnil;
}

/* def setpos(y, x) */
static VALUE
window_setpos(obj, y, x)
    VALUE obj;
    VALUE y;
    VALUE x;
{
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    wmove(winp->window, NUM2INT(y), NUM2INT(x));
    return Qnil;
}

/* def cury */
static VALUE
window_cury(obj)
    VALUE obj;
{
    struct windata *winp;
    int x, y;

    GetWINDOW(obj, winp);
    getyx(winp->window, y, x);
    return INT2FIX(y);
}

/* def curx */
static VALUE
window_curx(obj)
    VALUE obj;
{
    struct windata *winp;
    int x, y;

    GetWINDOW(obj, winp);
    getyx(winp->window, y, x);
    return INT2FIX(x);
}

/* def maxy */
static VALUE
window_maxy(obj)
    VALUE obj;
{
    struct windata *winp;

    GetWINDOW(obj, winp);
#if defined(getmaxy)
    return INT2FIX(getmaxy(winp->window));
#elif defined(getmaxyx)
    {
	int x, y;
	getmaxyx(winp->window, y, x);
	return INT2FIX(y);
    }
#else
    return INT2FIX(winp->window->_maxy+1);
#endif
}

/* def maxx */
static VALUE
window_maxx(obj)
    VALUE obj;
{
    struct windata *winp;

    GetWINDOW(obj, winp);
#if defined(getmaxx)
    return INT2FIX(getmaxx(winp->window));
#elif defined(getmaxyx)
    {
	int x, y;
	getmaxyx(winp->window, y, x);
	return INT2FIX(x);
    }
#else
    return INT2FIX(winp->window->_maxx+1);
#endif
}

/* def begy */
static VALUE
window_begy(obj)
    VALUE obj;
{
    struct windata *winp;
    int x, y;

    GetWINDOW(obj, winp);
#ifdef getbegyx
    getbegyx(winp->window, y, x);
    return INT2FIX(y);
#else
    return INT2FIX(winp->window->_begy);
#endif
}

/* def begx */
static VALUE
window_begx(obj)
    VALUE obj;
{
    struct windata *winp;
    int x, y;

    GetWINDOW(obj, winp);
#ifdef getbegyx
    getbegyx(winp->window, y, x);
    return INT2FIX(x);
#else
    return INT2FIX(winp->window->_begx);
#endif
}

/* def box(vert, hor) */
static VALUE
window_box(argc, argv, self)
    int argc;
    VALUE argv[], self;
{
    struct windata *winp; 
    VALUE vert, hor, corn;

    rb_scan_args(argc, argv, "21", &vert, &hor, &corn);

    GetWINDOW(self, winp);
    box(winp->window, NUM2CHR(vert), NUM2CHR(hor));

    if (!NIL_P(corn)) {
      int cur_x, cur_y, x, y;
      char c;

      c = NUM2CHR(corn);
      getyx(winp->window, cur_y, cur_x);
      x = NUM2INT(window_maxx(self)) - 1;
      y = NUM2INT(window_maxy(self)) - 1;
      wmove(winp->window, 0, 0);
      waddch(winp->window, c);
      wmove(winp->window, y, 0);
      waddch(winp->window, c);
      wmove(winp->window, y, x);
      waddch(winp->window, c);
      wmove(winp->window, 0, x);
      waddch(winp->window, c);
      wmove(winp->window, cur_y, cur_x);
    }
    
    return Qnil;
}

/* def standout */
static VALUE
window_standout(obj)
    VALUE obj;
{
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    wstandout(winp->window);
    return Qnil;
}

/* def standend */
static VALUE
window_standend(obj)
    VALUE obj;
{
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    wstandend(winp->window);
    return Qnil;
}

/* def inch */
static VALUE
window_inch(obj)
    VALUE obj;
{
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    return CHR2FIX(winch(winp->window));
}

/* def addch(ch) */
static VALUE
window_addch(obj, ch)
    VALUE obj;
    VALUE ch;
{
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    waddch(winp->window, NUM2CHR(ch));
    
    return Qnil;
}

/* def insch(ch) */
static VALUE
window_insch(obj, ch)
    VALUE obj;
    VALUE ch;
{
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    winsch(winp->window, NUM2CHR(ch));
    
    return Qnil;
}

/* def addstr(str) */
static VALUE
window_addstr(obj, str)
    VALUE obj;
    VALUE str;
{
    if (!NIL_P(str)) {
	struct windata *winp;

	GetWINDOW(obj, winp);
	waddstr(winp->window, STR2CSTR(str));
    }
    return Qnil;
}

/* def <<(str) */
static VALUE
window_addstr2(obj, str)
    VALUE obj;
    VALUE str;
{
    window_addstr(obj, str);
    return obj;
}

/* def getch */
static VALUE
window_getch(obj)
    VALUE obj;
{
    struct windata *winp;
    
    rb_read_check(stdin);
    GetWINDOW(obj, winp);
    return UINT2NUM(wgetch(winp->window));
}

/* def getstr */
static VALUE
window_getstr(obj)
    VALUE obj;
{
    struct windata *winp;
    char rtn[1024]; /* This should be big enough.. I hope */
    
    GetWINDOW(obj, winp);
    rb_read_check(stdin);
#if defined(HAVE_WGETNSTR)
    wgetnstr(winp->window, rtn, 1023);
#else
    wgetstr(winp->window, rtn);
#endif
    return rb_tainted_str_new2(rtn);
}

/* def delch */
static VALUE
window_delch(obj)
    VALUE obj;
{
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    wdelch(winp->window);
    return Qnil;
}

/* def delelteln */
static VALUE
window_deleteln(obj)
    VALUE obj;
{
#if defined(HAVE_WDELETELN) || defined(wdeleteln)
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    wdeleteln(winp->window);
#endif
    return Qnil;
}

static VALUE
window_scrollok(VALUE obj, VALUE bf)
{
  struct windata *winp;

  GetWINDOW(obj, winp);
  scrollok(winp->window, RTEST(bf) ? TRUE : FALSE);
  return Qnil;
}

static VALUE
window_idlok(VALUE obj, VALUE bf)
{
  struct windata *winp;

  GetWINDOW(obj, winp);
  idlok(winp->window, RTEST(bf) ? TRUE : FALSE);
  return Qnil;
}

static VALUE
window_setscrreg(VALUE obj, VALUE top, VALUE bottom)
{
  struct windata *winp;
  int res;

  GetWINDOW(obj, winp);
  res = wsetscrreg(winp->window, NUM2INT(top), NUM2INT(bottom));
  /* may have to raise exception on ERR */
  return (res == OK) ? Qtrue : Qfalse;
}

static VALUE
window_scroll(VALUE obj)
{
  struct windata *winp;

  GetWINDOW(obj, winp);
  /* may have to raise exception on ERR */
  return (scroll(winp->window) == OK) ? Qtrue : Qfalse;
}

static VALUE
window_scrl(VALUE obj, VALUE n)
{
  struct windata *winp;

  GetWINDOW(obj, winp);
  /* may have to raise exception on ERR */
  return (wscrl(winp->window,NUM2INT(n)) == OK) ? Qtrue : Qfalse;
}

static VALUE
window_attroff(VALUE obj, VALUE attrs)
{
  struct windata *winp;

  GetWINDOW(obj,winp);
  return INT2FIX(wattroff(winp->window,NUM2INT(attrs)));
}

static VALUE
window_attron(VALUE obj, VALUE attrs)
{
  struct windata *winp;
  VALUE val;

  GetWINDOW(obj,winp);
  val = INT2FIX(wattron(winp->window,NUM2INT(attrs)));
  if( rb_block_given_p() ){
    rb_yield(val);
    wattroff(winp->window,NUM2INT(attrs));
    return val;
  }
  else{
    return val;
  }
}

static VALUE
window_attrset(VALUE obj, VALUE attrs)
{
  struct windata *winp;

  GetWINDOW(obj,winp);
  return INT2FIX(wattrset(winp->window,NUM2INT(attrs)));
}

static VALUE
window_bkgdset(VALUE obj, VALUE ch)
{
  struct windata *winp;

  GetWINDOW(obj,winp);
  wbkgdset(winp->window, NUM2CHR(ch));
  return Qnil;
}

static VALUE
window_bkgd(VALUE obj, VALUE ch)
{
  struct windata *winp;

  GetWINDOW(obj,winp);
  return CHR2FIX(wbkgd(winp->window, NUM2CHR(ch)));
}

static VALUE
window_getbkgd(VALUE obj)
{
  struct windata *winp;

  GetWINDOW(obj,winp);
  return CHR2FIX(getbkgd(winp->window));
}

static VALUE
window_resize(VALUE obj, VALUE lines, VALUE columns)
{
#if defined(HAVE_WRESIZE)
  struct windata *winp;

  GetWINDOW(obj,winp);
  return wresize(winp->window, NUM2INT(lines), NUM2INT(columns)) == OK ? Qtrue : Qfalse;
#else
  return Qnil;
#endif
}


#ifdef HAVE_KEYPAD
static VALUE
window_keypad(VALUE obj, VALUE val)
{
  struct windata *winp;

  GetWINDOW(obj,winp);
  /* keypad() of NetBSD's libcurses returns no value */
#if defined(__NetBSD__) && !defined(NCURSES_VERSION)
  keypad(winp->window,(RTEST(val) ? TRUE : FALSE));
  return Qnil;
#else
  /* may have to raise exception on ERR */
  return (keypad(winp->window,RTEST(val) ? TRUE : FALSE)) == OK ?
    Qtrue : Qfalse;
#endif
}
#endif /* HAVE_KEYPAD */

/*------------------------- Initialization -------------------------*/
void
Init_curses()
{
    mCurses    = rb_define_module("Curses");
    mKey       = rb_define_module_under(mCurses, "Key");

    rb_gc_register_address(&rb_stdscr);

#ifdef USE_MOUSE
    cMouseEvent = rb_define_class_under(mCurses,"MouseEvent",rb_cObject);
    rb_undef_method(CLASS_OF(cMouseEvent),"new");
    rb_define_method(cMouseEvent, "eid", curs_mouse_id, 0);
    rb_define_method(cMouseEvent, "x", curs_mouse_x, 0);
    rb_define_method(cMouseEvent, "y", curs_mouse_y, 0);
    rb_define_method(cMouseEvent, "z", curs_mouse_z, 0);
    rb_define_method(cMouseEvent, "bstate", curs_mouse_bstate, 0);
#endif /* USE_MOUSE */

    rb_define_module_function(mCurses, "init_screen", curses_init_screen, 0);
    rb_define_module_function(mCurses, "close_screen", curses_close_screen, 0);
    rb_define_module_function(mCurses, "closed?", curses_closed, 0);
    rb_define_module_function(mCurses, "stdscr", curses_stdscr, 0);
    rb_define_module_function(mCurses, "refresh", curses_refresh, 0);
    rb_define_module_function(mCurses, "doupdate", curses_doupdate, 0);
    rb_define_module_function(mCurses, "clear", curses_clear, 0);
    rb_define_module_function(mCurses, "echo", curses_echo, 0);
    rb_define_module_function(mCurses, "noecho", curses_noecho, 0);
    rb_define_module_function(mCurses, "raw", curses_raw, 0);
    rb_define_module_function(mCurses, "noraw", curses_noraw, 0);
    rb_define_module_function(mCurses, "cbreak", curses_cbreak, 0);
    rb_define_module_function(mCurses, "nocbreak", curses_nocbreak, 0);
    rb_define_alias(mCurses, "crmode", "cbreak");
    rb_define_alias(mCurses, "nocrmode", "nocbreak");
    rb_define_module_function(mCurses, "nl", curses_nl, 0);
    rb_define_module_function(mCurses, "nonl", curses_nonl, 0);
    rb_define_module_function(mCurses, "beep", curses_beep, 0);
    rb_define_module_function(mCurses, "flash", curses_flash, 0);
    rb_define_module_function(mCurses, "ungetch", curses_ungetch, 1);
    rb_define_module_function(mCurses, "setpos", curses_setpos, 2);
    rb_define_module_function(mCurses, "standout", curses_standout, 0);
    rb_define_module_function(mCurses, "standend", curses_standend, 0);
    rb_define_module_function(mCurses, "inch", curses_inch, 0);
    rb_define_module_function(mCurses, "addch", curses_addch, 1);
    rb_define_module_function(mCurses, "insch", curses_insch, 1);
    rb_define_module_function(mCurses, "addstr", curses_addstr, 1);
    rb_define_module_function(mCurses, "getch", curses_getch, 0);
    rb_define_module_function(mCurses, "getstr", curses_getstr, 0);
    rb_define_module_function(mCurses, "delch", curses_delch, 0);
    rb_define_module_function(mCurses, "deleteln", curses_deleteln, 0);
    rb_define_module_function(mCurses, "keyname", curses_keyname, 1);
    rb_define_module_function(mCurses, "lines", curses_lines, 0);
    rb_define_module_function(mCurses, "cols", curses_cols, 0);
    rb_define_module_function(mCurses, "curs_set", curses_curs_set, 1);
    rb_define_module_function(mCurses, "scrl", curses_scrl, 1);
    rb_define_module_function(mCurses, "setscrreg", curses_setscrreg, 2);
    rb_define_module_function(mCurses, "attroff", curses_attroff, 1);
    rb_define_module_function(mCurses, "attron", curses_attron, 1);
    rb_define_module_function(mCurses, "attrset", curses_attrset, 1);
    rb_define_module_function(mCurses, "bkgdset", curses_bkgdset, 1);
    rb_define_module_function(mCurses, "bkgd", curses_bkgd, 1);
    rb_define_module_function(mCurses, "resizeterm", curses_resizeterm, 2);
    rb_define_module_function(mCurses, "resize", curses_resizeterm, 2);
#ifdef USE_COLOR
    rb_define_module_function(mCurses, "start_color", curses_start_color, 0);
    rb_define_module_function(mCurses, "init_pair", curses_init_pair, 3);
    rb_define_module_function(mCurses, "init_color", curses_init_color, 4);
    rb_define_module_function(mCurses, "has_colors?", curses_has_colors, 0);
    rb_define_module_function(mCurses, "can_change_color?",
			      curses_can_change_color, 0);
    rb_define_module_function(mCurses, "color_content", curses_color_content, 1);
    rb_define_module_function(mCurses, "pair_content", curses_pair_content, 1);
    rb_define_module_function(mCurses, "color_pair", curses_color_pair, 1);
    rb_define_module_function(mCurses, "pair_number", curses_pair_number, 1);
#endif /* USE_COLOR */
#ifdef USE_MOUSE
    rb_define_module_function(mCurses, "getmouse", curses_getmouse, 0);
    rb_define_module_function(mCurses, "ungetmouse", curses_getmouse, 1);
    rb_define_module_function(mCurses, "mouseinterval", curses_mouseinterval, 1);
    rb_define_module_function(mCurses, "mousemask", curses_mousemask, 1);
#endif /* USE_MOUSE */

    cWindow = rb_define_class_under(mCurses, "Window", rb_cData);
    rb_define_singleton_method(cWindow, "allocate", window_s_allocate, 0);
    rb_define_method(cWindow, "initialize", window_initialize, 4);
    rb_define_method(cWindow, "subwin", window_subwin, 4);
    rb_define_method(cWindow, "close", window_close, 0);
    rb_define_method(cWindow, "clear", window_clear, 0);
    rb_define_method(cWindow, "refresh", window_refresh, 0);
    rb_define_method(cWindow, "noutrefresh", window_noutrefresh, 0);
    rb_define_method(cWindow, "box", window_box, -1);
    rb_define_method(cWindow, "move", window_move, 2);
    rb_define_method(cWindow, "setpos", window_setpos, 2);
    rb_define_method(cWindow, "cury", window_cury, 0);
    rb_define_method(cWindow, "curx", window_curx, 0);
    rb_define_method(cWindow, "maxy", window_maxy, 0);
    rb_define_method(cWindow, "maxx", window_maxx, 0);
    rb_define_method(cWindow, "begy", window_begy, 0);
    rb_define_method(cWindow, "begx", window_begx, 0);
    rb_define_method(cWindow, "standout", window_standout, 0);
    rb_define_method(cWindow, "standend", window_standend, 0);
    rb_define_method(cWindow, "inch", window_inch, 0);
    rb_define_method(cWindow, "addch", window_addch, 1);
    rb_define_method(cWindow, "insch", window_insch, 1);
    rb_define_method(cWindow, "addstr", window_addstr, 1);
    rb_define_method(cWindow, "<<", window_addstr2, 1);
    rb_define_method(cWindow, "getch", window_getch, 0);
    rb_define_method(cWindow, "getstr", window_getstr, 0);
    rb_define_method(cWindow, "delch", window_delch, 0);
    rb_define_method(cWindow, "deleteln", window_deleteln, 0);
    rb_define_method(cWindow, "scroll", window_scroll, 0);
    rb_define_method(cWindow, "scrollok", window_scrollok, 1);
    rb_define_method(cWindow, "idlok", window_idlok, 1);
    rb_define_method(cWindow, "setscrreg", window_setscrreg, 2);
    rb_define_method(cWindow, "scrl", window_scrl, 1);
    rb_define_method(cWindow, "resize", window_resize, 2);
#ifdef HAVE_KEYPAD
    rb_define_method(cWindow, "keypad", window_keypad, 1);
    rb_define_method(cWindow, "keypad=", window_keypad, 1);
#endif
#ifdef USE_COLOR
    rb_define_method(cWindow, "attroff", window_attroff, 1);
    rb_define_method(cWindow, "attron", window_attron, 1);
    rb_define_method(cWindow, "attrset", window_attrset, 1);
    rb_define_method(cWindow, "bkgdset", window_bkgdset, 1);
    rb_define_method(cWindow, "bkgd", window_bkgd, 1);
    rb_define_method(cWindow, "getbkgd", window_getbkgd, 0);
#endif /* USE_COLOR */


#define rb_curses_define_const(c) rb_define_const(mCurses,#c,UINT2NUM(c))

#ifdef USE_COLOR
    rb_curses_define_const(A_ATTRIBUTES);
#ifdef A_NORMAL
    rb_curses_define_const(A_NORMAL);
#endif
    rb_curses_define_const(A_STANDOUT);
    rb_curses_define_const(A_UNDERLINE);
    rb_curses_define_const(A_REVERSE);
    rb_curses_define_const(A_BLINK);
    rb_curses_define_const(A_DIM);
    rb_curses_define_const(A_BOLD);
    rb_curses_define_const(A_PROTECT);
#ifdef A_INVIS /* for NetBSD */
    rb_curses_define_const(A_INVIS);
#endif
    rb_curses_define_const(A_ALTCHARSET);
    rb_curses_define_const(A_CHARTEXT);
#ifdef A_HORIZONTAL
    rb_curses_define_const(A_HORIZONTAL);
#endif
#ifdef A_LEFT
    rb_curses_define_const(A_LEFT);
#endif
#ifdef A_LOW
    rb_curses_define_const(A_LOW);
#endif
#ifdef A_RIGHT
    rb_curses_define_const(A_RIGHT);
#endif
#ifdef A_TOP
    rb_curses_define_const(A_TOP);
#endif
#ifdef A_VERTICAL
    rb_curses_define_const(A_VERTICAL);
#endif
    rb_curses_define_const(A_COLOR);

#ifdef COLORS
    rb_curses_define_const(COLORS);
#endif
    rb_curses_define_const(COLOR_BLACK);
    rb_curses_define_const(COLOR_RED);
    rb_curses_define_const(COLOR_GREEN);
    rb_curses_define_const(COLOR_YELLOW);
    rb_curses_define_const(COLOR_BLUE);
    rb_curses_define_const(COLOR_MAGENTA);
    rb_curses_define_const(COLOR_CYAN);
    rb_curses_define_const(COLOR_WHITE);
#endif /* USE_COLOR */
#ifdef USE_MOUSE
#ifdef BUTTON1_PRESSED
    rb_curses_define_const(BUTTON1_PRESSED);
#endif
#ifdef BUTTON1_RELEASED
    rb_curses_define_const(BUTTON1_RELEASED);
#endif
#ifdef BUTTON1_CLICKED
    rb_curses_define_const(BUTTON1_CLICKED);
#endif
#ifdef BUTTON1_DOUBLE_CLICKED
    rb_curses_define_const(BUTTON1_DOUBLE_CLICKED);
#endif
#ifdef BUTTON1_TRIPLE_CLICKED
    rb_curses_define_const(BUTTON1_TRIPLE_CLICKED);
#endif
#ifdef BUTTON2_PRESSED
    rb_curses_define_const(BUTTON2_PRESSED);
#endif
#ifdef BUTTON2_RELEASED
    rb_curses_define_const(BUTTON2_RELEASED);
#endif
#ifdef BUTTON2_CLICKED
    rb_curses_define_const(BUTTON2_CLICKED);
#endif
#ifdef BUTTON2_DOUBLE_CLICKED
    rb_curses_define_const(BUTTON2_DOUBLE_CLICKED);
#endif
#ifdef BUTTON2_TRIPLE_CLICKED
    rb_curses_define_const(BUTTON2_TRIPLE_CLICKED);
#endif
#ifdef BUTTON3_PRESSED
    rb_curses_define_const(BUTTON3_PRESSED);
#endif
#ifdef BUTTON3_RELEASED
    rb_curses_define_const(BUTTON3_RELEASED);
#endif
#ifdef BUTTON3_CLICKED
    rb_curses_define_const(BUTTON3_CLICKED);
#endif
#ifdef BUTTON3_DOUBLE_CLICKED
    rb_curses_define_const(BUTTON3_DOUBLE_CLICKED);
#endif
#ifdef BUTTON3_TRIPLE_CLICKED
    rb_curses_define_const(BUTTON3_TRIPLE_CLICKED);
#endif
#ifdef BUTTON4_PRESSED
    rb_curses_define_const(BUTTON4_PRESSED);
#endif
#ifdef BUTTON4_RELEASED
    rb_curses_define_const(BUTTON4_RELEASED);
#endif
#ifdef BUTTON4_CLICKED
    rb_curses_define_const(BUTTON4_CLICKED);
#endif
#ifdef BUTTON4_DOUBLE_CLICKED
    rb_curses_define_const(BUTTON4_DOUBLE_CLICKED);
#endif
#ifdef BUTTON4_TRIPLE_CLICKED
    rb_curses_define_const(BUTTON4_TRIPLE_CLICKED);
#endif
#ifdef BUTTON_SHIFT
    rb_curses_define_const(BUTTON_SHIFT);
#endif
#ifdef BUTTON_CTRL
    rb_curses_define_const(BUTTON_CTRL);
#endif
#ifdef BUTTON_ALT
    rb_curses_define_const(BUTTON_ALT);
#endif
#ifdef ALL_MOUSE_EVENTS
    rb_curses_define_const(ALL_MOUSE_EVENTS);
#endif
#ifdef REPORT_MOUSE_POSITION
    rb_curses_define_const(REPORT_MOUSE_POSITION);
#endif
#endif /* USE_MOUSE */

#if defined(KEY_MOUSE) && defined(USE_MOUSE)
    rb_curses_define_const(KEY_MOUSE);
    rb_define_const(mKey, "MOUSE", INT2NUM(KEY_MOUSE));
#endif
#ifdef KEY_MIN
    rb_curses_define_const(KEY_MIN);
    rb_define_const(mKey, "MIN", INT2NUM(KEY_MIN));
#endif
#ifdef KEY_BREAK
    rb_curses_define_const(KEY_BREAK);
    rb_define_const(mKey, "BREAK", INT2NUM(KEY_BREAK));
#endif
#ifdef KEY_DOWN
    rb_curses_define_const(KEY_DOWN);
    rb_define_const(mKey, "DOWN", INT2NUM(KEY_DOWN));
#endif
#ifdef KEY_UP
    rb_curses_define_const(KEY_UP);
    rb_define_const(mKey, "UP", INT2NUM(KEY_UP));
#endif
#ifdef KEY_LEFT
    rb_curses_define_const(KEY_LEFT);
    rb_define_const(mKey, "LEFT", INT2NUM(KEY_LEFT));
#endif
#ifdef KEY_RIGHT
    rb_curses_define_const(KEY_RIGHT);
    rb_define_const(mKey, "RIGHT", INT2NUM(KEY_RIGHT));
#endif
#ifdef KEY_HOME
    rb_curses_define_const(KEY_HOME);
    rb_define_const(mKey, "HOME", INT2NUM(KEY_HOME));
#endif
#ifdef KEY_BACKSPACE
    rb_curses_define_const(KEY_BACKSPACE);
    rb_define_const(mKey, "BACKSPACE", INT2NUM(KEY_BACKSPACE));
#endif
#ifdef KEY_F
    /* KEY_F(n) : 0 <= n <= 63 */
    {
      int i;
      char c[8];
      for( i=0; i<64; i++ ){
	sprintf(c, "KEY_F%d", i);
	rb_define_const(mCurses, c, INT2NUM(KEY_F(i)));
	sprintf(c, "F%d", i);
	rb_define_const(mKey, c, INT2NUM(KEY_F(i)));
      }
    }
#endif
#ifdef KEY_DL
    rb_curses_define_const(KEY_DL);
    rb_define_const(mKey, "DL", INT2NUM(KEY_DL));
#endif
#ifdef KEY_IL
    rb_curses_define_const(KEY_IL);
    rb_define_const(mKey, "IL", INT2NUM(KEY_IL));
#endif
#ifdef KEY_DC
    rb_curses_define_const(KEY_DC);
    rb_define_const(mKey, "DC", INT2NUM(KEY_DC));
#endif
#ifdef KEY_IC
    rb_curses_define_const(KEY_IC);
    rb_define_const(mKey, "IC", INT2NUM(KEY_IC));
#endif
#ifdef KEY_EIC
    rb_curses_define_const(KEY_EIC);
    rb_define_const(mKey, "EIC", INT2NUM(KEY_EIC));
#endif
#ifdef KEY_CLEAR
    rb_curses_define_const(KEY_CLEAR);
    rb_define_const(mKey, "CLEAR", INT2NUM(KEY_CLEAR));
#endif
#ifdef KEY_EOS
    rb_curses_define_const(KEY_EOS);
    rb_define_const(mKey, "EOS", INT2NUM(KEY_EOS));
#endif
#ifdef KEY_EOL
    rb_curses_define_const(KEY_EOL);
    rb_define_const(mKey, "EOL", INT2NUM(KEY_EOL));
#endif
#ifdef KEY_SF
    rb_curses_define_const(KEY_SF);
    rb_define_const(mKey, "SF", INT2NUM(KEY_SF));
#endif
#ifdef KEY_SR
    rb_curses_define_const(KEY_SR);
    rb_define_const(mKey, "SR", INT2NUM(KEY_SR));
#endif
#ifdef KEY_NPAGE
    rb_curses_define_const(KEY_NPAGE);
    rb_define_const(mKey, "NPAGE", INT2NUM(KEY_NPAGE));
#endif
#ifdef KEY_PPAGE
    rb_curses_define_const(KEY_PPAGE);
    rb_define_const(mKey, "PPAGE", INT2NUM(KEY_PPAGE));
#endif
#ifdef KEY_STAB
    rb_curses_define_const(KEY_STAB);
    rb_define_const(mKey, "STAB", INT2NUM(KEY_STAB));
#endif
#ifdef KEY_CTAB
    rb_curses_define_const(KEY_CTAB);
    rb_define_const(mKey, "CTAB", INT2NUM(KEY_CTAB));
#endif
#ifdef KEY_CATAB
    rb_curses_define_const(KEY_CATAB);
    rb_define_const(mKey, "CATAB", INT2NUM(KEY_CATAB));
#endif
#ifdef KEY_ENTER
    rb_curses_define_const(KEY_ENTER);
    rb_define_const(mKey, "ENTER", INT2NUM(KEY_ENTER));
#endif
#ifdef KEY_SRESET
    rb_curses_define_const(KEY_SRESET);
    rb_define_const(mKey, "SRESET", INT2NUM(KEY_SRESET));
#endif
#ifdef KEY_RESET
    rb_curses_define_const(KEY_RESET);
    rb_define_const(mKey, "RESET", INT2NUM(KEY_RESET));
#endif
#ifdef KEY_PRINT
    rb_curses_define_const(KEY_PRINT);
    rb_define_const(mKey, "PRINT", INT2NUM(KEY_PRINT));
#endif
#ifdef KEY_LL
    rb_curses_define_const(KEY_LL);
    rb_define_const(mKey, "LL", INT2NUM(KEY_LL));
#endif
#ifdef KEY_A1
    rb_curses_define_const(KEY_A1);
    rb_define_const(mKey, "A1", INT2NUM(KEY_A1));
#endif
#ifdef KEY_A3
    rb_curses_define_const(KEY_A3);
    rb_define_const(mKey, "A3", INT2NUM(KEY_A3));
#endif
#ifdef KEY_B2
    rb_curses_define_const(KEY_B2);
    rb_define_const(mKey, "B2", INT2NUM(KEY_B2));
#endif
#ifdef KEY_C1
    rb_curses_define_const(KEY_C1);
    rb_define_const(mKey, "C1", INT2NUM(KEY_C1));
#endif
#ifdef KEY_C3
    rb_curses_define_const(KEY_C3);
    rb_define_const(mKey, "C3", INT2NUM(KEY_C3));
#endif
#ifdef KEY_BTAB
    rb_curses_define_const(KEY_BTAB);
    rb_define_const(mKey, "BTAB", INT2NUM(KEY_BTAB));
#endif
#ifdef KEY_BEG
    rb_curses_define_const(KEY_BEG);
    rb_define_const(mKey, "BEG", INT2NUM(KEY_BEG));
#endif
#ifdef KEY_CANCEL
    rb_curses_define_const(KEY_CANCEL);
    rb_define_const(mKey, "CANCEL", INT2NUM(KEY_CANCEL));
#endif
#ifdef KEY_CLOSE
    rb_curses_define_const(KEY_CLOSE);
    rb_define_const(mKey, "CLOSE", INT2NUM(KEY_CLOSE));
#endif
#ifdef KEY_COMMAND
    rb_curses_define_const(KEY_COMMAND);
    rb_define_const(mKey, "COMMAND", INT2NUM(KEY_COMMAND));
#endif
#ifdef KEY_COPY
    rb_curses_define_const(KEY_COPY);
    rb_define_const(mKey, "COPY", INT2NUM(KEY_COPY));
#endif
#ifdef KEY_CREATE
    rb_curses_define_const(KEY_CREATE);
    rb_define_const(mKey, "CREATE", INT2NUM(KEY_CREATE));
#endif
#ifdef KEY_END
    rb_curses_define_const(KEY_END);
    rb_define_const(mKey, "END", INT2NUM(KEY_END));
#endif
#ifdef KEY_EXIT
    rb_curses_define_const(KEY_EXIT);
    rb_define_const(mKey, "EXIT", INT2NUM(KEY_EXIT));
#endif
#ifdef KEY_FIND
    rb_curses_define_const(KEY_FIND);
    rb_define_const(mKey, "FIND", INT2NUM(KEY_FIND));
#endif
#ifdef KEY_HELP
    rb_curses_define_const(KEY_HELP);
    rb_define_const(mKey, "HELP", INT2NUM(KEY_HELP));
#endif
#ifdef KEY_MARK
    rb_curses_define_const(KEY_MARK);
    rb_define_const(mKey, "MARK", INT2NUM(KEY_MARK));
#endif
#ifdef KEY_MESSAGE
    rb_curses_define_const(KEY_MESSAGE);
    rb_define_const(mKey, "MESSAGE", INT2NUM(KEY_MESSAGE));
#endif
#ifdef KEY_MOVE
    rb_curses_define_const(KEY_MOVE);
    rb_define_const(mKey, "MOVE", INT2NUM(KEY_MOVE));
#endif
#ifdef KEY_NEXT
    rb_curses_define_const(KEY_NEXT);
    rb_define_const(mKey, "NEXT", INT2NUM(KEY_NEXT));
#endif
#ifdef KEY_OPEN
    rb_curses_define_const(KEY_OPEN);
    rb_define_const(mKey, "OPEN", INT2NUM(KEY_OPEN));
#endif
#ifdef KEY_OPTIONS
    rb_curses_define_const(KEY_OPTIONS);
    rb_define_const(mKey, "OPTIONS", INT2NUM(KEY_OPTIONS));
#endif
#ifdef KEY_PREVIOUS
    rb_curses_define_const(KEY_PREVIOUS);
    rb_define_const(mKey, "PREVIOUS", INT2NUM(KEY_PREVIOUS));
#endif
#ifdef KEY_REDO
    rb_curses_define_const(KEY_REDO);
    rb_define_const(mKey, "REDO", INT2NUM(KEY_REDO));
#endif
#ifdef KEY_REFERENCE
    rb_curses_define_const(KEY_REFERENCE);
    rb_define_const(mKey, "REFERENCE", INT2NUM(KEY_REFERENCE));
#endif
#ifdef KEY_REFRESH
    rb_curses_define_const(KEY_REFRESH);
    rb_define_const(mKey, "REFRESH", INT2NUM(KEY_REFRESH));
#endif
#ifdef KEY_REPLACE
    rb_curses_define_const(KEY_REPLACE);
    rb_define_const(mKey, "REPLACE", INT2NUM(KEY_REPLACE));
#endif
#ifdef KEY_RESTART
    rb_curses_define_const(KEY_RESTART);
    rb_define_const(mKey, "RESTART", INT2NUM(KEY_RESTART));
#endif
#ifdef KEY_RESUME
    rb_curses_define_const(KEY_RESUME);
    rb_define_const(mKey, "RESUME", INT2NUM(KEY_RESUME));
#endif
#ifdef KEY_SAVE
    rb_curses_define_const(KEY_SAVE);
    rb_define_const(mKey, "SAVE", INT2NUM(KEY_SAVE));
#endif
#ifdef KEY_SBEG
    rb_curses_define_const(KEY_SBEG);
    rb_define_const(mKey, "SBEG", INT2NUM(KEY_SBEG));
#endif
#ifdef KEY_SCANCEL
    rb_curses_define_const(KEY_SCANCEL);
    rb_define_const(mKey, "SCANCEL", INT2NUM(KEY_SCANCEL));
#endif
#ifdef KEY_SCOMMAND
    rb_curses_define_const(KEY_SCOMMAND);
    rb_define_const(mKey, "SCOMMAND", INT2NUM(KEY_SCOMMAND));
#endif
#ifdef KEY_SCOPY
    rb_curses_define_const(KEY_SCOPY);
    rb_define_const(mKey, "SCOPY", INT2NUM(KEY_SCOPY));
#endif
#ifdef KEY_SCREATE
    rb_curses_define_const(KEY_SCREATE);
    rb_define_const(mKey, "SCREATE", INT2NUM(KEY_SCREATE));
#endif
#ifdef KEY_SDC
    rb_curses_define_const(KEY_SDC);
    rb_define_const(mKey, "SDC", INT2NUM(KEY_SDC));
#endif
#ifdef KEY_SDL
    rb_curses_define_const(KEY_SDL);
    rb_define_const(mKey, "SDL", INT2NUM(KEY_SDL));
#endif
#ifdef KEY_SELECT
    rb_curses_define_const(KEY_SELECT);
    rb_define_const(mKey, "SELECT", INT2NUM(KEY_SELECT));
#endif
#ifdef KEY_SEND
    rb_curses_define_const(KEY_SEND);
    rb_define_const(mKey, "SEND", INT2NUM(KEY_SEND));
#endif
#ifdef KEY_SEOL
    rb_curses_define_const(KEY_SEOL);
    rb_define_const(mKey, "SEOL", INT2NUM(KEY_SEOL));
#endif
#ifdef KEY_SEXIT
    rb_curses_define_const(KEY_SEXIT);
    rb_define_const(mKey, "SEXIT", INT2NUM(KEY_SEXIT));
#endif
#ifdef KEY_SFIND
    rb_curses_define_const(KEY_SFIND);
    rb_define_const(mKey, "SFIND", INT2NUM(KEY_SFIND));
#endif
#ifdef KEY_SHELP
    rb_curses_define_const(KEY_SHELP);
    rb_define_const(mKey, "SHELP", INT2NUM(KEY_SHELP));
#endif
#ifdef KEY_SHOME
    rb_curses_define_const(KEY_SHOME);
    rb_define_const(mKey, "SHOME", INT2NUM(KEY_SHOME));
#endif
#ifdef KEY_SIC
    rb_curses_define_const(KEY_SIC);
    rb_define_const(mKey, "SIC", INT2NUM(KEY_SIC));
#endif
#ifdef KEY_SLEFT
    rb_curses_define_const(KEY_SLEFT);
    rb_define_const(mKey, "SLEFT", INT2NUM(KEY_SLEFT));
#endif
#ifdef KEY_SMESSAGE
    rb_curses_define_const(KEY_SMESSAGE);
    rb_define_const(mKey, "SMESSAGE", INT2NUM(KEY_SMESSAGE));
#endif
#ifdef KEY_SMOVE
    rb_curses_define_const(KEY_SMOVE);
    rb_define_const(mKey, "SMOVE", INT2NUM(KEY_SMOVE));
#endif
#ifdef KEY_SNEXT
    rb_curses_define_const(KEY_SNEXT);
    rb_define_const(mKey, "SNEXT", INT2NUM(KEY_SNEXT));
#endif
#ifdef KEY_SOPTIONS
    rb_curses_define_const(KEY_SOPTIONS);
    rb_define_const(mKey, "SOPTIONS", INT2NUM(KEY_SOPTIONS));
#endif
#ifdef KEY_SPREVIOUS
    rb_curses_define_const(KEY_SPREVIOUS);
    rb_define_const(mKey, "SPREVIOUS", INT2NUM(KEY_SPREVIOUS));
#endif
#ifdef KEY_SPRINT
    rb_curses_define_const(KEY_SPRINT);
    rb_define_const(mKey, "SPRINT", INT2NUM(KEY_SPRINT));
#endif
#ifdef KEY_SREDO
    rb_curses_define_const(KEY_SREDO);
    rb_define_const(mKey, "SREDO", INT2NUM(KEY_SREDO));
#endif
#ifdef KEY_SREPLACE
    rb_curses_define_const(KEY_SREPLACE);
    rb_define_const(mKey, "SREPLACE", INT2NUM(KEY_SREPLACE));
#endif
#ifdef KEY_SRIGHT
    rb_curses_define_const(KEY_SRIGHT);
    rb_define_const(mKey, "SRIGHT", INT2NUM(KEY_SRIGHT));
#endif
#ifdef KEY_SRSUME
    rb_curses_define_const(KEY_SRSUME);
    rb_define_const(mKey, "SRSUME", INT2NUM(KEY_SRSUME));
#endif
#ifdef KEY_SSAVE
    rb_curses_define_const(KEY_SSAVE);
    rb_define_const(mKey, "SSAVE", INT2NUM(KEY_SSAVE));
#endif
#ifdef KEY_SSUSPEND
    rb_curses_define_const(KEY_SSUSPEND);
    rb_define_const(mKey, "SSUSPEND", INT2NUM(KEY_SSUSPEND));
#endif
#ifdef KEY_SUNDO
    rb_curses_define_const(KEY_SUNDO);
    rb_define_const(mKey, "SUNDO", INT2NUM(KEY_SUNDO));
#endif
#ifdef KEY_SUSPEND
    rb_curses_define_const(KEY_SUSPEND);
    rb_define_const(mKey, "SUSPEND", INT2NUM(KEY_SUSPEND));
#endif
#ifdef KEY_UNDO
    rb_curses_define_const(KEY_UNDO);
    rb_define_const(mKey, "UNDO", INT2NUM(KEY_UNDO));
#endif
#ifdef KEY_RESIZE
    rb_curses_define_const(KEY_RESIZE);
    rb_define_const(mKey, "RESIZE", INT2NUM(KEY_RESIZE));
#endif
#ifdef KEY_MAX
    rb_curses_define_const(KEY_MAX);
    rb_define_const(mKey, "MAX", INT2NUM(KEY_MAX));
#endif
    {
      int c;
      char name[] = "KEY_CTRL_x";
      for( c = 'A'; c <= 'Z'; c++ ){
	sprintf(name, "KEY_CTRL_%c", c);
	rb_define_const(mCurses, name, INT2FIX(c - 'A' + 1));
      }
    }
#undef rb_curses_define_const

    rb_set_end_proc(curses_finalize, 0);
}
@


1.14
log
@* ext/curses/curses.c: follow allocation framework.
@
text
@d2 1
a2 1
 * $Id: curses.c,v 1.13 2002/01/29 19:24:43 ttate Exp $
d16 1
a16 1
#ifdef HAVE_NCURSES_H
d18 5
d24 12
a35 20
# ifdef HAVE_NCURSES_CURSES_H
#  include <ncurses/curses.h>
#else
# ifdef HAVE_CURSES_COLR_CURSES_H
#  include <varargs.h>
#  include <curses_colr/curses.h>
# else
#  include <curses.h>
#  if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__)) && !defined(_maxx)
#   define _maxx maxx
#  endif
#  if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__)) && !defined(_maxy)
#   define _maxy maxy
#  endif
#  if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__)) && !defined(_begx)
#   define _begx begx
#  endif
#  if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__)) && !defined(_begy)
#   define _begy begy
#  endif
a37 1
#endif
d48 1
a48 1
#include "stdio.h"
d77 1
a77 2

#define GetWINDOW(obj, winp) {\
d80 1
a80 2
}

d593 1
a593 1
};
d595 1
a595 1
#define GetMOUSE(obj, data) {\
d598 1
a598 1
}
d605 1
a605 1
};
d617 1
a617 1
};
d626 1
a626 1
};
d632 1
a632 1
};
d638 1
a638 1
};
d648 5
a652 5
DEFINE_MOUSE_GET_MEMBER(curs_mouse_id, id);
DEFINE_MOUSE_GET_MEMBER(curs_mouse_x, x);
DEFINE_MOUSE_GET_MEMBER(curs_mouse_y, y);
DEFINE_MOUSE_GET_MEMBER(curs_mouse_z, z);
DEFINE_MOUSE_GET_MEMBER(curs_mouse_bstate, bstate);
a828 1
    int x, y;
d831 1
a831 1
#ifdef getmaxy
d833 6
a838 4
#else
#ifdef getmaxyx
    getmaxyx(winp->window, y, x);
    return INT2FIX(y);
a841 1
#endif
a849 1
    int x, y;
d852 1
a852 1
#ifdef getmaxx
d854 6
a859 4
#else
#ifdef getmaxyx
    getmaxyx(winp->window, y, x);
    return INT2FIX(x);
a862 1
#endif
d913 1
a913 1
    if( argc == 3 ){
a1092 1
  int res;
d1109 1
a1109 1
};
d1138 1
a1138 1
};
d1155 2
a1156 2
  };
};
d1225 1
a1225 1
};
d1533 2
a1534 2
      };
    };
d1874 1
a1874 1
      };
@


1.13
log
@Add wresize, resizeterm and KEY_RESIZE.
@
text
@d2 1
a2 1
 * $Id: curses.c,v 1.12 2001/12/10 07:18:14 matz Exp $
d63 1
a63 1
VALUE rb_stdscr;
d109 2
a110 1
    obj = Data_Make_Struct(class, struct windata, 0, free_window, winp);
d122 1
d133 1
a133 6
static VALUE
curses_stdscr()
{
    if (rb_stdscr == 0) curses_init_screen();
    return rb_stdscr;
}
d143 1
d156 2
d664 1
a664 1
/* def new(h, w, top, left) */
d666 1
a666 1
window_s_new(class, h, w, top, left)
d668 10
d683 1
a683 1
    VALUE win;
d685 4
a688 2
    VALUE args[4];
    
d691 1
a691 2
    win = prep_window(class, window);
    args[0] = h; args[1] = w; args[2] = top; args[3] = left;
d693 1
a693 1
    return win;
a707 1
    VALUE args[4];
d712 1
a712 2
    win = prep_window(cWindow, window);
    args[0] = h; args[1] = w; args[2] = top; args[3] = left;
d1239 4
a1242 2
  mCurses    = rb_define_module("Curses");
  mKey       = rb_define_module_under(mCurses, "Key");
d1317 3
a1319 2
    cWindow = rb_define_class_under(mCurses, "Window", rb_cObject);
    rb_define_singleton_method(cWindow, "new", window_s_new, 4);
@


1.12
log
@* array.c (rb_ary_modify): should copy the internal buffer if the
  modifying buffer is shared.

* array.c (ary_make_shared): make an internal buffer of an array
  to be shared.

* array.c (rb_ary_shift): avoid sliding an internal buffer by
  using shared buffer.

* array.c (rb_ary_subseq): avoid copying the buffer.

* parse.y (gettable): should freeze __LINE__ string.

* io.c (rb_io_puts): old behavoir restored.  rationale: a) if you
  want to call to_s for arrays, you can just call print a, "\n".
  b) to_s wastes memory if array (and sum of its contents) is
  huge.  c) now any object that has to_ary is treated as an array,
  using rb_check_convert_type().

* hash.c (rb_hash_initialize): now accepts a block to calculate
  the default value. [new]

* hash.c (rb_hash_aref): call "default" method to get the value
  corrensponding to the non existing key.

* hash.c (rb_hash_default): get the default value based on the
  block given to 'new'.  Now it takes an optinal "key" argument.
  "default" became the method to get the value for non existing
  key.  Users may override "default" method to change the hash
  behavior.

* hash.c (rb_hash_set_default): clear the flag if a block is given
  to 'new'

* object.c (Init_Object): undef Data.allocate, left Data.new.

* ext/curses/curses.c (window_scrollok): use RTEST().

* ext/curses/curses.c (window_idlok): ditto.

* ext/curses/curses.c (window_keypad): ditto.

* ext/curses/curses.c (window_idlok): idlok() may return void on
  some platforms; so don't use return value.

* ext/curses/curses.c (window_scrollok): ditto for consistency.

* ext/curses/curses.c: replace FIX2INT() by typechecking NUM2INT().

* parse.y (str_extend): should not process immature #$x and
  #@@x interpolation, e.g #@@#@@ etc.

* enum.c (enum_sort_by): sort_by does not have to be stable always.

* enum.c (enum_sort_by): call qsort directly to gain performance.

* util.c (ruby_qsort): ruby_qsort(qs6) is now native thread safe.

* error.c (rb_sys_fail): it must be a bug if it's called when
  errno == 0.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@d2 1
a2 1
 * $Id: curses.c,v 1.11 2001/11/29 23:59:15 ttate Exp $
d514 10
d1193 14
d1285 2
d1338 1
d1854 4
@


1.11
log
@bug fix for getnstr() and wgetnstr()
@
text
@d2 1
a2 1
 * $Id: curses.c,v 1.10 2001/11/23 09:53:54 ttate Exp $
d463 1
a463 1
  return (n = curs_set(FIX2INT(visibility)) != ERR) ? INT2FIX(n) : Qnil;
d469 1
d476 1
d484 1
a484 1
  /* return INT2FIX(attroff(FIX2INT(attrs))); */
d491 1
a491 1
  /* return INT2FIX(attroff(FIX2INT(attrs))); */
d498 1
a498 1
  /* return INT2FIX(attroff(FIX2INT(attrs))); */
d518 1
d525 2
a526 1
  return (init_pair(FIX2INT(pair),FIX2INT(f),FIX2INT(b)) == OK) ? Qtrue : Qfalse;
d532 3
a534 2
  return (init_color(FIX2INT(color),FIX2INT(r),
		     FIX2INT(g),FIX2INT(b)) == OK) ? Qtrue : Qfalse;
d554 1
a554 1
  color_content(FIX2INT(color),&r,&g,&b);
d563 1
a563 1
  pair_content(FIX2INT(pair),&f,&b);
d570 1
a570 1
  return INT2FIX(COLOR_PAIR(FIX2INT(attrs)));
d576 1
a576 1
  return INT2FIX(PAIR_NUMBER(FIX2INT(attrs)));
d599 1
a599 1
  if( mdata->mevent )
d612 1
a612 1
  return ( getmouse(mdata->mevent) == OK ) ? val : Qnil;
d906 2
a907 2
      x = FIX2INT(window_maxx(self)) - 1;
      y = FIX2INT(window_maxy(self)) - 1;
a1069 1
  int res;
d1072 2
a1073 2
  res = scrollok(winp->window, (bf == Qtrue) ? TRUE : FALSE);
  return (res == OK) ? Qtrue : Qfalse;
d1083 2
a1084 2
  res = idlok(winp->window, (bf == Qtrue) ? TRUE : FALSE);
  return (res == OK) ? Qtrue : Qfalse;
d1095 1
d1105 1
d1115 1
d1125 1
a1125 1
  return INT2FIX(wattroff(winp->window,FIX2INT(attrs)));
d1135 1
a1135 1
  val = INT2FIX(wattron(winp->window,FIX2INT(attrs)));
d1138 1
a1138 1
    wattroff(winp->window,FIX2INT(attrs));
d1152 1
a1152 1
  return INT2FIX(wattrset(winp->window,FIX2INT(attrs)));
d1192 1
a1192 1
  keypad(winp->window,(val == Qtrue ? TRUE : FALSE));
d1195 2
a1196 1
  return (keypad(winp->window,(val == Qtrue) ? TRUE : FALSE)) == OK ?
@


1.10
log
@Curses::getstr and Window#getstr use getnstr() and wgetnstr()
if they are available.
@
text
@d2 1
a2 1
 * $Id: curses.c,v 1.9 2001/08/16 07:24:20 ttate Exp $
d399 1
a399 1
#ifdef GETNSTR
d1027 1
a1027 1
#ifdef WGETNSTR
@


1.9
log
@* curses.c: fix window_keypad() and curses_keyname() for NetBSD's libcurses.
* curses.c: attribute control routines and background manipulation routines
  are always available.
@
text
@d2 1
a2 1
 * $Id: curses.c,v 1.8 2001/08/13 02:13:06 ttate Exp $
d10 1
a10 1
 *         and Takaaki Tateishi (ttate@@jaist.ac.jp)
d13 1
a13 1
 * - Takaaki Tateishi (ttate@@jaist.ac.jp)
d399 3
d403 1
d1027 3
d1031 1
@


1.8
log
@bug fix for Window#{keypad,keypad=}
@
text
@d2 1
a2 1
 * $Id: curses.c,v 1.7 2001/08/12 23:42:44 ttate Exp $
d429 1
d432 6
a437 7
#ifdef HAVE_KEYPAD
    name = keyname(NUM2INT(c));
    if (name) {
        return rb_str_new2(name);
    } else {
        return Qnil;
    }
d439 1
a439 1
    return Qnil;
a473 1
#ifdef USE_COLOR
d496 14
d569 1
a569 14

static VALUE
curses_bkgdset(VALUE obj, VALUE ch)
{
  bkgdset(NUM2CHR(ch));
  return Qnil;
}

static VALUE
curses_bkgd(VALUE obj, VALUE ch)
{
  return CHR2FIX(bkgd(NUM2CHR(ch)));
}
#endif /* USE_COLOR */
a1103 1
#ifdef USE_COLOR
d1167 1
a1167 1
#endif /* USE_COLOR */
d1175 5
d1182 1
a1239 1
#ifdef USE_COLOR
d1243 3
a1255 2
    rb_define_module_function(mCurses, "bkgdset", curses_bkgdset, 1);
    rb_define_module_function(mCurses, "bkgd", curses_bkgd, 1);
d1324 1
d1326 1
d1818 1
a1818 1
      char keyname[] = "KEY_CTRL_x";
d1820 2
a1821 2
	sprintf(keyname, "KEY_CTRL_%c", c);
	rb_define_const(mCurses, keyname, INT2FIX(c - 'A' + 1));
@


1.7
log
@new methods and constants for using the mouse, character attributes,
colors and key codes.
@
text
@d2 1
a2 1
 * $Id: curses.c,v 1.6 2001/08/07 07:15:55 ttate Exp $
d1169 1
a1169 1
#ifdef USE_MOUSE
d1179 1
a1179 1
#endif /* USE_MOUSE */
d1291 1
d1294 1
@


1.6
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d1 3
a3 1
/*
d7 7
a13 1
 * modified by Yukihiro Matsumoto (matz@@netlab.co.jp)
d27 1
a27 1
#  if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__) ) && !defined(_maxx)
d43 9
d57 1
d59 3
d69 6
d81 1
a86 1
#define CHECK(c) c
d127 1
a127 1
    return Qnil;
d377 1
a377 1
	addstr(StringValuePtr(str));
d388 1
a388 1
    return CHR2FIX(getch());
d417 1
a417 1
#ifdef HAVE_DELETELN
d423 20
d455 188
d729 1
a729 1
/* def box(vert, hor) */
d731 1
a731 1
window_box(obj, vert, hor)
a732 2
    VALUE vert;
    VALUE hor;
d734 2
a735 2
    struct windata *winp; 
   
d737 6
a742 2
    box(winp->window, NUM2CHR(vert), NUM2CHR(hor));
    
a745 1

d877 36
d986 1
a986 1
	waddstr(winp->window, StringValuePtr(str));
d1010 1
a1010 1
    return CHR2FIX(wgetch(winp->window));
d1044 1
a1044 1
#ifdef HAVE_WDELETELN
d1053 128
d1185 13
a1197 1
    mCurses = rb_define_module("Curses");
d1229 1
d1232 27
a1258 1
    
d1265 2
a1266 1
    rb_define_method(cWindow, "box", window_box, 2);
d1286 530
@


1.5
log
@* eval.c: remove TMP_PROTECT_END to prevent C_ALLOCA crash.

* file.c (rb_file_flock): do not trap EINTR.

* missing/flock.c (flock): returns the value from lockf(2)
  directly.

* eval.c (ev_const_defined): should ignore toplevel cbase (Object).

* eval.c (ev_const_get): ditto.

* ext/md5/md5.h: replace by independent md5 implementation
  contributed by L. Peter Deutsch (thanks).

* ext/md5/md5init.c: adopted to Deutsch's md5 implementation.

* pack.c (pack_unpack): string from P/p should be tainted.

* ext/curses/curses.c: curses on Mac OS X public beta does not
  have _maxx etc.

* marshal.c (w_object): should truncate trailing zero short for
  bignums.

* object.c (sym_intern): new method.
@
text
@d350 1
a350 1
	addstr(STR2CSTR(str));
d714 1
a714 1
	waddstr(winp->window, STR2CSTR(str));
@


1.4
log
@2000-03-06
@
text
@d19 1
a19 1
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_maxx)
d22 1
a22 1
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_maxy)
d25 1
a25 1
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_begx)
d28 1
a28 1
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_begy)
@


1.4.2.1
log
@* eval.c: remove TMP_PROTECT_END to prevent C_ALLOCA crash.

* eval.c (ev_const_defined): should ignore toplevel cbase (Object).

* eval.c (ev_const_get): ditto.

* ext/curses/curses.c: curses on Mac OS X public beta does not
  have _maxx etc.

* marshal.c (w_object): should truncate trailing zero short for
  bignums.
@
text
@d19 1
a19 1
#  if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__) ) && !defined(_maxx)
d22 1
a22 1
#  if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__)) && !defined(_maxy)
d25 1
a25 1
#  if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__)) && !defined(_begx)
d28 1
a28 1
#  if (defined(__bsdi__) || defined(__NetBSD__) || defined(__APPLE__)) && !defined(_begy)
@


1.3
log
@2000-02-02
@
text
@a426 1
    rb_obj_call_init(win, 4, args);
a449 1
    rb_obj_call_init(win, 4, args);
@


1.2
log
@remove marshal/gtk/kconv
@
text
@d410 1
a410 1
/* def new(lines, cols, top, left) */
d412 1
a412 1
window_s_new(class, lines, cols, top, left)
d414 2
a415 2
    VALUE lines;
    VALUE cols;
d419 1
a419 1
    VALUE w;
d423 1
a423 1
    window = newwin(NUM2INT(lines), NUM2INT(cols), NUM2INT(top), NUM2INT(left));
d425 3
a427 3
    w = prep_window(class, window);
    args[0] = lines; args[1] = cols; args[2] = top; args[3] = left;
    rb_obj_call_init(w, 4, args);
d429 1
a429 1
    return w;
d432 1
a432 1
/* def subwin(lines, cols, top, left) */
d434 1
a434 1
window_subwin(obj, lines, cols, top, left)
d436 2
a437 2
    VALUE lines;
    VALUE cols;
d443 1
a443 1
    VALUE w;
d447 1
a447 1
    window = subwin(winp->window, NUM2INT(lines), NUM2INT(cols),
d449 3
a451 3
    w = prep_window(cWindow, window);
    args[0] = lines; args[1] = cols; args[2] = top; args[3] = left;
    rb_obj_call_init(w, 4, args);
d453 1
a453 1
    return w;
@


1.2.2.1
log
@2000-02-02
@
text
@d410 1
a410 1
/* def new(h, w, top, left) */
d412 1
a412 1
window_s_new(class, h, w, top, left)
d414 2
a415 2
    VALUE h;
    VALUE w;
d419 1
a419 1
    VALUE win;
d423 1
a423 1
    window = newwin(NUM2INT(h), NUM2INT(w), NUM2INT(top), NUM2INT(left));
d425 3
a427 3
    win = prep_window(class, window);
    args[0] = h; args[1] = w; args[2] = top; args[3] = left;
    rb_obj_call_init(win, 4, args);
d429 1
a429 1
    return win;
d432 1
a432 1
/* def subwin(h, w, top, left) */
d434 1
a434 1
window_subwin(obj, h, w, top, left)
d436 2
a437 2
    VALUE h;
    VALUE w;
d443 1
a443 1
    VALUE win;
d447 1
a447 1
    window = subwin(winp->window, NUM2INT(h), NUM2INT(w),
d449 3
a451 3
    win = prep_window(cWindow, window);
    args[0] = h; args[1] = w; args[2] = top; args[3] = left;
    rb_obj_call_init(win, 4, args);
d453 1
a453 1
    return win;
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 * modified by Yukihiro Matsumoto (matz@@ruby.club.or.jp)
d13 4
d19 1
a19 1
#  if defined(__NetBSD__) && !defined(_maxx)
d22 1
a22 1
#  if defined(__NetBSD__) && !defined(_maxy)
d25 6
d33 1
d35 1
d37 1
a47 3
#define NUM2CHAR(x) (char)NUM2INT(x)
#define CHAR2FIX(x) INT2FIX((int)x)

d51 1
a51 1
    Fail("already closed window");
d59 1
a59 7
static void
curses_err()
{
    Fail("curses error");
}

#define CHECK(c) if ((c)==ERR) {curses_err();}
d67 1
d79 1
a79 1
	Fail("failed to create window");
d96 1
a96 1
	Fail("cannot initialize curses");
d107 1
a107 1
    if (!rb_stdscr) curses_init_screen();
d115 4
a118 1
    CHECK(endwin());
d122 11
d137 1
a137 1
#ifdef HAVE_ENDWIN
d139 1
a139 1
	return TRUE;
d141 1
a141 1
    return FALSE;
d161 1
a161 1
    CHECK(refresh());
d165 1
a165 1
/* def refresh */
d170 5
a174 1
    CHECK(doupdate());
d183 1
a183 1
    CHECK(echo());
d192 1
a192 1
    CHECK(noecho());
d201 1
a201 1
    CHECK(raw());
d210 1
a210 1
    CHECK(noraw());
d219 1
a219 1
    CHECK(cbreak());
d228 1
a228 1
    CHECK(nocbreak());
d237 1
a237 1
    CHECK(nl());
d246 1
a246 1
    CHECK(nonl());
d266 1
d268 1
d279 1
a279 1
    CHECK(ungetch(NUM2INT(ch)));
d293 1
a293 1
    CHECK(move(NUM2INT(y), NUM2INT(x)));
d320 1
a320 1
    return CHAR2FIX(inch());
d329 1
a329 1
    CHECK(addch(NUM2CHAR(ch)));
d339 1
a339 1
    CHECK(insch(NUM2CHAR(ch)));
d349 3
a351 1
    addstr(RSTRING(str)->ptr);
d360 2
a361 1
    return CHAR2FIX(getch());
d370 4
a373 2
    CHECK(getstr(rtn));
    return str_taint(str_new2(rtn));
d381 1
a381 1
    CHECK(delch());
d390 3
a392 1
    CHECK(deleteln());
d419 1
d421 1
d425 5
a429 1
    return prep_window(class, window);
d443 2
d449 5
a453 1
    return prep_window(cWindow, window);
d464 2
a465 1
    free_window(winp);
d491 1
a491 1
    CHECK(wrefresh(winp->window));
d506 1
a506 1
    box(winp->window, NUM2CHAR(vert), NUM2CHAR(hor));
d522 1
a522 1
    CHECK(mvwin(winp->window, NUM2INT(y), NUM2INT(x)));
d537 1
a537 1
    CHECK(wmove(winp->window, NUM2INT(y), NUM2INT(x)));
d675 1
a675 1
    return CHAR2FIX(winch(winp->window));
d687 1
a687 1
    CHECK(waddch(winp->window, NUM2CHAR(ch)));
d701 1
a701 1
    CHECK(winsch(winp->window, NUM2CHAR(ch)));
d712 6
a717 5
    struct windata *winp;
    
    GetWINDOW(obj, winp);
    CHECK(waddstr(winp->window, RSTRING(str)->ptr));
    
d738 1
d740 1
a740 1
    return CHAR2FIX(wgetch(winp->window));
d752 3
a754 2
    CHECK(wgetstr(winp->window, rtn));
    return str_taint(str_new2(rtn));
d765 1
a765 1
    CHECK(wdelch(winp->window));
d774 1
d778 2
a779 1
    CHECK(wdeleteln(winp->window));
d822 1
a822 1
    cWindow = rb_define_class_under(mCurses, "Window", cObject);
d848 2
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d35 1
a35 2
#define NUM2CHAR(x) ((TYPE(x) == T_STRING)&&(RSTRING(x)->len>=1))?\
    RSTRING(x)->ptr[0]:(char)NUM2INT(x)
d49 7
a55 1
#define CHECK(c) c
d102 1
a102 1
    if (rb_stdscr == 0) curses_init_screen();
d110 1
a110 1
    endwin();
d142 1
a142 1
    refresh();
d151 1
a151 1
    doupdate();
d160 1
a160 1
    echo();
d169 1
a169 1
    noecho();
d178 1
a178 1
    raw();
d187 1
a187 1
    noraw();
d196 1
a196 1
    cbreak();
d205 1
a205 1
    nocbreak();
d214 1
a214 1
    nl();
d223 1
a223 1
    nonl();
d254 1
a254 1
    ungetch(NUM2INT(ch));
d268 1
a268 1
    move(NUM2INT(y), NUM2INT(x));
d304 1
a304 1
    addch(NUM2CHAR(ch));
d314 1
a314 1
    insch(NUM2CHAR(ch));
d342 1
a342 1
    getstr(rtn);
d351 1
a351 1
    delch();
d360 1
a360 1
    deleteln();
d446 1
a446 1
    wrefresh(winp->window);
d477 1
a477 1
    mvwin(winp->window, NUM2INT(y), NUM2INT(x));
d492 1
a492 1
    wmove(winp->window, NUM2INT(y), NUM2INT(x));
d642 1
a642 1
    waddch(winp->window, NUM2CHAR(ch));
d656 1
a656 1
    winsch(winp->window, NUM2CHAR(ch));
d670 1
a670 1
    waddstr(winp->window, RSTRING(str)->ptr);
d705 1
a705 1
    wgetstr(winp->window, rtn);
d717 1
a717 1
    wdelch(winp->window);
d729 1
a729 1
    wdeleteln(winp->window);
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d5 1
a5 1
 * modified by Yukihiro Matsumoto (matz@@netlab.co.jp)
d15 1
a15 1
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_maxx)
d18 1
a18 1
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_maxy)
a20 6
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_begx)
#   define _begx begx
#  endif
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_begy)
#   define _begy begy
#  endif
d35 4
d42 1
a42 1
    rb_raise(rb_eRuntimeError, "already closed window");
a57 1
    free(winp);
d69 1
a69 1
	rb_raise(rb_eRuntimeError, "failed to create window");
d86 1
a86 1
	rb_raise(rb_eRuntimeError, "cannot initialize curses");
d105 1
a105 4
#ifdef HAVE_ISENDWIN
    if (!isendwin())
#endif
	endwin();
a108 11
static void
curses_finalize()
{
    if (stdscr
#ifdef HAVE_ISENDWIN
	&& !isendwin()
#endif
	)
	endwin();
}

d113 1
a113 1
#ifdef HAVE_ISENDWIN
d115 1
a115 1
	return Qtrue;
d117 1
a117 1
    return Qfalse;
d141 1
a141 1
/* def doupdate */
a145 1
#ifdef HAVE_DOUPDATE
a146 3
#else
    refresh();
#endif
a237 1
#ifdef HAVE_FLASH
a238 1
#endif
d290 1
a290 1
    return CHR2FIX(inch());
d299 1
a299 1
    addch(NUM2CHR(ch));
d309 1
a309 1
    insch(NUM2CHR(ch));
d319 1
a319 3
    if (!NIL_P(str)) {
	addstr(STR2CSTR(str));
    }
d328 1
a328 1
    return CHR2FIX(getch());
d338 1
a338 1
    return rb_tainted_str_new2(rtn);
a354 1
#ifdef HAVE_DELETELN
a355 1
#endif
a381 1
    VALUE w;
d386 1
a386 4
    w = prep_window(class, window);
    rb_obj_call_init(w);

    return w;
d415 1
a415 2
    delwin(winp->window);
    winp->window = 0;
d456 1
a456 1
    box(winp->window, NUM2CHR(vert), NUM2CHR(hor));
d625 1
a625 1
    return CHR2FIX(winch(winp->window));
d637 1
a637 1
    waddch(winp->window, NUM2CHR(ch));
d651 1
a651 1
    winsch(winp->window, NUM2CHR(ch));
d662 5
a666 6
    if (!NIL_P(str)) {
	struct windata *winp;

	GetWINDOW(obj, winp);
	waddstr(winp->window, STR2CSTR(str));
    }
d688 1
a688 1
    return CHR2FIX(wgetch(winp->window));
d701 1
a701 1
    return rb_tainted_str_new2(rtn);
a720 1
#ifdef HAVE_WDELETELN
a724 1
#endif
d767 1
a767 1
    cWindow = rb_define_class_under(mCurses, "Window", rb_cObject);
a792 2

    rb_set_end_proc(curses_finalize, 0);
@


1.1.1.3.2.1
log
@990224
@
text
@a13 3
#ifdef __hpux
#include <curses_colr/curses.h>
#else
a27 1
#endif
@


1.1.1.3.2.2
log
@990225
@
text
@a414 1
    VALUE args[4];
d419 1
a419 2
    args[0] = lines; args[1] = cols; args[2] = top; args[3] = left;
    rb_obj_call_init(w, 4, args);
a434 2
    VALUE w;
    VALUE args[4];
d439 1
a439 5
    w = prep_window(cWindow, window);
    args[0] = lines; args[1] = cols; args[2] = top; args[3] = left;
    rb_obj_call_init(w, 4, args);

    return w;
@


1.1.1.3.2.3
log
@small fixes
@
text
@d13 3
a16 4
# ifdef HAVE_CURSES_COLR_CURSES_H
#  include <varargs.h>
#  include <curses_colr/curses.h>
# else
@


1.1.1.3.2.4
log
@990611
@
text
@a34 1
#include "stdio.h"
a35 1
#include "rubyio.h"
a357 1
    rb_read_check(stdin);
a366 2

    rb_read_check(stdin);
a732 1
    rb_read_check(stdin);
a745 1
    rb_read_check(stdin);
@


1.1.1.2.2.1
log
@1.1b8pre1
@
text
@a57 1
    free(winp);
@


1.1.1.2.2.2
log
@shugo's method etc.
@
text
@d35 4
d291 1
a291 1
    return CHR2FIX(inch());
d300 1
a300 1
    addch(NUM2CHR(ch));
d310 1
a310 1
    insch(NUM2CHR(ch));
d329 1
a329 1
    return CHR2FIX(getch());
d457 1
a457 1
    box(winp->window, NUM2CHR(vert), NUM2CHR(hor));
d626 1
a626 1
    return CHR2FIX(winch(winp->window));
d638 1
a638 1
    waddch(winp->window, NUM2CHR(ch));
d652 1
a652 1
    winsch(winp->window, NUM2CHR(ch));
d689 1
a689 1
    return CHR2FIX(wgetch(winp->window));
@


1.1.1.2.2.3
log
@*** empty log message ***
@
text
@d102 1
a102 4
#ifdef HAVE_ISENDWIN
    if (!isendwin())
#endif
	endwin();
a105 9
static void
curses_finalize()
{
#ifdef HAVE_ISENDWIN
    if (!isendwin())
#endif
	endwin();
}

d110 1
a110 1
#ifdef HAVE_ISENDWIN
d316 1
a316 1
    addstr(STR2CSTR(str));
d662 1
a662 1
    waddstr(winp->window, STR2CSTR(str));
a789 2

    rb_set_end_proc(curses_finalize, 0);
@


1.1.1.2.2.4
log
@1.1b9_00
@
text
@a111 1
    if (stdscr
d113 1
a113 1
	&& !isendwin()
a114 1
	)
@


1.1.1.2.2.5
log
@double free
@
text
@d426 1
a426 2
    delwin(winp->window);
    winp->window = 0;
@


1.1.1.2.2.6
log
@String#dump
@
text
@d5 1
a5 1
 * modified by Yukihiro Matsumoto (matz@@netlab.co.jp)
@


1.1.1.2.2.7
log
@call initialize
@
text
@a392 1
    VALUE w;
d397 1
a397 4
    w = prep_window(class, window);
    obj_call_init(w);

    return w;
@


1.1.1.2.2.8
log
@pack/unpack unsigned
@
text
@d15 1
a15 1
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_maxx)
d18 1
a18 1
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_maxy)
a19 6
#  endif
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_begx)
#   define _begx begx
#  endif
#  if (defined(__bsdi__) || defined(__NetBSD__)) && !defined(_begy)
#   define _begy begy
@


1.1.1.2.2.9
log
@*** empty log message ***
@
text
@d336 1
a336 5
    char *s = STR2CSTR(str);

    if (s) {
	addstr(s);
    }
d684 5
a688 8
    char *s = STR2CSTR(str);

    if (s) {
	struct windata *winp;

	GetWINDOW(obj, winp);
	waddstr(winp->window, s);
    }
@


1.1.1.2.2.10
log
@str2cstr
@
text
@d336 4
a339 2
    if (!NIL_P(str)) {
	addstr(STR2CSTR(str));
d688 3
a690 1
    if (!NIL_P(str)) {
d694 1
a694 1
	waddstr(winp->window, STR2CSTR(str));
@


1.1.1.2.2.11
log
@1.1c7
@
text
@d158 1
a158 1
/* def doupdate */
a162 1
#ifdef HAVE_DOUPDATE
a163 3
#else
    refresh();
#endif
a254 1
#ifdef HAVE_FLASH
a255 1
#endif
@


1.1.1.2.2.10.2.1
log
@1.1d series
@
text
@d44 1
a44 1
    rb_raise(rb_eRuntimeError, "already closed window");
d72 1
a72 1
	rb_raise(rb_eRuntimeError, "failed to create window");
d89 1
a89 1
	rb_raise(rb_eRuntimeError, "cannot initialize curses");
d132 1
a132 1
	return Qtrue;
d134 1
a134 1
    return Qfalse;
d357 1
a357 1
    return rb_str_taint(rb_str_new2(rtn));
d407 1
a407 1
    rb_obj_call_init(w);
d726 1
a726 1
    return rb_str_taint(rb_str_new2(rtn));
d792 1
a792 1
    cWindow = rb_define_class_under(mCurses, "Window", rb_cObject);
@


1.1.1.2.2.10.2.2
log
@*** empty log message ***
@
text
@d158 1
a158 1
/* def doupdate */
a162 1
#ifdef HAVE_DOUPDATE
a163 3
#else
    refresh();
#endif
a254 1
#ifdef HAVE_FLASH
a255 1
#endif
@


1.1.1.2.2.10.2.3
log
@1.1d1
@
text
@d363 1
a363 1
    return rb_tainted_str_new2(rtn);
a379 1
#ifdef HAVE_DELETELN
a380 1
#endif
d732 1
a732 1
    return rb_tainted_str_new2(rtn);
a751 1
#ifdef HAVE_WDELETELN
a755 1
#endif
@
