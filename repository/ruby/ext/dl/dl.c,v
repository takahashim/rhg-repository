head	1.12;
access;
symbols;
locks; strict;
comment	@ * @;


1.12
date	2002.08.04.13.49.13;	author ttate;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.11.14.59.43;	author ttate;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.11.14.44.53;	author ttate;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.11.11.16.56;	author ttate;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.11.01.27.47;	author H_Konishi;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.10.07.52.10;	author ttate;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.09.17.47.33;	author ttate;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.20.15.35.48;	author ttate;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.06.23.04;	author ttate;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.04.08.27.48;	author ttate;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.03.11.59.01;	author ttate;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.02.10.56.13;	author ttate;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Conform to the allocation framework.
@
text
@/*
 * $Id: dl.c,v 1.11 2002/06/11 14:59:43 ttate Exp $
 */

#include <ruby.h>
#include <rubyio.h>
#include <ctype.h>
#include "dl.h"

VALUE rb_mDL;
VALUE rb_eDLError;
VALUE rb_eDLTypeError;

static VALUE DLFuncTable;
static void *rb_dl_callback_table[CALLBACK_TYPES][MAX_CALLBACK];
static ID id_call;

static int
rb_dl_scan_callback_args(long stack[], const char *proto,
			 int *argc, VALUE argv[])
{
  int i;
  long *sp;
  VALUE val;

  sp = stack;
  for( i=1; proto[i]; i++ ){
    switch( proto[i] ){
    case 'C':
      {
	char v;
	v = (char)(*sp);
	sp++;
	val = INT2NUM(v);
      }
      break;
    case 'H':
      {
	short v;
	v = (short)(*sp);
	sp++;
	val = INT2NUM(v);
      }
      break;
    case 'I':
      {
	int v;
	v = (int)(*sp);
	sp++;
	val = INT2NUM(v);
      }
      break;
    case 'L':
      {
	long v;
	v = (long)(*sp);
	sp++;
	val = INT2NUM(v);
      }
      break;
    case 'F':
      {
	float v;
	memcpy(&v, sp, sizeof(float));
	sp += sizeof(float)/sizeof(long);
	val = rb_float_new(v);
      }
      break;
    case 'D':
      {
	double v;
	memcpy(&v, sp, sizeof(double));
	sp += sizeof(double)/sizeof(long);
	val = rb_float_new(v);
      }
      break;
    case 'P':
      {
	void *v;
	memcpy(&v, sp, sizeof(void*));
	sp++;
	val = rb_dlptr_new(v, 0, 0);
      }
      break;
    case 'S':
      {
	char *v;
	memcpy(&v, sp, sizeof(void*));
	sp++;
	val = rb_tainted_str_new2(v);
      }
      break;
    default:
      rb_raise(rb_eDLTypeError, "unsupported type `%c'", proto[i]);
      break;
    }
    argv[i-1] = val;
  }
  *argc = (i - 1);

  return (*argc);
}

#include "callback.func"

static void
init_dl_func_table(){
#include "cbtable.func"
}

void *
dlmalloc(size_t size)
{
  DEBUG_CODE2({
    void *ptr;

    printf("dlmalloc(%d)",size);
    ptr = xmalloc(size);
    printf(":0x%x\n",ptr);
    return ptr;
  },
  {
    return xmalloc(size);
  });
}

void *
dlrealloc(void *ptr, size_t size)
{
  DEBUG_CODE({
    printf("dlrealloc(0x%x,%d)\n",ptr,size);
  });
  return xrealloc(ptr, size);
}

void
dlfree(void *ptr)
{
  DEBUG_CODE({
    printf("dlfree(0x%x)\n",ptr);
  });
  xfree(ptr);
}

char*
dlstrdup(const char *str)
{
  char *newstr;

  newstr = (char*)dlmalloc(strlen(str));
  strcpy(newstr,str);

  return newstr;
}

size_t
dlsizeof(const char *cstr)
{
  size_t size;
  int i, len, n, dlen;
  char *d;

  len  = strlen(cstr);
  size = 0;
  for( i=0; i<len; i++ ){
    n = 1;
    if( isdigit(cstr[i+1]) ){
      dlen = 1;
      while( isdigit(cstr[i+dlen]) ){ dlen ++; };
      dlen --;
      d = ALLOCA_N(char, dlen + 1);
      strncpy(d, cstr + i + 1, dlen);
      d[dlen] = '\0';
      n = atoi(d);
    }
    else{
      dlen = 0;
    };

    switch( cstr[i] ){
    case 'I':
      DLALIGN(0,size,INT_ALIGN);
    case 'i':
      size += sizeof(int) * n;
      break;
    case 'L':
      DLALIGN(0,size,LONG_ALIGN);
    case 'l':
      size += sizeof(long) * n;
      break;
    case 'F':
      DLALIGN(0,size,FLOAT_ALIGN);
    case 'f':
      size += sizeof(float) * n;
      break;
    case 'D':
      DLALIGN(0,size,DOUBLE_ALIGN);
    case 'd':
      size += sizeof(double) * n;
      break;
    case 'C':
    case 'c':
      size += sizeof(char) * n;
      break;
    case 'H':
      DLALIGN(0,size,SHORT_ALIGN);
    case 'h':
      size += sizeof(short) * n;
      break;
    case 'P':
      DLALIGN(0,size,VOIDP_ALIGN);
    case 'p':
      size += sizeof(void*) * n;
      break;
    default:
      rb_raise(rb_eDLTypeError, "unexpected type '%c'", cstr[i]);
      break;
    };
    i += dlen;
  };

  return size;
}

static float *
c_farray(VALUE v, long *size)
{
  int i, len;
  float *ary;
  VALUE e;

  len = RARRAY(v)->len;
  *size = sizeof(float) * len;
  ary = dlmalloc(*size);
  for( i=0; i < len; i++ ){
    e = rb_ary_entry(v, i);
    switch( TYPE(e) ){
    case T_FLOAT:
      ary[i] = (float)(RFLOAT(e)->value);
      break;
    case T_NIL:
      ary[i] = 0.0;
      break;
    default:
      rb_raise(rb_eDLTypeError, "unexpected type of the element #%d", i);
      break;
    };
  };

  return ary;
}

static double *
c_darray(VALUE v, long *size)
{
  int i, len;
  double *ary;
  VALUE e;

  len = RARRAY(v)->len;
  *size = sizeof(double) * len;
  ary = dlmalloc(*size);
  for( i=0; i < len; i++ ){
    e = rb_ary_entry(v, i);
    switch( TYPE(e) ){
    case T_FLOAT:
      ary[i] = (double)(RFLOAT(e)->value);
      break;
    case T_NIL:
      ary[i] = 0.0;
      break;
    default:
      rb_raise(rb_eDLTypeError, "unexpected type of the element #%d", i);
      break;
    };
  };

  return ary;
}

static long *
c_larray(VALUE v, long *size)
{
  int i, len;
  long *ary;
  VALUE e;

  len = RARRAY(v)->len;
  *size = sizeof(long) * len;
  ary = dlmalloc(*size);
  for( i=0; i < len; i++ ){
    e = rb_ary_entry(v, i);
    switch( TYPE(e) ){
    case T_FIXNUM:
    case T_BIGNUM:
      ary[i] = (long)(NUM2INT(e));
      break;
    case T_NIL:
      ary[i] = 0;
      break;
    default:
      rb_raise(rb_eDLTypeError, "unexpected type of the element #%d", i);
      break;
    };
  };

  return ary;
}

static int *
c_iarray(VALUE v, long *size)
{
  int i, len;
  int *ary;
  VALUE e;

  len = RARRAY(v)->len;
  *size = sizeof(int) * len;
  ary = dlmalloc(*size);
  for( i=0; i < len; i++ ){
    e = rb_ary_entry(v, i);
    switch( TYPE(e) ){
    case T_FIXNUM:
    case T_BIGNUM:
      ary[i] = (int)(NUM2INT(e));
      break;
    case T_NIL:
      ary[i] = 0;
      break;
    default:
      rb_raise(rb_eDLTypeError, "unexpected type of the element #%d", i);
      break;
    };
  };

  return ary;
}

static short *
c_harray(VALUE v, long *size)
{
  int i, len;
  short *ary;
  VALUE e;

  len = RARRAY(v)->len;
  *size = sizeof(short) * len;
  ary = dlmalloc(*size);
  for( i=0; i < len; i++ ){
    e = rb_ary_entry(v, i);
    switch( TYPE(e) ){
    case T_FIXNUM:
    case T_BIGNUM:
      ary[i] = (short)(NUM2INT(e));
      break;
    case T_NIL:
      ary[i] = 0;
      break;
    default:
      rb_raise(rb_eDLTypeError, "unexpected type of the element #%d", i);
      break;
    };
  };

  return ary;
}

static char *
c_carray(VALUE v, long *size)
{
  int i, len;
  char *ary;
  VALUE e;

  len = RARRAY(v)->len;
  *size = sizeof(char) * len;
  ary = dlmalloc(*size);
  for( i=0; i < len; i++ ){
    e = rb_ary_entry(v, i);
    switch( TYPE(e) ){
    case T_FIXNUM:
    case T_BIGNUM:
      ary[i] = (char)(NUM2INT(e));
      break;
    case T_NIL:
      ary[i] = 0;
      break;
    default:
      rb_raise(rb_eDLTypeError, "unexpected type of the element #%d", i);
      break;
    };
  };

  return ary;
}

static void *
c_parray(VALUE v, long *size)
{
  int i, len;
  void **ary;
  VALUE e;

  len = RARRAY(v)->len;
  *size = sizeof(void*) * len;
  ary = dlmalloc(*size);
  for( i=0; i < len; i++ ){
    e = rb_ary_entry(v, i);
    switch( TYPE(e) ){
    case T_STRING:
      {
	char *str, *src;
	src = RSTRING(e)->ptr;
	str = dlstrdup(src);
	ary[i] = (void*)str;
      };
      break;
    case T_NIL:
      ary[i] = NULL;
      break;
    case T_DATA:
      if( rb_obj_is_kind_of(e, rb_cDLPtrData) ){
	struct ptr_data *pdata;
	Data_Get_Struct(e, struct ptr_data, pdata);
	ary[i] = (void*)(pdata->ptr);
      }
      else{
	rb_raise(rb_eDLTypeError, "unexpected type of the element #%d", i);
      };
      break;
    default:
      rb_raise(rb_eDLTypeError, "unexpected type of the element #%d", i);
      break;
    };
  };

  return ary;
}

void *
rb_ary2cary(char t, VALUE v, long *size)
{
  int len;
  VALUE val0;

  if( TYPE(v) != T_ARRAY ){
    rb_raise(rb_eDLTypeError, "an array is expected.");
  };

  len = RARRAY(v)->len;
  if( len == 0 ){
    return NULL;
  };

  if( !size ){
    size = ALLOCA_N(long,1);
  };

  val0 = rb_ary_entry(v,0);
  switch( TYPE(val0) ){
  case T_FIXNUM:
  case T_BIGNUM:
    switch( t ){
    case 'C': case 'c':
      return (void*)c_carray(v,size);
    case 'H': case 'h':
      return (void*)c_harray(v,size);
    case 'I': case 'i':
      return (void*)c_iarray(v,size);
    case 'L': case 'l': case 0:
      return (void*)c_larray(v,size);
    default:
      rb_raise(rb_eDLTypeError, "type mismatch");
    };
  case T_STRING:
    return (void*)c_parray(v,size);
  case T_FLOAT:
    switch( t ){
    case 'F': case 'f':
      return (void*)c_farray(v,size);
    case 'D': case 'd': case 0:
      return (void*)c_darray(v,size);
    };
    rb_raise(rb_eDLTypeError, "type mismatch");
  case T_DATA:
    if( rb_obj_is_kind_of(val0, rb_cDLPtrData) ){
      return (void*)c_parray(v,size);
    };
    rb_raise(rb_eDLTypeError, "type mismatch");
  default:
    rb_raise(rb_eDLTypeError, "unsupported type");
  };
}

VALUE
rb_str_to_ptr(VALUE self)
{
  char *ptr;
  int  len;

  len = RSTRING(self)->len;
  ptr = (char*)dlmalloc(len + 1);
  memcpy(ptr, RSTRING(self)->ptr, len);
  ptr[len] = '\0';
  return rb_dlptr_new((void*)ptr,len,dlfree);
}

VALUE
rb_ary_to_ptr(int argc, VALUE argv[], VALUE self)
{
  void *ptr;
  VALUE t;
  long size;

  switch( rb_scan_args(argc, argv, "01", &t) ){
  case 1:
    ptr = rb_ary2cary(StringValuePtr(t)[0], self, &size);
    break;
  case 0:
    ptr = rb_ary2cary(0, self, &size);
    break;
  };
  return ptr ? rb_dlptr_new(ptr, size, dlfree) : Qnil;
}

VALUE
rb_io_to_ptr(VALUE self)
{
  OpenFile *fptr;
  FILE     *fp;

  GetOpenFile(self, fptr);
  fp = fptr->f;

  return fp ? rb_dlptr_new(fp, sizeof(FILE), 0) : Qnil;
};

VALUE
rb_dl_dlopen(int argc, VALUE argv[], VALUE self)
{
  return rb_class_new_instance(argc, argv, rb_cDLHandle);
}

VALUE
rb_dl_malloc(VALUE self, VALUE size)
{
  return rb_dlptr_malloc(DLNUM2LONG(size), dlfree);
}

VALUE
rb_dl_strdup(VALUE self, VALUE str)
{
  void *p;

  str = rb_String(str);
  return rb_dlptr_new(strdup(RSTRING(str)->ptr), RSTRING(str)->len, dlfree);
}

static VALUE
rb_dl_sizeof(VALUE self, VALUE str)
{
  return INT2NUM(dlsizeof(StringValuePtr(str)));
}

static VALUE
rb_dl_callback(int argc, VALUE argv[], VALUE self)
{
  VALUE type, proc;
  int rettype, entry, i;
  char fname[127];

  proc = Qnil;
  switch( rb_scan_args(argc, argv, "11", &type, &proc) ){
  case 1:
    if( rb_block_given_p() ){
      proc = rb_f_lambda();
    }
    else{
      proc = Qnil;
    }
  default:
    break;
  }

  Check_Type(type, T_STRING);
  switch( RSTRING(type)->ptr[0] ){
  case '0':
    rettype = 0x00;
    break;
  case 'C':
    rettype = 0x01;
    break;
  case 'H':
    rettype = 0x02;
    break;
  case 'I':
    rettype = 0x03;
    break;
  case 'L':
    rettype = 0x04;
    break;
  case 'F':
    rettype = 0x05;
    break;
  case 'D':
    rettype = 0x06;
    break;
  case 'P':
    rettype = 0x07;
    break;
  default:
    rb_raise(rb_eDLTypeError, "unsupported type `%c'", RSTRING(type)->ptr[0]);
  }

  entry = -1;
  for( i=0; i < MAX_CALLBACK; i++ ){
    if( rb_hash_aref(DLFuncTable, rb_assoc_new(INT2NUM(rettype), INT2NUM(i))) == Qnil ){
      entry = i;
      break;
    }
  }
  if( entry < 0 ){
    rb_raise(rb_eDLError, "too many callbacks are defined.");
  }

  rb_hash_aset(DLFuncTable,
	       rb_assoc_new(INT2NUM(rettype),INT2NUM(entry)),
	       rb_assoc_new(type,proc));
  sprintf(fname, "rb_dl_callback_func_%d_%d", rettype, entry);
  return rb_dlsym_new((void (*)())rb_dl_callback_table[rettype][entry],
		      fname, RSTRING(type)->ptr);
}

static VALUE
rb_dl_remove_callback(VALUE mod, VALUE sym)
{
  freefunc_t f = rb_dlsym2csym(sym);
  int i, j;

  for( i=0; i < CALLBACK_TYPES; i++ ){
    for( j=0; j < MAX_CALLBACK; j++ ){
      if( rb_dl_callback_table[i][j] == f ){
	rb_hash_aset(DLFuncTable, rb_assoc_new(INT2NUM(i),INT2NUM(j)),Qnil);
	break;
      }
    }
  }
  return Qnil;
}

void
Init_dl()
{
  void Init_dlptr();
  void Init_dlsym();
  void Init_dlhandle();

  id_call = rb_intern("call");

  rb_mDL = rb_define_module("DL");

  rb_eDLError = rb_define_class_under(rb_mDL, "DLError", rb_eStandardError);
  rb_eDLTypeError = rb_define_class_under(rb_mDL, "DLTypeError", rb_eDLError);

  DLFuncTable = rb_hash_new();
  init_dl_func_table();
  rb_define_const(rb_mDL, "FuncTable", DLFuncTable);

  rb_define_const(rb_mDL, "RTLD_GLOBAL", INT2NUM(RTLD_GLOBAL));
  rb_define_const(rb_mDL, "RTLD_LAZY",   INT2NUM(RTLD_LAZY));
  rb_define_const(rb_mDL, "RTLD_NOW",    INT2NUM(RTLD_NOW));

  rb_define_const(rb_mDL, "ALIGN_INT",   INT2NUM(ALIGN_INT));
  rb_define_const(rb_mDL, "ALIGN_LONG",  INT2NUM(ALIGN_LONG));
  rb_define_const(rb_mDL, "ALIGN_FLOAT", INT2NUM(ALIGN_FLOAT));
  rb_define_const(rb_mDL, "ALIGN_SHORT", INT2NUM(ALIGN_SHORT));
  rb_define_const(rb_mDL, "ALIGN_DOUBLE",INT2NUM(ALIGN_DOUBLE));
  rb_define_const(rb_mDL, "ALIGN_VOIDP", INT2NUM(ALIGN_VOIDP));

  rb_define_const(rb_mDL, "VERSION",     rb_tainted_str_new2(DL_VERSION));
  rb_define_const(rb_mDL, "MAJOR_VERSION", INT2NUM(DL_MAJOR_VERSION));
  rb_define_const(rb_mDL, "MINOR_VERSION", INT2NUM(DL_MINOR_VERSION));
  rb_define_const(rb_mDL, "PATCH_VERSION", INT2NUM(DL_PATCH_VERSION));
  rb_define_const(rb_mDL, "MAX_ARG", INT2NUM(MAX_ARG));
  rb_define_const(rb_mDL, "DLSTACK", rb_tainted_str_new2(DLSTACK_METHOD));

  rb_define_module_function(rb_mDL, "dlopen", rb_dl_dlopen, -1);
  rb_define_module_function(rb_mDL, "callback", rb_dl_callback, -1);
  rb_define_module_function(rb_mDL, "define_callback", rb_dl_callback, -1);
  rb_define_module_function(rb_mDL, "remove_callback", rb_dl_remove_callback, 1);
  rb_define_module_function(rb_mDL, "malloc", rb_dl_malloc, 1);
  rb_define_module_function(rb_mDL, "strdup", rb_dl_strdup, 1);
  rb_define_module_function(rb_mDL, "sizeof", rb_dl_sizeof, 1);

  Init_dlptr();
  Init_dlsym();
  Init_dlhandle();

  rb_define_const(rb_mDL, "FREE", rb_dlsym_new(dlfree, "free", "0P"));

  rb_define_method(rb_cString, "to_ptr", rb_str_to_ptr, 0);
  rb_define_method(rb_cArray, "to_ptr", rb_ary_to_ptr, -1);
  rb_define_method(rb_cIO, "to_ptr", rb_io_to_ptr, 0);
}
@


1.11
log
@Include ctype.h for isdigit().
@
text
@d2 1
a2 1
 * $Id: dl.c,v 1.10 2002/06/11 14:44:53 ttate Exp $
d541 1
a541 1
  return rb_dlhandle_s_new(argc, argv, rb_cDLHandle);
@


1.10
log
@Get rid of STR2CSTR. (Thanks N.Nakada)
@
text
@d2 1
a2 1
 * $Id: dl.c,v 1.9 2002/06/11 11:16:56 ttate Exp $
d7 1
@


1.9
log
@bugfix. (Thanks U.Nakamura)
@
text
@d2 1
a2 1
 * $Id: dl.c,v 1.8 2002/06/11 01:27:47 H_Konishi Exp $
d585 1
a585 1
  switch( STR2CSTR(type)[0] ){
d611 1
a611 1
    rb_raise(rb_eDLTypeError, "unsupported type `%c'", STR2CSTR(type)[0]);
d629 2
a630 1
  return rb_dlsym_new((void (*)())rb_dl_callback_table[rettype][entry], fname, STR2CSTR(type));
@


1.8
log
@new platform [bccwin32] merged.
@
text
@d2 1
a2 1
 * $Id: dl.c,v 1.7 2002/06/10 07:52:10 ttate Exp $
d19 1
a19 1
			 int *argc, VALUE (*argv)[])
d96 1
a96 1
    (*argv)[i-1] = val;
d611 1
a611 1
    rb_raise(rb_eDLTypeError, "unsupported type `%s'", STR2CSTR(rettype));
@


1.7
log
@dl.c (rb_dl_scan_callback_args): memcpy() -> cast and substitution
@
text
@d2 1
a2 1
 * $Id: dl.c,v 1.6 2002/06/09 17:47:33 ttate Exp $
d629 1
a629 1
  return rb_dlsym_new(rb_dl_callback_table[rettype][entry], fname, STR2CSTR(type));
@


1.6
log
@* ext/dl: change the callback mechanism.
@
text
@d2 1
a2 1
 * $Id: dl.c,v 1.5 2002/05/20 15:35:48 ttate Exp $
d31 1
a31 1
	memcpy(&v, sp, sizeof(long));
d39 1
a39 1
	memcpy(&v, sp, sizeof(long));
d47 1
a47 1
	memcpy(&v, sp, sizeof(long));
d55 1
a55 1
	memcpy(&v, sp, sizeof(long));
@


1.5
log
@rename PtrData::alloc and Struct#alloc to malloc respectively.
@
text
@d2 1
a2 1
 * $Id: dl.c,v 1.4 2002/05/15 06:23:04 ttate Exp $
d14 1
a14 1
static void *rb_dl_func_table[MAX_CALLBACK_TYPE][MAX_CALLBACK];
d17 86
d565 1
a565 1
rb_dl_callback_type(VALUE *str)
d567 3
a569 4
  char *type;
  int len;
  int i;
  long ftype;
d571 11
a581 28
  ftype = 0;
  type = StringValuePtr(*str);
  len  = RSTRING(*str)->len;

  if( len - 1 > MAX_CBARG ){
    rb_raise(rb_eDLError, "maximum number of the argument is %d.", MAX_CBARG);
  };

  for( i = len - 1; i > 0; i-- ){
    switch( type[i] ){
    case 'P':
      CBPUSH_P(ftype);
      break;
    case 'I':
      CBPUSH_I(ftype);
      break;
    case 'L':
      CBPUSH_L(ftype);
      break;
    case 'F':
      CBPUSH_F(ftype);
      break;
    case 'D':
      CBPUSH_D(ftype);
    default:
      rb_raise(rb_eDLError, "unsupported type `%c'", type[i]);
      break;
    };
d584 2
a585 1
  switch( type[0] ){
d587 4
a590 1
    CBPUSH_0(ftype);
d592 2
a593 2
  case 'P':
    CBPUSH_P(ftype);
d596 1
a596 1
    CBPUSH_I(ftype);
d599 1
a599 1
    CBPUSH_L(ftype);
d602 1
a602 1
    CBPUSH_F(ftype);
d605 1
a605 1
    CBPUSH_D(ftype);
d607 2
a608 24
  default:
    rb_raise(rb_eDLError, "unsupported type `%c'", type[i]);
    break;
  };

  return INT2NUM(ftype);
}

VALUE
rb_dl_set_callback(int argc, VALUE argv[], VALUE self)
{
  VALUE types, num, proc;
  VALUE key;
  VALUE entry;
  void *func;

  char func_name[1024];
  extern dln_sym();

  switch( rb_scan_args(argc, argv, "21", &types, &num, &proc) ){
  case 2:
    proc = rb_f_lambda();
    break;
  case 3:
d611 2
a612 2
    rb_bug("rb_dl_set_callback");
  };
d614 10
a623 6
  key = rb_dl_callback_type(&types);
  entry = rb_hash_aref(DLFuncTable, key);
  if( entry == Qnil ){
    entry = rb_hash_new();
    rb_hash_aset(DLFuncTable, key, entry);
  };
d625 5
a629 9
  func = rb_dl_func_table[NUM2INT(key)][NUM2INT(num)];
  if( func ){
    rb_hash_aset(entry, num, proc);
    snprintf(func_name, 1023, "rb_dl_func%d_%d", NUM2INT(key), NUM2INT(num));
    return rb_dlsym_new(func, func_name, RSTRING(types)->ptr);
  }
  else{
    return Qnil;
  };
d632 2
a633 2
VALUE
rb_dl_get_callback(VALUE self, VALUE types, VALUE num)
d635 2
a636 2
  VALUE key;
  VALUE entry;
d638 9
a646 6
  key = rb_dl_callback_type(&types);
  entry = rb_hash_aref(DLFuncTable, key);
  if( entry == Qnil ){
    return Qnil;
  };
  return rb_hash_aref(entry, num);
a682 2
  rb_define_const(rb_mDL, "MAX_CBARG", INT2NUM(MAX_CBARG));
  rb_define_const(rb_mDL, "MAX_CBENT", INT2NUM(MAX_CBENT));
d686 3
a688 2
  rb_define_module_function(rb_mDL, "set_callback", rb_dl_set_callback, -1);
  rb_define_module_function(rb_mDL, "get_callback", rb_dl_get_callback, 2);
@


1.4
log
@Add DL::DLSTACK.
@
text
@d2 1
a2 1
 * $Id: dl.c,v 1.3 2002/04/04 08:27:48 ttate Exp $
d460 1
a460 7
  void *ptr;
  long s;

  s = DLNUM2LONG(size);
  ptr = dlmalloc((size_t)s);
  memset(ptr,0,(size_t)s);
  return rb_dlptr_new(ptr, s, dlfree);
@


1.3
log
@Patch [ruby-dev:16747] (Thanks Nakada)
@
text
@d2 1
a2 1
 * $Id: dl.c,v 1.2 2002/04/03 11:59:01 ttate Exp $
d638 1
@


1.2
log
@Merge Nakada's patch and define StringValuePtr for ruby-1.6.
CV ----------------------------------------------------------------------
@
text
@d2 1
a2 1
 * $Id: dl.c,v 1.1 2002/04/02 10:56:13 ttate Exp $
d326 1
a326 1
	src = StringValuePtr(e);
d475 1
a475 1
  return rb_dlptr_new(strdup(StringValuePtr(str)), RSTRING(str)->len, dlfree);
d485 1
a485 1
rb_dl_callback_type(VALUE str)
d493 2
a494 2
  type = StringValuePtr(str);
  len  = RSTRING(str)->len;
d570 1
a570 1
  key = rb_dl_callback_type(types);
d581 1
a581 1
    return rb_dlsym_new(func, func_name, StringValuePtr(types));
d594 1
a594 1
  key = rb_dl_callback_type(types);
@


1.1
log
@Add ruby-dl
@
text
@d2 1
a2 1
 * $Id: dl.c,v 1.94 2002/03/17 23:22:15 ttate Exp $
d22 1
a22 1
};
d38 1
a38 1
};
d47 1
a47 1
};
d56 1
a56 1
};
d67 1
a67 1
};
d136 1
a136 1
};
d164 1
a164 1
};
d192 1
a192 1
};
d221 1
a221 1
};
d250 1
a250 1
};
d279 1
a279 1
};
d308 1
a308 1
};
d326 1
a326 1
	src = STR2CSTR(e);
d351 1
a351 1
};
d406 1
a406 1
};
d416 1
a416 1
  memcpy(ptr, STR2CSTR(self), len);
d419 1
a419 1
};
d430 1
a430 1
    ptr = rb_ary2cary(STR2CSTR(t)[0], self, &size);
d437 1
a437 1
};
d455 1
a455 1
};
d467 1
a467 1
};
d475 2
a476 2
  return rb_dlptr_new(strdup(STR2CSTR(str)), RSTRING(str)->len, dlfree);
};
d481 2
a482 2
  return INT2NUM(dlsizeof(STR2CSTR(str)));
};
d493 1
a493 1
  type = STR2CSTR(str);
d520 1
a520 1
  };
d547 1
a547 1
};
d581 1
a581 1
    return rb_dlsym_new(func, func_name, STR2CSTR(types));
d586 1
a586 1
};
d600 1
a600 1
};
d655 1
a655 1
};
@
