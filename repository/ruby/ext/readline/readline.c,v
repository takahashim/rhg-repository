head	1.11;
access;
symbols
	v1_6_7:1.2.4.3
	v1_6_6:1.2.4.3
	v1_6_5:1.2.4.3
	v1_6_4:1.2.4.2
	v1_7_1:1.4
	v1_6_4_preview4:1.2.4.2
	v1_6_4_preview3:1.2.4.2
	v1_6_4_preview2:1.2.4.1
	v1_6_4_preview1:1.2
	v1_6_3:1.2
	ruby_m17n:1.2.0.6
	ruby_1_6:1.2.0.4
	v1_6_2:1.2
	v1_6_1:1.2
	v1_6_0:1.2
	v1_4_6:1.2
	v1_4_5:1.2
	v1_4_4:1.2
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.2
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.4
	v1_3_6_repack:1.1.1.1.2.4
	v1_3_6:1.1.1.1.2.4
	v1_3_5:1.1.1.1.2.3
	v1_3_4_990625:1.1.1.1.2.3
	v1_3_4_990624:1.1.1.1.2.3
	v1_3_4_990611:1.1.1.1.2.3
	v1_3_4_990531:1.1.1.1.2.3
	v1_3_3_990518:1.1.1.1.2.3
	v1_3_3_990513:1.1.1.1.2.2
	v1_3_3_990507:1.1.1.1.2.1
	v1_3_1_990225:1.1.1.1
	v1_3_1_990224:1.1.1.1
	v1_3_1_990215:1.1.1.1
	v1_3_1_990212:1.1.1.1
	v1_3_1_990210:1.1.1.1
	v1_3_1_:1.1.1.1
	v1_3_1_990209:1.1.1.1
	v1_3_1_990205:1.1.1.1
	v1_3_1_990203:1.1.1.1
	v1_3_1_990201:1.1.1.1
	v1_3_1"_990201:1.1.1.1
	v1_3_1_990128:1.1.1.1
	v1_3_1_990127:1.1.1.1
	v1_3_1_990126:1.1.1.1
	ruby_1_3:1.1.1.1.0.2
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2002.08.30.10.41.57;	author nobu;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.06.06.20.07;	author nobu;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.20.12.14.33;	author nobu;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.19.08.02.55;	author shugo;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.06.05.14.06;	author shugo;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.23.09.30.42;	author knu;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.19.09.21.38;	author knu;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.07.09.26.27;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.06.15.03.25;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.37.50;	author matz;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	99.01.20.04.59.33;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.20.04.59.33;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.03.24.08.52.34;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.05.11.01.34.33;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.05.17.09.54.19;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.07.22.10.37.24;	author matz;	state Exp;
branches;
next	;

1.2.4.1
date	2001.04.16.06.54.38;	author matz;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.05.07.06.18.49;	author matz;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.07.05.15.54.00;	author knu;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2002.06.20.12.14.18;	author nobu;	state Exp;
branches;
next	;

1.2.6.1
date	2002.07.09.05.26.54;	author matz;	state Exp;
branches;
next	;


desc
@@


1.11
log
@* ext/Win32API/Win32API.c (Win32API_Call): RSTRING()->ptr may be
  NULL.

* ext/nkf/nkf.c (rb_nkf_guess): ditto.

* ext/readline/readline.c (readline_s_set_completion_append_character):
  ditto.

* ext/socket/socket.c (sock_s_getaddrinfo, sock_s_getnameinfo):
  ditto.

* ext/tcltklib/tcltklib.c (ip_toUTF8, ip_fromUTF8): ditto.
@
text
@/* readline.c -- GNU Readline module
   Copyright (C) 1997-2001  Shugo Maeda */

#include <errno.h>
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

#include "ruby.h"
#include "rubysig.h"

static VALUE mReadline;

#define TOLOWER(c) (isupper(c) ? tolower(c) : c)

#define COMPLETION_PROC "completion_proc"
#define COMPLETION_CASE_FOLD "completion_case_fold"

#ifndef READLINE_42_OR_LATER
# define rl_filename_completion_function filename_completion_function
# define rl_username_completion_function username_completion_function
# define rl_completion_matches completion_matches
#endif

static int
readline_event()
{
    CHECK_INTS;
    rb_thread_schedule();
    return 0;
}

static VALUE
readline_readline(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE tmp, add_hist, result;
    char *prompt = NULL;
    char *buff;
    int status;

    if (rb_scan_args(argc, argv, "02", &tmp, &add_hist) > 0) {
	prompt = StringValuePtr(tmp);
    }

    if (!isatty(0) && errno == EBADF) rb_raise(rb_eIOError, "stdin closed");

    buff = (char*)rb_protect((VALUE(*)_((VALUE)))readline, (VALUE)prompt,
                              &status);
    if (status) {
#if READLINE_40_OR_LATER
        /* restore terminal mode and signal handler*/
        rl_cleanup_after_signal();
#elif READLINE_21_OR_LATER
        /* restore terminal mode */
        (*rl_deprep_term_function)();
#else
        rl_deprep_terminal();
#endif
        rb_jump_tag(status);
    }

    if (RTEST(add_hist) && buff) {
	add_history(buff);
    }
    if (buff)
	result = rb_tainted_str_new2(buff);
    else
	result = Qnil;
    if (buff) free(buff);
    return result;
}

static VALUE
readline_s_set_completion_proc(self, proc)
    VALUE self;
    VALUE proc;
{
    if (!rb_respond_to(proc, rb_intern("call")))
	rb_raise(rb_eArgError, "argument have to respond to `call'");
    return rb_iv_set(mReadline, COMPLETION_PROC, proc);
}

static VALUE
readline_s_get_completion_proc(self)
    VALUE self;
{
    return rb_iv_get(mReadline, COMPLETION_PROC);
}

static VALUE
readline_s_set_completion_case_fold(self, val)
    VALUE self;
    VALUE val;
{
    return rb_iv_set(mReadline, COMPLETION_CASE_FOLD, val);
}

static VALUE
readline_s_get_completion_case_fold(self)
    VALUE self;
{
    return rb_iv_get(mReadline, COMPLETION_CASE_FOLD);
}

static char **
readline_attempted_completion_function(text, start, end)
    char *text;
    int start;
    int end;
{
    VALUE proc, ary, temp;
    char **result;
    int case_fold;
    int i, matches;

    proc = rb_iv_get(mReadline, COMPLETION_PROC);
    if (NIL_P(proc))
	return NULL;
    rl_attempted_completion_over = 1;
    case_fold = RTEST(rb_iv_get(mReadline, COMPLETION_CASE_FOLD));
    ary = rb_funcall(proc, rb_intern("call"), 1, rb_tainted_str_new2(text));
    if (TYPE(ary) != T_ARRAY)
	ary = rb_Array(ary);
    matches = RARRAY(ary)->len;
    if (matches == 0)
	return NULL;
    result = ALLOC_N(char *, matches + 2);
    for (i = 0; i < matches; i++) {
	temp = rb_obj_as_string(RARRAY(ary)->ptr[i]);
	result[i + 1] = ALLOC_N(char, RSTRING(temp)->len + 1);
	strcpy(result[i + 1], RSTRING(temp)->ptr);
    }
    result[matches + 1] = NULL;

    if (matches == 1) {
	result[0] = result[1];
	result[1] = NULL;
    } else {
	register int i = 1;
	int low = 100000;

	while (i < matches) {
	    register int c1, c2, si;

	    if (case_fold) {
		for (si = 0;
		     (c1 = TOLOWER(result[i][si])) &&
			 (c2 = TOLOWER(result[i + 1][si]));
		     si++)
		    if (c1 != c2) break;
	    } else {
		for (si = 0;
		     (c1 = result[i][si]) &&
			 (c2 = result[i + 1][si]);
		     si++)
		    if (c1 != c2) break;
	    }

	    if (low > si) low = si;
	    i++;
	}
	result[0] = ALLOC_N(char, low + 1);
	strncpy(result[0], result[1], low);
	result[0][low] = '\0';
    }

    return result;
}

static VALUE
readline_s_vi_editing_mode(self)
    VALUE self;
{
    rl_vi_editing_mode(1,0);
    return Qnil;
}

static VALUE
readline_s_emacs_editing_mode(self)
    VALUE self;
{
    rl_emacs_editing_mode(1,0);
    return Qnil;
}

static VALUE
readline_s_set_completion_append_character(self, str)
    VALUE self, str;
{
#ifdef READLINE_21_OR_LATER
    if (NIL_P(str) || !StringValuePtr(str) || !RSTRING(str)->len) {
	rl_completion_append_character = '\0';
    } else {
	rl_completion_append_character = RSTRING(str)->ptr[0];
    }

    return self;
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
readline_s_get_completion_append_character(self)
    VALUE self;
{
#ifdef READLINE_21_OR_LATER
    VALUE str;

    if (rl_completion_append_character == '\0')
	return Qnil;

    str = rb_str_new("", 1);
    RSTRING(str)->ptr[0] = rl_completion_append_character;

    return str;
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
readline_s_set_basic_word_break_characters(self, str)
    VALUE self, str;
{
#ifdef READLINE_21_OR_LATER
    static char *basic_word_break_characters = NULL;
    char *s;

    StringValue(str);
    if (basic_word_break_characters == NULL) {
	basic_word_break_characters =
	    ALLOC_N(char, RSTRING(str)->len + 1);
    }
    else {
	REALLOC_N(basic_word_break_characters, char, RSTRING(str)->len + 1);
    }
    strncpy(basic_word_break_characters,
	    RSTRING(str)->ptr, RSTRING(str)->len);
    basic_word_break_characters[RSTRING(str)->len] = '\0';
    rl_basic_word_break_characters = basic_word_break_characters;

    return self;
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
readline_s_get_basic_word_break_characters(self, str)
    VALUE self, str;
{
#ifdef READLINE_21_OR_LATER
    if (rl_basic_word_break_characters == NULL)
	return Qnil;
    return rb_str_new2(rl_basic_word_break_characters);
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
readline_s_set_completer_word_break_characters(self, str)
    VALUE self, str;
{
#ifdef READLINE_21_OR_LATER
    static char *completer_word_break_characters = NULL;
    char *s;

    StringValue(str);
    if (completer_word_break_characters == NULL) {
	completer_word_break_characters =
	    ALLOC_N(char, RSTRING(str)->len + 1);
    }
    else {
	REALLOC_N(completer_word_break_characters, char, RSTRING(str)->len + 1);
    }
    strncpy(completer_word_break_characters,
	    RSTRING(str)->ptr, RSTRING(str)->len);
    completer_word_break_characters[RSTRING(str)->len] = '\0';
    rl_completer_word_break_characters = completer_word_break_characters;

    return self;
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
readline_s_get_completer_word_break_characters(self, str)
    VALUE self, str;
{
#ifdef READLINE_21_OR_LATER
    if (rl_completer_word_break_characters == NULL)
	return Qnil;
    return rb_str_new2(rl_completer_word_break_characters);
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
readline_s_set_basic_quote_characters(self, str)
    VALUE self, str;
{
#ifdef READLINE_21_OR_LATER
    static char *basic_quote_characters = NULL;
    char *s;

    StringValue(str);
    if (basic_quote_characters == NULL) {
	basic_quote_characters =
	    ALLOC_N(char, RSTRING(str)->len + 1);
    }
    else {
	REALLOC_N(basic_quote_characters, char, RSTRING(str)->len + 1);
    }
    strncpy(basic_quote_characters,
	    RSTRING(str)->ptr, RSTRING(str)->len);
    basic_quote_characters[RSTRING(str)->len] = '\0';
    rl_basic_quote_characters = basic_quote_characters;

    return self;
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
readline_s_get_basic_quote_characters(self, str)
    VALUE self, str;
{
#ifdef READLINE_21_OR_LATER
    if (rl_basic_quote_characters == NULL)
	return Qnil;
    return rb_str_new2(rl_basic_quote_characters);
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
readline_s_set_completer_quote_characters(self, str)
    VALUE self, str;
{
#ifdef READLINE_21_OR_LATER
    static char *completer_quote_characters = NULL;
    char *s;

    StringValue(str);
    if (completer_quote_characters == NULL) {
	completer_quote_characters =
	    ALLOC_N(char, RSTRING(str)->len + 1);
    }
    else {
	REALLOC_N(completer_quote_characters, char, RSTRING(str)->len + 1);
    }
    strncpy(completer_quote_characters,
	    RSTRING(str)->ptr, RSTRING(str)->len);
    completer_quote_characters[RSTRING(str)->len] = '\0';
    rl_completer_quote_characters = completer_quote_characters;

    return self;
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
readline_s_get_completer_quote_characters(self, str)
    VALUE self, str;
{
#ifdef READLINE_21_OR_LATER
    if (rl_completer_quote_characters == NULL)
	return Qnil;
    return rb_str_new2(rl_completer_quote_characters);
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
readline_s_set_filename_quote_characters(self, str)
    VALUE self, str;
{
#ifdef READLINE_21_OR_LATER
    static char *filename_quote_characters = NULL;
    char *s;

    StringValue(str);
    if (filename_quote_characters == NULL) {
	filename_quote_characters =
	    ALLOC_N(char, RSTRING(str)->len + 1);
    }
    else {
	REALLOC_N(filename_quote_characters, char, RSTRING(str)->len + 1);
    }
    strncpy(filename_quote_characters,
	    RSTRING(str)->ptr, RSTRING(str)->len);
    filename_quote_characters[RSTRING(str)->len] = '\0';
    rl_filename_quote_characters = filename_quote_characters;

    return self;
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
readline_s_get_filename_quote_characters(self, str)
    VALUE self, str;
{
#ifdef READLINE_21_OR_LATER
    if (rl_filename_quote_characters == NULL)
	return Qnil;
    return rb_str_new2(rl_filename_quote_characters);
#else
    rb_notimplement();
#endif /* READLINE_21_OR_LATER */
}

static VALUE
rb_remove_history(index)
    int index;
{
    HIST_ENTRY *entry;
    VALUE val;

    entry = remove_history(index);
    if (entry) {
        val = rb_tainted_str_new2(entry->line);
        free(entry->line);
        free(entry);
        return val;
    }
    return Qnil;
}

static VALUE
hist_to_s(self)
    VALUE self;
{
    return rb_str_new2("HISTORY");
}

static VALUE
hist_get(self, index)
    VALUE self;
    VALUE index;
{
    HISTORY_STATE *state;
    int i;

    state = history_get_history_state();
    i = NUM2INT(index);
    if (i < 0) {
        i += state->length;
    }
    if (i < 0 || i > state->length - 1) {
	rb_raise(rb_eIndexError, "Invalid index");
    }
    return rb_tainted_str_new2(state->entries[i]->line);
}

static VALUE
hist_set(self, index, str)
    VALUE self;
    VALUE index;
    VALUE str;
{
    HISTORY_STATE *state;
    VALUE s = str;
    int i;

    state = history_get_history_state();
    i = NUM2INT(index);
    if (i < 0) {
        i += state->length;
    }
    if (i < 0 || i > state->length - 1) {
	rb_raise(rb_eIndexError, "Invalid index");
    }
    replace_history_entry(i, StringValuePtr(s), NULL);
    return str;
}

static VALUE
hist_push(self, str)
    VALUE self;
    VALUE str;
{
    add_history(StringValuePtr(str));
    return self;
}

static VALUE
hist_push_method(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE str;
    
    while (argc--) {
	str = *argv++;
	add_history(StringValuePtr(str));
    }
    return self;
}

static VALUE
hist_pop(self)
    VALUE self;
{
    HISTORY_STATE *state;

    state = history_get_history_state();
    if (state->length > 0) {
	return rb_remove_history(state->length - 1);
    } else {
	return Qnil;
    }
}

static VALUE
hist_shift(self)
    VALUE self;
{
    HISTORY_STATE *state;

    state = history_get_history_state();
    if (state->length > 0) {
	return rb_remove_history(0);
    } else {
	return Qnil;
    }
}

static VALUE
hist_each(self)
    VALUE self;
{
    HISTORY_STATE *state;
    int i;

    state = history_get_history_state();
    for (i = 0; i < state->length; i++) {
	rb_yield(rb_tainted_str_new2(state->entries[i]->line));
    }
    return self;
}

static VALUE
hist_length(self)
    VALUE self;
{
    HISTORY_STATE *state;

    state = history_get_history_state();
    return INT2NUM(state->length);
}

static VALUE
hist_empty_p(self)
    VALUE self;
{
    HISTORY_STATE *state;

    state = history_get_history_state();
    if (state->length == 0)
	return Qtrue;
    else
	return Qfalse;
}

static VALUE
hist_delete_at(self, index)
    VALUE self;
    VALUE index;
{
    HISTORY_STATE *state;
    int i;

    state = history_get_history_state();
    i = NUM2INT(index);
    if (i < 0)
        i += state->length;
    if (i < 0 || i > state->length - 1) {
	rb_raise(rb_eIndexError, "Invalid index");
    }
    return rb_remove_history(i);
}

static VALUE
filename_completion_proc_call(self, str)
    VALUE self;
    VALUE str;
{
    VALUE result;
    char **matches;
    int i;

    matches = rl_completion_matches(StringValuePtr(str),
				    rl_filename_completion_function);
    if (matches) {
	result = rb_ary_new();
	for (i = 0; matches[i]; i++) {
	    rb_ary_push(result, rb_tainted_str_new2(matches[i]));
	    free(matches[i]);
	}
	free(matches);
	if (RARRAY(result)->len >= 2)
	    rb_ary_shift(result);
    }
    else {
	result = Qnil;
    }
    return result;
}

static VALUE
username_completion_proc_call(self, str)
    VALUE self;
    VALUE str;
{
    VALUE result;
    char **matches;
    int i;

    matches = rl_completion_matches(StringValuePtr(str),
				    rl_username_completion_function);
    if (matches) {
	result = rb_ary_new();
	for (i = 0; matches[i]; i++) {
	    rb_ary_push(result, rb_tainted_str_new2(matches[i]));
	    free(matches[i]);
	}
	free(matches);
	if (RARRAY(result)->len >= 2)
	    rb_ary_shift(result);
    }
    else {
	result = Qnil;
    }
    return result;
}

void
Init_readline()
{
    VALUE history, fcomp, ucomp;

    /* Allow conditional parsing of the ~/.inputrc file. */
    rl_readline_name = "Ruby";

    using_history();

    mReadline = rb_define_module("Readline");
    rb_define_module_function(mReadline, "readline",
			      readline_readline, -1);
    rb_define_singleton_method(mReadline, "completion_proc=",
			       readline_s_set_completion_proc, 1);
    rb_define_singleton_method(mReadline, "completion_proc",
			       readline_s_get_completion_proc, 0);
    rb_define_singleton_method(mReadline, "completion_case_fold=",
			       readline_s_set_completion_case_fold, 1);
    rb_define_singleton_method(mReadline, "completion_case_fold",
			       readline_s_get_completion_case_fold, 0);
    rb_define_singleton_method(mReadline, "vi_editing_mode",
			       readline_s_vi_editing_mode, 0);
    rb_define_singleton_method(mReadline, "emacs_editing_mode",
			       readline_s_emacs_editing_mode, 0);
    rb_define_singleton_method(mReadline, "completion_append_character=",
			       readline_s_set_completion_append_character, 1);
    rb_define_singleton_method(mReadline, "completion_append_character",
			       readline_s_get_completion_append_character, 0);
    rb_define_singleton_method(mReadline, "basic_word_break_characters=",
			       readline_s_set_basic_word_break_characters, 1);
    rb_define_singleton_method(mReadline, "basic_word_break_characters",
			       readline_s_get_basic_word_break_characters, 0);
    rb_define_singleton_method(mReadline, "completer_word_break_characters=",
			       readline_s_set_completer_word_break_characters, 1);
    rb_define_singleton_method(mReadline, "completer_word_break_characters",
			       readline_s_get_completer_word_break_characters, 0);
    rb_define_singleton_method(mReadline, "basic_quote_characters=",
			       readline_s_set_basic_quote_characters, 1);
    rb_define_singleton_method(mReadline, "basic_quote_characters",
			       readline_s_get_basic_quote_characters, 0);
    rb_define_singleton_method(mReadline, "completer_quote_characters=",
			       readline_s_set_completer_quote_characters, 1);
    rb_define_singleton_method(mReadline, "completer_quote_characters",
			       readline_s_get_completer_quote_characters, 0);
    rb_define_singleton_method(mReadline, "filename_quote_characters=",
			       readline_s_set_filename_quote_characters, 1);
    rb_define_singleton_method(mReadline, "filename_quote_characters",
			       readline_s_get_filename_quote_characters, 0);

    history = rb_obj_alloc(rb_cObject);
    rb_extend_object(history, rb_mEnumerable);
    rb_define_singleton_method(history,"to_s", hist_to_s, 0);
    rb_define_singleton_method(history,"[]", hist_get, 1);
    rb_define_singleton_method(history,"[]=", hist_set, 2);
    rb_define_singleton_method(history,"<<", hist_push, 1);
    rb_define_singleton_method(history,"push", hist_push_method, -1);
    rb_define_singleton_method(history,"pop", hist_pop, 0);
    rb_define_singleton_method(history,"shift", hist_shift, 0);
    rb_define_singleton_method(history,"each", hist_each, 0);
    rb_define_singleton_method(history,"length", hist_length, 0);
    rb_define_singleton_method(history,"size", hist_length, 0);

    rb_define_singleton_method(history,"empty?", hist_empty_p, 0);
    rb_define_singleton_method(history,"delete_at", hist_delete_at, 1);
    rb_define_const(mReadline, "HISTORY", history);

    fcomp = rb_obj_alloc(rb_cObject);
    rb_define_singleton_method(fcomp, "call",
			       filename_completion_proc_call, 1);
    rb_define_const(mReadline, "FILENAME_COMPLETION_PROC", fcomp);

    ucomp = rb_obj_alloc(rb_cObject);
    rb_define_singleton_method(ucomp, "call",
			       username_completion_proc_call, 1);
    rb_define_const(mReadline, "USERNAME_COMPLETION_PROC", ucomp);
#if READLINE_21_OR_LATER
    rb_define_const(mReadline, "VERSION", rb_str_new2(rl_library_version));
#else
    rb_define_const(mReadline, "VERSION",
                    rb_str_new2("2.0 or before version"));
#endif

    rl_attempted_completion_function
	= (CPPFunction *) readline_attempted_completion_function;
    rl_event_hook = readline_event;
    rl_clear_signals();
}
@


1.10
log
@typo
@
text
@d194 1
a194 1
    if (NIL_P(str)) {
a196 2
	StringValue(str);

@


1.9
log
@* ext/readline/readline.c (readline_readline): get rid of
  libreadline's bug. (ruby-bugs-ja:PR#268)
@
text
@d656 1
a656 1
    VALUE histary, fcomp, ucomp;
d703 12
a714 12
    histary = rb_obj_alloc(rb_cObject);
    rb_extend_object(histary, rb_mEnumerable);
    rb_define_singleton_method(histary,"to_s", hist_to_s, 0);
    rb_define_singleton_method(histary,"[]", hist_get, 1);
    rb_define_singleton_method(histary,"[]=", hist_set, 2);
    rb_define_singleton_method(histary,"<<", hist_push, 1);
    rb_define_singleton_method(histary,"push", hist_push_method, -1);
    rb_define_singleton_method(histary,"pop", hist_pop, 0);
    rb_define_singleton_method(histary,"shift", hist_shift, 0);
    rb_define_singleton_method(histary,"each", hist_each, 0);
    rb_define_singleton_method(histary,"length", hist_length, 0);
    rb_define_singleton_method(histary,"size", hist_length, 0);
d716 3
a718 3
    rb_define_singleton_method(histary,"empty?", hist_empty_p, 0);
    rb_define_singleton_method(histary,"delete_at", hist_delete_at, 1);
    rb_define_const(mReadline, "HISTORY", histary);
@


1.8
log
@* ext/readline/readline.c: new methods
	Readline::basic_word_break_characters,
	Readline::basic_word_break_characters=,
	Readline::completer_word_break_characters,
	Readline::completer_word_break_characters=,
	Readline::basic_quote_characters,
	Readline::basic_quote_characters=,
	Readline::completer_quote_characters,
	Readline::completer_quote_characters=,
	Readline::filename_quote_characters,
	Readline::filename_quote_characters=.
@
text
@d4 1
d47 2
@


1.7
log
@* ext/readline/readline.c: restore terminal mode
  even if readline() interrupted.

* ext/readline/readline.c: returned string need to
  be tainted.

* ext/readline/readline.c: fixed memory leak.

* ext/readline/readline.c: allow negative index.

* ext/readline/readline.c: added Readline::HISTORY.size
  same as Readline::HISTORY.length

* ext/readline/readline.c: allow conditional parsing
  of the ~/.inputrc file by `$if Ruby'.

* ext/readline/extconf.rb: check whether the
  libreadline has the variable `rl_completion_append_character'
  (this feature was implemented from GNU readline 2.1).
@
text
@d225 200
d679 20
@


1.6
log
@* ext/readline/readline.c (readline_event): a non-void function
  should return a value.
@
text
@d41 1
d46 16
a61 1
    buff = readline(prompt);
d66 1
a66 1
	result = rb_str_new2(buff);
d121 1
a121 1
    ary = rb_funcall(proc, rb_intern("call"), 1, rb_str_new2(text));
d190 1
d200 3
d209 1
d219 20
d258 3
d264 1
a264 1
    return rb_str_new2(state->entries[i]->line);
d279 3
a317 1
    HIST_ENTRY *entry;
d321 1
a321 2
	entry = remove_history(state->length - 1);
	return rb_str_new2(entry->line);
a331 1
    HIST_ENTRY *entry;
d335 1
a335 2
	entry = remove_history(0);
	return rb_str_new2(entry->line);
d350 1
a350 1
	rb_yield(rb_str_new2(state->entries[i]->line));
a383 1
    HIST_ENTRY *entry;
d388 2
d393 1
a393 2
    entry = remove_history(NUM2INT(index));
    return rb_str_new2(entry->line);
d410 1
a410 1
	    rb_ary_push(result, rb_str_new2(matches[i]));
d437 1
a437 1
	    rb_ary_push(result, rb_str_new2(matches[i]));
d455 3
d491 2
d506 6
@


1.5
log
@* ext/readline/readline.c: add new methods:
  Readline::completion_append_character and
  Readline::completion_append_character=.k
@
text
@d29 1
@


1.4
log
@* parse.y (arg): "||=" should not warn for uninitialized instance
  variables.

* eval.c (rb_eval): ditto.

* eval.c (eval): preserve and restore ruby_cref as well.
@
text
@d170 30
d428 4
@


1.3
log
@forgot some checkins.
@
text
@d21 1
d331 2
a332 2
    matches = completion_matches(StringValuePtr(str),
				 rl_filename_completion_function);
d358 2
a359 2
    matches = completion_matches(StringValuePtr(str),
				 rl_username_completion_function);
@


1.2
log
@remove marshal/gtk/kconv
@
text
@d2 1
a2 1
   Copyright (C) 1997-1998  Shugo Maeda */
d18 5
d41 1
a41 1
	prompt = STR2CSTR(tmp);
d198 1
d206 1
a206 1
    replace_history_entry(i, STR2CSTR(str), NULL);
d215 1
a215 1
    add_history(STR2CSTR(str));
d229 1
a229 1
	add_history(STR2CSTR(str));
d330 2
a331 2
    matches = completion_matches(STR2CSTR(str),
				 filename_completion_function);
d357 2
a358 2
    matches = completion_matches(STR2CSTR(str),
				 username_completion_function);
@


1.2.6.1
log
@several minor fixes.
@
text
@a17 6
#ifndef READLINE_42_OR_LATER
# define rl_filename_completion_function filename_completion_function
# define rl_username_completion_function username_completion_function
# define rl_completion_matches completion_matches
#endif

d324 2
a325 2
    matches = rl_completion_matches(STR2CSTR(str),
				    rl_filename_completion_function);
d351 2
a352 2
    matches = rl_completion_matches(STR2CSTR(str),
				    rl_username_completion_function);
@


1.2.4.1
log
@* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).
@
text
@a17 5
#ifndef READLINE_42_OR_LATER
# define rl_filename_completion_function filename_completion_function
# define rl_username_completion_function username_completion_function
#endif

d325 1
a325 1
				 rl_filename_completion_function);
d352 1
a352 1
				 rl_username_completion_function);
@


1.2.4.2
log
@checkin leftovers
@
text
@a20 1
# define rl_completion_matches completion_matches
d329 2
a330 2
    matches = rl_completion_matches(STR2CSTR(str),
				    rl_filename_completion_function);
d356 2
a357 2
    matches = rl_completion_matches(STR2CSTR(str),
				    rl_username_completion_function);
@


1.2.4.3
log
@* ext/readline/readline.c (readline_event): merge from 1.7: a
  non-void function should return a value.

* ext/readline/readline.c: merge from 1.7: add new methods:
  Readline::completion_append_character and
  Readline::completion_append_character=.

* ext/readline/README, ext/readline/README.jp: merge from 1.7: add
  an English version of the document.
@
text
@a28 1
    return 0;
a169 30
readline_s_set_completion_append_character(self, str)
    VALUE self, str;
{
    if (NIL_P(str)) {
	rl_completion_append_character = '\0';
    } else {
	Check_Type(str, T_STRING);

	rl_completion_append_character = RSTRING(str)->ptr[0];
    }

    return self;
}

static VALUE
readline_s_get_completion_append_character(self)
    VALUE self;
{
    VALUE str;

    if (rl_completion_append_character == '\0')
	return Qnil;

    str = rb_str_new("", 1);
    RSTRING(str)->ptr[0] = rl_completion_append_character;

    return str;
}

static VALUE
a396 4
    rb_define_singleton_method(mReadline, "completion_append_character=",
			       readline_s_set_completion_append_character, 1);
    rb_define_singleton_method(mReadline, "completion_append_character",
			       readline_s_get_completion_append_character, 0);
@


1.2.4.4
log
@* ext/readline/readline.c (readline_readline): get rid of
  libreadline's bug. (ruby-bugs-ja:PR#268)
@
text
@a3 1
#include <errno.h>
a44 3

    if (!isatty(0) && errno == EBADF) rb_raise(rb_eIOError, "stdin closed");

@


1.1
log
@Initial revision
@
text
@a21 1
#ifdef USE_THREAD
a22 1
#endif
d26 4
a29 1
readline_readline(int argc, VALUE *argv, VALUE self)
d51 3
a53 1
readline_s_set_completion_proc(VALUE self, VALUE proc)
d61 2
a62 1
readline_s_get_completion_proc(VALUE self)
d68 3
a70 1
readline_s_set_completion_case_fold(VALUE self, VALUE val)
d76 2
a77 1
readline_s_get_completion_case_fold(VALUE self)
d83 4
a86 1
readline_attempted_completion_function(char *text, int start, int end)
d94 2
d148 2
a149 1
readline_s_vi_editing_mode(VALUE self)
d151 1
a151 1
    rl_vi_editing_mode();
d156 2
a157 1
readline_s_emacs_editing_mode(VALUE self)
d159 1
a159 1
    rl_emacs_editing_mode();
d164 2
a165 1
hist_to_s(VALUE self)
d171 3
a173 1
hist_get(VALUE self, VALUE index)
d187 4
a190 1
hist_set(VALUE self, VALUE index, VALUE str)
d205 3
a207 1
hist_push(VALUE self, VALUE str)
d214 4
a217 2
hist_push_method(int argc, VALUE *argv,
			      VALUE self)
d229 2
a230 1
hist_pop(VALUE self)
d245 2
a246 1
hist_shift(VALUE self)
d261 2
a262 1
hist_each(VALUE self)
d271 1
a271 1
    return Qnil;
d275 2
a276 1
hist_length(VALUE self)
d285 2
a286 1
hist_empty_p(VALUE self)
d298 3
a300 1
hist_delete_at(VALUE self, VALUE index)
d316 3
a318 1
filename_completion_proc_call(VALUE self, VALUE str)
d343 3
a345 1
username_completion_proc_call(VALUE self, VALUE str)
d370 1
a370 1
Init_readline(void)
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@@


1.1.1.1.2.1
log
@990324
@
text
@d22 1
d24 1
d138 1
a138 1
    rl_vi_editing_mode(1,0);
d145 1
a145 1
    rl_emacs_editing_mode(1,0);
@


1.1.1.1.2.2
log
@.*/.+/.?
@
text
@a81 2
    if (NIL_P(proc))
	return NULL;
@


1.1.1.1.2.3
log
@arity/strict yield
@
text
@d26 1
a26 4
readline_readline(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
d48 1
a48 3
readline_s_set_completion_proc(self, proc)
    VALUE self;
    VALUE proc;
d56 1
a56 2
readline_s_get_completion_proc(self)
    VALUE self;
d62 1
a62 3
readline_s_set_completion_case_fold(self, val)
    VALUE self;
    VALUE val;
d68 1
a68 2
readline_s_get_completion_case_fold(self)
    VALUE self;
d74 1
a74 4
readline_attempted_completion_function(text, start, end)
    char *text;
    int start;
    int end;
d136 1
a136 2
readline_s_vi_editing_mode(self)
    VALUE self;
d143 1
a143 2
readline_s_emacs_editing_mode(self)
    VALUE self;
d150 1
a150 2
hist_to_s(self)
    VALUE self;
d156 1
a156 3
hist_get(self, index)
    VALUE self;
    VALUE index;
d170 1
a170 4
hist_set(self, index, str)
    VALUE self;
    VALUE index;
    VALUE str;
d185 1
a185 3
hist_push(self, str)
    VALUE self;
    VALUE str;
d192 2
a193 4
hist_push_method(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
d205 1
a205 2
hist_pop(self)
    VALUE self;
d220 1
a220 2
hist_shift(self)
    VALUE self;
d235 1
a235 2
hist_each(self)
    VALUE self;
d248 1
a248 2
hist_length(self)
    VALUE self;
d257 1
a257 2
hist_empty_p(self)
    VALUE self;
d269 1
a269 3
hist_delete_at(self, index)
    VALUE self;
    VALUE index;
d285 1
a285 3
filename_completion_proc_call(self, str)
    VALUE self;
    VALUE str;
d310 1
a310 3
username_completion_proc_call(self, str)
    VALUE self;
    VALUE str;
d335 1
a335 1
Init_readline()
@


1.1.1.1.2.4
log
@backtrace may be Qnil
@
text
@d271 1
a271 1
    return self;
@
