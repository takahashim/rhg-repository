head	1.1;
branch	1.1.1;
access;
symbols
	v1_6_7:1.1.1.2
	v1_6_6:1.1.1.2
	v1_6_5:1.1.1.2
	v1_6_4:1.1.1.2
	v1_7_1:1.1.1.2
	v1_6_4_preview4:1.1.1.2
	v1_6_4_preview3:1.1.1.2
	v1_6_4_preview2:1.1.1.2
	v1_6_4_preview1:1.1.1.2
	v1_6_3:1.1.1.2
	ruby_m17n:1.1.1.2.0.8
	ruby_1_6:1.1.1.2.0.6
	v1_6_2:1.1.1.2
	v1_6_1:1.1.1.2
	v1_6_0:1.1.1.2
	v1_4_6:1.1.1.2
	v1_4_5:1.1.1.2
	v1_4_4:1.1.1.2
	ruby_1_4_3:1.1.1.2
	ruby1_4_3:1.1.1.2
	v1_4_3:1.1.1.2
	v1_5_0:1.1.1.2
	ruby_1_4_3_pre1:1.1.1.2
	ruby_1_4:1.1.1.2.0.4
	v1_4_2:1.1.1.2
	v1_4_1:1.1.1.2
	v1_4_0:1.1.1.2
	v1_3_7:1.1.1.2
	v1_3_6_repack:1.1.1.2
	v1_3_6:1.1.1.2
	v1_3_5:1.1.1.2
	v1_2_6repack:1.1.1.1.2.1
	v1_3_4_990625:1.1.1.2
	v1_3_4_990624:1.1.1.2
	v1_2_6:1.1.1.1.2.1
	v1_3_4_990611:1.1.1.2
	v1_3_4_990531:1.1.1.2
	v1_3_3_990518:1.1.1.2
	v1_3_3_990513:1.1.1.2
	v1_3_3_990507:1.1.1.2
	v1_2_5:1.1.1.1.2.1
	v1_2_4:1.1.1.1.2.1
	v1_3_1_990225:1.1.1.2
	v1_3_1_990224:1.1.1.2
	v1_3_1_990215:1.1.1.2
	v1_3_1_990212:1.1.1.2
	v1_3_1_990210:1.1.1.2
	v1_3_1_:1.1.1.2
	v1_3_1_990209:1.1.1.2
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.2.1
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.2.1
	v1_2_1repack:1.1.1.1.2.1
	v1_2_1:1.1.1.1.2.1
	v1_2_stable:1.1.1.1
	v1_1d1:1.1.1.1
	v1_1d0:1.1.1.1
	v1_1c9_1:1.1.1.1
	v1_1c9:1.1.1.1
	v1_1c8:1.1.1.1
	v1_1c7:1.1.1.1
	v1_1c6:1.1.1.1
	v1_1d-start:1.1.1.1
	v1_1c5:1.1.1.1
	v1_1dev:1.1.1.1.0.4
	v1_1c4:1.1.1.1
	v1_1c3:1.1.1.1
	v1_1c2:1.1.1.1
	v1_1c1:1.1.1.1
	v1_1c0:1.1.1.1
	v1_1b9_31:1.1.1.1
	v1_1b9_30:1.1.1.1
	v1_1b9_28:1.1.1.1
	v1_1b9_27:1.1.1.1
	v1_1b9_26:1.1.1.1
	r1_1b9_25:1.1.1.1
	r1_1b9_24:1.1.1.1
	v1_1b9_23:1.1.1.1
	v1_1b9_22:1.1.1.1
	v1_1b9_20:1.1.1.1
	v1_1b9_18:1.1.1.1
	v1_1b9_16:1.1.1.1
	v1_1b9_15:1.1.1.1
	v1_1b9_13:1.1.1.1
	v1_1b9_12:1.1.1.1
	v1_1b9_11:1.1.1.1
	v1_1b9_08:1.1.1.1
	v1_1b9_07:1.1.1.1
	r1_1b9:1.1.1.1
	v1_1b8:1.1.1.1
	v1_1b7:1.1.1.1
	v1_1b6:1.1.1.1
	v1_1r:1.1.1.1.0.2
	v1_1:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;


1.1
date	98.01.16.12.19.16;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.19.16;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.33;	author matz;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	99.01.11.07.55.27;	author matz;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@# tof

#### tcltk ライブラリ
####	Sep. 5, 1997	Y. Shigehiro

require "tcltklib"

################

# module TclTk: tcl/tk のライブラリ全体で必要になるものを集めたもの
# (主に, 名前空間の点から module にする使う.)
module TclTk

  # 単にここに書けば最初に 1 度実行されるのか??

  # 生成した一意な名前を保持しておく連想配列を初期化する.
  @@namecnt = {}

  # コールバックを保持しておく連想配列を初期化する.
  @@callback = {}
end

# TclTk.mainloop(): TclTkLib.mainloop() を呼ぶ.
def TclTk.mainloop()
  print("mainloop: start\n") if $DEBUG
  TclTkLib.mainloop()
  print("mainloop: end\n") if $DEBUG
end

# TclTk.deletecallbackkey(ca): コールバックを TclTk module から取り除く.
#     tcl/tk インタプリタにおいてコールバックが取り消されるわけではない.
#     これをしないと, 最後に TclTkInterpreter が GC できない.
#     (GC したくなければ, 別に, これをしなくても良い.)
#   ca: コールバック(TclTkCallback)
def TclTk.deletecallbackkey(ca)
  print("deletecallbackkey: ", ca.to_s(), "\n") if $DEBUG
  @@callback.delete(ca.to_s)
end

# TclTk.dcb(ca, wid, W): 配列に入っている複数のコールバックに対して
#     TclTk.deletecallbackkey() を呼ぶ.
#     トップレベルの <Destroy> イベントのコールバックとして呼ぶためのもの.
#   ca: コールバック(TclTkCallback) の Array
#   wid: トップレベルのウィジェット(TclTkWidget)
#   w: コールバックに %W で与えられる, ウインドウに関するパラメータ(String)
def TclTk.dcb(ca, wid, w)
  if wid.to_s() == w
    ca.each{|i|
      TclTk.deletecallbackkey(i)
    }
  end
end

# TclTk._addcallback(ca): コールバックを登録する.
#   ca: コールバック(TclTkCallback)
def TclTk._addcallback(ca)
  print("_addcallback: ", ca.to_s(), "\n") if $DEBUG
  @@callback[ca.to_s()] = ca
end

# TclTk._callcallback(key, arg): 登録したコールバックを呼び出す.
#   key: コールバックを選択するキー (TclTkCallback が to_s() で返す値)
#   arg: tcl/tk インタプリタからのパラメータ
def TclTk._callcallback(key, arg)
  print("_callcallback: ", @@callback[key].inspect, "\n") if $DEBUG
  @@callback[key]._call(arg)
  # コールバックからの返り値はどうせ捨てられる.
  # String を返さないと, rb_eval_string() がエラーになる.
  return ""
end

# TclTk._newname(prefix): 一意な名前(String)を生成して返す.
#   prefix: 名前の接頭語
def TclTk._newname(prefix)
  # 生成した名前のカウンタは @@namecnt に入っているので, 調べる.
  if !@@namecnt.key?(prefix)
    # 初めて使う接頭語なので初期化する.
    @@namecnt[prefix] = 1
  else
    # 使ったことのある接頭語なので, 次の名前にする.
    @@namecnt[prefix] += 1
  end
  return "#{prefix}#{@@namecnt[prefix]}"
end

################

# class TclTkInterpreter: tcl/tk のインタプリタ
class TclTkInterpreter

  # initialize(): 初期化.
  def initialize()
    # インタプリタを生成する.
    @@ip = TclTkIp.new()

    # インタプリタに ruby_fmt コマンドを追加する.
    # ruby_fmt コマンドとは, 後ろの引数を format コマンドで処理して
    # ruby コマンドに渡すものである.
    # (なお, ruby コマンドは, 引数を 1 つしかとれない.)
    if $DEBUG
      @@ip._eval("proc ruby_fmt {fmt args} { puts \"ruby_fmt: $fmt $args\" ; ruby [format $fmt $args] }")
    else
      @@ip._eval("proc ruby_fmt {fmt args} { ruby [format $fmt $args] }")
    end

    # @@ip._get_eval_string(*args): tcl/tk インタプリタで評価する
    #     文字列(String)を生成して返す.
    #   *args: tcl/tk で評価するスクリプト(に対応するオブジェクト列)
    def @@ip._get_eval_string(*args)
      argstr = ""
      args.each{|arg|
	argstr += " " if argstr != ""
	# もし to_eval() メソッドが
	if (arg.respond_to?(:to_eval))
	  # 定義されていればそれを呼ぶ.
	  argstr += arg.to_eval()
	else
	  # 定義されていなければ to_s() を呼ぶ.
	  argstr += arg.to_s()
	end
      }
      return argstr
    end

    # @@ip._eval_args(*args): tcl/tk インタプリタで評価し,
    #     その結果(String)を返す.
    #   *args: tcl/tk で評価するスクリプト(に対応するオブジェクト列)
    def @@ip._eval_args(*args)
      # インタプリタで評価する文字列を求める.
      argstr = _get_eval_string(*args)

      # インタプリタで評価する.
      print("_eval: \"", argstr, "\"") if $DEBUG
      res = _eval(argstr)
      if $DEBUG
	print(" -> \"", res, "\"\n")
      elsif  _return_value() != 0
	print(res, "\n")
      end
      fail(%Q/can't eval "#{argstr}"/) if _return_value() != 0
      return res
    end

    # tcl/tk のコマンドに対応するオブジェクトを生成し, 連想配列に入れておく.
    @@commands = {}
    # tcl/tk インタプリタに登録されているすべてのコマンドに対して,
    @@ip._eval("info command").split(/ /).each{|comname|
      if comname =~ /^[.]/
	# コマンドがウィジェット(のパス名)の場合は
	# TclTkWidget のインスタンスを作って連想配列に入れる.
	@@commands[comname] = TclTkWidget.new(@@ip, comname)
      else
	# そうでない場合は
	# TclTkCommand のインスタンスを作って連想配列に入れる.
	@@commands[comname] = TclTkCommand.new(@@ip, comname)
      end
    }
  end

  # commands(): tcl/tk のコマンドに対応するオブジェクトを Hash に
  #     入れたものを返す.
  def commands()
    return @@commands
  end

  # rootwidget(): ルートウィジェット(TclTkWidget)を返す.
  def rootwidget()
    return @@commands["."]
  end

  # _tcltkip(): @@ip(TclTkIp) を返す.
  def _tcltkip()
    return @@ip
  end

  # method_missing(id, *args): 未定義のメソッドは tcl/tk のコマンドとみなして
  #     実行し, その結果(String)を返す.
  #   id: メソッドのシンボル
  #   *args: コマンドの引数
  def method_missing(id, *args)
    # もし, メソッドの tcl/tk コマンドが
    if @@commands.key?(id.id2name)
      # あれば, 実行して結果を返す.
      return @@commands[id.id2name].e(*args)
    else
      # 無ければもともとの処理.
      super
    end
  end
end

# class TclTkObject: tcl/tk のオブジェクト
# (基底クラスとして使う.
#  tcltk ライブラリを使う人が TclTkObject.new() することはないはず.)
class TclTkObject

  # initialize(ip, exp): 初期化.
  #   ip: インタプリタ(TclTkIp)
  #   exp: tcl/tk での表現形
  def initialize(ip, exp)
    fail("type is not TclTkIp") if !ip.kind_of?(TclTkIp)
    @@ip = ip
    @@exp = exp
  end

  # to_s(): tcl/tk での表現形(String)を返す.
  def to_s()
    return @@exp
  end
end

# class TclTkCommand: tcl/tk のコマンド
# (tcltk ライブラリを使う人が TclTkCommand.new() することはないはず.
#  TclTkInterpreter:initialize() から new() される.)
class TclTkCommand < TclTkObject

  # e(*args): コマンドを実行し, その結果(String)を返す.
  #     (e は exec または eval の e.)
  #   *args: コマンドの引数
  def e(*args)
    return @@ip._eval_args(to_s(), *args)
  end
end

# class TclTkLibCommand: tcl/tk のコマンド
# (ライブラリにより実現されるコマンドで, tcl/tk インタプリタに最初から
#  存在しないものは, インタプリタの commands() では生成できない.
#  そのようなものに対し, コマンドの名前から TclTkCommand オブジェクトを
#  生成する.
class TclTkLibCommand < TclTkCommand

  # initialize(ip, name): 初期化
  #   ip: インタプリタ(TclTkInterpreter)
  #   name: コマンド名 (String)
  def initialize(ip, name)
    super(ip._tcltkip, name)
  end
end

# class TclTkVariable: tcl/tk の変数
class TclTkVariable < TclTkObject

  # initialize(interp, dat): 初期化.
  #   interp: インタプリタ(TclTkInterpreter)
  #   dat: 設定する値(String)
  #       nil なら, 設定しない.
  def initialize(interp, dat)
    # tcl/tk での表現形(変数名)を自動生成する.
    exp = TclTk._newname("v_")
    # TclTkObject を初期化する.
    super(interp._tcltkip(), exp)
    # set コマンドを使うのでとっておく.
    @@set = interp.commands()["set"]
    # 値を設定する.
    set(dat) if dat
  end

  # tcl/tk の set を使えば, 値の設定/参照はできるが,
  # それだけではなんなので, 一応, メソッドをかぶせたものも用意しておく.

  # set(data): tcl/tk の変数に set を用いて値を設定する.
  #   data: 設定する値
  def set(data)
    @@set.e(to_s(), data.to_s())
  end

  # get(): tcl/tk の変数の値(String)を set を用いて読みだし返す.
  def get()
    return @@set.e(to_s())
  end
end

# class TclTkWidget: tcl/tk のウィジェット
class TclTkWidget < TclTkCommand

  # initialize(*args): 初期化.
  #   *args: パラメータ
  def initialize(*args)
    if args[0].kind_of?(TclTkIp)
      # 最初の引数が TclTkIp の場合:

      # 既に tcl/tk に定義されているウィジェットに TclTkWidget の構造を
      # かぶせる. (TclTkInterpreter:initialize() から使われる.)

      # パラメータ数が 2 でなければエラー.
      fail("illegal # of parameter") if args.size != 2

      # ip: インタプリタ(TclTkIp)
      # exp: tcl/tk での表現形
      ip, exp = args

      # TclTkObject を初期化する.
      super(ip, exp)
    elsif args[0].kind_of?(TclTkInterpreter)
      # 最初の引数が TclTkInterpreter の場合:

      # 親ウィジェットから新たなウィジェトを生成する.

      # interp: インタプリタ(TclTkInterpreter)
      # parent: 親ウィジェット
      # command: ウィジェットを生成するコマンド(label 等)
      # *args: command に渡す引数
      interp, parent, command, *args = args

      # ウィジェットの名前を作る.
      exp = parent.to_s()
      exp += "." if exp !~ /[.]$/
      exp += TclTk._newname("w_")
      # TclTkObject を初期化する.
      super(interp._tcltkip(), exp)
      # ウィジェットを生成する.
      res = @@ip._eval_args(command, exp, *args)
#      fail("can't create Widget") if res != exp
      # tk_optionMenu では, ボタン名を exp で指定すると
      # res にメニュー名を返すので res != exp となる.
    else
      fail("first parameter is not TclTkInterpreter")
    end
  end
end

# class TclTkCallback: tcl/tk のコールバック
class TclTkCallback < TclTkObject

  # initialize(interp, pr, arg): 初期化.
  #   interp: インタプリタ(TclTkInterpreter)
  #   pr: コールバック手続き(Proc)
  #   arg: pr のイテレータ変数に渡す文字列
  #       tcl/tk の bind コマンドではパラメータを受け取るために % 置換を
  #       用いるが, pr の内部で % を書いてもうまくいかない.
  #       arg に文字列を書いておくと, その置換結果を, pr で
  #       イテレータ変数を通して受け取ることができる.
  #       scrollbar コマンドの -command オプションのように
  #       何も指定しなくてもパラメータが付くコマンドに対しては,
  #       arg を指定してはならない.
  def initialize(interp, pr, arg = nil)
    # tcl/tk での表現形(変数名)を自動生成する.
    exp = TclTk._newname("c_")
    # TclTkObject を初期化する.
    super(interp._tcltkip(), exp)
    # パラメータをとっておく.
    @@pr = pr
    @@arg = arg
    # モジュールに登録しておく.
    TclTk._addcallback(self)
  end

  # to_eval(): @@ip._eval_args で評価するときの表現形(String)を返す.
  def to_eval()
    if @@arg
      # %s は ruby_fmt より前に bind により置換されてしまうので
      # %%s としてある. したがって, これは bind 専用.
      s = %Q/{ruby_fmt {TclTk._callcallback("#{to_s()}", "%%s")} #{@@arg}}/
    else
      s = %Q/{ruby_fmt {TclTk._callcallback("#{to_s()}", "%s")}}/
    end

    return s
  end

  # _call(arg): コールバックを呼び出す.
  #   arg: コールバックに渡されるパラメータ
  def _call(arg)
    @@pr.call(arg)
  end
end

# class TclTkImage: tcl/tk のイメージ
class TclTkImage < TclTkCommand

  # initialize(interp, t, *args): 初期化.
  #     イメージの生成は TclTkImage.new() で行うが,
  #     破壊は image delete で行う. (いまいちだけど仕方が無い.)
  #   interp: インタプリタ(TclTkInterpreter)
  #   t: イメージのタイプ (photo, bitmap, etc.)
  #   *args: コマンドの引数
  def initialize(interp, t, *args)
    # tcl/tk での表現形(変数名)を自動生成する.
    exp = TclTk._newname("i_")
    # TclTkObject を初期化する.
    super(interp._tcltkip(), exp)
    # イメージを生成する.
    res = @@ip._eval_args("image create", t, exp, *args)
    fail("can't create Image") if res != exp
  end
end

# eof
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@d3 1
a3 1
#### tcltk library, more direct manipulation of tcl/tk
d10 2
a11 1
# module TclTk: collection of tcl/tk utilities (supplies namespace.)
d14 3
a16 1
  # initialize Hash to hold unique symbols and such
d19 1
a19 1
  # initialize Hash to hold callbacks
d23 1
a23 1
# TclTk.mainloop(): call TclTkLib.mainloop()
d30 5
a34 4
# TclTk.deletecallbackkey(ca): remove callback from TclTk module
#     this does not remove callbacks from tcl/tk interpreter
#     without calling this method, TclTkInterpreter will not be GCed
#   ca: callback(TclTkCallback)
d40 6
a45 6
# TclTk.dcb(ca, wid, W): call TclTk.deletecallbackkey() for each callbacks
#     in an array.
#     this is for callback for top-level <Destroy>
#   ca: array of callbacks(TclTkCallback)
#   wid: top-level widget(TclTkWidget)
#   w: information about window given by %W(String)
d54 2
a55 2
# TclTk._addcallback(ca): register callback
#   ca: callback(TclTkCallback)
d61 3
a63 3
# TclTk._callcallback(key, arg): invoke registered callback
#   key: key to select callback (to_s value of the TclTkCallback)
#   arg: parameter from tcl/tk interpreter
d67 2
a68 2
  # throw out callback value
  # should return String to satisfy rb_eval_string()
d72 2
a73 2
# TclTk._newname(prefix): generate unique name(String)
#   prefix: prefix of the unique name
d75 1
a75 1
  # generated name counter is stored in @@namecnt
d77 1
a77 1
    # first appearing prefix, initialize
d80 1
a80 1
    # already appeared prefix, generate next name
d88 1
a88 1
# class TclTkInterpreter: tcl/tk interpreter
d91 1
a91 1
  # initialize(): 
d93 1
a93 1
    # generate interpreter object
d96 4
a99 3
    # add ruby_fmt command to tcl interpreter
    # ruby_fmt command format arguments by `format' and call `ruby' command
    # (notice ruby command receives only one argument)
d106 3
a108 2
    # @@ip._get_eval_string(*args): generate string to evaluate in tcl interpreter
    #   *args: script which is going to be evaluated under tcl/tk
d113 1
a113 1
	# call to_eval if it is defined
d115 1
d118 1
a118 1
	  # call to_s unless defined
d125 3
a127 3
    # @@ip._eval_args(*args): evaluate string under tcl/tk interpreter
    #     returns result string.
    #   *args: script which is going to be evaluated under tcl/tk
d129 1
a129 1
      # calculate the string to eval in the interpreter
d132 1
a132 1
      # evaluate under the interpreter
d140 1
a140 1
      fail(%Q/can't eval "#{argstr}"/) if _return_value() != 0 #'
d144 1
a144 1
    # generate tcl/tk command object and register in the hash
d146 1
a146 1
    # for all commands registered in tcl/tk interpreter:
d149 2
a150 2
	# if command is a widget (path), generate TclTkWidget,
	# and register it in the hash
d153 2
a154 1
	# otherwise, generate TclTkCommand
d160 2
a161 1
  # commands(): returns hash of the tcl/tk commands
d166 1
a166 1
  # rootwidget(): returns root widget(TclTkWidget)
d171 1
a171 1
  # _tcltkip(): returns @@ip(TclTkIp)
d176 4
a179 3
  # method_missing(id, *args): execute undefined method as tcl/tk command
  #   id: method symbol
  #   *args: method arguments
d181 1
a181 1
    # if command named by id registered, then execute it
d183 1
d186 1
a186 1
      # otherwise, exception
d192 3
a194 1
# class TclTkObject: base class of the tcl/tk objects
d197 3
a199 3
  # initialize(ip, exp): 
  #   ip: interpreter(TclTkIp)
  #   exp: tcl/tk representation
d206 1
a206 1
  # to_s(): returns tcl/tk representation
d212 3
a214 3
# class TclTkCommand: tcl/tk commands
# you should not call TclTkCommand.new()
# commands are created by TclTkInterpreter:initialize()
d217 3
a219 2
  # e(*args): execute command.  returns String (e is for exec or eval)
  #   *args: command arguments
d225 5
a229 1
# class TclTkLibCommand: tcl/tk commands in the library
d232 3
a234 3
  # initialize(ip, name): 
  #   ip: interpreter(TclTkInterpreter)
  #   name: command name (String)
d240 1
a240 1
# class TclTkVariable: tcl/tk variable
d243 4
a246 4
  # initialize(interp, dat): 
  #   interp: interpreter(TclTkInterpreter)
  #   dat: the value to set(String)
  #       if nil, not initialize variable
d248 1
a248 1
    # auto-generate tcl/tk representation (variable name)
d250 1
a250 1
    # initialize TclTkObject
d252 1
a252 1
    # safe this for `set' command
d254 1
a254 1
    # set value
d258 2
a259 2
  # although you can set/refer variable by using set in tcl/tk,
  # we provide the method for accessing variables
d261 2
a262 2
  # set(data): set tcl/tk variable using `set'
  #   data: new value
d267 1
a267 1
  # get(): read tcl/tk variable(String) using `set'
d273 1
a273 1
# class TclTkWidget: tcl/tk widget
d276 2
a277 2
  # initialize(*args): 
  #   *args: parameters
d280 1
a280 1
      # in case the 1st argument is TclTkIp:
d282 2
a283 2
      # Wrap tcl/tk widget by TclTkWidget
      # (used in TclTkInterpreter#initialize())
d285 1
a285 1
      # need two arguments
d288 2
a289 2
      # ip: interpreter(TclTkIp)
      # exp: tcl/tk representation
d292 1
a292 1
      # initialize TclTkObject
d295 1
a295 1
      # in case 1st parameter is TclTkInterpreter:
d297 1
a297 1
      # generate new widget from parent widget
d299 4
a302 4
      # interp: interpreter(TclTkInterpreter)
      # parent: parent widget
      # command: widget generating tk command(label 等)
      # *args: argument to the command 
d305 1
a305 1
      # generate widget name
d309 1
a309 1
      # initialize TclTkObject
d311 1
a311 1
      # generate widget
d314 2
a315 1
      # for tk_optionMenu, it is legal res != exp
d322 1
a322 1
# class TclTkCallback: tcl/tk callbacks
d325 11
a335 10
  # initialize(interp, pr, arg): 
  #   interp: interpreter(TclTkInterpreter)
  #   pr: callback procedure(Proc)
  #   arg: string to pass as block parameters of pr
  #       bind command of tcl/tk uses % replacement for parameters
  #       pr can receive replaced data using block parameter
  #       its format is specified by arg string
  #       You should not specify arg for the command like 
  #       scrollbar with -command option, which receives parameters
  #       without specifying any replacement
d337 1
a337 1
    # auto-generate tcl/tk representation (variable name)
d339 1
a339 1
    # initialize TclTkObject
d341 1
a341 1
    # save parameters
d344 1
a344 1
    # register in the module
d348 1
a348 1
  # to_eval(): retuens string representation for @@ip._eval_args
d351 2
a352 1
      # bind replaces %s before calling ruby_fmt, so %%s is used
d361 2
a362 2
  # _call(arg): invoke callback
  #   arg: callback parameter
d368 1
a368 1
# class TclTkImage: tcl/tk images
d371 6
a376 6
  # initialize(interp, t, *args): 
  #     generating image is done by TclTkImage.new()
  #     destrying is done by image delete (inconsistent, sigh)
  #   interp: interpreter(TclTkInterpreter)
  #   t: image type (photo, bitmap, etc.)
  #   *args: command argument
d378 1
a378 1
    # auto-generate tcl/tk representation
d380 1
a380 1
    # initialize TclTkObject
d382 1
a382 1
    # generate image
@


1.1.1.1.2.1
log
@1.2.1 stable
@
text
@d3 1
a3 1
#### tcltk library, more direct manipulation of tcl/tk
d10 2
a11 1
# module TclTk: collection of tcl/tk utilities (supplies namespace.)
d14 3
a16 1
  # initialize Hash to hold unique symbols and such
d19 1
a19 1
  # initialize Hash to hold callbacks
d23 1
a23 1
# TclTk.mainloop(): call TclTkLib.mainloop()
d30 5
a34 4
# TclTk.deletecallbackkey(ca): remove callback from TclTk module
#     this does not remove callbacks from tcl/tk interpreter
#     without calling this method, TclTkInterpreter will not be GCed
#   ca: callback(TclTkCallback)
d40 6
a45 6
# TclTk.dcb(ca, wid, W): call TclTk.deletecallbackkey() for each callbacks
#     in an array.
#     this is for callback for top-level <Destroy>
#   ca: array of callbacks(TclTkCallback)
#   wid: top-level widget(TclTkWidget)
#   w: information about window given by %W(String)
d54 2
a55 2
# TclTk._addcallback(ca): register callback
#   ca: callback(TclTkCallback)
d61 3
a63 3
# TclTk._callcallback(key, arg): invoke registered callback
#   key: key to select callback (to_s value of the TclTkCallback)
#   arg: parameter from tcl/tk interpreter
d67 2
a68 2
  # throw out callback value
  # should return String to satisfy rb_eval_string()
d72 2
a73 2
# TclTk._newname(prefix): generate unique name(String)
#   prefix: prefix of the unique name
d75 1
a75 1
  # generated name counter is stored in @@namecnt
d77 1
a77 1
    # first appearing prefix, initialize
d80 1
a80 1
    # already appeared prefix, generate next name
d88 1
a88 1
# class TclTkInterpreter: tcl/tk interpreter
d91 1
a91 1
  # initialize(): 
d93 1
a93 1
    # generate interpreter object
d96 4
a99 3
    # add ruby_fmt command to tcl interpreter
    # ruby_fmt command format arguments by `format' and call `ruby' command
    # (notice ruby command receives only one argument)
d106 3
a108 2
    # @@ip._get_eval_string(*args): generate string to evaluate in tcl interpreter
    #   *args: script which is going to be evaluated under tcl/tk
d113 1
a113 1
	# call to_eval if it is defined
d115 1
d118 1
a118 1
	  # call to_s unless defined
d125 3
a127 3
    # @@ip._eval_args(*args): evaluate string under tcl/tk interpreter
    #     returns result string.
    #   *args: script which is going to be evaluated under tcl/tk
d129 1
a129 1
      # calculate the string to eval in the interpreter
d132 1
a132 1
      # evaluate under the interpreter
d140 1
a140 1
      fail(%Q/can't eval "#{argstr}"/) if _return_value() != 0 #'
d144 1
a144 1
    # generate tcl/tk command object and register in the hash
d146 1
a146 1
    # for all commands registered in tcl/tk interpreter:
d149 2
a150 2
	# if command is a widget (path), generate TclTkWidget,
	# and register it in the hash
d153 2
a154 1
	# otherwise, generate TclTkCommand
d160 2
a161 1
  # commands(): returns hash of the tcl/tk commands
d166 1
a166 1
  # rootwidget(): returns root widget(TclTkWidget)
d171 1
a171 1
  # _tcltkip(): returns @@ip(TclTkIp)
d176 4
a179 3
  # method_missing(id, *args): execute undefined method as tcl/tk command
  #   id: method symbol
  #   *args: method arguments
d181 1
a181 1
    # if command named by id registered, then execute it
d183 1
d186 1
a186 1
      # otherwise, exception
d192 3
a194 1
# class TclTkObject: base class of the tcl/tk objects
d197 3
a199 3
  # initialize(ip, exp): 
  #   ip: interpreter(TclTkIp)
  #   exp: tcl/tk representation
d206 1
a206 1
  # to_s(): returns tcl/tk representation
d212 3
a214 3
# class TclTkCommand: tcl/tk commands
# you should not call TclTkCommand.new()
# commands are created by TclTkInterpreter:initialize()
d217 3
a219 2
  # e(*args): execute command.  returns String (e is for exec or eval)
  #   *args: command arguments
d225 5
a229 1
# class TclTkLibCommand: tcl/tk commands in the library
d232 3
a234 3
  # initialize(ip, name): 
  #   ip: interpreter(TclTkInterpreter)
  #   name: command name (String)
d240 1
a240 1
# class TclTkVariable: tcl/tk variable
d243 4
a246 4
  # initialize(interp, dat): 
  #   interp: interpreter(TclTkInterpreter)
  #   dat: the value to set(String)
  #       if nil, not initialize variable
d248 1
a248 1
    # auto-generate tcl/tk representation (variable name)
d250 1
a250 1
    # initialize TclTkObject
d252 1
a252 1
    # safe this for `set' command
d254 1
a254 1
    # set value
d258 2
a259 2
  # although you can set/refer variable by using set in tcl/tk,
  # we provide the method for accessing variables
d261 2
a262 2
  # set(data): set tcl/tk variable using `set'
  #   data: new value
d267 1
a267 1
  # get(): read tcl/tk variable(String) using `set'
d273 1
a273 1
# class TclTkWidget: tcl/tk widget
d276 2
a277 2
  # initialize(*args): 
  #   *args: parameters
d280 1
a280 1
      # in case the 1st argument is TclTkIp:
d282 2
a283 2
      # Wrap tcl/tk widget by TclTkWidget
      # (used in TclTkInterpreter#initialize())
d285 1
a285 1
      # need two arguments
d288 2
a289 2
      # ip: interpreter(TclTkIp)
      # exp: tcl/tk representation
d292 1
a292 1
      # initialize TclTkObject
d295 1
a295 1
      # in case 1st parameter is TclTkInterpreter:
d297 1
a297 1
      # generate new widget from parent widget
d299 4
a302 4
      # interp: interpreter(TclTkInterpreter)
      # parent: parent widget
      # command: widget generating tk command(label 等)
      # *args: argument to the command 
d305 1
a305 1
      # generate widget name
d309 1
a309 1
      # initialize TclTkObject
d311 1
a311 1
      # generate widget
d314 2
a315 1
      # for tk_optionMenu, it is legal res != exp
d322 1
a322 1
# class TclTkCallback: tcl/tk callbacks
d325 11
a335 10
  # initialize(interp, pr, arg): 
  #   interp: interpreter(TclTkInterpreter)
  #   pr: callback procedure(Proc)
  #   arg: string to pass as block parameters of pr
  #       bind command of tcl/tk uses % replacement for parameters
  #       pr can receive replaced data using block parameter
  #       its format is specified by arg string
  #       You should not specify arg for the command like 
  #       scrollbar with -command option, which receives parameters
  #       without specifying any replacement
d337 1
a337 1
    # auto-generate tcl/tk representation (variable name)
d339 1
a339 1
    # initialize TclTkObject
d341 1
a341 1
    # save parameters
d344 1
a344 1
    # register in the module
d348 1
a348 1
  # to_eval(): retuens string representation for @@ip._eval_args
d351 2
a352 1
      # bind replaces %s before calling ruby_fmt, so %%s is used
d361 2
a362 2
  # _call(arg): invoke callback
  #   arg: callback parameter
d368 1
a368 1
# class TclTkImage: tcl/tk images
d371 6
a376 6
  # initialize(interp, t, *args): 
  #     generating image is done by TclTkImage.new()
  #     destrying is done by image delete (inconsistent, sigh)
  #   interp: interpreter(TclTkInterpreter)
  #   t: image type (photo, bitmap, etc.)
  #   *args: command argument
d378 1
a378 1
    # auto-generate tcl/tk representation
d380 1
a380 1
    # initialize TclTkObject
d382 1
a382 1
    # generate image
@

