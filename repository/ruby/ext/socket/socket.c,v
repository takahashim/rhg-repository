head	1.87;
access;
symbols
	v1_6_7:1.35.2.10
	v1_6_6:1.35.2.10
	v1_6_5:1.35.2.6
	v1_6_4:1.35
	v1_7_1:1.42
	v1_6_4_preview4:1.35
	v1_6_4_preview3:1.35
	v1_6_4_preview2:1.35
	v1_6_4_preview1:1.35
	v1_6_3:1.35
	ruby_m17n:1.35.0.4
	ruby_1_6:1.35.0.2
	v1_6_2:1.35
	v1_6_1:1.31
	v1_6_0:1.31
	v1_4_6:1.6.2.14
	v1_4_5:1.6.2.11
	v1_4_4:1.6.2.7
	ruby_1_4_3:1.6.2.1
	ruby1_4_3:1.6
	v1_4_3:1.6
	v1_5_0:1.8
	ruby_1_4_3_pre1:1.6
	ruby_1_4:1.6.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.23
	v1_3_6_repack:1.1.1.3.2.22
	v1_3_6:1.1.1.3.2.22
	v1_3_5:1.1.1.3.2.21
	v1_2_6repack:1.1.1.2.2.19
	v1_3_4_990625:1.1.1.3.2.21
	v1_3_4_990624:1.1.1.3.2.21
	v1_2_6:1.1.1.2.2.19
	v1_3_4_990611:1.1.1.3.2.20
	v1_3_4_990531:1.1.1.3.2.17
	v1_3_3_990518:1.1.1.3.2.15
	v1_3_3_990513:1.1.1.3.2.15
	v1_3_3_990507:1.1.1.3.2.13
	v1_2_5:1.1.1.2.2.18
	v1_2_4:1.1.1.2.2.18
	v1_3_1_990225:1.1.1.3.2.2
	v1_3_1_990224:1.1.1.3.2.1
	v1_3_1_990215:1.1.1.3.2.1
	v1_3_1_990212:1.1.1.3.2.1
	v1_3_1_990210:1.1.1.3
	v1_3_1_:1.1.1.3
	v1_3_1_990209:1.1.1.3
	v1_3_1_990205:1.1.1.3
	v1_3_1_990203:1.1.1.3
	v1_3_1_990201:1.1.1.3
	v1_3_1"_990201:1.1.1.3
	v1_3_1_990128:1.1.1.3
	v1_3_1_990127:1.1.1.3
	v1_3_1_990126:1.1.1.3
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.18
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.18
	v1_2_1repack:1.1.1.2.2.18
	v1_2_1:1.1.1.2.2.18
	v1_2_stable:1.1.1.2.2.18
	v1_1d1:1.1.1.2.2.18.2.3
	v1_1d0:1.1.1.2.2.18.2.3
	v1_1c9_1:1.1.1.2.2.18
	v1_1c9:1.1.1.2.2.18
	v1_1c8:1.1.1.2.2.18
	v1_1c7:1.1.1.2.2.18
	v1_1c6:1.1.1.2.2.18
	v1_1d-start:1.1.1.2.2.18.2.1
	v1_1c5:1.1.1.2.2.18
	v1_1dev:1.1.1.2.2.18.0.2
	v1_1c4:1.1.1.2.2.18
	v1_1c3:1.1.1.2.2.17
	v1_1c2:1.1.1.2.2.17
	v1_1c1:1.1.1.2.2.17
	v1_1c0:1.1.1.2.2.17
	v1_1b9_31:1.1.1.2.2.17
	v1_1b9_30:1.1.1.2.2.17
	v1_1b9_28:1.1.1.2.2.16
	v1_1b9_27:1.1.1.2.2.14
	v1_1b9_26:1.1.1.2.2.14
	r1_1b9_25:1.1.1.2.2.13
	r1_1b9_24:1.1.1.2.2.13
	v1_1b9_23:1.1.1.2.2.12
	v1_1b9_22:1.1.1.2.2.12
	v1_1b9_20:1.1.1.2.2.11
	v1_1b9_18:1.1.1.2.2.9
	v1_1b9_16:1.1.1.2.2.8
	v1_1b9_15:1.1.1.2.2.8
	v1_1b9_13:1.1.1.2.2.8
	v1_1b9_12:1.1.1.2.2.8
	v1_1b9_11:1.1.1.2.2.8
	v1_1b9_08:1.1.1.2.2.6
	v1_1b9_07:1.1.1.2.2.6
	r1_1b9:1.1.1.2.2.2
	v1_1b8:1.1.1.2.2.2
	v1_1b7:1.1.1.2.2.2
	v1_1b6:1.1.1.2.2.1
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.87
date	2002.10.29.21.35.28;	author knu;	state Exp;
branches;
next	1.86;

1.86
date	2002.10.02.14.13.58;	author nobu;	state Exp;
branches;
next	1.85;

1.85
date	2002.10.01.15.26.39;	author nobu;	state Exp;
branches;
next	1.84;

1.84
date	2002.08.30.14.34.57;	author eban;	state Exp;
branches;
next	1.83;

1.83
date	2002.08.30.10.41.58;	author nobu;	state Exp;
branches;
next	1.82;

1.82
date	2002.08.01.09.42.38;	author matz;	state Exp;
branches;
next	1.81;

1.81
date	2002.07.26.06.17.44;	author matz;	state Exp;
branches;
next	1.80;

1.80
date	2002.06.11.07.01.17;	author matz;	state Exp;
branches;
next	1.79;

1.79
date	2002.06.04.07.34.17;	author matz;	state Exp;
branches;
next	1.78;

1.78
date	2002.06.03.15.50.01;	author nobu;	state Exp;
branches;
next	1.77;

1.77
date	2002.05.29.10.22.19;	author H_Konishi;	state Exp;
branches;
next	1.76;

1.76
date	2002.05.23.05.35.30;	author matz;	state Exp;
branches;
next	1.75;

1.75
date	2002.04.15.07.48.47;	author matz;	state Exp;
branches;
next	1.74;

1.74
date	2002.04.10.08.45.24;	author matz;	state Exp;
branches;
next	1.73;

1.73
date	2002.04.02.06.12.04;	author eban;	state Exp;
branches;
next	1.72;

1.72
date	2002.04.01.08.31.49;	author matz;	state Exp;
branches;
next	1.71;

1.71
date	2002.03.28.09.17.54;	author matz;	state Exp;
branches;
next	1.70;

1.70
date	2002.03.26.06.18.51;	author matz;	state Exp;
branches;
next	1.69;

1.69
date	2002.03.25.06.18.07;	author matz;	state Exp;
branches;
next	1.68;

1.68
date	2002.03.22.07.35.02;	author matz;	state Exp;
branches;
next	1.67;

1.67
date	2002.03.22.07.26.37;	author matz;	state Exp;
branches;
next	1.66;

1.66
date	2002.02.28.21.30.53;	author akr;	state Exp;
branches;
next	1.65;

1.65
date	2002.02.05.07.56.31;	author matz;	state Exp;
branches;
next	1.64;

1.64
date	2002.01.19.14.22.27;	author matz;	state Exp;
branches;
next	1.63;

1.63
date	2002.01.18.14.23.47;	author matz;	state Exp;
branches;
next	1.62;

1.62
date	2002.01.18.01.13.58;	author usa;	state Exp;
branches;
next	1.61;

1.61
date	2002.01.17.08.04.59;	author matz;	state Exp;
branches;
next	1.60;

1.60
date	2001.12.19.07.48.32;	author matz;	state Exp;
branches;
next	1.59;

1.59
date	2001.12.18.08.47.02;	author matz;	state Exp;
branches;
next	1.58;

1.58
date	2001.10.29.05.07.20;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2001.10.04.05.32.09;	author eban;	state Exp;
branches;
next	1.56;

1.56
date	2001.10.03.07.19.17;	author matz;	state Exp;
branches;
next	1.55;

1.55
date	2001.10.02.04.31.21;	author matz;	state Exp;
branches;
next	1.54;

1.54
date	2001.09.05.22.18.56;	author nobu;	state Exp;
branches;
next	1.53;

1.53
date	2001.09.05.06.54.55;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.16.04.54.31;	author usa;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.16.00.54.54;	author usa;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.06.06.10.10;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2001.08.06.03.05.19;	author matz;	state Exp;
branches;
next	1.48;

1.48
date	2001.07.31.08.02.57;	author nobu;	state Exp;
branches;
next	1.47;

1.47
date	2001.07.18.05.56.05;	author matz;	state Exp;
branches;
next	1.46;

1.46
date	2001.07.12.06.16.49;	author eban;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.22.15.48.59;	author eban;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.22.14.44.03;	author eban;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.22.09.12.22;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.06.15.03.48;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2001.03.21.03.41.43;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2001.02.16.07.53.21;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2001.02.15.06.00.58;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2001.02.13.05.09.06;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2001.02.08.09.19.21;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.18.08.43.10;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.17.04.41.19;	author matz;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2000.11.16.16.56.59;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.16.07.24.18;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2000.11.08.05.29.35;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.24.06.21.42;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.10.04.49.18;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.04.04.17.22;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.29.07.41.59;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.28.08.26.58;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.05.30.04.24.06;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.25.05.55.11;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.22.05.30.25;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.18.04.32.12;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.17.06.33.50;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.05.12.09.07.51;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.09.04.53.10;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.01.09.41.35;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.07.08.37.56;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.06.04.15.40;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.29.08.05.30;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.17.07.11.20;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.08.08.48.59;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.01.03.12.16;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.17.08.37.48;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.08.05.00.22;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.05.04.37.17;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	99.12.14.06.49.56;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.10.20.07.10.23;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.10.18.09.03.01;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.10.12.04.53.35;	author matz;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.10.04.04.51.08;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.09.22.04.30.10;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.09.20.07.14.18;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.37.50;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.16;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.33;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.02.12.11.17.06;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.25.06.39.12;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.03.24.08.52.34;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.04.09.17.57.43;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.04.13.05.18.12;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.04.16.06.03.35;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.04.20.08.21.41;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.04.30.06.19.20;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.04.30.07.55.47;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.04.30.08.20.00;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.04.30.15.16.44;	author matz;	state Exp;
branches;
next	1.1.1.3.2.12;

1.1.1.3.2.12
date	99.05.06.08.31.48;	author matz;	state Exp;
branches;
next	1.1.1.3.2.13;

1.1.1.3.2.13
date	99.05.07.08.24.36;	author matz;	state Exp;
branches;
next	1.1.1.3.2.14;

1.1.1.3.2.14
date	99.05.10.08.22.49;	author matz;	state Exp;
branches;
next	1.1.1.3.2.15;

1.1.1.3.2.15
date	99.05.11.01.34.33;	author matz;	state Exp;
branches;
next	1.1.1.3.2.16;

1.1.1.3.2.16
date	99.05.25.08.26.19;	author matz;	state Exp;
branches;
next	1.1.1.3.2.17;

1.1.1.3.2.17
date	99.05.31.09.13.31;	author matz;	state Exp;
branches;
next	1.1.1.3.2.18;

1.1.1.3.2.18
date	99.06.01.06.59.19;	author matz;	state Exp;
branches;
next	1.1.1.3.2.19;

1.1.1.3.2.19
date	99.06.09.09.21.35;	author matz;	state Exp;
branches;
next	1.1.1.3.2.20;

1.1.1.3.2.20
date	99.06.11.06.30.00;	author matz;	state Exp;
branches;
next	1.1.1.3.2.21;

1.1.1.3.2.21
date	99.06.24.04.24.06;	author matz;	state Exp;
branches;
next	1.1.1.3.2.22;

1.1.1.3.2.22
date	99.07.22.10.37.24;	author matz;	state Exp;
branches;
next	1.1.1.3.2.23;

1.1.1.3.2.23
date	99.08.06.06.48.22;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.36.01;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.29.03.22.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.03.28.10.57.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.03.30.09.32.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.03.30.09.41.17;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.04.02.10.03.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.04.14.04.55.52;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.04.16.10.20.23;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.05.01.08.56.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.05.13.05.58.09;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.05.13.07.26.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.05.18.09.12.27;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.06.02.10.05.37;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.06.16.04.24.33;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.06.24.04.38.07;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.06.26.09.44.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.07.03.07.06.39;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.09.03.07.43.47;	author matz;	state Exp;
branches
	1.1.1.2.2.18.2.1;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	99.04.20.08.20.56;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.18.2.1
date	98.09.08.07.09.39;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18.2.2;

1.1.1.2.2.18.2.2
date	98.10.06.03.28.24;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18.2.3;

1.1.1.2.2.18.2.3
date	98.11.25.03.31.18;	author matz;	state Exp;
branches;
next	;

1.6.2.1
date	99.12.07.16.47.18;	author matz;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.01.05.04.41.14;	author matz;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2000.01.24.03.46.10;	author matz;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2000.02.08.08.54.00;	author matz;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2000.02.17.08.29.06;	author matz;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2000.03.02.03.51.48;	author matz;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2000.03.08.06.25.19;	author matz;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2000.04.14.14.35.45;	author matz;	state Exp;
branches;
next	1.6.2.9;

1.6.2.9
date	2000.05.01.09.42.35;	author matz;	state Exp;
branches;
next	1.6.2.10;

1.6.2.10
date	2000.05.30.04.21.29;	author matz;	state Exp;
branches;
next	1.6.2.11;

1.6.2.11
date	2000.05.31.08.10.04;	author matz;	state Exp;
branches;
next	1.6.2.12;

1.6.2.12
date	2000.06.26.08.03.16;	author matz;	state Exp;
branches;
next	1.6.2.13;

1.6.2.13
date	2000.07.10.08.01.41;	author matz;	state Exp;
branches;
next	1.6.2.14;

1.6.2.14
date	2000.07.11.07.55.47;	author matz;	state Exp;
branches;
next	1.6.2.15;

1.6.2.15
date	2000.08.24.06.49.17;	author matz;	state Exp;
branches;
next	;

1.35.2.1
date	2001.06.22.08.15.56;	author matz;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2001.06.22.14.44.44;	author eban;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2001.06.22.15.49.08;	author eban;	state Exp;
branches;
next	1.35.2.4;

1.35.2.4
date	2001.07.12.06.15.23;	author eban;	state Exp;
branches;
next	1.35.2.5;

1.35.2.5
date	2001.09.05.06.53.29;	author matz;	state Exp;
branches;
next	1.35.2.6;

1.35.2.6
date	2001.09.06.09.32.10;	author matz;	state Exp;
branches;
next	1.35.2.7;

1.35.2.7
date	2001.10.02.04.24.26;	author matz;	state Exp;
branches;
next	1.35.2.8;

1.35.2.8
date	2001.10.04.05.30.32;	author eban;	state Exp;
branches;
next	1.35.2.9;

1.35.2.9
date	2001.10.29.05.04.43;	author matz;	state Exp;
branches;
next	1.35.2.10;

1.35.2.10
date	2001.12.19.07.45.30;	author matz;	state Exp;
branches;
next	1.35.2.11;

1.35.2.11
date	2002.03.25.06.16.02;	author matz;	state Exp;
branches;
next	1.35.2.12;

1.35.2.12
date	2002.06.03.15.52.16;	author nobu;	state Exp;
branches;
next	1.35.2.13;

1.35.2.13
date	2002.06.04.04.47.04;	author nobu;	state Exp;
branches;
next	1.35.2.14;

1.35.2.14
date	2002.06.04.07.11.54;	author matz;	state Exp;
branches;
next	1.35.2.15;

1.35.2.15
date	2002.06.11.06.58.39;	author matz;	state Exp;
branches;
next	1.35.2.16;

1.35.2.16
date	2002.08.01.16.22.39;	author matz;	state Exp;
branches;
next	1.35.2.17;

1.35.2.17
date	2002.10.01.15.25.49;	author nobu;	state Exp;
branches;
next	1.35.2.18;

1.35.2.18
date	2002.10.26.15.57.26;	author knu;	state Exp;
branches;
next	;


desc
@@


1.87
log
@* eval.c, file.c, gc.c, io.c, object.c, ruby.c, ruby.h, struct.c,
  ext/socket/socket.c: differentiate long and int; use proper
  printf type specifiers and do casts where appropriate.
@
text
@/************************************************

  socket.c -

  $Author: nobu $
  $Date: 2002/10/02 14:13:58 $
  created at: Thu Mar 31 12:21:29 JST 1994

  Copyright (C) 1993-2001 Yukihiro Matsumoto

************************************************/

#include "ruby.h"
#include "rubyio.h"
#include "rubysig.h"
#include <stdio.h>
#include <sys/types.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef HAVE_SYS_UIO_H
#include <sys/uio.h>
#endif

#ifndef NT
#if defined(__BEOS__)
# include <net/socket.h>
#else
# include <sys/socket.h>
#endif
#include <netinet/in.h>
#ifdef HAVE_NETINET_TCP_H
# include <netinet/tcp.h>
#endif
#ifdef HAVE_NETINET_UDP_H
# include <netinet/udp.h>
#endif
#include <netdb.h>
#endif
#include <errno.h>
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#if defined(HAVE_FCNTL)
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
#include <sys/types.h>
#include <sys/time.h>
#include <fcntl.h>
#endif
#ifndef EWOULDBLOCK
#define EWOULDBLOCK EAGAIN
#endif
#ifndef HAVE_GETADDRINFO
# include "addrinfo.h"
#endif
#include "sockport.h"

static int do_not_reverse_lookup = 0;

VALUE rb_cBasicSocket;
VALUE rb_cIPSocket;
VALUE rb_cTCPSocket;
VALUE rb_cTCPServer;
VALUE rb_cUDPSocket;
#ifdef AF_UNIX
VALUE rb_cUNIXSocket;
VALUE rb_cUNIXServer;
#endif
VALUE rb_cSocket;

static VALUE rb_eSocket;

#ifdef SOCKS
VALUE rb_cSOCKSSocket;
#ifdef SOCKS5
#include <socks.h>
#else
void SOCKSinit();
int Rconnect();
#endif
#endif

#define INET_CLIENT 0
#define INET_SERVER 1
#define INET_SOCKS  2

#ifndef HAVE_SOCKADDR_STORAGE
/*
 * RFC 2553: protocol-independent placeholder for socket addresses
 */
#define _SS_MAXSIZE	128
#define _SS_ALIGNSIZE	(sizeof(double))
#define _SS_PAD1SIZE	(_SS_ALIGNSIZE - sizeof(unsigned char) * 2)
#define _SS_PAD2SIZE	(_SS_MAXSIZE - sizeof(unsigned char) * 2 - \
				_SS_PAD1SIZE - _SS_ALIGNSIZE)

struct sockaddr_storage {
#ifdef HAVE_SA_LEN
	unsigned char ss_len;		/* address length */
	unsigned char ss_family;	/* address family */
#else
	unsigned short ss_family;
#endif
	char	__ss_pad1[_SS_PAD1SIZE];
	double	__ss_align;	/* force desired structure storage alignment */
	char	__ss_pad2[_SS_PAD2SIZE];
};
#endif

#if defined(INET6) && (defined(LOOKUP_ORDER_HACK_INET) || defined(LOOKUP_ORDER_HACK_INET6))
#define LOOKUP_ORDERS		3
static int lookup_order_table[LOOKUP_ORDERS] = {
#if defined(LOOKUP_ORDER_HACK_INET)
    PF_INET, PF_INET6, PF_UNSPEC,
#elif defined(LOOKUP_ORDER_HACK_INET6)
    PF_INET6, PF_INET, PF_UNSPEC,
#else
    /* should not happen */
#endif
};

static int
ruby_getaddrinfo(nodename, servname, hints, res)
     char *nodename;
     char *servname;
     struct addrinfo *hints;
     struct addrinfo **res;
{
    struct addrinfo tmp_hints;
    int i, af, error;

    if (hints->ai_family != PF_UNSPEC) {
	return getaddrinfo(nodename, servname, hints, res);
    }

    for (i = 0; i < LOOKUP_ORDERS; i++) {
	af = lookup_order_table[i];
	MEMCPY(&tmp_hints, hints, struct addrinfo, 1);
	tmp_hints.ai_family = af;
	error = getaddrinfo(nodename, servname, &tmp_hints, res);
	if (error) {
	    if (tmp_hints.ai_family == PF_UNSPEC) {
		break;
	    }
	}
	else {
	    break;
	}
    }

    return error;
}
#define getaddrinfo(node,serv,hints,res) ruby_getaddrinfo((node),(serv),(hints),(res))
#endif

#ifdef HAVE_CLOSESOCKET
#undef close
#define close closesocket
#endif

static VALUE
init_sock(sock, fd)
    VALUE sock;
    int fd;
{
    OpenFile *fp;

    MakeOpenFile(sock, fp);
    fp->f = rb_fdopen(fd, "r");
    fp->f2 = rb_fdopen(fd, "w");
    fp->mode = FMODE_READWRITE;
    rb_io_synchronized(fp);

    return sock;
}

static VALUE
bsock_s_for_fd(klass, fd)
    VALUE klass, fd;
{
    OpenFile *fptr;
    VALUE sock = init_sock(rb_obj_alloc(klass), NUM2INT(fd));

    GetOpenFile(sock, fptr);

    return sock;
}

static VALUE
bsock_shutdown(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    VALUE howto;
    int how;
    OpenFile *fptr;

    if (rb_safe_level() >= 4 && !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, "Insecure: can't shutdown socket");
    }
    rb_scan_args(argc, argv, "01", &howto);
    if (howto == Qnil)
	how = 2;
    else {
	how = NUM2INT(howto);
	if (how < 0 || 2 < how) {
	    rb_raise(rb_eArgError, "`how' should be either 0, 1, 2");
	}
    }
    GetOpenFile(sock, fptr);
    if (shutdown(fileno(fptr->f), how) == -1)
	rb_sys_fail(0);

    return INT2FIX(0);
}

static VALUE
bsock_close_read(sock)
    VALUE sock;
{
    OpenFile *fptr;

    if (rb_safe_level() >= 4 && !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, "Insecure: can't close socket");
    }
    GetOpenFile(sock, fptr);
    shutdown(fileno(fptr->f), 0);
    if (!(fptr->mode & FMODE_WRITABLE)) {
	return rb_io_close(sock);
    }
    fptr->mode &= ~FMODE_READABLE;

    return Qnil;
}

static VALUE
bsock_close_write(sock)
    VALUE sock;
{
    OpenFile *fptr;

    if (rb_safe_level() >= 4 && !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, "Insecure: can't close socket");
    }
    GetOpenFile(sock, fptr);
    if (!(fptr->mode & FMODE_READABLE)) {
	return rb_io_close(sock);
    }
    shutdown(fileno(fptr->f2), 1);
    fptr->mode &= ~FMODE_WRITABLE;

    return Qnil;
}

static VALUE
bsock_setsockopt(sock, lev, optname, val)
    VALUE sock, lev, optname, val;
{
    int level, option;
    OpenFile *fptr;
    int i;
    char *v;
    int vlen;

    rb_secure(2);
    level = NUM2INT(lev);
    option = NUM2INT(optname);
    switch (TYPE(val)) {
      case T_FIXNUM:
	i = FIX2INT(val);
	goto numval;
      case T_FALSE:
	i = 0;
	goto numval;
      case T_TRUE:
	i = 1;
      numval:
	v = (char*)&i; vlen = sizeof(i);
	break;
      default:
	StringValue(val);
	v = RSTRING(val)->ptr;
	vlen = RSTRING(val)->len;
	break;
    }

    GetOpenFile(sock, fptr);
    if (setsockopt(fileno(fptr->f), level, option, v, vlen) < 0)
	rb_sys_fail(fptr->path);

    return INT2FIX(0);
}

static VALUE
bsock_getsockopt(sock, lev, optname)
    VALUE sock, lev, optname;
{
#if !defined(__BEOS__)
    int level, option;
    socklen_t len;
    char *buf;
    OpenFile *fptr;

    level = NUM2INT(lev);
    option = NUM2INT(optname);
    len = 256;
    buf = ALLOCA_N(char,len);

    GetOpenFile(sock, fptr);
    if (getsockopt(fileno(fptr->f), level, option, buf, &len) < 0)
	rb_sys_fail(fptr->path);

    return rb_str_new(buf, len);
#else
    rb_notimplement();
#endif
}

static VALUE
bsock_getsockname(sock)
   VALUE sock;
{
    char buf[1024];
    socklen_t len = sizeof buf;
    OpenFile *fptr;

    GetOpenFile(sock, fptr);
    if (getsockname(fileno(fptr->f), (struct sockaddr*)buf, &len) < 0)
	rb_sys_fail("getsockname(2)");
    return rb_str_new(buf, len);
}

static VALUE
bsock_getpeername(sock)
   VALUE sock;
{
    char buf[1024];
    socklen_t len = sizeof buf;
    OpenFile *fptr;

    GetOpenFile(sock, fptr);
    if (getpeername(fileno(fptr->f), (struct sockaddr*)buf, &len) < 0)
	rb_sys_fail("getpeername(2)");
    return rb_str_new(buf, len);
}

static VALUE
bsock_send(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    VALUE mesg, to;
    VALUE flags;
    OpenFile *fptr;
    FILE *f;
    int fd, n;

    rb_secure(4);
    rb_scan_args(argc, argv, "21", &mesg, &flags, &to);

    GetOpenFile(sock, fptr);
    f = GetWriteFile(fptr);
    fd = fileno(f);
    rb_thread_fd_writable(fd);
    StringValue(mesg);
  retry:
    if (!NIL_P(to)) {
	StringValue(to);
	n = sendto(fd, RSTRING(mesg)->ptr, RSTRING(mesg)->len, NUM2INT(flags),
		   (struct sockaddr*)RSTRING(to)->ptr, RSTRING(to)->len);
    }
    else {
	n = send(fd, RSTRING(mesg)->ptr, RSTRING(mesg)->len, NUM2INT(flags));
    }
    if (n < 0) {
	if (rb_io_wait_writable(fd)) {
	    goto retry;
	}
	rb_sys_fail("send(2)");
    }
    return INT2FIX(n);
}

static VALUE ipaddr _((struct sockaddr*));
#ifdef HAVE_SYS_UN_H
static VALUE unixaddr _((struct sockaddr_un*));
#endif

enum sock_recv_type {
    RECV_RECV,			/* BasicSocket#recv(no from) */
    RECV_IP,			/* IPSocket#recvfrom */
    RECV_UNIX,			/* UNIXSocket#recvfrom */
    RECV_SOCKET			/* Socket#recvfrom */
};

static VALUE
s_recvfrom(sock, argc, argv, from)
    VALUE sock;
    int argc;
    VALUE *argv;
    enum sock_recv_type from;
{
    OpenFile *fptr;
    VALUE str;
    char buf[1024];
    socklen_t alen = sizeof buf;
    VALUE len, flg;
    long slen;
    int fd, flags;

    rb_scan_args(argc, argv, "11", &len, &flg);

    if (flg == Qnil) flags = 0;
    else             flags = NUM2INT(flg);

    GetOpenFile(sock, fptr);
    if (rb_read_pending(fptr->f)) {
	rb_raise(rb_eIOError, "recv for buffered IO");
    }
    fd = fileno(fptr->f);

    slen = NUM2INT(len);
    str = rb_tainted_str_new(0, slen);

  retry:
    rb_thread_wait_fd(fd);
    TRAP_BEG;
    slen = recvfrom(fd, RSTRING(str)->ptr, slen, flags, (struct sockaddr*)buf, &alen);
    TRAP_END;

    if (slen < 0) {
	if (rb_io_wait_readable(fd)) {
	    goto retry;
	}
	rb_sys_fail("recvfrom(2)");
    }
    if (slen < RSTRING(str)->len) {
	RSTRING(str)->len = slen;
	RSTRING(str)->ptr[slen] = '\0';
    }
    rb_obj_taint(str);
    switch (from) {
      case RECV_RECV:
	return (VALUE)str;
      case RECV_IP:
#if 0
	if (alen != sizeof(struct sockaddr_in)) {
	    rb_raise(rb_eTypeError, "sockaddr size differs - should not happen");
	}
#endif
	return rb_assoc_new(str, ipaddr((struct sockaddr*)buf));
#ifdef HAVE_SYS_UN_H
      case RECV_UNIX:
	return rb_assoc_new(str, unixaddr((struct sockaddr_un*)buf));
#endif
      case RECV_SOCKET:
	return rb_assoc_new(str, rb_str_new(buf, alen));
      default:
	rb_bug("s_recvfrom called with bad value");
    }
}

static VALUE
bsock_recv(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom(sock, argc, argv, RECV_RECV);
}

static VALUE
bsock_do_not_rev_lookup()
{
    return do_not_reverse_lookup?Qtrue:Qfalse;
}

static VALUE
bsock_do_not_rev_lookup_set(self, val)
{
    rb_secure(4);
    do_not_reverse_lookup = RTEST(val);
    return val;
}

static void
mkipaddr0(addr, buf, len)
    struct sockaddr *addr;
    char *buf;
    size_t len;
{
    int error;

    error = getnameinfo(addr, SA_LEN(addr), buf, len, NULL, 0, NI_NUMERICHOST);
    if (error) {
	rb_raise(rb_eSocket, "getnameinfo: %s", gai_strerror(error));
    }
}

static VALUE
mkipaddr(addr)
    struct sockaddr *addr;
{
    char buf[1024];

    mkipaddr0(addr, buf, sizeof(buf));
    return rb_str_new2(buf);
}

static void
mkinetaddr(host, buf, len)
    long host;
    char *buf;
    size_t len;
{
    struct sockaddr_in sin;

    MEMZERO(&sin, struct sockaddr_in, 1);
    sin.sin_family = AF_INET;
    SET_SIN_LEN(&sin, sizeof(sin));
    sin.sin_addr.s_addr = host;
    mkipaddr0((struct sockaddr*)&sin, buf, len);
}

static int
str_isnumber(p)
        const char *p;
{
    char *ep;

    if (!p || *p == '\0')
       return 0;
    ep = NULL;
    (void)strtoul(p, &ep, 10);
    if (ep && *ep == '\0')
       return 1;
    else
       return 0;
}

static struct addrinfo*
sock_addrinfo(host, port, socktype, flags)
    VALUE host, port;
    int socktype, flags;
{
    struct addrinfo hints, *hintsp, *res;
    char *hostp, *portp;
    int error;
    char hbuf[1024], pbuf[16];

    if (NIL_P(host)) {
	hostp = NULL;
    }
    else if (rb_obj_is_kind_of(host, rb_cInteger)) {
	long i = NUM2LONG(host);

	mkinetaddr(htonl(i), hbuf, sizeof(hbuf));
	hostp = hbuf;
    }
    else {
	char *name;

	SafeStringValue(host);
	name = RSTRING(host)->ptr;
	if (*name == 0 || (name[0] == '<' && strcmp(name, "<any>") == 0)) {
	    mkinetaddr(INADDR_ANY, hbuf, sizeof(hbuf));
	}
	else if (name[0] == '<' && strcmp(name, "<broadcast>") == 0) {
	    mkinetaddr(INADDR_BROADCAST, hbuf, sizeof(hbuf));
	}
	else if (strlen(name) >= sizeof(hbuf)) {
	    rb_raise(rb_eArgError, "hostname too long (%d)", strlen(name));
	}
	else {
	    strcpy(hbuf, name);
	}
	hostp = hbuf;
    }
    if (NIL_P(port)) {
	portp = 0;
    }
    else if (FIXNUM_P(port)) {
	snprintf(pbuf, sizeof(pbuf), "%d", FIX2INT(port));
	portp = pbuf;
    }
    else {
	SafeStringValue(port);
	portp = RSTRING(port)->ptr;
    }

    if (socktype == 0 && flags == 0 && str_isnumber(portp)) {
       socktype = SOCK_DGRAM;
    }

    hintsp = &hints;
    MEMZERO(&hints, struct addrinfo, 1);
    hints.ai_family = PF_UNSPEC;
    hints.ai_protocol = 0;
    hints.ai_socktype = socktype;
    hints.ai_flags = flags;
    error = getaddrinfo(hostp, portp, hintsp, &res);
    if (error) {
	if (hostp && hostp[strlen(hostp)-1] == '\n') {
	    rb_raise(rb_eSocket, "newline at the end of hostname");
	}
	rb_raise(rb_eSocket, "getaddrinfo: %s", gai_strerror(error));
    }

    return res;
}

static void
setipaddr(name, addr)
    VALUE name;
    struct sockaddr_storage *addr;
{
    struct addrinfo *res = sock_addrinfo(name, Qnil, SOCK_STREAM, 0);

    /* just take the first one */
    memcpy(addr, res->ai_addr, res->ai_addrlen);
    freeaddrinfo(res);
}

static VALUE
ipaddr(sockaddr)
    struct sockaddr *sockaddr;
{
    VALUE family, port, addr1, addr2;
    VALUE ary;
    int error;
    char hbuf[1024], pbuf[1024];

    switch (sockaddr->sa_family) {
    case AF_UNSPEC:
	family = rb_str_new2("AF_UNSPEC");
	break;
    case AF_INET:
	family = rb_str_new2("AF_INET");
	break;
#ifdef INET6
    case AF_INET6:
	family = rb_str_new2("AF_INET6");
	break;
#endif
#ifdef AF_LOCAL
    case AF_LOCAL:
	family = rb_str_new2("AF_LOCAL");
	break;
#elif  AF_UNIX
    case AF_UNIX:
	family = rb_str_new2("AF_UNIX");
	break;
#endif
    default:
        sprintf(pbuf, "unknown:%d", sockaddr->sa_family);
	family = rb_str_new2(pbuf);
	break;
    }
    if (!do_not_reverse_lookup) {
	error = getnameinfo(sockaddr, SA_LEN(sockaddr), hbuf, sizeof(hbuf),
			    NULL, 0, 0);
	if (error) {
	    rb_raise(rb_eSocket, "getnameinfo: %s", gai_strerror(error));
	}
	addr1 = rb_str_new2(hbuf);
    }
    error = getnameinfo(sockaddr, SA_LEN(sockaddr), hbuf, sizeof(hbuf),
			pbuf, sizeof(pbuf), NI_NUMERICHOST | NI_NUMERICSERV);
    if (error) {
	rb_raise(rb_eSocket, "getnameinfo: %s", gai_strerror(error));
    }
    addr2 = rb_str_new2(hbuf);
    if (do_not_reverse_lookup) {
	addr1 = addr2;
    }
    port = INT2FIX(atoi(pbuf));
    ary = rb_ary_new3(4, family, port, addr1, addr2);

    return ary;
}

static int
ruby_socket(domain, type, proto)
    int domain, type, proto;
{
    int fd;

    fd = socket(domain, type, proto);
    if (fd < 0) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    fd = socket(domain, type, proto);
	}
    }
    return fd;
}

static void
thread_read_select(fd)
    int fd;
{
    fd_set fds;

    FD_ZERO(&fds);
    FD_SET(fd, &fds);
    rb_thread_select(fd+1, &fds, 0, 0, 0);
}

static void
thread_write_select(fd)
    int fd;
{
    fd_set fds;

    FD_ZERO(&fds);
    FD_SET(fd, &fds);
    rb_thread_select(fd+1, 0, &fds, 0, 0);
}

static int
ruby_connect(fd, sockaddr, len, socks)
    int fd;
    struct sockaddr *sockaddr;
    int len;
    int socks;
{
    int status;
    int mode;
#if defined __CYGWIN__
    int wait_in_progress = -1;
#endif

#if defined(HAVE_FCNTL)
    mode = fcntl(fd, F_GETFL, 0);

#ifdef O_NDELAY
# define NONBLOCKING O_NDELAY
#else
#ifdef O_NBIO
# define NONBLOCKING O_NBIO
#else
# define NONBLOCKING O_NONBLOCK
#endif
#endif
#ifdef SOCKS5
    if (!socks)
#endif
    fcntl(fd, F_SETFL, mode|NONBLOCKING);
#endif /* HAVE_FCNTL */

    for (;;) {
#if defined(SOCKS) && !defined(SOCKS5)
	if (socks) {
	    status = Rconnect(fd, sockaddr, len);
	}
	else
#endif
	{
	    status = connect(fd, sockaddr, len);
	}
	if (status < 0) {
	    switch (errno) {
	      case EAGAIN:
#ifdef EINPROGRESS
	      case EINPROGRESS:
#ifdef __CYGWIN__
	      case EALREADY:
		wait_in_progress = 10;
#endif
#endif
		thread_write_select(fd);
		continue;

#if defined __CYGWIN__
	      case EINVAL:
		if (wait_in_progress-- > 0) {
		    struct timeval tv = {0, 100000};
		    rb_thread_wait_for(tv);
		    continue;
		}
		break;
#endif

#ifdef EISCONN
	      case EISCONN:
		status = 0;
		errno = 0;
		break;
#endif
	      default:
		break;
	    }
	}
#ifdef HAVE_FCNTL
	fcntl(fd, F_SETFL, mode);
#endif
	return status;
    }
}

static void
load_addr_info(h, serv, type, res)
    VALUE h, serv;
    int type;
    struct addrinfo **res;
{
    char *host;
    char pbuf[1024], *portp;
    struct addrinfo hints;
    int error;

    if (!NIL_P(h)) {
	SafeStringValue(h);
	host = RSTRING(h)->ptr;
    }
    else {
	host = NULL;
    }
    if (FIXNUM_P(serv)) {
	snprintf(pbuf, sizeof(pbuf), "%u", FIX2UINT(serv));
	portp = pbuf;
    }
    else {
	SafeStringValue(serv);
	if (RSTRING(serv)->len >= sizeof(pbuf))
	    rb_raise(rb_eArgError, "servicename too long (%ld)", RSTRING(serv)->len);
	strcpy(pbuf, RSTRING(serv)->ptr);
	portp = pbuf;
    }
    MEMZERO(&hints, struct addrinfo, 1);
    hints.ai_family = PF_UNSPEC;
    if (type == INET_SERVER) {
	hints.ai_flags = AI_PASSIVE;
    }
    error = getaddrinfo(host, portp, &hints, res);
    if (error) {
	rb_raise(rb_eSocket, "getaddrinfo: %s", gai_strerror(error));
    }
}

struct inetsock_arg
{
    VALUE sock;
    struct {
	VALUE host, serv;
	struct addrinfo *res;
    } remote, local;
    int type;
    int fd;
};

static VALUE
inetsock_cleanup(arg)
    struct inetsock_arg *arg;
{
    if (arg->remote.res) {
	freeaddrinfo(arg->remote.res);
	arg->remote.res = 0;
    }
    if (arg->local.res) {
	freeaddrinfo(arg->local.res);
	arg->local.res = 0;
    }
    if (arg->fd >= 0) {
	close(arg->fd);
    }
    return Qnil;
}

static VALUE
init_inetsock_internal(arg)
    struct inetsock_arg *arg;
{
    int type = arg->type;
    struct addrinfo hints, *res;
    int fd, status;
    char *syscall;

    arg->remote.res = sock_addrinfo(arg->remote.host, arg->remote.serv, SOCK_STREAM,
				    (type == INET_SERVER) ? AI_PASSIVE : 0);
    /*
     * Maybe also accept a local address
     */

    if (type != INET_SERVER && (!NIL_P(arg->local.host) || !NIL_P(arg->local.serv))) {
	arg->local.res = sock_addrinfo(arg->local.host, arg->local.serv, SOCK_STREAM, 0);
    }

    arg->fd = fd = -1;
    for (res = arg->remote.res; res; res = res->ai_next) {
	status = ruby_socket(res->ai_family,res->ai_socktype,res->ai_protocol);
	syscall = "socket(2)";
	fd = status;
	if (fd < 0) {
	    continue;
	}
	arg->fd = fd;
	if (type == INET_SERVER) {
#ifndef NT
	    status = 1;
	    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,
		       (char*)&status, sizeof(status));
#endif
	    status = bind(fd, res->ai_addr, res->ai_addrlen);
	    syscall = "bind(2)";
	}
	else {
	    if (arg->local.res) {
		status = bind(fd, arg->local.res->ai_addr, arg->local.res->ai_addrlen);
		syscall = "bind(2)";
	    }

	    if (status >= 0) {
		status = ruby_connect(fd, res->ai_addr, res->ai_addrlen,
				      (type == INET_SOCKS));
		syscall = "connect(2)";
	    }
	}

	if (status < 0) {
	    close(fd);
	    arg->fd = fd = -1;
	    continue;
	} else
	    break;
    }
    if (status < 0) {
	rb_sys_fail(syscall);
    }

    arg->fd = -1;

    if (type == INET_SERVER)
	listen(fd, 5);

    /* create new instance */
    return init_sock(arg->sock, fd);
}

static VALUE
init_inetsock(sock, remote_host, remote_serv, local_host, local_serv, type)
    VALUE sock, remote_host, remote_serv, local_host, local_serv;
    int type;
{
    struct inetsock_arg arg;
    arg.sock = sock;
    arg.remote.host = remote_host;
    arg.remote.serv = remote_serv;
    arg.remote.res = 0;
    arg.local.host = local_host;
    arg.local.serv = local_serv;
    arg.local.res = 0;
    arg.type = type;
    arg.fd = -1;
    return rb_ensure(init_inetsock_internal, (VALUE)&arg,
		     inetsock_cleanup, (VALUE)&arg);
}

static VALUE
tcp_init(argc, argv, sock)
     int argc;
     VALUE *argv;
     VALUE sock;
{
    VALUE remote_host, remote_serv;
    VALUE local_host, local_serv;

    int pcount = rb_scan_args(argc, argv, "22",
			      &remote_host, &remote_serv,
			      &local_host, &local_serv);

    return init_inetsock(sock, remote_host, remote_serv,
			 local_host, local_serv, INET_CLIENT);
}

#ifdef SOCKS
static VALUE
socks_init(sock, host, serv)
    VALUE sock, host, serv;
{
    static init = 0;

    if (init == 0) {
	SOCKSinit("ruby");
	init = 1;
    }

    return init_inetsock(class, host, serv, Qnil, Qnil, INET_SOCKS);
}

#ifdef SOCKS5
static VALUE
socks_s_close(sock)
    VALUE sock;
{
    OpenFile *fptr;

    if (rb_safe_level() >= 4 && !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, "Insecure: can't close socket");
    }
    GetOpenFile(sock, fptr);
    shutdown(fileno(fptr->f), 2);
    shutdown(fileno(fptr->f2), 2);
    return rb_io_close(sock);
}
#endif
#endif

/*
 * NOTE: using gethostbyname() against AF_INET6 is a bad idea, as it
 * does not initialize sin_flowinfo nor sin_scope_id properly.
 */

struct hostent*
sock_hostbyname(host)
    VALUE host;
{
    struct sockaddr_storage addr;
    struct hostent *h;

    rb_secure(3);
    setipaddr(host, &addr);
    switch (addr.ss_family) {
      case AF_INET:
      {
	struct sockaddr_in *sin;
	sin = (struct sockaddr_in*)&addr;
	h = gethostbyaddr((char*)&sin->sin_addr,
			  sizeof(sin->sin_addr),
			  sin->sin_family);
	break;
      }
#ifdef INET6
      case AF_INET6:
      {
	struct sockaddr_in6 *sin6;
	sin6 = (struct sockaddr_in6*)&addr;
	h = gethostbyaddr((char*)&sin6->sin6_addr,
			  sizeof(sin6->sin6_addr),
			  sin6->sin6_family);
	break;
      }
#endif
      default:
	h = NULL;
	break;
    }

    if (h == NULL) {
#ifdef HAVE_HSTERROR
	extern int h_errno;
	rb_raise(rb_eSocket, "%s", (char*)hsterror(h_errno));
#else
	rb_raise(rb_eSocket, "host not found");
#endif
    }
    return h;
}

static VALUE
tcp_s_gethostbyname(obj, host)
    VALUE obj, host;
{
    struct hostent *h = sock_hostbyname(host);
    VALUE ary, names;
    char **pch;
    size_t size;

    ary = rb_ary_new();
    rb_ary_push(ary, rb_str_new2(h->h_name));
    names = rb_ary_new();
    rb_ary_push(ary, names);
    for (pch = h->h_aliases; *pch; pch++) {
	rb_ary_push(names, rb_str_new2(*pch));
    }
    rb_ary_push(ary, INT2NUM(h->h_addrtype));
#ifdef h_addr
    for (pch = h->h_addr_list; *pch; pch++) {
	switch (h->h_length) {
	  case 4: /* AF_INET */ {
	    struct sockaddr_in sin;

	    MEMZERO(&sin, struct sockaddr_in, 1);
	    sin.sin_family = AF_INET;
	    SET_SIN_LEN(&sin, sizeof(sin));
	    memcpy((char*)&sin.sin_addr, *pch, h->h_length);
	    rb_ary_push(ary, mkipaddr((struct sockaddr*)&sin));
	    break;
	  }
#ifdef INET6
	  case 8: /* AF_INET6 */ {
	    struct sockaddr_in6 sin6;

	    MEMZERO(&sin6, struct sockaddr_in6, 1);
	    sin6.sin6_family = AF_INET6;
#ifdef SIN6_LEN
	    sin6.sin6_len = sizeof(sin6);
#endif
	    memcpy((char*)&sin6.sin6_addr, *pch, size);
	    rb_ary_push(ary, mkipaddr((struct sockaddr*)&sin6));
	    break;
	  }
#endif
	  default:
	    break;
	}
    }
#else
    memcpy((char*)&addr.sin_addr, h->h_addr, h->h_length);
    rb_ary_push(ary, mkipaddr((struct sockaddr*)&addr));
#endif

    return ary;
}

static VALUE
tcp_svr_init(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    VALUE arg1, arg2;

    if (rb_scan_args(argc, argv, "11", &arg1, &arg2) == 2)
	return init_inetsock(sock, arg1, arg2, NULL, Qnil, INET_SERVER);
    else
	return init_inetsock(sock, Qnil, arg1, NULL, Qnil, INET_SERVER);
}

static VALUE
s_accept(klass, fd, sockaddr, len)
    VALUE klass;
    int fd;
    struct sockaddr *sockaddr;
    socklen_t *len;
{
    int fd2;
    int retry = 0;

    rb_secure(3);
  retry:
    rb_thread_wait_fd(fd);
#if defined(_nec_ews)
    fd2 = accept(fd, sockaddr, len);
#else
    TRAP_BEG;
    fd2 = accept(fd, sockaddr, len);
    TRAP_END;
#endif
    if (fd2 < 0) {
	switch (errno) {
	  case EMFILE:
	  case ENFILE:
	    if (retry) break;
	    rb_gc();
	    retry = 1;
	    goto retry;
	  default:
	    if (!rb_io_wait_readable(fd)) break;
	    retry = 0;
	    goto retry;
	}
	rb_sys_fail(0);
    }
    if (!klass) return INT2NUM(fd2);
    return init_sock(rb_obj_alloc(klass), fd2);
}

static VALUE
tcp_accept(sock)
    VALUE sock;
{
    OpenFile *fptr;
    struct sockaddr_storage from;
    socklen_t fromlen;

    GetOpenFile(sock, fptr);
    fromlen = sizeof(from);
    return s_accept(rb_cTCPSocket, fileno(fptr->f),
		    (struct sockaddr*)&from, &fromlen);
}

static VALUE
tcp_sysaccept(sock)
    VALUE sock;
{
    OpenFile *fptr;
    struct sockaddr_storage from;
    socklen_t fromlen;

    GetOpenFile(sock, fptr);
    fromlen = sizeof(from);
    return s_accept(0, fileno(fptr->f), (struct sockaddr*)&from, &fromlen);
}

#ifdef HAVE_SYS_UN_H
struct unixsock_arg {
    struct sockaddr_un *sockaddr;
    int fd;
};

static VALUE
unixsock_connect_internal(arg)
    struct unixsock_arg *arg;
{
    return (VALUE)ruby_connect(arg->fd, arg->sockaddr, sizeof(*arg->sockaddr),
			       0);
}

static VALUE
init_unixsock(sock, path, server)
    VALUE sock;
    VALUE path;
    int server;
{
    struct sockaddr_un sockaddr;
    int fd, status;
    OpenFile *fptr;

    SafeStringValue(path);
    fd = ruby_socket(AF_UNIX, SOCK_STREAM, 0);
    if (fd < 0) {
	rb_sys_fail("socket(2)");
    }

    MEMZERO(&sockaddr, struct sockaddr_un, 1);
    sockaddr.sun_family = AF_UNIX;
    strncpy(sockaddr.sun_path, RSTRING(path)->ptr, sizeof(sockaddr.sun_path)-1);
    sockaddr.sun_path[sizeof(sockaddr.sun_path)-1] = '\0';

    if (server) {
        status = bind(fd, (struct sockaddr*)&sockaddr, sizeof(sockaddr));
    }
    else {
	int prot;
	struct unixsock_arg arg;
	arg.sockaddr = &sockaddr;
	arg.fd = fd;
        status = rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);
	if (prot) {
	    close(fd);
	    rb_jump_tag(prot);
	}
    }

    if (status < 0) {
	close(fd);
	rb_sys_fail(sockaddr.sun_path);
    }

    if (server) listen(fd, 5);

    init_sock(sock, fd);
    GetOpenFile(sock, fptr);
    fptr->path = strdup(RSTRING(path)->ptr);

    return sock;
}
#endif

static VALUE
ip_addr(sock)
    VALUE sock;
{
    OpenFile *fptr;
    struct sockaddr_storage addr;
    socklen_t len = sizeof addr;

    GetOpenFile(sock, fptr);

    if (getsockname(fileno(fptr->f), (struct sockaddr*)&addr, &len) < 0)
	rb_sys_fail("getsockname(2)");
    return ipaddr((struct sockaddr*)&addr);
}

static VALUE
ip_peeraddr(sock)
    VALUE sock;
{
    OpenFile *fptr;
    struct sockaddr_storage addr;
    socklen_t len = sizeof addr;

    GetOpenFile(sock, fptr);

    if (getpeername(fileno(fptr->f), (struct sockaddr*)&addr, &len) < 0)
	rb_sys_fail("getpeername(2)");
    return ipaddr((struct sockaddr*)&addr);
}

static VALUE
ip_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom(sock, argc, argv, RECV_IP);
}

static VALUE
ip_s_getaddress(obj, host)
    VALUE obj, host;
{
    struct sockaddr_storage addr;

    setipaddr(host, &addr);
    return mkipaddr((struct sockaddr*)&addr);
}

static VALUE
udp_init(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    VALUE arg;
    int socktype = AF_INET;
    int fd;

    rb_secure(3);
    if (rb_scan_args(argc, argv, "01", &arg) == 1) {
	socktype = NUM2INT(arg);
    }
    fd = ruby_socket(socktype, SOCK_DGRAM, 0);
    if (fd < 0) {
	rb_sys_fail("socket(2) - udp");
    }

    return init_sock(sock, fd);
}

struct udp_arg
{
    struct addrinfo *res;
    int fd;
};

static VALUE
udp_connect_internal(arg)
    struct udp_arg *arg;
{
    int fd = arg->fd;
    struct addrinfo *res;

    for (res = arg->res; res; res = res->ai_next) {
	if (ruby_connect(fd, res->ai_addr, res->ai_addrlen, 0) >= 0) {
	    return Qtrue;
	}
    }
    return Qfalse;
}

static VALUE
udp_connect(sock, host, port)
    VALUE sock, host, port;
{
    OpenFile *fptr;
    int fd;
    struct udp_arg arg;
    VALUE ret;

    rb_secure(3);
    GetOpenFile(sock, fptr);
    arg.res = sock_addrinfo(host, port, SOCK_DGRAM, 0);
    arg.fd = fileno(fptr->f);
    ret = rb_ensure(udp_connect_internal, (VALUE)&arg,
		    RUBY_METHOD_FUNC(freeaddrinfo), (VALUE)arg.res);
    if (!ret) rb_sys_fail("connect(2)");
    return INT2FIX(0);
}

static VALUE
udp_bind(sock, host, port)
    VALUE sock, host, port;
{
    OpenFile *fptr;
    struct addrinfo *res0, *res;

    rb_secure(3);
    GetOpenFile(sock, fptr);
    res0 = sock_addrinfo(host, port, SOCK_DGRAM, 0);
    for (res = res0; res; res = res->ai_next) {
	if (bind(fileno(fptr->f), res->ai_addr, res->ai_addrlen) < 0) {
	    continue;
	}
	freeaddrinfo(res0);
	return INT2FIX(0);
    }
    freeaddrinfo(res0);
    rb_sys_fail("bind(2)");
    return INT2FIX(0);
}

static VALUE
udp_send(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    VALUE mesg, flags, host, port;
    OpenFile *fptr;
    FILE *f;
    int n;
    struct addrinfo *res0, *res;

    if (argc == 2 || argc == 3) {
	return bsock_send(argc, argv, sock);
    }
    rb_secure(4);
    rb_scan_args(argc, argv, "4", &mesg, &flags, &host, &port);

    GetOpenFile(sock, fptr);
    res0 = sock_addrinfo(host, port, SOCK_DGRAM, 0);
    f = GetWriteFile(fptr);
    StringValue(mesg);
    for (res = res0; res; res = res->ai_next) {
      retry:
	n = sendto(fileno(f), RSTRING(mesg)->ptr, RSTRING(mesg)->len, NUM2INT(flags),
		   res->ai_addr, res->ai_addrlen);
	if (n >= 0) {
	    freeaddrinfo(res0);
	    return INT2FIX(n);
	}
	if (rb_io_wait_writable(fileno(f))) {
	    goto retry;
	}
    }
    freeaddrinfo(res0);
    rb_sys_fail("sendto(2)");
    return INT2FIX(n);
}

#ifdef HAVE_SYS_UN_H
static VALUE
unix_init(sock, path)
    VALUE sock, path;
{
    return init_unixsock(sock, path, 0);
}

static VALUE
unix_path(sock)
    VALUE sock;
{
    OpenFile *fptr;

    GetOpenFile(sock, fptr);
    if (fptr->path == 0) {
	struct sockaddr_un addr;
	socklen_t len = sizeof(addr);
	if (getsockname(fileno(fptr->f), (struct sockaddr*)&addr, &len) < 0)
	    rb_sys_fail(0);
	fptr->path = strdup(addr.sun_path);
    }
    return rb_str_new2(fptr->path);
}

static VALUE
unix_svr_s_open(klass, path)
    VALUE klass, path;
{
    return init_unixsock(rb_obj_alloc(klass), path, 1);
}

static VALUE
unix_svr_init(sock, path)
    VALUE sock, path;
{
    return init_unixsock(sock, path, 1);
}

static VALUE
unix_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom(sock, argc, argv, RECV_UNIX);
}

static VALUE
unix_send_io(sock, val)
    VALUE sock, val;
{
#if defined(HAVE_ST_MSG_CONTROL) || defined(HAVE_ST_MSG_ACCRIGHTS)
    int fd;
    OpenFile *fptr;
    struct msghdr msg;
    struct iovec vec[1];
    char buf[1];

#if defined(HAVE_ST_MSG_CONTROL)
    struct {
	struct cmsghdr hdr;
	int fd;
    } cmsg;
#endif

    if (rb_obj_is_kind_of(val, rb_cIO)) {
        OpenFile *valfptr;
	GetOpenFile(val, valfptr);
	fd = fileno(valfptr->f);
    }
    else if (FIXNUM_P(val)) {
        fd = FIX2INT(val);
    }
    else {
	rb_raise(rb_eTypeError, "IO nor file descriptor");
    }

    GetOpenFile(sock, fptr);

    msg.msg_name = NULL;
    msg.msg_namelen = 0;

    /* Linux and Solaris doesn't work if msg_iov is NULL. */
    buf[0] = '\0';
    vec[0].iov_base = buf;
    vec[0].iov_len = 1;
    msg.msg_iov = vec;
    msg.msg_iovlen = 1;

#if defined(HAVE_ST_MSG_CONTROL)
    msg.msg_control = (caddr_t)&cmsg;
    msg.msg_controllen = sizeof(struct cmsghdr) + sizeof(int);
    msg.msg_flags = 0;
    cmsg.hdr.cmsg_len = sizeof(struct cmsghdr) + sizeof(int);
    cmsg.hdr.cmsg_level = SOL_SOCKET;
    cmsg.hdr.cmsg_type = SCM_RIGHTS;
    cmsg.fd = fd;
#else
    msg.msg_accrights = (caddr_t)&fd;
    msg.msg_accrightslen = sizeof(fd);
#endif

    if (sendmsg(fileno(fptr->f), &msg, 0) == -1)
	rb_sys_fail("sendmsg(2)");

    return Qnil;
#else
    rb_notimplement();
#endif
}

static VALUE
unix_recv_io(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
#if defined(HAVE_ST_MSG_CONTROL) || defined(HAVE_ST_MSG_ACCRIGHTS)
    VALUE klass, mode;
    OpenFile *fptr;
    struct msghdr msg;
    struct iovec vec[2];
    char buf[1];

    int fd;
#if defined(HAVE_ST_MSG_CONTROL)
    struct {
	struct cmsghdr hdr;
	int fd;
    } cmsg;
#endif

    rb_scan_args(argc, argv, "02", &klass, &mode);
    if (argc == 0)
	klass = rb_cIO;
    if (argc <= 1)
	mode = Qnil;

    GetOpenFile(sock, fptr);

    thread_read_select(fileno(fptr->f));

    msg.msg_name = NULL;
    msg.msg_namelen = 0;

    vec[0].iov_base = buf;
    vec[0].iov_len = sizeof(buf);
    msg.msg_iov = vec;
    msg.msg_iovlen = 1;

#if defined(HAVE_ST_MSG_CONTROL)
    msg.msg_control = (caddr_t)&cmsg;
    msg.msg_controllen = sizeof(struct cmsghdr) + sizeof(int);
    msg.msg_flags = 0;
    cmsg.hdr.cmsg_len = sizeof(struct cmsghdr) + sizeof(int);
    cmsg.hdr.cmsg_level = SOL_SOCKET;
    cmsg.hdr.cmsg_type = SCM_RIGHTS;
    cmsg.fd = -1;
#else
    msg.msg_accrights = (caddr_t)&fd;
    msg.msg_accrightslen = sizeof(fd);
    fd = -1;
#endif

    if (recvmsg(fileno(fptr->f), &msg, 0) == -1)
	rb_sys_fail("recvmsg(2)");

    if (
#if defined(HAVE_ST_MSG_CONTROL)
	msg.msg_controllen != sizeof(struct cmsghdr) + sizeof(int) ||
        cmsg.hdr.cmsg_len != sizeof(struct cmsghdr) + sizeof(int) ||
	cmsg.hdr.cmsg_level != SOL_SOCKET ||
	cmsg.hdr.cmsg_type != SCM_RIGHTS
#else
        msg.msg_accrightslen != sizeof(fd)
#endif
	) {
	rb_raise(rb_eSocket, "File descriptor was not passed");
    }

#if defined(HAVE_ST_MSG_CONTROL)
    fd = cmsg.fd;
#endif

    if (klass == Qnil)
	return INT2FIX(fd);
    else {
	static ID for_fd = 0;
	int ff_argc;
	VALUE ff_argv[2];
	if (!for_fd)
	    for_fd = rb_intern("for_fd");
	ff_argc = mode == Qnil ? 1 : 2;
	ff_argv[0] = INT2FIX(fd);
	ff_argv[1] = mode;
        return rb_funcall2(klass, for_fd, ff_argc, ff_argv);
    }
#else
    rb_notimplement();
#endif
}

static VALUE
unix_accept(sock)
    VALUE sock;
{
    OpenFile *fptr;
    struct sockaddr_un from;
    socklen_t fromlen;

    GetOpenFile(sock, fptr);
    fromlen = sizeof(struct sockaddr_un);
    return s_accept(rb_cUNIXSocket, fileno(fptr->f),
		    (struct sockaddr*)&from, &fromlen);
}

static VALUE
unix_sysaccept(sock)
    VALUE sock;
{
    OpenFile *fptr;
    struct sockaddr_un from;
    socklen_t fromlen;

    GetOpenFile(sock, fptr);
    fromlen = sizeof(struct sockaddr_un);
    return s_accept(0, fileno(fptr->f), (struct sockaddr*)&from, &fromlen);
}

static VALUE
unixaddr(sockaddr)
    struct sockaddr_un *sockaddr;
{
    return rb_assoc_new(rb_str_new2("AF_UNIX"),
			rb_str_new2(sockaddr->sun_path));
}

static VALUE
unix_addr(sock)
    VALUE sock;
{
    OpenFile *fptr;
    struct sockaddr_un addr;
    socklen_t len = sizeof addr;

    GetOpenFile(sock, fptr);

    if (getsockname(fileno(fptr->f), (struct sockaddr*)&addr, &len) < 0)
	rb_sys_fail("getsockname(2)");
    if (len == 0)
        addr.sun_path[0] = '\0';
    return unixaddr(&addr);
}

static VALUE
unix_peeraddr(sock)
    VALUE sock;
{
    OpenFile *fptr;
    struct sockaddr_un addr;
    socklen_t len = sizeof addr;

    GetOpenFile(sock, fptr);

    if (getpeername(fileno(fptr->f), (struct sockaddr*)&addr, &len) < 0)
	rb_sys_fail("getsockname(2)");
    if (len == 0)
        addr.sun_path[0] = '\0';
    return unixaddr(&addr);
}
#endif

static void
setup_domain_and_type(domain, dv, type, tv)
    VALUE domain, type;
    int *dv, *tv;
{
    char *ptr;

    if (TYPE(domain) == T_STRING) {
	SafeStringValue(domain);
	ptr = RSTRING(domain)->ptr;
	if (strcmp(ptr, "AF_INET") == 0)
	    *dv = AF_INET;
#ifdef AF_UNIX
	else if (strcmp(ptr, "AF_UNIX") == 0)
	    *dv = AF_UNIX;
#endif
#ifdef AF_ISO
	else if (strcmp(ptr, "AF_ISO") == 0)
	    *dv = AF_ISO;
#endif
#ifdef AF_NS
	else if (strcmp(ptr, "AF_NS") == 0)
	    *dv = AF_NS;
#endif
#ifdef AF_IMPLINK
	else if (strcmp(ptr, "AF_IMPLINK") == 0)
	    *dv = AF_IMPLINK;
#endif
#ifdef PF_INET
	else if (strcmp(ptr, "PF_INET") == 0)
	    *dv = PF_INET;
#endif
#ifdef PF_UNIX
	else if (strcmp(ptr, "PF_UNIX") == 0)
	    *dv = PF_UNIX;
#endif
#ifdef PF_IMPLINK
	else if (strcmp(ptr, "PF_IMPLINK") == 0)
	    *dv = PF_IMPLINK;
	else if (strcmp(ptr, "AF_IMPLINK") == 0)
	    *dv = AF_IMPLINK;
#endif
#ifdef PF_AX25
	else if (strcmp(ptr, "PF_AX25") == 0)
	    *dv = PF_AX25;
#endif
#ifdef PF_IPX
	else if (strcmp(ptr, "PF_IPX") == 0)
	    *dv = PF_IPX;
#endif
	else
	    rb_raise(rb_eSocket, "Unknown socket domain %s", ptr);
    }
    else {
	*dv = NUM2INT(domain);
    }
    if (TYPE(type) == T_STRING) {
	SafeStringValue(type);
	ptr = RSTRING(type)->ptr;
	if (strcmp(ptr, "SOCK_STREAM") == 0)
	    *tv = SOCK_STREAM;
	else if (strcmp(ptr, "SOCK_DGRAM") == 0)
	    *tv = SOCK_DGRAM;
#ifdef SOCK_RAW
	else if (strcmp(ptr, "SOCK_RAW") == 0)
	    *tv = SOCK_RAW;
#endif
#ifdef SOCK_SEQPACKET
	else if (strcmp(ptr, "SOCK_SEQPACKET") == 0)
	    *tv = SOCK_SEQPACKET;
#endif
#ifdef SOCK_RDM
	else if (strcmp(ptr, "SOCK_RDM") == 0)
	    *tv = SOCK_RDM;
#endif
#ifdef SOCK_PACKET
	else if (strcmp(ptr, "SOCK_PACKET") == 0)
	    *tv = SOCK_PACKET;
#endif
	else
	    rb_raise(rb_eSocket, "Unknown socket type %s", ptr);
    }
    else {
	*tv = NUM2INT(type);
    }
}

static VALUE
sock_init(sock, domain, type, protocol)
    VALUE sock, domain, type, protocol;
{
    int fd;
    int d, t;

    rb_secure(3);
    setup_domain_and_type(domain, &d, type, &t);
    fd = ruby_socket(d, t, NUM2INT(protocol));
    if (fd < 0) rb_sys_fail("socket(2)");

    return init_sock(sock, fd);
}

static VALUE
sock_s_socketpair(klass, domain, type, protocol)
    VALUE klass, domain, type, protocol;
{
#if !defined(NT) && !defined(__BEOS__) && !defined(__EMX__) && !defined(__QNXNTO__)
    int d, t, sp[2];

    setup_domain_and_type(domain, &d, type, &t);
  again:
    if (socketpair(d, t, NUM2INT(protocol), sp) < 0) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    goto again;
	}
	rb_sys_fail("socketpair(2)");
    }

    return rb_assoc_new(init_sock(rb_obj_alloc(klass), sp[0]),
			init_sock(rb_obj_alloc(klass), sp[1]));
#else
    rb_notimplement();
#endif
}

#ifdef HAVE_SYS_UN_H
static VALUE
unix_s_socketpair(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE domain, type, protocol;
    domain = INT2FIX(PF_UNIX);

    rb_scan_args(argc, argv, "02", &type, &protocol);
    if (argc == 0)
	type = INT2FIX(SOCK_STREAM);
    if (argc <= 1)
	protocol = INT2FIX(0);

    return sock_s_socketpair(klass, domain, type, protocol);
}
#endif

static VALUE
sock_connect(sock, addr)
    VALUE sock, addr;
{
    OpenFile *fptr;
    int fd;

    StringValue(addr);
    rb_str_modify(addr);

    GetOpenFile(sock, fptr);
    fd = fileno(fptr->f);
    if (ruby_connect(fd, (struct sockaddr*)RSTRING(addr)->ptr, RSTRING(addr)->len, 0) < 0) {
	rb_sys_fail("connect(2)");
    }

    return INT2FIX(0);
}

static VALUE
sock_bind(sock, addr)
    VALUE sock, addr;
{
    OpenFile *fptr;

    StringValue(addr);
    rb_str_modify(addr);

    GetOpenFile(sock, fptr);
    if (bind(fileno(fptr->f), (struct sockaddr*)RSTRING(addr)->ptr, RSTRING(addr)->len) < 0)
	rb_sys_fail("bind(2)");

    return INT2FIX(0);
}

static VALUE
sock_listen(sock, log)
   VALUE sock, log;
{
    OpenFile *fptr;

    rb_secure(4);
    GetOpenFile(sock, fptr);
    if (listen(fileno(fptr->f), NUM2INT(log)) < 0)
	rb_sys_fail("listen(2)");

    return INT2FIX(0);
}

static VALUE
sock_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom(sock, argc, argv, RECV_SOCKET);
}

static VALUE
sock_accept(sock)
   VALUE sock;
{
    OpenFile *fptr;
    VALUE sock2;
    char buf[1024];
    socklen_t len = sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = s_accept(rb_cSocket,fileno(fptr->f),(struct sockaddr*)buf,&len);

    return rb_assoc_new(sock2, rb_str_new(buf, len));
}

static VALUE
sock_sysaccept(sock)
   VALUE sock;
{
    OpenFile *fptr;
    VALUE sock2;
    char buf[1024];
    socklen_t len = sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = s_accept(0,fileno(fptr->f),(struct sockaddr*)buf,&len);

    return rb_assoc_new(sock2, rb_str_new(buf, len));
}

#ifdef HAVE_GETHOSTNAME
static VALUE
sock_gethostname(obj)
    VALUE obj;
{
    char buf[1024];

    rb_secure(3);
    if (gethostname(buf, (int)sizeof buf - 1) < 0)
	rb_sys_fail("gethostname");

    buf[sizeof buf - 1] = '\0';
    return rb_str_new2(buf);
}
#else
#ifdef HAVE_UNAME

#include <sys/utsname.h>

static VALUE
sock_gethostname(obj)
    VALUE obj;
{
    struct utsname un;

    rb_secure(3);
    uname(&un);
    return rb_str_new2(un.nodename);
}
#else
static VALUE
sock_gethostname(obj)
    VALUE obj;
{
    rb_notimplement();
}
#endif
#endif

static VALUE
sock_mkhostent(h)
    struct hostent *h;
{
    char **pch;
    VALUE ary, names;

    if (h == NULL) {
#ifdef HAVE_HSTRERROR
	extern int h_errno;
	rb_raise(rb_eSocket, "%s", (char*)hstrerror(h_errno));
#else
	rb_raise(rb_eSocket, "host not found");
#endif
    }
    ary = rb_ary_new();
    rb_ary_push(ary, rb_str_new2(h->h_name));
    names = rb_ary_new();
    rb_ary_push(ary, names);
    for (pch = h->h_aliases; *pch; pch++) {
	rb_ary_push(names, rb_str_new2(*pch));
    }
    rb_ary_push(ary, INT2NUM(h->h_addrtype));
#ifdef h_addr
    for (pch = h->h_addr_list; *pch; pch++) {
	rb_ary_push(ary, rb_str_new(*pch, h->h_length));
    }
#else
    rb_ary_push(ary, rb_str_new(h->h_addr, h->h_length));
#endif

    return ary;
}

static VALUE
mkaddrinfo(res0)
    struct addrinfo *res0;
{
    VALUE base, ary;
    struct addrinfo *res;

    if (res0 == NULL) {
	rb_raise(rb_eSocket, "host not found");
    }
    base = rb_ary_new();
    for (res = res0; res; res = res->ai_next) {
	ary = ipaddr(res->ai_addr);
	rb_ary_push(ary, INT2FIX(res->ai_family));
	rb_ary_push(ary, INT2FIX(res->ai_socktype));
	rb_ary_push(ary, INT2FIX(res->ai_protocol));
	rb_ary_push(base, ary);
    }
    return base;
}

static VALUE
sock_s_gethostbyname(obj, host)
    VALUE obj, host;
{
    return sock_mkhostent(sock_hostbyname(host));
}

static VALUE
sock_s_gethostbyaddr(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE addr, type;
    struct hostent *h;
    struct sockaddr *sa;
    int t = AF_INET;

    rb_scan_args(argc, argv, "11", &addr, &type);
    sa = (struct sockaddr*)StringValuePtr(addr);
    if (!NIL_P(type)) {
	t = NUM2INT(type);
    }
#ifdef INET6
    else if (RSTRING(addr)->len == 16) {
	t = AF_INET6;
    }
#endif
    h = gethostbyaddr(RSTRING(addr)->ptr, RSTRING(addr)->len, t);

    return sock_mkhostent(h);
}

static VALUE
sock_s_getservbyaname(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE service, protocol;
    char *proto;
    struct servent *sp;
    int port;

    rb_scan_args(argc, argv, "11", &service, &protocol);
    if (NIL_P(protocol)) proto = "tcp";
    else proto = StringValuePtr(protocol);

    StringValue(service);
    sp = getservbyname(RSTRING(service)->ptr, proto);
    if (sp) {
	port = ntohs(sp->s_port);
    }
    else {
	char *s = RSTRING(service)->ptr;
	char *end;

	port = strtoul(s, &end, 0);
	if (*end != '\0') {
	    rb_raise(rb_eSocket, "no such service %s/%s", s, proto);
	}
    }
    return INT2FIX(port);
}

static VALUE
sock_s_getaddrinfo(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE host, port, family, socktype, protocol, flags, ret;
    char hbuf[1024], pbuf[1024];
    char *hptr, *pptr, *ap;
    struct addrinfo hints, *res;
    int error;

    host = port = family = socktype = protocol = flags = Qnil;
    rb_scan_args(argc, argv, "24", &host, &port, &family, &socktype, &protocol, &flags);
    if (NIL_P(host)) {
	hptr = NULL;
    }
    else {
	strncpy(hbuf, StringValuePtr(host), sizeof(hbuf));
	hbuf[sizeof(hbuf) - 1] = '\0';
	hptr = hbuf;
    }
    if (NIL_P(port)) {
	pptr = NULL;
    }
    else if (FIXNUM_P(port)) {
	snprintf(pbuf, sizeof(pbuf), "%d", FIX2INT(port));
	pptr = pbuf;
    }
    else {
	strncpy(pbuf, StringValuePtr(port), sizeof(pbuf));
	pbuf[sizeof(pbuf) - 1] = '\0';
	pptr = pbuf;
    }

    MEMZERO(&hints, struct addrinfo, 1);
    if (NIL_P(family)) {
	hints.ai_family = PF_UNSPEC;
    }
    else if (FIXNUM_P(family)) {
	hints.ai_family = FIX2INT(family);
    }
    else if ((ap = StringValuePtr(family)) != 0) {
	if (strcmp(ap, "AF_INET") == 0) {
	    hints.ai_family = PF_INET;
	}
#ifdef INET6
	else if (strcmp(ap, "AF_INET6") == 0) {
	    hints.ai_family = PF_INET6;
	}
#endif
    }

    if (!NIL_P(socktype)) {
	hints.ai_socktype = NUM2INT(socktype);
    }
    if (!NIL_P(protocol)) {
	hints.ai_protocol = NUM2INT(protocol);
    }
    if (!NIL_P(flags)) {
	hints.ai_flags = NUM2INT(flags);
    }
    error = getaddrinfo(hptr, pptr, &hints, &res);
    if (error) {
	rb_raise(rb_eSocket, "getaddrinfo: %s", gai_strerror(error));
    }

    ret = mkaddrinfo(res);
    freeaddrinfo(res);
    return ret;
}

static VALUE
sock_s_getnameinfo(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE sa, af = Qnil, host = Qnil, port = Qnil, flags;
    char *hptr, *pptr;
    char hbuf[1024], pbuf[1024];
    int fl;
    struct addrinfo hints, *res = NULL, *r;
    int error;
    struct sockaddr_storage ss;
    struct sockaddr *sap;
    char *ep, *ap;

    sa = flags = Qnil;
    rb_scan_args(argc, argv, "11", &sa, &flags);

    fl = 0;
    if (!NIL_P(flags)) {
	fl = NUM2INT(flags);
    }
    if (TYPE(sa) == T_STRING) {
	if (sizeof(ss) < RSTRING(sa)->len) {
	    rb_raise(rb_eTypeError, "sockaddr length too big");
	}
	memcpy(&ss, RSTRING(sa)->ptr, RSTRING(sa)->len);
	if (RSTRING(sa)->len != SA_LEN((struct sockaddr*)&ss)) {
	    rb_raise(rb_eTypeError, "sockaddr size differs - should not happen");
	}
	sap = (struct sockaddr*)&ss;
    }
    else if (TYPE(sa) == T_ARRAY) {
	MEMZERO(&hints, struct addrinfo, 1);
	if (RARRAY(sa)->len == 3) {
	    af = RARRAY(sa)->ptr[0];
	    port = RARRAY(sa)->ptr[1];
	    host = RARRAY(sa)->ptr[2];
	}
	else if (RARRAY(sa)->len >= 4) {
	    af = RARRAY(sa)->ptr[0];
	    port = RARRAY(sa)->ptr[1];
	    host = RARRAY(sa)->ptr[3];
	    if (NIL_P(host)) {
		host = RARRAY(sa)->ptr[2];
	    }
	    else {
		/*
		 * 4th element holds numeric form, don't resolve.
		 * see ipaddr().
		 */
		hints.ai_flags |= AI_NUMERICHOST;
	    }
	}
	else {
	    rb_raise(rb_eArgError, "array size should be 3 or 4, %ld given",
		     RARRAY(sa)->len);
	}
	/* host */
	if (NIL_P(host)) {
	    hptr = NULL;
	}
	else {
	    strncpy(hbuf, StringValuePtr(host), sizeof(hbuf));
	    hbuf[sizeof(hbuf) - 1] = '\0';
	    hptr = hbuf;
	}
	/* port */
	if (NIL_P(port)) {
	    strcpy(pbuf, "0");
	    pptr = NULL;
	}
	else if (FIXNUM_P(port)) {
	    snprintf(pbuf, sizeof(pbuf), "%d", NUM2INT(port));
	    pptr = pbuf;
	}
	else {
	    strncpy(pbuf, StringValuePtr(port), sizeof(pbuf));
	    pbuf[sizeof(pbuf) - 1] = '\0';
	    pptr = pbuf;
	}
	hints.ai_socktype = (fl & NI_DGRAM) ? SOCK_DGRAM : SOCK_STREAM;
	/* af */
	if (NIL_P(af)) {
	    hints.ai_family = PF_UNSPEC;
	}
	else if (FIXNUM_P(af)) {
	    hints.ai_family = FIX2INT(af);
	}
	else if ((ap = StringValuePtr(af)) != 0) {
	    if (strcmp(ap, "AF_INET") == 0) {
		hints.ai_family = PF_INET;
	    }
#ifdef INET6
	    else if (strcmp(ap, "AF_INET6") == 0) {
		hints.ai_family = PF_INET6;
	    }
#endif
	}
	error = getaddrinfo(hptr, pptr, &hints, &res);
	if (error) goto error_exit_addr;
	sap = res->ai_addr;
    }
    else {
	rb_raise(rb_eTypeError, "expecting String or Array");
    }

    error = getnameinfo(sap, SA_LEN(sap), hbuf, sizeof(hbuf),
			pbuf, sizeof(pbuf), fl);
    if (error) goto error_exit_name;
    if (res) {
	for (r = res->ai_next; r; r = r->ai_next) {
	    char hbuf2[1024], pbuf2[1024];

	    sap = r->ai_addr;
	    error = getnameinfo(sap, SA_LEN(sap), hbuf2, sizeof(hbuf2),
				pbuf2, sizeof(pbuf2), fl);
	    if (error) goto error_exit_name;
	    if (strcmp(hbuf, hbuf2) != 0|| strcmp(pbuf, pbuf2) != 0) {
		freeaddrinfo(res);
		rb_raise(rb_eSocket, "sockaddr resolved to multiple nodename");
	    }
	}
	freeaddrinfo(res);
    }
    return rb_assoc_new(rb_str_new2(hbuf), rb_str_new2(pbuf));

  error_exit_addr:
    if (res) freeaddrinfo(res);
    rb_raise(rb_eSocket, "getaddrinfo: %s", gai_strerror(error));

  error_exit_name:
    if (res) freeaddrinfo(res);
    rb_raise(rb_eSocket, "getnameinfo: %s", gai_strerror(error));
}

static VALUE
sock_s_pack_sockaddr_in(self, port, host)
    VALUE self, port, host;
{
    struct addrinfo *res = sock_addrinfo(host, port, 0, 0);
    VALUE addr = rb_str_new((char*)res->ai_addr, res->ai_addrlen);

    freeaddrinfo(res);
    OBJ_INFECT(addr, port);
    OBJ_INFECT(addr, host);

    return addr;
}

static VALUE
sock_s_unpack_sockaddr_in(self, addr)
    VALUE self, addr;
{
    struct sockaddr_in * sockaddr;
    VALUE host;

    sockaddr = (struct sockaddr_in*)StringValuePtr(addr);
    if (RSTRING(addr)->len != sizeof(struct sockaddr_in)) {
	rb_raise(rb_eTypeError, "sockaddr_in size differs - %ld required; %d given",
		 RSTRING(addr)->len, sizeof(struct sockaddr_in));
    }
    host = mkipaddr(sockaddr);
    OBJ_INFECT(host, addr);
    return rb_assoc_new(INT2NUM(ntohs(sockaddr->sin_port)), host);
}

#ifdef HAVE_SYS_UN_H
static VALUE
sock_s_pack_sockaddr_un(self, path)
    VALUE self, path;
{
    struct sockaddr_un sockaddr;
    VALUE addr;

    MEMZERO(&sockaddr, struct sockaddr_un, 1);
    sockaddr.sun_family = AF_UNIX;
    strncpy(sockaddr.sun_path, StringValuePtr(path), sizeof(sockaddr.sun_path)-1);
    addr = rb_str_new((char*)&sockaddr, sizeof(sockaddr));
    OBJ_INFECT(addr, path);

    return addr;
}

static VALUE
sock_s_unpack_sockaddr_un(self, addr)
    VALUE self, addr;
{
    struct sockaddr_un * sockaddr;
    VALUE path;

    sockaddr = (struct sockaddr_un*)StringValuePtr(addr);
    if (RSTRING(addr)->len != sizeof(struct sockaddr_un)) {
	rb_raise(rb_eTypeError, "sockaddr_un size differs - %ld required; %d given",
		 RSTRING(addr)->len, sizeof(struct sockaddr_un));
    }
    /* xxx: should I check against sun_path size? */
    path = rb_str_new2(sockaddr->sun_path);
    OBJ_INFECT(path, addr);
    return path;
}
#endif

static VALUE mConst;

static void
sock_define_const(name, value)
    char *name;
    int value;
{
    rb_define_const(rb_cSocket, name, INT2FIX(value));
    rb_define_const(mConst, name, INT2FIX(value));
}

void
Init_socket()
{
    rb_eSocket = rb_define_class("SocketError", rb_eStandardError);

    rb_cBasicSocket = rb_define_class("BasicSocket", rb_cIO);
    rb_undef_method(rb_cBasicSocket, "initialize");

    rb_define_singleton_method(rb_cBasicSocket, "do_not_reverse_lookup",
			       bsock_do_not_rev_lookup, 0);
    rb_define_singleton_method(rb_cBasicSocket, "do_not_reverse_lookup=",
			       bsock_do_not_rev_lookup_set, 1);
    rb_define_singleton_method(rb_cBasicSocket, "for_fd", bsock_s_for_fd, 1);

    rb_define_method(rb_cBasicSocket, "close_read", bsock_close_read, 0);
    rb_define_method(rb_cBasicSocket, "close_write", bsock_close_write, 0);
    rb_define_method(rb_cBasicSocket, "shutdown", bsock_shutdown, -1);
    rb_define_method(rb_cBasicSocket, "setsockopt", bsock_setsockopt, 3);
    rb_define_method(rb_cBasicSocket, "getsockopt", bsock_getsockopt, 2);
    rb_define_method(rb_cBasicSocket, "getsockname", bsock_getsockname, 0);
    rb_define_method(rb_cBasicSocket, "getpeername", bsock_getpeername, 0);
    rb_define_method(rb_cBasicSocket, "send", bsock_send, -1);
    rb_define_method(rb_cBasicSocket, "recv", bsock_recv, -1);

    rb_cIPSocket = rb_define_class("IPSocket", rb_cBasicSocket);
    rb_define_global_const("IPsocket", rb_cIPSocket);
    rb_define_method(rb_cIPSocket, "addr", ip_addr, 0);
    rb_define_method(rb_cIPSocket, "peeraddr", ip_peeraddr, 0);
    rb_define_method(rb_cIPSocket, "recvfrom", ip_recvfrom, -1);
    rb_define_singleton_method(rb_cIPSocket, "getaddress", ip_s_getaddress, 1);

    rb_cTCPSocket = rb_define_class("TCPSocket", rb_cIPSocket);
    rb_define_global_const("TCPsocket", rb_cTCPSocket);
    rb_define_singleton_method(rb_cTCPSocket, "gethostbyname", tcp_s_gethostbyname, 1);
    rb_define_method(rb_cTCPSocket, "initialize", tcp_init, -1);

#ifdef SOCKS
    rb_cSOCKSSocket = rb_define_class("SOCKSSocket", rb_cTCPSocket);
    rb_define_global_const("SOCKSsocket", rb_cSOCKSSocket);
    rb_define_method(rb_cSOCKSSocket, "initialize", socks_init, 2);
#ifdef SOCKS5
    rb_define_method(rb_cSOCKSSocket, "close", socks_s_close, 0);
#endif
#endif

    rb_cTCPServer = rb_define_class("TCPServer", rb_cTCPSocket);
    rb_define_global_const("TCPserver", rb_cTCPServer);
    rb_define_method(rb_cTCPServer, "accept", tcp_accept, 0);
    rb_define_method(rb_cTCPServer, "sysaccept", tcp_sysaccept, 0);
    rb_define_method(rb_cTCPServer, "initialize", tcp_svr_init, -1);
    rb_define_method(rb_cTCPServer, "listen", sock_listen, 1);

    rb_cUDPSocket = rb_define_class("UDPSocket", rb_cIPSocket);
    rb_define_global_const("UDPsocket", rb_cUDPSocket);
    rb_define_method(rb_cUDPSocket, "initialize", udp_init, -1);
    rb_define_method(rb_cUDPSocket, "connect", udp_connect, 2);
    rb_define_method(rb_cUDPSocket, "bind", udp_bind, 2);
    rb_define_method(rb_cUDPSocket, "send", udp_send, -1);

#ifdef HAVE_SYS_UN_H
    rb_cUNIXSocket = rb_define_class("UNIXSocket", rb_cBasicSocket);
    rb_define_global_const("UNIXsocket", rb_cUNIXSocket);
    rb_define_method(rb_cUNIXSocket, "initialize", unix_init, 1);
    rb_define_method(rb_cUNIXSocket, "path", unix_path, 0);
    rb_define_method(rb_cUNIXSocket, "addr", unix_addr, 0);
    rb_define_method(rb_cUNIXSocket, "peeraddr", unix_peeraddr, 0);
    rb_define_method(rb_cUNIXSocket, "recvfrom", unix_recvfrom, -1);
    rb_define_method(rb_cUNIXSocket, "send_io", unix_send_io, 1);
    rb_define_method(rb_cUNIXSocket, "recv_io", unix_recv_io, -1);
    rb_define_singleton_method(rb_cUNIXSocket, "socketpair", unix_s_socketpair, -1);
    rb_define_singleton_method(rb_cUNIXSocket, "pair", unix_s_socketpair, -1);

    rb_cUNIXServer = rb_define_class("UNIXServer", rb_cUNIXSocket);
    rb_define_global_const("UNIXserver", rb_cUNIXServer);
    rb_define_method(rb_cUNIXServer, "initialize", unix_svr_init, 1);
    rb_define_method(rb_cUNIXServer, "accept", unix_accept, 0);
    rb_define_method(rb_cUNIXServer, "sysaccept", unix_sysaccept, 0);
    rb_define_method(rb_cUNIXServer, "listen", sock_listen, 1);
#endif

    rb_cSocket = rb_define_class("Socket", rb_cBasicSocket);

    rb_define_method(rb_cSocket, "initialize", sock_init, 3);
    rb_define_method(rb_cSocket, "connect", sock_connect, 1);
    rb_define_method(rb_cSocket, "bind", sock_bind, 1);
    rb_define_method(rb_cSocket, "listen", sock_listen, 1);
    rb_define_method(rb_cSocket, "accept", sock_accept, 0);
    rb_define_method(rb_cSocket, "sysaccept", sock_sysaccept, 0);

    rb_define_method(rb_cSocket, "recvfrom", sock_recvfrom, -1);

    rb_define_singleton_method(rb_cSocket, "socketpair", sock_s_socketpair, 3);
    rb_define_singleton_method(rb_cSocket, "pair", sock_s_socketpair, 3);
    rb_define_singleton_method(rb_cSocket, "gethostname", sock_gethostname, 0);
    rb_define_singleton_method(rb_cSocket, "gethostbyname", sock_s_gethostbyname, 1);
    rb_define_singleton_method(rb_cSocket, "gethostbyaddr", sock_s_gethostbyaddr, -1);
    rb_define_singleton_method(rb_cSocket, "getservbyname", sock_s_getservbyaname, -1);
    rb_define_singleton_method(rb_cSocket, "getaddrinfo", sock_s_getaddrinfo, -1);
    rb_define_singleton_method(rb_cSocket, "getnameinfo", sock_s_getnameinfo, -1);
    rb_define_singleton_method(rb_cSocket, "sockaddr_in", sock_s_pack_sockaddr_in, 2);
    rb_define_singleton_method(rb_cSocket, "pack_sockaddr_in", sock_s_pack_sockaddr_in, 2);
    rb_define_singleton_method(rb_cSocket, "unpack_sockaddr_in", sock_s_unpack_sockaddr_in, 1);
#ifdef HAVE_SYS_UN_H
    rb_define_singleton_method(rb_cSocket, "sockaddr_un", sock_s_pack_sockaddr_un, 1);
    rb_define_singleton_method(rb_cSocket, "pack_sockaddr_un", sock_s_pack_sockaddr_un, 1);
    rb_define_singleton_method(rb_cSocket, "unpack_sockaddr_un", sock_s_unpack_sockaddr_un, 1);
#endif

    /* constants */
    mConst = rb_define_module_under(rb_cSocket, "Constants");
    sock_define_const("SOCK_STREAM", SOCK_STREAM);
    sock_define_const("SOCK_DGRAM", SOCK_DGRAM);
#ifdef SOCK_RAW
    sock_define_const("SOCK_RAW", SOCK_RAW);
#endif
#ifdef SOCK_RDM
    sock_define_const("SOCK_RDM", SOCK_RDM);
#endif
#ifdef SOCK_SEQPACKET
    sock_define_const("SOCK_SEQPACKET", SOCK_SEQPACKET);
#endif
#ifdef SOCK_PACKET
    sock_define_const("SOCK_PACKET", SOCK_PACKET);
#endif

    sock_define_const("AF_INET", AF_INET);
#ifdef PF_INET
    sock_define_const("PF_INET", PF_INET);
#endif
#ifdef AF_UNIX
    sock_define_const("AF_UNIX", AF_UNIX);
    sock_define_const("PF_UNIX", PF_UNIX);
#endif
#ifdef AF_AX25
    sock_define_const("AF_AX25", AF_AX25);
    sock_define_const("PF_AX25", PF_AX25);
#endif
#ifdef AF_IPX
    sock_define_const("AF_IPX", AF_IPX);
    sock_define_const("PF_IPX", PF_IPX);
#endif
#ifdef AF_APPLETALK
    sock_define_const("AF_APPLETALK", AF_APPLETALK);
    sock_define_const("PF_APPLETALK", PF_APPLETALK);
#endif
#ifdef AF_UNSPEC
    sock_define_const("AF_UNSPEC", AF_UNSPEC);
    sock_define_const("PF_UNSPEC", PF_UNSPEC);
#endif
#ifdef AF_INET6
    sock_define_const("AF_INET6", AF_INET6);
#endif
#ifdef PF_INET6
    sock_define_const("PF_INET6", PF_INET6);
#endif

    sock_define_const("MSG_OOB", MSG_OOB);
#ifdef MSG_PEEK
    sock_define_const("MSG_PEEK", MSG_PEEK);
#endif
#ifdef MSG_DONTROUTE
    sock_define_const("MSG_DONTROUTE", MSG_DONTROUTE);
#endif

    sock_define_const("SOL_SOCKET", SOL_SOCKET);
#ifdef SOL_IP
    sock_define_const("SOL_IP", SOL_IP);
#endif
#ifdef SOL_IPX
    sock_define_const("SOL_IPX", SOL_IPX);
#endif
#ifdef SOL_AX25
    sock_define_const("SOL_AX25", SOL_AX25);
#endif
#ifdef SOL_ATALK
    sock_define_const("SOL_ATALK", SOL_ATALK);
#endif
#ifdef SOL_TCP
    sock_define_const("SOL_TCP", SOL_TCP);
#endif
#ifdef SOL_UDP
    sock_define_const("SOL_UDP", SOL_UDP);
#endif

#ifdef	IPPROTO_IP
    sock_define_const("IPPROTO_IP", IPPROTO_IP);
#else
    sock_define_const("IPPROTO_IP", 0);
#endif
#ifdef	IPPROTO_ICMP
    sock_define_const("IPPROTO_ICMP", IPPROTO_ICMP);
#else
    sock_define_const("IPPROTO_ICMP", 1);
#endif
#ifdef	IPPROTO_IGMP
    sock_define_const("IPPROTO_IGMP", IPPROTO_IGMP);
#endif
#ifdef	IPPROTO_GGP
    sock_define_const("IPPROTO_GGP", IPPROTO_GGP);
#endif
#ifdef	IPPROTO_TCP
    sock_define_const("IPPROTO_TCP", IPPROTO_TCP);
#else
    sock_define_const("IPPROTO_TCP", 6);
#endif
#ifdef	IPPROTO_EGP
    sock_define_const("IPPROTO_EGP", IPPROTO_EGP);
#endif
#ifdef	IPPROTO_PUP
    sock_define_const("IPPROTO_PUP", IPPROTO_PUP);
#endif
#ifdef	IPPROTO_UDP
    sock_define_const("IPPROTO_UDP", IPPROTO_UDP);
#else
    sock_define_const("IPPROTO_UDP", 17);
#endif
#ifdef	IPPROTO_IDP
    sock_define_const("IPPROTO_IDP", IPPROTO_IDP);
#endif
#ifdef	IPPROTO_HELLO
    sock_define_const("IPPROTO_HELLO", IPPROTO_HELLO);
#endif
#ifdef	IPPROTO_ND
    sock_define_const("IPPROTO_ND", IPPROTO_ND);
#endif
#ifdef	IPPROTO_TP
    sock_define_const("IPPROTO_TP", IPPROTO_TP);
#endif
#ifdef	IPPROTO_XTP
    sock_define_const("IPPROTO_XTP", IPPROTO_XTP);
#endif
#ifdef	IPPROTO_EON
    sock_define_const("IPPROTO_EON", IPPROTO_EON);
#endif
#ifdef	IPPROTO_BIP
    sock_define_const("IPPROTO_BIP", IPPROTO_BIP);
#endif
/**/
#ifdef	IPPROTO_RAW
    sock_define_const("IPPROTO_RAW", IPPROTO_RAW);
#else
    sock_define_const("IPPROTO_RAW", 255);
#endif
#ifdef	IPPROTO_MAX
    sock_define_const("IPPROTO_MAX", IPPROTO_MAX);
#endif

	/* Some port configuration */
#ifdef	IPPORT_RESERVED
    sock_define_const("IPPORT_RESERVED", IPPORT_RESERVED);
#else
    sock_define_const("IPPORT_RESERVED", 1024);
#endif
#ifdef	IPPORT_USERRESERVED
    sock_define_const("IPPORT_USERRESERVED", IPPORT_USERRESERVED);
#else
    sock_define_const("IPPORT_USERRESERVED", 5000);
#endif
	/* Some reserved IP v.4 addresses */
#ifdef	INADDR_ANY
    sock_define_const("INADDR_ANY", INADDR_ANY);
#else
    sock_define_const("INADDR_ANY", 0x00000000);
#endif
#ifdef	INADDR_BROADCAST
    sock_define_const("INADDR_BROADCAST", INADDR_BROADCAST);
#else
    sock_define_const("INADDR_BROADCAST", 0xffffffff);
#endif
#ifdef	INADDR_LOOPBACK
    sock_define_const("INADDR_LOOPBACK", INADDR_LOOPBACK);
#else
    sock_define_const("INADDR_LOOPBACK", 0x7F000001);
#endif
#ifdef	INADDR_UNSPEC_GROUP
    sock_define_const("INADDR_UNSPEC_GROUP", INADDR_UNSPEC_GROUP);
#else
    sock_define_const("INADDR_UNSPEC_GROUP", 0xe0000000);
#endif
#ifdef	INADDR_ALLHOSTS_GROUP
    sock_define_const("INADDR_ALLHOSTS_GROUP", INADDR_ALLHOSTS_GROUP);
#else
    sock_define_const("INADDR_ALLHOSTS_GROUP", 0xe0000001);
#endif
#ifdef	INADDR_MAX_LOCAL_GROUP
    sock_define_const("INADDR_MAX_LOCAL_GROUP", INADDR_MAX_LOCAL_GROUP);
#else
    sock_define_const("INADDR_MAX_LOCAL_GROUP", 0xe00000ff);
#endif
#ifdef	INADDR_NONE
    sock_define_const("INADDR_NONE", INADDR_NONE);
#else
    sock_define_const("INADDR_NONE", 0xffffffff);
#endif
	/* IP [gs]etsockopt options */
#ifdef	IP_OPTIONS
    sock_define_const("IP_OPTIONS", IP_OPTIONS);
#endif
#ifdef	IP_HDRINCL
    sock_define_const("IP_HDRINCL", IP_HDRINCL);
#endif
#ifdef	IP_TOS
    sock_define_const("IP_TOS", IP_TOS);
#endif
#ifdef	IP_TTL
    sock_define_const("IP_TTL", IP_TTL);
#endif
#ifdef	IP_RECVOPTS
    sock_define_const("IP_RECVOPTS", IP_RECVOPTS);
#endif
#ifdef	IP_RECVRETOPTS
    sock_define_const("IP_RECVRETOPTS", IP_RECVRETOPTS);
#endif
#ifdef	IP_RECVDSTADDR
    sock_define_const("IP_RECVDSTADDR", IP_RECVDSTADDR);
#endif
#ifdef	IP_RETOPTS
    sock_define_const("IP_RETOPTS", IP_RETOPTS);
#endif
#ifdef	IP_MULTICAST_IF
    sock_define_const("IP_MULTICAST_IF", IP_MULTICAST_IF);
#endif
#ifdef	IP_MULTICAST_TTL
    sock_define_const("IP_MULTICAST_TTL", IP_MULTICAST_TTL);
#endif
#ifdef	IP_MULTICAST_LOOP
    sock_define_const("IP_MULTICAST_LOOP", IP_MULTICAST_LOOP);
#endif
#ifdef	IP_ADD_MEMBERSHIP
    sock_define_const("IP_ADD_MEMBERSHIP", IP_ADD_MEMBERSHIP);
#endif
#ifdef	IP_DROP_MEMBERSHIP
    sock_define_const("IP_DROP_MEMBERSHIP", IP_DROP_MEMBERSHIP);
#endif
#ifdef	IP_DEFAULT_MULTICAST_TTL
    sock_define_const("IP_DEFAULT_MULTICAST_TTL", IP_DEFAULT_MULTICAST_TTL);
#endif
#ifdef	IP_DEFAULT_MULTICAST_LOOP
    sock_define_const("IP_DEFAULT_MULTICAST_LOOP", IP_DEFAULT_MULTICAST_LOOP);
#endif
#ifdef	IP_MAX_MEMBERSHIPS
    sock_define_const("IP_MAX_MEMBERSHIPS", IP_MAX_MEMBERSHIPS);
#endif
#ifdef SO_DEBUG
    sock_define_const("SO_DEBUG", SO_DEBUG);
#endif
    sock_define_const("SO_REUSEADDR", SO_REUSEADDR);
#ifdef SO_TYPE
    sock_define_const("SO_TYPE", SO_TYPE);
#endif
#ifdef SO_ERROR
    sock_define_const("SO_ERROR", SO_ERROR);
#endif
#ifdef SO_DONTROUTE
    sock_define_const("SO_DONTROUTE", SO_DONTROUTE);
#endif
#ifdef SO_BROADCAST
    sock_define_const("SO_BROADCAST", SO_BROADCAST);
#endif
#ifdef SO_SNDBUF
    sock_define_const("SO_SNDBUF", SO_SNDBUF);
#endif
#ifdef SO_RCVBUF
    sock_define_const("SO_RCVBUF", SO_RCVBUF);
#endif
#ifdef SO_KEEPALIVE
    sock_define_const("SO_KEEPALIVE", SO_KEEPALIVE);
#endif
#ifdef SO_OOBINLINE
    sock_define_const("SO_OOBINLINE", SO_OOBINLINE);
#endif
#ifdef SO_NO_CHECK
    sock_define_const("SO_NO_CHECK", SO_NO_CHECK);
#endif
#ifdef SO_PRIORITY
    sock_define_const("SO_PRIORITY", SO_PRIORITY);
#endif
#ifdef SO_LINGER
    sock_define_const("SO_LINGER", SO_LINGER);
#endif
#ifdef SO_PASSCRED
    sock_define_const("SO_PASSCRED", SO_PASSCRED);
#endif
#ifdef SO_PEERCRED
    sock_define_const("SO_PEERCRED", SO_PEERCRED);
#endif
#ifdef SO_RCVLOWAT
    sock_define_const("SO_RCVLOWAT", SO_RCVLOWAT);
#endif
#ifdef SO_SNDLOWAT
    sock_define_const("SO_SNDLOWAT", SO_SNDLOWAT);
#endif
#ifdef SO_RCVTIMEO
    sock_define_const("SO_RCVTIMEO", SO_RCVTIMEO);
#endif
#ifdef SO_SNDTIMEO
    sock_define_const("SO_SNDTIMEO", SO_SNDTIMEO);
#endif

#ifdef SO_SECURITY_AUTHENTICATION
    sock_define_const("SO_SECURITY_AUTHENTICATION", SO_SECURITY_AUTHENTICATION);
#endif
#ifdef SO_SECURITY_ENCRYPTION_TRANSPORT
    sock_define_const("SO_SECURITY_ENCRYPTION_TRANSPORT", SO_SECURITY_ENCRYPTION_TRANSPORT);
#endif
#ifdef SO_SECURITY_ENCRYPTION_NETWORK
    sock_define_const("SO_SECURITY_ENCRYPTION_NETWORK", SO_SECURITY_ENCRYPTION_NETWORK);
#endif

#ifdef SO_BINDTODEVICE
    sock_define_const("SO_BINDTODEVICE", SO_BINDTODEVICE);
#endif
#ifdef SO_ATTACH_FILTER
    sock_define_const("SO_ATTACH_FILTER", SO_ATTACH_FILTER);
#endif
#ifdef SO_DETACH_FILTER
    sock_define_const("SO_DETACH_FILTER", SO_DETACH_FILTER);
#endif
#ifdef SO_PEERNAME
    sock_define_const("SO_PEERNAME", SO_PEERNAME);
#endif
#ifdef SO_TIMESTAMP
    sock_define_const("SO_TIMESTAMP", SO_TIMESTAMP);
#endif

#ifdef SOPRI_INTERACTIVE
    sock_define_const("SOPRI_INTERACTIVE", SOPRI_INTERACTIVE);
#endif
#ifdef SOPRI_NORMAL
    sock_define_const("SOPRI_NORMAL", SOPRI_NORMAL);
#endif
#ifdef SOPRI_BACKGROUND
    sock_define_const("SOPRI_BACKGROUND", SOPRI_BACKGROUND);
#endif

#ifdef IPX_TYPE
    sock_define_const("IPX_TYPE", IPX_TYPE);
#endif

#ifdef TCP_NODELAY
    sock_define_const("TCP_NODELAY", TCP_NODELAY);
#endif
#ifdef TCP_MAXSEG
    sock_define_const("TCP_MAXSEG", TCP_MAXSEG);
#endif

#ifdef EAI_ADDRFAMILY
    sock_define_const("EAI_ADDRFAMILY", EAI_ADDRFAMILY);
#endif
#ifdef EAI_AGAIN
    sock_define_const("EAI_AGAIN", EAI_AGAIN);
#endif
#ifdef EAI_BADFLAGS
    sock_define_const("EAI_BADFLAGS", EAI_BADFLAGS);
#endif
#ifdef EAI_FAIL
    sock_define_const("EAI_FAIL", EAI_FAIL);
#endif
#ifdef EAI_FAMILY
    sock_define_const("EAI_FAMILY", EAI_FAMILY);
#endif
#ifdef EAI_MEMORY
    sock_define_const("EAI_MEMORY", EAI_MEMORY);
#endif
#ifdef EAI_NODATA
    sock_define_const("EAI_NODATA", EAI_NODATA);
#endif
#ifdef EAI_NONAME
    sock_define_const("EAI_NONAME", EAI_NONAME);
#endif
#ifdef EAI_SERVICE
    sock_define_const("EAI_SERVICE", EAI_SERVICE);
#endif
#ifdef EAI_SOCKTYPE
    sock_define_const("EAI_SOCKTYPE", EAI_SOCKTYPE);
#endif
#ifdef EAI_SYSTEM
    sock_define_const("EAI_SYSTEM", EAI_SYSTEM);
#endif
#ifdef EAI_BADHINTS
    sock_define_const("EAI_BADHINTS", EAI_BADHINTS);
#endif
#ifdef EAI_PROTOCOL
    sock_define_const("EAI_PROTOCOL", EAI_PROTOCOL);
#endif
#ifdef EAI_MAX
    sock_define_const("EAI_MAX", EAI_MAX);
#endif
#ifdef AI_PASSIVE
    sock_define_const("AI_PASSIVE", AI_PASSIVE);
#endif
#ifdef AI_CANONNAME
    sock_define_const("AI_CANONNAME", AI_CANONNAME);
#endif
#ifdef AI_NUMERICHOST
    sock_define_const("AI_NUMERICHOST", AI_NUMERICHOST);
#endif
#ifdef AI_MASK
    sock_define_const("AI_MASK", AI_MASK);
#endif
#ifdef AI_ALL
    sock_define_const("AI_ALL", AI_ALL);
#endif
#ifdef AI_V4MAPPED_CFG
    sock_define_const("AI_V4MAPPED_CFG", AI_V4MAPPED_CFG);
#endif
#ifdef AI_ADDRCONFIG
    sock_define_const("AI_ADDRCONFIG", AI_ADDRCONFIG);
#endif
#ifdef AI_V4MAPPED
    sock_define_const("AI_V4MAPPED", AI_V4MAPPED);
#endif
#ifdef AI_DEFAULT
    sock_define_const("AI_DEFAULT", AI_DEFAULT);
#endif
#ifdef NI_MAXHOST
    sock_define_const("NI_MAXHOST", NI_MAXHOST);
#endif
#ifdef NI_MAXSERV
    sock_define_const("NI_MAXSERV", NI_MAXSERV);
#endif
#ifdef NI_NOFQDN
    sock_define_const("NI_NOFQDN", NI_NOFQDN);
#endif
#ifdef NI_NUMERICHOST
    sock_define_const("NI_NUMERICHOST", NI_NUMERICHOST);
#endif
#ifdef NI_NAMEREQD
    sock_define_const("NI_NAMEREQD", NI_NAMEREQD);
#endif
#ifdef NI_NUMERICSERV
    sock_define_const("NI_NUMERICSERV", NI_NUMERICSERV);
#endif
#ifdef NI_DGRAM
    sock_define_const("NI_DGRAM", NI_DGRAM);
#endif
}
@


1.86
log
@* io.c (rb_io_wait_readable): handle retryable errors.

* io.c (rb_io_wait_writable): ditto.

* ext/socket/socket.c (bsock_send): ditto.

* ext/socket/socket.c (s_recvfrom): ditto.

* ext/socket/socket.c (s_accept): ditto.

* ext/socket/socket.c (udp_send): ditto.

* ext/socket/getaddrinfo.c (afdl): made private structures constant.

* rubyio.h: prototype; rb_io_wait_readable(), rb_io_wait_writable().
@
text
@d6 1
a6 1
  $Date: 2002/10/01 15:26:39 $
d827 1
a827 1
	snprintf(pbuf, sizeof(pbuf), "%ld", FIX2UINT(serv));
d833 1
a833 1
	    rb_raise(rb_eArgError, "servicename too long (%d)", RSTRING(serv)->len);
d2129 1
a2129 1
	snprintf(pbuf, sizeof(pbuf), "%ld", FIX2INT(port));
d2230 1
a2230 1
	    rb_raise(rb_eArgError, "array size should be 3 or 4, %d given",
d2248 1
a2248 1
	    snprintf(pbuf, sizeof(pbuf), "%ld", NUM2INT(port));
d2334 1
a2334 1
	rb_raise(rb_eTypeError, "sockaddr_in size differs - %d required; %d given",
d2368 1
a2368 1
	rb_raise(rb_eTypeError, "sockaddr_un size differs - %d required; %d given",
@


1.85
log
@	* ext/socket/socket.c (init_sock): no need for special finalizer,
	  socket descriptor is no longer duplicated in 1.7.
	  [ruby-talk:50732]

	* win32/win32.c, win32/win32.h (rb_w32_fddup, rb_w32_fdclose):
	  delete.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/08/30 14:34:57 $
a370 1
  retry:
d373 1
d383 1
a383 3
	switch (errno) {
	  case EINTR:
	    rb_thread_schedule();
d439 1
a439 3
	switch (errno) {
	  case EINTR:
	    rb_thread_schedule();
d1165 3
a1167 2
	  case EINTR:
	    rb_thread_schedule();
d1431 1
a1431 3
	switch (errno) {
	  case EINTR:
	    rb_thread_schedule();
@


1.84
log
@ext/socket/socket.c (sock_s_getaddrinfo): add strcmp.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/08/30 10:41:58 $
a165 17
#ifdef NT
static void sock_finalize _((OpenFile *fptr));

static void
sock_finalize(fptr)
    OpenFile *fptr;
{
    SOCKET s;

    if (!fptr->f) return;
    s = get_osfhandle(fileno(fptr->f));
    rb_w32_fdclose(fptr->f);
    if (fptr->f2) rb_w32_fdclose(fptr->f2);
    closesocket(s);
}
#endif

a174 3
#ifdef NT
    fp->finalize = sock_finalize;
#endif
@


1.83
log
@* ext/Win32API/Win32API.c (Win32API_Call): RSTRING()->ptr may be
  NULL.

* ext/nkf/nkf.c (rb_nkf_guess): ditto.

* ext/readline/readline.c (readline_s_set_completion_append_character):
  ditto.

* ext/socket/socket.c (sock_s_getaddrinfo, sock_s_getnameinfo):
  ditto.

* ext/tcltklib/tcltklib.c (ip_toUTF8, ip_fromUTF8): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/01 09:42:38 $
d2294 1
a2294 1
	    else if (ap, "AF_INET6") == 0) {
@


1.82
log
@* parse.y (tokadd_string): ignore backslashed spaces in %w.

* enum.c (enum_find): do not use rb_eval_cmd(); should not accept
  a string for if_none.
@
text
@d6 1
a6 1
  $Date: 2002/07/26 06:17:44 $
d2136 1
a2136 1
    char *hptr, *pptr;
d2170 2
a2171 3
    else {
	StringValue(family);
	if (strcmp(RSTRING(family)->ptr, "AF_INET") == 0) {
d2175 1
a2175 1
	else if (strcmp(RSTRING(family)->ptr, "AF_INET6") == 0) {
d2213 1
a2213 1
    char *ep;
d2289 2
a2290 3
	else {
	    StringValue(af);
	    if (strcmp(RSTRING(af)->ptr, "AF_INET") == 0) {
d2294 1
a2294 1
	    else if (strcmp(RSTRING(af)->ptr, "AF_INET6") == 0) {
@


1.81
log
@* random.c: replace with Mersenne Twister RNG.

* eval.c (jump_tag_but_local_jump): preserve retval in
  LocalJumpError exceptions.

* parse.y (command): no more check for "super outside of method".

* eval.c (rb_mod_define_method): should set last_class and
  last_func in the block->frame.

* eval.c (error_handle): should handle TAG_THROW as well.

* parse.y (yylex): new decimal notation '0d4567'.

* parse.y (yylex): new octal notation '0o777'.

* parse.y (string_content): every string_content node should
  return string only.  use NODE_EVSTR to coercing.

* eval.c (rb_eval): NODE_EVSTR support.

* re.c (rb_reg_quote): avoid unnecessary string allocation.

* string.c (get_pat): quote metachracters before compiling a
  string into a regex.

* string.c (rb_str_split_m): special treatment of strings of size
  1, but AWK emulation.  now uses get_pat().

* string.c (rb_str_match_m): quote metacharacters.

* string.c (rb_str_match2): ditto.

* ext/socket/socket.c (sock_addrinfo): make all 3 versions of
  getaddrinfo happy.  [ruby-core:00184]
@
text
@d6 1
a6 1
  $Date: 2002/06/11 07:01:17 $
d437 1
d451 2
a452 1
    str = rb_tainted_str_new(0, NUM2INT(len));
d457 1
a457 2
    RSTRING(str)->len = recvfrom(fd, RSTRING(str)->ptr, RSTRING(str)->len, flags,
				 (struct sockaddr*)buf, &alen);
d460 1
a460 1
    if (RSTRING(str)->len < 0) {
d467 4
@


1.80
log
@* eval.c (rb_eval): ruby_frame->last_func may be null, if it's
  called outside of a method.

* parse.y (arg): use INT2NUM, not INT2FIX for tUMINUS.

* parse.y (arg): unnecessary negative tPOW treatment.

* parse.y (tokadd_escape): wrong backslash escapement.

* parse.y (stmt,arg): too much void value check.

* parse.y (stmt,arg): need to check void value on rules which does
  not use node_assign().

* ext/socket/socket.c (ipaddr): need not to taint hostnames.

* range.c (range_include): should be based on "<=>", whereas
  member? still is based on "each".

* range.c (range_min,range_max): redefine methods based on "<=>".
@
text
@d6 1
a6 1
  $Date: 2002/06/04 07:34:17 $
d551 16
d617 2
a618 10
    if (socktype == 0 && flags == 0) {
	hintsp = 0;
    }
    else {
	hintsp = &hints;
	MEMZERO(&hints, struct addrinfo, 1);
	hints.ai_family = PF_UNSPEC;
	hints.ai_protocol = 0;
	hints.ai_socktype = socktype;
	hints.ai_flags = flags;
d620 7
@


1.79
log
@* string.c (rb_str_aset): should raise error if an indexing string
  is not found in the receiver.

* sprintf.c (rb_f_sprintf): "%d" should convert objects into
  integers using Integer().

* lib/tempfile.rb (Tempfile::size): added.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/03 15:50:01 $
d339 1
a339 1
    return rb_tainted_str_new(buf, len);
d356 1
a356 1
    return rb_tainted_str_new(buf, len);
d370 1
a370 1
    return rb_tainted_str_new(buf, len);
d483 1
a483 1
	return rb_assoc_new(str, rb_tainted_str_new(buf, alen));
d533 1
a533 1
    return rb_tainted_str_new2(buf);
d676 1
a676 1
	addr1 = rb_tainted_str_new2(hbuf);
d683 1
a683 1
    addr2 = rb_tainted_str_new2(hbuf);
d1081 1
a1081 1
    rb_ary_push(ary, rb_tainted_str_new2(h->h_name));
d1085 1
a1085 1
	rb_ary_push(names, rb_tainted_str_new2(*pch));
d1467 1
a1467 1
    return rb_tainted_str_new2(fptr->path);
d1680 1
a1680 1
			rb_tainted_str_new2(sockaddr->sun_path));
d1934 1
a1934 1
    return rb_assoc_new(sock2, rb_tainted_str_new(buf, len));
d1949 1
a1949 1
    return rb_assoc_new(sock2, rb_tainted_str_new(buf, len));
d1964 1
a1964 1
    return rb_tainted_str_new2(buf);
d1979 1
a1979 1
    return rb_tainted_str_new2(un.nodename);
d2007 1
a2007 1
    rb_ary_push(ary, rb_tainted_str_new2(h->h_name));
d2011 1
a2011 1
	rb_ary_push(names, rb_tainted_str_new2(*pch));
d2016 1
a2016 1
	rb_ary_push(ary, rb_tainted_str_new(*pch, h->h_length));
d2019 1
a2019 1
    rb_ary_push(ary, rb_tainted_str_new(h->h_addr, h->h_length));
d2307 1
a2307 1
    return rb_assoc_new(rb_tainted_str_new2(hbuf), rb_tainted_str_new2(pbuf));
d2337 1
d2344 3
a2346 1
    return rb_assoc_new(INT2NUM(ntohs(sockaddr->sin_port)), mkipaddr(sockaddr));
d2371 1
d2379 3
a2381 1
    return rb_tainted_str_new2(sockaddr->sun_path);
@


1.78
log
@* ext/socket/addrinfo.h: typo.

* ext/socket/getaddrinfo.c (gai_strerror): get rid of warning.

* ext/socket/socket.c (init_inetsock): ensures resources are
  freed at exceptions.

* ext/socket/socket.c (init_unixsock): ditto.

* ext/socket/socket.c (udp_connect): ditto.
@
text
@d5 2
a6 2
  $Author: H_Konishi $
  $Date: 2002/05/29 10:22:19 $
d593 1
a593 1
	snprintf(pbuf, sizeof(pbuf), "%ld", FIX2INT(port));
d681 1
a681 1
	rb_raise(rb_eSocket, "getnameinfo %s", gai_strerror(error));
@


1.77
log
@Wed May 29 18:55:47 2002  KONISHI Hiromasa <H_Konishi@@ruby-lang.org>

	* function renames my* and win32_* to rb_w32_* in win32/win32.c
	  fixed files win32/win32.c, win32/win32.h, win32/dir.h,
	              hash.c, rubysig.h, signal.c, ext/socket/socket.c
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/23 05:35:30 $
d161 5
d852 29
d882 2
a883 3
init_inetsock(sock, remote_host, remote_serv, local_host, local_serv, type)
    VALUE sock, remote_host, remote_serv, local_host, local_serv;
    int type;
d885 2
a886 1
    struct addrinfo hints, *res, *res_remote, *res_local = NULL;
d890 2
a891 2
    res_remote = sock_addrinfo(remote_host, remote_serv, SOCK_STREAM,
			       (type == INET_SERVER) ? AI_PASSIVE : 0);
d896 2
a897 3
    if (type != INET_SERVER && (!NIL_P(local_host) || !NIL_P(local_serv))) {
	res_local = sock_addrinfo(local_host, local_serv, SOCK_STREAM,
				  (type == INET_SERVER) ? AI_PASSIVE : 0);
d900 2
a901 2
    fd = -1;
    for (res = res_remote; res; res = res->ai_next) {
d908 1
d919 2
a920 2
	    if (res_local) {
		status = bind(fd, res_local->ai_addr, res_local->ai_addrlen);
a931 3
#if defined(HAVE_CLOSESOCKET)
	    closesocket(fd);
#else
d933 1
a933 2
#endif
	    fd = -1;
a938 10
	if (fd >= 0)
#if defined(HAVE_CLOSESOCKET)
	    closesocket(fd);
#else
	    close(fd);
#endif
	freeaddrinfo(res_remote);
        if (res_local) {
	    freeaddrinfo(res_local);
	}
d942 2
d948 20
a967 4
    if (res_local)
      freeaddrinfo(res_local);
    freeaddrinfo(res_remote);
    return init_sock(sock, fd);
d1207 13
d1245 9
a1253 1
        status = ruby_connect(fd, (struct sockaddr*)&sockaddr, sizeof(sockaddr), 0);
a1256 3
#if defined(HAVE_CLOSESOCKET)
	closesocket(fd);
#else
a1257 1
#endif
d1342 21
d1369 2
a1370 1
    struct addrinfo *res0, *res;
d1374 5
a1378 11
    fd = fileno(fptr->f);
    res0 = sock_addrinfo(host, port, SOCK_DGRAM, 0);
    for (res = res0; res; res = res->ai_next) {
	if (ruby_connect(fd, res->ai_addr, res->ai_addrlen, 0) >= 0) {
	    freeaddrinfo(res0);
	    return INT2FIX(0);
	}
    }

    freeaddrinfo(res0);
    rb_sys_fail("connect(2)");
@


1.76
log
@* ruby.c (proc_options): removed "-*-" support for #! line.

* io.c (rb_io_s_sysopen): new method to get a raw file
  descriptor. [new]

* ext/socket/socket.c (tcp_sysaccept): new method to return an
  accepted socket fd (integer). [new]

* ext/socket/socket.c (unix_sysaccept,sock_sysaccept): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/04/15 07:48:47 $
d172 2
a173 2
    myfdclose(fptr->f);
    if (fptr->f2) myfdclose(fptr->f2);
@


1.75
log
@* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* error.c (exc_initialize): should clear backtrace information.

* io.c (rb_io_fptr_cleanup): should close IO created by IO.new(fd).

* rubyio.h: remove FMODE_FDOPEN
@
text
@d6 1
a6 1
  $Date: 2002/04/10 08:45:24 $
d1137 1
d1155 13
d1592 13
d1866 15
d2367 1
d2395 1
d2406 1
@


1.74
log
@* variable.c (rb_obj_remove_instance_variable): raise NameError if
  specified instance variable is not defined.

* variable.c (generic_ivar_remove): modified to check ivar
  existence.

* file.c (rb_file_s_extname): new method based on the proposal
  (and patch) from Mike Hall. [new]

* eval.c (error_handle): default to 1 unless status is set.

* eval.c (ruby_options): guard error_handle() with PROT_NONE.

* eval.c (ruby_stop): ditto.

* math.c (math_acosh): added. [new]

* math.c (math_asinh): ditto.

* math.c (math_atanh): ditto.

* struct.c (rb_struct_each_pair): method added. [new]

* class.c (rb_singleton_class): wrong condition; was creating
  unnecessary singleton class.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/04/02 06:12:04 $
a204 1
    fptr->mode |= FMODE_FDOPEN;
@


1.73
log
@* ext/socket/socket.c (sock_addrinfo): should clear addrinfo hints.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/04/01 08:31:49 $
d773 1
a773 1
#if defined __CYGWIN__
d2227 4
d2258 4
@


1.72
log
@* io.c (rb_io_fptr_cleanup): need flush even when io will not be
  closed.

* io.c (rb_io_initialize): was calling wrong function
  rb_io_mode_flags().
@
text
@d6 1
a6 1
  $Date: 2002/03/28 09:17:54 $
d602 1
@


1.71
log
@* ext/socket/socket.c (sock_addrinfo): should specify socktype
  from outside.

* io.c (argf_binmode): should call next_argv() to initialize ARGF.

* io.c (argf_filename): ditto.

* io.c (argf_file): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/26 06:18:51 $
a188 1
#else
d201 7
a207 1
    return init_sock(rb_obj_alloc(klass), NUM2INT(fd));
@


1.70
log
@* parse.y (primary): while/until statement modifiers to "begin"
  statement now work as "do .. while" even when begin statement
  has "rescue" or "ensure" [new].

* parse.y (bodystmt): rescue/ensure is allowed at every bodies,
  i.e. method bodies, begin bodies, class bodies[new], and module
  bodies[new].

* ext/socket/socket.c (sock_addrinfo): should specify ai_socktype
  for getaddrinfo hints.

* eval.c (rb_f_abort): embed aborting message into exception
  object [new].

* eval.c (terminate_process): utility function for exit and abort.
@
text
@d6 1
a6 1
  $Date: 2002/03/25 06:18:07 $
d543 1
a543 1
sock_addrinfo(host, port, flags)
d545 1
a545 1
    int flags;
d547 1
a547 1
    struct addrinfo hints, *res;
d592 11
a602 5
    MEMZERO(&hints, struct addrinfo, 1);
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = flags;
    error = getaddrinfo(hostp, portp, &hints, &res);
d618 1
a618 1
    struct addrinfo *res = sock_addrinfo(name, Qnil, 0);
d851 1
a851 1
    res_remote = sock_addrinfo(remote_host, remote_serv,
d858 1
a858 1
	res_local = sock_addrinfo(local_host, local_serv,
d1279 1
a1279 1
    res0 = sock_addrinfo(host, port, 0);
d1301 1
a1301 1
    res0 = sock_addrinfo(host, port, 0);
d1333 1
a1333 1
    res0 = sock_addrinfo(host, port, 0);
d2204 1
a2204 1
    struct addrinfo *res = sock_addrinfo(host, port, 0);
@


1.69
log
@* ext/socket/socket.c (bsock_do_not_rev_lookup_set): should not be
  allowed when $SAFE > 3.

* eval.c (rb_thread_ready): THREAD_TO_KILL threads should not turn
  into THREAD_RUNNABLE on wakeup.

* eval.c (rb_thread_list): THREAD_TO_KILL threads should be in the
  list.

* eval.c (thgroup_list): ditto; by moving gid clearance from
  rb_thread_cleanup().

* dir.c (fnmatch): "*/bar" (with FNM_PATHNAME flag) does not
  match "foo/bar".

* io.c (read_all): files on /proc filesystem with zero stat size,
  may have contents.

* ext/socket/socket.c (tcp_s_gethostbyname): refactored.

* ext/socket/socket.c (sock_s_gethostbyname): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/22 07:35:02 $
d594 1
@


1.68
log
@socket.c: oops, half-baked modifies were commited; backout
@
text
@d6 1
a6 1
  $Date: 2002/03/22 07:26:37 $
d128 1
a128 1
rb_getaddrinfo(nodename, servname, hints, res)
d158 1
a158 1
#define getaddrinfo(node,serv,hints,res) rb_getaddrinfo((node),(serv),(hints),(res))
d498 1
d543 1
a543 1
ip_addrsetup(host, port)
d545 1
d566 1
a566 1
	if (*name == 0) {
d594 1
a594 2
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_CANONNAME;
d609 1
a609 1
    struct sockaddr *addr;
d611 1
a611 1
    struct addrinfo *res = ip_addrsetup(name, Qnil);
a825 1
    hints.ai_socktype = SOCK_STREAM;
d844 2
a845 2
    load_addr_info(remote_host, remote_serv, type, &res_remote);

d850 4
a853 2
    if (type != INET_SERVER && (!NIL_P(local_host) || !NIL_P(local_serv)))
	load_addr_info(local_host, local_serv, type, &res_local);
d974 4
a977 3
static VALUE
tcp_s_gethostbyname(obj, host)
    VALUE obj, host;
a980 3
    char **pch;
    VALUE ary, names;
    size_t size;
d983 1
a983 13
    if (rb_obj_is_kind_of(host, rb_cInteger)) {
	long i = NUM2LONG(host);
	struct sockaddr_in *sin;

	sin = (struct sockaddr_in*)&addr;
	MEMZERO(sin, struct sockaddr_in, 1);
	sin->sin_family = AF_INET;
	SET_SIN_LEN(sin, sizeof(*sin));
	sin->sin_addr.s_addr = htonl(i);
    }
    else {
	setipaddr(host, &addr);
    }
d985 1
a985 1
    case AF_INET:
d995 1
a995 1
    case AF_INET6:
d1005 1
a1005 1
    default:
d1007 1
d1018 12
d1039 3
a1041 10
    for (pch = h->h_addr_list; *pch; pch++)
	;
    pch++;
    size = (char*)pch - (char*)h->h_addr_list;
    pch = (char**)alloca(size);
    memcpy((char*)pch, (char *)h->h_addr_list, size);
    size = h->h_length;
    for (; *pch && h; pch++) {
	switch (addr.ss_family) {
	  case AF_INET: {
d1047 1
a1047 4
	    memcpy((char*)&sin.sin_addr, *pch, size);
	    h = gethostbyaddr((char*)&sin.sin_addr,
			      sizeof(sin.sin_addr),
			      sin.sin_family);
d1052 1
a1052 1
	  case AF_INET6: {
d1056 1
a1056 1
	    sin6.sin6_family = AF_INET;
a1060 3
	    h = gethostbyaddr((char*)&sin6.sin6_addr,
			      sizeof(sin6.sin6_addr),
			      sin6.sin6_family);
a1065 1
	    h = NULL;
d1272 1
a1272 1
    res0 = ip_addrsetup(host, port);
d1294 1
a1294 1
    res0 = ip_addrsetup(host, port);
d1326 1
a1326 1
    res0 = ip_addrsetup(host, port);
d1867 1
a1867 1
mkhostent(h)
a1920 4
/*
 * NOTE: using gethostbyname() against AF_INET6 is a bad idea, as it
 * does not initialize sin_flowinfo nor sin_scope_id properly.
 */
d1925 1
a1925 41
    struct sockaddr_storage addr;
    struct hostent *h;

    if (rb_obj_is_kind_of(host, rb_cInteger)) {
	long i = NUM2LONG(host);
	struct sockaddr_in *sin;
	sin = (struct sockaddr_in*)&addr;
	MEMZERO(sin, struct sockaddr_in, 1);
	sin->sin_family = AF_INET;
	SET_SIN_LEN(sin, sizeof(*sin));
	sin->sin_addr.s_addr = htonl(i);
    }
    else {
	setipaddr(host, (struct sockaddr*)&addr);
    }
    switch (addr.ss_family) {
    case AF_INET:
      {
	struct sockaddr_in *sin;
	sin = (struct sockaddr_in*)&addr;
	h = gethostbyaddr((char*)&sin->sin_addr,
			  sizeof(sin->sin_addr),
			  sin->sin_family);
	break;
      }
#ifdef INET6
    case AF_INET6:
      {
	struct sockaddr_in6 *sin6;
	sin6 = (struct sockaddr_in6*)&addr;
	h = gethostbyaddr((char*)&sin6->sin6_addr,
			  sizeof(sin6->sin6_addr),
			  sin6->sin6_family);
	break;
      }
#endif
    default:
	h = NULL;
    }

    return mkhostent(h);
d1950 1
a1950 1
    return mkhostent(h);
d2197 1
a2197 1
    struct addrinfo *res = ip_addrsetup(host, port);
@


1.67
log
@* the VMS support patch submitted by Akiyoshi, Masamichi
  <Masamichi.Akiyoshi@@jp.compaq.com> is merged.

* eval.c (exec_under): changing ruby_class is OK, but should not
  alter cbase.

* eval.c (yield_under_i): ditto.
@
text
@d5 2
a6 2
  $Author: akr $
  $Date: 2002/02/28 21:30:53 $
a975 1
#if 0
a1087 27
#else

    struct addrinfo hints, *res, *r;
    VALUE ary, names;
    int error;

    rb_secure(3);
    MEMZERO(&hints, struct addrinfo, 1);
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    r = res = ip_addrsetup(host, Qnil);
    ary = rb_ary_new();
    rb_ary_push(ary, rb_tainted_str_new2(r->ai_canonname));
    r = r->ai_next;
    names = rb_ary_new();
    rb_ary_push(ary, names);
    rb_ary_push(ary, INT2NUM(res->ai_family));
    for (r = res; r; r = r->ai_next) {
	if (r != res) {
	    rb_ary_push(names, rb_tainted_str_new2(r->ai_canonname));
	}
	rb_ary_push(ary, mkipaddr(r->ai_addr));
    }
    freeaddrinfo(res);

    return ary;
#endif
@


1.66
log
@* ext/socket/extconf.rb (have_struct_member): new method.
check msg_control and msg_accrights in struct msghdr.  check sys/uio.h.

* socket/socket.c: include sys/uio.h if available.
(thread_read_select): new function.
(unix_send_io): ditto.
(unix_recv_io): ditto.
(unix_s_socketpair): ditto.
(Init_socket): define UNIXSocket#send_io, UNIXSocket#recv_io,
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/19 14:22:27 $
d404 1
a404 1
static VALUE ipaddr _((struct sockaddr *));
d406 1
a406 1
static VALUE unixaddr _((struct sockaddr_un *));
d468 1
a468 1
	return rb_assoc_new(str, ipaddr((struct sockaddr *)buf));
d471 1
a471 1
	return rb_assoc_new(str, unixaddr((struct sockaddr_un *)buf));
d538 1
a538 1
    mkipaddr0((struct sockaddr *)&sin, buf, len);
d593 1
d976 1
d981 1
d988 1
a988 1
	sin = (struct sockaddr_in *)&addr;
d1001 2
a1002 2
	sin = (struct sockaddr_in *)&addr;
	h = gethostbyaddr((char *)&sin->sin_addr,
d1011 2
a1012 2
	sin6 = (struct sockaddr_in6 *)&addr;
	h = gethostbyaddr((char *)&sin6->sin6_addr,
d1025 1
a1025 1
	rb_raise(rb_eSocket, "%s", (char *)hsterror(h_errno));
d1039 8
a1046 1
    for (pch = h->h_addr_list; *pch; pch++) {
d1048 1
a1048 2
	case AF_INET:
	  {
d1050 1
d1054 2
a1055 2
	    memcpy((char *) &sin.sin_addr, *pch, h->h_length);
	    h = gethostbyaddr((char *)&sin.sin_addr,
d1058 1
a1058 1
	    rb_ary_push(ary, mkipaddr((struct sockaddr *)&sin));
d1062 1
a1062 2
	case AF_INET6:
	  {
d1064 1
d1070 2
a1071 2
	    memcpy((char *) &sin6.sin6_addr, *pch, h->h_length);
	    h = gethostbyaddr((char *)&sin6.sin6_addr,
d1074 1
a1074 1
	    rb_ary_push(ary, mkipaddr((struct sockaddr *)&sin6));
d1078 1
a1078 1
	default:
d1080 1
d1084 2
a1085 2
    memcpy((char *)&addr.sin_addr, h->h_addr, h->h_length);
    rb_ary_push(ary, mkipaddr((struct sockaddr *)&addr));
d1089 27
d1243 1
a1243 1
    return ipaddr((struct sockaddr *)&addr);
d1258 1
a1258 1
    return ipaddr((struct sockaddr *)&addr);
d1277 1
a1277 1
    return mkipaddr((struct sockaddr *)&addr);
d1917 1
a1917 1
	rb_raise(rb_eSocket, "%s", (char *)hstrerror(h_errno));
d1976 1
a1976 1
	sin = (struct sockaddr_in *)&addr;
d1983 1
a1983 1
	setipaddr(host, (struct sockaddr *)&addr);
d1989 2
a1990 2
	sin = (struct sockaddr_in *)&addr;
	h = gethostbyaddr((char *)&sin->sin_addr,
d1999 2
a2000 2
	sin6 = (struct sockaddr_in6 *)&addr;
	h = gethostbyaddr((char *)&sin6->sin6_addr,
d2168 1
a2168 1
	if (RSTRING(sa)->len != SA_LEN((struct sockaddr *)&ss)) {
d2171 1
a2171 1
	sap = (struct sockaddr *)&ss;
@


1.65
log
@* io.c (fptr_finalize): should raise error when fclose fails.

* eval.c (method_inspect): proper output format to distinguish
  methods and singleton methods.
@
text
@d23 4
d691 11
d1400 155
d1737 20
d2370 4
@


1.64
log
@* eval.c (rb_eval): need not to clar method cache for NODE_CLASS,
  NODE_SCLASS.

* gc.c (obj_free): need not to clear method cache on class/module
  finalization.
@
text
@d6 1
a6 1
  $Date: 2002/01/18 14:23:47 $
d195 7
a1543 7
sock_s_for_fd(klass, fd)
    VALUE klass, fd;
{
    return init_sock(rb_obj_alloc(klass), NUM2INT(fd));
}

static VALUE
d2126 1
a2188 1
    rb_define_singleton_method(rb_cSocket, "for_fd", sock_s_for_fd, 1);
@


1.63
log
@* io.c (rb_io_s_new): block check moved from initialize to this
  method.

* io.c (rb_io_s_open): open should call initialize too. IO#for_fd
  also calls initialize. [new]

* error.c (rb_sys_fail): replace INT2FIX() by INT2NUM() since
  errno value may not fit in Fixnum size on Hurd.

* error.c (set_syserr): ditto.

* dir.c (dir_s_glob): returns nil if block given.

* io.c (rb_io_each_byte): should return self.

* io.c (rb_io_close_m): close check added.

* dir.c (dir_seek): should return pos.

* parse.y (fixpos): orig may be (NODE*)1, which should not be
  dereferenced.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2002/01/18 01:13:58 $
d1365 1
a1365 1
    return open_unix(sock, path, 1);
d1560 2
a1561 1
    return rb_assoc_new(sock_new(klass, sp[0]), sock_new(klass, sp[1]));
@


1.62
log
@* ext/socket/socket.c (tcp_svr_s_open): fix typo.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/17 08:04:59 $
a911 9
static VALUE
tcp_s_open(argc, argv, klass)
     int argc;
     VALUE *argv;
     VALUE klass;
{
    return tcp_init(argc, argv, rb_obj_alloc(klass));
}

a926 7
static VALUE
socks_s_open(klass, host, serv)
    VALUE klass, host, serv;
{
    return socks_init(rb_obj_alloc(klass), host, serv);
}

a1072 9
tcp_svr_s_open(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    return tcp_svr_init(argc, argv, rb_obj_alloc(klass));
}

static VALUE
a1242 9
udp_s_open(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    return udp_init(argc, argv, rb_obj_alloc(klass));
}

static VALUE
a1330 7
unix_s_sock_open(klass, path)
    VALUE klass, path;
{
    return init_unixsock(rb_obj_alloc(klass), path, 0);
}

static VALUE
a1536 7
sock_s_open(klass, domain, type, protocol)
    VALUE klass, domain, type, protocol;
{
    return init_sock(rb_obj_alloc(klass), domain, type, protocol);
}

static VALUE
a2118 1
    rb_undef_method(CLASS_OF(rb_cBasicSocket), "open");
a2144 1
    rb_define_singleton_method(rb_cTCPSocket, "open", tcp_s_open, -1);
a2150 1
    rb_define_singleton_method(rb_cSOCKSSocket, "open", socks_s_open, 2);
a2158 1
    rb_define_singleton_method(rb_cTCPServer, "open", tcp_svr_s_open, -1);
a2164 1
    rb_define_singleton_method(rb_cUDPSocket, "open", udp_s_open, -1);
a2172 1
    rb_define_singleton_method(rb_cUNIXSocket, "open", unix_s_sock_open, 1);
a2180 1
    rb_define_singleton_method(rb_cUNIXServer, "open", unix_svr_s_open, 1);
a2186 1
    rb_define_singleton_method(rb_cSocket, "open", sock_s_open, 3);
@


1.61
log
@* eval.c (block_pass): allow "retry" from within argument passed
  block. [new]

* eval.c (localjump_error): should preserve exit status in the
  exception object. [new]

* eval.c (proc_invoke): should raise exception for "break" if it's
  yielding, not calling. [new]

* eval.c (block_pass): should NOT raise exception for "break". [new]

* eval.c (block_pass): should allow block argument relay even in
  the tainted mode.

* ext/socket/socket.c: support subclassing by proper "initialize"
  calling convention. [new]
@
text
@d6 1
a6 1
  $Date: 2001/12/19 07:48:32 $
d1094 1
a1094 1
    return tcp_svr_s_init(argc, argv, rb_obj_alloc(klass));
@


1.60
log
@* eval.c (rb_mod_define_method): define_method should follow
  default method visibility.

* eval.c (rb_attr): should warn if the default method visibility
  is "module_function" (can be error).

* eval.c (rb_mod_define_method): should define class/module method
  also if the visibility is "module_function".

* eval.c (rb_mod_define_method): should call hook method
  "method_added", and "singleton_method_added".

* string.c: use RESIZE_CAPA for capacity change.

* ext/socket/socket.c (Init_socket): add listen method to
  TCPServer and UNIXServer.

* ext/socket/socket.c (bsock_send): should raise EWOULDBLOCK
  exception.

* ext/socket/socket.c (s_recvfrom): ditto.

* ext/socket/socket.c (s_accept): ditto.

* ext/socket/socket.c (udp_send): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/12/18 08:47:02 $
d175 2
a176 2
sock_new(class, fd)
    VALUE class;
a179 1
    VALUE sock = rb_obj_alloc(class);
d813 2
a814 2
open_inet(class, remote_host, remote_serv, local_host, local_serv, type)
    VALUE class, remote_host, remote_serv, local_host, local_serv;
d892 1
a892 1
    return sock_new(class, fd);
d896 1
a896 1
tcp_s_open(argc, argv, class)
d899 1
a899 1
     VALUE class;
d908 3
a910 4
    SafeStringValue(remote_host);
    if (!NIL_P(local_host)) {
	SafeStringValue(local_host);
    }
d912 7
a918 2
    return open_inet(class, remote_host, remote_serv,
		     local_host, local_serv, INET_CLIENT);
d923 2
a924 2
socks_s_open(class, host, serv)
    VALUE class, host, serv;
d933 8
a940 2
    SafeStringValue(host);
    return open_inet(class, host, serv, Qnil, Qnil, INET_SOCKS);
d1075 1
a1075 1
tcp_svr_s_open(argc, argv, class)
d1078 1
a1078 1
    VALUE class;
d1083 1
a1083 1
	return open_inet(class, arg1, arg2, NULL, Qnil, INET_SERVER);
d1085 10
a1094 1
	return open_inet(class, Qnil, arg1, NULL, Qnil, INET_SERVER);
d1098 2
a1099 2
s_accept(class, fd, sockaddr, len)
    VALUE class;
d1131 1
a1131 1
    return sock_new(class, fd2);
d1150 2
a1151 2
open_unix(class, path, server)
    VALUE class;
a1156 1
    VALUE sock;
d1188 1
a1188 1
    sock = sock_new(class, fd);
d1246 1
a1246 1
udp_s_open(argc, argv, class)
d1249 1
a1249 1
    VALUE class;
d1264 10
a1273 1
    return sock_new(class, fd);
d1365 8
a1372 1
unix_s_sock_open(sock, path)
d1375 1
a1375 1
    return open_unix(sock, path, 0);
d1396 8
a1403 1
unix_svr_s_open(sock, path)
d1563 2
a1564 2
sock_s_open(class, domain, type, protocol)
    VALUE class, domain, type, protocol;
d1574 8
a1581 1
    return sock_new(class, fd);
d1585 2
a1586 2
sock_s_for_fd(class, fd)
    VALUE class, fd;
d1588 1
a1588 1
    return sock_new(class, NUM2INT(fd));
d1592 2
a1593 2
sock_s_socketpair(class, domain, type, protocol)
    VALUE class, domain, type, protocol;
d1608 1
a1608 1
    return rb_assoc_new(sock_new(class, sp[0]), sock_new(class, sp[1]));
a2166 1
    rb_undef_method(CLASS_OF(rb_cBasicSocket), "new");
d2168 1
a2194 1
    rb_define_singleton_method(rb_cTCPSocket, "new", tcp_s_open, -1);
d2196 1
d2202 1
a2202 1
    rb_define_singleton_method(rb_cSOCKSSocket, "new", socks_s_open, 2);
a2210 1
    rb_define_singleton_method(rb_cTCPServer, "new", tcp_svr_s_open, -1);
d2212 1
d2218 1
a2218 1
    rb_define_singleton_method(rb_cUDPSocket, "new", udp_s_open, -1);
d2227 1
a2227 1
    rb_define_singleton_method(rb_cUNIXSocket, "new", unix_s_sock_open, 1);
d2236 1
a2236 1
    rb_define_singleton_method(rb_cUNIXServer, "new", unix_svr_s_open, 1);
a2242 1
    rb_define_singleton_method(rb_cSocket, "new", sock_s_open, 3);
d2245 1
@


1.59
log
@* string.c (rb_str_replace): swap arguments of OBJ_INFECT.

* eval.c (rb_thread_schedule): should not select a thread which is
  not yet initialized.

* time.c (time_plus): wrong boundary check.

* time.c (time_minus): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/10/29 05:07:20 $
a387 6
	  case EWOULDBLOCK:
#if EAGAIN != EWOULDBLOCK
	  case EAGAIN:
#endif
	    rb_thread_fd_writable(fd);
	    goto retry;
a444 6

	  case EWOULDBLOCK:
#if EAGAIN != EWOULDBLOCK
	  case EAGAIN:
#endif
	    goto retry;
a1109 6

	  case EWOULDBLOCK:
#if EAGAIN != EWOULDBLOCK
	  case EAGAIN:
#endif
	    goto retry;
a1329 7

	  case EWOULDBLOCK:
#if EAGAIN != EWOULDBLOCK
	  case EAGAIN:
#endif
	    rb_thread_fd_writable(fileno(f));
	    goto retry;
d2166 1
d2191 1
@


1.58
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* variable.c (rb_cvar_set): empty iv_tbl may cause infinite loop.

* variable.c (rb_cvar_get): ditto.

* variable.c (cvar_override_check): ditto.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.

* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/10/04 05:32:09 $
d564 1
a564 1
	Check_SafeStr(host);
d796 1
a796 1
	Check_SafeStr(h);
d807 1
a807 1
	Check_SafeStr(serv);
d921 1
a921 2
    Check_SafeStr(remote_host);

d923 1
a923 1
	Check_SafeStr(local_host);
d942 1
a942 1
    Check_SafeStr(host);
d1152 1
a1152 1
    struct RString *path;
d1160 1
a1160 1
    Check_SafeStr(path);
d1168 1
a1168 1
    strncpy(sockaddr.sun_path, path->ptr, sizeof(sockaddr.sun_path)-1);
d1191 1
a1191 1
    fptr->path = strdup(path->ptr);
d1468 1
a1468 1
	Check_SafeStr(domain);
d1517 1
a1517 1
	Check_SafeStr(type);
d1599 1
a1599 1
    Check_Type(addr, T_STRING);
d1617 1
a1617 1
    Check_Type(addr, T_STRING);
@


1.57
log
@* ext/socket/socket.c (ruby_connect): EALREADY is the equivalent
  for EINPROGRESS in ws2_32.lib.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/03 07:19:17 $
d852 1
d856 1
@


1.56
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/10/02 04:31:21 $
d750 1
a757 1
	      case EALREADY:
d759 1
a759 1
		if (--wait_in_progress > 0) {
@


1.55
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* string.c (rb_str_subpat_set): support function for new argument
  pattern String#[re,offset] = val. [new]

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_aref_m): new argument pattern
  String#[re,offset]. [new]

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* array.c (rb_ary_initialize): Array.new([1,2,3]) => [1,2,3]. [new]

* string.c (rb_str_reverse): should return an instance of
  receiver's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.

* eval.c (eval): retrieves file, line information from binding.

* eval.c (intersect_fds): counts intersecting fds.

* eval.c (rb_thread_schedule): only fds requested by
  each thread count as select_value.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/09/05 22:18:56 $
d180 1
a180 2
    NEWOBJ(sock, struct RFile);
    OBJSETUP(sock, class, T_FILE);
d192 1
a192 1
    return (VALUE)sock;
@


1.54
log
@* ext/socket/socket.c (Init_socket): remove duplicating constants.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/09/05 06:54:55 $
d1437 2
d1454 2
@


1.53
log
@* re.c (Init_Regexp): to_s to be alias to inspect.

* parse.y (yylex): should support 'keyword='.

* ruby.c (proc_options): should not adjust argc/argv if -e option
  is supplied.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/08/16 04:54:31 $
a2566 23
#endif

#ifdef IP_MULTICAST_IF
    sock_define_const("IP_MULTICAST_IF", IP_MULTICAST_IF);
#endif
#ifdef IP_MULTICAST_TTL
    sock_define_const("IP_MULTICAST_TTL", IP_MULTICAST_TTL);
#endif
#ifdef IP_MULTICAST_LOOP
    sock_define_const("IP_MULTICAST_LOOP", IP_MULTICAST_LOOP);
#endif
#ifdef IP_ADD_MEMBERSHIP
    sock_define_const("IP_ADD_MEMBERSHIP", IP_ADD_MEMBERSHIP);
#endif

#ifdef IP_DEFAULT_MULTICAST_TTL
    sock_define_const("IP_DEFAULT_MULTICAST_TTL", IP_DEFAULT_MULTICAST_TTL);
#endif
#ifdef IP_DEFAULT_MULTICAST_LOOP
    sock_define_const("IP_DEFAULT_MULTICAST_LOOP", IP_DEFAULT_MULTICAST_LOOP);
#endif
#ifdef IP_MAX_MEMBERSHIPS
    sock_define_const("IP_MAX_MEMBERSHIPS", IP_MAX_MEMBERSHIPS);
@


1.52
log
@* ext/socket/socket.c (s_recvfrom): fix typo.
@
text
@d6 1
a6 1
  $Date: 2001/08/16 00:54:54 $
d440 1
a441 1
  retry:
a456 1
	    rb_thread_wait_fd(fd);
d1104 3
d1110 1
a1126 1
	    rb_thread_wait_fd(fd);
d2318 159
@


1.51
log
@* ext/socket/socket.c (s_recvform): avoid VC++6 warning.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/08/06 06:10:10 $
d480 1
a480 1
	rb_bug("s_recvform called with bad value");
@


1.50
log
@* socket.c: wrap UNIX code by ifdef HAVE_SYS_UN_H.
@
text
@d6 1
a6 1
  $Date: 2001/08/06 03:05:19 $
d479 2
@


1.49
log
@* string.c (rb_str_lstrip_bang): new method.

* string.c (rb_str_rstrip_bang): new method.

* string.c (rb_str_associate): should consider STR_ASSOC too.

* eval.c (rb_undefined): do not recurse if method_missing is
  undefined.

* process.c (proc_waitpid): now all arguments are optional.

* process.c (Init_process): waitpid is now alias to wait.

* process.c (Init_process): waitpid2 is now alias to wait2.

* process.c (rb_waitpid): made public.

* ext/pty/pty.c (pty_getpty): avoid disturbing SIGCHLD using
  thread and rb_waitpid.

* process.c (proc_getpgrp): now takes no argument on all
  platforms.

* process.c (proc_setpgrp): ditto.

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::pack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::pack_sockaddr_un(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::unpack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::unpack_sockaddr_un(). [new]
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/07/31 08:02:57 $
d2082 11
a2108 10
sock_s_unpack_sockaddr_in(self, addr)
    VALUE self, addr;
{
    struct sockaddr_in * sockaddr;

    sockaddr = (struct sockaddr_in*)StringValuePtr(addr);
    return rb_assoc_new(INT2NUM(ntohs(sockaddr->sin_port)), mkipaddr(sockaddr));
}

static VALUE
d2118 1
d2230 3
a2233 1
    rb_define_singleton_method(rb_cSocket, "pack_sockaddr_in", sock_s_pack_sockaddr_in, 2);
a2234 1
    rb_define_singleton_method(rb_cSocket, "unpack_sockaddr_in", sock_s_unpack_sockaddr_in, 1);
d2236 1
@


1.48
log
@* process.c (last_status_set): nothing returned, should be void.

* ext/socket/socket.c (load_addr_info): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/07/18 05:56:05 $
d1565 1
a1565 1
#if !defined(NT) && !defined(__BEOS__) && !defined(__EMX__)
d1809 2
d1813 10
a1822 3
    StringValue(addr);
    h = gethostbyaddr(RSTRING(addr)->ptr, RSTRING(addr)->len,
		      NIL_P(type)?AF_INET:NUM2INT(type));
d2067 51
d2227 6
@


1.47
log
@* regex.c (NUM_FAILURE_ITEMS): was confusing NUM_REG_ITEMS and
  NUM_NONREG_ITEMS, which have happened to be same value.

* class.c (rb_class_new): subclass check moved to this function.

* class.c (rb_class_boot): check less version of rb_class_new().

* eval.c (proc_invoke): should preserve iter status for embedded
  frame in the block.

* file.c (rb_file_s_expand_path): may overrun buffer on stack.

* string.c (rb_str_insert): forgot to call rb_str_modify().
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/07/12 06:16:49 $
d719 1
a719 1
#ifdef O_NDELAY 
d784 1
a784 1
static VALUE
d823 1
a824 1
}
d841 2
a842 2
      load_addr_info(local_host, local_serv, type, &res_local);
      
d914 1
a914 1
  
d920 1
a920 1
  
d940 1
a940 1
	
@


1.46
log
@* ext/socket/socket.c (ruby_connect): workaround for the setup of
  Cygwin socket(EALREADY).
@
text
@d6 1
a6 1
  $Date: 2001/06/22 15:48:59 $
d773 2
@


1.45
log
@* ext/socket/socket.c (ruby_connect): typo
@
text
@d6 1
a6 1
  $Date: 2001/06/22 14:44:03 $
d712 3
d750 1
a750 6
		{
		    struct timeval tv;
		    tv.tv_sec = 0;
		    tv.tv_usec = 100000;
		    rb_thread_wait_for(tv);
		}
d755 11
@


1.44
log
@* ext/socket/socket.c (ruby_connect): workaround for the setup of
  Cygwin socket.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/06/22 09:12:22 $
d751 1
a751 1
		    rb_thread_wait_for(&tv);
@


1.43
log
@* eval.c (rb_yield_0): no mvalue_to_svalue conversion here.

* eval.c (massign): takes svalue, convert it to mvalue inside.

* eval.c (rb_eval): parameters for yield/return are always
  svalues now.

* eval.c (svalue_to_mvalue): more strict conversion.

* eval.c (mvalue_to_svalue): ditto.

* st.c (new_size): prime hash size enabled.

* ext/socket/socket.c (Init_socket): SO_* constants added.
@
text
@d6 1
a6 1
  $Date: 2001/05/06 15:03:48 $
d746 8
@


1.42
log
@forgot some checkins.
@
text
@d6 1
a6 1
  $Date: 2001/03/21 03:41:43 $
d2261 44
@


1.41
log
@* gc.c (id2ref): sometimes confused symbol and reference.

* dir.c (glob_helper): breaks loop after calling recusive
  glob_helper; all wild cards should be consumed; no need for
  further match.

* dir.c (dir_s_glob): gives warning if no match found.

* object.c (sym_inspect): did allocate extra byte space.

* marshal.c (shortlen): shortlen should return number of bytes
  written.

* eval.c (ev_const_defined): need not to check if cbase->nd_class
  is rb_cObject.

* eval.c (ev_const_get): ditto.

* time.c (time_zone): return "UTC" for UTC time objects.

* eval.c (THREAD_ALLOC): flags should be initialized.

* signal.c (rb_f_kill): should use FIX2INT, not FIX2UINT.
@
text
@d6 1
a6 1
  $Date: 2001/02/16 07:53:21 $
d158 2
d289 4
a292 1
	v = rb_str2cstr(val, &vlen);
d361 1
a361 1
    VALUE msg, to;
a365 2
    char *m, *t;
    int mlen, tlen;
d368 1
a368 1
    rb_scan_args(argc, argv, "21", &msg, &flags, &to);
d375 1
a375 1
    m = rb_str2cstr(msg, &mlen);
d377 3
a379 3
	t = rb_str2cstr(to, &tlen);
	n = sendto(fd, m, mlen, NUM2INT(flags),
		   (struct sockaddr*)t, tlen);
d382 1
a382 1
	n = send(fd, m, mlen, NUM2INT(flags));
d588 2
a589 2
	Check_SafeStr(port);
	portp = STR2CSTR(port);
a1300 2
    char *m;
    int mlen;
d1312 1
a1312 1
    m = rb_str2cstr(mesg, &mlen);
d1315 2
a1316 2
	n = sendto(fileno(f), m, mlen, NUM2INT(flags), res->ai_addr,
		    res->ai_addrlen);
d1788 1
a1788 4
    VALUE vaddr, vtype;
    int type;
    int alen;
    char *addr;
d1791 4
a1794 10
    rb_scan_args(argc, argv, "11", &vaddr, &vtype);
    addr = rb_str2cstr(vaddr, &alen);
    if (!NIL_P(vtype)) {
	type = NUM2INT(vtype);
    }
    else {
	type = AF_INET;
    }

    h = gethostbyaddr(addr, alen, type);
d1811 1
a1811 1
    else proto = STR2CSTR(protocol);
d1813 2
a1814 1
    sp = getservbyname(STR2CSTR(service), proto);
d1819 1
a1819 1
	char *s = STR2CSTR(service);
a1826 1
    
d1847 1
a1847 1
	strncpy(hbuf, STR2CSTR(host), sizeof(hbuf));
d1859 1
a1859 1
	strncpy(pbuf, STR2CSTR(port), sizeof(pbuf));
d1871 5
a1875 3
    else if (strcmp(STR2CSTR(family), "AF_INET") == 0) {
	hints.ai_family = PF_INET;
    }
d1877 4
a1880 2
    else if (strcmp(STR2CSTR(family), "AF_INET6") == 0) {
	hints.ai_family = PF_INET6;
a1881 1
#endif
d1965 1
a1965 1
	    strncpy(hbuf, STR2CSTR(host), sizeof(hbuf));
d1979 1
a1979 1
	    strncpy(pbuf, STR2CSTR(port), sizeof(pbuf));
d1991 5
a1995 3
	else if (strcmp(STR2CSTR(af), "AF_INET") == 0) {
	    hints.ai_family = PF_INET;
	}
d1997 4
a2000 2
	else if (strcmp(STR2CSTR(af), "AF_INET6") == 0) {
	    hints.ai_family = PF_INET6;
a2001 1
#endif
@


1.40
log
@* io.c (set_outfile): f should be the FILE* from the assigning value.

* ext/socket/socket.c (tcp_s_open): should not give default value
  to local_host.

* time.c (time_s_times): move to Process::times.

* file.c (rb_file_s_lchmod): new method File::lchmod.

* file.c (rb_file_s_lchown): new method File::lchown.
@
text
@d6 1
a6 1
  $Date: 2001/02/15 06:00:58 $
d1831 1
a1831 1
	    rb_raise(rb_eSocket, "no such servce %s/%s", s, proto);
@


1.39
log
@* process.c (proc_waitall): new method based on a patch from Brian
  Fundakowski Feldman <green@@green.dyndns.org>.

* process.c (last_status_set): objectify $? value (Process::Status).
@
text
@d6 1
a6 1
  $Date: 2001/02/13 05:09:06 $
a897 1

a902 4
    if (NIL_P(local_serv)) {
	local_serv = INT2NUM(0);
    }
      
@


1.38
log
@* io.c (rb_io_ctl): do not call ioctl/fcntl for f2, if f and f2
  have same fileno.

* eval.c (rb_load): raise LocaJumpError if unexpected local jumps
  appear during load.

* ext/socket/socket.c (bsock_close_read): don't call rb_thread_fd_close();
  it's supposed to be called by io_io_close().

* ext/socket/socket.c (bsock_close_read): do not modify f and f2.

* ext/socket/socket.c (bsock_close_write): ditto.

* ext/socket/socket.c (sock_new): avoid dup(2) on sockets.

* parse.y (primary): preserve and clear in_single and in_def using
  stack to prevent nested method errors in singleton class bodies.
@
text
@d6 1
a6 1
  $Date: 2001/02/08 09:19:21 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.37
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_options): new method to give an option values.

* parse.y (cond0): disable special treating of integer literal in
  conditional unless option -e is supplied.  changes current
  behavior.  experimental.

* parse.y (cond0): give warning for string/integer literals and
  dot operators in conditionals unless option -e is supplied.

* re.c (rb_reg_equal): all option flags should be same to be equal.

* error.c (Init_Exception): make Interrupt a subclass of
  SignalException.
@
text
@d6 1
a6 1
  $Date: 2001/01/18 08:43:10 $
a184 1
    fd = myfddup(fd);
a185 1
    fd = dup(fd);
d234 1
a234 1
    if (fptr->f2 == 0) {
a236 1
    rb_thread_fd_close(fileno(fptr->f));
a237 7
#ifdef NT
    myfdclose(fptr->f);
#else
    fclose(fptr->f);
#endif
    fptr->f = fptr->f2;
    fptr->f2 = 0;
d252 1
a252 1
    if (fptr->f2 == 0) {
a256 6
#ifdef NT
    myfdclose(fptr->f2);
#else
    fclose(fptr->f2);
#endif
    fptr->f2 = 0;
@


1.36
log
@* io.c (rb_io_s_read): new method to call IO#read from
  pathname.  In addition, it accepts third optional argument to
  specify starting point.
@
text
@d6 1
a6 1
  $Date: 2000/11/17 04:41:19 $
d779 2
a780 2
open_inet(class, h, serv, type)
    VALUE class, h, serv;
d782 1
d784 1
a784 3
    struct addrinfo hints, *res, *res0;
    int fd, status;
    char *syscall;
d786 1
a786 1
    char *host;
d789 1
a789 1
    if (h) {
d813 1
a813 1
    error = getaddrinfo(host, portp, &hints, &res0);
d818 19
d838 1
a838 1
    for (res = res0; res; res = res->ai_next) {
d853 10
a862 3
	    status = ruby_connect(fd, res->ai_addr, res->ai_addrlen,
				  (type == INET_SOCKS));
	    syscall = "connect(2)";
d883 4
a886 1
	freeaddrinfo(res0);
d894 3
a896 1
    freeaddrinfo(res0);
d901 25
a925 5
tcp_s_open(class, host, serv)
    VALUE class, host, serv;
{
    Check_SafeStr(host);
    return open_inet(class, host, serv, INET_CLIENT);
d941 1
a941 1
    return open_inet(class, host, serv, INET_SOCKS);
d1084 1
a1084 1
	return open_inet(class, arg1, arg2, INET_SERVER);
d1086 1
a1086 1
	return open_inet(class, 0, arg1, INET_SERVER);
d2106 2
a2107 2
    rb_define_singleton_method(rb_cTCPSocket, "open", tcp_s_open, 2);
    rb_define_singleton_method(rb_cTCPSocket, "new", tcp_s_open, 2);
@


1.35
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/16 16:56:59 $
d423 1
a423 1
    RECV_SOCKET,		/* Socket#recvfrom */
@


1.35.2.1
log
@* st.c (new_size): prime hash size enabled.

* ext/socket/socket.c (Init_socket): SO_* constants added.
@
text
@d6 1
a6 1
  $Date: 2000/11/17 04:41:19 $
a2233 44
#endif
#ifdef SO_PASSCRED
    sock_define_const("SO_PASSCRED", SO_PASSCRED);
#endif
#ifdef SO_PEERCRED
    sock_define_const("SO_PEERCRED", SO_PEERCRED);
#endif
#ifdef SO_RCVLOWAT
    sock_define_const("SO_RCVLOWAT", SO_RCVLOWAT);
#endif
#ifdef SO_SNDLOWAT
    sock_define_const("SO_SNDLOWAT", SO_SNDLOWAT);
#endif
#ifdef SO_RCVTIMEO
    sock_define_const("SO_RCVTIMEO", SO_RCVTIMEO);
#endif
#ifdef SO_SNDTIMEO
    sock_define_const("SO_SNDTIMEO", SO_SNDTIMEO);
#endif

#ifdef SO_SECURITY_AUTHENTICATION
    sock_define_const("SO_SECURITY_AUTHENTICATION", SO_SECURITY_AUTHENTICATION);
#endif
#ifdef SO_SECURITY_ENCRYPTION_TRANSPORT
    sock_define_const("SO_SECURITY_ENCRYPTION_TRANSPORT", SO_SECURITY_ENCRYPTION_TRANSPORT);
#endif
#ifdef SO_SECURITY_ENCRYPTION_NETWORK
    sock_define_const("SO_SECURITY_ENCRYPTION_NETWORK", SO_SECURITY_ENCRYPTION_NETWORK);
#endif

#ifdef SO_BINDTODEVICE
    sock_define_const("SO_BINDTODEVICE", SO_BINDTODEVICE);
#endif
#ifdef SO_ATTACH_FILTER
    sock_define_const("SO_ATTACH_FILTER", SO_ATTACH_FILTER);
#endif
#ifdef SO_DETACH_FILTER
    sock_define_const("SO_DETACH_FILTER", SO_DETACH_FILTER);
#endif
#ifdef SO_PEERNAME
    sock_define_const("SO_PEERNAME", SO_PEERNAME);
#endif
#ifdef SO_TIMESTAMP
    sock_define_const("SO_TIMESTAMP", SO_TIMESTAMP);
@


1.35.2.2
log
@* ext/socket/socket.c (ruby_connect): workaround for the setup of
  Cygwin socket.
@
text
@d6 1
a6 1
  $Date: 2001/06/22 08:15:56 $
a758 8
#if defined __CYGWIN__
		{
		    struct timeval tv;
		    tv.tv_sec = 0;
		    tv.tv_usec = 100000;
		    rb_thread_wait_for(&tv);
		}
#endif
@


1.35.2.3
log
@* ext/socket/socket.c (ruby_connect): typo
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/06/22 14:44:44 $
d764 1
a764 1
		    rb_thread_wait_for(tv);
@


1.35.2.4
log
@* ext/socket/socket.c (ruby_connect): workaround for the setup of
  Cygwin socket(EALREADY).
@
text
@d6 1
a6 1
  $Date: 2001/06/22 15:49:08 $
a724 3
#if defined __CYGWIN__
    int wait_in_progress = -1;
#endif
d760 6
a765 1
		wait_in_progress = 10;
a769 11

#if defined __CYGWIN__
	      case EALREADY:
	      case EINVAL:
		if (--wait_in_progress > 0) {
		    struct timeval tv = {0, 100000};
		    rb_thread_wait_for(tv);
		    continue;
		}
		break;
#endif
@


1.35.2.5
log
@* ruby.c (proc_options): should not adjust argc/argv if -e option
  is supplied.
@
text
@d6 1
a6 1
  $Date: 2001/07/12 06:15:23 $
d453 1
a454 1
    rb_thread_wait_fd(fd);
d470 1
a1068 3
#if defined(_nec_ews)
    fd2 = accept(fd, sockaddr, len);
#else
a1071 1
#endif
d1088 1
@


1.35.2.6
log
@010906
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/09/05 06:53:29 $
a490 2
      default:
	rb_bug("s_recvfrom called with bad value");
a784 2
	      default:
		break;
d1535 1
a1535 1
#if !defined(NT) && !defined(__BEOS__) && !defined(__EMX__) && !defined(__QNXNTO__)
a2216 159
#ifdef	IPPROTO_IP
    sock_define_const("IPPROTO_IP", IPPROTO_IP);
#else
    sock_define_const("IPPROTO_IP", 0);
#endif
#ifdef	IPPROTO_ICMP
    sock_define_const("IPPROTO_ICMP", IPPROTO_ICMP);
#else
    sock_define_const("IPPROTO_ICMP", 1);
#endif
#ifdef	IPPROTO_IGMP
    sock_define_const("IPPROTO_IGMP", IPPROTO_IGMP);
#endif
#ifdef	IPPROTO_GGP
    sock_define_const("IPPROTO_GGP", IPPROTO_GGP);
#endif
#ifdef	IPPROTO_TCP
    sock_define_const("IPPROTO_TCP", IPPROTO_TCP);
#else
    sock_define_const("IPPROTO_TCP", 6);
#endif
#ifdef	IPPROTO_EGP
    sock_define_const("IPPROTO_EGP", IPPROTO_EGP);
#endif
#ifdef	IPPROTO_PUP
    sock_define_const("IPPROTO_PUP", IPPROTO_PUP);
#endif
#ifdef	IPPROTO_UDP
    sock_define_const("IPPROTO_UDP", IPPROTO_UDP);
#else
    sock_define_const("IPPROTO_UDP", 17);
#endif
#ifdef	IPPROTO_IDP
    sock_define_const("IPPROTO_IDP", IPPROTO_IDP);
#endif
#ifdef	IPPROTO_HELLO
    sock_define_const("IPPROTO_HELLO", IPPROTO_HELLO);
#endif
#ifdef	IPPROTO_ND
    sock_define_const("IPPROTO_ND", IPPROTO_ND);
#endif
#ifdef	IPPROTO_TP
    sock_define_const("IPPROTO_TP", IPPROTO_TP);
#endif
#ifdef	IPPROTO_XTP
    sock_define_const("IPPROTO_XTP", IPPROTO_XTP);
#endif
#ifdef	IPPROTO_EON
    sock_define_const("IPPROTO_EON", IPPROTO_EON);
#endif
#ifdef	IPPROTO_BIP
    sock_define_const("IPPROTO_BIP", IPPROTO_BIP);
#endif
/**/
#ifdef	IPPROTO_RAW
    sock_define_const("IPPROTO_RAW", IPPROTO_RAW);
#else
    sock_define_const("IPPROTO_RAW", 255);
#endif
#ifdef	IPPROTO_MAX
    sock_define_const("IPPROTO_MAX", IPPROTO_MAX);
#endif

	/* Some port configuration */
#ifdef	IPPORT_RESERVED
    sock_define_const("IPPORT_RESERVED", IPPORT_RESERVED);
#else
    sock_define_const("IPPORT_RESERVED", 1024);
#endif
#ifdef	IPPORT_USERRESERVED
    sock_define_const("IPPORT_USERRESERVED", IPPORT_USERRESERVED);
#else
    sock_define_const("IPPORT_USERRESERVED", 5000);
#endif
	/* Some reserved IP v.4 addresses */
#ifdef	INADDR_ANY
    sock_define_const("INADDR_ANY", INADDR_ANY);
#else
    sock_define_const("INADDR_ANY", 0x00000000);
#endif
#ifdef	INADDR_BROADCAST
    sock_define_const("INADDR_BROADCAST", INADDR_BROADCAST);
#else
    sock_define_const("INADDR_BROADCAST", 0xffffffff);
#endif
#ifdef	INADDR_LOOPBACK
    sock_define_const("INADDR_LOOPBACK", INADDR_LOOPBACK);
#else
    sock_define_const("INADDR_LOOPBACK", 0x7F000001);
#endif
#ifdef	INADDR_UNSPEC_GROUP
    sock_define_const("INADDR_UNSPEC_GROUP", INADDR_UNSPEC_GROUP);
#else
    sock_define_const("INADDR_UNSPEC_GROUP", 0xe0000000);
#endif
#ifdef	INADDR_ALLHOSTS_GROUP
    sock_define_const("INADDR_ALLHOSTS_GROUP", INADDR_ALLHOSTS_GROUP);
#else
    sock_define_const("INADDR_ALLHOSTS_GROUP", 0xe0000001);
#endif
#ifdef	INADDR_MAX_LOCAL_GROUP
    sock_define_const("INADDR_MAX_LOCAL_GROUP", INADDR_MAX_LOCAL_GROUP);
#else
    sock_define_const("INADDR_MAX_LOCAL_GROUP", 0xe00000ff);
#endif
#ifdef	INADDR_NONE
    sock_define_const("INADDR_NONE", INADDR_NONE);
#else
    sock_define_const("INADDR_NONE", 0xffffffff);
#endif
	/* IP [gs]etsockopt options */
#ifdef	IP_OPTIONS
    sock_define_const("IP_OPTIONS", IP_OPTIONS);
#endif
#ifdef	IP_HDRINCL
    sock_define_const("IP_HDRINCL", IP_HDRINCL);
#endif
#ifdef	IP_TOS
    sock_define_const("IP_TOS", IP_TOS);
#endif
#ifdef	IP_TTL
    sock_define_const("IP_TTL", IP_TTL);
#endif
#ifdef	IP_RECVOPTS
    sock_define_const("IP_RECVOPTS", IP_RECVOPTS);
#endif
#ifdef	IP_RECVRETOPTS
    sock_define_const("IP_RECVRETOPTS", IP_RECVRETOPTS);
#endif
#ifdef	IP_RECVDSTADDR
    sock_define_const("IP_RECVDSTADDR", IP_RECVDSTADDR);
#endif
#ifdef	IP_RETOPTS
    sock_define_const("IP_RETOPTS", IP_RETOPTS);
#endif
#ifdef	IP_MULTICAST_IF
    sock_define_const("IP_MULTICAST_IF", IP_MULTICAST_IF);
#endif
#ifdef	IP_MULTICAST_TTL
    sock_define_const("IP_MULTICAST_TTL", IP_MULTICAST_TTL);
#endif
#ifdef	IP_MULTICAST_LOOP
    sock_define_const("IP_MULTICAST_LOOP", IP_MULTICAST_LOOP);
#endif
#ifdef	IP_ADD_MEMBERSHIP
    sock_define_const("IP_ADD_MEMBERSHIP", IP_ADD_MEMBERSHIP);
#endif
#ifdef	IP_DROP_MEMBERSHIP
    sock_define_const("IP_DROP_MEMBERSHIP", IP_DROP_MEMBERSHIP);
#endif
#ifdef	IP_DEFAULT_MULTICAST_TTL
    sock_define_const("IP_DEFAULT_MULTICAST_TTL", IP_DEFAULT_MULTICAST_TTL);
#endif
#ifdef	IP_DEFAULT_MULTICAST_LOOP
    sock_define_const("IP_DEFAULT_MULTICAST_LOOP", IP_DEFAULT_MULTICAST_LOOP);
#endif
#ifdef	IP_MAX_MEMBERSHIPS
    sock_define_const("IP_MAX_MEMBERSHIPS", IP_MAX_MEMBERSHIPS);
#endif
d2307 23
@


1.35.2.7
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* string.c (rb_str_reverse): should return an instance of
  reciever's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/09/06 09:32:10 $
a1406 2
    if (len == 0)
        addr.sun_path[0] = '\0';
a1421 2
    if (len == 0)
        addr.sun_path[0] = '\0';
@


1.35.2.8
log
@* ext/socket/socket.c (ruby_connect): EALREADY is the equivalent
  for EINPROGRESS in ws2_32.lib.
@
text
@d6 1
a6 1
  $Date: 2001/10/02 04:24:26 $
a763 1
	      case EALREADY:
d771 1
d773 1
a773 1
		if (wait_in_progress-- > 0) {
@


1.35.2.9
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/10/04 05:30:32 $
a847 1
#ifndef NT
a850 1
#endif
@


1.35.2.10
log
@* eval.c (rb_mod_define_method): define_method should follow
  default method visibility.

* eval.c (rb_attr): should warn if the default method visibility
  is "module_function" (can be error).

* eval.c (rb_mod_define_method): should define class/module method
  also if the visibility is "module_function".

* eval.c (rb_mod_define_method): should call hook method
  "method_added", and "singleton_method_added".

* ext/socket/socket.c (bsock_send): should raise EWOULDBLOCK
  exception.

* ext/socket/socket.c (s_recvfrom): ditto.

* ext/socket/socket.c (s_accept): ditto.

* ext/socket/socket.c (udp_send): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/29 05:04:43 $
d402 6
d465 6
d1092 6
d1319 7
@


1.35.2.11
log
@* ext/socket/socket.c (bsock_do_not_rev_lookup_set): should not be
  allowed when $SAFE > 3.

* dir.c (fnmatch): "*/bar" (with FNM_PATHNAME flag) does not
  match "foo/bar".

* io.c (read_all): files on /proc filesystem with zero stat size,
  may have contents.

* eval.c (exec_under): changing ruby_class is OK, but should not
  alter cbase.

* eval.c (yield_under_i): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/12/19 07:45:30 $
a501 1
    rb_secure(4);
@


1.35.2.12
log
@* ext/socket/addrinfo.h: typo.

* ext/socket/getaddrinfo.c (gai_strerror): get rid of warning.

* ext/socket/socket.c (init_inetsock): ensures resources are
  freed at exceptions.

* ext/socket/socket.c (init_unixsock): ditto.

* ext/socket/socket.c (udp_connect): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/25 06:16:02 $
a156 5
#ifdef HAVE_CLOSESOCKET
#undef close
#define close closesocket
#endif

d787 3
a789 5
struct inetsock_arg
{
    VALUE sock;
    VALUE host, serv;
    struct addrinfo *res;
a790 20
    int fd;
};

static VALUE
inetsock_cleanup(arg)
    struct inetsock_arg *arg;
{
    if (arg->res) {
	freeaddrinfo(arg->res);
	arg->res = 0;
    }
    if (arg->fd >= 0) {
	close(arg->fd);
    }
    return Qnil;
}

static VALUE
open_inet_internal(arg)
    struct inetsock_arg *arg;
d792 1
a792 2
    int type = arg->type;
    struct addrinfo hints, *res;
d799 3
a801 3
    if (arg->host) {
	Check_SafeStr(arg->host);
	host = RSTRING(arg->host)->ptr;
d806 2
a807 2
    if (FIXNUM_P(arg->serv)) {
	snprintf(pbuf, sizeof(pbuf), "%ld", FIX2UINT(arg->serv));
d811 4
a814 4
	Check_SafeStr(arg->serv);
	if (RSTRING(arg->serv)->len >= sizeof(pbuf))
	    rb_raise(rb_eArgError, "servicename too long (%d)", RSTRING(arg->serv)->len);
	strcpy(pbuf, RSTRING(arg->serv)->ptr);
d820 1
a820 1
    if (arg->type == INET_SERVER) {
d823 1
a823 1
    error = getaddrinfo(host, portp, &hints, &arg->res);
d829 1
a829 1
    for (res = arg->res; res; res = res->ai_next) {
a835 1
	arg->fd = fd;
d852 3
d856 2
a857 1
	    arg->fd = fd = -1;
d863 7
d877 2
a878 17
    return sock_new(arg->sock, fd);
}

static VALUE
open_inet(class, h, serv, type)
    VALUE class, h, serv;
    int type;
{
    struct inetsock_arg arg;
    arg.sock = class;
    arg.host = h;
    arg.serv = serv;
    arg.res = 0;
    arg.type = type;
    arg.fd = -1;
    return rb_ensure(open_inet_internal, (VALUE)&arg,
		     inetsock_cleanup, (VALUE)&arg);
a1101 13
struct unixsock_arg {
    struct sockaddr_un *sockaddr;
    int fd;
};

static VALUE
unixsock_connect_internal(arg)
    struct unixsock_arg *arg;
{
    return (VALUE)ruby_connect(arg->fd, arg->sockaddr, sizeof(*arg->sockaddr),
			       0);
}

d1128 1
a1128 9
	int prot;
	struct unixsock_arg arg;
	arg.sockaddr = &sockaddr;
	arg.fd = fd;
        status = rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);
	if (prot) {
	    close(fd);
	    rb_jump_tag(prot);
	}
d1132 3
d1136 1
a1220 21
struct udp_arg
{
    struct addrinfo *res;
    int fd;
};

static VALUE
udp_connect_internal(arg)
    struct udp_arg *arg;
{
    int fd = arg->fd;
    struct addrinfo *res;

    for (res = arg->res; res; res = res->ai_next) {
	if (ruby_connect(fd, res->ai_addr, res->ai_addrlen, 0) >= 0) {
	    return Qtrue;
	}
    }
    return Qfalse;
}

d1227 1
a1227 2
    struct udp_arg arg;
    VALUE ret;
d1232 10
a1241 5
    arg.res = ip_addrsetup(host, port);
    arg.fd = fileno(fptr->f);
    ret = rb_ensure(udp_connect_internal, (VALUE)&arg,
		    RUBY_METHOD_FUNC(freeaddrinfo), (VALUE)arg.res);
    if (!ret) rb_sys_fail("connect(2)");
@


1.35.2.13
log
@backport miss.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/03 15:52:16 $
a889 2

    arg->fd = -1;
@


1.35.2.14
log
@* string.c (rb_str_aset): should raise error if an indexing string
  is not found in the receiver.

* sprintf.c (rb_f_sprintf): "%d" should convert objects into
  integers using Integer().
@
text
@d6 1
a6 1
  $Date: 2002/06/04 04:47:04 $
d592 1
a592 1
	snprintf(pbuf, sizeof(pbuf), "%d", FIX2INT(port));
d672 1
a672 1
	rb_raise(rb_eSocket, "getnameinfo: %s", gai_strerror(error));
@


1.35.2.15
log
@* eval.c (rb_eval): ruby_frame->last_func may be null, if it's
  called outside of a method.

* parse.y (arg): use INT2NUM, not INT2FIX for tUMINUS.

* parse.y (arg): $1 may be null for tPOW.

* parse.y (stmt,arg): too much void value check.

* parse.y (arg): need to check void value on rules which does not
  use node_assign().

* ext/socket/socket.c (ipaddr): need not to taint hostnames.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/04 07:11:54 $
d337 1
a337 1
    return rb_str_new(buf, len);
d354 1
a354 1
    return rb_str_new(buf, len);
d368 1
a368 1
    return rb_str_new(buf, len);
d483 1
a483 1
	return rb_assoc_new(str, rb_str_new(buf, alen));
d533 1
a533 1
    return rb_str_new2(buf);
d667 1
a667 1
	addr1 = rb_str_new2(hbuf);
d674 1
a674 1
    addr2 = rb_str_new2(hbuf);
d1019 1
a1019 1
    rb_ary_push(ary, rb_str_new2(h->h_name));
d1023 1
a1023 1
	rb_ary_push(names, rb_str_new2(*pch));
d1401 1
a1401 1
    return rb_str_new2(fptr->path);
d1439 1
a1439 1
			rb_str_new2(sockaddr->sun_path));
d1694 1
a1694 1
    return rb_str_new2(buf);
d1709 1
a1709 1
    return rb_str_new2(un.nodename);
d1737 1
a1737 1
    rb_ary_push(ary, rb_str_new2(h->h_name));
d1741 1
a1741 1
	rb_ary_push(names, rb_str_new2(*pch));
d1746 1
a1746 1
	rb_ary_push(ary, rb_str_new(*pch, h->h_length));
d1749 1
a1749 1
    rb_ary_push(ary, rb_str_new(h->h_addr, h->h_length));
d2075 1
a2075 1
    return rb_assoc_new(rb_str_new2(hbuf), rb_str_new2(pbuf));
@


1.35.2.16
log
@* ext/socket/socket.c (s_recvfrom): update RSTRING len.
@
text
@d6 1
a6 1
  $Date: 2002/06/11 06:58:39 $
a436 1
    long slen;
d450 1
a450 2
    slen = NUM2INT(len);
    str = rb_tainted_str_new(0, slen);
d455 2
a456 1
    slen = recvfrom(fd, RSTRING(str)->ptr, slen, flags, (struct sockaddr*)buf, &alen);
d459 1
a459 1
    if (slen < 0) {
a465 4
    }
    if (slen < RSTRING(str)->len) {
	RSTRING(str)->len = slen;
	RSTRING(str)->ptr[slen] = '\0';
@


1.35.2.17
log
@	* ext/socket/socket.c (sock_new): duplicate underlying socket
	  handle not only descriptor.  [ruby-talk:40015]

	* ext/socket/socket.c (bsock_close_read, bsock_close_write): not
	  use myfdclose().

	* win32/win32.c, win32/win32.h (myfddup, myfdclose): delete.
@
text
@d6 1
a6 1
  $Date: 2002/08/01 16:22:39 $
d162 15
d188 4
d193 1
d246 3
d250 1
d272 3
d276 1
@


1.35.2.18
log
@* array.c, class.c, eval.c, file.c, gc.c, node.h, numeric.c,
  object.c, parse.y, range.c, re.c, string.c, struct.c, util.c,
  ext/socket/socket.c: merge from 1.7: treat long values as long
  instead of int.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/10/01 15:25:49 $
d818 1
a818 1
	    rb_raise(rb_eArgError, "servicename too long (%ld)", RSTRING(arg->serv)->len);
d1984 1
a1984 1
	    rb_raise(rb_eArgError, "array size should be 3 or 4, %ld given",
@


1.34
log
@001117
@
text
@d6 1
a6 1
  $Date: 2000/11/16 07:24:18 $
a771 1
	mode &= ~NONBLOCKING;	/* needed? */
@


1.33
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/08 05:29:35 $
d772 1
@


1.32
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/24 06:21:42 $
d185 1
@


1.31
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/10 04:49:18 $
a770 1
	mode &= ~NONBLOCKING;
@


1.30
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/04 04:17:22 $
d1047 1
d1057 6
@


1.29
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/29 07:41:59 $
d24 5
a28 1
#include <sys/socket.h>
@


1.28
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/28 08:26:58 $
d522 1
a522 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
d608 1
a608 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
d665 1
a665 1
	    rb_raise(rb_eSocket, "%s", gai_strerror(error));
d672 1
a672 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
d812 1
a812 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
d1859 1
a1859 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
d1965 1
a1965 1
	if (error) goto error_exit;
d1974 1
a1974 1
    if (error) goto error_exit;
d1982 1
a1982 1
	    if (error) goto error_exit;
d1992 1
a1992 1
  error_exit:
d1994 5
a1998 1
    rb_raise(rb_eSocket, "%s", gai_strerror(error));
@


1.27
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/05/30 04:24:06 $
d107 1
a107 1
#if defined(INET6) && (defined(LOOKUP_ORDER_HACK_INET) || defined(LOOKUP_ORDER_HACK_INET))
d384 1
a384 1
    if (RTEST(to)) {
a613 9
static VALUE
ip_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom(sock, argc, argv, RECV_IP);
}

d1162 9
d1262 1
a1262 1
    if (argc == 2) {
@


1.26
log
@2000-05-30
@
text
@d6 1
a6 1
  $Date: 2000/05/25 05:55:11 $
d416 1
a416 2
    RECV_TCP,			/* TCPSocket#recvfrom */
    RECV_UDP,			/* UDPSocket#recvfrom */
d422 1
a422 1
s_recv(sock, argc, argv, from)
d474 1
a474 2
      case RECV_TCP:
      case RECV_UDP:
d496 1
a496 1
    return s_recv(sock, argc, argv, RECV_RECV);
d614 9
d645 3
d656 9
d666 2
a667 1
	family = 0;
a1090 9
static VALUE
tcp_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recv(sock, argc, argv, RECV_TCP);
}

a1297 9
static VALUE
udp_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recv(sock, argc, argv, RECV_UDP);
}

d1336 1
a1336 1
    return s_recv(sock, argc, argv, RECV_UNIX);
d1579 1
a1579 1
    return s_recv(sock, argc, argv, RECV_SOCKET);
d1833 8
a1840 2
    if (!NIL_P(family)) {
	hints.ai_family = NUM2INT(family);
d1842 3
a1844 2
    else {
	hints.ai_family = PF_UNSPEC;
d1846 2
d1975 12
a1986 10
    for (r = res->ai_next; r; r = r->ai_next) {
	char hbuf2[1024], pbuf2[1024];

	sap = r->ai_addr;
	error = getnameinfo(sap, SA_LEN(sap), hbuf2, sizeof(hbuf2),
			    pbuf2, sizeof(pbuf2), fl);
	if (error) goto error_exit;
	if (strcmp(hbuf, hbuf2) != 0|| strcmp(pbuf, pbuf2) != 0) {
	    freeaddrinfo(res);
	    rb_raise(rb_eSocket, "sockaddr resolved to multiple nodename");
d1988 1
a1989 1
    freeaddrinfo(res);
d2036 1
a2043 1
    rb_define_method(rb_cTCPSocket, "recvfrom", tcp_recvfrom, -1);
a2067 1
    rb_define_method(rb_cUDPSocket, "recvfrom", udp_recvfrom, -1);
@


1.25
log
@2000-05-25
@
text
@d6 1
a6 1
  $Date: 2000/05/22 05:30:25 $
d107 9
a115 10
#define LOOKUP_ORDER_UNSPEC	0
#define LOOKUP_ORDER_INET	1
#define LOOKUP_ORDER_INET6	2

#if   defined(DEFAULT_LOOKUP_ORDER_UNSPEC)
# define LOOKUP_ORDER_DEFAULT LOOKUP_ORDER_UNSPEC
#elif defined(DEFAULT_LOOKUP_ORDER_INET)
# define LOOKUP_ORDER_DEFAULT LOOKUP_ORDER_INET
#elif defined(DEFAULT_LOOKUP_ORDER_INET6)
# define LOOKUP_ORDER_DEFAULT LOOKUP_ORDER_INET6
a116 7

#ifdef INET6
#define LOOKUP_ORDERS		3
int lookup_order_table[LOOKUP_ORDERS][LOOKUP_ORDERS] = {
  {PF_UNSPEC, PF_UNSPEC, PF_UNSPEC},	/* 0:unspec */
  {PF_INET, PF_INET6, PF_UNSPEC},	/* 1:inet inet6 */
  {PF_INET6, PF_INET, PF_UNSPEC}	/* 2:inet6 inet */
a118 22
static int lookup_order = LOOKUP_ORDER_DEFAULT;

static VALUE
lookup_order_get(self)
    VALUE self;
{
    return INT2FIX(lookup_order);
}

static VALUE
lookup_order_set(self, order)
    VALUE self, order;
{
    int n = NUM2INT(order);

    if (n < 0 || LOOKUP_ORDERS <= n) {
	rb_raise(rb_eArgError, "invalid value for lookup_order");
    }
    lookup_order = n;
    return order;
}

d129 4
d134 1
a134 1
	af = lookup_order_table[lookup_order][i];
d150 1
a150 14
#else
static VALUE
lookup_order_get(self)
    VALUE self;
{
    return INT2FIX(LOOKUP_ORDER_DEFAULT);
}

static VALUE
lookup_order_set(self, order)
    VALUE self, order;
{
    return order;
}
a604 1
#ifndef INET6
a605 3
#else
    error = rb_getaddrinfo(hostp, portp, &hints, &res);
#endif
a798 1
#ifndef INET6
a799 3
#else
    error = rb_getaddrinfo(host, portp, &hints, &res0);
#endif
a1833 1
#ifndef INET6
a1836 1
#endif
a1845 1
#ifndef INET6
a1846 8
#else
    if (!NIL_P(family)) {
      error = getaddrinfo(hptr, pptr, &hints, &res);
    }
    else {
      error = rb_getaddrinfo(hptr, pptr, &hints, &res);
    }
#endif
a1861 1
    static char hbuf[1024], pbuf[1024];
d1863 1
d1865 1
a1865 1
    struct addrinfo hints, *res = NULL;
d1869 1
a1877 1

d1889 1
d1902 7
d1914 1
d1923 1
a1930 1
	    fl |= NI_NUMERICSERV;
d1937 9
a1945 2
	MEMZERO(&hints, struct addrinfo, 1);
	if (strcmp(STR2CSTR(af), "AF_INET") == 0) {
a1952 3
	else {
	    hints.ai_family = PF_UNSPEC;
	}
d1954 1
a1954 3
	if (error) {
	    rb_raise(rb_eSocket, "%s", gai_strerror(error));
	}
d1963 12
a1974 2
    if (error) {
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
d1976 2
a1977 2
    if (res)
	freeaddrinfo(res);
d1979 3
a1981 1
    return rb_assoc_new(rb_tainted_str_new2(hbuf), rb_tainted_str_new2(pbuf));
a2141 6

    sock_define_const("LOOKUP_INET", LOOKUP_ORDER_INET);
    sock_define_const("LOOKUP_INET6", LOOKUP_ORDER_INET6);
    sock_define_const("LOOKUP_UNSPEC", LOOKUP_ORDER_UNSPEC);
    rb_define_singleton_method(rb_cBasicSocket, "lookup_order", lookup_order_get, 0);
    rb_define_singleton_method(rb_cBasicSocket, "lookup_order=", lookup_order_set, 1);
@


1.24
log
@socket security bug
@
text
@d6 1
a6 1
  $Date: 2000/05/18 04:32:12 $
d107 3
a109 3
#define LOOKUP_ORDER_INET	0
#define LOOKUP_ORDER_INET6	1
#define LOOKUP_ORDER_UNSPEC	2
d1931 5
d1976 1
a1976 1
	else if (!NIL_P(port)) {
d1979 1
a2005 5
    }

    fl = 0;
    if (!NIL_P(flags)) {
	fl = NUM2INT(flags);
@


1.23
log
@2000-05-18
@
text
@d6 1
a6 1
  $Date: 2000/05/17 06:33:50 $
d143 1
a143 1
	rb_raise(rb_eRuntimeError, "invalid value for lookup_order");
d321 1
d366 1
a366 1
    return rb_str_new(buf, len);
d383 1
a383 1
    return rb_str_new(buf, len);
d397 1
a397 1
    return rb_str_new(buf, len);
d486 1
a486 1
    str = rb_str_new(0, NUM2INT(len));
d527 1
a527 1
	return rb_assoc_new(str, rb_str_new(buf, alen));
d561 1
a561 2
    error = getnameinfo(addr, SA_LEN(addr), buf, len, NULL, 0,
			NI_NUMERICHOST);
d574 1
a574 1
    return rb_str_new2(buf);
d611 1
a611 1
	char *name = STR2CSTR(host);
d613 2
d621 1
a621 1
	else if (strlen(name) > sizeof(hbuf)-1) {
d637 1
d699 1
a699 1
	addr1 = rb_str_new2(hbuf);
d706 1
a706 1
    addr2 = rb_str_new2(hbuf);
d830 4
a833 1
	strcpy(pbuf, STR2CSTR(serv));
d957 1
d961 1
d1005 1
a1005 1
    rb_ary_push(ary, rb_str_new2(h->h_name));
d1009 1
a1009 1
	rb_ary_push(names, rb_str_new2(*pch));
d1080 1
d1226 1
d1246 1
d1269 1
d1301 1
d1309 1
a1309 1
  retry:
d1365 1
a1365 1
    return rb_str_new2(fptr->path);
d1402 2
a1403 1
    return rb_assoc_new(rb_str_new2("AF_UNIX"),rb_str_new2(sockaddr->sun_path));
d1445 1
d1494 1
d1531 1
d1610 1
d1639 1
a1639 1
    return rb_assoc_new(sock2, rb_str_new(buf, len));
d1649 1
d1654 1
a1654 1
    return rb_str_new2(buf);
d1665 1
a1665 1
  struct utsname un;
d1667 3
a1669 2
  uname(&un);
  return rb_str_new2(un.nodename);
d1697 1
a1697 1
    rb_ary_push(ary, rb_str_new2(h->h_name));
d1701 1
a1701 1
	rb_ary_push(names, rb_str_new2(*pch));
d1706 1
a1706 1
	rb_ary_push(ary, rb_str_new(*pch, h->h_length));
d1709 1
a1709 1
    rb_ary_push(ary, rb_str_new(h->h_addr, h->h_length));
d2015 1
a2015 1
    return rb_ary_new3(2, rb_str_new2(hbuf), rb_str_new2(pbuf));
@


1.22
log
@thread problems
@
text
@d6 1
a6 1
  $Date: 2000/05/12 09:07:51 $
d107 85
d641 1
d643 3
d729 11
d784 1
a784 1
		rb_thread_fd_writable(fd);
d836 1
d838 3
d1312 1
a1312 1
	    thread_write_select(fileno(f));
d1835 1
a1835 2
    rb_scan_args(argc, argv, "24", &host, &port, &family, &socktype, &protocol,
		 &flags);
d1861 1
d1865 1
d1875 1
d1877 8
d2156 6
@


1.21
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/09 04:53:10 $
a623 11
static void
thread_write_select(fd)
    int fd;
{
    fd_set fds;

    FD_ZERO(&fds);
    FD_SET(fd, &fds);
    rb_thread_select(fd+1, 0, &fds, 0, 0);
}

d684 1
a684 1
		thread_write_select(fd);
@


1.20
log
@2000-05-09
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:35 $
d18 5
d546 1
a546 1
	snprintf(pbuf, sizeof(pbuf), "%d", FIX2INT(port));
d734 1
a734 1
	snprintf(pbuf, sizeof(pbuf), "%d", FIX2UINT(serv));
d1756 1
a1756 1
	snprintf(pbuf, sizeof(pbuf), "%d", FIX2INT(port));
d1796 1
a1796 1
    VALUE sa, af, host, port, flags;
d1832 4
d1849 1
a1849 1
	    snprintf(pbuf, sizeof(pbuf), "%d", NUM2INT(port));
a1883 1
  gotsap:
@


1.19
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/03/07 08:37:56 $
d8 2
@


1.18
log
@2000-03-07
@
text
@d6 1
a6 1
  $Date: 2000/03/06 04:15:40 $
d184 1
a184 1
    free(fptr->f);
d210 1
a210 1
    free(fptr->f2);
d259 2
a260 1
    int level, option, len;
d284 1
a284 1
    int len = sizeof buf;
d298 1
a298 1
    int len = sizeof buf;
d378 1
a378 1
    int fd, alen = sizeof buf;
d380 1
a380 1
    int flags;
d767 3
d771 1
d779 3
d783 1
d968 1
a968 1
    int *len;
d1001 1
a1001 1
    int fromlen;
d1049 3
d1053 1
d1073 1
a1073 1
    int len = sizeof addr;
d1088 1
a1088 1
    int len = sizeof addr;
d1247 1
a1247 1
	int len = sizeof(addr);
d1277 1
a1277 1
    int fromlen;
d1298 1
a1298 1
    int len = sizeof addr;
d1313 1
a1313 1
    int len = sizeof addr;
d1516 1
a1516 1
    int len = sizeof buf;
@


1.17
log
@2000-03-06
@
text
@d6 1
a6 1
  $Date: 2000/02/29 08:05:30 $
a29 7
#endif

#ifdef USE_CWGUSI
extern int fileno(FILE *stream); /* <unix.mac.h> */
extern int rb_thread_select(int, fd_set*, fd_set*, fd_set*, struct timeval*); /* thread.c */
# include <sys/errno.h>
# include <GUSI.h>
@


1.16
log
@2000-02-29
@
text
@d6 1
a6 1
  $Date: 2000/02/17 07:11:20 $
d533 3
d557 3
@


1.15
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:48:59 $
d522 1
d536 1
a537 1
    hostp = hbuf;
@


1.14
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:12:16 $
d89 1
a89 1
#define _SS_ALIGNSIZE	(sizeof(long long))
d102 1
a102 1
	long long __ss_align;	/* force desired structure storage alignment */
@


1.13
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:37:48 $
d402 1
a403 1
  retry:
@


1.12
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/08 05:00:22 $
d84 21
a104 4
#ifndef INET6
# undef  ss_family
# define sockaddr_storage	sockaddr
# define ss_family		sa_family
@


1.11
log
@2000-01-08
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:37:17 $
d376 6
a383 2
    GetOpenFile(sock, fptr);
    fd = fileno(fptr->f);
@


1.10
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:49:56 $
d95 2
d98 1
a98 1

d100 2
a101 1
    if(fptr->f2) myfdclose(fptr->f2);
@


1.9
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/10/20 07:10:23 $
a94 3
    SOCKET s;
	extern int errno;

d97 2
a98 6
	myfdclose(fptr->f);
	if(fptr->f2)  myfdclose(fptr->f);
/*
	s = get_osfhandle(fileno(fptr->f));
    closesocket(s);
*/
@


1.8
log
@marshal load GC protect
@
text
@d6 1
a6 1
  $Date: 1999/10/18 09:03:01 $
a117 1
    rb_secure(4);
d142 3
a144 1
    rb_secure(4);
d167 3
a169 1
    rb_secure(4);
d194 3
a196 1
    rb_secure(4);
a222 1
    rb_secure(2);
d801 3
@


1.7
log
@19991018
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:35 $
d19 1
a19 1
#ifdef NETINET_TCP
d22 1
a22 1
#ifdef NETINET_UDP
@


1.6
log
@19991012
@
text
@d6 1
a6 1
  $Date: 1999/10/04 04:51:08 $
d893 1
d895 1
@


1.6.2.1
log
@19991208
@
text
@d6 1
a6 1
  $Date: 1999/10/20 07:10:23 $
d19 1
a19 1
#ifdef HAVE_NETINET_TCP_H
d22 1
a22 1
#ifdef HAVE_NETINET_UDP_H
a892 1
#ifdef SIN6_LEN
a893 1
#endif
@


1.6.2.2
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/07 16:47:18 $
d96 1
d99 5
a103 3
    s = get_osfhandle(fileno(fptr->f));
    myfdclose(fptr->f);
    if (fptr->f2) myfdclose(fptr->f2);
d105 1
@


1.6.2.3
log
@2000-01-24
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:41:14 $
d84 4
a87 21
#ifndef HAVE_SOCKADDR_STORAGE
/*
 * RFC 2553: protocol-independent placeholder for socket addresses
 */
#define _SS_MAXSIZE	128
#define _SS_ALIGNSIZE	(sizeof(long long))
#define _SS_PAD1SIZE	(_SS_ALIGNSIZE - sizeof(unsigned char) * 2)
#define _SS_PAD2SIZE	(_SS_MAXSIZE - sizeof(unsigned char) * 2 - \
				_SS_PAD1SIZE - _SS_ALIGNSIZE)

struct sockaddr_storage {
#ifdef HAVE_SA_LEN
	unsigned char ss_len;		/* address length */
	unsigned char ss_family;	/* address family */
#else
	unsigned short ss_family;
#endif
	char	__ss_pad1[_SS_PAD1SIZE];
	long long __ss_align;	/* force desired structure storage alignment */
	char	__ss_pad2[_SS_PAD2SIZE];
};
@


1.6.2.4
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/01/24 03:46:10 $
d394 1
a395 1
    TRAP_BEG;
@


1.6.2.5
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:54:00 $
d89 1
a89 1
#define _SS_ALIGNSIZE	(sizeof(double))
d102 1
a102 1
	double	__ss_align;	/* force desired structure storage alignment */
@


1.6.2.6
log
@2000-03-02
@
text
@d6 1
a6 1
  $Date: 2000/02/17 08:29:06 $
a513 1
	hostp = hbuf;
a526 1
	hostp = hbuf;
d528 1
@


1.6.2.7
log
@2000-03-08
@
text
@d6 1
a6 1
  $Date: 2000/03/02 03:51:48 $
a524 3
	else if (strlen(name) > sizeof(hbuf)-1) {
	    rb_raise(rb_eSocket, "hostname too long (%d)", strlen(name));
	}
a545 3
	if (hostp && hostp[strlen(hostp)-1] == '\n') {
	    rb_raise(rb_eSocket, "newline at the end of hostname");
	}
@


1.6.2.8
log
@000414
@
text
@d6 1
a6 1
  $Date: 2000/03/08 06:25:19 $
d188 1
a188 1
    myfdclose(fptr->f);
d212 1
a212 1
    myfdclose(fptr->f2);
a764 3
#if defined(HAVE_CLOSESOCKET)
	    closesocket(fd);
#else
a765 1
#endif
a772 3
#if defined(HAVE_CLOSESOCKET)
	    closesocket(fd);
#else
a773 1
#endif
a1035 3
#if defined(HAVE_CLOSESOCKET)
	closesocket(fd);
#else
a1036 1
#endif
@


1.6.2.9
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/14 14:35:45 $
d262 1
a262 2
    int level, option;
    socklen_t len;
d286 1
a286 1
    socklen_t len = sizeof buf;
d300 1
a300 1
    socklen_t len = sizeof buf;
d380 1
a380 1
    socklen_t alen = sizeof buf;
d382 1
a382 1
    int fd, flags;
d963 1
a963 1
    socklen_t *len;
d996 1
a996 1
    socklen_t fromlen;
d1068 1
a1068 1
    socklen_t len = sizeof addr;
d1083 1
a1083 1
    socklen_t len = sizeof addr;
d1242 1
a1242 1
	socklen_t len = sizeof(addr);
d1272 1
a1272 1
    socklen_t fromlen;
d1293 1
a1293 1
    socklen_t len = sizeof addr;
d1308 1
a1308 1
    socklen_t len = sizeof addr;
d1511 1
a1511 1
    socklen_t len = sizeof buf;
@


1.6.2.10
log
@2000-05-30
@
text
@d6 1
a6 1
  $Date: 2000/05/22 05:30:25 $
a8 2
  Copyright (C) 1993-2000 Yukihiro Matsumoto

a15 5

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

d32 7
a106 85
#define LOOKUP_ORDER_UNSPEC	0
#define LOOKUP_ORDER_INET	1
#define LOOKUP_ORDER_INET6	2

#if   defined(DEFAULT_LOOKUP_ORDER_UNSPEC)
# define LOOKUP_ORDER_DEFAULT LOOKUP_ORDER_UNSPEC
#elif defined(DEFAULT_LOOKUP_ORDER_INET)
# define LOOKUP_ORDER_DEFAULT LOOKUP_ORDER_INET
#elif defined(DEFAULT_LOOKUP_ORDER_INET6)
# define LOOKUP_ORDER_DEFAULT LOOKUP_ORDER_INET6
#endif

#ifdef INET6
#define LOOKUP_ORDERS		3
int lookup_order_table[LOOKUP_ORDERS][LOOKUP_ORDERS] = {
  {PF_UNSPEC, PF_UNSPEC, PF_UNSPEC},	/* 0:unspec */
  {PF_INET, PF_INET6, PF_UNSPEC},	/* 1:inet inet6 */
  {PF_INET6, PF_INET, PF_UNSPEC}	/* 2:inet6 inet */
};

static int lookup_order = LOOKUP_ORDER_DEFAULT;

static VALUE
lookup_order_get(self)
    VALUE self;
{
    return INT2FIX(lookup_order);
}

static VALUE
lookup_order_set(self, order)
    VALUE self, order;
{
    int n = NUM2INT(order);

    if (n < 0 || LOOKUP_ORDERS <= n) {
	rb_raise(rb_eArgError, "invalid value for lookup_order");
    }
    lookup_order = n;
    return order;
}

static int
rb_getaddrinfo(nodename, servname, hints, res)
     char *nodename;
     char *servname;
     struct addrinfo *hints;
     struct addrinfo **res;
{
    struct addrinfo tmp_hints;
    int i, af, error;

    for (i = 0; i < LOOKUP_ORDERS; i++) {
	af = lookup_order_table[lookup_order][i];
	MEMCPY(&tmp_hints, hints, struct addrinfo, 1);
	tmp_hints.ai_family = af;
	error = getaddrinfo(nodename, servname, &tmp_hints, res);
	if (error) {
	    if (tmp_hints.ai_family == PF_UNSPEC) {
		break;
	    }
	}
	else {
	    break;
	}
    }

    return error;
}
#else
static VALUE
lookup_order_get(self)
    VALUE self;
{
    return INT2FIX(LOOKUP_ORDER_DEFAULT);
}

static VALUE
lookup_order_set(self, order)
    VALUE self, order;
{
    return order;
}
#endif

d131 1
d156 1
a156 3
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, "Insecure: can't shutdown socket");
    }
d179 1
a179 3
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, "Insecure: can't close socket");
    }
d204 1
a204 3
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, "Insecure: can't close socket");
    }
d276 1
a276 1
    return rb_tainted_str_new(buf, len);
d293 1
a293 1
    return rb_tainted_str_new(buf, len);
d307 1
a307 1
    return rb_tainted_str_new(buf, len);
d390 2
a392 3
    if (rb_read_pending(fptr->f)) {
	rb_raise(rb_eIOError, "recv for buffered IO");
    }
a393 3

    str = rb_tainted_str_new(0, NUM2INT(len));

d433 1
a433 1
	return rb_assoc_new(str, rb_tainted_str_new(buf, alen));
d467 2
a468 1
    error = getnameinfo(addr, SA_LEN(addr), buf, len, NULL, 0, NI_NUMERICHOST);
d481 1
a481 1
    return rb_tainted_str_new2(buf);
d518 1
a518 1
	char *name;
a519 2
	Check_SafeStr(host);
	name = RSTRING(host)->ptr;
d526 2
a527 2
	else if (strlen(name) >= sizeof(hbuf)) {
	    rb_raise(rb_eArgError, "hostname too long (%d)", strlen(name));
d538 1
a538 1
	snprintf(pbuf, sizeof(pbuf), "%ld", FIX2INT(port));
a541 1
	Check_SafeStr(port);
a547 1
#ifndef INET6
a548 3
#else
    error = rb_getaddrinfo(hostp, portp, &hints, &res);
#endif
d599 1
a599 1
	addr1 = rb_tainted_str_new2(hbuf);
d606 1
a606 1
    addr2 = rb_tainted_str_new2(hbuf);
d616 11
a642 11
static void
thread_write_select(fd)
    int fd;
{
    fd_set fds;

    FD_ZERO(&fds);
    FD_SET(fd, &fds);
    rb_thread_select(fd+1, 0, &fds, 0, 0);
}

d726 1
a726 1
	snprintf(pbuf, sizeof(pbuf), "%ld", FIX2UINT(serv));
d730 1
a730 4
	Check_SafeStr(serv);
	if (RSTRING(serv)->len >= sizeof(pbuf))
	    rb_raise(rb_eArgError, "servicename too long (%d)", RSTRING(serv)->len);
	strcpy(pbuf, RSTRING(serv)->ptr);
a738 1
#ifndef INET6
a739 3
#else
    error = rb_getaddrinfo(host, portp, &hints, &res0);
#endif
a825 3
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, "Insecure: can't close socket");
    }
a846 1
    rb_secure(3);
a849 1

d893 1
a893 1
    rb_ary_push(ary, rb_tainted_str_new2(h->h_name));
d897 1
a897 1
	rb_ary_push(names, rb_tainted_str_new2(*pch));
a967 1
    rb_secure(3);
a1112 1
    rb_secure(3);
a1131 1
    rb_secure(3);
a1153 1
    rb_secure(3);
a1184 1
    rb_secure(4);
d1192 1
a1192 1
      retry:
d1208 1
a1208 1
	    rb_thread_fd_writable(fileno(f));
d1248 1
a1248 1
    return rb_tainted_str_new2(fptr->path);
d1285 1
a1285 2
    return rb_assoc_new(rb_str_new2("AF_UNIX"),
			rb_tainted_str_new2(sockaddr->sun_path));
a1326 1
	Check_SafeStr(domain);
a1374 1
	Check_SafeStr(type);
a1410 1
    rb_secure(3);
a1488 1
    rb_secure(4);
d1517 1
a1517 1
    return rb_assoc_new(sock2, rb_tainted_str_new(buf, len));
a1526 1
    rb_secure(3);
d1531 1
a1531 1
    return rb_tainted_str_new2(buf);
d1542 1
a1542 1
    struct utsname un;
d1544 2
a1545 3
    rb_secure(3);
    uname(&un);
    return rb_tainted_str_new2(un.nodename);
d1573 1
a1573 1
    rb_ary_push(ary, rb_tainted_str_new2(h->h_name));
d1577 1
a1577 1
	rb_ary_push(names, rb_tainted_str_new2(*pch));
d1582 1
a1582 1
	rb_ary_push(ary, rb_tainted_str_new(*pch, h->h_length));
d1585 1
a1585 1
    rb_ary_push(ary, rb_tainted_str_new(h->h_addr, h->h_length));
d1731 2
a1732 1
    rb_scan_args(argc, argv, "24", &host, &port, &family, &socktype, &protocol, &flags);
d1745 1
a1745 1
	snprintf(pbuf, sizeof(pbuf), "%ld", FIX2INT(port));
a1757 1
#ifndef INET6
a1760 1
#endif
a1769 1
#ifndef INET6
a1770 8
#else
    if (!NIL_P(family)) {
      error = getaddrinfo(hptr, pptr, &hints, &res);
    }
    else {
      error = rb_getaddrinfo(hptr, pptr, &hints, &res);
    }
#endif
d1785 1
a1785 1
    VALUE sa, af = Qnil, host = Qnil, port = Qnil, flags;
a1820 4
	else {
	    rb_raise(rb_eArgError, "array size should be 3 or 4, %d given",
		     RARRAY(sa)->len);
	}
d1834 1
a1834 1
	    snprintf(pbuf, sizeof(pbuf), "%ld", NUM2INT(port));
d1869 1
d1878 1
a1878 1
    return rb_assoc_new(rb_tainted_str_new2(hbuf), rb_tainted_str_new2(pbuf));
a2038 6

    sock_define_const("LOOKUP_INET", LOOKUP_ORDER_INET);
    sock_define_const("LOOKUP_INET6", LOOKUP_ORDER_INET6);
    sock_define_const("LOOKUP_UNSPEC", LOOKUP_ORDER_UNSPEC);
    rb_define_singleton_method(rb_cBasicSocket, "lookup_order", lookup_order_get, 0);
    rb_define_singleton_method(rb_cBasicSocket, "lookup_order=", lookup_order_set, 1);
@


1.6.2.11
log
@2000-05-31
@
text
@d6 1
a6 1
  $Date: 2000/05/30 04:24:06 $
d107 13
a119 1
#if defined(INET6) && (defined(LOOKUP_ORDER_HACK_INET) || defined(LOOKUP_ORDER_HACK_INET))
d121 4
a124 8
static int lookup_order_table[LOOKUP_ORDERS] = {
#if defined(LOOKUP_ORDER_HACK_INET)
    PF_INET, PF_INET6, PF_UNSPEC,
#elif defined(LOOKUP_ORDER_HACK_INET6)
    PF_INET6, PF_INET, PF_UNSPEC,
#else
    /* should not happen */
#endif
d127 22
a158 4
    if (hints->ai_family != PF_UNSPEC) {
	return getaddrinfo(nodename, servname, hints, res);
    }

d160 1
a160 1
	af = lookup_order_table[i];
d176 14
a189 1
#define getaddrinfo(node,serv,hints,res) rb_getaddrinfo((node),(serv),(hints),(res))
d481 3
d644 1
d646 3
d842 1
d844 3
d1881 1
d1885 1
d1895 1
d1897 8
d1920 1
a1921 1
    char hbuf[1024], pbuf[1024];
d1923 1
a1923 1
    struct addrinfo hints, *res = NULL, *r;
a1926 1
    char *ep;
a1930 4
    fl = 0;
    if (!NIL_P(flags)) {
	fl = NUM2INT(flags);
    }
a1941 1
	MEMZERO(&hints, struct addrinfo, 1);
a1953 7
	    else {
		/*
		 * 4th element holds numeric form, don't resolve.
		 * see ipaddr().
		 */
		hints.ai_flags |= AI_NUMERICHOST;
	    }
a1958 1
	/* host */
a1966 1
	/* port */
d1971 1
a1971 1
	else if (FIXNUM_P(port)) {
d1980 2
a1981 9
	hints.ai_socktype = (fl & NI_DGRAM) ? SOCK_DGRAM : SOCK_STREAM;
	/* af */
	if (NIL_P(af)) {
	    hints.ai_family = PF_UNSPEC;
	}
	else if (FIXNUM_P(af)) {
	    hints.ai_family = FIX2INT(af);
	}
	else if (strcmp(STR2CSTR(af), "AF_INET") == 0) {
d1989 3
d1993 3
a1995 1
	if (error) goto error_exit;
d2002 5
d2009 2
a2010 12
    if (error) goto error_exit;
    for (r = res->ai_next; r; r = r->ai_next) {
	char hbuf2[1024], pbuf2[1024];

	sap = r->ai_addr;
	error = getnameinfo(sap, SA_LEN(sap), hbuf2, sizeof(hbuf2),
			    pbuf2, sizeof(pbuf2), fl);
	if (error) goto error_exit;
	if (strcmp(hbuf, hbuf2) != 0|| strcmp(pbuf, pbuf2) != 0) {
	    freeaddrinfo(res);
	    rb_raise(rb_eSocket, "sockaddr resolved to multiple nodename");
	}
d2012 3
a2014 1
    freeaddrinfo(res);
a2015 4

  error_exit:
    if (res) freeaddrinfo(res);
    rb_raise(rb_eSocket, "%s", gai_strerror(error));
d2176 6
@


1.6.2.12
log
@000626
@
text
@d6 1
a6 1
  $Date: 2000/05/31 08:10:04 $
d1961 10
a1970 12
    if (res) {
	for (r = res->ai_next; r; r = r->ai_next) {
	    char hbuf2[1024], pbuf2[1024];

	    sap = r->ai_addr;
	    error = getnameinfo(sap, SA_LEN(sap), hbuf2, sizeof(hbuf2),
				pbuf2, sizeof(pbuf2), fl);
	    if (error) goto error_exit;
	    if (strcmp(hbuf, hbuf2) != 0|| strcmp(pbuf, pbuf2) != 0) {
		freeaddrinfo(res);
		rb_raise(rb_eSocket, "sockaddr resolved to multiple nodename");
	    }
a1971 1
	freeaddrinfo(res);
d1973 1
@


1.6.2.13
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/26 08:03:16 $
d521 1
a521 1
	rb_raise(rb_eSocket, "getnameinfo: %s", gai_strerror(error));
d607 1
a607 1
	rb_raise(rb_eSocket, "getaddrinfo: %s", gai_strerror(error));
d651 1
a651 1
	    rb_raise(rb_eSocket, "getnameinfo: %s", gai_strerror(error));
d658 1
a658 1
	rb_raise(rb_eSocket, "getnameinfo %s", gai_strerror(error));
d798 1
a798 1
	rb_raise(rb_eSocket, "getaddrinfo: %s", gai_strerror(error));
d1845 1
a1845 1
	rb_raise(rb_eSocket, "getaddrinfo: %s", gai_strerror(error));
d1951 1
a1951 1
	if (error) goto error_exit_addr;
d1960 1
a1960 1
    if (error) goto error_exit_name;
d1968 1
a1968 1
	    if (error) goto error_exit_name;
d1978 1
a1978 1
  error_exit_addr:
d1980 1
a1980 5
    rb_raise(rb_eSocket, "getaddrinfo: %s", gai_strerror(error));

  error_exit_name:
    if (res) freeaddrinfo(res);
    rb_raise(rb_eSocket, "getnameinfo: %s", gai_strerror(error));
@


1.6.2.14
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/10 08:01:41 $
d107 1
a107 1
#if defined(INET6) && (defined(LOOKUP_ORDER_HACK_INET) || defined(LOOKUP_ORDER_HACK_INET6))
@


1.6.2.15
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/11 07:55:47 $
a1028 1
    int retry = 0;
a1037 6
	  case EMFILE:
	  case ENFILE:
	    if (retry) break;
	    rb_gc();
	    retry = 1;
	    goto retry;
@


1.5
log
@19991004
@
text
@d6 1
a6 1
  $Date: 1999/09/22 04:30:10 $
d19 6
@


1.4
log
@19990922
@
text
@d6 1
a6 1
  $Date: 1999/09/20 07:14:18 $
d783 14
d1893 3
@


1.3
log
@19990920
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:37:50 $
d66 3
d72 1
d638 3
d645 1
a645 1
#ifdef SOCKS
@


1.2
log
@remove marshal/gtk/kconv
@
text
@d6 1
a6 1
  $Date: 1999/08/06 06:48:22 $
d118 1
a118 1
    rb_io_unbuffered(fp);
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1995/01/10 10:42:55 $
d12 2
a13 1
#include "io.h"
d16 1
d20 1
d26 8
a33 1
#if defined(THREAD) && defined(HAVE_FCNTL)
d44 4
d49 1
a49 2
extern VALUE cIO;
extern VALUE cInteger;
d51 5
a55 3
VALUE cBasicSocket;
VALUE cTCPsocket;
VALUE cTCPserver;
d57 2
a58 2
VALUE cUNIXsocket;
VALUE cUNIXserver;
d60 1
a60 1
VALUE cSocket;
d62 1
a62 2
extern VALUE eException;
static VALUE eSocket;
d65 1
a65 1
VALUE cSOCKSsocket;
a69 3
FILE *rb_fdopen();
char *strdup();

d74 6
d85 9
a93 3
    SOCKET s = fileno(fptr->f);
    free(fptr->f);
    free(fptr->f2);
d95 1
d108 1
d114 1
a114 1
    setbuf(fp->f, NULL);
d118 1
a118 1
    io_unbuffered(fp);
d133 1
d139 3
a141 1
	if (how < 0 && how > 2) how = 2;
d151 48
d200 1
a200 2
    VALUE sock, lev, optname;
    struct RString *val;
d224 1
a224 2
	Check_Type(val, T_STRING);
	v = val->ptr; vlen = val->len;
d238 1
d252 4
a255 1
    return str_new(buf, len);
d269 1
a269 1
    return str_new(buf, len);
d283 1
a283 1
    return str_new(buf, len);
d292 1
a292 1
    struct RString *msg, *to;
d297 2
a302 2
    Check_Type(msg, T_STRING);

d304 1
a304 1
    f = fptr->f2?fptr->f2:fptr->f;
d307 2
a308 3
#ifdef THREAD
    thread_fd_writable(fd);
#endif
d310 3
a312 3
	Check_Type(to, T_STRING);
	n = sendto(fd, msg->ptr, msg->len, NUM2INT(flags),
		   (struct sockaddr*)to->ptr, to->len);
d315 1
a315 1
	n = send(fd, msg->ptr, msg->len, NUM2INT(flags));
d320 2
d326 1
a326 3
#ifdef THREAD
	    thread_schedule();
#endif
d334 1
a334 1
static VALUE tcpaddr _((struct sockaddr_in*));
d336 1
a336 1
static VALUE unixaddr _((struct sockaddr_un*));
d339 8
d352 1
a352 4
    int from;			/* 0 - recv,
				   1 - TCPsocket#recvfrom,
				   2 - UNIXsocket#recvfrom,
				   3 - Socket#recvfrom */
d355 1
a355 2
    FILE f;
    struct RString *str;
d366 1
a366 1
    str = (struct RString*)str_new(0, NUM2INT(len));
d370 1
a370 3
#ifdef THREAD
    thread_wait_fd(fd);
#endif
d373 2
a374 2
    str->len = recvfrom(fd, str->ptr, str->len, flags,
			(struct sockaddr*)buf, &alen);
d377 1
a377 1
    if (str->len < 0) {
d380 3
d387 1
a387 3
#ifdef THREAD
	    thread_schedule();
#endif
d392 1
a392 1
    str_taint(str);
d394 1
a394 1
      case 0:
d396 3
a398 1
      case 1:
d400 1
a400 1
	    TypeError("sockaddr size differs - should not happen");
d402 2
a403 1
	return assoc_new(str, tcpaddr((struct sockaddr_in *)buf));
d405 2
a406 5
      case 2:
	if (alen != sizeof(struct sockaddr_un)) {
	    TypeError("sockaddr size differs - should not happen");
	}
	return assoc_new(str, unixaddr((struct sockaddr_un *)buf));
d408 2
a409 2
      case 3:
	return assoc_new(str, str_new(buf, alen));
d419 191
a609 1
    return s_recv(sock, argc, argv, 0);
a611 1
#if defined(THREAD) && defined(HAVE_FCNTL)
d613 1
a613 1
thread_connect(fd, sockaddr, len, type)
d617 1
a617 1
    int type;
a620 1
    fd_set fds;
d622 1
d635 2
d639 1
a639 1
	if (type == INET_SOCKS) {
d649 1
a651 2
#ifdef EAGAIN
	      case EAGAIN:
d653 1
a653 3
		FD_ZERO(&fds);
		FD_SET(fd, &fds);
		thread_select(fd+1, 0, &fds, 0, 0, 0);
a654 1
#endif
a657 5
#endif
#ifdef EALREADY
	      case EALREADY:
#endif
#if defined(EISCONN) || defined(EALREADY)
d664 1
d667 1
a670 1
#endif
d677 1
a677 5
    char *host;
    struct hostent *hostent, _hostent;
    struct servent *servent, _servent;
    struct protoent *protoent;
    struct sockaddr_in sockaddr;
a678 2
    int hostaddr, hostaddrPtr[2];
    int servport;
d680 3
a682 1
    VALUE sock;
a686 22
	hostent = gethostbyname(host);
	if (hostent == NULL) {
	    hostaddr = inet_addr(host);
	    if (hostaddr == -1) {
		if (type == INET_SERVER && !strlen(host))
		    hostaddr = INADDR_ANY;
		else {
#ifdef HAVE_HSTRERROR
		    extern int h_errno;
		    Raise(eSocket, (char *)hstrerror(h_errno));
#else
		    Raise(eSocket, "host not found");
#endif
		}
	    }
	    _hostent.h_addr_list = (char **)hostaddrPtr;
	    _hostent.h_addr_list[0] = (char *)&hostaddr;
	    _hostent.h_addr_list[1] = NULL;
	    _hostent.h_length = sizeof(hostaddr);
	    _hostent.h_addrtype = AF_INET;
	    hostent = &_hostent;
	}
d688 3
a690 1
    servent = NULL;
d692 2
a693 2
	servport = FIX2UINT(serv);
	goto setup_servent;
d695 3
a697 15
    Check_Type(serv, T_STRING);
    servent = getservbyname(RSTRING(serv)->ptr, "tcp");
    if (servent == NULL) {
	servport = strtoul(RSTRING(serv)->ptr, 0, 0);
	if (servport == -1) {
	    Raise(eSocket, "no such servce %s", RSTRING(serv)->ptr);
	}
      setup_servent:
	_servent.s_port = htons(servport);
 	_servent.s_proto = "tcp";
	servent = &_servent;
    }
    protoent = getprotobyname(servent->s_proto);
    if (protoent == NULL) {
	Raise(eSocket, "no such proto %s", servent->s_proto);
d699 5
a703 9

    fd = socket(PF_INET, SOCK_STREAM, protoent->p_proto);

    memset(&sockaddr, 0, sizeof(sockaddr));
    sockaddr.sin_family = AF_INET;
    if (h) {
	memcpy((char *)&(sockaddr.sin_addr.s_addr),
	       (char *) hostent->h_addr_list[0],
	       (size_t) hostent->h_length);
d705 3
a707 2
    else {
	sockaddr.sin_addr.s_addr = INADDR_ANY;
a708 1
    sockaddr.sin_port = servent->s_port;
d710 14
a723 14
    if (type == INET_SERVER) {
	status = 1;
	setsockopt(fd,SOL_SOCKET,SO_REUSEADDR,(char*)&status,sizeof(status));
	status = bind(fd, (struct sockaddr*)&sockaddr, sizeof(sockaddr));
	syscall = "bind(2)";
    }
    else {
#if defined(THREAD) && defined(HAVE_FCNTL)
        status = thread_connect(fd, (struct sockaddr*)&sockaddr,
				sizeof(sockaddr), type);
#else
#ifdef SOCKS
	if (type == INET_SOCKS) {
	    status = Rconnect(fd, &sockaddr, sizeof(sockaddr));
d725 4
a728 4
	else
#endif
	{
	    status = connect(fd, (struct sockaddr*)&sockaddr, sizeof(sockaddr));
d730 7
a736 2
#endif
	syscall = "connect(2)";
a737 1

d739 3
a741 1
	close (fd);
d744 3
a746 1
    if (type == INET_SERVER) listen(fd, 5);
d749 2
a750 3
    sock = sock_new(class, fd);

    return sock;
d778 109
d911 1
a911 3
#ifdef THREAD
    thread_wait_fd(fd);
#endif
d918 3
d925 1
a925 3
#ifdef THREAD
	    thread_schedule();
#endif
d938 1
a938 1
    struct sockaddr_in from;
d942 2
a943 2
    fromlen = sizeof(struct sockaddr_in);
    return s_accept(cTCPsocket, fileno(fptr->f),
d947 9
d969 4
a972 2
    fd = socket(PF_UNIX, SOCK_STREAM, 0);
    if (fd < 0) rb_sys_fail("socket(2)");
d974 1
a974 1
    memset(&sockaddr, 0, sizeof(sockaddr));
d983 1
a983 1
        status = connect(fd, (struct sockaddr*)&sockaddr, sizeof(sockaddr));
d1001 18
a1018 4
static void
setipaddr(name, addr)
    char *name;
    struct sockaddr_in *addr;
d1020 9
a1028 30
    int d1, d2, d3, d4;
    char ch;
    struct hostent *hp;
    long x;

    if (name[0] == 0) {
	addr->sin_addr.s_addr = INADDR_ANY;
    }
    else if (name[0] == '<' && strcmp(name, "<broadcast>") == 0) {
	addr->sin_addr.s_addr = INADDR_BROADCAST;
    }
    else if (sscanf(name, "%d.%d.%d.%d%c", &d1, &d2, &d3, &d4, &ch) == 4 &&
	     0 <= d1 && d1 <= 255 && 0 <= d2 && d2 <= 255 &&
	     0 <= d3 && d3 <= 255 && 0 <= d4 && d4 <= 255) {
	addr->sin_addr.s_addr = htonl(
	    ((long) d1 << 24) | ((long) d2 << 16) |
	    ((long) d3 << 8) | ((long) d4 << 0));
    }
    else {
	hp = gethostbyname(name);
	if (!hp) {
#ifdef HAVE_HSTRERROR
	    extern int h_errno;
	    Raise(eSocket, (char *)hstrerror(h_errno));
#else
	    Raise(eSocket, "host not found");
#endif
	}
	memcpy((char *) &addr->sin_addr, hp->h_addr, hp->h_length);
    }
d1032 2
a1033 2
mkipaddr(x)
    unsigned long x;
d1035 1
a1035 1
    char buf[16];
d1037 2
a1038 5
    x = ntohl(x);
    sprintf(buf, "%d.%d.%d.%d",
	    (int) (x>>24) & 0xff, (int) (x>>16) & 0xff,
	    (int) (x>> 8) & 0xff, (int) (x>> 0) & 0xff);
    return str_new2(buf);
d1042 4
a1045 2
tcpaddr(sockaddr)
    struct sockaddr_in *sockaddr;
d1047 3
a1049 3
    VALUE family, port, addr1, addr2;
    VALUE ary;
    struct hostent *hostent;
d1051 6
a1056 7
    family = str_new2("AF_INET");
    hostent = gethostbyaddr((char*)&sockaddr->sin_addr.s_addr,
			    sizeof(sockaddr->sin_addr),
			    AF_INET);
    addr1 = 0;
    if (hostent) {
	addr1 = str_new2(hostent->h_name);
a1057 2
    addr2 = mkipaddr(sockaddr->sin_addr.s_addr);
    if (!addr1) addr1 = addr2;
d1059 1
a1059 4
    port = INT2FIX(ntohs(sockaddr->sin_port));
    ary = ary_new3(4, family, port, addr1, addr2);

    return ary;
d1063 2
a1064 2
tcp_addr(sock)
    VALUE sock;
d1067 2
a1068 2
    struct sockaddr_in addr;
    int len = sizeof addr;
d1071 8
d1080 3
a1082 3
    if (getsockname(fileno(fptr->f), (struct sockaddr*)&addr, &len) < 0)
	rb_sys_fail("getsockname(2)");
    return tcpaddr(&addr);
d1086 2
a1087 2
tcp_peeraddr(sock)
    VALUE sock;
d1090 1
a1090 2
    struct sockaddr_in addr;
    int len = sizeof addr;
d1093 11
a1103 4

    if (getpeername(fileno(fptr->f), (struct sockaddr*)&addr, &len) < 0)
	rb_sys_fail("getpeername(2)");
    return tcpaddr(&addr);
d1107 1
a1107 1
tcp_recvfrom(argc, argv, sock)
d1112 41
a1152 1
    return s_recv(sock, argc, argv, 1);
d1156 4
a1159 2
tcp_s_getaddress(obj, host)
    VALUE obj, host;
d1161 1
a1161 13
    struct sockaddr_in addr;
    struct hostent *h;

    if (obj_is_kind_of(host, cInteger)) {
	int i = NUM2INT(host);
	addr.sin_addr.s_addr = htonl(i);
    }
    else {
	Check_Type(host, T_STRING);
	setipaddr(RSTRING(host)->ptr, &addr);
    }

    return mkipaddr(addr.sin_addr.s_addr);
d1186 1
a1186 1
    return str_new2(fptr->path);
d1190 2
a1191 2
unix_svr_s_open(class, path)
    VALUE class, path;
d1193 1
a1193 1
    return open_unix(class, path, 1);
d1202 1
a1202 1
    return s_recv(sock, argc, argv, 2);
d1215 1
a1215 1
    return s_accept(cUNIXsocket, fileno(fptr->f),
d1223 1
a1223 1
    return assoc_new(str_new2("AF_UNIX"),str_new2(sockaddr->sun_path));
d1266 20
a1285 1
	if (strcmp(ptr, "PF_INET") == 0)
d1287 1
d1295 2
d1307 1
a1307 1
	    Raise(eSocket, "Unknown socket domain %s", ptr);
d1335 1
a1335 1
	    Raise(eSocket, "Unknown socket type %s", ptr);
d1350 1
a1350 1
    fd = socket(d, t, NUM2INT(protocol));
d1352 1
d1367 1
a1367 2
#if !defined(__CYGWIN32__) && !defined(NT)
    int fd;
d1371 6
a1376 1
    if (socketpair(d, t, NUM2INT(protocol), sp) < 0)
d1378 1
d1380 1
a1380 1
    return assoc_new(sock_new(class, sp[0]), sock_new(class, sp[1]));
d1388 1
a1388 2
    VALUE sock;
    struct RString *addr;
d1391 1
d1394 1
a1394 1
    str_modify(addr);
d1397 2
a1398 13
  retry:
    if (connect(fileno(fptr->f), (struct sockaddr*)addr->ptr, addr->len) < 0) {
	switch (errno) {
	  case EINTR:
	  case EWOULDBLOCK:
#if EAGAIN != EWOULDBLOCK
	  case EAGAIN:
#endif
#ifdef THREAD
	    thread_schedule();
#endif
	    goto retry;
	}
d1407 1
a1407 2
    VALUE sock;
    struct RString *addr;
d1412 1
a1412 1
    str_modify(addr);
d1415 1
a1415 1
    if (bind(fileno(fptr->f), (struct sockaddr*)addr->ptr, addr->len) < 0)
d1440 1
a1440 1
    return s_recv(sock, argc, argv, 3);
d1448 1
a1448 1
    VALUE addr, sock2;
d1453 1
a1453 1
    sock2 = s_accept(cSocket,fileno(fptr->f),(struct sockaddr*)buf,&len);
d1455 1
a1455 1
    return assoc_new(sock2, str_new(buf, len));
d1469 1
a1469 1
    return str_new2(buf);
d1483 1
a1483 1
  return str_new2(un.nodename);
a1498 1
    struct sockaddr_in addr;
d1505 1
a1505 1
	Raise(eSocket, (char *)hstrerror(h_errno));
d1507 1
a1507 1
	Raise(eSocket, "host not found");
d1510 4
a1513 4
    ary = ary_new();
    ary_push(ary, str_new2(h->h_name));
    names = ary_new();
    ary_push(ary, names);
d1515 1
a1515 1
	ary_push(names, str_new2(*pch));
d1517 1
a1517 1
    ary_push(ary, INT2FIX(h->h_length));
d1520 1
a1520 1
	ary_push(ary, str_new(*pch, h->h_length));
d1523 1
a1523 1
    ary_push(ary, str_new(h->h_addr, h->h_length));
d1530 25
d1558 1
a1558 1
    struct sockaddr_in addr;
d1561 8
a1568 3
    if (obj_is_kind_of(host, cInteger)) {
	int i = NUM2INT(host);
	addr.sin_addr.s_addr = htonl(i);
d1571 25
a1595 2
	Check_Type(host, T_STRING);
	setipaddr(RSTRING(host)->ptr, &addr);
a1596 3
    h = gethostbyaddr((char *)&addr.sin_addr,
		      sizeof(addr.sin_addr),
		      AF_INET);
d1608 2
a1609 2

    struct sockaddr_in *addr;
d1612 3
a1614 3
    rb_scan_args(argc, argv, "11", &addr, &type);
    Check_Type(addr, T_STRING);
    if (!NIL_P(type)) {
d1621 1
a1621 1
    h = gethostbyaddr(RSTRING(addr)->ptr, RSTRING(addr)->len, type);
d1632 1
a1632 1
    char *name, *proto;
a1636 1
    Check_Type(service, T_STRING);
d1638 1
a1638 1
    else proto = RSTRING(protocol)->ptr;
d1640 12
a1651 3
    sp = getservbyname(RSTRING(service)->ptr, proto);
    if (!sp) {
	Raise(eSocket, "service/proto not found");
a1652 1
    port = ntohs(sp->s_port);
d1657 174
d1833 1
a1833 1
    eSocket = rb_define_class("SocketError", eException);
d1835 31
a1865 17
    cBasicSocket = rb_define_class("BasicSocket", cIO);
    rb_undef_method(CLASS_OF(cBasicSocket), "new");
    rb_define_method(cBasicSocket, "shutdown", bsock_shutdown, -1);
    rb_define_method(cBasicSocket, "setsockopt", bsock_setsockopt, 3);
    rb_define_method(cBasicSocket, "getsockopt", bsock_getsockopt, 2);
    rb_define_method(cBasicSocket, "getsockname", bsock_getsockname, 0);
    rb_define_method(cBasicSocket, "getpeername", bsock_getpeername, 0);
    rb_define_method(cBasicSocket, "send", bsock_send, -1);
    rb_define_method(cBasicSocket, "recv", bsock_recv, -1);

    cTCPsocket = rb_define_class("TCPsocket", cBasicSocket);
    rb_define_singleton_method(cTCPsocket, "open", tcp_s_open, 2);
    rb_define_singleton_method(cTCPsocket, "new", tcp_s_open, 2);
    rb_define_method(cTCPsocket, "addr", tcp_addr, 0);
    rb_define_method(cTCPsocket, "peeraddr", tcp_peeraddr, 0);
    rb_define_singleton_method(cTCPsocket, "getaddress", tcp_s_getaddress, 1);
    rb_define_method(cTCPsocket, "recvfrom", tcp_recvfrom, -1);
d1868 20
a1887 9
    cSOCKSsocket = rb_define_class("SOCKSsocket", cTCPsocket);
    rb_define_singleton_method(cSOCKSsocket, "open", socks_s_open, 2);
    rb_define_singleton_method(cSOCKSsocket, "new", socks_s_open, 2);
#endif

    cTCPserver = rb_define_class("TCPserver", cTCPsocket);
    rb_define_singleton_method(cTCPserver, "open", tcp_svr_s_open, -1);
    rb_define_singleton_method(cTCPserver, "new", tcp_svr_s_open, -1);
    rb_define_method(cTCPserver, "accept", tcp_accept, 0);
d1890 36
a1925 32
    cUNIXsocket = rb_define_class("UNIXsocket", cBasicSocket);
    rb_define_singleton_method(cUNIXsocket, "open", unix_s_sock_open, 1);
    rb_define_singleton_method(cUNIXsocket, "new", unix_s_sock_open, 1);
    rb_define_method(cUNIXsocket, "path", unix_path, 0);
    rb_define_method(cUNIXsocket, "addr", unix_addr, 0);
    rb_define_method(cUNIXsocket, "peeraddr", unix_peeraddr, 0);
    rb_define_method(cUNIXsocket, "recvfrom", unix_recvfrom, -1);

    cUNIXserver = rb_define_class("UNIXserver", cUNIXsocket);
    rb_define_singleton_method(cUNIXserver, "open", unix_svr_s_open, 1);
    rb_define_singleton_method(cUNIXserver, "new", unix_svr_s_open, 1);
    rb_define_method(cUNIXserver, "accept", unix_accept, 0);
#endif

    cSocket = rb_define_class("Socket", cBasicSocket);
    rb_define_singleton_method(cSocket, "open", sock_s_open, 3);
    rb_define_singleton_method(cSocket, "new", sock_s_open, 3);
    rb_define_singleton_method(cSocket, "for_fd", sock_s_for_fd, 1);

    rb_define_method(cSocket, "connect", sock_connect, 1);
    rb_define_method(cSocket, "bind", sock_bind, 1);
    rb_define_method(cSocket, "listen", sock_listen, 1);
    rb_define_method(cSocket, "accept", sock_accept, 0);

    rb_define_method(cSocket, "recvfrom", sock_recvfrom, -1);

    rb_define_singleton_method(cSocket, "socketpair", sock_s_socketpair, 3);
    rb_define_singleton_method(cSocket, "pair", sock_s_socketpair, 3);
    rb_define_singleton_method(cSocket, "gethostname", sock_gethostname, 0);
    rb_define_singleton_method(cSocket, "gethostbyname", sock_s_gethostbyname, 1);
    rb_define_singleton_method(cSocket, "gethostbyaddr", sock_s_gethostbyaddr, -1);
    rb_define_singleton_method(cSocket, "getservbyname", sock_s_getservbyaname, -1);
d1928 6
a1933 3
    rb_define_const(cSocket, "SOCK_STREAM", INT2FIX(SOCK_STREAM));
    rb_define_const(cSocket, "SOCK_DGRAM", INT2FIX(SOCK_DGRAM));
    rb_define_const(cSocket, "SOCK_RAW", INT2FIX(SOCK_RAW));
d1935 1
a1935 1
    rb_define_const(cSocket, "SOCK_RDM", INT2FIX(SOCK_RDM));
d1938 1
a1938 1
    rb_define_const(cSocket, "SOCK_SEQPACKET", INT2FIX(SOCK_SEQPACKET));
d1941 1
a1941 1
    rb_define_const(cSocket, "SOCK_PACKET", INT2FIX(SOCK_PACKET));
d1944 4
a1947 2
    rb_define_const(cSocket, "AF_INET", INT2FIX(AF_INET));
    rb_define_const(cSocket, "PF_INET", INT2FIX(PF_INET));
d1949 2
a1950 2
    rb_define_const(cSocket, "AF_UNIX", INT2FIX(AF_UNIX));
    rb_define_const(cSocket, "PF_UNIX", INT2FIX(PF_UNIX));
d1953 2
a1954 2
    rb_define_const(cSocket, "AF_AX25", INT2FIX(AF_AX25));
    rb_define_const(cSocket, "PF_AX25", INT2FIX(PF_AX25));
d1957 2
a1958 2
    rb_define_const(cSocket, "AF_IPX", INT2FIX(AF_IPX));
    rb_define_const(cSocket, "PF_IPX", INT2FIX(PF_IPX));
d1961 12
a1972 2
    rb_define_const(cSocket, "AF_APPLETALK", INT2FIX(AF_APPLETALK));
    rb_define_const(cSocket, "PF_APPLETALK", INT2FIX(PF_APPLETALK));
d1975 7
a1981 3
    rb_define_const(cSocket, "MSG_OOB", INT2FIX(MSG_OOB));
    rb_define_const(cSocket, "MSG_PEEK", INT2FIX(MSG_PEEK));
    rb_define_const(cSocket, "MSG_DONTROUTE", INT2FIX(MSG_DONTROUTE));
d1983 1
a1983 1
    rb_define_const(cSocket, "SOL_SOCKET", INT2FIX(SOL_SOCKET));
d1985 1
a1985 1
    rb_define_const(cSocket, "SOL_IP", INT2FIX(SOL_IP));
d1988 1
a1988 1
    rb_define_const(cSocket, "SOL_IPX", INT2FIX(SOL_IPX));
d1991 1
a1991 1
    rb_define_const(cSocket, "SOL_AX25", INT2FIX(SOL_AX25));
d1994 1
a1994 1
    rb_define_const(cSocket, "SOL_ATALK", INT2FIX(SOL_ATALK));
d1997 1
a1997 1
    rb_define_const(cSocket, "SOL_TCP", INT2FIX(SOL_TCP));
d2000 1
a2000 1
    rb_define_const(cSocket, "SOL_UDP", INT2FIX(SOL_UDP));
d2004 1
a2004 1
    rb_define_const(cSocket, "SO_DEBUG", INT2FIX(SO_DEBUG));
d2006 1
a2006 1
    rb_define_const(cSocket, "SO_REUSEADDR", INT2FIX(SO_REUSEADDR));
d2008 1
a2008 1
    rb_define_const(cSocket, "SO_TYPE", INT2FIX(SO_TYPE));
d2011 1
a2011 1
    rb_define_const(cSocket, "SO_ERROR", INT2FIX(SO_ERROR));
d2014 1
a2014 1
    rb_define_const(cSocket, "SO_DONTROUTE", INT2FIX(SO_DONTROUTE));
d2017 1
a2017 1
    rb_define_const(cSocket, "SO_BROADCAST", INT2FIX(SO_BROADCAST));
d2020 1
a2020 1
    rb_define_const(cSocket, "SO_SNDBUF", INT2FIX(SO_SNDBUF));
d2023 4
a2026 1
    rb_define_const(cSocket, "SO_RCVBUF", INT2FIX(SO_RCVBUF));
a2027 1
    rb_define_const(cSocket, "SO_KEEPALIVE", INT2FIX(SO_KEEPALIVE));
d2029 1
a2029 1
    rb_define_const(cSocket, "SO_OOBINLINE", INT2FIX(SO_OOBINLINE));
d2032 1
a2032 1
    rb_define_const(cSocket, "SO_NO_CHECK", INT2FIX(SO_NO_CHECK));
d2035 4
a2038 1
    rb_define_const(cSocket, "SO_PRIORITY", INT2FIX(SO_PRIORITY));
a2039 1
    rb_define_const(cSocket, "SO_LINGER", INT2FIX(SO_LINGER));
d2042 1
a2042 1
    rb_define_const(cSocket, "SOPRI_INTERACTIVE", INT2FIX(SOPRI_INTERACTIVE));
d2045 1
a2045 1
    rb_define_const(cSocket, "SOPRI_NORMAL", INT2FIX(SOPRI_NORMAL));
d2048 1
a2048 1
    rb_define_const(cSocket, "SOPRI_BACKGROUND", INT2FIX(SOPRI_BACKGROUND));
d2052 1
a2052 1
    rb_define_const(cSocket, "IP_MULTICAST_IF", INT2FIX(IP_MULTICAST_IF));
d2055 1
a2055 1
    rb_define_const(cSocket, "IP_MULTICAST_TTL", INT2FIX(IP_MULTICAST_TTL));
d2058 1
a2058 1
    rb_define_const(cSocket, "IP_MULTICAST_LOOP", INT2FIX(IP_MULTICAST_LOOP));
d2061 1
a2061 1
    rb_define_const(cSocket, "IP_ADD_MEMBERSHIP", INT2FIX(IP_ADD_MEMBERSHIP));
d2065 1
a2065 1
    rb_define_const(cSocket, "IP_DEFAULT_MULTICAST_TTL", INT2FIX(IP_DEFAULT_MULTICAST_TTL));
d2068 1
a2068 1
    rb_define_const(cSocket, "IP_DEFAULT_MULTICAST_LOOP", INT2FIX(IP_DEFAULT_MULTICAST_LOOP));
d2071 1
a2071 1
    rb_define_const(cSocket, "IP_MAX_MEMBERSHIPS", INT2FIX(IP_MAX_MEMBERSHIPS));
d2075 1
a2075 1
    rb_define_const(cSocket, "IPX_TYPE", INT2FIX(IPX_TYPE));
d2079 1
a2079 1
    rb_define_const(cSocket, "TCP_NODELAY", INT2FIX(TCP_NODELAY));
d2082 92
a2173 1
    rb_define_const(cSocket, "TCP_MAXSEG", INT2FIX(TCP_MAXSEG));
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@a14 1
#ifndef NT
a17 1
#endif
a38 1
VALUE cIPsocket;
a40 1
VALUE cUDPsocket;
d88 2
d257 1
a257 1
static VALUE ipaddr _((struct sockaddr_in*));
a261 8
enum sock_recv_type {
    RECV_RECV,			/* BasicSocket#recv(no from) */
    RECV_TCP,			/* TCPsocket#recvfrom */
    RECV_UDP,			/* UDPsocket#recvfrom */
    RECV_UNIX,			/* UNIXsocket#recvfrom */
    RECV_SOCKET,		/* Socket#recvfrom */
};

d267 4
a270 1
    enum sock_recv_type from;
d274 1
a274 1
    VALUE str;
d285 1
a285 1
    str = str_new(0, NUM2INT(len));
d294 2
a295 2
    RSTRING(str)->len = recvfrom(fd, RSTRING(str)->ptr, RSTRING(str)->len, flags,
				 (struct sockaddr*)buf, &alen);
d298 1
a298 1
    if (RSTRING(str)->len < 0) {
d314 1
a314 1
      case RECV_RECV:
d316 1
a316 1
      case RECV_TCP:
d320 1
a320 8
	return assoc_new(str, ipaddr((struct sockaddr_in *)buf));
      case RECV_UDP:
        {
	    VALUE addr = ipaddr((struct sockaddr_in *)buf);

	    return assoc_new(str, assoc_new(RARRAY(addr)->ptr[2],
					    RARRAY(addr)->ptr[1]));
	}
d322 1
a322 1
      case RECV_UNIX:
d328 1
a328 1
      case RECV_SOCKET:
d339 1
a339 1
    return s_recv(sock, argc, argv, RECV_RECV);
d473 1
a473 1
    fd = socket(AF_INET, SOCK_STREAM, protoent->p_proto);
d518 3
a520 1
    return sock_new(class, fd);
a608 9
static VALUE
tcp_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recv(sock, argc, argv, RECV_TCP);
}

d622 1
a622 1
    fd = socket(AF_UNIX, SOCK_STREAM, 0);
d703 1
a703 1
ipaddr(sockaddr)
d728 1
a728 1
ip_addr(sock)
d739 1
a739 1
    return ipaddr(&addr);
d743 1
a743 1
ip_peeraddr(sock)
d754 1
a754 1
    return ipaddr(&addr);
d758 10
a767 1
ip_s_getaddress(obj, host)
d771 1
a784 142
static VALUE
udp_s_open(class)
    VALUE class;
{
    return sock_new(class, socket(AF_INET, SOCK_DGRAM, 0));
}

static void
udp_addrsetup(host, port, addr)
    VALUE host, port;
    struct sockaddr_in *addr;
{
    struct hostent *hostent;

    memset(addr, 0, sizeof(struct sockaddr_in));
    addr->sin_family = AF_INET;
    if (NIL_P(host)) {
	addr->sin_addr.s_addr = INADDR_ANY;
    }
    else if (obj_is_kind_of(host, cInteger)) {
	int i = NUM2INT(host);
	addr->sin_addr.s_addr = htonl(i);
    }
    else {
	Check_Type(host, T_STRING);
	setipaddr(RSTRING(host)->ptr, addr);
    }
    if (FIXNUM_P(port)) {
	addr->sin_port = FIX2INT(port);
    }
    else {
	struct servent *servent;

	Check_Type(port, T_STRING);
	servent = getservbyname(RSTRING(port)->ptr, "udp");
	if (servent) {
	    addr->sin_port = servent->s_port;
	}
	else {
	    int port = strtoul(RSTRING(port)->ptr, 0, 0);

	    if (port == -1) {
		Raise(eSocket, "no such servce %s", RSTRING(port)->ptr);
	    }
	    addr->sin_port = htons(port);
	}
    }
}

static VALUE
udp_connect(sock, host, port)
    VALUE sock, host, port;
{
    struct sockaddr_in addr;
    OpenFile *fptr;

    udp_addrsetup(host, port, &addr);
    GetOpenFile(sock, fptr);
  retry:
    if (connect(fileno(fptr->f), (struct sockaddr*)&addr, sizeof(addr))<0) {
	switch (errno) {
	  case EINTR:
	  case EWOULDBLOCK:
#if EAGAIN != EWOULDBLOCK
	  case EAGAIN:
#endif
#ifdef THREAD
	    thread_schedule();
#endif
	    goto retry;
	}
	rb_sys_fail("connect(2)");
    }

    return INT2FIX(0);
}

static VALUE
udp_bind(sock, host, port)
    VALUE sock, host, port;
{
    struct sockaddr_in addr;
    OpenFile *fptr;

    udp_addrsetup(host, port, &addr);
    GetOpenFile(sock, fptr);
    if (bind(fileno(fptr->f), (struct sockaddr*)&addr, sizeof(addr))<0) {
	rb_sys_fail("bind(2)");
    }
    return INT2FIX(0);
}

static VALUE
udp_send(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    VALUE mesg, flags, host, port;
    struct sockaddr_in addr;
    OpenFile *fptr;
    FILE *f;
    int n;

    if (argc == 2) {
	return bsock_send(argc, argv, sock);
    }
    rb_scan_args(argc, argv, "4", &mesg, &flags, &host, &port);
    Check_Type(mesg, T_STRING);

    udp_addrsetup(host, port, &addr);
    GetOpenFile(sock, fptr);
    f = fptr->f2?fptr->f2:fptr->f;
  retry:
    n = sendto(fileno(f), RSTRING(mesg)->ptr, RSTRING(mesg)->len,
	       NUM2INT(flags), (struct sockaddr*)&addr, sizeof(addr));
    if (n < 0) {
	switch (errno) {
	  case EINTR:
	  case EWOULDBLOCK:
#if EAGAIN != EWOULDBLOCK
	  case EAGAIN:
#endif
#ifdef THREAD
	    thread_schedule();
#endif
	    goto retry;
	}
	rb_sys_fail("sendto(2)");
    }
    return INT2FIX(n);
}

static VALUE
udp_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recv(sock, argc, argv, RECV_UDP);
}

d823 1
a823 1
    return s_recv(sock, argc, argv, RECV_UNIX);
d887 1
a887 19
	if (strcmp(ptr, "AF_INET") == 0)
	    *dv = AF_INET;
#ifdef AF_UNIX
	else if (strcmp(ptr, "AF_UNIX") == 0)
	    *dv = AF_UNIX;
#endif
#ifdef AF_ISO
	else if (strcmp(ptr, "AF_ISO") == 0)
	    *dv = AF_ISO;
#endif
#ifdef AF_NS
	else if (strcmp(ptr, "AF_NS") == 0)
	    *dv = AF_NS;
#endif
#ifdef AF_IMPLINK
	else if (strcmp(ptr, "AF_IMPLINK") == 0)
	    *dv = AF_IMPLINK;
#endif
	else if (strcmp(ptr, "PF_INET") == 0)
a895 2
	else if (strcmp(ptr, "AF_IMPLINK") == 0)
	    *dv = AF_IMPLINK;
d981 2
a982 1
    VALUE sock, addr;
d991 1
a991 1
    if (connect(fileno(fptr->f), (struct sockaddr*)RSTRING(addr)->ptr, RSTRING(addr)->len) < 0) {
d1011 2
a1012 1
    VALUE sock, addr;
d1020 1
a1020 1
    if (bind(fileno(fptr->f), (struct sockaddr*)RSTRING(addr)->ptr, RSTRING(addr)->len) < 0)
d1045 1
a1045 1
    return s_recv(sock, argc, argv, RECV_SOCKET);
d1188 1
a1188 1
    char *proto;
a1205 11
static VALUE mConst;

static void
sock_define_const(name, value)
    char *name;
    INT value;
{
    rb_define_const(cSocket, name, INT2FIX(value));
    rb_define_const(mConst, name, INT2FIX(value));
}

a1211 1
    rb_undef_method(CLASS_OF(cBasicSocket), "open");
d1220 1
a1220 6
    cIPsocket = rb_define_class("IPsocket", cBasicSocket);
    rb_define_method(cIPsocket, "addr", ip_addr, 0);
    rb_define_method(cIPsocket, "peeraddr", ip_peeraddr, 0);
    rb_define_singleton_method(cIPsocket, "getaddress", ip_s_getaddress, 1);

    cTCPsocket = rb_define_class("TCPsocket", cIPsocket);
d1223 3
a1238 8
    cUDPsocket = rb_define_class("UDPsocket", cIPsocket);
    rb_define_singleton_method(cUDPsocket, "open", udp_s_open, 0);
    rb_define_singleton_method(cUDPsocket, "new", udp_s_open, 0);
    rb_define_method(cUDPsocket, "connect", udp_connect, 2);
    rb_define_method(cUDPsocket, "bind", udp_bind, 2);
    rb_define_method(cUDPsocket, "send", udp_send, -1);
    rb_define_method(cUDPsocket, "recvfrom", udp_recvfrom, -1);

d1274 3
a1276 4
    mConst = rb_define_module_under(cSocket, "Constants");
    sock_define_const("SOCK_STREAM", SOCK_STREAM);
    sock_define_const("SOCK_DGRAM", SOCK_DGRAM);
    sock_define_const("SOCK_RAW", SOCK_RAW);
d1278 1
a1278 1
    sock_define_const("SOCK_RDM", SOCK_RDM);
d1281 1
a1281 1
    sock_define_const("SOCK_SEQPACKET", SOCK_SEQPACKET);
d1284 1
a1284 1
    sock_define_const("SOCK_PACKET", SOCK_PACKET);
d1287 2
a1288 2
    sock_define_const("AF_INET", AF_INET);
    sock_define_const("PF_INET", PF_INET);
d1290 2
a1291 2
    sock_define_const("AF_UNIX", AF_UNIX);
    sock_define_const("PF_UNIX", PF_UNIX);
d1294 2
a1295 2
    sock_define_const("AF_AX25", AF_AX25);
    sock_define_const("PF_AX25", PF_AX25);
d1298 2
a1299 2
    sock_define_const("AF_IPX", AF_IPX);
    sock_define_const("PF_IPX", PF_IPX);
d1302 2
a1303 2
    sock_define_const("AF_APPLETALK", AF_APPLETALK);
    sock_define_const("PF_APPLETALK", PF_APPLETALK);
d1306 3
a1308 3
    sock_define_const("MSG_OOB", MSG_OOB);
    sock_define_const("MSG_PEEK", MSG_PEEK);
    sock_define_const("MSG_DONTROUTE", MSG_DONTROUTE);
d1310 1
a1310 1
    sock_define_const("SOL_SOCKET", SOL_SOCKET);
d1312 1
a1312 1
    sock_define_const("SOL_IP", SOL_IP);
d1315 1
a1315 1
    sock_define_const("SOL_IPX", SOL_IPX);
d1318 1
a1318 1
    sock_define_const("SOL_AX25", SOL_AX25);
d1321 1
a1321 1
    sock_define_const("SOL_ATALK", SOL_ATALK);
d1324 1
a1324 1
    sock_define_const("SOL_TCP", SOL_TCP);
d1327 1
a1327 1
    sock_define_const("SOL_UDP", SOL_UDP);
d1331 1
a1331 1
    sock_define_const("SO_DEBUG", SO_DEBUG);
d1333 1
a1333 1
    sock_define_const("SO_REUSEADDR", SO_REUSEADDR);
d1335 1
a1335 1
    sock_define_const("SO_TYPE", SO_TYPE);
d1338 1
a1338 1
    sock_define_const("SO_ERROR", SO_ERROR);
d1341 1
a1341 1
    sock_define_const("SO_DONTROUTE", SO_DONTROUTE);
d1344 1
a1344 1
    sock_define_const("SO_BROADCAST", SO_BROADCAST);
d1347 1
a1347 1
    sock_define_const("SO_SNDBUF", SO_SNDBUF);
d1350 1
a1350 1
    sock_define_const("SO_RCVBUF", SO_RCVBUF);
d1352 1
a1352 1
    sock_define_const("SO_KEEPALIVE", SO_KEEPALIVE);
d1354 1
a1354 1
    sock_define_const("SO_OOBINLINE", SO_OOBINLINE);
d1357 1
a1357 1
    sock_define_const("SO_NO_CHECK", SO_NO_CHECK);
d1360 1
a1360 1
    sock_define_const("SO_PRIORITY", SO_PRIORITY);
d1362 1
a1362 1
    sock_define_const("SO_LINGER", SO_LINGER);
d1365 1
a1365 1
    sock_define_const("SOPRI_INTERACTIVE", SOPRI_INTERACTIVE);
d1368 1
a1368 1
    sock_define_const("SOPRI_NORMAL", SOPRI_NORMAL);
d1371 1
a1371 1
    sock_define_const("SOPRI_BACKGROUND", SOPRI_BACKGROUND);
d1375 1
a1375 1
    sock_define_const("IP_MULTICAST_IF", IP_MULTICAST_IF);
d1378 1
a1378 1
    sock_define_const("IP_MULTICAST_TTL", IP_MULTICAST_TTL);
d1381 1
a1381 1
    sock_define_const("IP_MULTICAST_LOOP", IP_MULTICAST_LOOP);
d1384 1
a1384 1
    sock_define_const("IP_ADD_MEMBERSHIP", IP_ADD_MEMBERSHIP);
d1388 1
a1388 1
    sock_define_const("IP_DEFAULT_MULTICAST_TTL", IP_DEFAULT_MULTICAST_TTL);
d1391 1
a1391 1
    sock_define_const("IP_DEFAULT_MULTICAST_LOOP", IP_DEFAULT_MULTICAST_LOOP);
d1394 1
a1394 1
    sock_define_const("IP_MAX_MEMBERSHIPS", IP_MAX_MEMBERSHIPS);
d1398 1
a1398 1
    sock_define_const("IPX_TYPE", IPX_TYPE);
d1402 1
a1402 1
    sock_define_const("TCP_NODELAY", TCP_NODELAY);
d1405 1
a1405 1
    sock_define_const("TCP_MAXSEG", TCP_MAXSEG);
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/11/25 03:31:18 $
d12 1
a12 2
#include "rubyio.h"
#include "rubysig.h"
d25 1
a25 8
#ifdef USE_CWGUSI
extern int fileno(FILE *stream); /* <unix.mac.h> */
extern int rb_thread_select(int, fd_set*, fd_set*, fd_set*, struct timeval*); /* thread.c */
# include <sys/errno.h>
# include <GUSI.h>
#endif

#if defined(USE_THREAD) && defined(HAVE_FCNTL)
d37 8
a44 5
VALUE rb_cBasicSocket;
VALUE rb_cIPsocket;
VALUE rb_cTCPsocket;
VALUE rb_cTCPserver;
VALUE rb_cUDPsocket;
d46 2
a47 2
VALUE rb_cUNIXsocket;
VALUE rb_cUNIXserver;
d49 1
a49 1
VALUE rb_cSocket;
d51 2
a52 1
static VALUE rb_eSocket;
d55 1
a55 1
VALUE rb_cSOCKSsocket;
d60 1
d72 1
a72 4
    SOCKET s;

    if (!fptr->f) return;
    s = fileno(fptr->f);
d74 1
a74 1
    if (fptr->f2) free(fptr->f2);
a87 1
    rb_secure(4);
d95 1
a95 2
    rb_io_unbuffered(fp);
    rb_obj_call_init((VALUE)sock);
a109 1
    rb_secure(4);
d115 1
a115 3
	if (how < 0 || 2 < how) {
	    rb_raise(rb_eArgError, "`how' should be either 0, 1, 2");
	}
a124 49
bsock_close_read(sock)
    VALUE sock;
{
    OpenFile *fptr;

    rb_secure(4);
    GetOpenFile(sock, fptr);
    if (fptr->f2 == 0) {
	return rb_io_close(sock);
    }
    if (shutdown(fileno(fptr->f), 0) == -1)
	rb_sys_fail(0);
    fptr->mode &= ~FMODE_READABLE;
#ifdef NT
    free(fptr->f);
#else
    fclose(fptr->f);
#endif
    fptr->f = fptr->f2;
    fptr->f2 = 0;

    return Qnil;
}

static VALUE
bsock_close_write(sock)
    VALUE sock;
{
    OpenFile *fptr;

    rb_secure(4);
    GetOpenFile(sock, fptr);
    if (fptr->f2 == 0) {
	return rb_io_close(sock);
    }
    if (shutdown(fileno(fptr->f), 1) == -1)
	rb_sys_fail(0);
    fptr->mode &= ~FMODE_WRITABLE;
#ifdef NT
    free(fptr->f2);
#else
    fclose(fptr->f2);
#endif
    fptr->f2 = 0;

    return Qnil;
}

static VALUE
d126 2
a127 1
    VALUE sock, lev, optname, val;
d151 2
a152 1
	v = rb_str2cstr(val, &vlen);
a165 1
#if !defined(__BEOS__)
d179 1
a179 4
    return rb_str_new(buf, len);
#else
    rb_notimplement();
#endif
d193 1
a193 1
    return rb_str_new(buf, len);
d207 1
a207 1
    return rb_str_new(buf, len);
d216 1
a216 1
    VALUE msg, to;
a220 2
    char *m, *t;
    int mlen, tlen;
d225 2
d228 1
a228 1
    f = GetWriteFile(fptr);
d231 2
a232 2
#ifdef USE_THREAD
    rb_thread_fd_writable(fd);
a233 1
    m = rb_str2cstr(msg, &mlen);
d235 3
a237 3
	t = rb_str2cstr(to, &tlen);
	n = sendto(fd, m, mlen, NUM2INT(flags),
		   (struct sockaddr*)t, tlen);
d240 1
a240 1
	n = send(fd, m, mlen, NUM2INT(flags));
d249 2
a250 2
#ifdef USE_THREAD
	    rb_thread_schedule();
d280 1
d292 1
a292 1
    str = rb_str_new(0, NUM2INT(len));
d296 2
a297 2
#ifdef USE_THREAD
    rb_thread_wait_fd(fd);
d312 2
a313 2
#ifdef USE_THREAD
	    rb_thread_schedule();
d319 1
a319 1
    rb_obj_taint(str);
d325 1
a325 1
	    rb_raise(rb_eTypeError, "sockaddr size differs - should not happen");
d327 1
a327 1
	return rb_assoc_new(str, ipaddr((struct sockaddr_in *)buf));
d332 2
a333 2
	    return rb_assoc_new(str, rb_assoc_new(RARRAY(addr)->ptr[2],
						  RARRAY(addr)->ptr[1]));
d337 4
a340 1
	return rb_assoc_new(str, unixaddr((struct sockaddr_un *)buf));
d343 1
a343 1
	return rb_assoc_new(str, rb_str_new(buf, alen));
d356 1
a356 90
static VALUE
mkipaddr(x)
    unsigned long x;
{
    char buf[16];

    x = ntohl(x);
    sprintf(buf, "%d.%d.%d.%d",
	    (int) (x>>24) & 0xff, (int) (x>>16) & 0xff,
	    (int) (x>> 8) & 0xff, (int) (x>> 0) & 0xff);
    return rb_str_new2(buf);
}

static VALUE
ipaddr(sockaddr)
    struct sockaddr_in *sockaddr;
{
    VALUE family, port, addr1, addr2;
    VALUE ary;
    struct hostent *hostent;

    family = rb_str_new2("AF_INET");
    hostent = gethostbyaddr((char*)&sockaddr->sin_addr.s_addr,
			    sizeof(sockaddr->sin_addr),
			    AF_INET);
    addr1 = 0;
    if (hostent) {
	addr1 = rb_str_new2(hostent->h_name);
    }
    addr2 = mkipaddr(sockaddr->sin_addr.s_addr);
    if (!addr1) addr1 = addr2;

    port = INT2FIX(ntohs(sockaddr->sin_port));
    ary = rb_ary_new3(4, family, port, addr1, addr2);

    return ary;
}

#ifndef HAVE_INET_ATON
static unsigned long
inet_aton(host, inp)
    char *host;
    struct in_addr *inp;
{
    int d1, d2, d3, d4;
    char ch;

    if (sscanf(host, "%d.%d.%d.%d%c", &d1, &d2, &d3, &d4, &ch) == 4 &&
	0 <= d1 && d1 <= 255 && 0 <= d2 && d2 <= 255 &&
	0 <= d3 && d3 <= 255 && 0 <= d4 && d4 <= 255) {
	inp->s_addr = htonl(
	    ((long) d1 << 24) | ((long) d2 << 16) |
	    ((long) d3 << 8) | ((long) d4 << 0));
	return 1;
    }
    return 0;
}
#endif

static void
setipaddr(name, addr)
    char *name;
    struct sockaddr_in *addr;
{
    struct hostent *hp;

    if (name[0] == 0) {
	addr->sin_addr.s_addr = INADDR_ANY;
    }
    else if (name[0] == '<' && strcmp(name, "<broadcast>") == 0) {
	addr->sin_addr.s_addr = INADDR_BROADCAST;
    }
    else if (inet_aton(name, &addr->sin_addr) != 0) {
	/* ok to set addr->sin_addr */
    }
    else {
	hp = gethostbyname(name);
	if (!hp) {
#ifdef HAVE_HSTRERROR
	    extern int h_errno;
	    rb_raise(rb_eSocket, (char *)hstrerror(h_errno));
#else
	    rb_raise(rb_eSocket, "host not found");
#endif
	}
	memcpy((char *) &addr->sin_addr, hp->h_addr, hp->h_length);
    }
}

#if defined(USE_THREAD) && defined(HAVE_FCNTL)
d399 1
a399 1
		rb_thread_select(fd+1, 0, &fds, 0, 0);
d437 1
d444 2
a445 1
	    if (!inet_aton(host, &sockaddr.sin_addr)) {
d451 1
a451 1
		    rb_raise(rb_eSocket, (char *)hstrerror(h_errno));
d453 1
a453 1
		    rb_raise(rb_eSocket, "host not found");
a456 1
	    hostaddr = sockaddr.sin_addr.s_addr;
d470 2
a471 1
    servent = getservbyname(STR2CSTR(serv), "tcp");
d473 3
a475 6
	char *s = STR2CSTR(serv);
	char *end;

	servport = strtoul(s, &end, 0);
	if (*end != '\0') {
	    rb_raise(rb_eSocket, "no such servce %s", s);
a481 3
#ifdef __BEOS__
    fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
#else
d484 1
a484 1
	rb_raise(rb_eSocket, "no such proto %s", servent->s_proto);
a487 1
#endif
d508 1
a508 1
#if defined(USE_THREAD) && defined(HAVE_FCNTL)
d510 1
a510 1
			       sizeof(sockaddr), type);
d526 1
a526 1
	close(fd);
a560 43
tcp_s_gethostbyname(obj, host)
    VALUE obj, host;
{
    struct sockaddr_in addr;
    struct hostent *h;
    char **pch;
    VALUE ary, names;

    setipaddr(STR2CSTR(host), &addr);
    h = gethostbyaddr((char *)&addr.sin_addr,
		      sizeof(addr.sin_addr),
		      AF_INET);

    if (h == NULL) {
#ifdef HAVE_HSTRERROR
	extern int h_errno;
	rb_raise(rb_eSocket, (char *)hstrerror(h_errno));
#else
	rb_raise(rb_eSocket, "host not found");
#endif
    }
    ary = rb_ary_new();
    rb_ary_push(ary, rb_str_new2(h->h_name));
    names = rb_ary_new();
    rb_ary_push(ary, names);
    for (pch = h->h_aliases; *pch; pch++) {
	rb_ary_push(names, rb_str_new2(*pch));
    }
    rb_ary_push(ary, NUM2INT(h->h_addrtype));
#ifdef h_addr
    for (pch = h->h_addr_list; *pch; pch++) {
	memcpy((char *) &addr.sin_addr, *pch, h->h_length);
	rb_ary_push(ary, mkipaddr(addr.sin_addr.s_addr));
    }
#else
    memcpy((char *)&addr.sin_addr, h->h_addr, h->h_length);
    rb_ary_push(ary, mkipaddr(addr.sin_addr.s_addr));
#endif

    return ary;
}

static VALUE
d584 2
a585 2
#ifdef USE_THREAD
    rb_thread_wait_fd(fd);
d597 2
a598 2
#ifdef USE_THREAD
	    rb_thread_schedule();
d617 1
a617 1
    return s_accept(rb_cTCPsocket, fileno(fptr->f),
d673 75
d784 1
a784 1
    if (rb_obj_is_kind_of(host, rb_cInteger)) {
d789 2
a790 1
	setipaddr(STR2CSTR(host), &addr);
d808 2
d815 1
a815 1
    else if (rb_obj_is_kind_of(host, rb_cInteger)) {
d820 2
a821 1
	setipaddr(STR2CSTR(host), addr);
d824 1
a824 1
	addr->sin_port = htons(FIX2INT(port));
d829 2
a830 1
	servent = getservbyname(STR2CSTR(port), "udp");
d835 4
a838 7
	    char *s = STR2CSTR(port);
	    char *end;
	    int portno;

	    portno = strtoul(s, &end, 0);
	    if (*end != '\0') {
		rb_raise(rb_eSocket, "no such servce %s", s);
d862 2
a863 2
#ifdef USE_THREAD
	    rb_thread_schedule();
a898 2
    char *m;
    int mlen;
d904 1
d908 1
a908 2
    f = GetWriteFile(fptr);
    m = rb_str2cstr(mesg, &mlen);
d910 2
a911 2
    n = sendto(fileno(f), m, mlen, NUM2INT(flags),
	       (struct sockaddr*)&addr, sizeof(addr));
d919 2
a920 2
#ifdef USE_THREAD
	    rb_thread_schedule();
d960 1
a960 1
    return rb_str_new2(fptr->path);
d964 2
a965 2
unix_svr_s_open(sock, path)
    VALUE sock, path;
d967 1
a967 1
    return open_unix(sock, path, 1);
d989 1
a989 1
    return s_accept(rb_cUNIXsocket, fileno(fptr->f),
d997 1
a997 1
    return rb_assoc_new(rb_str_new2("AF_UNIX"),rb_str_new2(sockaddr->sun_path));
a1057 1
#ifdef PF_INET
a1059 1
#endif
d1079 1
a1079 1
	    rb_raise(rb_eSocket, "Unknown socket domain %s", ptr);
d1107 1
a1107 1
	    rb_raise(rb_eSocket, "Unknown socket type %s", ptr);
a1123 1

d1138 2
a1139 1
#if !defined(NT) && !defined(__BEOS__)
d1146 1
a1146 1
    return rb_assoc_new(sock_new(class, sp[0]), sock_new(class, sp[1]));
d1159 1
a1159 1
    rb_str_modify(addr);
d1170 2
a1171 2
#ifdef USE_THREAD
	    rb_thread_schedule();
d1188 1
a1188 1
    rb_str_modify(addr);
d1229 1
a1229 1
    sock2 = s_accept(rb_cSocket,fileno(fptr->f),(struct sockaddr*)buf,&len);
d1231 1
a1231 1
    return rb_assoc_new(sock2, rb_str_new(buf, len));
d1245 1
a1245 1
    return rb_str_new2(buf);
d1259 1
a1259 1
  return rb_str_new2(un.nodename);
d1275 1
d1282 1
a1282 1
	rb_raise(rb_eSocket, (char *)hstrerror(h_errno));
d1284 1
a1284 1
	rb_raise(rb_eSocket, "host not found");
d1287 4
a1290 4
    ary = rb_ary_new();
    rb_ary_push(ary, rb_str_new2(h->h_name));
    names = rb_ary_new();
    rb_ary_push(ary, names);
d1292 1
a1292 1
	rb_ary_push(names, rb_str_new2(*pch));
d1294 1
a1294 1
    rb_ary_push(ary, NUM2INT(h->h_addrtype));
d1297 1
a1297 1
	rb_ary_push(ary, rb_str_new(*pch, h->h_length));
d1300 1
a1300 1
    rb_ary_push(ary, rb_str_new(h->h_addr, h->h_length));
d1313 1
a1313 1
    if (rb_obj_is_kind_of(host, rb_cInteger)) {
d1318 2
a1319 1
	setipaddr(STR2CSTR(host), &addr);
d1335 2
a1336 2
    int alen;
    char *addr;
d1339 3
a1341 3
    rb_scan_args(argc, argv, "11", &vaddr, &vtype);
    addr = rb_str2cstr(vaddr, &alen);
    if (!NIL_P(vtype)) {
d1348 1
a1348 1
    h = gethostbyaddr(addr, alen, type);
d1364 1
d1366 1
a1366 1
    else proto = STR2CSTR(protocol);
d1368 3
a1370 12
    sp = getservbyname(STR2CSTR(service), proto);
    if (sp) {
	port = ntohs(sp->s_port);
    }
    else {
	char *s = STR2CSTR(service);
	char *end;

	port = strtoul(s, &end, 0);
	if (*end != '\0') {
	    rb_raise(rb_eSocket, "no such servce %s/%s", s, proto);
	}
d1372 1
d1380 1
a1380 1
sock_rb_define_const(name, value)
d1382 1
a1382 1
    int value;
d1384 1
a1384 1
    rb_define_const(rb_cSocket, name, INT2FIX(value));
d1390 1
a1390 1
    rb_eSocket = rb_define_class("SocketError", rb_eStandardError);
d1392 20
a1411 23
    rb_cBasicSocket = rb_define_class("BasicSocket", rb_cIO);
    rb_undef_method(CLASS_OF(rb_cBasicSocket), "new");
    rb_undef_method(CLASS_OF(rb_cBasicSocket), "open");
    rb_define_method(rb_cBasicSocket, "close_read", bsock_close_read, 0);
    rb_define_method(rb_cBasicSocket, "close_write", bsock_close_write, 0);
    rb_define_method(rb_cBasicSocket, "shutdown", bsock_shutdown, -1);
    rb_define_method(rb_cBasicSocket, "setsockopt", bsock_setsockopt, 3);
    rb_define_method(rb_cBasicSocket, "getsockopt", bsock_getsockopt, 2);
    rb_define_method(rb_cBasicSocket, "getsockname", bsock_getsockname, 0);
    rb_define_method(rb_cBasicSocket, "getpeername", bsock_getpeername, 0);
    rb_define_method(rb_cBasicSocket, "send", bsock_send, -1);
    rb_define_method(rb_cBasicSocket, "recv", bsock_recv, -1);

    rb_cIPsocket = rb_define_class("IPsocket", rb_cBasicSocket);
    rb_define_method(rb_cIPsocket, "addr", ip_addr, 0);
    rb_define_method(rb_cIPsocket, "peeraddr", ip_peeraddr, 0);
    rb_define_singleton_method(rb_cIPsocket, "getaddress", ip_s_getaddress, 1);

    rb_cTCPsocket = rb_define_class("TCPsocket", rb_cIPsocket);
    rb_define_singleton_method(rb_cTCPsocket, "open", tcp_s_open, 2);
    rb_define_singleton_method(rb_cTCPsocket, "new", tcp_s_open, 2);
    rb_define_singleton_method(rb_cTCPsocket, "gethostbyname", tcp_s_gethostbyname, 1);
    rb_define_method(rb_cTCPsocket, "recvfrom", tcp_recvfrom, -1);
d1414 17
a1430 17
    rb_cSOCKSsocket = rb_define_class("SOCKSsocket", rb_cTCPsocket);
    rb_define_singleton_method(rb_cSOCKSsocket, "open", socks_s_open, 2);
    rb_define_singleton_method(rb_cSOCKSsocket, "new", socks_s_open, 2);
#endif

    rb_cTCPserver = rb_define_class("TCPserver", rb_cTCPsocket);
    rb_define_singleton_method(rb_cTCPserver, "open", tcp_svr_s_open, -1);
    rb_define_singleton_method(rb_cTCPserver, "new", tcp_svr_s_open, -1);
    rb_define_method(rb_cTCPserver, "accept", tcp_accept, 0);

    rb_cUDPsocket = rb_define_class("UDPsocket", rb_cIPsocket);
    rb_define_singleton_method(rb_cUDPsocket, "open", udp_s_open, 0);
    rb_define_singleton_method(rb_cUDPsocket, "new", udp_s_open, 0);
    rb_define_method(rb_cUDPsocket, "connect", udp_connect, 2);
    rb_define_method(rb_cUDPsocket, "bind", udp_bind, 2);
    rb_define_method(rb_cUDPsocket, "send", udp_send, -1);
    rb_define_method(rb_cUDPsocket, "recvfrom", udp_recvfrom, -1);
d1433 32
a1464 32
    rb_cUNIXsocket = rb_define_class("UNIXsocket", rb_cBasicSocket);
    rb_define_singleton_method(rb_cUNIXsocket, "open", unix_s_sock_open, 1);
    rb_define_singleton_method(rb_cUNIXsocket, "new", unix_s_sock_open, 1);
    rb_define_method(rb_cUNIXsocket, "path", unix_path, 0);
    rb_define_method(rb_cUNIXsocket, "addr", unix_addr, 0);
    rb_define_method(rb_cUNIXsocket, "peeraddr", unix_peeraddr, 0);
    rb_define_method(rb_cUNIXsocket, "recvfrom", unix_recvfrom, -1);

    rb_cUNIXserver = rb_define_class("UNIXserver", rb_cUNIXsocket);
    rb_define_singleton_method(rb_cUNIXserver, "open", unix_svr_s_open, 1);
    rb_define_singleton_method(rb_cUNIXserver, "new", unix_svr_s_open, 1);
    rb_define_method(rb_cUNIXserver, "accept", unix_accept, 0);
#endif

    rb_cSocket = rb_define_class("Socket", rb_cBasicSocket);
    rb_define_singleton_method(rb_cSocket, "open", sock_s_open, 3);
    rb_define_singleton_method(rb_cSocket, "new", sock_s_open, 3);
    rb_define_singleton_method(rb_cSocket, "for_fd", sock_s_for_fd, 1);

    rb_define_method(rb_cSocket, "connect", sock_connect, 1);
    rb_define_method(rb_cSocket, "bind", sock_bind, 1);
    rb_define_method(rb_cSocket, "listen", sock_listen, 1);
    rb_define_method(rb_cSocket, "accept", sock_accept, 0);

    rb_define_method(rb_cSocket, "recvfrom", sock_recvfrom, -1);

    rb_define_singleton_method(rb_cSocket, "socketpair", sock_s_socketpair, 3);
    rb_define_singleton_method(rb_cSocket, "pair", sock_s_socketpair, 3);
    rb_define_singleton_method(rb_cSocket, "gethostname", sock_gethostname, 0);
    rb_define_singleton_method(rb_cSocket, "gethostbyname", sock_s_gethostbyname, 1);
    rb_define_singleton_method(rb_cSocket, "gethostbyaddr", sock_s_gethostbyaddr, -1);
    rb_define_singleton_method(rb_cSocket, "getservbyname", sock_s_getservbyaname, -1);
d1467 4
a1470 6
    mConst = rb_define_module_under(rb_cSocket, "Constants");
    sock_rb_define_const("SOCK_STREAM", SOCK_STREAM);
    sock_rb_define_const("SOCK_DGRAM", SOCK_DGRAM);
#ifdef SOCK_RAW
    sock_rb_define_const("SOCK_RAW", SOCK_RAW);
#endif
d1472 1
a1472 1
    sock_rb_define_const("SOCK_RDM", SOCK_RDM);
d1475 1
a1475 1
    sock_rb_define_const("SOCK_SEQPACKET", SOCK_SEQPACKET);
d1478 1
a1478 1
    sock_rb_define_const("SOCK_PACKET", SOCK_PACKET);
d1481 2
a1482 4
    sock_rb_define_const("AF_INET", AF_INET);
#ifdef PF_INET
    sock_rb_define_const("PF_INET", PF_INET);
#endif
d1484 2
a1485 2
    sock_rb_define_const("AF_UNIX", AF_UNIX);
    sock_rb_define_const("PF_UNIX", PF_UNIX);
d1488 2
a1489 2
    sock_rb_define_const("AF_AX25", AF_AX25);
    sock_rb_define_const("PF_AX25", PF_AX25);
d1492 2
a1493 2
    sock_rb_define_const("AF_IPX", AF_IPX);
    sock_rb_define_const("PF_IPX", PF_IPX);
d1496 2
a1497 2
    sock_rb_define_const("AF_APPLETALK", AF_APPLETALK);
    sock_rb_define_const("PF_APPLETALK", PF_APPLETALK);
d1500 3
a1502 7
    sock_rb_define_const("MSG_OOB", MSG_OOB);
#ifdef MSG_PEEK
    sock_rb_define_const("MSG_PEEK", MSG_PEEK);
#endif
#ifdef MSG_DONTROUTE
    sock_rb_define_const("MSG_DONTROUTE", MSG_DONTROUTE);
#endif
d1504 1
a1504 1
    sock_rb_define_const("SOL_SOCKET", SOL_SOCKET);
d1506 1
a1506 1
    sock_rb_define_const("SOL_IP", SOL_IP);
d1509 1
a1509 1
    sock_rb_define_const("SOL_IPX", SOL_IPX);
d1512 1
a1512 1
    sock_rb_define_const("SOL_AX25", SOL_AX25);
d1515 1
a1515 1
    sock_rb_define_const("SOL_ATALK", SOL_ATALK);
d1518 1
a1518 1
    sock_rb_define_const("SOL_TCP", SOL_TCP);
d1521 1
a1521 1
    sock_rb_define_const("SOL_UDP", SOL_UDP);
d1525 1
a1525 1
    sock_rb_define_const("SO_DEBUG", SO_DEBUG);
d1527 1
a1527 1
    sock_rb_define_const("SO_REUSEADDR", SO_REUSEADDR);
d1529 1
a1529 1
    sock_rb_define_const("SO_TYPE", SO_TYPE);
d1532 1
a1532 1
    sock_rb_define_const("SO_ERROR", SO_ERROR);
d1535 1
a1535 1
    sock_rb_define_const("SO_DONTROUTE", SO_DONTROUTE);
d1538 1
a1538 1
    sock_rb_define_const("SO_BROADCAST", SO_BROADCAST);
d1541 1
a1541 1
    sock_rb_define_const("SO_SNDBUF", SO_SNDBUF);
d1544 1
a1544 4
    sock_rb_define_const("SO_RCVBUF", SO_RCVBUF);
#endif
#ifdef SO_KEEPALIVE
    sock_rb_define_const("SO_KEEPALIVE", SO_KEEPALIVE);
d1546 1
d1548 1
a1548 1
    sock_rb_define_const("SO_OOBINLINE", SO_OOBINLINE);
d1551 1
a1551 1
    sock_rb_define_const("SO_NO_CHECK", SO_NO_CHECK);
d1554 1
a1554 4
    sock_rb_define_const("SO_PRIORITY", SO_PRIORITY);
#endif
#ifdef SO_LINGER
    sock_rb_define_const("SO_LINGER", SO_LINGER);
d1556 1
d1559 1
a1559 1
    sock_rb_define_const("SOPRI_INTERACTIVE", SOPRI_INTERACTIVE);
d1562 1
a1562 1
    sock_rb_define_const("SOPRI_NORMAL", SOPRI_NORMAL);
d1565 1
a1565 1
    sock_rb_define_const("SOPRI_BACKGROUND", SOPRI_BACKGROUND);
d1569 1
a1569 1
    sock_rb_define_const("IP_MULTICAST_IF", IP_MULTICAST_IF);
d1572 1
a1572 1
    sock_rb_define_const("IP_MULTICAST_TTL", IP_MULTICAST_TTL);
d1575 1
a1575 1
    sock_rb_define_const("IP_MULTICAST_LOOP", IP_MULTICAST_LOOP);
d1578 1
a1578 1
    sock_rb_define_const("IP_ADD_MEMBERSHIP", IP_ADD_MEMBERSHIP);
d1582 1
a1582 1
    sock_rb_define_const("IP_DEFAULT_MULTICAST_TTL", IP_DEFAULT_MULTICAST_TTL);
d1585 1
a1585 1
    sock_rb_define_const("IP_DEFAULT_MULTICAST_LOOP", IP_DEFAULT_MULTICAST_LOOP);
d1588 1
a1588 1
    sock_rb_define_const("IP_MAX_MEMBERSHIPS", IP_MAX_MEMBERSHIPS);
d1592 1
a1592 1
    sock_rb_define_const("IPX_TYPE", IPX_TYPE);
d1596 1
a1596 1
    sock_rb_define_const("TCP_NODELAY", TCP_NODELAY);
d1599 1
a1599 1
    sock_rb_define_const("TCP_MAXSEG", TCP_MAXSEG);
@


1.1.1.3.2.1
log
@990212
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:33 $
a98 2
#else
    fd = dup(fd);
a142 1
    shutdown(fileno(fptr->f), 0);
d146 2
a147 3
#ifdef USE_THREAD
    rb_thread_fd_close(fileno(fptr->f));
#endif
d171 2
a172 1
    shutdown(fileno(fptr->f2), 1);
@


1.1.1.3.2.2
log
@990225
@
text
@d6 1
a6 1
  $Date: 1999/02/12 11:17:06 $
d105 1
a105 1
    rb_obj_call_init((VALUE)sock, 0, 0);
@


1.1.1.3.2.3
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/25 06:39:12 $
d33 1
a33 1
#if defined(HAVE_FCNTL)
d46 4
a49 4
VALUE rb_cIPSocket;
VALUE rb_cTCPSocket;
VALUE rb_cTCPServer;
VALUE rb_cUDPSocket;
d51 2
a52 2
VALUE rb_cUNIXSocket;
VALUE rb_cUNIXServer;
d59 1
a59 1
VALUE rb_cSOCKSSocket;
d149 1
d151 1
d296 1
d298 1
d315 1
d317 1
d332 3
a334 3
    RECV_TCP,			/* TCPSocket#recvfrom */
    RECV_UDP,			/* UDPSocket#recvfrom */
    RECV_UNIX,			/* UNIXSocket#recvfrom */
d361 1
d363 1
d377 1
d379 1
d507 1
a507 1
#if defined(HAVE_FCNTL)
d664 1
a664 1
#if defined(HAVE_FCNTL)
d745 1
a745 1
    rb_ary_push(ary, INT2NUM(h->h_addrtype));
d783 1
d785 1
d796 1
d798 1
d816 1
a816 1
    return s_accept(rb_cTCPSocket, fileno(fptr->f),
d984 1
d986 1
d1043 1
d1045 1
d1113 1
a1113 1
    return s_accept(rb_cUNIXSocket, fileno(fptr->f),
d1296 1
d1298 1
d1419 1
a1419 1
    rb_ary_push(ary, INT2NUM(h->h_addrtype));
d1536 10
a1545 12
    rb_cIPSocket = rb_define_class("IPSocket", rb_cBasicSocket);
    rb_define_global_const("IPsocket", rb_cIPSocket);
    rb_define_method(rb_cIPSocket, "addr", ip_addr, 0);
    rb_define_method(rb_cIPSocket, "peeraddr", ip_peeraddr, 0);
    rb_define_singleton_method(rb_cIPSocket, "getaddress", ip_s_getaddress, 1);

    rb_cTCPSocket = rb_define_class("TCPSocket", rb_cIPSocket);
    rb_define_global_const("TCPsocket", rb_cTCPSocket);
    rb_define_singleton_method(rb_cTCPSocket, "open", tcp_s_open, 2);
    rb_define_singleton_method(rb_cTCPSocket, "new", tcp_s_open, 2);
    rb_define_singleton_method(rb_cTCPSocket, "gethostbyname", tcp_s_gethostbyname, 1);
    rb_define_method(rb_cTCPSocket, "recvfrom", tcp_recvfrom, -1);
d1548 17
a1564 20
    rb_cSOCKSSocket = rb_define_class("SOCKSSocket", rb_cTCPSocket);
    rb_define_global_const("SOCKSsocket", rb_cSOCKSSocket);
    rb_define_singleton_method(rb_cSOCKSSocket, "open", socks_s_open, 2);
    rb_define_singleton_method(rb_cSOCKSSocket, "new", socks_s_open, 2);
#endif

    rb_cTCPServer = rb_define_class("TCPServer", rb_cTCPSocket);
    rb_define_global_const("TCPserver", rb_cTCPServer);
    rb_define_singleton_method(rb_cTCPServer, "open", tcp_svr_s_open, -1);
    rb_define_singleton_method(rb_cTCPServer, "new", tcp_svr_s_open, -1);
    rb_define_method(rb_cTCPServer, "accept", tcp_accept, 0);

    rb_cUDPSocket = rb_define_class("UDPSocket", rb_cIPSocket);
    rb_define_global_const("UDPsocket", rb_cUDPSocket);
    rb_define_singleton_method(rb_cUDPSocket, "open", udp_s_open, 0);
    rb_define_singleton_method(rb_cUDPSocket, "new", udp_s_open, 0);
    rb_define_method(rb_cUDPSocket, "connect", udp_connect, 2);
    rb_define_method(rb_cUDPSocket, "bind", udp_bind, 2);
    rb_define_method(rb_cUDPSocket, "send", udp_send, -1);
    rb_define_method(rb_cUDPSocket, "recvfrom", udp_recvfrom, -1);
d1567 12
a1578 14
    rb_cUNIXSocket = rb_define_class("UNIXSocket", rb_cBasicSocket);
    rb_define_global_const("UNIXsocket", rb_cUNIXSocket);
    rb_define_singleton_method(rb_cUNIXSocket, "open", unix_s_sock_open, 1);
    rb_define_singleton_method(rb_cUNIXSocket, "new", unix_s_sock_open, 1);
    rb_define_method(rb_cUNIXSocket, "path", unix_path, 0);
    rb_define_method(rb_cUNIXSocket, "addr", unix_addr, 0);
    rb_define_method(rb_cUNIXSocket, "peeraddr", unix_peeraddr, 0);
    rb_define_method(rb_cUNIXSocket, "recvfrom", unix_recvfrom, -1);

    rb_cUNIXServer = rb_define_class("UNIXServer", rb_cUNIXSocket);
    rb_define_global_const("UNIXserver", rb_cUNIXServer);
    rb_define_singleton_method(rb_cUNIXServer, "open", unix_svr_s_open, 1);
    rb_define_singleton_method(rb_cUNIXServer, "new", unix_svr_s_open, 1);
    rb_define_method(rb_cUNIXServer, "accept", unix_accept, 0);
@


1.1.1.3.2.4
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:34 $
a21 3
#ifdef __EMX__
#undef HAVE_SYS_UN_H
#endif
d1247 1
a1247 1
#if !defined(NT) && !defined(__BEOS__) && !defined(__EMX__)
@


1.1.1.3.2.5
log
@remove strdup
@
text
@d6 1
a6 1
  $Date: 1999/04/09 17:57:43 $
a66 1
#ifndef HAVE_STRDUP
a67 1
#endif
@


1.1.1.3.2.6
log
@prepare to alpha
@
text
@d6 1
a6 1
  $Date: 1999/04/13 05:18:12 $
d538 2
a541 2
#ifdef EINPROGRESS
	      case EINPROGRESS:
d543 3
a545 1
		rb_thread_fd_writable(fd);
@


1.1.1.3.2.7
log
@to open CVS
@
text
@d6 1
a6 1
  $Date: 1999/04/16 06:03:35 $
d65 4
@


1.1.1.3.2.8
log
@ipv6
@
text
@d6 1
a6 1
  $Date: 1999/04/20 08:21:41 $
a46 3
#ifndef HAVE_GETADDRINFO
# include "addrinfo.h"
#endif
d320 1
a320 1
static VALUE ipaddr _((struct sockaddr *));
d322 1
a322 1
static VALUE unixaddr _((struct sockaddr_un *));
a379 1
#if 0
d383 1
a383 2
#endif
	return rb_assoc_new(str, ipaddr((struct sockaddr *)buf));
d386 1
a386 1
	    VALUE addr = ipaddr((struct sockaddr *)buf);
d410 2
a411 2
mkipaddr(addr)
    struct sockaddr *addr;
d413 1
a413 2
    char buf[1024];
    int error;
d415 4
a418 5
    error = getnameinfo(addr, SA_LEN(addr), buf, sizeof(buf), NULL, 0,
			NI_NUMERICHOST);
    if (error) {
	rb_raise(rb_eSocket, gai_strerror(error));
    }
d424 1
a424 1
    struct sockaddr *sockaddr;
d428 9
a436 16
    struct addrinfo hints, *res;
    int error;
    char hbuf[1024], pbuf[1024];

    switch (sockaddr->sa_family) {
    case AF_INET:
	family = rb_str_new2("AF_INET");
	break;
#ifdef INET6
    case AF_INET6:
	family = rb_str_new2("AF_INET6");
	break;
#endif
    default:
	family = 0;
	break;
d438 4
a441 13
    error = getnameinfo(sockaddr, SA_LEN(sockaddr), hbuf, sizeof(hbuf),
			NULL, 0, 0);
    if (error) {
	rb_raise(rb_eSocket, gai_strerror(error));
    }
    addr1 = rb_str_new2(hbuf);
    error = getnameinfo(sockaddr, SA_LEN(sockaddr), hbuf, sizeof(hbuf),
			pbuf, sizeof(pbuf), NI_NUMERICHOST | NI_NUMERICSERV);
    if (error) {
	rb_raise(rb_eSocket, gai_strerror(error));
    }
    addr2 = rb_str_new2(hbuf);
    port = INT2FIX(atoi(pbuf));
a446 1

d471 1
a471 1
    struct sockaddr *addr;
d473 1
a473 3
    struct addrinfo hints, *res;
    struct sockaddr_in *sin;
    int error;
a474 1
    sin = (struct sockaddr_in *)addr;
d476 1
a476 4
	memset(sin, 0, sizeof(*sin));
	sin->sin_family = AF_INET;
	SET_SIN_LEN(*sin, sizeof(*sin));
	sin->sin_addr.s_addr = INADDR_ANY;
d479 4
a482 3
	sin->sin_family = AF_INET;
	SET_SIN_LEN(*sin, sizeof(*sin));
	sin->sin_addr.s_addr = INADDR_BROADCAST;
d485 8
a492 5
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	error = getaddrinfo(name, NULL, &hints, &res);
	if (error) {
	    rb_raise(rb_eSocket, gai_strerror(error));
d494 1
a494 3
	/* just take the first one */
	memcpy(addr, res->ai_addr, res->ai_addrlen);
	freeaddrinfo(res);
d568 5
a572 1
    struct addrinfo hints, *res, *res0;
d574 2
a576 4
    VALUE sock;
    char pbuf[1024], *portp;
    char *host;
    int error;
d581 41
d623 6
a628 2
    else {
	host = NULL;
d630 10
a639 3
    if (FIXNUM_P(serv)) {
	snprintf(pbuf, sizeof(pbuf), "%d", FIX2UINT(serv));
	portp = pbuf;
d642 1
a642 2
	strcpy(pbuf, STR2CSTR(serv));
	portp = pbuf;
d644 2
a645 3
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
d647 4
a650 1
	hints.ai_flags = AI_PASSIVE;
d652 1
a652 20
    error = getaddrinfo(host, portp, &hints, &res0);
    if (error) {
	rb_raise(rb_eSocket, gai_strerror(error));
    }

    fd = -1;
    for (res = res0; res; res = res->ai_next) {
	status = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	syscall = "socket(2)";
	fd = status;
	if (fd < 0)
	    continue;
	if (type == INET_SERVER) {
	    status = 1;
	    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&status,
		sizeof(status));
	    status = bind(fd, res->ai_addr, res->ai_addrlen);
	    syscall = "bind(2)";
	}
	else {
d654 2
a655 1
	    status = thread_connect(fd, res->ai_addr, res->ai_addrlen, type);
d658 4
a661 4
	    if (type == INET_SOCKS) {
		status = Rconnect(fd, res->ai_addr, res->ai_addrlen);
	    }
	    else
d663 3
a665 3
	    {
		status = connect(fd, res->ai_addr, res->ai_addrlen);
	    }
d667 2
a668 2
	    syscall = "connect(2)";
	}
a669 7
	if (status < 0) {
	    close(fd);
	    fd = -1;
	    continue;
	} else
	    break;
    }
d671 1
a671 3
	if (fd >= 0)
	    close(fd);
	freeaddrinfo(res0);
d674 1
a674 3

    if (type == INET_SERVER)
	listen(fd, 5);
a676 1
    freeaddrinfo(res0);
a704 4
/*
 * NOTE: using gethostbyname() against AF_INET6 is a bad idea, as it
 * does not initialize sin_flowinfo nor sin_scope_id properly.
 */
d709 1
a709 1
    struct sockaddr_storage addr;
d714 4
a717 36
    if (rb_obj_is_kind_of(host, rb_cInteger)) {
	int i = NUM2INT(host);
	struct sockaddr_in *sin;
	sin = (struct sockaddr_in *)&addr;
	memset(sin, 0, sizeof(*sin));
	sin->sin_family = AF_INET;
	SET_SIN_LEN(sin, sizeof(*sin));
	sin->sin_addr.s_addr = htonl(i);
    }
    else {
	setipaddr(STR2CSTR(host), (struct sockaddr *)&addr);
    }
    switch (addr.ss_family) {
    case AF_INET:
      {
	struct sockaddr_in *sin;
	sin = (struct sockaddr_in *)&addr;
	h = gethostbyaddr((char *)&sin->sin_addr,
			  sizeof(sin->sin_addr),
			  sin->sin_family);
	break;
      }
#ifdef INET6
    case AF_INET6:
      {
	struct sockaddr_in6 *sin6;
	sin6 = (struct sockaddr_in6 *)&addr;
	h = gethostbyaddr((char *)&sin6->sin6_addr,
			  sizeof(sin6->sin6_addr),
			  sin6->sin6_family);
	break;
      }
#endif
    default:
	h = NULL;
    }
d737 2
a738 32
	switch (addr.ss_family) {
	case AF_INET:
	  {
	    struct sockaddr_in sin;
	    memset(&sin, 0, sizeof(sin));
	    sin.sin_family = AF_INET;
	    SET_SIN_LEN(sin, sizeof(sin));
	    memcpy((char *) &sin.sin_addr, *pch, h->h_length);
	    h = gethostbyaddr((char *)&sin.sin_addr,
			      sizeof(sin.sin_addr),
			      sin.sin_family);
	    rb_ary_push(ary, mkipaddr((struct sockaddr *)&sin));
	    break;
	  }
#ifdef INET6
	case AF_INET6:
	  {
	    struct sockaddr_in6 sin6;
	    memset(&sin6, 0, sizeof(sin6));
	    sin6.sin6_family = AF_INET;
	    sin6.sin6_len = sizeof(sin6);
	    memcpy((char *) &sin6.sin6_addr, *pch, h->h_length);
	    h = gethostbyaddr((char *)&sin6.sin6_addr,
			      sizeof(sin6.sin6_addr),
			      sin6.sin6_family);
	    rb_ary_push(ary, mkipaddr((struct sockaddr *)&sin6));
	    break;
	  }
#endif
	default:
	    h = NULL;
	}
d796 1
a796 1
    struct sockaddr_storage from;
d800 1
a800 1
    fromlen = sizeof(from);
d862 1
a862 1
    struct sockaddr_storage addr;
d869 1
a869 1
    return ipaddr((struct sockaddr *)&addr);
d877 1
a877 1
    struct sockaddr_storage addr;
d884 1
a884 1
    return ipaddr((struct sockaddr *)&addr);
d891 1
a891 1
    struct sockaddr_storage addr;
d895 1
a895 6
	struct sockaddr_in *sin;
	sin = (struct sockaddr_in *)&addr;
	memset(sin, 0, sizeof(*sin));
	sin->sin_family = AF_INET;
	SET_SIN_LEN(*sin, sizeof(*sin));
	sin->sin_addr.s_addr = htonl(i);
d898 1
a898 1
	setipaddr(STR2CSTR(host), (struct sockaddr *)&addr);
d901 1
a901 1
    return mkipaddr((struct sockaddr *)&addr);
d905 1
a905 3
udp_s_open(argc, argv, class)
    int argc;
    VALUE *argv;
d908 1
a908 13
    VALUE arg;

    if (rb_scan_args(argc, argv, "01", &arg) == 1) {
	if (rb_obj_is_kind_of(arg, rb_cInteger)) {
	    return sock_new(class, socket(NUM2INT(arg), SOCK_DGRAM, 0));
	}
	else {
	    rb_raise(rb_eSocket, "argument must be Integer");
	}
    }
    else {
	return sock_new(class, socket(AF_INET, SOCK_DGRAM, 0));
    }
d911 2
a912 3
static struct addrinfo *
udp_addrsetup(fptr, host, port)
    OpenFile *fptr;	/* use for AF check? */
d914 1
d916 2
a917 5
    struct addrinfo hints, *res;
    int error;
    char *hostp, *portp;
    char hbuf[1024], pbuf[1024];

d919 1
a919 1
	hostp = NULL;
a921 1
	struct sockaddr_in sin;
d923 1
a923 10
	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	SET_SIN_LEN(sin, sizeof(sin));
	sin.sin_addr.s_addr = htonl(i);
	error = getnameinfo((struct sockaddr *)&sin, SIN_LEN(sin),
		    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
	if (error) {
	    rb_raise(rb_eSocket, gai_strerror(error));
	}
	hostp = hbuf;
d926 1
a926 2
	strcpy(hbuf, STR2CSTR(host));
	hostp = hbuf;
d929 1
a929 2
	snprintf(pbuf, sizeof(pbuf), "%d", FIX2INT(port));
	portp = pbuf;
d932 1
a932 2
	portp = STR2CSTR(port);
    }
d934 15
a948 6
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;
    error = getaddrinfo(hostp, portp, &hints, &res);
    if (error) {
	rb_raise(rb_eSocket, gai_strerror(error));
a949 2

    return res;
d956 1
a957 1
    struct addrinfo *res0, *res;
d959 1
a960 2
    res0 = udp_addrsetup(fptr, host, port);
    for (res0 = res; res; res = res->ai_next) {
d962 1
a962 4
	if (connect(fileno(fptr->f), res->ai_addr, res->ai_addrlen) >= 0) {
	    freeaddrinfo(res0);
	    return INT2FIX(0);
	}
d972 1
a974 2
    freeaddrinfo(res0);
    rb_sys_fail("connect(2)");
d982 1
a982 1
    struct sockaddr_storage addr;
a983 1
    struct addrinfo *res0, *res;
d985 1
d987 2
a988 7
    res0 = udp_addrsetup(fptr, host, port);
    for (res = res0; res; res = res->ai_next) {
	if (bind(fileno(fptr->f), res->ai_addr, res->ai_addrlen) < 0) {
	    continue;
	}
	freeaddrinfo(res0);
	return INT2FIX(0);
a989 2
    freeaddrinfo(res0);
    rb_sys_fail("bind(2)");
d1000 1
a1005 1
    struct addrinfo *res0, *res;
d1012 1
a1013 1
    res0 = udp_addrsetup(fptr, host, port);
a1015 1
    for (res = res0; res; res = res->ai_next) {
d1017 3
a1019 6
	n = sendto(fileno(f), m, mlen, NUM2INT(flags), res->ai_addr,
		    res->ai_addrlen);
	if (n >= 0) {
	    freeaddrinfo(res0);
	    return INT2FIX(n);
	}
d1029 1
a1030 2
    freeaddrinfo(res0);
    rb_sys_fail("sendto(2)");
a1410 26
mkaddrinfo(res0)
    struct addrinfo *res0;
{
    char **pch;
    VALUE base, ary;
    struct addrinfo *res;

    if (res0 == NULL) {
	rb_raise(rb_eSocket, "host not found");
    }
    base = rb_ary_new();
    for (res = res0; res; res = res->ai_next) {
	ary = ipaddr(res->ai_addr);
	rb_ary_push(ary, INT2FIX(res->ai_family));
	rb_ary_push(ary, INT2FIX(res->ai_socktype));
	rb_ary_push(ary, INT2FIX(res->ai_protocol));
	rb_ary_push(base, ary);
    }
    return base;
}

/*
 * NOTE: using gethostbyname() against AF_INET6 is a bad idea, as it
 * does not initialize sin_flowinfo nor sin_scope_id properly.
 */
static VALUE
d1414 1
a1414 1
    struct sockaddr_storage addr;
d1419 1
a1419 6
	struct sockaddr_in *sin;
	sin = (struct sockaddr_in *)&addr;
	memset(sin, 0, sizeof(*sin));
	sin->sin_family = AF_INET;
	SET_SIN_LEN(*sin, sizeof(*sin));
	sin->sin_addr.s_addr = htonl(i);
d1422 1
a1422 25
	setipaddr(STR2CSTR(host), (struct sockaddr *)&addr);
    }
    switch (addr.ss_family) {
    case AF_INET:
      {
	struct sockaddr_in *sin;
	sin = (struct sockaddr_in *)&addr;
	h = gethostbyaddr((char *)&sin->sin_addr,
			  sizeof(sin->sin_addr),
			  sin->sin_family);
	break;
      }
#ifdef INET6
    case AF_INET6:
      {
	struct sockaddr_in6 *sin6;
	sin6 = (struct sockaddr_in6 *)&addr;
	h = gethostbyaddr((char *)&sin6->sin6_addr,
			  sizeof(sin6->sin6_addr),
			  sin6->sin6_family);
	break;
      }
#endif
    default:
	h = NULL;
d1424 3
a1486 162
static VALUE
sock_s_getaddrinfo(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE host, port, family, socktype, protocol, flags, ret;
    char hbuf[1024], pbuf[1024];
    char *hptr, *pptr;
    struct addrinfo hints, *res;
    int error;

    host = port = family = socktype = protocol = flags = Qnil;
    rb_scan_args(argc, argv, "24", &host, &port, &family, &socktype, &protocol,
	    &flags);
    if (NIL_P(host)) {
	hptr = NULL;
    }
    else {
	strncpy(hbuf, STR2CSTR(host), sizeof(hbuf));
	hbuf[sizeof(hbuf) - 1] = '\0';
	hptr = hbuf;
    }
    if (NIL_P(port)) {
	pptr = NULL;
    }
    else if (rb_obj_is_kind_of(port, rb_cInteger)) {
	snprintf(pbuf, sizeof(pbuf), "%d", FIX2INT(port));
	pptr = pbuf;
    }
    else {
	strncpy(pbuf, STR2CSTR(port), sizeof(pbuf));
	pbuf[sizeof(pbuf) - 1] = '\0';
	pptr = pbuf;
    }

    memset(&hints, 0, sizeof(hints));
    if (!NIL_P(family) && rb_obj_is_kind_of(family, rb_cInteger)) {
	hints.ai_family = FIX2INT(family);
    }
    else {
	hints.ai_family = PF_UNSPEC;
    }
    if (!NIL_P(socktype) && rb_obj_is_kind_of(socktype, rb_cInteger)) {
	hints.ai_socktype = socktype;
    }
    if (!NIL_P(protocol) && rb_obj_is_kind_of(protocol, rb_cInteger)) {
	hints.ai_protocol = protocol;
    }
    if (!NIL_P(flags) && rb_obj_is_kind_of(flags, rb_cInteger)) {
	hints.ai_flags = flags;
    }
    error = getaddrinfo(hptr, pptr, &hints, &res);
    if (error) {
	rb_raise(rb_eSocket, gai_strerror(error));
    }

    ret = mkaddrinfo(res);
    freeaddrinfo(res);
    return ret;
}

static VALUE
sock_s_getnameinfo(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE sa, af, host, port, flags;
    static char hbuf[1024], pbuf[1024];
    char *hptr, *pptr;
    int fl;
    struct addrinfo hints, *res = NULL;
    int error;
    struct sockaddr_storage ss;
    struct sockaddr *sap;

    sa = flags = Qnil;
    rb_scan_args(argc, argv, "11", &sa, &flags);

    if (TYPE(sa) == T_STRING) {
	if (sizeof(ss) < RSTRING(sa)->len) {
	    rb_raise(rb_eTypeError, "sockaddr length too big");
	}
	memcpy(&ss, RSTRING(sa)->ptr, RSTRING(sa)->len);
	if (RSTRING(sa)->len != ss.ss_len) {
	    rb_raise(rb_eTypeError, "sockaddr size differs - should not happen");
	}
	sap = (struct sockaddr *)&ss;
    }
    else if (TYPE(sa) == T_ARRAY) {
	if (RARRAY(sa)->len == 3) {
	    af = RARRAY(sa)->ptr[0];
	    port = RARRAY(sa)->ptr[1];
	    host = RARRAY(sa)->ptr[2];
	}
	else if (RARRAY(sa)->len >= 4) {
	    af = RARRAY(sa)->ptr[0];
	    port = RARRAY(sa)->ptr[1];
	    host = RARRAY(sa)->ptr[3];
	    if (NIL_P(host)) {
		host = RARRAY(sa)->ptr[2];
	    }
	}
	if (NIL_P(host)) {
	    hptr = NULL;
	}
	else {
	    strncpy(hbuf, STR2CSTR(host), sizeof(hbuf));
	    hbuf[sizeof(hbuf) - 1] = '\0';
	    hptr = hbuf;
	}
	if (NIL_P(port)) {
	    strcpy(pbuf, "0");
	    pptr = NULL;
	}
	else if (rb_obj_is_kind_of(port, rb_cInteger)) {
	    snprintf(pbuf, sizeof(pbuf), "%d", FIX2INT(port));
	    pptr = pbuf;
	}
	else {
	    strncpy(pbuf, STR2CSTR(port), sizeof(pbuf));
	    pbuf[sizeof(pbuf) - 1] = '\0';
	    pptr = pbuf;
	}
	memset(&hints, 0, sizeof(hints));
	if (strcmp(STR2CSTR(af), "AF_INET") == 0) {
	    hints.ai_family = PF_INET;
	}
    #ifdef INET6
	else if (strcmp(STR2CSTR(af), "AF_INET6") == 0) {
	    hints.ai_family = PF_INET6;
	}
    #endif
	else {
	    hints.ai_family = PF_UNSPEC;
	}
	error = getaddrinfo(hptr, pptr, &hints, &res);
	if (error) {
	    rb_raise(rb_eSocket, gai_strerror(error));
	}
	sap = res->ai_addr;
    }
    else {
	rb_raise(rb_eTypeError, "expecting String or Array");
    }

    fl = 0;
    if (!NIL_P(flags) && rb_obj_is_kind_of(flags, rb_cInteger)) {
	fl = FIX2INT(flags);
    }

gotsap:
    error = getnameinfo(sap, SA_LEN(sap), hbuf, sizeof(hbuf),
			pbuf, sizeof(pbuf), fl);
    if (error) {
	rb_raise(rb_eSocket, gai_strerror(error));
    }
    if (res)
	freeaddrinfo(res);

    return rb_ary_new3(2, rb_str_new2(hbuf), rb_str_new2(pbuf));
}

d1543 2
a1544 2
    rb_define_singleton_method(rb_cUDPSocket, "open", udp_s_open, -1);
    rb_define_singleton_method(rb_cUDPSocket, "new", udp_s_open, -1);
a1584 2
    rb_define_singleton_method(rb_cSocket, "getaddrinfo", sock_s_getaddrinfo, -1);
    rb_define_singleton_method(rb_cSocket, "getnameinfo", sock_s_getnameinfo, -1);
a1622 8
#ifdef AF_UNSPEC
    sock_rb_define_const("AF_UNSPEC", AF_UNSPEC);
    sock_rb_define_const("PF_UNSPEC", PF_UNSPEC);
#endif
#ifdef AF_INET6
    sock_rb_define_const("AF_INET6", AF_INET6);
    sock_rb_define_const("PF_INET6", PF_INET6);
#endif
a1731 91
#endif

#ifdef EAI_ADDRFAMILY
    sock_rb_define_const("EAI_ADDRFAMILY", EAI_ADDRFAMILY);
#endif
#ifdef EAI_AGAIN
    sock_rb_define_const("EAI_AGAIN", EAI_AGAIN);
#endif
#ifdef EAI_BADFLAGS
    sock_rb_define_const("EAI_BADFLAGS", EAI_BADFLAGS);
#endif
#ifdef EAI_FAIL
    sock_rb_define_const("EAI_FAIL", EAI_FAIL);
#endif
#ifdef EAI_FAMILY
    sock_rb_define_const("EAI_FAMILY", EAI_FAMILY);
#endif
#ifdef EAI_MEMORY
    sock_rb_define_const("EAI_MEMORY", EAI_MEMORY);
#endif
#ifdef EAI_NODATA
    sock_rb_define_const("EAI_NODATA", EAI_NODATA);
#endif
#ifdef EAI_NONAME
    sock_rb_define_const("EAI_NONAME", EAI_NONAME);
#endif
#ifdef EAI_SERVICE
    sock_rb_define_const("EAI_SERVICE", EAI_SERVICE);
#endif
#ifdef EAI_SOCKTYPE
    sock_rb_define_const("EAI_SOCKTYPE", EAI_SOCKTYPE);
#endif
#ifdef EAI_SYSTEM
    sock_rb_define_const("EAI_SYSTEM", EAI_SYSTEM);
#endif
#ifdef EAI_BADHINTS
    sock_rb_define_const("EAI_BADHINTS", EAI_BADHINTS);
#endif
#ifdef EAI_PROTOCOL
    sock_rb_define_const("EAI_PROTOCOL", EAI_PROTOCOL);
#endif
#ifdef EAI_MAX
    sock_rb_define_const("EAI_MAX", EAI_MAX);
#endif
#ifdef AI_PASSIVE
    sock_rb_define_const("AI_PASSIVE", AI_PASSIVE);
#endif
#ifdef AI_CANONNAME
    sock_rb_define_const("AI_CANONNAME", AI_CANONNAME);
#endif
#ifdef AI_NUMERICHOST
    sock_rb_define_const("AI_NUMERICHOST", AI_NUMERICHOST);
#endif
#ifdef AI_MASK
    sock_rb_define_const("AI_MASK", AI_MASK);
#endif
#ifdef AI_ALL
    sock_rb_define_const("AI_ALL", AI_ALL);
#endif
#ifdef AI_V4MAPPED_CFG
    sock_rb_define_const("AI_V4MAPPED_CFG", AI_V4MAPPED_CFG);
#endif
#ifdef AI_ADDRCONFIG
    sock_rb_define_const("AI_ADDRCONFIG", AI_ADDRCONFIG);
#endif
#ifdef AI_V4MAPPED
    sock_rb_define_const("AI_V4MAPPED", AI_V4MAPPED);
#endif
#ifdef AI_DEFAULT
    sock_rb_define_const("AI_DEFAULT", AI_DEFAULT);
#endif
#ifdef NI_MAXHOST
    sock_rb_define_const("NI_MAXHOST", NI_MAXHOST);
#endif
#ifdef NI_MAXSERV
    sock_rb_define_const("NI_MAXSERV", NI_MAXSERV);
#endif
#ifdef NI_NOFQDN
    sock_rb_define_const("NI_NOFQDN", NI_NOFQDN);
#endif
#ifdef NI_NUMERICHOST
    sock_rb_define_const("NI_NUMERICHOST", NI_NUMERICHOST);
#endif
#ifdef NI_NAMEREQD
    sock_rb_define_const("NI_NAMEREQD", NI_NAMEREQD);
#endif
#ifdef NI_NUMERICSERV
    sock_rb_define_const("NI_NUMERICSERV", NI_NUMERICSERV);
#endif
#ifdef NI_DGRAM
    sock_rb_define_const("NI_DGRAM", NI_DGRAM);
@


1.1.1.3.2.9
log
@glibc 2.1
@
text
@d6 1
a6 1
  $Date: 1999/04/30 06:19:20 $
a50 11
#ifdef SOCKADDR_STORAGE
# define ss_falily __ss_family
# define SS_LEN(ss) (ss)->__ss_len
#else
# define SOCKADDR_STORAGE sockaddr
# define ss_family sa_family
# ifdef SA_LEN
#  define SS_LEN(ss) SA_LEN(ss)
# endif
#endif

d471 21
d716 1
a716 1
    struct SOCKADDR_STORAGE addr;
d759 1
a759 1
#ifdef HAVE_HSTERROR
d761 1
a761 1
	rb_raise(rb_eSocket, (char *)hsterror(h_errno));
d865 1
a865 1
    struct SOCKADDR_STORAGE from;
d931 1
a931 1
    struct SOCKADDR_STORAGE addr;
d946 1
a946 1
    struct SOCKADDR_STORAGE addr;
d960 1
a960 1
    struct SOCKADDR_STORAGE addr;
d1084 1
a1084 1
    struct SOCKADDR_STORAGE addr;
d1554 1
a1554 1
    struct SOCKADDR_STORAGE addr;
d1725 1
a1725 1
    struct SOCKADDR_STORAGE ss;
d1736 1
a1736 2
#ifdef SS_LEN
	if (RSTRING(sa)->len != SS_LEN(&ss)) {
a1738 1
#endif
@


1.1.1.3.2.10
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/04/30 07:55:47 $
d52 1
a52 1
# define ss_family __ss_family
@


1.1.1.3.2.11
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/04/30 08:20:00 $
a49 1
#include "sockport.h"
d52 2
a53 1
# define SS_LEN(ss) (ss)->ss_len
a55 1
# undef ss_family
d57 3
d481 1
d495 1
a495 1
	SET_SIN_LEN(sin, sizeof(*sin));
d500 1
a500 1
	SET_SIN_LEN(sin, sizeof(*sin));
d772 1
a772 1
	    SET_SIN_LEN(&sin, sizeof(sin));
d958 1
a958 1
	SET_SIN_LEN(sin, sizeof(*sin));
d1007 1
a1007 1
	SET_SIN_LEN(&sin, sizeof(sin));
d1009 2
a1010 2
	error = getnameinfo((struct sockaddr *)&sin, SIN_LEN(&sin),
			    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
d1553 1
a1553 1
	SET_SIN_LEN(sin, sizeof(*sin));
d1726 1
a1726 1
#ifdef HAVE_SS_LEN
@


1.1.1.3.2.12
log
@small fixes
@
text
@d6 1
a6 1
  $Date: 1999/04/30 15:16:44 $
d1045 1
a1045 1
    for (res = res0; res; res = res->ai_next) {
d1807 1
a1807 1
sock_define_const(name, value)
d1907 2
a1908 2
    sock_define_const("SOCK_STREAM", SOCK_STREAM);
    sock_define_const("SOCK_DGRAM", SOCK_DGRAM);
d1910 1
a1910 1
    sock_define_const("SOCK_RAW", SOCK_RAW);
d1913 1
a1913 1
    sock_define_const("SOCK_RDM", SOCK_RDM);
d1916 1
a1916 1
    sock_define_const("SOCK_SEQPACKET", SOCK_SEQPACKET);
d1919 1
a1919 1
    sock_define_const("SOCK_PACKET", SOCK_PACKET);
d1922 1
a1922 1
    sock_define_const("AF_INET", AF_INET);
d1924 1
a1924 1
    sock_define_const("PF_INET", PF_INET);
d1927 2
a1928 2
    sock_define_const("AF_UNIX", AF_UNIX);
    sock_define_const("PF_UNIX", PF_UNIX);
d1931 2
a1932 2
    sock_define_const("AF_AX25", AF_AX25);
    sock_define_const("PF_AX25", PF_AX25);
d1935 2
a1936 2
    sock_define_const("AF_IPX", AF_IPX);
    sock_define_const("PF_IPX", PF_IPX);
d1939 2
a1940 2
    sock_define_const("AF_APPLETALK", AF_APPLETALK);
    sock_define_const("PF_APPLETALK", PF_APPLETALK);
d1943 2
a1944 2
    sock_define_const("AF_UNSPEC", AF_UNSPEC);
    sock_define_const("PF_UNSPEC", PF_UNSPEC);
d1947 2
a1948 2
    sock_define_const("AF_INET6", AF_INET6);
    sock_define_const("PF_INET6", PF_INET6);
d1951 1
a1951 1
    sock_define_const("MSG_OOB", MSG_OOB);
d1953 1
a1953 1
    sock_define_const("MSG_PEEK", MSG_PEEK);
d1956 1
a1956 1
    sock_define_const("MSG_DONTROUTE", MSG_DONTROUTE);
d1959 1
a1959 1
    sock_define_const("SOL_SOCKET", SOL_SOCKET);
d1961 1
a1961 1
    sock_define_const("SOL_IP", SOL_IP);
d1964 1
a1964 1
    sock_define_const("SOL_IPX", SOL_IPX);
d1967 1
a1967 1
    sock_define_const("SOL_AX25", SOL_AX25);
d1970 1
a1970 1
    sock_define_const("SOL_ATALK", SOL_ATALK);
d1973 1
a1973 1
    sock_define_const("SOL_TCP", SOL_TCP);
d1976 1
a1976 1
    sock_define_const("SOL_UDP", SOL_UDP);
d1980 1
a1980 1
    sock_define_const("SO_DEBUG", SO_DEBUG);
d1982 1
a1982 1
    sock_define_const("SO_REUSEADDR", SO_REUSEADDR);
d1984 1
a1984 1
    sock_define_const("SO_TYPE", SO_TYPE);
d1987 1
a1987 1
    sock_define_const("SO_ERROR", SO_ERROR);
d1990 1
a1990 1
    sock_define_const("SO_DONTROUTE", SO_DONTROUTE);
d1993 1
a1993 1
    sock_define_const("SO_BROADCAST", SO_BROADCAST);
d1996 1
a1996 1
    sock_define_const("SO_SNDBUF", SO_SNDBUF);
d1999 1
a1999 1
    sock_define_const("SO_RCVBUF", SO_RCVBUF);
d2002 1
a2002 1
    sock_define_const("SO_KEEPALIVE", SO_KEEPALIVE);
d2005 1
a2005 1
    sock_define_const("SO_OOBINLINE", SO_OOBINLINE);
d2008 1
a2008 1
    sock_define_const("SO_NO_CHECK", SO_NO_CHECK);
d2011 1
a2011 1
    sock_define_const("SO_PRIORITY", SO_PRIORITY);
d2014 1
a2014 1
    sock_define_const("SO_LINGER", SO_LINGER);
d2018 1
a2018 1
    sock_define_const("SOPRI_INTERACTIVE", SOPRI_INTERACTIVE);
d2021 1
a2021 1
    sock_define_const("SOPRI_NORMAL", SOPRI_NORMAL);
d2024 1
a2024 1
    sock_define_const("SOPRI_BACKGROUND", SOPRI_BACKGROUND);
d2028 1
a2028 1
    sock_define_const("IP_MULTICAST_IF", IP_MULTICAST_IF);
d2031 1
a2031 1
    sock_define_const("IP_MULTICAST_TTL", IP_MULTICAST_TTL);
d2034 1
a2034 1
    sock_define_const("IP_MULTICAST_LOOP", IP_MULTICAST_LOOP);
d2037 1
a2037 1
    sock_define_const("IP_ADD_MEMBERSHIP", IP_ADD_MEMBERSHIP);
d2041 1
a2041 1
    sock_define_const("IP_DEFAULT_MULTICAST_TTL", IP_DEFAULT_MULTICAST_TTL);
d2044 1
a2044 1
    sock_define_const("IP_DEFAULT_MULTICAST_LOOP", IP_DEFAULT_MULTICAST_LOOP);
d2047 1
a2047 1
    sock_define_const("IP_MAX_MEMBERSHIPS", IP_MAX_MEMBERSHIPS);
d2051 1
a2051 1
    sock_define_const("IPX_TYPE", IPX_TYPE);
d2055 1
a2055 1
    sock_define_const("TCP_NODELAY", TCP_NODELAY);
d2058 1
a2058 1
    sock_define_const("TCP_MAXSEG", TCP_MAXSEG);
d2062 1
a2062 1
    sock_define_const("EAI_ADDRFAMILY", EAI_ADDRFAMILY);
d2065 1
a2065 1
    sock_define_const("EAI_AGAIN", EAI_AGAIN);
d2068 1
a2068 1
    sock_define_const("EAI_BADFLAGS", EAI_BADFLAGS);
d2071 1
a2071 1
    sock_define_const("EAI_FAIL", EAI_FAIL);
d2074 1
a2074 1
    sock_define_const("EAI_FAMILY", EAI_FAMILY);
d2077 1
a2077 1
    sock_define_const("EAI_MEMORY", EAI_MEMORY);
d2080 1
a2080 1
    sock_define_const("EAI_NODATA", EAI_NODATA);
d2083 1
a2083 1
    sock_define_const("EAI_NONAME", EAI_NONAME);
d2086 1
a2086 1
    sock_define_const("EAI_SERVICE", EAI_SERVICE);
d2089 1
a2089 1
    sock_define_const("EAI_SOCKTYPE", EAI_SOCKTYPE);
d2092 1
a2092 1
    sock_define_const("EAI_SYSTEM", EAI_SYSTEM);
d2095 1
a2095 1
    sock_define_const("EAI_BADHINTS", EAI_BADHINTS);
d2098 1
a2098 1
    sock_define_const("EAI_PROTOCOL", EAI_PROTOCOL);
d2101 1
a2101 1
    sock_define_const("EAI_MAX", EAI_MAX);
d2104 1
a2104 1
    sock_define_const("AI_PASSIVE", AI_PASSIVE);
d2107 1
a2107 1
    sock_define_const("AI_CANONNAME", AI_CANONNAME);
d2110 1
a2110 1
    sock_define_const("AI_NUMERICHOST", AI_NUMERICHOST);
d2113 1
a2113 1
    sock_define_const("AI_MASK", AI_MASK);
d2116 1
a2116 1
    sock_define_const("AI_ALL", AI_ALL);
d2119 1
a2119 1
    sock_define_const("AI_V4MAPPED_CFG", AI_V4MAPPED_CFG);
d2122 1
a2122 1
    sock_define_const("AI_ADDRCONFIG", AI_ADDRCONFIG);
d2125 1
a2125 1
    sock_define_const("AI_V4MAPPED", AI_V4MAPPED);
d2128 1
a2128 1
    sock_define_const("AI_DEFAULT", AI_DEFAULT);
d2131 1
a2131 1
    sock_define_const("NI_MAXHOST", NI_MAXHOST);
d2134 1
a2134 1
    sock_define_const("NI_MAXSERV", NI_MAXSERV);
d2137 1
a2137 1
    sock_define_const("NI_NOFQDN", NI_NOFQDN);
d2140 1
a2140 1
    sock_define_const("NI_NUMERICHOST", NI_NUMERICHOST);
d2143 1
a2143 1
    sock_define_const("NI_NAMEREQD", NI_NAMEREQD);
d2146 1
a2146 1
    sock_define_const("NI_NUMERICSERV", NI_NUMERICSERV);
d2149 1
a2149 1
    sock_define_const("NI_DGRAM", NI_DGRAM);
@


1.1.1.3.2.13
log
@990507
@
text
@d6 1
a6 1
  $Date: 1999/05/06 08:31:48 $
d52 8
d703 1
a703 1
    struct sockaddr addr;
d720 1
a720 1
    switch (addr.sa_family) {
d763 1
a763 1
	switch (addr.sa_family) {
d852 1
a852 1
    struct sockaddr from;
d918 1
a918 1
    struct sockaddr addr;
d933 1
a933 1
    struct sockaddr addr;
d947 1
a947 1
    struct sockaddr addr;
d1071 1
a1071 1
    struct sockaddr addr;
d1541 1
a1541 1
    struct sockaddr addr;
d1556 1
a1556 1
    switch (addr.sa_family) {
d1712 1
a1712 1
    struct sockaddr ss;
d1723 2
a1724 1
	if (RSTRING(sa)->len != SA_LEN(&ss)) {
d1727 1
@


1.1.1.3.2.14
log
@regexp,range,squeeze
@
text
@d6 1
a6 1
  $Date: 1999/05/07 08:24:36 $
a311 2
	    rb_thread_schedule();
	    goto retry;
d316 1
a316 1
	    rb_thread_fd_writable(fd);
a369 3
	    rb_thread_schedule();
	    goto retry;

d374 1
a374 1
	    rb_thread_wait_fd(fd);
d425 1
a425 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
d456 1
a456 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
d462 1
a462 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
d482 1
a482 1
	MEMZERO(sin, struct sockaddr_in, 1);
d493 1
a493 1
	MEMZERO(&hints, struct addrinfo, 1);
d497 1
a497 1
	    rb_raise(rb_eSocket, "%s", gai_strerror(error));
a504 11
static void
thread_write_select(fd)
    int fd;
{
    fd_set fds;

    FD_ZERO(&fds);
    FD_SET(fd, &fds);
    rb_thread_select(fd+1, 0, &fds, 0, 0);
}

d507 1
a507 1
ruby_connect(fd, sockaddr, len, socks)
d511 1
a511 1
    int socks;
d515 1
d531 1
a531 1
	if (socks) {
d541 1
d546 1
a546 1
		thread_write_select(fd);
d548 1
d552 5
a567 23

#else

#ifdef SOCKS
static int
ruby_connect(fd, sockaddr, len, socks)
    int fd;
    struct sockaddr *sockaddr;
    int len;
    int socks;
{
    if (socks) {
	return Rconnect(fd, sockaddr, len);
    }
    else {
	return connect(fd, sockaddr, len);
    }
}
#else

#define ruby_connect(fd, sockaddr, len, socks) connect(fd, sockaddr, len)

#endif /* SOCKS */
d598 1
a598 1
    MEMZERO(&hints, struct addrinfo, 1);
d606 1
a606 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
d624 13
a636 2
	    status = ruby_connect(fd, res->ai_addr, res->ai_addrlen,
				  (type == INET_SOCKS));
d701 1
a701 1
	long i = NUM2LONG(host);
d704 1
a704 1
	MEMZERO(sin, struct sockaddr_in, 1);
d740 1
a740 1
	rb_raise(rb_eSocket, "%s", (char *)hsterror(h_errno));
d759 1
a759 1
	    MEMZERO(&sin, struct sockaddr_in, 1);
d773 1
a773 1
	    MEMZERO(&sin6, struct sockaddr_in6, 1);
a826 3
	    rb_thread_schedule();
	    goto retry;

d831 1
a831 1
	    rb_thread_wait_fd(fd);
d878 1
a878 1
    MEMZERO(&sockaddr, struct sockaddr_un, 1);
d887 1
a887 1
        status = ruby_connect(fd, (struct sockaddr*)&sockaddr, sizeof(sockaddr), 0);
d942 1
a942 1
	long i = NUM2LONG(host);
d945 1
a945 1
	MEMZERO(sin, struct sockaddr_in, 1);
a963 1
    int socktype = AF_INET;
d966 9
a974 1
	socktype = NUM2INT(arg);
a975 1
    return sock_new(class, socket(socktype, SOCK_DGRAM, 0));
d993 2
a994 2
	long i = NUM2LONG(host);
	MEMZERO(&sin, struct sockaddr_in, 1);
d1001 1
a1001 1
	    rb_raise(rb_eSocket, "%s", gai_strerror(error));
d1017 1
a1017 1
    MEMZERO(&hints, struct addrinfo, 1);
d1022 1
a1022 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
a1032 1
    int fd;
a1035 1
    fd = fileno(fptr->f);
d1039 1
a1039 1
	if (ruby_connect(fd, res->ai_addr, res->ai_addrlen, 0) >= 0) {
a1044 3
	    rb_thread_schedule();
	    goto retry;

d1049 1
a1049 1
	    thread_write_select(fd);
a1113 3
	    rb_thread_schedule();
	    goto retry;

d1118 1
a1118 1
	    thread_write_select(fileno(f));
a1356 1
    int fd;
a1361 1
    fd = fileno(fptr->f);
d1363 1
a1363 1
    if (ruby_connect(fd, (struct sockaddr*)RSTRING(addr)->ptr, RSTRING(addr)->len, 0) < 0) {
a1365 2
	    rb_thread_schedule();
	    goto retry;
d1370 1
a1370 1
	    thread_write_select(fd);
d1479 1
a1479 1
	rb_raise(rb_eSocket, "%s", (char *)hstrerror(h_errno));
d1537 1
a1537 1
	long i = NUM2LONG(host);
d1540 1
a1540 1
	MEMZERO(sin, struct sockaddr_in, 1);
d1645 1
a1645 1
		 &flags);
d1657 1
a1657 1
    else if (FIXNUM_P(port)) {
d1667 3
a1669 3
    MEMZERO(&hints, struct addrinfo, 1);
    if (!NIL_P(family)) {
	hints.ai_family = NUM2INT(family);
d1674 2
a1675 2
    if (!NIL_P(socktype)) {
	hints.ai_socktype = NUM2INT(socktype);
d1677 2
a1678 2
    if (!NIL_P(protocol)) {
	hints.ai_protocol = NUM2INT(protocol);
d1680 2
a1681 2
    if (!NIL_P(flags)) {
	hints.ai_flags = NUM2INT(flags);
d1685 1
a1685 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
d1746 2
a1747 2
	else if (!NIL_P(port)) {
	    snprintf(pbuf, sizeof(pbuf), "%d", NUM2INT(port));
d1755 1
a1755 1
	MEMZERO(&hints, struct addrinfo, 1);
d1759 1
a1759 1
#ifdef INET6
d1763 1
a1763 1
#endif
d1769 1
a1769 1
	    rb_raise(rb_eSocket, "%s", gai_strerror(error));
d1778 2
a1779 2
    if (!NIL_P(flags)) {
	fl = NUM2INT(flags);
d1782 1
a1782 1
  gotsap:
d1786 1
a1786 1
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
@


1.1.1.3.2.15
log
@.*/.+/.?
@
text
@d6 1
a6 1
  $Date: 1999/05/10 08:22:49 $
d521 1
a531 1
#if defined(HAVE_FCNTL)
a543 2
#endif /* HAVE_FCNTL */

a570 1
#ifdef HAVE_FCNTL
a572 1
#endif
d577 24
d1057 1
d1062 12
d1389 1
d1391 11
@


1.1.1.3.2.16
log
@regexp null pattern
@
text
@d6 1
a6 1
  $Date: 1999/05/11 01:34:33 $
a74 6
#ifndef INET6
# undef  ss_family
# define sockaddr_storage	sockaddr
# define ss_family		sa_family
#endif

d695 1
a695 1
    struct sockaddr_storage addr;
d712 1
a712 1
    switch (addr.ss_family) {
d755 1
a755 1
	switch (addr.ss_family) {
d790 1
a790 1
    rb_ary_push(ary, mkipaddr((struct sockaddr *)&addr));
d847 1
a847 1
    struct sockaddr_storage from;
d913 1
a913 1
    struct sockaddr_storage addr;
d928 1
a928 1
    struct sockaddr_storage addr;
d942 1
a942 1
    struct sockaddr_storage addr;
d1052 1
d1517 1
a1517 1
    struct sockaddr_storage addr;
d1532 1
a1532 1
    switch (addr.ss_family) {
d1688 1
a1688 1
    struct sockaddr_storage ss;
d1699 1
a1699 1
	if (RSTRING(sa)->len != SA_LEN((struct sockaddr *)&ss)) {
@


1.1.1.3.2.17
log
@990531
@
text
@d6 1
a6 1
  $Date: 1999/05/25 08:26:19 $
a86 1
	extern int errno;
d89 3
a91 5

	myfdclose(fptr->f);
	if(fptr->f2)  myfdclose(fptr->f);
/*
	s = get_osfhandle(fileno(fptr->f));
a92 1
*/
a425 15
static void
mkipaddr0(addr, buf, len)
    struct sockaddr *addr;
    char *buf;
    size_t len;
{
    int error;

    error = getnameinfo(addr, SA_LEN(addr), buf, len, NULL, 0,
			NI_NUMERICHOST);
    if (error) {
	rb_raise(rb_eSocket, "%s", gai_strerror(error));
    }
}

a430 26

    mkipaddr0(addr, buf, sizeof(buf));
    return rb_str_new2(buf);
}

static void
mkinetaddr(host, buf, len)
    long host;
    char *buf;
    size_t len;
{
    struct sockaddr_in sin;

    MEMZERO(&sin, struct sockaddr_in, 1);
    sin.sin_family = AF_INET;
    SET_SIN_LEN(&sin, sizeof(sin));
    sin.sin_addr.s_addr = host;
    mkipaddr0((struct sockaddr *)&sin, buf, len);
}

static struct addrinfo*
ip_addrsetup(host, port)
    VALUE host, port;
{
    struct addrinfo hints, *res;
    char *hostp, *portp;
a431 1
    char hbuf[1024], pbuf[16];
d433 2
a434 38
    if (NIL_P(host)) {
	hostp = NULL;
    }
    else if (rb_obj_is_kind_of(host, rb_cInteger)) {
	struct sockaddr_in sin;
	long i = NUM2LONG(host);

	mkinetaddr(htonl(i), hbuf, sizeof(hbuf));
    }
    else {
	char *name = STR2CSTR(host);

	if (*name == 0) {
	    mkinetaddr(INADDR_ANY, hbuf, sizeof(hbuf));
	}
	if (name[0] == '<' && strcmp(name, "<broadcast>") == 0) {
	    mkinetaddr(INADDR_BROADCAST, hbuf, sizeof(hbuf));
	}
	else {
	    strcpy(hbuf, name);
	}
    }
    hostp = hbuf;
    if (NIL_P(port)) {
	portp = 0;
    }
    else if (FIXNUM_P(port)) {
	snprintf(pbuf, sizeof(pbuf), "%d", FIX2INT(port));
	portp = pbuf;
    }
    else {
	portp = STR2CSTR(port);
    }

    MEMZERO(&hints, struct addrinfo, 1);
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;
    error = getaddrinfo(hostp, portp, &hints, &res);
d438 1
a438 14

    return res;
}

static void
setipaddr(name, addr)
    VALUE name;
    struct sockaddr *addr;
{
    struct addrinfo *res = ip_addrsetup(name, Qnil);

    /* just take the first one */
    memcpy(addr, res->ai_addr, res->ai_addrlen);
    freeaddrinfo(res);
d483 34
d635 2
a636 2
	    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,
		       (char*)&status, sizeof(status));
d716 1
a716 1
	setipaddr(host, &addr);
d950 13
a962 1
    setipaddr(host, &addr);
d981 50
d1041 1
a1041 1
    res0 = ip_addrsetup(host, port);
d1062 1
a1062 1
    res0 = ip_addrsetup(host, port);
d1095 1
a1095 1
    res0 = ip_addrsetup(host, port);
d1535 1
a1535 1
	setipaddr(host, (struct sockaddr *)&addr);
@


1.1.1.3.2.18
log
@rb_exec_end_proc, etc.
@
text
@d6 1
a6 1
  $Date: 1999/05/31 09:13:31 $
d22 3
@


1.1.1.3.2.19
log
@thread bugs
@
text
@d6 1
a6 1
  $Date: 1999/06/01 06:59:19 $
a585 15
ruby_socket(domain, type, proto)
    int domain, type, proto;
{
    int fd;

    fd = socket(domain, type, proto);
    if (fd < 0) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    fd = socket(domain, type, proto);
	}
    }
}

static int
d686 1
a686 1
	status = ruby_socket(res->ai_family,res->ai_socktype,res->ai_protocol);
d689 1
a689 1
	if (fd < 0) {
a690 1
	}
d942 2
a943 4
    fd = ruby_socket(AF_UNIX, SOCK_STREAM, 0);
    if (fd < 0) {
	rb_sys_fail("socket(2)");
    }
a1019 1
    int fd;
d1024 1
a1024 6
    fd = ruby_socket(socktype, SOCK_DGRAM, 0);
    if (fd < 0) {
	rb_sys_fail("socket(2) - udp");
    }

    return sock_new(class, fd);
d1315 1
a1315 1
    fd = ruby_socket(d, t, NUM2INT(protocol));
d1336 1
a1336 6
  again:
    if (socketpair(d, t, NUM2INT(protocol), sp) < 0) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    goto again;
	}
a1337 1
    }
a1922 2
#endif
#ifdef PF_INET6
@


1.1.1.3.2.20
log
@990611
@
text
@d6 1
a6 1
  $Date: 1999/06/09 09:21:35 $
d117 1
@


1.1.1.3.2.21
log
@990624
@
text
@d6 1
a6 1
  $Date: 1999/06/11 06:30:00 $
d490 1
a490 1
	else if (name[0] == '<' && strcmp(name, "<broadcast>") == 0) {
a596 1
    return fd;
@


1.1.1.3.2.22
log
@backtrace may be Qnil
@
text
@d6 1
a6 1
  $Date: 1999/06/24 04:24:06 $
a48 2
static int do_not_reverse_lookup = 0;

a425 13
static VALUE
bsock_do_not_rev_lookup()
{
    return do_not_reverse_lookup?Qtrue:Qfalse;
}

static VALUE
bsock_do_not_rev_lookup_set(self, val)
{
    do_not_reverse_lookup = RTEST(val);
    return val;
}

d479 1
d538 1
d555 4
a558 7
    if (!do_not_reverse_lookup) {
	error = getnameinfo(sockaddr, SA_LEN(sockaddr), hbuf, sizeof(hbuf),
			    NULL, 0, 0);
	if (error) {
	    rb_raise(rb_eSocket, "%s", gai_strerror(error));
	}
	addr1 = rb_str_new2(hbuf);
d560 1
a566 3
    if (do_not_reverse_lookup) {
	addr1 = addr2;
    }
d668 1
d1437 1
a1437 1
    VALUE sock2;
d1522 1
a1819 1
void
a1826 6

    rb_define_singleton_method(rb_cBasicSocket, "do_not_reverse_lookup",
			       bsock_do_not_rev_lookup, 0);
    rb_define_singleton_method(rb_cBasicSocket, "do_not_reverse_lookup=",
			       bsock_do_not_rev_lookup_set, 1);

@


1.1.1.3.2.23
log
@990806
@
text
@d6 1
a6 1
  $Date: 1999/07/22 10:37:24 $
a396 1
      case RECV_UDP:
d403 7
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 04:14:50 $
@


1.1.1.2.2.2
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:36:01 $
d824 1
a824 1
	addr->sin_port = htons(FIX2INT(port));
@


1.1.1.2.2.3
log
@1.1b9_05 bug fix
@
text
@d6 1
a6 1
  $Date: 1998/01/29 03:22:53 $
a87 1
    rb_secure(4);
a109 1
    rb_secure(4);
@


1.1.1.2.2.4
log
@gw32 b19 patch
@
text
@d6 1
a6 1
  $Date: 1998/03/28 10:57:41 $
d1140 1
a1140 1
#if !defined(NT)
@


1.1.1.2.2.5
log
@instance_eva/module_eval
@
text
@d6 1
a6 1
  $Date: 1998/03/30 09:32:56 $
d117 1
a117 3
#if 0
	if (how < 0 || 2 < how) how = 2;
#endif
@


1.1.1.2.2.6
log
@call initialize
@
text
@d6 1
a6 1
  $Date: 1998/03/30 09:41:17 $
a542 1
    VALUE s;
d544 1
a544 3
    s = open_inet(class, host, serv, INET_CLIENT);
    obj_call_init(s);
    return s;
a552 1
    VALUE s;
d560 1
a560 3
    s = open_inet(class, host, serv, INET_SOCKS);
    obj_call_init(s);
    return s;
d570 1
a570 1
    VALUE arg1, arg2, s;
d573 1
a573 1
	s = open_inet(class, arg1, arg2, INET_SERVER);
d575 1
a575 3
	s = open_inet(class, 0, arg1, INET_SERVER);
    obj_call_init(s);
    return s;
d804 1
a804 5
    VALUE s;

    s = sock_new(class, socket(AF_INET, SOCK_DGRAM, 0));
    obj_call_init(s);
    return s;
d947 1
a947 4
    VALUE s;
    s = open_unix(sock, path, 0);
    obj_call_init(s);
    return s;
d968 2
a969 2
unix_svr_s_open(sock, path)
    VALUE sock, path;
d971 1
a971 4
    VALUE s;
    s = open_unix(sock, path, 1);
    obj_call_init(s);
    return s;
a1123 1
    VALUE s;
d1128 1
a1128 4
    s = sock_new(class, fd);
    obj_call_init(s);

    return s;
d1135 1
a1135 4
    VALUE s = sock_new(class, NUM2INT(fd));

    obj_call_init(s);
    return s;
@


1.1.1.2.2.7
log
@signal delivered to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:03:53 $
a96 1
    obj_call_init((VALUE)sock);
d546 1
d565 1
d582 1
d815 1
d961 1
d988 1
d1147 2
d1150 1
a1150 1
    return sock_new(class, fd);
d1157 4
a1160 1
    return sock_new(class, NUM2INT(fd));
@


1.1.1.2.2.8
log
@exception name on -d
@
text
@d6 1
a6 1
  $Date: 1998/04/14 04:55:52 $
d544 1
d546 2
a547 1
    return open_inet(class, host, serv, INET_CLIENT);
d556 1
d564 2
a565 1
    return open_inet(class, host, serv, INET_SOCKS);
d575 1
a575 1
    VALUE arg1, arg2;
d578 1
a578 1
	return open_inet(class, arg1, arg2, INET_SERVER);
d580 2
a581 1
	return open_inet(class, 0, arg1, INET_SERVER);
d810 4
a813 1
    return sock_new(class, socket(AF_INET, SOCK_DGRAM, 0));
d956 3
a958 1
    return open_unix(sock, path, 0);
d982 3
a984 1
    return open_unix(sock, path, 1);
@


1.1.1.2.2.9
log
@exception model changed
@
text
@d6 1
a6 1
  $Date: 1998/04/16 10:20:23 $
d51 1
a51 1
extern VALUE eStandardError;
d1397 1
a1397 1
    eSocket = rb_define_class("SocketError", eStandardError);
@


1.1.1.2.2.10
log
@no INT,UINT
@
text
@d6 1
a6 1
  $Date: 1998/05/01 08:56:40 $
d1389 1
a1389 1
    int value;
@


1.1.1.2.2.11
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/05/13 05:58:09 $
a24 7
#ifdef USE_CWGUSI
extern int fileno(FILE *stream); /* <unix.mac.h> */
extern int thread_select(int, fd_set*, fd_set*, fd_set*, struct timeval*); /* thread.c */
# include <sys/errno.h>
# include <GUSI.h>
#endif

a170 1
#if !defined(__BEOS__)
a184 3
#else
    rb_notimplement();
#endif
a403 1
#ifndef USE_CWGUSI
a404 3
#else
		thread_select(fd+1, 0, &fds, 0, 0);
#endif
a448 1
#ifndef USE_CWGUSI
a449 3
#else
	    hostaddr = inet_addr(host).s_addr;
#endif
a486 3
#ifdef __BEOS__
    fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
#else
a492 1
#endif
a1062 1
#ifdef PF_INET
a1064 1
#endif
a1476 1
#ifdef SOCK_RAW
a1477 1
#endif
a1488 1
#ifdef PF_INET
a1489 1
#endif
a1507 1
#ifdef MSG_PEEK
a1508 2
#endif
#ifdef MSG_DONTROUTE
a1509 1
#endif
a1552 1
#ifdef SO_KEEPALIVE
a1553 1
#endif
a1562 1
#ifdef SO_LINGER
a1563 1
#endif
@


1.1.1.2.2.12
log
@BeOS patches
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:46 $
d1170 1
a1170 1
#if !defined(NT) && !defined(__BEOS__)
d1371 1
a1371 1
    rb_scan_args(argc, argv, "11", &addr, &vtype);
d1373 1
a1373 1
    if (!NIL_P(vtype)) {
@


1.1.1.2.2.13
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/18 09:12:27 $
d138 2
a139 1
    VALUE sock, lev, optname, val;
d163 2
a164 1
	v = str2cstr(val, &vlen);
d232 1
a232 1
    VALUE msg, to;
a236 2
    char *m, *t;
    int mlen, tlen;
d241 2
a249 1
    m = str2cstr(msg, &mlen);
d251 3
a253 3
	t = str2cstr(to, &tlen);
	n = sendto(fd, m, mlen, NUM2INT(flags),
		   (struct sockaddr*)t, tlen);
d256 1
a256 1
	n = send(fd, m, mlen, NUM2INT(flags));
d494 2
a495 1
    servent = getservbyname(STR2CSTR(serv), "tcp");
d497 3
a499 6
	char *s = STR2CSTR(serv);
	char *end;

	servport = strtoul(s, &end, 0);
	if (*end != '\0') {
	    Raise(eSocket, "no such servce %s", s);
d817 2
a818 1
	setipaddr(STR2CSTR(host), &addr);
d848 2
a849 1
	setipaddr(STR2CSTR(host), addr);
d857 2
a858 1
	servent = getservbyname(STR2CSTR(port), "udp");
d863 4
a866 7
	    char *s = STR2CSTR(port);
	    char *end;
	    int portno;

	    portno = strtoul(s, &end, 0);
	    if (*end != '\0') {
		Raise(eSocket, "no such servce %s", s);
a926 2
    char *m;
    int mlen;
d932 1
a936 1
    m = str2cstr(mesg, &mlen);
d938 2
a939 2
    n = sendto(fileno(f), m, mlen, NUM2INT(flags),
	       (struct sockaddr*)&addr, sizeof(addr));
d1350 2
a1351 1
	setipaddr(STR2CSTR(host), &addr);
d1367 2
a1368 2
    char *addr;
    int alen;
d1372 1
a1372 1
    addr = str2cstr(vaddr, &alen);
d1380 1
a1380 1
    h = gethostbyaddr(addr, alen, type);
d1396 1
d1398 1
a1398 1
    else proto = STR2CSTR(protocol);
d1400 3
a1402 12
    sp = getservbyname(STR2CSTR(service), proto);
    if (sp) {
	port = ntohs(sp->s_port);
    }
    else {
	char *s = STR2CSTR(service);
	char *end;

	port = strtoul(s, &end, 0);
	if (*end != '\0') {
	    Raise(eSocket, "no such servce %s/%s", s, proto);
	}
d1404 1
@


1.1.1.2.2.14
log
@baseline
@
text
@d6 1
a6 1
  $Date: 1998/06/02 10:05:37 $
d12 1
a12 1
#include "rubyio.h"
@


1.1.1.2.2.15
log
@thread->thred
@
text
@d6 1
a6 1
  $Date: 1998/06/16 04:24:33 $
d27 1
a27 1
extern int thred_select(int, fd_set*, fd_set*, fd_set*, struct timeval*); /* thread.c */
d246 1
a246 1
    thred_fd_writable(fd);
d265 1
a265 1
	    thred_schedule();
d312 1
a312 1
    thred_wait_fd(fd);
d328 1
a328 1
	    thred_schedule();
d373 1
a373 1
thred_connect(fd, sockaddr, len, type)
d415 1
a415 1
		thred_select(fd+1, 0, &fds, 0, 0, 0);
d417 1
a417 1
		thred_select(fd+1, 0, &fds, 0, 0);
d538 2
a539 2
        status = thred_connect(fd, (struct sockaddr*)&sockaddr,
			       sizeof(sockaddr), type);
d614 1
a614 1
    thred_wait_fd(fd);
d627 1
a627 1
	    thred_schedule();
d892 1
a892 1
	    thred_schedule();
d951 1
a951 1
	    thred_schedule();
d1206 1
a1206 1
	    thred_schedule();
@


1.1.1.2.2.16
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/24 04:38:07 $
a12 1
#include "rubysig.h"
d27 1
a27 1
extern int thread_select(int, fd_set*, fd_set*, fd_set*, struct timeval*); /* thread.c */
d44 3
d58 1
d246 1
a246 1
    thread_fd_writable(fd);
d265 1
a265 1
	    thread_schedule();
d312 1
a312 1
    thread_wait_fd(fd);
d328 1
a328 1
	    thread_schedule();
d373 1
a373 1
thread_connect(fd, sockaddr, len, type)
d415 1
a415 1
		thread_select(fd+1, 0, &fds, 0, 0, 0);
d417 1
a417 1
		thread_select(fd+1, 0, &fds, 0, 0);
d538 1
a538 1
        status = thread_connect(fd, (struct sockaddr*)&sockaddr,
d614 1
a614 1
    thread_wait_fd(fd);
d627 1
a627 1
	    thread_schedule();
d892 1
a892 1
	    thread_schedule();
d951 1
a951 1
	    thread_schedule();
d1206 1
a1206 1
	    thread_schedule();
@


1.1.1.2.2.17
log
@1.1b9_29
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:49 $
d1370 1
a1370 1
    rb_scan_args(argc, argv, "11", &vaddr, &vtype);
@


1.1.1.2.2.18
log
@1.1c4
@
text
@d6 1
a6 1
  $Date: 1998/07/03 07:06:39 $
d411 3
d415 1
@


1.1.1.2.2.19
log
@to open CVS
@
text
@d6 1
a6 1
  $Date: 1998/09/03 07:43:47 $
d63 3
@


1.1.1.2.2.18.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/09/03 07:43:47 $
d28 1
a28 1
extern int rb_thread_select(int, fd_set*, fd_set*, fd_set*, struct timeval*); /* thread.c */
d45 5
a49 5
VALUE rb_cBasicSocket;
VALUE rb_cIPsocket;
VALUE rb_cTCPsocket;
VALUE rb_cTCPserver;
VALUE rb_cUDPsocket;
d51 2
a52 2
VALUE rb_cUNIXsocket;
VALUE rb_cUNIXserver;
d54 1
a54 1
VALUE rb_cSocket;
d56 1
a56 1
static VALUE rb_eSocket;
d59 1
a59 1
VALUE rb_cSOCKSsocket;
d64 1
d100 2
a101 2
    rb_io_unbuffered(fp);
    rb_obj_call_init((VALUE)sock);
d122 3
a124 3
	if (how < 0 || 2 < how) {
	    rb_raise(rb_eArgError, "`how' should be either 0, 1, 2");
	}
d159 1
a159 1
	v = rb_str2cstr(val, &vlen);
d187 1
a187 1
    return rb_str_new(buf, len);
d204 1
a204 1
    return rb_str_new(buf, len);
d218 1
a218 1
    return rb_str_new(buf, len);
d243 1
a243 1
    rb_thread_fd_writable(fd);
d245 1
a245 1
    m = rb_str2cstr(msg, &mlen);
d247 1
a247 1
	t = rb_str2cstr(to, &tlen);
d262 1
a262 1
	    rb_thread_schedule();
d292 1
d304 1
a304 1
    str = rb_str_new(0, NUM2INT(len));
d309 1
a309 1
    rb_thread_wait_fd(fd);
d325 1
a325 1
	    rb_thread_schedule();
d331 1
a331 1
    rb_str_taint(str);
d337 1
a337 1
	    rb_raise(rb_eTypeError, "sockaddr size differs - should not happen");
d339 1
a339 1
	return rb_assoc_new(str, ipaddr((struct sockaddr_in *)buf));
d344 2
a345 2
	    return rb_assoc_new(str, rb_assoc_new(RARRAY(addr)->ptr[2],
						  RARRAY(addr)->ptr[1]));
d349 4
a352 1
	return rb_assoc_new(str, unixaddr((struct sockaddr_un *)buf));
d355 1
a355 1
	return rb_assoc_new(str, rb_str_new(buf, alen));
a367 89
static VALUE
mkipaddr(x)
    unsigned long x;
{
    char buf[16];

    x = ntohl(x);
    sprintf(buf, "%d.%d.%d.%d",
	    (int) (x>>24) & 0xff, (int) (x>>16) & 0xff,
	    (int) (x>> 8) & 0xff, (int) (x>> 0) & 0xff);
    return rb_str_new2(buf);
}

static VALUE
ipaddr(sockaddr)
    struct sockaddr_in *sockaddr;
{
    VALUE family, port, addr1, addr2;
    VALUE ary;
    struct hostent *hostent;

    family = rb_str_new2("AF_INET");
    hostent = gethostbyaddr((char*)&sockaddr->sin_addr.s_addr,
			    sizeof(sockaddr->sin_addr),
			    AF_INET);
    addr1 = 0;
    if (hostent) {
	addr1 = rb_str_new2(hostent->h_name);
    }
    addr2 = mkipaddr(sockaddr->sin_addr.s_addr);
    if (!addr1) addr1 = addr2;

    port = INT2FIX(ntohs(sockaddr->sin_port));
    ary = rb_ary_new3(4, family, port, addr1, addr2);

    return ary;
}

#ifndef HAVE_INET_ATON
static unsigned long
inet_aton(host, inp)
    char *host;
    struct in_addr *inp;
{
    int d1, d2, d3, d4;
    char ch;

    if (sscanf(host, "%d.%d.%d.%d%c", &d1, &d2, &d3, &d4, &ch) == 4 &&
	0 <= d1 && d1 <= 255 && 0 <= d2 && d2 <= 255 &&
	0 <= d3 && d3 <= 255 && 0 <= d4 && d4 <= 255) {
	inp->s_addr = htonl(
	    ((long) d1 << 24) | ((long) d2 << 16) |
	    ((long) d3 << 8) | ((long) d4 << 0));
	return 1;
    }
    return 0;
}
#endif

static void
setipaddr(name, addr)
    char *name;
    struct sockaddr_in *addr;
{
    struct hostent *hp;

    if (name[0] == 0) {
	addr->sin_addr.s_addr = INADDR_ANY;
    }
    else if (name[0] == '<' && strcmp(name, "<broadcast>") == 0) {
	addr->sin_addr.s_addr = INADDR_BROADCAST;
    }
    else if (inet_aton(name, &addr->sin_addr) != 0) {
	/* ok to set addr->sin_addr */
    }
    else {
	hp = gethostbyname(name);
	if (!hp) {
#ifdef HAVE_HSTRERROR
	    extern int h_errno;
	    rb_raise(rb_eSocket, (char *)hstrerror(h_errno));
#else
	    rb_raise(rb_eSocket, "host not found");
#endif
	}
	memcpy((char *) &addr->sin_addr, hp->h_addr, hp->h_length);
    }
}

d411 1
a411 1
		rb_thread_select(fd+1, 0, &fds, 0, 0);
d449 1
d456 5
a460 2
	    inet_aton(host, &sockaddr.sin_addr);
	    hostaddr = sockaddr.sin_addr.s_addr;
d467 1
a467 1
		    rb_raise(rb_eSocket, (char *)hstrerror(h_errno));
d469 1
a469 1
		    rb_raise(rb_eSocket, "host not found");
d493 1
a493 1
	    rb_raise(rb_eSocket, "no such servce %s", s);
d505 1
a505 1
	rb_raise(rb_eSocket, "no such proto %s", servent->s_proto);
d548 1
a548 1
	close(fd);
a582 43
tcp_s_gethostbyname(obj, host)
    VALUE obj, host;
{
    struct sockaddr_in addr;
    struct hostent *h;
    char **pch;
    VALUE ary, names;

    setipaddr(STR2CSTR(host), &addr);
    h = gethostbyaddr((char *)&addr.sin_addr,
		      sizeof(addr.sin_addr),
		      AF_INET);

    if (h == NULL) {
#ifdef HAVE_HSTRERROR
	extern int h_errno;
	rb_raise(rb_eSocket, (char *)hstrerror(h_errno));
#else
	rb_raise(rb_eSocket, "host not found");
#endif
    }
    ary = rb_ary_new();
    rb_ary_push(ary, rb_str_new2(h->h_name));
    names = rb_ary_new();
    rb_ary_push(ary, names);
    for (pch = h->h_aliases; *pch; pch++) {
	rb_ary_push(names, rb_str_new2(*pch));
    }
    rb_ary_push(ary, NUM2INT(h->h_addrtype));
#ifdef h_addr
    for (pch = h->h_addr_list; *pch; pch++) {
	memcpy((char *) &addr.sin_addr, *pch, h->h_length);
	rb_ary_push(ary, mkipaddr(addr.sin_addr.s_addr));
    }
#else
    memcpy((char *)&addr.sin_addr, h->h_addr, h->h_length);
    rb_ary_push(ary, mkipaddr(addr.sin_addr.s_addr));
#endif

    return ary;
}

static VALUE
d607 1
a607 1
    rb_thread_wait_fd(fd);
d620 1
a620 1
	    rb_thread_schedule();
d639 1
a639 1
    return s_accept(rb_cTCPsocket, fileno(fptr->f),
d695 75
d806 1
a806 1
    if (rb_obj_is_kind_of(host, rb_cInteger)) {
d829 2
d836 1
a836 1
    else if (rb_obj_is_kind_of(host, rb_cInteger)) {
d860 1
a860 1
		rb_raise(rb_eSocket, "no such servce %s", s);
d885 1
a885 1
	    rb_thread_schedule();
d932 1
a932 1
    m = rb_str2cstr(mesg, &mlen);
d944 1
a944 1
	    rb_thread_schedule();
d984 1
a984 1
    return rb_str_new2(fptr->path);
d1013 1
a1013 1
    return s_accept(rb_cUNIXsocket, fileno(fptr->f),
d1021 1
a1021 1
    return rb_assoc_new(rb_str_new2("AF_UNIX"),rb_str_new2(sockaddr->sun_path));
d1105 1
a1105 1
	    rb_raise(rb_eSocket, "Unknown socket domain %s", ptr);
d1133 1
a1133 1
	    rb_raise(rb_eSocket, "Unknown socket type %s", ptr);
d1146 1
d1167 1
d1174 1
a1174 1
    return rb_assoc_new(sock_new(class, sp[0]), sock_new(class, sp[1]));
d1187 1
a1187 1
    rb_str_modify(addr);
d1199 1
a1199 1
	    rb_thread_schedule();
d1216 1
a1216 1
    rb_str_modify(addr);
d1257 1
a1257 1
    sock2 = s_accept(rb_cSocket,fileno(fptr->f),(struct sockaddr*)buf,&len);
d1259 1
a1259 1
    return rb_assoc_new(sock2, rb_str_new(buf, len));
d1273 1
a1273 1
    return rb_str_new2(buf);
d1287 1
a1287 1
  return rb_str_new2(un.nodename);
d1303 1
d1310 1
a1310 1
	rb_raise(rb_eSocket, (char *)hstrerror(h_errno));
d1312 1
a1312 1
	rb_raise(rb_eSocket, "host not found");
d1315 4
a1318 4
    ary = rb_ary_new();
    rb_ary_push(ary, rb_str_new2(h->h_name));
    names = rb_ary_new();
    rb_ary_push(ary, names);
d1320 1
a1320 1
	rb_ary_push(names, rb_str_new2(*pch));
d1322 1
a1322 1
    rb_ary_push(ary, NUM2INT(h->h_addrtype));
d1325 1
a1325 1
	rb_ary_push(ary, rb_str_new(*pch, h->h_length));
d1328 1
a1328 1
    rb_ary_push(ary, rb_str_new(h->h_addr, h->h_length));
d1341 1
a1341 1
    if (rb_obj_is_kind_of(host, rb_cInteger)) {
d1362 1
a1363 1
    char *addr;
d1367 1
a1367 1
    addr = rb_str2cstr(vaddr, &alen);
d1404 1
a1404 1
	    rb_raise(rb_eSocket, "no such servce %s/%s", s, proto);
d1414 1
a1414 1
sock_rb_define_const(name, value)
d1418 1
a1418 1
    rb_define_const(rb_cSocket, name, INT2FIX(value));
d1424 1
a1424 1
    rb_eSocket = rb_define_class("SocketError", rb_eStandardError);
d1426 20
a1445 21
    rb_cBasicSocket = rb_define_class("BasicSocket", rb_cIO);
    rb_undef_method(CLASS_OF(rb_cBasicSocket), "new");
    rb_undef_method(CLASS_OF(rb_cBasicSocket), "open");
    rb_define_method(rb_cBasicSocket, "shutdown", bsock_shutdown, -1);
    rb_define_method(rb_cBasicSocket, "setsockopt", bsock_setsockopt, 3);
    rb_define_method(rb_cBasicSocket, "getsockopt", bsock_getsockopt, 2);
    rb_define_method(rb_cBasicSocket, "getsockname", bsock_getsockname, 0);
    rb_define_method(rb_cBasicSocket, "getpeername", bsock_getpeername, 0);
    rb_define_method(rb_cBasicSocket, "send", bsock_send, -1);
    rb_define_method(rb_cBasicSocket, "recv", bsock_recv, -1);

    rb_cIPsocket = rb_define_class("IPsocket", rb_cBasicSocket);
    rb_define_method(rb_cIPsocket, "addr", ip_addr, 0);
    rb_define_method(rb_cIPsocket, "peeraddr", ip_peeraddr, 0);
    rb_define_singleton_method(rb_cIPsocket, "getaddress", ip_s_getaddress, 1);

    rb_cTCPsocket = rb_define_class("TCPsocket", rb_cIPsocket);
    rb_define_singleton_method(rb_cTCPsocket, "open", tcp_s_open, 2);
    rb_define_singleton_method(rb_cTCPsocket, "new", tcp_s_open, 2);
    rb_define_singleton_method(rb_cTCPsocket, "gethostbyname", tcp_s_gethostbyname, 1);
    rb_define_method(rb_cTCPsocket, "recvfrom", tcp_recvfrom, -1);
d1448 17
a1464 17
    rb_cSOCKSsocket = rb_define_class("SOCKSsocket", rb_cTCPsocket);
    rb_define_singleton_method(rb_cSOCKSsocket, "open", socks_s_open, 2);
    rb_define_singleton_method(rb_cSOCKSsocket, "new", socks_s_open, 2);
#endif

    rb_cTCPserver = rb_define_class("TCPserver", rb_cTCPsocket);
    rb_define_singleton_method(rb_cTCPserver, "open", tcp_svr_s_open, -1);
    rb_define_singleton_method(rb_cTCPserver, "new", tcp_svr_s_open, -1);
    rb_define_method(rb_cTCPserver, "accept", tcp_accept, 0);

    rb_cUDPsocket = rb_define_class("UDPsocket", rb_cIPsocket);
    rb_define_singleton_method(rb_cUDPsocket, "open", udp_s_open, 0);
    rb_define_singleton_method(rb_cUDPsocket, "new", udp_s_open, 0);
    rb_define_method(rb_cUDPsocket, "connect", udp_connect, 2);
    rb_define_method(rb_cUDPsocket, "bind", udp_bind, 2);
    rb_define_method(rb_cUDPsocket, "send", udp_send, -1);
    rb_define_method(rb_cUDPsocket, "recvfrom", udp_recvfrom, -1);
d1467 32
a1498 32
    rb_cUNIXsocket = rb_define_class("UNIXsocket", rb_cBasicSocket);
    rb_define_singleton_method(rb_cUNIXsocket, "open", unix_s_sock_open, 1);
    rb_define_singleton_method(rb_cUNIXsocket, "new", unix_s_sock_open, 1);
    rb_define_method(rb_cUNIXsocket, "path", unix_path, 0);
    rb_define_method(rb_cUNIXsocket, "addr", unix_addr, 0);
    rb_define_method(rb_cUNIXsocket, "peeraddr", unix_peeraddr, 0);
    rb_define_method(rb_cUNIXsocket, "recvfrom", unix_recvfrom, -1);

    rb_cUNIXserver = rb_define_class("UNIXserver", rb_cUNIXsocket);
    rb_define_singleton_method(rb_cUNIXserver, "open", unix_svr_s_open, 1);
    rb_define_singleton_method(rb_cUNIXserver, "new", unix_svr_s_open, 1);
    rb_define_method(rb_cUNIXserver, "accept", unix_accept, 0);
#endif

    rb_cSocket = rb_define_class("Socket", rb_cBasicSocket);
    rb_define_singleton_method(rb_cSocket, "open", sock_s_open, 3);
    rb_define_singleton_method(rb_cSocket, "new", sock_s_open, 3);
    rb_define_singleton_method(rb_cSocket, "for_fd", sock_s_for_fd, 1);

    rb_define_method(rb_cSocket, "connect", sock_connect, 1);
    rb_define_method(rb_cSocket, "bind", sock_bind, 1);
    rb_define_method(rb_cSocket, "listen", sock_listen, 1);
    rb_define_method(rb_cSocket, "accept", sock_accept, 0);

    rb_define_method(rb_cSocket, "recvfrom", sock_recvfrom, -1);

    rb_define_singleton_method(rb_cSocket, "socketpair", sock_s_socketpair, 3);
    rb_define_singleton_method(rb_cSocket, "pair", sock_s_socketpair, 3);
    rb_define_singleton_method(rb_cSocket, "gethostname", sock_gethostname, 0);
    rb_define_singleton_method(rb_cSocket, "gethostbyname", sock_s_gethostbyname, 1);
    rb_define_singleton_method(rb_cSocket, "gethostbyaddr", sock_s_gethostbyaddr, -1);
    rb_define_singleton_method(rb_cSocket, "getservbyname", sock_s_getservbyaname, -1);
d1501 3
a1503 3
    mConst = rb_define_module_under(rb_cSocket, "Constants");
    sock_rb_define_const("SOCK_STREAM", SOCK_STREAM);
    sock_rb_define_const("SOCK_DGRAM", SOCK_DGRAM);
d1505 1
a1505 1
    sock_rb_define_const("SOCK_RAW", SOCK_RAW);
d1508 1
a1508 1
    sock_rb_define_const("SOCK_RDM", SOCK_RDM);
d1511 1
a1511 1
    sock_rb_define_const("SOCK_SEQPACKET", SOCK_SEQPACKET);
d1514 1
a1514 1
    sock_rb_define_const("SOCK_PACKET", SOCK_PACKET);
d1517 1
a1517 1
    sock_rb_define_const("AF_INET", AF_INET);
d1519 1
a1519 1
    sock_rb_define_const("PF_INET", PF_INET);
d1522 2
a1523 2
    sock_rb_define_const("AF_UNIX", AF_UNIX);
    sock_rb_define_const("PF_UNIX", PF_UNIX);
d1526 2
a1527 2
    sock_rb_define_const("AF_AX25", AF_AX25);
    sock_rb_define_const("PF_AX25", PF_AX25);
d1530 2
a1531 2
    sock_rb_define_const("AF_IPX", AF_IPX);
    sock_rb_define_const("PF_IPX", PF_IPX);
d1534 2
a1535 2
    sock_rb_define_const("AF_APPLETALK", AF_APPLETALK);
    sock_rb_define_const("PF_APPLETALK", PF_APPLETALK);
d1538 1
a1538 1
    sock_rb_define_const("MSG_OOB", MSG_OOB);
d1540 1
a1540 1
    sock_rb_define_const("MSG_PEEK", MSG_PEEK);
d1543 1
a1543 1
    sock_rb_define_const("MSG_DONTROUTE", MSG_DONTROUTE);
d1546 1
a1546 1
    sock_rb_define_const("SOL_SOCKET", SOL_SOCKET);
d1548 1
a1548 1
    sock_rb_define_const("SOL_IP", SOL_IP);
d1551 1
a1551 1
    sock_rb_define_const("SOL_IPX", SOL_IPX);
d1554 1
a1554 1
    sock_rb_define_const("SOL_AX25", SOL_AX25);
d1557 1
a1557 1
    sock_rb_define_const("SOL_ATALK", SOL_ATALK);
d1560 1
a1560 1
    sock_rb_define_const("SOL_TCP", SOL_TCP);
d1563 1
a1563 1
    sock_rb_define_const("SOL_UDP", SOL_UDP);
d1567 1
a1567 1
    sock_rb_define_const("SO_DEBUG", SO_DEBUG);
d1569 1
a1569 1
    sock_rb_define_const("SO_REUSEADDR", SO_REUSEADDR);
d1571 1
a1571 1
    sock_rb_define_const("SO_TYPE", SO_TYPE);
d1574 1
a1574 1
    sock_rb_define_const("SO_ERROR", SO_ERROR);
d1577 1
a1577 1
    sock_rb_define_const("SO_DONTROUTE", SO_DONTROUTE);
d1580 1
a1580 1
    sock_rb_define_const("SO_BROADCAST", SO_BROADCAST);
d1583 1
a1583 1
    sock_rb_define_const("SO_SNDBUF", SO_SNDBUF);
d1586 1
a1586 1
    sock_rb_define_const("SO_RCVBUF", SO_RCVBUF);
d1589 1
a1589 1
    sock_rb_define_const("SO_KEEPALIVE", SO_KEEPALIVE);
d1592 1
a1592 1
    sock_rb_define_const("SO_OOBINLINE", SO_OOBINLINE);
d1595 1
a1595 1
    sock_rb_define_const("SO_NO_CHECK", SO_NO_CHECK);
d1598 1
a1598 1
    sock_rb_define_const("SO_PRIORITY", SO_PRIORITY);
d1601 1
a1601 1
    sock_rb_define_const("SO_LINGER", SO_LINGER);
d1605 1
a1605 1
    sock_rb_define_const("SOPRI_INTERACTIVE", SOPRI_INTERACTIVE);
d1608 1
a1608 1
    sock_rb_define_const("SOPRI_NORMAL", SOPRI_NORMAL);
d1611 1
a1611 1
    sock_rb_define_const("SOPRI_BACKGROUND", SOPRI_BACKGROUND);
d1615 1
a1615 1
    sock_rb_define_const("IP_MULTICAST_IF", IP_MULTICAST_IF);
d1618 1
a1618 1
    sock_rb_define_const("IP_MULTICAST_TTL", IP_MULTICAST_TTL);
d1621 1
a1621 1
    sock_rb_define_const("IP_MULTICAST_LOOP", IP_MULTICAST_LOOP);
d1624 1
a1624 1
    sock_rb_define_const("IP_ADD_MEMBERSHIP", IP_ADD_MEMBERSHIP);
d1628 1
a1628 1
    sock_rb_define_const("IP_DEFAULT_MULTICAST_TTL", IP_DEFAULT_MULTICAST_TTL);
d1631 1
a1631 1
    sock_rb_define_const("IP_DEFAULT_MULTICAST_LOOP", IP_DEFAULT_MULTICAST_LOOP);
d1634 1
a1634 1
    sock_rb_define_const("IP_MAX_MEMBERSHIPS", IP_MAX_MEMBERSHIPS);
d1638 1
a1638 1
    sock_rb_define_const("IPX_TYPE", IPX_TYPE);
d1642 1
a1642 1
    sock_rb_define_const("TCP_NODELAY", TCP_NODELAY);
d1645 1
a1645 1
    sock_rb_define_const("TCP_MAXSEG", TCP_MAXSEG);
@


1.1.1.2.2.18.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/09/08 07:09:39 $
d33 1
a33 1
#if defined(USE_THREAD) && defined(HAVE_FCNTL)
d75 1
a75 4
    SOCKET s;

    if (!fptr->f) return;
    s = fileno(fptr->f);
d77 1
a77 1
    if (fptr->f2) free(fptr->f2);
a132 49
bsock_close_read(sock)
    VALUE sock;
{
    OpenFile *fptr;

    rb_secure(4);
    GetOpenFile(sock, fptr);
    if (fptr->f2 == 0) {
	return rb_io_close(sock);
    }
    if (shutdown(fileno(fptr->f), 0) == -1)
	rb_sys_fail(0);
    fptr->mode &= ~FMODE_READABLE;
#ifdef NT
    free(fptr->f);
#else
    fclose(fptr->f);
#endif
    fptr->f = fptr->f2;
    fptr->f2 = 0;

    return Qnil;
}

static VALUE
bsock_close_write(sock)
    VALUE sock;
{
    OpenFile *fptr;

    rb_secure(4);
    GetOpenFile(sock, fptr);
    if (fptr->f2 == 0) {
	return rb_io_close(sock);
    }
    if (shutdown(fileno(fptr->f), 1) == -1)
	rb_sys_fail(0);
    fptr->mode &= ~FMODE_WRITABLE;
#ifdef NT
    free(fptr->f2);
#else
    fclose(fptr->f2);
#endif
    fptr->f2 = 0;

    return Qnil;
}

static VALUE
d238 1
a238 1
    f = GetWriteFile(fptr);
d241 1
a241 1
#ifdef USE_THREAD
d260 1
a260 1
#ifdef USE_THREAD
d306 1
a306 1
#ifdef USE_THREAD
d322 1
a322 1
#ifdef USE_THREAD
d452 1
a452 1
#if defined(USE_THREAD) && defined(HAVE_FCNTL)
d610 1
a610 1
#if defined(USE_THREAD) && defined(HAVE_FCNTL)
d729 1
a729 1
#ifdef USE_THREAD
d742 1
a742 1
#ifdef USE_THREAD
d930 1
a930 1
#ifdef USE_THREAD
d977 1
a977 1
    f = GetWriteFile(fptr);
d989 1
a989 1
#ifdef USE_THREAD
d1242 1
a1242 1
#ifdef USE_THREAD
a1471 2
    rb_define_method(rb_cBasicSocket, "close_read", bsock_close_read, 0);
    rb_define_method(rb_cBasicSocket, "close_write", bsock_close_write, 0);
@


1.1.1.2.2.18.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/10/06 03:28:24 $
d381 1
a381 1
    rb_obj_taint(str);
d591 3
a593 1
	    if (!inet_aton(host, &sockaddr.sin_addr)) {
a604 1
	    hostaddr = sockaddr.sin_addr.s_addr;
@
