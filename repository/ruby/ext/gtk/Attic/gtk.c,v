head	1.2;
access;
symbols
	v1_6_3:1.2
	ruby_1_6:1.2.0.2
	v1_2_6repack:1.1.1.1.2.27
	v1_2_6:1.1.1.1.2.27
	v1_1d1:1.1.1.1.2.25.2.4
	v1_1d0:1.1.1.1.2.25.2.3
	v1_1c6:1.1.1.1.2.27
	gtk_012:1.1.1.1.2.26
	v1_1d-start:1.1.1.1.2.25.2.1
	v1_1dev:1.1.1.1.2.25.0.2
	v1_1r:1.1.1.1.0.2
	v1_1:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	99.08.13.05.37.48;	author matz;	state dead;
branches;
next	1.1;

1.1
date	98.01.16.12.19.15;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.19.15;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	98.01.16.12.35.59;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	98.01.19.05.08.23;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	98.01.20.06.10.11;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	98.01.22.08.32.48;	author matz;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	98.01.22.10.01.05;	author matz;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	98.01.26.05.18.10;	author matz;	state Exp;
branches;
next	1.1.1.1.2.7;

1.1.1.1.2.7
date	98.01.29.08.22.20;	author matz;	state Exp;
branches;
next	1.1.1.1.2.8;

1.1.1.1.2.8
date	98.01.29.08.58.06;	author matz;	state Exp;
branches;
next	1.1.1.1.2.9;

1.1.1.1.2.9
date	98.02.10.06.50.17;	author matz;	state Exp;
branches;
next	1.1.1.1.2.10;

1.1.1.1.2.10
date	98.02.18.01.56.45;	author matz;	state Exp;
branches;
next	1.1.1.1.2.11;

1.1.1.1.2.11
date	98.02.20.08.28.49;	author matz;	state Exp;
branches;
next	1.1.1.1.2.12;

1.1.1.1.2.12
date	98.02.26.08.27.13;	author matz;	state Exp;
branches;
next	1.1.1.1.2.13;

1.1.1.1.2.13
date	98.03.05.06.37.49;	author matz;	state Exp;
branches;
next	1.1.1.1.2.14;

1.1.1.1.2.14
date	98.03.11.07.33.03;	author matz;	state Exp;
branches;
next	1.1.1.1.2.15;

1.1.1.1.2.15
date	98.04.14.04.55.51;	author matz;	state Exp;
branches;
next	1.1.1.1.2.16;

1.1.1.1.2.16
date	98.04.23.07.38.03;	author matz;	state Exp;
branches;
next	1.1.1.1.2.17;

1.1.1.1.2.17
date	98.04.24.09.33.24;	author matz;	state Exp;
branches;
next	1.1.1.1.2.18;

1.1.1.1.2.18
date	98.04.27.10.04.05;	author matz;	state Exp;
branches;
next	1.1.1.1.2.19;

1.1.1.1.2.19
date	98.04.28.06.14.45;	author matz;	state Exp;
branches;
next	1.1.1.1.2.20;

1.1.1.1.2.20
date	98.05.14.04.10.36;	author matz;	state Exp;
branches;
next	1.1.1.1.2.21;

1.1.1.1.2.21
date	98.06.24.04.38.05;	author matz;	state Exp;
branches;
next	1.1.1.1.2.22;

1.1.1.1.2.22
date	98.06.26.08.08.47;	author matz;	state Exp;
branches;
next	1.1.1.1.2.23;

1.1.1.1.2.23
date	98.06.30.01.40.47;	author matz;	state Exp;
branches;
next	1.1.1.1.2.24;

1.1.1.1.2.24
date	98.07.03.06.28.57;	author matz;	state Exp;
branches;
next	1.1.1.1.2.25;

1.1.1.1.2.25
date	98.08.10.05.55.34;	author matz;	state Exp;
branches
	1.1.1.1.2.25.2.1;
next	1.1.1.1.2.26;

1.1.1.1.2.26
date	98.09.17.09.55.47;	author matz;	state Exp;
branches;
next	1.1.1.1.2.27;

1.1.1.1.2.27
date	98.10.06.02.47.50;	author matz;	state Exp;
branches;
next	;

1.1.1.1.2.25.2.1
date	98.09.08.07.09.33;	author matz;	state Exp;
branches;
next	1.1.1.1.2.25.2.2;

1.1.1.1.2.25.2.2
date	98.10.06.03.28.18;	author matz;	state Exp;
branches;
next	1.1.1.1.2.25.2.3;

1.1.1.1.2.25.2.3
date	98.12.16.07.30.34;	author matz;	state Exp;
branches;
next	1.1.1.1.2.25.2.4;

1.1.1.1.2.25.2.4
date	98.12.22.09.01.54;	author matz;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove marshal/gtk/kconv
@
text
@/************************************************

  gtk.c -

  $Author: matz $
  $Date: 1998/01/16 12:19:15 $
  created at: Wed Jan  7 23:55:11 JST 1998

************************************************/

#include "ruby.h"
#include "sig.h"
#include <gtk/gtk.h>
#include <signal.h>

extern VALUE rb_argv, rb_argv0;
extern VALUE cData;

static VALUE mGtk;

static VALUE gObject;
static VALUE gWidget;
static VALUE gContainer;
static VALUE gBin;
static VALUE gAlignment;
static VALUE gMisc;
static VALUE gArrow;
static VALUE gFrame;
static VALUE gAspectFrame;
static VALUE gData;
static VALUE gAdjustment;
static VALUE gBox;
static VALUE gButton;
static VALUE gTButton;
static VALUE gCButton;
static VALUE gRButton;
static VALUE gBBox;
static VALUE gCList;
static VALUE gWindow;
static VALUE gDialog;
static VALUE gFileSel;
static VALUE gVBox;
static VALUE gColorSel;
static VALUE gColorSelDialog;
static VALUE gImage;
static VALUE gDrawArea;
static VALUE gEntry;
static VALUE gEventBox;
static VALUE gFixed;
static VALUE gGamma;
static VALUE gHBBox;
static VALUE gVBBox;
static VALUE gHBox;
static VALUE gPaned;
static VALUE gHPaned;
static VALUE gVPaned;
static VALUE gRuler;
static VALUE gHRuler;
static VALUE gVRuler;
static VALUE gRange;
static VALUE gScale;
static VALUE gHScale;
static VALUE gVScale;
static VALUE gScrollbar;
static VALUE gHScrollbar;
static VALUE gVScrollbar;
static VALUE gSeparator;
static VALUE gHSeparator;
static VALUE gVSeparator;
static VALUE gInputDialog;
static VALUE gLabel;
static VALUE gList;
static VALUE gItem;
static VALUE gListItem;
static VALUE gMenuShell;
static VALUE gMenu;
static VALUE gMenuBar;
static VALUE gMenuItem;
static VALUE gCMenuItem;
static VALUE gRMenuItem;
static VALUE gNotebook;
static VALUE gOptionMenu;
static VALUE gPixmap;
static VALUE gPreview;
static VALUE gProgressBar;
static VALUE gScrolledWin;
static VALUE gTable;
static VALUE gText;
static VALUE gToolbar;
static VALUE gTooltips;
static VALUE gTree;
static VALUE gTreeItem;
static VALUE gViewPort;

static VALUE gAcceleratorTable;
static VALUE gStyle;
static VALUE gPreviewInfo;
static VALUE gAllocation;
static VALUE gRequisiton;

static VALUE mGdk;

static VALUE gdkFont;
static VALUE gdkColor;
static VALUE gdkColormap;
static VALUE gdkPixmap;
static VALUE gdkBitmap;
static VALUE gdkWindow;
static VALUE gdkImage;
static VALUE gdkVisual;
static VALUE gdkGC;
static VALUE gdkRectangle;
static VALUE gdkGCValues;
static VALUE gdkRectangle;
static VALUE gdkSegment;
static VALUE gdkWindowAttr;
static VALUE gdkCursor;
static VALUE gdkAtom;
static VALUE gdkColorContext;
static VALUE gdkEvent;

ID id_gtkdata, id_relatives, id_call;

static void gobj_free();

static char*
get_cstring(str)
    VALUE str;
{
    if (NIL_P(str)) return NULL;
    Check_Type(str, T_STRING);
    return RSTRING(str)->ptr;
}

static GtkObject*
get_gobject(obj)
    VALUE obj;
{
    struct RData *data;
    GtkObject *gtkp;

    if (NIL_P(obj)) return NULL;

    Check_Type(obj, T_OBJECT);
    data = RDATA(rb_ivar_get(obj, id_gtkdata));
    if (NIL_P(data) || data->dfree != gobj_free) {
	TypeError("not a Gtk object");
    }
    Data_Get_Struct(data, GtkObject, gtkp);
    if (!GTK_IS_OBJECT(gtkp)) {
	TypeError("not a GtkObject");
    }

    return gtkp;
}

static GtkWidget*
get_widget(obj)
    VALUE obj;
{
    GtkObject *data = get_gobject(obj);

    return GTK_WIDGET(data);
}

static VALUE
get_value_from_gobject(obj)
    GtkObject *obj;
{
    return (VALUE)gtk_object_get_user_data(obj);
}

static void
clear_gobject(obj)
    VALUE obj;
{
    rb_ivar_set(obj, id_relatives, Qnil);
}

static void
add_relative(obj, relative)
    VALUE obj, relative;
{
    VALUE ary = rb_ivar_get(obj, id_relatives);

    if (TYPE(ary) != T_ARRAY) {
	ary = ary_new();
	rb_ivar_set(obj, id_relatives, ary);
    }
    ary_push(ary, relative);
}

static VALUE gtk_object_list;

static void
gobj_free(obj)
    GtkObject *obj;
{
    VALUE self = get_value_from_gobject(obj);

    if (GTK_OBJECT_NEED_DESTROY(obj)) {
	gtk_object_destroy(obj);
    }
    rb_ivar_set(self, id_relatives, Qnil);
}

static void
delete_gobject(obj)
    GtkObject *obj;
{
    ary_delete(gtk_object_list, get_value_from_gobject(obj));
}

static VALUE
make_gobject(klass, gtkobj)
    VALUE klass;
    GtkObject *gtkobj;
{
    VALUE obj = obj_alloc(klass);
    VALUE data;

    data = Data_Wrap_Struct(cData, 0, gobj_free, gtkobj);
    gtk_object_set_user_data(gtkobj, (gpointer)obj);

    rb_ivar_set(obj, id_gtkdata, data);
    gtk_signal_connect(gtkobj, "destroy", (GtkSignalFunc)delete_gobject, 0);
    ary_push(gtk_object_list, obj);
    return obj;
}

static VALUE
make_widget(klass, widget)
    VALUE klass;
    GtkWidget *widget;
{
    return make_gobject(klass, GTK_OBJECT(widget));
}

static void
free_gstyle(style)
    GtkStyle *style;
{
    gtk_style_unref(style);
}

static VALUE
make_gstyle(style)
    GtkStyle *style;
{
    gtk_style_ref(style);
    return Data_Wrap_Struct(gStyle, 0, free_gstyle, style);
}

static GtkStyle*
get_gstyle(style)
    VALUE style;
{
    GtkStyle *gstyle;

    if (NIL_P(style)) return NULL;
    if (!obj_is_instance_of(style, gStyle)) {
	TypeError("not a GtkStyle");
    }
    Data_Get_Struct(style, GtkStyle, gstyle);

    return gstyle;
}

static void
free_gaccel(tbl)
    GtkAcceleratorTable *tbl;
{
    gtk_accelerator_table_unref(tbl);
}

static VALUE
make_gtkacceltbl(tbl)
    GtkAcceleratorTable *tbl;
{
    gtk_accelerator_table_ref(tbl);
    return Data_Wrap_Struct(gAcceleratorTable, 0, free_gaccel, tbl);
}

static GtkAcceleratorTable*
get_gtkacceltbl(value)
    VALUE value;
{
    GtkAcceleratorTable *tbl;

    if (NIL_P(value)) return NULL;

    if (!obj_is_instance_of(value, gAcceleratorTable)) {
	TypeError("not an AcceleratorTable");
    }
    Data_Get_Struct(value, GtkAcceleratorTable, tbl);

    return tbl;
}

static VALUE
make_gtkprevinfo(info)
    GtkPreviewInfo *info;
{
    return Data_Wrap_Struct(gAcceleratorTable, 0, 0, info);
}

static GtkPreviewInfo*
get_gtkprevinfo(value)
    VALUE value;
{
    GtkPreviewInfo *info;

    if (NIL_P(value)) return NULL;

    if (!obj_is_instance_of(value, gPreviewInfo)) {
	TypeError("not a PreviewInfo");
    }
    Data_Get_Struct(value, GtkPreviewInfo, info);

    return info;
}

static void
exec_callback(widget, data, nparams, params)
    GtkWidget *widget;
    VALUE data;
    int nparams;
    GtkType *params;
{
    VALUE self = get_value_from_gobject(GTK_OBJECT(widget));
    VALUE proc = RARRAY(data)->ptr[0];
    VALUE event = RARRAY(data)->ptr[1];
    ID id = NUM2INT(event);

    if (NIL_P(proc) && rb_respond_to(self, id)) {
	rb_funcall(self, id, 3, self,
		   INT2FIX(nparams), INT2NUM((INT)params));
    }
    else {
	rb_funcall(proc, id_call, 1, self);
    }
}

static void
free_ttips(tips)
    GtkTooltips *tips;
{
    gtk_tooltips_unref(tips);
}

static VALUE
make_ttips(klass, tips)
    VALUE klass;
    GtkTooltips *tips;
{
    gtk_tooltips_ref(tips);
    return Data_Wrap_Struct(klass, 0, free_ttips, tips);
}

static GtkTooltips*
get_ttips(tips)
    VALUE tips;
{
    GtkTooltips *gtips;

    if (NIL_P(tips)) return NULL;

    if (!obj_is_instance_of(tips, gTooltips)) {
	TypeError("not a GtkTooltips");
    }
    Data_Get_Struct(tips, GtkTooltips, gtips);

    return gtips;
}

static void
free_gdkfont(font)
    GdkFont *font;
{
    gdk_font_unref(font);
}

static VALUE
make_gdkfont(font)
    GdkFont *font;
{
    gdk_font_ref(font);
    return Data_Wrap_Struct(gdkFont, 0, free_gdkfont, font);
}

static GdkFont*
get_gdkfont(font)
    VALUE font;
{
    GdkFont *gfont;

    if (NIL_P(font)) return NULL;

    if (!obj_is_instance_of(font, gdkFont)) {
	TypeError("not a GdkFont");
    }
    Data_Get_Struct(font, GdkFont, gfont);

    return gfont;
}

static VALUE
gdkfnt_equal(fn1, fn2)
    VALUE fn1, fn2;
{
    if (gdk_font_equal(get_gdkfont(fn1), get_gdkfont(fn2)))
	return TRUE;
    return FALSE;
}

static void
free_tobj(obj)
    gpointer obj;
{
    free(obj);
}

static VALUE
make_tobj(obj, klass, size)
    gpointer obj;
    VALUE klass;
    int size;
{
    gpointer copy;
    VALUE data;

    copy = xmalloc(size);
    memcpy(copy, obj, size);
    data = Data_Wrap_Struct(klass, 0, free_tobj, copy);

    return data;
}

static gpointer
get_tobj(obj, klass)
    VALUE obj, klass;
{
    void *ptr;

    if (NIL_P(obj)) return NULL;

    if (!obj_is_instance_of(obj, klass)) {
	TypeError("not a %s", rb_class2name(klass));
    }
    Data_Get_Struct(obj, void, ptr);

    return ptr;
}

#define make_gdkcolor(c) make_tobj(c, gdkColor, sizeof(GdkColor))
#define get_gdkcolor(c) ((GdkColor*)get_tobj(c, gdkColor))

#define make_gdkrect(c) make_tobj(c, gdkRectangle, sizeof(GdkRectangle))
#define get_gdkrect(c) ((GdkRectangle*)get_tobj(c, gdkRectangle))

#define make_gdksegment(c) make_tobj(c, gdkSegment, sizeof(GdkSegment))
#define get_gdksegment(c) ((GdkSegment*)get_tobj(c, gdkSegment))

#define make_gdkwinattr(c) make_tobj(c, gdkWindowAttr, sizeof(GdkWindowAttr))
#define get_gdkwinattr(c) ((GdkWindowAttr*)get_tobj(c, gdkWindowAttr))

#define make_gdkwinattr(c) make_tobj(c, gdkWindowAttr, sizeof(GdkWindowAttr))
#define get_gdkwinattr(c) ((GdkWindowAttr*)get_tobj(c, gdkWindowAttr))

#define make_gallocation(c) make_tobj(c, gAllocation, sizeof(GtkAllocation))
#define get_gallocation(c) ((GtkAllocation*)get_tobj(c, gAllocation))

#define make_grequisiton(c) make_tobj(c, gRequisiton, sizeof(GtkRequisition))
#define get_grequisiton(c) ((GtkRequisition*)get_tobj(c, gRequisiton))

#define make_gdkrectangle(r) make_tobj(r, gdkRectangle, sizeof(GdkRectangle))
#define get_gdkrectangle(r) ((GdkRectangle*)get_tobj(r, gdkRectangle))

static void
free_gdkcmap(cmap)
    GdkColormap *cmap;
{
    gdk_colormap_unref(cmap);
}

static VALUE
make_gdkcmap(cmap)
    GdkColormap *cmap;
{
    gdk_colormap_ref(cmap);
    return Data_Wrap_Struct(gdkColormap, 0, free_gdkcmap, cmap);
}

static GdkColormap*
get_gdkcmap(cmap)
    VALUE cmap;
{
    GdkColormap *gcmap;

    if (NIL_P(cmap)) return NULL;

    if (!obj_is_kind_of(cmap, gdkColormap)) {
	TypeError("not a GdkColormap");
    }
    Data_Get_Struct(cmap, GdkColormap, gcmap);

    return gcmap;
}

static VALUE
make_gdkvisual(visual)
    GdkVisual *visual;
{
    return Data_Wrap_Struct(gdkVisual, 0, 0, visual);
}

static GdkVisual*
get_gdkvisual(visual)
    VALUE visual;
{
    GdkVisual *gvisual;

    if (NIL_P(visual)) return NULL;

    if (!obj_is_kind_of(visual, gdkVisual)) {
	TypeError("not a GdkVisual");
    }
    Data_Get_Struct(visual, GdkVisual, gvisual);

    return gvisual;
}

static void
free_gdkwindow(window)
    GdkWindow *window;
{
    gdk_window_unref(window);
}

static VALUE
make_gdkwindow(window)
    GdkWindow *window;
{
    gdk_window_ref(window);
    return Data_Wrap_Struct(gdkWindow, 0, free_gdkwindow, window);
}

static GdkWindow*
get_gdkwindow(window)
    VALUE window;
{
    GdkWindow *gwindow;

    if (NIL_P(window)) return NULL;

    if (!obj_is_kind_of(window, gdkWindow)) {
	TypeError("not a GdkWindow");
    }
    Data_Get_Struct(window, GdkWindow, gwindow);

    return gwindow;
}

static void
free_gdkpixmap(pixmap)
    GdkPixmap *pixmap;
{
    gdk_pixmap_unref(pixmap);
}

static VALUE
make_gdkpixmap(klass, pixmap)
    VALUE klass;
    GdkPixmap *pixmap;
{
    gdk_pixmap_ref(pixmap);
    return Data_Wrap_Struct(klass, 0, free_gdkpixmap, pixmap);
}

static GdkPixmap*
get_gdkpixmap(pixmap)
    VALUE pixmap;
{
    GdkPixmap *gpixmap;

    if (NIL_P(pixmap)) return NULL;

    if (!obj_is_kind_of(pixmap, gdkPixmap)) {
	TypeError("not a GdkPixmap");
    }
    Data_Get_Struct(pixmap, GdkPixmap, gpixmap);

    return gpixmap;
}

static VALUE
gdkpmap_s_new(self, win, w, h, depth)
    VALUE self, win, w, h, depth;
{
    GdkPixmap *new;
    GdkWindow *window = get_gdkwindow(win);

    new = gdk_pixmap_new(window, NUM2INT(w), NUM2INT(h), NUM2INT(depth));
    return make_gdkpixmap(self, new);
}

static VALUE
gdkpmap_create_from_data(self, win, data, w, h, depth, fg, bg)
    VALUE self, win, data, w, h, depth, fg, bg;
{
    GdkPixmap *new;
    GdkWindow *window = get_gdkwindow(win);

    Check_Type(data, T_STRING);
    new = gdk_pixmap_create_from_data(window,
				      RSTRING(data)->ptr,
				      NUM2INT(w), NUM2INT(h),
				      NUM2INT(depth),
				      get_gdkcolor(fg),
				      get_gdkcolor(bg));
    return make_gdkpixmap(self, new);
}

static VALUE
gdkpmap_create_from_xpm(self, win, tcolor, fname)
    VALUE self, win, tcolor, fname;
{
    GdkPixmap *new;
    GdkBitmap *mask;
    GdkWindow *window = get_gdkwindow(win);

    Check_Type(fname, T_STRING);
    new = gdk_pixmap_create_from_xpm(window, &mask,
				     get_gdkcolor(tcolor),
				     RSTRING(fname)->ptr);
    if (!new) {
	ArgError("Pixmap not created from %s", RSTRING(fname)->ptr);
    }
    return assoc_new(make_gdkpixmap(self, new),
		     make_gdkpixmap(gdkBitmap, mask));
}

static VALUE
gdkpmap_create_from_xpm_d(self, win, tcolor, data)
    VALUE self, win, tcolor, data;
{
    GdkPixmap *new;
    GdkBitmap *mask;
    GdkWindow *window = get_gdkwindow(win);
    int i;
    gchar **buf;

    Check_Type(data, T_ARRAY);
    buf = ALLOCA_N(char*, RARRAY(data)->len);
    for (i=0; i<RARRAY(data)->len; i++) {
	Check_Type(RARRAY(data)->ptr[i], T_STRING);
	buf[i] = RSTRING(RARRAY(data)->ptr[i])->ptr;
    }

    new = gdk_pixmap_create_from_xpm_d(window, &mask,
				       get_gdkcolor(tcolor),
				       buf);

    return assoc_new(make_gdkpixmap(self, new),
		     make_gdkpixmap(gdkBitmap, mask));
}

static VALUE
gdkbmap_s_new(self, win, w, h)
    VALUE self, win, w, h;
{
    GdkPixmap *new;
    GdkWindow *window = get_gdkwindow(win);

    new = gdk_pixmap_new(window, NUM2INT(w), NUM2INT(h), 1);
    return make_gdkpixmap(self, new);
}

static VALUE
gdkbmap_create_from_data(self, win, data, w, h)
    VALUE self, win, data, w, h;
{
    GdkBitmap *new;
    GdkWindow *window = get_gdkwindow(win);

    Check_Type(data, T_STRING);
    new = gdk_bitmap_create_from_data(window,
				      RSTRING(data)->ptr,
				      NUM2INT(w), NUM2INT(h));
    return make_gdkpixmap(self, (GdkPixmap*)new);
}

static void
free_gdkimage(image)
    GdkImage *image;
{
    gdk_image_destroy(image);
}

static VALUE
make_gdkimage(image)
    GdkImage *image;
{
    return Data_Wrap_Struct(gdkImage, 0, free_gdkimage, image);
}

static GdkImage*
get_gdkimage(image)
    VALUE image;
{
    GdkImage *gimage;

    if (NIL_P(image)) return NULL;

    if (!obj_is_instance_of(image, gdkImage)) {
	TypeError("not a GdkImage");
    }
    Data_Get_Struct(image, GdkImage, gimage);

    return gimage;
}

static void
free_gdkevent(event)
    GdkEvent *event;
{
    gdk_event_free(event);
}

static VALUE
make_gdkevent(event)
    GdkEvent *event;
{
    event = gdk_event_copy(event);
    return Data_Wrap_Struct(gdkEvent, 0, free_gdkevent, event);
}

static GdkEvent*
get_gdkevent(event)
    VALUE event;
{
    GdkEvent *gevent;

    if (NIL_P(event)) return NULL;

    if (!obj_is_instance_of(event, gdkEvent)) {
	TypeError("not a GdkEvent");
    }
    Data_Get_Struct(event, GdkEvent, gevent);

    return gevent;
}

static VALUE
glist2ary(list)
    GList *list; 
{
    VALUE ary = ary_new();

    while (list) {
	ary_push(ary, get_value_from_gobject(GTK_OBJECT(list->data)));
	list = list->next;
    }

    return ary;
}

static GList*
ary2glist(ary)
    VALUE ary;
{
    int i;
    GList *glist = NULL;

    Check_Type(ary, T_ARRAY);
    for (i=0; i<RARRAY(ary)->len; i++) {
	glist = g_list_prepend(glist,get_widget(RARRAY(ary)->ptr[i]));
    }

    return g_list_reverse(glist);
}

static GSList*
ary2gslist(ary)
    VALUE ary;
{
    int i;
    GSList *glist = NULL;

    if (NIL_P(ary)) return NULL;
    Check_Type(ary, T_ARRAY);
    for (i=0; i<RARRAY(ary)->len; i++) {
	glist = g_slist_append(glist,get_widget(RARRAY(ary)->ptr[i]));
    }

    return glist;
}

static VALUE
gslist2ary(list)
    GSList *list; 
{
    VALUE ary = ary_new();

    while (list) {
	ary_push(ary, get_value_from_gobject(GTK_OBJECT(list->data)));
	list = list->next;
    }

    return ary;
}

static VALUE
gobj_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    Fail("can't instantiate class %s", rb_class2name(self));
}

static VALUE
gobj_smethod_added(self, id)
    VALUE self, id;
{
    GtkObject *obj = get_gobject(self);
    char *name = rb_id2name(NUM2INT(id));
    

    if (gtk_signal_lookup(name, GTK_OBJECT_TYPE(obj))) {
	VALUE handler = assoc_new(Qnil, id);

	add_relative(self, handler);
	gtk_signal_connect_interp(obj, name,
				  exec_callback, (gpointer)handler,
				  NULL, 0);
    }
    return Qnil;
}

static VALUE
gobj_destroy(self)
    VALUE self;
{
    printf("a\n");
    gtk_object_destroy(get_gobject(self));
    printf("b\n");
    clear_gobject(self);
    return Qnil;
}

static VALUE
gobj_set_flags(self, flags)
    VALUE self, flags;
{
    GtkObject *object = get_gobject(self);
    GTK_OBJECT_SET_FLAGS(object, NUM2INT(flags));
    return self;
}

static VALUE
gobj_unset_flags(self, flags)
    VALUE self, flags;
{
    GtkObject *object = get_gobject(self);
    GTK_OBJECT_UNSET_FLAGS(object, NUM2INT(flags));
    return self;
}

static VALUE
gobj_sig_connect(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE sig, handler;
    GtkWidget *widget = get_widget(self);
    ID id = 0;
    int n;

    rb_scan_args(argc, argv, "11", &sig, &handler);
    Check_Type(sig, T_STRING);
    if (NIL_P(handler) && iterator_p()) {
	handler = f_lambda();
	id = rb_intern(RSTRING(sig)->ptr);
    }
    handler = assoc_new(handler, INT2NUM(id));
    add_relative(self, handler);
    n = gtk_signal_connect_interp(GTK_OBJECT(widget), RSTRING(sig)->ptr,
				  exec_callback, (gpointer)handler,
				  NULL, 0);

    return INT2FIX(n);
}

static VALUE
gobj_sig_connect_after(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE sig, handler;
    GtkWidget *widget = get_widget(self);
    ID id = 0;
    int n;

    rb_scan_args(argc, argv, "11", &sig, &handler);
    Check_Type(sig, T_STRING);
    if (NIL_P(handler) && iterator_p()) {
	handler = f_lambda();
	id = rb_intern(RSTRING(sig)->ptr);
    }
    add_relative(self, handler);
    n = gtk_signal_connect_interp(GTK_OBJECT(widget), RSTRING(sig)->ptr,
				  exec_callback, (gpointer)handler,
				  NULL, 1);

    return INT2FIX(n);
}

static VALUE
cont_bwidth(self, width)
    VALUE self, width;
{
    GtkWidget *widget = get_widget(self);
    gtk_container_border_width(GTK_CONTAINER(widget), NUM2INT(width));
    return self;
}

static VALUE
cont_add(self, other)
    VALUE self, other;
{
    GtkWidget *widget = get_widget(self);

    gtk_container_add(GTK_CONTAINER(widget), get_widget(other));
    return self;
}

static VALUE
cont_disable_resize(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_container_disable_resize(GTK_CONTAINER(widget));
    return self;
}

static VALUE
cont_enable_resize(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_container_enable_resize(GTK_CONTAINER(widget));
    return self;
}

static VALUE
cont_block_resize(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_container_block_resize(GTK_CONTAINER(widget));
    return self;
}

static VALUE
cont_unblock_resize(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_container_unblock_resize(GTK_CONTAINER(widget));
    return self;
}

static VALUE
cont_need_resize(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_container_need_resize(GTK_CONTAINER(widget));
    return self;
}

static VALUE
cont_foreach(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE callback;
    GtkWidget *widget = get_widget(self);

    rb_scan_args(argc, argv, "01", &callback);
    if (NIL_P(callback)) {
	callback = f_lambda();
    }
    gtk_container_foreach(GTK_CONTAINER(widget), 
			  exec_callback, (gpointer)callback);
    return self;
}

static void
yield_callback(widget)
    GtkWidget *widget;
{
    rb_yield(get_value_from_gobject(GTK_OBJECT(widget)));
}

static VALUE
cont_each(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_container_foreach(GTK_CONTAINER(widget), 
			  yield_callback, 0);
    return self;
}

static VALUE
cont_focus(self, direction)
    VALUE self, direction;
{
    GtkWidget *widget = get_widget(self);

    gtk_container_focus(GTK_CONTAINER(widget),
			(GtkDirectionType)NUM2INT(direction));
    return self;
}

static void
cont_children_callback(widget, data)
    GtkWidget *widget;
    gpointer data;
{
    VALUE ary = (VALUE)data;

    ary_push(ary, get_value_from_gobject(GTK_OBJECT(widget)));
}

static VALUE
cont_children(self, direction)
    VALUE self, direction;
{
    GtkWidget *widget = get_widget(self);
    VALUE ary = ary_new();

    gtk_container_foreach(GTK_CONTAINER(widget),
			  cont_children_callback,
			  (gpointer)ary);
    return ary;
}

static VALUE
align_s_new(self, xalign, yalign, xscale, yscale)
    VALUE self, xalign, yalign, xscale, yscale;
{
    return make_widget(self, gtk_alignment_new(NUM2DBL(xalign),
					       NUM2DBL(yalign),
					       NUM2DBL(xscale),
					       NUM2DBL(yscale)));
}

static VALUE
align_set(self, xalign, yalign, xscale, yscale)
    VALUE self, xalign, yalign, xscale, yscale;
{
    GtkWidget *widget = get_widget(self);

    gtk_alignment_set(GTK_ALIGNMENT(widget),
		      NUM2DBL(xalign), NUM2DBL(yalign),
		      NUM2DBL(xscale), NUM2DBL(yscale));
    return self;
}

static VALUE
misc_set_align(self, xalign, yalign)
    VALUE self, xalign, yalign;
{
    GtkWidget *widget = get_widget(self);

    gtk_misc_set_alignment(GTK_MISC(widget),
		      NUM2DBL(xalign), NUM2DBL(yalign));
    return self;
}

static VALUE
misc_set_padding(self, xpad, ypad)
    VALUE self, xpad, ypad;
{
    GtkWidget *widget = get_widget(self);

    gtk_misc_set_padding(GTK_MISC(widget),
			 NUM2DBL(xpad), NUM2DBL(ypad));
    return self;
}

static VALUE
arrow_s_new(self, arrow_t, shadow_t)
    VALUE self, arrow_t, shadow_t;
{
    return make_widget(self, gtk_arrow_new((GtkArrowType)NUM2INT(arrow_t),
					   (GtkShadowType)NUM2INT(shadow_t)));
}

static VALUE
arrow_set(self, arrow_t, shadow_t)
    VALUE self, arrow_t, shadow_t;
{
    GtkWidget *widget = get_widget(self);

    gtk_arrow_set(GTK_ARROW(widget),
		  (GtkArrowType)NUM2INT(arrow_t),
		  (GtkShadowType)NUM2INT(shadow_t));
    return self;
}

static VALUE
frame_s_new(self, label)
    VALUE self, label;
{
    return make_widget(self, gtk_frame_new(get_cstring(label)));
}

static VALUE
frame_set_label(self, label)
    VALUE self, label;
{
    GtkWidget *widget = get_widget(self);

    gtk_frame_set_label(GTK_FRAME(widget), get_cstring(label));
    return self;
}

static VALUE
frame_set_label_align(self, xalign, yalign)
    VALUE self, xalign, yalign;
{
    GtkWidget *widget = get_widget(self);

    gtk_frame_set_label_align(GTK_FRAME(widget),
			      NUM2DBL(xalign),
			      NUM2DBL(yalign));

    return self;
}

static VALUE
frame_set_shadow_type(self, type)
    VALUE self, type;
{
    GtkWidget *widget = get_widget(self);

    gtk_frame_set_shadow_type(GTK_FRAME(widget),
			      (GtkShadowType)NUM2INT(type));
    return self;
}

static VALUE
aframe_s_new(self, label, xalign, yalign, ratio, obey_child)
    VALUE self, label, xalign, yalign, ratio, obey_child;
{
    return make_widget(self, gtk_aspect_frame_new(get_cstring(label),
						  NUM2DBL(xalign),
						  NUM2DBL(yalign),
						  NUM2DBL(ratio),
						  RTEST(obey_child)));
}

static VALUE
aframe_set(self, xalign, yalign, ratio, obey_child)
    VALUE self, xalign, yalign, ratio, obey_child;
{
    GtkWidget *widget = get_widget(self);

    gtk_aspect_frame_set(GTK_ASPECT_FRAME(widget),
			 NUM2DBL(xalign), NUM2DBL(yalign),
			 NUM2DBL(ratio), RTEST(obey_child));
    return self;
}

static VALUE
adj_s_new(self, value, lower, upper, step_inc, page_inc, page_size)
    VALUE self, value, lower, upper, step_inc, page_inc, page_size;
{
    return make_widget(self, gtk_adjustment_new(NUM2DBL(value),
						NUM2DBL(lower),
						NUM2DBL(upper),
						NUM2DBL(step_inc),
						NUM2DBL(page_inc),
						NUM2DBL(page_size)));
}

static VALUE
widget_destroy(self)
    VALUE self;
{
    gtk_widget_destroy(get_widget(self));
    clear_gobject(self);

    return Qnil;
}

static VALUE
widget_show(self)
    VALUE self;
{
    gtk_widget_show(get_widget(self));
    return self;
}

static VALUE
widget_show_all(self)
    VALUE self;
{
    gtk_widget_show_all(get_widget(self));
    return self;
}

static VALUE
widget_hide(self)
    VALUE self;
{
    gtk_widget_hide(get_widget(self));
    return self;
}

static VALUE
widget_hide_all(self)
    VALUE self;
{
    gtk_widget_hide_all(get_widget(self));
    return self;
}

static VALUE
widget_map(self)
    VALUE self;
{
    gtk_widget_map(get_widget(self));
    return self;
}

static VALUE
widget_unmap(self)
    VALUE self;
{
    gtk_widget_unmap(get_widget(self));
    return self;
}

static VALUE
widget_realize(self)
    VALUE self;
{
    gtk_widget_realize(get_widget(self));
    return self;
}

static VALUE
widget_unrealize(self)
    VALUE self;
{
    gtk_widget_unrealize(get_widget(self));
    return self;
}

static VALUE
widget_queue_draw(self)
    VALUE self;
{
    gtk_widget_queue_draw(get_widget(self));
    return self;
}

static VALUE
widget_queue_resize(self)
    VALUE self;
{
    gtk_widget_queue_resize(get_widget(self));
    return self;
}

static VALUE
widget_draw(self, rect)
    VALUE self, rect;
{
    gtk_widget_draw(get_widget(self), get_gdkrectangle(rect));
    return self;
}

static VALUE
widget_draw_focus(self)
    VALUE self;
{
    gtk_widget_draw_focus(get_widget(self));
    return self;
}

static VALUE
widget_draw_default(self)
    VALUE self;
{
    gtk_widget_draw_default(get_widget(self));
    return self;
}

static VALUE
widget_draw_children(self)
    VALUE self;
{
    gtk_widget_draw_children(get_widget(self));
    return self;
}

static VALUE
widget_size_request(self, req)
    VALUE self, req;
{
    gtk_widget_size_request(get_widget(self), get_grequisiton(req));
    return self;
}

static VALUE
widget_size_allocate(self, alloc)
    VALUE self, alloc;
{
    gtk_widget_size_allocate(get_widget(self), get_gallocation(alloc));
    return self;
}

static VALUE
widget_inst_accel(self, accel, sig, key, mod)
    VALUE self, accel, sig, key, mod;
{
    gtk_widget_install_accelerator(get_widget(self),
				   get_gtkacceltbl(accel),
				   get_cstring(sig),
				   NUM2INT(key),
				   (guint8)NUM2INT(mod));
    return self;
}

static VALUE
widget_rm_accel(self, accel, sig)
    VALUE self, accel, sig;
{
    gtk_widget_remove_accelerator(get_widget(self),
				  get_gtkacceltbl(accel),
				  get_cstring(sig));
    return self;
}

static VALUE
widget_event(self, event)
    VALUE self, event;
{
    int n = gtk_widget_event(get_widget(self), get_gdkevent(event));
    return NUM2INT(n);
}

static VALUE
widget_activate(self)
    VALUE self;
{
    gtk_widget_activate(get_widget(self));
    return self;
}

static VALUE
widget_grab_focus(self)
    VALUE self;
{
    gtk_widget_grab_focus(get_widget(self));
    return self;
}

static VALUE
widget_grab_default(self)
    VALUE self;
{
    gtk_widget_grab_default(get_widget(self));
    return self;
}

static VALUE
widget_restore_state(self)
    VALUE self;
{
    gtk_widget_restore_state(get_widget(self));
    return self;
}

static VALUE
widget_visible(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    
    if (GTK_WIDGET_VISIBLE(widget))
	return TRUE;
    return FALSE;
}

static VALUE
widget_reparent(self, parent)
    VALUE self, parent;
{
    gtk_widget_reparent(get_widget(self), get_widget(parent));
    return self;
}

static VALUE
widget_popup(self, x, y)
    VALUE self, x, y;
{
    gtk_widget_popup(get_widget(self), NUM2INT(x), NUM2INT(y));
    return self;
}

static VALUE
widget_intersect(self, area, intersect)
    VALUE self, area, intersect;
{
    int n = gtk_widget_intersect(get_widget(self),
				 get_gdkrectangle(area),
				 get_gdkrectangle(intersect));
    return NUM2INT(n);
}

static VALUE
widget_basic(self)
    VALUE self;
{
    int n = gtk_widget_basic(get_widget(self));
    return NUM2INT(n);
}

static VALUE
widget_set_state(self, state)
    VALUE self, state;
{
    gtk_widget_set_state(get_widget(self), (GtkStateType)NUM2INT(state));
    return self;
}

static VALUE
widget_set_style(self, style)
    VALUE self, style;
{
    gtk_widget_set_style(get_widget(self),
			 get_gstyle(style));
    return self;
}

static VALUE
widget_set_parent(self, parent)
    VALUE self, parent;
{
    gtk_widget_set_parent(get_widget(self), get_widget(parent));
    return self;
}

static VALUE
widget_set_name(self, name)
    VALUE self, name;
{
    gtk_widget_set_name(get_widget(self), get_cstring(name));
    return self;
}

static VALUE
widget_get_name(self)
    VALUE self;
{
    char *name = gtk_widget_get_name(get_widget(self));
    
    return str_new2(name);
}

static VALUE
widget_set_sensitive(self, sensitive)
    VALUE self, sensitive;
{
    gtk_widget_set_sensitive(get_widget(self), RTEST(sensitive));
    return self;
}

static VALUE
widget_set_uposition(self, x, y)
    VALUE self, x, y;
{
    gtk_widget_set_uposition(get_widget(self), NUM2INT(x), NUM2INT(y));
    return self;
}

static VALUE
widget_set_usize(self, w, h)
    VALUE self, w, h;
{
    gtk_widget_set_usize(get_widget(self), NUM2INT(w), NUM2INT(h));
    return self;
}

static VALUE
widget_set_events(self, events)
    VALUE self, events;
{
    gtk_widget_set_events(get_widget(self), NUM2INT(events));
    return self;
}

static VALUE
widget_set_eevents(self, mode)
    VALUE self, mode;
{
    gtk_widget_set_extension_events(get_widget(self),
				    (GdkExtensionMode)NUM2INT(mode));
    return self;
}

static VALUE
widget_unparent(self)
    VALUE self;
{
    gtk_widget_unparent(get_widget(self));
    return self;
}

static VALUE
widget_window(self)
    VALUE self;
{
    return make_gdkwindow(get_widget(self)->window);
}

static VALUE
widget_get_toplevel(self)
    VALUE self;
{
    return get_value_from_gobject(gtk_widget_get_toplevel(get_widget(self)));
}

static VALUE
widget_get_ancestor(self, type)
    VALUE self, type;
{
    GtkWidget *widget = get_widget(self);
#if 0
    if (obj_is_kind_of(type, cClass)) {
    }
#endif
    widget = gtk_widget_get_ancestor(widget, NUM2INT(type));

    return get_value_from_gobject(widget);
}

static VALUE
widget_get_colormap(self)
    VALUE self;
{
    GdkColormap *cmap = gtk_widget_get_colormap(get_widget(self));

    return make_gdkcmap(cmap);
}

static VALUE
widget_get_visual(self)
    VALUE self;
{
    GdkVisual *v = gtk_widget_get_visual(get_widget(self));

    return make_gdkvisual(v);
}

static VALUE
widget_get_style(self)
    VALUE self;
{
    GtkStyle *s = gtk_widget_get_style(get_widget(self));

    return make_gstyle(s);
}

static VALUE
widget_get_pointer(self)
    VALUE self;
{
    int x, y;

    gtk_widget_get_pointer(get_widget(self), &x, &y);
    return assoc_new(INT2FIX(x), INT2FIX(y));
}

static VALUE
widget_is_ancestor(self, ancestor)
    VALUE self, ancestor;
{
    if (gtk_widget_is_ancestor(get_widget(self), get_widget(ancestor))) {
	return TRUE;
    }
    return FALSE;
}

static VALUE
widget_is_child(self, child)
    VALUE self, child;
{
    if (gtk_widget_is_child(get_widget(self), get_widget(child))) {
	return TRUE;
    }
    return FALSE;
}

static VALUE
widget_get_events(self)
    VALUE self;
{
    int n = gtk_widget_get_events(get_widget(self));
    return NUM2INT(n);
}

static VALUE
widget_get_eevents(self)
    VALUE self;
{
    GdkExtensionMode m;
    m = gtk_widget_get_extension_events(get_widget(self));
    return NUM2INT((int)m);
}

static VALUE
widget_push_cmap(self, cmap)
    VALUE self, cmap;
{
    gtk_widget_push_colormap(get_gdkcmap(cmap));
    return Qnil;
}

static VALUE
widget_push_visual(self, visual)
    VALUE self, visual;
{
    gtk_widget_push_visual(get_gdkvisual(visual));
    return make_gdkcmap(visual);
}

static VALUE
widget_push_style(self, style)
    VALUE self, style;
{
    gtk_widget_push_style(get_gstyle(style));
    return Qnil;
}

static VALUE
widget_pop_cmap(self, cmap)
    VALUE self, cmap;
{
    gtk_widget_pop_colormap();
    return Qnil;
}

static VALUE
widget_pop_visual(self, visual)
    VALUE self, visual;
{
    gtk_widget_pop_visual();
    return Qnil;
}

static VALUE
widget_pop_style(self, style)
    VALUE self, style;
{
    gtk_widget_pop_style();
    return Qnil;
}

static VALUE
widget_set_default_cmap(self, cmap)
    VALUE self, cmap;
{
    gtk_widget_set_default_colormap(get_gdkcmap(cmap));
    return Qnil;
}

static VALUE
widget_set_default_visual(self, visual)
    VALUE self, visual;
{
    gtk_widget_set_default_visual(get_gdkvisual(visual));
    return make_gdkcmap(visual);
}

static VALUE
widget_set_default_style(self, style)
    VALUE self, style;
{
    gtk_widget_set_default_style(get_gstyle(style));
    return Qnil;
}

static VALUE
widget_get_default_cmap(self)
    VALUE self;
{
    GdkColormap *cmap = gtk_widget_get_default_colormap();

    return make_gdkcmap(cmap);
}

static VALUE
widget_get_default_visual(self)
    VALUE self;
{
    GdkVisual *v = gtk_widget_get_default_visual();

    return make_gdkvisual(v);
}

static VALUE
widget_get_default_style(self)
    VALUE self;
{
    GtkStyle *s = gtk_widget_get_default_style();

    return make_gstyle(s);
}

static VALUE
widget_propagate_default_style(self)
    VALUE self;
{
    gtk_widget_propagate_default_style();
    return Qnil;
}

static VALUE
bbox_get_child_size_default(self)
    VALUE self;
{
    int min_width, max_width;

    gtk_button_box_get_child_size_default(&min_width, &max_width);

    return assoc_new(INT2FIX(min_width), INT2FIX(max_width));
}

static VALUE
bbox_get_child_ipadding_default(self)
    VALUE self;
{
    int ipad_x, ipad_y;

    gtk_button_box_get_child_ipadding_default(&ipad_x, &ipad_y);
    return assoc_new(INT2FIX(ipad_x), INT2FIX(ipad_y));
}

static VALUE
bbox_set_child_size_default(self, min_width, max_width)
    VALUE self, min_width, max_width;
{
    gtk_button_box_set_child_size_default(NUM2INT(min_width),
					  NUM2INT(max_width));
    return Qnil;
}

static VALUE
bbox_set_child_ipadding_default(self, ipad_x, ipad_y)
    VALUE self, ipad_x, ipad_y;
{
    gtk_button_box_set_child_ipadding_default(NUM2INT(ipad_x),
					      NUM2INT(ipad_y));
    return Qnil;
}

static VALUE
bbox_get_spacing(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    int n = gtk_button_box_get_spacing(GTK_BUTTON_BOX(widget));

    return INT2FIX(n);
}

static VALUE
bbox_get_layout(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    int n = gtk_button_box_get_layout(GTK_BUTTON_BOX(widget));

    return INT2FIX(n);
}

static VALUE
bbox_get_child_size(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    int min_width, max_width;

    gtk_button_box_get_child_size(GTK_BUTTON_BOX(widget),
				  &min_width, &max_width);
    return assoc_new(INT2FIX(min_width), INT2FIX(max_width));
}

static VALUE
bbox_get_child_ipadding(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    int ipad_x, ipad_y;

    gtk_button_box_get_child_ipadding(GTK_BUTTON_BOX(widget),
				      &ipad_x, &ipad_y);
    return assoc_new(INT2FIX(ipad_x), INT2FIX(ipad_y));
}

static VALUE
bbox_set_spacing(self, spacing)
    VALUE self, spacing;
{
    GtkWidget *widget = get_widget(self);

    gtk_button_box_set_spacing(GTK_BUTTON_BOX(widget),
			       NUM2INT(spacing));
    return self;
}

static VALUE
bbox_set_layout(self, layout)
    VALUE self, layout;
{
    GtkWidget *widget = get_widget(self);

    gtk_button_box_set_layout(GTK_BUTTON_BOX(widget),
			      NUM2INT(layout));
    return self;
}

static VALUE
bbox_set_child_size(self, min_width, max_width)
    VALUE self, min_width, max_width;
{
    GtkWidget *widget = get_widget(self);

    gtk_button_box_set_child_size(GTK_BUTTON_BOX(widget),
				  NUM2INT(min_width),
				  NUM2INT(max_width));
    return self;
}

static VALUE
bbox_set_child_ipadding(self, ipad_x, ipad_y)
    VALUE self, ipad_x, ipad_y;
{
    GtkWidget *widget = get_widget(self);

    gtk_button_box_set_child_ipadding(GTK_BUTTON_BOX(widget),
				      NUM2INT(ipad_x),
				      NUM2INT(ipad_y));
    return self;
}

static VALUE
clist_s_new(self, titles)
    VALUE self, titles;
{
    char **buf;
    int i, len;

    Check_Type(titles, T_ARRAY);
    len = RARRAY(titles)->len;
    buf = ALLOCA_N(char*, len);
    for (i=0; i<len; i++) {
	Check_Type(RARRAY(titles)->ptr[i], T_STRING);
	buf[i] = RSTRING(RARRAY(titles)->ptr[i])->ptr;
    }
    return make_widget(self, gtk_clist_new(len, buf));
}

static VALUE
clist_set_border(self, border)
    VALUE self, border;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_border(GTK_CLIST(widget), (GtkShadowType)NUM2INT(border));
    return self;
}

static VALUE
clist_set_sel_mode(self, mode)
    VALUE self, mode;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_selection_mode(GTK_CLIST(widget),
				 (GtkSelectionMode)NUM2INT(mode));
    return self;
}

static VALUE
clist_set_policy(self, vpolicy, hpolicy)
    VALUE self, vpolicy, hpolicy;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_policy(GTK_CLIST(widget),
			 (GtkPolicyType)NUM2INT(vpolicy),
			 (GtkPolicyType)NUM2INT(hpolicy));
    return self;
}

static VALUE
clist_freeze(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_freeze(GTK_CLIST(widget));
    return self;
}

static VALUE
clist_thaw(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_thaw(GTK_CLIST(widget));
    return self;
}

static VALUE
clist_set_col_title(self, col, title)
    VALUE self, col, title;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_column_title(GTK_CLIST(widget),
			       NUM2INT(col),
			       get_cstring(title));
    return self;
}

static VALUE
clist_set_col_wigdet(self, col, win)
    VALUE self, col, win;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_column_widget(GTK_CLIST(widget),
				NUM2INT(col),
				get_widget(win));
    return self;
}

static VALUE
clist_set_col_just(self, col, just)
    VALUE self, col, just;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_column_justification(GTK_CLIST(widget),
				       NUM2INT(col),
				       (GtkJustification)NUM2INT(just));
    return self;
}

static VALUE
clist_set_col_width(self, col, width)
    VALUE self, col, width;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_column_width(GTK_CLIST(widget),
			       NUM2INT(col), NUM2INT(width));
    return self;
}

static VALUE
clist_set_row_height(self, height)
    VALUE self, height;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_row_height(GTK_CLIST(widget), NUM2INT(height));
    return self;
}

static VALUE
clist_moveto(self, row, col, row_align, col_align)
    VALUE self, row, col, row_align, col_align;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_moveto(GTK_CLIST(widget),
		     NUM2INT(row), NUM2INT(col),
		     NUM2INT(row_align), NUM2INT(col_align));
    return self;
}

static VALUE
clist_set_text(self, row, col, text)
    VALUE self, row, col, text;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_text(GTK_CLIST(widget),
		       NUM2INT(row), NUM2INT(col),
		       get_cstring(text));
    return self;
}

static VALUE
clist_set_pixmap(self, row, col, pixmap, mask)
    VALUE self, row, col, pixmap, mask;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_pixmap(GTK_CLIST(widget),
			 NUM2INT(row), NUM2INT(col),
			 get_gdkpixmap(pixmap),
			 (GdkBitmap*)get_gdkpixmap(mask));
    return self;
}

static VALUE
clist_set_pixtext(self, row, col, text, spacing, pixmap, mask)
    VALUE self, row, col, text, spacing, pixmap, mask;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_pixtext(GTK_CLIST(widget),
			  NUM2INT(row), NUM2INT(col),
			  get_cstring(text),
			  NUM2INT(spacing),
			  get_gdkpixmap(pixmap),
			 (GdkBitmap*)get_gdkpixmap(mask));
    return self;
}

static VALUE
clist_set_foreground(self, row, color)
    VALUE self, row, color;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_foreground(GTK_CLIST(widget),
			     NUM2INT(row), get_gdkcolor(color));
    return self;
}

static VALUE
clist_set_background(self, row, color)
    VALUE self, row, color;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_background(GTK_CLIST(widget),
			     NUM2INT(row), get_gdkcolor(color));
    return self;
}

static VALUE
clist_set_shift(self, row, col, verticle, horizontal)
    VALUE self, row, col, verticle, horizontal;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_set_shift(GTK_CLIST(widget),
			NUM2INT(row), NUM2INT(col),
			NUM2INT(verticle), NUM2INT(horizontal));
    return self;
}

static VALUE
clist_append(self, text)
    VALUE self, text;
{
    GtkWidget *widget = get_widget(self);
    char **buf;
    int i, len;

    Check_Type(text, T_ARRAY);
    len = GTK_CLIST(widget)->columns;
    if (len > RARRAY(text)->len) {
	ArgError("text too short");
    }
    buf = ALLOCA_N(char*, len);
    for (i=0; i<len; i++) {
	Check_Type(RARRAY(text)->ptr[i], T_STRING);
	buf[i] = RSTRING(RARRAY(text)->ptr[i])->ptr;
    }
    i = gtk_clist_append(GTK_CLIST(widget), buf);
    return INT2FIX(i);
}

static VALUE
clist_insert(self, row, text)
    VALUE self, row, text;
{
    GtkWidget *widget = get_widget(self);
    char **buf;
    int i, len;

    Check_Type(text, T_ARRAY);
    len = GTK_CLIST(widget)->columns;
    if (len > RARRAY(text)->len) {
	ArgError("text too short");
    }
    buf = ALLOCA_N(char*, len);
    for (i=0; i<len; i++) {
	Check_Type(RARRAY(text)->ptr[i], T_STRING);
	buf[i] = RSTRING(RARRAY(text)->ptr[i])->ptr;
    }
    gtk_clist_insert(GTK_CLIST(widget), NUM2INT(row), buf);
    return self;
}

static VALUE
clist_remove(self, row)
    VALUE self, row;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_remove(GTK_CLIST(widget), NUM2INT(row));
    return self;
}

static VALUE
clist_set_row_data(self, row, data)
    VALUE self, row, data;
{
    GtkWidget *widget = get_widget(self);

    add_relative(self, data);
    gtk_clist_set_row_data(GTK_CLIST(widget), NUM2INT(row), (gpointer)data);
    return self;
}

static VALUE
clist_get_row_data(self, row)
    VALUE self, row;
{
    GtkWidget *widget = get_widget(self);

    return (VALUE)gtk_clist_get_row_data(GTK_CLIST(widget), NUM2INT(row));
}

static VALUE
clist_select_row(self, row, col)
    VALUE self, row, col;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_select_row(GTK_CLIST(widget), NUM2INT(row), NUM2INT(col));
    return self;
}

static VALUE
clist_unselect_row(self, row, col)
    VALUE self, row, col;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_unselect_row(GTK_CLIST(widget), NUM2INT(row), NUM2INT(col));
    return self;
}

static VALUE
clist_clear(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_clear(GTK_CLIST(widget));
    return self;
}

static VALUE
gwin_s_new(self, type)
    VALUE self, type;
{
    return make_widget(self, gtk_window_new(NUM2INT(type)));
}

static VALUE
gwin_set_policy(self, shrink, grow, auto_shrink)
    VALUE self, shrink, grow, auto_shrink;
{
    GtkWidget *widget = get_widget(self);

    gtk_window_set_policy(GTK_WINDOW(widget),
			  RTEST(shrink), RTEST(grow), RTEST(auto_shrink));
    return self;
}

static VALUE
gwin_set_title(self, title)
    VALUE self, title;
{
    GtkWidget *widget = get_widget(self);

    gtk_window_set_title(GTK_WINDOW(widget), get_cstring(title));
    return self;
}

static VALUE
gwin_position(self, pos)
    VALUE self, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_window_position(GTK_WINDOW(widget),
			(GtkWindowPosition)NUM2INT(pos));

    return self;
}

static VALUE
gwin_set_wmclass(self, wmclass1, wmclass2)
    VALUE self, wmclass1, wmclass2;
{
    GtkWidget *widget = get_widget(self);

    gtk_window_set_wmclass(GTK_WINDOW(widget),
			   get_cstring(wmclass1),
			   get_cstring(wmclass2));
    return self;
}

static VALUE
gwin_set_focus(self, win)
    VALUE self, win;
{
    GtkWidget *widget = get_widget(self);

    gtk_window_set_focus(GTK_WINDOW(widget), get_widget(win));
    return self;
}

static VALUE
gwin_set_default(self, win)
    VALUE self, win;
{
    GtkWidget *widget = get_widget(self);

    gtk_window_set_default(GTK_WINDOW(widget), get_widget(win));
    return self;
}

static VALUE
gwin_add_accel(self, accel)
    VALUE self, accel;
{
    GtkWidget *widget = get_widget(self);

    gtk_window_add_accelerator_table(GTK_WINDOW(widget),
				     get_gtkacceltbl(accel));
    return self;
}

static VALUE
gwin_rm_accel(self, accel)
    VALUE self, accel;
{
    GtkWidget *widget = get_widget(self);

    gtk_window_remove_accelerator_table(GTK_WINDOW(widget),
					get_gtkacceltbl(accel));
    return self;
}

static VALUE
dialog_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_dialog_new());
}

static VALUE
fsel_s_new(self, title)
    VALUE self, title;
{
    return make_widget(self, gtk_file_selection_new(get_cstring(title)));
}

static VALUE
fsel_set_fname(self, fname)
    VALUE self, fname;
{
    GtkWidget *widget = get_widget(self);
    
    Check_Type(fname, T_STRING);
    gtk_file_selection_set_filename(GTK_FILE_SELECTION(widget),
				    RSTRING(fname)->ptr);

    return self;
}

static VALUE
fsel_get_fname(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    gchar *fname;

    fname = gtk_file_selection_get_filename(GTK_FILE_SELECTION(widget));

    return str_new2(fname);
}

static VALUE
fsel_ok_button(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    VALUE b = rb_iv_get(self, "ok_button");

    if (NIL_P(b)) {
	GtkWidget *w = GTK_FILE_SELECTION(widget)->ok_button;
	b = make_widget(gButton, w);
	rb_iv_set(self, "ok_button", b);
    }

    return b;
}

static VALUE
fsel_cancel_button(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    VALUE b = rb_iv_get(self, "cancel_button");

    if (NIL_P(b)) {
	GtkWidget *w = GTK_FILE_SELECTION(widget)->cancel_button;
	b = make_widget(gButton, w);
	rb_iv_set(self, "cancel_button", b);
    }

    return b;
}

static VALUE
fsel_help_button(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    VALUE b = rb_iv_get(self, "help_button");

    if (NIL_P(b)) {
	GtkWidget *w = GTK_FILE_SELECTION(widget)->help_button;
	b = make_widget(gButton, w);
	rb_iv_set(self, "help_button", b);
    }

    return b;
}

static VALUE
label_s_new(self, label)
    VALUE self, label;
{
    return make_widget(self, gtk_label_new(get_cstring(label)));
}

static VALUE
list_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_list_new());
}

static VALUE
list_set_sel_mode(self, mode)
    VALUE self, mode;
{
    GtkWidget *widget = get_widget(self);

    gtk_list_set_selection_mode(GTK_LIST(widget),
				(GtkSelectionMode)NUM2INT(mode));
    return self;
}

static VALUE
list_sel_mode(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    return INT2FIX(GTK_LIST(widget)->selection_mode);
}

static VALUE
list_selection(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    return glist2ary(GTK_LIST(widget)->selection);
}

static VALUE
list_insert_items(self, items, pos)
    VALUE self, items, pos;
{
    GtkWidget *widget = get_widget(self);
    GList *glist;

    glist = ary2glist(items);

    gtk_list_insert_items(GTK_LIST(widget), glist, NUM2INT(pos));
    g_list_free(glist);

    return self;
}

static VALUE
list_append_items(self, items)
    VALUE self, items;
{
    GtkWidget *widget = get_widget(self);
    GList *glist;

    glist = ary2glist(items);

    gtk_list_append_items(GTK_LIST(widget), glist);
    g_list_free(glist);

    return self;
}

static VALUE
list_prepend_items(self, items)
    VALUE self, items;
{
    GtkWidget *widget = get_widget(self);
    GList *glist;

    glist = ary2glist(items);
    gtk_list_prepend_items(GTK_LIST(widget), glist);
    g_list_free(glist);

    return self;
}

static VALUE
list_remove_items(self, items)
    VALUE self, items;
{
    GtkWidget *widget = get_widget(self);
    GList *glist;

    glist = ary2glist(items);
    gtk_list_remove_items(GTK_LIST(widget), glist);
    g_list_free(glist);

    return self;
}

static VALUE
list_clear_items(self, start, end)
    VALUE self, start, end;
{
    GtkWidget *widget = get_widget(self);

    gtk_list_clear_items(GTK_LIST(widget), NUM2INT(start), NUM2INT(end));
    return self;
}

static VALUE
list_select_item(self, pos)
    VALUE self, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_list_select_item(GTK_LIST(widget), NUM2INT(pos));
    return self;
}

static VALUE
list_unselect_item(self, pos)
    VALUE self, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_list_unselect_item(GTK_LIST(widget), NUM2INT(pos));
    return self;
}

static VALUE
list_select_child(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_list_select_child(GTK_LIST(widget), get_widget(child));
    return self;
}

static VALUE
list_unselect_child(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_list_unselect_child(GTK_LIST(widget), get_widget(child));
    return self;
}

static VALUE
list_child_position(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);
    gint pos;

    pos = gtk_list_child_position(GTK_LIST(widget), get_widget(child));
    return INT2FIX(pos);
}

static VALUE
item_select(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_item_select(GTK_ITEM(widget));
    return self;
}

static VALUE
item_deselect(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_item_deselect(GTK_ITEM(widget));
    return self;
}

static VALUE
item_toggle(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_item_toggle(GTK_ITEM(widget));
    return self;
}

static VALUE
litem_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE label;
    GtkWidget *widget;

    if (rb_scan_args(argc, argv, "01", &label) == 1) {
	widget = gtk_list_item_new_with_label(get_cstring(label));
    }
    else {
	widget = gtk_list_item_new();
    }

    return make_widget(self, widget);
}

static VALUE
mshell_append(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_shell_append(GTK_MENU_SHELL(widget), get_widget(child));
    return self;
}

static VALUE
mshell_prepend(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_shell_prepend(GTK_MENU_SHELL(widget), get_widget(child));
    return self;
}

static VALUE
mshell_insert(self, child, pos)
    VALUE self, child, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_shell_insert(GTK_MENU_SHELL(widget), get_widget(child),
			  NUM2INT(pos));
    return self;
}

static VALUE
mshell_deactivate(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_shell_deactivate(GTK_MENU_SHELL(widget));
    return self;
}

static VALUE
menu_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_menu_new());
}

static VALUE
menu_append(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_append(GTK_MENU(widget), get_widget(child));
    return self;
}

static VALUE
menu_prepend(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_prepend(GTK_MENU(widget), get_widget(child));
    return self;
}

static VALUE
menu_insert(self, child, pos)
    VALUE self, child, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_insert(GTK_MENU(widget), get_widget(child), NUM2INT(pos));
    return self;
}

static void
menu_pos_func(menu, x, y, data)
    GtkMenu *menu;
    gint x, y;
    gpointer data;
{
    VALUE m = get_value_from_gobject(GTK_OBJECT(menu));

    rb_funcall((VALUE)data, 3, m, INT2FIX(x), INT2FIX(y));
}

static VALUE
menu_popup(self, pshell, pitem, func, button, activate_time)
    VALUE self, pshell, pitem, func, button, activate_time;
{
    GtkWidget *widget = get_widget(self);
    GtkMenuPositionFunc pfunc = NULL;
    gpointer data = NULL;

    if (!NIL_P(func)) {
	pfunc = menu_pos_func;
	data = (gpointer)func;
	add_relative(self, func);
    }
    gtk_menu_popup(GTK_MENU(widget),
		   get_widget(pshell), get_widget(pitem),
		   pfunc,
		   data,
		   NUM2INT(button),
		   NUM2INT(activate_time));
    return self;
}

static VALUE
menu_popdown(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_popdown(GTK_MENU(widget));
    return self;
}

static VALUE
menu_get_active(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    GtkWidget *mitem = gtk_menu_get_active(GTK_MENU(widget));

    return make_widget(gMenuItem, mitem);
}

static VALUE
menu_set_active(self, active)
    VALUE self, active;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_set_active(GTK_MENU(widget), NUM2INT(active));
    return self;
}

static VALUE
menu_set_acceltbl(self, table)
    VALUE self, table;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_set_accelerator_table(GTK_MENU(widget),
				   get_gtkacceltbl(table));
    return self;
}

static VALUE
mbar_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_menu_bar_new());
}

static VALUE
mbar_append(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_bar_append(GTK_MENU_BAR(widget), get_widget(child));
    return self;
}

static VALUE
mbar_prepend(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_bar_prepend(GTK_MENU_BAR(widget), get_widget(child));
    return self;
}
static VALUE
mbar_insert(self, child, pos)
    VALUE self, child, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_bar_insert(GTK_MENU_BAR(widget),
			get_widget(child), NUM2INT(pos));
    return self;
}

static VALUE
mitem_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
{
    VALUE label;
    GtkWidget *widget;

    if (rb_scan_args(argc, argv, "01", &label) == 1) {
	widget = gtk_menu_item_new_with_label(get_cstring(label));
    }
    else {
	widget = gtk_menu_item_new();
    }

    return make_widget(self, widget);
}

static VALUE
mitem_set_submenu(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_item_set_submenu(GTK_MENU_ITEM(widget), get_widget(child));
    return self;
}

static VALUE
mitem_set_placement(self, place)
    VALUE self, place;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_item_set_placement(GTK_MENU_ITEM(widget), 
				(GtkSubmenuPlacement)NUM2INT(place));
    return self;
}

static VALUE
mitem_accelerator_size(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_item_accelerator_size(GTK_MENU_ITEM(widget));
    return self;
}

static VALUE
mitem_accelerator_text(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    char buf[1024];		/* enough? */

    gtk_menu_item_accelerator_text(GTK_MENU_ITEM(widget), buf);
    return str_new2(buf);
}

static VALUE
mitem_configure(self, show_toggle, show_submenu)
    VALUE self, show_toggle, show_submenu;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_item_configure(GTK_MENU_ITEM(widget), 
			    NUM2INT(show_toggle),
			    NUM2INT(show_submenu));
    return self;
}

static VALUE
mitem_select(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_item_select(GTK_MENU_ITEM(widget));
    return self;
}

static VALUE
mitem_deselect(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_item_deselect(GTK_MENU_ITEM(widget));
    return self;
}

static VALUE
mitem_activate(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_item_activate(GTK_MENU_ITEM(widget));
    return self;
}

static VALUE
mitem_right_justify(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_menu_item_right_justify(GTK_MENU_ITEM(widget));
    return self;
}

static VALUE
cmitem_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
{
    VALUE label;
    GtkWidget *widget;

    if (rb_scan_args(argc, argv, "01", &label) == 1) {
	widget = gtk_check_menu_item_new_with_label(get_cstring(label));
    }
    else {
	widget = gtk_check_menu_item_new();
    }

    return make_widget(self, widget);
}

static VALUE
cmitem_set_state(self, state)
    VALUE self, state;
{
    GtkWidget *widget = get_widget(self);

    gtk_check_menu_item_set_state(GTK_CHECK_MENU_ITEM(widget), 
				  NUM2INT(state));
    return self;
}

static VALUE
cmitem_set_show_toggle(self, always)
    VALUE self, always;
{
    GtkWidget *widget = get_widget(self);

    gtk_check_menu_item_set_show_toggle(GTK_CHECK_MENU_ITEM(widget), 
					(gboolean)RTEST(always));
    return self;
}

static VALUE
cmitem_toggled(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_check_menu_item_toggled(GTK_CHECK_MENU_ITEM(widget));
    return self;
}

static VALUE
rmitem_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
{
    VALUE arg1, arg2;
    GtkWidget *widget;
    GSList *list = NULL;
    char *label = NULL;
    
    if (rb_scan_args(argc, argv, "02", &arg1, &arg2) == 1 &&
	TYPE(arg1) == T_STRING) {
	label = RSTRING(arg1)->ptr;
    }
    else {
	if (!NIL_P(arg2)) {
	    Check_Type(arg2, T_STRING);
	    label = RSTRING(arg2)->ptr;
	}
	if (obj_is_kind_of(arg1, gRMenuItem)) {
	    GtkWidget *b = get_widget(arg1);
	    list = GTK_RADIO_MENU_ITEM(b)->group;
	}
	else {
	    list = ary2gslist(arg1);
	}
    }
    if (label) {
	widget = gtk_radio_menu_item_new_with_label(list, label);
    }
    else {
	widget = gtk_radio_menu_item_new(list);
    }
    return make_widget(self, widget);
}

static VALUE
rmitem_group(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    
    return gslist2ary(gtk_radio_menu_item_group(GTK_RADIO_MENU_ITEM(widget)));
}

static VALUE
note_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_notebook_new());
}

static VALUE
note_append_page(self, child, label)
    VALUE self, child, label;
{
    GtkWidget *widget = get_widget(self);

    gtk_notebook_append_page(GTK_NOTEBOOK(widget),
			     get_widget(child),
			     get_widget(label));
    return self;
}

static VALUE
note_prepend_page(self, child, label)
    VALUE self, child, label;
{
    GtkWidget *widget = get_widget(self);

    gtk_notebook_prepend_page(GTK_NOTEBOOK(widget),
			      get_widget(child),
			      get_widget(label));
    return self;
}

static VALUE
note_insert_page(self, child, label, pos)
    VALUE self, child, label, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_notebook_insert_page(GTK_NOTEBOOK(widget),
			     get_widget(child),
			     get_widget(label),
			     NUM2INT(pos));
    return self;
}

static VALUE
note_remove_page(self, pos)
    VALUE self, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_notebook_remove_page(GTK_NOTEBOOK(widget), NUM2INT(pos));
    return self;
}

static VALUE
note_set_page(self, pos)
    VALUE self, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_notebook_set_page(GTK_NOTEBOOK(widget), NUM2INT(pos));
    return self;
}

static VALUE
note_cur_page(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    return INT2FIX(GTK_NOTEBOOK(widget)->cur_page);
}

static VALUE
note_next_page(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_notebook_next_page(GTK_NOTEBOOK(widget));
    return self;
}

static VALUE
note_prev_page(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_notebook_prev_page(GTK_NOTEBOOK(widget));
    return self;
}

static VALUE
note_set_tab_pos(self, pos)
    VALUE self, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_notebook_set_tab_pos(GTK_NOTEBOOK(widget), NUM2INT(pos));
    return self;
}

static VALUE
note_tab_pos(self, pos)
    VALUE self, pos;
{
    GtkWidget *widget = get_widget(self);

    return INT2FIX(GTK_NOTEBOOK(widget)->tab_pos);
}

static VALUE
note_set_show_tabs(self, show_tabs)
    VALUE self, show_tabs;
{
    GtkWidget *widget = get_widget(self);

    gtk_notebook_set_tab_pos(GTK_NOTEBOOK(widget), RTEST(show_tabs));
    return self;
}

static VALUE
note_show_tabs(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    return GTK_NOTEBOOK(widget)->show_tabs?TRUE:FALSE;
}

static VALUE
note_set_show_border(self, show_border)
    VALUE self, show_border;
{
    GtkWidget *widget = get_widget(self);

    gtk_notebook_set_tab_pos(GTK_NOTEBOOK(widget), RTEST(show_border));
    return self;
}

static VALUE
note_show_border(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    return GTK_NOTEBOOK(widget)->show_border?TRUE:FALSE;
}

static VALUE
omenu_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_option_menu_new());
}

static VALUE
omenu_set_menu(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    rb_iv_set(self, "option_menu", child);
    gtk_option_menu_set_menu(GTK_OPTION_MENU(widget), get_widget(child));
    return self;
}

static VALUE
omenu_get_menu(self)
    VALUE self;
{
    return rb_iv_get(self, "option_menu");
}

static VALUE
omenu_remove_menu(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_option_menu_remove_menu(GTK_OPTION_MENU(widget));
    return self;
}

static VALUE
omenu_set_history(self, index)
    VALUE self, index;
{
    GtkWidget *widget = get_widget(self);

    gtk_option_menu_set_history(GTK_OPTION_MENU(widget), NUM2INT(index));
    return self;
}

static VALUE
image_s_new(self, val, mask)
    VALUE self, val, mask;
{
    return make_widget(self, gtk_image_new(get_gdkimage(val),
					   (GdkBitmap*)get_gdkpixmap(mask)));
}

static VALUE
image_set(self, val, mask)
    VALUE self, val, mask;
{
    GtkWidget *widget = get_widget(self);

    gtk_image_set(GTK_IMAGE(widget), get_gdkimage(val), get_gdkpixmap(mask));
    return self;
}

static VALUE
image_get(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    GdkImage  *val;
    GdkBitmap *mask;

    gtk_image_get(GTK_IMAGE(widget), &val, &mask);

    return assoc_new(make_gdkimage(self, val),
		     make_gdkpixmap(self, mask));
}

static VALUE
preview_s_new(self, type)
    VALUE self, type;
{
    return make_widget(self, gtk_preview_new((GtkPreviewType)NUM2INT(type)));
}


static VALUE
preview_size(self, w, h)
    VALUE self, w, h;
{
    GtkWidget *widget = get_widget(self);

    gtk_preview_size(GTK_PREVIEW(widget), NUM2INT(w), NUM2INT(h));
    return self;
}

#if 0
    rb_define_method(gPixmap, "put", preview_size, 8);
    rb_define_method(gPixmap, "put_row", preview_size, 5);
    rb_define_method(gPixmap, "draw_row", preview_size, 4);
#endif

static VALUE
preview_set_expand(self, expand)
    VALUE self, expand;
{
    GtkWidget *widget = get_widget(self);

    gtk_preview_set_expand(GTK_PREVIEW(widget), NUM2INT(expand));
    return self;
}

static VALUE
preview_set_gamma(self, gamma)
    VALUE self, gamma;
{
    gtk_preview_set_gamma(NUM2DBL(gamma));
    return Qnil;
}

static VALUE
preview_set_color_cube(self, nred, ngreen, nblue, ngray)
    VALUE self, nred, ngreen, nblue, ngray;
{
    gtk_preview_set_color_cube(NUM2INT(nred),
			       NUM2INT(ngreen),
			       NUM2INT(nblue),
			       NUM2INT(ngray));
    return Qnil;
}

static VALUE
preview_set_install_cmap(self, cmap)
    VALUE self, cmap;
{
    gtk_preview_set_install_cmap(NUM2INT(cmap));
    return Qnil;
}

static VALUE
preview_set_reserved(self, nreserved)
    VALUE self, nreserved;
{
    gtk_preview_set_reserved(NUM2INT(nreserved));
    return Qnil;
}

static VALUE
preview_get_visual(self)
    VALUE self;
{
    GdkVisual *v = gtk_preview_get_visual();
    return make_gdkvisual(v);
}

static VALUE
preview_get_cmap(self)
    VALUE self;
{
    GdkColormap *c = gtk_preview_get_cmap();
    return make_gdkcmap(c);
}

static VALUE
preview_get_info(self)
    VALUE self;
{
    GtkPreviewInfo *i = gtk_preview_get_info();
    return make_gtkprevinfo(i);
}

static VALUE
pbar_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_progress_bar_new());
}

static VALUE
pbar_update(self, percentage)
    VALUE self, percentage;
{
    GtkWidget *widget = get_widget(self);

    gtk_progress_bar_update(GTK_PROGRESS_BAR(widget),
			    NUM2DBL(percentage));
    return self;
}    

static VALUE
scwin_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE arg1, arg2;
    GtkAdjustment *h_adj = NULL;
    GtkAdjustment *v_adj = NULL;

    rb_scan_args(argc, argv, "02", &arg1, &arg2);
    if (!NIL_P(arg1)) h_adj = (GtkAdjustment*)get_gobject(arg1);
    if (!NIL_P(arg2)) v_adj = (GtkAdjustment*)get_gobject(arg2);

    return make_widget(self, gtk_scrolled_window_new(h_adj, v_adj));
}

static VALUE
scwin_set_policy(self, hpolicy, vpolicy)
    VALUE self, hpolicy, vpolicy;
{
    GtkWidget *widget = get_widget(self);

    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(widget),
				   (GtkPolicyType)NUM2INT(hpolicy),
				   (GtkPolicyType)NUM2INT(vpolicy));
    return self;
}


static VALUE
tbl_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
{
    VALUE row, col, homogeneous;

    rb_scan_args(argc, argv, "21", &row, &col, &homogeneous);
    return make_widget(self, gtk_table_new(NUM2INT(row),
					   NUM2INT(col),
					   RTEST(homogeneous)));
}

static VALUE
tbl_attach(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    VALUE child, left, right, top, bottom;
    VALUE arg0, arg1, arg2, arg3;
    int xopt, yopt, xspc, yspc;

    xopt = yopt = GTK_EXPAND | GTK_FILL;
    xspc = yspc = 0;
    rb_scan_args(argc, argv, "54",
		 &child, &left, &right, &top, &bottom,
		 &arg0, &arg1, &arg2, &arg3);
    if (!NIL_P(arg0)) xopt = NUM2INT(arg0);
    if (!NIL_P(arg1)) yopt = NUM2INT(arg1);
    if (!NIL_P(arg2)) xspc = NUM2INT(arg2);
    if (!NIL_P(arg3)) yspc = NUM2INT(arg3);

    gtk_table_attach(GTK_TABLE(widget),
		     get_widget(child),
		     NUM2INT(left),NUM2INT(right),
		     NUM2INT(top),NUM2INT(bottom),
		     xopt, yopt, xspc, yspc);

    return self;
}

static VALUE
tbl_set_row_spacing(self, row, spc)
    VALUE self, row, spc;
{
    GtkWidget *widget = get_widget(self);

    gtk_table_set_row_spacing(GTK_TABLE(widget), NUM2INT(row), NUM2INT(spc));
    return self;
}

static VALUE
tbl_set_col_spacing(self, col, spc)
    VALUE self, col, spc;
{
    GtkWidget *widget = get_widget(self);

    gtk_table_set_col_spacing(GTK_TABLE(widget), NUM2INT(col), NUM2INT(spc));
    return self;
}

static VALUE
tbl_set_row_spacings(self, spc)
    VALUE self, spc;
{
    GtkWidget *widget = get_widget(self);

    gtk_table_set_row_spacings(GTK_TABLE(widget), NUM2INT(spc));
    return self;
}

static VALUE
tbl_set_col_spacings(self, spc)
    VALUE self, spc;
{
    GtkWidget *widget = get_widget(self);

    gtk_table_set_col_spacings(GTK_TABLE(widget), NUM2INT(spc));
    return self;
}

static VALUE
txt_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE arg1, arg2;
    GtkAdjustment *h_adj = NULL;
    GtkAdjustment *v_adj = NULL;

    rb_scan_args(argc, argv, "02", &arg1, &arg2);
    if (!NIL_P(arg1)) h_adj = (GtkAdjustment*)get_gobject(arg1);
    if (!NIL_P(arg2)) v_adj = (GtkAdjustment*)get_gobject(arg2);

    return make_widget(self, gtk_text_new(h_adj, v_adj));
}

static VALUE
txt_set_editable(self, editable)
    VALUE self, editable;
{
    GtkWidget *widget = get_widget(self);

    gtk_text_set_editable(GTK_TEXT(widget), RTEST(editable));
    return self;
}

static VALUE
txt_set_adjustment(self, h_adj, v_adj)
    VALUE self, h_adj, v_adj;
{
    GtkWidget *widget = get_widget(self);

    gtk_text_set_adjustments(GTK_TEXT(widget),
			     (GtkAdjustment*)get_gobject(h_adj),
			     (GtkAdjustment*)get_gobject(v_adj));

    return self;
}

static VALUE
txt_set_point(self, index)
    VALUE self, index;
{
    GtkWidget *widget = get_widget(self);

    gtk_text_set_point(GTK_TEXT(widget), NUM2INT(index));
    return self;
}

static VALUE
txt_get_point(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    int index = gtk_text_get_point(GTK_TEXT(widget));
    
    return INT2FIX(index);
}

static VALUE
txt_get_length(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    int len = gtk_text_get_length(GTK_TEXT(widget));
    
    return INT2FIX(len);
}

static VALUE
txt_freeze(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_text_freeze(GTK_TEXT(widget));
    return self;
}

static VALUE
txt_thaw(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_text_thaw(GTK_TEXT(widget));
    return self;
}

static VALUE
txt_insert(self, font, fore, back, str)
    VALUE self, font, fore, back, str;
{
    GtkWidget *widget = get_widget(self);

    Check_Type(str, T_STRING);
    gtk_text_insert(GTK_TEXT(widget), 
		    get_gdkfont(font),
		    get_gdkcolor(fore),
		    get_gdkcolor(back),
		    RSTRING(str)->ptr,
		    RSTRING(str)->len);

    return self;
}

static VALUE
txt_backward_delete(self, nchars)
    VALUE self, nchars;
{
    GtkWidget *widget = get_widget(self);

    gtk_text_backward_delete(GTK_TEXT(widget), NUM2INT(nchars));
    return self;
}

static VALUE
txt_forward_delete(self, nchars)
    VALUE self, nchars;
{
    GtkWidget *widget = get_widget(self);

    gtk_text_forward_delete(GTK_TEXT(widget), NUM2INT(nchars));
    return self;
}

static VALUE
tbar_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE arg1, arg2;
    GtkOrientation orientation = GTK_ORIENTATION_HORIZONTAL;
    GtkToolbarStyle style = GTK_TOOLBAR_BOTH;

    rb_scan_args(argc, argv, "02", &arg1, &arg2);
    if (!NIL_P(arg1)) orientation = (GtkOrientation)NUM2INT(arg1);
    if (!NIL_P(arg2)) style = (GtkToolbarStyle)NUM2INT(arg2);

    return make_widget(self, gtk_toolbar_new(orientation, style));
}

static VALUE
tbar_append_item(self, text, ttext, icon, func)
    VALUE self, text, ttext, icon, func;
{
    GtkWidget *widget = get_widget(self);
    GtkObject *pixmap = get_gobject(icon);

    if (NIL_P(func)) {
	func = f_lambda();
    }
    gtk_toolbar_append_item(GTK_TOOLBAR(widget),
			    get_cstring(text),
			    get_cstring(ttext),
			    GTK_PIXMAP(pixmap),
			    exec_callback,
			    (gpointer)ary_new3(1, func));
    return self;
}

static VALUE
tbar_prepend_item(self, text, ttext, icon, func)
    VALUE self, text, ttext, icon, func;
{
    GtkWidget *widget = get_widget(self);
    GtkObject *pixmap = get_gobject(icon);

    if (NIL_P(func)) {
	func = f_lambda();
    }
    gtk_toolbar_prepend_item(GTK_TOOLBAR(widget),
			     get_cstring(text),
			     get_cstring(ttext),
			     GTK_PIXMAP(pixmap),
			     exec_callback,
			     (gpointer)ary_new3(1, func));
    return self;
}

static VALUE
tbar_insert_item(self, text, ttext, icon, func, pos)
    VALUE self, text, ttext, icon, func, pos;
{
    GtkWidget *widget = get_widget(self);
    GtkObject *pixmap = get_gobject(icon);

    if (NIL_P(func)) {
	func = f_lambda();
    }
    gtk_toolbar_insert_item(GTK_TOOLBAR(widget),
			    get_cstring(text),
			    get_cstring(ttext),
			    GTK_PIXMAP(pixmap),
			    exec_callback,
			    (gpointer)ary_new3(1, func),
			    NUM2INT(pos));
    return self;
}

static VALUE
tbar_append_space(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_toolbar_append_space(GTK_TOOLBAR(widget));
    return self;
}

static VALUE
tbar_prepend_space(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_toolbar_prepend_space(GTK_TOOLBAR(widget));
    return self;
}

static VALUE
tbar_insert_space(self, pos)
    VALUE self, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_toolbar_insert_space(GTK_TOOLBAR(widget), NUM2INT(pos));
    return self;
}

static VALUE
tbar_set_orientation(self, orientation)
    VALUE self, orientation;
{
    GtkWidget *widget = get_widget(self);

    gtk_toolbar_set_orientation(GTK_TOOLBAR(widget), 
				(GtkOrientation)NUM2INT(orientation));
    return self;
}

static VALUE
tbar_set_style(self, style)
    VALUE self, style;
{
    GtkWidget *widget = get_widget(self);

    gtk_toolbar_set_style(GTK_TOOLBAR(widget), 
			  (GtkToolbarStyle)NUM2INT(style));
    return self;
}

static VALUE
tbar_set_space_size(self, size)
    VALUE self, size;
{
    GtkWidget *widget = get_widget(self);

    gtk_toolbar_set_space_size(GTK_TOOLBAR(widget), NUM2INT(size));
    return self;
}

static VALUE
tbar_set_tooltips(self, enable)
    VALUE self, enable;
{
    GtkWidget *widget = get_widget(self);

    gtk_toolbar_set_tooltips(GTK_TOOLBAR(widget), RTEST(enable));
    return self;
}

static VALUE
ttips_s_new(self)
    VALUE self;
{
    return make_ttips(self, gtk_tooltips_new());
}

static VALUE
ttips_set_tips(self, win, text)
    VALUE self, win, text;
{
    Check_Type(text, T_STRING);
    gtk_tooltips_set_tips(get_ttips(self),
			  get_widget(win),
			  RSTRING(text)->ptr);

    return self;
}

static VALUE
ttips_set_delay(self, delay)
    VALUE self, delay;
{
    gtk_tooltips_set_delay(get_ttips(self), NUM2INT(delay));

    return self;
}

static VALUE
ttips_enable(self)
    VALUE self;
{
    gtk_tooltips_enable(get_ttips(self));
    return self;
}

static VALUE
ttips_disable(self)
    VALUE self;
{
    gtk_tooltips_enable(get_ttips(self));
    return self;
}

static VALUE
tree_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_tree_new());
}

static VALUE
tree_append(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_tree_append(GTK_TREE(widget), get_widget(child));
    return self;
}

static VALUE
tree_prepend(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_tree_prepend(GTK_TREE(widget), get_widget(child));
    return self;
}

static VALUE
tree_insert(self, child, pos)
    VALUE self, child, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_tree_insert(GTK_TREE(widget), get_widget(child), NUM2INT(pos));
    return self;
}

static VALUE
titem_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
{
    VALUE label;
    GtkWidget *widget;

    if (rb_scan_args(argc, argv, "01", &label) == 1) {
	Check_Type(label, T_STRING);
	widget = gtk_tree_item_new_with_label(RSTRING(label)->ptr);
    }
    else {
	widget = gtk_tree_item_new();
    }

    return make_widget(self, widget);
}

static VALUE
titem_set_subtree(self, subtree)
    VALUE self, subtree;
{
    GtkWidget *widget = get_widget(self);

    gtk_tree_item_set_subtree(GTK_TREE_ITEM(widget), get_widget(subtree));
    return self;
}

static VALUE
titem_select(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_tree_item_select(GTK_TREE_ITEM(widget));
    return self;
}

static VALUE
titem_deselect(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_tree_item_deselect(GTK_TREE_ITEM(widget));
    return self;
}

static VALUE
titem_expand(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_tree_item_expand(GTK_TREE_ITEM(widget));
    return self;
}

static VALUE
titem_collapse(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_tree_item_collapse(GTK_TREE_ITEM(widget));
    return self;
}

static VALUE
vport_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE arg1, arg2;
    GtkAdjustment *h_adj = NULL;
    GtkAdjustment *v_adj = NULL;

    rb_scan_args(argc, argv, "02", &arg1, &arg2);
    if (!NIL_P(arg1)) h_adj = (GtkAdjustment*)get_gobject(arg1);
    if (!NIL_P(arg2)) v_adj = (GtkAdjustment*)get_gobject(arg2);

    return make_widget(self, gtk_viewport_new(h_adj, v_adj));
}

static VALUE
vport_get_hadj(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    GtkAdjustment *adj = gtk_viewport_get_hadjustment(GTK_VIEWPORT(widget));

    return make_gobject(gAdjustment, GTK_OBJECT(adj));
}

static VALUE
vport_get_vadj(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    GtkAdjustment *adj = gtk_viewport_get_vadjustment(GTK_VIEWPORT(widget));

    return make_gobject(gAdjustment, GTK_OBJECT(adj));
}

static VALUE
vport_set_vadj(self, adj)
    VALUE self, adj;
{
    GtkWidget *widget = get_widget(self);
    GtkObject *adjustment = get_gobject(adj);

    gtk_viewport_set_vadjustment(GTK_VIEWPORT(widget),
				 GTK_ADJUSTMENT(adj));

    return self;
}

static VALUE
vport_set_hadj(self, adj)
    VALUE self, adj;
{
    GtkWidget *widget = get_widget(self);
    GtkObject *adjustment = get_gobject(adj);

    gtk_viewport_set_hadjustment(GTK_VIEWPORT(widget),
				 GTK_ADJUSTMENT(adj));

    return self;
}

static VALUE
vport_set_shadow(self, type)
    VALUE self, type;
{
    GtkWidget *widget = get_widget(self);

    gtk_viewport_set_shadow_type(GTK_VIEWPORT(widget),
				 (GtkShadowType)NUM2INT(type));

    return self;
}

static VALUE
button_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
{
    VALUE label;
    GtkWidget *widget;

    if (rb_scan_args(argc, argv, "01", &label) == 1) {
	Check_Type(label, T_STRING);
	widget = gtk_button_new_with_label(RSTRING(label)->ptr);
    }
    else {
	widget = gtk_button_new();
    }

    return make_widget(self, widget);
}

static VALUE
button_pressed(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_button_pressed(GTK_BUTTON(widget));
    return self;
}

static VALUE
button_released(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_button_released(GTK_BUTTON(widget));
    return self;
}

static VALUE
button_clicked(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_button_clicked(GTK_BUTTON(widget));
    return self;
}

static VALUE
button_enter(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_button_enter(GTK_BUTTON(widget));
    return self;
}

static VALUE
button_leave(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_button_leave(GTK_BUTTON(widget));
    return self;
}

static VALUE
tbtn_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
{
    VALUE label;
    GtkWidget *widget;

    if (rb_scan_args(argc, argv, "01", &label) == 1) {
	Check_Type(label, T_STRING);
	widget = gtk_toggle_button_new_with_label(RSTRING(label)->ptr);
    }
    else {
	widget = gtk_toggle_button_new();
    }

    return make_widget(self, widget);
}

static VALUE
tbtn_set_mode(self, mode)
    VALUE self, mode;
{
    GtkWidget *widget = get_widget(self);

    gtk_toggle_button_set_mode(GTK_TOGGLE_BUTTON(widget), NUM2INT(mode));
    return self;
}

static VALUE
tbtn_set_state(self, state)
    VALUE self, state;
{
    GtkWidget *widget = get_widget(self);

    gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(widget), NUM2INT(state));
    return self;
}

static VALUE
tbtn_toggled(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_toggle_button_toggled(GTK_TOGGLE_BUTTON(widget));
    return self;
}

static VALUE
cbtn_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
{
    VALUE label;
    GtkWidget *widget;

    if (rb_scan_args(argc, argv, "01", &label) == 1) {
	Check_Type(label, T_STRING);
	widget = gtk_check_button_new_with_label(RSTRING(label)->ptr);
    }
    else {
	widget = gtk_check_button_new();
    }

    return make_widget(self, widget);
}

static VALUE
rbtn_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
{
    VALUE arg1, arg2;
    GtkWidget *widget;
    GSList *list = NULL;
    char *label = NULL;
    
    if (rb_scan_args(argc, argv, "02", &arg1, &arg2) == 1 &&
	TYPE(arg1) == T_STRING) {
	label = RSTRING(arg1)->ptr;
    }
    else {
	if (!NIL_P(arg2)) {
	    Check_Type(arg2, T_STRING);
	    label = RSTRING(arg2)->ptr;
	}
	if (obj_is_kind_of(arg1, gRButton)) {
	    GtkWidget *b = get_widget(arg1);
	    list = GTK_RADIO_BUTTON(b)->group;
	}
	else {
	    list = ary2gslist(arg1);
	}
    }
    if (label) {
	widget = gtk_radio_button_new_with_label(list, label);
    }
    else {
	widget = gtk_radio_button_new(list);
    }
    return make_widget(self, widget);
}

static VALUE
rbtn_group(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    
    return gslist2ary(gtk_radio_button_group(GTK_RADIO_BUTTON(widget)));
}

static void
box_pack_start_or_end(argc, argv, self, start)
    int argc;
    VALUE *argv;
    VALUE self;
    int start;
{
    VALUE arg0, arg1, arg2, arg3;
    gint expand, fill, padding;
    GtkWidget *widget, *child;

    expand = fill = TRUE; padding = 0;
    switch (rb_scan_args(argc, argv, "13", &arg0, &arg1, &arg2, &arg3)) {
      case 4:
	padding = NUM2INT(arg3);
      case 3:
	fill = RTEST(arg2);
      case 2:
	expand = RTEST(arg1);
      default:
	child = get_widget(arg0);
	break;
    }
    widget = get_widget(self);

    if (start)
	gtk_box_pack_start(GTK_BOX(widget), child, expand, fill, padding);
    else
	gtk_box_pack_end(GTK_BOX(widget), child, expand, fill, padding);
}

static VALUE
box_pack_start(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    box_pack_start_or_end(argc, argv, self, 1);
    return self;
}

static VALUE
box_pack_end(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    box_pack_start_or_end(argc, argv, self, 0);
    return self;
}

static VALUE
vbox_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE homogeneous, spacing;
    GtkWidget *widget;

    rb_scan_args(argc, argv, "02", &homogeneous, &spacing);
    widget = gtk_vbox_new(RTEST(homogeneous), NUM2INT(spacing));

    return make_widget(self, widget);
}

static VALUE
colorsel_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_color_selection_new());
}

static VALUE
colorsel_set_update_policy(self, policy)
    VALUE self, policy;
{
    GtkWidget *widget = get_widget(self);

    gtk_color_selection_set_update_policy(GTK_COLOR_SELECTION(widget),
					  (GtkUpdateType)NUM2INT(policy));
    return self;
}

static VALUE
colorsel_set_opacity(self, opacity)
    VALUE self, opacity;
{
    GtkWidget *widget = get_widget(self);

    gtk_color_selection_set_opacity(GTK_COLOR_SELECTION(widget),
				    RTEST(opacity));
    return self;
}

static VALUE
colorsel_set_color(self, color)
    VALUE self, color;
{
    GtkWidget *widget = get_widget(self);
    double buf[3];

    Check_Type(color, T_ARRAY);
    if (RARRAY(color)->len < 3) {
	ArgError("color array too small");
    }
    buf[0] = NUM2DBL(RARRAY(color)->ptr[0]);
    buf[1] = NUM2DBL(RARRAY(color)->ptr[1]);
    buf[2] = NUM2DBL(RARRAY(color)->ptr[2]);

    gtk_color_selection_set_color(GTK_COLOR_SELECTION(widget), buf);
    return self;
}

static VALUE
colorsel_get_color(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    double buf[3];
    VALUE ary;

    gtk_color_selection_get_color(GTK_COLOR_SELECTION(widget), buf);
    ary = ary_new2(3);
    ary_push(ary, NUM2DBL(buf[0]));
    ary_push(ary, NUM2DBL(buf[1]));
    ary_push(ary, NUM2DBL(buf[2]));
    return ary;
}

static VALUE
cdialog_s_new(self, title)
    VALUE self;
{
    char *t;

    Check_Type(title, T_STRING);
    t = RSTRING(title)->ptr;
    return make_widget(self, gtk_color_selection_dialog_new(t));
}

static VALUE
pixmap_s_new(self, val, mask)
    VALUE self, val, mask;
{
    return make_widget(self, gtk_pixmap_new(get_gdkpixmap(val),
					    get_gdkpixmap(mask)));
}

static VALUE
pixmap_set(self, val, mask)
    VALUE self, val, mask;
{
    GtkWidget *widget = get_widget(self);

    gtk_pixmap_set(GTK_PIXMAP(widget),
		   get_gdkpixmap(val), get_gdkpixmap(mask));
    return self;
}

static VALUE
pixmap_get(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    GdkPixmap  *val;
    GdkBitmap *mask;

    gtk_pixmap_get(GTK_PIXMAP(widget), &val, &mask);

    return assoc_new(make_gdkpixmap(self, val),
		     make_gdkpixmap(self, mask));
}

static VALUE
darea_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_drawing_area_new());
}

static VALUE
darea_size(self, w, h)
    VALUE self, w, h;
{
    GtkWidget *widget = get_widget(self);

    gtk_drawing_area_size(GTK_DRAWING_AREA(widget), NUM2INT(w), NUM2INT(h));
    return self;
}

static VALUE
entry_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_entry_new());
}

static VALUE
entry_set_text(self, text)
    VALUE self, text;
{
    GtkWidget *widget = get_widget(self);

    Check_Type(text, T_STRING);
    gtk_entry_set_text(GTK_ENTRY(widget), RSTRING(text)->ptr);

    return self;
}

static VALUE
eventbox_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_event_box_new());
}

static VALUE
fixed_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_fixed_new());
}

static VALUE
fixed_put(self, win, x, y)
    VALUE self, win, x, y;
{
    GtkWidget *widget = get_widget(self);

    gtk_fixed_put(GTK_FIXED(widget), get_widget(win), NUM2INT(x), NUM2INT(y));
    return self;
}

static VALUE
fixed_move(self, win, x, y)
    VALUE self, win, x, y;
{
    GtkWidget *widget = get_widget(self);

    gtk_fixed_move(GTK_FIXED(widget), get_widget(win), NUM2INT(x), NUM2INT(y));
    return self;
}

static VALUE
gamma_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_gamma_curve_new());
}

static VALUE
gamma_gamma(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    return float_new(GTK_GAMMA_CURVE(widget)->gamma);
}

static VALUE
hbbox_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_hbutton_box_new());
}

static VALUE
hbbox_get_spacing_default(self)
    VALUE self;
{
    int n = gtk_hbutton_box_get_spacing_default();
    
    return INT2FIX(n);
}

static VALUE
hbbox_get_layout_default(self)
    VALUE self;
{
    int n = gtk_hbutton_box_get_layout_default();
    
    return INT2FIX(n);
}

static VALUE
hbbox_set_spacing_default(self, spacing)
    VALUE self, spacing;
{
    gtk_hbutton_box_set_spacing_default(NUM2INT(spacing));
    return Qnil;
}

static VALUE
hbbox_set_layout_default(self, layout)
    VALUE self, layout;
{
    gtk_hbutton_box_set_layout_default(NUM2INT(layout));
    return Qnil;
}

static VALUE
vbbox_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_vbutton_box_new());
}

static VALUE
vbbox_get_spacing_default(self)
    VALUE self;
{
    int n = gtk_vbutton_box_get_spacing_default();
    
    return INT2FIX(n);
}

static VALUE
vbbox_get_layout_default(self)
    VALUE self;
{
    int n = gtk_vbutton_box_get_layout_default();
    
    return INT2FIX(n);
}

static VALUE
vbbox_set_spacing_default(self, spacing)
    VALUE self, spacing;
{
    gtk_vbutton_box_set_spacing_default(NUM2INT(spacing));
    return Qnil;
}

static VALUE
vbbox_set_layout_default(self, layout)
    VALUE self, layout;
{
    gtk_vbutton_box_set_layout_default(NUM2INT(layout));
    return Qnil;
}

static VALUE
hbox_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE homogeneous, spacing;
    GtkWidget *widget;

    rb_scan_args(argc, argv, "02", &homogeneous, &spacing);
    widget = gtk_hbox_new(RTEST(homogeneous), NUM2INT(spacing));

    return make_widget(self, widget);
}

static VALUE
paned_add1(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_paned_add1(GTK_PANED(widget), get_widget(child));
    return self;
}

static VALUE
paned_add2(self, child)
    VALUE self, child;
{
    GtkWidget *widget = get_widget(self);

    gtk_paned_add2(GTK_PANED(widget), get_widget(child));
    return self;
}

static VALUE
paned_handle_size(self, size)
    VALUE self, size;
{
    GtkWidget *widget = get_widget(self);

    gtk_paned_handle_size(GTK_PANED(widget), NUM2INT(size));
    return self;
}

static VALUE
paned_gutter_size(self, size)
    VALUE self, size;
{
    GtkWidget *widget = get_widget(self);

    gtk_paned_gutter_size(GTK_PANED(widget), NUM2INT(size));
    return self;
}

static VALUE
hpaned_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_hpaned_new());
}

static VALUE
vpaned_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_vpaned_new());
}

static VALUE
ruler_set_metric(self, metric)
    VALUE self, metric;
{
    GtkWidget *widget = get_widget(self);

    gtk_ruler_set_metric(GTK_RULER(widget), 
			 (GtkMetricType)NUM2INT(metric));

    return self;
}

static VALUE
ruler_set_range(self, lower, upper, position, max_size)
    VALUE self, lower, upper, position, max_size;
{
    GtkWidget *widget = get_widget(self);

    gtk_ruler_set_range(GTK_RULER(widget), 
			NUM2DBL(lower), NUM2DBL(upper),
			NUM2DBL(position), NUM2DBL(max_size));

    return self;
}

static VALUE
ruler_draw_ticks(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_ruler_draw_ticks(GTK_RULER(widget));
    return self;
}

static VALUE
ruler_draw_pos(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_ruler_draw_pos(GTK_RULER(widget));
    return self;
}

static VALUE
hruler_s_new(self)
{
    return make_widget(self, gtk_hruler_new());
}

static VALUE
vruler_s_new(self)
{
    return make_widget(self, gtk_vruler_new());
}

static VALUE
range_get_adj(self)
{
    GtkWidget *widget = get_widget(self);
    GtkAdjustment *adj = gtk_range_get_adjustment(GTK_RANGE(widget));

    return make_gobject(gAdjustment, GTK_OBJECT(adj));
}

static VALUE
range_set_update_policy(self, policy)
    VALUE self, policy;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_set_update_policy(GTK_RANGE(widget),
				(GtkUpdateType)NUM2INT(policy));
    return self;
}

static VALUE
range_set_adj(self, adj)
    VALUE self, adj;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_set_adjustment(GTK_RANGE(widget),
			     (GtkAdjustment*)get_gobject(adj));

    return self;
}

static VALUE
range_draw_bg(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_draw_background(GTK_RANGE(widget));
    return self;
}

static VALUE
range_draw_trough(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_draw_trough(GTK_RANGE(widget));
    return self;
}

static VALUE
range_draw_slider(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_draw_slider(GTK_RANGE(widget));
    return self;
}

static VALUE
range_draw_step_forw(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_draw_step_forw(GTK_RANGE(widget));
    return self;
}

static VALUE
range_draw_step_back(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_draw_step_back(GTK_RANGE(widget));
    return self;
}

static VALUE
range_slider_update(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_slider_update(GTK_RANGE(widget));
    return self;
}

static VALUE
range_trough_click(self, x, y)
    VALUE self, x, y;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_trough_click(GTK_RANGE(widget), NUM2INT(x), NUM2INT(y));
    return self;
}

static VALUE
range_default_hslider_update(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_default_hslider_update(GTK_RANGE(widget));
    return self;
}

static VALUE
range_default_vslider_update(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_default_vslider_update(GTK_RANGE(widget));
    return self;
}

static VALUE
range_default_htrough_click(self, x, y)
    VALUE self, x, y;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_default_htrough_click(GTK_RANGE(widget),
				    NUM2INT(x), NUM2INT(y));
    return self;
}

static VALUE
range_default_vtrough_click(self, x, y)
    VALUE self, x, y;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_default_vtrough_click(GTK_RANGE(widget),
				    NUM2INT(x), NUM2INT(y));
    return self;
}

static VALUE
range_default_hmotion(self, xdelta, ydelta)
    VALUE self, xdelta, ydelta;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_default_hmotion(GTK_RANGE(widget),
			      NUM2INT(xdelta), NUM2INT(ydelta));
    return self;
}

static VALUE
range_default_vmotion(self, xdelta, ydelta)
    VALUE self, xdelta, ydelta;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_default_vmotion(GTK_RANGE(widget),
			      NUM2INT(xdelta), NUM2INT(ydelta));
    return self;
}

static VALUE
range_calc_value(self, pos)
    VALUE self, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_range_calc_value(GTK_RANGE(widget), NUM2INT(pos));
    return self;
}

static VALUE
scale_set_digits(self, digits)
    VALUE self, digits;
{
    GtkWidget *widget = get_widget(self);

    gtk_scale_set_digits(GTK_SCALE(widget), NUM2INT(digits));
    return self;
}

static VALUE
scale_set_draw_value(self, draw_value)
    VALUE self, draw_value;
{
    GtkWidget *widget = get_widget(self);

    gtk_scale_set_draw_value(GTK_SCALE(widget), NUM2INT(draw_value));
    return self;
}

static VALUE
scale_set_value_pos(self, pos)
    VALUE self, pos;
{
    GtkWidget *widget = get_widget(self);

    gtk_scale_set_value_pos(GTK_SCALE(widget), 
			    (GtkPositionType)NUM2INT(pos));
    return self;
}

static VALUE
scale_value_width(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);
    int i = gtk_scale_value_width(GTK_SCALE(widget));

    return INT2FIX(i);
}

static VALUE
scale_draw_value(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_scale_draw_value(GTK_SCALE(widget));
    return self;
}

static VALUE
hscale_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE arg1;
    GtkAdjustment *adj = NULL;

    rb_scan_args(argc, argv, "01", &arg1);
    if (!NIL_P(arg1)) adj = (GtkAdjustment*)get_gobject(arg1);

    return make_widget(self, gtk_hscale_new(adj));
}

static VALUE
vscale_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE arg1;
    GtkAdjustment *adj = NULL;

    rb_scan_args(argc, argv, "01", &arg1);
    if (!NIL_P(arg1)) adj = (GtkAdjustment*)get_gobject(arg1);

    return make_widget(self, gtk_vscale_new(adj));
}

static VALUE
hscrollbar_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE arg1;
    GtkAdjustment *adj = NULL;

    rb_scan_args(argc, argv, "01", &arg1);
    if (!NIL_P(arg1)) adj = (GtkAdjustment*)get_gobject(arg1);

    return make_widget(self, gtk_hscrollbar_new(adj));
}

static VALUE
vscrollbar_s_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE arg1;
    GtkAdjustment *adj = NULL;

    rb_scan_args(argc, argv, "01", &arg1);
    if (!NIL_P(arg1)) adj = (GtkAdjustment*)get_gobject(arg1);

    return make_widget(self, gtk_vscrollbar_new(adj));
}

static VALUE
hsep_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_hseparator_new());
}

static VALUE
vsep_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_vseparator_new());
}

static VALUE
idiag_s_new(self)
    VALUE self;
{
    return make_widget(self, gtk_input_dialog_new());
}

static VALUE
gtk_m_main(self)
    VALUE self;
{
    gtk_main();
    return Qnil;
}

static gint
idle()
{
    CHECK_INTS;
    return TRUE;
}

static void
exec_interval(proc)
    VALUE proc;
{
    rb_funcall(proc, id_call, 0);
}

static VALUE
timeout_add(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE interval, func;
    int id;

    rb_scan_args(argc, argv, "11", &interval, &func);
    if (NIL_P(func)) {
	func = f_lambda();
    }
    id = gtk_timeout_add_interp(NUM2INT(interval), exec_interval,
				(gpointer)func, 0);
    return INT2FIX(id);
}

static VALUE
timeout_remove(self, id)
    VALUE self, id;
{
    gtk_timeout_remove(NUM2INT(id));
    return Qnil;
}

static VALUE
idle_add(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE func;
    int id;

    rb_scan_args(argc, argv, "01", &func);
    if (NIL_P(func)) {
	func = f_lambda();
    }
    id = gtk_idle_add_interp(exec_interval, (gpointer)func, 0);
    return INT2FIX(id);
}

static VALUE
idle_remove(self, id)
    VALUE self, id;
{
    gtk_idle_remove(NUM2INT(id));
    return Qnil;
}

static VALUE warn_handler;
static VALUE mesg_handler;
static VALUE print_handler;

static void
gtkwarn(mesg)
    char *mesg;
{
    rb_funcall(warn_handler, id_call, 1, str_new2(mesg));
}

static void
gtkmesg(mesg)
    char *mesg;
{
    rb_funcall(mesg_handler, id_call, 1, str_new2(mesg));
}

static void
gtkprint(mesg)
    char *mesg;
{
    rb_funcall(print_handler, id_call, 1, str_new2(mesg));
}

static VALUE
set_warning_handler(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE handler;

    rb_scan_args(argc, argv, "01", &handler);
    if (NIL_P(handler)) {
	handler = f_lambda();
    }
    g_set_warning_handler(gtkwarn);
}

static VALUE
set_message_handler(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE handler;

    rb_scan_args(argc, argv, "01", &handler);
    if (NIL_P(handler)) {
	handler = f_lambda();
    }
    g_set_message_handler(gtkmesg);
}

static VALUE
set_print_handler(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE handler;

    rb_scan_args(argc, argv, "01", &handler);
    if (NIL_P(handler)) {
	handler = f_lambda();
    }
    g_set_print_handler(gtkprint);
}

static void
gtkerr(mesg)
    char *mesg;
{
    Fail("%s", mesg);
}

void
Init_gtk()
{
    int argc, i;
    char **argv;

    gtk_object_list = ary_new();
    rb_global_variable(&gtk_object_list);

    mGtk = rb_define_module("Gtk");

    gObject = rb_define_class_under(mGtk, "GtkObject", cObject);
    gWidget = rb_define_class_under(mGtk, "Widget", gObject);
    gContainer = rb_define_class_under(mGtk, "Container", gWidget);
    gBin = rb_define_class_under(mGtk, "Bin", gContainer);
    gAlignment = rb_define_class_under(mGtk, "Alignment", gBin);
    gMisc = rb_define_class_under(mGtk, "Misc", gWidget);
    gArrow = rb_define_class_under(mGtk, "Arrow", gMisc);
    gFrame = rb_define_class_under(mGtk, "Frame", gBin);
    gAspectFrame = rb_define_class_under(mGtk, "AspectFrame", gFrame);
    gData = rb_define_class_under(mGtk, "Data", gObject);
    gAdjustment = rb_define_class_under(mGtk, "Adjustment", gData);
    gBox = rb_define_class_under(mGtk, "Box", gContainer);
    gButton = rb_define_class_under(mGtk, "Button", gContainer);
    gTButton = rb_define_class_under(mGtk, "ToggleButton", gButton);
    gCButton = rb_define_class_under(mGtk, "CheckButton", gTButton);
    gRButton = rb_define_class_under(mGtk, "RadioButton", gCButton);
    gBBox = rb_define_class_under(mGtk, "ButtonBox", gBox);
    gCList = rb_define_class_under(mGtk, "CList", gContainer);
    gWindow = rb_define_class_under(mGtk, "Window", gBin);
    gDialog = rb_define_class_under(mGtk, "Dialog", gWindow);
    gFileSel = rb_define_class_under(mGtk, "FileSelection", gWindow);
    gVBox = rb_define_class_under(mGtk, "VBox", gBox);
    gColorSel = rb_define_class_under(mGtk, "ColorSelection", gVBox);
    gColorSelDialog = rb_define_class_under(mGtk, "ColorSelectionDialog", gWindow);
    gImage = rb_define_class_under(mGtk, "Image", gMisc);
    gDrawArea = rb_define_class_under(mGtk, "DrawingArea", gWidget);
    gEntry = rb_define_class_under(mGtk, "Entry", gWidget);
    gEventBox = rb_define_class_under(mGtk, "EventBox", gBin);
    gFixed = rb_define_class_under(mGtk, "Fixed", gContainer);
    gGamma = rb_define_class_under(mGtk, "GammaCurve", gVBox);
    gHBBox = rb_define_class_under(mGtk, "HButtonBox", gBBox);
    gVBBox = rb_define_class_under(mGtk, "VButtonBox", gBBox);
    gHBox = rb_define_class_under(mGtk, "HBox", gBox);
    gPaned = rb_define_class_under(mGtk, "Paned", gContainer);
    gHPaned = rb_define_class_under(mGtk, "HPaned", gPaned);
    gVPaned = rb_define_class_under(mGtk, "VPaned", gPaned);
    gRuler = rb_define_class_under(mGtk, "Ruler", gWidget);
    gHRuler = rb_define_class_under(mGtk, "HRuler", gRuler);
    gVRuler = rb_define_class_under(mGtk, "VRuler", gRuler);
    gRange = rb_define_class_under(mGtk, "Range", gWidget);
    gScale = rb_define_class_under(mGtk, "Scale", gRange);
    gHScale = rb_define_class_under(mGtk, "HScale", gScale);
    gVScale = rb_define_class_under(mGtk, "VScale", gScale);
    gScrollbar = rb_define_class_under(mGtk, "Scrollbar", gRange);
    gHScrollbar = rb_define_class_under(mGtk, "HScrollbar", gScrollbar);
    gVScrollbar = rb_define_class_under(mGtk, "VScrollbar", gScrollbar);
    gSeparator = rb_define_class_under(mGtk, "Separator", gWidget);
    gHSeparator = rb_define_class_under(mGtk, "HSeparator", gSeparator);
    gVSeparator = rb_define_class_under(mGtk, "VSeparator", gSeparator);
    gInputDialog = rb_define_class_under(mGtk, "InputDialog", gDialog);
    gLabel = rb_define_class_under(mGtk, "Label", gMisc);
    gList = rb_define_class_under(mGtk, "List", gContainer);
    gItem = rb_define_class_under(mGtk, "Item", gBin);
    gListItem = rb_define_class_under(mGtk, "ListItem", gItem);
    gMenuShell = rb_define_class_under(mGtk, "MenuShell", gContainer);
    gMenu = rb_define_class_under(mGtk, "Menu", gMenuShell);
    gMenuBar = rb_define_class_under(mGtk, "MenuBar", gMenuShell);
    gMenuItem = rb_define_class_under(mGtk, "MenuItem", gItem);
    gCMenuItem = rb_define_class_under(mGtk, "CheckMenuItem", gMenuItem);
    gRMenuItem = rb_define_class_under(mGtk, "RadioMenuItem", gCMenuItem);
    gNotebook = rb_define_class_under(mGtk, "Notebook", gContainer);
    gOptionMenu = rb_define_class_under(mGtk, "OptionMenu", gButton);
    gPixmap = rb_define_class_under(mGtk, "Pixmap", gMisc);
    gPreview = rb_define_class_under(mGtk, "Preview", gWidget);
    gProgressBar = rb_define_class_under(mGtk, "ProgressBar", gWidget);
    gScrolledWin = rb_define_class_under(mGtk, "ScrolledWindow", gContainer);
    gTable = rb_define_class_under(mGtk, "Table", gContainer);
    gText = rb_define_class_under(mGtk, "Text", gWidget);
    gToolbar = rb_define_class_under(mGtk, "Toolbar", gContainer);
    gTooltips = rb_define_class_under(mGtk, "Tooltips", cObject);
    gTree = rb_define_class_under(mGtk, "Tree", gContainer);
    gTreeItem = rb_define_class_under(mGtk, "TreeItem", gItem);
    gViewPort = rb_define_class_under(mGtk, "ViewPort", gBin);

    gAcceleratorTable = rb_define_class_under(mGtk, "AcceleratorTable", cObject);
    gStyle = rb_define_class_under(mGtk, "Style", cObject);
    gPreviewInfo = rb_define_class_under(mGtk, "PreviewInfo", cObject);
    gRequisiton = rb_define_class_under(mGtk, "Requisiton", cObject);
    gAllocation = rb_define_class_under(mGtk, "Allocation", cObject);

    mGdk = rb_define_module("Gdk");

    gdkFont = rb_define_class_under(mGdk, "Font", cObject);
    gdkColor = rb_define_class_under(mGdk, "Color", cObject);
    gdkPixmap = rb_define_class_under(mGdk, "Pixmap", cObject);
    gdkBitmap = rb_define_class_under(mGdk, "Bitmap", gdkPixmap);
    gdkWindow = rb_define_class_under(mGdk, "Window", cObject);
    gdkImage = rb_define_class_under(mGdk, "Image", cObject);
    gdkVisual = rb_define_class_under(mGdk, "Visual", cObject);
    gdkGC = rb_define_class_under(mGdk, "GC", cObject);
    gdkGCValues = rb_define_class_under(mGdk, "GCValues", cObject);
    gdkRectangle = rb_define_class_under(mGdk, "Rectangle", cObject);
    gdkSegment = rb_define_class_under(mGdk, "Segment", cObject);
    gdkWindowAttr = rb_define_class_under(mGdk, "WindowAttr", cObject);
    gdkCursor = rb_define_class_under(mGdk, "Cursor", cObject);
    gdkAtom = rb_define_class_under(mGdk, "Atom", cObject);
    gdkColorContext = rb_define_class_under(mGdk, "ColotContext", cObject);
    gdkEvent = rb_define_class_under(mGdk, "gdkEvent", cObject);

    /* GtkObject */
    rb_define_singleton_method(gObject, "new", gobj_s_new, -1);
    rb_define_method(gObject, "set_flags", gobj_set_flags, 1);
    rb_define_method(gObject, "unset_flags", gobj_unset_flags, 1);
    rb_define_method(gObject, "destroy", gobj_destroy, 0);
    rb_define_method(gObject, "signal_connect", gobj_sig_connect, -1);
    rb_define_method(gObject, "signal_connect_after", gobj_sig_connect_after, -1);
    rb_define_method(gObject, "singleton_method_added", gobj_smethod_added, 1);

    /* Widget */
    rb_define_method(gWidget, "destroy", widget_destroy, 0);
    rb_define_method(gWidget, "show", widget_show, 0);
    rb_define_method(gWidget, "show_all", widget_show_all, 0);
    rb_define_method(gWidget, "hide", widget_hide, 0);
    rb_define_method(gWidget, "hide_all", widget_hide_all, 0);
    rb_define_method(gWidget, "map", widget_map, 0);
    rb_define_method(gWidget, "unmap", widget_unmap, 0);
    rb_define_method(gWidget, "realize", widget_realize, 0);
    rb_define_method(gWidget, "unrealize", widget_unrealize, 0);
    rb_define_method(gWidget, "queue_draw", widget_queue_draw, 0);
    rb_define_method(gWidget, "queue_resize", widget_queue_resize, 0);
    rb_define_method(gWidget, "draw", widget_draw, 1);
    rb_define_method(gWidget, "draw_focus", widget_draw_focus, 0);
    rb_define_method(gWidget, "draw_default", widget_draw_default, 0);
    rb_define_method(gWidget, "draw_children", widget_draw_children, 0);
    rb_define_method(gWidget, "size_request", widget_size_request, 1);
    rb_define_method(gWidget, "size_alocate", widget_size_allocate, 1);
    rb_define_method(gWidget, "install_accelerator", widget_inst_accel, 4);
    rb_define_method(gWidget, "remove_accelerator", widget_rm_accel, 4);
    rb_define_method(gWidget, "event", widget_event, 1);
    rb_define_method(gWidget, "activate", widget_activate, 0);
    rb_define_method(gWidget, "grab_focus", widget_grab_focus, 0);
    rb_define_method(gWidget, "grab_default", widget_grab_default, 0);
    rb_define_method(gWidget, "restore_state", widget_restore_state, 0);
    rb_define_method(gWidget, "visible?", widget_visible, 0);
    rb_define_method(gWidget, "reparent", widget_reparent, 1);
    rb_define_method(gWidget, "popup", widget_popup, 2);
    rb_define_method(gWidget, "intersect", widget_intersect, 2);
    rb_define_method(gWidget, "basic", widget_basic, 0);
    rb_define_method(gWidget, "get_name", widget_set_name, 0);
    rb_define_method(gWidget, "set_name", widget_set_name, 1);
    rb_define_method(gWidget, "set_parent", widget_set_parent, 1);
    rb_define_method(gWidget, "set_sensitive", widget_set_sensitive, 1);
    rb_define_method(gWidget, "set_usize", widget_set_usize, 2);
    rb_define_method(gWidget, "set_uposition", widget_set_uposition, 2);
    rb_define_method(gWidget, "set_style", widget_set_style, 1);
    rb_define_method(gWidget, "set_events", widget_set_events, 1);
    rb_define_method(gWidget, "set_extension_events", widget_set_eevents, 1);
    rb_define_method(gWidget, "unparent", widget_unparent, 0);
    rb_define_method(gWidget, "get_toplevel", widget_get_toplevel, 0);
    rb_define_method(gWidget, "get_ancestor", widget_get_ancestor, 1);
    rb_define_method(gWidget, "get_colormap", widget_get_colormap, 0);
    rb_define_method(gWidget, "get_visual", widget_get_visual, 0);
    rb_define_method(gWidget, "get_style", widget_get_style, 0);
    rb_define_method(gWidget, "style", widget_get_style, 0);
    rb_define_method(gWidget, "get_events", widget_get_events, 0);
    rb_define_method(gWidget, "get_extension_events", widget_get_eevents, 0);
    rb_define_method(gWidget, "get_pointer", widget_get_eevents, 0);
    rb_define_method(gWidget, "ancestor?", widget_is_ancestor, 1);
    rb_define_method(gWidget, "child?", widget_is_child, 1);
    rb_define_method(gWidget, "window", widget_window, 0);

    rb_define_singleton_method(gWidget, "push_colomap", widget_push_cmap, 1);
    rb_define_singleton_method(gWidget, "push_visual", widget_push_visual, 1);
    rb_define_singleton_method(gWidget, "push_style", widget_push_style, 1);
    rb_define_singleton_method(gWidget, "pop_colomap", widget_pop_cmap, 0);
    rb_define_singleton_method(gWidget, "pop_visual", widget_pop_visual, 0);
    rb_define_singleton_method(gWidget, "pop_style", widget_pop_style, 0);

    rb_define_singleton_method(gWidget, "set_default_colomap",
			       widget_set_default_cmap, 1);
    rb_define_singleton_method(gWidget, "set_default_visual",
			       widget_set_default_visual, 1);
    rb_define_singleton_method(gWidget, "set_default_style",
			       widget_set_default_style, 1);
    rb_define_singleton_method(gWidget, "get_default_colomap",
			       widget_get_default_cmap, 0);
    rb_define_singleton_method(gWidget, "get_default_visual",
			       widget_get_default_visual, 0);
    rb_define_singleton_method(gWidget, "get_default_style",
			       widget_get_default_style, 0);
    rb_define_singleton_method(gWidget, "set_default_colomap",
			       widget_set_default_cmap, 1);
    rb_define_singleton_method(gWidget, "set_default_visual",
			       widget_set_default_visual, 1);
    rb_define_singleton_method(gWidget, "set_default_style",
			       widget_set_default_style, 1);
    rb_define_singleton_method(gWidget, "set_default_colomap",
			       widget_set_default_cmap, 1);
    rb_define_singleton_method(gWidget, "set_default_visual",
			       widget_set_default_visual, 1);
    rb_define_singleton_method(gWidget, "propagage_default_style",
			       widget_propagate_default_style, 0);

    /* Container */
    rb_define_method(gContainer, "border_width", cont_bwidth, 1);
    rb_define_method(gContainer, "add", cont_add, 1);
    rb_define_method(gContainer, "disable_resize", cont_disable_resize, 0);
    rb_define_method(gContainer, "enable_resize", cont_enable_resize, 0);
    rb_define_method(gContainer, "block_resize", cont_block_resize, 0);
    rb_define_method(gContainer, "unblock_resize", cont_unblock_resize, 0);
    rb_define_method(gContainer, "need_resize", cont_need_resize, 0);
    rb_define_method(gContainer, "foreach", cont_foreach, -1);
    rb_define_method(gContainer, "each", cont_each, 0);
    rb_define_method(gContainer, "focus", cont_focus, 1);
    rb_define_method(gContainer, "children", cont_children, 0);

    /* Bin */
    /* -- */

    /* Alignment */
    rb_define_singleton_method(gAlignment, "new", align_s_new, 4);
    rb_define_method(gAlignment, "set", align_set, 4);

    /* Misc */
    rb_define_method(gMisc, "set_alignment", misc_set_align, 2);
    rb_define_method(gMisc, "set_padding", misc_set_padding, 2);
    
    /* Arrow */
    rb_define_singleton_method(gArrow, "new", arrow_s_new, 2);
    rb_define_method(gArrow, "set", arrow_s_new, 2);

    /* Frame */
    rb_define_singleton_method(gFrame, "new", frame_s_new, 1);
    rb_define_method(gFrame, "set_label", frame_set_label, 1);
    rb_define_method(gFrame, "set_label_align", frame_set_label_align, 2);
    rb_define_method(gFrame, "set_shadow_type", frame_set_shadow_type, 1);

    /* AspectFrame */
    rb_define_singleton_method(gAspectFrame, "new", aframe_s_new, 5);
    rb_define_method(gAspectFrame, "set", aframe_set, 4);

    /* Data */
    /* -- */

    /* Adjustment */
    rb_define_singleton_method(gAdjustment, "new", adj_s_new, 6);

    /* Box */
    rb_define_method(gBox, "pack_start", box_pack_start, -1);
    rb_define_method(gBox, "pack_end", box_pack_end, -1);

    /* Button */
    rb_define_singleton_method(gButton, "new", button_s_new, -1);
    rb_define_method(gButton, "pressed", button_pressed, 0);
    rb_define_method(gButton, "released", button_released, 0);
    rb_define_method(gButton, "clicked", button_clicked, 0);
    rb_define_method(gButton, "enter", button_enter, 0);
    rb_define_method(gButton, "leave", button_leave, 0);

    /* ToggleButton */
    rb_define_singleton_method(gTButton, "new", tbtn_s_new, -1);
    rb_define_method(gTButton, "set_mode", tbtn_set_mode, 1);
    rb_define_method(gTButton, "set_state", tbtn_set_state, 1);
    rb_define_method(gTButton, "toggled", tbtn_toggled, 0);

    /* CheckButton */
    rb_define_singleton_method(gCButton, "new", cbtn_s_new, -1);

    /* RadioButton */
    rb_define_singleton_method(gCButton, "new", rbtn_s_new, -1);
    rb_define_method(gCButton, "group", rbtn_group, 0);

    /* ButtonBox */
    rb_define_singleton_method(gBBox, "get_child_size_default",
			       bbox_get_child_size_default, 0);
    rb_define_singleton_method(gBBox, "get_child_ipadding_default",
			       bbox_get_child_ipadding_default, 0);
    rb_define_singleton_method(gBBox, "set_child_size_default",
			       bbox_set_child_size_default, 2);
    rb_define_singleton_method(gBBox, "set_child_ipadding_default",
			       bbox_set_child_ipadding_default, 2);
    rb_define_method(gBBox, "get_spacing", bbox_get_spacing, 0);
    rb_define_method(gBBox, "get_layout", bbox_get_layout, 0);
    rb_define_method(gBBox, "get_child_size", bbox_get_child_size, 0);
    rb_define_method(gBBox, "get_child_ipadding", bbox_get_child_ipadding, 0);
    rb_define_method(gBBox, "set_spacing", bbox_set_spacing, 1);
    rb_define_method(gBBox, "set_layout", bbox_set_layout, 1);
    rb_define_method(gBBox, "set_child_size", bbox_set_child_size, 2);
    rb_define_method(gBBox, "set_child_ipadding", bbox_set_child_ipadding, 2);

    /* CList */
    rb_define_singleton_method(gCList, "new", clist_s_new, 1);
    rb_define_method(gCList, "set_border", clist_set_border, 1);
    rb_define_method(gCList, "set_selection_mode", clist_set_sel_mode, 1);
    rb_define_method(gCList, "set_policy", clist_set_policy, 2);
    rb_define_method(gCList, "freeze", clist_freeze, 0);
    rb_define_method(gCList, "thaw", clist_thaw, 0);
    rb_define_method(gCList, "set_column_title", clist_set_col_title, 2);
    rb_define_method(gCList, "set_column_widget", clist_set_col_wigdet, 2);
    rb_define_method(gCList, "set_column_justification", clist_set_col_just, 2);
    rb_define_method(gCList, "set_column_width", clist_set_col_width, 2);
    rb_define_method(gCList, "set_row_height", clist_set_row_height, 1);
    rb_define_method(gCList, "moveto", clist_moveto, 4);
    rb_define_method(gCList, "set_text", clist_set_text, 3);
    rb_define_method(gCList, "set_pixmap", clist_set_text, 4);
    rb_define_method(gCList, "set_pixtext", clist_set_pixtext, 6);
    rb_define_method(gCList, "set_foreground", clist_set_foreground, 2);
    rb_define_method(gCList, "set_background", clist_set_background, 2);
    rb_define_method(gCList, "set_shift", clist_set_shift, 4);
    rb_define_method(gCList, "append", clist_append, 1);
    rb_define_method(gCList, "insert", clist_insert, 2);
    rb_define_method(gCList, "remove", clist_remove, 1);
    rb_define_method(gCList, "set_row_data", clist_set_row_data, 2);
    rb_define_method(gCList, "get_row_data", clist_set_row_data, 1);
    rb_define_method(gCList, "select_row", clist_select_row, 2);
    rb_define_method(gCList, "unselect_row", clist_unselect_row, 2);
    rb_define_method(gCList, "clear", clist_clear, 0);

    /* Window */
    rb_define_singleton_method(gWindow, "new", gwin_s_new, 1);
    rb_define_method(gWindow, "set_title", gwin_set_title, 1);
    rb_define_method(gWindow, "set_policy", gwin_set_policy, 3);
    rb_define_method(gWindow, "set_wmclass", gwin_set_wmclass, 1);
    rb_define_method(gWindow, "set_focus", gwin_set_focus, 1);
    rb_define_method(gWindow, "set_default", gwin_set_focus, 1);
    rb_define_method(gWindow, "add_accelerator_table", gwin_add_accel, 1);
    rb_define_method(gWindow, "remove_accelerator_table", gwin_rm_accel, 1);
    rb_define_method(gWindow, "position", gwin_position, 1);

    /* Dialog */
    rb_define_singleton_method(gDialog, "new", dialog_s_new, 0);

    /* FileSelection */
    rb_define_singleton_method(gFileSel, "new", fsel_s_new, 1);
    rb_define_method(gFileSel, "set_filename", fsel_set_fname, 1);
    rb_define_method(gFileSel, "get_filename", fsel_get_fname, 0);
    rb_define_method(gFileSel, "ok_button", fsel_ok_button, 0);
    rb_define_method(gFileSel, "cancel_button", fsel_cancel_button, 0);
    rb_define_method(gFileSel, "help_button", fsel_help_button, 0);

    /* VBox */
    rb_define_singleton_method(gVBox, "new", vbox_s_new, -1);

    /* ColorSelection */
    rb_define_singleton_method(gColorSel, "new", colorsel_s_new, 0);
    rb_define_method(gColorSel, "set_update_policy", colorsel_set_update_policy, 1);
    rb_define_method(gColorSel, "set_opacity", colorsel_set_opacity, 1);
    rb_define_method(gColorSel, "set_color", colorsel_set_color, 1);
    rb_define_method(gColorSel, "get_color", colorsel_get_color, 0);

    /* ColorSelectionDialog */
    rb_define_singleton_method(gColorSelDialog, "new", cdialog_s_new, 1);

    /* Image */
    rb_define_singleton_method(gImage, "new", image_s_new, 2);
    rb_define_method(gImage, "set", image_set, 2);
    rb_define_method(gImage, "get", image_get, 0);

    /* DrawingArea */
    rb_define_singleton_method(gDrawArea, "new", darea_s_new, 0);
    rb_define_method(gDrawArea, "size", darea_size, 2);

    /* Entry */
    rb_define_singleton_method(gEntry, "new", entry_s_new, 0);
    rb_define_method(gEntry, "set_text", entry_set_text, 1);

    /* EventBox */
    rb_define_singleton_method(gEventBox, "new", eventbox_s_new, 0);

    /* Fixed */
    rb_define_singleton_method(gFixed, "new", fixed_s_new, 0);
    rb_define_method(gFixed, "put", fixed_put, 3);
    rb_define_method(gFixed, "move", fixed_move, 3);

    /* GammaCurve */
    rb_define_singleton_method(gGamma, "new", gamma_s_new, 0);
    rb_define_method(gGamma, "gamma", gamma_gamma, 0);
    
    /* HButtonBox */
    rb_define_singleton_method(gHBBox, "new", hbbox_s_new, 0);
    rb_define_singleton_method(gHBBox, "get_spacing_default",
			       hbbox_get_spacing_default, 0);
    rb_define_singleton_method(gHBBox, "get_layout_default",
			       hbbox_get_spacing_default, 0);
    rb_define_singleton_method(gHBBox, "set_spacing_default",
			       hbbox_set_spacing_default, 1);
    rb_define_singleton_method(gHBBox, "set_layout_default",
			       hbbox_set_layout_default, 1);

    /* VButtonBox */
    rb_define_singleton_method(gVBBox, "new", vbbox_s_new, 0);
    rb_define_singleton_method(gVBBox, "get_spacing_default",
			       vbbox_get_spacing_default, 0);
    rb_define_singleton_method(gVBBox, "get_layout_default",
			       vbbox_get_spacing_default, 0);
    rb_define_singleton_method(gVBBox, "set_spacing_default",
			       vbbox_set_spacing_default, 1);
    rb_define_singleton_method(gVBBox, "set_layout_default",
			       vbbox_set_layout_default, 1);

    /* HBox */
    rb_define_singleton_method(gHBox, "new", hbox_s_new, -1);

    /* Paned */
    rb_define_method(gPaned, "add1", paned_add1, 1);
    rb_define_method(gPaned, "add2", paned_add1, 1);
    rb_define_method(gPaned, "handle_size", paned_handle_size, 1);
    rb_define_method(gPaned, "gutter_size", paned_gutter_size, 1);

    /* HPaned */
    rb_define_singleton_method(gHPaned, "new", hpaned_s_new, 0);

    /* VPaned */
    rb_define_singleton_method(gVPaned, "new", vpaned_s_new, 0);

    /* Ruler */
    rb_define_method(gRuler, "set_metric", ruler_set_metric, 1);
    rb_define_method(gRuler, "set_range", ruler_set_range, 4);
    rb_define_method(gRuler, "draw_ticks", ruler_draw_ticks, 0);
    rb_define_method(gRuler, "draw_pos", ruler_draw_pos, 0);

    /* HRuler */
    rb_define_singleton_method(gHRuler, "new", hruler_s_new, 0);

    /* VRuler */
    rb_define_singleton_method(gVRuler, "new", vruler_s_new, 0);

    /* Range */
    rb_define_method(gRange, "get_adjustment", range_get_adj, 0);
    rb_define_method(gRange, "set_update_policy", range_set_update_policy, 1);
    rb_define_method(gRange, "set_adjustment", range_set_adj, 1);
    rb_define_method(gRange, "draw_background", range_draw_bg, 0);
    rb_define_method(gRange, "draw_trough", range_draw_trough, 0);
    rb_define_method(gRange, "draw_slider", range_draw_slider, 0);
    rb_define_method(gRange, "draw_step_forw", range_draw_step_forw, 0);
    rb_define_method(gRange, "draw_step_back", range_draw_step_back, 0);
    rb_define_method(gRange, "slider_update", range_slider_update, 0);
    rb_define_method(gRange, "trough_click", range_trough_click, 2);
    rb_define_method(gRange, "draw_background", range_draw_bg, 2);
    rb_define_method(gRange, "default_hslider_update", range_default_hslider_update, 0);
    rb_define_method(gRange, "default_vslider_update", range_default_vslider_update, 0);
    rb_define_method(gRange, "default_htrough_click", range_default_htrough_click, 2);
    rb_define_method(gRange, "default_vtrough_click", range_default_vtrough_click, 2);
    rb_define_method(gRange, "default_hmotion", range_default_hmotion, 2);
    rb_define_method(gRange, "default_vmotion", range_default_vmotion, 2);
    rb_define_method(gRange, "calc_value", range_calc_value, 1);

    /* Scale */
    rb_define_method(gScale, "set_digits", scale_set_digits, 1);
    rb_define_method(gScale, "set_draw_value", scale_set_draw_value, 1);
    rb_define_method(gScale, "set_value_pos", scale_set_value_pos, 1);
    rb_define_method(gScale, "value_width", scale_value_width, 0);
    rb_define_method(gScale, "draw_value", scale_draw_value, 0);

    /* HScale */
    rb_define_singleton_method(gHScale, "new", hscale_s_new, -1);

    /* VScale */
    rb_define_singleton_method(gVScale, "new", vscale_s_new, -1);

    /* Scrollbar */
    /* -- */

    /* HScrollbar */
    rb_define_singleton_method(gHScrollbar, "new", hscrollbar_s_new, -1);

    /* VScrollbar */
    rb_define_singleton_method(gVScrollbar, "new", vscrollbar_s_new, -1);

    /* Separator */
    /* -- */

    /* HSeparator */
    rb_define_singleton_method(gHSeparator, "new", hsep_s_new, 0);

    /* VSeparator */
    rb_define_singleton_method(gVSeparator, "new", vsep_s_new, 0);

    /* InputDialog */
    rb_define_singleton_method(gInputDialog, "new", idiag_s_new, 0);

    /* Label */
    rb_define_singleton_method(gLabel, "new", label_s_new, 1);

    /* List */
    rb_define_singleton_method(gList, "new", list_s_new, 0);
    rb_define_method(gList, "set_selection_mode", list_set_sel_mode, 1);
    rb_define_method(gList, "selection_mode", list_sel_mode, 1);
    rb_define_method(gList, "selection", list_selection, 0);
    rb_define_method(gList, "insert_items", list_insert_items, 2);
    rb_define_method(gList, "append_items", list_append_items, 1);
    rb_define_method(gList, "prepend_items", list_prepend_items, 1);
    rb_define_method(gList, "remove_items", list_remove_items, 1);
    rb_define_method(gList, "clear_items", list_clear_items, 2);
    rb_define_method(gList, "select_item", list_select_item, 1);
    rb_define_method(gList, "unselect_item", list_unselect_item, 1);
    rb_define_method(gList, "select_child", list_select_child, 1);
    rb_define_method(gList, "unselect_child", list_unselect_child, 1);
    rb_define_method(gList, "child_position", list_child_position, 1);

    /* Item */
    rb_define_method(gItem, "select", item_select, 0);
    rb_define_method(gItem, "deselect", item_deselect, 0);
    rb_define_method(gItem, "toggle", item_toggle, 0);

    /* ListItem */
    rb_define_singleton_method(gListItem, "new", litem_s_new, -1);

    /* MenuShell */
    rb_define_method(gMenuShell, "append", mshell_append, 1);
    rb_define_method(gMenuShell, "prepend", mshell_prepend, 1);
    rb_define_method(gMenuShell, "insert", mshell_insert, 2);
    rb_define_method(gMenuShell, "deactivate", mshell_deactivate, 0);

    /* Menu */
    rb_define_singleton_method(gMenu, "new", menu_s_new, 0);
    rb_define_method(gMenu, "append", menu_append, 1);
    rb_define_method(gMenu, "prepend", menu_prepend, 1);
    rb_define_method(gMenu, "insert", menu_insert, 2);
    rb_define_method(gMenu, "popup", menu_popup, 6);
    rb_define_method(gMenu, "popdown", menu_popup, 0);
    rb_define_method(gMenu, "get_active", menu_get_active, 0);
    rb_define_method(gMenu, "set_active", menu_set_active, 1);
    rb_define_method(gMenu, "set_accelerator_table", menu_set_acceltbl, 1);

    /* MenuBar */
    rb_define_singleton_method(gMenuBar, "new", mbar_s_new, 0);
    rb_define_method(gMenuBar, "append", mbar_append, 1);
    rb_define_method(gMenuBar, "prepend", mbar_prepend, 1);
    rb_define_method(gMenuBar, "insert", mbar_insert, 2);

    /* MenuItem */
    rb_define_singleton_method(gMenuItem, "new", mitem_s_new, -1);
    rb_define_method(gMenuItem, "set_submenu", mitem_set_submenu, 1);
    rb_define_method(gMenuItem, "set_placement", mitem_set_placement, 1);
    rb_define_method(gMenuItem, "accelerator_size", mitem_accelerator_size, 0);
    rb_define_method(gMenuItem, "accelerator_text", mitem_accelerator_text, 0);
    rb_define_method(gMenuItem, "configure", mitem_configure, 2);
    rb_define_method(gMenuItem, "select", mitem_select, 0);
    rb_define_method(gMenuItem, "deselect", mitem_deselect, 0);
    rb_define_method(gMenuItem, "activate", mitem_activate, 0);
    rb_define_method(gMenuItem, "right_justify", mitem_right_justify, 0);

    /* CheckMenuItem */
    rb_define_singleton_method(gCMenuItem, "new", cmitem_s_new, -1);
    rb_define_method(gCMenuItem, "set_state", cmitem_set_state, 1);
    rb_define_method(gCMenuItem, "set_show_toggle", cmitem_set_show_toggle, 1);
    rb_define_method(gCMenuItem, "toggled", cmitem_toggled, 0);

    /* RadioMenuItem */
    rb_define_singleton_method(gRMenuItem, "new", rmitem_s_new, -1);
    rb_define_method(gRMenuItem, "group", rmitem_group, 0);

    /* NoteBook */
    rb_define_singleton_method(gNotebook, "new", note_s_new, 0);
    rb_define_method(gNotebook, "append_page", note_append_page, 2);
    rb_define_method(gNotebook, "prepend_page", note_prepend_page, 2);
    rb_define_method(gNotebook, "insert_page", note_insert_page, 3);
    rb_define_method(gNotebook, "remove_page", note_remove_page, 1);
    rb_define_method(gNotebook, "set_page", note_set_page, 1);
    rb_define_method(gNotebook, "cur_page", note_cur_page, 0);
    rb_define_method(gNotebook, "page", note_cur_page, 0);
    rb_define_method(gNotebook, "next_page", note_next_page, 0);
    rb_define_method(gNotebook, "prev_page", note_prev_page, 0);
    rb_define_method(gNotebook, "set_tab_pos", note_set_tab_pos, 1);
    rb_define_method(gNotebook, "tab_pos", note_tab_pos, 0);
    rb_define_method(gNotebook, "set_show_tabs", note_set_show_tabs, 1);
    rb_define_method(gNotebook, "show_tabs", note_show_tabs, 0);
    rb_define_method(gNotebook, "set_show_border", note_set_show_border, 1);
    rb_define_method(gNotebook, "show_border", note_show_border, 0);

    /* OptionMenu */
    rb_define_singleton_method(gOptionMenu, "new", omenu_s_new, 0);
    rb_define_method(gOptionMenu, "get_menu", omenu_get_menu, 0);
    rb_define_method(gOptionMenu, "set_menu", omenu_set_menu, 1);
    rb_define_method(gOptionMenu, "remove_menu", omenu_set_menu, 0);
    rb_define_method(gOptionMenu, "set_history", omenu_set_history, 1);

    /* Pixmap */
    rb_define_singleton_method(gPixmap, "new", pixmap_s_new, 2);
    rb_define_method(gPixmap, "set", pixmap_set, 2);
    rb_define_method(gPixmap, "get", pixmap_get, 0);

    /* Preview */
    rb_define_singleton_method(gPreview, "new", preview_s_new, 1);
    rb_define_method(gPreview, "size", preview_size, 2);
    rb_define_method(gPreview, "put", preview_size, 8);
    rb_define_method(gPreview, "put_row", preview_size, 5);
    rb_define_method(gPreview, "draw_row", preview_size, 4);
    rb_define_method(gPreview, "set_expand", preview_set_expand, 1);
    rb_define_singleton_method(gPreview, "set_gamma", preview_set_gamma, 1);
    rb_define_singleton_method(gPreview, "set_color_cube",
			       preview_set_color_cube, 4);
    rb_define_singleton_method(gPreview, "set_install_cmap",
			       preview_set_install_cmap, 1);
    rb_define_singleton_method(gPreview, "set_reserved",
			       preview_set_reserved, 1);
    rb_define_singleton_method(gPreview, "get_visual", preview_get_visual, 0);
    rb_define_singleton_method(gPreview, "get_cmap", preview_get_cmap, 0);
    rb_define_singleton_method(gPreview, "get_info", preview_get_info, 0);

    /* ProgressBar */
    rb_define_singleton_method(gProgressBar, "new", pbar_s_new, 0);
    rb_define_method(gProgressBar, "update", pbar_update, 1);

    /* ScrolledWindow */
    rb_define_singleton_method(gScrolledWin, "new", scwin_s_new, -1);
    rb_define_method(gScrolledWin, "set_policy", scwin_set_policy, 2);

    /* Table */
    rb_define_singleton_method(gTable, "new", tbl_s_new, -1);
    rb_define_method(gTable, "attach", tbl_attach, -1);
    rb_define_method(gTable, "set_row_spacing", tbl_set_row_spacing, 2);
    rb_define_method(gTable, "set_col_spacing", tbl_set_col_spacing, 2);
    rb_define_method(gTable, "set_row_spacings", tbl_set_row_spacings, 1);
    rb_define_method(gTable, "set_col_spacings", tbl_set_col_spacings, 1);

    /* Text */
    rb_define_singleton_method(gText, "new", txt_s_new, -1);
    rb_define_method(gText, "set_editable", txt_set_editable, 1);
    rb_define_method(gText, "set_adjustment", txt_set_adjustment, 2);
    rb_define_method(gText, "set_point", txt_set_point, 1);
    rb_define_method(gText, "get_point", txt_get_point, 0);
    rb_define_method(gText, "get_length", txt_get_length, 0);
    rb_define_method(gText, "freeze", txt_freeze, 0);
    rb_define_method(gText, "thaw", txt_thaw, 0);
    rb_define_method(gText, "insert", txt_insert, 4);
    rb_define_method(gText, "backward_delete", txt_backward_delete, 1);
    rb_define_method(gText, "forward_delete", txt_forward_delete, 1);

    /* Toolbar */
    rb_define_singleton_method(gToolbar, "new", tbar_s_new, -1);
    rb_define_method(gToolbar, "append_item", tbar_append_item, 4);
    rb_define_method(gToolbar, "prepend_item", tbar_prepend_item, 4);
    rb_define_method(gToolbar, "insert_item", tbar_append_item, 5);
    rb_define_method(gToolbar, "append_space", tbar_append_space, 0);
    rb_define_method(gToolbar, "prepend_space", tbar_prepend_space, 0);
    rb_define_method(gToolbar, "insert_space", tbar_append_space, 1);
    rb_define_method(gToolbar, "set_orientation", tbar_set_orientation, 1);
    rb_define_method(gToolbar, "set_style", tbar_set_style, 1);
    rb_define_method(gToolbar, "set_space_size", tbar_set_space_size, 1);
    rb_define_method(gToolbar, "set_tooltips", tbar_set_tooltips, 1);

    /* Tooltips */
    rb_define_singleton_method(gTooltips, "new", ttips_s_new, 0);
    rb_define_method(gTooltips, "set_tips", ttips_set_tips, 2);
    rb_define_method(gTooltips, "set_delay", ttips_set_delay, 1);
    rb_define_method(gTooltips, "enable", ttips_enable, 0);
    rb_define_method(gTooltips, "disable", ttips_disable, 0);

    /* Tree */
    rb_define_singleton_method(gTree, "new", tree_s_new, 0);
    rb_define_method(gTree, "append", tree_append, 1);
    rb_define_method(gTree, "prepend", tree_prepend, 1);
    rb_define_method(gTree, "insert", tree_insert, 2);

    /* TreeItem */
    rb_define_singleton_method(gTreeItem, "new", titem_s_new, -1);
    rb_define_method(gTreeItem, "set_subtree", titem_set_subtree, 1);
    rb_define_method(gTreeItem, "select", titem_select, 0);
    rb_define_method(gTreeItem, "deselect", titem_deselect, 0);
    rb_define_method(gTreeItem, "expand", titem_expand, 0);
    rb_define_method(gTreeItem, "collapse", titem_collapse, 0);

    /* ViewPort */
    rb_define_singleton_method(gViewPort, "new", vport_s_new, -1);
    rb_define_method(gViewPort, "get_hadjustment", vport_get_hadj, 0);
    rb_define_method(gViewPort, "get_vadjustment", vport_get_vadj, 0);
    rb_define_method(gViewPort, "set_hadjustment", vport_set_hadj, 1);
    rb_define_method(gViewPort, "set_vadjustment", vport_set_vadj, 1);
    rb_define_method(gViewPort, "set_shadow_type", vport_set_shadow, 1);

    /* AcceleratorTable */
    /* Style */

    /* Gtk module */
    rb_define_module_function(mGtk, "main", gtk_m_main, 0);
    rb_define_module_function(mGtk, "timeout_add", timeout_add, -1);
    rb_define_module_function(mGtk, "timeout_remove", timeout_remove, 1);
    rb_define_module_function(mGtk, "idle_add", idle_add, -1);
    rb_define_module_function(mGtk, "idle_remove", idle_remove, 1);

    rb_define_module_function(mGtk, "set_warning_handler",
			      set_warning_handler, -1);
    rb_define_module_function(mGtk, "set_message_handler",
			      set_message_handler, -1);
    rb_define_module_function(mGtk, "set_print_handler",
			      set_print_handler, -1);

    /* Gdk module */
    /* GdkFont */
    rb_define_method(gdkFont, "==", gdkfnt_equal, 1);

    /* GdkBitmap */
    rb_define_singleton_method(gdkBitmap, "new", gdkbmap_s_new, 3);
    rb_define_singleton_method(gdkBitmap, "create_from_data",
			       gdkbmap_create_from_data, 4);

    /* GdkPixmap */
    rb_define_singleton_method(gdkPixmap, "new", gdkpmap_s_new, 4);
    rb_define_singleton_method(gdkPixmap, "create_from_xpm",
			       gdkpmap_create_from_xpm, 3);
    rb_define_singleton_method(gdkPixmap, "create_from_xpm_d",
			       gdkpmap_create_from_xpm, 3);

    /* GdkWindow */

    /* GdkImage */

    rb_define_const(mGtk, "VISIBLE", INT2FIX(GTK_VISIBLE));
    rb_define_const(mGtk, "MAPPED", INT2FIX(GTK_MAPPED));
    rb_define_const(mGtk, "UNMAPPED", INT2FIX(GTK_UNMAPPED));
    rb_define_const(mGtk, "REALIZED", INT2FIX(GTK_REALIZED));
    rb_define_const(mGtk, "SENSITIVE", INT2FIX(GTK_SENSITIVE));
    rb_define_const(mGtk, "PARENT_SENSITIVE", INT2FIX(GTK_PARENT_SENSITIVE));
    rb_define_const(mGtk, "NO_WINDOW", INT2FIX(GTK_NO_WINDOW));
    rb_define_const(mGtk, "HAS_FOCUS", INT2FIX(GTK_HAS_FOCUS));
    rb_define_const(mGtk, "CAN_FOCUS", INT2FIX(GTK_CAN_FOCUS));
    rb_define_const(mGtk, "HAS_DEFAULT", INT2FIX(GTK_HAS_DEFAULT));
    rb_define_const(mGtk, "CAN_DEFAULT", INT2FIX(GTK_CAN_DEFAULT));
    rb_define_const(mGtk, "PROPAGATE_STATE", INT2FIX(GTK_PROPAGATE_STATE));
    rb_define_const(mGtk, "ANCHORED", INT2FIX(GTK_ANCHORED));
    rb_define_const(mGtk, "BASIC", INT2FIX(GTK_BASIC));
    rb_define_const(mGtk, "USER_STYLE", INT2FIX(GTK_USER_STYLE));
    rb_define_const(mGtk, "GRAB_ALL", INT2FIX(GTK_GRAB_ALL));
    rb_define_const(mGtk, "REDRAW_PENDING", INT2FIX(GTK_REDRAW_PENDING));
    rb_define_const(mGtk, "RESIZE_PENDING", INT2FIX(GTK_RESIZE_PENDING));
    rb_define_const(mGtk, "RESIZE_NEEDED", INT2FIX(GTK_RESIZE_NEEDED));
    rb_define_const(mGtk, "HAS_SHAPE_MASK", INT2FIX(GTK_HAS_SHAPE_MASK));

    /* GtkWindowType */
    rb_define_const(mGtk, "WINDOW_TOPLEVEL", INT2FIX(GTK_WINDOW_TOPLEVEL));
    rb_define_const(mGtk, "WINDOW_DIALOG", INT2FIX(GTK_WINDOW_DIALOG));
    rb_define_const(mGtk, "WIN_POS_NONE", INT2FIX(GTK_WIN_POS_NONE));
    rb_define_const(mGtk, "WIN_POS_CENTER", INT2FIX(GTK_WIN_POS_CENTER));
    rb_define_const(mGtk, "WIN_POS_MOUSE", INT2FIX(GTK_WIN_POS_MOUSE));

    /* GtkDirectionType */
    rb_define_const(mGtk, "DIR_TAB_FORWARD", INT2FIX(GTK_DIR_TAB_FORWARD));
    rb_define_const(mGtk, "DIR_TAB_BACKWARD", INT2FIX(GTK_DIR_TAB_BACKWARD));
    rb_define_const(mGtk, "DIR_UP", INT2FIX(GTK_DIR_UP));
    rb_define_const(mGtk, "DIR_DOWN", INT2FIX(GTK_DIR_DOWN));
    rb_define_const(mGtk, "DIR_LEFT", INT2FIX(GTK_DIR_LEFT));
    rb_define_const(mGtk, "DIR_RIGHT", INT2FIX(GTK_DIR_RIGHT));

    /* GtkPolicyType */
    rb_define_const(mGtk, "POLICY_ALWAYS", INT2FIX(GTK_POLICY_ALWAYS));
    rb_define_const(mGtk, "POLICY_AUTOMATIC", INT2FIX(GTK_POLICY_AUTOMATIC));

    /* GtkSelectionMode */
    rb_define_const(mGtk, "SELECTION_SINGLE", INT2FIX(GTK_SELECTION_SINGLE));
    rb_define_const(mGtk, "SELECTION_BROWSE", INT2FIX(GTK_SELECTION_BROWSE));
    rb_define_const(mGtk, "SELECTION_MULTIPLE", INT2FIX(GTK_SELECTION_MULTIPLE));
    rb_define_const(mGtk, "SELECTION_EXTENDED", INT2FIX(GTK_SELECTION_EXTENDED));
    /* GtkPositionType */
    rb_define_const(mGtk, "POS_LEFT", INT2FIX(GTK_POS_LEFT));
    rb_define_const(mGtk, "POS_RIGHT", INT2FIX(GTK_POS_RIGHT));
    rb_define_const(mGtk, "POS_TOP", INT2FIX(GTK_POS_TOP));
    rb_define_const(mGtk, "POS_BOTTOM", INT2FIX(GTK_POS_BOTTOM));

    /* GtkShadowType */
    rb_define_const(mGtk, "SHADOW_NONE", INT2FIX(GTK_SHADOW_NONE));
    rb_define_const(mGtk, "SHADOW_IN", INT2FIX(GTK_SHADOW_IN));
    rb_define_const(mGtk, "SHADOW_OUT", INT2FIX(GTK_SHADOW_OUT));
    rb_define_const(mGtk, "SHADOW_ETCHED_IN", INT2FIX(GTK_SHADOW_ETCHED_IN));
    rb_define_const(mGtk, "SHADOW_ETCHED_OUT", INT2FIX(GTK_SHADOW_ETCHED_OUT));
    /* GtkStateType */
    rb_define_const(mGtk, "STATE_NORMAL", INT2FIX(GTK_STATE_NORMAL));
    rb_define_const(mGtk, "STATE_ACTIVE", INT2FIX(GTK_STATE_ACTIVE));
    rb_define_const(mGtk, "STATE_PRELIGHT", INT2FIX(GTK_STATE_PRELIGHT));
    rb_define_const(mGtk, "STATE_SELECTED", INT2FIX(GTK_STATE_SELECTED));
    rb_define_const(mGtk, "STATE_INSENSITIVE", INT2FIX(GTK_STATE_INSENSITIVE));
    /* GtkAttachOptions */
    rb_define_const(mGtk, "EXPAND", INT2FIX(GTK_EXPAND));
    rb_define_const(mGtk, "SHRINK", INT2FIX(GTK_SHRINK));
    rb_define_const(mGtk, "FILL", INT2FIX(GTK_FILL));
    /* GtkSubmenuDirection */
    rb_define_const(mGtk, "DIRECTION_LEFT", INT2FIX(GTK_DIRECTION_LEFT));
    rb_define_const(mGtk, "DIRECTION_RIGHT", INT2FIX(GTK_DIRECTION_RIGHT));
    /* GtkSubmenuPlacement */
    rb_define_const(mGtk, "TOP_BOTTOM", INT2FIX(GTK_TOP_BOTTOM));
    rb_define_const(mGtk, "LEFT_RIGHT", INT2FIX(GTK_LEFT_RIGHT));
    /* GtkMetricType */
    rb_define_const(mGtk, "PIXELS", INT2FIX(GTK_PIXELS));
    rb_define_const(mGtk, "INCHES", INT2FIX(GTK_INCHES));
    rb_define_const(mGtk, "CENTIMETERS", INT2FIX(GTK_CENTIMETERS));

    /* GtkArrowType */
    rb_define_const(mGtk, "ARROW_UP", INT2FIX(GTK_ARROW_UP));
    rb_define_const(mGtk, "ARROW_DOWN", INT2FIX(GTK_ARROW_DOWN));
    rb_define_const(mGtk, "ARROW_LEFT", INT2FIX(GTK_ARROW_LEFT));
    rb_define_const(mGtk, "ARROW_RIGHT", INT2FIX(GTK_ARROW_RIGHT));

    /* GtkPreviewType */
    rb_define_const(mGtk, "PREVIEW_COLOR", INT2FIX(GTK_PREVIEW_COLOR));
    rb_define_const(mGtk, "PREVIEW_GRAYSCALE", INT2FIX(GTK_PREVIEW_GRAYSCALE));

    rb_define_const(mGtk, "BUTTONBOX_DEFAULT", INT2FIX(GTK_BUTTONBOX_DEFAULT));
    rb_define_const(mGtk, "BUTTONBOX_SPREAD", INT2FIX(GTK_BUTTONBOX_SPREAD));
    rb_define_const(mGtk, "BUTTONBOX_EDGE", INT2FIX(GTK_BUTTONBOX_EDGE));
    rb_define_const(mGtk, "BUTTONBOX_START", INT2FIX(GTK_BUTTONBOX_START));
    rb_define_const(mGtk, "BUTTONBOX_END", INT2FIX(GTK_BUTTONBOX_END));

    /* GtkToolbarStyle */
    rb_define_const(mGtk, "TOOLBAR_ICONS", INT2FIX(GTK_TOOLBAR_ICONS));
    rb_define_const(mGtk, "TOOLBAR_TEXT", INT2FIX(GTK_TOOLBAR_TEXT));
    rb_define_const(mGtk, "TOOLBAR_BOTH", INT2FIX(GTK_TOOLBAR_BOTH));

    /* GtkOrientation */
    rb_define_const(mGtk, "ORIENTATION_HORIZONTAL", INT2FIX(GTK_ORIENTATION_HORIZONTAL));
    rb_define_const(mGtk, "ORIENTATION_VERTICAL", INT2FIX(GTK_ORIENTATION_VERTICAL));

    /* GdkExtensionMode */
    rb_define_const(mGdk, "EXTENSION_EVENTS_NONE", INT2FIX(GDK_EXTENSION_EVENTS_NONE));
    rb_define_const(mGdk, "EXTENSION_EVENTS_ALL", INT2FIX(GDK_EXTENSION_EVENTS_ALL));
    rb_define_const(mGdk, "EXTENSION_EVENTS_CURSOR", INT2FIX(GDK_EXTENSION_EVENTS_CURSOR));

    argc = RARRAY(rb_argv)->len;
    argv = ALLOCA_N(char*,argc+1);
    argv[0] = RSTRING(rb_argv0)->ptr;
    for (i=0;i<argc;i++) {
	if (TYPE(RARRAY(rb_argv)->ptr[i]) == T_STRING) {
	    argv[i+1] = RSTRING(RARRAY(rb_argv)->ptr[i])->ptr;
	}
	else {
	    argv[i+1] = "";
	}
    }
    argc++;
    {
	/* Gdk modifies sighandlers, sigh */
	RETSIGTYPE (*sigfunc[7])();

	sigfunc[0] = signal(SIGHUP, SIG_IGN);
	sigfunc[1] = signal(SIGINT, SIG_IGN);
	sigfunc[2] = signal(SIGQUIT, SIG_IGN);
	sigfunc[3] = signal(SIGBUS, SIG_IGN);
	sigfunc[4] = signal(SIGSEGV, SIG_IGN);
	sigfunc[5] = signal(SIGPIPE, SIG_IGN);
	sigfunc[6] = signal(SIGTERM, SIG_IGN);

	gdk_init(&argc, &argv);

	signal(SIGHUP,  sigfunc[0]);
	signal(SIGINT,  sigfunc[1]);
	signal(SIGQUIT, sigfunc[2]);
	signal(SIGBUS,  sigfunc[3]);
	signal(SIGSEGV, sigfunc[4]);
	signal(SIGPIPE, sigfunc[5]);
	signal(SIGTERM, sigfunc[6]);
    }

    for (i=1;i<argc;i++) {
	RARRAY(rb_argv)->ptr[i] = str_taint(str_new2(argv[i]));
    }
    RARRAY(rb_argv)->len = argc-1;

    id_gtkdata = rb_intern("gtkdata");
    id_relatives = rb_intern("relatives");
    id_call = rb_intern("call");
    gtk_idle_add((GtkFunction)idle, 0);

    g_set_error_handler(gtkerr);
    g_set_warning_handler(gtkerr);
    rb_global_variable(&warn_handler);
    rb_global_variable(&mesg_handler);
    rb_global_variable(&print_handler);
}
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: $
@


1.1.1.1
log
@
@
text
@@


1.1.1.1.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 04:14:49 $
@


1.1.1.1.2.2
log
@Mon Jan 19 14:06:13 JST 1998
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:59 $
d199 6
a204 1
    /* just a type mark */
d208 2
a209 3
delete_gobject(gtkobj, obj)
    GtkObject *gtkobj;
    VALUE obj;
d211 1
a211 6
    struct RData *data;

    data = RDATA(rb_ivar_get(obj, id_gtkdata));
    data->dfree = 0;
    data->data = 0;
    ary_delete(gtk_object_list, obj);
d226 1
a226 2
    gtk_signal_connect(gtkobj, "destroy",
		       (GtkSignalFunc)delete_gobject, (gpointer)obj);
@


1.1.1.1.2.3
log
@Tue Jan 20 15:08:03 JST 1998
@
text
@d6 1
a6 1
  $Date: 1998/01/19 05:08:23 $
d122 1
a122 1
ID id_gtkdata, id_relatives, id_call, id_init;
d199 1
a199 1
    /* just for type mark */
d215 3
a217 3
static void
set_gobject(obj, gtkobj)
    VALUE obj;
d220 1
a229 11
}

static VALUE
make_gobject(klass, gtkobj)
    VALUE klass;
    GtkObject *gtkobj;
{
    VALUE obj = obj_alloc(klass);

    set_gobject(obj, gtkobj);
    rb_funcall(obj, id_init, 0, 0);
a232 8
static void
set_widget(obj, widget)
    VALUE obj;
    GtkWidget *widget;
{
    set_gobject(obj, GTK_OBJECT(widget));
}

a237 2
    VALUE obj;

a251 2
    VALUE obj;

d253 1
a253 4
    obj = Data_Wrap_Struct(gStyle, 0, free_gstyle, style);
    rb_funcall(obj, id_init, 0, 0);

    return obj;
a281 2
    VALUE obj;

d283 1
a283 4
    obj = Data_Wrap_Struct(gAcceleratorTable, 0, free_gaccel, tbl);
    rb_funcall(obj, id_init, 0, 0);

    return obj;
d306 1
a306 4
    VALUE obj = Data_Wrap_Struct(gAcceleratorTable, 0, 0, info);

    rb_funcall(obj, id_init, 0, 0);
    return obj;
a357 2
    VALUE obj;

d359 1
a359 3
    obj = Data_Wrap_Struct(klass, 0, free_ttips, tips);
    rb_funcall(obj, id_init, 0, 0);
    return obj;
a388 2
    VALUE obj;

d390 1
a390 3
    obj = Data_Wrap_Struct(gdkFont, 0, free_gdkfont, font);
    rb_funcall(obj, id_init, 0, 0);
    return obj;
a436 1
    rb_funcall(data, id_init, 0, 0);
d816 1
a816 1
gobj_initialize(argc, argv, self)
d1063 1
a1063 1
align_initialize(self, xalign, yalign, xscale, yscale)
d1066 4
a1069 5
    set_widget(self, gtk_alignment_new(NUM2DBL(xalign),
				       NUM2DBL(yalign),
				       NUM2DBL(xscale),
				       NUM2DBL(yscale)));
    return Qnil;
d1107 1
a1107 1
arrow_initialize(self, arrow_t, shadow_t)
d1110 2
a1111 3
    set_widget(self, gtk_arrow_new((GtkArrowType)NUM2INT(arrow_t),
				   (GtkShadowType)NUM2INT(shadow_t)));
    return Qnil;
d1127 1
a1127 1
frame_initialize(self, label)
d1130 1
a1130 2
    set_widget(self, gtk_frame_new(get_cstring(label)));
    return Qnil;
d1168 1
a1168 1
aframe_initialize(self, label, xalign, yalign, ratio, obey_child)
d1171 5
a1175 6
    set_widget(self, gtk_aspect_frame_new(get_cstring(label),
					  NUM2DBL(xalign),
					  NUM2DBL(yalign),
					  NUM2DBL(ratio),
					  RTEST(obey_child)));
    return Qnil;
d1191 1
a1191 1
adj_initialize(self, value, lower, upper, step_inc, page_inc, page_size)
d1194 6
a1199 7
    set_widget(self, gtk_adjustment_new(NUM2DBL(value),
					NUM2DBL(lower),
					NUM2DBL(upper),
					NUM2DBL(step_inc),
					NUM2DBL(page_inc),
					NUM2DBL(page_size)));
    return Qnil;
d1877 1
a1877 1
clist_initialize(self, titles)
d1890 1
a1890 2
    set_widget(self, gtk_clist_new(len, buf));
    return Qnil;
d2194 1
a2194 1
gwin_initialize(self, type)
d2197 1
a2197 2
    set_widget(self, gtk_window_new(NUM2INT(type)));
    return Qnil;
d2288 1
a2288 1
dialog_initialize(self)
d2291 1
a2291 2
    set_widget(self, gtk_dialog_new());
    return Qnil;
d2295 1
a2295 1
fsel_initialize(self, title)
d2298 1
a2298 2
    set_widget(self, gtk_file_selection_new(get_cstring(title)));
    return Qnil;
d2375 1
a2375 1
label_initialize(self, label)
d2378 1
a2378 2
    set_widget(self, gtk_label_new(get_cstring(label)));
    return Qnil;
d2382 1
a2382 1
list_initialize(self)
d2385 1
a2385 2
    set_widget(self, gtk_list_new());
    return Qnil;
d2566 1
a2566 1
litem_initialize(argc, argv, self)
d2581 1
a2581 2
    set_widget(self, widget);
    return Qnil;
d2626 1
a2626 1
menu_initialize(self)
d2629 1
a2629 2
    set_widget(self, gtk_menu_new());
    return Qnil;
d2712 1
a2712 2
    set_widget(gMenuItem, mitem);
    return Qnil;
d2737 1
a2737 1
mbar_initialize(self)
d2740 1
a2740 2
    set_widget(self, gtk_menu_bar_new());
    return Qnil;
d2774 1
a2774 1
mitem_initialize(argc, argv, self)
d2788 1
a2788 2
    set_widget(self, widget);
    return Qnil;
d2886 1
a2886 1
cmitem_initialize(argc, argv, self)
d2900 1
a2900 2
    set_widget(self, widget);
    return Qnil;
d2936 1
a2936 1
rmitem_initialize(argc, argv, self)
d2968 1
a2968 2
    set_widget(self, widget);
    return Qnil;
d2981 1
a2981 1
note_initialize(self)
d2984 1
a2984 2
    set_widget(self, gtk_notebook_new());
    return Qnil;
d3131 1
a3131 1
omenu_initialize(self)
d3134 1
a3134 2
    set_widget(self, gtk_option_menu_new());
    return Qnil;
d3176 1
a3176 1
image_initialize(self, val, mask)
d3179 2
a3180 3
    set_widget(self, gtk_image_new(get_gdkimage(val),
				   (GdkBitmap*)get_gdkpixmap(mask)));
    return Qnil;
d3208 1
a3208 1
preview_initialize(self, type)
d3211 1
a3211 2
    set_widget(self, gtk_preview_new((GtkPreviewType)NUM2INT(type)));
    return Qnil;
d3301 1
a3301 1
pbar_initialize(self)
d3304 1
a3304 2
    set_widget(self, gtk_progress_bar_new());
    return Qnil;
d3319 1
a3319 1
scwin_initialize(argc, argv, self)
d3332 1
a3332 2
    set_widget(self, gtk_scrolled_window_new(h_adj, v_adj));
    return Qnil;
d3349 1
a3349 1
tbl_initialize(argc, argv, self)
d3356 1
a3356 1
    set_widget(self, gtk_table_new(NUM2INT(row),
a3358 1
    return Qnil;
d3432 1
a3432 1
txt_initialize(argc, argv, self)
d3445 1
a3445 2
    set_widget(self, gtk_text_new(h_adj, v_adj));
    return Qnil;
d3559 1
a3559 1
tbar_initialize(argc, argv, self)
d3572 1
a3572 2
    set_widget(self, gtk_toolbar_new(orientation, style));
    return Qnil;
d3706 1
a3706 1
ttips_initialize(self)
d3750 1
a3750 1
tree_initialize(self)
d3753 1
a3753 2
    set_widget(self, gtk_tree_new());
    return Qnil;
d3787 1
a3787 1
titem_initialize(argc, argv, self)
d3802 1
a3802 2
    set_widget(self, widget);
    return Qnil;
d3856 1
a3856 1
vport_initialize(argc, argv, self)
d3869 1
a3869 2
    set_widget(self, gtk_viewport_new(h_adj, v_adj));
    return Qnil;
d3931 1
a3931 1
button_initialize(argc, argv, self)
d3946 1
a3946 2
    set_widget(self, widget);
    return Qnil;
d4000 1
a4000 1
tbtn_initialize(argc, argv, self)
d4015 1
a4015 2
    set_widget(self, widget);
    return Qnil;
d4049 1
a4049 1
cbtn_initialize(argc, argv, self)
d4064 1
a4064 2
    set_widget(self, widget);
    return Qnil;
d4068 1
a4068 1
rbtn_initialize(argc, argv, self)
d4100 1
a4100 2
    set_widget(self, widget);
    return Qnil;
d4164 1
a4164 1
vbox_initialize(argc, argv, self)
d4175 1
a4175 2
    set_widget(self, widget);
    return Qnil;
d4179 1
a4179 1
colorsel_initialize(self)
d4182 1
a4182 2
    set_widget(self, gtk_color_selection_new());
    return Qnil;
d4243 1
a4243 1
cdialog_initialize(self, title)
d4250 1
a4250 2
    set_widget(self, gtk_color_selection_dialog_new(t));
    return Qnil;
d4254 1
a4254 1
pixmap_initialize(self, val, mask)
d4257 1
a4257 1
    set_widget(self, gtk_pixmap_new(get_gdkpixmap(val),
a4258 1
    return Qnil;
d4287 1
a4287 1
darea_initialize(self)
d4290 1
a4290 2
    set_widget(self, gtk_drawing_area_new());
    return Qnil;
d4304 1
a4304 1
entry_initialize(self)
d4307 1
a4307 2
    set_widget(self, gtk_entry_new());
    return Qnil;
d4323 1
a4323 1
eventbox_initialize(self)
d4326 1
a4326 2
    set_widget(self, gtk_event_box_new());
    return Qnil;
d4330 1
a4330 1
fixed_initialize(self)
d4333 1
a4333 2
    set_widget(self, gtk_fixed_new());
    return Qnil;
d4357 1
a4357 1
gamma_initialize(self)
d4360 1
a4360 2
    set_widget(self, gtk_gamma_curve_new());
    return Qnil;
d4373 1
a4373 1
hbbox_initialize(self)
d4376 1
a4376 2
    set_widget(self, gtk_hbutton_box_new());
    return Qnil;
d4414 1
a4414 1
vbbox_initialize(self)
d4417 1
a4417 2
    set_widget(self, gtk_vbutton_box_new());
    return Qnil;
d4455 1
a4455 1
hbox_initialize(argc, argv, self)
d4466 1
a4466 2
    set_widget(self, widget);
    return Qnil;
d4510 1
a4510 1
hpaned_initialize(self)
d4513 1
a4513 2
    set_widget(self, gtk_hpaned_new());
    return Qnil;
d4517 1
a4517 1
vpaned_initialize(self)
d4520 1
a4520 2
    set_widget(self, gtk_vpaned_new());
    return Qnil;
d4569 1
a4569 1
hruler_initialize(self)
d4571 1
a4571 2
    set_widget(self, gtk_hruler_new());
    return Qnil;
d4575 1
a4575 1
vruler_initialize(self)
d4577 1
a4577 2
    set_widget(self, gtk_vruler_new());
    return Qnil;
d4808 1
a4808 1
hscale_initialize(argc, argv, self)
d4819 1
a4819 2
    set_widget(self, gtk_hscale_new(adj));
    return Qnil;
d4823 1
a4823 1
vscale_initialize(argc, argv, self)
d4834 1
a4834 2
    set_widget(self, gtk_vscale_new(adj));
    return Qnil;
d4838 1
a4838 1
hscrollbar_initialize(argc, argv, self)
d4849 1
a4849 2
    set_widget(self, gtk_hscrollbar_new(adj));
    return Qnil;
d4853 1
a4853 1
vscrollbar_initialize(argc, argv, self)
d4864 1
a4864 2
    set_widget(self, gtk_vscrollbar_new(adj));
    return Qnil;
d4868 1
a4868 1
hsep_initialize(self)
d4871 1
a4871 2
    set_widget(self, gtk_hseparator_new());
    return Qnil;
d4875 1
a4875 1
vsep_initialize(self)
d4878 1
a4878 2
    set_widget(self, gtk_vseparator_new());
    return Qnil;
d4882 1
a4882 1
idiag_initialize(self)
d4885 1
a4885 2
    set_widget(self, gtk_input_dialog_new());
    return Qnil;
d5149 1
a5149 2
    rb_define_method(gObject, "initialize", gobj_initialize, -1);
    rb_define_method(gObject, "initialize", gobj_initialize, -1);
d5259 1
a5259 1
    rb_define_method(gAlignment, "initialize", align_initialize, 4);
d5267 2
a5268 2
    rb_define_method(gArrow, "initialize", arrow_initialize, 2);
    rb_define_method(gArrow, "set", arrow_initialize, 2);
d5271 1
a5271 1
    rb_define_method(gFrame, "initialize", frame_initialize, 1);
d5277 1
a5277 1
    rb_define_method(gAspectFrame, "initialize", aframe_initialize, 5);
d5284 1
a5284 1
    rb_define_method(gAdjustment, "initialize", adj_initialize, 6);
d5291 1
a5291 1
    rb_define_method(gButton, "initialize", button_initialize, -1);
d5299 1
a5299 1
    rb_define_method(gTButton, "initialize", tbtn_initialize, -1);
d5305 1
a5305 1
    rb_define_method(gCButton, "initialize", cbtn_initialize, -1);
d5308 1
a5308 1
    rb_define_method(gCButton, "initialize", rbtn_initialize, -1);
d5330 1
a5330 1
    rb_define_method(gCList, "initialize", clist_initialize, 1);
d5358 1
a5358 1
    rb_define_method(gWindow, "initialize", gwin_initialize, 1);
d5369 1
a5369 1
    rb_define_method(gDialog, "initialize", dialog_initialize, 0);
d5372 1
a5372 1
    rb_define_method(gFileSel, "initialize", fsel_initialize, 1);
d5380 1
a5380 1
    rb_define_method(gVBox, "initialize", vbox_initialize, -1);
d5383 1
a5383 1
    rb_define_method(gColorSel, "initialize", colorsel_initialize, 0);
d5390 1
a5390 1
    rb_define_method(gColorSelDialog, "initialize", cdialog_initialize, 1);
d5393 1
a5393 1
    rb_define_method(gImage, "initialize", image_initialize, 2);
d5398 1
a5398 1
    rb_define_method(gDrawArea, "initialize", darea_initialize, 0);
d5402 1
a5402 1
    rb_define_method(gEntry, "initialize", entry_initialize, 0);
d5406 1
a5406 1
    rb_define_method(gEventBox, "initialize", eventbox_initialize, 0);
d5409 1
a5409 1
    rb_define_method(gFixed, "initialize", fixed_initialize, 0);
d5414 1
a5414 1
    rb_define_method(gGamma, "initialize", gamma_initialize, 0);
d5418 1
a5418 1
    rb_define_method(gHBBox, "initialize", hbbox_initialize, 0);
d5429 1
a5429 1
    rb_define_method(gVBBox, "initialize", vbbox_initialize, 0);
d5440 1
a5440 1
    rb_define_method(gHBox, "initialize", hbox_initialize, -1);
d5449 1
a5449 1
    rb_define_method(gHPaned, "initialize", hpaned_initialize, 0);
d5452 1
a5452 1
    rb_define_method(gVPaned, "initialize", vpaned_initialize, 0);
d5461 1
a5461 1
    rb_define_method(gHRuler, "initialize", hruler_initialize, 0);
d5464 1
a5464 1
    rb_define_method(gVRuler, "initialize", vruler_initialize, 0);
d5494 1
a5494 1
    rb_define_method(gHScale, "initialize", hscale_initialize, -1);
d5497 1
a5497 1
    rb_define_method(gVScale, "initialize", vscale_initialize, -1);
d5503 1
a5503 1
    rb_define_method(gHScrollbar, "initialize", hscrollbar_initialize, -1);
d5506 1
a5506 1
    rb_define_method(gVScrollbar, "initialize", vscrollbar_initialize, -1);
d5512 1
a5512 1
    rb_define_method(gHSeparator, "initialize", hsep_initialize, 0);
d5515 1
a5515 1
    rb_define_method(gVSeparator, "initialize", vsep_initialize, 0);
d5518 1
a5518 1
    rb_define_method(gInputDialog, "initialize", idiag_initialize, 0);
d5521 1
a5521 1
    rb_define_method(gLabel, "initialize", label_initialize, 1);
d5524 1
a5524 1
    rb_define_method(gList, "initialize", list_initialize, 0);
d5545 1
a5545 1
    rb_define_method(gListItem, "initialize", litem_initialize, -1);
d5554 1
a5554 1
    rb_define_method(gMenu, "initialize", menu_initialize, 0);
d5565 1
a5565 1
    rb_define_method(gMenuBar, "initialize", mbar_initialize, 0);
d5571 1
a5571 1
    rb_define_method(gMenuItem, "initialize", mitem_initialize, -1);
d5583 1
a5583 1
    rb_define_method(gCMenuItem, "initialize", cmitem_initialize, -1);
d5589 1
a5589 1
    rb_define_method(gRMenuItem, "initialize", rmitem_initialize, -1);
d5593 1
a5593 1
    rb_define_method(gNotebook, "initialize", note_initialize, 0);
d5611 1
a5611 1
    rb_define_method(gOptionMenu, "initialize", omenu_initialize, 0);
d5618 1
a5618 1
    rb_define_method(gPixmap, "initialize", pixmap_initialize, 2);
d5623 1
a5623 1
    rb_define_method(gPreview, "initialize", preview_initialize, 1);
d5641 1
a5641 1
    rb_define_method(gProgressBar, "initialize", pbar_initialize, 0);
d5645 1
a5645 1
    rb_define_method(gScrolledWin, "initialize", scwin_initialize, -1);
d5649 1
a5649 1
    rb_define_method(gTable, "initialize", tbl_initialize, -1);
d5657 1
a5657 1
    rb_define_method(gText, "initialize", txt_initialize, -1);
d5670 1
a5670 1
    rb_define_method(gToolbar, "initialize", tbar_initialize, -1);
d5683 1
a5683 1
    rb_define_method(gTooltips, "initialize", ttips_initialize, 0);
d5690 1
a5690 1
    rb_define_method(gTree, "initialize", tree_initialize, 0);
d5696 1
a5696 1
    rb_define_method(gTreeItem, "initialize", titem_initialize, -1);
d5704 1
a5704 1
    rb_define_method(gViewPort, "initialize", vport_initialize, -1);
d5733 1
a5733 1
    rb_define_method(gdkBitmap, "new", gdkbmap_s_new, 3);
d5738 1
a5738 1
    rb_define_method(gdkPixmap, "new", gdkpmap_s_new, 4);
d5898 1
a5898 1
    id_init = rb_intern("initialize");
@


1.1.1.1.2.4
log
@initialize made private
@
text
@d6 1
a6 1
  $Date: 1998/01/20 06:10:11 $
d5248 1
@


1.1.1.1.2.5
log
@use STR2CSTR
@
text
@d6 1
a6 1
  $Date: 1998/01/22 08:32:48 $
d126 9
d1174 1
a1174 1
    set_widget(self, gtk_frame_new(STR2CSTR(label)));
d1184 1
a1184 1
    gtk_frame_set_label(GTK_FRAME(widget), STR2CSTR(label));
d1216 1
a1216 1
    set_widget(self, gtk_aspect_frame_new(STR2CSTR(label),
d1393 1
a1393 1
				   STR2CSTR(sig),
d1405 1
a1405 1
				  STR2CSTR(sig));
d1523 1
a1523 1
    gtk_widget_set_name(get_widget(self), STR2CSTR(name));
d2002 1
a2002 1
			       STR2CSTR(title));
d2071 1
a2071 1
		       STR2CSTR(text));
d2096 1
a2096 1
			  STR2CSTR(text),
d2266 1
a2266 1
    gtk_window_set_title(GTK_WINDOW(widget), STR2CSTR(title));
d2289 2
a2290 2
			   STR2CSTR(wmclass1),
			   STR2CSTR(wmclass2));
d2348 1
a2348 1
    set_widget(self, gtk_file_selection_new(STR2CSTR(title)));
d2429 1
a2429 1
    set_widget(self, gtk_label_new(STR2CSTR(label)));
d2628 1
a2628 1
	widget = gtk_list_item_new_with_label(STR2CSTR(label));
d2839 1
a2839 1
	widget = gtk_menu_item_new_with_label(STR2CSTR(label));
d2952 1
a2952 1
	widget = gtk_check_menu_item_new_with_label(STR2CSTR(label));
d3655 2
a3656 2
			    STR2CSTR(text),
			    STR2CSTR(ttext),
d3674 2
a3675 2
			     STR2CSTR(text),
			     STR2CSTR(ttext),
d3693 2
a3694 2
			    STR2CSTR(text),
			    STR2CSTR(ttext),
@


1.1.1.1.2.6
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/22 10:01:05 $
a5985 1
    id_call = rb_intern("call");
@


1.1.1.1.2.7
log
@gtk 0.99.3
@
text
@d6 1
a6 1
  $Date: 1998/01/26 05:18:10 $
d1928 1
a1928 1
    set_widget(self, gtk_clist_new(len));
d5853 1
a5853 1
/*    rb_define_const(mGtk, "GRAB_ALL", INT2FIX(GTK_GRAB_ALL)); */
@


1.1.1.1.2.8
log
@gtk 0.99.3_2
@
text
@d6 1
a6 1
  $Date: 1998/01/29 08:22:20 $
d1918 2
a1919 1
    GtkWidget *widget;
d1921 6
a1926 15
    if (TYPE(titles) == T_ARRAY) {
	char **buf;
	int i, len;

	Check_Type(titles, T_ARRAY);
	len = RARRAY(titles)->len;
	buf = ALLOCA_N(char*, len);
	for (i=0; i<len; i++) {
	    Check_Type(RARRAY(titles)->ptr[i], T_STRING);
	    buf[i] = RSTRING(RARRAY(titles)->ptr[i])->ptr;
	}
	widget = gtk_clist_new_with_titles(len, buf);
    }
    else {
	widget = gtk_clist_new(NUM2INT(titles));
d1928 1
a1928 2
    set_widget(self, widget);

a1985 60
clist_col_titles_show(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_column_titles_show(GTK_CLIST(widget));
    return self;
}

static VALUE
clist_col_titles_hide(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_column_titles_hide(GTK_CLIST(widget));
    return self;
}

static VALUE
clist_col_title_active(self, column)
    VALUE self, column;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_column_title_active(GTK_CLIST(widget), NUM2INT(column));
    return self;
}

static VALUE
clist_col_title_passive(self, column)
    VALUE self, column;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_column_title_passive(GTK_CLIST(widget), NUM2INT(column));
    return self;
}

static VALUE
clist_col_titles_active(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_column_titles_active(GTK_CLIST(widget));
    return self;
}

static VALUE
clist_col_titles_passive(self)
    VALUE self;
{
    GtkWidget *widget = get_widget(self);

    gtk_clist_column_titles_passive(GTK_CLIST(widget));
    return self;
}

static VALUE
d3640 1
d3648 1
a3648 1
			    get_widget(icon),
d3659 1
d3667 1
a3667 1
			     get_widget(icon),
d3678 1
d3686 1
a3686 1
			    get_widget(icon),
d5420 1
a5420 1
    rb_define_method(gCList, "initialize", clist_initialize, -1);
a5425 6
    rb_define_method(gCList, "column_titles_show", clist_col_titles_show, 0);
    rb_define_method(gCList, "column_titles_hide", clist_col_titles_hide, 0);
    rb_define_method(gCList, "column_title_active", clist_col_title_active, 1);
    rb_define_method(gCList, "column_title_passive", clist_col_title_passive, 1);
    rb_define_method(gCList, "column_titles_active", clist_col_title_active, 0);
    rb_define_method(gCList, "column_titles_passive", clist_col_title_passive, 0);
d5853 1
@


1.1.1.1.2.9
log
@1.1b7 pre2
@
text
@d6 1
a6 1
  $Date: 1998/01/29 08:58:06 $
d350 1
a350 1
signal_callback(widget, data, nparams, params)
d354 1
a354 1
    GtkArg *params;
a370 8
exec_callback(widget, proc)
    GtkWidget *widget;
    VALUE proc;
{
    rb_funcall(proc, id_call, 1, get_value_from_gobject(GTK_OBJECT(widget)));
}

static void
d864 1
d870 1
a870 1
				  signal_callback, (gpointer)handler,
d925 1
a925 1
				  signal_callback, (gpointer)handler,
d950 1
a950 1
				  signal_callback, (gpointer)handler,
d3718 1
a3718 1
			    (gpointer)func);
d3736 1
a3736 1
			     (gpointer)func);
d3754 1
a3754 1
			    (gpointer)func,
@


1.1.1.1.2.10
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/02/10 06:50:17 $
a105 1
static VALUE gdkDrawable;
d124 1
a124 1
static void gobj_mark();
d137 1
a137 1
    if (NIL_P(data) || data->dmark != gobj_mark) {
d187 1
a187 1
gobj_mark(obj)
d213 1
a213 1
    data = Data_Wrap_Struct(cData, gobj_mark, 0, gtkobj);
d247 2
a322 7
static void
free_gtkprevinfo(info)
    GtkPreviewInfo *info;
{
    /* no need to free() */
}

d327 2
a328 1
    VALUE obj = Data_Wrap_Struct(gPreviewInfo, 0, free_gtkprevinfo, info);
d350 29
d458 7
d476 1
a476 1
    data = Data_Wrap_Struct(klass, 0, (void*)-1, copy);
a552 7
static void
free_gdkvisual(visual)
    GdkVisual *visual;
{
    gdk_visual_unref(visual);
}

d557 1
a557 2
    gdk_visual_ref(visual);
    return Data_Wrap_Struct(gdkVisual, 0, free_gdkvisual, visual);
d740 1
a765 64
static VALUE
gdkimage_s_newbmap(klass, visual, data, w, h)
    VALUE klass, visual, data, w, h;
{
    GdkImage *image;

    Check_Type(data, T_STRING);
    if (RSTRING(data)->len < w * h) {
	ArgError("data too short");
    }
    return make_gdkimage(gdk_image_new_bitmap(get_gdkvisual(visual),
					      RSTRING(data)->ptr,
					      NUM2INT(w),NUM2INT(h)));
}

static VALUE
gdkimage_s_new(klass, type, visual, w, h)
    VALUE klass, type, visual, w, h;
{
    GdkImage *image;

    return make_gdkimage(gdk_image_new((GdkImageType)NUM2INT(type),
				       get_gdkvisual(visual),
				       NUM2INT(w),NUM2INT(h)));
}

static VALUE
gdkimage_s_get(klass, win, x, y, w, h)
    VALUE klass, win, x, y, w, h;
{
    GdkImage *image;

    return make_gdkimage(gdk_image_get(get_gdkwindow(win),
				       NUM2INT(x),NUM2INT(y),
				       NUM2INT(w),NUM2INT(h)));
}

static VALUE
gdkimage_put_pixel(self, x, y, pix)
    VALUE self, x, y, pix;
{
    gdk_image_put_pixel(get_gdkimage(self),
			NUM2INT(x),NUM2INT(y),NUM2INT(pix));
    return self;
}

static VALUE
gdkimage_get_pixel(self, x, y)
    VALUE self, x, y;
{
    guint32 pix;

    pix = gdk_image_get_pixel(get_gdkimage(self), NUM2INT(x),NUM2INT(y));
    return INT2NUM(pix);
}

static VALUE
gdkimage_destroy(self)
    VALUE self;
{
    gdk_image_destroy(get_gdkimage(self));
    return Qnil;
}

a856 301
arg_to_value(arg)
    GtkArg *arg;
{
    switch (GTK_FUNDAMENTAL_TYPE(arg->type)) {
      case GTK_TYPE_CHAR:
	return INT2FIX(GTK_VALUE_CHAR(*arg));
	break;

      case GTK_TYPE_BOOL:
      case GTK_TYPE_INT:
      case GTK_TYPE_ENUM:
      case GTK_TYPE_FLAGS:
	return INT2NUM(GTK_VALUE_INT(*arg));
	break;

      case GTK_TYPE_UINT:
	return INT2NUM(GTK_VALUE_UINT(*arg));
	break;
      case GTK_TYPE_LONG:
	return INT2NUM(GTK_VALUE_LONG(*arg));
	break;
      case GTK_TYPE_ULONG:
	return INT2NUM(GTK_VALUE_ULONG(*arg));
	break;

      case GTK_TYPE_FLOAT:
	return float_new(GTK_VALUE_FLOAT(*arg));
	break;

      case GTK_TYPE_STRING:
	return str_new2(GTK_VALUE_STRING(*arg));
	break;

      case GTK_TYPE_OBJECT:
	return get_value_from_gobject(GTK_VALUE_OBJECT(*arg));
	break;
	    
      case GTK_TYPE_SIGNAL:
	/* signal type?? */
	goto unsupported;

      case GTK_TYPE_BOXED:
	if (arg->type == GTK_TYPE_GDK_EVENT) {
	    return make_gdkevent(GTK_VALUE_BOXED(*arg));
	}
#ifdef GTK_TYPE_GDK_COLORMAP
	else if (arg->type == GTK_TYPE_GDK_COLORMAP) {
	    return make_gdkcmap(GTK_VALUE_BOXED(*arg));
	}
#endif
#ifdef GTK_TYPE_GDK_FONT
	else if (arg->type == GTK_TYPE_GDK_FONT) {
	    return make_gdkfont(GTK_VALUE_BOXED(*arg));
	}
#endif
#ifdef GTK_TYPE_GDK_PIXMAP
	else if (arg->type == GTK_TYPE_GDK_PIXMAP) {
	    return make_gdkpixmap(gdkPixmap, GTK_VALUE_BOXED(*arg));
	}
#endif
#ifdef GTK_TYPE_GDK_VISUAL
	else if (arg->type == GTK_TYPE_GDK_VISUAL) {
	    return make_gdkvisual(GTK_VALUE_BOXED(*arg));
	}
#endif
#ifdef GTK_TYPE_ACCELERATOR_TABLE
	else if (arg->type == GTK_TYPE_ACCELERATOR_TABLE) {
	    return make_gtkacceltbl(GTK_VALUE_BOXED(*arg));
	}
#endif
#ifdef GTK_TYPE_STYLE
	else if (arg->type == GTK_TYPE_STYLE) {
	    return make_gstyle(GTK_VALUE_BOXED(*arg));
	}
#endif
#ifdef GTK_TYPE_TOOLTIPS
	else if (arg->type == GTK_TYPE_TOOLTIPS) {
	    return make_ttips(gTooltips, GTK_VALUE_BOXED(*arg));
	}
#endif
	else {
	    goto unsupported;
	}

      case GTK_TYPE_POINTER:
	return get_value_from_gobject(GTK_VALUE_OBJECT(*arg));
	break;

      case GTK_TYPE_INVALID:
      case GTK_TYPE_NONE:
      case GTK_TYPE_FOREIGN:
      case GTK_TYPE_CALLBACK:
      case GTK_TYPE_ARGS:
      case GTK_TYPE_C_CALLBACK:
      unsupported:
      default:
	TypeError("unsupported arg type %s (fundamental type %s)",
		  gtk_type_name(arg->type),
		  gtk_type_name(GTK_FUNDAMENTAL_TYPE(arg->type)));
	break;
    }
}

static void
signal_setup_args(obj, sig, argc, params, args)
    VALUE obj;
    ID sig;
    int argc;
    GtkArg *params;
    VALUE args;
{
    int i;
    char *signame = rb_id2name(sig);

    if (obj_is_kind_of(obj, gWidget)) {
	if (strcmp(signame, "draw") == 0) {
	    ary_push(args, make_gdkrect(GTK_VALUE_POINTER(params[0])));
	    return;
	}
	if (strcmp(signame, "size_request") == 0) {
	    ary_push(args, make_grequisiton(GTK_VALUE_POINTER(params[0])));
	    return;
	}
	if (strcmp(signame, "size_allocate") == 0) {
	    ary_push(args, make_gallocation(GTK_VALUE_POINTER(params[0])));
	    return;
	}
    }
    else if (obj_is_kind_of(obj, gWindow)) {
	if (strcmp(signame, "move_resize") == 0) {
	    ary_push(args, NUM2INT(*GTK_RETLOC_INT(params[0])));
	    ary_push(args, NUM2INT(*GTK_RETLOC_INT(params[1])));
	    ary_push(args, NUM2INT(GTK_VALUE_INT(params[3])));
	    ary_push(args, NUM2INT(GTK_VALUE_INT(params[4])));
	    return;
	}
	if (strcmp(signame, "set_focus") == 0) {
	    ary_push(args, get_value_from_gobject(GTK_VALUE_POINTER(params[0])));
	    return;
	}
    }
    else if (obj_is_kind_of(obj, gEntry)) {
	if (strcmp(signame, "insert_position") == 0) {
	    ary_push(args, NUM2INT(*GTK_RETLOC_INT(params[0])));
	    return;
	}
    }
    else if (obj_is_kind_of(obj, gCList)) {
	if (strcmp(signame, "select_row") == 0) {
	    if (GTK_VALUE_POINTER(params[0]))
		ary_push(args, make_gdkevent(GTK_VALUE_POINTER(params[0])));
	    else
		ary_push(args, Qnil);
	    return;
	}
	if (strcmp(signame, "unselect_row") == 0) {
	    if (GTK_VALUE_POINTER(params[0]))
		ary_push(args, make_gdkevent(GTK_VALUE_POINTER(params[0])));
	    else
		ary_push(args, Qnil);
	    return;
	}
    }

    for (i=0; i<argc; i++) {
	ary_push(args, arg_to_value(params));
	params++;
    }
}

static void
arg_set_value(arg, value)
    GtkArg *arg;
    VALUE value;
{
    char *type = 0;

    switch (GTK_FUNDAMENTAL_TYPE(arg->type)) {
      case GTK_TYPE_NONE:
	break;

      case GTK_TYPE_CHAR:
	*GTK_RETLOC_CHAR(*arg) = NUM2INT(value);
	break;
      case GTK_TYPE_BOOL:
      case GTK_TYPE_INT:
      case GTK_TYPE_ENUM:
      case GTK_TYPE_FLAGS:
	*GTK_RETLOC_INT(*arg) = NUM2INT(value);
	break;
      case GTK_TYPE_UINT:
	*GTK_RETLOC_UINT(*arg) = NUM2INT(value);
	break;
      case GTK_TYPE_LONG:
	*GTK_RETLOC_LONG(*arg) = NUM2INT(value);
	break;
      case GTK_TYPE_ULONG:
	*GTK_RETLOC_ULONG(*arg) = NUM2INT(value);
	break;

      case GTK_TYPE_FLOAT:
	value = rb_Float(value);
	*GTK_RETLOC_FLOAT(*arg) = (float)RFLOAT(value)->value;
	break;

      case GTK_TYPE_STRING:
	*GTK_RETLOC_STRING(*arg) = STR2CSTR(value);
	break;

      case GTK_TYPE_OBJECT:
	*GTK_RETLOC_OBJECT(*arg) = get_gobject(value);
	break;
	    
      case GTK_TYPE_POINTER:
	*GTK_RETLOC_POINTER(*arg) = (gpointer)value;
	break;

      case GTK_TYPE_BOXED:
	if (arg->type == GTK_TYPE_GDK_EVENT)
	    GTK_VALUE_BOXED(*arg) = get_gdkevent(value);
#ifdef GTK_TYPE_GDK_COLORMAP
	else if (arg->type == GTK_TYPE_GDK_COLORMAP)
	    GTK_VALUE_BOXED(*arg) = get_gdkcmap(value);
#endif
#ifdef GTK_TYPE_GDK_FONT
	else if (arg->type == GTK_TYPE_GDK_FONT)
	    GTK_VALUE_BOXED(*arg) = get_gdkfont(value);
#endif
#ifdef GTK_TYPE_GDK_PIXMAP
	else if (arg->type == GTK_TYPE_GDK_PIXMAP)
	    GTK_VALUE_BOXED(*arg) = get_gdkpixmap(value);
#endif
#ifdef GTK_TYPE_GDK_VISUAL
	else if (arg->type == GTK_TYPE_GDK_VISUAL)
	    GTK_VALUE_BOXED(*arg) = get_gdkvisual(value);
#endif
#ifdef GTK_TYPE_ACCELERATOR_TABLE
	else if (arg->type == GTK_TYPE_ACCELERATOR_TABLE)
	    GTK_VALUE_BOXED(*arg) = get_gtkacceltbl(value);
#endif
#ifdef GTK_TYPE_STYLE
	else if (arg->type == GTK_TYPE_STYLE)
	    GTK_VALUE_BOXED(*arg) = get_gstyle(value);
#endif
#ifdef GTK_TYPE_TOOLTIPS
	else if (arg->type == GTK_TYPE_TOOLTIPS)
	    GTK_VALUE_BOXED(*arg) = get_ttips(value);
#endif
	else
	    goto unsupported;

      unsupported:
      case GTK_TYPE_INVALID:
      case GTK_TYPE_FOREIGN:
      case GTK_TYPE_CALLBACK:
      case GTK_TYPE_ARGS:
      case GTK_TYPE_SIGNAL:
      case GTK_TYPE_C_CALLBACK:
      default:
	TypeError("unsupported return type %s (fundamental type %s)",
		  gtk_type_name(arg->type),
		  gtk_type_name(GTK_FUNDAMENTAL_TYPE(arg->type)));
	break;
    }
}

static void
signal_callback(widget, data, nparams, params)
    GtkWidget *widget;
    VALUE data;
    int nparams;
    GtkArg *params;
{
    VALUE self = get_value_from_gobject(GTK_OBJECT(widget));
    VALUE proc = RARRAY(data)->ptr[0];
    ID id = NUM2INT(RARRAY(data)->ptr[1]);
    VALUE result = Qnil;
    VALUE args = ary_new2(nparams+1);

    signal_setup_args(self, id, nparams, params, args);
    if (NIL_P(proc)) {
	if (rb_respond_to(self, id)) {
	    result = rb_apply(self, id, args);
	}
    }
    else {
	ary_unshift(args, self);
	result = rb_apply(proc, id_call, args);
    }
    arg_set_value(params+nparams, result);
}

static void
exec_callback(widget, proc)
    GtkWidget *widget;
    VALUE proc;
{
    rb_funcall(proc, id_call, 1, get_value_from_gobject(GTK_OBJECT(widget)));
}

static VALUE
d873 1
a873 1
	VALUE data = assoc_new(Qnil, id);
d875 1
a875 1
	add_relative(self, data);
d877 1
a877 1
				  signal_callback, (gpointer)data,
d887 1
d889 1
d918 1
a918 1
    VALUE sig, data;
d923 1
a923 1
    rb_scan_args(argc, argv, "11", &sig, &data);
d925 2
a926 2
    if (NIL_P(data) && iterator_p()) {
	data = f_lambda();
d929 2
a930 2
    data = assoc_new(data, INT2NUM(id));
    add_relative(self, data);
d932 1
a932 1
				  signal_callback, (gpointer)data,
d944 1
a944 1
    VALUE sig, data;
d949 1
a949 1
    rb_scan_args(argc, argv, "11", &sig, &data);
d951 2
a952 2
    if (NIL_P(data) && iterator_p()) {
	data = f_lambda();
d955 1
a955 1
    add_relative(self, data);
d957 1
a957 1
				  signal_callback, (gpointer)data,
d1440 8
d4036 1
a4036 1
				 GTK_ADJUSTMENT(adjustment));
d4049 1
a4049 1
				 GTK_ADJUSTMENT(adjustment));
a5161 1
    return handler;
a5176 1
    return handler;
a5191 1
    return handler;
d5296 1
a5296 2
    gdkDrawable = rb_define_class_under(mGdk, "Drawable", cObject);
    gdkPixmap = rb_define_class_under(mGdk, "Pixmap", gdkDrawable);
d5298 1
a5298 1
    gdkWindow = rb_define_class_under(mGdk, "Window", gdkDrawable);
d5344 1
a5344 1
    rb_define_method(gWidget, "set_state", widget_set_state, 1);
d5350 1
a5350 1
    rb_define_method(gWidget, "get_name", widget_get_name, 0);
d5368 1
a5368 1
    rb_define_method(gWidget, "get_pointer", widget_get_pointer, 0);
d5431 1
a5431 1
    rb_define_method(gArrow, "set", arrow_set, 2);
d5503 2
a5504 2
    rb_define_method(gCList, "column_titles_active", clist_col_titles_active, 0);
    rb_define_method(gCList, "column_titles_passive", clist_col_titles_passive, 0);
d5512 1
a5512 1
    rb_define_method(gCList, "set_pixmap", clist_set_pixmap, 4);
d5521 1
a5521 1
    rb_define_method(gCList, "get_row_data", clist_get_row_data, 1);
d5532 1
a5532 1
    rb_define_method(gWindow, "set_default", gwin_set_default, 1);
d5591 1
a5591 1
			       hbbox_get_layout_default, 0);
d5602 1
a5602 1
			       vbbox_get_layout_default, 0);
d5613 1
a5613 1
    rb_define_method(gPaned, "add2", paned_add2, 1);
d5728 1
a5728 1
    rb_define_method(gMenu, "popdown", menu_popdown, 0);
d5783 1
a5783 1
    rb_define_method(gOptionMenu, "remove_menu", omenu_remove_menu, 0);
d5842 1
a5842 1
    rb_define_method(gToolbar, "insert_item", tbar_insert_item, 5);
d5845 1
a5845 1
    rb_define_method(gToolbar, "insert_space", tbar_insert_space, 1);
d5902 1
a5902 1
    rb_define_singleton_method(gdkBitmap, "new", gdkbmap_s_new, 3);
d5907 1
a5907 3
    rb_define_singleton_method(gdkPixmap, "new", gdkpmap_s_new, 4);
    rb_define_singleton_method(gdkPixmap, "create_from_data",
			       gdkpmap_create_from_data, 7);
d5911 1
a5911 1
			       gdkpmap_create_from_xpm_d, 3);
a5915 6
    rb_define_singleton_method(gdkImage, "new_bitmap", gdkimage_s_newbmap, 4);
    rb_define_singleton_method(gdkImage, "new", gdkimage_s_new, 4);
    rb_define_singleton_method(gdkImage, "get", gdkimage_s_get, 5);
    rb_define_method(gdkImage, "put_pixel", gdkimage_put_pixel, 3);
    rb_define_method(gdkImage, "get_pixel", gdkimage_get_pixel, 2);
    rb_define_method(gdkImage, "destroy", gdkimage_destroy, 0);
a5916 1
    /* constants */
a6022 4

    rb_define_const(mGdk, "IMAGE_NORMAL", INT2FIX(GDK_IMAGE_NORMAL));
    rb_define_const(mGdk, "IMAGE_SHARED", INT2FIX(GDK_IMAGE_SHARED));
    rb_define_const(mGdk, "IMAGE_FASTEST", INT2FIX(GDK_IMAGE_FASTEST));
@


1.1.1.1.2.11
log
@1.1b8pre2
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:45 $
d251 7
d265 1
a265 1
    obj = Data_Wrap_Struct(gStyle, 0, gtk_style_unref, style);
d286 7
d300 1
a300 2
    obj = Data_Wrap_Struct(gAcceleratorTable, 0,
			   gtk_accelerator_table_unref, tbl);
d322 7
d333 1
a333 1
    VALUE obj = Data_Wrap_Struct(gPreviewInfo, 0, 0, info);
d354 7
d369 1
a369 1
    obj = Data_Wrap_Struct(klass, 0, gtk_tooltips_unref, tips);
d390 7
d404 1
a404 1
    obj = Data_Wrap_Struct(gdkFont, 0, gdk_font_unref, font);
d491 7
d503 1
a503 1
    return Data_Wrap_Struct(gdkColormap, 0, gdk_colormap_unref, cmap);
d522 7
d534 1
a534 1
    return Data_Wrap_Struct(gdkVisual, 0, gdk_visual_unref, visual);
d553 7
d561 5
a565 8
make_gdkdraw(klass, draw, ref, unref)
    VALUE klass;
    GdkDrawable *draw;
    void (*ref)();
    void (*unref)();
{
    (*ref)(draw);
    return Data_Wrap_Struct(gdkWindow, 0, unref, draw);
a567 7
#define make_gdkwindow2(c,w) make_gdkdraw(c,(w),gdk_window_ref,gdk_window_unref)
#define make_gdkbitmap2(c,w) make_gdkdraw(c,(w),gdk_bitmap_ref,gdk_bitmap_unref)
#define make_gdkpixmap2(c,w) make_gdkdraw(c,(w),gdk_pixmap_ref,gdk_pixmap_unref)
#define make_gdkwindow(w) make_gdkwindow0(gdkWindow,(w))
#define make_gdkbitmap(w) make_gdkbitmap0(gdkBitmap,(w))
#define make_gdkpixmap(w) make_gdkpixmap0(gdkPixmap,(w))

d569 2
a570 3
get_gdkdraw(draw, klass, kname)
    VALUE draw, klass;
    char *kname;
d572 1
a572 1
    GdkDrawable *d;
d574 1
a574 1
    if (NIL_P(draw)) return NULL;
d576 2
a577 2
    if (!obj_is_kind_of(draw, klass)) {
	TypeError("not a %s", kname);
d579 1
a579 1
    Data_Get_Struct(draw, GdkDrawable, d);
d581 1
a581 1
    return d;
d584 31
a614 4
#define get_gdkdrawable(w) get_gdkdraw((w),gdkDrawable,"GdkDrawable")
#define get_gdkwindow(w) get_gdkdraw((w),gdkWindow,"GdkWindow")
#define get_gdkpixmap(w) get_gdkdraw((w),gdkPixmap,"GdkPixmap")
#define get_gdkbitmap(w) get_gdkdraw((w),gdkBitmap,"GdkBitmap")
d624 1
a624 1
    return make_gdkpixmap2(self,new);
d641 1
a641 1
    return make_gdkpixmap2(self,new);
d659 2
a660 2
    return assoc_new(make_gdkpixmap2(self,new),
		     make_gdkbitmap(mask));
d684 2
a685 2
    return assoc_new(make_gdkpixmap2(self,new),
		     make_gdkbitmap(mask));
d696 1
a696 1
    return make_gdkpixmap2(self,new);
d710 7
a716 1
    return make_gdkbitmap2(self,new);
d723 1
a723 1
    return Data_Wrap_Struct(gdkImage, 0, gdk_image_destroy, image);
a737 3
    if (gimage == 0) {
	ArgError("destroyed GdkImage");
    }
a802 1
    DATA_PTR(self) = 0;
d806 7
d818 1
a818 1
    return Data_Wrap_Struct(gdkEvent, 0, gdk_event_free, event);
a837 50
make_gdkgc(gc)
    GdkGC *gc;
{
    return Data_Wrap_Struct(gdkGC, 0, gdk_gc_destroy, gc);
}

static GdkGC*
get_gdkgc(gc)
    VALUE gc;
{
    GdkGC *ggc;

    if (NIL_P(gc)) return NULL;

    if (!obj_is_instance_of(gc, gdkGC)) {
	TypeError("not a GdkGC");
    }
    Data_Get_Struct(gc, GdkGC, ggc);
    if (ggc == 0) {
	ArgError("destroyed GdkGC");
    }

    return ggc;
}

static VALUE
gdkgc_s_new(self, win)
    VALUE self, win;
{
    return make_gdkgc(gdk_gc_new(get_widget(win)->window));
}

static VALUE
gdkgc_copy(self, copy)
    VALUE copy;
{
    gdk_gc_copy(get_gdkgc(self), get_gdkgc(copy));
    return copy;
}

static VALUE
gdkgc_destroy(self)
    VALUE self;
{
    gdk_gc_destroy(get_gdkgc(self));
    DATA_PTR(self) = 0;
    return Qnil;
}

static VALUE
d954 1
a954 1
	    return make_gdkpixmap(GTK_VALUE_BOXED(*arg));
d3665 1
a3665 1
		     make_gdkpixmap(mask));
d3676 1
d3687 5
a3691 59
static VALUE
preview_put(self, win, gc, srcx, srcy, dstx, dsty, w, h)
    VALUE self, win, gc, srcx, srcy, dstx, dsty, w, h;
{
    GtkWidget *widget = get_widget(self);

    gtk_preview_put(GTK_PREVIEW(widget), get_gdkwindow(win), get_gdkgc(gc),
		    NUM2INT(srcx), NUM2INT(srcy),
		    NUM2INT(dstx), NUM2INT(dsty),
		    NUM2INT(w), NUM2INT(h));
    return self;
}

static VALUE
preview_put_row(self, src, dst, x, y, w)
    VALUE self, src, dst, x, y, w;
{
    GtkWidget *widget = get_widget(self);
    int width = NUM2INT(w);
    int dlen = width;

    if (GTK_PREVIEW(widget)->type == GTK_PREVIEW_COLOR) {
	dlen *= 3;
    }
    Check_Type(src, T_STRING);
    if (RSTRING(src)->len < dlen) {
	ArgError("src too short");
    }
    Check_Type(dst, T_STRING);
    if (RSTRING(dst)->len < dlen) {
	ArgError("dst too short");
    }
    str_modify(dst);
    gtk_preview_put_row(GTK_PREVIEW(widget),
			RSTRING(src)->ptr, RSTRING(dst)->ptr,
			NUM2INT(x), NUM2INT(y), width);
    return self;
}

static VALUE
preview_draw_row(self, data, x, y, w)
    VALUE self, data, x, y, w;
{
    GtkWidget *widget = get_widget(self);
    int width = NUM2INT(w);
    int dlen = width;

    if (GTK_PREVIEW(widget)->type == GTK_PREVIEW_COLOR) {
	dlen *= 3;
    }
    Check_Type(data, T_STRING);
    if (RSTRING(data)->len < dlen) {
	ArgError("data too short");
    }

    gtk_preview_draw_row(GTK_PREVIEW(widget), RSTRING(data)->ptr,
			 NUM2INT(x), NUM2INT(y), width);
    return self;
}
d3726 1
a3726 1
    gtk_preview_set_install_cmap(RTEST(cmap));
d3742 2
a3743 1
    return make_gdkvisual(gtk_preview_get_visual());
d3750 2
a3751 1
    return make_gdkcmap(gtk_preview_get_cmap());
d4757 2
a4758 2
    return assoc_new(make_gdkpixmap(val),
		     make_gdkbitmap(mask));
a5389 162

static VALUE
gdkdraw_draw_point(self, gc, x, y)
    VALUE self, gc, x, y;
{
    gdk_draw_point(get_gdkdrawable(self), get_gdkgc(gc),
		   NUM2INT(x), NUM2INT(y));
    return self;
}

static VALUE
gdkdraw_draw_line(self, gc, x1, y1, x2, y2)
    VALUE self, gc, x1, y1, x2, y2;
{
    gdk_draw_line(get_gdkdrawable(self), get_gdkgc(gc),
		  NUM2INT(x1), NUM2INT(y1),
		  NUM2INT(x2), NUM2INT(y2));
    return self;
}

static VALUE
gdkdraw_draw_rect(self, gc, filled, x, y, w, h)
    VALUE self, gc, filled, x, y, w, h;
{
    gdk_draw_rectangle(get_gdkdrawable(self), get_gdkgc(gc),
		       RTEST(filled),
		       NUM2INT(x), NUM2INT(y),
		       NUM2INT(w), NUM2INT(h));
    return self;
}

static VALUE
gdkdraw_draw_arc(self, gc, filled, x, y, w, h, a1, a2)
    VALUE gc, filled, x, y, w, h, a1, a2;
{
    gdk_draw_arc(get_gdkdrawable(self), get_gdkgc(gc),
		 RTEST(filled),
		 NUM2INT(x), NUM2INT(y),
		 NUM2INT(w), NUM2INT(h),
		 NUM2INT(a1), NUM2INT(a2));
    return self;
}

static VALUE
gdkdraw_draw_poly(self, gc, filled, pnts)
    VALUE self, gc, filled, pnts;
{
    GdkPoint *points;
    int i;

    Check_Type(pnts, T_ARRAY);
    points = ALLOCA_N(GdkPoint,RARRAY(pnts)->len);
    for (i=0; i<RARRAY(pnts)->len; i++) {
	Check_Type(RARRAY(pnts)->ptr[i], T_ARRAY);
	if (RARRAY(RARRAY(pnts)->ptr[i])->len < 2) {
	    ArgError("point %d should be array of size 2", i);
	}
	points[i].x = NUM2INT(RARRAY(RARRAY(pnts)->ptr[i])->ptr[0]);
	points[i].y = NUM2INT(RARRAY(RARRAY(pnts)->ptr[i])->ptr[1]);
    }
    gdk_draw_polygon(get_gdkdrawable(self), get_gdkgc(gc),
		     RTEST(filled),
		     points,
		     RARRAY(pnts)->len);
    return self;
}

static VALUE
gdkdraw_draw_text(self, font, gc, x, y, str)
    VALUE self, font, gc, x, y, str;
{
    Check_Type(str, T_STRING);
    gdk_draw_text(get_gdkdrawable(self), get_gdkfont(font), get_gdkgc(gc),
		  NUM2INT(x), NUM2INT(y),
		  RSTRING(str)->ptr, RSTRING(str)->len);
    return self;
}

static VALUE
gdkdraw_draw_pmap(self, gc, src, xsrc, ysrc, xdst, ydst, w, h)
    VALUE self, gc, src, xsrc, ysrc, xdst, ydst, w, h;
{
    gdk_draw_pixmap(get_gdkdrawable(self), get_gdkgc(gc),
		    get_gdkdrawable(src),
		    NUM2INT(xsrc), NUM2INT(ysrc),
		    NUM2INT(xdst), NUM2INT(ydst),
		    NUM2INT(w), NUM2INT(h));
    return self;
}

static VALUE
gdkdraw_draw_bmap(self, gc, src, xsrc, ysrc, xdst, ydst, w, h)
    VALUE self, gc, src, xsrc, ysrc, xdst, ydst, w, h;
{
    gdk_draw_bitmap(get_gdkdrawable(self), get_gdkgc(gc),
		    get_gdkdrawable(src),
		    NUM2INT(xsrc), NUM2INT(ysrc),
		    NUM2INT(xdst), NUM2INT(ydst),
		    NUM2INT(w), NUM2INT(h));
    return self;
}

static VALUE
gdkdraw_draw_image(self, gc, image, xsrc, ysrc, xdst, ydst, w, h)
    VALUE self, gc, image, xsrc, ysrc, xdst, ydst, w, h;
{
    gdk_draw_image(get_gdkdrawable(self), get_gdkgc(gc),
		   get_gdkimage(image),
		   NUM2INT(xsrc), NUM2INT(ysrc),
		   NUM2INT(xdst), NUM2INT(ydst),
		   NUM2INT(w), NUM2INT(h));
    return self;
}

static VALUE
gdkdraw_draw_pnts(self, gc, pnts)
    VALUE self, gc, pnts;
{
    GdkPoint *points;
    int i;

    Check_Type(pnts, T_ARRAY);
    points = ALLOCA_N(GdkPoint,RARRAY(pnts)->len);
    for (i=0; i<RARRAY(pnts)->len; i++) {
	Check_Type(RARRAY(pnts)->ptr[i], T_ARRAY);
	if (RARRAY(RARRAY(pnts)->ptr[i])->len < 2) {
	    ArgError("point %d should be array of size 2", i);
	}
	points[i].x = NUM2INT(RARRAY(RARRAY(pnts)->ptr[i])->ptr[0]);
	points[i].y = NUM2INT(RARRAY(RARRAY(pnts)->ptr[i])->ptr[1]);
    }
    gdk_draw_points(get_gdkdrawable(self), get_gdkgc(gc),
		    points,
		    RARRAY(pnts)->len);
    return self;
}

static VALUE
gdkdraw_draw_segs(self, gc, segs)
    VALUE self, gc, segs;
{
    GdkSegment *segments;
    int i;

    Check_Type(segs, T_ARRAY);
    segments = ALLOCA_N(GdkSegment,RARRAY(segs)->len);
    for (i=0; i<RARRAY(segs)->len; i++) {
	Check_Type(RARRAY(segs)->ptr[i], T_ARRAY);
	if (RARRAY(RARRAY(segs)->ptr[i])->len < 4) {
	    ArgError("segment %d should be array of size 4", i);
	}
	segments[i].x1 = NUM2INT(RARRAY(RARRAY(segs)->ptr[i])->ptr[0]);
	segments[i].y1 = NUM2INT(RARRAY(RARRAY(segs)->ptr[i])->ptr[1]);
	segments[i].x2 = NUM2INT(RARRAY(RARRAY(segs)->ptr[i])->ptr[2]);
	segments[i].y2 = NUM2INT(RARRAY(RARRAY(segs)->ptr[i])->ptr[3]);
    }
    gdk_draw_segments(get_gdkdrawable(self), get_gdkgc(gc),
		      segments,
		      RARRAY(segs)->len);
    return self;
}

d6129 3
a6131 3
    rb_define_method(gPreview, "put", preview_put, 8);
    rb_define_method(gPreview, "put_row", preview_put_row, 5);
    rb_define_method(gPreview, "draw_row", preview_draw_row, 4);
d6236 4
a6239 13
    /* GdkDrawable */
    rb_define_method(gdkDrawable, "draw_point", gdkdraw_draw_point, 3);
    rb_define_method(gdkDrawable, "draw_line", gdkdraw_draw_line, 5);
    rb_define_method(gdkDrawable, "draw_rectangle", gdkdraw_draw_rect, 6);
    rb_define_method(gdkDrawable, "draw_arc", gdkdraw_draw_arc, 8);
    rb_define_method(gdkDrawable, "draw_polygon", gdkdraw_draw_poly, 3);
    rb_define_method(gdkDrawable, "draw_string", gdkdraw_draw_text, 5);
    rb_define_method(gdkDrawable, "draw_text", gdkdraw_draw_text, 5);
    rb_define_method(gdkDrawable, "draw_pixmap", gdkdraw_draw_pmap, 8);
    rb_define_method(gdkDrawable, "draw_bitmap", gdkdraw_draw_bmap, 8);
    rb_define_method(gdkDrawable, "draw_image", gdkdraw_draw_image, 8);
    rb_define_method(gdkDrawable, "draw_points", gdkdraw_draw_pnts, 2);
    rb_define_method(gdkDrawable, "draw_segments", gdkdraw_draw_segs, 2);
a6249 5
    /* GdkBitmap */
    rb_define_singleton_method(gdkBitmap, "new", gdkbmap_s_new, 3);
    rb_define_singleton_method(gdkBitmap, "create_from_data",
			       gdkbmap_create_from_data, 4);

a6250 5

    /* GdkGC */
    rb_define_singleton_method(gdkGC, "new", gdkgc_s_new, 1);
    rb_define_method(gdkGC, "copy", gdkgc_copy, 1);
    rb_define_method(gdkGC, "destroy", gdkgc_destroy, 0);
@


1.1.1.1.2.12
log
@1.1b8_00?
@
text
@d6 1
a6 1
  $Date: 1998/02/20 08:28:49 $
a5403 297
style_s_new(klass)
    VALUE klass;
{
    return make_gstyle(gtk_style_new());
}

static VALUE
style_attach(self, win)
    VALUE self, win;
{
    return make_gstyle(gtk_style_attach(get_gstyle(self), get_gdkwindow(win)));
}

static VALUE
style_detach(self)
{
    gtk_style_detach(get_gstyle(self));
    return self;
}

static VALUE
style_set_bg(self, win, state_type)
    VALUE self, win, state_type;
{
    gtk_style_set_background(get_gstyle(self), get_gdkwindow(win),
			     (GtkStateType)NUM2INT(state_type));
    return self;
}

static VALUE
style_fg(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkcolor(get_gstyle(self)->fg[i]);
}

static VALUE
style_bg(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkcolor(get_gstyle(self)->bg[i]);
}

static VALUE
style_light(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkcolor(get_gstyle(self)->light[i]);
}

static VALUE
style_dark(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkcolor(get_gstyle(self)->dark[i]);
}

static VALUE
style_mid(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkcolor(get_gstyle(self)->mid[i]);
}

static VALUE
style_text(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkcolor(get_gstyle(self)->text[i]);
}

static VALUE
style_base(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkcolor(get_gstyle(self)->base[i]);
}

static VALUE
style_black(self)
{
    return make_gdkcolor(get_gstyle(self)->black);
}

static VALUE
style_white(self)
{
    return make_gdkcolor(get_gstyle(self)->white);
}

static VALUE
style_font(self)
{
    return make_gdkfont(get_gstyle(self)->font);
}

static VALUE
style_fg_gc(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkgc(get_gstyle(self)->fg_gc[i]);
}

static VALUE
style_bg_gc(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkgc(get_gstyle(self)->bg_gc[i]);
}

static VALUE
style_light_gc(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkgc(get_gstyle(self)->light_gc[i]);
}

static VALUE
style_dark_gc(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkgc(get_gstyle(self)->dark_gc[i]);
}

static VALUE
style_mid_gc(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkgc(get_gstyle(self)->mid_gc[i]);
}

static VALUE
style_text_gc(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkgc(get_gstyle(self)->text_gc[i]);
}

static VALUE
style_base_gc(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkgc(get_gstyle(self)->base_gc[i]);
}

static VALUE
style_black_gc(self)
{
    return make_gdkgc(get_gstyle(self)->black_gc);
}

static VALUE
style_white_gc(self)
{
    return make_gdkgc(get_gstyle(self)->white_gc);
}

static VALUE
style_bg_pixmap(self, idx)
    VALUE self, idx;
{
    int i = NUM2INT(idx);

    if (i < 0 || 5 < i) ArgError("state out of range");
    return make_gdkpixmap(get_gstyle(self)->bg_pixmap[i]);
}


#if 0
static VALUE
style_draw_hline(self, win, state_type, x1, x2, y)
    VALUE self, win, type, x1, x2, y;
{
    gtk_draw_hline(get_gstyle(self), get_gdkwindow(win),
		   (GtkStateType)NUM2INT(state_type),
		   NUM2INT(x1), NUM2INT(x2), NUM2INT(y));
    return self;
}

static VALUE
style_draw_vline(self, win, state_type, y1, y2, x)
    VALUE self,win,type,y1,y2,x;
{
    gtk_draw_vline(get_gstyle(self), get_gdkwindow(win),
		   (GtkStateType)NUM2INT(state_type),
		   NUM2INT(y1), NUM2INT(y2), NUM2INT(x));
    return self;
}

static VALUE
style_draw_shadow(self,win,state_type,shadow_type,x,y,w,h)
    VALUE self,win,state_type,shadow_type,x,y,w,h;
{
    gtk_draw_shadow(get_gstyle(self), get_gdkwindow(win),
		    (GtkStateType)NUM2INT(state_type),
		    (GtkShadowType)NUM2INT(shadow_type),
		    NUM2INT(x), NUM2INT(y), 
		    NUM2INT(w), NUM2INT(h));
    return self;
}

static VALUE
style_draw_polygon(self,win,state_type,shadow_type,pnts,fill)
    VALUE self,win,state_type,shadow_type,pnts,fill;
{
    GdkPoint *points;
    int i;

    Check_Type(pnts, T_ARRAY);
    points = ALLOCA_N(GdkPoint,RARRAY(pnts)->len);
    for (i=0; i<RARRAY(pnts)->len; i++) {
	Check_Type(RARRAY(pnts)->ptr[i], T_ARRAY);
	if (RARRAY(RARRAY(pnts)->ptr[i])->len < 2) {
	    ArgError("point %d should be array of size 2", i);
	}
	points[i].x = NUM2INT(RARRAY(RARRAY(pnts)->ptr[i])->ptr[0]);
	points[i].y = NUM2INT(RARRAY(RARRAY(pnts)->ptr[i])->ptr[1]);
    }

    gtk_draw_polygon(get_gstyle(self), get_gdkwindow(win),
		     (GtkStateType)NUM2INT(state_type),
		     (GtkShadowType)NUM2INT(shadow_type),
		     points, RARRAY(pnts)->len,
		     RTEST(fill));
    return self;
}

static VALUE
style_draw_arrow(self,)		/* 9 */
{
    gtk_draw_polygon(get_gstyle(self), get_gdkwindow(win),
		     (GtkStateType)NUM2INT(state_type),
		     (GtkShadowType)NUM2INT(shadow_type),
		     points, RARRAY(pnts)->len,
		     RTEST(fill));
    return self;
}

static VALUE
style_draw_diamond(self,)	/* 7 */
{
}

static VALUE
style_draw_oval(self,)		/* 7 */
{
}

static VALUE
style_draw_string(self,)	/* 5 */
{
}
#endif

static VALUE
d5729 1
a5729 1
    gObject = rb_define_class_under(mGtk, "Object", cObject);
a6399 34
    rb_define_singleton_method(gStyle, "new", style_s_new, 0);
    rb_define_method(gStyle, "attach", style_attach, 1);
    rb_define_method(gStyle, "detach", style_detach, 0);
    rb_define_method(gStyle, "set_background", style_set_bg, 0);
    rb_define_method(gStyle, "fg", style_fg, 1);
    rb_define_method(gStyle, "bg", style_bg, 1);
    rb_define_method(gStyle, "light", style_light, 1);
    rb_define_method(gStyle, "dark", style_dark, 1);
    rb_define_method(gStyle, "mid", style_mid, 1);
    rb_define_method(gStyle, "text", style_text, 1);
    rb_define_method(gStyle, "base", style_base, 1);
    rb_define_method(gStyle, "black", style_black, 0);
    rb_define_method(gStyle, "white", style_white, 0);
    rb_define_method(gStyle, "font", style_font, 0);
    rb_define_method(gStyle, "fg_gc", style_fg_gc, 1);
    rb_define_method(gStyle, "bg_gc", style_bg_gc, 1);
    rb_define_method(gStyle, "light_gc", style_light_gc, 1);
    rb_define_method(gStyle, "dark_gc", style_dark_gc, 1);
    rb_define_method(gStyle, "mid_gc", style_mid_gc, 1);
    rb_define_method(gStyle, "text_gc", style_text_gc, 1);
    rb_define_method(gStyle, "base_gc", style_base_gc, 1);
    rb_define_method(gStyle, "black_gc", style_black_gc, 0);
    rb_define_method(gStyle, "white_gc", style_white_gc, 0);
    rb_define_method(gStyle, "bg_pixmap", style_bg_pixmap, 1);
#if 0
    rb_define_method(gStyle, "draw_hline", style_draw_hline, 5);
    rb_define_method(gStyle, "draw_vline", style_draw_vline, 5);
    rb_define_method(gStyle, "draw_shadow", style_draw_shadow, 7);
    rb_define_method(gStyle, "draw_polygon", style_draw_polygon, 6);
    rb_define_method(gStyle, "draw_arrow", style_draw_arrow, 9);
    rb_define_method(gStyle, "draw_diamond", style_draw_diamond, 7);
    rb_define_method(gStyle, "draw_oval", style_draw_oval, 7);
    rb_define_method(gStyle, "draw_string", style_draw_string, 5);
#endif
@


1.1.1.1.2.13
log
@block arg etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/26 08:27:13 $
d411 1
a411 1
    data = Data_Wrap_Struct(klass, 0, free, copy);
@


1.1.1.1.2.14
log
@gets speed up patch
@
text
@d6 1
a6 1
  $Date: 1998/03/05 06:37:49 $
d123 1
a123 1
ID id_gtkdata, id_relatives, id_call;
d178 1
a178 1
    if (NIL_P(ary) || TYPE(ary) != T_ARRAY) {
d231 1
a231 1
    rb_funcall(obj, rb_intern("initialize"), 0, 0);
d258 4
a261 1
    return Data_Wrap_Struct(gStyle, 0, gtk_style_unref, style);
d286 5
a290 2
    return Data_Wrap_Struct(gAcceleratorTable, 0,
			    gtk_accelerator_table_unref, tbl);
d313 3
a315 1
    return Data_Wrap_Struct(gPreviewInfo, 0, 0, info);
d335 29
d371 1
a371 1

d412 1
d513 1
a513 1
    return Data_Wrap_Struct(klass, 0, unref, draw);
d519 3
a521 3
#define make_gdkwindow(w) make_gdkwindow2(gdkWindow,(w))
#define make_gdkbitmap(w) make_gdkbitmap2(gdkBitmap,(w))
#define make_gdkpixmap(w) make_gdkpixmap2(gdkPixmap,(w))
d1113 1
a1113 1
	    GTK_VALUE_BOXED(*arg) = get_widget(value);
d1228 1
d1230 1
a1230 1
    int i;
d1240 1
a1240 2
    i = gtk_signal_connect_interp(GTK_OBJECT(get_widget(self)),
				  RSTRING(sig)->ptr,
d1244 1
a1244 1
    return INT2FIX(i);
d1254 1
d1256 1
a1256 1
    int i;
d1265 1
a1265 2
    i = gtk_signal_connect_interp(GTK_OBJECT(get_widget(self)),
				  RSTRING(sig)->ptr,
d1269 1
a1269 1
    return INT2FIX(i);
d1276 2
a1277 2
    gtk_container_border_width(GTK_CONTAINER(get_widget(self)),
			       NUM2INT(width));
d1285 3
a1287 1
    gtk_container_add(GTK_CONTAINER(get_widget(self)), get_widget(other));
d1295 3
a1297 1
    gtk_container_disable_resize(GTK_CONTAINER(get_widget(self)));
d1305 3
a1307 1
    gtk_container_enable_resize(GTK_CONTAINER(get_widget(self)));
d1315 3
a1317 1
    gtk_container_block_resize(GTK_CONTAINER(get_widget(self)));
d1325 3
a1327 1
    gtk_container_unblock_resize(GTK_CONTAINER(get_widget(self)));
d1335 3
a1337 1
    gtk_container_need_resize(GTK_CONTAINER(get_widget(self)));
d1348 1
d1354 1
a1354 1
    gtk_container_foreach(GTK_CONTAINER(get_widget(self)), 
d1370 3
a1372 1
    gtk_container_foreach(GTK_CONTAINER(get_widget(self)), 
d1381 3
a1383 1
    gtk_container_focus(GTK_CONTAINER(get_widget(self)),
d1402 1
d1405 1
a1405 1
    gtk_container_foreach(GTK_CONTAINER(get_widget(self)),
d1426 3
a1428 1
    gtk_alignment_set(GTK_ALIGNMENT(get_widget(self)),
d1438 3
a1440 1
    gtk_misc_set_alignment(GTK_MISC(get_widget(self)),
d1449 3
a1451 1
    gtk_misc_set_padding(GTK_MISC(get_widget(self)),
d1469 3
a1471 1
    gtk_arrow_set(GTK_ARROW(get_widget(self)),
d1489 3
a1491 1
    gtk_frame_set_label(GTK_FRAME(get_widget(self)), STR2CSTR(label));
d1499 3
a1501 1
    gtk_frame_set_label_align(GTK_FRAME(get_widget(self)),
d1512 3
a1514 1
    gtk_frame_set_shadow_type(GTK_FRAME(get_widget(self)),
d1535 3
a1537 1
    gtk_aspect_frame_set(GTK_ASPECT_FRAME(get_widget(self)),
d1720 2
a1721 2
    int i = gtk_widget_event(get_widget(self), get_gdkevent(event));
    return NUM2INT(i);
d1752 3
a1754 1
    if (GTK_WIDGET_VISIBLE(get_widget(self)))
d1779 1
a1779 1
    int i = gtk_widget_intersect(get_widget(self),
d1782 1
a1782 1
    return NUM2INT(i);
d1789 2
a1790 2
    int i = gtk_widget_basic(get_widget(self));
    return NUM2INT(i);
d1973 2
a1974 2
    int i = gtk_widget_get_events(get_widget(self));
    return NUM2INT(i);
d2136 2
a2137 1
    int i = gtk_button_box_get_spacing(GTK_BUTTON_BOX(get_widget(self)));
d2139 1
a2139 1
    return INT2FIX(i);
d2146 2
a2147 1
    int i = gtk_button_box_get_layout(GTK_BUTTON_BOX(get_widget(self)));
d2149 1
a2149 1
    return INT2FIX(i);
d2156 1
d2159 1
a2159 1
    gtk_button_box_get_child_size(GTK_BUTTON_BOX(get_widget(self)),
d2168 1
d2171 1
a2171 1
    gtk_button_box_get_child_ipadding(GTK_BUTTON_BOX(get_widget(self)),
d2180 3
a2182 1
    gtk_button_box_set_spacing(GTK_BUTTON_BOX(get_widget(self)),
d2191 3
a2193 1
    gtk_button_box_set_layout(GTK_BUTTON_BOX(get_widget(self)),
d2202 3
a2204 1
    gtk_button_box_set_child_size(GTK_BUTTON_BOX(get_widget(self)),
d2214 3
a2216 1
    gtk_button_box_set_child_ipadding(GTK_BUTTON_BOX(get_widget(self)),
d2253 3
a2255 2
    gtk_clist_set_border(GTK_CLIST(get_widget(self)),
			 (GtkShadowType)NUM2INT(border));
d2263 3
a2265 1
    gtk_clist_set_selection_mode(GTK_CLIST(get_widget(self)),
d2274 3
a2276 1
    gtk_clist_set_policy(GTK_CLIST(get_widget(self)),
d2286 3
a2288 1
    gtk_clist_freeze(GTK_CLIST(get_widget(self)));
d2296 3
a2298 1
    gtk_clist_thaw(GTK_CLIST(get_widget(self)));
d2306 3
a2308 1
    gtk_clist_column_titles_show(GTK_CLIST(get_widget(self)));
d2316 3
a2318 1
    gtk_clist_column_titles_hide(GTK_CLIST(get_widget(self)));
d2326 3
a2328 2
    gtk_clist_column_title_active(GTK_CLIST(get_widget(self)),
				  NUM2INT(column));
d2336 3
a2338 2
    gtk_clist_column_title_passive(GTK_CLIST(get_widget(self)),
				   NUM2INT(column));
d2346 3
a2348 1
    gtk_clist_column_titles_active(GTK_CLIST(get_widget(self)));
d2356 3
a2358 1
    gtk_clist_column_titles_passive(GTK_CLIST(get_widget(self)));
d2366 3
a2368 1
    gtk_clist_set_column_title(GTK_CLIST(get_widget(self)),
d2378 3
a2380 1
    gtk_clist_set_column_widget(GTK_CLIST(get_widget(self)),
d2390 3
a2392 1
    gtk_clist_set_column_justification(GTK_CLIST(get_widget(self)),
d2402 3
a2404 1
    gtk_clist_set_column_width(GTK_CLIST(get_widget(self)),
d2413 3
a2415 1
    gtk_clist_set_row_height(GTK_CLIST(get_widget(self)), NUM2INT(height));
d2423 3
a2425 1
    gtk_clist_moveto(GTK_CLIST(get_widget(self)),
d2435 3
a2437 1
    gtk_clist_set_text(GTK_CLIST(get_widget(self)),
d2447 3
a2449 1
    gtk_clist_set_pixmap(GTK_CLIST(get_widget(self)),
d2460 3
a2462 1
    gtk_clist_set_pixtext(GTK_CLIST(get_widget(self)),
d2475 3
a2477 1
    gtk_clist_set_foreground(GTK_CLIST(get_widget(self)),
d2486 3
a2488 1
    gtk_clist_set_background(GTK_CLIST(get_widget(self)),
d2497 3
a2499 1
    gtk_clist_set_shift(GTK_CLIST(get_widget(self)),
d2509 1
d2514 1
a2514 1
    len = GTK_CLIST(get_widget(self))->columns;
d2523 1
a2523 1
    i = gtk_clist_append(GTK_CLIST(get_widget(self)), buf);
d2531 1
d2536 1
a2536 1
    len = GTK_CLIST(get_widget(self))->columns;
d2545 1
a2545 1
    gtk_clist_insert(GTK_CLIST(get_widget(self)), NUM2INT(row), buf);
d2553 3
a2555 1
    gtk_clist_remove(GTK_CLIST(get_widget(self)), NUM2INT(row));
d2563 2
d2566 1
a2566 2
    gtk_clist_set_row_data(GTK_CLIST(get_widget(self)),
			   NUM2INT(row), (gpointer)data);
d2574 3
a2576 2
    return (VALUE)gtk_clist_get_row_data(GTK_CLIST(get_widget(self)),
					 NUM2INT(row));
d2583 3
a2585 2
    gtk_clist_select_row(GTK_CLIST(get_widget(self)),
			 NUM2INT(row), NUM2INT(col));
d2593 3
a2595 2
    gtk_clist_unselect_row(GTK_CLIST(get_widget(self)),
			   NUM2INT(row), NUM2INT(col));
d2603 3
a2605 1
    gtk_clist_clear(GTK_CLIST(get_widget(self)));
d2621 3
a2623 1
    gtk_window_set_policy(GTK_WINDOW(get_widget(self)),
d2632 3
a2634 1
    gtk_window_set_title(GTK_WINDOW(get_widget(self)), STR2CSTR(title));
d2642 3
a2644 1
    gtk_window_position(GTK_WINDOW(get_widget(self)),
d2654 3
a2656 1
    gtk_window_set_wmclass(GTK_WINDOW(get_widget(self)),
d2666 3
a2668 1
    gtk_window_set_focus(GTK_WINDOW(get_widget(self)), get_widget(win));
d2676 3
a2678 1
    gtk_window_set_default(GTK_WINDOW(get_widget(self)), get_widget(win));
d2686 3
a2688 1
    gtk_window_add_accelerator_table(GTK_WINDOW(get_widget(self)),
d2697 3
a2699 1
    gtk_window_remove_accelerator_table(GTK_WINDOW(get_widget(self)),
d2724 2
d2727 1
a2727 1
    gtk_file_selection_set_filename(GTK_FILE_SELECTION(get_widget(self)),
d2737 1
d2740 1
a2740 1
    fname = gtk_file_selection_get_filename(GTK_FILE_SELECTION(get_widget(self)));
d2749 1
d2753 1
a2753 1
	GtkWidget *w = GTK_FILE_SELECTION(get_widget(self))->ok_button;
d2765 1
d2769 1
a2769 1
	GtkWidget *w = GTK_FILE_SELECTION(get_widget(self))->cancel_button;
d2781 1
d2785 1
a2785 1
	GtkWidget *w = GTK_FILE_SELECTION(get_widget(self))->help_button;
d2813 3
a2815 1
    gtk_list_set_selection_mode(GTK_LIST(get_widget(self)),
d2824 3
a2826 1
    return INT2FIX(GTK_LIST(get_widget(self))->selection_mode);
d2833 2
a2834 1
    return glist2ary(GTK_LIST(get_widget(self))->selection);
d2841 1
d2846 1
a2846 1
    gtk_list_insert_items(GTK_LIST(get_widget(self)), glist, NUM2INT(pos));
d2856 1
d2861 1
a2861 1
    gtk_list_append_items(GTK_LIST(get_widget(self)), glist);
d2871 1
d2875 1
a2875 1
    gtk_list_prepend_items(GTK_LIST(get_widget(self)), glist);
d2885 1
d2889 1
a2889 1
    gtk_list_remove_items(GTK_LIST(get_widget(self)), glist);
d2899 3
a2901 2
    gtk_list_clear_items(GTK_LIST(get_widget(self)),
			 NUM2INT(start), NUM2INT(end));
d2909 3
a2911 1
    gtk_list_select_item(GTK_LIST(get_widget(self)), NUM2INT(pos));
d2919 3
a2921 1
    gtk_list_unselect_item(GTK_LIST(get_widget(self)), NUM2INT(pos));
d2929 3
a2931 1
    gtk_list_select_child(GTK_LIST(get_widget(self)), get_widget(child));
d2939 3
a2941 1
    gtk_list_unselect_child(GTK_LIST(get_widget(self)), get_widget(child));
d2949 1
d2952 1
a2952 2
    pos = gtk_list_child_position(GTK_LIST(get_widget(self)),
				  get_widget(child));
d2960 3
a2962 1
    gtk_item_select(GTK_ITEM(get_widget(self)));
d2970 3
a2972 1
    gtk_item_deselect(GTK_ITEM(get_widget(self)));
d2980 3
a2982 1
    gtk_item_toggle(GTK_ITEM(get_widget(self)));
d3010 3
a3012 2
    gtk_menu_shell_append(GTK_MENU_SHELL(get_widget(self)),
			  get_widget(child));
d3020 3
a3022 2
    gtk_menu_shell_prepend(GTK_MENU_SHELL(get_widget(self)),
			   get_widget(child));
d3030 3
a3032 2
    gtk_menu_shell_insert(GTK_MENU_SHELL(get_widget(self)),
			  get_widget(child),
d3041 3
a3043 1
    gtk_menu_shell_deactivate(GTK_MENU_SHELL(get_widget(self)));
d3059 3
a3061 1
    gtk_menu_append(GTK_MENU(get_widget(self)), get_widget(child));
d3069 3
a3071 1
    gtk_menu_prepend(GTK_MENU(get_widget(self)), get_widget(child));
d3079 3
a3081 2
    gtk_menu_insert(GTK_MENU(get_widget(self)),
		    get_widget(child), NUM2INT(pos));
d3100 1
d3109 1
a3109 1
    gtk_menu_popup(GTK_MENU(get_widget(self)),
d3122 3
a3124 1
    gtk_menu_popdown(GTK_MENU(get_widget(self)));
d3132 2
a3133 1
    GtkWidget *mitem = gtk_menu_get_active(GTK_MENU(get_widget(self)));
d3135 2
a3136 1
    return make_gobject(gMenuItem, mitem);
d3143 3
a3145 1
    gtk_menu_set_active(GTK_MENU(get_widget(self)), NUM2INT(active));
d3153 3
a3155 1
    gtk_menu_set_accelerator_table(GTK_MENU(get_widget(self)),
d3172 3
a3174 1
    gtk_menu_bar_append(GTK_MENU_BAR(get_widget(self)), get_widget(child));
d3182 3
a3184 1
    gtk_menu_bar_prepend(GTK_MENU_BAR(get_widget(self)), get_widget(child));
a3186 1

d3191 3
a3193 1
    gtk_menu_bar_insert(GTK_MENU_BAR(get_widget(self)),
d3221 3
a3223 2
    gtk_menu_item_set_submenu(GTK_MENU_ITEM(get_widget(self)),
			      get_widget(child));
d3231 3
a3233 1
    gtk_menu_item_set_placement(GTK_MENU_ITEM(get_widget(self)), 
d3242 3
a3244 1
    gtk_menu_item_accelerator_size(GTK_MENU_ITEM(get_widget(self)));
d3252 1
d3255 1
a3255 1
    gtk_menu_item_accelerator_text(GTK_MENU_ITEM(get_widget(self)), buf);
d3263 3
a3265 1
    gtk_menu_item_configure(GTK_MENU_ITEM(get_widget(self)), 
d3275 3
a3277 1
    gtk_menu_item_select(GTK_MENU_ITEM(get_widget(self)));
d3285 3
a3287 1
    gtk_menu_item_deselect(GTK_MENU_ITEM(get_widget(self)));
d3295 3
a3297 1
    gtk_menu_item_activate(GTK_MENU_ITEM(get_widget(self)));
d3305 3
a3307 1
    gtk_menu_item_right_justify(GTK_MENU_ITEM(get_widget(self)));
d3334 3
a3336 1
    gtk_check_menu_item_set_state(GTK_CHECK_MENU_ITEM(get_widget(self)), 
d3345 3
a3347 1
    gtk_check_menu_item_set_show_toggle(GTK_CHECK_MENU_ITEM(get_widget(self)), 
d3356 3
a3358 1
    gtk_check_menu_item_toggled(GTK_CHECK_MENU_ITEM(get_widget(self)));
d3403 3
a3405 1
    return gslist2ary(gtk_radio_menu_item_group(GTK_RADIO_MENU_ITEM(get_widget(self))));
d3420 3
a3422 1
    gtk_notebook_append_page(GTK_NOTEBOOK(get_widget(self)),
d3432 3
a3434 1
    gtk_notebook_prepend_page(GTK_NOTEBOOK(get_widget(self)),
d3444 3
a3446 1
    gtk_notebook_insert_page(GTK_NOTEBOOK(get_widget(self)),
d3457 3
a3459 1
    gtk_notebook_remove_page(GTK_NOTEBOOK(get_widget(self)), NUM2INT(pos));
d3467 3
a3469 1
    gtk_notebook_set_page(GTK_NOTEBOOK(get_widget(self)), NUM2INT(pos));
d3477 3
a3479 1
    return INT2FIX(GTK_NOTEBOOK(get_widget(self))->cur_page);
d3486 3
a3488 1
    gtk_notebook_next_page(GTK_NOTEBOOK(get_widget(self)));
d3496 3
a3498 1
    gtk_notebook_prev_page(GTK_NOTEBOOK(get_widget(self)));
d3506 3
a3508 1
    gtk_notebook_set_tab_pos(GTK_NOTEBOOK(get_widget(self)), NUM2INT(pos));
d3516 3
a3518 1
    return INT2FIX(GTK_NOTEBOOK(get_widget(self))->tab_pos);
d3525 3
a3527 1
    gtk_notebook_set_tab_pos(GTK_NOTEBOOK(get_widget(self)), RTEST(show_tabs));
d3535 3
a3537 1
    return GTK_NOTEBOOK(get_widget(self))->show_tabs?TRUE:FALSE;
d3544 3
a3546 1
    gtk_notebook_set_tab_pos(GTK_NOTEBOOK(get_widget(self)), RTEST(show_border));
d3554 3
a3556 1
    return GTK_NOTEBOOK(get_widget(self))->show_border?TRUE:FALSE;
d3571 2
d3574 1
a3574 2
    gtk_option_menu_set_menu(GTK_OPTION_MENU(get_widget(self)),
			     get_widget(child));
d3589 3
a3591 1
    gtk_option_menu_remove_menu(GTK_OPTION_MENU(get_widget(self)));
d3599 3
a3601 2
    gtk_option_menu_set_history(GTK_OPTION_MENU(get_widget(self)),
				NUM2INT(index));
d3618 3
a3620 2
    gtk_image_set(GTK_IMAGE(get_widget(self)), get_gdkimage(val),
		  get_gdkpixmap(mask));
d3628 1
d3632 1
a3632 1
    gtk_image_get(GTK_IMAGE(get_widget(self)), &val, &mask);
d3650 3
a3652 1
    gtk_preview_size(GTK_PREVIEW(get_widget(self)), NUM2INT(w), NUM2INT(h));
d3660 3
a3662 2
    gtk_preview_put(GTK_PREVIEW(get_widget(self)), get_gdkwindow(win),
		    get_gdkgc(gc),
d3673 1
d3677 1
a3677 1
    if (GTK_PREVIEW(get_widget(self))->type == GTK_PREVIEW_COLOR) {
d3689 1
a3689 1
    gtk_preview_put_row(GTK_PREVIEW(get_widget(self)),
d3699 1
d3703 1
a3703 1
    if (GTK_PREVIEW(get_widget(self))->type == GTK_PREVIEW_COLOR) {
d3711 1
a3711 1
    gtk_preview_draw_row(GTK_PREVIEW(get_widget(self)), RSTRING(data)->ptr,
d3720 3
a3722 1
    gtk_preview_set_expand(GTK_PREVIEW(get_widget(self)), NUM2INT(expand));
d3795 3
a3797 1
    gtk_progress_bar_update(GTK_PROGRESS_BAR(get_widget(self)),
d3824 3
a3826 1
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(get_widget(self)),
d3853 1
d3868 1
a3868 1
    gtk_table_attach(GTK_TABLE(get_widget(self)),
d3881 3
a3883 2
    gtk_table_set_row_spacing(GTK_TABLE(get_widget(self)),
			      NUM2INT(row), NUM2INT(spc));
d3891 3
a3893 2
    gtk_table_set_col_spacing(GTK_TABLE(get_widget(self)),
			      NUM2INT(col), NUM2INT(spc));
d3901 3
a3903 1
    gtk_table_set_row_spacings(GTK_TABLE(get_widget(self)), NUM2INT(spc));
d3911 3
a3913 1
    gtk_table_set_col_spacings(GTK_TABLE(get_widget(self)), NUM2INT(spc));
d3939 3
a3941 1
    gtk_text_set_editable(GTK_TEXT(get_widget(self)), RTEST(editable));
d3949 3
a3951 1
    gtk_text_set_adjustments(GTK_TEXT(get_widget(self)),
d3962 3
a3964 1
    gtk_text_set_point(GTK_TEXT(get_widget(self)), NUM2INT(index));
d3972 2
a3973 1
    int index = gtk_text_get_point(GTK_TEXT(get_widget(self)));
d3982 2
a3983 1
    int len = gtk_text_get_length(GTK_TEXT(get_widget(self)));
d3992 3
a3994 1
    gtk_text_freeze(GTK_TEXT(get_widget(self)));
d4002 3
a4004 1
    gtk_text_thaw(GTK_TEXT(get_widget(self)));
d4012 2
d4015 1
a4015 1
    gtk_text_insert(GTK_TEXT(get_widget(self)), 
d4029 3
a4031 1
    gtk_text_backward_delete(GTK_TEXT(get_widget(self)), NUM2INT(nchars));
d4039 3
a4041 1
    gtk_text_forward_delete(GTK_TEXT(get_widget(self)), NUM2INT(nchars));
d4064 2
a4065 2
tbar_append_item(self, text, ttext, ptext, icon, func)
    VALUE self, text, ttext, ptext, icon, func;
d4067 2
d4072 1
a4072 1
    gtk_toolbar_append_item(GTK_TOOLBAR(get_widget(self)),
a4074 1
			    STR2CSTR(ptext),
d4082 2
a4083 2
tbar_prepend_item(self, text, ttext, ptext, icon, func)
    VALUE self, text, ttext, ptext, icon, func;
d4085 2
d4090 1
a4090 1
    gtk_toolbar_prepend_item(GTK_TOOLBAR(get_widget(self)),
a4092 1
			     STR2CSTR(ptext),
d4100 2
a4101 2
tbar_insert_item(self, text, ttext, ptext, icon, func, pos)
    VALUE self, text, ttext, ptext, icon, func, pos;
d4103 2
d4108 1
a4108 1
    gtk_toolbar_insert_item(GTK_TOOLBAR(get_widget(self)),
a4110 1
			    STR2CSTR(ptext),
d4122 3
a4124 1
    gtk_toolbar_append_space(GTK_TOOLBAR(get_widget(self)));
d4132 3
a4134 1
    gtk_toolbar_prepend_space(GTK_TOOLBAR(get_widget(self)));
d4142 3
a4144 1
    gtk_toolbar_insert_space(GTK_TOOLBAR(get_widget(self)), NUM2INT(pos));
d4152 3
a4154 1
    gtk_toolbar_set_orientation(GTK_TOOLBAR(get_widget(self)), 
d4163 3
a4165 1
    gtk_toolbar_set_style(GTK_TOOLBAR(get_widget(self)), 
d4174 3
a4176 1
    gtk_toolbar_set_space_size(GTK_TOOLBAR(get_widget(self)), NUM2INT(size));
d4184 3
a4186 1
    gtk_toolbar_set_tooltips(GTK_TOOLBAR(get_widget(self)), RTEST(enable));
d4194 1
a4194 2
    set_widget(self, gtk_tooltips_new());
    return Qnil;
d4202 1
a4202 1
    gtk_tooltips_set_tips(GTK_TOOLTIPS(get_widget(self)),
d4213 1
a4213 1
    gtk_tooltips_set_delay(GTK_TOOLTIPS(get_widget(self)), NUM2INT(delay));
d4222 1
a4222 1
    gtk_tooltips_enable(GTK_TOOLTIPS(get_widget(self)));
d4230 1
a4230 1
    gtk_tooltips_disable(GTK_TOOLTIPS(get_widget(self)));
d4246 3
a4248 1
    gtk_tree_append(GTK_TREE(get_widget(self)), get_widget(child));
d4256 3
a4258 1
    gtk_tree_prepend(GTK_TREE(get_widget(self)), get_widget(child));
d4266 3
a4268 2
    gtk_tree_insert(GTK_TREE(get_widget(self)), get_widget(child),
		    NUM2INT(pos));
d4296 3
a4298 2
    gtk_tree_item_set_subtree(GTK_TREE_ITEM(get_widget(self)),
			      get_widget(subtree));
d4306 3
a4308 1
    gtk_tree_item_select(GTK_TREE_ITEM(get_widget(self)));
d4316 3
a4318 1
    gtk_tree_item_deselect(GTK_TREE_ITEM(get_widget(self)));
d4326 3
a4328 1
    gtk_tree_item_expand(GTK_TREE_ITEM(get_widget(self)));
d4336 3
a4338 1
    gtk_tree_item_collapse(GTK_TREE_ITEM(get_widget(self)));
d4364 2
a4365 1
    GtkAdjustment *adj = gtk_viewport_get_hadjustment(GTK_VIEWPORT(get_widget(self)));
d4384 5
a4388 2
    gtk_viewport_set_vadjustment(GTK_VIEWPORT(get_widget(self)),
				 GTK_ADJUSTMENT(get_gobject(adj)));
d4397 5
a4401 2
    gtk_viewport_set_hadjustment(GTK_VIEWPORT(get_widget(self)),
				 GTK_ADJUSTMENT(get_gobject(adj)));
d4410 3
a4412 1
    gtk_viewport_set_shadow_type(GTK_VIEWPORT(get_widget(self)),
d4442 3
a4444 1
    gtk_button_pressed(GTK_BUTTON(get_widget(self)));
d4452 3
a4454 1
    gtk_button_released(GTK_BUTTON(get_widget(self)));
d4462 3
a4464 1
    gtk_button_clicked(GTK_BUTTON(get_widget(self)));
d4472 3
a4474 1
    gtk_button_enter(GTK_BUTTON(get_widget(self)));
d4482 3
a4484 1
    gtk_button_leave(GTK_BUTTON(get_widget(self)));
d4512 3
a4514 2
    gtk_toggle_button_set_mode(GTK_TOGGLE_BUTTON(get_widget(self)),
			       NUM2INT(mode));
d4522 3
a4524 2
    gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(get_widget(self)),
				NUM2INT(state));
d4532 3
a4534 1
    gtk_toggle_button_toggled(GTK_TOGGLE_BUTTON(get_widget(self)));
d4630 1
a4630 1
	gtk_box_pack_start(GTK_BOX(get_widget(self)), child, expand, fill, padding);
d4632 1
a4632 1
	gtk_box_pack_end(GTK_BOX(get_widget(self)), child, expand, fill, padding);
d4662 1
d4665 1
d4667 1
a4667 1
    set_widget(self, gtk_vbox_new(RTEST(homogeneous), NUM2INT(spacing)));
d4683 3
a4685 1
    gtk_color_selection_set_update_policy(GTK_COLOR_SELECTION(get_widget(self)),
d4694 3
a4696 1
    gtk_color_selection_set_opacity(GTK_COLOR_SELECTION(get_widget(self)),
d4705 1
d4716 1
a4716 1
    gtk_color_selection_set_color(GTK_COLOR_SELECTION(get_widget(self)), buf);
d4724 1
d4728 1
a4728 1
    gtk_color_selection_get_color(GTK_COLOR_SELECTION(get_widget(self)), buf);
d4761 3
a4763 1
    gtk_pixmap_set(GTK_PIXMAP(get_widget(self)),
d4772 1
d4776 1
a4776 1
    gtk_pixmap_get(GTK_PIXMAP(get_widget(self)), &val, &mask);
d4794 3
a4796 2
    gtk_drawing_area_size(GTK_DRAWING_AREA(get_widget(self)),
			  NUM2INT(w), NUM2INT(h));
d4812 2
d4815 1
a4815 1
    gtk_entry_set_text(GTK_ENTRY(get_widget(self)), RSTRING(text)->ptr);
d4840 3
a4842 1
    gtk_fixed_put(GTK_FIXED(get_widget(self)), get_widget(win), NUM2INT(x), NUM2INT(y));
d4850 3
a4852 1
    gtk_fixed_move(GTK_FIXED(get_widget(self)), get_widget(win), NUM2INT(x), NUM2INT(y));
d4868 3
a4870 1
    return float_new(GTK_GAMMA_CURVE(get_widget(self))->gamma);
d4885 1
a4885 1
    int i = gtk_hbutton_box_get_spacing_default();
d4887 1
a4887 1
    return INT2FIX(i);
d4894 1
a4894 1
    int i = gtk_hbutton_box_get_layout_default();
d4896 1
a4896 1
    return INT2FIX(i);
d4927 1
a4927 1
    int i = gtk_vbutton_box_get_spacing_default();
d4929 1
a4929 1
    return INT2FIX(i);
d4936 1
a4936 1
    int i = gtk_vbutton_box_get_layout_default();
d4938 1
a4938 1
    return INT2FIX(i);
d4964 1
d4967 1
d4969 1
a4969 1
    set_widget(self, gtk_hbox_new(RTEST(homogeneous), NUM2INT(spacing)));
d4977 3
a4979 1
    gtk_paned_add1(GTK_PANED(get_widget(self)), get_widget(child));
d4987 3
a4989 1
    gtk_paned_add2(GTK_PANED(get_widget(self)), get_widget(child));
d4997 3
a4999 1
    gtk_paned_handle_size(GTK_PANED(get_widget(self)), NUM2INT(size));
d5007 3
a5009 1
    gtk_paned_gutter_size(GTK_PANED(get_widget(self)), NUM2INT(size));
d5033 3
a5035 1
    gtk_ruler_set_metric(GTK_RULER(get_widget(self)), 
d5045 3
a5047 1
    gtk_ruler_set_range(GTK_RULER(get_widget(self)), 
d5058 3
a5060 1
    gtk_ruler_draw_ticks(GTK_RULER(get_widget(self)));
d5068 3
a5070 1
    gtk_ruler_draw_pos(GTK_RULER(get_widget(self)));
d5101 3
a5103 1
    gtk_range_set_update_policy(GTK_RANGE(get_widget(self)),
d5112 4
a5115 2
    gtk_range_set_adjustment(GTK_RANGE(get_widget(self)),
			     GTK_ADJUSTMENT(get_gobject(adj)));
d5124 3
a5126 1
    gtk_range_draw_background(GTK_RANGE(get_widget(self)));
d5134 3
a5136 1
    gtk_range_draw_trough(GTK_RANGE(get_widget(self)));
d5144 3
a5146 1
    gtk_range_draw_slider(GTK_RANGE(get_widget(self)));
d5154 3
a5156 1
    gtk_range_draw_step_forw(GTK_RANGE(get_widget(self)));
d5164 3
a5166 1
    gtk_range_draw_step_back(GTK_RANGE(get_widget(self)));
d5174 3
a5176 1
    gtk_range_slider_update(GTK_RANGE(get_widget(self)));
d5184 1
a5184 1
    int i;
d5186 2
a5187 4
    i = gtk_range_trough_click(GTK_RANGE(get_widget(self)),
			       NUM2INT(x), NUM2INT(y),
			       0);
    return INT2FIX(i);
d5194 3
a5196 1
    gtk_range_default_hslider_update(GTK_RANGE(get_widget(self)));
d5204 3
a5206 1
    gtk_range_default_vslider_update(GTK_RANGE(get_widget(self)));
d5214 1
a5214 1
    int i;
d5216 3
a5218 4
    i = gtk_range_default_htrough_click(GTK_RANGE(get_widget(self)),
					NUM2INT(x), NUM2INT(y),
					0);
    return INT2FIX(i);
d5222 2
a5223 2
range_default_vtrough_click(self, x, y, jump_prec)
    VALUE self, x, y, jump_prec;
d5225 1
a5225 1
    int i;
d5227 3
a5229 4
    i = gtk_range_default_vtrough_click(GTK_RANGE(get_widget(self)),
					NUM2INT(x), NUM2INT(y),
					0);
    return INT2FIX(i);
d5236 3
a5238 1
    gtk_range_default_hmotion(GTK_RANGE(get_widget(self)),
d5247 3
a5249 1
    gtk_range_default_vmotion(GTK_RANGE(get_widget(self)),
d5258 3
a5260 1
    gtk_range_calc_value(GTK_RANGE(get_widget(self)), NUM2INT(pos));
d5268 3
a5270 1
    gtk_scale_set_digits(GTK_SCALE(get_widget(self)), NUM2INT(digits));
d5278 3
a5280 2
    gtk_scale_set_draw_value(GTK_SCALE(get_widget(self)),
			     NUM2INT(draw_value));
d5288 3
a5290 1
    gtk_scale_set_value_pos(GTK_SCALE(get_widget(self)), 
d5299 2
a5300 1
    int i = gtk_scale_value_width(GTK_SCALE(get_widget(self)));
d5309 3
a5311 1
    gtk_scale_draw_value(GTK_SCALE(get_widget(self)));
d6095 1
a6095 1
    gTooltips = rb_define_class_under(mGtk, "Tooltips", cData);
d6100 5
a6104 5
    gAcceleratorTable = rb_define_class_under(mGtk, "AcceleratorTable", cData);
    gStyle = rb_define_class_under(mGtk, "Style", cData);
    gPreviewInfo = rb_define_class_under(mGtk, "PreviewInfo", cData);
    gRequisiton = rb_define_class_under(mGtk, "Requisiton", cData);
    gAllocation = rb_define_class_under(mGtk, "Allocation", cData);
d6108 3
a6110 3
    gdkFont = rb_define_class_under(mGdk, "Font", cData);
    gdkColor = rb_define_class_under(mGdk, "Color", cData);
    gdkDrawable = rb_define_class_under(mGdk, "Drawable", cData);
d6114 11
a6124 11
    gdkImage = rb_define_class_under(mGdk, "Image", cData);
    gdkVisual = rb_define_class_under(mGdk, "Visual", cData);
    gdkGC = rb_define_class_under(mGdk, "GC", cData);
    gdkGCValues = rb_define_class_under(mGdk, "GCValues", cData);
    gdkRectangle = rb_define_class_under(mGdk, "Rectangle", cData);
    gdkSegment = rb_define_class_under(mGdk, "Segment", cData);
    gdkWindowAttr = rb_define_class_under(mGdk, "WindowAttr", cData);
    gdkCursor = rb_define_class_under(mGdk, "Cursor", cData);
    gdkAtom = rb_define_class_under(mGdk, "Atom", cData);
    gdkColorContext = rb_define_class_under(mGdk, "ColotContext", cData);
    gdkEvent = rb_define_class_under(mGdk, "gdkEvent", cData);
d6655 3
a6657 3
    rb_define_method(gToolbar, "append_item", tbar_append_item, 5);
    rb_define_method(gToolbar, "prepend_item", tbar_prepend_item, 5);
    rb_define_method(gToolbar, "insert_item", tbar_insert_item, 6);
d6796 1
d6805 2
d6808 5
d6948 1
@


1.1.1.1.2.15
log
@signal delivered to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/03/11 07:33:03 $
a46 1
static VALUE gEditable;
a4432 92
edit_sel_region(self, start, end)
    VALUE self, start, end;
{
    gtk_editable_select_region(GTK_EDITABLE(get_widget(self)),
			       NUM2INT(start), NUM2INT(end));
    return self;
}

static VALUE
edit_insert_text(self, new_text)
    VALUE self;
{
    gint pos;

    Check_Type(new_text, T_STRING);
    gtk_editable_insert_text(GTK_EDITABLE(get_widget(self)),
			     RSTRING(new_text)->ptr,
			     RSTRING(new_text)->len,
			     &pos);
    return INT2NUM(pos);
}

static VALUE
edit_delete_text(self, start, end)
    VALUE self, start, end;
{
    gtk_editable_delete_text(GTK_EDITABLE(get_widget(self)),
			     NUM2INT(start), NUM2INT(end));
    return self;
}

static VALUE
edit_get_chars(self, start, end)
    VALUE self, start, end;
{
    gchar *s;

    s = gtk_editable_get_chars(GTK_EDITABLE(get_widget(self)),
			       NUM2INT(start), NUM2INT(end));
    return str_new2(s);
}

static VALUE
edit_cut_clipboard(self, time)
    VALUE self, time;
{
    gtk_editable_cut_clipboard(GTK_EDITABLE(get_widget(self)),NUM2INT(time));
    return self;
}

static VALUE
edit_copy_clipboard(self, time)
    VALUE self, time;
{
    gtk_editable_copy_clipboard(GTK_EDITABLE(get_widget(self)),NUM2INT(time));
    return self;
}
	
static VALUE
edit_paste_clipboard(self, time)
    VALUE self, time;
{
    gtk_editable_paste_clipboard(GTK_EDITABLE(get_widget(self)),NUM2INT(time));
    return self;
}
	
static VALUE
edit_claim_selection(self, claim, time)
    VALUE self, claim, time;
{
    gtk_editable_claim_selection(GTK_EDITABLE(get_widget(self)),
				 RTEST(claim), NUM2INT(time));
    return self;
}
	
static VALUE
edit_delete_selection(self)
    VALUE self;
{
    gtk_editable_delete_selection(GTK_EDITABLE(get_widget(self)));
    return self;
}

static VALUE
edit_changed(self)
    VALUE self;
{
    gtk_editable_changed(GTK_EDITABLE(get_widget(self)));
    return self;
}

static VALUE
d5628 1
a5628 2
    gEditable = rb_define_class_under(mGtk, "Editable", gWidget);
    gEntry = rb_define_class_under(mGtk, "Entry", gEditable);
d5669 1
a5669 1
    gText = rb_define_class_under(mGtk, "Text", gEditable);
a5959 12

    /* Editable */
    rb_define_method(gEditable, "select_region", edit_sel_region, 2);
    rb_define_method(gEditable, "insert_text", edit_insert_text, 3);
    rb_define_method(gEditable, "delete_text", edit_delete_text, 2);
    rb_define_method(gEditable, "get_chars", edit_get_chars, 2);
    rb_define_method(gEditable, "cut_clipboard", edit_cut_clipboard, 1);
    rb_define_method(gEditable, "copy_clipboard", edit_copy_clipboard, 1);
    rb_define_method(gEditable, "paste_clipboard", edit_paste_clipboard, 1);
    rb_define_method(gEditable, "claim_selection", edit_claim_selection, 2);
    rb_define_method(gEditable, "delete_selection", edit_delete_selection, 0);
    rb_define_method(gEditable, "changed", edit_changed, 0);
@


1.1.1.1.2.16
log
@gdk_draw_bitmap
@
text
@d6 1
a6 1
  $Date: 1998/04/14 04:55:51 $
d907 1
a907 1
	    return make_gobject(gTooltips, GTK_OBJECT(GTK_VALUE_BOXED(*arg)));
d3880 1
a3880 1
ttips_set_tip(self, win, text,priv)
d3884 3
a3886 4
    gtk_tooltips_set_tip(GTK_TOOLTIPS(get_widget(self)),
			 get_widget(win),
			 RSTRING(text)->ptr,
			 RSTRING(priv)->ptr);
a3900 10
ttips_set_colors(self, back, fore)
    VALUE self, back, fore;
{
    gtk_tooltips_set_colors(GTK_TOOLTIPS(get_widget(self)),
			    get_gdkcolor(back),
			    get_gdkcolor(fore));
    return self;
}

static VALUE
d4934 8
d5471 1
a5471 2
    /* why there's no gdk_draw_bitmap()?? */
    gdk_draw_pixmap(get_gdkdrawable(self), get_gdkgc(gc),
d6150 1
d6350 1
a6350 1
    rb_define_method(gTooltips, "set_tip", ttips_set_tip, 3);
a6351 1
    rb_define_method(gTooltips, "set_colors", ttips_set_colors, 2);
@


1.1.1.1.2.17
log
@gtk/nested local variables
@
text
@d6 1
a6 1
  $Date: 1998/04/23 07:38:03 $
a44 1
static VALUE gCombo;
a101 2
static VALUE mRC;

a142 3
    if (!gtkp) {
	ArgError("destroyed GtkObject");
    }
a201 1
    ary_delete(gtk_object_list, obj);
d205 1
d232 1
d544 1
d547 1
a547 1
				     STR2CSTR(fname));
d549 1
a549 1
	ArgError("Pixmap not created from %s", STR2CSTR(fname));
d568 2
a569 1
	buf[i] = STR2CSTR(RARRAY(data)->ptr[i]);
a1104 1
    VALUE a = RARRAY(data)->ptr[3];
d1107 1
a1107 2
    VALUE args = ary_new2(nparams+1+RARRAY(a)->len);
    int i;
a1109 3
    for (i=0; i<RARRAY(a)->len; i++) {
	ary_push(args, RARRAY(a)->ptr[i]);
    }
a1157 40
nil()
{
    return Qnil;
}

static GtkObject*
try_get_gobject(self)
    VALUE self;
{
    return (GtkObject*)rb_rescue(get_gobject, self, nil, Qnil);
}

static VALUE
gobj_equal(self, other)
    VALUE self, other;
{
    if (self == other) return TRUE;
    if (get_gobject(self) == try_get_gobject(other)) return TRUE;
    return FALSE;
}

static VALUE
gobj_inspect(self)
    VALUE self;
{
    VALUE iv = rb_ivar_get(self, id_gtkdata);
    char *cname = rb_class2name(CLASS_OF(self));
    char *s;

    s = ALLOCA_N(char, strlen(cname)+8+16+1); /* 6:tags 16:addr 1:eos */
    if (NIL_P(iv) || RDATA(iv)->data == 0) {
	sprintf(s, "#<%s: destroyed>", cname);
    }
    else {
	sprintf(s, "#<%s: id=0x%x>", cname, get_gobject(self));
    }
    return str_new2(s);
}

static VALUE
a1160 6
    VALUE iv = rb_ivar_get(self, id_gtkdata);

    if (NIL_P(iv) || RDATA(iv)->data == 0) {
	/* destroyed object */
	return Qnil;
    }
d1190 1
a1190 1
    VALUE sig, data, args;
d1194 7
a1200 3
    rb_scan_args(argc, argv, "1*", &sig, &args);
    id = rb_intern(STR2CSTR(sig));
    data = ary_new3(3, f_lambda(), INT2NUM(id), args);
d1203 1
a1203 1
				  STR2CSTR(sig),
d1216 1
a1216 1
    VALUE sig, data, args;
d1220 6
a1225 3
    rb_scan_args(argc, argv, "1*", &sig, &args);
     id = rb_intern(STR2CSTR(sig));
    data = ary_new3(3, f_lambda(), INT2NUM(id), args);
d1227 2
a1228 2
     i = gtk_signal_connect_interp(GTK_OBJECT(get_widget(self)),
				  STR2CSTR(sig),
d1486 10
d2151 2
a2152 1
	    buf[i] = STR2CSTR(RARRAY(titles)->ptr[i]);
d2391 2
a2392 1
	buf[i] = STR2CSTR(RARRAY(text)->ptr[i]);
d2412 2
a2413 1
	buf[i] = STR2CSTR(RARRAY(text)->ptr[i]);
d2570 1
d2572 1
a2572 1
				    STR2CSTR(fname));
d3148 2
a3149 1
	    label = STR2CSTR(arg2);
d3883 1
d3886 2
a3887 2
			 STR2CSTR(text),
			 STR2CSTR(priv));
d3969 2
a3970 1
	widget = gtk_tree_item_new_with_label(STR2CSTR(label));
d4097 2
a4098 1
	widget = gtk_button_new_with_label(STR2CSTR(label));
d4157 2
a4158 1
	widget = gtk_toggle_button_new_with_label(STR2CSTR(label));
a4194 9
tbtn_active(self)
    VALUE self;
{
    if (GTK_TOGGLE_BUTTON(get_widget(self))->active)
	return TRUE;
    return FALSE;
}

static VALUE
d4203 2
a4204 1
	widget = gtk_check_button_new_with_label(STR2CSTR(label));
d4230 2
a4231 1
	    label = STR2CSTR(arg2);
d4388 5
a4392 1
    set_widget(self, gtk_color_selection_dialog_new(STR2CSTR(title)));
d4548 2
a4549 4
    gtk_entry_set_text(GTK_ENTRY(get_widget(self)), STR2CSTR(text));

    return self;
}
a4550 5
static VALUE
entry_set_editable(self, editable)
    VALUE self, editable;
{
    gtk_entry_set_editable(GTK_ENTRY(get_widget(self)), RTEST(editable));
a4699 108
combo_initialize(self)
    VALUE self;
{
    set_widget(self, gtk_combo_new());
    return Qnil;
}

static VALUE
combo_val_in_list(self, val, ok)
    VALUE self, val, ok;
{
    gtk_combo_set_value_in_list(GTK_COMBO(get_widget(self)),
				RTEST(val), RTEST(ok));
    return Qnil;
}

static VALUE
combo_use_arrows(self, val)
    VALUE self, val;
{
    gtk_combo_set_use_arrows(GTK_COMBO(get_widget(self)),
			     RTEST(val));
    return Qnil;
}

static VALUE
combo_case_sensitive(self, val)
    VALUE self, val;
{
    gtk_combo_set_case_sensitive(GTK_COMBO(get_widget(self)),
				 RTEST(val));
    return Qnil;
}

static VALUE
combo_item_string(self, item, val)
    VALUE self, item, val;
{
    gtk_combo_set_item_string(GTK_COMBO(get_widget(self)),
			      GTK_ITEM(get_widget(self)),
			      STR2CSTR(val));
    return Qnil;
}

static VALUE
combo_popdown_strings(self, ary)
    VALUE self, ary;
{
    int i;
    GList *glist = NULL;

    Check_Type(ary, T_ARRAY);
    for (i=0; i<RARRAY(ary)->len; i++) {
	/* check to avoid memory leak */
	STR2CSTR(RARRAY(ary)->ptr[i]);
    }
    for (i=0; i<RARRAY(ary)->len; i++) {
	glist = g_list_append(glist,STR2CSTR(RARRAY(ary)->ptr[i]));
    }

    gtk_combo_set_popdown_strings(GTK_COMBO(get_widget(self)), glist);
    return Qnil;
}

static VALUE
combo_disable_activate(self)
    VALUE self;
{
    gtk_combo_disable_activate(GTK_COMBO(get_widget(self)));
    return Qnil;
}

static VALUE
combo_entry(self)
    VALUE self;
{
    return make_widget(gEntry, GTK_COMBO(get_widget(self))->entry);
}

static VALUE
combo_button(self)
    VALUE self;
{
    return make_widget(gButton, GTK_COMBO(get_widget(self))->button);
}

static VALUE
combo_popup(self)
    VALUE self;
{
    return make_widget(gScrolledWin, GTK_COMBO(get_widget(self))->popup);
}

static VALUE
combo_popwin(self)
    VALUE self;
{
    return make_widget(gWindow, GTK_COMBO(get_widget(self))->popwin);
}

static VALUE
combo_list(self)
    VALUE self;
{
    return make_widget(gList, GTK_COMBO(get_widget(self))->list);
}

static VALUE
a5379 39
static VALUE
gtk_rc_m_parse(self, rc)
    VALUE self, rc;
{
    gtk_rc_parse(STR2CSTR(rc));
    return Qnil;
}

static VALUE
gtk_rc_m_parse_string(self, rc)
    VALUE self, rc;
{
    gtk_rc_parse_string(STR2CSTR(rc));
    return Qnil;
}

static VALUE
gtk_rc_m_get_style(self, w)
    VALUE self, w;
{
    GtkStyle *s = gtk_rc_get_style(get_widget(w));
    return make_gstyle(s);
}

static VALUE
gtk_rc_m_add_widget_name_style(self, style, pat)
    VALUE self, style, pat;
{
    gtk_rc_add_widget_name_style(get_gstyle(style), STR2CSTR(pat));
    return Qnil;
}

static VALUE
gtk_rc_m_add_widget_class_style(self, style, pat)
    VALUE self, style, pat;
{
    gtk_rc_add_widget_class_style(get_gstyle(style), STR2CSTR(pat));
    return Qnil;
}
a5693 1
    gtk_set_locale();
a5732 1
    gCombo = rb_define_class_under(mGtk, "Combo", gHBox);
a5779 2
    mRC = rb_define_module_under(mGtk, "RC");

a5807 2
    rb_define_method(gObject, "==", gobj_equal, 1);
    rb_define_method(gObject, "inspect", gobj_inspect, 0);
d5810 1
a5954 1
    rb_define_method(gTButton, "active", tbtn_active, 0);
d5960 2
a5961 2
    rb_define_method(gRButton, "initialize", rbtn_initialize, -1);
    rb_define_method(gRButton, "group", rbtn_group, 0);
a6073 1
    rb_define_method(gEntry, "set_editable", entry_set_editable, 1);
a6111 15
    /* Combo */
    rb_define_method(gCombo, "initialize", combo_initialize, 0);
    rb_define_method(gCombo, "set_value_in_list", combo_val_in_list, 2);
    rb_define_method(gCombo, "set_use_arrows", combo_use_arrows, 1);
    rb_define_method(gCombo, "set_case_sensitive", combo_case_sensitive, 1);
    rb_define_method(gCombo, "set_item_string", combo_item_string, 2);
    rb_define_method(gCombo, "set_popdown_strings", combo_popdown_strings, 1);
    rb_define_method(gCombo, "disable_activate", combo_disable_activate, 0);

    rb_define_method(gCombo, "entry", combo_entry, 0);
    rb_define_method(gCombo, "button", combo_button, 0);
    rb_define_method(gCombo, "popup", combo_popup, 0);
    rb_define_method(gCombo, "popwin", combo_popwin, 0);
    rb_define_method(gCombo, "list", combo_list, 0);

a6431 9
    /* RC module */
    rb_define_module_function(mRC, "parse", gtk_rc_m_parse, 1);
    rb_define_module_function(mRC, "parse_string", gtk_rc_m_parse_string, 1);
    rb_define_module_function(mRC, "get_style", gtk_rc_m_get_style, 1);
    rb_define_module_function(mRC, "add_widget_name_style",
			      gtk_rc_m_add_widget_name_style, 1);
    rb_define_module_function(mRC, "add_widget_class_style",
			      gtk_rc_m_add_widget_class_style, 1);

d6585 1
a6585 1
    argv[0] = STR2CSTR(rb_argv0);
d6607 1
a6607 1
	gtk_init(&argc, &argv);
@


1.1.1.1.2.18
log
@tcltklib/gtk
@
text
@d6 1
a6 1
  $Date: 1998/04/24 09:33:24 $
d1108 1
a1108 1
    VALUE a = RARRAY(data)->ptr[2];
d1155 1
a1155 1
	VALUE data = ary_new3(3, Qnil, id, ary_new2(0));
a5731 3
#ifdef THREAD
    if (!thread_critical) thread_schedule();
#endif
d5743 4
a5746 2
timeout_add(self, interval)
    VALUE self, interval;
d5748 1
d5751 4
d5756 1
a5756 1
				(gpointer)f_lambda(), 0);
d5769 3
a5771 1
idle_add(self)
d5774 1
d5777 5
a5781 1
    id = gtk_idle_add_interp(exec_interval, (gpointer)f_lambda(), 0);
d6627 1
a6627 1
    rb_define_module_function(mGtk, "timeout_add", timeout_add, 1);
d6629 1
a6629 1
    rb_define_module_function(mGtk, "idle_add", idle_add, 0);
a6841 1
#if 0
a6842 4
#else
    /* use timeout to avoid busy wait */
    gtk_timeout_add(1, (GtkFunction)idle, 0);
#endif
@


1.1.1.1.2.19
log
@fujioto's patch
@
text
@d6 1
a6 1
  $Date: 1998/04/27 10:04:05 $
a4584 41
entry_append_text(self, text)
    VALUE self, text;
{
    gtk_entry_append_text(GTK_ENTRY(get_widget(self)), STR2CSTR(text));
    return self;
}

static VALUE
entry_prepend_text(self, text)
    VALUE self, text;
{
    gtk_entry_prepend_text(GTK_ENTRY(get_widget(self)), STR2CSTR(text));
    return self;
}

static VALUE
entry_set_position(self, position)
    VALUE self, position;
{
    gtk_entry_set_position(GTK_ENTRY(get_widget(self)), NUM2INT(position));
    return self;
}

static VALUE
entry_get_text(self)
    VALUE self;
{
    gchar* text;
    text = gtk_entry_get_text(GTK_ENTRY(get_widget(self)));
    return str_new2(text);
}

static VALUE
entry_set_visibility(self, visibility)
    VALUE self, visibility;
{
    gtk_entry_set_visibility(GTK_ENTRY(get_widget(self)), RTEST(visibility));
    return self;
}

static VALUE
a4592 8
entry_set_max_length(self, max)
    VALUE self, max;
{
    gtk_entry_set_max_length(GTK_ENTRY(get_widget(self)), NUM2INT(max));
    return self;
}

static VALUE
a6253 5
    rb_define_method(gEntry, "append_text", entry_append_text, 1);
    rb_define_method(gEntry, "prepend_text", entry_prepend_text, 1);
    rb_define_method(gEntry, "set_position", entry_set_position, 1);
    rb_define_method(gEntry, "get_text", entry_get_text, 0);
    rb_define_method(gEntry, "set_visibility", entry_set_visibility, 1);
a6254 1
    rb_define_method(gEntry, "set_max_length", entry_set_max_length, 1);
a6786 4

    rb_define_const(mGdk, "CURRENT_TIME", INT2FIX(GDK_CURRENT_TIME));
    rb_define_const(mGdk, "NONE", INT2FIX(GDK_NONE));
    rb_define_const(mGdk, "PARENT_RELATIVE", INT2FIX(GDK_PARENT_RELATIVE));
@


1.1.1.1.2.20
log
@prototypes
@
text
@d6 1
a6 1
  $Date: 1998/04/28 06:14:45 $
d1175 1
a1175 1
    return (GtkObject*)rb_rescue((VALUE(*)())get_gobject, self, nil, 0);
@


1.1.1.1.2.21
log
@thread->thred
@
text
@d6 1
a6 1
  $Date: 1998/05/14 04:10:36 $
d5782 1
a5782 1
    if (!thred_critical) thred_schedule();
@


1.1.1.1.2.22
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/06/24 04:38:05 $
d12 1
a12 1
#include "rubysig.h"
d6054 1
a6054 1
    rb_define_method(gWidget, "size_allocate", widget_size_allocate, 1);
d6211 1
a6211 1
    rb_define_method(gCList, "initialize", clist_initialize, 1);
@


1.1.1.1.2.23
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/06/26 08:08:47 $
d5782 1
a5782 1
    if (!thread_critical) thread_schedule();
@


1.1.1.1.2.24
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/06/30 01:40:47 $
a513 12
gdkdraw_get_geometry(self)
    VALUE self;
{
    gint x, y, width, height, depth;

    gdk_window_get_geometry(get_gdkdrawable(self),
			    &x, &y, &width, &height, &depth);
    return ary_new3(5, INT2NUM(x), INT2NUM(y),
		    INT2NUM(width), INT2NUM(height), INT2NUM(depth));
}

static VALUE
a2057 10
widget_shape_combine_mask(self, gdk_pixmap_mask, x, y)
    VALUE self, gdk_pixmap_mask, x, y;
{
    gtk_widget_shape_combine_mask(get_widget(self),
				  get_gdkpixmap(gdk_pixmap_mask),
				  NUM2INT(x), NUM2INT(y));
    return self;
}

static VALUE
a6088 1
    rb_define_method(gWidget, "shape_combine_mask", widget_shape_combine_mask, 3);
a6708 1
    rb_define_method(gdkDrawable, "get_geometry", gdkdraw_get_geometry, 0);
@


1.1.1.1.2.25
log
@0.10pre
@
text
@d6 1
a6 1
  $Date: 1998/07/03 06:28:57 $
a13 1
#include <gdk/gdkx.h> /* for GDK_ROOT_WINDOW() */
a88 1
static VALUE gStatusBar;
d119 1
a126 22
static VALUE gdkEventType;
static VALUE gdkEventAny;
static VALUE gdkEventExpose;
static VALUE gdkEventNoExpose;
static VALUE gdkEventVisibility;
static VALUE gdkEventMotion;
static VALUE gdkEventButton;
static VALUE gdkEventKey;
static VALUE gdkEventCrossing;
static VALUE gdkEventFocus;
static VALUE gdkEventConfigure;
static VALUE gdkEventProperty;
static VALUE gdkEventSelection;
static VALUE gdkEventProximity;
static VALUE gdkEventDragBegin;
static VALUE gdkEventDragRequest;
static VALUE gdkEventDropEnter;
static VALUE gdkEventDropLeave;
static VALUE gdkEventDropDataAvailable;
static VALUE gdkEventClient;
static VALUE gdkEventOther;

d404 3
a711 49
gdkwin_get_pointer(self)
     VALUE self;
{
  int x, y;
  GdkModifierType state;
  gdk_window_get_pointer(get_gdkwindow(self), &x, &y, &state);
  return ary_new3(3, INT2FIX(x), INT2FIX(y), INT2FIX((int)state));

}

static VALUE
gdkwin_pointer_grab(self, owner_events, event_mask, confine_to, cursor, time)
     VALUE self, owner_events, event_mask, confine_to, cursor, time;
{
  gdk_pointer_grab(get_gdkwindow(self),
		   NUM2INT(owner_events),
		   NUM2INT(event_mask),
		   NULL,  /*get_gdkwindow(confine_to),*/
		   NULL,  /*get_gdkcursor(cursor),*/
		   NUM2INT(time));
  return self;
}

static VALUE
gdkwin_pointer_ungrab(self, time)
     VALUE self, time;
{
  gdk_pointer_ungrab(NUM2INT(time));
  return self;
}

static VALUE
gdkwin_foreign_new(self, anid)
     VALUE self, anid;
{
  GdkWindow *window;
  window = gdk_window_foreign_new(NUM2INT(anid));
  return make_gdkwindow(window);
}

static VALUE
gdkwin_root_window(self)
     VALUE self;
{
  return INT2NUM(GDK_ROOT_WINDOW() );
}


static VALUE
d716 1
a716 16
    switch (event->type) {
    case GDK_EXPOSE:
    case GDK_NO_EXPOSE:
      return Data_Wrap_Struct(gdkEventExpose, 0, gdk_event_free, event);
      break;
    case GDK_MOTION_NOTIFY:
      return Data_Wrap_Struct(gdkEventMotion, 0, gdk_event_free, event);
      break;
    case GDK_BUTTON_PRESS:
    case GDK_2BUTTON_PRESS:
    case GDK_3BUTTON_PRESS:
      return Data_Wrap_Struct(gdkEventButton, 0, gdk_event_free, event);
      break;
    default:
      return Data_Wrap_Struct(gdkEvent, 0, gdk_event_free, event);
    }
d727 2
a728 2
    if (!obj_is_kind_of(event, gdkEvent)) {
	TypeError("not a GdkEvent... ");
a738 1
    gdk_gc_ref(gc);
d961 1
a961 1
	    ary_push(args, make_gdkrectangle(GTK_VALUE_POINTER(params[0])));
d1477 1
a1477 1
    set_widget(self, gtk_frame_new(NIL_P(label)?NULL:STR2CSTR(label)));
d1513 1
a1513 1
    set_widget(self, gtk_aspect_frame_new(NIL_P(label)?NULL:STR2CSTR(label),
a2079 14
widget_get_alloc(self)
	VALUE self;
{
	return make_gallocation(&(get_widget(self)->allocation));
}

static VALUE
widget_state(self)
	VALUE self;
{
	return INT2FIX(get_widget(self)->state);
}

static VALUE
d2567 2
a2568 2
			   NIL_P(wmclass1)?NULL:STR2CSTR(wmclass1),
			   NIL_P(wmclass2)?NULL:STR2CSTR(wmclass2));
a2606 27
gwin_grab_add(self)
     VALUE self;
{
  gtk_grab_add(get_widget(self));
  return self;
}

static VALUE
gwin_grab_remove(self)
     VALUE self;
{
  gtk_grab_remove(get_widget(self));
  return self;
}

static VALUE
gwin_shape_combine_mask(self, shape_mask, offset_x, offset_y)
     VALUE self, shape_mask, offset_x, offset_y;
{
  gtk_widget_shape_combine_mask(get_widget(self),
				get_gdkbitmap(shape_mask),
				NUM2INT(offset_x),
				NUM2INT(offset_y));
  return self;
}

static VALUE
a2696 17
label_get(self)
     VALUE self;
{
  gchar** str;
  gtk_label_get(GTK_LABEL(get_widget(self)), str);
  return str_new2(*str);
}

static VALUE
label_set(self, str)
     VALUE self, str;
{
     gtk_label_set(GTK_LABEL(get_widget(self)), STR2CSTR(str));
     return Qnil;
}

static VALUE
d3823 3
a3825 3
			    NIL_P(text)?NULL:STR2CSTR(text),
			    NIL_P(ttext)?NULL:STR2CSTR(ttext),
			    NIL_P(ptext)?NULL:STR2CSTR(ptext),
d3840 3
a3842 3
			     NIL_P(text)?NULL:STR2CSTR(text),
			     NIL_P(ttext)?NULL:STR2CSTR(ttext),
			     NIL_P(ptext)?NULL:STR2CSTR(ptext),
d3857 3
a3859 3
			    NIL_P(text)?NULL:STR2CSTR(text),
			    NIL_P(ttext)?NULL:STR2CSTR(ttext),
			    NIL_P(ptext)?NULL:STR2CSTR(ptext),
d3934 2
a3935 2
ttips_set_tip(self, win, text, priv)
    VALUE self, win, text, priv;
d3939 2
a3940 2
			 NIL_P(text)?NULL:STR2CSTR(text),
			 NIL_P(priv)?NULL:STR2CSTR(priv));
a4808 52
statusbar_initialize(self)
     VALUE self;
{
  set_widget(self, gtk_statusbar_new());
  return Qnil;
}

static VALUE
statusbar_push(self, id, text)
     VALUE self;
     VALUE id;
     VALUE text;
{
  gint message_id;
  message_id = gtk_statusbar_push(GTK_STATUSBAR(get_widget(self)), 
				  NUM2INT(id), STR2CSTR(text));
  return INT2FIX(message_id);
}

static VALUE
statusbar_pop(self, id)
     VALUE self;
     VALUE id;
{
  gtk_statusbar_pop(GTK_STATUSBAR(get_widget(self)), NUM2INT(id));
  return Qnil;

}

static VALUE
statusbar_get_context_id(self, text)
     VALUE self;
     VALUE text;
{
  gint context_id;
  context_id = gtk_statusbar_get_context_id(GTK_STATUSBAR(get_widget(self)),
					    STR2CSTR(text));
  return INT2FIX(context_id);
}

static VALUE
statusbar_remove(self, cid, mid)
     VALUE self;
     VALUE cid;
     VALUE mid;
{
  gtk_statusbar_remove(GTK_STATUSBAR(get_widget(self)),
		       NUM2INT(cid), NUM2INT(mid)); 
  return Qnil;
}

static VALUE
d4849 1
a4849 1
			      NIL_P(val)?NULL:STR2CSTR(val));
a5589 25
gallocation_x(self)
{
	return INT2NUM(get_gallocation(self)->x);
}

static VALUE
gallocation_y(self)
{
	return INT2NUM(get_gallocation(self)->y);
}

static VALUE
gallocation_w(self)
{
	return INT2NUM(get_gallocation(self)->width);
}

static VALUE
gallocation_h(self)
{
	return INT2NUM(get_gallocation(self)->height);
}


static VALUE
a5798 98

static VALUE
gdkrect_s_new(self, x, y, width, height)
	VALUE self, x, y, width, height;
{
	GdkRectangle new;
	new.x = NUM2INT(x);
	new.y = NUM2INT(y);
	new.width = NUM2INT(width);
	new.height = NUM2INT(height);
	return make_gdkrectangle(&new);
}

static VALUE
gdkrect_x(self)
{
	return INT2NUM(get_gdkrectangle(self)->x);
}

static VALUE
gdkrect_y(self)
{
	return INT2NUM(get_gdkrectangle(self)->y);
}

static VALUE
gdkrect_w(self)
{
	return INT2NUM(get_gdkrectangle(self)->width);
}

static VALUE
gdkrect_h(self)
{
	return INT2NUM(get_gdkrectangle(self)->height);
}

static VALUE
gdkevent_type(self)
{
  return INT2NUM(get_gdkevent(self)->type);
}

static VALUE
gdkeventexpose_area(self)
{
  return make_gdkrectangle( &(((GdkEventExpose*)get_gdkevent(self))->area) );
}

static VALUE
gdkeventbutton_x(self)
{
  return INT2NUM(((GdkEventButton*)get_gdkevent(self))->x);
}

static VALUE
gdkeventbutton_y(self)
{
  return INT2NUM(((GdkEventButton*)get_gdkevent(self))->y);
}

static VALUE
gdkeventbutton_button(self)
{
  return INT2NUM(((GdkEventButton*)get_gdkevent(self))->button);
}

static VALUE
gdkeventmotion_window(self)
{
  return make_gdkwindow( ((GdkEventMotion*)get_gdkevent(self))->window);
}

static VALUE
gdkeventmotion_x(self)
{
  return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->x);
}

static VALUE
gdkeventmotion_y(self)
{
  return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->y);
}

static VALUE
gdkeventmotion_state(self)
{
  return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->state);
}

static VALUE
gdkeventmotion_is_hint(self)
{
  return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->is_hint);
}


a5978 1
    gStatusBar = rb_define_class_under(mGtk, "Statusbar", gHBox);
d6046 1
a6046 1
    gdkColorContext = rb_define_class_under(mGdk, "ColorContext", cData);
a6048 23
    gdkEventType = rb_define_class_under(mGdk, "gdkEventType", gdkEvent);
    gdkEventAny = rb_define_class_under(mGdk, "gdkEventAny", gdkEvent);
    gdkEventExpose = rb_define_class_under(mGdk, "gdkEventExpose", gdkEvent);
    gdkEventNoExpose = rb_define_class_under(mGdk, "gdkEventNoExpose", gdkEvent);
    gdkEventVisibility = rb_define_class_under(mGdk, "gdkEventVisibility", gdkEvent);
    gdkEventMotion = rb_define_class_under(mGdk, "gdkEventMotion", gdkEvent);
    gdkEventButton = rb_define_class_under(mGdk, "gdkEventButton", gdkEvent);
    gdkEventKey = rb_define_class_under(mGdk, "gdkEventKey", gdkEvent);
    gdkEventCrossing = rb_define_class_under(mGdk, "gdkEventCrossing", gdkEvent);
    gdkEventFocus = rb_define_class_under(mGdk, "gdkEventFocus", gdkEvent);
    gdkEventConfigure = rb_define_class_under(mGdk, "gdkEventConfigure", gdkEvent);
    gdkEventProperty = rb_define_class_under(mGdk, "gdkEventProperty", gdkEvent);
    gdkEventSelection = rb_define_class_under(mGdk, "gdkEventSelection", gdkEvent);
    gdkEventProximity = rb_define_class_under(mGdk, "gdkEventProximity", gdkEvent);
    gdkEventDragBegin = rb_define_class_under(mGdk, "gdkEventDragBegin", gdkEvent);
    gdkEventDragRequest = rb_define_class_under(mGdk, "gdkEventDragRequest", gdkEvent);
    gdkEventDropEnter = rb_define_class_under(mGdk, "gdkEventDropEnter", gdkEvent);
    gdkEventDropLeave = rb_define_class_under(mGdk, "gdkEventDropLeave", gdkEvent);
    gdkEventDropDataAvailable = rb_define_class_under(mGdk, "gdkEventDropDataAvailable", gdkEvent);
    gdkEventClient = rb_define_class_under(mGdk, "gdkEventClient", gdkEvent);
    gdkEventOther = rb_define_class_under(mGdk, "gdkEventOther", gdkEvent);


a6098 2
    rb_define_method(gWidget, "allocation", widget_get_alloc, 0);
    rb_define_method(gWidget, "state", widget_state, 0);
a6276 3
    rb_define_method(gWindow, "grab_add", gwin_grab_add, 0);
    rb_define_method(gWindow, "grab_remove", gwin_grab_remove, 0);
    rb_define_method(gWindow, "shape_combine_mask", gwin_shape_combine_mask, 3);
a6370 7
    /* Statusbar */
    rb_define_method(gStatusBar, "initialize", statusbar_initialize, 0);
    rb_define_method(gStatusBar, "push", statusbar_push, 2);
    rb_define_method(gStatusBar, "pop", statusbar_pop, 1);
    rb_define_method(gStatusBar, "get_context_id", statusbar_get_context_id, 1);
    rb_define_method(gStatusBar, "remove", statusbar_remove, 2);

a6464 2
    rb_define_method(gLabel, "get", label_get, 0);
    rb_define_method(gLabel, "set", label_set, 1);
a6691 5
    rb_define_method(gAllocation, "x", gallocation_x, 0);
    rb_define_method(gAllocation, "y", gallocation_y, 0);
    rb_define_method(gAllocation, "width", gallocation_w, 0);
    rb_define_method(gAllocation, "height", gallocation_h, 0);

a6748 5
    rb_define_method(gdkWindow, "get_pointer", gdkwin_get_pointer, 0);
    rb_define_method(gdkWindow, "pointer_grab", gdkwin_pointer_grab, 5);
    rb_define_method(gdkWindow, "pointer_ungrab", gdkwin_pointer_ungrab, 1);
    rb_define_singleton_method(gdkWindow, "foreign_new", gdkwin_foreign_new, 1);
    rb_define_singleton_method(gdkWindow, "root_window", gdkwin_root_window, 0);
a6762 25
    /* GdkRectangle */
    rb_define_singleton_method(gdkRectangle, "new", gdkrect_s_new, 4);
    rb_define_method(gdkRectangle, "x", gdkrect_x, 0);
    rb_define_method(gdkRectangle, "y", gdkrect_y, 0);
    rb_define_method(gdkRectangle, "width", gdkrect_w, 0);
    rb_define_method(gdkRectangle, "height", gdkrect_h, 0);

    /* GdkEvent */
    rb_define_method(gdkEvent, "type", gdkevent_type, 0);

    /* GdkEventExpose */
    rb_define_method(gdkEventExpose, "area", gdkeventexpose_area, 0);

    /* GdkEventButton */
    rb_define_method(gdkEventButton, "x", gdkeventbutton_x, 0);
    rb_define_method(gdkEventButton, "y", gdkeventbutton_y, 0);
    rb_define_method(gdkEventButton, "button", gdkeventbutton_button, 0);

    /* GdkEventMotion */
    rb_define_method(gdkEventMotion, "window", gdkeventmotion_window, 0);
    rb_define_method(gdkEventMotion, "x", gdkeventmotion_x, 0);
    rb_define_method(gdkEventMotion, "y", gdkeventmotion_y, 0);
    rb_define_method(gdkEventMotion, "state", gdkeventmotion_state, 0);
    rb_define_method(gdkEventMotion, "is_hint", gdkeventmotion_is_hint, 0);

a6778 2
    rb_define_const(mGtk, "WINDOW_POPUP", INT2FIX(GTK_WINDOW_POPUP));

a6869 39

    /* GdkEventMask */
    rb_define_const(mGdk, "EXPOSURE_MASK", INT2FIX(GDK_EXPOSURE_MASK));
    rb_define_const(mGdk, "POINTER_MOTION_MASK", INT2FIX(GDK_POINTER_MOTION_MASK));
    rb_define_const(mGdk, "POINTER_MOTION_HINT_MASK", INT2FIX(GDK_POINTER_MOTION_HINT_MASK));
    rb_define_const(mGdk, "BUTTON_MOTION_MASK", INT2FIX(GDK_BUTTON_MOTION_MASK));
    rb_define_const(mGdk, "BUTTON1_MOTION_MASK", INT2FIX(GDK_BUTTON1_MOTION_MASK));
    rb_define_const(mGdk, "BUTTON2_MOTION_MASK", INT2FIX(GDK_BUTTON2_MOTION_MASK));
    rb_define_const(mGdk, "BUTTON3_MOTION_MASK", INT2FIX(GDK_BUTTON3_MOTION_MASK));
    rb_define_const(mGdk, "BUTTON_PRESS_MASK", INT2FIX(GDK_BUTTON_PRESS_MASK));
    rb_define_const(mGdk, "BUTTON_RELEASE_MASK", INT2FIX(GDK_BUTTON_RELEASE_MASK));
    rb_define_const(mGdk, "KEY_PRESS_MASK", INT2FIX(GDK_KEY_PRESS_MASK));
    rb_define_const(mGdk, "KEY_RELEASE_MASK", INT2FIX(GDK_KEY_RELEASE_MASK));
    rb_define_const(mGdk, "ENTER_NOTIFY_MASK", INT2FIX(GDK_ENTER_NOTIFY_MASK));
    rb_define_const(mGdk, "LEAVE_NOTIFY_MASK", INT2FIX(GDK_LEAVE_NOTIFY_MASK));
    rb_define_const(mGdk, "FOCUS_CHANGE_MASK", INT2FIX(GDK_FOCUS_CHANGE_MASK));
    rb_define_const(mGdk, "STRUCTURE_MASK", INT2FIX(GDK_STRUCTURE_MASK));
    rb_define_const(mGdk, "PROPERTY_CHANGE_MASK", INT2FIX(GDK_PROPERTY_CHANGE_MASK));
    rb_define_const(mGdk, "VISIBILITY_NOTIFY_MASK", INT2FIX(GDK_VISIBILITY_NOTIFY_MASK));
    rb_define_const(mGdk, "PROXIMITY_IN_MASK", INT2FIX(GDK_PROXIMITY_IN_MASK));
    rb_define_const(mGdk, "PROXIMITY_OUT_MASK", INT2FIX(GDK_PROXIMITY_OUT_MASK));
    rb_define_const(mGdk, "ALL_EVENTS_MASK", INT2FIX(GDK_ALL_EVENTS_MASK));


    /* GdkModifierType */
    rb_define_const(mGdk, "SHIFT_MASK", INT2FIX(GDK_SHIFT_MASK));
    rb_define_const(mGdk, "LOCK_MASK", INT2FIX(GDK_LOCK_MASK));
    rb_define_const(mGdk, "CONTROL_MASK", INT2FIX(GDK_CONTROL_MASK));
    rb_define_const(mGdk, "MOD1_MASK", INT2FIX(GDK_MOD1_MASK));
    rb_define_const(mGdk, "MOD2_MASK", INT2FIX(GDK_MOD2_MASK));
    rb_define_const(mGdk, "MOD3_MASK", INT2FIX(GDK_MOD3_MASK));
    rb_define_const(mGdk, "MOD4_MASK", INT2FIX(GDK_MOD4_MASK));
    rb_define_const(mGdk, "MOD5_MASK", INT2FIX(GDK_MOD5_MASK));
    rb_define_const(mGdk, "BUTTON1_MASK", INT2FIX(GDK_BUTTON1_MASK));
    rb_define_const(mGdk, "BUTTON2_MASK", INT2FIX(GDK_BUTTON2_MASK));
    rb_define_const(mGdk, "BUTTON3_MASK", INT2FIX(GDK_BUTTON3_MASK));
    rb_define_const(mGdk, "BUTTON4_MASK", INT2FIX(GDK_BUTTON4_MASK));
    rb_define_const(mGdk, "BUTTON5_MASK", INT2FIX(GDK_BUTTON5_MASK));

@


1.1.1.1.2.26
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/08/10 05:55:34 $
d103 1
a103 1
static VALUE gRequisition;
a383 55
gdkfnt_load_font(self, name)
    VALUE self, name;
{
    GdkFont *font;

    font = gdk_font_load(STR2CSTR(name));
    return Data_Wrap_Struct(gdkFont, 0, gdk_font_unref, font);
	/*    return make_gdkfont(new); */ 
}

static VALUE
gdkfnt_load_fontset(self, name)
    VALUE self, name;
{
    GdkFont *new;

    new = gdk_fontset_load(STR2CSTR(name));
    return make_gdkfont(new);
}

static VALUE
gdkfnt_new(self, name)
    VALUE self, name;
{
  char *cname = STR2CSTR(name);
  return (strchr(cname, ',') == NULL)
	? gdkfnt_load_font(self, name)
	: gdkfnt_load_fontset(self, name);
}

static VALUE
gdkfnt_string_width(self, str)
    VALUE self, str;
{
  int w;

  w = gdk_string_width(get_gdkfont(self), STR2CSTR(str));
  return INT2NUM(w);
}

static VALUE
gdkfnt_ascent(self)
    VALUE self;
{
  return INT2NUM(get_gdkfont(self)->ascent);
}

static VALUE
gdkfnt_descent(self)
    VALUE self;
{
  return INT2NUM(get_gdkfont(self)->descent);
}

static VALUE
d439 2
a440 2
#define make_grequisition(c) make_tobj(c, gRequisition, sizeof(GtkRequisition))
#define get_grequisition(c) ((GtkRequisition*)get_tobj(c, gRequisition))
a778 71
static VALUE
gdkwin_clear(self)
     VALUE self;
{
  gdk_window_clear(get_gdkwindow(self));
  return self;
}

static VALUE
gdkwin_clear_area(self, x,y,w,h)
     VALUE self,x,y,w,h;
{
  gdk_window_clear_area(get_gdkwindow(self),
						NUM2INT(x), NUM2INT(y), NUM2INT(w), NUM2INT(h));
  return self;
}

static VALUE
gdkwin_clear_area_e(self, x,y,w,h)
     VALUE self,x,y,w,h;
{
  gdk_window_clear_area_e(get_gdkwindow(self),
						  NUM2INT(x), NUM2INT(y), NUM2INT(w), NUM2INT(h));
  return self;
}

static VALUE
gdkwin_set_background(self, c)
    VALUE self, c;
{
  GdkColor color;
  color.pixel = NUM2INT(c);
  gdk_window_set_background(get_gdkwindow(self), &color);
  return self;
}

static VALUE
gdkwin_set_back_pixmap(self, pixmap, parent_relative)
    VALUE self, pixmap, parent_relative;
{
  gdk_window_set_back_pixmap(get_gdkwindow(self), get_gdkpixmap(pixmap),
							 NUM2INT(parent_relative));
  return self;
}

static VALUE
gdkwin_move(self, x,y)
    VALUE self, x,y;
{
  gdk_window_move(get_gdkwindow(self),
				  NUM2INT(x), NUM2INT(y));
  return self;
}

static VALUE
gdkwin_resize(self, w,h)
    VALUE self, w,h;
{
  gdk_window_resize(get_gdkwindow(self),
					NUM2INT(w), NUM2INT(h));
  return self;
}

static VALUE
gdkwin_move_resize(self, x,y,w,h)
    VALUE self, x,y,w,h;
{
  gdk_window_move_resize(get_gdkwindow(self),
						 NUM2INT(x), NUM2INT(y), NUM2INT(w), NUM2INT(h));
  return self;
}
a870 66
gdkgc_set_function(self, func)
    VALUE func;
{
  GdkFunction f;
  f = (GdkFunction) NUM2INT(func);
  if (f != GDK_COPY && f != GDK_INVERT && f != GDK_XOR)
	ArgError("function out of range");
  
  gdk_gc_set_function(get_gdkgc(self), f);
  return func;
}

static VALUE
gdkgc_set_foreground(self, pix)
    VALUE pix;
{
  GdkColor c;
  c.pixel = NUM2INT(pix);
  gdk_gc_set_foreground(get_gdkgc(self), &c);
  return pix;
}

static VALUE
gdkgc_set_background(self, pix)
    VALUE pix;
{
  GdkColor c;
  c.pixel = NUM2INT(pix);
  gdk_gc_set_background(get_gdkgc(self), &c);
  return pix;
}

static VALUE
gdkgc_set_clip_mask(self, mask)
    VALUE mask;
{
  gdk_gc_set_clip_mask(get_gdkgc(self), get_gdkbitmap(mask));
  return mask;
}

static VALUE
gdkgc_set_clip_origin(self, x, y)
    VALUE x, y;
{
  gdk_gc_set_clip_origin(get_gdkgc(self), NUM2INT(x), NUM2INT(y));
  return self;
}

static VALUE
gdkgc_set_clip_rectangle(self, rectangle)
	 VALUE rectangle;
{
  gdk_gc_set_clip_rectangle(get_gdkgc(self), get_gdkrectangle(rectangle));
  return rectangle;
}
/*
static VALUE
gdkgc_set_clip_region(self, region)
	 VALUE region;
{
  gdk_gc_set_clip_region(get_gdkgc(self), get_gdkregion(region));
  return region;
}
*/

static VALUE
a1040 1
    GtkArg *params1;
d1050 1
a1050 1
	    ary_push(args, make_grequisition(GTK_VALUE_POINTER(params[0])));
d1058 1
a1058 1
    if (obj_is_kind_of(obj, gWindow)) {
d1060 4
a1063 4
	    ary_push(args, INT2NUM(*GTK_RETLOC_INT(params[0])));
	    ary_push(args, INT2NUM(*GTK_RETLOC_INT(params[1])));	
	    ary_push(args, INT2NUM(GTK_VALUE_INT(params[3])));
	    ary_push(args, INT2NUM(GTK_VALUE_INT(params[4])));
d1071 1
a1071 1
    if (obj_is_kind_of(obj, gEntry)) {
d1073 1
a1073 1
	    ary_push(args, INT2NUM(*GTK_RETLOC_INT(params[0])));
d1077 11
a1087 7
    if (obj_is_kind_of(obj, gCList)) {
	if (strcmp(signame, "select_row") == 0 ||
	    strcmp(signame, "unselect_row") == 0) {
	    ary_push(args, INT2NUM(GTK_VALUE_INT(params[0])));
	    ary_push(args, INT2NUM(GTK_VALUE_INT(params[1])));
	    if (GTK_VALUE_POINTER(params[2]))
		ary_push(args, make_gdkevent(GTK_VALUE_POINTER(params[2])));
a1093 1
    params1 = params;
d1095 2
a1096 22
	ary_push(args, arg_to_value(params1));
	params1++;
    }
}

static void
signal_sync_args(obj, sig, argc, params, args)
    VALUE obj;
    ID sig;
    int argc;
    GtkArg *params;
    VALUE args;
{
    int i;
    char *signame = rb_id2name(sig);

    if (obj_is_kind_of(obj, gWidget)) {
	if (strcmp(signame, "size_request") == 0) {
	    memcpy(GTK_VALUE_POINTER(params[0]), get_grequisition(ary_pop(args)),
			   sizeof(GtkRequisition));
	    return;
	}
a1222 1
	ary_shift(args);
a1224 5

    for (i=0; i<RARRAY(a)->len; i++) {
	ary_pop(args);
    }
    signal_sync_args(self, id, nparams, params, args);
a1386 6
static VALUE
cont_get_bwidth(self)
    VALUE self;
{
    return INT2NUM(GTK_CONTAINER(get_widget(self))->border_width);
}
a1539 28
misc_get_xalign(self)
    VALUE self;
{
    return float_new(GTK_MISC(get_widget(self))->xalign);
}

static VALUE
misc_get_yalign(self)
    VALUE self;
{
    return float_new(GTK_MISC(get_widget(self))->yalign);
}

static VALUE
misc_get_xpad(self)
    VALUE self;
{
    return INT2NUM(GTK_MISC(get_widget(self))->xpad);
}

static VALUE
misc_get_ypad(self)
    VALUE self;
{
    return INT2NUM(GTK_MISC(get_widget(self))->ypad);
}

static VALUE
d1745 1
a1745 1
    gtk_widget_size_request(get_widget(self), get_grequisition(req));
a1818 17
static VALUE
widget_mapped(self)
    VALUE self;
{
    if (GTK_WIDGET_MAPPED(get_widget(self)))
	return TRUE;
    return FALSE;
}

static VALUE
widget_realized(self)
    VALUE self;
{
    if (GTK_WIDGET_REALIZED(get_widget(self)))
	return TRUE;
    return FALSE;
}
a2058 1
    GdkVisual v;
d2065 1
a2065 1
    VALUE self;
d2072 2
a2073 2
widget_pop_cmap(self)
    VALUE self;
d2080 2
a2081 2
widget_pop_visual(self)
    VALUE self;
d2088 2
a2089 2
widget_pop_style(self)
    VALUE self;
a2094 32
/*
static VALUE
widget_peek_cmap(self)
    VALUE self;
{
    GdkColormap *cmap;

	cmap = (GdkColormap*)gtk_widget_peek_colormap();
    return make_gdkcmap(cmap);
}

static VALUE
widget_peek_visual(self)
    VALUE self;
{
    GdkVisual *v;

	v = (GdkVisual*)gtk_widget_peek_visual();
    return make_gdkvisual(v);
}

static VALUE
widget_peek_style(self)
    VALUE self;
{
    GtkStyle *style;

	style = (GtkStyle*)gtk_widget_peek_style();
    return make_gstyle(style);
}
*/

a2169 28
static VALUE
widget_set_alloc(self, x,y,w,h)
  VALUE self, x,y,w,h;
{
  GtkAllocation *a = &(get_widget(self)->allocation);
  a->x      = NUM2INT(x);
  a->y      = NUM2INT(y);
  a->width  = NUM2INT(w);
  a->height = NUM2INT(h);
  return self;
}

static VALUE
widget_get_requisition(self)
	VALUE self;
{
	return make_grequisition(&(get_widget(self)->requisition));
}

static VALUE
widget_set_requisition(self, w,h)
	VALUE self,w,h;
{
  GtkRequisition *r = &(get_widget(self)->requisition);
  r->width  = NUM2INT(w);
  r->height = NUM2INT(h);
  return self;
}
a2820 15
static VALUE
label_get_jtype(self)
    VALUE self;
{
  return(INT2FIX(GTK_LABEL(get_widget(self))->jtype));
}
static VALUE
label_set_jtype(self, jtype)
    VALUE self, jtype;
{
  GtkJustification j;
  j = (GtkJustification) NUM2INT(jtype);
  gtk_label_set_justify(GTK_LABEL(get_widget(self)), j);
  return self;
}
d2826 3
a2828 3
  gchar* str;
  gtk_label_get(GTK_LABEL(get_widget(self)), &str);
  return str_new2(str);
a5494 7
style_copy(self)
    VALUE self;
{
  return make_gstyle(gtk_style_copy(get_gstyle(self)));
}

static VALUE
d5509 1
a5509 1
style_set_background(self, win, state_type)
a5586 27
#define DEFINE_STYLE_SET_COLOR(func, type) \
static VALUE \
func(self, idx, r, g, b) \
    VALUE self, idx, r, g, b; \
{ \
  GtkStyle *style; \
  GdkColor *color; \
  int i = NUM2INT(idx); \
 \
  if (i < 0 || 5 < i) ArgError("state out of range"); \
  style = get_gstyle(self); \
  if (style->fg_gc[0] != NULL) ArgError("you must not change widget style."); \
  color =  &(style-> type [i]); \
  color->red   = NUM2INT(r); \
  color->green = NUM2INT(g); \
  color->blue  = NUM2INT(b); \
  return(make_gdkcolor(*color)); \
} \

DEFINE_STYLE_SET_COLOR(style_set_fg, fg)
DEFINE_STYLE_SET_COLOR(style_set_bg, bg)
DEFINE_STYLE_SET_COLOR(style_set_light, light)
DEFINE_STYLE_SET_COLOR(style_set_dark, dark)
DEFINE_STYLE_SET_COLOR(style_set_mid, mid)
DEFINE_STYLE_SET_COLOR(style_set_text, text)
DEFINE_STYLE_SET_COLOR(style_set_base, base)

a5605 17
style_set_font(self, f)
	 VALUE f;
{
  GdkFont *font = get_gdkfont(f);
  GtkStyle *style = get_gstyle(self);

  if (style->fg_gc[0] != NULL) ArgError("you must not change widget style.");
  if (style->font != NULL)
	gdk_font_unref(style->font);

  gdk_font_ref(font);
  style->font = font;

  return self;
}

static VALUE
a5784 12
gallocation_new(VALUE self, VALUE x, VALUE y, VALUE w, VALUE h)
{
  GtkAllocation a;

  a.x = NUM2INT(x);
  a.y = NUM2INT(y);
  a.width = NUM2INT(w);
  a.height = NUM2INT(h);
  return make_gallocation(&a);
}

static VALUE
a5807 21
static VALUE
gallocation_to_a(self)
	 VALUE self;
{
  GtkAllocation *a;

  a = get_gallocation(self);
  return ary_new3(4, a->x, a->y, a->width, a->height);
}

static VALUE
gallocation_to_s(self)
	 VALUE self;
{
  char str[2 +2*3 +5*4  +1]; /* member is guint16. max string size is 5 */
  GtkAllocation *a;

  a = get_gallocation(self);
  sprintf(str, "(%5d, %5d, %5d, %5d)", a->x, a->y, a->width, a->height);
  return str_new2(str);
}
d6014 2
a6015 1
		      segments, RARRAY(segs)->len);
a6018 61
static VALUE grequisition_new(self, w, h)
    VALUE self, w, h;
{
  GtkRequisition r;

  r.width = NUM2INT(w);
  r.height = NUM2INT(h);
  return make_grequisition(&r);
}

static VALUE
grequisition_w(self)
    VALUE self;
{
	return INT2NUM(get_grequisition(self)->width);
}

static VALUE
grequisition_h(self)
    VALUE self;
{
	return INT2NUM(get_grequisition(self)->height);
}

static VALUE
grequisition_set_w(self, w)
	 VALUE self, w;
{
  get_grequisition(self)->width = NUM2INT(w);
  return self;
}

static VALUE
grequisition_set_h(self, h)
	 VALUE self, h;
{
  get_grequisition(self)->height = NUM2INT(h);
  return self;
}

static VALUE
grequisition_to_a(self)
	 VALUE self;
{
  GtkRequisition *r;

  r = get_grequisition(self);
  return ary_new3(2, r->width, r->height);
}

static VALUE
grequisition_to_s(self)
	 VALUE self;
{
  char str[2 +2*1 +5*2  +1]; /* member is guint16. max string size is 5 */
  GtkRequisition *r;

  r = get_grequisition(self);
  sprintf(str, "(%5d, %5d)", r->width, r->height);
  return str_new2(str);
}
d6024 6
a6029 6
    GdkRectangle new;
    new.x = NUM2INT(x);
    new.y = NUM2INT(y);
    new.width = NUM2INT(width);
    new.height = NUM2INT(height);
    return make_gdkrectangle(&new);
d6035 1
a6035 1
    return INT2NUM(get_gdkrectangle(self)->x);
d6041 1
a6041 1
    return INT2NUM(get_gdkrectangle(self)->y);
d6047 1
a6047 1
    return INT2NUM(get_gdkrectangle(self)->width);
d6053 1
a6053 1
    return INT2NUM(get_gdkrectangle(self)->height);
d6059 1
a6059 1
    return INT2NUM(get_gdkevent(self)->type);
d6065 1
a6065 1
    return make_gdkrectangle(&(((GdkEventExpose*)get_gdkevent(self))->area));
d6071 1
a6071 1
    return INT2NUM(((GdkEventButton*)get_gdkevent(self))->x);
d6077 1
a6077 1
    return INT2NUM(((GdkEventButton*)get_gdkevent(self))->y);
d6083 1
a6083 1
    return INT2NUM(((GdkEventButton*)get_gdkevent(self))->button);
d6089 1
a6089 1
    return make_gdkwindow(((GdkEventMotion*)get_gdkevent(self))->window);
d6095 1
a6095 1
    return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->x);
d6101 1
a6101 1
    return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->y);
d6107 1
a6107 1
    return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->state);
d6113 1
a6113 1
    return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->is_hint);
d6116 1
d6343 1
a6343 1
    gRequisition = rb_define_class_under(mGtk, "Requisition", cData);
a6426 1
    rb_define_method(gWidget, "mapped?", widget_mapped, 0);
a6441 3
    rb_define_method(gWidget, "set_allocation", widget_set_alloc, 4);
    rb_define_method(gWidget, "requisition", widget_get_requisition, 0);
    rb_define_method(gWidget, "set_requisition", widget_set_requisition, 2);
a6462 5
	/* below peek_* function is defined in *.c but not decralated in gtk/*.h
    rb_define_singleton_method(gWidget, "peek_colomap", widget_pop_cmap, 0);
    rb_define_singleton_method(gWidget, "peek_visual", widget_pop_visual, 0);
    rb_define_singleton_method(gWidget, "peek_style", widget_pop_style, 0);
	*/
a6490 1
    rb_define_method(gContainer, "get_border_width", cont_get_bwidth, 0);
a6511 4
    rb_define_method(gMisc, "xalign", misc_get_xalign, 0);
    rb_define_method(gMisc, "yalign", misc_get_yalign, 0);
    rb_define_method(gMisc, "xpad", misc_get_xpad, 0);
    rb_define_method(gMisc, "ypad", misc_get_ypad, 0);
a6550 1
    rb_define_method(gTButton, "active?", tbtn_active, 0);
a6819 2
    rb_define_method(gLabel, "jtype", label_get_jtype, 0);
    rb_define_method(gLabel, "jtype=", label_set_jtype, 1);
a6820 2
    rb_define_method(gLabel, "jtype", label_get_jtype, 0);
    rb_define_method(gLabel, "jtype=", label_set_jtype, 1);
a7013 3
    rb_define_method(gStyle, "copy", style_copy, 0);
    rb_define_method(gStyle, "clone", style_copy, 0);
    rb_define_method(gStyle, "dup", style_copy, 0);
d7016 1
a7016 1
    rb_define_method(gStyle, "set_background", style_set_background, 2);
a7023 8
    rb_define_method(gStyle, "set_fg", style_set_fg, 4);
    rb_define_method(gStyle, "set_bg", style_set_bg, 4);
    rb_define_method(gStyle, "set_light", style_set_light, 4);
    rb_define_method(gStyle, "set_dark", style_set_dark, 4);
    rb_define_method(gStyle, "set_mid", style_set_mid, 4);
    rb_define_method(gStyle, "set_text", style_set_text, 4);
    rb_define_method(gStyle, "set_base", style_set_base, 4);

a7026 1
    rb_define_method(gStyle, "set_font", style_set_font, 1);
a7047 1
    rb_define_singleton_method(gAllocation, "new", gallocation_new, 4);
a7051 17
    rb_define_method(gAllocation, "to_a", gallocation_to_a, 0);
    rb_define_method(gAllocation, "to_s", gallocation_to_s, 0);

    rb_define_singleton_method(gRequisition, "new", grequisition_new, 2);
    rb_define_method(gRequisition, "width", grequisition_w, 0);
    rb_define_method(gRequisition, "height", grequisition_h, 0);
    rb_define_method(gRequisition, "width=", grequisition_set_w, 1);
    rb_define_method(gRequisition, "height=", grequisition_set_h, 1);
    rb_define_method(gRequisition, "to_a", grequisition_to_a, 0);
    rb_define_method(gRequisition, "to_s", grequisition_to_s, 0);

    rb_define_method(gRequisition, "width", grequisition_w, 0);
    rb_define_method(gRequisition, "height", grequisition_h, 0);
	/*
    rb_define_method(gRequisition, "width=", grequisition_set_w, 1);
    rb_define_method(gRequisition, "height=", grequisition_set_h, 1);
	*/
a7077 6
    rb_define_singleton_method(gdkFont, "load_font", gdkfnt_load_font, 1);
    rb_define_singleton_method(gdkFont, "new", gdkfnt_new, 1);
    rb_define_singleton_method(gdkFont, "load_fontset", gdkfnt_load_fontset, 1);
    rb_define_method(gdkFont, "string_width", gdkfnt_string_width, 1);
    rb_define_method(gdkFont, "ascent", gdkfnt_ascent, 0);
    rb_define_method(gdkFont, "descent", gdkfnt_descent, 0);
a7114 8
    rb_define_method(gdkWindow, "clear", gdkwin_clear, 0);
    rb_define_method(gdkWindow, "clear_area", gdkwin_clear_area, 4);
    rb_define_method(gdkWindow, "clear_area_e", gdkwin_clear, 4);
    rb_define_method(gdkWindow, "set_background", gdkwin_set_background, 1);
    rb_define_method(gdkWindow, "set_back_pixmap", gdkwin_set_back_pixmap, 2);
    rb_define_method(gdkWindow, "move", gdkwin_move, 2);
    rb_define_method(gdkWindow, "resize", gdkwin_resize, 2);
    rb_define_method(gdkWindow, "move_resize", gdkwin_move_resize, 4);
a7119 7
    rb_define_method(gdkGC, "set_function", gdkgc_set_function, 1);
    rb_define_method(gdkGC, "set_foreground", gdkgc_set_foreground, 1);
    rb_define_method(gdkGC, "set_background", gdkgc_set_background, 1);
    rb_define_method(gdkGC, "set_clip_mask", gdkgc_set_clip_mask, 1);
    rb_define_method(gdkGC, "set_clip_origin", gdkgc_set_clip_origin, 2);
    rb_define_method(gdkGC, "set_clip_rectangle", gdkgc_set_clip_rectangle, 1);
	/* rb_define_method(gdkGC, "set_clip_region", gdkgc_set_clip_region, 1); */
a7187 6
    /* GtkJustification */
    rb_define_const(mGtk, "JUSTIFY_LEFT", INT2FIX(GTK_JUSTIFY_LEFT));
    rb_define_const(mGtk, "JUSTIFY_RIGHT", INT2FIX(GTK_JUSTIFY_RIGHT));
    rb_define_const(mGtk, "JUSTIFY_CENTER", INT2FIX(GTK_JUSTIFY_CENTER));
    rb_define_const(mGtk, "JUSTIFY_FILL", INT2FIX(GTK_JUSTIFY_FILL));

a7192 1

a7204 1

a7210 1

a7214 1

a7217 1

a7220 1

a7250 5
    /* GdkMiscMode */
    rb_define_const(mGdk, "FUNCTION_COPY", INT2FIX(GDK_COPY));
    rb_define_const(mGdk, "FUNCTION_INVERT", INT2FIX(GDK_INVERT));
    rb_define_const(mGdk, "FUNCTION_XOR", INT2FIX(GDK_XOR));

d7339 1
a7339 1
	RARRAY(rb_argv)->ptr[i-1] = str_taint(str_new2(argv[i]));
@


1.1.1.1.2.27
log
@gtk-0.13
@
text
@d391 1
d398 1
a398 1
    GdkFont *font;
d400 12
a411 2
    font = gdk_fontset_load(STR2CSTR(name));
    return Data_Wrap_Struct(gdkFont, 0, gdk_font_unref, font);
a1533 8
gobj_get_flags(self)
    VALUE self;
{
  /* _GtkObject.flags is int32 */
    return(INT2FIX( GTK_OBJECT_FLAGS(get_gobject(self)) ));
}

static VALUE
d1565 1
a1565 1
	i = gtk_signal_connect_interp(get_gobject(self),
a1618 8
cont_remove(self, other)
    VALUE self, other;
{
	gtk_container_remove(GTK_CONTAINER(get_widget(self)), get_widget(other));
    return self;
}

static VALUE
a1879 16
adj_set_value(self, value)
    VALUE self, value;
{
    gtk_adjustment_set_value(GTK_ADJUSTMENT(get_gobject(self)),
					NUM2DBL(value));
    return Qnil;
}

static VALUE
adj_get_value(self)
    VALUE self;
{
    return float_new(GTK_ADJUSTMENT(get_gobject(self))->value);
}

static VALUE
d2062 26
a2394 24
#define DEFINE_IS_WIDGET(STATE) \
static VALUE \
widget_ ## STATE (self) \
    VALUE self; \
{ \
    return( GTK_WIDGET_ ## STATE (get_widget(self))? TRUE: FALSE ); \
}
DEFINE_IS_WIDGET(TOPLEVEL)
DEFINE_IS_WIDGET(NO_WINDOW)
DEFINE_IS_WIDGET(REALIZED)
DEFINE_IS_WIDGET(MAPPED)
DEFINE_IS_WIDGET(VISIBLE)
DEFINE_IS_WIDGET(DRAWABLE)
DEFINE_IS_WIDGET(SENSITIVE)
DEFINE_IS_WIDGET(PARENT_SENSITIVE)
DEFINE_IS_WIDGET(IS_SENSITIVE)
DEFINE_IS_WIDGET(CAN_FOCUS)
DEFINE_IS_WIDGET(HAS_FOCUS)
DEFINE_IS_WIDGET(CAN_DEFAULT)
DEFINE_IS_WIDGET(HAS_DEFAULT)
DEFINE_IS_WIDGET(HAS_GRAB)
DEFINE_IS_WIDGET(BASIC)
DEFINE_IS_WIDGET(RC_STYLE)

a2928 11
clist_get_text(self, row, col)
    VALUE self, row, col;
{
    char* text;

    gtk_clist_get_text(GTK_CLIST(get_widget(self)),
					   NUM2INT(row), NUM2INT(col), &text);
	return str_new2(text);
}

static VALUE
d5575 2
a5576 3
	if (! NIL_P(adj))
	  gtk_range_set_adjustment(GTK_RANGE(get_widget(self)),
							   GTK_ADJUSTMENT(get_gobject(adj)));
d5953 1
a5953 1
  return(make_gdkcolor(color)); \
a6878 2
    rb_define_method(gObject, "flags", gobj_get_flags, 0);
    rb_define_method(gObject, "get_flags", gobj_get_flags, 0);
d6912 2
d6946 1
d6953 1
a6953 3

	/* peek_* function is defined in gtkwidget.c but not decralated in gtk/*.h
	   so normally not using it.
a6958 17
    rb_define_method(gWidget, "toplevel?",  widget_TOPLEVEL, 0);
    rb_define_method(gWidget, "no_window?", widget_NO_WINDOW, 0);
    rb_define_method(gWidget, "realized?",  widget_REALIZED, 0);
    rb_define_method(gWidget, "mapped?",    widget_MAPPED, 0);
    rb_define_method(gWidget, "visible?",   widget_VISIBLE, 0);
    rb_define_method(gWidget, "drawable?",  widget_DRAWABLE, 0);
    rb_define_method(gWidget, "individual_sensitive?", widget_SENSITIVE, 0);
    rb_define_method(gWidget, "parent_sensitive?", widget_PARENT_SENSITIVE, 0);
    rb_define_method(gWidget, "sensitive?",   widget_IS_SENSITIVE, 0);
    rb_define_method(gWidget, "can_focus?",   widget_CAN_FOCUS, 0);
    rb_define_method(gWidget, "has_focus?",   widget_HAS_FOCUS, 0);
    rb_define_method(gWidget, "can_default?", widget_CAN_DEFAULT, 0);
    rb_define_method(gWidget, "has_default?", widget_HAS_DEFAULT, 0);
    rb_define_method(gWidget, "has_grab?",    widget_HAS_GRAB, 0);
    rb_define_method(gWidget, "basic?",       widget_BASIC, 0);
    rb_define_method(gWidget, "rc_style?",    widget_RC_STYLE, 0);

a6987 1
    rb_define_method(gContainer, "remove", cont_remove, 1);
a7031 4
    rb_define_method(gAdjustment, "set_value", adj_set_value, 1);
    rb_define_method(gAdjustment, "get_value", adj_get_value, 0);
    rb_define_method(gAdjustment, "value=", adj_set_value, 1);
    rb_define_method(gAdjustment, "value", adj_get_value, 0);
a7107 1
    rb_define_method(gCList, "get_text", clist_get_text, 2);
d7321 2
d7581 7
d7614 1
a7722 7
    /* GtkStateType */
    rb_define_const(mGtk, "STATE_NORMAL", INT2FIX(GTK_STATE_NORMAL));
    rb_define_const(mGtk, "STATE_ACTIVE", INT2FIX(GTK_STATE_ACTIVE));
    rb_define_const(mGtk, "STATE_PRELIGHT", INT2FIX(GTK_STATE_PRELIGHT));
    rb_define_const(mGtk, "STATE_SELECTED", INT2FIX(GTK_STATE_SELECTED));
    rb_define_const(mGtk, "STATE_INSENSITIVE", INT2FIX(GTK_STATE_INSENSITIVE));

d7728 4
d7740 22
d7769 6
a7774 18
    /* GtkArrowType */
    rb_define_const(mGtk, "ARROW_UP", INT2FIX(GTK_ARROW_UP));
    rb_define_const(mGtk, "ARROW_DOWN", INT2FIX(GTK_ARROW_DOWN));
    rb_define_const(mGtk, "ARROW_LEFT", INT2FIX(GTK_ARROW_LEFT));
    rb_define_const(mGtk, "ARROW_RIGHT", INT2FIX(GTK_ARROW_RIGHT));

    /* GtkPackType */
    rb_define_const(mGtk, "GTK_PACK_START", INT2FIX(GTK_PACK_START));
    rb_define_const(mGtk, "GTK_PACK_END", INT2FIX(GTK_PACK_END));

    /* GtkPolicyType */
    rb_define_const(mGtk, "POLICY_ALWAYS", INT2FIX(GTK_POLICY_ALWAYS));
    rb_define_const(mGtk, "POLICY_AUTOMATIC", INT2FIX(GTK_POLICY_AUTOMATIC));

    /* GtkUpdateType */
    rb_define_const(mGtk, "UPDATE_CONTINUOUS", INT2FIX(GTK_UPDATE_CONTINUOUS));
    rb_define_const(mGtk, "UPDATE_DISCONTINUOUS", INT2FIX(GTK_UPDATE_DISCONTINUOUS));
    rb_define_const(mGtk, "UPDATE_DELAYED", INT2FIX(GTK_UPDATE_DELAYED));
a7780 12
    /* GtkSignalRunOptions */
    rb_define_const(mGtk, "RUN_FIRST", INT2FIX(GTK_RUN_FIRST));
    rb_define_const(mGtk, "RUN_LAST", INT2FIX(GTK_RUN_LAST));
    rb_define_const(mGtk, "RUN_BOTH", INT2FIX(GTK_RUN_BOTH));
    rb_define_const(mGtk, "RUN_MASK", INT2FIX(GTK_RUN_MASK));
    rb_define_const(mGtk, "RUN_NO_RECURSE", INT2FIX(GTK_RUN_NO_RECURSE));

    /* GtkWindowPosition */
    rb_define_const(mGtk, "WIN_POS_NONE", INT2FIX(GTK_WIN_POS_NONE));
    rb_define_const(mGtk, "WIN_POS_CENTER", INT2FIX(GTK_WIN_POS_CENTER));
    rb_define_const(mGtk, "WIN_POS_MOUSE", INT2FIX(GTK_WIN_POS_MOUSE));

a7788 5
    /* GtkMenuFactoryType */
    rb_define_const(mGtk, "MENU_FACTORY_MENU", INT2FIX(GTK_MENU_FACTORY_MENU));
    rb_define_const(mGtk, "MENU_FACTORY_MENU_BAR", INT2FIX(GTK_MENU_FACTORY_MENU_BAR));
    rb_define_const(mGtk, "MENU_FACTORY_OPTION_MENU", INT2FIX(GTK_MENU_FACTORY_OPTION_MENU));

d7794 5
a7798 19
    /* GtkScrollType */
    rb_define_const(mGtk, "SCROLL_NONE", INT2FIX(GTK_SCROLL_NONE));
    rb_define_const(mGtk, "SCROLL_STEP_BACKWARD", INT2FIX(GTK_SCROLL_STEP_BACKWARD));
    rb_define_const(mGtk, "SCROLL_STEP_FORWARD", INT2FIX(GTK_SCROLL_STEP_FORWARD));
    rb_define_const(mGtk, "SCROLL_PAGE_BACKWARD", INT2FIX(GTK_SCROLL_PAGE_BACKWARD));
    rb_define_const(mGtk, "SCROLL_PAGE_FORWARD", INT2FIX(GTK_SCROLL_PAGE_FORWARD));
    rb_define_const(mGtk, "SCROLL_JUMP", INT2FIX(GTK_SCROLL_JUMP));

    /* GtkTroughType */
    rb_define_const(mGtk, "TROUGH_NONE", INT2FIX(GTK_TROUGH_NONE));
    rb_define_const(mGtk, "TROUGH_START", INT2FIX(GTK_TROUGH_START));
    rb_define_const(mGtk, "TROUGH_END", INT2FIX(GTK_TROUGH_END));
    rb_define_const(mGtk, "TROUGH_JUMP", INT2FIX(GTK_TROUGH_JUMP));

	/* GtkPositionType */
    rb_define_const(mGtk, "POS_LEFT", INT2FIX(GTK_POS_LEFT));
    rb_define_const(mGtk, "POS_RIGHT", INT2FIX(GTK_POS_RIGHT));
    rb_define_const(mGtk, "POS_TOP", INT2FIX(GTK_POS_TOP));
    rb_define_const(mGtk, "POS_BOTTOM", INT2FIX(GTK_POS_BOTTOM));
d7804 5
a7808 15
    /* GtkJustification */
    rb_define_const(mGtk, "JUSTIFY_LEFT", INT2FIX(GTK_JUSTIFY_LEFT));
    rb_define_const(mGtk, "JUSTIFY_RIGHT", INT2FIX(GTK_JUSTIFY_RIGHT));
    rb_define_const(mGtk, "JUSTIFY_CENTER", INT2FIX(GTK_JUSTIFY_CENTER));
    rb_define_const(mGtk, "JUSTIFY_FILL", INT2FIX(GTK_JUSTIFY_FILL));

    /* GtkSelectionMode */
    rb_define_const(mGtk, "SELECTION_SINGLE", INT2FIX(GTK_SELECTION_SINGLE));
    rb_define_const(mGtk, "SELECTION_BROWSE", INT2FIX(GTK_SELECTION_BROWSE));
    rb_define_const(mGtk, "SELECTION_MULTIPLE", INT2FIX(GTK_SELECTION_MULTIPLE));
    rb_define_const(mGtk, "SELECTION_EXTENDED", INT2FIX(GTK_SELECTION_EXTENDED));

    /* GtkOrientation */
    rb_define_const(mGtk, "ORIENTATION_HORIZONTAL", INT2FIX(GTK_ORIENTATION_HORIZONTAL));
    rb_define_const(mGtk, "ORIENTATION_VERTICAL", INT2FIX(GTK_ORIENTATION_VERTICAL));
d7815 3
a7817 12
    /* GtkVisibility */
    rb_define_const(mGtk, "VISIBILITY_NONE", INT2FIX(GTK_VISIBILITY_NONE));
    rb_define_const(mGtk, "VISIBILITY_PARTIAL", INT2FIX(GTK_VISIBILITY_PARTIAL));
    rb_define_const(mGtk, "VISIBILITY_FULL", INT2FIX(GTK_VISIBILITY_FULL));


	/* GtkButtonBox */
    rb_define_const(mGtk, "BUTTONBOX_DEFAULT", INT2FIX(GTK_BUTTONBOX_DEFAULT));
    rb_define_const(mGtk, "BUTTONBOX_SPREAD", INT2FIX(GTK_BUTTONBOX_SPREAD));
    rb_define_const(mGtk, "BUTTONBOX_EDGE", INT2FIX(GTK_BUTTONBOX_EDGE));
    rb_define_const(mGtk, "BUTTONBOX_START", INT2FIX(GTK_BUTTONBOX_START));
    rb_define_const(mGtk, "BUTTONBOX_END", INT2FIX(GTK_BUTTONBOX_END));
@


1.1.1.1.2.25.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/08/10 05:55:34 $
d18 1
a18 1
extern VALUE rb_cData;
d103 1
a103 1
static VALUE gRequisition;
d166 1
a166 1
	rb_raise(rb_eTypeError, "not a Gtk object");
d170 1
a170 1
	rb_raise(rb_eArgError, "destroyed GtkObject");
d173 1
a173 1
	rb_raise(rb_eTypeError, "not a GtkObject");
d209 1
a209 1
	ary = rb_ary_new();
d212 1
a212 1
    rb_ary_push(ary, relative);
d231 1
a231 1
    rb_ary_delete(gtk_object_list, obj);
d244 1
a244 1
    data = Data_Wrap_Struct(rb_cData, gobj_mark, 0, gtkobj);
d250 1
a250 1
    rb_ary_push(gtk_object_list, obj);
d258 1
a258 1
    VALUE obj = rb_obj_alloc(klass);
d297 2
a298 2
    if (!rb_obj_is_instance_of(style, gStyle)) {
	rb_raise(rb_eTypeError, "not a GtkStyle");
d324 2
a325 2
    if (!rb_obj_is_instance_of(value, gAcceleratorTable)) {
	rb_raise(rb_eTypeError, "not an AcceleratorTable");
d347 2
a348 2
    if (!rb_obj_is_instance_of(value, gPreviewInfo)) {
	rb_raise(rb_eTypeError, "not a PreviewInfo");
d375 2
a376 2
    if (!rb_obj_is_instance_of(font, gdkFont)) {
	rb_raise(rb_eTypeError, "not a GdkFont");
a383 50
gdkfnt_load_font(self, name)
    VALUE self, name;
{
    GdkFont *font;

    font = gdk_font_load(STR2CSTR(name));
    return Data_Wrap_Struct(gdkFont, 0, gdk_font_unref, font);
	/*    return make_gdkfont(new); */ 
}
static VALUE
gdkfnt_load_fontset(self, name)
    VALUE self, name;
{
    GdkFont *new;

    new = gdk_fontset_load(STR2CSTR(name));
    return make_gdkfont(new);
}
static VALUE
gdkfnt_new(self, name)
    VALUE self, name;
{
  char *cname = STR2CSTR(name);
  return (strchr(cname, ',') == NULL)
	? gdkfnt_load_font(self, name)
	: gdkfnt_load_fontset(self, name);
}
static VALUE
gdkfnt_string_width(self, str)
    VALUE self, str;
{
  int w;

  w = gdk_string_width(get_gdkfont(self), STR2CSTR(str));
  return INT2NUM(w);
}
static VALUE
gdkfnt_ascent(self)
    VALUE self;
{
  return INT2NUM(get_gdkfont(self)->ascent);
}
static VALUE
gdkfnt_descent(self)
    VALUE self;
{
  return INT2NUM(get_gdkfont(self)->descent);
}

static VALUE
d388 2
a389 2
	return Qtrue;
    return Qfalse;
d416 2
a417 2
    if (!rb_obj_is_instance_of(obj, klass)) {
	rb_raise(rb_eTypeError, "not a %s", rb_class2name(klass));
d439 2
a440 2
#define make_grequisition(c) make_tobj(c, gRequisition, sizeof(GtkRequisition))
#define get_grequisition(c) ((GtkRequisition*)get_tobj(c, gRequisition))
d461 2
a462 2
    if (!rb_obj_is_kind_of(cmap, gdkColormap)) {
	rb_raise(rb_eTypeError, "not a GdkColormap");
d485 2
a486 2
    if (!rb_obj_is_kind_of(visual, gdkVisual)) {
	rb_raise(rb_eTypeError, "not a GdkVisual");
d520 2
a521 2
    if (!rb_obj_is_kind_of(draw, klass)) {
	rb_raise(rb_eTypeError, "not a %s", kname);
d541 1
a541 1
    return rb_ary_new3(5, INT2NUM(x), INT2NUM(y),
d585 1
a585 1
	rb_raise(rb_eArgError, "Pixmap not created from %s", STR2CSTR(fname));
d587 1
a587 1
    return rb_assoc_new(make_gdkpixmap2(self,new),
d611 1
a611 1
    return rb_assoc_new(make_gdkpixmap2(self,new),
d655 2
a656 2
    if (!rb_obj_is_instance_of(image, gdkImage)) {
	rb_raise(rb_eTypeError, "not a GdkImage");
d660 1
a660 1
	rb_raise(rb_eArgError, "destroyed GdkImage");
d674 1
a674 1
	rb_raise(rb_eArgError, "data too short");
d738 1
a738 1
  return rb_ary_new3(3, INT2FIX(x), INT2FIX(y), INT2FIX((int)state));
a778 43
static VALUE
gdkwin_clear(self)
     VALUE self;
{
  gdk_window_clear(get_gdkwindow(self));
  return self;
}
static VALUE
gdkwin_clear_area(self, x,y,w,h)
     VALUE self,x,y,w,h;
{
  gdk_window_clear_area(get_gdkwindow(self),
						NUM2INT(x), NUM2INT(y), NUM2INT(w), NUM2INT(h));
  return self;
}
static VALUE
gdkwin_clear_area_e(self, x,y,w,h)
     VALUE self,x,y,w,h;
{
  gdk_window_clear_area_e(get_gdkwindow(self),
						  NUM2INT(x), NUM2INT(y), NUM2INT(w), NUM2INT(h));
  return self;
}

static VALUE
gdkwin_set_background(self, c)
    VALUE self, c;
{
  GdkColor color;
  color.pixel = NUM2INT(c);
  gdk_window_set_background(get_gdkwindow(self), &color);
  return self;
}

static VALUE
gdkwin_set_back_pixmap(self, pixmap, parent_relative)
    VALUE self, pixmap, parent_relative;
{
  gdk_window_set_back_pixmap(get_gdkwindow(self), get_gdkpixmap(pixmap),
							 NUM2INT(parent_relative));
  return self;
}

d811 2
a812 2
    if (!rb_obj_is_instance_of(event, gdkEvent)) {
	rb_raise(rb_eTypeError, "not a GdkEvent");
d835 2
a836 2
    if (!rb_obj_is_instance_of(gc, gdkGC)) {
	rb_raise(rb_eTypeError, "not a GdkGC");
d840 1
a840 1
	rb_raise(rb_eArgError, "destroyed GdkGC");
a870 62
gdkgc_set_function(self, func)
    VALUE func;
{
  GdkFunction f;
  f = (GdkFunction) NUM2INT(func);
  if (f != GDK_COPY && f != GDK_INVERT && f != GDK_XOR)
	ArgError("function out of range");
  
  gdk_gc_set_function(get_gdkgc(self), f);
  return func;
}

static VALUE
gdkgc_set_foreground(self, pix)
    VALUE pix;
{
  GdkColor c;
  c.pixel = NUM2INT(pix);
  gdk_gc_set_foreground(get_gdkgc(self), &c);
  return pix;
}
static VALUE
gdkgc_set_background(self, pix)
    VALUE pix;
{
  GdkColor c;
  c.pixel = NUM2INT(pix);
  gdk_gc_set_background(get_gdkgc(self), &c);
  return pix;
}
static VALUE
gdkgc_set_clip_mask(self, mask)
    VALUE mask;
{
  gdk_gc_set_clip_mask(get_gdkgc(self), get_gdkbitmap(mask));
  return mask;
}
static VALUE
gdkgc_set_clip_origin(self, x, y)
    VALUE x, y;
{
  gdk_gc_set_clip_origin(get_gdkgc(self), NUM2INT(x), NUM2INT(y));
  return self;
}
static VALUE
gdkgc_set_clip_rectangle(self, rectangle)
	 VALUE rectangle;
{
  gdk_gc_set_clip_rectangle(get_gdkgc(self), get_gdkrectangle(rectangle));
  return rectangle;
}
/*
static VALUE
gdkgc_set_clip_region(self, region)
	 VALUE region;
{
  gdk_gc_set_clip_region(get_gdkgc(self), get_gdkregion(region));
  return region;
}
*/

static VALUE
d874 1
a874 1
    VALUE ary = rb_ary_new();
d877 1
a877 1
	rb_ary_push(ary, get_value_from_gobject(GTK_OBJECT(list->data)));
d919 1
a919 1
    VALUE ary = rb_ary_new();
d922 1
a922 1
	rb_ary_push(ary, get_value_from_gobject(GTK_OBJECT(list->data)));
d956 1
a956 1
	return rb_float_new(GTK_VALUE_FLOAT(*arg));
d960 1
a960 1
	return rb_str_new2(GTK_VALUE_STRING(*arg));
d1026 1
a1026 1
	rb_raise(rb_eTypeError, "unsupported arg type %s (fundamental type %s)",
d1044 1
a1044 1
    if (rb_obj_is_kind_of(obj, gWidget)) {
d1046 1
a1046 1
	    rb_ary_push(args, make_gdkrectangle(GTK_VALUE_POINTER(params[0])));
d1050 1
a1050 1
	    rb_ary_push(args, make_grequisition(GTK_VALUE_POINTER(params[0])));
d1054 1
a1054 1
	    rb_ary_push(args, make_gallocation(GTK_VALUE_POINTER(params[0])));
d1058 1
a1058 1
    if (rb_obj_is_kind_of(obj, gWindow)) {
d1060 4
a1063 4
	    rb_ary_push(args, INT2NUM(*GTK_RETLOC_INT(params[0])));
	    rb_ary_push(args, INT2NUM(*GTK_RETLOC_INT(params[1])));
	    rb_ary_push(args, INT2NUM(GTK_VALUE_INT(params[3])));
	    rb_ary_push(args, INT2NUM(GTK_VALUE_INT(params[4])));
d1067 1
a1067 1
	    rb_ary_push(args, get_value_from_gobject(GTK_VALUE_POINTER(params[0])));
d1071 1
a1071 1
    if (rb_obj_is_kind_of(obj, gEntry)) {
d1073 1
a1073 1
	    rb_ary_push(args, INT2NUM(*GTK_RETLOC_INT(params[0])));
d1077 11
a1087 7
    if (rb_obj_is_kind_of(obj, gCList)) {
	if (strcmp(signame, "select_row") == 0 ||
	    strcmp(signame, "unselect_row") == 0) {
	    rb_ary_push(args, INT2NUM(GTK_VALUE_INT(params[0])));
	    rb_ary_push(args, INT2NUM(GTK_VALUE_INT(params[1])));
	    if (GTK_VALUE_POINTER(params[2]))
		rb_ary_push(args, make_gdkevent(GTK_VALUE_POINTER(params[2])));
d1089 1
a1089 1
		rb_ary_push(args, Qnil);
d1095 1
a1095 1
	rb_ary_push(args, arg_to_value(params));
d1189 1
a1189 1
	rb_raise(rb_eTypeError, "unsupported return type %s (fundamental type %s)",
d1208 1
a1208 1
    VALUE args = rb_ary_new2(nparams+1+RARRAY(a)->len);
d1213 1
a1213 1
	rb_ary_push(args, RARRAY(a)->ptr[i]);
d1221 1
a1221 1
	rb_ary_unshift(args, self);
d1241 1
a1241 1
    rb_raise(rb_eRuntimeError, "can't instantiate class %s", rb_class2name(self));
d1252 1
a1252 1
	VALUE data = rb_ary_new3(3, Qnil, id, rb_ary_new2(0));
d1276 1
a1276 1
grb_obj_equal(self, other)
d1279 3
a1281 3
    if (self == other) return Qtrue;
    if (get_gobject(self) == try_get_gobject(other)) return Qtrue;
    return Qfalse;
d1299 1
a1299 1
    return rb_str_new2(s);
d1347 1
a1347 1
    data = rb_ary_new3(3, rb_f_lambda(), INT2NUM(id), args);
d1369 1
a1369 1
    data = rb_ary_new3(3, rb_f_lambda(), INT2NUM(id), args);
d1446 1
a1446 1
	callback = rb_f_lambda();
d1485 1
a1485 1
    rb_ary_push(ary, get_value_from_gobject(GTK_OBJECT(widget)));
d1492 1
a1492 1
    VALUE ary = rb_ary_new();
a1539 25
misc_get_xalign(self)
    VALUE self;
{
    return float_new(GTK_MISC(get_widget(self))->xalign);
}
static VALUE
misc_get_yalign(self)
    VALUE self;
{
    return float_new(GTK_MISC(get_widget(self))->yalign);
}
static VALUE
misc_get_xpad(self)
    VALUE self;
{
    return INT2NUM(GTK_MISC(get_widget(self))->xpad);
}
static VALUE
misc_get_ypad(self)
    VALUE self;
{
    return INT2NUM(GTK_MISC(get_widget(self))->ypad);
}

static VALUE
d1710 2
a1711 4
widget_draw(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
a1712 3
    VALUE rect;

    rb_scan_args(argc, argv, "01", &rect);
d1745 1
a1745 1
    gtk_widget_size_request(get_widget(self), get_grequisition(req));
d1816 2
a1817 2
	return Qtrue;
    return Qfalse;
a1826 8
static VALUE
widget_mapped(self)
    VALUE self;
{
    if (GTK_WIDGET_MAPPED(get_widget(self)))
	return TRUE;
    return FALSE;
}
d1893 1
a1893 1
    return rb_str_new2(name);
d1965 1
a1965 1
    if (rb_obj_is_kind_of(type, rb_cClass)) {
d2007 1
a2007 1
    return rb_assoc_new(INT2FIX(x), INT2FIX(y));
d2015 1
a2015 1
	return Qtrue;
d2017 1
a2017 1
    return Qfalse;
d2025 1
a2025 1
	return Qtrue;
d2027 1
a2027 1
    return Qfalse;
a2171 17
widget_get_requisition(self)
	VALUE self;
{
	return make_grequisition(&(get_widget(self)->requisition));
}

static VALUE
widget_set_requisition(self, w,h)
	VALUE self,w,h;
{
  GtkRequisition *r = &(get_widget(self)->requisition);
  r->width  = NUM2INT(w);
  r->height = NUM2INT(h);
  return self;
}

static VALUE
d2186 1
a2186 1
    return rb_assoc_new(INT2FIX(min_width), INT2FIX(max_width));
d2196 1
a2196 1
    return rb_assoc_new(INT2FIX(ipad_x), INT2FIX(ipad_y));
d2243 1
a2243 1
    return rb_assoc_new(INT2FIX(min_width), INT2FIX(max_width));
d2254 1
a2254 1
    return rb_assoc_new(INT2FIX(ipad_x), INT2FIX(ipad_y));
d2544 1
a2544 1
	rb_raise(rb_eArgError, "text too short");
d2564 1
a2564 1
	rb_raise(rb_eArgError, "text too short");
d2766 1
a2766 1
    return rb_str_new2(fname);
a2820 15
static VALUE
label_get_jtype(self)
    VALUE self;
{
  return(INT2FIX(GTK_LABEL(get_widget(self))->jtype));
}
static VALUE
label_set_jtype(self, jtype)
    VALUE self, jtype;
{
  GtkJustification j;
  j = (GtkJustification) NUM2INT(jtype);
  gtk_label_set_justify(GTK_LABEL(get_widget(self)), j);
  return self;
}
d2828 1
a2828 1
  return rb_str_new2(*str);
d3240 1
a3240 1
    return rb_str_new2(buf);
d3348 1
a3348 1
	if (rb_obj_is_kind_of(arg1, gRMenuItem)) {
d3478 1
a3478 1
    return GTK_NOTEBOOK(get_widget(self))->show_tabs?Qtrue:Qfalse;
d3493 1
a3493 1
    return GTK_NOTEBOOK(get_widget(self))->show_border?Qtrue:Qfalse;
d3565 1
a3565 1
    return rb_assoc_new(make_gdkimage(self, val),
d3609 1
a3609 1
	rb_raise(rb_eArgError, "src too short");
d3613 1
a3613 1
	rb_raise(rb_eArgError, "dst too short");
d3615 1
a3615 1
    rb_str_modify(dst);
d3634 1
a3634 1
	rb_raise(rb_eArgError, "data too short");
d3963 1
a3963 1
	func = rb_f_lambda();
d3980 1
a3980 1
	func = rb_f_lambda();
d3997 1
a3997 1
	func = rb_f_lambda();
d4392 2
a4393 2
	return Qtrue;
    return Qfalse;
d4433 1
a4433 1
	if (rb_obj_is_kind_of(arg1, gRButton)) {
d4471 1
a4471 1
    expand = fill = Qtrue; padding = 0;
d4559 1
a4559 1
	rb_raise(rb_eArgError, "color array too small");
d4577 4
a4580 4
    ary = rb_ary_new2(3);
    rb_ary_push(ary, NUM2DBL(buf[0]));
    rb_ary_push(ary, NUM2DBL(buf[1]));
    rb_ary_push(ary, NUM2DBL(buf[2]));
d4619 1
a4619 1
    return rb_assoc_new(make_gdkpixmap(val),
d4680 1
a4680 1
    return rb_str_new2(s);
d4779 1
a4779 1
    return rb_str_new2(text);
d4850 1
a4850 1
    return rb_float_new(GTK_GAMMA_CURVE(get_widget(self))->gamma);
a5494 7
style_copy(self)
    VALUE self;
{
  return make_gstyle(gtk_style_copy(get_gstyle(self)));
}

static VALUE
d5509 1
a5509 1
style_set_background(self, win, state_type)
d5523 1
a5523 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5533 1
a5533 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5543 1
a5543 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5553 1
a5553 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5563 1
a5563 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5573 1
a5573 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5583 1
a5583 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
a5586 27
#define DEFINE_STYLE_SET_COLOR(FUNC, TYPE) \
static VALUE \
FUNC(self, idx, r, g, b) \
    VALUE self, idx, r, g, b; \
{ \
  GtkStyle *style; \
  GdkColor *color; \
  int i = NUM2INT(idx); \
 \
  if (i < 0 || 5 < i) ArgError("state out of range"); \
  style = get_gstyle(self); \
  if (style->fg_gc[0] != NULL) ArgError("you must not change widget style."); \
  color =  &(style-> TYPE [i]); \
  color->red   = NUM2INT(r); \
  color->green = NUM2INT(g); \
  color->blue  = NUM2INT(b); \
  return(make_gdkcolor(*color)); \
} \

DEFINE_STYLE_SET_COLOR(style_set_fg, fg)
DEFINE_STYLE_SET_COLOR(style_set_bg, bg)
DEFINE_STYLE_SET_COLOR(style_set_light, light)
DEFINE_STYLE_SET_COLOR(style_set_dark, dark)
DEFINE_STYLE_SET_COLOR(style_set_mid, mid)
DEFINE_STYLE_SET_COLOR(style_set_text, text)
DEFINE_STYLE_SET_COLOR(style_set_base, base)

a5605 17
style_set_font(self, f)
	 VALUE f;
{
  GdkFont *font = get_gdkfont(f);
  GtkStyle *style = get_gstyle(self);

  if (style->fg_gc[0] != NULL) ArgError("you must not change widget style.");
  if (style->font != NULL)
	gdk_font_unref(style->font);

  gdk_font_ref(font);
  style->font = font;

  return self;
}

static VALUE
d5611 1
a5611 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5621 1
a5621 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5631 1
a5631 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5641 1
a5641 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5651 1
a5651 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5661 1
a5661 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5671 1
a5671 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5693 1
a5693 1
    if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range");
d5743 1
a5743 1
	    rb_raise(rb_eArgError, "point %d should be array of size 2", i);
a5807 26
static VALUE
grequisition_w(self)
{
	return INT2NUM(get_grequisition(self)->width);
}
static VALUE
grequisition_h(self)
{
	return INT2NUM(get_grequisition(self)->height);
}
/*
static VALUE
grequisition_set_w(self, w)
	 VALUE self, w;
{
  get_grequisition(self)->width = NUM2INT(w);
  return self;
}
static VALUE
grequisition_set_h(self, h)
	 VALUE self, h;
{
  get_grequisition(self)->height = NUM2INT(h);
  return self;
}
*/
d5911 1
a5911 1
	    rb_raise(rb_eArgError, "point %d should be array of size 2", i);
d5983 1
a5983 1
	    rb_raise(rb_eArgError, "point %d should be array of size 2", i);
d6006 1
a6006 1
	    rb_raise(rb_eArgError, "segment %d should be array of size 4", i);
d6122 1
a6122 1
    if (!rb_thread_critical) rb_thread_schedule();
d6124 1
a6124 1
    return Qtrue;
d6141 1
a6141 1
				(gpointer)rb_f_lambda(), 0);
d6159 1
a6159 1
    id = gtk_idle_add_interp(exec_interval, (gpointer)rb_f_lambda(), 0);
d6179 1
a6179 1
    rb_funcall(warn_handler, id_call, 1, rb_str_new2(mesg));
d6186 1
a6186 1
    rb_funcall(mesg_handler, id_call, 1, rb_str_new2(mesg));
d6193 1
a6193 1
    rb_funcall(print_handler, id_call, 1, rb_str_new2(mesg));
d6206 1
a6206 1
	handler = rb_f_lambda();
d6222 1
a6222 1
	handler = rb_f_lambda();
d6238 1
a6238 1
	handler = rb_f_lambda();
d6248 1
a6248 1
    rb_raise(rb_eRuntimeError, "%s", mesg);
d6258 1
a6258 1
    gtk_object_list = rb_ary_new();
d6263 1
a6263 1
    gObject = rb_define_class_under(mGtk, "Object", rb_cObject);
d6335 1
a6335 1
    gTooltips = rb_define_class_under(mGtk, "Tooltips", rb_cData);
d6340 5
a6344 5
    gAcceleratorTable = rb_define_class_under(mGtk, "AcceleratorTable", rb_cData);
    gStyle = rb_define_class_under(mGtk, "Style", rb_cData);
    gPreviewInfo = rb_define_class_under(mGtk, "PreviewInfo", rb_cData);
    gRequisition = rb_define_class_under(mGtk, "Requisition", rb_cData);
    gAllocation = rb_define_class_under(mGtk, "Allocation", rb_cData);
d6350 3
a6352 3
    gdkFont = rb_define_class_under(mGdk, "Font", rb_cData);
    gdkColor = rb_define_class_under(mGdk, "Color", rb_cData);
    gdkDrawable = rb_define_class_under(mGdk, "Drawable", rb_cData);
d6356 11
a6366 11
    gdkImage = rb_define_class_under(mGdk, "Image", rb_cData);
    gdkVisual = rb_define_class_under(mGdk, "Visual", rb_cData);
    gdkGC = rb_define_class_under(mGdk, "GC", rb_cData);
    gdkGCValues = rb_define_class_under(mGdk, "GCValues", rb_cData);
    gdkRectangle = rb_define_class_under(mGdk, "Rectangle", rb_cData);
    gdkSegment = rb_define_class_under(mGdk, "Segment", rb_cData);
    gdkWindowAttr = rb_define_class_under(mGdk, "WindowAttr", rb_cData);
    gdkCursor = rb_define_class_under(mGdk, "Cursor", rb_cData);
    gdkAtom = rb_define_class_under(mGdk, "Atom", rb_cData);
    gdkColorContext = rb_define_class_under(mGdk, "ColotContext", rb_cData);
    gdkEvent = rb_define_class_under(mGdk, "gdkEvent", rb_cData);
d6399 1
a6399 1
    rb_define_method(gObject, "==", grb_obj_equal, 1);
d6413 1
a6413 1
    rb_define_method(gWidget, "draw", widget_draw, -1);
a6426 1
    rb_define_method(gWidget, "mapped?", widget_mapped, 0);
a6441 2
    rb_define_method(gWidget, "requisition", widget_get_requisition, 0);
    rb_define_method(gWidget, "set_requisition", widget_set_requisition, 2);
a6511 4
    rb_define_method(gMisc, "xalign", misc_get_xalign, 0);
    rb_define_method(gMisc, "yalign", misc_get_yalign, 0);
    rb_define_method(gMisc, "xpad", misc_get_xpad, 0);
    rb_define_method(gMisc, "ypad", misc_get_ypad, 0);
a6820 2
    rb_define_method(gLabel, "jtype", label_get_jtype, 0);
    rb_define_method(gLabel, "jtype=", label_set_jtype, 1);
a7013 3
    rb_define_method(gStyle, "copy", style_copy, 0);
    rb_define_method(gStyle, "clone", style_copy, 0);
    rb_define_method(gStyle, "dup", style_copy, 0);
d7016 1
a7016 1
    rb_define_method(gStyle, "set_background", style_set_background, 1);
a7023 8
    rb_define_method(gStyle, "set_fg", style_set_fg, 4);
    rb_define_method(gStyle, "set_bg", style_set_bg, 4);
    rb_define_method(gStyle, "set_light", style_set_light, 4);
    rb_define_method(gStyle, "set_dark", style_set_dark, 4);
    rb_define_method(gStyle, "set_mid", style_set_mid, 4);
    rb_define_method(gStyle, "set_text", style_set_text, 4);
    rb_define_method(gStyle, "set_base", style_set_base, 4);

a7026 1
    rb_define_method(gStyle, "set_font", style_set_font, 1);
a7052 7
    rb_define_method(gRequisition, "width", grequisition_w, 0);
    rb_define_method(gRequisition, "height", grequisition_h, 0);
	/*
    rb_define_method(gRequisition, "width=", grequisition_set_w, 1);
    rb_define_method(gRequisition, "height=", grequisition_set_h, 1);
	*/

a7077 6
    rb_define_singleton_method(gdkFont, "load_font", gdkfnt_load_font, 1);
    rb_define_singleton_method(gdkFont, "new", gdkfnt_new, 1);
    rb_define_singleton_method(gdkFont, "load_fontset", gdkfnt_load_fontset, 1);
    rb_define_method(gdkFont, "string_width", gdkfnt_string_width, 1);
    rb_define_method(gdkFont, "ascent", gdkfnt_ascent, 0);
    rb_define_method(gdkFont, "descent", gdkfnt_descent, 0);
a7114 5
    rb_define_method(gdkWindow, "clear", gdkwin_clear, 0);
    rb_define_method(gdkWindow, "clear_area", gdkwin_clear_area, 4);
    rb_define_method(gdkWindow, "clear_area_e", gdkwin_clear, 4);
    rb_define_method(gdkWindow, "set_background", gdkwin_set_background, 1);
    rb_define_method(gdkWindow, "set_back_pixmap", gdkwin_set_back_pixmap, 2);
a7119 7
    rb_define_method(gdkGC, "set_function", gdkgc_set_function, 1);
    rb_define_method(gdkGC, "set_foreground", gdkgc_set_foreground, 1);
    rb_define_method(gdkGC, "set_background", gdkgc_set_background, 1);
    rb_define_method(gdkGC, "set_clip_mask", gdkgc_set_clip_mask, 1);
    rb_define_method(gdkGC, "set_clip_origin", gdkgc_set_clip_origin, 2);
    rb_define_method(gdkGC, "set_clip_rectangle", gdkgc_set_clip_rectangle, 1);
	/* rb_define_method(gdkGC, "set_clip_region", gdkgc_set_clip_region, 1); */
a7187 6
    /* GtkJustification */
    rb_define_const(mGtk, "JUSTIFY_LEFT", INT2FIX(GTK_JUSTIFY_LEFT));
    rb_define_const(mGtk, "JUSTIFY_RIGHT", INT2FIX(GTK_JUSTIFY_RIGHT));
    rb_define_const(mGtk, "JUSTIFY_CENTER", INT2FIX(GTK_JUSTIFY_CENTER));
    rb_define_const(mGtk, "JUSTIFY_FILL", INT2FIX(GTK_JUSTIFY_FILL));

a7250 5
    /* GdkMiscMode */
    rb_define_const(mGdk, "FUNCTION_COPY", INT2FIX(GDK_COPY));
    rb_define_const(mGdk, "FUNCTION_INVERT", INT2FIX(GDK_INVERT));
    rb_define_const(mGdk, "FUNCTION_XOR", INT2FIX(GDK_XOR));

d7339 1
a7339 1
	RARRAY(rb_argv)->ptr[i-1] = rb_str_taint(rb_str_new2(argv[i]));
@


1.1.1.1.2.25.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/10/06 02:47:50 $
d18 1
d391 1
a392 1

d397 1
a397 1
    GdkFont *font;
d399 11
a409 2
    font = gdk_fontset_load(STR2CSTR(name));
    return Data_Wrap_Struct(gdkFont, 0, gdk_font_unref, font);
a410 1

a419 1

a425 1

a835 1

a843 1

a871 26
static VALUE
gdkwin_move(self, x,y)
    VALUE self, x,y;
{
  gdk_window_move(get_gdkwindow(self),
				  NUM2INT(x), NUM2INT(y));
  return self;
}

static VALUE
gdkwin_resize(self, w,h)
    VALUE self, w,h;
{
  gdk_window_resize(get_gdkwindow(self),
					NUM2INT(w), NUM2INT(h));
  return self;
}

static VALUE
gdkwin_move_resize(self, x,y,w,h)
    VALUE self, x,y,w,h;
{
  gdk_window_move_resize(get_gdkwindow(self),
						 NUM2INT(x), NUM2INT(y), NUM2INT(w), NUM2INT(h));
  return self;
}
a984 1

a993 1

a1000 1

a1007 1

a1195 1
    GtkArg *params1;
a1244 1
    params1 = params;
d1246 2
a1247 22
	rb_ary_push(args, arg_to_value(params1));
	params1++;
    }
}

static void
signal_sync_args(obj, sig, argc, params, args)
    VALUE obj;
    ID sig;
    int argc;
    GtkArg *params;
    VALUE args;
{
    int i;
    char *signame = rb_id2name(sig);

    if (rb_obj_is_kind_of(obj, gWidget)) {
	if (strcmp(signame, "size_request") == 0) {
	    memcpy(GTK_VALUE_POINTER(params[0]), get_grequisition(rb_ary_pop(args)),
			   sizeof(GtkRequisition));
	    return;
	}
a1373 1
	rb_ary_shift(args);
a1375 5

    for (i=0; i<RARRAY(a)->len; i++) {
	rb_ary_pop(args);
    }
    signal_sync_args(self, id, nparams, params, args);
d1427 1
a1427 1
gobj_equal(self, other)
a1468 8
gobj_get_flags(self)
    VALUE self;
{
  /* _GtkObject.flags is int32 */
    return(INT2FIX( GTK_OBJECT_FLAGS(get_gobject(self)) ));
}

static VALUE
d1500 1
a1500 1
	i = gtk_signal_connect_interp(get_gobject(self),
a1537 6
static VALUE
cont_get_bwidth(self)
    VALUE self;
{
    return INT2NUM(GTK_CONTAINER(get_widget(self))->border_width);
}
a1547 8
cont_remove(self, other)
    VALUE self, other;
{
	gtk_container_remove(GTK_CONTAINER(get_widget(self)), get_widget(other));
    return self;
}

static VALUE
d1694 1
a1694 1
    return rb_float_new(GTK_MISC(get_widget(self))->xalign);
a1695 1

d1700 1
a1700 1
    return rb_float_new(GTK_MISC(get_widget(self))->yalign);
a1701 1

a1707 1

a1805 16
adj_set_value(self, value)
    VALUE self, value;
{
    gtk_adjustment_set_value(GTK_ADJUSTMENT(get_gobject(self)),
					NUM2DBL(value));
    return Qnil;
}

static VALUE
adj_get_value(self)
    VALUE self;
{
    return rb_float_new(GTK_ADJUSTMENT(get_gobject(self))->value);
}

static VALUE
d1993 9
d2008 8
a2247 1
    GdkVisual v;
d2254 1
a2254 1
    VALUE self;
d2261 2
a2262 2
widget_pop_cmap(self)
    VALUE self;
d2269 2
a2270 2
widget_pop_visual(self)
    VALUE self;
d2277 2
a2278 2
widget_pop_style(self)
    VALUE self;
a2283 56
/*
static VALUE
widget_peek_cmap(self)
    VALUE self;
{
    GdkColormap *cmap;

	cmap = (GdkColormap*)gtk_widget_peek_colormap();
    return make_gdkcmap(cmap);
}

static VALUE
widget_peek_visual(self)
    VALUE self;
{
    GdkVisual *v;

	v = (GdkVisual*)gtk_widget_peek_visual();
    return make_gdkvisual(v);
}

static VALUE
widget_peek_style(self)
    VALUE self;
{
    GtkStyle *style;

	style = (GtkStyle*)gtk_widget_peek_style();
    return make_gstyle(style);
}
*/

#define DEFINE_IS_WIDGET(STATE) \
static VALUE \
widget_ ## STATE (self) \
    VALUE self; \
{ \
    return( GTK_WIDGET_ ## STATE (get_widget(self))? Qtrue: Qfalse ); \
}
DEFINE_IS_WIDGET(TOPLEVEL)
DEFINE_IS_WIDGET(NO_WINDOW)
DEFINE_IS_WIDGET(REALIZED)
DEFINE_IS_WIDGET(MAPPED)
DEFINE_IS_WIDGET(VISIBLE)
DEFINE_IS_WIDGET(DRAWABLE)
DEFINE_IS_WIDGET(SENSITIVE)
DEFINE_IS_WIDGET(PARENT_SENSITIVE)
DEFINE_IS_WIDGET(IS_SENSITIVE)
DEFINE_IS_WIDGET(CAN_FOCUS)
DEFINE_IS_WIDGET(HAS_FOCUS)
DEFINE_IS_WIDGET(CAN_DEFAULT)
DEFINE_IS_WIDGET(HAS_DEFAULT)
DEFINE_IS_WIDGET(HAS_GRAB)
DEFINE_IS_WIDGET(BASIC)
DEFINE_IS_WIDGET(RC_STYLE)

a2358 11
static VALUE
widget_set_alloc(self, x,y,w,h)
  VALUE self, x,y,w,h;
{
  GtkAllocation *a = &(get_widget(self)->allocation);
  a->x      = NUM2INT(x);
  a->y      = NUM2INT(y);
  a->width  = NUM2INT(w);
  a->height = NUM2INT(h);
  return self;
}
a2806 11
clist_get_text(self, row, col)
    VALUE self, row, col;
{
    char* text;

    gtk_clist_get_text(GTK_CLIST(get_widget(self)),
					   NUM2INT(row), NUM2INT(col), &text);
	return rb_str_new2(text);
}

static VALUE
d3047 3
a3049 3
  gchar *str;
  gtk_label_get(GTK_LABEL(get_widget(self)), &str);
  return rb_str_new2(str);
d5453 2
a5454 3
	if (! NIL_P(adj))
	  gtk_range_set_adjustment(GTK_RANGE(get_widget(self)),
							   GTK_ADJUSTMENT(get_gobject(adj)));
d5815 1
a5815 1
#define DEFINE_STYLE_SET_COLOR(func, type) \
d5817 1
a5817 1
func(self, idx, r, g, b) \
d5824 1
a5824 1
  if (i < 0 || 5 < i) rb_raise(rb_eArgError, "state out of range"); \
d5826 2
a5827 3
  if (style->fg_gc[0] != NULL) \
      rb_raise(rb_eArgError, "you must not change widget style."); \
  color =  &(style-> type [i]); \
d5867 1
a5867 2
  if (style->fg_gc[0] != NULL)
      rb_raise(rb_eArgError, "you must not change widget style.");
a6056 12
gallocation_new(VALUE self, VALUE x, VALUE y, VALUE w, VALUE h)
{
  GtkAllocation a;

  a.x = NUM2INT(x);
  a.y = NUM2INT(y);
  a.width = NUM2INT(w);
  a.height = NUM2INT(h);
  return make_gallocation(&a);
}

static VALUE
d6081 6
a6086 2
gallocation_to_a(self)
	 VALUE self;
d6088 1
a6088 4
  GtkAllocation *a;

  a = get_gallocation(self);
  return rb_ary_new3(4, a->x, a->y, a->width, a->height);
d6090 1
a6090 1

d6092 2
a6093 2
gallocation_to_s(self)
	 VALUE self;
d6095 9
a6103 6
  char str[2 +2*3 +5*4  +1]; /* member is guint16. max string size is 5 */
  GtkAllocation *a;

  a = get_gallocation(self);
  sprintf(str, "(%5d, %5d, %5d, %5d)", a->x, a->y, a->width, a->height);
  return rb_str_new2(str);
d6105 1
d6312 2
a6313 1
		      segments, RARRAY(segs)->len);
a6316 61
static VALUE grequisition_new(self, w, h)
    VALUE self, w, h;
{
  GtkRequisition r;

  r.width = NUM2INT(w);
  r.height = NUM2INT(h);
  return make_grequisition(&r);
}

static VALUE
grequisition_w(self)
    VALUE self;
{
	return INT2NUM(get_grequisition(self)->width);
}

static VALUE
grequisition_h(self)
    VALUE self;
{
	return INT2NUM(get_grequisition(self)->height);
}

static VALUE
grequisition_set_w(self, w)
	 VALUE self, w;
{
  get_grequisition(self)->width = NUM2INT(w);
  return self;
}

static VALUE
grequisition_set_h(self, h)
	 VALUE self, h;
{
  get_grequisition(self)->height = NUM2INT(h);
  return self;
}

static VALUE
grequisition_to_a(self)
	 VALUE self;
{
  GtkRequisition *r;

  r = get_grequisition(self);
  return rb_ary_new3(2, r->width, r->height);
}

static VALUE
grequisition_to_s(self)
	 VALUE self;
{
  char str[2 +2*1 +5*2  +1]; /* member is guint16. max string size is 5 */
  GtkRequisition *r;

  r = get_grequisition(self);
  sprintf(str, "(%5d, %5d)", r->width, r->height);
  return rb_str_new2(str);
}
d6322 6
a6327 6
    GdkRectangle new;
    new.x = NUM2INT(x);
    new.y = NUM2INT(y);
    new.width = NUM2INT(width);
    new.height = NUM2INT(height);
    return make_gdkrectangle(&new);
d6333 1
a6333 1
    return INT2NUM(get_gdkrectangle(self)->x);
d6339 1
a6339 1
    return INT2NUM(get_gdkrectangle(self)->y);
d6345 1
a6345 1
    return INT2NUM(get_gdkrectangle(self)->width);
d6351 1
a6351 1
    return INT2NUM(get_gdkrectangle(self)->height);
d6357 1
a6357 1
    return INT2NUM(get_gdkevent(self)->type);
d6363 1
a6363 1
    return make_gdkrectangle(&(((GdkEventExpose*)get_gdkevent(self))->area));
d6369 1
a6369 1
    return INT2NUM(((GdkEventButton*)get_gdkevent(self))->x);
d6375 1
a6375 1
    return INT2NUM(((GdkEventButton*)get_gdkevent(self))->y);
d6381 1
a6381 1
    return INT2NUM(((GdkEventButton*)get_gdkevent(self))->button);
d6387 1
a6387 1
    return make_gdkwindow(((GdkEventMotion*)get_gdkevent(self))->window);
d6393 1
a6393 1
    return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->x);
d6399 1
a6399 1
    return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->y);
d6405 1
a6405 1
    return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->state);
d6411 1
a6411 1
    return INT2NUM(((GdkEventMotion*)get_gdkevent(self))->is_hint);
d6414 1
d6419 1
a6419 1
#ifdef USE_THREAD
a6690 2
    rb_define_method(gObject, "flags", gobj_get_flags, 0);
    rb_define_method(gObject, "get_flags", gobj_get_flags, 0);
d6697 1
a6697 1
    rb_define_method(gObject, "==", gobj_equal, 1);
d6724 2
a6740 1
    rb_define_method(gWidget, "set_allocation", widget_set_alloc, 4);
d6757 1
a6764 24
	/* peek_* function is defined in gtkwidget.c but not decralated in gtk/*.h
	   so normally not using it.
    rb_define_singleton_method(gWidget, "peek_colomap", widget_pop_cmap, 0);
    rb_define_singleton_method(gWidget, "peek_visual", widget_pop_visual, 0);
    rb_define_singleton_method(gWidget, "peek_style", widget_pop_style, 0);
	*/

    rb_define_method(gWidget, "toplevel?",  widget_TOPLEVEL, 0);
    rb_define_method(gWidget, "no_window?", widget_NO_WINDOW, 0);
    rb_define_method(gWidget, "realized?",  widget_REALIZED, 0);
    rb_define_method(gWidget, "mapped?",    widget_MAPPED, 0);
    rb_define_method(gWidget, "visible?",   widget_VISIBLE, 0);
    rb_define_method(gWidget, "drawable?",  widget_DRAWABLE, 0);
    rb_define_method(gWidget, "individual_sensitive?", widget_SENSITIVE, 0);
    rb_define_method(gWidget, "parent_sensitive?", widget_PARENT_SENSITIVE, 0);
    rb_define_method(gWidget, "sensitive?",   widget_IS_SENSITIVE, 0);
    rb_define_method(gWidget, "can_focus?",   widget_CAN_FOCUS, 0);
    rb_define_method(gWidget, "has_focus?",   widget_HAS_FOCUS, 0);
    rb_define_method(gWidget, "can_default?", widget_CAN_DEFAULT, 0);
    rb_define_method(gWidget, "has_default?", widget_HAS_DEFAULT, 0);
    rb_define_method(gWidget, "has_grab?",    widget_HAS_GRAB, 0);
    rb_define_method(gWidget, "basic?",       widget_BASIC, 0);
    rb_define_method(gWidget, "rc_style?",    widget_RC_STYLE, 0);

a6791 1
    rb_define_method(gContainer, "get_border_width", cont_get_bwidth, 0);
a6792 1
    rb_define_method(gContainer, "remove", cont_remove, 1);
a6836 4
    rb_define_method(gAdjustment, "set_value", adj_set_value, 1);
    rb_define_method(gAdjustment, "get_value", adj_get_value, 0);
    rb_define_method(gAdjustment, "value=", adj_set_value, 1);
    rb_define_method(gAdjustment, "value", adj_get_value, 0);
a6855 1
    rb_define_method(gTButton, "active?", tbtn_active, 0);
a6911 1
    rb_define_method(gCList, "get_text", clist_get_text, 2);
a7124 2
    rb_define_method(gLabel, "jtype", label_get_jtype, 0);
    rb_define_method(gLabel, "jtype=", label_set_jtype, 1);
d7326 1
a7326 1
    rb_define_method(gStyle, "set_background", style_set_background, 2);
a7366 1
    rb_define_singleton_method(gAllocation, "new", gallocation_new, 4);
a7370 2
    rb_define_method(gAllocation, "to_a", gallocation_to_a, 0);
    rb_define_method(gAllocation, "to_s", gallocation_to_s, 0);
a7371 1
    rb_define_singleton_method(gRequisition, "new", grequisition_new, 2);
d7374 1
d7377 1
a7377 2
    rb_define_method(gRequisition, "to_a", grequisition_to_a, 0);
    rb_define_method(gRequisition, "to_s", grequisition_to_s, 0);
d7405 1
a7451 3
    rb_define_method(gdkWindow, "move", gdkwin_move, 2);
    rb_define_method(gdkWindow, "resize", gdkwin_resize, 2);
    rb_define_method(gdkWindow, "move_resize", gdkwin_move_resize, 4);
a7510 7
    /* GtkStateType */
    rb_define_const(mGtk, "STATE_NORMAL", INT2FIX(GTK_STATE_NORMAL));
    rb_define_const(mGtk, "STATE_ACTIVE", INT2FIX(GTK_STATE_ACTIVE));
    rb_define_const(mGtk, "STATE_PRELIGHT", INT2FIX(GTK_STATE_PRELIGHT));
    rb_define_const(mGtk, "STATE_SELECTED", INT2FIX(GTK_STATE_SELECTED));
    rb_define_const(mGtk, "STATE_INSENSITIVE", INT2FIX(GTK_STATE_INSENSITIVE));

d7516 4
d7528 21
d7555 6
a7560 20

    /* GtkArrowType */
    rb_define_const(mGtk, "ARROW_UP", INT2FIX(GTK_ARROW_UP));
    rb_define_const(mGtk, "ARROW_DOWN", INT2FIX(GTK_ARROW_DOWN));
    rb_define_const(mGtk, "ARROW_LEFT", INT2FIX(GTK_ARROW_LEFT));
    rb_define_const(mGtk, "ARROW_RIGHT", INT2FIX(GTK_ARROW_RIGHT));

    /* GtkPackType */
    rb_define_const(mGtk, "GTK_PACK_START", INT2FIX(GTK_PACK_START));
    rb_define_const(mGtk, "GTK_PACK_END", INT2FIX(GTK_PACK_END));

    /* GtkPolicyType */
    rb_define_const(mGtk, "POLICY_ALWAYS", INT2FIX(GTK_POLICY_ALWAYS));
    rb_define_const(mGtk, "POLICY_AUTOMATIC", INT2FIX(GTK_POLICY_AUTOMATIC));

    /* GtkUpdateType */
    rb_define_const(mGtk, "UPDATE_CONTINUOUS", INT2FIX(GTK_UPDATE_CONTINUOUS));
    rb_define_const(mGtk, "UPDATE_DISCONTINUOUS", INT2FIX(GTK_UPDATE_DISCONTINUOUS));
    rb_define_const(mGtk, "UPDATE_DELAYED", INT2FIX(GTK_UPDATE_DELAYED));

a7564 13

    /* GtkSignalRunOptions */
    rb_define_const(mGtk, "RUN_FIRST", INT2FIX(GTK_RUN_FIRST));
    rb_define_const(mGtk, "RUN_LAST", INT2FIX(GTK_RUN_LAST));
    rb_define_const(mGtk, "RUN_BOTH", INT2FIX(GTK_RUN_BOTH));
    rb_define_const(mGtk, "RUN_MASK", INT2FIX(GTK_RUN_MASK));
    rb_define_const(mGtk, "RUN_NO_RECURSE", INT2FIX(GTK_RUN_NO_RECURSE));

    /* GtkWindowPosition */
    rb_define_const(mGtk, "WIN_POS_NONE", INT2FIX(GTK_WIN_POS_NONE));
    rb_define_const(mGtk, "WIN_POS_CENTER", INT2FIX(GTK_WIN_POS_CENTER));
    rb_define_const(mGtk, "WIN_POS_MOUSE", INT2FIX(GTK_WIN_POS_MOUSE));

a7567 1

a7570 6

    /* GtkMenuFactoryType */
    rb_define_const(mGtk, "MENU_FACTORY_MENU", INT2FIX(GTK_MENU_FACTORY_MENU));
    rb_define_const(mGtk, "MENU_FACTORY_MENU_BAR", INT2FIX(GTK_MENU_FACTORY_MENU_BAR));
    rb_define_const(mGtk, "MENU_FACTORY_OPTION_MENU", INT2FIX(GTK_MENU_FACTORY_OPTION_MENU));

d7576 5
a7580 19
    /* GtkScrollType */
    rb_define_const(mGtk, "SCROLL_NONE", INT2FIX(GTK_SCROLL_NONE));
    rb_define_const(mGtk, "SCROLL_STEP_BACKWARD", INT2FIX(GTK_SCROLL_STEP_BACKWARD));
    rb_define_const(mGtk, "SCROLL_STEP_FORWARD", INT2FIX(GTK_SCROLL_STEP_FORWARD));
    rb_define_const(mGtk, "SCROLL_PAGE_BACKWARD", INT2FIX(GTK_SCROLL_PAGE_BACKWARD));
    rb_define_const(mGtk, "SCROLL_PAGE_FORWARD", INT2FIX(GTK_SCROLL_PAGE_FORWARD));
    rb_define_const(mGtk, "SCROLL_JUMP", INT2FIX(GTK_SCROLL_JUMP));

    /* GtkTroughType */
    rb_define_const(mGtk, "TROUGH_NONE", INT2FIX(GTK_TROUGH_NONE));
    rb_define_const(mGtk, "TROUGH_START", INT2FIX(GTK_TROUGH_START));
    rb_define_const(mGtk, "TROUGH_END", INT2FIX(GTK_TROUGH_END));
    rb_define_const(mGtk, "TROUGH_JUMP", INT2FIX(GTK_TROUGH_JUMP));

	/* GtkPositionType */
    rb_define_const(mGtk, "POS_LEFT", INT2FIX(GTK_POS_LEFT));
    rb_define_const(mGtk, "POS_RIGHT", INT2FIX(GTK_POS_RIGHT));
    rb_define_const(mGtk, "POS_TOP", INT2FIX(GTK_POS_TOP));
    rb_define_const(mGtk, "POS_BOTTOM", INT2FIX(GTK_POS_BOTTOM));
d7586 5
a7590 15
    /* GtkJustification */
    rb_define_const(mGtk, "JUSTIFY_LEFT", INT2FIX(GTK_JUSTIFY_LEFT));
    rb_define_const(mGtk, "JUSTIFY_RIGHT", INT2FIX(GTK_JUSTIFY_RIGHT));
    rb_define_const(mGtk, "JUSTIFY_CENTER", INT2FIX(GTK_JUSTIFY_CENTER));
    rb_define_const(mGtk, "JUSTIFY_FILL", INT2FIX(GTK_JUSTIFY_FILL));

    /* GtkSelectionMode */
    rb_define_const(mGtk, "SELECTION_SINGLE", INT2FIX(GTK_SELECTION_SINGLE));
    rb_define_const(mGtk, "SELECTION_BROWSE", INT2FIX(GTK_SELECTION_BROWSE));
    rb_define_const(mGtk, "SELECTION_MULTIPLE", INT2FIX(GTK_SELECTION_MULTIPLE));
    rb_define_const(mGtk, "SELECTION_EXTENDED", INT2FIX(GTK_SELECTION_EXTENDED));

    /* GtkOrientation */
    rb_define_const(mGtk, "ORIENTATION_HORIZONTAL", INT2FIX(GTK_ORIENTATION_HORIZONTAL));
    rb_define_const(mGtk, "ORIENTATION_VERTICAL", INT2FIX(GTK_ORIENTATION_VERTICAL));
d7597 3
a7599 12
    /* GtkVisibility */
    rb_define_const(mGtk, "VISIBILITY_NONE", INT2FIX(GTK_VISIBILITY_NONE));
    rb_define_const(mGtk, "VISIBILITY_PARTIAL", INT2FIX(GTK_VISIBILITY_PARTIAL));
    rb_define_const(mGtk, "VISIBILITY_FULL", INT2FIX(GTK_VISIBILITY_FULL));


	/* GtkButtonBox */
    rb_define_const(mGtk, "BUTTONBOX_DEFAULT", INT2FIX(GTK_BUTTONBOX_DEFAULT));
    rb_define_const(mGtk, "BUTTONBOX_SPREAD", INT2FIX(GTK_BUTTONBOX_SPREAD));
    rb_define_const(mGtk, "BUTTONBOX_EDGE", INT2FIX(GTK_BUTTONBOX_EDGE));
    rb_define_const(mGtk, "BUTTONBOX_START", INT2FIX(GTK_BUTTONBOX_START));
    rb_define_const(mGtk, "BUTTONBOX_END", INT2FIX(GTK_BUTTONBOX_END));
@


1.1.1.1.2.25.2.3
log
@first public release of 1.1d (pre1.2) series
@
text
@d6 1
a6 1
  $Date: 1998/10/06 03:28:18 $
d6650 1
a6650 1
static VALUE
d6654 1
a6654 1
    return rb_funcall(proc, id_call, 0);
d6663 2
a6664 2
    id = gtk_timeout_add(NUM2INT(interval), (GtkFunction)exec_interval,
			 (gpointer)rb_f_lambda());
d6682 1
a6682 1
    id = gtk_idle_add((GtkFunction)exec_interval, (gpointer)rb_f_lambda());
@


1.1.1.1.2.25.2.4
log
@1.1d1
@
text
@d6 1
a6 1
  $Date: 1998/12/16 07:30:34 $
d991 1
a991 1
	rb_raise(rb_eArgError, "function out of range");
@


