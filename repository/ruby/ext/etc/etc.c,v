head	1.7;
access;
symbols
	v1_6_7:1.4
	v1_6_6:1.4
	v1_6_5:1.4
	v1_6_4:1.4
	v1_7_1:1.4
	v1_6_4_preview4:1.4
	v1_6_4_preview3:1.4
	v1_6_4_preview2:1.4
	v1_6_4_preview1:1.4
	v1_6_3:1.4
	ruby_m17n:1.4.0.4
	ruby_1_6:1.4.0.2
	v1_6_2:1.4
	v1_6_1:1.4
	v1_6_0:1.4
	v1_4_6:1.2
	v1_4_5:1.2
	v1_4_4:1.2
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.2
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.2.2.2
	v1_3_6_repack:1.1.1.2.2.2
	v1_3_6:1.1.1.2.2.2
	v1_3_5:1.1.1.2.2.2
	v1_2_6repack:1.1.1.1.4.5
	v1_3_4_990625:1.1.1.2.2.2
	v1_3_4_990624:1.1.1.2.2.2
	v1_2_6:1.1.1.1.4.5
	v1_3_4_990611:1.1.1.2.2.1
	v1_3_4_990531:1.1.1.2
	v1_3_3_990518:1.1.1.2
	v1_3_3_990513:1.1.1.2
	v1_3_3_990507:1.1.1.2
	v1_2_5:1.1.1.1.4.4
	v1_2_4:1.1.1.1.4.4
	v1_3_1_990225:1.1.1.2
	v1_3_1_990224:1.1.1.2
	v1_3_1_990215:1.1.1.2
	v1_3_1_990212:1.1.1.2
	v1_3_1_990210:1.1.1.2
	v1_3_1_:1.1.1.2
	v1_3_1_990209:1.1.1.2
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.4.4
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.4.4
	v1_2_1repack:1.1.1.1.4.4
	v1_2_1:1.1.1.1.4.4
	v1_2_stable:1.1.1.1.4.4
	v1_1d1:1.1.1.1.4.3.2.3
	v1_1d0:1.1.1.1.4.3.2.3
	v1_1c9_1:1.1.1.1.4.4
	v1_1c9:1.1.1.1.4.4
	v1_1c8:1.1.1.1.4.4
	v1_1c7:1.1.1.1.4.4
	v1_1c6:1.1.1.1.4.4
	v1_1d-start:1.1.1.1.4.3.2.1
	v1_1c5:1.1.1.1.4.3
	v1_1dev:1.1.1.1.4.3.0.2
	v1_1c4:1.1.1.1.4.3
	v1_1c3:1.1.1.1.4.3
	v1_1c2:1.1.1.1.4.3
	v1_1c1:1.1.1.1.4.3
	v1_1c0:1.1.1.1.4.3
	v1_1b9_31:1.1.1.1.4.3
	v1_1b9_30:1.1.1.1.4.3
	v1_1b9_28:1.1.1.1.4.3
	v1_1b9_27:1.1.1.1.4.3
	v1_1b9_26:1.1.1.1.4.3
	r1_1b9_25:1.1.1.1.4.3
	r1_1b9_24:1.1.1.1.4.3
	v1_1b9_23:1.1.1.1.4.3
	v1_1b9_22:1.1.1.1.4.3
	v1_1b9_20:1.1.1.1.4.3
	v1_1b9_18:1.1.1.1.4.2
	v1_1b9_16:1.1.1.1.4.2
	v1_1b9_15:1.1.1.1.4.2
	v1_1b9_13:1.1.1.1.4.2
	v1_1b9_12:1.1.1.1.4.2
	v1_1b9_11:1.1.1.1.4.2
	v1_1b9_08:1.1.1.1.4.2
	v1_1b9_07:1.1.1.1.4.2
	r1_1b9:1.1.1.1.4.1
	v1_1b8:1.1.1.1.4.1
	v1_1b7:1.1.1.1.4.1
	v1_1b6:1.1.1.1.4.1
	v1_1r:1.1.1.1.0.4
	v1_1:1.1.1.1
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2002.09.08.10.00.43;	author eban;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.29.05.20.37;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.18.08.47.00;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.24.04.34.14;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.12.09.07.49;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.37.47;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.32;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	;

1.1.1.2.2.1
date	99.06.11.06.29.59;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	99.06.24.04.24.05;	author matz;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	98.01.16.12.35.54;	author matz;	state Exp;
branches;
next	1.1.1.1.4.2;

1.1.1.1.4.2
date	98.03.30.09.32.54;	author matz;	state Exp;
branches;
next	1.1.1.1.4.3;

1.1.1.1.4.3
date	98.05.13.07.26.44;	author matz;	state Exp;
branches
	1.1.1.1.4.3.2.1;
next	1.1.1.1.4.4;

1.1.1.1.4.4
date	98.10.06.02.45.09;	author matz;	state Exp;
branches;
next	1.1.1.1.4.5;

1.1.1.1.4.5
date	99.06.21.06.31.11;	author matz;	state Exp;
branches;
next	;

1.1.1.1.4.3.2.1
date	98.09.08.07.09.32;	author matz;	state Exp;
branches;
next	1.1.1.1.4.3.2.2;

1.1.1.1.4.3.2.2
date	98.10.06.03.28.18;	author matz;	state Exp;
branches;
next	1.1.1.1.4.3.2.3;

1.1.1.1.4.3.2.3
date	98.11.25.03.31.18;	author matz;	state Exp;
branches;
next	;


desc
@@


1.7
log
@* lib/mkmf.rb (have_struct_member): moved from ext/socket/extconf.rb.
* ext/socket/extconf.rb: use macro_defined? instead of egrep_cpp.
* ext/etc/extconf.rb: use have_struct_member.
* ext/etc/etc.c: add prefix HAVE_ST_ to PW_ macros.
@
text
@/************************************************

  etc.c -

  $Author: matz $
  $Date: 2002/05/29 05:20:37 $
  created at: Tue Mar 22 18:39:19 JST 1994

************************************************/

#include "ruby.h"

#include <sys/types.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef HAVE_GETPWENT
#include <pwd.h>
#endif

#ifdef HAVE_GETGRENT
#include <grp.h>
#endif

static VALUE sPasswd, sGroup;

char *getenv();
char *getlogin();

static VALUE
etc_getlogin(obj)
    VALUE obj;
{
    char *login;

    rb_secure(4);
#ifdef HAVE_GETLOGIN
    login = getlogin();
    if (!login) login = getenv("USER");
#else
    login = getenv("USER");
#endif

    if (login)
	return rb_tainted_str_new2(login);
    return Qnil;
}

#ifdef HAVE_GETPWENT
static VALUE
setup_passwd(pwd)
    struct passwd *pwd;
{
    if (pwd == 0) rb_sys_fail("/etc/passwd");
    return rb_struct_new(sPasswd,
			 rb_tainted_str_new2(pwd->pw_name),
			 rb_tainted_str_new2(pwd->pw_passwd),
			 INT2FIX(pwd->pw_uid),
			 INT2FIX(pwd->pw_gid),
#ifdef HAVE_ST_PW_GECOS
			 rb_tainted_str_new2(pwd->pw_gecos),
#endif
			 rb_tainted_str_new2(pwd->pw_dir),
			 rb_tainted_str_new2(pwd->pw_shell),
#ifdef HAVE_ST_PW_CHANGE
			 INT2FIX(pwd->pw_change),
#endif
#ifdef HAVE_ST_PW_QUOTA
			 INT2FIX(pwd->pw_quota),
#endif
#ifdef HAVE_ST_PW_AGE
			 INT2FIX(pwd->pw_age),
#endif
#ifdef HAVE_ST_PW_CLASS
			 rb_tainted_str_new2(pwd->pw_class),
#endif
#ifdef HAVE_ST_PW_COMMENT
			 rb_tainted_str_new2(pwd->pw_comment),
#endif
#ifdef HAVE_ST_PW_EXPIRE
			 INT2FIX(pwd->pw_expire),
#endif
			 0		/*dummy*/
	);
}
#endif

static VALUE
etc_getpwuid(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
#if defined(HAVE_GETPWENT)
    VALUE id, ary;
    int uid;
    struct passwd *pwd;

    rb_secure(4);
    if (rb_scan_args(argc, argv, "01", &id) == 1) {
	uid = NUM2INT(id);
    }
    else {
	uid = getuid();
    }
    pwd = getpwuid(uid);
    if (pwd == 0) rb_raise(rb_eArgError, "can't find user for %d", uid);
    return setup_passwd(pwd);
#else 
    return Qnil;
#endif
}

static VALUE
etc_getpwnam(obj, nam)
    VALUE obj, nam;
{
#ifdef HAVE_GETPWENT
    struct passwd *pwd;

    SafeStringValue(nam);
    pwd = getpwnam(RSTRING(nam)->ptr);
    if (pwd == 0) rb_raise(rb_eArgError, "can't find user for %s", RSTRING(nam)->ptr);
    return setup_passwd(pwd);
#else 
    return Qnil;
#endif
}

#ifdef HAVE_GETPWENT
static int passwd_blocking = 0;
static VALUE
passwd_ensure()
{
    passwd_blocking = Qfalse;
    return Qnil;
}

static VALUE
passwd_iterate()
{
    struct passwd *pw;

    setpwent();
    while (pw = getpwent()) {
	rb_yield(setup_passwd(pw));
    }
    endpwent();
    return Qnil;
}
#endif

static VALUE
etc_passwd(obj)
    VALUE obj;
{
#ifdef HAVE_GETPWENT
    struct passwd *pw;

    rb_secure(4);
    if (rb_block_given_p()) {
	if (passwd_blocking) {
	    rb_raise(rb_eRuntimeError, "parallel passwd iteration");
	}
	passwd_blocking = Qtrue;
	rb_ensure(passwd_iterate, 0, passwd_ensure, 0);
    }
    if (pw = getpwent()) {
	return setup_passwd(pw);
    }
#endif
    return Qnil;
}

#ifdef HAVE_GETGRENT
static VALUE
setup_group(grp)
    struct group *grp;
{
    VALUE mem;
    char **tbl;

    mem = rb_ary_new();
    tbl = grp->gr_mem;
    while (*tbl) {
	rb_ary_push(mem, rb_tainted_str_new2(*tbl));
	tbl++;
    }
    return rb_struct_new(sGroup,
			 rb_tainted_str_new2(grp->gr_name),
			 rb_tainted_str_new2(grp->gr_passwd),
			 INT2FIX(grp->gr_gid),
			 mem);
}
#endif

static VALUE
etc_getgrgid(obj, id)
    VALUE obj, id;
{
#ifdef HAVE_GETGRENT
    int gid;
    struct group *grp;

    rb_secure(4);
    gid = NUM2INT(id);
    grp = getgrgid(gid);
    if (grp == 0) rb_raise(rb_eArgError, "can't find group for %d", gid);
    return setup_group(grp);
#else
    return Qnil;
#endif
}

static VALUE
etc_getgrnam(obj, nam)
    VALUE obj, nam;
{
#ifdef HAVE_GETGRENT
    struct group *grp;

    rb_secure(4);
    SafeStringValue(nam);
    grp = getgrnam(RSTRING(nam)->ptr);
    if (grp == 0) rb_raise(rb_eArgError, "can't find group for %s", RSTRING(nam)->ptr);
    return setup_group(grp);
#else
    return Qnil;
#endif
}

#ifdef HAVE_GETGRENT
static int group_blocking = 0;
static VALUE
group_ensure()
{
    group_blocking = Qfalse;
    return Qnil;
}

static VALUE
group_iterate()
{
    struct group *pw;

    setpwent();
    while (pw = getgrent()) {
	rb_yield(setup_group(pw));
    }
    endpwent();
    return Qnil;
}
#endif

static VALUE
etc_group(obj)
    VALUE obj;
{
#ifdef HAVE_GETGRENT
    struct group *grp;

    rb_secure(4);
    if (rb_block_given_p()) {
	if (group_blocking) {
	    rb_raise(rb_eRuntimeError, "parallel group iteration");
	}
	group_blocking = Qtrue;
	rb_ensure(group_iterate, 0, group_ensure, 0);
    }
    if (grp = getgrent()) {
	return setup_group(grp);
    }
#endif
    return Qnil;
}

static VALUE mEtc;

void
Init_etc()
{
    mEtc = rb_define_module("Etc");

    rb_define_module_function(mEtc, "getlogin", etc_getlogin, 0);

    rb_define_module_function(mEtc, "getpwuid", etc_getpwuid, -1);
    rb_define_module_function(mEtc, "getpwnam", etc_getpwnam, 1);
    rb_define_module_function(mEtc, "passwd", etc_passwd, 0);

    rb_define_module_function(mEtc, "getgrgid", etc_getgrgid, 1);
    rb_define_module_function(mEtc, "getgrnam", etc_getgrnam, 1);
    rb_define_module_function(mEtc, "group", etc_group, 0);

    sPasswd =  rb_struct_define("Passwd",
				"name", "passwd", "uid", "gid",
#ifdef HAVE_ST_PW_GECOS
				"gecos",
#endif
				"dir", "shell",
#ifdef HAVE_ST_PW_CHANGE
				"change",
#endif
#ifdef HAVE_ST_PW_QUOTA
				"quota",
#endif
#ifdef HAVE_ST_PW_AGE
				"age",
#endif
#ifdef HAVE_ST_PW_CLASS
				"uclass",
#endif
#ifdef HAVE_ST_PW_COMMENT
				"comment",
#endif
#ifdef HAVE_ST_PW_EXPIRE
				"expire",
#endif
				0);
    rb_global_variable(&sPasswd);

#ifdef HAVE_GETGRENT
    sGroup = rb_struct_define("Group", "name", "passwd", "gid", "mem", 0);
    rb_global_variable(&sGroup);
#endif
}
@


1.6
log
@* parse.y: yyparse #defines moved from intern.h

* ruby.c (proc_options): access prefixed "ruby_yydebug".

* applied modifies to pacify some of gcc -Wall warnings.

* parse.y (arg): no more ugly hack for "**", so that "-2**2" to be
  parsed as "(-2)**2", whereas "- 2**2" or "-(2)**2" to be parsed
  as "-(2**2)".

* parse.y (yylex): '-2' to be literal fixnum. [new]

* time.c (time_succ): new method for Range support.

* time.c (time_arg): nil test against v[6] (usec).
@
text
@d6 1
a6 1
  $Date: 2001/12/18 08:47:00 $
d61 1
a61 1
#ifdef PW_GECOS
d66 1
a66 1
#ifdef PW_CHANGE
d69 1
a69 1
#ifdef PW_QUOTA
d72 1
a72 1
#ifdef PW_AGE
d75 1
a75 1
#ifdef PW_CLASS
d78 1
a78 1
#ifdef PW_COMMENT
d81 1
a81 1
#ifdef PW_EXPIRE
d297 1
a297 1
#ifdef PW_GECOS
d301 1
a301 1
#ifdef PW_CHANGE
d304 1
a304 1
#ifdef PW_QUOTA
d307 1
a307 1
#ifdef PW_AGE
d310 1
a310 1
#ifdef PW_CLASS
d313 1
a313 1
#ifdef PW_COMMENT
d316 1
a316 1
#ifdef PW_EXPIRE
@


1.5
log
@* string.c (rb_str_replace): swap arguments of OBJ_INFECT.

* eval.c (rb_thread_schedule): should not select a thread which is
  not yet initialized.

* time.c (time_plus): wrong boundary check.

* time.c (time_minus): ditto.
@
text
@d6 1
a6 1
  $Date: 2000/05/24 04:34:14 $
d28 3
a34 1
    char *getenv();
d37 1
a38 2
    char *getlogin();

d95 2
a96 2
#ifdef HAVE_GETPWENT
    VALUE id;
d100 1
d122 1
a122 1
    StringValue(nam);
d131 23
d161 1
d163 2
a164 3
	setpwent();
	while (pw = getpwent()) {
	    rb_yield(setup_passwd(pw));
d166 2
a167 2
	endpwent();
	return obj;
d206 1
d223 2
a224 1
    StringValue(nam);
d233 23
d263 1
d265 2
a266 3
	setgrent();
	while (grp = getgrent()) {
	    rb_yield(setup_group(grp));
d268 2
a269 2
	endgrent();
	return obj;
d311 1
a311 1
				"class",
@


1.4
log
@2000-05-24
@
text
@d6 1
a6 1
  $Date: 2000/05/12 09:07:49 $
d120 1
a120 1
    Check_Type(nam, T_STRING);
d197 1
a197 1
    Check_Type(nam, T_STRING);
@


1.3
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:37:47 $
d136 1
a136 1
    if (rb_iterator_p()) {
d213 1
a213 1
    if (rb_iterator_p()) {
@


1.2
log
@remove marshal/gtk/kconv
@
text
@d6 1
a6 1
  $Date: 1999/06/24 04:24:05 $
d12 5
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1995/01/10 10:42:32 $
d40 1
a40 1
	return str_new2(login);
d50 10
a59 8
    return struct_new(sPasswd,
		      str_new2(pwd->pw_name),
		      str_new2(pwd->pw_passwd),
		      INT2FIX(pwd->pw_uid),
		      INT2FIX(pwd->pw_gid),
		      str_new2(pwd->pw_gecos),
		      str_new2(pwd->pw_dir),
		      str_new2(pwd->pw_shell),
d61 1
a61 1
		      INT2FIX(pwd->pw_change),
d64 1
a64 1
		      INT2FIX(pwd->pw_quota),
d67 1
a67 1
		      INT2FIX(pwd->pw_age),
d70 1
a70 1
		      str_new2(pwd->pw_class),
d73 1
a73 1
		      str_new2(pwd->pw_comment),
d76 1
a76 1
		      INT2FIX(pwd->pw_expire),
d78 2
a79 2
		      0		/*dummy*/
		      );
d101 1
a101 1
    if (pwd == 0) Fail("can't find user for %d", uid);
d117 1
a117 1
    if (pwd == 0) Fail("can't find user for %s", RSTRING(nam)->ptr);
d128 1
a128 1
#if defined(HAVE_GETPWENT) && !defined(__CYGWIN32__)
d131 1
a131 1
    if (iterator_p()) {
d139 4
a142 4
    pw = getpwent();
    if (pw == 0) Fail("can't fetch next -- /etc/passwd");
    return setup_passwd(pw);
#else 
a143 1
#endif
d154 1
a154 1
    mem = ary_new();
d157 1
a157 1
	ary_push(mem, str_new2(*tbl));
d160 5
a164 5
    return struct_new(sGroup,
		      str_new2(grp->gr_name),
		      str_new2(grp->gr_passwd),
		      INT2FIX(grp->gr_gid),
		      mem);
d178 1
a178 1
    if (grp == 0) Fail("can't find group for %d", gid);
d194 1
a194 1
    if (grp == 0) Fail("can't find group for %s", RSTRING(nam)->ptr);
d208 1
a208 1
    if (iterator_p()) {
d216 4
a219 2
    return setup_group(getgrent());
#else
a220 1
#endif
d240 6
a245 3
    sPasswd =  struct_define("Passwd",
			     "name", "passwd", "uid", "gid",
			     "gecos", "dir", "shell",
d247 1
a247 1
			     "change",
d250 1
a250 1
			     "quota",
d253 1
a253 1
			     "age",
d256 1
a256 1
			     "class",
d259 1
a259 1
			     "comment",
d262 1
a262 1
			     "expire",
d264 1
a264 1
			     0);
d268 1
a268 1
    sGroup = struct_define("Group", "name", "passwd", "gid", "mem", 0);
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/11/25 03:31:18 $
d40 1
a40 1
	return rb_tainted_str_new2(login);
d50 8
a57 10
    return rb_struct_new(sPasswd,
			 rb_tainted_str_new2(pwd->pw_name),
			 rb_tainted_str_new2(pwd->pw_passwd),
			 INT2FIX(pwd->pw_uid),
			 INT2FIX(pwd->pw_gid),
#ifdef PW_GECOS
			 rb_tainted_str_new2(pwd->pw_gecos),
#endif
			 rb_tainted_str_new2(pwd->pw_dir),
			 rb_tainted_str_new2(pwd->pw_shell),
d59 1
a59 1
			 INT2FIX(pwd->pw_change),
d62 1
a62 1
			 INT2FIX(pwd->pw_quota),
d65 1
a65 1
			 INT2FIX(pwd->pw_age),
d68 1
a68 1
			 rb_tainted_str_new2(pwd->pw_class),
d71 1
a71 1
			 rb_tainted_str_new2(pwd->pw_comment),
d74 1
a74 1
			 INT2FIX(pwd->pw_expire),
d76 2
a77 2
			 0		/*dummy*/
	);
d99 1
a99 1
    if (pwd == 0) rb_raise(rb_eArgError, "can't find user for %d", uid);
d115 1
a115 1
    if (pwd == 0) rb_raise(rb_eArgError, "can't find user for %s", RSTRING(nam)->ptr);
d126 1
a126 1
#if defined(HAVE_GETPWENT)
d129 1
a129 1
    if (rb_iterator_p()) {
d138 1
a138 1
    if (pw == 0) rb_raise(rb_eRuntimeError, "can't fetch next -- /etc/passwd");
d153 1
a153 1
    mem = rb_ary_new();
d156 1
a156 1
	rb_ary_push(mem, rb_tainted_str_new2(*tbl));
d159 5
a163 5
    return rb_struct_new(sGroup,
			 rb_tainted_str_new2(grp->gr_name),
			 rb_tainted_str_new2(grp->gr_passwd),
			 INT2FIX(grp->gr_gid),
			 mem);
d177 1
a177 1
    if (grp == 0) rb_raise(rb_eArgError, "can't find group for %d", gid);
d193 1
a193 1
    if (grp == 0) rb_raise(rb_eArgError, "can't find group for %s", RSTRING(nam)->ptr);
d207 1
a207 1
    if (rb_iterator_p()) {
d238 3
a240 6
    sPasswd =  rb_struct_define("Passwd",
				"name", "passwd", "uid", "gid",
#ifdef PW_GECOS
				"gecos",
#endif
				"dir", "shell",
d242 1
a242 1
				"change",
d245 1
a245 1
				"quota",
d248 1
a248 1
				"age",
d251 1
a251 1
				"class",
d254 1
a254 1
				"comment",
d257 1
a257 1
				"expire",
d259 1
a259 1
				0);
d263 1
a263 1
    sGroup = rb_struct_define("Group", "name", "passwd", "gid", "mem", 0);
@


1.1.1.2.2.1
log
@990611
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:32 $
d217 3
a219 3
    if (grp = getgrent()) {
	return setup_group(grp);
    }
a220 1
    return Qnil;
@


1.1.1.2.2.2
log
@990624
@
text
@d6 1
a6 1
  $Date: 1999/06/11 06:29:59 $
d128 1
a128 1
#ifdef HAVE_GETPWENT
d139 5
a143 3
    if (pw = getpwent()) {
	return setup_passwd(pw);
    }
a144 1
    return Qnil;
@


1.1.1.1.4.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 04:05:49 $
@


1.1.1.1.4.2
log
@gw32 b19 patch
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:54 $
d126 1
a126 1
#if defined(HAVE_GETPWENT)
@


1.1.1.1.4.3
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/03/30 09:32:54 $
a54 1
#ifdef PW_GECOS
a55 1
#endif
@


1.1.1.1.4.4
log
@1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:44 $
d242 1
a242 4
#ifdef PW_GECOS
                            "gecos",
#endif
			     "dir", "shell",
@


1.1.1.1.4.5
log
@1.2.6
@
text
@d6 1
a6 1
  $Date: 1998/10/06 02:45:09 $
d217 3
a219 3
    if (grp = getgrent()) {
	return setup_group(grp);
    }
a220 1
    return Qnil;
@


1.1.1.1.4.3.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:44 $
d40 1
a40 1
	return rb_str_new2(login);
d50 5
a54 5
    return rb_struct_new(sPasswd,
			 rb_str_new2(pwd->pw_name),
			 rb_str_new2(pwd->pw_passwd),
			 INT2FIX(pwd->pw_uid),
			 INT2FIX(pwd->pw_gid),
d56 1
a56 1
			 rb_str_new2(pwd->pw_gecos),
d58 2
a59 2
			 rb_str_new2(pwd->pw_dir),
			 rb_str_new2(pwd->pw_shell),
d61 1
a61 1
			 INT2FIX(pwd->pw_change),
d64 1
a64 1
			 INT2FIX(pwd->pw_quota),
d67 1
a67 1
			 INT2FIX(pwd->pw_age),
d70 1
a70 1
			 rb_str_new2(pwd->pw_class),
d73 1
a73 1
			 rb_str_new2(pwd->pw_comment),
d76 1
a76 1
			 INT2FIX(pwd->pw_expire),
d78 2
a79 2
			 0		/*dummy*/
	);
d101 1
a101 1
    if (pwd == 0) rb_raise(rb_eArgError, "can't find user for %d", uid);
d117 1
a117 1
    if (pwd == 0) rb_raise(rb_eArgError, "can't find user for %s", RSTRING(nam)->ptr);
d131 1
a131 1
    if (rb_iterator_p()) {
d140 1
a140 1
    if (pw == 0) rb_raise(rb_eRuntimeError, "can't fetch next -- /etc/passwd");
d155 1
a155 1
    mem = rb_ary_new();
d158 1
a158 1
	rb_ary_push(mem, rb_str_new2(*tbl));
d161 5
a165 5
    return rb_struct_new(sGroup,
			 rb_str_new2(grp->gr_name),
			 rb_str_new2(grp->gr_passwd),
			 INT2FIX(grp->gr_gid),
			 mem);
d179 1
a179 1
    if (grp == 0) rb_raise(rb_eArgError, "can't find group for %d", gid);
d195 1
a195 1
    if (grp == 0) rb_raise(rb_eArgError, "can't find group for %s", RSTRING(nam)->ptr);
d209 1
a209 1
    if (rb_iterator_p()) {
d240 3
a242 3
    sPasswd =  rb_struct_define("Passwd",
				"name", "passwd", "uid", "gid",
				"gecos", "dir", "shell",
d244 1
a244 1
				"change",
d247 1
a247 1
				"quota",
d250 1
a250 1
				"age",
d253 1
a253 1
				"class",
d256 1
a256 1
				"comment",
d259 1
a259 1
				"expire",
d261 1
a261 1
				0);
d265 1
a265 1
    sGroup = rb_struct_define("Group", "name", "passwd", "gid", "mem", 0);
@


1.1.1.1.4.3.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/10/06 02:45:09 $
d242 1
a242 4
#ifdef PW_GECOS
				"gecos",
#endif
				"dir", "shell",
@


1.1.1.1.4.3.2.3
log
@*** empty log message ***
@
text
@d40 1
a40 1
	return rb_tainted_str_new2(login);
d51 2
a52 2
			 rb_tainted_str_new2(pwd->pw_name),
			 rb_tainted_str_new2(pwd->pw_passwd),
d56 1
a56 1
			 rb_tainted_str_new2(pwd->pw_gecos),
d58 2
a59 2
			 rb_tainted_str_new2(pwd->pw_dir),
			 rb_tainted_str_new2(pwd->pw_shell),
d70 1
a70 1
			 rb_tainted_str_new2(pwd->pw_class),
d73 1
a73 1
			 rb_tainted_str_new2(pwd->pw_comment),
d158 1
a158 1
	rb_ary_push(mem, rb_tainted_str_new2(*tbl));
d162 2
a163 2
			 rb_tainted_str_new2(grp->gr_name),
			 rb_tainted_str_new2(grp->gr_passwd),
@
