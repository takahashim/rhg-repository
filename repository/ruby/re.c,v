head	1.83;
access;
symbols
	v1_6_7:1.34.2.10
	v1_6_6:1.34.2.7
	v1_6_5:1.34.2.4
	v1_6_4:1.34.2.3
	v1_7_1:1.43
	v1_6_4_preview4:1.34.2.3
	v1_6_4_preview3:1.34.2.3
	v1_6_4_preview2:1.34.2.3
	v1_6_4_preview1:1.34.2.3
	v1_6_3:1.34.2.3
	ruby_m17n:1.34.0.4
	ruby_1_6:1.34.0.2
	v1_6_2:1.34
	v1_6_1:1.32
	v1_6_0:1.31
	v1_4_6:1.3.2.8
	v1_4_5:1.3.2.6
	v1_4_4:1.3.2.3
	ruby_1_4_3:1.3.2.2
	ruby1_4_3:1.3.2.2
	v1_4_3:1.3.2.2
	v1_5_0:1.7
	ruby_1_4_3_pre1:1.3.2.1
	ruby_1_4:1.3.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.12
	v1_3_6_repack:1.1.1.3.2.12
	v1_3_6:1.1.1.3.2.12
	v1_3_5:1.1.1.3.2.12
	v1_2_6repack:1.1.1.2.2.33
	v1_3_4_990625:1.1.1.3.2.12
	v1_3_4_990624:1.1.1.3.2.11
	v1_2_6:1.1.1.2.2.33
	v1_3_4_990611:1.1.1.3.2.11
	v1_3_4_990531:1.1.1.3.2.10
	v1_3_3_990518:1.1.1.3.2.9
	v1_3_3_990513:1.1.1.3.2.9
	v1_3_3_990507:1.1.1.3.2.9
	v1_2_5:1.1.1.2.2.33
	v1_2_4:1.1.1.2.2.32
	v1_3_1_990225:1.1.1.3.2.6
	v1_3_1_990224:1.1.1.3.2.5
	v1_3_1_990215:1.1.1.3.2.4
	v1_3_1_990212:1.1.1.3.2.4
	v1_3_1_990210:1.1.1.3.2.4
	v1_3_1_:1.1.1.3.2.4
	v1_3_1_990209:1.1.1.3.2.4
	v1_3_1_990205:1.1.1.3.2.3
	v1_3_1_990203:1.1.1.3.2.2
	v1_3_1_990201:1.1.1.3.2.2
	v1_3_1"_990201:1.1.1.3.2.2
	v1_3_1_990128:1.1.1.3.2.1
	v1_3_1_990127:1.1.1.3.2.1
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.32
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.32
	v1_2_1repack:1.1.1.2.2.32
	v1_2_1:1.1.1.2.2.32
	v1_2_stable:1.1.1.2.2.32
	v1_1d1:1.1.1.2.2.31.2.3
	v1_1d0:1.1.1.2.2.31.2.2
	v1_1c9_1:1.1.1.2.2.32
	v1_1c9:1.1.1.2.2.32
	v1_1c8:1.1.1.2.2.32
	v1_1c7:1.1.1.2.2.32
	v1_1c6:1.1.1.2.2.31
	v1_1d-start:1.1.1.2.2.31.2.1
	v1_1c5:1.1.1.2.2.31
	v1_1dev:1.1.1.2.2.31.0.2
	v1_1c4:1.1.1.2.2.31
	v1_1c3:1.1.1.2.2.30
	v1_1c2:1.1.1.2.2.29
	v1_1c1:1.1.1.2.2.29
	v1_1c0:1.1.1.2.2.28
	v1_1b9_31:1.1.1.2.2.28
	v1_1b9_30:1.1.1.2.2.27
	v1_1b9_28:1.1.1.2.2.27
	v1_1b9_27:1.1.1.2.2.25
	v1_1b9_26:1.1.1.2.2.25
	r1_1b9_25:1.1.1.2.2.25
	r1_1b9_24:1.1.1.2.2.25
	v1_1b9_23:1.1.1.2.2.22
	v1_1b9_22:1.1.1.2.2.20
	v1_1b9_20:1.1.1.2.2.19
	v1_1b9_18:1.1.1.2.2.19
	v1_1b9_16:1.1.1.2.2.16
	v1_1b9_15:1.1.1.2.2.16
	v1_1b9_13:1.1.1.2.2.16
	v1_1b9_12:1.1.1.2.2.16
	v1_1b9_11:1.1.1.2.2.16
	v1_1b9_08:1.1.1.2.2.11
	v1_1b9_07:1.1.1.2.2.11
	r1_1b9:1.1.1.2.2.7
	v1_1b8:1.1.1.2.2.6
	v1_1b7:1.1.1.2.2.4
	v1_1b6:1.1.1.2.2.2
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.83
date	2002.09.25.14.52.37;	author nobu;	state Exp;
branches;
next	1.82;

1.82
date	2002.09.16.15.56.31;	author aamine;	state Exp;
branches;
next	1.81;

1.81
date	2002.09.03.05.20.06;	author matz;	state Exp;
branches;
next	1.80;

1.80
date	2002.09.02.14.04.19;	author nobu;	state Exp;
branches;
next	1.79;

1.79
date	2002.08.30.08.22.09;	author michal;	state Exp;
branches;
next	1.78;

1.78
date	2002.08.29.09.08.16;	author matz;	state Exp;
branches;
next	1.77;

1.77
date	2002.08.28.08.05.23;	author michal;	state Exp;
branches;
next	1.76;

1.76
date	2002.08.27.08.31.06;	author matz;	state Exp;
branches;
next	1.75;

1.75
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.74;

1.74
date	2002.08.20.07.36.01;	author matz;	state Exp;
branches;
next	1.73;

1.73
date	2002.08.19.05.56.05;	author matz;	state Exp;
branches;
next	1.72;

1.72
date	2002.07.29.06.14.04;	author matz;	state Exp;
branches;
next	1.71;

1.71
date	2002.07.26.06.12.39;	author matz;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.28.14.39.59;	author matz;	state Exp;
branches;
next	1.69;

1.69
date	2002.05.14.06.22.26;	author matz;	state Exp;
branches;
next	1.68;

1.68
date	2002.05.07.08.31.59;	author matz;	state Exp;
branches;
next	1.67;

1.67
date	2002.05.01.09.41.50;	author matz;	state Exp;
branches;
next	1.66;

1.66
date	2002.04.24.04.54.14;	author matz;	state Exp;
branches;
next	1.65;

1.65
date	2002.04.19.05.59.45;	author nobu;	state Exp;
branches;
next	1.64;

1.64
date	2002.04.19.04.14.07;	author matz;	state Exp;
branches;
next	1.63;

1.63
date	2002.04.18.08.46.18;	author matz;	state Exp;
branches;
next	1.62;

1.62
date	2002.04.18.08.04.57;	author akr;	state Exp;
branches;
next	1.61;

1.61
date	2002.04.08.20.21.14;	author knu;	state Exp;
branches;
next	1.60;

1.60
date	2002.04.01.07.39.09;	author matz;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.19.09.03.07;	author matz;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.14.06.23.44;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.13.09.01.09;	author matz;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.01.06.02.59;	author matz;	state Exp;
branches;
next	1.55;

1.55
date	2002.01.11.09.18.50;	author matz;	state Exp;
branches;
next	1.54;

1.54
date	2002.01.04.14.14.35;	author matz;	state Exp;
branches;
next	1.53;

1.53
date	2001.12.21.09.23.21;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2001.12.11.03.48.08;	author matz;	state Exp;
branches;
next	1.51;

1.51
date	2001.11.19.05.03.03;	author matz;	state Exp;
branches;
next	1.50;

1.50
date	2001.10.05.06.30.42;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2001.10.05.03.04.52;	author nobu;	state Exp;
branches;
next	1.48;

1.48
date	2001.10.03.07.19.10;	author matz;	state Exp;
branches;
next	1.47;

1.47
date	2001.10.02.04.31.19;	author matz;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.20.06.23.50;	author nobu;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.05.06.54.53;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.24.09.07.33;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2001.05.30.09.12.34;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.16.09.05.50;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.02.04.22.11;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2001.02.08.09.19.17;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2001.02.02.11.38.11;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.29.05.10.42;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.15.07.00.54;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.13.10.47.12;	author eban;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.09.07.26.17;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.20.07.31.45;	author matz;	state Exp;
branches
	1.34.2.1
	1.34.4.1;
next	1.33;

1.33
date	2000.10.10.07.03.23;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.01.09.18.11;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.28.09.53.29;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.14.07.18.58;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.01.06.46.37;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.22.08.29.46;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.19.08.38.09;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.16.07.44.04;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.14.05.30.22;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.13.09.42.40;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.12.07.48.21;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.30.04.24.02;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.05.24.07.36.46;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.24.04.34.07;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.23.15.36.43;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.22.07.29.50;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.22.07.09.55;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.18.04.32.06;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.17.06.33.49;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.01.09.41.28;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.10.05.44.18;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.07.08.37.45;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.23.05.23.07;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.08.08.48.54;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.05.04.37.11;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.12.14.06.49.51;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.12.01.09.24.13;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.11.17.07.30.34;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.11.04.08.39.37;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.10.15.08.52.17;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.09.16.09.40.32;	author matz;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.08.13.05.45.13;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.11;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.25;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.14;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.01.07.34.57;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.05.10.27.32;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.02.09.06.08.23;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.02.24.04.31.24;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.02.25.06.39.10;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.03.24.08.52.31;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.04.20.08.21.40;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.05.06.08.31.43;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.05.25.08.26.13;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.06.11.06.29.57;	author matz;	state Exp;
branches;
next	1.1.1.3.2.12;

1.1.1.3.2.12
date	99.06.25.09.02.45;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.20.04.16.43;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.02.03.10.02.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.02.09.10.56.22;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.02.18.01.56.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.02.20.08.28.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.02.23.05.36.39;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.03.05.06.37.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.03.09.07.56.57;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.03.11.07.32.59;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.04.02.10.03.50;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.04.08.08.12.38;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.04.09.09.30.23;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.04.09.09.58.00;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.04.09.10.10.09;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.04.13.06.06.12;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.05.01.08.56.35;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.05.06.03.08.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.05.08.09.38.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.05.18.04.56.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.05.25.04.57.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.05.25.09.42.32;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.06.01.04.23.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.06.02.10.05.30;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	98.06.03.09.06.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.26;

1.1.1.2.2.26
date	98.06.26.07.19.01;	author matz;	state Exp;
branches;
next	1.1.1.2.2.27;

1.1.1.2.2.27
date	98.06.26.09.44.32;	author matz;	state Exp;
branches;
next	1.1.1.2.2.28;

1.1.1.2.2.28
date	98.07.13.04.37.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.29;

1.1.1.2.2.29
date	98.07.24.04.32.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.30;

1.1.1.2.2.30
date	98.08.27.03.55.26;	author matz;	state Exp;
branches;
next	1.1.1.2.2.31;

1.1.1.2.2.31
date	98.09.03.07.43.37;	author matz;	state Exp;
branches
	1.1.1.2.2.31.2.1;
next	1.1.1.2.2.32;

1.1.1.2.2.32
date	98.11.09.09.11.50;	author matz;	state Exp;
branches;
next	1.1.1.2.2.33;

1.1.1.2.2.33
date	99.04.09.18.04.08;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.31.2.1
date	98.09.08.07.09.04;	author matz;	state Exp;
branches;
next	1.1.1.2.2.31.2.2;

1.1.1.2.2.31.2.2
date	98.11.25.03.31.16;	author matz;	state Exp;
branches;
next	1.1.1.2.2.31.2.3;

1.1.1.2.2.31.2.3
date	98.12.22.09.01.53;	author matz;	state Exp;
branches;
next	;

1.3.2.1
date	99.11.17.07.29.52;	author matz;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	99.12.01.09.24.46;	author matz;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2000.01.17.08.24.11;	author matz;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2000.05.01.09.42.30;	author matz;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2000.06.13.09.50.48;	author matz;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2000.06.14.04.19.22;	author eban;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2000.07.01.06.47.47;	author matz;	state Exp;
branches;
next	1.3.2.8;

1.3.2.8
date	2000.07.24.07.16.14;	author matz;	state Exp;
branches;
next	;

1.34.2.1
date	2001.01.13.10.18.04;	author eban;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2001.01.15.07.33.12;	author matz;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2001.02.08.09.17.57;	author matz;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2001.08.17.05.06.11;	author matz;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2001.10.05.06.27.46;	author matz;	state Exp;
branches;
next	1.34.2.6;

1.34.2.6
date	2001.12.21.09.20.54;	author matz;	state Exp;
branches;
next	1.34.2.7;

1.34.2.7
date	2001.12.25.15.09.05;	author matz;	state Exp;
branches;
next	1.34.2.8;

1.34.2.8
date	2002.01.16.09.22.39;	author matz;	state Exp;
branches;
next	1.34.2.9;

1.34.2.9
date	2002.02.01.06.01.49;	author matz;	state Exp;
branches;
next	1.34.2.10;

1.34.2.10
date	2002.02.13.09.02.15;	author matz;	state Exp;
branches;
next	1.34.2.11;

1.34.2.11
date	2002.03.14.06.21.38;	author matz;	state Exp;
branches;
next	1.34.2.12;

1.34.2.12
date	2002.03.19.09.02.04;	author matz;	state Exp;
branches;
next	1.34.2.13;

1.34.2.13
date	2002.04.01.07.40.39;	author matz;	state Exp;
branches;
next	1.34.2.14;

1.34.2.14
date	2002.05.01.09.37.59;	author matz;	state Exp;
branches;
next	1.34.2.15;

1.34.2.15
date	2002.05.14.06.08.44;	author matz;	state Exp;
branches;
next	1.34.2.16;

1.34.2.16
date	2002.07.11.08.24.54;	author matz;	state Exp;
branches;
next	1.34.2.17;

1.34.2.17
date	2002.08.19.05.59.05;	author matz;	state Exp;
branches;
next	1.34.2.18;

1.34.2.18
date	2002.08.21.08.31.25;	author matz;	state Exp;
branches;
next	1.34.2.19;

1.34.2.19
date	2002.10.26.15.57.24;	author knu;	state Exp;
branches;
next	;

1.34.4.1
date	2001.01.12.04.36.00;	author matz;	state Exp;
branches;
next	1.34.4.2;

1.34.4.2
date	2001.03.05.03.37.34;	author matz;	state Exp;
branches;
next	1.34.4.3;

1.34.4.3
date	2002.07.09.05.26.49;	author matz;	state Exp;
branches;
next	;


desc
@@


1.83
log
@* dir.c (glob_helper): must not closedir() when exception raised
  while globbing "**".

* marshal.c (w_uclass): unused variable.

* re.c (match_clone): unused.

* regex.c (re_compile_pattern): get rid of implicit promotion from
  plain char to int.
@
text
@/**********************************************************************

  re.c -

  $Author: aamine $
  created at: Mon Aug  9 18:24:49 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto

**********************************************************************/

#include "ruby.h"
#include "re.h"
#include <ctype.h>

static VALUE rb_eRegexpError;

#define BEG(no) regs->beg[no]
#define END(no) regs->end[no]

#if 'a' == 97   /* it's ascii */
static const char casetable[] = {
        '\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
        '\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
        '\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
        '\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
        /* ' '     '!'     '"'     '#'     '$'     '%'     '&'     ''' */
        '\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
        /* '('     ')'     '*'     '+'     ','     '-'     '.'     '/' */
        '\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
        /* '0'     '1'     '2'     '3'     '4'     '5'     '6'     '7' */
        '\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
        /* '8'     '9'     ':'     ';'     '<'     '='     '>'     '?' */
        '\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
        /* '@@'     'A'     'B'     'C'     'D'     'E'     'F'     'G' */
        '\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
        /* 'H'     'I'     'J'     'K'     'L'     'M'     'N'     'O' */
        '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
        /* 'P'     'Q'     'R'     'S'     'T'     'U'     'V'     'W' */
        '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
        /* 'X'     'Y'     'Z'     '['     '\'     ']'     '^'     '_' */
        '\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
        /* '`'     'a'     'b'     'c'     'd'     'e'     'f'     'g' */
        '\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
        /* 'h'     'i'     'j'     'k'     'l'     'm'     'n'     'o' */
        '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
        /* 'p'     'q'     'r'     's'     't'     'u'     'v'     'w' */
        '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
        /* 'x'     'y'     'z'     '{'     '|'     '}'     '~' */
        '\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
        '\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
        '\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
        '\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
        '\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
        '\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
        '\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
        '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
        '\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
        '\300', '\301', '\302', '\303', '\304', '\305', '\306', '\307',
        '\310', '\311', '\312', '\313', '\314', '\315', '\316', '\317',
        '\320', '\321', '\322', '\323', '\324', '\325', '\326', '\327',
        '\330', '\331', '\332', '\333', '\334', '\335', '\336', '\337',
        '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
        '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
        '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
        '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
};
#else
# error >>> "You lose. You will need a translation table for your character set." <<<
#endif

#define MIN(a,b) (((a)>(b))?(b):(a))

int
rb_memcicmp(p1, p2, len)
    char *p1, *p2;
    long len;
{
    int tmp;

    while (len--) {
	if (tmp = casetable[(unsigned)*p1++] - casetable[(unsigned)*p2++])
	    return tmp;
    }
    return 0;
}

int
rb_memcmp(p1, p2, len)
    char *p1, *p2;
    long len;
{
    if (!ruby_ignorecase) {
	return memcmp(p1, p2, len);
    }
    return rb_memcicmp(p1, p2, len);
}

#define REG_CASESTATE  FL_USER0
#define KCODE_NONE  0
#define KCODE_EUC   FL_USER1
#define KCODE_SJIS  FL_USER2
#define KCODE_UTF8  FL_USER3
#define KCODE_FIXED FL_USER4
#define KCODE_MASK (KCODE_EUC|KCODE_SJIS|KCODE_UTF8)

static int reg_kcode = DEFAULT_KCODE;

static void
kcode_euc(re)
    struct RRegexp *re;
{
    FL_UNSET(re, KCODE_MASK);
    FL_SET(re, KCODE_EUC);
    FL_SET(re, KCODE_FIXED);
}

static void
kcode_sjis(re)
    struct RRegexp *re;
{
    FL_UNSET(re, KCODE_MASK);
    FL_SET(re, KCODE_SJIS);
    FL_SET(re, KCODE_FIXED);
}

static void
kcode_utf8(re)
    struct RRegexp *re;
{
    FL_UNSET(re, KCODE_MASK);
    FL_SET(re, KCODE_UTF8);
    FL_SET(re, KCODE_FIXED);
}

static void
kcode_none(re)
    struct RRegexp *re;
{
    FL_UNSET(re, KCODE_MASK);
    FL_SET(re, KCODE_FIXED);
}

static int curr_kcode;

static void
kcode_set_option(re)
    VALUE re;
{
    if (!FL_TEST(re, KCODE_FIXED)) return;

    curr_kcode = RBASIC(re)->flags & KCODE_MASK;
    if (reg_kcode == curr_kcode) return;
    switch (curr_kcode) {
      case KCODE_NONE:
	re_mbcinit(MBCTYPE_ASCII);
	break;
      case KCODE_EUC:
	re_mbcinit(MBCTYPE_EUC);
	break;
      case KCODE_SJIS:
	re_mbcinit(MBCTYPE_SJIS);
	break;
      case KCODE_UTF8:
	re_mbcinit(MBCTYPE_UTF8);
	break;
    }
}	  

static void
kcode_reset_option()
{
    if (reg_kcode == curr_kcode) return;
    switch (reg_kcode) {
      case KCODE_NONE:
	re_mbcinit(MBCTYPE_ASCII);
	break;
      case KCODE_EUC:
	re_mbcinit(MBCTYPE_EUC);
	break;
      case KCODE_SJIS:
	re_mbcinit(MBCTYPE_SJIS);
	break;
      case KCODE_UTF8:
	re_mbcinit(MBCTYPE_UTF8);
	break;
    }
}

int
rb_reg_mbclen2(c, re)
    unsigned int c;
    VALUE re;
{
    int len;

    if (!FL_TEST(re, KCODE_FIXED))
	return mbclen(c);
    kcode_set_option(re);
    len = mbclen(c);
    kcode_reset_option();
    return len;
}

static void
rb_reg_check(re)
    VALUE re;
{
    if (!RREGEXP(re)->ptr || !RREGEXP(re)->str) {
	rb_raise(rb_eTypeError, "uninitialized Regexp");
    }
}

extern int ruby_in_compile;

static void
rb_reg_expr_str(str, s, len)
    VALUE str;
    const char *s;
    long len;
{
    const char *p, *pend;
    int need_escape = 0;

    p = s; pend = p + len;
    while (p<pend) {
	if (*p == '/' || (!ISPRINT(*p) && !ismbchar(*p))) {
	    need_escape = 1;
	    break;
	}
	p += mbclen(*p);
    }
    if (!need_escape) {
	rb_str_buf_cat(str, s, len);
    }
    else {
	p = s; 
	while (p<pend) {
	    if (*p == '\\') {
		int n = mbclen(p[1]) + 1;
		rb_str_buf_cat(str, p, n);
		p += n;
		continue;
	    }
	    else if (*p == '/') {
		char c = '\\';
		rb_str_buf_cat(str, &c, 1);
		rb_str_buf_cat(str, p, 1);
	    }
	    else if (ismbchar(*p)) {
	    	rb_str_buf_cat(str, p, mbclen(*p));
		p += mbclen(*p);
		continue;
	    }
	    else if (ISPRINT(*p)) {
		rb_str_buf_cat(str, p, 1);
	    }
	    else if (!ISSPACE(*p)) {
		char b[8];

		sprintf(b, "\\%03o", *p & 0377);
		rb_str_buf_cat(str, b, 4);
	    }
	    else {
		rb_str_buf_cat(str, p, 1);
	    }
	    p++;
	}
    }
}

static VALUE
rb_reg_desc(s, len, re)
    const char *s;
    long len;
    VALUE re;
{
    VALUE str = rb_str_buf_new2("/");

    rb_reg_expr_str(str, s, len);
    rb_str_buf_cat2(str, "/");
    if (re) {
	rb_reg_check(re);
	if (RREGEXP(re)->ptr->options & RE_OPTION_MULTILINE)
	    rb_str_buf_cat2(str, "m");
	if (RREGEXP(re)->ptr->options & RE_OPTION_IGNORECASE)
	    rb_str_buf_cat2(str, "i");
	if (RREGEXP(re)->ptr->options & RE_OPTION_EXTENDED)
	    rb_str_buf_cat2(str, "x");
	
	if (FL_TEST(re, KCODE_FIXED)) {
	    switch ((RBASIC(re)->flags & KCODE_MASK)) {
	      case KCODE_NONE:
		rb_str_buf_cat2(str, "n");
		break;
	      case KCODE_EUC:
		rb_str_buf_cat2(str, "e");
		break;
	      case KCODE_SJIS:
		rb_str_buf_cat2(str, "s");
		break;
	      case KCODE_UTF8:
		rb_str_buf_cat2(str, "u");
		break;
	    }
	}
    }
    OBJ_INFECT(str, re);
    return str;
}

static VALUE
rb_reg_source(re)
    VALUE re;
{
    VALUE str;

    rb_reg_check(re);
    str = rb_str_new(RREGEXP(re)->str,RREGEXP(re)->len);
    if (OBJ_TAINTED(re)) OBJ_TAINT(str);
    return str;
}

static VALUE
rb_reg_inspect(re)
    VALUE re;
{
    rb_reg_check(re);
    return rb_reg_desc(RREGEXP(re)->str, RREGEXP(re)->len, re);
}

static VALUE
rb_reg_to_s(re)
    VALUE re;
{
    int options;
    const int embeddable = RE_OPTION_MULTILINE|RE_OPTION_IGNORECASE|RE_OPTION_EXTENDED;
    long len;
    const char* ptr;
    VALUE str = rb_str_buf_new2("(?");

    rb_reg_check(re);

    options = RREGEXP(re)->ptr->options;
    ptr = RREGEXP(re)->str;
    len = RREGEXP(re)->len;
  again:
    if (len >= 4 && ptr[0] == '(' && ptr[1] == '?') {
	int err = 1;
	ptr += 2;
	if ((len -= 2) > 0) {
	    do {
		if (*ptr == 'm') {
		    options |= RE_OPTION_MULTILINE;
		}
		else if (*ptr == 'i') {
		    options |= RE_OPTION_IGNORECASE;
		}
		else if (*ptr == 'x') {
		    options |= RE_OPTION_EXTENDED;
		}
		else break;
		++ptr;
	    } while (--len > 0);
	}
	if (len > 1 && *ptr == '-') {
	    ++ptr;
	    --len;
	    do {
		if (*ptr == 'm') {
		    options &= ~RE_OPTION_MULTILINE;
		}
		else if (*ptr == 'i') {
		    options &= ~RE_OPTION_IGNORECASE;
		}
		else if (*ptr == 'x') {
		    options &= ~RE_OPTION_EXTENDED;
		}
		else break;
		++ptr;
	    } while (--len > 0);
	}
	if (*ptr == ')') {
	    --len;
	    ++ptr;
	    goto again;
	}
	if (*ptr == ':' && ptr[len-1] == ')') {
	    Regexp *rp;
	    kcode_set_option(re);
	    rp = ALLOC(Regexp);
	    MEMZERO((char *)rp, Regexp, 1);
	    err = re_compile_pattern(++ptr, len -= 2, rp) != 0;
	    kcode_reset_option();
	    re_free_pattern(rp);
	}
	if (err) {
	    options = RREGEXP(re)->ptr->options;
	    ptr = RREGEXP(re)->str;
	    len = RREGEXP(re)->len;
	}
    }

    if (options & RE_OPTION_MULTILINE) rb_str_buf_cat2(str, "m");
    if (options & RE_OPTION_IGNORECASE) rb_str_buf_cat2(str, "i");
    if (options & RE_OPTION_EXTENDED) rb_str_buf_cat2(str, "x");

    if ((options & embeddable) != embeddable) {
	rb_str_buf_cat2(str, "-");
	if (!(options & RE_OPTION_MULTILINE)) rb_str_buf_cat2(str, "m");
	if (!(options & RE_OPTION_IGNORECASE)) rb_str_buf_cat2(str, "i");
	if (!(options & RE_OPTION_EXTENDED)) rb_str_buf_cat2(str, "x");
    }

    rb_str_buf_cat2(str, ":");
    rb_reg_expr_str(str, ptr, len);
    rb_str_buf_cat2(str, ")");

    OBJ_INFECT(str, re);
    return str;
}

static void
rb_reg_raise(s, len, err, re)
    const char *s;
    long len;
    const char *err;
    VALUE re;
{
    VALUE desc = rb_reg_desc(s, len, re);

    if (ruby_in_compile)
	rb_compile_error("%s: %s", err, RSTRING(desc)->ptr);
    else
	rb_raise(rb_eRegexpError, "%s: %s", err, RSTRING(desc)->ptr);
}

static VALUE
rb_reg_casefold_p(re)
    VALUE re;
{
    rb_reg_check(re);
    if (RREGEXP(re)->ptr->options & RE_OPTION_IGNORECASE) return Qtrue;
    return Qfalse;
}

static VALUE
rb_reg_options_m(re)
    VALUE re;
{
    rb_reg_check(re);
    return INT2NUM(RREGEXP(re)->ptr->options);
}

static VALUE
rb_reg_kcode_m(re)
    VALUE re;
{
    char *kcode;

    if (FL_TEST(re, KCODE_FIXED)) {
	switch (RBASIC(re)->flags & KCODE_MASK) {
	  case KCODE_NONE:
	    kcode = "none"; break;
	  case KCODE_EUC:
	    kcode = "euc"; break;
	  case KCODE_SJIS:
	    kcode = "sjis"; break;
	  case KCODE_UTF8:
	    kcode = "utf8"; break;
	  default:
	    rb_bug("unknow kcode - should not happen");
	    break;
	}
	return rb_str_new2(kcode);
    }
    return Qnil;
}

static Regexp*
make_regexp(s, len, flags)
    const char *s;
    long len;
    int flags;
{
    Regexp *rp;
    char *err;

    /* Handle escaped characters first. */

    /* Build a copy of the string (in dest) with the
       escaped characters translated,  and generate the regex
       from that.
    */

    rp = ALLOC(Regexp);
    MEMZERO((char *)rp, Regexp, 1);
    rp->buffer = ALLOC_N(char, 16);
    rp->allocated = 16;
    rp->fastmap = ALLOC_N(char, 256);
    if (flags) {
	rp->options = flags;
    }
    err = re_compile_pattern(s, len, rp);

    if (err != NULL) {
	rb_reg_raise(s, len, err, 0);
    }
    return rp;
}

static VALUE rb_cMatch;

static VALUE
match_alloc(klass)
    VALUE klass;
{
    NEWOBJ(match, struct RMatch);
    OBJSETUP(match, klass, T_MATCH);

    match->str = 0;
    match->regs = 0;
    match->regs = ALLOC(struct re_registers);
    MEMZERO(match->regs, struct re_registers, 1);

    return (VALUE)match;
}

static VALUE
match_become(obj, orig)
    VALUE obj, orig;
{
    if (obj == orig) return obj;

    if (!rb_obj_is_instance_of(orig, rb_obj_class(obj))) {
	rb_raise(rb_eTypeError, "wrong argument class");
    }
    RMATCH(obj)->str = RMATCH(orig)->str;
    re_free_registers(RMATCH(obj)->regs);
    RMATCH(obj)->regs->allocated = 0;
    re_copy_registers(RMATCH(obj)->regs, RMATCH(orig)->regs);

    return obj;
}

static VALUE
match_size(match)
    VALUE match;
{
    return INT2FIX(RMATCH(match)->regs->num_regs);
}

static VALUE
match_offset(match, n)
    VALUE match, n;
{
    int i = NUM2INT(n);

    if (i < 0 || RMATCH(match)->regs->num_regs <= i)
	rb_raise(rb_eIndexError, "index %d out of matches", i);

    if (RMATCH(match)->regs->beg[i] < 0)
	return rb_assoc_new(Qnil, Qnil);

    return rb_assoc_new(INT2FIX(RMATCH(match)->regs->beg[i]),
			INT2FIX(RMATCH(match)->regs->end[i]));
}

static VALUE
match_begin(match, n)
    VALUE match, n;
{
    int i = NUM2INT(n);

    if (i < 0 || RMATCH(match)->regs->num_regs <= i)
	rb_raise(rb_eIndexError, "index %d out of matches", i);

    if (RMATCH(match)->regs->beg[i] < 0)
	return Qnil;

    return INT2FIX(RMATCH(match)->regs->beg[i]);
}

static VALUE
match_end(match, n)
    VALUE match, n;
{
    int i = NUM2INT(n);

    if (i < 0 || RMATCH(match)->regs->num_regs <= i)
	rb_raise(rb_eIndexError, "index %d out of matches", i);

    if (RMATCH(match)->regs->beg[i] < 0)
	return Qnil;

    return INT2FIX(RMATCH(match)->regs->end[i]);
}

#define MATCH_BUSY FL_USER2

void
rb_match_busy(match)
    VALUE match;
{
    FL_SET(match, MATCH_BUSY);
}

int ruby_ignorecase;
static int may_need_recompile;

static void
rb_reg_prepare_re(re)
    VALUE re;
{
    int need_recompile = 0;
    int state;

    rb_reg_check(re);
    state = FL_TEST(re, REG_CASESTATE);
    /* ignorecase status */
    if (ruby_ignorecase && !state) {
	FL_SET(re, REG_CASESTATE);
	RREGEXP(re)->ptr->options |= RE_OPTION_IGNORECASE;
	need_recompile = 1;
    }
    if (!ruby_ignorecase && state) {
	FL_UNSET(re, REG_CASESTATE);
	RREGEXP(re)->ptr->options &= ~RE_OPTION_IGNORECASE;
	need_recompile = 1;
    }

    if (!FL_TEST(re, KCODE_FIXED) &&
	(RBASIC(re)->flags & KCODE_MASK) != reg_kcode) {
	need_recompile = 1;
	RBASIC(re)->flags &= ~KCODE_MASK;
	RBASIC(re)->flags |= reg_kcode;
    }

    if (need_recompile) {
	char *err;

	if (FL_TEST(re, KCODE_FIXED))
	    kcode_set_option(re);
	rb_reg_check(re);
	RREGEXP(re)->ptr->fastmap_accurate = 0;
	err = re_compile_pattern(RREGEXP(re)->str, RREGEXP(re)->len, RREGEXP(re)->ptr);
	if (err != NULL) {
	    rb_reg_raise(RREGEXP(re)->str, RREGEXP(re)->len, err, re);
	}
    }
}

long
rb_reg_adjust_startpos(re, str, pos, reverse)
    VALUE re, str;
    long pos, reverse;
{
    long range;

    rb_reg_check(re);
    if (may_need_recompile) rb_reg_prepare_re(re);

    if (FL_TEST(re, KCODE_FIXED))
	kcode_set_option(re);
    else if (reg_kcode != curr_kcode)
	kcode_reset_option();

    if (reverse) {
	range = -pos;
    }
    else {
	range = RSTRING(str)->len - pos;
    }
    return re_adjust_startpos(RREGEXP(re)->ptr,
			      RSTRING(str)->ptr, RSTRING(str)->len,
			      pos, range);
}

long
rb_reg_search(re, str, pos, reverse)
    VALUE re, str;
    long pos, reverse;
{
    long result;
    VALUE match;
    static struct re_registers regs;
    long range;

    if (pos > RSTRING(str)->len || pos < 0) {
	rb_backref_set(Qnil);
	return -1;
    }

    rb_reg_check(re);
    if (may_need_recompile) rb_reg_prepare_re(re);

    if (FL_TEST(re, KCODE_FIXED))
	kcode_set_option(re);
    else if (reg_kcode != curr_kcode)
	kcode_reset_option();

    if (reverse) {
	range = -pos;
    }
    else {
	range = RSTRING(str)->len - pos;
    }
    result = re_search(RREGEXP(re)->ptr,RSTRING(str)->ptr,RSTRING(str)->len,
		       pos, range, &regs);

    if (FL_TEST(re, KCODE_FIXED))
	kcode_reset_option();

    if (result == -2) {
	rb_reg_raise(RREGEXP(re)->str, RREGEXP(re)->len,
		     "Stack overflow in regexp matcher", re);
    }

    if (result < 0) {
	rb_backref_set(Qnil);
	return result;
    }

    match = rb_backref_get();
    if (NIL_P(match) || FL_TEST(match, MATCH_BUSY)) {
	match = match_alloc(rb_cMatch);
    }
    else {
	if (rb_safe_level() >= 3) 
	    OBJ_TAINT(match);
	else
	    FL_UNSET(match, FL_TAINT);
    }

    re_copy_registers(RMATCH(match)->regs, &regs);
    RMATCH(match)->str = rb_str_new4(str);
    rb_backref_set(match);

    OBJ_INFECT(match, re);
    OBJ_INFECT(match, str);
    return result;
}

VALUE
rb_reg_nth_defined(nth, match)
    int nth;
    VALUE match;
{
    if (NIL_P(match)) return Qnil;
    if (nth >= RMATCH(match)->regs->num_regs) {
	return Qnil;
    }
    if (nth < 0) {
	nth += RMATCH(match)->regs->num_regs;
	if (nth <= 0) return Qnil;
    }
    if (RMATCH(match)->BEG(nth) == -1) return Qfalse;
    return Qtrue;
}

VALUE
rb_reg_nth_match(nth, match)
    int nth;
    VALUE match;
{
    VALUE str;
    long start, end, len;

    if (NIL_P(match)) return Qnil;
    if (nth >= RMATCH(match)->regs->num_regs) {
	return Qnil;
    }
    if (nth < 0) {
	nth += RMATCH(match)->regs->num_regs;
	if (nth <= 0) return Qnil;
    }
    start = RMATCH(match)->BEG(nth);
    if (start == -1) return Qnil;
    end = RMATCH(match)->END(nth);
    len = end - start;
    str = rb_str_new(RSTRING(RMATCH(match)->str)->ptr + start, len);
    if (OBJ_TAINTED(match)) OBJ_TAINT(str);
    return str;
}

VALUE
rb_reg_last_match(match)
    VALUE match;
{
    return rb_reg_nth_match(0, match);
}

VALUE
rb_reg_match_pre(match)
    VALUE match;
{
    VALUE str;

    if (NIL_P(match)) return Qnil;
    if (RMATCH(match)->BEG(0) == -1) return Qnil;
    str = rb_str_new(RSTRING(RMATCH(match)->str)->ptr, RMATCH(match)->BEG(0));
    if (OBJ_TAINTED(match)) OBJ_TAINT(str);
    return str;
}

VALUE
rb_reg_match_post(match)
    VALUE match;
{
    VALUE str;

    if (NIL_P(match)) return Qnil;
    if (RMATCH(match)->BEG(0) == -1) return Qnil;
    str = rb_str_new(RSTRING(RMATCH(match)->str)->ptr+RMATCH(match)->END(0),
		     RSTRING(RMATCH(match)->str)->len-RMATCH(match)->END(0));
    if (OBJ_TAINTED(match)) OBJ_TAINT(str);
    return str;
}

VALUE
rb_reg_match_last(match)
    VALUE match;
{
    int i;

    if (NIL_P(match)) return Qnil;
    if (RMATCH(match)->BEG(0) == -1) return Qnil;

    for (i=RMATCH(match)->regs->num_regs-1; RMATCH(match)->BEG(i) == -1 && i > 0; i--)
	;
    if (i == 0) return Qnil;
    return rb_reg_nth_match(i, match);
}

static VALUE
last_match_getter()
{
    return rb_reg_last_match(rb_backref_get());
}

static VALUE
prematch_getter()
{
    return rb_reg_match_pre(rb_backref_get());
}

static VALUE
postmatch_getter()
{
    return rb_reg_match_post(rb_backref_get());
}

static VALUE
last_paren_match_getter()
{
    return rb_reg_match_last(rb_backref_get());
}

static VALUE
match_to_a(match)
    VALUE match;
{
    struct re_registers *regs = RMATCH(match)->regs;
    VALUE ary = rb_ary_new2(regs->num_regs);
    char *ptr = RSTRING(RMATCH(match)->str)->ptr;
    int i;
    int taint = OBJ_TAINTED(match);
    
    for (i=0; i<regs->num_regs; i++) {
	if (regs->beg[i] == -1) {
	    rb_ary_push(ary, Qnil);
	}
	else {
	    VALUE str = rb_str_new(ptr+regs->beg[i], regs->end[i]-regs->beg[i]);
	    if (taint) OBJ_TAINT(str);
	    rb_ary_push(ary, str);
	}
    }
    return ary;
}

static VALUE
match_aref(argc, argv, match)
    int argc;
    VALUE *argv;
    VALUE match;
{
    VALUE idx, rest;

    rb_scan_args(argc, argv, "11", &idx, &rest);

    if (!NIL_P(rest) || !FIXNUM_P(idx) || FIX2INT(idx) < 0) {
	return rb_ary_aref(argc, argv, match_to_a(match));
    }
    return rb_reg_nth_match(FIX2INT(idx), match);
}

static VALUE
match_select(argc, argv, match)
    int argc;
    VALUE *argv;
    VALUE match;
{
    struct re_registers *regs = RMATCH(match)->regs;
    char *ptr = RSTRING(RMATCH(match)->str)->ptr;
    VALUE result = rb_ary_new();
    int i;
    long idx;
    int taint = OBJ_TAINTED(match);

    for (i=0; i<argc; i++) {
	idx = NUM2LONG(argv[i]);
	if (idx < 0) idx += regs->num_regs;
	if (idx < 0 || regs->num_regs <= idx) {
	    rb_ary_push(result, Qnil);
	}
	else {
	    VALUE str = rb_str_new(ptr+regs->beg[idx], regs->end[idx]-regs->beg[idx]);
	    if (taint) OBJ_TAINT(str);
	    rb_ary_push(result, str);
	}
    }
    return result;
}

static VALUE
match_to_s(match)
    VALUE match;
{
    VALUE str = rb_reg_last_match(match);

    if (NIL_P(str)) str = rb_str_new(0,0);
    if (OBJ_TAINTED(match)) OBJ_TAINT(str);
    if (OBJ_TAINTED(RMATCH(match)->str)) OBJ_TAINT(str);
    return str;
}

static VALUE
match_string(match)
    VALUE match;
{
    return RMATCH(match)->str;	/* str is frozen */
}

VALUE rb_cRegexp;

static void
rb_reg_initialize(obj, s, len, options)
    VALUE obj;
    const char *s;
    long len;
    int options;		/* CASEFOLD  = 1 */
				/* EXTENDED  = 2 */
				/* MULTILINE = 4 */
				/* CODE_NONE = 16 */
				/* CODE_EUC  = 32 */
				/* CODE_SJIS = 48 */
				/* CODE_UTF8 = 64 */
{
    struct RRegexp *re = RREGEXP(obj);

    if (re->ptr) re_free_pattern(re->ptr);
    if (re->str) free(re->str);
    re->ptr = 0;
    re->str = 0;

    switch (options & ~0xf) {
      case 0:
      default:
	FL_SET(re, reg_kcode);
	break;
      case 16:
	kcode_none(re);
	break;
      case 32:
	kcode_euc(re);
	break;
      case 48:
	kcode_sjis(re);
	break;
      case 64:
	kcode_utf8(re);
	break;
    }

    if (options & ~0xf) {
	kcode_set_option((VALUE)re);
    }
    if (ruby_ignorecase) {
	options |= RE_OPTION_IGNORECASE;
	FL_SET(re, REG_CASESTATE);
    }
    re->ptr = make_regexp(s, len, options & 0xf);
    re->str = ALLOC_N(char, len+1);
    memcpy(re->str, s, len);
    re->str[len] = '\0';
    re->len = len;
    if (options & ~0xf) {
	kcode_reset_option();
    }
}

static VALUE
rb_reg_s_alloc(klass)
    VALUE klass;
{
    NEWOBJ(re, struct RRegexp);
    OBJSETUP(re, klass, T_REGEXP);

    re->ptr = 0;
    re->len = 0;
    re->str = 0;

    return (VALUE)re;
}

VALUE
rb_reg_new(s, len, options)
    const char *s;
    long len;
    int options;
{
    VALUE re = rb_reg_s_alloc(rb_cRegexp);

    rb_reg_initialize(re, s, len, options);
    return (VALUE)re;
}

static int case_cache;
static int kcode_cache;
static VALUE reg_cache;

VALUE
rb_reg_regcomp(str)
    VALUE str;
{
    if (reg_cache && RREGEXP(reg_cache)->len == RSTRING(str)->len
	&& case_cache == ruby_ignorecase
	&& kcode_cache == reg_kcode
	&& memcmp(RREGEXP(reg_cache)->str, RSTRING(str)->ptr, RSTRING(str)->len) == 0)
	return reg_cache;

    case_cache = ruby_ignorecase;
    kcode_cache = reg_kcode;
    return reg_cache = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
				  ruby_ignorecase);
}

static int
rb_reg_cur_kcode(re)
    VALUE re;
{
    if (FL_TEST(re, KCODE_FIXED)) {
	return RBASIC(re)->flags & KCODE_MASK;
    }
    return 0;
}

static VALUE
rb_reg_equal(re1, re2)
    VALUE re1, re2;
{
    if (re1 == re2) return Qtrue;
    if (TYPE(re2) != T_REGEXP) return Qfalse;
    rb_reg_check(re1); rb_reg_check(re2);
    if (RREGEXP(re1)->len != RREGEXP(re2)->len) return Qfalse;
    if (memcmp(RREGEXP(re1)->str, RREGEXP(re2)->str, RREGEXP(re1)->len) == 0 &&
	rb_reg_cur_kcode(re1) == rb_reg_cur_kcode(re2) &&
	RREGEXP(re1)->ptr->options == RREGEXP(re2)->ptr->options) {
	return Qtrue;
    }
    return Qfalse;
}

VALUE
rb_reg_match(re, str)
    VALUE re, str;
{
    long start;

    if (NIL_P(str)) {
	rb_backref_set(Qnil);
	return Qnil;
    }
    StringValue(str);
    start = rb_reg_search(re, str, 0, 0);
    if (start < 0) {
	return Qnil;
    }
    return LONG2FIX(start);
}

VALUE
rb_reg_match2(re)
    VALUE re;
{
    long start;
    VALUE line = rb_lastline_get();

    if (TYPE(line) != T_STRING) {
	rb_backref_set(Qnil);
	return Qnil;
    }

    start = rb_reg_search(re, line, 0, 0);
    if (start < 0) {
	return Qnil;
    }
    return LONG2FIX(start);
}

static VALUE
rb_reg_match_m(re, str)
    VALUE re, str;
{
    VALUE result = rb_reg_match(re, str);

    if (NIL_P(result)) return Qnil;
    result = rb_backref_get();
    rb_match_busy(result);
    return result;
}

static VALUE
rb_reg_initialize_m(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE src;
    int flags = 0;

    if (argc == 0 || argc > 3) {
	rb_raise(rb_eArgError, "wrong number of argument");
    }
    if (argc >= 2) {
	if (FIXNUM_P(argv[1])) flags = FIX2INT(argv[1]);
	else if (RTEST(argv[1])) flags = RE_OPTION_IGNORECASE;
    }
    if (argc == 3) {
	char *kcode = StringValuePtr(argv[2]);

	switch (kcode[0]) {
	  case 'n': case 'N':
	    flags |= 16;
	    break;
	  case 'e': case 'E':
	    flags |= 32;
	    break;
	  case 's': case 'S':
	    flags |= 48;
	    break;
	  case 'u': case 'U':
	    flags |= 64;
	    break;
	  default:
	    break;
	}
    }

    rb_check_frozen(self);
    src = argv[0];
    if (TYPE(src) == T_REGEXP) {
	rb_reg_check(src);
	rb_reg_initialize(self, RREGEXP(src)->str, RREGEXP(src)->len, flags);
    }
    else {
	StringValue(src);
	rb_reg_initialize(self, RSTRING(src)->ptr, RSTRING(src)->len, flags);
    }
    return self;
}

VALUE
rb_reg_quote(str)
    VALUE str;
{
    char *s, *send, *t;
    VALUE tmp;
    int c;

    s = RSTRING(str)->ptr;
    send = s + RSTRING(str)->len;
    for (; s < send; s++) {
	c = *s;
	if (ismbchar(c)) {
	    int n = mbclen(c);

	    while (n-- && s < send)
		s++;
	    s--;
	    continue;
	}
	switch (c) {
	  case '[': case ']': case '{': case '}':
	  case '(': case ')': case '|': case '-':
	  case '*': case '.': case '\\':
	  case '?': case '+': case '^': case '$':
	  case ' ': case '#':
	    goto meta_found;
	}
    }
    return str;

  meta_found:
    tmp = rb_str_new(0, RSTRING(str)->len*2);
    t = RSTRING(tmp)->ptr;
    /* copy upto metacharacter */
    memcpy(t, RSTRING(str)->ptr, s - RSTRING(str)->ptr);
    t += s - RSTRING(str)->ptr;

    for (; s < send; s++) {
	c = *s;
	if (ismbchar(c)) {
	    int n = mbclen(c);

	    while (n-- && s < send)
		*t++ = *s++;
	    s--;
	    continue;
	}
	switch (c) {
	  case '[': case ']': case '{': case '}':
	  case '(': case ')': case '|': case '-':
	  case '*': case '.': case '\\':
	  case '?': case '+': case '^': case '$':
	  case ' ': case '#':
	    *t++ = '\\';
	    break;
	}
	*t++ = c;
    }
    rb_str_resize(tmp, t - RSTRING(tmp)->ptr);
    OBJ_INFECT(tmp, str);
    return tmp;
}

static VALUE
rb_reg_s_quote(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE str, kcode;
    int kcode_saved = reg_kcode;

    rb_scan_args(argc, argv, "11", &str, &kcode);
    if (!NIL_P(kcode)) {
	rb_set_kcode(StringValuePtr(kcode));
	curr_kcode = reg_kcode;
	reg_kcode = kcode_saved;
    }
    StringValue(str);
    str = rb_reg_quote(str);
    kcode_reset_option();
    return str;
}

int
rb_kcode()
{
    switch (reg_kcode) {
      case KCODE_EUC:
	return MBCTYPE_EUC;
      case KCODE_SJIS:
	return MBCTYPE_SJIS;
      case KCODE_UTF8:
	return MBCTYPE_UTF8;
      case KCODE_NONE:
	return MBCTYPE_ASCII;
    }
    rb_bug("wrong reg_kcode value (0x%x)", reg_kcode);
}

static int
rb_reg_get_kcode(re)
    VALUE re;
{
    switch (RBASIC(re)->flags & KCODE_MASK) {
      case KCODE_NONE:
	return 16;
      case KCODE_EUC:
	return 32;
      case KCODE_SJIS:
	return 48;
      case KCODE_UTF8:
	return 64;
      default:
	return 0;
    }
}

int
rb_reg_options(re)
    VALUE re;
{
    int options = 0;

    rb_reg_check(re);
    if (RREGEXP(re)->ptr->options & RE_OPTION_IGNORECASE)
	options |= RE_OPTION_IGNORECASE;
    if (RREGEXP(re)->ptr->options & RE_OPTION_MULTILINE)
	options |= RE_OPTION_MULTILINE;
    if (RREGEXP(re)->ptr->options & RE_OPTION_EXTENDED)
	options |= RE_OPTION_EXTENDED;
    if (FL_TEST(re, KCODE_FIXED)) {
	options |= rb_reg_get_kcode(re);
    }
    return options;
}

static VALUE
rb_reg_become(copy, re)
    VALUE copy, re;
{
    if (copy == re) return copy;
    rb_check_frozen(copy);
    /* need better argument type check */
    if (!rb_obj_is_instance_of(re, rb_obj_class(copy))) {
	rb_raise(rb_eTypeError, "wrong argument type");
    }
    RREGEXP(copy)->ptr = 0;
    RREGEXP(copy)->len = 0;
    RREGEXP(copy)->str = 0;
    rb_reg_check(re);
    rb_reg_initialize(copy, RREGEXP(re)->str, RREGEXP(re)->len,
		      rb_reg_options(re));
    return copy;
}

VALUE
rb_reg_regsub(str, src, regs)
    VALUE str, src;
    struct re_registers *regs;
{
    VALUE val = 0;
    char *p, *s, *e, c;
    int no;

    p = s = RSTRING(str)->ptr;
    e = s + RSTRING(str)->len;

    while (s < e) {
	char *ss = s;

	c = *s++;
	if (ismbchar(c)) {
	    s += mbclen(c) - 1;
	    continue;
	}
	if (c != '\\' || s == e) continue;

	if (!val) {
	    val = rb_str_buf_new(ss-p);
	    rb_str_buf_cat(val, p, ss-p);
	}
	else {
	    rb_str_buf_cat(val, p, ss-p);
	}

	c = *s++;
	p = s;
	switch (c) {
	  case '0': case '1': case '2': case '3': case '4':
	  case '5': case '6': case '7': case '8': case '9':
	    no = c - '0';
	    break;
	  case '&':
	    no = 0;
	    break;

	  case '`':
	    rb_str_buf_cat(val, RSTRING(src)->ptr, BEG(0));
	    continue;

	  case '\'':
	    rb_str_buf_cat(val, RSTRING(src)->ptr+END(0), RSTRING(src)->len-END(0));
	    continue;

	  case '+':
	    no = regs->num_regs-1;
	    while (BEG(no) == -1 && no > 0) no--;
	    if (no == 0) continue;
	    break;

	  case '\\':
	    rb_str_buf_cat(val, s-1, 1);
	    continue;

	  default:
	    rb_str_buf_cat(val, s-2, 2);
	    continue;
	}

	if (no >= 0) {
	    if (no >= regs->num_regs) continue;
	    if (BEG(no) == -1) continue;
	    rb_str_buf_cat(val, RSTRING(src)->ptr+BEG(no), END(no)-BEG(no));
	}
    }

    if (p < e) {
	if (!val) {
	    val = rb_str_buf_new(e-p);
	    rb_str_buf_cat(val, p, e-p);
	}
	else {
	    rb_str_buf_cat(val, p, e-p);
	}
    }
    if (!val) return str;

    return val;
}

const char*
rb_get_kcode()
{
    switch (reg_kcode) {
      case KCODE_SJIS:
	return "SJIS";
      case KCODE_EUC:
	return "EUC";
      case KCODE_UTF8:
	return "UTF8";
      default:
	return "NONE";
    }
}

static VALUE
kcode_getter()
{
    return rb_str_new2(rb_get_kcode());
}

void
rb_set_kcode(code)
    const char *code;
{
    if (code == 0) goto set_no_conversion;

    switch (code[0]) {
      case 'E':
      case 'e':
	reg_kcode = KCODE_EUC;
	re_mbcinit(MBCTYPE_EUC);
	break;
      case 'S':
      case 's':
	reg_kcode = KCODE_SJIS;
	re_mbcinit(MBCTYPE_SJIS);
	break;
      case 'U':
      case 'u':
	reg_kcode = KCODE_UTF8;
	re_mbcinit(MBCTYPE_UTF8);
	break;
      default:
      case 'N':
      case 'n':
      case 'A':
      case 'a':
      set_no_conversion:
	reg_kcode = KCODE_NONE;
	re_mbcinit(MBCTYPE_ASCII);
	break;
    }
}

static void
kcode_setter(val)
    VALUE val;
{
    may_need_recompile = 1;
    rb_set_kcode(StringValuePtr(val));
}

static VALUE
ignorecase_getter()
{
    return ruby_ignorecase?Qtrue:Qfalse;
}

static void
ignorecase_setter(val, id)
    VALUE val;
    ID id;
{
    rb_warn("modifying %s is deperecated", rb_id2name(id));
    may_need_recompile = 1;
    ruby_ignorecase = RTEST(val);
}

static VALUE
match_getter()
{
    VALUE match = rb_backref_get();

    if (NIL_P(match)) return Qnil;
    rb_match_busy(match);
    return match;
}

static void
match_setter(val)
    VALUE val;
{
    if (!NIL_P(val)) {
	Check_Type(val, T_MATCH);
    }
    rb_backref_set(val);
}

static VALUE
rb_reg_s_last_match(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE nth;

    if (rb_scan_args(argc, argv, "01", &nth) == 1) {
	return rb_reg_nth_match(NUM2INT(nth), rb_backref_get());
    }
    return match_getter();
}

void
Init_Regexp()
{
    rb_eRegexpError = rb_define_class("RegexpError", rb_eStandardError);

    re_set_casetable(casetable);
#if DEFAULT_KCODE == KCODE_EUC
    re_mbcinit(MBCTYPE_EUC);
#else
#if DEFAULT_KCODE == KCODE_SJIS
    re_mbcinit(MBCTYPE_SJIS);
#else
#if DEFAULT_KCODE == KCODE_UTF8
    re_mbcinit(MBCTYPE_UTF8);
#else
    re_mbcinit(MBCTYPE_ASCII);
#endif
#endif
#endif

    rb_define_virtual_variable("$~", match_getter, match_setter);
    rb_define_virtual_variable("$&", last_match_getter, 0);
    rb_define_virtual_variable("$`", prematch_getter, 0);
    rb_define_virtual_variable("$'", postmatch_getter, 0);
    rb_define_virtual_variable("$+", last_paren_match_getter, 0);

    rb_define_virtual_variable("$=", ignorecase_getter, ignorecase_setter);
    rb_define_virtual_variable("$KCODE", kcode_getter, kcode_setter);
    rb_define_virtual_variable("$-K", kcode_getter, kcode_setter);

    rb_cRegexp = rb_define_class("Regexp", rb_cObject);
    rb_define_singleton_method(rb_cRegexp, "allocate", rb_reg_s_alloc, 0);
    rb_define_singleton_method(rb_cRegexp, "compile", rb_class_new_instance, -1);
    rb_define_singleton_method(rb_cRegexp, "quote", rb_reg_s_quote, -1);
    rb_define_singleton_method(rb_cRegexp, "escape", rb_reg_s_quote, -1);
    rb_define_singleton_method(rb_cRegexp, "last_match", rb_reg_s_last_match, -1);

    rb_define_method(rb_cRegexp, "initialize", rb_reg_initialize_m, -1);
    rb_define_method(rb_cRegexp, "become", rb_reg_become, 1);
    rb_define_method(rb_cRegexp, "==", rb_reg_equal, 1);
    rb_define_method(rb_cRegexp, "=~", rb_reg_match, 1);
    rb_define_method(rb_cRegexp, "===", rb_reg_match, 1);
    rb_define_method(rb_cRegexp, "~", rb_reg_match2, 0);
    rb_define_method(rb_cRegexp, "match", rb_reg_match_m, 1);
    rb_define_method(rb_cRegexp, "to_s", rb_reg_to_s, 0);
    rb_define_method(rb_cRegexp, "inspect", rb_reg_inspect, 0);
    rb_define_method(rb_cRegexp, "source", rb_reg_source, 0);
    rb_define_method(rb_cRegexp, "casefold?", rb_reg_casefold_p, 0);
    rb_define_method(rb_cRegexp, "options", rb_reg_options_m, 0);
    rb_define_method(rb_cRegexp, "kcode", rb_reg_kcode_m, 0);

    rb_define_const(rb_cRegexp, "IGNORECASE", INT2FIX(RE_OPTION_IGNORECASE));
    rb_define_const(rb_cRegexp, "EXTENDED", INT2FIX(RE_OPTION_EXTENDED));
    rb_define_const(rb_cRegexp, "MULTILINE", INT2FIX(RE_OPTION_MULTILINE));

    rb_global_variable(&reg_cache);

    rb_cMatch  = rb_define_class("MatchData", rb_cObject);
    rb_define_global_const("MatchingData", rb_cMatch);
    rb_define_singleton_method(rb_cMatch, "allocate", match_alloc, 0);
    rb_undef_method(CLASS_OF(rb_cMatch), "new");

    rb_define_method(rb_cMatch, "become", match_become, 1);
    rb_define_method(rb_cMatch, "size", match_size, 0);
    rb_define_method(rb_cMatch, "length", match_size, 0);
    rb_define_method(rb_cMatch, "offset", match_offset, 1);
    rb_define_method(rb_cMatch, "begin", match_begin, 1);
    rb_define_method(rb_cMatch, "end", match_end, 1);
    rb_define_method(rb_cMatch, "to_a", match_to_a, 0);
    rb_define_method(rb_cMatch, "to_ary", match_to_a, 0);
    rb_define_method(rb_cMatch, "[]", match_aref, -1);
    rb_define_method(rb_cMatch, "select", match_select, -1);
    rb_define_method(rb_cMatch, "pre_match", rb_reg_match_pre, 0);
    rb_define_method(rb_cMatch, "post_match", rb_reg_match_post, 0);
    rb_define_method(rb_cMatch, "to_s", match_to_s, 0);
    rb_define_method(rb_cMatch, "inspect", rb_any_to_s, 0);
    rb_define_method(rb_cMatch, "string", match_string, 0);
}
@


1.82
log
@* io.c: add parameter prototype.
* re.c: ditto.
@
text
@d5 1
a5 1
  $Author: matz $
a526 17
}

static VALUE
match_clone(match)
    VALUE match;
{
    NEWOBJ(clone, struct RMatch);
    CLONESETUP(clone, match);

    clone->str = RMATCH(match)->str;
    clone->regs = 0;

    clone->regs = ALLOC(struct re_registers);
    clone->regs->allocated = 0;
    re_copy_registers(clone->regs, RMATCH(match)->regs);

    return (VALUE)clone;
@


1.81
log
@	* variable.c (rb_copy_generic_ivar): remove old generic instance
	  variable table if it existes.

	* class.c (rb_make_metaclass): metaclass of a metaclass is a
	  metaclass itself.
@
text
@d5 1
a5 1
  $Author: nobu $
d1330 1
a1330 1
    VALUE re;
@


1.80
log
@* re.c (rb_reg_search): MatchData must be rb_cMatch. (ruby-bugs-ja:PR#319)
@
text
@d5 1
a5 1
  $Author: michal $
d530 17
d1178 1
a1178 3
    if (OBJ_FROZEN(self)) {
	rb_error_frozen("Regexp");
    }
d1329 1
a1329 1
rb_reg_become(clone, re)
d1332 2
d1335 1
a1335 1
    if (!rb_obj_is_instance_of(re, rb_obj_class(clone))) {
d1338 3
a1340 3
    RREGEXP(clone)->ptr = 0;
    RREGEXP(clone)->len = 0;
    RREGEXP(clone)->str = 0;
d1342 1
a1342 1
    rb_reg_initialize(clone, RREGEXP(re)->str, RREGEXP(re)->len,
d1344 1
a1344 1
    return clone;
@


1.79
log
@re.c: match_become based on (ruby-core:382, :386, :389)
@
text
@d5 1
a5 1
  $Author: matz $
d240 3
a242 4
		rb_str_buf_cat(str, p, 1);
		p++;
	    	rb_str_buf_cat(str, p, mbclen(*p));
		p += mbclen(*p);
a252 1
		need_escape = 1;
d726 1
a726 1
	match = match_alloc(rb_obj_class(re));
@


1.78
log
@* array.c (rb_ary_become): should not free ptr if it's shared.

* eval.c (rb_alias): prohibit making an alias named "allocate" if
  klass is a metaclass.

* string.c (rb_string_value_ptr): StringValuePtr() should never
  return NULL pointer.
@
text
@d5 1
a5 1
  $Author: michal $
d517 2
a518 1
match_alloc()
d521 1
a521 1
    OBJSETUP(match, rb_cMatch, T_MATCH);
d532 2
a533 2
match_clone(match)
    VALUE match;
d535 1
a535 2
    NEWOBJ(clone, struct RMatch);
    CLONESETUP(clone, match);
d537 7
a543 6
    clone->str = RMATCH(match)->str;
    clone->regs = 0;

    clone->regs = ALLOC(struct re_registers);
    clone->regs->allocated = 0;
    re_copy_registers(clone->regs, RMATCH(match)->regs);
d545 1
a545 18
    return (VALUE)clone;
}

static VALUE
match_dup(match)
    VALUE match;
{
    NEWOBJ(dup, struct RMatch);
    DUPSETUP(dup, match);

    dup->str = RMATCH(match)->str;
    dup->regs = 0;

    dup->regs = ALLOC(struct re_registers);
    dup->regs->allocated = 0;
    re_copy_registers(dup->regs, RMATCH(match)->regs);

    return (VALUE)dup;
d728 1
a728 1
	match = match_alloc();
d1588 1
a1588 1
    rb_undef_method(CLASS_OF(rb_cMatch), "allocate");
d1591 1
a1591 4
    /* to be replaced by allocation framework */
    rb_define_method(rb_cMatch, "clone", match_clone, 0);
    rb_define_method(rb_cMatch, "dup", match_dup, 0);

@


1.77
log
@Int vs Long cleanup #3 (ruby-core:352)
@
text
@d5 1
a5 1
  $Author: matz $
d1336 1
a1336 1
    if (!rb_obj_is_kind_of(re, rb_obj_class(clone))) {
@


1.76
log
@* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.

* class.c (rb_mod_dup): need to preserve metaclass and flags.

* object.c (rb_cstr_to_dbl): had a buffer overrun.

* marshal.c (w_class): integrate singleton check into a funciton
  to follow DRY principle.

* marshal.c (w_uclass): should check singleton method.

* object.c (rb_obj_dup): dmark and dfree functions must be match
  for T_DATA type.

* object.c (rb_obj_dup): class of the duped object must be match
  to the class of the original.

* re.c (rb_reg_quote): do not escape \t, \f, \r, \n, for they are
  not regular expression metacharacters.

* time.c (time_s_alloc): use time_free instead of free (null check,
  also serves for type mark).

* time.c (time_s_at): check dfree function too.
@
text
@d5 1
a5 1
  $Author: michal $
d785 1
a785 1
    int start, end, len;
d1097 1
a1097 1
    int start;
d1108 1
a1108 1
    return INT2FIX(start);
d1115 1
a1115 1
    int start;
d1127 1
a1127 1
    return INT2FIX(start);
@


1.75
log
@*.c: Int vs Long cleanup
@
text
@d5 1
a5 1
  $Author: matz $
d548 17
a1214 1
	  case '\t': case '\f': case '\r': case '\n':
a1242 16
	  case '\t':
	    c = 't';
	    *t++ = '\\';
	    break;
	  case '\f':
	    c = 'f';
	    *t++ = '\\';
	    break;
	  case '\r':
	    c = 'r';
	    *t++ = '\\';
	    break;
	  case '\n':
	    c = 'n';
	    *t++ = '\\';
	    break;
d1332 1
a1332 1
rb_reg_clone(re)
d1335 4
a1338 2
    VALUE clone = rb_obj_clone(re);

d1583 1
a1583 1
    rb_define_method(rb_cRegexp, "clone", rb_reg_clone, 0);
d1607 1
d1609 2
@


1.74
log
@* io.c (rb_io_putc): output via rb_io_write().

* re.c (rb_reg_initialize_m): frozen check should be moved here
  from rb_reg_initialize().
@
text
@d69 1
a69 1
>>> "You lose. You will need a translation table for your character set." <<<
d220 1
a220 1
    int len;
d277 1
a277 1
    int len;
d428 1
a428 1
    int len;
d485 2
a486 1
    int len, flags;
d507 1
a510 1

d654 1
a654 1
int
d657 1
a657 1
    int pos, reverse;
d659 1
a659 1
    int range;
d680 1
a680 1
int
d683 1
a683 1
    int pos, reverse;
d685 1
a685 1
    int result;
d688 1
a688 1
    int range;
d952 1
a952 1
    int len;
@


1.73
log
@* array.c (sort_2): *a - *b may overflow.

* array.c (ary_new): len*sizeof(VALUE) may be a positive value.

* array.c (rb_ary_initialize): ditto.

* object.c (rb_class_allocate_instance): move singleton class
  check from rb_obj_alloc().

* re.c (rb_reg_initialize): should not modify frozen Regexp.

* ext/tcltklib/tcltklib.c (ip_init): allocation framework.
@
text
@a961 3
    if (OBJ_FROZEN(obj)) {
	rb_error_frozen("Regexp");
    }
d1161 3
@


1.72
log
@* numeric.c (num_to_int): default to_int implementaion for every
  numeric class.

* re.c (rb_reg_quote): initial part of the string was never copied
  to the quoted string.
@
text
@d962 3
@


1.71
log
@* random.c: replace with Mersenne Twister RNG.

* eval.c (jump_tag_but_local_jump): preserve retval in
  LocalJumpError exceptions.

* parse.y (command): no more check for "super outside of method".

* eval.c (rb_mod_define_method): should set last_class and
  last_func in the block->frame.

* eval.c (error_handle): should handle TAG_THROW as well.

* parse.y (yylex): new decimal notation '0d4567'.

* parse.y (yylex): new octal notation '0o777'.

* parse.y (string_content): every string_content node should
  return string only.  use NODE_EVSTR to coercing.

* eval.c (rb_eval): NODE_EVSTR support.

* re.c (rb_reg_quote): avoid unnecessary string allocation.

* string.c (get_pat): quote metachracters before compiling a
  string into a regex.

* string.c (rb_str_split_m): special treatment of strings of size
  1, but AWK emulation.  now uses get_pat().

* string.c (rb_str_match_m): quote metacharacters.

* string.c (rb_str_match2): ditto.

* ext/socket/socket.c (sock_addrinfo): make all 3 versions of
  getaddrinfo happy.  [ruby-core:00184]
@
text
@d1208 3
@


1.70
log
@* re.c (rb_reg_expr_str): need to process backslashes properly.

* object.c (rb_any_to_a): declare Object#to_a to be obsolete.

* object.c (rb_Array): do not convert nil into [] automagically.

* object.c (rb_Integer): use "to_int" instead of
  "to_i". [experimental]

* object.c (nil_to_f): new method.

* object.c (rb_Integer): Symbols and nil should cause error.

* object.c (rb_Float): nil should cause error.
@
text
@d1173 3
a1175 4
static VALUE
rb_reg_s_quote(argc, argv)
    int argc;
    VALUE *argv;
a1176 2
    VALUE str, kcode;
    int kcode_saved = reg_kcode;
a1180 7
    rb_scan_args(argc, argv, "11", &str, &kcode);
    if (!NIL_P(kcode)) {
	rb_set_kcode(StringValuePtr(kcode));
	curr_kcode = reg_kcode;
	reg_kcode = kcode_saved;
    }
    StringValue(str);
d1183 23
a1245 1
    kcode_reset_option();
d1249 20
@


1.69
log
@* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* numeric.c (flo_to_s): default format precision to be "%.16g".

* util.c (ruby_strtod): use own strtod(3) implementation to avoid
  locale hell.  Due to this change "0xff".to_f no longer returns 255.0

* eval.c (avalue_to_yvalue): new function to distinguish yvalue
  (no-arg == Qundef) from svalue (no-arg == Qnil).

* eval.c (rb_yield_0): use avalue_to_yvalue().

* eval.c (assign): warn if val == Qundef where it means rhs is
  void (e.g. yield without value or call without argument).

* parse.y (value_expr): need not to warn for WHILE and UNTIL,
  since they can have return value (via valued break).
@
text
@d239 8
a246 1
	    if (*p == '/' && (s == p || p[-1] != '\\')) {
d254 1
@


1.68
log
@* re.c (rb_reg_s_quote): # also should be quoted.
@
text
@d8 1
a8 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
@


1.67
log
@* numeric.c (num_step): better iteration condition for float
  values;  suggested by Masahiro TANAKA <masa@@ir.isas.ac.jp>.

* range.c (range_step): step (for Range#step method) <= 0 makes no
  sence, thus ArgError will be raised.

* range.c (range_each): Range#each method is special case for
  Range#step(1)

* file.c (rb_find_file): load must be done from an abolute path if
  $SAFE >= 4.

* enum.c (enum_partition): new method. [new]

* re.c (rb_reg_s_quote): quote whitespaces for /x cases.
@
text
@d1219 1
a1219 1
	  case ' ':
@


1.66
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d5 1
a5 1
  $Author: nobu $
d864 2
a865 1
	} else {
d1174 1
d1189 3
a1191 2
	if (ismbchar(*s)) {
	    int n = mbclen(*s);
d1198 11
a1208 7
	if (*s == '[' || *s == ']'
	    || *s == '{' || *s == '}'
	    || *s == '(' || *s == ')'
	    || *s == '|' || *s == '-'
	    || *s == '*' || *s == '.' || *s == '\\'
	    || *s == '?' || *s == '+'
	    || *s == '^' || *s == '$') {
d1210 12
d1223 1
a1223 1
	*t++ = *s;
@


1.65
log
@* re.c (rb_reg_to_s): remove redundant shy group.
@
text
@d5 1
a5 1
  $Author: matz $
a92 2
    int tmp;

d231 1
a231 1
	p++;
d239 1
a239 7
	    if (*p == '\\') {
		rb_str_buf_cat(str, p++, 1);
		if (p<pend) {
		    rb_str_buf_cat(str, p, 1);
		}
	    }
	    else if (*p == '/') {
d252 6
d259 1
a259 28
		char b[8];
		switch (*p) {
		case '\r':
		    rb_str_buf_cat(str, "\\r", 2);
		    break;
		case '\n':
		    rb_str_buf_cat(str, "\\n", 2);
		    break;
		case '\t':
		    rb_str_buf_cat(str, "\\t", 2);
		    break;
		case '\f':
		    rb_str_buf_cat(str, "\\f", 2);
		    break;
		case 007:
		    rb_str_buf_cat(str, "\\a", 2);
		    break;
		case 013:
		    rb_str_buf_cat(str, "\\v", 2);
		    break;
		case 033:
		    rb_str_buf_cat(str, "\\e", 2);
		    break;
		default:
		    sprintf(b, "\\%03o", *p & 0377);
		    rb_str_buf_cat(str, b, 4);
		    break;
		}
d341 2
a342 1
    if (len >= 4 && ptr[0] == '(' && ptr[1] == '?' && ptr[len-1] == ')') {
d345 1
a345 1
	if ((len -= 3) > 0) {
d377 9
a385 2
	if (*ptr == ':') {
	    Regexp *rp = ALLOC(Regexp);
d387 1
a387 2
	    kcode_set_option(re);
	    err = re_compile_pattern(++ptr, --len, rp) != 0;
@


1.64
log
@* eval.c (rb_thread_cleanup): current thread may be THREAD_STOPPED,
  for example when terminated from signal handler.

* regex.c (re_compile_pattern): remove /p support.

* regex.h: ditto.

* parse.y (parse_regx): ditto.
@
text
@d371 1
a371 1
	int nest = 0;
d406 2
a407 2
	    const char* p = ++ptr;
	    long l = --len;
d409 1
a409 16
	    while (len > 0) {
		int n;
		if (*p == '(') {
		    ++nest;
		}
		else if (*p == ')') {
		    if (--nest < 0) break;
		}
		else if (*p == '\\') {
		    --l;
		    ++p;
		}
		n = mbclen(*p);
		l -= n;
		p += n;
	    }
d411 1
d413 1
a413 1
	if (nest) {
@


1.63
log
@* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* io.c: complete off_t handling; missing argument for
  fptr_finalize(); polished rb_scan_args call.

* dir.c: wrap multi-statment macro by do { } while (0)

* eval.c, numeric,c, sprintf.c, util.c: ditto.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.
@
text
@d5 1
a5 1
  $Author: akr $
d307 1
a307 4
	/* /p is obsolete; to be removed */
	if ((RREGEXP(re)->ptr->options & RE_OPTION_POSIXLINE) == RE_OPTION_POSIXLINE)
	    rb_str_buf_cat2(str, "p");
	else if (RREGEXP(re)->ptr->options & RE_OPTION_MULTILINE)
d359 4
a362 1
    int all;
d367 70
a436 13
    all = 1;
    if (RREGEXP(re)->ptr->options & RE_OPTION_MULTILINE)
	rb_str_buf_cat2(str, "m");
    else
	all = 0;
    if (RREGEXP(re)->ptr->options & RE_OPTION_IGNORECASE)
	rb_str_buf_cat2(str, "i");
    else
	all = 0;
    if (RREGEXP(re)->ptr->options & RE_OPTION_EXTENDED)
	rb_str_buf_cat2(str, "x");
    else
	all = 0;
d438 1
a438 1
    if (!all) {
d440 3
a442 6
	if (!(RREGEXP(re)->ptr->options & RE_OPTION_MULTILINE))
	    rb_str_buf_cat2(str, "m");
	if (!(RREGEXP(re)->ptr->options & RE_OPTION_IGNORECASE))
	    rb_str_buf_cat2(str, "i");
	if (!(RREGEXP(re)->ptr->options & RE_OPTION_EXTENDED))
	    rb_str_buf_cat2(str, "x");
d446 1
a446 1
    rb_reg_expr_str(str, RREGEXP(re)->str, RREGEXP(re)->len);
d1291 1
a1291 3
    if ((RREGEXP(re)->ptr->options & RE_OPTION_POSIXLINE) == RE_OPTION_POSIXLINE)
	options |= RE_OPTION_POSIXLINE;
    else if (RREGEXP(re)->ptr->options & RE_OPTION_MULTILINE)
@


1.62
log
@* re.c (rb_reg_to_s): new function for Regexp#to_s.
@
text
@d5 1
a5 1
  $Author: matz $
d241 7
a247 1
	    if (*p == '/') {
@


1.61
log
@* re.c (match_select): fix index references and make
  MatchData#select actually work.
@
text
@d352 41
d1499 1
a1499 1
    rb_define_method(rb_cRegexp, "to_s", rb_reg_inspect, 0);
@


1.60
log
@* re.c (match_setter): it's OK to assign nil to $~.

* io.c (rb_io_fptr_cleanup): do not close IO created by for_fd().

* io.c (rb_io_initialize): mark IO created by for_fd

* ext/socket/socket.c (bsock_s_for_fd): ditto.
@
text
@d844 1
a844 1
	    VALUE str = rb_str_new(ptr+regs->beg[i], regs->end[i]-regs->beg[i]);
@


1.59
log
@* re.c (rb_reg_search): should clear last_match if pos is out of
  string range.

* string.c (rb_str_index_m): ditto.

* string.c (rb_str_rindex): ditto.

* class.c (rb_define_class): should handle autoload.

* class.c (rb_define_module): ditto.
@
text
@d1395 3
a1397 1
    Check_Type(val, T_MATCH);
@


1.58
log
@* re.c (rb_reg_match): should clear $~ if operand is nil.

* re.c (rb_reg_match2): ditto.

* configure: merge Jonathan Baker's large file support patch
  [ruby-talk:35316], with read_all patch in [ruby-talk:35470].

* eval.c (rb_f_abort): optional message argument that be printed
  on termination. [new]
@
text
@d616 4
a619 1
    if (pos > RSTRING(str)->len) return -1;
@


1.57
log
@* parse.y (stmt): local variable declaration order was changed
  since 1.6

* parse.y (arg): ditto.

* pack.c (pack_pack): add templates 'q' and 'Q'.

* pack.c (pack_unpack): ditto.

* bignum.c (rb_quad_pack): new utility function.

* bignum.c (rb_quad_unpack): ditto.

* parse.y (assignable): should emit CVASGN within the method
  body.

* dir.c (dir_s_glob): should not warn even if no match found.

* eval.c (rb_eval): clean up class variable behavior.

* eval.c (assign): ditto.

* eval.c (is_defined): ditto.

* variable.c (rb_mod_class_variables): need not to call rb_cvar_singleton().

* variable.c (rb_cvar_singleton): removed.
@
text
@d640 1
a640 1
		  "Stack overflow in regexp matcher", re);
d1004 4
a1007 1
    if (NIL_P(str)) return Qnil;
d1023 2
a1024 1
    if (TYPE(line) != T_STRING)
d1026 1
@


1.56
log
@* file.c (rb_stat_inspect): print dev, rdev in hexadecimal.
@
text
@a631 1
    regs.allocated = 0;
@


1.55
log
@* re.c (match_select): should propagate taintness.

* hash.c (rb_hash_set_default): Hash#default= should return the
  new value.

* string.c (rb_str_to_i): accepts optional base argument. [new]

* numeric.c (rb_fix2str): should not handle negative fixnum values
  int32 via calling sprintf() directly.
@
text
@d632 1
@


1.54
log
@* process.c (rb_f_system): abandon vfork.

* io.c (pipe_open): ditto.

* defines.h: sparc linux needs different FLUSH_REGISTER_WINDOWS

* regex.c (re_search): abandon stclass optimization.

* bignum.c (rb_cstr2inum): deny "0_".

* bignum.c (rb_cstr2inum): allow "0\n" and so on.

* error.c (rb_invalid_str): utility function to show inspect()'ed
  string.

* bignum.c (rb_cstr2inum): prints invalid strings in inspect()'ed
  format.

* object.c (rb_Float): ditto.

* object.c (rb_convert_type): no longer use rb_rescue().

* re.c (rb_reg_search): initialize taint status of match object.
@
text
@d832 1
d841 3
a843 2
	    rb_ary_push(result, rb_str_new(ptr+regs->beg[idx],
					   regs->end[idx]-regs->beg[idx]));
a985 2
    int min;

d990 1
a990 3
    min = RREGEXP(re1)->len;
    if (min > RREGEXP(re2)->len) min = RREGEXP(re2)->len;
    if (memcmp(RREGEXP(re1)->str, RREGEXP(re2)->str, min) == 0 &&
@


1.53
log
@* time.c (time_plus): result should not be negative unless
  NEGATIVE_TIME_T is defined.

* time.c (time_new_internal): should check tv_sec overflow too.

* time.c (time_timeval): should check time_t range when time is
  initialized from float.

* time.c (time_plus): uses modf(3).

* variable.c (rb_cvar_set): add frozen class/module check.

* variable.c (rb_cvar_declare): add frozen class/module check.

* re.c (match_to_a): should propagate taint.

* re.c (rb_reg_s_quote): ditto.
@
text
@d652 7
@


1.52
log
@* string.c (rb_str_match_m): should convert an argument into
  regexp if it's a string.

* array.c (rb_ary_select): Array#select(n,m,...) now works like
  Array#indexes(n,m,..). [new, experimental]

* hash.c (rb_hash_select): ditto.

* hash.c (env_select): ditto.

* re.c (match_select): ditto.

* struct.c (rb_struct_select): ditto.

* gc.c (STR_ASSOC): use FL_USER3 instead of FL_USER2.

* parse.y (str_extend): make up pushback call.
@
text
@d784 2
a785 1

d787 7
a793 3
	if (regs->beg[i] == -1) rb_ary_push(ary, Qnil);
	else rb_ary_push(ary, rb_str_new(ptr+regs->beg[i],
					 regs->end[i]-regs->beg[i]));
d1130 1
a1130 1

@


1.51
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* massages: replace "wrong #" by "wrong number".

* marshal.c (w_float): output Infinity and NaN explicitly.

* marshal.c (r_object): support new explicit float format.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.

* array.c (rb_ary_join): dumped core if sep is not T_STRING nor T_NIL.

* array.c (rb_ary_join): buffer size calculattion was wrong.

* array.c (rb_ary_to_s): if rb_output_fs is nil, insert newlines
  between array elements (use rb_default_rs as newline litral)
  [experimental].

* gc.c (init_mark_stack): no need to clear mark_stack.

* gc.c (gc_mark_all): need to handle finalizer mark.

* gc.c (gc_mark_rest): use MEMCPY instead of memcpy.

* gc.c (rb_gc_mark): earlier const check to avoid pusing special
  constants into mark stack.

* numeric.c (fix_to_s): 'to_s' now takes optional argument to
  specify radix. [new]

* bignum.c (rb_big_to_s): ditto. [new]
@
text
@d788 1
a788 1
				   regs->end[i]-regs->beg[i]));
d810 26
d1465 1
@


1.50
log
@* marshal.c (w_unique): should not dump anonymous class.
@
text
@d5 1
a5 1
  $Author: nobu $
d1016 1
a1016 1
	rb_raise(rb_eArgError, "wrong # of argument");
@


1.49
log
@* re.c (rb_reg_s_alloc): avoid inifinte recursion.
@
text
@d5 1
a5 1
  $Author: matz $
d886 14
d906 1
a906 3
    
    NEWOBJ(re, struct RRegexp);
    OBJSETUP(re, rb_cRegexp, T_REGEXP);
a907 1
    re->ptr = 0; re->len = 0; re->str = 0;
a1052 14
}

static VALUE
rb_reg_s_alloc(klass)
    VALUE klass;
{
    NEWOBJ(re, struct RRegexp);
    OBJSETUP(re, klass, T_REGEXP);

    re->ptr = 0;
    re->len = 0;
    re->str = 0;

    return (VALUE)re;
@


1.48
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d1048 2
a1049 1
    VALUE re = rb_obj_alloc(klass);
d1051 3
a1053 3
    RREGEXP(re)->ptr = 0;
    RREGEXP(re)->len = 0;
    RREGEXP(re)->str = 0;
d1055 1
a1055 1
    return re;
@


1.47
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* string.c (rb_str_subpat_set): support function for new argument
  pattern String#[re,offset] = val. [new]

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_aref_m): new argument pattern
  String#[re,offset]. [new]

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* array.c (rb_ary_initialize): Array.new([1,2,3]) => [1,2,3]. [new]

* string.c (rb_str_reverse): should return an instance of
  receiver's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.

* eval.c (eval): retrieves file, line information from binding.

* eval.c (intersect_fds): counts intersecting fds.

* eval.c (rb_thread_schedule): only fds requested by
  each thread count as select_value.
@
text
@d5 1
a5 1
  $Author: nobu $
d668 5
a672 1
	return Qfalse;
d690 4
d892 1
d1045 1
a1045 3
rb_reg_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
d1048 7
a1054 5
    NEWOBJ(re, struct RRegexp);
    OBJSETUP(re, klass, T_REGEXP);
    re->ptr = 0; re->len = 0; re->str = 0;
    rb_obj_call_init((VALUE)re, argc, argv);
    return (VALUE)re;
d1164 5
a1168 2
    NEWOBJ(clone, struct RRegexp);
    CLONESETUP(clone, re);
a1169 1
    clone->ptr = 0; clone->len = 0; clone->str = 0;
d1172 1
a1172 1
    return (VALUE)re;
d1401 2
a1402 2
    rb_define_singleton_method(rb_cRegexp, "new", rb_reg_s_new, -1);
    rb_define_singleton_method(rb_cRegexp, "compile", rb_reg_s_new, -1);
d1429 1
@


1.46
log
@* eval.c, intern.h (rb_svar): return reference to special variable
  from local variable index. [new]

* eval.c (rb_eval): use rb_svar() for NODE_FLIP{2,3}.

* parse.y (rb_(backref|lastline)_(get|set)): access via rb_svar().

* eval.c (proc_invoke): push dynamic variables.

* eval.c (rb_thread_yield): push special variables as dynamic
  variables($_, $~ and FLIP states).


* intern.h, parse.y (rb_is_local_id): return true if the ID is
  local symbol. [new]

* parse.y (internal_id): make new ID for internal use. [new]

* parse.y (cond0): allocate internal ID for NODE_FLIP{2,3}.

* eval.c (rb_f_local_variables): use rb_is_local_id() to select
  visible local variables.


* eval.c (rb_thread_start_0): SCOPE_SHARED is removed.

* eval.c, intern.h (rb_thread_scope_shared_p): removed. special
  variables are no longer shared by threads.

* re.c (rb_reg_search): MATCHDATA is no longer shared by threads.
@
text
@d5 1
a5 1
  $Author: matz $
d706 2
d710 3
a712 1
    return rb_str_new(RSTRING(RMATCH(match)->str)->ptr, RMATCH(match)->BEG(0));
d719 2
d723 4
a726 2
    return rb_str_new(RSTRING(RMATCH(match)->str)->ptr+RMATCH(match)->END(0),
		      RSTRING(RMATCH(match)->str)->len-RMATCH(match)->END(0));
@


1.45
log
@* re.c (Init_Regexp): to_s to be alias to inspect.

* parse.y (yylex): should support 'keyword='.

* ruby.c (proc_options): should not adjust argc/argv if -e option
  is supplied.
@
text
@d648 1
a648 6
    if (rb_thread_scope_shared_p()) {
	match = Qnil;
    }
    else {
	match = rb_backref_get();
    }
@


1.44
log
@* eval.c (rb_provide_feature): should not tweak extension used for
  loading.

* io.c (io_fread): use fread(3) if PENDING_COUND is available.

* class.c (rb_mod_include_p): Module#include? added. [new]

* re.c (ignorecase_setter): give warning on modifying $=.

* string.c (rb_str_casecmp): new method. [new]

* string.c (rb_str_eql): separated from rb_str_equal(), make it
  always be case sensitive. [new]

* string.c (rb_str_hash): made it always be case sensitive.

* eval.c (rb_f_require): should not include path in $" value

* file.c (rb_find_file): should return 0 explicitly on failure.
@
text
@d1400 1
d1429 1
a1430 1
    rb_define_method(rb_cMatch, "inspect", rb_any_to_s, 0);
@


1.43
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d75 1
a75 1
rb_memcmp(p1, p2, len)
a80 4
    if (!ruby_ignorecase) {
	return memcmp(p1, p2, len);
    }

d88 13
d1316 1
a1316 1
ignorecase_setter(val)
d1318 1
d1320 1
@


1.42
log
@* array.c (rb_ary_and): should not push frozen key string.

* array.c (rb_ary_or): ditto.

* eval.c (rb_thread_schedule): should save context before raising
  deadlock, saved context for current thread might be obsolete.

* time.c (make_time_t): non DST timezone shift supported (hopefully).

* time.c (make_time_t): strict range detection for negative time_t.

* signal.c: SIGINFO added.

* eval.c (rb_ensure): should not SEGV when prot_tag is NULL.
@
text
@d227 1
a227 1
	rb_str_cat(str, s, len);
d234 2
a235 2
		rb_str_cat(str, &c, 1);
		rb_str_cat(str, p, 1);
d238 1
a238 1
	    	rb_str_cat(str, p, mbclen(*p));
d243 1
a243 1
		rb_str_cat(str, p, 1);
d249 1
a249 1
		    rb_str_cat(str, "\\r", 2);
d252 1
a252 1
		    rb_str_cat(str, "\\n", 2);
d255 1
a255 1
		    rb_str_cat(str, "\\t", 2);
d258 1
a258 1
		    rb_str_cat(str, "\\f", 2);
d261 1
a261 1
		    rb_str_cat(str, "\\a", 2);
d264 1
a264 1
		    rb_str_cat(str, "\\v", 2);
d267 1
a267 1
		    rb_str_cat(str, "\\e", 2);
d271 1
a271 1
		    rb_str_cat(str, b, 4);
d286 1
a286 1
    VALUE str = rb_str_new2("/");
d289 1
a289 1
    rb_str_cat2(str, "/");
d294 1
a294 1
	    rb_str_cat2(str, "p");
d296 1
a296 1
	    rb_str_cat2(str, "m");
d298 1
a298 1
	    rb_str_cat2(str, "i");
d300 1
a300 1
	    rb_str_cat2(str, "x");
d305 1
a305 1
		rb_str_cat2(str, "n");
d308 1
a308 1
		rb_str_cat2(str, "e");
d311 1
a311 1
		rb_str_cat2(str, "s");
d314 1
a314 1
		rb_str_cat2(str, "u");
d1174 7
a1180 2
	if (!val) val = rb_str_new(p, ss-p);
	else      rb_str_cat(val, p, ss-p);
d1194 1
a1194 1
	    rb_str_cat(val, RSTRING(src)->ptr, BEG(0));
d1198 1
a1198 1
	    rb_str_cat(val, RSTRING(src)->ptr+END(0), RSTRING(src)->len-END(0));
d1208 1
a1208 1
	    rb_str_cat(val, s-1, 1);
d1212 1
a1212 1
	    rb_str_cat(val, s-2, 2);
d1219 1
a1219 1
	    rb_str_cat(val, RSTRING(src)->ptr+BEG(no), END(no)-BEG(no));
d1224 7
a1230 2
	if (!val) val = rb_str_new(p, e-p);
	else      rb_str_cat(val, p, e-p);
@


1.41
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d14 1
a779 3
    struct re_registers *regs;
    char *ptr;
    int i;
a1103 2
    int kcode;

@


1.40
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_options): new method to give an option values.

* parse.y (cond0): disable special treating of integer literal in
  conditional unless option -e is supplied.  changes current
  behavior.  experimental.

* parse.y (cond0): give warning for string/integer literals and
  dot operators in conditionals unless option -e is supplied.

* re.c (rb_reg_equal): all option flags should be same to be equal.

* error.c (Init_Exception): make Interrupt a subclass of
  SignalException.
@
text
@d939 1
a939 1
    str = rb_str_to_str(str);
d993 1
a993 1
	char *kcode = STR2CSTR(argv[2]);
d1019 2
a1020 5
	char *p;
	int len;

	p = rb_str2cstr(src, &len);
	rb_reg_initialize(self, p, len, flags);
a1046 1
    int len;
d1050 1
a1050 1
	rb_set_kcode(STR2CSTR(kcode));
d1054 4
a1057 3
    s = rb_str2cstr(str, &len);
    send = s + len;
    tmp = rb_str_new(0, len*2);
d1288 1
a1288 1
    struct RString *val;
d1291 1
a1291 1
    rb_set_kcode(STR2CSTR(val));
d1406 1
@


1.39
log
@* array.c (rb_ary_sort_bang): returns self, even if its length is
  less than 2.

* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d367 8
d926 1
a926 2
	!((RREGEXP(re1)->ptr->options & RE_OPTION_IGNORECASE) ^
	  (RREGEXP(re2)->ptr->options & RE_OPTION_IGNORECASE))) {
d1389 1
@


1.38
log
@* string.c (str_independent): should not clear str->orig here.
  it's too early.
@
text
@d392 1
a392 1
make_regexp(s, len, flag)
d394 1
a394 1
    int len, flag;
d411 2
a412 2
    if (flag) {
	rp->options = flag;
d976 1
a976 1
    int flag = 0;
d982 2
a983 2
	if (FIXNUM_P(argv[1])) flag = FIX2INT(argv[1]);
	else if (RTEST(argv[1])) flag = RE_OPTION_IGNORECASE;
d990 1
a990 1
	    flag |= 16;
d993 1
a993 1
	    flag |= 32;
d996 1
a996 1
	    flag |= 48;
d999 1
a999 1
	    flag |= 64;
d1009 1
a1009 1
	rb_reg_initialize(self, RREGEXP(src)->str, RREGEXP(src)->len, flag);
d1016 1
a1016 1
	rb_reg_initialize(self, p, len, flag);
@


1.37
log
@Mon Jan 15 16:00:07 2001  Yukihiro Matsumoto  <matz@@ruby-lang.org>

	* pack.c (pack_unpack): should check associated pointer packed by
	  pack("P").  restriction added.

Sun Jan 14 21:49:28 2001  Koji Arai  <JCA02266@@nifty.ne.jp>

	* sprintf.c (rb_f_sprintf): simple typo.  binary base should be 2,
	  not '2'.

	* re.c (rb_reg_s_last_match): should explicitly return nth match.
@
text
@d5 1
a5 1
  $Author: eban $
d8 1
a8 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.36
log
@* re.c (rb_reg_desc): separate RE_OPTION_MULTILINE
* re.c (rb_reg_options): add RE_OPTION_{POSIXLINE,RE_OPTION_MULTILINE,
  RE_OPTION_EXTENDED}
@
text
@d5 1
a5 1
  $Author: matz $
a729 13
rb_reg_s_last_match(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE nth;

    if (rb_scan_args(argc, argv, "01", &nth) == 1) {
	rb_reg_nth_match(NUM2INT(nth), rb_backref_get());
    }
    return rb_reg_last_match(rb_backref_get());
}

static VALUE
d1018 1
d1322 13
d1370 1
a1370 1
    rb_define_singleton_method(rb_cRegexp, "last_match", rb_reg_s_last_match, 0);
@


1.35
log
@* enum.c (enum_inject): new method.

* gc.c (rb_gc_call_finalizer_at_exit): clear klass member of
  terminating object.

* eval.c (rb_call): raise exception for terminated object.

* bignum.c (bigdivrem): t2 might be too big for signed long; do
  not use rb_int2big(), but rb_uint2big().

* error.c (rb_load_fail): new func to report LoadError.

* ruby.c (load_file): use rb_load_fail.

* eval.c (ruby_finalize): should enclosed by PUSH_TAG/POP_TAG.

* gc.c (rb_gc_mark): link 2 of NODE_IFUNC should not be explicitly
  marked.  it may contain non object pointer.

* re.c (reg_s_last_match): Regexp::last_match(nth) returns nth
  substring of the match  (alternative for $& and $<digit>).

* eval.c (rb_mod_define_method): wrong comparison for blocks.

* gc.c (id2ref): should handle Symbol too.

* gc.c (id2ref): should print original ptr value

* eval.c (rb_iterate): NODE_CFUNC does not protect its data
  (nd_tval), so create new node NODE_IFUNC for iteration C
  function.

* eval.c (rb_yield_0): use NODE_IFUNC.

* gc.c (rb_gc_mark): support NODE_IFUNC.

* gc.c (mem_error): prohibit recursive mem_error().
  (ruby-bugs-ja:PR#36)

* eval.c (rb_thread_fd_writable): should not switch context if
  rb_thread_critical is set.

* eval.c (rb_thread_wait_fd): ditto.

* eval.c (rb_thread_wait_for): ditto.

* eval.c (rb_thread_select): ditto.

* eval.c (rb_thread_join): join during critical section causes
  deadlock.
@
text
@a290 2
	if (RREGEXP(re)->ptr->options & RE_OPTION_MULTILINE)
	    rb_str_cat2(str, "m");
d294 2
d1139 6
@


1.34
log
@matz
@
text
@d730 13
d1363 1
a1363 1
    rb_define_singleton_method(rb_cRegexp, "last_match", match_getter, 0);
@


1.34.2.1
log
@* re.c (rb_reg_desc): separate RE_OPTION_MULTILINE
* re.c (rb_reg_options): add RE_OPTION_{POSIXLINE,RE_OPTION_MULTILINE,RE_OPTION_EXTENDED}
@
text
@d291 2
a295 2
	else if (RREGEXP(re)->ptr->options & RE_OPTION_MULTILINE)
	    rb_str_cat2(str, "m");
a1125 6
    if ((RREGEXP(re)->ptr->options & RE_OPTION_POSIXLINE) == RE_OPTION_POSIXLINE)
	options |= RE_OPTION_POSIXLINE;
    else if (RREGEXP(re)->ptr->options & RE_OPTION_MULTILINE)
	options |= RE_OPTION_MULTILINE;
    if (RREGEXP(re)->ptr->options & RE_OPTION_EXTENDED)
	options |= RE_OPTION_EXTENDED;
@


1.34.2.2
log
@Sun Jan 14 21:49:28 2001  Koji Arai  <JCA02266@@nifty.ne.jp>

	* sprintf.c (rb_f_sprintf): simple typo.  binary base should be 2,
	  not '2'.
@
text
@d5 1
a5 1
  $Author: eban $
a1017 1
    return self;
@


1.34.2.3
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_equal): all option flags should be same to be equal.
@
text
@d5 1
a5 1
  $Author: matz $
d918 2
a919 1
	RREGEXP(re1)->ptr->options == RREGEXP(re2)->ptr->options) {
@


1.34.2.4
log
@* parse.y (parse_regx): handle backslash escaping of delimiter here.
@
text
@d217 1
a217 1
    p = s; pend = p + len; 
@


1.34.2.5
log
@* marshal.c: backport from 1.7 marshal.c
@
text
@d655 1
a655 5
	return Qnil;
    }
    if (nth < 0) {
	nth += RMATCH(match)->regs->num_regs;
	if (nth <= 0) return Qnil;
a672 4
    if (nth < 0) {
	nth += RMATCH(match)->regs->num_regs;
	if (nth <= 0) return Qnil;
    }
d1148 1
a1148 1
    return (VALUE)clone;
@


1.34.2.6
log
@* variable.c (rb_cvar_set): add frozen class/module check.

* variable.c (rb_cvar_declare): add frozen class/module check.

* re.c (match_to_a): should propagate taint.

* re.c (rb_reg_s_quote): ditto.
@
text
@d763 1
a763 2
    int taint = OBJ_TAINTED(match);
    
d765 3
a767 7
	if (regs->beg[i] == -1) {
	    rb_ary_push(ary, Qnil);
	} else {
	    VALUE str = rb_str_new(ptr+regs->beg[i], regs->end[i]-regs->beg[i]);
	    if (taint) OBJ_TAINT(str);
	    rb_ary_push(ary, str);
	}
d1085 1
a1085 1
    OBJ_INFECT(tmp, str);
@


1.34.2.7
log
@* stable version 1.6.6 released.
@
text
@a638 7
    else {
	if (rb_safe_level() >= 3) 
	    OBJ_TAINT(match);
	else
	    FL_UNSET(match, FL_TAINT);
    }

@


1.34.2.8
log
@* eval.c (block_pass): should not pass tainted block, if $SAFE > 0.

* variable.c (rb_mod_remove_cvar): should pass the char*.
@
text
@d928 2
d934 3
a936 1
    if (memcmp(RREGEXP(re1)->str, RREGEXP(re2)->str, RREGEXP(re1)->len) == 0 &&
@


1.34.2.9
log
@* re.c (rb_reg_search): should set regs.allocated.
@
text
@a613 1
    regs.allocated = 0;
@


1.34.2.10
log
@* parse.y (assignable): should emit CVASGN within the method
  body.
@
text
@d614 1
@


1.34.2.11
log
@* re.c (rb_reg_match): should clear $~ if operand is nil.

* re.c (rb_reg_match2): ditto.
@
text
@d946 1
a946 4
    if (NIL_P(str)) {
	rb_backref_set(Qnil);
	return Qnil;
    }
d962 1
a962 2
    if (TYPE(line) != T_STRING) {
	rb_backref_set(Qnil);
a963 1
    }
@


1.34.2.12
log
@* re.c (rb_reg_search): should clear last_match if pos is out of
  string range.

* string.c (rb_str_index_m): ditto.

* string.c (rb_str_rindex): ditto.
@
text
@d598 1
a598 4
    if (pos > RSTRING(str)->len) {
	rb_backref_set(Qnil);
	return -1;
    }
@


1.34.2.13
log
@* re.c (match_setter): it's OK to assign nil to $~.
@
text
@d1341 1
a1341 3
    if (!NIL_P(val)) {
	Check_Type(val, T_MATCH);
    }
@


1.34.2.14
log
@* file.c (rb_find_file): load must be done from an abolute path if
  $SAFE >= 4.

* re.c (rb_reg_s_quote): quote whitespaces for /x cases.

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* eval.c (rb_thread_cleanup): current thread may be THREAD_STOPPED,
  for example when terminated from signal handler.

* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.

* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* marshal.c (w_uclass): should check based on rb_obj_class(), not
  CLASS_OF().

* io.c (io_write): check error if written data is less than
  specified size to detect EPIPE.

* eval.c (assign): ruby_verbose should be surrounded by RTEST().

* object.c (rb_str2cstr): ditto.

* parse.y (void_expr): ditto.

* parse.y (void_stmts): ditto.

* variable.c (rb_ivar_get): ditto.

* variable.c (rb_cvar_set): ditto.

* variable.c (rb_cvar_get): ditto.
@
text
@d223 1
a223 1
	p += mbclen(*p);
d231 1
a231 1
	    if (*p == '/' && (s == p || p[-1] != '\\')) {
d244 1
a244 1
	    else if (!ISSPACE(*p)) {
d246 27
a272 6

		sprintf(b, "\\%03o", *p & 0377);
		rb_str_cat(str, b, 4);
	    }
	    else {
		rb_str_cat(str, p, 1);
d1066 1
a1066 1
    int len, c;
d1080 2
a1081 3
	c = *s;
	if (ismbchar(c)) {
	    int n = mbclen(c);
d1088 7
a1094 7
	switch (c) {
	  case '\t':
	    c = 't';
	    *t++ = '\\';
	    break;
	  case '\f':
	    c = 'f';
a1095 16
	    break;
	  case '\r':
	    c = 'r';
	    *t++ = '\\';
	    break;
	  case '\n':
	    c = 'n';
	    *t++ = '\\';
	    break;
	  case '[': case ']': case '{': case '}':
	  case '(': case ')': case '|': case '-':
	  case '*': case '.': case '\\':
	  case '?': case '+': case '^': case '$':
	  case ' ':
	    *t++ = '\\';
	    break;
d1097 1
a1097 1
	*t++ = c;
@


1.34.2.15
log
@* eval.c (blk_orphan): the wrong condition; backported from 1.7

* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* re.c (rb_reg_s_quote): # also should be quoted.
@
text
@d1089 1
a1089 1
	  case ' ': case '#':
@


1.34.2.16
log
@* string.c (rb_str_slice_bang): if there's no corresponding
  substring, slice! should return nil without exception.

* string.c (rb_str_split_m): accept separator value nil as well.

* class.c (include_class_new): module may be T_ICLASS; retrieve
  original module information.

* re.c (rb_reg_expr_str): need to process backslashes properly.

* parse.y (yylex): no here document after a dot.

* parse.y (yylex): should have set lex_state properly after '`'.

* parse.y (yylex): should have set lex_state properly after
  tOP_ASGN.

* bignum.c (rb_big2dbl): return canonical HUGE_VAL for infinity.
@
text
@d231 1
a231 8
	    if (*p == '\\') {
		rb_str_cat(str, p, 1);
		p++;
	    	rb_str_cat(str, p, mbclen(*p));
		p += mbclen(*p);
		continue;
	    }
	    else if (*p == '/') {
a689 2
    VALUE str;

d692 1
a692 3
    str = rb_str_new(RSTRING(RMATCH(match)->str)->ptr, RMATCH(match)->BEG(0));
    if (OBJ_TAINTED(match)) OBJ_TAINT(str);
    return str;
a698 2
    VALUE str;

d701 2
a702 4
    str = rb_str_new(RSTRING(RMATCH(match)->str)->ptr+RMATCH(match)->END(0),
		     RSTRING(RMATCH(match)->str)->len-RMATCH(match)->END(0));
    if (OBJ_TAINTED(match)) OBJ_TAINT(str);
    return str;
@


1.34.2.17
log
@* array.c (sort_2): *a - *b may overflow.

* array.c (rb_ary_new2): len*sizeof(VALUE) may be a positive value.

* array.c (rb_ary_initialize): ditto.

* re.c (rb_reg_initialize): should not modify frozen Regexp.

* bignum.c (rb_uint2big): there should be no zero sized bignum.

* ext/extmk.rb.in: extmake() that works properly for both tkutil
  (tk/tkutil.so) and digest/sha1.
@
text
@a835 3
    if (OBJ_FROZEN(obj)) {
	rb_error_frozen("Regexp");
    }
@


1.34.2.18
log
@* eval.c (rb_thread_cleanup): should not modify the global
  variable curr_thread.

* re.c (rb_reg_initialize_m): frozen check should be moved here
  from rb_reg_initialize().
@
text
@d836 3
a1025 3
    if (OBJ_FROZEN(self)) {
	rb_error_frozen("Regexp");
    }
@


1.34.2.19
log
@* array.c, class.c, eval.c, file.c, gc.c, node.h, numeric.c,
  object.c, parse.y, range.c, re.c, string.c, struct.c, util.c,
  ext/socket/socket.c: merge from 1.7: treat long values as long
  instead of int.
@
text
@d788 1
@


1.34.4.1
log
@m17n fix
@
text
@d8 1
a8 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
d20 51
d72 19
d92 26
d120 20
a139 1
rb_reg_check(re)
d142 37
a178 2
    if (!RREGEXP(re)->ptr || !RREGEXP(re)->str) {
	rb_raise(rb_eTypeError, "uninitialized Regexp");
d182 18
a199 4
static VALUE
enc_nth(str, nth)
    VALUE str;
    int nth;
d201 2
a202 13
    m17n_encoding *enc = rb_m17n_get_encoding(str);
    if (m17n_mbmaxlen(enc) == 1) return INT2NUM(nth);
    else {
	char *p = RSTRING(str)->ptr;
	char *e = p + nth;
	int i;

	i = 0;
	while (p < e) {
	    p += mbclen(*p);
	    i++;
	}
	return INT2NUM(i);
a213 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
d219 1
a219 1
	if (*p == '/' || (!m17n_isprint(enc, *p) && !ismbchar(*p))) {
d241 1
a241 1
	    else if (m17n_isprint(enc, *p)) {
a284 1
    m17n_encoding *enc;
a286 3

    enc = re ? rb_m17n_get_encoding(re) : ruby_default_encoding;
    rb_m17n_associate_encoding(str, enc);
d300 16
a315 3

	if (enc->index == 0) {	/* ascii */
	    rb_str_cat2(str, "n");
d370 1
a370 1
    m17n_encoding *enc = rb_m17n_get_encoding(re);
d372 17
a388 2
    rb_warn("do not use Regex#kcode; use Regex#encoding instead");
    return rb_str_new2(enc->name);
d392 1
a392 1
make_regexp(s, len, flag, enc)
a394 1
    m17n_encoding *enc;
a413 1
    rp->encoding = enc ? enc : ruby_default_encoding;
a461 2
#define match_nth(m,x,i) enc_nth(RMATCH(match)->str, RMATCH(match)->regs->x[i])

d490 1
a490 1
    return match_nth(match,beg,i);
d505 1
a505 1
    return match_nth(match,end,i);
d541 7
d551 2
d572 5
d603 5
d617 3
a729 13
rb_reg_s_last_match(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE nth;

    if (rb_scan_args(argc, argv, "01", &nth) == 1) {
	rb_reg_nth_match(NUM2INT(nth), rb_backref_get());
    }
    return rb_reg_last_match(rb_backref_get());
}

static VALUE
d771 3
d805 1
a805 1
rb_reg_initialize(obj, s, len, options, enc)
a815 1
    m17n_encoding *enc;
d824 17
a840 19
    if (!enc) {
	 switch (options & ~0xf) {
	   case 0:
	   default:
	     enc = ruby_default_encoding;
	     break;
	   case 16:
	     enc = m17n_find_encoding("ascii");
	     break;
	   case 32:
	     enc = m17n_find_encoding("euc-jp");
	     break;
	   case 48:
	     enc = m17n_find_encoding("sjis");
	     break;
	   case 64:
	     enc = m17n_find_encoding("utf-8");
	     break;
	 }
d843 3
d850 1
a850 1
    re->ptr = make_regexp(s, len, options, enc);
d855 3
a857 1
    rb_m17n_associate_encoding((VALUE)re, enc);
d870 1
a870 2

    rb_reg_initialize(re, s, len, options, 0);
d875 1
d884 1
d889 1
d894 10
d917 1
a917 1
	rb_m17n_get_encoding(re1) == rb_m17n_get_encoding(re2) &&
d937 1
a937 1
    return enc_nth(str, start);
d954 1
a954 1
    return enc_nth(line, start);
a974 1
    m17n_encoding *enc;
d988 15
a1002 21
	if (kcode[1] == 0) {
	    switch (kcode[0]) {
	      case 'n': case 'N':
		kcode = "ascii";
		break;
	      case 'e': case 'E':
		kcode = "euc-jp";
		break;
	      case 's': case 'S':
		kcode = "sjis";
		break;
	      case 'u': case 'U':
		kcode = "utf-8";
		break;
	      default:
		break;
	    }
	}
	enc = m17n_find_encoding(kcode);
	if (!enc) {
	    rb_raise(rb_eArgError, "unknow encoding %s", kcode);
d1009 1
a1009 1
	rb_reg_initialize(self, RREGEXP(src)->str, RREGEXP(src)->len, flag, enc);
d1016 1
a1016 1
	rb_reg_initialize(self, p, len, flag, enc);
a1017 1
    return self;
a1037 1
    m17n_encoding *enc;
d1039 1
d1046 3
a1048 4
	enc = m17n_find_encoding(STR2CSTR(kcode));
    }
    else {
	enc = rb_m17n_get_encoding(str);
d1075 1
d1082 36
d1126 3
a1135 1
    m17n_encoding *enc = rb_m17n_get_encoding(re);
d1141 1
a1141 1
		      rb_reg_options(re), enc);
a1149 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
d1220 15
d1238 1
a1238 2
    rb_warn("$KCODE is obsolete");
    return rb_str_new2(ruby_default_encoding->name);
d1245 1
a1245 5
    m17n_encoding *enc;

    if (code == 0) {
	code = "ascii";
    }
d1247 25
a1271 21
    if (code[1] == 0) {
	switch (code[0]) {
	  case 'E':
	  case 'e':
	    code = "euc-jp";
	    break;
	  case 'S':
	  case 's':
	    code = "sjis";
	    break;
	  case 'U':
	  case 'u':
	    code = "utf-8";
	    break;
	  case 'N':
	  case 'n':
	  case 'A':
	  case 'a':
	    code = "ascii";
	    break;
	}
a1272 5
    enc = m17n_find_encoding(code);
    if (!enc) {
	rb_raise(rb_eArgError, "unknow encoding %s", code);
    }
    ruby_default_encoding = enc;
d1279 1
a1279 1
    rb_warn("changing default encoding on the fly is not recommended");
d1320 15
a1334 1
    re_set_default_encoding(ruby_default_encoding);
d1350 1
a1350 1
    rb_define_singleton_method(rb_cRegexp, "last_match", rb_reg_s_last_match, 0);
a1362 3

    rb_define_method(rb_cRegexp, "encoding", rb_enc_get_encoding, 0);
    rb_define_method(rb_cRegexp, "encoding=", rb_enc_set_encoding, 1);
@


1.34.4.2
log
@tested a bit; utf-8 bugs removed
@
text
@d37 14
a50 2
    int i = rb_str_sublen(str, nth);
    return INT2NUM(i);
d136 1
d143 2
a147 2
	else if (RREGEXP(re)->ptr->options & RE_OPTION_MULTILINE)
	    rb_str_cat2(str, "m");
d1126 1
@


1.34.4.3
log
@several minor fixes.
@
text
@d73 2
a74 3
		int len = m17n_mbcspan(enc, p, pend);
	    	rb_str_cat(str, p, len);
		p += len;
a471 1
    rb_m17n_copy_encoding(str, RMATCH(match)->str);
a485 2
    VALUE str;

d488 1
a488 4
    str = rb_str_new(RSTRING(RMATCH(match)->str)->ptr, RMATCH(match)->BEG(0));
    if (OBJ_TAINTED(match)) OBJ_TAINT(str);
    rb_m17n_copy_encoding(str, RMATCH(match)->str);
    return str;
a494 2
    VALUE str;

d497 2
a498 5
    str = rb_str_new(RSTRING(RMATCH(match)->str)->ptr+RMATCH(match)->END(0),
		     RSTRING(RMATCH(match)->str)->len-RMATCH(match)->END(0));
    if (OBJ_TAINTED(match)) OBJ_TAINT(str);
    rb_m17n_copy_encoding(str, RMATCH(match)->str);
    return str;
d764 1
a764 1
    m17n_encoding *enc = ruby_default_encoding;
d855 1
a855 1
	    int n = m17n_mbcspan(enc, s, send);
d920 1
a920 1
	c = *s;
d922 1
a922 1
	    s += m17n_mbcspan(enc, s, e);
a924 1
	s++;
@


1.33
log
@matz
@
text
@d76 1
a76 1
    size_t len;
d1057 1
a1057 1
	    size_t n = mbclen(*s);
@


1.32
log
@matz
@
text
@d1041 1
a1041 1
    char *tmp;
d1052 2
a1053 2
    tmp = ALLOCA_N(char, len*2);
    t = tmp;
d1076 1
d1078 1
a1078 1
    return rb_str_new(tmp, t - tmp);
@


1.31
log
@matz
@
text
@d780 1
a780 8

    regs = RMATCH(match)->regs;
    i = FIX2INT(idx);

    if (i >= regs->num_regs) return Qnil;

    ptr = RSTRING(RMATCH(match)->str)->ptr;
    return rb_str_new(ptr+regs->beg[i], regs->end[i]-regs->beg[i]);
@


1.30
log
@matz
@
text
@d15 1
a15 1
static VALUE rb_eRegxpError;
d354 1
a354 1
	rb_raise(rb_eRegxpError, "%s: %s", err, RSTRING(desc)->ptr);
d1324 1
a1324 1
    rb_eRegxpError = rb_define_class("RegxpError", rb_eStandardError);
@


1.29
log
@matz
@
text
@d971 3
a973 1
    return rb_backref_get();
@


1.28
log
@2000-06-22
@
text
@a90 6
int
rb_str_cicmp(str1, str2)
    VALUE str1, str2;
{
}

d827 1
a827 1
    if (re->str) free(re->ptr);
d876 1
a876 1
    re->ptr = 0; re->len = 0;
d1033 1
a1033 1
    re->ptr = 0; re->len = 0;
d1060 1
a1060 1
    for (; s != send; s++) {
d1064 1
a1064 1
	    while (n--)
d1143 1
a1143 1
    clone->ptr = 0; clone->len = 0;
@


1.27
log
@2000-06-19
@
text
@d376 1
a376 1
    char *kcode = "$KCODE";
d389 1
d392 1
d394 1
a394 2

    return rb_str_new2(kcode);
@


1.26
log
@2000-06-16
@
text
@d1148 1
@


1.25
log
@2000-06-14
@
text
@d1358 1
a1370 1
    rb_define_method(rb_cRegexp, "last_match", match_getter, 0);
@


1.24
log
@2000-06-13
@
text
@d74 3
a76 2
rb_str_cicmp(str1, str2)
    VALUE str1, str2;
d78 1
a78 2
    int len, i;
    char *p1, *p2;
d80 3
a82 2
    len = MIN(RSTRING(str1)->len, RSTRING(str2)->len);
    p1 = RSTRING(str1)->ptr; p2 = RSTRING(str2)->ptr;
d84 3
a86 3
    for (i = 0; i < len; i++, p1++, p2++) {
	if (casetable[(unsigned)*p1] != casetable[(unsigned)*p2])
	    return casetable[(unsigned)*p1] - casetable[(unsigned)*p2];
d88 7
a94 1
    return RSTRING(str1)->len - RSTRING(str2)->len;
@


1.23
log
@2000-06-12
@
text
@d523 1
d526 11
a536 8
    /* case-flag not set for the object */
    if (!(RREGEXP(re)->ptr->options & RE_OPTION_IGNORECASE)) {
	int state = FL_TEST(re, REG_CASESTATE);

	if ((ruby_ignorecase || state) && !(ruby_ignorecase && state))  {
	    RBASIC(re)->flags ^= REG_CASESTATE;
	    need_recompile = 1;
	}
@


1.22
log
@2000-05-30
@
text
@d616 1
a616 1
		  "Stack overfow in regexp matcher", re);
@


1.21
log
@inspect,to_s dump core
@
text
@d214 1
a214 1
    int slash = 0;
d218 2
a219 2
	if (*p == '/') {
	    slash = 1;
d224 1
a224 1
    if (!slash) {
d235 8
d244 28
a271 1
		rb_str_cat(str, p, 1);
@


1.20
log
@2000-05-24
@
text
@a250 1
    rb_reg_check(re);
d254 1
d257 2
a258 1
	if (RREGEXP(re)->ptr->options & RE_OPTION_POSIXLINE)
@


1.19
log
@regex initialize bug
@
text
@d1063 1
a1063 1
    int kcode = 0;
d1067 1
a1067 1
	kcode |= 16; break;
d1069 1
a1069 1
	kcode |= 32; break;
d1071 1
a1071 1
	kcode |= 48; break;
d1073 1
a1073 1
	kcode |= 64; break;
d1075 1
a1075 1
	break;
a1076 2

    return kcode;
@


1.18
log
@/p is back for transit
@
text
@d777 4
a780 4
				/* CODE_NONE = 8 */
				/* CODE_EUC  = 16 */
				/* CODE_SJIS = 24 */
				/* CODE_UTF8 = 32 */
d789 1
a789 1
    switch (options & ~0x7) {
d953 1
a953 1
	    flag |= 8;
d956 1
a956 1
	    flag |= 16;
d959 1
a959 1
	    flag |= 24;
d962 1
a962 1
	    flag |= 32;
d991 1
d1067 1
a1067 1
	kcode |= 4; break;
d1069 1
a1069 1
	kcode |= 8; break;
d1071 1
a1071 1
	kcode |= 12; break;
d1073 1
a1073 1
	kcode |= 16; break;
@


1.17
log
@/p is back for transit
@
text
@d794 1
a794 1
      case 8:
d797 1
a797 1
      case 16:
d800 1
a800 1
      case 24:
d803 1
a803 1
      case 32:
d808 1
a808 1
    if (options & ~0x7) {
d815 1
a815 1
    re->ptr = make_regexp(s, len, options & 0x7);
d820 1
a820 1
    if (options & ~0x7) {
@


1.16
log
@2000-05-18
@
text
@a90 4
#define REG_IGNORECASE FL_USER1
#define REG_EXTENDED   FL_USER2
#define REG_MULTILINE  FL_USER3

d92 4
a95 4
#define KCODE_EUC   FL_USER4
#define KCODE_SJIS  FL_USER5
#define KCODE_UTF8  FL_USER6
#define KCODE_FIXED FL_USER7
d101 2
a102 2
kcode_euc(reg)
    struct RRegexp *reg;
d104 3
a106 3
    FL_UNSET(reg, KCODE_MASK);
    FL_SET(reg, KCODE_EUC);
    FL_SET(reg, KCODE_FIXED);
d110 2
a111 2
kcode_sjis(reg)
    struct RRegexp *reg;
d113 3
a115 3
    FL_UNSET(reg, KCODE_MASK);
    FL_SET(reg, KCODE_SJIS);
    FL_SET(reg, KCODE_FIXED);
d119 2
a120 2
kcode_utf8(reg)
    struct RRegexp *reg;
d122 3
a124 3
    FL_UNSET(reg, KCODE_MASK);
    FL_SET(reg, KCODE_UTF8);
    FL_SET(reg, KCODE_FIXED);
d128 2
a129 2
kcode_none(reg)
    struct RRegexp *reg;
d131 2
a132 2
    FL_UNSET(reg, KCODE_MASK);
    FL_SET(reg, KCODE_FIXED);
d138 2
a139 2
kcode_set_option(reg)
    VALUE reg;
d141 1
a141 1
    if (!FL_TEST(reg, KCODE_FIXED)) return;
d143 1
a143 1
    curr_kcode = RBASIC(reg)->flags & KCODE_MASK;
d196 9
d250 2
d255 5
a259 1
	if (FL_TEST(re, REG_IGNORECASE))
d261 1
a261 1
	if (FL_TEST(re, REG_EXTENDED))
d263 1
a263 2
	if (FL_TEST(re, REG_MULTILINE))
	    rb_str_cat2(str, "m");
d289 4
a292 1
    VALUE str = rb_str_new(RREGEXP(re)->str,RREGEXP(re)->len);
d301 1
d324 2
a325 1
    if (FL_TEST(re, REG_IGNORECASE)) return Qtrue;
d405 1
a405 1
    OBJSETUP(clone, rb_cMatch, T_MATCH);
a412 1
    CLONESETUP(clone, match);
d483 2
a484 2
rb_reg_prepare_re(reg)
    VALUE reg;
d488 1
d490 2
a491 2
    if (!FL_TEST(reg, REG_IGNORECASE)) {
	int state = FL_TEST(reg, REG_CASESTATE);
d494 1
a494 1
	    RBASIC(reg)->flags ^= REG_CASESTATE;
d499 2
a500 2
    if (!FL_TEST(reg, KCODE_FIXED) &&
	(RBASIC(reg)->flags & KCODE_MASK) != reg_kcode) {
d502 2
a503 2
	RBASIC(reg)->flags &= ~KCODE_MASK;
	RBASIC(reg)->flags |= reg_kcode;
d509 5
a513 4
	if (FL_TEST(reg, KCODE_FIXED))
	    kcode_set_option(reg);
	RREGEXP(reg)->ptr->fastmap_accurate = 0;
	err = re_compile_pattern(RREGEXP(reg)->str, RREGEXP(reg)->len, RREGEXP(reg)->ptr);
d515 1
a515 1
	    rb_reg_raise(RREGEXP(reg)->str, RREGEXP(reg)->len, err, reg);
d521 2
a522 2
rb_reg_adjust_startpos(reg, str, pos, reverse)
    VALUE reg, str;
d527 2
a528 2
    if (may_need_recompile)
	rb_reg_prepare_re(reg);
d530 2
a531 2
    if (FL_TEST(reg, KCODE_FIXED))
	kcode_set_option(reg);
d541 1
a541 1
    return re_adjust_startpos(RREGEXP(reg)->ptr,
d547 2
a548 2
rb_reg_search(reg, str, pos, reverse)
    VALUE reg, str;
d558 2
a559 2
    if (may_need_recompile)
	rb_reg_prepare_re(reg);
d561 2
a562 2
    if (FL_TEST(reg, KCODE_FIXED))
	kcode_set_option(reg);
d572 1
a572 1
    result = re_search(RREGEXP(reg)->ptr,RSTRING(str)->ptr,RSTRING(str)->len,
d575 1
a575 1
    if (FL_TEST(reg, KCODE_FIXED))
d579 2
a580 2
	rb_reg_raise(RREGEXP(reg)->str, RREGEXP(reg)->len,
		  "Stack overfow in regexp matcher", reg);
d601 1
a601 1
    OBJ_INFECT(match, reg);
d769 3
a771 3
static VALUE
rb_reg_new_1(klass, s, len, options)
    VALUE klass;
d782 4
a785 2
    NEWOBJ(re, struct RRegexp);
    OBJSETUP(re, klass, T_REGEXP);
a788 9
    if (options & RE_OPTION_IGNORECASE) {
	FL_SET(re, REG_IGNORECASE);
    }
    if (options & RE_OPTION_EXTENDED) {
	FL_SET(re, REG_EXTENDED);
    }
    if (options & RE_OPTION_MULTILINE) {
	FL_SET(re, REG_MULTILINE);
    }
a822 2

    return (VALUE)re;
d831 6
a836 1
    return rb_reg_new_1(rb_cRegexp, s, len, options);
d877 1
d883 2
a884 1
	!(FL_TEST(re1,REG_IGNORECASE) ^ FL_TEST(re2,REG_IGNORECASE))) {
d933 1
a933 1
rb_reg_s_new(argc, argv, self)
d971 2
a972 1
	return rb_reg_new_1(self, RREGEXP(src)->str, RREGEXP(src)->len, flag);
d979 1
a979 1
	return rb_reg_new_1(self, p, len, flag);
d984 12
d1086 2
a1087 1
    if (FL_TEST(re, REG_IGNORECASE)) 
d1096 2
a1097 2
rb_reg_clone(reg)
    VALUE reg;
d1099 6
a1104 6
    VALUE clone;
    
    clone = rb_reg_new_1(CLASS_OF(reg), RREGEXP(reg)->str, RREGEXP(reg)->len,
			 rb_reg_options(reg));
    CLONESETUP(clone, reg);
    return clone;
d1313 1
@


1.15
log
@thread problems
@
text
@a92 1
#define REG_POSIXLINE  FL_USER3
a1298 1
    rb_define_const(rb_cRegexp, "POSIXLINE", INT2FIX(RE_OPTION_POSIXLINE));
@


1.14
log
@2000-05-01
@
text
@d94 1
d253 2
a254 2
	if (FL_TEST(re, REG_POSIXLINE))
	    rb_str_cat2(str, "p");
d761 1
a761 1
				/* POSIXLINE = 4 */
d778 2
a779 2
    if (options & RE_OPTION_POSIXLINE) {
	FL_SET(re, REG_POSIXLINE);
d1301 1
@


1.13
log
@2000-04-10
@
text
@d1 1
a1 1
/************************************************
d10 1
a10 1
************************************************/
d187 1
a187 1
    unsigned char c;
@


1.12
log
@2000-03-07
@
text
@d246 1
a246 1
    rb_str_cat(str, "/", 1);
d249 1
a249 1
	    rb_str_cat(str, "i", 1);
d251 1
a251 1
	    rb_str_cat(str, "x", 1);
d253 1
a253 1
	    rb_str_cat(str, "p", 1);
d257 1
a257 1
		rb_str_cat(str, "n", 1);
d260 1
a260 1
		rb_str_cat(str, "e", 1);
d263 1
a263 1
		rb_str_cat(str, "s", 1);
d266 1
a266 1
		rb_str_cat(str, "u", 1);
@


1.11
log
@2000-02-23
@
text
@d1295 1
@


1.10
log
@2000-02-08
@
text
@d271 1
d1302 2
a1303 1
    rb_cMatch  = rb_define_class("MatchingData", rb_cObject);
@


1.9
log
@20000105
@
text
@d186 1
a186 1
rb_mbclen2(c, re)
d458 1
a458 1
rb_match_busy(match, busy)
a459 1
    int busy;
d461 1
a461 6
    if (busy) {
	FL_SET(match, MATCH_BUSY);
    }
    else {
	FL_UNSET(match, MATCH_BUSY);
    }
a465 1
static VALUE matchcache;
d536 1
a536 1
    struct re_registers *regs = 0;
a548 17
    if (rb_thread_scope_shared_p()) {
	match = Qnil;
    }
    else {
	match = rb_backref_get();
    }
    if (NIL_P(match) || FL_TEST(match, MATCH_BUSY)) {
	if (matchcache) {
	    match = matchcache;
	    matchcache = 0;
	}
	else {
	    match = match_alloc();
	}
    }
    regs = RMATCH(match)->regs;

d556 1
a556 1
		       pos, range, regs);
d565 1
a566 2
	FL_UNSET(match, FL_TAINT);
	matchcache = match;
d568 5
d575 4
a578 2
	RMATCH(match)->str = rb_str_new4(str);
	rb_backref_set(match);
d580 3
d1138 1
d1236 2
a1237 1
    return match_clone(match);
a1299 1
    rb_global_variable(&matchcache);
@


1.8
log
@19991214
@
text
@d8 1
a8 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d314 1
a314 1
rb_reg_kcode_method(re)
d385 2
a386 2
match_clone(orig)
    VALUE orig;
d388 2
a389 2
    NEWOBJ(match, struct RMatch);
    OBJSETUP(match, rb_cMatch, T_MATCH);
d391 2
a392 2
    match->str = RMATCH(orig)->str;
    match->regs = 0;
d394 4
a397 4
    match->regs = ALLOC(struct re_registers);
    match->regs->allocated = 0;
    re_copy_registers(match->regs, RMATCH(orig)->regs);
    CLONESETUP(match, orig);
d399 1
a399 1
    return (VALUE)match;
d590 1
d599 2
d622 1
d633 3
a635 1
    return rb_str_new(RSTRING(RMATCH(match)->str)->ptr + start, len);
d754 1
d923 1
a923 1
rb_reg_match_method(re, str)
d977 1
a977 1
	p = str2cstr(src, &len);
d999 1
a999 1
    s = str2cstr(str, &len);
d1082 2
a1083 2
rb_reg_clone(orig)
    VALUE orig;
d1085 1
a1085 1
    VALUE reg;
d1087 4
a1090 4
    reg = rb_reg_new_1(CLASS_OF(orig), RREGEXP(orig)->str, RREGEXP(orig)->len,
		       rb_reg_options(orig));
    CLONESETUP(reg, orig);
    return reg;
d1302 1
a1302 1
    rb_define_method(rb_cRegexp, "match", rb_reg_match_method, 1);
d1306 1
a1306 1
    rb_define_method(rb_cRegexp, "kcode", rb_reg_kcode_method, 0);
@


1.7
log
@19991201
@
text
@d511 26
@


1.6
log
@19991117
@
text
@d278 3
a280 1
    return rb_str_new(RREGEXP(re)->str,RREGEXP(re)->len);
d720 2
a721 1
    if (NIL_P(str)) return rb_str_new(0,0);
@


1.5
log
@19991104
@
text
@d278 1
a278 4
    VALUE str = rb_str_new(0,0);
    rb_reg_expr_str(str, RREGEXP(re)->str, RREGEXP(re)->len);

    return str;
@


1.4
log
@-r debug, -s, etc.
@
text
@d185 15
d556 1
@


1.3
log
@1.4.1
@
text
@d264 1
a264 1
    rb_reg_expr_str(str, RREGEXP(re)->str,RREGEXP(re)->len);
d713 1
a713 1
    return rb_str_dup(RMATCH(match)->str);
d1266 3
a1268 1
    rb_cMatch  = rb_define_class("MatchingData", rb_cData);
@


1.3.2.1
log
@19991117
@
text
@a184 15
int
rb_mbclen2(c, re)
    unsigned char c;
    VALUE re;
{
    int len;

    if (!FL_TEST(re, KCODE_FIXED))
	return mbclen(c);
    kcode_set_option(re);
    len = mbclen(c);
    kcode_reset_option();
    return len;
}

d263 4
a266 1
    return rb_str_new(RREGEXP(re)->str,RREGEXP(re)->len);
a540 1

d713 1
a713 1
    return RMATCH(match)->str;	/* str is frozen */
d1266 1
a1266 3
    rb_cMatch  = rb_define_class("MatchingData", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cMatch), "new");

@


1.3.2.2
log
@19991201
@
text
@d278 1
a278 3
    VALUE str = rb_str_new(RREGEXP(re)->str,RREGEXP(re)->len);
    if (OBJ_TAINTED(re)) OBJ_TAINT(str);
    return str;
@


1.3.2.3
log
@2000-01-17
@
text
@d8 1
a8 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.3.2.4
log
@2000-05-01
@
text
@d187 1
a187 1
    unsigned int c;
@


1.3.2.5
log
@2000-06-13
@
text
@d480 8
a487 14
    int state;

    rb_reg_check(re);
    state = FL_TEST(re, REG_CASESTATE);
    /* ignorecase status */
    if (ruby_ignorecase && !state) {
	FL_SET(re, REG_CASESTATE);
	RREGEXP(re)->ptr->options |= RE_OPTION_IGNORECASE;
	need_recompile = 1;
    }
    if (!ruby_ignorecase && state) {
	FL_UNSET(re, REG_CASESTATE);
	RREGEXP(re)->ptr->options &= ~RE_OPTION_IGNORECASE;
	need_recompile = 1;
d561 1
a561 1
		  "Stack overflow in regexp matcher", reg);
@


1.3.2.6
log
@2000-06-14
@
text
@a199 9
static void
rb_reg_check(re)
    VALUE re;
{
    if (!RREGEXP(re)->ptr || !RREGEXP(re)->str) {
	rb_raise(rb_eTypeError, "uninitialized Regexp");
    }
}

d475 2
a476 2
rb_reg_prepare_re(re)
    VALUE re;
d496 2
a497 2
    if (!FL_TEST(re, KCODE_FIXED) &&
	(RBASIC(re)->flags & KCODE_MASK) != reg_kcode) {
d499 2
a500 2
	RBASIC(re)->flags &= ~KCODE_MASK;
	RBASIC(re)->flags |= reg_kcode;
d506 4
a509 4
	if (FL_TEST(re, KCODE_FIXED))
	    kcode_set_option(re);
	RREGEXP(re)->ptr->fastmap_accurate = 0;
	err = re_compile_pattern(RREGEXP(re)->str, RREGEXP(re)->len, RREGEXP(re)->ptr);
d511 1
a511 1
	    rb_reg_raise(RREGEXP(re)->str, RREGEXP(re)->len, err, re);
@


1.3.2.7
log
@matz
@
text
@d5 1
a5 1
  $Author: eban $
d985 1
a985 1
    for (; s < send; s++) {
d989 1
a989 1
	    while (n-- && s < send)
@


1.3.2.8
log
@matz
@
text
@d5 1
a5 1
  $Author: matz $
d910 1
a910 3
    result = rb_backref_get();
    rb_match_busy(result, Qtrue);
    return result;
@


1.2
log
@1.4.0
@
text
@d967 1
a967 1
	    || *s == '|'
@


1.1
log
@Initial revision
@
text
@a5 1
  $Date: 1996/12/25 10:42:49 $
d8 1
a8 1
  Copyright (C) 1993-1996 Yukihiro Matsumoto
d15 1
a15 1
static VALUE eRegxpError;
d21 1
a21 1
static char casetable[] = {
d71 1
a71 1
#define min(a,b) (((a)>(b))?(b):(a))
d74 2
a75 2
str_cicmp(str1, str2)
    struct RString *str1, *str2;
d80 2
a81 2
    len = min(str1->len, str2->len);
    p1 = str1->ptr; p2 = str2->ptr;
d87 1
a87 1
    return str1->len - str2->len;
d90 4
a93 1
#define REG_IGNORECASE FL_USER0
d96 7
a102 15
#define KCODE_EUC   FL_USER2
#define KCODE_SJIS  FL_USER3
#define KCODE_FIXED FL_USER4
#define KCODE_MASK (KCODE_EUC|KCODE_SJIS)

static int reg_kcode = 
#ifdef EUC
    KCODE_EUC;
#else
# ifdef SJIS
    KCODE_SJIS;
# else
    KCODE_NONE;
# endif
#endif
d123 9
d139 2
d143 1
a143 1
    struct RRegexp *reg;
d147 3
a149 2
    re_syntax_options &= ~RE_MBCTYPE_MASK;
    switch ((RBASIC(reg)->flags & KCODE_MASK)) {
d151 1
d154 1
a154 1
	re_syntax_options |= RE_MBCTYPE_EUC;
d157 4
a160 1
	re_syntax_options |= RE_MBCTYPE_SJIS;
a162 1
    re_set_syntax(re_syntax_options);
d168 1
a168 1
    re_syntax_options &= ~RE_MBCTYPE_MASK;
d171 1
d174 1
a174 1
	re_syntax_options |= RE_MBCTYPE_EUC;
d177 4
a180 1
	re_syntax_options |= RE_MBCTYPE_SJIS;
a182 1
    re_set_syntax(re_syntax_options);
d185 1
a185 1
extern int rb_in_eval;
d187 4
a190 3
static VALUE
reg_desc(s, len, re)
    char *s;
a191 1
    VALUE re;
d193 1
a193 2
    VALUE str = str_new2("/");
    char *p, *pend;
d205 1
a205 1
	str_cat(str, s, len);
d212 2
a213 2
		str_cat(str, &c, 1);
		str_cat(str, p, 1);
d216 1
a216 1
		str_cat(str, p, 1);
d221 11
a231 1
    str_cat(str, "/", 1);
d233 21
a253 2
	if (FL_TEST(re, REG_IGNORECASE)) {
	    str_cat(str, "i", 1);
d260 12
a271 2
reg_inspect(re)
    struct RRegexp *re;
d273 1
a273 1
    return reg_desc(re->str, re->len, re);
d277 2
a278 2
reg_raise(s, len, err, re)
    char *s;
d280 1
a280 1
    char *err;
d283 1
a283 1
    VALUE desc = reg_desc(s, len, re);
d285 2
a286 2
    if (rb_in_eval)
	Raise(eRegxpError, "%s: %s", err, RSTRING(desc)->ptr);
d288 33
a320 1
	Error("%s: %s", err, RSTRING(desc)->ptr);
d325 1
a325 1
    char *s;
d344 1
a344 1
	rp->translate = casetable;
d346 1
a346 2
    err = re_compile_pattern(s, (size_t)len, rp);
    kcode_reset_option();
d348 1
a348 1
	reg_raise(s, len, err, 0);
d354 1
a354 2
extern VALUE cData;
static VALUE cMatch;
d360 1
a360 1
    OBJSETUP(match, cMatch, T_MATCH);
d363 1
d370 17
a386 1
VALUE ignorecase;
d388 41
a428 6
int
reg_search(reg, str, start, regs)
    struct RRegexp *reg;
    struct RString *str;
    int start;
    struct re_registers *regs;
d430 7
a436 5
    int result;
    int casefold = RTEST(ignorecase);
    VALUE match = 0;
    struct re_registers *regs0 = 0;
    int need_recompile = 0;
d438 2
a439 1
    if (start > str->len) return -1;
d441 1
a441 16
    /* case-flag set for the object */
    if (FL_TEST(reg, REG_IGNORECASE)) {
	casefold = TRUE;
    }
    if (casefold) {
	if (reg->ptr->translate != casetable) {
	    reg->ptr->translate = casetable;
	    reg->ptr->fastmap_accurate = 0;
	    need_recompile = 1;
	}
    }
    else if (reg->ptr->translate) {
	reg->ptr->translate = NULL;
	reg->ptr->fastmap_accurate = 0;
	need_recompile = 1;
    }
d443 7
a449 2
    if (regs == (struct re_registers*)-1) {
	regs = 0;
d452 1
a452 2
	match = match_alloc();
	regs0 = RMATCH(match)->regs;
d454 11
d466 3
a468 1
    if (regs && !match) regs0 = regs;
d470 4
a473 2
    if (FL_TEST(reg, KCODE_FIXED)) {
	kcode_set_option(reg);
d475 3
a477 1
    else if ((RBASIC(reg)->flags & KCODE_MASK) != reg_kcode) {
d479 1
a479 1
	RBASIC(reg)->flags = RBASIC(reg)->flags & ~KCODE_MASK;
d486 4
a489 1
	err = re_compile_pattern(reg->str, reg->len, reg->ptr);
d491 1
a491 2
	    kcode_reset_option();
	    reg_raise(reg->str, reg->len, err, reg);
d494 1
d496 36
a531 3
    result = re_search(reg->ptr, str->ptr, str->len,
		       start, str->len - start, regs0);
    kcode_reset_option();
d533 14
a546 2
    if (start == -2) {
	reg_raise(reg->str, reg->len, "Stack overfow in regexp matcher", reg);
d549 2
a550 1
	backref_set(Qnil);
d552 3
a554 3
    else if (match) {
	RMATCH(match)->str = str_new4(str);
	backref_set(match);
a555 1
    if (regs && regs0 && regs0 != regs) re_copy_registers(regs, regs0);
d561 1
a561 1
reg_nth_defined(nth, match)
d563 1
a563 1
    struct RMatch *match;
d566 2
a567 2
    if (nth >= match->regs->num_regs) {
	return FALSE;
d569 2
a570 2
    if (match->BEG(nth) == -1) return FALSE;
    return TRUE;
d574 1
a574 1
reg_nth_match(nth, match)
d576 1
a576 1
    struct RMatch *match;
d581 1
a581 1
    if (nth >= match->regs->num_regs) {
d584 1
a584 1
    start = match->BEG(nth);
d586 1
a586 1
    end = match->END(nth);
d588 1
a588 1
    return str_new(RSTRING(match->str)->ptr + start, len);
d592 2
a593 2
reg_last_match(match)
    struct RMatch *match;
d595 1
a595 1
    return reg_nth_match(0, match);
d599 2
a600 2
reg_match_pre(match)
    struct RMatch *match;
d603 2
a604 2
    if (match->BEG(0) == -1) return Qnil;
    return str_new(RSTRING(match->str)->ptr, match->BEG(0));
d608 2
a609 2
reg_match_post(match)
    struct RMatch *match;
d612 3
a614 3
    if (match->BEG(0) == -1) return Qnil;
    return str_new(RSTRING(match->str)->ptr+match->END(0),
		   RSTRING(match->str)->len-match->END(0));
d618 2
a619 2
reg_match_last(match)
    struct RMatch *match;
d624 1
a624 1
    if (match->BEG(0) == -1) return Qnil;
d626 1
a626 1
    for (i=match->regs->num_regs-1; match->BEG(i) == -1 && i > 0; i--)
d629 1
a629 1
    return reg_nth_match(i, match);
d635 1
a635 1
    return reg_last_match(backref_get());
d641 1
a641 1
    return reg_match_pre(backref_get());
d647 1
a647 1
    return reg_match_post(backref_get());
d653 1
a653 1
    return reg_match_last(backref_get());
d658 1
a658 1
    struct RMatch *match;
d660 3
a662 3
    struct re_registers *regs = match->regs;
    VALUE ary = ary_new(regs->num_regs);
    char *ptr = RSTRING(match->str)->ptr;
d666 2
a667 2
	if (regs->beg[0] == -1) ary_push(ary, Qnil);
	else ary_push(ary, str_new(ptr+regs->beg[i],
d674 26
d701 1
a701 1
    struct RMatch *match;
d703 1
a703 1
    VALUE str = reg_last_match(match);
d705 1
a705 1
    if (NIL_P(str)) return str_new(0,0);
d709 3
a711 3
void
reg_free(rp)
Regexp *rp;
d713 1
a713 3
    free(rp->buffer);
    free(rp->fastmap);
    free(rp);
d716 1
a716 1
VALUE cRegexp;
d719 3
a721 3
reg_new_1(class, s, len, flag)
    VALUE class;
    char *s;
d723 7
a729 4
    int flag;			/* CASEFOLD  = 0x1 */
				/* CODE_NONE = 0x2 */
				/* CODE_EUC  = 0x4 */
				/* CODE_SJIS = 0x6 */
d732 3
a734 1
    OBJSETUP(re, class, T_REGEXP);
d736 1
a736 1
    if (flag & 0x1) {
d739 7
a745 1
    switch (flag & ~0x1) {
d750 1
a750 1
      case 2:
d753 1
a753 1
      case 4:
d756 1
a756 1
      case 6:
d759 3
d764 8
a771 2
    kcode_set_option(re);
    re->ptr = make_regexp(s, len, flag & 0x1);
d776 3
d784 4
a787 3
reg_new(s, len, flag)
    char *s;
    int len, flag;
d789 1
a789 1
    return reg_new_1(cRegexp, s, len, flag);
d792 2
a793 1
static int ign_cache;
d797 18
a814 2
reg_regcomp(str)
    struct RString *str;
d816 5
a820 1
    int ignc = RTEST(ignorecase);
d822 5
a826 4
    if (reg_cache && RREGEXP(reg_cache)->len == str->len
	&& ign_cache == ignc
	&& memcmp(RREGEXP(reg_cache)->str, str->ptr, str->len) == 0)
	return reg_cache;
d828 11
a838 2
    ign_cache = ignc;
    return reg_cache = reg_new(str->ptr, str->len, ignc);
d842 2
a843 3
reg_match(re, str)
    struct RRegexp *re;
    struct RString *str;
d847 3
a849 2
    if (TYPE(str) != T_STRING) return FALSE;
    start = reg_search(re, str, 0, 0);
d851 1
a851 1
	return FALSE;
d857 2
a858 2
reg_match2(re)
    struct RRegexp *re;
d861 1
a861 1
    VALUE line = lastline_get();
d864 1
a864 1
	return FALSE;
d866 1
a866 1
    start = reg_search(re, line, 0, 0);
d868 1
a868 1
	return FALSE;
d874 11
a884 1
reg_s_new(argc, argv, self)
d893 1
a893 1
	ArgError("wrong # of argument");
d895 3
a897 2
    if (argc >= 2 && RTEST(argv[1])) {
	flag = 1;
d900 3
a902 2
	Check_Type(argv[2], T_STRING);
	switch (RSTRING(argv[2])->ptr[0]) {
d904 1
a904 1
	    flag |= 2;
d907 1
a907 1
	    flag |= 4;
d910 4
a913 1
	    flag |= 6;
d921 11
a931 4
    switch (TYPE(src)) {
      case T_STRING:
	return reg_new_1(self, RSTRING(src)->ptr, RSTRING(src)->len, flag);
	break;
d933 10
a942 3
      case T_REGEXP:
	return reg_new_1(self, RREGEXP(src)->str, RREGEXP(src)->len, flag);
	break;
d944 30
a973 2
      default:
	Check_Type(src, T_STRING);
d975 1
d977 17
a993 1
    return Qnil;
d996 2
a997 2
static VALUE
reg_s_quote(re, str)
a998 1
    struct RString *str;
d1000 1
a1000 2
  char *s, *send, *t;
  char *tmp;
d1002 12
a1013 1
  Check_Type(str, T_STRING);
d1015 2
a1016 1
  tmp = ALLOCA_N(char, str->len*2);
d1018 5
a1022 2
  s = str->ptr; send = s + str->len;
  t = tmp;
d1024 4
a1027 11
  for (; s != send; s++) {
      if (*s == '[' || *s == ']'
	  || *s == '{' || *s == '}'
	  || *s == '(' || *s == ')'
	  || *s == '|'
	  || *s == '*' || *s == '.' || *s == '\\'
	  || *s == '?' || *s == '+'
	  || *s == '^' || *s == '$') {
	  *t++ = '\\';
      }
      *t++ = *s;
d1029 1
a1029 2

  return str_new(tmp, t - tmp);
d1033 2
a1034 2
reg_clone(re)
    struct RRegexp *re;
d1036 6
a1041 14
    int flag = FL_TEST(re, REG_IGNORECASE);
    if (FL_TEST(re, KCODE_FIXED)) {
	switch (RBASIC(re)->flags & KCODE_MASK) {
	  case KCODE_NONE:
	    flag |= 2; break;
	  case KCODE_EUC:
	    flag |= 4; break;
	  case KCODE_SJIS:
	    flag |= 6; break;
	  default:
	    break;
	}
    }
    return reg_new_1(CLASS_OF(re), re->str, re->len, flag);
d1045 2
a1046 3
reg_regsub(str, src, regs)
    struct RString *str;
    struct RString *src;
a1049 1
    VALUE tmp;
d1053 2
a1054 2
    p = s = str->ptr;
    e = s + str->len;
d1060 5
a1064 1
	if (c != '\\') continue;
d1066 2
a1067 2
	if (!val) val = str_new(p, ss-p);
	else      str_cat(val, p, ss-p);
d1081 1
a1081 1
	    str_cat(val, src->ptr, BEG(0));
d1085 1
a1085 1
	    str_cat(val, src->ptr+END(0), src->len-END(0));
d1095 1
a1095 1
	    str_cat(val, s-1, 1);
d1099 1
a1099 1
	    str_cat(val, s-2, 2);
d1105 1
a1105 1
	    str_cat(val, src->ptr+BEG(no), END(no)-BEG(no));
d1110 2
a1111 2
	if (!val) val = str_new(p, e-p);
	else      str_cat(val, p, e-p);
d1113 1
a1113 1
    if (!val) return (VALUE)str;
d1118 2
a1119 2
static VALUE
kcode_getter()
d1123 1
a1123 1
	return str_new2("SJIS");
d1125 3
a1127 1
	return str_new2("EUC");
d1129 1
a1129 1
	return str_new2("NONE");
d1133 6
d1141 1
a1141 1
    char *code;
a1142 1
    re_syntax_options &= ~RE_MBCTYPE_MASK;
d1149 1
a1149 1
	re_syntax_options |= RE_MBCTYPE_EUC;
d1154 6
a1159 1
	re_syntax_options |= RE_MBCTYPE_SJIS;
d1164 2
d1168 1
a1170 1
    re_set_syntax(re_syntax_options);
d1177 16
a1192 2
    Check_Type(val, T_STRING);
    rb_set_kcode(val->ptr);
d1198 4
a1201 1
    return backref_get();
d1209 1
a1209 1
    backref_set(val);
a1211 2
VALUE any_to_s();

d1215 1
a1215 1
    extern VALUE eException;
d1217 13
a1229 9
    eRegxpError = rb_define_class("RegxpError", eException);

    re_set_syntax(RE_NO_BK_PARENS | RE_NO_BK_VBAR
		  | RE_INTERVALS
		  | RE_NO_BK_BRACES
		  | RE_CONTEXTUAL_INVALID_OPS
		  | RE_BACKSLASH_ESCAPE_IN_LISTS
#ifdef DEFAULT_MBCTYPE
		  | DEFAULT_MBCTYPE
a1230 1
);
d1238 1
a1238 1
    rb_define_variable("$=", &ignorecase);
d1242 20
a1261 10
    cRegexp  = rb_define_class("Regexp", cObject);
    rb_define_singleton_method(cRegexp, "new", reg_s_new, -1);
    rb_define_singleton_method(cRegexp, "compile", reg_s_new, -1);
    rb_define_singleton_method(cRegexp, "quote", reg_s_quote, 1);

    rb_define_method(cRegexp, "clone", reg_clone, 0);
    rb_define_method(cRegexp, "=~", reg_match, 1);
    rb_define_method(cRegexp, "===", reg_match, 1);
    rb_define_method(cRegexp, "~", reg_match2, 0);
    rb_define_method(cRegexp, "inspect", reg_inspect, 0);
d1264 1
d1266 14
a1279 4
    cMatch  = rb_define_class("MatchingData", cData);
    rb_define_method(cMatch, "to_a", match_to_a, 0);
    rb_define_method(cMatch, "to_s", match_to_s, 0);
    rb_define_method(cMatch, "inspect", any_to_s, 0);
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d76 1
a76 1
    VALUE str1, str2;
d81 2
a82 2
    len = min(RSTRING(str1)->len, RSTRING(str2)->len);
    p1 = RSTRING(str1)->ptr; p2 = RSTRING(str2)->ptr;
d88 1
a88 1
    return RSTRING(str1)->len - RSTRING(str2)->len;
d112 1
a112 1
    VALUE reg;
d121 1
a121 1
    VALUE reg;
d130 1
a130 1
    VALUE reg;
d138 1
a138 1
    VALUE reg;
d156 1
a156 1
void
d175 2
a176 3
static void
reg_expr_str(str, s, len)
    VALUE str;
d179 1
d181 1
a209 10
}

static VALUE
reg_desc(s, len, re)
    char *s;
    int len;
    VALUE re;
{
    VALUE str = str_new2("/");
    reg_expr_str(str, s, len);
d212 1
a212 1
	if (FL_TEST(re,REG_IGNORECASE))
a213 12
	if (FL_TEST(re,KCODE_FIXED)) {
	    switch ((RBASIC(re)->flags & KCODE_MASK)) {
	      case KCODE_NONE:
		str_cat(str, "n", 1);
		break;
	      case KCODE_EUC:
		str_cat(str, "e", 1);
		break;
	      case KCODE_SJIS:
		str_cat(str, "s", 1);
		break;
	    }
a219 10
reg_source(re)
    VALUE re;
{
    VALUE str = str_new(0,0);
    reg_expr_str(str, RREGEXP(re)->str,RREGEXP(re)->len,re);

    return str;
}

static VALUE
d221 1
a221 1
    VALUE re;
d223 1
a223 1
    return reg_desc(RREGEXP(re)->str, RREGEXP(re)->len, re);
a240 30
static VALUE
reg_casefold_p(re)
    VALUE re;
{
    if (FL_TEST(re, REG_IGNORECASE)) return TRUE;
    return FALSE;
}

static VALUE
reg_kcode_method(re)
    VALUE re;
{
    char *kcode = "$KCODE";

    if (FL_TEST(re, KCODE_FIXED)) {
	switch (RBASIC(re)->flags & KCODE_MASK) {
	  case KCODE_NONE:
	    kcode = "none"; break;
	  case KCODE_EUC:
	    kcode = "euc"; break;
	  case KCODE_SJIS:
	    kcode = "sjis"; break;
	  default:
	    break;
	}
    }

    return str_new2(kcode);
}

a288 18
static VALUE
match_clone(orig)
    VALUE orig;
{
    struct re_registers *rr;

    NEWOBJ(match, struct RMatch);
    OBJSETUP(match, cMatch, T_MATCH);

    match->str = RMATCH(orig)->str;

    match->regs = ALLOC(struct re_registers);
    match->regs->allocated = 0;
    re_copy_registers(match->regs, RMATCH(orig)->regs);

    return (VALUE)match;
}

a289 1
static VALUE matchcache;
d291 6
a296 3
void
reg_prepare_re(reg)
    VALUE reg;
d300 2
d304 2
d311 3
a313 3
	if (RREGEXP(reg)->ptr->translate != casetable) {
	    RREGEXP(reg)->ptr->translate = casetable;
	    RREGEXP(reg)->ptr->fastmap_accurate = 0;
d317 3
a319 3
    else if (RREGEXP(reg)->ptr->translate) {
	RREGEXP(reg)->ptr->translate = NULL;
	RREGEXP(reg)->ptr->fastmap_accurate = 0;
d323 10
d345 1
a345 1
	err = re_compile_pattern(RREGEXP(reg)->str, RREGEXP(reg)->len, RREGEXP(reg)->ptr);
d348 1
a348 28
	    reg_raise(RREGEXP(reg)->str, RREGEXP(reg)->len, err, reg);
	}
    }
}

int
reg_search(reg, str, start, regs)
    VALUE reg, str;
    int start;
    struct re_registers *regs;
{
    int result;
    int casefold = RTEST(ignorecase);
    VALUE match = 0;
    struct re_registers *regs0 = 0;
    int need_recompile = 0;

    if (start > RSTRING(str)->len) return -1;

    reg_prepare_re(reg);

    if (regs == (struct re_registers*)-1) {
	regs = 0;
    }
    else {
	if (matchcache) {
	    match = matchcache;
	    matchcache = 0;
a349 4
	else {
	    match = match_alloc();
	}
	regs0 = RMATCH(match)->regs;
d352 2
a353 2
    result = re_search(RREGEXP(reg)->ptr,RSTRING(str)->ptr,RSTRING(str)->len,
		       start,RSTRING(str)->len-start,regs0);
d357 1
a357 2
	reg_raise(RREGEXP(reg)->str, RREGEXP(reg)->len,
		  "Stack overfow in regexp matcher", reg);
a359 1
	matchcache = match;
d366 1
a366 1
    if (regs && regs0) re_copy_registers(regs, regs0);
d374 1
a374 1
    VALUE match;
d377 1
a377 1
    if (nth >= RMATCH(match)->regs->num_regs) {
d380 1
a380 1
    if (RMATCH(match)->BEG(nth) == -1) return FALSE;
d387 1
a387 1
    VALUE match;
d392 1
a392 1
    if (nth >= RMATCH(match)->regs->num_regs) {
d395 1
a395 1
    start = RMATCH(match)->BEG(nth);
d397 1
a397 1
    end = RMATCH(match)->END(nth);
d399 1
a399 1
    return str_new(RSTRING(RMATCH(match)->str)->ptr + start, len);
d404 1
a404 1
    VALUE match;
d411 1
a411 1
    VALUE match;
d414 2
a415 2
    if (RMATCH(match)->BEG(0) == -1) return Qnil;
    return str_new(RSTRING(RMATCH(match)->str)->ptr, RMATCH(match)->BEG(0));
d420 1
a420 1
    VALUE match;
d423 3
a425 3
    if (RMATCH(match)->BEG(0) == -1) return Qnil;
    return str_new(RSTRING(RMATCH(match)->str)->ptr+RMATCH(match)->END(0),
		   RSTRING(RMATCH(match)->str)->len-RMATCH(match)->END(0));
d430 1
a430 1
    VALUE match;
d435 1
a435 1
    if (RMATCH(match)->BEG(0) == -1) return Qnil;
d437 1
a437 1
    for (i=RMATCH(match)->regs->num_regs-1; RMATCH(match)->BEG(i) == -1 && i > 0; i--)
d469 1
a469 1
    VALUE match;
d471 3
a473 3
    struct re_registers *regs = RMATCH(match)->regs;
    VALUE ary = ary_new2(regs->num_regs);
    char *ptr = RSTRING(RMATCH(match)->str)->ptr;
a484 26
match_aref(argc, argv, match)
    int argc;
    VALUE *argv;
    VALUE match;
{
    VALUE idx, rest;
    struct re_registers *regs;
    char *ptr;
    int i;

    rb_scan_args(argc, argv, "11", &idx, &rest);

    if (!NIL_P(rest) || !FIXNUM_P(idx) || FIX2INT(idx) < 0) {
	return ary_aref(argc, argv, match_to_a(match));
    }

    regs = RMATCH(match)->regs;
    i = FIX2INT(idx);

    if (i>=regs->num_regs) return Qnil;

    ptr = RSTRING(RMATCH(match)->str)->ptr;
    return str_new(ptr+regs->beg[i], regs->end[i]-regs->beg[i]);
}

static VALUE
d486 1
a486 1
    VALUE match;
d560 1
a560 1
    VALUE str;
d564 1
a564 1
    if (reg_cache && RREGEXP(reg_cache)->len == RSTRING(str)->len
d566 1
a566 1
	&& memcmp(RREGEXP(reg_cache)->str, RSTRING(str)->ptr, RSTRING(str)->len) == 0)
d570 1
a570 30
    return reg_cache = reg_new(RSTRING(str)->ptr, RSTRING(str)->len, ignc);
}

static int
reg_cur_kcode(re)
    VALUE re;
{
    if (FL_TEST(re, KCODE_FIXED)) {
	return RBASIC(re)->flags & KCODE_MASK;
    }
    return 0;
}

static VALUE
reg_equal(re1, re2)
    VALUE re1, re2;
{
    int min;

    if (re1 == re2) return TRUE;
    if (TYPE(re2) != T_REGEXP) return FALSE;
    if (RREGEXP(re1)->len != RREGEXP(re2)->len) return FALSE;
    min = RREGEXP(re1)->len;
    if (min > RREGEXP(re2)->len) min = RREGEXP(re2)->len;
    if (memcmp(RREGEXP(re1)->str, RREGEXP(re2)->str, min) == 0 &&
	reg_cur_kcode(re1) == reg_cur_kcode(re2) &&
	!(FL_TEST(re1,REG_IGNORECASE) ^ FL_TEST(re2,REG_IGNORECASE))) {
	return TRUE;
    }
    return FALSE;
d575 2
a576 1
    VALUE re, str;
d590 1
a590 1
    VALUE re;
d656 2
a657 1
    VALUE re, str;
d664 1
a664 1
  tmp = ALLOCA_N(char, RSTRING(str)->len*2);
d666 1
a666 1
  s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
a684 20
static int
reg_get_kcode(re)
    VALUE re;
{
    int kcode = 0;

    switch (RBASIC(re)->flags & KCODE_MASK) {
      case KCODE_NONE:
	kcode |= 2; break;
      case KCODE_EUC:
	kcode |= 4; break;
      case KCODE_SJIS:
	kcode |= 6; break;
      default:
	break;
    }

    return kcode;
}

d687 1
a687 1
    VALUE re;
d689 1
a689 2
    int flag = FL_TEST(re, REG_IGNORECASE)?1:0;

d691 10
a700 1
	flag |= reg_get_kcode(re);
d702 1
a702 1
    return reg_new_1(CLASS_OF(re), RREGEXP(re)->str, RREGEXP(re)->len, flag);
d707 2
a708 1
    VALUE str, src;
d716 2
a717 2
    p = s = RSTRING(str)->ptr;
    e = s + RSTRING(str)->len;
d740 1
a740 1
	    str_cat(val, RSTRING(src)->ptr, BEG(0));
d744 1
a744 1
	    str_cat(val, RSTRING(src)->ptr+END(0), RSTRING(src)->len-END(0));
d764 1
a764 1
	    str_cat(val, RSTRING(src)->ptr+BEG(no), END(no)-BEG(no));
a776 35
#define IS_KCODE_FIXED(re) (FL_TEST((re), KCODE_FIXED)?1:0)

static int
reg_prepare_operation(re1, re2)
    VALUE re1, re2;
{
    int flag = 0;

    Check_Type(re2, T_REGEXP);
    flag = IS_KCODE_FIXED(re1)+IS_KCODE_FIXED(re2)*2;
    switch (IS_KCODE_FIXED(re1)+IS_KCODE_FIXED(re2)*2) {
      case 3:			/* both have fixed kcode (must match) */
	if (((RBASIC(re1)->flags^RBASIC(re2)->flags)&KCODE_MASK) != 0) {
	    Raise(eRegxpError, "kanji code mismatch");
	}
	/* fall through */
      case 2:			/* re2 has fixed kcode */
	flag = reg_get_kcode(re2);
	break;
      case 1:			/* re1 has fixed kcode */
	flag = reg_get_kcode(re1);
	break;
      case 0:			/* neither has fixed kcode */
	flag = 0;
	break;
    }

    if (FL_TEST(re1, REG_IGNORECASE) ^ FL_TEST(re2, REG_IGNORECASE)) {
	Raise(eRegxpError, "casefold mismatch");
    }
    if (FL_TEST(re1, REG_IGNORECASE)) flag |= 0x1;

    return flag;
}

d857 1
a857 1
	);
a874 1
    rb_define_method(cRegexp, "==", reg_equal, 1);
a878 3
    rb_define_method(cRegexp, "source", reg_source, 0);
    rb_define_method(cRegexp, "casefold?", reg_casefold_p, 0);
    rb_define_method(cRegexp, "kcode", reg_kcode_method, 0);
a880 1
    rb_global_variable(&matchcache);
a883 1
    rb_define_method(cMatch, "[]", match_aref, -1);
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
d16 1
a16 1
static VALUE rb_eRegxpError;
d72 1
a72 1
#define MIN(a,b) (((a)>(b))?(b):(a))
d75 1
a75 1
rb_str_cicmp(str1, str2)
d81 1
a81 1
    len = MIN(RSTRING(str1)->len, RSTRING(str2)->len);
a91 1
#define REG_CASESTATE  FL_USER1
d96 2
a97 3
#define KCODE_UTF8  FL_USER4
#define KCODE_FIXED FL_USER5
#define KCODE_MASK (KCODE_EUC|KCODE_SJIS|KCODE_UTF8)
d100 1
a100 1
#ifdef RUBY_USE_EUC
d103 1
a103 1
# ifdef RUBY_USE_SJIS
a105 3
#  ifdef RUBY_USE_UTF8
    KCODE_UTF8
#  else
a106 1
#  endif
d112 1
a112 1
    struct RRegexp *reg;
d121 1
a121 1
    struct RRegexp *reg;
a128 9
kcode_utf8(reg)
    struct RRegexp *reg;
{
    FL_UNSET(reg, KCODE_MASK);
    FL_SET(reg, KCODE_UTF8);
    FL_SET(reg, KCODE_FIXED);
}

static void
d130 1
a130 1
    struct RRegexp *reg;
a135 2
static int curr_kcode;

d142 2
a143 3
    curr_kcode = RBASIC(reg)->flags & KCODE_MASK;
    if (reg_kcode == curr_kcode) return;
    switch (curr_kcode) {
a144 1
	re_mbcinit(MBCTYPE_ASCII);
d147 1
a147 1
	re_mbcinit(MBCTYPE_EUC);
d150 1
a150 4
	re_mbcinit(MBCTYPE_SJIS);
	break;
      case KCODE_UTF8:
	re_mbcinit(MBCTYPE_UTF8);
d153 1
d156 1
a156 1
static void
d159 1
a159 1
    if (reg_kcode == curr_kcode) return;
a161 1
	re_mbcinit(MBCTYPE_ASCII);
d164 1
a164 1
	re_mbcinit(MBCTYPE_EUC);
d167 1
a167 4
	re_mbcinit(MBCTYPE_SJIS);
	break;
      case KCODE_UTF8:
	re_mbcinit(MBCTYPE_UTF8);
d170 1
d173 1
a173 1
extern int ruby_in_compile;
d176 1
a176 1
rb_reg_expr_str(str, s, len)
d193 1
a193 1
	rb_str_cat(str, s, len);
d200 2
a201 2
		rb_str_cat(str, &c, 1);
		rb_str_cat(str, p, 1);
d204 1
a204 1
		rb_str_cat(str, p, 1);
d212 1
a212 1
rb_reg_desc(s, len, re)
d217 3
a219 3
    VALUE str = rb_str_new2("/");
    rb_reg_expr_str(str, s, len);
    rb_str_cat(str, "/", 1);
d221 3
a223 3
	if (FL_TEST(re, REG_IGNORECASE))
	    rb_str_cat(str, "i", 1);
	if (FL_TEST(re, KCODE_FIXED)) {
d226 1
a226 1
		rb_str_cat(str, "n", 1);
d229 1
a229 1
		rb_str_cat(str, "e", 1);
d232 1
a232 4
		rb_str_cat(str, "s", 1);
		break;
	      case KCODE_UTF8:
		rb_str_cat(str, "u", 1);
d241 1
a241 1
rb_reg_source(re)
d244 2
a245 2
    VALUE str = rb_str_new(0,0);
    rb_reg_expr_str(str, RREGEXP(re)->str,RREGEXP(re)->len);
d251 1
a251 1
rb_reg_inspect(re)
d254 1
a254 1
    return rb_reg_desc(RREGEXP(re)->str, RREGEXP(re)->len, re);
d258 1
a258 1
rb_reg_raise(s, len, err, re)
d264 1
a264 1
    VALUE desc = rb_reg_desc(s, len, re);
d266 2
a267 2
    if (ruby_in_compile)
	rb_compile_error("%s: %s", err, RSTRING(desc)->ptr);
d269 1
a269 1
	rb_raise(rb_eRegxpError, "%s: %s", err, RSTRING(desc)->ptr);
d273 1
a273 1
rb_reg_casefold_p(re)
d276 2
a277 2
    if (FL_TEST(re, REG_IGNORECASE)) return Qtrue;
    return Qfalse;
d281 1
a281 1
rb_reg_kcode_method(re)
a293 2
	  case KCODE_UTF8:
	    kcode = "utf8"; break;
d299 1
a299 1
    return rb_str_new2(kcode);
d305 1
a305 1
    size_t len, flag;
d323 1
a323 1
	rp->options = flag;
d325 2
a326 1
    err = re_compile_pattern(s, len, rp);
d328 1
a328 1
	rb_reg_raise(s, len, err, 0);
d334 2
a335 1
static VALUE rb_cMatch;
d341 1
a341 1
    OBJSETUP(match, rb_cMatch, T_MATCH);
a343 1
    match->regs = 0;
d354 2
d357 1
a357 1
    OBJSETUP(match, rb_cMatch, T_MATCH);
a359 1
    match->regs = 0;
a363 1
    CLONESETUP(match, orig);
d368 1
a368 2
int ruby_ignorecase;
static int may_need_recompile;
d371 2
a372 2
static void
rb_reg_prepare_re(reg)
d375 2
d379 8
a386 6
    /* case-flag not set for the object */
    if (!FL_TEST(reg, REG_IGNORECASE)) {
	int state = FL_TEST(reg, REG_CASESTATE);

	if ((ruby_ignorecase || state) && !(ruby_ignorecase && state))  {
	    RBASIC(reg)->flags ^= REG_CASESTATE;
d390 5
d396 4
a399 2
    if (!FL_TEST(reg, KCODE_FIXED) &&
	(RBASIC(reg)->flags & KCODE_MASK) != reg_kcode) {
d401 1
a401 1
	RBASIC(reg)->flags &= ~KCODE_MASK;
a407 3
	if (FL_TEST(reg, KCODE_FIXED))
	    kcode_set_option(reg);
	RREGEXP(reg)->ptr->fastmap_accurate = 0;
d410 2
a411 1
	    rb_reg_raise(RREGEXP(reg)->str, RREGEXP(reg)->len, err, reg);
d417 1
a417 1
rb_reg_search(reg, str, start, reverse)
d419 2
a420 1
    int start, reverse;
d423 4
a426 3
    VALUE match;
    struct re_registers *regs = 0;
    int range;
d430 1
a430 7
    if (may_need_recompile)
	rb_reg_prepare_re(reg);

    if (FL_TEST(reg, KCODE_FIXED))
	kcode_set_option(reg);
    else if (reg_kcode != curr_kcode)
	kcode_reset_option();
d432 2
a433 3
#ifdef USE_THREAD
    if (rb_thread_scope_shared_p()) {
	match = Qnil;
a435 6
	match = rb_backref_get();
    }
#else
    match = rb_backref_get();
#endif
    if (NIL_P(match)) {
d443 1
a444 1
    regs = RMATCH(match)->regs;
a445 6
    if (reverse) {
	range = -start;
    }
    else {
	range = RSTRING(str)->len - start;
    }
d447 2
a448 1
		       start, range, regs);
d450 2
a451 2
    if (result == -2) {
	rb_reg_raise(RREGEXP(reg)->str, RREGEXP(reg)->len,
d456 1
a456 1
	rb_backref_set(Qnil);
d458 3
a460 3
    else {
	RMATCH(match)->str = rb_str_new4(str);
	rb_backref_set(match);
d462 1
d468 1
a468 1
rb_reg_nth_defined(nth, match)
d474 1
a474 1
	return Qfalse;
d476 2
a477 2
    if (RMATCH(match)->BEG(nth) == -1) return Qfalse;
    return Qtrue;
d481 1
a481 1
rb_reg_nth_match(nth, match)
d495 1
a495 1
    return rb_str_new(RSTRING(RMATCH(match)->str)->ptr + start, len);
d499 1
a499 1
rb_reg_last_match(match)
d502 1
a502 1
    return rb_reg_nth_match(0, match);
d506 1
a506 1
rb_reg_match_pre(match)
d511 1
a511 1
    return rb_str_new(RSTRING(RMATCH(match)->str)->ptr, RMATCH(match)->BEG(0));
d515 1
a515 1
rb_reg_match_post(match)
d520 1
a520 1
    return rb_str_new(RSTRING(RMATCH(match)->str)->ptr+RMATCH(match)->END(0),
d525 1
a525 1
rb_reg_match_last(match)
d536 1
a536 1
    return rb_reg_nth_match(i, match);
d542 1
a542 1
    return rb_reg_last_match(rb_backref_get());
d548 1
a548 1
    return rb_reg_match_pre(rb_backref_get());
d554 1
a554 1
    return rb_reg_match_post(rb_backref_get());
d560 1
a560 1
    return rb_reg_match_last(rb_backref_get());
d568 1
a568 1
    VALUE ary = rb_ary_new2(regs->num_regs);
d573 2
a574 2
	if (regs->beg[i] == -1) rb_ary_push(ary, Qnil);
	else rb_ary_push(ary, rb_str_new(ptr+regs->beg[i],
d594 1
a594 1
	return rb_ary_aref(argc, argv, match_to_a(match));
d603 1
a603 1
    return rb_str_new(ptr+regs->beg[i], regs->end[i]-regs->beg[i]);
d610 1
a610 1
    VALUE str = rb_reg_last_match(match);
d612 1
a612 1
    if (NIL_P(str)) return rb_str_new(0,0);
d616 10
a625 1
VALUE rb_cRegexp;
d628 2
a629 2
rb_reg_new_1(klass, s, len, options)
    VALUE klass;
d631 5
a635 7
    size_t len;
    int options;		/* CASEFOLD  = 1 */
				/* EXTENDED  = 2 */
				/* CODE_NONE = 4 */
				/* CODE_EUC  = 8 */
				/* CODE_SJIS = 12 */
				/* CODE_UTF8 = 16 */
d638 1
a638 3
    OBJSETUP(re, klass, T_REGEXP);
    re->ptr = 0;
    re->str = 0;
d640 1
a640 1
    if (options & RE_OPTION_IGNORECASE) {
d643 1
a643 1
    switch (options & ~0x3) {
d648 1
a648 1
      case 4:
d651 1
a651 1
      case 8:
d654 1
a654 1
      case 12:
a656 3
      case 16:
	kcode_utf8(re);
	break;
d659 2
a660 8
    if (options & ~0x3) {
	kcode_set_option((VALUE)re);
    }
    if (ruby_ignorecase) {
	options |= RE_OPTION_IGNORECASE;
	FL_SET(re, REG_CASESTATE);
    }
    re->ptr = make_regexp(s, len, options & 0x3);
a664 4
    if (options & ~0x3) {
	kcode_reset_option();
    }
    rb_obj_call_init((VALUE)re);
d670 1
a670 1
rb_reg_new(s, len, options)
d672 1
a672 2
    size_t len;
    int options;
d674 1
a674 1
    return rb_reg_new_1(rb_cRegexp, s, len, options);
d677 1
a677 2
static int case_cache;
static int kcode_cache;
d681 1
a681 1
rb_reg_regcomp(str)
d684 2
d687 1
a687 2
	&& case_cache == ruby_ignorecase
	&& kcode_cache == reg_kcode
d691 2
a692 4
    case_cache = ruby_ignorecase;
    kcode_cache = reg_kcode;
    return reg_cache = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
				  ruby_ignorecase);
d696 1
a696 1
rb_reg_cur_kcode(re)
d706 1
a706 1
rb_reg_equal(re1, re2)
d711 3
a713 3
    if (re1 == re2) return Qtrue;
    if (TYPE(re2) != T_REGEXP) return Qfalse;
    if (RREGEXP(re1)->len != RREGEXP(re2)->len) return Qfalse;
d717 1
a717 1
	rb_reg_cur_kcode(re1) == rb_reg_cur_kcode(re2) &&
d719 1
a719 1
	return Qtrue;
d721 1
a721 1
    return Qfalse;
d725 1
a725 1
rb_reg_match(re, str)
d730 2
a731 3
    if (NIL_P(str)) return Qnil;
    str = rb_str_to_str(str);
    start = rb_reg_search(re, str, 0, 0);
d733 1
a733 1
	return Qnil;
d739 1
a739 1
rb_reg_match2(re)
d743 1
a743 1
    VALUE line = rb_lastline_get();
d746 1
a746 1
	return Qnil;
d748 1
a748 1
    start = rb_reg_search(re, line, 0, 0);
d750 1
a750 1
	return Qnil;
d756 1
a756 1
rb_reg_s_new(argc, argv, self)
d765 1
a765 1
	rb_raise(rb_eArgError, "wrong # of argument");
d768 1
a768 1
	flag = RE_OPTION_IGNORECASE;
d771 2
a772 3
	char *kcode = STR2CSTR(argv[2]);

	switch (kcode[0]) {
d774 1
a774 1
	    flag |= 4;
d777 1
a777 1
	    flag |= 8;
d780 1
a780 1
	    flag |= 12;
d788 11
a798 2
    if (TYPE(src) == T_REGEXP) {
	return rb_reg_new_1(self, RREGEXP(src)->str, RREGEXP(src)->len, flag);
a799 3
    else {
	char *p;
	size_t len;
d801 1
a801 3
	p = str2cstr(src, &len);
	return rb_reg_new_1(self, p, len, flag);
    }
d805 1
a805 1
rb_reg_s_quote(re, str)
a809 1
  int len;
d811 5
a815 3
  s = str2cstr(str, &len);
  send = s + len;
  tmp = ALLOCA_N(char, len*2);
a818 5
      if (ismbchar(*s)) {
	  *t++ = *s++;
	  *t++ = *s;
	  continue;
      }
d831 1
a831 15
  return rb_str_new(tmp, t - tmp);
}

int
rb_kcode()
{
    switch (reg_kcode) {
      case KCODE_EUC:
	return MBCTYPE_EUC;
      case KCODE_SJIS:
	return MBCTYPE_SJIS;
      case KCODE_NONE:
	return MBCTYPE_ASCII;
    }
    rb_bug("wrong reg_kcode value (0x%x)", reg_kcode);
d835 1
a835 1
rb_reg_get_kcode(re)
d842 2
a844 2
      case KCODE_EUC:
	kcode |= 8; break;
d846 1
a846 1
	kcode |= 12; break;
d854 2
a855 2
int
rb_reg_options(re)
d858 1
a858 1
    int options = 0;
a859 2
    if (FL_TEST(re, REG_IGNORECASE)) 
	options |= RE_OPTION_IGNORECASE;
d861 1
a861 1
	options |= rb_reg_get_kcode(re);
d863 1
a863 13
    return options;
}

static VALUE
rb_reg_clone(orig)
    VALUE orig;
{
    VALUE reg;
    
    reg = rb_reg_new_1(CLASS_OF(orig), RREGEXP(orig)->str, RREGEXP(orig)->len,
		       rb_reg_options(orig));
    CLONESETUP(reg, orig);
    return reg;
d867 1
a867 1
rb_reg_regsub(str, src, regs)
d872 1
d883 1
a883 5
	if (ismbchar(c)) {
	    s++;
	    continue;
	}
	if (c != '\\' || s == e) continue;
d885 2
a886 2
	if (!val) val = rb_str_new(p, ss-p);
	else      rb_str_cat(val, p, ss-p);
d900 1
a900 1
	    rb_str_cat(val, RSTRING(src)->ptr, BEG(0));
d904 1
a904 1
	    rb_str_cat(val, RSTRING(src)->ptr+END(0), RSTRING(src)->len-END(0));
d914 1
a914 1
	    rb_str_cat(val, s-1, 1);
d918 1
a918 1
	    rb_str_cat(val, s-2, 2);
d924 1
a924 1
	    rb_str_cat(val, RSTRING(src)->ptr+BEG(no), END(no)-BEG(no));
d929 2
a930 2
	if (!val) val = rb_str_new(p, e-p);
	else      rb_str_cat(val, p, e-p);
d932 1
a932 1
    if (!val) return str;
d937 5
a941 2
char*
rb_get_kcode()
d943 23
a965 9
    switch (reg_kcode) {
      case KCODE_SJIS:
	return "SJIS";
      case KCODE_EUC:
	return "EUC";
      case KCODE_UTF8:
	return "UTF8";
      default:
	return "NONE";
d967 3
d975 8
a982 1
    return rb_str_new2(rb_get_kcode());
d989 1
d996 1
a996 1
	re_mbcinit(MBCTYPE_EUC);
d1001 1
a1001 6
	re_mbcinit(MBCTYPE_SJIS);
	break;
      case 'U':
      case 'u':
	reg_kcode = KCODE_UTF8;
	re_mbcinit(MBCTYPE_UTF8);
a1005 2
      case 'A':
      case 'a':
a1007 1
	re_mbcinit(MBCTYPE_ASCII);
d1010 1
d1017 2
a1018 16
    may_need_recompile = 1;
    rb_set_kcode(STR2CSTR(val));
}

static VALUE
ignorecase_getter()
{
    return ruby_ignorecase?Qtrue:Qfalse;
}

static void
ignorecase_setter(val)
    VALUE val;
{
    may_need_recompile = 1;
    ruby_ignorecase = RTEST(val);
d1024 1
a1024 1
    return match_clone(rb_backref_get());
d1032 1
a1032 1
    rb_backref_set(val);
d1035 2
d1040 3
a1042 1
    rb_eRegxpError = rb_define_class("RegxpError", rb_eStandardError);
d1044 7
a1050 13
    re_set_casetable(casetable);
#ifdef RUBY_USE_EUC
    re_mbcinit(MBCTYPE_EUC);
#else
#ifdef RUBY_USE_SJIS
    re_mbcinit(MBCTYPE_SJIS);
#else
#ifdef RUBY_USE_UTF8
    re_mbcinit(MBCTYPE_UTF8);
#else
    re_mbcinit(MBCTYPE_ASCII);
#endif
#endif
d1052 1
d1060 1
a1060 1
    rb_define_virtual_variable("$=", ignorecase_getter, ignorecase_setter);
d1064 14
a1077 14
    rb_cRegexp = rb_define_class("Regexp", rb_cObject);
    rb_define_singleton_method(rb_cRegexp, "new", rb_reg_s_new, -1);
    rb_define_singleton_method(rb_cRegexp, "compile", rb_reg_s_new, -1);
    rb_define_singleton_method(rb_cRegexp, "quote", rb_reg_s_quote, 1);

    rb_define_method(rb_cRegexp, "clone", rb_reg_clone, 0);
    rb_define_method(rb_cRegexp, "==", rb_reg_equal, 1);
    rb_define_method(rb_cRegexp, "=~", rb_reg_match, 1);
    rb_define_method(rb_cRegexp, "===", rb_reg_match, 1);
    rb_define_method(rb_cRegexp, "~", rb_reg_match2, 0);
    rb_define_method(rb_cRegexp, "inspect", rb_reg_inspect, 0);
    rb_define_method(rb_cRegexp, "source", rb_reg_source, 0);
    rb_define_method(rb_cRegexp, "casefold?", rb_reg_casefold_p, 0);
    rb_define_method(rb_cRegexp, "kcode", rb_reg_kcode_method, 0);
d1082 5
a1086 6
    rb_cMatch  = rb_define_class("MatchingData", rb_cData);
    rb_define_method(rb_cMatch, "clone", match_clone, 0);
    rb_define_method(rb_cMatch, "to_a", match_to_a, 0);
    rb_define_method(rb_cMatch, "[]", match_aref, -1);
    rb_define_method(rb_cMatch, "to_s", match_to_s, 0);
    rb_define_method(rb_cMatch, "inspect", rb_any_to_s, 0);
@


1.1.1.3.2.1
log
@990126
@
text
@d8 1
a8 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d333 1
a333 1
    int len, flag;
d656 1
a656 1
    int len;
d714 1
a714 1
    int len;
d840 1
a840 1
	int len;
@


1.1.1.3.2.2
log
@990201
@
text
@a828 3
	  case 'u': case 'U':
	    flag |= 16;
	    break;
a888 2
      case KCODE_UTF8:
	return MBCTYPE_UTF8;
a907 2
      case KCODE_UTF8:
	kcode |= 16; break;
@


1.1.1.3.2.3
log
@990205
@
text
@a484 3
    if (FL_TEST(reg, KCODE_FIXED))
	kcode_reset_option();

@


1.1.1.3.2.4
log
@990209
@
text
@a394 15
#define MATCH_BUSY FL_USER2

void
rb_match_busy(match, busy)
    VALUE match;
    int busy;
{
    if (busy) {
	FL_SET(match, MATCH_BUSY);
    }
    else {
	FL_UNSET(match, MATCH_BUSY);
    }
}

d465 1
a465 1
    if (NIL_P(match) || FL_TEST(match, MATCH_BUSY)) {
d484 1
d1105 1
a1105 4
    VALUE match = rb_backref_get();

    if (NIL_P(match)) return Qnil;
    return match_clone(match);
@


1.1.1.3.2.5
log
@990224
@
text
@d882 2
a883 5
	  size_t n = mbclen(*s);

	  while (n--)
	    *t++ = *s++;
	  s--;
d982 1
a982 1
	    s += mbclen(c) - 1;
@


1.1.1.3.2.6
log
@990225
@
text
@d723 1
a723 1
    rb_obj_call_init((VALUE)re, 0, 0);
@


1.1.1.3.2.7
log
@990324
@
text
@d21 1
a21 1
static const char casetable[] = {
d201 1
a201 1
    const char *s;
d204 1
a204 1
    const char *p, *pend;
d236 1
a236 1
    const char *s;
d285 1
a285 1
    const char *s;
d287 1
a287 1
    const char *err;
d332 1
a332 1
    const char *s;
a394 53
static VALUE
match_size(match)
    VALUE match;
{
    return INT2FIX(RMATCH(match)->regs->num_regs);
}

static VALUE
match_offset(match, n)
    VALUE match, n;
{
    int i = NUM2INT(n);

    if (i < 0 || RMATCH(match)->regs->num_regs <= i)
	rb_raise(rb_eIndexError, "index %d out of matches", i);

    if (RMATCH(match)->regs->beg[i] < 0)
	return rb_assoc_new(Qnil, Qnil);

    return rb_assoc_new(INT2FIX(RMATCH(match)->regs->beg[i]),
			INT2FIX(RMATCH(match)->regs->end[i]));
}

static VALUE
match_begin(match, n)
    VALUE match, n;
{
    int i = NUM2INT(n);

    if (i < 0 || RMATCH(match)->regs->num_regs <= i)
	rb_raise(rb_eIndexError, "index %d out of matches", i);

    if (RMATCH(match)->regs->beg[i] < 0)
	return Qnil;

    return INT2FIX(RMATCH(match)->regs->beg[i]);
}

static VALUE
match_end(match, n)
    VALUE match, n;
{
    int i = NUM2INT(n);

    if (i < 0 || RMATCH(match)->regs->num_regs <= i)
	rb_raise(rb_eIndexError, "index %d out of matches", i);

    if (RMATCH(match)->regs->beg[i] < 0)
	return Qnil;

    return INT2FIX(RMATCH(match)->regs->end[i]);
}

d470 1
d477 3
d572 1
a572 1
		      RSTRING(RMATCH(match)->str)->len-RMATCH(match)->END(0));
d651 1
a651 1
    if (i >= regs->num_regs) return Qnil;
a666 7
static VALUE
match_string(match)
    VALUE match;
{
    return rb_str_dup(RMATCH(match)->str);
}

d672 1
a672 1
    const char *s;
d730 1
a730 1
    const char *s;
a818 10
rb_reg_match_method(re, str)
    VALUE re, str;
{
    VALUE result = rb_reg_match(re, str);

    if (NIL_P(result)) return Qnil;
    return rb_backref_get();
}

static VALUE
d830 2
a831 3
    if (argc >= 2) {
	if (FIXNUM_P(argv[1])) flag = FIX2INT(argv[1]);
	else if (RTEST(argv[1])) flag = RE_OPTION_IGNORECASE;
d868 2
a869 3
rb_reg_s_quote(argc, argv)
    int argc;
    VALUE *argv;
d871 28
a898 36
    VALUE str, kcode;
    int kcode_saved = reg_kcode;
    char *s, *send, *t;
    char *tmp;
    int len;

    rb_scan_args(argc, argv, "11", &str, &kcode);
    if (!NIL_P(kcode)) {
	rb_set_kcode(STR2CSTR(kcode));
	curr_kcode = reg_kcode;
	reg_kcode = kcode_saved;
    }
    s = str2cstr(str, &len);
    send = s + len;
    tmp = ALLOCA_N(char, len*2);
    t = tmp;

    for (; s != send; s++) {
	if (ismbchar(*s)) {
	    size_t n = mbclen(*s);

	    while (n--)
		*t++ = *s++;
	    s--;
	    continue;
	}
	if (*s == '[' || *s == ']'
	    || *s == '{' || *s == '}'
	    || *s == '(' || *s == ')'
	    || *s == '|'
	    || *s == '*' || *s == '.' || *s == '\\'
	    || *s == '?' || *s == '+'
	    || *s == '^' || *s == '$') {
	    *t++ = '\\';
	}
	*t++ = *s;
a899 1
    kcode_reset_option();
d901 1
a901 1
    return rb_str_new(tmp, t - tmp);
d1042 1
a1042 1
const char*
d1065 1
a1065 1
    const char *code;
d1169 1
a1169 2
    rb_define_singleton_method(rb_cRegexp, "quote", rb_reg_s_quote, -1);
    rb_define_singleton_method(rb_cRegexp, "escape", rb_reg_s_quote, -1);
a1175 1
    rb_define_method(rb_cRegexp, "match", rb_reg_match_method, 1);
a1180 3
    rb_define_const(rb_cRegexp, "IGNORECASE", INT2FIX(RE_OPTION_IGNORECASE));
    rb_define_const(rb_cRegexp, "EXTENDED", INT2FIX(RE_OPTION_EXTENDED));

a1185 5
    rb_define_method(rb_cMatch, "size", match_size, 0);
    rb_define_method(rb_cMatch, "length", match_size, 0);
    rb_define_method(rb_cMatch, "offset", match_offset, 1);
    rb_define_method(rb_cMatch, "begin", match_begin, 1);
    rb_define_method(rb_cMatch, "end", match_end, 1);
a1187 2
    rb_define_method(rb_cMatch, "pre_match", rb_reg_match_pre, 0);
    rb_define_method(rb_cMatch, "post_match", rb_reg_match_post, 0);
a1188 1
    rb_define_method(rb_cMatch, "string_s", match_string, 0);
@


1.1.1.3.2.8
log
@to open CVS
@
text
@d90 2
a91 4
#define REG_CASESTATE  FL_USER0
#define REG_IGNORECASE FL_USER1
#define REG_EXTENDED   FL_USER2
#define REG_POSIX      FL_USER3
d94 4
a97 4
#define KCODE_EUC   FL_USER4
#define KCODE_SJIS  FL_USER5
#define KCODE_UTF8  FL_USER6
#define KCODE_FIXED FL_USER7
d100 14
a113 1
static int reg_kcode = DEFAULT_KCODE;
a245 4
	if (FL_TEST(re, REG_EXTENDED))
	    rb_str_cat(str, "x", 1);
	if (FL_TEST(re, REG_POSIX))
	    rb_str_cat(str, "p", 1);
d732 4
a735 5
				/* POSIX     = 4 */
				/* CODE_NONE = 8 */
				/* CODE_EUC  = 16 */
				/* CODE_SJIS = 24 */
				/* CODE_UTF8 = 32 */
d745 1
a745 7
    if (options & RE_OPTION_EXTENDED) {
	FL_SET(re, REG_EXTENDED);
    }
    if (options & RE_OPTION_POSIX) {
	FL_SET(re, REG_POSIX);
    }
    switch (options & ~0x7) {
d750 1
a750 1
      case 8:
d753 1
a753 1
      case 16:
d756 1
a756 1
      case 24:
d759 1
a759 1
      case 32:
d764 1
a764 1
    if (options & ~0x7) {
d771 1
a771 1
    re->ptr = make_regexp(s, len, options & 0x7);
d776 1
a776 1
    if (options & ~0x7) {
d905 1
a905 1
	    flag |= 8;
d908 1
a908 1
	    flag |= 16;
d911 1
a911 1
	    flag |= 24;
d914 1
a914 1
	    flag |= 32;
a1261 1
    rb_define_const(rb_cRegexp, "POSIX", INT2FIX(RE_OPTION_POSIX));
@


1.1.1.3.2.9
log
@small fixes
@
text
@d93 1
a93 1
#define REG_POSIXLINE  FL_USER3
d237 1
a237 1
	if (FL_TEST(re, REG_POSIXLINE))
d497 1
a497 1
rb_reg_search(reg, str, pos, reverse)
d499 1
a499 1
    int pos, reverse;
d506 1
a506 1
    if (pos > RSTRING(str)->len) return -1;
a532 1
    range = RSTRING(str)->len - pos;
d534 4
a537 2
	range = -range;
	pos = RSTRING(str)->len;
d540 1
a540 1
		       pos, range, regs);
d725 1
a725 1
				/* POSIXLINE = 4 */
d742 2
a743 2
    if (options & RE_OPTION_POSIXLINE) {
	FL_SET(re, REG_POSIXLINE);
d1219 1
a1219 1
#if DEFAULT_KCODE == KCODE_EUC
d1222 1
a1222 1
#if DEFAULT_KCODE == KCODE_SJIS
d1225 1
a1225 1
#if DEFAULT_KCODE == KCODE_UTF8
d1262 1
a1262 1
    rb_define_const(rb_cRegexp, "POSIXLINE", INT2FIX(RE_OPTION_POSIXLINE));
d1279 1
a1279 1
    rb_define_method(rb_cMatch, "string", match_string, 0);
@


1.1.1.3.2.10
log
@regexp null pattern
@
text
@d786 1
a786 1
    long len;
@


1.1.1.3.2.11
log
@990611
@
text
@d778 1
@


1.1.1.3.2.12
log
@990625
@
text
@d533 1
d535 2
a536 4
	range = -pos;
    }
    else {
	range = RSTRING(str)->len - pos;
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:04:57 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:47 $
d72 1
a72 1
#define MIN(a,b) (((a)>(b))?(b):(a))
d81 1
a81 1
    len = MIN(RSTRING(str1)->len, RSTRING(str2)->len);
@


1.1.1.2.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/20 04:16:43 $
d573 1
a573 1
	if (regs->beg[i] == -1) ary_push(ary, Qnil);
@


1.1.1.2.2.4
log
@1.1b7 pre
@
text
@d6 1
a6 1
  $Date: 1998/02/03 10:02:56 $
d932 1
a932 1
    if (!val) return str;
@


1.1.1.2.2.5
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/02/09 10:56:22 $
d628 2
a629 2
reg_new_1(klass, s, len, flag)
    VALUE klass;
d638 1
a638 1
    OBJSETUP(re, klass, T_REGEXP);
@


1.1.1.2.2.6
log
@1.1b8pre2
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:41 $
d972 2
a973 2
char*
rb_get_kcode()
d977 1
a977 1
	return "SJIS";
d979 1
a979 1
	return "EUC";
d981 1
a981 1
	return "NONE";
a982 6
}

static VALUE
kcode_getter()
{
    return str_new2(rb_get_kcode());
@


1.1.1.2.2.7
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/02/20 08:28:46 $
a818 5
      if (ismbchar(*s)) {
	  *t++ = *s++;
	  *t++ = *s;
	  continue;
      }
@


1.1.1.2.2.8
log
@block arg etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/23 05:36:39 $
a1091 3

    /* turn on premitive flag for the class */
    FL_SET(cRegexp, FL_PRIMITIVE);
@


1.1.1.2.2.9
log
@1.1b9_00
@
text
@d6 1
a6 1
  $Date: 1998/03/05 06:37:47 $
d142 1
a144 1
	mbcinit(MBCTYPE_ASCII);
d147 1
a147 1
	mbcinit(MBCTYPE_EUC);
d150 1
a150 1
	mbcinit(MBCTYPE_EUC);
d153 1
d159 1
a161 1
	mbcinit(MBCTYPE_ASCII);
d164 1
a164 1
	mbcinit(MBCTYPE_EUC);
d167 1
a167 1
	mbcinit(MBCTYPE_SJIS);
d170 1
d1000 1
d1007 1
a1007 1
	mbcinit(MBCTYPE_EUC);
d1012 1
a1012 1
	mbcinit(MBCTYPE_SJIS);
a1016 2
      case 'A':
      case 'a':
a1018 1
	mbcinit(MBCTYPE_ASCII);
d1021 1
d1059 5
a1063 1
		  | RE_BACKSLASH_ESCAPE_IN_LISTS);
@


1.1.1.2.2.10
log
@gets speed up patch
@
text
@d6 1
a6 1
  $Date: 1998/03/09 07:56:57 $
d332 1
a1057 1
		  | RE_CHAR_CLASSES
d1087 3
@


1.1.1.2.2.11
log
@call initialize
@
text
@d6 1
a6 1
  $Date: 1998/03/11 07:32:59 $
a661 1
    obj_call_init((VALUE)re);
d798 1
a798 1
    return Qnil;		/* not reached */
@


1.1.1.2.2.12
log
@local_variables/defined?(TOPLEVEL_CONST) in modules
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:03:50 $
d886 1
a886 1
	if (c != '\\' || s == e) continue;
d915 4
@


1.1.1.2.2.13
log
@1.1b9_09 pre
@
text
@d6 1
a6 1
  $Date: 1998/04/08 08:12:38 $
a914 4

	  case '\\':
	    str_cat(val, s-1, 1);
	    continue;
@


1.1.1.2.2.14
log
@1.1b9_09
@
text
@d6 1
a6 1
  $Date: 1998/04/09 09:30:23 $
d915 4
@


1.1.1.2.2.15
log
@1.1b9_09
@
text
@d6 1
a6 1
  $Date: 1998/04/09 09:58:00 $
a914 4

	  case '\\':
	    str_cat(val, s-1, 1);
	    continue;
@


1.1.1.2.2.16
log
@signal to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/09 10:10:09 $
d150 1
a150 1
	mbcinit(MBCTYPE_SJIS);
a885 4
	if (ismbchar(c)) {
	    s++;
	    continue;
	}
@


1.1.1.2.2.17
log
@exception model changed
@
text
@d6 1
a6 1
  $Date: 1998/04/13 06:06:12 $
a1049 1
extern VALUE eStandardError;
d1054 3
a1056 1
    eRegxpError = rb_define_class("RegxpError", eStandardError);
@


1.1.1.2.2.18
log
@new exception model
@
text
@d6 1
a6 1
  $Date: 1998/05/01 08:56:35 $
d414 1
a414 1
reg_search(reg, str, start, reverse)
d416 2
a417 1
    int start, reverse;
d422 1
a422 2
    struct re_registers *regs = 0;
    int range;
d429 2
a430 3
    if (matchcache) {
	match = matchcache;
	matchcache = 0;
d433 8
a440 1
	match = match_alloc();
a441 1
    regs = RMATCH(match)->regs;
a442 6
    if (reverse) {
	range = -start;
    }
    else {
	range = RSTRING(str)->len-start;
    }
d444 1
a444 1
		       start, range, regs);
d459 1
d728 1
a728 1
    str = str_to_str(str);
@


1.1.1.2.2.19
log
@pack/unpack unsigned
@
text
@d6 1
a6 1
  $Date: 1998/05/06 03:08:56 $
a727 1
    if (NIL_P(str)) return FALSE;
@


1.1.1.2.2.20
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/08 09:38:13 $
d1050 1
@


1.1.1.2.2.21
log
@remove unused variables
@
text
@d6 1
a6 1
  $Date: 1998/05/18 04:56:13 $
a340 1
    match->regs = 0;
d351 2
a356 1
    match->regs = 0;
d372 1
d419 1
d423 1
a636 3
    re->ptr = 0;
    re->str = 0;

d876 1
d945 35
a1092 1
    rb_define_method(cMatch, "clone", match_clone, 0);
@


1.1.1.2.2.22
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 04:57:51 $
d321 1
a321 1
	rp->options = flag;
d379 9
a387 2
    if ((casefold && !(RREGEXP(reg)->ptr->options & RE_OPTION_IGNORECASE))
	|| (!casefold && (RREGEXP(reg)->ptr->options & RE_OPTION_IGNORECASE))) {
d622 1
a622 1
reg_new_1(klass, s, len, options)
d626 4
a629 5
    int options;		/* CASEFOLD  = 1 */
				/* EXTENDED  = 2 */
				/* CODE_NONE = 4 */
				/* CODE_EUC  = 8 */
				/* CODE_SJIS = 12 */
d633 1
d637 1
a637 1
    if (options & 0x1) {
d640 1
a640 1
    switch (options & ~0x3) {
d645 1
a645 1
      case 4:
d648 1
a648 1
      case 8:
d651 1
a651 1
      case 12:
d657 1
a657 1
    re->ptr = make_regexp(s, len, options & 0x3);
a1026 1
    re_set_casetable(casetable);
@


1.1.1.2.2.23
log
@regex.c
@
text
@d6 1
a6 1
  $Date: 1998/05/25 09:42:32 $
a91 1
#define REG_CASESTATE  FL_USER1
d379 2
a380 2
    else if ((casefold && !FL_TEST(reg, REG_CASESTATE)) ||
	     (!casefold && FL_TEST(reg, REG_CASESTATE))) {
a381 1
	RBASIC(reg)->flags ^= REG_CASESTATE;
d390 1
a390 1
	RBASIC(reg)->flags &= ~KCODE_MASK;
a649 4
    if (RTEST(ignorecase)) {
	options |= RE_OPTION_IGNORECASE;
	FL_SET(re, REG_CASESTATE);
    }
@


1.1.1.2.2.24
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/06/01 04:23:40 $
d440 1
a440 1
    if (result == -2) {
d1012 2
@


1.1.1.2.2.25
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/06/02 10:05:30 $
d172 1
a172 1
extern int rb_in_compile;
d265 3
a267 1
    if (rb_in_compile)
a268 2
    else
	Raise(eRegxpError, "%s: %s", err, RSTRING(desc)->ptr);
@


1.1.1.2.2.26
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/06/03 09:06:42 $
d101 1
a101 1
#ifdef RUBY_USE_EUC
d104 1
a104 1
# ifdef RUBY_USE_SJIS
d786 6
a791 1
    if (TYPE(src) == T_REGEXP) {
d793 4
a797 3
    else {
	char *p;
	int len;
d799 1
a799 3
	p = str2cstr(src, &len);
	return reg_new_1(self, p, len, flag);
    }
d995 2
a996 1
    rb_set_kcode(STR2CSTR(val));
a1024 10

#ifdef RUBY_USE_EUC
    mbcinit(MBCTYPE_EUC);
#else
#ifdef RUBY_USE_SJIS
    mbcinit(MBCTYPE_SJIS);
#else
    mbcinit(MBCTYPE_ASCII);
#endif
#endif
@


1.1.1.2.2.27
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/26 07:19:01 $
d632 1
a632 1
    if (options & RE_OPTION_IGNORECASE) {
d766 1
a766 1
	flag = RE_OPTION_IGNORECASE;
d769 2
a770 4
	char *kcode = STR2CSTR(argv[2]);

	if (!kcode) TypeError("wrong char-code");
	switch (kcode[0]) {
d772 1
a772 1
	    flag |= 4;
d775 1
a775 1
	    flag |= 8;
d778 1
a778 1
	    flag |= 12;
a803 1
  int len;
d805 5
a809 3
  s = str2cstr(str, &len);
  send = s + len;
  tmp = ALLOCA_N(char, len*2);
@


1.1.1.2.2.28
log
@str2cstr
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:32 $
d771 1
@


1.1.1.2.2.29
log
@marshal/reg_clone
@
text
@d6 1
a6 1
  $Date: 1998/07/13 04:37:53 $
d667 1
a667 1
reg_new(s, len, options)
d669 1
a669 1
    int len, options;
d671 1
a671 1
    return reg_new_1(cRegexp, s, len, options);
d841 2
a843 2
      case KCODE_EUC:
	kcode |= 8; break;
d845 1
a845 1
	kcode |= 12; break;
d853 2
a854 2
int
reg_options(re)
d857 1
a857 1
    int options = 0;
a858 2
    if (FL_TEST(re, REG_IGNORECASE)) 
	options |= RE_OPTION_IGNORECASE;
d860 1
a860 1
	options |= reg_get_kcode(re);
d862 1
a862 9
    return options;
}

static VALUE
reg_clone(re)
    VALUE re;
{
    return reg_new_1(CLASS_OF(re), RREGEXP(re)->str, RREGEXP(re)->len,
		     reg_options(re));
@


1.1.1.2.2.30
log
@1.1c3
@
text
@d6 1
a6 1
  $Date: 1998/07/24 04:32:29 $
d113 1
a113 1
    struct RRegexp *reg;
d122 1
a122 1
    struct RRegexp *reg;
d131 1
a131 1
    struct RRegexp *reg;
d244 1
a244 1
    reg_expr_str(str, RREGEXP(re)->str, RREGEXP(re)->len);
@


1.1.1.2.2.31
log
@1.1c4
@
text
@d6 1
a6 1
  $Date: 1998/08/27 03:55:26 $
d145 1
a145 1
	re_mbcinit(MBCTYPE_ASCII);
d148 1
a148 1
	re_mbcinit(MBCTYPE_EUC);
d151 1
a151 1
	re_mbcinit(MBCTYPE_SJIS);
d161 1
a161 1
	re_mbcinit(MBCTYPE_ASCII);
d164 1
a164 1
	re_mbcinit(MBCTYPE_EUC);
d167 1
a167 1
	re_mbcinit(MBCTYPE_SJIS);
d605 9
d651 1
a651 1
    kcode_set_option((VALUE)re);
a660 3
    if (options & ~0x3) {
	kcode_reset_option();
    }
d978 1
a978 1
	re_mbcinit(MBCTYPE_EUC);
d983 1
a983 1
	re_mbcinit(MBCTYPE_SJIS);
d992 1
a992 1
	re_mbcinit(MBCTYPE_ASCII);
d1032 1
a1032 1
    re_mbcinit(MBCTYPE_EUC);
d1035 1
a1035 1
    re_mbcinit(MBCTYPE_SJIS);
d1037 1
a1037 1
    re_mbcinit(MBCTYPE_ASCII);
@


1.1.1.2.2.32
log
@1.1c7
@
text
@d6 1
a6 1
  $Date: 1998/09/03 07:43:37 $
d721 1
a721 1
    if (NIL_P(str)) return Qnil;
d724 4
a727 2
    if (start >= 0) return INT2FIX(start);
    return Qnil;
d737 3
a739 1
    if (TYPE(line) != T_STRING) return Qnil;
d741 4
a744 2
    if (start >= 0) return INT2FIX(start);
    return Qnil;
@


1.1.1.2.2.33
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:50 $
d725 1
a725 1
    return FALSE;
d738 1
a738 1
    return FALSE;
@


1.1.1.2.2.31.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/09/03 07:43:37 $
d16 1
a16 1
static VALUE rb_eRegxpError;
d75 1
a75 1
rb_str_cicmp(str1, str2)
a136 2
static int curr_kcode;

d143 1
a143 3
    curr_kcode = RBASIC(reg)->flags & KCODE_MASK;
    if (reg_kcode == curr_kcode) return;
    switch (curr_kcode) {
d156 1
a156 1
static void
a158 1
    if (reg_kcode == curr_kcode) return;
d175 1
a175 1
rb_reg_expr_str(str, s, len)
d192 1
a192 1
	rb_str_cat(str, s, len);
d199 2
a200 2
		rb_str_cat(str, &c, 1);
		rb_str_cat(str, p, 1);
d203 1
a203 1
		rb_str_cat(str, p, 1);
d211 1
a211 1
rb_reg_desc(s, len, re)
d216 3
a218 3
    VALUE str = rb_str_new2("/");
    rb_reg_expr_str(str, s, len);
    rb_str_cat(str, "/", 1);
d220 3
a222 3
	if (FL_TEST(re, REG_IGNORECASE))
	    rb_str_cat(str, "i", 1);
	if (FL_TEST(re, KCODE_FIXED)) {
d225 1
a225 1
		rb_str_cat(str, "n", 1);
d228 1
a228 1
		rb_str_cat(str, "e", 1);
d231 1
a231 1
		rb_str_cat(str, "s", 1);
d240 1
a240 1
rb_reg_source(re)
d243 2
a244 2
    VALUE str = rb_str_new(0,0);
    rb_reg_expr_str(str, RREGEXP(re)->str,RREGEXP(re)->len);
d250 1
a250 1
rb_reg_inspect(re)
d253 1
a253 1
    return rb_reg_desc(RREGEXP(re)->str, RREGEXP(re)->len, re);
d257 1
a257 1
rb_reg_raise(s, len, err, re)
d263 1
a263 1
    VALUE desc = rb_reg_desc(s, len, re);
d266 1
a266 1
	rb_compile_error("%s: %s", err, RSTRING(desc)->ptr);
d268 1
a268 1
	rb_raise(rb_eRegxpError, "%s: %s", err, RSTRING(desc)->ptr);
d272 1
a272 1
rb_reg_casefold_p(re)
d275 2
a276 2
    if (FL_TEST(re, REG_IGNORECASE)) return Qtrue;
    return Qfalse;
d280 1
a280 1
rb_reg_kcode_method(re)
d298 1
a298 1
    return rb_str_new2(kcode);
d325 1
d327 1
a327 1
	rb_reg_raise(s, len, err, 0);
d333 1
a333 1
static VALUE rb_cMatch;
d339 1
a339 1
    OBJSETUP(match, rb_cMatch, T_MATCH);
d354 1
a354 1
    OBJSETUP(match, rb_cMatch, T_MATCH);
a361 1
    CLONESETUP(match, orig);
d366 1
a366 2
static int ignorecase;
static int may_need_recompile;
d369 2
a370 2
static void
rb_reg_prepare_re(reg)
d373 1
d376 9
a384 8
    /* case-flag not set for the object */
    if (!FL_TEST(reg, REG_IGNORECASE)) {
	int state = FL_TEST(reg, REG_CASESTATE);

	if ((ignorecase || state) && !(ignorecase && state))  {
	    RBASIC(reg)->flags ^= REG_CASESTATE;
	    need_recompile = 1;
	}
d387 4
a390 2
    if (!FL_TEST(reg, KCODE_FIXED) &&
	(RBASIC(reg)->flags & KCODE_MASK) != reg_kcode) {
a398 3
	if (FL_TEST(reg, KCODE_FIXED))
	    kcode_set_option(reg);
	RREGEXP(reg)->ptr->fastmap_accurate = 0;
d401 2
a402 1
	    rb_reg_raise(RREGEXP(reg)->str, RREGEXP(reg)->len, err, reg);
d408 1
a408 1
rb_reg_search(reg, str, start, reverse)
d413 1
a413 1
    VALUE match;
d419 1
a419 7
    if (may_need_recompile)
	rb_reg_prepare_re(reg);

    if (FL_TEST(reg, KCODE_FIXED))
	kcode_set_option(reg);
    else if (reg_kcode != curr_kcode)
	kcode_reset_option();
d421 3
a423 2
    if (rb_thread_scope_shared_p()) {
	match = Qnil;
d426 1
a426 10
	match = rb_backref_get();
    }
    if (NIL_P(match)) {
	if (matchcache) {
	    match = matchcache;
	    matchcache = 0;
	}
	else {
	    match = match_alloc();
	}
d434 1
a434 1
	range = RSTRING(str)->len - start;
d438 1
d441 1
a441 1
	rb_reg_raise(RREGEXP(reg)->str, RREGEXP(reg)->len,
d446 1
a446 1
	rb_backref_set(Qnil);
d448 3
a450 3
    else {
	RMATCH(match)->str = rb_str_new4(str);
	rb_backref_set(match);
d457 1
a457 1
rb_reg_nth_defined(nth, match)
d463 1
a463 1
	return Qfalse;
d465 2
a466 2
    if (RMATCH(match)->BEG(nth) == -1) return Qfalse;
    return Qtrue;
d470 1
a470 1
rb_reg_nth_match(nth, match)
d484 1
a484 1
    return rb_str_new(RSTRING(RMATCH(match)->str)->ptr + start, len);
d488 1
a488 1
rb_reg_last_match(match)
d491 1
a491 1
    return rb_reg_nth_match(0, match);
d495 1
a495 1
rb_reg_match_pre(match)
d500 1
a500 1
    return rb_str_new(RSTRING(RMATCH(match)->str)->ptr, RMATCH(match)->BEG(0));
d504 1
a504 1
rb_reg_match_post(match)
d509 1
a509 1
    return rb_str_new(RSTRING(RMATCH(match)->str)->ptr+RMATCH(match)->END(0),
d514 1
a514 1
rb_reg_match_last(match)
d525 1
a525 1
    return rb_reg_nth_match(i, match);
d531 1
a531 1
    return rb_reg_last_match(rb_backref_get());
d537 1
a537 1
    return rb_reg_match_pre(rb_backref_get());
d543 1
a543 1
    return rb_reg_match_post(rb_backref_get());
d549 1
a549 1
    return rb_reg_match_last(rb_backref_get());
d557 1
a557 1
    VALUE ary = rb_ary_new2(regs->num_regs);
d562 2
a563 2
	if (regs->beg[i] == -1) rb_ary_push(ary, Qnil);
	else rb_ary_push(ary, rb_str_new(ptr+regs->beg[i],
d583 1
a583 1
	return rb_ary_aref(argc, argv, match_to_a(match));
d592 1
a592 1
    return rb_str_new(ptr+regs->beg[i], regs->end[i]-regs->beg[i]);
d599 1
a599 1
    VALUE str = rb_reg_last_match(match);
d601 1
a601 1
    if (NIL_P(str)) return rb_str_new(0,0);
d605 1
a605 1
VALUE rb_cRegexp;
d608 1
a608 1
rb_reg_new_1(klass, s, len, options)
d642 2
a643 4
    if (options & ~0x3) {
	kcode_set_option((VALUE)re);
    }
    if (ignorecase) {
d655 1
a655 1
    rb_obj_call_init((VALUE)re);
d661 1
a661 1
rb_reg_new(s, len, options)
d665 1
a665 1
    return rb_reg_new_1(rb_cRegexp, s, len, options);
d668 1
a668 2
static int case_cache;
static int kcode_cache;
d672 1
a672 1
rb_reg_regcomp(str)
d675 2
d678 1
a678 2
	&& case_cache == ignorecase
	&& kcode_cache == reg_kcode
d682 2
a683 4
    case_cache = ignorecase;
    kcode_cache = reg_kcode;
    return reg_cache = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
				  ignorecase);
d687 1
a687 1
rb_reg_cur_kcode(re)
d697 1
a697 1
rb_reg_equal(re1, re2)
d702 3
a704 3
    if (re1 == re2) return Qtrue;
    if (TYPE(re2) != T_REGEXP) return Qfalse;
    if (RREGEXP(re1)->len != RREGEXP(re2)->len) return Qfalse;
d708 1
a708 1
	rb_reg_cur_kcode(re1) == rb_reg_cur_kcode(re2) &&
d710 1
a710 1
	return Qtrue;
d712 1
a712 1
    return Qfalse;
d716 1
a716 1
rb_reg_match(re, str)
d721 3
a723 3
    if (NIL_P(str)) return Qfalse;
    str = rb_str_to_str(str);
    start = rb_reg_search(re, str, 0, 0);
d725 1
a725 1
	return Qfalse;
d731 1
a731 1
rb_reg_match2(re)
d735 1
a735 1
    VALUE line = rb_lastline_get();
d738 1
a738 1
	return Qfalse;
d740 1
a740 1
    start = rb_reg_search(re, line, 0, 0);
d742 1
a742 1
	return Qfalse;
d748 1
a748 1
rb_reg_s_new(argc, argv, self)
d757 1
a757 1
	rb_raise(rb_eArgError, "wrong # of argument");
d782 1
a782 1
	return rb_reg_new_1(self, RREGEXP(src)->str, RREGEXP(src)->len, flag);
d789 1
a789 1
	return rb_reg_new_1(self, p, len, flag);
d794 1
a794 1
rb_reg_s_quote(re, str)
d824 1
a824 1
  return rb_str_new(tmp, t - tmp);
d828 1
a828 1
rb_reg_get_kcode(re)
d848 1
a848 1
rb_reg_options(re)
d856 1
a856 1
	options |= rb_reg_get_kcode(re);
d862 2
a863 2
rb_reg_clone(orig)
    VALUE orig;
d865 2
a866 6
    VALUE reg;
    
    reg = rb_reg_new_1(CLASS_OF(orig), RREGEXP(orig)->str, RREGEXP(orig)->len,
		       rb_reg_options(orig));
    CLONESETUP(reg, orig);
    return reg;
d870 1
a870 1
rb_reg_regsub(str, src, regs)
d891 2
a892 2
	if (!val) val = rb_str_new(p, ss-p);
	else      rb_str_cat(val, p, ss-p);
d906 1
a906 1
	    rb_str_cat(val, RSTRING(src)->ptr, BEG(0));
d910 1
a910 1
	    rb_str_cat(val, RSTRING(src)->ptr+END(0), RSTRING(src)->len-END(0));
d920 1
a920 1
	    rb_str_cat(val, s-1, 1);
d924 1
a924 1
	    rb_str_cat(val, s-2, 2);
d930 1
a930 1
	    rb_str_cat(val, RSTRING(src)->ptr+BEG(no), END(no)-BEG(no));
d935 2
a936 2
	if (!val) val = rb_str_new(p, e-p);
	else      rb_str_cat(val, p, e-p);
d959 1
a959 1
    return rb_str_new2(rb_get_kcode());
a994 1
    may_need_recompile = 1;
a998 20
ignorecase_getter()
{
    return ignorecase?Qtrue:Qfalse;
}

static void
ignorecase_setter(val)
    VALUE val;
{
    may_need_recompile = 1;
    ignorecase = RTEST(val);
}

int
rb_ignorecase_p()
{
    return (int)ignorecase;
}

static VALUE
d1001 1
a1001 1
    return match_clone(rb_backref_get());
d1009 1
a1009 1
    rb_backref_set(val);
d1015 1
a1015 1
    rb_eRegxpError = rb_define_class("RegxpError", rb_eStandardError);
d1041 1
a1041 1
    rb_define_virtual_variable("$=", ignorecase_getter, ignorecase_setter);
d1045 14
a1058 14
    rb_cRegexp = rb_define_class("Regexp", rb_cObject);
    rb_define_singleton_method(rb_cRegexp, "new", rb_reg_s_new, -1);
    rb_define_singleton_method(rb_cRegexp, "compile", rb_reg_s_new, -1);
    rb_define_singleton_method(rb_cRegexp, "quote", rb_reg_s_quote, 1);

    rb_define_method(rb_cRegexp, "clone", rb_reg_clone, 0);
    rb_define_method(rb_cRegexp, "==", rb_reg_equal, 1);
    rb_define_method(rb_cRegexp, "=~", rb_reg_match, 1);
    rb_define_method(rb_cRegexp, "===", rb_reg_match, 1);
    rb_define_method(rb_cRegexp, "~", rb_reg_match2, 0);
    rb_define_method(rb_cRegexp, "inspect", rb_reg_inspect, 0);
    rb_define_method(rb_cRegexp, "source", rb_reg_source, 0);
    rb_define_method(rb_cRegexp, "casefold?", rb_reg_casefold_p, 0);
    rb_define_method(rb_cRegexp, "kcode", rb_reg_kcode_method, 0);
d1063 6
a1068 6
    rb_cMatch  = rb_define_class("MatchingData", rb_cData);
    rb_define_method(rb_cMatch, "clone", match_clone, 0);
    rb_define_method(rb_cMatch, "to_a", match_to_a, 0);
    rb_define_method(rb_cMatch, "[]", match_aref, -1);
    rb_define_method(rb_cMatch, "to_s", match_to_s, 0);
    rb_define_method(rb_cMatch, "inspect", rb_any_to_s, 0);
@


1.1.1.2.2.31.2.2
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:50 $
d371 1
a371 1
int ruby_ignorecase;
d385 1
a385 1
	if ((ruby_ignorecase || state) && !(ruby_ignorecase && state))  {
d662 1
a662 1
    if (ruby_ignorecase) {
d696 1
a696 1
	&& case_cache == ruby_ignorecase
d701 1
a701 1
    case_cache = ruby_ignorecase;
d704 1
a704 1
				  ruby_ignorecase);
d742 1
a742 1
    if (NIL_P(str)) return Qnil;
d746 1
a746 1
	return Qnil;
d759 1
a759 1
	return Qnil;
d763 1
a763 1
	return Qnil;
d1027 1
a1027 1
    return ruby_ignorecase?Qtrue:Qfalse;
d1035 7
a1041 1
    ruby_ignorecase = RTEST(val);
@


1.1.1.2.2.31.2.3
log
@1.1d1
@
text
@d6 1
a6 1
  $Date: 1998/11/25 03:31:16 $
a430 1
#ifdef USE_THREAD
a436 3
#else
    match = rb_backref_get();
#endif
@
