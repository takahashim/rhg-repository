head	1.6;
access;
symbols
	v1_6_7:1.3.2.3
	v1_6_6:1.3.2.3
	v1_6_5:1.3.2.3
	v1_6_4:1.3.2.3
	v1_7_1:1.6
	v1_6_4_preview4:1.3.2.3
	v1_6_4_preview3:1.3.2.3
	v1_6_4_preview2:1.3.2.3
	v1_6_4_preview1:1.3.2.2
	v1_6_3:1.3.2.2
	ruby_m17n:1.3.0.4
	ruby_1_6:1.3.0.2
	v1_6_2:1.3
	v1_6_1:1.3
	v1_6_0:1.3
	v1_4_6:1.1.1.1.10.1
	v1_4_5:1.1.1.1.10.1
	v1_4_4:1.1.1.1.10.1
	ruby_1_4_3:1.1.1.1
	ruby1_4_3:1.1.1.1
	v1_4_3:1.1.1.1
	v1_5_0:1.1.1.1
	ruby_1_4_3_pre1:1.1.1.1
	ruby_1_4:1.1.1.1.0.10
	v1_4_2:1.1.1.1
	v1_4_1:1.1.1.1
	v1_4_0:1.1.1.1
	v1_3_7:1.1.1.1
	v1_3_6_repack:1.1.1.1
	v1_3_6:1.1.1.1
	v1_3_5:1.1.1.1
	v1_2_6repack:1.1.1.1
	v1_3_4_990625:1.1.1.1
	v1_3_4_990624:1.1.1.1
	v1_2_6:1.1.1.1
	v1_3_4_990611:1.1.1.1
	v1_3_4_990531:1.1.1.1
	v1_3_3_990518:1.1.1.1
	v1_3_3_990513:1.1.1.1
	v1_3_3_990507:1.1.1.1
	v1_2_5:1.1.1.1
	v1_2_4:1.1.1.1
	v1_3_1_990225:1.1.1.1
	v1_3_1_990224:1.1.1.1
	v1_3_1_990215:1.1.1.1
	v1_3_1_990212:1.1.1.1
	v1_3_1_990210:1.1.1.1
	v1_3_1_:1.1.1.1
	v1_3_1_990205:1.1.1.1
	v1_3_1_990201:1.1.1.1
	v1_3_1"_990201:1.1.1.1
	v1_3_1_990128:1.1.1.1
	v1_3_1_990127:1.1.1.1
	v1_3_1_990126:1.1.1.1
	ruby_1_3:1.1.1.1.0.8
	v1_2_2:1.1.1.1
	RUBY_1_3:1.1.1.1
	v1_2_2_pr1:1.1.1.1
	v1_2_1repack:1.1.1.1
	v1_2_1:1.1.1.1
	v1_2_stable:1.1.1.1
	v1_1d1:1.1.1.1
	v1_1d0:1.1.1.1
	v1_1c9_1:1.1.1.1
	v1_1c9:1.1.1.1
	v1_1c8:1.1.1.1
	v1_1c7:1.1.1.1
	v1_1c6:1.1.1.1
	v1_1d-start:1.1.1.1
	v1_1c5:1.1.1.1
	v1_1dev:1.1.1.1.0.6
	v1_1c4:1.1.1.1
	v1_1c3:1.1.1.1
	v1_1c2:1.1.1.1
	v1_1c1:1.1.1.1
	v1_1c0:1.1.1.1
	v1_1b9_31:1.1.1.1
	v1_1b9_30:1.1.1.1
	v1_1b9_28:1.1.1.1
	v1_1b9_27:1.1.1.1
	v1_1b9_26:1.1.1.1
	r1_1b9_25:1.1.1.1
	r1_1b9_24:1.1.1.1
	v1_1b9_23:1.1.1.1
	v1_1b9_22:1.1.1.1
	v1_1b9_20:1.1.1.1
	v1_1b9_18:1.1.1.1
	v1_1b9_16:1.1.1.1
	v1_1b9_15:1.1.1.1
	v1_1b9_13:1.1.1.1
	v1_1b9_12:1.1.1.1
	v1_1b9_11:1.1.1.1
	v1_1b9_08:1.1.1.1
	v1_1b9_07:1.1.1.1
	r1_1b9:1.1.1.1
	v1_1b8:1.1.1.1
	v1_1b7:1.1.1.1
	v1_1b6:1.1.1.1
	v1_1r:1.1.1.1.0.4
	v1_1:1.1.1.1
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2001.03.26.08.57.16;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.26.05.29.06;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.18.08.18.47;	author eban;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.13.16.12.27;	author eban;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.03.09.08.59.58;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.08;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.08;	author matz;	state Exp;
branches
	1.1.1.1.10.1;
next	;

1.1.1.1.10.1
date	2000.03.09.09.04.36;	author matz;	state Exp;
branches;
next	;

1.3.2.1
date	2001.02.18.08.18.52;	author eban;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.02.26.04.07.52;	author matz;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.04.16.06.54.40;	author matz;	state Exp;
branches;
next	;


desc
@@


1.6
log
@* eval.c: remove TMP_PROTECT_END to prevent C_ALLOCA crash.

* file.c (rb_file_flock): do not trap EINTR.

* missing/flock.c (flock): returns the value from lockf(2)
  directly.

* eval.c (ev_const_defined): should ignore toplevel cbase (Object).

* eval.c (ev_const_get): ditto.

* ext/md5/md5.h: replace by independent md5 implementation
  contributed by L. Peter Deutsch (thanks).

* ext/md5/md5init.c: adopted to Deutsch's md5 implementation.

* pack.c (pack_unpack): string from P/p should be tainted.

* ext/curses/curses.c: curses on Mac OS X public beta does not
  have _maxx etc.

* marshal.c (w_object): should truncate trailing zero short for
  bignums.

* object.c (sym_intern): new method.
@
text
@#include "config.h"

#if defined HAVE_FCNTL && defined HAVE_FCNTL_H

/* These are the flock() constants.  Since this sytems doesn't have
   flock(), the values of the constants are probably not available.
*/
# ifndef LOCK_SH
#  define LOCK_SH 1
# endif
# ifndef LOCK_EX
#  define LOCK_EX 2
# endif
# ifndef LOCK_NB
#  define LOCK_NB 4
# endif
# ifndef LOCK_UN
#  define LOCK_UN 8
# endif

#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

int
flock(fd, operation)
    int fd;
    int operation;
{
    struct flock lock;
 
    switch (operation & ~LOCK_NB) {
    case LOCK_SH:
	lock.l_type = F_RDLCK;
	break;
    case LOCK_EX:
	lock.l_type = F_WRLCK;
	break;
    case LOCK_UN:
	lock.l_type = F_UNLCK;
	break;
    default:
	errno = EINVAL;
	return -1;
    }
    lock.l_whence = SEEK_SET;
    lock.l_start = lock.l_len = 0L;
 
    return fcntl(fd, (operation & LOCK_NB) ? F_SETLK : F_SETLKW, &lock);
}

#elif defined(HAVE_LOCKF)

#include <unistd.h>
#include <errno.h>

/*  Emulate flock() with lockf() or fcntl().  This is just to increase
    portability of scripts.  The calls might not be completely
    interchangeable.  What's really needed is a good file
    locking module.
*/

# ifndef F_ULOCK
#  define F_ULOCK	0	/* Unlock a previously locked region */
# endif
# ifndef F_LOCK
#  define F_LOCK	1	/* Lock a region for exclusive use */
# endif
# ifndef F_TLOCK
#  define F_TLOCK	2	/* Test and lock a region for exclusive use */
# endif
# ifndef F_TEST
#  define F_TEST	3	/* Test a region for other processes locks */
# endif

/* These are the flock() constants.  Since this sytems doesn't have
   flock(), the values of the constants are probably not available.
*/
# ifndef LOCK_SH
#  define LOCK_SH 1
# endif
# ifndef LOCK_EX
#  define LOCK_EX 2
# endif
# ifndef LOCK_NB
#  define LOCK_NB 4
# endif
# ifndef LOCK_UN
#  define LOCK_UN 8
# endif

int
flock(fd, operation)
    int fd;
    int operation;
{
    switch (operation) {

	/* LOCK_SH - get a shared lock */
      case LOCK_SH:
        rb_notimplement();
        return -1;
	/* LOCK_EX - get an exclusive lock */
      case LOCK_EX:
	return lockf (fd, F_LOCK, 0);

	/* LOCK_SH|LOCK_NB - get a non-blocking shared lock */
      case LOCK_SH|LOCK_NB:
        rb_notimplement();
        return -1;
	/* LOCK_EX|LOCK_NB - get a non-blocking exclusive lock */
      case LOCK_EX|LOCK_NB:
	return lockf (fd, F_TLOCK, 0);

	/* LOCK_UN - unlock */
      case LOCK_UN:
	return lockf (fd, F_ULOCK, 0);

	/* Default - can't decipher operation */
      default:
	errno = EINVAL;
        return -1;
    }
}
#elif !defined NT
int
flock(fd, operation)
    int fd;
    int operation;
{
    rb_notimplement();
    return -1;
}
#endif
@


1.5
log
@* eval.c (proc_call): should not modify ruby_block->frame.iter
  based on ruby_frame->iter altered by PUSH_ITER().

* eval.c (rb_thread_fd_close): should save current context before
  raising exception.

* io.c (set_stdin): preserve original stdin.

* io.c (set_outfile): preserve original stdout/stderr.
@
text
@a96 1
    int i;
d105 1
a105 2
	i = lockf (fd, F_LOCK, 0);
	break;
d113 1
a113 5
	i = lockf (fd, F_TLOCK, 0);
	if (i == -1)
	    if ((errno == EAGAIN) || (errno == EACCES))
		errno = EWOULDBLOCK;
	break;
d117 1
a117 2
	i = lockf (fd, F_ULOCK, 0);
	break;
a120 1
	i = -1;
d122 1
a122 1
	break;
a123 1
    return i;
@


1.4
log
@* ext/curses/extconf.rb: add dir_config.
quote> * missing/flock.c: use fcntl(2) instead of lockf(2).
@
text
@d102 2
d111 2
@


1.3
log
@support mingw32.
@
text
@d3 50
a52 1
#if defined(HAVE_LOCKF)
a128 48
}
#elif defined HAVE_FCNTL && defined HAVE_FCNTL_H

/* These are the flock() constants.  Since this sytems doesn't have
   flock(), the values of the constants are probably not available.
*/
# ifndef LOCK_SH
#  define LOCK_SH 1
# endif
# ifndef LOCK_EX
#  define LOCK_EX 2
# endif
# ifndef LOCK_NB
#  define LOCK_NB 4
# endif
# ifndef LOCK_UN
#  define LOCK_UN 8
# endif

#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

int
flock(fd, operation)
    int fd;
    int operation;
{
    struct flock lock;
 
    switch (operation & ~LOCK_NB) {
    case LOCK_SH:
	lock.l_type = F_RDLCK;
	break;
    case LOCK_EX:
	lock.l_type = F_WRLCK;
	break;
    case LOCK_UN:
	lock.l_type = F_UNLCK;
	break;
    default:
	errno = EINVAL;
	return -1;
    }
    lock.l_whence = SEEK_SET;
    lock.l_start = lock.l_len = 0L;
 
    return fcntl(fd, (operation & LOCK_NB) ? F_SETLK : F_SETLKW, &lock);
@


1.3.2.1
log
@* ext/curses/extconf.rb: add dir_config.
* missing/flock.c: use fcntl(2) instead of lockf(2).
@
text
@d3 1
a3 50
#if defined HAVE_FCNTL && defined HAVE_FCNTL_H

/* These are the flock() constants.  Since this sytems doesn't have
   flock(), the values of the constants are probably not available.
*/
# ifndef LOCK_SH
#  define LOCK_SH 1
# endif
# ifndef LOCK_EX
#  define LOCK_EX 2
# endif
# ifndef LOCK_NB
#  define LOCK_NB 4
# endif
# ifndef LOCK_UN
#  define LOCK_UN 8
# endif

#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

int
flock(fd, operation)
    int fd;
    int operation;
{
    struct flock lock;
 
    switch (operation & ~LOCK_NB) {
    case LOCK_SH:
	lock.l_type = F_RDLCK;
	break;
    case LOCK_EX:
	lock.l_type = F_WRLCK;
	break;
    case LOCK_UN:
	lock.l_type = F_UNLCK;
	break;
    default:
	errno = EINVAL;
	return -1;
    }
    lock.l_whence = SEEK_SET;
    lock.l_start = lock.l_len = 0L;
 
    return fcntl(fd, (operation & LOCK_NB) ? F_SETLK : F_SETLKW, &lock);
}

#elif defined(HAVE_LOCKF)
d80 48
@


1.3.2.2
log
@* eval.c (proc_call): should not modify ruby_block->frame.iter
  based on ruby_frame->iter altered by PUSH_ITER().

* eval.c (rb_thread_fd_close): should save current context before
  raising exception.
@
text
@a101 2
        rb_notimplement();
        return -1;
a108 2
        rb_notimplement();
        return -1;
@


1.3.2.3
log
@* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).
@
text
@d97 1
d106 2
a107 1
	return lockf (fd, F_LOCK, 0);
d115 5
a119 1
	return lockf (fd, F_TLOCK, 0);
d123 2
a124 1
	return lockf (fd, F_ULOCK, 0);
d128 1
d130 1
a130 1
        return -1;
d132 1
@


1.2
log
@2000-03-09
@
text
@d129 1
a129 1
#else
@


1.1
log
@Initial revision
@
text
@d81 48
@


1.1.1.1
log
@
@
text
@@


1.1.1.1.10.1
log
@2000-03-09
@
text
@a80 48
#elif defined HAVE_FCNTL && defined HAVE_FCNTL_H

/* These are the flock() constants.  Since this sytems doesn't have
   flock(), the values of the constants are probably not available.
*/
# ifndef LOCK_SH
#  define LOCK_SH 1
# endif
# ifndef LOCK_EX
#  define LOCK_EX 2
# endif
# ifndef LOCK_NB
#  define LOCK_NB 4
# endif
# ifndef LOCK_UN
#  define LOCK_UN 8
# endif

#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

int
flock(fd, operation)
    int fd;
    int operation;
{
    struct flock lock;
 
    switch (operation & ~LOCK_NB) {
    case LOCK_SH:
	lock.l_type = F_RDLCK;
	break;
    case LOCK_EX:
	lock.l_type = F_WRLCK;
	break;
    case LOCK_UN:
	lock.l_type = F_UNLCK;
	break;
    default:
	errno = EINVAL;
	return -1;
    }
    lock.l_whence = SEEK_SET;
    lock.l_start = lock.l_len = 0L;
 
    return fcntl(fd, (operation & LOCK_NB) ? F_SETLK : F_SETLKW, &lock);
}
@

