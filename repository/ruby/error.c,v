head	1.50;
access;
symbols
	v1_6_7:1.19.2.3
	v1_6_6:1.19.2.2
	v1_6_5:1.19.2.2
	v1_6_4:1.19.2.1
	v1_7_1:1.27
	v1_6_4_preview4:1.19.2.1
	v1_6_4_preview3:1.19.2.1
	v1_6_4_preview2:1.19.2.1
	v1_6_4_preview1:1.19.2.1
	v1_6_3:1.19.2.1
	ruby_m17n:1.19.0.4
	ruby_1_6:1.19.0.2
	v1_6_2:1.19
	v1_6_1:1.16
	v1_6_0:1.16
	v1_4_6:1.3.2.6
	v1_4_5:1.3.2.6
	v1_4_4:1.3.2.4
	ruby_1_4_3:1.3.2.2
	ruby1_4_3:1.3.2.2
	v1_4_3:1.3.2.2
	v1_5_0:1.7
	ruby_1_4_3_pre1:1.3.2.2
	ruby_1_4:1.3.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.8
	v1_3_6_repack:1.1.1.3.2.8
	v1_3_6:1.1.1.3.2.8
	v1_3_5:1.1.1.3.2.8
	v1_2_6repack:1.1.1.2.2.25
	v1_3_4_990625:1.1.1.3.2.8
	v1_3_4_990624:1.1.1.3.2.8
	v1_2_6:1.1.1.2.2.25
	v1_3_4_990611:1.1.1.3.2.8
	v1_3_4_990531:1.1.1.3.2.8
	v1_3_3_990518:1.1.1.3.2.7
	v1_3_3_990513:1.1.1.3.2.7
	v1_3_3_990507:1.1.1.3.2.7
	v1_2_5:1.1.1.2.2.25
	v1_2_4:1.1.1.2.2.25
	v1_3_1_990225:1.1.1.3.2.5
	v1_3_1_990224:1.1.1.3.2.4
	v1_3_1_990215:1.1.1.3.2.3
	v1_3_1_990212:1.1.1.3.2.3
	v1_3_1_990210:1.1.1.3.2.3
	v1_3_1_:1.1.1.3.2.3
	v1_3_1_990209:1.1.1.3.2.3
	v1_3_1_990205:1.1.1.3.2.2
	v1_3_1_990203:1.1.1.3.2.2
	v1_3_1_990201:1.1.1.3.2.2
	v1_3_1"_990201:1.1.1.3.2.2
	v1_3_1_990128:1.1.1.3.2.1
	v1_3_1_990127:1.1.1.3.2.1
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.24
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.24
	v1_2_1repack:1.1.1.2.2.24
	v1_2_1:1.1.1.2.2.24
	v1_2_stable:1.1.1.2.2.24
	v1_1d1:1.1.1.2.2.24.2.3
	v1_1d0:1.1.1.2.2.24.2.3
	v1_1c9_1:1.1.1.2.2.24
	v1_1c9:1.1.1.2.2.24
	v1_1c8:1.1.1.2.2.24
	v1_1c7:1.1.1.2.2.24
	v1_1c6:1.1.1.2.2.24
	v1_1d-start:1.1.1.2.2.24.2.1
	v1_1c5:1.1.1.2.2.24
	v1_1dev:1.1.1.2.2.24.0.2
	v1_1c4:1.1.1.2.2.24
	v1_1c3:1.1.1.2.2.24
	v1_1c2:1.1.1.2.2.24
	v1_1c1:1.1.1.2.2.23
	v1_1c0:1.1.1.2.2.22
	v1_1b9_31:1.1.1.2.2.22
	v1_1b9_30:1.1.1.2.2.21
	v1_1b9_28:1.1.1.2.2.21
	v1_1b9_27:1.1.1.2.2.20
	v1_1b9_26:1.1.1.2.2.20
	r1_1b9_25:1.1.1.2.2.20
	r1_1b9_24:1.1.1.2.2.20
	v1_1b9_23:1.1.1.2.2.19
	v1_1b9_22:1.1.1.2.2.19
	v1_1b9_20:1.1.1.2.2.16
	v1_1b9_18:1.1.1.2.2.12
	v1_1b9_16:1.1.1.2.2.7
	v1_1b9_15:1.1.1.2.2.7
	v1_1b9_13:1.1.1.2.2.7
	v1_1b9_12:1.1.1.2.2.7
	v1_1b9_11:1.1.1.2.2.7
	v1_1b9_08:1.1.1.2.2.7
	v1_1b9_07:1.1.1.2.2.7
	r1_1b9:1.1.1.2.2.3
	v1_1b8:1.1.1.2.2.3
	v1_1b7:1.1.1.2.2.2
	v1_1b6:1.1.1.2.2.2
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2002.09.14.11.17.32;	author H_Konishi;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.03.05.20.06;	author matz;	state Exp;
branches;
next	1.48;

1.48
date	2002.08.28.08.05.23;	author michal;	state Exp;
branches;
next	1.47;

1.47
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.46;

1.46
date	2002.08.15.11.49.39;	author nobu;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.11.01.27.46;	author H_Konishi;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.02.07.50.36;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2002.04.24.04.54.13;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2002.04.15.07.48.45;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2002.04.01.08.31.45;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.22.07.26.35;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.19.09.03.07;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2002.01.18.14.23.06;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2002.01.11.09.18.49;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.04.14.14.34;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.10.07.18.12;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.13.08.19.51;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2001.10.29.05.07.17;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2001.10.03.07.19.10;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.03.05.16.29;	author knu;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.03.05.52.20;	author shugo;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.02.08.46.21;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.05.07.50.59;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.30.09.12.33;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.02.04.22.10;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.19.09.14.58;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.19.07.03.05;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.08.09.19.16;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.29.05.10.41;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.09.08.24.35;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.09.07.26.16;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.14.07.10.20;	author matz;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2000.11.10.08.52.23;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.08.05.29.21;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.24.06.21.28;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.10.04.49.10;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.22.08.29.41;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.01.09.41.13;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.10.05.44.06;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.07.08.37.28;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.01.03.12.00;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.05.04.36.59;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.12.14.06.49.40;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.12.01.09.24.12;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.11.04.08.39.36;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.10.18.09.03.00;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.10.16.10.33.05;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.10.12.04.53.32;	author matz;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.08.13.05.45.04;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.09;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.22;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.10;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.01.07.34.53;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.09.06.08.19;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.02.24.04.31.18;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.02.25.06.39.05;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.03.24.08.52.25;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.05.06.08.31.30;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.05.25.08.25.52;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.44;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.23.10.01.07;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.02.18.01.56.31;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.03.05.06.37.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.03.25.09.36.57;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.04.02.10.03.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.04.07.08.34.06;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.04.30.07.41.08;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.05.01.08.56.27;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.05.06.03.08.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.05.06.09.16.04;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.05.12.08.38.36;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.05.13.05.57.52;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.05.13.07.26.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.05.14.04.10.27;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.05.15.05.43.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.05.18.04.55.58;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.05.18.05.57.37;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.05.18.09.12.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.06.02.10.05.17;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.06.26.09.44.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.07.13.04.37.25;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.07.24.04.41.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.08.10.05.41.12;	author matz;	state Exp;
branches
	1.1.1.2.2.24.2.1;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	99.02.09.03.29.21;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.24.2.1
date	98.09.08.07.08.39;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24.2.2;

1.1.1.2.2.24.2.2
date	98.10.06.03.28.06;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24.2.3;

1.1.1.2.2.24.2.3
date	98.12.16.07.30.29;	author matz;	state Exp;
branches;
next	;

1.3.2.1
date	99.10.18.09.03.16;	author matz;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	99.11.24.07.13.50;	author matz;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	99.12.14.06.50.37;	author matz;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2000.01.17.08.23.54;	author matz;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2000.04.10.05.48.27;	author matz;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2000.05.01.09.42.21;	author matz;	state Exp;
branches;
next	;

1.19.2.1
date	2001.02.02.11.39.51;	author matz;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.09.03.05.18.02;	author knu;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2002.01.21.07.43.39;	author matz;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2002.04.02.09.47.46;	author matz;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2002.09.25.07.07.36;	author matz;	state Exp;
branches;
next	;


desc
@@


1.50
log
@* error.c(rb_sys_fail): remove case EPIPE on bcc32 .
@
text
@/**********************************************************************

  error.c -

  $Author: matz $
  $Date: 2002/09/03 05:20:06 $
  created at: Mon Aug  9 16:11:34 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto

**********************************************************************/

#include "ruby.h"
#include "env.h"
#include "version.h"

#include <stdio.h>
#ifdef HAVE_STDARG_PROTOTYPES
#include <stdarg.h>
#define va_init_list(a,b) va_start(a,b)
#else
#include <varargs.h>
#define va_init_list(a,b) va_start(a)
#endif

#if defined __CYGWIN__
# include <cygwin/version.h>
# if (CYGWIN_VERSION_API_MAJOR > 0) || (CYGWIN_VERSION_API_MINOR >= 8)
#  define sys_nerr _sys_nerr
# endif
#endif

int ruby_nerrs;

static void
err_snprintf(buf, len, fmt, args)
    char *buf, *fmt;
    long len;
    va_list args;
{
    long n;

    ruby_set_current_source();
    if (!ruby_sourcefile) {
	vsnprintf(buf, len, fmt, args);
	return;
    }
    else if (ruby_sourceline == 0) {
	n = snprintf(buf, len, "%s: ", ruby_sourcefile);
    }
    else {
	n = snprintf(buf, len, "%s:%d: ", ruby_sourcefile, ruby_sourceline);
    }
    if (len > n) {
	vsnprintf((char*)buf+n, len-n, fmt, args);
    }
}

static void err_append _((const char*));
static void
err_print(fmt, args)
    const char *fmt;
    va_list args;
{
    char buf[BUFSIZ];

    err_snprintf(buf, BUFSIZ, fmt, args);
    err_append(buf);
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_compile_error(const char *fmt, ...)
#else
rb_compile_error(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    va_list args;

    va_init_list(args, fmt);
    err_print(fmt, args);
    va_end(args);
    ruby_nerrs++;
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_compile_error_append(const char *fmt, ...)
#else
rb_compile_error_append(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    va_list args;
    char buf[BUFSIZ];

    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);
    err_append(buf);
}

static void
warn_print(fmt, args)
    const char *fmt;
    va_list args;
{
    char buf[BUFSIZ];

    err_snprintf(buf, BUFSIZ, fmt, args);
    fputs(buf, stderr);
    fputs("\n", stderr);
    fflush(stderr);
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_warn(const char *fmt, ...)
#else
rb_warn(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    char buf[BUFSIZ];
    va_list args;

    snprintf(buf, BUFSIZ, "warning: %s", fmt);

    va_init_list(args, fmt);
    warn_print(buf, args);
    va_end(args);
}

/* rb_warning() reports only in verbose mode */
void
#ifdef HAVE_STDARG_PROTOTYPES
rb_warning(const char *fmt, ...)
#else
rb_warning(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    char buf[BUFSIZ];
    va_list args;

    if (!RTEST(ruby_verbose)) return;

    snprintf(buf, BUFSIZ, "warning: %s", fmt);

    va_init_list(args, fmt);
    warn_print(buf, args);
    va_end(args);
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_bug(const char *fmt, ...)
#else
rb_bug(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    char buf[BUFSIZ];
    va_list args;

    snprintf(buf, BUFSIZ, "[BUG] %s", fmt);
    ruby_in_eval = 0;

    va_init_list(args, fmt);
    warn_print(buf, args);
    va_end(args);
    fprintf(stderr, "ruby %s (%s) [%s]\n", RUBY_VERSION, RUBY_RELEASE_DATE, RUBY_PLATFORM);
    abort();
}

static struct types {
    int type;
    const char *name;
} builtin_types[] = {
    {T_NIL,	"nil"},
    {T_OBJECT,	"Object"},
    {T_CLASS,	"Class"},
    {T_ICLASS,	"iClass"},	/* internal use: mixed-in module holder */
    {T_MODULE,	"Module"},
    {T_FLOAT,	"Float"},
    {T_STRING,	"String"},
    {T_REGEXP,	"Regexp"},
    {T_ARRAY,	"Array"},
    {T_FIXNUM,	"Fixnum"},
    {T_HASH,	"Hash"},
    {T_STRUCT,	"Struct"},
    {T_BIGNUM,	"Bignum"},
    {T_FILE,	"File"},
    {T_TRUE,	"true"},
    {T_FALSE,	"false"},
    {T_SYMBOL,	"Symbol"},	/* :symbol */
    {T_DATA,	"Data"},	/* internal use: wrapped C pointers */
    {T_MATCH,	"MatchData"},	/* data of $~ */
    {T_VARMAP,	"Varmap"},	/* internal use: dynamic variables */
    {T_SCOPE,	"Scope"},	/* internal use: variable scope */
    {T_NODE,	"Node"},	/* internal use: syntax tree node */
    {T_UNDEF,	"undef"},	/* internal use: #undef; should not happen */
    {-1,	0}
};

void
rb_check_type(x, t)
    VALUE x;
    int t;
{
    struct types *type = builtin_types;

    if (x == Qundef) {
	rb_bug("undef leaked to the Ruby space");
    }

    if (TYPE(x) != t) {
	while (type->type >= 0) {
	    if (type->type == t) {
		char *etype;

		if (NIL_P(x)) {
		    etype = "nil";
		}
		else if (FIXNUM_P(x)) {
		    etype = "Fixnum";
		}
		else if (rb_special_const_p(x)) {
		    etype = RSTRING(rb_obj_as_string(x))->ptr;
		}
		else {
		    etype = rb_class2name(CLASS_OF(x));
		}
		rb_raise(rb_eTypeError, "wrong argument type %s (expected %s)",
			 etype, type->name);
	    }
	    type++;
	}
	rb_bug("unknown type 0x%x", t);
    }
}

/* exception classes */
#include <errno.h>

VALUE rb_eException;
VALUE rb_eSystemExit;
VALUE rb_eInterrupt;
VALUE rb_eSignal;
VALUE rb_eFatal;
VALUE rb_eStandardError;
VALUE rb_eRuntimeError;
VALUE rb_eTypeError;
VALUE rb_eArgError;
VALUE rb_eIndexError;
VALUE rb_eRangeError;
VALUE rb_eNameError;
VALUE rb_eNoMethodError;
VALUE rb_eSecurityError;
VALUE rb_eNotImpError;
VALUE rb_eNoMemError;

VALUE rb_eScriptError;
VALUE rb_eSyntaxError;
VALUE rb_eLoadError;

VALUE rb_eSystemCallError;
VALUE rb_mErrno;

VALUE
rb_exc_new(etype, ptr, len)
    VALUE etype;
    const char *ptr;
    long len;
{
    return rb_funcall(etype, rb_intern("new"), 1, rb_str_new(ptr, len));
}

VALUE
rb_exc_new2(etype, s)
    VALUE etype;
    const char *s;
{
    return rb_exc_new(etype, s, strlen(s));
}

VALUE
rb_exc_new3(etype, str)
    VALUE etype, str;
{
    StringValue(str);
    return rb_exc_new(etype, RSTRING(str)->ptr, RSTRING(str)->len);
}

static VALUE
exc_initialize(argc, argv, exc)
    int argc;
    VALUE *argv;
    VALUE exc;
{
    VALUE mesg;

    if (rb_scan_args(argc, argv, "01", &mesg) == 1) {
	StringValue(mesg);	/* ensure mesg can be converted to String */
    }
    rb_iv_set(exc, "mesg", mesg);
    rb_iv_set(exc, "bt", Qnil);

    return exc;
}

static VALUE
exc_exception(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE exc;

    if (argc == 0) return self;
    if (argc == 1 && self == argv[0]) return self;
    exc = rb_obj_clone(self);
    exc_initialize(argc, argv, exc);

    return exc;
}

static VALUE
exc_to_s(exc)
    VALUE exc;
{
    VALUE mesg = rb_iv_get(exc, "mesg");

    if (NIL_P(mesg)) return rb_class_path(CLASS_OF(exc));
    if (OBJ_TAINTED(exc)) OBJ_TAINT(mesg);
    return mesg;
}

static VALUE
exc_inspect(exc)
    VALUE exc;
{
    VALUE str, klass;

    klass = CLASS_OF(exc);
    exc = rb_obj_as_string(exc);
    if (RSTRING(exc)->len == 0) {
	return rb_str_dup(rb_class_path(klass));
    }

    str = rb_str_buf_new2("#<");
    klass = rb_class_path(klass);
    rb_str_buf_append(str, klass);
    rb_str_buf_cat(str, ": ", 2);
    rb_str_buf_append(str, exc);
    rb_str_buf_cat(str, ">", 1);

    return str;
}

static VALUE
exc_backtrace(exc)
    VALUE exc;
{
    ID bt = rb_intern("bt");

    if (!rb_ivar_defined(exc, bt)) return Qnil;
    return rb_ivar_get(exc, bt);
}

static VALUE
check_backtrace(bt)
    VALUE bt;
{
    long i;
    static char *err = "backtrace must be Array of String";

    if (!NIL_P(bt)) {
	int t = TYPE(bt);

	if (t == T_STRING) return rb_ary_new3(1, bt);
	if (t != T_ARRAY) {
	    rb_raise(rb_eTypeError, err);
	}
	for (i=0;i<RARRAY(bt)->len;i++) {
	    if (TYPE(RARRAY(bt)->ptr[i]) != T_STRING) {
		rb_raise(rb_eTypeError, err);
	    }
	}
    }
    return bt;
}

static VALUE
exc_set_backtrace(exc, bt)
    VALUE exc;
    VALUE bt;
{
    return rb_iv_set(exc, "bt", check_backtrace(bt));
}

static VALUE
exit_status(exc)
    VALUE exc;
{
    return rb_iv_get(exc, "status");
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_name_error(ID id, const char *fmt, ...)
#else
rb_name_error(id, fmt, va_alist)
    ID id;
    const char *fmt;
    va_dcl
#endif
{
    VALUE exc;

    va_list args;
    char buf[BUFSIZ];

    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);
    exc = rb_exc_new2(rb_eNameError, buf);
    rb_iv_set(exc, "name", ID2SYM(id));
    rb_exc_raise(exc);
}

static VALUE
name_err_name(self)
    VALUE self;
{
    return rb_iv_get(self, "name");
}

static VALUE
nometh_err_args(self)
    VALUE self;
{
    return rb_iv_get(self, "args");
}

void
rb_invalid_str(str, type)
    const char *str, *type;
{
    VALUE s = rb_str_inspect(rb_str_new2(str));

    rb_raise(rb_eArgError, "invalid value for %s: %s", type, RSTRING(s)->ptr);
}

#ifdef __BEOS__
typedef struct {
   VALUE *list;
   int n;
} syserr_list_entry;

typedef struct {
   int ix;
   int n;
} syserr_index_entry;

static VALUE syserr_error;
static VALUE syserr_list_b_general[16+1];
static VALUE syserr_list_b_os0[2+1];
static VALUE syserr_list_b_os1[5+1];
static VALUE syserr_list_b_os2[2+1];
static VALUE syserr_list_b_os3[3+1];
static VALUE syserr_list_b_os4[1+1];
static VALUE syserr_list_b_app[15+1];
static VALUE syserr_list_b_interface[0+1];
static VALUE syserr_list_b_media[8+1];
static VALUE syserr_list_b_midi[0+1];
static VALUE syserr_list_b_storage[15+1];
static VALUE syserr_list_b_posix[38+1];
static VALUE syserr_list_b_mail[8+1];
static VALUE syserr_list_b_print[1+1];
static VALUE syserr_list_b_device[14+1];

# define SYSERR_LIST_B(n) {(n), sizeof(n)/sizeof(VALUE)}
static const syserr_list_entry syserr_list[] = {
   SYSERR_LIST_B(syserr_list_b_general),
   SYSERR_LIST_B(syserr_list_b_os0),
   SYSERR_LIST_B(syserr_list_b_os1),
   SYSERR_LIST_B(syserr_list_b_os2),
   SYSERR_LIST_B(syserr_list_b_os3),
   SYSERR_LIST_B(syserr_list_b_os4),
   SYSERR_LIST_B(syserr_list_b_app),
   SYSERR_LIST_B(syserr_list_b_interface),
   SYSERR_LIST_B(syserr_list_b_media),
   SYSERR_LIST_B(syserr_list_b_midi),
   SYSERR_LIST_B(syserr_list_b_storage),
   SYSERR_LIST_B(syserr_list_b_posix),
   SYSERR_LIST_B(syserr_list_b_mail),
   SYSERR_LIST_B(syserr_list_b_print),
   SYSERR_LIST_B(syserr_list_b_device),
};
# undef SYSERR_LIST_B

static const syserr_index_entry syserr_index[]= {
     {0, 1},  {1, 5},  {6, 1},  {7, 1}, {8, 1}, {9, 1}, {10, 1}, {11, 1},
     {12, 1}, {13, 1}, {14, 1}, {0, 0},
};
#else
static VALUE *syserr_list;
#endif

#if !HAVE_DECL_SYS_NERR
extern int sys_nerr;
#endif

static VALUE
set_syserr(i, name)
    int i;
    const char *name;
{
#ifdef __BEOS__
   VALUE *list;
   int ix, offset;
#endif
    VALUE error = rb_define_class_under(rb_mErrno, name, rb_eSystemCallError);
    rb_define_const(error, "Errno", INT2NUM(i));
#ifdef __BEOS__
   if (i == B_ERROR) {
      syserr_error = error;
      rb_global_variable(&syserr_error);
      return error;
   }
   i -= B_GENERAL_ERROR_BASE;
   ix = (i >> 12) & 0xf;
   offset = (i >> 8) & 0xf;
   if (offset < syserr_index[ix].n) {
      ix = syserr_index[ix].ix;
      if ((i & 0xff) < syserr_list[ix + offset].n) {
	 list = syserr_list[ix + offset].list;
	 list[i & 0xff] = error;
	 rb_global_variable(&list[i & 0xff]);
      }
   }
#else
    if (i <= sys_nerr) {
	syserr_list[i] = error;
    }
#endif
    return error;
}

static VALUE
syserr_errno(self)
    VALUE self;
{
    return rb_iv_get(self, "errno");
}

static VALUE
syserr_eqq(self, exc)
    VALUE self, exc;
{
    VALUE num;

    if (!rb_obj_is_kind_of(exc, rb_eSystemCallError)) return Qfalse;
    if (self == rb_eSystemCallError) return Qtrue;

    num = rb_iv_get(exc, "errno");
    if (NIL_P(num)) {
	VALUE klass = CLASS_OF(exc);

	while (TYPE(klass) == T_ICLASS || FL_TEST(klass, FL_SINGLETON)) {
	    klass = (VALUE)RCLASS(klass)->super;
	}
	num = rb_const_get(klass, rb_intern("Errno"));
    }
    if (rb_const_get(self, rb_intern("Errno")) == num)
	return Qtrue;
    return Qfalse;
}

#ifdef __BEOS__
static VALUE
get_syserr(int i)
{
   VALUE *list;
   int ix, offset;
   
   if (i == B_ERROR) return syserr_error;
   i -= B_GENERAL_ERROR_BASE;
   ix = (i >> 12) & 0xf;
   offset = (i >> 8) & 0xf;
   if (offset < syserr_index[ix].n) {
      ix = syserr_index[ix].ix;
      if ((i & 0xff) < syserr_list[ix + offset].n) {
	 list = syserr_list[ix + offset].list;
	 return list[i & 0xff];
      }
   }
   return 0;
}
#endif /* __BEOS__ */

static void init_syserr _((void));

void
Init_Exception()
{
    rb_eException   = rb_define_class("Exception", rb_cObject);
    rb_define_singleton_method(rb_eException, "exception", rb_class_new_instance, -1);
    rb_define_method(rb_eException, "exception", exc_exception, -1);
    rb_define_method(rb_eException, "initialize", exc_initialize, -1);
    rb_define_method(rb_eException, "to_s", exc_to_s, 0);
    rb_define_method(rb_eException, "to_str", exc_to_s, 0);
    rb_define_method(rb_eException, "message", exc_to_s, 0);
    rb_define_method(rb_eException, "inspect", exc_inspect, 0);
    rb_define_method(rb_eException, "backtrace", exc_backtrace, 0);
    rb_define_method(rb_eException, "set_backtrace", exc_set_backtrace, 1);

    rb_eSystemExit  = rb_define_class("SystemExit", rb_eException);
    rb_define_method(rb_eSystemExit, "status", exit_status, 0);

    rb_eFatal  	    = rb_define_class("fatal", rb_eException);
    rb_eSignal      = rb_define_class("SignalException", rb_eException);
    rb_eInterrupt   = rb_define_class("Interrupt", rb_eSignal);

    rb_eStandardError = rb_define_class("StandardError", rb_eException);
    rb_eTypeError     = rb_define_class("TypeError", rb_eStandardError);
    rb_eArgError      = rb_define_class("ArgumentError", rb_eStandardError);
    rb_eIndexError    = rb_define_class("IndexError", rb_eStandardError);
    rb_eRangeError    = rb_define_class("RangeError", rb_eStandardError);
    rb_eNameError     = rb_define_class("NameError", rb_eStandardError);
    rb_define_method(rb_eNameError, "name", name_err_name, 0);
    rb_eNoMethodError = rb_define_class("NoMethodError", rb_eNameError);
    rb_define_method(rb_eNoMethodError, "args", nometh_err_args, 0);

    rb_eScriptError = rb_define_class("ScriptError", rb_eException);
    rb_eSyntaxError = rb_define_class("SyntaxError", rb_eScriptError);
    rb_eLoadError   = rb_define_class("LoadError", rb_eScriptError);
    rb_eNotImpError = rb_define_class("NotImplementedError", rb_eScriptError);

    rb_eRuntimeError = rb_define_class("RuntimeError", rb_eStandardError);
    rb_eSecurityError = rb_define_class("SecurityError", rb_eStandardError);
    rb_eNoMemError = rb_define_class("NoMemoryError", rb_eException);

    init_syserr();
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_raise(VALUE exc, const char *fmt, ...)
#else
rb_raise(exc, fmt, va_alist)
    VALUE exc;
    const char *fmt;
    va_dcl
#endif
{
    va_list args;
    char buf[BUFSIZ];

    va_init_list(args,fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);
    rb_exc_raise(rb_exc_new2(exc, buf));
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_loaderror(const char *fmt, ...)
#else
rb_loaderror(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    va_list args;
    char buf[BUFSIZ];

    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);
    rb_exc_raise(rb_exc_new2(rb_eLoadError, buf));
}

void
rb_notimplement()
{
    rb_raise(rb_eNotImpError,
	     "The %s() function is unimplemented on this machine",
	     rb_id2name(ruby_frame->last_func));
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_fatal(const char *fmt, ...)
#else
rb_fatal(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    va_list args;
    char buf[BUFSIZ];

    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);

    ruby_in_eval = 0;
    rb_exc_fatal(rb_exc_new2(rb_eFatal, buf));
}

void
rb_sys_fail(mesg)
    const char *mesg;
{
#if !defined(NT) && !defined(__VMS)
    char *strerror();
#endif
    char *err;
    char *buf;
    extern int errno;
    int n = errno;
    VALUE ee;

    if (errno == 0) {
	rb_bug("rb_sys_fail() - errno == 0");
    }

    err = strerror(errno);
    if (mesg) {
	volatile VALUE tmp = rb_str_inspect(rb_str_new2(mesg));

	buf = ALLOCA_N(char, strlen(err)+RSTRING(tmp)->len+4);
	sprintf(buf, "%s - %s", err, RSTRING(tmp)->ptr);
    }
    else {
	buf = ALLOCA_N(char, strlen(err)+1);
	strcpy(buf, err);
    }

    errno = 0;
#ifdef __BEOS__
    ee = get_syserr(n);
    if (!ee) {
	char name[12];
      
	sprintf(name, "E%03d", n);
	ee = set_syserr(n, name);
   }
#else
    if (n > sys_nerr || !syserr_list[n]) {
	char name[12];

	sprintf(name, "E%03d", n);
	ee = set_syserr(n, name);
    }
    else {
	ee = syserr_list[n];
    }
#endif
    ee = rb_exc_new2(ee, buf);
    rb_iv_set(ee, "errno", INT2NUM(n));
    rb_exc_raise(ee);
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_sys_warning(const char *fmt, ...)
#else
rb_sys_warning(fmt, va_alist)
     const char *fmt;
     va_dcl
#endif
{
     char buf[BUFSIZ];
     va_list args;
     int errno_save;
     
     errno_save = errno;

     if (!RTEST(ruby_verbose)) return;

     snprintf(buf, BUFSIZ, "warning: %s", fmt);
     snprintf(buf+strlen(buf), BUFSIZ-strlen(buf), ": %s", strerror(errno_save));
     
     va_init_list(args, fmt);
     warn_print(buf, args);
     va_end(args);
     errno = errno_save;
}

void
rb_load_fail(path)
    char *path;
{
    rb_loaderror("%s -- %s", strerror(errno), path);
}

void
rb_error_frozen(what)
    char *what;
{
    rb_raise(rb_eTypeError, "can't modify frozen %s", what);
}

void
rb_check_frozen(obj)
    VALUE obj;
{
    if (OBJ_FROZEN(obj)) rb_error_frozen(rb_class2name(CLASS_OF(obj)));
}

static void
init_syserr()
{
#ifdef __BEOS__
   int i, ix, offset;
#endif
    rb_eSystemCallError = rb_define_class("SystemCallError", rb_eStandardError);
    rb_define_method(rb_eSystemCallError, "errno", syserr_errno, 0);
    rb_define_singleton_method(rb_eSystemCallError, "===", syserr_eqq, 1);

    rb_mErrno = rb_define_module("Errno");
#ifdef __BEOS__
   for (i = 0; syserr_index[i].n != 0; i++) {
      ix = syserr_index[i].ix;
      for (offset = 0; offset < syserr_index[i].n; offset++) {
	 MEMZERO(syserr_list[ix + offset].list, VALUE, syserr_list[ix + offset].n);
      }
   }
   set_syserr(B_ERROR, "ERROR");
#else
    syserr_list = ALLOC_N(VALUE, sys_nerr+1);
    MEMZERO(syserr_list, VALUE, sys_nerr+1);
#endif

#ifdef EPERM
    set_syserr(EPERM, "EPERM");
#endif
#ifdef ENOENT
    set_syserr(ENOENT, "ENOENT");
#endif
#ifdef ESRCH
    set_syserr(ESRCH, "ESRCH");
#endif
#ifdef EINTR
    set_syserr(EINTR, "EINTR");
#endif
#ifdef EIO
    set_syserr(EIO, "EIO");
#endif
#ifdef ENXIO
    set_syserr(ENXIO, "ENXIO");
#endif
#ifdef E2BIG
    set_syserr(E2BIG, "E2BIG");
#endif
#ifdef ENOEXEC
    set_syserr(ENOEXEC, "ENOEXEC");
#endif
#ifdef EBADF
    set_syserr(EBADF, "EBADF");
#endif
#ifdef ECHILD
    set_syserr(ECHILD, "ECHILD");
#endif
#ifdef EAGAIN
    set_syserr(EAGAIN, "EAGAIN");
#endif
#ifdef ENOMEM
    set_syserr(ENOMEM, "ENOMEM");
#endif
#ifdef EACCES
    set_syserr(EACCES, "EACCES");
#endif
#ifdef EFAULT
    set_syserr(EFAULT, "EFAULT");
#endif
#ifdef ENOTBLK
    set_syserr(ENOTBLK, "ENOTBLK");
#endif
#ifdef EBUSY
    set_syserr(EBUSY, "EBUSY");
#endif
#ifdef EEXIST
    set_syserr(EEXIST, "EEXIST");
#endif
#ifdef EXDEV
    set_syserr(EXDEV, "EXDEV");
#endif
#ifdef ENODEV
    set_syserr(ENODEV, "ENODEV");
#endif
#ifdef ENOTDIR
    set_syserr(ENOTDIR, "ENOTDIR");
#endif
#ifdef EISDIR
    set_syserr(EISDIR, "EISDIR");
#endif
#ifdef EINVAL
    set_syserr(EINVAL, "EINVAL");
#endif
#ifdef ENFILE
    set_syserr(ENFILE, "ENFILE");
#endif
#ifdef EMFILE
    set_syserr(EMFILE, "EMFILE");
#endif
#ifdef ENOTTY
    set_syserr(ENOTTY, "ENOTTY");
#endif
#ifdef ETXTBSY
    set_syserr(ETXTBSY, "ETXTBSY");
#endif
#ifdef EFBIG
    set_syserr(EFBIG, "EFBIG");
#endif
#ifdef ENOSPC
    set_syserr(ENOSPC, "ENOSPC");
#endif
#ifdef ESPIPE
    set_syserr(ESPIPE, "ESPIPE");
#endif
#ifdef EROFS
    set_syserr(EROFS, "EROFS");
#endif
#ifdef EMLINK
    set_syserr(EMLINK, "EMLINK");
#endif
#ifdef EPIPE
    set_syserr(EPIPE, "EPIPE");
#endif
#ifdef EDOM
    set_syserr(EDOM, "EDOM");
#endif
#ifdef ERANGE
    set_syserr(ERANGE, "ERANGE");
#endif
#ifdef EDEADLK
    set_syserr(EDEADLK, "EDEADLK");
#endif
#ifdef ENAMETOOLONG
    set_syserr(ENAMETOOLONG, "ENAMETOOLONG");
#endif
#ifdef ENOLCK
    set_syserr(ENOLCK, "ENOLCK");
#endif
#ifdef ENOSYS
    set_syserr(ENOSYS, "ENOSYS");
#endif
#ifdef ENOTEMPTY
    set_syserr(ENOTEMPTY, "ENOTEMPTY");
#endif
#ifdef ELOOP
    set_syserr(ELOOP, "ELOOP");
#endif
#ifdef EWOULDBLOCK
    set_syserr(EWOULDBLOCK, "EWOULDBLOCK");
#endif
#ifdef ENOMSG
    set_syserr(ENOMSG, "ENOMSG");
#endif
#ifdef EIDRM
    set_syserr(EIDRM, "EIDRM");
#endif
#ifdef ECHRNG
    set_syserr(ECHRNG, "ECHRNG");
#endif
#ifdef EL2NSYNC
    set_syserr(EL2NSYNC, "EL2NSYNC");
#endif
#ifdef EL3HLT
    set_syserr(EL3HLT, "EL3HLT");
#endif
#ifdef EL3RST
    set_syserr(EL3RST, "EL3RST");
#endif
#ifdef ELNRNG
    set_syserr(ELNRNG, "ELNRNG");
#endif
#ifdef EUNATCH
    set_syserr(EUNATCH, "EUNATCH");
#endif
#ifdef ENOCSI
    set_syserr(ENOCSI, "ENOCSI");
#endif
#ifdef EL2HLT
    set_syserr(EL2HLT, "EL2HLT");
#endif
#ifdef EBADE
    set_syserr(EBADE, "EBADE");
#endif
#ifdef EBADR
    set_syserr(EBADR, "EBADR");
#endif
#ifdef EXFULL
    set_syserr(EXFULL, "EXFULL");
#endif
#ifdef ENOANO
    set_syserr(ENOANO, "ENOANO");
#endif
#ifdef EBADRQC
    set_syserr(EBADRQC, "EBADRQC");
#endif
#ifdef EBADSLT
    set_syserr(EBADSLT, "EBADSLT");
#endif
#ifdef EDEADLOCK
    set_syserr(EDEADLOCK, "EDEADLOCK");
#endif
#ifdef EBFONT
    set_syserr(EBFONT, "EBFONT");
#endif
#ifdef ENOSTR
    set_syserr(ENOSTR, "ENOSTR");
#endif
#ifdef ENODATA
    set_syserr(ENODATA, "ENODATA");
#endif
#ifdef ETIME
    set_syserr(ETIME, "ETIME");
#endif
#ifdef ENOSR
    set_syserr(ENOSR, "ENOSR");
#endif
#ifdef ENONET
    set_syserr(ENONET, "ENONET");
#endif
#ifdef ENOPKG
    set_syserr(ENOPKG, "ENOPKG");
#endif
#ifdef EREMOTE
    set_syserr(EREMOTE, "EREMOTE");
#endif
#ifdef ENOLINK
    set_syserr(ENOLINK, "ENOLINK");
#endif
#ifdef EADV
    set_syserr(EADV, "EADV");
#endif
#ifdef ESRMNT
    set_syserr(ESRMNT, "ESRMNT");
#endif
#ifdef ECOMM
    set_syserr(ECOMM, "ECOMM");
#endif
#ifdef EPROTO
    set_syserr(EPROTO, "EPROTO");
#endif
#ifdef EMULTIHOP
    set_syserr(EMULTIHOP, "EMULTIHOP");
#endif
#ifdef EDOTDOT
    set_syserr(EDOTDOT, "EDOTDOT");
#endif
#ifdef EBADMSG
    set_syserr(EBADMSG, "EBADMSG");
#endif
#ifdef EOVERFLOW
    set_syserr(EOVERFLOW, "EOVERFLOW");
#endif
#ifdef ENOTUNIQ
    set_syserr(ENOTUNIQ, "ENOTUNIQ");
#endif
#ifdef EBADFD
    set_syserr(EBADFD, "EBADFD");
#endif
#ifdef EREMCHG
    set_syserr(EREMCHG, "EREMCHG");
#endif
#ifdef ELIBACC
    set_syserr(ELIBACC, "ELIBACC");
#endif
#ifdef ELIBBAD
    set_syserr(ELIBBAD, "ELIBBAD");
#endif
#ifdef ELIBSCN
    set_syserr(ELIBSCN, "ELIBSCN");
#endif
#ifdef ELIBMAX
    set_syserr(ELIBMAX, "ELIBMAX");
#endif
#ifdef ELIBEXEC
    set_syserr(ELIBEXEC, "ELIBEXEC");
#endif
#ifdef EILSEQ
    set_syserr(EILSEQ, "EILSEQ");
#endif
#ifdef ERESTART
    set_syserr(ERESTART, "ERESTART");
#endif
#ifdef ESTRPIPE
    set_syserr(ESTRPIPE, "ESTRPIPE");
#endif
#ifdef EUSERS
    set_syserr(EUSERS, "EUSERS");
#endif
#ifdef ENOTSOCK
    set_syserr(ENOTSOCK, "ENOTSOCK");
#endif
#ifdef EDESTADDRREQ
    set_syserr(EDESTADDRREQ, "EDESTADDRREQ");
#endif
#ifdef EMSGSIZE
    set_syserr(EMSGSIZE, "EMSGSIZE");
#endif
#ifdef EPROTOTYPE
    set_syserr(EPROTOTYPE, "EPROTOTYPE");
#endif
#ifdef ENOPROTOOPT
    set_syserr(ENOPROTOOPT, "ENOPROTOOPT");
#endif
#ifdef EPROTONOSUPPORT
    set_syserr(EPROTONOSUPPORT, "EPROTONOSUPPORT");
#endif
#ifdef ESOCKTNOSUPPORT
    set_syserr(ESOCKTNOSUPPORT, "ESOCKTNOSUPPORT");
#endif
#ifdef EOPNOTSUPP
    set_syserr(EOPNOTSUPP, "EOPNOTSUPP");
#endif
#ifdef EPFNOSUPPORT
    set_syserr(EPFNOSUPPORT, "EPFNOSUPPORT");
#endif
#ifdef EAFNOSUPPORT
    set_syserr(EAFNOSUPPORT, "EAFNOSUPPORT");
#endif
#ifdef EADDRINUSE
    set_syserr(EADDRINUSE, "EADDRINUSE");
#endif
#ifdef EADDRNOTAVAIL
    set_syserr(EADDRNOTAVAIL, "EADDRNOTAVAIL");
#endif
#ifdef ENETDOWN
    set_syserr(ENETDOWN, "ENETDOWN");
#endif
#ifdef ENETUNREACH
    set_syserr(ENETUNREACH, "ENETUNREACH");
#endif
#ifdef ENETRESET
    set_syserr(ENETRESET, "ENETRESET");
#endif
#ifdef ECONNABORTED
    set_syserr(ECONNABORTED, "ECONNABORTED");
#endif
#ifdef ECONNRESET
    set_syserr(ECONNRESET, "ECONNRESET");
#endif
#ifdef ENOBUFS
    set_syserr(ENOBUFS, "ENOBUFS");
#endif
#ifdef EISCONN
    set_syserr(EISCONN, "EISCONN");
#endif
#ifdef ENOTCONN
    set_syserr(ENOTCONN, "ENOTCONN");
#endif
#ifdef ESHUTDOWN
    set_syserr(ESHUTDOWN, "ESHUTDOWN");
#endif
#ifdef ETOOMANYREFS
    set_syserr(ETOOMANYREFS, "ETOOMANYREFS");
#endif
#ifdef ETIMEDOUT
    set_syserr(ETIMEDOUT, "ETIMEDOUT");
#endif
#ifdef ECONNREFUSED
    set_syserr(ECONNREFUSED, "ECONNREFUSED");
#endif
#ifdef EHOSTDOWN
    set_syserr(EHOSTDOWN, "EHOSTDOWN");
#endif
#ifdef EHOSTUNREACH
    set_syserr(EHOSTUNREACH, "EHOSTUNREACH");
#endif
#ifdef EALREADY
    set_syserr(EALREADY, "EALREADY");
#endif
#ifdef EINPROGRESS
    set_syserr(EINPROGRESS, "EINPROGRESS");
#endif
#ifdef ESTALE
    set_syserr(ESTALE, "ESTALE");
#endif
#ifdef EUCLEAN
    set_syserr(EUCLEAN, "EUCLEAN");
#endif
#ifdef ENOTNAM
    set_syserr(ENOTNAM, "ENOTNAM");
#endif
#ifdef ENAVAIL
    set_syserr(ENAVAIL, "ENAVAIL");
#endif
#ifdef EISNAM
    set_syserr(EISNAM, "EISNAM");
#endif
#ifdef EREMOTEIO
    set_syserr(EREMOTEIO, "EREMOTEIO");
#endif
#ifdef EDQUOT
    set_syserr(EDQUOT, "EDQUOT");
#endif
}

static void
err_append(s)
    const char *s;
{
    extern VALUE ruby_errinfo;

    if (ruby_in_eval) {
	if (NIL_P(ruby_errinfo)) {
	    ruby_errinfo = rb_exc_new2(rb_eSyntaxError, s);
	}
	else {
	    VALUE str = rb_str_to_str(ruby_errinfo);

	    rb_str_cat2(str, "\n");
	    rb_str_cat2(str, s);
	    ruby_errinfo = rb_exc_new3(rb_eSyntaxError, str);
	}
    }
    else {
	fputs(s, stderr);
	fputs("\n", stderr);
	fflush(stderr);
    }
}
@


1.49
log
@	* variable.c (rb_copy_generic_ivar): remove old generic instance
	  variable table if it existes.

	* class.c (rb_make_metaclass): metaclass of a metaclass is a
	  metaclass itself.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/28 08:05:23 $
a735 3
#ifdef __BORLANDC__
    if (errno == EPIPE) return; // (*moriq*)
#endif
@


1.48
log
@Int vs Long cleanup #3 (ruby-core:352)
@
text
@d6 1
a6 1
  $Date: 2002/08/21 15:47:54 $
d814 7
@


1.47
log
@*.c: Int vs Long cleanup
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/08/15 11:49:39 $
d38 1
a38 1
    int len;
d41 1
a41 1
    int n;
@


1.46
log
@* eval.c (ruby_current_node) : added to set sourceline on demand.

* eval.c (error_pos, error_print, rb_longjmp, assign): set source
  file/line.

* eval.c (rb_eval): store current node instead of file/line, and
  preserve it at return.

* eval.c (module_setup): ditto.

* eval.c (struct thread): store node instead of file/line.

* eval.c (rb_thread_raise): ditto.

* intern.h (ruby_current_node): added.

* intern.h (ruby_set_current_source): added.

* parse.y (stmt, arg): not fix position of assignment.

* parse.y (node_assign): ditto.

* parse.y (yycompile): clear current node.
@
text
@d5 2
a6 2
  $Author: H_Konishi $
  $Date: 2002/06/11 01:27:46 $
d381 1
a381 1
    int i;
@


1.45
log
@new platform [bccwin32] merged.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/02 07:50:36 $
d43 1
@


1.44
log
@* error.c: use HAVE_DECL_SYS_NERR instead of platform names.
@
text
@d6 1
a6 1
  $Date: 2002/04/24 04:54:13 $
d735 3
@


1.43
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d6 1
a6 1
  $Date: 2002/04/15 07:48:45 $
d516 1
a516 1
#if !defined(NT) && !defined(__FreeBSD__) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(sys_nerr)
@


1.42
log
@* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* error.c (exc_initialize): should clear backtrace information.

* io.c (rb_io_fptr_cleanup): should close IO created by IO.new(fd).

* rubyio.h: remove FMODE_FDOPEN
@
text
@d6 1
a6 1
  $Date: 2002/04/01 08:31:45 $
d185 24
a208 24
    T_NIL,	"nil",
    T_OBJECT,	"Object",
    T_CLASS,	"Class",
    T_ICLASS,	"iClass",	/* internal use: mixed-in module holder */
    T_MODULE,	"Module",
    T_FLOAT,	"Float",
    T_STRING,	"String",
    T_REGEXP,	"Regexp",
    T_ARRAY,	"Array",
    T_FIXNUM,	"Fixnum",
    T_HASH,	"Hash",
    T_STRUCT,	"Struct",
    T_BIGNUM,	"Bignum",
    T_FILE,	"File",
    T_TRUE,	"true",
    T_FALSE,	"false",
    T_SYMBOL,	"Symbol",	/* :symbol */
    T_DATA,	"Data",		/* internal use: wrapped C pointers */
    T_MATCH,	"MatchData",	/* data of $~ */
    T_VARMAP,	"Varmap",	/* internal use: dynamic variables */
    T_SCOPE,	"Scope",	/* internal use: variable scope */
    T_NODE,	"Node",		/* internal use: syntax tree node */
    T_UNDEF,	"undef",	/* internal use: #undef; should not happen */
    -1,		0,
@


1.41
log
@* io.c (rb_io_fptr_cleanup): need flush even when io will not be
  closed.

* io.c (rb_io_initialize): was calling wrong function
  rb_io_mode_flags().
@
text
@d6 1
a6 1
  $Date: 2002/03/22 07:26:35 $
d312 1
@


1.40
log
@* the VMS support patch submitted by Akiyoshi, Masamichi
  <Masamichi.Akiyoshi@@jp.compaq.com> is merged.

* eval.c (exec_under): changing ruby_class is OK, but should not
  alter cbase.

* eval.c (yield_under_i): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/19 09:03:07 $
d203 1
a203 1
    T_MATCH,	"Match",	/* data of $~ */
@


1.39
log
@* re.c (rb_reg_search): should clear last_match if pos is out of
  string range.

* string.c (rb_str_index_m): ditto.

* string.c (rb_str_rindex): ditto.

* class.c (rb_define_class): should handle autoload.

* class.c (rb_define_module): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/01/18 14:23:06 $
d721 1
a721 1
#ifndef NT
@


1.38
log
@* io.c (rb_io_s_new): block check moved from initialize to this
  method.

* io.c (rb_io_s_open): open should call initialize too. IO#for_fd
  also calls initialize. [new]

* error.c (rb_sys_fail): replace INT2FIX() by INT2NUM() since
  errno value may not fit in Fixnum size on Hurd.

* error.c (set_syserr): ditto.

* dir.c (dir_s_glob): returns nil if block given.

* io.c (rb_io_each_byte): should return self.

* io.c (rb_io_close_m): close check added.

* dir.c (dir_seek): should return pos.

* parse.y (fixpos): orig may be (NODE*)1, which should not be
  dereferenced.
@
text
@d6 1
a6 1
  $Date: 2002/01/11 09:18:49 $
d437 1
a437 1
name_name(self)
d444 1
a444 1
nometh_args(self)
d636 1
a636 1
    rb_define_method(rb_eNameError, "name", name_name, 0);
d638 1
a638 1
    rb_define_method(rb_eNoMethodError, "args", nometh_args, 0);
@


1.37
log
@* re.c (match_select): should propagate taintness.

* hash.c (rb_hash_set_default): Hash#default= should return the
  new value.

* string.c (rb_str_to_i): accepts optional base argument. [new]

* numeric.c (rb_fix2str): should not handle negative fixnum values
  int32 via calling sprintf() directly.
@
text
@d6 1
a6 1
  $Date: 2002/01/04 14:14:34 $
d529 1
a529 1
    rb_define_const(error, "Errno", INT2FIX(i));
d767 1
a767 1
    rb_iv_set(ee, "errno", INT2FIX(n));
@


1.36
log
@* process.c (rb_f_system): abandon vfork.

* io.c (pipe_open): ditto.

* defines.h: sparc linux needs different FLUSH_REGISTER_WINDOWS

* regex.c (re_search): abandon stclass optimization.

* bignum.c (rb_cstr2inum): deny "0_".

* bignum.c (rb_cstr2inum): allow "0\n" and so on.

* error.c (rb_invalid_str): utility function to show inspect()'ed
  string.

* bignum.c (rb_cstr2inum): prints invalid strings in inspect()'ed
  format.

* object.c (rb_Float): ditto.

* object.c (rb_convert_type): no longer use rb_rescue().

* re.c (rb_reg_search): initialize taint status of match object.
@
text
@d6 1
a6 1
  $Date: 2001/12/10 07:18:12 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
@


1.35
log
@* array.c (rb_ary_modify): should copy the internal buffer if the
  modifying buffer is shared.

* array.c (ary_make_shared): make an internal buffer of an array
  to be shared.

* array.c (rb_ary_shift): avoid sliding an internal buffer by
  using shared buffer.

* array.c (rb_ary_subseq): avoid copying the buffer.

* parse.y (gettable): should freeze __LINE__ string.

* io.c (rb_io_puts): old behavoir restored.  rationale: a) if you
  want to call to_s for arrays, you can just call print a, "\n".
  b) to_s wastes memory if array (and sum of its contents) is
  huge.  c) now any object that has to_ary is treated as an array,
  using rb_check_convert_type().

* hash.c (rb_hash_initialize): now accepts a block to calculate
  the default value. [new]

* hash.c (rb_hash_aref): call "default" method to get the value
  corrensponding to the non existing key.

* hash.c (rb_hash_default): get the default value based on the
  block given to 'new'.  Now it takes an optinal "key" argument.
  "default" became the method to get the value for non existing
  key.  Users may override "default" method to change the hash
  behavior.

* hash.c (rb_hash_set_default): clear the flag if a block is given
  to 'new'

* object.c (Init_Object): undef Data.allocate, left Data.new.

* ext/curses/curses.c (window_scrollok): use RTEST().

* ext/curses/curses.c (window_idlok): ditto.

* ext/curses/curses.c (window_keypad): ditto.

* ext/curses/curses.c (window_idlok): idlok() may return void on
  some platforms; so don't use return value.

* ext/curses/curses.c (window_scrollok): ditto for consistency.

* ext/curses/curses.c: replace FIX2INT() by typechecking NUM2INT().

* parse.y (str_extend): should not process immature #$x and
  #@@x interpolation, e.g #@@#@@ etc.

* enum.c (enum_sort_by): sort_by does not have to be stable always.

* enum.c (enum_sort_by): call qsort directly to gain performance.

* util.c (ruby_qsort): ruby_qsort(qs6) is now native thread safe.

* error.c (rb_sys_fail): it must be a bug if it's called when
  errno == 0.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@d6 1
a6 1
  $Date: 2001/11/13 08:19:51 $
d448 9
@


1.34
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* eval.c (rb_eval_cmd): should not upgrade safe level unless
  explicitly specified by argument newly added.

* signal.c (sig_trap): should not allow tainted trap closure.

* variable.c (rb_f_trace_var): should not allow trace_var on safe
  level higher than 3.

* variable.c (rb_f_trace_var): should not allow tainted trace
  closure.

* gc.c: do not use static stack until system stack overflows.

* eval.c (eval): should call Exception#exception instead of
  calling rb_exc_new3() directly.

* error.c (exc_exception): set "mesg" directly to the clone.  it
  might be better to set mesg via some method for flexibility.

* variable.c (cvar_override_check): should print original module
  name, if 'a' is T_ICLASS.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/10/29 05:07:17 $
d720 4
@


1.33
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* variable.c (rb_cvar_set): empty iv_tbl may cause infinite loop.

* variable.c (rb_cvar_get): ditto.

* variable.c (cvar_override_check): ditto.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.

* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.
@
text
@d6 1
a6 1
  $Date: 2001/10/03 07:19:10 $
d327 1
a327 1
    rb_obj_call_init(exc, argc, argv);
@


1.32
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2001/09/03 05:16:29 $
d737 1
a737 1
	char name[6];
d744 1
a744 1
	char name[6];
@


1.31
log
@* error.c: unbreak the build on *BSD with gcc 3.0.1 by removing
  the conflicting declaration of sys_nerr for *BSD.
@
text
@d5 2
a6 2
  $Author: shugo $
  $Date: 2001/07/03 05:52:20 $
d281 1
a281 4
    VALUE exc = rb_obj_alloc(etype);

    rb_iv_set(exc, "mesg", rb_str_new(ptr, len));
    return exc;
@


1.30
log
@* error.c (rb_name_error): raise NameError instead of LoadError.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/07/02 08:46:21 $
d509 1
a509 1
#if !defined NT && !defined sys_nerr
@


1.29
log
@* error.c (exc_exception): clone the receiver exception instead of
  creating brand new exception object of the receiver.

* eval.c (rb_eval_string_wrap): extend new ruby_top_self, not
  original self.

* eval.c (rb_eval_cmd): respect ruby_wrapper if set.

* eval.c (eval): do not update ruby_class unless scope is not
  provided.

* eval.c (eval): preserve wrapper information.

* eval.c (proc_invoke): ditto.

* eval.c (block_pass): ditto.

* parse.y (void_expr): too much warnings for void context
  (e.g. foo[1] that can be mere Proc call).

* error.c (rb_name_error): new function to raise NameError with
  name attribute set.

* eval.c (rb_f_missing): set name and args in the exception
  object. [new]

* error.c (name_name): NameError#name - new method.

* error.c (nometh_args): NoMethodError#args - new method.

* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.

* dir.c (isdelim): space, tab, and newline are no longer
  delimiters for glob patterns.

* eval.c (svalue_to_avalue): new conversion scheme between single
  value and array values.

* eval.c (avalue_to_svalue): ditto.

* eval.c (rb_eval): REXPAND now uses avalue_to_svalue(), return
  and yield too.

* eval.c (rb_yield_0): use avalue_to_svalue().

* eval.c (proc_invoke): Proc#call gives avaules, whereas
  Proc#yield gives mvalues.

* eval.c (bmcall): convert given value (svalue) to avalue.
@
text
@d6 1
a6 1
  $Date: 2001/06/05 07:50:59 $
d434 1
a434 1
    exc = rb_exc_new2(rb_eLoadError, buf);
@


1.28
log
@* error.c (Init_Exception): NameError went under StandardError,
  and NoMethodError went under NameError.

* parse.y (rb_intern): non identifier symbols should be
  categorized as ID_JUNK. [new]
@
text
@d6 1
a6 1
  $Date: 2001/05/30 09:12:33 $
d325 1
a325 1
    VALUE etype, exc;
d329 1
a329 5
    etype = CLASS_OF(self);
    while (FL_TEST(etype, FL_SINGLETON)) {
	etype = RCLASS(etype)->super;
    }
    exc = rb_obj_alloc(etype);
d416 37
d630 1
d632 1
@


1.27
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:10 $
d262 2
a266 1
VALUE rb_eNoMethodError;
a268 1
VALUE rb_eNameError;
d596 2
a597 1
    rb_eNoMethodError = rb_define_class("NoMethodError", rb_eStandardError);
a600 1
    rb_eNameError   = rb_define_class("NameError", rb_eScriptError);
@


1.26
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d6 1
a6 1
  $Date: 2001/02/19 09:14:58 $
d362 1
a362 1
    str = rb_str_new2("#<");
d364 4
a367 4
    rb_str_append(str, klass);
    rb_str_cat(str, ": ", 2);
    rb_str_append(str, exc);
    rb_str_cat(str, ">", 1);
@


1.25
log
@* string.c (rb_str_substr): "a"[1,2] should return ""; need
  rubicon upgrade.
@
text
@d6 1
a6 1
  $Date: 2001/02/19 07:03:05 $
d265 1
d299 2
a300 5
    char *s;
    int len;

    s = rb_str2cstr(str, &len);
    return rb_exc_new(etype, s, len);
d312 1
a312 1
	STR2CSTR(mesg);		/* ensure mesg can be converted to String */
d523 23
d592 5
a596 4
    rb_eTypeError   = rb_define_class("TypeError", rb_eStandardError);
    rb_eArgError    = rb_define_class("ArgumentError", rb_eStandardError);
    rb_eIndexError  = rb_define_class("IndexError", rb_eStandardError);
    rb_eRangeError  = rb_define_class("RangeError", rb_eStandardError);
d774 1
@


1.24
log
@* eval.c (secure_visibility): visibility check for untainted modules.

* signal.c (sigpipe): sighandler which does nothing.

* signal.c (trap): set sigpipe function for SIGPIPE.

* signal.c (Init_signal): default SIGPIPE handler should be
  sigpipe function.

* array.c (rb_ary_subseq): wrong boundary check.

* parse.y (cond0): integer literal in condition should not be
  compared to lineno ($.).
@
text
@d6 1
a6 1
  $Date: 2001/02/08 09:19:16 $
d702 26
@


1.23
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_options): new method to give an option values.

* parse.y (cond0): disable special treating of integer literal in
  conditional unless option -e is supplied.  changes current
  behavior.  experimental.

* parse.y (cond0): give warning for string/integer literals and
  dot operators in conditionals unless option -e is supplied.

* re.c (rb_reg_equal): all option flags should be same to be equal.

* error.c (Init_Exception): make Interrupt a subclass of
  SignalException.
@
text
@d6 1
a6 1
  $Date: 2001/01/29 05:10:41 $
d415 7
d564 2
@


1.22
log
@* string.c (str_independent): should not clear str->orig here.
  it's too early.
@
text
@d6 1
a6 1
  $Date: 2001/01/09 08:24:35 $
a557 1
    rb_eInterrupt   = rb_define_class("Interrupt", rb_eException);
d559 1
@


1.21
log
@* error.c: typo
@
text
@d6 1
a6 1
  $Date: 2001/01/09 07:26:16 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.20
log
@* enum.c (enum_inject): new method.

* gc.c (rb_gc_call_finalizer_at_exit): clear klass member of
  terminating object.

* eval.c (rb_call): raise exception for terminated object.

* bignum.c (bigdivrem): t2 might be too big for signed long; do
  not use rb_int2big(), but rb_uint2big().

* error.c (rb_load_fail): new func to report LoadError.

* ruby.c (load_file): use rb_load_fail.

* eval.c (ruby_finalize): should enclosed by PUSH_TAG/POP_TAG.

* gc.c (rb_gc_mark): link 2 of NODE_IFUNC should not be explicitly
  marked.  it may contain non object pointer.

* re.c (reg_s_last_match): Regexp::last_match(nth) returns nth
  substring of the match  (alternative for $& and $<digit>).

* eval.c (rb_mod_define_method): wrong comparison for blocks.

* gc.c (id2ref): should handle Symbol too.

* gc.c (id2ref): should print original ptr value

* eval.c (rb_iterate): NODE_CFUNC does not protect its data
  (nd_tval), so create new node NODE_IFUNC for iteration C
  function.

* eval.c (rb_yield_0): use NODE_IFUNC.

* gc.c (rb_gc_mark): support NODE_IFUNC.

* gc.c (mem_error): prohibit recursive mem_error().
  (ruby-bugs-ja:PR#36)

* eval.c (rb_thread_fd_writable): should not switch context if
  rb_thread_critical is set.

* eval.c (rb_thread_wait_fd): ditto.

* eval.c (rb_thread_wait_for): ditto.

* eval.c (rb_thread_select): ditto.

* eval.c (rb_thread_join): join during critical section causes
  deadlock.
@
text
@d6 1
a6 1
  $Date: 2000/11/14 07:10:20 $
d696 1
a696 1
rb_load_failed(path)
@


1.19
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/10 08:52:23 $
a571 2
    /* backward compatibility -- will be removed in the future */
    rb_define_global_const("NotImplementError", rb_eNotImpError);
d693 7
@


1.19.2.1
log
@* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2000/11/14 07:10:20 $
a694 7
}

void
rb_load_fail(path)
    char *path;
{
    rb_loaderror("%s -- %s", strerror(errno), path);
@


1.19.2.2
log
@* error.c: unbreak the build on *BSD with gcc 3.0.1 by removing
  the conflicting declaration of sys_nerr for *BSD.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:39:51 $
d471 1
a471 1
#if !defined(NT) && !defined(__FreeBSD__) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(sys_nerr)
@


1.19.2.3
log
@* eval.c (ruby_stop): should not trace error handler.

* io.c (io_write): should not raise exception on O_NONBLOCK io.

* dir.c (dir_set_pos): seek should return dir, pos= should not.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2001/09/03 05:18:02 $
d485 1
a485 1
    rb_define_const(error, "Errno", INT2NUM(i));
d693 1
a693 1
    rb_iv_set(ee, "errno", INT2NUM(n));
@


1.19.2.4
log
@* error.c: MatchData, not Match.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/21 07:43:39 $
d203 1
a203 1
    T_MATCH,	"MatchData",	/* data of $~ */
@


1.19.2.5
log
@* eval.c (ruby_run): should set toplevel visibility again here.

* eval.c (rb_eval): should not rely on ruby_class == rb_cObject
  check.   Besides allow implicit publicity for attribute set
  methods.

* parse.y (primary): need not to check class_nest, just set
  whether method is an attrset or not.

* string.c (rb_str_each_line): p might be at the top of the
  string.

* variable.c (rb_path2class): should not use rb_eval_string().

* parse.y (str_extend): expression substitution can contain string
  terminator again.

* parse.y (yylex): the warning message "invalid
  character syntax" was never issued.

* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/04/02 09:47:46 $
a471 1
#  if !defined(__APPLE__) || (__APPLE_CC__ < 1151)
a472 1
#  endif
@


1.18
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/08 05:29:21 $
d15 2
d177 1
a177 1
    ruby_show_version();
@


1.17
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/24 06:21:28 $
d199 1
a199 2
    T_UNDEF,	"Symbol",	/* :symbol */
    T_UNDEF,	"undef",	/* internal use: #undef */
d205 1
a214 1
    int tt = TYPE(x);
d216 5
a220 1
    if (tt != t) {
@


1.16
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/10 04:49:10 $
d103 13
d131 1
a131 1
    err_print(buf, args);
d153 1
a153 1
    err_print(buf, args);
d173 1
a173 1
    err_print(buf, args);
@


1.15
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/22 08:29:41 $
d1090 2
a1091 2
	    rb_str_cat(str, "\n", 1);
	    rb_str_cat(str, s, strlen(s));
@


1.14
log
@2000-06-22
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:13 $
d162 1
@


1.13
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:44:06 $
d552 3
a554 1
    rb_eNotImpError = rb_define_class("NotImplementError", rb_eScriptError);
@


1.12
log
@2000-04-10
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/03/07 08:37:28 $
d11 1
a11 1
************************************************/
d407 1
d468 5
d506 1
d700 1
@


1.11
log
@2000-03-07
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:12:00 $
d347 1
a347 1
    rb_str_concat(str, klass);
d349 1
a349 1
    rb_str_concat(str, exc);
d634 4
a637 2
	buf = ALLOCA_N(char, strlen(err)+strlen(mesg)+4);
	sprintf(buf, "%s - %s", err, mesg);
d663 1
a664 1
#endif
@


1.10
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:36:59 $
a23 5
#ifdef USE_CWGUSI
#include <sys/errno.h>
int sys_nerr = 256;
#endif

d183 4
a186 2
    T_TRUE,	"TRUE",
    T_FALSE,	"FALSE",
d242 1
d539 1
a651 11
# ifdef USE_CWGUSI
    if (n < 0) {
	int macoserr_index = sys_nerr - 1;
	if (!syserr_list[macoserr_index]) {
	    char name[6];
	    sprintf(name, "E%03d", macoserr_index);
	    ee = set_syserr(macoserr_index, name);
	}
    }
    else
#endif /* USE_CWGUSI */
@


1.9
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:49:40 $
a241 1
VALUE rb_eSyntaxError;
a243 1
VALUE rb_eNameError;
a244 1
VALUE rb_eLoadError;
d249 5
a537 1
    rb_eSyntaxError = rb_define_class("SyntaxError", rb_eStandardError);
a539 1
    rb_eNameError   = rb_define_class("NameError", rb_eStandardError);
d541 6
a546 1
    rb_eLoadError   = rb_define_class("LoadError", rb_eStandardError);
a549 1
    rb_eNotImpError = rb_define_class("NotImplementError", rb_eException);
d677 7
@


1.8
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/12/01 09:24:12 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d282 1
a282 1
    s = str2cstr(str, &len);
@


1.7
log
@19991201
@
text
@d6 1
a6 1
  $Date: 1999/11/04 08:39:36 $
d250 1
d391 1
d546 1
@


1.6
log
@19991104
@
text
@d6 1
a6 1
  $Date: 1999/10/18 09:03:00 $
d328 1
@


1.5
log
@19991018
@
text
@d6 1
a6 1
  $Date: 1999/10/16 10:33:05 $
d29 5
a33 2
#if defined __CYGWIN__ && defined _sys_nerr
#define sys_nerr _sys_nerr
d448 1
a448 1
#ifndef NT
@


1.4
log
@ruby -v
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:32 $
d27 4
@


1.3
log
@19991012
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:04 $
d37 2
d41 4
d47 4
a50 4
	int n = snprintf(buf, len, "%s:%d: ", ruby_sourcefile, ruby_sourceline);
	if (len > n) {
	    vsnprintf((char*)buf+n, len-n, fmt, args);
	}
@


1.3.2.1
log
@19991018
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:32 $
a26 4
#endif

#if defined __CYGWIN__ && defined _sys_nerr
#define sys_nerr _sys_nerr
@


1.3.2.2
log
@19991124-1.4.3pre1
@
text
@d6 1
a6 1
  $Date: 1999/10/18 09:03:16 $
d29 2
a30 5
#if defined __CYGWIN__
# include <cygwin/version.h>
# if (CYGWIN_VERSION_API_MAJOR > 0) || (CYGWIN_VERSION_API_MINOR >= 8)
#  define sys_nerr _sys_nerr
# endif
a40 2
    int n;

a42 4
	return;
    }
    else if (ruby_sourceline == 0) {
	n = snprintf(buf, len, "%s: ", ruby_sourcefile);
d45 4
a48 4
	n = snprintf(buf, len, "%s:%d: ", ruby_sourcefile, ruby_sourceline);
    }
    if (len > n) {
	vsnprintf((char*)buf+n, len-n, fmt, args);
d439 1
a439 1
#if !defined NT && !defined sys_nerr
@


1.3.2.3
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/11/24 07:13:50 $
a388 1
    VALUE bt;
@


1.3.2.4
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:50:37 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.3.2.5
log
@2000-04-10
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:23:54 $
d666 1
a667 1
    ee = rb_exc_new2(ee, buf);
@


1.3.2.6
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:48:27 $
a404 1
static VALUE syserr_error;
a464 5
   if (i == B_ERROR) {
      syserr_error = error;
      rb_global_variable(&syserr_error);
      return error;
   }
a497 1
   if (i == B_ERROR) return syserr_error;
a688 1
   set_syserr(B_ERROR, "ERROR");
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/05/25 08:25:52 $
d333 1
a333 1
    rb_str_cat(str, ":", 1);
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1996/12/25 10:42:31 $
d9 1
a9 1
  Copyright (C) 1993-1996 Yukihiro Matsumoto
d16 4
d21 2
d24 4
a27 2
extern char *sourcefile;
extern int   sourceline;
d29 1
a29 1
int nerrs;
d32 1
a32 1
err_sprintf(buf, fmt, args)
d34 1
d37 2
a38 2
    if (!sourcefile) {
	vsprintf(buf, fmt, args);
d41 3
a43 14
	sprintf(buf, "%s:%d: ", sourcefile, sourceline);
	vsprintf((char*)buf+strlen(buf), fmt, args);
    }
}

static void
err_append(s)
    char *s;
{
    extern VALUE errinfo;

    if (rb_in_eval) {
	if (NIL_P(errinfo)) {
	    errinfo = str_new2(s);
a44 9
	else {
	    str_cat(errinfo, "\n", 1);
	    str_cat(errinfo, s, strlen(s));
	}
    }
    else {
	fputs(s, stderr);
	fputs("\n", stderr);
	fflush(stderr);
d48 1
d51 1
a51 1
    char *fmt;
d56 1
a56 1
    err_sprintf(buf, fmt, args);
d61 5
a65 2
Error(fmt, va_alist)
    char *fmt;
d67 1
d71 1
a71 1
    va_start(args);
d74 1
a74 1
    nerrs++;
d78 5
a82 2
Error_Append(fmt, va_alist)
    char *fmt;
d84 1
d89 2
a90 2
    va_start(args);
    vsprintf(buf, fmt, args);
d96 25
a120 2
Warning(fmt, va_alist)
    char *fmt;
d122 1
d127 1
a127 1
    if (!verbose) return;
d129 1
a129 1
    sprintf(buf, "warning: %s", fmt);
d131 1
a131 1
    va_start(args);
d137 5
a141 2
Bug(fmt, va_alist)
    char *fmt;
d143 1
d148 2
a149 2
    sprintf(buf, "[BUG] %s", fmt);
    rb_in_eval = 0;
d151 1
a151 1
    va_start(args);
d159 1
a159 1
    char *name;
a184 2
extern void TypeError();

d191 1
d193 1
a193 1
    if (TYPE(x)!=(t)) {
d196 16
a211 2
		TypeError("wrong argument type %s (expected %s)",
			  rb_class2name(CLASS_OF(x)), type->name);
d215 1
a215 1
	Bug("unknown type 0x%x", t);
d220 1
a220 1
#include "errno.h"
d222 15
a236 12
extern VALUE cString;
VALUE eGlobalExit, eException;
VALUE eSystemExit, eInterrupt, eFatal;
VALUE eRuntimeError;
VALUE eSyntaxError;
VALUE eTypeError;
VALUE eArgError;
VALUE eNameError;
VALUE eIndexError;
VALUE eNotImpError;
VALUE eLoadError;
VALUE eSecurityError;
d238 2
a239 2
VALUE eSystemCallError;
VALUE mErrno;
d242 1
a242 1
exc_new(etype, ptr, len)
d244 2
a245 2
    char *ptr;
    UINT len;
d247 1
a247 2
    NEWOBJ(exc, struct RString);
    OBJSETUP(exc, etype, T_STRING);
d249 2
a250 8
    exc->len = len;
    exc->orig = 0;
    exc->ptr = ALLOC_N(char,len+1);
    if (ptr) {
	memcpy(exc->ptr, ptr, len);
    }
    exc->ptr[len] = '\0';
    return (VALUE)exc;
d254 1
a254 1
exc_new2(etype, s)
d256 1
a256 1
    char *s;
d258 1
a258 1
    return exc_new(etype, s, strlen(s));
d262 15
a276 3
exc_new3(etype, str)
    VALUE etype;
    struct RString *str;
d278 8
a285 2
    Check_Type(str, T_STRING);
    return exc_new(etype, str->ptr, str->len);
d289 1
a289 1
exc_s_new(argc, argv, etype)
d292 1
a292 1
    VALUE etype;
d294 1
a294 1
    VALUE arg;
d296 5
a300 2
    if (rb_scan_args(argc, argv, "01", &arg) == 0) {
	return exc_new(etype, 0, 0);
d302 14
a315 2
    Check_Type(arg, T_STRING);
    return exc_new3(etype, arg);
d322 1
a322 2
    struct RString *classpath = RSTRING(rb_class_path(CLASS_OF(exc)));
    VALUE str = str_new(classpath->ptr, classpath->len);
d324 2
a325 1
    str_cat(str, ":", 1);
d327 1
a327 1
	str_cat(str, "\"\"", 2);
d329 8
a336 1
    str_cat(str, RSTRING(exc)->ptr, RSTRING(exc)->len);
d341 12
a352 3
exception(argc, argv)
    int argc;
    VALUE *argv;
a353 2
    void ArgError();
    VALUE v = Qnil;
d355 1
a355 1
    ID id;
d357 6
a362 7
    if (argc == 0) {
	ArgError("wrong # of arguments");
    }
    for (i=0; i<argc; i++) {	/* argument check */
	id = rb_to_id(argv[i]);
	if (!rb_id2name(id)) {
	    ArgError("argument needs to be symbol or string");
d364 4
a367 2
	if (!rb_is_const_id(id)) {
	    ArgError("identifier %s needs to be constant", rb_id2name(id));
d370 8
a377 4
    for (i=0; i<argc; i++) {
	v = rb_define_class(rb_id2name(rb_to_id(argv[i])), eException);
    }
    return v;
d380 52
d433 1
d439 1
a439 1
static void
d442 1
a442 1
    char *name;
d444 19
d464 1
a464 2
	syserr_list[i] = rb_define_class_under(mErrno, name, eSystemCallError);
	rb_global_variable(&syserr_list[i]);
d466 2
d470 6
a475 1
static void init_syserr();
d477 3
a479 2
void
Init_Exception()
d481 14
a494 23
    eGlobalExit  = rb_define_class("GlobalExit", cString);
    rb_define_singleton_method(eGlobalExit, "new", exc_s_new, -1);
    rb_define_method(eGlobalExit, "inspect", exc_inspect, 0);

    eSystemExit  = rb_define_class("SystemExit", eGlobalExit);
    eFatal  	 = rb_define_class("fatal", eGlobalExit);
    eInterrupt   = rb_define_class("Interrupt", eGlobalExit);

    eException   = rb_define_class("Exception", eGlobalExit);
    eSyntaxError = rb_define_class("SyntaxError", eException);
    eTypeError   = rb_define_class("TypeError", eException);
    eArgError    = rb_define_class("ArgumentError", eException);
    eNameError   = rb_define_class("NameError", eException);
    eIndexError  = rb_define_class("IndexError", eException);
    eNotImpError = rb_define_class("NotImplementError", eException);
    eLoadError = rb_define_class("LoadError", eException);

    eRuntimeError = rb_define_class("RuntimeError", eException);
    eSecurityError = rb_define_class("SecurityError", eException);

    init_syserr();

    rb_define_global_function("Exception", exception, -1);
d496 1
d498 1
a498 10
#define RAISE_ERROR(class) {\
    va_list args;\
    char buf[BUFSIZ];\
\
    va_start(args);\
    vsprintf(buf, fmt, args);\
    va_end(args);\
\
    rb_raise(exc_new2(class, buf));\
}
d501 1
a501 4
Raise(exc, fmt, va_alist)
    VALUE exc;
    char *fmt;
    va_dcl
d503 27
a529 2
    RAISE_ERROR(exc);
}
d531 1
a531 6
void
TypeError(fmt, va_alist)
    char *fmt;
    va_dcl
{
    RAISE_ERROR(eTypeError);
d535 6
a540 2
ArgError(fmt, va_alist)
    char *fmt;
d542 1
d544 2
a545 2
    RAISE_ERROR(eArgError);
}
d547 4
a550 6
void
NameError(fmt, va_alist)
    char *fmt;
    va_dcl
{
    RAISE_ERROR(eNameError);
d554 5
a558 2
IndexError(fmt, va_alist)
    char *fmt;
d560 1
d562 2
a563 2
    RAISE_ERROR(eIndexError);
}
d565 4
a568 6
void
Fail(fmt, va_alist)
    char *fmt;
    va_dcl
{
    RAISE_ERROR(eRuntimeError);
d574 3
a576 3
    Raise(eNotImpError,
	  "The %s() function is unimplemented on this machine",
	  rb_id2name(the_frame->last_func));
d580 5
a584 10
LoadError(fmt, va_alist)
    char *fmt;
    va_dcl
{
    RAISE_ERROR(eLoadError);
}

void
Fatal(fmt, va_alist)
    char *fmt;
d586 1
d591 2
a592 2
    va_start(args);
    vsprintf(buf, fmt, args);
d595 2
a596 2
    rb_in_eval = 0;
    rb_fatal(exc_new2(eFatal, buf));
d601 1
a601 1
    char *mesg;
d606 2
a607 1
    char buf[BUFSIZ];
d610 1
d612 9
a620 4
    if (RTEST(mesg))
	sprintf(buf, "%s - %s", strerror(errno), mesg);
    else
	sprintf(buf, "%s", strerror(errno));
d623 20
d647 1
a647 1
	set_syserr(n, name);
d649 7
a655 1
    rb_raise(exc_new2(syserr_list[n], buf));
d661 15
a675 2
    eSystemCallError = rb_define_class("SystemCallError", eException);
    mErrno = rb_define_module("Errno");
d678 1
d1046 25
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d105 1
a105 1
    if (!RTEST(verbose)) return;
d228 2
a229 1
    VALUE etype, str;
d232 1
a232 1
    return exc_new(etype, RSTRING(str)->ptr, RSTRING(str)->len);
d254 2
a255 1
    VALUE str, klass;
d257 1
a257 1
    klass = CLASS_OF(exc);
d259 1
a259 1
	return rb_class_path(klass);
a260 5

    str = str_new2("#<");
    klass = rb_class_path(klass);
    str_cat(str, RSTRING(klass)->ptr, RSTRING(klass)->len);
    str_cat(str, ":", 1);
a261 2
    str_cat(str, ">", 1);

d288 1
a288 1
	v = rb_define_class_under(the_class, rb_id2name(rb_to_id(argv[i])), eException);
d330 1
a330 1
    eLoadError   = rb_define_class("LoadError", eException);
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/12/16 07:30:29 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
a15 4
#ifdef HAVE_STDARG_PROTOTYPES
#include <stdarg.h>
#define va_init_list(a,b) va_start(a,b)
#else
a16 2
#define va_init_list(a,b) va_start(a)
#endif
d18 2
a19 4
#ifdef USE_CWGUSI
#include <sys/errno.h>
int sys_nerr = 256;
#endif
d21 1
a21 1
int ruby_nerrs;
d24 1
a24 1
err_snprintf(buf, len, fmt, args)
a25 1
    int len;
d28 2
a29 2
    if (!ruby_sourcefile) {
	vsnprintf(buf, len, fmt, args);
d32 18
a49 3
	int n = snprintf(buf, len, "%s:%d: ", ruby_sourcefile, ruby_sourceline);
	if (len > n) {
	    vsnprintf((char*)buf+n, len-n, fmt, args);
d52 5
a58 1
static void err_append _((char*));
d66 1
a66 1
    err_snprintf(buf, BUFSIZ, fmt, args);
d71 1
a71 4
#ifdef HAVE_STDARG_PROTOTYPES
rb_compile_error(char *fmt, ...)
#else
rb_compile_error(fmt, va_alist)
a73 1
#endif
d77 1
a77 1
    va_init_list(args, fmt);
d80 1
a80 1
    ruby_nerrs++;
d84 1
a84 4
#ifdef HAVE_STDARG_PROTOTYPES
rb_compile_error_append(char *fmt, ...)
#else
rb_compile_error_append(fmt, va_alist)
a86 1
#endif
d91 2
a92 2
    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
d98 1
a98 4
#ifdef HAVE_STDARG_PROTOTYPES
rb_warn(char *fmt, ...)
#else
rb_warn(fmt, va_alist)
a100 1
#endif
d105 1
a105 1
    snprintf(buf, BUFSIZ, "warning: %s", fmt);
d107 1
a107 19
    va_init_list(args, fmt);
    err_print(buf, args);
    va_end(args);
}

/* rb_warning() reports only in verbose mode */
void
#ifdef HAVE_STDARG_PROTOTYPES
rb_warning(char *fmt, ...)
#else
rb_warning(fmt, va_alist)
    char *fmt;
    va_dcl
#endif
{
    char buf[BUFSIZ];
    va_list args;

    if (!RTEST(rb_verbose)) return;
d109 1
a109 3
    snprintf(buf, BUFSIZ, "warning: %s", fmt);

    va_init_list(args, fmt);
d115 1
a115 4
#ifdef HAVE_STDARG_PROTOTYPES
rb_bug(char *fmt, ...)
#else
rb_bug(fmt, va_alist)
a117 1
#endif
d122 1
a122 1
    snprintf(buf, BUFSIZ, "[BUG] %s", fmt);
d125 1
a125 1
    va_init_list(args, fmt);
d159 2
a166 1
    int tt = TYPE(x);
d168 1
a168 1
    if (tt != t) {
d171 2
a172 16
		char *etype;

		if (NIL_P(x)) {
		    etype = "nil";
		}
		else if (FIXNUM_P(x)) {
		    etype = "Fixnum";
		}
		else if (rb_special_const_p(x)) {
		    etype = RSTRING(rb_obj_as_string(x))->ptr;
		}
		else {
		    etype = rb_class2name(CLASS_OF(x));
		}
		rb_raise(rb_eTypeError, "wrong argument type %s (expected %s)",
			 etype, type->name);
d176 1
a176 1
	rb_bug("unknown type 0x%x", t);
d181 1
a181 1
#include <errno.h>
d183 12
a194 12
VALUE rb_eException;
VALUE rb_eSystemExit, rb_eInterrupt, rb_eFatal;
VALUE rb_eStandardError;
VALUE rb_eRuntimeError;
VALUE rb_eSyntaxError;
VALUE rb_eTypeError;
VALUE rb_eArgError;
VALUE rb_eNameError;
VALUE rb_eIndexError;
VALUE rb_eLoadError;
VALUE rb_eSecurityError;
VALUE rb_eNotImpError;
d196 2
a197 2
VALUE rb_eSystemCallError;
VALUE rb_mErrno;
d200 1
a200 1
rb_exc_new(etype, ptr, len)
d203 1
a203 1
    int len;
d205 2
a206 1
    VALUE exc = rb_obj_alloc(etype);
d208 8
a215 2
    rb_iv_set(exc, "mesg", rb_str_new(ptr, len));
    return exc;
d219 1
a219 1
rb_exc_new2(etype, s)
d223 1
a223 1
    return rb_exc_new(etype, s, strlen(s));
d227 1
a227 1
rb_exc_new3(etype, str)
d230 2
a231 5
    char *s;
    int len;

    s = str2cstr(str, &len);
    return rb_exc_new(etype, s, len);
d235 1
a235 1
exc_initialize(argc, argv, exc)
d238 1
a238 1
    VALUE exc;
d240 1
a240 1
    VALUE mesg;
d242 2
a243 2
    if (rb_scan_args(argc, argv, "01", &mesg) == 1) {
	STR2CSTR(mesg);		/* ensure mesg can be converted to String */
d245 2
a246 32
    rb_iv_set(exc, "mesg", mesg);

    return exc;
}

static VALUE
exc_new(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE etype, exc;

    if (argc == 1 && self == argv[0]) return self;
    etype = CLASS_OF(self);
    while (FL_TEST(etype, FL_SINGLETON)) {
	etype = RCLASS(etype)->super;
    }
    exc = rb_obj_alloc(etype);
    rb_obj_call_init(exc);

    return exc;
}

static VALUE
exc_to_s(exc)
    VALUE exc;
{
    VALUE mesg = rb_iv_get(exc, "mesg");

    if (NIL_P(mesg)) return rb_class_path(CLASS_OF(exc));
    return mesg;
a255 1
    exc = rb_obj_as_string(exc);
d257 1
a257 1
	return rb_str_dup(rb_class_path(klass));
d260 1
a260 1
    str = rb_str_new2("#<");
d262 4
a265 4
    rb_str_concat(str, klass);
    rb_str_cat(str, ":", 1);
    rb_str_concat(str, exc);
    rb_str_cat(str, ">", 1);
a270 37
exc_backtrace(exc)
    VALUE exc;
{
    return rb_iv_get(exc, "bt");
}

static VALUE
check_backtrace(bt)
    VALUE bt;
{
    int i;
    static char *err = "backtrace must be Array of String";

    if (!NIL_P(bt)) {
	int t = TYPE(bt);

	if (t == T_STRING) return rb_ary_new3(1, bt);
	if (t != T_ARRAY) {
	    rb_raise(rb_eTypeError, err);
	}
	for (i=0;i<RARRAY(bt)->len;i++) {
	    if (TYPE(RARRAY(bt)->ptr[i]) != T_STRING) {
		rb_raise(rb_eTypeError, err);
	    }
	}
    }
    return bt;
}

static VALUE
exc_set_backtrace(exc, bt)
    VALUE exc;
{
    return rb_iv_set(exc, "bt", check_backtrace(bt));
}

static VALUE
d275 1
a276 1
    VALUE etype = rb_eStandardError;
d281 1
a281 9
	rb_raise(rb_eArgError, "wrong # of arguments");
    }
    rb_warn("Exception() is now obsolete");
    if (TYPE(argv[argc-1]) == T_CLASS) {
	etype = argv[argc-1];
	argc--;
	if (!rb_funcall(etype, '<', 1, rb_eException)) {
	    rb_raise(rb_eTypeError, "exception should be subclass of Exception");
	}
d286 1
a286 1
	    rb_raise(rb_eArgError, "argument needs to be symbol or string");
d289 1
a289 2
	    rb_raise(rb_eArgError, "identifier `%s' needs to be constant",
		     rb_id2name(id));
d293 1
a293 3
	v = rb_define_class_under(ruby_class,
				  rb_id2name(rb_to_id(argv[i])),
				  rb_eStandardError);
a297 52
#ifdef __BEOS__
typedef struct {
   VALUE *list;
   size_t n;
} syserr_list_entry;

typedef struct {
   int ix;
   size_t n;
} syserr_index_entry;

static VALUE syserr_list_b_general[16+1];
static VALUE syserr_list_b_os0[2+1];
static VALUE syserr_list_b_os1[5+1];
static VALUE syserr_list_b_os2[2+1];
static VALUE syserr_list_b_os3[3+1];
static VALUE syserr_list_b_os4[1+1];
static VALUE syserr_list_b_app[15+1];
static VALUE syserr_list_b_interface[0+1];
static VALUE syserr_list_b_media[8+1];
static VALUE syserr_list_b_midi[0+1];
static VALUE syserr_list_b_storage[15+1];
static VALUE syserr_list_b_posix[38+1];
static VALUE syserr_list_b_mail[8+1];
static VALUE syserr_list_b_print[1+1];
static VALUE syserr_list_b_device[14+1];

# define SYSERR_LIST_B(n) {(n), sizeof(n)/sizeof(VALUE)}
static const syserr_list_entry syserr_list[] = {
   SYSERR_LIST_B(syserr_list_b_general),
   SYSERR_LIST_B(syserr_list_b_os0),
   SYSERR_LIST_B(syserr_list_b_os1),
   SYSERR_LIST_B(syserr_list_b_os2),
   SYSERR_LIST_B(syserr_list_b_os3),
   SYSERR_LIST_B(syserr_list_b_os4),
   SYSERR_LIST_B(syserr_list_b_app),
   SYSERR_LIST_B(syserr_list_b_interface),
   SYSERR_LIST_B(syserr_list_b_media),
   SYSERR_LIST_B(syserr_list_b_midi),
   SYSERR_LIST_B(syserr_list_b_storage),
   SYSERR_LIST_B(syserr_list_b_posix),
   SYSERR_LIST_B(syserr_list_b_mail),
   SYSERR_LIST_B(syserr_list_b_print),
   SYSERR_LIST_B(syserr_list_b_device),
};
# undef SYSERR_LIST_B

static const syserr_index_entry syserr_index[]= {
     {0, 1},  {1, 5},  {6, 1},  {7, 1}, {8, 1}, {9, 1}, {10, 1}, {11, 1},
     {12, 1}, {13, 1}, {14, 1}, {0, 0},
};
#else
a298 1
#endif
d304 1
a304 1
static VALUE
a308 19
#ifdef __BEOS__
   VALUE *list;
   int ix, offset;
#endif
    VALUE error = rb_define_class_under(rb_mErrno, name, rb_eSystemCallError);
    rb_define_const(error, "Errno", INT2FIX(i));
#ifdef __BEOS__
   i -= B_GENERAL_ERROR_BASE;
   ix = (i >> 12) & 0xf;
   offset = (i >> 8) & 0xf;
   if (offset < syserr_index[ix].n) {
      ix = syserr_index[ix].ix;
      if ((i & 0xff) < syserr_list[ix + offset].n) {
	 list = syserr_list[ix + offset].list;
	 list[i & 0xff] = error;
	 rb_global_variable(&list[i & 0xff]);
      }
   }
#else
d310 2
a311 1
	syserr_list[i] = error;
a312 29
#endif
    return error;
}

static VALUE
syserr_errno(self)
    VALUE self;
{
    return rb_iv_get(self, "errno");
}

#ifdef __BEOS__
static VALUE
get_syserr(int i)
{
   VALUE *list;
   int ix, offset;
   
   i -= B_GENERAL_ERROR_BASE;
   ix = (i >> 12) & 0xf;
   offset = (i >> 8) & 0xf;
   if (offset < syserr_index[ix].n) {
      ix = syserr_index[ix].ix;
      if ((i & 0xff) < syserr_list[ix + offset].n) {
	 list = syserr_list[ix + offset].list;
	 return list[i & 0xff];
      }
   }
   return 0;
a313 1
#endif /* __BEOS__ */
d315 1
a315 1
static void init_syserr _((void));
d320 19
a338 25
    rb_eException   = rb_define_class("Exception", rb_cObject);
    rb_define_method(rb_eException, "new", exc_new, -1);
    rb_define_method(rb_eException, "initialize", exc_initialize, -1);
    rb_define_method(rb_eException, "to_s", exc_to_s, 0);
    rb_define_method(rb_eException, "to_str", exc_to_s, 0);
    rb_define_method(rb_eException, "message", exc_to_s, 0);
    rb_define_method(rb_eException, "inspect", exc_inspect, 0);
    rb_define_method(rb_eException, "backtrace", exc_backtrace, 0);
    rb_define_method(rb_eException, "set_backtrace", exc_set_backtrace, 1);

    rb_eSystemExit  = rb_define_class("SystemExit", rb_eException);
    rb_eFatal  	 = rb_define_class("fatal", rb_eException);
    rb_eInterrupt   = rb_define_class("Interrupt", rb_eException);

    rb_eStandardError = rb_define_class("StandardError", rb_eException);
    rb_eSyntaxError = rb_define_class("SyntaxError", rb_eStandardError);
    rb_eTypeError   = rb_define_class("TypeError", rb_eStandardError);
    rb_eArgError    = rb_define_class("ArgumentError", rb_eStandardError);
    rb_eNameError   = rb_define_class("NameError", rb_eStandardError);
    rb_eIndexError  = rb_define_class("IndexError", rb_eStandardError);
    rb_eLoadError   = rb_define_class("LoadError", rb_eStandardError);

    rb_eRuntimeError = rb_define_class("RuntimeError", rb_eStandardError);
    rb_eSecurityError = rb_define_class("SecurityError", rb_eStandardError);
    rb_eNotImpError = rb_define_class("NotImplementError", rb_eException);
d345 11
d357 1
a357 4
#ifdef HAVE_STDARG_PROTOTYPES
rb_raise(VALUE exc, char *fmt, ...)
#else
rb_raise(exc, fmt, va_alist)
a360 1
#endif
d362 18
a379 2
    va_list args;
    char buf[BUFSIZ];
d381 6
a386 4
    va_init_list(args,fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);
    rb_exc_raise(rb_exc_new2(exc, buf));
d390 1
a390 4
#ifdef HAVE_STDARG_PROTOTYPES
rb_loaderror(char *fmt, ...)
#else
rb_loaderror(fmt, va_alist)
a392 1
#endif
d394 2
a395 2
    va_list args;
    char buf[BUFSIZ];
d397 6
a402 4
    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);
    rb_exc_raise(rb_exc_new2(rb_eLoadError, buf));
d408 3
a410 3
    rb_raise(rb_eNotImpError,
	     "The %s() function is unimplemented on this machine",
	     rb_id2name(ruby_frame->last_func));
d414 9
a422 4
#ifdef HAVE_STDARG_PROTOTYPES
rb_fatal(char *fmt, ...)
#else
rb_fatal(fmt, va_alist)
a424 1
#endif
d429 2
a430 2
    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
d434 1
a434 1
    rb_exc_fatal(rb_exc_new2(rb_eFatal, buf));
d444 1
a444 2
    char *err;
    char *buf;
a446 1
    VALUE ee;
d448 4
a451 9
    err = strerror(errno);
    if (mesg) {
	buf = ALLOCA_N(char, strlen(err)+strlen(mesg)+4);
	sprintf(buf, "%s - %s", err, mesg);
    }
    else {
	buf = ALLOCA_N(char, strlen(err)+1);
	strcpy(buf, err);
    }
a453 20
#ifdef __BEOS__
    ee = get_syserr(n);
    if (!ee) {
	char name[6];
      
	sprintf(name, "E%03d", n);
	ee = set_syserr(n, name);
   }
#else
# ifdef USE_CWGUSI
    if (n < 0) {
	int macoserr_index = sys_nerr - 1;
	if (!syserr_list[macoserr_index]) {
	    char name[6];
	    sprintf(name, "E%03d", macoserr_index);
	    ee = set_syserr(macoserr_index, name);
	}
    }
    else
#endif /* USE_CWGUSI */
d458 1
a458 1
	ee = set_syserr(n, name);
d460 1
a460 7
    else {
	ee = syserr_list[n];
    }
    ee = rb_exc_new2(ee, buf);
#endif
    rb_iv_set(ee, "errno", INT2FIX(n));
    rb_exc_raise(ee);
d466 2
a467 15
#ifdef __BEOS__
   int i, ix, offset;
#endif
    rb_eSystemCallError = rb_define_class("SystemCallError", rb_eStandardError);
    rb_define_method(rb_eSystemCallError, "errno", syserr_errno, 0);

    rb_mErrno = rb_define_module("Errno");
#ifdef __BEOS__
   for (i = 0; syserr_index[i].n != 0; i++) {
      ix = syserr_index[i].ix;
      for (offset = 0; offset < syserr_index[i].n; offset++) {
	 MEMZERO(syserr_list[ix + offset].list, VALUE, syserr_list[ix + offset].n);
      }
   }
#else
a469 1
#endif
a836 25
}

static void
err_append(s)
    char *s;
{
    extern VALUE rb_errinfo;

    if (rb_in_eval) {
	if (NIL_P(rb_errinfo)) {
	    rb_errinfo = rb_exc_new2(rb_eSyntaxError, s);
	}
	else {
	    VALUE str = rb_str_to_str(rb_errinfo);

	    rb_str_cat(str, "\n", 1);
	    rb_str_cat(str, s, strlen(s));
	    rb_errinfo = rb_exc_new3(rb_eSyntaxError, str);
	}
    }
    else {
	fputs(s, stderr);
	fputs("\n", stderr);
	fflush(stderr);
    }
@


1.1.1.3.2.1
log
@990126
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:22 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d286 1
a286 1
exc_exception(argc, argv, self)
d415 1
a415 1
   int n;
d420 1
a420 1
   int n;
d536 1
a536 2
    rb_define_singleton_method(rb_eException, "exception", rb_class_new_instance, -1);
    rb_define_method(rb_eException, "exception", exc_exception, -1);
@


1.1.1.3.2.2
log
@990201
@
text
@d6 1
a6 1
  $Date: 1999/01/26 10:08:10 $
d127 1
a127 1
    if (!RTEST(ruby_verbose)) return;
d149 1
a149 1
    ruby_in_eval = 0;
d628 1
a628 1
    ruby_in_eval = 0;
d1085 1
a1085 1
    extern VALUE ruby_errinfo;
d1087 3
a1089 3
    if (ruby_in_eval) {
	if (NIL_P(ruby_errinfo)) {
	    ruby_errinfo = rb_exc_new2(rb_eSyntaxError, s);
d1092 1
a1092 1
	    VALUE str = rb_str_to_str(ruby_errinfo);
d1096 1
a1096 1
	    ruby_errinfo = rb_exc_new3(rb_eSyntaxError, str);
@


1.1.1.3.2.3
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/02/01 07:34:53 $
d340 1
a340 4
    ID bt = rb_intern("bt");

    if (!rb_ivar_defined(exc, bt)) return Qnil;
    return rb_ivar_get(exc, bt);
@


1.1.1.3.2.4
log
@990224
@
text
@d6 1
a6 1
  $Date: 1999/02/09 06:08:19 $
a292 1
    if (argc == 0) return self;
@


1.1.1.3.2.5
log
@990225
@
text
@d6 1
a6 1
  $Date: 1999/02/24 04:31:18 $
d300 1
a300 1
    rb_obj_call_init(exc, argc, argv);
d377 39
d567 2
@


1.1.1.3.2.6
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/25 06:39:05 $
d48 1
a48 1
static void err_append _((const char*));
d51 1
a51 1
    const char *fmt;
d62 1
a62 1
rb_compile_error(const char *fmt, ...)
d65 1
a65 1
    const char *fmt;
d79 1
a79 1
rb_compile_error_append(const char *fmt, ...)
d82 1
a82 1
    const char *fmt;
d97 1
a97 1
rb_warn(const char *fmt, ...)
d100 1
a100 1
    const char *fmt;
d117 1
a117 1
rb_warning(const char *fmt, ...)
d120 1
a120 1
    const char *fmt;
d138 1
a138 1
rb_bug(const char *fmt, ...)
d141 1
a141 1
    const char *fmt;
d159 1
a159 1
    const char *name;
d223 1
a223 4
VALUE rb_eSystemExit;
VALUE rb_eInterrupt;
VALUE rb_eSignal;
VALUE rb_eFatal;
d241 1
a241 1
    const char *ptr;
d253 1
a253 1
    const char *s;
d439 1
a439 1
    const char *name;
d512 1
a512 2
    rb_eFatal  	    = rb_define_class("fatal", rb_eException);
    rb_eInterrupt   = rb_define_class("Interrupt", rb_eException);
a513 1
    rb_eSignal      = rb_define_class("SignalException", rb_eException);
d532 1
a532 1
rb_raise(VALUE exc, const char *fmt, ...)
d536 1
a536 1
    const char *fmt;
d551 1
a551 1
rb_loaderror(const char *fmt, ...)
d554 1
a554 1
    const char *fmt;
d577 1
a577 1
rb_fatal(const char *fmt, ...)
d580 1
a580 1
    const char *fmt;
d597 1
a597 1
    const char *mesg;
d1046 1
a1046 1
    const char *s;
@


1.1.1.3.2.7
log
@small fixes
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:25 $
d516 1
@


1.1.1.3.2.8
log
@regexp null pattern
@
text
@d6 1
a6 1
  $Date: 1999/05/06 08:31:30 $
d245 1
a245 1
    long len;
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:04:56 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:44 $
d257 1
a257 1
	return str_dup(rb_class_path(klass));
@


1.1.1.2.2.3
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/01/23 10:01:07 $
a170 11
		char *etype;

		if (NIL_P(x)) {
		    etype = "nil";
		}
		else if (rb_special_const_p(x)) {
		    etype = RSTRING(obj_as_string(x))->ptr;
		}
		else {
		    etype = rb_class2name(CLASS_OF(x));
		}
d172 1
a172 1
			  etype, type->name);
d345 1
a345 1
#define RAISE_ERROR(klass) {\
d353 1
a353 1
    rb_raise(exc_new2(klass, buf));\
@


1.1.1.2.2.4
log
@block arg etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:31 $
a166 1
    int tt = TYPE(x);
d168 1
a168 1
    if (tt != t) {
a174 3
		}
		else if (FIXNUM_P(x)) {
		    etype = "Fixnum";
@


1.1.1.2.2.5
log
@heredoc etc.
@
text
@d6 1
a6 1
  $Date: 1998/03/05 06:37:42 $
a96 16
void
Warn(fmt, va_alist)
    char *fmt;
    va_dcl
{
    char buf[BUFSIZ];
    va_list args;

    sprintf(buf, "warning: %s", fmt);

    va_start(args);
    err_print(buf, args);
    va_end(args);
}

/* Warning() reports only in verbose mode */
@


1.1.1.2.2.6
log
@call initialize
@
text
@d6 1
a6 1
  $Date: 1998/03/25 09:36:57 $
d271 1
a271 1
    VALUE arg, exc;
d274 1
a274 1
	exc = exc_new(etype, 0, 0);
d276 2
a277 6
    else {
	Check_Type(arg, T_STRING);
	exc = exc_new3(etype, arg);
    }
    obj_call_init(exc);
    return exc;
@


1.1.1.2.2.7
log
@dynamic (nested) local variables
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:03:47 $
d277 2
a278 1
	exc = exc_new3(etype, obj_as_string(arg));
@


1.1.1.2.2.8
log
@new exception model
@
text
@d6 1
a6 1
  $Date: 1998/04/07 08:34:06 $
a214 1
VALUE eThrowable, eExceptional;
d261 2
a262 5
    char *s;
    int len;

    s = str2cstr(str, &len);
    return exc_new(etype, s, len);
a283 17
exc_new_method(self, str)
    VALUE self, str;
{
    VALUE etype;
    char *s;
    int len;

    if (self == str) return self;
    etype = CLASS_OF(self);
    while (FL_TEST(etype, FL_SINGLETON)) {
	etype = RCLASS(etype)->super;
    }
    s = str2cstr(str, &len);
    return exc_new(etype, s, len);
}

static VALUE
a353 1
    eThrowable  = rb_define_module("Throwable");
a354 1
    rb_include_module(eGlobalExit, eThrowable);
a355 1
    rb_define_method(eGlobalExit, "new", exc_new_method, 1);
a361 2
    eExceptional = rb_define_module("Exceptional");
    rb_include_module(eExceptional, eThrowable);
a362 1
    rb_include_module(eException, eExceptional);
@


1.1.1.2.2.9
log
@exception model changed
@
text
@d6 1
a6 1
  $Date: 1998/04/30 07:41:08 $
d215 2
a216 1
VALUE eException;
a217 2
VALUE eDefaultRescue;
VALUE eStandardError;
a330 1
    VALUE etype = eStandardError;
a337 4
    if (TYPE(argv[argc-1]) == T_CLASS) {
	etype = argv[argc-1];
	argc--; argv++;
    }
d348 1
a348 3
	v = rb_define_class_under(the_class,
				  rb_id2name(rb_to_id(argv[i])),
				  etype);
d375 22
a396 19
    eException   = rb_define_class("Exception", cString);
    rb_define_singleton_method(eException, "new", exc_s_new, -1);
    rb_define_method(eException, "new", exc_new_method, 1);
    rb_define_method(eException, "inspect", exc_inspect, 0);

    eSystemExit  = rb_define_class("SystemExit", eException);
    eFatal  	 = rb_define_class("fatal", eException);
    eInterrupt   = rb_define_class("Interrupt", eException);

    eDefaultRescue = rb_define_module("DefaultRescue");
    eStandardError = rb_define_class("StandardError", eException);
    rb_include_module(eStandardError, eDefaultRescue);
    eSyntaxError = rb_define_class("SyntaxError", eStandardError);
    eTypeError   = rb_define_class("TypeError", eStandardError);
    eArgError    = rb_define_class("ArgumentError", eStandardError);
    eNameError   = rb_define_class("NameError", eStandardError);
    eIndexError  = rb_define_class("IndexError", eStandardError);
    eNotImpError = rb_define_class("NotImplementError", eStandardError);
    eLoadError   = rb_define_class("LoadError", eStandardError);
d398 2
a399 2
    eRuntimeError = rb_define_class("RuntimeError", eStandardError);
    eSecurityError = rb_define_class("SecurityError", eStandardError);
d527 1
a527 1
    eSystemCallError = rb_define_class("SystemCallError", eStandardError);
@


1.1.1.2.2.10
log
@new exception model
@
text
@d6 1
a6 1
  $Date: 1998/05/01 08:56:27 $
d217 1
d225 1
a227 1
VALUE eNotImpError;
d238 2
a239 1
    VALUE exc = obj_alloc(etype);
d241 8
a248 2
    rb_iv_set(exc, "mesg", str_new(ptr, len));
    return exc;
d271 1
a271 1
exc_initialize(argc, argv, exc)
d274 1
a274 1
    VALUE exc;
d276 1
a276 1
    VALUE mesg;
d278 2
a279 3
    rb_scan_args(argc, argv, "01", &mesg);
    if (NIL_P(mesg)) {
	mesg = str_new(0, 0);
d282 1
a282 1
	STR2CSTR(mesg);		/* ensure mesg can be converted to String */
d284 1
a284 2
    rb_iv_set(exc, "mesg", mesg);

d289 2
a290 4
exc_new_method(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
d292 3
a294 1
    VALUE etype, exc;
d296 1
a296 1
    if (argc == 1 && self == argv[0]) return self;
d301 2
a302 11
    exc = obj_alloc(etype);
    obj_call_init(exc);

    return exc;
}

static VALUE
exc_to_s(exc)
    VALUE exc;
{
    return rb_iv_get(exc, "mesg");
a311 1
    exc = obj_as_string(exc);
d318 1
a318 1
    str_concat(str, klass);
d320 1
a320 1
    str_concat(str, exc);
a326 37
exc_backtrace(exc)
    VALUE exc;
{
    return rb_iv_get(exc, "bt");
}

static VALUE
check_backtrace(bt)
    VALUE bt;
{
    int i;
    static char *err = "backtrace must be Array of String";

    if (!NIL_P(bt)) {
	int t = TYPE(bt);

	if (t == T_STRING) return ary_new3(1, bt);
	if (t != T_ARRAY) {
	    TypeError(err);
	}
	for (i=0;i<RARRAY(bt)->len;i++) {
	    if (TYPE(RARRAY(bt)->ptr[i]) != T_STRING) {
		TypeError(err);
	    }
	}
    }
    return bt;
}

static VALUE
exc_set_backtrace(exc, bt)
    VALUE exc;
{
    return rb_iv_set(exc, "bt", check_backtrace(bt));
}

static VALUE
d332 1
a333 1
    VALUE etype = eStandardError;
a339 1
    Warn("Exception() is now obsolete");
d342 1
a342 4
	argc--;
	if (!rb_funcall(etype, '<', 1, eException)) {
	    TypeError("exception should be subclass of Exception");
	}
a345 3
	if (!rb_is_const_id(id)) {
	    ArgError("identifier `%s' needs to be constant", rb_id2name(id));
	}
d349 3
d356 1
a356 1
				  eStandardError);
d383 3
a385 6
    eException   = rb_define_class("Exception", cObject);
    rb_define_method(eException, "new", exc_new_method, -1);
    rb_define_method(eException, "initialize", exc_initialize, -1);
    rb_define_method(eException, "to_s", exc_to_s, 0);
    rb_define_method(eException, "to_str", exc_to_s, 0);
    rb_define_method(eException, "message", exc_to_s, 0);
a386 2
    rb_define_method(eException, "backtrace", exc_backtrace, 0);
    rb_define_private_method(eException, "set_backtrace", exc_set_backtrace, 1);
d392 1
d394 1
d400 1
a404 1
    eNotImpError = rb_define_class("NotImplementError", eException);
@


1.1.1.2.2.11
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/06 03:08:49 $
d436 1
a436 1
    rb_define_method(eException, "set_backtrace", exc_set_backtrace, 1);
@


1.1.1.2.2.12
log
@1.1b9_18
@
text
@d6 1
a6 1
  $Date: 1998/05/06 09:16:04 $
d412 1
a412 1
static VALUE
a416 2
    VALUE error = rb_define_class_under(mErrno, name, eSystemCallError);
    rb_define_const(error, "Errno", INT2FIX(i));
d418 2
a419 1
	syserr_list[i] = error;
a420 8
    return error;
}

static VALUE
syserr_errno(self)
    VALUE self;
{
    return rb_iv_get(self, "errno");
d558 1
a558 2
    char *err;
    char *buf;
a560 1
    VALUE ee;
d562 4
a565 9
    err = strerror(errno);
    if (mesg) {
	buf = ALLOCA_N(char, strlen(err)+strlen(mesg)+1);
	sprintf(buf, "%s - %s", err, mesg);
    }
    else {
	buf = ALLOCA_N(char, strlen(err)+1);
	sprintf(buf, "%s", err);
    }
d572 1
a572 1
	ee = set_syserr(n, name);
d574 1
a574 6
    else {
	ee = syserr_list[n];
    }
    ee = exc_new2(ee, buf);
    rb_iv_set(ee, "errno", INT2FIX(n));
    rb_raise(ee);
a580 2
    rb_define_method(eSystemCallError, "errno", syserr_errno, 0);

@


1.1.1.2.2.13
log
@no INT,UINT
@
text
@d6 1
a6 1
  $Date: 1998/05/12 08:38:36 $
d235 1
a235 1
    unsigned len;
@


1.1.1.2.2.14
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/05/13 05:57:52 $
a15 4
#ifdef __STDC__
#include <stdarg.h>
#define va_init_list(a,b) va_start(a,b)
#else
a16 7
#define va_init_list(a,b) va_start(a)
#endif

#ifdef USE_CWGUSI
#include <sys/errno.h>
int sys_nerr = 256;
#endif
d37 22
a58 1
static void err_append _((char*));
a70 3
#ifdef __STDC__
Error(char *fmt, ...)
#else
a73 1
#endif
d77 1
a77 1
    va_init_list(args, fmt);
a83 3
#ifdef __STDC__
Error_Append(char *fmt, ...)
#else
a86 1
#endif
d91 1
a91 1
    va_init_list(args, fmt);
a97 3
#ifdef __STDC__
Warn(char *fmt, ...)
#else
a100 1
#endif
d107 1
a107 1
    va_init_list(args, fmt);
a113 3
#ifdef __STDC__
Warning(char *fmt, ...)
#else
a116 1
#endif
d125 1
a125 1
    va_init_list(args, fmt);
a130 3
#ifdef __STDC__
Bug(char *fmt, ...)
#else
a133 1
#endif
d141 1
a141 1
    va_init_list(args, fmt);
a174 1
#ifndef __STDC__
a175 1
#endif
d372 1
a405 52
#ifdef __BEOS__
typedef struct {
   VALUE *list;
   size_t n;
} syserr_list_entry;

typedef struct {
   int ix;
   size_t n;
} syserr_index_entry;

static VALUE syserr_list_b_general[16+1];
static VALUE syserr_list_b_os0[2+1];
static VALUE syserr_list_b_os1[5+1];
static VALUE syserr_list_b_os2[2+1];
static VALUE syserr_list_b_os3[3+1];
static VALUE syserr_list_b_os4[1+1];
static VALUE syserr_list_b_app[15+1];
static VALUE syserr_list_b_interface[0+1];
static VALUE syserr_list_b_media[8+1];
static VALUE syserr_list_b_midi[0+1];
static VALUE syserr_list_b_storage[15+1];
static VALUE syserr_list_b_posix[38+1];
static VALUE syserr_list_b_mail[8+1];
static VALUE syserr_list_b_print[1+1];
static VALUE syserr_list_b_device[14+1];

# define SYSERR_LIST_B(n) {(n), sizeof(n)/sizeof(VALUE)}
static const syserr_list_entry syserr_list[] = {
   SYSERR_LIST_B(syserr_list_b_general),
   SYSERR_LIST_B(syserr_list_b_os0),
   SYSERR_LIST_B(syserr_list_b_os1),
   SYSERR_LIST_B(syserr_list_b_os2),
   SYSERR_LIST_B(syserr_list_b_os3),
   SYSERR_LIST_B(syserr_list_b_os4),
   SYSERR_LIST_B(syserr_list_b_app),
   SYSERR_LIST_B(syserr_list_b_interface),
   SYSERR_LIST_B(syserr_list_b_media),
   SYSERR_LIST_B(syserr_list_b_midi),
   SYSERR_LIST_B(syserr_list_b_storage),
   SYSERR_LIST_B(syserr_list_b_posix),
   SYSERR_LIST_B(syserr_list_b_mail),
   SYSERR_LIST_B(syserr_list_b_print),
   SYSERR_LIST_B(syserr_list_b_device),
};
# undef SYSERR_LIST_B

static const syserr_index_entry syserr_index[]= {
     {0, 1},  {1, 5},  {6, 1},  {7, 1}, {8, 1}, {9, 1}, {10, 1}, {11, 1},
     {12, 1}, {13, 1}, {14, 1}, {0, 0},
};
#else
a406 1
#endif
d468 1
a468 1
#define RAISE_ERROR(klass,fmt) {\
d471 5
a475 1
    va_init_list(args,fmt);\
a479 3
#ifdef __STDC__
Raise(VALUE exc, char *fmt, ...)
#else
a483 1
#endif
d485 1
a485 1
    RAISE_ERROR(exc, fmt);
a488 3
#ifdef __STDC__
TypeError(char *fmt, ...)
#else
a491 1
#endif
d493 1
a493 1
    RAISE_ERROR(eTypeError, fmt);
a496 3
#ifdef __STDC__
ArgError(char *fmt, ...)
#else
a499 1
#endif
d501 1
a501 1
    RAISE_ERROR(eArgError, fmt);
a504 3
#ifdef __STDC__
NameError(char *fmt, ...)
#else
a507 1
#endif
d509 1
a509 1
    RAISE_ERROR(eNameError, fmt);
a512 3
#ifdef __STDC__
IndexError(char *fmt, ...)
#else
a515 1
#endif
d517 1
a517 1
    RAISE_ERROR(eIndexError, fmt);
a520 3
#ifdef __STDC__
Fail(char *fmt, ...)
#else
a523 1
#endif
d525 1
a525 1
    RAISE_ERROR(eRuntimeError, fmt);
a536 3
#ifdef __STDC__
LoadError(char *fmt, ...)
#else
a539 1
#endif
d541 1
a541 1
    RAISE_ERROR(eLoadError, fmt);
a544 3
#ifdef __STDC__
Fatal(char *fmt, ...)
#else
a547 1
#endif
d552 1
a552 1
    va_init_list(args, fmt);
a583 20
#ifdef __BEOS__
    ee = get_syserr(n);
    if (!ee) {
	char name[6];
      
	sprintf(name, "E%03d", n);
	ee = set_syserr(n, name);
   }
#else
# ifdef USE_CWGUSI
    if (n < 0) {
	int macoserr_index = sys_nerr - 1;
	if (!syserr_list[macoserr_index]) {
	    char name[6];
	    sprintf(name, "E%03d", macoserr_index);
	    ee = set_syserr(macoserr_index, name);
	}
    }
    else
#endif /* USE_CWGUSI */
a593 1
#endif
a973 25
}

static void
err_append(s)
    char *s;
{
    extern VALUE errinfo;

    if (rb_in_eval) {
	if (NIL_P(errinfo)) {
	    errinfo = exc_new2(eSyntaxError, s);
	}
	else {
	    VALUE str = str_to_str(errinfo);

	    str_cat(str, "\n", 1);
	    str_cat(str, s, strlen(s));
	    errinfo = exc_new3(eSyntaxError, str);
	}
    }
    else {
	fputs(s, stderr);
	fputs("\n", stderr);
	fflush(stderr);
    }
@


1.1.1.2.2.15
log
@prototypes
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:10 $
d16 1
a16 1
#ifdef HAVE_STDARG_PROTOTYPES
d61 1
a61 1
#ifdef HAVE_STDARG_PROTOTYPES
d78 1
a78 1
#ifdef HAVE_STDARG_PROTOTYPES
d96 1
a96 1
#ifdef HAVE_STDARG_PROTOTYPES
d116 1
a116 1
#ifdef HAVE_STDARG_PROTOTYPES
d137 1
a137 1
#ifdef HAVE_STDARG_PROTOTYPES
d185 4
d540 1
a540 1
#ifdef HAVE_STDARG_PROTOTYPES
d553 1
a553 1
#ifdef HAVE_STDARG_PROTOTYPES
d565 1
a565 1
#ifdef HAVE_STDARG_PROTOTYPES
d577 1
a577 1
#ifdef HAVE_STDARG_PROTOTYPES
d589 1
a589 1
#ifdef HAVE_STDARG_PROTOTYPES
d601 1
a601 1
#ifdef HAVE_STDARG_PROTOTYPES
d621 1
a621 1
#ifdef HAVE_STDARG_PROTOTYPES
d633 1
a633 1
#ifdef HAVE_STDARG_PROTOTYPES
@


1.1.1.2.2.16
log
@ruby 1.1b9_20
@
text
@d6 1
a6 1
  $Date: 1998/05/14 04:10:27 $
a476 4
#ifdef __BEOS__
   VALUE *list;
   int ix, offset;
#endif
a478 13
#ifdef __BEOS__
   i -= B_GENERAL_ERROR_BASE;
   ix = (i >> 12) & 0xf;
   offset = (i >> 8) & 0xf;
   if (offset < syserr_index[ix].n) {
      ix = syserr_index[ix].ix;
      if ((i & 0xff) < syserr_list[ix + offset].n) {
	 list = syserr_list[ix + offset].list;
	 list[i & 0xff] = error;
	 rb_global_variable(&list[i & 0xff]);
      }
   }
#else
a481 1
#endif
a709 3
#ifdef __BEOS__
   int i, ix, offset;
#endif
a713 8
#ifdef __BEOS__
   for (i = 0; syserr_index[i].n != 0; i++) {
      ix = syserr_index[i].ix;
      for (offset = 0; offset < syserr_index[i].n; offset++) {
	 MEMZERO(syserr_list[ix + offset].list, VALUE, syserr_list[ix + offset].n);
      }
   }
#else
a715 1
#endif
@


1.1.1.2.2.17
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/15 05:43:19 $
d510 1
a510 1
static void init_syserr _((void));
@


1.1.1.2.2.18
log
@1.1b9_21
@
text
@d6 1
a6 1
  $Date: 1998/05/18 04:55:58 $
a549 2
    vsprintf(buf, fmt, args);\
    va_end(args);\
@


1.1.1.2.2.19
log
@BeOS patches
@
text
@d6 1
a6 1
  $Date: 1998/05/18 05:57:37 $
a508 21

#ifdef __BEOS__
static VALUE
get_syserr(int i)
{
   VALUE *list;
   int ix, offset;
   
   i -= B_GENERAL_ERROR_BASE;
   ix = (i >> 12) & 0xf;
   offset = (i >> 8) & 0xf;
   if (offset < syserr_index[ix].n) {
      ix = syserr_index[ix].ix;
      if ((i & 0xff) < syserr_list[ix + offset].n) {
	 list = syserr_list[ix + offset].list;
	 return list[i & 0xff];
      }
   }
   return 0;
}
#endif /* __BEOS__ */
@


1.1.1.2.2.20
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/18 09:12:19 $
d222 1
@


1.1.1.2.2.21
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/02 10:05:17 $
d220 1
a220 1
#include <errno.h>
@


1.1.1.2.2.22
log
@str2cstr
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:14 $
d277 2
a278 1
    if (rb_scan_args(argc, argv, "01", &mesg) == 0) {
@


1.1.1.2.2.23
log
@1.1c1
@
text
@d6 1
a6 1
  $Date: 1998/07/13 04:37:25 $
d396 3
a400 3
	}
	if (!rb_is_const_id(id)) {
	    ArgError("identifier `%s' needs to be constant", rb_id2name(id));
@


1.1.1.2.2.24
log
@1.1c2
@
text
@d6 1
a6 1
  $Date: 1998/07/24 04:41:51 $
d35 1
a35 1
err_snprintf(buf, len, fmt, args)
a36 1
    int len;
d40 1
a40 1
	vsnprintf(buf, len, fmt, args);
d43 2
a44 4
	int n = snprintf(buf, len, "%s:%d: ", sourcefile, sourceline); 
	if (len > n) {
	    vsnprintf((char*)buf+n, len-n, fmt, args);
	}
d56 1
a56 1
    err_snprintf(buf, BUFSIZ, fmt, args);
d90 1
a90 1
    vsnprintf(buf, BUFSIZ, fmt, args);
d107 1
a107 1
    snprintf(buf, BUFSIZ, "warning: %s", fmt);
d129 1
a129 1
    snprintf(buf, BUFSIZ, "warning: %s", fmt);
d148 1
a148 1
    snprintf(buf, BUFSIZ, "[BUG] %s", fmt);
d569 1
a569 1
    vsnprintf(buf, BUFSIZ, fmt, args);\
d680 1
a680 1
    vsnprintf(buf, BUFSIZ, fmt, args);
d707 1
a707 1
	strcpy(buf, err);
@


1.1.1.2.2.25
log
@990209
@
text
@d6 1
a6 1
  $Date: 1998/08/10 05:41:12 $
d705 1
a705 1
	buf = ALLOCA_N(char, strlen(err)+strlen(mesg)+4);
@


1.1.1.2.2.24.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/08/10 05:41:12 $
d29 4
a32 1
int ruby_nerrs;
d40 1
a40 1
    if (!ruby_sourcefile) {
d44 1
a44 1
	int n = snprintf(buf, len, "%s:%d: ", ruby_sourcefile, ruby_sourceline);
d65 1
a65 1
rb_compile_error(char *fmt, ...)
d67 1
a67 1
rb_compile_error(fmt, va_alist)
d77 1
a77 1
    ruby_nerrs++;
d82 1
a82 1
rb_compile_error_append(char *fmt, ...)
d84 1
a84 1
rb_compile_error_append(fmt, va_alist)
d100 1
a100 1
rb_warn(char *fmt, ...)
d102 1
a102 1
rb_warn(fmt, va_alist)
d117 1
a117 1
/* rb_warning() reports only in verbose mode */
d120 1
a120 1
rb_warning(char *fmt, ...)
d122 1
a122 1
rb_warning(fmt, va_alist)
d130 1
a130 1
    if (!RTEST(rb_verbose)) return;
d141 1
a141 1
rb_bug(char *fmt, ...)
d143 1
a143 1
rb_bug(fmt, va_alist)
d208 1
a208 1
		    etype = RSTRING(rb_obj_as_string(x))->ptr;
d213 2
a214 2
		rb_raise(rb_eTypeError, "wrong argument type %s (expected %s)",
			 etype, type->name);
d218 1
a218 1
	rb_bug("unknown type 0x%x", t);
d225 12
a236 12
VALUE rb_eException;
VALUE rb_eSystemExit, rb_eInterrupt, rb_eFatal;
VALUE rb_eStandardError;
VALUE rb_eRuntimeError;
VALUE rb_eSyntaxError;
VALUE rb_eTypeError;
VALUE rb_eArgError;
VALUE rb_eNameError;
VALUE rb_eIndexError;
VALUE rb_eLoadError;
VALUE rb_eSecurityError;
VALUE rb_eNotImpError;
d238 2
a239 2
VALUE rb_eSystemCallError;
VALUE rb_mErrno;
d242 1
a242 1
rb_exc_new(etype, ptr, len)
d247 1
a247 1
    VALUE exc = rb_obj_alloc(etype);
d249 1
a249 1
    rb_iv_set(exc, "mesg", rb_str_new(ptr, len));
d254 1
a254 1
rb_exc_new2(etype, s)
d258 1
a258 1
    return rb_exc_new(etype, s, strlen(s));
d262 1
a262 1
rb_exc_new3(etype, str)
d269 1
a269 1
    return rb_exc_new(etype, s, len);
d281 1
a281 1
	mesg = rb_str_new(0, 0);
d292 1
a292 1
exc_new(argc, argv, self)
d304 2
a305 2
    exc = rb_obj_alloc(etype);
    rb_obj_call_init(exc);
d324 1
a324 1
    exc = rb_obj_as_string(exc);
d326 1
a326 1
	return rb_str_dup(rb_class_path(klass));
d329 1
a329 1
    str = rb_str_new2("#<");
d331 4
a334 4
    rb_str_concat(str, klass);
    rb_str_cat(str, ":", 1);
    rb_str_concat(str, exc);
    rb_str_cat(str, ">", 1);
d356 1
a356 1
	if (t == T_STRING) return rb_ary_new3(1, bt);
d358 1
a358 1
	    rb_raise(rb_eTypeError, err);
d362 1
a362 1
		rb_raise(rb_eTypeError, err);
d382 1
a382 1
    VALUE etype = rb_eStandardError;
d387 1
a387 1
	rb_raise(rb_eArgError, "wrong # of arguments");
d389 1
a389 1
    rb_warn("Exception() is now obsolete");
d393 2
a394 2
	if (!rb_funcall(etype, '<', 1, rb_eException)) {
	    rb_raise(rb_eTypeError, "exception should be subclass of Exception");
d400 1
a400 1
	    rb_raise(rb_eArgError, "argument needs to be symbol or string");
d403 1
a403 2
	    rb_raise(rb_eArgError, "identifier `%s' needs to be constant",
		     rb_id2name(id));
d407 1
a407 1
	v = rb_define_class_under(ruby_class,
d409 1
a409 1
				  rb_eStandardError);
d482 1
a482 1
    VALUE error = rb_define_class_under(rb_mErrno, name, rb_eSystemCallError);
d537 25
a561 25
    rb_eException   = rb_define_class("Exception", rb_cObject);
    rb_define_method(rb_eException, "new", exc_new, -1);
    rb_define_method(rb_eException, "initialize", exc_initialize, -1);
    rb_define_method(rb_eException, "to_s", exc_to_s, 0);
    rb_define_method(rb_eException, "to_str", exc_to_s, 0);
    rb_define_method(rb_eException, "message", exc_to_s, 0);
    rb_define_method(rb_eException, "inspect", exc_inspect, 0);
    rb_define_method(rb_eException, "backtrace", exc_backtrace, 0);
    rb_define_method(rb_eException, "set_backtrace", exc_set_backtrace, 1);

    rb_eSystemExit  = rb_define_class("SystemExit", rb_eException);
    rb_eFatal  	 = rb_define_class("fatal", rb_eException);
    rb_eInterrupt   = rb_define_class("Interrupt", rb_eException);

    rb_eStandardError = rb_define_class("StandardError", rb_eException);
    rb_eSyntaxError = rb_define_class("SyntaxError", rb_eStandardError);
    rb_eTypeError   = rb_define_class("TypeError", rb_eStandardError);
    rb_eArgError    = rb_define_class("ArgumentError", rb_eStandardError);
    rb_eNameError   = rb_define_class("NameError", rb_eStandardError);
    rb_eIndexError  = rb_define_class("IndexError", rb_eStandardError);
    rb_eLoadError   = rb_define_class("LoadError", rb_eStandardError);

    rb_eRuntimeError = rb_define_class("RuntimeError", rb_eStandardError);
    rb_eSecurityError = rb_define_class("SecurityError", rb_eStandardError);
    rb_eNotImpError = rb_define_class("NotImplementError", rb_eException);
d568 9
d579 1
a579 1
rb_raise(VALUE exc, char *fmt, ...)
d581 1
a581 1
rb_raise(exc, fmt, va_alist)
d587 26
a612 2
    va_list args;
    char buf[BUFSIZ];
d614 10
a623 4
    va_init_list(args,fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);
    rb_exc_raise(rb_exc_new2(exc, buf));
d628 1
a628 1
rb_loaderror(char *fmt, ...)
d630 1
a630 1
rb_loaderror(fmt, va_alist)
d635 2
a636 2
    va_list args;
    char buf[BUFSIZ];
d638 10
a647 4
    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);
    rb_exc_raise(rb_exc_new2(rb_eLoadError, buf));
d653 15
a667 3
    rb_raise(rb_eNotImpError,
	     "The %s() function is unimplemented on this machine",
	     rb_id2name(ruby_frame->last_func));
d672 1
a672 1
rb_fatal(char *fmt, ...)
d674 1
a674 1
rb_fatal(fmt, va_alist)
d687 1
a687 1
    rb_exc_fatal(rb_exc_new2(rb_eFatal, buf));
d705 1
a705 1
	buf = ALLOCA_N(char, strlen(err)+strlen(mesg)+4);
d743 1
a743 1
    ee = rb_exc_new2(ee, buf);
d746 1
a746 1
    rb_exc_raise(ee);
d755 2
a756 2
    rb_eSystemCallError = rb_define_class("SystemCallError", rb_eStandardError);
    rb_define_method(rb_eSystemCallError, "errno", syserr_errno, 0);
d758 1
a758 1
    rb_mErrno = rb_define_module("Errno");
d1143 1
a1143 1
    extern VALUE rb_errinfo;
d1146 2
a1147 2
	if (NIL_P(rb_errinfo)) {
	    rb_errinfo = rb_exc_new2(rb_eSyntaxError, s);
d1150 1
a1150 1
	    VALUE str = rb_str_to_str(rb_errinfo);
d1152 3
a1154 3
	    rb_str_cat(str, "\n", 1);
	    rb_str_cat(str, s, strlen(s));
	    rb_errinfo = rb_exc_new3(rb_eSyntaxError, str);
@


1.1.1.2.2.24.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/09/08 07:08:39 $
d242 1
a242 1
    int len;
@


1.1.1.2.2.24.2.3
log
@first public release of 1.1d (pre1.2) series
@
text
@d6 1
a6 1
  $Date: 1998/10/06 03:28:06 $
d277 4
a280 1
    if (rb_scan_args(argc, argv, "01", &mesg) == 1) {
d311 1
a311 4
    VALUE mesg = rb_iv_get(exc, "mesg");

    if (NIL_P(mesg)) return rb_class_path(CLASS_OF(exc));
    return mesg;
@
