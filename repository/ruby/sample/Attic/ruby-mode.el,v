head	1.2;
access;
symbols
	v1_6_3:1.2
	ruby_1_6:1.2.0.2
	v1_2_6repack:1.1.1.2.2.24
	v1_2_6:1.1.1.2.2.24
	v1_2_5:1.1.1.2.2.24
	v1_2_4:1.1.1.2.2.24
	v1_2_2:1.1.1.2.2.24
	v1_2_2_pr1:1.1.1.2.2.24
	v1_2_1repack:1.1.1.2.2.24
	v1_2_1:1.1.1.2.2.23
	v1_2_stable:1.1.1.2.2.23
	v1_1c9_1:1.1.1.2.2.23
	v1_1c9:1.1.1.2.2.23
	v1_1c8:1.1.1.2.2.22
	v1_1c7:1.1.1.2.2.21
	v1_1c6:1.1.1.2.2.20
	v1_1d-start:1.1.1.2.2.20.2.1
	v1_1c5:1.1.1.2.2.20
	v1_1dev:1.1.1.2.2.20.0.2
	v1_1c4:1.1.1.2.2.20
	v1_1c3:1.1.1.2.2.20
	v1_1c2:1.1.1.2.2.20
	v1_1c1:1.1.1.2.2.19
	v1_1c0:1.1.1.2.2.19
	v1_1b9_31:1.1.1.2.2.19
	v1_1b9_30:1.1.1.2.2.18
	v1_1b9_28:1.1.1.2.2.17
	v1_1b9_27:1.1.1.2.2.17
	v1_1b9_26:1.1.1.2.2.17
	r1_1b9_25:1.1.1.2.2.17
	r1_1b9_24:1.1.1.2.2.17
	v1_1b9_23:1.1.1.2.2.15
	v1_1b9_22:1.1.1.2.2.14
	v1_1b9_20:1.1.1.2.2.14
	v1_1b9_18:1.1.1.2.2.14
	v1_1b9_16:1.1.1.2.2.14
	v1_1b9_15:1.1.1.2.2.14
	v1_1b9_13:1.1.1.2.2.14
	v1_1b9_12:1.1.1.2.2.14
	v1_1b9_11:1.1.1.2.2.13
	v1_1b9_08:1.1.1.2.2.10
	v1_1b9_07:1.1.1.2.2.10
	r1_1b9:1.1.1.2.2.9
	v1_1b8:1.1.1.2.2.6
	v1_1b7:1.1.1.2.2.6
	v1_1b6:1.1.1.2.2.2
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@; @;


1.2
date	99.08.13.06.09.53;	author matz;	state dead;
branches;
next	1.1;

1.1
date	98.01.16.12.13.08;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.08;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.21;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	;

1.1.1.2.2.1
date	98.01.19.05.08.25;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.23.10.39.02;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.01.29.03.22.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.01.29.03.48.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.01.29.08.18.03;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.02.02.04.49.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.02.25.06.52.43;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.02.26.08.27.15;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.02.27.05.43.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.03.30.09.41.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.04.09.09.30.25;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.04.14.04.55.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.04.16.07.42.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.04.17.09.29.36;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.05.25.09.42.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.06.03.09.06.44;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.06.05.09.54.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.07.09.08.40.45;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.07.15.06.13.08;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.07.29.09.50.58;	author matz;	state Exp;
branches
	1.1.1.2.2.20.2.1;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.11.09.09.11.52;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.11.17.09.12.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.11.26.08.25.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	99.01.12.01.16.57;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.20.2.1
date	98.09.08.07.09.52;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20.2.2;

1.1.1.2.2.20.2.2
date	98.11.25.03.31.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20.2.3;

1.1.1.2.2.20.2.3
date	98.12.16.07.30.36;	author matz;	state dead;
branches;
next	;


desc
@@


1.2
log
@remove obsolete files
@
text
@;;;
;;;  ruby-mode.el -
;;;
;;;  $Author: matz $
;;;  Time-stamp: <97/03/21 01:16:05 matz>
;;;  created at: Fri Feb  4 14:49:13 JST 1994
;;;

(defconst ruby-mode-version "1.0.7")

(defconst ruby-block-beg-re
  "class\\|module\\|def\\|if\\|unless\\|case\\|while\\|until\\|for\\|begin\\|do"
  )

(defconst ruby-indent-beg-re
  "\\(\\s *\\(class\\|module\\|def\\)\\)\\|if\\|unless\\|case\\|while\\|until\\|for\\|begin"
    )

(defconst ruby-modifier-re
  "if\\|unless\\|while\\|until"
  )

(defconst ruby-block-mid-re
  "then\\|else\\|elsif\\|when\\|rescue\\|ensure"
  )

(defconst ruby-block-op-re
  "and\\|or\\|not"
  )

(defconst ruby-block-end-re "end")

(defconst ruby-delimiter
  (concat "[?$/%(){}#\"'`]\\|\\[\\|\\]\\|\\<\\("
	  ruby-block-beg-re
	  "\\|" ruby-block-end-re
	  "\\)\\>\\|^=begin")
  )

(defconst ruby-negative
  (concat "^[ \t]*\\(\\(" ruby-block-mid-re "\\)\\>\\|\\("
	    ruby-block-end-re "\\)\\>\\|\\}\\|\\]\\)")
  )

(defconst ruby-operator-chars "[,.+*/%-&|^~=<>:]")
(defconst ruby-symbol-chars "[a-zA-Z0-9_]")

(defvar ruby-mode-abbrev-table nil
  "Abbrev table in use in ruby-mode buffers.")

(define-abbrev-table 'ruby-mode-abbrev-table ())

(defvar ruby-mode-map nil "Keymap used in ruby mode.")

(if ruby-mode-map
    nil
  (setq ruby-mode-map (make-sparse-keymap))
  (define-key ruby-mode-map "{" 'ruby-electric-brace)
  (define-key ruby-mode-map "}" 'ruby-electric-brace)
  (define-key ruby-mode-map "\e\C-a" 'ruby-beginning-of-defun)
  (define-key ruby-mode-map "\e\C-e" 'ruby-end-of-defun)
  (define-key ruby-mode-map "\e\C-b" 'ruby-beginning-of-block)
  (define-key ruby-mode-map "\e\C-f" 'ruby-end-of-block)
  (define-key ruby-mode-map "\e\C-p" 'ruby-beginning-of-block)
  (define-key ruby-mode-map "\e\C-n" 'ruby-end-of-block)
  (define-key ruby-mode-map "\t" 'ruby-indent-command)
  (define-key ruby-mode-map "\C-c\C-e" 'ruby-insert-end)
  (define-key ruby-mode-map "\C-j" 'ruby-reindent-then-newline-and-indent)
  (define-key ruby-mode-map "\C-m" 'newline))

(defvar ruby-mode-syntax-table nil
  "Syntax table in use in ruby-mode buffers.")

(if ruby-mode-syntax-table
    ()
  (setq ruby-mode-syntax-table (make-syntax-table))
  (modify-syntax-entry ?\' "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?\" "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?\` "\"" ruby-mode-syntax-table)
  (modify-syntax-entry ?# "<" ruby-mode-syntax-table)
  (modify-syntax-entry ?\n ">" ruby-mode-syntax-table)
  (modify-syntax-entry ?\\ "'" ruby-mode-syntax-table)
  (modify-syntax-entry ?$ "/" ruby-mode-syntax-table)
  (modify-syntax-entry ?? "_" ruby-mode-syntax-table)
  (modify-syntax-entry ?_ "_" ruby-mode-syntax-table)
  (modify-syntax-entry ?< "." ruby-mode-syntax-table)
  (modify-syntax-entry ?> "." ruby-mode-syntax-table)
  (modify-syntax-entry ?& "." ruby-mode-syntax-table)
  (modify-syntax-entry ?| "." ruby-mode-syntax-table)
  (modify-syntax-entry ?% "." ruby-mode-syntax-table)
  (modify-syntax-entry ?= "." ruby-mode-syntax-table)
  (modify-syntax-entry ?/ "." ruby-mode-syntax-table)
  (modify-syntax-entry ?+ "." ruby-mode-syntax-table)
  (modify-syntax-entry ?* "." ruby-mode-syntax-table)
  (modify-syntax-entry ?- "." ruby-mode-syntax-table)
  (modify-syntax-entry ?\; "." ruby-mode-syntax-table)
  (modify-syntax-entry ?\( "()" ruby-mode-syntax-table)
  (modify-syntax-entry ?\) ")(" ruby-mode-syntax-table)
  (modify-syntax-entry ?\{ "(}" ruby-mode-syntax-table)
  (modify-syntax-entry ?\} "){" ruby-mode-syntax-table)
  (modify-syntax-entry ?\[ "(]" ruby-mode-syntax-table)
  (modify-syntax-entry ?\] ")[" ruby-mode-syntax-table)
  )

(defvar ruby-indent-level 2
  "*Indentation of ruby statements.")

(defun ruby-mode ()
  "Major mode for editing ruby scripts.
\\[ruby-indent-command] properly indents subexpressions of multi-line
class, module, def, if, while, for, do, and case statements, taking
nesting into account.

The variable ruby-indent-level controls the amount of indentation.
\\{ruby-mode-map}"
  (interactive)
  (kill-all-local-variables)
  (use-local-map ruby-mode-map)
  (setq mode-name "ruby")
  (setq major-mode 'ruby-mode)
  (set-syntax-table ruby-mode-syntax-table)
  (setq local-abbrev-table ruby-mode-abbrev-table)
  (make-local-variable 'indent-line-function)
  (setq indent-line-function 'ruby-indent-line)
  (make-local-variable 'require-final-newline)
  (setq require-final-newline t)
  (make-variable-buffer-local 'comment-start)
  (setq comment-start "# ")
  (make-variable-buffer-local 'comment-end)
  (setq comment-end "")
  (make-variable-buffer-local 'comment-column)
  (setq comment-column 32)
  (make-variable-buffer-local 'comment-start-skip)
  (setq comment-start-skip "#+ *")
  (make-local-variable 'parse-sexp-ignore-comments)
  (setq parse-sexp-ignore-comments t)
  (run-hooks 'ruby-mode-hook))

(defun ruby-current-indentation ()
  (save-excursion
    (beginning-of-line)
    (back-to-indentation)
    (current-column)))

(defun ruby-indent-line (&optional flag)
  "Correct indentation of the current ruby line."
  (ruby-indent-to (ruby-calculate-indent)))

(defun ruby-indent-command ()
  (interactive)
  (ruby-indent-line t))

(defun ruby-indent-to (x)
  (if x
      (let (shift top beg)
	(and (< x 0)
	     (error "invalid nest"))
	(setq shift (current-column))
	(beginning-of-line)
	(setq beg (point))
	(back-to-indentation)
	(setq top (current-column))
	(skip-chars-backward " \t")
	(cond
	 ((>= x shift)
	  (setq shift 0))
	 ((>= shift top)
	  (setq shift (- shift top)))
	 (t (setq shift 0)))
	(if (and (bolp)
		 (= x top))
	    (move-to-column (+ x shift))
	  (move-to-column top)
	  (delete-region beg (point))
	  (beginning-of-line)
	  (indent-to x)
	  (move-to-column (+ x shift))))))

(defun ruby-expr-beg (&optional modifier)
  (save-excursion
    (if (looking-at "\\?")
	(progn
	  (or (bolp) (forward-char -1))
	  (not (looking-at "\\sw")))
      (skip-chars-backward " \t")
      (or (bolp) (forward-char -1))
      (or (looking-at ruby-operator-chars)
	  (looking-at "[\\[({!?]")
	  (bolp)
	  (and (looking-at ruby-symbol-chars)
	       (forward-word -1)
	       (or 
		(and modifier (bolp))
		(looking-at ruby-block-beg-re)
		(looking-at ruby-block-op-re)
		(looking-at ruby-block-mid-re)
		(and modifier
		     (save-excursion
		       (forward-char -1)
		       (let ((c (char-after (point))))
			 (or (eq c ?.)
			     (eq c ? )
			     (eq c ?\t))))))
	       (goto-char (match-end 0))
	       (looking-at "[^_]"))))))

(defun ruby-parse-region (start end)
  (let ((indent-point end)
	  (indent 0)
	  (in-string nil)
	  (in-paren nil)
	  (depth 0)
	  (nest nil)
	  (pcol nil))
    (save-excursion
	(if start
	    (goto-char start)
	  (ruby-beginning-of-indent))
	(save-restriction
	  (narrow-to-region (point) end)
	  (while (and (> indent-point (point))
		      (re-search-forward ruby-delimiter indent-point t))
	    (let ((pnt (point)) w)
	      (goto-char (match-beginning 0))
	      (cond
	       ((or (looking-at "\"")	;skip string
		    (looking-at "'")
		    (looking-at "`"))
		(setq w (char-after (point)))
		(cond
		 ((and (not (eobp))
		       (re-search-forward (format "[^\\]%c" w) indent-point t))
		  nil)
		 (t
		  (setq in-string (point))
		  (goto-char indent-point))))
	       ((looking-at "/")
		(cond
		 ((and (not (eobp)) (ruby-expr-beg))
		  (if (re-search-forward "[^\\]/" indent-point t)
		      nil
		    (setq in-string (point))
		    (goto-char indent-point)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "%")
		(cond
		 ((and (not (eobp)) (ruby-expr-beg)
		       (looking-at "%[Qqrx]?\\(.\\)"))
		  (setq w (buffer-substring (match-beginning 1)
					    (match-end 1)))
		  (cond
		   ((string= w "[") (setq w "]"))
		   ((string= w "{") (setq w "}"))
		   ((string= w "(") (setq w ")"))
		   ((string= w "<") (setq w ">")))
		  (goto-char (match-end 0))
		  (if (search-forward w indent-point t)
		      nil
		    (setq in-string (point))
		    (goto-char indent-point)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "\\?")	;skip ?char
		(cond
		 ((ruby-expr-beg)
		  (looking-at "?\\(\\\\C-\\|\\\\M-\\)*.")
		  (goto-char (match-end 0)))
		 (t
		  (goto-char pnt))))
	       ((looking-at "\\$")	;skip $char
		(goto-char pnt)
		(forward-char 1))
	       ((looking-at "#")		;skip comment
		(forward-line 1)
		(goto-char (point))
		)
	       ((looking-at "(")
		(setq nest (cons (cons (char-after (point)) pnt) nest))
		(setq pcol (cons (cons pnt depth) pcol))
		(setq depth 0)
		(goto-char pnt)
		)
	       ((looking-at "[\\[{]")
		(setq nest (cons (cons (char-after (point)) pnt) nest))
		(setq depth (1+ depth))
		(goto-char pnt)
		)
	       ((looking-at ")")
		(setq nest (cdr nest))
		(setq depth (cdr (car pcol)))
		(setq pcol (cdr pcol))
		(goto-char pnt))
	       ((looking-at "[])}]")
		(setq nest (cdr nest))
		(setq depth (1- depth))
		(goto-char pnt))
	       ((looking-at ruby-block-end-re)
		(if (or (and (not (bolp))
			     (progn
			       (forward-char -1)
			       (eq ?_ (char-after (point)))))
			(progn
			  (goto-char pnt)
			  (setq w (char-after (point)))
			  (or (eq ?_ w)
			      (eq ?! w)
			      (eq ?? w))))
		    nil
		  (setq nest (cdr nest))
		  (setq depth (1- depth)))
		(goto-char pnt))
	       ((looking-at ruby-block-beg-re)
		(and 
		 (or (bolp)
		     (progn
		       (forward-char -1)
		       (not (eq ?_ (char-after (point))))))
		 (progn
		   (goto-char pnt)
		   (setq w (char-after (point)))
		   (and (not (eq ?_ w))
			(not (eq ?! w))
			(not (eq ?? w))))
		 (progn
		   (goto-char (match-beginning 0))
		   (if (looking-at ruby-modifier-re)
		       (ruby-expr-beg)
		     t))
		 (progn
		   (setq nest (cons (cons nil pnt) nest))
		   (setq depth (1+ depth))))
		(if (looking-at "def\\s *[/`]")
		    (goto-char (match-end 0))
		  (goto-char pnt)))
	       ((looking-at "^=begin")
		(if (re-search-forward "^=end" indent-point t)
		    (forward-line 1)
		  (setq in-string (match-end 0))
		  (goto-char indent-point)))
	       (t
		(error (format "bad string %s"
			       (buffer-substring (point) pnt)
			       )))))))
	(list in-string (car nest) depth (car (car pcol))))))

(defun ruby-calculate-indent (&optional parse-start)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
	    (case-fold-search nil)
	    state bol eol
	    (indent 0))
	(if parse-start
	    (goto-char parse-start)
	  (ruby-beginning-of-indent)
	  (setq parse-start (point)))
	(back-to-indentation)
	(setq indent (current-column))
	(setq state (ruby-parse-region parse-start indent-point))
	(cond
	 ((nth 0 state)			; within string
	  (setq indent nil))		;  do nothing

	 ((car (nth 1 state))		; in paren
	  (goto-char (cdr (nth 1 state)))
	  (if (eq (car (nth 1 state)) ?\( )
	      (let ((column (current-column))
		    (s (ruby-parse-region (point) indent-point)))
		(cond
		 ((and (nth 2 s) (> (nth 2 s) 0))
		  (goto-char (cdr (nth 1 s)))
		  (forward-word -1)
		  (setq indent (+ (current-column) ruby-indent-level)))
		 (t 
		  (setq indent (current-column)))))
	    (cond
	     ((nth 3 state)
	      (goto-char (nth 3 state))
	      (setq indent (+ (current-column) ruby-indent-level)))
	     (t
	      (goto-char parse-start)
	      (back-to-indentation)
	      (setq indent (+ (current-column) (* (nth 2 state) ruby-indent-level)))))
	    ))

	 ((and (nth 2 state)(> (nth 2 state) 0)) ; in nest
	  (goto-char (cdr (nth 1 state)))
	  (forward-word -1)		; skip back a keyword
	  (cond
	   ((looking-at "do")		; iter block is a special case
	    (cond
	     ((nth 3 state)
	      (goto-char (nth 3 state))
	      (setq indent (+ (current-column) ruby-indent-level)))
	     (t
	      (goto-char parse-start)
	      (back-to-indentation)
	      (setq indent (+ (current-column) (* (nth 2 state) ruby-indent-level))))))
	   (t
	    (setq indent (+ (current-column) ruby-indent-level)))))

	 ((and (nth 2 state) (< (nth 2 state) 0)) ; in negative nest
	  (setq indent (+ (current-column) (* (nth 2 state) ruby-indent-level)))))

	(cond
	 (indent
	  (goto-char indent-point)
	  (end-of-line)
	  (setq eol (point))
	  (beginning-of-line)
	  (cond 
	   ((re-search-forward ruby-negative eol t)
	    (and (not (eq ?_ (char-after (match-end 0))))
		 (setq indent (- indent ruby-indent-level))))
	   ;;operator terminated lines
	   ((and
	     (save-excursion
	       (beginning-of-line)
	       (not (bobp)))
	     (or (null (car (nth 1 state))) ;not in parens
		 (and (eq (car (nth 1 state)) ?\{)
		      (save-excursion	;except non-block braces
			(goto-char (cdr (nth 1 state)))
			(or (bobp) (forward-char -1))
			(not (ruby-expr-beg))))))
	    ;; goto beginning of non-empty no-comment line
	    (let (end done)
	      (while (not done)
		(skip-chars-backward " \t\n")
		(setq end (point))
		(beginning-of-line)
		(if (re-search-forward "^\\s *#" end t)
		    (beginning-of-line)
		  (setq done t))))
	    (setq bol (point))
	    (end-of-line)
	    (skip-chars-backward " \t")
	    (or (bobp) (forward-char -1))
	    (and
	     (or (and (looking-at ruby-symbol-chars)
		      (skip-chars-backward ruby-symbol-chars)
		      (looking-at ruby-block-op-re))
		 (and (looking-at ruby-operator-chars)
		      (or (not (or (eq ?/ (char-after (point)))))
			  (null (nth 0 (ruby-parse-region parse-start (point)))))
		      (not (eq (char-after (1- (point))) ?$))
		      (or (not (eq ?| (char-after (point))))
			  (save-excursion
			    (or (eolp) (forward-char -1))
			    (and (search-backward "|")
				 (skip-chars-backward " \t\n")
				 (and (not (eolp))
				      (progn
					(forward-char -1)
					(not (looking-at "\\{")))
				      (progn
					(forward-word -1)
					(not (looking-at "do\\>[^_]")))))))))
	     (setq indent (+ indent ruby-indent-level)))))))
	indent)))
 
(defun ruby-electric-brace (arg)
  (interactive "P")
  (self-insert-command (prefix-numeric-value arg))
  (ruby-indent-line t))

(defun ruby-beginning-of-defun (&optional arg)
  "Move backward to next beginning-of-defun.
With argument, do this that many times.
Returns t unless search stops due to end of buffer."
  (interactive "p")
  (and (re-search-backward (concat "^\\(" ruby-block-beg-re "\\)\\b")
			   nil 'move (or arg 1))
       (progn (beginning-of-line) t)))

(defun ruby-beginning-of-indent ()
  (and (re-search-backward (concat "^\\(" ruby-indent-beg-re "\\)\\b")
			   nil 'move)
       (progn
	 (beginning-of-line)
	 t)))

(defun ruby-end-of-defun (&optional arg)
  "Move forward to next end of defun.
An end of a defun is found by moving forward from the beginning of one."
  (interactive "p")
  (and (re-search-forward (concat "^\\(" ruby-block-end-re "\\)\\b[^_]")
			  nil 'move (or arg 1))
       (progn (beginning-of-line) t))
  (forward-line 1))

(defun ruby-move-to-block (n)
  (let (start pos done down)
    (setq start (ruby-calculate-indent))
    (if (eobp)
	nil
      (while (and (not (bobp)) (not done))
	(forward-line n)
	(cond
	 ((looking-at "^$"))
	 ((looking-at "^\\s *#"))
	 (t
	  (setq pos (current-indentation))
	  (cond
	   ((< start pos)
	    (setq down t))
	   ((and down (= pos start))
	    (setq done t))
	   ((> start pos)
	    (setq done t)))))
	(if done
	    (progn
	      (back-to-indentation)
	      (if (looking-at ruby-block-mid-re)
		  (setq done nil)))))))
  (back-to-indentation))

(defun ruby-beginning-of-block ()
  "Move backward to next beginning-of-block"
  (interactive)
  (ruby-move-to-block -1))

(defun ruby-end-of-block ()
  "Move forward to next beginning-of-block"
  (interactive)
  (ruby-move-to-block 1))

(defun ruby-reindent-then-newline-and-indent ()
  (interactive "*")
  (save-excursion
    (delete-region (point) (progn (skip-chars-backward " \t") (point))))
  (newline)
  (save-excursion
    (forward-line -1)
    (indent-according-to-mode))
  (indent-according-to-mode))

(fset 'ruby-encomment-region (symbol-function 'comment-region))

(defun ruby-decomment-region (beg end)
  (interactive "r")
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "^\\([ \t]*\\)#" end t)
      (replace-match "\\1" nil nil)
      (save-excursion
	(ruby-indent-line)))))

(defun ruby-insert-end ()
  (interactive)
  (insert "end")
  (ruby-indent-line t)
  (end-of-line))

(cond
 ((featurep 'hilit19)
  (hilit-set-mode-patterns
   'ruby-mode
   '(("[^$\\?]\\(\"[^\\\"]*\\(\\\\\\(.\\|\n\\)[^\\\"]*\\)*\"\\)" 1 string)
     ("[^$\\?]\\('[^\\']*\\(\\\\\\(.\\|\n\\)[^\\']*\\)*'\\)" 1 string)
     ("[^$\\?]\\(`[^\\`]*\\(\\\\\\(.\\|\n\\)[^\\`]*\\)*`\\)" 1 string)
     ("^\\s *#.*$" nil comment)
     ("[^$@@?\\]\\(#[^$@@{].*$\\)" 1 comment)
     ("[^a-zA-Z_]\\(\\?\\(\\\\[CM]-\\)*.\\)" 1 string)
     ("^\\s *\\(require\\|load\\).*$" nil include)
     ("^\\s *\\(include\\|alias\\|undef\\).*$" nil decl)
     ("^\\s *\\<\\(class\\|def\\|module\\)\\>" "[)\n;]" defun)
     ("[^_]\\<\\(begin\\|case\\|else\\|elsif\\|end\\|ensure\\|for\\|if\\|unless\\|rescue\\|then\\|when\\|while\\|until\\|do\\)\\>[^_]" 1 defun)
     ("[^_]\\<\\(and\\|break\\|next\\|raise\\|fail\\|in\\|not\\|or\\|redo\\|retry\\|return\\|super\\|yield\\|self\\|nil\\)\\>[^_]" 1 keyword)
     ("\\$\\(.\\|\\sw+\\)" nil type)
     ("[$@@].[a-zA-Z_0-9]*" nil struct)
     ("^__END__" nil label))))

 ((featurep 'font-lock)
  (or (boundp 'font-lock-variable-name-face)
      (setq font-lock-variable-name-face font-lock-type-face))
  (defvar ruby-font-lock-keywords
    (list
     (cons (concat
	    "\\(^\\|[^_]\\)\\b\\("
	    (mapconcat
	     'identity
	     '("alias"
	       "and"
	       "begin"
	       "break"
	       "case"
	       "class"
	       "do"
	       "elsif"
	       "else"
	       "fail"
	       "ensure"
	       "for"
	       "end"
	       "if"
	       "in"
	       "module"
	       "next"
	       "not"
	       "or"
	       "raise"
	       "redo"
	       "rescue"
	       "retry"
	       "return"
	       "then"
	       "self"
	       "super"
	       "unless"
	       "undef"
	       "until"
	       "when"
	       "while"
	       )
	     "\\|")
	    "\\)[ \n\t()]")
	   2)
     ;; variables
     '("\\(^\\|[^_]\\)\\b\\(nil\\|self\\|true\\|false\\)\\b[^_]"
       2 font-lock-variable-name-face)
     ;; variables
     '("\\[$@@].\\([a-zA-Z0-9_]\\)"
       0 font-lock-variable-name-face)
     ;; constants
     '("\\(^\\|[^_]\\)\\b\\([A-Z]+[a-zA-Z0-9_]*\\)"
       2 font-lock-type-face)
     ;; functions
     '("\\bdef[ \t]+\\([a-zA-Z_]+[a-zA-Z0-9_]*[?!=]?\\|\\[\\]=?\\)"
       0 font-lock-function-name-face))
    "*Additional expressions to highlight in ruby mode.")
  (if (and (>= (string-to-int emacs-version) 20)
          (not (featurep 'xemacs)))
      (add-hook
       'ruby-mode-hook
       (lambda ()
        (make-local-variable 'font-lock-defaults)
        (setq font-lock-defaults 
              '((ruby-font-lock-keywords) nil nil ((?\_ . "w"))))))
    (add-hook 'ruby-mode-hook
             (lambda ()
               (setq font-lock-keywords ruby-font-lock-keywords)
               (font-lock-mode 1))))))
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
;;;  $Author: matz$
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d134 1
a134 1
  (setq comment-start-skip "\\(^\\|\\s-\\);?#+ *")
a387 2
	  (if (null (cdr (nth 1 state)))
	      (error "invalid nest"))
d443 1
a443 4
		      (looking-at ruby-block-op-re)
		      (save-excursion
			(goto-char (match-end 0))
			(not (looking-at "[a-z_]"))))
d630 1
a630 1
     '("^\\s *def[ \t]+.*$"
@


1.1.1.2.2.1
log
@Mon Jan 19 14:06:13 JST 1998
@
text
@d4 1
a4 1
;;;  $Author: matz $
d636 1
a636 1
       0 font-lock-function-name-face t))
@


1.1.1.2.2.2
log
@tempfile.rb modified
@
text
@d635 1
a635 1
     '("^\\s *def[ \t]+[^ \t(]*"
@


1.1.1.2.2.3
log
@*** empty log message ***
@
text
@d5 1
a5 1
;;;  $Date$
d9 1
a9 1
(defconst ruby-mode-version "$Id$")
@


1.1.1.2.2.4
log
@*** empty log message ***
@
text
@d5 1
a5 1
;;;  $Date: 1998/01/29 03:22:53 $
d9 1
a9 3
(defconst ruby-mode-revision "$Revision$")

(defconst ruby-mode-version "$Id: ruby-mode.el,v 1.1.1.2.2.3 1998/01/29 03:22:53 matz Exp $")
@


1.1.1.2.2.5
log
@*** empty log message ***
@
text
@d5 1
a5 1
;;;  $Date: 1998/01/29 03:48:41 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.4 $")
d11 1
a11 4
(defconst ruby-mode-version
  (progn
   (string-match "[0-9.]+" ruby-mode-revision)
   (substring ruby-mode-revision (match-beginning 0) (match-end 0))))
@


1.1.1.2.2.6
log
@__FILE__,__LINE__
@
text
@d5 1
a5 1
;;;  $Date: 1998/01/29 08:18:03 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.5 $")
d87 1
a87 1
  (modify-syntax-entry ?\\ "\\" ruby-mode-syntax-table)
d643 1
a643 1
  (if (and (>= (string-to-int emacs-version) 19)
d653 2
a654 1
               (setq font-lock-keywords ruby-font-lock-keywords))))))
@


1.1.1.2.2.7
log
@reserved words & etc.
@
text
@d5 1
a5 1
;;;  $Date: 1998/02/02 04:49:13 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.6 $")
d237 1
a237 1
		       (re-search-forward (format "[^\\]\\(\\\\\\\\\\)*%c" w) indent-point t))
@


1.1.1.2.2.8
log
@1.1b8_00?
@
text
@d5 1
a5 1
;;;  $Date: 1998/02/25 06:52:43 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.7 $")
d39 1
a39 1
  (concat "[?$/%(){}#\"'`.:]\\|\\[\\|\\]\\|\\<\\("
d88 1
a88 1
  (modify-syntax-entry ?$ "." ruby-mode-syntax-table)
d279 1
a279 1
	       ((looking-at "#")	;skip comment
a317 9
	       ((looking-at "def\\s *[^\n;]*\\(\\|$\\)")
		(if (or (bolp)
			(progn
			  (forward-char -1)
			  (not (eq ?_ (char-after (point))))))
		    (progn
		      (setq nest (cons (cons nil pnt) nest))
		      (setq depth (1+ depth))))
		(goto-char (match-end 0)))
d324 6
a329 5
		 (goto-char pnt)
		 (setq w (char-after (point)))
		 (not (eq ?_ w))
		 (not (eq ?! w))
		 (not (eq ?? w))
d335 6
a340 10
		 (goto-char pnt)
		 (setq nest (cons (cons nil pnt) nest))
		 (setq depth (1+ depth)))
		(goto-char pnt))
	       ((looking-at ":\\([a-zA-Z_][a-zA-Z_0-9]*\\)?")
		(goto-char (match-end 0)))
	       ((or (looking-at "\\.\\.\\.?")
		    (looking-at "\\.[0-9]+")
		    (looking-at "\\.[a-zA-Z_0-9]+"))
		(goto-char (match-end 0)))
@


1.1.1.2.2.9
log
@*** empty log message ***
@
text
@d5 1
a5 1
;;;  $Date: 1998/02/26 08:27:15 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.8 $")
d603 1
a603 1
	    "\\(^\\|[^_:.]\\|\\.\\.\\)\\b\\("
@


1.1.1.2.2.10
log
@instance_eva/module_eval
@
text
@d5 1
a5 1
;;;  $Date: 1998/02/27 05:43:40 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.9 $")
a363 3
(defun ruby-indent-size (pos nest)
  (+ pos (* (if nest nest 1) ruby-indent-level)))

d391 1
a391 1
		  (setq indent (ruby-indent-size (current-column) (nth 2 state))))
d397 1
a397 1
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))
d401 1
a401 1
	      (setq indent (ruby-indent-size (current-column) (nth 2 state)))))
d403 1
a403 1
	  
d414 1
a414 1
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))
d418 1
a418 1
	      (setq indent (ruby-indent-size (current-column) (nth 2 state))))))
d423 2
a424 2
	  (setq indent (ruby-indent-size (current-column) (nth 2 state)))))
	 
@


1.1.1.2.2.11
log
@1.1b9_09 pre
@
text
@d5 1
a5 1
;;;  $Date: 1998/03/30 09:41:19 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.10 $")
d113 13
a125 1
(defun ruby-mode-variables ()
d141 1
a141 16
  (setq parse-sexp-ignore-comments t))

(defun ruby-mode ()
  "Major mode for editing ruby scripts.
\\[ruby-indent-command] properly indents subexpressions of multi-line
class, module, def, if, while, for, do, and case statements, taking
nesting into account.

The variable ruby-indent-level controls the amount of indentation.
\\{ruby-mode-map}"
  (interactive)
  (kill-all-local-variables)
  (use-local-map ruby-mode-map)
  (setq mode-name "ruby")
  (setq major-mode 'ruby-mode)
  (ruby-mode-variable)
a668 2

(provide 'ruby-mode)
@


1.1.1.2.2.12
log
@signal delivered to main_thread
@
text
@d5 1
a5 1
;;;  $Date: 1998/04/09 09:30:25 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.11 $")
d144 1
a144 1
  (ruby-mode-variables)
@


1.1.1.2.2.13
log
@flock,flatten,signal to main_thread
@
text
@d5 1
a5 1
;;;  $Date: 1998/04/14 04:55:53 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.12 $")
d649 1
a649 1
     '("\\(^\\|[^_]\\)\\b\\(nil\\|self\\|true\\|false\\)\\b\\([^_]\\|$\\)"
@


1.1.1.2.2.14
log
@*** empty log message ***
@
text
@d5 1
a5 1
;;;  $Date: 1998/04/16 07:42:49 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.13 $")
d658 1
a658 1
     '("^\\s *def[ \t]+[^ \t(]*$"
@


1.1.1.2.2.15
log
@*** empty log message ***
@
text
@d5 1
a5 1
;;;  $Date: 1998/04/17 09:29:36 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.14 $")
d352 1
a352 2
	       ((or (looking-at "\\.")
		    (looking-at "\\.\\.\\.?")
@


1.1.1.2.2.16
log
@*** empty log message ***
@
text
@d5 1
a5 1
;;;  $Date: 1998/05/25 09:42:47 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.15 $")
d196 1
a196 2
	  (looking-at "[\\[({]")
	  (and (not modifier) (looking-at "[!?]"))
d201 1
a201 1
		(and (not modifier) (bolp))
d341 5
a345 8
		 (skip-chars-forward " \t")
		 (if (not (eolp))
		     (progn
		       (goto-char (match-beginning 0))
		       (if (looking-at ruby-modifier-re)
			   (ruby-expr-beg t)
			 t))
		   t)
@


1.1.1.2.2.17
log
@regex
@
text
@d5 1
a5 1
;;;  $Date: 1998/06/03 09:06:44 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.16 $")
d663 1
a663 1
     '("^\\s *def[ \t]+[^ \t(]*"
@


1.1.1.2.2.18
log
@1.1b9_30
@
text
@d5 1
a5 1
;;;  $Date: 1998/06/05 09:54:28 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.17 $")
d322 1
a322 1
	       ((looking-at "def\\s +[^(\n;]*")
@


1.1.1.2.2.19
log
@1.1b9_31
@
text
@d5 1
a5 1
;;;  $Date: 1998/07/09 08:40:45 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.18 $")
d50 2
a51 5
(defconst ruby-operator-chars ",.+*/%-&|^~=<>:")
(defconst ruby-operator-re (concat "[" ruby-operator-chars "]"))

(defconst ruby-symbol-chars "a-zA-Z0-9_")
(defconst ruby-symbol-re (concat "[" ruby-symbol-chars "]"))
d187 1
a187 1
(defun ruby-expr-beg (&optional modifier pnt)
a192 1
      (store-match-data nil)
d195 1
a195 2
      (or (bolp)
	  (looking-at ruby-operator-re)
d198 2
a199 1
	  (and (looking-at ruby-symbol-re)
d201 14
a214 8
	       (if (and (not modifier) (bolp))
		   t
		 (if (or (looking-at ruby-block-beg-re)
			 (looking-at ruby-block-op-re)
			 (looking-at ruby-block-mid-re))
		     (progn
		       (goto-char (match-end 0))
		       (looking-at "[^_]")))))))))
d471 1
a471 1
	     (or (and (looking-at ruby-symbol-re)
d477 1
a477 1
		 (and (looking-at ruby-operator-re)
@


1.1.1.2.2.20
log
@sync ev
@
text
@d5 1
a5 1
;;;  $Date: 1998/07/15 06:13:08 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.19 $")
d91 1
a91 1
  (modify-syntax-entry ?$ "/" ruby-mode-syntax-table)
d655 1
a655 1
     '("[$@@].[a-zA-Z0-9_]*"
@


1.1.1.2.2.21
log
@1.1c7
@
text
@d5 1
a5 1
;;;  $Date: 1998/07/29 09:50:58 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.20 $")
d256 1
a256 1
		       (looking-at "%[Qqrxw]?\\(.\\)"))
a620 1
	       "def"
d649 1
a649 1
	    "\\)\\b")
d661 2
a662 2
     '("^\\s *def[ \t]+\\([^ \t(]*\\)"
       1 font-lock-function-name-face t))
@


1.1.1.2.2.22
log
@1.1c8
@
text
@d5 1
a5 1
;;;  $Date: 1998/11/09 09:11:52 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.21 $")
d595 1
a595 1
     ("[^$@@?\\]\\(#[^$@@{\n].*$\\)" 1 comment)
@


1.1.1.2.2.23
log
@1.1c9 - 1.1c final, hopefully
@
text
@d5 1
a5 1
;;;  $Date: 1998/11/25 03:31:19 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.20.2.2 $")
d145 1
a145 1
  (setq mode-name "Ruby")
d212 1
a212 1
		       (looking-at "\\>")))))))))
a466 6
	    (and (re-search-backward "#" (save-excursion
					   (beginning-of-line)
					   (point)) t)
		 (setq state (ruby-parse-region parse-start (point)))
		 (nth 0 state)
		 (goto-char (nth 0 state)))
d476 1
a476 1
		      (or (not (eq ?/ (char-after (point))))
@


1.1.1.2.2.24
log
@1.2.1 repack
@
text
@d5 1
a5 1
;;;  $Date: 1998/12/16 07:30:36 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.2.1 $")
a73 1
  (define-key ruby-mode-map "\e\C-h" 'ruby-mark-defun)
d132 1
a132 7
  (setq parse-sexp-ignore-comments t)
  (make-local-variable 'paragraph-start)
  (setq paragraph-start (concat "$\\|" page-delimiter))
  (make-local-variable 'paragraph-separate)
  (setq paragraph-separate paragraph-start)
  (make-local-variable 'paragraph-ignore-fill-prefix)
  (setq paragraph-ignore-fill-prefix t))
d525 1
a525 1
  (and (re-search-forward (concat "^\\(" ruby-block-end-re "\\)\\($\\|\\b[^_]\\)")
a592 9
(defun ruby-mark-defun ()
  "Put mark at end of this Ruby function, point at beginning."
  (interactive)
  (push-mark (point))
  (ruby-end-of-defun)
  (push-mark (point) nil t)
  (ruby-beginning-of-defun)
  (re-search-backward "^\n" (- (point) 1) t))

d659 2
a660 2
     '("\\b\\(nil\\|self\\|true\\|false\\)\\b"
       1 font-lock-variable-name-face)
d668 2
a669 2
     '("^\\s *def\\s *\\<\\(\\(\\w\\|\\s_\\)+\\.\\)?\\(\\(\\w\\|\\s_\\)+\\)\\>"
       3 font-lock-function-name-face t))
@


1.1.1.2.2.20.2.1
log
@1.1d series
@
text
@d5 1
a5 1
;;;  $Date: 1998/07/29 09:50:58 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.20 $")
d145 1
a145 1
  (setq mode-name "Ruby")
a466 6
	    (and (re-search-backward "#" (save-excursion
					   (beginning-of-line)
					   (point)) t)
		 (setq state (ruby-parse-region parse-start (point)))
		 (nth 0 state)
		 (goto-char (nth 0 state)))
d476 1
a476 1
		      (or (not (eq ?/ (char-after (point))))
@


1.1.1.2.2.20.2.2
log
@*** empty log message ***
@
text
@d5 1
a5 1
;;;  $Date: 1998/11/17 09:12:49 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.20.2.1 $")
d212 1
a212 1
		       (looking-at "\\>")))))))))
d256 1
a256 1
		       (looking-at "%[Qqrxw]?\\(.\\)"))
d601 1
a601 1
     ("[^$@@?\\]\\(#[^$@@{\n].*$\\)" 1 comment)
a626 1
	       "def"
d655 1
a655 1
	    "\\)\\b")
d667 2
a668 2
     '("^\\s *def[ \t]+\\([^ \t(]*\\)"
       1 font-lock-function-name-face t))
@


1.1.1.2.2.20.2.3
log
@first public release of 1.1d (pre1.2) series
@
text
@d5 1
a5 1
;;;  $Date: 1998/11/25 03:31:19 $
d9 1
a9 1
(defconst ruby-mode-revision "$Revision: 1.1.1.2.2.20.2.2 $")
@


