head	1.5;
access;
symbols
	v1_6_4_preview2:1.4
	v1_6_4_preview1:1.4
	v1_6_3:1.4
	ruby_m17n:1.4.0.4
	ruby_1_6:1.4.0.2
	v1_6_2:1.4
	v1_6_1:1.4
	v1_6_0:1.4
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.2
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.2.2.1
	v1_3_6_repack:1.1.1.2.2.1
	v1_3_6:1.1.1.2.2.1
	v1_3_5:1.1.1.2.2.1
	v1_2_6repack:1.1.1.1.2.9
	v1_3_4_990625:1.1.1.2.2.1
	v1_3_4_990624:1.1.1.2.2.1
	v1_2_6:1.1.1.1.2.9
	v1_3_4_990611:1.1.1.2.2.1
	v1_3_4_990531:1.1.1.2.2.1
	v1_3_3_990518:1.1.1.2.2.1
	v1_3_3_990513:1.1.1.2.2.1
	v1_3_3_990507:1.1.1.2.2.1
	v1_2_5:1.1.1.1.2.9
	v1_2_4:1.1.1.1.2.9
	v1_3_1_990225:1.1.1.2.2.1
	v1_3_1_990224:1.1.1.2.2.1
	v1_3_1_990215:1.1.1.2.2.1
	v1_3_1_990212:1.1.1.2.2.1
	v1_3_1_990210:1.1.1.2.2.1
	v1_3_1_:1.1.1.2.2.1
	v1_3_1_990209:1.1.1.2.2.1
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.2.9
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.2.9
	v1_2_1repack:1.1.1.1.2.9
	v1_2_1:1.1.1.1.2.9
	v1_2_stable:1.1.1.1.2.9
	v1_1d1:1.1.1.1.2.9
	v1_1d0:1.1.1.1.2.9
	v1_1c9_1:1.1.1.1.2.9
	v1_1c9:1.1.1.1.2.9
	v1_1c8:1.1.1.1.2.9
	v1_1c7:1.1.1.1.2.9
	v1_1c6:1.1.1.1.2.9
	v1_1d-start:1.1.1.1.2.9
	v1_1c5:1.1.1.1.2.9
	v1_1dev:1.1.1.1.2.9.0.2
	v1_1c4:1.1.1.1.2.9
	v1_1c3:1.1.1.1.2.9
	v1_1c2:1.1.1.1.2.8
	v1_1c1:1.1.1.1.2.8
	v1_1c0:1.1.1.1.2.8
	v1_1b9_31:1.1.1.1.2.8
	v1_1b9_30:1.1.1.1.2.8
	v1_1b9_28:1.1.1.1.2.8
	v1_1b9_27:1.1.1.1.2.8
	v1_1b9_26:1.1.1.1.2.8
	r1_1b9_25:1.1.1.1.2.8
	r1_1b9_24:1.1.1.1.2.8
	v1_1b9_23:1.1.1.1.2.8
	v1_1b9_22:1.1.1.1.2.8
	v1_1b9_20:1.1.1.1.2.8
	v1_1b9_18:1.1.1.1.2.8
	v1_1b9_16:1.1.1.1.2.8
	v1_1b9_15:1.1.1.1.2.8
	v1_1b9_13:1.1.1.1.2.8
	v1_1b9_12:1.1.1.1.2.8
	v1_1b9_11:1.1.1.1.2.8
	v1_1b9_08:1.1.1.1.2.8
	v1_1b9_07:1.1.1.1.2.8
	r1_1b9:1.1.1.1.2.7
	v1_1b8:1.1.1.1.2.4
	v1_1b7:1.1.1.1.2.4
	v1_1b6:1.1.1.1.2.1
	v1_1r:1.1.1.1.0.2
	v1_1:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2001.05.07.18.46.39;	author knu;	state dead;
branches;
next	1.4;

1.4
date	2000.05.17.04.38.19;	author matz;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.05.12.09.07.57;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.19;	author matz;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	98.01.16.12.19.21;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.19.21;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.38;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	;

1.1.1.2.2.1
date	99.02.09.06.08.24;	author matz;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	98.01.16.12.36.10;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	98.01.29.08.18.03;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	98.02.06.10.03.24;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	98.02.09.10.56.23;	author matz;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	98.02.23.05.36.39;	author matz;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	98.02.24.03.55.01;	author matz;	state Exp;
branches;
next	1.1.1.1.2.7;

1.1.1.1.2.7
date	98.02.27.05.40.07;	author matz;	state Exp;
branches;
next	1.1.1.1.2.8;

1.1.1.1.2.8
date	98.03.11.09.19.50;	author matz;	state Exp;
branches;
next	1.1.1.1.2.9;

1.1.1.1.2.9
date	98.08.14.03.56.28;	author matz;	state Exp;
branches;
next	;

1.2.2.1
date	99.12.07.16.53.19;	author matz;	state dead;
branches;
next	;

1.4.2.1
date	2001.05.07.18.46.24;	author knu;	state dead;
branches;
next	;


desc
@@


1.5
log
@Obsoleted by IRB.
@
text
@#!/usr/local/bin/ruby
#
#   rbc.rb - 
#   	$Release Version: 0.8 $
#   	$Revision: 1.8 $
#   	$Date: 1998/03/11 05:43:00 $
#   	by Keiju ISHITSUKA(Nippon Rational Inc.)
#
# --
# Usage:
#
#   rbc.rb [options] file_name opts
#   options:
#	-d		    debug mode (not recommended)
#	-f		    does not read ~/.irbrc
#	-m		    bc mode (rational/matrix calc)
#	-r load-module	    same as `ruby -r'
#	--inspect	    use inspect for result output
#			    (default for non-bc mode)
#	--noinspect	    does not use inspect for result output
#	--noreadline	    does not use readline library
#			    (default: try to use readline)
#
# additional private method (as function):
#   exit, quit		    terminate the interpreter
#   inspect_mode(sw = nil)  toggle inspect mode
#   trace_load(sw = nil)    change trace mode for file loading using
#			    load/require.  (default: trace-mode on)
#
require "e2mmap.rb"

$stdout.sync = TRUE

module BC_APPLICATION__
  RCS_ID='-$Id: rbc.rb,v 1.8 1998/03/11 05:43:00 keiju Exp keiju $-'
  
  extend Exception2MessageMapper
  def_exception :UnrecognizedSwitch, "Unrecognized switch: %s"
  
  CONFIG = {}
  CONFIG[0] = $0
  CONFIG[:USE_READLINE] = TRUE
  CONFIG[:LOAD_MODULES] = []
  CONFIG[:INSPECT] = nil
  CONFIG[:TRACE_LOAD] = FALSE
  CONFIG[:RC] = TRUE

  CONFIG[:DEBUG] = FALSE

  while opt = ARGV.shift
    case opt
    when "-d"
      CONFIG[:DEBUG] = TRUE
    when "-m"
      CONFIG[:INSPECT] = FALSE if CONFIG[:INSPECT].nil?
      require "mathn.rb"
      include Math
    when "-r"
      opt = ARGV.shift
      CONFIG[:LOAD_MODULES].push opt if opt
    when "-f"
      opt = ARGV.shift
      CONFIG[:RC] = FALSE
    when "--inspect"
      CONFIG[:INSPECT] = TRUE
    when "--noinspect"
      CONFIG[:INSPECT] = FALSE
    when "--noreadline"
      CONFIG[:USE_READLINE] = FALSE
    when /^-/
      #	  print UnrecognizedSwitch.inspect, "\n"
      BC_APPLICATION__.fail UnrecognizedSwitch, opt
    else
      CONFIG[:USE_READLINE] = FALSE
      $0 = opt
      break
    end
  end
  CONFIG[:INSPECT] = TRUE if CONFIG[:INSPECT].nil?

  PROMPTi = "rbc%d> "
  PROMPTs = "rbc%d%s "
  PROMPTe = "rbc%d* "
  
  class BC
    def initialize
      lex_init
    end
    
    def eval_input(io, cont, bind)
      line = ''
      @@io = io
      @@ltype = nil
      @@quoted = nil
      @@indent = 0
      @@lex_state = EXPR_BEG
      
      @@io.prompt = format(PROMPTi, @@indent)

      loop do
	@@continue = FALSE
	l = @@io.gets

	unless l
	  break if line == ''
	else
	  line = line + l
	  
	  lex(l) if l != "\n"
	  print @@quoted.inspect, "\n" if CONFIG[:DEBUG]
	  if @@ltype
	    @@io.prompt = format(PROMPTs, @@indent, @@ltype)
	    next
	  elsif @@continue
	    @@io.prompt = format(PROMPTe, @@indent)
	    next
	  elsif @@indent > 0
	    @@io.prompt = format(PROMPTi, @@indent)
	    next
	  end
	end
	
	if line != "\n"
	  begin
	    if CONFIG[:INSPECT]
	      print((cont._=eval(line, bind)).inspect, "\n")
	    else
	      print((cont._=eval(line, bind)), "\n")
	    end
	  rescue StandardError, ScriptError
	    #	$! = 'exception raised' unless $!
	    #	print "ERR: ", $!, "\n"
	    $! = RuntimeError.new("exception raised") unless $!
	    print $!.type, ": ", $!, "\n"
	  end
	end
	break if not l
	line = ''
	indent = 0
	@@io.prompt = format(PROMPTi, indent)
      end
      print "\n"
    end
    
    EXPR_BEG = :EXPR_BEG
    EXPR_MID = :EXPR_MID
    EXPR_END = :EXPR_END
    EXPR_ARG = :EXPR_ARG
    EXPR_FNAME = :EXPR_FNAME

    CLAUSE_STATE_TRANS = {
      "alias"	=>  EXPR_FNAME,
      "and"	=>  EXPR_BEG,
      "begin"	=>  EXPR_BEG,
      "case"	=>  EXPR_BEG,
      "class"	=>  EXPR_BEG,
      "def"	=>  EXPR_FNAME,
      "defined?"	=>  EXPR_END,
      "do"	=>  EXPR_BEG,
      "else"	=>  EXPR_BEG,
      "elsif"	=>  EXPR_BEG,
      "end"	=>  EXPR_END,
      "ensure"	=>  EXPR_BEG,
      "for"	=>  EXPR_BEG,
      "if"	=>  EXPR_BEG,
      "in"	=>  EXPR_BEG,
      "module"	=>  EXPR_BEG,
      "nil"	=>  EXPR_END,
      "not"	=>  EXPR_BEG,
      "or"	=>  EXPR_BEG,
      "rescue"	=>  EXPR_MID,
      "return"	=>  EXPR_MID,
      "self"	=>  EXPR_END,
      "super"	=>  EXPR_END,
      "then"	=>  EXPR_BEG,
      "undef"	=>  EXPR_FNAME,
      "unless"	=>  EXPR_BEG,
      "until"	=>  EXPR_BEG,
      "when"	=>  EXPR_BEG,
      "while"	=>  EXPR_BEG,
      "yield"	=>  EXPR_END
    }
    
    ENINDENT_CLAUSE = [
      "case", "class", "def", "do", "for", "if",
      "module", "unless", "until", "while", "begin" #, "when"
    ]
    DEINDENT_CLAUSE = ["end" #, "when"
    ]

    PARCENT_LTYPE = {
      "q" => "\'",
      "Q" => "\"",
      "x" => "\`",
      "r" => "\/"
    }
    
    PARCENT_PAREN = {
      "{" => "}",
      "[" => "]",
      "<" => ">",
      "(" => ")"
    }

    def lex_init()
      @@OP = Trie.new
      @@OP.def_rules("\0", "\004", "\032"){}
      @@OP.def_rules(" ", "\t", "\f", "\r", "\13") do
	@@space_seen = TRUE
	next
      end
      @@OP.def_rule("#") do
	|op, rests|
	@@ltype = "#"
	identify_comment(rests)
      end
      @@OP.def_rule("\n") do
	print "\\n\n" if CONFIG[:DEBUG]
	if @@lex_state == EXPR_BEG || @@lex_state == EXPR_FNAME
	  @@continue = TRUE
	else
	  @@lex_state = EXPR_BEG
	end
      end
      @@OP.def_rules("*", "*=", "**=", "**") {@@lex_state = EXPR_BEG}
      @@OP.def_rules("!", "!=", "!~") {@@lex_state = EXPR_BEG}
      @@OP.def_rules("=", "==", "===", "=~", "<=>") {@@lex_state = EXPR_BEG}
      @@OP.def_rules("<", "<=", "<<") {@@lex_state = EXPR_BEG}
      @@OP.def_rules(">", ">=", ">>") {@@lex_state = EXPR_BEG}
      @@OP.def_rules("'", '"') do
	|op, rests|
	@@ltype = op
	@@quoted = op
	identify_string(rests)
      end
      @@OP.def_rules("`") do
	|op, rests|
	if @@lex_state != EXPR_FNAME
	  @@ltype = op
	  @@quoted = op
	  identify_string(rests)
	end
      end
      @@OP.def_rules('?') do
	|op, rests|
	@@lex_state = EXPR_END
	identify_question(rests)
      end
      @@OP.def_rules("&", "&&", "&=", "|", "||", "|=") do
	@@lex_state = EXPR_BEG
      end
      @@OP.def_rule("+@@", proc{@@lex_state == EXPR_FNAME}) {}
      @@OP.def_rule("-@@", proc{@@lex_state == EXPR_FNAME}) {}
      @@OP.def_rules("+=", "-=") {@@lex_state = EXPR_BEG}
      @@OP.def_rules("+", "-") do
	|op, rests|
	if @@lex_state == EXPR_ARG
	  if @@space_seen and rests[0] =~ /[0-9]/
	    identify_number(rests)
	  else
	    @@lex_state = EXPR_BEG
	  end
	elsif @@lex_state != EXPR_END and rests[0] =~ /[0-9]/
	  identify_number(rests)
	else
	  @@lex_state = EXPR_BEG
	end
      end
      @@OP.def_rule(".") do
	|op, rests|
	@@lex_state = EXPR_BEG
	if rests[0] =~ /[0-9]/
	  rests.unshift op
	  identify_number(rests)
	else
	  # handle ``obj.if'' and such
	  identify_identifier(rests, TRUE)
	  @@lex_state = EXPR_ARG
	end
      end
      @@OP.def_rules("..", "...") {@@lex_state = EXPR_BEG}

      lex_int2
    end
    
    def lex_int2
      @@OP.def_rules("]", "}", ")") do
	@@lex_state = EXPR_END
	@@indent -= 1
      end
      @@OP.def_rule(":") {|op,rests|
	identify_identifier(rests, TRUE)
      }
      @@OP.def_rule("::") {|op,rests|
	identify_identifier(rests, TRUE);
      }
      @@OP.def_rule("/") do
	|op, rests|
	if @@lex_state == EXPR_BEG || @@lex_state == EXPR_MID
	  @@ltype = op
	  @@quoted = op
	  identify_string(rests)
	elsif rests[0] == '='
	  rests.shift
	  @@lex_state = EXPR_BEG
	elsif @@lex_state == EXPR_ARG and @@space_seen and rests[0] =~ /\s/
	  @@ltype = op
	  @@quoted = op
	  identify_string(rests)
	else 
	  @@lex_state = EXPR_BEG
	end
      end
      @@OP.def_rules("^", "^=") {@@lex_state = EXPR_BEG}
      @@OP.def_rules(",", ";") {@@lex_state = EXPR_BEG}
      @@OP.def_rule("~") {@@lex_state = EXPR_BEG}
      @@OP.def_rule("~@@", proc{@@lex_state = EXPR_FNAME}) {}
      @@OP.def_rule("(") do
	@@lex_state = EXPR_BEG
	@@indent += 1
      end
      @@OP.def_rule("[]", proc{@@lex_state == EXPR_FNAME}) {}
      @@OP.def_rule("[]=", proc{@@lex_state == EXPR_FNAME}) {}
      @@OP.def_rule("[") do
	@@indent += 1
	if @@lex_state != EXPR_FNAME
	  @@lex_state = EXPR_BEG
	end
      end
      @@OP.def_rule("{") do
	@@lex_state = EXPR_BEG
	@@indent += 1
      end
      @@OP.def_rule('\\') {|op, rests| identify_escape(rests)} #')
      @@OP.def_rule('%') do
	|op, rests|
	if @@lex_state == EXPR_BEG || @@lex_state == EXPR_MID
	  identify_quotation(rests)
	elsif rests[0] == '='
	  rests.shift
	elsif @@lex_state == EXPR_ARG and @@space_seen and rests[0] =~ /\s/
	  identify_quotation(rests)
	else
	  @@lex_state = EXPR_BEG
	end
      end
      @@OP.def_rule('$') do	#'
	|op, rests|
	identify_gvar(rests)
      end
      @@OP.def_rule('@@') do
	|op, rests|
	if rests[0] =~ /[\w_]/
	  rests.unshift op
	  identify_identifier(rests)
	end
      end
      @@OP.def_rule("def", proc{|op, chrs| /\s/ =~ chrs[0]}) do 
	|op, rests|
	@@indent += 1
	@@lex_state = EXPR_END
	until rests[0] == "\n" or rests[0] == ";"
	  rests.shift
	end
      end
      @@OP.def_rule("") do
	|op, rests|
	printf "MATCH: start %s: %s\n", op, rests.inspect if CONFIG[:DEBUG]
	if rests[0] =~ /[0-9]/
	  identify_number(rests)
	elsif rests[0] =~ /[\w_]/
	  identify_identifier(rests)
	end
	printf "MATCH: end %s: %s\n", op, rests.inspect if CONFIG[:DEBUG]
      end
      
      p @@OP if CONFIG[:DEBUG]
    end
    
    def lex(l)
      chrs = l.split(//)
      tokens = []
      
      case @@ltype
      when "'", '"', '`', '/'
	identify_string(chrs)
	return if chrs.empty?
      when "#"
	identify_comment(chrs)
	return
      when "="
	if l =~ /^=end/
	  $ltype = nil
	  return
	end
      else
	if l =~ /^=begin/
	  $ltype = "="
	  return
	end
      end
      
      until chrs.empty?
	@@space_seen = FALSE
	printf "perse: %s\n", chrs.join("") if CONFIG[:DEBUG]
	@@OP.match(chrs)
	printf "lex_state: %s continue: %s\n", @@lex_state.id2name, @@continue if CONFIG[:DEBUG]
      end
    end
    
    def identify_gvar(chrs)
      @@lex_state = EXPR_END
      
      ch = chrs.shift
      case ch
      when /[_~*$?!@@\/\\;,.=:<>"]/   #"
	return
	
      when "-"
	ch = chrs.shift
	return
	
      when "&", "`", "'", "+"
	return
	
      when /[1-9]/
	chrs.unshift ch
	v = "$"
	while (ch = chrs.shift) =~ /[0-9]/
	end
	chrs.unshift ch
	return
	
      when /\w/
	chrs.unshift ch
	chrs.unshift "$"
	identify_identifier(chrs)
	return
	
      else 
	chrs.unshift ch
	return
      end
    end
    
    def identify_identifier(chrs, escaped = FALSE)
      token = ""
      token.concat chrs.shift if chrs[0] =~ /[$@@]/ or escaped
      while (ch = chrs.shift) =~ /\w|_/
	print ":", ch, ":" if CONFIG[:DEBUG]
	token.concat ch
      end
      chrs.unshift ch
      
      if ch == "!" or ch == "?"
	chrs.shift
	token.concat ch
      end
      # fix token
      
      if token =~ /^[$@@]/ or escaped
	@@lex_state = EXPR_END
	return
      end
      
      print token, "\n" if CONFIG[:DEBUG]
      if state = CLAUSE_STATE_TRANS[token]
	if @@lex_state != EXPR_BEG and token =~ /^(if|unless|while|until)/
	  # modifiers
	else
	  if ENINDENT_CLAUSE.include?(token)
	    @@indent += 1
	  elsif DEINDENT_CLAUSE.include?(token)
	    @@indent -= 1
	  end
	end
	@@lex_state = state
	return
      end
      if @@lex_state == EXPR_FNAME
	@@lex_state = EXPR_END
	if chrs[0] == '='
	  chrs.shift
	end
      elsif @@lex_state == EXPR_BEG
	@@lex_state = EXPR_ARG
      else
	@@lex_state = EXPR_END
      end
    end
    
    def identify_quotation(chrs)
      ch = chrs.shift
      if lt = PARCENT_LTYPE[ch]
	ch = chrs.shift
      else
	lt = "\""
      end
      if ch !~ /\W/
	chrs.unshift ch
	next
      end
      @@ltype = lt
      unless @@quoted = PARCENT_PAREN[ch]
	@@quoted = ch
      end
      identify_string(chrs)
    end

    def identify_number(chrs)
      @@lex_state = EXPR_END
      
      ch = chrs.shift
      case ch
      when /0/
	if (ch = chrs[0]) == "x"
	  chrs.shift
	  match = /[0-9a-f_]/
	else
	  match = /[0-7_]/
	end
	while ch = chrs.shift
	  if ch !~ match
	    chrs.unshift ch
	    break
	  end
	end
	return
      end
      
      while ch = chrs.shift
	case ch
	when /[0-9]/
	when "e", "E"
	  #	type = FLOAT
	  unless (ch = chrs.shift) == "+" or ch == "-"
	    chrs.unshift ch
	  end
	when "."
	  #	type = FLOAT
	when "_"
	else
	  chrs.unshift ch
	  return
	end
      end
    end
    
    def identify_question(chrs)
      @@lex_state = EXPR_END
      
      if chrs.shift == "\\" #"
	identify_escape(chrs)
      end
    end
    
    def identify_string(chrs)
      while ch = chrs.shift
	if @@quoted == ch
	  if @@ltype == "/"
	    if chrs[0] =~ /i|o|n|e|s/
	      chrs.shift
	    end
	  end
	  @@ltype = nil
	  @@quoted = nil
	  @@lex_state = EXPR_END
	  break
	elsif ch == '\\' #'
	  identify_escape(chrs)
	end
      end
    end
    
    def identify_comment(chrs)
      while ch = chrs.shift
	if ch == "\\" #"
	  identify_escape(chrs)
	end
	if ch == "\n"
	  @@ltype = nil
	  chrs.unshift ch
	  break
	end
      end
    end
    
    def identify_escape(chrs)
      ch = chrs.shift
      case ch
      when "\n", "\r", "\f"
	@@continue = TRUE
      when "\\", "n", "t", "r", "f", "v", "a", "e", "b" #"
      when /[0-7]/
	chrs.unshift ch
	3.times do
	  ch = chrs.shift
	  case ch
	  when /[0-7]/
	  when nil
	    break
	  else
	    chrs.unshift ch
	    break
	  end
	end
      when "x"
	2.times do
	  ch = chrs.shift
	  case ch
	  when /[0-9a-fA-F]/
	  when nil
	    break
	  else
	    chrs.unshift ch
	    break
	  end
	end
      when "M"
	if (ch = chrs.shift) != '-'
	  chrs.unshift ch
	elsif (ch = chrs.shift) == "\\" #"
	  identify_escape(chrs)
	end
	return
      when "C", "c", "^"
	if ch == "C" and (ch = chrs.shift) != "-"
	  chrs.unshift ch
	elsif (ch = chrs.shift) == "\\" #"
	  identify_escape(chrs)
	end
	return
      end
    end
  end
  
  class Trie
    extend Exception2MessageMapper
    def_exception :ErrNodeNothing, "node nothing"
    def_exception :ErrNodeAlreadyExists, "node already exists"

    class Node
      # abstract node if postproc is nil.
      def initialize(preproc = nil, postproc = nil)
	@@Tree = {}
	@@preproc = preproc
	@@postproc = postproc
      end

      attr :preproc, TRUE
      attr :postproc, TRUE
      
      def search(chrs, opt = nil)
	return self if chrs.empty?
	ch = chrs.shift
	if node = @@Tree[ch]
	  node.search(chrs, opt)
	else
	  if opt
	    chrs.unshift ch
	    self.create_subnode(chrs)
	  else
	    Trie.fail ErrNodeNothing
	  end
	end
      end
      
      def create_subnode(chrs, preproc = nil, postproc = nil)
	if chrs.empty?
	  if @@postproc
	    p node
	    Trie.fail ErrNodeAlreadyExists
	  else
	    print "Warn: change abstruct node to real node\n" if CONFIG[:DEBUG]
	    @@preproc = preproc
	    @@postproc = postproc
	  end
	  return self
	end
	
	ch = chrs.shift
	if node = @@Tree[ch]
	  if chrs.empty?
	    if node.postproc
	      p node
	      Trie.fail ErrNodeAlreadyExists
	    else
	      print "Warn: change abstruct node to real node\n" if CONFIG[:DEBUG]
	      node.preproc = preproc
	      node.postproc = postproc
	    end
	  else
	    node.create_subnode(chrs, preproc, postproc)
	  end
	else
	  if chrs.empty?
	    node = Node.new(preproc, postproc)
	  else
	    node = Node.new
	    node.create_subnode(chrs, preproc, postproc)
	  end
	  @@Tree[ch] = node
	end
	node
      end
      
      def match(chrs, op = "")
	print "match>: ", chrs, "op:", op, "\n" if CONFIG[:DEBUG]
	if chrs.empty?
	  if @@preproc.nil? || @@preproc.call(op, chrs)
	    printf "op1: %s\n", op if CONFIG[:DEBUG]
	    @@postproc.call(op, chrs)
	    ""
	  else
	    nil
	  end
	else
	  ch = chrs.shift
	  if node = @@Tree[ch]
	    if ret = node.match(chrs, op+ch)
	      return ch+ret
	    else
	      chrs.unshift ch
	      if @@postproc and @@preproc.nil? || @@preproc.call(op, chrs)
		printf "op2: %s\n", op.inspect if CONFIG[:DEBUG]
		@@postproc.call(op, chrs)
		return ""
	      else
		return nil
	      end
	    end
	  else
	    chrs.unshift ch
	    if @@postproc and @@preproc.nil? || @@preproc.call(op, chrs)
	      printf "op3: %s\n", op if CONFIG[:DEBUG]
	      @@postproc.call(op, chrs)
	      return ""
	    else
	      return nil
	    end
	  end
	end
      end
    end
    
    def initialize
      @@head = Node.new("")
    end
    
    def def_rule(token, preproc = nil, postproc = nil)
#      print node.inspect, "\n" if CONFIG[:DEBUG]
      postproc = proc if iterator?
      node = create(token, preproc, postproc)
    end
    
    def def_rules(*tokens)
      if iterator?
	p = proc
      end
      for token in tokens
	def_rule(token, nil, p)
      end
    end
    
    def preporc(token, proc)
      node = search(token)
      node.preproc=proc
    end
    
    def postproc(token)
      node = search(token, proc)
      node.postproc=proc
    end
    
    def search(token)
      @@head.search(token.split(//))
    end

    def create(token, preproc = nil, postproc = nil)
      @@head.create_subnode(token.split(//), preproc, postproc)
    end
    
    def match(token)
      token = token.split(//) if token.kind_of?(String)
      ret = @@head.match(token)
      printf "match end: %s:%s", ret, token.inspect if CONFIG[:DEBUG]
      ret
    end
    
    def inspect
      format("<Trie: @@head = %s>", @@head.inspect)
    end
  end
  
  if /^-tt(.*)$/ =~ ARGV[0]
#    Tracer.on
    case $1
    when "1"
      tr = Trie.new
      print "0: ", tr.inspect, "\n"
      tr.def_rule("=") {print "=\n"}
      print "1: ", tr.inspect, "\n"
      tr.def_rule("==") {print "==\n"}
      print "2: ", tr.inspect, "\n"
      
      print "case 1:\n"
      print tr.match("="), "\n"
      print "case 2:\n"
      print tr.match("=="), "\n"
      print "case 3:\n"
      print tr.match("=>"), "\n"
      
    when "2"
      tr = Trie.new
      print "0: ", tr.inspect, "\n"
      tr.def_rule("=") {print "=\n"}
      print "1: ", tr.inspect, "\n"
      tr.def_rule("==", proc{FALSE}) {print "==\n"}
      print "2: ", tr.inspect, "\n"
      
      print "case 1:\n"
      print tr.match("="), "\n"
      print "case 2:\n"
      print tr.match("=="), "\n"
      print "case 3:\n"
      print tr.match("=>"), "\n"
    end
    exit
  end
  
  module CONTEXT
    def _=(value)
      CONFIG[:_] = value
      eval "_=BC_APPLICATION__::CONFIG[:_]", CONFIG[:BIND]
    end
    
#    def _
#      eval "_", CONFIG[:BIND]
#    end
    
    def quit
      exit
    end
    
    def trace_load(opt = nil)
      if !opt.nil?
	CONFIG[:TRACE_LOAD] = opt
      else
	CONFIG[:TRACE_LOAD] = !CONFIG[:TRACE_LOAD]
      end
      print "Switch to load/require #{unless CONFIG[:TRACE_LOAD]; ' non';end} trace mode.\n"
      if CONFIG[:TRACE_LOAD]
	eval %{
	  class << self
	    alias load rbc_load
	    alias require rbc_require
	  end
	}
      else
	eval %{
	  class << self
	    alias load rbc_load_org
	    alias require rbc_require_org
	  end
	}
      end
      CONFIG[:TRACE_LOAD]
    end
    
    alias rbc_load_org load
    def rbc_load(file_name)
      return true if load_sub(file_name)
      raise LoadError, "No such file to load -- #{file_name}"
    end

    alias rbc_require_org require
    def rbc_require(file_name)
      rex = Regexp.new("#{Regexp.quote(file_name)}(\.o|\.rb)?")
      return false if $".find{|f| f =~ rex}

      case file_name
      when /\.rb$/
	if load_sub(file_name)
	  $".push file_name
	  return true
	end
      when /\.(so|o|sl)$/
	rbc_require_org(file_name)
      end
      
      if load_sub(f = file_name + ".rb")
	$".push f
	return true
      end
      rbc_require_org(file_name)
    end

    def load_sub(fn)
      if fn =~ /^#{Regexp.quote(File::Separator)}/
	return false unless File.exist?(fn)
	BC.new.eval_input FileInputMethod.new(fn), self, CONFIG[:BIND]
	return true
      end
      
      for path in $:
	if File.exist?(f = File.join(path, fn))
	  BC.new.eval_input FileInputMethod.new(f), self, CONFIG[:BIND]
	  return true
	end
      end
      return false
    end

    def inspect_mode(opt = nil)
      if opt
	CONFIG[:INSPECT] = opt
      else
	CONFIG[:INSPECT] = !CONFIG[:INSPECT]
      end
      print "Switch to#{unless CONFIG[:INSPECT]; ' non';end} inspect mode.\n"
      CONFIG[:INSPECT]
    end
    
    def run(bind)
      CONFIG[:BIND] = bind

      if CONFIG[:RC]
	rc = File.expand_path("~/.irbrc")
	if File.exists?(rc)
	  begin
	    load rc
	  rescue LoadError
	    print "load error: #{rc}\n"
	    print $!.type, ": ", $!, "\n"
	    for err in $@@[0, $@@.size - 2]
	      print "\t", err, "\n"
	    end
	  end 
	end
      end
  
      if CONFIG[:TRACE_LOAD]
	trace_load true
      end
  
      for m in CONFIG[:LOAD_MODULES]
	begin
	  require m
	rescue LoadError
	  print $@@[0], ":", $!.type, ": ", $!, "\n"
	end
      end

      if !$0.equal?(CONFIG[0])
	io = FileInputMethod.new($0)
      elsif defined? Readline
	io = ReadlineInputMethod.new
      else
	io = StdioInputMethod.new
      end

      BC.new.eval_input io, self, CONFIG[:BIND]
    end
  end
  
  class InputMethod
    attr :prompt, TRUE
    
    def gets
    end
    public :gets
  end
  
  class StdioInputMethod < InputMethod
    def gets
      print @@prompt
      $stdin.gets
    end
  end
  
  class FileInputMethod < InputMethod
    def initialize(file)
      @@io = open(file)
    end

    def gets
      l = @@io.gets
      print @@prompt, l
      l
    end
  end

  if CONFIG[:USE_READLINE]
    begin
      require "readline"
      print "use readline module\n"
      class ReadlineInputMethod < InputMethod
	include Readline 
	def gets
	  if l = readline(@@prompt, TRUE)
	    l + "\n"
	  else
	    l
	  end
	end
      end
    rescue LoadError
      CONFIG[:USE_READLINE] = FALSE
    end
  end
end

extend BC_APPLICATION__::CONTEXT
run(binding)

@


1.4
log
@2000-05-17
@
text
@@


1.4.2.1
log
@Obsoleted by IRB.
@
text
@@


1.3
log
@2000-05-12
@
text
@d130 1
a130 1
	  rescue
d932 1
a932 1
	  rescue
d949 1
a949 1
	rescue
d1007 1
a1007 1
    rescue
@


1.2
log
@1.4.0
@
text
@d416 1
a416 1
      when /[_~*$?!@@/\\;,.=:<>"]/   #"
@


1.2.2.1
log
@991208-repack
@
text
@@


1.1
log
@Initial revision
@
text
@d4 3
a6 3
#   	$Release Version: 0.6 $
#   	$Revision: 1.2 $
#   	$Date: 1997/11/27 13:46:06 $
d14 9
a22 8
#	-d		    ¥Ç¥Ð¥Ã¥°¥â¡¼¥É(ÍøÍÑ¤·¤Ê¤¤Êý¤¬ÎÉ¤¤¤Ç¤·¤ç¤¦)
#	-m		    bc¥â¡¼¥É(Ê¬¿ô, ¹ÔÎó¤Î·×»»¤¬¤Ç¤­¤Þ¤¹)
#	-r load-module	    ruby -r ¤ÈÆ±¤¸
#	--inspect	    ·ë²Ì½ÐÎÏ¤Ëinspect¤òÍÑ¤¤¤ë(bc¥â¡¼¥É°Ê³°¤Ï¥Ç
#			    ¥Õ¥©¥ë¥È). 
#	--noinspect	    ·ë²Ì½ÐÎÏ¤Ëinspect¤òÍÑ¤¤¤Ê¤¤.
#	--noreadline	    readline¥é¥¤¥Ö¥é¥ê¤òÍøÍÑ¤·¤Ê¤¤(¥Ç¥Õ¥©¥ë¥È
#			    ¤Ç¤Ïreadline¥é¥¤¥Ö¥é¥ê¤òÍøÍÑ¤·¤è¤¦¤È¤¹¤ë).
d24 5
a28 6
# ÄÉ²Ã private method:
#   exit, quit		    ½ªÎ»¤¹¤ë.
#   inspect(sw = nil)	    ¥¤¥ó¥¹¥Ú¥¯¥È¥â¡¼¥É¤Î¥È¥°¥ë
#   trace_load(sw = nil)    load/require»þ¤Ërbc¤ÎfileÆÉ¤ß¹þ¤ßµ¡Ç½¤òÍÑ
#			    ¤¤¤ë¥â¡¼¥É¤Î¥¹¥¤¥Ã¥Á(¥Ç¥Õ¥©¥ë¥È¤Ï¥È¥ì¡¼¥¹
#			    ¥â¡¼¥É)
d35 1
a35 1
  RCS_ID='-$Header: /home/keiju/var/src/var.lib/ruby/ruby/RCS/rbc.rb,v 1.2 1997/11/27 13:46:06 keiju Exp keiju $-'
a39 3
  $DEBUG = FALSE
  $INSPECT = nil
  
d45 4
a48 1
  CONFIG[:TRACE_LOAD] = TRUE
d53 1
a53 1
      $DEBUG = TRUE
d61 3
d72 1
a72 1
      BC.fail UnrecognizedSwitch, opt
d110 1
a110 1
	  print @@quoted.inspect, "\n" if $DEBUG
d126 1
a126 1
	      print (cont._=eval(line, bind)).inspect, "\n"
d128 1
a128 1
	      print (cont._=eval(line, bind)), "\n"
d188 2
a189 1
    DEINDENT_CLAUSE = ["end"]
d204 1
a204 1
    
d218 1
a218 1
	print "\\n\n" if $DEBUG
d227 3
a229 3
      @@OP.def_rules("=", "==", "===", "=~", "=>") {@@lex_state = EXPR_BEG}
      @@OP.def_rules("<", "<=", "<=>", "<<", "<=") {@@lex_state = EXPR_BEG}
      @@OP.def_rules(">", ">=", ">>", ">=") {@@lex_state = EXPR_BEG}
d275 4
d282 1
a282 1
      
d291 6
a296 2
      @@OP.def_rule(":") {}
      @@OP.def_rule("::") {@@lex_state = EXPR_BEG}
d347 1
a347 1
      @@OP.def_rule('$') do
d358 8
d368 1
a368 1
	printf "match: start %s: %s", op, rests.inspect if $DEBUG
d374 1
a374 1
	printf "match: end %s: %s", op, rests.inspect if $DEBUG
d376 2
d405 1
a405 1
	printf "perse: %s\n", chrs.join("") if $DEBUG
d407 1
a407 1
	printf "lex_state: %s continue: %s\n", @@lex_state.id2name, @@continue if $DEBUG
d446 1
a446 1
    def identify_identifier(chrs)
d448 1
a448 1
      token.concat chrs.shift if chrs[0] =~ /[$@@]/
d450 1
a450 1
	print ":", ch, ":" if $DEBUG
d461 1
a461 1
      if token =~ /^[$@@]/
d466 1
a466 1
      print token, "\n" if $DEBUG
d469 1
a469 1
	  # ½¤¾þ»Ò
d643 1
a643 1
      # postproc¤¬¤Ê¤±¤ì¤ÐÃê¾Ý¥Î¡¼¥É, nil¤¸¤ã¤Ê¤±¤ì¤Ð¶ñ¾Ý¥Î¡¼¥É
d649 3
a651 8
      
      def preproc(p)
	@@preproc = p
      end
      
      def postproc(p)
	@@postproc = p
      end
d669 12
d684 8
a691 1
	    Trie.fail ErrNodeAlreadyExists
d708 1
a708 1
	print "match: ", chrs, ":", op, "\n" if $DEBUG
d711 1
a711 1
	    printf "op1: %s\n", op if $DEBUG
a721 5
	    elsif @@postproc and @@preproc.nil? || @@preproc.call(op, chrs)
	      chrs.unshift ch
	      printf "op2: %s\n", op if $DEBUG
	      @@postproc.call(op, chrs)
	      return ""
d724 7
a730 1
	      return nil
d733 1
d735 1
a735 2
	      printf "op3: %s\n", op if $DEBUG
	      chrs.unshift ch
a738 1
	      chrs.unshift ch
d751 3
a753 8
      node = search(token, :CREATE)
#      print node.inspect, "\n" if $DEBUG
      node.preproc(preproc)
      if iterator?
	node.postproc(proc)
      elsif postproc
	node.postproc(postproc)
      end
d765 1
a765 1
    def preporc(token)
d767 1
a767 1
      node.preproc proc
d771 2
a772 2
      node = search(token)
      node.postproc proc
d775 6
a780 2
    def search(token, opt = nil)
      @@head.search(token.split(//), opt)
d786 1
a786 1
      printf "match end: %s:%s", ret, token.inspect if $DEBUG
d833 2
a834 1
      @@_ = value
d837 3
a839 3
    def _
      @@_
    end
d846 2
a847 2
      if opt
	@@Trace_require = opt
d849 1
a849 1
	@@Trace_require = !@@Trace_require
d851 2
a852 2
      print "Switch to load/require #{unless @@Trace_require; ' non';end} trace mode.\n"
      if @@Trace_require
d867 1
a867 1
      @@Trace_require
d884 1
a884 1
	  $:.push file_name
d888 1
a888 1
	require_org(file_name)
d892 2
a893 1
	  $:.push f
d895 1
a895 1
      require(file_name)
d914 1
a914 1
    def inspect(opt = nil)
d918 1
a918 1
	CONFIG[:INSPECT] = !$INSPECT
d920 2
a921 2
      print "Switch to#{unless $INSPECT; ' non';end} inspect mode.\n"
      $INSPECT
d924 2
a925 2
    def run
      CONFIG[:BIND] = proc
d927 15
d953 1
a953 1
  
d1014 2
a1015 1
run{}
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@d4 3
a6 3
#   	$Release Version: 0.8 $
#   	$Revision: 1.8 $
#   	$Date: 1998/03/11 05:43:00 $
d14 8
a21 9
#	-d		    debug mode (not recommended)
#	-f		    does not read ~/.irbrc
#	-m		    bc mode (rational/matrix calc)
#	-r load-module	    same as `ruby -r'
#	--inspect	    use inspect for result output
#			    (default for non-bc mode)
#	--noinspect	    does not use inspect for result output
#	--noreadline	    does not use readline library
#			    (default: try to use readline)
d23 6
a28 5
# additional private method (as function):
#   exit, quit		    terminate the interpreter
#   inspect_mode(sw = nil)  toggle inspect mode
#   trace_load(sw = nil)    change trace mode for file loading using
#			    load/require.  (default: trace-mode on)
d35 1
a35 1
  RCS_ID='-$Id: rbc.rb,v 1.8 1998/03/11 05:43:00 keiju Exp keiju $-'
d40 3
d48 1
a48 4
  CONFIG[:TRACE_LOAD] = FALSE
  CONFIG[:RC] = TRUE

  CONFIG[:DEBUG] = FALSE
d53 1
a53 1
      CONFIG[:DEBUG] = TRUE
a60 3
    when "-f"
      opt = ARGV.shift
      CONFIG[:RC] = FALSE
d69 1
a69 1
      BC_APPLICATION__.fail UnrecognizedSwitch, opt
d107 1
a107 1
	  print @@quoted.inspect, "\n" if CONFIG[:DEBUG]
d123 1
a123 1
	      print((cont._=eval(line, bind)).inspect, "\n")
d125 1
a125 1
	      print((cont._=eval(line, bind)), "\n")
d185 1
a185 2
    DEINDENT_CLAUSE = ["end" #, "when"
    ]
d200 1
a200 1

d214 1
a214 1
	print "\\n\n" if CONFIG[:DEBUG]
d223 3
a225 3
      @@OP.def_rules("=", "==", "===", "=~", "<=>") {@@lex_state = EXPR_BEG}
      @@OP.def_rules("<", "<=", "<<") {@@lex_state = EXPR_BEG}
      @@OP.def_rules(">", ">=", ">>") {@@lex_state = EXPR_BEG}
a270 4
	else
	  # obj.if ¤Ê¤É¤ÎÂÐ±þ
	  identify_identifier(rests, TRUE)
	  @@lex_state = EXPR_ARG
d274 1
a274 1

d283 2
a284 6
      @@OP.def_rule(":") {|op,rests|
	identify_identifier(rests, TRUE)
      }
      @@OP.def_rule("::") {|op,rests|
	identify_identifier(rests, TRUE);
      }
a345 8
      @@OP.def_rule("def", proc{|op, chrs| /\s/ =~ chrs[0]}) do 
	|op, rests|
	@@indent += 1
	@@lex_state = EXPR_END
	until rests[0] == "\n" or rests[0] == ";"
	  rests.shift
	end
      end
d348 1
a348 1
	printf "MATCH: start %s: %s\n", op, rests.inspect if CONFIG[:DEBUG]
d354 1
a354 1
	printf "MATCH: end %s: %s\n", op, rests.inspect if CONFIG[:DEBUG]
a355 2
      
      p @@OP if CONFIG[:DEBUG]
d383 1
a383 1
	printf "perse: %s\n", chrs.join("") if CONFIG[:DEBUG]
d385 1
a385 1
	printf "lex_state: %s continue: %s\n", @@lex_state.id2name, @@continue if CONFIG[:DEBUG]
d424 1
a424 1
    def identify_identifier(chrs, escaped = FALSE)
d426 1
a426 1
      token.concat chrs.shift if chrs[0] =~ /[$@@]/ or escaped
d428 1
a428 1
	print ":", ch, ":" if CONFIG[:DEBUG]
d439 1
a439 1
      if token =~ /^[$@@]/ or escaped
d444 1
a444 1
      print token, "\n" if CONFIG[:DEBUG]
d627 8
a634 3

      attr :preproc, TRUE
      attr :postproc, TRUE
a651 12
	if chrs.empty?
	  if @@postproc
	    p node
	    Trie.fail ErrNodeAlreadyExists
	  else
	    print "Warn: change abstruct node to real node\n" if CONFIG[:DEBUG]
	    @@preproc = preproc
	    @@postproc = postproc
	  end
	  return self
	end
	
d655 1
a655 8
	    if node.postproc
	      p node
	      Trie.fail ErrNodeAlreadyExists
	    else
	      print "Warn: change abstruct node to real node\n" if CONFIG[:DEBUG]
	      node.preproc = preproc
	      node.postproc = postproc
	    end
d672 1
a672 1
	print "match>: ", chrs, "op:", op, "\n" if CONFIG[:DEBUG]
d675 1
a675 1
	    printf "op1: %s\n", op if CONFIG[:DEBUG]
d686 5
d693 1
a693 7
	      if @@postproc and @@preproc.nil? || @@preproc.call(op, chrs)
		printf "op2: %s\n", op.inspect if CONFIG[:DEBUG]
		@@postproc.call(op, chrs)
		return ""
	      else
		return nil
	      end
a695 1
	    chrs.unshift ch
d697 2
a698 1
	      printf "op3: %s\n", op if CONFIG[:DEBUG]
d702 1
d715 8
a722 3
#      print node.inspect, "\n" if CONFIG[:DEBUG]
      postproc = proc if iterator?
      node = create(token, preproc, postproc)
d734 1
a734 1
    def preporc(token, proc)
d736 1
a736 1
      node.preproc=proc
d740 2
a741 2
      node = search(token, proc)
      node.postproc=proc
d744 2
a745 6
    def search(token)
      @@head.search(token.split(//))
    end

    def create(token, preproc = nil, postproc = nil)
      @@head.create_subnode(token.split(//), preproc, postproc)
d751 1
a751 1
      printf "match end: %s:%s", ret, token.inspect if CONFIG[:DEBUG]
d798 1
a798 2
      CONFIG[:_] = value
      eval "_=BC_APPLICATION__::CONFIG[:_]", CONFIG[:BIND]
d801 3
a803 3
#    def _
#      eval "_", CONFIG[:BIND]
#    end
d810 2
a811 2
      if !opt.nil?
	CONFIG[:TRACE_LOAD] = opt
d813 1
a813 1
	CONFIG[:TRACE_LOAD] = !CONFIG[:TRACE_LOAD]
d815 2
a816 2
      print "Switch to load/require #{unless CONFIG[:TRACE_LOAD]; ' non';end} trace mode.\n"
      if CONFIG[:TRACE_LOAD]
d831 1
a831 1
      CONFIG[:TRACE_LOAD]
d848 1
a848 1
	  $".push file_name
d852 1
a852 1
	rbc_require_org(file_name)
d856 1
a856 2
	$".push f
	return true
d858 1
a858 1
      rbc_require_org(file_name)
d877 1
a877 1
    def inspect_mode(opt = nil)
d881 1
a881 1
	CONFIG[:INSPECT] = !CONFIG[:INSPECT]
d883 2
a884 2
      print "Switch to#{unless CONFIG[:INSPECT]; ' non';end} inspect mode.\n"
      CONFIG[:INSPECT]
d887 2
a888 2
    def run(bind)
      CONFIG[:BIND] = bind
a889 15
      if CONFIG[:RC]
	rc = File.expand_path("~/.irbrc")
	if File.exists?(rc)
	  begin
	    load rc
	  rescue
	    print "load error: #{rc}\n"
	    print $!.type, ": ", $!, "\n"
	    for err in $@@[0, $@@.size - 2]
	      print "\t", err, "\n"
	    end
	  end 
	end
      end
  
d901 1
a901 1

d962 1
a962 2
run(binding)

@


1.1.1.2.2.1
log
@990209
@
text
@d276 1
a276 1
	  # handle ``obj.if'' and such
d347 1
a347 1
      @@OP.def_rule('$') do	#'
d469 1
a469 1
	  # modifiers
d643 1
a643 1
      # abstract node if postproc is nil.
@


1.1.1.1.2.1
log
@*** empty log message ***
@
text
@d5 2
a6 2
#   	$Revision: 1.1.1.1 $
#   	$Date: 1998/01/16 04:14:56 $
d35 1
a35 1
  RCS_ID='-$Header: /home/cvsroot/ruby/sample/rbc.rb,v 1.1.1.1 1998/01/16 04:14:56 matz Exp $-'
@


1.1.1.1.2.2
log
@*** empty log message ***
@
text
@d5 2
a6 2
#   	$Revision: 1.1.1.1.2.1 $
#   	$Date: 1998/01/16 12:36:10 $
d35 1
a35 1
  RCS_ID='-$Header: /home/cvsroot/ruby/sample/rbc.rb,v 1.1.1.1.2.1 1998/01/16 12:36:10 matz Exp $-'
d123 1
a123 1
	      print((cont._=eval(line, bind)).inspect, "\n")
d125 1
a125 1
	      print((cont._=eval(line, bind)), "\n")
@


1.1.1.1.2.3
log
@-ko for keiju's files
@
text
@d5 2
a6 2
#   	$Revision: 1.2 $
#   	$Date: 1997/11/27 13:46:06 $
d35 1
a35 1
  RCS_ID='-$Header: /home/keiju/var/src/var.lib/ruby/ruby/RCS/rbc.rb,v 1.2 1997/11/27 13:46:06 keiju Exp keiju $-'
@


1.1.1.1.2.4
log
@1.1b7 pre
@
text
@d14 8
a21 8
#	-d		    debug mode(not encouraged)
#	-m		    bc mode(calculate rational, matrix)
#	-r load-module	    same as `ruby -r'
#	--inspect	    use inspect for output.
#                           (default except in bc mode)
#	--noinspect	    do not use inspect for output.
#	--noreadline	    do not use readline library.
#                           (rbc tries to use readline as default).
d23 6
a28 5
# additional private methods:
#   exit, quit		    quit
#   inspect(sw = nil)	    toggle inspect mode
#   trace_load(sw = nil)    toggle trace mode for load/require.
#			    (default is trace mode on)
d35 2
a36 3

  RCS_ID=%q$Id: rbc.rb,v 1.2 1997/11/27 13:46:06 keiju Exp keiju $

d189 1
a189 1
      "Q" => "\"", #"
d335 1
a335 1
      @@OP.def_rule('$') do #'
d447 1
a447 1
	  # $B=$>~;R(B
d475 1
a475 1
	lt = "\"" #"
d621 1
a621 1
      # postproc$B$,$J$1$l$PCj>]%N!<%I(B, nil$B$8$c$J$1$l$P6q>]%N!<%I(B
@


1.1.1.1.2.5
log
@*** empty log message ***
@
text
@d852 1
a852 1
	rbc_require_org(file_name)
@


1.1.1.1.2.6
log
@dyna_var,regex,line cotinuation
@
text
@d4 3
a6 3
#   	$Release Version: 0.7 $
#   	$Revision: 1.4 $
#   	$Date: 1998/02/23 03:56:16 $
d14 8
a21 9
#	-d		    ¥Ç¥Ð¥Ã¥°¥â¡¼¥É(ÍøÍÑ¤·¤Ê¤¤Êý¤¬ÎÉ¤¤¤Ç¤·¤ç¤¦)
#	-f		    ~/.irbrc ¤òÆÉ¤ß¹þ¤Þ¤Ê¤¤.
#	-m		    bc¥â¡¼¥É(Ê¬¿ô, ¹ÔÎó¤Î·×»»¤¬¤Ç¤­¤Þ¤¹)
#	-r load-module	    ruby -r ¤ÈÆ±¤¸.
#	--inspect	    ·ë²Ì½ÐÎÏ¤Ëinspect¤òÍÑ¤¤¤ë(bc¥â¡¼¥É°Ê³°¤Ï¥Ç
#			    ¥Õ¥©¥ë¥È). 
#	--noinspect	    ·ë²Ì½ÐÎÏ¤Ëinspect¤òÍÑ¤¤¤Ê¤¤.
#	--noreadline	    readline¥é¥¤¥Ö¥é¥ê¤òÍøÍÑ¤·¤Ê¤¤(¥Ç¥Õ¥©¥ë¥È
#			    ¤Ç¤Ïreadline¥é¥¤¥Ö¥é¥ê¤òÍøÍÑ¤·¤è¤¦¤È¤¹¤ë).
d23 5
a27 6
# ÄÉ²Ã private method:
#   exit, quit		    ½ªÎ»¤¹¤ë.
#   inspect(sw = nil)	    ¥¤¥ó¥¹¥Ú¥¯¥È¥â¡¼¥É¤Î¥È¥°¥ë
#   trace_load(sw = nil)    load/require»þ¤Ërbc¤ÎfileÆÉ¤ß¹þ¤ßµ¡Ç½¤òÍÑ
#			    ¤¤¤ë¥â¡¼¥É¤Î¥¹¥¤¥Ã¥Á(¥Ç¥Õ¥©¥ë¥È¤Ï¥È¥ì¡¼¥¹
#			    ¥â¡¼¥É)
d34 3
a36 2
  RCS_ID='-$Id: rbc.rb,v 1.4 1998/02/23 03:56:16 keiju Exp keiju $-'
  
d40 3
a48 3
  CONFIG[:RC] = TRUE

  CONFIG[:DEBUG] = FALSE
d53 1
a53 1
      CONFIG[:DEBUG] = TRUE
a60 3
    when "-f"
      opt = ARGV.shift
      CONFIG[:RC] = FALSE
d69 1
a69 1
      BC_APPLICATION__.fail UnrecognizedSwitch, opt
d107 1
a107 1
	  print @@quoted.inspect, "\n" if CONFIG[:DEBUG]
d185 1
a185 2
    DEINDENT_CLAUSE = ["end" #, "when"
    ]
d189 1
a189 1
      "Q" => "\"",
d214 1
a214 1
	print "\\n\n" if CONFIG[:DEBUG]
d335 1
a335 1
      @@OP.def_rule('$') do
d348 1
a348 1
	printf "match: start %s: %s", op, rests.inspect if CONFIG[:DEBUG]
d354 1
a354 1
	printf "match: end %s: %s", op, rests.inspect if CONFIG[:DEBUG]
d383 1
a383 1
	printf "perse: %s\n", chrs.join("") if CONFIG[:DEBUG]
d385 1
a385 1
	printf "lex_state: %s continue: %s\n", @@lex_state.id2name, @@continue if CONFIG[:DEBUG]
d428 1
a428 1
	print ":", ch, ":" if CONFIG[:DEBUG]
d444 1
a444 1
      print token, "\n" if CONFIG[:DEBUG]
d447 1
a447 1
	  # ½¤¾þ»Ò
d475 1
a475 1
	lt = "\""
d621 1
a621 1
      # postproc¤¬¤Ê¤±¤ì¤ÐÃê¾Ý¥Î¡¼¥É, nil¤¸¤ã¤Ê¤±¤ì¤Ð¶ñ¾Ý¥Î¡¼¥É
d672 1
a672 1
	print "match: ", chrs, ":", op, "\n" if CONFIG[:DEBUG]
d675 1
a675 1
	    printf "op1: %s\n", op if CONFIG[:DEBUG]
d688 1
a688 1
	      printf "op2: %s\n", op if CONFIG[:DEBUG]
d697 1
a697 1
	      printf "op3: %s\n", op if CONFIG[:DEBUG]
d716 1
a716 1
#      print node.inspect, "\n" if CONFIG[:DEBUG]
d751 1
a751 1
      printf "match end: %s:%s", ret, token.inspect if CONFIG[:DEBUG]
d848 1
a848 1
	  $".push file_name
d856 1
a856 2
	$".push f
	return true
d858 1
a858 1
      rbc_require_org(file_name)
d881 1
a881 1
	CONFIG[:INSPECT] = !CONFIG[:INSPECT]
d883 2
a884 2
      print "Switch to#{unless CONFIG[:INSPECT]; ' non';end} inspect mode.\n"
      CONFIG[:INSPECT]
d887 2
a888 2
    def run(bind)
      CONFIG[:BIND] = bind
a889 15
      if CONFIG[:RC]
	rc = File.expand_path("~/.irbrc")
	if File.exists?(rc)
	  begin
	    load rc
	  rescue
	    print "load error: #{rc}\n"
	    print $!.type, ": ", $!, "\n"
	    for err in $@@[0, $@@.size - 2]
	      print "\t", err, "\n"
	    end
	  end 
	end
      end
  
d901 1
a901 1

d962 1
a962 2
run(binding)

@


1.1.1.1.2.7
log
@*** empty log message ***
@
text
@d4 3
a6 3
#   	$Release Version: 0.8 $
#   	$Revision: 1.7 $
#   	$Date: 1998/02/27 03:45:51 $
d36 1
a36 1
  RCS_ID='-$Id: rbc.rb,v 1.7 1998/02/27 03:45:51 keiju Exp keiju $-'
d205 1
a205 1

d228 3
a230 3
      @@OP.def_rules("=", "==", "===", "=~", "<=>") {@@lex_state = EXPR_BEG}
      @@OP.def_rules("<", "<=", "<<") {@@lex_state = EXPR_BEG}
      @@OP.def_rules(">", ">=", ">>") {@@lex_state = EXPR_BEG}
a275 4
	else
	  # obj.if ¤Ê¤É¤ÎÂÐ±þ
	  identify_identifier(rests, TRUE)
	  @@lex_state = EXPR_ARG
d279 1
a279 1

d288 2
a289 6
      @@OP.def_rule(":") {|op,rests|
	identify_identifier(rests, TRUE)
      }
      @@OP.def_rule("::") {|op,rests|
	identify_identifier(rests, TRUE);
      }
a350 8
      @@OP.def_rule("def", proc{|op, chrs| /\s/ =~ chrs[0]}) do 
	|op, rests|
	@@indent += 1
	@@lex_state = EXPR_END
	until rests[0] == "\n" or rests[0] == ";"
	  rests.shift
	end
      end
d353 1
a353 1
	printf "MATCH: start %s: %s\n", op, rests.inspect if CONFIG[:DEBUG]
d359 1
a359 1
	printf "MATCH: end %s: %s\n", op, rests.inspect if CONFIG[:DEBUG]
a360 2
      
      p @@OP if CONFIG[:DEBUG]
d429 1
a429 1
    def identify_identifier(chrs, escaped = FALSE)
d431 1
a431 1
      token.concat chrs.shift if chrs[0] =~ /[$@@]/ or escaped
d444 1
a444 1
      if token =~ /^[$@@]/ or escaped
d632 8
a639 3

      attr :preproc, TRUE
      attr :postproc, TRUE
a656 12
	if chrs.empty?
	  if @@postproc
	    p node
	    Trie.fail ErrNodeAlreadyExists
	  else
	    print "Warn: change abstruct node to real node\n" if CONFIG[:DEBUG]
	    @@preproc = preproc
	    @@postproc = postproc
	  end
	  return self
	end
	
d660 1
a660 8
	    if node.postproc
	      p node
	      Trie.fail ErrNodeAlreadyExists
	    else
	      print "Warn: change abstruct node to real node\n" if CONFIG[:DEBUG]
	      node.preproc = preproc
	      node.postproc = postproc
	    end
d677 1
a677 1
	print "match>: ", chrs, "op:", op, "\n" if CONFIG[:DEBUG]
d691 5
d698 1
a698 7
	      if @@postproc and @@preproc.nil? || @@preproc.call(op, chrs)
		printf "op2: %s\n", op.inspect if CONFIG[:DEBUG]
		@@postproc.call(op, chrs)
		return ""
	      else
		return nil
	      end
a700 1
	    chrs.unshift ch
d703 1
d707 1
d720 1
d722 6
a727 2
      postproc = proc if iterator?
      node = create(token, preproc, postproc)
d739 1
a739 1
    def preporc(token, proc)
d741 1
a741 1
      node.preproc=proc
d745 2
a746 2
      node = search(token, proc)
      node.postproc=proc
d749 2
a750 6
    def search(token)
      @@head.search(token.split(//))
    end

    def create(token, preproc = nil, postproc = nil)
      @@head.create_subnode(token.split(//), preproc, postproc)
@


1.1.1.1.2.8
log
@speed up patch 2
@
text
@d5 2
a6 2
#   	$Revision: 1.8 $
#   	$Date: 1998/03/11 05:43:00 $
d26 1
a26 1
#   inspect_mode(sw = nil)  ¥¤¥ó¥¹¥Ú¥¯¥È¥â¡¼¥É¤Î¥È¥°¥ë
d36 1
a36 1
  RCS_ID='-$Id: rbc.rb,v 1.8 1998/03/11 05:43:00 keiju Exp keiju $-'
d46 1
a46 1
  CONFIG[:TRACE_LOAD] = FALSE
d834 1
a834 2
      CONFIG[:_] = value
      eval "_=BC_APPLICATION__::CONFIG[:_]", CONFIG[:BIND]
d837 3
a839 3
#    def _
#      eval "_", CONFIG[:BIND]
#    end
d846 2
a847 2
      if !opt.nil?
	CONFIG[:TRACE_LOAD] = opt
d849 1
a849 1
	CONFIG[:TRACE_LOAD] = !CONFIG[:TRACE_LOAD]
d851 2
a852 2
      print "Switch to load/require #{unless CONFIG[:TRACE_LOAD]; ' non';end} trace mode.\n"
      if CONFIG[:TRACE_LOAD]
d867 1
a867 1
      CONFIG[:TRACE_LOAD]
d914 1
a914 1
    def inspect_mode(opt = nil)
@


1.1.1.1.2.9
log
@*** empty log message ***
@
text
@d14 9
a22 9
#	-d		    debug mode (not recommended)
#	-f		    does not read ~/.irbrc
#	-m		    bc mode (rational/matrix calc)
#	-r load-module	    same as `ruby -r'
#	--inspect	    use inspect for result output
#			    (default for non-bc mode)
#	--noinspect	    does not use inspect for result output
#	--noreadline	    does not use readline library
#			    (default: try to use readline)
d24 6
a29 5
# additional private method (as function):
#   exit, quit		    terminate the interpreter
#   inspect_mode(sw = nil)  toggle inspect mode
#   trace_load(sw = nil)    change trace mode for file loading using
#			    load/require.  (default: trace-mode on)
@

