head	1.73;
access;
symbols
	v1_6_7:1.31.2.13
	v1_6_6:1.31.2.13
	v1_6_5:1.31.2.11
	v1_6_4:1.31.2.10
	v1_7_1:1.45
	v1_6_4_preview4:1.31.2.9
	v1_6_4_preview3:1.31.2.9
	v1_6_4_preview2:1.31.2.9
	v1_6_4_preview1:1.31.2.9
	v1_6_3:1.31.2.6
	ruby_m17n:1.31.0.4
	ruby_1_6:1.31.0.2
	v1_6_2:1.31
	v1_6_1:1.23
	v1_6_0:1.18
	v1_4_6:1.4.2.7
	v1_4_5:1.4.2.4
	v1_4_4:1.4.2.4
	ruby_1_4_3:1.4.2.1
	ruby1_4_3:1.4.2.1
	v1_4_3:1.4.2.1
	v1_5_0:1.5
	ruby_1_4_3_pre1:1.4.2.1
	ruby_1_4:1.4.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.4
	v1_3_6_repack:1.1.1.1.2.4
	v1_3_6:1.1.1.1.2.4
	v1_3_5:1.1.1.1.2.4
	v1_3_4_990625:1.1.1.1.2.4
	v1_3_4_990624:1.1.1.1.2.4
	v1_3_4_990611:1.1.1.1.2.3
	v1_3_4_990531:1.1.1.1.2.3
	v1_3_3_990518:1.1.1.1.2.1
	v1_3_3_990513:1.1.1.1.2.1
	v1_3_3_990507:1.1.1.1.2.1
	v1_3_1_990225:1.1.1.1.2.1
	v1_3_1_990224:1.1.1.1.2.1
	v1_3_1_990215:1.1.1.1.2.1
	v1_3_1_990212:1.1.1.1.2.1
	v1_3_1_990210:1.1.1.1.2.1
	v1_3_1_:1.1.1.1.2.1
	v1_3_1_990209:1.1.1.1.2.1
	v1_3_1_990205:1.1.1.1.2.1
	v1_3_1_990203:1.1.1.1.2.1
	v1_3_1_990201:1.1.1.1.2.1
	v1_3_1"_990201:1.1.1.1.2.1
	v1_3_1_990128:1.1.1.1.2.1
	v1_3_1_990127:1.1.1.1.2.1
	v1_3_1_990126:1.1.1.1.2.1
	ruby_1_3:1.1.1.1.0.2
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_1d1:1.1.0.2;
locks; strict;
comment	@ * @;


1.73
date	2002.10.12.14.47.07;	author nobu;	state Exp;
branches;
next	1.72;

1.72
date	2002.10.10.21.07.16;	author nobu;	state Exp;
branches;
next	1.71;

1.71
date	2002.10.01.15.26.39;	author nobu;	state Exp;
branches;
next	1.70;

1.70
date	2002.09.29.09.31.45;	author nobu;	state Exp;
branches;
next	1.69;

1.69
date	2002.09.28.21.39.57;	author usa;	state Exp;
branches;
next	1.68;

1.68
date	2002.09.15.13.02.09;	author H_Konishi;	state Exp;
branches;
next	1.67;

1.67
date	2002.09.11.08.50.13;	author usa;	state Exp;
branches;
next	1.66;

1.66
date	2002.09.08.10.06.40;	author usa;	state Exp;
branches;
next	1.65;

1.65
date	2002.08.28.08.56.18;	author nobu;	state Exp;
branches;
next	1.64;

1.64
date	2002.08.28.02.39.29;	author usa;	state Exp;
branches;
next	1.63;

1.63
date	2002.08.20.13.03.22;	author H_Konishi;	state Exp;
branches;
next	1.62;

1.62
date	2002.07.30.06.34.27;	author eban;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.28.18.26.01;	author usa;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.27.14.57.10;	author usa;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.14.12.21.50;	author H_Konishi;	state Exp;
branches;
next	1.58;

1.58
date	2002.06.11.01.27.48;	author H_Konishi;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.29.10.22.19;	author H_Konishi;	state Exp;
branches;
next	1.56;

1.56
date	2002.04.28.09.14.20;	author eban;	state Exp;
branches;
next	1.55;

1.55
date	2002.04.19.07.33.18;	author eban;	state Exp;
branches;
next	1.54;

1.54
date	2002.03.15.10.48.57;	author nobu;	state Exp;
branches;
next	1.53;

1.53
date	2001.11.26.07.59.01;	author usa;	state Exp;
branches;
next	1.52;

1.52
date	2001.11.14.18.41.46;	author usa;	state Exp;
branches;
next	1.51;

1.51
date	2001.11.13.16.14.42;	author usa;	state Exp;
branches;
next	1.50;

1.50
date	2001.11.13.07.50.20;	author usa;	state Exp;
branches;
next	1.49;

1.49
date	2001.11.13.03.59.20;	author usa;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.25.01.47.47;	author usa;	state Exp;
branches;
next	1.47;

1.47
date	2001.08.24.05.44.20;	author usa;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.15.18.51.58;	author usa;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.12.06.47.24;	author usa;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.06.15.06.00;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2001.04.01.16.22.13;	author eban;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.21.15.17.32;	author eban;	state Exp;
branches;
next	1.41;

1.41
date	2001.03.21.14.12.09;	author eban;	state Exp;
branches;
next	1.40;

1.40
date	2001.03.21.04.18.10;	author eban;	state Exp;
branches;
next	1.39;

1.39
date	2001.03.20.23.10.05;	author usa;	state Exp;
branches;
next	1.38;

1.38
date	2001.03.20.14.50.43;	author eban;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.05.08.28.50;	author eban;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.24.13.19.13;	author eban;	state Exp;
branches;
next	1.35;

1.35
date	2001.02.17.15.17.10;	author usa;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.09.15.02.14;	author usa;	state Exp;
branches;
next	1.33;

1.33
date	2001.02.08.09.19.27;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.14.09.20.21;	author usa;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.22.09.00.23;	author matz;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2000.12.08.07.10.38;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.20.01.24.28;	author eban;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.16.07.24.20;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.14.07.10.31;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.13.10.11.31;	author eban;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.31.08.37.47;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.02.07.48.42;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.27.09.11.13;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.25.13.39.58;	author eban;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.25.07.00.55;	author eban;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.18.09.54.47;	author eban;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.01.03.31.05;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.15.07.11.13;	author eban;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.15.06.22.49;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.09.04.26.06;	author eban;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.24.09.58.10;	author eban;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.06.07.21.26;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.05.16.01.49;	author eban;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.28.08.27.03;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.29.02.10.22;	author eban;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.13.16.12.27;	author eban;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.18.06.59.36;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.01.03.12.21;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.08.05.00.25;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.05.04.37.27;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.11.08.03.57.01;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.09.22.04.30.11;	author matz;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.09.18.04.48.51;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.20;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	99.01.20.04.45.32;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.20.04.59.38;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.01.26.10.08.18;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.05.25.08.26.20;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.05.31.09.13.33;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.06.24.04.24.08;	author matz;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.08.11.07.24.11;	author matz;	state Exp;
branches;
next	;

1.4.2.1
date	99.11.09.03.57.28;	author matz;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2000.01.05.04.41.20;	author matz;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2000.01.17.08.24.22;	author matz;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2000.02.18.06.58.58;	author matz;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2000.06.27.05.42.14;	author matz;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2000.07.10.08.01.49;	author matz;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2000.07.24.09.56.41;	author eban;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2000.08.09.04.46.33;	author eban;	state Exp;
branches;
next	;

1.31.2.1
date	2001.02.02.15.48.20;	author usa;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2001.02.08.09.18.04;	author matz;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2001.02.09.15.07.52;	author usa;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2001.02.24.13.19.06;	author eban;	state Exp;
branches;
next	1.31.2.5;

1.31.2.5
date	2001.03.05.08.29.01;	author eban;	state Exp;
branches;
next	1.31.2.6;

1.31.2.6
date	2001.03.20.14.50.25;	author eban;	state Exp;
branches;
next	1.31.2.7;

1.31.2.7
date	2001.03.21.14.11.30;	author eban;	state Exp;
branches;
next	1.31.2.8;

1.31.2.8
date	2001.03.21.15.18.05;	author eban;	state Exp;
branches;
next	1.31.2.9;

1.31.2.9
date	2001.04.01.16.21.26;	author eban;	state Exp;
branches;
next	1.31.2.10;

1.31.2.10
date	2001.05.25.22.22.02;	author usa;	state Exp;
branches;
next	1.31.2.11;

1.31.2.11
date	2001.08.24.05.45.55;	author usa;	state Exp;
branches;
next	1.31.2.12;

1.31.2.12
date	2001.09.25.01.45.57;	author usa;	state Exp;
branches;
next	1.31.2.13;

1.31.2.13
date	2001.11.13.08.32.19;	author usa;	state Exp;
branches;
next	1.31.2.14;

1.31.2.14
date	2002.03.04.18.42.18;	author usa;	state Exp;
branches;
next	1.31.2.15;

1.31.2.15
date	2002.04.22.04.56.51;	author eban;	state Exp;
branches;
next	1.31.2.16;

1.31.2.16
date	2002.04.28.09.15.02;	author eban;	state Exp;
branches;
next	1.31.2.17;

1.31.2.17
date	2002.04.28.10.55.53;	author eban;	state Exp;
branches;
next	1.31.2.18;

1.31.2.18
date	2002.06.27.15.51.49;	author usa;	state Exp;
branches;
next	1.31.2.19;

1.31.2.19
date	2002.09.08.10.25.43;	author usa;	state Exp;
branches;
next	1.31.2.20;

1.31.2.20
date	2002.09.09.11.43.29;	author usa;	state Exp;
branches;
next	1.31.2.21;

1.31.2.21
date	2002.09.15.12.56.44;	author H_Konishi;	state Exp;
branches;
next	1.31.2.22;

1.31.2.22
date	2002.10.01.15.25.49;	author nobu;	state Exp;
branches;
next	1.31.2.23;

1.31.2.23
date	2002.10.10.21.07.11;	author nobu;	state Exp;
branches;
next	;


desc
@@


1.73
log
@* win32/win32.c (rb_w32_putc): wrong condition to fill or flush on
  bccwin32.  [ruby-win32:408]
@
text
@/*
 *  Copyright (c) 1993, Intergraph Corporation
 *
 *  You may distribute under the terms of either the GNU General Public
 *  License or the Artistic License, as specified in the perl README file.
 *
 *  Various Unix compatibility functions and NT specific functions.
 *
 *  Some of this code was derived from the MSDOS port(s) and the OS/2 port.
 *
 */

#include "ruby.h"
#include "rubysig.h"
#include <fcntl.h>
#include <process.h>
#include <sys/stat.h>
/* #include <sys/wait.h> */
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <assert.h>

#include <windows.h>
#include <winbase.h>
#include <wincon.h>
#ifdef __MINGW32__
#include <mswsock.h>
#endif
#include "win32.h"
#include "win32/dir.h"
#ifndef index
#define index(x, y) strchr((x), (y))
#endif
#define isdirsep(x) ((x) == '/' || (x) == '\\')

#undef stat
#undef fclose
#undef close
#undef setsockopt

#ifndef bool
#define bool int
#endif

#ifdef _M_IX86
# define WIN95 1
#else
# undef  WIN95
#endif

#ifdef __BORLANDC__
#  define _filbuf _fgetc
#  define _flsbuf _fputc
#  define enough_to_get(n) (--(n) >= 0)
#  define enough_to_put(n) (++(n) < 0)
#else
#  define enough_to_get(n) (--(n) >= 0)
#  define enough_to_put(n) (--(n) >= 0)
#endif

#if HAVE_WSAWAITFORMULTIPLEEVENTS
# define USE_INTERRUPT_WINSOCK
#endif

#if USE_INTERRUPT_WINSOCK
# define WaitForMultipleEvents WSAWaitForMultipleEvents
# define CreateSignal() (HANDLE)WSACreateEvent()
# define SetSignal(ev) WSASetEvent(ev)
# define ResetSignal(ev) WSAResetEvent(ev)
#else  /* USE_INTERRUPT_WINSOCK */
# define WaitForMultipleEvents WaitForMultipleObjectsEx
# define CreateSignal() CreateEvent(NULL, FALSE, FALSE, NULL);
# define SetSignal(ev) SetEvent(ev)
# define ResetSignal(ev) (void)0
#endif /* USE_INTERRUPT_WINSOCK */

#ifdef WIN32_DEBUG
#define Debug(something) something
#else
#define Debug(something) /* nothing */
#endif

#define TO_SOCKET(x)	_get_osfhandle(x)

bool NtSyncProcess = TRUE;

static struct ChildRecord *CreateChild(char *, SECURITY_ATTRIBUTES *, HANDLE, HANDLE, HANDLE);
static bool NtHasRedirection (char *);
static int valid_filename(char *s);
static void StartSockets ();
static char *str_grow(struct RString *str, size_t new_size);
static DWORD wait_events(HANDLE event, DWORD timeout);
#ifndef __BORLANDC__
static int rb_w32_open_osfhandle(long osfhandle, int flags);
#else
#define rb_w32_open_osfhandle(osfhandle, flags) _open_osfhandle(osfhandle, flags)
#endif

char *NTLoginName;

#ifdef WIN95
DWORD Win32System = (DWORD)-1;

static DWORD
IdOS(void)
{
    static OSVERSIONINFO osver;

    if (osver.dwPlatformId != Win32System) {
	memset(&osver, 0, sizeof(OSVERSIONINFO));
	osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osver);
	Win32System = osver.dwPlatformId;
    }
    return (Win32System);
}

static int 
IsWin95(void) {
    return (IdOS() == VER_PLATFORM_WIN32_WINDOWS);
}

static int
IsWinNT(void) {
    return (IdOS() == VER_PLATFORM_WIN32_NT);
}
#else
# define IsWinNT() TRUE
# define IsWin95() FALSE
#endif

/* main thread constants */
static struct {
    HANDLE handle;
    DWORD id;
} main_thread;

/* interrupt stuff */
static HANDLE interrupted_event;

HANDLE GetCurrentThreadHandle(void)
{
    static HANDLE current_process_handle = NULL;
    HANDLE h;

    if (!current_process_handle)
	current_process_handle = GetCurrentProcess();
    if (!DuplicateHandle(current_process_handle, GetCurrentThread(),
			 current_process_handle, &h,
			 0, FALSE, DUPLICATE_SAME_ACCESS))
	return NULL;
    return h;
}

/* simulate flock by locking a range on the file */


#define LK_ERR(f,i) ((f) ? (i = 0) : (errno = GetLastError()))
#define LK_LEN      0xffff0000

static VALUE
flock_winnt(VALUE self, int argc, VALUE* argv)
{
    OVERLAPPED o;
    int i = -1;
    const HANDLE fh = (HANDLE)self;
    const int oper = argc;

    memset(&o, 0, sizeof(o));

    switch(oper) {
      case LOCK_SH:		/* shared lock */
	LK_ERR(LockFileEx(fh, 0, 0, LK_LEN, 0, &o), i);
	break;
      case LOCK_EX:		/* exclusive lock */
	LK_ERR(LockFileEx(fh, LOCKFILE_EXCLUSIVE_LOCK, 0, LK_LEN, 0, &o), i);
	break;
      case LOCK_SH|LOCK_NB:	/* non-blocking shared lock */
	LK_ERR(LockFileEx(fh, LOCKFILE_FAIL_IMMEDIATELY, 0, LK_LEN, 0, &o), i);
	break;
      case LOCK_EX|LOCK_NB:	/* non-blocking exclusive lock */
	LK_ERR(LockFileEx(fh,
			  LOCKFILE_EXCLUSIVE_LOCK|LOCKFILE_FAIL_IMMEDIATELY,
			  0, LK_LEN, 0, &o), i);
	if (errno == EDOM)
	    errno = EWOULDBLOCK;
	break;
      case LOCK_UN:		/* unlock lock */
	if (UnlockFileEx(fh, 0, LK_LEN, 0, &o)) {
	    i = 0;
	    if (errno == EDOM)
		errno = EWOULDBLOCK;
	}
	else {
	    /* GetLastError() must returns `ERROR_NOT_LOCKED' */
	    errno = EWOULDBLOCK;
	}
	break;
      default:            /* unknown */
	errno = EINVAL;
	break;
    }
    return i;
}

#ifdef WIN95
static VALUE
flock_win95(VALUE self, int argc, VALUE* argv)
{
    int i = -1;
    const HANDLE fh = (HANDLE)self;
    const int oper = argc;

    switch(oper) {
      case LOCK_EX:
	while(i == -1) {
	    LK_ERR(LockFile(fh, 0, 0, LK_LEN, 0), i);
	    if (errno != EDOM && i == -1) break;
	}
	break;
      case LOCK_EX | LOCK_NB:
	LK_ERR(LockFile(fh, 0, 0, LK_LEN, 0), i);
	if (errno == EDOM)
	    errno = EWOULDBLOCK;
	break;
      case LOCK_UN:
	LK_ERR(UnlockFile(fh, 0, 0, LK_LEN, 0), i);
	if (errno == EDOM)
	    errno = EWOULDBLOCK;
	break;
      default:
	errno = EINVAL;
	break;
    }
    return i;
}
#endif

#undef LK_ERR
#undef LK_LEN

int
flock(int fd, int oper)
{
#ifdef WIN95
    static asynchronous_func_t locker = NULL;

    if (!locker) {
	if (IsWinNT())
	    locker = flock_winnt;
	else
	    locker = flock_win95;
    }
#else
    const asynchronous_func_t locker = flock_winnt;
#endif

    return rb_w32_asynchronize(locker,
			      (VALUE)_get_osfhandle(fd), oper, NULL,
			      (DWORD)-1);
}

//#undef const
//FILE *fdopen(int, const char *);

//
// Initialization stuff
//
void
NtInitialize(int *argc, char ***argv)
{

    WORD version;
    int ret;

    //
    // subvert cmd.exe's feeble attempt at command line parsing
    //
    *argc = NtMakeCmdVector((char *)GetCommandLine(), argv, TRUE);

    //
    // Now set up the correct time stuff
    //

    tzset();

    // Initialize Winsock
    StartSockets();
}

char *getlogin()
{
    char buffer[200];
    DWORD len = 200;
    extern char *NTLoginName;

    if (NTLoginName == NULL) {
	if (GetUserName(buffer, &len)) {
	    NTLoginName = ALLOC_N(char, len+1);
	    strncpy(NTLoginName, buffer, len);
	    NTLoginName[len] = '\0';
	}
	else {
	    NTLoginName = "<Unknown>";
	}
    }
    return NTLoginName;
}

#define MAXCHILDNUM 256	/* max num of child processes */

struct ChildRecord {
    HANDLE hProcess;	/* process handle */
    pid_t pid;		/* process id */
} ChildRecord[MAXCHILDNUM];

#define FOREACH_CHILD(v) do { \
    struct ChildRecord* v; \
    for (v = ChildRecord; v < ChildRecord + sizeof(ChildRecord) / sizeof(ChildRecord[0]); ++v)
#define END_FOREACH_CHILD } while (0)

static struct ChildRecord *
FindFirstChildSlot(void)
{
    FOREACH_CHILD(child) {
	if (child->pid) return child;
    } END_FOREACH_CHILD;
    return NULL;
}

static struct ChildRecord *
FindChildSlot(pid_t pid)
{

    FOREACH_CHILD(child) {
	if (child->pid == pid) {
	    return child;
	}
    } END_FOREACH_CHILD;
    return NULL;
}

static void
CloseChildHandle(struct ChildRecord *child)
{
    HANDLE h = child->hProcess;
    child->hProcess = NULL;
    child->pid = 0;
    CloseHandle(h);
}

static struct ChildRecord *
FindFreeChildSlot(void)
{
    FOREACH_CHILD(child) {
	if (!child->pid) {
	    child->pid = -1;	/* lock the slot */
	    child->hProcess = NULL;
	    return child;
	}
    } END_FOREACH_CHILD;
    return NULL;
}


int SafeFree(char **vec, int vecc)
{
    //   vec
    //   |
    //   V       ^---------------------V
    //   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    //   |   |       | ....  |  NULL |   | ..... |\0 |   | ..... |\0 |...
    //   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    //   |-  elements+1             -| ^ 1st element   ^ 2nd element

	char *p;

	p = (char *)vec;
	free(p);

	return 0;
}


static char *szInternalCmds[] = {
  "append",
  "break",
  "call",
  "cd",
  "chdir",
  "cls",
  "copy",
  "date",
  "del",
  "dir",
  "echo",
  "erase",
  "label",
  "md",
  "mkdir",
  "path",
  "pause",
  "rd",
  "rem",
  "ren",
  "rename",
  "rmdir",
  "set",
  "start",
  "time",
  "type",
  "ver",
  "vol",
  NULL
};

int
isInternalCmd(char *cmd)
{
    int i, fRet=0;
    char **vec;
    int vecc = NtMakeCmdVector(cmd, &vec, FALSE);

    if (vecc == 0)
	return 0;
    for( i = 0; szInternalCmds[i] ; i++){
	if(!strcasecmp(szInternalCmds[i], vec[0])){
	    fRet = 1;
	    break;
	}
    }

    SafeFree(vec, vecc);

    return fRet;
}


SOCKET
rb_w32_get_osfhandle(int fh)
{
    return _get_osfhandle(fh);
}

pid_t
pipe_exec(char *cmd, int mode, FILE **fpr, FILE **fpw)
{
    struct ChildRecord* child;
    HANDLE hReadIn, hReadOut;
    HANDLE hWriteIn, hWriteOut;
    HANDLE hSavedStdIn, hSavedStdOut;
    HANDLE hDupInFile, hDupOutFile;
    HANDLE hCurProc;
    SECURITY_ATTRIBUTES sa;
    BOOL fRet;
    BOOL reading, writing;
    int fdin, fdout;
    int pipemode;
    char modes[3];
    int ret;

    /* Figure out what we're doing... */
    writing = (mode & (O_WRONLY | O_RDWR)) ? TRUE : FALSE;
    reading = ((mode & O_RDWR) || !writing) ? TRUE : FALSE;
    pipemode = (mode & O_BINARY) ? O_BINARY : O_TEXT;

    sa.nLength              = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = TRUE;

    /* create pipe, save parent's STDIN/STDOUT and redirect them for child */
    RUBY_CRITICAL(do {
	ret = -1;
	hCurProc = GetCurrentProcess();
	if (reading) {
	    fRet = CreatePipe(&hReadIn, &hReadOut, &sa, 2048L);
	    if (!fRet) {
		errno = GetLastError();
		break;
	    }
	    hSavedStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	    if (!SetStdHandle(STD_OUTPUT_HANDLE, hReadOut) ||
		!DuplicateHandle(hCurProc, hReadIn, hCurProc, &hDupInFile, 0,
				 FALSE, DUPLICATE_SAME_ACCESS)) {
		errno = GetLastError();
		CloseHandle(hReadIn);
		CloseHandle(hReadOut);
		CloseHandle(hCurProc);
		break;
	    }
	    CloseHandle(hReadIn);
	}
	if (writing) {
	    fRet = CreatePipe(&hWriteIn, &hWriteOut, &sa, 2048L);
	    if (!fRet) {
		errno = GetLastError();
		if (reading) {
		    CloseHandle(hDupInFile);
		    CloseHandle(hReadOut);
		}
		break;
	    }
	    hSavedStdIn = GetStdHandle(STD_INPUT_HANDLE);
	    if (!SetStdHandle(STD_INPUT_HANDLE, hWriteIn) ||
		!DuplicateHandle(hCurProc, hWriteOut, hCurProc, &hDupOutFile, 0,
				 FALSE, DUPLICATE_SAME_ACCESS)) {
		errno = GetLastError();
		CloseHandle(hWriteIn);
		CloseHandle(hWriteOut);
		CloseHandle(hCurProc);
		if (reading) {
		    CloseHandle(hDupInFile);
		    CloseHandle(hReadOut);
		}
		break;
	    }
	    CloseHandle(hWriteOut);
	}
	CloseHandle(hCurProc);

	/* create child process */
	child = CreateChild(cmd, &sa, NULL, NULL, NULL);
	if (!child) {
	    if (reading) {
		SetStdHandle(STD_OUTPUT_HANDLE, hSavedStdOut);
		CloseHandle(hReadOut);
		CloseHandle(hDupInFile);
	    }
	    if (writing) {
		SetStdHandle(STD_INPUT_HANDLE, hSavedStdIn);
		CloseHandle(hWriteIn);
		CloseHandle(hDupOutFile);
	    }
	    break;
	}

	/* restore STDIN/STDOUT */
	if (reading) {
	    if (!SetStdHandle(STD_OUTPUT_HANDLE, hSavedStdOut)) {
		errno = GetLastError();
		CloseChildHandle(child);
		CloseHandle(hReadOut);
		CloseHandle(hDupInFile);
		if (writing) {
		    CloseHandle(hWriteIn);
		    CloseHandle(hDupOutFile);
		}
		break;
	    }
	}
	if (writing) {
	    if (!SetStdHandle(STD_INPUT_HANDLE, hSavedStdIn)) {
		errno = GetLastError();
		CloseChildHandle(child);
		CloseHandle(hWriteIn);
		CloseHandle(hDupOutFile);
		if (reading) {
		    CloseHandle(hReadOut);
		    CloseHandle(hDupInFile);
		}
		break;
	    }
	}

	if (reading) {
	    fdin = rb_w32_open_osfhandle((long)hDupInFile,
					 (_O_RDONLY | pipemode));
	    CloseHandle(hReadOut);
	    if (fdin == -1) {
		CloseHandle(hDupInFile);
		if (writing) {
		    CloseHandle(hWriteIn);
		    CloseHandle(hDupOutFile);
		}
		CloseChildHandle(child);
		break;
	    }
	}
	if (writing) {
	    fdout = rb_w32_open_osfhandle((long)hDupOutFile,
					  (_O_WRONLY | pipemode));
	    CloseHandle(hWriteIn);
	    if (fdout == -1) {
		CloseHandle(hDupOutFile);
		if (reading) {
		    _close(fdin);
		}
		CloseChildHandle(child);
		break;
	    }
	}

	if (reading) {
	    sprintf(modes, "r%s", pipemode == O_BINARY ? "b" : "");
	    if ((*fpr = (FILE *)fdopen(fdin, modes)) == NULL) {
		_close(fdin);
		if (writing) {
		    _close(fdout);
		}
		CloseChildHandle(child);
		break;
	    }
	}
	if (writing) {
	    sprintf(modes, "w%s", pipemode == O_BINARY ? "b" : "");
	    if ((*fpw = (FILE *)fdopen(fdout, modes)) == NULL) {
		_close(fdout);
		if (reading) {
		    fclose(*fpr);
		}
		CloseChildHandle(child);
		break;
	    }
	}
	ret = child->pid;
    } while (0));

    return ret;
}

extern VALUE rb_last_status;

int
do_spawn(cmd)
char *cmd;
{
    struct ChildRecord *child = CreateChild(cmd, NULL, NULL, NULL, NULL);
    if (!child) {
	return -1;
    }
    rb_syswait(child->pid);
    return NUM2INT(rb_last_status);
}

static struct ChildRecord *
CreateChild(char *cmd, SECURITY_ATTRIBUTES *psa, HANDLE hInput, HANDLE hOutput, HANDLE hError)
{
    BOOL fRet;
    DWORD  dwCreationFlags;
    STARTUPINFO aStartupInfo;
    PROCESS_INFORMATION aProcessInformation;
    SECURITY_ATTRIBUTES sa;
    char *shell;
    struct ChildRecord *child;

    child = FindFreeChildSlot();
    if (!child) {
	errno = EAGAIN;
	return NULL;
    }

    if (!psa) {
	sa.nLength              = sizeof (SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle       = TRUE;
	psa = &sa;
    }

    memset(&aStartupInfo, 0, sizeof (STARTUPINFO));
    memset(&aProcessInformation, 0, sizeof (PROCESS_INFORMATION));
    aStartupInfo.cb = sizeof (STARTUPINFO);
    if (hInput || hOutput || hError) {
	aStartupInfo.dwFlags = STARTF_USESTDHANDLES;
	if (hInput) {
	    aStartupInfo.hStdInput  = hInput;
	}
	else {
	    aStartupInfo.hStdInput  = GetStdHandle(STD_INPUT_HANDLE);
	}
	if (hOutput) {
	    aStartupInfo.hStdOutput = hOutput;
	}
	else {
	    aStartupInfo.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
	}
	if (hError) {
	    aStartupInfo.hStdError = hError;
	}
	else {
	    aStartupInfo.hStdError = GetStdHandle(STD_ERROR_HANDLE);
	}
    }

    dwCreationFlags = (NORMAL_PRIORITY_CLASS);

    if ((shell = getenv("RUBYSHELL")) && NtHasRedirection(cmd)) {
	char *tmp = ALLOCA_N(char, strlen(shell) + strlen(cmd) + sizeof (" -c "));
	sprintf(tmp, "%s -c %s", shell, cmd);
	cmd = tmp;
    }
    else if ((shell = getenv("COMSPEC")) &&
	     (NtHasRedirection(cmd) || isInternalCmd(cmd))) {
	char *tmp = ALLOCA_N(char, strlen(shell) + strlen(cmd) + sizeof (" /c "));
	sprintf(tmp, "%s /c %s", shell, cmd);
	cmd = tmp;
    }
    else {
	shell = NULL;
    }

    RUBY_CRITICAL({
	fRet = CreateProcess(shell, cmd, psa, psa,
			     psa->bInheritHandle, dwCreationFlags, NULL, NULL,
			     &aStartupInfo, &aProcessInformation);
	errno = GetLastError();
    });

    if (!fRet) {
	child->pid = 0;		/* release the slot */
	return NULL;
    }

    CloseHandle(aProcessInformation.hThread);

    child->hProcess = aProcessInformation.hProcess;
    child->pid = (pid_t)aProcessInformation.dwProcessId;

    if (!IsWinNT()) {
	/* On Win9x, make pid positive similarly to cygwin and perl */
	child->pid = -child->pid;
    }

    return child;
}

typedef struct _NtCmdLineElement {
    struct _NtCmdLineElement *next, *prev;
    char *str;
    int len;
    int flags;
} NtCmdLineElement;

//
// Possible values for flags
//

#define NTGLOB   0x1	// element contains a wildcard
#define NTMALLOC 0x2	// string in element was malloc'ed
#define NTSTRING 0x4	// element contains a quoted string

NtCmdLineElement *NtCmdHead = NULL, *NtCmdTail = NULL;

void
NtFreeCmdLine(void)
{
    NtCmdLineElement *ptr;
    
    while(NtCmdHead) {
	ptr = NtCmdHead;
	NtCmdHead = NtCmdHead->next;
	free(ptr);
    }
    NtCmdHead = NtCmdTail = NULL;
}

//
// This function expands wild card characters that were spotted 
// during the parse phase. The idea here is to call FindFirstFile and
// FindNextFile with the wildcard pattern specified, and splice in the
// resulting list of new names. If the wildcard pattern doesn't match 
// any existing files, just leave it in the list.
//
typedef struct {
    NtCmdLineElement *head;
    NtCmdLineElement *tail;
} ListInfo;

static void
insert(const char *path, VALUE vinfo)
{
    NtCmdLineElement *tmpcurr;
    ListInfo *listinfo = (ListInfo *)vinfo;

    tmpcurr = ALLOC(NtCmdLineElement);
    MEMZERO(tmpcurr, NtCmdLineElement, 1);
    tmpcurr->len = strlen(path);
    tmpcurr->str = ALLOC_N(char, tmpcurr->len + 1);
    tmpcurr->flags |= NTMALLOC;
    strcpy(tmpcurr->str, path);
    if (listinfo->tail) {
	listinfo->tail->next = tmpcurr;
	tmpcurr->prev = listinfo->tail;
	listinfo->tail = tmpcurr;
    }
    else {
	listinfo->tail = listinfo->head = tmpcurr;
    }
}

#ifdef HAVE_SYS_PARAM_H
# include <sys/param.h>
#else
# define MAXPATHLEN 512
#endif

void
NtCmdGlob (NtCmdLineElement *patt)
{
    ListInfo listinfo;
    char buffer[MAXPATHLEN], *buf = buffer;
    char *p;

    listinfo.head = listinfo.tail = 0;

    if (patt->len >= MAXPATHLEN)
	buf = ruby_xmalloc(patt->len + 1);

    strncpy (buf, patt->str, patt->len);
    buf[patt->len] = '\0';
    for (p = buf; *p; p = CharNext(p))
	if (*p == '\\')
	    *p = '/';
    rb_globi(buf, insert, (VALUE)&listinfo);
    if (buf != buffer)
	free(buf);

    if (listinfo.head && listinfo.tail) {
	listinfo.head->prev = patt->prev;
	listinfo.tail->next = patt->next;
	if (listinfo.head->prev)
	    listinfo.head->prev->next = listinfo.head;
	if (listinfo.tail->next)
	    listinfo.tail->next->prev = listinfo.tail;
    }
    if (patt->flags & NTMALLOC)
	free(patt->str);
    // free(patt);  //TODO:  memory leak occures here. we have to fix it.
}

// 
// Check a command string to determine if it has I/O redirection
// characters that require it to be executed by a command interpreter
//

static bool
NtHasRedirection (char *cmd)
{
    int inquote = 0;
    char quote = '\0';
    char *ptr ;

    //
    // Scan the string, looking for redirection (< or >) or pipe 
    // characters (|) that are not in a quoted string
    //

    for (ptr = cmd; *ptr; ptr++) {

	switch (*ptr) {

	  case '\'':
	  case '\"':
	    if (inquote) {
		if (quote == *ptr) {
		    inquote = 0;
		    quote = '\0';
		}
	    }
	    else {
		quote = *ptr;
		inquote++;
	    }
	    break;

	  case '>':
	  case '<':
	  case '|':

	    if (!inquote)
		return TRUE;
	}
    }
    return FALSE;
}


int 
NtMakeCmdVector (char *cmdline, char ***vec, int InputCmd)
{
    int cmdlen = strlen(cmdline);
    int done, instring, globbing, quoted, len;
    int newline, need_free = 0, i;
    int elements, strsz;
    int slashes = 0;
    char *ptr, *base, *buffer;
    char **vptr;
    char quote;
    NtCmdLineElement *curr;

    //
    // just return if we don't have a command line
    //

    if (cmdlen == 0) {
	*vec = NULL;
	return 0;
    }

    cmdline = strdup(cmdline);

    //
    // strip trailing white space
    //

    ptr = cmdline+(cmdlen - 1);
    while(ptr >= cmdline && ISSPACE(*ptr))
        --ptr;
    *++ptr = '\0';


    //
    // Ok, parse the command line, building a list of CmdLineElements.
    // When we've finished, and it's an input command (meaning that it's
    // the processes argv), we'll do globing and then build the argument 
    // vector.
    // The outer loop does one interation for each element seen. 
    // The inner loop does one interation for each character in the element.
    //

    for (done = 0, ptr = cmdline; *ptr;) {

	//
	// zap any leading whitespace
	//

	while(ISSPACE(*ptr))
	    ptr++;
	base = ptr;

	for (done = newline = globbing = instring = quoted = 0; 
	     *ptr && !done; ptr++) {

	    //
	    // Switch on the current character. We only care about the
	    // white-space characters, the  wild-card characters, and the
	    // quote characters.
	    //

	    switch (*ptr) {
	      case '\\':
	        if (ptr[1] == '"') ptr++;
	        break;
	      case ' ':
	      case '\t':
#if 0
	      case '/':  // have to do this for NT/DOS option strings

		//
		// check to see if we're parsing an option switch
		//

		if (*ptr == '/' && base == ptr)
		    continue;
#endif
		//
		// if we're not in a string, then we're finished with this
		// element
		//

		if (!instring)
		    done++;
		break;

	      case '*':
	      case '?':

		// 
		// record the fact that this element has a wildcard character
		// N.B. Don't glob if inside a single quoted string
		//

		if (!(instring && quote == '\''))
		    globbing++;
		break;

	      case '\n':

		//
		// If this string contains a newline, mark it as such so
		// we can replace it with the two character sequence "\n"
		// (cmd.exe doesn't like raw newlines in strings...sigh).
		//

		newline++;
		break;

	      case '\'':
	      case '\"':

		//
		// if we're already in a string, see if this is the
		// terminating close-quote. If it is, we're finished with 
		// the string, but not neccessarily with the element.
		// If we're not already in a string, start one.
		//

		if (instring) {
		    if (quote == *ptr) {
			instring = 0;
			quote = '\0';
		    }
		}
		else {
		    instring++;
		    quote = *ptr;
		    quoted++;
		}
		break;
	    }
	}

	//
	// need to back up ptr by one due to last increment of for loop
	// (if we got out by seeing white space)
	//

	if (*ptr)
	    ptr--;

	//
	// when we get here, we've got a pair of pointers to the element,
	// base and ptr. Base points to the start of the element while ptr
	// points to the character following the element.
	//

	curr = ALLOC(NtCmdLineElement);
	memset (curr, 0, sizeof(*curr));

	len = ptr - base;

	//
	// if it's an input vector element and it's enclosed by quotes, 
	// we can remove them.
	//

	if (InputCmd && (base[0] == '\"' && base[len-1] == '\"')) {
	    char *p;
	    base++;
	    len -= 2;
	    base[len] = 0;
	    for (p = base; p < base + len; p++) {
		if ((p[0] == '\\' || p[0] == '\"') && p[1] == '"') {
		    strcpy(p, p + 1);
		    len--;
		}
	    }
	}
	else if (InputCmd && (base[0] == '\'' && base[len-1] == '\'')) {
	    base++;
	    len -= 2;
	}

	curr->str = base;
	curr->len = len;
	curr->flags |= (globbing ? NTGLOB : 0);

	//
	// Now put it in the list of elements
	//
	if (NtCmdTail) {
	    NtCmdTail->next = curr;
	    curr->prev = NtCmdTail;
	    NtCmdTail = curr;
	}
	else {
	    NtCmdHead = NtCmdTail = curr;
	}
    }

    if (InputCmd) {

	//
	// When we get here we've finished parsing the command line. Now 
	// we need to run the list, expanding any globbing patterns.
	//
	
	for(curr = NtCmdHead; curr; curr = curr->next) {
	    if (curr->flags & NTGLOB) {
		NtCmdGlob(curr);
	    }
	}
    }

    //
    // Almost done! 
    // Count up the elements, then allocate space for a vector of pointers
    // (argv) and a string table for the elements.
    // 

    for (elements = 0, strsz = 0, curr = NtCmdHead; curr; curr = curr->next) {
	elements++;
	strsz += (curr->len + 1);
    }

    len = (elements+1)*sizeof(char *) + strsz;
    buffer = ALLOC_N(char, len);
    
    memset (buffer, 0, len);

    //
    // make vptr point to the start of the buffer
    // and ptr point to the area we'll consider the string table.
    //
    //   buffer (*vec)
    //   |
    //   V       ^---------------------V
    //   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    //   |   |       | ....  | NULL  |   | ..... |\0 |   | ..... |\0 |...
    //   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    //   |-  elements+1             -| ^ 1st element   ^ 2nd element

    vptr = (char **) buffer;

    ptr = buffer + (elements+1) * sizeof(char *);

    for (curr =  NtCmdHead; curr;  curr = curr->next) {
	strncpy (ptr, curr->str, curr->len);
	ptr[curr->len] = '\0';
	*vptr++ = ptr;
	ptr += curr->len + 1;
    }
    NtFreeCmdLine();
    *vec = (char **) buffer;
    free(cmdline);
    return elements;
}

//
// UNIX compatible directory access functions for NT
//

#define PATHLEN 1024

//
// The idea here is to read all the directory names into a string table
// (separated by nulls) and when one of the other dir functions is called
// return the pointer to the current file name. 
//

DIR *
rb_w32_opendir(const char *filename)
{
    DIR               *p;
    long               len;
    long               idx;
    char               scannamespc[PATHLEN];
    char	      *scanname = scannamespc;
    struct stat	       sbuf;
    struct _finddata_t fd;
    long               fh;

    //
    // check to see if we've got a directory
    //

    if ((rb_w32_stat (filename, &sbuf) < 0 ||
#ifdef __BORLANDC__
	 (unsigned short)(sbuf.st_mode)
#else
	 sbuf.st_mode
#endif
	 & _S_IFDIR == 0) &&
	(!ISALPHA(filename[0]) || filename[1] != ':' || filename[2] != '\0' ||
	((1 << (filename[0] & 0x5f) - 'A') & GetLogicalDrives()) == 0)) {
	return NULL;
    }

    //
    // Get us a DIR structure
    //

    p = xcalloc(sizeof(DIR), 1);
    if (p == NULL)
	return NULL;
    
    //
    // Create the search pattern
    //

    strcpy(scanname, filename);

    if (index("/\\:", *CharPrev(scanname, scanname + strlen(scanname))) == NULL)
	strcat(scanname, "/*");
    else
	strcat(scanname, "*");

    //
    // do the FindFirstFile call
    //

    fh = _findfirst(scanname, &fd);
    if (fh == -1) {
	return NULL;
    }

    //
    // now allocate the first part of the string table for the
    // filenames that we find.
    //

    idx = strlen(fd.name)+1;
    p->start = ALLOC_N(char, idx);
    strcpy(p->start, fd.name);
    p->nfiles++;
    
    //
    // loop finding all the files that match the wildcard
    // (which should be all of them in this directory!).
    // the variable idx should point one past the null terminator
    // of the previous string found.
    //
    while (_findnext(fh, &fd) == 0) {
	len = strlen(fd.name);

	//
	// bump the string table size by enough for the
	// new name and it's null terminator 
	//

	#define Renew(x, y, z) (x = (z *)realloc(x, y))

	Renew (p->start, idx+len+1, char);
	if (p->start == NULL) {
            rb_fatal ("opendir: malloc failed!\n");
	}
	strcpy(&p->start[idx], fd.name);
	p->nfiles++;
	idx += len+1;
    }
    _findclose(fh);
    p->size = idx;
    p->curr = p->start;
    return p;
}


//
// Readdir just returns the current string pointer and bumps the
// string pointer to the next entry.
//

struct direct  *
rb_w32_readdir(DIR *dirp)
{
    int         len;
    static int  dummy = 0;

    if (dirp->curr) {

	//
	// first set up the structure to return
	//

	len = strlen(dirp->curr);
	strcpy(dirp->dirstr.d_name, dirp->curr);
	dirp->dirstr.d_namlen = len;

	//
	// Fake inode
	//
	dirp->dirstr.d_ino = dummy++;

	//
	// Now set up for the next call to readdir
	//

	dirp->curr += len + 1;
	if (dirp->curr >= (dirp->start + dirp->size)) {
	    dirp->curr = NULL;
	}

	return &(dirp->dirstr);

    } else
	return NULL;
}

//
// Telldir returns the current string pointer position
//

long
rb_w32_telldir(DIR *dirp)
{
	return (long) dirp->curr;	/* ouch! pointer to long cast */
}

//
// Seekdir moves the string pointer to a previously saved position
// (Saved by telldir).

void
rb_w32_seekdir(DIR *dirp, long loc)
{
	dirp->curr = (char *) loc;	/* ouch! long to pointer cast */
}

//
// Rewinddir resets the string pointer to the start
//

void
rb_w32_rewinddir(DIR *dirp)
{
	dirp->curr = dirp->start;
}

//
// This just free's the memory allocated by opendir
//

void
rb_w32_closedir(DIR *dirp)
{
	free(dirp->start);
	free(dirp);
}

static int 
valid_filename(char *s)
{
    int fd;

    //
    // if the file exists, then it's a valid filename!
    //

    if (_access(s, 0) == 0) {
	return 1;
    }

    //
    // It doesn't exist, so see if we can open it.
    //
    
    if ((fd = _open(s, _O_CREAT, 0666)) >= 0) {
	close(fd);
	_unlink (s);	// don't leave it laying around
	return 1;
    }
    return 0;
}

//
// This is a clone of fdopen so that we can handle the 
// brain damaged version of sockets that NT gets to use.
//
// The problem is that sockets are not real file handles and 
// cannot be fdopen'ed. This causes problems in the do_socket
// routine in doio.c, since it tries to create two file pointers
// for the socket just created. We'll fake out an fdopen and see
// if we can prevent perl from trying to do stdio on sockets.
//

//EXTERN_C int __cdecl _alloc_osfhnd(void);
//EXTERN_C int __cdecl _set_osfhnd(int fh, long value);
EXTERN_C void __cdecl _lock_fhandle(int);
EXTERN_C void __cdecl _unlock_fhandle(int);
EXTERN_C void __cdecl _unlock(int);

#if (defined _MT || defined __MSVCRT__) && !defined __BORLANDC__
#define MSVCRT_THREADS
#endif
#ifdef MSVCRT_THREADS
# define MTHREAD_ONLY(x) x
# define STHREAD_ONLY(x)
#elif defined(__BORLANDC__)
# define MTHREAD_ONLY(x)
# define STHREAD_ONLY(x)
#else
# define MTHREAD_ONLY(x)
# define STHREAD_ONLY(x) x
#endif

typedef struct	{
    long osfhnd;    /* underlying OS file HANDLE */
    char osfile;    /* attributes of file (e.g., open in text mode?) */
    char pipech;    /* one char buffer for handles opened on pipes */
#ifdef MSVCRT_THREADS
    int lockinitflag;
    CRITICAL_SECTION lock;
#endif
}	ioinfo;

#if !defined _CRTIMP
#define _CRTIMP __declspec(dllimport)
#endif

#ifndef __BORLANDC__
EXTERN_C _CRTIMP ioinfo * __pioinfo[];

#define IOINFO_L2E			5
#define IOINFO_ARRAY_ELTS	(1 << IOINFO_L2E)
#define _pioinfo(i)	(__pioinfo[i >> IOINFO_L2E] + (i & (IOINFO_ARRAY_ELTS - 1)))
#define _osfhnd(i)  (_pioinfo(i)->osfhnd)
#define _osfile(i)  (_pioinfo(i)->osfile)
#define _pipech(i)  (_pioinfo(i)->pipech)

#define _set_osfhnd(fh, osfh) (void)(_osfhnd(fh) = osfh)
#define _set_osflags(fh, flags) (_osfile(fh) = (flags))

#define FOPEN			0x01	/* file handle open */
#define FNOINHERIT		0x10	/* file handle opened O_NOINHERIT */
#define FAPPEND			0x20	/* file handle opened O_APPEND */
#define FDEV			0x40	/* file handle refers to device */
#define FTEXT			0x80	/* file handle is in text mode */

static int
rb_w32_open_osfhandle(long osfhandle, int flags)
{
    int fh;
    char fileflags;		/* _osfile flags */
    HANDLE hF;

    /* copy relevant flags from second parameter */
    fileflags = FDEV;

    if (flags & O_APPEND)
	fileflags |= FAPPEND;

    if (flags & O_TEXT)
	fileflags |= FTEXT;

    if (flags & O_NOINHERIT)
	fileflags |= FNOINHERIT;

    /* attempt to allocate a C Runtime file handle */
    hF = CreateFile("NUL", 0, 0, NULL, OPEN_ALWAYS, 0, NULL);
    fh = _open_osfhandle((long)hF, 0);
    CloseHandle(hF);
    if (fh == -1) {
	errno = EMFILE;		/* too many open files */
	_doserrno = 0L;		/* not an OS error */
    }
    else {

	MTHREAD_ONLY(EnterCriticalSection(&(_pioinfo(fh)->lock)));
	/* the file is open. now, set the info in _osfhnd array */
	_set_osfhnd(fh, osfhandle);

	fileflags |= FOPEN;		/* mark as open */

	_set_osflags(fh, fileflags); /* set osfile entry */
	MTHREAD_ONLY(LeaveCriticalSection(&_pioinfo(fh)->lock));
    }
    return fh;			/* return handle */
}
#else

#define _set_osfhnd(fh, osfh) (void)((fh), (osfh))
#define _set_osflags(fh, flags) (void)((fh), (flags))

#endif

#undef getsockopt

static int
is_socket(SOCKET fd)
{
    char sockbuf[80];
    int optlen;
    int retval;
    int result = TRUE;

    optlen = sizeof(sockbuf);
    RUBY_CRITICAL({
	retval = getsockopt(fd, SOL_SOCKET, SO_TYPE, sockbuf, &optlen);
	if (retval == SOCKET_ERROR) {
	    int iRet;
	    iRet = WSAGetLastError();
	    if (iRet == WSAENOTSOCK || iRet == WSANOTINITIALISED)
		result = FALSE;
	}
    });

    //
    // If we get here, then fd is actually a socket.
    //

    return result;
}

//
// Since the errors returned by the socket error function 
// WSAGetLastError() are not known by the library routine strerror
// we have to roll our own.
//

#undef strerror

char *
rb_w32_strerror(int e)
{
    static char buffer[512];
#if !defined __MINGW32__
    extern int sys_nerr;
#endif
    DWORD source = 0;
    char *p;

    if (e < 0 || e > sys_nerr) {
	if (e < 0)
	    e = GetLastError();
	if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
			  FORMAT_MESSAGE_IGNORE_INSERTS, &source, e, 0,
			  buffer, 512, NULL) == 0) {
	    strcpy(buffer, "Unknown Error");
	}
	for (p = buffer + strlen(buffer) - 1; buffer <= p; p--) {
	    if (*p != '\r' && *p != '\n') break;
	    *p = 0;
	}
	return buffer;
    }
    return strerror(e);
}

//
// various stubs
//


// Ownership
//
// Just pretend that everyone is a superuser. NT will let us know if
// we don't really have permission to do something.
//

#define ROOT_UID	0
#define ROOT_GID	0

UIDTYPE
getuid(void)
{
	return ROOT_UID;
}

UIDTYPE
geteuid(void)
{
	return ROOT_UID;
}

GIDTYPE
getgid(void)
{
	return ROOT_GID;
}

GIDTYPE
getegid(void)
{
    return ROOT_GID;
}

int
setuid(int uid)
{ 
    return (uid == ROOT_UID ? 0 : -1);
}

int
setgid(int gid)
{
    return (gid == ROOT_GID ? 0 : -1);
}

//
// File system stuff
//

int
/* ioctl(int i, unsigned int u, char *data) */
#ifdef __BORLANDC__
  ioctl(int i, int u, ...)
#else
  ioctl(int i, unsigned int u, long data)
#endif
{
    return -1;
}

#undef FD_SET

void
rb_w32_fdset(int fd, fd_set *set)
{
    unsigned int i;
    SOCKET s = TO_SOCKET(fd);

    for (i = 0; i < set->fd_count; i++) {
        if (set->fd_array[i] == s) {
            return;
        }
    }
    if (i == set->fd_count) {
        if (set->fd_count < FD_SETSIZE) {
            set->fd_array[i] = s;
            set->fd_count++;
        }
    }
}

#undef FD_CLR

void
rb_w32_fdclr(int fd, fd_set *set)
{
    unsigned int i;
    SOCKET s = TO_SOCKET(fd);

    for (i = 0; i < set->fd_count; i++) {
        if (set->fd_array[i] == s) {
            while (i < set->fd_count - 1) {
                set->fd_array[i] = set->fd_array[i + 1];
                i++;
            }
            set->fd_count--;
            break;
        }
    }
}

#undef FD_ISSET

int
rb_w32_fdisset(int fd, fd_set *set)
{
       return __WSAFDIsSet(TO_SOCKET(fd), set);
}

//
// Networking trampolines
// These are used to avoid socket startup/shutdown overhead in case 
// the socket routines aren't used.
//

#undef select

static int NtSocketsInitialized = 0;

static int
extract_file_fd(fd_set *set, fd_set *fileset)
{
    int idx;

    fileset->fd_count = 0;
    if (!set)
	return 0;
    for (idx = 0; idx < set->fd_count; idx++) {
	SOCKET fd = set->fd_array[idx];

	if (!is_socket(fd)) {
	    int i;

	    for (i = 0; i < fileset->fd_count; i++) {
		if (fileset->fd_array[i] == fd) {
		    break;
		}
	    }
	    if (i == fileset->fd_count) {
		if (fileset->fd_count < FD_SETSIZE) {
		    fileset->fd_array[i] = fd;
		    fileset->fd_count++;
		}
	    }
	}
    }
    return fileset->fd_count;
}

long 
rb_w32_select (int nfds, fd_set *rd, fd_set *wr, fd_set *ex,
	       struct timeval *timeout)
{
    long r;
    fd_set file_rd;
    fd_set file_wr;
#ifdef USE_INTERRUPT_WINSOCK
    fd_set trap;
#endif /* USE_INTERRUPT_WINSOCK */
    int file_nfds;

    if (!NtSocketsInitialized) {
	StartSockets();
    }
    r = 0;
    if (rd && rd->fd_count > r) r = rd->fd_count;
    if (wr && wr->fd_count > r) r = wr->fd_count;
    if (ex && ex->fd_count > r) r = ex->fd_count;
    if (nfds > r) nfds = r;
    if (nfds == 0 && timeout) {
	Sleep(timeout->tv_sec * 1000 + timeout->tv_usec / 1000);
	return 0;
    }
    file_nfds = extract_file_fd(rd, &file_rd);
    file_nfds += extract_file_fd(wr, &file_wr);
    if (file_nfds)
    {
	// assume normal files are always readable/writable
	// fake read/write fd_set and return value
	if (rd) *rd = file_rd;
	if (wr) *wr = file_wr;
	return file_nfds;
    }

#if USE_INTERRUPT_WINSOCK
    if (ex)
	trap = *ex;
    else
	trap.fd_count = 0;
    if (trap.fd_count < FD_SETSIZE)
	trap.fd_array[trap.fd_count++] = (SOCKET)interrupted_event;
    // else unable to catch interrupt.
    ex = &trap;
#endif /* USE_INTERRUPT_WINSOCK */

    RUBY_CRITICAL({
	r = select(nfds, rd, wr, ex, timeout);
	if (r == SOCKET_ERROR) {
	    errno = WSAGetLastError();
	    switch (errno) {
	      case WSAEINTR:
		errno = EINTR;
		break;
	    }
	}
    });
    return r;
}

static void
StartSockets ()
{
    WORD version;
    WSADATA retdata;
    int ret;
    int iSockOpt;
    
    //
    // initalize the winsock interface and insure that it's
    // cleaned up at exit.
    //
    version = MAKEWORD(1, 1);
    if (ret = WSAStartup(version, &retdata))
	rb_fatal ("Unable to locate winsock library!\n");
    if (LOBYTE(retdata.wVersion) != 1)
	rb_fatal("could not find version 1 of winsock dll\n");

    if (HIBYTE(retdata.wVersion) != 1)
	rb_fatal("could not find version 1 of winsock dll\n");

    atexit((void (*)(void)) WSACleanup);

#ifndef SO_SYNCHRONOUS_NONALERT
#define SO_SYNCHRONOUS_NONALERT 0x20
#endif

    iSockOpt = SO_SYNCHRONOUS_NONALERT;
    /*
     * Enable the use of sockets as filehandles
     */
#ifndef SO_OPENTYPE
#define SO_OPENTYPE     0x7008
#endif

    setsockopt(INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE,
	       (char *)&iSockOpt, sizeof(iSockOpt));

    main_thread.handle = GetCurrentThreadHandle();
    main_thread.id = GetCurrentThreadId();

    interrupted_event = CreateSignal();
    if (!interrupted_event)
	rb_fatal("Unable to create interrupt event!\n");
    NtSocketsInitialized = 1;
}

#undef accept

int
rb_w32_accept(int s, struct sockaddr *addr, int *addrlen)
{
    SOCKET r;

    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = accept(TO_SOCKET(s), addr, addrlen);
	if (r == INVALID_SOCKET) {
	    errno = WSAGetLastError();
	    s = -1;
	}
	else {
	    s = rb_w32_open_osfhandle(r, O_RDWR|O_BINARY);
	}
    });
    return s;
}

#undef bind

int 
rb_w32_bind(int s, struct sockaddr *addr, int addrlen)
{
    int r;

    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = bind(TO_SOCKET(s), addr, addrlen);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef connect

int 
rb_w32_connect(int s, struct sockaddr *addr, int addrlen)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = connect(TO_SOCKET(s), addr, addrlen);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}


#undef getpeername

int 
rb_w32_getpeername(int s, struct sockaddr *addr, int *addrlen)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = getpeername(TO_SOCKET(s), addr, addrlen);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef getsockname

int 
rb_w32_getsockname(int s, struct sockaddr *addr, int *addrlen)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = getsockname(TO_SOCKET(s), addr, addrlen);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}

int 
rb_w32_getsockopt(int s, int level, int optname, char *optval, int *optlen)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = getsockopt(TO_SOCKET(s), level, optname, optval, optlen);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef ioctlsocket

int 
rb_w32_ioctlsocket(int s, long cmd, u_long *argp)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = ioctlsocket(TO_SOCKET(s), cmd, argp);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef listen

int 
rb_w32_listen(int s, int backlog)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = listen(TO_SOCKET(s), backlog);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef recv

int 
rb_w32_recv(int s, char *buf, int len, int flags)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = recv(TO_SOCKET(s), buf, len, flags);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef recvfrom

int 
rb_w32_recvfrom(int s, char *buf, int len, int flags, 
		struct sockaddr *from, int *fromlen)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = recvfrom(TO_SOCKET(s), buf, len, flags, from, fromlen);
	if (r == SOCKET_ERROR)
	    errno =  WSAGetLastError();
    });
    return r;
}

#undef send

int 
rb_w32_send(int s, char *buf, int len, int flags)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = send(TO_SOCKET(s), buf, len, flags);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef sendto

int 
rb_w32_sendto(int s, char *buf, int len, int flags, 
	      struct sockaddr *to, int tolen)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = sendto(TO_SOCKET(s), buf, len, flags, to, tolen);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef setsockopt

int 
rb_w32_setsockopt(int s, int level, int optname, char *optval, int optlen)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = setsockopt(TO_SOCKET(s), level, optname, optval, optlen);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}
    
#undef shutdown

int 
rb_w32_shutdown(int s, int how)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = shutdown(TO_SOCKET(s), how);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef socket

int 
rb_w32_socket(int af, int type, int protocol)
{
    SOCKET s;
    int fd;

    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	s = socket(af, type, protocol);
	if (s == INVALID_SOCKET) {
	    errno = WSAGetLastError();
	    fd = -1;
	}
	else {
	    fd = rb_w32_open_osfhandle(s, O_RDWR|O_BINARY);
	}
    });
    return fd;
}

#undef gethostbyaddr

struct hostent *
rb_w32_gethostbyaddr (char *addr, int len, int type)
{
    struct hostent *r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = gethostbyaddr(addr, len, type);
	if (r == NULL)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef gethostbyname

struct hostent *
rb_w32_gethostbyname (char *name)
{
    struct hostent *r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = gethostbyname(name);
	if (r == NULL)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef gethostname

int
rb_w32_gethostname (char *name, int len)
{
    int r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = gethostname(name, len);
	if (r == SOCKET_ERROR)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef getprotobyname

struct protoent *
rb_w32_getprotobyname (char *name)
{
    struct protoent *r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = getprotobyname(name);
	if (r == NULL)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef getprotobynumber

struct protoent *
rb_w32_getprotobynumber (int num)
{
    struct protoent *r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = getprotobynumber(num);
	if (r == NULL)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef getservbyname

struct servent *
rb_w32_getservbyname (char *name, char *proto)
{
    struct servent *r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = getservbyname(name, proto);
	if (r == NULL)
	    errno = WSAGetLastError();
    });
    return r;
}

#undef getservbyport

struct servent *
rb_w32_getservbyport (int port, char *proto)
{
    struct servent *r;
    if (!NtSocketsInitialized) {
	StartSockets();
    }
    RUBY_CRITICAL({
	r = getservbyport(port, proto);
	if (r == NULL)
	    errno = WSAGetLastError();
    });
    return r;
}

//
// Networking stubs
//

void endhostent() {}
void endnetent() {}
void endprotoent() {}
void endservent() {}

struct netent *getnetent (void) {return (struct netent *) NULL;}

struct netent *getnetbyaddr(char *name) {return (struct netent *)NULL;}

struct netent *getnetbyname(long net, int type) {return (struct netent *)NULL;}

struct protoent *getprotoent (void) {return (struct protoent *) NULL;}

struct servent *getservent (void) {return (struct servent *) NULL;}

void sethostent (int stayopen) {}

void setnetent (int stayopen) {}

void setprotoent (int stayopen) {}

void setservent (int stayopen) {}

#ifndef WNOHANG
#define WNOHANG -1
#endif

static pid_t
poll_child_status(struct ChildRecord *child, int *stat_loc)
{
    DWORD exitcode;

    if (!GetExitCodeProcess(child->hProcess, &exitcode)) {
	/* If an error occured, return immediatly. */
	errno = GetLastError();
	if (errno == ERROR_INVALID_PARAMETER) {
	    errno = ECHILD;
	}
	CloseChildHandle(child);
	return -1;
    }
    if (exitcode != STILL_ACTIVE) {
	/* If already died, return immediatly. */
	pid_t pid = child->pid;
	CloseChildHandle(child);
	if (stat_loc) *stat_loc = exitcode << 8;
	return pid;
    }
    return 0;
}

pid_t
waitpid (pid_t pid, int *stat_loc, int options)
{
    DWORD timeout;

    if (options == WNOHANG) {
	timeout = 0;
    } else {
	timeout = INFINITE;
    }

    if (pid == -1) {
	int count = 0;
	DWORD ret;
	HANDLE events[MAXCHILDNUM + 1];

	FOREACH_CHILD(child) {
	    if (!child->pid || child->pid < 0) continue;
	    if ((pid = poll_child_status(child, stat_loc))) return pid;
	    events[count++] = child->hProcess;
	} END_FOREACH_CHILD;
	if (!count) {
	    errno = ECHILD;
	    return -1;
	}
	events[count] = interrupted_event;

	ret = WaitForMultipleEvents(count + 1, events, FALSE, timeout, TRUE);
	if (ret == WAIT_TIMEOUT) return 0;
	if ((ret -= WAIT_OBJECT_0) == count) {
	    ResetSignal(interrupted_event);
	    errno = EINTR;
	    return -1;
	}
	if (ret > count) {
	    errno = GetLastError();
	    return -1;
	}

	return poll_child_status(ChildRecord + ret, stat_loc);
    }
    else {
	struct ChildRecord* child = FindChildSlot(pid);
	if (!child) {
	    errno = ECHILD;
	    return -1;
	}

	while (!(pid = poll_child_status(child, stat_loc))) {
	    /* wait... */
	    if (wait_events(child->hProcess, timeout) != WAIT_OBJECT_0) {
		/* still active */
		pid = 0;
		break;
	    }
	}
    }

    return pid;
}

#include <sys/timeb.h>

int _cdecl
gettimeofday(struct timeval *tv, struct timezone *tz)
{
    SYSTEMTIME st;
    time_t t;
    struct tm tm;

    GetLocalTime(&st);
    tm.tm_sec = st.wSecond;
    tm.tm_min = st.wMinute;
    tm.tm_hour = st.wHour;
    tm.tm_mday = st.wDay;
    tm.tm_mon = st.wMonth - 1;
    tm.tm_year = st.wYear - 1900;
    tm.tm_isdst = -1;
    t = mktime(&tm);
    tv->tv_sec = t;
    tv->tv_usec = st.wMilliseconds * 1000;

    return 0;
}

char *
rb_w32_getcwd(buffer, size)
    char *buffer;
    int size;
{
    int length;
    char *bp;

#ifdef __BORLANDC__
#undef getcwd
    if (getcwd(buffer, size) == NULL) {
#else
    if (_getcwd(buffer, size) == NULL) {
#endif
        return NULL;
    }
    length = strlen(buffer);
    if (length >= size) {
        return NULL;
    }

    for (bp = buffer; *bp != '\0'; bp = CharNext(bp)) {
	if (*bp == '\\') {
	    *bp = '/';
	}
    }
    return buffer;
}

static char *
str_grow(struct RString *str, size_t new_size)
{
	char *p;

	p = realloc(str->ptr, new_size);
	if (p == NULL)
                rb_fatal("cannot grow string\n");

	str->len = new_size;
	str->ptr = p;

	return p;
}

int
chown(const char *path, int owner, int group)
{
	return 0;
}

int
kill(int pid, int sig)
{
    int ret = 0;

    if (pid <= 0) {
	errno = EINVAL;
	return -1;
    }

    if (IsWin95()) pid = -pid;
    if ((unsigned int)pid == GetCurrentProcessId() && sig != SIGKILL)
	return raise(sig);

    switch (sig) {
      case SIGINT:
	RUBY_CRITICAL({
	    if (!GenerateConsoleCtrlEvent(CTRL_C_EVENT, (DWORD)pid)) {
		if ((errno = GetLastError()) == 0) {
		    errno = EPERM;
		}
		ret = -1;
	    }
	});
	break;

      case SIGKILL:
	RUBY_CRITICAL({
	    HANDLE hProc = OpenProcess(PROCESS_TERMINATE, FALSE, (DWORD)pid);
	    if (hProc == NULL || hProc == INVALID_HANDLE_VALUE) {
		if (GetLastError() == ERROR_INVALID_PARAMETER) {
		    errno = ESRCH;
		}
		else {
		    errno = EPERM;
		}
		ret = -1;
	    }
	    else if (!TerminateProcess(hProc, 0)) {
		errno = EPERM;
		ret = -1;
	    }
	    CloseHandle(hProc);
	});
	break;

      define:
	errno = EINVAL;
	ret = -1;
	break;
    }

    return ret;
}

int
link(char *from, char *to)
{
	return -1;
}

int
wait()
{
	return 0;
}

char *
rb_w32_getenv(const char *name)
{
    static char *curitem = NULL;
    static DWORD curlen = 0;
    DWORD needlen;

    if (curitem == NULL || curlen == 0) {
	curlen = 512;
	curitem = ALLOC_N(char, curlen);
    }

    needlen = GetEnvironmentVariable(name, curitem, curlen);
    if (needlen != 0) {
	while (needlen > curlen) {
	    REALLOC_N(curitem, char, needlen);
	    curlen = needlen;
	    needlen = GetEnvironmentVariable(name, curitem, curlen);
	}
    }
    else {
	return NULL;
    }

    return curitem;
}

int
rb_w32_rename(const char *oldpath, const char *newpath)
{
    int res = 0;
    int oldatts;
    int newatts;

    oldatts = GetFileAttributes(oldpath);
    newatts = GetFileAttributes(newpath);

    if (oldatts == -1) {
	errno = GetLastError();
	return -1;
    }

    RUBY_CRITICAL({
	if (newatts != -1 && newatts & FILE_ATTRIBUTE_READONLY)
	    SetFileAttributesA(newpath, newatts & ~ FILE_ATTRIBUTE_READONLY);

	if (!MoveFile(oldpath, newpath))
	    res = -1;

	if (res) {
	    switch (GetLastError()) {
	      case ERROR_ALREADY_EXISTS:
	      case ERROR_FILE_EXISTS:
		if (IsWinNT()) {
		    if (MoveFileEx(oldpath, newpath, MOVEFILE_REPLACE_EXISTING))
			res = 0;
		} else {
		    for (;;) {
			if (!DeleteFile(newpath) && GetLastError() != ERROR_FILE_NOT_FOUND)
			    break;
			else if (MoveFile(oldpath, newpath)) {
			    res = 0;
			    break;
			}
		    }
		}
	    }
	}

	if (res)
	    errno = GetLastError();
	else
	    SetFileAttributes(newpath, oldatts);
    });

    return res;
}

static int
isUNCRoot(const char *path)
{
    if (path[0] == '\\' && path[1] == '\\') {
	const char *p;
	for (p = path + 3; *p; p = CharNext(p)) {
	    if (*p == '\\')
		break;
	}
	if (p[0] && p[1]) {
	    for (p++; *p; p = CharNext(p)) {
		if (*p == '\\')
		    break;
	    }
	    if (!p[0] || !p[1])
		return 1;
	}
    }
    return 0;
}

int
rb_w32_stat(const char *path, struct stat *st)
{
    const char *p;
    char *buf1 = ALLOCA_N(char, strlen(path) + 2);
    char *buf2 = ALLOCA_N(char, MAXPATHLEN);
    char *s;
    int len;
    int ret;

    for (p = path, s = buf1; *p; p++, s++) {
	if (*p == '/')
	    *s = '\\';
	else
	    *s = *p;
    }
    *s = '\0';
    len = strlen(buf1);
    p = CharPrev(buf1, buf1 + len);
    if( '\"' == *(--s) )
    {
	errno = EBADF;
	return -1;
    }

    if (isUNCRoot(buf1)) {
	if (*p != '\\')
	    strcat(buf1, "\\");
    } else if (*p == '\\' || *p == ':')
	strcat(buf1, ".");
    if (_fullpath(buf2, buf1, MAXPATHLEN)) {
	ret = stat(buf2, st);
	if (ret == 0) {
	    st->st_mode &= ~(S_IWGRP | S_IWOTH);
	}
	return ret;
    }
    else
	return -1;
}

static long
filetime_to_clock(FILETIME *ft)
{
    __int64 qw = ft->dwHighDateTime;
    qw <<= 32;
    qw |= ft->dwLowDateTime;
    qw /= 10000;  /* File time ticks at 0.1uS, clock at 1mS */
    return (long) qw;
}

int
rb_w32_times(struct tms *tmbuf)
{
    FILETIME create, exit, kernel, user;

    if (GetProcessTimes(GetCurrentProcess(),&create, &exit, &kernel, &user)) {
	tmbuf->tms_utime = filetime_to_clock(&user);
	tmbuf->tms_stime = filetime_to_clock(&kernel);
	tmbuf->tms_cutime = 0;
	tmbuf->tms_cstime = 0;
    }
    else {
	tmbuf->tms_utime = clock();
	tmbuf->tms_stime = 0;
	tmbuf->tms_cutime = 0;
	tmbuf->tms_cstime = 0;
    }
    return 0;
}

#undef Sleep
#define yield_once() Sleep(0)
#define yield_until(condition) do yield_once(); while (!(condition))

static DWORD wait_events(HANDLE event, DWORD timeout)
{
    HANDLE events[2];
    int count = 0;
    DWORD ret;

    if (event) {
	events[count++] = event;
    }
    events[count++] = interrupted_event;

    ret = WaitForMultipleEvents(count, events, FALSE, timeout, TRUE);

    if (ret == WAIT_OBJECT_0 + count - 1) {
	ResetSignal(interrupted_event);
	errno = EINTR;
    }

    return ret;
}

static CRITICAL_SECTION* system_state(void)
{
    static int initialized = 0;
    static CRITICAL_SECTION syssect;

    if (!initialized) {
	InitializeCriticalSection(&syssect);
	initialized = 1;
    }
    return &syssect;
}

static LONG flag_interrupt = -1;
static volatile DWORD tlsi_interrupt = TLS_OUT_OF_INDEXES;

void rb_w32_enter_critical(void)
{
    if (IsWinNT()) {
	EnterCriticalSection(system_state());
	return;
    }

    if (tlsi_interrupt == TLS_OUT_OF_INDEXES) {
	tlsi_interrupt = TlsAlloc();
    }

    {
	DWORD ti = (DWORD)TlsGetValue(tlsi_interrupt);
	while (InterlockedIncrement(&flag_interrupt) > 0 && !ti) {
	    InterlockedDecrement(&flag_interrupt);
	    Sleep(1);
	}
	TlsSetValue(tlsi_interrupt, (PVOID)++ti);
    }
}

void rb_w32_leave_critical(void)
{
    if (IsWinNT()) {
	LeaveCriticalSection(system_state());
	return;
    }

    InterlockedDecrement(&flag_interrupt);
    TlsSetValue(tlsi_interrupt, (PVOID)((DWORD)TlsGetValue(tlsi_interrupt) - 1));
}

struct handler_arg_t {
    void (*handler)(int);
    int arg;
    int status;
    int finished;
    HANDLE handshake;
};

static void rb_w32_call_handler(struct handler_arg_t* h)
{
    int status;
    RUBY_CRITICAL(rb_protect((VALUE (*)(VALUE))h->handler, (VALUE)h->arg, &h->status);
		  status = h->status;
		  SetEvent(h->handshake));
    if (status) {
	rb_jump_tag(status);
    }
    h->finished = 1;
    Sleep(INFINITE);		/* safe on Win95? */
}

static struct handler_arg_t* setup_handler(struct handler_arg_t *harg,
					   int arg,
					   void (*handler)(int),
					   HANDLE handshake)
{
    harg->handler = handler;
    harg->arg = arg;
    harg->status = 0;
    harg->finished = 0;
    harg->handshake = handshake;
    return harg;
}

static void setup_call(CONTEXT* ctx, struct handler_arg_t *harg)
{
#ifdef _M_IX86
    DWORD *esp = (DWORD *)ctx->Esp;
    *--esp = (DWORD)harg;
    *--esp = ctx->Eip;
    ctx->Esp = (DWORD)esp;
    ctx->Eip = (DWORD)rb_w32_call_handler;
#else
#error unsupported processor
#endif
}

int rb_w32_main_context(int arg, void (*handler)(int))
{
    static HANDLE interrupt_done = NULL;
    struct handler_arg_t harg;
    CONTEXT ctx_orig;
    HANDLE current_thread = GetCurrentThread();
    int old_priority = GetThreadPriority(current_thread);

    if (GetCurrentThreadId() == main_thread.id) return FALSE;

    SetSignal(interrupted_event);

    RUBY_CRITICAL({		/* the main thread must be in user state */
	CONTEXT ctx;

	SuspendThread(main_thread.handle);
	SetThreadPriority(current_thread, GetThreadPriority(main_thread.handle));

	ZeroMemory(&ctx, sizeof(CONTEXT));
	ctx.ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT;
	GetThreadContext(main_thread.handle, &ctx);
	ctx_orig = ctx;

	/* handler context setup */
	if (!interrupt_done) {
	    interrupt_done = CreateEvent(NULL, FALSE, FALSE, NULL);
	    /* anonymous one-shot event */
	}
	else {
	    ResetEvent(interrupt_done);
	}
	setup_call(&ctx, setup_handler(&harg, arg, handler, interrupt_done));

	ctx.ContextFlags = CONTEXT_CONTROL;
	SetThreadContext(main_thread.handle, &ctx);
	ResumeThread(main_thread.handle);
    });

    /* give a chance to the main thread */
    yield_once();
    WaitForSingleObject(interrupt_done, INFINITE); /* handshaking */

    if (!harg.status) {
	/* no exceptions raised, restore old context. */
	RUBY_CRITICAL({
	    /* ensure the main thread is in user state. */
	    yield_until(harg.finished);

	    SuspendThread(main_thread.handle);
	    ctx_orig.ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT;
	    SetThreadContext(main_thread.handle, &ctx_orig);
	    ResumeThread(main_thread.handle);
	});
    }
    /* otherwise leave the main thread raised */

    SetThreadPriority(current_thread, old_priority);

    return TRUE;
}

int rb_w32_sleep(unsigned long msec)
{
    DWORD ret;
    RUBY_CRITICAL(ret = wait_events(NULL, msec));
    yield_once();
    CHECK_INTS;
    return ret != WAIT_TIMEOUT;
}

static void catch_interrupt(void)
{
    yield_once();
    RUBY_CRITICAL(wait_events(NULL, 0));
    CHECK_INTS;
}

#undef fgetc
int rb_w32_getc(FILE* stream)
{
    int c, trap_immediate = rb_trap_immediate;
    if (enough_to_get(stream->FILE_COUNT)) {
	c = (unsigned char)*stream->FILE_READPTR++;
	rb_trap_immediate = trap_immediate;
    }
    else {
	c = _filbuf(stream);
#ifdef __BORLANDC__
        if( ( c == EOF )&&( errno == EPIPE ) )
        {
          clearerr(stream);
        }
#endif
	rb_trap_immediate = trap_immediate;
	catch_interrupt();
    }
    return c;
}

#undef fputc
int rb_w32_putc(int c, FILE* stream)
{
    int trap_immediate = rb_trap_immediate;
    if (enough_to_put(stream->FILE_COUNT)) {
	c = (unsigned char)(*stream->FILE_READPTR++ = (char)c);
	rb_trap_immediate = trap_immediate;
    }
    else {
	c = _flsbuf(c, stream);
	rb_trap_immediate = trap_immediate;
	catch_interrupt();
    }
    return c;
}

struct asynchronous_arg_t {
    /* output field */
    void* stackaddr;

    /* input field */
    VALUE (*func)(VALUE self, int argc, VALUE* argv);
    VALUE self;
    int argc;
    VALUE* argv;
};

static DWORD WINAPI
call_asynchronous(PVOID argp)
{
    struct asynchronous_arg_t *arg = argp;
    arg->stackaddr = &argp;
    return (DWORD)arg->func(arg->self, arg->argc, arg->argv);
}

VALUE rb_w32_asynchronize(asynchronous_func_t func,
			 VALUE self, int argc, VALUE* argv, VALUE intrval)
{
    DWORD val;
    BOOL interrupted = FALSE;
    HANDLE thr;

    RUBY_CRITICAL({
	struct asynchronous_arg_t arg;

	arg.stackaddr = NULL;
	arg.func = func;
	arg.self = self;
	arg.argc = argc;
	arg.argv = argv;

	thr = CreateThread(NULL, 0, call_asynchronous, &arg, 0, &val);

	if (thr) {
	    yield_until(arg.stackaddr);

	    if (wait_events(thr, INFINITE) != WAIT_OBJECT_0) {
		interrupted = TRUE;

		if (TerminateThread(thr, intrval)) {
		    yield_once();
		}
	    }

	    GetExitCodeThread(thr, &val);
	    CloseHandle(thr);

	    if (interrupted) {
		/* must release stack of killed thread, why doesn't Windows? */
		MEMORY_BASIC_INFORMATION m;

		memset(&m, 0, sizeof(m));
		if (!VirtualQuery(arg.stackaddr, &m, sizeof(m))) {
		    Debug(fprintf(stderr, "couldn't get stack base:%p:%d\n",
				  arg.stackaddr, GetLastError()));
		}
		else if (!VirtualFree(m.AllocationBase, 0, MEM_RELEASE)) {
		    Debug(fprintf(stderr, "couldn't release stack:%p:%d\n",
				  m.AllocationBase, GetLastError()));
		}
	    }
	}
    });

    if (!thr) {
	rb_fatal("failed to launch waiter thread:%d", GetLastError());
    }

    if (interrupted) {
	errno = EINTR;
	CHECK_INTS;
    }

    return val;
}

char **rb_w32_get_environ(void)
{
    char *envtop, *env;
    char **myenvtop, **myenv;
    int num;

    /*
     * We avoid values started with `='. If you want to deal those values,
     * change this function, and some functions in hash.c which recognize
     * `=' as delimiter or rb_w32_getenv() and ruby_setenv().
     * CygWin deals these values by changing first `=' to '!'. But we don't
     * use such trick and follow cmd.exe's way that just doesn't show these
     * values.
     * (U.N. 2001-11-15)
     */
    envtop = GetEnvironmentStrings();
    for (env = envtop, num = 0; *env; env += strlen(env) + 1)
	if (*env != '=') num++;

    myenvtop = ALLOC_N(char*, num + 1);
    for (env = envtop, myenv = myenvtop; *env; env += strlen(env) + 1) {
	if (*env != '=') {
	    *myenv = ALLOC_N(char, strlen(env) + 1);
	    strcpy(*myenv, env);
	    myenv++;
	}
    }
    *myenv = NULL;
    FreeEnvironmentStrings(envtop);

    return myenvtop;
}

void rb_w32_free_environ(char **env)
{
    char **t = env;

    while (*t) free(*t++);
    free(env);
}

pid_t rb_w32_getpid(void)
{
    pid_t pid;

    pid = _getpid();
    if (IsWin95()) pid = -pid;

    return pid;
}

int
rb_w32_fclose(FILE *fp)
{
    int fd = fileno(fp);
    SOCKET sock = TO_SOCKET(fd);

    if (fflush(fp)) return -1;
    if (!is_socket(sock)) {
	return fclose(fp);
    }
    _set_osfhnd(fd, (SOCKET)INVALID_HANDLE_VALUE);
    fclose(fp);
    if (closesocket(sock) == SOCKET_ERROR) {
	errno = WSAGetLastError();
	return -1;
    }
    return 0;
}

int
rb_w32_close(int fd)
{
    SOCKET sock = TO_SOCKET(fd);

    if (!is_socket(sock)) {
	return _close(fd);
    }
    if (closesocket(sock) == SOCKET_ERROR) {
	errno = WSAGetLastError();
	return -1;
    }
    return 0;
}
@


1.72
log
@* win32/win32.c (rb_w32_fclose, rb_w32_close): use closesocket()
  for socket.  [ruby-win32:382]

* win32/win32.c (StartSockets): set NtSocketsInitialized.

* win32/win32.h: prototypes; rb_w32_fclose, rb_w32_close
@
text
@d54 6
a59 1
#  define _flsbuf fputc
d2796 1
a2796 1
    if (--stream->FILE_COUNT >= 0) {
d2818 1
a2818 1
    if (--stream->FILE_COUNT >= 0) {
@


1.71
log
@	* ext/socket/socket.c (init_sock): no need for special finalizer,
	  socket descriptor is no longer duplicated in 1.7.
	  [ruby-talk:50732]

	* win32/win32.c, win32/win32.h (rb_w32_fddup, rb_w32_fdclose):
	  delete.
@
text
@d36 1
d38 3
d1680 1
a1680 1
    if (!NtSocketsInitialized++) {
d1734 1
a1734 1
	int iSockOpt;
d1772 1
d1782 1
a1782 1
    if (!NtSocketsInitialized++) {
d1805 1
a1805 1
    if (!NtSocketsInitialized++) {
d1822 1
a1822 1
    if (!NtSocketsInitialized++) {
d1840 1
a1840 1
    if (!NtSocketsInitialized++) {
d1857 1
a1857 1
    if (!NtSocketsInitialized++) {
d1872 1
a1872 1
    if (!NtSocketsInitialized++) {
d1889 1
a1889 1
    if (!NtSocketsInitialized++) {
d1906 1
a1906 1
    if (!NtSocketsInitialized++) {
d1923 1
a1923 1
    if (!NtSocketsInitialized++) {
d1941 1
a1941 1
    if (!NtSocketsInitialized++) {
d1958 1
a1958 1
    if (!NtSocketsInitialized++) {
d1976 1
a1976 1
    if (!NtSocketsInitialized++) {
d1993 1
a1993 1
    if (!NtSocketsInitialized++) {
d2010 1
a2010 1
    if (!NtSocketsInitialized++) {
d2029 1
a2029 1
    if (!NtSocketsInitialized++) {
d2051 1
a2051 1
    if (!NtSocketsInitialized++) {
d2068 1
a2068 1
    if (!NtSocketsInitialized++) {
d2085 1
a2085 1
    if (!NtSocketsInitialized++) {
d2102 1
a2102 1
    if (!NtSocketsInitialized++) {
d2119 1
a2119 1
    if (!NtSocketsInitialized++) {
d2136 1
a2136 1
    if (!NtSocketsInitialized++) {
d2153 1
a2153 1
    if (!NtSocketsInitialized++) {
d2954 34
@


1.70
log
@* win32/win32.c (rb_w32_open_osfhandle): adjust
  rb_w32_open_osfhandle() with _open_osfhandle().

* win32/win32.c (rb_w32_accept, rb_w32_socket): return -1 on
  error.

* win32/win32.h: should use file descriptor instead of SOCKET.
@
text
@a1474 22
int
rb_w32_fddup (int fd)
{
    SOCKET s = TO_SOCKET(fd);

    if (s == -1)
	return -1;

    RUBY_CRITICAL(fd = rb_w32_open_osfhandle(s, O_RDWR|O_BINARY));
    return fd;
}


void
rb_w32_fdclose(FILE *fp)
{
    RUBY_CRITICAL({
	STHREAD_ONLY(_free_osfhnd(fileno(fp)));
	fclose(fp);
    });
}

@


1.69
log
@* win32/win32.c (is_socket, rb_w32_select, rb_w32_accept, rb_w32_bind,
  rb_w32_connect, rb_w32_getpeername, rb_w32_getsockname,
  rb_w32_getsockopt, rb_w32_ioctlsocket, rb_w32_listen, rb_w32_recv,
  rb_w32_recvfrom, rb_w32_send, rb_w32_sendto, rb_w32_setsockopt,
  rb_w32_shutdown, rb_w32_socket, rb_w32_gethostbyaddr,
  rb_w32_gethostbyname, rb_w32_gethostname, rb_w32_getprotobyname,
  rb_w32_getprotobynumber, rb_w32_getservbyname, rb_w32_getservbyport):
  need to protect WSAGetLastError() by RUBY_CRITICAL. [ruby-talk:51778]
@
text
@d87 2
a434 1

a511 5
	ret = 0;
    } while (0));
    if (ret != 0) {
	return ret;
    }
d513 3
a515 4
    /* create child process */
    child = CreateChild(cmd, &sa, NULL, NULL, NULL);
    if (!child) {
	RUBY_CRITICAL({
d526 2
a527 3
	});
	return -1;
    }
d529 1
a529 3
    /* restore STDIN/STDOUT */
    RUBY_CRITICAL(do {
	ret = -1;
a555 5
	ret = 0;
    } while (0));
    if (ret != 0) {
	return ret;
    }
d557 19
a575 11
    if (reading) {
#ifdef __BORLANDC__
	fdin = _open_osfhandle((long)hDupInFile, (_O_RDONLY | pipemode));
#else
	fdin = rb_w32_open_osfhandle((long)hDupInFile, (_O_RDONLY | pipemode));
#endif
	CloseHandle(hReadOut);
	if (fdin == -1) {
	    CloseHandle(hDupInFile);
	    if (writing) {
		CloseHandle(hWriteIn);
d577 5
a582 2
	    CloseChildHandle(child);
	    return -1;
d584 4
a587 12
    }
    if (writing) {
#ifdef __BORLANDC__
	fdout = _open_osfhandle((long)hDupOutFile, (_O_WRONLY | pipemode));
#else
	fdout = rb_w32_open_osfhandle((long)hDupOutFile,
				      (_O_WRONLY | pipemode));
#endif
	CloseHandle(hWriteIn);
	if (fdout == -1) {
	    CloseHandle(hDupOutFile);
	    if (reading) {
d589 5
a594 2
	    CloseChildHandle(child);
	    return -1;
d596 3
a598 7
    }

    if (reading) {
	sprintf(modes, "r%s", pipemode == O_BINARY ? "b" : "");
	if ((*fpr = (FILE *)fdopen(fdin, modes)) == NULL) {
	    _close(fdin);
	    if (writing) {
d600 5
a605 2
	    CloseChildHandle(child);
	    return -1;
d607 2
a608 12
    }
    if (writing) {
	sprintf(modes, "w%s", pipemode == O_BINARY ? "b" : "");
	if ((*fpw = (FILE *)fdopen(fdout, modes)) == NULL) {
	    _close(fdout);
	    if (reading) {
		fclose(*fpr);
	    }
	    CloseChildHandle(child);
	    return -1;
	}
    }
d610 1
a610 1
    return child->pid;
a1393 7
#else

#define _set_osfhnd(fh, osfh) (void)((fh), (osfh))
#define _set_osflags(fh, flags) (void)((fh), (flags))

#endif

d1405 1
d1419 9
a1427 10
    RUBY_CRITICAL({
	/* attempt to allocate a C Runtime file handle */
	HANDLE hF = CreateFile("NUL", 0, 0, NULL, OPEN_ALWAYS, 0, NULL);
	fh = _open_osfhandle((long)hF, 0);
	CloseHandle(hF);
	if (fh == -1) {
	    errno = EMFILE;		/* too many open files */
	    _doserrno = 0L;		/* not an OS error */
	}
	else {
d1429 3
a1431 3
	    MTHREAD_ONLY(EnterCriticalSection(&(_pioinfo(fh)->lock)));
	    /* the file is open. now, set the info in _osfhnd array */
	    _set_osfhnd(fh, osfhandle);
d1433 1
a1433 1
	    fileflags |= FOPEN;		/* mark as open */
d1435 3
a1437 4
	    _set_osflags(fh, fileflags); /* set osfile entry */
	    MTHREAD_ONLY(LeaveCriticalSection(&_pioinfo(fh)->lock));
	}
    });
d1440 6
d1483 2
a1484 1
    return rb_w32_open_osfhandle(s, O_RDWR|O_BINARY);
d1794 2
a1795 2
SOCKET
rb_w32_accept (SOCKET s, struct sockaddr *addr, int *addrlen)
d1804 1
a1804 1
	if (r == INVALID_SOCKET)
d1806 5
d1812 1
a1812 1
    return rb_w32_open_osfhandle(r, O_RDWR|O_BINARY);
d1818 1
a1818 1
rb_w32_bind (SOCKET s, struct sockaddr *addr, int addrlen)
d1836 1
a1836 1
rb_w32_connect (SOCKET s, struct sockaddr *addr, int addrlen)
d1854 1
a1854 1
rb_w32_getpeername (SOCKET s, struct sockaddr *addr, int *addrlen)
d1871 1
a1871 1
rb_w32_getsockname (SOCKET s, struct sockaddr *addr, int *addrlen)
d1886 1
a1886 1
rb_w32_getsockopt (SOCKET s, int level, int optname, char *optval, int *optlen)
d1903 1
a1903 1
rb_w32_ioctlsocket (SOCKET s, long cmd, u_long *argp)
d1920 1
a1920 1
rb_w32_listen (SOCKET s, int backlog)
d1937 1
a1937 1
rb_w32_recv (SOCKET s, char *buf, int len, int flags)
d1954 1
a1954 1
rb_w32_recvfrom (SOCKET s, char *buf, int len, int flags, 
d1972 1
a1972 1
rb_w32_send (SOCKET s, char *buf, int len, int flags)
d1989 2
a1990 2
rb_w32_sendto (SOCKET s, char *buf, int len, int flags, 
		struct sockaddr *to, int tolen)
d2007 1
a2007 1
rb_w32_setsockopt (SOCKET s, int level, int optname, char *optval, int optlen)
d2024 1
a2024 1
rb_w32_shutdown (SOCKET s, int how)
d2040 2
a2041 2
SOCKET 
rb_w32_socket (int af, int type, int protocol)
d2044 2
d2051 1
a2051 1
	if (s == INVALID_SOCKET)
d2053 5
d2059 1
a2059 5
#ifdef __BORLANDC__
    return _open_osfhandle(s, O_RDWR|O_BINARY);
#else
    return rb_w32_open_osfhandle(s, O_RDWR|O_BINARY);
#endif
@


1.68
log
@* win32/win32.c (rb_w32_opendir): Corresponds to the unjust path containing ".
                        (rb_w32_stat) : ditto.
@
text
@d1475 1
d1478 9
a1486 8
    retval = getsockopt(fd, SOL_SOCKET, SO_TYPE, sockbuf, &optlen);
    if (retval == SOCKET_ERROR) {
	int iRet;

	iRet = WSAGetLastError();
	if (iRet == WSAENOTSOCK || iRet == WSANOTINITIALISED)
	    return FALSE;
    }
d1492 1
a1492 1
    return TRUE;
d1751 9
a1759 7
    RUBY_CRITICAL(r = select (nfds, rd, wr, ex, timeout));
    if (r == SOCKET_ERROR) {
	errno = WSAGetLastError();
	switch (errno) {
	  case WSAEINTR:
	    errno = EINTR;
	    break;
d1761 1
a1761 1
    }
d1821 5
a1825 3
    RUBY_CRITICAL(r = accept (TO_SOCKET(s), addr, addrlen));
    if (r == INVALID_SOCKET)
	errno = WSAGetLastError();
d1839 5
a1843 3
    RUBY_CRITICAL(r = bind (TO_SOCKET(s), addr, addrlen));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d1856 5
a1860 3
    RUBY_CRITICAL(r = connect (TO_SOCKET(s), addr, addrlen));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d1874 5
a1878 3
    RUBY_CRITICAL(r = getpeername (TO_SOCKET(s), addr, addrlen));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d1891 5
a1895 3
    RUBY_CRITICAL(r = getsockname (TO_SOCKET(s), addr, addrlen));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d1906 5
a1910 3
    RUBY_CRITICAL(r = getsockopt (TO_SOCKET(s), level, optname, optval, optlen));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d1923 5
a1927 3
    RUBY_CRITICAL(r = ioctlsocket (TO_SOCKET(s), cmd, argp));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d1940 5
a1944 3
    RUBY_CRITICAL(r = listen (TO_SOCKET(s), backlog));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d1957 5
a1961 3
    RUBY_CRITICAL(r = recv (TO_SOCKET(s), buf, len, flags));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d1975 5
a1979 3
    RUBY_CRITICAL(r = recvfrom (TO_SOCKET(s), buf, len, flags, from, fromlen));
    if (r == SOCKET_ERROR)
	errno =  WSAGetLastError();
d1992 5
a1996 3
    RUBY_CRITICAL(r = send (TO_SOCKET(s), buf, len, flags));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d2010 5
a2014 3
    RUBY_CRITICAL(r = sendto (TO_SOCKET(s), buf, len, flags, to, tolen));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d2027 5
a2031 3
    RUBY_CRITICAL(r = setsockopt (TO_SOCKET(s), level, optname, optval, optlen));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d2044 5
a2048 3
    RUBY_CRITICAL(r = shutdown (TO_SOCKET(s), how));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d2061 5
a2065 5
    RUBY_CRITICAL(s = socket (af, type, protocol));
    if (s == INVALID_SOCKET) {
	errno = WSAGetLastError();
	//fprintf(stderr, "socket fail (%d)", WSAGetLastError());
    }
d2082 5
a2086 3
    RUBY_CRITICAL(r = gethostbyaddr (addr, len, type));
    if (r == NULL)
	errno = WSAGetLastError();
d2099 5
a2103 3
    RUBY_CRITICAL(r = gethostbyname (name));
    if (r == NULL)
	errno = WSAGetLastError();
d2116 5
a2120 3
    RUBY_CRITICAL(r = gethostname (name, len));
    if (r == SOCKET_ERROR)
	errno = WSAGetLastError();
d2133 5
a2137 3
    RUBY_CRITICAL(r = getprotobyname (name));
    if (r == NULL)
	errno = WSAGetLastError();
d2150 5
a2154 3
    RUBY_CRITICAL(r = getprotobynumber (num));
    if (r == NULL)
	errno = WSAGetLastError();
d2167 5
a2171 3
    RUBY_CRITICAL(r = getservbyname (name, proto));
    if (r == NULL)
	errno = WSAGetLastError();
d2184 5
a2188 3
    RUBY_CRITICAL(r = getservbyport (port, proto));
    if (r == NULL)
	errno = WSAGetLastError();
@


1.67
log
@* win32/win32.c, win32/win32.h (rb_w32_getpid): negate pid under Win9x.
@
text
@d1153 8
a1160 8
    DIR            *p;
    long            len;
    long            idx;
    char            scannamespc[PATHLEN];
    char	   *scanname = scannamespc;
    struct stat	    sbuf;
    WIN32_FIND_DATA FindData;
    HANDLE          fh;
d1168 1
a1168 1
	(unsigned short)(sbuf.st_mode) & _S_IFDIR == 0) &&
d1170 1
a1170 1
	sbuf.st_mode & _S_IFDIR == 0) &&
d1172 1
d1201 2
a1202 2
    fh = FindFirstFile (scanname, &FindData);
    if (fh == INVALID_HANDLE_VALUE) {
d1211 1
a1211 1
    idx = strlen(FindData.cFileName)+1;
d1213 1
a1213 1
    strcpy (p->start, FindData.cFileName);
d1222 2
a1223 2
    while (FindNextFile(fh, &FindData)) {
	len = strlen (FindData.cFileName);
d1236 1
a1236 1
	strcpy(&p->start[idx], FindData.cFileName);
d1240 1
a1240 1
    FindClose(fh);
d2521 6
@


1.66
log
@* time.c: prototype; time_free() to avoid VC++ warnings.

* win32/win32.c (rb_w32_stat): remove S_IWGRP and S_IWOTH bits from
  st_mode.

* win32/win32.h (S_I*): define if not defined.
@
text
@d2920 10
@


1.65
log
@* win32/win32.c (kill): negate pid under Win9x.
@
text
@d2509 1
d2525 7
a2531 2
    if (_fullpath(buf2, buf1, MAXPATHLEN))
	return stat(buf2, st);
@


1.64
log
@* win32/win32.h: define SIGINT and SIGKILL if not defined.
* win32/win32.c: remove definition of SIGINT and SIGKILL.
@
text
@d2340 6
d2349 2
a2350 1
    if (sig == SIGINT && pid > 0) {
d2353 3
a2355 1
		errno = GetLastError();
d2359 1
a2359 3
    }
    else if (sig == SIGKILL && pid > 0) {
	HANDLE hProc;
d2361 1
d2363 1
a2363 2
	    hProc = OpenProcess(PROCESS_TERMINATE, FALSE,
				IsWin95() ? -pid : pid);
d2379 3
a2381 2
    }
    else {
d2384 1
@


1.63
log
@* replace of check EPIPE error(in getc()) rutine on bcc32.
@
text
@a2334 7
#include <signal.h>
#ifndef SIGINT
#define SIGINT 2
#endif
#ifndef SIGKILL
#define SIGKILL	9
#endif
@


1.62
log
@* ext/tcltklib/stubs.c (ruby_tcltk_stubs): win32_getenv returns
  the same address always, so allocate string by ruby_strdup.

* win32/win32.c: prototype; rb_w32_open_osfhandle().
@
text
@d2764 6
@


1.61
log
@* io.c (pipe_finalize, pipe_popen): two-way pipe support for win32.

* win32/win32.c (ChildRecord, FindFreeChildSlot): ditto.

* win32/win32.c, win32/win32.h (pipe_exec): new function for two-way
  pipe support for win32.

* win32/win32.c, win32/win32.h (FindPipedChildSlot, rb_w32_popen,
  rb_w32_pclose): removed functions for two-way pipe support for win32.
@
text
@d85 3
@


1.60
log
@* win32/win32.c (rb_w32_stat): fix buffer overflow. (ruby-bugs:PR#329)
@
text
@a301 1
    FILE* pipe;		/* pipe */
a329 11
static struct ChildRecord *
FindPipedChildSlot(FILE *fp)
{
    FOREACH_CHILD(child) {
	if (child->pid && child->pipe == fp) {
	    return child;
	}
    } END_FOREACH_CHILD;
    return NULL;
}

a345 1
	    child->pipe = NULL;
d433 2
a434 3

FILE *
rb_w32_popen (char *cmd, char *mode) 
a435 3
    FILE *fp;
    int reading;
    int pipemode;
d437 4
a440 2
    BOOL fRet;
    HANDLE hInFile, hOutFile, hSavedStdIo, hDupFile;
d443 11
a453 1
    int fd;
a454 10
    //
    // Figure out what we're doing...
    //

    reading = (*mode == 'r') ? TRUE : FALSE;
    pipemode = (*(mode+1) == 'b') ? O_BINARY : O_TEXT;

    //
    // Now get a pipe
    //
d459 21
a479 18
    fRet = CreatePipe(&hInFile, &hOutFile, &sa, 2048L);
    if (!fRet) {
	errno = GetLastError();
	return NULL;
    }

    /* save parent's STDIO and redirect for child */
    hCurProc = GetCurrentProcess();
    if (reading) {
	hSavedStdIo = GetStdHandle(STD_OUTPUT_HANDLE);
	if (!SetStdHandle(STD_OUTPUT_HANDLE, hOutFile) ||
	    !DuplicateHandle(hCurProc, hInFile, hCurProc, &hDupFile, 0, FALSE,
			     DUPLICATE_SAME_ACCESS)) {
	    errno = GetLastError();
	    CloseHandle(hInFile);
	    CloseHandle(hOutFile);
	    CloseHandle(hCurProc);
	    return NULL;
d481 25
a505 12
	CloseHandle(hInFile);
    }
    else {
	hSavedStdIo = GetStdHandle(STD_INPUT_HANDLE);
	if (!SetStdHandle(STD_INPUT_HANDLE, hInFile) ||
	    !DuplicateHandle(hCurProc, hOutFile, hCurProc, &hDupFile, 0, FALSE,
			     DUPLICATE_SAME_ACCESS)) {
	    errno = GetLastError();
	    CloseHandle(hInFile);
	    CloseHandle(hOutFile);
	    CloseHandle(hCurProc);
	    return NULL;
d507 5
a511 1
	CloseHandle(hOutFile);
a512 1
    CloseHandle(hCurProc);
d517 48
a564 3
	CloseHandle(reading ? hOutFile : hInFile);
	CloseHandle(hDupFile);
	return NULL;
a566 1
    /* restore STDIO */
d568 12
a579 2
	if (!SetStdHandle(STD_OUTPUT_HANDLE, hSavedStdIo)) {
	    errno = GetLastError();
d581 1
a581 3
	    CloseHandle(hDupFile);
	    CloseHandle(hOutFile);
	    return NULL;
d584 13
a596 3
    else {
	if (!SetStdHandle(STD_INPUT_HANDLE, hSavedStdIo)) {
	    errno = GetLastError();
d598 1
a598 3
	    CloseHandle(hInFile);
	    CloseHandle(hDupFile);
	    return NULL;
d603 9
a611 2
	fd = _open_osfhandle((long)hDupFile, (_O_RDONLY | pipemode));
	CloseHandle(hOutFile);
d613 10
a622 15
    else {
	fd = _open_osfhandle((long)hDupFile, (_O_WRONLY | pipemode));
	CloseHandle(hInFile);
    }

    if (fd == -1) {
	CloseHandle(hDupFile);
	CloseChildHandle(child);
	return NULL;
    }

    if ((fp = (FILE *) fdopen(fd, mode)) == NULL) {
	_close(fd);
	CloseChildHandle(child);
	return NULL;
d625 1
a625 3
    child->pipe = fp;

    return fp;
a628 23

int
rb_w32_pclose(FILE *fp)
{
    struct ChildRecord *child = FindPipedChildSlot(fp);

    if (!child) {
	return -1;		/* may closed in waitpid() */
    }

    //
    // close the pipe
    //
    child->pipe = NULL;
    fflush(fp);
    fclose(fp);

    //
    // get the return status of the process
    //
    rb_syswait(child->pid);
    return NUM2INT(rb_last_status);
}
@


1.59
log
@*bcc32 fix for win9x.
@
text
@d2459 1
a2459 1
    char *buf1 = ALLOCA_N(char, strlen(path) + 1);
@


1.58
log
@new platform [bccwin32] merged.
@
text
@d1326 1
a1326 1
#if defined _MT || defined __MSVCRT__
d1363 9
a1379 2
#define _set_osfhnd(fh, osfh) (void)(_osfhnd(fh) = osfh)

a1397 23
#ifdef __BORLANDC__
    {
	/* attempt to allocate a C Runtime file handle */
	HANDLE hF = CreateFile("NUL", 0, 0, NULL, OPEN_ALWAYS, 0, NULL);
	fh = _open_osfhandle((long)hF, 0);
	CloseHandle(hF);
	if (fh == -1) {
	    errno = EMFILE;		/* too many open files */
	    _doserrno = 0L;		/* not an OS error */
	}
	else {

	    MTHREAD_ONLY(EnterCriticalSection(&(_pioinfo(fh)->lock)));
	    /* the file is open. now, set the info in _osfhnd array */
	    //_set_osfhnd(fh, osfhandle);

	    fileflags |= FOPEN;		/* mark as open */

	    //_osfile(fh) = fileflags;	/* set osfile entry */
	    MTHREAD_ONLY(LeaveCriticalSection(&_pioinfo(fh)->lock));
	}
    }
#else
d1415 1
a1415 1
	    _osfile(fh) = fileflags;	/* set osfile entry */
a1418 1
#endif
@


1.57
log
@Wed May 29 18:55:47 2002  KONISHI Hiromasa <H_Konishi@@ruby-lang.org>

	* function renames my* and win32_* to rb_w32_* in win32/win32.c
	  fixed files win32/win32.c, win32/win32.h, win32/dir.h,
	              hash.c, rubysig.h, signal.c, ext/socket/socket.c
@
text
@d48 5
d1123 3
d1127 1
d1332 3
d1354 1
a1359 1

d1363 1
d1391 23
d1435 1
a1435 1

d1577 5
a1581 1
ioctl(int i, unsigned int u, long data)
d1756 4
d1764 4
d2006 3
d2010 1
d2266 4
d2271 1
d2731 2
a2732 2
    if (--stream->_cnt >= 0) {
	c = (unsigned char)*stream->_ptr++;
d2747 2
a2748 2
    if (--stream->_cnt >= 0) {
	c = (unsigned char)(*stream->_ptr++ = (char)c);
@


1.56
log
@* win32/win32.c (insert): fix prototype for ANSI C.
@
text
@d240 1
a240 1
    return win32_asynchronize(locker,
d435 1
a435 1
myget_osfhandle(int fh)
d443 1
a443 1
mypopen (char *cmd, char *mode) 
d562 1
a562 1
mypclose(FILE *fp)
d1102 1
a1102 1
opendir(const char *filename)
d1117 1
a1117 1
    if ((win32_stat (filename, &sbuf) < 0 ||
d1199 1
a1199 1
readdir(DIR *dirp)
d1239 1
a1239 1
telldir(DIR *dirp)
d1249 1
a1249 1
seekdir(DIR *dirp, long loc)
d1259 1
a1259 1
rewinddir(DIR *dirp)
d1269 1
a1269 1
closedir(DIR *dirp)
d1361 1
a1361 1
my_open_osfhandle(long osfhandle, int flags)
d1430 1
a1430 1
myfddup (int fd)
d1437 1
a1437 1
    return my_open_osfhandle(s, O_RDWR|O_BINARY);
d1442 1
a1442 1
myfdclose(FILE *fp)
d1459 1
a1459 1
mystrerror(int e)
d1549 1
a1549 1
myfdset(int fd, fd_set *set)
d1570 1
a1570 1
myfdclr(int fd, fd_set *set)
d1590 1
a1590 1
myfdisset(int fd, fd_set *set)
d1636 1
a1636 1
myselect (int nfds, fd_set *rd, fd_set *wr, fd_set *ex,
d1734 1
a1734 1
myaccept (SOCKET s, struct sockaddr *addr, int *addrlen)
d1744 1
a1744 1
    return my_open_osfhandle(r, O_RDWR|O_BINARY);
d1750 1
a1750 1
mybind (SOCKET s, struct sockaddr *addr, int addrlen)
d1766 1
a1766 1
myconnect (SOCKET s, struct sockaddr *addr, int addrlen)
d1782 1
a1782 1
mygetpeername (SOCKET s, struct sockaddr *addr, int *addrlen)
d1797 1
a1797 1
mygetsockname (SOCKET s, struct sockaddr *addr, int *addrlen)
d1810 1
a1810 1
mygetsockopt (SOCKET s, int level, int optname, char *optval, int *optlen)
d1825 1
a1825 1
myioctlsocket (SOCKET s, long cmd, u_long *argp)
d1840 1
a1840 1
mylisten (SOCKET s, int backlog)
d1855 1
a1855 1
myrecv (SOCKET s, char *buf, int len, int flags)
d1870 1
a1870 1
myrecvfrom (SOCKET s, char *buf, int len, int flags, 
d1886 1
a1886 1
mysend (SOCKET s, char *buf, int len, int flags)
d1901 1
a1901 1
mysendto (SOCKET s, char *buf, int len, int flags, 
d1917 1
a1917 1
mysetsockopt (SOCKET s, int level, int optname, char *optval, int optlen)
d1932 1
a1932 1
myshutdown (SOCKET s, int how)
d1947 1
a1947 1
mysocket (int af, int type, int protocol)
d1958 1
a1958 1
    return my_open_osfhandle(s, O_RDWR|O_BINARY);
d1964 1
a1964 1
mygethostbyaddr (char *addr, int len, int type)
d1979 1
a1979 1
mygethostbyname (char *name)
d1994 1
a1994 1
mygethostname (char *name, int len)
d2009 1
a2009 1
mygetprotobyname (char *name)
d2024 1
a2024 1
mygetprotobynumber (int num)
d2039 1
a2039 1
mygetservbyname (char *name, char *proto)
d2054 1
a2054 1
mygetservbyport (int port, char *proto)
d2207 1
a2207 1
win32_getcwd(buffer, size)
d2317 1
a2317 1
win32_getenv(const char *name)
d2344 1
a2344 1
myrename(const char *oldpath, const char *newpath)
d2416 1
a2416 1
win32_stat(const char *path, struct stat *st)
d2455 1
a2455 1
mytimes(struct tms *tmbuf)
d2514 1
a2514 1
void win32_enter_critical(void)
d2535 1
a2535 1
void win32_leave_critical(void)
d2554 1
a2554 1
static void win32_call_handler(struct handler_arg_t* h)
d2587 1
a2587 1
    ctx->Eip = (DWORD)win32_call_handler;
d2593 1
a2593 1
int win32_main_context(int arg, void (*handler)(int))
d2654 1
a2654 1
int win32_sleep(unsigned long msec)
d2671 1
a2671 1
int win32_getc(FILE* stream)
d2687 1
a2687 1
int win32_putc(int c, FILE* stream)
d2721 1
a2721 1
VALUE win32_asynchronize(asynchronous_func_t func,
d2782 1
a2782 1
char **win32_get_environ(void)
d2791 1
a2791 1
     * `=' as delimiter or win32_getenv() and ruby_setenv().
d2815 1
a2815 1
void win32_free_environ(char **env)
@


1.55
log
@* win32/win32.c: include <mswsock.h> on __MINGW32__.
@
text
@d730 1
a730 1
insert(char *path, ListInfo *listinfo)
d733 1
d774 1
a774 1
    rb_globi(buf, (void (*) _((const char*, VALUE)))insert, (VALUE)&listinfo);
@


1.54
log
@* win32/win32.c (StartSockets): remove duplicated lines.
@
text
@d27 3
@


1.53
log
@	* win32/win32.c (mypopen): fixed that mypclose() didn't really close
	  pipe.

	* win32/win32.c (CreateChild): set STARTF_USESTDHANDLES flag only
	  when some handles are passed.
@
text
@a1724 3
    interrupted_event = CreateSignal();
    if (!interrupted_event)
	rb_fatal("Unable to create interrupt event!\n");
@


1.52
log
@	* hash.c (ruby_setenv): remove USE_WIN32_RTL_ENV block since it's
	  obsoleted.

	* win32/win32.c, win32/win32.h: sort out #if 0 - #endif or others.
@
text
@d447 2
a448 1
    HANDLE hInFile, hOutFile;
d472 2
d475 11
a485 1
	child = CreateChild(cmd, &sa, NULL, hOutFile, NULL);
d488 11
a498 1
	child = CreateChild(cmd, &sa, hInFile, NULL, NULL);
d500 1
d502 2
d505 2
a506 2
	CloseHandle(hInFile);
	CloseHandle(hOutFile);
d510 20
d531 1
a531 1
	fd = _open_osfhandle((long)hInFile,  (_O_RDONLY | pipemode));
d535 1
a535 1
	fd = _open_osfhandle((long)hOutFile, (_O_WRONLY | pipemode));
d540 1
a540 1
	CloseHandle(reading ? hInFile : hOutFile);
d620 20
a639 18
    aStartupInfo.dwFlags = STARTF_USESTDHANDLES;
    if (hInput) {
	aStartupInfo.hStdInput  = hInput;
    }
    else {
	aStartupInfo.hStdInput  = GetStdHandle(STD_INPUT_HANDLE);
    }
    if (hOutput) {
	aStartupInfo.hStdOutput = hOutput;
    }
    else {
	aStartupInfo.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    }
    if (hError) {
	aStartupInfo.hStdError = hError;
    }
    else {
	aStartupInfo.hStdError = GetStdHandle(STD_ERROR_HANDLE);
@


1.51
log
@	* win32/win32.c (waitpid): fix wait count.

	* win32/win32.c (poll_child_status): rename from wait_child().
@
text
@a69 4
#if 0  // declared in header file
extern char **environ;
#define environ _environ
#endif
a244 1

d256 1
a256 1
    // subvert cmd.exe\'s feeble attempt at command line parsing
a269 1

a288 3


#if 1
d452 1
a452 1
    // Figure out what we\'re doing...
a533 3
#endif

#if 1
a534 1

a635 2
#endif

d670 1
a670 1
// resulting list of new names. If the wildcard pattern doesn\'t match 
a672 76

#if 0
void
NtCmdGlob (NtCmdLineElement *patt)
{
    WIN32_FIND_DATA fd;
    HANDLE fh;
    char buffer[512];
    NtCmdLineElement *tmphead, *tmptail, *tmpcurr;

    strncpy(buffer, patt->str, patt->len);
    buffer[patt->len] = '\0';
    if ((fh = FindFirstFile (buffer, &fd)) == INVALID_HANDLE_VALUE) {
	return;
    }
    tmphead = tmptail = NULL;
    do {
	tmpcurr = ALLOC(NtCmdLineElement);
	if (tmpcurr == NULL) {
	    fprintf(stderr, "Out of Memory in globbing!\n");
	    while (tmphead) {
		tmpcurr = tmphead;
		tmphead = tmphead->next;
		free(tmpcurr->str);
		free(tmpcurr);
	    }
	    return;
	}
	memset (tmpcurr, 0, sizeof(*tmpcurr));
	tmpcurr->len = strlen(fd.cFileName);
	tmpcurr->str = ALLOC_N(char, tmpcurr->len+1);
	if (tmpcurr->str == NULL) {
	    fprintf(stderr, "Out of Memory in globbing!\n");
	    while (tmphead) {
		tmpcurr = tmphead;
		tmphead = tmphead->next;
		free(tmpcurr->str);
		free(tmpcurr);
	    }
	    return;
	}
	strcpy(tmpcurr->str, fd.cFileName);
	tmpcurr->flags |= NTMALLOC;
	if (tmptail) {
	    tmptail->next = tmpcurr;
	    tmpcurr->prev = tmptail;
	    tmptail = tmpcurr;
	}
	else {
	    tmptail = tmphead = tmpcurr;
	}
    } while(FindNextFile(fh, &fd));

    //
    // ok, now we\'ve got a list of files that matched the wildcard
    // specification. Put it in place of the pattern structure.
    //
    
    tmphead->prev = patt->prev;
    tmptail->next = patt->next;

    if (tmphead->prev)
	tmphead->prev->next = tmphead;

    if (tmptail->next)
	tmptail->next->prev = tmptail;

    //
    // Now get rid of the pattern structure
    //

    if (patt->flags & NTMALLOC)
	free(patt->str);
    // free(patt);  //TODO:  memory leak occures here. we have to fix it.
}
#else
a737 1
#endif
d750 1
a750 1
    
d800 1
a800 1
    // just return if we don\'t have a command line
d822 2
a823 2
    // When we\'ve finished, and it\'s an input command (meaning that it\'s
    // the processes argv), we\'ll do globing and then build the argument 
d858 1
a858 1
		// check to see if we\'re parsing an option switch
d865 1
a865 1
		// if we\'re not in a string, then we\'re finished with this
d878 1
a878 1
		// N.B. Don\'t glob if inside a single quoted string
d890 1
a890 1
		// (cmd.exe doesn\'t like raw newlines in strings...sigh).
d900 2
a901 2
		// if we\'re already in a string, see if this is the
		// terminating close-quote. If it is, we\'re finished with 
d903 1
a903 1
		// If we\'re not already in a string, start one.
d930 1
a930 1
	// when we get here, we\'ve got a pair of pointers to the element,
d941 1
a941 1
	// if it\'s an input vector element and it\'s enclosed by quotes, 
d982 1
a982 1
	// When we get here we\'ve finished parsing the command line. Now 
d1011 1
a1011 1
    // and ptr point to the area we\'ll consider the string table.
a1036 1

d1062 1
a1062 1
    // check to see if we\'ve got a directory
d1213 1
a1213 1
// This just free\'s the memory allocated by opendir
a1221 127


//
// 98.2% of this code was lifted from the OS2 port. (JCW)
//

#if 0
// add_suffix is in util.c too.
/*
 * Suffix appending for in-place editing under MS-DOS and OS/2 (and now NT!).
 *
 * Here are the rules:
 *
 * Style 0:  Append the suffix exactly as standard perl would do it.
 *           If the filesystem groks it, use it.  (HPFS will always
 *           grok it.  So will NTFS. FAT will rarely accept it.)
 *
 * Style 1:  The suffix begins with a '.'.  The extension is replaced.
 *           If the name matches the original name, use the fallback method.
 *
 * Style 2:  The suffix is a single character, not a '.'.  Try to add the 
 *           suffix to the following places, using the first one that works.
 *               [1] Append to extension.  
 *               [2] Append to filename, 
 *               [3] Replace end of extension, 
 *               [4] Replace end of filename.
 *           If the name matches the original name, use the fallback method.
 *
 * Style 3:  Any other case:  Ignore the suffix completely and use the
 *           fallback method.
 *
 * Fallback method:  Change the extension to ".$$$".  If that matches the
 *           original name, then change the extension to ".~~~".
 *
 * If filename is more than 1000 characters long, we die a horrible
 * death.  Sorry.
 *
 * The filename restriction is a cheat so that we can use buf[] to store
 * assorted temporary goo.
 *
 * Examples, assuming style 0 failed.
 *
 * suffix = ".bak" (style 1)
 *                foo.bar => foo.bak
 *                foo.bak => foo.$$$	(fallback)
 *                foo.$$$ => foo.~~~	(fallback)
 *                makefile => makefile.bak
 *
 * suffix = "~" (style 2)
 *                foo.c => foo.c~
 *                foo.c~ => foo.c~~
 *                foo.c~~ => foo~.c~~
 *                foo~.c~~ => foo~~.c~~
 *                foo~~~~~.c~~ => foo~~~~~.$$$ (fallback)
 *
 *                foo.pas => foo~.pas
 *                makefile => makefile.~
 *                longname.fil => longname.fi~
 *                longname.fi~ => longnam~.fi~
 *                longnam~.fi~ => longnam~.$$$
 *                
 */


static char suffix1[] = ".$$$";
static char suffix2[] = ".~~~";

#define ext (&buf[1000])

#define strEQ(s1,s2) (strcmp(s1,s2) == 0)

void
add_suffix(struct RString *str, char *suffix)
{
    int baselen;
    int extlen = strlen(suffix);
    char *s, *t, *p;
    int slen;
    char buf[1024];

    if (str->len > 1000)
        rb_fatal("Cannot do inplace edit on long filename (%d characters)", str->len);

    /* Style 0 */
    slen = str->len;
    str_cat(str, suffix, extlen);
    if (valid_filename(str->ptr)) return;

    /* Fooey, style 0 failed.  Fix str before continuing. */
    str->ptr[str->len = slen] = '\0';

    slen = extlen;
    t = buf; baselen = 0; s = str->ptr;
    while ( (*t = *s) && *s != '.') {
	baselen++;
	if (*s == '\\' || *s == '/') baselen = 0;
 	s++; t++;
    }
    p = t;

    t = ext; extlen = 0;
    while (*t++ = *s++) extlen++;
    if (extlen == 0) { ext[0] = '.'; ext[1] = 0; extlen++; }

    if (*suffix == '.') {        /* Style 1 */
        if (strEQ(ext, suffix)) goto fallback;
	strcpy(p, suffix);
    } else if (suffix[1] == '\0') {  /* Style 2 */
        if (extlen < 4) { 
	    ext[extlen] = *suffix;
	    ext[++extlen] = '\0';
        } else if (baselen < 8) {
   	    *p++ = *suffix;
	} else if (ext[3] != *suffix) {
	    ext[3] = *suffix;
	} else if (buf[7] != *suffix) {
	    buf[7] = *suffix;
	} else goto fallback;
	strcpy(p, ext);
    } else { /* Style 3:  Panic */
fallback:
	(void)memcpy(p, strEQ(ext, suffix1) ? suffix2 : suffix1, 5);
    }
    str_grow(str, strlen(buf));
    memcpy(str->ptr, buf, str->len);
}
#endif
d1229 1
a1229 1
    // if the file exists, then it\'s a valid filename!
d1237 1
a1237 1
    // It doesn\'t exist, so see if we can open it.
d1242 1
a1242 1
	_unlink (s);	// don\'t leave it laying around
a1247 1

d1253 1
a1253 1
// cannot be fdopen\'ed. This causes problems in the do_socket
d1255 1
a1255 1
// for the socket just created. We\'ll fake out an fdopen and see
a1397 1

d1432 1
a1432 1

d1441 1
a1441 1
// we don\'t really have permission to do something.
a1493 1

d1546 1
a1546 1
// the socket routines aren\'t used.
d1650 1
a1650 1
    // initalize the winsock interface and insure that it\'s
a2042 1

a2424 1

d2739 9
@


1.50
log
@	* win32/win32.c (mypopen): return error status instead of calling
	  rb_sys_fail().

	* win32/win32.c (do_spawn): ditto.
@
text
@d2273 1
a2273 1
wait_child(struct ChildRecord *child, int *stat_loc, DWORD timeout)
d2314 1
a2314 1
	    if ((pid = wait_child(child, stat_loc, 0))) return pid;
d2323 1
a2323 1
	ret = WaitForMultipleEvents(count, events, FALSE, timeout, TRUE);
d2335 1
a2335 1
	return wait_child(ChildRecord + ret, stat_loc, 0);
d2344 1
a2344 1
	while (!(pid = wait_child(child, stat_loc, timeout))) {
@


1.49
log
@	* hash.c (envix): use GET_ENVIRON and FREE_ENVIRON to get environment
	  variables list.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_key): ditto.

	* hash.c (env_values): ditto.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_value): ditto.

	* hash.c (env_each): ditto.

	* hash.c (env_inspect): ditto.

	* hash.c (env_to_a): ditto.

	* hash.c (env_size): ditto.

	* hash.c (env_empty_p): ditto.

	* hash.c (env_has_value): ditto.

	* hash.c (env_index): ditto.

	* hash.c (env_to_hash): ditto.

	* win32/win32.c (win32_getenv): use static buffer.

	* win32/win32.c, win32/win32.h (win32_get_environ): get environment
	  variables list. [new]

	* win32/win32.c, win32/win32.h (win32_free_environ): free environment
	  variables list. [new]

	* win32/win32.c (do_spawn): use CreateChild() instead of calling
	  CreateProcess() directly. Original patches comes from Patrick Cheng.

	* win32/win32.c (mypopen): ditto.

	* win32/win32.c (mypclose): use rb_syswait() instead of waiting in this
	  function.

	* win32/win32.c (waitpid): use wait_child() instead of _cwait().

	* win32/win32.c (CreateChild): added. [new]

	* win32/win32.c (wait_child): added. [new]

	* win32/win32.c (FindFirstChildSlot): added. [new]

	* win32/win32.c (FindChildSlot): added. [new]

	* win32/win32.c (FindPipedChildSlot): added. [new]

	* win32/win32.c (CloseChildHandle): added. [new]

	* win32/win32.c (FindFreeChildSlot): added. [new]
@
text
@d477 1
a477 1
	rb_sys_fail("mypopen: CreatePipe");
d490 1
a490 1
	rb_sys_fail("mypopen: CreateChild");
d505 1
a505 1
	rb_sys_fail("mypopen: _open_osfhandle");
d511 1
a511 1
	rb_sys_fail("mypopen: fdopen");
d554 1
a554 1
	rb_sys_fail("do_spawn: CreateChild");
@


1.48
log
@* win32/win32.c (isInternalCmd): check return value of NtMakeCmdVector (Tietew <tietew@@tietew.net>'s patch).
@
text
@d75 1
d298 1
a298 1
// popen stuff
d300 10
a309 3
//
// use these so I can remember which index is which
//
d311 8
a318 2
#define NtPipeRead  0	   // index of pipe read descriptor
#define NtPipeWrite 1	   // index of pipe write descriptor
d320 3
a322 1
#define NtPipeSize  1024   // size of pipe buffer
d324 41
a364 1
#define MYPOPENSIZE 256	   // size of book keeping structure
a365 5
struct {
    int inuse;
    int pid;
    FILE *pipe;
} MyPopenRecord[MYPOPENSIZE];
d452 1
a452 1
    int saved, reading;
d454 5
a458 26
    int pipes[2];
    int pid;
    int slot;
    static initialized = 0;

    //
    // if first time through, intialize our book keeping structure
    //

    if (!initialized++) {
	for (slot = 0; slot < MYPOPENSIZE; slot++)
	    MyPopenRecord[slot].inuse = FALSE;
    }

    //printf("mypopen %s\n", cmd);
    
    //
    // find a free popen slot
    //

    for (slot = 0; slot < MYPOPENSIZE && MyPopenRecord[slot].inuse; slot++)
	;

    if (slot > MYPOPENSIZE) {
	return NULL;
    }
d470 3
d474 4
a477 3
#if 0    
    if (_pipe(pipes, NtPipeSize, pipemode) == -1) {
	return NULL;
d481 1
a481 19

	//
	// we\'re reading from the pipe, so we must hook up the
	// write end of the pipe to the new processes stdout.
	// To do this we must save our file handle from stdout
	// by _dup\'ing it, then setting our stdout to be the pipe\'s 
	// write descriptor. We must also make the write handle 
	// inheritable so the new process can use it.

	if ((saved = _dup(fileno(stdout))) == -1) {
	    _close(pipes[NtPipeRead]);
	    _close(pipes[NtPipeWrite]);
	    return NULL;
	}
	if (_dup2 (pipes[NtPipeWrite], fileno(stdout)) == -1) {
	    _close(pipes[NtPipeRead]);
	    _close(pipes[NtPipeWrite]);
	    return NULL;
	}
d484 2
a485 5
	//
	// must be writing to the new process. Do the opposite of
	// the above, i.e. hook up the processes stdin to the read
	// end of the pipe.
	//
d487 4
a490 10
	if ((saved = _dup(fileno(stdin))) == -1) {
	    _close(pipes[NtPipeRead]);
	    _close(pipes[NtPipeWrite]);
	    return NULL;
	}
	if (_dup2(pipes[NtPipeRead], fileno(stdin)) == -1) {
	    _close(pipes[NtPipeRead]);
	    _close(pipes[NtPipeWrite]);
	    return NULL;
	}
d493 3
a495 14
    //
    // Start the new process. Must set _fileinfo to non-zero value
    // for file descriptors to be inherited. Reset after the process
    // is started.
    //

    if (NtHasRedirection(cmd)) {
      docmd:
	pid = spawnlpe(_P_NOWAIT, "cmd.exe", "/c", cmd, 0, environ);
	if (pid == -1) {
	    _close(pipes[NtPipeRead]);
	    _close(pipes[NtPipeWrite]);
	    return NULL;
	}
d498 2
a499 9
	char **vec;
	int vecc = NtMakeCmdVector(cmd, &vec, FALSE);

	//pid = spawnvpe (_P_NOWAIT, vec[0], vec, environ);
	pid = spawnvpe (_P_WAIT, vec[0], vec, environ);
	if (pid == -1) {
	    goto docmd;
	}
		Safefree (vec, vecc);
d502 4
a505 25
    if (reading) {

	//
	// We need to close our instance of the inherited pipe write
	// handle now that it's been inherited so that it will actually close
	// when the child process ends.
	//

	if (_close(pipes[NtPipeWrite]) == -1) {
	    _close(pipes[NtPipeRead]);
	    return NULL;
	}
	if (_dup2 (saved, fileno(stdout)) == -1) {
	    _close(pipes[NtPipeRead]);
	    return NULL;
	}
	_close(saved);

	// 
	// Now get a stream pointer to return to the calling program.
	//

	if ((fp = (FILE *) fdopen(pipes[NtPipeRead], mode)) == NULL) {
	    return NULL;
	}
a506 1
    else {
d508 4
a511 23
	//
	// need to close our read end of the pipe so that it will go 
	// away when the write end is closed.
	//

	if (_close(pipes[NtPipeRead]) == -1) {
	    _close(pipes[NtPipeWrite]);
	    return NULL;
	}
	if (_dup2 (saved, fileno(stdin)) == -1) {
	    _close(pipes[NtPipeWrite]);
	    return NULL;
	}
	_close(saved);

	// 
	// Now get a stream pointer to return to the calling program.
	//

	if ((fp = (FILE *) fdopen(pipes[NtPipeWrite], mode)) == NULL) {
	    _close(pipes[NtPipeWrite]);
	    return NULL;
	}
d514 1
a514 7
    //
    // do the book keeping
    //

    MyPopenRecord[slot].inuse = TRUE;
    MyPopenRecord[slot].pipe = fp;
    MyPopenRecord[slot].pid = pid;
d517 1
a517 24
#else
    {
		int p[2];

		BOOL fRet;
		HANDLE hInFile, hOutFile;
		LPCSTR lpApplicationName = NULL;
		LPTSTR lpCommandLine;
		LPTSTR lpCmd2 = NULL;
		DWORD  dwCreationFlags;
		STARTUPINFO aStartupInfo;
		PROCESS_INFORMATION     aProcessInformation;
		SECURITY_ATTRIBUTES sa;
		int fd;

		sa.nLength              = sizeof (SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;
		sa.bInheritHandle       = TRUE;

		fRet = CreatePipe(&hInFile, &hOutFile, &sa, 2048L);
		if (!fRet) {
			errno = GetLastError();
			rb_sys_fail("mypopen: CreatePipe");
		}
d519 1
a519 68
		memset(&aStartupInfo, 0, sizeof (STARTUPINFO));
		memset(&aProcessInformation, 0, sizeof (PROCESS_INFORMATION));
		aStartupInfo.cb = sizeof (STARTUPINFO);
		aStartupInfo.dwFlags    = STARTF_USESTDHANDLES;

		if (reading) {
			aStartupInfo.hStdInput  = GetStdHandle(STD_INPUT_HANDLE);
			aStartupInfo.hStdOutput = hOutFile;
		}
		else {
			aStartupInfo.hStdInput  = hInFile;
			aStartupInfo.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
		}
		aStartupInfo.hStdError  = GetStdHandle(STD_ERROR_HANDLE);

		dwCreationFlags = (NORMAL_PRIORITY_CLASS);

		lpCommandLine = cmd;
		if (NtHasRedirection(cmd) || isInternalCmd(cmd)) {
		  lpApplicationName = getenv("COMSPEC");
		  lpCmd2 = xmalloc(strlen(lpApplicationName) + 1 + strlen(cmd) + sizeof (" /c "));
		  sprintf(lpCmd2, "%s %s%s", lpApplicationName, " /c ", cmd);
		  lpCommandLine = lpCmd2;
		}

		fRet = CreateProcess(lpApplicationName, lpCommandLine, &sa, &sa,
			sa.bInheritHandle, dwCreationFlags, NULL, NULL, &aStartupInfo, &aProcessInformation);
		errno = GetLastError();

		if (lpCmd2)
			free(lpCmd2);

		if (!fRet) {
			CloseHandle(hInFile);
			CloseHandle(hOutFile);
			return NULL;
		}

		CloseHandle(aProcessInformation.hThread);

		if (reading) {
			fd = _open_osfhandle((long)hInFile,  (_O_RDONLY | pipemode));
			CloseHandle(hOutFile);
		}
		else {
			fd = _open_osfhandle((long)hOutFile, (_O_WRONLY | pipemode));
			CloseHandle(hInFile);
		}

		if (fd == -1) {
			CloseHandle(reading ? hInFile : hOutFile);
			CloseHandle(aProcessInformation.hProcess);
			rb_sys_fail("mypopen: _open_osfhandle");
		}

		if ((fp = (FILE *) fdopen(fd, mode)) == NULL) {
			_close(fd);
			CloseHandle(aProcessInformation.hProcess);
			rb_sys_fail("mypopen: fdopen");
		}

		MyPopenRecord[slot].inuse = TRUE;
		MyPopenRecord[slot].pipe  = fp;
		MyPopenRecord[slot].pid   = (int)aProcessInformation.hProcess;
		return fp;
    }
#endif
}
d524 1
a524 2
    int i;
    DWORD exitcode;
d526 2
a527 7
    Sleep(100);
    for (i = 0; i < MYPOPENSIZE; i++) {
	if (MyPopenRecord[i].inuse && MyPopenRecord[i].pipe == fp)
	    break;
    }
    if (i >= MYPOPENSIZE) {
                rb_fatal("Invalid file pointer passed to mypclose!\n");
a530 33
    // get the return status of the process
    //

#if 0
    if (_cwait(&exitcode, MyPopenRecord[i].pid, WAIT_CHILD) == -1) {
	if (errno == ECHILD) {
	    fprintf(stderr, "mypclose: nosuch child as pid %x\n", 
		    MyPopenRecord[i].pid);
	}
    }
#else
	for (;;) {
		if (GetExitCodeProcess((HANDLE)MyPopenRecord[i].pid, &exitcode)) {
			if (exitcode == STILL_ACTIVE) {
				//printf("Process is Active.\n");
				Sleep(100);
				TerminateProcess((HANDLE)MyPopenRecord[i].pid, 0); // ugly...
				continue;
			}
			else if (exitcode == 0) {
				//printf("done.\n");
				break;
			}
			else {
				//printf("never.\n");
				break;
			}
		}
	}
	CloseHandle((HANDLE)MyPopenRecord[i].pid);
#endif

    //
d533 1
a533 1

d538 1
a538 1
    // free this slot
d540 2
a541 6

    MyPopenRecord[i].inuse = FALSE;
    MyPopenRecord[i].pipe  = NULL;
    MyPopenRecord[i].pid   = 0;

    return (int)((exitcode & 0xff) << 8);
a547 6
typedef char* CHARP;
/*
 * The following code is based on the do_exec and do_aexec functions
 * in file doio.c
 */

d552 56
a607 8
    register char **a;
    register char *s;
    char **argv;
    int status = -1;
    char *shell, *cmd2;
    int mode = NtSyncProcess ? P_WAIT : P_NOWAIT;
    char quote;
    char *exec;
d609 14
a622 7
    /* save an extra exec if possible */
    if ((shell = getenv("RUBYSHELL")) != 0) {
	if (NtHasRedirection(cmd)) {
	    int  i;
	    char *p;
	    char *argv[4];
	    char *cmdline = ALLOC_N(char, (strlen(cmd) * 2 + 1));
d624 6
a629 9
	    p=cmdline;           
	    *p++ = '"';
	    for (s=cmd; *s;) {
		if (*s == '"') 
		    *p++ = '\\'; /* Escape d-quote */
		*p++ = *s++;
	    }
	    *p++ = '"';
	    *p   = '\0';
d631 3
a633 16
	    /* fprintf(stderr, "do_spawn: %s %s\n", shell, cmdline); */
	    argv[0] = shell;
	    argv[1] = "-c";
	    argv[2] = cmdline;
	    argv[4] = NULL;
	    status = spawnvpe(mode, argv[0], argv, environ);
	    /* return spawnle(mode, shell, shell, "-c", cmd, (char*)0, environ); */
	    free(cmdline);
	    return (int)((status & 0xff) << 8);
	} 
    }
    else if ((shell = getenv("COMSPEC")) != 0) {
	if (NtHasRedirection(cmd) /* || isInternalCmd(cmd) */) {
	    status = spawnle(mode, shell, shell, "/c", cmd, (char*)0, environ);
	    return (int)((status & 0xff) << 8);
	}
d636 8
a643 45
    argv = ALLOC_N(CHARP, (strlen(cmd) / 2 + 2));
    cmd2 = ALLOC_N(char, (strlen(cmd) + 1));
    strcpy(cmd2, cmd);
    a = argv;
    for (s = cmd2; *s;) {
	while (*s && ISSPACE(*s)) s++;
	if (*s == '"') {
	    quote = *s;
	    *(a++) = s++;
	    while (*s) {
		if (*s == '\\' && *(s + 1) == quote) {
		    memmove(s, s + 1, strlen(s) + 1);
		    s++;
		}
		else if (*s == quote) {
		    s++;
		    break;
		}
		s++;
	    }
	}
	else if (*s) {
	    *(a++) = s;
	    while (*s && !ISSPACE(*s)) s++;
	}
	if (*s)
	    *s++ = '\0';
    }
    *a = NULL;
    exec = NULL;
    if (argv[0]) {
	exec = ALLOC_N(char, (strlen(argv[0]) + 1));
	if (argv[0][0] == '"' && argv[0][strlen(argv[0]) - 1] == '"') {
	    strcpy(exec, &argv[0][1]);
	    exec[strlen(exec) - 1] = '\0';
	}
	else {
	    strcpy(exec, argv[0]);
	}
	if ((status = spawnvpe(mode, exec, argv, environ)) == -1) {
	    free(exec);
	    free(argv);
	    free(cmd2);
	    return -1;
	}
d645 2
a646 4
    free(exec);
    free(cmd2);
    free(argv);
    return (int)((status & 0xff) << 8);
d868 1
d2272 24
d2306 36
a2341 3
    RUBY_CRITICAL({
	if (wait_events((HANDLE)pid, timeout) == WAIT_OBJECT_0) {
	    pid = _cwait(stat_loc, pid, 0);
d2343 8
a2350 2
	else {
	    pid = 0;
d2352 2
a2353 4
    });
#if !defined __BORLANDC__
    if (pid) *stat_loc <<= 8;
#endif
d2361 1
a2361 1
{                                
d2427 6
d2436 3
a2438 1
    if ((unsigned int)pid == GetCurrentProcessId())
d2441 7
a2447 5
    if (sig == 2 && pid > 0) {
	if (!GenerateConsoleCtrlEvent(CTRL_C_EVENT, (DWORD)pid)) {
	    errno = GetLastError();
	    return -1;
	}
d2449 1
a2449 1
    else if (sig == 9 && pid > 0) {
d2452 16
a2467 7
	hProc = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
	if (hProc == NULL || hProc == INVALID_HANDLE_VALUE) {
	    errno = GetLastError();
	    return -1;
	}
	if (!TerminateProcess(hProc, 0)) {
	    errno = GetLastError();
d2469 1
a2469 3
	    return -1;
	}
	CloseHandle(hProc);
d2473 1
a2473 1
	return -1;
d2476 1
a2476 1
    return 0;
d2494 2
a2495 2
    char *curitem = NULL;	/* XXX threadead */
    DWORD curlen = 0;		/* XXX threadead */
d2498 4
a2501 2
    curlen = 512;
    curitem = ALLOC_N(char, curlen);
d2503 1
a2503 1
    needlen = GetEnvironmentVariable(name,curitem,curlen);
d2956 32
@


1.47
log
@* dln.c (dln_strerror): fix a bug that sometimes made null message on
  win32 (Tietew <tietew@@tietew.net>'s patch).

* win32/win32.c (mystrerror): ditto.
@
text
@d370 3
a372 3
        int i, fRet=0;
	char **vec;
        int vecc = NtMakeCmdVector(cmd, &vec, FALSE);
d374 8
a381 8
        for( i = 0; szInternalCmds[i] ; i++){
	    if(!strcasecmp(szInternalCmds[i], vec[0])){
		fRet = 1;
		break;
	    }
        }
 
	SafeFree (vec, vecc);
d383 3
a385 1
	return fRet;
@


1.46
log
@* win32/win32.c (NtCmdGlob): avoid VC++ warning.
* lib/mkmf.rb: add -I$(srcdir) to CPPFLAGS.
@
text
@d1835 2
a1836 1
	if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, &source, e, 0,
@


1.45
log
@* win32/win32.c (kill): add support of signal 9 on mswin32/mingw32.
@
text
@d1008 1
a1008 1
    rb_globi(buf, insert, (VALUE)&listinfo);
@


1.44
log
@forgot some checkins.
@
text
@d2562 2
a2563 3
#if 1
	if ((unsigned int)pid == GetCurrentProcessId())
		return raise(sig);
d2565 8
a2572 3
	if (sig == 2 && pid > 0)
		if (GenerateConsoleCtrlEvent(CTRL_C_EVENT, (DWORD)pid))
			return 0;
d2574 14
d2589 3
a2591 3
#else
	return 0;
#endif
@


1.43
log
@* win32/win32.c: use ruby's opendir on mingw32.
* win32/dir.h, dir.c, Makefile: ditto.
@
text
@d2828 1
a2828 1
    RUBY_CRITICAL(rb_protect((VALUE (*)())h->handler, (VALUE)h->arg, &h->status);
@


1.42
log
@* win32/win32.c (isUNCRoot): multibyte character support.
@
text
@a1323 1
#if !defined __MINGW32__
d1352 1
a1352 1
    if ((stat (filename, &sbuf) < 0 ||
a1508 1
#endif
@


1.41
log
@* win32/win32.c (win32_stat): WinNT/2k "//host/share" support.
@
text
@d2671 10
a2680 7
	if (p = strchr(path + 3, '\\')) {
	    if (!p[1])
		return 0;
	    if (p = strchr(p + 1, '\\')) {
		if (!p[1])
		    return 1;
	    } else
@


1.40
log
@rb_iglob -> rb_globi
@
text
@d2666 18
d2702 4
a2705 1
    if (*p == '\\' || *p == ':')
a2706 2
    else if (buf1[0] == '\\' && buf1[1] == '\\')
	strcat(buf1, "\\.");
@


1.39
log
@* win32/dir.h: replace missing/dir.h .
* win32/win32.h: ditto.
* win32/win32.c: ditto.
@
text
@d1008 1
a1008 1
    rb_iglob(buf, insert, (VALUE)&listinfo);
@


1.38
log
@* win32/win32.c (win32_stat): UNC support.
* dir.c (extract_path): fix "./*" problem.
@
text
@d28 1
a28 1
#include "dir.h"
d33 1
d1338 1
a1338 1
opendir(char *filename)
a1347 3
    char            root[PATHLEN];
    char            volname[PATHLEN];
    DWORD           serial, maxname, flags;
@


1.37
log
@* win32/win32.c (gettimeofday): use GetLocalTime() instead of ftime()
  for high-resolution timing.
@
text
@d2671 5
a2675 2
    const char *p = path;
    int ret;
d2677 5
a2681 3
    if ((isdirsep(*p) && (p++, TRUE)) || /* absolute path or UNC */
	(ISALPHA(*p) && p[1] == ':' && (p += 2, TRUE))) { /* has drive */
	if (isdirsep(*p)) p++;
d2683 11
a2693 10
    if (*p && (p = CharPrev(p, p + strlen(p)), isdirsep(*p))) {
	/* Win95/2000 fail with trailing path separator? */
	int len = p - path;
	char *s = ALLOCA_N(char, len + 1);
	memcpy(s, path, len);
	s[len] = '\0';
	path = s;
    }
    RUBY_CRITICAL(ret = stat(path, st));
    return ret;
@


1.36
log
@* win32/win32.c (myrename): fix error handling.
@
text
@d2498 3
a2500 1
    struct timeb tb;
d2502 11
a2512 3
    ftime(&tb);
    tv->tv_sec = tb.time;
    tv->tv_usec = tb.millitm * 1000;
d2514 1
a2514 1
	return 0;
@


1.35
log
@* win32/win32.c: fasten file I/O on mswin32/mingw32.

* win32/win32.h: ditto.

* rubysig.h: ditto.
@
text
@d2618 1
a2618 1
	printf("file to move doesn't exist");
@


1.34
log
@* win32/win32.c (win32_stat): replace stat for enable when pathname
  ends with '/' or '\' for mswin32 on Win9X / Win2k.

* win32/win32.h: ditto.

* ruby.h: ditto.

* dir.c (rb_glob_helper): ditto.

* file.c (rb_stat, rb_file_s_stat, eaccess, check3rdbyte): ditto.
@
text
@d38 5
a42 1
#if USE_INTERRUPT_WINSOCK
d44 3
a46 6
# if defined(_MSC_VER) && _MSC_VER <= 1000
/* VC++4.0 doesn't have this. */
extern DWORD WSAWaitForMultipleEvents(DWORD nevent, const HANDLE *events,
				      BOOL waitall, DWORD timeout,
				      BOOL alertable);
# endif
d48 1
d82 1
d108 4
d187 1
d218 1
d226 1
d235 3
d1687 7
a1727 14
_alloc_osfhnd(void)
{
    HANDLE hF = CreateFile("NUL", 0, 0, NULL, OPEN_ALWAYS, 0, NULL);
    int fh = _open_osfhandle((long)hF, 0);
    CloseHandle(hF);
    if (fh == -1)
        return fh;
#ifdef MSVCRT_THREADS
    EnterCriticalSection(&(_pioinfo(fh)->lock));
#endif
    return fh;
}

static int
d1745 10
a1754 6
    /* attempt to allocate a C Runtime file handle */
    if ((fh = _alloc_osfhnd()) == -1) {
	errno = EMFILE;		/* too many open files */
	_doserrno = 0L;		/* not an OS error */
	return -1;		/* return error to caller */
    }
d1756 3
a1758 2
    /* the file is open. now, set the info in _osfhnd array */
    _set_osfhnd(fh, osfhandle);
d1760 1
a1760 1
    fileflags |= FOPEN;		/* mark as open */
d1762 4
a1765 4
    _osfile(fh) = fileflags;	/* set osfile entry */
#ifdef MSVCRT_THREADS
    LeaveCriticalSection(&_pioinfo(fh)->lock);
#endif
d1811 4
a1814 4
#if !defined MSVCRT_THREADS
    _free_osfhnd(fileno(fp));
#endif
    fclose(fp);
d2049 2
a2050 1
    if ((r = select (nfds, rd, wr, ex, timeout)) == SOCKET_ERROR) {
d2097 3
d2112 2
a2113 1
    if ((r = accept (TO_SOCKET(s), addr, addrlen)) == INVALID_SOCKET)
d2128 2
a2129 1
    if ((r = bind (TO_SOCKET(s), addr, addrlen)) == SOCKET_ERROR)
d2143 2
a2144 1
    if ((r = connect (TO_SOCKET(s), addr, addrlen)) == SOCKET_ERROR)
d2159 2
a2160 1
    if ((r = getpeername (TO_SOCKET(s), addr, addrlen)) == SOCKET_ERROR)
d2174 2
a2175 1
    if ((r = getsockname (TO_SOCKET(s), addr, addrlen)) == SOCKET_ERROR)
d2187 2
a2188 1
    if ((r = getsockopt (TO_SOCKET(s), level, optname, optval, optlen)) == SOCKET_ERROR)
d2202 2
a2203 1
    if ((r = ioctlsocket (TO_SOCKET(s), cmd, argp)) == SOCKET_ERROR)
d2217 2
a2218 1
    if ((r = listen (TO_SOCKET(s), backlog)) == SOCKET_ERROR)
d2232 2
a2233 1
    if ((r = recv (TO_SOCKET(s), buf, len, flags)) == SOCKET_ERROR)
d2248 2
a2249 1
    if ((r = recvfrom (TO_SOCKET(s), buf, len, flags, from, fromlen)) == SOCKET_ERROR)
d2263 2
a2264 1
    if ((r = send (TO_SOCKET(s), buf, len, flags)) == SOCKET_ERROR)
d2279 2
a2280 1
    if ((r = sendto (TO_SOCKET(s), buf, len, flags, to, tolen)) == SOCKET_ERROR)
d2294 2
a2295 2
    if ((r = setsockopt (TO_SOCKET(s), level, optname, optval, optlen))
    		 == SOCKET_ERROR)
d2309 2
a2310 1
    if ((r = shutdown (TO_SOCKET(s), how)) == SOCKET_ERROR)
d2324 2
a2325 1
    if ((s = socket (af, type, protocol)) == INVALID_SOCKET) {
d2341 2
a2342 1
    if ((r = gethostbyaddr (addr, len, type)) == NULL)
d2356 2
a2357 1
    if ((r = gethostbyname (name)) == NULL)
d2371 2
a2372 1
    if ((r = gethostname (name, len)) == SOCKET_ERROR)
d2386 2
a2387 1
    if ((r = getprotobyname (name)) == NULL)
d2401 2
a2402 1
    if ((r = getprotobynumber (num)) == NULL)
d2416 2
a2417 1
    if ((r = getservbyname (name, proto)) == NULL)
d2431 2
a2432 1
    if ((r = getservbyport (port, proto)) == NULL)
d2479 8
a2486 2
    if (wait_events((HANDLE)pid, timeout) == WAIT_OBJECT_0) {
	pid = _cwait(stat_loc, pid, 0);
d2488 1
a2488 1
	*stat_loc <<= 8;
d2490 1
a2490 3
	return pid;
    }
    return 0;
d2622 13
a2634 18
    if (newatts != -1 && newatts & FILE_ATTRIBUTE_READONLY)
	SetFileAttributesA(newpath, newatts & ~ FILE_ATTRIBUTE_READONLY);

    if (!MoveFile(oldpath, newpath))
	res = -1;

    if (res) {
	switch (GetLastError()) {
	  case ERROR_ALREADY_EXISTS:
	  case ERROR_FILE_EXISTS:
	    if (IsWinNT()) {
		if (MoveFileEx(oldpath, newpath, MOVEFILE_REPLACE_EXISTING))
		    res = 0;
	    } else {
		for (;;) {
		    if (!DeleteFile(newpath) && GetLastError() != ERROR_FILE_NOT_FOUND)
			break;
		    else if (MoveFile(oldpath, newpath)) {
d2636 8
a2643 1
			break;
a2647 1
    }
d2649 5
a2653 4
    if (res)
	errno = GetLastError();
    else
	SetFileAttributes(newpath, oldatts);
d2662 1
d2676 2
a2677 1
    return stat(path, st);
d2751 1
a2751 1
void win32_disable_interrupt(void)
d2772 1
a2772 1
void win32_enable_interrupt(void)
d2787 1
a2787 1
    int userstate;
d2800 2
a2801 2
    h->userstate = 1;		/* never syscall after here */
    for (;;);			/* wait here in user state */
d2812 1
a2812 1
    harg->userstate = 0;
d2876 1
a2876 1
	    yield_until(harg.userstate);
d2893 5
a2897 1
    return wait_events(NULL, msec) != WAIT_TIMEOUT;
d2903 1
a2903 1
    win32_sleep(0);
d2907 2
a2908 1
void win32_enter_syscall(void)
d2910 11
a2920 3
    InterlockedExchange(&rb_trap_immediate, 1);
    catch_interrupt();
    win32_disable_interrupt();
d2923 2
a2924 1
void win32_leave_syscall(void)
d2926 11
a2936 3
    win32_enable_interrupt();
    catch_interrupt();
    InterlockedExchange(&rb_trap_immediate, 0);
@


1.33
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_options): new method to give an option values.

* parse.y (cond0): disable special treating of integer literal in
  conditional unless option -e is supplied.  changes current
  behavior.  experimental.

* parse.y (cond0): give warning for string/integer literals and
  dot operators in conditionals unless option -e is supplied.

* re.c (rb_reg_equal): all option flags should be same to be equal.

* error.c (Init_Exception): make Interrupt a subclass of
  SignalException.
@
text
@d32 1
d2614 20
@


1.32
log
@*** empty log message ***
@
text
@d782 1
a782 1
	while (*s && isspace(*s)) s++;
d800 1
a800 1
	    while (*s && !isspace(*s)) s++;
d1086 1
a1086 1
    while(ptr >= cmdline && isspace(*ptr))
d1106 1
a1106 1
	while(isspace(*ptr))
d1343 1
a1343 1
	(!isalpha(filename[0]) || filename[1] != ':' || filename[2] != '\0' ||
@


1.31
log
@matz
@
text
@d360 1
a360 1
	    if(!strcmp(szInternalCmds[i], vec[0])){
d738 2
d783 16
a798 1
	if (*s)
d800 2
a801 1
	while (*s && !isspace(*s)) s++;
d806 1
d808 10
a817 1
	if ((status = spawnvpe(mode, argv[0], argv, environ)) == -1) {
d823 1
@


1.31.2.1
log
@Sat Feb  3 00:48:50 2001  Usaku Nakamura  <usa@@osb.att.ne.jp>

	* win32/win32.c (isInternalCmd): ignore case for shell's internal
	  command. (marge from HEAD)
@
text
@d360 1
a360 1
	    if(!strcasecmp(szInternalCmds[i], vec[0])){
@


1.31.2.2
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_equal): all option flags should be same to be equal.
@
text
@d780 1
a780 1
	while (*s && ISSPACE(*s)) s++;
d783 1
a783 1
	while (*s && !ISSPACE(*s)) s++;
d1057 1
a1057 1
    while(ptr >= cmdline && ISSPACE(*ptr))
d1077 1
a1077 1
	while(ISSPACE(*ptr))
d1314 1
a1314 1
	(!ISALPHA(filename[0]) || filename[1] != ':' || filename[2] != '\0' ||
@


1.31.2.3
log
@* win32/win32.c (win32_stat): replace stat for enable when pathname
  ends with '/' or '\' for mswin32 on Win9X / Win2k.

* win32/win32.h: ditto.

* ruby.h: ditto.

* dir.c (rb_glob_helper): ditto.

* file.c (rb_stat, rb_file_s_stat, eaccess, check3rdbyte): ditto.
@
text
@a31 1
#define isdirsep(x) ((x) == '/' || (x) == '\\')
a2583 20
}

int
win32_stat(const char *path, struct stat *st)
{
    const char *p = path;

    if ((isdirsep(*p) && (p++, TRUE)) || /* absolute path or UNC */
	(ISALPHA(*p) && p[1] == ':' && (p += 2, TRUE))) { /* has drive */
	if (isdirsep(*p)) p++;
    }
    if (*p && (p = CharPrev(p, p + strlen(p)), isdirsep(*p))) {
	/* Win95/2000 fail with trailing path separator? */
	int len = p - path;
	char *s = ALLOCA_N(char, len + 1);
	memcpy(s, path, len);
	s[len] = '\0';
	path = s;
    }
    return stat(path, st);
@


1.31.2.4
log
@* win32/win32.c (myrename): fix error handling.
@
text
@d2549 1
a2549 1
	errno = GetLastError();
@


1.31.2.5
log
@* win32/win32.c (gettimeofday): use GetLocalTime() instead of ftime()
  for high-resolution timing.
@
text
@d2429 1
a2429 3
    SYSTEMTIME st;
    time_t t;
    struct tm tm;
d2431 3
a2433 11
    GetLocalTime(&st);
    tm.tm_sec = st.wSecond;
    tm.tm_min = st.wMinute;
    tm.tm_hour = st.wHour;
    tm.tm_mday = st.wDay;
    tm.tm_mon = st.wMonth - 1;
    tm.tm_year = st.wYear - 1900;
    tm.tm_isdst = -1;
    t = mktime(&tm);
    tv->tv_sec = t;
    tv->tv_usec = st.wMilliseconds * 1000;
d2435 1
a2435 1
    return 0;
@


1.31.2.6
log
@* win32/win32.c (win32_stat): UNC support.
* dir.c (extract_path): fix "./*" problem.
@
text
@d2600 1
a2600 5
    const char *p;
    char *buf1 = ALLOCA_N(char, strlen(path) + 1);
    char *buf2 = ALLOCA_N(char, MAXPATHLEN);
    char *s;
    int len;
d2602 3
a2604 5
    for (p = path, s = buf1; *p; p++, s++) {
	if (*p == '/')
	    *s = '\\';
	else
	    *s = *p;
d2606 9
a2614 11
    *s = '\0';
    len = strlen(buf1);
    p = CharPrev(buf1, buf1 + len);
    if (*p == '\\' || *p == ':')
	strcat(buf1, ".");
    else if (buf1[0] == '\\' && buf1[1] == '\\')
	strcat(buf1, "\\.");
    if (_fullpath(buf2, buf1, MAXPATHLEN))
	return stat(buf2, st);
    else
	return -1;
@


1.31.2.7
log
@* win32/win32.c (win32_stat): WinNT/2k "//host/share" support.
@
text
@a2596 18
static int
isUNCRoot(const char *path)
{
    if (path[0] == '\\' && path[1] == '\\') {
	const char *p;
	if (p = strchr(path + 3, '\\')) {
	    if (!p[1])
		return 0;
	    if (p = strchr(p + 1, '\\')) {
		if (!p[1])
		    return 1;
	    } else
		return 1;
	}
    }
    return 0;
}

d2615 1
a2615 4
    if (isUNCRoot(buf1)) {
	if (*p != '\\')
	    strcat(buf1, "\\");
    } else if (*p == '\\' || *p == ':')
d2617 2
@


1.31.2.8
log
@* win32/win32.c (isUNCRoot): multibyte character support.
@
text
@d2602 7
a2608 10
	for (p = path + 3; *p; p = CharNext(p)) {
	    if (*p == '\\')
		break;
	}
	if (p[0] && p[1]) {
	    for (p++; *p; p = CharNext(p)) {
		if (*p == '\\')
		    break;
	    }
	    if (!p[0] || !p[1])
@


1.31.2.9
log
@* win32/win32.c: use ruby's opendir on mingw32.
* missing/dir.h, dir.c, Makefile: ditto.
@
text
@d1281 1
d1313 1
a1313 1
    if ((win32_stat (filename, &sbuf) < 0 ||
d1470 1
@


1.31.2.10
log
@* win32/win32.c (opendir): add const directive.
@
text
@d1294 1
a1294 1
opendir(const char *filename)
@


1.31.2.11
log
@* dln.c (dln_strerror): fix a bug that sometimes made null message on
  win32 (Tietew <tietew@@tietew.net>'s patch).

* win32/win32.c (mystrerror): ditto.
@
text
@d1797 1
a1797 2
	if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
			  FORMAT_MESSAGE_IGNORE_INSERTS, &source, e, 0,
@


1.31.2.12
log
@* win32/win32.c (isInternalCmd): check return value of NtMakeCmdVector (Tietew <tietew@@tietew.net>'s patch).
@
text
@d356 3
a358 3
    int i, fRet=0;
    char **vec;
    int vecc = NtMakeCmdVector(cmd, &vec, FALSE);
d360 8
a367 8
    if (vecc == 0)
	return 0;
    for( i = 0; szInternalCmds[i] ; i++){
	if(!strcasecmp(szInternalCmds[i], vec[0])){
	    fRet = 1;
	    break;
	}
    }
d369 1
a369 3
    SafeFree(vec, vecc);

    return fRet;
@


1.31.2.13
log
@	* hash.c (envix): merge from 1.7: use GET_ENVIRON and FREE_ENVIRON to
	  get environment variables list.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_key): ditto.

	* hash.c (env_values): ditto.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_value): ditto.

	* hash.c (env_each): ditto.

	* hash.c (env_inspect): ditto.

	* hash.c (env_to_a): ditto.

	* hash.c (env_size): ditto.

	* hash.c (env_empty_p): ditto.

	* hash.c (env_has_value): ditto.

	* hash.c (env_index): ditto.

	* hash.c (env_to_hash): ditto.

	* win32/win32.c (win32_getenv): merge from 1.7: use static buffer.

	* win32/win32.c, win32/win32.h (win32_get_environ): merge from 1.7:
	  get environment variables list.

	* win32/win32.c, win32/win32.h (win32_free_environ): merge from 1.7:
	  free environment variables list.

	* win32/Makefile.sub: merge from 1.7: add -DLIBRUBY_SO to CPPFLAGS.
@
text
@d2527 2
a2528 2
    static char *curitem = NULL;
    static DWORD curlen = 0;
d2531 2
a2532 4
    if (curitem == NULL || curlen == 0) {
	curlen = 512;
	curitem = ALLOC_N(char, curlen);
    }
d2534 1
a2534 1
    needlen = GetEnvironmentVariable(name, curitem, curlen);
a2962 32
}

char **win32_get_environ(void)
{
    char *envtop, *env;
    char **myenvtop, **myenv;
    int num;

    envtop = GetEnvironmentStrings();
    for (env = envtop, num = 0; *env; env += strlen(env) + 1)
	if (*env != '=') num++;

    myenvtop = ALLOC_N(char*, num + 1);
    for (env = envtop, myenv = myenvtop; *env; env += strlen(env) + 1) {
	if (*env != '=') {
	    *myenv = ALLOC_N(char, strlen(env) + 1);
	    strcpy(*myenv, env);
	    myenv++;
	}
    }
    *myenv = NULL;
    FreeEnvironmentStrings(envtop);

    return myenvtop;
}

void win32_free_environ(char **env)
{
    char **t = env;

    while (*t) free(*t++);
    free(env);
@


1.31.2.14
log
@* ext/extmk.rb.in (create_makefile): remove unnecessary -L option from
  LIBS macro.
* ext/extmk.rb.in (extmake): default $LIBPATH to $libdir.
* win32/win32.c (NtCmdGlob): avoid VC++ warning.
@
text
@d967 1
a967 1
    rb_iglob(buf, (void (*) _((const char*, VALUE)))insert, (VALUE)&listinfo);
@


1.31.2.15
log
@* win32/win32.c: forgot to commit.
@
text
@a26 3
#ifdef __MINGW32__
#include <mswsock.h>
#endif
@


1.31.2.16
log
@* win32/win32.c (insert): fix prototype for ANSI C.
@
text
@d927 1
a927 1
insert(const char *path, VALUE vinfo)
a929 1
    ListInfo *listinfo = (ListInfo *)vinfo;
@


1.31.2.17
log
@* win32/win32.c (NtCmdGlob): get rid of cast.
@
text
@d971 1
a971 1
    rb_iglob(buf, insert, (VALUE)&listinfo);
@


1.31.2.18
log
@* win32/win32.c (rb_w32_stat): fix buffer overflow. (ruby-bugs:PR#329)
@
text
@d2629 1
a2629 1
    char *buf1 = ALLOCA_N(char, strlen(path) + 2);
@


1.31.2.19
log
@* dir.c (rb_glob): add prototype of 2nd argument to avoid VC++ warning.

* dir.c (push_pattern): add const directive to 1st argument.

* dir.c: prototype; push_pattern() to avoid VC++ warning.

* ext/tcltklib/tcltklib.c: prototype; _timer_for_tcl() and ip_ruby()
  to avoid VC++ warning.

* win32/win32.c (win32_stat): remove S_IWGRP and S_IWOTH bits from
  st_mode.

* win32/win32.h (S_I*): define if not defined.
@
text
@a2632 1
    int ret;
d2648 2
a2649 7
    if (_fullpath(buf2, buf1, MAXPATHLEN)) {
	ret = stat(buf2, st);
	if (ret == 0) {
	    st->st_mode &= ~(S_IWGRP | S_IWOTH);
	}
	return ret;
    }
@


1.31.2.20
log
@* win32/win32.c (do_spawn): fix the bug which the environment variables
  had not spread.
@
text
@a743 1
    char **env = NULL;
a744 1
    env = win32_get_environ();
d768 1
a768 1
	    status = spawnvpe(mode, argv[0], argv, env);
a770 1
	    if (env) win32_free_environ(env);
d776 1
a776 2
	    status = spawnle(mode, shell, shell, "/c", cmd, (char*)0, env);
	    if (env) win32_free_environ(env);
d795 1
a795 1
	if ((status = spawnvpe(mode, argv[0], argv, env)) == -1) {
a797 1
	    if (env) win32_free_environ(env);
a802 1
    if (env) win32_free_environ(env);
@


1.31.2.21
log
@* win32/win32.c (opendir): Corresponds to the unjust path containing ".
                   (win32_stat) : ditto.
@
text
@d1314 2
a1315 2
    struct _finddata_t fd;
    long               fh;
d1354 2
a1355 2
    fh = _findfirst(scanname, &fd);
    if (fh == -1) {
d1364 1
a1364 1
    idx = strlen(fd.name)+1;
d1366 1
a1366 1
    strcpy(p->start, fd.name);
d1375 2
a1376 2
    while (_findnext(fh, &fd) == 0) {
	len = strlen(fd.name);
d1389 1
a1389 1
	strcpy(&p->start[idx], fd.name);
d1393 1
a1393 1
    _findclose(fh);
a2649 6
    if( '\"' == *(--s) )
    {
	errno = EBADF;
	return -1;
    }

@


1.31.2.22
log
@	* ext/socket/socket.c (sock_new): duplicate underlying socket
	  handle not only descriptor.  [ruby-talk:40015]

	* ext/socket/socket.c (bsock_close_read, bsock_close_write): not
	  use myfdclose().

	* win32/win32.c, win32/win32.h (myfddup, myfdclose): delete.
@
text
@d1766 21
@


1.31.2.23
log
@* win32/win32.c (win32_fclose, win32_close): use closesocket()
  for socket.  [ruby-win32:382]

* win32/win32.c (StartSockets): set NtSocketsInitialized.

* win32/win32.h: prototypes; win32_fclose, win32_close
@
text
@a36 4
#undef fclose
#undef close
#undef setsockopt

d1965 1
a1965 1
    if (!NtSocketsInitialized) {
d2016 1
a2016 1
    int iSockOpt;
a2045 1
    NtSocketsInitialized = 1;
d2055 1
a2055 1
    if (!NtSocketsInitialized) {
d2070 1
a2070 1
    if (!NtSocketsInitialized) {
d2084 1
a2084 1
    if (!NtSocketsInitialized) {
d2099 1
a2099 1
    if (!NtSocketsInitialized) {
d2113 1
a2113 1
    if (!NtSocketsInitialized) {
d2125 1
a2125 1
    if (!NtSocketsInitialized) {
d2139 1
a2139 1
    if (!NtSocketsInitialized) {
d2153 1
a2153 1
    if (!NtSocketsInitialized) {
d2167 1
a2167 1
    if (!NtSocketsInitialized) {
d2182 1
a2182 1
    if (!NtSocketsInitialized) {
d2196 1
a2196 1
    if (!NtSocketsInitialized) {
d2211 1
a2211 1
    if (!NtSocketsInitialized) {
d2225 1
a2225 1
    if (!NtSocketsInitialized) {
d2240 1
a2240 1
    if (!NtSocketsInitialized) {
d2254 1
a2254 1
    if (!NtSocketsInitialized) {
d2270 1
a2270 1
    if (!NtSocketsInitialized) {
d2284 1
a2284 1
    if (!NtSocketsInitialized) {
d2298 1
a2298 1
    if (!NtSocketsInitialized) {
d2312 1
a2312 1
    if (!NtSocketsInitialized) {
d2326 1
a2326 1
    if (!NtSocketsInitialized) {
d2340 1
a2340 1
    if (!NtSocketsInitialized) {
d2354 1
a2354 1
    if (!NtSocketsInitialized) {
a2997 34
}

int
win32_fclose(FILE *fp)
{
    int fd = fileno(fp);
    SOCKET sock = TO_SOCKET(fd);

    if (fflush(fp)) return -1;
    if (!is_socket(sock)) {
	return fclose(fp);
    }
    _set_osfhnd(fd, (SOCKET)INVALID_HANDLE_VALUE);
    fclose(fp);
    if (closesocket(sock) == SOCKET_ERROR) {
	errno = WSAGetLastError();
	return -1;
    }
    return 0;
}

int
win32_close(int fd)
{
    SOCKET sock = TO_SOCKET(fd);

    if (!is_socket(sock)) {
	return _close(fd);
    }
    if (closesocket(sock) == SOCKET_ERROR) {
	errno = WSAGetLastError();
	return -1;
    }
    return 0;
@


1.30
log
@matz
@
text
@d1977 5
@


1.29
log
@eban
@
text
@d1770 1
a1770 1
#if !defined __MINGW32__
@


1.28
log
@matz
@
text
@d964 1
a964 1
    rb_glob(buf, insert, (VALUE)&listinfo);
@


1.27
log
@matz
@
text
@d1729 2
d1755 2
a1756 2
FILE *
myfdopen (int fd, const char *mode)
d1758 4
a1761 2
    if (is_socket((SOCKET)fd)) {
	int fh;
d1763 1
a1763 6
	fh = my_open_osfhandle((SOCKET)fd, O_RDWR|O_BINARY);
	return _fdopen(fh, mode);		// return file pointer
    }
    else {
	return (_fdopen(fd, mode));
    }
a2057 1
    int trap_immediate = rb_trap_immediate;
d2064 1
a2064 1
    return r;
d2077 1
a2077 1
    if ((r = bind (s, addr, addrlen)) == SOCKET_ERROR)
d2091 1
a2091 1
    if ((r = connect (s, addr, addrlen)) == SOCKET_ERROR)
a2124 2
#undef getsockopt

d2132 1
a2132 1
    if ((r = getsockopt (s, level, optname, optval, optlen)) == SOCKET_ERROR)
d2160 1
a2160 1
    if ((r = listen (s, backlog)) == SOCKET_ERROR)
d2232 1
a2232 1
    if ((r = setsockopt (s, level, optname, optval, optlen))
d2265 1
a2265 1
    return s;
@


1.26
log
@eban
@
text
@d37 26
d75 1
d106 7
a112 4
HANDLE rb_CurrentProcessHandle;
HANDLE rb_MainThreadHandle;
DWORD rb_MainThreadId;
HANDLE rb_InterruptEvent;
d116 1
a117 1
    HANDLE proc = rb_CurrentProcessHandle;
d119 4
a122 1
    if (!DuplicateHandle(proc, GetCurrentThread(), proc, &h,
d134 2
a135 2
int
flock(int fd, int oper)
d139 2
a140 1
    HANDLE fh;
a141 1
    fh = (HANDLE)_get_osfhandle(fd);
d144 21
a164 23
    if(IsWinNT()) {
        switch(oper) {
        case LOCK_SH:       /* shared lock */
            LK_ERR(LockFileEx(fh, 0, 0, LK_LEN, 0, &o),i);
            break;
        case LOCK_EX:       /* exclusive lock */
            LK_ERR(LockFileEx(fh, LOCKFILE_EXCLUSIVE_LOCK, 0, LK_LEN, 0, &o),i);
            break;
        case LOCK_SH|LOCK_NB:   /* non-blocking shared lock */
            LK_ERR(LockFileEx(fh, LOCKFILE_FAIL_IMMEDIATELY, 0, LK_LEN, 0, &o),i);
            break;
        case LOCK_EX|LOCK_NB:   /* non-blocking exclusive lock */
            LK_ERR(LockFileEx(fh,
                   LOCKFILE_EXCLUSIVE_LOCK|LOCKFILE_FAIL_IMMEDIATELY,
                   0, LK_LEN, 0, &o),i);
	    if(errno == EDOM) errno = EWOULDBLOCK;
            break;
        case LOCK_UN:       /* unlock lock */
	    if (UnlockFileEx(fh, 0, LK_LEN, 0, &o)) {
		i = 0;
	    }
	    else {
		/* GetLastError() must returns `ERROR_NOT_LOCKED' */
d166 9
a174 7
	    }
	    if(errno == EDOM) errno = EWOULDBLOCK;
            break;
        default:            /* unknown */
            errno = EINVAL;
            break;
        }
d176 13
a188 9
    else if(IsWin95()) {
        switch(oper) {
        case LOCK_EX:
	    while(i == -1) {
	        LK_ERR(LockFile(fh, 0, 0, LK_LEN, 0), i);
		if(errno != EDOM && i == -1) break;
	    }
	    break;
	case LOCK_EX | LOCK_NB:
d190 16
a205 10
	    if(errno == EDOM) errno = EWOULDBLOCK;
            break;
        case LOCK_UN:
            LK_ERR(UnlockFile(fh, 0, 0, LK_LEN, 0), i);
	    if(errno == EDOM) errno = EWOULDBLOCK;
            break;
        default:
            errno = EINVAL;
            break;
        }
d213 16
d1970 3
a1973 1
    int trap_immediate = rb_trap_immediate;
d1992 12
a2003 2
    if (trap_immediate)
	TRAP_END;
d2007 1
a2007 1
	case WSAEINTR:
a2011 2
    if (trap_immediate)
	TRAP_BEG;
d2029 1
a2029 1
        rb_fatal ("Unable to locate winsock library!\n");
d2031 1
a2031 1
        rb_fatal("could not find version 1 of winsock dll\n");
d2034 1
a2034 1
        rb_fatal("could not find version 1 of winsock dll\n");
d2038 1
a2038 1
	iSockOpt = SO_SYNCHRONOUS_NONALERT;
d2043 1
a2043 1
		(char *)&iSockOpt, sizeof(iSockOpt));
d2045 6
a2050 4
    rb_CurrentProcessHandle = GetCurrentProcess();
    rb_MainThreadHandle = GetCurrentThreadHandle();
    rb_MainThreadId = GetCurrentThreadId();
    rb_InterruptEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
d2055 1
a2055 1
SOCKET 
a2063 2
    if (trap_immediate)
	TRAP_END;
a2065 2
    if (trap_immediate)
	TRAP_BEG;
d2412 1
a2412 1
    if (WaitForSingleObject((HANDLE) pid, timeout) == WAIT_OBJECT_0) {
d2557 16
a2572 14
    if (res == 0 || (GetLastError() != ERROR_ALREADY_EXISTS
		  && GetLastError() != ERROR_FILE_EXISTS))
	goto done;

    if (IsWinNT()) {
	if (MoveFileEx(oldpath, newpath, MOVEFILE_REPLACE_EXISTING))
	    res = 0;
    } else {
	for (;;) {
	    if (!DeleteFile(newpath) && GetLastError() != ERROR_FILE_NOT_FOUND)
		break;
	    else if (MoveFile(oldpath, newpath)) {
		  res = 0;
		  break;
a2576 1
done:
d2616 5
a2620 1
static int win32_thread_exclusive(void)
d2622 3
a2624 1
    if (GetCurrentThreadId() == rb_MainThreadId) return FALSE;
d2626 13
a2638 2
    SuspendThread(rb_MainThreadHandle);
    return TRUE;
d2641 1
a2641 1
void win32_thread_resume_main(void)
d2643 8
a2650 2
    if (GetCurrentThreadId() != rb_MainThreadId)
	ResumeThread(rb_MainThreadHandle);
d2653 4
a2656 1
static void win32_suspend_self(void)
d2658 17
a2674 1
    SuspendThread(GetCurrentThread());
d2677 1
a2677 1
static void win32_call_handler(int arg, void (*handler)(int), CONTEXT ctx)
d2679 28
a2706 3
    handler(arg);
    ctx.ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT;
    SetThreadContext(rb_MainThreadHandle, &ctx);
d2709 4
a2712 1
static int catch_interrupt(unsigned long msec)
d2714 6
a2719 1
    return !WaitForSingleObject(rb_InterruptEvent, msec);
d2722 1
a2722 1
int win32_interruptible(void)
d2724 9
a2732 3
    if (catch_interrupt(0)) return TRUE;
    SetEvent(rb_InterruptEvent);
    return FALSE;
d2737 5
a2741 1
    if (!win32_thread_exclusive()) return FALSE;
d2743 3
a2745 4
    if (!catch_interrupt(0)) {
	SetEvent(rb_InterruptEvent);
	return FALSE;
    }
d2747 1
a2747 1
    {
d2750 3
d2755 10
a2764 9
	GetThreadContext(rb_MainThreadHandle, &ctx);
#ifdef _M_IX86
	{
	    DWORD *esp = (DWORD *)(ctx.Esp - sizeof(CONTEXT));
	    *(CONTEXT *)esp = ctx;
	    *--esp = (DWORD)handler;
	    *--esp = arg;
	    *--esp = ctx.Eip;
	    ctx.Esp = (DWORD)esp;
d2766 1
a2766 4
	ctx.Eip = (DWORD)win32_call_handler;
#else
#error
#endif
d2769 19
a2787 1
	SetThreadContext(rb_MainThreadHandle, &ctx);
d2789 3
a2791 1
    ResumeThread(rb_MainThreadHandle);
d2796 6
a2801 1
void win32_sleep(unsigned long msec)
d2803 95
a2897 1
    int trap_immediate = rb_trap_immediate;
d2899 1
a2899 5
    if (trap_immediate)
	TRAP_END;
    catch_interrupt(msec);
    if (trap_immediate)
	TRAP_BEG;
@


1.25
log
@matz
@
text
@d656 1
a656 1
    return exitcode;
d676 1
a676 1
    int status;
d706 1
a706 1
	    return status;
d711 2
a712 2
	  do_comspec_shell:
	    return spawnle(mode, shell, shell, "/c", cmd, (char*)0, environ);
d738 1
a738 1
    return status;
d2347 3
@


1.24
log
@matz
@
text
@d1727 2
a1728 2
char * 
mystrerror(int e) 
d1735 1
d1742 5
a1746 1
	    strcpy (buffer, "Unknown Error");
a1750 1
	
@


1.23
log
@matz
@
text
@a1906 1
    fd_set trap;
a1926 7
    if (ex)
	trap = *ex;
    else
	trap.fd_count = 0;
    if (trap.fd_count < FD_SETSIZE)
	trap.fd_array[trap.fd_count++] = rb_InterruptEvent;
    // else unable to catch interrupt.
d1929 1
a1929 1
    if ((r = select (nfds, rd, wr, &trap, timeout)) == SOCKET_ERROR) {
@


1.22
log
@eban
@
text
@d78 16
d179 2
a180 1
NtInitialize(int *argc, char ***argv) {
d1235 1
a1235 1
opendir(const char *filename)
d1907 1
d1928 7
d1937 1
a1937 1
    if ((r = select (nfds, rd, wr, ex, timeout)) == SOCKET_ERROR) {
d1951 2
a1952 1
StartSockets () {
d1979 5
d2546 87
@


1.21
log
@eban
@
text
@d876 1
a876 1
    char *p, *pend, *pb;
d883 5
a887 6
    p = patt->str;
    pend = p + patt->len;
    pb = buf;
    for (; p < pend; p = CharNext(p))
	*pb++ = *p == '\\' ? '/' : *p;
    buf[patt->len] = 0;
@


1.20
log
@eban
@
text
@d876 1
d883 5
a887 1
    strncpy(buf, patt->str, patt->len);
@


1.19
log
@matz
@
text
@d1561 4
d1569 1
a1569 1
#ifdef _MT
d1605 1
a1605 1
#ifdef _MT
d1642 1
a1642 1
#ifdef _MT
@


1.18
log
@eban
@
text
@d1565 1
d1568 1
d1601 1
d1603 1
d1638 3
a1640 1
//    _unlock_fhandle(fh);
@


1.17
log
@matz
@
text
@d2491 2
a2492 2
	tmbuf->cutime = 0;
	tmbuf->cstime = 0;
d2495 4
a2498 4
	tmbuf->utime = clock();
	tmbuf->stime = 0;
	tmbuf->cutime = 0;
	tmbuf->cstime = 0;
@


1.16
log
@eban
@
text
@a157 11
#if 0
void
sleep(unsigned int len)
{
	time_t end;

	end = time((time_t *)0) + len;
	while (time((time_t *)0) < end)
		;
}
#endif
d2471 30
@


1.15
log
@eban
@
text
@d2435 48
@


1.14
log
@matz
@
text
@d2414 2
a2415 2
    static char *curitem = NULL;	/* XXX threadead */
    static DWORD curlen = 0;		/* XXX threadead */
d2417 3
a2419 4
    if (!curitem) {
	curlen = 512;
	curitem = ALLOC_N(char, curlen);
    }
@


1.13
log
@eban
@
text
@d14 1
d1888 1
d1907 2
d1917 2
d1958 1
d1963 2
d1967 2
@


1.12
log
@matz
@
text
@d875 7
d885 1
d889 8
a896 1
    rb_glob(patt->str, insert, (VALUE)&listinfo);
@


1.11
log
@see ChangeLog.
@
text
@d1634 2
a1635 2
FILE *
myfdopen (int fd, const char *mode)
a1639 4
    int fh;
    extern int errno;

    //fprintf(stderr, "myfdopen()\n");
d1641 2
a1642 2
	optlen = sizeof(sockbuf);
    retval = getsockopt((SOCKET)fd, SOL_SOCKET, SO_TYPE, sockbuf, &optlen);
d1648 1
a1648 1
	    return (_fdopen(fd, mode));
d1655 9
d1665 5
a1669 1
    return _fdopen(fh, mode);		// return file pointer
d1796 19
d1834 30
d1869 4
d1880 10
a1894 16
	    break;
	case WSAENOTSOCK:
	    // assume normal files are always readable/writable
	    // fake read/write fd_set and return value
	    r = 0;
	    if (rd) r += rd->fd_count;
	    if (wr) r += wr->fd_count;
	    if (ex && ex->fd_count > 0) {
		// exceptional condition never happen for normal files
		if (r > 0)
		    ex->fd_count = 0;
		else {
		    errno = EBADF;
		    r = SOCKET_ERROR;
		}
	    }
@


1.10
log
@support mingw32.
@
text
@d197 1
a197 1
    int len = 200;
d590 1
a590 1
    int exitcode;
d774 1
d848 48
d965 2
a975 30
    //
    // check for newlines and formfeeds. If we find any, make a new
    // command string that replaces them with escaped sequences (\n or \f)
    //

    for (ptr = cmdline, newline = 0; *ptr; ptr++) {
	if (*ptr == '\n' || *ptr == '\f')
	    newline++;
    }

    if (newline) {
	base = ALLOC_N(char, strlen(cmdline) + 1 + newline + slashes);
	if (base == NULL) {
	    fprintf(stderr, "malloc failed!\n");
	    return 0;
	}
	for (i = 0, ptr = base; (unsigned) i < strlen(cmdline); i++) {
	    switch (cmdline[i]) {
	      case '\n':
		*ptr++ = '\\';
		*ptr++ = 'n';
		break;
	      default:
		*ptr++ = cmdline[i];
	    }
	}
	*ptr = '\0';
	cmdline = base;
	need_free++;
    }
d1006 3
a1092 6
	if (curr == NULL) {
	    NtFreeCmdLine();
	    fprintf(stderr, "Out of memory!!\n");
	    *vec = NULL;
	    return 0;
	}
d1102 13
a1114 3
	if (InputCmd &&
	    ((base[0] == '\"' && base[len-1] == '\"') ||
	     (base[0] == '\'' && base[len-1] == '\''))) {
a1162 6
    if (buffer == NULL) {
	fprintf(stderr, "Out of memory!!\n");
	NtFreeCmdLine();
	*vec = NULL;
	return 0;
    }
d1190 1
@


1.9
log
@2000-02-18
@
text
@d1172 1
a1172 1
#if 1
d1186 1
a1186 1
opendir(char *filename)
d1527 2
a1528 2
EXTERN_C int __cdecl _alloc_osfhnd(void);
EXTERN_C int __cdecl _set_osfhnd(int fh, long value);
a1536 1
#if defined (_MT) && !defined (DLL_FOR_WIN32S)
a1538 1
#endif  /* defined (_MT) && !defined (DLL_FOR_WIN32S) */
d1541 4
d1550 4
a1553 1
#define _osfile(i)	(_pioinfo(i)->osfile)
d1561 14
d1644 1
d1646 1
d1663 1
d1665 1
@


1.8
log
@2000-02-01
@
text
@a548 2
		CloseHandle(aProcessInformation.hThread);

a551 1
			CloseHandle(aProcessInformation.hProcess);
d555 2
d1543 1
a1543 1
EXTERN_C ioinfo * __pioinfo[];
d1551 1
d1571 3
d2209 1
a2209 1
getcwd(buffer, size)
d2224 1
a2224 1
    for (bp = buffer; *bp != '\0'; bp++) {
@


1.7
log
@2000-01-08
@
text
@d1622 2
a1623 1
	fclose(fp);
@


1.6
log
@20000105
@
text
@a231 1
    HANDLE oshandle;
d511 4
a514 12
		if (!reading) {
        	FILE *fp;

			fp = (_popen)(cmd, mode);

			MyPopenRecord[slot].inuse = TRUE;
			MyPopenRecord[slot].pipe = fp;
			MyPopenRecord[slot].pid = -1;

			if (!fp)
                        rb_fatal("cannot open pipe \"%s\" (%s)", cmd, strerror(errno));
				return fp;
a516 4
		fRet = CreatePipe(&hInFile, &hOutFile, &sa, 2048L);
		if (!fRet)
                        rb_fatal("cannot open pipe \"%s\" (%s)", cmd, strerror(errno));

d537 1
a537 3
		  lpCmd2 = malloc(strlen(lpApplicationName) + 1 + strlen(cmd) + sizeof (" /c "));
		  if (lpCmd2 == NULL)
                     rb_fatal("Mypopen: malloc failed");
d544 6
d554 2
a555 1
                        rb_fatal("cannot fork for \"%s\" (%s)", cmd, strerror(errno));
a557 2
		CloseHandle(aProcessInformation.hThread);

d563 1
a563 1
		    fd = _open_osfhandle((long)hOutFile, (_O_WRONLY | pipemode));
d567 5
a571 2
		if (fd == -1) 
                  rb_fatal("cannot open pipe \"%s\" (%s)", cmd, strerror(errno));
d573 5
a577 6

		if ((fp = (FILE *) fdopen(fd, mode)) == NULL)
			return NULL;

		if (lpCmd2)
			free(lpCmd2);
a580 1
		MyPopenRecord[slot].oshandle = (reading ? hInFile : hOutFile);
d632 1
a634 1

d638 1
a638 2
    // Closehandle() is done by fclose().
    //CloseHandle(MyPopenRecord[i].oshandle);
@


1.5
log
@19991108
@
text
@d498 1
a498 1
		HANDLE hInFile, hOutFile, hStdin, hStdout;
d536 1
a536 12
			aStartupInfo.hStdInput  = GetStdHandle(STD_OUTPUT_HANDLE);//hStdin;
			aStartupInfo.hStdError  = INVALID_HANDLE_VALUE;
			//for save
			DuplicateHandle(GetCurrentProcess(), GetStdHandle(STD_OUTPUT_HANDLE),
			  GetCurrentProcess(), &hStdout,
			  0, FALSE, DUPLICATE_SAME_ACCESS
			);
			//for redirect
			DuplicateHandle(GetCurrentProcess(), GetStdHandle(STD_INPUT_HANDLE),
			  GetCurrentProcess(), &hStdin,
			  0, TRUE, DUPLICATE_SAME_ACCESS
			);
d540 2
a541 13
			aStartupInfo.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE); //hStdout;
			aStartupInfo.hStdError  = INVALID_HANDLE_VALUE;
			// for save
			DuplicateHandle(GetCurrentProcess(), GetStdHandle(STD_INPUT_HANDLE),
			  GetCurrentProcess(), &hStdin,
			  0, FALSE, DUPLICATE_SAME_ACCESS
			);
			//for redirect
			DuplicateHandle(GetCurrentProcess(), GetStdHandle(STD_OUTPUT_HANDLE),
			  GetCurrentProcess(), &hStdout,
			  0, TRUE, DUPLICATE_SAME_ACCESS
			);
			aStartupInfo.hStdInput = hInFile;
d543 1
a568 2
			HANDLE hDummy;

a570 4
			DuplicateHandle(GetCurrentProcess(), hStdout,
			  GetCurrentProcess(), &hDummy,
			  0, TRUE, (DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE)
			);
a572 2
			HANDLE hDummy;

a574 4
			DuplicateHandle(GetCurrentProcess(), hStdin,
			  GetCurrentProcess(), &hDummy,
			  0, TRUE, (DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE)
			);
d1215 4
a1218 2
    if (stat (filename, &sbuf) < 0 ||
	sbuf.st_mode & _S_IFDIR == 0) {
d1236 1
a1236 1
    if (index("/\\", *(scanname + strlen(scanname) - 1)) == NULL)
d1773 4
@


1.4
log
@19990922
@
text
@a1220 6
//
// File names are converted to lowercase if the
// CONVERT_TO_LOWER_CASE variable is defined.
//

#define CONVERT_TO_LOWER_CASE
a1242 2
    BOOL            downcase;
    char           *dummy;
a1253 15
    // check out the file system characteristics
    //
    if (GetFullPathName(filename, PATHLEN, root, &dummy)) {
	if (dummy = strchr(root, '\\'))
	    *++dummy = '\0';
	if (GetVolumeInformation(root, volname, PATHLEN, 
				 &serial, &maxname, &flags, 0, 0)) {
	    downcase = !(flags & FS_CASE_SENSITIVE);
	}
    }
    else {
	downcase = TRUE;
    }

    //
a1288 2
    if (downcase)
	strlwr(p->start);
a1311 2
	if (downcase) 
	    strlwr(&p->start[idx]);
@


1.4.2.1
log
@19991109
@
text
@d1221 6
d1249 2
d1262 15
d1312 2
d1337 2
@


1.4.2.2
log
@20000105
@
text
@d498 1
a498 1
		HANDLE hInFile, hOutFile;
d536 12
a547 1
			aStartupInfo.hStdInput  = GetStdHandle(STD_INPUT_HANDLE);
d551 13
a563 2
			aStartupInfo.hStdInput  = hInFile;
			aStartupInfo.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
a564 1
		aStartupInfo.hStdError  = GetStdHandle(STD_ERROR_HANDLE);
d590 2
d594 4
d600 2
d604 4
d1248 2
a1249 4
    if ((stat (filename, &sbuf) < 0 ||
	sbuf.st_mode & _S_IFDIR == 0) &&
	(!isalpha(filename[0]) || filename[1] != ':' || filename[2] != '\0' ||
	((1 << (filename[0] & 0x5f) - 'A') & GetLogicalDrives()) == 0)) {
d1267 1
a1267 1
    if (index("/\\:", *CharPrev(scanname, scanname + strlen(scanname))) == NULL)
d1663 1
a1663 2
    _free_osfhnd(fileno(fp));
    fclose(fp);
a1803 4
    }
    if (nfds == 0 && timeout) {
	Sleep(timeout->tv_sec * 1000 + timeout->tv_usec / 1000);
	return 0;
@


1.4.2.3
log
@2000-01-17
@
text
@d232 1
d512 14
d527 2
a528 4
		if (!fRet) {
			errno = GetLastError();
			rb_sys_fail("mypopen: CreatePipe");
		}
d550 3
a552 1
		  lpCmd2 = xmalloc(strlen(lpApplicationName) + 1 + strlen(cmd) + sizeof (" /c "));
a558 6
		errno = GetLastError();

		if (lpCmd2)
			free(lpCmd2);

		CloseHandle(aProcessInformation.hThread);
d563 1
a563 2
			CloseHandle(aProcessInformation.hProcess);
			return NULL;
d566 2
d573 1
a573 1
			fd = _open_osfhandle((long)hOutFile, (_O_WRONLY | pipemode));
d577 6
a582 5
		if (fd == -1) {
			CloseHandle(reading ? hInFile : hOutFile);
			CloseHandle(aProcessInformation.hProcess);
			rb_sys_fail("mypopen: _open_osfhandle");
		}
d584 2
a585 5
		if ((fp = (FILE *) fdopen(fd, mode)) == NULL) {
			_close(fd);
			CloseHandle(aProcessInformation.hProcess);
			rb_sys_fail("mypopen: fdopen");
		}
d589 1
a640 1
	CloseHandle((HANDLE)MyPopenRecord[i].pid);
d643 1
d647 2
a648 1

@


1.4.2.4
log
@2000-02-18
@
text
@d549 2
d554 1
a557 2
		CloseHandle(aProcessInformation.hThread);

d1544 1
a1544 1
EXTERN_C _CRTIMP ioinfo * __pioinfo[];
a1551 1
#define FNOINHERIT		0x10	/* file handle opened O_NOINHERIT */
a1570 3
    if (flags & O_NOINHERIT)
	fileflags |= FNOINHERIT;

d2206 1
a2206 1
win32_getcwd(buffer, size)
d2221 1
a2221 1
    for (bp = buffer; *bp != '\0'; bp = CharNext(bp)) {
@


1.4.2.5
log
@win32 fix
@
text
@d1592 2
a1593 2
static int
is_socket(SOCKET fd)
d1598 4
d1603 2
a1604 2
    optlen = sizeof(sockbuf);
    retval = getsockopt(fd, SOL_SOCKET, SO_TYPE, sockbuf, &optlen);
d1610 1
a1610 1
	    return FALSE;
a1616 9
    return TRUE;
}

FILE *
myfdopen (int fd, const char *mode)
{
    if (is_socket((SOCKET)fd)) {
	int fh;

d1618 1
a1618 5
	return _fdopen(fh, mode);		// return file pointer
    }
    else {
	return (_fdopen(fd, mode));
    }
a1740 19
#undef FD_CLR

void
myfdclr(int fd, fd_set *set)
{
    unsigned int i;
    SOCKET s = TO_SOCKET(fd);

    for (i = 0; i < set->fd_count; i++) {
        if (set->fd_array[i] == s) {
            while (i < set->fd_count - 1) {
                set->fd_array[i] = set->fd_array[i + 1];
                i++;
            }
            set->fd_count--;
            break;
        }
    }
}
a1759 30
static int
extract_file_fd(fd_set *set, fd_set *fileset)
{
    int idx;

    fileset->fd_count = 0;
    if (!set)
	return 0;
    for (idx = 0; idx < set->fd_count; idx++) {
	SOCKET fd = set->fd_array[idx];

	if (!is_socket(fd)) {
	    int i;

	    for (i = 0; i < fileset->fd_count; i++) {
		if (fileset->fd_array[i] == fd) {
		    break;
		}
	    }
	    if (i == fileset->fd_count) {
		if (fileset->fd_count < FD_SETSIZE) {
		    fileset->fd_array[i] = fd;
		    fileset->fd_count++;
		}
	    }
	}
    }
    return fileset->fd_count;
}

a1764 4
    fd_set file_rd;
    fd_set file_wr;
    int file_nfds;

a1771 10
    file_nfds = extract_file_fd(rd, &file_rd);
    file_nfds += extract_file_fd(wr, &file_wr);
    if (file_nfds)
    {
	// assume normal files are always readable/writable
	// fake read/write fd_set and return value
	if (rd) *rd = file_rd;
	if (wr) *wr = file_wr;
	return file_nfds;
    }
d1777 16
@


1.4.2.6
log
@matz
@
text
@a13 1
#include "rubysig.h"
a1825 1
    int trap_immediate = rb_trap_immediate;
a1843 2
    if (trap_immediate)
	TRAP_END;
a1851 2
    if (trap_immediate)
	TRAP_BEG;
a1890 1
    int trap_immediate = rb_trap_immediate;
a1894 2
    if (trap_immediate)
	TRAP_END;
a1896 2
    if (trap_immediate)
	TRAP_BEG;
@


1.4.2.7
log
@eban
@
text
@d2353 2
a2354 2
    char *curitem = NULL;	/* XXX threadead */
    DWORD curlen = 0;		/* XXX threadead */
d2356 4
a2359 3

    curlen = 512;
    curitem = ALLOC_N(char, curlen);
@


1.4.2.8
log
@eban
@
text
@a2373 48

int
myrename(const char *oldpath, const char *newpath)
{
    int res = 0;
    int oldatts;
    int newatts;

    oldatts = GetFileAttributes(oldpath);
    newatts = GetFileAttributes(newpath);

    if (oldatts == -1) {
	printf("file to move doesn't exist");
	return -1;
    }

    if (newatts != -1 && newatts & FILE_ATTRIBUTE_READONLY)
	SetFileAttributesA(newpath, newatts & ~ FILE_ATTRIBUTE_READONLY);

    if (!MoveFile(oldpath, newpath))
	res = -1;

    if (res == 0 || (GetLastError() != ERROR_ALREADY_EXISTS
		  && GetLastError() != ERROR_FILE_EXISTS))
	goto done;

    if (IsWinNT()) {
	if (MoveFileEx(oldpath, newpath, MOVEFILE_REPLACE_EXISTING))
	    res = 0;
    } else {
	for (;;) {
	    if (!DeleteFile(newpath) && GetLastError() != ERROR_FILE_NOT_FOUND)
		break;
	    else if (MoveFile(oldpath, newpath)) {
		  res = 0;
		  break;
	    }
	}
    }

done:
    if (res)
	errno = GetLastError();
    else
	SetFileAttributes(newpath, oldatts);

    return res;
}
@


1.3
log
@990918-repack
@
text
@d680 2
a681 1
    CloseHandle(MyPopenRecord[i].oshandle);
d1839 14
a1852 1
	    errno = EBADF;
@


1.2
log
@1.4.0
@
text
@d1831 1
a1831 1
    if ((r = select (nfds, rd, wr, ex, timeout)) == SOCKET_ERROR)
d1833 9
@


1.1
log
@
Win32 VCC support.
@
text
@d26 1
a26 1
#include "nt.h"
d36 2
d307 8
d1595 61
a1658 1
    FILE *fp;
d1662 1
d1667 1
d1674 1
a1674 1
	return (_fdopen(fd, mode));
d1680 10
a1689 11
    fp = xcalloc(sizeof(FILE), 1);
#if _MSC_VER < 800
    fileno(fp) = fd;
#else
    fp->_file = fd;
#endif
    if (*mode == 'r')
	fp->_flag = _IOREAD;
    else
	fp->_flag = _IOWRT;
    return fp;
d1783 30
d1841 1
d1857 7
d1876 1
a1876 1
    if ((r = accept (s, addr, addrlen)) == INVALID_SOCKET)
d1920 1
a1920 1
    if ((r = getpeername (s, addr, addrlen)) == SOCKET_ERROR)
d1934 1
a1934 1
    if ((r = getsockname (s, addr, addrlen)) == SOCKET_ERROR)
d1962 1
a1962 1
    if ((r = ioctlsocket (s, cmd, argp)) == SOCKET_ERROR)
d1990 1
a1990 1
    if ((r = recv (s, buf, len, flags)) == SOCKET_ERROR)
d2005 1
a2005 1
    if ((r = recvfrom (s, buf, len, flags, from, fromlen)) == SOCKET_ERROR)
d2019 1
a2019 1
    if ((r = send (s, buf, len, flags)) == SOCKET_ERROR)
d2034 1
a2034 1
    if ((r = sendto (s, buf, len, flags, to, tolen)) == SOCKET_ERROR)
d2048 2
a2049 1
    if ((r = setsockopt (s, level, optname, optval, optlen)) == SOCKET_ERROR)
d2063 1
a2063 1
    if ((r = shutdown (s, how)) == SOCKET_ERROR)
d2233 1
a2233 1
void _cdecl
d2241 2
d2285 1
a2285 1
chown(char *path, int owner, int group)
d2290 1
d2295 1
a2295 1
	if (pid == GetCurrentProcessId())
d2320 25
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@@


1.1.1.1.2.1
log
@990126
@
text
@d26 1
a26 1
#include "win32.h"
@


1.1.1.1.2.2
log
@regexp null pattern
@
text
@a1595 1
    optlen = sizeof(sockbuf);
d1602 1
a1602 1
	    return (_fdopen(fd, mode));
@


1.1.1.1.2.3
log
@990531
@
text
@a35 2
#define TO_SOCKET(x)	_get_osfhandle(x)

a304 8
SOCKET
myget_osfhandle(int fh)
{
    return _get_osfhandle(fh);

}


a1584 61
EXTERN_C int __cdecl _alloc_osfhnd(void);
EXTERN_C int __cdecl _set_osfhnd(int fh, long value);
EXTERN_C void __cdecl _lock_fhandle(int);
EXTERN_C void __cdecl _unlock_fhandle(int);
EXTERN_C void __cdecl _unlock(int);

typedef struct	{
    long osfhnd;    /* underlying OS file HANDLE */
    char osfile;    /* attributes of file (e.g., open in text mode?) */
    char pipech;    /* one char buffer for handles opened on pipes */
#if defined (_MT) && !defined (DLL_FOR_WIN32S)
    int lockinitflag;
    CRITICAL_SECTION lock;
#endif  /* defined (_MT) && !defined (DLL_FOR_WIN32S) */
}	ioinfo;

EXTERN_C ioinfo * __pioinfo[];

#define IOINFO_L2E			5
#define IOINFO_ARRAY_ELTS	(1 << IOINFO_L2E)
#define _pioinfo(i)	(__pioinfo[i >> IOINFO_L2E] + (i & (IOINFO_ARRAY_ELTS - 1)))
#define _osfile(i)	(_pioinfo(i)->osfile)

#define FOPEN			0x01	/* file handle open */
#define FAPPEND			0x20	/* file handle opened O_APPEND */
#define FDEV			0x40	/* file handle refers to device */
#define FTEXT			0x80	/* file handle is in text mode */

static int
my_open_osfhandle(long osfhandle, int flags)
{
    int fh;
    char fileflags;		/* _osfile flags */

    /* copy relevant flags from second parameter */
    fileflags = FDEV;

    if (flags & O_APPEND)
	fileflags |= FAPPEND;

    if (flags & O_TEXT)
	fileflags |= FTEXT;

    /* attempt to allocate a C Runtime file handle */
    if ((fh = _alloc_osfhnd()) == -1) {
	errno = EMFILE;		/* too many open files */
	_doserrno = 0L;		/* not an OS error */
	return -1;		/* return error to caller */
    }

    /* the file is open. now, set the info in _osfhnd array */
    _set_osfhnd(fh, osfhandle);

    fileflags |= FOPEN;		/* mark as open */

    _osfile(fh) = fileflags;	/* set osfile entry */
//    _unlock_fhandle(fh);

    return fh;			/* return handle */
}

d1588 1
a1591 1
    int fh;
d1596 1
a1596 1
	optlen = sizeof(sockbuf);
d1609 11
a1619 10

	fh = my_open_osfhandle((SOCKET)fd, O_RDWR|O_BINARY);
    return _fdopen(fh, mode);		// return file pointer
}


void
myfdclose(FILE *fp)
{
	fclose(fp);
a1740 1
	int iSockOpt;
a1755 7

	iSockOpt = SO_SYNCHRONOUS_NONALERT;
    /*
     * Enable the use of sockets as filehandles
     */
    setsockopt(INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE,
		(char *)&iSockOpt, sizeof(iSockOpt));
d1768 1
a1768 1
    if ((r = accept (TO_SOCKET(s), addr, addrlen)) == INVALID_SOCKET)
d1812 1
a1812 1
    if ((r = getpeername (TO_SOCKET(s), addr, addrlen)) == SOCKET_ERROR)
d1826 1
a1826 1
    if ((r = getsockname (TO_SOCKET(s), addr, addrlen)) == SOCKET_ERROR)
d1854 1
a1854 1
    if ((r = ioctlsocket (TO_SOCKET(s), cmd, argp)) == SOCKET_ERROR)
d1882 1
a1882 1
    if ((r = recv (TO_SOCKET(s), buf, len, flags)) == SOCKET_ERROR)
d1897 1
a1897 1
    if ((r = recvfrom (TO_SOCKET(s), buf, len, flags, from, fromlen)) == SOCKET_ERROR)
d1911 1
a1911 1
    if ((r = send (TO_SOCKET(s), buf, len, flags)) == SOCKET_ERROR)
d1926 1
a1926 1
    if ((r = sendto (TO_SOCKET(s), buf, len, flags, to, tolen)) == SOCKET_ERROR)
d1940 1
a1940 2
    if ((r = setsockopt (s, level, optname, optval, optlen))
    		 == SOCKET_ERROR)
d1954 1
a1954 1
    if ((r = shutdown (TO_SOCKET(s), how)) == SOCKET_ERROR)
d2124 1
a2124 1
int _cdecl
a2131 2

	return 0;
d2174 1
a2174 1
chown(const char *path, int owner, int group)
a2178 1
#include <signal.h>
d2183 1
a2183 1
	if ((unsigned int)pid == GetCurrentProcessId())
@


1.1.1.1.2.4
log
@990624
@
text
@a1782 30
#undef FD_SET

void
myfdset(int fd, fd_set *set)
{
    unsigned int i;
    SOCKET s = TO_SOCKET(fd);

    for (i = 0; i < set->fd_count; i++) {
        if (set->fd_array[i] == s) {
            return;
        }
    }
    if (i == set->fd_count) {
        if (set->fd_count < FD_SETSIZE) {
            set->fd_array[i] = s;
            set->fd_count++;
        }
    }
}


#undef FD_ISSET

int
myfdisset(int fd, fd_set *set)
{
       return __WSAFDIsSet(TO_SOCKET(fd), set);
}

@


1.1.1.1.2.5
log
@1.3.8 to be, final beta (hopefully)
@
text
@a2319 25
char *
win32_getenv(const char *name)
{
    static char *curitem = NULL;	/* XXX threadead */
    static DWORD curlen = 0;		/* XXX threadead */
    DWORD needlen;
    if (!curitem) {
	curlen = 512;
	curitem = ALLOC_N(char, curlen);
    }

    needlen = GetEnvironmentVariable(name,curitem,curlen);
    if (needlen != 0) {
	while (needlen > curlen) {
	    REALLOC_N(curitem, char, needlen);
	    curlen = needlen;
	    needlen = GetEnvironmentVariable(name, curitem, curlen);
	}
    }
    else {
	return NULL;
    }

    return curitem;
}
@
