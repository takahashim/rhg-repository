head	1.31;
access;
symbols
	v1_6_7:1.11.2.3
	v1_6_6:1.11.2.3
	v1_6_5:1.11.2.2
	v1_6_4:1.11.2.1
	v1_7_1:1.18
	v1_6_4_preview4:1.11.2.1
	v1_6_4_preview3:1.11.2.1
	v1_6_4_preview2:1.11.2.1
	v1_6_4_preview1:1.11.2.1
	v1_6_3:1.11.2.1
	ruby_m17n:1.11.0.4
	ruby_1_6:1.11.0.2
	v1_6_2:1.11
	v1_6_1:1.9
	v1_6_0:1.8
	v1_4_6:1.2.2.4
	v1_4_5:1.2.2.2
	v1_4_4:1.2.2.2
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.2
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.5
	v1_3_6_repack:1.1.1.1.2.5
	v1_3_6:1.1.1.1.2.5
	v1_3_5:1.1.1.1.2.5
	v1_3_4_990625:1.1.1.1.2.5
	v1_3_4_990624:1.1.1.1.2.5
	v1_3_4_990611:1.1.1.1.2.4
	v1_3_4_990531:1.1.1.1.2.4
	v1_3_3_990518:1.1.1.1.2.3
	v1_3_3_990513:1.1.1.1.2.3
	v1_3_3_990507:1.1.1.1.2.3
	v1_3_1_990225:1.1.1.1.2.2
	v1_3_1_990224:1.1.1.1.2.2
	v1_3_1_990215:1.1.1.1.2.2
	v1_3_1_990212:1.1.1.1.2.2
	v1_3_1_990210:1.1.1.1.2.2
	v1_3_1_:1.1.1.1.2.2
	v1_3_1_990209:1.1.1.1.2.2
	v1_3_1_990205:1.1.1.1.2.2
	v1_3_1_990203:1.1.1.1.2.2
	v1_3_1_990201:1.1.1.1.2.2
	v1_3_1"_990201:1.1.1.1.2.2
	v1_3_1_990128:1.1.1.1.2.2
	v1_3_1_990127:1.1.1.1.2.1
	v1_3_1_990126:1.1.1.1.2.1
	ruby_1_3:1.1.1.1.0.2
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_1d1:1.1.0.2;
locks; strict;
comment	@ * @;


1.31
date	2002.10.10.21.07.16;	author nobu;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.01.15.26.39;	author nobu;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.29.09.31.45;	author nobu;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.11.08.50.13;	author usa;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.09.14.46.32;	author eban;	state Exp;
branches;
next	1.26;

1.26
date	2002.09.08.10.06.40;	author usa;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.28.02.39.29;	author usa;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.28.18.26.01;	author usa;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.11.01.27.48;	author H_Konishi;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.29.10.22.19;	author H_Konishi;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.14.18.41.46;	author usa;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.13.03.59.20;	author usa;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.07.00.21.18;	author usa;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.20.23.10.05;	author usa;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.19.03.20.24;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.17.15.17.10;	author usa;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.09.15.02.14;	author usa;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.11.01.55.51;	author eban;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.10.08.09.01;	author eban;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.10.07.30.18;	author eban;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.16.07.24.21;	author matz;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.11.14.07.10.31;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.27.09.11.13;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.15.06.22.49;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.09.04.26.06;	author eban;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.28.08.27.03;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.13.16.12.28;	author eban;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.18.06.59.36;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.05.04.37.27;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.20;	author matz;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.01.20.04.45.32;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.20.04.59.38;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.01.26.10.08.18;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.01.28.07.55.30;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.05.06.08.31.50;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.05.31.09.13.34;	author matz;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.06.24.04.24.09;	author matz;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	99.08.11.07.24.11;	author matz;	state Exp;
branches;
next	;

1.2.2.1
date	2000.01.05.04.41.21;	author matz;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.02.18.06.58.58;	author matz;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2000.06.27.05.42.15;	author matz;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2000.06.29.07.46.56;	author matz;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2000.08.09.04.46.33;	author eban;	state Exp;
branches;
next	;

1.11.2.1
date	2001.02.09.15.07.52;	author usa;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.08.07.00.21.40;	author usa;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.11.13.08.32.19;	author usa;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2002.09.08.10.25.43;	author usa;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2002.09.09.14.48.21;	author eban;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2002.10.01.15.25.49;	author nobu;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2002.10.10.21.07.11;	author nobu;	state Exp;
branches;
next	;


desc
@@


1.31
log
@* win32/win32.c (rb_w32_fclose, rb_w32_close): use closesocket()
  for socket.  [ruby-win32:382]

* win32/win32.c (StartSockets): set NtSocketsInitialized.

* win32/win32.h: prototypes; rb_w32_fclose, rb_w32_close
@
text
@#ifndef RUBY_WIN32_H
#define RUBY_WIN32_H

/*
 *  Copyright (c) 1993, Intergraph Corporation
 *
 *  You may distribute under the terms of either the GNU General Public
 *  License or the Artistic License, as specified in the perl README file.
 *
 */

#undef EXTERN
#if defined(IMPORT)
#define EXTERN extern __declspec(dllimport)
#elif defined(EXPORT)
#define EXTERN extern __declspec(dllexport)
#endif

//
// Definitions for NT port of Perl
//


//
// Ok now we can include the normal include files.
//

// #include <stdarg.h> conflict with varargs.h?
// There is function-name conflitct, so we rename it
#if !defined(IN) && !defined(FLOAT)
#define OpenFile  WINAPI_OpenFile
#include <windows.h>
#include <winsock.h>
#undef OpenFile
#endif
//
// We're not using Microsoft's "extensions" to C for
// Structured Exception Handling (SEH) so we can nuke these
//
#undef try
#undef except
#undef finally
#undef leave

#if defined(__cplusplus)
extern "C++" {
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <direct.h>
#include <process.h>
#include <time.h>
#include <math.h>
#include <signal.h>
#include <sys/stat.h>
#include <sys/types.h>
#if !defined(__BORLANDC__)
# include <sys/utime.h>
#else
# include <utime.h>
#endif
#include <io.h>
#include <malloc.h>

#if defined(__cplusplus)
}
#endif

#define UIDTYPE int
#define GIDTYPE int
#define pid_t   int
#define WNOHANG -1

#undef getc
#undef putc
#undef fgetc
#undef fputc
#undef getchar
#undef putchar
#undef fgetchar
#undef fputchar
#define getc(_stream)		rb_w32_getc(_stream)
#define putc(_c, _stream)	rb_w32_putc(_c, _stream)
#define fgetc(_stream)		getc(_stream)
#define fputc(_c, _stream)	putc(_c, _stream)
#define getchar()		rb_w32_getc(stdin)
#define putchar(_c)		rb_w32_putc(_c, stdout)
#define fgetchar()		getchar()
#define fputchar(_c)		putchar(_c)

#ifndef __BORLANDC__

#define access	   _access
#define chmod	   _chmod
#define chsize	   _chsize
#define dup	   _dup
#define dup2	   _dup2
#define isatty	   _isatty
#define open	   _open
#define setmode    _setmode
#define execl	   _execl
#define execle	   _execle
#define execlp	   _execlp
#define execlpe    _execlpe
#define execv	   _execv
#define execve	   _execve
#define execvp	   _execvp
#define execvpe    _execvpe
#define lseek      _lseek
#define spawnl	   _spawnl
#define spawnle    _spawnle
#define spawnlp    _spawnlp
#define spawnlpe   _spawnlpe
#define spawnv	   _spawnv
#define spawnve    _spawnve
#define spawnvp    _spawnvp
#define spawnvpe   _spawnvpe
#if _MSC_VER < 800
#define fileno	   _fileno
#endif
#define strcasecmp _stricmp
#define strncasecmp _strnicmp
#else
#define strcasecmp  stricmp
#define strncasecmp strnicmp
#define _open       _sopen
#endif

#define close	   rb_w32_close
#define fclose	   rb_w32_fclose
#define creat	   _creat
#define eof	   _eof
#define filelength _filelength
#define locking    _locking
#define mktemp	   _mktemp
#define perror     _perror
#define read	   _read
#define sopen	   _sopen
#define tell	   _tell
#define umask	   _umask
#define unlink	   _unlink
#define write	   _write
#define getpid	   rb_w32_getpid
#define sleep(x)   rb_w32_sleep((x)*1000)
#define utime      _utime
#define vsnprintf  _vsnprintf
#define snprintf   _snprintf
#undef stat
#define stat(path,st) rb_w32_stat(path,st)

#ifdef __MINGW32__
struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};
#endif
extern int    NtMakeCmdVector(char *, char ***, int);
extern void   NtInitialize(int *, char ***);
extern char * NtGetLib(void);
extern char * NtGetBin(void);
extern pid_t  pipe_exec(char *, int, FILE **, FILE **);
extern int    flock(int fd, int oper);
extern int    rb_w32_accept(int, struct sockaddr *, int *);
extern int    rb_w32_bind(int, struct sockaddr *, int);
extern int    rb_w32_connect(int, struct sockaddr *, int);
extern void   rb_w32_fdset(int, fd_set*);
extern void   rb_w32_fdclr(int, fd_set*);
extern int    rb_w32_fdisset(int, fd_set*);
extern long   rb_w32_select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
extern int    rb_w32_getpeername(int, struct sockaddr *, int *);
extern int    rb_w32_getsockname(int, struct sockaddr *, int *);
extern int    rb_w32_getsockopt(int, int, int, char *, int *);
extern int    rb_w32_ioctlsocket(int, long, u_long *);
extern int    rb_w32_listen(int, int);
extern int    rb_w32_recv(int, char *, int, int);
extern int    rb_w32_recvfrom(int, char *, int, int, struct sockaddr *, int *);
extern int    rb_w32_send(int, char *, int, int);
extern int    rb_w32_sendto(int, char *, int, int, struct sockaddr *, int);
extern int    rb_w32_setsockopt(int, int, int, char *, int);
extern int    rb_w32_shutdown(int, int);
extern int    rb_w32_socket(int, int, int);
extern SOCKET rb_w32_get_osfhandle(int);
extern struct hostent * rb_w32_gethostbyaddr(char *, int, int);
extern struct hostent * rb_w32_gethostbyname(char *);
extern int    rb_w32_gethostname(char *, int);
extern struct protoent * rb_w32_getprotobyname(char *);
extern struct protoent * rb_w32_getprotobynumber(int);
extern struct servent  * rb_w32_getservbyname(char *, char *);
extern struct servent  * rb_w32_getservbyport(int, char *);
extern char * rb_w32_getenv(const char *);
extern int    rb_w32_rename(const char *, const char *);
extern char **rb_w32_get_environ(void);
extern void   rb_w32_free_environ(char **);

extern int chown(const char *, int, int);
extern int link(char *, char *);
extern int gettimeofday(struct timeval *, struct timezone *);
extern pid_t waitpid (pid_t, int *, int);
extern int do_spawn(char *);
extern int kill(int, int);
extern pid_t rb_w32_getpid(void);
#ifndef __BORLANDC__
extern int isinf(double);
extern int isnan(double);
#else
#include <float.h>
#ifndef isinf
#define isinf    !_finite
#endif
#ifndef isnan
#define isnan    _isnan
#endif

#ifdef S_ISDIR
#undef S_ISDIR
#endif

#ifdef S_ISFIFO
#undef S_ISFIFO
#endif

#ifdef S_ISBLK
#undef S_ISBLK
#endif

#ifdef S_ISCHR
#undef S_ISCHR
#endif

#ifdef S_ISREG
#undef S_ISREG
#endif

#define S_ISDIR(m)  (((unsigned short)(m) & S_IFMT) == S_IFDIR)
#define S_ISFIFO(m) (((unsigned short)(m) & S_IFMT) == S_IFIFO)
#define S_ISBLK(m)  (((unsigned short)(m) & S_IFMT) == S_IFBLK)
#define S_ISCHR(m)  (((unsigned short)(m) & S_IFMT) == S_IFCHR)
#define S_ISREG(m)  (((unsigned short)(m) & S_IFMT) == S_IFREG)
#endif

#if !defined S_IRUSR && !defined __MINGW32__
#define S_IRUSR 0400
#endif
#ifndef S_IRGRP
#define S_IRGRP 0040
#endif
#ifndef S_IROTH
#define S_IROTH 0004
#endif

#if !defined S_IWUSR && !defined __MINGW32__
#define S_IWUSR 0200
#endif
#ifndef S_IWGRP
#define S_IWGRP 0020
#endif
#ifndef S_IWOTH
#define S_IWOTH 0002
#endif

#if !defined S_IXUSR && !defined __MINGW32__
#define S_IXUSR 0100
#endif
#ifndef S_IXGRP
#define S_IXGRP 0010
#endif
#ifndef S_IXOTH
#define S_IXOTH 0001
#endif

//
// define this so we can do inplace editing
//

#define SUFFIX

//
// stubs
//
#if !defined(__BORLANDC__)
extern int       ioctl (int, unsigned int, long);
#endif
extern UIDTYPE   getuid (void);
extern UIDTYPE   geteuid (void);
extern GIDTYPE   getgid (void);
extern GIDTYPE   getegid (void);
extern int       setuid (int);
extern int       setgid (int);

extern char *rb_w32_strerror(int);

#define strerror(e) rb_w32_strerror(e)

#define PIPE_BUF 1024

#define LOCK_SH 1
#define LOCK_EX 2
#define LOCK_NB 4
#define LOCK_UN 8
#ifndef EWOULDBLOCK
#define EWOULDBLOCK 10035 /* EBASEERR + 35 (winsock.h) */
#endif


#ifndef SIGINT
#define SIGINT 2
#endif
#ifndef SIGKILL
#define SIGKILL	9
#endif


/* #undef va_start */
/* #undef va_end */

#ifdef accept
#undef accept
#endif
#define accept rb_w32_accept

#ifdef bind
#undef bind
#endif
#define bind rb_w32_bind

#ifdef connect
#undef connect
#endif
#define connect rb_w32_connect

#undef FD_SET
#define FD_SET rb_w32_fdset

#undef FD_CLR
#define FD_CLR rb_w32_fdclr

#undef FD_ISSET
#define FD_ISSET rb_w32_fdisset

#undef select
#define select rb_w32_select

#ifdef getpeername
#undef getpeername
#endif
#define getpeername rb_w32_getpeername

#ifdef getsockname
#undef getsockname
#endif
#define getsockname rb_w32_getsockname

#ifdef getsockopt
#undef getsockopt
#endif
#define getsockopt rb_w32_getsockopt

#ifdef ioctlsocket
#undef ioctlsocket
#endif
#define ioctlsocket rb_w32_ioctlsocket

#ifdef listen
#undef listen
#endif
#define listen rb_w32_listen

#ifdef recv
#undef recv
#endif
#define recv rb_w32_recv

#ifdef recvfrom
#undef recvfrom
#endif
#define recvfrom rb_w32_recvfrom

#ifdef send
#undef send
#endif
#define send rb_w32_send

#ifdef sendto
#undef sendto
#endif
#define sendto rb_w32_sendto

#ifdef setsockopt
#undef setsockopt
#endif
#define setsockopt rb_w32_setsockopt

#ifdef shutdown
#undef shutdown
#endif
#define shutdown rb_w32_shutdown

#ifdef socket
#undef socket
#endif
#define socket rb_w32_socket

#ifdef gethostbyaddr
#undef gethostbyaddr
#endif
#define gethostbyaddr rb_w32_gethostbyaddr

#ifdef gethostbyname
#undef gethostbyname
#endif
#define gethostbyname rb_w32_gethostbyname

#ifdef gethostname
#undef gethostname
#endif
#define gethostname rb_w32_gethostname

#ifdef getprotobyname
#undef getprotobyname
#endif
#define getprotobyname rb_w32_getprotobyname

#ifdef getprotobynumber
#undef getprotobynumber
#endif
#define getprotobynumber rb_w32_getprotobynumber

#ifdef getservbyname
#undef getservbyname
#endif
#define getservbyname rb_w32_getservbyname

#ifdef getservbyport
#undef getservbyport
#endif
#define getservbyport rb_w32_getservbyport

#ifdef get_osfhandle
#undef get_osfhandle
#endif
#define get_osfhandle rb_w32_get_osfhandle

#ifdef getcwd
#undef getcwd
#endif
#define getcwd rb_w32_getcwd

#ifdef getenv
#undef getenv
#endif
#define getenv rb_w32_getenv

#ifdef rename
#undef rename
#endif
#define rename rb_w32_rename

struct tms {
	long	tms_utime;
	long	tms_stime;
	long	tms_cutime;
	long	tms_cstime;
};

#ifdef times
#undef times
#endif
#define times rb_w32_times

/* thread stuff */
HANDLE GetCurrentThreadHandle(void);
int  rb_w32_main_context(int arg, void (*handler)(int));
int  rb_w32_sleep(unsigned long msec);
void rb_w32_enter_critical(void);
void rb_w32_leave_critical(void);
int  rb_w32_putc(int, FILE*);
int  rb_w32_getc(FILE*);
int  rb_w32_close(int);
int  rb_w32_fclose(FILE*);
#define Sleep(msec) (void)rb_w32_sleep(msec)

/*
== ***CAUTION***
Since this function is very dangerous, ((*NEVER*))
* lock any HANDLEs(i.e. Mutex, Semaphore, CriticalSection and so on) or,
* use anything like TRAP_BEG...TRAP_END block structure,
in asynchronous_func_t.
*/
typedef DWORD (*asynchronous_func_t)(DWORD self, int argc, DWORD* argv);
DWORD rb_w32_asynchronize(asynchronous_func_t func, DWORD self, int argc, DWORD* argv, DWORD intrval);

#endif
@


1.30
log
@	* ext/socket/socket.c (init_sock): no need for special finalizer,
	  socket descriptor is no longer duplicated in 1.7.
	  [ruby-talk:50732]

	* win32/win32.c, win32/win32.h (rb_w32_fddup, rb_w32_fdclose):
	  delete.
@
text
@d1 2
a2 2
#ifndef EXT_NT_H
#define EXT_NT_H
d90 2
a91 2
#define fgetchar(_stream)	getchar()
#define fputchar(_c, _stream)	putchar(_c)
d131 2
a132 1
#define close	   _close
d480 2
@


1.29
log
@* win32/win32.c (rb_w32_open_osfhandle): adjust
  rb_w32_open_osfhandle() with _open_osfhandle().

* win32/win32.c (rb_w32_accept, rb_w32_socket): return -1 on
  error.

* win32/win32.h: should use file descriptor instead of SOCKET.
@
text
@a163 2
extern int    rb_w32_fddup(int);
extern void   rb_w32_fdclose(FILE *);
@


1.28
log
@* win32/win32.c, win32/win32.h (rb_w32_getpid): negate pid under Win9x.
@
text
@d166 3
a168 3
extern SOCKET rb_w32_accept(SOCKET, struct sockaddr *, int *);
extern int    rb_w32_bind(SOCKET, struct sockaddr *, int);
extern int    rb_w32_connect(SOCKET, struct sockaddr *, int);
d173 12
a184 12
extern int    rb_w32_getpeername(SOCKET, struct sockaddr *, int *);
extern int    rb_w32_getsockname(SOCKET, struct sockaddr *, int *);
extern int    rb_w32_getsockopt(SOCKET, int, int, char *, int *);
extern int    rb_w32_ioctlsocket(SOCKET, long, u_long *);
extern int    rb_w32_listen(SOCKET, int);
extern int    rb_w32_recv(SOCKET, char *, int, int);
extern int    rb_w32_recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);
extern int    rb_w32_send(SOCKET, char *, int, int);
extern int    rb_w32_sendto(SOCKET, char *, int, int, struct sockaddr *, int);
extern int    rb_w32_setsockopt(SOCKET, int, int, char *, int);
extern int    rb_w32_shutdown(SOCKET, int);
extern SOCKET rb_w32_socket(int, int, int);
@


1.27
log
@* win32/win32.h (S_I?USR): define only if not mingw32.
@
text
@d144 1
a144 1
#define getpid	   _getpid
d204 1
@


1.26
log
@* time.c: prototype; time_free() to avoid VC++ warnings.

* win32/win32.c (rb_w32_stat): remove S_IWGRP and S_IWOTH bits from
  st_mode.

* win32/win32.h (S_I*): define if not defined.
@
text
@d243 1
a243 1
#ifndef S_IRUSR
d253 1
a253 1
#ifndef S_IWUSR
d263 1
a263 1
#ifndef S_IXUSR
@


1.25
log
@* win32/win32.h: define SIGINT and SIGKILL if not defined.
* win32/win32.c: remove definition of SIGINT and SIGKILL.
@
text
@d243 30
@


1.24
log
@* io.c (pipe_finalize, pipe_popen): two-way pipe support for win32.

* win32/win32.c (ChildRecord, FindFreeChildSlot): ditto.

* win32/win32.c, win32/win32.h (pipe_exec): new function for two-way
  pipe support for win32.

* win32/win32.c, win32/win32.h (FindPipedChildSlot, rb_w32_popen,
  rb_w32_pclose): removed functions for two-way pipe support for win32.
@
text
@d56 1
d274 8
@


1.23
log
@new platform [bccwin32] merged.
@
text
@a147 2
#define popen      _popen
#define pclose     _pclose
a149 1
/* these are defined in nt.c */
d161 1
a161 2
extern FILE * rb_w32_popen(char *, char *);
extern int    rb_w32_pclose(FILE *);
a274 8
#ifdef popen
#undef popen
#define popen    rb_w32_popen
#endif
#ifdef pclose
#undef pclose
#define pclose   rb_w32_pclose
#endif
@


1.22
log
@Wed May 29 18:55:47 2002  KONISHI Hiromasa <H_Konishi@@ruby-lang.org>

	* function renames my* and win32_* to rb_w32_* in win32/win32.c
	  fixed files win32/win32.c, win32/win32.h, win32/dir.h,
	              hash.c, rubysig.h, signal.c, ext/socket/socket.c
@
text
@d92 2
a96 2
#define close	   _close
#define creat	   _creat
a98 2
#define eof	   _eof
#define filelength _filelength
a99 3
#define locking    _locking
#define lseek	   _lseek
#define mktemp	   _mktemp
a100 2
#define perror     _perror
#define read	   _read
a101 5
#define sopen	   _sopen
#define tell	   _tell
#define umask	   _umask
#define unlink	   _unlink
#define write	   _write
d110 1
a110 2
#define getpid	   _getpid
#define sleep(x)   rb_w32_sleep((x)*1000)
d122 23
a149 2
#define strcasecmp _stricmp
#define strncasecmp _strnicmp
d207 1
d210 24
d235 10
@


1.21
log
@	* hash.c (ruby_setenv): remove USE_WIN32_RTL_ENV block since it's
	  obsoleted.

	* win32/win32.c, win32/win32.h: sort out #if 0 - #endif or others.
@
text
@d83 2
a84 2
#define getc(_stream)		win32_getc(_stream)
#define putc(_c, _stream)	win32_putc(_c, _stream)
d87 2
a88 2
#define getchar()		win32_getc(stdin)
#define putchar(_c)		win32_putc(_c, stdout)
d123 1
a123 1
#define sleep(x)   win32_sleep((x)*1000)
d143 1
a143 1
#define stat(path,st) win32_stat(path,st)
d152 40
a191 40
extern int NtMakeCmdVector(char *, char ***, int);
extern void NtInitialize(int *, char ***);
extern char *NtGetLib(void);
extern char *NtGetBin(void);
extern FILE *mypopen(char *, char *);
extern int   mypclose(FILE *);
extern int  flock(int fd, int oper);
extern int  myfddup(int);
extern void  myfdclose(FILE *);
extern SOCKET  myaccept(SOCKET, struct sockaddr *, int *);
extern int  mybind(SOCKET, struct sockaddr *, int);
extern int  myconnect(SOCKET, struct sockaddr *, int);
extern void myfdset(int, fd_set*);
extern void myfdclr(int, fd_set*);
extern int  myfdisset(int, fd_set*);
extern long myselect(int, fd_set *, fd_set *, fd_set *, struct timeval *);
extern int  mygetpeername(SOCKET, struct sockaddr *, int *);
extern int  mygetsockname(SOCKET, struct sockaddr *, int *);
extern int  mygetsockopt(SOCKET, int, int, char *, int *);
extern int  myioctlsocket(SOCKET, long, u_long *);
extern int  mylisten(SOCKET, int);
extern int  myrecv(SOCKET, char *, int, int);
extern int  myrecvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);
extern int  mysend(SOCKET, char *, int, int);
extern int  mysendto(SOCKET, char *, int, int, struct sockaddr *, int);
extern int  mysetsockopt(SOCKET, int, int, char *, int);
extern int  myshutdown(SOCKET, int);
extern SOCKET  mysocket(int, int, int);
extern SOCKET  myget_osfhandle(int);
extern struct hostent *  mygethostbyaddr(char *, int, int);
extern struct hostent *  mygethostbyname(char *);
extern int  mygethostname(char *, int);
extern struct protoent *  mygetprotobyname(char *);
extern struct protoent *  mygetprotobynumber(int);
extern struct servent *  mygetservbyname(char *, char *);
extern struct servent * mygetservbyport(int, char *);
extern char *win32_getenv(const char *);
extern int myrename(const char *, const char *);
extern char **win32_get_environ(void);
extern void win32_free_environ(char **);
d222 1
a222 1
extern char *mystrerror(int);
d224 1
a224 1
#define strerror(e) mystrerror(e)
d238 1
a238 1
#define popen    mypopen
d242 1
a242 1
#define pclose   mypclose
d251 1
a251 1
#define accept myaccept
d256 1
a256 1
#define bind mybind
d261 1
a261 1
#define connect myconnect
d264 1
a264 1
#define FD_SET myfdset
d267 1
a267 1
#define FD_CLR myfdclr
d270 1
a270 1
#define FD_ISSET myfdisset
d273 1
a273 1
#define select myselect
d278 1
a278 1
#define getpeername mygetpeername
d283 1
a283 1
#define getsockname mygetsockname
d288 1
a288 1
#define getsockopt mygetsockopt
d293 1
a293 1
#define ioctlsocket myioctlsocket
d298 1
a298 1
#define listen mylisten
d303 1
a303 1
#define recv myrecv
d308 1
a308 1
#define recvfrom myrecvfrom
d313 1
a313 1
#define send mysend
d318 1
a318 1
#define sendto mysendto
d323 1
a323 1
#define setsockopt mysetsockopt
d328 1
a328 1
#define shutdown myshutdown
d333 1
a333 1
#define socket mysocket
d338 1
a338 1
#define gethostbyaddr mygethostbyaddr
d343 1
a343 1
#define gethostbyname mygethostbyname
d348 1
a348 1
#define gethostname mygethostname
d353 1
a353 1
#define getprotobyname mygetprotobyname
d358 1
a358 1
#define getprotobynumber mygetprotobynumber
d363 1
a363 1
#define getservbyname mygetservbyname
d368 1
a368 1
#define getservbyport mygetservbyport
d373 1
a373 1
#define get_osfhandle myget_osfhandle
d378 1
a378 1
#define getcwd win32_getcwd
d383 1
a383 1
#define getenv win32_getenv
d388 1
a388 1
#define rename myrename
d400 1
a400 1
#define times mytimes
d404 7
a410 7
int win32_main_context(int arg, void (*handler)(int));
int win32_sleep(unsigned long msec);
void win32_enter_critical(void);
void win32_leave_critical(void);
int win32_putc(int, FILE*);
int win32_getc(FILE*);
#define Sleep(msec) (void)win32_sleep(msec)
d420 1
a420 1
DWORD win32_asynchronize(asynchronous_func_t func, DWORD self, int argc, DWORD* argv, DWORD intrval);
@


1.20
log
@	* hash.c (envix): use GET_ENVIRON and FREE_ENVIRON to get environment
	  variables list.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_key): ditto.

	* hash.c (env_values): ditto.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_value): ditto.

	* hash.c (env_each): ditto.

	* hash.c (env_inspect): ditto.

	* hash.c (env_to_a): ditto.

	* hash.c (env_size): ditto.

	* hash.c (env_empty_p): ditto.

	* hash.c (env_has_value): ditto.

	* hash.c (env_index): ditto.

	* hash.c (env_to_hash): ditto.

	* win32/win32.c (win32_getenv): use static buffer.

	* win32/win32.c, win32/win32.h (win32_get_environ): get environment
	  variables list. [new]

	* win32/win32.c, win32/win32.h (win32_free_environ): free environment
	  variables list. [new]

	* win32/win32.c (do_spawn): use CreateChild() instead of calling
	  CreateProcess() directly. Original patches comes from Patrick Cheng.

	* win32/win32.c (mypopen): ditto.

	* win32/win32.c (mypclose): use rb_syswait() instead of waiting in this
	  function.

	* win32/win32.c (waitpid): use wait_child() instead of _cwait().

	* win32/win32.c (CreateChild): added. [new]

	* win32/win32.c (wait_child): added. [new]

	* win32/win32.c (FindFirstChildSlot): added. [new]

	* win32/win32.c (FindChildSlot): added. [new]

	* win32/win32.c (FindPipedChildSlot): added. [new]

	* win32/win32.c (CloseChildHandle): added. [new]

	* win32/win32.c (FindFreeChildSlot): added. [new]
@
text
@a22 45
//
// GRRRR!!!!  Windows Nonsense.
// Define the following so we don't get tons of extra stuff
// when we include windows.h 
//
#if 0
#define NOGDICAPMASKS     
#define NOVIRTUALKEYCODES 
#define NOWINMESSAGES     
#define NOWINSTYLES       
#define NOSYSMETRICS      
#define NOMENUS           
#define NOICONS           
#define NOKEYSTATES       
#define NOSYSCOMMANDS     
#define NORASTEROPS       
#define NOSHOWWINDOW      
#define OEMRESOURCE       
#define NOATOM            
#define NOCLIPBOARD       
#define NOCOLOR           
#define NOCTLMGR          
#define NODRAWTEXT        
#define NOGDI             
//#define NOKERNEL        
//#define NOUSER          
#define NONLS             
#define NOMB              
#define NOMEMMGR          
#define NOMETAFILE        
#define NOMINMAX          
#define NOMSG             
#define NOOPENFILE        
#define NOSCROLL          
#define NOSERVICE         
#define NOSOUND           
#define NOTEXTMETRIC      
#define NOWH              
#define NOWINOFFSETS      
#define NOCOMM            
#define NOKANJI           
#define NOHELP            
#define NOPROFILER        
#define NODEFERWINDOWPOS  
#endif
d37 1
a37 1
// We\'re not using Microsoft\'s "extensions" to C for
a221 5

#if 0
extern int sys_nerr;
extern char *sys_errlist[];
#endif
@


1.19
log
@* win32/win32.h: fix problems with BC++ (ruby-bugs#PR161).
@
text
@d235 2
@


1.18
log
@* win32/dir.h: replace missing/dir.h .
* win32/win32.h: ditto.
* win32/win32.c: ditto.
@
text
@d103 5
a107 1
#include <sys/utime.h>
d255 1
d257 1
@


1.17
log
@* dir.c (glob_helper): replace lstat() by stat() to follow symlink
  in the case like 'symlink/*'.

* dir.c (glob_helper): gave warning too much.
@
text
@d101 1
d184 1
a184 1
#define stat win32_stat
@


1.16
log
@* win32/win32.c: fasten file I/O on mswin32/mingw32.

* win32/win32.h: ditto.

* rubysig.h: ditto.
@
text
@d182 2
a183 2
#undef rb_sys_stat
#define rb_sys_stat win32_stat
@


1.15
log
@* win32/win32.c (win32_stat): replace stat for enable when pathname
  ends with '/' or '\' for mswin32 on Win9X / Win2k.

* win32/win32.h: ditto.

* ruby.h: ditto.

* dir.c (rb_glob_helper): ditto.

* file.c (rb_stat, rb_file_s_stat, eaccess, check3rdbyte): ditto.
@
text
@d115 17
d447 4
a450 4
void win32_enter_syscall(void);
void win32_leave_syscall(void);
void win32_disable_interrupt(void);
void win32_enable_interrupt(void);
@


1.14
log
@NORETURN, INLINE
@
text
@d165 2
@


1.13
log
@NORETURN
@
text
@a18 4
#if defined _MSC_VER && !defined NORETURN
#define NORETURN(x) __declspec(noreturn) x
#endif

@


1.12
log
@setres[ug]id, NORETURN
@
text
@d19 1
a19 1
#if defined _MSC_VER
@


1.11
log
@matz
@
text
@d19 4
@


1.11.2.1
log
@* win32/win32.c (win32_stat): replace stat for enable when pathname
  ends with '/' or '\' for mswin32 on Win9X / Win2k.

* win32/win32.h: ditto.

* ruby.h: ditto.

* dir.c (rb_glob_helper): ditto.

* file.c (rb_stat, rb_file_s_stat, eaccess, check3rdbyte): ditto.
@
text
@a164 2
#undef rb_sys_stat
#define rb_sys_stat win32_stat
@


1.11.2.2
log
@* win32/win32.h: fix problems with BC++ (ruby-bugs#PR161).
@
text
@d102 1
a102 5
#if !defined(__BORLANDC__)
# include <sys/utime.h>
#else
# include <utime.h>
#endif
a232 1
#if !defined(__BORLANDC__)
a233 1
#endif
@


1.11.2.3
log
@	* hash.c (envix): merge from 1.7: use GET_ENVIRON and FREE_ENVIRON to
	  get environment variables list.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_key): ditto.

	* hash.c (env_values): ditto.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_value): ditto.

	* hash.c (env_each): ditto.

	* hash.c (env_inspect): ditto.

	* hash.c (env_to_a): ditto.

	* hash.c (env_size): ditto.

	* hash.c (env_empty_p): ditto.

	* hash.c (env_has_value): ditto.

	* hash.c (env_index): ditto.

	* hash.c (env_to_hash): ditto.

	* win32/win32.c (win32_getenv): merge from 1.7: use static buffer.

	* win32/win32.c, win32/win32.h (win32_get_environ): merge from 1.7:
	  get environment variables list.

	* win32/win32.c, win32/win32.h (win32_free_environ): merge from 1.7:
	  free environment variables list.

	* win32/Makefile.sub: merge from 1.7: add -DLIBRUBY_SO to CPPFLAGS.
@
text
@a216 2
extern char **win32_get_environ(void);
extern void win32_free_environ(char **);
@


1.11.2.4
log
@* dir.c (rb_glob): add prototype of 2nd argument to avoid VC++ warning.

* dir.c (push_pattern): add const directive to 1st argument.

* dir.c: prototype; push_pattern() to avoid VC++ warning.

* ext/tcltklib/tcltklib.c: prototype; _timer_for_tcl() and ip_ruby()
  to avoid VC++ warning.

* win32/win32.c (win32_stat): remove S_IWGRP and S_IWOTH bits from
  st_mode.

* win32/win32.h (S_I*): define if not defined.
@
text
@a229 30
#ifndef S_IRUSR
#define S_IRUSR 0400
#endif
#ifndef S_IRGRP
#define S_IRGRP 0040
#endif
#ifndef S_IROTH
#define S_IROTH 0004
#endif

#ifndef S_IWUSR
#define S_IWUSR 0200
#endif
#ifndef S_IWGRP
#define S_IWGRP 0020
#endif
#ifndef S_IWOTH
#define S_IWOTH 0002
#endif

#ifndef S_IXUSR
#define S_IXUSR 0100
#endif
#ifndef S_IXGRP
#define S_IXGRP 0010
#endif
#ifndef S_IXOTH
#define S_IXOTH 0001
#endif

@


1.11.2.5
log
@* win32/win32.h (S_I?USR): define only if not mingw32.
@
text
@d230 1
a230 1
#if !defined S_IRUSR && !defined __MINGW32__
d240 1
a240 1
#if !defined S_IWUSR && !defined __MINGW32__
d250 1
a250 1
#if !defined S_IXUSR && !defined __MINGW32__
@


1.11.2.6
log
@	* ext/socket/socket.c (sock_new): duplicate underlying socket
	  handle not only descriptor.  [ruby-talk:40015]

	* ext/socket/socket.c (bsock_close_read, bsock_close_write): not
	  use myfdclose().

	* win32/win32.c, win32/win32.h (myfddup, myfdclose): delete.
@
text
@d186 2
@


1.11.2.7
log
@* win32/win32.c (win32_fclose, win32_close): use closesocket()
  for socket.  [ruby-win32:382]

* win32/win32.c (StartSockets): set NtSocketsInitialized.

* win32/win32.h: prototypes; win32_fclose, win32_close
@
text
@d1 2
a2 2
#ifndef RUBY_WIN32_H
#define RUBY_WIN32_H
d122 1
a122 2
#define close	   win32_close
#define fclose	   win32_fclose
a469 2
int  win32_close(int);
int  win32_fclose(FILE*);
@


1.10
log
@matz
@
text
@d180 1
a180 1
extern FILE *  myfdopen(int, const char *);
a268 5

#ifdef fdopen
#undef fdopen
#endif
#define fdopen myfdopen
@


1.9
log
@matz
@
text
@a429 6
/* initialized by NtInitialize() */
HANDLE rb_CurrentProcessHandle;
HANDLE rb_MainThreadHandle;
HANDLE rb_InterruptEvent;
DWORD rb_MainThreadId;

d432 16
a447 4
int win32_interruptible(void);
void win32_thread_resume_main(void);
void win32_sleep(unsigned long msec);
#define Sleep(msec) win32_sleep(msec)
@


1.8
log
@matz
@
text
@d146 1
a146 1
#define sleep(x)   Sleep((x)*1000)
d428 14
@


1.7
log
@eban
@
text
@d417 12
@


1.6
log
@matz
@
text
@d210 1
d411 5
@


1.5
log
@support mingw32.
@
text
@d186 1
d291 3
@


1.4
log
@2000-02-18
@
text
@d12 1
d167 6
@


1.3
log
@20000105
@
text
@d390 5
@


1.2
log
@1.4.0
@
text
@d90 1
a90 1
}
d106 1
a106 1
extern "C" {
@


1.2.2.1
log
@20000105
@
text
@d90 1
a90 1
extern "C++" {
d106 1
a106 1
}
@


1.2.2.2
log
@2000-02-18
@
text
@a389 5
#ifdef getcwd
#undef getcwd
#endif
#define getcwd win32_getcwd

@


1.2.2.3
log
@win32 fix
@
text
@a283 3
#undef FD_CLR
#define FD_CLR myfdclr

@


1.2.2.4
log
@matz
@
text
@a178 1
extern void myfdclr(int, fd_set*);
@


1.2.2.5
log
@eban
@
text
@a202 1
extern int myrename(const char *, const char *);
a402 5

#ifdef rename
#undef rename
#endif
#define rename myrename
@


1.1
log
@
Win32 VCC support.
@
text
@d88 5
d102 2
d105 8
a112 3
//
// Grrr...
//
d128 1
d145 1
d158 6
a163 4
//#define pipe       _pipe
#define perror      _perror


d167 1
a167 1
/* extern void NtInitialize(int *, char ***); */
d171 1
d173 2
a174 1
extern FILE *  myfdopen(int, char*);
d178 3
d193 1
d201 11
a221 1
// extern int       ioctl (int, unsigned int, char *);
a222 6
#if 0
extern void      sleep (unsigned int);
#else
#define sleep(x) Sleep(x*1000)
#endif

a230 2
#undef IN  /* confict in parse.c */

a240 5
#define HAVE_STDLIB_H 1
#define HAVE_GETLOGIN 1
#define HAVE_WAITPID 1
#define HAVE_GETCWD 1

a248 2
#define O_BINARY 0x8000

d281 9
d384 11
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@@


1.1.1.1.2.1
log
@990126
@
text
@d98 3
a100 4
#define UIDTYPE int
#define GIDTYPE int
#define pid_t   int
#define WNOHANG -1
a115 1
#define perror     _perror
a131 1
#define sleep(x)   Sleep((x)*1000)
d144 3
a146 1
#define vsnprintf  _vsnprintf
d189 1
d191 6
d205 2
d217 5
a229 1
#ifndef O_BINARY
a230 1
#endif
@


1.1.1.1.2.2
log
@990128
@
text
@a147 4
#define snprintf   _snprintf
#define popen      _popen
#define pclose     _pclose
#define strcasecmp _strcmpi
d215 4
@


1.1.1.1.2.3
log
@small fixes
@
text
@d151 1
a151 2
#define strcasecmp _stricmp
#define strncasecmp _strnicmp
@


1.1.1.1.2.4
log
@990531
@
text
@a87 5

#if defined(__cplusplus)
}
#endif

a96 6
#include <io.h>
#include <malloc.h>

#if defined(__cplusplus)
extern "C" {
#endif
d153 1
d157 1
a157 1
extern void NtInitialize(int *, char ***);
a160 1
extern int   mypclose(FILE *);
d162 1
a162 2
extern FILE *  myfdopen(int, const char *);
extern void  myfdclose(FILE *);
a177 1
extern SOCKET  myget_osfhandle(int);
a185 10
extern int chown(const char *, int, int);
extern int link(char *, char *);
extern int gettimeofday(struct timeval *, struct timezone *);
extern pid_t waitpid (pid_t, int *, int);
extern int do_spawn(char *);
extern int kill(int, int);
extern int isinf(double);
extern int isnan(double);


a347 5

#ifdef get_osfhandle
#undef get_osfhandle
#endif
#define get_osfhandle myget_osfhandle
@


1.1.1.1.2.5
log
@990624
@
text
@a177 3
extern void myfdset(int, fd_set*);
extern int  myfdisset(int, fd_set*);
extern long myselect(int, fd_set *, fd_set *, fd_set *, struct timeval *);
a275 9

#undef FD_SET
#define FD_SET myfdset

#undef FD_ISSET
#define FD_ISSET myfdisset

#undef select
#define select myselect
@


1.1.1.1.2.6
log
@1.3.8 to be, final beta (hopefully)
@
text
@a200 1
extern char *win32_getenv(const char *);
a387 6

#ifdef getenv
#undef getenv
#endif
#define getenv win32_getenv

@
