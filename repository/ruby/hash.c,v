head	1.81;
access;
symbols
	v1_6_7:1.39.2.9
	v1_6_6:1.39.2.6
	v1_6_5:1.39.2.5
	v1_6_4:1.39.2.2
	v1_7_1:1.45
	v1_6_4_preview4:1.39.2.1
	v1_6_4_preview3:1.39.2.1
	v1_6_4_preview2:1.39.2.1
	v1_6_4_preview1:1.39.2.1
	v1_6_3:1.39.2.1
	ruby_m17n:1.39.0.4
	ruby_1_6:1.39.0.2
	v1_6_2:1.39
	v1_6_1:1.36
	v1_6_0:1.34
	v1_4_6:1.3.2.5
	v1_4_5:1.3.2.4
	v1_4_4:1.3.2.3
	ruby_1_4_3:1.3.2.1
	ruby1_4_3:1.3.2.1
	v1_4_3:1.3.2.1
	v1_5_0:1.9
	ruby_1_4_3_pre1:1.3.2.1
	ruby_1_4:1.3.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.15
	v1_3_6_repack:1.1.1.3.2.14
	v1_3_6:1.1.1.3.2.14
	v1_3_5:1.1.1.3.2.13
	v1_2_6repack:1.1.1.2.2.26
	v1_3_4_990625:1.1.1.3.2.12
	v1_3_4_990624:1.1.1.3.2.12
	v1_2_6:1.1.1.2.2.26
	v1_3_4_990611:1.1.1.3.2.12
	v1_3_4_990531:1.1.1.3.2.10
	v1_3_3_990518:1.1.1.3.2.9
	v1_3_3_990513:1.1.1.3.2.9
	v1_3_3_990507:1.1.1.3.2.9
	v1_2_5:1.1.1.2.2.26
	v1_2_4:1.1.1.2.2.26
	v1_3_1_990225:1.1.1.3.2.6
	v1_3_1_990224:1.1.1.3.2.5
	v1_3_1_990215:1.1.1.3.2.4
	v1_3_1_990212:1.1.1.3.2.4
	v1_3_1_990210:1.1.1.3.2.4
	v1_3_1_:1.1.1.3.2.4
	v1_3_1_990209:1.1.1.3.2.4
	v1_3_1_990205:1.1.1.3.2.3
	v1_3_1_990203:1.1.1.3.2.3
	v1_3_1_990201:1.1.1.3.2.2
	v1_3_1"_990201:1.1.1.3.2.2
	v1_3_1_990128:1.1.1.3.2.1
	v1_3_1_990127:1.1.1.3.2.1
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.25
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.25
	v1_2_1repack:1.1.1.2.2.24
	v1_2_1:1.1.1.2.2.24
	v1_2_stable:1.1.1.2.2.24
	v1_1d1:1.1.1.2.2.23.2.5
	v1_1d0:1.1.1.2.2.23.2.4
	v1_1c9_1:1.1.1.2.2.24
	v1_1c9:1.1.1.2.2.23
	v1_1c8:1.1.1.2.2.23
	v1_1c7:1.1.1.2.2.23
	v1_1c6:1.1.1.2.2.23
	v1_1d-start:1.1.1.2.2.23.2.1
	v1_1c5:1.1.1.2.2.23
	v1_1dev:1.1.1.2.2.23.0.2
	v1_1c4:1.1.1.2.2.23
	v1_1c3:1.1.1.2.2.23
	v1_1c2:1.1.1.2.2.22
	v1_1c1:1.1.1.2.2.22
	v1_1c0:1.1.1.2.2.22
	v1_1b9_31:1.1.1.2.2.22
	v1_1b9_30:1.1.1.2.2.21
	v1_1b9_28:1.1.1.2.2.20
	v1_1b9_27:1.1.1.2.2.19
	v1_1b9_26:1.1.1.2.2.19
	r1_1b9_25:1.1.1.2.2.18
	r1_1b9_24:1.1.1.2.2.18
	v1_1b9_23:1.1.1.2.2.17
	v1_1b9_22:1.1.1.2.2.15
	v1_1b9_20:1.1.1.2.2.14
	v1_1b9_18:1.1.1.2.2.13
	v1_1b9_16:1.1.1.2.2.13
	v1_1b9_15:1.1.1.2.2.12
	v1_1b9_13:1.1.1.2.2.12
	v1_1b9_12:1.1.1.2.2.12
	v1_1b9_11:1.1.1.2.2.11
	v1_1b9_08:1.1.1.2.2.10
	v1_1b9_07:1.1.1.2.2.10
	r1_1b9:1.1.1.2.2.6
	v1_1b8:1.1.1.2.2.5
	v1_1b7:1.1.1.2.2.4
	v1_1b6:1.1.1.2.2.1
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.81
date	2002.10.17.16.13.44;	author knu;	state Exp;
branches;
next	1.80;

1.80
date	2002.09.28.04.21.31;	author nobu;	state Exp;
branches;
next	1.79;

1.79
date	2002.09.28.02.41.05;	author matz;	state Exp;
branches;
next	1.78;

1.78
date	2002.09.03.05.20.06;	author matz;	state Exp;
branches;
next	1.77;

1.77
date	2002.08.29.09.08.16;	author matz;	state Exp;
branches;
next	1.76;

1.76
date	2002.08.27.08.31.05;	author matz;	state Exp;
branches;
next	1.75;

1.75
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.74;

1.74
date	2002.08.19.05.56.05;	author matz;	state Exp;
branches;
next	1.73;

1.73
date	2002.08.13.09.21.13;	author matz;	state Exp;
branches;
next	1.72;

1.72
date	2002.08.12.07.39.08;	author matz;	state Exp;
branches;
next	1.71;

1.71
date	2002.06.13.03.55.44;	author matz;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.11.01.27.46;	author H_Konishi;	state Exp;
branches;
next	1.69;

1.69
date	2002.05.29.10.22.18;	author H_Konishi;	state Exp;
branches;
next	1.68;

1.68
date	2002.05.29.05.20.33;	author matz;	state Exp;
branches;
next	1.67;

1.67
date	2002.05.21.05.39.18;	author matz;	state Exp;
branches;
next	1.66;

1.66
date	2002.05.14.06.22.26;	author matz;	state Exp;
branches;
next	1.65;

1.65
date	2002.03.08.07.03.03;	author matz;	state Exp;
branches;
next	1.64;

1.64
date	2002.02.25.09.16.25;	author matz;	state Exp;
branches;
next	1.63;

1.63
date	2002.02.20.04.31.50;	author matz;	state Exp;
branches;
next	1.62;

1.62
date	2002.01.28.08.44.37;	author matz;	state Exp;
branches;
next	1.61;

1.61
date	2002.01.25.08.22.04;	author matz;	state Exp;
branches;
next	1.60;

1.60
date	2002.01.11.09.18.50;	author matz;	state Exp;
branches;
next	1.59;

1.59
date	2001.12.11.03.48.08;	author matz;	state Exp;
branches;
next	1.58;

1.58
date	2001.12.10.07.18.12;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2001.11.19.05.03.03;	author matz;	state Exp;
branches;
next	1.56;

1.56
date	2001.11.14.18.41.45;	author usa;	state Exp;
branches;
next	1.55;

1.55
date	2001.11.13.03.59.20;	author usa;	state Exp;
branches;
next	1.54;

1.54
date	2001.10.29.05.07.18;	author matz;	state Exp;
branches;
next	1.53;

1.53
date	2001.10.03.07.19.10;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.23.06.02.15;	author matz;	state Exp;
branches;
next	1.51;

1.51
date	2001.07.31.06.24.42;	author matz;	state Exp;
branches;
next	1.50;

1.50
date	2001.07.24.09.07.33;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.22.09.12.19;	author matz;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.12.05.31.46;	author matz;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.08.14.20.19;	author matz;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.01.09.38.11;	author matz;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.30.09.12.34;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.16.09.05.49;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2001.05.02.04.22.10;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.14.05.51.57;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.13.05.08.59;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.15.07.00.53;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.25.06.28.59;	author matz;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2000.12.18.09.45.59;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2000.12.05.09.36.26;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.12.05.37.23;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.04.08.24.01;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.09.04.32.17;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2000.08.07.05.01.53;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2000.07.27.09.49.19;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2000.07.21.08.45.31;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.17.09.37.59;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.04.07.04.32;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.22.08.29.43;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.05.24.04.33.59;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.05.12.09.07.40;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.09.04.52.58;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.01.09.41.19;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.12.05.06.21;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.10.05.44.10;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.23.08.37.25;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.15.09.05.37;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.07.08.37.36;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.29.08.05.25;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.02.25.03.51.18;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.23.05.23.05;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.17.07.11.11;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.08.08.52.55;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.08.08.48.49;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.01.03.12.05;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.05.04.37.04;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	99.12.14.06.49.45;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	99.12.07.09.23.26;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.12.06.09.03.54;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.12.01.09.24.12;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.11.25.09.03.05;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.11.11.04.08.26;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.10.13.06.44.41;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.10.12.04.53.33;	author matz;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.08.13.05.45.05;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.10;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.24;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.12;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.01.07.34.55;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.03.09.47.58;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.02.09.06.08.21;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.02.24.04.31.20;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.02.25.06.39.07;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.03.24.08.52.28;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.04.09.17.57.39;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.04.16.06.03.31;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.05.25.08.26.00;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.06.09.09.21.13;	author matz;	state Exp;
branches;
next	1.1.1.3.2.12;

1.1.1.3.2.12
date	99.06.11.06.29.53;	author matz;	state Exp;
branches;
next	1.1.1.3.2.13;

1.1.1.3.2.13
date	99.07.15.07.59.46;	author matz;	state Exp;
branches;
next	1.1.1.3.2.14;

1.1.1.3.2.14
date	99.07.28.09.26.40;	author matz;	state Exp;
branches;
next	1.1.1.3.2.15;

1.1.1.3.2.15
date	99.08.06.06.48.18;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.02.09.10.56.20;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.02.10.06.50.15;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.02.10.08.44.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.02.18.01.56.39;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.02.27.05.43.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.03.05.06.37.45;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.03.11.07.32.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.04.02.10.03.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.04.07.08.34.08;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.04.16.07.42.43;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.04.20.05.55.36;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.04.27.10.03.54;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.05.13.07.26.18;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.05.18.04.56.03;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.05.25.04.57.37;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.05.25.09.42.26;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.05.27.09.31.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.06.16.04.23.32;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.06.26.09.44.22;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.07.03.07.06.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.07.13.04.37.38;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.08.27.03.55.15;	author matz;	state Exp;
branches
	1.1.1.2.2.23.2.1;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.12.14.09.00.07;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	99.01.18.09.08.50;	author matz;	state Exp;
branches;
next	1.1.1.2.2.26;

1.1.1.2.2.26
date	99.02.09.03.29.22;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.23.2.1
date	98.09.08.07.08.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23.2.2;

1.1.1.2.2.23.2.2
date	98.10.06.03.28.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23.2.3;

1.1.1.2.2.23.2.3
date	98.11.25.03.31.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23.2.4;

1.1.1.2.2.23.2.4
date	98.12.16.07.30.31;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23.2.5;

1.1.1.2.2.23.2.5
date	98.12.22.09.01.51;	author matz;	state Exp;
branches;
next	;

1.3.2.1
date	99.11.11.04.07.29;	author matz;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2000.01.05.04.41.07;	author matz;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2000.01.17.08.24.02;	author matz;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2000.03.23.04.14.16;	author matz;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2000.07.24.07.16.07;	author matz;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2000.09.12.05.33.02;	author matz;	state Exp;
branches;
next	;

1.39.2.1
date	2001.02.13.05.10.43;	author matz;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2001.06.01.09.38.30;	author matz;	state Exp;
branches;
next	1.39.2.3;

1.39.2.3
date	2001.06.11.06.26.17;	author matz;	state Exp;
branches;
next	1.39.2.4;

1.39.2.4
date	2001.07.31.06.20.10;	author matz;	state Exp;
branches;
next	1.39.2.5;

1.39.2.5
date	2001.08.23.06.00.30;	author matz;	state Exp;
branches;
next	1.39.2.6;

1.39.2.6
date	2001.11.13.08.32.19;	author usa;	state Exp;
branches;
next	1.39.2.7;

1.39.2.7
date	2002.01.21.07.43.40;	author matz;	state Exp;
branches;
next	1.39.2.8;

1.39.2.8
date	2002.02.20.04.28.51;	author matz;	state Exp;
branches;
next	1.39.2.9;

1.39.2.9
date	2002.02.24.08.25.09;	author knu;	state Exp;
branches;
next	1.39.2.10;

1.39.2.10
date	2002.03.08.06.59.52;	author matz;	state Exp;
branches;
next	1.39.2.11;

1.39.2.11
date	2002.06.13.03.54.39;	author matz;	state Exp;
branches;
next	1.39.2.12;

1.39.2.12
date	2002.08.12.07.40.32;	author matz;	state Exp;
branches;
next	1.39.2.13;

1.39.2.13
date	2002.10.17.16.27.15;	author knu;	state Exp;
branches;
next	;


desc
@@


1.81
log
@* hash.c, eval.c: Use (*_NSGetEnviron()) instead of environ on
  Darwin for namespace cleanness.  [ruby-core:00537]

* dln.c (dln_load): Fix Darwin support that has been disabled and
  switch to using it on Darwin instead of the system dlopen().
  [ruby-core:00541]
@
text
@/**********************************************************************

  hash.c -

  $Author: nobu $
  $Date: 2002/09/28 04:21:31 $
  created at: Mon Nov 22 18:51:18 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#include "ruby.h"
#include "st.h"
#include "util.h"
#include "rubysig.h"

#ifdef __APPLE__
#include <crt_externs.h>
#endif

#define HASH_DELETED  FL_USER1
#define HASH_PROC_DEFAULT FL_USER2

static void
rb_hash_modify(hash)
    VALUE hash;
{
    if (!RHASH(hash)->tbl) rb_raise(rb_eTypeError, "uninitialized Hash");
    if (OBJ_FROZEN(hash)) rb_error_frozen("hash");
    if (!OBJ_TAINTED(hash) && rb_safe_level() >= 4)
	rb_raise(rb_eSecurityError, "Insecure: can't modify hash");
}

VALUE
rb_hash_freeze(hash)
    VALUE hash;
{
    return rb_obj_freeze(hash);
}

VALUE rb_cHash;

static VALUE envtbl;
static ID id_hash, id_yield, id_default;

VALUE
rb_hash(obj)
    VALUE obj;
{
    return rb_funcall(obj, id_hash, 0);
}

static VALUE
eql(args)
    VALUE *args;
{
    return (VALUE)rb_eql(args[0], args[1]);
}

static int
rb_any_cmp(a, b)
    VALUE a, b;
{
    VALUE args[2];
    if (FIXNUM_P(a) && FIXNUM_P(b)) {
	return a != b;
    }
    if (TYPE(a) == T_STRING && RBASIC(a)->klass == rb_cString &&
	TYPE(b) == T_STRING && RBASIC(b)->klass == rb_cString) {
	return rb_str_cmp(a, b);
    }
    if (SYMBOL_P(a) && SYMBOL_P(b)) {
	return a != b;
    }
    if (a == Qundef || b == Qundef) return -1;

    args[0] = a;
    args[1] = b;
    return !rb_with_disable_interrupt(eql, (VALUE)args);
}

static int
rb_any_hash(a)
    VALUE a;
{
    VALUE hval;

    switch (TYPE(a)) {
      case T_FIXNUM:
      case T_SYMBOL:
	return (int)a;
	break;

      case T_STRING:
	return rb_str_hash(a);
	break;

      default:
	DEFER_INTS;
	hval = rb_funcall(a, id_hash, 0);
	if (FIXNUM_P(hval)) {
	    hval %= 536870923;
	}
	else {
	    hval = rb_funcall(hval, '%', 1, INT2FIX(536870923));
	}
	ENABLE_INTS;
	return (int)FIX2LONG(hval);
    }
}

static struct st_hash_type objhash = {
    rb_any_cmp,
    rb_any_hash,
};

struct rb_hash_foreach_arg {
    VALUE hash;
    enum st_retval (*func)();
    char *arg;
};

static int
rb_hash_foreach_iter(key, value, arg)
    VALUE key, value;
    struct rb_hash_foreach_arg *arg;
{
    int status;
    st_table *tbl = RHASH(arg->hash)->tbl;
    struct st_table_entry **bins = tbl->bins;

    if (key == Qundef) return ST_CONTINUE;
    status = (*arg->func)(key, value, arg->arg);
    if (RHASH(arg->hash)->tbl != tbl || RHASH(arg->hash)->tbl->bins != bins){
	rb_raise(rb_eIndexError, "rehash occurred during iteration");
    }
    return status;
}

static VALUE
rb_hash_foreach_call(arg)
    struct rb_hash_foreach_arg *arg;
{
    st_foreach(RHASH(arg->hash)->tbl, rb_hash_foreach_iter, arg);
    return Qnil;
}

static VALUE
rb_hash_foreach_ensure(hash)
    VALUE hash;
{
    RHASH(hash)->iter_lev--;

    if (RHASH(hash)->iter_lev == 0) {
	if (FL_TEST(hash, HASH_DELETED)) {
	    st_cleanup_safe(RHASH(hash)->tbl, Qundef);
	    FL_UNSET(hash, HASH_DELETED);
	}
    }
    return 0;
}

static int
rb_hash_foreach(hash, func, farg)
    VALUE hash;
    enum st_retval (*func)();
    char *farg;
{
    struct rb_hash_foreach_arg arg;

    RHASH(hash)->iter_lev++;
    arg.hash = hash;
    arg.func = func;
    arg.arg  = farg;
    return rb_ensure(rb_hash_foreach_call, (VALUE)&arg, rb_hash_foreach_ensure, hash);
}

static VALUE
rb_hash_s_alloc(klass)
    VALUE klass;
{
    NEWOBJ(hash, struct RHash);
    OBJSETUP(hash, klass, T_HASH);

    hash->ifnone = Qnil;
    hash->tbl = st_init_table(&objhash);

    return (VALUE)hash;
}

VALUE
rb_hash_new()
{
    return rb_hash_s_alloc(rb_cHash);
}

static VALUE
rb_hash_initialize(argc, argv, hash)
    int argc;
    VALUE *argv;
    VALUE hash;
{
    VALUE ifnone;

    rb_hash_modify(hash);
    if (rb_block_given_p()) {
	if (argc > 0) {
	    rb_raise(rb_eArgError, "wrong number of arguments");
	}
	RHASH(hash)->ifnone = rb_f_lambda();
	FL_SET(hash, HASH_PROC_DEFAULT);
    }
    else {
	rb_scan_args(argc, argv, "01", &ifnone);
	RHASH(hash)->ifnone = ifnone;
    }

    return hash;
}

static VALUE
rb_hash_s_create(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE hash;
    int i;

    if (argc == 1 && TYPE(argv[0]) == T_HASH) {
	hash = rb_obj_alloc(klass);
	    
	RHASH(hash)->ifnone = Qnil;
	RHASH(hash)->tbl = st_copy(RHASH(argv[0])->tbl);

	return hash;
    }

    if (argc % 2 != 0) {
	rb_raise(rb_eArgError, "odd number args for Hash");
    }

    hash = rb_obj_alloc(klass);
    for (i=0; i<argc; i+=2) {
        rb_hash_aset(hash, argv[i], argv[i + 1]);
    }

    return hash;
}

static VALUE
to_hash(hash)
    VALUE hash;
{
    return rb_convert_type(hash, T_HASH, "Hash", "to_hash");
}

static int
rb_hash_rehash_i(key, value, tbl)
    VALUE key, value;
    st_table *tbl;
{
    if (key != Qundef) st_insert(tbl, key, value);
    return ST_CONTINUE;
}

static VALUE
rb_hash_rehash(hash)
    VALUE hash;
{
    st_table *tbl;

    rb_hash_modify(hash);
    tbl = st_init_table_with_size(&objhash, RHASH(hash)->tbl->num_entries);
    st_foreach(RHASH(hash)->tbl, rb_hash_rehash_i, tbl);
    st_free_table(RHASH(hash)->tbl);
    RHASH(hash)->tbl = tbl;

    return hash;
}

VALUE
rb_hash_aref(hash, key)
    VALUE hash, key;
{
    VALUE val;

    if (!st_lookup(RHASH(hash)->tbl, key, &val)) {
	return rb_funcall(hash, id_default, 1, key);
    }
    return val;
}

static VALUE
rb_hash_fetch(argc, argv, hash)
    int argc;
    VALUE *argv;
    VALUE hash;
{
    VALUE key, if_none;
    VALUE val;

    rb_scan_args(argc, argv, "11", &key, &if_none);

    if (!st_lookup(RHASH(hash)->tbl, key, &val)) {
	if (rb_block_given_p()) {
	    if (argc > 1) {
               rb_raise(rb_eArgError, "wrong number of arguments");
	    }
	    return rb_yield(key);
	}
	if (argc == 1) {
	    rb_raise(rb_eIndexError, "key not found");
	}
	return if_none;
    }
    return val;
}

static VALUE
rb_hash_default(argc, argv, hash)
    int argc;
    VALUE *argv;
    VALUE hash;
{
    VALUE key;

    rb_scan_args(argc, argv, "01", &key);
    if (FL_TEST(hash, HASH_PROC_DEFAULT)) {
	return rb_funcall(RHASH(hash)->ifnone, id_yield, 2, hash, key);
    }
    return RHASH(hash)->ifnone;
}

static VALUE
rb_hash_set_default(hash, ifnone)
    VALUE hash, ifnone;
{
    rb_hash_modify(hash);
    RHASH(hash)->ifnone = ifnone;
    FL_UNSET(hash, HASH_PROC_DEFAULT);
    return ifnone;
}

static VALUE
rb_hash_default_proc(hash)
    VALUE hash;
{
    if (FL_TEST(hash, HASH_PROC_DEFAULT)) {
	return RHASH(hash)->ifnone;
    }
    return Qnil;
}

static int
index_i(key, value, args)
    VALUE key, value;
    VALUE *args;
{
    if (rb_equal(value, args[0])) {
	args[1] = key;
	return ST_STOP;
    }
    return ST_CONTINUE;
}

static VALUE
rb_hash_index(hash, value)
    VALUE hash, value;
{
    VALUE args[2];

    args[0] = value;
    args[1] = Qnil;

    st_foreach(RHASH(hash)->tbl, index_i, args);

    return args[1];
}

static VALUE
rb_hash_indexes(argc, argv, hash)
    int argc;
    VALUE *argv;
    VALUE hash;
{
    VALUE indexes;
    int i;

    rb_warn("Hash#%s is deprecated; use Hash#select",
	    rb_id2name(rb_frame_last_func()));
    indexes = rb_ary_new2(argc);
    for (i=0; i<argc; i++) {
	RARRAY(indexes)->ptr[i] = rb_hash_aref(hash, argv[i]);
	RARRAY(indexes)->len++;
    }
    return indexes;
}

VALUE
rb_hash_delete(hash, key)
    VALUE hash, key;
{
    VALUE val;

    rb_hash_modify(hash);
    if (RHASH(hash)->iter_lev > 0) {
	if (st_delete_safe(RHASH(hash)->tbl, &key, &val, Qundef)) {
	    FL_SET(hash, HASH_DELETED);
	    return val;
	}
    }
    else if (st_delete(RHASH(hash)->tbl, &key, &val))
	return val;
    if (rb_block_given_p()) {
	return rb_yield(key);
    }
    return Qnil;
}

struct shift_var {
    int stop;
    VALUE key;
    VALUE val;
};

static int
shift_i(key, value, var)
    VALUE key, value;
    struct shift_var *var;
{
    if (key == Qundef) return ST_CONTINUE;
    if (var->stop) return ST_STOP;
    var->stop = 1;
    var->key = key;
    var->val = value;
    return ST_DELETE;
}

static VALUE
rb_hash_shift(hash)
    VALUE hash;
{
    struct shift_var var;

    rb_hash_modify(hash);
    var.stop = 0;
    st_foreach(RHASH(hash)->tbl, shift_i, &var);

    if (var.stop) {
	return rb_assoc_new(var.key, var.val);
    }
    else if (FL_TEST(hash, HASH_PROC_DEFAULT)) {
	return rb_funcall(RHASH(hash)->ifnone, id_yield, 2, hash, Qnil);
    }
    else {
	return RHASH(hash)->ifnone;
    }
}

static int
delete_if_i(key, value)
    VALUE key, value;
{
    if (key == Qundef) return ST_CONTINUE;
    if (RTEST(rb_yield(rb_assoc_new(key, value))))
	return ST_DELETE;
    return ST_CONTINUE;
}

VALUE
rb_hash_delete_if(hash)
    VALUE hash;
{
    rb_hash_modify(hash);
    rb_hash_foreach(hash, delete_if_i, 0);
    return hash;
}

VALUE
rb_hash_reject_bang(hash)
    VALUE hash;
{
    int n = RHASH(hash)->tbl->num_entries;
    rb_hash_delete_if(hash);
    if (n == RHASH(hash)->tbl->num_entries) return Qnil;
    return hash;
}

static VALUE
rb_hash_reject(hash)
    VALUE hash;
{
    return rb_hash_delete_if(rb_obj_dup(hash));
}

static int
select_i(key, value, result)
    VALUE key, value;
{
    VALUE assoc;

    if (key == Qundef) return ST_CONTINUE;
    assoc = rb_assoc_new(key, value);
    if (RTEST(rb_yield(assoc)))
	rb_ary_push(result, assoc);
    return ST_CONTINUE;
}

VALUE
rb_hash_select(argc, argv, hash)
    int argc;
    VALUE *argv;
    VALUE hash;
{
    VALUE result = rb_ary_new();
    long i;

    if (rb_block_given_p()) {
	if (argc > 0) {
	    rb_raise(rb_eArgError, "wrong number arguments(%d for 0)", argc);
	}
	rb_hash_foreach(hash, select_i, result);
    }
    else {
	for (i=0; i<argc; i++) {
	    rb_ary_push(result, rb_hash_aref(hash, argv[i]));
	}
    }
    return result;
}

static int
clear_i(key, value, dummy)
    VALUE key, value, dummy;
{
    return ST_DELETE;
}

static VALUE
rb_hash_clear(hash)
    VALUE hash;
{
    rb_hash_modify(hash);
    st_foreach(RHASH(hash)->tbl, clear_i, 0);

    return hash;
}

VALUE
rb_hash_aset(hash, key, val)
    VALUE hash, key, val;
{
    rb_hash_modify(hash);
    if (TYPE(key) != T_STRING || st_lookup(RHASH(hash)->tbl, key, 0)) {
	st_insert(RHASH(hash)->tbl, key, val);
    }
    else {
	st_add_direct(RHASH(hash)->tbl, rb_str_new4(key), val);
    }
    return val;
}

static int
replace_i(key, val, hash)
    VALUE key, val, hash;
{
    if (key != Qundef) {
	rb_hash_aset(hash, key, val);
    }

    return ST_CONTINUE;
}

static VALUE
rb_hash_become(hash, hash2)
    VALUE hash, hash2;
{
    hash2 = to_hash(hash2);
    if (hash == hash2) return hash;
    rb_hash_clear(hash);
    st_foreach(RHASH(hash2)->tbl, replace_i, hash);
    RHASH(hash)->ifnone = RHASH(hash2)->ifnone;
    if (FL_TEST(hash2, HASH_PROC_DEFAULT)) {
	FL_SET(hash, HASH_PROC_DEFAULT);
    }
    else {
	FL_UNSET(hash, HASH_PROC_DEFAULT);
    }

    return hash;
}

static VALUE
rb_hash_size(hash)
    VALUE hash;
{
    return INT2FIX(RHASH(hash)->tbl->num_entries);
}

static VALUE
rb_hash_empty_p(hash)
    VALUE hash;
{
    if (RHASH(hash)->tbl->num_entries == 0)
	return Qtrue;
    return Qfalse;
}

static int
each_value_i(key, value)
    VALUE key, value;
{
    if (key == Qundef) return ST_CONTINUE;
    rb_yield(value);
    return ST_CONTINUE;
}

static VALUE
rb_hash_each_value(hash)
    VALUE hash;
{
    rb_hash_foreach(hash, each_value_i, 0);
    return hash;
}

static int
each_key_i(key, value)
    VALUE key, value;
{
    if (key == Qundef) return ST_CONTINUE;
    rb_yield(key);
    return ST_CONTINUE;
}

static VALUE
rb_hash_each_key(hash)
    VALUE hash;
{
    rb_hash_foreach(hash, each_key_i, 0);
    return hash;
}

static int
each_pair_i(key, value)
    VALUE key, value;
{
    if (key == Qundef) return ST_CONTINUE;
    rb_yield(rb_assoc_new(key, value));
    return ST_CONTINUE;
}

static VALUE
rb_hash_each_pair(hash)
    VALUE hash;
{
    rb_hash_foreach(hash, each_pair_i, 0);
    return hash;
}

static int
to_a_i(key, value, ary)
    VALUE key, value, ary;
{
    if (key == Qundef) return ST_CONTINUE;
    rb_ary_push(ary, rb_assoc_new(key, value));
    return ST_CONTINUE;
}

static VALUE
rb_hash_to_a(hash)
    VALUE hash;
{
    VALUE ary;

    ary = rb_ary_new();
    st_foreach(RHASH(hash)->tbl, to_a_i, ary);
    if (OBJ_TAINTED(hash)) OBJ_TAINT(ary);

    return ary;
}

static VALUE
rb_hash_sort(hash)
    VALUE hash;
{
    VALUE entries = rb_hash_to_a(hash);
    rb_ary_sort_bang(entries);
    return entries;
}

static int
inspect_i(key, value, str)
    VALUE key, value, str;
{
    VALUE str2;

    if (key == Qundef) return ST_CONTINUE;
    if (RSTRING(str)->len > 1) {
	rb_str_cat2(str, ", ");
    }
    str2 = rb_inspect(key);
    rb_str_buf_append(str, str2);
    OBJ_INFECT(str, str2);
    rb_str_buf_cat2(str, "=>");
    str2 = rb_inspect(value);
    rb_str_buf_append(str, str2);
    OBJ_INFECT(str, str2);

    return ST_CONTINUE;
}

static VALUE
inspect_hash(hash)
    VALUE hash;
{
    VALUE str;

    str = rb_str_buf_new2("{");
    st_foreach(RHASH(hash)->tbl, inspect_i, str);
    rb_str_buf_cat2(str, "}");
    OBJ_INFECT(str, hash);

    return str;
}

static VALUE
rb_hash_inspect(hash)
    VALUE hash;
{
    if (RHASH(hash)->tbl == 0 || RHASH(hash)->tbl->num_entries == 0)
	return rb_str_new2("{}");
    if (rb_inspecting_p(hash)) return rb_str_new2("{...}");
    return rb_protect_inspect(inspect_hash, hash, 0);
}

static VALUE
to_s_hash(hash)
    VALUE hash;
{
    return rb_ary_to_s(rb_hash_to_a(hash));
}

static VALUE
rb_hash_to_s(hash)
    VALUE hash;
{
    if (rb_inspecting_p(hash)) return rb_str_new2("{...}");
    return rb_protect_inspect(to_s_hash, hash, 0);
}

static VALUE
rb_hash_to_hash(hash)
    VALUE hash;
{
    return hash;
}

static int
keys_i(key, value, ary)
    VALUE key, value, ary;
{
    if (key == Qundef) return ST_CONTINUE;
    rb_ary_push(ary, key);
    return ST_CONTINUE;
}

static VALUE
rb_hash_keys(hash)
    VALUE hash;
{
    VALUE ary;

    ary = rb_ary_new();
    st_foreach(RHASH(hash)->tbl, keys_i, ary);

    return ary;
}

static int
values_i(key, value, ary)
    VALUE key, value, ary;
{
    if (key == Qundef) return ST_CONTINUE;
    rb_ary_push(ary, value);
    return ST_CONTINUE;
}

static VALUE
rb_hash_values(hash)
    VALUE hash;
{
    VALUE ary;

    ary = rb_ary_new();
    st_foreach(RHASH(hash)->tbl, values_i, ary);

    return ary;
}

static VALUE
rb_hash_has_key(hash, key)
    VALUE hash;
    VALUE key;
{
    if (st_lookup(RHASH(hash)->tbl, key, 0)) {
	return Qtrue;
    }
    return Qfalse;
}

static int
rb_hash_search_value(key, value, data)
    VALUE key, value, *data;
{
    if (key == Qundef) return ST_CONTINUE;
    if (rb_equal(value, data[1])) {
	data[0] = Qtrue;
	return ST_STOP;
    }
    return ST_CONTINUE;
}

static VALUE
rb_hash_has_value(hash, val)
    VALUE hash;
    VALUE val;
{
    VALUE data[2];

    data[0] = Qfalse;
    data[1] = val;
    st_foreach(RHASH(hash)->tbl, rb_hash_search_value, data);
    return data[0];
}

struct equal_data {
    int result;
    st_table *tbl;
};

static int
equal_i(key, val1, data)
    VALUE key, val1;
    struct equal_data *data;
{
    VALUE val2;

    if (key == Qundef) return ST_CONTINUE;
    if (!st_lookup(data->tbl, key, &val2)) {
	data->result = Qfalse;
	return ST_STOP;
    }
    if (!rb_equal(val1, val2)) {
	data->result = Qfalse;
	return ST_STOP;
    }
    return ST_CONTINUE;
}

static VALUE
rb_hash_equal(hash1, hash2)
    VALUE hash1, hash2;
{
    struct equal_data data;

    if (hash1 == hash2) return Qtrue;
    if (TYPE(hash2) != T_HASH) return Qfalse;
    if (RHASH(hash1)->tbl->num_entries != RHASH(hash2)->tbl->num_entries)
	return Qfalse;
    if (!(rb_equal(RHASH(hash1)->ifnone, RHASH(hash2)->ifnone) &&
	  FL_TEST(hash1, HASH_PROC_DEFAULT) == FL_TEST(hash2, HASH_PROC_DEFAULT)))
	return Qfalse;

    data.tbl = RHASH(hash2)->tbl;
    data.result = Qtrue;
    st_foreach(RHASH(hash1)->tbl, equal_i, &data);

    return data.result;
}

static int
rb_hash_invert_i(key, value, hash)
    VALUE key, value;
    VALUE hash;
{
    if (key == Qundef) return ST_CONTINUE;
    rb_hash_aset(hash, value, key);
    return ST_CONTINUE;
}

static VALUE
rb_hash_invert(hash)
    VALUE hash;
{
    VALUE h = rb_hash_new();

    st_foreach(RHASH(hash)->tbl, rb_hash_invert_i, h);
    return h;
}

static int
rb_hash_update_i(key, value, hash)
    VALUE key, value;
    VALUE hash;
{
    if (key == Qundef) return ST_CONTINUE;
    rb_hash_aset(hash, key, value);
    return ST_CONTINUE;
}

static int
rb_hash_update_block_i(key, value, hash)
    VALUE key, value;
    VALUE hash;
{
    if (key == Qundef) return ST_CONTINUE;
    if (rb_hash_has_key(hash, key)) {
	value = rb_yield(rb_ary_new3(3, key, rb_hash_aref(hash, key), value));
    }
    rb_hash_aset(hash, key, value);
    return ST_CONTINUE;
}

static VALUE
rb_hash_update(hash1, hash2)
    VALUE hash1, hash2;
{
    hash2 = to_hash(hash2);
    if (rb_block_given_p()) {
	st_foreach(RHASH(hash2)->tbl, rb_hash_update_block_i, hash1);
    }
    else {
	st_foreach(RHASH(hash2)->tbl, rb_hash_update_i, hash1);
    }
    return hash1;
}

static int path_tainted = -1;

static char **origenviron;
#ifdef NT
#define GET_ENVIRON(e) (e = rb_w32_get_environ())
#define FREE_ENVIRON(e) rb_w32_free_environ(e)
static char **my_environ;
#undef environ
#define environ my_environ
#elif defined(__APPLE__)
#undef environ
#define environ (*_NSGetEnviron())
#define GET_ENVIRON(e) (e)
#define FREE_ENVIRON(e)
#else
extern char **environ;
#define GET_ENVIRON(e) (e)
#define FREE_ENVIRON(e)
#endif

static VALUE
env_delete(obj, name)
    VALUE obj, name;
{
    char *nam, *val;

    rb_secure(4);
    SafeStringValue(name);
    nam = RSTRING(name)->ptr;
    if (strlen(nam) != RSTRING(name)->len) {
	rb_raise(rb_eArgError, "bad environment variable name");
    }
    val = getenv(nam);
    if (val) {
	VALUE value = rb_tainted_str_new2(val);

	ruby_setenv(nam, 0);
#ifdef __BORLANDC__
	if (strcmpi(nam, "PATH") == 0) {
#else
	if (strcmp(nam, "PATH") == 0) {
#endif
	    path_tainted = 0;
	}
	return value;
    }
    return Qnil;
}

static VALUE
env_delete_m(obj, name)
    VALUE obj, name;
{
    VALUE val = env_delete(obj, name);
    if (rb_block_given_p()) rb_yield(name);
    return val;
}

static VALUE
rb_f_getenv(obj, name)
    VALUE obj, name;
{
    char *nam, *env;

    StringValue(name);
    nam = RSTRING(name)->ptr;
    if (strlen(nam) != RSTRING(name)->len) {
	rb_raise(rb_eArgError, "bad environment variable name");
    }
    env = getenv(nam);
    if (env) {
#ifdef __BORLANDC__
	if (strcmpi(nam, "PATH") == 0 && !rb_env_path_tainted())
#else
	if (strcmp(nam, "PATH") == 0 && !rb_env_path_tainted())
#endif
	    return rb_str_new2(env);
	return rb_tainted_str_new2(env);
    }
    return Qnil;
}

static VALUE
env_fetch(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE key, if_none;
    char *nam, *env;

    rb_scan_args(argc, argv, "11", &key, &if_none);
    StringValue(key);
    nam = RSTRING(key)->ptr;
    if (strlen(nam) != RSTRING(key)->len) {
	rb_raise(rb_eArgError, "bad environment variable name");
    }
    env = getenv(nam);
    if (!env) {
	if (rb_block_given_p()) {
	    if (argc > 1) {
		rb_raise(rb_eArgError, "wrong number of arguments");
	    }
	    return rb_yield(key);
	}
	if (argc == 1) {
	    rb_raise(rb_eIndexError, "key not found");
	}
	return if_none;
    }
#ifdef __BORLANDC__
    if (strcmpi(nam, "PATH") == 0 && !rb_env_path_tainted())
#else
    if (strcmp(nam, "PATH") == 0 && !rb_env_path_tainted())
#endif
	return rb_str_new2(env);
    return rb_tainted_str_new2(env);
}

static void
path_tainted_p(path)
    char *path;
{
    path_tainted = rb_path_check(path)?0:1;
}

int
rb_env_path_tainted()
{
    if (path_tainted < 0) {
	path_tainted_p(getenv("PATH"));
    }
    return path_tainted;
}

static int
envix(nam)
char *nam;
{
    register int i, len = strlen(nam);
    char **env;

    env = GET_ENVIRON(environ);
    for (i = 0; env[i]; i++) {
	if (
#ifdef WIN32
	    strnicmp(env[i],nam,len) == 0
#else
	    memcmp(env[i],nam,len) == 0
#endif
	    && env[i][len] == '=')
	    break;			/* memcmp must come first to avoid */
    }					/* potential SEGV's */
    FREE_ENVIRON(environ);
    return i;
}

void
ruby_setenv(name, value)
    const char *name;
    const char *value;
{
#if defined(WIN32) && !defined(__CYGWIN32__)
    /* The sane way to deal with the environment.
     * Has these advantages over putenv() & co.:
     *  * enables us to store a truly empty value in the
     *    environment (like in UNIX).
     *  * we don't have to deal with RTL globals, bugs and leaks.
     *  * Much faster.
     * Why you may want to enable USE_WIN32_RTL_ENV:
     *  * environ[] and RTL functions will not reflect changes,
     *    which might be an issue if extensions want to access
     *    the env. via RTL.  This cuts both ways, since RTL will
     *    not see changes made by extensions that call the Win32
     *    functions directly, either.
     * GSAR 97-06-07
     *
     * REMARK: USE_WIN32_RTL_ENV is already obsoleted since we don't use
     *         RTL's environ global variable directly yet.
     */
    SetEnvironmentVariable(name,value);
#elif defined __CYGWIN__
#undef setenv
#undef unsetenv
    if (value)
	setenv(name,value,1);
    else
	unsetenv(name);
#else  /* WIN32 */

    int i=envix(name);		        /* where does it go? */

    if (environ == origenviron) {	/* need we copy environment? */
	int j;
	int max;
	char **tmpenv;

	for (max = i; environ[max]; max++) ;
	tmpenv = ALLOC_N(char*, max+2);
	for (j=0; j<max; j++)		/* copy environment */
	    tmpenv[j] = strdup(environ[j]);
	tmpenv[max] = 0;
	environ = tmpenv;		/* tell exec where it is now */
    }
    if (!value) {
	if (environ != origenviron) {
	    char **envp = origenviron;
	    while (*envp && *envp != environ[i]) envp++;
	    if (!*envp)
		free(environ[i]);
	}
	while (environ[i]) {
	    environ[i] = environ[i+1];
	    i++;
	}
	return;
    }
    if (!environ[i]) {			/* does not exist yet */
	REALLOC_N(environ, char*, i+2);	/* just expand it a bit */
	environ[i+1] = 0;	/* make sure it's null terminated */
    }
    else {
	if (environ[i] != origenviron[i])
	    free(environ[i]);
    }
    environ[i] = ALLOC_N(char, strlen(name) + strlen(value) + 2);
#ifndef MSDOS
    sprintf(environ[i],"%s=%s",name,value); /* all that work just for this */
#else
    /* MS-DOS requires environment variable names to be in uppercase */
    /* [Tom Dinger, 27 August 1990: Well, it doesn't _require_ it, but
     * some utilities and applications may break because they only look
     * for upper case strings. (Fixed strupr() bug here.)]
     */
    strcpy(environ[i],name); strupr(environ[i]);
    sprintf(environ[i] + strlen(name),"=%s", value);
#endif /* MSDOS */

#endif /* WIN32 */
}

void
ruby_unsetenv(name)
    const char *name;
{
    ruby_setenv(name, 0);
}

static VALUE
env_aset(obj, nm, val)
    VALUE obj, nm, val;
{
    char *name, *value;

    if (rb_safe_level() >= 4) {
	rb_raise(rb_eSecurityError, "cannot change environment variable");
    }

    if (NIL_P(val)) {
	env_delete(obj, nm);
	return Qnil;
    }

    StringValue(nm);
    StringValue(val);
    name = RSTRING(nm)->ptr;
    value = RSTRING(val)->ptr;
    if (strlen(name) != RSTRING(nm)->len)
	rb_raise(rb_eArgError, "bad environment variable name");
    if (strlen(value) != RSTRING(val)->len)
	rb_raise(rb_eArgError, "bad environment variable value");

    ruby_setenv(name, value);
    if (strcmp(name, "PATH") == 0) {
	if (OBJ_TAINTED(val)) {
	    /* already tainted, no check */
	    path_tainted = 1;
	    return val;
	}
	else {
	    path_tainted_p(value);
	}
    }
    return val;
}

static VALUE
env_keys()
{
    char **env;
    VALUE ary = rb_ary_new();

    env = GET_ENVIRON(environ);
    while (*env) {
	char *s = strchr(*env, '=');
	if (s) {
	    rb_ary_push(ary, rb_tainted_str_new(*env, s-*env));
	}
	env++;
    }
    FREE_ENVIRON(environ);
    return ary;
}

static VALUE
env_each_key(hash)
    VALUE hash;
{
    char **env;

    env = GET_ENVIRON(environ);
    while (*env) {
	char *s = strchr(*env, '=');
	if (s) {
	    rb_yield(rb_tainted_str_new(*env, s-*env));
	}
	env++;
    }
    FREE_ENVIRON(environ);
    return Qnil;
}

static VALUE
env_values()
{
    char **env;
    VALUE ary = rb_ary_new();

    env = GET_ENVIRON(environ);
    while (*env) {
	char *s = strchr(*env, '=');
	if (s) {
	    rb_ary_push(ary, rb_tainted_str_new2(s+1));
	}
	env++;
    }
    FREE_ENVIRON(environ);
    return ary;
}

static VALUE
env_each_value(hash)
    VALUE hash;
{
    char **env;

    env = GET_ENVIRON(environ);
    while (*env) {
	char *s = strchr(*env, '=');
	if (s) {
	    rb_yield(rb_tainted_str_new2(s+1));
	}
	env++;
    }
    FREE_ENVIRON(environ);
    return Qnil;
}

static VALUE
env_each(hash)
    VALUE hash;
{
    char **env;

    env = GET_ENVIRON(environ);
    while (*env) {
	char *s = strchr(*env, '=');
	if (s) {
	    rb_yield(rb_assoc_new(rb_tainted_str_new(*env, s-*env),
				  rb_tainted_str_new2(s+1)));
	}
	env++;
    }
    FREE_ENVIRON(environ);
    return Qnil;
}

static VALUE
env_reject_bang()
{
    volatile VALUE keys;
    VALUE *ptr;
    long len;
    int del = 0;

    rb_secure(4);
    keys = env_keys();
    ptr = RARRAY(keys)->ptr;
    len = RARRAY(keys)->len; 

    while (len--) {
	VALUE val = rb_f_getenv(Qnil, *ptr);
	if (!NIL_P(val)) {
	    if (RTEST(rb_yield(rb_assoc_new(*ptr, val)))) {
		env_delete(Qnil, *ptr);
		del++;
	    }
	}
	ptr++;
    }
    if (del == 0) return Qnil;
    return envtbl;
}

static VALUE
env_delete_if()
{
    env_reject_bang();
    return envtbl;
}

static VALUE
env_select(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE result = rb_ary_new();
    long i;

    if (rb_block_given_p()) {
	char **env;

	if (argc > 0) {
	    rb_raise(rb_eArgError, "wrong number arguments(%d for 0)", argc);
	}
	env = GET_ENVIRON(environ);
	while (*env) {
	    char *s = strchr(*env, '=');
	    if (s) {
                VALUE assoc = rb_assoc_new(rb_tainted_str_new(*env, s-*env),
                                           rb_tainted_str_new2(s+1));
		if (RTEST(rb_yield(assoc))) {
		    rb_ary_push(result, assoc);
		}
	    }
	    env++;
	}
	FREE_ENVIRON(environ);
    }
    else {
	for (i=0; i<argc; i++) {
	    rb_ary_push(result, rb_f_getenv(Qnil, argv[i]));
	}
    }
    return result;
}

static VALUE
env_to_s()
{
    return rb_str_new2("ENV");
}

static VALUE
env_inspect()
{
    char **env;
    VALUE str = rb_str_buf_new2("{");
    VALUE i;

    env = GET_ENVIRON(environ);
    while (*env) {
	char *s = strchr(*env, '=');

	if (env != environ) {
	    rb_str_buf_cat2(str, ", ");
	}
	if (s) {
	    rb_str_buf_cat2(str, "\"");
	    rb_str_buf_cat(str, *env, s-*env);
	    rb_str_buf_cat2(str, "\"=>");
	    i = rb_inspect(rb_str_new2(s+1));
	    rb_str_buf_append(str, i);
	}
	env++;
    }
    FREE_ENVIRON(environ);
    rb_str_buf_cat2(str, "}");
    OBJ_TAINT(str);

    return str;
}

static VALUE
env_to_a()
{
    char **env;
    VALUE ary = rb_ary_new();

    env = GET_ENVIRON(environ);
    while (*env) {
	char *s = strchr(*env, '=');
	if (s) {
	    rb_ary_push(ary, rb_assoc_new(rb_tainted_str_new(*env, s-*env),
					  rb_tainted_str_new2(s+1)));
	}
	env++;
    }
    FREE_ENVIRON(environ);
    return ary;
}

static VALUE
env_none()
{
    return Qnil;
}

static VALUE
env_size()
{
    int i;
    char **env;

    env = GET_ENVIRON(environ);
    for(i=0; env[i]; i++)
	;
    FREE_ENVIRON(environ);
    return INT2FIX(i);
}

static VALUE
env_empty_p()
{
    char **env;

    env = GET_ENVIRON(environ);
    if (env[0] == 0) {
	FREE_ENVIRON(environ);
	return Qtrue;
    }
    FREE_ENVIRON(environ);
    return Qfalse;
}

static VALUE
env_has_key(env, key)
    VALUE env, key;
{
    char *s;

    s = StringValuePtr(key);
    if (strlen(s) != RSTRING(key)->len)
	rb_raise(rb_eArgError, "bad environment variable name");
    if (getenv(s)) return Qtrue;
    return Qfalse;
}

static VALUE
env_has_value(dmy, value)
    VALUE dmy, value;
{
    char **env;

    if (TYPE(value) != T_STRING) return Qfalse;
    env = GET_ENVIRON(environ);
    while (*env) {
	char *s = strchr(*env, '=')+1;
	if (s) {
	    if (strncmp(s, RSTRING(value)->ptr, strlen(s)) == 0) {
		FREE_ENVIRON(environ);
		return Qtrue;
	    }
	}
	env++;
    }
    FREE_ENVIRON(environ);
    return Qfalse;
}

static VALUE
env_index(dmy, value)
    VALUE dmy, value;
{
    char **env;
    VALUE str;

    if (TYPE(value) != T_STRING) return Qnil;
    env = GET_ENVIRON(environ);
    while (*env) {
	char *s = strchr(*env, '=')+1;
	if (s) {
	    if (strncmp(s, RSTRING(value)->ptr, strlen(s)) == 0) {
		str = rb_tainted_str_new(*env, s-*env-1);
		FREE_ENVIRON(environ);
		return str;
	    }
	}
	env++;
    }
    FREE_ENVIRON(environ);
    return Qnil;
}

static VALUE
env_indexes(argc, argv)
    int argc;
    VALUE *argv;
{
    int i;
    VALUE indexes = rb_ary_new2(argc);

    rb_warn("ENV.%s is deprecated; use ENV.select",
	    rb_id2name(rb_frame_last_func()));
    for (i=0;i<argc;i++) {
	char *v = 0;
	if (TYPE(argv[i]) == T_STRING) {
	    v = getenv(RSTRING(argv[i])->ptr);
	}
	if (v) {
	    RARRAY(indexes)->ptr[i] = rb_tainted_str_new2(v);
	}
	else {
	    RARRAY(indexes)->ptr[i] = Qnil;
	}
	RARRAY(indexes)->len = i+1;
    }

    return indexes;
}

static VALUE
env_to_hash()
{
    char **env;
    VALUE hash = rb_hash_new();

    env = GET_ENVIRON(environ);
    while (*env) {
	char *s = strchr(*env, '=');
	if (s) {
	    rb_hash_aset(hash, rb_tainted_str_new(*env, s-*env),
			       rb_tainted_str_new2(s+1));
	}
	env++;
    }
    FREE_ENVIRON(environ);
    return hash;
}

static VALUE
env_reject()
{
    return rb_hash_delete_if(env_to_hash());
}

void
Init_Hash()
{
    id_hash = rb_intern("hash");
    id_yield = rb_intern("yield");
    id_default = rb_intern("default");

    rb_cHash = rb_define_class("Hash", rb_cObject);

    rb_include_module(rb_cHash, rb_mEnumerable);

    rb_define_singleton_method(rb_cHash, "allocate", rb_hash_s_alloc, 0);
    rb_define_singleton_method(rb_cHash, "[]", rb_hash_s_create, -1);
    rb_define_method(rb_cHash,"initialize", rb_hash_initialize, -1);

    rb_define_method(rb_cHash,"become", rb_hash_become, 1);
    rb_define_method(rb_cHash,"rehash", rb_hash_rehash, 0);

    rb_define_method(rb_cHash,"to_hash", rb_hash_to_hash, 0);
    rb_define_method(rb_cHash,"to_a", rb_hash_to_a, 0);
    rb_define_method(rb_cHash,"to_s", rb_hash_to_s, 0);
    rb_define_method(rb_cHash,"inspect", rb_hash_inspect, 0);

    rb_define_method(rb_cHash,"==", rb_hash_equal, 1);
    rb_define_method(rb_cHash,"[]", rb_hash_aref, 1);
    rb_define_method(rb_cHash,"fetch", rb_hash_fetch, -1);
    rb_define_method(rb_cHash,"[]=", rb_hash_aset, 2);
    rb_define_method(rb_cHash,"store", rb_hash_aset, 2);
    rb_define_method(rb_cHash,"default", rb_hash_default, -1);
    rb_define_method(rb_cHash,"default=", rb_hash_set_default, 1);
    rb_define_method(rb_cHash,"default_proc", rb_hash_default_proc, 0);
    rb_define_method(rb_cHash,"index", rb_hash_index, 1);
    rb_define_method(rb_cHash,"indexes", rb_hash_indexes, -1);
    rb_define_method(rb_cHash,"indices", rb_hash_indexes, -1);
    rb_define_method(rb_cHash,"size", rb_hash_size, 0);
    rb_define_method(rb_cHash,"length", rb_hash_size, 0);
    rb_define_method(rb_cHash,"empty?", rb_hash_empty_p, 0);

    rb_define_method(rb_cHash,"each", rb_hash_each_pair, 0);
    rb_define_method(rb_cHash,"each_value", rb_hash_each_value, 0);
    rb_define_method(rb_cHash,"each_key", rb_hash_each_key, 0);
    rb_define_method(rb_cHash,"each_pair", rb_hash_each_pair, 0);
    rb_define_method(rb_cHash,"sort", rb_hash_sort, 0);

    rb_define_method(rb_cHash,"keys", rb_hash_keys, 0);
    rb_define_method(rb_cHash,"values", rb_hash_values, 0);

    rb_define_method(rb_cHash,"shift", rb_hash_shift, 0);
    rb_define_method(rb_cHash,"delete", rb_hash_delete, 1);
    rb_define_method(rb_cHash,"delete_if", rb_hash_delete_if, 0);
    rb_define_method(rb_cHash,"select", rb_hash_select, -1);
    rb_define_method(rb_cHash,"reject", rb_hash_reject, 0);
    rb_define_method(rb_cHash,"reject!", rb_hash_reject_bang, 0);
    rb_define_method(rb_cHash,"clear", rb_hash_clear, 0);
    rb_define_method(rb_cHash,"invert", rb_hash_invert, 0);
    rb_define_method(rb_cHash,"update", rb_hash_update, 1);
    rb_define_method(rb_cHash,"replace", rb_hash_become, 1);

    rb_define_method(rb_cHash,"include?", rb_hash_has_key, 1);
    rb_define_method(rb_cHash,"member?", rb_hash_has_key, 1);
    rb_define_method(rb_cHash,"has_key?", rb_hash_has_key, 1);
    rb_define_method(rb_cHash,"has_value?", rb_hash_has_value, 1);
    rb_define_method(rb_cHash,"key?", rb_hash_has_key, 1);
    rb_define_method(rb_cHash,"value?", rb_hash_has_value, 1);

#ifndef __MACOS__ /* environment variables nothing on MacOS. */
    origenviron = environ;
    envtbl = rb_obj_alloc(rb_cObject);
    rb_extend_object(envtbl, rb_mEnumerable);

    rb_define_singleton_method(envtbl,"[]", rb_f_getenv, 1);
    rb_define_singleton_method(envtbl,"fetch", env_fetch, -1);
    rb_define_singleton_method(envtbl,"[]=", env_aset, 2);
    rb_define_singleton_method(envtbl,"store", env_aset, 2);
    rb_define_singleton_method(envtbl,"each", env_each, 0);
    rb_define_singleton_method(envtbl,"each_pair", env_each, 0);
    rb_define_singleton_method(envtbl,"each_key", env_each_key, 0);
    rb_define_singleton_method(envtbl,"each_value", env_each_value, 0);
    rb_define_singleton_method(envtbl,"delete", env_delete_m, 1);
    rb_define_singleton_method(envtbl,"delete_if", env_delete_if, 0);
    rb_define_singleton_method(envtbl,"reject", env_reject, 0);
    rb_define_singleton_method(envtbl,"reject!", env_reject_bang, 0);
    rb_define_singleton_method(envtbl,"select", env_select, -1);
    rb_define_singleton_method(envtbl,"to_s", env_to_s, 0);
    rb_define_singleton_method(envtbl,"inspect", env_inspect, 0);
    rb_define_singleton_method(envtbl,"rehash", env_none, 0);
    rb_define_singleton_method(envtbl,"to_a", env_to_a, 0);
    rb_define_singleton_method(envtbl,"index", env_index, 1);
    rb_define_singleton_method(envtbl,"indexes", env_indexes, -1);
    rb_define_singleton_method(envtbl,"indices", env_indexes, -1);
    rb_define_singleton_method(envtbl,"size", env_size, 0);
    rb_define_singleton_method(envtbl,"length", env_size, 0);
    rb_define_singleton_method(envtbl,"empty?", env_empty_p, 0);
    rb_define_singleton_method(envtbl,"keys", env_keys, 0);
    rb_define_singleton_method(envtbl,"values", env_values, 0);
    rb_define_singleton_method(envtbl,"include?", env_has_key, 1);
    rb_define_singleton_method(envtbl,"member?", env_has_key, 1);
    rb_define_singleton_method(envtbl,"has_key?", env_has_key, 1);
    rb_define_singleton_method(envtbl,"has_value?", env_has_value, 1);
    rb_define_singleton_method(envtbl,"key?", env_has_key, 1);
    rb_define_singleton_method(envtbl,"value?", env_has_value, 1);
    rb_define_singleton_method(envtbl,"to_hash", env_to_hash, 0);

    rb_define_global_const("ENV", envtbl);
#else /* __MACOS__ */
	envtbl = rb_hash_s_new(0, NULL, rb_cHash);
    rb_define_global_const("ENV", envtbl);
#endif  /* ifndef __MACOS__  environment variables nothing on MacOS. */
}
@


1.80
log
@* hash.c (rb_hash_become): should check self-assignment after
 conversion.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/28 02:41:05 $
d20 4
d951 5
@


1.79
log
@
* hash.c (rb_hash_become): Hash#become should check added
  self-assignment.

* class.c (rb_make_metaclass): metaclass of a superclass may be
  NULL at boot time.
@
text
@d6 1
a6 1
  $Date: 2002/09/03 05:20:06 $
d578 1
a579 1
    hash2 = to_hash(hash2);
@


1.78
log
@	* variable.c (rb_copy_generic_ivar): remove old generic instance
	  variable table if it existes.

	* class.c (rb_make_metaclass): metaclass of a metaclass is a
	  metaclass itself.
@
text
@d6 1
a6 1
  $Date: 2002/08/29 09:08:16 $
d578 1
@


1.77
log
@* array.c (rb_ary_become): should not free ptr if it's shared.

* eval.c (rb_alias): prohibit making an alias named "allocate" if
  klass is a metaclass.

* string.c (rb_string_value_ptr): StringValuePtr() should never
  return NULL pointer.
@
text
@d6 1
a6 1
  $Date: 2002/08/27 08:31:05 $
a256 24
static VALUE
rb_hash_become(copy, orig)
    VALUE copy, orig;
{
    orig = to_hash(orig);
    if (RHASH(copy)->tbl) st_free_table(RHASH(copy)->tbl);
    RHASH(copy)->tbl = (st_table*)st_copy(RHASH(orig)->tbl);
    RHASH(copy)->ifnone = RHASH(orig)->ifnone;
    if (FL_TEST(orig, HASH_PROC_DEFAULT)) {
	FL_SET(copy, HASH_PROC_DEFAULT);
    }
    else {
	FL_UNSET(copy, HASH_PROC_DEFAULT);
    }
    if (FL_TEST(orig, HASH_DELETED)) {
	FL_SET(copy, HASH_DELETED);
    }
    else {
	FL_UNSET(copy, HASH_DELETED);
    }

    return copy;
}

d575 1
a575 1
rb_hash_replace(hash, hash2)
d1633 1
a1633 1
    rb_define_method(rb_cHash,"replace", rb_hash_replace, 1);
@


1.76
log
@* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.

* class.c (rb_mod_dup): need to preserve metaclass and flags.

* object.c (rb_cstr_to_dbl): had a buffer overrun.

* marshal.c (w_class): integrate singleton check into a funciton
  to follow DRY principle.

* marshal.c (w_uclass): should check singleton method.

* object.c (rb_obj_dup): dmark and dfree functions must be match
  for T_DATA type.

* object.c (rb_obj_dup): class of the duped object must be match
  to the class of the original.

* re.c (rb_reg_quote): do not escape \t, \f, \r, \n, for they are
  not regular expression metacharacters.

* time.c (time_s_alloc): use time_free instead of free (null check,
  also serves for type mark).

* time.c (time_s_at): check dfree function too.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/21 15:47:54 $
d268 3
d273 3
@


1.75
log
@*.c: Int vs Long cleanup
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/19 05:56:05 $
d251 1
a251 1
rb_hash_clone(hash)
d254 1
a254 6
    VALUE clone = rb_obj_clone(hash);

    RHASH(clone)->ifnone = RHASH(hash)->ifnone;
    RHASH(clone)->tbl = (st_table*)st_copy(RHASH(hash)->tbl);

    return clone;
d258 2
a259 2
rb_hash_dup(hash)
    VALUE hash;
d261 6
a266 4
    VALUE dup = rb_obj_dup(hash);

    if (FL_TEST(hash, HASH_PROC_DEFAULT)) {
	FL_SET(dup, HASH_PROC_DEFAULT);
d268 2
a269 2
    if (FL_TEST(hash, HASH_DELETED)) {
	FL_SET(dup, HASH_DELETED);
a270 2
    return dup;
}
d272 1
a272 5
static VALUE
to_hash(hash)
    VALUE hash;
{
    return rb_convert_type(hash, T_HASH, "Hash", "to_hash");
d977 1
a977 1
    StringValue(name);
d988 1
a988 1
	if (strcmpi(nam, "PATH") == 0 && !OBJ_TAINTED(name)) {
d990 1
a990 1
	if (strcmp(nam, "PATH") == 0 && !OBJ_TAINTED(name)) {
d1610 1
a1610 2
    rb_define_method(rb_cHash,"clone", rb_hash_clone, 0);
    rb_define_method(rb_cHash,"dup", rb_hash_dup, 0);
@


1.74
log
@* array.c (sort_2): *a - *b may overflow.

* array.c (ary_new): len*sizeof(VALUE) may be a positive value.

* array.c (rb_ary_initialize): ditto.

* object.c (rb_class_allocate_instance): move singleton class
  check from rb_obj_alloc().

* re.c (rb_reg_initialize): should not modify frozen Regexp.

* ext/tcltklib/tcltklib.c (ip_init): allocation framework.
@
text
@d6 1
a6 1
  $Date: 2002/08/13 09:21:13 $
a374 2
    VALUE key;

d1340 2
a1341 1
    int len, del = 0;
@


1.73
log
@* hash.c (rb_hash_replace): should copy ifnone.

* hash.c (rb_hash_dup): should preserve HASH_PROC_DEFAULT and
  HASH_DELETED flags.

* hash.c (rb_hash_shift): shift from empty hash should not return
  its default proc.

* hash.c (rb_hash_default_proc): new method. [new]

* array.c (rb_ary_aref): no need for Bignum check.

* array.c (rb_ary_aset): explicit Bignum check removd.

* numeric.c (fix_aref): normalize bignum before bit-op.

* bignum.c (rb_big_rand): max may be Bignum zero.

* bignum.c (rb_cstr_to_inum): should normalize bignums, to avoid
  returning fixable bignum value.

* bignum.c (rb_uint2big): there should be no zero sized bignum.

* ext/extmk.rb.in: extmake() that works properly for both tkutil
  (tk/tkutil.so) and digest/sha1.

* hash.c (rb_hash_equal): should check HASH_PROC_DEFAULT too.
@
text
@d6 1
a6 1
  $Date: 2002/08/12 07:39:08 $
d613 3
@


1.72
log
@* bignum.c (rb_big_cmp): use dbl2big() for Floats, instead of
  big2dbl().

* bignum.c (Init_Bignum): rb_big_zero_p() removed.  There may be
  Bignum zero.

* eval.c (rb_call0): new argument added for original method name.
  preserve original method name in frame->orig_func.

* eval.c (is_defined): use frame->orig_func, not last_func.

* eval.c (rb_eval): ditto.

* eval.c (method_call): supply data->oid also to rb_call0().

* object.c (rb_class_allocate_instance): call rb_obj_alloc() when
  called from alias, thus invoke original "allocate".

* eval.c (remove_method): removing allocate from classes should
  cause NameError.

* hash.c (rb_hash_equal): should check default values.

* ext/socket/socket.c (s_recvfrom): update RSTRING len.
@
text
@d6 1
a6 1
  $Date: 2002/06/13 03:55:44 $
d263 15
d371 12
d478 9
a486 2
    if (var.stop == 0) return RHASH(hash)->ifnone;
    return rb_assoc_new(var.key, var.val);
d610 4
d895 2
a896 1
    if (!rb_equal(RHASH(hash1)->ifnone, RHASH(hash2)->ifnone))
d1618 1
d1633 1
@


1.71
log
@* eval.c (svalue_to_avalue): v may be Qundef.  This fix was
  suggested by Guy Decoux.

* hash.c (rb_hash_s_create): use rb_hash_aset() instead of calling
  st_insert() directly, to dup&freeze string keys.

* parse.y (yylex): proper error message for "@@@@0".

* parse.y (yylex): paren to parse_string() must be zero for
  unparenthesized strings.

* parse.y (str_extend): broken string when unterminated "#{".

* enum.c (enum_sort_by): had a bug in 1 element enumeration.
@
text
@d5 2
a6 2
  $Author: H_Konishi $
  $Date: 2002/06/11 01:27:46 $
d27 1
d230 1
a230 1
	VALUE hash = rb_obj_alloc(klass);
a240 1
    hash = rb_hash_s_alloc(klass);
d242 1
d284 1
d856 2
@


1.70
log
@new platform [bccwin32] merged.
@
text
@d6 1
a6 1
  $Date: 2002/05/29 10:22:18 $
d243 1
a243 1
	st_insert(RHASH(hash)->tbl, argv[i], argv[i+1]);
d317 1
a317 1
		rb_raise(rb_eArgError, "wrong number of arguments", argc);
@


1.69
log
@Wed May 29 18:55:47 2002  KONISHI Hiromasa <H_Konishi@@ruby-lang.org>

	* function renames my* and win32_* to rb_w32_* in win32/win32.c
	  fixed files win32/win32.c, win32/win32.h, win32/dir.h,
	              hash.c, rubysig.h, signal.c, ext/socket/socket.c
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/29 05:20:33 $
d952 3
d956 1
d986 3
d990 1
d1024 3
d1028 1
@


1.68
log
@* parse.y: yyparse #defines moved from intern.h

* ruby.c (proc_options): access prefixed "ruby_yydebug".

* applied modifies to pacify some of gcc -Wall warnings.

* parse.y (arg): no more ugly hack for "**", so that "-2**2" to be
  parsed as "(-2)**2", whereas "- 2**2" or "-(2)**2" to be parsed
  as "-(2**2)".

* parse.y (yylex): '-2' to be literal fixnum. [new]

* time.c (time_succ): new method for Range support.

* time.c (time_arg): nil test against v[6] (usec).
@
text
@d6 1
a6 1
  $Date: 2002/05/21 05:39:18 $
d924 2
a925 2
#define GET_ENVIRON(e) (e = win32_get_environ())
#define FREE_ENVIRON(e) win32_free_environ(e)
@


1.67
log
@* object.c (Init_Object): should do exact match for Module#==.

* compar.c (cmp_eq): returns 'false' if <=> returns 'nil'.

* compar.c (cmp_gt,cmp_ge,cmp_lt,cmp_le,cmp_between): ditto.

* pack.c (pack_pack): should propagate taintedness.

* pack.c (pack_unpack): ditto.

* eval.c (rb_thread_schedule): need to preserve errno before
  calling rb_trap_exec().

* regex.c (calculate_must_string): a bug in charset/charset_not
  parsing.
@
text
@d6 1
a6 1
  $Date: 2002/05/14 06:22:26 $
a55 13
}

static VALUE
eql_failed()
{
    return Qfalse;
}

static VALUE
any_eql(args)
    VALUE *args;
{
    return rb_rescue(eql, (VALUE)args, eql_failed, 0);
@


1.66
log
@* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* numeric.c (flo_to_s): default format precision to be "%.16g".

* util.c (ruby_strtod): use own strtod(3) implementation to avoid
  locale hell.  Due to this change "0xff".to_f no longer returns 255.0

* eval.c (avalue_to_yvalue): new function to distinguish yvalue
  (no-arg == Qundef) from svalue (no-arg == Qnil).

* eval.c (rb_yield_0): use avalue_to_yvalue().

* eval.c (assign): warn if val == Qundef where it means rhs is
  void (e.g. yield without value or call without argument).

* parse.y (value_expr): need not to warn for WHILE and UNTIL,
  since they can have return value (via valued break).
@
text
@d6 1
a6 1
  $Date: 2002/03/08 07:03:03 $
d56 13
@


1.65
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.

* class.c (rb_mod_clone): should not call rb_obj_clone(), since
  Module does not provide "allocate".

* class.c (rb_singleton_class): should crate new singleton class
  if obj is a class or module and attached object is different,
  which means metaclass of singleton class is sought.

* time.c (time_s_alloc): now follows allocation framework.

* eval.c (rb_eval): should initialize outer class variables from
  methods in singleton class definitions.

* eval.c (assign): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/02/25 09:16:25 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
@


1.64
log
@* eval.c (method_inspect): should not dump core for unbound
  singleton methods.

* object.c (rb_mod_to_s): better description.

* hash.c (env_select): should path the assoc list.

* process.c (rb_syswait): thread kludge; should be fixed to
  support native thread.
@
text
@d6 1
a6 1
  $Date: 2002/02/20 04:31:50 $
d100 1
a100 1
	    hval %= 536870917;
d103 1
a103 1
	    hval = rb_funcall(hval, '%', 1, INT2FIX(536870917));
@


1.63
log
@* hash.c (rb_any_cmp): should handle Qundef in keys.

* eval.c (remove_method): should not remove a empty method to
  implement "undef".

* eval.c (rb_eval): should allow singleton class def for
  true/false/nil.

* parse.y (str_extend): backslash escape was done wrong.
@
text
@d6 1
a6 1
  $Date: 2002/01/28 08:44:37 $
d1330 4
a1333 4
		VALUE str = rb_tainted_str_new(*env, s-*env);

		if (RTEST(rb_yield(str))) {
		    rb_ary_push(result, str);
@


1.62
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.

* object.c (Init_Object): remove dup and clone from TrueClass,
  FalseClass, and NilClass.

* array.c (rb_ary_fill): Array#fill takes block to get the value to
  fill.

* string.c (rb_str_to_i): to_i(0) auto-detects base radix.

* array.c (rb_ary_initialize): fill by the block evaluation value
  if block is given.
@
text
@d6 1
a6 1
  $Date: 2002/01/25 08:22:04 $
d73 1
@


1.61
log
@* class.c (rb_include_module): detect cyclic module inclusion.

* eval.c (rb_thread_cleanup): need not to free thread stacks at
  process termination.

* array.c (rb_ary_fetch): use the block to get the default value
  if the block is given.

* eval.c (rb_thread_schedule): should check time only if BOTH
  WAIT_SELECT and WAIT_TIME.

* eval.c (umethod_bind): should update rklass field.

* hash.c (rb_hash_update): if a block is given, yields [key,
  value1, value2] to the block to resolve conflict.

* string.c (rb_str_split_m): no need to consider KANJI
characters, if the length of separator is 1 (byte).
@
text
@d6 1
a6 1
  $Date: 2002/01/11 09:18:50 $
d204 2
a205 2
	if (argc > 1) {
	    rb_raise(rb_eArgError, "wrong number of arguments", argc);
@


1.60
log
@* re.c (match_select): should propagate taintness.

* hash.c (rb_hash_set_default): Hash#default= should return the
  new value.

* string.c (rb_str_to_i): accepts optional base argument. [new]

* numeric.c (rb_fix2str): should not handle negative fixnum values
  int32 via calling sprintf() directly.
@
text
@d6 1
a6 1
  $Date: 2001/12/11 03:48:08 $
d892 13
d910 6
a915 1
    st_foreach(RHASH(hash2)->tbl, rb_hash_update_i, hash1);
d1006 1
a1006 1
		rb_raise(rb_eArgError, "wrong number of arguments", argc);
@


1.59
log
@* string.c (rb_str_match_m): should convert an argument into
  regexp if it's a string.

* array.c (rb_ary_select): Array#select(n,m,...) now works like
  Array#indexes(n,m,..). [new, experimental]

* hash.c (rb_hash_select): ditto.

* hash.c (env_select): ditto.

* re.c (match_select): ditto.

* struct.c (rb_struct_select): ditto.

* gc.c (STR_ASSOC): use FL_USER3 instead of FL_USER2.

* parse.y (str_extend): make up pushback call.
@
text
@d6 1
a6 1
  $Date: 2001/12/10 07:18:12 $
d350 1
a350 1
    return hash;
@


1.58
log
@* array.c (rb_ary_modify): should copy the internal buffer if the
  modifying buffer is shared.

* array.c (ary_make_shared): make an internal buffer of an array
  to be shared.

* array.c (rb_ary_shift): avoid sliding an internal buffer by
  using shared buffer.

* array.c (rb_ary_subseq): avoid copying the buffer.

* parse.y (gettable): should freeze __LINE__ string.

* io.c (rb_io_puts): old behavoir restored.  rationale: a) if you
  want to call to_s for arrays, you can just call print a, "\n".
  b) to_s wastes memory if array (and sum of its contents) is
  huge.  c) now any object that has to_ary is treated as an array,
  using rb_check_convert_type().

* hash.c (rb_hash_initialize): now accepts a block to calculate
  the default value. [new]

* hash.c (rb_hash_aref): call "default" method to get the value
  corrensponding to the non existing key.

* hash.c (rb_hash_default): get the default value based on the
  block given to 'new'.  Now it takes an optinal "key" argument.
  "default" became the method to get the value for non existing
  key.  Users may override "default" method to change the hash
  behavior.

* hash.c (rb_hash_set_default): clear the flag if a block is given
  to 'new'

* object.c (Init_Object): undef Data.allocate, left Data.new.

* ext/curses/curses.c (window_scrollok): use RTEST().

* ext/curses/curses.c (window_idlok): ditto.

* ext/curses/curses.c (window_keypad): ditto.

* ext/curses/curses.c (window_idlok): idlok() may return void on
  some platforms; so don't use return value.

* ext/curses/curses.c (window_scrollok): ditto for consistency.

* ext/curses/curses.c: replace FIX2INT() by typechecking NUM2INT().

* parse.y (str_extend): should not process immature #$x and
  #@@x interpolation, e.g #@@#@@ etc.

* enum.c (enum_sort_by): sort_by does not have to be stable always.

* enum.c (enum_sort_by): call qsort directly to gain performance.

* util.c (ruby_qsort): ruby_qsort(qs6) is now native thread safe.

* error.c (rb_sys_fail): it must be a bug if it's called when
  errno == 0.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 05:03:03 $
d388 2
d489 36
d1294 36
d1484 2
d1577 1
d1609 1
@


1.57
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* massages: replace "wrong #" by "wrong number".

* marshal.c (w_float): output Infinity and NaN explicitly.

* marshal.c (r_object): support new explicit float format.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.

* array.c (rb_ary_join): dumped core if sep is not T_STRING nor T_NIL.

* array.c (rb_ary_join): buffer size calculattion was wrong.

* array.c (rb_ary_to_s): if rb_output_fs is nil, insert newlines
  between array elements (use rb_default_rs as newline litral)
  [experimental].

* gc.c (init_mark_stack): no need to clear mark_stack.

* gc.c (gc_mark_all): need to handle finalizer mark.

* gc.c (gc_mark_rest): use MEMCPY instead of memcpy.

* gc.c (rb_gc_mark): earlier const check to avoid pusing special
  constants into mark stack.

* numeric.c (fix_to_s): 'to_s' now takes optional argument to
  specify radix. [new]

* bignum.c (rb_big_to_s): ditto. [new]
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/11/14 18:41:45 $
d21 1
d42 1
a42 1
static ID hash;
d48 1
a48 1
    return rb_funcall(obj, hash, 0);
d97 1
a97 1
	hval = rb_funcall(a, hash, 0);
a201 1
    rb_scan_args(argc, argv, "01", &ifnone);
d203 11
a213 1
    RHASH(hash)->ifnone = ifnone;
d297 1
a297 1
	return RHASH(hash)->ifnone;
d329 3
a331 1
rb_hash_default(hash)
d334 6
d349 1
d414 1
a414 1
    return RHASH(hash)->ifnone;
d1455 3
a1457 1
    hash = rb_intern("hash");
d1480 1
a1480 1
    rb_define_method(rb_cHash,"default", rb_hash_default, 0);
@


1.56
log
@	* hash.c (ruby_setenv): remove USE_WIN32_RTL_ENV block since it's
	  obsoleted.

	* win32/win32.c, win32/win32.h: sort out #if 0 - #endif or others.
@
text
@d6 1
a6 1
  $Date: 2001/11/13 03:59:20 $
d306 1
a306 1
		rb_raise(rb_eArgError, "wrong # of arguments", argc);
d931 1
a931 1
		rb_raise(rb_eArgError, "wrong # of arguments", argc);
@


1.55
log
@	* hash.c (envix): use GET_ENVIRON and FREE_ENVIRON to get environment
	  variables list.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_key): ditto.

	* hash.c (env_values): ditto.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_value): ditto.

	* hash.c (env_each): ditto.

	* hash.c (env_inspect): ditto.

	* hash.c (env_to_a): ditto.

	* hash.c (env_size): ditto.

	* hash.c (env_empty_p): ditto.

	* hash.c (env_has_value): ditto.

	* hash.c (env_index): ditto.

	* hash.c (env_to_hash): ditto.

	* win32/win32.c (win32_getenv): use static buffer.

	* win32/win32.c, win32/win32.h (win32_get_environ): get environment
	  variables list. [new]

	* win32/win32.c, win32/win32.h (win32_free_environ): free environment
	  variables list. [new]

	* win32/win32.c (do_spawn): use CreateChild() instead of calling
	  CreateProcess() directly. Original patches comes from Patrick Cheng.

	* win32/win32.c (mypopen): ditto.

	* win32/win32.c (mypclose): use rb_syswait() instead of waiting in this
	  function.

	* win32/win32.c (waitpid): use wait_child() instead of _cwait().

	* win32/win32.c (CreateChild): added. [new]

	* win32/win32.c (wait_child): added. [new]

	* win32/win32.c (FindFirstChildSlot): added. [new]

	* win32/win32.c (FindChildSlot): added. [new]

	* win32/win32.c (FindPipedChildSlot): added. [new]

	* win32/win32.c (CloseChildHandle): added. [new]

	* win32/win32.c (FindFreeChildSlot): added. [new]
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/29 05:07:18 $
a988 38
#ifdef USE_WIN32_RTL_ENV
    register char *envstr;
    STRLEN namlen = strlen(name);
    STRLEN vallen;
    char *oldstr = environ[envix(name)];

    /* putenv() has totally broken semantics in both the Borland
     * and Microsoft CRTLs.  They either store the passed pointer in
     * the environment without making a copy, or make a copy and don't
     * free it. And on top of that, they dont free() old entries that
     * are being replaced/deleted.  This means the caller must
     * free any old entries somehow, or we end up with a memory
     * leak every time setenv() is called.  One might think
     * one could directly manipulate environ[], like the UNIX code
     * above, but direct changes to environ are not allowed when
     * calling putenv(), since the RTLs maintain an internal
     * *copy* of environ[]. Bad, bad, *bad* stink.
     * GSAR 97-06-07
     */

    if (!value) {
	if (!oldstr)
	    return;
	value = "";
	vallen = 0;
    }
    else
	vallen = strlen(val);
    envstr = ALLOC_N(char, namelen + vallen + 3);
    sprintf(envstr,"%s=%s",name,value);
    putenv(envstr);
    if (oldstr) free(oldstr);
#ifdef _MSC_VER
    free(envstr);		/* MSVCRT leaks without this */
#endif

#else /* !USE_WIN32_RTL_ENV */

d1002 3
a1006 2
#endif

@


1.54
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* variable.c (rb_cvar_set): empty iv_tbl may cause infinite loop.

* variable.c (rb_cvar_get): ditto.

* variable.c (cvar_override_check): ditto.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.

* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.
@
text
@d6 1
a6 1
  $Date: 2001/10/03 07:19:10 $
d846 8
a853 1
#ifndef NT
d855 2
a857 1
static char **origenviron;
d966 1
d968 2
a969 1
    for (i = 0; environ[i]; i++) {
d972 1
a972 1
	    strnicmp(environ[i],nam,len) == 0
d974 1
a974 1
	    memcmp(environ[i],nam,len) == 0
d976 1
a976 1
	    && environ[i][len] == '=')
d979 1
d1155 1
a1155 1
    env = environ;
d1163 1
d1173 1
a1173 1
    env = environ;
d1181 1
d1191 1
a1191 1
    env = environ;
d1199 1
d1209 1
a1209 1
    env = environ;
d1217 1
d1227 1
a1227 1
    env = environ;
d1236 1
d1286 1
a1286 1
    env = environ;
d1302 1
d1315 1
a1315 1
    env = environ;
d1324 1
d1338 1
d1340 2
a1341 1
    for(i=0; environ[i]; i++)
d1343 1
d1350 8
a1357 1
    if (environ[0] == 0) return Qtrue;
d1381 1
a1381 1
    env = environ;
d1385 2
a1386 1
	    if (strncmp(s, RSTRING(value)->ptr, strlen(s)) == 0)
d1388 1
d1392 1
d1401 1
d1404 1
a1404 1
    env = environ;
d1409 3
a1411 1
		return rb_tainted_str_new(*env, s-*env-1);
d1416 1
d1451 1
a1451 1
    env = environ;
d1460 1
@


1.53
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/08/23 06:02:15 $
d1101 1
a1101 1
rb_f_setenv(obj, nm, val)
d1129 1
a1129 1
	    return Qtrue;
d1135 1
a1135 1
    return Qtrue;
d1502 2
a1503 2
    rb_define_singleton_method(envtbl,"[]=", rb_f_setenv, 2);
    rb_define_singleton_method(envtbl,"store", rb_f_setenv, 2);
@


1.52
log
@* eval.c (is_defined): should not dump core for "defined?(())".

* eval.c (umethod_bind): recv can be an instance of descender of
  oklass if oklass is a Module.

* hash.c (rb_hash_equal): check identiry equality first.

* file.c (group_member): should check real gid only.

* file.c (eaccess): do not cache euid, since effective euid may be
  changed via Process.euid=().

* file.c (eaccess): return -1 unless every specified access mode
  is permitted.

* eval.c (rb_eval): while/until returns the value which is given
  to break.

* parse.y (value_expr): using while/until/class/def as an
  expression is now gives a warning, not an error.

* range.c (range_eqq): should compare strings based on magical
  increment (using String#upto), not dictionary order.

* enum.c (enum_sort_by): new method for Schewartzian transformed
  stable sort.

* variable.c (mod_av_set): detect constant overriding for built-in
  classes/modules.
@
text
@d6 1
a6 1
  $Date: 2001/07/31 06:24:42 $
d175 1
a175 1
rb_hash_new2(klass)
d190 1
a190 13
    return rb_hash_new2(rb_cHash);
}

static VALUE
rb_hash_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE hash = rb_hash_new2(klass);

    rb_obj_call_init(hash, argc, argv);
    return hash;
d218 1
a218 2
	NEWOBJ(hash, struct RHash);
	OBJSETUP(hash, klass, T_HASH);
d220 2
a221 2
	hash->ifnone = Qnil;
	hash->tbl = st_copy(RHASH(argv[0])->tbl);
d223 1
a223 1
	return (VALUE)hash;
d229 1
a229 1
    hash = rb_hash_new2(klass);
d242 1
a242 2
    NEWOBJ(clone, struct RHash);
    CLONESETUP(clone, hash);
d244 2
a245 2
    clone->ifnone = RHASH(hash)->ifnone;
    clone->tbl = (st_table*)st_copy(RHASH(hash)->tbl);
d247 1
a247 1
    return (VALUE)clone;
d1443 1
a1443 1
    rb_define_singleton_method(rb_cHash, "new", rb_hash_s_new, -1);
@


1.51
log
@* marshal.c (Init_marshal): new constant Marshal::MAJOR_VERSION
  and Marshal::MINOR_VERSION.

* marshal.c (marshal_load): ruby_verbose test should be wrapped by
  RTEST().

* hash.c (rb_hash_index): should return nil (not the default
  value) if value is not in the hash.

* numeric.c (num_div): new method added.  alias to '/' which
  should be preserved even if '/' is redefined (e.g. by
  mathn). [new]

* bignum.c (rb_cstr2inum): "0 ff".hex should return 0, not 255.

* file.c (rb_file_s_expand_path): fixed using CharNext().
@
text
@d6 1
a6 1
  $Date: 2001/07/24 09:07:33 $
d807 1
@


1.50
log
@* eval.c (rb_provide_feature): should not tweak extension used for
  loading.

* io.c (io_fread): use fread(3) if PENDING_COUND is available.

* class.c (rb_mod_include_p): Module#include? added. [new]

* re.c (ignorecase_setter): give warning on modifying $=.

* string.c (rb_str_casecmp): new method. [new]

* string.c (rb_str_eql): separated from rb_str_equal(), make it
  always be case sensitive. [new]

* string.c (rb_str_hash): made it always be case sensitive.

* eval.c (rb_f_require): should not include path in $" value

* file.c (rb_find_file): should return 0 explicitly on failure.
@
text
@d6 1
a6 1
  $Date: 2001/06/22 09:12:19 $
d367 1
a367 1
    args[1] = RHASH(hash)->ifnone;
@


1.49
log
@* eval.c (rb_yield_0): no mvalue_to_svalue conversion here.

* eval.c (massign): takes svalue, convert it to mvalue inside.

* eval.c (rb_eval): parameters for yield/return are always
  svalues now.

* eval.c (svalue_to_mvalue): more strict conversion.

* eval.c (mvalue_to_svalue): ditto.

* st.c (new_size): prime hash size enabled.

* ext/socket/socket.c (Init_socket): SO_* constants added.
@
text
@d6 1
a6 1
  $Date: 2001/06/12 05:31:46 $
d391 1
a391 1
static VALUE
@


1.48
log
@* eval.c (method_eq): new method Method#==. [new]

* gc.c (STR_NO_ORIG): STR_NO_ORIG value was different between
  string.c and gc.c

* eval.c (rb_eval): should convert *non-array at the end of
  arguments by using Array().

* hash.c (ruby_setenv): readline library leaves their environment
  strings uncopied.  "free" check revised.
@
text
@d6 1
a6 1
  $Date: 2001/06/08 14:20:19 $
d671 2
a672 1
    if (RHASH(hash)->tbl->num_entries == 0) return rb_str_new2("{}");
@


1.47
log
@* gc.c (Init_stack): avoid __builtin_frame_address(2) to retrieve
  stack bottom line.

* st.c (numhash): should shuffle bits by dividing by prime number.

* eval.c (rb_eval): multiple assignment behavior fixed, which
  results "*a = nil" makes "a == []" now.

* eval.c (rb_f_require): should set SCOPE_PUBLIC before calling
  dln_load().
@
text
@d6 1
a6 1
  $Date: 2001/06/01 09:38:11 $
d1069 6
a1074 2
	if (environ[i] != origenviron[i])
	    free(environ[i]);
@


1.46
log
@* hash.c (replace_i): ignore when key == Qundef.
@
text
@d6 1
a6 1
  $Date: 2001/05/30 09:12:34 $
d97 5
a101 2
	if (!FIXNUM_P(hval)) {
	    hval = rb_funcall(hval, '%', 1, INT2FIX(65439));
@


1.45
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d6 1
a6 1
  $Date: 2001/05/16 09:05:49 $
d513 4
a516 1
    rb_hash_aset(hash, key, val);
@


1.44
log
@* array.c (rb_ary_and): should not push frozen key string.

* array.c (rb_ary_or): ditto.

* eval.c (rb_thread_schedule): should save context before raising
  deadlock, saved context for current thread might be obsolete.

* time.c (make_time_t): non DST timezone shift supported (hopefully).

* time.c (make_time_t): strict range detection for negative time_t.

* signal.c: SIGINFO added.

* eval.c (rb_ensure): should not SEGV when prot_tag is NULL.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:10 $
d637 1
a637 1
    rb_str_append(str, str2);
d639 1
a639 1
    rb_str_cat2(str, "=>");
d641 1
a641 1
    rb_str_append(str, str2);
d653 1
a653 1
    str = rb_str_new2("{");
d655 1
a655 2
    rb_str_cat2(str, "}");
    
d657 1
d1269 1
a1269 1
    VALUE str = rb_str_new2("{");
d1277 1
a1277 1
	    rb_str_cat2(str, ", ");
d1280 3
a1282 3
	    rb_str_cat2(str, "\"");
	    rb_str_cat(str, *env, s-*env);
	    rb_str_cat2(str, "\"=>");
d1284 1
a1284 1
	    rb_str_append(str, i);
d1288 1
a1288 1
    rb_str_cat2(str, "}");
@


1.43
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d6 1
a6 1
  $Date: 2001/02/14 05:51:57 $
a895 1
    int len;
a1106 1
    int nlen, vlen;
@


1.42
log
@* dir.c (dir_s_glob): supprt backslash escape of metacharacters
  and delimiters.

* dir.c (remove_backslases): remove backslashes from path before
  calling stat(2).

* dir.c (dir_s_glob): call rb_yield directly (via push_pattern) if
  block is given to the method.

* dir.c (push_pattern): do not call rb_ary_push; yield directly.

* eval.c (blk_copy_prev): reduced ALLOC_N too much.

* eval.c (frame_dup): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/02/13 05:08:59 $
a860 1
    int len;
d864 3
a866 2
    nam = rb_str2cstr(name, &len);
    if (strlen(nam) != len) {
d898 3
a900 2
    nam = rb_str2cstr(name, &len);
    if (strlen(nam) != len) {
a918 1
    int len;
d921 3
a923 2
    nam = rb_str2cstr(key, &len);
    if (strlen(nam) != len) {
d1119 5
a1123 3
    name = rb_str2cstr(nm, &nlen);
    value = rb_str2cstr(val, &vlen);
    if (strlen(name) != nlen)
d1125 1
a1125 1
    if (strlen(value) != vlen)
d1341 6
a1346 2
    if (TYPE(key) != T_STRING) return Qfalse;
    if (getenv(STR2CSTR(key))) return Qtrue;
@


1.41
log
@* io.c (rb_io_ctl): do not call ioctl/fcntl for f2, if f and f2
  have same fileno.

* eval.c (rb_load): raise LocaJumpError if unexpected local jumps
  appear during load.

* ext/socket/socket.c (bsock_close_read): don't call rb_thread_fd_close();
  it's supposed to be called by io_io_close().

* ext/socket/socket.c (bsock_close_read): do not modify f and f2.

* ext/socket/socket.c (bsock_close_write): ditto.

* ext/socket/socket.c (sock_new): avoid dup(2) on sockets.

* parse.y (primary): preserve and clear in_single and in_def using
  stack to prevent nested method errors in singleton class bodies.
@
text
@d6 1
a6 1
  $Date: 2001/01/15 07:00:53 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.40
log
@Mon Jan 15 16:00:07 2001  Yukihiro Matsumoto  <matz@@ruby-lang.org>

	* pack.c (pack_unpack): should check associated pointer packed by
	  pack("P").  restriction added.

Sun Jan 14 21:49:28 2001  Koji Arai  <JCA02266@@nifty.ne.jp>

	* sprintf.c (rb_f_sprintf): simple typo.  binary base should be 2,
	  not '2'.

	* re.c (rb_reg_s_last_match): should explicitly return nth match.
@
text
@d6 1
a6 1
  $Date: 2000/12/25 06:28:59 $
d82 1
a82 1
    unsigned int hval;
d87 1
a87 1
	hval = a;
d91 1
a91 1
	hval = rb_str_hash(a);
d101 1
a101 1
	hval = FIX2LONG(hval);
a102 1
    return  hval;
@


1.39
log
@001225
@
text
@d6 1
a6 1
  $Date: 2000/12/18 09:45:59 $
d384 1
a385 1
    RARRAY(indexes)->len = i;
@


1.39.2.1
log
@* parse.y (primary): preserve and clear in_single and in_def using
  stack to prevent nested method errors in singleton class bodies.
@
text
@d6 1
a6 1
  $Date: 2000/12/25 06:28:59 $
d82 1
a82 1
    VALUE hval;
d87 1
a87 1
	return (int)a;
d91 1
a91 1
	return rb_str_hash(a);
d101 1
a101 1
	return (int)FIX2LONG(hval);
d103 1
@


1.39.2.2
log
@* hash.c (replace_i): ignore when key == Qundef.
@
text
@d6 1
a6 1
  $Date: 2001/02/13 05:10:43 $
d513 1
a513 4
    if (key != Qundef) {
	rb_hash_aset(hash, key, val);
    }

@


1.39.2.3
log
@* hash.c (ruby_setenv): readline library leaves their environment
  strings uncopied.  "free" check revised.

* st.c (numhash): should shuffle bits by dividing by prime number.
@
text
@d6 1
a6 1
  $Date: 2001/06/01 09:38:30 $
d1066 2
a1067 6
	if (environ != origenviron) {
	    char **envp = origenviron;
	    while (*envp && *envp != environ[i]) envp++;
	    if (!*envp)
		free(environ[i]);
	}
@


1.39.2.4
log
@* marshal.c (marshal_load): ruby_verbose test should be wrapped by
  RTEST().

* hash.c (rb_hash_index): should return nil (not the default
  value) if value is not in the hash.

* bignum.c (rb_cstr2inum): "0 ff".hex should return 0, not 255.
@
text
@d6 1
a6 1
  $Date: 2001/06/11 06:26:17 $
d364 1
a364 1
    args[1] = Qnil;
@


1.39.2.5
log
@* eval.c (is_defined): should not dump core for "defined?(())".

* eval.c (umethod_bind): recv can be an instance of descender of
  oklass if oklass is a Module.

* hash.c (rb_hash_equal): check identiry equality first.

* variable.c (mod_av_set): detect constant overriding for built-in
  classes/modules.

* marshal.c (w_object): should retrieve __member__ data from
  non-singleton class.
@
text
@d6 1
a6 1
  $Date: 2001/07/31 06:20:10 $
a802 1
    if (hash1 == hash2) return Qtrue;
@


1.39.2.6
log
@	* hash.c (envix): merge from 1.7: use GET_ENVIRON and FREE_ENVIRON to
	  get environment variables list.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_key): ditto.

	* hash.c (env_values): ditto.

	* hash.c (env_keys): ditto.

	* hash.c (env_each_value): ditto.

	* hash.c (env_each): ditto.

	* hash.c (env_inspect): ditto.

	* hash.c (env_to_a): ditto.

	* hash.c (env_size): ditto.

	* hash.c (env_empty_p): ditto.

	* hash.c (env_has_value): ditto.

	* hash.c (env_index): ditto.

	* hash.c (env_to_hash): ditto.

	* win32/win32.c (win32_getenv): merge from 1.7: use static buffer.

	* win32/win32.c, win32/win32.h (win32_get_environ): merge from 1.7:
	  get environment variables list.

	* win32/win32.c, win32/win32.h (win32_free_environ): merge from 1.7:
	  free environment variables list.

	* win32/Makefile.sub: merge from 1.7: add -DLIBRUBY_SO to CPPFLAGS.
@
text
@d6 1
a6 1
  $Date: 2001/08/23 06:00:30 $
d856 1
a856 8
static char **origenviron;
#ifdef NT
#define GET_ENVIRON(e) (e = win32_get_environ())
#define FREE_ENVIRON(e) win32_free_environ(e)
static char **my_environ;
#undef environ
#define environ my_environ
#else
a857 2
#define GET_ENVIRON(e) (e)
#define FREE_ENVIRON(e)
d859 1
a967 1
    char **env;
d969 1
a969 2
    env = GET_ENVIRON(environ);
    for (i = 0; env[i]; i++) {
d972 1
a972 1
	    strnicmp(env[i],nam,len) == 0
d974 1
a974 1
	    memcmp(env[i],nam,len) == 0
d976 1
a976 1
	    && env[i][len] == '=')
a978 1
    FREE_ENVIRON(environ);
d1153 1
a1153 1
    env = GET_ENVIRON(environ);
a1160 1
    FREE_ENVIRON(environ);
d1170 1
a1170 1
    env = GET_ENVIRON(environ);
a1177 1
    FREE_ENVIRON(environ);
d1187 1
a1187 1
    env = GET_ENVIRON(environ);
a1194 1
    FREE_ENVIRON(environ);
d1204 1
a1204 1
    env = GET_ENVIRON(environ);
a1211 1
    FREE_ENVIRON(environ);
d1221 1
a1221 1
    env = GET_ENVIRON(environ);
a1229 1
    FREE_ENVIRON(environ);
d1279 1
a1279 1
    env = GET_ENVIRON(environ);
a1294 1
    FREE_ENVIRON(environ);
d1307 1
a1307 1
    env = GET_ENVIRON(environ);
a1315 1
    FREE_ENVIRON(environ);
a1328 1
    char **env;
d1330 1
a1330 2
    env = GET_ENVIRON(environ);
    for(i=0; env[i]; i++)
a1331 1
    FREE_ENVIRON(environ);
d1338 1
a1338 8
    char **env;

    env = GET_ENVIRON(environ);
    if (env[0] == 0) {
	FREE_ENVIRON(environ);
	return Qtrue;
    }
    FREE_ENVIRON(environ);
d1358 1
a1358 1
    env = GET_ENVIRON(environ);
d1362 1
a1362 2
	    if (strncmp(s, RSTRING(value)->ptr, strlen(s)) == 0) {
		FREE_ENVIRON(environ);
a1363 1
	    }
a1366 1
    FREE_ENVIRON(environ);
a1374 1
    VALUE str;
d1377 1
a1377 1
    env = GET_ENVIRON(environ);
d1382 1
a1382 3
		str = rb_tainted_str_new(*env, s-*env-1);
		FREE_ENVIRON(environ);
		return str;
a1386 1
    FREE_ENVIRON(environ);
d1421 1
a1421 1
    env = GET_ENVIRON(environ);
a1429 1
    FREE_ENVIRON(environ);
@


1.39.2.7
log
@* eval.c (ruby_stop): should not trace error handler.

* io.c (io_write): should not raise exception on O_NONBLOCK io.

* dir.c (dir_set_pos): seek should return dir, pos= should not.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/11/13 08:32:19 $
d342 1
a342 1
    return ifnone;
@


1.39.2.8
log
@* hash.c (rb_any_cmp): should handle Qundef in keys.

* eval.c (remove_method): should not remove a empty method to
  implement "undef".

* eval.c (rb_eval): should allow singleton class def for
  true/false/nil.

* parse.y (str_extend): backslash escape was done wrong.

* class.c (rb_include_module): should preserve ancestor order in
  the included class/module.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/21 07:43:40 $
a71 1
    if (a == Qundef || b == Qundef) return -1;
@


1.39.2.9
log
@* ext/digest/*/*.h: Merge from rough.
  - Avoid namespace pollution. (MD5_* -> rb_Digest_MD5_*, etc.)
@
text
@d6 1
a6 1
  $Date: 2002/02/20 04:28:51 $
d1150 1
a1150 1
	    return val;
d1156 1
a1156 1
    return val;
@


1.39.2.10
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2002/02/24 08:25:09 $
d99 1
a99 1
	    hval = rb_funcall(hval, '%', 1, INT2FIX(536870923));
@


1.39.2.11
log
@* hash.c (rb_hash_s_create): use rb_hash_aset() instead of calling
  st_insert() directly, to dup&freeze string keys.

* parse.y (yylex): proper error message for "@@@@0".

* parse.y (yylex): paren to parse_string() must be zero for
  unparenthesized strings.

* parse.y (str_extend): broken string when unterminated "#{".
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/08 06:59:52 $
d243 1
a243 1
        rb_hash_aset(hash, argv[i], argv[i + 1]);
d318 1
a318 1
		rb_raise(rb_eArgError, "wrong # of arguments");
@


1.39.2.12
log
@* hash.c (rb_hash_equal): should check default values.

* ext/socket/socket.c (s_recvfrom): update RSTRING len.
@
text
@d6 1
a6 1
  $Date: 2002/06/13 03:54:39 $
a806 2
	return Qfalse;
    if (!rb_equal(RHASH(hash1)->ifnone, RHASH(hash2)->ifnone))
@


1.39.2.13
log
@* hash.c, eval.c: Use (*_NSGetEnviron()) instead of environ on
  Darwin for namespace cleanness.  [ruby-core:00537]

* dln.c (dln_load): Fix Darwin support that has been disabled and
  switch to using it on Darwin instead of the system dlopen().
  [ruby-core:00541]
@
text
@d6 1
a6 1
  $Date: 2002/08/12 07:40:32 $
a19 4
#ifdef __APPLE__
#include <crt_externs.h>
#endif

a865 5
#elif defined(__APPLE__)
#undef environ
#define environ (*_NSGetEnviron())
#define GET_ENVIRON(e) (e)
#define FREE_ENVIRON(e)
@


1.38
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/05 09:36:26 $
d62 2
a63 2
    if (FIXNUM_P(a)) {
	if (FIXNUM_P(b)) return a != b;
d65 6
a70 2
    else if (TYPE(a) == T_STRING) {
	if (TYPE(b) == T_STRING) return rb_str_cmp(a, b);
d86 1
@


1.37
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/12 05:37:23 $
d336 1
@


1.36
log
@matz: 1.6.0 final (hopufully)
@
text
@d6 1
a6 1
  $Date: 2000/09/04 08:24:01 $
d1260 29
d1505 1
@


1.35
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/09 04:32:17 $
d1058 2
a1059 1
	free(environ[i]);
d1071 2
a1072 1
	free(environ[i]);
@


1.34
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/07 05:01:53 $
d616 3
a618 1
    return rb_ary_sort_bang(rb_hash_to_a(hash));
@


1.33
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/27 09:49:19 $
a173 1
    hash->iter_lev = 0;
a174 1
    hash->tbl = 0;		/* avoid GC crashing  */
a225 1
	hash->iter_lev = 0;
a226 1
	hash->tbl = 0;	/* avoid GC crashing  */
a250 1
    clone->iter_lev = 0;
a251 1
    clone->tbl = 0;		/* avoid GC crashing  */
@


1.32
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/21 08:45:31 $
d459 2
d462 7
d1223 1
a1223 1
env_delete_if()
d1227 1
a1227 1
    int len;
d1239 1
d1244 8
a1445 1
    rb_define_method(rb_cHash,"reject!", rb_hash_delete_if, 0);
d1447 1
a1474 1
    rb_define_singleton_method(envtbl,"reject!", env_delete_if, 0);
d1476 1
@


1.31
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/17 09:37:59 $
a18 5

#ifndef HAVE_STRING_H
char *strchr _((char*,char));
char *strdup _((const char*));
#endif
@


1.30
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/04 07:04:32 $
d22 1
@


1.29
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/22 08:29:43 $
a267 21
rb_hash_dup(hash)
    VALUE hash;
{
    VALUE klass = CLASS_OF(hash);

    NEWOBJ(dup, struct RHash);
    while (TYPE(klass) == T_ICLASS || FL_TEST(klass, FL_SINGLETON)) {
	klass = (VALUE)RCLASS(klass)->super;
    }
    OBJSETUP(dup, klass, T_HASH);

    dup->iter_lev = 0;
    dup->ifnone = RHASH(hash)->ifnone;
    dup->tbl = 0;		/* avoid GC crashing  */
    dup->tbl = (st_table*)st_copy(RHASH(hash)->tbl);

    if (OBJ_TAINTED(hash)) OBJ_TAINT(dup);
    return (VALUE)dup;
}

static VALUE
d471 1
a471 1
    return rb_hash_delete_if(rb_hash_dup(hash));
a1398 1
    rb_define_method(rb_cHash,"dup", rb_hash_dup, 0);
@


1.28
log
@2000-06-22
@
text
@d6 1
a6 1
  $Date: 2000/05/24 04:33:59 $
d478 1
a478 1
static VALUE
@


1.27
log
@2000-05-24
@
text
@d6 1
a6 1
  $Date: 2000/05/12 09:07:40 $
d271 2
d274 4
a277 1
    OBJSETUP(dup, CLASS_OF(hash), T_HASH);
@


1.26
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/09 04:52:58 $
d337 1
a337 1
	if (rb_iterator_p()) {
d424 1
a424 1
    if (rb_iterator_p()) {
d897 1
a897 1
    if (rb_iterator_p()) rb_yield(name);
d937 1
a937 1
	if (rb_iterator_p()) {
@


1.25
log
@2000-05-09
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:19 $
a690 2
    VALUE str;

a928 2

    VALUE val;
@


1.24
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/12 05:06:21 $
d11 1
a11 1
  Copyright (C) 2000  Information-technology Promotion Agancy, Japan
@


1.23
log
@mkmf
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/04/10 05:44:10 $
d10 2
d13 1
a13 1
************************************************/
@


1.22
log
@2000-04-10
@
text
@d6 1
a6 1
  $Date: 2000/03/23 08:37:25 $
d339 1
a339 1
	    return rb_yield(argv[0]);
d921 34
d1471 1
d1473 1
@


1.21
log
@2000-03-23
@
text
@d6 1
a6 1
  $Date: 2000/03/15 09:05:37 $
d642 1
a642 1
	rb_str_cat(str, ", ", 2);
d645 1
a645 1
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d647 1
a647 1
    rb_str_cat(str, "=>", 2);
d649 1
a649 1
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d663 1
a663 1
    rb_str_cat(str, "}", 1);
@


1.20
log
@2000-03-15
@
text
@d6 1
a6 1
  $Date: 2000/03/07 08:37:36 $
d414 5
a418 4
    if (RHASH(hash)->iter_lev > 0 &&
	st_delete_safe(RHASH(hash)->tbl, &key, &val, Qundef)) {
	FL_SET(hash, HASH_DELETED);
	return val;
@


1.19
log
@2000-03-07
@
text
@d6 1
a6 1
  $Date: 2000/02/29 08:05:25 $
d226 3
a228 4
    if (argc == 1) {
	if (TYPE(argv[0]) == T_HASH) {
	    NEWOBJ(hash, struct RHash);
	    OBJSETUP(hash, klass, T_HASH);
d230 4
a233 4
	    hash->iter_lev = 0;
	    hash->ifnone = Qnil;
	    hash->tbl = 0;	/* avoid GC crashing  */
	    hash->tbl = st_copy(RHASH(argv[0])->tbl);
d235 1
a235 6
	    return (VALUE)hash;
	}
	else {
	    VALUE a = rb_Array(argv[0]);
	    return rb_hash_s_create(RARRAY(a)->len, RARRAY(a)->ptr, klass);
	}
@


1.18
log
@2000-02-29
@
text
@d6 1
a6 1
  $Date: 2000/02/25 03:51:18 $
a19 4
#endif

#ifdef USE_CWGUSI
char* strdup(const char*);
@


1.17
log
@2000-02-25
@
text
@d6 1
a6 1
  $Date: 2000/02/23 05:23:05 $
d174 1
a174 3
rb_hash_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
a176 2
    VALUE ifnone;

a182 4

    rb_scan_args(argc, argv, "01", &ifnone);

    hash->ifnone = ifnone;
d188 6
d195 3
a197 1
rb_hash_new2(klass)
d200 1
a200 2
    NEWOBJ(hash, struct RHash);
    OBJSETUP(hash, klass, T_HASH);
d202 2
a203 6
    hash->iter_lev = 0;
    hash->ifnone = Qnil;
    hash->tbl = 0;		/* avoid GC crashing  */
    hash->tbl = st_init_table(&objhash);

    return (VALUE)hash;
d206 5
a210 2
VALUE
rb_hash_new()
d212 7
a218 1
    return rb_hash_new2(rb_cHash);
d1389 1
@


1.16
log
@2000-02-23
@
text
@d6 1
a6 1
  $Date: 2000/02/17 07:11:11 $
a91 1
#if 0
a92 15
#else
	{
	    register const char *p = RSTRING(a)->ptr;
	    register int len = RSTRING(a)->len;
	    register unsigned int h = 0, g;

	    while (len--) {
		h = ( h << 4 ) + *p++;
		if ( g = h & 0xF0000000 )
		    h ^= g >> 24;
		h &= ~g;
	    }
	    hval = h;
	}
#endif
@


1.15
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:52:55 $
d92 1
d94 15
d667 1
d671 1
d685 2
a686 1

@


1.14
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:48:49 $
d35 7
@


1.13
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:12:05 $
a1220 6
env_reject()
{
    return rb_hash_delete_if(env_to_hash());
}

static VALUE
d1356 6
@


1.12
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:37:04 $
d479 7
d1221 6
d1347 1
a1347 2
env_to_hash(obj)
    VALUE obj;
d1412 1
d1439 1
@


1.11
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:49:45 $
d26 1
a26 2
#define HASH_FREEZE   FL_USER1
#define HASH_DELETED  FL_USER2
d32 1
a32 2
    if (FL_TEST(hash, HASH_FREEZE))
	rb_raise(rb_eTypeError, "can't modify frozen hash");
a36 20
VALUE
rb_hash_freeze(hash)
    VALUE hash;
{
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(hash))
	rb_raise(rb_eSecurityError, "Insecure: can't freeze hash");
	
    FL_SET(hash, HASH_FREEZE);
    return hash;
}

static VALUE
rb_hash_frozen_p(hash)
    VALUE hash;
{
    if (FL_TEST(hash, HASH_FREEZE))
	return Qtrue;
    return Qfalse;
}

a1366 3

    rb_define_method(rb_cHash,"freeze", rb_hash_freeze, 0);
    rb_define_method(rb_cHash,"frozen?",rb_hash_frozen_p, 0);
@


1.10
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/12/07 09:23:26 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
a17 3
#include <sys/types.h>
#include <sys/stat.h>

d142 1
a142 1
    if (key == Qnil) return ST_CONTINUE;
d166 1
a166 1
	    st_cleanup_safe(RHASH(hash)->tbl, Qnil);
d275 2
a276 2
    NEWOBJ(hash2, struct RHash);
    CLONESETUP(hash2, hash);
d278 4
a281 4
    hash2->iter_lev = 0;
    hash2->ifnone = RHASH(hash)->ifnone;
    hash2->tbl = 0;		/* avoid GC crashing  */
    hash2->tbl = (st_table*)st_copy(RHASH(hash)->tbl);
d283 1
a283 1
    return (VALUE)hash2;
d290 2
a291 2
    NEWOBJ(hash2, struct RHash);
    OBJSETUP(hash2, CLASS_OF(hash), T_HASH);
d293 4
a296 4
    hash2->iter_lev = 0;
    hash2->ifnone = RHASH(hash)->ifnone;
    hash2->tbl = 0;		/* avoid GC crashing  */
    hash2->tbl = (st_table*)st_copy(RHASH(hash)->tbl);
d298 2
a299 1
    return (VALUE)hash2;
d314 1
a314 3
    if (key != Qnil) {
	st_insert(tbl, key, value);
    }
d404 1
a404 1
    args[1] = Qnil;
d436 1
a436 1
	st_delete_safe(RHASH(hash)->tbl, &key, &val, Qnil)) {
d445 1
a445 1
    return Qnil;
d459 1
a459 1
    if (key == Qnil) return ST_CONTINUE;
d477 1
a477 1
    if (var.stop == 0) return Qnil;
d485 1
a485 1
    if (key == Qnil) return ST_CONTINUE;
d571 1
a571 1
    if (key == Qnil) return ST_CONTINUE;
d588 1
a588 1
    if (key == Qnil) return ST_CONTINUE;
d605 1
a605 1
    if (key == Qnil) return ST_CONTINUE;
d622 1
a622 1
    if (key == Qnil) return ST_CONTINUE;
d635 1
d653 1
a653 1
    if (key == Qnil) return ST_CONTINUE;
d689 1
a689 1
hash_to_s(hash)
d692 1
a692 6
    VALUE str;

    if (rb_inspecting_p(hash)) return rb_str_new2("{...}");
    str = rb_ary_to_s(rb_hash_to_a(hash));
    if (OBJ_TAINTED(hash)) OBJ_TAINT(str);
    return hash;
d699 2
d702 1
a702 1
    return rb_protect_inspect(hash_to_s, hash, 0);
d716 1
a716 1
    if (key == Qnil) return ST_CONTINUE;
d737 1
a737 1
    if (key == Qnil) return ST_CONTINUE;
d769 1
a769 1
    if (key == Qnil) return ST_CONTINUE;
d802 1
a802 1
    if (key == Qnil) return ST_CONTINUE;
d836 1
a836 1
    if (key == Qnil) return ST_CONTINUE;
d856 1
a856 1
    if (key == Qnil) return ST_CONTINUE;
d885 1
a885 1
    nam = str2cstr(name, &len);
d891 2
d897 1
a897 1
	return rb_tainted_str_new2(val);
d903 1
a903 1
env_delete_method(obj, name)
d918 1
a918 1
    nam = str2cstr(name, &len);
a930 48
static int
path_check_1(path)
    char *path;
{
    struct stat st;
    char *p = 0;
    char *s;

    for (;;) {
	if (stat(path, &st) == 0 && (st.st_mode & 002)) {
	    return 0;
	}
	s = strrchr(path, '/');
	if (p) *p = '/';
	if (!s || s == path) return 1;
	p = s;
	*p = '\0';
    }
}

int
rb_path_check(path)
    char *path;
{
    char *p, *pend;
    const char sep = PATH_SEP_CHAR;

    if (!path) return 1;

    p = path;
    pend = strchr(path, sep);
    
    for (;;) {
	int safe;

	if (pend) *pend = '\0';
	safe = path_check_1(p);
	if (!pend) break;
	*pend = sep;
	if (!safe) {
	    return 0;
	}
	p = pend + 1;
	pend = strchr(p, sep);
    }
    return 1;
}

d1104 2
a1105 2
    name = str2cstr(nm, &nlen);
    value = str2cstr(val, &vlen);
d1322 1
a1322 1
		return rb_tainted_str_new(*env, s-*env);
d1448 1
a1448 1
    rb_define_singleton_method(envtbl,"delete", env_delete_method, 1);
@


1.9
log
@991207
@
text
@d6 1
a6 1
  $Date: 1999/12/06 09:03:54 $
d38 1
a38 1
    if (!FL_TEST(hash, FL_TAINT) && rb_safe_level() >= 4)
d46 3
@


1.8
log
@19991206
@
text
@d6 1
a6 1
  $Date: 1999/12/01 09:24:12 $
d553 1
a553 1
rb_hash_length(hash)
d1457 2
a1458 2
    rb_define_method(rb_cHash,"length", rb_hash_length, 0);
    rb_define_alias(rb_cHash, "size", "length");
d1506 1
@


1.7
log
@19991201
@
text
@d6 1
a6 1
  $Date: 1999/11/25 09:03:05 $
d898 1
a898 1
	return rb_str_new2(val);
@


1.6
log
@19991125
@
text
@d6 1
a6 1
  $Date: 1999/11/11 04:08:26 $
d692 2
d695 3
a697 1
    return rb_ary_to_s(rb_hash_to_a(hash));
d805 1
a805 1
    if (val1 == Qnil) return ST_CONTINUE;
@


1.5
log
@19991111
@
text
@d6 1
a6 1
  $Date: 1999/10/13 06:44:41 $
d142 1
a142 1
    if (value == Qnil) return ST_CONTINUE;
d460 1
a460 1
    if (value == Qnil) return ST_CONTINUE;
d486 1
a486 1
    if (value == Qnil) return ST_CONTINUE;
d572 1
a572 1
    if (value == Qnil) return ST_CONTINUE;
d589 1
a589 1
    if (value == Qnil) return ST_CONTINUE;
d606 1
a606 1
    if (value == Qnil) return ST_CONTINUE;
d623 1
a623 1
    if (value == Qnil) return ST_CONTINUE;
d653 1
a653 1
    if (value == Qnil) return ST_CONTINUE;
d715 1
a715 1
    if (value == Qnil) return ST_CONTINUE;
d736 1
a736 1
    if (value == Qnil) return ST_CONTINUE;
d768 1
a768 1
    if (value == Qnil) return ST_CONTINUE;
d835 1
a835 1
    if (value == Qnil) return ST_CONTINUE;
d855 1
a855 1
    if (value == Qnil) return ST_CONTINUE;
@


1.4
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:33 $
d82 1
a88 2
    else {
	VALUE args[2];
d90 3
a92 4
	args[0] = a;
	args[1] = b;
	return !rb_with_disable_interrupt(eql, (VALUE)args);
    }
@


1.3
log
@19991012
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:05 $
a266 1
	if (NIL_P(argv[i+1])) continue;
d365 3
a525 4
    if (NIL_P(val)) {
	rb_hash_delete(hash, key);
	return Qnil;
    }
@


1.3.2.1
log
@19991111
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:33 $
a81 1
    VALUE args[2];
d88 2
d91 4
a94 3
    args[0] = a;
    args[1] = b;
    return !rb_with_disable_interrupt(eql, (VALUE)args);
@


1.3.2.2
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/11/11 04:07:29 $
d691 1
a691 1
to_s_hash(hash)
d694 1
a701 2
    VALUE str;

d703 1
a703 1
    return rb_protect_inspect(to_s_hash, hash, 0);
d1369 1
a1369 1
		return rb_tainted_str_new(*env, s-*env-1);
@


1.3.2.3
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:41:07 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.3.2.4
log
@2000-03-23
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:24:02 $
d241 4
a244 3
    if (argc == 1 && TYPE(argv[0]) == T_HASH) {
	NEWOBJ(hash, struct RHash);
	OBJSETUP(hash, klass, T_HASH);
d246 4
a249 4
	hash->iter_lev = 0;
	hash->ifnone = Qnil;
	hash->tbl = 0;	/* avoid GC crashing  */
	hash->tbl = st_copy(RHASH(argv[0])->tbl);
d251 6
a256 1
	return (VALUE)hash;
d434 4
a437 5
    if (RHASH(hash)->iter_lev > 0) {
	if (st_delete_safe(RHASH(hash)->tbl, &key, &val, Qnil)) {
	    FL_SET(hash, HASH_DELETED);
	    return val;
	}
@


1.3.2.5
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/03/23 04:14:16 $
d25 2
a26 2
#ifndef strdup
char *strdup();
@


1.3.2.6
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/24 07:16:07 $
d1094 1
a1094 2
	if (environ[i] != origenviron[i])
	    free(environ[i]);
d1106 1
a1106 2
	if (environ[i] != origenviron[i])
	    free(environ[i]);
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/06 06:48:18 $
d267 1
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1996/12/25 10:42:26 $
d9 1
a9 1
  Copyright (C) 1993-1997 Yukihiro Matsumoto
d15 2
a16 1
#include "sig.h"
d18 9
a26 4
#ifdef HAVE_STRING_H
# include <string.h>
#else
char *strchr();
d29 2
a30 2
#define HASH_DELETED  0x1
#define HASH_REHASHED 0x2
d32 26
a57 3
#ifndef NT
char *getenv();
#endif
d59 1
a59 1
VALUE cHash;
d71 7
d79 1
a79 1
any_cmp(a, b)
d86 1
a86 1
	if (TYPE(b) == T_STRING) return str_cmp(a, b);
d88 2
d91 4
a94 4
    DEFER_INTS;
    a = !rb_eql(a, b);
    ENABLE_INTS;
    return a;
d98 1
a98 1
any_hash(a, mod)
a99 1
    int mod;
d109 1
a109 1
	hval = str_hash(a);
d119 1
a119 1
	hval = FIX2INT(hval);
d121 1
a121 1
    return  hval % mod;
d125 2
a126 2
    any_cmp,
    any_hash,
d129 2
a130 2
struct hash_foreach_arg {
    struct RHash *hash;
d136 1
a136 1
hash_foreach_iter(key, value, arg)
d138 1
a138 1
    struct hash_foreach_arg *arg;
d141 2
d144 1
a144 1
    if (key == Qnil) return ST_CONTINUE;
d146 3
a148 1
    if (arg->hash->status & HASH_REHASHED) return ST_STOP;
d153 2
a154 2
hash_foreach_call(arg)
    struct hash_foreach_arg *arg;
d156 1
a156 1
    st_foreach(arg->hash->tbl, hash_foreach_iter, arg);
d160 3
a162 11
static int
hash_delete_nil(key, value)
    VALUE key, value;
{
    if (key == Qnil) return ST_DELETE;
    return ST_CONTINUE;
}

static void
hash_foreach_ensure(hash)
    struct RHash *hash;
d164 1
a164 1
    hash->iter_lev--;
d166 4
a169 3
    if (hash->iter_lev == 0) {
	if (hash->status & HASH_DELETED) {
	    st_foreach(hash->tbl, hash_delete_nil, 0);
a170 1
	hash->status = 0;
d172 1
d176 2
a177 2
hash_foreach(hash, func, farg)
    struct RHash *hash;
d181 1
a181 1
    struct hash_foreach_arg arg;
d183 1
a183 1
    hash->iter_lev++;
d187 1
a187 1
    return rb_ensure(hash_foreach_call, &arg, hash_foreach_ensure, hash);
d191 1
a191 1
hash_s_new(argc, argv, class)
d194 1
a194 1
    VALUE class;
d196 1
a196 2
    VALUE sz;
    int size;
d199 1
a199 5
    OBJSETUP(hash, class, T_HASH);

    rb_scan_args(argc, argv, "01", &sz);
    if (NIL_P(sz)) size = 0;
    else size = NUM2INT(sz);
d202 1
a202 1
    hash->status = 0;
d204 5
a208 1
    hash->tbl = st_init_table_with_size(&objhash, size);
d213 3
a215 3
VALUE
hash_new2(class)
    VALUE class;
d217 9
a225 1
    return hash_s_new(0, 0, class);
d229 1
a229 1
hash_new()
d231 1
a231 1
    return hash_new2(cHash);
d235 1
a235 1
hash_s_create(argc, argv, class)
d238 1
a238 1
    VALUE class;
d240 1
a240 1
    struct RHash *hash;
d243 2
a244 3
    if (argc == 1 && TYPE(argv[0]) == T_HASH) {
	if (class == CLASS_OF(argv[0])) return argv[0];
	else {
d246 1
a246 1
	    OBJSETUP(hash, class, T_HASH);
d249 1
a249 1
	    hash->status = 0;
d251 2
a252 1
	    hash->tbl = (st_table*)st_copy(RHASH(argv[0])->tbl);
d255 4
d262 1
a262 1
	ArgError("odd number args for Hash");
d264 1
a264 1
    hash = (struct RHash*)hash_new2(class);
d267 1
a267 1
	st_insert(hash->tbl, argv[i], argv[i+1]);
d270 1
a270 1
    return (VALUE)hash;
d274 2
a275 2
hash_clone(hash)
    struct RHash *hash;
d281 16
a296 1
    hash2->status = 0;
d298 1
a298 1
    hash2->tbl = (st_table*)st_copy(hash->tbl);
d303 7
d311 1
a311 1
hash_rehash_i(key, value, tbl)
d322 2
a323 2
hash_rehash(hash)
    struct RHash *hash;
d325 1
a325 1
    st_table *tbl = st_init_table_with_size(&objhash, hash->tbl->num_entries);
d327 4
a330 4
    st_foreach(hash->tbl, hash_rehash_i, tbl);
    st_free_table(hash->tbl);
    hash->tbl = tbl;
    if (hash->iter_lev > 0) hash->status |= HASH_REHASHED;
d332 1
a332 1
    return (VALUE)hash;
d336 16
a351 3
hash_aref(hash, key)
    struct RHash *hash;
    VALUE key;
d353 1
d356 10
a365 2
    if (!st_lookup(hash->tbl, key, &val)) {
	return Qnil;
d371 42
a412 1
hash_indexes(argc, argv, hash)
d415 1
a415 1
    struct RHash *hash;
d417 1
a417 1
    struct RArray *indexes;
d420 1
a420 1
    indexes = (struct RArray*)ary_new2(argc);
d422 1
a422 1
	indexes->ptr[i] = hash_aref(hash, argv[i]);
d424 2
a425 2
    indexes->len = i;
    return (VALUE)indexes;
d429 2
a430 3
hash_delete(hash, key)
    struct RHash *hash;
    VALUE key;
d434 4
a437 2
    rb_secure(5);
    if (hash->iter_lev > 0 && st_delete_safe(hash->tbl, &key, &val, Qnil))
d439 2
a440 1
    else if (st_delete(hash->tbl, &key, &val))
d442 3
a444 1
    if (iterator_p()) rb_yield(key);
d459 1
a459 1
    if (key == Qnil) return ST_CONTINUE;
d468 2
a469 2
hash_shift(hash)
    struct RHash *hash;
d473 1
a473 1
    rb_secure(5);
d475 1
a475 1
    st_foreach(hash->tbl, shift_i, &var);
d478 1
a478 1
    return assoc_new(var.key, var.val);
d485 2
a486 2
    if (key == Qnil) return ST_CONTINUE;
    if (rb_yield(assoc_new(key, value)))
d492 2
a493 2
hash_delete_if(hash)
    struct RHash *hash;
d495 2
a496 2
    rb_secure(5);
    hash_foreach(hash, delete_if_i, 0);
d498 1
a498 1
    return (VALUE)hash;
d502 2
a503 2
clear_i(key, value)
    VALUE key, value;
d509 2
a510 2
hash_clear(hash)
    struct RHash *hash;
d512 2
a513 2
    rb_secure(5);
    st_foreach(hash->tbl, clear_i);
d515 1
a515 1
    return (VALUE)hash;
d519 2
a520 3
hash_aset(hash, key, val)
    struct RHash *hash;
    VALUE key, val;
d522 1
a522 1
    rb_secure(5);
d524 1
a524 1
	hash_delete(hash, key);
d527 5
a531 2
    if (TYPE(key) == T_STRING) {
	key = str_dup_freezed(key);
a532 1
    st_insert(hash->tbl, key, val);
d536 19
d556 2
a557 2
hash_length(hash)
    struct RHash *hash;
d559 1
a559 1
    return INT2FIX(hash->tbl->num_entries);
d562 3
a564 3
VALUE
hash_empty_p(hash)
    struct RHash *hash;
d566 3
a568 3
    if (hash->tbl->num_entries == 0)
	return TRUE;
    return FALSE;
d575 1
a575 1
    if (key == Qnil) return ST_CONTINUE;
d581 2
a582 2
hash_each_value(hash)
    struct RHash *hash;
d584 2
a585 2
    hash_foreach(hash, each_value_i);
    return (VALUE)hash;
d592 1
a592 1
    if (key == Qnil) return ST_CONTINUE;
d598 2
a599 2
hash_each_key(hash)
    struct RHash *hash;
d601 2
a602 2
    hash_foreach(hash, each_key_i);
    return (VALUE)hash;
d609 2
a610 2
    if (key == Qnil) return ST_CONTINUE;
    rb_yield(assoc_new(key, value));
d615 2
a616 2
hash_each_pair(hash)
    struct RHash *hash;
d618 2
a619 2
    hash_foreach(hash, each_pair_i);
    return (VALUE)hash;
d626 2
a627 2
    if (key == Qnil) return ST_CONTINUE;
    ary_push(ary, assoc_new(key, value));
d632 2
a633 2
hash_to_a(hash)
    struct RHash *hash;
d637 2
a638 2
    ary = ary_new();
    st_foreach(hash->tbl, to_a_i, ary);
d643 7
d652 1
a652 2
    VALUE key, value;
    struct RString *str;
d656 3
a658 3
    if (key == Qnil) return ST_CONTINUE;
    if (str->len > 1) {
	str_cat(str, ", ", 2);
d661 2
a662 2
    str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
    str_cat(str, "=>", 2);
d664 1
a664 1
    str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d670 2
a671 2
hash_inspect(hash)
    struct RHash *hash;
d675 3
a677 3
    str = str_new2("{");
    st_foreach(hash->tbl, inspect_i, str);
    str_cat(str, "}", 1);
d683 9
d695 17
a711 1
    return ary_to_s(hash_to_a(hash));
d718 2
a719 2
    if (key == Qnil) return ST_CONTINUE;
    ary_push(ary, key);
d724 2
a725 2
hash_keys(hash)
    struct RHash *hash;
d729 2
a730 2
    ary = ary_new();
    st_foreach(hash->tbl, keys_i, ary);
d739 2
a740 2
    if (key == Qnil) return ST_CONTINUE;
    ary_push(ary, value);
d745 2
a746 2
hash_values(hash)
    struct RHash *hash;
d750 2
a751 2
    ary = ary_new();
    st_foreach(hash->tbl, values_i, ary);
d757 2
a758 2
hash_has_key(hash, key)
    struct RHash *hash;
d761 2
a762 2
    if (st_lookup(hash->tbl, key, 0)) {
	return TRUE;
d764 1
a764 1
    return FALSE;
d768 1
a768 1
hash_search_value(key, value, data)
d771 1
a771 1
    if (key == Qnil) return ST_CONTINUE;
d773 1
a773 1
	data[0] = TRUE;
d780 2
a781 2
hash_has_value(hash, val)
    struct RHash *hash;
d786 1
a786 1
    data[0] = FALSE;
d788 1
a788 1
    st_foreach(hash->tbl, hash_search_value, data);
d804 1
a804 1
    if (key == Qnil) return ST_CONTINUE;
d806 1
a806 1
	data->result = FALSE;
d810 1
a810 1
	data->result = FALSE;
d817 2
a818 2
hash_equal(hash1, hash2)
    struct RHash *hash1, *hash2;
d822 7
a828 7
    if (TYPE(hash2) != T_HASH) return FALSE;
    if (hash1->tbl->num_entries != hash2->tbl->num_entries)
	return FALSE;

    data.tbl = hash2->tbl;
    data.result = TRUE;
    st_foreach(hash1->tbl, equal_i, &data);
d834 1
a834 1
hash_invert_i(key, value, hash)
d836 1
a836 1
    struct RHash *hash;
d838 2
a839 2
    if (key == Qnil) return ST_CONTINUE;
    hash_aset(hash, value, key);
d844 2
a845 2
hash_invert(hash)
    struct RHash *hash;
d847 1
a847 1
    VALUE h = hash_new();
d849 1
a849 1
    st_foreach(hash->tbl, hash_invert_i, h);
d853 20
a872 1
int env_path_tainted = 0;
d877 1
d881 1
a881 2
    VALUE obj;
    struct RString *name;
d883 2
a884 2
    int i, len;
    char *nam, *val = 0;
d887 3
a889 13
    Check_Type(name, T_STRING);
    nam = name->ptr;
    len = strlen(nam);
    if (strcmp(nam, "PATH") == 0) env_path_tainted = 0;
    for(i=0; environ[i]; i++) {
	if (strncmp(environ[i], nam, len) == 0 && environ[i][len] == '=') {
	    val = environ[i]+len+1;
	    break;
	}
    }
    while (environ[i]) {
	environ[i] = environ[i+1];
	i++;
d891 1
d893 5
a897 1
	return str_new2(val);
d903 2
a904 3
f_getenv(obj, name)
    VALUE obj;
    struct RString *name;
d906 4
a909 1
    char *env;
d911 6
a916 1
    Check_Type(name, T_STRING);
d918 5
a922 4
    if (strlen(name->ptr) != name->len)
	ArgError("Bad environment name");

    env = getenv(name->ptr);
d924 3
a926 3
	if (strcmp(name->ptr, "PATH") == 0 && !env_path_tainted)
	    return str_new2(env);
	return str_taint(str_new2(env));
d931 205
d1137 2
a1138 3
f_setenv(obj, name, value)
    VALUE obj;
    struct RString *name, *value;
d1140 3
d1144 1
a1144 2
	extern VALUE eSecurityError;
	Raise(eSecurityError, "cannot change environment variable");
d1147 2
a1148 3
    Check_SafeStr(name);
    if (NIL_P(value)) {
	env_delete(obj, name);
d1152 19
a1170 9
    Check_SafeStr(value);
    if (strlen(name->ptr) != name->len)
	ArgError("Bad environment name");
    if (strlen(value->ptr) != value->len)
	ArgError("Bad environment value");

    setenv(name->ptr, value->ptr, 1);
    if (strcmp(name->ptr, "PATH") == 0) env_path_tainted = 0;
    return TRUE;
d1177 1
a1177 1
    VALUE ary = ary_new();
d1182 3
a1184 1
	ary_push(ary, str_taint(str_new(*env, s-*env)));
d1194 11
a1204 1
    return ary_each(env_keys());
d1211 1
a1211 1
    VALUE ary = ary_new();
d1216 3
a1218 1
	ary_push(ary, str_taint(str_new2(s+1)));
d1228 11
a1238 1
    return ary_each(env_values());
d1245 1
a1245 3
    VALUE ary = env_keys();
    VALUE *ptr = RARRAY(ary)->ptr;
    int len = RARRAY(ary)->len; 
d1247 6
a1252 4
    while (len--) {
	VALUE val = f_getenv(Qnil, *ptr);
	if (!NIL_P(val)) {
	    rb_yield(assoc_new(*ptr, val));
d1254 1
a1254 1
	ptr++;
d1256 1
a1256 1
    return hash;
d1262 8
a1269 3
    VALUE ary = env_keys();
    VALUE *ptr = RARRAY(ary)->ptr;
    int len = RARRAY(ary)->len; 
d1272 1
a1272 1
	VALUE val = f_getenv(Qnil, *ptr);
d1274 1
a1274 1
	    if (RTEST(rb_yield(assoc_new(*ptr, val)))) {
d1286 1
a1286 1
    return str_new2("ENV");
d1293 1
a1293 1
    VALUE ary = ary_new();
d1298 4
a1301 2
	ary_push(ary, assoc_new(str_taint(str_new(*env, s-*env)),
				str_taint(str_new2(s+1))));
d1326 2
a1327 2
    if (environ[0] == 0) return TRUE;
    return FALSE;
d1334 3
a1336 3
    if (TYPE(key) != T_STRING) return FALSE;
    if (getenv(RSTRING(key)->ptr)) return TRUE;
    return FALSE;
a1343 1
    VALUE ary;
d1345 20
a1364 2
    if (TYPE(value) != T_STRING) return FALSE;
    ary = ary_new();
d1368 5
a1372 2
	int len = strlen(s);
	if (strncmp(s, RSTRING(value)->ptr, len) == 0) return TRUE;
d1375 1
a1375 1
    return FALSE;
d1384 1
a1384 1
    VALUE indexes = ary_new2(argc);
d1392 1
a1392 1
	    RARRAY(indexes)->ptr[i] = str_new2(v);
d1403 19
a1424 2
    extern VALUE mEnumerable;

d1427 1
a1427 1
    cHash = rb_define_class("Hash", cObject);
d1429 1
a1429 1
    rb_include_module(cHash, mEnumerable);
d1431 2
a1432 2
    rb_define_singleton_method(cHash, "new", hash_s_new, -1);
    rb_define_singleton_method(cHash, "[]", hash_s_create, -1);
d1434 55
a1488 34
    rb_define_method(cHash,"clone",  hash_clone, 0);
    rb_define_method(cHash,"rehash",  hash_rehash, 0);

    rb_define_method(cHash,"to_a",  hash_to_a, 0);
    rb_define_method(cHash,"to_s",  hash_to_s, 0);
    rb_define_method(cHash,"inspect",  hash_inspect, 0);

    rb_define_method(cHash,"==",  hash_equal, 1);
    rb_define_method(cHash,"[]",  hash_aref, 1);
    rb_define_method(cHash,"[]=", hash_aset, 2);
    rb_define_method(cHash,"indexes", hash_indexes, -1);
    rb_define_method(cHash,"length", hash_length, 0);
    rb_define_alias(cHash, "size", "length");
    rb_define_method(cHash,"empty?", hash_empty_p, 0);

    rb_define_method(cHash,"each", hash_each_pair, 0);
    rb_define_method(cHash,"each_value", hash_each_value, 0);
    rb_define_method(cHash,"each_key", hash_each_key, 0);
    rb_define_method(cHash,"each_pair", hash_each_pair, 0);

    rb_define_method(cHash,"keys", hash_keys, 0);
    rb_define_method(cHash,"values", hash_values, 0);

    rb_define_method(cHash,"shift", hash_shift, 0);
    rb_define_method(cHash,"delete", hash_delete, 1);
    rb_define_method(cHash,"delete_if", hash_delete_if, 0);
    rb_define_method(cHash,"clear", hash_clear, 0);
    rb_define_method(cHash,"invert", hash_invert, 0);

    rb_define_method(cHash,"include?", hash_has_key, 1);
    rb_define_method(cHash,"has_key?", hash_has_key, 1);
    rb_define_method(cHash,"has_value?", hash_has_value, 1);
    rb_define_method(cHash,"key?", hash_has_key, 1);
    rb_define_method(cHash,"value?", hash_has_value, 1);
d1490 2
a1491 5
    envtbl = obj_alloc(cObject);
    rb_extend_object(envtbl, mEnumerable);

    rb_define_singleton_method(envtbl,"[]", f_getenv, 1);
    rb_define_singleton_method(envtbl,"[]=", f_setenv, 2);
d1496 1
a1496 1
    rb_define_singleton_method(envtbl,"delete", env_delete, 1);
d1498 1
d1502 1
d1504 1
d1510 1
d1515 1
d1518 4
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d17 3
a19 3
#include <sys/stat.h>

#ifndef HAVE_STRING_H
a25 29
#define HASH_FREEZE   FL_USER1

static void
hash_modify(hash)
    VALUE hash;
{
    rb_secure(5);
    if (FL_TEST(hash, HASH_FREEZE)) {
	TypeError("can't modify frozen hash");
    }
}

VALUE
hash_freeze(hash)
    VALUE hash;
{
    FL_SET(hash, HASH_FREEZE);
    return hash;
}

static VALUE
hash_frozen_p(hash)
    VALUE hash;
{
    if (FL_TEST(hash, HASH_FREEZE))
	return TRUE;
    return FALSE;
}

d93 1
a93 1
    VALUE hash;
d107 1
a107 1
    if (RHASH(arg->hash)->status & HASH_REHASHED) return ST_STOP;
d115 1
a115 1
    st_foreach(RHASH(arg->hash)->tbl, hash_foreach_iter, arg);
d129 1
a129 1
    VALUE hash;
d131 1
a131 1
    RHASH(hash)->iter_lev--;
d133 3
a135 3
    if (RHASH(hash)->iter_lev == 0) {
	if (RHASH(hash)->status & HASH_DELETED) {
	    st_foreach(RHASH(hash)->tbl, hash_delete_nil, 0);
d137 1
a137 1
	RHASH(hash)->status = 0;
d143 1
a143 1
    VALUE hash;
d149 1
a149 1
    RHASH(hash)->iter_lev++;
d153 1
a153 1
    return rb_ensure(hash_foreach_call, (VALUE)&arg, hash_foreach_ensure, (VALUE)hash);
d180 1
a180 1
static VALUE
d199 1
a199 1
    VALUE hash;
d219 1
a219 1
    hash = hash_new2(class);
d222 1
a222 1
	st_insert(RHASH(hash)->tbl, argv[i], argv[i+1]);
d225 1
a225 1
    return hash;
d230 1
a230 1
    VALUE hash;
d238 1
a238 16
    hash2->tbl = (st_table*)st_copy(RHASH(hash)->tbl);

    return (VALUE)hash2;
}

static VALUE
hash_dup(hash)
    VALUE hash;
{
    NEWOBJ(hash2, struct RHash);
    OBJSETUP(hash2, CLASS_OF(hash), T_HASH);

    hash2->iter_lev = 0;
    hash2->status = 0;
    hash2->tbl = 0;		/* avoid GC crashing  */
    hash2->tbl = (st_table*)st_copy(RHASH(hash)->tbl);
d256 1
a256 1
    VALUE hash;
d258 1
a258 1
    st_table *tbl;
d260 4
a263 5
    tbl = st_init_table_with_size(&objhash, RHASH(hash)->tbl->num_entries);
    st_foreach(RHASH(hash)->tbl, hash_rehash_i, tbl);
    st_free_table(RHASH(hash)->tbl);
    RHASH(hash)->tbl = tbl;
    if (RHASH(hash)->iter_lev > 0) RHASH(hash)->status |= HASH_REHASHED;
d270 2
a271 1
    VALUE hash, key;
d275 1
a275 1
    if (!st_lookup(RHASH(hash)->tbl, key, &val)) {
d285 1
a285 1
    VALUE hash;
d287 1
a287 1
    VALUE indexes;
d290 1
a290 1
    indexes = ary_new2(argc);
d292 1
a292 1
	RARRAY(indexes)->ptr[i] = hash_aref(hash, argv[i]);
d294 2
a295 2
    RARRAY(indexes)->len = i;
    return indexes;
d300 2
a301 1
    VALUE hash, key;
d305 2
a306 3
    hash_modify(hash);
    if (RHASH(hash)->iter_lev > 0
	&& st_delete_safe(RHASH(hash)->tbl, &key, &val, Qnil))
d308 1
a308 1
    else if (st_delete(RHASH(hash)->tbl, &key, &val))
d335 1
a335 1
    VALUE hash;
d339 1
a339 1
    hash_modify(hash);
d341 1
a341 1
    st_foreach(RHASH(hash)->tbl, shift_i, &var);
d359 1
a359 1
    VALUE hash;
d361 1
a361 1
    hash_modify(hash);
d376 1
a376 1
    VALUE hash;
d378 2
a379 2
    hash_modify(hash);
    st_foreach(RHASH(hash)->tbl, clear_i);
d386 2
a387 1
    VALUE hash, key, val;
d389 1
a389 1
    hash_modify(hash);
d397 1
a397 1
    st_insert(RHASH(hash)->tbl, key, val);
d403 1
a403 1
    VALUE hash;
d405 1
a405 1
    return INT2FIX(RHASH(hash)->tbl->num_entries);
d408 1
a408 1
static VALUE
d410 1
a410 1
    VALUE hash;
d412 1
a412 1
    if (RHASH(hash)->tbl->num_entries == 0)
d428 1
a428 1
    VALUE hash;
d445 1
a445 1
    VALUE hash;
d462 1
a462 1
    VALUE hash;
d479 1
a479 1
    VALUE hash;
d484 1
a484 1
    st_foreach(RHASH(hash)->tbl, to_a_i, ary);
d491 2
a492 1
    VALUE key, value, str;
d497 1
a497 1
    if (RSTRING(str)->len > 1) {
d511 1
a511 1
    VALUE hash;
d516 1
a516 1
    st_foreach(RHASH(hash)->tbl, inspect_i, str);
d540 1
a540 1
    VALUE hash;
d545 1
a545 1
    st_foreach(RHASH(hash)->tbl, keys_i, ary);
d561 1
a561 1
    VALUE hash;
d566 1
a566 1
    st_foreach(RHASH(hash)->tbl, values_i, ary);
d573 1
a573 1
    VALUE hash;
d576 1
a576 1
    if (st_lookup(RHASH(hash)->tbl, key, 0)) {
d596 1
a596 1
    VALUE hash;
d603 1
a603 1
    st_foreach(RHASH(hash)->tbl, hash_search_value, data);
d633 1
a633 1
    VALUE hash1, hash2;
d638 1
a638 1
    if (RHASH(hash1)->tbl->num_entries != RHASH(hash2)->tbl->num_entries)
d641 1
a641 1
    data.tbl = RHASH(hash2)->tbl;
d643 1
a643 1
    st_foreach(RHASH(hash1)->tbl, equal_i, &data);
d651 1
a651 1
    VALUE hash;
d660 1
a660 1
    VALUE hash;
d664 1
a664 1
    st_foreach(RHASH(hash)->tbl, hash_invert_i, h);
d668 1
a668 22
static int
hash_update_i(key, value, hash)
    VALUE key, value;
    VALUE hash;
{
    if (key == Qnil) return ST_CONTINUE;
    hash_aset(hash, key, value);
    return ST_CONTINUE;
}

static VALUE
hash_update(hash1, hash2)
    VALUE hash1, hash2;
{
    Check_Type(hash2, T_HASH);

    st_foreach(RHASH(hash2)->tbl, hash_update_i, hash1);
    return hash1;
}

int env_path_tainted();
static int path_tainted = -1;
d676 2
a677 1
    VALUE obj, name;
d684 1
a684 1
    nam = RSTRING(name)->ptr;
d686 1
a686 1
    if (strcmp(nam, "PATH") == 0) path_tainted = 0;
a703 9
env_delete_method(obj, name)
    VALUE obj, name;
{
    VALUE val = env_delete(obj, name);
    if (iterator_p()) rb_yield(name);
    return val;
}

static VALUE
d705 2
a706 1
    VALUE obj, name;
d712 1
a712 1
    if (strlen(RSTRING(name)->ptr) != RSTRING(name)->len)
d715 1
a715 1
    env = getenv(RSTRING(name)->ptr);
d717 1
a717 1
	if (strcmp(RSTRING(name)->ptr, "PATH") == 0 && !env_path_tainted())
a723 60
static int
path_check_1(path)
    char *path;
{
    struct stat st;
    char *p = 0;
    char *s;

    for (;;) {
	if (stat(path, &st) == 0 && (st.st_mode & 2)) {
	    return 0;
	}
	s = strrchr(path, '/');
	if (p) *p = '/';
	if (!s || s == path) return 1;
	p = s;
	*p = '\0';
    }
}

static void
path_check(path)
    char *path;
{
    char *p = path;
    char *pend = strchr(path, ':');

    if (!path) {
	path_tainted = 0;
    }

    p = path;
    pend = strchr(path, ':');
    
    for (;;) {
	int safe;

	if (pend) *pend = '\0';
	safe = path_check_1(p);
	if (!pend) break;
	*pend = ':';
	if (!safe) {
	    path_tainted = 1;
	    return;
	}
	p = pend + 1;
	pend = strchr(p, ':');
    }
    path_tainted = 0;
}

int
env_path_tainted()
{
    if (path_tainted < 0) {
	path_check(getenv("PATH"));
    }
    return path_tainted;
}

d726 2
a727 1
    VALUE obj, name, value;
d741 1
a741 1
    if (strlen(RSTRING(name)->ptr) != RSTRING(name)->len)
d743 1
a743 1
    if (strlen(RSTRING(value)->ptr) != RSTRING(value)->len)
d746 2
a747 12
    setenv(RSTRING(name)->ptr, RSTRING(value)->ptr, 1);
    if (strcmp(RSTRING(name)->ptr, "PATH") == 0) {
	char *p, pend;

	if (str_tainted(value)) {
	    /* already tainted, no check */
	    path_tainted = 1;
	    return TRUE;
	}

	path_check(RSTRING(name)->ptr);
    }
d944 6
a949 10
    rb_define_method(cHash,"clone", hash_clone, 0);
    rb_define_method(cHash,"dup", hash_dup, 0);
    rb_define_method(cHash,"rehash", hash_rehash, 0);

    rb_define_method(cHash,"freeze", hash_freeze, 0);
    rb_define_method(cHash,"frozen?",hash_frozen_p, 0);

    rb_define_method(cHash,"to_a", hash_to_a, 0);
    rb_define_method(cHash,"to_s", hash_to_s, 0);
    rb_define_method(cHash,"inspect", hash_inspect, 0);
d951 2
a952 2
    rb_define_method(cHash,"==", hash_equal, 1);
    rb_define_method(cHash,"[]", hash_aref, 1);
a971 1
    rb_define_method(cHash,"update", hash_update, 1);
d988 1
a988 1
    rb_define_singleton_method(envtbl,"delete", env_delete_method, 1);
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/12/22 09:01:51 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
d15 1
a15 1
#include "rubysig.h"
a16 1
#include <sys/types.h>
d20 1
a20 1
char *strchr _((char*,char));
d23 3
a26 1
#define HASH_DELETED  FL_USER2
d29 1
a29 1
rb_hash_modify(hash)
d32 4
a35 4
    if (FL_TEST(hash, HASH_FREEZE))
	rb_raise(rb_eTypeError, "can't modify frozen hash");
    if (rb_safe_level() >= 4 && !FL_TEST(hash, FL_TAINT))
	rb_raise(rb_eSecurityError, "Insecure: can't modify hash");
d39 1
a39 1
rb_hash_freeze(hash)
d47 1
a47 1
rb_hash_frozen_p(hash)
d51 2
a52 2
	return Qtrue;
    return Qfalse;
d55 5
a59 1
VALUE rb_cHash;
d72 1
a72 1
rb_any_cmp(a, b)
d79 1
a79 1
	if (TYPE(b) == T_STRING) return rb_str_cmp(a, b);
d89 1
a89 1
rb_any_hash(a)
d91 1
d101 1
a101 1
	hval = rb_str_hash(a);
d111 1
a111 1
	hval = FIX2LONG(hval);
d113 1
a113 1
    return  hval;
d117 2
a118 2
    rb_any_cmp,
    rb_any_hash,
d121 1
a121 1
struct rb_hash_foreach_arg {
d128 1
a128 1
rb_hash_foreach_iter(key, value, arg)
d130 1
a130 1
    struct rb_hash_foreach_arg *arg;
a132 2
    st_table *tbl = RHASH(arg->hash)->tbl;
    struct st_table_entry **bins = tbl->bins;
d136 1
a136 3
    if (RHASH(arg->hash)->tbl != tbl || RHASH(arg->hash)->tbl->bins != bins){
	rb_raise(rb_eIndexError, "rehash occurred during iteration");
    }
d141 2
a142 2
rb_hash_foreach_call(arg)
    struct rb_hash_foreach_arg *arg;
d144 1
a144 1
    st_foreach(RHASH(arg->hash)->tbl, rb_hash_foreach_iter, arg);
d149 1
a149 1
rb_hash_delete_nil(key, value)
d152 1
a152 1
    if (value == Qnil) return ST_DELETE;
d156 2
a157 2
static VALUE
rb_hash_foreach_ensure(hash)
d163 2
a164 3
	if (FL_TEST(hash, HASH_DELETED)) {
	    st_foreach(RHASH(hash)->tbl, rb_hash_delete_nil, 0);
	    FL_UNSET(hash, HASH_DELETED);
d166 1
a167 1
    return 0;
d171 1
a171 1
rb_hash_foreach(hash, func, farg)
d176 1
a176 1
    struct rb_hash_foreach_arg arg;
d182 1
a182 1
    return rb_ensure(rb_hash_foreach_call, (VALUE)&arg, rb_hash_foreach_ensure, hash);
d186 1
a186 1
rb_hash_s_new(argc, argv, klass)
d189 1
a189 1
    VALUE klass;
d191 1
a191 1
    VALUE sz, ifnone;
d195 5
a199 1
    OBJSETUP(hash, klass, T_HASH);
d202 1
a202 1
    hash->ifnone = Qnil;
a203 8

    rb_scan_args(argc, argv, "02", &ifnone, &sz);
    if (NIL_P(sz)) {
	size = 0;
    }
    else size = NUM2INT(sz);

    hash->ifnone = ifnone;
a204 1
    rb_obj_call_init((VALUE)hash);
d210 2
a211 2
rb_hash_new2(klass)
    VALUE klass;
d213 1
a213 9
    NEWOBJ(hash, struct RHash);
    OBJSETUP(hash, klass, T_HASH);

    hash->iter_lev = 0;
    hash->ifnone = Qnil;
    hash->tbl = 0;		/* avoid GC crashing  */
    hash->tbl = st_init_table(&objhash);

    return (VALUE)hash;
d217 1
a217 1
rb_hash_new()
d219 1
a219 1
    return rb_hash_new2(rb_cHash);
d223 1
a223 1
rb_hash_s_create(argc, argv, klass)
d226 1
a226 1
    VALUE klass;
d232 1
a232 1
	if (klass == CLASS_OF(argv[0])) return argv[0];
d235 1
a235 1
	    OBJSETUP(hash, klass, T_HASH);
d238 1
a238 1
	    hash->ifnone = Qnil;
a240 1
	    rb_obj_call_init((VALUE)hash);
d246 1
a246 1
	rb_raise(rb_eArgError, "odd number args for Hash");
d248 1
a248 1
    hash = rb_hash_new2(klass);
a252 1
    rb_obj_call_init(hash);
d258 1
a258 1
rb_hash_clone(hash)
d265 1
a265 1
    hash2->ifnone = RHASH(hash)->ifnone;
d273 1
a273 1
rb_hash_dup(hash)
d280 1
a280 1
    hash2->ifnone = RHASH(hash)->ifnone;
a286 7
static VALUE
to_hash(hash)
    VALUE hash;
{
    return rb_convert_type(hash, T_HASH, "Hash", "to_hash");
}

d288 1
a288 1
rb_hash_rehash_i(key, value, tbl)
d299 1
a299 1
rb_hash_rehash(hash)
d305 1
a305 1
    st_foreach(RHASH(hash)->tbl, rb_hash_rehash_i, tbl);
d308 1
d310 1
a310 1
    return hash;
d314 1
a314 1
rb_hash_aref(hash, key)
d320 1
a320 1
	return RHASH(hash)->ifnone;
d326 1
a326 39
rb_hash_fetch(argc, argv, hash)
    int argc;
    VALUE *argv;
    VALUE hash;
{
    VALUE key, if_none;
    VALUE val;

    rb_scan_args(argc, argv, "11", &key, &if_none);

    if (!st_lookup(RHASH(hash)->tbl, key, &val)) {
	if (rb_iterator_p()) {
	    if (argc > 1) {
		rb_raise(rb_eArgError, "wrong # of arguments", argc);
	    }
	    return rb_yield(argv[0]);
	}
	return if_none;
    }
    return val;
}

static VALUE
rb_hash_default(hash)
    VALUE hash;
{
    return RHASH(hash)->ifnone;
}

static VALUE
rb_hash_set_default(hash, ifnone)
    VALUE hash, ifnone;
{
    RHASH(hash)->ifnone = ifnone;
    return hash;
}

static VALUE
rb_hash_indexes(argc, argv, hash)
d334 1
a334 1
    indexes = rb_ary_new2(argc);
d336 1
a336 1
	RARRAY(indexes)->ptr[i] = rb_hash_aref(hash, argv[i]);
d343 1
a343 1
rb_hash_delete(hash, key)
d348 3
a350 4
    rb_hash_modify(hash);
    if (RHASH(hash)->iter_lev > 0 &&
	st_delete_safe(RHASH(hash)->tbl, &key, &val, Qnil)) {
	FL_SET(hash, HASH_DELETED);
a351 1
    }
d354 1
a354 3
    if (rb_iterator_p()) {
	return rb_yield(key);
    }
d378 1
a378 1
rb_hash_shift(hash)
d383 1
a383 1
    rb_hash_modify(hash);
d388 1
a388 1
    return rb_assoc_new(var.key, var.val);
d396 1
a396 1
    if (rb_yield(rb_assoc_new(key, value)))
d402 1
a402 1
rb_hash_delete_if(hash)
d405 2
a406 2
    rb_hash_modify(hash);
    rb_hash_foreach(hash, delete_if_i, 0);
d408 1
a408 1
    return hash;
d419 1
a419 1
rb_hash_clear(hash)
d422 1
a422 1
    rb_hash_modify(hash);
d425 1
a425 1
    return hash;
d429 1
a429 1
rb_hash_aset(hash, key, val)
d432 1
a432 1
    rb_hash_modify(hash);
d434 1
a434 1
	rb_hash_delete(hash, key);
d437 2
a438 5
    if (TYPE(key) != T_STRING || st_lookup(RHASH(hash)->tbl, key, 0)) {
	st_insert(RHASH(hash)->tbl, key, val);
    }
    else {
	st_add_direct(RHASH(hash)->tbl, rb_str_dup_frozen(key), val);
d440 1
a443 19
static int
replace_i(key, val, hash)
    VALUE key, val, hash;
{
    rb_hash_aset(hash, key, val);
    return ST_CONTINUE;
}

static VALUE
rb_hash_replace(hash, hash2)
    VALUE hash, hash2;
{
    hash2 = to_hash(hash2);
    rb_hash_clear(hash);
    st_foreach(RHASH(hash2)->tbl, replace_i, hash);

    return hash;
}

d445 1
a445 1
rb_hash_length(hash)
d452 1
a452 1
rb_hash_empty_p(hash)
d456 2
a457 2
	return Qtrue;
    return Qfalse;
d470 1
a470 1
rb_hash_each_value(hash)
d473 2
a474 2
    rb_hash_foreach(hash, each_value_i, 0);
    return hash;
d487 1
a487 1
rb_hash_each_key(hash)
d490 2
a491 2
    rb_hash_foreach(hash, each_key_i, 0);
    return hash;
d499 1
a499 1
    rb_yield(rb_assoc_new(key, value));
d504 1
a504 1
rb_hash_each_pair(hash)
d507 2
a508 2
    rb_hash_foreach(hash, each_pair_i, 0);
    return hash;
d516 1
a516 1
    rb_ary_push(ary, rb_assoc_new(key, value));
d521 1
a521 1
rb_hash_to_a(hash)
d526 1
a526 1
    ary = rb_ary_new();
a531 7
static VALUE
rb_hash_sort(hash)
    VALUE hash;
{
    return rb_ary_sort_bang(rb_hash_to_a(hash));
}

d540 1
a540 1
	rb_str_cat(str, ", ", 2);
d543 2
a544 2
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
    rb_str_cat(str, "=>", 2);
d546 1
a546 1
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d552 1
a552 1
inspect_hash(hash)
d557 1
a557 1
    str = rb_str_new2("{");
d559 1
a559 1
    rb_str_cat(str, "}", 1);
a564 9
rb_hash_inspect(hash)
    VALUE hash;
{
    if (RHASH(hash)->tbl->num_entries == 0) return rb_str_new2("{}");
    if (rb_inspecting_p(hash)) return rb_str_new2("{...}");
    return rb_protect_inspect(inspect_hash, hash, 0);
}

static VALUE
d568 1
a568 17
    if (rb_inspecting_p(hash)) return rb_str_new2("{...}");
    return rb_ary_to_s(rb_hash_to_a(hash));
}

static VALUE
rb_hash_to_s(hash)
    VALUE hash;
{
    if (rb_inspecting_p(hash)) return rb_str_new2("{...}");
    return rb_protect_inspect(hash_to_s, hash, 0);
}

static VALUE
rb_hash_to_hash(hash)
    VALUE hash;
{
    return hash;
d576 1
a576 1
    rb_ary_push(ary, key);
d581 1
a581 1
rb_hash_keys(hash)
d586 1
a586 1
    ary = rb_ary_new();
d597 1
a597 1
    rb_ary_push(ary, value);
d602 1
a602 1
rb_hash_values(hash)
d607 1
a607 1
    ary = rb_ary_new();
d614 1
a614 1
rb_hash_has_key(hash, key)
d619 1
a619 1
	return Qtrue;
d621 1
a621 1
    return Qfalse;
d625 1
a625 1
rb_hash_search_value(key, value, data)
d630 1
a630 1
	data[0] = Qtrue;
d637 1
a637 1
rb_hash_has_value(hash, val)
d643 1
a643 1
    data[0] = Qfalse;
d645 1
a645 1
    st_foreach(RHASH(hash)->tbl, rb_hash_search_value, data);
d663 1
a663 1
	data->result = Qfalse;
d667 1
a667 1
	data->result = Qfalse;
d674 1
a674 1
rb_hash_equal(hash1, hash2)
d679 1
a679 1
    if (TYPE(hash2) != T_HASH) return Qfalse;
d681 1
a681 1
	return Qfalse;
d684 1
a684 1
    data.result = Qtrue;
d691 1
a691 1
rb_hash_invert_i(key, value, hash)
d696 1
a696 1
    rb_hash_aset(hash, value, key);
d701 1
a701 1
rb_hash_invert(hash)
d704 1
a704 1
    VALUE h = rb_hash_new();
d706 1
a706 1
    st_foreach(RHASH(hash)->tbl, rb_hash_invert_i, h);
d711 1
a711 1
rb_hash_update_i(key, value, hash)
d716 1
a716 1
    rb_hash_aset(hash, key, value);
d721 1
a721 1
rb_hash_update(hash1, hash2)
d724 3
a726 2
    hash2 = to_hash(hash2);
    st_foreach(RHASH(hash2)->tbl, rb_hash_update_i, hash1);
d730 1
a730 1
#ifndef __MACOS__ /* no environment variables on MacOS. */
a735 1
static char **origenviron;
d745 3
a747 1
    nam = STR2CSTR(name);
a748 1
    len = strlen(nam);
d760 1
a760 1
	return rb_str_new2(val);
d770 1
a770 1
    if (rb_iterator_p()) rb_yield(name);
d775 1
a775 1
rb_f_getenv(obj, name)
d778 6
a783 2
    char *nam, *env;
    int len;
d785 1
a785 5
    nam = str2cstr(name, &len);
    if (strlen(nam) != len) {
	rb_raise(rb_eArgError, "Bad environment variable name");
    }
    env = getenv(nam);
d787 3
a789 3
	if (strcmp(nam, "PATH") == 0 && !rb_env_path_tainted())
	    return rb_str_new2(env);
	return rb_tainted_str_new2(env);
d803 1
a803 1
	if (stat(path, &st) == 0 && (st.st_mode & 002)) {
d814 2
a815 2
int
rb_path_check(path)
d818 2
a819 2
    char *p, *pend;
    const char sep = RUBY_PATH_SEP[0];
d821 3
a823 1
    if (!path) return 1;
d826 1
a826 1
    pend = strchr(path, sep);
d834 1
a834 1
	*pend = sep;
d836 2
a837 1
	    return 0;
d840 1
a840 1
	pend = strchr(p, sep);
d842 1
a842 8
    return 1;
}

static void
path_tainted_p(path)
    char *path;
{
    path_tainted = rb_path_check(path)?0:1;
d846 1
a846 1
rb_env_path_tainted()
d849 1
a849 1
	path_tainted_p(getenv("PATH"));
a853 126
static int
envix(nam)
char *nam;
{
    register int i, len = strlen(nam);

    for (i = 0; environ[i]; i++) {
	if (
#ifdef WIN32
	    strnicmp(environ[i],nam,len) == 0
#else
	    memcmp(environ[i],nam,len) == 0
#endif
	    && environ[i][len] == '=')
	    break;			/* memcmp must come first to avoid */
    }					/* potential SEGV's */
    return i;
}

static void
my_setenv(name, value)
    char *name;
    char *value;
{
#ifdef WIN32
#ifdef USE_WIN32_RTL_ENV
    register char *envstr;
    STRLEN namlen = strlen(name);
    STRLEN vallen;
    char *oldstr = environ[envix(name)];

    /* putenv() has totally broken semantics in both the Borland
     * and Microsoft CRTLs.  They either store the passed pointer in
     * the environment without making a copy, or make a copy and don't
     * free it. And on top of that, they dont free() old entries that
     * are being replaced/deleted.  This means the caller must
     * free any old entries somehow, or we end up with a memory
     * leak every time setenv() is called.  One might think
     * one could directly manipulate environ[], like the UNIX code
     * above, but direct changes to environ are not allowed when
     * calling putenv(), since the RTLs maintain an internal
     * *copy* of environ[]. Bad, bad, *bad* stink.
     * GSAR 97-06-07
     */

    if (!value) {
	if (!oldstr)
	    return;
	value = "";
	vallen = 0;
    }
    else
	vallen = strlen(val);
    envstr = ALLOC_N(char, namelen + vallen + 3);
    sprintf(envstr,"%s=%s",name,value);
    putenv(envstr);
    if (oldstr) free(oldstr);
#ifdef _MSC_VER
    free(envstr);		/* MSVCRT leaks without this */
#endif

#else /* !USE_WIN32_RTL_ENV */

    /* The sane way to deal with the environment.
     * Has these advantages over putenv() & co.:
     *  * enables us to store a truly empty value in the
     *    environment (like in UNIX).
     *  * we don't have to deal with RTL globals, bugs and leaks.
     *  * Much faster.
     * Why you may want to enable USE_WIN32_RTL_ENV:
     *  * environ[] and RTL functions will not reflect changes,
     *    which might be an issue if extensions want to access
     *    the env. via RTL.  This cuts both ways, since RTL will
     *    not see changes made by extensions that call the Win32
     *    functions directly, either.
     * GSAR 97-06-07
     */
    SetEnvironmentVariable(name,value);
#endif

#else  /* WIN32 */

    register int i=envix(name);		/* where does it go? */

    if (environ == origenviron) {	/* need we copy environment? */
	int j;
	int max;
	char **tmpenv;

	for (max = i; environ[max]; max++) ;
	tmpenv = ALLOC_N(char*, max+2);
	for (j=0; j<max; j++)		/* copy environment */
	    tmpenv[j] = strdup(environ[j]);
	tmpenv[max] = 0;
	environ = tmpenv;		/* tell exec where it is now */
    }
    if (!value) {
	while (environ[i]) {
	    environ[i] = environ[i+1];
	    i++;
	}
	return;
    }
    if (!environ[i]) {			/* does not exist yet */
	REALLOC_N(environ, char*, i+2);	/* just expand it a bit */
	environ[i+1] = 0;	/* make sure it's null terminated */
    }
    else {
	free(environ[i]);
    }
    environ[i] = ALLOC_N(char, strlen(name) + strlen(value) + 2);
#ifndef MSDOS
    sprintf(environ[i],"%s=%s",name,value); /* all that work just for this */
#else
    /* MS-DOS requires environment variable names to be in uppercase */
    /* [Tom Dinger, 27 August 1990: Well, it doesn't _require_ it, but
     * some utilities and applications may break because they only look
     * for upper case strings. (Fixed strupr() bug here.)]
     */
    strcpy(environ[i],name); strupr(environ[i]);
    sprintf(environ[i] + strlen(name),"=%s", value);
#endif /* MSDOS */

#endif /* WIN32 */
}

d855 2
a856 2
rb_f_setenv(obj, nm, val)
    VALUE obj, nm, val;
a857 3
    char *name, *value;
    int nlen, vlen;

d859 2
a860 1
	rb_raise(rb_eSecurityError, "cannot change environment variable");
d863 3
a865 2
    if (NIL_P(val)) {
	env_delete(obj, nm);
d869 11
a879 10
    name = str2cstr(nm, &nlen);
    value = STR2CSTR(val &vlen);
    if (strlen(name) != nlen)
	rb_raise(rb_eArgError, "Bad environment name");
    if (strlen(value) != vlen)
	rb_raise(rb_eArgError, "Bad environment value");

    my_setenv(name, value);
    if (strcmp(name, "PATH") == 0) {
	if (OBJ_TAINTED(val)) {
d882 1
a882 4
	    return Qtrue;
	}
	else {
	    path_tainted_p(value);
d884 2
d887 1
a887 1
    return Qtrue;
d894 1
a894 1
    VALUE ary = rb_ary_new();
d899 1
a899 3
	if (s) {
	    rb_ary_push(ary, rb_tainted_str_new(*env, s-*env));
	}
d909 1
a909 11
    char **env;

    env = environ;
    while (*env) {
	char *s = strchr(*env, '=');
	if (s) {
	    rb_yield(rb_tainted_str_new(*env, s-*env));
	}
	env++;
    }
    return Qnil;
d916 1
a916 1
    VALUE ary = rb_ary_new();
d921 1
a921 3
	if (s) {
	    rb_ary_push(ary, rb_tainted_str_new2(s+1));
	}
d931 1
a931 11
    char **env;

    env = environ;
    while (*env) {
	char *s = strchr(*env, '=');
	if (s) {
	    rb_yield(rb_tainted_str_new2(s+1));
	}
	env++;
    }
    return Qnil;
d938 3
a940 1
    char **env;
d942 4
a945 6
    env = environ;
    while (*env) {
	char *s = strchr(*env, '=');
	if (s) {
	    rb_yield(rb_assoc_new(rb_tainted_str_new(*env, s-*env),
				  rb_tainted_str_new2(s+1)));
d947 1
a947 1
	env++;
d949 1
a949 1
    return Qnil;
d955 3
a957 8
    volatile VALUE keys;
    VALUE *ptr;
    int len;

    rb_secure(4);
    keys = env_keys();
    ptr = RARRAY(keys)->ptr;
    len = RARRAY(keys)->len; 
d960 1
a960 1
	VALUE val = rb_f_getenv(Qnil, *ptr);
d962 1
a962 1
	    if (RTEST(rb_yield(rb_assoc_new(*ptr, val)))) {
d974 1
a974 1
    return rb_str_new2("ENV");
d981 1
a981 1
    VALUE ary = rb_ary_new();
d986 2
a987 4
	if (s) {
	    rb_ary_push(ary, rb_assoc_new(rb_tainted_str_new(*env, s-*env),
					  rb_tainted_str_new2(s+1)));
	}
d1012 2
a1013 2
    if (environ[0] == 0) return Qtrue;
    return Qfalse;
d1020 3
a1022 3
    if (TYPE(key) != T_STRING) return Qfalse;
    if (getenv(STR2CSTR(key))) return Qtrue;
    return Qfalse;
d1030 1
a1030 1
    volatile VALUE ary;
d1032 2
a1033 2
    if (TYPE(value) != T_STRING) return Qfalse;
    ary = rb_ary_new();
d1037 2
a1038 4
	if (s) {
	    if (strncmp(s, RSTRING(value)->ptr, strlen(s)) == 0)
		return Qtrue;
	}
d1041 1
a1041 1
    return Qfalse;
d1050 1
a1050 1
    VALUE indexes = rb_ary_new2(argc);
d1058 1
a1058 1
	    RARRAY(indexes)->ptr[i] = rb_tainted_str_new2(v);
a1068 21
static VALUE
env_to_hash(obj)
    VALUE obj;
{
    char **env;
    VALUE hash = rb_hash_new();

    env = environ;
    while (*env) {
	char *s = strchr(*env, '=');
	if (s) {
	    rb_hash_aset(hash, rb_tainted_str_new(*env, s-*env),
			       rb_tainted_str_new2(s+1));
	}
	env++;
    }
    return hash;
}

#endif  /* ifndef __MACOS__  no environment variables on MacOS. */

d1072 2
d1076 3
a1078 1
    rb_cHash = rb_define_class("Hash", rb_cObject);
d1080 2
a1081 1
    rb_include_module(rb_cHash, rb_mEnumerable);
d1083 39
a1121 2
    rb_define_singleton_method(rb_cHash, "new", rb_hash_s_new, -1);
    rb_define_singleton_method(rb_cHash, "[]", rb_hash_s_create, -1);
d1123 2
a1124 52
    rb_define_method(rb_cHash,"clone", rb_hash_clone, 0);
    rb_define_method(rb_cHash,"dup", rb_hash_dup, 0);
    rb_define_method(rb_cHash,"rehash", rb_hash_rehash, 0);

    rb_define_method(rb_cHash,"freeze", rb_hash_freeze, 0);
    rb_define_method(rb_cHash,"frozen?",rb_hash_frozen_p, 0);

    rb_define_method(rb_cHash,"to_hash", rb_hash_to_hash, 0);
    rb_define_method(rb_cHash,"to_a", rb_hash_to_a, 0);
    rb_define_method(rb_cHash,"to_s", rb_hash_to_s, 0);
    rb_define_method(rb_cHash,"inspect", rb_hash_inspect, 0);

    rb_define_method(rb_cHash,"==", rb_hash_equal, 1);
    rb_define_method(rb_cHash,"[]", rb_hash_aref, 1);
    rb_define_method(rb_cHash,"fetch", rb_hash_fetch, -1);
    rb_define_method(rb_cHash,"[]=", rb_hash_aset, 2);
    rb_define_method(rb_cHash,"store", rb_hash_aset, 2);
    rb_define_method(rb_cHash,"default", rb_hash_default, 0);
    rb_define_method(rb_cHash,"default=", rb_hash_set_default, 1);
    rb_define_method(rb_cHash,"indexes", rb_hash_indexes, -1);
    rb_define_method(rb_cHash,"indices", rb_hash_indexes, -1);
    rb_define_method(rb_cHash,"length", rb_hash_length, 0);
    rb_define_alias(rb_cHash, "size", "length");
    rb_define_method(rb_cHash,"empty?", rb_hash_empty_p, 0);

    rb_define_method(rb_cHash,"each", rb_hash_each_pair, 0);
    rb_define_method(rb_cHash,"each_value", rb_hash_each_value, 0);
    rb_define_method(rb_cHash,"each_key", rb_hash_each_key, 0);
    rb_define_method(rb_cHash,"each_pair", rb_hash_each_pair, 0);
    rb_define_method(rb_cHash,"sort", rb_hash_sort, 0);

    rb_define_method(rb_cHash,"keys", rb_hash_keys, 0);
    rb_define_method(rb_cHash,"values", rb_hash_values, 0);

    rb_define_method(rb_cHash,"shift", rb_hash_shift, 0);
    rb_define_method(rb_cHash,"delete", rb_hash_delete, 1);
    rb_define_method(rb_cHash,"delete_if", rb_hash_delete_if, 0);
    rb_define_method(rb_cHash,"clear", rb_hash_clear, 0);
    rb_define_method(rb_cHash,"invert", rb_hash_invert, 0);
    rb_define_method(rb_cHash,"update", rb_hash_update, 1);
    rb_define_method(rb_cHash,"replace", rb_hash_replace, 1);

    rb_define_method(rb_cHash,"include?", rb_hash_has_key, 1);
    rb_define_method(rb_cHash,"has_key?", rb_hash_has_key, 1);
    rb_define_method(rb_cHash,"has_value?", rb_hash_has_value, 1);
    rb_define_method(rb_cHash,"key?", rb_hash_has_key, 1);
    rb_define_method(rb_cHash,"value?", rb_hash_has_value, 1);

#ifndef __MACOS__ /* environment variables nothing on MacOS. */
    origenviron = environ;
    envtbl = rb_obj_alloc(rb_cObject);
    rb_extend_object(envtbl, rb_mEnumerable);
d1126 2
a1127 2
    rb_define_singleton_method(envtbl,"[]", rb_f_getenv, 1);
    rb_define_singleton_method(envtbl,"[]=", rb_f_setenv, 2);
a1137 1
    rb_define_singleton_method(envtbl,"indices", env_indexes, -1);
a1146 1
    rb_define_singleton_method(envtbl,"to_hash", env_to_hash, 0);
a1148 4
#else /* __MACOS__ */
	envtbl = rb_hash_s_new(0, NULL, rb_cHash);
    rb_define_global_const("ENV", envtbl);
#endif  /* ifndef __MACOS__  environment variables nothing on MacOS. */
@


1.1.1.3.2.1
log
@990126
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:24 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
a23 4
#ifdef USE_CWGUSI
char* strdup(const char*);
#endif

d844 1
d1365 2
@


1.1.1.3.2.2
log
@990201
@
text
@d6 1
a6 1
  $Date: 1999/01/26 10:08:12 $
d37 1
a37 1
    if (!FL_TEST(hash, FL_TAINT) && rb_safe_level() >= 4)
d462 1
a462 1
    if (RTEST(rb_yield(rb_assoc_new(key, value))))
d1118 1
a1118 1
    value = str2cstr(val, &vlen);
@


1.1.1.3.2.3
log
@990203
@
text
@d6 1
a6 1
  $Date: 1999/02/01 07:34:55 $
a1417 1
    rb_define_method(rb_cHash,"reject!", rb_hash_delete_if, 0);
a1441 1
    rb_define_singleton_method(envtbl,"reject!", env_delete_if, 0);
@


1.1.1.3.2.4
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/02/03 09:47:58 $
d507 1
a507 1
	st_add_direct(RHASH(hash)->tbl, rb_str_new4(key), val);
@


1.1.1.3.2.5
log
@990224
@
text
@d6 1
a6 1
  $Date: 1999/02/09 06:08:21 $
a14 1
#include "util.h"
d134 1
a134 1
    if (value == Qnil) return ST_CONTINUE;
d435 1
a435 1
    if (value == Qnil) return ST_CONTINUE;
d461 1
a461 1
    if (value == Qnil) return ST_CONTINUE;
d551 1
a551 1
    if (value == Qnil) return ST_CONTINUE;
d568 1
a568 1
    if (value == Qnil) return ST_CONTINUE;
d585 1
a585 1
    if (value == Qnil) return ST_CONTINUE;
d602 1
a602 1
    if (value == Qnil) return ST_CONTINUE;
d632 1
a632 1
    if (value == Qnil) return ST_CONTINUE;
d694 1
a694 1
    if (value == Qnil) return ST_CONTINUE;
d715 1
a715 1
    if (value == Qnil) return ST_CONTINUE;
d747 1
a747 1
    if (value == Qnil) return ST_CONTINUE;
d780 1
a780 1
    if (val1 == Qnil) return ST_CONTINUE;
d814 1
a814 1
    if (value == Qnil) return ST_CONTINUE;
d834 1
a834 1
    if (value == Qnil) return ST_CONTINUE;
a854 18
void
ruby_unsetenv(name)
    char *name;
{
    int i, len;

    len = strlen(name);
    for(i=0; environ[i]; i++) {
	if (strncmp(environ[i], name, len) == 0 && environ[i][len] == '=') {
	    break;
	}
    }
    while (environ[i]) {
	environ[i] = environ[i+1];
	i++;
    }
}

d864 1
a864 3
    if (strcmp(nam, "PATH") == 0 && !OBJ_TAINTED(name)) {
	path_tainted = 0;
    }
d994 2
a995 2
void
ruby_setenv(name, value)
a1100 11
void
ruby_setenv2(name, value)
    char *name;
    char *value;
{
    if (value == NULL) {
	ruby_unsetenv(name);
    }
    ruby_setenv(name, value);
}

d1124 1
a1124 1
    ruby_setenv(name, value);
@


1.1.1.3.2.6
log
@990225
@
text
@d6 1
a6 1
  $Date: 1999/02/24 04:31:20 $
d195 1
a195 1
    VALUE ifnone;
d205 5
a209 1
    rb_scan_args(argc, argv, "01", &ifnone);
d212 2
a213 2
    hash->tbl = st_init_table(&objhash);
    rb_obj_call_init((VALUE)hash, argc, argv);
d249 4
a252 2
	NEWOBJ(hash, struct RHash);
	OBJSETUP(hash, klass, T_HASH);
d254 7
a260 7
	hash->iter_lev = 0;
	hash->ifnone = Qnil;
	hash->tbl = 0;	/* avoid GC crashing  */
	hash->tbl = (st_table*)st_copy(RHASH(argv[0])->tbl);
	rb_obj_call_init((VALUE)hash, argc, argv);

	return (VALUE)hash;
d271 1
a271 1
    rb_obj_call_init(hash, argc, argv);
d921 1
a921 1
	rb_raise(rb_eArgError, "bad environment variable name");
d1122 11
d1152 1
a1152 1
	rb_raise(rb_eArgError, "bad environment variable name");
d1154 1
a1154 1
	rb_raise(rb_eArgError, "bad environment variable value");
@


1.1.1.3.2.7
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/25 06:39:07 $
d850 18
d873 1
a873 1
    char *nam, *val;
d876 14
a889 3
    nam = str2cstr(name, &len);
    if (strlen(nam) != len) {
	rb_raise(rb_eArgError, "bad environment variable name");
a890 1
    val = getenv(nam);
a891 4
	ruby_setenv(nam, 0);
	if (strcmp(nam, "PATH") == 0 && !OBJ_TAINTED(name)) {
	    path_tainted = 0;
	}
d1014 1
a1014 1
#if defined(WIN32) && !defined(__CYGWIN32__)
d1072 1
a1072 1
    int i=envix(name);		        /* where does it go? */
a1086 1
	free(environ[i]);
a1113 7
}

void
ruby_unsetenv(name)
    char *name;
{
    ruby_setenv(name, 0);
@


1.1.1.3.2.8
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:28 $
d987 2
a988 2
    const char *name;
    const char *value;
d1095 1
a1095 1
    const char *name;
@


1.1.1.3.2.9
log
@prepare to alpha
@
text
@d6 1
a6 1
  $Date: 1999/04/09 17:57:39 $
d244 3
a246 4
    if (argc == 1) {
	if (TYPE(argv[0]) == T_HASH) {
	    NEWOBJ(hash, struct RHash);
	    OBJSETUP(hash, klass, T_HASH);
d248 5
a252 5
	    hash->iter_lev = 0;
	    hash->ifnone = Qnil;
	    hash->tbl = 0;	/* avoid GC crashing  */
	    hash->tbl = st_copy(RHASH(argv[0])->tbl);
	    rb_obj_call_init((VALUE)hash, argc, argv);
d254 1
a254 6
	    return (VALUE)hash;
	}
	else {
	    VALUE a = rb_Array(argv[0]);
	    return rb_hash_s_create(RARRAY(a)->len, RARRAY(a)->ptr, klass);
	}
@


1.1.1.3.2.10
log
@regexp null pattern
@
text
@d6 1
a6 1
  $Date: 1999/04/16 06:03:31 $
d196 1
d860 1
a860 1
    int len;
@


1.1.1.3.2.11
log
@thread bugs
@
text
@d6 1
a6 1
  $Date: 1999/05/25 08:26:00 $
a1050 7
#elif defined __CYGWIN__
#undef setenv
#undef unsetenv
    if (value)
	setenv(name,value,1);
    else
	unsetenv(name);
@


1.1.1.3.2.12
log
@990611
@
text
@d6 1
a6 1
  $Date: 1999/06/09 09:21:13 $
d208 1
d252 1
d270 1
@


1.1.1.3.2.13
log
@990715
@
text
@d6 1
a6 1
  $Date: 1999/06/11 06:29:53 $
d151 8
d167 1
a167 1
	    st_cleanup_safe(RHASH(hash)->tbl, Qnil);
a383 26
static int
index_i(key, value, args)
    VALUE key, value;
    VALUE *args;
{
    if (rb_equal(value, args[0])) {
	args[1] = key;
	return ST_STOP;
    }
    return ST_CONTINUE;
}

static VALUE
rb_hash_index(hash, value)
    VALUE hash, value;
{
    VALUE args[2];

    args[0] = value;
    args[1] = Qnil;

    st_foreach(RHASH(hash)->tbl, index_i, args);

    return args[1];
}

d1317 1
d1320 1
a1333 20
env_index(dmy, value)
    VALUE dmy, value;
{
    char **env;

    if (TYPE(value) != T_STRING) return Qnil;
    env = environ;
    while (*env) {
	char *s = strchr(*env, '=')+1;
	if (s) {
	    if (strncmp(s, RSTRING(value)->ptr, strlen(s)) == 0) {
		return rb_tainted_str_new(*env, s-*env);
	    }
	}
	env++;
    }
    return Qnil;
}

static VALUE
a1407 1
    rb_define_method(rb_cHash,"index", rb_hash_index, 1);
a1432 1
    rb_define_method(rb_cHash,"member?", rb_hash_has_key, 1);
a1454 1
    rb_define_singleton_method(envtbl,"index", env_index, 1);
a1461 1
    rb_define_singleton_method(envtbl,"member?", env_has_key, 1);
@


1.1.1.3.2.14
log
@990728
@
text
@d6 1
a6 1
  $Date: 1999/07/15 07:59:46 $
d493 2
a494 2
clear_i(key, value, dummy)
    VALUE key, value, dummy;
d504 1
a504 1
    st_foreach(RHASH(hash)->tbl, clear_i, 0);
@


1.1.1.3.2.15
log
@990806
@
text
@d6 1
a6 1
  $Date: 1999/07/28 09:26:40 $
a70 7
static VALUE
eql(args)
    VALUE *args;
{
    return (VALUE)rb_eql(args[0], args[1]);
}

a80 2
    else {
	VALUE args[2];
d82 4
a85 4
	args[0] = a;
	args[1] = b;
	return !rb_with_disable_interrupt(eql, (VALUE)args);
    }
d947 1
a947 1
    const char sep = PATH_SEP_CHAR;
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:13:16 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@1.1b7 pre
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:46 $
d182 1
a182 1
    return rb_ensure(hash_foreach_call, (VALUE)&arg, hash_foreach_ensure, hash);
d310 1
a310 1
    return hash;
d408 1
a408 1
    return hash;
d425 1
a425 1
    return hash;
a443 19
static int
replace_i(key, val, hash)
    VALUE key, val, hash;
{
    hash_aset(hash, key, val);
    return ST_CONTINUE;
}

static VALUE
hash_replace(hash, hash2)
    VALUE hash, hash2;
{
    Check_Type(hash2, T_HASH);
    hash_clear(hash);
    st_foreach(RHASH(hash2)->tbl, replace_i, hash);

    return hash;
}

d474 1
a474 1
    return hash;
d491 1
a491 1
    return hash;
d508 1
a508 1
    return hash;
a1097 1
    rb_define_method(cHash,"indices", hash_indexes, -1);
a1115 1
    rb_define_method(cHash,"replace", hash_replace, 1);
a1137 1
    rb_define_singleton_method(envtbl,"indices", env_indexes, -1);
@


1.1.1.2.2.3
log
@1.1b7 pre2
@
text
@d6 1
a6 1
  $Date: 1998/02/09 10:56:20 $
a16 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
@


1.1.1.2.2.4
log
@1.1b7 pre3
@
text
@d6 1
a6 1
  $Date: 1998/02/10 06:50:15 $
d17 3
a19 1
#include <sys/types.h>
@


1.1.1.2.2.5
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/02/10 08:44:05 $
d187 1
a187 1
hash_s_new(argc, argv, klass)
d190 1
a190 1
    VALUE klass;
d196 1
a196 1
    OBJSETUP(hash, klass, T_HASH);
d211 2
a212 2
hash_new2(klass)
    VALUE klass;
d214 1
a214 1
    return hash_s_new(0, 0, klass);
d224 1
a224 1
hash_s_create(argc, argv, klass)
d227 1
a227 1
    VALUE klass;
d233 1
a233 1
	if (klass == CLASS_OF(argv[0])) return argv[0];
d236 1
a236 1
	    OBJSETUP(hash, klass, T_HASH);
d249 1
a249 1
    hash = hash_new2(klass);
@


1.1.1.2.2.6
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:39 $
d24 3
a27 1
#define HASH_DELETED  FL_USER2
a133 2
    st_table *tbl = RHASH(arg->hash)->tbl;
    st_table_entry **bins = tbl->bins;
d137 1
a137 3
    if (RHASH(arg->hash)->tbl != tbl || RHASH(arg->hash)->tbl->bins != bins){
	IndexError("rehash occurred during iteration");
    }
d153 1
a153 1
    if (value == Qnil) return ST_DELETE;
d164 1
a164 1
	if (FL_TEST(hash, HASH_DELETED)) {
a165 1
	    FL_UNSET(hash, HASH_DELETED);
d167 1
d309 1
d350 2
a351 3
    if (RHASH(hash)->iter_lev > 0 &&
	st_delete_safe(RHASH(hash)->tbl, &key, &val, Qnil)) {
	FL_SET(hash, HASH_DELETED);
a352 1
    }
@


1.1.1.2.2.7
log
@block arg etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/27 05:43:40 $
a1174 3

    /* turn on premitive flag for the class */
    FL_SET(cHash, FL_PRIMITIVE);
@


1.1.1.2.2.8
log
@gets speed up patch
@
text
@d6 1
a6 1
  $Date: 1998/03/05 06:37:45 $
d1175 3
@


1.1.1.2.2.9
log
@call initialize
@
text
@d6 1
a6 1
  $Date: 1998/03/11 07:32:56 $
a207 1
    obj_call_init((VALUE)hash);
d216 1
a216 9
    NEWOBJ(hash, struct RHash);
    OBJSETUP(hash, klass, T_HASH);

    hash->iter_lev = 0;
    hash->status = 0;
    hash->tbl = 0;		/* avoid GC crashing  */
    hash->tbl = st_init_table(&objhash);

    return (VALUE)hash;
a243 1
	    obj_call_init((VALUE)hash);
a255 1
    obj_call_init(hash);
@


1.1.1.2.2.10
log
@dynamic (nested) local variables
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:03:49 $
d529 1
a529 1
each_pair_i(key, value, rev)
d533 1
a533 4
    if (rev) 
	rb_yield(assoc_new(value, key));
    else
	rb_yield(assoc_new(key, value));
d541 1
a541 9
    hash_foreach(hash, each_pair_i, 0);
    return hash;
}

static VALUE
hash_each_with_index(hash)
    VALUE hash;
{
    hash_foreach(hash, each_pair_i, 1);
a1140 1
    rb_define_method(cHash,"each_with_index", hash_each_with_index, 0);
@


1.1.1.2.2.11
log
@flock,flatten,signal to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/07 08:34:08 $
d453 1
a453 1
	key = str_dup_frozen(key);
@


1.1.1.2.2.12
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/04/16 07:42:43 $
d529 1
a529 1
each_pair_i(key, value)
d533 4
a536 1
    rb_yield(assoc_new(key, value));
d548 8
d1152 1
@


1.1.1.2.2.13
log
@tcltklib/gtk
@
text
@d6 1
a6 1
  $Date: 1998/04/20 05:55:36 $
a300 7
static VALUE
to_hash(hash)
    VALUE hash;
{
    return rb_convert_type(hash, T_HASH, "Hash", "to_hash");
}

d471 1
a471 1
    hash2 = to_hash(hash2);
a604 7
static VALUE
hash_to_hash(hash)
    VALUE hash;
{
    return hash;
}

d758 2
a759 1
    hash2 = to_hash(hash2);
d779 2
a780 1
    nam = STR2CSTR(name);
d812 1
a812 2
    char *nam, *env;
    int len;
d814 3
a816 2
    nam = str2cstr(name, &len);
    if (strlen(nam) != len)
d819 1
a819 1
    env = getenv(nam);
d821 1
a821 1
	if (strcmp(nam, "PATH") == 0 && !env_path_tainted())
a1102 19
static VALUE
env_to_hash(obj)
    VALUE obj;
{
    VALUE hash = hash_new();
    VALUE ary = env_keys();
    VALUE *ptr = RARRAY(ary)->ptr;
    int len = RARRAY(ary)->len; 

    while (len--) {
	VALUE val = f_getenv(Qnil, *ptr);
	if (!NIL_P(val)) {
	    hash_aset(hash, *ptr, val);
	}
	ptr++;
    }
    return hash;
}

a1123 1
    rb_define_method(cHash,"to_hash", hash_to_hash, 0);
a1183 1
    rb_define_singleton_method(envtbl,"to_hash", env_to_hash, 0);
@


1.1.1.2.2.14
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/04/27 10:03:54 $
d159 1
a159 1
static VALUE
a776 2
#ifndef __MACOS__ /* environment variables nothing on MacOS. */

a1133 2
#endif  /* ifndef __MACOS__  environment variables nothing on MacOS. */

a1190 1
#ifndef __MACOS__ /* environment variables nothing on MacOS. */
a1218 4
#else /* __MACOS__ */
	envtbl = hash_s_new(0, NULL, cHash);
    rb_define_global_const("ENV", envtbl);
#endif  /* ifndef __MACOS__  environment variables nothing on MacOS. */
@


1.1.1.2.2.15
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:18 $
d21 1
a21 1
char *strchr _((char*,char));
d54 4
d778 2
@


1.1.1.2.2.16
log
@remove unused variables
@
text
@d6 1
a6 1
  $Date: 1998/05/18 04:56:03 $
a166 1
    return 0;
a195 4
    hash->iter_lev = 0;
    hash->status = 0;
    hash->tbl = 0;		/* avoid GC crashing  */

d200 3
d919 2
@


1.1.1.2.2.17
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 04:57:37 $
d374 1
a374 3
    if (iterator_p()) {
	return rb_yield(key);
    }
@


1.1.1.2.2.18
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 09:42:26 $
a343 23
hash_fetch(argc, argv, hash)
    int argc;
    VALUE *argv;
    VALUE hash;
{
    VALUE key, if_none;
    VALUE val;

    rb_scan_args(argc, argv, "11", &key, &if_none);

    if (!st_lookup(RHASH(hash)->tbl, key, &val)) {
	if (iterator_p()) {
	    if (argc > 1) {
		ArgError("wrong # of arguments", argc);
	    }
	    return rb_yield(argv[0]);
	}
	return if_none;
    }
    return val;
}

static VALUE
a1161 1
    rb_define_method(cHash,"fetch", hash_fetch, -1);
a1162 1
    rb_define_method(cHash,"store", hash_aset, 2);
@


1.1.1.2.2.19
log
@baseline
@
text
@d6 1
a6 1
  $Date: 1998/05/27 09:31:51 $
d15 1
a15 1
#include "rubysig.h"
@


1.1.1.2.2.20
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/16 04:23:32 $
d928 1
d1160 2
@


1.1.1.2.2.21
log
@1.1b9_29
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:22 $
d106 1
a106 1
	hval = FIX2LONG(hval);
@


1.1.1.2.2.22
log
@str2cstr
@
text
@d6 1
a6 1
  $Date: 1998/07/03 07:06:28 $
d201 2
a202 3
    if (rb_scan_args(argc, argv, "01", &sz) == 0) {
	size = 0;
    }
d851 3
a853 3
    if (strlen(nam) != len) {
	ArgError("Bad environment variable name");
    }
@


1.1.1.2.2.23
log
@1.1c3
@
text
@d6 1
a6 1
  $Date: 1998/07/13 04:37:38 $
d538 1
a538 1
    hash_foreach(hash, each_value_i, 0);
d555 1
a555 1
    hash_foreach(hash, each_key_i, 0);
@


1.1.1.2.2.24
log
@1.1c final (hopefully)
@
text
@d6 1
a6 1
  $Date: 1998/08/27 03:55:15 $
d1005 1
a1005 1
    volatile VALUE ary = env_keys();
d1022 1
a1022 1
    volatile VALUE ary = env_keys();
@


1.1.1.2.2.25
log
@1.2.2 PR1
@
text
@d6 1
a6 1
  $Date: 1998/12/14 09:00:07 $
a965 4
	if (!s) {
	  env++;
	  continue;
	}
a987 4
	if (!s) {
	  env++;
	  continue;
	}
a1052 4
	if (!s) {
	  env++;
	  continue;
	}
a1097 1
    int len;
d1103 2
a1104 7
	char *s = strchr(*env, '=');
	if (!s) {
	  env++;
	  continue;
	}
	s++;
	len = strlen(s);
@


1.1.1.2.2.26
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/01/18 09:08:50 $
d442 1
a442 1
    if (RTEST(rb_yield(assoc_new(key, value))))
@


1.1.1.2.2.23.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/08/27 03:55:15 $
d28 1
a28 1
rb_hash_modify(hash)
d33 1
a33 1
	rb_raise(rb_eTypeError, "can't modify frozen hash");
d38 1
a38 1
rb_hash_freeze(hash)
d46 1
a46 1
rb_hash_frozen_p(hash)
d50 2
a51 2
	return Qtrue;
    return Qfalse;
d54 1
a54 1
VALUE rb_cHash;
d67 1
a67 1
rb_any_cmp(a, b)
d74 1
a74 1
	if (TYPE(b) == T_STRING) return rb_str_cmp(a, b);
d84 1
a84 1
rb_any_hash(a, mod)
d96 1
a96 1
	hval = rb_str_hash(a);
a107 1
    if (hval < 0) hval = -hval;
d112 2
a113 2
    rb_any_cmp,
    rb_any_hash,
d116 1
a116 1
struct rb_hash_foreach_arg {
d123 1
a123 1
rb_hash_foreach_iter(key, value, arg)
d125 1
a125 1
    struct rb_hash_foreach_arg *arg;
d134 1
a134 1
	rb_raise(rb_eIndexError, "rehash occurred during iteration");
d140 2
a141 2
rb_hash_foreach_call(arg)
    struct rb_hash_foreach_arg *arg;
d143 1
a143 1
    st_foreach(RHASH(arg->hash)->tbl, rb_hash_foreach_iter, arg);
d148 1
a148 1
rb_hash_delete_nil(key, value)
d156 1
a156 1
rb_hash_foreach_ensure(hash)
d163 1
a163 1
	    st_foreach(RHASH(hash)->tbl, rb_hash_delete_nil, 0);
d171 1
a171 1
rb_hash_foreach(hash, func, farg)
d176 1
a176 1
    struct rb_hash_foreach_arg arg;
d182 1
a182 1
    return rb_ensure(rb_hash_foreach_call, (VALUE)&arg, rb_hash_foreach_ensure, hash);
d186 1
a186 1
rb_hash_s_new(argc, argv, klass)
d191 1
a191 1
    VALUE sz, ifnone;
d198 1
a198 1
    hash->ifnone = Qnil;
d201 1
a201 2
    rb_scan_args(argc, argv, "02", &ifnone, &sz);
    if (NIL_P(sz)) {
a205 1
    hash->ifnone = ifnone;
d207 1
a207 1
    rb_obj_call_init((VALUE)hash);
d213 1
a213 1
rb_hash_new2(klass)
d220 1
a220 1
    hash->ifnone = Qnil;
d228 1
a228 1
rb_hash_new()
d230 1
a230 1
    return rb_hash_new2(rb_cHash);
d234 1
a234 1
rb_hash_s_create(argc, argv, klass)
d249 1
a249 1
	    hash->ifnone = Qnil;
d252 1
a252 1
	    rb_obj_call_init((VALUE)hash);
d258 1
a258 1
	rb_raise(rb_eArgError, "odd number args for Hash");
d260 1
a260 1
    hash = rb_hash_new2(klass);
d265 1
a265 1
    rb_obj_call_init(hash);
d271 1
a271 1
rb_hash_clone(hash)
d278 1
a278 1
    hash2->ifnone = RHASH(hash)->ifnone;
d286 1
a286 1
rb_hash_dup(hash)
d293 1
a293 1
    hash2->ifnone = RHASH(hash)->ifnone;
d308 1
a308 1
rb_hash_rehash_i(key, value, tbl)
d319 1
a319 1
rb_hash_rehash(hash)
d325 1
a325 1
    st_foreach(RHASH(hash)->tbl, rb_hash_rehash_i, tbl);
d333 1
a333 1
rb_hash_aref(hash, key)
d339 1
a339 1
	return RHASH(hash)->ifnone;
d345 1
a345 1
rb_hash_fetch(argc, argv, hash)
d356 1
a356 1
	if (rb_iterator_p()) {
d358 1
a358 1
		rb_raise(rb_eArgError, "wrong # of arguments", argc);
d368 1
a368 9
rb_hash_default(hash, ifnone)
    VALUE hash;
{
    RHASH(hash)->ifnone = ifnone;
    return hash;
}

static VALUE
rb_hash_indexes(argc, argv, hash)
d376 1
a376 1
    indexes = rb_ary_new2(argc);
d378 1
a378 1
	RARRAY(indexes)->ptr[i] = rb_hash_aref(hash, argv[i]);
d385 1
a385 1
rb_hash_delete(hash, key)
d390 1
a390 1
    rb_hash_modify(hash);
d398 1
a398 1
    if (rb_iterator_p()) {
d424 1
a424 1
rb_hash_shift(hash)
d429 1
a429 1
    rb_hash_modify(hash);
d434 1
a434 1
    return rb_assoc_new(var.key, var.val);
d442 1
a442 1
    if (rb_yield(rb_assoc_new(key, value)))
d448 1
a448 1
rb_hash_delete_if(hash)
d451 2
a452 2
    rb_hash_modify(hash);
    rb_hash_foreach(hash, delete_if_i, 0);
d465 1
a465 1
rb_hash_clear(hash)
d468 1
a468 1
    rb_hash_modify(hash);
d475 1
a475 1
rb_hash_aset(hash, key, val)
d478 1
a478 1
    rb_hash_modify(hash);
d480 1
a480 1
	rb_hash_delete(hash, key);
d484 1
a484 1
	key = rb_str_dup_frozen(key);
d494 1
a494 1
    rb_hash_aset(hash, key, val);
d499 1
a499 1
rb_hash_replace(hash, hash2)
d503 1
a503 1
    rb_hash_clear(hash);
d510 1
a510 1
rb_hash_length(hash)
d517 1
a517 1
rb_hash_empty_p(hash)
d521 2
a522 2
	return Qtrue;
    return Qfalse;
d535 1
a535 1
rb_hash_each_value(hash)
d538 1
a538 1
    rb_hash_foreach(hash, each_value_i, 0);
d552 1
a552 1
rb_hash_each_key(hash)
d555 1
a555 1
    rb_hash_foreach(hash, each_key_i, 0);
d564 1
a564 1
    rb_yield(rb_assoc_new(key, value));
d569 1
a569 1
rb_hash_each_pair(hash)
d572 1
a572 1
    rb_hash_foreach(hash, each_pair_i, 0);
d581 1
a581 1
    rb_ary_push(ary, rb_assoc_new(key, value));
d586 1
a586 1
rb_hash_to_a(hash)
d591 1
a591 1
    ary = rb_ary_new();
a596 7
static VALUE
rb_hash_sort(hash)
    VALUE hash;
{
    return rb_ary_sort_bang(rb_hash_to_a(hash));
}

d605 1
a605 1
	rb_str_cat(str, ", ", 2);
d608 2
a609 2
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
    rb_str_cat(str, "=>", 2);
d611 1
a611 1
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d617 1
a617 1
rb_hash_inspect(hash)
d622 1
a622 1
    str = rb_str_new2("{");
d624 1
a624 1
    rb_str_cat(str, "}", 1);
d630 1
a630 1
rb_hash_to_s(hash)
d633 1
a633 1
    return rb_ary_to_s(rb_hash_to_a(hash));
d637 1
a637 1
rb_hash_to_hash(hash)
d648 1
a648 1
    rb_ary_push(ary, key);
d653 1
a653 1
rb_hash_keys(hash)
d658 1
a658 1
    ary = rb_ary_new();
d669 1
a669 1
    rb_ary_push(ary, value);
d674 1
a674 1
rb_hash_values(hash)
d679 1
a679 1
    ary = rb_ary_new();
d686 1
a686 1
rb_hash_has_key(hash, key)
d691 1
a691 1
	return Qtrue;
d693 1
a693 1
    return Qfalse;
d697 1
a697 1
rb_hash_search_value(key, value, data)
d702 1
a702 1
	data[0] = Qtrue;
d709 1
a709 1
rb_hash_has_value(hash, val)
d715 1
a715 1
    data[0] = Qfalse;
d717 1
a717 1
    st_foreach(RHASH(hash)->tbl, rb_hash_search_value, data);
d735 1
a735 1
	data->result = Qfalse;
d739 1
a739 1
	data->result = Qfalse;
d746 1
a746 1
rb_hash_equal(hash1, hash2)
d751 1
a751 1
    if (TYPE(hash2) != T_HASH) return Qfalse;
d753 1
a753 1
	return Qfalse;
d756 1
a756 1
    data.result = Qtrue;
d763 1
a763 1
rb_hash_invert_i(key, value, hash)
d768 1
a768 1
    rb_hash_aset(hash, value, key);
d773 1
a773 1
rb_hash_invert(hash)
d776 1
a776 1
    VALUE h = rb_hash_new();
d778 1
a778 1
    st_foreach(RHASH(hash)->tbl, rb_hash_invert_i, h);
d783 1
a783 1
rb_hash_update_i(key, value, hash)
d788 1
a788 1
    rb_hash_aset(hash, key, value);
d793 1
a793 1
rb_hash_update(hash1, hash2)
d797 1
a797 1
    st_foreach(RHASH(hash2)->tbl, rb_hash_update_i, hash1);
d830 1
a830 1
	return rb_str_new2(val);
d840 1
a840 1
    if (rb_iterator_p()) rb_yield(name);
d845 1
a845 1
rb_f_getenv(obj, name)
d853 1
a853 1
	rb_raise(rb_eArgError, "Bad environment variable name");
d857 3
a859 3
	if (strcmp(nam, "PATH") == 0 && !rb_env_path_tainted())
	    return rb_str_new2(env);
	return rb_str_taint(rb_str_new2(env));
d916 1
a916 1
rb_env_path_tainted()
d925 1
a925 1
rb_f_setenv(obj, name, value)
d929 1
a929 1
	rb_raise(rb_eSecurityError, "cannot change environment variable");
d940 1
a940 1
	rb_raise(rb_eArgError, "Bad environment name");
d942 2
a943 2
	rb_raise(rb_eArgError, "Bad environment value");
    
d946 1
a946 1
	if (rb_str_tainted(value)) {
d949 1
a949 1
	    return Qtrue;
d954 1
a954 1
    return Qtrue;
d961 1
a961 1
    VALUE ary = rb_ary_new();
d966 1
a966 1
	rb_ary_push(ary, rb_str_taint(rb_str_new(*env, s-*env)));
d976 1
a976 1
    return rb_ary_each(env_keys());
d983 1
a983 1
    VALUE ary = rb_ary_new();
d988 1
a988 1
	rb_ary_push(ary, rb_str_taint(rb_str_new2(s+1)));
d998 1
a998 1
    return rb_ary_each(env_values());
d1010 1
a1010 1
	VALUE val = rb_f_getenv(Qnil, *ptr);
d1012 1
a1012 1
	    rb_yield(rb_assoc_new(*ptr, val));
d1027 1
a1027 1
	VALUE val = rb_f_getenv(Qnil, *ptr);
d1029 1
a1029 1
	    if (RTEST(rb_yield(rb_assoc_new(*ptr, val)))) {
d1041 1
a1041 1
    return rb_str_new2("ENV");
d1048 1
a1048 1
    VALUE ary = rb_ary_new();
d1053 2
a1054 2
	rb_ary_push(ary, rb_assoc_new(rb_str_taint(rb_str_new(*env, s-*env)),
				   rb_str_taint(rb_str_new2(s+1))));
d1079 2
a1080 2
    if (environ[0] == 0) return Qtrue;
    return Qfalse;
d1087 3
a1089 3
    if (TYPE(key) != T_STRING) return Qfalse;
    if (getenv(RSTRING(key)->ptr)) return Qtrue;
    return Qfalse;
d1099 2
a1100 2
    if (TYPE(value) != T_STRING) return Qfalse;
    ary = rb_ary_new();
d1105 1
a1105 1
	if (strncmp(s, RSTRING(value)->ptr, len) == 0) return Qtrue;
d1108 1
a1108 1
    return Qfalse;
d1117 1
a1117 1
    VALUE indexes = rb_ary_new2(argc);
d1125 1
a1125 1
	    RARRAY(indexes)->ptr[i] = rb_str_new2(v);
d1140 1
a1140 1
    VALUE hash = rb_hash_new();
d1146 1
a1146 1
	VALUE val = rb_f_getenv(Qnil, *ptr);
d1148 1
a1148 1
	    rb_hash_aset(hash, *ptr, val);
d1162 1
a1162 1
    rb_cHash = rb_define_class("Hash", rb_cObject);
d1164 1
a1164 1
    rb_include_module(rb_cHash, rb_mEnumerable);
d1166 2
a1167 2
    rb_define_singleton_method(rb_cHash, "new", rb_hash_s_new, -1);
    rb_define_singleton_method(rb_cHash, "[]", rb_hash_s_create, -1);
d1169 44
a1212 46
    rb_define_method(rb_cHash,"clone", rb_hash_clone, 0);
    rb_define_method(rb_cHash,"dup", rb_hash_dup, 0);
    rb_define_method(rb_cHash,"rehash", rb_hash_rehash, 0);

    rb_define_method(rb_cHash,"freeze", rb_hash_freeze, 0);
    rb_define_method(rb_cHash,"frozen?",rb_hash_frozen_p, 0);

    rb_define_method(rb_cHash,"to_hash", rb_hash_to_hash, 0);
    rb_define_method(rb_cHash,"to_a", rb_hash_to_a, 0);
    rb_define_method(rb_cHash,"to_s", rb_hash_to_s, 0);
    rb_define_method(rb_cHash,"inspect", rb_hash_inspect, 0);

    rb_define_method(rb_cHash,"==", rb_hash_equal, 1);
    rb_define_method(rb_cHash,"[]", rb_hash_aref, 1);
    rb_define_method(rb_cHash,"fetch", rb_hash_fetch, -1);
    rb_define_method(rb_cHash,"[]=", rb_hash_aset, 2);
    rb_define_method(rb_cHash,"store", rb_hash_aset, 2);
    rb_define_method(rb_cHash,"default", rb_hash_default, 1);
    rb_define_method(rb_cHash,"indexes", rb_hash_indexes, -1);
    rb_define_method(rb_cHash,"indices", rb_hash_indexes, -1);
    rb_define_method(rb_cHash,"length", rb_hash_length, 0);
    rb_define_alias(rb_cHash, "size", "length");
    rb_define_method(rb_cHash,"empty?", rb_hash_empty_p, 0);

    rb_define_method(rb_cHash,"each", rb_hash_each_pair, 0);
    rb_define_method(rb_cHash,"each_value", rb_hash_each_value, 0);
    rb_define_method(rb_cHash,"each_key", rb_hash_each_key, 0);
    rb_define_method(rb_cHash,"each_pair", rb_hash_each_pair, 0);
    rb_define_method(rb_cHash,"sort", rb_hash_sort, 0);

    rb_define_method(rb_cHash,"keys", rb_hash_keys, 0);
    rb_define_method(rb_cHash,"values", rb_hash_values, 0);

    rb_define_method(rb_cHash,"shift", rb_hash_shift, 0);
    rb_define_method(rb_cHash,"delete", rb_hash_delete, 1);
    rb_define_method(rb_cHash,"delete_if", rb_hash_delete_if, 0);
    rb_define_method(rb_cHash,"clear", rb_hash_clear, 0);
    rb_define_method(rb_cHash,"invert", rb_hash_invert, 0);
    rb_define_method(rb_cHash,"update", rb_hash_update, 1);
    rb_define_method(rb_cHash,"replace", rb_hash_replace, 1);

    rb_define_method(rb_cHash,"include?", rb_hash_has_key, 1);
    rb_define_method(rb_cHash,"has_key?", rb_hash_has_key, 1);
    rb_define_method(rb_cHash,"has_value?", rb_hash_has_value, 1);
    rb_define_method(rb_cHash,"key?", rb_hash_has_key, 1);
    rb_define_method(rb_cHash,"value?", rb_hash_has_value, 1);
d1215 2
a1216 2
    envtbl = rb_obj_alloc(rb_cObject);
    rb_extend_object(envtbl, rb_mEnumerable);
d1218 2
a1219 2
    rb_define_singleton_method(envtbl,"[]", rb_f_getenv, 1);
    rb_define_singleton_method(envtbl,"[]=", rb_f_setenv, 2);
d1244 1
a1244 1
	envtbl = rb_hash_s_new(0, NULL, rb_cHash);
@


1.1.1.2.2.23.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/09/08 07:08:47 $
d31 1
d902 2
a903 2
void
rb_path_check(path)
d937 1
a937 1
	rb_path_check(getenv("PATH"));
d970 1
a970 1
	rb_path_check(RSTRING(name)->ptr);
@


1.1.1.2.2.23.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/10/06 03:28:10 $
d31 1
a31 1
    if (FL_TEST(hash, HASH_FREEZE))
d33 1
a33 2
    if (rb_safe_level() >= 4 && !FL_TEST(hash, FL_TAINT))
	rb_raise(rb_eSecurityError, "Insecure: can't modify hash");
d83 1
a83 1
rb_any_hash(a)
d85 1
d107 2
a108 1
    return  hval;
d129 1
a129 1
    struct st_table_entry **bins = tbl->bins;
d370 1
a370 1
rb_hash_default(hash)
a372 7
    return RHASH(hash)->ifnone;
}

static VALUE
rb_hash_set_default(hash, ifnone)
    VALUE hash, ifnone;
{
d493 2
a494 5
    if (TYPE(key) != T_STRING || st_lookup(RHASH(hash)->tbl, key, 0)) {
	st_insert(RHASH(hash)->tbl, key, val);
    }
    else {
	st_add_direct(RHASH(hash)->tbl, rb_str_dup_frozen(key), val);
d496 1
d876 1
a876 1
	return rb_tainted_str_new2(env);
d963 1
a963 1
	if (rb_obj_tainted(value)) {
d983 1
a983 1
	rb_ary_push(ary, rb_tainted_str_new(*env, s-*env));
d1005 1
a1005 1
	rb_ary_push(ary, rb_tainted_str_new2(s+1));
d1039 3
a1041 8
    VALUE ary;
    VALUE *ptr;
    int len;

    rb_secure(4);
    ary = env_keys();
    ptr = RARRAY(ary)->ptr;
    len = RARRAY(ary)->len; 
d1070 2
a1071 2
	rb_ary_push(ary, rb_assoc_new(rb_tainted_str_new(*env, s-*env),
				      rb_tainted_str_new2(s+1)));
d1203 1
a1203 2
    rb_define_method(rb_cHash,"default", rb_hash_default, 0);
    rb_define_method(rb_cHash,"default=", rb_hash_set_default, 1);
@


1.1.1.2.2.23.2.4
log
@first public release of 1.1d (pre1.2) series
@
text
@d6 1
a6 1
  $Date: 1998/12/14 09:00:07 $
d1030 1
a1030 1
    volatile VALUE ary = env_keys();
d1047 1
a1047 1
    volatile VALUE ary;
d1127 1
a1127 1
    volatile VALUE ary;
d1171 1
a1171 1
    volatile VALUE ary = env_keys();
@


1.1.1.2.2.23.2.5
log
@1.1d1
@
text
@d6 1
a6 1
  $Date: 1998/12/16 07:30:31 $
d826 1
a826 1
#ifndef __MACOS__ /* no environment variables on MacOS. */
a831 1
static char **origenviron;
d841 2
a842 2
    Check_SafeStr(name);
    nam = RSTRING(name)->ptr;
a843 1
    len = strlen(nam);
d898 1
a898 1
	if (stat(path, &st) == 0 && (st.st_mode & 002)) {
d909 1
a909 1
int
d913 2
a914 2
    char *p, *pend;
    const char sep = *RUBY_LIB_SEP;
d916 3
a918 1
    if (!path) return 1;
d921 1
a921 1
    pend = strchr(path, sep);
d929 1
a929 1
	*pend = sep;
d931 2
a932 1
	    return 0;
d935 1
a935 1
	pend = strchr(p, sep);
d937 1
a937 8
    return 1;
}

static void
path_tainted_p(path)
    char *path;
{
    path_tainted = rb_path_check(path)?0:1;
d944 1
a944 1
	path_tainted_p(getenv("PATH"));
a948 126
static int
envix(nam)
char *nam;
{
    register int i, len = strlen(nam);

    for (i = 0; environ[i]; i++) {
	if (
#ifdef WIN32
	    strnicmp(environ[i],nam,len) == 0
#else
	    memcmp(environ[i],nam,len) == 0
#endif
	    && environ[i][len] == '=')
	    break;			/* memcmp must come first to avoid */
    }					/* potential SEGV's */
    return i;
}

static void
my_setenv(name, value)
    char *name;
    char *value;
{
#ifdef WIN32
#ifdef USE_WIN32_RTL_ENV
    register char *envstr;
    STRLEN namlen = strlen(name);
    STRLEN vallen;
    char *oldstr = environ[envix(name)];

    /* putenv() has totally broken semantics in both the Borland
     * and Microsoft CRTLs.  They either store the passed pointer in
     * the environment without making a copy, or make a copy and don't
     * free it. And on top of that, they dont free() old entries that
     * are being replaced/deleted.  This means the caller must
     * free any old entries somehow, or we end up with a memory
     * leak every time setenv() is called.  One might think
     * one could directly manipulate environ[], like the UNIX code
     * above, but direct changes to environ are not allowed when
     * calling putenv(), since the RTLs maintain an internal
     * *copy* of environ[]. Bad, bad, *bad* stink.
     * GSAR 97-06-07
     */

    if (!value) {
	if (!oldstr)
	    return;
	value = "";
	vallen = 0;
    }
    else
	vallen = strlen(val);
    envstr = ALLOC_N(char, namelen + vallen + 3);
    sprintf(envstr,"%s=%s",name,value);
    putenv(envstr);
    if (oldstr) free(oldstr);
#ifdef _MSC_VER
    free(envstr);		/* MSVCRT leaks without this */
#endif

#else /* !USE_WIN32_RTL_ENV */

    /* The sane way to deal with the environment.
     * Has these advantages over putenv() & co.:
     *  * enables us to store a truly empty value in the
     *    environment (like in UNIX).
     *  * we don't have to deal with RTL globals, bugs and leaks.
     *  * Much faster.
     * Why you may want to enable USE_WIN32_RTL_ENV:
     *  * environ[] and RTL functions will not reflect changes,
     *    which might be an issue if extensions want to access
     *    the env. via RTL.  This cuts both ways, since RTL will
     *    not see changes made by extensions that call the Win32
     *    functions directly, either.
     * GSAR 97-06-07
     */
    SetEnvironmentVariable(name,value);
#endif

#else  /* WIN32 */

    register int i=envix(name);		/* where does it go? */

    if (environ == origenviron) {	/* need we copy environment? */
	int j;
	int max;
	char **tmpenv;

	for (max = i; environ[max]; max++) ;
	tmpenv = ALLOC_N(char*, max+2);
	for (j=0; j<max; j++)		/* copy environment */
	    tmpenv[j] = strdup(environ[j]);
	tmpenv[max] = 0;
	environ = tmpenv;		/* tell exec where it is now */
    }
    if (!value) {
	while (environ[i]) {
	    environ[i] = environ[i+1];
	    i++;
	}
	return;
    }
    if (!environ[i]) {			/* does not exist yet */
	REALLOC_N(environ, char*, i+2);	/* just expand it a bit */
	environ[i+1] = 0;	/* make sure it's null terminated */
    }
    else {
	free(environ[i]);
    }
    environ[i] = ALLOC_N(char, strlen(name) + strlen(value) + 2);
#ifndef MSDOS
    sprintf(environ[i],"%s=%s",name,value); /* all that work just for this */
#else
    /* MS-DOS requires environment variable names to be in uppercase */
    /* [Tom Dinger, 27 August 1990: Well, it doesn't _require_ it, but
     * some utilities and applications may break because they only look
     * for upper case strings. (Fixed strupr() bug here.)]
     */
    strcpy(environ[i],name); strupr(environ[i]);
    sprintf(environ[i] + strlen(name),"=%s", value);
#endif /* MSDOS */

#endif /* WIN32 */
}

d957 1
a962 1
    Check_SafeStr(name);
d968 2
a969 2

    my_setenv(RSTRING(name)->ptr, RSTRING(value)->ptr);
d976 2
a977 3
	else {
	    path_tainted_p(RSTRING(value)->ptr);
	}
d1185 1
a1185 1
#endif  /* ifndef __MACOS__  no environment variables on MacOS. */
a1247 1
    origenviron = environ;
@
