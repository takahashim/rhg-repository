head	1.46;
access;
symbols
	v1_6_7:1.14.2.1
	v1_6_6:1.14.2.1
	v1_6_5:1.14
	v1_6_4:1.14
	v1_7_1:1.20
	v1_6_4_preview4:1.14
	v1_6_4_preview3:1.14
	v1_6_4_preview2:1.14
	v1_6_4_preview1:1.14
	v1_6_3:1.14
	ruby_m17n:1.15.0.2
	ruby_1_6:1.14.0.2
	v1_6_2:1.14
	v1_6_1:1.13
	v1_6_0:1.13
	v1_4_6:1.3.2.1
	v1_4_5:1.3.2.1
	v1_4_4:1.3.2.1
	ruby_1_4_3:1.3
	ruby1_4_3:1.3
	v1_4_3:1.3
	v1_5_0:1.5
	ruby_1_4_3_pre1:1.3
	ruby_1_4:1.3.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.11
	v1_3_6_repack:1.1.1.3.2.10
	v1_3_6:1.1.1.3.2.10
	v1_3_5:1.1.1.3.2.9
	v1_2_6repack:1.1.1.2.2.9
	v1_3_4_990625:1.1.1.3.2.9
	v1_3_4_990624:1.1.1.3.2.9
	v1_2_6:1.1.1.2.2.9
	v1_3_4_990611:1.1.1.3.2.9
	v1_3_4_990531:1.1.1.3.2.8
	v1_3_3_990518:1.1.1.3.2.7
	v1_3_3_990513:1.1.1.3.2.6
	v1_3_3_990507:1.1.1.3.2.5
	v1_2_5:1.1.1.2.2.9
	v1_2_4:1.1.1.2.2.9
	v1_3_1_990225:1.1.1.3.2.2
	v1_3_1_990224:1.1.1.3.2.1
	v1_3_1_990215:1.1.1.3.2.1
	v1_3_1_990212:1.1.1.3.2.1
	v1_3_1_990210:1.1.1.3.2.1
	v1_3_1_:1.1.1.3.2.1
	v1_3_1_990209:1.1.1.3.2.1
	v1_3_1_990205:1.1.1.3.2.1
	v1_3_1_990203:1.1.1.3.2.1
	v1_3_1_990201:1.1.1.3.2.1
	v1_3_1"_990201:1.1.1.3.2.1
	v1_3_1_990128:1.1.1.3.2.1
	v1_3_1_990127:1.1.1.3.2.1
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.9
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.9
	v1_2_1repack:1.1.1.2.2.9
	v1_2_1:1.1.1.2.2.9
	v1_2_stable:1.1.1.2.2.9
	v1_1d1:1.1.1.2.2.9.2.2
	v1_1d0:1.1.1.2.2.9.2.2
	v1_1c9_1:1.1.1.2.2.9
	v1_1c9:1.1.1.2.2.9
	v1_1c8:1.1.1.2.2.9
	v1_1c7:1.1.1.2.2.9
	v1_1c6:1.1.1.2.2.9
	v1_1d-start:1.1.1.2.2.9.2.1
	v1_1c5:1.1.1.2.2.9
	v1_1dev:1.1.1.2.2.9.0.2
	v1_1c4:1.1.1.2.2.9
	v1_1c3:1.1.1.2.2.9
	v1_1c2:1.1.1.2.2.9
	v1_1c1:1.1.1.2.2.9
	v1_1c0:1.1.1.2.2.9
	v1_1b9_31:1.1.1.2.2.8
	v1_1b9_30:1.1.1.2.2.8
	v1_1b9_28:1.1.1.2.2.8
	v1_1b9_27:1.1.1.2.2.8
	v1_1b9_26:1.1.1.2.2.8
	r1_1b9_25:1.1.1.2.2.8
	r1_1b9_24:1.1.1.2.2.8
	v1_1b9_23:1.1.1.2.2.7
	v1_1b9_22:1.1.1.2.2.7
	v1_1b9_20:1.1.1.2.2.7
	v1_1b9_18:1.1.1.2.2.6
	v1_1b9_16:1.1.1.2.2.6
	v1_1b9_15:1.1.1.2.2.6
	v1_1b9_13:1.1.1.2.2.6
	v1_1b9_12:1.1.1.2.2.6
	v1_1b9_11:1.1.1.2.2.6
	v1_1b9_08:1.1.1.2.2.6
	v1_1b9_07:1.1.1.2.2.6
	r1_1b9:1.1.1.2.2.2
	v1_1b8:1.1.1.2.2.2
	v1_1b7:1.1.1.2.2.1
	v1_1b6:1.1.1.2.2.1
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2002.09.30.11.59.37;	author matz;	state Exp;
branches;
next	1.45;

1.45
date	2002.09.03.05.20.06;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2002.08.27.08.31.06;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.42;

1.42
date	2002.07.30.10.22.32;	author michal;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.02.09.58.13;	author michal;	state Exp;
branches;
next	1.40;

1.40
date	2002.06.18.06.29.04;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.11.07.01.14;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.30.06.12.27;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.29.05.20.33;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.28.18.11.07;	author michal;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.14.06.22.26;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.02.07.50.36;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.01.09.41.49;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.24.04.54.14;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.25.08.22.05;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.11.09.18.50;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.07.05.27.01;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.05.04.19.58;	author nobu;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.08.09.21.59;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2001.10.29.06.16.00;	author usa;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.23.06.02.15;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.20.04.29.56;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.14.08.13.26;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.14.15.17.18;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.02.08.46.21;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.01.06.47.30;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.30.09.12.34;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.14.05.51.57;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.02.11.38.10;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.29.02.46.09;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.27.05.59.03;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.27.09.23.25;	author matz;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2000.08.31.05.29.48;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.24.06.21.32;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.01.09.41.27;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.10.05.44.16;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.07.08.37.45;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.29.08.05.27;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.05.04.37.10;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.12.14.06.49.51;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.12.07.09.23.27;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.12.06.09.03.56;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.09.16.09.40.32;	author matz;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.08.13.05.45.13;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.11;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.25;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.14;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.25.06.39.10;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.03.24.08.52.31;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.04.09.17.57.42;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.05.06.08.31.43;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.05.10.08.22.45;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.05.17.09.54.14;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.05.25.08.26.12;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.06.11.06.29.56;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.07.22.10.37.18;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.08.06.06.48.21;	author matz;	state Exp;
branches;
next	1.1.1.3.2.12;

1.1.1.3.2.12
date	99.08.13.05.17.41;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.02.18.01.56.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.03.12.07.22.55;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.03.13.09.04.31;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.03.16.06.37.12;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.04.02.10.03.50;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.05.13.07.26.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.06.02.10.05.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.07.17.05.12.42;	author matz;	state Exp;
branches
	1.1.1.2.2.9.2.1;
next	;

1.1.1.2.2.9.2.1
date	98.09.08.07.09.03;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9.2.2;

1.1.1.2.2.9.2.2
date	98.11.25.03.31.16;	author matz;	state Exp;
branches;
next	;

1.3.2.1
date	2000.01.17.08.24.10;	author matz;	state Exp;
branches;
next	;

1.14.2.1
date	2001.11.13.08.22.27;	author matz;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.07.11.08.24.54;	author matz;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2002.09.25.07.07.38;	author matz;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2002.10.26.15.57.24;	author knu;	state Exp;
branches;
next	;


desc
@@


1.46
log
@* range.c (range_check): need no Fixnum check.
@
text
@/**********************************************************************

  range.c -

  $Author: matz $
  $Date: 2002/09/03 05:20:06 $
  created at: Thu Aug 19 17:46:47 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto

**********************************************************************/

#include "ruby.h"

VALUE rb_cRange;
static ID id_cmp, id_succ, id_beg, id_end, id_excl;

#define EXCL(r) RTEST(rb_ivar_get((r), id_excl))
#define SET_EXCL(r,v) rb_ivar_set((r), id_excl, (v) ? Qtrue : Qfalse)

static VALUE
range_check(args)
    VALUE *args;
{
    rb_funcall(args[0], id_cmp, 1, args[1]);
    /* rb_funcall(args[0], id_succ, 0, 0); */
    return Qnil;
}

static VALUE
range_failed()
{
    rb_raise(rb_eArgError, "bad value for range");
    return Qnil;		/* dummy */
}

static void
range_init(range, beg, end, exclude_end)
    VALUE range, beg, end;
    int exclude_end;
{
    VALUE args[2];

    args[0] = beg;
    args[1] = end;
    
    if (!FIXNUM_P(beg) || !FIXNUM_P(end)) {
	rb_rescue(range_check, (VALUE)args, range_failed, 0);
    }

    SET_EXCL(range, exclude_end);
    rb_ivar_set(range, id_beg, beg);
    rb_ivar_set(range, id_end, end);
}

VALUE
rb_range_new(beg, end, exclude_end)
    VALUE beg, end;
    int exclude_end;
{
    VALUE range = rb_obj_alloc(rb_cRange);

    range_init(range, beg, end, exclude_end);
    return range;
}

static VALUE
range_initialize(argc, argv, range)
    int argc;
    VALUE *argv;
    VALUE range;
{
    VALUE beg, end, flags;
    
    rb_scan_args(argc, argv, "21", &beg, &end, &flags);
    /* Ranges are immutable, so that they should be initialized only once. */
    if (rb_ivar_defined(range, id_beg)) {
	rb_name_error(rb_intern("initialize"), "`initialize' called twice");
    }
    range_init(range, beg, end, RTEST(flags));
    return Qnil;
}

static VALUE
range_exclude_end_p(range)
    VALUE range;
{
    return EXCL(range) ? Qtrue : Qfalse;
}

static VALUE
range_eq(range, obj)
    VALUE range, obj;
{
    if (range == obj) return Qtrue;
    if (!rb_obj_is_instance_of(obj, rb_obj_class(range)))
	return Qfalse;

    if (!rb_equal(rb_ivar_get(range, id_beg), rb_ivar_get(obj, id_beg)))
	return Qfalse;
    if (!rb_equal(rb_ivar_get(range, id_end), rb_ivar_get(obj, id_end)))
	return Qfalse;

    if (EXCL(range) != EXCL(obj)) return Qfalse;

    return Qtrue;
}

static int
r_eq(a, b)
    VALUE a, b;
{
    if (a == b) return Qtrue;

    if (rb_funcall(a, id_cmp, 1, b) == INT2FIX(0))
	return Qtrue;
    return Qfalse;
}

static int
r_lt(a, b)
    VALUE a, b;
{
    VALUE r = rb_funcall(a, id_cmp, 1, b);

    if (rb_cmpint(r) < 0) return Qtrue;
    return Qfalse;
}

static int
r_le(a, b)
    VALUE a, b;
{
    VALUE r = rb_funcall(a, id_cmp, 1, b);

    if (rb_cmpint(r) <= 0) return Qtrue;
    return Qfalse;
}

static int
r_gt(a,b)
    VALUE a, b;
{
    VALUE r = rb_funcall(a, id_cmp, 1, b);

    if (rb_cmpint(r) > 0) return Qtrue;
    return Qfalse;
}

static VALUE
range_eql(range, obj)
    VALUE range, obj;
{
    if (range == obj) return Qtrue;
    if (!rb_obj_is_instance_of(obj, rb_obj_class(range)))
	return Qfalse;

    if (!rb_eql(rb_ivar_get(range, id_beg), rb_ivar_get(obj, id_beg)))
	return Qfalse;
    if (!rb_eql(rb_ivar_get(range, id_end), rb_ivar_get(obj, id_end)))
	return Qfalse;

    if (EXCL(range) != EXCL(obj)) return Qfalse;

    return Qtrue;
}

static VALUE
range_hash(range)
    VALUE range;
{
    long hash = EXCL(range);
    VALUE v;

    v = rb_hash(rb_ivar_get(range, id_beg));
    hash ^= v << 1;
    v = rb_hash(rb_ivar_get(range, id_end));
    hash ^= v << 9;
    hash ^= EXCL(range) << 24;

    return LONG2FIX(hash);
}

static VALUE
str_step(args)
    VALUE *args;
{
    return rb_str_upto(args[0], args[1], EXCL(args[2]));
}

static VALUE
step_i(i, iter)
    VALUE i;
    long *iter;
{
    iter[0]--;
    if (iter[0] == 0) {
	rb_yield(i);
	iter[0] = iter[1];
    }
    return Qnil;
}

static void
range_each_func(range, func, v, e, arg)
    VALUE range;
    void (*func) _((VALUE, void*));
    VALUE v, e;
    void *arg;
{
    if (EXCL(range)) {
	while (r_lt(v, e)) {
	    (*func)(v, arg);
	    v = rb_funcall(v, id_succ, 0, 0);
	}
    }
    else {
	while (r_le(v, e)) {
	    (*func)(v, arg);
	    v = rb_funcall(v, id_succ, 0, 0);
	}
    }
}

static VALUE
range_step(argc, argv, range)
    int argc;
    VALUE *argv;
    VALUE range;
{
    VALUE b, e, step;
    long unit;

    b = rb_ivar_get(range, id_beg);
    e = rb_ivar_get(range, id_end);
    if (rb_scan_args(argc, argv, "01", &step) == 0) {
	step = INT2FIX(1);
    }

    unit = NUM2LONG(step);
    if (unit <= 0) {
	rb_raise(rb_eArgError, "step can't be <= 0");
    }
    if (FIXNUM_P(b) && FIXNUM_P(e)) { /* fixnums are special */
	long end = FIX2LONG(e);
	long i;

	if (!EXCL(range)) end += 1;
	for (i=FIX2LONG(b); i<end; i+=unit) {
	    rb_yield(LONG2NUM(i));
	}
    }
    else if (rb_obj_is_kind_of(b, rb_cNumeric)) {
	ID c = rb_intern(EXCL(range) ? "<" : "<=");

	while (RTEST(rb_funcall(b, c, 1, e))) {
	    rb_yield(b);
	    b = rb_funcall(b, '+', 1, step);
	}
    }
    else if (TYPE(b) == T_STRING) {
	VALUE args[5];
	long iter[2];

	args[0] = b; args[1] = e; args[2] = range;
	iter[0] = 1; iter[1] = unit;
	rb_iterate((VALUE(*)_((VALUE)))str_step, (VALUE)args, step_i, (VALUE)iter);
    }
    else {
	long args[2];

	if (!rb_respond_to(b, id_succ)) {
	    rb_raise(rb_eTypeError, "cannot iterate from %s",
		     rb_class2name(CLASS_OF(b)));
	}
	
	args[0] = 1;
	args[1] = unit;
	range_each_func(range, step_i, b, e, args);
    }
    return range;
}

static void
each_i(v, arg)
    VALUE v;
    void *arg;
{
    rb_yield(v);
}

static VALUE
range_each(range)
    VALUE range;
{
    VALUE beg, end;

    beg = rb_ivar_get(range, id_beg);
    end = rb_ivar_get(range, id_end);

    if (!rb_respond_to(beg, id_succ)) {
	rb_raise(rb_eTypeError, "cannot iterate from %s",
		 rb_class2name(CLASS_OF(beg)));
    }
    if (TYPE(beg) == T_STRING) {
	VALUE args[5];
	long iter[2];

	args[0] = beg; args[1] = end; args[2] = range;
	iter[0] = 1; iter[1] = 1;
	rb_iterate((VALUE(*)_((VALUE)))str_step, (VALUE)args, step_i, (VALUE)iter);
    }
    else {
	range_each_func(range, each_i, beg, end, 0);
    }
    return range;
}

static VALUE
range_first(range)
    VALUE range;
{
    return rb_ivar_get(range, id_beg);
}

static VALUE
range_last(range)
    VALUE range;
{
    return rb_ivar_get(range, id_end);
}

VALUE
rb_range_beg_len(range, begp, lenp, len, err)
    VALUE range;
    long *begp, *lenp;
    long len;
    int err;
{
    long beg, end, b, e;

    if (!rb_obj_is_kind_of(range, rb_cRange)) return Qfalse;

    beg = b = NUM2LONG(rb_ivar_get(range, id_beg));
    end = e = NUM2LONG(rb_ivar_get(range, id_end));

    if (beg < 0) {
	beg += len;
	if (beg < 0) goto out_of_range;
    }
    if (err == 0 || err == 2) {
	if (beg > len) goto out_of_range;
	if (end > len || (!EXCL(range) && end == len))
	    end = len;
    }
    if (end < 0) {
	end += len;
	if (end < 0) {
	    if (beg == 0 && end == -1 && !EXCL(range)) {
		len = 0;
		goto length_set;
	    }
	    goto out_of_range;
	}
    }
    len = end - beg;
    if (!EXCL(range)) len++;	/* include end point */
    if (len < 0) goto out_of_range;

  length_set:
    *begp = beg;
    *lenp = len;

    return Qtrue;

  out_of_range:
    if (err) {
	rb_raise(rb_eRangeError, "%ld..%s%ld out of range",
		 b, EXCL(range)? "." : "", e);
    }
    return Qnil;
}

static VALUE
range_min(range)
    VALUE range;

{
    VALUE b = rb_ivar_get(range, id_beg);
    VALUE e = rb_ivar_get(range, id_end);

    if (r_le(b, e)) return b;
    return e;
}

static VALUE
range_max(range)
    VALUE range;
{
    VALUE b = rb_ivar_get(range, id_beg);
    VALUE e = rb_ivar_get(range, id_end);

    if (r_gt(b, e)) return b;
    return e;
}

static VALUE
range_to_s(range)
    VALUE range;
{
    VALUE str, str2;

    str = rb_obj_as_string(rb_ivar_get(range, id_beg));
    str2 = rb_obj_as_string(rb_ivar_get(range, id_end));
    str = rb_str_dup(str);
    rb_str_cat(str, "...", EXCL(range)?3:2);
    rb_str_append(str, str2);
    OBJ_INFECT(str, str2);

    return str;
}

static VALUE
range_inspect(range)
    VALUE range;
{
    VALUE str, str2;

    str = rb_inspect(rb_ivar_get(range, id_beg));
    str2 = rb_inspect(rb_ivar_get(range, id_end));
    str = rb_str_dup(str);
    rb_str_cat(str, "...", EXCL(range)?3:2);
    rb_str_append(str, str2);
    OBJ_INFECT(str, str2);

    return str;
}

static void
member_i(v, args)
    VALUE v;
    VALUE *args;
{
    if (rb_equal(v, args[0])) {
	args[1] = Qtrue;
    }
}

static VALUE
range_member(range, val)
    VALUE range, val;
{
    VALUE beg, end;
    VALUE args[2];

    beg = rb_ivar_get(range, id_beg);
    end = rb_ivar_get(range, id_end);

    if (!rb_respond_to(beg, id_succ)) {
	rb_raise(rb_eTypeError, "cannot iterate from %s",
		 rb_class2name(CLASS_OF(beg)));
    }
    args[0] = val;
    args[1] = Qfalse;
    range_each_func(range, member_i, beg, end, args);
    return args[1];
}

static VALUE
range_include(range, val)
    VALUE range, val;
{
    VALUE beg, end;

    beg = rb_ivar_get(range, id_beg);
    end = rb_ivar_get(range, id_end);
    if (r_gt(beg, val)) return Qfalse;
    if (EXCL(range)) {
	if (r_lt(val, end)) return Qtrue;
    }
    else {
	if (r_le(val, end)) return Qtrue;
    }
    return Qfalse;
}

void
Init_Range()
{
    rb_cRange = rb_define_class("Range", rb_cObject);
    rb_include_module(rb_cRange, rb_mEnumerable);
    rb_define_method(rb_cRange, "initialize", range_initialize, -1);
    rb_define_method(rb_cRange, "==", range_eq, 1);
    rb_define_method(rb_cRange, "===", range_include, 1);
    rb_define_method(rb_cRange, "eql?", range_eql, 1);
    rb_define_method(rb_cRange, "hash", range_hash, 0);
    rb_define_method(rb_cRange, "each", range_each, 0);
    rb_define_method(rb_cRange, "step", range_step, -1);
    rb_define_method(rb_cRange, "first", range_first, 0);
    rb_define_method(rb_cRange, "last", range_last, 0);
    rb_define_method(rb_cRange, "begin", range_first, 0);
    rb_define_method(rb_cRange, "end", range_last, 0);
    rb_define_method(rb_cRange, "min", range_min, 0);
    rb_define_method(rb_cRange, "max", range_max, 0);
    rb_define_method(rb_cRange, "to_s", range_to_s, 0);
    rb_define_method(rb_cRange, "inspect", range_inspect, 0);
    rb_define_alias(rb_cRange,  "to_ary", "to_a");

    rb_define_method(rb_cRange, "exclude_end?", range_exclude_end_p, 0);

    rb_define_method(rb_cRange, "member?", range_member, 1);
    rb_define_method(rb_cRange, "include?", range_include, 1);

    id_cmp = rb_intern("<=>");
    id_succ = rb_intern("succ");
    id_beg = rb_intern("begin");
    id_end = rb_intern("end");
    id_excl = rb_intern("excl");
}
@


1.45
log
@	* variable.c (rb_copy_generic_ivar): remove old generic instance
	  variable table if it existes.

	* class.c (rb_make_metaclass): metaclass of a metaclass is a
	  metaclass itself.
@
text
@d6 1
a6 1
  $Date: 2002/08/27 08:31:06 $
d25 2
a26 4
    if (!FIXNUM_P(args[0]) && !rb_obj_is_kind_of(args[0], rb_cNumeric)) {
	rb_funcall(args[0], id_cmp, 1, args[1]);
	/* rb_funcall(args[0], id_succ, 0, 0); */
    }
@


1.44
log
@* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.

* class.c (rb_mod_dup): need to preserve metaclass and flags.

* object.c (rb_cstr_to_dbl): had a buffer overrun.

* marshal.c (w_class): integrate singleton check into a funciton
  to follow DRY principle.

* marshal.c (w_uclass): should check singleton method.

* object.c (rb_obj_dup): dmark and dfree functions must be match
  for T_DATA type.

* object.c (rb_obj_dup): class of the duped object must be match
  to the class of the original.

* re.c (rb_reg_quote): do not escape \t, \f, \r, \n, for they are
  not regular expression metacharacters.

* time.c (time_s_alloc): use time_free instead of free (null check,
  also serves for type mark).

* time.c (time_s_at): check dfree function too.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/21 15:47:54 $
d98 2
a99 1
    if (!rb_obj_is_kind_of(obj, rb_obj_class(range))) return Qfalse;
d157 2
a158 1
    if (!rb_obj_is_kind_of(obj, rb_obj_class(obj))) return Qfalse;
@


1.43
log
@*.c: Int vs Long cleanup
@
text
@d6 1
a6 1
  $Date: 2002/07/30 10:22:32 $
d98 1
a98 1
    if (!rb_obj_is_kind_of(obj, rb_cRange)) return Qfalse;
d156 1
a156 1
    if (!rb_obj_is_kind_of(obj, rb_cRange)) return Qfalse;
@


1.42
log
@range.c: small-cleanup [ruby-core:276]
@
text
@d6 1
a6 1
  $Date: 2002/07/02 09:58:13 $
d250 1
a250 1
	    rb_yield(INT2NUM(i));
@


1.41
log
@object.c: rb_Integer reformat, nil#to_f added to rb_define_method.
parse.y: Clean unused vars.
range.c: ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/18 06:29:04 $
d19 1
a19 1
#define SET_EXCL(r,v) rb_ivar_set((r), id_excl, (v)?Qtrue:Qfalse)
d46 3
a48 1
    args[0] = beg; args[1] = end;
d90 1
a90 1
    return EXCL(range)?Qtrue:Qfalse;
d181 1
a181 1
    return INT2FIX(hash);
d208 1
a212 1
	    if (r_eq(v, e)) break;
a219 1
	    if (r_eq(v, e)) break;
d276 1
@


1.40
log
@* parse.y (yylex): obsolete '?<whitespace>'; use '?\s', '?\n',
  etc, instead.

* parse.y (yylex): no here document after a dot.

* parse.y (yylex): should have set lex_state after '`'.

* parse.y (yylex): should have set lex_state properly after
  tOP_ASGN.

* bignum.c (rb_big2dbl): return canonical HUGE_VAL for infinity.
@
text
@d6 1
a6 1
  $Date: 2002/06/11 07:01:14 $
d387 2
a388 5
    VALUE b, e, step;
    long unit;

    b = rb_ivar_get(range, id_beg);
    e = rb_ivar_get(range, id_end);
d398 2
a399 5
    VALUE b, e, step;
    long unit;

    b = rb_ivar_get(range, id_beg);
    e = rb_ivar_get(range, id_end);
@


1.39
log
@* eval.c (rb_eval): ruby_frame->last_func may be null, if it's
  called outside of a method.

* parse.y (arg): use INT2NUM, not INT2FIX for tUMINUS.

* parse.y (arg): unnecessary negative tPOW treatment.

* parse.y (tokadd_escape): wrong backslash escapement.

* parse.y (stmt,arg): too much void value check.

* parse.y (stmt,arg): need to check void value on rules which does
  not use node_assign().

* ext/socket/socket.c (ipaddr): need not to taint hostnames.

* range.c (range_include): should be based on "<=>", whereas
  member? still is based on "each".

* range.c (range_min,range_max): redefine methods based on "<=>".
@
text
@d6 1
a6 1
  $Date: 2002/05/30 06:12:27 $
d498 1
a498 1
    rb_define_method(rb_cRange, "===", range_member, 1);
@


1.38
log
@* range.c (range_step): iteration done using "+" if elements are
  Numeric.  Otherwise using "succ".

* range.c (range_each): iteration done using "succ".  If the
  elements does not respond to "succ", raise TypeError.  As a
  result, all Enumerable methods, e.g. collect, require elements
  to respond to "succ'.

* range.c (range_member): comparison done using "each", if
  elements are non-Numeric or no-"succ" objects.  Otherwise
  compare using "<=>".

* range.c (Init_Range): remove "size" and "length".
@
text
@d6 1
a6 1
  $Date: 2002/05/29 05:20:33 $
d40 2
a41 2
range_init(obj, beg, end, exclude_end)
    VALUE obj, beg, end;
d51 3
a53 3
    SET_EXCL(obj, exclude_end);
    rb_ivar_set(obj, id_beg, beg);
    rb_ivar_set(obj, id_end, end);
d61 1
a61 1
    VALUE obj = rb_obj_alloc(rb_cRange);
d63 2
a64 2
    range_init(obj, beg, end, exclude_end);
    return obj;
d68 1
a68 1
range_initialize(argc, argv, obj)
d71 1
a71 1
    VALUE obj;
d77 1
a77 1
    if (rb_ivar_defined(obj, id_beg)) {
d80 1
a80 1
    range_init(obj, beg, end, RTEST(flags));
d318 2
a319 2
range_first(obj)
    VALUE obj;
d321 1
a321 1
    return rb_ivar_get(obj, id_beg);
d325 2
a326 2
range_last(obj)
    VALUE obj;
d328 1
a328 1
    return rb_ivar_get(obj, id_end);
d383 29
d463 3
a465 9
    if (rb_obj_is_kind_of(beg, rb_cNumeric) || !rb_respond_to(beg, id_succ)) {
	if (r_gt(beg, val)) return Qfalse;
	if (EXCL(range)) {
	    if (r_lt(val, end)) return Qtrue;
	}
	else {
	    if (r_le(val, end)) return Qtrue;
	}
	return Qfalse;
d473 18
d507 2
d516 1
a516 1
    rb_define_method(rb_cRange, "include?", range_member, 1);
@


1.37
log
@* parse.y: yyparse #defines moved from intern.h

* ruby.c (proc_options): access prefixed "ruby_yydebug".

* applied modifies to pacify some of gcc -Wall warnings.

* parse.y (arg): no more ugly hack for "**", so that "-2**2" to be
  parsed as "(-2)**2", whereas "- 2**2" or "-(2)**2" to be parsed
  as "-(2**2)".

* parse.y (yylex): '-2' to be literal fixnum. [new]

* time.c (time_succ): new method for Range support.

* time.c (time_arg): nil test against v[6] (usec).
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/05/28 18:11:07 $
a149 52
r_eqq_str_i(i, data)
    VALUE i;
    VALUE *data;
{
    if (rb_str_cmp(i, data[0]) == 0) {
	data[1] = Qtrue;
	rb_iter_break();
    }
    return Qnil;
}

static VALUE
range_eqq(range, obj)
    VALUE range, obj;
{
    VALUE beg, end;

    beg = rb_ivar_get(range, id_beg);
    end = rb_ivar_get(range, id_end);

    if (FIXNUM_P(beg) && FIXNUM_P(obj) && FIXNUM_P(end)) {
	if (FIX2LONG(beg) <= FIX2LONG(obj)) {
	    if (EXCL(range)) {
		if (FIX2LONG(obj) < FIX2LONG(end)) return Qtrue;
	    }
	    else {
		if (FIX2LONG(obj) <= FIX2LONG(end)) return Qtrue;
	    }
	}
	return Qfalse;
    }
    else if (TYPE(beg) == T_STRING &&
	     TYPE(obj) == T_STRING &&
	     TYPE(end) == T_STRING) {
	VALUE data[2];

	data[0] = obj; data[1] = Qfalse;
	rb_iterate(rb_each, range, r_eqq_str_i, (VALUE)data);
	return data[1];
    }
    else if (r_le(beg, obj)) {
	if (EXCL(range)) {
	    if (r_lt(obj, end)) return Qtrue;
	}
	else {
	    if (r_le(obj, end)) return Qtrue;
	}
    }
    return Qfalse;
}

static VALUE
d167 2
a168 2
range_hash(range, obj)
    VALUE range, obj;
d177 1
d183 1
a183 1
r_step_str(args)
d190 1
a190 1
r_step_str_i(i, iter)
d202 22
d231 1
d239 4
d244 1
a244 1
	long end = FIX2LONG(e), s = NUM2LONG(step);
d246 1
a246 3
	if (s <= 0) {
	    rb_raise(rb_eArgError, "step can't be <= 0");
	}
d248 1
a248 1
	for (i=FIX2LONG(b); i<end; i+=s) {
d253 1
a253 3
	b = rb_Integer(b);
	e = rb_Integer(e);
	step = rb_Integer(step);
d255 1
a255 5
	if (RTEST(rb_funcall(step, rb_intern("<="), 1, INT2FIX(0)))) {
	    rb_raise(rb_eArgError, "step can't be <= 0");
	}
	if (!EXCL(range)) e = rb_funcall(e, '+', 1, INT2FIX(1));
	while (RTEST(rb_funcall(b, '<', 1, e))) {
d265 2
a266 6
	iter[0] = 1; iter[1] = NUM2LONG(step);
	if (iter[1] <= 0) {
	    rb_raise(rb_eArgError, "step can't be <= 0");
	}
	rb_iterate((VALUE(*)_((VALUE)))r_step_str, (VALUE)args, r_step_str_i,
		   (VALUE)iter);
d268 2
a269 4
    else {			/* generic each */
	VALUE v = b;
	long lim = NUM2LONG(step);
	long i;
d271 7
a277 19
	if (lim <= 0) {
	    rb_raise(rb_eArgError, "step can't be <= 0");
	}
	if (EXCL(range)) {
	    while (r_lt(v, e)) {
		if (r_eq(v, e)) break;
		rb_yield(v);
		for (i=0; i<lim; i++) 
		    v = rb_funcall(v, id_succ, 0, 0);
	    }
	}
	else {
	    while (r_le(v, e)) {
		rb_yield(v);
		if (r_eq(v, e)) break;
		for (i=0; i<lim; i++) 
		    v = rb_funcall(v, id_succ, 0, 0);
	    }
	}
d282 8
d294 21
a314 1
    return range_step(0, NULL, range);
d321 1
a321 4
    VALUE b;

    b = rb_ivar_get(obj, id_beg);
    return b;
d328 1
a328 4
    VALUE e;

    e = rb_ivar_get(obj, id_end);
    return e;
d414 4
a417 4
static VALUE
length_i(i, length)
    VALUE i;
    int *length;
d419 3
a421 12
    (*length)++;
    return Qnil;
}

VALUE
rb_length_by_each(obj)
    VALUE obj;
{
    int length = 0;

    rb_iterate(rb_each, obj, length_i, (VALUE)&length);
    return INT2FIX(length);
d425 2
a426 2
range_length(range)
    VALUE range;
d429 1
a429 1
    long size;
d434 2
a435 4
    if (r_gt(beg, end)) {
	return INT2FIX(0);
    }
    if (FIXNUM_P(beg) && FIXNUM_P(end)) {
d437 1
a437 1
	    return INT2NUM(NUM2LONG(end) - NUM2LONG(beg));
d440 1
a440 1
	    return INT2NUM(NUM2LONG(end) - NUM2LONG(beg) + 1);
d442 1
d444 4
a447 31
    if (!rb_obj_is_kind_of(beg, rb_cInteger)) {
	return rb_length_by_each(range);
    }
    size = rb_funcall(end, '-', 1, beg);
    if (!EXCL(range)) {
	size = rb_funcall(size, '+', 1, INT2FIX(1));
    }
    if (TYPE(size) == T_FLOAT) {
	size = rb_funcall(size, rb_intern("floor"), 0);
    }

    return size;
}

static VALUE
range_member(range, val)
    VALUE range, val;
{
    VALUE beg, end;

    beg = rb_ivar_get(range, id_beg);
    end = rb_ivar_get(range, id_end);

    if (r_gt(beg, val)) return Qfalse;
    if (EXCL(range)) {
	if (r_lt(val, end)) return Qtrue;
    }
    else {
	if (r_le(val, end)) return Qtrue;
    }
    return Qfalse;
d457 1
a457 1
    rb_define_method(rb_cRange, "===", range_eqq, 1);
a471 2
    rb_define_method(rb_cRange, "length", range_length, 0);
    rb_define_method(rb_cRange, "size", range_length, 0);
@


1.36
log
@	* array.c: fixed format string for 'long' args (%d -> %ld).

	* class.c: ditto.

	* eval.c: ditto.

	* numeric.c: ditto.

	* pack.c: ditto.

	* parse.y: ditto.

	* range.c: ditto.

	* string.c: ditto.

	* util.c: ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/14 06:22:26 $
a24 1
    rb_funcall(args[0], id_cmp, 1, args[1]);
d26 2
a27 1
	rb_funcall(args[0], id_succ, 0, 0);
@


1.35
log
@* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* numeric.c (flo_to_s): default format precision to be "%.16g".

* util.c (ruby_strtod): use own strtod(3) implementation to avoid
  locale hell.  Due to this change "0xff".to_f no longer returns 255.0

* eval.c (avalue_to_yvalue): new function to distinguish yvalue
  (no-arg == Qundef) from svalue (no-arg == Qnil).

* eval.c (rb_yield_0): use avalue_to_yvalue().

* eval.c (assign): warn if val == Qundef where it means rhs is
  void (e.g. yield without value or call without argument).

* parse.y (value_expr): need not to warn for WHILE and UNTIL,
  since they can have return value (via valued break).
@
text
@d6 1
a6 1
  $Date: 2002/05/02 07:50:36 $
d404 1
a404 1
	rb_raise(rb_eRangeError, "%d..%s%d out of range",
@


1.34
log
@* error.c: use HAVE_DECL_SYS_NERR instead of platform names.
@
text
@d6 1
a6 1
  $Date: 2002/05/01 09:41:49 $
d268 1
a268 1
	long beg, end = FIX2LONG(e), s = NUM2LONG(step);
@


1.33
log
@* numeric.c (num_step): better iteration condition for float
  values;  suggested by Masahiro TANAKA <masa@@ir.isas.ac.jp>.

* range.c (range_step): step (for Range#step method) <= 0 makes no
  sence, thus ArgError will be raised.

* range.c (range_each): Range#each method is special case for
  Range#step(1)

* file.c (rb_find_file): load must be done from an abolute path if
  $SAFE >= 4.

* enum.c (enum_partition): new method. [new]

* re.c (rb_reg_s_quote): quote whitespaces for /x cases.
@
text
@d6 1
a6 1
  $Date: 2002/04/24 04:54:14 $
d268 1
a268 1
	long beg = FIX2LONG(b), end = FIX2LONG(e), s = NUM2LONG(step);
d273 3
a275 11
	if ((end - beg) < 0) {
	    if (!EXCL(range)) end -= 1;
	    for (i=beg; i>end; i-=s) {
		rb_yield(LONG2NUM(i));
	    }
	}
	else {
	    if (!EXCL(range)) end += 1;
	    for (i=beg; i<end; i+=s) {
		rb_yield(INT2NUM(i));
	    }
a278 1
	VALUE diff;
d286 4
a289 14
	diff = rb_funcall(e, '-', 1, b);
	if (RTEST(rb_funcall(diff, '<', 1, INT2FIX(0)))) {
	    if (!EXCL(range)) e = rb_funcall(e, '-', 1, INT2FIX(1));
	    while (RTEST(rb_funcall(b, '>', 1, e))) {
		rb_yield(b);
		b = rb_funcall(b, '-', 1, step);
	    }
	}
	else {
	    if (!EXCL(range)) e = rb_funcall(e, '+', 1, INT2FIX(1));
	    while (RTEST(rb_funcall(b, '<', 1, e))) {
		rb_yield(b);
		b = rb_funcall(b, '+', 1, step);
	    }
d298 3
d306 1
a306 1
	long lim = NUM2INT(step);
d309 3
@


1.32
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d6 1
a6 1
  $Date: 2002/01/25 08:22:05 $
d78 1
a78 1
	rb_name_error(rb_intern("initialized"), "`initialize' called twice");
a233 53
range_each(range)
    VALUE range;
{
    VALUE b, e;

    b = rb_ivar_get(range, id_beg);
    e = rb_ivar_get(range, id_end);

    if (FIXNUM_P(b) && FIXNUM_P(e)) { /* fixnums are special */
	long end = FIX2LONG(e);
	long i;

	if (!EXCL(range)) end += 1;
	for (i=FIX2LONG(b); i<end; i++) {
	    rb_yield(INT2NUM(i));
	}
    }
    else if (TYPE(b) == T_STRING) {
	rb_str_upto(b, e, EXCL(range));
    }
    else if (rb_obj_is_kind_of(b, rb_cNumeric)) {
	b = rb_Integer(b);
	e = rb_Integer(e);

	if (!EXCL(range)) e = rb_funcall(e, '+', 1, INT2FIX(1));
	while (RTEST(rb_funcall(b, '<', 1, e))) {
	    rb_yield(b);
	    b = rb_funcall(b, '+', 1, INT2FIX(1));
	}
    }
    else {			/* generic each */
	VALUE v = b;

	if (EXCL(range)) {
	    while (r_lt(v, e)) {
		if (r_eq(v, e)) break;
		rb_yield(v);
		v = rb_funcall(v, id_succ, 0, 0);
	    }
	}
	else {
	    while (r_le(v, e)) {
		rb_yield(v);
		if (r_eq(v, e)) break;
		v = rb_funcall(v, id_succ, 0, 0);
	    }
	}
    }

    return range;
}

static VALUE
d263 3
a265 1
    rb_scan_args(argc, argv, "01", &step);
d268 16
a283 6
	long end = FIX2LONG(e);
	long i, s = (argc == 0) ? 1 : NUM2LONG(step);

	if (!EXCL(range)) end += 1;
	for (i=FIX2LONG(b); i<end; i+=s) {
	    rb_yield(INT2NUM(i));
d287 1
d292 17
a308 4
	if (!EXCL(range)) e = rb_funcall(e, '+', 1, INT2FIX(1));
	while (RTEST(rb_funcall(b, '<', 1, e))) {
	    rb_yield(b);
	    b = rb_funcall(b, '+', 1, step);
d342 2
d345 5
a349 1
    return range;
@


1.31
log
@* class.c (rb_include_module): detect cyclic module inclusion.

* eval.c (rb_thread_cleanup): need not to free thread stacks at
  process termination.

* array.c (rb_ary_fetch): use the block to get the default value
  if the block is given.

* eval.c (rb_thread_schedule): should check time only if BOTH
  WAIT_SELECT and WAIT_TIME.

* eval.c (umethod_bind): should update rklass field.

* hash.c (rb_hash_update): if a block is given, yields [key,
  value1, value2] to the block to resolve conflict.

* string.c (rb_str_split_m): no need to consider KANJI
characters, if the length of separator is 1 (byte).
@
text
@d6 1
a6 1
  $Date: 2002/01/11 09:18:50 $
a111 2
    VALUE r;

@


1.30
log
@* re.c (match_select): should propagate taintness.

* hash.c (rb_hash_set_default): Hash#default= should return the
  new value.

* string.c (rb_str_to_i): accepts optional base argument. [new]

* numeric.c (rb_fix2str): should not handle negative fixnum values
  int32 via calling sprintf() directly.
@
text
@d6 1
a6 1
  $Date: 2002/01/07 05:27:01 $
d441 1
a441 1
		 b, EXCL(range)?".":"", e);
@


1.29
log
@* string.c (rb_str_new2): NULL pointer check added.

* class.c (rb_define_module_under): should locate predefined
  module using rb_const_defined_at().
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/01/05 04:19:58 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
@


1.28
log
@* range.c (range_member): beginning check was
  wrong. [ruby-talk:30252]
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/11/08 09:21:59 $
d109 1
a109 1
r_eq(a,b)
d122 1
a122 1
r_lt(a,b)
d127 1
a127 1
    if (NUM2LONG(r) < 0) return Qtrue;
d132 1
a132 1
r_le(a,b)
d137 1
a137 1
    if (NUM2LONG(r) <= 0) return Qtrue;
d147 1
a147 1
    if (NUM2LONG(r) > 0) return Qtrue;
@


1.27
log
@* file.c (path_check_1): forgot to initialize 'p'.

* mkconfig.rb: use String#dump to generate Ruby string literal.

* range.c (range_eql): should override 'eql?'

* array.c (rb_ary_hash): should override 'hash' too.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/10/29 06:16:00 $
d541 1
a541 1
    if (r_lt(beg, val)) return Qtrue;
@


1.26
log
@	* intern.h (rb_protect_inspect): follow the change of array.c.

	* eval.c (rb_exec_end_proc): follow the change of rb_protect().

	* eval.c (method_proc, umethod_proc, rb_catch): cast the first
	  parameter of rb_iterate() to avoid VC++ warning.

	* range.c (range_step): ditto.

	* ext/sdbm/init.c (fsdbm_update, fsdbm_replace): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/08/23 06:02:15 $
d204 32
d559 2
@


1.25
log
@* eval.c (is_defined): should not dump core for "defined?(())".

* eval.c (umethod_bind): recv can be an instance of descender of
  oklass if oklass is a Module.

* hash.c (rb_hash_equal): check identiry equality first.

* file.c (group_member): should check real gid only.

* file.c (eaccess): do not cache euid, since effective euid may be
  changed via Process.euid=().

* file.c (eaccess): return -1 unless every specified access mode
  is permitted.

* eval.c (rb_eval): while/until returns the value which is given
  to break.

* parse.y (value_expr): using while/until/class/def as an
  expression is now gives a warning, not an error.

* range.c (range_eqq): should compare strings based on magical
  increment (using String#upto), not dictionary order.

* enum.c (enum_sort_by): new method for Schewartzian transformed
  stable sort.

* variable.c (mod_av_set): detect constant overriding for built-in
  classes/modules.
@
text
@d6 1
a6 1
  $Date: 2001/08/20 04:29:56 $
d314 2
a315 1
	rb_iterate(r_step_str, (VALUE)args, r_step_str_i, (VALUE)iter);
@


1.24
log
@* range.c (range_step): 'iter' here should be an array.

* marshal.c (w_object): should retrieve __member__ data from
  non-singleton class.

* variable.c (rb_cvar_get): class variable override check added.

* variable.c (rb_cvar_set): ditto

* variable.c (rb_cvar_declare): ditto.

* parse.y (parse_regx): handle backslash escaping of delimiter here.
@
text
@d6 1
a6 1
  $Date: 2001/08/14 08:13:26 $
d152 12
d182 9
@


1.23
log
@* range.c (range_step): new method.

* string.c (rb_str_cmp): remove needless conditional.

* string.c (rb_str_lstrip_bang) `return Qnil' was missing.
@
text
@d6 1
a6 1
  $Date: 2001/07/14 15:17:18 $
d289 1
a289 1
	long *iter;
@


1.22
log
@* regex.c (re_search): should consider reverse search.

* dir.c (dir_s_chdir): warn only when invoked from multiple
  threads or block is not given.

* object.c (rb_convert_type): should use rb_rescue(), not rb_rescue2().

* range.c (range_init): ditto.

* object.c (rb_obj_dup): should free generic_ivar if original owns
  them.

* string.c (rb_str_each_line): should propagate taint mark.

* ext/nkf/nkf.c (rb_nkf_kconv): ditto.

* eval.c (rb_f_require): revamp for simpler implementation.

* file.c (rb_find_file_noext): use String object, instead of
  passing char* around.

* file.c (rb_find_file): ditto.

* dln.c (dln_load): should use NSLINKMODULE_OPTION_BINDNOW.

* ruby.c (load_file): local variables 'c' remain uninitialized on
  xflag.

* regex.c (re_match): prefetched escaped character too early.

* eval.c (rb_call0): add argument check for attr_readers.
@
text
@d6 1
a6 1
  $Date: 2001/07/02 08:46:21 $
d236 86
d506 1
@


1.21
log
@* error.c (exc_exception): clone the receiver exception instead of
  creating brand new exception object of the receiver.

* eval.c (rb_eval_string_wrap): extend new ruby_top_self, not
  original self.

* eval.c (rb_eval_cmd): respect ruby_wrapper if set.

* eval.c (eval): do not update ruby_class unless scope is not
  provided.

* eval.c (eval): preserve wrapper information.

* eval.c (proc_invoke): ditto.

* eval.c (block_pass): ditto.

* parse.y (void_expr): too much warnings for void context
  (e.g. foo[1] that can be mere Proc call).

* error.c (rb_name_error): new function to raise NameError with
  name attribute set.

* eval.c (rb_f_missing): set name and args in the exception
  object. [new]

* error.c (name_name): NameError#name - new method.

* error.c (nometh_args): NoMethodError#args - new method.

* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.

* dir.c (isdelim): space, tab, and newline are no longer
  delimiters for glob patterns.

* eval.c (svalue_to_avalue): new conversion scheme between single
  value and array values.

* eval.c (avalue_to_svalue): ditto.

* eval.c (rb_eval): REXPAND now uses avalue_to_svalue(), return
  and yield too.

* eval.c (rb_yield_0): use avalue_to_svalue().

* eval.c (proc_invoke): Proc#call gives avaules, whereas
  Proc#yield gives mvalues.

* eval.c (bmcall): convert given value (svalue) to avalue.
@
text
@d6 1
a6 1
  $Date: 2001/06/01 06:47:30 $
d48 1
a48 1
	rb_rescue2(range_check, (VALUE)args, range_failed, 0);
@


1.20
log
@* parse.y (yylex): fixed 'print CGI::bar() {}, "\n"' syntax
  breakage, adding new lex_state status.  sigh. [new]

* file.c (rb_file_s_unlink): should not allow if $SAFE >= 2.

* range.c (Init_Range): define "to_ary".
@
text
@d6 1
a6 1
  $Date: 2001/05/30 09:12:34 $
d48 1
a48 2
	rb_rescue2(range_check, (VALUE)args, range_failed, 0,
		   rb_eStandardError, rb_eNameError, 0);
d78 1
a78 1
	rb_raise(rb_eNameError, "`initialize' called twice");
@


1.19
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d6 1
a6 1
  $Date: 2001/02/14 05:51:57 $
d427 1
@


1.18
log
@* dir.c (dir_s_glob): supprt backslash escape of metacharacters
  and delimiters.

* dir.c (remove_backslases): remove backslashes from path before
  calling stat(2).

* dir.c (dir_s_glob): call rb_yield directly (via push_pattern) if
  block is given to the method.

* dir.c (push_pattern): do not call rb_ary_push; yield directly.

* eval.c (blk_copy_prev): reduced ALLOC_N too much.

* eval.c (frame_dup): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:38:10 $
d16 1
a16 1
static ID id_cmp, id_beg, id_end, id_excl;
d26 3
d109 43
d172 1
a172 1
    else if (RTEST(rb_funcall(beg, rb_intern("<="), 1, obj))) {
d174 1
a174 2
	    if (RTEST(rb_funcall(end, rb_intern(">"), 1, obj)))
		return Qtrue;
d177 1
a177 2
	    if (RTEST(rb_funcall(end, rb_intern(">="), 1, obj)))
		return Qtrue;
a215 1
	ID succ = rb_intern("succ");
d218 2
a219 2
	    while (RTEST(rb_funcall(v, '<', 1, e))) {
		if (rb_equal(v, e)) break;
d221 1
a221 1
		v = rb_funcall(v, succ, 0, 0);
d225 1
a225 3
	    ID le = rb_intern("<=");

	    while (RTEST(rb_funcall(v, le, 1, e))) {
d227 2
a228 2
		if (rb_equal(v, e)) break;
		v = rb_funcall(v, succ, 0, 0);
d368 1
a368 1
    if (RTEST(rb_funcall(beg, '>', 1, end))) {
d393 19
d432 2
d436 1
@


1.17
log
@* array.c (rb_ary_sort_bang): returns self, even if its length is
  less than 2.

* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2000/12/29 02:46:09 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.16
log
@thread_critical bug reported by Dave - matz
@
text
@d6 1
a6 1
  $Date: 2000/12/27 05:59:03 $
d71 1
a71 1
    VALUE beg, end, flag;
d73 1
a73 1
    rb_scan_args(argc, argv, "21", &beg, &end, &flag);
d78 1
a78 1
    range_init(obj, beg, end, RTEST(flag));
@


1.15
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/27 09:23:25 $
d93 1
@


1.14
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/31 05:29:48 $
d343 3
@


1.14.2.1
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.

* mkconfig.rb: use String#dump to generate Ruby string literal.

* range.c (range_eql): should override 'eql?'
@
text
@d6 1
a6 1
  $Date: 2000/11/27 09:23:25 $
a138 32
range_eql(range, obj)
    VALUE range, obj;
{
    if (range == obj) return Qtrue;
    if (!rb_obj_is_kind_of(obj, rb_cRange)) return Qfalse;

    if (!rb_eql(rb_ivar_get(range, id_beg), rb_ivar_get(obj, id_beg)))
	return Qfalse;
    if (!rb_eql(rb_ivar_get(range, id_end), rb_ivar_get(obj, id_end)))
	return Qfalse;

    if (EXCL(range) != EXCL(obj)) return Qfalse;

    return Qtrue;
}

static VALUE
range_hash(range, obj)
    VALUE range, obj;
{
    long hash = EXCL(range);
    VALUE v;

    v = rb_hash(rb_ivar_get(range, id_beg));
    hash ^= v << 1;
    v = rb_hash(rb_ivar_get(range, id_end));
    hash ^= v << 9;

    return INT2FIX(hash);
}

static VALUE
a355 2
    rb_define_method(rb_cRange, "eql?", range_eql, 1);
    rb_define_method(rb_cRange, "hash", range_hash, 0);
@


1.14.2.2
log
@* string.c (rb_str_slice_bang): if there's no corresponding
  substring, slice! should return nil without exception.

* string.c (rb_str_split_m): accept separator value nil as well.

* class.c (include_class_new): module may be T_ICLASS; retrieve
  original module information.

* re.c (rb_reg_expr_str): need to process backslashes properly.

* parse.y (yylex): no here document after a dot.

* parse.y (yylex): should have set lex_state properly after '`'.

* parse.y (yylex): should have set lex_state properly after
  tOP_ASGN.

* bignum.c (rb_big2dbl): return canonical HUGE_VAL for infinity.
@
text
@d6 1
a6 1
  $Date: 2001/11/13 08:22:27 $
d19 1
a19 1
#define SET_EXCL(r,v) rb_ivar_set((r), id_excl, (v) ? Qtrue : Qfalse)
d86 1
a86 1
    return EXCL(range) ? Qtrue : Qfalse;
d292 1
a292 1
		 b, EXCL(range) ? "." : "", e);
d306 1
a306 1
    rb_str_cat(str, "...", EXCL(range) ? 3 : 2);
d322 1
a322 1
    rb_str_cat(str, "...", EXCL(range) ? 3 : 2);
@


1.14.2.3
log
@* eval.c (ruby_run): should set toplevel visibility again here.

* eval.c (rb_eval): should not rely on ruby_class == rb_cObject
  check.   Besides allow implicit publicity for attribute set
  methods.

* parse.y (primary): need not to check class_nest, just set
  whether method is an attrset or not.

* string.c (rb_str_each_line): p might be at the top of the
  string.

* variable.c (rb_path2class): should not use rb_eval_string().

* parse.y (str_extend): expression substitution can contain string
  terminator again.

* parse.y (yylex): the warning message "invalid
  character syntax" was never issued.

* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/07/11 08:24:54 $
d93 1
a93 1
    if (!rb_obj_is_kind_of(obj, rb_obj_class(range))) return Qfalse;
d143 1
a143 1
    if (!rb_obj_is_kind_of(obj, rb_obj_class(range))) return Qfalse;
@


1.14.2.4
log
@* array.c, class.c, eval.c, file.c, gc.c, node.h, numeric.c,
  object.c, parse.y, range.c, re.c, string.c, struct.c, util.c,
  ext/socket/socket.c: merge from 1.7: treat long values as long
  instead of int.
@
text
@d6 1
a6 1
  $Date: 2002/09/25 07:07:38 $
d291 1
a291 1
	rb_raise(rb_eRangeError, "%ld..%s%ld out of range",
@


1.13
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/24 06:21:32 $
d16 1
a16 1
static ID id_cmp, id_beg, id_end;
d18 2
a19 2
#define EXCL(r) FL_TEST((r), FL_USER1)
#define SET_EXCL(r) FL_SET((r), FL_USER1)
d49 1
a49 4
    if (exclude_end) {
	SET_EXCL(obj);
    }

d90 16
d354 1
d372 1
@


1.12
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:27 $
d45 2
a46 1
	rb_rescue(range_check, (VALUE)args, range_failed, 0);
@


1.11
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:44:16 $
d101 1
a101 1
	if (NUM2LONG(beg) <= NUM2LONG(obj)) {
d103 1
a103 1
		if (NUM2LONG(obj) < NUM2LONG(end)) return Qtrue;
d106 1
a106 1
		if (NUM2LONG(obj) <= NUM2LONG(end)) return Qtrue;
@


1.10
log
@2000-04-10
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/03/07 08:37:45 $
d11 1
a11 1
************************************************/
@


1.9
log
@2000-03-07
@
text
@d6 1
a6 1
  $Date: 2000/02/29 08:05:27 $
d259 1
d261 2
a262 1
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d275 1
d277 2
a278 1
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
@


1.8
log
@2000-02-29
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:37:10 $
d245 1
a245 1
	rb_raise(rb_eIndexError, "%d..%s%d out of range",
@


1.7
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:49:51 $
d36 3
a38 3
static VALUE
range_new(klass, beg, end, exclude_end)
    VALUE klass, beg, end;
a40 1
    VALUE obj;
a47 1
    obj = rb_obj_alloc(klass);
a53 2

    return obj;
d61 4
a64 1
    return range_new(rb_cRange, beg, end, exclude_end);
d68 1
a68 1
range_s_new(argc, argv, klass)
d71 1
a71 1
    VALUE klass;
d76 6
a81 1
    return range_new(klass, beg, end, RTEST(flag));
d335 1
a335 1
    rb_define_singleton_method(rb_cRange, "new", range_s_new, -1);
@


1.6
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/12/07 09:23:27 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
@


1.5
log
@991207
@
text
@d6 1
a6 1
  $Date: 1999/12/06 09:03:56 $
d141 10
d299 1
a299 1
    VALUE size;
d315 1
a315 1
    if (!rb_obj_is_kind_of(beg, rb_cNumeric)) {
@


1.4
log
@19991206
@
text
@d6 1
a6 1
  $Date: 1999/09/16 09:40:32 $
d266 19
d306 1
a306 1
	return rb_enum_length(range);
@


1.3
log
@1.4.1
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:13 $
d33 1
@


1.3.2.1
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 1999/09/16 09:40:32 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:17:41 $
d137 4
a140 1
    else {			      /* generic each */
a141 1
	ID le = EXCL(range)?'<':rb_intern("<=");
d144 15
a158 3
	while (rb_funcall(v, le, 1, e)) {
	    rb_yield(v);
	    v = rb_funcall(v, succ, 0, 0);
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1996/12/25 09:30:12 $
d9 1
a9 1
  Copyright (C) 1993-1996 Yukihiro Matsumoto
d15 2
a16 3
VALUE mComparable;
static VALUE cRange;
extern VALUE cNumeric;
d18 2
a19 1
static ID upto;
d22 17
a38 2
range_s_new(class, first, last)
    VALUE class, first, last;
d41 1
d43 3
a45 7
    if (!(FIXNUM_P(first) && FIXNUM_P(last))
	&& (TYPE(first) != TYPE(last)
	    || CLASS_OF(first) != CLASS_OF(last)
	    || !rb_respond_to(first, upto))
	&& !(obj_is_kind_of(first, cNumeric)
	     && obj_is_kind_of(last, cNumeric))) {
	ArgError("bad value for range");
d48 4
a51 1
    obj = obj_alloc(class);
d53 2
a54 2
    rb_iv_set(obj, "first", first);
    rb_iv_set(obj, "last", last);
d60 22
a81 2
range_new(first, last)
    VALUE first, last;
d83 1
a83 1
    return range_s_new(cRange, first, last);
d87 2
a88 2
range_eqq(rng, obj)
    VALUE rng, obj;
d90 1
a90 1
    VALUE first, last;
d92 2
a93 2
    first = rb_iv_get(rng, "first");
    last = rb_iv_get(rng, "last");
d95 8
a102 3
    if (FIXNUM_P(first) && FIXNUM_P(obj) && FIXNUM_P(last)) {
	if (FIX2INT(first) <= FIX2INT(obj) && FIX2INT(obj) <= FIX2INT(last)) {
	    return TRUE;
d104 1
a104 1
	return FALSE;
d106 8
a113 4
    else {
	if (RTEST(rb_funcall(first, rb_intern("<="), 1, obj)) &&
	    RTEST(rb_funcall(last, rb_intern(">="), 1, obj))) {
	    return TRUE;
a114 1
	return FALSE;
d116 1
a118 5
struct upto_data {
    VALUE first;
    VALUE last;
};

d120 2
a121 9
range_upto(data)
    struct upto_data *data;
{
    return rb_funcall(data->first, upto, 1, data->last);
}

static VALUE
range_each(obj)
    VALUE obj;
d125 2
a126 2
    b = rb_iv_get(obj, "first");
    e = rb_iv_get(obj, "last");
d128 8
a135 2
    if (FIXNUM_P(b)) {		/* fixnum is a special case(for performance) */
	num_upto(b, e);
d137 9
a145 7
    else {
	struct upto_data data;

	data.first = b;
	data.last = e;

	rb_iterate(range_upto, &data, rb_yield, 0);
d148 1
a148 1
    return Qnil;
d157 1
a157 1
    b = rb_iv_get(obj, "first");
d167 1
a167 1
    e = rb_iv_get(obj, "last");
d172 1
a172 1
range_beg_end(range, begp, endp)
d174 3
a176 1
    int *begp, *endp;
d178 3
a180 1
    VALUE first, last;
d182 2
a183 1
    if (!obj_is_kind_of(range, cRange)) return FALSE;
d185 35
a219 3
    first = rb_iv_get(range, "first"); *begp = NUM2INT(first);
    last = rb_iv_get(range, "last");   *endp = NUM2INT(last);
    return TRUE;
d228 4
a231 4
    str = obj_as_string(rb_iv_get(range, "first"));
    str2 = obj_as_string(rb_iv_get(range, "last"));
    str_cat(str, "..", 2);
    str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d242 4
a245 4
    str = rb_inspect(rb_iv_get(range, "first"));
    str2 = rb_inspect(rb_iv_get(range, "last"));
    str_cat(str, "..", 2);
    str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d251 2
a252 2
range_length(rng)
    VALUE rng;
d254 1
a254 1
    VALUE first, last;
d257 2
a258 2
    first = rb_iv_get(rng, "first");
    last = rb_iv_get(rng, "last");
d260 17
a276 2
    if (!obj_is_kind_of(first, cNumeric)) {
	return enum_length(rng);
a277 2
    size = rb_funcall(last, '-', 1, first);
    size = rb_funcall(size, '+', 1, INT2FIX(1));
a281 2
extern VALUE mEnumerable;

d285 20
a304 14
    cRange = rb_define_class("Range", cObject);
    rb_include_module(cRange, mEnumerable);
    rb_define_singleton_method(cRange, "new", range_s_new, 2);
    rb_define_method(cRange, "===", range_eqq, 1);
    rb_define_method(cRange, "each", range_each, 0);
    rb_define_method(cRange, "first", range_first, 0);
    rb_define_method(cRange, "last", range_last, 0);
    rb_define_method(cRange, "to_s", range_to_s, 0);
    rb_define_method(cRange, "inspect", range_inspect, 0);

    rb_define_method(cRange, "length", range_length, 0);
    rb_define_method(cRange, "size", range_length, 0);

    upto = rb_intern("upto");
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d15 1
a171 2

VALUE enum_length();
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/11/25 03:31:16 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
d15 2
a16 3
VALUE rb_cRange;
static ID id_upto, id_cmp;
static ID id_beg, id_end;
d18 1
a18 13
static VALUE
range_check(args)
    VALUE *args;
{
    rb_funcall(args[0], id_cmp, 1, args[1]);
    return Qnil;
}

static VALUE
range_failed()
{
    rb_raise(rb_eArgError, "bad value for range");
}
d21 2
a22 2
range_s_new(klass, beg, end)
    VALUE klass, beg, end;
d26 7
a32 5
    if (!FIXNUM_P(beg) || !FIXNUM_P(end)) {
	VALUE args[2];

	args[0] = beg; args[1] = end;
	rb_rescue(range_check, (VALUE)args, range_failed, 0);
d35 1
a35 1
    obj = rb_obj_alloc(klass);
d37 2
a38 3
    rb_ivar_set(obj, id_beg, beg);
    rb_ivar_set(obj, id_end, end);
    rb_obj_call_init(obj);
d44 2
a45 2
rb_range_new(beg, end)
    VALUE beg, end;
d47 1
a47 1
    return range_s_new(rb_cRange, beg, end);
d54 1
a54 1
    VALUE beg, end;
d56 2
a57 2
    beg = rb_ivar_get(rng, id_beg);
    end = rb_ivar_get(rng, id_end);
d59 3
a61 3
    if (FIXNUM_P(beg) && FIXNUM_P(obj) && FIXNUM_P(end)) {
	if (FIX2INT(beg) <= FIX2INT(obj) && FIX2INT(obj) <= FIX2INT(end)) {
	    return Qtrue;
d63 1
a63 1
	return Qfalse;
d66 3
a68 3
	if (RTEST(rb_funcall(beg, rb_intern("<="), 1, obj)) &&
	    RTEST(rb_funcall(end, rb_intern(">="), 1, obj))) {
	    return Qtrue;
d70 1
a70 1
	return Qfalse;
d75 2
a76 2
    VALUE beg;
    VALUE end;
d83 1
a83 1
    return rb_funcall(data->beg, id_upto, 1, data->end);
d92 2
a93 2
    b = rb_ivar_get(obj, id_beg);
    e = rb_ivar_get(obj, id_end);
d96 1
a96 1
	rb_fix_upto(b, e);
d101 2
a102 2
	data.beg = b;
	data.end = e;
d104 1
a104 1
	rb_iterate(range_upto, (VALUE)&data, rb_yield, 0);
d116 1
a116 1
    b = rb_ivar_get(obj, id_beg);
d126 1
a126 1
    e = rb_ivar_get(obj, id_end);
d131 1
a131 1
rb_range_beg_end(range, begp, endp)
d135 1
a135 1
    VALUE beg, end;
d137 1
a137 1
    if (!rb_obj_is_kind_of(range, rb_cRange)) return Qfalse;
d139 3
a141 3
    beg = rb_ivar_get(range, id_beg); *begp = NUM2INT(beg);
    end = rb_ivar_get(range, id_end);   *endp = NUM2INT(end);
    return Qtrue;
d150 4
a153 4
    str = rb_obj_as_string(rb_ivar_get(range, id_beg));
    str2 = rb_obj_as_string(rb_ivar_get(range, id_end));
    rb_str_cat(str, "..", 2);
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d164 4
a167 4
    str = rb_inspect(rb_ivar_get(range, id_beg));
    str2 = rb_inspect(rb_ivar_get(range, id_end));
    rb_str_cat(str, "..", 2);
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d172 2
d178 1
a178 1
    VALUE beg, end;
d181 2
a182 2
    beg = rb_ivar_get(rng, id_beg);
    end = rb_ivar_get(rng, id_end);
d184 2
a185 5
    if (RTEST(rb_funcall(beg, '>', 1, end))) {
	return INT2FIX(0);
    }
    if (!rb_obj_is_kind_of(beg, rb_cNumeric)) {
	return rb_enum_length(rng);
d187 1
a187 1
    size = rb_funcall(end, '-', 1, beg);
d193 2
d198 14
a211 19
    rb_cRange = rb_define_class("Range", rb_cObject);
    rb_include_module(rb_cRange, rb_mEnumerable);
    rb_define_singleton_method(rb_cRange, "new", range_s_new, 2);
    rb_define_method(rb_cRange, "===", range_eqq, 1);
    rb_define_method(rb_cRange, "each", range_each, 0);
    rb_define_method(rb_cRange, "first", range_first, 0);
    rb_define_method(rb_cRange, "last", range_last, 0);
    rb_define_method(rb_cRange, "begin", range_first, 0);
    rb_define_method(rb_cRange, "end", range_last, 0);
    rb_define_method(rb_cRange, "to_s", range_to_s, 0);
    rb_define_method(rb_cRange, "inspect", range_inspect, 0);

    rb_define_method(rb_cRange, "length", range_length, 0);
    rb_define_method(rb_cRange, "size", range_length, 0);

    id_upto = rb_intern("upto");
    id_cmp = rb_intern("<=>");
    id_beg = rb_intern("begin");
    id_end = rb_intern("end");
@


1.1.1.3.2.1
log
@990126
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:25 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
@


1.1.1.3.2.2
log
@990225
@
text
@d6 1
a6 1
  $Date: 1999/01/26 10:08:14 $
a37 1
    VALUE args[2];
a38 1
    args[0] = beg; args[1] = end;
d40 3
d50 1
a50 1
    rb_obj_call_init(obj, 2, args);
@


1.1.1.3.2.3
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/25 06:39:10 $
d16 2
a17 4
static ID id_cmp, id_beg, id_end;

#define EXCL(r) FL_TEST((r), FL_USER1)
#define SET_EXCL(r) FL_SET((r), FL_USER1)
d34 1
a34 1
range_new(klass, beg, end, exclude_end)
a35 1
    int exclude_end;
a45 3
    if (exclude_end) {
	SET_EXCL(obj);
    }
d55 1
a55 1
rb_range_new(beg, end, exclude_end)
a56 21
    int exclude_end;
{
    return range_new(rb_cRange, beg, end, exclude_end);
}

static VALUE
range_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE beg, end, flag, range;
    
    rb_scan_args(argc, argv, "21", &beg, &end, &flag);
    if (argc == 2) flag == Qtrue;
    return range_new(klass, beg, end, RTEST(flag));
}

static VALUE
range_exclude_end_p(range)
    VALUE range;
d58 1
a58 1
    return EXCL(range)?Qtrue:Qfalse;;
d62 2
a63 2
range_eqq(range, obj)
    VALUE range, obj;
d67 2
a68 2
    beg = rb_ivar_get(range, id_beg);
    end = rb_ivar_get(range, id_end);
d71 2
a72 7
	if (FIX2INT(beg) <= FIX2INT(obj)) {
	    if (EXCL(range)) {
		if (FIX2INT(obj) <= FIX2INT(end)) return Qtrue;
	    }
	    else {
		if (FIX2INT(obj) < FIX2INT(end)) return Qtrue;
	    }
d76 4
a79 9
    else if (RTEST(rb_funcall(beg, rb_intern("<="), 1, obj))) {
	if (EXCL(range)) {
	    if (RTEST(rb_funcall(end, rb_intern(">="), 1, obj)))
		return Qtrue;
	}
	else {
	    if (RTEST(rb_funcall(end, rb_intern(">"), 1, obj)))
		return Qtrue;
	    if (FIX2INT(obj) < FIX2INT(end)) return Qtrue;
d81 1
d83 12
a94 1
    return Qfalse;
d98 2
a99 2
range_each(range)
    VALUE range;
d103 2
a104 2
    b = rb_ivar_get(range, id_beg);
    e = rb_ivar_get(range, id_end);
d106 2
a107 8
    if (FIXNUM_P(b) && FIXNUM_P(e)) { /* fixnums are special */
	long end = FIX2LONG(e);
	long i;

	if (!EXCL(range)) end += 1;
	for (i=FIX2LONG(b); i<end; i++) {
	    rb_yield(INT2FIX(i));
	}
d109 7
a115 12
    else if (TYPE(b) == T_STRING) {
	rb_str_upto(b, e, EXCL(range));
    }
    else {			      /* generic each */
	VALUE v = b;
	ID le = EXCL(range)?'<':rb_intern("<=");
	ID succ = rb_intern("succ");

	while (rb_funcall(v, le, 1, e)) {
	    rb_yield(v);
	    v = rb_funcall(v, succ, 0, 0);
	}
d142 1
a142 1
rb_range_beg_len(range, begp, lenp, len, err)
d144 1
a144 2
    int *begp, *lenp;
    int len, err;
d146 1
a146 1
    int beg, end, b, e;
d150 2
a151 26
    beg = b = NUM2INT(rb_ivar_get(range, id_beg));
    end = e = NUM2INT(rb_ivar_get(range, id_end));

    if (beg < 0) {
	beg += len;
	if (beg < 0) goto out_of_range;
    }
    if (err == 2 && beg > len) goto out_of_range;
    if (end < 0) {
	end += len;
	if (end < 0) {
	    if (err == 1 && e == -1 && !EXCL(range)) {
		len = 0;
		goto length_set;
	    }
	    goto out_of_range;
	}
    }
    len = end - beg;
    if (!EXCL(range)) len++;	/* include end point */
    if (len < 0) goto out_of_range;

  length_set:
    *begp = beg;
    *lenp = len;

a152 7

  out_of_range:
    if (err) {
	rb_raise(rb_eIndexError, "%d..%s%d out of range",
		 b, EXCL(range)?".":"", e);
    }
    return Qnil;
d163 1
a163 1
    rb_str_cat(str, "...", EXCL(range)?3:2);
d177 1
a177 1
    rb_str_cat(str, "...", EXCL(range)?3:2);
d184 2
a185 2
range_length(range)
    VALUE range;
d190 2
a191 2
    beg = rb_ivar_get(range, id_beg);
    end = rb_ivar_get(range, id_end);
a195 8
    if (FIXNUM_P(beg) && FIXNUM_P(end)) {
	if (EXCL(range)) {
	    return INT2FIX(FIX2INT(end) - FIX2INT(beg));
	}
	else {
	    return INT2FIX(FIX2INT(end) - FIX2INT(beg) + 1);
	}
    }
d197 1
a197 1
	return rb_enum_length(range);
d200 1
a200 3
    if (!EXCL(range)) {
	size = rb_funcall(size, '+', 1, INT2FIX(1));
    }
d210 1
a210 1
    rb_define_singleton_method(rb_cRange, "new", range_s_new, -1);
a219 2
    rb_define_method(rb_cRange, "exclude_end?", range_exclude_end_p, 0);

d223 1
@


1.1.1.3.2.4
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:31 $
d194 1
a194 5
    if (err == 2) {
	if (beg > len) goto out_of_range;
	if (end > len || (!EXCL(range) && end == len))
	    goto out_of_range;
    }
@


1.1.1.3.2.5
log
@small fixes
@
text
@d6 1
a6 1
  $Date: 1999/04/09 17:57:42 $
d77 1
a77 1
    if (argc == 2) flag = Qfalse;
@


1.1.1.3.2.6
log
@regexp,range,squeeze
@
text
@d6 1
a6 1
  $Date: 1999/05/06 08:31:43 $
d77 1
d85 1
a85 1
    return EXCL(range)?Qtrue:Qfalse;
d100 1
a100 1
		if (FIX2INT(obj) < FIX2INT(end)) return Qtrue;
d103 1
a103 1
		if (FIX2INT(obj) <= FIX2INT(end)) return Qtrue;
d110 1
a110 1
	    if (RTEST(rb_funcall(end, rb_intern(">"), 1, obj)))
d114 1
a114 1
	    if (RTEST(rb_funcall(end, rb_intern(">="), 1, obj)))
d116 1
@


1.1.1.3.2.7
log
@arity/strict yield
@
text
@d6 1
a6 1
  $Date: 1999/05/10 08:22:45 $
d192 1
a192 1
    if (err == 0 || err == 2) {
d200 1
a200 1
	    if (beg == 0 && end == -1 && !EXCL(range)) {
@


1.1.1.3.2.8
log
@regexp null pattern
@
text
@d6 1
a6 1
  $Date: 1999/05/17 09:54:14 $
d74 1
a74 1
    VALUE beg, end, flag;
d97 1
a97 1
	if (NUM2LONG(beg) <= NUM2LONG(obj)) {
d99 1
a99 1
		if (NUM2LONG(obj) < NUM2LONG(end)) return Qtrue;
d102 1
a102 1
		if (NUM2LONG(obj) <= NUM2LONG(end)) return Qtrue;
d135 1
a135 1
	    rb_yield(INT2NUM(i));
d178 2
a179 3
    long *begp, *lenp;
    long len;
    int err;
d181 1
a181 1
    long beg, end, b, e;
d185 2
a186 2
    beg = b = NUM2LONG(rb_ivar_get(range, id_beg));
    end = e = NUM2LONG(rb_ivar_get(range, id_end));
d268 1
a268 1
	    return INT2NUM(NUM2LONG(end) - NUM2LONG(beg));
d271 1
a271 1
	    return INT2NUM(NUM2LONG(end) - NUM2LONG(beg) + 1);
@


1.1.1.3.2.9
log
@990611
@
text
@d6 1
a6 1
  $Date: 1999/05/25 08:26:12 $
d55 1
@


1.1.1.3.2.10
log
@backtrace may be Qnil
@
text
@d6 1
a6 1
  $Date: 1999/06/11 06:29:56 $
d151 1
a151 1
    return range;
@


1.1.1.3.2.11
log
@990806
@
text
@d6 1
a6 1
  $Date: 1999/07/22 10:37:18 $
d136 3
@


1.1.1.3.2.12
log
@pre 1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/06 06:48:21 $
d192 1
a192 1
	    end = len;
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:04:57 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:47 $
d21 2
a22 2
range_s_new(klass, first, last)
    VALUE klass, first, last;
d35 1
a35 1
    obj = obj_alloc(klass);
@


1.1.1.2.2.3
log
@range check
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:41 $
a20 18
range_check(args)
    VALUE *args;
{
    VALUE v = rb_funcall(args[0], rb_intern("<="), 1, args[1]);

    if (!RTEST(v)) {
	Fail("");		/* no ascending values */
    }
    return Qnil;
}

static VALUE
range_failed()
{
    ArgError("bad value for range");
}

static VALUE
a24 1
    VALUE args[2];
d26 8
a33 2
    args[0] = first; args[1] = last;
    rb_rescue(range_check, args, range_failed, 0);
@


1.1.1.2.2.4
log
@1.1b9_02
@
text
@d6 1
a6 1
  $Date: 1998/03/12 07:22:55 $
d24 5
a28 1
    rb_funcall(args[0], rb_intern("<=>"), 1, args[1]);
@


1.1.1.2.2.5
log
@1.1b9_03 pre2
@
text
@d6 1
a6 1
  $Date: 1998/03/13 09:04:31 $
a192 3
    if (RTEST(rb_funcall(first, '>', 1, last))) {
	return INT2FIX(0);
    }
@


1.1.1.2.2.6
log
@call initialize
@
text
@d6 1
a6 1
  $Date: 1998/03/16 06:37:12 $
a47 1
    obj_call_init(obj);
@


1.1.1.2.2.7
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:03:50 $
d42 1
a42 1
    rb_rescue(range_check, (VALUE)args, range_failed, 0);
d114 1
a114 1
	rb_iterate(range_upto, (VALUE)&data, rb_yield, 0);
@


1.1.1.2.2.8
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:28 $
d16 2
d205 2
@


1.1.1.2.2.9
log
@1.1c0
@
text
@d6 1
a6 1
  $Date: 1998/06/02 10:05:29 $
d16 1
a16 2
static ID id_upto, id_cmp;
static ID id_beg, id_end;
d22 1
a22 1
    rb_funcall(args[0], id_cmp, 1, args[1]);
d44 2
a45 2
    rb_ivar_set(obj, id_beg, first);
    rb_ivar_set(obj, id_end, last);
d64 2
a65 2
    first = rb_ivar_get(rng, id_beg);
    last = rb_ivar_get(rng, id_end);
d91 1
a91 1
    return rb_funcall(data->first, id_upto, 1, data->last);
d100 2
a101 2
    b = rb_ivar_get(obj, id_beg);
    e = rb_ivar_get(obj, id_end);
d124 1
a124 1
    b = rb_ivar_get(obj, id_beg);
d134 1
a134 1
    e = rb_ivar_get(obj, id_end);
d147 2
a148 2
    first = rb_ivar_get(range, id_beg); *begp = NUM2INT(first);
    last = rb_ivar_get(range, id_end);   *endp = NUM2INT(last);
d158 2
a159 2
    str = obj_as_string(rb_ivar_get(range, id_beg));
    str2 = obj_as_string(rb_ivar_get(range, id_end));
d172 2
a173 2
    str = rb_inspect(rb_ivar_get(range, id_beg));
    str2 = rb_inspect(rb_ivar_get(range, id_end));
d189 2
a190 2
    first = rb_ivar_get(rng, id_beg);
    last = rb_ivar_get(rng, id_end);
d220 1
a220 4
    id_upto = rb_intern("upto");
    id_cmp = rb_intern("<=>");
    id_beg = rb_intern("first");
    id_end = rb_intern("last");
@


1.1.1.2.2.9.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/07/17 05:12:42 $
d15 1
a15 1
VALUE rb_cRange;
d30 1
a30 1
    rb_raise(rb_eArgError, "bad value for range");
d43 1
a43 1
    obj = rb_obj_alloc(klass);
d47 1
a47 1
    rb_obj_call_init(obj);
d53 1
a53 1
rb_range_new(first, last)
d56 1
a56 1
    return range_s_new(rb_cRange, first, last);
d70 1
a70 1
	    return Qtrue;
d72 1
a72 1
	return Qfalse;
d77 1
a77 1
	    return Qtrue;
d79 1
a79 1
	return Qfalse;
d105 1
a105 1
	rb_fix_upto(b, e);
d140 1
a140 1
rb_range_beg_end(range, begp, endp)
d146 1
a146 1
    if (!rb_obj_is_kind_of(range, rb_cRange)) return Qfalse;
d150 1
a150 1
    return Qtrue;
d159 4
a162 4
    str = rb_obj_as_string(rb_ivar_get(range, id_beg));
    str2 = rb_obj_as_string(rb_ivar_get(range, id_end));
    rb_str_cat(str, "..", 2);
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d175 2
a176 2
    rb_str_cat(str, "..", 2);
    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d181 2
d196 2
a197 2
    if (!rb_obj_is_kind_of(first, rb_cNumeric)) {
	return rb_enum_length(rng);
d208 9
a216 9
    rb_cRange = rb_define_class("Range", rb_cObject);
    rb_include_module(rb_cRange, rb_mEnumerable);
    rb_define_singleton_method(rb_cRange, "new", range_s_new, 2);
    rb_define_method(rb_cRange, "===", range_eqq, 1);
    rb_define_method(rb_cRange, "each", range_each, 0);
    rb_define_method(rb_cRange, "first", range_first, 0);
    rb_define_method(rb_cRange, "last", range_last, 0);
    rb_define_method(rb_cRange, "to_s", range_to_s, 0);
    rb_define_method(rb_cRange, "inspect", range_inspect, 0);
d218 2
a219 2
    rb_define_method(rb_cRange, "length", range_length, 0);
    rb_define_method(rb_cRange, "size", range_length, 0);
@


1.1.1.2.2.9.2.2
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/09/08 07:09:03 $
d34 2
a35 2
range_s_new(klass, beg, end)
    VALUE klass, beg, end;
d38 1
d40 2
a41 6
    if (!FIXNUM_P(beg) || !FIXNUM_P(end)) {
	VALUE args[2];

	args[0] = beg; args[1] = end;
	rb_rescue(range_check, (VALUE)args, range_failed, 0);
    }
d45 2
a46 2
    rb_ivar_set(obj, id_beg, beg);
    rb_ivar_set(obj, id_end, end);
d53 2
a54 2
rb_range_new(beg, end)
    VALUE beg, end;
d56 1
a56 1
    return range_s_new(rb_cRange, beg, end);
d63 1
a63 1
    VALUE beg, end;
d65 2
a66 2
    beg = rb_ivar_get(rng, id_beg);
    end = rb_ivar_get(rng, id_end);
d68 2
a69 2
    if (FIXNUM_P(beg) && FIXNUM_P(obj) && FIXNUM_P(end)) {
	if (FIX2INT(beg) <= FIX2INT(obj) && FIX2INT(obj) <= FIX2INT(end)) {
d75 2
a76 2
	if (RTEST(rb_funcall(beg, rb_intern("<="), 1, obj)) &&
	    RTEST(rb_funcall(end, rb_intern(">="), 1, obj))) {
d84 2
a85 2
    VALUE beg;
    VALUE end;
d92 1
a92 1
    return rb_funcall(data->beg, id_upto, 1, data->end);
d110 2
a111 2
	data.beg = b;
	data.end = e;
d144 1
a144 1
    VALUE beg, end;
d148 2
a149 2
    beg = rb_ivar_get(range, id_beg); *begp = NUM2INT(beg);
    end = rb_ivar_get(range, id_end);   *endp = NUM2INT(end);
d185 1
a185 1
    VALUE beg, end;
d188 2
a189 2
    beg = rb_ivar_get(rng, id_beg);
    end = rb_ivar_get(rng, id_end);
d191 1
a191 1
    if (RTEST(rb_funcall(beg, '>', 1, end))) {
d194 1
a194 1
    if (!rb_obj_is_kind_of(beg, rb_cNumeric)) {
d197 1
a197 1
    size = rb_funcall(end, '-', 1, beg);
a212 2
    rb_define_method(rb_cRange, "begin", range_first, 0);
    rb_define_method(rb_cRange, "end", range_last, 0);
d221 2
a222 2
    id_beg = rb_intern("begin");
    id_end = rb_intern("end");
@
