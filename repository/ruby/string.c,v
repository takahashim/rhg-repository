head	1.123;
access;
symbols
	v1_6_7:1.50.2.25
	v1_6_6:1.50.2.23
	v1_6_5:1.50.2.14
	v1_6_4:1.50.2.9
	v1_7_1:1.67
	v1_6_4_preview4:1.50.2.9
	v1_6_4_preview3:1.50.2.8
	v1_6_4_preview2:1.50.2.8
	v1_6_4_preview1:1.50.2.8
	v1_6_3:1.50.2.7
	ruby_m17n:1.52.0.2
	ruby_1_6:1.50.0.2
	v1_6_2:1.50
	v1_6_1:1.45
	v1_6_0:1.42
	v1_4_6:1.4.2.16
	v1_4_5:1.4.2.14
	v1_4_4:1.4.2.11
	ruby_1_4_3:1.4.2.4
	ruby1_4_3:1.4.2.4
	v1_4_3:1.4.2.4
	v1_5_0:1.11
	ruby_1_4_3_pre1:1.4.2.3
	ruby_1_4:1.4.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.23
	v1_3_6_repack:1.1.1.3.2.23
	v1_3_6:1.1.1.3.2.23
	v1_3_5:1.1.1.3.2.21
	v1_2_6repack:1.1.1.2.2.52
	v1_3_4_990625:1.1.1.3.2.20
	v1_3_4_990624:1.1.1.3.2.19
	v1_2_6:1.1.1.2.2.52
	v1_3_4_990611:1.1.1.3.2.18
	v1_3_4_990531:1.1.1.3.2.16
	v1_3_3_990518:1.1.1.3.2.14
	v1_3_3_990513:1.1.1.3.2.13
	v1_3_3_990507:1.1.1.3.2.11
	v1_2_5:1.1.1.2.2.49
	v1_2_4:1.1.1.2.2.49
	v1_3_1_990225:1.1.1.3.2.7
	v1_3_1_990224:1.1.1.3.2.6
	v1_3_1_990215:1.1.1.3.2.5
	v1_3_1_990212:1.1.1.3.2.5
	v1_3_1_990210:1.1.1.3.2.4
	v1_3_1_:1.1.1.3.2.4
	v1_3_1_990209:1.1.1.3.2.4
	v1_3_1_990205:1.1.1.3.2.3
	v1_3_1_990203:1.1.1.3.2.2
	v1_3_1_990201:1.1.1.3.2.2
	v1_3_1"_990201:1.1.1.3.2.2
	v1_3_1_990128:1.1.1.3.2.1
	v1_3_1_990127:1.1.1.3.2.1
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.48
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.48
	v1_2_1repack:1.1.1.2.2.48
	v1_2_1:1.1.1.2.2.48
	v1_2_stable:1.1.1.2.2.48
	v1_1d1:1.1.1.2.2.45.2.5
	v1_1d0:1.1.1.2.2.45.2.4
	v1_1c9_1:1.1.1.2.2.48
	v1_1c9:1.1.1.2.2.48
	v1_1c8:1.1.1.2.2.48
	v1_1c7:1.1.1.2.2.48
	v1_1c6:1.1.1.2.2.47
	v1_1d-start:1.1.1.2.2.45.2.1
	v1_1c5:1.1.1.2.2.46
	v1_1dev:1.1.1.2.2.45.0.2
	v1_1c4:1.1.1.2.2.45
	v1_1c3:1.1.1.2.2.44
	v1_1c2:1.1.1.2.2.43
	v1_1c1:1.1.1.2.2.42
	v1_1c0:1.1.1.2.2.42
	v1_1b9_31:1.1.1.2.2.41
	v1_1b9_30:1.1.1.2.2.40
	v1_1b9_28:1.1.1.2.2.40
	v1_1b9_27:1.1.1.2.2.39
	v1_1b9_26:1.1.1.2.2.39
	r1_1b9_25:1.1.1.2.2.39
	r1_1b9_24:1.1.1.2.2.38
	v1_1b9_23:1.1.1.2.2.36
	v1_1b9_22:1.1.1.2.2.35
	v1_1b9_20:1.1.1.2.2.33
	v1_1b9_18:1.1.1.2.2.31
	v1_1b9_16:1.1.1.2.2.28
	v1_1b9_15:1.1.1.2.2.27
	v1_1b9_13:1.1.1.2.2.24
	v1_1b9_12:1.1.1.2.2.24
	v1_1b9_11:1.1.1.2.2.24
	v1_1b9_08:1.1.1.2.2.20
	v1_1b9_07:1.1.1.2.2.20
	r1_1b9:1.1.1.2.2.7
	v1_1b8:1.1.1.2.2.7
	v1_1b7:1.1.1.2.2.5
	v1_1b6:1.1.1.2.2.1
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.123
date	2002.10.24.17.54.53;	author aamine;	state Exp;
branches;
next	1.122;

1.122
date	2002.10.23.10.17.29;	author nobu;	state Exp;
branches;
next	1.121;

1.121
date	2002.09.25.07.03.01;	author matz;	state Exp;
branches;
next	1.120;

1.120
date	2002.09.13.08.26.35;	author michal;	state Exp;
branches;
next	1.119;

1.119
date	2002.09.12.06.27.13;	author matz;	state Exp;
branches;
next	1.118;

1.118
date	2002.09.11.04.05.36;	author knu;	state Exp;
branches;
next	1.117;

1.117
date	2002.09.03.05.20.06;	author matz;	state Exp;
branches;
next	1.116;

1.116
date	2002.08.29.09.08.16;	author matz;	state Exp;
branches;
next	1.115;

1.115
date	2002.08.28.08.05.23;	author michal;	state Exp;
branches;
next	1.114;

1.114
date	2002.08.28.06.01.58;	author matz;	state Exp;
branches;
next	1.113;

1.113
date	2002.08.27.10.24.24;	author eban;	state Exp;
branches;
next	1.112;

1.112
date	2002.08.27.08.31.06;	author matz;	state Exp;
branches;
next	1.111;

1.111
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.110;

1.110
date	2002.08.06.06.20.43;	author usa;	state Exp;
branches;
next	1.109;

1.109
date	2002.07.26.06.12.39;	author matz;	state Exp;
branches;
next	1.108;

1.108
date	2002.07.11.17.17.14;	author nobu;	state Exp;
branches;
next	1.107;

1.107
date	2002.07.11.08.22.10;	author matz;	state Exp;
branches;
next	1.106;

1.106
date	2002.06.18.06.29.05;	author matz;	state Exp;
branches;
next	1.105;

1.105
date	2002.06.04.07.34.15;	author matz;	state Exp;
branches;
next	1.104;

1.104
date	2002.05.29.05.20.33;	author matz;	state Exp;
branches;
next	1.103;

1.103
date	2002.05.28.18.11.07;	author michal;	state Exp;
branches;
next	1.102;

1.102
date	2002.04.24.04.54.14;	author matz;	state Exp;
branches;
next	1.101;

1.101
date	2002.04.18.08.46.18;	author matz;	state Exp;
branches;
next	1.100;

1.100
date	2002.03.19.09.03.07;	author matz;	state Exp;
branches;
next	1.99;

1.99
date	2002.03.14.00.10.49;	author nobu;	state Exp;
branches;
next	1.98;

1.98
date	2002.03.11.08.02.02;	author matz;	state Exp;
branches;
next	1.97;

1.97
date	2002.02.01.10.23.22;	author nobu;	state Exp;
branches;
next	1.96;

1.96
date	2002.01.28.08.44.37;	author matz;	state Exp;
branches;
next	1.95;

1.95
date	2002.01.25.08.22.05;	author matz;	state Exp;
branches;
next	1.94;

1.94
date	2002.01.11.09.18.50;	author matz;	state Exp;
branches;
next	1.93;

1.93
date	2002.01.07.05.27.01;	author matz;	state Exp;
branches;
next	1.92;

1.92
date	2001.12.19.07.48.30;	author matz;	state Exp;
branches;
next	1.91;

1.91
date	2001.12.18.08.46.56;	author matz;	state Exp;
branches;
next	1.90;

1.90
date	2001.12.11.03.48.08;	author matz;	state Exp;
branches;
next	1.89;

1.89
date	2001.12.10.07.18.12;	author matz;	state Exp;
branches;
next	1.88;

1.88
date	2001.11.29.15.57.25;	author matz;	state Exp;
branches;
next	1.87;

1.87
date	2001.11.19.14.42.45;	author matz;	state Exp;
branches;
next	1.86;

1.86
date	2001.11.19.05.03.03;	author matz;	state Exp;
branches;
next	1.85;

1.85
date	2001.11.13.08.19.52;	author matz;	state Exp;
branches;
next	1.84;

1.84
date	2001.11.08.06.43.08;	author matz;	state Exp;
branches;
next	1.83;

1.83
date	2001.10.31.06.53.22;	author matz;	state Exp;
branches;
next	1.82;

1.82
date	2001.10.30.08.43.25;	author matz;	state Exp;
branches;
next	1.81;

1.81
date	2001.10.16.03.27.06;	author matz;	state Exp;
branches;
next	1.80;

1.80
date	2001.10.03.07.19.10;	author matz;	state Exp;
branches;
next	1.79;

1.79
date	2001.10.02.04.31.19;	author matz;	state Exp;
branches;
next	1.78;

1.78
date	2001.09.19.06.54.11;	author matz;	state Exp;
branches;
next	1.77;

1.77
date	2001.09.08.14.17.10;	author matz;	state Exp;
branches;
next	1.76;

1.76
date	2001.08.29.06.28.44;	author matz;	state Exp;
branches;
next	1.75;

1.75
date	2001.08.20.04.29.56;	author matz;	state Exp;
branches;
next	1.74;

1.74
date	2001.08.14.08.13.26;	author matz;	state Exp;
branches;
next	1.73;

1.73
date	2001.08.12.09.41.39;	author nobu;	state Exp;
branches;
next	1.72;

1.72
date	2001.08.06.15.05.50;	author nobu;	state Exp;
branches;
next	1.71;

1.71
date	2001.08.06.03.05.13;	author matz;	state Exp;
branches;
next	1.70;

1.70
date	2001.07.24.09.07.33;	author matz;	state Exp;
branches;
next	1.69;

1.69
date	2001.07.18.05.55.20;	author matz;	state Exp;
branches;
next	1.68;

1.68
date	2001.07.14.15.17.19;	author matz;	state Exp;
branches;
next	1.67;

1.67
date	2001.05.30.09.12.34;	author matz;	state Exp;
branches;
next	1.66;

1.66
date	2001.05.16.09.05.50;	author matz;	state Exp;
branches;
next	1.65;

1.65
date	2001.05.11.06.13.45;	author eban;	state Exp;
branches;
next	1.64;

1.64
date	2001.05.11.05.24.54;	author matz;	state Exp;
branches;
next	1.63;

1.63
date	2001.05.06.15.01.59;	author matz;	state Exp;
branches;
next	1.62;

1.62
date	2001.05.02.04.22.11;	author matz;	state Exp;
branches;
next	1.61;

1.61
date	2001.03.26.08.57.10;	author matz;	state Exp;
branches;
next	1.60;

1.60
date	2001.03.04.09.45.29;	author eban;	state Exp;
branches;
next	1.59;

1.59
date	2001.02.28.06.30.03;	author matz;	state Exp;
branches;
next	1.58;

1.58
date	2001.02.19.09.14.58;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2001.02.08.09.19.17;	author matz;	state Exp;
branches;
next	1.56;

1.56
date	2001.02.02.11.38.11;	author matz;	state Exp;
branches;
next	1.55;

1.55
date	2001.01.29.05.10.42;	author matz;	state Exp;
branches;
next	1.54;

1.54
date	2001.01.15.07.00.54;	author matz;	state Exp;
branches;
next	1.53;

1.53
date	2001.01.09.16.55.50;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2000.12.26.08.32.35;	author matz;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2000.12.26.08.08.50;	author matz;	state Exp;
branches;
next	1.50;

1.50
date	2000.12.25.06.29.10;	author matz;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2000.12.05.09.36.35;	author matz;	state Exp;
branches;
next	1.48;

1.48
date	2000.11.17.05.59.45;	author eban;	state Exp;
branches;
next	1.47;

1.47
date	2000.10.10.07.03.24;	author matz;	state Exp;
branches;
next	1.46;

1.46
date	2000.10.02.07.48.33;	author matz;	state Exp;
branches;
next	1.45;

1.45
date	2000.09.26.09.11.47;	author eban;	state Exp;
branches;
next	1.44;

1.44
date	2000.09.07.06.59.36;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2000.09.01.09.18.11;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2000.08.25.08.26.03;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2000.08.07.05.01.57;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.25.06.03.47;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2000.07.24.07.19.32;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2000.06.23.07.01.27;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.22.08.29.47;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.16.07.44.04;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2000.06.14.08.08.50;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.14.05.30.22;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.05.08.46.53;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2000.05.24.04.34.08;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.12.09.07.46;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.09.04.53.05;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.05.01.09.41.29;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.10.05.44.19;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.03.23.08.37.29;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.17.08.58.14;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.15.05.01.16;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.13.07.18.39;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.08.06.23.18;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.07.08.37.47;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.29.08.05.27;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.25.03.51.21;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.23.05.23.09;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.17.07.11.17;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.02.08.08.48.54;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.02.08.10.30;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.01.03.12.11;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.17.08.37.46;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.05.04.37.12;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	99.12.14.06.49.52;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	99.12.07.09.23.27;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	99.12.06.09.03.59;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	99.12.01.09.24.14;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.11.04.08.39.38;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.10.29.09.25.31;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.10.20.07.10.22;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.10.15.08.52.17;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.09.22.04.30.10;	author matz;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.09.16.09.40.33;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.14;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.12;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.28;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.17;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.01.07.34.57;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.05.10.27.33;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.02.09.06.08.23;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.02.12.11.17.06;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.02.24.04.31.25;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.02.25.06.39.11;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.03.24.08.52.33;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.04.20.08.21.41;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.04.26.09.42.42;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.05.06.08.31.46;	author matz;	state Exp;
branches;
next	1.1.1.3.2.12;

1.1.1.3.2.12
date	99.05.10.08.22.47;	author matz;	state Exp;
branches;
next	1.1.1.3.2.13;

1.1.1.3.2.13
date	99.05.13.10.01.07;	author matz;	state Exp;
branches;
next	1.1.1.3.2.14;

1.1.1.3.2.14
date	99.05.17.09.54.17;	author matz;	state Exp;
branches;
next	1.1.1.3.2.15;

1.1.1.3.2.15
date	99.05.25.08.26.16;	author matz;	state Exp;
branches;
next	1.1.1.3.2.16;

1.1.1.3.2.16
date	99.05.31.09.13.27;	author matz;	state Exp;
branches;
next	1.1.1.3.2.17;

1.1.1.3.2.17
date	99.06.09.09.21.32;	author matz;	state Exp;
branches;
next	1.1.1.3.2.18;

1.1.1.3.2.18
date	99.06.11.06.29.57;	author matz;	state Exp;
branches;
next	1.1.1.3.2.19;

1.1.1.3.2.19
date	99.06.24.04.24.03;	author matz;	state Exp;
branches;
next	1.1.1.3.2.20;

1.1.1.3.2.20
date	99.06.25.09.02.48;	author matz;	state Exp;
branches;
next	1.1.1.3.2.21;

1.1.1.3.2.21
date	99.07.15.07.59.55;	author matz;	state Exp;
branches;
next	1.1.1.3.2.22;

1.1.1.3.2.22
date	99.07.22.10.37.20;	author matz;	state Exp;
branches;
next	1.1.1.3.2.23;

1.1.1.3.2.23
date	99.07.28.09.26.49;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.02.05.09.46.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.02.09.10.56.22;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.02.10.06.50.15;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.02.10.08.44.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.02.18.01.56.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.02.20.08.28.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.03.03.10.16.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.03.05.06.37.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.03.09.07.56.58;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.03.11.07.33.01;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.03.20.09.20.30;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.03.23.09.49.17;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.03.26.09.07.27;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.03.26.09.09.38;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.03.28.11.05.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.03.30.09.32.52;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.03.31.04.52.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.04.02.10.03.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.04.07.08.34.09;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.04.07.10.18.09;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.04.08.08.12.38;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.04.09.09.30.24;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.04.16.07.42.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	98.04.22.08.57.34;	author matz;	state Exp;
branches;
next	1.1.1.2.2.26;

1.1.1.2.2.26
date	98.04.23.06.53.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.27;

1.1.1.2.2.27
date	98.04.24.09.33.21;	author matz;	state Exp;
branches;
next	1.1.1.2.2.28;

1.1.1.2.2.28
date	98.04.27.10.04.01;	author matz;	state Exp;
branches;
next	1.1.1.2.2.29;

1.1.1.2.2.29
date	98.04.30.07.41.15;	author matz;	state Exp;
branches;
next	1.1.1.2.2.30;

1.1.1.2.2.30
date	98.05.01.08.56.37;	author matz;	state Exp;
branches;
next	1.1.1.2.2.31;

1.1.1.2.2.31
date	98.05.06.03.08.59;	author matz;	state Exp;
branches;
next	1.1.1.2.2.32;

1.1.1.2.2.32
date	98.05.13.05.58.08;	author matz;	state Exp;
branches;
next	1.1.1.2.2.33;

1.1.1.2.2.33
date	98.05.13.07.26.35;	author matz;	state Exp;
branches;
next	1.1.1.2.2.34;

1.1.1.2.2.34
date	98.05.18.04.56.21;	author matz;	state Exp;
branches;
next	1.1.1.2.2.35;

1.1.1.2.2.35
date	98.05.18.09.12.22;	author matz;	state Exp;
branches;
next	1.1.1.2.2.36;

1.1.1.2.2.36
date	98.05.25.04.57.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.37;

1.1.1.2.2.37
date	98.06.02.10.05.32;	author matz;	state Exp;
branches;
next	1.1.1.2.2.38;

1.1.1.2.2.38
date	98.06.05.09.54.23;	author matz;	state Exp;
branches;
next	1.1.1.2.2.39;

1.1.1.2.2.39
date	98.06.11.10.03.11;	author matz;	state Exp;
branches;
next	1.1.1.2.2.40;

1.1.1.2.2.40
date	98.06.26.09.44.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.41;

1.1.1.2.2.41
date	98.07.13.04.37.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.42;

1.1.1.2.2.42
date	98.07.17.00.53.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.43;

1.1.1.2.2.43
date	98.07.29.09.50.34;	author matz;	state Exp;
branches;
next	1.1.1.2.2.44;

1.1.1.2.2.44
date	98.08.27.03.55.32;	author matz;	state Exp;
branches;
next	1.1.1.2.2.45;

1.1.1.2.2.45
date	98.09.01.02.53.51;	author matz;	state Exp;
branches
	1.1.1.2.2.45.2.1;
next	1.1.1.2.2.46;

1.1.1.2.2.46
date	98.09.08.09.17.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.47;

1.1.1.2.2.47
date	98.10.06.02.45.03;	author matz;	state Exp;
branches;
next	1.1.1.2.2.48;

1.1.1.2.2.48
date	98.11.09.09.11.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.49;

1.1.1.2.2.49
date	99.04.08.10.14.34;	author matz;	state Exp;
branches;
next	1.1.1.2.2.50;

1.1.1.2.2.50
date	99.04.20.08.20.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.51;

1.1.1.2.2.51
date	99.05.14.08.56.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.52;

1.1.1.2.2.52
date	99.06.21.06.31.09;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.45.2.1
date	98.09.08.07.09.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.45.2.2;

1.1.1.2.2.45.2.2
date	98.10.06.03.28.15;	author matz;	state Exp;
branches;
next	1.1.1.2.2.45.2.3;

1.1.1.2.2.45.2.3
date	98.11.25.03.31.17;	author matz;	state Exp;
branches;
next	1.1.1.2.2.45.2.4;

1.1.1.2.2.45.2.4
date	98.12.16.07.30.33;	author matz;	state Exp;
branches;
next	1.1.1.2.2.45.2.5;

1.1.1.2.2.45.2.5
date	98.12.22.09.01.53;	author matz;	state Exp;
branches;
next	;

1.4.2.1
date	99.10.29.09.25.48;	author matz;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	99.11.04.08.39.56;	author matz;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	99.11.17.07.29.52;	author matz;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	99.12.01.09.24.46;	author matz;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2000.01.17.08.24.12;	author matz;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2000.02.01.03.11.23;	author matz;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2000.02.02.08.09.40;	author matz;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2000.02.08.08.53.55;	author matz;	state Exp;
branches;
next	1.4.2.9;

1.4.2.9
date	2000.02.17.08.29.03;	author matz;	state Exp;
branches;
next	1.4.2.10;

1.4.2.10
date	2000.03.02.03.51.45;	author matz;	state Exp;
branches;
next	1.4.2.11;

1.4.2.11
date	2000.03.08.06.25.16;	author matz;	state Exp;
branches;
next	1.4.2.12;

1.4.2.12
date	2000.03.23.04.14.21;	author matz;	state Exp;
branches;
next	1.4.2.13;

1.4.2.13
date	2000.04.17.06.24.45;	author matz;	state Exp;
branches;
next	1.4.2.14;

1.4.2.14
date	2000.05.01.09.42.31;	author matz;	state Exp;
branches;
next	1.4.2.15;

1.4.2.15
date	2000.07.24.07.16.15;	author matz;	state Exp;
branches;
next	1.4.2.16;

1.4.2.16
date	2000.07.25.06.15.18;	author matz;	state Exp;
branches;
next	1.4.2.17;

1.4.2.17
date	2000.09.12.05.33.08;	author matz;	state Exp;
branches;
next	;

1.50.2.1
date	2000.12.28.04.45.16;	author matz;	state Exp;
branches;
next	1.50.2.2;

1.50.2.2
date	2001.01.09.16.58.18;	author matz;	state Exp;
branches;
next	1.50.2.3;

1.50.2.3
date	2001.02.02.11.39.51;	author matz;	state Exp;
branches;
next	1.50.2.4;

1.50.2.4
date	2001.02.08.09.17.57;	author matz;	state Exp;
branches;
next	1.50.2.5;

1.50.2.5
date	2001.02.19.09.15.27;	author matz;	state Exp;
branches;
next	1.50.2.6;

1.50.2.6
date	2001.02.28.06.31.21;	author matz;	state Exp;
branches;
next	1.50.2.7;

1.50.2.7
date	2001.03.04.09.46.08;	author eban;	state Exp;
branches;
next	1.50.2.8;

1.50.2.8
date	2001.03.26.08.56.04;	author matz;	state Exp;
branches;
next	1.50.2.9;

1.50.2.9
date	2001.05.25.15.01.06;	author matz;	state Exp;
branches;
next	1.50.2.10;

1.50.2.10
date	2001.07.06.06.36.59;	author matz;	state Exp;
branches;
next	1.50.2.11;

1.50.2.11
date	2001.07.13.05.50.04;	author matz;	state Exp;
branches;
next	1.50.2.12;

1.50.2.12
date	2001.08.14.08.11.00;	author matz;	state Exp;
branches;
next	1.50.2.13;

1.50.2.13
date	2001.08.24.06.36.14;	author matz;	state Exp;
branches;
next	1.50.2.14;

1.50.2.14
date	2001.09.06.07.47.46;	author matz;	state Exp;
branches;
next	1.50.2.15;

1.50.2.15
date	2001.10.02.04.25.53;	author matz;	state Exp;
branches;
next	1.50.2.16;

1.50.2.16
date	2001.10.05.06.27.46;	author matz;	state Exp;
branches;
next	1.50.2.17;

1.50.2.17
date	2001.10.22.06.46.05;	author matz;	state Exp;
branches;
next	1.50.2.18;

1.50.2.18
date	2001.11.07.09.01.31;	author matz;	state Exp;
branches;
next	1.50.2.19;

1.50.2.19
date	2001.11.19.14.36.40;	author matz;	state Exp;
branches;
next	1.50.2.20;

1.50.2.20
date	2001.11.19.16.16.13;	author matz;	state Exp;
branches;
next	1.50.2.21;

1.50.2.21
date	2001.12.03.10.06.39;	author matz;	state Exp;
branches;
next	1.50.2.22;

1.50.2.22
date	2001.12.03.14.05.28;	author eban;	state Exp;
branches;
next	1.50.2.23;

1.50.2.23
date	2001.12.04.04.53.31;	author matz;	state Exp;
branches;
next	1.50.2.24;

1.50.2.24
date	2002.01.07.05.24.03;	author matz;	state Exp;
branches;
next	1.50.2.25;

1.50.2.25
date	2002.01.25.08.23.31;	author matz;	state Exp;
branches;
next	1.50.2.26;

1.50.2.26
date	2002.03.12.09.27.26;	author matz;	state Exp;
branches;
next	1.50.2.27;

1.50.2.27
date	2002.03.19.09.02.04;	author matz;	state Exp;
branches;
next	1.50.2.28;

1.50.2.28
date	2002.06.04.07.11.52;	author matz;	state Exp;
branches;
next	1.50.2.29;

1.50.2.29
date	2002.07.11.08.24.54;	author matz;	state Exp;
branches;
next	1.50.2.30;

1.50.2.30
date	2002.09.25.07.07.38;	author matz;	state Exp;
branches;
next	1.50.2.31;

1.50.2.31
date	2002.10.26.15.57.24;	author knu;	state Exp;
branches;
next	;

1.52.2.1
date	2001.01.10.09.24.27;	author matz;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2001.01.12.04.36.00;	author matz;	state Exp;
branches;
next	1.52.2.3;

1.52.2.3
date	2001.03.05.03.37.34;	author matz;	state Exp;
branches;
next	1.52.2.4;

1.52.2.4
date	2002.07.09.05.26.49;	author matz;	state Exp;
branches;
next	;


desc
@@


1.123
log
@* string.c (rb_str_split_m): RSTRING(str)->ptr might become NULL.
@
text
@/**********************************************************************

  string.c -

  $Author: nobu $
  $Date: 2002/10/23 10:17:29 $
  created at: Mon Aug  9 17:12:58 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#include "ruby.h"
#include "re.h"

#define BEG(no) regs->beg[no]
#define END(no) regs->end[no]

#include <math.h>
#include <ctype.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

VALUE rb_cString;

#define STR_ASSOC   FL_USER3

#define RESIZE_CAPA(str,capacity) do {\
    REALLOC_N(RSTRING(str)->ptr, char, (capacity)+1);\
    RSTRING(str)->aux.capa = (capacity);\
} while (0)

VALUE rb_fs;

static VALUE
rb_str_s_alloc(klass)
    VALUE klass;
{
    NEWOBJ(str, struct RString);
    OBJSETUP(str, klass, T_STRING);

    str->ptr = 0;
    str->len = 0;
    str->aux.capa = 0;

    return (VALUE)str;
}

static VALUE
str_new(klass, ptr, len)
    VALUE klass;
    const char *ptr;
    long len;
{
    VALUE str;

    if (len < 0) {
	rb_raise(rb_eArgError, "negative string size (or size too big)");
    }

    str = rb_obj_alloc(klass);
    RSTRING(str)->len = len;
    RSTRING(str)->aux.capa = len;
    RSTRING(str)->ptr = ALLOC_N(char,len+1);
    if (ptr) {
	memcpy(RSTRING(str)->ptr, ptr, len);
    }
    else {
	MEMZERO(RSTRING(str)->ptr, char, len);
    }
    RSTRING(str)->ptr[len] = '\0';
    return str;
}

VALUE
rb_str_new(ptr, len)
    const char *ptr;
    long len;
{
    return str_new(rb_cString, ptr, len);
}

VALUE
rb_str_new2(ptr)
    const char *ptr;
{
    if (!ptr) {
	rb_raise(rb_eArgError, "NULL pointer given");
    }
    return rb_str_new(ptr, strlen(ptr));
}

VALUE
rb_tainted_str_new(ptr, len)
    const char *ptr;
    long len;
{
    VALUE str = rb_str_new(ptr, len);

    OBJ_TAINT(str);
    return str;
}

VALUE
rb_tainted_str_new2(ptr)
    const char *ptr;
{
    VALUE str = rb_str_new2(ptr);

    OBJ_TAINT(str);
    return str;
}

static VALUE
str_new3(klass, str)
    VALUE klass, str;
{
    VALUE str2 = rb_obj_alloc(klass);

    RSTRING(str2)->len = RSTRING(str)->len;
    RSTRING(str2)->ptr = RSTRING(str)->ptr;
    RSTRING(str2)->aux.shared = str;
    FL_SET(str2, ELTS_SHARED);
    OBJ_INFECT(str2, str);

    return str2;
}

VALUE
rb_str_new3(str)
    VALUE str;
{
    return str_new3(rb_obj_class(str), str);
}

VALUE
rb_str_new4(orig)
    VALUE orig;
{
    VALUE klass, str;

    klass = rb_obj_class(orig);
    if (FL_TEST(orig, ELTS_SHARED)) {
	str = str_new3(klass, RSTRING(orig)->aux.shared);
    }
    else if (FL_TEST(orig, STR_ASSOC)) {
	str = str_new(klass, RSTRING(orig)->ptr, RSTRING(orig)->len);
    }
    else {
	str = rb_obj_alloc(klass);

	RSTRING(str)->len = RSTRING(orig)->len;
	RSTRING(str)->ptr = RSTRING(orig)->ptr;
	RSTRING(orig)->aux.shared = str;
	FL_SET(orig, ELTS_SHARED);
    }
    OBJ_INFECT(str, orig);
    OBJ_FREEZE(str);
    return str;
}

VALUE
rb_str_new5(obj, ptr, len)
    VALUE obj;
    const char *ptr;
    long len;
{
    return str_new(rb_obj_class(obj), ptr, len);
}

#define STR_BUF_MIN_SIZE 128

VALUE
rb_str_buf_new(capa)
    long capa;
{
    VALUE str = rb_obj_alloc(rb_cString);

    if (capa < STR_BUF_MIN_SIZE) {
	capa = STR_BUF_MIN_SIZE;
    }
    RSTRING(str)->ptr = 0;
    RSTRING(str)->len = 0;
    RSTRING(str)->aux.capa = capa;
    RSTRING(str)->ptr = ALLOC_N(char, capa+1);
    RSTRING(str)->ptr[0] = '\0';

    return str;
}

VALUE
rb_str_buf_new2(ptr)
    const char *ptr;
{
    VALUE str;
    long len = strlen(ptr);

    str = rb_str_buf_new(len);
    rb_str_buf_cat(str, ptr, len);

    return str;
}

VALUE
rb_str_to_str(str)
    VALUE str;
{
    return rb_convert_type(str, T_STRING, "String", "to_str");
}

static void
rb_str_shared_replace(str, str2)
    VALUE str, str2;
{
    if (str == str2) return;
    if (!FL_TEST(str, ELTS_SHARED)) free(RSTRING(str)->ptr);
    if (NIL_P(str2)) {
	RSTRING(str)->ptr = 0;
	RSTRING(str)->len = 0;
	RSTRING(str)->aux.capa = 0;
	FL_UNSET(str, ELTS_SHARED|STR_ASSOC);
	return;
    }
    RSTRING(str)->ptr = RSTRING(str2)->ptr;
    RSTRING(str)->len = RSTRING(str2)->len;
    if (FL_TEST(str2, ELTS_SHARED|STR_ASSOC)) {
	FL_SET(str, RBASIC(str2)->flags & (ELTS_SHARED|STR_ASSOC));
	RSTRING(str)->aux.shared = RSTRING(str2)->aux.shared;
    }
    else {
	FL_UNSET(str, ELTS_SHARED|STR_ASSOC);
	RSTRING(str)->aux.capa = RSTRING(str2)->aux.capa;
    }
    RSTRING(str2)->ptr = 0;	/* abandon str2 */
    RSTRING(str2)->len = 0;
    RSTRING(str2)->aux.capa = 0;
    FL_UNSET(str2, ELTS_SHARED|STR_ASSOC);
    if (OBJ_TAINTED(str2)) OBJ_TAINT(str);
}

static ID id_to_s;

VALUE
rb_obj_as_string(obj)
    VALUE obj;
{
    VALUE str;

    if (TYPE(obj) == T_STRING) {
	return obj;
    }
    str = rb_funcall(obj, id_to_s, 0);
    if (TYPE(str) != T_STRING)
	return rb_any_to_s(obj);
    if (OBJ_TAINTED(obj)) OBJ_TAINT(str);
    return str;
}

static VALUE rb_str_replace _((VALUE, VALUE));

VALUE
rb_str_dup(str)
    VALUE str;
{
    VALUE dup = rb_str_s_alloc(rb_cString);
    rb_str_replace(dup, str);
    return dup;
}

static VALUE
rb_str_init(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE orig;

    if (rb_scan_args(argc, argv, "01", &orig) == 1)
	rb_str_replace(str, orig);
    return str;
}

static VALUE
rb_str_length(str)
    VALUE str;
{
    return LONG2NUM(RSTRING(str)->len);
}

static VALUE
rb_str_empty(str)
    VALUE str;
{
    if (RSTRING(str)->len == 0)
	return Qtrue;
    return Qfalse;
}

VALUE
rb_str_plus(str1, str2)
    VALUE str1, str2;
{
    VALUE str3;

    StringValue(str2);
    str3 = rb_str_new(0, RSTRING(str1)->len+RSTRING(str2)->len);
    memcpy(RSTRING(str3)->ptr, RSTRING(str1)->ptr, RSTRING(str1)->len);
    memcpy(RSTRING(str3)->ptr + RSTRING(str1)->len,
	   RSTRING(str2)->ptr, RSTRING(str2)->len);
    RSTRING(str3)->ptr[RSTRING(str3)->len] = '\0';

    if (OBJ_TAINTED(str1) || OBJ_TAINTED(str2))
	OBJ_TAINT(str3);
    return str3;
}

VALUE
rb_str_times(str, times)
    VALUE str;
    VALUE times;
{
    VALUE str2;
    long i, len;

    len = NUM2LONG(times);
    if (len == 0) return rb_str_new5(str,0,0);
    if (len < 0) {
	rb_raise(rb_eArgError, "negative argument");
    }
    if (LONG_MAX/len <  RSTRING(str)->len) {
	rb_raise(rb_eArgError, "argument too big");
    }

    str2 = rb_str_new5(str,0, RSTRING(str)->len*len);
    for (i=0; i<len; i++) {
	memcpy(RSTRING(str2)->ptr+(i*RSTRING(str)->len),
	       RSTRING(str)->ptr, RSTRING(str)->len);
    }
    RSTRING(str2)->ptr[RSTRING(str2)->len] = '\0';

    OBJ_INFECT(str2, str);

    return str2;
}

static VALUE
rb_str_format(str, arg)
    VALUE str, arg;
{
    VALUE *argv;

    if (TYPE(arg) == T_ARRAY) {
	argv = ALLOCA_N(VALUE, RARRAY(arg)->len + 1);
	argv[0] = str;
	MEMCPY(argv+1, RARRAY(arg)->ptr, VALUE, RARRAY(arg)->len);
	return rb_f_sprintf(RARRAY(arg)->len+1, argv);
    }
    
    argv = ALLOCA_N(VALUE, 2);
    argv[0] = str;
    argv[1] = arg;
    return rb_f_sprintf(2, argv);
}

static int
str_independent(str)
    VALUE str;
{
    if (OBJ_FROZEN(str)) rb_error_frozen("string");
    if (!OBJ_TAINTED(str) && rb_safe_level() >= 4)
	rb_raise(rb_eSecurityError, "Insecure: can't modify string");
    if (!FL_TEST(str, ELTS_SHARED)) return 1;
    return 0;
}

static void
str_make_independent(str)
    VALUE str;
{
    char *ptr;

    ptr = ALLOC_N(char, RSTRING(str)->len+1);
    if (RSTRING(str)->ptr) {
	memcpy(ptr, RSTRING(str)->ptr, RSTRING(str)->len);
    }
    ptr[RSTRING(str)->len] = 0;
    RSTRING(str)->ptr = ptr;
    RSTRING(str)->aux.capa = RSTRING(str)->len;
    FL_UNSET(str, ELTS_SHARED|STR_ASSOC);
}

void
rb_str_modify(str)
    VALUE str;
{
    if (!str_independent(str))
	str_make_independent(str);
}

void
rb_str_associate(str, add)
    VALUE str, add;
{
    if (FL_TEST(str, STR_ASSOC)) {
	/* already associated */
	rb_ary_concat(RSTRING(str)->aux.shared, add);
    }
    else {
	if (FL_TEST(str, ELTS_SHARED)) {
	    str_make_independent(str);
	}
	else if (RSTRING(str)->aux.capa != RSTRING(str)->len) {
	    RESIZE_CAPA(str, RSTRING(str)->len);
	}
	RSTRING(str)->aux.shared = add;
	FL_SET(str, STR_ASSOC);
    }
}

VALUE
rb_str_associated(str)
    VALUE str;
{
    if (FL_TEST(str, STR_ASSOC)) {
	return RSTRING(str)->aux.shared;
    }
    return Qfalse;
}

VALUE
rb_string_value(ptr)
    volatile VALUE *ptr;
{
    return *ptr = rb_str_to_str(*ptr);
}

char *
rb_string_value_ptr(ptr)
    volatile VALUE *ptr;
{
    VALUE s = *ptr;
    if (TYPE(s) != T_STRING) {
	s = rb_str_to_str(s);
	*ptr = s;
    }
    if (!RSTRING(s)->ptr) {
	str_make_independent(s);
    }
    return RSTRING(s)->ptr;
}

VALUE
rb_str_substr(str, beg, len)
    VALUE str;
    long beg, len;
{
    VALUE str2;

    if (len < 0) return Qnil;
    if (beg > RSTRING(str)->len) return Qnil;
    if (beg < 0) {
	beg += RSTRING(str)->len;
	if (beg < 0) return Qnil;
    }
    if (beg + len > RSTRING(str)->len) {
	len = RSTRING(str)->len - beg;
    }
    if (len < 0) {
	len = 0;
    }
    if (len == 0) return rb_str_new5(str,0,0);

    str2 = rb_str_new5(str,RSTRING(str)->ptr+beg, len);
    OBJ_INFECT(str2, str);

    return str2;
}

VALUE
rb_str_freeze(str)
    VALUE str;
{
    return rb_obj_freeze(str);
}

VALUE
rb_str_dup_frozen(str)
    VALUE str;
{
    if (FL_TEST(str, ELTS_SHARED)) {
	OBJ_FREEZE(RSTRING(str)->aux.shared);
	return RSTRING(str)->aux.shared;
    }
    if (OBJ_FROZEN(str)) return str;
    str = rb_str_dup(str);
    OBJ_FREEZE(str);
    return str;
}

VALUE
rb_str_resize(str, len)
    VALUE str;
    long len;
{
    if (len < 0) {
	rb_raise(rb_eArgError, "negative string size (or size too big)");
    }
	
    if (len != RSTRING(str)->len) {
	rb_str_modify(str);
	if (RSTRING(str)->len < len || RSTRING(str)->len - len > 1024) {
	    REALLOC_N(RSTRING(str)->ptr, char, len+1);
	    if (!FL_TEST(str, STR_ASSOC)) {
		RSTRING(str)->aux.capa = len;
	    }
	}
	RSTRING(str)->len = len;
	RSTRING(str)->ptr[len] = '\0';	/* sentinel */
    }
    return str;
}

VALUE
rb_str_buf_cat(str, ptr, len)
    VALUE str;
    const char *ptr;
    long len;
{
    long capa, total;

    if (len == 0) return str;
    if (len < 0) {
	rb_raise(rb_eArgError, "negative string size (or size too big)");
    }
    rb_str_modify(str);
    if (FL_TEST(str, STR_ASSOC)) {
	FL_UNSET(str, STR_ASSOC);
	capa = RSTRING(str)->aux.capa = RSTRING(str)->len;
    }
    else {
	capa = RSTRING(str)->aux.capa;
    }
    total = RSTRING(str)->len+len;
    if (capa <= total) {
	while (total > capa) {
	    capa = (capa + 1) * 2;
	}
	RESIZE_CAPA(str, capa);
    }
    memcpy(RSTRING(str)->ptr + RSTRING(str)->len, ptr, len);
    RSTRING(str)->len = total;
    RSTRING(str)->ptr[total] = '\0'; /* sentinel */

    return str;
}

VALUE
rb_str_buf_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    return rb_str_buf_cat(str, ptr, strlen(ptr));
}

VALUE
rb_str_cat(str, ptr, len)
    VALUE str;
    const char *ptr;
    long len;
{
    if (len < 0) {
	rb_raise(rb_eArgError, "negative string size (or size too big)");
    }
    if (FL_TEST(str, STR_ASSOC)) {
	rb_str_modify(str);
	REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len+len);
	if (ptr) {
	    memcpy(RSTRING(str)->ptr + RSTRING(str)->len, ptr, len);
	}
	else {
	    MEMZERO(RSTRING(str)->ptr + RSTRING(str)->len, char, len);
	}
	RSTRING(str)->len += len;
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0'; /* sentinel */
	return str;
    }

    return rb_str_buf_cat(str, ptr, len);
}

VALUE
rb_str_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    return rb_str_cat(str, ptr, strlen(ptr));
}

VALUE
rb_str_buf_append(str, str2)
    VALUE str, str2;
{
    long capa, len;

    rb_str_modify(str);
    if (FL_TEST(str, STR_ASSOC)) {
	FL_UNSET(str, STR_ASSOC);
	capa = RSTRING(str)->aux.capa = RSTRING(str)->len;
    }
    else {
	capa = RSTRING(str)->aux.capa;
    }
    len = RSTRING(str)->len+RSTRING(str2)->len;
    if (capa <= len) {
	while (len > capa) {
	    capa = (capa + 1) * 2;
	}
	RESIZE_CAPA(str, capa);
    }
    memcpy(RSTRING(str)->ptr + RSTRING(str)->len,
	   RSTRING(str2)->ptr, RSTRING(str2)->len);
    RSTRING(str)->len += RSTRING(str2)->len;
    RSTRING(str)->ptr[RSTRING(str)->len] = '\0'; /* sentinel */
    OBJ_INFECT(str, str2);

    return str;
}

VALUE
rb_str_append(str, str2)
    VALUE str, str2;
{
    rb_str_modify(str);
    StringValue(str2);
    if (RSTRING(str2)->len > 0) {
	if (FL_TEST(str, STR_ASSOC)) {
	    long len = RSTRING(str)->len+RSTRING(str2)->len;
	    REALLOC_N(RSTRING(str)->ptr, char, len+1);
	    memcpy(RSTRING(str)->ptr + RSTRING(str)->len,
		   RSTRING(str2)->ptr, RSTRING(str2)->len);
	    RSTRING(str)->ptr[len] = '\0'; /* sentinel */
	    RSTRING(str)->len = len;
	}
	else {
	    return rb_str_buf_append(str, str2);
	}
    }
    OBJ_INFECT(str, str2);
    return str;
}

VALUE
rb_str_concat(str1, str2)
    VALUE str1, str2;
{
    if (FIXNUM_P(str2)) {
	int i = FIX2INT(str2);
	if (0 <= i && i <= 0xff) { /* byte */
	    char c = i;
	    return rb_str_cat(str1, &c, 1);
	}
    }
    str1 = rb_str_append(str1, str2);

    return str1;
}

int
rb_str_hash(str)
    VALUE str;
{
    register long len = RSTRING(str)->len;
    register char *p = RSTRING(str)->ptr;
    register int key = 0;

#ifdef HASH_ELFHASH
    register unsigned int g;

    while (len--) {
	key = (key << 4) + *p++;
	if (g = key & 0xF0000000)
	    key ^= g >> 24;
	key &= ~g;
    }
#elif HASH_PERL
    while (len--) {
	key = key*33 + *p++;
    }
    key = key + (key>>5);
#else
    while (len--) {
	key = key*65599 + *p;
	p++;
    }
    key = key + (key>>5);
#endif
    return key;
}

static VALUE
rb_str_hash_m(str)
    VALUE str;
{
    int key = rb_str_hash(str);
    return INT2FIX(key);
}

#define lesser(a,b) (((a)>(b))?(b):(a))

int
rb_str_cmp(str1, str2)
    VALUE str1, str2;
{
    long len;
    int retval;

    len = lesser(RSTRING(str1)->len, RSTRING(str2)->len);
    retval = rb_memcmp(RSTRING(str1)->ptr, RSTRING(str2)->ptr, len);
    if (retval == 0) {
	if (RSTRING(str1)->len == RSTRING(str2)->len) return 0;
	if (RSTRING(str1)->len > RSTRING(str2)->len) return 1;
	return -1;
    }
    if (retval > 0) return 1;
    return -1;
}

static VALUE
rb_str_equal(str1, str2)
    VALUE str1, str2;
{
    if (str1 == str2) return Qtrue;
    if (TYPE(str2) != T_STRING) {
	str2 = rb_check_convert_type(str2, T_STRING, "String", "to_str");
	if (NIL_P(str2)) return Qfalse;
    }

    if (RSTRING(str1)->len == RSTRING(str2)->len
	&& rb_str_cmp(str1, str2) == 0) {
	return Qtrue;
    }
    return Qfalse;
}

static VALUE
rb_str_eql(str1, str2)
    VALUE str1, str2;
{
    if (TYPE(str2) != T_STRING || RSTRING(str1)->len != RSTRING(str2)->len)
	return Qfalse;

    if (memcmp(RSTRING(str1)->ptr, RSTRING(str2)->ptr,
	       lesser(RSTRING(str1)->len, RSTRING(str2)->len)) == 0)
	return Qtrue;

    return Qfalse;
}

static VALUE
rb_str_cmp_m(str1, str2)
    VALUE str1, str2;
{
    int result;

    StringValue(str2);
    result = rb_str_cmp(str1, str2);
    return INT2FIX(result);
}

static VALUE
rb_str_casecmp(str1, str2)
    VALUE str1, str2;
{
    long len;
    int retval;

    StringValue(str2);
    len = lesser(RSTRING(str1)->len, RSTRING(str2)->len);
    retval = rb_memcicmp(RSTRING(str1)->ptr, RSTRING(str2)->ptr, len);
    if (retval == 0) {
	if (RSTRING(str1)->len == RSTRING(str2)->len) return INT2FIX(0);
	if (RSTRING(str1)->len > RSTRING(str2)->len) return INT2FIX(1);
	return INT2FIX(-1);
    }
    if (retval == 0) return INT2FIX(0);
    if (retval > 0) return INT2FIX(1);
    return INT2FIX(-1);
}

static long
rb_str_index(str, sub, offset)
    VALUE str, sub;
    long offset;
{
    char *s, *e, *p;
    long len;

    if (offset < 0) {
	offset += RSTRING(str)->len;
	if (offset < 0) return -1;
    }
    if (RSTRING(str)->len - offset < RSTRING(sub)->len) return -1;
    s = RSTRING(str)->ptr+offset;
    p = RSTRING(sub)->ptr;
    len = RSTRING(sub)->len;
    if (len == 0) return offset;
    e = RSTRING(str)->ptr + RSTRING(str)->len - len + 1;
    while (s < e) {
	if (rb_memcmp(s, p, len) == 0) {
	    return (s-(RSTRING(str)->ptr));
	}
	s++;
    }
    return -1;
}

static VALUE
rb_str_index_m(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE sub;
    VALUE initpos;
    long pos;

    if (rb_scan_args(argc, argv, "11", &sub, &initpos) == 2) {
	pos = NUM2LONG(initpos);
    }
    else {
	pos = 0;
    }
    if (pos < 0) {
	pos += RSTRING(str)->len;
	if (pos < 0) {
	    if (TYPE(sub) == T_REGEXP) {
		rb_backref_set(Qnil);
	    }
	    return Qnil;
	}
    }

    switch (TYPE(sub)) {
      case T_REGEXP:
	pos = rb_reg_adjust_startpos(sub, str, pos, 0);
	pos = rb_reg_search(sub, str, pos, 0);
	break;

      case T_STRING:
	pos = rb_str_index(str, sub, pos);
	break;

      case T_FIXNUM:
      {
	  int c = FIX2INT(sub);
	  long len = RSTRING(str)->len;
	  char *p = RSTRING(str)->ptr;

	  for (;pos<len;pos++) {
	      if (p[pos] == c) return LONG2NUM(pos);
	  }
	  return Qnil;
      }

      default:
	rb_raise(rb_eTypeError, "type mismatch: %s given",
		 rb_class2name(CLASS_OF(sub)));
    }

    if (pos == -1) return Qnil;
    return LONG2NUM(pos);
}

static long
rb_str_rindex(str, sub, pos)
    VALUE str, sub;
    long pos;
{
    long len = RSTRING(sub)->len;
    char *s, *sbeg, *t;

    /* substring longer than string */
    if (RSTRING(str)->len < len) return -1;
    if (RSTRING(str)->len - pos < len) {
	pos = RSTRING(str)->len - len;
    }
    sbeg = RSTRING(str)->ptr;
    s = RSTRING(str)->ptr + pos;
    t = RSTRING(sub)->ptr;
    if (len) {
	while (sbeg <= s) {
	    if (rb_memcmp(s, t, len) == 0) {
		return s - RSTRING(str)->ptr;
	    }
	    s--;
	}
	return -1;
    }
    else {
	return pos;
    }
}

static VALUE
rb_str_rindex_m(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE sub;
    VALUE position;
    long pos;

    if (rb_scan_args(argc, argv, "11", &sub, &position) == 2) {
	pos = NUM2LONG(position);
        if (pos < 0) {
	    pos += RSTRING(str)->len;
	    if (pos < 0) {
		if (TYPE(sub) == T_REGEXP) {
		    rb_backref_set(Qnil);
		}
		return Qnil;
	    }
        }
	if (pos > RSTRING(str)->len) pos = RSTRING(str)->len;
    }
    else {
	pos = RSTRING(str)->len;
    }

    switch (TYPE(sub)) {
      case T_REGEXP:
	if (RREGEXP(sub)->len) {
	    pos = rb_reg_adjust_startpos(sub, str, pos, 1);
	    pos = rb_reg_search(sub, str, pos, 1);
	}
	if (pos >= 0) return LONG2NUM(pos);
	break;

      case T_STRING:
	pos = rb_str_rindex(str, sub, pos);
	if (pos >= 0) return LONG2NUM(pos);
	break;

      case T_FIXNUM:
      {
	  int c = FIX2INT(sub);
	  char *p = RSTRING(str)->ptr + pos;
	  char *pbeg = RSTRING(str)->ptr;

	  while (pbeg <= p) {
	      if (*p == c) return LONG2NUM(p - RSTRING(str)->ptr);
	      p--;
	  }
	  return Qnil;
      }

      default:
	rb_raise(rb_eTypeError, "type mismatch: %s given",
		 rb_class2name(CLASS_OF(sub)));
    }
    return Qnil;
}

static VALUE
rb_str_match(x, y)
    VALUE x, y;
{
    long start;

    switch (TYPE(y)) {
      case T_REGEXP:
	return rb_reg_match(y, x);

      case T_STRING:
	start = rb_str_index(x, y, 0);
	if (start == -1) {
	    return Qnil;
	}
	return LONG2NUM(start);

      default:
	return rb_funcall(y, rb_intern("=~"), 1, x);
    }
}

static VALUE
rb_str_match2(str)
    VALUE str;
{
    StringValue(str);
    return rb_reg_match2(rb_reg_regcomp(rb_reg_quote(str)));
}

static VALUE get_pat _((VALUE, int));

static VALUE
rb_str_match_m(str, re)
    VALUE str, re;
{
    return rb_funcall(get_pat(re, 0), rb_intern("match"), 1, str);
}

static char
succ_char(s)
    char *s;
{
    char c = *s;

    /* numerics */
    if ('0' <= c && c < '9') (*s)++;
    else if (c == '9') {
	*s = '0';
	return '1';
    }
    /* small alphabets */
    else if ('a' <= c && c < 'z') (*s)++;
    else if (c == 'z') {
	return *s = 'a';
    }
    /* capital alphabets */
    else if ('A' <= c && c < 'Z') (*s)++;
    else if (c == 'Z') {
	return *s = 'A';
    }
    return 0;
}

static VALUE
rb_str_succ(orig)
    VALUE orig;
{
    VALUE str;
    char *sbeg, *s;
    int c = -1;
    long n = 0;

    str = rb_str_new5(orig,RSTRING(orig)->ptr, RSTRING(orig)->len);
    OBJ_INFECT(str, orig);
    if (RSTRING(str)->len == 0) return str;

    sbeg = RSTRING(str)->ptr; s = sbeg + RSTRING(str)->len - 1;

    while (sbeg <= s) {
	if (ISALNUM(*s)) {
	    if ((c = succ_char(s)) == 0) break;
	    n = s - sbeg;
	}
	s--;
    }
    if (c == -1) {		/* str contains no alnum */
	sbeg = RSTRING(str)->ptr; s = sbeg + RSTRING(str)->len - 1;
	c = '\001';
	while (sbeg <= s) {
           if ((*s += 1) != 0) break;
           s--;
	}
    }
    if (s < sbeg) {
	RESIZE_CAPA(str, RSTRING(str)->len + 1);
	s = RSTRING(str)->ptr + n;
	memmove(s+1, s, RSTRING(str)->len - n);
	*s = c;
	RSTRING(str)->len += 1;
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
    }

    return str;
}

static VALUE
rb_str_succ_bang(str)
    VALUE str;
{
    rb_str_modify(str);
    rb_str_shared_replace(str, rb_str_succ(str));

    return str;
}

VALUE
rb_str_upto(beg, end, excl)
    VALUE beg, end;
    int excl;
{
    VALUE current;
    ID succ = rb_intern("succ");

    StringValue(end);
    current = beg;
    while (rb_str_cmp(current, end) <= 0) {
	rb_yield(current);
	if (!excl && rb_str_equal(current, end)) break;
	current = rb_funcall(current, succ, 0, 0);
	if (excl && rb_str_equal(current, end)) break;
	if (RSTRING(current)->len > RSTRING(end)->len)
	    break;
    }

    return beg;
}

static VALUE
rb_str_upto_m(beg, end)
    VALUE beg, end;
{
    return rb_str_upto(beg, end, 0);
}

static VALUE
rb_str_subpat(str, re, nth)
    VALUE str, re;
    int nth;
{
    if (rb_reg_search(re, str, 0, 0) >= 0) {
	return rb_reg_nth_match(nth, rb_backref_get());
    }
    return Qnil;
}
    
static VALUE
rb_str_aref(str, indx)
    VALUE str;
    VALUE indx;
{
    long idx;

    switch (TYPE(indx)) {
      case T_FIXNUM:
	idx = FIX2LONG(indx);

      num_index:
	if (idx < 0) {
	    idx = RSTRING(str)->len + idx;
	}
	if (idx < 0 || RSTRING(str)->len <= idx) {
	    return Qnil;
	}
	return INT2FIX(RSTRING(str)->ptr[idx] & 0xff);

      case T_REGEXP:
	return rb_str_subpat(str, indx, 0);

      case T_STRING:
	if (rb_str_index(str, indx, 0) != -1)
	    return rb_str_dup(indx);
	return Qnil;

      default:
	/* check if indx is Range */
	{
	    long beg, len;
	    switch (rb_range_beg_len(indx, &beg, &len, RSTRING(str)->len, 0)) {
	      case Qfalse:
		break;
	      case Qnil:
		return Qnil;
	      default:
		return rb_str_substr(str, beg, len);
	    }
	}
	idx = NUM2LONG(indx);
	goto num_index;
    }
    return Qnil;		/* not reached */
}

static VALUE
rb_str_aref_m(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    if (argc == 2) {
	if (TYPE(argv[0]) == T_REGEXP) {
	    return rb_str_subpat(str, argv[0], NUM2INT(argv[1]));
	}
	return rb_str_substr(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]));
    }
    if (argc != 1) {
	rb_raise(rb_eArgError, "wrong number of arguments(%d for 1)", argc);
    }
    return rb_str_aref(str, argv[0]);
}

void
rb_str_update(str, beg, len, val)
    VALUE str;
    long beg, len;
    VALUE val;
{
    if (len < 0) rb_raise(rb_eIndexError, "negative length %ld", len);
    if (RSTRING(str)->len < beg) {
      out_of_range:
	rb_raise(rb_eIndexError, "index %ld out of string", beg);
    }
    if (beg < 0) {
	if (-beg > RSTRING(str)->len) {
	    goto out_of_range;
	}
	beg += RSTRING(str)->len;
    }
    if (RSTRING(str)->len < beg + len) {
	len = RSTRING(str)->len - beg;
    }

    StringValue(val);
    if (len < RSTRING(val)->len) {
	/* expand string */
	RESIZE_CAPA(str, RSTRING(str)->len + RSTRING(val)->len - len);
    }

    if (RSTRING(val)->len != len) {
	memmove(RSTRING(str)->ptr + beg + RSTRING(val)->len,
		RSTRING(str)->ptr + beg + len,
		RSTRING(str)->len - (beg + len));
    }
    if (RSTRING(str)->len < beg && len < 0) {
	MEMZERO(RSTRING(str)->ptr + RSTRING(str)->len, char, -len);
    }
    if (RSTRING(val)->len > 0) {
	memmove(RSTRING(str)->ptr+beg, RSTRING(val)->ptr, RSTRING(val)->len);
    }
    RSTRING(str)->len += RSTRING(val)->len - len;
    RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
    OBJ_INFECT(str, val);
}

static void
rb_str_subpat_set(str, re, nth, val)
    VALUE str, re;
    int nth;
    VALUE val;
{
    VALUE match;
    long start, end, len;

    if (rb_reg_search(re, str, 0, 0) < 0) {
	rb_raise(rb_eIndexError, "regexp not matched");
    }
    match = rb_backref_get();
    if (nth >= RMATCH(match)->regs->num_regs) {
      out_of_range:
	rb_raise(rb_eIndexError, "index %d out of regexp", nth);
    }
    if (nth < 0) {
	if (-nth >= RMATCH(match)->regs->num_regs) {
	    goto out_of_range;
	}
	nth += RMATCH(match)->regs->num_regs;
    }

    start = RMATCH(match)->BEG(nth);
    if (start == -1) {
	rb_raise(rb_eIndexError, "regexp group %d not matched", nth);
    }
    end = RMATCH(match)->END(nth);
    len = end - start;
    rb_str_modify(str);
    rb_str_update(str, start, len, val);
}

static VALUE
rb_str_aset(str, indx, val)
    VALUE str;
    VALUE indx, val;
{
    long idx, beg;

    switch (TYPE(indx)) {
      case T_FIXNUM:
      num_index:
	idx = NUM2LONG(indx);
	if (RSTRING(str)->len <= idx) {
	  out_of_range:
	    rb_raise(rb_eIndexError, "index %ld out of string", idx);
	}
	if (idx < 0) {
	    if (-idx > RSTRING(str)->len)
		goto out_of_range;
	    idx += RSTRING(str)->len;
	}
	if (FIXNUM_P(val)) {
	    if (RSTRING(str)->len == idx) {
		RSTRING(str)->len += 1;
		RESIZE_CAPA(str, RSTRING(str)->len);
	    }
	    RSTRING(str)->ptr[idx] = NUM2INT(val) & 0xff;
	}
	else {
	    rb_str_update(str, idx, 1, val);
	}
	return val;

      case T_REGEXP:
	rb_str_subpat_set(str, indx, 0, val);
	return val;

      case T_STRING:
	beg = rb_str_index(str, indx, 0);
	if (beg < 0) {
	    rb_raise(rb_eIndexError, "string not matched");
	}
	rb_str_update(str, beg, RSTRING(indx)->len, val);
	return val;

      default:
	/* check if indx is Range */
	{
	    long beg, len;
	    if (rb_range_beg_len(indx, &beg, &len, RSTRING(str)->len, 2)) {
		rb_str_update(str, beg, len, val);
		return val;
	    }
	}
	idx = NUM2LONG(indx);
	goto num_index;
    }
}

static VALUE
rb_str_aset_m(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    rb_str_modify(str);
    if (argc == 3) {
	if (TYPE(argv[0]) == T_REGEXP) {
	    rb_str_subpat_set(str, argv[0], NUM2INT(argv[1]), argv[2]);
	}
	else {
	    rb_str_update(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]), argv[2]);
	}
	return argv[2];
    }
    if (argc != 2) {
	rb_raise(rb_eArgError, "wrong number of arguments(%d for 2)", argc);
    }
    return rb_str_aset(str, argv[0], argv[1]);
}

static VALUE
rb_str_insert(str, idx, str2)
    VALUE str, idx, str2;
{
    long pos = NUM2LONG(idx);

    rb_str_modify(str);
    if (pos == -1) {
	pos = RSTRING(str)->len;
    }
    else if (pos < 0) {
	pos++;
    }
    rb_str_update(str, pos, 0, str2);
    return str;
}

static VALUE
rb_str_slice_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE result;
    VALUE buf[3];
    int i;

    if (argc < 1 || 2 < argc) {
	rb_raise(rb_eArgError, "wrong number of arguments(%d for 1)", argc);
    }
    for (i=0; i<argc; i++) {
	buf[i] = argv[i];
    }
    buf[i] = rb_str_new(0,0);
    result = rb_str_aref_m(argc, buf, str);
    if (!NIL_P(result)) {
	rb_str_aset_m(argc+1, buf, str);
    }
    return result;
}

static VALUE
get_pat(pat, quote)
    VALUE pat;
    int quote;
{
    VALUE val;

    switch (TYPE(pat)) {
      case T_REGEXP:
	return pat;

      case T_STRING:
	break;

      default:
	val = rb_check_convert_type(pat, T_STRING, "String", "to_str");
	if (NIL_P(val)) {
	    Check_Type(pat, T_REGEXP);
	}
	pat = val;
    }

    if (quote) {
	val = rb_reg_quote(pat);
#if RUBY_VERSION_CODE < 180
	if (val != pat && rb_str_cmp(val, pat) != 0) {
	    rb_warn("string pattern instead of regexp; metacharacters no longer effective");
	}
#endif
	pat = val;
    }

    return rb_reg_regcomp(pat);
}

static VALUE
rb_str_sub_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE pat, repl, match;
    struct re_registers *regs;
    int iter = 0;
    int tainted = 0;
    long plen;

    if (argc == 1 && rb_block_given_p()) {
	iter = 1;
    }
    else if (argc == 2) {
	repl = argv[1];
	StringValue(repl);
	if (OBJ_TAINTED(repl)) tainted = 1;
    }
    else {
	rb_raise(rb_eArgError, "wrong number of arguments(%d for 2)", argc);
    }

    pat = get_pat(argv[0], 1);
    if (rb_reg_search(pat, str, 0, 0) >= 0) {
	rb_str_modify(str);
	match = rb_backref_get();
	regs = RMATCH(match)->regs;

	if (iter) {
	    rb_match_busy(match);
	    repl = rb_obj_as_string(rb_yield(rb_reg_nth_match(0, match)));
	    rb_backref_set(match);
	}
	else {
	    repl = rb_reg_regsub(repl, str, regs);
	}
	if (OBJ_TAINTED(repl)) tainted = 1;
	plen = END(0) - BEG(0);
	if (RSTRING(repl)->len > plen) {
	    RESIZE_CAPA(str, RSTRING(str)->len + RSTRING(repl)->len - plen);
	}
	if (RSTRING(repl)->len != plen) {
	    memmove(RSTRING(str)->ptr + BEG(0) + RSTRING(repl)->len,
		    RSTRING(str)->ptr + BEG(0) + plen,
		    RSTRING(str)->len - BEG(0) - plen);
	}
	memcpy(RSTRING(str)->ptr + BEG(0),
	       RSTRING(repl)->ptr, RSTRING(repl)->len);
	RSTRING(str)->len += RSTRING(repl)->len - plen;
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
	if (tainted) OBJ_TAINT(str);

	return str;
    }
    return Qnil;
}

static VALUE
rb_str_sub(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_sub_bang(argc, argv, str);
    return str;
}

static VALUE
str_gsub(argc, argv, str, bang)
    int argc;
    VALUE *argv;
    VALUE str;
    int bang;
{
    VALUE pat, val, repl, match;
    struct re_registers *regs;
    long beg, n;
    long offset, blen, len;
    int iter = 0;
    char *buf, *bp, *cp;
    int tainted = 0;

    if (argc == 1 && rb_block_given_p()) {
	iter = 1;
    }
    else if (argc == 2) {
	repl = argv[1];
	StringValue(repl);
	if (OBJ_TAINTED(repl)) tainted = 1;
    }
    else {
	rb_raise(rb_eArgError, "wrong number of arguments(%d for 2)", argc);
    }

    pat = get_pat(argv[0], 1);
    offset=0; n=0; 
    beg = rb_reg_search(pat, str, 0, 0);
    if (beg < 0) {
	if (bang) return Qnil;	/* no match, no substitution */
	return rb_str_dup(str);
    }

    blen = RSTRING(str)->len + 30; /* len + margin */
    buf = ALLOC_N(char, blen);
    bp = buf;
    cp = RSTRING(str)->ptr;

    while (beg >= 0) {
	n++;
	match = rb_backref_get();
	regs = RMATCH(match)->regs;
	if (iter) {
	    rb_match_busy(match);
	    val = rb_obj_as_string(rb_yield(rb_reg_nth_match(0, match)));
	    rb_backref_set(match);
	}
	else {
	    val = rb_reg_regsub(repl, str, regs);
	}
	if (OBJ_TAINTED(val)) tainted = 1;
	len = (bp - buf) + (beg - offset) + RSTRING(val)->len + 3;
	if (blen < len) {
	    while (blen < len) blen *= 2;
	    len = bp - buf;
	    REALLOC_N(buf, char, blen);
	    bp = buf + len;
	}
	len = beg - offset;	/* copy pre-match substr */
	memcpy(bp, cp, len);
	bp += len;
	memcpy(bp, RSTRING(val)->ptr, RSTRING(val)->len);
	bp += RSTRING(val)->len;
	if (BEG(0) == END(0)) {
	    /*
	     * Always consume at least one character of the input string
	     * in order to prevent infinite loops.
	     */
	    len = mbclen2(RSTRING(str)->ptr[END(0)], pat);
	    if (RSTRING(str)->len > END(0)) {
		memcpy(bp, RSTRING(str)->ptr+END(0), len);
		bp += len;
	    }
	    offset = END(0) + len;
	}
	else {
	    offset = END(0);
	}
	cp = RSTRING(str)->ptr + offset;
	if (offset > RSTRING(str)->len) break;
	beg = rb_reg_search(pat, str, offset, 0);
    }
    if (RSTRING(str)->len > offset) {
	len = bp - buf;
	if (blen - len < RSTRING(str)->len - offset + 1) {
	    REALLOC_N(buf, char, len + RSTRING(str)->len - offset + 1);
	    bp = buf + len;
	}
	memcpy(bp, cp, RSTRING(str)->len - offset);
	bp += RSTRING(str)->len - offset;
    }
    rb_backref_set(match);
    if (bang) {
	if (str_independent(str)) {
	    free(RSTRING(str)->ptr);
	}
	FL_UNSET(str, ELTS_SHARED|STR_ASSOC);
    }
    else {
	VALUE dup = rb_obj_alloc(rb_obj_class(str));

	OBJ_INFECT(dup, str);
	str = dup;
    }
    RSTRING(str)->ptr = buf;
    RSTRING(str)->len = len = bp - buf;
    RSTRING(str)->ptr[len] = '\0';
    RSTRING(str)->aux.capa = len;

    if (tainted) OBJ_TAINT(str);
    return str;
}

static VALUE
rb_str_gsub_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return str_gsub(argc, argv, str, 1);
}

static VALUE
rb_str_gsub(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return str_gsub(argc, argv, str, 0);
}

static VALUE
rb_str_replace(str, str2)
    VALUE str, str2;
{
    if (str == str2) return str;

    StringValue(str2);
    if (FL_TEST(str2, ELTS_SHARED)) {
	if (str_independent(str)) {
	    free(RSTRING(str)->ptr);
	}
	RSTRING(str)->len = RSTRING(str2)->len;
	RSTRING(str)->ptr = RSTRING(str2)->ptr;
	FL_SET(str, ELTS_SHARED);
	RSTRING(str)->aux.shared = RSTRING(str2)->aux.shared;
    }
    else {
	rb_str_modify(str);
	rb_str_resize(str, RSTRING(str2)->len);
	memcpy(RSTRING(str)->ptr, RSTRING(str2)->ptr, RSTRING(str2)->len);
	if (FL_TEST(str2, STR_ASSOC)) {
	    FL_SET(str, STR_ASSOC);
	    RSTRING(str)->aux.shared = RSTRING(str2)->aux.shared;
	}
    }

    OBJ_INFECT(str, str2);
    return str;
}

static VALUE
uscore_get()
{
    VALUE line;

    line = rb_lastline_get();
    if (TYPE(line) != T_STRING) {
	rb_raise(rb_eTypeError, "$_ value need to be String (%s given)",
		 NIL_P(line) ? "nil" : rb_class2name(CLASS_OF(line)));
    }
    return line;
}

static VALUE
rb_f_sub_bang(argc, argv)
    int argc;
    VALUE *argv;
{
    return rb_str_sub_bang(argc, argv, uscore_get());
}

static VALUE
rb_f_sub(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE str = rb_str_dup(uscore_get());

    if (NIL_P(rb_str_sub_bang(argc, argv, str)))
	return str;
    rb_lastline_set(str);
    return str;
}

static VALUE
rb_f_gsub_bang(argc, argv)
    int argc;
    VALUE *argv;
{
    return rb_str_gsub_bang(argc, argv, uscore_get());
}

static VALUE
rb_f_gsub(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE str = rb_str_dup(uscore_get());

    if (NIL_P(rb_str_gsub_bang(argc, argv, str)))
	return str;
    rb_lastline_set(str);
    return str;
}

static VALUE
rb_str_reverse_bang(str)
    VALUE str;
{
    char *s, *e;
    char c;

    rb_str_modify(str);
    s = RSTRING(str)->ptr;
    e = s + RSTRING(str)->len - 1;
    while (s < e) {
	c = *s;
	*s++ = *e;
	*e-- = c;
    }

    return str;
}

static VALUE
rb_str_reverse(str)
    VALUE str;
{
    VALUE obj;
    char *s, *e, *p;

    if (RSTRING(str)->len <= 1) return rb_str_dup(str);

    obj = rb_str_new5(str, 0, RSTRING(str)->len);
    s = RSTRING(str)->ptr; e = s + RSTRING(str)->len - 1;
    p = RSTRING(obj)->ptr;

    while (e >= s) {
	*p++ = *e--;
    }
    OBJ_INFECT(obj, str);

    return obj;
}

static VALUE
rb_str_include(str, arg)
    VALUE str, arg;
{
    long i;

    if (FIXNUM_P(arg)) {
	int c = FIX2INT(arg);
	long len = RSTRING(str)->len;
	char *p = RSTRING(str)->ptr;

	for (i=0; i<len; i++) {
	    if (p[i] == c) {
		return Qtrue;
	    }
	}
	return Qfalse;
    }

    StringValue(arg);
    i = rb_str_index(str, arg, 0);

    if (i == -1) return Qfalse;
    return Qtrue;
}

static VALUE
rb_str_to_i(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE b;
    int base;

    rb_scan_args(argc, argv, "01", &b);
    if (argc == 0) base = 10;
    else base = NUM2INT(b);

    switch (base) {
      case 0: case 2: case 8: case 10: case 16:
	break;
      default:
	rb_raise(rb_eArgError, "illegal radix %d", base);
    }
    return rb_str_to_inum(str, base, Qfalse);
}

static VALUE
rb_str_to_f(str)
    VALUE str;
{
    return rb_float_new(rb_str_to_dbl(str, Qfalse));
}

static VALUE
rb_str_to_s(str)
    VALUE str;
{
    return str;
}

VALUE
rb_str_inspect(str)
    VALUE str;
{
    char *p, *pend;
    VALUE result = rb_str_buf_new2("\"");
    char s[5];

    p = RSTRING(str)->ptr; pend = p + RSTRING(str)->len;
    while (p < pend) {
	char c = *p++;
	if (ismbchar(c) && p < pend) {
	    int len = mbclen(c);
	    rb_str_buf_cat(result, p - 1, len);
	    p += len - 1;
	}
	else if (c == '"'|| c == '\\') {
	    s[0] = '\\'; s[1] = c;
	    rb_str_buf_cat(result, s, 2);
	}
	else if (ISPRINT(c)) {
	    s[0] = c;
	    rb_str_buf_cat(result, s, 1);
	}
	else if (c == '\n') {
	    s[0] = '\\'; s[1] = 'n';
	    rb_str_buf_cat(result, s, 2);
	}
	else if (c == '\r') {
	    s[0] = '\\'; s[1] = 'r';
	    rb_str_buf_cat(result, s, 2);
	}
	else if (c == '\t') {
	    s[0] = '\\'; s[1] = 't';
	    rb_str_buf_cat(result, s, 2);
	}
	else if (c == '\f') {
	    s[0] = '\\'; s[1] = 'f';
	    rb_str_buf_cat(result, s, 2);
	}
	else if (c == '\013') {
	    s[0] = '\\'; s[1] = 'v';
	    rb_str_buf_cat(result, s, 2);
	}
	else if (c == '\007') {
	    s[0] = '\\'; s[1] = 'a';
	    rb_str_buf_cat(result, s, 2);
	}
	else if (c == 033) {
	    s[0] = '\\'; s[1] = 'e';
	    rb_str_buf_cat(result, s, 2);
	}
	else {
	    sprintf(s, "\\%03o", c & 0377);
	    rb_str_buf_cat2(result, s);
	}
    }
    rb_str_buf_cat2(result, "\"");

    OBJ_INFECT(result, str);
    return result;
}

VALUE
rb_str_dump(str)
    VALUE str;
{
    long len;
    char *p, *pend;
    char *q, *qend;
    VALUE result;

    len = 2;			/* "" */
    p = RSTRING(str)->ptr; pend = p + RSTRING(str)->len;
    while (p < pend) {
	char c = *p++;
	switch (c) {
	  case '"':  case '\\':
	  case '\n': case '\r':
	  case '\t': case '\f': case '#':
	  case '\013': case '\007': case '\033': 
	    len += 2;
	    break;

	  default:
	    if (ISPRINT(c)) {
		len++;
	    }
	    else {
		len += 4;		/* \nnn */
	    }
	    break;
	}
    }

    result = rb_str_new5(str, 0, len);
    p = RSTRING(str)->ptr; pend = p + RSTRING(str)->len;
    q = RSTRING(result)->ptr; qend = q + len;

    *q++ = '"';
    while (p < pend) {
	char c = *p++;

	if (c == '"' || c == '\\') {
	    *q++ = '\\';
	    *q++ = c;
	}
	else if (c == '#') {
	    *q++ = '\\';
	    *q++ = '#';
	}
	else if (ISPRINT(c)) {
	    *q++ = c;
	}
	else if (c == '\n') {
	    *q++ = '\\';
	    *q++ = 'n';
	}
	else if (c == '\r') {
	    *q++ = '\\';
	    *q++ = 'r';
	}
	else if (c == '\t') {
	    *q++ = '\\';
	    *q++ = 't';
	}
	else if (c == '\f') {
	    *q++ = '\\';
	    *q++ = 'f';
	}
	else if (c == '\013') {
	    *q++ = '\\';
	    *q++ = 'v';
	}
	else if (c == '\007') {
	    *q++ = '\\';
	    *q++ = 'a';
	}
	else if (c == '\033') {
	    *q++ = '\\';
	    *q++ = 'e';
	}
	else {
	    *q++ = '\\';
	    sprintf(q, "%03o", c&0xff);
	    q += 3;
	}
    }
    *q++ = '"';

    OBJ_INFECT(result, str);
    return result;
}

static VALUE
rb_str_upcase_bang(str)
    VALUE str;
{
    char *s, *send;
    int modify = 0;

    rb_str_modify(str);
    s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
    while (s < send) {
	if (ismbchar(*s)) {
	    s+=mbclen(*s) - 1;
	}
	else if (ISLOWER(*s)) {
	    *s = toupper(*s);
	    modify = 1;
	}
	s++;
    }

    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_upcase(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_upcase_bang(str);
    return str;
}

static VALUE
rb_str_downcase_bang(str)
    VALUE str;
{
    char *s, *send;
    int modify = 0;

    rb_str_modify(str);
    s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
    while (s < send) {
	if (ismbchar(*s)) {
	    s+=mbclen(*s) - 1;
	}
	else if (ISUPPER(*s)) {
	    *s = tolower(*s);
	    modify = 1;
	}
	s++;
    }

    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_downcase(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_downcase_bang(str);
    return str;
}

static VALUE
rb_str_capitalize_bang(str)
    VALUE str;
{
    char *s, *send;
    int modify = 0;

    rb_str_modify(str);
    s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
    if (ISLOWER(*s)) {
	*s = toupper(*s);
	modify = 1;
    }
    while (++s < send) {
	if (ismbchar(*s)) {
	    s+=mbclen(*s) - 1;
	}
	else if (ISUPPER(*s)) {
	    *s = tolower(*s);
	    modify = 1;
	}
    }
    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_capitalize(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_capitalize_bang(str);
    return str;
}

static VALUE
rb_str_swapcase_bang(str)
    VALUE str;
{
    char *s, *send;
    int modify = 0;

    rb_str_modify(str);
    s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
    while (s < send) {
	if (ismbchar(*s)) {
	    s+=mbclen(*s) - 1;
	}
	else if (ISUPPER(*s)) {
	    *s = tolower(*s);
	    modify = 1;
	}
	else if (ISLOWER(*s)) {
	    *s = toupper(*s);
	    modify = 1;
	}
	s++;
    }

    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_swapcase(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_swapcase_bang(str);
    return str;
}

typedef unsigned char *USTR;

struct tr {
    int gen, now, max;
    char *p, *pend;
};

static int
trnext(t)
    struct tr *t;
{
    for (;;) {
	if (!t->gen) {
	    if (t->p == t->pend) return -1;
	    if (t->p < t->pend - 1 && *t->p == '\\') {
		t->p++;
	    }
	    t->now = *(USTR)t->p++;
	    if (t->p < t->pend - 1 && *t->p == '-') {
		t->p++;
		if (t->p < t->pend) {
		    if (t->now > *(USTR)t->p) {
			t->p++;
			continue;
		    }
		    t->gen = 1;
		    t->max = *(USTR)t->p++;
		}
	    }
	    return t->now;
	}
	else if (++t->now < t->max) {
	    return t->now;
	}
	else {
	    t->gen = 0;
	    return t->max;
	}
    }
}

static VALUE rb_str_delete_bang _((int,VALUE*,VALUE));

static VALUE
tr_trans(str, src, repl, sflag)
    VALUE str, src, repl;
    int sflag;
{
    struct tr trsrc, trrepl;
    int cflag = 0;
    int trans[256];
    int i, c, modify = 0;
    char *s, *send;

    rb_str_modify(str);
    StringValue(src);
    StringValue(repl);
    if (RSTRING(str)->len == 0 || !RSTRING(str)->ptr) return Qnil;
    trsrc.p = RSTRING(src)->ptr; trsrc.pend = trsrc.p + RSTRING(src)->len;
    if (RSTRING(src)->len >= 2 && RSTRING(src)->ptr[0] == '^') {
	cflag++;
	trsrc.p++;
    }
    if (RSTRING(repl)->len == 0) {
	return rb_str_delete_bang(1, &src, str);
    }
    trrepl.p = RSTRING(repl)->ptr;
    trrepl.pend = trrepl.p + RSTRING(repl)->len;
    trsrc.gen = trrepl.gen = 0;
    trsrc.now = trrepl.now = 0;
    trsrc.max = trrepl.max = 0;

    if (cflag) {
	for (i=0; i<256; i++) {
	    trans[i] = 1;
	}
	while ((c = trnext(&trsrc)) >= 0) {
	    trans[c & 0xff] = -1;
	}
	while ((c = trnext(&trrepl)) >= 0)
	    /* retrieve last replacer */;
	for (i=0; i<256; i++) {
	    if (trans[i] >= 0) {
		trans[i] = trrepl.now;
	    }
	}
    }
    else {
	int r;

	for (i=0; i<256; i++) {
	    trans[i] = -1;
	}
	while ((c = trnext(&trsrc)) >= 0) {
	    r = trnext(&trrepl);
	    if (r == -1) r = trrepl.now;
	    trans[c & 0xff] = r;
	}
    }

    s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
    if (sflag) {
	char *t = s;
	int c0, last = -1;

	while (s < send) {
	    c0 = *s++;
	    if ((c = trans[c0 & 0xff]) >= 0) {
		if (last == c) continue;
		last = c;
		*t++ = c & 0xff;
		modify = 1;
	    }
	    else {
		last = -1;
		*t++ = c0;
	    }
	}
	if (RSTRING(str)->len > (t - RSTRING(str)->ptr)) {
	    RSTRING(str)->len = (t - RSTRING(str)->ptr);
	    modify = 1;
	    *t = '\0';
	}
    }
    else {
	while (s < send) {
	    if ((c = trans[*s & 0xff]) >= 0) {
		*s = c & 0xff;
		modify = 1;
	    }
	    s++;
	}
    }

    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_tr_bang(str, src, repl)
    VALUE str, src, repl;
{
    return tr_trans(str, src, repl, 0);
}

static VALUE
rb_str_tr(str, src, repl)
    VALUE str, src, repl;
{
    str = rb_str_dup(str);
    tr_trans(str, src, repl, 0);
    return str;
}

static void
tr_setup_table(str, table, init)
    VALUE str;
    char table[256];
    int init;
{
    char buf[256];
    struct tr tr;
    int i, c;
    int cflag = 0;

    tr.p = RSTRING(str)->ptr; tr.pend = tr.p + RSTRING(str)->len;
    tr.gen = tr.now = tr.max = 0;
    if (RSTRING(str)->len > 1 && RSTRING(str)->ptr[0] == '^') {
	cflag = 1;
	tr.p++;
    }

    if (init) {
	for (i=0; i<256; i++) {
	    table[i] = 1;
	}
    }
    for (i=0; i<256; i++) {
	buf[i] = cflag;
    }
    while ((c = trnext(&tr)) >= 0) {
	buf[c & 0xff] = !cflag;
    }
    for (i=0; i<256; i++) {
	table[i] = table[i]&&buf[i];
    }
}

static VALUE
rb_str_delete_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    char *s, *send, *t;
    char squeez[256];
    int modify = 0;
    int init = 1;
    int i;

    if (argc < 1) {
	rb_raise(rb_eArgError, "wrong number of arguments");
    }
    rb_str_modify(str);
    for (i=0; i<argc; i++) {
	VALUE s = argv[i];

	StringValue(s);
	tr_setup_table(s, squeez, init);
	init = 0;
    }

    s = t = RSTRING(str)->ptr;
    if (!s || RSTRING(str)->len == 0) return Qnil;
    send = s + RSTRING(str)->len;
    while (s < send) {
	if (squeez[*s & 0xff])
	    modify = 1;
	else
	    *t++ = *s;
	s++;
    }
    *t = '\0';
    RSTRING(str)->len = t - RSTRING(str)->ptr;

    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_delete(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_delete_bang(argc, argv, str);
    return str;
}

static VALUE
rb_str_squeeze_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    char squeez[256];
    char *s, *send, *t;
    int c, save, modify = 0;
    int init = 1;
    int i;

    rb_str_modify(str);
    if (argc == 0) {
	for (i=0; i<256; i++) {
	    squeez[i] = 1;
	}
    }
    else {
	for (i=0; i<argc; i++) {
	    VALUE s = argv[i];

	    StringValue(s);
	    tr_setup_table(s, squeez, init);
	    init = 0;
	}
    }

    s = t = RSTRING(str)->ptr;
    if (!s || RSTRING(str)->len == 0) return Qnil;
    send = s + RSTRING(str)->len;
    save = -1;
    while (s < send) {
	c = *s++ & 0xff;
	if (c != save || !squeez[c]) {
	    *t++ = save = c;
	}
    }
    *t = '\0';
    if (t - RSTRING(str)->ptr != RSTRING(str)->len) {
	RSTRING(str)->len = t - RSTRING(str)->ptr;
	modify = 1;
    }

    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_squeeze(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_squeeze_bang(argc, argv, str);
    return str;
}

static VALUE
rb_str_tr_s_bang(str, src, repl)
    VALUE str, src, repl;
{
    return tr_trans(str, src, repl, 1);
}

static VALUE
rb_str_tr_s(str, src, repl)
    VALUE str, src, repl;
{
    str = rb_str_dup(str);
    tr_trans(str, src, repl, 1);
    return str;
}

static VALUE
rb_str_count(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    char table[256];
    char *s, *send;
    int init = 1;
    int i;

    if (argc < 1) {
	rb_raise(rb_eArgError, "wrong number of arguments");
    }
    for (i=0; i<argc; i++) {
	VALUE s = argv[i];

	StringValue(s);
	tr_setup_table(s, table, init);
	init = 0;
    }

    s = RSTRING(str)->ptr;
    if (!s || RSTRING(str)->len == 0) return Qnil;
    send = s + RSTRING(str)->len;
    i = 0;
    while (s < send) {
	if (table[*s++ & 0xff]) {
	    i++;
	}
    }
    return INT2NUM(i);
}

static VALUE
rb_str_split_m(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE spat;
    VALUE limit;
    int awk_split = Qfalse;
    long beg, end, i = 0;
    int lim = 0;
    VALUE result, tmp;

    if (rb_scan_args(argc, argv, "02", &spat, &limit) == 2) {
	lim = NUM2INT(limit);
	if (lim <= 0) limit = Qnil;
	else if (lim == 1) return rb_ary_new3(1, str);
	i = 1;
    }

    if (NIL_P(spat)) {
	if (!NIL_P(rb_fs)) {
	    spat = rb_fs;
	    goto fs_set;
	}
	awk_split = Qtrue;
    }
    else {
      fs_set:
	if (TYPE(spat) == T_STRING && RSTRING(spat)->len == 1) {
	    if (RSTRING(spat)->ptr[0] == ' ') {
		awk_split = Qtrue;
	    }
	    else {
		spat = rb_reg_regcomp(rb_reg_quote(spat));
	    }
	}
	else {
	    spat = get_pat(spat, 1);
	}
    }

    result = rb_ary_new();
    beg = 0;
    if (awk_split) {
	char *ptr = RSTRING(str)->ptr;
	long len = RSTRING(str)->len;
	char *eptr = ptr + len;
	int skip = 1;

	for (end = beg = 0; ptr<eptr; ptr++) {
	    if (skip) {
		if (ISSPACE(*ptr)) {
		    beg++;
		}
		else {
		    end = beg+1;
		    skip = 0;
		}
	    }
	    else {
		if (ISSPACE(*ptr)) {
		    rb_ary_push(result, rb_str_substr(str, beg, end-beg));
		    skip = 1;
		    beg = end + 1;
		    if (!NIL_P(limit) && lim <= ++i) break;
		}
		else {
		    end++;
		}
	    }
	}
    }
    else {
	long start = beg;
	long idx;
	int last_null = 0;
	struct re_registers *regs;

	while ((end = rb_reg_search(spat, str, start, 0)) >= 0) {
	    regs = RMATCH(rb_backref_get())->regs;
	    if (start == end && BEG(0) == END(0)) {
		if (!RSTRING(str)->ptr) {
		    rb_ary_push(result, rb_str_new("", 0));
		    break;
                }
		else if (last_null == 1) {
		    rb_ary_push(result, rb_str_substr(str, beg, mbclen2(RSTRING(str)->ptr[beg],spat)));
		    beg = start;
		}
		else {
		    start += mbclen2(RSTRING(str)->ptr[start],spat);
		    last_null = 1;
		    continue;
		}
	    }
	    else {
		rb_ary_push(result, rb_str_substr(str, beg, end-beg));
		beg = start = END(0);
	    }
	    last_null = 0;

	    for (idx=1; idx < regs->num_regs; idx++) {
		if (BEG(idx) == -1) continue;
		if (BEG(idx) == END(idx))
		    tmp = rb_str_new5(str, 0, 0);
		else
		    tmp = rb_str_substr(str, BEG(idx), END(idx)-BEG(idx));
		rb_ary_push(result, tmp);
	    }
	    if (!NIL_P(limit) && lim <= ++i) break;
	}
    }
    if (!NIL_P(limit) || RSTRING(str)->len > beg || lim < 0) {
	if (RSTRING(str)->len == beg)
	    tmp = rb_str_new5(str, 0, 0);
	else
	    tmp = rb_str_substr(str, beg, RSTRING(str)->len-beg);
	rb_ary_push(result, tmp);
    }
    if (NIL_P(limit) && lim == 0) {
	while (RARRAY(result)->len > 0 &&
	       RSTRING(RARRAY(result)->ptr[RARRAY(result)->len-1])->len == 0)
	    rb_ary_pop(result);
    }

    return result;
}

VALUE
rb_str_split(str, sep0)
    VALUE str;
    const char *sep0;
{
    VALUE sep;

    StringValue(str);
    sep = rb_str_new2(sep0);
    return rb_str_split_m(1, &sep, str);
}

static VALUE
rb_f_split(argc, argv)
    int argc;
    VALUE *argv;
{
    return rb_str_split_m(argc, argv, uscore_get());
}

static VALUE
rb_str_each_line(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE rs;
    int newline;
    char *p = RSTRING(str)->ptr, *pend = p + RSTRING(str)->len, *s;
    char *ptr = p;
    long len = RSTRING(str)->len, rslen;
    VALUE line;

    if (rb_scan_args(argc, argv, "01", &rs) == 0) {
	rs = rb_rs;
    }

    if (NIL_P(rs)) {
	rb_yield(str);
	return str;
    }
    StringValue(rs);
    rslen = RSTRING(rs)->len;
    if (rslen == 0) {
	newline = '\n';
    }
    else {
	newline = RSTRING(rs)->ptr[rslen-1];
    }

    for (s = p, p += rslen; p < pend; p++) {
	if (rslen == 0 && *p == '\n') {
	    if (*++p != '\n') continue;
	    while (*p == '\n') p++;
	}
	if (RSTRING(str)->ptr < p && p[-1] == newline &&
	    (rslen <= 1 ||
	     rb_memcmp(RSTRING(rs)->ptr, p-rslen, rslen) == 0)) {
	    line = rb_str_new5(str, s, p - s);
	    OBJ_INFECT(line, str);
	    rb_yield(line);
	    if (RSTRING(str)->ptr != ptr || RSTRING(str)->len != len)
		rb_raise(rb_eArgError, "string modified");
	    s = p;
	}
    }

    if (s != pend) {
        if (p > pend) p = pend;
	line = rb_str_new5(str, s, p - s);
	OBJ_INFECT(line, str);
	rb_yield(line);
    }

    return str;
}

static VALUE
rb_str_each_byte(str)
    VALUE str;
{
    long i;

    for (i=0; i<RSTRING(str)->len; i++) {
	rb_yield(INT2FIX(RSTRING(str)->ptr[i] & 0xff));
    }
    return str;
}

static VALUE
rb_str_chop_bang(str)
    VALUE str;
{
    if (RSTRING(str)->len > 0) {
	rb_str_modify(str);
	RSTRING(str)->len--;
	if (RSTRING(str)->ptr[RSTRING(str)->len] == '\n') {
	    if (RSTRING(str)->len > 0 &&
		RSTRING(str)->ptr[RSTRING(str)->len-1] == '\r') {
		RSTRING(str)->len--;
	    }
	}
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
	return str;
    }
    return Qnil;
}

static VALUE
rb_str_chop(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_chop_bang(str);
    return str;
}

static VALUE
rb_f_chop_bang(str)
    VALUE str;
{
    return rb_str_chop_bang(uscore_get());
}

static VALUE
rb_f_chop()
{
    VALUE str = uscore_get();

    if (RSTRING(str)->len > 0) {
	str = rb_str_dup(str);
	rb_str_chop_bang(str);
	rb_lastline_set(str);
    }
    return str;
}

static VALUE
rb_str_chomp_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE rs;
    int newline;
    char *p = RSTRING(str)->ptr;
    long len = RSTRING(str)->len, rslen;

    if (rb_scan_args(argc, argv, "01", &rs) == 0) {
	if (len == 0) return Qnil;
	rs = rb_rs;
	if (rs == rb_default_rs) {
	  smart_chomp:
	    rb_str_modify(str);
	    if (RSTRING(str)->ptr[len-1] == '\n') {
		RSTRING(str)->len--;
		if (RSTRING(str)->len > 0 &&
		    RSTRING(str)->ptr[RSTRING(str)->len-1] == '\r') {
		    RSTRING(str)->len--;
		}
	    }
	    else if (RSTRING(str)->ptr[len-1] == '\r') {
		RSTRING(str)->len--;
	    }
	    else {
		return Qnil;
	    }
	    RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
	    return str;
	}
    }
    if (NIL_P(rs)) return Qnil;
    if (len == 0) return Qnil;

    StringValue(rs);
    rb_str_modify(str);
    rslen = RSTRING(rs)->len;
    if (rslen == 0) {
	while (len>0 && p[len-1] == '\n') {
	    len--;
	    if (len>0 && p[len-1] == '\r')
		len--;
	}
	if (len < RSTRING(str)->len) {
	    rb_str_modify(str);
	    RSTRING(str)->len = len;
	    RSTRING(str)->ptr[len] = '\0';
	    return str;
	}
	return Qnil;
    }
    if (rslen > len) return Qnil;
    newline = RSTRING(rs)->ptr[rslen-1];
    if (rslen == 1 && newline == '\n')
	goto smart_chomp;

    if (p[len-1] == newline &&
	(rslen <= 1 ||
	 rb_memcmp(RSTRING(rs)->ptr, p+len-rslen, rslen) == 0)) {
	rb_str_modify(str);
	RSTRING(str)->len -= rslen;
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
	return str;
    }
    return Qnil;
}

static VALUE
rb_str_chomp(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_chomp_bang(argc, argv, str);
    return str;
}

static VALUE
rb_f_chomp_bang(argc, argv)
    int argc;
    VALUE *argv;
{
    return rb_str_chomp_bang(argc, argv, uscore_get());
}

static VALUE
rb_f_chomp(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE str = uscore_get();
    VALUE dup = rb_str_dup(str);

    if (NIL_P(rb_str_chomp_bang(argc, argv, dup)))
	return str;
    rb_lastline_set(dup);
    return dup;
}

static VALUE
rb_str_lstrip_bang(str)
    VALUE str;
{
    char *s, *t, *e;

    rb_str_modify(str);
    s = RSTRING(str)->ptr;
    if (!s || RSTRING(str)->len == 0) return Qnil;
    e = t = s + RSTRING(str)->len;
    /* remove spaces at head */
    while (s < t && ISSPACE(*s)) s++;

    RSTRING(str)->len = t-s;
    if (s > RSTRING(str)->ptr) {
	memmove(RSTRING(str)->ptr, s, RSTRING(str)->len);
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
	return str;
    }
    return Qnil;
}

static VALUE
rb_str_lstrip(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_lstrip_bang(str);
    return str;
}

static VALUE
rb_str_rstrip_bang(str)
    VALUE str;
{
    char *s, *t, *e;

    rb_str_modify(str);
    s = RSTRING(str)->ptr;
    if (!s || RSTRING(str)->len == 0) return Qnil;
    e = t = s + RSTRING(str)->len;

    /* remove trailing spaces */
    while (s < t && ISSPACE(*(t-1))) t--;

    RSTRING(str)->len = t-s;
    if (t < e) {
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
	return str;
    }
    return Qnil;
}

static VALUE
rb_str_rstrip(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_rstrip_bang(str);
    return str;
}

static VALUE
rb_str_strip_bang(str)
    VALUE str;
{
    VALUE l = rb_str_lstrip_bang(str);
    VALUE r = rb_str_rstrip_bang(str);

    if (NIL_P(l) && NIL_P(r)) return Qnil;
    return str;
}

static VALUE
rb_str_strip(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_strip_bang(str);
    return str;
}

static VALUE
scan_once(str, pat, start)
    VALUE str, pat;
    long *start;
{
    VALUE result, match;
    struct re_registers *regs;
    long i;

    if (rb_reg_search(pat, str, *start, 0) >= 0) {
	match = rb_backref_get();
	regs = RMATCH(match)->regs;
	if (BEG(0) == END(0)) {
	    /*
	     * Always consume at least one character of the input string
	     */
	    *start = END(0)+mbclen2(RSTRING(str)->ptr[END(0)],pat);
	}
	else {
	    *start = END(0);
	}
	if (regs->num_regs == 1) {
	    return rb_reg_nth_match(0, match);
	}
	result = rb_ary_new2(regs->num_regs);
	for (i=1; i < regs->num_regs; i++) {
	    rb_ary_push(result, rb_reg_nth_match(i, match));
	}

	return result;
    }
    return Qnil;
}

static VALUE
rb_str_scan(str, pat)
    VALUE str, pat;
{
    VALUE result;
    long start = 0;
    VALUE match = Qnil;

    pat = get_pat(pat, 1);
    if (!rb_block_given_p()) {
	VALUE ary = rb_ary_new();

	while (!NIL_P(result = scan_once(str, pat, &start))) {
	    match = rb_backref_get();
	    rb_ary_push(ary, result);
	}
	rb_backref_set(match);
	return ary;
    }
    
    while (!NIL_P(result = scan_once(str, pat, &start))) {
	match = rb_backref_get();
	rb_match_busy(match);
	rb_yield(result);
	rb_backref_set(match);	/* restore $~ value */
    }
    rb_backref_set(match);
    return str;
}

static VALUE
rb_f_scan(self, pat)
    VALUE self, pat;
{
    return rb_str_scan(uscore_get(), pat);
}

static VALUE
rb_str_hex(str)
    VALUE str;
{
    return rb_str_to_inum(str, 16, Qfalse);
}

static VALUE
rb_str_oct(str)
    VALUE str;
{
    return rb_str_to_inum(str, -8, Qfalse);
}

static VALUE
rb_str_crypt(str, salt)
    VALUE str, salt;
{
    extern char *crypt();
    VALUE result;
    char *s;

    StringValue(salt);
    if (RSTRING(salt)->len < 2)
	rb_raise(rb_eArgError, "salt too short(need >=2 bytes)");

    if (RSTRING(str)->ptr) s = RSTRING(str)->ptr;
    else s = "";
    result = rb_str_new2(crypt(s, RSTRING(salt)->ptr));
    OBJ_INFECT(result, str);
    OBJ_INFECT(result, salt);
    return result;
}

VALUE
rb_str_intern(str)
    VALUE str;
{
    ID id;

    if (!RSTRING(str)->ptr || RSTRING(str)->len == 0) {
	rb_raise(rb_eArgError, "interning empty string");
    }
    if (strlen(RSTRING(str)->ptr) != RSTRING(str)->len)
	rb_raise(rb_eArgError, "string contains `\\0'");
    id = rb_intern(RSTRING(str)->ptr);
    return ID2SYM(id);
}

static VALUE
rb_str_sum(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE vbits;
    int bits;
    char *p, *pend;

    if (rb_scan_args(argc, argv, "01", &vbits) == 0) {
	bits = 16;
    }
    else bits = NUM2INT(vbits);

    p = RSTRING(str)->ptr; pend = p + RSTRING(str)->len;
    if (bits > sizeof(long)*CHAR_BIT) {
	VALUE res = INT2FIX(0);
	VALUE mod;

	mod = rb_funcall(INT2FIX(1), rb_intern("<<"), 1, INT2FIX(bits));
	mod = rb_funcall(mod, '-', 1, INT2FIX(1));

	while (p < pend) {
	    res = rb_funcall(res, '+', 1, INT2FIX((unsigned int)*p));
	    p++;
	}
	res = rb_funcall(res, '&', 1, mod);
	return res;
    }
    else {
	unsigned int res = 0;
	unsigned int mod = (1<<bits)-1;

	if (mod == 0) {
	    mod = -1;
	}
	while (p < pend) {
	    res += (unsigned int)*p;
	    p++;
	}
	res &= mod;
	return rb_int2inum(res);
    }
}

static VALUE
rb_str_ljust(str, w)
    VALUE str;
    VALUE w;
{
    long width = NUM2LONG(w);
    VALUE res;
    char *p, *pend;

    if (width < 0 || RSTRING(str)->len >= width) return rb_str_dup(str);
    res = rb_str_new5(str, 0, width);
    memcpy(RSTRING(res)->ptr, RSTRING(str)->ptr, RSTRING(str)->len);
    p = RSTRING(res)->ptr + RSTRING(str)->len; pend = RSTRING(res)->ptr + width;
    while (p < pend) {
	*p++ = ' ';
    }
    OBJ_INFECT(res, str);
    return res;
}

static VALUE
rb_str_rjust(str, w)
    VALUE str;
    VALUE w;
{
    long width = NUM2LONG(w);
    VALUE res;
    char *p, *pend;

    if (width < 0 || RSTRING(str)->len >= width) return rb_str_dup(str);
    res = rb_str_new5(str, 0, width);
    p = RSTRING(res)->ptr; pend = p + width - RSTRING(str)->len;
    while (p < pend) {
	*p++ = ' ';
    }
    memcpy(pend, RSTRING(str)->ptr, RSTRING(str)->len);
    OBJ_INFECT(res, str);
    return res;
}

static VALUE
rb_str_center(str, w)
    VALUE str;
    VALUE w;
{
    long width = NUM2LONG(w);
    VALUE res;
    char *p, *pend;
    long n;

    if (width < 0 || RSTRING(str)->len >= width) return rb_str_dup(str);
    res = rb_str_new5(str, 0, width);
    n = (width - RSTRING(str)->len)/2;
    p = RSTRING(res)->ptr; pend = p + n;
    while (p < pend) {
	*p++ = ' ';
    }
    memcpy(pend, RSTRING(str)->ptr, RSTRING(str)->len);
    p = pend + RSTRING(str)->len; pend = RSTRING(res)->ptr + width;
    while (p < pend) {
	*p++ = ' ';
    }
    OBJ_INFECT(res, str);
    return res;
}

void
rb_str_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    if (!NIL_P(val) && TYPE(val) != T_STRING) {
	rb_raise(rb_eTypeError, "value of %s must be String", rb_id2name(id));
    }
    *var = val;
}

void
Init_String()
{
    rb_cString  = rb_define_class("String", rb_cObject);
    rb_include_module(rb_cString, rb_mComparable);
    rb_include_module(rb_cString, rb_mEnumerable);
    rb_define_singleton_method(rb_cString, "allocate", rb_str_s_alloc, 0);
    rb_define_method(rb_cString, "initialize", rb_str_init, -1);
    rb_define_method(rb_cString, "become", rb_str_replace, 1); 
    rb_define_method(rb_cString, "<=>", rb_str_cmp_m, 1);
    rb_define_method(rb_cString, "==", rb_str_equal, 1);
    rb_define_method(rb_cString, "===", rb_str_equal, 1);
    rb_define_method(rb_cString, "eql?", rb_str_eql, 1);
    rb_define_method(rb_cString, "hash", rb_str_hash_m, 0);
    rb_define_method(rb_cString, "casecmp", rb_str_casecmp, 1);
    rb_define_method(rb_cString, "+", rb_str_plus, 1);
    rb_define_method(rb_cString, "*", rb_str_times, 1);
    rb_define_method(rb_cString, "%", rb_str_format, 1);
    rb_define_method(rb_cString, "[]", rb_str_aref_m, -1);
    rb_define_method(rb_cString, "[]=", rb_str_aset_m, -1);
    rb_define_method(rb_cString, "insert", rb_str_insert, 2);
    rb_define_method(rb_cString, "length", rb_str_length, 0);
    rb_define_method(rb_cString, "size", rb_str_length, 0);
    rb_define_method(rb_cString, "empty?", rb_str_empty, 0);
    rb_define_method(rb_cString, "=~", rb_str_match, 1);
    rb_define_method(rb_cString, "~", rb_str_match2, 0);
    rb_define_method(rb_cString, "match", rb_str_match_m, 1);
    rb_define_method(rb_cString, "succ", rb_str_succ, 0);
    rb_define_method(rb_cString, "succ!", rb_str_succ_bang, 0);
    rb_define_method(rb_cString, "next", rb_str_succ, 0);
    rb_define_method(rb_cString, "next!", rb_str_succ_bang, 0);
    rb_define_method(rb_cString, "upto", rb_str_upto_m, 1);
    rb_define_method(rb_cString, "index", rb_str_index_m, -1);
    rb_define_method(rb_cString, "rindex", rb_str_rindex_m, -1);
    rb_define_method(rb_cString, "replace", rb_str_replace, 1);

    rb_define_method(rb_cString, "to_i", rb_str_to_i, -1);
    rb_define_method(rb_cString, "to_f", rb_str_to_f, 0);
    rb_define_method(rb_cString, "to_s", rb_str_to_s, 0);
    rb_define_method(rb_cString, "to_str", rb_str_to_s, 0);
    rb_define_method(rb_cString, "inspect", rb_str_inspect, 0);
    rb_define_method(rb_cString, "dump", rb_str_dump, 0);

    rb_define_method(rb_cString, "upcase", rb_str_upcase, 0);
    rb_define_method(rb_cString, "downcase", rb_str_downcase, 0);
    rb_define_method(rb_cString, "capitalize", rb_str_capitalize, 0);
    rb_define_method(rb_cString, "swapcase", rb_str_swapcase, 0);

    rb_define_method(rb_cString, "upcase!", rb_str_upcase_bang, 0);
    rb_define_method(rb_cString, "downcase!", rb_str_downcase_bang, 0);
    rb_define_method(rb_cString, "capitalize!", rb_str_capitalize_bang, 0);
    rb_define_method(rb_cString, "swapcase!", rb_str_swapcase_bang, 0);

    rb_define_method(rb_cString, "hex", rb_str_hex, 0);
    rb_define_method(rb_cString, "oct", rb_str_oct, 0);
    rb_define_method(rb_cString, "split", rb_str_split_m, -1);
    rb_define_method(rb_cString, "reverse", rb_str_reverse, 0);
    rb_define_method(rb_cString, "reverse!", rb_str_reverse_bang, 0);
    rb_define_method(rb_cString, "concat", rb_str_concat, 1);
    rb_define_method(rb_cString, "<<", rb_str_concat, 1);
    rb_define_method(rb_cString, "crypt", rb_str_crypt, 1);
    rb_define_method(rb_cString, "intern", rb_str_intern, 0);

    rb_define_method(rb_cString, "include?", rb_str_include, 1);

    rb_define_method(rb_cString, "scan", rb_str_scan, 1);

    rb_define_method(rb_cString, "ljust", rb_str_ljust, 1);
    rb_define_method(rb_cString, "rjust", rb_str_rjust, 1);
    rb_define_method(rb_cString, "center", rb_str_center, 1);

    rb_define_method(rb_cString, "sub", rb_str_sub, -1);
    rb_define_method(rb_cString, "gsub", rb_str_gsub, -1);
    rb_define_method(rb_cString, "chop", rb_str_chop, 0);
    rb_define_method(rb_cString, "chomp", rb_str_chomp, -1);
    rb_define_method(rb_cString, "strip", rb_str_strip, 0);
    rb_define_method(rb_cString, "lstrip", rb_str_lstrip, 0);
    rb_define_method(rb_cString, "rstrip", rb_str_rstrip, 0);

    rb_define_method(rb_cString, "sub!", rb_str_sub_bang, -1);
    rb_define_method(rb_cString, "gsub!", rb_str_gsub_bang, -1);
    rb_define_method(rb_cString, "chop!", rb_str_chop_bang, 0);
    rb_define_method(rb_cString, "chomp!", rb_str_chomp_bang, -1);
    rb_define_method(rb_cString, "strip!", rb_str_strip_bang, 0);
    rb_define_method(rb_cString, "lstrip!", rb_str_lstrip_bang, 0);
    rb_define_method(rb_cString, "rstrip!", rb_str_rstrip_bang, 0);

    rb_define_method(rb_cString, "tr", rb_str_tr, 2);
    rb_define_method(rb_cString, "tr_s", rb_str_tr_s, 2);
    rb_define_method(rb_cString, "delete", rb_str_delete, -1);
    rb_define_method(rb_cString, "squeeze", rb_str_squeeze, -1);
    rb_define_method(rb_cString, "count", rb_str_count, -1);

    rb_define_method(rb_cString, "tr!", rb_str_tr_bang, 2);
    rb_define_method(rb_cString, "tr_s!", rb_str_tr_s_bang, 2);
    rb_define_method(rb_cString, "delete!", rb_str_delete_bang, -1);
    rb_define_method(rb_cString, "squeeze!", rb_str_squeeze_bang, -1);

    rb_define_method(rb_cString, "each_line", rb_str_each_line, -1);
    rb_define_method(rb_cString, "each", rb_str_each_line, -1);
    rb_define_method(rb_cString, "each_byte", rb_str_each_byte, 0);

    rb_define_method(rb_cString, "sum", rb_str_sum, -1);

    rb_define_global_function("sub", rb_f_sub, -1);
    rb_define_global_function("gsub", rb_f_gsub, -1);

    rb_define_global_function("sub!", rb_f_sub_bang, -1);
    rb_define_global_function("gsub!", rb_f_gsub_bang, -1);

    rb_define_global_function("chop", rb_f_chop, 0);
    rb_define_global_function("chop!", rb_f_chop_bang, 0);

    rb_define_global_function("chomp", rb_f_chomp, -1);
    rb_define_global_function("chomp!", rb_f_chomp_bang, -1);

    rb_define_global_function("split", rb_f_split, -1);
    rb_define_global_function("scan", rb_f_scan, 1);

    rb_define_method(rb_cString, "slice", rb_str_aref_m, -1);
    rb_define_method(rb_cString, "slice!", rb_str_slice_bang, -1);

    id_to_s = rb_intern("to_s");

    rb_fs = Qnil;
    rb_define_hooked_variable("$;", &rb_fs, 0, rb_str_setter);
    rb_define_hooked_variable("$-F", &rb_fs, 0, rb_str_setter);
}
@


1.122
log
@* eval.c (rb_eval): added NODE_DSYM, symbol literal with
  interpolation.

* node.h: ditto.

* intern.h: prototypes; rb_is_junk_id, rb_str_dump, rb_str_intern

* object.c (sym_inspect): escape and quote for non-alphanumeric
  symbols.

* parse.y (dsym, tokadd_string, yylex): extended symbol literals.

* parse.y (rb_is_junk_id): added.

* string.c (rb_str_dump, rb_str_intern) : make extern.

* lib/mkmf.rb (create_makefile): deffile should be removed by
  distclean, not clean.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/25 07:03:01 $
d2536 5
a2540 1
		if (last_null == 1) {
@


1.121
log
@* io.c (appendline): forget to terminate with nul.

* eval.c (ruby_run): should set toplevel visibility again here.

* eval.c (rb_eval): should not rely on ruby_class == rb_cObject
  check.   Besides allow implicit publicity for attribute set
  methods.

* parse.y (primary): need not to check class_nest, just set
  whether method is an attrset or not.

* string.c (rb_str_each_line): p might be at the top of the
  string.

* class.c (rb_make_metaclass): class of metaclass should be
  metaclass of superclass, unless class itself is a metaclass;
  class of metaclass of metaclass should point back to self.
  eh, confusing, isn't it.

* class.c (rb_singleton_class): check if its class is singleton
  AND attached to self.

* eval.c (rb_eval): should define class/module under ruby_cbase.

* eval.c (rb_eval): should set class/module path based on
  ruby_cbase, not ruby_class.

* eval.c (module_setup): use ruby_cbase instead of ruby_class.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/09/13 08:26:35 $
d1876 1
a1876 1
static VALUE
d3006 1
a3006 1
static VALUE
@


1.120
log
@Fix-Addons [ruby-core:483] with corrections from [ruby-core:484]
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/12 06:27:13 $
d2634 1
a2634 1
	if (p[-1] == newline &&
@


1.119
log
@* dir.c (glob_helper): prevent memory leak using rb_protect().

* string.c (rb_str_associate): no need to check freeze flag.

* string.c (rb_str_resize): should honor STR_ASSOC flag on
  resize.

* string.c (rb_str_resize): proper STR_ASSOC handling.  pointed
  out by Michal Rokos.

* string.c (rb_str_buf_cat): ditto.

* string.c (rb_str_cat): ditto.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_append): ditto.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2002/09/11 04:05:36 $
d225 1
d235 1
d637 1
a637 2
    long len;

a638 1
    rb_str_modify(str);
d641 1
a641 1
	    len = RSTRING(str)->len+RSTRING(str2)->len;
d1639 1
a1639 1
	FL_SET(str, RBASIC(str2)->flags & (ELTS_SHARED|STR_ASSOC));
d1647 1
a1647 1
	    FL_SET(str, RBASIC(str2)->flags & (ELTS_SHARED|STR_ASSOC));
d2308 1
a2316 1
    rb_str_modify(str);
d2357 1
a2372 1
    rb_str_modify(str);
@


1.118
log
@* string.c (get_pat): Add an extra argument "quote".

* string.c (rb_str_match_m): Do not bother to convert if a regexp
  is given.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/03 05:20:06 $
d239 1
a239 1
    FL_UNSET(str, ELTS_SHARED|STR_ASSOC);
a242 34
void
rb_str_associate(str, add)
    VALUE str, add;
{
    if (FL_TEST(str, STR_ASSOC)) {
	/* already associated */
	rb_ary_concat(RSTRING(str)->aux.shared, add);
    }
    else {
	if (FL_TEST(str, ELTS_SHARED)) {
	    rb_str_modify(str);
	}
	else if (RSTRING(str)->aux.shared) {
	    /* str_buf */
	    if (RSTRING(str)->aux.capa != RSTRING(str)->len) {
		RESIZE_CAPA(str, RSTRING(str)->len);
	    }
	}
	RSTRING(str)->aux.shared = add;
	FL_UNSET(str, ELTS_SHARED);
	FL_SET(str, STR_ASSOC);
    }
}

VALUE
rb_str_associated(str)
    VALUE str;
{
    if (FL_TEST(str, STR_ASSOC)) {
	return RSTRING(str)->aux.shared;
    }
    return Qfalse;
}

d402 30
a512 1

d514 4
a517 1
	    RESIZE_CAPA(str, len);
d533 11
a543 2
    if (FL_TEST(str, ELTS_SHARED)) {
	rb_str_modify(str);
a544 1
    capa = RSTRING(str)->aux.capa;
d573 6
a578 6
    rb_str_modify(str);
    if (len > 0) {
	if (!FL_TEST(str, ELTS_SHARED) && !FL_TEST(str, STR_ASSOC)) {
	    return rb_str_buf_cat(str, ptr, len);
	}
	RESIZE_CAPA(str, RSTRING(str)->len + len);
d587 1
d590 1
a590 1
    return str;
d607 7
a613 2
    if (FL_TEST(str, ELTS_SHARED)) {
	rb_str_modify(str);
a614 2
    capa = RSTRING(str)->aux.capa;

d626 1
d640 10
a649 5
	len = RSTRING(str)->len+RSTRING(str2)->len;
	if (!FL_TEST(str, ELTS_SHARED) && !FL_TEST(str, STR_ASSOC)) {
	    rb_str_buf_append(str, str2);
	    OBJ_INFECT(str, str2);
	    return str;
a650 5
	RESIZE_CAPA(str, len);
	memcpy(RSTRING(str)->ptr + RSTRING(str)->len,
	       RSTRING(str2)->ptr, RSTRING(str2)->len);
	RSTRING(str)->len += RSTRING(str2)->len;
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0'; /* sentinel */
a652 1

@


1.117
log
@	* variable.c (rb_copy_generic_ivar): remove old generic instance
	  variable table if it existes.

	* class.c (rb_make_metaclass): metaclass of a metaclass is a
	  metaclass itself.
@
text
@d6 1
a6 1
  $Date: 2002/08/29 09:08:16 $
d989 2
d995 1
a995 7
    VALUE str2 = rb_check_convert_type(re, T_STRING, "String", "to_str");

    if (!NIL_P(str2)) {
	StringValue(re);
	re = rb_reg_regcomp(rb_reg_quote(re));
    }
    return rb_funcall(re, rb_intern("match"), 1, str);
d1379 1
a1379 1
get_pat(pat)
d1381 1
d1399 3
a1401 1
    val = rb_reg_quote(pat);
d1403 5
a1407 2
    if (val != pat && rb_str_cmp(val, pat) != 0) {
	rb_warn("string pattern instead of regexp; metacharacters no longer effective");
d1409 2
a1410 2
#endif
    return rb_reg_regcomp(val);
d1437 1
a1437 1
    pat = get_pat(argv[0]);
d1510 1
a1510 1
    pat = get_pat(argv[0]);
d2482 1
a2482 1
	    spat = get_pat(spat);
d2933 1
a2933 1
    pat = get_pat(pat);
@


1.116
log
@* array.c (rb_ary_become): should not free ptr if it's shared.

* eval.c (rb_alias): prohibit making an alias named "allocate" if
  klass is a metaclass.

* string.c (rb_string_value_ptr): StringValuePtr() should never
  return NULL pointer.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/28 08:05:23 $
d216 1
a216 1
rb_str_become(str, str2)
d1074 1
a1074 1
    rb_str_become(str, rb_str_succ(str));
@


1.115
log
@Int vs Long cleanup #3 (ruby-core:352)
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/28 06:01:58 $
d443 15
d1627 2
a1628 7
	if (FL_TEST(str2, ELTS_SHARED|STR_ASSOC)) {
	    FL_SET(str, RBASIC(str2)->flags & (ELTS_SHARED|STR_ASSOC));
	    RSTRING(str)->aux.shared = RSTRING(str2)->aux.shared;
	}
	else {
	    RSTRING(str)->aux.capa = RSTRING(str2)->aux.capa;
	}
d1634 4
@


1.114
log
@* string.c (rb_str_delete_bang): should check if str->ptr is 0.

* string.c (rb_str_squeeze_bang): ditto.

* string.c (rb_str_count): ditto.

* string.c (rb_str_lstrip_bang): ditto.

* string.c (rb_str_rstrip_bang): ditto.

* string.c (rb_str_intern): ditto.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/08/27 10:24:24 $
d1019 1
a1019 1
    int n = 0;
d1219 1
a1219 1
    int start, end, len;
d3002 1
a3002 1
    int   bits;
@


1.113
log
@* string.c (rb_str_rstrip_bang): don't access address -1.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/27 08:31:06 $
d2136 1
d2292 1
a2346 1

d2348 1
d2417 1
d2801 1
d2832 1
d2966 1
d2972 3
a2974 1
    result = rb_str_new2(crypt(RSTRING(str)->ptr, RSTRING(salt)->ptr));
d2986 3
@


1.112
log
@* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.

* class.c (rb_mod_dup): need to preserve metaclass and flags.

* object.c (rb_cstr_to_dbl): had a buffer overrun.

* marshal.c (w_class): integrate singleton check into a funciton
  to follow DRY principle.

* marshal.c (w_uclass): should check singleton method.

* object.c (rb_obj_dup): dmark and dfree functions must be match
  for T_DATA type.

* object.c (rb_obj_dup): class of the duped object must be match
  to the class of the original.

* re.c (rb_reg_quote): do not escape \t, \f, \r, \n, for they are
  not regular expression metacharacters.

* time.c (time_s_alloc): use time_free instead of free (null check,
  also serves for type mark).

* time.c (time_s_at): check dfree function too.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/21 15:47:54 $
d2831 1
a2831 3
    t--;
    while (s <= t && ISSPACE(*t)) t--;
    t++;
@


1.111
log
@*.c: Int vs Long cleanup
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2002/08/06 06:20:43 $
d295 1
a295 33
static VALUE
str_copy(str, clone)
    VALUE str;
    int clone;
{
    VALUE str2;
    int flags;

    StringValue(str);

    if (FL_TEST(str, ELTS_SHARED)) {
	str2 = rb_str_new3(RSTRING(str)->aux.shared);
    }
    else if (FL_TEST(str, STR_ASSOC)) {
	str2 = str_new(RSTRING(str)->ptr, RSTRING(str)->len);
	RSTRING(str2)->aux.shared = RSTRING(str)->aux.shared;
    }
    else if (OBJ_FROZEN(str)) {
	str2 = rb_str_new3(str);
    }
    else {
	str2 = rb_str_new3(rb_str_new4(str));
    }
    flags = FL_TEST(str2, ELTS_SHARED|STR_ASSOC);
    if (clone) {
	CLONESETUP(str2, str);
    }
    else {
	DUPSETUP(str2, str);
    } 
    if (flags) FL_SET(str2, flags);
    return str2;
}
d301 3
a303 1
    return str_copy(str, Qfalse);
a306 9
rb_str_clone(str)
    VALUE str;
{
    return str_copy(str, Qtrue);
}

static VALUE rb_str_replace _((VALUE, VALUE));

static VALUE
d1389 1
a1389 1
    if (val != pat) {
d3118 1
a3118 2
    rb_define_method(rb_cString, "clone", rb_str_clone, 0);
    rb_define_method(rb_cString, "dup", rb_str_dup, 0);
@


1.110
log
@* string.c (rb_str_rindex): must return -1 if unmatched.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/07/26 06:12:39 $
d362 1
a362 1
    return INT2NUM(RSTRING(str)->len);
d878 1
a878 1
	      if (p[pos] == c) return INT2NUM(pos);
d889 1
a889 1
    return INT2NUM(pos);
d930 1
a930 1
    int pos;
d933 1
a933 1
	pos = NUM2INT(position);
d955 1
a955 1
	if (pos >= 0) return INT2NUM(pos);
d960 1
a960 1
	if (pos >= 0) return INT2NUM(pos);
d970 1
a970 1
	      if (*p == c) return INT2NUM(p - RSTRING(str)->ptr);
d998 1
a998 1
	return INT2NUM(start);
d1200 1
a1200 1
	return rb_str_substr(str, NUM2INT(argv[0]), NUM2INT(argv[1]));
d1211 1
a1211 2
    long beg;
    long len;
d1295 1
a1295 1
	idx = NUM2INT(indx);
d1355 1
a1355 1
	    rb_str_update(str, NUM2INT(argv[0]), NUM2INT(argv[1]), argv[2]);
a2616 1
    int rslen;
d2619 1
a2619 1
    long len = RSTRING(str)->len;
a2733 1
    int rslen;
d2735 1
a2735 1
    long len = RSTRING(str)->len;
@


1.109
log
@* random.c: replace with Mersenne Twister RNG.

* eval.c (jump_tag_but_local_jump): preserve retval in
  LocalJumpError exceptions.

* parse.y (command): no more check for "super outside of method".

* eval.c (rb_mod_define_method): should set last_class and
  last_func in the block->frame.

* eval.c (error_handle): should handle TAG_THROW as well.

* parse.y (yylex): new decimal notation '0d4567'.

* parse.y (yylex): new octal notation '0o777'.

* parse.y (string_content): every string_content node should
  return string only.  use NODE_EVSTR to coercing.

* eval.c (rb_eval): NODE_EVSTR support.

* re.c (rb_reg_quote): avoid unnecessary string allocation.

* string.c (get_pat): quote metachracters before compiling a
  string into a regex.

* string.c (rb_str_split_m): special treatment of strings of size
  1, but AWK emulation.  now uses get_pat().

* string.c (rb_str_match_m): quote metacharacters.

* string.c (rb_str_match2): ditto.

* ext/socket/socket.c (sock_addrinfo): make all 3 versions of
  getaddrinfo happy.  [ruby-core:00184]
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/07/11 17:17:14 $
d915 1
@


1.108
log
@* string.c (rb_str_match): fix for string match.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/07/11 08:22:10 $
d892 29
d922 1
a922 1
rb_str_rindex(argc, argv, str)
d929 1
a929 2
    int pos, len;
    char *s, *sbeg, *t;
d958 2
a959 20
	len = RSTRING(sub)->len;
	/* substring longer than string */
	if (RSTRING(str)->len < len) return Qnil;
	if (RSTRING(str)->len - pos < len) {
	    pos = RSTRING(str)->len - len;
	}
	sbeg = RSTRING(str)->ptr;
	s = RSTRING(str)->ptr + pos;
	t = RSTRING(sub)->ptr;
	if (len) {
	    while (sbeg <= s) {
		if (rb_memcmp(s, t, len) == 0) {
		    return INT2NUM(s - RSTRING(str)->ptr);
		}
		s--;
	    }
	}
	else {
	    return INT2NUM(pos);
	}
d1009 1
a1009 1
    return rb_reg_match2(rb_reg_regcomp(str));
d1020 1
a1020 1
	re = rb_reg_regcomp(re);
d1410 2
d1414 1
a1414 1
	break;
a1416 1
	pat = rb_reg_regcomp(pat);
d1420 10
a1429 2
	/* type failed */
	Check_Type(pat, T_REGEXP);
d1431 2
a1432 1
    return pat;
d2472 1
a2472 1
    int char_sep = -1;
d2489 1
a2489 1
	char_sep = ' ';
d2493 3
a2495 4
	switch (TYPE(spat)) {
	  case T_STRING:
	    if (RSTRING(spat)->len == 1) {
		char_sep = (unsigned char)RSTRING(spat)->ptr[0];
d2498 1
a2498 1
		spat = rb_reg_regcomp(spat);
d2500 3
a2502 5
	    break;
	  case T_REGEXP:
	    break;
	  default:
	    rb_raise(rb_eArgError, "bad separator");
d2508 1
a2508 1
    if (char_sep >= 0) {
d2512 1
d2514 4
a2517 12
	if (char_sep == ' ') {	/* AWK emulation */
	    int skip = 1;

	    for (end = beg = 0; ptr<eptr; ptr++) {
		if (skip) {
		    if (ISSPACE(*ptr)) {
			beg++;
		    }
		    else {
			end = beg+1;
			skip = 0;
		    }
d2520 2
a2521 9
		    if (ISSPACE(*ptr)) {
			rb_ary_push(result, rb_str_substr(str, beg, end-beg));
			skip = 1;
			beg = end + 1;
			if (!NIL_P(limit) && lim <= ++i) break;
		    }
		    else {
			end++;
		    }
d2524 2
a2525 4
	}
	else {
	    for (end = beg = 0; ptr<eptr; ptr++) {
		if (*ptr == (char)char_sep) {
d2527 1
d2531 3
a2533 1
		end++;
d3185 1
a3185 1
    rb_define_method(rb_cString, "rindex", rb_str_rindex, -1);
@


1.107
log
@* string.c (rb_str_slice_bang): if there's no corresponding
  substring, slice! should return nil without exception.

* array.c (rb_ary_insert): type fixed.

* string.c (rb_str_split_m): accept separator value nil as well.

* string.c (rb_str_become): was leaking memory.

* class.c (rb_include_module): should not alter other
  classes/modules by inclusion.  by this fix, local order may not
  be preserved for some cases.

* class.c (include_class_new): module may be T_ICLASS; retrieve
  original module information.
@
text
@d6 1
a6 1
  $Date: 2002/06/18 06:29:05 $
a975 1
    VALUE reg;
d983 1
a983 1
	start = rb_str_index(reg, x, 0);
@


1.106
log
@* parse.y (yylex): obsolete '?<whitespace>'; use '?\s', '?\n',
  etc, instead.

* parse.y (yylex): no here document after a dot.

* parse.y (yylex): should have set lex_state after '`'.

* parse.y (yylex): should have set lex_state properly after
  tOP_ASGN.

* bignum.c (rb_big2dbl): return canonical HUGE_VAL for infinity.
@
text
@d6 1
a6 1
  $Date: 2002/06/04 07:34:15 $
d59 1
a59 1
    VALUE str = rb_obj_alloc(klass);
d65 1
d72 3
d183 1
a183 1
    if (capa < STR_BUF_MIN_SIZE)
d185 1
d202 2
a203 2
    str = rb_str_buf_new(len + STR_BUF_MIN_SIZE);
    rb_str_cat(str, ptr, len);
d220 1
a226 1
    if (FL_TEST(str, ELTS_SHARED)) free(RSTRING(str)->ptr);
a807 45
static VALUE
rb_str_match(x, y)
    VALUE x, y;
{
    VALUE reg;
    long start;

    switch (TYPE(y)) {
      case T_REGEXP:
	return rb_reg_match(y, x);

      case T_STRING:
	reg = rb_reg_regcomp(y);
	start = rb_reg_search(reg, x, 0, 0);
	if (start == -1) {
	    return Qnil;
	}
	return INT2NUM(start);

      default:
	return rb_funcall(y, rb_intern("=~"), 1, x);
    }
}

static VALUE
rb_str_match2(str)
    VALUE str;
{
    StringValue(str);
    return rb_reg_match2(rb_reg_regcomp(str));
}

static VALUE
rb_str_match_m(str, re)
    VALUE str, re;
{
    VALUE str2 = rb_check_convert_type(re, T_STRING, "String", "to_str");

    if (!NIL_P(str2)) {
	StringValue(re);
	re = rb_reg_regcomp(re);
    }
    return rb_funcall(re, rb_intern("match"), 1, str);
}

d972 44
d1391 3
a1393 1
    rb_str_aset_m(argc+1, buf, str);
d2465 1
a2465 1
    if (argc == 0) {
@


1.105
log
@* string.c (rb_str_aset): should raise error if an indexing string
  is not found in the receiver.

* sprintf.c (rb_f_sprintf): "%d" should convert objects into
  integers using Integer().

* lib/tempfile.rb (Tempfile::size): added.
@
text
@d6 1
a6 1
  $Date: 2002/05/29 05:20:33 $
d2994 1
d2999 5
a3003 1
    return rb_tainted_str_new2(crypt(RSTRING(str)->ptr, RSTRING(salt)->ptr));
@


1.104
log
@* parse.y: yyparse #defines moved from intern.h

* ruby.c (proc_options): access prefixed "ruby_yydebug".

* applied modifies to pacify some of gcc -Wall warnings.

* parse.y (arg): no more ugly hack for "**", so that "-2**2" to be
  parsed as "(-2)**2", whereas "- 2**2" or "-(2)**2" to be parsed
  as "-(2**2)".

* parse.y (yylex): '-2' to be literal fixnum. [new]

* time.c (time_succ): new method for Range support.

* time.c (time_arg): nil test against v[6] (usec).
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/05/28 18:11:07 $
d1310 2
a1311 2
	if (beg != -1) {
	    rb_str_update(str, beg, RSTRING(indx)->len, val);
d1313 1
@


1.103
log
@	* array.c: fixed format string for 'long' args (%d -> %ld).

	* class.c: ditto.

	* eval.c: ditto.

	* numeric.c: ditto.

	* pack.c: ditto.

	* parse.y: ditto.

	* range.c: ditto.

	* string.c: ditto.

	* util.c: ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/04/24 04:54:14 $
d2447 1
a2447 1
    long beg, end, i;
@


1.102
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d6 1
a6 1
  $Date: 2002/04/18 08:46:18 $
d1201 1
a1201 1
    if (len < 0) rb_raise(rb_eIndexError, "negative length %d", len);
d1204 1
a1204 1
	rb_raise(rb_eIndexError, "index %d out of string", beg);
d1285 1
a1285 1
	    rb_raise(rb_eIndexError, "index %d out of string", idx);
@


1.101
log
@* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* io.c: complete off_t handling; missing argument for
  fptr_finalize(); polished rb_scan_args call.

* dir.c: wrap multi-statment macro by do { } while (0)

* eval.c, numeric,c, sprintf.c, util.c: ditto.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.
@
text
@d6 1
a6 1
  $Date: 2002/03/19 09:03:07 $
a295 1
    VALUE klass;
d530 4
d537 2
a538 6
	if (len >= 0) {
	    if (RSTRING(str)->len < len || RSTRING(str)->len - len > 1024) {
		RESIZE_CAPA(str, len);
	    }
	    RSTRING(str)->len = len;
	    RSTRING(str)->ptr[len] = '\0';	/* sentinel */
d540 2
d552 1
a552 1
    long i, capa, total;
a585 2
    long i, capa;

d617 1
a617 1
    long i, capa, len;
d643 1
a643 1
    long i, capa, len;
@


1.100
log
@* re.c (rb_reg_search): should clear last_match if pos is out of
  string range.

* string.c (rb_str_index_m): ditto.

* string.c (rb_str_rindex): ditto.

* class.c (rb_define_class): should handle autoload.

* class.c (rb_define_module): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/14 00:10:49 $
d61 4
d467 2
a468 2
    if (str_independent(str)) return;
    str_make_independent(str);
@


1.99
log
@* string.c (rb_str_subpat_set): must make str independent after
  rb_reg_search() matched.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/11 08:02:02 $
d890 6
a895 1
	if (pos < 0) return Qnil;
d944 6
a949 1
	    if (pos < 0) return Qnil;
@


1.98
log
@* marshal.c (w_object): module inclusion using extend() should
  also be detected.

* eval.c (rb_eval_cmd): cbase should not be NULL; it should be
  either ruby_wrapper or Object.

* enum.c (enum_each_with_index): should return self.

* process.c (proc_setpgrp): should return value for non-void function.

* process.c (proc_getpgid): should raise exception if getpgid() return -1.

* string.c (rb_str_ljust): should return a duplicated string.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/02/01 10:23:22 $
d1255 1
@


1.97
log
@* intern.h: prototypes for new functions; rb_cstr_to_inum(),
  rb_str_to_inum(), rb_cstr_to_dbl(), rb_str_to_dbl()

* bignum.c (rb_cstr_to_inum): changed from rb_cstr2inum(), and
  added argument badcheck to be consistent with parser. [new]

* bignum.c (rb_str_to_inum): ditto.

* bignum.c (rb_cstr2inum): wapper of rb_cstr_to_inum() now.

* bignum.c (rb_str2inum): ditto.

* object.c (rb_cstr_to_dbl): float number parser. [new]

* object.c (rb_str_to_dbl): ditto.

* object.c (rb_Float): use rb_cstr_to_dbl() for strict check.

* object.c (rb_Integer): use rb_str_to_inum() for strict check.

* string.c (rb_str_to_f): use rb_str_to_dbl() with less check.

* string.c (rb_str_to_i): use rb_str_to_inum() with less check.

* string.c (rb_str_hex): ditto.

* string.c (rb_str_oct): ditto.

* sprintf.c (rb_f_sprintf): ditto.

* time.c (obj2long): ditto.

* parse.y (yylex): use rb_cstr_to_inum() for strict check.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/28 08:44:37 $
d3053 1
a3053 1
    if (width < 0 || RSTRING(str)->len >= width) return str;
d3073 1
a3073 1
    if (width < 0 || RSTRING(str)->len >= width) return str;
d3094 1
a3094 1
    if (width < 0 || RSTRING(str)->len >= width) return str;
@


1.96
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.

* object.c (Init_Object): remove dup and clone from TrueClass,
  FalseClass, and NilClass.

* array.c (rb_ary_fill): Array#fill takes block to get the value to
  fill.

* string.c (rb_str_to_i): to_i(0) auto-detects base radix.

* array.c (rb_ary_initialize): fill by the block evaluation value
  if block is given.
@
text
@d6 1
a6 1
  $Date: 2002/01/25 08:22:05 $
d1769 1
a1769 1
    return rb_str2inum(str, base);
d1776 1
a1776 3
    double f = strtod(RSTRING(str)->ptr, 0);

    return rb_float_new(f);
d2964 1
a2964 1
    return rb_str2inum(str, 16);
d2971 1
a2971 15
    int base = 8;

    if (RSTRING(str)->len > 2 && RSTRING(str)->ptr[0] == '0') {
	switch (RSTRING(str)->ptr[1]) {
	  case 'x':
	  case 'X':
	    base = 16;
	    break;
	  case 'b':
	  case 'B':
	    base = 2;
	    break;
	}
    }
    return rb_str2inum(str, base);
@


1.95
log
@* class.c (rb_include_module): detect cyclic module inclusion.

* eval.c (rb_thread_cleanup): need not to free thread stacks at
  process termination.

* array.c (rb_ary_fetch): use the block to get the default value
  if the block is given.

* eval.c (rb_thread_schedule): should check time only if BOTH
  WAIT_SELECT and WAIT_TIME.

* eval.c (umethod_bind): should update rklass field.

* hash.c (rb_hash_update): if a block is given, yields [key,
  value1, value2] to the block to resolve conflict.

* string.c (rb_str_split_m): no need to consider KANJI
characters, if the length of separator is 1 (byte).
@
text
@d6 1
a6 1
  $Date: 2002/01/11 09:18:50 $
d1764 1
a1764 1
      case 2: case 8: case 10: case 16:
@


1.94
log
@* re.c (match_select): should propagate taintness.

* hash.c (rb_hash_set_default): Hash#default= should return the
  new value.

* string.c (rb_str_to_i): accepts optional base argument. [new]

* numeric.c (rb_fix2str): should not handle negative fixnum values
  int32 via calling sprintf() directly.
@
text
@d6 1
a6 1
  $Date: 2002/01/07 05:27:01 $
d1637 1
a1637 1
		 NIL_P(line)?"nil":rb_class2name(CLASS_OF(line)));
a2511 1
		if (ismbchar(*ptr)) {ptr++; end++;}
@


1.93
log
@* string.c (rb_str_new2): NULL pointer check added.

* class.c (rb_define_module_under): should locate predefined
  module using rb_const_defined_at().
@
text
@d6 1
a6 1
  $Date: 2001/12/19 07:48:30 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
d1751 3
a1753 1
rb_str_to_i(str)
d1756 14
a1769 1
    return rb_str2inum(str, 10);
d3176 1
a3176 1
    rb_define_method(rb_cString, "to_i", rb_str_to_i, 0);
@


1.92
log
@* eval.c (rb_mod_define_method): define_method should follow
  default method visibility.

* eval.c (rb_attr): should warn if the default method visibility
  is "module_function" (can be error).

* eval.c (rb_mod_define_method): should define class/module method
  also if the visibility is "module_function".

* eval.c (rb_mod_define_method): should call hook method
  "method_added", and "singleton_method_added".

* string.c: use RESIZE_CAPA for capacity change.

* ext/socket/socket.c (Init_socket): add listen method to
  TCPServer and UNIXServer.

* ext/socket/socket.c (bsock_send): should raise EWOULDBLOCK
  exception.

* ext/socket/socket.c (s_recvfrom): ditto.

* ext/socket/socket.c (s_accept): ditto.

* ext/socket/socket.c (udp_send): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/12/18 08:46:56 $
d83 3
@


1.91
log
@* string.c (rb_str_replace): swap arguments of OBJ_INFECT.

* eval.c (rb_thread_schedule): should not select a thread which is
  not yet initialized.

* time.c (time_plus): wrong boundary check.

* time.c (time_minus): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/12/11 03:48:08 $
d32 5
d246 1
a246 1
		REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len + 1);
d529 1
a529 1
		REALLOC_N(RSTRING(str)->ptr, char, len + 1);
d555 1
a555 2
	REALLOC_N(RSTRING(str)->ptr, char, capa+1);
	RSTRING(str)->aux.capa = capa;
d585 1
a585 1
	REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len+len+1);
d623 1
a623 2
	REALLOC_N(RSTRING(str)->ptr, char, capa+1);
	RSTRING(str)->aux.capa = capa;
d648 1
a648 1
	REALLOC_N(RSTRING(str)->ptr, char, len+1);
d1052 1
a1052 1
	REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len + 2);
d1203 1
a1203 1
	REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len+RSTRING(val)->len-len+1);
d1278 1
a1278 1
		REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len);
d1433 1
a1433 2
	    REALLOC_N(RSTRING(str)->ptr, char,
		      RSTRING(str)->len + RSTRING(repl)->len - plen + 1);
@


1.90
log
@* string.c (rb_str_match_m): should convert an argument into
  regexp if it's a string.

* array.c (rb_ary_select): Array#select(n,m,...) now works like
  Array#indexes(n,m,..). [new, experimental]

* hash.c (rb_hash_select): ditto.

* hash.c (env_select): ditto.

* re.c (match_select): ditto.

* struct.c (rb_struct_select): ditto.

* gc.c (STR_ASSOC): use FL_USER3 instead of FL_USER2.

* parse.y (str_extend): make up pushback call.
@
text
@d6 1
a6 1
  $Date: 2001/12/10 07:18:12 $
a197 7
VALUE
rb_string_value(ptr)
    volatile VALUE *ptr;
{
    return *ptr = rb_str_to_str(*ptr);
}

d424 42
a492 28
static int
str_independent(str)
    VALUE str;
{
    if (OBJ_FROZEN(str)) rb_error_frozen("string");
    if (!OBJ_TAINTED(str) && rb_safe_level() >= 4)
	rb_raise(rb_eSecurityError, "Insecure: can't modify string");
    if (!FL_TEST(str, ELTS_SHARED)) return 1;
    return 0;
}

void
rb_str_modify(str)
    VALUE str;
{
    char *ptr;

    if (str_independent(str)) return;
    ptr = ALLOC_N(char, RSTRING(str)->len+1);
    if (RSTRING(str)->ptr) {
	memcpy(ptr, RSTRING(str)->ptr, RSTRING(str)->len);
    }
    ptr[RSTRING(str)->len] = 0;
    RSTRING(str)->ptr = ptr;
    RSTRING(str)->aux.capa = RSTRING(str)->len;
    FL_UNSET(str, ELTS_SHARED|STR_ASSOC);
}

d1620 1
a1620 1
    OBJ_INFECT(str2, str);
@


1.89
log
@* array.c (rb_ary_modify): should copy the internal buffer if the
  modifying buffer is shared.

* array.c (ary_make_shared): make an internal buffer of an array
  to be shared.

* array.c (rb_ary_shift): avoid sliding an internal buffer by
  using shared buffer.

* array.c (rb_ary_subseq): avoid copying the buffer.

* parse.y (gettable): should freeze __LINE__ string.

* io.c (rb_io_puts): old behavoir restored.  rationale: a) if you
  want to call to_s for arrays, you can just call print a, "\n".
  b) to_s wastes memory if array (and sum of its contents) is
  huge.  c) now any object that has to_ary is treated as an array,
  using rb_check_convert_type().

* hash.c (rb_hash_initialize): now accepts a block to calculate
  the default value. [new]

* hash.c (rb_hash_aref): call "default" method to get the value
  corrensponding to the non existing key.

* hash.c (rb_hash_default): get the default value based on the
  block given to 'new'.  Now it takes an optinal "key" argument.
  "default" became the method to get the value for non existing
  key.  Users may override "default" method to change the hash
  behavior.

* hash.c (rb_hash_set_default): clear the flag if a block is given
  to 'new'

* object.c (Init_Object): undef Data.allocate, left Data.new.

* ext/curses/curses.c (window_scrollok): use RTEST().

* ext/curses/curses.c (window_idlok): ditto.

* ext/curses/curses.c (window_keypad): ditto.

* ext/curses/curses.c (window_idlok): idlok() may return void on
  some platforms; so don't use return value.

* ext/curses/curses.c (window_scrollok): ditto for consistency.

* ext/curses/curses.c: replace FIX2INT() by typechecking NUM2INT().

* parse.y (str_extend): should not process immature #$x and
  #@@x interpolation, e.g #@@#@@ etc.

* enum.c (enum_sort_by): sort_by does not have to be stable always.

* enum.c (enum_sort_by): call qsort directly to gain performance.

* util.c (ruby_qsort): ruby_qsort(qs6) is now native thread safe.

* error.c (rb_sys_fail): it must be a bug if it's called when
  errno == 0.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@d6 1
a6 1
  $Date: 2001/11/29 15:57:25 $
d815 1
d823 6
@


1.88
log
@* string.c (rb_str_equal): object with to_str must be treated as a
  string.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 14:42:45 $
a29 1
#define STR_NO_ORIG FL_USER2
d43 1
a43 1
    str->orig = 0;
d48 2
a49 2
VALUE
rb_str_new0(klass, ptr, len)
d57 1
d71 1
a71 1
    return rb_str_new0(rb_cString, ptr, len);
d102 3
a104 3
VALUE
rb_str_new3(str)
    VALUE str;
d106 1
a106 1
    VALUE str2 = rb_obj_alloc(rb_obj_class(str));
d110 2
a111 1
    RSTRING(str2)->orig = str;
d118 7
d128 1
a128 1
    VALUE klass;
d131 5
a135 12
    if (RSTRING(orig)->orig) {
	VALUE str;

	if (FL_TEST(orig, STR_NO_ORIG)) {
	    str = rb_str_new0(klass, RSTRING(orig)->ptr, RSTRING(orig)->len);
	}
	else {
	    str = rb_str_new3(RSTRING(orig)->orig);
	    RBASIC(str)->klass = klass;
	}
	OBJ_FREEZE(str);
	return str;
d138 1
a138 1
	VALUE str = rb_obj_alloc(klass);
d142 2
a143 5
	RSTRING(orig)->orig = str;
	OBJ_INFECT(str, orig);
	OBJ_FREEZE(str);

	return str;
d145 3
d156 1
a156 1
    return rb_str_new0(rb_obj_class(obj), ptr, len);
a166 1
    FL_SET(str, STR_NO_ORIG);
d171 1
a171 1
    RSTRING(str)->orig = LONG2FIX(capa);
d213 1
a213 1
	RSTRING(str)->orig = 0;
d216 1
a216 2
    if ((!RSTRING(str)->orig||FL_TEST(str,STR_NO_ORIG))&&RSTRING(str)->ptr)
	free(RSTRING(str)->ptr);
d219 7
a225 1
    RSTRING(str)->orig = RSTRING(str2)->orig;
d228 2
d237 9
a245 2
    if (FL_TEST(str, STR_NO_ORIG|STR_ASSOC) != (STR_NO_ORIG|STR_ASSOC)) {
	if (FL_TEST(str, STR_NO_ORIG)) {
d247 1
a247 1
	    if (FIX2LONG(RSTRING(str)->orig) != RSTRING(str)->len) {
d251 3
a253 9
	else if (RSTRING(str)->orig) {
	    rb_str_modify(str);
	}
	RSTRING(str)->orig = add;
	FL_SET(str, STR_NO_ORIG|STR_ASSOC);
    }
    else {
	/* already associated */
	rb_ary_concat(RSTRING(str)->orig, add);
d261 2
a262 2
    if (FL_TEST(str, STR_NO_ORIG|STR_ASSOC) != (STR_NO_ORIG|STR_ASSOC)) {
	return Qfalse;
d264 1
a264 1
    return RSTRING(str)->orig;
d285 2
a286 2
VALUE
rb_str_dup(str)
d288 1
d292 1
a294 1
    klass = rb_obj_class(str);
d296 9
a304 9
    if (OBJ_FROZEN(str)) str2 = rb_str_new3(str);
    else if (FL_TEST(str, STR_NO_ORIG)) {
	str2 = rb_str_new0(klass, RSTRING(str)->ptr, RSTRING(str)->len);
    }
    else if (RSTRING(str)->orig) {
	str2 = rb_str_new3(RSTRING(str)->orig);
	RBASIC(str2)->klass = klass;
	FL_UNSET(str2, FL_TAINT);
	OBJ_INFECT(str2, str);
d309 8
a316 3
    if (FL_TEST(str, FL_EXIVAR))
	rb_copy_generic_ivar(str2, str);
    OBJ_INFECT(str2, str);
d320 7
d331 1
a331 6
    VALUE clone = rb_str_dup(str);
    if (FL_TEST(str, STR_NO_ORIG))
	RSTRING(clone)->orig = RSTRING(str)->orig;
    CLONESETUP(clone, str);

    return clone;
d465 1
a465 3
    if (!RSTRING(str)->orig || FL_TEST(str, STR_NO_ORIG)) return 1;
    if (RBASIC(str)->flags == 0) abort();
    if (TYPE(RSTRING(str)->orig) != T_STRING) rb_bug("non string str->orig");
d482 2
a483 1
    RSTRING(str)->orig = 0;
d497 3
a499 3
    if (RSTRING(str)->orig && !FL_TEST(str, STR_NO_ORIG)) {
	OBJ_FREEZE(RSTRING(str)->orig);
	return RSTRING(str)->orig;
d534 2
a535 6
    if (RSTRING(str)->orig == 0) {
	capa = RSTRING(str)->len;
	FL_SET(str, STR_NO_ORIG);
    }
    else {
	capa = FIX2LONG(RSTRING(str)->orig);
d537 1
a537 1

d544 1
a544 1
	RSTRING(str)->orig = LONG2FIX(capa);
d571 1
a571 2
	if (RSTRING(str)->orig == 0 ||
	    (FL_TEST(str, STR_NO_ORIG) && !FL_TEST(str, STR_ASSOC))) {
d602 2
a603 6
    if (RSTRING(str)->orig == 0) {
	capa = RSTRING(str)->len;
	FL_SET(str, STR_NO_ORIG);
    }
    else {
	capa = FIX2LONG(RSTRING(str)->orig);
d605 1
d613 1
a613 1
	RSTRING(str)->orig = LONG2FIX(capa);
d633 1
a633 2
	if (RSTRING(str)->orig == 0 ||
	    (FL_TEST(str, STR_NO_ORIG) && !FL_TEST(str, STR_ASSOC))) {
a635 1
	    
d818 7
d1544 1
a1544 3
	else {
	    RSTRING(str)->orig = 0;
	}
a1550 1
	RSTRING(dup)->orig = 0;
d1555 1
d1586 1
a1586 1
    if (RSTRING(str2)->orig && !FL_TEST(str2, STR_NO_ORIG)) {
d1592 7
a1598 1
	RSTRING(str)->orig = RSTRING(str2)->orig;
d3132 1
@


1.87
log
@* eval.c (rb_mod_modfunc): should follow NODE_ZSUPER link; based
  on Guy Decoux's patch in [ruby-talk:25478].

* string.c (rb_str_succ): there was buffer overrun.

* parse.y (str_extend): term can be any character.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 05:03:03 $
d725 4
a728 2
    if (TYPE(str2) != T_STRING)
	return Qfalse;
@


1.86
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* massages: replace "wrong #" by "wrong number".

* marshal.c (w_float): output Infinity and NaN explicitly.

* marshal.c (r_object): support new explicit float format.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.

* array.c (rb_ary_join): dumped core if sep is not T_STRING nor T_NIL.

* array.c (rb_ary_join): buffer size calculattion was wrong.

* array.c (rb_ary_to_s): if rb_output_fs is nil, insert newlines
  between array elements (use rb_default_rs as newline litral)
  [experimental].

* gc.c (init_mark_stack): no need to clear mark_stack.

* gc.c (gc_mark_all): need to handle finalizer mark.

* gc.c (gc_mark_rest): use MEMCPY instead of memcpy.

* gc.c (rb_gc_mark): earlier const check to avoid pusing special
  constants into mark stack.

* numeric.c (fix_to_s): 'to_s' now takes optional argument to
  specify radix. [new]

* bignum.c (rb_big_to_s): ditto. [new]
@
text
@d6 1
a6 1
  $Date: 2001/11/13 08:19:52 $
d1021 1
a1021 1
	REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len + 1);
@


1.85
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* eval.c (rb_eval_cmd): should not upgrade safe level unless
  explicitly specified by argument newly added.

* signal.c (sig_trap): should not allow tainted trap closure.

* variable.c (rb_f_trace_var): should not allow trace_var on safe
  level higher than 3.

* variable.c (rb_f_trace_var): should not allow tainted trace
  closure.

* gc.c: do not use static stack until system stack overflows.

* eval.c (eval): should call Exception#exception instead of
  calling rb_exc_new3() directly.

* error.c (exc_exception): set "mesg" directly to the clone.  it
  might be better to set mesg via some method for flexibility.

* variable.c (cvar_override_check): should print original module
  name, if 'a' is T_ICLASS.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/11/08 06:43:08 $
d1142 1
a1142 1
	rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)", argc);
d1298 1
a1298 1
	rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)", argc);
d1331 1
a1331 1
	rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)", argc);
d1382 1
a1382 1
	rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)", argc);
d1456 1
a1456 1
	rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)", argc);
d2228 1
a2228 1
	rb_raise(rb_eArgError, "wrong # of arguments");
d2353 1
a2353 1
	rb_raise(rb_eArgError, "wrong # of arguments");
@


1.84
log
@* process.c (security): always give warning for insecure PATH.

* dir.c (my_getcwd): do not rely on MAXPATHLEN.

* file.c (rb_file_s_readlink): ditto.

* file.c (path_check_1): ditto.

* eval.c (rb_yield_0): should not call rb_f_block_given_p().

* string.c (rb_str_chomp_bang): should terminate string by NUL.

* eval.c (rb_yield_0): better error message.
@
text
@d6 1
a6 1
  $Date: 2001/10/31 06:53:22 $
d106 1
a106 1
    VALUE str2 = rb_obj_alloc(rb_cString);
d127 1
a127 1
	    str = rb_str_new(RSTRING(orig)->ptr, RSTRING(orig)->len);
d131 1
a133 1
	RBASIC(str)->klass = klass;
a141 1
	RSTRING(str)->orig = 0;
d289 1
a289 1
	str2 = rb_str_new(RSTRING(str)->ptr, RSTRING(str)->len);
d293 1
a302 1
    RBASIC(str2)->klass = klass;
d450 1
@


1.83
log
@* eval.c (POP_VARS): should not set DVAR_DONT_RECYCLE if _old
  ruby_vars is already force_recycled.

* gc.c (rb_gc): handles mark stack overflow.

* gc.c (PUSH_MARK): use static mark stack, no more recursion.
@
text
@d6 1
a6 1
  $Date: 2001/10/30 08:43:25 $
d294 2
a2677 1
		return str;
a2680 1
		return str;
d2682 5
a2686 1
	    return Qnil;
@


1.82
log
@* string.c (rb_str_chomp_bang): do smart chomp if $/ == '\n'.

* io.c (rb_io_puts): don't treat Array specially.

* bignum.c (rb_big_cmp): should convert bignum to float.

* eval.c (rb_f_eval): can't modify untainted binding.

* regex.c (re_compile_pattern): should preverve p0 value.
@
text
@d6 1
a6 1
  $Date: 2001/10/16 03:27:06 $
d1104 2
a1105 1
	if (rb_str_index(str, indx, 0) != -1) return indx;
@


1.81
log
@* string.c (rb_str_index): wrong increment for non alphanumeric
  string.
@
text
@d6 1
a6 1
  $Date: 2001/10/03 07:19:10 $
d2664 1
d2666 17
d2685 1
d2688 1
d2693 2
d2706 2
@


1.80
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/10/02 04:31:19 $
d1014 2
a1015 2
	    *s += 1;
	    if (*s-- != 0) break;
@


1.79
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* string.c (rb_str_subpat_set): support function for new argument
  pattern String#[re,offset] = val. [new]

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_aref_m): new argument pattern
  String#[re,offset]. [new]

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* array.c (rb_ary_initialize): Array.new([1,2,3]) => [1,2,3]. [new]

* string.c (rb_str_reverse): should return an instance of
  receiver's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.

* eval.c (eval): retrieves file, line information from binding.

* eval.c (intersect_fds): counts intersecting fds.

* eval.c (rb_thread_schedule): only fds requested by
  each thread count as select_value.
@
text
@d6 1
a6 1
  $Date: 2001/09/19 06:54:11 $
d35 14
d55 1
a55 2
    NEWOBJ(str, struct RString);
    OBJSETUP(str, klass, T_STRING);
d57 2
a58 4
    str->ptr = 0;
    str->len = len;
    str->orig = 0;
    str->ptr = ALLOC_N(char,len+1);
d60 1
a60 1
	memcpy(str->ptr, ptr, len);
d62 2
a63 2
    str->ptr[len] = '\0';
    return (VALUE)str;
d106 1
a106 2
    NEWOBJ(str2, struct RString);
    OBJSETUP(str2, rb_cString, T_STRING);
d108 3
a110 3
    str2->len = RSTRING(str)->len;
    str2->ptr = RSTRING(str)->ptr;
    str2->orig = str;
d113 1
a113 1
    return (VALUE)str2;
d137 1
a137 2
	NEWOBJ(str, struct RString);
	OBJSETUP(str, klass, T_STRING);
d139 4
a142 4
	str->len = RSTRING(orig)->len;
	str->ptr = RSTRING(orig)->ptr;
	RSTRING(orig)->orig = (VALUE)str;
	str->orig = 0;
d146 1
a146 1
	return (VALUE)str;
d165 1
a165 2
    NEWOBJ(str, struct RString);
    OBJSETUP(str, rb_cString, T_STRING);
d170 5
a174 5
    str->ptr = 0;
    str->len = 0;
    str->orig = LONG2FIX(capa);
    str->ptr = ALLOC_N(char, capa+1);
    str->ptr[0] = '\0';
d176 1
a176 1
    return (VALUE)str;
a316 12
static VALUE
rb_str_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE str = rb_str_new0(klass, 0, 0);

    rb_obj_call_init(str, argc, argv);
    return str;
}

d1070 1
a1070 1
rb_str_subpat(str, re, offset)
d1072 1
a1072 1
    int offset;
d1075 1
a1075 1
	return rb_reg_nth_match(offset, rb_backref_get());
d1152 4
d1157 3
a1161 6
    if (beg < 0 || RSTRING(str)->len < beg) {
	if (beg < 0) {
	    beg -= RSTRING(str)->len;
	}
	rb_raise(rb_eIndexError, "index %d out of string", beg);
    }
d1189 1
a1189 1
rb_str_subpat_set(str, re, offset, val)
d1191 1
a1191 1
    int offset;
d1201 9
a1209 2
    if (offset >= RMATCH(match)->regs->num_regs) {
	rb_raise(rb_eIndexError, "index %d out of regexp", offset);
d1212 1
a1212 1
    start = RMATCH(match)->BEG(offset);
d1214 1
a1214 1
	rb_raise(rb_eIndexError, "regexp group %d not matched", offset);
d1216 1
a1216 1
    end = RMATCH(match)->END(offset);
d1232 4
d1237 2
a1240 3
	if (idx < 0 || RSTRING(str)->len <= idx) {
	    rb_raise(rb_eIndexError, "index %d out of string", idx);
	}
d1532 2
a1533 2
	NEWOBJ(dup, struct RString);
	OBJSETUP(dup, rb_cString, T_STRING);
d1535 2
a1536 3
	RBASIC(dup)->klass = rb_obj_class(str);
	str = (VALUE)dup;
	dup->orig = 0;
d2573 1
d3064 1
a3064 1
    rb_define_singleton_method(rb_cString, "new", rb_str_s_new, -1);
@


1.78
log
@* string.c (rb_str_init): String.new() => ""

* dir.c (dir_path): new method.

* dir.c (dir_initialize): wrap DIR into struct, along with path
  information.
@
text
@d6 1
a6 1
  $Date: 2001/09/08 14:17:10 $
d36 2
a37 1
rb_str_new(ptr, len)
d42 1
a42 1
    OBJSETUP(str, rb_cString, T_STRING);
d56 8
d141 9
a296 1

d315 1
a315 2
    VALUE str = rb_str_new(0, 0);
    OBJSETUP(str, klass, T_STRING);
d379 1
a379 1
    if (len == 0) return rb_str_new(0,0);
d387 1
a387 1
    str2 = rb_str_new(0, RSTRING(str)->len*len);
d394 1
a394 3
    if (OBJ_TAINTED(str)) {
	OBJ_TAINT(str2);
    }
d437 1
a437 1
    if (len == 0) return rb_str_new(0,0);
d439 2
a440 2
    str2 = rb_str_new(RSTRING(str)->ptr+beg, len);
    if (OBJ_TAINTED(str)) OBJ_TAINT(str2);
d1001 1
a1001 1
    str = rb_str_new(RSTRING(orig)->ptr, RSTRING(orig)->len);
d1074 11
d1105 1
a1105 3
	if (rb_reg_search(indx, str, 0, 0) >= 0)
	    return rb_reg_last_match(rb_backref_get());
	return Qnil;
d1137 3
d1191 25
a1215 1
static VALUE rb_str_sub_bang _((int, VALUE*, VALUE));
d1247 1
a1247 6
        {
	    VALUE args[2];
	    args[0] = indx;
	    args[1] = val;
	    rb_str_sub_bang(2, args, str);
	}
d1279 6
a1284 5
	long beg, len;

	beg = NUM2INT(argv[0]);
	len = NUM2INT(argv[1]);
	rb_str_update(str, beg, len, argv[2]);
d1528 1
d1579 1
a1579 1
    if (OBJ_TAINTED(str2)) OBJ_TAINT(str);
d1666 1
a1666 1
    obj = rb_str_new(0, RSTRING(str)->len);
d1673 1
d1822 1
a1822 1
    result = rb_str_new(0, len);
d2483 1
a2483 1
		    tmp = rb_str_new(0, 0);
d2493 1
a2493 1
	    tmp = rb_str_new(0, 0);
d2566 1
a2566 1
	    line = rb_str_new(s, p - s);
d2576 1
a2576 1
	line = rb_str_new(s, p - s);
d2983 1
a2983 1
    res = rb_str_new(0, width);
d3003 1
a3003 1
    res = rb_str_new(0, width);
d3024 1
a3024 1
    res = rb_str_new(0, width);
@


1.77
log
@* eval.c (rb_thread_restore_context): save current value of
  lastline and lastmatch in the thread struct for later restore.

* eval.c (rb_thread_save_context): restore lastline and lastmatch.

* numeric.c (flo_to_s): should handle negative float value.

* class.c (rb_include_module): should check whole ancestors to
  avoid duplicate module inclusion.

* string.c (trnext): should check backslash before updating "now"
  position.
@
text
@d6 1
a6 1
  $Date: 2001/08/29 06:28:44 $
d305 15
d3010 1
a3010 1
    rb_define_method(rb_cString, "initialize", rb_str_replace, 1);
@


1.76
log
@* parse.y (yylex): ternary ? can be followed by newline.

* eval.c (rb_f_require): should check static linked libraries
  before raising exception.

* array.c (rb_ary_equal): check identiry equality first.

* string.c (rb_str_equal): ditto.

* struct.c (rb_struct_equal): ditto.

* numeric.c (Init_Numeric): undef Integer::new.

* eval.c (rb_eval): NODE_WHILE should update result for each
  conditional evaluation.

* eval.c (rb_eval): NODE_UNTIL should return last evaluated value
  (or value given to break).
@
text
@d6 1
a6 1
  $Date: 2001/08/20 04:29:56 $
a1969 1
	    t->now = *(USTR)t->p++;
d1973 2
a1974 1
	    else if (t->p < t->pend - 1 && *t->p == '-') {
@


1.75
log
@* range.c (range_step): 'iter' here should be an array.

* marshal.c (w_object): should retrieve __member__ data from
  non-singleton class.

* variable.c (rb_cvar_get): class variable override check added.

* variable.c (rb_cvar_set): ditto

* variable.c (rb_cvar_declare): ditto.

* parse.y (parse_regx): handle backslash escaping of delimiter here.
@
text
@d6 1
a6 1
  $Date: 2001/08/14 08:13:26 $
d697 1
@


1.74
log
@* range.c (range_step): new method.

* string.c (rb_str_cmp): remove needless conditional.

* string.c (rb_str_lstrip_bang) `return Qnil' was missing.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/08/12 09:41:39 $
d103 1
a103 1
    klass = rb_obj_type(orig);
d260 1
a260 1
    klass = rb_obj_type(str);
@


1.73
log
@* string.c (rb_str_cat): fix buffer overflow.

* string.c (rb_str_append): nothing to append actually when `str2'
  is empty.
@
text
@d6 1
a6 1
  $Date: 2001/08/06 15:05:50 $
a688 1
    if (retval == 0) return 0;
d2676 1
a3067 1
    rb_define_method(rb_cString, "strip!", rb_str_strip_bang, 0);
@


1.72
log
@a problem about `associated' String and `str_buf'.

* pack.c (pack_unpack): associates p/P strings once at
  last(reverted to 1.26).

* string.c (rb_str_associate): associates an Array at once, not
  but a String. realloc's when str_buf.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/08/06 03:05:13 $
d537 1
a537 1
	REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len+1);
d597 2
a598 2
    len = RSTRING(str)->len+RSTRING(str2)->len;
    if (len > 0) {
@


1.71
log
@* string.c (rb_str_lstrip_bang): new method.

* string.c (rb_str_rstrip_bang): new method.

* string.c (rb_str_associate): should consider STR_ASSOC too.

* eval.c (rb_undefined): do not recurse if method_missing is
  undefined.

* process.c (proc_waitpid): now all arguments are optional.

* process.c (Init_process): waitpid is now alias to wait.

* process.c (Init_process): waitpid2 is now alias to wait2.

* process.c (rb_waitpid): made public.

* ext/pty/pty.c (pty_getpty): avoid disturbing SIGCHLD using
  thread and rb_waitpid.

* process.c (proc_getpgrp): now takes no argument on all
  platforms.

* process.c (proc_setpgrp): ditto.

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::pack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::pack_sockaddr_un(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::unpack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::unpack_sockaddr_un(). [new]
@
text
@d6 1
a6 1
  $Date: 2001/07/24 09:07:33 $
d206 7
a212 1
	if (RSTRING(str)->orig) {
d215 1
a215 1
	RSTRING(str)->orig = rb_ary_new();
d218 4
a221 1
    rb_ary_push(RSTRING(str)->orig, add);
@


1.70
log
@* eval.c (rb_provide_feature): should not tweak extension used for
  loading.

* io.c (io_fread): use fread(3) if PENDING_COUND is available.

* class.c (rb_mod_include_p): Module#include? added. [new]

* re.c (ignorecase_setter): give warning on modifying $=.

* string.c (rb_str_casecmp): new method. [new]

* string.c (rb_str_eql): separated from rb_str_equal(), make it
  always be case sensitive. [new]

* string.c (rb_str_hash): made it always be case sensitive.

* eval.c (rb_f_require): should not include path in $" value

* file.c (rb_find_file): should return 0 explicitly on failure.
@
text
@d6 1
a6 1
  $Date: 2001/07/18 05:55:20 $
d205 1
a205 1
    if (!FL_TEST(str, STR_NO_ORIG)) {
d219 1
a219 1
    if (!FL_TEST(str, STR_NO_ORIG|STR_ASSOC)) {
d2651 1
a2651 1
rb_str_strip_bang(str)
d2662 27
d2695 1
a2695 5
    if (s > RSTRING(str)->ptr) { 
	char *p = RSTRING(str)->ptr;

	RSTRING(str)->ptr = ALLOC_N(char, RSTRING(str)->len+1);
	memcpy(RSTRING(str)->ptr, s, RSTRING(str)->len);
d2697 1
a2697 7
	free(p);
    }
    else if (t < e) {
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
    }
    else {
	return Qnil;
d2699 18
d2718 1
d3054 2
d3062 3
@


1.69
log
@* regex.c (NUM_FAILURE_ITEMS): was confusing NUM_REG_ITEMS and
  NUM_NONREG_ITEMS, which have happened to be same value.

* class.c (rb_class_new): subclass check moved to this function.

* class.c (rb_class_boot): check less version of rb_class_new().

* eval.c (proc_invoke): should preserve iter status for embedded
  frame in the block.

* file.c (rb_file_s_expand_path): may overrun buffer on stack.

* string.c (rb_str_insert): forgot to call rb_str_modify().
@
text
@d6 1
a6 1
  $Date: 2001/07/14 15:17:19 $
d642 2
a643 10
    if (ruby_ignorecase) {
	while (len--) {
	    key = key*33 + toupper(*p);
	    p++;
	}
    }
    else {
	while (len--) {
	    key = key*33 + *p++;
	}
d647 3
a649 11
    if (ruby_ignorecase) {
	while (len--) {
	    key = key*65599 + toupper(*p);
	    p++;
	}
    }
    else {
	while (len--) {
	    key = key*65599 + *p;
	    p++;
	}
d700 14
d725 20
d2955 1
a2955 1
    rb_define_method(rb_cString, "eql?", rb_str_equal, 1);
d2957 1
@


1.68
log
@* regex.c (re_search): should consider reverse search.

* dir.c (dir_s_chdir): warn only when invoked from multiple
  threads or block is not given.

* object.c (rb_convert_type): should use rb_rescue(), not rb_rescue2().

* range.c (range_init): ditto.

* object.c (rb_obj_dup): should free generic_ivar if original owns
  them.

* string.c (rb_str_each_line): should propagate taint mark.

* ext/nkf/nkf.c (rb_nkf_kconv): ditto.

* eval.c (rb_f_require): revamp for simpler implementation.

* file.c (rb_find_file_noext): use String object, instead of
  passing char* around.

* file.c (rb_find_file): ditto.

* dln.c (dln_load): should use NSLINKMODULE_OPTION_BINDNOW.

* ruby.c (load_file): local variables 'c' remain uninitialized on
  xflag.

* regex.c (re_match): prefetched escaped character too early.

* eval.c (rb_call0): add argument check for attr_readers.
@
text
@d6 1
a6 1
  $Date: 2001/05/30 09:12:34 $
d1211 1
@


1.67
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d6 1
a6 1
  $Date: 2001/05/16 09:05:50 $
d103 1
a103 5
    klass = CLASS_OF(orig);
    while (TYPE(klass) == T_ICLASS || FL_TEST(klass, FL_SINGLETON)) {
	klass = (VALUE)RCLASS(klass)->super;
    }

d251 1
a251 4
    klass = CLASS_OF(str);
    while (TYPE(klass) == T_ICLASS || FL_TEST(klass, FL_SINGLETON)) {
	klass = (VALUE)RCLASS(klass)->super;
    }
d263 2
@


1.66
log
@* array.c (rb_ary_and): should not push frozen key string.

* array.c (rb_ary_or): ditto.

* eval.c (rb_thread_schedule): should save context before raising
  deadlock, saved context for current thread might be obsolete.

* time.c (make_time_t): non DST timezone shift supported (hopefully).

* time.c (make_time_t): strict range detection for negative time_t.

* signal.c: SIGINFO added.

* eval.c (rb_ensure): should not SEGV when prot_tag is NULL.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/05/11 06:13:45 $
d31 1
d136 34
d214 1
a214 1
	FL_SET(str, STR_NO_ORIG);
d223 1
a223 1
    if (!FL_TEST(str, STR_NO_ORIG)) {
d481 39
d525 3
d529 3
a531 6
	int poffset = -1;

	rb_str_modify(str);
	if (RSTRING(str)->ptr <= ptr &&
	    ptr < RSTRING(str)->ptr + RSTRING(str)->len) {
	    poffset = ptr - RSTRING(str)->ptr;
d533 1
a533 1
	REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len + len + 1);
a534 1
	    if (poffset >= 0) ptr = RSTRING(str)->ptr + poffset;
d537 3
d543 1
d556 32
a587 2
rb_str_append(str1, str2)
    VALUE str1, str2;
d589 2
d592 17
a608 2
    str1 = rb_str_cat(str1, RSTRING(str2)->ptr, RSTRING(str2)->len);
    OBJ_INFECT(str1, str2);
d610 1
a610 1
    return str1;
d1125 1
d1646 1
a1646 1
    VALUE result = rb_str_new2("\"");
d1654 1
a1654 1
	    rb_str_cat(result, p - 1, len);
d1659 1
a1659 1
	    rb_str_cat(result, s, 2);
d1663 1
a1663 1
	    rb_str_cat(result, s, 1);
d1667 1
a1667 1
	    rb_str_cat(result, s, 2);
d1671 1
a1671 1
	    rb_str_cat(result, s, 2);
d1675 1
a1675 1
	    rb_str_cat(result, s, 2);
d1679 1
a1679 1
	    rb_str_cat(result, s, 2);
d1683 1
a1683 1
	    rb_str_cat(result, s, 2);
d1687 1
a1687 1
	    rb_str_cat(result, s, 2);
d1691 1
a1691 1
	    rb_str_cat(result, s, 2);
d1695 1
a1695 1
	    rb_str_cat2(result, s);
d1698 1
a1698 1
    rb_str_cat2(result, "\"");
d2789 1
a2789 1
    return rb_str_new2(crypt(RSTRING(str)->ptr, RSTRING(salt)->ptr));
d2866 1
d2886 1
d2912 1
@


1.65
log
@* ruby.h (rb_string_value): add volatile to avoid compiler warning.
* string.c (rb_string_value): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/05/11 05:24:54 $
d431 2
a432 1
    rb_str_modify(str);
d434 6
a439 3
    if (len >= 0) {
	if (RSTRING(str)->len < len || RSTRING(str)->len - len > 1024) {
	    REALLOC_N(RSTRING(str)->ptr, char, len + 1);
a440 2
	RSTRING(str)->len = len;
	RSTRING(str)->ptr[len] = '\0';	/* sentinel */
d961 1
a961 1
static void
a1519 1
    long len;
a1520 1
    char *q, *qend;
@


1.64
log
@* bignum.c (bigdivrem): access boundary bug.

* marshal.c (w_object): prohibit dumping out singleton classes.

* object.c (rb_mod_to_s): distinguish singleton classes.

* variable.c (rb_class2name): it's ok to reveal NilClass,
  TrueClass, FalseClass.

* eval.c (rb_yield_0): preserve and restore ruby_cref as well.

* eval.c (is_defined): core dumped during instance_eval for
  special constants.

* eval.c (rb_eval): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/05/06 15:01:59 $
d144 1
a144 1
    VALUE *ptr;
@


1.63
log
@forgot some checkins.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:11 $
d140 7
@


1.62
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d6 1
a6 1
  $Date: 2001/03/26 08:57:10 $
d953 1
a953 1
rb_str_replace(str, beg, len, val)
d1021 1
a1021 1
	    rb_str_replace(str, idx, 1, val);
d1037 1
a1037 1
	    rb_str_replace(str, beg, RSTRING(indx)->len, val);
d1046 1
a1046 1
		rb_str_replace(str, beg, len, val);
d1067 1
a1067 1
	rb_str_replace(str, beg, len, argv[2]);
d1080 9
a1088 1
    rb_str_replace(str, NUM2LONG(idx), 0, str2);
d1340 1
a1340 1
rb_str_replace_m(str, str2)
d2800 1
a2800 1
    rb_define_method(rb_cString, "initialize", rb_str_replace_m, 1);
d2826 1
a2826 1
    rb_define_method(rb_cString, "replace", rb_str_replace_m, 1);
@


1.61
log
@* eval.c: remove TMP_PROTECT_END to prevent C_ALLOCA crash.

* file.c (rb_file_flock): do not trap EINTR.

* missing/flock.c (flock): returns the value from lockf(2)
  directly.

* eval.c (ev_const_defined): should ignore toplevel cbase (Object).

* eval.c (ev_const_get): ditto.

* ext/md5/md5.h: replace by independent md5 implementation
  contributed by L. Peter Deutsch (thanks).

* ext/md5/md5init.c: adopted to Deutsch's md5 implementation.

* pack.c (pack_unpack): string from P/p should be tainted.

* ext/curses/curses.c: curses on Mac OS X public beta does not
  have _maxx etc.

* marshal.c (w_object): should truncate trailing zero short for
  bignums.

* object.c (sym_intern): new method.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/03/04 09:45:29 $
d212 1
a212 1
    if (TYPE(str) != T_STRING) str = rb_str_to_str(str);
d281 1
a281 1
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
d473 1
a473 1
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
d593 1
a593 1
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
d868 1
a868 2
    if (TYPE(end) != T_STRING) end = rb_str_to_str(end);

d954 1
a954 1
    VALUE str, val;
d957 1
d959 10
d973 1
a1020 1
	    if (TYPE(val) != T_STRING) val = rb_str_to_str(val);
a1036 1
	    if (TYPE(val) != T_STRING) val = rb_str_to_str(val);
a1045 1
		if (TYPE(val) != T_STRING) val = rb_str_to_str(val);
a1064 1
	if (TYPE(argv[2]) != T_STRING) argv[2] = rb_str_to_str(argv[2]);
a1066 13
	if (len < 0) rb_raise(rb_eIndexError, "negative length %d", len);
	if (beg < 0) {
	    beg += RSTRING(str)->len;
	}
	if (beg < 0 || RSTRING(str)->len < beg) {
	    if (beg < 0) {
		beg -= RSTRING(str)->len;
	    }
	    rb_raise(rb_eIndexError, "index %d out of string", beg);
	}
	if (beg + len > RSTRING(str)->len) {
	    len = RSTRING(str)->len - beg;
	}
d1077 8
d1141 2
a1142 1
	repl = rb_str_to_str(argv[1]);;
d1215 2
a1216 1
	repl = rb_str_to_str(argv[1]);
a1335 1
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
d1337 1
d1469 1
a1469 1
    if (TYPE(arg) != T_STRING) arg = rb_str_to_str(arg);
d1848 2
a1849 1
    if (TYPE(src) != T_STRING) src = rb_str_to_str(src);
a1854 1
    if (TYPE(repl) != T_STRING) repl = rb_str_to_str(repl);
d1998 1
a1998 2
	if (TYPE(s) != T_STRING) 
	    s = rb_str_to_str(s);
d2052 1
a2052 2
	    if (TYPE(s) != T_STRING) 
		s = rb_str_to_str(s);
d2123 1
a2123 2
	if (TYPE(s) != T_STRING) 
	    s = rb_str_to_str(s);
d2288 1
a2288 1
    if (TYPE(str) != T_STRING) str = rb_str_to_str(str);
d2323 1
a2323 4
    if (TYPE(rs) != T_STRING) {
	rs = rb_str_to_str(rs);
    }

d2435 1
a2435 1
    if (TYPE(rs) != T_STRING) rs = rb_str_to_str(rs);
d2646 1
a2646 1
    if (TYPE(salt) != T_STRING) salt = rb_str_to_str(salt);
d2805 1
@


1.60
log
@* string.c (trnext): support backslash escape in String#tr.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/02/28 06:30:03 $
d187 1
a187 1
static ID to_str;
d198 1
a198 1
    str = rb_funcall(obj, to_str, 0);
d1139 1
a1139 1
	repl = rb_obj_as_string(argv[1]);;
d1212 1
a1212 1
	repl = rb_obj_as_string(argv[1]);
d2903 1
a2903 1
    to_str = rb_intern("to_s");
@


1.59
log
@* string.c (rb_str_delete_bang): delete! should take at least 1
  argument.

* ruby.c (load_file): add rb_gc() after loading to avoid
  extraordinary memory growth.

* dir.c (rb_glob_helper): "./foo" should match "foo", not "./foo".

* eval.c (ev_const_get): retrieve Object's constant if no current
  class is available (e.g. defining singleton class for Fixnums).

* eval.c (ev_const_defined): check Object's constant if no current
  class is available (e.g. defining singleton class for Fixnums).

* time.c (time_timeval): negative time interval shoule not be
  allowed.

* eval.c (proc_call): ignore block to `call' always, despite of
  being orphan or not.

* eval.c (rb_yield_0): should check based on rb_block_given_p()
  and rb_f_block_given_p().

* configure.in (frame-address): --enable-frame-address to allow
  __builtin_frame_address() to be used.

* eval.c (stack_length): use __builtin_frame_address() based on
  the macro USE_BUILTIN_FRAME_ADDRESS.

* gc.c (rb_gc): ditto.

* gc.c (Init_stack): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/02/19 09:14:58 $
d1804 4
a1807 1
	    if (t->p < t->pend - 1 && *t->p == '-') {
@


1.58
log
@* string.c (rb_str_substr): "a"[1,2] should return ""; need
  rubicon upgrade.
@
text
@d6 1
a6 1
  $Date: 2001/02/08 09:19:17 $
d1985 3
@


1.57
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_options): new method to give an option values.

* parse.y (cond0): disable special treating of integer literal in
  conditional unless option -e is supplied.  changes current
  behavior.  experimental.

* parse.y (cond0): give warning for string/integer literals and
  dot operators in conditionals unless option -e is supplied.

* re.c (rb_reg_equal): all option flags should be same to be equal.

* error.c (Init_Exception): make Interrupt a subclass of
  SignalException.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:38:11 $
a351 1
    if (beg == RSTRING(str)->len && len > 0) return Qnil;
@


1.56
log
@* array.c (rb_ary_sort_bang): returns self, even if its length is
  less than 2.

* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2001/01/29 05:10:42 $
d1665 1
a1665 1
	else if (islower(*s)) {
@


1.55
log
@* string.c (str_independent): should not clear str->orig here.
  it's too early.
@
text
@d6 1
a6 1
  $Date: 2001/01/15 07:00:54 $
d1291 3
d1300 1
a1304 1
    RSTRING(str)->orig = 0;
@


1.54
log
@Mon Jan 15 16:00:07 2001  Yukihiro Matsumoto  <matz@@ruby-lang.org>

	* pack.c (pack_unpack): should check associated pointer packed by
	  pack("P").  restriction added.

Sun Jan 14 21:49:28 2001  Koji Arai  <JCA02266@@nifty.ne.jp>

	* sprintf.c (rb_f_sprintf): simple typo.  binary base should be 2,
	  not '2'.

	* re.c (rb_reg_s_last_match): should explicitly return nth match.
@
text
@d6 1
a6 1
  $Date: 2001/01/09 16:55:50 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
a379 1
    RSTRING(str)->orig = 0;
d396 1
a1296 1
	dup->orig = 0;
d1301 1
@


1.53
log
@* string.c (rb_str_reverse_bang): forgot to call rb_str_modify().

* object.c (rb_obj_taint): check frozen status before modifying
  taint status.

* object.c (rb_obj_untaint): ditto.
@
text
@d6 1
a6 1
  $Date: 2000/12/26 08:32:35 $
d175 10
@


1.52
log
@matz
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2000/12/26 08:08:50 $
d1402 1
@


1.52.2.1
log
@m17n baseline
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/12/26 08:32:35 $
a33 112
<<<<<<< string.c
static ID id_encoding = 0;

#define ENCODING_INLINE_MAX 127
#define ENCODING_MASK (FL_USER1|FL_USER2|FL_USER3|FL_USER4|FL_USER5|FL_USER6|FL_USER7)
#define ENCODING_SHIFT (FL_USHIFT+1)
#define ENCODING_SET(obj,i) do {\
    RBASIC(obj)->flags &= ~ENCODING_MASK;\
    RBASIC(obj)->flags |= i << ENCODING_SHIFT;\
} while (0)
#define ENCODING_GET(obj) ((RBASIC(obj)->flags & ENCODING_MASK)>>ENCODING_SHIFT)

void
rb_m17n_associate_encoding(obj, enc)
    VALUE obj;
    m17n_encoding *enc;
{
    int i = enc->index;

    if (i < ENCODING_INLINE_MAX) {
	ENCODING_SET(obj, i);
	return;
    }
    ENCODING_SET(obj, ENCODING_INLINE_MAX);
    if (!id_encoding) {
	id_encoding = rb_intern("encoding");
    }
    rb_ivar_set(obj, id_encoding, INT2NUM(i));
    return;
}

m17n_encoding*
rb_m17n_get_encoding(obj)
    VALUE obj;
{
    int i = ENCODING_GET(obj);

    if (i == ENCODING_INLINE_MAX) {
	VALUE iv;

	if (!id_encoding) {
	    return ruby_default_encoding;
	}
	iv = rb_ivar_get(obj, id_encoding);
	i = NUM2INT(iv);
    }
    return m17n_index_to_encoding(i);
}

static int
enc_memcmp(p1, p2, len, enc)
    char *p1, *p2;
    long len;
    m17n_encoding *enc;
{
    if (!ruby_ignorecase) {
	return memcmp(p1, p2, len);
    }
    return m17n_memcmp(p1, p2, len, enc);
}

void
rb_m17n_enc_check(str1, str2, enc)
    VALUE str1, str2;
    m17n_encoding **enc;
{
    m17n_encoding *enc2;

    *enc = rb_m17n_get_encoding(str1);
    enc2 = rb_m17n_get_encoding(str2);

    if (*enc != enc2) {
	rb_raise(rb_eArgError, "character encodings differ");
    }
}

VALUE
rb_enc_get_encoding(str)
    VALUE str;
{
    m17n_encoding *enc = rb_m17n_get_encoding(str);
    return rb_str_new2(enc->name);
}

VALUE
rb_enc_set_encoding(obj, encoding)
    VALUE obj, encoding;
{
    m17n_encoding *enc = m17n_find_encoding(STR2CSTR(encoding));

    if (!enc) {
	rb_raise(rb_eArgError, "undefined encoding `%s'", STR2CSTR(encoding));
    }
    if (OBJ_FROZEN(obj)) {
	rb_error_frozen("object's encoding");
    }
    rb_m17n_associate_encoding(obj, enc);

    return encoding;
}

static void
rb_str_copy_encoding(str1, str2)
    VALUE str1, str2;
{
    rb_m17n_associate_encoding(str1, rb_m17n_get_encoding(str2));
}

#define str_ptr(str) RSTRING(str)->ptr
#define str_len(str) RSTRING(str)->len
#define str_end(str) (str_ptr(str)+str_len(str))

d552 2
a553 6
    m17n_encoding *enc;

    rb_m17n_enc_check(str1, str2, &enc);
    len = lesser(str_len(str1), str_len(str2));

    retval = enc_memcmp(str_ptr(str1), str_ptr(str2), len, enc);
d994 3
a996 25
<<<<<<< string.c
	    unsigned int c = NUM2UINT(val);
	    int clen = m17n_codelen(enc, c);
	    char *p = str_nth(enc, str_ptr(str), str_end(str), idx);
	    int plen;

	    if (!p) goto bad_idx;
	    if (p == str_end(str)) plen = 0;
	    else {
		plen = m17n_mbcspan(enc, p, str_end(str));
		if (plen == 0) {
		    rb_raise(rb_eArgError, "invalid mbstring sequence at %d", idx);
		}
	    }

	    if (plen != clen) {
		long offset = p - str_ptr(str);
		char *p0 = str_ptr(str);

		str_ptr(str) = ALLOC_N(char, str_len(str) + clen - plen);
		memcpy(str_ptr(str), p0, offset);
		p = str_ptr(str) + offset;
		memcpy(p + clen, p0 + offset + plen, str_len(str) - offset);
		str_len(str) += clen - plen;
		str_ptr(str)[str_len(str)] = '\0';
d998 1
a998 1
	    m17n_mbcput(enc, c, p);
d1396 18
a1416 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
d1420 1
a1420 1
    if (str_len(str) <= 1) return rb_str_dup(str);
d1422 3
a1424 14
    obj = rb_str_new(0, str_len(str));
    s = str_ptr(str);
    e = str_end(str);
    p = str_end(obj);

    if (m17n_mbmaxlen(enc) == 1) {
	while (s < e) {
	    *--p = *s++;
	}
    }
    else {
	while (s < e) {
	    int c = m17n_codepoint(enc, s, e);
	    int clen = m17n_codelen(enc, c);
d1426 2
a1427 4
	    p -= clen;
	    m17n_mbcput(enc, c, p);
	    s += clen;
	}
a1428 1
    rb_str_copy_encoding(obj, str);
a1433 10
rb_str_reverse_bang(str)
    VALUE str;
{
    rb_str_modify(str);
    rb_str_become(str, rb_str_reverse(str));

    return str;
}

static VALUE
a1941 6
	if (!*ctablep) *ctablep = rb_hash_new();
	table = *ctablep;
    }
    else {
	if (!*tablep) *tablep = rb_hash_new();
	table = *tablep;
d2174 1
a2174 3
	    while (ptr < eptr) {
		c = m17n_codepoint(enc, ptr, eptr);

@


1.52.2.2
log
@m17n fix
@
text
@d6 1
a6 1
  $Date: 2001/01/10 07:52:46 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
d22 1
d30 1
a30 1
#define STR_NO_ORIG FL_USER0
d34 1
d84 1
a84 1
str_memcmp(p1, p2, len, enc)
a99 1
    m17n_encoding *enc1;
d102 1
a102 1
    enc1 = rb_m17n_get_encoding(str1);
d105 1
a105 7
    if (enc1->index == 0 && m17n_asciicompat(enc2)) {
	*enc = enc2;
    }
    else if (enc2->index == 0 && m17n_asciicompat(enc1)) {
	*enc = enc1;
    }
    else if (enc1 != enc2) {
a107 3
    else {
	*enc = enc1;
    }
a161 1
    rb_m17n_associate_encoding((VALUE)str, ruby_default_encoding);
d200 2
a201 2
    str2->len = str_len(str);
    str2->ptr = str_ptr(str);
a203 1
    rb_m17n_associate_encoding((VALUE)str2, rb_m17n_get_encoding(str));
d223 1
a223 1
	    str = rb_str_new(str_ptr(orig), str_len(orig));
d236 2
a237 2
	str->len = str_len(orig);
	str->ptr = str_ptr(orig);
a239 1
	rb_m17n_associate_encoding((VALUE)str, rb_m17n_get_encoding(orig));
d265 4
a268 4
    if ((!RSTRING(str)->orig||FL_TEST(str,STR_NO_ORIG))&&str_ptr(str))
	free(str_ptr(str));
    RSTRING(str)->ptr = str_ptr(str2);
    RSTRING(str)->len = str_len(str2);
a271 1
    rb_str_copy_encoding(str, str2);
d322 1
a322 1
	str2 = rb_str_new(str_ptr(str), str_len(str));
a360 2
static VALUE rb_str_replace_m _((VALUE str, VALUE str2));

a361 32
rb_str_initialize(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE str2, encoding;

    rb_scan_args(argc, argv, "11", &str2, &encoding);
    rb_str_replace_m(str, str2);
    if (!NIL_P(encoding)) {
	rb_enc_set_encoding(str, encoding);
    }

    return str;
}

static int
str_strlen(str, enc)
    VALUE str;
    m17n_encoding *enc;
{
    int len;

    if (m17n_mbmaxlen(enc) == 1) return str_len(str);
    len = m17n_strlen(enc, str_ptr(str), str_end(str));
    if (len < 0) {
	rb_raise(rb_eArgError, "invalid mbstring sequence");
    }
    return len;
}

VALUE
d365 1
a365 12
    m17n_encoding *enc = rb_m17n_get_encoding(str);
    int len;

    len = str_strlen(str, enc);
    return INT2NUM(len);
}

static VALUE
rb_str_size(str)
    VALUE str;
{
    return INT2NUM(str_len(str));
d372 1
a372 1
    if (str_len(str) == 0)
d384 5
a388 5
    str3 = rb_str_new(0, str_len(str1)+str_len(str2));
    memcpy(str_ptr(str3), str_ptr(str1), str_len(str1));
    memcpy(str_ptr(str3) + RSTRING(str1)->len,
	   str_ptr(str2), str_len(str2));
    str_ptr(str3)[str_len(str3)] = '\0';
d408 1
a408 1
    if (LONG_MAX/len <  str_len(str)) {
d412 1
a412 1
    str2 = rb_str_new(0, str_len(str)*len);
d414 2
a415 2
	memcpy(str_ptr(str2)+(i*str_len(str)),
	       str_ptr(str), str_len(str));
d417 1
a417 1
    str_ptr(str2)[str_len(str2)] = '\0';
a444 13
static char*
str_nth(enc, p, e, idx)
    m17n_encoding *enc;
    char *p, *e;
    int idx;
{
    p = m17n_nth(enc, p, e, idx);
    if (p == (char*)-1) {
	rb_raise(rb_eArgError, "invalid mbstring sequence");
    }
    return p;
}

a449 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
a450 2
    char *p, *pend = str_end(str);
    int slen = str_strlen(str, enc);
d453 2
a454 2
    if (beg > slen) return Qnil;
    if (beg == slen && len > 0) return Qnil;
d456 1
a456 1
	beg += slen;
d459 2
a460 2
    if (beg + len > slen) {
	len = slen - beg;
d466 2
a467 3
    p = str_nth(enc, str_ptr(str), pend, beg);
    pend = str_nth(enc, p, pend, len);
    str2 = rb_str_new(p, pend - p);
d493 3
a495 3
    ptr = ALLOC_N(char, str_len(str)+1);
    if (str_ptr(str)) {
	memcpy(ptr, str_ptr(str), str_len(str));
d497 2
a498 2
    ptr[str_len(str)] = 0;
    str_ptr(str) = ptr;
d530 2
a531 2
	if (str_len(str) < len || str_len(str) - len > 1024) {
	    REALLOC_N(str_ptr(str), char, len + 1);
d533 2
a534 2
	str_len(str) = len;
	str_ptr(str)[len] = '\0';	/* sentinel */
d549 3
a551 3
	if (str_ptr(str) <= ptr &&
	    ptr < str_ptr(str) + str_len(str)) {
	    poffset = ptr - str_ptr(str);
d553 1
a553 1
	REALLOC_N(str_ptr(str), char, str_len(str) + len + 1);
d555 2
a556 2
	    if (poffset >= 0) ptr = str_ptr(str) + poffset;
	    memcpy(str_ptr(str) + str_len(str), ptr, len);
d558 2
a559 2
	str_len(str) += len;
	str_ptr(str)[str_len(str)] = '\0'; /* sentinel */
a575 2
    m17n_encoding *enc;

d577 1
a577 2
    rb_m17n_enc_check(str1, str2, &enc);
    str1 = rb_str_cat(str1, str_ptr(str2), str_len(str2));
d603 2
a604 3
    m17n_encoding *enc = rb_m17n_get_encoding(str);
    register long len = str_len(str);
    register char *p = str_ptr(str);
d632 1
a632 1
	    key = key*65599 + m17n_toupper(enc, *p);
d663 1
d669 1
a669 1
    retval = str_memcmp(str_ptr(str1), str_ptr(str2), len, enc);
d671 2
a672 2
	if (str_len(str1) == str_len(str2)) return 0;
	if (str_len(str1) > str_len(str2)) return 1;
a683 1
    m17n_encoding *enc;
d687 2
a688 3
    enc = rb_m17n_get_encoding(str1);
    if (enc != rb_m17n_get_encoding(str2)) return Qfalse;
    if (str_len(str1) == str_len(str2) && rb_str_cmp(str1, str2) == 0) {
a742 1
    m17n_encoding *enc;
a743 1
    rb_m17n_enc_check(str, sub, &enc);
d745 1
a745 1
	offset += str_len(str);
d748 4
a751 4
    if (str_len(str) - offset < str_len(sub)) return -1;
    s = str_ptr(str)+offset;
    p = str_ptr(sub);
    len = str_len(sub);
d753 1
a753 1
    e = str_ptr(str) + str_len(str) - len + 1;
d755 2
a756 2
	if (str_memcmp(s, p, len, enc) == 0) {
	    return (s-(str_ptr(str)));
d780 1
a780 1
	pos += str_len(str);
d797 2
a798 2
	  long len = str_len(str);
	  char *p = str_ptr(str);
a824 1
    m17n_encoding *enc;
d829 1
a829 1
	    pos += str_len(str);
d832 1
a832 1
	if (pos > str_len(str)) pos = str_len(str);
d835 1
a835 1
	pos = str_len(str);
a839 1
	rb_m17n_enc_check(str, sub, &enc);
d848 9
a856 9
	rb_m17n_enc_check(str, sub, &enc);
	len = str_len(sub);
	if (str_len(str) < len) return Qnil;
	if (str_len(str) - pos < len) {
	    pos = str_len(str) - len;
	}
	sbeg = str_ptr(str);
	s = str_ptr(str) + pos;
	t = str_ptr(sub);
d859 2
a860 2
		if (str_memcmp(s, t, len, enc) == 0) {
		    return INT2NUM(s - str_ptr(str));
d873 2
a874 3
	  char *p = str_ptr(str) + pos;
	  char *pbeg = str_ptr(str);
	  /* get encoding */
d877 1
a877 1
	      if (*p == c) return INT2NUM(p - str_ptr(str));
a918 1
    m17n_encoding *enc = rb_m17n_get_encoding(orig);
d924 1
a924 1
    str = rb_str_new(str_ptr(orig), str_len(orig));
d926 1
a926 1
    if (str_len(str) == 0) return str;
d928 1
a928 1
    sbeg = str_ptr(str); s = sbeg + str_len(str) - 1;
d931 1
a931 1
	if (m17n_isalnum(enc, *s)) {
d938 1
a938 1
	sbeg = str_ptr(str); s = sbeg + str_len(str) - 1;
d946 3
a948 3
	REALLOC_N(str_ptr(str), char, str_len(str) + 1);
	s = str_ptr(str) + n;
	memmove(s+1, s, str_len(str) - n);
d950 2
a951 2
	str_len(str) += 1;
	str_ptr(str)[str_len(str)] = '\0';
d983 1
a983 1
	if (str_len(current) > str_len(end))
d1002 1
a1002 2
    long idx, len;
    m17n_encoding *enc;
a1008 2
	enc = rb_m17n_get_encoding(str);
	len = str_strlen(str, enc);
d1010 1
a1010 1
	    idx = len + idx;
d1012 1
a1012 1
	if (idx < 0 || len <= idx) {
d1015 1
a1015 3
	idx = m17n_codepoint(enc, str_nth(enc, str_ptr(str), str_end(str), idx),
			     str_end(str));
	return INT2FIX(idx);
d1029 2
a1030 5
	    long beg;

	    enc = rb_m17n_get_encoding(str);
	    len = str_strlen(str, enc);
	    switch (rb_range_beg_len(indx, &beg, &len, len, 0)) {
d1066 2
a1067 2
    if (str_len(str) < beg + len) {
	len = str_len(str) - beg;
d1070 1
a1070 1
    if (len < str_len(val)) {
d1072 1
a1072 1
	REALLOC_N(str_ptr(str), char, str_len(str)+str_len(val)-len+1);
d1075 4
a1078 4
    if (str_len(val) != len) {
	memmove(str_ptr(str) + beg + str_len(val),
		str_ptr(str) + beg + len,
		str_len(str) - (beg + len));
d1080 2
a1081 2
    if (str_len(str) < beg && len < 0) {
	MEMZERO(str_ptr(str) + str_len(str), char, -len);
d1083 2
a1084 2
    if (str_len(val) > 0) {
	memmove(str_ptr(str)+beg, str_ptr(val), str_len(val));
d1086 2
a1087 2
    RSTRING(str)->len += str_len(val) - len;
    str_ptr(str)[str_len(str)] = '\0';
d1097 1
a1097 2
    m17n_encoding *enc;
    long idx, beg, len;
a1098 1
    rb_str_modify(str);
a1101 1
        enc = rb_m17n_get_encoding(str);
a1102 1

d1104 1
a1104 1
	    idx += str_strlen(str, enc);
d1106 1
a1106 2
	if (idx < 0) {
	  bad_idx:
a1108 1

d1110 1
d1157 1
a1157 1
	    rb_str_replace(str, beg, str_len(indx), val);
d1164 2
a1165 1
	    if (rb_range_beg_len(indx, &beg, &len, str_len(str), 2)) {
d1191 1
a1191 1
	    beg += str_len(str);
d1193 1
a1193 1
	if (beg < 0 || str_len(str) < beg) {
d1195 1
a1195 1
		beg -= str_len(str);
d1199 2
a1200 2
	if (beg + len > str_len(str)) {
	    len = str_len(str) - beg;
d1291 13
a1303 12
	if (str_len(repl) > plen) {
	    REALLOC_N(str_ptr(str), char,
		      str_len(str) + str_len(repl) - plen + 1);
	}
	if (str_len(repl) != plen) {
	    memmove(str_ptr(str) + BEG(0) + str_len(repl),
		    str_ptr(str) + BEG(0) + plen,
		    str_len(str) - BEG(0) - plen);
	}
	memcpy(str_ptr(str) + BEG(0), str_ptr(repl), str_len(repl));
	RSTRING(str)->len += str_len(repl) - plen;
	str_ptr(str)[str_len(str)] = '\0';
a1328 1
    m17n_encoding *enc;
a1348 1
    rb_m17n_enc_check(pat, str, &enc);
d1356 1
a1356 1
    blen = str_len(str) + 30; /* len + margin */
d1359 1
a1359 1
    cp = str_ptr(str);
d1374 1
a1374 1
	len = (bp - buf) + (beg - offset) + str_len(val) + 3;
d1384 1
a1384 1
	memcpy(bp, str_ptr(val), str_len(val));
d1391 3
a1393 3
	    len = mbclen(str_ptr(str)[END(0)]);
	    if (str_len(str) > END(0)) {
		memcpy(bp, str_ptr(str)+END(0), len);
d1401 2
a1402 2
	cp = str_ptr(str) + offset;
	if (offset > str_len(str)) break;
d1405 1
a1405 1
    if (str_len(str) > offset) {
d1407 2
a1408 2
	if (blen - len < str_len(str) - offset + 1) {
	    REALLOC_N(buf, char, len + str_len(str) - offset + 1);
d1411 2
a1412 2
	memcpy(bp, cp, str_len(str) - offset);
	bp += str_len(str) - offset;
d1417 1
a1417 1
	    free(str_ptr(str));
a1423 1
	rb_m17n_associate_encoding((VALUE)dup, rb_m17n_get_encoding(str));
d1427 3
a1429 3
    str_ptr(str) = buf;
    str_len(str) = len = bp - buf;
    str_ptr(str)[len] = '\0';
d1462 1
a1462 1
	    free(str_ptr(str));
d1464 2
a1465 2
	RSTRING(str)->len = str_len(str2);
	RSTRING(str)->ptr = str_ptr(str2);
d1470 2
a1471 2
	rb_str_resize(str, str_len(str2));
	memcpy(str_ptr(str), str_ptr(str2), str_len(str2));
a1473 1
    rb_str_copy_encoding(str, str2);
d1586 2
a1587 2
	long len = str_len(str);
	char *p = str_ptr(str);
d1615 1
a1615 1
    double f = strtod(str_ptr(str), 0);
d1631 1
a1631 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
d1633 1
d1637 1
a1637 1
    p = str_ptr(str); pend = p + str_len(str);
d1649 1
a1649 1
	else if (m17n_isprint(enc, c)) {
a1695 1
    m17n_encoding *enc = m17n_index_to_encoding(0);
d1702 1
a1702 1
    p = str_ptr(str); pend = p + str_len(str);
d1714 1
a1714 1
	    if (m17n_isprint(enc, c)) {
d1725 2
a1726 2
    p = str_ptr(str); pend = p + str_len(str);
    q = str_ptr(result); qend = q + len;
d1740 1
a1740 1
	else if (m17n_isprint(enc, c)) {
a1786 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
d1791 1
a1791 1
    s = str_ptr(str); send = s + str_len(str);
d1793 5
a1797 5
	int c = m17n_codepoint(enc, s, send);

	if (m17n_islower(enc, c)) {
	    /* assuming toupper returns codepoint with same size */
	    m17n_mbcput(enc, m17n_toupper(enc, c), s);
d1800 1
a1800 1
	s += m17n_codelen(enc, c);
a1819 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
d1824 1
a1824 1
    s = str_ptr(str); send = s + str_len(str);
d1826 5
a1830 5
	int c = m17n_codepoint(enc, s, send);

	if (m17n_isupper(enc, c)) {
	    /* assuming tolower returns codepoint with same size */
	    m17n_mbcput(enc, m17n_tolower(enc, c), s);
d1833 1
a1833 1
	s += m17n_codelen(enc, c);
a1852 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
a1853 1
    int c;
d1857 3
a1859 5
    s = str_ptr(str); send = s + str_len(str);
    c = m17n_codepoint(enc, s, send);
    if (m17n_islower(enc, c)) {
	/* assuming toupper returns codepoint with same size */
	m17n_mbcput(enc, m17n_toupper(enc, c), s);
a1860 1
	s += m17n_codelen(enc, c);
d1862 6
a1867 6
    while (s < send) {
	c = m17n_codepoint(enc, s, send);

	if (m17n_isupper(enc, c)) {
	    /* assuming tolower returns codepoint with same size */
	    m17n_mbcput(enc, m17n_tolower(enc, c), s);
a1869 1
	s += m17n_codelen(enc, c);
a1887 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
d1892 1
a1892 1
    s = str_ptr(str); send = s + str_len(str);
d1894 5
a1898 5
	int c = m17n_codepoint(enc, s, send);

	if (m17n_isupper(enc, c)) {
	    /* assuming tolower returns codepoint with same size */
	    m17n_mbcput(enc, m17n_tolower(enc, c), s);
d1901 2
a1902 3
	else if (m17n_islower(enc, c)) {
	    /* assuming toupper returns codepoint with same size */
	    m17n_mbcput(enc, m17n_toupper(enc, c), s);
d1905 1
a1905 1
	s += m17n_codelen(enc, c);
d1929 1
a1929 1
trnext(t, enc)
a1930 1
    m17n_encoding *enc;
d1935 1
a1935 2
	    t->now = m17n_codepoint(enc, t->p, t->pend);
	    t->p += m17n_codelen(enc, t->now);
d1939 4
a1942 3
		    int c = m17n_codepoint(enc, t->p, t->pend);
		    t->p += m17n_codelen(enc, c);
		    if (t->now > c) continue;
d1944 1
a1944 1
		    t->max = c;
a1965 1
    m17n_encoding *enc;
d1968 2
a1969 1
    int c, last, modify = 0;
d1971 1
a1971 2
    VALUE hash;
    
d1974 2
a1975 2
    trsrc.p = str_ptr(src); trsrc.pend = trsrc.p + str_len(src);
    if (str_len(src) >= 2 && str_ptr(src)[0] == '^') {
d1980 1
a1980 1
    if (str_len(repl) == 0) {
d1983 2
a1984 4
    rb_m17n_enc_check(str, src, &enc);
    rb_m17n_enc_check(str, repl, &enc);
    trrepl.p = str_ptr(repl);
    trrepl.pend = trrepl.p + str_len(repl);
a1987 1
    hash = rb_hash_new();
d1990 2
a1991 2
	while ((c = trnext(&trsrc, enc)) >= 0) {
	    rb_hash_aset(hash, INT2NUM(c), Qtrue);
d1993 4
a1996 1
	while ((c = trnext(&trrepl, enc)) >= 0)
d1998 5
a2002 1
	last = trrepl.now;
d2007 5
a2011 2
	while ((c = trnext(&trsrc, enc)) >= 0) {
	    r = trnext(&trrepl, enc);
d2013 1
a2013 1
	    rb_hash_aset(hash, INT2NUM(c), INT2NUM(r));
d2017 1
a2017 1
    s = str_ptr(str); send = s + str_len(str);
d2019 2
a2020 4
	int clen, tlen, max = str_len(str);
	int offset, save = -1;
	char *buf = ALLOC_N(char, max), *t = buf;
	VALUE v;
a2021 1
	if (cflag) tlen = m17n_codelen(enc, last);
d2023 5
a2027 16
	    c = m17n_codepoint(enc, s, send);
	    tlen = clen = m17n_codelen(enc, c);

	    s += clen;
	    v = rb_hash_aref(hash, INT2NUM(c));
	    if (!NIL_P(v)) {
		if (!cflag) {
		    c = NUM2INT(v);
		    if (save == c) continue;
		    save = c;
		    tlen = m17n_codelen(enc, c);
		    modify = 1;
		}
	    }
	    else if (cflag) {
		save = c = last;
d2031 2
a2032 1
		save = -1;
d2034 5
a2038 28
	    while (t - buf + tlen >= max) {
		offset = t - buf;
		max *= 2;
		REALLOC_N(buf, char, max);
		t = buf + offset;
	    }
	    m17n_mbcput(enc, c, t);
	    t += tlen;
	}
	free(str_ptr(str));
	str_ptr(str) = buf;
	str_len(str) = t - buf;
	str_ptr(str)[str_len(str)] = '\0';
    }
    else if (m17n_mbmaxlen(enc) == 1) {
	while (s < send) {
	    VALUE v = rb_hash_aref(hash, INT2FIX(*s));
	    if (!NIL_P(v)) {
		if (cflag) {
		    *s = last;
		}
		else {
		    c = FIX2INT(v);
		    *s = c & 0xff;
		}
		modify = 1;
	    }
	    s++;
a2041 6
	int clen, tlen, max = str_len(str) * 1.2;
	int offset;
	char *buf = ALLOC_N(char, max), *t = buf;
	VALUE v;

	if (cflag) tlen = m17n_codelen(enc, last);
d2043 2
a2044 13
	    c = m17n_codepoint(enc, s, send);
	    tlen = clen = m17n_codelen(enc, c);

	    v = rb_hash_aref(hash, INT2NUM(c));
	    if (!NIL_P(v)) {
		if (!cflag) {
		    c = NUM2INT(v);
		    tlen = m17n_codelen(enc, c);
		    modify = 1;
		}
	    }
	    else if (cflag) {
		c = last;
d2047 1
a2047 9
	    while (t - buf + tlen >= max) {
		offset = t - buf;
		max *= 2;
		REALLOC_N(buf, char, max);
		t = buf + offset;
	    }
	    if (s != t) m17n_mbcput(enc, c, t);
	    s += clen;
	    t += tlen;
a2048 4
	free(str_ptr(str));
	str_ptr(str) = buf;
	str_len(str) = t - buf;
	str_ptr(str)[str_len(str)] = '\0';
a2049 1
    rb_gc_force_recycle(hash);
d2072 1
a2072 1
tr_setup_table(str, tablep, ctablep, enc)
d2074 2
a2075 3
    VALUE *tablep;
    VALUE *ctablep;
    m17n_encoding *enc;
d2077 1
d2079 2
a2080 2
    int c;
    VALUE table;
d2082 1
a2082 1
    tr.p = str_ptr(str); tr.pend = tr.p + str_len(str);
d2084 2
a2085 1
    if (str_len(str) > 1 && str_ptr(str)[0] == '^') {
d2095 13
a2107 2
    while ((c = trnext(&tr, enc)) >= 0) {
	rb_hash_aset(table, INT2NUM(c), Qtrue);
a2116 1
    m17n_encoding *enc;
d2118 1
a2118 1
    VALUE del = 0, nodel = 0;
d2120 1
d2128 2
a2129 2
	rb_m17n_enc_check(str, s, &enc);
	tr_setup_table(s, &del, &nodel, enc);
d2133 2
a2134 2
    s = t = str_ptr(str);
    send = str_end(str);
d2136 1
a2136 6
	int c = m17n_codepoint(enc, s, send);
	int clen = m17n_codelen(enc, c);
	VALUE v = INT2NUM(c);

	if ((del && !NIL_P(rb_hash_aref(del, v))) &&
	    (!nodel || NIL_P(rb_hash_aref(nodel, v)))) {
d2138 3
a2140 6
	}
	else {
	    if (t != s) m17n_mbcput(enc, c, t);
	    t += clen;
	}
	s += clen;
d2143 1
a2143 1
    str_len(str) = t - str_ptr(str);
d2166 1
a2166 2
    m17n_encoding *enc;
    VALUE del = 0, nodel = 0;
d2168 2
a2169 1
    int save, modify = 0;
d2173 3
a2175 1
	enc = rb_m17n_get_encoding(str);
d2183 2
a2184 2
	    rb_m17n_enc_check(str, s, &enc);
	    tr_setup_table(s, &del, &nodel, enc);
d2189 3
a2191 2
    s = t = str_ptr(str);
    send = str_end(str);
d2194 3
a2196 9
	int c = m17n_codepoint(enc, s, send);
	int clen = m17n_codelen(enc, c);
	VALUE v = INT2NUM(c);

	if (c != save && del && !NIL_P(rb_hash_aref(del, v)) &&
	    (!nodel || NIL_P(rb_hash_aref(nodel, v)))) {
	    save = c;
	    if (t != s) m17n_mbcput(enc, c, t);
	    t += clen;
a2197 1
	s += clen;
d2200 2
a2201 2
    if (t - str_ptr(str) != str_len(str)) {
	str_len(str) = t - str_ptr(str);
d2242 1
a2242 2
    m17n_encoding *enc;
    VALUE del = 0, nodel = 0;
d2244 1
d2255 2
a2256 2
	rb_m17n_enc_check(str, s, &enc);
	tr_setup_table(s, &del, &nodel, enc);
d2259 2
a2260 2
    s = str_ptr(str);
    send = s + str_len(str);
d2263 1
a2263 6
	int c = m17n_codepoint(enc, s, send);
	int clen = m17n_codelen(enc, c);
	VALUE v = INT2NUM(c);

	if ((del && !NIL_P(rb_hash_aref(del, v))) &&
	    (!nodel || NIL_P(rb_hash_aref(nodel, v)))) {
a2265 1
	s += clen;
a2275 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
d2301 2
a2302 2
	    if (str_len(spat) == 1) {
		char_sep = (unsigned char)str_ptr(spat)[0];
d2318 2
a2319 2
	char *ptr = str_ptr(str);
	long len = str_len(str);
a2320 1
	int c;
a2321 1
	end = beg = 0;
d2329 1
a2329 1
		    if (m17n_isspace(enc,c)) {
d2338 1
a2338 1
		    if (m17n_isspace(enc, c)) {
a2347 1
		ptr += m17n_codelen(enc, c);
d2351 2
a2352 3
	    while (ptr < eptr) {
		c = m17n_codepoint(enc, ptr, eptr);
		if (c == (char)char_sep) {
d2358 1
a2358 1
		ptr += m17n_codelen(enc, c);
d2372 1
a2372 3
		    tmp = rb_str_new(str_ptr(str)+beg, mbclen(str_ptr(str)[beg]));
		    rb_str_copy_encoding(tmp, str);
		    rb_ary_push(result, tmp);
d2376 1
a2376 1
		    start += mbclen(str_ptr(str)[start]);
d2382 1
a2382 3
		tmp = rb_str_new(str_ptr(str)+beg, end-beg);
		rb_str_copy_encoding(tmp, str);
		rb_ary_push(result, tmp);
d2392 1
a2392 2
		    tmp = rb_reg_nth_match(idx, rb_backref_get());
		rb_str_copy_encoding(tmp, str);
d2398 2
a2399 2
    if (!NIL_P(limit) || str_len(str) > beg || lim < 0) {
	if (str_len(str) == beg)
d2402 1
a2402 2
	    tmp = rb_str_new(str_ptr(str)+beg, str_len(str)-beg);
	rb_str_copy_encoding(tmp, str);
d2407 1
a2407 1
	       str_len(RARRAY(result)->ptr[RARRAY(result)->len-1]) == 0)
d2443 1
a2443 1
    char *p = str_ptr(str), *pend = p + str_len(str), *s;
d2445 1
a2445 1
    long len = str_len(str);
d2460 1
a2460 1
    rslen = str_len(rs);
d2465 1
a2465 1
	newline = str_ptr(rs)[rslen-1];
d2475 1
a2475 1
	     memcmp(str_ptr(rs), p-rslen, rslen) == 0)) {
d2478 1
a2478 1
	    if (str_ptr(str) != ptr || str_len(str) != len)
d2500 2
a2501 2
    for (i=0; i<str_len(str); i++) {
	rb_yield(INT2FIX(str_ptr(str)[i] & 0xff));
d2510 1
a2510 1
    if (str_len(str) > 0) {
d2512 5
a2516 5
	str_len(str)--;
	if (str_ptr(str)[str_len(str)] == '\n') {
	    if (str_len(str) > 0 &&
		str_ptr(str)[str_len(str)-1] == '\r') {
		str_len(str)--;
d2519 1
a2519 1
	str_ptr(str)[str_len(str)] = '\0';
d2546 1
a2546 1
    if (str_len(str) > 0) {
d2563 2
a2564 2
    char *p = str_ptr(str);
    long len = str_len(str);
d2572 1
a2572 1
    rslen = str_len(rs);
d2577 1
a2577 1
	if (len < str_len(str)) {
d2579 2
a2580 2
	    str_len(str) = len;
	    str_ptr(str)[len] = '\0';
d2586 1
a2586 1
    newline = str_ptr(rs)[rslen-1];
d2590 1
a2590 1
	 memcmp(str_ptr(rs), p+len-rslen, rslen) == 0)) {
d2592 2
a2593 2
	str_len(str) -= rslen;
	str_ptr(str)[str_len(str)] = '\0';
a2635 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
d2639 2
a2640 2
    s = str_ptr(str);
    e = t = s + str_len(str);
d2642 1
a2642 1
    while (s < t && m17n_isspace(enc,*s)) s++;
d2646 1
a2646 1
    while (s <= t && m17n_isspace(enc,*t)) t--;
d2649 7
a2655 7
    str_len(str) = t-s;
    if (s > str_ptr(str)) { 
	char *p = str_ptr(str);

	str_ptr(str) = ALLOC_N(char, str_len(str)+1);
	memcpy(str_ptr(str), s, str_len(str));
	str_ptr(str)[str_len(str)] = '\0';
d2659 1
a2659 1
	str_ptr(str)[str_len(str)] = '\0';
a2681 1
    m17n_encoding *enc;
a2685 1
    rb_m17n_enc_check(pat, str, &enc);
d2693 1
a2693 1
	    *start = END(0)+mbclen(str_ptr(str)[END(0)]);
d2761 2
a2762 2
    if (str_len(str) > 2 && str_ptr(str)[0] == '0') {
	switch (str_ptr(str)[1]) {
d2783 1
a2783 1
    if (str_len(salt) < 2)
d2785 1
a2785 1
    return rb_str_new2(crypt(str_ptr(str), str_ptr(salt)));
d2794 1
a2794 1
    if (strlen(str_ptr(str)) != str_len(str))
d2796 1
a2796 1
    id = rb_intern(str_ptr(str));
d2815 1
a2815 1
    p = str_ptr(str); pend = p + str_len(str);
d2855 1
a2855 1
    if (width < 0 || str_len(str) >= width) return str;
d2857 2
a2858 2
    memcpy(str_ptr(res), str_ptr(str), str_len(str));
    p = str_end(res); pend = str_ptr(res) + width;
d2874 1
a2874 1
    if (width < 0 || str_len(str) >= width) return str;
d2876 1
a2876 1
    p = str_ptr(res); pend = p + width - str_len(str);
d2880 1
a2880 1
    memcpy(pend, str_ptr(str), str_len(str));
d2894 1
a2894 1
    if (width < 0 || str_len(str) >= width) return str;
d2896 2
a2897 2
    n = (width - str_len(str))/2;
    p = str_ptr(res); pend = p + n;
d2901 2
a2902 2
    memcpy(pend, str_ptr(str), str_len(str));
    p = pend + str_len(str); pend = str_ptr(res) + width;
d2928 1
a2928 1
    rb_define_method(rb_cString, "initialize", rb_str_initialize, 1);
d2942 1
a2942 1
    rb_define_method(rb_cString, "size", rb_str_size, 0);
a3035 3

    rb_define_method(rb_cString, "encoding", rb_enc_get_encoding, 0);
    rb_define_method(rb_cString, "encoding=", rb_enc_set_encoding, 1);
@


1.52.2.3
log
@tested a bit; utf-8 bugs removed
@
text
@d6 1
a6 1
  $Date: 2001/01/12 04:36:00 $
d143 3
a145 3
void
rb_m17n_copy_encoding(obj1, obj2)
    VALUE obj1, obj2;
d147 1
a147 1
    rb_m17n_associate_encoding(obj1, rb_m17n_get_encoding(obj2));
d283 1
a283 1
    rb_m17n_copy_encoding(str, str2);
a514 29
static int
str_sublen(str, len, enc)
    VALUE str;
    int len;
    m17n_encoding *enc;
{
    if (m17n_mbmaxlen(enc) == 1) return len;
    else {
	char *p = str_ptr(str);
	char *e = p + len;
	int i;

	i = 0;
	while (p < e) {
	    p += mbclen(*p);
	    i++;
	}
	return i;
    }
}
    
int
rb_str_sublen(str, len)
    VALUE str;
    int len;
{
    return str_sublen(str, len, rb_m17n_get_encoding(str));
}

a800 1
	start = rb_str_sublen(x, start);
d826 1
a826 1
	offset += str_strlen(str, enc);
d829 2
a830 3
    if (str_strlen(str, enc) - offset < str_strlen(sub, enc))
	return -1;
    s = str_nth(enc, str_ptr(str), str_end(str), offset);
d837 1
a837 1
	    return offset;
d839 1
a839 2
	offset++;
	s += m17n_mbclen(enc, *s);
a868 1
	pos = rb_str_sublen(str, pos);
d904 2
a905 2
    int pos, len, len2;
    char *s, *sbeg, *e, *t;
a925 1
	    pos = str_sublen(str, pos, enc);
d932 4
a935 8
	len = str_strlen(sub);
	len2 = str_strlen(str);
	if (len > len2) return Qnil;
	if (len2 - pos < len) {
	    pos = len2 - len;
	}
	if (len == 0) {
	    return INT2NUM(pos);
d938 1
a938 1
	e = str_end(str);
d940 6
a945 4
	do {
	    s = str_nth(enc, sbeg, e, pos);
	    if (str_memcmp(s, t, len, enc) == 0) {
		return INT2NUM(pos);
d947 4
a950 2
	    pos--;
	} while (sbeg <= s);
d1005 1
a1005 1
    char *sbeg, *s, *e;
a1013 1
    e = str_end(str);
d1016 1
a1016 2
	int c = m17n_codepoint(enc, s, e);
	if (m17n_isalnum(enc, c)) {
d1281 1
a1281 2
	m17n_encoding *enc;
	long beg, len, slen, b, l;
a1286 1
	slen = str_strlen(str);
d1288 1
a1288 1
	    beg += slen;
d1290 1
a1290 1
	if (beg < 0 || slen < beg) {
d1292 1
a1292 1
		beg -= slen;
d1296 2
a1297 2
	if (beg + len > slen) {
	    len = slen - beg;
d1299 1
a1299 4
	rb_m17n_enc_check(str, argv[2], &enc);
	b = str_nth(enc, str_ptr(str), str_end(str), beg) - str_ptr(str);
	l = str_nth(enc, str_ptr(str), str_end(str), beg+len) - str_ptr(str) - b;
	rb_str_replace(str, b, l, argv[2]);
d1573 1
a1573 1
    rb_m17n_copy_encoding(str, str2);
d1663 1
a1663 1
    rb_m17n_copy_encoding(obj, str);
d2362 3
a2364 3
	if (c != save &&
	    ((del && NIL_P(rb_hash_aref(del, v))) ||
	     (!nodel || NIL_P(rb_hash_aref(nodel, v))))) {
a2365 1
	    save = c;
d2479 2
a2480 3
	    if (str_strlen(spat, enc) == 1) {
		rb_m17n_enc_check(str, spat, &enc);
		char_sep = m17n_codepoint(enc, str_ptr(spat), str_end(spat));
a2549 1
	rb_m17n_enc_check(str, spat, &enc);
d2555 1
a2555 1
		    rb_m17n_copy_encoding(tmp, str);
d2567 1
a2567 1
		rb_m17n_copy_encoding(tmp, str);
d2579 1
a2579 1
		rb_m17n_copy_encoding(tmp, str);
a2583 1
	beg = str_sublen(str, beg, enc);
d2586 1
a2586 1
	if (str_strlen(str, enc) == beg)
d2588 3
a2590 5
	else {
	    char *p = str_nth(enc, str_ptr(str), str_end(str), beg);
	    tmp = rb_str_new(p, str_end(str)-p);
	}
	rb_m17n_copy_encoding(tmp, str);
@


1.52.2.4
log
@several minor fixes.
@
text
@d6 1
a6 1
  $Date: 2001/03/05 03:37:34 $
d90 1
a90 1
    return m17n_casecmp(p1, p2, len, enc);
d105 1
a105 1
	if (enc) *enc = enc2;
d108 1
a108 1
	if (enc) *enc = enc1;
d114 1
a114 1
	if (enc) *enc = enc1;
a239 1
	rb_m17n_copy_encoding(str, orig);
d250 1
a252 1
	rb_m17n_copy_encoding((VALUE)str, orig);
d419 1
a419 1
rb_str_bufsize(str)
a439 1
    rb_m17n_enc_check(str1, str2, 0);
d521 1
a521 1
    if (m17n_mbmaxlen(enc) == 1 || len < 0) return len;
d529 1
a529 1
	    p += m17n_mbcspan(enc, p, e);
d709 1
d714 3
d718 16
a733 2
	key = key*65599 + *p;
	p++;
d736 15
a750 1

d871 1
a871 1
	s += m17n_mbcspan(enc, s, e);
d978 1
a978 1
	for (;;) {
a982 1
	    if (pos == 0) break;
d984 1
a984 1
	}
d1051 1
a1051 1
	unsigned int c = m17n_codepoint(enc, s, e);
d1324 1
a1324 2
	rb_m17n_enc_check(str, argv[2], &enc);
	slen = str_strlen(str, enc);
d1337 1
d1530 1
a1530 1
	    len = m17n_mbcspan(enc, str_ptr(str)+END(0), str_end(str));
d1775 1
a1775 1
    char s[8];
d1779 1
a1779 1
	char c = *p;
d1781 2
a1782 2
	    int len = m17n_mbcspan(enc, p, pend);
	    rb_str_cat(result, p, len);
a1824 1
	p++;
d2598 1
a2598 1
		    tmp = rb_str_new(str_ptr(str)+beg, m17n_mbcspan(enc, str_ptr(str)+beg, str_end(str)));
d2604 1
a2604 1
		    start += m17n_mbcspan(enc, str_ptr(str)+start, str_end(str));
a2741 19
rb_str_each_char(str)
    VALUE str;
{
    m17n_encoding *enc = rb_m17n_get_encoding(str);
    char *p, *pend;
    unsigned int c;

    p = RSTRING(str)->ptr;
    pend = p + str_len(str);

    while (p < pend) {
	c = m17n_codepoint(enc, p, pend);
	rb_yield(INT2FIX(c));
	p += m17n_codelen(enc, c);
    }
    return str;
}

static VALUE
d2931 1
a2931 1
	    *start = END(0)+m17n_mbcspan(enc, str_ptr(str)+END(0),str_end(str));
d3085 1
a3085 1
space_pad(str, pre, post, c, enc)
d3087 1
a3087 4
    int pre;
    int post;
    int c;
    m17n_encoding *enc;
d3089 1
a3089 1
    long width = m17n_swidth(enc, str_ptr(str), str_end(str));
d3091 1
a3091 1
    long offset = 0, capa, i, clen;
d3093 6
a3098 28
    if (width < 0) return str;	/* can't calculate column width */

    clen = m17n_codelen(enc, c);
    capa = str_len(str)+(pre+post)*clen;
    res = rb_str_new(0, capa);
    rb_m17n_copy_encoding(res, str);

    for (i=0; i<pre; i++) {
	if (offset + clen >= capa) {
	    capa *= 2;
	    rb_str_resize(res, capa);
	}
	m17n_mbcput(enc, c, str_ptr(res)+offset);
	offset += clen;
    }
    if (offset + str_len(str) > capa) {
	capa *= 2;
	rb_str_resize(res, capa);
    }
    memcpy(str_ptr(res)+offset, str_ptr(str), str_len(str));
    offset += str_len(str);
    for (i=0; i<post; i++) {
	if (offset + clen >= capa) {
	    capa *= 2;
	    rb_str_resize(res, capa);
	}
	m17n_mbcput(enc, c, str_ptr(res)+offset);
	offset += clen;
a3099 1
    rb_str_resize(res, offset);
a3103 14
rb_str_ljust(str, w)
    VALUE str;
    VALUE w;
{
    m17n_encoding *enc = rb_m17n_get_encoding(str);
    long width = NUM2LONG(w);

    if (width < 0) return str;
    width -= str_strlen(str, enc);
    if (width < 0) return str;
    return space_pad(str, 0, width, ' ', enc);
}

static VALUE
a3107 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
d3109 2
d3112 8
a3119 4
    if (width < 0) return str;
    width -= str_strlen(str, enc);
    if (width < 0) return str;
    return space_pad(str, width, 0, ' ', enc);
a3126 1
    m17n_encoding *enc = rb_m17n_get_encoding(str);
d3128 2
d3132 13
a3144 5
    if (width < 0) return str;
    width -= str_strlen(str, enc);
    if (width < 0) return str;
    n = width/2;
    return space_pad(str, n, width - n, ' ', enc);
d3166 1
a3166 1
    rb_define_method(rb_cString, "initialize", rb_str_initialize, -1);
d3180 1
a3180 2
    rb_define_method(rb_cString, "size", rb_str_length, 0);
    rb_define_method(rb_cString, "buffer_size", rb_str_bufsize, 0);
a3253 1
    rb_define_method(rb_cString, "each_char", rb_str_each_char, 0);
@


1.51
log
@matz
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/12/25 06:29:10 $
d1497 2
a1498 2
	    rb_str_cat(result, p, len);
	    p += len;
@


1.50
log
@001225
@
text
@d6 1
a6 1
  $Date: 2000/12/05 09:36:35 $
d1319 1
a1320 1
    rb_str_modify(str);
d1322 4
a1325 1
    if (RSTRING(str2)->orig && FL_TEST(str2, STR_NO_ORIG)) {
d1331 1
@


1.50.2.1
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/25 06:29:10 $
a1318 1
    if (str == str2) return str;
d1320 1
d1322 1
a1322 4
    if (RSTRING(str2)->orig && !FL_TEST(str2, STR_NO_ORIG)) {
	if (str_independent(str))
	  free(RSTRING(str)->ptr);

a1327 1
	rb_str_modify(str);
d1493 2
a1494 2
	    rb_str_cat(result, p - 1, len);
	    p += len - 1;
@


1.50.2.2
log
@* string.c (rb_str_reverse_bang): forgot to call rb_str_modify().
@
text
@d6 1
a6 1
  $Date: 2000/12/28 04:45:16 $
a1401 1
    rb_str_modify(str);
@


1.50.2.3
log
@* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2001/01/09 16:58:18 $
d370 1
a386 1
    RSTRING(str)->orig = 0;
a1280 3
	else {
	    RSTRING(str)->orig = 0;
	}
d1323 3
a1325 3
	if (str_independent(str)) {
	    free(RSTRING(str)->ptr);
	}
@


1.50.2.4
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_equal): all option flags should be same to be equal.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:39:51 $
d1655 1
a1655 1
	else if (ISLOWER(*s)) {
@


1.50.2.5
log
@* string.c (rb_str_substr): "a"[1,2] should return ""; need
  rubicon upgrade.
@
text
@d6 1
a6 1
  $Date: 2001/02/08 09:17:57 $
d342 1
@


1.50.2.6
log
@* string.c (rb_str_delete_bang): delete! should take at least 1
  argument.

* eval.c (ev_const_defined): check Object's constant if no current
  class is available (e.g. defining singleton class for Fixnums).

* eval.c (rb_yield_0): should check based on rb_block_given_p()
  and rb_f_block_given_p().
@
text
@d6 1
a6 1
  $Date: 2001/02/19 09:15:27 $
a1974 3
    if (argc < 1) {
	rb_raise(rb_eArgError, "wrong # of arguments");
    }
@


1.50.2.7
log
@* string.c (trnext): support backslash escape in String#tr.
@
text
@d6 1
a6 1
  $Date: 2001/02/28 06:31:21 $
d1794 1
a1794 4
	    if (t->p < t->pend - 1 && *t->p == '\\') {
		t->p++;
	    }
	    else if (t->p < t->pend - 1 && *t->p == '-') {
@


1.50.2.8
log
@* eval.c: remove TMP_PROTECT_END to prevent C_ALLOCA crash.

* eval.c (ev_const_defined): should ignore toplevel cbase (Object).

* eval.c (ev_const_get): ditto.

* ext/curses/curses.c: curses on Mac OS X public beta does not
  have _maxx etc.

* marshal.c (w_object): should truncate trailing zero short for
  bignums.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/03/04 09:46:08 $
d177 1
a177 1
static ID id_to_s;
d188 1
a188 1
    str = rb_funcall(obj, id_to_s, 0);
d1129 1
a1129 1
	repl = rb_str_to_str(argv[1]);;
d1202 1
a1202 1
	repl = rb_str_to_str(argv[1]);
d2893 1
a2893 1
    id_to_s = rb_intern("to_s");
@


1.50.2.9
log
@* string.c (rb_str_replace): add taint status infection
  (OBJ_INFECT()).

* string.c (rb_str_crypt): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/03/26 08:56:04 $
a970 1
    OBJ_INFECT(str, val);
a2636 1
    VALUE result;
d2641 1
a2641 4

    result = rb_str_new2(crypt(RSTRING(str)->ptr, RSTRING(salt)->ptr));
    OBJ_INFECT(result, str);
    return result;
a2717 1
    OBJ_INFECT(res, str);
a2736 1
    OBJ_INFECT(res, str);
a2761 1
    OBJ_INFECT(res, str);
@


1.50.2.10
log
@* eval.c (rb_f_require): move rb_file_s_expand_path from
  rb_find_file_noext().

* file.c (rb_find_file_noext): move rb_file_s_expand_path to
  rb_f_require().

* string.c (rb_str_each_line): should propagate taint mark.

* ext/nkf/nkf.c (rb_nkf_kconv): ditto.

* ruby.c (load_file): local variables 'c' remain uninitialized on
  xflag.

* regex.c (re_match): prefetched escaped character too early.

* eval.c (rb_call0): add argument check for attr_readers.
@
text
@d6 1
a6 1
  $Date: 2001/05/25 15:01:06 $
a2333 1
	    OBJ_INFECT(line, str);
@


1.50.2.11
log
@* eval.c: wrapper modifies updated to 1.7 changes.

* object.c (rb_obj_dup): should free generic_ivar if original owns
  them.
@
text
@d6 1
a6 1
  $Date: 2001/07/06 06:36:59 $
a218 2
    if (FL_TEST(str, FL_EXIVAR))
	rb_clone_generic_ivar(str2, str);
@


1.50.2.12
log
@* string.c (rb_str_cmp): remove needless conditional.

* array.c (rb_inspecting_p): initialize inspect_key if it is
  not initialized yet.
@
text
@d6 1
a6 1
  $Date: 2001/07/13 05:50:04 $
d560 1
@


1.50.2.13
log
@* array.c (rb_ary_equal): check identiry equality first.

* string.c (rb_str_equal): ditto.

* struct.c (rb_struct_equal): ditto.

* numeric.c (Init_Numeric): undef Integer::new.
@
text
@d6 1
a6 1
  $Date: 2001/08/14 08:11:00 $
a567 1
    if (str1 == str2) return Qtrue;
@


1.50.2.14
log
@* class.c (rb_include_module): should check whole ancestors to
  avoid duplicate module inclusion.

* string.c (trnext): should check backslash before updating "now"
  position.
@
text
@d6 1
a6 1
  $Date: 2001/08/24 06:36:14 $
d1796 1
d1800 1
a1800 2
	    t->now = *(USTR)t->p++;
	    if (t->p < t->pend - 1 && *t->p == '-') {
@


1.50.2.15
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* string.c (rb_str_reverse): should return an instance of
  reciever's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/09/06 07:47:46 $
d309 3
a311 2
    OBJ_INFECT(str2, str);
    RBASIC(str2)->klass = rb_obj_class(str);
a356 1
    RBASIC(str2)->klass = rb_obj_class(str);
a809 1
    RBASIC(str)->klass = rb_obj_class(orig);
a1290 1
	RBASIC(dup)->klass = rb_obj_class(str);
a1434 2
    OBJ_INFECT(obj, str);
    RBASIC(obj)->klass = rb_obj_class(str);
a2720 1
    RBASIC(res)->klass = rb_obj_class(str);
a2740 1
    RBASIC(res)->klass = rb_obj_class(str);
a2761 1
    RBASIC(res)->klass = rb_obj_class(str);
@


1.50.2.16
log
@* marshal.c: backport from 1.7 marshal.c
@
text
@d6 1
a6 1
  $Date: 2001/10/02 04:25:53 $
a989 4
	if (RSTRING(str)->len <= idx) {
	  out_of_range:
	    rb_raise(rb_eIndexError, "index %d out of string", idx);
	}
a990 2
	    if (-idx > RSTRING(str)->len)
		goto out_of_range;
d993 3
d1055 2
a1056 3
	if (RSTRING(str)->len < beg) {
	  out_of_range:
	    rb_raise(rb_eIndexError, "index %d out of string", beg);
d1058 3
a1060 3
	if (beg < 0) {
	    if (-beg > RSTRING(str)->len) {
		goto out_of_range;
d1062 1
a1062 1
	    beg += RSTRING(str)->len;
@


1.50.2.17
log
@* string.c (rb_str_index): wrong increment for non alphanumeric
  string.
@
text
@d6 1
a6 1
  $Date: 2001/10/05 06:27:46 $
d827 2
a828 2
           if ((*s += 1) != 0) break;
           s--;
@


1.50.2.18
log
@* dir.c (my_getcwd): do not rely on MAXPATHLEN.

* eval.c (rb_yield_0): should not call rb_f_block_given_p().
@
text
@d6 1
a6 1
  $Date: 2001/10/22 06:46:05 $
a213 2
	FL_UNSET(str2, FL_TAINT);
	OBJ_INFECT(str2, str);
@


1.50.2.19
log
@* parse.y (str_extend): term can be any character.
@
text
@d6 1
a6 1
  $Date: 2001/11/07 09:01:31 $
d834 1
a834 1
	REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len + 2);
@


1.50.2.20
log
@* parse.y (str_extend): should not terminate string interpolation
  with newlines in here-docs and newline terminated strings.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 14:36:40 $
d1502 1
d1504 1
@


1.50.2.21
log
@* time.c (time_new_internal): round usec overflow and underflow
  here.

* time.c (time_plus): remove overflow/underflow check.

* time.c (time_minus): ditto.

* time.c (time_cmp): should consider tv_usec too.

* time.c (time_gmtime): time_modify() should be called even if tm
  struct is not calculated yet.

* string.c (rb_str_equal): object with to_str must be treated as a
  string.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 16:16:13 $
a565 13
to_str(str)
    VALUE str;
{
    return rb_funcall(str, rb_intern("to_str"), 0);
}

static VALUE
str_or_nil(str)
    VALUE str;
{
    return rb_rescue(to_str, (VALUE)str, 0, 0);
}

d571 2
a572 4
    if (TYPE(str2) != T_STRING) {
	str2 = str_or_nil(str2);
	if (NIL_P(str2)) return Qfalse;
    }
@


1.50.2.22
log
@* string.c (to_str): should return VALUE.
@
text
@d6 1
a6 1
  $Date: 2001/12/03 10:06:39 $
a565 1
VALUE
d576 1
a576 1
    return rb_rescue(to_str, str, 0, 0);
@


1.50.2.23
log
@* io.c (io_fread): EAGAIN/EWOULDBLOCK should not terminate and
  throw away the input.

* time.c (time_new_internal): underflow adjustment must not use
  negative div/mod.

* time.c (time_cmp): should consider tv_usec on non Fixnum number
  comparison.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/12/03 14:05:28 $
d566 14
d586 1
a586 1
	str2 = rb_check_convert_type(str2, T_STRING, "String", "to_str");
@


1.50.2.24
log
@* string.c (rb_str_new2): NULL pointer check added.

* class.c (rb_define_module_under): should locate predefined
  module using rb_const_defined_at().
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/12/04 04:53:31 $
a56 3
    if (!ptr) {
	rb_raise(rb_eArgError, "NULL pointer given");
    }
@


1.50.2.25
log
@* class.c (rb_include_module): detect cyclic module inclusion.

* eval.c (rb_thread_schedule): should check time only if BOTH
  WAIT_SELECT and WAIT_TIME.

* string.c (rb_str_split_m): no need to consider KANJI
characters, if the length of separator is 1 (byte).
@
text
@d6 1
a6 1
  $Date: 2002/01/07 05:24:03 $
d2230 1
@


1.50.2.26
log
@* regex.c (re_compile_pattern): '\0111' should be '\011' plus '1',
  since octal literals are formed by three digits at most.

* eval.c (rb_eval_cmd): cbase should not be NULL; it should be
  either ruby_wrapper or Object.

* enum.c (enum_each_with_index): should return self.

* process.c (proc_setpgrp): should return value for non-void function.

* process.c (proc_getpgid): should raise exception if getpgid() return -1.

* string.c (rb_str_ljust): should return a duplicated string.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/01/25 08:23:31 $
d2731 1
a2731 1
    if (width < 0 || RSTRING(str)->len >= width) return rb_str_dup(str);
d2752 1
a2752 1
    if (width < 0 || RSTRING(str)->len >= width) return rb_str_dup(str);
d2774 1
a2774 1
    if (width < 0 || RSTRING(str)->len >= width) return rb_str_dup(str);
@


1.50.2.27
log
@* re.c (rb_reg_search): should clear last_match if pos is out of
  string range.

* string.c (rb_str_index_m): ditto.

* string.c (rb_str_rindex): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/12 09:27:26 $
d673 1
a673 6
	if (pos < 0) {
	    if (TYPE(sub) == T_REGEXP) {
		rb_backref_set(Qnil);
	    }
		return Qnil;
	}
d722 1
a722 6
	    if (pos < 0) {
		if (TYPE(sub) == T_REGEXP) {
		    rb_backref_set(Qnil);
		}
		return Qnil;
	    }
@


1.50.2.28
log
@* string.c (rb_str_aset): should raise error if an indexing string
  is not found in the receiver.

* sprintf.c (rb_f_sprintf): "%d" should convert objects into
  integers using Integer().
@
text
@d6 1
a6 1
  $Date: 2002/03/19 09:02:04 $
d1040 3
a1042 2
	if (beg < 0) {
	    rb_raise(rb_eIndexError, "string not matched");
a1043 2
	if (TYPE(val) != T_STRING) val = rb_str_to_str(val);
	rb_str_replace(str, beg, RSTRING(indx)->len, val);
@


1.50.2.29
log
@* string.c (rb_str_slice_bang): if there's no corresponding
  substring, slice! should return nil without exception.

* string.c (rb_str_split_m): accept separator value nil as well.

* class.c (include_class_new): module may be T_ICLASS; retrieve
  original module information.

* re.c (rb_reg_expr_str): need to process backslashes properly.

* parse.y (yylex): no here document after a dot.

* parse.y (yylex): should have set lex_state properly after '`'.

* parse.y (yylex): should have set lex_state properly after
  tOP_ASGN.

* bignum.c (rb_big2dbl): return canonical HUGE_VAL for infinity.
@
text
@d6 1
a6 1
  $Date: 2002/06/04 07:11:52 $
d1116 1
a1116 3
    if (!NIL_P(result)) {
	rb_str_aset_m(argc+1, buf, str);
    }
d1377 1
a1377 1
		 NIL_P(line) ? "nil" : rb_class2name(CLASS_OF(line)));
d2175 1
a2175 1
    if (NIL_P(spat)) {
a2671 1
    OBJ_INFECT(result, salt);
@


1.50.2.30
log
@* eval.c (ruby_run): should set toplevel visibility again here.

* eval.c (rb_eval): should not rely on ruby_class == rb_cObject
  check.   Besides allow implicit publicity for attribute set
  methods.

* parse.y (primary): need not to check class_nest, just set
  whether method is an attrset or not.

* string.c (rb_str_each_line): p might be at the top of the
  string.

* variable.c (rb_path2class): should not use rb_eval_string().

* parse.y (str_extend): expression substitution can contain string
  terminator again.

* parse.y (yylex): the warning message "invalid
  character syntax" was never issued.

* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/07/11 08:24:54 $
d2357 1
a2357 1
	if (RSTRING(str)->ptr < p && p[-1] == newline &&
@


1.50.2.31
log
@* array.c, class.c, eval.c, file.c, gc.c, node.h, numeric.c,
  object.c, parse.y, range.c, re.c, string.c, struct.c, util.c,
  ext/socket/socket.c: merge from 1.7: treat long values as long
  instead of int.
@
text
@d6 1
a6 1
  $Date: 2002/09/25 07:07:38 $
d1075 1
a1075 1
	if (len < 0) rb_raise(rb_eIndexError, "negative length %ld", len);
d1078 1
a1078 1
	    rb_raise(rb_eIndexError, "index %ld out of string", beg);
@


1.49
log
@matz
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/11/17 05:59:45 $
d100 7
a106 1
    if (OBJ_FROZEN(orig)) return orig;
d108 2
d111 1
a111 3
	    orig = rb_str_new(RSTRING(orig)->ptr, RSTRING(orig)->len);
	    OBJ_FREEZE(orig);
	    return orig;
d113 6
a118 2
	OBJ_FREEZE(RSTRING(orig)->orig);
	return RSTRING(orig)->orig;
d122 1
a122 1
	OBJSETUP(str, rb_cString, T_STRING);
d216 1
a216 8
	NEWOBJ(dup, struct RString);
	OBJSETUP(dup, klass, T_STRING);

	str2 = rb_str_new4(str);
	dup->len = RSTRING(str2)->len;
	dup->ptr = RSTRING(str2)->ptr;
	dup->orig = str2;
	str2 = (VALUE)dup;
d1321 11
a1331 2
    rb_str_resize(str, RSTRING(str2)->len);
    memcpy(RSTRING(str)->ptr, RSTRING(str2)->ptr, RSTRING(str2)->len);
a1332 1

@


1.48
log
@eban
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/10/10 07:03:24 $
d1471 1
a1471 2
#define STRMAX 80
    char buf[STRMAX];
d1473 3
a1475 2
    char *b;
    VALUE inspect;
a1477 11
    b = buf;
    *b++ = '"';

#define CHECK(n) {\
    if (b - buf + n > STRMAX - 4) {\
	strcpy(b, "...");\
	b += 3;\
        break;\
    }\
}

d1482 2
a1483 6

	    CHECK(len);
	    *b++ = c;
	    while (--len) {
		*b++ = *p++;
	    }
d1486 2
a1487 3
	    CHECK(2);
	    *b++ = '\\';
	    *b++ = c;
d1490 2
a1491 2
	    CHECK(1);
	    *b++ = c;
d1494 2
a1495 3
	    CHECK(2);
	    *b++ = '\\';
	    *b++ = 'n';
d1498 2
a1499 3
	    CHECK(2);
	    *b++ = '\\';
	    *b++ = 'r';
d1502 2
a1503 3
	    CHECK(2);
	    *b++ = '\\';
	    *b++ = 't';
d1506 2
a1507 3
	    CHECK(2);
	    *b++ = '\\';
	    *b++ = 'f';
d1510 2
a1511 3
	    CHECK(2);
	    *b++ = '\\';
	    *b++ = 'v';
d1514 2
a1515 3
	    CHECK(2);
	    *b++ = '\\';
	    *b++ = 'a';
d1518 2
a1519 3
	    CHECK(2);
	    *b++ = '\\';
	    *b++ = 'e';
d1522 2
a1523 4
	    CHECK(4);
	    *b++ = '\\';
	    sprintf(b, "%03o", c & 0377);
	    b += 3;
d1526 4
a1529 4
    *b++ = '"';
    inspect = rb_str_new(buf, b - buf);
    OBJ_INFECT(inspect, str);
    return inspect;
d1619 1
@


1.47
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/02 07:48:33 $
d832 1
a832 1
	
@


1.46
log
@matz
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/09/26 09:11:47 $
d1384 2
a1385 1
    char *s, *e, *p, *q;
d1389 4
a1392 4
    p = q = ALLOCA_N(char, RSTRING(str)->len);

    while (e >= s) {
	*p++ = *e--;
a1393 1
    MEMCPY(RSTRING(str)->ptr, q, char, RSTRING(str)->len);
@


1.45
log
@eban
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/09/07 06:59:36 $
d1800 1
a1800 1
	    if (t->p < t->pend && *t->p == '-') {
@


1.44
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/01 09:18:11 $
d21 1
@


1.43
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/25 08:26:03 $
d430 2
d433 4
d438 2
a439 1
	if (ptr)
d441 1
@


1.42
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/07 05:01:57 $
d2582 1
a2582 1
	rb_backref_set(match);
@


1.41
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/25 06:03:47 $
d2754 12
@


1.40
log
@matz - irb (PR#46)
@
text
@d6 1
a6 1
  $Date: 2000/07/24 07:19:32 $
d100 6
a105 1
    if (RSTRING(orig)->orig && !FL_TEST(orig, STR_NO_ORIG)) {
d357 13
d376 1
a376 5
    if (OBJ_FROZEN(str)) rb_error_frozen("string");
    if (!OBJ_TAINTED(str) && rb_safe_level() >= 4)
	rb_raise(rb_eSecurityError, "Insecure: can't modify string");
    if (!RSTRING(str)->orig || FL_TEST(str, STR_NO_ORIG)) return;
    if (TYPE(RSTRING(str)->orig) != T_STRING) abort();
a382 1
    RSTRING(str)->orig = 0;
d1266 3
a1268 2
	rb_str_modify(str);
	free(RSTRING(str)->ptr);
d1342 1
a1342 2
    VALUE str = uscore_get();
    VALUE dup = rb_str_dup(str);
d1344 1
a1344 1
    if (NIL_P(rb_str_sub_bang(argc, argv, dup)))
d1346 2
a1347 2
    rb_lastline_set(dup);
    return dup;
d1363 1
a1363 2
    VALUE str = uscore_get();
    VALUE dup = rb_str_dup(str);
d1365 1
a1365 1
    if (NIL_P(rb_str_gsub_bang(argc, argv, dup)))
d1367 2
a1368 2
    rb_lastline_set(dup);
    return dup;
@


1.39
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/23 07:01:27 $
d2084 1
a2084 1
    if (argc < 0) {
@


1.38
log
@2000-06-23
@
text
@d6 1
a6 1
  $Date: 2000/06/22 08:29:47 $
d687 4
@


1.37
log
@2000-06-22
@
text
@d6 1
a6 1
  $Date: 2000/06/16 07:44:04 $
d332 2
a333 1
    if (beg >= RSTRING(str)->len) return Qnil;
d2230 5
a2234 1
	rb_ary_push(result, rb_str_substr(str, beg, RSTRING(str)->len-beg));
@


1.36
log
@2000-06-16
@
text
@d6 1
a6 1
  $Date: 2000/06/14 08:08:50 $
d184 1
d187 7
a193 2
    if (OBJ_FROZEN(str)) return rb_str_new3(str);
    if (FL_TEST(str, STR_NO_ORIG)) {
a194 2
	OBJ_INFECT(str2, str);
	return str2;
d196 1
a196 1
    if (RSTRING(str)->orig) {
a197 2
	OBJ_INFECT(str2, str);
	return str2;
d199 3
d203 1
a203 4
    str2 = rb_str_new4(str);
    {
	NEWOBJ(dup, struct RString);
	OBJSETUP(dup, rb_cString, T_STRING);
d207 1
a207 3
	OBJ_INFECT(dup, str);

	return (VALUE)dup;
d209 3
d332 1
a332 1
    if (beg > RSTRING(str)->len) return Qnil;
@


1.35
log
@2000-06-14-2
@
text
@d6 1
a6 1
  $Date: 2000/06/14 05:30:22 $
d1090 1
d1098 1
d1118 1
d1133 2
a1134 1
	OBJ_INFECT(str, repl);
@


1.34
log
@2000-06-14
@
text
@d6 1
a6 1
  $Date: 2000/06/05 08:46:53 $
d1316 2
a1317 1
    VALUE str = rb_str_dup(uscore_get());
d1319 4
a1322 3
    rb_str_sub_bang(argc, argv, str);
    rb_lastline_set(str);
    return str;
d1338 2
a1339 1
    VALUE str = rb_str_dup(uscore_get());
d1341 4
a1344 3
    rb_str_gsub_bang(argc, argv, str);
    rb_lastline_set(str);
    return str;
d2363 1
a2363 1
    VALUE str = rb_str_dup(uscore_get());
d2365 5
a2369 2
    rb_str_chop_bang(str);
    rb_lastline_set(str);
d2442 2
a2443 1
    VALUE str = rb_str_dup(uscore_get());
d2445 4
a2448 3
    rb_str_chomp_bang(argc, argv, str);
    rb_lastline_set(str);
    return str;
@


1.33
log
@2000-06-05
@
text
@d6 1
a6 1
  $Date: 2000/05/24 04:34:08 $
d90 1
d183 1
a183 1
    VALUE shadow;
d188 8
a195 3
	VALUE s = rb_str_new(RSTRING(str)->ptr, RSTRING(str)->len);
	OBJ_INFECT(s, str);
	return s;
a196 1
    if (RSTRING(str)->orig) return rb_str_new3(RSTRING(str)->orig);
d198 1
a198 1
    shadow = rb_str_new4(str);
d202 3
a204 3
	dup->len = RSTRING(shadow)->len;
	dup->ptr = RSTRING(shadow)->ptr;
	dup->orig = shadow;
a522 4
    if (ruby_ignorecase) {
	return rb_str_cicmp(str1, str2);
    }

d524 1
a524 1
    retval = memcmp(RSTRING(str1)->ptr, RSTRING(str2)->ptr, len);
d610 1
a610 1
	if (*s == *(RSTRING(sub)->ptr) && memcmp(s, p, len) == 0) {
d710 1
a710 1
		if (*s == *t && memcmp(s, t, len) == 0) {
d2290 1
a2290 1
	     memcmp(RSTRING(rs)->ptr, p-rslen, rslen) == 0)) {
d2402 1
a2402 1
	 memcmp(RSTRING(rs)->ptr, p+len-rslen, rslen) == 0)) {
@


1.32
log
@2000-05-24
@
text
@d6 1
a6 1
  $Date: 2000/05/12 09:07:46 $
d1056 2
a1057 2
    result = rb_str_aref_m(2, buf, str);
    rb_str_aset_m(3, buf, str);
@


1.31
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/09 04:53:05 $
d901 5
a905 4
    VALUE arg1, arg2;

    if (rb_scan_args(argc, argv, "11", &arg1, &arg2) == 2) {
	return rb_str_substr(str, NUM2INT(arg1), NUM2INT(arg2));
d907 1
a907 1
    return rb_str_aref(str, arg1);
d1033 3
d1045 3
a1047 2
    VALUE arg1, arg2;
    long pos, len;
d1049 2
a1050 14
    rb_str_modify(str);
    if (rb_scan_args(argc, argv, "11", &arg1, &arg2) == 2) {
	pos = NUM2LONG(arg1);
	len = NUM2LONG(arg2);
      delete_pos_len:
	if (pos < 0) {
	    pos = RSTRING(str)->len + pos;
	}
	if (pos < 0 || RSTRING(str)->len <= pos) {
	    rb_raise(rb_eIndexError, "index %d out of string", pos);
	}
	arg2 = rb_str_substr(str, pos, len);
	rb_str_replace(str, pos, len, rb_str_new(0,0));
	return arg2;
d1052 2
a1053 3

    if (!FIXNUM_P(arg1) && rb_range_beg_len(arg1, &pos, &len, RSTRING(str)->len, 0)) {
	goto delete_pos_len;
d1055 4
a1058 15

    pos = NUM2LONG(arg1);
    len = RSTRING(str)->len;

    if (pos >= len) return Qnil;
    if (pos < 0) pos += len;
    if (pos < 0) return Qnil;

    arg2 = INT2FIX(RSTRING(str)->ptr[pos] & 0xff);
    memmove(RSTRING(str)->ptr + pos,
	    RSTRING(str)->ptr + pos + 1,
	    RSTRING(str)->len - (pos + 1));
    RSTRING(str)->len--;

    return arg2;
d1091 1
a1091 1
    if (argc == 1 && rb_iterator_p()) {
d1161 1
a1161 1
    if (argc == 1 && rb_iterator_p()) {
d2529 1
a2529 1
    if (!rb_iterator_p()) {
a2832 1
    rb_define_method(rb_cString, "delete_at", rb_str_slice_bang, -1);
@


1.30
log
@2000-05-09
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:29 $
d769 1
a769 1
    VALUE str, str2;
d1042 1
a1042 1
    long pos, len, i;
@


1.29
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:44:19 $
d11 1
a11 1
  Copyright (C) 2000  Information-technology Promotion Agancy, Japan
@


1.28
log
@2000-04-10
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/03/23 08:37:29 $
d10 2
d13 1
a13 1
************************************************/
d772 1
d775 2
d781 4
a784 1
	if (ISALNUM(*s) && (c = succ_char(s)) == 0) break;
d787 6
a792 9
    if (s < sbeg) {
	if (c == -1 && RSTRING(str)->len > 0) {
	    RSTRING(str)->ptr[RSTRING(str)->len-1] += 1;
	}
	else {
	    str2 = rb_str_new(0, RSTRING(str)->len+1);
	    RSTRING(str2)->ptr[0] = c;
	    memcpy(RSTRING(str2)->ptr+1, RSTRING(str)->ptr, RSTRING(str)->len);
	    str = str2;
d795 7
a801 3

    if (OBJ_TAINTED(orig)) {
	OBJ_TAINT(str);
@


1.27
log
@2000-03-23
@
text
@d6 1
a6 1
  $Date: 2000/03/17 08:58:14 $
d417 19
a438 1
    rb_str_modify(str1);
d446 2
a447 3
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
    str1 = rb_str_cat(str1, RSTRING(str2)->ptr, RSTRING(str2)->len);
    if (OBJ_TAINTED(str2)) OBJ_TAINT(str1);
@


1.26
log
@2000-03-17
@
text
@d6 1
a6 1
  $Date: 2000/03/15 05:01:16 $
d889 4
d898 1
a898 1
    if (len != RSTRING(val)->len) {
d906 3
a908 1
    memmove(RSTRING(str)->ptr+beg, RSTRING(val)->ptr, RSTRING(val)->len);
d1025 3
@


1.25
log
@2000-03-15
@
text
@d6 1
a6 1
  $Date: 2000/03/13 07:18:39 $
d144 14
d180 2
a189 2
    else {
	VALUE shadow;
d191 2
a194 3

	shadow = rb_str_new4(str);

d211 1
a211 1
	RSTRING(str)->orig = RSTRING(str)->orig;
d213 1
d351 1
d1232 1
@


1.24
log
@2000-03-13
@
text
@d6 1
a6 1
  $Date: 2000/03/08 06:23:18 $
d134 1
a134 1
    if ((!RSTRING(str)->orig||FL_TEST(str, STR_NO_ORIG))&&RSTRING(str)->ptr)
a161 13
static VALUE
str_dup(str)
    VALUE str;
{
    VALUE s;

    if (TYPE(str) != T_STRING) str = rb_str_to_str(str);
    s = rb_str_new(RSTRING(str)->ptr, RSTRING(str)->len);
    if (OBJ_TAINTED(str)) OBJ_TAINT(s);

    return s;
}

d168 5
a172 1
    if (FL_TEST(str, STR_NO_ORIG)) return str_dup(str);
d337 1
a337 2
    ptr = RSTRING(str)->ptr;
    RSTRING(str)->ptr = ALLOC_N(char, RSTRING(str)->len+1);
d339 1
a339 2
	memcpy(RSTRING(str)->ptr, ptr, RSTRING(str)->len);
	RSTRING(str)->ptr[RSTRING(str)->len] = 0;
d341 2
d1215 1
d2357 1
d2370 1
@


1.23
log
@2000-03-08
@
text
@d6 1
a6 1
  $Date: 2000/03/07 08:37:47 $
d109 1
a109 3
	if (OBJ_TAINTED(orig)) {
	    OBJ_TAINT(str);
	}
d163 1
a163 1
rb_str_clone(str)
d166 5
a170 1
    VALUE clone;
d172 1
a172 8
    if (RSTRING(str)->orig && !FL_TEST(str, STR_NO_ORIG))
	clone = rb_str_new3(RSTRING(str)->orig);
    else
	clone = rb_str_new(RSTRING(str)->ptr, RSTRING(str)->len);
    if (RSTRING(str)->orig && FL_TEST(str, STR_NO_ORIG))
	RSTRING(str)->orig = RSTRING(str)->orig;
    CLONESETUP(clone, str);
    return clone;
d179 20
a198 1
    VALUE s;
a199 3
    if (TYPE(str) != T_STRING) str = rb_str_to_str(str);
    s = rb_str_new(RSTRING(str)->ptr, RSTRING(str)->len);
    if (OBJ_TAINTED(str)) OBJ_TAINT(s);
d201 9
a209 1
    return s;
d1081 1
a1093 1
	rb_str_modify(str);
d1107 1
d1125 1
a1125 1
rb_str_gsub_bang(argc, argv, str)
d1129 1
d1153 4
a1156 1
    if (beg < 0) return Qnil;	/* no match, no substitution */
d1217 9
a1225 2
    rb_str_modify(str);
    free(RSTRING(str)->ptr);
d1229 1
d1231 2
d1234 7
a1240 1
    return str;
d1249 1
a1249 3
    str = rb_str_dup(str);
    rb_str_gsub_bang(argc, argv, str);
    return str;
@


1.22
log
@2000-03-07
@
text
@d6 1
a6 1
  $Date: 2000/02/29 08:05:27 $
d2487 7
d2765 1
@


1.21
log
@2000-02-29
@
text
@d6 1
a6 1
  $Date: 2000/02/25 03:51:21 $
d2535 1
a2535 1
    return INT2FIX(id);
@


1.20
log
@2000-02-25
@
text
@d6 1
a6 1
  $Date: 2000/02/23 05:23:09 $
d194 3
a196 1
rb_str_s_new(klass, orig)
a197 1
    VALUE orig;
d199 1
a199 1
    NEWOBJ(str, struct RString);
d202 2
a203 14
    str->orig = 0;
    orig = rb_obj_as_string(orig);
    str->len = RSTRING(orig)->len;
    if (RSTRING(orig)->ptr) {
	str->ptr = ALLOC_N(char, RSTRING(orig)->len+1);
	memcpy(str->ptr, RSTRING(orig)->ptr, RSTRING(orig)->len);
	str->ptr[RSTRING(orig)->len] = '\0';
    }

    if (rb_safe_level() >= 3) {
	OBJ_TAINT(str);
    }

    return (VALUE)str;
d249 1
d253 3
d807 1
d838 2
a839 1
	rb_raise(rb_eIndexError, "invalid index for string");
d861 2
a862 2
    int beg;
    int len;
d889 1
a889 2
    int idx;
    int beg;
d893 2
a894 1
	beg = idx = NUM2INT(indx);
d941 2
a942 1
	rb_raise(rb_eIndexError, "invalid index for string");
d954 1
a954 1
	int beg, len;
d1048 1
a1048 1
    int plen;
d1112 2
a1113 1
    int beg, n;
a1115 1
    int offset, blen, len;
d1461 1
a1461 1
    int len;
d2037 1
a2037 1
    int beg, end, i;
d2077 1
a2077 1
	int len = RSTRING(str)->len;
d2119 2
a2120 1
	int start = beg;
a2121 1
	int idx;
d2197 1
a2197 1
    int len = RSTRING(str)->len;
d2250 1
a2250 1
    int i;
d2313 1
a2313 1
    int len = RSTRING(str)->len;
d2653 2
a2654 1
    rb_define_singleton_method(rb_cString, "new", rb_str_s_new, 1);
@


1.19
log
@2000-02-23
@
text
@d6 1
a6 1
  $Date: 2000/02/17 07:11:17 $
d424 10
a433 1
#if 0
d436 1
a436 1
	    key = key*65599 + toupper(*p);
d442 1
a442 2
	    key = key*65599 + *p;
	    p++;
d445 1
d449 1
a449 1
	    key = key*33 + toupper(*p);
d455 2
a456 1
	    key = key*33 + *p++;
a955 2
    VALUE arg1, arg2, arg3;

d957 1
a957 2

    if (rb_scan_args(argc, argv, "21", &arg1, &arg2, &arg3) == 3) {
d960 3
a962 3
	if (TYPE(arg3) != T_STRING) arg3 = rb_str_to_str(arg3);
	beg = NUM2INT(arg1);
	len = NUM2INT(arg2);
d976 2
a977 2
	rb_str_replace(str, beg, len, arg3);
	return arg3;
d979 1
a979 1
    return rb_str_aset(str, arg1, arg2);
@


1.18
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:48:54 $
d424 1
d437 14
d1372 1
d1449 3
a1451 1
    return rb_str_new(buf, b - buf);
@


1.17
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/02/02 08:10:30 $
d344 7
d570 4
@


1.16
log
@2000-02-02
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:12:11 $
a1032 1
	rb_str_modify(str);
d1037 1
a1037 1
	    rb_match_busy(match, Qtrue);
a1038 1
	    rb_match_busy(match, Qfalse);
d1045 1
d1059 1
d1061 1
a1061 1
    return str;
d1103 1
a1103 1
    if (beg < 0) return str;	/* no match, no substitution */
a1112 1
	rb_match_busy(match, Qtrue);
d1115 1
a1162 1
    rb_match_busy(match, Qfalse);
d1520 1
d1530 1
d1534 3
a1536 1
    return str;
d1553 1
d1563 1
d1567 3
a1569 1
    return str;
d1586 1
d1592 1
d1600 1
d1603 2
a1604 1
    return str;
d1621 1
d1631 1
d1635 1
d1640 2
a1641 1
    return str;
d1693 1
a1693 1
static void
d1701 1
a1701 1
    int i, c;
d1713 1
a1713 2
	rb_str_delete_bang(1, &src, str);
	return;
d1760 1
d1769 1
d1777 1
d1782 3
d1791 1
a1791 2
    tr_trans(str, src, repl, 0);
    return str;
d1845 1
d1862 3
a1864 1
	if (!squeez[*s & 0xff])
d1871 2
a1872 1
    return str;
d1894 1
a1894 1
    int c, save;
d1915 1
d1928 1
d1931 2
a1932 1
    return str;
d1950 1
a1950 2
    tr_trans(str, src, repl, 1);
    return str;
d2240 1
d2242 1
a2242 1
    return str;
d2309 1
d2311 1
a2311 1
    return str;
d2338 1
a2338 1
    VALUE str = rb_str_dup(uscore_get());;
d2374 4
d2430 1
d2437 1
d2440 1
d2443 1
a2443 1

d2445 2
d2448 1
d2450 1
@


1.15
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:37:46 $
d1011 1
a1011 1
str_sub_bang(argc, argv, str)
a1059 1
	return str;
a1060 10
    return Qnil;
}

static VALUE
rb_str_sub_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    str_sub_bang(argc, argv, str);
d1070 3
a1072 7
    VALUE dup = rb_str_dup(str);

    if (NIL_P(str_sub_bang(argc, argv, dup))) {
	rb_gc_force_recycle(dup);
	return str;
    }
    return dup;
d1076 1
a1076 1
str_gsub_bang(argc, argv, str)
d1103 1
a1103 1
    if (beg < 0) return Qnil;	/* no match, no substitution */
d1113 1
a1115 1
	    rb_match_busy(match, Qtrue);
a1116 1
	    rb_match_busy(match, Qfalse);
d1163 2
d1176 1
a1176 1
rb_str_gsub_bang(argc, argv, str)
d1181 2
a1182 1
    str_gsub_bang(argc, argv, str);
a1186 15
rb_str_gsub(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE dup = rb_str_dup(str);

    if (NIL_P(str_gsub_bang(argc, argv, dup))) {
	rb_gc_force_recycle(dup);
	return str;
    }
    return dup;
}

static VALUE
d1225 1
a1225 2
    VALUE line = uscore_get();
    VALUE dup = rb_str_dup(line);
d1227 3
a1229 6
    if (NIL_P(str_sub_bang(argc, argv, dup))) {
	rb_gc_force_recycle(dup);
	return line;
    }
    rb_lastline_set(dup);
    return dup;
d1245 1
a1245 2
    VALUE line = uscore_get();
    VALUE dup = rb_str_dup(line);
d1247 3
a1249 6
    if (NIL_P(str_gsub_bang(argc, argv, dup))) {
	rb_gc_force_recycle(dup);
	return line;
    }
    rb_lastline_set(dup);
    return dup;
d1517 1
a1517 1
str_upcase_bang(str)
a1520 1
    int modify = 0;
a1529 1
	    modify = 1;
a1532 10

    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_upcase_bang(str)
    VALUE str;
{
    str_upcase_bang(str);
d1540 3
a1542 7
    VALUE dup = rb_str_dup(str);

    if (NIL_P(str_upcase_bang(dup))) {
	rb_gc_force_recycle(dup);
	return str;
    }
    return dup;
d1546 1
a1546 1
str_downcase_bang(str)
a1549 1
    int modify = 0;
a1558 1
	    modify = 1;
a1561 10

    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_downcase_bang(str)
    VALUE str;
{
    str_downcase_bang(str);
d1569 3
a1571 7
    VALUE dup = rb_str_dup(str);

    if (NIL_P(str_downcase_bang(dup))) {
	rb_gc_force_recycle(dup);
	return str;
    }
    return dup;
d1575 1
a1575 1
str_capitalize_bang(str)
a1578 1
    int modify = 0;
a1583 1
	modify = 1;
a1590 1
	    modify = 1;
a1592 9
    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_capitalize_bang(str)
    VALUE str;
{
    str_capitalize_bang(str);
d1600 3
a1602 7
    VALUE dup = rb_str_dup(str);

    if (NIL_P(str_capitalize_bang(dup))) {
	rb_gc_force_recycle(dup);
	return str;
    }
    return dup;
d1606 1
a1606 1
str_swapcase_bang(str)
a1609 1
    int modify = 0;
a1618 1
	    modify = 1;
a1621 1
	    modify = 1;
a1625 9
    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_swapcase_bang(str)
    VALUE str;
{
    str_swapcase_bang(str);
d1633 3
a1635 7
    VALUE dup = rb_str_dup(str);

    if (NIL_P(str_swapcase_bang(dup))) {
	rb_gc_force_recycle(dup);
	return str;
    }
    return dup;
d1678 1
a1678 1
static VALUE
d1686 1
a1686 1
    int i, c, modify = 0;
d1698 2
a1699 1
	return rb_str_delete_bang(1, &src, str);
a1745 1
		modify = 1;
a1753 1
	    modify = 1;
a1760 1
		modify = 1;
a1764 3

    if (modify) return str;
    return Qnil;
d1779 3
a1781 5
    VALUE dup = rb_str_dup(str);

    if (NIL_P(tr_trans(str, src, repl, 0)))
	return str;
    return dup;
d1819 1
a1819 1
str_delete_bang(argc, argv, str)
a1825 1
    int modify = 0;
d1842 1
a1842 3
	if (squeez[*s & 0xff])
	    modify = 1;
	else
d1849 1
a1849 2
    if (modify) return str;
    return Qnil;
d1853 1
a1853 1
rb_str_delete_bang(argc, argv, str)
d1858 2
a1859 1
    str_delete_bang(argc, argv, str);
a1861 15
    
static VALUE
rb_str_delete(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE dup = rb_str_dup(str);

    if (NIL_P(str_delete_bang(argc, argv, dup))) {
	rb_gc_force_recycle(dup);
	return str;
    }
    return dup;
}
d1864 1
a1864 1
str_squeeze_bang(argc, argv, str)
d1871 1
a1871 1
    int c, save, modify = 0;
a1891 1

a1903 1
	modify = 1;
a1905 11
    if (modify) return str;
    return Qnil;
}

static VALUE
rb_str_squeeze_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    str_squeeze_bang(argc, argv, str);
d1915 3
a1917 7
    VALUE dup = rb_str_dup(str);

    if (NIL_P(str_squeeze_bang(argc, argv, dup))) {
	rb_gc_force_recycle(dup);
	return str;
    }
    return dup;
d1932 3
a1934 5
    VALUE dup = rb_str_dup(str);

    if (NIL_P(tr_trans(str, src, repl, 1)))
	return str;
    return dup;
d2202 1
a2202 1
str_chop_bang(str)
a2214 1
	return str;
a2215 8
    return Qnil;
}

static VALUE
rb_str_chop_bang(str)
    VALUE str;
{
    str_chop_bang(str);
d2223 3
a2225 7
    VALUE dup = rb_str_dup(str);

    if (NIL_P(str_chop_bang(dup))) {
	rb_gc_force_recycle(dup);
	return str;
    }
    return dup;
d2238 1
a2238 2
    VALUE line = uscore_get();
    VALUE dup = rb_str_dup(line);
d2240 3
a2242 5
    if (!NIL_P(str_chop_bang(dup))) {
	rb_lastline_set(dup);
	return dup;
    }
    return line;
d2246 1
a2246 1
str_chomp_bang(argc, argv, str)
a2282 1
	return str;
a2283 10
    return Qnil;
}

static VALUE
rb_str_chomp_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    str_chomp_bang(argc, argv, str);
d2293 3
a2295 7
    VALUE dup = rb_str_dup(str);

    if (NIL_P(str_chomp_bang(argc, argv, dup))) {
	rb_gc_force_recycle(dup);
	return str;
    }
    return dup;
d2311 1
a2311 2
    VALUE str = uscore_get();
    VALUE dup = rb_str_dup(str);
d2313 2
a2314 4
    if (!NIL_P(str_chomp_bang(argc, argv, dup))) {
	rb_lastline_set(dup);
	return dup;
    }
d2319 1
a2319 1
str_strip_bang(str)
a2346 4
    else {
	return Qnil;
    }

d2351 1
a2351 1
rb_str_strip_bang(str)
d2354 2
a2355 1
    str_strip_bang(str);
a2356 13
}

static VALUE
rb_str_strip(str)
    VALUE str;
{
    VALUE dup = rb_str_dup(str);

    if (NIL_P(str_strip_bang(dup))) {
	rb_gc_force_recycle(dup);
	return str;
    }
    return dup;
@


1.14
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:37:12 $
d27 1
a27 2
#define STR_FREEZE FL_USER1
#define STR_NO_ORIG FL_USER3
d96 4
a99 5
    if (FL_TEST(orig, STR_FREEZE)) {
	return orig;
    }
    else if (RSTRING(orig)->orig && !FL_TEST(orig, STR_NO_ORIG)) {
	return rb_str_freeze(RSTRING(orig)->orig);
d112 2
a113 1
	FL_SET(str, STR_FREEZE);
d330 1
a330 2
    if (FL_TEST(str, STR_FREEZE))
	rb_raise(rb_eTypeError, "can't modify frozen string");
a343 20
rb_str_freeze(str)
    VALUE str;
{
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(str))
	rb_raise(rb_eSecurityError, "Insecure: can't freeze string");

    FL_SET(str, STR_FREEZE);
    return str;
}

static VALUE
rb_str_frozen_p(str)
    VALUE str;
{
    if (FL_TEST(str, STR_FREEZE))
	return Qtrue;
    return Qfalse;
}

VALUE
d348 2
a349 1
	return rb_str_freeze(RSTRING(str)->orig);
d351 4
a354 3
    if (FL_TEST(str, STR_FREEZE))
	return str;
    return rb_str_freeze(rb_str_dup(str));
d950 42
d1011 1
a1011 1
rb_str_sub_bang(argc, argv, str)
d1066 10
d1081 7
a1087 3
    str = rb_str_dup(str);
    rb_str_sub_bang(argc, argv, str);
    return str;
d1091 1
a1091 1
rb_str_gsub_bang(argc, argv, str)
d1190 10
d1205 7
a1211 3
    str = rb_str_dup(str);
    rb_str_gsub_bang(argc, argv, str);
    return str;
d1253 2
a1254 1
    VALUE line;
d1256 3
a1258 3
    line = rb_str_dup(uscore_get());
    if (!NIL_P(rb_str_sub_bang(argc, argv, line))) {
	rb_lastline_set(line);
d1260 2
a1261 1
    return line;
d1277 2
a1278 1
    VALUE line;
d1280 3
a1282 3
    line = rb_str_dup(uscore_get());
    if (!NIL_P(rb_str_gsub_bang(argc, argv, line = rb_str_dup(line)))) {
	rb_lastline_set(line);
d1284 2
a1285 1
    return line;
d1553 1
a1553 1
rb_str_upcase_bang(str)
d1577 8
d1588 7
a1594 3
    str = rb_str_dup(str);
    rb_str_upcase_bang(str);
    return str;
d1598 1
a1598 1
rb_str_downcase_bang(str)
d1622 8
d1633 7
a1639 3
    str = rb_str_dup(str);
    rb_str_downcase_bang(str);
    return str;
d1643 1
a1643 1
rb_str_capitalize_bang(str)
d1669 8
d1680 7
a1686 3
    str = rb_str_dup(str);
    rb_str_capitalize_bang(str);
    return str;
d1690 1
a1690 1
rb_str_swapcase_bang(str)
d1718 8
d1729 7
a1735 3
    str = rb_str_dup(str);
    rb_str_swapcase_bang(str);
    return str;
d1876 2
a1877 1
    return tr_trans(str, src, repl, 0);
d1884 5
a1888 3
    str = rb_str_dup(str);
    tr_trans(str, src, repl, 0);
    return str;
d1926 1
a1926 1
rb_str_delete_bang(argc, argv, str)
d1964 10
d1979 7
a1985 3
    str = rb_str_dup(str);
    rb_str_delete_bang(argc, argv, str);
    return str;
d1989 1
a1989 1
rb_str_squeeze_bang(argc, argv, str)
d2038 10
d2053 7
a2059 3
    str = rb_str_dup(str);
    rb_str_squeeze_bang(argc, argv, str);
    return str;
d2066 2
a2067 1
    return tr_trans(str, src, repl, 1);
d2074 5
a2078 3
    str = rb_str_dup(str);
    tr_trans(str, src, repl, 1);
    return str;
d2326 1
d2346 1
a2346 1
rb_str_chop_bang(str)
d2365 8
d2376 7
a2382 3
    str = rb_str_dup(str);
    rb_str_chop_bang(str);
    return str;
d2395 2
a2396 1
    VALUE str = rb_str_dup(uscore_get());
d2398 3
a2400 2
    if (!NIL_P(rb_str_chop_bang(str))) {
	rb_lastline_set(str);
d2402 1
a2402 1
    return str;
d2406 1
a2406 1
rb_str_chomp_bang(argc, argv, str)
d2449 10
d2464 7
a2470 3
    str = rb_str_dup(str);
    rb_str_chomp_bang(argc, argv, str);
    return str;
d2486 6
a2491 3
    VALUE str = rb_str_dup(uscore_get());
    if (!NIL_P(rb_str_chomp_bang(argc, argv, str))) {
	rb_lastline_set(str);
d2497 1
a2497 1
rb_str_strip_bang(str)
d2533 8
d2544 7
a2550 3
    str = rb_str_dup(str);
    rb_str_strip_bang(str);
    return str;
a2803 3
    rb_define_method(rb_cString, "freeze", rb_str_freeze, 0);
    rb_define_method(rb_cString, "frozen?", rb_str_frozen_p, 0);

d2881 4
@


1.13
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:49:52 $
d866 1
a866 1
    memcpy(RSTRING(str)->ptr+beg, RSTRING(val)->ptr, RSTRING(val)->len);
a2195 26
#ifdef STR_TO_A_USE_EACH
static VALUE
to_a_push(str, ary)
    VALUE str, ary;
{
    return rb_ary_push(ary, str);
}
#endif

static VALUE
rb_str_to_a(str)
    VALUE str;
{
#ifdef STR_TO_A_USE_EACH
    VALUE ary;

    if (RSTRING(str)->len == 0) return rb_ary_new3(1, str);
    ary = rb_ary_new();
    rb_iterate(rb_each, str, to_a_push, ary);

    return ary;
#else
    return rb_ary_new3(1, str);
#endif
}

a2628 1
    rb_define_method(rb_cString, "to_a", rb_str_to_a, 0);
@


1.12
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/12/07 09:23:27 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
a24 4
#ifndef atof
double strtod();
#endif

d30 1
a30 1
extern VALUE rb_rs;
d166 2
a167 2
rb_str_clone(orig)
    VALUE orig;
d169 1
a169 1
    VALUE str;
d171 2
a172 2
    if (RSTRING(orig)->orig && !FL_TEST(orig, STR_NO_ORIG))
	str = rb_str_new3(RSTRING(orig)->orig);
d174 5
a178 5
	str = rb_str_new(RSTRING(orig)->ptr, RSTRING(orig)->len);
    if (RSTRING(orig)->orig && FL_TEST(orig, STR_NO_ORIG))
	RSTRING(str)->orig = RSTRING(orig)->orig;
    CLONESETUP(str, orig);
    return str;
d453 1
a453 1
rb_str_hash_method(str)
d500 1
a500 1
rb_str_cmp_method(str1, str2)
d569 1
a569 1
rb_str_index_method(argc, argv, str)
d781 1
a781 1
rb_str_upto_method(beg, end)
d834 1
a834 1
rb_str_aref_method(argc, argv, str)
d935 1
a935 1
rb_str_aset_method(argc, argv, str)
d1066 1
d1072 2
a1073 1
	repl = rb_obj_as_string(argv[1]);;
d1102 1
d1148 1
d1165 1
a1165 1
rb_str_replace_method(str, str2)
d1302 1
a1302 1
    return rb_str2inum(RSTRING(str)->ptr, 10);
d1980 1
a1980 1
rb_str_split_method(argc, argv, str)
d2007 1
a2009 1
	  fs_set:
d2126 1
a2126 1
    return rb_str_split_method(1, &sep, str);
d2134 1
a2134 1
    return rb_str_split_method(argc, argv, uscore_get());
d2196 26
d2460 1
a2460 1
    return rb_str2inum(RSTRING(str)->ptr, 16);
d2481 1
a2481 1
    return rb_str2inum(RSTRING(str)->ptr, base);
d2626 1
a2626 1
    rb_define_method(rb_cString, "<=>", rb_str_cmp_method, 1);
d2630 1
a2630 1
    rb_define_method(rb_cString, "hash", rb_str_hash_method, 0);
d2634 2
a2635 2
    rb_define_method(rb_cString, "[]", rb_str_aref_method, -1);
    rb_define_method(rb_cString, "[]=", rb_str_aset_method, -1);
d2645 2
a2646 2
    rb_define_method(rb_cString, "upto", rb_str_upto_method, 1);
    rb_define_method(rb_cString, "index", rb_str_index_method, -1);
d2648 1
a2648 1
    rb_define_method(rb_cString, "replace", rb_str_replace_method, 1);
d2655 1
d2673 1
a2673 1
    rb_define_method(rb_cString, "split", rb_str_split_method, -1);
d2733 4
@


1.11
log
@991207
@
text
@d6 1
a6 1
  $Date: 1999/12/06 09:03:59 $
d69 1
a69 1
    FL_SET(str, FL_TAINT);
d79 1
a79 1
    FL_SET(str, FL_TAINT);
d115 2
a116 2
	if (FL_TEST(orig, FL_TAINT)) {
	    FL_SET(str, FL_TAINT);
d216 1
a216 1
	FL_SET(str, FL_TAINT);
d337 1
a337 1
    if (!FL_TEST(str, FL_TAINT) && rb_safe_level() >= 4)
d353 3
d591 1
d642 1
@


1.10
log
@19991206
@
text
@d6 1
a6 1
  $Date: 1999/12/01 09:24:14 $
d2606 1
a2606 1
    rb_define_alias(rb_cString,  "size", "length");
@


1.9
log
@19991201
@
text
@d6 1
a6 1
  $Date: 1999/11/04 08:39:38 $
d131 1
a131 1
rb_str_assign(str, str2)
d425 3
a427 1
    return rb_str_cat(str1, RSTRING(str2)->ptr, RSTRING(str2)->len);
d751 1
a751 1
    rb_str_assign(str, rb_str_succ(str));
@


1.8
log
@19991104
@
text
@d6 1
a6 1
  $Date: 1999/10/29 09:25:31 $
d2058 1
a2058 1
		if (ismbchar(*ptr)) ptr++;
@


1.7
log
@19991029
@
text
@d6 1
a6 1
  $Date: 1999/10/20 07:10:22 $
d760 1
d768 1
a768 1
	current = rb_str_succ(current);
d1114 1
a1114 1
	    len = mbclen(RSTRING(str)->ptr[END(0)]);
a1345 6
#if 0
	else if ((c & 0x80) && rb_kcode() != MBCTYPE_EUC) {
	    CHECK(1);
	    *b++ = c;
	}
#endif
d2072 1
a2072 1
		    rb_ary_push(result, rb_str_substr(str, beg, mbclen(RSTRING(str)->ptr[beg])));
d2076 1
a2076 1
		    start += mbclen(RSTRING(str)->ptr[start]);
d2382 1
a2382 1
	    *start = END(0)+mbclen(RSTRING(str)->ptr[END(0)]);
@


1.6
log
@marshal load GC protect
@
text
@d6 1
a6 1
  $Date: 1999/10/15 08:52:17 $
d2063 1
@


1.5
log
@-r debug, -s, etc.
@
text
@d6 1
a6 1
  $Date: 1999/09/22 04:30:10 $
d1045 3
a1047 4
    VALUE val = rb_str_sub_bang(argc, argv, str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1151 3
a1153 4
    VALUE val = rb_str_gsub_bang(argc, argv, str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1195 1
a1195 1
    VALUE line, v;
d1197 5
a1201 5
    line = uscore_get();
    v = rb_str_sub_bang(argc, argv, line = rb_str_dup(line));
    if (NIL_P(v)) return line;
    rb_lastline_set(v);
    return v;
d1217 1
a1217 1
    VALUE line, v;
d1219 5
a1223 5
    line = uscore_get();
    v = rb_str_gsub_bang(argc, argv, line = rb_str_dup(line));
    if (NIL_P(v)) return line;
    rb_lastline_set(v);
    return v;
d1524 3
a1526 4
    VALUE val = rb_str_upcase_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1557 3
a1559 4
    VALUE val = rb_str_downcase_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1592 3
a1594 4
    VALUE val = rb_str_capitalize_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1629 3
a1631 4
    VALUE val = rb_str_swapcase_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1779 3
a1781 4
    VALUE val = tr_trans(str = rb_str_dup(str), src, repl, 0);

    if (NIL_P(val)) return str;
    return val;
d1862 3
a1864 4
    VALUE val = rb_str_delete_bang(argc, argv, str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1922 3
a1924 4
    VALUE val = rb_str_squeeze_bang(argc, argv, str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1938 3
a1940 4
    VALUE val = tr_trans(str = rb_str_dup(str), src, repl, 1);

    if (NIL_P(val)) return str;
    return val;
d2228 3
a2230 4
    VALUE val = rb_str_chop_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d2243 1
a2243 2
    VALUE str = uscore_get();
    VALUE val = rb_str_chop_bang(str = rb_str_dup(str));
d2245 4
a2248 3
    if (NIL_P(val)) return str;
    rb_lastline_set(val);
    return val;
d2300 3
a2302 4
    VALUE val = rb_str_chomp_bang(argc, argv, str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d2318 5
a2322 6
    VALUE str = uscore_get();
    VALUE val = rb_str_chomp_bang(argc, argv, str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    rb_lastline_set(val);
    return val;
d2365 3
a2367 4
    VALUE val = rb_str_strip_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
@


1.4
log
@19990922
@
text
@d6 1
a6 1
  $Date: 1999/09/16 09:40:33 $
d115 1
a115 1
	if (FL_TEST(str, FL_TAINT)) {
d118 1
@


1.4.2.1
log
@19991029
@
text
@d6 1
a6 1
  $Date: 1999/09/22 04:30:10 $
a2071 1
		if (ismbchar(*ptr)) ptr++;
@


1.4.2.2
log
@19991104
@
text
@d6 1
a6 1
  $Date: 1999/10/29 09:25:48 $
a758 1
    ID succ = rb_intern("succ");
d766 1
a766 1
	current = rb_funcall(current, succ, 0, 0);
@


1.4.2.3
log
@19991117
@
text
@d6 1
a6 1
  $Date: 1999/11/04 08:39:56 $
d115 1
a115 1
	if (FL_TEST(orig, FL_TAINT)) {
a117 1
	FL_SET(str, STR_FREEZE);
d1114 1
a1114 1
	    len = mbclen2(RSTRING(str)->ptr[END(0)], pat);
d1347 6
d2087 1
a2087 1
		    rb_ary_push(result, rb_str_substr(str, beg, mbclen2(RSTRING(str)->ptr[beg],spat)));
d2091 1
a2091 1
		    start += mbclen2(RSTRING(str)->ptr[start],spat);
d2401 1
a2401 1
	    *start = END(0)+mbclen2(RSTRING(str)->ptr[END(0)],pat);
@


1.4.2.4
log
@19991201
@
text
@d6 1
a6 1
  $Date: 1999/11/17 07:29:52 $
d2068 1
a2068 1
		if (ismbchar(*ptr)) {ptr++; end++;}
@


1.4.2.5
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 1999/12/01 09:24:46 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
d863 1
a863 1
    memmove(RSTRING(str)->ptr+beg, RSTRING(val)->ptr, RSTRING(val)->len);
@


1.4.2.6
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:24:12 $
d1046 1
a1046 1
    VALUE dup = rb_str_dup(str);
d1048 2
a1049 3
    if (NIL_P(rb_str_sub_bang(argc, argv, dup)))
	return str;
    return dup;
d1153 1
a1153 1
    VALUE dup = rb_str_dup(str);
d1155 2
a1156 3
    if (NIL_P(rb_str_gsub_bang(argc, argv, dup)))
	return str;
    return dup;
d1198 1
a1198 2
    VALUE line = uscore_get();
    VALUE dup = rb_str_dup(line);
d1200 5
a1204 4
    if (NIL_P(rb_str_sub_bang(argc, argv, dup)))
	return line;
    rb_lastline_set(dup);
    return dup;
d1220 1
a1220 2
    VALUE line = uscore_get();
    VALUE dup = rb_str_dup(line);
d1222 5
a1226 4
    if (NIL_P(rb_str_gsub_bang(argc, argv, dup)))
	return line;
    rb_lastline_set(dup);
    return dup;
d1521 1
a1521 1
    VALUE dup = rb_str_dup(str);
d1523 2
a1524 3
    if (NIL_P(rb_str_upcase_bang(dup)))
	return str;
    return dup;
d1555 1
a1555 1
    VALUE dup = rb_str_dup(str);
d1557 2
a1558 3
    if (NIL_P(rb_str_downcase_bang(dup)))
	return str;
    return dup;
d1591 1
a1591 1
    VALUE dup = rb_str_dup(str);
d1593 2
a1594 3
    if (NIL_P(rb_str_capitalize_bang(dup)))
	return str;
    return dup;
d1629 1
a1629 1
    VALUE dup = rb_str_dup(str);
d1631 2
a1632 3
    if (NIL_P(rb_str_swapcase_bang(dup)))
	return str;
    return dup;
d1780 1
a1780 1
    VALUE dup = rb_str_dup(str);
d1782 2
a1783 3
    if (NIL_P(tr_trans(dup, src, repl, 0)))
	return str;
    return dup;
d1864 1
a1864 1
    VALUE dup = rb_str_dup(str);
d1866 2
a1867 3
    if (NIL_P(rb_str_delete_bang(argc, argv, dup)))
	return str;
    return dup;
d1925 1
a1925 1
    VALUE dup = rb_str_dup(str);
d1927 2
a1928 3
    if (NIL_P(rb_str_squeeze_bang(argc, argv, dup)))
	return str;
    return dup;
d1942 1
a1942 1
    VALUE dup = rb_str_dup(str);
d1944 2
a1945 3
    if (NIL_P(tr_trans(dup, src, repl, 1)))
	return str;
    return dup;
d2234 1
a2234 1
    VALUE dup = rb_str_dup(str);
d2236 2
a2237 3
    if (NIL_P(rb_str_chop_bang(dup)))
	return str;
    return dup;
d2251 1
a2251 1
    VALUE dup = rb_str_dup(str);
d2253 3
a2255 4
    if (NIL_P(rb_str_chop_bang(dup)))
	return str;
    rb_lastline_set(dup);
    return dup;
d2307 1
a2307 1
    VALUE dup = rb_str_dup(str);
d2309 2
a2310 3
    if (NIL_P(rb_str_chomp_bang(argc, argv, dup)))
	return str;
    return dup;
d2327 1
a2327 1
    VALUE dup = rb_str_dup(str);
d2329 3
a2331 4
    if (NIL_P(rb_str_chomp_bang(argc, argv, dup)))
	return str;
    rb_lastline_set(dup);
    return dup;
d2374 1
a2374 1
    VALUE dup = rb_str_dup(str);
d2376 2
a2377 3
    if (NIL_P(rb_str_strip_bang(dup)))
	return str;
    return dup;
@


1.4.2.7
log
@2000-02-02
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:11:23 $
d1046 5
a1050 3
    str = rb_str_dup(str);
    rb_str_sub_bang(argc, argv, str);
    return str;
d1154 1
a1154 1
    str = rb_str_dup(str);
d1156 3
a1158 2
    rb_str_gsub_bang(argc, argv, dup);
    return str;
d1200 2
a1201 1
    VALUE str = rb_str_dup(uscore_get());
d1203 4
a1206 3
    rb_str_sub_bang(argc, argv, str);
    rb_lastline_set(str);
    return str;
d1222 2
a1223 1
    VALUE str = rb_str_dup(uscore_get());
d1225 4
a1228 3
    rb_str_gsub_bang(argc, argv, str);
    rb_lastline_set(str);
    return str;
d1523 5
a1527 3
    str = rb_str_dup(str);
    rb_str_upcase_bang(str);
    return str;
d1558 5
a1562 3
    str = rb_str_dup(str);
    rb_str_downcase_bang(str);
    return str;
d1595 5
a1599 3
    str = rb_str_dup(str);
    rb_str_capitalize_bang(str);
    return str;
d1634 5
a1638 3
    str = rb_str_dup(str);
    rb_str_swapcase_bang(str);
    return str;
d1786 5
a1790 3
    str = rb_str_dup(str);
    tr_trans(str, src, repl, 0);
    return str;
d1871 5
a1875 3
    str = rb_str_dup(str);
    rb_str_delete_bang(argc, argv, str);
    return str;
d1933 5
a1937 3
    str = rb_str_dup(str);
    rb_str_squeeze_bang(argc, argv, str);
    return str;
d1951 5
a1955 3
    str = rb_str_dup(str);
    tr_trans(str, src, repl, 1);
    return str;
d2244 5
a2248 3
    str = rb_str_dup(str);
    rb_str_chop_bang(str);
    return str;
d2261 2
a2262 1
    VALUE str = rb_str_dup(uscore_get());
d2264 4
a2267 3
    rb_str_chop_bang(str);
    rb_lastline_set(str);
    return str;
d2319 5
a2323 3
    str = rb_str_dup(str);
    rb_str_chomp_bang(argc, argv, str);
    return str;
d2339 2
a2340 1
    VALUE str = rb_str_dup(uscore_get());
d2342 4
a2345 3
    rb_str_chomp_bang(argc, argv, str);
    rb_lastline_set(str);
    return str;
d2388 5
a2392 3
    str = rb_str_dup(str);
    rb_str_strip_bang(str);
    return str;
@


1.4.2.8
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/02/02 08:09:40 $
d1154 1
a1154 1
    rb_str_gsub_bang(argc, argv, str);
@


1.4.2.9
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:53:55 $
a581 4
    }
    if (pos < 0) {
	pos += RSTRING(str)->len;
	if (pos < 0) return Qnil;
@


1.4.2.10
log
@2000-03-02
@
text
@d6 1
a6 1
  $Date: 2000/02/17 08:29:03 $
a266 3
    }
    if (LONG_MAX / len <  RSTRING(str)->len) {
	rb_raise(rb_eArgError, "argument too big");
@


1.4.2.11
log
@2000-03-08
@
text
@d6 1
a6 1
  $Date: 2000/03/02 03:51:45 $
a264 1
    if (len == 0) return rb_str_new(0,0);
@


1.4.2.12
log
@2000-03-23
@
text
@d6 1
a6 1
  $Date: 2000/03/08 06:25:16 $
a2274 1
	    rb_str_modify(str);
a2286 1
	rb_str_modify(str);
@


1.4.2.13
log
@2000-04-17
@
text
@d6 1
a6 1
  $Date: 2000/03/23 04:14:21 $
a857 4
    if (RSTRING(str)->len < beg + len) {
	len = RSTRING(str)->len - beg;
    }

@


1.4.2.14
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/17 06:24:45 $
a723 1
    int n = 0;
a725 2
    if (OBJ_TAINTED(orig)) OBJ_TAINT(str);
    if (RSTRING(str)->len == 0) return str;
d730 1
a730 4
	if (ISALNUM(*s)) {
	    if ((c = succ_char(s)) == 0) break;
	    n = s - sbeg;
	}
d733 9
a741 6
    if (c == -1) {		/* str contains no alnum */
	sbeg = RSTRING(str)->ptr; s = sbeg + RSTRING(str)->len - 1;
	c = '\001';
	while (sbeg <= s) {
	    *s += 1;
	    if (*s-- != 0) break;
d744 3
a746 7
    if (s < sbeg) {
	REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len + 1);
	s = RSTRING(str)->ptr + n;
	memmove(s+1, s, RSTRING(str)->len - n);
	*s = c;
	RSTRING(str)->len += 1;
	
@


1.4.2.15
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:42:31 $
a634 4
        if (pos < 0) {
	    pos += RSTRING(str)->len;
	    if (pos < 0) return Qnil;
        }
@


1.4.2.16
log
@matz - irb (PR#46)
@
text
@d6 1
a6 1
  $Date: 2000/07/24 07:16:15 $
d1969 1
a1969 1
    if (argc < 1) {
@


1.4.2.17
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/25 06:15:18 $
a405 2
	int poffset = -1;

a406 4
	if (RSTRING(str)->ptr <= ptr &&
	    ptr < RSTRING(str)->ptr + RSTRING(str)->len) {
	    poffset = ptr - RSTRING(str)->ptr;
	}
d408 1
a408 2
	if (ptr) {
	    if (poffset >= 0) ptr = RSTRING(str)->ptr + poffset;
a409 1
	}
@


1.3
log
@1.4.1
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:14 $
d1278 1
a1278 1
		return INT2NUM(i);
d1288 1
a1288 1
    return INT2NUM(i);
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/07/28 09:26:49 $
d523 1
a523 1
	    return Qfalse;
d763 1
a763 1
    for (;;) {
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1996/12/25 10:43:01 $
d9 1
a9 1
  Copyright (C) 1993-1996 Yukihiro Matsumoto
a18 1
#include <stdio.h>
d21 7
a27 1
VALUE cString;
d29 1
a29 1
#define STRLEN(s) RSTRING(s)->len
d32 3
a34 3
#define STR_TAINT  FL_USER2
VALUE str_taint();
VALUE str_tainted();
d37 3
a39 3
str_new(ptr, len)
    UCHAR *ptr;
    UINT len;
d42 1
a42 1
    OBJSETUP(str, cString, T_STRING);
d44 1
a44 3
    if (rb_safe_level() >= 3) {
	FL_SET(str, STR_TAINT);
    }
d56 20
a75 2
str_new2(ptr)
    UCHAR *ptr;
d77 4
a80 1
    return str_new(ptr, strlen(ptr));
d84 2
a85 2
str_new3(str)
    struct RString *str;
d88 1
a88 1
    OBJSETUP(str2, cString, T_STRING);
d90 2
a91 2
    str2->len = str->len;
    str2->ptr = str->ptr;
a93 4
    if (rb_safe_level() >= 3) {
	FL_SET(str2, STR_TAINT);
    }

d98 2
a99 2
str_new4(orig)
    struct RString *orig;
d101 5
a105 7
    NEWOBJ(str, struct RString);
    OBJSETUP(str, cString, T_STRING);

    str->len = orig->len;
    str->ptr = orig->ptr;
    if (orig->orig) {
	str->orig = orig->orig;
d108 6
a113 1
	orig->orig = str;
d115 4
d120 1
a120 3
    if (rb_safe_level() >= 3) {
	FL_SET(str, STR_TAINT);
    }
d122 5
a126 1
    return (VALUE)str;
d129 20
a148 1
#define as_str(str) (struct RString*)obj_as_string(str)
d150 1
a150 1
static ID pr_str;
d153 1
a153 1
obj_as_string(obj)
d161 1
a161 1
    str = rb_funcall(obj, pr_str, 0);
d163 2
a164 1
	return any_to_s(obj);
d169 2
a170 2
str_clone(orig)
    struct RString *orig;
d174 2
a175 2
    if (orig->orig)
	str = str_new3(orig->orig);
d177 3
a179 1
	str = str_new(orig->ptr, orig->len);
d185 2
a186 2
str_dup(str)
    struct RString *str;
d188 6
a193 2
    VALUE s = str_new(str->ptr, str->len);
    if (str_tainted(str)) s = str_taint(s);
d198 3
a200 3
str_s_new(class, orig)
    VALUE class;
    struct RString *orig;
d203 1
a203 1
    OBJSETUP(str, class, T_STRING);
d205 7
a211 5
    orig = as_str(orig);
    str->len = orig->len;
    str->ptr = ALLOC_N(char, orig->len+1);
    if (str->ptr) {
	memcpy(str->ptr, orig->ptr, orig->len);
a212 2
    str->ptr[orig->len] = '\0';
    str->orig = 0;
d215 1
a215 1
	FL_SET(str, STR_TAINT);
d222 2
a223 2
str_length(str)
    struct RString *str;
d225 10
a234 1
    return INT2FIX(str->len);
d238 2
a239 2
str_plus(str1, str2)
    struct RString *str1, *str2;
d241 1
a241 1
    struct RString *str3;
d243 10
a252 9
    str2 = as_str(str2);
    str3 = (struct RString*)str_new(0, str1->len+str2->len);
    memcpy(str3->ptr, str1->ptr, str1->len);
    memcpy(str3->ptr+str1->len, str2->ptr, str2->len);
    str3->ptr[str3->len] = '\0';

    if (str_tainted(str1) || str_tainted(str2))
	return str_taint(str3);
    return (VALUE)str3;
d256 2
a257 2
str_times(str, times)
    struct RString *str;
d260 2
a261 2
    struct RString *str2;
    int i, len;
d263 1
a263 1
    len = NUM2INT(times);
d265 1
a265 1
	ArgError("negative argument");
d268 1
a268 1
    str2 = (struct RString*)str_new(0, str->len*len);
d270 2
a271 1
	memcpy(str2->ptr+(i*str->len), str->ptr, str->len);
d273 1
a273 1
    str2->ptr[str2->len] = '\0';
d275 3
a277 2
    if (str_tainted(str))
	return str_taint(str2);
d279 1
a279 1
    return (VALUE)str2;
d282 3
a284 4
VALUE
str_substr(str, start, len)
    struct RString *str;
    int start, len;
d286 1
a286 13
    struct RString *str2;

    if (start < 0) {
	start = str->len + start;
    }
    if (str->len <= start || len < 0) {
	return str_new(0,0);
    }
    if (str->len < start + len) {
	len = str->len - start;
    }

    str2 = (struct RString*)str_new(str->ptr+start, len);
d288 11
a298 1
    return (VALUE)str2;
d301 4
a304 4
static VALUE
str_subseq(str, beg, end)
    struct RString *str;
    int beg, end;
d306 1
a306 5
    int len;

    if ((beg > 0 && end > 0 || beg < 0 && end < 0) && beg > end) {
	IndexError("end smaller than beg [%d..%d]", beg, end);
    }
d308 2
d311 2
a312 2
	beg = str->len + beg;
	if (beg < 0) beg = 0;
d314 2
a315 6
    if (end < 0) {
	end = str->len + end;
	if (end < 0) end = -1;
	else if (str->len < end) {
	    end = str->len;
	}
a316 6

    if (beg >= str->len) {
	return str_new(0, 0);
    }

    len = end - beg + 1;
d320 4
d325 1
a325 1
    return str_substr(str, beg, len);
a327 2
extern VALUE ignorecase;

d329 2
a330 2
str_modify(str)
    struct RString *str;
d332 1
a332 1
    UCHAR *ptr;
a333 4
    if (rb_safe_level() >= 5) {
	extern VALUE eSecurityError;
	Raise(eSecurityError, "cannot change string status");
    }
d335 9
a343 7
	TypeError("can't modify frozen string");
    if (!str->orig) return;
    ptr = str->ptr;
    str->ptr = ALLOC_N(char, str->len+1);
    if (str->ptr) {
	memcpy(str->ptr, ptr, str->len);
	str->ptr[str->len] = 0;
d345 1
a345 1
    str->orig = 0;
d349 1
a349 1
str_freeze(str)
d357 1
a357 1
str_frozen_p(str)
d361 2
a362 2
	return TRUE;
    return FALSE;
d366 1
a366 1
str_dup_freezed(str)
d369 2
a370 11
    str = str_dup(str);
    str_freeze(str);
    return str;
}

VALUE
str_taint(str)
    VALUE str;
{
    if (TYPE(str) == T_STRING) {
	FL_SET(str, STR_TAINT);
d372 3
a374 1
    return str;
d378 1
a378 1
str_tainted(str)
d380 1
d382 1
a382 11
    if (FL_TEST(str, STR_TAINT))
	return TRUE;
    return FALSE;
}

VALUE
str_resize(str, len)
    struct RString *str;
    int len;
{
    str_modify(str);
d385 2
a386 2
	if (str->len < len || str->len - len > 1024) {
	    REALLOC_N(str->ptr, char, len + 1);
d388 2
a389 2
	str->len = len;
	str->ptr[len] = '\0';	/* sentinel */
d391 1
a391 1
    return (VALUE)str;
d395 4
a398 4
str_cat(str, ptr, len)
    struct RString *str;
    UCHAR *ptr;
    UINT len;
d401 2
a402 2
	str_modify(str);
	REALLOC_N(str->ptr, char, str->len + len + 1);
d404 3
a406 3
	    memcpy(str->ptr + str->len, ptr, len);
	str->len += len;
	str->ptr[str->len] = '\0'; /* sentinel */
d408 1
a408 1
    return (VALUE)str;
d411 3
a413 3
static VALUE
str_concat(str1, str2)
    struct RString *str1, *str2;
d415 10
a424 3
    str2 = as_str(str2);
    str_cat(str1, str2->ptr, str2->len);
    return (VALUE)str1;
d428 2
a429 2
str_hash(str)
    struct RString *str;
d431 3
a433 3
    int len = str->len;
    UCHAR *p = str->ptr;
    int key = 0;
d435 1
a435 1
    if (ignorecase) {
d451 1
a451 1
str_hash_method(str)
d454 1
a454 1
    int key = str_hash(str);
d458 1
a458 1
#define min(a,b) (((a)>(b))?(b):(a))
d461 2
a462 2
str_cmp(str1, str2)
    struct RString *str1, *str2;
d464 1
a464 1
    UINT len;
d467 2
a468 2
    if (ignorecase != FALSE) {
	return str_cicmp(str1, str2);
d471 2
a472 2
    len = min(str1->len, str2->len);
    retval = memcmp(str1->ptr, str2->ptr, len);
d474 3
a476 1
	return str1->ptr[len] - str2->ptr[len];
d478 3
a480 1
    return retval;
d484 2
a485 2
str_equal(str1, str2)
    struct RString *str1, *str2;
d488 1
a488 1
	return FALSE;
d490 3
a492 3
    if (str1->len == str2->len
	&& str_cmp(str1, str2) == 0) {
	return TRUE;
d494 1
a494 1
    return FALSE;
d498 1
a498 1
str_cmp_method(str1, str2)
d503 2
a504 2
    str2 = obj_as_string(str2);
    result = str_cmp(str1, str2);
a507 2
VALUE Freg_match();

d509 2
a510 2
str_match(x, y)
    struct RString *x, *y;
d513 1
a513 1
    int start;
d517 1
a517 1
	return reg_match(y, x);
d520 2
a521 2
	reg = reg_regcomp(y);
	start = reg_search(reg, x, 0, 0);
d523 1
a523 1
	    return FALSE;
d525 1
a525 1
	return INT2FIX(start);
d528 1
a528 2
	TypeError("type mismatch");
	break;
d533 2
a534 2
str_match2(str)
    struct RString *str;
d536 1
a536 1
    return reg_match2(reg_regcomp(str));
d539 18
a556 13
static int
str_index(str, sub, offset)
    struct RString *str, *sub;
    int offset;
{
    UCHAR *s, *e, *p;
    int len;

    if (str->len - offset < sub->len) return -1;
    s = str->ptr+offset;
    p = sub->ptr;
    len = sub->len;
    e = s + str->len - len + 1;
d558 2
a559 2
	if (*s == *(sub->ptr) && memcmp(s, p, len) == 0) {
	    return (s-(str->ptr));
d567 1
a567 1
str_index_method(argc, argv, str)
d570 1
a570 1
    struct RString *str;
d572 1
a572 1
    struct RString *sub;
d574 1
a574 1
    int pos;
d577 1
a577 1
	pos = NUM2INT(initpos);
d585 1
a585 1
	pos = reg_search(sub, str, pos, (struct re_registers *)-1);
d589 1
a589 1
	pos = str_index(str, sub, pos);
d592 12
d605 2
a606 1
	TypeError("Type mismatch: %s given", rb_class2name(CLASS_OF(sub)));
d610 1
a610 1
    return INT2FIX(pos);
d614 1
a614 1
str_rindex(argc, argv, str)
d617 1
a617 1
    struct RString *str;
d619 2
a620 2
    struct RString *sub;
    VALUE initpos;
d622 1
a622 1
    UCHAR *s, *sbeg, *t;
d624 3
a626 3
    if (rb_scan_args(argc, argv, "11", &sub, &initpos) == 2) {
	pos = NUM2INT(initpos);
	if (pos >= str->len) pos = str->len;
d629 1
a629 1
	pos = str->len;
d632 28
a659 8
    Check_Type(sub, T_STRING);
    if (pos > str->len) return Qnil; /* substring longer than string */
    sbeg = str->ptr; s = sbeg + pos - sub->len;
    t = sub->ptr;
    len = sub->len;
    while (sbeg <= s) {
	if (*s == *t && memcmp(s, t, len) == 0) {
	    return INT2FIX(s - sbeg);
d661 18
a678 1
	s--;
d683 1
a683 1
static UCHAR
d685 1
a685 1
    UCHAR *s;
d709 2
a710 2
str_succ(orig)
    struct RString *orig;
d712 3
a714 3
    struct RString *str, *str2;
    UCHAR *sbeg, *s;
    char c = -1;
d716 1
a716 1
    str = (struct RString*)str_new(orig->ptr, orig->len);
d718 1
a718 1
    sbeg = str->ptr; s = sbeg + str->len - 1;
d721 1
a721 1
	if (isalnum(*s) && (c = succ_char(s)) == 0) break;
d725 2
a726 2
	if (c == -1 && str->len > 0) {
	    str->ptr[str->len-1] += 1;
d729 3
a731 3
	    str2 = (struct RString*)str_new(0, str->len+1);
	    str2->ptr[0] = c;
	    memcpy(str2->ptr+1, str->ptr, str->len);
d736 13
a748 2
    if (str_tainted(orig))
	return str_taint(str);
d750 1
a750 1
    return (VALUE)str;
d754 1
a754 1
str_upto(beg, end)
d756 1
d760 1
a760 3
    Check_Type(end, T_STRING);
    if (RTEST(rb_funcall(beg, '>', 1, end))) 
	return Qnil;
d765 3
a767 2
	if (str_equal(current, end)) break;
	current = str_succ(current);
d772 8
a779 1
    return Qnil;
d783 2
a784 2
str_aref(str, indx)
    struct RString *str;
d787 1
a787 1
    int idx;
d791 1
a791 1
	idx = FIX2INT(indx);
d794 1
a794 1
	    idx = str->len + idx;
d796 1
a796 1
	if (idx < 0 || str->len <= idx) {
d799 1
a799 1
	return (VALUE)INT2FIX(str->ptr[idx] & 0xff);
d802 2
a803 2
	if (str_match(str, indx))
	    return reg_last_match(0);
d807 1
a807 1
	if (str_index(str, indx, 0) != -1) return indx;
d813 8
a820 3
	    int beg, end;
	    if (range_beg_end(indx, &beg, &end)) {
		return str_subseq(str, beg, end);
d823 1
a823 1
	IndexError("Invalid index for string");
d825 1
d829 1
a829 1
str_aref_method(argc, argv, str)
d832 1
a832 1
    struct RString *str;
d837 1
a837 1
	return str_substr(str, NUM2INT(arg1), NUM2INT(arg2));
d839 1
a839 1
    return str_aref(str, arg1);
d843 4
a846 3
str_replace(str, beg, len, val)
    struct RString *str, *val;
    int beg, len;
d848 1
a848 1
    if (len < val->len) {
d850 1
a850 71
	REALLOC_N(str->ptr, char, str->len+val->len-len+1);
    }

    if (len != val->len) {
	memmove(str->ptr+beg+val->len, str->ptr+beg+len, str->len-(beg+len));
    }
    memcpy(str->ptr+beg, val->ptr, val->len);
    str->len += val->len - len;
    str->ptr[str->len] = '\0';
}

/* str_replace2() understands negatice offset */
static void
str_replace2(str, beg, end, val)
    struct RString *str, *val;
    int beg, end;
{
    int len;

    if ((beg > 0 && end > 0 || beg < 0 && end < 0) && beg > end) {
	IndexError("end smaller than beg [%d..%d]", beg, end);
    }

    if (beg < 0) {
	beg = str->len + beg;
	if (beg < 0) {
	    beg = 0;
	}
    }
    if (str->len <= beg) {
	beg = str->len;
    }
    if (end < 0) {
	end = str->len + end;
	if (end < 0) {
	    end = 0;
	}
    }
    if (str->len <= end) {
	end = str->len - 1;
    }
    len = end - beg + 1;	/* length of substring */
    if (len < 0) {
	len = 0;
    }

    str_replace(str, beg, len, val);
}

static VALUE
str_sub_s(str, pat, val, once)
    struct RString *str;
    struct RRegexp *pat;
    VALUE val;
    int once;
{
    VALUE result, repl;
    int beg, offset, n;
    struct re_registers *regs;

    switch (TYPE(pat)) {
      case T_REGEXP:
	break;

      case T_STRING:
	pat = (struct RRegexp*)reg_regcomp(pat);
	break;

      default:
	/* type failed */
	Check_Type(pat, T_REGEXP);
d853 4
a856 25
    val = obj_as_string(val);
    result = str_new(0,0);
    offset=0; n=0; 
    while ((beg=reg_search(pat, str, offset, 0)) >= 0) {
	n++;

	regs = RMATCH(backref_get())->regs;
	str_cat(result, str->ptr+offset, beg-offset);

	repl = reg_regsub(val, str, regs);
	str_cat(result, RSTRING(repl)->ptr, RSTRING(repl)->len);
	if (END(0) == offset) {
	    /*
	     * Always consume at least one character of the input string
	     * in order to prevent infinite loops.
	     */
	    if (str->len) str_cat(result, str->ptr+END(0), 1);
	    offset = END(0)+1;
	}
	else {
	    offset = END(0);
	}

	if (once) break;
	if (offset >= STRLEN(str)) break;
d858 2
a859 3
    if (n == 0) return Qnil;
    if (str->len > offset) {
	str_cat(result, str->ptr+offset, str->len-offset);
d861 3
a863 3

    if (str_tainted(val)) str_taint(result);
    return result;
d866 1
a866 19
static VALUE
str_sub_f(str, pat, val, once)
    struct RString *str;
    VALUE pat;
    VALUE val;
    int once;
{
    VALUE result;

    str_modify(str);
    result = str_sub_s(str, pat, val, once);

    if (NIL_P(result)) return Qnil;
    str_resize(str, RSTRING(result)->len);
    memcpy(str->ptr, RSTRING(result)->ptr, RSTRING(result)->len);
    if (str_tainted(result)) str_taint(str);

    return (VALUE)str;
}
d869 2
a870 82
str_sub_iter_s(str, pat, once)
    struct RString *str;
    VALUE pat;
    int once;
{
    VALUE val, result;
    int beg, offset, n, null;
    struct re_registers *regs;

    if (!iterator_p()) {
	ArgError("Wrong # of arguments(1 for 2)");
    }

    switch (TYPE(pat)) {
      case T_REGEXP:
	break;

      case T_STRING:
	pat = reg_regcomp(pat);
	break;

      default:
	/* type failed */
	Check_Type(pat, T_REGEXP);
    }

    result = str_new(0,0);
    n = 0; offset = 0;
    while ((beg=reg_search(pat, str, offset, 0)) >= 0) {
	n++;

	null = 0;
	regs = RMATCH(backref_get())->regs;
	str_cat(result, str->ptr+offset, beg-offset);

	if (END(0) == offset) {
	    null = 1;
	    offset = END(0)+1;
	}
	else {
	    offset = END(0);
	}

	val = rb_yield(reg_nth_match(0, backref_get()));
	val = obj_as_string(val);
	str_cat(result, RSTRING(val)->ptr, RSTRING(val)->len);
	if (null && str->len) {
	    str_cat(result, str->ptr+offset-1, 1);
	}

	if (once) break;
	if (offset >= STRLEN(str)) break;
    }
    if (n == 0) return Qnil;
    if (str->len > offset) {
	str_cat(result, str->ptr+offset, str->len-offset);
    }

    return result;
}

static VALUE
str_sub_iter_f(str, pat, once)
    struct RString *str;
    VALUE pat;
    int once;
{
    VALUE result;

    str_modify(str);
    result = str_sub_iter_s(str, pat, once);

    if (NIL_P(result)) return Qnil;
    str_resize(str, RSTRING(result)->len);
    memcpy(str->ptr, RSTRING(result)->ptr, RSTRING(result)->len);

    return (VALUE)str;
}

static VALUE
str_aset(str, indx, val)
    struct RString *str;
d873 2
a874 1
    int idx, beg, end, offset;
d878 1
a878 1
	idx = NUM2INT(indx);
d880 11
a890 1
	    idx = str->len + idx;
d892 3
a894 2
	if (idx < 0 || str->len <= idx) {
	    IndexError("index %d out of range [0..%d]", idx, str->len-1);
a895 1
	str->ptr[idx] = FIX2INT(val) & 0xff;
d899 6
a904 1
	str_sub_f(str, indx, val, 0);
d908 4
a911 5
	for (offset=0;
	     (beg=str_index(str, indx, offset)) >= 0;
	     offset=beg+STRLEN(val)) {
	    end = beg + STRLEN(indx) - 1;
	    str_replace2(str, beg, end, val);
a912 1
	if (offset == 0) return Qnil;
d918 4
a921 3
	    int beg, end;
	    if (range_beg_end(indx, &beg, &end)) {
		str_replace2(str, beg, end, val);
d925 1
a925 1
	IndexError("Invalid index for string");
d930 1
a930 1
str_aset_method(argc, argv, str)
d933 1
a933 1
    struct RString *str;
d937 1
a937 1
    str_modify(str);
d942 1
a942 2
	Check_Type(arg3, T_STRING);

d944 2
d947 1
a947 2
	    beg = str->len + beg;
	    if (beg < 0) beg = 0;
d949 8
a956 4
	len = NUM2INT(arg2);
	if (len < 0) IndexError("negative length %d", len);
	if (beg + len > str->len) {
	    len = str->len - beg;
d958 1
a958 1
	str_replace(str, beg, len, arg3);
d961 1
a961 1
    return str_aset(str, arg1, arg2);
d965 2
a966 4
str_sub_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
d968 3
a970 1
    VALUE pat, val;
d972 7
a978 2
    if (rb_scan_args(argc, argv, "11", &pat, &val) == 1) {
	return str_sub_iter_f(str, pat, 1);
d980 1
a980 1
    return str_sub_f(str, pat, val, 1);
d984 1
a984 1
str_sub(argc, argv, str)
d989 4
a992 1
    VALUE pat, val, v;
d994 5
a998 2
    if (rb_scan_args(argc, argv, "11", &pat, &val) == 1) {
	v = str_sub_iter_s(str, pat, 1);
d1001 33
a1033 1
	v = str_sub_s(str, pat, val, 1);
d1035 1
a1035 2
    if (NIL_P(v)) return str;
    return v;
d1039 1
a1039 1
str_gsub_bang(argc, argv, str)
d1044 1
a1044 1
    VALUE pat, val;
d1046 2
a1047 4
    if (rb_scan_args(argc, argv, "11", &pat, &val) == 1) {
	return str_sub_iter_f(str, pat, 0);
    }
    return str_sub_f(str, pat, val, 0);
d1051 1
a1051 1
str_gsub(argc, argv, str)
d1056 6
a1061 1
    VALUE pat, val, v;
d1063 5
a1067 2
    if (rb_scan_args(argc, argv, "11", &pat, &val) == 1) {
	v =  str_sub_iter_s(str, pat, 0);
d1070 1
a1070 1
	v = str_sub_s(str, pat, val, 0);
d1072 96
a1167 2
    if (NIL_P(v)) return str;
    return v;    
d1175 1
a1175 1
    line = lastline_get();
d1177 2
a1178 1
	TypeError("$_ value need to be String");
d1184 1
a1184 1
f_sub_bang(argc, argv)
d1188 1
a1188 7
    VALUE pat, val, line;

    line = uscore_get();
    if (rb_scan_args(argc, argv, "11", &pat, &val) == 1) {
	return str_sub_iter_f(line, pat, 1);
    }
    return str_sub_f(line, pat, val, 1);
d1192 1
a1192 1
f_sub(argc, argv)
d1196 1
a1196 1
    VALUE pat, val, line, v;
d1199 4
a1202 11
    if (rb_scan_args(argc, argv, "11", &pat, &val) == 1) {
	v = str_sub_iter_s(line, pat, 1);
    }
    else {
	v = str_sub_s(line, pat, val, 1);
    }
    if (!NIL_P(v)) {
	lastline_set(v);
	return v;
    }
    return line;
d1206 1
a1206 1
f_gsub_bang(argc, argv)
d1210 1
a1210 7
    VALUE pat, val, line;

    line = uscore_get();
    if (rb_scan_args(argc, argv, "11", &pat, &val) == 1) {
	return str_sub_iter_f(line, pat, 0);
    }
    return str_sub_f(line, pat, val, 0);
d1214 1
a1214 1
f_gsub(argc, argv)
d1218 1
a1218 1
    VALUE pat, val, line, v;
d1221 4
a1224 11
    if (rb_scan_args(argc, argv, "11", &pat, &val) == 1) {
	v = str_sub_iter_s(line, pat, 0);
    }
    else {
	v = str_sub_s(line, pat, val, 0);
    }
    if (!NIL_P(v)) {
	lastline_set(v);
	return v;
    }
    return line;
d1228 2
a1229 2
str_reverse_bang(str)
    struct RString *str;
d1231 1
a1231 1
    UCHAR *s, *e, *p;
d1233 3
a1235 3
    s = str->ptr;
    e = s + str->len - 1;
    p = ALLOCA_N(char, str->len);
d1240 1
a1240 1
    MEMCPY(str->ptr, p, char, str->len);
d1242 1
a1242 1
    return (VALUE)str;
d1246 2
a1247 2
str_reverse(str)
    struct RString *str;
d1249 4
a1252 2
    VALUE obj = str_new(0, str->len);
    UCHAR *s, *e, *p;
d1254 2
a1255 1
    s = str->ptr; e = s + str->len - 1;
d1266 2
a1267 2
str_to_i(str)
    struct RString *str;
d1269 20
a1288 1
    return str2inum(str->ptr, 10);
d1291 6
a1296 3
#ifndef atof
double atof();
#endif
d1299 2
a1300 2
str_to_f(str)
    struct RString *str;
d1302 1
a1302 1
    double f = atof(str->ptr);
d1304 1
a1304 1
    return float_new(f);
d1308 1
a1308 1
str_to_s(str)
d1315 2
a1316 2
str_inspect(str)
    struct RString *str;
d1319 3
a1321 3
    UCHAR buf[STRMAX];
    UCHAR *p, *pend;
    UCHAR *b;
d1323 1
a1323 1
    p = str->ptr; pend = p + str->len;
d1336 1
a1336 1
	UCHAR c = *p++;
d1338 11
a1348 1
	    CHECK(2);
a1349 1
	    *b++ = *p++;
d1351 2
a1352 1
	else if (c == '"') {
d1355 1
a1355 6
	    *b++ = '"';
	}
	else if (c == '\\') {
	    CHECK(2);
	    *b++ = '\\';
	    *b++ = '\\';
d1357 1
a1357 1
	else if (isprint(c)) {
d1381 1
a1381 1
	else if (c == '\13') {
d1399 1
a1399 1
	    sprintf(b, "%03o", c);
d1404 91
a1494 1
    return str_new(buf, b - buf);
d1498 2
a1499 2
str_upcase_bang(str)
    struct RString *str;
d1501 2
a1502 1
    UCHAR *s, *send;
d1504 2
a1505 2
    str_modify(str);
    s = str->ptr; send = s + str->len;
d1507 4
a1510 1
	if (islower(*s)) {
d1512 1
d1517 2
a1518 1
    return (VALUE)str;
d1522 2
a1523 2
str_upcase(str)
    struct RString *str;
d1525 4
a1528 1
    return str_upcase_bang(str_dup(str));
d1532 2
a1533 2
str_downcase_bang(str)
    struct RString *str;
d1535 2
a1536 1
    UCHAR *s, *send;
d1538 2
a1539 2
    str_modify(str);
    s = str->ptr; send = s + str->len;
d1541 4
a1544 1
	if (isupper(*s)) {
d1546 1
d1551 2
a1552 1
    return (VALUE)str;
d1556 2
a1557 2
str_downcase(str)
    struct RString *str;
d1559 4
a1562 1
    return str_downcase_bang(str_dup(str));
d1566 2
a1567 2
str_capitalize_bang(str)
    struct RString *str;
d1569 2
a1570 1
    UCHAR *s, *send;
d1572 3
a1574 3
    str_modify(str);
    s = str->ptr; send = s + str->len;
    if (islower(*s))
d1576 2
d1579 4
a1582 1
	if (isupper(*s)) {
d1584 1
d1587 2
a1588 1
    return (VALUE)str;
d1592 2
a1593 2
str_capitalize(str)
    struct RString *str;
d1595 4
a1598 1
    return str_capitalize_bang(str_dup(str));
d1602 2
a1603 2
str_swapcase_bang(str)
    struct RString *str;
d1605 2
a1606 1
    UCHAR *s, *send;
d1608 2
a1609 2
    str_modify(str);
    s = str->ptr; send = s + str->len;
d1611 4
a1614 1
	if (isupper(*s)) {
d1616 1
d1618 1
a1618 1
	else if (islower(*s)) {
d1620 1
d1625 2
a1626 1
    return (VALUE)str;
d1630 2
a1631 2
str_swapcase(str)
    struct RString *str;
d1633 4
a1636 1
    return str_swapcase_bang(str_dup(str));
d1639 1
a1639 1
typedef UCHAR *USTR;
d1641 1
a1641 1
static struct tr {
d1643 2
a1644 2
    UCHAR *p, *pend;
} trsrc, trrepl;
d1653 1
a1653 1
	    t->now = *t->p++;
d1677 1
a1677 1
static VALUE str_delete_bang();
d1681 1
a1681 1
    struct RString *str, *src, *repl;
d1686 8
a1693 7
    UCHAR trans[256];
    int i, c, c0;
    UCHAR *s, *send, *t;

    Check_Type(src, T_STRING);
    trsrc.p = src->ptr; trsrc.pend = trsrc.p + src->len;
    if (src->len > 2 && src->ptr[0] == '^') {
d1697 6
a1702 3
    Check_Type(repl, T_STRING);
    if (repl->len == 0) return str_delete_bang(str, src);
    trrepl.p = repl->ptr; trrepl.pend = trrepl.p + repl->len;
d1712 1
a1712 1
	    trans[c & 0xff] = 0;
d1714 2
d1717 2
a1718 11
	    if (trans[i] == 0) {
		trans[i] = i;
	    }
	    else {
		c = trnext(&trrepl);
		if (c == -1) {
		    trans[i] = trrepl.now;
		}
		else {
		    trans[i] = c;
		}
d1723 1
a1723 1
	char r;
d1726 1
a1726 1
	    trans[i] = i;
d1735 1
a1735 3
    str_modify(str);
    t = s = str->ptr; send = s + str->len;
    c0 = -1;
d1737 3
d1741 10
a1750 4
	    c = trans[*s++ & 0xff] & 0xff;
	    if (s[-1] == c || c != c0) {
		c0 = (s[-1] == c)?-1:c;
		*t++ = c;
d1753 5
d1761 5
a1765 2
	    c = trans[*s++ & 0xff] & 0xff;
	    *t++ = c;
a1767 2
    *t = '\0';
    if (sflag) str->len = (t - str->ptr);
d1769 2
a1770 1
    return (VALUE)str;
d1774 1
a1774 1
str_tr_bang(str, src, repl)
d1781 1
a1781 1
str_tr(str, src, repl)
d1784 4
a1787 1
    return tr_trans(str_dup(str), src, repl, 0);
d1791 4
a1794 3
tr_setup_table(str, table)
    struct RString *str;
    UCHAR table[256];
d1796 1
d1798 2
a1799 2
    int i, cflag = 0;
    int c;
d1801 1
a1801 1
    tr.p = str->ptr; tr.pend = tr.p + str->len;
d1803 2
a1804 2
    if (str->len > 1 && str->ptr[0] == '^') {
	cflag++;
d1808 7
a1814 2
    for  (i=0; i<256; i++) {
	table[i] = cflag ? 1 : 0;
d1817 4
a1820 1
	table[c & 0xff] = cflag ? 0 : 1;
d1825 4
a1828 2
str_delete_bang(str1, str2)
    struct RString *str1, *str2;
d1830 5
a1834 2
    UCHAR *s, *send, *t;
    UCHAR squeez[256];
d1836 2
a1837 2
    Check_Type(str2, T_STRING);
    tr_setup_table(str2, squeez);
d1839 5
a1843 1
    str_modify(str1);
d1845 3
a1847 2
    s = t = str1->ptr;
    send = s + str1->len;
d1849 3
a1851 1
	if (!squeez[*s & 0xff]) {
a1852 1
	}
d1856 1
a1856 1
    str1->len = t - str1->ptr;
d1858 2
a1859 1
    return (VALUE)str1;
d1863 4
a1866 2
str_delete(str1, str2)
    struct RString *str1, *str2;
d1868 4
a1871 1
    return str_delete_bang(str_dup(str1), str2);
d1875 4
a1878 2
tr_squeeze(str1, str2)
    struct RString *str1, *str2;
d1880 5
a1884 3
    UCHAR squeez[256];
    UCHAR *s, *send, *t;
    char c, save;
d1886 4
a1889 2
    if (!NIL_P(str2)) {
	tr_setup_table(str2, squeez);
d1892 2
a1893 1
	int i;
d1895 4
a1898 2
	for (i=0; i<256; i++) {
	    squeez[i] = 1;
d1902 1
a1902 1
    str_modify(str1);
d1904 2
a1905 2
    s = t = str1->ptr;
    send = s + str1->len;
d1909 1
a1909 1
	if (c != save || !squeez[c & 0xff]) {
d1914 4
a1917 1
    str1->len = t - str1->ptr;
d1919 2
a1920 1
    return (VALUE)str1;
d1924 1
a1924 1
str_squeeze_bang(argc, argv, str1)
d1927 1
a1927 1
    VALUE str1;
d1929 1
a1929 1
    VALUE str2;
d1931 2
a1932 5
    rb_scan_args(argc, argv, "01", &str2);
    if (!NIL_P(str2)) {
	Check_Type(str2, T_STRING);
    }
    return tr_squeeze(str1, str2);
d1936 2
a1937 4
str_squeeze(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
d1939 1
a1939 1
    return str_squeeze_bang(argc, argv, str_dup(str));
d1943 1
a1943 1
str_tr_s_bang(str, src, repl)
d1946 1
a1946 2
    Check_Type(src, T_STRING);
    Check_Type(repl, T_STRING);
d1948 2
a1949 1
    return tr_trans(str, src, repl, 1);
d1953 4
a1956 2
str_tr_s(str, src, repl)
    VALUE str, src, repl;
d1958 26
a1983 1
    return str_tr_s_bang(str_dup(str), src, repl);
d1987 1
a1987 1
str_split_method(argc, argv, str)
d1990 1
a1990 1
    struct RString *str;
d1992 1
a1992 2
    extern VALUE FS;
    struct RRegexp *spat;
d1994 3
a1996 2
    char char_sep = 0;
    int beg, end, lim, i;
d1999 1
a1999 2
    rb_scan_args(argc, argv, "02", &spat, &limit);
    if (!NIL_P(limit)) {
d2001 2
a2002 2
	if (lim == 0) limit = Qnil;
	else if (lim == 1) return ary_new3(1, str);
d2006 3
a2008 3
    if (NIL_P(spat)) {
	if (!NIL_P(FS)) {
	    spat = (struct RRegexp*)FS;
d2017 2
a2018 2
	    if (STRLEN(spat) == 1) {
		char_sep = RSTRING(spat)->ptr[0];
d2021 1
a2021 1
		spat = (struct RRegexp*)reg_regcomp(spat);
d2027 1
a2027 1
	    ArgError("split(): bad separator");
d2031 1
a2031 1
    result = ary_new();
d2033 4
a2036 4
    if (char_sep != 0) {
	UCHAR *ptr = str->ptr;
	int len = str->len;
	UCHAR *eptr = ptr + len;
d2043 1
a2043 1
		    if (isspace(*ptr)) {
d2052 2
a2053 2
		    if (isspace(*ptr)) {
			ary_push(result, str_substr(str, beg, end-beg));
d2066 2
a2067 2
		if (*ptr == char_sep) {
		    ary_push(result, str_substr(str, beg, end-beg));
d2081 2
a2082 2
	while ((end = reg_search(spat, str, start, 0)) >= 0) {
	    regs = RMATCH(backref_get())->regs;
d2085 1
a2085 4
		    if (ismbchar(str->ptr[beg]))
			ary_push(result, str_substr(str, beg, 2));
		    else
			ary_push(result, str_substr(str, beg, 1));
d2089 1
a2089 1
		    start += ismbchar(str->ptr[start])?2:1;
d2095 1
a2095 1
		ary_push(result, str_substr(str, beg, end-beg));
d2103 1
a2103 1
		    tmp = str_new(0, 0);
d2105 2
a2106 2
		    tmp = str_subseq(str, BEG(idx), END(idx)-1);
		ary_push(result, tmp);
d2111 7
a2117 2
    if (str->len > beg) {
	ary_push(result, str_subseq(str, beg, -1));
d2124 3
a2126 3
str_split(str, sep0)
    struct RString* str;
    char *sep0;
d2130 3
a2132 3
    Check_Type(str, T_STRING);
    sep = str_new2(sep0);
    return str_split_method(1, &sep, str);
d2136 1
a2136 1
f_split(argc, argv)
d2140 1
a2140 1
    return str_split_method(argc, argv, uscore_get());
d2144 1
a2144 1
str_each_line(argc, argv, str)
d2147 1
a2147 1
    struct RString* str;
a2148 1
    extern VALUE RS;
d2152 3
a2154 3
    UCHAR *p = str->ptr, *pend = p + str->len, *s;
    UCHAR *ptr = p;
    int len = str->len;
d2157 2
a2158 5
    if (rb_scan_args(argc, argv, "01", &rs) == 1) {
	if (!NIL_P(rs)) Check_Type(rs, T_STRING);
    }
    else {
	rs = RS;
d2163 4
a2166 1
	return Qnil;
d2179 1
a2179 1
	    if (*(p+1) != '\n') continue;
a2180 1
	    p--;
d2182 1
a2182 1
	if (*p == newline &&
d2184 2
a2185 3
	     memcmp(RSTRING(rs)->ptr, p-rslen+1, rslen) == 0)) {
	    line = str_new(s, p - s + 1);
	    lastline_set(line);
d2187 3
a2189 3
	    if (str->ptr != ptr || str->len != len)
		Fail("string modified");
	    s = p + 1;
d2194 2
a2195 2
	line = str_new(s, p - s);
	lastline_set(line);
d2199 1
a2199 1
    return Qnil;
d2203 2
a2204 2
str_each_byte(str)
    struct RString* str;
d2208 21
a2228 2
    for (i=0; i<str->len; i++) {
	rb_yield(INT2FIX(str->ptr[i] & 0xff));
d2234 32
a2265 2
str_chop_bang(str)
    struct RString *str;
d2267 10
a2276 1
    str_modify(str);
d2278 10
a2287 6
    if (str->len > 0) {
	str->len--;
	if (str->ptr[str->len] == '\n') {
	    if (str->len > 0 && str->ptr[str->len-1] == '\r') {
		str->len--;
	    }
d2289 1
a2289 1
	str->ptr[str->len] = '\0';
d2291 2
d2294 8
a2301 1
    return (VALUE)str;
d2305 4
a2308 2
str_chop(str)
    struct RString *str;
d2310 4
a2313 1
    return str_chop_bang(str_dup(str));
d2317 3
a2319 2
f_chop_bang(str)
    struct RString *str;
d2321 1
a2321 1
    return str_chop_bang(uscore_get());
d2325 3
a2327 1
f_chop()
d2329 6
a2334 1
    return str_chop_bang(str_dup(uscore_get()));
d2338 2
a2339 2
str_strip_bang(str)
    struct RString *str;
d2341 1
a2341 3
    UCHAR *s, *t, *e;

    str_modify(str);
d2343 3
a2345 2
    s = str->ptr;
    e = t = s + str->len;
d2347 1
a2347 1
    while (s < t && isspace(*s)) s++;
d2351 1
a2351 1
    while (s <= t && isspace(*t)) t--;
d2354 7
a2360 7
    str->len = t-s;
    if (s > str->ptr) { 
	UCHAR *p = str->ptr;

	str->ptr = ALLOC_N(char, str->len+1);
	memcpy(str->ptr, s, str->len);
	str->ptr[str->len] = '\0';
d2364 1
a2364 1
	str->ptr[str->len] = '\0';
d2366 12
d2379 2
a2380 1
    return (VALUE)str;
d2385 2
a2386 3
    struct RString *str;
    struct RRegexp *pat;
    int *start;
d2388 1
a2388 1
    VALUE result;
d2390 1
a2390 1
    int idx;
d2392 8
a2399 16
    if (reg_search(pat, str, *start, 0) >= 0) {
	regs = RMATCH(backref_get())->regs;
	result = ary_new2(regs->num_regs);
	for (idx=1; idx < regs->num_regs; idx++) {
	    if (BEG(idx) == -1) {
		ary_push(result, Qnil);
	    }
	    else if (BEG(idx) == END(idx)) {
		ary_push(result, str_new(0, 0));
	    }
	    else {
		ary_push(result, str_subseq(str, BEG(idx), END(idx)-1));
	    }
	}
	if (END(0) == *start) {
	    *start = END(0)+1;
d2404 7
d2418 2
a2419 3
str_scan(str, pat)
    struct RString *str;
    struct RRegexp *pat;
d2422 1
a2422 1
    int start = 0;
d2424 3
a2426 9
    switch (TYPE(pat)) {
      case T_STRING:
	pat = (struct RRegexp*)reg_regcomp(pat);
	break;
      case T_REGEXP:
	break;
      default:
	Check_Type(pat, T_REGEXP);
    }
d2428 4
a2431 2
    if (!iterator_p()) {
	return scan_once(str, pat, &start);
d2437 1
a2437 1
    return Qnil;
d2441 2
a2442 2
str_strip(str)
    struct RString *str;
d2444 1
a2444 1
    return str_strip_bang(str_dup(str));
d2448 2
a2449 2
str_hex(str)
    struct RString *str;
d2451 15
a2465 1
    return str2inum(str->ptr, 16);
d2469 2
a2470 2
str_oct(str)
    struct RString *str;
d2472 1
a2472 2
    return str2inum(str->ptr, 8);
}
d2474 4
a2477 8
static VALUE
str_crypt(str, salt)
    struct RString *str, *salt;
{
    salt = as_str(salt);
    if (salt->len < 2)
	ArgError("salt too short(need >2 bytes)");
    return str_new2(crypt(str->ptr, salt->ptr));
d2481 2
a2482 2
str_intern(str)
    struct RString *str;
d2486 3
a2488 3
    if (strlen(str->ptr) != str->len)
	ArgError("string contains `\0'");
    id = rb_intern(str->ptr);
d2493 1
a2493 1
str_sum(argc, argv, str)
d2496 1
a2496 1
    struct RString *str;
d2500 1
a2500 1
    UCHAR *p, *pend;
d2502 3
a2504 2
    rb_scan_args(argc, argv, "01", &vbits);
    if (NIL_P(vbits)) bits = 16;
d2507 2
a2508 2
    p = str->ptr; pend = p + str->len;
    if (bits > 32) {
d2516 1
a2516 2
	    res = rb_funcall(res, '+', 1, INT2FIX((UINT)*p));
	    res = rb_funcall(res, '%', 1, mod);
d2519 1
d2523 2
a2524 2
	UINT res = 0;
	UINT mod = (1<<bits)-1;
d2526 3
d2530 1
a2530 2
	    res += (UINT)*p;
	    res %= mod;
d2533 2
a2534 1
	return int2inum(res);
d2539 2
a2540 2
str_ljust(str, w)
    struct RString *str;
d2543 8
a2550 8
    int width = NUM2INT(w);
    struct RString *res;
    UCHAR *p, *pend;

    if (str->len >= width) return (VALUE)str;
    res = (struct RString*)str_new(0, width);
    memcpy(res->ptr, str->ptr, str->len);
    p = res->ptr + str->len; pend = res->ptr + width;
d2554 1
a2554 1
    return (VALUE)res;
d2558 2
a2559 2
str_rjust(str, w)
    struct RString *str;
d2562 7
a2568 7
    int width = NUM2INT(w);
    struct RString *res;
    UCHAR *p, *pend;

    if (str->len >= width) return (VALUE)str;
    res = (struct RString*)str_new(0, width);
    p = res->ptr; pend = p + width - str->len;
d2572 2
a2573 2
    memcpy(pend, str->ptr, str->len);
    return (VALUE)res;
d2577 2
a2578 2
str_center(str, w)
    struct RString *str;
d2581 9
a2589 9
    int width = NUM2INT(w);
    struct RString *res;
    UCHAR *p, *pend;
    int n;

    if (str->len >= width) return (VALUE)str;
    res = (struct RString*)str_new(0, width);
    n = (width - str->len)/2;
    p = res->ptr; pend = p + n;
d2593 2
a2594 2
    memcpy(pend, str->ptr, str->len);
    p = pend + str->len; pend = res->ptr + width;
d2598 1
a2598 1
    return (VALUE)res;
a2600 4
extern VALUE mKernel;
extern VALUE mComparable;
extern VALUE mEnumerable;

d2604 105
a2708 92
    cString  = rb_define_class("String", cObject);
    rb_include_module(cString, mComparable);
    rb_include_module(cString, mEnumerable);
    rb_define_singleton_method(cString, "new", str_s_new, 1);
    rb_define_method(cString, "clone", str_clone, 0);
    rb_define_method(cString, "dup", str_dup, 0);
    rb_define_method(cString, "<=>", str_cmp_method, 1);
    rb_define_method(cString, "==", str_equal, 1);
    rb_define_method(cString, "===", str_equal, 1);
    rb_define_method(cString, "eql?", str_equal, 1);
    rb_define_method(cString, "hash", str_hash_method, 0);
    rb_define_method(cString, "+", str_plus, 1);
    rb_define_method(cString, "*", str_times, 1);
    rb_define_method(cString, "[]", str_aref_method, -1);
    rb_define_method(cString, "[]=", str_aset_method, -1);
    rb_define_method(cString, "length", str_length, 0);
    rb_define_alias(cString,  "size", "length");
    rb_define_method(cString, "=~", str_match, 1);
    rb_define_method(cString, "~", str_match2, 0);
    rb_define_method(cString, "succ", str_succ, 0);
    rb_define_method(cString, "upto", str_upto, 1);
    rb_define_method(cString, "index", str_index_method, -1);
    rb_define_method(cString, "rindex", str_rindex, -1);

    rb_define_method(cString, "freeze", str_freeze, 0);
    rb_define_method(cString, "frozen?", str_frozen_p, 0);

    rb_define_method(cString, "taint", str_taint, 0);
    rb_define_method(cString, "tainted?", str_tainted, 0);

    rb_define_method(cString, "to_i", str_to_i, 0);
    rb_define_method(cString, "to_f", str_to_f, 0);
    rb_define_method(cString, "to_s", str_to_s, 0);
    rb_define_method(cString, "inspect", str_inspect, 0);

    rb_define_method(cString, "upcase", str_upcase, 0);
    rb_define_method(cString, "downcase", str_downcase, 0);
    rb_define_method(cString, "capitalize", str_capitalize, 0);
    rb_define_method(cString, "swapcase", str_swapcase, 0);

    rb_define_method(cString, "upcase!", str_upcase_bang, 0);
    rb_define_method(cString, "downcase!", str_downcase_bang, 0);
    rb_define_method(cString, "capitalize!", str_capitalize_bang, 0);
    rb_define_method(cString, "swapcase!", str_swapcase_bang, 0);

    rb_define_method(cString, "hex", str_hex, 0);
    rb_define_method(cString, "oct", str_oct, 0);
    rb_define_method(cString, "split", str_split_method, -1);
    rb_define_method(cString, "reverse", str_reverse, 0);
    rb_define_method(cString, "reverse!", str_reverse_bang, 0);
    rb_define_method(cString, "concat", str_concat, 1);
    rb_define_method(cString, "<<", str_concat, 1);
    rb_define_method(cString, "crypt", str_crypt, 1);
    rb_define_method(cString, "intern", str_intern, 0);

    rb_define_method(cString, "scan", str_scan, 1);

    rb_define_method(cString, "ljust", str_ljust, 1);
    rb_define_method(cString, "rjust", str_rjust, 1);
    rb_define_method(cString, "center", str_center, 1);

    rb_define_method(cString, "sub", str_sub, -1);
    rb_define_method(cString, "gsub", str_gsub, -1);
    rb_define_method(cString, "chop", str_chop, 0);
    rb_define_method(cString, "strip", str_strip, 0);

    rb_define_method(cString, "sub!", str_sub_bang, -1);
    rb_define_method(cString, "gsub!", str_gsub_bang, -1);
    rb_define_method(cString, "strip!", str_strip_bang, 0);
    rb_define_method(cString, "chop!", str_chop_bang, 0);

    rb_define_method(cString, "tr", str_tr, 2);
    rb_define_method(cString, "tr_s", str_tr_s, 2);
    rb_define_method(cString, "delete", str_delete, 1);
    rb_define_method(cString, "squeeze", str_squeeze, -1);

    rb_define_method(cString, "tr!", str_tr_bang, 2);
    rb_define_method(cString, "tr_s!", str_tr_s_bang, 2);
    rb_define_method(cString, "delete!", str_delete_bang, 1);
    rb_define_method(cString, "squeeze!", str_squeeze_bang, -1);

    rb_define_method(cString, "each_line", str_each_line, -1);
    rb_define_method(cString, "each", str_each_line, -1);
    rb_define_method(cString, "each_byte", str_each_byte, 0);

    rb_define_method(cString, "sum", str_sum, -1);

    rb_define_global_function("sub", f_sub, -1);
    rb_define_global_function("gsub", f_gsub, -1);

    rb_define_global_function("sub!", f_sub_bang, -1);
    rb_define_global_function("gsub!", f_gsub_bang, -1);
d2710 2
a2711 2
    rb_define_global_function("chop", f_chop, 0);
    rb_define_global_function("chop!", f_chop_bang, 0);
d2713 1
a2713 1
    rb_define_global_function("split", f_split, -1);
d2715 1
a2715 1
    pr_str = rb_intern("to_s");
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@a20 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
d28 2
a29 2
void reg_prepare_re _((VALUE));
void kcode_reset_option _((void));
d61 1
a61 1
    VALUE str;
d66 2
a67 2
    str2->len = RSTRING(str)->len;
    str2->ptr = RSTRING(str)->ptr;
d79 1
a79 1
    VALUE orig;
d84 4
a87 4
    str->len = RSTRING(orig)->len;
    str->ptr = RSTRING(orig)->ptr;
    if (RSTRING(orig)->orig) {
	str->orig = RSTRING(orig)->orig;
d90 1
a90 1
	RSTRING(orig)->orig = (VALUE)str;
d100 2
d121 1
a121 1
    VALUE orig;
d125 2
a126 2
    if (RSTRING(orig)->orig)
	str = str_new3(RSTRING(orig)->orig);
d128 1
a128 1
	str = str_new(RSTRING(orig)->ptr, RSTRING(orig)->len);
d135 1
a135 1
    VALUE str;
d137 1
a137 1
    VALUE s = str_new(RSTRING(str)->ptr, RSTRING(str)->len);
d145 1
a145 1
    VALUE orig;
d150 3
a152 3
    orig = obj_as_string(orig);
    str->len = RSTRING(orig)->len;
    str->ptr = ALLOC_N(char, RSTRING(orig)->len+1);
d154 1
a154 1
	memcpy(str->ptr, RSTRING(orig)->ptr, RSTRING(orig)->len);
d156 1
a156 1
    str->ptr[RSTRING(orig)->len] = '\0';
d168 1
a168 1
    VALUE str;
d170 1
a170 1
    return INT2FIX(RSTRING(str)->len);
d175 1
a175 1
    VALUE str1, str2;
d177 1
a177 1
    VALUE str3;
d179 5
a183 5
    str2 = obj_as_string(str2);
    str3 = str_new(0, RSTRING(str1)->len+RSTRING(str2)->len);
    memcpy(RSTRING(str3)->ptr, RSTRING(str1)->ptr, RSTRING(str1)->len);
    memcpy(RSTRING(str3)->ptr+RSTRING(str1)->len, RSTRING(str2)->ptr, RSTRING(str2)->len);
    RSTRING(str3)->ptr[RSTRING(str3)->len] = '\0';
d192 1
a192 1
    VALUE str;
d195 1
a195 1
    VALUE str2;
d203 1
a203 1
    str2 = str_new(0, RSTRING(str)->len*len);
d205 1
a205 6
	memcpy(RSTRING(str2)->ptr+(i*RSTRING(str)->len), RSTRING(str)->ptr, RSTRING(str)->len);
    }
    RSTRING(str2)->ptr[RSTRING(str2)->len] = '\0';

    if (str_tainted(str)) {
	return str_taint((VALUE)str2);
d207 1
d209 2
a210 2
    return str2;
}
d212 1
a212 17
VALUE
str_format(str, arg)
    VALUE str, arg;
{
    VALUE *argv;

    if (TYPE(arg) == T_ARRAY) {
	argv = ALLOCA_N(VALUE, RARRAY(arg)->len + 1);
	argv[0] = str;
	MEMCPY(argv+1, RARRAY(arg)->ptr, VALUE, RARRAY(arg)->len);
	return f_sprintf(RARRAY(arg)->len+1, argv);
    }
    
    argv = ALLOCA_N(VALUE, 2);
    argv[0] = str;
    argv[1] = arg;
    return f_sprintf(2, argv);
d217 1
a217 1
    VALUE str;
d223 1
a223 1
	start = RSTRING(str)->len + start;
d225 1
a225 1
    if (RSTRING(str)->len <= start || len < 0) {
d228 2
a229 2
    if (RSTRING(str)->len < start + len) {
	len = RSTRING(str)->len - start;
d232 3
a234 1
    return str_new(RSTRING(str)->ptr+start, len);
d239 1
a239 1
    VALUE str;
d249 1
a249 1
	beg = RSTRING(str)->len + beg;
d253 1
a253 1
	end = RSTRING(str)->len + end;
d255 2
a256 2
	else if (RSTRING(str)->len < end) {
	    end = RSTRING(str)->len;
d260 1
a260 1
    if (beg >= RSTRING(str)->len) {
d276 1
a276 1
    VALUE str;
d286 6
a291 6
    if (!RSTRING(str)->orig) return;
    ptr = RSTRING(str)->ptr;
    RSTRING(str)->ptr = ALLOC_N(char, RSTRING(str)->len+1);
    if (RSTRING(str)->ptr) {
	memcpy(RSTRING(str)->ptr, ptr, RSTRING(str)->len);
	RSTRING(str)->ptr[RSTRING(str)->len] = 0;
d293 1
a293 1
    RSTRING(str)->orig = 0;
d343 1
a343 1
    VALUE str;
d349 2
a350 2
	if (RSTRING(str)->len < len || RSTRING(str)->len - len > 1024) {
	    REALLOC_N(RSTRING(str)->ptr, char, len + 1);
d352 2
a353 2
	RSTRING(str)->len = len;
	RSTRING(str)->ptr[len] = '\0';	/* sentinel */
d360 1
a360 1
    VALUE str;
d366 1
a366 1
	REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len + len + 1);
d368 3
a370 3
	    memcpy(RSTRING(str)->ptr + RSTRING(str)->len, ptr, len);
	RSTRING(str)->len += len;
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0'; /* sentinel */
d372 1
a372 1
    return str;
d377 1
a377 1
    VALUE str1, str2;
d379 3
a381 3
    str2 = obj_as_string(str2);
    str_cat(str1, RSTRING(str2)->ptr, RSTRING(str2)->len);
    return str1;
d386 1
a386 1
    VALUE str;
d388 3
a390 3
    register int len = RSTRING(str)->len;
    register UCHAR *p = RSTRING(str)->ptr;
    register int key = 0;
d392 1
a392 1
    if (RTEST(ignorecase)) {
d419 1
a419 1
    VALUE str1, str2;
d424 1
a424 1
    if (RTEST(ignorecase)) {
d428 2
a429 2
    len = min(RSTRING(str1)->len, RSTRING(str2)->len);
    retval = memcmp(RSTRING(str1)->ptr, RSTRING(str2)->ptr, len);
d431 1
a431 1
	return RSTRING(str1)->ptr[len] - RSTRING(str2)->ptr[len];
d438 1
a438 1
    VALUE str1, str2;
d443 1
a443 1
    if (RSTRING(str1)->len == RSTRING(str2)->len
d461 2
d465 1
a465 1
    VALUE x, y;
d483 2
a484 1
	return rb_funcall(y, rb_intern("=~"), 1, x);
d490 1
a490 1
    VALUE str;
d497 1
a497 1
    VALUE str, sub;
d503 5
a507 5
    if (RSTRING(str)->len - offset < RSTRING(sub)->len) return -1;
    s = RSTRING(str)->ptr+offset;
    p = RSTRING(sub)->ptr;
    len = RSTRING(sub)->len;
    e = s + RSTRING(str)->len - len + 1;
d509 2
a510 2
	if (*s == *(RSTRING(sub)->ptr) && memcmp(s, p, len) == 0) {
	    return (s-(RSTRING(str)->ptr));
d521 1
a521 1
    VALUE str;
d523 1
a523 1
    VALUE sub;
a542 12
      case T_FIXNUM:
      {
	  int c = FIX2INT(sub);
	  int len = RSTRING(str)->len;
	  char *p = RSTRING(str)->ptr;

	  for (;pos<len;pos++) {
	      if (p[pos] == c) return INT2FIX(pos);
	  }
	  return Qnil;
      }

d555 1
a555 1
    VALUE str;
d557 1
a557 1
    VALUE sub;
d564 1
a564 1
	if (pos >= RSTRING(str)->len) pos = RSTRING(str)->len;
d567 1
a567 1
	pos = RSTRING(str)->len;
d570 8
a577 21
    switch (TYPE(sub)) {
      case T_REGEXP:
	reg_prepare_re(sub);
	pos = re_search(RREGEXP(sub)->ptr,
			RSTRING(str)->ptr, RSTRING(str)->len,
			pos, -pos, 0);
	kcode_reset_option();
	if (pos >= 0) return INT2FIX(pos); 
	break;

      case T_STRING:
	/* substring longer than string */
	if (pos > RSTRING(str)->len) return Qnil;
	sbeg = RSTRING(str)->ptr; s = sbeg + pos - RSTRING(sub)->len;
	t = RSTRING(sub)->ptr;
	len = RSTRING(sub)->len;
	while (sbeg <= s) {
	    if (*s == *t && memcmp(s, t, len) == 0) {
		return INT2FIX(s - sbeg);
	    }
	    s--;
d579 1
a579 15
	break;

      case T_FIXNUM:
      {
	  int c = FIX2INT(sub);
	  char *p = RSTRING(str)->ptr;

	  for (;pos>=0;pos--) {
	      if (p[pos] == c) return INT2FIX(pos);
	  }
	  return Qnil;
      }

      default:
	TypeError("Type mismatch: %s given", rb_class2name(CLASS_OF(sub)));
d611 1
a611 1
    VALUE orig;
d613 1
a613 1
    VALUE str, str2;
d617 1
a617 1
    str = str_new(RSTRING(orig)->ptr, RSTRING(orig)->len);
d619 1
a619 1
    sbeg = RSTRING(str)->ptr; s = sbeg + RSTRING(str)->len - 1;
d626 2
a627 2
	if (c == -1 && RSTRING(str)->len > 0) {
	    RSTRING(str)->ptr[RSTRING(str)->len-1] += 1;
d630 3
a632 3
	    str2 = str_new(0, RSTRING(str)->len+1);
	    RSTRING(str2)->ptr[0] = c;
	    memcpy(RSTRING(str2)->ptr+1, RSTRING(str)->ptr, RSTRING(str)->len);
d637 1
a637 1
    if (str_tainted(orig)) {
a638 1
    }
d640 1
a640 1
    return str;
d667 1
a667 1
    VALUE str;
d677 1
a677 1
	    idx = RSTRING(str)->len + idx;
d679 1
a679 1
	if (idx < 0 || RSTRING(str)->len <= idx) {
d682 1
a682 1
	return (VALUE)INT2FIX(RSTRING(str)->ptr[idx] & 0xff);
d709 1
a709 1
    VALUE str;
d721 1
a721 1
    VALUE str, val;
d724 1
a724 1
    if (len < RSTRING(val)->len) {
d726 1
a726 1
	REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len+RSTRING(val)->len-len+1);
d729 2
a730 4
    if (len != RSTRING(val)->len) {
	memmove(RSTRING(str)->ptr+beg+RSTRING(val)->len,
		RSTRING(str)->ptr+beg+len,
		RSTRING(str)->len-(beg+len));
d732 3
a734 3
    memcpy(RSTRING(str)->ptr+beg, RSTRING(val)->ptr, RSTRING(val)->len);
    RSTRING(str)->len += RSTRING(val)->len - len;
    RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
d740 1
a740 1
    VALUE str, *val;
d750 1
a750 1
	beg = RSTRING(str)->len + beg;
d755 2
a756 2
    if (RSTRING(str)->len <= beg) {
	beg = RSTRING(str)->len;
d759 1
a759 1
	end = RSTRING(str)->len + end;
d764 2
a765 2
    if (RSTRING(str)->len <= end) {
	end = RSTRING(str)->len - 1;
d777 3
a779 1
    VALUE str, pat, val;
d791 1
a791 1
	pat = reg_regcomp(pat);
d806 1
a806 1
	str_cat(result, RSTRING(str)->ptr+offset, beg-offset);
d815 1
a815 3
	    if (RSTRING(str)->len > 0) {
		str_cat(result, RSTRING(str)->ptr+END(0), 1);
	    }
d826 2
a827 2
    if (RSTRING(str)->len > offset) {
	str_cat(result, RSTRING(str)->ptr+offset, RSTRING(str)->len-offset);
d836 1
a836 1
    VALUE str;
d848 1
a848 1
    memcpy(RSTRING(str)->ptr, RSTRING(result)->ptr, RSTRING(result)->len);
d856 1
a856 1
    VALUE str;
d887 2
a888 1
	str_cat(result, RSTRING(str)->ptr+offset, beg-offset);
a889 1
	regs = RMATCH(backref_get())->regs;
d901 2
a902 2
	if (null && RSTRING(str)->len) {
	    str_cat(result, RSTRING(str)->ptr+offset-1, 1);
d909 2
a910 2
    if (RSTRING(str)->len > offset) {
	str_cat(result, RSTRING(str)->ptr+offset, RSTRING(str)->len-offset);
d918 1
a918 1
    VALUE str;
d929 1
a929 1
    memcpy(RSTRING(str)->ptr, RSTRING(result)->ptr, RSTRING(result)->len);
d936 1
a936 1
    VALUE str;
d945 1
a945 1
	    idx = RSTRING(str)->len + idx;
d947 2
a948 2
	if (idx < 0 || RSTRING(str)->len <= idx) {
	    IndexError("index %d out of range [0..%d]", idx, RSTRING(str)->len-1);
d950 1
a950 1
	RSTRING(str)->ptr[idx] = FIX2INT(val) & 0xff;
d984 1
a984 1
    VALUE str;
d997 1
a997 1
	    beg = RSTRING(str)->len + beg;
d1002 2
a1003 2
	if (beg + len > RSTRING(str)->len) {
	    len = RSTRING(str)->len - beg;
d1039 1
a1039 1
    if (NIL_P(v)) return str_dup(str);
d1071 1
a1071 1
    if (NIL_P(v)) return str_dup(str);
d1082 1
a1082 2
	TypeError("$_ value need to be String (%s given)",
		  rb_class2name(CLASS_OF(line)));
d1150 5
a1154 4
    if (NIL_P(v)) v = str_dup(line);
    lastline_set(v);

    return v;
d1159 1
a1159 1
    VALUE str;
d1163 3
a1165 3
    s = RSTRING(str)->ptr;
    e = s + RSTRING(str)->len - 1;
    p = ALLOCA_N(char, RSTRING(str)->len);
d1170 1
a1170 1
    MEMCPY(RSTRING(str)->ptr, p, char, RSTRING(str)->len);
d1177 1
a1177 1
    VALUE str;
d1179 1
a1179 1
    VALUE obj = str_new(0, RSTRING(str)->len);
d1182 1
a1182 1
    s = RSTRING(str)->ptr; e = s + RSTRING(str)->len - 1;
a1192 26
str_include(str, arg)
    VALUE str, arg;
{
    int i;

    if (FIXNUM_P(arg)) {
	int c = FIX2INT(arg);
	int len = RSTRING(str)->len;
	char *p = RSTRING(str)->ptr;

	for (i=0; i<len; i++) {
	    if (p[i] == c) {
		return INT2FIX(i);
	    }
	}
	return FALSE;
    }

    Check_Type(arg, T_STRING);
    i = str_index(str, arg, 0);

    if (i == -1) return FALSE;
    return INT2FIX(i);
}

static VALUE
d1194 1
a1194 1
    VALUE str;
d1196 1
a1196 1
    return str2inum(RSTRING(str)->ptr, 10);
d1205 1
a1205 1
    VALUE str;
d1207 1
a1207 1
    double f = atof(RSTRING(str)->ptr);
d1221 1
a1221 1
    VALUE str;
d1228 1
a1228 1
    p = RSTRING(str)->ptr; pend = p + RSTRING(str)->len;
d1309 1
a1309 1
    VALUE str;
d1314 1
a1314 1
    s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
d1327 1
a1327 1
    VALUE str;
d1334 1
a1334 1
    VALUE str;
d1339 1
a1339 1
    s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
d1352 1
a1352 1
    VALUE str;
d1359 1
a1359 1
    VALUE str;
d1364 1
a1364 1
    s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
d1377 1
a1377 1
    VALUE str;
d1384 1
a1384 1
    VALUE str;
d1389 1
a1389 1
    s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
d1405 1
a1405 1
    VALUE str;
d1452 1
a1452 1
    VALUE str, src, repl;
d1462 2
a1463 2
    trsrc.p = RSTRING(src)->ptr; trsrc.pend = trsrc.p + RSTRING(src)->len;
    if (RSTRING(src)->len > 2 && RSTRING(src)->ptr[0] == '^') {
d1468 2
a1469 2
    if (RSTRING(repl)->len == 0) return str_delete_bang(str, src);
    trrepl.p = RSTRING(repl)->ptr; trrepl.pend = trrepl.p + RSTRING(repl)->len;
d1510 1
a1510 1
    t = s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
d1528 1
a1528 1
    if (sflag) RSTRING(str)->len = (t - RSTRING(str)->ptr);
d1549 1
a1549 1
    VALUE str;
d1556 1
a1556 1
    tr.p = RSTRING(str)->ptr; tr.pend = tr.p + RSTRING(str)->len;
d1558 1
a1558 1
    if (RSTRING(str)->len > 1 && RSTRING(str)->ptr[0] == '^') {
d1573 1
a1573 1
    VALUE str1, *str2;
d1583 2
a1584 2
    s = t = RSTRING(str1)->ptr;
    send = s + RSTRING(str1)->len;
d1592 1
a1592 1
    RSTRING(str1)->len = t - RSTRING(str1)->ptr;
d1599 1
a1599 1
    VALUE str1, *str2;
d1606 1
a1606 1
    VALUE str1, str2;
d1625 2
a1626 2
    s = t = RSTRING(str1)->ptr;
    send = s + RSTRING(str1)->len;
d1635 1
a1635 1
    RSTRING(str1)->len = t - RSTRING(str1)->ptr;
d1648 2
a1649 1
    if (rb_scan_args(argc, argv, "01", &str2) == 1) {
d1685 1
a1685 1
    VALUE str;
d1688 1
a1688 1
    VALUE spat;
d1704 1
a1704 1
	    spat = FS;
d1717 1
a1717 1
		spat = reg_regcomp(spat);
d1730 2
a1731 2
	UCHAR *ptr = RSTRING(str)->ptr;
	int len = RSTRING(str)->len;
d1781 1
a1781 1
		    if (ismbchar(RSTRING(str)->ptr[beg]))
d1788 1
a1788 1
		    start += ismbchar(RSTRING(str)->ptr[start])?2:1;
d1810 1
a1810 1
    if (RSTRING(str)->len > beg) {
d1819 1
a1819 1
    VALUE str;
d1841 1
a1841 1
    VALUE str;
d1847 1
a1847 1
    UCHAR *p = RSTRING(str)->ptr, *pend = p + RSTRING(str)->len, *s;
d1849 1
a1849 1
    int len = RSTRING(str)->len;
d1884 1
a1884 1
	    if (RSTRING(str)->ptr != ptr || RSTRING(str)->len != len)
d1905 2
a1906 2
    for (i=0; i<RSTRING(str)->len; i++) {
	rb_yield(INT2FIX(RSTRING(str)->ptr[i] & 0xff));
d1913 1
a1913 1
    VALUE str;
d1917 5
a1921 6
    if (RSTRING(str)->len > 0) {
	RSTRING(str)->len--;
	if (RSTRING(str)->ptr[RSTRING(str)->len] == '\n') {
	    if (RSTRING(str)->len > 0 &&
		RSTRING(str)->ptr[RSTRING(str)->len-1] == '\r') {
		RSTRING(str)->len--;
d1924 1
a1924 1
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
d1927 1
a1927 1
    return str;
d1932 1
a1932 1
    VALUE str;
d1939 1
a1939 1
    VALUE str;
a1950 38
str_chomp_bang(str)
    VALUE str;
{
    str_modify(str);

    if (RSTRING(str)->len > 0 &&
	RSTRING(str)->ptr[RSTRING(str)->len-1] == '\n') {
	RSTRING(str)->len--;
	if (RSTRING(str)->len > 0 &&
	    RSTRING(str)->ptr[RSTRING(str)->len] == '\r') {
	    RSTRING(str)->len--;
	}
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
    }
    return str;
}

static VALUE
str_chomp(str)
    VALUE str;
{
    return str_chomp_bang(str_dup(str));
}

static VALUE
f_chomp_bang(str)
    VALUE str;
{
    return str_chomp_bang(uscore_get());
}

static VALUE
f_chomp()
{
    return str_chomp_bang(str_dup(uscore_get()));
}

static VALUE
d1952 1
a1952 1
    VALUE str;
d1958 2
a1959 2
    s = RSTRING(str)->ptr;
    e = t = s + RSTRING(str)->len;
d1968 7
a1974 7
    RSTRING(str)->len = t-s;
    if (s > RSTRING(str)->ptr) { 
	UCHAR *p = RSTRING(str)->ptr;

	RSTRING(str)->ptr = ALLOC_N(char, RSTRING(str)->len+1);
	memcpy(RSTRING(str)->ptr, s, RSTRING(str)->len);
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
d1978 1
a1978 1
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
d1986 2
a1987 1
    VALUE str, pat;
d1992 1
a1992 1
    int i;
d1996 12
a2013 12
	if (regs->num_regs == 1) {
	    return str_substr(str, BEG(0), END(0)-BEG(0));
	}
	result = ary_new2(regs->num_regs);
	for (i=1; i < regs->num_regs; i++) {
	    if (BEG(i) == -1) {
		ary_push(result, Qnil);
	    }
	    else {
		ary_push(result, str_substr(str, BEG(i), END(i)-BEG(i)));
	    }
	}
d2022 2
a2023 1
    VALUE str, pat;
d2030 1
a2030 1
	pat = reg_regcomp(pat);
d2039 1
a2039 6
	VALUE ary = ary_new();

	while (!NIL_P(result = scan_once(str, pat, &start))) {
	    ary_push(ary, result);
	}
	return ary;
d2050 1
a2050 1
    VALUE str;
d2057 1
a2057 1
    VALUE str;
d2059 1
a2059 1
    return str2inum(RSTRING(str)->ptr, 16);
d2064 1
a2064 1
    VALUE str;
d2066 1
a2066 1
    return str2inum(RSTRING(str)->ptr, 8);
d2071 1
a2071 1
    VALUE str, salt;
d2073 2
a2074 3
    extern char *crypt();
    salt = obj_as_string(salt);
    if (RSTRING(salt)->len < 2)
d2076 1
a2076 1
    return str_new2(crypt(RSTRING(str)->ptr, RSTRING(salt)->ptr));
d2081 1
a2081 1
    VALUE str;
d2085 1
a2085 1
    if (strlen(RSTRING(str)->ptr) != RSTRING(str)->len)
d2087 1
a2087 1
    id = rb_intern(RSTRING(str)->ptr);
d2095 1
a2095 1
    VALUE str;
d2105 1
a2105 1
    p = RSTRING(str)->ptr; pend = p + RSTRING(str)->len;
d2135 1
a2135 1
    VALUE str;
d2139 1
a2139 1
    VALUE res;
d2142 4
a2145 4
    if (RSTRING(str)->len >= width) return (VALUE)str;
    res = str_new(0, width);
    memcpy(RSTRING(res)->ptr, RSTRING(str)->ptr, RSTRING(str)->len);
    p = RSTRING(res)->ptr + RSTRING(str)->len; pend = RSTRING(res)->ptr + width;
d2149 1
a2149 1
    return res;
d2154 1
a2154 1
    VALUE str;
d2158 1
a2158 1
    VALUE res;
d2161 3
a2163 3
    if (RSTRING(str)->len >= width) return (VALUE)str;
    res = str_new(0, width);
    p = RSTRING(res)->ptr; pend = p + width - RSTRING(str)->len;
d2167 2
a2168 2
    memcpy(pend, RSTRING(str)->ptr, RSTRING(str)->len);
    return res;
d2173 1
a2173 1
    VALUE str;
d2177 1
a2177 1
    VALUE res;
d2181 4
a2184 4
    if (RSTRING(str)->len >= width) return (VALUE)str;
    res = str_new(0, width);
    n = (width - RSTRING(str)->len)/2;
    p = RSTRING(res)->ptr; pend = p + n;
d2188 2
a2189 2
    memcpy(pend, RSTRING(str)->ptr, RSTRING(str)->len);
    p = pend + RSTRING(str)->len; pend = RSTRING(res)->ptr + width;
d2193 1
a2193 1
    return res;
a2198 1
extern VALUE eGlobalExit;
a2215 1
    rb_define_method(cString, "%", str_format, 1);
a2257 2
    rb_define_method(cString, "include?", str_include, 1);

a2266 1
    rb_define_method(cString, "chomp", str_chomp, 0);
a2272 1
    rb_define_method(cString, "chomp!", str_chomp_bang, 0);
a2298 3
    rb_define_global_function("chomp", f_chomp, 0);
    rb_define_global_function("chomp!", f_chomp_bang, 0);

a2301 3

    /* Fix-up initialize ordering */
    RCLASS(eGlobalExit)->super = cString;
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/12/22 09:01:53 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
d19 1
a20 1

d25 3
a27 1
VALUE rb_cString;
d30 3
a32 3
#define STR_NO_ORIG FL_USER3

extern VALUE rb_rs;
d35 3
a37 3
rb_str_new(ptr, len)
    char *ptr;
    size_t len;
d40 1
a40 1
    OBJSETUP(str, rb_cString, T_STRING);
d42 3
a44 1
    str->ptr = 0;
d56 2
a57 10
rb_str_new2(ptr)
    char *ptr;
{
    return rb_str_new(ptr, strlen(ptr));
}

VALUE
rb_tainted_str_new(ptr, len)
    char *ptr;
    size_t len;
d59 1
a59 1
    return rb_obj_taint(rb_str_new(ptr, len));
d63 1
a63 8
rb_tainted_str_new2(ptr)
    char *ptr;
{
    return rb_obj_taint(rb_str_new2(ptr));
}

VALUE
rb_str_new3(str)
d67 1
a67 1
    OBJSETUP(str2, rb_cString, T_STRING);
d73 4
d81 1
a81 1
rb_str_new4(orig)
d84 7
a90 5
    if (FL_TEST(orig, STR_FREEZE)) {
	return orig;
    }
    else if (RSTRING(orig)->orig && !FL_TEST(orig, STR_NO_ORIG)) {
	return rb_str_freeze(RSTRING(orig)->orig);
a92 5
	NEWOBJ(str, struct RString);
	OBJSETUP(str, rb_cString, T_STRING);

	str->len = RSTRING(orig)->len;
	str->ptr = RSTRING(orig)->ptr;
a94 4
	if (rb_safe_level() >= 3) {
	    FL_SET(str, FL_TAINT);
	}
	return (VALUE)str;
d96 3
a98 1
}
d100 1
a100 26
VALUE
rb_str_to_str(str)
    VALUE str;
{
    return rb_convert_type(str, T_STRING, "String", "to_str");
}

static void
rb_str_assign(str, str2)
    VALUE str, str2;
{
    if (str == str2) return;
    if (NIL_P(str2)) {
	RSTRING(str)->ptr = 0;
	RSTRING(str)->len = 0;
	RSTRING(str)->orig = 0;
	return;
    }
    if ((!RSTRING(str)->orig||FL_TEST(str, STR_NO_ORIG))&&RSTRING(str)->ptr)
	free(RSTRING(str)->ptr);
    RSTRING(str)->ptr = RSTRING(str2)->ptr;
    RSTRING(str)->len = RSTRING(str2)->len;
    RSTRING(str)->orig = RSTRING(str2)->orig;
    RSTRING(str2)->ptr = 0;	/* abandon str2 */
    RSTRING(str2)->len = 0;
    if (OBJ_TAINTED(str2)) OBJ_TAINT(str);
d103 1
a103 1
static ID to_str;
d106 1
a106 1
rb_obj_as_string(obj)
d114 1
a114 1
    str = rb_funcall(obj, to_str, 0);
d116 1
a116 2
	return rb_any_to_s(obj);
    if (OBJ_TAINTED(obj)) OBJ_TAINT(str);
d121 1
a121 1
rb_str_clone(orig)
d126 2
a127 2
    if (RSTRING(orig)->orig && !FL_TEST(orig, STR_NO_ORIG))
	str = rb_str_new3(RSTRING(orig)->orig);
d129 1
a129 3
	str = rb_str_new(RSTRING(orig)->ptr, RSTRING(orig)->len);
    if (RSTRING(orig)->orig && FL_TEST(orig, STR_NO_ORIG))
	RSTRING(str)->orig = RSTRING(orig)->orig;
d135 1
a135 1
rb_str_dup(str)
d138 2
a139 6
    VALUE s;

    if (TYPE(str) != T_STRING) str = rb_str_to_str(str);
    s = rb_str_new(RSTRING(str)->ptr, RSTRING(str)->len);
    if (OBJ_TAINTED(str)) OBJ_TAINT(s);

d144 2
a145 2
rb_str_s_new(klass, orig)
    VALUE klass;
d149 1
a149 1
    OBJSETUP(str, klass, T_STRING);
d151 1
a151 2
    str->orig = 0;
    orig = rb_obj_as_string(orig);
d153 2
a154 2
    if (RSTRING(orig)->ptr) {
	str->ptr = ALLOC_N(char, RSTRING(orig)->len+1);
a155 1
	str->ptr[RSTRING(orig)->len] = '\0';
d157 2
d161 1
a161 1
	FL_SET(str, FL_TAINT);
a162 1
    rb_obj_call_init((VALUE)str);
d168 1
a168 1
rb_str_length(str)
a173 9
static VALUE
rb_str_empty(str)
    VALUE str;
{
    if (RSTRING(str)->len == 0)
	return Qtrue;
    return Qfalse;
}

d175 1
a175 1
rb_str_plus(str1, str2)
d180 2
a181 2
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
    str3 = rb_str_new(0, RSTRING(str1)->len+RSTRING(str2)->len);
d183 1
a183 2
    memcpy(RSTRING(str3)->ptr + RSTRING(str1)->len,
	   RSTRING(str2)->ptr, RSTRING(str2)->len);
d186 3
a188 3
    if (OBJ_TAINTED(str1) || OBJ_TAINTED(str2))
	OBJ_TAINT(str3);
    return str3;
d192 1
a192 1
rb_str_times(str, times)
d197 1
a197 1
    size_t i, len;
d201 1
a201 1
	rb_raise(rb_eArgError, "negative argument");
d204 1
a204 1
    str2 = rb_str_new(0, RSTRING(str)->len*len);
d206 1
a206 2
	memcpy(RSTRING(str2)->ptr+(i*RSTRING(str)->len),
	       RSTRING(str)->ptr, RSTRING(str)->len);
d210 2
a211 2
    if (OBJ_TAINTED(str)) {
	OBJ_TAINT(str2);
d217 2
a218 2
static VALUE
rb_str_format(str, arg)
d227 1
a227 1
	return rb_f_sprintf(RARRAY(arg)->len+1, argv);
d233 1
a233 1
    return rb_f_sprintf(2, argv);
d237 1
a237 1
rb_str_substr(str, start, len)
d239 1
a239 1
    size_t start, len;
d241 1
a241 1
    VALUE str2;
d247 1
a247 1
	return rb_str_new(0,0);
d253 1
a253 4
    str2 = rb_str_new(RSTRING(str)->ptr+start, len);
    if (OBJ_TAINTED(str)) OBJ_TAINT(str2);

    return str2;
d257 1
a257 1
rb_str_subseq(str, beg, end)
d259 1
a259 1
    size_t beg, end;
d261 1
a261 1
    size_t len;
d264 1
a264 1
	rb_raise(rb_eIndexError, "end smaller than beg [%d..%d]", beg, end);
d280 1
a280 1
	return rb_str_new(0, 0);
d288 1
a288 1
    return rb_str_substr(str, beg, len);
d291 2
d294 1
a294 1
rb_str_modify(str)
d297 1
a297 1
    char *ptr;
d299 4
d304 2
a305 4
	rb_raise(rb_eTypeError, "can't modify frozen string");
    if (rb_safe_level() >= 4 && !FL_TEST(str, FL_TAINT))
	rb_raise(rb_eSecurityError, "Insecure: can't modify string");
    if (!RSTRING(str)->orig || FL_TEST(str, STR_NO_ORIG)) return;
d316 1
a316 1
rb_str_freeze(str)
d324 1
a324 1
rb_str_frozen_p(str)
d328 2
a329 2
	return Qtrue;
    return Qfalse;
d333 1
a333 1
rb_str_dup_frozen(str)
d336 11
a346 2
    if (RSTRING(str)->orig && !FL_TEST(str, STR_NO_ORIG)) {
	return rb_str_freeze(RSTRING(str)->orig);
d348 10
a357 3
    if (FL_TEST(str, STR_FREEZE))
	return str;
    return rb_str_freeze(rb_str_dup(str));
d361 1
a361 1
rb_str_resize(str, len)
d363 1
a363 1
    size_t len;
d365 1
a365 1
    rb_str_modify(str);
d374 1
a374 1
    return str;
d378 1
a378 1
rb_str_cat(str, ptr, len)
d380 2
a381 2
    char *ptr;
    size_t len;
d384 1
a384 1
	rb_str_modify(str);
d394 2
a395 2
VALUE
rb_str_concat(str1, str2)
d398 3
a400 9
    if (FIXNUM_P(str2)) {
	int i = FIX2INT(str2);
	if (0 <= i && i <= 0xff) { /* byte */
	    char c = i;
	    return rb_str_cat(str1, &c, 1);
	}
    }
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
    return rb_str_cat(str1, RSTRING(str2)->ptr, RSTRING(str2)->len);
d404 1
a404 1
rb_str_hash(str)
d407 2
a408 2
    register size_t len = RSTRING(str)->len;
    register char *p = RSTRING(str)->ptr;
d411 1
a411 1
    if (ruby_ignorecase) {
d427 1
a427 1
rb_str_hash_method(str)
d430 1
a430 1
    int key = rb_str_hash(str);
d434 1
a434 1
#define lesser(a,b) (((a)>(b))?(b):(a))
d437 1
a437 1
rb_str_cmp(str1, str2)
d440 1
a440 1
    size_t len;
d443 2
a444 2
    if (ruby_ignorecase) {
	return rb_str_cicmp(str1, str2);
d447 1
a447 1
    len = lesser(RSTRING(str1)->len, RSTRING(str2)->len);
d450 1
a450 3
	if (RSTRING(str1)->len == RSTRING(str2)->len) return 0;
	if (RSTRING(str1)->len > RSTRING(str2)->len) return 1;
	return -1;
d452 1
a452 3
    if (retval == 0) return 0;
    if (retval > 0) return 1;
    return -1;
d456 1
a456 1
rb_str_equal(str1, str2)
d460 1
a460 1
	return Qfalse;
d463 2
a464 2
	&& rb_str_cmp(str1, str2) == 0) {
	return Qtrue;
d466 1
a466 1
    return Qfalse;
d470 1
a470 1
rb_str_cmp_method(str1, str2)
d475 2
a476 2
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
    result = rb_str_cmp(str1, str2);
d481 1
a481 1
rb_str_match(x, y)
d485 1
a485 1
    size_t start;
d489 1
a489 1
	return rb_reg_match(y, x);
d492 2
a493 2
	reg = rb_reg_regcomp(y);
	start = rb_reg_search(reg, x, 0, 0);
d495 1
a495 1
	    return Qfalse;
d505 1
a505 1
rb_str_match2(str)
d508 1
a508 1
    return rb_reg_match2(rb_reg_regcomp(str));
d511 2
a512 2
static size_t
rb_str_index(str, sub, offset)
d514 1
a514 1
    size_t offset;
d516 2
a517 2
    char *s, *e, *p;
    size_t len;
d530 1
a530 1
    return (size_t)-1;
d534 1
a534 1
rb_str_index_method(argc, argv, str)
d541 1
a541 1
    size_t pos;
d544 1
a544 1
	pos = NUM2UINT(initpos);
d552 1
a552 1
	pos = rb_reg_search(sub, str, pos, 0);
d556 1
a556 1
	pos = rb_str_index(str, sub, pos);
d562 1
a562 1
	  size_t len = RSTRING(str)->len;
d572 1
a572 2
	rb_raise(rb_eTypeError, "Type mismatch: %s given",
		 rb_class2name(CLASS_OF(sub)));
d580 1
a580 1
rb_str_rindex(argc, argv, str)
d587 2
a588 2
    size_t pos, len;
    char *s, *sbeg, *t;
d591 1
a591 1
	pos = NUM2UINT(initpos);
d600 5
a604 1
	pos = rb_reg_search(sub, str, pos, 1);
d634 1
a634 2
	rb_raise(rb_eTypeError, "Type mismatch: %s given",
		 rb_class2name(CLASS_OF(sub)));
d639 1
a639 1
static char
d641 1
a641 1
    char *s;
d665 1
a665 1
rb_str_succ(orig)
d669 1
a669 1
    char *sbeg, *s;
d672 1
a672 1
    str = rb_str_new(RSTRING(orig)->ptr, RSTRING(orig)->len);
d677 1
a677 1
	if (ISALNUM(*s) && (c = succ_char(s)) == 0) break;
d685 1
a685 1
	    str2 = rb_str_new(0, RSTRING(str)->len+1);
d692 2
a693 2
    if (OBJ_TAINTED(orig)) {
	OBJ_TAINT(str);
a698 10
static VALUE
rb_str_succ_bang(str)
    VALUE str;
{
    rb_str_modify(str);
    rb_str_assign(str, rb_str_succ(str));

    return str;
}

d700 1
a700 1
rb_str_upto(beg, end)
d705 1
a705 1
    if (TYPE(end) != T_STRING) end = rb_str_to_str(end);
d712 2
a713 2
	if (rb_str_equal(current, end)) break;
	current = rb_str_succ(current);
d722 1
a722 1
rb_str_aref(str, indx)
d726 1
a726 1
    size_t idx;
d738 1
a738 1
	return INT2FIX(RSTRING(str)->ptr[idx] & 0xff);
d741 2
a742 2
	if (rb_reg_search(indx, str, 0, 0) >= 0)
	    return rb_reg_last_match(rb_backref_get());
d746 1
a746 1
	if (rb_str_index(str, indx, 0) != (size_t)-1) return indx;
d752 3
a754 3
	    size_t beg, end;
	    if (rb_range_beg_end(indx, &beg, &end)) {
		return rb_str_subseq(str, beg, end);
d757 1
a757 1
	rb_raise(rb_eIndexError, "Invalid index for string");
a758 1
    return Qnil;		/* not reached */
d762 1
a762 1
rb_str_aref_method(argc, argv, str)
d770 1
a770 1
	return rb_str_substr(str, NUM2INT(arg1), NUM2INT(arg2));
d772 1
a772 1
    return rb_str_aref(str, arg1);
d776 1
a776 1
rb_str_replace(str, beg, len, val)
d778 1
a778 1
    size_t beg, len;
d786 3
a788 6
	memmove(RSTRING(str)->ptr + beg + RSTRING(val)->len,
		RSTRING(str)->ptr + beg + len,
		RSTRING(str)->len - (beg + len));
    }
    if (RSTRING(str)->len < beg && len < 0) {
	MEMZERO(RSTRING(str)->ptr + RSTRING(str)->len, char, -len);
d795 1
a795 1
/* rb_str_replace2() understands negatice offset */
d797 3
a799 3
rb_str_replace2(str, beg, end, val)
    VALUE str, val;
    size_t beg, end;
d801 1
a801 1
    size_t len;
d804 1
a804 1
	rb_raise(rb_eIndexError, "end smaller than beg [%d..%d]", beg, end);
d830 1
a830 1
    rb_str_replace(str, beg, len, val);
d833 140
a972 1
static VALUE rb_str_sub_bang _((int, VALUE*, VALUE));
d975 19
a993 1
rb_str_aset(str, indx, val)
d997 1
a997 1
    size_t idx, beg, end;
d1001 1
a1001 1
	idx = NUM2UINT(indx);
d1006 1
a1006 8
	    rb_raise(rb_eIndexError, "index %d out of range [0..%d]", idx,
		     RSTRING(str)->len - 1);
	}
	if (TYPE(val) == T_STRING) {
	    rb_str_replace(str, idx, 1, val);
	}
	else {
	    RSTRING(str)->ptr[idx] = NUM2INT(val) & 0xff;
d1008 1
d1012 1
a1012 6
        {
	    VALUE args[2];
	    args[0] = indx;
	    args[1] = val;
	    rb_str_sub_bang(2, args, str);
	}
d1016 5
a1020 4
	beg = rb_str_index(str, indx, 0);
	if (beg != (size_t)-1) {
	    end = beg + RSTRING(indx)->len - 1;
	    rb_str_replace2(str, beg, end, val);
d1022 1
d1028 3
a1030 4
	    size_t beg, end;
	    if (rb_range_beg_end(indx, &beg, &end)) {
		if (TYPE(val) != T_STRING) val = rb_str_to_str(val);
		rb_str_replace2(str, beg, end, val);
d1034 1
a1034 1
	rb_raise(rb_eIndexError, "Invalid index for string");
d1039 1
a1039 1
rb_str_aset_method(argc, argv, str)
d1046 1
a1046 1
    rb_str_modify(str);
d1049 1
a1049 1
	size_t beg, len;
d1051 3
a1053 2
	if (TYPE(arg3) != T_STRING) arg3 = rb_str_to_str(arg3);
	beg = NUM2UINT(arg1);
d1058 2
a1059 2
	len = NUM2UINT(arg2);
	if (len < 0) rb_raise(rb_eIndexError, "negative length %d", len);
d1063 1
a1063 1
	rb_str_replace(str, beg, len, arg3);
d1066 1
a1066 1
    return rb_str_aset(str, arg1, arg2);
d1070 4
a1073 2
get_pat(pat)
    VALUE pat;
d1075 1
a1075 3
    switch (TYPE(pat)) {
      case T_REGEXP:
	break;
d1077 2
a1078 7
      case T_STRING:
	pat = rb_reg_regcomp(pat);
	break;

      default:
	/* type failed */
	Check_Type(pat, T_REGEXP);
d1080 1
a1080 1
    return pat;
d1084 1
a1084 1
rb_str_sub_bang(argc, argv, str)
d1089 1
a1089 4
    VALUE pat, repl, match;
    struct re_registers *regs;
    int iter = 0;
    size_t plen;
d1091 2
a1092 5
    if (argc == 1 && rb_iterator_p()) {
	iter = 1;
    }
    else if (argc == 2) {
	repl = rb_obj_as_string(argv[1]);;
d1095 1
a1095 1
	rb_raise(rb_eArgError, "Wrong # of arguments(%d for 2)", argc);
d1097 2
a1098 30

    pat = get_pat(argv[0]);
    if (rb_reg_search(pat, str, 0, 0) >= 0) {
	rb_str_modify(str);
	match = rb_backref_get();
	regs = RMATCH(match)->regs;

	if (iter) {
	    repl = rb_obj_as_string(rb_yield(rb_reg_nth_match(0, match)));
	}
	else {
	    repl = rb_reg_regsub(repl, str, regs);
	}
	plen = END(0) - BEG(0);
	if (RSTRING(repl)->len > plen) {
	    REALLOC_N(RSTRING(str)->ptr, char,
		      RSTRING(str)->len + RSTRING(repl)->len - plen + 1);
	}
	if (RSTRING(repl)->len != plen) {
	    memmove(RSTRING(str)->ptr + BEG(0) + RSTRING(repl)->len,
		    RSTRING(str)->ptr + BEG(0) + plen,
		    RSTRING(str)->len - BEG(0) - plen);
	}
	memcpy(RSTRING(str)->ptr + BEG(0),
	       RSTRING(repl)->ptr, RSTRING(repl)->len);
	RSTRING(str)->len += RSTRING(repl)->len - plen;
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
	return str;
    }
    return Qnil;
d1102 1
a1102 1
rb_str_sub(argc, argv, str)
d1107 1
a1107 1
    VALUE val = rb_str_sub_bang(argc, argv, str = rb_str_dup(str));
d1109 4
a1112 2
    if (NIL_P(val)) return str;
    return val;
d1116 1
a1116 1
rb_str_gsub_bang(argc, argv, str)
d1121 1
a1121 6
    VALUE pat, val, repl, match;
    struct re_registers *regs;
    int beg, offset, n;
    int iter = 0;
    char *buf, *bp, *cp;
    size_t blen, len;
d1123 2
a1124 5
    if (argc == 1 && rb_iterator_p()) {
	iter = 1;
    }
    else if (argc == 2) {
	repl = rb_obj_as_string(argv[1]);;
d1127 1
a1127 53
	rb_raise(rb_eArgError, "Wrong # of arguments(%d for 2)", argc);
    }

    pat = get_pat(argv[0]);
    offset=0; n=0; 
    beg = rb_reg_search(pat, str, 0, 0);
    if (beg < 0) return Qnil;	/* no match, no substitution */

    blen = RSTRING(str)->len + 30; /* len + margin */
    buf = ALLOC_N(char, blen);
    bp = buf;
    cp = RSTRING(str)->ptr;

    while (beg >= 0) {
	n++;
	match = rb_backref_get();
	regs = RMATCH(match)->regs;
	if (iter) {
	    val = rb_obj_as_string(rb_yield(rb_reg_nth_match(0, match)));
	}
	else {
	    val = rb_reg_regsub(repl, str, regs);
	}
	len = (bp - buf) + (beg - offset) + RSTRING(val)->len + 3;
	if (blen < len) {
	    while (blen < len) blen *= 2;
	    len = bp - buf;
	    REALLOC_N(buf, char, blen);
	    bp = buf + len;
	}
	len = beg - offset;	/* copy pre-match substr */
	memcpy(bp, cp, len);
	bp += len;
	memcpy(bp, RSTRING(val)->ptr, RSTRING(val)->len);
	bp += RSTRING(val)->len;
	if (BEG(0) == END(0)) {
	    /*
	     * Always consume at least one character of the input string
	     * in order to prevent infinite loops.
	     */
	    len = mbclen(RSTRING(str)->ptr[END(0)]);
	    if (RSTRING(str)->len > END(0)) {
		memcpy(bp, RSTRING(str)->ptr+END(0), len);
		bp += len;
	    }
	    offset = END(0) + len;
	}
	else {
	    offset = END(0);
	}
	cp = RSTRING(str)->ptr + offset;
	if (offset > RSTRING(str)->len) break;
	beg = rb_reg_search(pat, str, offset, 0);
d1129 2
a1130 41
    if (RSTRING(str)->len > offset) {
	len = bp - buf;
	if (blen - len < RSTRING(str)->len - offset) {
	    REALLOC_N(buf, char, len + RSTRING(str)->len - offset + 1);
	    bp = buf + len;
	}
	memcpy(bp, cp, RSTRING(str)->len - offset);
	bp += RSTRING(str)->len - offset;
    }
    rb_str_modify(str);
    free(RSTRING(str)->ptr);
    RSTRING(str)->ptr = buf;
    RSTRING(str)->len = len = bp - buf;
    RSTRING(str)->ptr[len] = '\0';

    return str;
}

static VALUE
rb_str_gsub(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE val = rb_str_gsub_bang(argc, argv, str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
}

static VALUE
rb_str_replace_method(str, str2)
    VALUE str, str2;
{
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
    rb_str_modify(str);
    rb_str_resize(str, RSTRING(str2)->len);
    memcpy(RSTRING(str)->ptr, RSTRING(str2)->ptr, RSTRING(str2)->len);
    if (OBJ_TAINTED(str2)) OBJ_TAINT(str);

    return str;
d1138 1
a1138 1
    line = rb_lastline_get();
d1140 2
a1141 2
	rb_raise(rb_eTypeError, "$_ value need to be String (%s given)",
		 NIL_P(line)?"nil":rb_class2name(CLASS_OF(line)));
d1147 1
a1147 1
rb_f_sub_bang(argc, argv)
d1151 7
a1157 1
    return rb_str_sub_bang(argc, argv, uscore_get());
d1161 1
a1161 1
rb_f_sub(argc, argv)
d1165 1
a1165 1
    VALUE line, v;
d1167 12
a1178 5
    line = rb_str_dup(uscore_get());
    v = rb_str_sub_bang(argc, argv, line);
    if (NIL_P(v)) return line;
    rb_lastline_set(v);
    return v;
d1182 1
a1182 1
rb_f_gsub_bang(argc, argv)
d1186 7
a1192 1
    return rb_str_gsub_bang(argc, argv, uscore_get());
d1196 1
a1196 1
rb_f_gsub(argc, argv)
d1200 11
a1210 1
    VALUE line, v;
a1211 4
    line = rb_str_dup(uscore_get());
    v = rb_str_gsub_bang(argc, argv, line);
    if (NIL_P(v)) return line;
    rb_lastline_set(v);
d1216 1
a1216 1
rb_str_reverse_bang(str)
d1219 1
a1219 1
    char *s, *e, *p, *q;
d1223 1
a1223 1
    p = q = ALLOCA_N(char, RSTRING(str)->len);
d1228 1
a1228 1
    MEMCPY(RSTRING(str)->ptr, q, char, RSTRING(str)->len);
d1230 1
a1230 1
    return str;
d1234 1
a1234 1
rb_str_reverse(str)
d1237 2
a1238 4
    VALUE obj;
    char *s, *e, *p;

    if (RSTRING(str)->len <= 1) return str;
a1239 1
    obj = rb_str_new(0, RSTRING(str)->len);
d1251 1
a1251 1
rb_str_include(str, arg)
d1254 1
a1254 1
    size_t i;
d1258 1
a1258 1
	size_t len = RSTRING(str)->len;
d1266 1
a1266 1
	return Qfalse;
d1269 2
a1270 2
    if (TYPE(arg) != T_STRING) arg = rb_str_to_str(arg);
    i = rb_str_index(str, arg, 0);
d1272 1
a1272 1
    if (i == (size_t)-1) return Qfalse;
d1277 1
a1277 1
rb_str_to_i(str)
d1280 1
a1280 1
    return rb_str2inum(RSTRING(str)->ptr, 10);
d1283 4
d1288 1
a1288 1
rb_str_to_f(str)
d1293 1
a1293 1
    return rb_float_new(f);
d1297 1
a1297 1
rb_str_to_s(str)
d1304 1
a1304 1
rb_str_inspect(str)
d1308 3
a1310 3
    char buf[STRMAX];
    char *p, *pend;
    char *b;
d1325 1
a1325 1
	char c = *p++;
d1327 1
a1327 3
	    int len = mbclen(c)-1;

	    CHECK(len);
d1329 1
a1329 3
	    while (len--) {
		*b++ = *p++;
	    }
d1331 4
a1334 3
	else if ((c & 0x80) && rb_kcode() != MBCTYPE_EUC) {
	    CHECK(1);
	    *b++ = c;
d1336 1
a1336 1
	else if (c == '"'|| c == '\\') {
d1339 1
a1339 1
	    *b++ = c;
d1341 1
a1341 1
	else if (ISPRINT(c)) {
d1365 1
a1365 1
	else if (c == '\013') {
d1383 1
a1383 1
	    sprintf(b, "%03o", c & 0377);
d1388 1
a1388 1
    return rb_str_new(buf, b - buf);
d1392 1
a1392 1
rb_str_dump(str)
d1395 1
a1395 4
    size_t len;
    char *p, *pend;
    char *q, *qend;
    VALUE result;
d1397 1
a1397 85
    len = 2;			/* "" */
    p = RSTRING(str)->ptr; pend = p + RSTRING(str)->len;
    while (p < pend) {
	char c = *p++;
	switch (c) {
	  case '"':  case '\\':
	  case '\n': case '\r':
	  case '\t': case '\f':
	  case '\013': case '\007': case '\033': 
	    len += 2;
	    break;

	  default:
	    if (ISPRINT(c)) {
		len++;
	    }
	    else {
		len += 4;		/* \nnn */
	    }
	    break;
	}
    }

    result = rb_str_new(0, len);
    p = RSTRING(str)->ptr; pend = p + RSTRING(str)->len;
    q = RSTRING(result)->ptr; qend = q + len;

    *q++ = '"';
    while (p < pend) {
	char c = *p++;

	if (c == '"' || c == '\\') {
	    *q++ = '\\';
	    *q++ = c;
	}
	else if (ISPRINT(c)) {
	    *q++ = c;
	}
	else if (c == '\n') {
	    *q++ = '\\';
	    *q++ = 'n';
	}
	else if (c == '\r') {
	    *q++ = '\\';
	    *q++ = 'r';
	}
	else if (c == '\t') {
	    *q++ = '\\';
	    *q++ = 't';
	}
	else if (c == '\f') {
	    *q++ = '\\';
	    *q++ = 'f';
	}
	else if (c == '\013') {
	    *q++ = '\\';
	    *q++ = 'v';
	}
	else if (c == '\007') {
	    *q++ = '\\';
	    *q++ = 'a';
	}
	else if (c == '\033') {
	    *q++ = '\\';
	    *q++ = 'e';
	}
	else {
	    *q++ = '\\';
	    sprintf(q, "%03o", c&0xff);
	    q += 3;
	}
    }
    *q++ = '"';

    return result;
}

static VALUE
rb_str_upcase_bang(str)
    VALUE str;
{
    char *s, *send;
    int modify = 0;

    rb_str_modify(str);
d1400 1
a1400 4
	if (ismbchar(*s)) {
	    s+=mbclen(*s);
	}
	else if (islower(*s)) {
a1401 1
	    modify = 1;
d1406 1
a1406 2
    if (modify) return str;
    return Qnil;
d1410 1
a1410 1
rb_str_upcase(str)
d1413 1
a1413 4
    VALUE val = rb_str_upcase_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1417 1
a1417 1
rb_str_downcase_bang(str)
d1420 1
a1420 2
    char *s, *send;
    int modify = 0;
d1422 1
a1422 1
    rb_str_modify(str);
d1425 1
a1425 4
	if (ismbchar(*s)) {
	    s+=mbclen(*s);
	}
	else if (ISUPPER(*s)) {
a1426 1
	    modify = 1;
d1431 1
a1431 2
    if (modify) return str;
    return Qnil;
d1435 1
a1435 1
rb_str_downcase(str)
d1438 1
a1438 4
    VALUE val = rb_str_downcase_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1442 1
a1442 1
rb_str_capitalize_bang(str)
d1445 1
a1445 2
    char *s, *send;
    int modify = 0;
d1447 1
a1447 1
    rb_str_modify(str);
d1449 1
a1449 1
    if (ISLOWER(*s)) {
a1450 2
	modify = 1;
    }
d1452 1
a1452 4
	if (ismbchar(*s)) {
	    s+=mbclen(*s);
	}
	else if (ISUPPER(*s)) {
a1453 1
	    modify = 1;
d1456 1
a1456 2
    if (modify) return str;
    return Qnil;
d1460 1
a1460 1
rb_str_capitalize(str)
d1463 1
a1463 4
    VALUE val = rb_str_capitalize_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1467 1
a1467 1
rb_str_swapcase_bang(str)
d1470 1
a1470 2
    char *s, *send;
    int modify = 0;
d1472 1
a1472 1
    rb_str_modify(str);
d1475 1
a1475 4
	if (ismbchar(*s)) {
	    s+=mbclen(*s);
	}
	else if (ISUPPER(*s)) {
a1476 1
	    modify = 1;
d1478 1
a1478 1
	else if (ISLOWER(*s)) {
a1479 1
	    modify = 1;
d1484 1
a1484 2
    if (modify) return str;
    return Qnil;
d1488 1
a1488 1
rb_str_swapcase(str)
d1491 1
a1491 4
    VALUE val = rb_str_swapcase_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1494 1
a1494 1
typedef unsigned char *USTR;
d1496 1
a1496 1
struct tr {
d1498 2
a1499 2
    char *p, *pend;
};
d1508 1
a1508 1
	    t->now = *(USTR)t->p++;
d1532 1
a1532 1
static VALUE rb_str_delete_bang _((VALUE,VALUE));
d1541 3
a1543 3
    char trans[256];
    int i, c, c0, modify = 0;
    char *s, *send;
d1545 1
a1545 2
    rb_str_modify(str);
    if (TYPE(src) != T_STRING) src = rb_str_to_str(src);
d1551 3
a1553 4
    if (TYPE(repl) != T_STRING) repl = rb_str_to_str(repl);
    if (RSTRING(repl)->len == 0) return rb_str_delete_bang(str, src);
    trrepl.p = RSTRING(repl)->ptr;
    trrepl.pend = trrepl.p + RSTRING(repl)->len;
d1593 2
a1594 1
    s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
a1596 2
	char *t = s;

a1600 4
		if (*t != c) {
		    *t = c;
		    modify = 1;
		}
a1603 5
	if (RSTRING(str)->len > (t - RSTRING(str)->ptr)) {
	    RSTRING(str)->len = (t - RSTRING(str)->ptr);
	    modify = 1;
	    *t = '\0';
	}
d1607 2
a1608 6
	    c = trans[*s & 0xff] & 0xff;
	    if (*s != c) {
		*s = c;
		modify = 1;
	    }
	    s++;
d1611 2
d1614 1
a1614 2
    if (modify) return str;
    return Qnil;
d1618 1
a1618 1
rb_str_tr_bang(str, src, repl)
d1625 1
a1625 1
rb_str_tr(str, src, repl)
d1628 1
a1628 4
    VALUE val = tr_trans(str = rb_str_dup(str), src, repl, 0);

    if (NIL_P(val)) return str;
    return val;
d1634 1
a1634 1
    char table[256];
d1656 2
a1657 2
rb_str_delete_bang(str1, str2)
    VALUE str1, str2;
d1659 2
a1660 3
    char *s, *send, *t;
    char squeez[256];
    int modify = 0;
d1662 1
a1662 1
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
d1665 1
a1665 1
    rb_str_modify(str1);
d1670 1
a1670 3
	if (squeez[*s & 0xff])
	    modify = 1;
	else
d1672 1
d1678 1
a1678 2
    if (modify) return str1;
    return Qnil;
d1682 2
a1683 2
rb_str_delete(str1, str2)
    VALUE str1, str2;
d1685 1
a1685 4
    VALUE val = rb_str_delete_bang(str1 = rb_str_dup(str1), str2);

    if (NIL_P(val)) return str1;
    return val;
d1692 3
a1694 3
    char squeez[256];
    char *s, *send, *t;
    char c, save, modify = 0;
d1707 1
a1707 1
    rb_str_modify(str1);
a1715 1
	    modify = 1;
d1721 1
a1721 2
    if (modify) return str1;
    return Qnil;
d1725 1
a1725 1
rb_str_squeeze_bang(argc, argv, str1)
d1732 2
a1733 2
    if (rb_scan_args(argc, argv, "01", &str2) == 1 && TYPE(str2) != T_STRING) {
	str2 = rb_str_to_str(str2);
d1739 1
a1739 1
rb_str_squeeze(argc, argv, str)
d1744 1
a1744 4
    VALUE val = rb_str_squeeze_bang(argc, argv, str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1748 1
a1748 1
rb_str_tr_s_bang(str, src, repl)
d1751 3
d1758 1
a1758 1
rb_str_tr_s(str, src, repl)
d1761 1
a1761 4
    VALUE val = tr_trans(str = rb_str_dup(str), src, repl, 1);

    if (NIL_P(val)) return str;
    return val;
d1765 1
a1765 1
rb_str_split_method(argc, argv, str)
d1770 1
d1773 2
a1774 3
    int char_sep = -1;
    int beg, end, i;
    int lim = 0;
d1777 2
a1778 1
    if (rb_scan_args(argc, argv, "02", &spat, &limit) == 2) {
d1780 2
a1781 2
	if (lim <= 0) limit = Qnil;
	else if (lim == 1) return rb_ary_new3(1, str);
d1785 3
a1787 3
    if (argc == 0) {
	if (!NIL_P(rb_fs)) {
	    spat = rb_fs;
d1796 2
a1797 2
	    if (RSTRING(spat)->len == 1) {
		char_sep = (unsigned char)RSTRING(spat)->ptr[0];
d1800 1
a1800 1
		spat = rb_reg_regcomp(spat);
d1806 1
a1806 1
	    rb_raise(rb_eArgError, "bad separator");
d1810 1
a1810 1
    result = rb_ary_new();
d1812 4
a1815 4
    if (char_sep >= 0) {
	char *ptr = RSTRING(str)->ptr;
	size_t len = RSTRING(str)->len;
	char *eptr = ptr + len;
d1822 1
a1822 1
		    if (ISSPACE(*ptr)) {
d1831 2
a1832 2
		    if (ISSPACE(*ptr)) {
			rb_ary_push(result, rb_str_substr(str, beg, end-beg));
d1845 2
a1846 2
		if (*ptr == (char)char_sep) {
		    rb_ary_push(result, rb_str_substr(str, beg, end-beg));
d1855 1
a1855 1
	size_t start = beg;
d1857 1
a1857 1
	size_t idx;
d1860 2
a1861 2
	while ((end = rb_reg_search(spat, str, start, 0)) >= 0) {
	    regs = RMATCH(rb_backref_get())->regs;
d1864 4
a1867 1
		    rb_ary_push(result, rb_str_substr(str, beg, mbclen(RSTRING(str)->ptr[beg])));
d1871 1
a1871 1
		    start += mbclen(RSTRING(str)->ptr[start]);
d1877 1
a1877 1
		rb_ary_push(result, rb_str_substr(str, beg, end-beg));
d1885 1
a1885 1
		    tmp = rb_str_new(0, 0);
d1887 2
a1888 2
		    tmp = rb_str_subseq(str, BEG(idx), END(idx)-1);
		rb_ary_push(result, tmp);
d1893 2
a1894 7
    if (!NIL_P(limit) || RSTRING(str)->len > beg || lim < 0) {
	rb_ary_push(result, rb_str_subseq(str, beg, -1));
    }
    if (NIL_P(limit) && lim == 0) {
	while (RARRAY(result)->len > 0 &&
	       RSTRING(RARRAY(result)->ptr[RARRAY(result)->len-1])->len == 0)
	    rb_ary_pop(result);
d1901 1
a1901 1
rb_str_split(str, sep0)
d1907 3
a1909 3
    if (TYPE(str) != T_STRING) str = rb_str_to_str(str);
    sep = rb_str_new2(sep0);
    return rb_str_split_method(1, &sep, str);
d1913 1
a1913 1
rb_f_split(argc, argv)
d1917 1
a1917 1
    return rb_str_split_method(argc, argv, uscore_get());
d1921 1
a1921 1
rb_str_each_line(argc, argv, str)
d1926 1
d1930 3
a1932 3
    char *p = RSTRING(str)->ptr, *pend = p + RSTRING(str)->len, *s;
    char *ptr = p;
    size_t len = RSTRING(str)->len;
d1935 5
a1939 2
    if (rb_scan_args(argc, argv, "01", &rs) == 0) {
	rs = rb_rs;
a1945 1
    if (TYPE(rs) != T_STRING) rs = rb_str_to_str(rs);
d1957 1
a1957 1
	    if (p[1] != '\n') continue;
d1959 1
d1961 1
a1961 1
	if (p[-1] == newline &&
d1963 3
a1965 2
	     memcmp(RSTRING(rs)->ptr, p-rslen, rslen) == 0)) {
	    line = rb_str_new(s, p - s);
d1968 2
a1969 2
		rb_raise(rb_eArgError, "string modified");
	    s = p;
d1974 2
a1975 1
	line = rb_str_new(s, p - s);
d1983 1
a1983 1
rb_str_each_byte(str)
d1986 1
a1986 1
    size_t i;
d1995 1
a1995 1
rb_str_chop_bang(str)
d1998 2
a2000 1
	rb_str_modify(str);
a2008 1
	return str;
d2010 2
a2011 1
    return Qnil;
d2015 1
a2015 1
rb_str_chop(str)
d2018 1
a2018 4
    VALUE val = rb_str_chop_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d2022 1
a2022 1
rb_f_chop_bang(str)
d2025 1
a2025 1
    return rb_str_chop_bang(uscore_get());
d2029 1
a2029 1
rb_f_chop()
d2031 1
a2031 6
    VALUE str = rb_str_dup(uscore_get());
    VALUE val = rb_str_chop_bang(str);

    if (NIL_P(str)) return str;
    rb_lastline_set(val);
    return val;
d2035 1
a2035 3
rb_str_chomp_bang(argc, argv, str)
    int argc;
    VALUE *argv;
d2038 1
a2038 5
    VALUE rs;
    int newline;
    int rslen;
    char *p = RSTRING(str)->ptr;
    size_t len = RSTRING(str)->len;
d2040 6
a2045 15
    if (rb_scan_args(argc, argv, "01", &rs) == 0) {
	rs = rb_rs;
    }
    if (NIL_P(rs)) return Qnil;

    if (TYPE(rs) != T_STRING) rs = rb_str_to_str(rs);
    rslen = RSTRING(rs)->len;
    if (rslen == 0) {
	while (len>0 && p[len-1] == '\n') {
	    len--;
	}
	if (len < RSTRING(str)->len) {
	    RSTRING(str)->len = len;
	    RSTRING(str)->ptr[len] = '\0';
	    return str;
a2046 9
	return Qnil;
    }
    if (rslen > len) return Qnil;
    newline = RSTRING(rs)->ptr[rslen-1];

    if (p[len-1] == newline &&
	(rslen <= 1 ||
	 memcmp(RSTRING(rs)->ptr, p+len-rslen, rslen) == 0)) {
	RSTRING(str)->len -= rslen;
a2047 1
	return str;
d2049 1
a2049 1
    return Qnil;
d2053 1
a2053 3
rb_str_chomp(argc, argv, str)
    int argc;
    VALUE *argv;
d2056 1
a2056 4
    VALUE val = rb_str_chomp_bang(argc, argv, str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d2060 2
a2061 3
rb_f_chomp_bang(argc, argv)
    int argc;
    VALUE *argv;
d2063 1
a2063 1
    return rb_str_chomp_bang(argc, argv, uscore_get());
d2067 1
a2067 3
rb_f_chomp(argc, argv)
    int argc;
    VALUE *argv;
d2069 1
a2069 3
    VALUE str = rb_str_dup(uscore_get());
    VALUE val = rb_str_chomp_bang(argc, argv, str);
    return val;
d2073 1
a2073 1
rb_str_strip_bang(str)
d2076 3
a2078 1
    char *s, *t, *e;
a2079 1
    rb_str_modify(str);
d2083 1
a2083 1
    while (s < t && ISSPACE(*s)) s++;
d2087 1
a2087 1
    while (s <= t && ISSPACE(*t)) t--;
d2092 1
a2092 1
	char *p = RSTRING(str)->ptr;
a2101 3
    else {
	return Qnil;
    }
d2103 1
a2103 11
    return str;
}

static VALUE
rb_str_strip(str)
    VALUE str;
{
    VALUE val = rb_str_strip_bang(str = rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d2109 1
a2109 1
    size_t *start;
d2111 1
a2111 1
    VALUE result, match;
d2113 1
a2113 1
    size_t i;
d2115 4
a2118 8
    if (rb_reg_search(pat, str, *start, 0) >= 0) {
	match = rb_backref_get();
	regs = RMATCH(match)->regs;
	if (BEG(0) == END(0)) {
	    /*
	     * Always consume at least one character of the input string
	     */
	    *start = END(0)+mbclen(RSTRING(str)->ptr[END(0)]);
d2124 1
a2124 1
	    return rb_reg_nth_match(0, match);
d2126 1
a2126 1
	result = rb_ary_new2(regs->num_regs);
d2128 6
a2133 1
	    rb_ary_push(result, rb_reg_nth_match(i, match));
d2142 1
a2142 1
rb_str_scan(str, pat)
d2146 11
a2156 1
    size_t start = 0;
d2158 2
a2159 3
    pat = get_pat(pat);
    if (!rb_iterator_p()) {
	VALUE ary = rb_ary_new();
d2162 1
a2162 1
	    rb_ary_push(ary, result);
d2174 1
a2174 1
rb_str_hex(str)
d2177 1
a2177 1
    return rb_str2inum(RSTRING(str)->ptr, 16);
d2181 1
a2181 1
rb_str_oct(str)
d2184 2
a2185 1
    int base = 8;
d2187 5
a2191 5
    if (RSTRING(str)->len > 2 && RSTRING(str)->ptr[0] == '0' &&
	(RSTRING(str)->ptr[1] == 'x' || RSTRING(str)->ptr[1] == 'X')) {
	base = 16;
    }
    return rb_str2inum(RSTRING(str)->ptr, base);
d2195 1
a2195 1
rb_str_crypt(str, salt)
d2199 1
a2199 2

    if (TYPE(salt) != T_STRING) salt = rb_str_to_str(salt);
d2201 2
a2202 2
	rb_raise(rb_eArgError, "salt too short(need >2 bytes)");
    return rb_str_new2(crypt(RSTRING(str)->ptr, RSTRING(salt)->ptr));
d2206 1
a2206 1
rb_str_intern(str)
d2212 1
a2212 1
	rb_raise(rb_eArgError, "string contains `\\0'");
d2218 1
a2218 1
rb_str_sum(argc, argv, str)
d2225 1
a2225 1
    char *p, *pend;
d2227 2
a2228 3
    if (rb_scan_args(argc, argv, "01", &vbits) == 0) {
	bits = 16;
    }
d2232 1
a2232 1
    if (bits > sizeof(long)*CHAR_BIT) {
d2240 2
a2241 1
	    res = rb_funcall(res, '+', 1, INT2FIX((unsigned int)*p));
a2243 1
	res = rb_funcall(res, '&', 1, mod);
d2247 2
a2248 2
	unsigned int res = 0;
	unsigned int mod = (1<<bits)-1;
a2249 3
	if (mod == 0) {
	    mod = -1;
	}
d2251 2
a2252 1
	    res += (unsigned int)*p;
d2255 1
a2255 2
	res &= mod;
	return rb_int2inum(res);
d2260 1
a2260 1
rb_str_ljust(str, w)
d2264 1
a2264 1
    size_t width = NUM2UINT(w);
d2266 1
a2266 1
    char *p, *pend;
d2268 2
a2269 2
    if (width < 0 || RSTRING(str)->len >= width) return str;
    res = rb_str_new(0, width);
d2279 1
a2279 1
rb_str_rjust(str, w)
d2283 1
a2283 1
    size_t width = NUM2UINT(w);
d2285 1
a2285 1
    char *p, *pend;
d2287 2
a2288 2
    if (width < 0 || RSTRING(str)->len >= width) return str;
    res = rb_str_new(0, width);
d2298 1
a2298 1
rb_str_center(str, w)
d2302 1
a2302 1
    size_t width = NUM2UINT(w);
d2304 2
a2305 2
    char *p, *pend;
    size_t n;
d2307 2
a2308 2
    if (width < 0 || RSTRING(str)->len >= width) return str;
    res = rb_str_new(0, width);
d2322 5
d2330 103
a2432 104
    rb_cString  = rb_define_class("String", rb_cObject);
    rb_include_module(rb_cString, rb_mComparable);
    rb_include_module(rb_cString, rb_mEnumerable);
    rb_define_singleton_method(rb_cString, "new", rb_str_s_new, 1);
    rb_define_method(rb_cString, "clone", rb_str_clone, 0);
    rb_define_method(rb_cString, "dup", rb_str_dup, 0);
    rb_define_method(rb_cString, "<=>", rb_str_cmp_method, 1);
    rb_define_method(rb_cString, "==", rb_str_equal, 1);
    rb_define_method(rb_cString, "===", rb_str_equal, 1);
    rb_define_method(rb_cString, "eql?", rb_str_equal, 1);
    rb_define_method(rb_cString, "hash", rb_str_hash_method, 0);
    rb_define_method(rb_cString, "+", rb_str_plus, 1);
    rb_define_method(rb_cString, "*", rb_str_times, 1);
    rb_define_method(rb_cString, "%", rb_str_format, 1);
    rb_define_method(rb_cString, "[]", rb_str_aref_method, -1);
    rb_define_method(rb_cString, "[]=", rb_str_aset_method, -1);
    rb_define_method(rb_cString, "length", rb_str_length, 0);
    rb_define_alias(rb_cString,  "size", "length");
    rb_define_method(rb_cString, "empty?", rb_str_empty, 0);
    rb_define_method(rb_cString, "=~", rb_str_match, 1);
    rb_define_method(rb_cString, "~", rb_str_match2, 0);
    rb_define_method(rb_cString, "succ", rb_str_succ, 0);
    rb_define_method(rb_cString, "succ!", rb_str_succ_bang, 0);
    rb_define_method(rb_cString, "next", rb_str_succ, 0);
    rb_define_method(rb_cString, "next!", rb_str_succ_bang, 0);
    rb_define_method(rb_cString, "upto", rb_str_upto, 1);
    rb_define_method(rb_cString, "index", rb_str_index_method, -1);
    rb_define_method(rb_cString, "rindex", rb_str_rindex, -1);
    rb_define_method(rb_cString, "replace", rb_str_replace_method, 1);

    rb_define_method(rb_cString, "freeze", rb_str_freeze, 0);
    rb_define_method(rb_cString, "frozen?", rb_str_frozen_p, 0);

    rb_define_method(rb_cString, "to_i", rb_str_to_i, 0);
    rb_define_method(rb_cString, "to_f", rb_str_to_f, 0);
    rb_define_method(rb_cString, "to_s", rb_str_to_s, 0);
    rb_define_method(rb_cString, "to_str", rb_str_to_s, 0);
    rb_define_method(rb_cString, "inspect", rb_str_inspect, 0);
    rb_define_method(rb_cString, "dump", rb_str_dump, 0);

    rb_define_method(rb_cString, "upcase", rb_str_upcase, 0);
    rb_define_method(rb_cString, "downcase", rb_str_downcase, 0);
    rb_define_method(rb_cString, "capitalize", rb_str_capitalize, 0);
    rb_define_method(rb_cString, "swapcase", rb_str_swapcase, 0);

    rb_define_method(rb_cString, "upcase!", rb_str_upcase_bang, 0);
    rb_define_method(rb_cString, "downcase!", rb_str_downcase_bang, 0);
    rb_define_method(rb_cString, "capitalize!", rb_str_capitalize_bang, 0);
    rb_define_method(rb_cString, "swapcase!", rb_str_swapcase_bang, 0);

    rb_define_method(rb_cString, "hex", rb_str_hex, 0);
    rb_define_method(rb_cString, "oct", rb_str_oct, 0);
    rb_define_method(rb_cString, "split", rb_str_split_method, -1);
    rb_define_method(rb_cString, "reverse", rb_str_reverse, 0);
    rb_define_method(rb_cString, "reverse!", rb_str_reverse_bang, 0);
    rb_define_method(rb_cString, "concat", rb_str_concat, 1);
    rb_define_method(rb_cString, "<<", rb_str_concat, 1);
    rb_define_method(rb_cString, "crypt", rb_str_crypt, 1);
    rb_define_method(rb_cString, "intern", rb_str_intern, 0);

    rb_define_method(rb_cString, "include?", rb_str_include, 1);

    rb_define_method(rb_cString, "scan", rb_str_scan, 1);

    rb_define_method(rb_cString, "ljust", rb_str_ljust, 1);
    rb_define_method(rb_cString, "rjust", rb_str_rjust, 1);
    rb_define_method(rb_cString, "center", rb_str_center, 1);

    rb_define_method(rb_cString, "sub", rb_str_sub, -1);
    rb_define_method(rb_cString, "gsub", rb_str_gsub, -1);
    rb_define_method(rb_cString, "chop", rb_str_chop, 0);
    rb_define_method(rb_cString, "chomp", rb_str_chomp, -1);
    rb_define_method(rb_cString, "strip", rb_str_strip, 0);

    rb_define_method(rb_cString, "sub!", rb_str_sub_bang, -1);
    rb_define_method(rb_cString, "gsub!", rb_str_gsub_bang, -1);
    rb_define_method(rb_cString, "strip!", rb_str_strip_bang, 0);
    rb_define_method(rb_cString, "chop!", rb_str_chop_bang, 0);
    rb_define_method(rb_cString, "chomp!", rb_str_chomp_bang, -1);

    rb_define_method(rb_cString, "tr", rb_str_tr, 2);
    rb_define_method(rb_cString, "tr_s", rb_str_tr_s, 2);
    rb_define_method(rb_cString, "delete", rb_str_delete, 1);
    rb_define_method(rb_cString, "squeeze", rb_str_squeeze, -1);

    rb_define_method(rb_cString, "tr!", rb_str_tr_bang, 2);
    rb_define_method(rb_cString, "tr_s!", rb_str_tr_s_bang, 2);
    rb_define_method(rb_cString, "delete!", rb_str_delete_bang, 1);
    rb_define_method(rb_cString, "squeeze!", rb_str_squeeze_bang, -1);

    rb_define_method(rb_cString, "each_line", rb_str_each_line, -1);
    rb_define_method(rb_cString, "each", rb_str_each_line, -1);
    rb_define_method(rb_cString, "each_byte", rb_str_each_byte, 0);

    rb_define_method(rb_cString, "sum", rb_str_sum, -1);

    rb_define_global_function("sub", rb_f_sub, -1);
    rb_define_global_function("gsub", rb_f_gsub, -1);

    rb_define_global_function("sub!", rb_f_sub_bang, -1);
    rb_define_global_function("gsub!", rb_f_gsub_bang, -1);

    rb_define_global_function("chop", rb_f_chop, 0);
    rb_define_global_function("chop!", rb_f_chop_bang, 0);
d2434 1
a2434 2
    rb_define_global_function("chomp", rb_f_chomp, -1);
    rb_define_global_function("chomp!", rb_f_chomp_bang, -1);
d2436 1
a2436 1
    rb_define_global_function("split", rb_f_split, -1);
d2438 2
a2439 1
    to_str = rb_intern("to_s");
@


1.1.1.3.2.1
log
@990126
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:28 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d35 1
a35 1
    int len;
d61 1
a61 1
    int len;
d252 1
a252 1
    int i, len;
d295 1
a295 1
    int start, len;
d318 1
a318 1
    int beg, end;
d320 1
a320 1
    int len;
d402 1
a402 1
    int len;
d420 1
a420 1
    int len;
d452 1
a452 1
    register int len = RSTRING(str)->len;
d485 2
a486 1
    int len, retval;
d534 1
a534 1
    int start;
d560 1
a560 1
static int
d563 1
a563 1
    int offset;
d566 1
a566 1
    int len;
d579 1
a579 1
    return -1;
d590 1
a590 1
    int pos;
d593 1
a593 1
	pos = NUM2INT(initpos);
d611 1
a611 1
	  int len = RSTRING(str)->len;
d637 1
a637 1
    int pos, len;
d641 1
a641 1
	pos = NUM2INT(initpos);
d783 1
a783 1
    int idx;
d803 1
a803 1
	if (rb_str_index(str, indx, 0) != -1) return indx;
d809 1
a809 1
	    int beg, end;
d836 1
a836 2
    int beg;
    int len;
d860 1
a860 1
    int beg, end;
d862 1
a862 1
    int len;
d901 1
a901 2
    int idx;
    int beg, end;
d905 1
a905 1
	idx = NUM2INT(indx);
d932 1
a932 1
	if (beg != -1) {
d941 1
a941 1
	    int beg, end;
d963 1
a963 2
	int beg;
	int len;
d966 1
a966 1
	beg = NUM2INT(arg1);
d971 1
a971 1
	len = NUM2INT(arg2);
d1010 1
a1010 1
    int plen;
d1073 1
a1073 1
    int beg, n;
d1076 1
a1076 1
    int offset, blen, len;
d1281 1
a1281 1
    int i;
d1285 1
a1285 1
	int len = RSTRING(str)->len;
d1299 1
a1299 1
    if (i == -1) return Qfalse;
d1421 1
a1421 1
    int len;
d1993 1
a1993 1
	int len = RSTRING(str)->len;
d2034 1
a2034 1
	int start = beg;
d2036 1
a2036 1
	int idx;
d2112 1
a2112 1
    int len = RSTRING(str)->len;
d2161 1
a2161 1
    int i;
d2226 1
a2226 1
    int len = RSTRING(str)->len;
d2338 1
a2338 1
    int *start;
d2342 1
a2342 1
    int i;
d2374 1
a2374 1
    int start = 0;
d2487 1
a2487 1
    int width = NUM2INT(w);
d2506 1
a2506 1
    int width = NUM2INT(w);
d2525 1
a2525 1
    int width = NUM2INT(w);
d2528 1
a2528 1
    int n;
@


1.1.1.3.2.2
log
@990201
@
text
@d6 1
a6 1
  $Date: 1999/01/26 10:08:17 $
d358 1
a358 1
    if (!FL_TEST(str, FL_TAINT) && rb_safe_level() >= 4)
@


1.1.1.3.2.3
log
@990205
@
text
@d6 1
a6 1
  $Date: 1999/02/01 07:34:57 $
d1143 1
a1143 1
	if (blen - len < RSTRING(str)->len - offset + 1) {
@


1.1.1.3.2.4
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/02/05 10:27:33 $
a24 4
#ifndef atof
double strtod();
#endif

d63 1
a63 4
    VALUE str = rb_str_new(ptr, len);

    FL_SET(str, FL_TAINT);
    return str;
d70 1
a70 4
    VALUE str = rb_str_new2(ptr);

    FL_SET(str, FL_TAINT);
    return str;
d105 1
a105 1
	if (FL_TEST(str, FL_TAINT)) {
a1030 1
	    rb_match_busy(match, Qtrue);
a1031 2
	    rb_match_busy(match, Qfalse);
	    rb_backref_set(match);
a1104 1
	    rb_match_busy(match, Qtrue);
a1105 2
	    rb_match_busy(match, Qfalse);
	    rb_backref_set(match);
d1316 1
a1316 1
    double f = strtod(RSTRING(str)->ptr, 0);
@


1.1.1.3.2.5
log
@990212
@
text
@d6 1
a6 1
  $Date: 1999/02/09 06:08:23 $
d1368 1
a1368 1
	    int len = mbclen(c);
d1372 1
a1372 1
	    while (--len) {
@


1.1.1.3.2.6
log
@990224
@
text
@d6 1
a6 1
  $Date: 1999/02/12 11:17:06 $
a308 4
    if (len == 0) return rb_str_new(0,0);
    if (len < 0) {
	rb_raise(rb_eIndexError, "negative length %d", len);
    }
d312 1
a312 1
    if (RSTRING(str)->len <= start) {
d330 5
a334 1
    int b, e, len;
a335 1
    b = beg; e = end;
d338 1
d342 4
d347 2
a348 4
    if (beg > end) {
	if (e != -1) {
	    rb_raise(rb_eIndexError, "end smaller than beg [%d..%d]", b, e);
	}
d352 2
a353 1
    if (beg >= RSTRING(str)->len) {
a356 1
    len = end - beg + 1;
d866 1
a866 1
/* rb_str_replace2() understands negative offset */
d872 5
a876 1
    int b, e, len;
a877 1
    b = beg; e = end;
d880 6
d889 3
d893 2
a894 5
    if (beg > end) {
	if (e != -1) {
	    rb_raise(rb_eIndexError, "end smaller than beg [%d..%d]", b, e);
	}
	end = beg - 1;
d896 2
a897 2
    if (beg >= RSTRING(str)->len) {
	beg = RSTRING(str)->len;
d900 1
a900 3
    else {
	len = end - beg + 1;
    }
d1532 1
a1532 1
	    s+=mbclen(*s) - 1;
d1566 1
a1566 1
	    s+=mbclen(*s) - 1;
d1604 1
a1604 1
	    s+=mbclen(*s) - 1;
d1636 1
a1636 1
	    s+=mbclen(*s) - 1;
@


1.1.1.3.2.7
log
@990225
@
text
@d6 1
a6 1
  $Date: 1999/02/24 04:31:25 $
d217 1
a217 1
    rb_obj_call_init((VALUE)str, 1, &orig);
d628 1
a628 1
	rb_raise(rb_eTypeError, "type mismatch: %s given",
d687 1
a687 1
	rb_raise(rb_eTypeError, "type mismatch: %s given",
d821 1
a821 1
	rb_raise(rb_eIndexError, "invalid index for string");
d950 1
a950 1
	rb_raise(rb_eIndexError, "invalid index for string");
d1022 1
a1022 1
	rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)", argc);
d1091 1
a1091 1
	rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)", argc);
@


1.1.1.3.2.8
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/25 06:39:11 $
d38 1
a38 1
    const char *ptr;
d57 1
a57 1
    const char *ptr;
d64 1
a64 1
    const char *ptr;
d75 1
a75 1
    const char *ptr;
d303 1
a303 1
rb_str_substr(str, beg, len)
d305 1
a305 1
    int beg, len;
d309 6
a314 5
    if (len < 0) return Qnil;
    if (beg > RSTRING(str)->len) return Qnil;
    if (beg < 0) {
	beg += RSTRING(str)->len;
	if (beg < 0) return Qnil;
d316 2
a317 2
    if (beg + len > RSTRING(str)->len) {
	len = RSTRING(str)->len - beg;
d319 2
a320 2
    if (len < 0) {
	len = 0;
a321 1
    if (len == 0) return rb_str_new(0,0);
d323 1
a323 1
    str2 = rb_str_new(RSTRING(str)->ptr+beg, len);
d329 29
d427 1
a427 1
    const char *ptr;
a574 4
    if (offset < 0) {
	offset += RSTRING(str)->len;
	if (offset < 0) return -1;
    }
d579 1
a579 2
    if (len == 0) return offset;
    e = RSTRING(str)->ptr + RSTRING(str)->len - len + 1;
d764 1
a764 1
rb_str_upto(beg, end, excl)
a765 1
    int excl;
d770 2
d776 1
a776 1
	if (!excl && rb_str_equal(current, end)) break;
a777 1
	if (excl && rb_str_equal(current, end)) break;
a785 7
rb_str_upto_method(beg, end)
    VALUE beg, end;
{
    return rb_str_upto(beg, end, 0);
}

static VALUE
d816 3
a818 8
	    int beg, len;
	    switch (rb_range_beg_len(indx, &beg, &len, RSTRING(str)->len, 0)) {
	      case Qfalse:
		break;
	      case Qnil:
		return Qnil;
	      default:
		return rb_str_substr(str, beg, len);
d864 31
d907 1
a907 1
	beg = idx = NUM2INT(indx);
d909 1
a909 1
	    idx += RSTRING(str)->len;
d911 3
a913 2
	if (idx < 0 || RSTRING(str)->len < idx) {
	    rb_raise(rb_eIndexError, "index %d out of string", NUM2INT(beg));
d915 2
a916 6
	if (FIXNUM_P(val)) {
	    if (RSTRING(str)->len == idx) {
		RSTRING(str)->len += 1;
		REALLOC_N(RSTRING(str)->ptr, char, RSTRING(str)->len);
	    }
	    RSTRING(str)->ptr[idx] = NUM2INT(val) & 0xff;
d919 1
a919 2
	    if (TYPE(val) != T_STRING) val = rb_str_to_str(val);
	    rb_str_replace(str, idx, 1, val);
d935 2
a936 2
	    if (TYPE(val) != T_STRING) val = rb_str_to_str(val);
	    rb_str_replace(str, beg, RSTRING(indx)->len, val);
d943 2
a944 2
	    int beg, len;
	    if (rb_range_beg_len(indx, &beg, &len, RSTRING(str)->len, 2)) {
d946 1
a946 1
		rb_str_replace(str, beg, len, val);
d965 2
a966 1
	int beg, len;
d970 4
a975 9
	if (beg < 0) {
	    beg += RSTRING(str)->len;
	}
	if (beg < 0 || RSTRING(str)->len < beg) {
	    if (beg < 0) {
		beg -= RSTRING(str)->len;
	    }
	    rb_raise(rb_eIndexError, "index %d out of string", beg);
	}
d2072 1
a2072 1
		    tmp = rb_str_substr(str, BEG(idx), END(idx)-BEG(idx));
d2079 1
a2079 1
	rb_ary_push(result, rb_str_substr(str, beg, RSTRING(str)->len-beg));
d2093 1
a2093 1
    const char *sep0;
d2582 1
a2582 1
    rb_define_method(rb_cString, "upto", rb_str_upto_method, 1);
@


1.1.1.3.2.9
log
@to open CVS
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:33 $
d1407 1
a1407 1
	  case '\t': case '\f': case '#':
a1433 4
	}
	else if (c == '#') {
	    *q++ = '\\';
	    *q++ = '#';
@


1.1.1.3.2.10
log
@aix shlib link
@
text
@d6 1
a6 1
  $Date: 1999/04/20 08:21:41 $
d2189 1
a2189 1
    if (NIL_P(val)) return str;
a2263 3

    if (NIL_P(val)) return str;
    rb_lastline_set(val);
@


1.1.1.3.2.11
log
@small fixes
@
text
@d6 1
a6 1
  $Date: 1999/04/26 09:42:42 $
d619 1
a619 1
    VALUE position;
d623 3
a625 3
    if (rb_scan_args(argc, argv, "11", &sub, &position) == 2) {
	pos = NUM2INT(position);
	if (pos > RSTRING(str)->len) return Qnil;
d628 1
a628 1
	pos = 0;
d639 2
a640 3
	if (RSTRING(str)->len - pos < RSTRING(sub)->len) return Qnil;
	sbeg = RSTRING(str)->ptr + pos;
	s = RSTRING(str)->ptr + RSTRING(str)->len - RSTRING(sub)->len;
d645 1
a645 1
		return INT2FIX(s - RSTRING(str)->ptr);
d654 1
a654 2
	  char *p = RSTRING(str)->ptr + RSTRING(str)->len - 1;
	  char *pbeg = RSTRING(str)->ptr + pos;
d656 2
a657 3
	  while (pbeg <= p) {
	      if (*p == c) return INT2FIX(p - RSTRING(str)->ptr);
	      p--;
d868 2
a869 2
	if (idx < 0 || RSTRING(str)->len <= idx) {
	    rb_raise(rb_eIndexError, "index %d out of string", idx);
@


1.1.1.3.2.12
log
@regexp,range,squeeze
@
text
@d6 1
a6 1
  $Date: 1999/05/06 08:31:46 $
a1334 1
#if 0
a1338 1
#endif
d1674 1
a1674 1
    int i, c, modify = 0;
d1680 1
a1680 1
    if (RSTRING(src)->len >= 2 && RSTRING(src)->ptr[0] == '^') {
a1698 2
	while ((c = trnext(&trrepl)) >= 0)
	    /* retrieve last replacer */;
d1700 11
a1710 2
	    if (trans[i] != 0) {
		trans[i] = trrepl.now;
d1718 1
a1718 1
	    trans[i] = 0;
d1728 1
a1730 1
	int c0, last = -1;
d1733 7
a1739 4
	    c0 = *s++;
	    if ((c = trans[c0 & 0xff] & 0xff) != 0) {
		if (last == c) continue;
		last = c;
a1740 5
		modify = 1;
	    }
	    else {
		last = -1;
		*t++ = c0;
d1751 2
a1752 1
	    if ((c = trans[*s & 0xff] & 0xff) != 0) {
d1872 1
d1876 1
a1876 4
    if (t - RSTRING(str1)->ptr != RSTRING(str1)->len) {
	RSTRING(str1)->len = t - RSTRING(str1)->ptr;
	modify = 1;
    }
@


1.1.1.3.2.13
log
@990513
@
text
@d6 1
a6 1
  $Date: 1999/05/10 08:22:47 $
a415 1
    rb_str_modify(str1);
@


1.1.1.3.2.14
log
@arity/strict yield
@
text
@d6 1
a6 1
  $Date: 1999/05/13 10:01:07 $
d704 1
a704 1
    int c = -1;
d1711 1
a1711 1
	int r;
@


1.1.1.3.2.15
log
@regexp null pattern
@
text
@d6 1
a6 1
  $Date: 1999/05/17 09:54:17 $
d39 1
a39 1
    long len;
d65 1
a65 1
    long len;
d226 1
a226 1
    return INT2NUM(RSTRING(str)->len);
d262 1
a262 1
    long i, len;
d264 1
a264 1
    len = NUM2LONG(times);
d305 1
a305 1
    long beg, len;
d381 1
a381 1
    long len;
d399 1
a399 1
    long len;
d432 1
a432 1
    register long len = RSTRING(str)->len;
d465 1
a465 2
    long len;
    int retval;
d513 1
a513 1
    long start;
d525 1
a525 1
	return INT2NUM(start);
d539 1
a539 1
static long
d542 1
a542 1
    long offset;
d545 1
a545 1
    long len;
d574 1
a574 1
    long pos;
d577 1
a577 1
	pos = NUM2LONG(initpos);
d595 1
a595 1
	  long len = RSTRING(str)->len;
d599 1
a599 1
	      if (p[pos] == c) return INT2NUM(pos);
d610 1
a610 1
    return INT2NUM(pos);
d635 1
a635 1
	if (pos >= 0) return INT2NUM(pos); 
d647 1
a647 1
		return INT2NUM(s - RSTRING(str)->ptr);
d660 1
a660 1
	      if (*p == c) return INT2NUM(p - RSTRING(str)->ptr);
d777 1
a777 1
    long idx;
d781 1
a781 1
	idx = FIX2LONG(indx);
d803 1
a803 1
	    long beg, len;
d864 1
a864 1
    int beg;
d908 1
a908 1
	    long beg, len;
d1259 1
a1259 1
    long i;
d1263 1
a1263 1
	long len = RSTRING(str)->len;
d1268 1
a1268 1
		return INT2NUM(i);
d1278 1
a1278 1
    return INT2NUM(i);
d2321 1
a2321 1
    long *start;
d2325 1
a2325 1
    long i;
d2357 1
a2357 1
    long start = 0;
d2470 1
a2470 1
    long width = NUM2LONG(w);
d2489 1
a2489 1
    long width = NUM2LONG(w);
d2508 1
a2508 1
    long width = NUM2LONG(w);
d2511 1
a2511 1
    long n;
@


1.1.1.3.2.16
log
@990531
@
text
@d6 1
a6 1
  $Date: 1999/05/25 08:26:16 $
d1035 1
a1035 1
    VALUE val = rb_str_sub_bang(argc, argv, rb_str_dup(str));
d1142 1
a1142 1
    VALUE val = rb_str_gsub_bang(argc, argv, rb_str_dup(str));
d1189 2
a1190 2
    line = uscore_get();
    v = rb_str_sub_bang(argc, argv, rb_str_dup(line));
d1211 2
a1212 2
    line = uscore_get();
    v = rb_str_gsub_bang(argc, argv, rb_str_dup(line));
d1516 1
a1516 1
    VALUE val = rb_str_upcase_bang(rb_str_dup(str));
d1550 1
a1550 1
    VALUE val = rb_str_downcase_bang(rb_str_dup(str));
d1586 1
a1586 1
    VALUE val = rb_str_capitalize_bang(rb_str_dup(str));
d1624 1
a1624 1
    VALUE val = rb_str_swapcase_bang(rb_str_dup(str));
d1668 1
a1668 1
static VALUE rb_str_delete_bang _((int,VALUE*,VALUE));
d1677 1
a1677 1
    int trans[256];
d1689 1
a1689 3
    if (RSTRING(repl)->len == 0) {
	return rb_str_delete_bang(1, &src, str);
    }
d1701 1
a1701 1
	    trans[c & 0xff] = -1;
d1706 1
a1706 1
	    if (trans[i] >= 0) {
d1715 1
a1715 1
	    trans[i] = -1;
d1731 1
a1731 1
	    if ((c = trans[c0 & 0xff]) >= 0) {
d1734 1
a1734 1
		*t++ = c & 0xff;
d1750 2
a1751 2
	    if ((c = trans[*s & 0xff]) >= 0) {
		*s = c & 0xff;
d1773 1
a1773 1
    VALUE val = tr_trans(rb_str_dup(str), src, repl, 0);
d1780 1
a1780 1
tr_setup_table(str, table, init)
a1782 1
    int init;
a1783 1
    char buf[256];
d1785 2
a1786 2
    int i, c;
    int cflag = 0;
d1791 1
a1791 1
	cflag = 1;
d1795 2
a1796 7
    if (init) {
	for (i=0; i<256; i++) {
	    table[i] = 1;
	}
    }
    for (i=0; i<256; i++) {
	buf[i] = cflag;
d1799 1
a1799 4
	buf[c & 0xff] = !cflag;
    }
    for (i=0; i<256; i++) {
	table[i] = table[i]&&buf[i];
d1804 2
a1805 4
rb_str_delete_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
a1809 2
    int init = 1;
    int i;
d1811 2
a1812 2
    for (i=0; i<argc; i++) {
	VALUE s = argv[i];
d1814 1
a1814 5
	if (TYPE(s) != T_STRING) 
	    s = rb_str_to_str(s);
	tr_setup_table(s, squeez, init);
	init = 0;
    }
d1816 2
a1817 3
    rb_str_modify(str);
    s = t = RSTRING(str)->ptr;
    send = s + RSTRING(str)->len;
d1826 1
a1826 1
    RSTRING(str)->len = t - RSTRING(str)->ptr;
d1828 1
a1828 1
    if (modify) return str;
d1833 2
a1834 4
rb_str_delete(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
d1836 1
a1836 1
    VALUE val = rb_str_delete_bang(argc, argv, rb_str_dup(str));
d1838 1
a1838 1
    if (NIL_P(val)) return str;
d1843 2
a1844 4
rb_str_squeeze_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
a1848 2
    int init = 1;
    int i;
d1850 2
a1851 4
    if (argc == 0) {
	for (i=0; i<256; i++) {
	    squeez[i] = 1;
	}
d1854 1
a1854 2
	for (i=0; i<argc; i++) {
	    VALUE s = argv[i];
d1856 2
a1857 4
	    if (TYPE(s) != T_STRING) 
		s = rb_str_to_str(s);
	    tr_setup_table(s, squeez, init);
	    init = 0;
d1861 1
a1861 1
    rb_str_modify(str);
d1863 2
a1864 2
    s = t = RSTRING(str)->ptr;
    send = s + RSTRING(str)->len;
d1873 2
a1874 2
    if (t - RSTRING(str)->ptr != RSTRING(str)->len) {
	RSTRING(str)->len = t - RSTRING(str)->ptr;
d1878 1
a1878 1
    if (modify) return str;
d1883 14
d1902 1
a1902 1
    VALUE val = rb_str_squeeze_bang(argc, argv, rb_str_dup(str));
d1919 1
a1919 1
    VALUE val = tr_trans(rb_str_dup(str), src, repl, 1);
a1925 35
rb_str_count(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE a1, a2;
    char table[256];
    char *s, *send;
    int init = 1;
    int i;

    if (argc < 0) {
	rb_raise(rb_eArgError, "wrong # of arguments");
    }
    for (i=0; i<argc; i++) {
	VALUE s = argv[i];

	if (TYPE(s) != T_STRING) 
	    s = rb_str_to_str(s);
	tr_setup_table(s, table, init);
	init = 0;
    }

    s = RSTRING(str)->ptr;
    send = s + RSTRING(str)->len;
    i = 0;
    while (s < send) {
	if (table[*s++ & 0xff]) {
	    i++;
	}
    }
    return INT2NUM(i);
}

static VALUE
d2173 1
a2173 1
    VALUE val = rb_str_chop_bang(rb_str_dup(str));
d2189 2
a2190 2
    VALUE str = uscore_get();
    VALUE val = rb_str_chop_bang(rb_str_dup(str));
d2246 1
a2246 1
    VALUE val = rb_str_chomp_bang(argc, argv, rb_str_dup(str));
d2265 2
a2266 2
    VALUE str = uscore_get();
    VALUE val = rb_str_chomp_bang(argc, argv, rb_str_dup(str));
d2313 1
a2313 1
    VALUE val = rb_str_strip_bang(rb_str_dup(str));
d2614 1
a2614 1
    rb_define_method(rb_cString, "delete", rb_str_delete, -1);
a2615 1
    rb_define_method(rb_cString, "count", rb_str_count, -1);
d2619 1
a2619 1
    rb_define_method(rb_cString, "delete!", rb_str_delete_bang, -1);
@


1.1.1.3.2.17
log
@thread bugs
@
text
@d6 1
a6 1
  $Date: 1999/05/31 09:13:27 $
d2442 3
a2444 11
    if (RSTRING(str)->len > 2 && RSTRING(str)->ptr[0] == '0') {
	switch (RSTRING(str)->ptr[1]) {
	  case 'x':
	  case 'X':
	    base = 16;
	    break;
	  case 'b':
	  case 'B':
	    base = 2;
	    break;
	}
@


1.1.1.3.2.18
log
@990611
@
text
@d6 1
a6 1
  $Date: 1999/06/09 09:21:32 $
d217 1
@


1.1.1.3.2.19
log
@990624
@
text
@d6 1
a6 1
  $Date: 1999/06/11 06:29:57 $
a2182 1
        if (p > pend) p = pend ;
@


1.1.1.3.2.20
log
@990625
@
text
@d6 1
a6 1
  $Date: 1999/06/24 04:24:03 $
d626 1
a626 1
	if (pos > RSTRING(str)->len) pos = RSTRING(str)->len;
d629 1
a629 1
	pos = RSTRING(str)->len;
d640 3
a642 3
	if (pos < RSTRING(sub)->len) return Qnil;
	sbeg = RSTRING(str)->ptr;
	s = RSTRING(str)->ptr + pos - RSTRING(sub)->len;
d656 2
a657 2
	  char *p = RSTRING(str)->ptr + pos - 1;
	  char *pbeg = RSTRING(str)->ptr;
@


1.1.1.3.2.21
log
@990715
@
text
@d6 1
a6 1
  $Date: 1999/06/25 09:02:48 $
d634 2
a635 4
	if (RREGEXP(sub)->len) {
	    pos = rb_reg_search(sub, str, pos, 1);
	}
	if (pos >= 0) return INT2NUM(pos);
a638 1
	len = RSTRING(sub)->len;
d640 1
a640 4
	if (RSTRING(str)->len < len) return Qnil;
	if (RSTRING(str)->len - pos < len) {
	    pos = RSTRING(str)->len - len;
	}
d642 1
a642 1
	s = RSTRING(str)->ptr + pos;
d644 4
a647 6
	if (len) {
	    while (sbeg <= s) {
		if (*s == *t && memcmp(s, t, len) == 0) {
		    return INT2NUM(s - RSTRING(str)->ptr);
		}
		s--;
d649 1
a649 3
	}
	else {
	    return INT2NUM(pos);
d656 1
a656 1
	  char *p = RSTRING(str)->ptr + pos;
d1948 1
d2168 1
a2168 1
	    if (*++p != '\n') continue;
d2465 1
a2465 1
	rb_raise(rb_eArgError, "salt too short(need >=2 bytes)");
@


1.1.1.3.2.22
log
@backtrace may be Qnil
@
text
@d6 1
a6 1
  $Date: 1999/07/15 07:59:55 $
d772 1
a772 1
    return beg;
d1044 1
a1044 1
    VALUE val = rb_str_sub_bang(argc, argv, str = rb_str_dup(str));
d1151 1
a1151 1
    VALUE val = rb_str_gsub_bang(argc, argv, str = rb_str_dup(str));
d1199 1
a1199 1
    v = rb_str_sub_bang(argc, argv, line = rb_str_dup(line));
d1221 1
a1221 1
    v = rb_str_gsub_bang(argc, argv, line = rb_str_dup(line));
d1252 1
a1252 1
    if (RSTRING(str)->len <= 1) return rb_str_dup(str);
d1525 1
a1525 1
    VALUE val = rb_str_upcase_bang(str = rb_str_dup(str));
d1559 1
a1559 1
    VALUE val = rb_str_downcase_bang(str = rb_str_dup(str));
d1595 1
a1595 1
    VALUE val = rb_str_capitalize_bang(str = rb_str_dup(str));
d1633 1
a1633 1
    VALUE val = rb_str_swapcase_bang(str = rb_str_dup(str));
d1784 1
a1784 1
    VALUE val = tr_trans(str = rb_str_dup(str), src, repl, 0);
d1868 1
a1868 1
    VALUE val = rb_str_delete_bang(argc, argv, str = rb_str_dup(str));
d1882 1
a1882 1
    int c, save, modify = 0;
d1909 1
a1909 1
	if (c != save || !squeez[c]) {
d1929 1
a1929 1
    VALUE val = rb_str_squeeze_bang(argc, argv, str = rb_str_dup(str));
d1946 1
a1946 1
    VALUE val = tr_trans(str = rb_str_dup(str), src, repl, 1);
d2163 1
a2163 4
	return str;
    }
    if (TYPE(rs) != T_STRING) {
	rs = rb_str_to_str(rs);
d2165 1
d2197 1
a2197 1
    return str;
d2202 1
a2202 1
    VALUE str;
d2209 1
a2209 1
    return str;
d2235 1
a2235 1
    VALUE val = rb_str_chop_bang(str = rb_str_dup(str));
d2252 1
a2252 1
    VALUE val = rb_str_chop_bang(str = rb_str_dup(str));
d2308 1
a2308 1
    VALUE val = rb_str_chomp_bang(argc, argv, str = rb_str_dup(str));
d2328 1
a2328 1
    VALUE val = rb_str_chomp_bang(argc, argv, str = rb_str_dup(str));
d2375 1
a2375 1
    VALUE val = rb_str_strip_bang(str = rb_str_dup(str));
d2435 1
a2435 1
    return str;
@


1.1.1.3.2.23
log
@990728
@
text
@d6 1
a6 1
  $Date: 1999/07/22 10:37:20 $
d2194 1
a2194 1
        if (p > pend) p = pend;
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:04:58 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@string mbchar support (SJIS)
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:48 $
d1400 1
a1400 4
	if (ismbchar(*s)) {
	    s++;
	}
	else if (islower(*s)) {
d1425 1
a1425 4
	if (ismbchar(*s)) {
	    s++;
	}
	else if (isupper(*s)) {
d1452 1
a1452 4
	if (ismbchar(*s)) {
	    s++;
	}
	else if (isupper(*s)) {
d1475 1
a1475 4
	if (ismbchar(*s)) {
	    s++;
	}
	else if (isupper(*s)) {
@


1.1.1.2.2.3
log
@1.1b7 pre
@
text
@d6 1
a6 1
  $Date: 1998/02/05 09:46:10 $
a102 14
static void
str_assign(str, str2)
    VALUE str, str2;
{
    if (NIL_P(str2) || str == str2) return;
    free(RSTRING(str)->ptr);
    RSTRING(str)->ptr = RSTRING(str2)->ptr;
    RSTRING(str)->len = RSTRING(str2)->len;
    RSTRING(str)->orig = RSTRING(str2)->orig;
    RSTRING(str2)->ptr = 0;	/* abandon str2 */
    RSTRING(str2)->len = 0;
    if (str_tainted(str2)) str_taint(str);
}

a173 9
static VALUE
str_empty(str)
    VALUE str;
{
    if (RSTRING(str)->len == 0)
	return TRUE;
    return FALSE;
}

d188 1
a188 1
    return str3;
d211 1
a211 1
	return str_taint(str2);
d374 1
a374 1
    return str;
a698 10
static VALUE
str_succ_bang(str)
    VALUE str;
{
    str_modify(str);
    str_assign(str, str_succ(str));

    return str;
}

d738 1
a738 1
	return INT2FIX(RSTRING(str)->ptr[idx] & 0xff);
d903 1
d905 3
a907 1
    str_assign(str, result);
d909 1
a909 1
    return str;
d984 1
d986 2
a987 1
    str_assign(str, result);
d989 1
a989 1
    return str;
a1133 14
str_replace_method(str, str2)
    VALUE str, str2;
{
    Check_Type(str2, T_STRING);

    str_modify(str);
    str_resize(str, RSTRING(str2)->len);
    memcpy(RSTRING(str)->ptr, RSTRING(str2)->ptr, RSTRING(str2)->len);
    if (str_tainted(str2)) str_taint(str);

    return str;
}

static VALUE
d1230 1
a1230 1
    return str;
d1409 1
a1409 1
    return str;
d1437 1
a1437 1
    return str;
d1465 1
a1465 1
    return str;
d1496 1
a1496 1
    return str;
d1626 1
a1626 1
    return str;
d1690 1
a1690 1
    return str1;
d1733 1
a1733 1
    return str1;
d2115 1
a2115 1
    return str;
d2244 1
a2244 1
    if (bits > sizeof(UINT)*CHAR_BIT) {
d2253 1
a2255 1
	res = rb_funcall(res, '&', 1, mod);
a2261 3
	if (mod == 0) {
	    mod = -1;
	}
d2264 1
a2266 1
	res &= mod;
d2280 1
a2280 1
    if (RSTRING(str)->len >= width) return str;
d2299 1
a2299 1
    if (RSTRING(str)->len >= width) return str;
d2319 1
a2319 1
    if (RSTRING(str)->len >= width) return str;
a2359 1
    rb_define_method(cString, "empty?", str_empty, 0);
a2362 1
    rb_define_method(cString, "succ!", str_succ_bang, 0);
a2365 1
    rb_define_method(cString, "replace", str_replace_method, 1);
@


1.1.1.2.2.4
log
@1.1b7 pre2
@
text
@d6 1
a6 1
  $Date: 1998/02/09 10:56:22 $
d108 1
a108 2
    if (!RSTRING(str)->orig && RSTRING(str)->ptr)
	free(RSTRING(str)->ptr);
@


1.1.1.2.2.5
log
@1.1b7 pre3
@
text
@d6 1
a6 1
  $Date: 1998/02/10 06:50:15 $
d1037 1
a1037 6
	if (TYPE(val) == T_STRING) {
	    str_replace(str, idx, 1, val);
	}
	else {
	    RSTRING(str)->ptr[idx] = NUM2INT(val) & 0xff;
	}
d2246 1
a2246 7
    int base = 8;

    if (RSTRING(str)->len > 2 && RSTRING(str)->ptr[0] == '0' &&
	(RSTRING(str)->ptr[1] == 'x' || RSTRING(str)->ptr[1] == 'X')) {
	base = 16;
    }
    return str2inum(RSTRING(str)->ptr, base);
@


1.1.1.2.2.6
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/02/10 08:44:05 $
d159 2
a160 2
str_s_new(klass, orig)
    VALUE klass;
d164 1
a164 1
    OBJSETUP(str, klass, T_STRING);
d900 1
a900 1
	if (BEG(0) == END(0)) {
d905 1
a905 1
	    if (RSTRING(str)->len > END(0)) {
@


1.1.1.2.2.7
log
@1.1b8pre2
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:42 $
a900 1
	    int len = ismbchar(RSTRING(str)->ptr[END(0)])?2:1;
d906 1
a906 1
		str_cat(result, RSTRING(str)->ptr+END(0), len);
d908 1
a908 1
	    offset = END(0)+len;
d973 1
d975 1
a975 2
	n++;
	regs = RMATCH(backref_get())->regs;
d978 4
a981 14
	val = obj_as_string(rb_yield(reg_nth_match(0, backref_get())));
	str_cat(result, RSTRING(val)->ptr, RSTRING(val)->len);

	if (BEG(0) == END(0)) {
	    int len = ismbchar(RSTRING(str)->ptr[END(0)])?2:1;

	    /*
	     * Always consume at least one character of the input string
	     * in order to prevent infinite loops.
	     */
	    if (RSTRING(str)->len > END(0)) {
		str_cat(result, RSTRING(str)->ptr+END(0), len);
	    }
	    offset = END(0)+len;
d987 7
d2509 3
@


1.1.1.2.2.8
log
@shugo's method etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/20 08:28:47 $
d1378 1
a1378 1
	if (ismbchar(c) && p < pend && ismbchar2(*p)) {
@


1.1.1.2.2.9
log
@block arg etc.
@
text
@d6 1
a6 1
  $Date: 1998/03/03 10:16:14 $
a2425 2
    rb_define_method(cString, "next", str_succ, 0);
    rb_define_method(cString, "next!", str_succ_bang, 0);
a2512 3

    /* turn on premitive flag for the class */
    FL_SET(cString, FL_PRIMITIVE);
@


1.1.1.2.2.10
log
@1.1b9_00
@
text
@d6 1
a6 1
  $Date: 1998/03/05 06:37:47 $
d1378 1
a1378 1
	if (ismbchar(c) && p < pend) {
a1381 4
	}
	if (c & 0x80) {
	    CHECK(1);
	    *b++ = c;
@


1.1.1.2.2.11
log
@gets speed up patch
@
text
@d6 1
a6 1
  $Date: 1998/03/09 07:56:58 $
d2519 3
@


1.1.1.2.2.12
log
@-a -> -a- ^^;;
@
text
@d6 1
a6 1
  $Date: 1998/03/11 07:33:01 $
d916 1
a916 1
	if (offset > STRLEN(str)) break;
d999 1
a999 1
	if (offset > STRLEN(str)) break;
@


1.1.1.2.2.13
log
@String#chomp! etc.
@
text
@d6 1
a6 1
  $Date: 1998/03/20 09:20:30 $
a33 2
extern VALUE RS;

d1289 1
a1289 1
    VALUE obj;
a1291 3
    if (RSTRING(str)->len <= 1) return str;

    obj = str_new(0, RSTRING(str)->len);
a1451 1
    int modify = 0;
a1460 1
	    modify = 1;
d1465 1
a1465 2
    if (modify) return str;
    return Qnil;
d1472 1
a1472 4
    VALUE val = str_upcase_bang(str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1479 1
a1479 1
    UCHAR *s, *send, modify = 0;
a1488 1
	    modify = 1;
d1493 1
a1493 2
    if (modify) return str;
    return Qnil;
d1500 1
a1500 4
    VALUE val = str_downcase_bang(str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1507 1
a1507 1
    UCHAR *s, *send, modify = 0;
a1518 1
	    modify = 1;
d1521 1
a1521 2
    if (modify) return str;
    return Qnil;
d1528 1
a1528 4
    VALUE val = str_capitalize_bang(str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1535 1
a1535 1
    UCHAR *s, *send, modify = 0;
a1544 1
	    modify = 1;
a1547 1
	    modify = 1;
d1552 1
a1552 2
    if (modify) return str;
    return Qnil;
d1559 1
a1559 4
    VALUE val = str_swapcase_bang(str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1610 2
a1611 2
    int i, c, c0, modify = 0;
    UCHAR *s, *send;
a1612 1
    str_modify(str);
d1621 1
a1621 2
    trrepl.p = RSTRING(repl)->ptr;
    trrepl.pend = trrepl.p + RSTRING(repl)->len;
d1661 2
a1662 1
    s = RSTRING(str)->ptr; send = s + RSTRING(str)->len;
a1664 2
	UCHAR *t = s;

a1668 4
		if (*t != c) {
		    *t = c;
		    modify = 1;
		}
a1671 5
	if (RSTRING(str)->len = (t - RSTRING(str)->ptr)) {
	    RSTRING(str)->len = (t - RSTRING(str)->ptr);
	    modify = 1;
	    *t = '\0';
	}
d1675 2
a1676 6
	    c = trans[*s & 0xff] & 0xff;
	    if (*s != c) {
		*s = c;
		modify = 1;
	    }
	    s++;
d1679 2
d1682 1
a1682 2
    if (modify) return str;
    return Qnil;
d1696 1
a1696 4
    VALUE val = tr_trans(str_dup(str), src, repl, 0);

    if (NIL_P(val)) return str;
    return Qnil;
a1728 1
    int modify = 0;
a1739 1
	    modify = 1;
d1746 1
a1746 2
    if (modify) return str1;
    return Qnil;
d1753 1
a1753 4
    VALUE val = str_delete_bang(str_dup(str1), str2);

    if (NIL_P(val)) return str1;
    return val;
d1762 1
a1762 1
    char c, save, modify = 0;
a1783 1
	    modify = 1;
d1789 1
a1789 2
    if (modify) return str1;
    return Qnil;
d1812 1
a1812 4
    VALUE val = str_squeeze_bang(argc, argv, str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1819 3
d1829 1
a1829 4
    VALUE val = tr_trans(str_dup(str), src, repl, 1);

    if (NIL_P(val)) return str;
    return val;
d1994 1
d2003 4
a2006 1
    if (rb_scan_args(argc, argv, "01", &rs) == 0) {
a2013 1
    Check_Type(rs, T_STRING);
d2066 2
a2068 1
	str_modify(str);
a2076 1
	return str;
d2078 2
a2079 1
    return Qnil;
d2086 1
a2086 4
    VALUE val = str_chop_bang(str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d2099 1
a2099 6
    VALUE str = uscore_get();

    str = str_chop_bang(str_dup(str));
    if (NIL_P(str)) return uscore_get();
    lastline_set(str);
    return str;
d2103 1
a2103 3
str_chomp_bang(argc, argv, str)
    int argc;
    VALUE *argv;
d2106 1
a2106 5
    VALUE rs;
    int newline;
    int rslen;
    UCHAR *p = RSTRING(str)->ptr;
    int len = RSTRING(str)->len;
d2108 6
a2113 10
    if (rb_scan_args(argc, argv, "01", &rs) == 0) {
	rs = RS;
    }
    if (NIL_P(rs)) return Qnil;

    Check_Type(rs, T_STRING);
    rslen = RSTRING(rs)->len;
    if (rslen == 0) {
	while (len>0 && p[len-1] == '\n') {
	    len--;
d2115 1
a2115 5
	if (len < RSTRING(str)->len) {
	    RSTRING(str)->len = len;
	    return str;
	}
	return Qnil;
d2117 1
a2117 10
    if (rslen > len) return Qnil;
    newline = RSTRING(rs)->ptr[rslen-1];

    if (p[len-1] == newline &&
	(rslen <= 1 ||
	 memcmp(RSTRING(rs)->ptr, p+len-rslen, rslen) == 0)) {
	RSTRING(str)->len -= rslen;
	return str;
    }
    return Qnil;
d2121 1
a2121 3
str_chomp(argc, argv, str)
    int argc;
    VALUE *argv;
d2124 1
a2124 4
    VALUE val = str_chomp_bang(argc, argv, str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d2128 2
a2129 3
f_chomp_bang(argc, argv)
    int argc;
    VALUE *argv;
d2131 1
a2131 1
    return str_chomp_bang(argc, argv, uscore_get());
d2135 1
a2135 3
f_chomp(argc, argv)
    int argc;
    VALUE *argv;
d2137 1
a2137 5
    VALUE val = str_chomp_bang(argc, argv, str_dup(uscore_get()));

    if (NIL_P(val)) return uscore_get();
    lastline_set(val);
    return val;
d2147 1
a2169 3
    else {
	return Qnil;
    }
a2174 10
str_strip(str)
    VALUE str;
{
    VALUE val = str_strip_bang(str_dup(str));

    if (NIL_P(val)) return str;
    return val;
}

static VALUE
d2242 7
d2479 1
a2479 1
    rb_define_method(cString, "chomp", str_chomp, -1);
d2486 1
a2486 1
    rb_define_method(cString, "chomp!", str_chomp_bang, -1);
d2513 2
a2514 2
    rb_define_global_function("chomp", f_chomp, -1);
    rb_define_global_function("chomp!", f_chomp_bang, -1);
@


1.1.1.2.2.14
log
@String#dump
@
text
@d6 1
a6 1
  $Date: 1998/03/23 09:49:17 $
d1426 1
a1426 1
	else if (c == '\013') {
a1451 86
VALUE
str_dump(str)
    VALUE str;
{
    int len;
    UCHAR *p, *pend;
    UCHAR *q, *qend;
    VALUE result;

    len = 2;			/* "" */
    p = RSTRING(str)->ptr; pend = p + RSTRING(str)->len;
    while (p < pend) {
	UCHAR c = *p++;
	switch (c) {
	  case '"':  case '\'':
	  case '\n': case '\r':
	  case '\t': case '\f':
	  case '\013': case '\007': case '\033': 
	    len += 2;
	    break;

	  default:
	    if (isascii(c) && isprint(c)) {
		len++;
	    }
	    else {
		len += 4;		/* \nnn */
	    }
	    break;
	}
    }

    result = str_new(0, len);
    p = RSTRING(str)->ptr; pend = p + RSTRING(str)->len;
    q = RSTRING(result)->ptr; qend = q + len;

    *q++ = '"';
    while (p < pend) {
	UCHAR c = *p++;

	if (c == '"' || c == '\\') {
	    *q++ = '\\';
	    *q++ = c;
	}
	else if (isascii(c) && isprint(c)) {
	    *q++ = c;
	}
	else if (c == '\n') {
	    *q++ = '\\';
	    *q++ = 'n';
	}
	else if (c == '\r') {
	    *q++ = '\\';
	    *q++ = 'r';
	}
	else if (c == '\t') {
	    *q++ = '\\';
	    *q++ = 't';
	}
	else if (c == '\f') {
	    *q++ = '\\';
	    *q++ = 'f';
	}
	else if (c == '\13') {
	    *q++ = '\\';
	    *q++ = 'v';
	}
	else if (c == '\007') {
	    *q++ = '\\';
	    *q++ = 'a';
	}
	else if (c == 033) {
	    *q++ = '\\';
	    *q++ = 'e';
	}
	else {
	    *q++ = '\\';
	    sprintf(q, "%03o", c);
	    q += 3;
	}
    }
    *q++ = '"';

    return result;
}

a2546 1
    rb_define_method(cString, "dump", str_dump, 0);
@


1.1.1.2.2.15
log
@1.1b9_05_pre1
@
text
@d6 1
a6 1
  $Date: 1998/03/26 09:07:27 $
d1273 1
a1273 1
    UCHAR *s, *e, *p, *q;
d1277 1
a1277 1
    p = q = ALLOCA_N(char, RSTRING(str)->len);
d1282 1
a1282 1
    MEMCPY(RSTRING(str)->ptr, q, char, RSTRING(str)->len);
@


1.1.1.2.2.16
log
@1.1b9_05 patches
@
text
@d6 1
a6 1
  $Date: 1998/03/26 09:09:38 $
d1827 1
a1827 1
    return val;
@


1.1.1.2.2.17
log
@gw32 b19 patch
@
text
@d6 1
a6 1
  $Date: 1998/03/28 11:05:46 $
d1613 1
a1613 1
    if (islower(*s)) {
a1614 2
	modify = 1;
    }
d1870 2
a1871 1
	if (squeez[*s & 0xff])
d1873 1
a1873 2
	else
	    *t++ = *s;
d2472 1
a2472 1
	ArgError("string contains `\\0'");
@


1.1.1.2.2.18
log
@eval(..,file,line);String#center
@
text
@d6 1
a6 1
  $Date: 1998/03/30 09:32:52 $
d2533 1
a2533 1
    if (width < 0 || RSTRING(str)->len >= width) return str;
d2552 1
a2552 1
    if (width < 0 || RSTRING(str)->len >= width) return str;
d2572 1
a2572 1
    if (width < 0 || RSTRING(str)->len >= width) return str;
@


1.1.1.2.2.19
log
@call initialize
@
text
@d6 1
a6 1
  $Date: 1998/03/31 04:52:10 $
a179 1
    obj_call_init((VALUE)str);
@


1.1.1.2.2.20
log
@dynamic (nested) local variables
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:03:51 $
a206 1
#if 0
a207 3
#else
    Check_Type(str2, T_STRING);
#endif
a424 1
#if 0
a425 3
#else
    Check_Type(str2, T_STRING);
#endif
a501 1
#if 0
a502 3
#else
    Check_Type(str2, T_STRING);
#endif
d1389 1
a1389 1
	else if (c & 0x80) {
d2462 1
a2462 2

    Check_Type(salt, T_STRING);
@


1.1.1.2.2.21
log
@Array#cmp
@
text
@d6 1
a6 1
  $Date: 1998/04/07 08:34:09 $
d485 1
a485 1
	retval = RSTRING(str1)->ptr[len] - RSTRING(str2)->ptr[len];
d487 1
a487 3
    if (retval == 0) return 0;
    if (retval > 0) return 1;
    return -1;
@


1.1.1.2.2.22
log
@local_variables/defined?(TOPLEVEL_CONST) in modules
@
text
@d6 1
a6 1
  $Date: 1998/04/07 10:18:09 $
a431 1
    if (NIL_P(str2)) return str1;
@


1.1.1.2.2.23
log
@1.1b9_09 pre
@
text
@d6 1
a6 1
  $Date: 1998/04/08 08:12:38 $
a46 1
    str->ptr = 0;
d486 1
a486 3
	if (RSTRING(str1)->len == RSTRING(str2)->len) return 0;
	if (RSTRING(str1)->len > RSTRING(str2)->len) return 1;
	return -1;
a2290 1
	    RSTRING(str)->ptr[len] = '\0';
a2301 1
	RSTRING(str)->ptr[RSTRING(str)->len] = '\0';
@


1.1.1.2.2.24
log
@flock,flatten,signal to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/09 09:30:24 $
d87 5
d93 1
a93 4
	return str_freeze(RSTRING(orig)->orig);
    }
    else if (FL_TEST(orig, STR_FREEZE)) {
	return orig;
a95 5
	NEWOBJ(str, struct RString);
	OBJSETUP(str, cString, T_STRING);

	str->len = RSTRING(orig)->len;
	str->ptr = RSTRING(orig)->ptr;
a97 4
	if (rb_safe_level() >= 3) {
	    FL_SET(str, STR_TAINT);
	}
	return (VALUE)str;
d99 5
d365 1
a365 1
str_dup_frozen(str)
d368 3
a370 6
    if (RSTRING(str)->orig) {
	return str_freeze(RSTRING(str)->orig);
    }
    if (FL_TEST(str, STR_FREEZE))
	return str;
    return str_freeze(str_dup(str));
@


1.1.1.2.2.25
log
@1.1b9_14
@
text
@d6 1
a6 1
  $Date: 1998/04/16 07:42:47 $
a30 1
#define STR_NO_ORIG FL_USER3
d87 4
a90 1
    if (FL_TEST(orig, STR_FREEZE)) {
a92 3
    else if (RSTRING(orig)->orig && !FL_TEST(orig, STR_NO_ORIG)) {
	return str_freeze(RSTRING(orig)->orig);
    }
d113 1
a113 1
    if ((!RSTRING(str)->orig||FL_TEST(str, STR_NO_ORIG)) && RSTRING(str)->ptr)
d146 1
a146 1
    if (RSTRING(orig)->orig && !FL_TEST(orig, STR_NO_ORIG))
d339 1
a339 1
    if (!RSTRING(str)->orig || FL_TEST(str, STR_NO_ORIG)) return;
d370 1
a370 1
    if (RSTRING(str)->orig && !FL_TEST(str, STR_NO_ORIG)) {
@


1.1.1.2.2.26
log
@use to_io
@
text
@d6 1
a6 1
  $Date: 1998/04/22 08:57:34 $
a150 2
    if (RSTRING(orig)->orig && FL_TEST(orig, STR_NO_ORIG))
	RSTRING(str)->orig = RSTRING(orig)->orig;
a160 2
    if (RSTRING(str)->orig && FL_TEST(str, STR_NO_ORIG))
	RSTRING(s)->orig = RSTRING(str)->orig;
@


1.1.1.2.2.27
log
@gtk/nested local variables
@
text
@d6 1
a6 1
  $Date: 1998/04/23 06:53:19 $
a2665 1
    rb_define_method(cString, "to_str", str_to_s, 0);
@


1.1.1.2.2.28
log
@tcltklib/gtk
@
text
@d6 1
a6 1
  $Date: 1998/04/24 09:33:21 $
a108 7
static VALUE
to_str(str)
    VALUE str;
{
    return rb_convert_type(str, T_STRING, "String", "to_str");
}

d113 2
a114 8
    if (str == str2) return;
    if (NIL_P(str2)) {
	RSTRING(str)->ptr = 0;
	RSTRING(str)->len = 0;
	RSTRING(str)->orig = 0;
	return;
    }
    if ((!RSTRING(str)->orig||FL_TEST(str, STR_NO_ORIG))&&RSTRING(str)->ptr)
d215 5
a219 1
    str2 = to_str(str2);
d440 6
a445 1
    str2 = to_str(str2);
d526 5
a530 1
    str2 = to_str(str2);
d770 1
a770 1
    end = to_str(end);
d1120 2
a1121 1
	arg3 = to_str(arg3);
d1206 2
a1207 1
    str2 = to_str(str2);
d1355 2
a1356 1
    i = str_index(str, to_str(arg), 0);
d1758 1
a1758 1
    src = to_str(src);
d1764 1
a1764 1
    repl = to_str(repl);
d1887 1
a1887 1
    VALUE str1, str2;
d1893 1
a1893 1
    str2 = to_str(str2);
d1971 1
a1971 1
	str2 = to_str(str2);
d2148 1
a2148 1
    str = to_str(str);
d2183 1
a2183 1
    rs = to_str(rs);
d2296 1
a2296 1
    rs = to_str(rs);
d2493 1
a2493 1
    salt = to_str(salt);
@


1.1.1.2.2.29
log
@new exception model
@
text
@d6 1
a6 1
  $Date: 1998/04/27 10:04:01 $
d174 1
a174 4
    VALUE s;

    str = to_str(str);
    s = str_new(RSTRING(str)->ptr, RSTRING(str)->len);
d445 1
a445 1
VALUE
@


1.1.1.2.2.30
log
@exception model changed
@
text
@d6 1
a6 1
  $Date: 1998/04/30 07:41:15 $
d2622 1
@


1.1.1.2.2.31
log
@new exception model
@
text
@d6 1
a6 1
  $Date: 1998/05/01 08:56:37 $
d109 2
a110 2
VALUE
str_to_str(str)
d176 1
a176 1
    str = str_to_str(str);
d231 1
a231 1
    str2 = str_to_str(str2);
d452 1
a452 1
    str2 = str_to_str(str2);
d533 1
a533 1
    str2 = str_to_str(str2);
d610 1
a610 1
	pos = reg_search(sub, str, pos, 0);
d658 5
a662 1
	pos = reg_search(sub, str, pos, 1);
d773 1
a773 1
    end = str_to_str(end);
d1123 1
a1123 1
	arg3 = str_to_str(arg3);
d1208 1
a1208 1
    str2 = str_to_str(str2);
d1356 1
a1356 1
    i = str_index(str, str_to_str(arg), 0);
d1758 1
a1758 1
    src = str_to_str(src);
d1764 1
a1764 1
    repl = str_to_str(repl);
d1893 1
a1893 1
    str2 = str_to_str(str2);
d1971 1
a1971 1
	str2 = str_to_str(str2);
d2148 1
a2148 1
    str = str_to_str(str);
d2183 1
a2183 1
    rs = str_to_str(rs);
d2296 1
a2296 1
    rs = str_to_str(rs);
d2493 1
a2493 1
    salt = str_to_str(salt);
@


1.1.1.2.2.32
log
@no INT,UINT
@
text
@d6 1
a6 1
  $Date: 1998/05/06 03:08:59 $
d39 2
a40 2
    char *ptr;
    unsigned len;
d61 1
a61 1
    char *ptr;
d348 1
a348 1
    char *ptr;
d434 2
a435 2
    char *ptr;
    unsigned len;
d462 1
a462 1
    register char *p = RSTRING(str)->ptr;
d494 1
a494 1
    unsigned int len;
d574 1
a574 1
    char *s, *e, *p;
d646 1
a646 1
    char *s, *sbeg, *t;
d693 1
a693 1
static char
d695 1
a695 1
    char *s;
d723 1
a723 1
    char *sbeg, *s;
d1299 1
a1299 1
    char *s, *e, *p, *q;
d1318 1
a1318 1
    char *s, *e, *p;
d1390 3
a1392 3
    char buf[STRMAX];
    char *p, *pend;
    char *b;
d1407 1
a1407 1
	char c = *p++;
d1482 2
a1483 2
    char *p, *pend;
    char *q, *qend;
d1489 1
a1489 1
	char c = *p++;
d1515 1
a1515 1
	char c = *p++;
d1567 1
a1567 1
    char *s, *send;
d1601 1
a1601 2
    char *s, *send;
    int modify = 0;
d1634 1
a1634 2
    char *s, *send;
    int modify = 0;
d1669 1
a1669 2
    char *s, *send;
    int modify = 0;
d1702 1
a1702 1
typedef unsigned char *USTR;
d1706 1
a1706 1
    char *p, *pend;
d1749 1
a1749 1
    char trans[256];
d1751 1
a1751 1
    char *s, *send;
d1806 1
a1806 1
	char *t = s;
d1860 1
a1860 1
    char table[256];
d1885 2
a1886 2
    char *s, *send, *t;
    char squeez[256];
d1924 2
a1925 2
    char squeez[256];
    char *s, *send, *t;
d2050 1
a2050 1
	char *ptr = RSTRING(str)->ptr;
d2052 1
a2052 1
	char *eptr = ptr + len;
d2166 2
a2167 2
    char *p = RSTRING(str)->ptr, *pend = p + RSTRING(str)->len, *s;
    char *ptr = p;
d2284 1
a2284 1
    char *p = RSTRING(str)->ptr;
d2354 1
a2354 1
    char *s, *t, *e;
d2369 1
a2369 1
	char *p = RSTRING(str)->ptr;
d2515 1
a2515 1
    char *p, *pend;
d2522 1
a2522 1
    if (bits > sizeof(long)*CHAR_BIT) {
d2530 1
a2530 1
	    res = rb_funcall(res, '+', 1, INT2FIX((unsigned int)*p));
d2537 2
a2538 2
	unsigned int res = 0;
	unsigned int mod = (1<<bits)-1;
d2544 1
a2544 1
	    res += (unsigned int)*p;
d2559 1
a2559 1
    char *p, *pend;
d2578 1
a2578 1
    char *p, *pend;
d2597 1
a2597 1
    char *p, *pend;
@


1.1.1.2.2.33
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/05/13 05:58:08 $
d32 2
@


1.1.1.2.2.34
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:35 $
d19 1
a20 1

d729 1
a729 1
	if (ISALNUM(*s) && (c = succ_char(s)) == 0) break;
d1363 4
d1425 1
a1425 1
	else if (ISPRINT(c)) {
d1497 1
a1497 1
	    if (ISPRINT(c)) {
d1608 1
a1608 1
	else if (ISUPPER(*s)) {
d1638 1
a1638 1
    if (ISLOWER(*s)) {
d1646 1
a1646 1
	else if (ISUPPER(*s)) {
d1678 1
a1678 1
	else if (ISUPPER(*s)) {
d1682 1
a1682 1
	else if (ISLOWER(*s)) {
d1741 1
a1741 1
static VALUE str_delete_bang _((VALUE,VALUE));
d1913 1
a1913 1
    VALUE str1, str2;
d2060 1
a2060 1
		    if (ISSPACE(*ptr)) {
d2069 1
a2069 1
		    if (ISSPACE(*ptr)) {
d2361 1
a2361 1
    while (s < t && ISSPACE(*s)) s++;
d2365 1
a2365 1
    while (s <= t && ISSPACE(*t)) t--;
@


1.1.1.2.2.35
log
@BeOS patches
@
text
@d6 1
a6 1
  $Date: 1998/05/18 04:56:21 $
d1515 1
a1515 1
	else if (ISPRINT(c)) {
@


1.1.1.2.2.36
log
@remove unused variables
@
text
@d6 1
a6 1
  $Date: 1998/05/18 09:12:22 $
d290 2
d979 1
a979 1
    int beg, offset, n;
d1701 1
a1701 1
struct tr {
d1704 1
a1704 1
};
d1816 1
a1816 1
	if (RSTRING(str)->len > (t - RSTRING(str)->ptr)) {
@


1.1.1.2.2.37
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 04:57:56 $
d2609 4
@


1.1.1.2.2.38
log
@regex
@
text
@d6 1
a6 1
  $Date: 1998/06/02 10:05:32 $
d1711 1
a1711 1
	    t->now = *(USTR)t->p++;
@


1.1.1.2.2.39
log
@1.1b9_25
@
text
@d6 1
a6 1
  $Date: 1998/06/05 09:54:23 $
d2005 1
a2005 1
    int char_sep = -1;
d2029 1
a2029 1
		char_sep = (unsigned char)RSTRING(spat)->ptr[0];
d2044 1
a2044 1
    if (char_sep >= 0) {
d2077 1
a2077 1
		if (*ptr == (char)char_sep) {
@


1.1.1.2.2.40
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/11 10:03:11 $
d347 1
d1094 1
a1094 1
		str_replace2(str, beg, end, str_to_str(val));
@


1.1.1.2.2.41
log
@str2cstr
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:41 $
d2008 2
a2009 1
    if (rb_scan_args(argc, argv, "02", &spat, &limit) == 2) {
d2016 1
a2016 1
    if (argc == 0) {
d2511 2
a2512 3
    if (rb_scan_args(argc, argv, "01", &vbits) == 0) {
	bits = 16;
    }
@


1.1.1.2.2.42
log
@substr() taint
@
text
@d6 1
a6 1
  $Date: 1998/07/13 04:37:56 $
a289 2
    VALUE str2;

d300 1
a300 4
    str2 = str_new(RSTRING(str)->ptr+start, len);
    if (str_tainted(str)) str_taint(str2);

    return str2;
d975 1
a975 1
    VALUE val, match, result;
d1001 1
a1001 2
	match = backref_get();
	regs = RMATCH(match)->regs;
d1004 1
a1004 1
	val = obj_as_string(rb_yield(reg_nth_match(0, match)));
d2394 1
a2394 1
    VALUE result, match;
d2399 1
a2399 2
	match = backref_get();
	regs = RMATCH(match)->regs;
d2407 1
a2407 1
	    return reg_nth_match(0, match);
d2411 6
a2416 1
	    ary_push(result, reg_nth_match(i, match));
@


1.1.1.2.2.43
log
@sync ev
@
text
@d6 1
a6 1
  $Date: 1998/07/17 00:53:48 $
a853 3
    if (RSTRING(str)->len < beg && len < 0) {
	MEMZERO(RSTRING(str)->ptr+RSTRING(str)->len, char, -len);
    }
d1410 1
a1410 1
	else if ((c & 0x80) && current_mbctype != MBCTYPE_EUC) {
@


1.1.1.2.2.44
log
@1.1c3
@
text
@d6 1
a6 1
  $Date: 1998/07/29 09:50:34 $
d865 1
a865 1
    VALUE str, val;
@


1.1.1.2.2.45
log
@euc-kana
@
text
@d6 1
a6 1
  $Date: 1998/08/27 03:55:32 $
d1469 1
a1469 1
	    sprintf(b, "%03o", c & 0377);
@


1.1.1.2.2.46
log
@1.1c5
@
text
@d6 1
a6 1
  $Date: 1998/09/01 02:53:51 $
d1591 1
a1591 1
    VALUE val = str_upcase_bang(str = str_dup(str));
d1625 1
a1625 1
    VALUE val = str_downcase_bang(str = str_dup(str));
d1661 1
a1661 1
    VALUE val = str_capitalize_bang(str = str_dup(str));
d1699 1
a1699 1
    VALUE val = str_swapcase_bang(str = str_dup(str));
d1854 1
a1854 1
    VALUE val = tr_trans(str = str_dup(str), src, repl, 0);
d1917 1
a1917 1
    VALUE val = str_delete_bang(str1 = str_dup(str1), str2);
d1981 1
a1981 1
    VALUE val = str_squeeze_bang(argc, argv, str = str_dup(str));
d1998 1
a1998 1
    VALUE val = tr_trans(str = str_dup(str), src, repl, 1);
d2195 1
d2197 1
a2197 1
	if (p[-1] == newline &&
d2199 2
a2200 2
	     memcmp(RSTRING(rs)->ptr, p-rslen, rslen) == 0)) {
	    line = str_new(s, p - s);
d2205 1
a2205 1
	    s = p;
d2253 1
a2253 1
    VALUE val = str_chop_bang(str = str_dup(str));
d2269 1
a2269 2
    VALUE str = str_dup(uscore_get());
    VALUE val;
d2271 4
a2274 4
    val = str_chop_bang(str);
    if (NIL_P(val)) return str;
    lastline_set(val);
    return val;
d2326 1
a2326 1
    VALUE val = str_chomp_bang(argc, argv, str = str_dup(str));
d2345 1
a2345 2
    VALUE str = str_dup(uscore_get());
    VALUE val = str_chomp_bang(argc, argv, str);
d2347 1
a2347 1
    if (NIL_P(val)) return str;
d2392 1
a2392 1
    VALUE val = str_strip_bang(str = str_dup(str));
@


1.1.1.2.2.47
log
@1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/09/08 09:17:42 $
d2411 2
a2412 5
	if (BEG(0) == END(0)) {
	    /*
	     * Always consume at least one character of the input string
	     */
	    *start = END(0)+(ismbchar(RSTRING(str)->ptr[END(0)])?2:1);
@


1.1.1.2.2.48
log
@1.1c7
@
text
@d6 1
a6 1
  $Date: 1998/10/06 02:45:03 $
d805 2
a806 2
	if (reg_match(indx, str))
	    return reg_last_match(backref_get());
d1554 1
a1554 1
	    sprintf(q, "%03o", c&0xff);
d2014 1
a2014 1
    int beg, end, i, lim = 0;
d2019 1
a2019 1
	if (lim <= 0) limit = Qnil;
d2122 2
a2123 3
		if (BEG(idx) == -1)
		    tmp = Qnil;
		else if (BEG(idx) == END(idx))
d2132 1
a2132 1
    if (!NIL_P(limit) || RSTRING(str)->len > beg || lim < 0) {
a2133 5
    }
    if (NIL_P(limit) && lim == 0) {
	while (RARRAY(result)->len > 0 &&
	       RSTRING(RARRAY(result)->ptr[RARRAY(result)->len-1])->len == 0)
	    ary_pop(result);
@


1.1.1.2.2.49
log
@1.2.4
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:51 $
a576 4
    if (offset < 0) {
	offset += RSTRING(str)->len;
	if (offset < 0) return -1;
    }
d581 1
a581 1
    e = RSTRING(str)->ptr + RSTRING(str)->len - len + 1;
d1477 1
a1477 1
static VALUE
d1491 1
a1491 1
	  case '"':  case '\\':
d1540 1
a1540 1
	else if (c == '\013') {
d1548 1
a1548 1
	else if (c == '\033') {
@


1.1.1.2.2.50
log
@to open CVS
@
text
@d6 1
a6 1
  $Date: 1999/04/08 10:14:34 $
d1497 1
a1497 1
	  case '\t': case '\f': case '#':
a1523 4
	}
	else if (c == '#') {
	    *q++ = '\\';
	    *q++ = '#';
@


1.1.1.2.2.51
log
@moving
@
text
@d6 1
a6 1
  $Date: 1999/04/20 08:20:56 $
d1417 4
d1761 1
a1761 1
    int i, c, modify = 0;
d1765 1
a1765 1
    if (TYPE(src) != T_STRING) src = str_to_str(src);
d1767 1
a1767 1
    if (RSTRING(src)->len >= 2 && RSTRING(src)->ptr[0] == '^') {
d1771 1
a1771 1
    if (TYPE(repl) != T_STRING) repl = str_to_str(repl);
a1785 2
	while ((c = trnext(&trrepl)) >= 0)
	    /* retrieve last replacer */;
d1787 11
a1797 2
	    if (trans[i] != 0) {
		trans[i] = trrepl.now;
d1805 1
a1805 1
	    trans[i] = 0;
d1815 1
a1817 1
	int c0, last = -1;
d1820 7
a1826 4
	    c0 = *s++;
	    if ((c = trans[c0 & 0xff] & 0xff) != 0) {
		if (last == c) continue;
		last = c;
a1827 5
		modify = 1;
	    }
	    else {
		last = -1;
		*t++ = c0;
d1838 2
a1839 1
	    if ((c = trans[*s++ & 0xff] & 0xff) != 0) {
d1843 1
d1963 1
a1963 4
    if (t - RSTRING(str1)->ptr != RSTRING(str1)->len) {
	RSTRING(str1)->len = t - RSTRING(str1)->ptr;
	modify = 1;
    }
@


1.1.1.2.2.52
log
@1.2.6
@
text
@d6 1
a6 1
  $Date: 1999/05/14 08:56:48 $
d728 1
a728 1
    int c = -1;
d1172 1
a1172 1
    if (NIL_P(v)) return str;
d1204 1
a1204 1
    if (NIL_P(v)) return str;
d1297 2
a1298 4
    if (!NIL_P(v)) {
	lastline_set(v);
	line = v;
    }
d1300 1
a1300 1
    return line;
d1595 1
a1595 1
    VALUE val = str_upcase_bang(str_dup(str));
d1629 1
a1629 1
    VALUE val = str_downcase_bang(str_dup(str));
d1665 1
a1665 1
    VALUE val = str_capitalize_bang(str_dup(str));
d1703 1
a1703 1
    VALUE val = str_swapcase_bang(str_dup(str));
d1756 1
a1756 1
    int trans[256];
d1768 1
a1768 3
    if (RSTRING(repl)->len == 0) {
	return str_delete_bang(str, src);
    }
d1780 1
a1780 1
	    trans[c & 0xff] = -1;
d1785 1
a1785 1
	    if (trans[i] >= 0) {
d1791 1
a1791 1
	int r;
d1794 1
a1794 1
	    trans[i] = -1;
d1810 1
a1810 1
	    if ((c = trans[c0 & 0xff]) >= 0) {
d1813 1
a1813 1
		*t++ = c & 0xff;
d1829 2
a1830 2
	    if ((c = trans[*s & 0xff]) >= 0) {
		*s = c & 0xff;
a1832 1
	    s++;
d1851 1
a1851 1
    VALUE val = tr_trans(str_dup(str), src, repl, 0);
d1914 1
a1914 1
    VALUE val = str_delete_bang(str_dup(str1), str2);
d1981 1
a1981 1
    VALUE val = str_squeeze_bang(argc, argv, str_dup(str));
d1998 1
a1998 1
    VALUE val = tr_trans(str_dup(str), src, repl, 1);
d2258 1
a2258 1
    VALUE val = str_chop_bang(str_dup(str));
d2274 1
a2274 1
    VALUE str = uscore_get();
d2277 1
a2277 1
    val = str_chop_bang(str_dup(str));
d2332 1
a2332 1
    VALUE val = str_chomp_bang(argc, argv, str_dup(str));
d2351 2
a2352 2
    VALUE str = uscore_get();
    VALUE val = str_chomp_bang(argc, argv, str_dup(str));
d2399 1
a2399 1
    VALUE val = str_strip_bang(str_dup(str));
@


1.1.1.2.2.45.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/09/01 02:53:51 $
d25 3
a27 1
VALUE rb_cString;
d33 1
a33 1
extern VALUE rb_rs;
d36 1
a36 1
rb_str_new(ptr, len)
d41 1
a41 1
    OBJSETUP(str, rb_cString, T_STRING);
d58 1
a58 1
rb_str_new2(ptr)
d61 1
a61 1
    return rb_str_new(ptr, strlen(ptr));
d65 1
a65 1
rb_str_new3(str)
d69 1
a69 1
    OBJSETUP(str2, rb_cString, T_STRING);
d83 1
a83 1
rb_str_new4(orig)
d90 1
a90 1
	return rb_str_freeze(RSTRING(orig)->orig);
d94 1
a94 1
	OBJSETUP(str, rb_cString, T_STRING);
d108 1
a108 1
rb_str_to_str(str)
d115 1
a115 1
rb_str_assign(str, str2)
d132 1
a132 1
    if (rb_str_tainted(str2)) rb_str_taint(str);
d138 1
a138 1
rb_obj_as_string(obj)
d148 1
a148 1
	return rb_any_to_s(obj);
d153 1
a153 1
rb_str_clone(orig)
d159 1
a159 1
	str = rb_str_new3(RSTRING(orig)->orig);
d161 1
a161 1
	str = rb_str_new(RSTRING(orig)->ptr, RSTRING(orig)->len);
d169 1
a169 1
rb_str_dup(str)
d174 3
a176 3
    if (TYPE(str) != T_STRING) str = rb_str_to_str(str);
    s = rb_str_new(RSTRING(str)->ptr, RSTRING(str)->len);
    if (rb_str_tainted(str)) s = rb_str_taint(s);
d183 1
a183 1
rb_str_s_new(klass, orig)
d190 1
a190 2
    str->orig = 0;
    orig = rb_obj_as_string(orig);
d192 2
a193 2
    if (RSTRING(orig)->ptr) {
	str->ptr = ALLOC_N(char, RSTRING(orig)->len+1);
a194 1
	str->ptr[RSTRING(orig)->len] = '\0';
d196 2
d202 1
a202 1
    rb_obj_call_init((VALUE)str);
d208 1
a208 1
rb_str_length(str)
d215 1
a215 1
rb_str_empty(str)
d219 2
a220 2
	return Qtrue;
    return Qfalse;
d224 1
a224 1
rb_str_plus(str1, str2)
d229 2
a230 2
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
    str3 = rb_str_new(0, RSTRING(str1)->len+RSTRING(str2)->len);
d232 1
a232 2
    memcpy(RSTRING(str3)->ptr + RSTRING(str1)->len,
	   RSTRING(str2)->ptr, RSTRING(str2)->len);
d235 2
a236 2
    if (rb_str_tainted(str1) || rb_str_tainted(str2))
	return rb_str_taint(str3);
d241 1
a241 1
rb_str_times(str, times)
d250 1
a250 1
	rb_raise(rb_eArgError, "negative argument");
d253 1
a253 1
    str2 = rb_str_new(0, RSTRING(str)->len*len);
d255 1
a255 2
	memcpy(RSTRING(str2)->ptr+(i*RSTRING(str)->len),
	       RSTRING(str)->ptr, RSTRING(str)->len);
d259 2
a260 2
    if (rb_str_tainted(str)) {
	return rb_str_taint(str2);
d266 2
a267 2
static VALUE
rb_str_format(str, arg)
d276 1
a276 1
	return rb_f_sprintf(RARRAY(arg)->len+1, argv);
d282 1
a282 1
    return rb_f_sprintf(2, argv);
d286 1
a286 1
rb_str_substr(str, start, len)
d296 1
a296 1
	return rb_str_new(0,0);
d302 2
a303 2
    str2 = rb_str_new(RSTRING(str)->ptr+start, len);
    if (rb_str_tainted(str)) rb_str_taint(str2);
d309 1
a309 1
rb_str_subseq(str, beg, end)
d316 1
a316 1
	rb_raise(rb_eIndexError, "end smaller than beg [%d..%d]", beg, end);
d332 1
a332 1
	return rb_str_new(0, 0);
d340 1
a340 1
    return rb_str_substr(str, beg, len);
d343 2
d346 1
a346 1
rb_str_modify(str)
d352 1
a352 1
	rb_raise(rb_eSecurityError, "cannot change string status");
d355 1
a355 1
	rb_raise(rb_eTypeError, "can't modify frozen string");
d367 1
a367 1
rb_str_freeze(str)
d375 1
a375 1
rb_str_frozen_p(str)
d379 2
a380 2
	return Qtrue;
    return Qfalse;
d384 1
a384 1
rb_str_dup_frozen(str)
d388 1
a388 1
	return rb_str_freeze(RSTRING(str)->orig);
d392 1
a392 1
    return rb_str_freeze(rb_str_dup(str));
d396 1
a396 1
rb_str_taint(str)
d406 1
a406 1
rb_str_tainted(str)
d410 2
a411 2
	return Qtrue;
    return Qfalse;
d415 1
a415 1
rb_str_resize(str, len)
d419 1
a419 1
    rb_str_modify(str);
d432 1
a432 1
rb_str_cat(str, ptr, len)
d438 1
a438 1
	rb_str_modify(str);
d449 1
a449 1
rb_str_concat(str1, str2)
d452 2
a453 2
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
    rb_str_cat(str1, RSTRING(str2)->ptr, RSTRING(str2)->len);
d458 1
a458 1
rb_str_hash(str)
d465 1
a465 1
    if (rb_ignorecase_p()) {
d481 1
a481 1
rb_str_hash_method(str)
d484 1
a484 1
    int key = rb_str_hash(str);
d491 1
a491 1
rb_str_cmp(str1, str2)
d497 2
a498 2
    if (rb_ignorecase_p()) {
	return rb_str_cicmp(str1, str2);
d514 1
a514 1
rb_str_equal(str1, str2)
d518 1
a518 1
	return Qfalse;
d521 2
a522 2
	&& rb_str_cmp(str1, str2) == 0) {
	return Qtrue;
d524 1
a524 1
    return Qfalse;
d528 1
a528 1
rb_str_cmp_method(str1, str2)
d533 2
a534 2
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
    result = rb_str_cmp(str1, str2);
d539 1
a539 1
rb_str_match(x, y)
d547 1
a547 1
	return rb_reg_match(y, x);
d550 2
a551 2
	reg = rb_reg_regcomp(y);
	start = rb_reg_search(reg, x, 0, 0);
d553 1
a553 1
	    return Qfalse;
d563 1
a563 1
rb_str_match2(str)
d566 1
a566 1
    return rb_reg_match2(rb_reg_regcomp(str));
d570 1
a570 1
rb_str_index(str, sub, offset)
d592 1
a592 1
rb_str_index_method(argc, argv, str)
d610 1
a610 1
	pos = rb_reg_search(sub, str, pos, 0);
d614 1
a614 1
	pos = rb_str_index(str, sub, pos);
d630 1
a630 2
	rb_raise(rb_eTypeError, "Type mismatch: %s given",
		 rb_class2name(CLASS_OF(sub)));
d638 1
a638 1
rb_str_rindex(argc, argv, str)
d658 1
a658 1
	pos = rb_reg_search(sub, str, pos, 1);
d688 1
a688 2
	rb_raise(rb_eTypeError, "Type mismatch: %s given",
		 rb_class2name(CLASS_OF(sub)));
d719 1
a719 1
rb_str_succ(orig)
d726 1
a726 1
    str = rb_str_new(RSTRING(orig)->ptr, RSTRING(orig)->len);
d739 1
a739 1
	    str2 = rb_str_new(0, RSTRING(str)->len+1);
d746 2
a747 2
    if (rb_str_tainted(orig)) {
	return rb_str_taint(str);
d754 1
a754 1
rb_str_succ_bang(str)
d757 2
a758 2
    rb_str_modify(str);
    rb_str_assign(str, rb_str_succ(str));
d764 1
a764 1
rb_str_upto(beg, end)
d769 1
a769 1
    if (TYPE(end) != T_STRING) end = rb_str_to_str(end);
d776 2
a777 2
	if (rb_str_equal(current, end)) break;
	current = rb_str_succ(current);
d786 1
a786 1
rb_str_aref(str, indx)
d805 2
a806 2
	if (rb_str_match(str, indx))
	    return rb_reg_last_match(0);
d810 1
a810 1
	if (rb_str_index(str, indx, 0) != -1) return indx;
d817 2
a818 2
	    if (rb_range_beg_end(indx, &beg, &end)) {
		return rb_str_subseq(str, beg, end);
d821 1
a821 1
	rb_raise(rb_eIndexError, "Invalid index for string");
d826 1
a826 1
rb_str_aref_method(argc, argv, str)
d834 1
a834 1
	return rb_str_substr(str, NUM2INT(arg1), NUM2INT(arg2));
d836 1
a836 1
    return rb_str_aref(str, arg1);
d840 1
a840 1
rb_str_replace(str, beg, len, val)
d850 3
a852 3
	memmove(RSTRING(str)->ptr + beg + RSTRING(val)->len,
		RSTRING(str)->ptr + beg + len,
		RSTRING(str)->len - (beg + len));
d855 1
a855 1
	MEMZERO(RSTRING(str)->ptr + RSTRING(str)->len, char, -len);
d862 1
a862 1
/* rb_str_replace2() understands negatice offset */
d864 1
a864 1
rb_str_replace2(str, beg, end, val)
d871 1
a871 1
	rb_raise(rb_eIndexError, "end smaller than beg [%d..%d]", beg, end);
d897 78
a974 1
    rb_str_replace(str, beg, len, val);
d977 65
a1041 1
static VALUE rb_str_sub_bang _((int, VALUE*, VALUE));
d1044 17
a1060 1
rb_str_aset(str, indx, val)
d1073 1
a1073 2
	    rb_raise(rb_eIndexError, "index %d out of range [0..%d]", idx,
		     RSTRING(str)->len - 1);
d1076 1
a1076 1
	    rb_str_replace(str, idx, 1, val);
d1084 1
a1084 6
        {
	    VALUE args[2];
	    args[0] = indx;
	    args[1] = val;
	    rb_str_sub_bang(2, args, str);
	}
d1089 4
a1092 4
	     (beg=rb_str_index(str, indx, offset)) >= 0;
	     offset=beg+RSTRING(val)->len) {
	    end = beg + RSTRING(indx)->len - 1;
	    rb_str_replace2(str, beg, end, val);
d1101 2
a1102 3
	    if (rb_range_beg_end(indx, &beg, &end)) {
		if (TYPE(val) != T_STRING) val = rb_str_to_str(val);
		rb_str_replace2(str, beg, end, val);
d1106 1
a1106 1
	rb_raise(rb_eIndexError, "Invalid index for string");
d1111 1
a1111 1
rb_str_aset_method(argc, argv, str)
d1118 1
a1118 1
    rb_str_modify(str);
d1123 1
a1123 1
	if (TYPE(arg3) != T_STRING) arg3 = rb_str_to_str(arg3);
d1130 1
a1130 1
	if (len < 0) rb_raise(rb_eIndexError, "negative length %d", len);
d1134 1
a1134 1
	rb_str_replace(str, beg, len, arg3);
d1137 1
a1137 1
    return rb_str_aset(str, arg1, arg2);
d1141 4
a1144 2
get_pat(pat)
    VALUE pat;
d1146 1
a1146 7
    switch (TYPE(pat)) {
      case T_REGEXP:
	break;

      case T_STRING:
	pat = rb_reg_regcomp(pat);
	break;
d1148 2
a1149 3
      default:
	/* type failed */
	Check_Type(pat, T_REGEXP);
d1151 1
a1151 1
    return pat;
d1155 1
a1155 1
rb_str_sub_bang(argc, argv, str)
d1160 1
a1160 4
    VALUE pat, repl, match;
    struct re_registers *regs;
    int iter = 0;
    int plen;
d1162 2
a1163 5
    if (rb_scan_args(argc, argv, "11", &pat, &repl) == 1) {
	if (!rb_iterator_p()) {
	    rb_raise(rb_eArgError, "Wrong # of arguments(1 for 2)");
	}
	iter = 1;
d1166 1
a1166 1
	repl = rb_obj_as_string(repl);
d1168 2
a1169 29

    pat = get_pat(pat);
    if (rb_reg_search(pat, str, 0, 0) >= 0) {
	rb_str_modify(str);
	match = rb_backref_get();
	regs = RMATCH(match)->regs;

	if (iter) {
	    repl = rb_obj_as_string(rb_yield(rb_reg_nth_match(0, match)));
	}
	else {
	    repl = rb_reg_regsub(repl, str, regs);
	}
	plen = END(0) - BEG(0);
	if (RSTRING(repl)->len > plen) {
	    REALLOC_N(RSTRING(str)->ptr, char,
		      RSTRING(str)->len + RSTRING(repl)->len - plen + 1);
	}
	if (RSTRING(repl)->len != plen) {
	    memmove(RSTRING(str)->ptr + BEG(0) + RSTRING(repl)->len,
		    RSTRING(str)->ptr + BEG(0) + plen,
		    RSTRING(str)->len - BEG(0) - plen);
	}
	memcpy(RSTRING(str)->ptr + BEG(0),
	       RSTRING(repl)->ptr, RSTRING(repl)->len);
	RSTRING(str)->len += RSTRING(repl)->len - plen;
	return str;
    }
    return Qnil;
d1173 1
a1173 1
rb_str_sub(argc, argv, str)
d1178 1
a1178 1
    VALUE val = rb_str_sub_bang(argc, argv, rb_str_dup(str));
d1180 4
a1183 2
    if (NIL_P(val)) return str;
    return val;
d1187 1
a1187 1
rb_str_gsub_bang(argc, argv, str)
d1192 4
a1195 12
    VALUE pat, val, repl, match;
    struct re_registers *regs;
    int beg, offset, n;
    int iter = 0;
    char *buf, *bp, *cp;
    int blen, len;

    if (rb_scan_args(argc, argv, "11", &pat, &repl) == 1) {
	if (!rb_iterator_p()) {
	    rb_raise(rb_eArgError, "Wrong # of arguments(1 for 2)");
	}
	iter = 1;
d1198 1
a1198 1
	repl = rb_obj_as_string(repl);
d1200 2
a1201 80

    pat = get_pat(pat);
    offset=0; n=0; 
    beg = rb_reg_search(pat, str, 0, 0);
    if (beg < 0) return Qnil;	/* no match, no substitution */

    blen = RSTRING(str)->len + 30; /* len + margin */
    buf = ALLOC_N(char, blen);
    bp = buf;
    cp = RSTRING(str)->ptr;

    while (beg >= 0) {
	n++;
	match = rb_backref_get();
	regs = RMATCH(match)->regs;
	if (iter) {
	    val = rb_obj_as_string(rb_yield(rb_reg_nth_match(0, match)));
	}
	else {
	    val = rb_reg_regsub(repl, str, regs);
	}
	len = beg + RSTRING(val)->len + 3;
	if (blen < len) {
	    while (blen < len) blen *= 2;
	    len = bp - buf;
	    REALLOC_N(buf, char, blen);
	    bp = buf + len;
	}
	len = beg - offset;	/* copy pre-match substr */
	memcpy(bp, cp, len);
	bp += len;
	memcpy(bp, RSTRING(val)->ptr, RSTRING(val)->len);
	bp += RSTRING(val)->len;
	if (BEG(0) == END(0)) {
	    /*
	     * Always consume at least one character of the input string
	     * in order to prevent infinite loops.
	     */
	    len = ismbchar(RSTRING(str)->ptr[END(0)])?2:1;
	    if (RSTRING(str)->len > END(0)) {
		memcpy(bp, RSTRING(str)->ptr, len);
		bp += len;
	    }
	    offset = END(0) + len;
	}
	else {
	    offset = END(0);
	}
	cp = RSTRING(str)->ptr + offset;
	if (offset > RSTRING(str)->len) break;
	beg = rb_reg_search(pat, str, offset, 0);
    }
    if (RSTRING(str)->len > offset) {
	len = bp - buf;
	if (blen - len < RSTRING(str)->len - offset) {
	    REALLOC_N(buf, char, len + RSTRING(str)->len - offset + 1);
	    bp = buf + len;
	}
	memcpy(bp, cp, RSTRING(str)->len - offset);
	bp += RSTRING(str)->len - offset;
    }
    rb_str_modify(str);
    free(RSTRING(str)->ptr);
    RSTRING(str)->ptr = buf;
    RSTRING(str)->len = len = bp - buf;
    RSTRING(str)->ptr[len] = '\0';

    return str;
}

static VALUE
rb_str_gsub(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE val = rb_str_gsub_bang(argc, argv, rb_str_dup(str));

    if (NIL_P(val)) return str;
    return val;
d1205 1
a1205 1
rb_str_replace_method(str, str2)
d1208 3
a1210 3
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
    rb_str_modify(str);
    rb_str_resize(str, RSTRING(str2)->len);
d1212 1
a1212 1
    if (rb_str_tainted(str2)) rb_str_taint(str);
d1222 1
a1222 1
    line = rb_lastline_get();
d1224 2
a1225 2
	rb_raise(rb_eTypeError, "$_ value need to be String (%s given)",
		 rb_class2name(CLASS_OF(line)));
d1231 1
a1231 1
rb_f_sub_bang(argc, argv)
d1235 7
a1241 1
    return rb_str_sub_bang(argc, argv, uscore_get());
d1245 1
a1245 1
rb_f_sub(argc, argv)
d1249 1
a1249 1
    VALUE line, v;
d1252 6
a1257 1
    v = rb_str_sub_bang(argc, argv, line);
d1259 1
a1259 1
	rb_lastline_set(v);
d1266 1
a1266 1
rb_f_gsub_bang(argc, argv)
d1270 7
a1276 1
    return rb_str_gsub_bang(argc, argv, uscore_get());
d1280 1
a1280 1
rb_f_gsub(argc, argv)
d1284 1
a1284 1
    VALUE line, v;
d1287 5
a1291 4
    v = rb_str_gsub_bang(argc, argv, line);
    if (!NIL_P(v)) {
	rb_lastline_set(v);
	return v;
d1293 4
a1296 1
    return line;
d1300 1
a1300 1
rb_str_reverse_bang(str)
d1318 1
a1318 1
rb_str_reverse(str)
d1326 1
a1326 1
    obj = rb_str_new(0, RSTRING(str)->len);
d1338 1
a1338 1
rb_str_include(str, arg)
d1353 1
a1353 1
	return Qfalse;
d1356 1
a1356 2
    if (TYPE(arg) != T_STRING) arg = rb_str_to_str(arg);
    i = rb_str_index(str, arg, 0);
d1358 1
a1358 1
    if (i == -1) return Qfalse;
d1363 1
a1363 1
rb_str_to_i(str)
d1366 1
a1366 1
    return rb_str2inum(RSTRING(str)->ptr, 10);
d1370 1
a1370 1
rb_str_to_f(str)
d1375 1
a1375 1
    return rb_float_new(f);
d1379 1
a1379 1
rb_str_to_s(str)
d1386 1
a1386 1
rb_str_inspect(str)
d1474 1
a1474 1
    return rb_str_new(buf, b - buf);
d1477 2
a1478 2
static VALUE
rb_str_dump(str)
d1509 1
a1509 1
    result = rb_str_new(0, len);
d1564 1
a1564 1
rb_str_upcase_bang(str)
d1570 1
a1570 1
    rb_str_modify(str);
d1588 1
a1588 1
rb_str_upcase(str)
d1591 1
a1591 1
    VALUE val = rb_str_upcase_bang(rb_str_dup(str));
d1598 1
a1598 1
rb_str_downcase_bang(str)
d1604 1
a1604 1
    rb_str_modify(str);
d1622 1
a1622 1
rb_str_downcase(str)
d1625 1
a1625 1
    VALUE val = rb_str_downcase_bang(rb_str_dup(str));
d1632 1
a1632 1
rb_str_capitalize_bang(str)
d1638 1
a1638 1
    rb_str_modify(str);
d1658 1
a1658 1
rb_str_capitalize(str)
d1661 1
a1661 1
    VALUE val = rb_str_capitalize_bang(rb_str_dup(str));
d1668 1
a1668 1
rb_str_swapcase_bang(str)
d1674 1
a1674 1
    rb_str_modify(str);
d1696 1
a1696 1
rb_str_swapcase(str)
d1699 1
a1699 1
    VALUE val = rb_str_swapcase_bang(rb_str_dup(str));
d1743 1
a1743 1
static VALUE rb_str_delete_bang _((VALUE,VALUE));
d1756 2
a1757 2
    rb_str_modify(str);
    if (TYPE(src) != T_STRING) src = rb_str_to_str(src);
d1763 2
a1764 2
    if (TYPE(repl) != T_STRING) repl = rb_str_to_str(repl);
    if (RSTRING(repl)->len == 0) return rb_str_delete_bang(str, src);
d1844 1
a1844 1
rb_str_tr_bang(str, src, repl)
d1851 1
a1851 1
rb_str_tr(str, src, repl)
d1854 1
a1854 1
    VALUE val = tr_trans(rb_str_dup(str), src, repl, 0);
d1885 1
a1885 1
rb_str_delete_bang(str1, str2)
d1892 1
a1892 1
    if (TYPE(str2) != T_STRING) str2 = rb_str_to_str(str2);
d1895 1
a1895 1
    rb_str_modify(str1);
d1914 1
a1914 1
rb_str_delete(str1, str2)
d1917 1
a1917 1
    VALUE val = rb_str_delete_bang(rb_str_dup(str1), str2);
d1942 1
a1942 1
    rb_str_modify(str1);
d1962 1
a1962 1
rb_str_squeeze_bang(argc, argv, str1)
d1969 2
a1970 2
    if (rb_scan_args(argc, argv, "01", &str2) == 1 && TYPE(str2) != T_STRING) {
	str2 = rb_str_to_str(str2);
d1976 1
a1976 1
rb_str_squeeze(argc, argv, str)
d1981 1
a1981 1
    VALUE val = rb_str_squeeze_bang(argc, argv, rb_str_dup(str));
d1988 1
a1988 1
rb_str_tr_s_bang(str, src, repl)
d1995 1
a1995 1
rb_str_tr_s(str, src, repl)
d1998 1
a1998 1
    VALUE val = tr_trans(rb_str_dup(str), src, repl, 1);
d2005 1
a2005 1
rb_str_split_method(argc, argv, str)
d2010 1
d2020 1
a2020 1
	else if (lim == 1) return rb_ary_new3(1, str);
d2025 2
a2026 2
	if (!NIL_P(rb_fs)) {
	    spat = rb_fs;
d2035 1
a2035 1
	    if (RSTRING(spat)->len == 1) {
d2039 1
a2039 1
		spat = rb_reg_regcomp(spat);
d2045 1
a2045 1
	    rb_raise(rb_eArgError, "split(): bad separator");
d2049 1
a2049 1
    result = rb_ary_new();
d2071 1
a2071 1
			rb_ary_push(result, rb_str_substr(str, beg, end-beg));
d2085 1
a2085 1
		    rb_ary_push(result, rb_str_substr(str, beg, end-beg));
d2099 2
a2100 2
	while ((end = rb_reg_search(spat, str, start, 0)) >= 0) {
	    regs = RMATCH(rb_backref_get())->regs;
d2104 1
a2104 1
			rb_ary_push(result, rb_str_substr(str, beg, 2));
d2106 1
a2106 1
			rb_ary_push(result, rb_str_substr(str, beg, 1));
d2116 1
a2116 1
		rb_ary_push(result, rb_str_substr(str, beg, end-beg));
d2124 1
a2124 1
		    tmp = rb_str_new(0, 0);
d2126 2
a2127 2
		    tmp = rb_str_subseq(str, BEG(idx), END(idx)-1);
		rb_ary_push(result, tmp);
d2133 1
a2133 1
	rb_ary_push(result, rb_str_subseq(str, beg, -1));
d2140 1
a2140 1
rb_str_split(str, sep0)
d2146 3
a2148 3
    if (TYPE(str) != T_STRING) str = rb_str_to_str(str);
    sep = rb_str_new2(sep0);
    return rb_str_split_method(1, &sep, str);
d2152 1
a2152 1
rb_f_split(argc, argv)
d2156 1
a2156 1
    return rb_str_split_method(argc, argv, uscore_get());
d2160 1
a2160 1
rb_str_each_line(argc, argv, str)
d2174 1
a2174 1
	rs = rb_rs;
d2181 1
a2181 1
    if (TYPE(rs) != T_STRING) rs = rb_str_to_str(rs);
d2200 2
a2201 2
	    line = rb_str_new(s, p - s + 1);
	    rb_lastline_set(line);
d2204 1
a2204 1
		rb_raise(rb_eArgError, "string modified");
d2210 2
a2211 2
	line = rb_str_new(s, p - s);
	rb_lastline_set(line);
d2219 1
a2219 1
rb_str_each_byte(str)
d2231 1
a2231 1
rb_str_chop_bang(str)
d2235 1
a2235 1
	rb_str_modify(str);
d2250 1
a2250 1
rb_str_chop(str)
d2253 1
a2253 1
    VALUE val = rb_str_chop_bang(rb_str_dup(str));
d2260 1
a2260 1
rb_f_chop_bang(str)
d2263 1
a2263 1
    return rb_str_chop_bang(uscore_get());
d2267 1
a2267 1
rb_f_chop()
d2271 1
a2271 1
    str = rb_str_chop_bang(rb_str_dup(str));
d2273 1
a2273 1
    rb_lastline_set(str);
d2278 1
a2278 1
rb_str_chomp_bang(argc, argv, str)
d2290 1
a2290 1
	rs = rb_rs;
d2294 1
a2294 1
    if (TYPE(rs) != T_STRING) rs = rb_str_to_str(rs);
d2321 1
a2321 1
rb_str_chomp(argc, argv, str)
d2326 1
a2326 1
    VALUE val = rb_str_chomp_bang(argc, argv, rb_str_dup(str));
d2333 1
a2333 1
rb_f_chomp_bang(argc, argv)
d2337 1
a2337 1
    return rb_str_chomp_bang(argc, argv, uscore_get());
d2341 1
a2341 1
rb_f_chomp(argc, argv)
d2345 1
a2345 1
    VALUE val = rb_str_chomp_bang(argc, argv, rb_str_dup(uscore_get()));
d2348 1
a2348 1
    rb_lastline_set(val);
d2353 1
a2353 1
rb_str_strip_bang(str)
d2358 1
a2358 1
    rb_str_modify(str);
d2389 1
a2389 1
rb_str_strip(str)
d2392 1
a2392 1
    VALUE val = rb_str_strip_bang(rb_str_dup(str));
d2407 2
a2408 2
    if (rb_reg_search(pat, str, *start, 0) >= 0) {
	match = rb_backref_get();
d2417 1
a2417 1
	    return rb_reg_nth_match(0, match);
d2419 1
a2419 1
	result = rb_ary_new2(regs->num_regs);
d2421 1
a2421 1
	    rb_ary_push(result, rb_reg_nth_match(i, match));
d2430 1
a2430 1
rb_str_scan(str, pat)
d2436 12
a2447 3
    pat = get_pat(pat);
    if (!rb_iterator_p()) {
	VALUE ary = rb_ary_new();
d2450 1
a2450 1
	    rb_ary_push(ary, result);
d2462 1
a2462 1
rb_str_hex(str)
d2465 1
a2465 1
    return rb_str2inum(RSTRING(str)->ptr, 16);
d2469 1
a2469 1
rb_str_oct(str)
d2478 1
a2478 1
    return rb_str2inum(RSTRING(str)->ptr, base);
d2482 1
a2482 1
rb_str_crypt(str, salt)
d2487 1
a2487 1
    if (TYPE(salt) != T_STRING) salt = rb_str_to_str(salt);
d2489 2
a2490 2
	rb_raise(rb_eArgError, "salt too short(need >2 bytes)");
    return rb_str_new2(crypt(RSTRING(str)->ptr, RSTRING(salt)->ptr));
d2494 1
a2494 1
rb_str_intern(str)
d2500 1
a2500 1
	rb_raise(rb_eArgError, "string contains `\\0'");
d2506 1
a2506 1
rb_str_sum(argc, argv, str)
d2547 1
a2547 1
	return rb_int2inum(res);
d2552 1
a2552 1
rb_str_ljust(str, w)
d2561 1
a2561 1
    res = rb_str_new(0, width);
d2571 1
a2571 1
rb_str_rjust(str, w)
d2580 1
a2580 1
    res = rb_str_new(0, width);
d2590 1
a2590 1
rb_str_center(str, w)
d2600 1
a2600 1
    res = rb_str_new(0, width);
d2617 104
a2720 104
    rb_cString  = rb_define_class("String", rb_cObject);
    rb_include_module(rb_cString, rb_mComparable);
    rb_include_module(rb_cString, rb_mEnumerable);
    rb_define_singleton_method(rb_cString, "new", rb_str_s_new, 1);
    rb_define_method(rb_cString, "clone", rb_str_clone, 0);
    rb_define_method(rb_cString, "dup", rb_str_dup, 0);
    rb_define_method(rb_cString, "<=>", rb_str_cmp_method, 1);
    rb_define_method(rb_cString, "==", rb_str_equal, 1);
    rb_define_method(rb_cString, "===", rb_str_equal, 1);
    rb_define_method(rb_cString, "eql?", rb_str_equal, 1);
    rb_define_method(rb_cString, "hash", rb_str_hash_method, 0);
    rb_define_method(rb_cString, "+", rb_str_plus, 1);
    rb_define_method(rb_cString, "*", rb_str_times, 1);
    rb_define_method(rb_cString, "%", rb_str_format, 1);
    rb_define_method(rb_cString, "[]", rb_str_aref_method, -1);
    rb_define_method(rb_cString, "[]=", rb_str_aset_method, -1);
    rb_define_method(rb_cString, "length", rb_str_length, 0);
    rb_define_alias(rb_cString,  "size", "length");
    rb_define_method(rb_cString, "empty?", rb_str_empty, 0);
    rb_define_method(rb_cString, "=~", rb_str_match, 1);
    rb_define_method(rb_cString, "~", rb_str_match2, 0);
    rb_define_method(rb_cString, "succ", rb_str_succ, 0);
    rb_define_method(rb_cString, "succ!", rb_str_succ_bang, 0);
    rb_define_method(rb_cString, "next", rb_str_succ, 0);
    rb_define_method(rb_cString, "next!", rb_str_succ_bang, 0);
    rb_define_method(rb_cString, "upto", rb_str_upto, 1);
    rb_define_method(rb_cString, "index", rb_str_index_method, -1);
    rb_define_method(rb_cString, "rindex", rb_str_rindex, -1);
    rb_define_method(rb_cString, "replace", rb_str_replace_method, 1);

    rb_define_method(rb_cString, "freeze", rb_str_freeze, 0);
    rb_define_method(rb_cString, "frozen?", rb_str_frozen_p, 0);

    rb_define_method(rb_cString, "taint", rb_str_taint, 0);
    rb_define_method(rb_cString, "tainted?", rb_str_tainted, 0);

    rb_define_method(rb_cString, "to_i", rb_str_to_i, 0);
    rb_define_method(rb_cString, "to_f", rb_str_to_f, 0);
    rb_define_method(rb_cString, "to_s", rb_str_to_s, 0);
    rb_define_method(rb_cString, "to_str", rb_str_to_s, 0);
    rb_define_method(rb_cString, "inspect", rb_str_inspect, 0);
    rb_define_method(rb_cString, "dump", rb_str_dump, 0);

    rb_define_method(rb_cString, "upcase", rb_str_upcase, 0);
    rb_define_method(rb_cString, "downcase", rb_str_downcase, 0);
    rb_define_method(rb_cString, "capitalize", rb_str_capitalize, 0);
    rb_define_method(rb_cString, "swapcase", rb_str_swapcase, 0);

    rb_define_method(rb_cString, "upcase!", rb_str_upcase_bang, 0);
    rb_define_method(rb_cString, "downcase!", rb_str_downcase_bang, 0);
    rb_define_method(rb_cString, "capitalize!", rb_str_capitalize_bang, 0);
    rb_define_method(rb_cString, "swapcase!", rb_str_swapcase_bang, 0);

    rb_define_method(rb_cString, "hex", rb_str_hex, 0);
    rb_define_method(rb_cString, "oct", rb_str_oct, 0);
    rb_define_method(rb_cString, "split", rb_str_split_method, -1);
    rb_define_method(rb_cString, "reverse", rb_str_reverse, 0);
    rb_define_method(rb_cString, "reverse!", rb_str_reverse_bang, 0);
    rb_define_method(rb_cString, "concat", rb_str_concat, 1);
    rb_define_method(rb_cString, "<<", rb_str_concat, 1);
    rb_define_method(rb_cString, "crypt", rb_str_crypt, 1);
    rb_define_method(rb_cString, "intern", rb_str_intern, 0);

    rb_define_method(rb_cString, "include?", rb_str_include, 1);

    rb_define_method(rb_cString, "scan", rb_str_scan, 1);

    rb_define_method(rb_cString, "ljust", rb_str_ljust, 1);
    rb_define_method(rb_cString, "rjust", rb_str_rjust, 1);
    rb_define_method(rb_cString, "center", rb_str_center, 1);

    rb_define_method(rb_cString, "sub", rb_str_sub, -1);
    rb_define_method(rb_cString, "gsub", rb_str_gsub, -1);
    rb_define_method(rb_cString, "chop", rb_str_chop, 0);
    rb_define_method(rb_cString, "chomp", rb_str_chomp, -1);
    rb_define_method(rb_cString, "strip", rb_str_strip, 0);

    rb_define_method(rb_cString, "sub!", rb_str_sub_bang, -1);
    rb_define_method(rb_cString, "gsub!", rb_str_gsub_bang, -1);
    rb_define_method(rb_cString, "strip!", rb_str_strip_bang, 0);
    rb_define_method(rb_cString, "chop!", rb_str_chop_bang, 0);
    rb_define_method(rb_cString, "chomp!", rb_str_chomp_bang, -1);

    rb_define_method(rb_cString, "tr", rb_str_tr, 2);
    rb_define_method(rb_cString, "tr_s", rb_str_tr_s, 2);
    rb_define_method(rb_cString, "delete", rb_str_delete, 1);
    rb_define_method(rb_cString, "squeeze", rb_str_squeeze, -1);

    rb_define_method(rb_cString, "tr!", rb_str_tr_bang, 2);
    rb_define_method(rb_cString, "tr_s!", rb_str_tr_s_bang, 2);
    rb_define_method(rb_cString, "delete!", rb_str_delete_bang, 1);
    rb_define_method(rb_cString, "squeeze!", rb_str_squeeze_bang, -1);

    rb_define_method(rb_cString, "each_line", rb_str_each_line, -1);
    rb_define_method(rb_cString, "each", rb_str_each_line, -1);
    rb_define_method(rb_cString, "each_byte", rb_str_each_byte, 0);

    rb_define_method(rb_cString, "sum", rb_str_sum, -1);

    rb_define_global_function("sub", rb_f_sub, -1);
    rb_define_global_function("gsub", rb_f_gsub, -1);

    rb_define_global_function("sub!", rb_f_sub_bang, -1);
    rb_define_global_function("gsub!", rb_f_gsub_bang, -1);
d2722 2
a2723 2
    rb_define_global_function("chop", rb_f_chop, 0);
    rb_define_global_function("chop!", rb_f_chop_bang, 0);
d2725 2
a2726 2
    rb_define_global_function("chomp", rb_f_chomp, -1);
    rb_define_global_function("chomp!", rb_f_chomp_bang, -1);
d2728 1
a2728 1
    rb_define_global_function("split", rb_f_split, -1);
@


1.1.1.2.2.45.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/10/06 02:45:03 $
d36 1
a36 1
    int len;
d349 3
d433 1
a433 1
    int len;
d1066 1
a1066 1
    VALUE val = rb_str_sub_bang(argc, argv, str = rb_str_dup(str));
d1170 1
a1170 1
    VALUE val = rb_str_gsub_bang(argc, argv, str = rb_str_dup(str));
d1217 1
a1217 1
    line = rb_str_dup(uscore_get());
d1219 5
a1223 3
    if (NIL_P(v)) return line;
    rb_lastline_set(v);
    return v;
d1241 1
a1241 1
    line = rb_str_dup(uscore_get());
d1243 5
a1247 3
    if (NIL_P(v)) return line;
    rb_lastline_set(v);
    return v;
d1369 6
a1374 1
	else if (c == '"' || c == '\''|| c == '\\') {
d1377 1
a1377 1
	    *b++ = c;
d1443 1
a1443 1
	  case '"':  case '\'': case '\\':
d1469 1
a1469 1
	if (c == '"' || c == '\'' || c == '\\') {
d1492 1
a1492 1
	else if (c == '\013') {
d1500 1
a1500 1
	else if (c == '\033') {
d1543 1
a1543 1
    VALUE val = rb_str_upcase_bang(str = rb_str_dup(str));
d1577 1
a1577 1
    VALUE val = rb_str_downcase_bang(str = rb_str_dup(str));
d1613 1
a1613 1
    VALUE val = rb_str_capitalize_bang(str = rb_str_dup(str));
d1651 1
a1651 1
    VALUE val = rb_str_swapcase_bang(str = rb_str_dup(str));
d1806 1
a1806 1
    VALUE val = tr_trans(str = rb_str_dup(str), src, repl, 0);
d1869 1
a1869 1
    VALUE val = rb_str_delete_bang(str1 = rb_str_dup(str1), str2);
d1933 1
a1933 1
    VALUE val = rb_str_squeeze_bang(argc, argv, str = rb_str_dup(str));
d1950 1
a1950 1
    VALUE val = tr_trans(str = rb_str_dup(str), src, repl, 1);
d2144 1
a2144 1
	    if (p[1] != '\n') continue;
d2146 1
d2148 1
a2148 1
	if (p[-1] == newline &&
d2150 3
a2152 2
	     memcmp(RSTRING(rs)->ptr, p-rslen, rslen) == 0)) {
	    line = rb_str_new(s, p - s);
d2156 1
a2156 1
	    s = p;
d2162 1
d2204 1
a2204 1
    VALUE val = rb_str_chop_bang(str = rb_str_dup(str));
d2220 1
a2220 2
    VALUE str = rb_str_dup(uscore_get());
    VALUE val = rb_str_chop_bang(str);
d2222 4
a2225 3
    if (NIL_P(str)) return str;
    rb_lastline_set(val);
    return val;
d2277 1
a2277 1
    VALUE val = rb_str_chomp_bang(argc, argv, str = rb_str_dup(str));
d2296 1
a2296 2
    VALUE str = rb_str_dup(uscore_get());
    VALUE val = rb_str_chomp_bang(argc, argv, str);
d2298 1
a2298 1
    if (NIL_P(val)) return str;
d2343 1
a2343 2

    VALUE val = rb_str_strip_bang(str = rb_str_dup(str));
d2361 2
a2362 5
	if (BEG(0) == END(0)) {
	    /*
	     * Always consume at least one character of the input string
	     */
	    *start = END(0)+(ismbchar(RSTRING(str)->ptr[END(0)])?2:1);
@


1.1.1.2.2.45.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:51 $
d28 1
d41 3
a62 15
rb_tainted_str_new(ptr, len)
    char *ptr;
    int len;
{
    return rb_str_new(ptr, len);
}

VALUE
rb_tainted_str_new2(ptr)
    char *ptr;
{
    return rb_str_new2(ptr);
}

VALUE
d73 4
d99 1
a99 1
	    FL_SET(str, FL_TAINT);
d130 1
a130 1
    if (rb_obj_tainted(str2)) rb_obj_taint(str);
d174 3
a176 1
    if (rb_obj_tainted(str)) s = rb_obj_taint(s);
d198 1
a198 1
	FL_SET(str, FL_TAINT);
d234 2
a235 2
    if (rb_obj_tainted(str1) || rb_obj_tainted(str2))
	return rb_obj_taint(str3);
d259 2
a260 2
    if (rb_obj_tainted(str)) {
	return rb_obj_taint(str2);
d303 1
a303 1
    if (rb_obj_tainted(str)) rb_obj_taint(str2);
a350 2
    if (rb_safe_level() >= 4 && !FL_TEST(str, FL_TAINT))
	rb_raise(rb_eSecurityError, "Insecure: can't modify string");
d391 19
d460 1
a460 1
    if (ruby_ignorecase) {
d492 1
a492 1
    if (ruby_ignorecase) {
d743 2
a744 2
    if (rb_obj_tainted(orig)) {
	return rb_obj_taint(str);
d802 2
a803 2
	if (rb_reg_search(indx, str, 0, 0) >= 0)
	    return rb_reg_last_match(rb_backref_get());
d934 3
a936 2
	beg = rb_str_index(str, indx, 0);
	if (beg >= 0) {
d940 1
d1017 4
a1020 1
    if (argc == 1 && rb_iterator_p()) {
a1022 3
    else if (argc == 2) {
	repl = repl = rb_obj_as_string(argv[1]);;
    }
d1024 1
a1024 1
	rb_raise(rb_eArgError, "Wrong # of arguments(%d for 2)", argc);
d1027 1
a1027 1
    pat = get_pat(argv[0]);
d1082 4
a1085 1
    if (argc == 1 && rb_iterator_p()) {
a1087 3
    else if (argc == 2) {
	repl = repl = rb_obj_as_string(argv[1]);;
    }
d1089 1
a1089 1
	rb_raise(rb_eArgError, "Wrong # of arguments(%d for 2)", argc);
d1092 1
a1092 1
    pat = get_pat(argv[0]);
d1181 1
a1181 1
    if (rb_obj_tainted(str2)) rb_obj_taint(str);
d1494 1
a1494 1
	    sprintf(q, "%03o", c&0xff);
d1953 1
a1953 1
    int beg, end, i, lim = 0;
d1958 1
a1958 1
	if (lim <= 0) limit = Qnil;
d1984 1
a1984 1
	    rb_raise(rb_eArgError, "bad separator");
d2071 1
a2071 1
    if (!NIL_P(limit) || RSTRING(str)->len > beg || lim < 0) {
a2073 5
    if (NIL_P(limit) && lim == 0) {
	while (RARRAY(result)->len > 0 &&
	       RSTRING(RARRAY(result)->ptr[RARRAY(result)->len-1])->len == 0)
	    rb_ary_pop(result);
    }
d2283 3
d2329 1
d2581 3
@


1.1.1.2.2.45.2.4
log
@first public release of 1.1d (pre1.2) series
@
text
@d6 1
a6 1
  $Date: 1998/11/25 03:31:17 $
d1348 1
a1348 1
	else if (c == '"'|| c == '\\') {
d1417 1
a1417 1
	  case '"':  case '\\':
d1443 1
a1443 1
	if (c == '"' || c == '\\') {
@


1.1.1.2.2.45.2.5
log
@1.1d1
@
text
@d6 1
a6 1
  $Date: 1998/12/16 07:30:33 $
d63 1
a63 1
    return rb_obj_taint(rb_str_new(ptr, len));
d70 1
a70 1
    return rb_obj_taint(rb_str_new2(ptr));
d1098 1
a1098 1
	len = (bp - buf) + (beg - offset) + RSTRING(val)->len + 3;
@
