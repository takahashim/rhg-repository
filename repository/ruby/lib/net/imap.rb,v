head	1.28;
access;
symbols
	v1_6_7:1.14.2.4
	v1_6_6:1.14.2.4
	v1_6_5:1.14.2.3
	v1_6_4:1.14.2.3
	v1_7_1:1.22
	v1_6_4_preview4:1.14.2.3
	v1_6_4_preview3:1.14.2.3
	v1_6_4_preview2:1.14.2.3
	v1_6_4_preview1:1.14.2.3
	v1_6_3:1.14.2.1
	ruby_m17n:1.14.0.4
	ruby_1_6:1.14.0.2
	v1_6_2:1.14;
locks; strict;
comment	@# @;


1.28
date	2002.03.01.02.27.37;	author shugo;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.06.04.39.00;	author shugo;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.01.14.05.41;	author knu;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.01.14.03.19;	author knu;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.06.05.20.25;	author shugo;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.30.02.15.13;	author shugo;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.09.02.57.36;	author shugo;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.02.03.41.35;	author shugo;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.02.03.03.29;	author shugo;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.30.19.51.33;	author shugo;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.30.13.59.26;	author shugo;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.26.12.32.38;	author shugo;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.26.12.29.50;	author shugo;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.14.08.40.49;	author shugo;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.21.06.35.05;	author shugo;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2000.11.01.02.48.47;	author shugo;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.31.07.06.47;	author shugo;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.30.04.17.42;	author shugo;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.27.07.20.02;	author shugo;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.26.08.19.04;	author shugo;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.25.21.31.52;	author shugo;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.25.04.27.59;	author shugo;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.17.18.04.41;	author shugo;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.16.09.11.10;	author shugo;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.16.07.38.26;	author shugo;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.15.16.47.29;	author shugo;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.14.14.54.51;	author shugo;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.13.08.06.16;	author shugo;	state Exp;
branches;
next	;

1.14.2.1
date	2001.02.14.08.30.54;	author shugo;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2001.04.02.03.46.15;	author shugo;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2001.04.09.02.58.56;	author shugo;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2001.12.01.14.07.01;	author knu;	state Exp;
branches;
next	;


desc
@@


1.28
log
@* lib/net/imap.rb: added document.
* lib/net/imap.rb (getquotaroot): new method.
* lib/net/imap.rb (setacl): remove the rights if the rights
parameter is nil.
* lib/net/imap.rb (getacl): return a MailboxACLItem object.
@
text
@=begin

= net/imap.rb

Copyright (C) 2000  Shugo Maeda <shugo@@ruby-lang.org>

This library is distributed under the terms of the Ruby license.
You can freely distribute/modify this library.

== Net::IMAP

Net::IMAP implements Internet Message Access Protocol (IMAP) clients.
(The protocol is described in ((<[IMAP]>)).)

Net::IMAP supports multiple commands. For example,

  imap = Net::IMAP.new("imap.foo.net", "imap2")
  imap.authenticate("cram-md5", "bar", "password")
  imap.select("inbox")
  fetch_thread = Thread.start { imap.fetch(1..-1, "UID") }
  search_result = imap.search(["BODY", "hello"])
  fetch_result = fetch_thread.value
  imap.disconnect

This script invokes the FETCH command and the SEARCH command concurrently.

=== Super Class

Object

=== Class Methods

: new(host, port = 143, usessl = false, certs = nil, verify = false)
      Creates a new Net::IMAP object and connects it to the specified
      port on the named host.  If usessl is true, then an attempt will
      be made to use SSL (now TLS) to connect to the server.  For this
      to work OpenSSL((<[OSSL]>)) and the Ruby OpenSSL((<[RSSL]>))
      extension need to be installed.  The certs parameter indicates
      the path or file containing the CA cert of the server, and the
      verify parameter is for the OpenSSL verification callback.

: debug
      Returns the debug mode.

: debug = val
      Sets the debug mode.

: add_authenticator(auth_type, authenticator)
      Adds an authenticator for Net::IMAP#authenticate.

=== Methods

: greeting
      Returns an initial greeting response from the server.

: responses
      Returns recorded untagged responses.

      ex).
        imap.select("inbox")
        p imap.responses["EXISTS"][-1]
        #=> 2
        p imap.responses["UIDVALIDITY"][-1]
        #=> 968263756

: disconnect
      Disconnects from the server.

: capability
      Sends a CAPABILITY command, and returns a listing of
      capabilities that the server supports.

: noop
      Sends a NOOP command to the server. It does nothing.

: logout
      Sends a LOGOUT command to inform the server that the client is
      done with the connection.

: authenticate(auth_type, arg...)
      Sends an AUTEHNTICATE command to authenticate the client.
      The auth_type parameter is a string that represents
      the authentication mechanism to be used. Currently Net::IMAP
      supports "LOGIN" and "CRAM-MD5" for the auth_type.

      ex).
        imap.authenticate('LOGIN', user, password)

: login(user, password)
      Sends a LOGIN command to identify the client and carries
      the plaintext password authenticating this user.

: select(mailbox)
      Sends a SELECT command to select a mailbox so that messages
      in the mailbox can be accessed.

: examine(mailbox)
      Sends a EXAMINE command to select a mailbox so that messages
      in the mailbox can be accessed. However, the selected mailbox
      is identified as read-only.

: create(mailbox)
      Sends a CREATE command to create a new mailbox.

: delete(mailbox)
      Sends a DELETE command to remove the mailbox.

: rename(mailbox, newname)
      Sends a RENAME command to change the name of the mailbox to
      the newname.

: subscribe(mailbox)
      Sends a SUBSCRIBE command to add the specified mailbox name to
      the server's set of "active" or "subscribed" mailboxes.

: unsubscribe(mailbox)
      Sends a UNSUBSCRIBE command to remove the specified mailbox name
      from the server's set of "active" or "subscribed" mailboxes.

: list(refname, mailbox)
      Sends a LIST command, and returns a subset of names from
      the complete set of all names available to the client.
      The return value is an array of ((<Net::IMAP::MailboxList>)).

      ex).
        imap.create("foo/bar")
        imap.create("foo/baz")
        p imap.list("", "foo/%")
        #=> [#<Net::IMAP::MailboxList attr=[:Noselect], delim="/", name="foo/">, #<Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim="/", name="foo/bar">, #<Net::IMAP::MailboxList attr=[:Noinferiors], delim="/", name="foo/baz">]

: lsub(refname, mailbox)
      Sends a LSUB command, and returns a subset of names from the set
      of names that the user has declared as being "active" or
      "subscribed".
      The return value is an array of ((<Net::IMAP::MailboxList>)).

: status(mailbox, attr)
      Sends a STATUS command, and returns the status of the indicated
      mailbox.
      The return value is a hash of attributes.

      ex).
        p imap.status("inbox", ["MESSAGES", "RECENT"])
        #=> {"RECENT"=>0, "MESSAGES"=>44}

: append(mailbox, message, flags = nil, date_time = nil)
      Sends a APPEND command to append the message to the end of
      the mailbox.

      ex).
        imap.append("inbox", <<EOF.gsub(/\n/, "\r\n"), [:Seen], Time.now)
        Subject: hello
        From: shugo@@ruby-lang.org
        To: shugo@@ruby-lang.org
        
        hello world
        EOF

: check
      Sends a CHECK command to request a checkpoint of the currently
      selected mailbox.

: close
      Sends a CLOSE command to close the currently selected mailbox.
      The CLOSE command permanently removes from the mailbox all
      messages that have the \Deleted flag set.

: expunge
      Sends a EXPUNGE command to permanently remove from the currently
      selected mailbox all messages that have the \Deleted flag set.

: search(keys, charset = nil)
: uid_search(keys, charset = nil)
      Sends a SEARCH command to search the mailbox for messages that
      match the given searching criteria, and returns message sequence
      numbers (search) or unique identifiers (uid_search).

      ex).
        p imap.search(["SUBJECT", "hello"])
        #=> [1, 6, 7, 8]
        p imap.search('SUBJECT "hello"')
        #=> [1, 6, 7, 8]

: fetch(set, attr)
: uid_fetch(set, attr)
      Sends a FETCH command to retrieve data associated with a message
      in the mailbox. the set parameter is a number or an array of
      numbers or a Range object. the number is a message sequence
      number (fetch) or a unique identifier (uid_fetch).
      The return value is an array of ((<Net::IMAP::FetchData>)).

      ex).
        p imap.fetch(6..8, "UID")
        #=> [#<Net::IMAP::FetchData seqno=6, attr={"UID"=>98}>, #<Net::IMAP::FetchData seqno=7, attr={"UID"=>99}>, #<Net::IMAP::FetchData seqno=8, attr={"UID"=>100}>]
        p imap.fetch(6, "BODY[HEADER.FIELDS (SUBJECT)]")
        #=> [#<Net::IMAP::FetchData seqno=6, attr={"BODY[HEADER.FIELDS (SUBJECT)]"=>"Subject: test\r\n\r\n"}>]
        data = imap.uid_fetch(98, ["RFC822.SIZE", "INTERNALDATE"])[0]
        p data.seqno
        #=> 6
        p data.attr["RFC822.SIZE"]
        #=> 611
        p data.attr["INTERNALDATE"]
        #=> "12-Oct-2000 22:40:59 +0900"
        p data.attr["UID"]
        #=> 98

: store(set, attr, flags)
: uid_store(set, attr, flags)
      Sends a STORE command to alter data associated with a message
      in the mailbox. the set parameter is a number or an array of
      numbers or a Range object. the number is a message sequence
      number (store) or a unique identifier (uid_store).
      The return value is an array of ((<Net::IMAP::FetchData>)).

      ex).
        p imap.store(6..8, "+FLAGS", [:Deleted])
        #=> [#<Net::IMAP::FetchData seqno=6, attr={"FLAGS"=>[:Seen, :Deleted]}>, #<Net::IMAP::FetchData seqno=7, attr={"FLAGS"=>[:Seen, :Deleted]}>, #<Net::IMAP::FetchData seqno=8, attr={"FLAGS"=>[:Seen, :Deleted]}>]

: copy(set, mailbox)
: uid_copy(set, mailbox)
      Sends a COPY command to copy the specified message(s) to the end
      of the specified destination mailbox. the set parameter is
      a number or an array of numbers or a Range object. the number is
      a message sequence number (copy) or a unique identifier (uid_copy).

: sort(sort_keys, search_keys, charset)
: uid_sort(sort_keys, search_keys, charset)
      Sends a SORT command to sort messages in the mailbox.

      ex).
        p imap.sort(["FROM"], ["ALL"], "US-ASCII")
        #=> [1, 2, 3, 5, 6, 7, 8, 4, 9]
        p imap.sort(["DATE"], ["SUBJECT", "hello"], "US-ASCII")
        #=> [6, 7, 8, 1]

: setquota(mailbox, quota)
      Sends a SETQUOTA command along with the specified mailbox and
      quota.  If quota is nil, then quota will be unset for that
      mailbox.  Typically one needs to be logged in as server admin
      for this to work.  The IMAP quota commands are described in
      ((<[RFC-2087]>)).

: getquota(mailbox)
      Sends the GETQUOTA command along with specified mailbox.
      If this mailbox exists, then an array containing a
      ((<Net::IMAP::MailboxQuota>)) object is returned.  This
      command generally is only available to server admin.

: getquotaroot(mailbox)
      Sends the GETQUOTAROOT command along with specified mailbox.
      This command is generally available to both admin and user.
      If mailbox exists, returns an array containing objects of
      ((<Net::IMAP::MailboxQuotaRoot>)) and ((<Net::IMAP::MailboxQuota>)).

: setacl(mailbox, user, rights)
      Sends the SETACL command along with mailbox, user and the
      rights that user is to have on that mailbox.  If rights is nil,
      then that user will be stripped of any rights to that mailbox.
      The IMAP ACL commands are described in ((<[RFC-2086]>)).

: getacl(mailbox)
      Send the GETACL command along with specified mailbox.
      If this mailbox exists, an array containing objects of
      ((<Net::IMAP::MailboxACLItem>)) will be returned.

: add_response_handler(handler = Proc.new)
      Adds a response handler.

      ex).
        imap.add_response_handler do |resp|
          p resp
        end

: remove_response_handler(handler)
      Removes the response handler.

: response_handlers
      Returns all response handlers.

== Net::IMAP::ContinuationRequest

Net::IMAP::ContinuationRequest represents command continuation requests.

The command continuation request response is indicated by a "+" token
instead of a tag.  This form of response indicates that the server is
ready to accept the continuation of a command from the client.  The
remainder of this response is a line of text.

  continue_req    ::= "+" SPACE (resp_text / base64)

=== Super Class

Struct

=== Methods

: data
      Returns the data (Net::IMAP::ResponseText).

: raw_data
      Returns the raw data string.

== Net::IMAP::UntaggedResponse

Net::IMAP::UntaggedResponse represents untagged responses.

Data transmitted by the server to the client and status responses
that do not indicate command completion are prefixed with the token
"*", and are called untagged responses.

  response_data   ::= "*" SPACE (resp_cond_state / resp_cond_bye /
                      mailbox_data / message_data / capability_data)

=== Super Class

Struct

=== Methods

: name
      Returns the name such as "FLAGS", "LIST", "FETCH"....

: data
      Returns the data such as an array of flag symbols,
      a ((<Net::IMAP::MailboxList>)) object....

: raw_data
      Returns the raw data string.

== Net::IMAP::TaggedResponse

Net::IMAP::TaggedResponse represents tagged responses.

The server completion result response indicates the success or
failure of the operation.  It is tagged with the same tag as the
client command which began the operation.

  response_tagged ::= tag SPACE resp_cond_state CRLF
  
  tag             ::= 1*<any ATOM_CHAR except "+">
  
  resp_cond_state ::= ("OK" / "NO" / "BAD") SPACE resp_text

=== Super Class

Struct

=== Methods

: tag
      Returns the tag.

: name
      Returns the name. the name is one of "OK", "NO", "BAD".

: data
      Returns the data. See ((<Net::IMAP::ResponseText>)).

: raw_data
      Returns the raw data string.

== Net::IMAP::ResponseText

Net::IMAP::ResponseText represents texts of responses.
The text may be prefixed by the response code.

  resp_text       ::= ["[" resp_text_code "]" SPACE] (text_mime2 / text)
                      ;; text SHOULD NOT begin with "[" or "="
  
=== Super Class

Struct

=== Methods

: code
      Returns the response code. See ((<Net::IMAP::ResponseCode>)).
      
: text
      Returns the text.

== Net::IMAP::ResponseCode

Net::IMAP::ResponseCode represents response codes.

  resp_text_code  ::= "ALERT" / "PARSE" /
                      "PERMANENTFLAGS" SPACE "(" #(flag / "\*") ")" /
                      "READ-ONLY" / "READ-WRITE" / "TRYCREATE" /
                      "UIDVALIDITY" SPACE nz_number /
                      "UNSEEN" SPACE nz_number /
                      atom [SPACE 1*<any TEXT_CHAR except "]">]

=== SuperClass

Struct

=== Methods

: name
      Returns the name such as "ALERT", "PERMANENTFLAGS", "UIDVALIDITY"....

: data
      Returns the data if it exists.

== Net::IMAP::MailboxList

Net::IMAP::MailboxList represents contents of the LIST response.

  mailbox_list    ::= "(" #("\Marked" / "\Noinferiors" /
                      "\Noselect" / "\Unmarked" / flag_extension) ")"
                      SPACE (<"> QUOTED_CHAR <"> / nil) SPACE mailbox

=== Super Class

Struct

=== Methods

: attr
      Returns the name attributes. Each name attribute is a symbol
      capitalized by String#capitalize, such as :Noselect (not :NoSelect).

: delim
      Returns the hierarchy delimiter

: name
      Returns the mailbox name.

== Net::IMAP::MailboxQuota

Net::IMAP::MailboxQuota represents contents of GETQUOTA response.
This object can also be a response to GETQUOTAROOT.  In the syntax
specification below, the delimiter used with the "#" construct is a
single space (SPACE).

   quota_list      ::= "(" #quota_resource ")"

   quota_resource  ::= atom SPACE number SPACE number

   quota_response  ::= "QUOTA" SPACE astring SPACE quota_list

=== Super Class

Struct

=== Methods

: mailbox
      The mailbox with the associated quota.

: usage
      Current storage usage of mailbox.

: quota
      Quota limit imposed on mailbox.

== Net::IMAP::MailboxQuotaRoot

Net::IMAP::MailboxQuotaRoot represents part of the GETQUOTAROOT
response. (GETQUOTAROOT can also return Net::IMAP::MailboxQuota.)

   quotaroot_response
                   ::= "QUOTAROOT" SPACE astring *(SPACE astring)

=== Super Class

Struct

=== Methods

: mailbox
      The mailbox with the associated quota.

: quotaroots
      Zero or more quotaroots that effect the quota on the
      specified mailbox.

== Net::IMAP::MailboxACLItem

Net::IMAP::MailboxACLItem represents response from GETACL.

   acl_data        ::= "ACL" SPACE mailbox *(SPACE identifier SPACE
                        rights)

   identifier      ::= astring

   rights          ::= astring

=== Super Class

Struct

=== Methods

: user
      Login name that has certain rights to the mailbox
      that was specified with the getacl command.

: rights
      The access rights the indicated user has to the
      mailbox.

== Net::IMAP::StatusData

Net::IMAP::StatusData represents contents of the STATUS response.

=== Super Class

Object

=== Methods

: mailbox
      Returns the mailbox name.

: attr
      Returns a hash. Each key is one of "MESSAGES", "RECENT", "UIDNEXT",
      "UIDVALIDITY", "UNSEEN". Each value is a number.

== Net::IMAP::FetchData

Net::IMAP::FetchData represents contents of the FETCH response.

=== Super Class

Object

=== Methods

: seqno
      Returns the message sequence number.
      (Note: not the unique identifier, even for the UID command response.)

: attr
      Returns a hash. Each key is a data item name, and each value is
      its value.

      The current data items are:

      : BODY
          A form of BODYSTRUCTURE without extension data.
      : BODY[<section>]<<origin_octet>>
          A string expressing the body contents of the specified section.
      : BODYSTRUCTURE
          An object that describes the ((<[MIME-IMB]>)) body structure of a message.
          See ((<Net::IMAP::BodyTypeBasic>)), ((<Net::IMAP::BodyTypeText>)),
          ((<Net::IMAP::BodyTypeMessage>)), ((<Net::IMAP::BodyTypeMultipart>)).
      : ENVELOPE
          A ((<Net::IMAP::Envelope>)) object that describes the envelope
          structure of a message.
      : FLAGS
          A array of flag symbols that are set for this message. flag symbols
          are capitalized by String#capitalize.
      : INTERNALDATE
          A string representing the internal date of the message.
      : RFC822
          Equivalent to BODY[].
      : RFC822.HEADER
          Equivalent to BODY.PEEK[HEADER].
      : RFC822.SIZE
          A number expressing the ((<[RFC-822]>)) size of the message.
      : RFC822.TEXT
          Equivalent to BODY[TEXT].
      : UID
          A number expressing the unique identifier of the message.

== Net::IMAP::Envelope

Net::IMAP::Envelope represents envelope structures of messages.

=== Super Class

Struct

=== Methods

: date
      Retunns a string that represents the date.

: subject
      Retunns a string that represents the subject.

: from
      Retunns an array of ((<Net::IMAP::Address>)) that represents the from.

: sender
      Retunns an array of ((<Net::IMAP::Address>)) that represents the sender.

: reply_to
      Retunns an array of ((<Net::IMAP::Address>)) that represents the reply-to.

: to
      Retunns an array of ((<Net::IMAP::Address>)) that represents the to.

: cc
      Retunns an array of ((<Net::IMAP::Address>)) that represents the cc.

: bcc
      Retunns an array of ((<Net::IMAP::Address>)) that represents the bcc.

: in_reply_to
      Retunns a string that represents the in-reply-to.

: message_id
      Retunns a string that represents the message-id.

== Net::IMAP::Address

((<Net::IMAP::Address>)) represents electronic mail addresses.

=== Super Class

Struct

=== Methods

: name
      Returns the phrase from ((<[RFC-822]>)) mailbox.

: route
      Returns the route from ((<[RFC-822]>)) route-addr.

: mailbox
      nil indicates end of ((<[RFC-822]>)) group.
      If non-nil and host is nil, returns ((<[RFC-822]>)) group name.
      Otherwise, returns ((<[RFC-822]>)) local-part

: host
      nil indicates ((<[RFC-822]>)) group syntax.
      Otherwise, returns ((<[RFC-822]>)) domain name.

== Net::IMAP::ContentDisposition

Net::IMAP::ContentDisposition represents Content-Disposition fields.

=== Super Class

Struct

=== Methods

: dsp_type
      Returns the disposition type.

: param
      Returns a hash that represents parameters of the Content-Disposition
      field.

== Net::IMAP::BodyTypeBasic

Net::IMAP::BodyTypeBasic represents basic body structures of messages.

=== Super Class

Struct

=== Methods

: media_type
      Returns the content media type name as defined in ((<[MIME-IMB]>)).

: subtype
      Returns the content subtype name as defined in ((<[MIME-IMB]>)).

: param
      Returns a hash that represents parameters as defined in
      ((<[MIME-IMB]>)).

: content_id
      Returns a string giving the content id as defined in ((<[MIME-IMB]>)).

: description
      Returns a string giving the content description as defined in
      ((<[MIME-IMB]>)).

: encoding
      Returns a string giving the content transfer encoding as defined in
      ((<[MIME-IMB]>)).

: size
      Returns a number giving the size of the body in octets.

: md5
      Returns a string giving the body MD5 value as defined in ((<[MD5]>)).

: disposition
      Returns a ((<Net::IMAP::ContentDisposition>)) object giving
      the content disposition.

: language
      Returns a string or an array of strings giving the body
      language value as defined in [LANGUAGE-TAGS].

: extension
      Returns extension data.

: multipart?
      Returns false.

== Net::IMAP::BodyTypeText

Net::IMAP::BodyTypeText represents TEXT body structures of messages.

=== Super Class

Struct

=== Methods

: lines
      Returns the size of the body in text lines.

And Net::IMAP::BodyTypeText has all methods of ((<Net::IMAP::BodyTypeBasic>)).

== Net::IMAP::BodyTypeMessage

Net::IMAP::BodyTypeMessage represents MESSAGE/RFC822 body structures of messages.

=== Super Class

Struct

=== Methods

: envelope
      Returns a ((<Net::IMAP::Envelope>)) giving the envelope structure.

: body
      Returns an object giving the body structure.

And Net::IMAP::BodyTypeMessage has all methods of ((<Net::IMAP::BodyTypeText>)).

== Net::IMAP::BodyTypeText

=== Super Class

Struct

=== Methods

: media_type
      Returns the content media type name as defined in ((<[MIME-IMB]>)).

: subtype
      Returns the content subtype name as defined in ((<[MIME-IMB]>)).

: parts
      Returns multiple parts.

: param
      Returns a hash that represents parameters as defined in
      ((<[MIME-IMB]>)).

: disposition
      Returns a ((<Net::IMAP::ContentDisposition>)) object giving
      the content disposition.

: language
      Returns a string or an array of strings giving the body
      language value as defined in [LANGUAGE-TAGS].

: extension
      Returns extension data.

: multipart?
      Returns true.

== References

: [IMAP]
    M. Crispin, "INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1",
    RFC 2060, December 1996.

: [LANGUAGE-TAGS]
    Alvestrand, H., "Tags for the Identification of
    Languages", RFC 1766, March 1995.

: [MD5]
    Myers, J., and M. Rose, "The Content-MD5 Header Field", RFC
    1864, October 1995.

: [MIME-IMB]
    Freed, N., and N. Borenstein, "MIME (Multipurpose Internet
    Mail Extensions) Part One: Format of Internet Message Bodies", RFC
    2045, November 1996.

: [RFC-822]
    Crocker, D., "Standard for the Format of ARPA Internet Text
    Messages", STD 11, RFC 822, University of Delaware, August 1982.

: [RFC-2087]
    Myers, J., "IMAP4 QUOTA extension", RFC 2087, January 1997.

: [RFC-2086]
    Myers, J., "IMAP4 ACL extension", RFC 2086, January 1997.

: [OSSL]
    http://www.openssl.org

: [RSSL]
    http://savannah.gnu.org/projects/rubypki

=end

require "socket"
require "monitor"
require "digest/md5"
begin
  require "openssl"
rescue LoadError
end

module Net
  class IMAP
    include MonitorMixin
    if defined?(OpenSSL)
      include OpenSSL
      include SSL
    end

    attr_reader :greeting, :responses, :response_handlers

    SEEN = :Seen
    ANSWERED = :Answered
    FLAGGED = :Flagged
    DELETED = :Deleted
    DRAFT = :Draft
    RECENT = :Recent

    NOINFERIORS = :Noinferiors
    NOSELECT = :Noselect
    MARKED = :Marked
    UNMARKED = :Unmarked

    def self.debug
      return @@@@debug
    end

    def self.debug=(val)
      return @@@@debug = val
    end

    def self.add_authenticator(auth_type, authenticator)
      @@@@authenticators[auth_type] = authenticator
    end

    def disconnect
      @@sock.shutdown unless @@usessl
      @@receiver_thread.join
      @@sock.close
    end

    def capability
      synchronize do
	send_command("CAPABILITY")
	return @@responses.delete("CAPABILITY")[-1]
      end
    end

    def noop
      send_command("NOOP")
    end

    def logout
      send_command("LOGOUT")
    end

    def authenticate(auth_type, *args)
      auth_type = auth_type.upcase
      unless @@@@authenticators.has_key?(auth_type)
	raise ArgumentError,
	  format('unknown auth type - "%s"', auth_type)
      end
      authenticator = @@@@authenticators[auth_type].new(*args)
      send_command("AUTHENTICATE", auth_type) do |resp|
	if resp.instance_of?(ContinuationRequest)
	  data = authenticator.process(resp.data.text.unpack("m")[0])
	  send_data([data].pack("m").chomp)
	end
      end
    end

    def login(user, password)
      send_command("LOGIN", user, password)
    end

    def select(mailbox)
      synchronize do
	@@responses.clear
	send_command("SELECT", mailbox)
      end
    end

    def examine(mailbox)
      synchronize do
	@@responses.clear
	send_command("EXAMINE", mailbox)
      end
    end

    def create(mailbox)
      send_command("CREATE", mailbox)
    end

    def delete(mailbox)
      send_command("DELETE", mailbox)
    end

    def rename(mailbox, newname)
      send_command("RENAME", mailbox, newname)
    end

    def subscribe(mailbox)
      send_command("SUBSCRIBE", mailbox)
    end

    def unsubscribe(mailbox)
      send_command("UNSUBSCRIBE", mailbox)
    end

    def list(refname, mailbox)
      synchronize do
	send_command("LIST", refname, mailbox)
	return @@responses.delete("LIST")
      end
    end

    def getquotaroot(mailbox)
      synchronize do
        send_command("GETQUOTAROOT", mailbox)
        result = []
        result.concat(@@responses.delete("QUOTAROOT"))
        result.concat(@@responses.delete("QUOTA"))
        return result
      end
    end

    def getquota(mailbox)
      synchronize do
	send_command("GETQUOTA", mailbox)
	return @@responses.delete("QUOTA")
      end
    end

    # setquota(mailbox, nil) will unset quota.
    def setquota(mailbox, quota)
      if quota.nil?
        data = '()'
      else
        data = '(STORAGE ' + quota.to_s + ')'
      end
      send_command("SETQUOTA", mailbox, RawData.new(data))
    end

    # setacl(mailbox, user, nil) will remove rights.
    def setacl(mailbox, user, rights)
      if rights.nil? 
        send_command("SETACL", mailbox, user, "")
      else
        send_command("SETACL", mailbox, user, rights)
      end
    end

    def getacl(mailbox)
      synchronize do
	send_command("GETACL", mailbox)
	return @@responses.delete("ACL")[-1]
      end
    end

    def lsub(refname, mailbox)
      synchronize do
	send_command("LSUB", refname, mailbox)
	return @@responses.delete("LSUB")
      end
    end

    def status(mailbox, attr)
      synchronize do
	send_command("STATUS", mailbox, attr)
	return @@responses.delete("STATUS")[-1].attr
      end
    end

    def append(mailbox, message, flags = nil, date_time = nil)
      args = []
      if flags
	args.push(flags)
      end
      args.push(date_time) if date_time
      args.push(Literal.new(message))
      send_command("APPEND", mailbox, *args)
    end

    def check
      send_command("CHECK")
    end

    def close
      send_command("CLOSE")
    end

    def expunge
      synchronize do
	send_command("EXPUNGE")
	return @@responses.delete("EXPUNGE")
      end
    end

    def search(keys, charset = nil)
      return search_internal("SEARCH", keys, charset)
    end

    def uid_search(keys, charset = nil)
      return search_internal("UID SEARCH", keys, charset)
    end

    def fetch(set, attr)
      return fetch_internal("FETCH", set, attr)
    end

    def uid_fetch(set, attr)
      return fetch_internal("UID FETCH", set, attr)
    end

    def store(set, attr, flags)
      return store_internal("STORE", set, attr, flags)
    end

    def uid_store(set, attr, flags)
      return store_internal("UID STORE", set, attr, flags)
    end

    def copy(set, mailbox)
      copy_internal("COPY", set, mailbox)
    end

    def uid_copy(set, mailbox)
      copy_internal("UID COPY", set, mailbox)
    end

    def sort(sort_keys, search_keys, charset)
      return sort_internal("SORT", sort_keys, search_keys, charset)
    end

    def uid_sort(sort_keys, search_keys, charset)
      return sort_internal("UID SORT", sort_keys, search_keys, charset)
    end

    def add_response_handler(handler = Proc.new)
      @@response_handlers.push(handler)
    end

    def remove_response_handler(handler)
      @@response_handlers.delete(handler)
    end

    private

    CRLF = "\r\n"
    PORT = 143

    @@@@debug = false
    @@@@authenticators = {}

    def initialize(host, port = PORT, usessl = false, certs = nil, verify = false)
      super()
      @@host = host
      @@port = port
      @@tag_prefix = "RUBY"
      @@tagno = 0
      @@parser = ResponseParser.new
      @@sock = TCPSocket.open(host, port)
      if usessl
        unless defined?(OpenSSL)
          raise "SSL extension not installed"
        end
        @@usessl = true
        @@sock = SSLSocket.new(@@sock)

        # verify the server.
        @@sock.ca_file = certs if certs && FileTest::file?(certs)
        @@sock.ca_path = certs if certs && FileTest::directory?(certs)
        @@sock.verify_mode = VERIFY_PEER if verify
        @@sock.verify_callback = VerifyCallbackProc if defined?(VerifyCallbackProc)

        @@sock.connect   # start ssl session.
      else
        @@usessl = false
      end
      @@responses = Hash.new([].freeze)
      @@tagged_responses = {}
      @@response_handlers = []
      @@tag_arrival = new_cond

      @@greeting = get_response
      if /\ABYE\z/ni =~ @@greeting.name
	@@sock.close
	raise ByeResponseError, resp[0]
      end

      @@receiver_thread = Thread.start {
	receive_responses
      }
    end

    def receive_responses
      while resp = get_response
	synchronize do
	  case resp
	  when TaggedResponse
	    @@tagged_responses[resp.tag] = resp
	    @@tag_arrival.broadcast
	  when UntaggedResponse
	    record_response(resp.name, resp.data)
	    if resp.data.instance_of?(ResponseText) &&
		(code = resp.data.code)
	      record_response(code.name, code.data)
	    end
	  end
	  @@response_handlers.each do |handler|
	    handler.call(resp)
	  end
	end
      end
    end

    def get_tagged_response(tag, cmd)
      until @@tagged_responses.key?(tag)
	@@tag_arrival.wait
      end
      resp = @@tagged_responses.delete(tag)
      case resp.name
      when /\A(?:NO)\z/ni
	raise NoResponseError, resp.data.text
      when /\A(?:BAD)\z/ni
	raise BadResponseError, resp.data.text
      else
	return resp
      end
    end

    def get_response
      buff = ""
      while true
	s = @@sock.gets(CRLF)
	break unless s
	buff.concat(s)
	if /\{(\d+)\}\r\n/n =~ s
	  s = @@sock.read($1.to_i)
	  buff.concat(s)
	else
	  break
	end
      end
      return nil if buff.length == 0
      if @@@@debug
        $stderr.print(buff.gsub(/^/n, "S: "))
      end
      return @@parser.parse(buff)
    end

    def record_response(name, data)
      unless @@responses.has_key?(name)
	@@responses[name] = []
      end
      @@responses[name].push(data)
    end

    def send_command(cmd, *args, &block)
      synchronize do
	tag = generate_tag
	data = args.collect {|i| format_data(i)}.join(" ")
	if data.length > 0
	  put_line(tag + " " + cmd + " " + data)
	else
	  put_line(tag + " " + cmd)
	end
	if block
	  add_response_handler(block)
	end
	begin
	  return get_tagged_response(tag, cmd)
	ensure
	  if block
	    remove_response_handler(block)
	  end
	end
      end
    end

    def generate_tag
      @@tagno += 1
      return format("%s%04d", @@tag_prefix, @@tagno)
    end

    def send_data(*args)
      data = args.collect {|i| format_data(i)}.join(" ")
      put_line(data)
    end

    def put_line(line)
      line = line + CRLF
      @@sock.print(line)
      if @@@@debug
        $stderr.print(line.gsub(/^/n, "C: "))
      end
    end

    def format_data(data)
      case data
      when nil
	return "NIL"
      when String
	return format_string(data)
      when Integer
	return format_number(data)
      when Array
	return format_list(data)
      when Time
	return format_time(data)
      when Symbol
	return format_symbol(data)
      else
	return data.format_data
      end
    end

    def format_string(str)
      case str
      when ""
	return '""'
      when /[\x80-\xff\r\n]/n
	# literal
	return "{" + str.length.to_s + "}" + CRLF + str
      when /[(){ \x00-\x1f\x7f%*"\\]/n
	# quoted string
	return '"' + str.gsub(/["\\]/n, "\\\\\\&") + '"'
      else
	# atom
	return str
      end
    end

    def format_number(num)
      if num < 0 || num >= 4294967296
	raise DataFormatError, num.to_s
      end
      return num.to_s
    end

    def format_list(list)
      contents = list.collect {|i| format_data(i)}.join(" ")
      return "(" + contents + ")"
    end

    DATE_MONTH = %w(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)

    def format_time(time)
      t = time.dup.gmtime
      return format('"%2d-%3s-%4d %02d:%02d:%02d +0000"',
		    t.day, DATE_MONTH[t.month - 1], t.year,
		    t.hour, t.min, t.sec)
    end

    def format_symbol(symbol)
      return "\\" + symbol.to_s
    end

    def search_internal(cmd, keys, charset)
      if keys.instance_of?(String)
	keys = [RawData.new(keys)]
      else
	normalize_searching_criteria(keys)
      end
      synchronize do
	if charset
	  send_command(cmd, "CHARSET", charset, *keys)
	else
	  send_command(cmd, *keys)
	end
	return @@responses.delete("SEARCH")[-1]
      end
    end

    def fetch_internal(cmd, set, attr)
      if attr.instance_of?(String)
	attr = RawData.new(attr)
      end
      synchronize do
	@@responses.delete("FETCH")
	send_command(cmd, MessageSet.new(set), attr)
	return @@responses.delete("FETCH")
      end
    end

    def store_internal(cmd, set, attr, flags)
      if attr.instance_of?(String)
	attr = RawData.new(attr)
      end
      synchronize do
	@@responses.delete("FETCH")
	send_command(cmd, MessageSet.new(set), attr, flags)
	return @@responses.delete("FETCH")
      end
    end

    def copy_internal(cmd, set, mailbox)
      send_command(cmd, MessageSet.new(set), mailbox)
    end

    def sort_internal(cmd, sort_keys, search_keys, charset)
      if search_keys.instance_of?(String)
	search_keys = [RawData.new(search_keys)]
      else
	normalize_searching_criteria(search_keys)
      end
      normalize_searching_criteria(search_keys)
      synchronize do
	send_command(cmd, sort_keys, charset, *search_keys)
	return @@responses.delete("SORT")[-1]
      end
    end

    def normalize_searching_criteria(keys)
      keys.collect! do |i|
	case i
	when -1, Range, Array
	  MessageSet.new(i)
	else
	  i
	end
      end
    end

    class RawData
      def format_data
	return @@data
      end

      private

      def initialize(data)
	@@data = data
      end
    end

    class Atom
      def format_data
	return @@data
      end

      private

      def initialize(data)
	@@data = data
      end
    end

    class QuotedString
      def format_data
	return '"' + @@data.gsub(/["\\]/n, "\\\\\\&") + '"'
      end

      private

      def initialize(data)
	@@data = data
      end
    end

    class Literal
      def format_data
	return "{" + @@data.length.to_s + "}" + CRLF + @@data
      end

      private

      def initialize(data)
	@@data = data
      end
    end

    class MessageSet
      def format_data
	return format_internal(@@data)
      end

      private

      def initialize(data)
	@@data = data
      end

      def format_internal(data)
	case data
	when "*"
	  return data
	when Integer
	  ensure_nz_number(data)
	  if data == -1
	    return "*"
	  else
	    return data.to_s
	  end
	when Range
	  return format_internal(data.first) +
	    ":" + format_internal(data.last)
	when Array
	  return data.collect {|i| format_internal(i)}.join(",")
	else
	  raise DataFormatError, data.inspect
	end
      end

      def ensure_nz_number(num)
	if num < -1 || num == 0 || num >= 4294967296
	  raise DataFormatError, num.inspect
	end
      end
    end

    ContinuationRequest = Struct.new(:data, :raw_data)
    UntaggedResponse = Struct.new(:name, :data, :raw_data)
    TaggedResponse = Struct.new(:tag, :name, :data, :raw_data)
    ResponseText = Struct.new(:code, :text)
    ResponseCode = Struct.new(:name, :data)
    MailboxList = Struct.new(:attr, :delim, :name)
    MailboxQuota = Struct.new(:mailbox, :usage, :quota)
    MailboxQuotaRoot = Struct.new(:mailbox, :quotaroots)
    MailboxACLItem = Struct.new(:user, :rights)
    StatusData = Struct.new(:mailbox, :attr)
    FetchData = Struct.new(:seqno, :attr)
    Envelope = Struct.new(:date, :subject, :from, :sender, :reply_to,
			  :to, :cc, :bcc, :in_reply_to, :message_id)
    Address = Struct.new(:name, :route, :mailbox, :host)
    ContentDisposition = Struct.new(:dsp_type, :param)

    class BodyTypeBasic < Struct.new(:media_type, :subtype,
				     :param, :content_id,
				     :description, :encoding, :size,
				     :md5, :disposition, :language,
				     :extension)
      def multipart?
	return false
      end

      def media_subtype
	$stderr.printf("warning: media_subtype is obsolete.\n")
	$stderr.printf("         use subtype instead.\n")
	return subtype
      end
    end

    class BodyTypeText < Struct.new(:media_type, :subtype,
				    :param, :content_id,
				    :description, :encoding, :size,
				    :lines,
				    :md5, :disposition, :language,
				    :extension)
      def multipart?
	return false
      end

      def media_subtype
	$stderr.printf("warning: media_subtype is obsolete.\n")
	$stderr.printf("         use subtype instead.\n")
	return subtype
      end
    end

    class BodyTypeMessage < Struct.new(:media_type, :subtype,
				       :param, :content_id,
				       :description, :encoding, :size,
				       :envelope, :body, :lines,
				       :md5, :disposition, :language,
				       :extension)
      def multipart?
	return false
      end

      def media_subtype
	$stderr.printf("warning: media_subtype is obsolete.\n")
	$stderr.printf("         use subtype instead.\n")
	return subtype
      end
    end

    class BodyTypeMultipart < Struct.new(:media_type, :subtype,
					 :parts,
					 :param, :disposition, :language,
					 :extension)
      def multipart?
	return true
      end

      def media_subtype
	$stderr.printf("warning: media_subtype is obsolete.\n")
	$stderr.printf("         use subtype instead.\n")
	return subtype
      end
    end

    class ResponseParser
      def parse(str)
	@@str = str
	@@pos = 0
	@@lex_state = EXPR_BEG
	@@token = nil
	return response
      end

      private

      EXPR_BEG		= :EXPR_BEG
      EXPR_DATA		= :EXPR_DATA
      EXPR_TEXT		= :EXPR_TEXT
      EXPR_RTEXT	= :EXPR_RTEXT
      EXPR_CTEXT	= :EXPR_CTEXT

      T_SPACE	= :SPACE
      T_NIL	= :NIL
      T_NUMBER	= :NUMBER
      T_ATOM	= :ATOM
      T_QUOTED	= :QUOTED
      T_LPAR	= :LPAR
      T_RPAR	= :RPAR
      T_BSLASH	= :BSLASH
      T_STAR	= :STAR
      T_LBRA	= :LBRA
      T_RBRA	= :RBRA
      T_LITERAL	= :LITERAL
      T_PLUS	= :PLUS
      T_PERCENT	= :PERCENT
      T_CRLF	= :CRLF
      T_EOF	= :EOF
      T_TEXT	= :TEXT

      BEG_REGEXP = /\G(?:\
(?# 1:	SPACE	)( )|\
(?# 2:	NIL	)(NIL)(?=[\x80-\xff(){ \x00-\x1f\x7f%*"\\\[\]+])|\
(?# 3:	NUMBER	)(\d+)(?=[\x80-\xff(){ \x00-\x1f\x7f%*"\\\[\]+])|\
(?# 4:	ATOM	)([^\x80-\xff(){ \x00-\x1f\x7f%*"\\\[\]+]+)|\
(?# 5:	QUOTED	)"((?:[^\x80-\xff\x00\r\n"\\]|\\["\\])*)"|\
(?# 6:	LPAR	)(\()|\
(?# 7:	RPAR	)(\))|\
(?# 8:	BSLASH	)(\\)|\
(?# 9:	STAR	)(\*)|\
(?# 10:	LBRA	)(\[)|\
(?# 11:	RBRA	)(\])|\
(?# 12:	LITERAL	)\{(\d+)\}\r\n|\
(?# 13:	PLUS	)(\+)|\
(?# 14:	PERCENT	)(%)|\
(?# 15:	CRLF	)(\r\n)|\
(?# 16:	EOF	)(\z))/ni

      DATA_REGEXP = /\G(?:\
(?# 1:	SPACE	)( )|\
(?# 2:	NIL	)(NIL)|\
(?# 3:	NUMBER	)(\d+)|\
(?# 4:	QUOTED	)"((?:[^\x80-\xff\x00\r\n"\\]|\\["\\])*)"|\
(?# 5:	LITERAL	)\{(\d+)\}\r\n|\
(?# 6:	LPAR	)(\()|\
(?# 7:	RPAR	)(\)))/ni

      TEXT_REGEXP = /\G(?:\
(?# 1:	TEXT	)([^\x00\x80-\xff\r\n]*))/ni

      RTEXT_REGEXP = /\G(?:\
(?# 1:	LBRA	)(\[)|\
(?# 2:	TEXT	)([^\x00\x80-\xff\r\n]*))/ni

      CTEXT_REGEXP = /\G(?:\
(?# 1:	TEXT	)([^\x00\x80-\xff\r\n\]]*))/ni

      Token = Struct.new(:symbol, :value)

      def response
	token = lookahead
	case token.symbol
	when T_PLUS
	  result = continue_req
	when T_STAR
	  result = response_untagged
	else
	  result = response_tagged
	end
	match(T_CRLF)
	match(T_EOF)
	return result
      end

      def continue_req
	match(T_PLUS)
	match(T_SPACE)
	return ContinuationRequest.new(resp_text, @@str)
      end

      def response_untagged
	match(T_STAR)
	match(T_SPACE)
	token = lookahead
	if token.symbol == T_NUMBER
	  return numeric_response
	elsif token.symbol == T_ATOM
	  case token.value
	  when /\A(?:OK|NO|BAD|BYE|PREAUTH)\z/ni
	    return response_cond
	  when /\A(?:FLAGS)\z/ni
	    return flags_response
	  when /\A(?:LIST|LSUB)\z/ni
	    return list_response
	  when /\A(?:QUOTA)\z/ni
	    return getquota_response
	  when /\A(?:QUOTAROOT)\z/ni
	    return getquotaroot_response
	  when /\A(?:ACL)\z/ni
	    return getacl_response
	  when /\A(?:SEARCH|SORT)\z/ni
	    return search_response
	  when /\A(?:STATUS)\z/ni
	    return status_response
	  when /\A(?:CAPABILITY)\z/ni
	    return capability_response
	  else
	    return text_response
	  end
	else
	  parse_error("unexpected token %s", token.symbol)
	end
      end

      def response_tagged
	tag = atom
	match(T_SPACE)
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	return TaggedResponse.new(tag, name, resp_text, @@str)
      end

      def response_cond
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	return UntaggedResponse.new(name, resp_text, @@str)
      end

      def numeric_response
	n = number
	match(T_SPACE)
	token = match(T_ATOM)
	name = token.value.upcase
	case name
	when "EXISTS", "RECENT", "EXPUNGE"
	  return UntaggedResponse.new(name, n, @@str)
	when "FETCH"
	  shift_token
	  match(T_SPACE)
	  data = FetchData.new(n, msg_att)
	  return UntaggedResponse.new(name, data, @@str)
	end
      end

      def msg_att
	match(T_LPAR)
	attr = {}
	while true
	  token = lookahead
	  case token.symbol
	  when T_RPAR
	    shift_token
	    break
	  when T_SPACE
	    shift_token
	    token = lookahead
	  end
	  case token.value
	  when /\A(?:ENVELOPE)\z/ni
	    name, val = envelope_data
	  when /\A(?:FLAGS)\z/ni
	    name, val = flags_data
	  when /\A(?:INTERNALDATE)\z/ni
	    name, val = internaldate_data
	  when /\A(?:RFC822(?:\.HEADER|\.TEXT)?)\z/ni
	    name, val = rfc822_text
	  when /\A(?:RFC822\.SIZE)\z/ni
	    name, val = rfc822_size
	  when /\A(?:BODY(?:STRUCTURE)?)\z/ni
	    name, val = body_data
	  when /\A(?:UID)\z/ni
	    name, val = uid_data
	  else
	    parse_error("unknown attribute `%s'", token.value)
	  end
	  attr[name] = val
	end
	return attr
      end

      def envelope_data
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	return name, envelope
      end

      def envelope
	@@lex_state = EXPR_DATA
	match(T_LPAR)
	date = nstring
	match(T_SPACE)
	subject = nstring
	match(T_SPACE)
	from = address_list
	match(T_SPACE)
	sender = address_list
	match(T_SPACE)
	reply_to = address_list
	match(T_SPACE)
	to = address_list
	match(T_SPACE)
	cc = address_list
	match(T_SPACE)
	bcc = address_list
	match(T_SPACE)
	in_reply_to = nstring
	match(T_SPACE)
	message_id = nstring
	match(T_RPAR)
	@@lex_state = EXPR_BEG
	return Envelope.new(date, subject, from, sender, reply_to,
			    to, cc, bcc, in_reply_to, message_id)
      end

      def flags_data
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	return name, flag_list
      end

      def internaldate_data
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	token = match(T_QUOTED)
	return name, token.value
      end

      def rfc822_text
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	return name, nstring
      end

      def rfc822_size
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	return name, number
      end

      def body_data
	token = match(T_ATOM)
	name = token.value.upcase
	token = lookahead
	if token.symbol == T_SPACE
	  shift_token
	  return name, body
	end
	name.concat(section)
	token = lookahead
	if token.symbol == T_ATOM
	  name.concat(token.value)
	  shift_token
	end
	match(T_SPACE)
	data = nstring
	return name, data
      end

      def body
	@@lex_state = EXPR_DATA
	match(T_LPAR)
	token = lookahead
	if token.symbol == T_LPAR
	  result = body_type_mpart
	else
	  result = body_type_1part
	end
	match(T_RPAR)
	@@lex_state = EXPR_BEG
	return result
      end

      def body_type_1part
	token = lookahead
	case token.value
	when /\A(?:TEXT)\z/ni
	  return body_type_text
	when /\A(?:MESSAGE)\z/ni
	  return body_type_msg
	else
	  return body_type_basic
	end
      end

      def body_type_basic
	mtype, msubtype = media_type
	match(T_SPACE)
	param, content_id, desc, enc, size = body_fields
	md5, disposition, language, extension = body_ext_1part
	return BodyTypeBasic.new(mtype, msubtype,
				 param, content_id,
				 desc, enc, size,
				 md5, disposition, language, extension)
      end

      def body_type_text
	mtype, msubtype = media_type
	match(T_SPACE)
	param, content_id, desc, enc, size = body_fields
	match(T_SPACE)
	lines = number
	md5, disposition, language, extension = body_ext_1part
	return BodyTypeText.new(mtype, msubtype,
				param, content_id,
				desc, enc, size,
				lines,
				md5, disposition, language, extension)
      end

      def body_type_msg
	mtype, msubtype = media_type
	match(T_SPACE)
	param, content_id, desc, enc, size = body_fields
	match(T_SPACE)
	env = envelope
	match(T_SPACE)
	b = body
	match(T_SPACE)
	lines = number
	md5, disposition, language, extension = body_ext_1part
	return BodyTypeMessage.new(mtype, msubtype,
				   param, content_id,
				   desc, enc, size,
				   env, b, lines,
				   md5, disposition, language, extension)
      end

      def body_type_mpart
	parts = []
	while true
	  token = lookahead
	  if token.symbol == T_SPACE
	    shift_token
	    break
	  end
	  parts.push(body)
	end
	mtype = "MULTIPART"
	msubtype = string.upcase
	param, disposition, language, extension = body_ext_mpart
	return BodyTypeMultipart.new(mtype, msubtype, parts,
				     param, disposition, language,
				     extension)
      end

      def media_type
	mtype = string.upcase
	match(T_SPACE)
	msubtype = string.upcase
	return mtype, msubtype
      end

      def body_fields
	param = body_fld_param
	match(T_SPACE)
	content_id = nstring
	match(T_SPACE)
	desc = nstring
	match(T_SPACE)
	enc = string.upcase
	match(T_SPACE)
	size = number
	return param, content_id, desc, enc, size
      end

      def body_fld_param
	token = lookahead
	if token.symbol == T_NIL
	  shift_token
	  return nil
	end
	match(T_LPAR)
	param = {}
	while true
	  token = lookahead
	  case token.symbol
	  when T_RPAR
	    shift_token
	    break
	  when T_SPACE
	    shift_token
	  end
	  name = string.upcase
	  match(T_SPACE)
	  val = string
	  param[name] = val
	end
	return param
      end

      def body_ext_1part
	token = lookahead
	if token.symbol == T_SPACE
	  shift_token
	else
	  return nil
	end
	md5 = nstring

	token = lookahead
	if token.symbol == T_SPACE
	  shift_token
	else
	  return md5
	end
	disposition = body_fld_dsp

	token = lookahead
	if token.symbol == T_SPACE
	  shift_token
	else
	  return md5, disposition
	end
	language = body_fld_lang

	token = lookahead
	if token.symbol == T_SPACE
	  shift_token
	else
	  return md5, disposition, language
	end

	extension = body_extensions
	return md5, disposition, language, extension
      end

      def body_ext_mpart
	token = lookahead
	if token.symbol == T_SPACE
	  shift_token
	else
	  return nil
	end
	param = body_fld_param

	token = lookahead
	if token.symbol == T_SPACE
	  shift_token
	else
	  return param
	end
	disposition = body_fld_dsp
	match(T_SPACE)
	language = body_fld_lang

	token = lookahead
	if token.symbol == T_SPACE
	  shift_token
	else
	  return param, disposition, language
	end

	extension = body_extensions
	return param, disposition, language, extension
      end

      def body_fld_dsp
	token = lookahead
	if token.symbol == T_NIL
	  shift_token
	  return nil
	end
	match(T_LPAR)
	dsp_type = string.upcase
	match(T_SPACE)
	param = body_fld_param
	match(T_RPAR)
	return ContentDisposition.new(dsp_type, param)
      end

      def body_fld_lang
	token = lookahead
	if token.symbol == T_LPAR
	  shift_token
	  result = []
	  while true
	    token = lookahead
	    case token.symbol
	    when T_RPAR
	      shift_token
	      return result
	    when T_SPACE
	      shift_token
	    end
	    result.push(string.upcase)
	  end
	else
	  lang = nstring
	  if lang
	    return lang.upcase
	  else
	    return lang
	  end
	end
      end

      def body_extensions
	result = []
	while true
	  token = lookahead
	  case token.symbol
	  when T_RPAR
	    return result
	  when T_SPACE
	    shift_token
	  end
	  result.push(body_extension)
	end
      end

      def body_extension
	token = lookahead
	case token.symbol
	when T_LPAR
	  shift_token
	  result = body_extensions
	  match(T_RPAR)
	  return result
	when T_NUMBER
	  return number
	else
	  return nstring
	end
      end

      def section
	str = ""
	token = match(T_LBRA)
	str.concat(token.value)
	token = match(T_ATOM, T_NUMBER, T_RBRA)
	if token.symbol == T_RBRA
	  str.concat(token.value)
	  return str
	end
	str.concat(token.value)
	token = lookahead
	if token.symbol == T_SPACE
	  shift_token
	  str.concat(token.value)
	  token = match(T_LPAR)
	  str.concat(token.value)
	  while true
	    token = lookahead
	    case token.symbol
	    when T_RPAR
	      str.concat(token.value)
	      shift_token
	      break
	    when T_SPACE
	      shift_token
	      str.concat(token.value)
	    end
	    str.concat(format_string(astring))
	  end
	end
	token = match(T_RBRA)
	str.concat(token.value)
	return str
      end

      def format_string(str)
	case str
	when ""
	  return '""'
	when /[\x80-\xff\r\n]/n
	  # literal
	  return "{" + str.length.to_s + "}" + CRLF + str
	when /[(){ \x00-\x1f\x7f%*"\\]/n
	  # quoted string
	  return '"' + str.gsub(/["\\]/n, "\\\\\\&") + '"'
	else
	  # atom
	  return str
	end
      end

      def uid_data
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	return name, number
      end

      def text_response
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	@@lex_state = EXPR_TEXT
	token = match(T_TEXT)
	@@lex_state = EXPR_BEG
	return UntaggedResponse.new(name, token.value)
      end

      def flags_response
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	return UntaggedResponse.new(name, flag_list, @@str)
      end

      def list_response
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	return UntaggedResponse.new(name, mailbox_list, @@str)
      end

      def mailbox_list
	attr = flag_list
	match(T_SPACE)
	token = match(T_QUOTED, T_NIL)
	if token.symbol == T_NIL
	  delim = nil
	else
	  delim = token.value
	end
	match(T_SPACE)
	name = astring
	return MailboxList.new(attr, delim, name)
      end

      def getquota_response
        # If quota never established, get back
        # `NO Quota root does not exist'.
        # If quota removed, get `()' after the
        # folder spec with no mention of `STORAGE'.
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        mailbox = astring
        match(T_SPACE)
        match(T_LPAR)
        token = lookahead
        case token.symbol
        when T_RPAR
          shift_token
          data = MailboxQuota.new(mailbox, nil, nil)
          return UntaggedResponse.new(name, data, @@str)
        when T_ATOM
          shift_token
          match(T_SPACE)
          token = match(T_NUMBER)
          usage = token.value
          match(T_SPACE)
          token = match(T_NUMBER)
          quota = token.value
          match(T_RPAR)
          data = MailboxQuota.new(mailbox, usage, quota)
          return UntaggedResponse.new(name, data, @@str)
        else
          parse_error("unexpected token %s", token.symbol)
        end
      end

      def getquotaroot_response
        # Similar to getquota, but only admin can use getquota.
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        mailbox = astring
        quotaroots = []
        while true
          token = lookahead
          break unless token.symbol == T_SPACE
          shift_token
          quotaroots.push(astring)
        end
        data = MailboxQuotaRoot.new(mailbox, quotaroots)
        return UntaggedResponse.new(name, data, @@str)
      end

      def getacl_response
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        mailbox = astring
        data = []
        token = lookahead
        if token.symbol == T_SPACE
          shift_token
          while true
            token = lookahead
            case token.symbol
            when T_CRLF
              break
            when T_SPACE
              shift_token
            end
            user = astring
            match(T_SPACE)
            rights = astring
            ##XXX data.push([user, rights])
            data.push(MailboxACLItem.new(user, rights))
          end
        end
	return UntaggedResponse.new(name, data, @@str)
      end

      def search_response
	token = match(T_ATOM)
	name = token.value.upcase
	token = lookahead
	if token.symbol == T_SPACE
	  shift_token
	  data = []
	  while true
	    token = lookahead
	    case token.symbol
	    when T_CRLF
	      break
	    when T_SPACE
	      shift_token
	    end
	    data.push(number)
	  end
	else
	  data = []
	end
	return UntaggedResponse.new(name, data, @@str)
      end

      def status_response
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	mailbox = astring
	match(T_SPACE)
	match(T_LPAR)
	attr = {}
	while true
	  token = lookahead
	  case token.symbol
	  when T_RPAR
	    shift_token
	    break
	  when T_SPACE
	    shift_token
	  end
	  token = match(T_ATOM)
	  key = token.value.upcase
	  match(T_SPACE)
	  val = number
	  attr[key] = val
	end
	data = StatusData.new(mailbox, attr)
	return UntaggedResponse.new(name, data, @@str)
      end

      def capability_response
	token = match(T_ATOM)
	name = token.value.upcase
	match(T_SPACE)
	data = []
	while true
	  token = lookahead
	  case token.symbol
	  when T_CRLF
	    break
	  when T_SPACE
	    shift_token
	  end
	  data.push(atom.upcase)
	end
	return UntaggedResponse.new(name, data, @@str)
      end

      def resp_text
	@@lex_state = EXPR_RTEXT
	token = lookahead
	if token.symbol == T_LBRA
	  code = resp_text_code
	else
	  code = nil
	end
	token = match(T_TEXT)
	@@lex_state = EXPR_BEG
	return ResponseText.new(code, token.value)
      end

      def resp_text_code
	@@lex_state = EXPR_BEG
	match(T_LBRA)
	token = match(T_ATOM)
	name = token.value.upcase
	case name
	when /\A(?:ALERT|PARSE|READ-ONLY|READ-WRITE|TRYCREATE)\z/n
	  result = ResponseCode.new(name, nil)
	when /\A(?:PERMANENTFLAGS)\z/n
	  match(T_SPACE)
	  result = ResponseCode.new(name, flag_list)
	when /\A(?:UIDVALIDITY|UIDNEXT|UNSEEN)\z/n
	  match(T_SPACE)
	  result = ResponseCode.new(name, number)
	else
	  match(T_SPACE)
	  @@lex_state = EXPR_CTEXT
	  token = match(T_TEXT)
	  @@lex_state = EXPR_BEG
	  result = ResponseCode.new(name, token.value)
	end
	match(T_RBRA)
	@@lex_state = EXPR_RTEXT
	return result
      end

      def address_list
	token = lookahead
	if token.symbol == T_NIL
	  shift_token
	  return nil
	else
	  result = []
	  match(T_LPAR)
	  while true
	    token = lookahead
	    case token.symbol
	    when T_RPAR
	      shift_token
	      break
	    when T_SPACE
	      shift_token
	    end
	    result.push(address)
	  end
	  return result
	end
      end

      ADDRESS_REGEXP = /\G\
(?# 1: NAME	)(?:NIL|"((?:[^\x80-\xff\x00\r\n"\\]|\\["\\])*)") \
(?# 2: ROUTE	)(?:NIL|"((?:[^\x80-\xff\x00\r\n"\\]|\\["\\])*)") \
(?# 3: MAILBOX	)(?:NIL|"((?:[^\x80-\xff\x00\r\n"\\]|\\["\\])*)") \
(?# 4: HOST	)(?:NIL|"((?:[^\x80-\xff\x00\r\n"\\]|\\["\\])*)")\
\)/ni

      def address
	match(T_LPAR)
	if @@str.index(ADDRESS_REGEXP, @@pos)
	  # address does not include literal.
	  @@pos = $~.end(0)
	  name = $1
	  route = $2
	  mailbox = $3
	  host = $4
	  for s in [name, route, mailbox, host]
	    if s
	      s.gsub!(/\\(["\\])/n, "\\1")
	    end
	  end
	else
	  name = nstring
	  match(T_SPACE)
	  route = nstring
	  match(T_SPACE)
	  mailbox = nstring
	  match(T_SPACE)
	  host = nstring
	  match(T_RPAR)
	end
	return Address.new(name, route, mailbox, host)
      end

#        def flag_list
#  	result = []
#  	match(T_LPAR)
#  	while true
#  	  token = lookahead
#  	  case token.symbol
#  	  when T_RPAR
#  	    shift_token
#  	    break
#  	  when T_SPACE
#  	    shift_token
#  	  end
#  	  result.push(flag)
#  	end
#  	return result
#        end

#        def flag
#  	token = lookahead
#  	if token.symbol == T_BSLASH
#  	  shift_token
#  	  token = lookahead
#  	  if token.symbol == T_STAR
#  	    shift_token
#  	    return token.value.intern
#  	  else
#  	    return atom.intern
#  	  end
#  	else
#  	  return atom
#  	end
#        end

      FLAG_REGEXP = /\
(?# FLAG	)\\([^\x80-\xff(){ \x00-\x1f\x7f%"\\]+)|\
(?# ATOM	)([^\x80-\xff(){ \x00-\x1f\x7f%*"\\]+)/n

      def flag_list
	if @@str.index(/\(([^)]*)\)/ni, @@pos)
	  @@pos = $~.end(0)
	  return $1.scan(FLAG_REGEXP).collect { |flag, atom|
	    atom || flag.capitalize.intern
	  }
	else
	  parse_error("invalid flag list")
	end
      end

      def nstring
	token = lookahead
	if token.symbol == T_NIL
	  shift_token
	  return nil
	else
	  return string
	end
      end

      def astring
	token = lookahead
	if string_token?(token)
	  return string
	else
	  return atom
	end
      end

      def string
	token = match(T_QUOTED, T_LITERAL)
	return token.value
      end

      STRING_TOKENS = [T_QUOTED, T_LITERAL]

      def string_token?(token)
	return STRING_TOKENS.include?(token.symbol)
      end

      def atom
  	result = ""
  	while true
  	  token = lookahead
  	  if atom_token?(token)
  	    result.concat(token.value)
  	    shift_token
  	  else
  	    if result.empty?
  	      parse_error("unexpected token %s", token.symbol)
  	    else
  	      return result
  	    end
  	  end
  	end
      end

      ATOM_TOKENS = [
	T_ATOM,
	T_NUMBER,
	T_NIL,
	T_LBRA,
	T_RBRA,
	T_PLUS
      ]

      def atom_token?(token)
	return ATOM_TOKENS.include?(token.symbol)
      end

      def number
	token = match(T_NUMBER)
	return token.value.to_i
      end

      def nil_atom
	match(T_NIL)
	return nil
      end

      def match(*args)
	token = lookahead
	unless args.include?(token.symbol)
	  parse_error('unexpected token %s (expected %s)',
		      token.symbol.id2name,
		      args.collect {|i| i.id2name}.join(" or "))
	end
	shift_token
	return token
      end

      def lookahead
	unless @@token
	  @@token = next_token
	end
	return @@token
      end

      def shift_token
	@@token = nil
      end

      def next_token
	case @@lex_state
	when EXPR_BEG
	  if @@str.index(BEG_REGEXP, @@pos)
	    @@pos = $~.end(0)
	    if $1
	      return Token.new(T_SPACE, $+)
	    elsif $2
	      return Token.new(T_NIL, $+)
	    elsif $3
	      return Token.new(T_NUMBER, $+)
	    elsif $4
	      return Token.new(T_ATOM, $+)
	    elsif $5
	      return Token.new(T_QUOTED,
			       $+.gsub(/\\(["\\])/n, "\\1"))
	    elsif $6
	      return Token.new(T_LPAR, $+)
	    elsif $7
	      return Token.new(T_RPAR, $+)
	    elsif $8
	      return Token.new(T_BSLASH, $+)
	    elsif $9
	      return Token.new(T_STAR, $+)
	    elsif $10
	      return Token.new(T_LBRA, $+)
	    elsif $11
	      return Token.new(T_RBRA, $+)
	    elsif $12
	      len = $+.to_i
	      val = @@str[@@pos, len]
	      @@pos += len
	      return Token.new(T_LITERAL, val)
	    elsif $13
	      return Token.new(T_PLUS, $+)
	    elsif $14
	      return Token.new(T_PERCENT, $+)
	    elsif $15
	      return Token.new(T_CRLF, $+)
	    elsif $16
	      return Token.new(T_EOF, $+)
	    else
	      parse_error("[Net::IMAP BUG] BEG_REGEXP is invalid")
	    end
	  else
	    @@str.index(/\S*/n, @@pos)
	    parse_error("unknown token - %s", $&.dump)
	  end
	when EXPR_DATA
	  if @@str.index(DATA_REGEXP, @@pos)
	    @@pos = $~.end(0)
	    if $1
	      return Token.new(T_SPACE, $+)
	    elsif $2
	      return Token.new(T_NIL, $+)
	    elsif $3
	      return Token.new(T_NUMBER, $+)
	    elsif $4
	      return Token.new(T_QUOTED,
			       $+.gsub(/\\(["\\])/n, "\\1"))
	    elsif $5
	      len = $+.to_i
	      val = @@str[@@pos, len]
	      @@pos += len
	      return Token.new(T_LITERAL, val)
	    elsif $6
	      return Token.new(T_LPAR, $+)
	    elsif $7
	      return Token.new(T_RPAR, $+)
	    else
	      parse_error("[Net::IMAP BUG] BEG_REGEXP is invalid")
	    end
	  else
	    @@str.index(/\S*/n, @@pos)
	    parse_error("unknown token - %s", $&.dump)
	  end
	when EXPR_TEXT
	  if @@str.index(TEXT_REGEXP, @@pos)
	    @@pos = $~.end(0)
	    if $1
	      return Token.new(T_TEXT, $+)
	    else
	      parse_error("[Net::IMAP BUG] TEXT_REGEXP is invalid")
	    end
	  else
	    @@str.index(/\S*/n, @@pos)
	    parse_error("unknown token - %s", $&.dump)
	  end
	when EXPR_RTEXT
	  if @@str.index(RTEXT_REGEXP, @@pos)
	    @@pos = $~.end(0)
	    if $1
	      return Token.new(T_LBRA, $+)
	    elsif $2
	      return Token.new(T_TEXT, $+)
	    else
	      parse_error("[Net::IMAP BUG] RTEXT_REGEXP is invalid")
	    end
	  else
	    @@str.index(/\S*/n, @@pos)
	    parse_error("unknown token - %s", $&.dump)
	  end
	when EXPR_CTEXT
	  if @@str.index(CTEXT_REGEXP, @@pos)
	    @@pos = $~.end(0)
	    if $1
	      return Token.new(T_TEXT, $+)
	    else
	      parse_error("[Net::IMAP BUG] CTEXT_REGEXP is invalid")
	    end
	  else
	    @@str.index(/\S*/n, @@pos) #/
	    parse_error("unknown token - %s", $&.dump)
	  end
	else
	  parse_error("illegal @@lex_state - %s", @@lex_state.inspect)
	end
      end

      def parse_error(fmt, *args)
	if IMAP.debug
	  $stderr.printf("@@str: %s\n", @@str.dump)
	  $stderr.printf("@@pos: %d\n", @@pos)
	  $stderr.printf("@@lex_state: %s\n", @@lex_state)
	  if @@token.symbol
	    $stderr.printf("@@token.symbol: %s\n", @@token.symbol)
	    $stderr.printf("@@token.value: %s\n", @@token.value.inspect)
	  end
	end
	raise ResponseParseError, format(fmt, *args)
      end
    end

    class LoginAuthenticator
      def process(data)
	case @@state
	when STATE_USER
	  @@state = STATE_PASSWORD
	  return @@user
	when STATE_PASSWORD
	  return @@password
	end
      end

      private

      STATE_USER = :USER
      STATE_PASSWORD = :PASSWORD

      def initialize(user, password)
	@@user = user
	@@password = password
	@@state = STATE_USER
      end
    end
    add_authenticator "LOGIN", LoginAuthenticator

    class CramMD5Authenticator
      def process(challenge)
	digest = hmac_md5(challenge, @@password)
	return @@user + " " + digest
      end

      private

      def initialize(user, password)
	@@user = user
	@@password = password
      end

      def hmac_md5(text, key)
	if key.length > 64
	  key = Digest::MD5.digest(key)
	end

	k_ipad = key + "\0" * (64 - key.length)
	k_opad = key + "\0" * (64 - key.length)
	for i in 0..63
	  k_ipad[i] ^= 0x36
	  k_opad[i] ^= 0x5c
	end

	digest = Digest::MD5.digest(k_ipad + text)

	return Digest::MD5.hexdigest(k_opad + digest)
      end
    end
    add_authenticator "CRAM-MD5", CramMD5Authenticator

    class Error < StandardError
    end

    class DataFormatError < Error
    end

    class ResponseParseError < Error
    end

    class ResponseError < Error
    end

    class NoResponseError < ResponseError
    end

    class BadResponseError < ResponseError
    end

    class ByeResponseError < ResponseError
    end
  end
end

if __FILE__ == $0
  require "getoptlong"

  $stdout.sync = true
  $port = "imap2"
  $user = ENV["USER"] || ENV["LOGNAME"]
  $auth = "cram-md5"

  def usage
    $stderr.print <<EOF
usage: #{$0} [options] <host>

  --help                        print this message
  --port=PORT                   specifies port
  --user=USER                   specifies user
  --auth=AUTH                   specifies auth type
EOF
  end

  def get_password
    print "password: "
    system("stty", "-echo")
    begin
      return gets.chop
    ensure
      system("stty", "echo")
      print "\n"
    end
  end

  def get_command
    printf("%s@@%s> ", $user, $host)
    if line = gets
      return line.strip.split(/\s+/)
    else
      return nil
    end
  end

  parser = GetoptLong.new
  parser.set_options(['--help', GetoptLong::NO_ARGUMENT],
		     ['--port', GetoptLong::REQUIRED_ARGUMENT],
		     ['--user', GetoptLong::REQUIRED_ARGUMENT],
		     ['--auth', GetoptLong::REQUIRED_ARGUMENT])
  begin
    parser.each_option do |name, arg|
      case name
      when "--port"
	$port = arg
      when "--user"
	$user = arg
      when "--auth"
	$auth = arg
      when "--help"
	usage
	exit(1)
      end
    end
  rescue
    usage
    exit(1)
  end

  $host = ARGV.shift
  unless $host
    usage
    exit(1)
  end
    
  imap = Net::IMAP.new($host, $port)
  begin
    password = get_password
    imap.authenticate($auth, $user, password)
    while true
      cmd, *args = get_command
      break unless cmd
      begin
	case cmd
	when "list"
	  for mbox in imap.list("", args[0] || "*")
	    if mbox.attr.include?(Net::IMAP::NOSELECT)
	      prefix = "!"
	    elsif mbox.attr.include?(Net::IMAP::MARKED)
	      prefix = "*"
	    else
	      prefix = " "
	    end
	    print prefix, mbox.name, "\n"
	  end
	when "select"
	  imap.select(args[0] || "inbox")
	  print "ok\n"
	when "close"
	  imap.close
	  print "ok\n"
	when "summary"
	  unless messages = imap.responses["EXISTS"][-1]
	    puts "not selected"
	    next
	  end
	  if messages > 0
	    for data in imap.fetch(1..-1, ["ENVELOPE"])
	      print data.seqno, ": ", data.attr["ENVELOPE"].subject, "\n"
	    end
	  else
	    puts "no message"
	  end
	when "fetch"
	  if args[0]
	    data = imap.fetch(args[0].to_i, ["RFC822.HEADER", "RFC822.TEXT"])[0]
	    puts data.attr["RFC822.HEADER"]
	    puts data.attr["RFC822.TEXT"]
	  else
	    puts "missing argument"
	  end
	when "logout", "exit", "quit"
	  break
	when "help", "?"
	  print <<EOF
list [pattern]			list mailboxes
select [mailbox]		select mailbox
close				close mailbox
summary				display summary
fetch [msgno]			display message
logout				logout
help, ?				display help message
EOF
	else
	  print "unknown command: ", cmd, "\n"
	end
      rescue Net::IMAP::Error
	puts $!
      end
    end
  ensure
    imap.logout
    imap.disconnect
  end
end
@


1.27
log
@* lib/net/imap.rb: OpenSSL support.
* lib/net/imap.rb (setquota): unset quota if the second argument is nil.
@
text
@d33 1
a33 1
: new(host, port = 143)
d35 6
a40 1
      port on the named host.
d236 30
d429 74
d791 12
d928 10
d955 7
a961 2
    def setacl(mailbox, user, acl)
      send_command("SETACL", mailbox, user, acl)
d1430 2
d1615 2
d2180 17
d2202 1
a2205 1
          data = []
d2216 3
a2218 2
            acl = astring
            data.push([user, acl])
a2219 2
        else
          data = []
@


1.26
log
@One more fix to use Digest::MD5.
@
text
@d687 4
d695 4
d727 1
a727 1
      @@sock.shutdown
d814 1
d816 5
a820 1
      data = '(STORAGE ' + quota.to_s + ')'
d930 1
a930 1
    def initialize(host, port = PORT)
d938 17
d2008 1
a2008 1
        # If no quota set, get back
d2010 2
d2018 20
a2037 10
        match(T_ATOM)
        match(T_SPACE)
        token = match(T_NUMBER)
        usage = token.value
        match(T_SPACE)
        token = match(T_NUMBER)
        quota = token.value
        match(T_RPAR)
        data = MailboxQuota.new(mailbox, usage, quota)
        return UntaggedResponse.new(name, data, @@str)
@


1.25
log
@Reflect the update of the MD5 module which is now Digest::MD5.
@
text
@d686 1
a686 1
require "md5"
@


1.24
log
@* lib/net/imap.rb (getquota_response): use astring for mailbox
names.
* lib/net/imap.rb (getacl_response): ditto.
@
text
@d2502 1
a2502 2
	  md5 = MD5.new(key)
	  key = md5.digest
d2512 1
a2512 4
	md5 = MD5.new
	md5.update(k_ipad)
	md5.update(text)
	digest = md5.digest
d2514 1
a2514 4
	md5 = MD5.new
	md5.update(k_opad)
	md5.update(digest)
	return md5.hexdigest
@


1.23
log
@* lib/net/imap.rb: added new commands for managing folder quotas
and folder ACLs.
@
text
@d1983 1
a1983 2
        token = match(T_ATOM)
        mailbox = token.value
d2002 1
a2002 2
        token = match(T_ATOM)
        mailbox = token.value
@


1.22
log
@* lib/net/imap.rb: fix typo.
@
text
@d799 23
d1263 1
d1445 4
d1975 51
@


1.21
log
@* lib/net/imap.rb (media_subtype): return subtype.
@
text
@d31 1
a31 1
=== Methods
@


1.20
log
@* lib/net/imap.rb (flag_list): capitalize flags.
@
text
@d1259 1
d1276 1
d1293 1
d1308 1
@


1.19
log
@* lib/net/imap.rb: add document and example code.
@
text
@d20 3
a22 5
  t = Thread.start {
    p imap.fetch(1..-1, "UID")
  }
  p imap.search(["BODY", "hello"])
  t.join
d124 1
a124 1
        #=> [#<Net::IMAP::MailboxList attr=[:NoSelect], delim="/", name="foo/">, #<Net::IMAP::MailboxList attr=[:NoInferiors, :Marked], delim="/", name="foo/bar">, #<Net::IMAP::MailboxList attr=[:NoInferiors], delim="/", name="foo/baz">]
d385 2
a386 1
      Returns the name attributes.
d443 2
a444 1
          A array of flag symbols that are set for this message.
d694 12
d2150 1
a2150 1
	    atom || flag.intern
d2546 1
a2546 1
	when "list", "ls"
d2548 8
a2555 1
	    puts mbox.name
d2557 1
a2557 1
	when "select", "cd"
d2560 3
d2564 5
a2568 1
	  if imap.responses["EXISTS"][-1] > 0
d2570 1
a2570 1
	      print data.seqno, " ", data.attr["ENVELOPE"].subject, "\n"
d2575 1
a2575 1
	when "show", "cat"
d2583 1
a2583 1
	when "exit", "quit", "logout"
d2587 7
a2593 5
list [pattern], ls [pattern]		list mailboxes
select [mailbox], cd [mailbox]		select mailbox
summary					display summary
show [msgno], cat [msgno]		display message
help, ?					display help message
@


1.18
log
@* lib/net/imap.rb: rename ContinueRequest to ContinuationRequest.
@
text
@d10 1
a10 1
== class Net::IMAP
d13 1
d33 1
a33 1
=== Class Methods
d120 1
d132 1
d137 1
d187 1
d210 1
d247 435
d797 1
a797 1
	return @@responses.delete("STATUS")[-1][1]
d1235 1
a1235 1
    class BodyTypeBasic < Struct.new(:media_type, :media_subtype,
d1243 5
d1250 1
a1250 1
    class BodyTypeText < Struct.new(:media_type, :media_subtype,
d1259 5
d1266 1
a1266 1
    class BodyTypeMessage < Struct.new(:media_type, :media_subtype,
d1275 5
d1282 1
a1282 1
    class BodyTypeMultipart < Struct.new(:media_type, :media_subtype,
d1289 5
d2453 124
@


1.17
log
@* lib/net/imap.rb: added example.
@
text
@d294 1
a294 1
	if resp.instance_of?(ContinueRequest)
d781 1
a781 1
    ContinueRequest = Struct.new(:data, :raw_data)
d927 1
a927 1
	return ContinueRequest.new(resp_text, @@str)
@


1.16
log
@* lib/net/imap.rb: supports response handlers and multiple commands.
@
text
@d230 5
@


1.15
log
@* lib/net/imap.rb: supports unknown resp_text_code.
@
text
@d14 14
d227 9
d239 1
d244 3
a246 1
    attr_reader :greeting, :responses
d261 2
d267 4
a270 2
      send_command("CAPABILITY")
      return @@responses.delete("CAPABILITY")[-1]
d301 4
a304 2
      @@responses.clear
      send_command("SELECT", mailbox)
d308 4
a311 2
      @@responses.clear
      send_command("EXAMINE", mailbox)
d335 4
a338 2
      send_command("LIST", refname, mailbox)
      return @@responses.delete("LIST")
d342 4
a345 2
      send_command("LSUB", refname, mailbox)
      return @@responses.delete("LSUB")
d349 4
a352 2
      send_command("STATUS", mailbox, attr)
      return @@responses.delete("STATUS")[-1][1]
d374 4
a377 2
      send_command("EXPUNGE")
      return @@responses.delete("EXPUNGE")
d420 8
d437 1
d445 4
a453 1
    end
d455 3
a457 19
    def send_command(cmd, *args, &block)
      tag = generate_tag
      data = args.collect {|i| format_data(i)}.join(" ")
      if data.length > 0
	put_line(tag + " " + cmd + " " + data)
      else
	put_line(tag + " " + cmd)
      end
      return get_all_responses(tag, cmd, &block)
    end

    def generate_tag
      @@tagno += 1
      return format("%s%04d", @@tag_prefix, @@tagno)
    end

    def send_data(*args)
      data = args.collect {|i| format_data(i)}.join(" ")
      put_line(data)
d460 1
a460 9
    def put_line(line)
      line = line + CRLF
      @@sock.print(line)
      if @@@@debug
        $stderr.print(line.gsub(/^/n, "C: "))
      end
    end

    def get_all_responses(tag, cmd, &block)
d462 11
a472 17
	if @@@@debug
	  $stderr.printf("R: %s\n", resp.inspect)
	end
	case resp
	when TaggedResponse
	  case resp.name
	  when /\A(?:NO)\z/ni
	    raise NoResponseError, resp.data.text
	  when /\A(?:BAD)\z/ni
	    raise BadResponseError, resp.data.text
	  else
	    return resp
	  end
	when UntaggedResponse
	  if /\ABYE\z/ni =~ resp.name &&
	      cmd != "LOGOUT"
	    raise ByeResponseError, resp.data.text
d474 2
a475 4
	  record_response(resp.name, resp.data)
	  if resp.data.instance_of?(ResponseText) &&
	      (code = resp.data.code)
	    record_response(code.name, code.data)
d478 15
a492 1
	block.call(resp) if block
d523 40
d629 7
a635 4
      if charset
	send_command(cmd, "CHARSET", charset, *keys)
      else
	send_command(cmd, *keys)
a636 1
      return @@responses.delete("SEARCH")[-1]
d643 5
a647 3
      @@responses.delete("FETCH")
      send_command(cmd, MessageSet.new(set), attr)
      return @@responses.delete("FETCH")
d654 5
a658 3
      @@responses.delete("FETCH")
      send_command(cmd, MessageSet.new(set), attr, flags)
      return @@responses.delete("FETCH")
d672 4
a675 2
      send_command(cmd, sort_keys, charset, *search_keys)
      return @@responses.delete("SORT")[-1]
@


1.14
log
@shugo
@
text
@d1478 6
@


1.14.2.1
log
@* lib/net/imap.rb: supports unknown resp_text_code.
@
text
@a1477 6
	else
	  match(T_SPACE)
	  @@lex_state = EXPR_CTEXT
	  token = match(T_TEXT)
	  @@lex_state = EXPR_BEG
	  result = ResponseCode.new(name, token.value)
@


1.14.2.2
log
@* lib/net/imap.rb: backport from ruby-1.7.
@
text
@d10 1
a10 1
== Net::IMAP
a12 1
(The protocol is described in ((<[IMAP]>)).)
d18 1
a18 1
=== Methods
a104 1
      The return value is an array of ((<Net::IMAP::MailboxList>)).
d110 1
a110 1
        #=> [#<Net::IMAP::MailboxList attr=[:Noselect], delim="/", name="foo/">, #<Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim="/", name="foo/bar">, #<Net::IMAP::MailboxList attr=[:Noinferiors], delim="/", name="foo/baz">]
a115 1
      The return value is an array of ((<Net::IMAP::MailboxList>)).
a119 1
      The return value is a hash of attributes.
a168 1
      The return value is an array of ((<Net::IMAP::FetchData>)).
a190 1
      The return value is an array of ((<Net::IMAP::FetchData>)).
a212 437
== Net::IMAP::ContinuationRequest

Net::IMAP::ContinuationRequest represents command continuation requests.

The command continuation request response is indicated by a "+" token
instead of a tag.  This form of response indicates that the server is
ready to accept the continuation of a command from the client.  The
remainder of this response is a line of text.

  continue_req    ::= "+" SPACE (resp_text / base64)

=== Super Class

Struct

=== Methods

: data
      Returns the data (Net::IMAP::ResponseText).

: raw_data
      Returns the raw data string.

== Net::IMAP::UntaggedResponse

Net::IMAP::UntaggedResponse represents untagged responses.

Data transmitted by the server to the client and status responses
that do not indicate command completion are prefixed with the token
"*", and are called untagged responses.

  response_data   ::= "*" SPACE (resp_cond_state / resp_cond_bye /
                      mailbox_data / message_data / capability_data)

=== Super Class

Struct

=== Methods

: name
      Returns the name such as "FLAGS", "LIST", "FETCH"....

: data
      Returns the data such as an array of flag symbols,
      a ((<Net::IMAP::MailboxList>)) object....

: raw_data
      Returns the raw data string.

== Net::IMAP::TaggedResponse

Net::IMAP::TaggedResponse represents tagged responses.

The server completion result response indicates the success or
failure of the operation.  It is tagged with the same tag as the
client command which began the operation.

  response_tagged ::= tag SPACE resp_cond_state CRLF
  
  tag             ::= 1*<any ATOM_CHAR except "+">
  
  resp_cond_state ::= ("OK" / "NO" / "BAD") SPACE resp_text

=== Super Class

Struct

=== Methods

: tag
      Returns the tag.

: name
      Returns the name. the name is one of "OK", "NO", "BAD".

: data
      Returns the data. See ((<Net::IMAP::ResponseText>)).

: raw_data
      Returns the raw data string.

== Net::IMAP::ResponseText

Net::IMAP::ResponseText represents texts of responses.
The text may be prefixed by the response code.

  resp_text       ::= ["[" resp_text_code "]" SPACE] (text_mime2 / text)
                      ;; text SHOULD NOT begin with "[" or "="
  
=== Super Class

Struct

=== Methods

: code
      Returns the response code. See ((<Net::IMAP::ResponseCode>)).
      
: text
      Returns the text.

== Net::IMAP::ResponseCode

Net::IMAP::ResponseCode represents response codes.

  resp_text_code  ::= "ALERT" / "PARSE" /
                      "PERMANENTFLAGS" SPACE "(" #(flag / "\*") ")" /
                      "READ-ONLY" / "READ-WRITE" / "TRYCREATE" /
                      "UIDVALIDITY" SPACE nz_number /
                      "UNSEEN" SPACE nz_number /
                      atom [SPACE 1*<any TEXT_CHAR except "]">]

=== SuperClass

Struct

=== Methods

: name
      Returns the name such as "ALERT", "PERMANENTFLAGS", "UIDVALIDITY"....

: data
      Returns the data if it exists.

== Net::IMAP::MailboxList

Net::IMAP::MailboxList represents contents of the LIST response.

  mailbox_list    ::= "(" #("\Marked" / "\Noinferiors" /
                      "\Noselect" / "\Unmarked" / flag_extension) ")"
                      SPACE (<"> QUOTED_CHAR <"> / nil) SPACE mailbox

=== Super Class

Struct

=== Methods

: attr
      Returns the name attributes. Each name attribute is a symbol
      capitalized by String#capitalize, such as :Noselect (not :NoSelect).

: delim
      Returns the hierarchy delimiter

: name
      Returns the mailbox name.

== Net::IMAP::StatusData

Net::IMAP::StatusData represents contents of the STATUS response.

=== Super Class

Object

=== Methods

: mailbox
      Returns the mailbox name.

: attr
      Returns a hash. Each key is one of "MESSAGES", "RECENT", "UIDNEXT",
      "UIDVALIDITY", "UNSEEN". Each value is a number.

== Net::IMAP::FetchData

Net::IMAP::FetchData represents contents of the FETCH response.

=== Super Class

Object

=== Methods

: seqno
      Returns the message sequence number.
      (Note: not the unique identifier, even for the UID command response.)

: attr
      Returns a hash. Each key is a data item name, and each value is
      its value.

      The current data items are:

      : BODY
          A form of BODYSTRUCTURE without extension data.
      : BODY[<section>]<<origin_octet>>
          A string expressing the body contents of the specified section.
      : BODYSTRUCTURE
          An object that describes the ((<[MIME-IMB]>)) body structure of a message.
          See ((<Net::IMAP::BodyTypeBasic>)), ((<Net::IMAP::BodyTypeText>)),
          ((<Net::IMAP::BodyTypeMessage>)), ((<Net::IMAP::BodyTypeMultipart>)).
      : ENVELOPE
          A ((<Net::IMAP::Envelope>)) object that describes the envelope
          structure of a message.
      : FLAGS
          A array of flag symbols that are set for this message. flag symbols
          are capitalized by String#capitalize.
      : INTERNALDATE
          A string representing the internal date of the message.
      : RFC822
          Equivalent to BODY[].
      : RFC822.HEADER
          Equivalent to BODY.PEEK[HEADER].
      : RFC822.SIZE
          A number expressing the ((<[RFC-822]>)) size of the message.
      : RFC822.TEXT
          Equivalent to BODY[TEXT].
      : UID
          A number expressing the unique identifier of the message.

== Net::IMAP::Envelope

Net::IMAP::Envelope represents envelope structures of messages.

=== Super Class

Struct

=== Methods

: date
      Retunns a string that represents the date.

: subject
      Retunns a string that represents the subject.

: from
      Retunns an array of ((<Net::IMAP::Address>)) that represents the from.

: sender
      Retunns an array of ((<Net::IMAP::Address>)) that represents the sender.

: reply_to
      Retunns an array of ((<Net::IMAP::Address>)) that represents the reply-to.

: to
      Retunns an array of ((<Net::IMAP::Address>)) that represents the to.

: cc
      Retunns an array of ((<Net::IMAP::Address>)) that represents the cc.

: bcc
      Retunns an array of ((<Net::IMAP::Address>)) that represents the bcc.

: in_reply_to
      Retunns a string that represents the in-reply-to.

: message_id
      Retunns a string that represents the message-id.

== Net::IMAP::Address

((<Net::IMAP::Address>)) represents electronic mail addresses.

=== Super Class

Struct

=== Methods

: name
      Returns the phrase from ((<[RFC-822]>)) mailbox.

: route
      Returns the route from ((<[RFC-822]>)) route-addr.

: mailbox
      nil indicates end of ((<[RFC-822]>)) group.
      If non-nil and host is nil, returns ((<[RFC-822]>)) group name.
      Otherwise, returns ((<[RFC-822]>)) local-part

: host
      nil indicates ((<[RFC-822]>)) group syntax.
      Otherwise, returns ((<[RFC-822]>)) domain name.

== Net::IMAP::ContentDisposition

Net::IMAP::ContentDisposition represents Content-Disposition fields.

=== Super Class

Struct

=== Methods

: dsp_type
      Returns the disposition type.

: param
      Returns a hash that represents parameters of the Content-Disposition
      field.

== Net::IMAP::BodyTypeBasic

Net::IMAP::BodyTypeBasic represents basic body structures of messages.

=== Super Class

Struct

=== Methods

: media_type
      Returns the content media type name as defined in ((<[MIME-IMB]>)).

: subtype
      Returns the content subtype name as defined in ((<[MIME-IMB]>)).

: param
      Returns a hash that represents parameters as defined in
      ((<[MIME-IMB]>)).

: content_id
      Returns a string giving the content id as defined in ((<[MIME-IMB]>)).

: description
      Returns a string giving the content description as defined in
      ((<[MIME-IMB]>)).

: encoding
      Returns a string giving the content transfer encoding as defined in
      ((<[MIME-IMB]>)).

: size
      Returns a number giving the size of the body in octets.

: md5
      Returns a string giving the body MD5 value as defined in ((<[MD5]>)).

: disposition
      Returns a ((<Net::IMAP::ContentDisposition>)) object giving
      the content disposition.

: language
      Returns a string or an array of strings giving the body
      language value as defined in [LANGUAGE-TAGS].

: extension
      Returns extension data.

: multipart?
      Returns false.

== Net::IMAP::BodyTypeText

Net::IMAP::BodyTypeText represents TEXT body structures of messages.

=== Super Class

Struct

=== Methods

: lines
      Returns the size of the body in text lines.

And Net::IMAP::BodyTypeText has all methods of ((<Net::IMAP::BodyTypeBasic>)).

== Net::IMAP::BodyTypeMessage

Net::IMAP::BodyTypeMessage represents MESSAGE/RFC822 body structures of messages.

=== Super Class

Struct

=== Methods

: envelope
      Returns a ((<Net::IMAP::Envelope>)) giving the envelope structure.

: body
      Returns an object giving the body structure.

And Net::IMAP::BodyTypeMessage has all methods of ((<Net::IMAP::BodyTypeText>)).

== Net::IMAP::BodyTypeText

=== Super Class

Struct

=== Methods

: media_type
      Returns the content media type name as defined in ((<[MIME-IMB]>)).

: subtype
      Returns the content subtype name as defined in ((<[MIME-IMB]>)).

: parts
      Returns multiple parts.

: param
      Returns a hash that represents parameters as defined in
      ((<[MIME-IMB]>)).

: disposition
      Returns a ((<Net::IMAP::ContentDisposition>)) object giving
      the content disposition.

: language
      Returns a string or an array of strings giving the body
      language value as defined in [LANGUAGE-TAGS].

: extension
      Returns extension data.

: multipart?
      Returns true.

== References

: [IMAP]
    M. Crispin, "INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1",
    RFC 2060, December 1996.

: [LANGUAGE-TAGS]
    Alvestrand, H., "Tags for the Identification of
    Languages", RFC 1766, March 1995.

: [MD5]
    Myers, J., and M. Rose, "The Content-MD5 Header Field", RFC
    1864, October 1995.

: [MIME-IMB]
    Freed, N., and N. Borenstein, "MIME (Multipurpose Internet
    Mail Extensions) Part One: Format of Internet Message Bodies", RFC
    2045, November 1996.

: [RFC-822]
    Crocker, D., "Standard for the Format of ARPA Internet Text
    Messages", STD 11, RFC 822, University of Delaware, August 1982.

d705 1
a705 1
    class BodyTypeBasic < Struct.new(:media_type, :subtype,
a712 6

      def media_subtype
	$stderr.printf("warning: media_subtype is obsolete.\n")
	$stderr.printf("         use subtype instead.\n")
	return subtype
      end
d715 1
a715 1
    class BodyTypeText < Struct.new(:media_type, :subtype,
a723 6

      def media_subtype
	$stderr.printf("warning: media_subtype is obsolete.\n")
	$stderr.printf("         use subtype instead.\n")
	return subtype
      end
d726 1
a726 1
    class BodyTypeMessage < Struct.new(:media_type, :subtype,
a734 6

      def media_subtype
	$stderr.printf("warning: media_subtype is obsolete.\n")
	$stderr.printf("         use subtype instead.\n")
	return subtype
      end
d737 1
a737 1
    class BodyTypeMultipart < Struct.new(:media_type, :subtype,
a743 6

      def media_subtype
	$stderr.printf("warning: media_subtype is obsolete.\n")
	$stderr.printf("         use subtype instead.\n")
	return subtype
      end
d1588 1
a1588 1
	    atom || flag.capitalize.intern
@


1.14.2.3
log
@* lib/net/imap.rb: fix typo.
@
text
@d19 1
a19 1
=== Class Methods
@


1.14.2.4
log
@Reflect the update of the MD5 module which is now Digest::MD5.
@
text
@d659 1
a659 1
require "digest/md5"
d2326 2
a2327 1
	  key = Digest::MD5.digest(key)
d2337 9
a2345 3
	digest = Digest::MD5.digest(k_ipad + text)

	return Digest::MD5.hexdigest(k_opad + digest)
@


1.13
log
@shugo

* lib/net/imap.rb (ResponseParser#section): accept empty section.
@
text
@d25 1
a25 1
      Returns the debug mode
d28 1
a28 1
      Sets the debug mode
@


1.12
log
@shugo

* lib/net/imap.rb (ResponseParser#address): bug fix.
@
text
@d1291 5
a1295 1
	token = match(T_ATOM, T_NUMBER)
@


1.11
log
@shugo

* lib/net/imap.rb (ResponseParser#section): accept T_NUMBER.
@
text
@d1515 9
a1523 4
	  name = $1 ? $1.gsub(/\\(["\\])/n, "\\1") : nil
	  route = $2 ? $2.gsub(/\\(["\\])/n, "\\1") : nil
	  mailbox = $3 ? $3.gsub(/\\(["\\])/n, "\\1") : nil
	  host = $4 ? $4.gsub(/\\(["\\])/n, "\\1") : nil
@


1.10
log
@shugo

hack for speed
@
text
@d1291 1
a1291 1
	token = match(T_ATOM)
@


1.9
log
@shugo

* lib/net/imap.rb: hack for speed.
@
text
@d1503 7
d1512 17
a1528 8
	name = nstring
	match(T_SPACE)
	route = nstring
	match(T_SPACE)
	mailbox = nstring
	match(T_SPACE)
	host = nstring
	match(T_RPAR)
d1532 37
d1570 5
a1574 27
	result = []
	match(T_LPAR)
	while true
	  token = lookahead
	  case token.symbol
	  when T_RPAR
	    shift_token
	    break
	  when T_SPACE
	    shift_token
	  end
	  result.push(flag)
	end
	return result
      end

      def flag
	token = lookahead
	if token.symbol == T_BSLASH
	  shift_token
	  token = lookahead
	  if token.symbol == T_STAR
	    shift_token
	    return token.value.intern
	  else
	    return atom.intern
	  end
d1576 1
a1576 1
	  return atom
@


1.8
log
@shugo
@
text
@d433 1
a433 1
	  $stderr.puts(resp.inspect)
d757 5
a761 4
      EXPR_BEG		= :BEG
      EXPR_TEXT		= :TEXT
      EXPR_RTEXT	= :RTEXT
      EXPR_CTEXT	= :CTEXT
d799 9
d945 1
d967 1
d1021 1
d1030 1
d1656 1
a1656 1
				 $+.gsub(/\\(["\\])/n, "\\1"))
d1682 28
@


1.7
log
@shugo
* lib/net/imap.rb (Net::IMAP#append): don't call Flag::new.
@
text
@d44 1
a44 1
        #=> [2]
d46 1
a46 1
        #=> [968263756]
d110 1
a110 1
        #=> [[[:NoSelect], "/", "foo/"], [[:NoInferiors], "/", "foo/baz"], [[:NoInferiors], "/", "foo/bar"]]
d123 1
a123 1
        #=> {"RECENT"=>0, "MESSAGES"=>5}
d172 1
a172 1
        #=> [[6, ["UID", 98]], [7, ["UID", 99]], [8, ["UID", 100]]]
d174 5
a178 4
        #=> [[6, ["BODY[HEADER.FIELDS (\"SUBJECT\")]", "Subject: test\r\n\r\n"]]]
        seqno, data = imap.uid_fetch(98, ["RFC822.SIZE", "INTERNALDATE"])[0]
        attr = Hash[*data]
        p attr["RFC822.SIZE"]
d180 1
a180 1
        p attr["INTERNALDATE"]
d182 1
a182 1
        p attr["UID"]
d194 1
a194 1
        #=> [[6, ["FLAGS", [:Seen, :Deleted]]], [7, ["FLAGS", [:Seen, :Deleted]]], [8, ["FLAGS", [:Deleted]]]]
d259 2
a260 2
	if resp.prefix == "+"
	  data = authenticator.process(resp[0].unpack("m")[0])
d312 1
a312 2
      status_list = @@responses.delete("STATUS")[-1][1]
      return Hash[*status_list]
d335 1
a335 1
      return @@responses.delete("EXPUNGE").collect {|i| i[0]}
d435 2
a436 1
	if resp.prefix == tag
d438 4
a441 4
	  when /\ANO\z/ni
	    raise NoResponseError, resp[0]
	  when /\ABAD\z/ni
	    raise BadResponseError, resp[0]
d445 9
a453 11
	else
	  if resp.prefix == "*"
	    if /\ABYE\z/ni =~ resp.name &&
		cmd != "LOGOUT"
	      raise ByeResponseError, resp[0]
	    end
	    record_response(resp.name, resp.data)
	    if /\A(OK|NO|BAD)\z/ni =~ resp.name &&
		resp[0].instance_of?(Array)
	      record_response(resp[0][0], resp[0][1..-1])
	    end
a454 1
	  block.call(resp) if block
d456 1
a480 1
      name = name.upcase
d510 1
a510 1
      when /[\r\n]/n
d565 1
d574 1
d692 22
a713 2
    class Response
      attr_reader :prefix, :name, :data, :raw_data
d715 8
a722 7
      def inspect
	s = @@data.collect{|i| i.inspect}.join(" ")
	if @@name
	  return "#<Response: " + @@prefix + " " + @@name + " " + s + ">"
	else
	  return "#<Response: " + @@prefix + " " + s + ">"
	end
d724 1
d726 8
a733 2
      def method_missing(mid, *args)
	return @@data.send(mid, *args)
d735 1
d737 6
a742 17
      private

      def initialize(prefix, data, raw_data)
	@@prefix = prefix
	if prefix == "+"
	  @@name = nil
	else
	  data.each_with_index do |item, i|
	    if item.instance_of?(String)
	      @@name = item
	      data.delete_at(i)
	      break
	    end
	  end
	end
	@@data = data
	@@raw_data = raw_data
d750 3
a752 3
	@@lex_state = EXPR_DATA
	@@token.symbol = nil
	return parse_response
d757 1
a757 1
      EXPR_DATA		= :DATA
d759 2
a760 2
      EXPR_CODE		= :CODE
      EXPR_CODE_TEXT	= :CODE_TEXT
d762 1
a764 1
      T_ATTR	= :ATTR
d767 6
d774 2
a775 4
      T_FLAG	= :FLAG
      T_LPAREN	= :LPAREN
      T_RPAREN	= :RPAREN
      T_STAR	= :STAR
a777 2
      T_LBRA	= :LBRA
      T_RBRA	= :RBRA
d780 17
a796 22
      DATA_REGEXP = /\G *(?:\
(?# 1:	NIL	)(NIL)|\
(?# 2:	NUMBER	)(\d+)|\
(?# 3:	ATTR	)(BODY\[[^\]]*\](?:<\d+>)?)|\
(?# 4:	ATOM	)([^(){ \x00-\x1f\x7f%*"\\]+)|\
(?# 5:	QUOTED	)"((?:[^"\\]|\\["\\])*)"|\
(?# 6:	LITERAL	)\{(\d+)\}\r\n|\
(?# 7:	FLAG	)(\\(?:[^(){ \x00-\x1f\x7f%*"\\]+|\*))|\
(?# 8:	LPAREN	)(\()|\
(?# 9:	RPAREN	)(\))|\
(?# 10:	STAR	)(\*)|\
(?# 11:	CRLF	)(\r\n)|\
(?# 12:	EOF	)(\z))/ni

      CODE_REGEXP = /\G *(?:\
(?# 1:	NUMBER	)(\d+)|\
(?# 2:	ATOM	)([^(){ \x00-\x1f\x7f%*"\\\[\]]+)|\
(?# 3:	FLAG	)(\\(?:[^(){ \x00-\x1f\x7f%*"\\]+|\*))|\
(?# 4:	LPAREN	)(\()|\
(?# 5:	RPAREN	)(\))|\
(?# 6:	LBRA	)(\[)|\
(?# 7:	RBRA	)(\]))/ni
d798 2
a799 2
      CODE_TEXT_REGEXP = /\G *(?:\
(?# 1:	TEXT	)([^\r\n\]]*))/ni
d801 1
a801 1
      TEXT_REGEXP = /\G *(?:\
d803 1
a803 1
(?# 2:	TEXT	)([^\r\n]*))/ni
d805 2
a806 1
      Token = Struct.new("Token", :symbol, :value)
d808 198
a1005 2
      def initialize
	@@token = Token.new(nil, nil)
d1008 306
a1313 7
      def parse_response
	prefix = parse_prefix
	case prefix
	when "+"
	  data = parse_resp_text
	when "*"
	  data = parse_response_data
d1315 2
a1316 1
	  data = parse_response_cond
a1317 3
	match_token(T_CRLF)
	match_token(T_EOF)
	return Response.new(prefix, data, @@str)
d1320 5
a1324 3
      def parse_prefix
	token = match_token(T_STAR, T_ATOM)
	return token.value
d1327 4
a1330 2
      def parse_resp_text
	val = []
d1332 52
a1383 3
	token = get_token
	if token.symbol == T_LBRA
	  val.push(parse_resp_text_code)
d1385 1
a1385 3
	val.push(parse_text)
	@@lex_state = EXPR_DATA
	return val
d1388 22
a1409 23
      def parse_resp_text_code
	val = []
	@@lex_state = EXPR_CODE
	match_token(T_LBRA)
	token = match_token(T_ATOM)
	val.push(token.value)
	case token.value
	when /\A(ALERT|PARSE|READ-ONLY|READ-WRITE|TRYCREATE)\z/n
	  # do nothing
	when /\A(PERMANENTFLAGS)\z/n
	  token = get_token
	  if token.symbol != T_LPAREN
	    parse_error('unexpected token %s (expected "(")',
			token.symbol.id2name)
	  end
	  val.push(parse_parenthesized_list)
	when /\A(UIDVALIDITY|UIDNEXT|UNSEEN)\z/n
	  token = match_token(T_NUMBER)
	  val.push(token.value)
	else
	  @@lex_state = EXPR_CODE_TEXT
	  val.push(parse_text)
	  @@lex_state = EXPR_CODE
d1411 2
a1412 3
	match_token(T_RBRA)
	@@lex_state = EXPR_TEXT
	return val
d1415 16
a1430 3
      def parse_text
	token = match_token(T_TEXT)
	return token.value
d1433 5
a1437 5
      def parse_response_data
	token = get_token
	if token.symbol == T_ATOM &&
	    /\A(OK|NO|BAD|PREAUTH|BYE)\z/n =~ token.value
	  return parse_response_cond
d1439 1
a1439 1
	  return parse_data_list
d1441 23
d1466 21
a1486 6
      def parse_response_cond
	val = []
	token = match_token(T_ATOM)
	val.push(token.value)
	val += parse_resp_text
	return val
d1489 16
a1504 2
      def parse_data_list
	val = []
d1506 1
a1506 1
	  token = get_token
d1508 19
a1526 6
	  when T_EOF
	    parse_error('unexpected token %s', token.symbol.id2name)
	  when T_CRLF, T_RPAREN
	    return val
	  when T_LPAREN
	    val.push(parse_parenthesized_list)
d1528 1
a1528 2
	    val.push(token.value)
	    @@token.symbol = nil
d1530 21
d1554 49
a1602 5
      def parse_parenthesized_list
	match_token(T_LPAREN)
	val = parse_data_list
	match_token(T_RPAREN)
	return val
d1605 2
a1606 2
      def match_token(*args)
	token = get_token
d1612 1
a1612 1
	@@token.symbol = nil
d1616 3
a1618 3
      def get_token
	unless @@token.symbol
	  next_token
d1623 4
d1629 2
a1630 2
	when EXPR_DATA
	  if @@str.index(DATA_REGEXP, @@pos)
d1633 1
a1633 2
	      @@token.value = nil
	      @@token.symbol = T_NIL
d1635 1
a1635 2
	      @@token.value = $+.to_i
	      @@token.symbol = T_NUMBER
d1637 1
a1637 2
	      @@token.value = $+
	      @@token.symbol = T_ATTR
d1639 1
a1639 2
	      @@token.value = $+
	      @@token.symbol = T_ATOM
d1641 2
a1642 2
	      @@token.value = $+.gsub(/\\(["\\])/n, "\\1")
	      @@token.symbol = T_QUOTED
d1644 1
a1644 4
	      len = $+.to_i
	      @@token.value = @@str[@@pos, len]
	      @@pos += len
	      @@token.symbol = T_LITERAL
d1646 1
a1646 2
	      @@token.value = $+[1..-1].intern
	      @@token.symbol = T_FLAG
d1648 1
a1648 2
	      @@token.value = nil
	      @@token.symbol = T_LPAREN
d1650 1
a1650 2
	      @@token.value = nil
	      @@token.symbol = T_RPAREN
d1652 1
a1652 2
	      @@token.value = $+
	      @@token.symbol = T_STAR
d1654 1
a1654 2
	      @@token.value = nil
	      @@token.symbol = T_CRLF
d1656 12
a1667 2
	      @@token.value = nil
	      @@token.symbol = T_EOF
d1669 1
a1669 1
	      parse_error("[BUG] DATA_REGEXP is invalid")
d1671 3
a1673 1
	    return
d1679 1
a1679 5
	      @@token.value = nil
	      @@token.symbol = T_LBRA
	    elsif $2
	      @@token.value = $+
	      @@token.symbol = T_TEXT
d1681 1
a1681 1
	      parse_error("[BUG] TEXT_REGEXP is invalid")
d1683 3
a1685 1
	    return
d1687 2
a1688 2
	when EXPR_CODE
	  if @@str.index(CODE_REGEXP, @@pos)
d1691 1
a1691 2
	      @@token.value = $+.to_i
	      @@token.symbol = T_NUMBER
d1693 1
a1693 17
	      @@token.value = $+
	      @@token.symbol = T_ATOM
	    elsif $3
	      @@token.value = $+[1..-1].capitalize.intern
	      @@token.symbol = T_FLAG
	    elsif $4
	      @@token.value = nil
	      @@token.symbol = T_LPAREN
	    elsif $5
	      @@token.value = nil
	      @@token.symbol = T_RPAREN
	    elsif $6
	      @@token.value = nil
	      @@token.symbol = T_LBRA
	    elsif $7
	      @@token.value = nil
	      @@token.symbol = T_RBRA
d1695 1
a1695 1
	      parse_error("[BUG] CODE_REGEXP is invalid")
d1697 3
a1699 1
	    return
d1701 2
a1702 2
	when EXPR_CODE_TEXT
	  if @@str.index(CODE_TEXT_REGEXP, @@pos)
d1705 1
a1705 2
	      @@token.value = $+
	      @@token.symbol = T_TEXT
d1707 1
a1707 1
	      parse_error("[BUG] CODE_TEXT_REGEXP is invalid")
d1709 3
a1711 1
	    return
a1715 2
	@@str.index(/\S*/n, @@pos)
	parse_error("unknown token - %s", $&.dump)
d1722 1
a1722 1
	  $stderr.printf("@@lex_state: %s\n", @@lex_state.inspect)
d1724 1
a1724 1
	    $stderr.printf("@@token.symbol: %s\n", @@token.symbol.id2name)
@


1.6
log
@shugo
* lib/net/imap.rb: changed return value of Net::IMAP#fetch.
* lib/net/imap.rb: support HEADER.FIELDS.
@
text
@a317 1
	flags.collect! {|i| Flag.new(i)}
@


1.5
log
@shugo
* lib/net/imap.rb: don't upcase the value of ATOM token.
@
text
@d160 2
d171 12
a182 2
        p imap.fetch(6..-1, "UID")
        #=> [[6, {"UID"=>28}], [7, {"UID"=>29}], [8, {"UID"=>30}]]
d192 2
a193 2
        p imap.store(6..-1, "+FLAGS", [:Deleted])
        #=> [[6, {"FLAGS"=>[:Deleted]}], [7, {"FLAGS"=>[:Seen, :Deleted]}], [8, {"FLAGS"=>[:Seen, :Deleted]}]]
d551 5
a555 1
      normalize_searching_criteria(keys)
d565 3
d569 1
a569 1
      return get_fetch_response
d573 3
d577 1
a577 1
      return get_fetch_response
d585 5
d606 10
a615 5
    def get_fetch_response
      return @@responses.delete("FETCH").collect { |i|
	i[1] = Hash[*i[1]]
	i
      }
d747 1
d764 10
a773 9
(?# 3:	ATOM	)([^(){ \x00-\x1f\x7f%*"\\]+)|\
(?# 4:	QUOTED	)"((?:[^"\\]|\\["\\])*)"|\
(?# 5:	LITERAL	)\{(\d+)\}\r\n|\
(?# 6:	FLAG	)(\\(?:[^(){ \x00-\x1f\x7f%*"\\]+|\*))|\
(?# 7:	LPAREN	)(\()|\
(?# 8:	RPAREN	)(\))|\
(?# 9:	STAR	)(\*)|\
(?# 10:	CRLF	)(\r\n)|\
(?# 11:	EOF	)(\z))/ni
d937 3
d941 1
a941 1
	    elsif $4
d944 1
a944 1
	    elsif $5
d949 1
a949 1
	    elsif $6
d952 1
a952 1
	    elsif $7
d955 1
a955 1
	    elsif $8
d958 1
a958 1
	    elsif $9
d961 1
a961 1
	    elsif $10
d964 1
a964 1
	    elsif $11
@


1.4
log
@shugo
@
text
@d384 1
a384 1
      if @@greeting.name == "BYE"
d426 1
a426 1
	  when "NO"
d428 1
a428 1
	  when "BAD"
d435 1
a435 1
	    if resp.name == "BYE" &&
d440 1
a440 1
	    if /\A(OK|NO|BAD)\z/n =~ resp.name &&
d471 1
d902 1
a902 1
	      @@token.value = $+.upcase
d956 1
a956 1
	      @@token.value = $+.upcase
@


1.3
log
@shugo
@
text
@d912 1
a912 1
	      @@token.value = $+[1..-1].capitalize.intern
@


1.2
log
@*** empty log message ***
@
text
@d415 1
a415 1
        $stderr.print(line.gsub(/^/, "C: "))
d440 1
a440 1
	    if /\A(OK|NO|BAD)\z/ =~ resp.name &&
d456 1
a456 1
	if /\{(\d+)\}\r\n/ =~ s
d465 1
a465 1
        $stderr.print(buff.gsub(/^/, "S: "))
d500 1
a500 1
      when /[\r\n]/
d503 1
a503 1
      when /[(){ \x00-\x1f\x7f%*"\\]/
d505 1
a505 1
	return '"' + str.gsub(/["\\]/, "\\\\\\&") + '"'
d599 1
a599 1
	return '"' + @@data.gsub(/["\\]/, "\\\\\\&") + '"'
d738 1
a738 1
(?# 11:	EOF	)(\z))/i
d747 1
a747 1
(?# 7:	RBRA	)(\]))/i
d750 1
a750 1
(?# 1:	TEXT	)([^\r\n\]]*))/i
d754 1
a754 1
(?# 2:	TEXT	)([^\r\n]*))/i
d801 1
a801 1
	when /\A(ALERT|PARSE|READ-ONLY|READ-WRITE|TRYCREATE)\z/
d803 1
a803 1
	when /\A(PERMANENTFLAGS)\z/
d810 1
a810 1
	when /\A(UIDVALIDITY|UIDNEXT|UNSEEN)\z/
d831 1
a831 1
	    /\A(OK|NO|BAD|PREAUTH|BYE)\z/ =~ token.value
d904 1
a904 1
	      @@token.value = $+.gsub(/\\(["\\])/, "\\1")
d991 1
a991 1
	@@str.index(/\S*/, @@pos)
d996 1
a996 1
	if @@@@debug
d999 1
@


1.1
log
@lib/net/imap.rb
@
text
@d30 3
d217 4
d240 1
a240 1
      unless AUTHENTICATORS.has_key?(auth_type)
d244 1
a244 1
      authenticator = AUTHENTICATORS[auth_type].new(*args)
d373 1
d1030 1
d1069 1
a1069 5

    AUTHENTICATORS = {
      "LOGIN"		=> LoginAuthenticator,
      "CRAM-MD5"	=> CramMD5Authenticator
    }
@

