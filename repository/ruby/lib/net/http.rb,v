head	1.73;
access;
symbols
	v1_6_7:1.41.2.18
	v1_6_6:1.41.2.14
	v1_6_5:1.41.2.11
	v1_6_4:1.41.2.7
	v1_7_1:1.53
	v1_6_4_preview4:1.41.2.7
	v1_6_4_preview3:1.41.2.7
	v1_6_4_preview2:1.41.2.7
	v1_6_4_preview1:1.41.2.7
	v1_6_3:1.41.2.7
	ruby_m17n:1.41.0.4
	ruby_1_6:1.41.0.2
	v1_6_2:1.41
	v1_6_1:1.32
	v1_6_0:1.27
	v1_4_6:1.5.2.19
	v1_4_5:1.5.2.17
	v1_4_4:1.5.2.2
	ruby_1_4:1.5.0.2
	V1-1-3:1.4
	V1-1-1:1.2;
locks; strict;
comment	@# @;


1.73
date	2002.10.17.07.27.00;	author matz;	state Exp;
branches;
next	1.72;

1.72
date	2002.07.11.21.33.38;	author aamine;	state Exp;
branches;
next	1.71;

1.71
date	2002.03.26.11.18.02;	author aamine;	state Exp;
branches;
next	1.70;

1.70
date	2002.02.22.12.54.11;	author aamine;	state Exp;
branches;
next	1.69;

1.69
date	2002.02.22.12.10.58;	author aamine;	state Exp;
branches;
next	1.68;

1.68
date	2002.02.19.12.33.52;	author aamine;	state Exp;
branches;
next	1.67;

1.67
date	2002.02.07.20.22.39;	author aamine;	state Exp;
branches;
next	1.66;

1.66
date	2001.12.30.19.18.45;	author aamine;	state Exp;
branches;
next	1.65;

1.65
date	2001.12.20.05.00.20;	author aamine;	state Exp;
branches;
next	1.64;

1.64
date	2001.12.13.19.15.21;	author aamine;	state Exp;
branches;
next	1.63;

1.63
date	2001.12.09.08.58.30;	author aamine;	state Exp;
branches;
next	1.62;

1.62
date	2001.12.07.10.04.25;	author aamine;	state Exp;
branches;
next	1.61;

1.61
date	2001.08.17.03.08.45;	author aamine;	state Exp;
branches;
next	1.60;

1.60
date	2001.07.13.21.16.11;	author aamine;	state Exp;
branches;
next	1.59;

1.59
date	2001.07.08.07.00.23;	author aamine;	state Exp;
branches;
next	1.58;

1.58
date	2001.07.03.19.18.17;	author aamine;	state Exp;
branches;
next	1.57;

1.57
date	2001.07.03.19.03.16;	author aamine;	state Exp;
branches;
next	1.56;

1.56
date	2001.07.03.18.13.13;	author aamine;	state Exp;
branches;
next	1.55;

1.55
date	2001.06.27.00.59.08;	author aamine;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.26.23.49.21;	author aamine;	state Exp;
branches;
next	1.53;

1.53
date	2001.03.13.05.48.58;	author aamine;	state Exp;
branches;
next	1.52;

1.52
date	2001.03.08.08.39.40;	author aamine;	state Exp;
branches;
next	1.51;

1.51
date	2001.02.24.04.53.50;	author aamine;	state Exp;
branches;
next	1.50;

1.50
date	2001.02.22.23.23.57;	author aamine;	state Exp;
branches;
next	1.49;

1.49
date	2001.02.17.20.40.50;	author aamine;	state Exp;
branches;
next	1.48;

1.48
date	2001.02.07.17.17.51;	author aamine;	state Exp;
branches;
next	1.47;

1.47
date	2001.02.07.07.23.09;	author aamine;	state Exp;
branches;
next	1.46;

1.46
date	2001.02.06.13.04.08;	author aamine;	state Exp;
branches;
next	1.45;

1.45
date	2001.02.06.12.26.25;	author aamine;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.06.11.14.51;	author aamine;	state Exp;
branches;
next	1.43;

1.43
date	2001.01.16.07.57.43;	author aamine;	state Exp;
branches;
next	1.42;

1.42
date	2001.01.13.19.07.15;	author aamine;	state Exp;
branches;
next	1.41;

1.41
date	2000.12.24.20.01.43;	author aamine;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2000.12.24.19.39.15;	author aamine;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.22.18.40.55;	author aamine;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.16.14.03.20;	author aamine;	state Exp;
branches;
next	1.37;

1.37
date	2000.11.10.23.31.32;	author aamine;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.07.11.27.16;	author aamine;	state Exp;
branches;
next	1.35;

1.35
date	2000.10.15.21.37.30;	author aamine;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.12.09.54.32;	author aamine;	state Exp;
branches;
next	1.33;

1.33
date	2000.10.11.05.27.56;	author aamine;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.23.18.00.28;	author aamine;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.22.06.44.59;	author aamine;	state Exp;
branches;
next	1.30;

1.30
date	2000.09.21.06.58.01;	author aamine;	state Exp;
branches;
next	1.29;

1.29
date	2000.09.21.06.37.24;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2000.09.12.05.37.35;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.16.19.26.07;	author aamine;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.12.06.04.40;	author aamine;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.03.09.20.35;	author aamine;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.27.13.36.17;	author aamine;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.12.16.42.46;	author aamine;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.12.15.45.58;	author aamine;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.09.07.53.59;	author aamine;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.01.13.43.43;	author aamine;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.22.13.39.24;	author aamine;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.18.08.57.37;	author aamine;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.05.08.53.06;	author aamine;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.22.07.29.53;	author aamine;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.18.09.39.02;	author aamine;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.14.10.41.35;	author aamine;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.31.13.02.40;	author aamine;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.27.15.52.27;	author aamine;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.26.16.29.02;	author aamine;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.26.08.48.15;	author aamine;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.08.10.40.11;	author aamine;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.05.10.25.53;	author aamine;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.21.15.25.37;	author aamine;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.21.12.52.24;	author aamine;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.05.07.55.36;	author aamine;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.12.29.11.14.04;	author aamine;	state Exp;
branches;
next	1.3;

1.3
date	99.12.22.13.49.12;	author aamine;	state Exp;
branches;
next	1.2;

1.2
date	99.12.20.20.48.49;	author aamine;	state Exp;
branches;
next	1.1;

1.1
date	99.12.17.15.00.13;	author aamine;	state Exp;
branches;
next	;

1.5.2.1
date	2000.01.16.08.15.50;	author aamine;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2000.01.21.12.53.38;	author aamine;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2000.03.15.13.30.27;	author aamine;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2000.03.23.21.56.16;	author aamine;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2000.03.26.16.35.03;	author aamine;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2000.03.27.15.52.56;	author aamine;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2000.03.31.13.03.16;	author aamine;	state Exp;
branches;
next	1.5.2.8;

1.5.2.8
date	2000.04.14.10.42.57;	author aamine;	state Exp;
branches;
next	1.5.2.9;

1.5.2.9
date	2000.04.18.09.39.40;	author aamine;	state Exp;
branches;
next	1.5.2.10;

1.5.2.10
date	2000.04.22.07.30.29;	author aamine;	state Exp;
branches;
next	1.5.2.11;

1.5.2.11
date	2000.05.05.08.53.37;	author aamine;	state Exp;
branches;
next	1.5.2.12;

1.5.2.12
date	2000.05.18.08.56.58;	author aamine;	state Exp;
branches;
next	1.5.2.13;

1.5.2.13
date	2000.05.22.13.39.01;	author aamine;	state Exp;
branches;
next	1.5.2.14;

1.5.2.14
date	2000.06.01.13.41.35;	author aamine;	state Exp;
branches;
next	1.5.2.15;

1.5.2.15
date	2000.06.09.07.52.24;	author aamine;	state Exp;
branches;
next	1.5.2.16;

1.5.2.16
date	2000.06.12.15.45.21;	author aamine;	state Exp;
branches;
next	1.5.2.17;

1.5.2.17
date	2000.06.12.16.42.24;	author aamine;	state Exp;
branches;
next	1.5.2.18;

1.5.2.18
date	2000.06.27.13.35.45;	author aamine;	state Exp;
branches;
next	1.5.2.19;

1.5.2.19
date	2000.07.03.09.19.45;	author aamine;	state Exp;
branches;
next	;

1.41.2.1
date	2001.02.06.11.57.09;	author aamine;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2001.02.13.07.55.16;	author aamine;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2001.02.22.23.19.50;	author aamine;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2001.02.23.04.22.04;	author aamine;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2001.02.23.07.31.07;	author aamine;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	2001.02.24.06.38.35;	author aamine;	state Exp;
branches;
next	1.41.2.7;

1.41.2.7
date	2001.03.13.05.55.31;	author aamine;	state Exp;
branches;
next	1.41.2.8;

1.41.2.8
date	2001.06.26.23.49.02;	author aamine;	state Exp;
branches;
next	1.41.2.9;

1.41.2.9
date	2001.06.27.00.59.52;	author aamine;	state Exp;
branches;
next	1.41.2.10;

1.41.2.10
date	2001.07.08.07.01.22;	author aamine;	state Exp;
branches;
next	1.41.2.11;

1.41.2.11
date	2001.07.13.21.20.41;	author aamine;	state Exp;
branches;
next	1.41.2.12;

1.41.2.12
date	2001.12.07.09.40.16;	author aamine;	state Exp;
branches;
next	1.41.2.13;

1.41.2.13
date	2001.12.07.10.12.52;	author aamine;	state Exp;
branches;
next	1.41.2.14;

1.41.2.14
date	2001.12.09.08.58.06;	author aamine;	state Exp;
branches;
next	1.41.2.15;

1.41.2.15
date	2002.01.15.03.34.59;	author aamine;	state Exp;
branches;
next	1.41.2.16;

1.41.2.16
date	2002.02.07.20.29.58;	author aamine;	state Exp;
branches;
next	1.41.2.17;

1.41.2.17
date	2002.02.19.13.40.23;	author aamine;	state Exp;
branches;
next	1.41.2.18;

1.41.2.18
date	2002.02.22.12.50.23;	author aamine;	state Exp;
branches;
next	;


desc
@@


1.73
log
@* object.c (rb_str_to_dbl): RString ptr might be NULL.

* object.c (rb_cstr_to_dbl): p pointer might be NULL.

* bignum.c (rb_str_to_inum): RString ptr might be NULL.

* bignum.c (rb_cstr_to_inum): str pointer might be NULL.
@
text
@=begin

= net/http.rb

Copyright (c) 1999-2002 Yukihiro Matsumoto

written & maintained by Minero Aoki <aamine@@loveruby.net>
This file is derived from "http-access.rb".

This program is free software. You can re-distribute and/or
modify this program under the same terms as Ruby itself,
Ruby Distribute License or GNU General Public License.

NOTE: You can find Japanese version of this document in
the doc/net directory of the standard ruby interpreter package.

$Id: http.rb,v 1.72 2002/07/11 21:33:38 aamine Exp $

== What is this module?

This module provide your program the functions to access WWW
documents via HTTP, Hyper Text Transfer Protocol version 1.1.
For details of HTTP, refer [RFC2616]
((<URL:http://www.ietf.org/rfc/rfc2616.txt>)).

== Examples

=== Getting Document From Server

    require 'net/http'
    Net::HTTP.start( 'some.www.server', 80 ) {|http|
        response = http.get('/index.html')
        puts response.body
    }

(shorter version)

    require 'net/http'
    Net::HTTP.get_print 'some.www.server', '/index.html'
    # or
    Net::HTTP.get_print URI.parse('http://www.example.com/index.html')

=== Posting Form Data

    require 'net/http'
    Net::HTTP.start( 'some.www.server', 80 ) {|http|
        response = http.post('/cgi-bin/any.rhtml',
                             'querytype=subject&target=ruby')
    }

=== Accessing via Proxy

Net::HTTP.Proxy() creates http proxy class. It has same
methods of Net::HTTP but its instances always connect to
proxy, instead of given host.

    require 'net/http'

    $proxy_addr = 'your.proxy.addr'
    $proxy_port = 8080
            :
    Net::HTTP::Proxy($proxy_addr, $proxy_port).start('some.www.server') {|http|
        # always connect to your.proxy.addr:8080
            :
    }

Since Net::HTTP.Proxy() returns Net::HTTP itself when $proxy_addr is nil,
there's no need to change code if there's proxy or not.

=== Following Redirection

    require 'net/http'

    def read_uri( uri_str )
      response = Net::HTTP.get_response(URI.parse(uri_str))
      case response
      when Net::HTTPSuccess     then response
      when Net::HTTPRedirection then read_uri(response['location'])
      else
        response.error!
      end
    end

    print read_uri('http://www.ruby-lang.org')

Net::HTTPSuccess and Net::HTTPRedirection is a HTTPResponse class.
All HTTPResponse objects belong to its own response class which
indicate HTTP result status. For details of response classes,
see section "HTTP Response Classes".

=== Basic Authentication

    require 'net/http'

    req = Net::HTTP::Get.new('/need-auth.cgi')
    req.basic_auth 'account', 'password'
    Net::HTTP.start( 'auth.some.domain' ) {|http|
        response = http.request(req)
        print response.body
    }

=== HTTP Response Classes

Followings are sub classes of Net::HTTPResponse. All classes are
defined under the Net module. Indentation indicates inheritance.

  xxx        HTTPResponse

    1xx        HTTPInformation
      100        HTTPContinue    
      101        HTTPSwitchProtocol

    2xx        HTTPSuccess
      200        HTTPOK
      201        HTTPCreated
      202        HTTPAccepted
      203        HTTPNonAuthoritativeInformation
      204        HTTPNoContent
      205        HTTPResetContent
      206        HTTPPartialContent

    3xx        HTTPRedirection
      300        HTTPMultipleChoice
      301        HTTPMovedPermanently
      302        HTTPFound
      303        HTTPSeeOther
      304        HTTPNotModified
      305        HTTPUseProxy
      307        HTTPTemporaryRedirect

    4xx        HTTPClientError
      400        HTTPBadRequest
      401        HTTPUnauthorized
      402        HTTPPaymentRequired
      403        HTTPForbidden
      404        HTTPNotFound
      405        HTTPMethodNotAllowed
      406        HTTPNotAcceptable
      407        HTTPProxyAuthenticationRequired
      408        HTTPRequestTimeOut
      409        HTTPConflict
      410        HTTPGone
      411        HTTPLengthRequired
      412        HTTPPreconditionFailed
      413        HTTPRequestEntityTooLarge
      414        HTTPRequestURITooLong
      415        HTTPUnsupportedMediaType
      416        HTTPRequestedRangeNotSatisfiable
      417        HTTPExpectationFailed

    5xx        HTTPServerError
      500        HTTPInternalServerError
      501        HTTPNotImplemented
      502        HTTPBadGateway
      503        HTTPServiceUnavailable
      504        HTTPGatewayTimeOut
      505        HTTPVersionNotSupported

    xxx        HTTPUnknownResponse

== Switching Net::HTTP versions

You can use net/http.rb 1.1 features (bundled with Ruby 1.6)
by calling HTTP.version_1_1. Calling Net::HTTP.version_1_2
allows you to use 1.2 features again.

    # example
    Net::HTTP.start {|http1| ...(http1 has 1.2 features)... }

    Net::HTTP.version_1_1
    Net::HTTP.start {|http2| ...(http2 has 1.1 features)... }

    Net::HTTP.version_1_2
    Net::HTTP.start {|http3| ...(http3 has 1.2 features)... }

This function is not thread-safe.

== class Net::HTTP

=== Class Methods

: new( address, port = 80, proxy_addr = nil, proxy_port = nil )
    creates a new Net::HTTP object.
    If proxy_addr is given, creates an Net::HTTP object with proxy support.

: start( address, port = 80, proxy_addr = nil, proxy_port = nil )
    creates a new Net::HTTP object and returns it
    with opening HTTP session. 

: start( address, port = 80, proxy_addr = nil, proxy_port = nil ) {|http| .... }
    creates a new Net::HTTP object and gives it to the block.
    HTTP session is kept to open while the block is exected.

    This method returns the return value of the block.

: get_print( uri )
: get_print( address, path, port = 80 )
    gets entity body from the target and output it to stdout.

        Net::HTTP.get_print URI.parse('http://www.example.com')

: get( uri )
: get( address, path, port = 80 )
    send GET request to the target and get a response.
    This method returns a String.

        print Net::HTTP.get(URI.parse('http://www.example.com'))

: get_response( uri )
: get_response( address, path, port = 80 )
    send GET request to the target and get a response.
    This method returns a Net::HTTPResponse object.

        res = Net::HTTP.get_response(URI.parse('http://www.example.com'))
        print res.body

: Proxy( address, port = 80 )
    creates a HTTP proxy class.
    Arguments are address/port of proxy host.
    You can replace HTTP class with created proxy class.

    If ADDRESS is nil, this method returns self (Net::HTTP).

        # example
        proxy_class = Net::HTTP::Proxy( 'proxy.foo.org', 8080 )
                        :
        proxy_class.start( 'www.ruby-lang.org' ) {|http|
            # connecting proxy.foo.org:8080
                        :
        }

: proxy_class?
    If self is HTTP, false.
    If self is a class which was created by HTTP::Proxy(), true.

: port
    default HTTP port (80).

=== Instance Methods

: start
: start {|http| .... }
    opens HTTP session.

    When this method is called with block, gives a HTTP object
    to the block and closes the HTTP session after block call finished.

: started?
    returns true if HTTP session is started.

: address
    the address to connect

: port
    the port number to connect

: open_timeout
: open_timeout=(n)
    seconds to wait until connection is opened.
    If HTTP object cannot open a conection in this seconds,
    it raises TimeoutError exception.

: read_timeout
: read_timeout=(n)
    seconds to wait until reading one block (by one read(1) call).
    If HTTP object cannot open a conection in this seconds,
    it raises TimeoutError exception.

: finish
    finishes HTTP session.
    If HTTP session had not started, raises an IOError.

: proxy?
    true if self is a HTTP proxy class

: proxy_address
    address of proxy host. If self does not use a proxy, nil.

: proxy_port
    port number of proxy host. If self does not use a proxy, nil.

: get( path, header = nil )
: get( path, header = nil ) {|str| .... }
    gets data from PATH on the connecting host.
    HEADER must be a Hash like { 'Accept' => '*/*', ... }.

    In version 1.1, this method returns a pair of objects,
    a Net::HTTPResponse object and entity body string.
    In version 1.2, this method returns a Net::HTTPResponse
    object.

    If called with block, gives entity body string to the block
    little by little.

    In version 1.1, this method might raises exception for also
    3xx (redirect). On the case you can get a HTTPResponse object
    by "anException.response".
    In version 1.2, this method never raises exception.

        # version 1.1 (bundled with Ruby 1.6)
        response, body = http.get( '/index.html' )

        # version 1.2 (bundled with Ruby 1.7 or later)
        response = http.get( '/index.html' )

        # compatible in both version
        response , = http.get( '/index.html' )
        response.body
        
        # using block
        File.open( 'save.txt', 'w' ) {|f|
            http.get( '/~foo/', nil ) do |str|
              f.write str
            end
        }

: head( path, header = nil )
    gets only header from PATH on the connecting host.
    HEADER is a Hash like { 'Accept' => '*/*', ... }.

    This method returns a Net::HTTPResponse object.

    In version 1.1, this method might raises exception for also
    3xx (redirect). On the case you can get a HTTPResponse object
    by "anException.response".
    In version 1.2, this method never raises exception.

        response = nil
        Net::HTTP.start( 'some.www.server', 80 ) {|http|
            response = http.head( '/index.html' )
        }
        p response['content-type']

: post( path, data, header = nil )
: post( path, data, header = nil ) {|str| .... }
    posts DATA (must be String) to PATH. HEADER must be a Hash
    like { 'Accept' => '*/*', ... }.

    In version 1.1, this method returns a pair of objects, a
    Net::HTTPResponse object and an entity body string.
    In version 1.2, this method returns a Net::HTTPReponse object.

    If called with block, gives a part of entity body string.

    In version 1.1, this method might raises exception for also
    3xx (redirect). On the case you can get a HTTPResponse object
    by "anException.response".
    In version 1.2, this method never raises exception.

        # version 1.1
        response, body = http.post( '/cgi-bin/search.rb', 'query=subject&target=ruby' )

        # version 1.2
        response = http.post( '/cgi-bin/search.rb', 'query=subject&target=ruby' )

        # compatible in both version
        response , = http.post( '/cgi-bin/search.rb', 'query=subject&target=ruby' )

        # using block
        File.open( 'save.html', 'w' ) {|f|
            http.post( '/cgi-bin/search.rb',
                       'query=subject&target=ruby' ) do |str|
              f.write str
            end
        }

: request_get( path, header = nil )
: request_get( path, header = nil ) {|response| .... }
    gets entity from PATH. This method returns a HTTPResponse object.

    When called with block, keep connection while block is executed
    and gives a HTTPResponse object to the block.

    This method never raises Net::* exceptions.

        # example
        response = http.request_get( '/index.html' )
        p response['content-type']
        puts response.body          # body is already read

        # using block
        http.request_get( '/index.html' ) {|response|
            p response['content-type']
            response.read_body do |str|   # read body now
              print str
            end
        }

: request_post( path, data, header = nil )
: request_post( path, data, header = nil ) {|response| .... }
    posts data to PATH. This method returns a HTTPResponse object.

    When called with block, gives a HTTPResponse object to the block
    before reading entity body, with keeping connection.

    This method never raises Net::* exceptions.

        # example
        response = http.post2( '/cgi-bin/nice.rb', 'datadatadata...' )
        p response.status
        puts response.body          # body is already read

        # using block
        http.post2( '/cgi-bin/nice.rb', 'datadatadata...' ) {|response|
            p response.status
            p response['content-type']
            response.read_body do |str|   # read body now
              print str
            end
        }

: request( request [, data] )
: request( request [, data] ) {|response| .... }
    sends a HTTPRequest object REQUEST to the HTTP server.
    This method also writes DATA string if REQUEST is a post/put request.
    Giving DATA for get/head request causes ArgumentError.

    If called with block, this method passes a HTTPResponse object to
    the block, without reading entity body.

    This method never raises Net::* exceptions.

== class Net::HTTPRequest

HTTP request class. This class wraps request header and entity path.
You MUST use its subclass, Net::HTTP::Get, Post, Head.

=== Class Methods

: new
    creats HTTP request object.

=== Instance Methods

: self[ key ]
    returns the header field corresponding to the case-insensitive key.
    For example, a key of "Content-Type" might return "text/html"

: self[ key ] = val
    sets the header field corresponding to the case-insensitive key.

: each {|name, val| .... }
    iterates for each field name and value pair.

: basic_auth( account, password )
    set Authorization: header for basic auth.

: range
    returns a Range object which represents Range: header field.

: range = r
: set_range( i, len )
    set Range: header from Range (arg r) or beginning index and
    length from it (arg i&len).

: content_length
    returns a Integer object which represents Content-Length: header field.

: content_range
    returns a Range object which represents Content-Range: header field.

== class Net::HTTPResponse

HTTP response class. This class wraps response header and entity.
All arguments named KEY is case-insensitive.

=== Instance Methods

: self[ key ]
    returns the header field corresponding to the case-insensitive key.
    For example, a key of "Content-Type" might return "text/html".
    A key of "Content-Length" might do "2045".

    More than one fields which has same names are joined with ','.

: self[ key ] = val
    sets the header field corresponding to the case-insensitive key.

: fetch( key [,default] )

    returns the header field corresponding to the case-insensitive key.
    returns the default value if there's no header field named key.

: key?( key )
    true if key exists.
    KEY is case insensitive.

: each {|name,value| .... }
    iterates for each field name and value pair.

: canonical_each {|name,value| .... }
    iterates for each "canonical" field name and value pair.

: code
    HTTP result code string. For example, '302'.

: message
    HTTP result message. For example, 'Not Found'.

: read_body( dest = '' )
    gets entity body and write it into DEST using "<<" method.
    If this method is called twice or more, nothing will be done
    and returns first DEST.

: read_body {|str| .... }
    gets entity body little by little and pass it to block.

: body
    response body. If #read_body has been called, this method returns
    arg of #read_body DEST. Else gets body as String and returns it.

=end

require 'net/protocol'
require 'uri'


module Net

  class HTTPBadResponse < StandardError; end
  class HTTPHeaderSyntaxError < StandardError; end


  class HTTP < Protocol

    HTTPVersion = '1.1'


    #
    # for backward compatibility
    #

    @@@@newimpl = true

    def HTTP.version_1_2
      @@@@newimpl = true
    end

    def HTTP.version_1_1
      @@@@newimpl = false
    end

    def HTTP.is_version_1_2?
      @@@@newimpl
    end

    def HTTP.setimplversion( obj )
      f = @@@@newimpl
      obj.instance_eval { @@newimpl = f }
    end
    private_class_method :setimplversion


    #
    # short cut methods
    #

    def HTTP.get_print( arg1, arg2 = nil, port = nil )
      if arg2
        addr, path = arg1, arg2
      else
        uri = arg1
        addr = uri.host
        path = uri.request_uri
        port = uri.port
      end
      new(addr, port || HTTP.default_port).start {|http|
          http.get path, nil, $stdout
      }
      nil
    end

    def HTTP.get( arg1, arg2 = nil, arg3 = nil )
      get_response(arg1,arg2,arg3).body
    end

    def HTTP.get_response( arg1, arg2 = nil, arg3 = nil )
      if arg2 then
        get_by_path(arg1, arg2, arg3)
      else
        get_by_uri(arg1)
      end
    end

    def HTTP.get_by_path( addr, path, port = nil )
      new( addr, port || HTTP.default_port ).start {|http|
          return http.request(Get.new(path))
      }
    end
    private_class_method :get_by_path

    def HTTP.get_by_uri( uri )
      # Should we allow this?
      # uri = URI.parse(uri) unless uri.respond_to?(:host)
      new(uri.host, uri.port).start {|http|
          return http.request(Get.new(uri.request_uri))
      }
    end
    private_class_method :get_by_uri


    #
    # connection
    #

    protocol_param :default_port, '80'
    protocol_param :socket_type,  '::Net::InternetMessageIO'

    class << HTTP
      def start( address, port = nil, p_addr = nil, p_port = nil, &block )
        new( address, port, p_addr, p_port ).start( &block )
      end

      alias newobj new

      def new( address, port = nil, p_addr = nil, p_port = nil )
        obj = Proxy(p_addr, p_port).newobj(address, port)
        setimplversion obj
        obj
      end
    end

    def initialize( addr, port = nil )
      super
      @@curr_http_version = HTTPVersion
      @@seems_1_0_server = false
      @@close_on_empty_response = false
    end

    attr_accessor :close_on_empty_response

    private

    def do_start
      conn_socket
    end

    def do_finish
      disconn_socket
    end


    #
    # proxy
    #

    public

    # no proxy
    @@is_proxy_class = false
    @@proxy_addr = nil
    @@proxy_port = nil

    def HTTP.Proxy( p_addr, p_port = nil )
      p_addr or return self

      p_port ||= port()
      delta = ProxyDelta
      proxyclass = Class.new(self)
      proxyclass.module_eval {
          include delta
          # with proxy
          @@is_proxy_class = true
          @@proxy_address = p_addr
          @@proxy_port    = p_port
      }
      proxyclass
    end

    class << HTTP
      def proxy_class?
        @@is_proxy_class
      end

      attr_reader :proxy_address
      attr_reader :proxy_port
    end

    def proxy?
      self.class.proxy_class?
    end

    def proxy_address
      self.class.proxy_address
    end

    def proxy_port
      self.class.proxy_port
    end

    alias proxyaddr proxy_address
    alias proxyport proxy_port

    private

    # no proxy

    def conn_address
      address
    end

    def conn_port
      port
    end

    def edit_path( path )
      path
    end

    module ProxyDelta
      private

      # with proxy
    
      def conn_address
        proxy_address
      end

      def conn_port
        proxy_port
      end

      def edit_path( path )
        'http://' + addr_port() + path
      end
    end


    #
    # http operations
    #

    public

    def get( path, initheader = nil, dest = nil, &block )
      res = nil
      request( Get.new(path,initheader) ) {|res|
          res.read_body dest, &block
      }
      unless @@newimpl then
        res.value
        return res, res.body
      end

      res
    end

    def head( path, initheader = nil )
      res = request( Head.new(path,initheader) )
      @@newimpl or res.value
      res
    end

    def post( path, data, initheader = nil, dest = nil, &block )
      res = nil
      request( Post.new(path,initheader), data ) {|res|
          res.read_body dest, &block
      }
      unless @@newimpl then
        res.value
        return res, res.body
      end

      res
    end

    def put( path, data, initheader = nil )
      res = request( Put.new(path,initheader), data )
      @@newimpl or res.value
      res
    end


    def request_get( path, initheader = nil, &block )
      request Get.new(path,initheader), &block
    end

    def request_head( path, initheader = nil, &block )
      request Head.new(path,initheader), &block
    end

    def request_post( path, data, initheader = nil, &block )
      request Post.new(path,initheader), data, &block
    end

    def request_put( path, data, initheader = nil, &block )
      request Put.new(path,initheader), data, &block
    end

    alias get2   request_get
    alias head2  request_head
    alias post2  request_post
    alias put2   request_put


    def send_request( name, path, body = nil, header = nil )
      r = HTTPGenericRequest.new( name, (body ? true : false), true,
                                  path, header )
      request r, body
    end


    def request( req, body = nil, &block )
      unless started? then
        start {
            req['connection'] = 'close'
            return request(req, body, &block)
        }
      end
        
      begin_transport req
          req.exec @@socket, @@curr_http_version, edit_path(req.path), body
          begin
            res = HTTPResponse.read_new(@@socket)
          end while HTTPContinue === res
          res.reading_body(@@socket, req.response_body_permitted?) {
              yield res if block_given?
          }
      end_transport req, res

      res
    end

    private

    def begin_transport( req )
      if @@socket.closed? then
        reconn_socket
      end
      if @@seems_1_0_server then
        req['connection'] = 'close'
      end
      if not req.response_body_permitted? and @@close_on_empty_response then
        req['connection'] = 'close'
      end
      req['host'] = addr_port()
    end

    def end_transport( req, res )
      @@curr_http_version = res.http_version

      if not res.body and @@close_on_empty_response then
        D 'Conn close'
        @@socket.close
      elsif keep_alive? req, res then
        D 'Conn keep-alive'
        if @@socket.closed? then
          D 'Conn (but seems 1.0 server)'
          @@seems_1_0_server = true
        end
      else
        D 'Conn close'
        @@socket.close
      end
    end

    def keep_alive?( req, res )
      /close/i === req['connection'].to_s            and return false
      @@seems_1_0_server                              and return false

      /keep-alive/i === res['connection'].to_s       and return true
      /close/i      === res['connection'].to_s       and return false
      /keep-alive/i === res['proxy-connection'].to_s and return true
      /close/i      === res['proxy-connection'].to_s and return false

      @@curr_http_version == '1.1'                    and return true
      false
    end


    #
    # utils
    #

    private

    def addr_port
      address + (port == HTTP.default_port ? '' : ":#{port}")
    end

    def D( msg )
      if @@debug_output then
        @@debug_output << msg
        @@debug_output << "\n"
      end
    end

  end

  HTTPSession = HTTP


  ###
  ### header
  ###

  module HTTPHeader

    def size
      @@header.size
    end

    alias length size

    def []( key )
      @@header[ key.downcase ]
    end

    def []=( key, val )
      @@header[ key.downcase ] = val
    end

    def each_header( &block )
      @@header.each( &block )
    end

    alias each each_header

    def each_key( &block )
      @@header.each_key( &block )
    end

    def each_value( &block )
      @@header.each_value( &block )
    end

    def delete( key )
      @@header.delete key.downcase
    end

    def fetch(*args)
      @@header.fetch(*args)
    end

    def key?( key )
      @@header.key? key.downcase
    end

    def to_hash
      @@header.dup
    end

    def canonical_each
      @@header.each do |k,v|
        yield canonical(k), v
      end
    end

    def canonical( k )
      k.split('-').collect {|i| i.capitalize }.join('-')
    end

    def range
      s = @@header['range'] or return nil
      s.split(',').collect {|spec|
          m = /bytes\s*=\s*(\d+)?\s*-\s*(\d+)?/i.match(spec) or
                  raise HTTPHeaderSyntaxError, "wrong Range: #{spec}"
          d1 = m[1].to_i
          d2 = m[2].to_i
          if    m[1] and m[2] then  d1..d2
          elsif m[1]          then  d1..-1
          elsif          m[2] then -d2..-1
          else
            raise HTTPHeaderSyntaxError, 'range is not specified'
          end
      }
    end

    def range=( r, fin = nil )
      r = (r ... r + fin) if fin

      case r
      when Numeric
        s = r > 0 ? "0-#{r - 1}" : "-#{-r}"
      when Range
        first = r.first
        last = r.last
        if r.exclude_end? then
          last -= 1
        end

        if last == -1 then
          s = first > 0 ? "#{first}-" : "-#{-first}"
        else
          first >= 0 or raise HTTPHeaderSyntaxError, 'range.first is negative' 
          last > 0  or raise HTTPHeaderSyntaxError, 'range.last is negative' 
          first < last or raise HTTPHeaderSyntaxError, 'must be .first < .last'
          s = "#{first}-#{last}"
        end
      else
        raise TypeError, 'Range/Integer is required'
      end

      @@header['range'] = "bytes=#{s}"
      r
    end

    alias set_range range=

    def content_length
      s = @@header['content-length'] or return nil
      m = /\d+/.match(s) or
              raise HTTPHeaderSyntaxError, 'wrong Content-Length format'
      m[0].to_i
    end

    def chunked?
      s = @@header['transfer-encoding']
      (s and /(?:\A|[^\-\w])chunked(?:[^\-\w]|\z)/i === s) ? true : false
    end

    def content_range
      s = @@header['content-range'] or return nil
      m = %r<bytes\s+(\d+)-(\d+)/(?:\d+|\*)>i.match(s) or
              raise HTTPHeaderSyntaxError, 'wrong Content-Range format'
      m[1].to_i .. m[2].to_i + 1
    end

    def range_length
      r = self.content_range
      r and r.length
    end

    def basic_auth( acc, pass )
      @@header['authorization'] = 'Basic ' + ["#{acc}:#{pass}"].pack('m').strip
    end

  end


  ###
  ### request
  ###

  class HTTPGenericRequest

    include HTTPHeader

    def initialize( m, reqbody, resbody, path, initheader = nil )
      @@method = m
      @@request_has_body = reqbody
      @@response_has_body = resbody
      @@path = path

      @@header = tmp = {}
      return unless initheader
      initheader.each do |k,v|
        key = k.downcase
        if tmp.key? key then
          $stderr.puts "WARNING: duplicated HTTP header: #{k}" if $VERBOSE
        end
        tmp[ key ] = v.strip
      end
      tmp['accept'] ||= '*/*'
    end

    attr_reader :method
    attr_reader :path

    def inspect
      "\#<#{self.class} #{@@method}>"
    end

    def request_body_permitted?
      @@request_has_body
    end

    def response_body_permitted?
      @@response_has_body
    end

    alias body_exist? response_body_permitted?

    #
    # write
    #

    # internal use only
    def exec( sock, ver, path, body )
      if body then
        check_body_premitted
        send_request_with_body sock, ver, path, body
      else
        request sock, ver, path
      end
    end

    private

    def check_body_premitted
      request_body_permitted? or
          raise ArgumentError, 'HTTP request body is not premitted'
    end

    def send_request_with_body( sock, ver, path, body )
      if block_given? then
        ac = Accumulator.new
        yield ac              # must be yield, DO NOT USE block.call
        data = ac.terminate
      else
        data = body
      end
      @@header['content-length'] = data.size.to_s
      @@header.delete 'transfer-encoding'

      unless @@header['content-type'] then
        $stderr.puts 'Content-Type did not set; using application/x-www-form-urlencoded' if $VERBOSE
        @@header['content-type'] = 'application/x-www-form-urlencoded'
      end

      request sock, ver, path
      sock.write data
    end

    def request( sock, ver, path )
      sock.writeline sprintf('%s %s HTTP/%s', @@method, path, ver)
      canonical_each do |k,v|
        sock.writeline k + ': ' + v
      end
      sock.writeline ''
    end
  
  end


  class HTTPRequest < HTTPGenericRequest

    def initialize( path, initheader = nil )
      super self.class::METHOD,
            self.class::REQUEST_HAS_BODY,
            self.class::RESPONSE_HAS_BODY,
            path, initheader
    end

  end


  class HTTP

    class Get < HTTPRequest
      METHOD = 'GET'
      REQUEST_HAS_BODY  = false
      RESPONSE_HAS_BODY = true
    end

    class Head < HTTPRequest
      METHOD = 'HEAD'
      REQUEST_HAS_BODY = false
      RESPONSE_HAS_BODY = false
    end

    class Post < HTTPRequest
      METHOD = 'POST'
      REQUEST_HAS_BODY = true
      RESPONSE_HAS_BODY = true
    end

    class Put < HTTPRequest
      METHOD = 'PUT'
      REQUEST_HAS_BODY = true
      RESPONSE_HAS_BODY = true
    end

  end



  ###
  ### response
  ###

  class HTTPResponse
    # predefine HTTPResponse class to allow inheritance

    def self.body_permitted?
      self::HAS_BODY
    end

    def self.exception_type
      self::EXCEPTION_TYPE
    end
  end


  class HTTPUnknownResponse < HTTPResponse
    HAS_BODY = true
    EXCEPTION_TYPE = ProtocolError
  end
  class HTTPInformation < HTTPResponse           # 1xx
    HAS_BODY = false
    EXCEPTION_TYPE = ProtocolError
  end
  class HTTPSuccess < HTTPResponse               # 2xx
    HAS_BODY = true
    EXCEPTION_TYPE = ProtocolError
  end
  class HTTPRedirection < HTTPResponse           # 3xx
    HAS_BODY = true
    EXCEPTION_TYPE = ProtoRetriableError
  end
  class HTTPClientError < HTTPResponse           # 4xx
    HAS_BODY = true
    EXCEPTION_TYPE = ProtoFatalError
  end
  class HTTPServerError < HTTPResponse           # 5xx
    HAS_BODY = true
    EXCEPTION_TYPE = ProtoServerError
  end

  class HTTPContinue < HTTPInformation           # 100
    HAS_BODY = false
  end
  class HTTPSwitchProtocol < HTTPInformation     # 101
    HAS_BODY = false
  end

  class HTTPOK < HTTPSuccess                            # 200
    HAS_BODY = true
  end
  class HTTPCreated < HTTPSuccess                       # 201
    HAS_BODY = true
  end
  class HTTPAccepted < HTTPSuccess                      # 202
    HAS_BODY = true
  end
  class HTTPNonAuthoritativeInformation < HTTPSuccess   # 203
    HAS_BODY = true
  end
  class HTTPNoContent < HTTPSuccess                     # 204
    HAS_BODY = false
  end
  class HTTPResetContent < HTTPSuccess                  # 205
    HAS_BODY = false
  end
  class HTTPPartialContent < HTTPSuccess                # 206
    HAS_BODY = true
  end

  class HTTPMultipleChoice < HTTPRedirection     # 300
    HAS_BODY = true
  end
  class HTTPMovedPermanently < HTTPRedirection   # 301
    HAS_BODY = true
  end
  class HTTPFound < HTTPRedirection              # 302
    HAS_BODY = true
  end
  HTTPMovedTemporarily = HTTPFound
  class HTTPSeeOther < HTTPRedirection           # 303
    HAS_BODY = true
  end
  class HTTPNotModified < HTTPRedirection        # 304
    HAS_BODY = false
  end
  class HTTPUseProxy < HTTPRedirection           # 305
    HAS_BODY = false
  end
  # 306 unused
  class HTTPTemporaryRedirect < HTTPRedirection  # 307
    HAS_BODY = true
  end

  class HTTPBadRequest < HTTPClientError                    # 400
    HAS_BODY = true
  end
  class HTTPUnauthorized < HTTPClientError                  # 401
    HAS_BODY = true
  end
  class HTTPPaymentRequired < HTTPClientError               # 402
    HAS_BODY = true
  end
  class HTTPForbidden < HTTPClientError                     # 403
    HAS_BODY = true
  end
  class HTTPNotFound < HTTPClientError                      # 404
    HAS_BODY = true
  end
  class HTTPMethodNotAllowed < HTTPClientError              # 405
    HAS_BODY = true
  end
  class HTTPNotAcceptable < HTTPClientError                 # 406
    HAS_BODY = true
  end
  class HTTPProxyAuthenticationRequired < HTTPClientError   # 407
    HAS_BODY = true
  end
  class HTTPRequestTimeOut < HTTPClientError                # 408
    HAS_BODY = true
  end
  class HTTPConflict < HTTPClientError                      # 409
    HAS_BODY = true
  end
  class HTTPGone < HTTPClientError                          # 410
    HAS_BODY = true
  end
  class HTTPLengthRequired < HTTPClientError                # 411
    HAS_BODY = true
  end
  class HTTPPreconditionFailed < HTTPClientError            # 412
    HAS_BODY = true
  end
  class HTTPRequestEntityTooLarge < HTTPClientError         # 413
    HAS_BODY = true
  end
  class HTTPRequestURITooLong < HTTPClientError             # 414
    HAS_BODY = true
  end
  HTTPRequestURITooLarge = HTTPRequestURITooLong
  class HTTPUnsupportedMediaType < HTTPClientError          # 415
    HAS_BODY = true
  end
  class HTTPRequestedRangeNotSatisfiable < HTTPClientError  # 416
    HAS_BODY = true
  end
  class HTTPExpectationFailed < HTTPClientError             # 417
    HAS_BODY = true
  end

  class HTTPInternalServerError < HTTPServerError   # 500
    HAS_BODY = true
  end
  class HTTPNotImplemented < HTTPServerError        # 501
    HAS_BODY = true
  end
  class HTTPBadGateway < HTTPServerError            # 502
    HAS_BODY = true
  end
  class HTTPServiceUnavailable < HTTPServerError    # 503
    HAS_BODY = true
  end
  class HTTPGatewayTimeOut < HTTPServerError        # 504
    HAS_BODY = true
  end
  class HTTPVersionNotSupported < HTTPServerError   # 505
    HAS_BODY = true
  end


  class HTTPResponse   # redefine

    CODE_CLASS_TO_OBJ = {
      '1' => HTTPInformation,
      '2' => HTTPSuccess,
      '3' => HTTPRedirection,
      '4' => HTTPClientError,
      '5' => HTTPServerError
    }
    CODE_TO_OBJ = {
      '100' => HTTPContinue,
      '101' => HTTPSwitchProtocol,

      '200' => HTTPOK,
      '201' => HTTPCreated,
      '202' => HTTPAccepted,
      '203' => HTTPNonAuthoritativeInformation,
      '204' => HTTPNoContent,
      '205' => HTTPResetContent,
      '206' => HTTPPartialContent,

      '300' => HTTPMultipleChoice,
      '301' => HTTPMovedPermanently,
      '302' => HTTPFound,
      '303' => HTTPSeeOther,
      '304' => HTTPNotModified,
      '305' => HTTPUseProxy,
      '307' => HTTPTemporaryRedirect,

      '400' => HTTPBadRequest,
      '401' => HTTPUnauthorized,
      '402' => HTTPPaymentRequired,
      '403' => HTTPForbidden,
      '404' => HTTPNotFound,
      '405' => HTTPMethodNotAllowed,
      '406' => HTTPNotAcceptable,
      '407' => HTTPProxyAuthenticationRequired,
      '408' => HTTPRequestTimeOut,
      '409' => HTTPConflict,
      '410' => HTTPGone,
      '411' => HTTPLengthRequired,
      '412' => HTTPPreconditionFailed,
      '413' => HTTPRequestEntityTooLarge,
      '414' => HTTPRequestURITooLong,
      '415' => HTTPUnsupportedMediaType,
      '416' => HTTPRequestedRangeNotSatisfiable,
      '417' => HTTPExpectationFailed,

      '501' => HTTPInternalServerError,
      '501' => HTTPNotImplemented,
      '502' => HTTPBadGateway,
      '503' => HTTPServiceUnavailable,
      '504' => HTTPGatewayTimeOut,
      '505' => HTTPVersionNotSupported
    }


    class << self

      def read_new( sock )
        httpv, code, msg = read_status_line(sock)
        res = response_class(code).new(httpv, code, msg)
        each_response_header(sock) do |k,v|
          if res.key? k then
            res[k] << ', ' << v
          else
            res[k] = v
          end
        end

        res
      end

      private

      def read_status_line( sock )
        str = sock.readline
        m = /\AHTTP(?:\/(\d+\.\d+))?\s+(\d\d\d)\s*(.*)\z/in.match(str) or
                raise HTTPBadResponse, "wrong status line: #{str.dump}"
        m.to_a[1,3]
      end

      def response_class( code )
        CODE_TO_OBJ[code] or
        CODE_CLASS_TO_OBJ[code[0,1]] or
        HTTPUnknownResponse
      end

      def each_response_header( sock )
        while true do
          line = sock.readuntil( "\n", true )   # ignore EOF
          line.sub!( /\s+\z/, '' )              # don't use chop!
          break if line.empty?

          m = /\A([^:]+):\s*/.match(line) or
                  raise HTTPBadResponse, 'wrong header line format'
          yield m[1], m.post_match
        end
      end

    end


    include HTTPHeader

    def initialize( httpv, code, msg )
      @@http_version = httpv
      @@code         = code
      @@message      = msg

      @@header = {}
      @@body = nil
      @@read = false
    end

    attr_reader :http_version
    attr_reader :code
    attr_reader :message
    alias msg message

    def inspect
      "#<#{self.class} #{@@code} readbody=#{@@read}>"
    end

    #
    # response <-> exception relationship
    #

    def code_type
      self.class
    end

    def error!
      raise error_type().new(@@code + ' ' + @@message.dump, self)
    end

    def error_type
      self.class::EXCEPTION_TYPE
    end

    def value
      HTTPSuccess === self or error!
    end

    #
    # header (for backward compatibility only; DO NOT USE)
    #

    def response
      self
    end

    alias header response
    alias read_header response

    #
    # body
    #

    # internal use only
    def reading_body( sock, reqmethodallowbody )
      @@socket = sock
      @@body_exist = reqmethodallowbody && self.class.body_permitted?
      yield
      self.body
      @@socket = nil
    end

    def read_body( dest = nil, &block )
      if @@read then
        (dest or block) and
                raise IOError, "#{self.class}\#read_body called twice"
        return @@body
      end

      to = procdest(dest, block)
      stream_check
      if @@body_exist then
        read_body_0 to
        @@body = to
      else
        @@body = nil
      end
      @@read = true

      @@body
    end

    alias body read_body
    alias entity read_body

    private

    def read_body_0( dest )
      if chunked? then
        read_chunked dest
      else
        clen = content_length
        if clen then
          @@socket.read clen, dest, true   # ignore EOF
        else
          clen = range_length
          if clen then
            @@socket.read clen, dest
          else
            @@socket.read_all dest
          end
        end
      end
    end

    def read_chunked( dest )
      len = nil
      total = 0

      while true do
        line = @@socket.readline
        m = /[0-9a-fA-F]+/.match(line)
        m or raise HTTPBadResponse, "wrong chunk size line: #{line}"
        len = m[0].hex
        break if len == 0
        @@socket.read len, dest; total += len
        @@socket.read 2   # \r\n
      end
      until @@socket.readline.empty? do
        # none
      end
    end

    def stream_check
      @@socket.closed? and raise IOError, 'try to read body out of block'
    end

    def procdest( dest, block )
      (dest and block) and
          raise ArgumentError, 'both of arg and block are given for HTTP method'
      if block then
        ReadAdapter.new(block)
      else
        dest || ''
      end
    end

  end



  # for backward compatibility

  module NetPrivate
    HTTPResponse         = ::Net::HTTPResponse
    HTTPGenericRequest   = ::Net::HTTPGenericRequest
    HTTPRequest          = ::Net::HTTPRequest
    HTTPHeader           = ::Net::HTTPHeader
  end
  HTTPInformationCode = HTTPInformation
  HTTPSuccessCode     = HTTPSuccess
  HTTPRedirectionCode = HTTPRedirection
  HTTPRetriableCode   = HTTPRedirection
  HTTPClientErrorCode = HTTPClientError
  HTTPFatalErrorCode  = HTTPClientError
  HTTPServerErrorCode = HTTPServerError
  HTTPResponceReceiver = HTTPResponse

end   # module Net
@


1.72
log
@* lib/net/http.rb: rename HTTP.get_uri get_response.
* lib/net/http.rb: HTTP.get_print accepts URI objects.
* lib/net/http.rb: HTTP.get did not work with URI.
@
text
@d17 1
a17 1
$Id: header.rd,v 1.3 2002/02/19 12:23:15 aamine Exp $
d479 5
d929 4
@


1.71
log
@* lib/net/http.rb: HTTP.get accepts URI.
* lib/net/http.rb: add some HTTP 1.1 response codes.
@
text
@d40 2
d47 2
a48 2
        response = http.post( '/cgi-bin/any.rhtml',
                              'querytype=subject&target=ruby' )
d61 4
a64 4
          :
    Net::HTTP::Proxy($proxy_addr, $proxy_port).start( 'some.www.server' ) {|http|
      # always connect to your.proxy.addr:8080
          :
d70 1
a70 1
=== Redirect
a72 1
    require 'uri'
d74 2
a75 2
    def read_uri( uri )
      response = HTTP.get_uri(URI.parse(uri))
d84 1
a84 1
    p read_uri('http://www.ruby-lang.org')
d196 7
d204 9
a212 2
    gets entity body from path and returns it.
    return value is a String.
d214 2
a215 2
: get_print( address, path, port = 80 )
    gets entity body from path and output it to $stdout.
d510 1
d553 10
a562 2
    def HTTP.get_print( addr, path, port = nil )
      new( addr, port || HTTP.default_port ).start {|http|
d569 4
d574 1
a574 1
        get_path(arg1, arg2, arg3).body
d576 1
a576 1
        get_uri(arg1).body
d580 1
a580 1
    def HTTP.get_path( addr, path, port = nil )
d585 1
a585 1
    private_class_method :get_path
d587 5
a591 3
    def HTTP.get_uri( uri )
      new(uri.addr, uri.port).start {|http|
          return http.request(Get.new(http_path(uri)))
d594 1
@


1.70
log
@modify typo.
@
text
@d17 1
a17 1
$Id: http.rb,v 1.69 2002/02/22 12:10:58 aamine Exp $
a29 3
Be care to ',' (comma) putted after "response".
This is required for compatibility.

d32 2
a33 2
      response , = http.get('/index.html')
      puts response.body
d45 2
a46 2
        response , = http.post( '/cgi-bin/any.rhtml',
                                'querytype=subject&target=ruby' )
d71 1
a71 1
    Net::HTTP.version_1_1
d73 7
a79 12
    host = 'www.ruby-lang.org'
    path = '/'
    begin
      Net::HTTP.start( host, 80 ) {|http|
	response , = http.get(path)
        print response.body
      }
    rescue Net::ProtoRetriableError => err
      if m = %r<http://([^/]+)>.match( err.response['location'] ) then
	host = m[1].strip
	path = m.post_match
	retry
d83 6
a88 2
NOTE: This code is using ad-hoc way to extract host name, but in future
URI class will be included in ruby standard library.
d94 2
d97 1
a97 2
        response , = http.get( '/need-auth.cgi',
                'Authorization' => 'Basic ' + ["#{account}:#{password}"].pack('m').strip )
d101 4
a104 1
In version 1.2 (Ruby 1.7 or later), you can write like this:
d106 51
a156 1
    require 'net/http'
d158 1
a158 6
    req = Net::HTTP::Get.new('/need-auth.cgi')
    req.basic_auth 'account', 'password'
    Net::HTTP.start( 'auth.some.domain' ) {|http|
        response = http.request(req)
        print response.body
    }
d162 3
a164 3
You can use old Net::HTTP (in Ruby 1.6) features by calling
HTTP.version_1_1. And calling Net::HTTP.version_1_2 allows
you to use 1.2 features again.
d175 1
a175 1
Yes, this is not thread-safe.
d186 3
d190 2
a191 1
    is equals to
d193 1
a193 1
        Net::HTTP.new(address, port, proxy_addr, proxy_port).start(&block)
d228 1
a228 1
    creates a new Net::HTTP object and starts HTTP session.
d230 2
a231 2
    When this method is called with block, gives a HTTP object to block
    and close the HTTP session after block call finished.
d233 2
a234 2
: active?
    true if HTTP session is started.
d394 1
a394 1
	    end
d408 1
a408 1
== class Net::HTTP::Get, Head, Post
d410 2
a411 2
HTTP request classes. These classes wraps request header and
entity path. All arguments named "key" is case-insensitive.
d537 16
a552 3
    def HTTP.get( addr, path, port = nil )
      req = Get.new( path )
      resp = nil
d554 1
a554 1
          resp = http.request( req )
a555 1
      resp.body
d557 1
d559 3
a561 3
    def HTTP.get_print( addr, path, port = nil )
      new( addr, port || HTTP.port ).start {|http|
          http.get path, nil, $stdout
a562 1
      nil
d591 1
d594 2
d644 1
a644 1
      type.proxy_class?
d648 1
a648 1
      type.proxy_address
d652 1
a652 1
      type.proxy_port
d768 1
a768 1
      unless active? then
d776 1
a776 2
          req.__send__(:exec,
                       @@socket, @@curr_http_version, edit_path(req.path), body)
d778 1
a778 1
            res = HTTPResponse.read_new(@@socket, req.response_body_permitted?)
d780 3
a782 1
          yield res if block_given?
d794 4
a797 1
      if not req.body_exist? or @@seems_1_0_server then
a803 1
      res.__send__ :terminate
d806 2
a807 1
      if not res.body then
d811 1
a811 1
        if @@socket.closed? then   # (only) read stream had been closed
a813 1
          @@socket.close
d846 3
a848 3
      if @@dout then
        @@dout << msg
        @@dout << "\n"
d961 3
a963 5
      s = @@header['content-length']
      s or return nil

      m = /\d+/.match(s)
      m or raise HTTPHeaderSyntaxError, 'wrong Content-Length format'
d973 3
a975 6
      s = @@header['content-range']
      s or return nil

      m = %r<bytes\s+(\d+)-(\d+)/(?:\d+|\*)>i.match( s )
      m or raise HTTPHeaderSyntaxError, 'wrong Content-Range format'

d980 1
a980 1
      r = content_range
d1021 1
a1021 1
      "\#<#{self.type} #{@@method}>"
d1038 1
a1038 2
    private

d1048 2
d1089 3
a1091 3
      super type::METHOD,
            type::REQUEST_HAS_BODY,
            type::RESPONSE_HAS_BODY,
d1149 1
a1149 1
  class HTTPInformation < HTTPResponse
d1153 1
a1153 1
  class HTTPSuccess < HTTPResponse
d1157 1
a1157 1
  class HTTPRedirection < HTTPResponse
d1161 1
a1161 1
  class HTTPClientError < HTTPResponse
d1165 1
a1165 1
  class HTTPServerError < HTTPResponse
d1169 2
a1170 1
  class HTTPContinue < HTTPInformation
d1173 1
a1173 1
  class HTTPSwitchProtocol < HTTPInformation
d1176 2
a1177 1
  class HTTPOK < HTTPSuccess
d1180 1
a1180 1
  class HTTPCreated < HTTPSuccess
d1183 1
a1183 1
  class HTTPAccepted < HTTPSuccess
d1186 1
a1186 1
  class HTTPNonAuthoritativeInformation < HTTPSuccess
d1189 1
a1189 1
  class HTTPNoContent < HTTPSuccess
d1192 1
a1192 1
  class HTTPResetContent < HTTPSuccess
d1195 1
a1195 1
  class HTTPPartialContent < HTTPSuccess
d1198 5
a1202 1
  class HTTPMultipleChoice < HTTPRedirection
d1205 1
a1205 1
  class HTTPMovedPermanently < HTTPRedirection
d1208 2
a1209 1
  class HTTPMovedTemporarily < HTTPRedirection
d1212 1
a1212 1
  class HTTPNotModified < HTTPRedirection
d1215 1
a1215 1
  class HTTPUseProxy < HTTPRedirection
d1218 6
a1223 1
  class HTTPBadRequest < HTTPClientError
d1226 1
a1226 1
  class HTTPUnauthorized < HTTPClientError
d1229 1
a1229 1
  class HTTPPaymentRequired < HTTPClientError
d1232 1
a1232 1
  class HTTPForbidden < HTTPClientError
d1235 1
a1235 1
  class HTTPNotFound < HTTPClientError
d1238 1
a1238 1
  class HTTPMethodNotAllowed < HTTPClientError
d1241 1
a1241 1
  class HTTPNotAcceptable < HTTPClientError
d1244 1
a1244 1
  class HTTPProxyAuthenticationRequired < HTTPClientError
d1247 1
a1247 1
  class HTTPRequestTimeOut < HTTPClientError
d1250 1
a1250 1
  class HTTPConflict < HTTPClientError
d1253 1
a1253 1
  class HTTPGone < HTTPClientError
d1256 1
a1256 1
  class HTTPLengthRequired < HTTPClientError
d1259 1
a1259 1
  class HTTPPreconditionFailed < HTTPClientError
d1262 1
a1262 1
  class HTTPRequestEntityTooLarge < HTTPClientError
d1265 1
a1265 1
  class HTTPRequestURITooLarge < HTTPClientError
d1268 2
a1269 1
  class HTTPUnsupportedMediaType < HTTPClientError
d1272 1
a1272 1
  class HTTPInternalServerError < HTTPServerError
d1275 1
a1275 1
  class HTTPNotImplemented < HTTPServerError
d1278 2
a1279 1
  class HTTPBadGateway < HTTPServerError
d1282 1
a1282 1
  class HTTPServiceUnavailable < HTTPServerError
d1285 1
a1285 1
  class HTTPGatewayTimeOut < HTTPServerError
d1288 7
a1294 1
  class HTTPVersionNotSupported < HTTPServerError
d1322 2
a1323 1
      '302' => HTTPMovedTemporarily,
d1326 1
d1342 1
a1342 1
      '414' => HTTPRequestURITooLarge,
d1344 2
d1358 1
a1358 1
      def read_new( sock, hasbody )
d1360 1
a1360 1
        res = response_class(code).new( httpv, code, msg, sock, hasbody )
d1404 1
a1404 1
    def initialize( httpv, code, msg, sock, hasbody )
a1407 2
      @@socket       = sock
      @@body_exist   = hasbody
d1420 1
a1420 1
      "#<#{type} #{@@code} readbody=#{@@read}>"
d1428 1
a1428 1
      self.type
d1432 1
a1432 1
      raise error_type.new(@@code + ' ' + @@message.dump, self)
d1436 1
a1436 1
      type::EXCEPTION_TYPE
d1444 1
a1444 1
    # header (for backward compatibility)
d1458 9
d1470 1
a1470 1
                raise IOError, "#{type}\#read_body called twice with argument"
d1476 1
a1476 1
      if @@body_exist and self.type.body_permitted? then
a1490 4

    def terminate
      read_body
    end
@


1.69
log
@* lib/net/protocol.rb: set read_timeout dynamically.
* lib/net/http.rb: @@@@newimpl is always true in the main trunk.
* lib/net/http.rb: HTTP.port -> default_port
* lib/net/http.rb: HTTPResponse.read_response_status -> read_status_line
@
text
@d17 1
a17 1
$Id: header.rd,v 1.3 2002/02/19 12:23:15 aamine Exp $
d1300 1
a1300 1
      def each_response_header( sock, res )
@


1.68
log
@aamine
* lib/net/protocol.rb: rename Protocol.port to default_port.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
* lib/net/protocol.rb: rename BufferedSocket class to InternetMessageIO.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#write_pendstr to write_message.
* lib/net/smtp.rb: ditto.
* lib/net/protocol.rb: new method InternetMessageIO#through_message.
* lib/net/smtp.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#read_pendstr to read_message_to.
* lib/net/pop.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#read_pendlist to each_list_item
* lib/net/pop.rb: ditto.
* lib/net/protocol.rb: Now block size is 1024.
* lib/net/smtp.rb: new methods SMTP#esmtp? and #esmtp=.
* lib/net/http.rb: Using singleton method syntax instead of singleton class clause, to avoid behavior change of class variables in ruby 1.7.
* lib/net/http.rb: HTTPResponse class does not inherit from Net::Response.
* lib/net/http.rb: devide HTTP#connecting into {begin,end}_transport.
* lib/net/http.rb: unused class Accumulator removed.
* lib/net/http.rb: Net::HTTP reads response. not HTTPRequest.
* lib/net/http.rb: proxy related class-instance-variables are not initialized correctly.
@
text
@d463 1
a463 5
    if RUBY_VERSION  <= '1.6' then
      @@@@newimpl = false
    else
      @@@@newimpl = true
    end
d491 1
a491 1
      new( addr, port || HTTP.port ).start {|http|
d775 1
a775 1
      address + (port == HTTP.port ? '' : ":#{port}")
d847 13
a859 19
      s = @@header['range']
      s or return nil

      arr = []
      s.split(',').each do |spec|
        m = /bytes\s*=\s*(\d+)?\s*-\s*(\d+)?/i.match( spec )
        m or raise HTTPHeaderSyntaxError, "wrong Range: #{spec}"

        d1 = m[1].to_i
        d2 = m[2].to_i
        if    m[1] and m[2] then arr.push(  d1..d2 )
        elsif m[1]          then arr.push(  d1..-1 )
        elsif          m[2] then arr.push( -d2..-1 )
        else
          raise HTTPHeaderSyntaxError, 'range is not specified'
        end
      end

      return arr
d1272 1
a1272 1
        httpv, code, msg = read_response_status(sock)
d1274 8
a1281 1
        read_response_header sock, res
d1287 1
a1287 1
      def read_response_status( sock )
d1291 1
a1291 1
        return m.to_a[1,3]
d1300 1
a1300 1
      def read_response_header( sock, res )
d1308 1
a1308 7
          name = m[1]
          line = m.post_match
          if res.key? name then
            res[name] << ', ' << line
          else
            res[name] = line
          end
@


1.67
log
@aamine
* lib/net/http.rb: HTTP.Proxy should use self for proxy-class's super class.
* lib/net/http.rb: initialize HTTP.proxy_port by HTTP.port.
@
text
@d5 1
a5 1
Copyright (c) 1999-2001 Yukihiro Matsumoto
d17 1
a17 1
$Id: header.rd,v 1.2 2001/12/10 12:37:16 aamine Exp $
d100 1
a100 1
                'Authentication' => ["#{account}:#{password}"].pack('m').strip )
d456 3
d460 1
a460 1
    # constructors
d463 5
a467 13
    class << self

      def start( address, port = nil, p_addr = nil, p_port = nil, &block )
        new( address, port, p_addr, p_port ).start( &block )
      end

      alias newobj new

      def new( address, port = nil, p_addr = nil, p_port = nil )
        obj = Proxy(p_addr, p_port).newobj(address, port)
        setimplversion obj
        obj
      end
d469 2
d473 2
a474 4
    def initialize( addr, port = nil )
      super
      @@curr_http_version = HTTPVersion
      @@seems_1_0_server = false
d477 2
a478 13

    #
    # connection
    #

    protocol_param :port, '80'

    HTTPVersion = '1.1'

    private

    def do_start
      conn_socket
d481 3
a483 2
    def do_finish
      disconn_socket
d485 1
d510 1
a510 1
    # proxy
d513 7
a519 1
    public
d521 1
a521 3
    class << self
      def Proxy( p_addr, p_port = nil )
        p_addr or return self
d523 4
a526 10
        p_port ||= port()
        mod = ProxyDelta
        proxyclass = Class.new(self)
        proxyclass.module_eval {
            include mod
            @@is_proxy_class = true
            @@proxy_address = p_addr
            @@proxy_port    = p_port
        }
        proxyclass
d528 1
d530 5
a534 3
      @@is_proxy_class = false
      @@proxy_addr = nil
      @@proxy_port = nil
d536 39
d600 1
a600 1
    # without proxy
a633 34
    # for backward compatibility
    #

    if Version < '1.2.0' then   ###noupdate
      @@@@newimpl = false
    else
      @@@@newimpl = true
    end

    class << self

      def version_1_2
        @@@@newimpl = true
      end

      def version_1_1
        @@@@newimpl = false
      end

      def is_version_1_2?
        @@@@newimpl
      end

      private

      def setimplversion( obj )
        f = @@@@newimpl
        obj.instance_eval { @@newimpl = f }
      end

    end


    #
d677 1
d699 1
d706 1
d715 10
a724 6
      connecting( req ) {
          req.__send__( :exec,
                  @@socket, @@curr_http_version, edit_path(req.path), body )
          yield req.response if block_given?
      }
      req.response
d729 1
a729 1
    def connecting( req )
d737 1
d739 3
a741 3
      yield req
      req.response.__send__ :terminate
      @@curr_http_version = req.response.http_version
d743 1
a743 1
      if not req.response.body then
d745 1
a745 1
      elsif keep_alive? req, req.response then
d791 1
a791 65


  class Code

    def http_mkchild( bodyexist = nil )
      c = mkchild(nil)
      be = if bodyexist.nil? then @@body_exist else bodyexist end
      c.instance_eval { @@body_exist = be }
      c
    end

    def body_exist?
      @@body_exist
    end
  
  end

  HTTPInformationCode               = InformationCode.http_mkchild( false )
  HTTPSuccessCode                   = SuccessCode    .http_mkchild( true )
  HTTPRedirectionCode               = RetriableCode  .http_mkchild( true )
  HTTPRetriableCode = HTTPRedirectionCode
  HTTPClientErrorCode               = FatalErrorCode .http_mkchild( true )
  HTTPFatalErrorCode = HTTPClientErrorCode
  HTTPServerErrorCode               = ServerErrorCode.http_mkchild( true )


  HTTPSwitchProtocol                = HTTPInformationCode.http_mkchild

  HTTPOK                            = HTTPSuccessCode.http_mkchild
  HTTPCreated                       = HTTPSuccessCode.http_mkchild
  HTTPAccepted                      = HTTPSuccessCode.http_mkchild
  HTTPNonAuthoritativeInformation   = HTTPSuccessCode.http_mkchild
  HTTPNoContent                     = HTTPSuccessCode.http_mkchild( false )
  HTTPResetContent                  = HTTPSuccessCode.http_mkchild( false )
  HTTPPartialContent                = HTTPSuccessCode.http_mkchild

  HTTPMultipleChoice                = HTTPRedirectionCode.http_mkchild
  HTTPMovedPermanently              = HTTPRedirectionCode.http_mkchild
  HTTPMovedTemporarily              = HTTPRedirectionCode.http_mkchild
  HTTPNotModified                   = HTTPRedirectionCode.http_mkchild( false )
  HTTPUseProxy                      = HTTPRedirectionCode.http_mkchild( false )
  
  HTTPBadRequest                    = HTTPClientErrorCode.http_mkchild
  HTTPUnauthorized                  = HTTPClientErrorCode.http_mkchild
  HTTPPaymentRequired               = HTTPClientErrorCode.http_mkchild
  HTTPForbidden                     = HTTPClientErrorCode.http_mkchild
  HTTPNotFound                      = HTTPClientErrorCode.http_mkchild
  HTTPMethodNotAllowed              = HTTPClientErrorCode.http_mkchild
  HTTPNotAcceptable                 = HTTPClientErrorCode.http_mkchild
  HTTPProxyAuthenticationRequired   = HTTPClientErrorCode.http_mkchild
  HTTPRequestTimeOut                = HTTPClientErrorCode.http_mkchild
  HTTPConflict                      = HTTPClientErrorCode.http_mkchild
  HTTPGone                          = HTTPClientErrorCode.http_mkchild
  HTTPLengthRequired                = HTTPClientErrorCode.http_mkchild
  HTTPPreconditionFailed            = HTTPClientErrorCode.http_mkchild
  HTTPRequestEntityTooLarge         = HTTPClientErrorCode.http_mkchild
  HTTPRequestURITooLarge            = HTTPClientErrorCode.http_mkchild
  HTTPUnsupportedMediaType          = HTTPClientErrorCode.http_mkchild

  HTTPNotImplemented                = HTTPServerErrorCode.http_mkchild
  HTTPBadGateway                    = HTTPServerErrorCode.http_mkchild
  HTTPServiceUnavailable            = HTTPServerErrorCode.http_mkchild
  HTTPGatewayTimeOut                = HTTPServerErrorCode.http_mkchild
  HTTPVersionNotSupported           = HTTPServerErrorCode.http_mkchild

a951 1
      @@response = nil
a966 1
    attr_reader :response
d969 1
a969 1
      "\#<#{type}>"
a981 3

    private

d986 3
a988 1
    def exec( sock, ver, path, body, &block )
d991 1
a991 2
        check_arg_b body, block
        sendreq_with_body sock, ver, path, body, &block
d993 1
a993 2
        check_arg_n body
        sendreq_no_body sock, ver, path
a994 2
      @@response = r = get_response(sock)
      r
d1002 1
a1002 15
    def check_arg_b( data, block )
      (data and block) and raise ArgumentError, 'both of data and block given'
      (data or block) or raise ArgumentError, 'str or block required'
    end

    def check_arg_n( data )
      data and raise ArgumentError, "data is not permitted for #{@@method}"
    end


    def sendreq_no_body( sock, ver, path )
      request sock, ver, path
    end

    def sendreq_with_body( sock, ver, path, body )
a1028 11

    #
    # read
    #

    def get_response( sock )
      begin
        resp = HTTPResponse.new_from_socket(sock, response_body_permitted?)
      end while ContinueCode === resp
      resp
    end
a1044 24
  class Accumulator
  
    def initialize
      @@buf = ''
    end

    def write( s )
      @@buf.concat s
    end

    def <<( s )
      @@buf.concat s
      self
    end

    def terminate
      ret = @@buf
      @@buf = nil
      ret
    end
  
  end


d1079 146
a1224 1
  class HTTPResponse < Response
d1226 1
a1226 1
    include HTTPHeader
d1229 5
a1233 5
      '1' => HTTPInformationCode,
      '2' => HTTPSuccessCode,
      '3' => HTTPRedirectionCode,
      '4' => HTTPClientErrorCode,
      '5' => HTTPServerErrorCode
a1234 1

d1236 1
a1236 1
      '100' => ContinueCode,
a1249 1
      '303' => HTTPMovedPermanently,
d1264 1
a1264 1
      '411' => HTTPFatalErrorCode,
d1270 1
a1270 1
      '500' => HTTPFatalErrorCode,
d1281 15
a1295 2
      def new_from_socket( sock, hasbody )
        resp = readnew( sock, hasbody )
d1297 7
d1309 3
a1311 3
          m = /\A([^:]+):\s*/.match( line )
          m or raise HTTPBadResponse, 'wrong header line format'
          nm = m[1]
d1313 2
a1314 2
          if resp.key? nm then
            resp[nm] << ', ' << line
d1316 1
a1316 1
            resp[nm] = line
a1318 2

        resp
d1321 1
a1321 1
      private
a1322 10
      def readnew( sock, hasbody )
        str = sock.readline
        m = /\AHTTP(?:\/(\d+\.\d+))?\s+(\d\d\d)\s*(.*)\z/in.match( str )
        m or raise HTTPBadResponse, "wrong status line: #{str}"
        discard, httpv, stat, desc = *m.to_a
        
        new( stat, desc, sock, hasbody, httpv )
      end

    end
d1324 1
d1326 6
a1331 8
    def initialize( stat, msg, sock, be, hv )
      code = CODE_TO_OBJ[stat] ||
             CODE_CLASS_TO_OBJ[stat[0,1]] ||
             UnknownCode
      super code, stat, msg
      @@socket = sock
      @@body_exist = be
      @@http_version = hv
d1339 3
d1344 17
a1360 1
      "#<#{type} #{code}>"
d1364 1
a1364 1
      SuccessCode === self or error!
a1366 1

d1391 1
a1391 2

      if @@body_exist and code_type.body_exist? then
d1443 1
a1443 1
        ;
d1452 2
a1453 3
      if dest and block then
        raise ArgumentError, 'both of arg and block are given for HTTP method'
      end
d1455 1
a1455 1
        ReadAdapter.new block
d1464 1
a1466 2
  HTTPSession = HTTP

a1470 1
    Accumulator          = ::Net::Accumulator
d1473 7
@


1.66
log
@aamine
* lib/net/protocol.rb: Protocol#start returns the return value of block.
* lib/net/protocol.rb: set timeout limit by default.
* lib/net/protocol.rb: new methods WriteAdapter#write, puts, print, printf.
* lib/net/http.rb: rename HTTP#get2 to request_get, post2 to request_post ...
* lib/net/smtp.rb: should not resolve HELO domain automatically.
@
text
@a455 2
    HTTPVersion = '1.1'

d457 1
a457 1
    # connection
d460 15
a474 1
    protocol_param :port, '80'
d482 9
a529 1

d531 1
a531 6
        if p_addr then
          ProxyMod.create_proxy_class( p_addr, p_port || self.port )
        else
          self
        end
      end
d533 10
a542 11
      alias orig_new new

      def new( address, port = nil, p_addr = nil, p_port = nil )
        c = p_addr ? self::Proxy(p_addr, p_port) : self
        i = c.orig_new( address, port )
        setimplversion i
        i
      end

      def start( address, port = nil, p_addr = nil, p_port = nil, &block )
        new( address, port, p_addr, p_port ).start( &block )
a554 1

d572 12
d588 2
d591 1
a591 15
    module ProxyMod

      def self.create_proxy_class( p_addr, p_port )
        mod = self
        klass = Class.new( HTTP )
        klass.module_eval {
            include mod
            @@is_proxy_class = true
            @@proxy_address = p_addr
            @@proxy_port    = p_port
        }
        klass
      end

      private
d594 1
a594 1
        proxy_address()
d598 1
a598 1
        proxy_port()
d604 1
a604 2
    
    end   # module ProxyMod
@


1.65
log
@aamine
* lib/net/protocol.rb: rename Net::Socket to Net::BufferedSocket
@
text
@d218 1
a218 1
: get( path, header = nil, dest = '' )
a221 1
    Response body is written into DEST by using "<<" method.
d223 4
a226 1
    This method returns Net::HTTPResponse object.
d228 2
a229 2
    If called with block, gives entity body little by little
    to the block (as String).
a233 1

a251 4
        # same effect
        File.open( 'save.txt', 'w' ) {|f|
            http.get '/~foo/', nil, f
        }
d262 1
d270 1
a270 1
: post( path, data, header = nil, dest = '' )
d272 6
a277 5
    posts "data" (must be String) to "path".
    If the body exists, also gets entity body.
    Response body is written into "dest" by using "<<" method.
    "header" must be a Hash like { 'Accept' => '*/*', ... }.
    This method returns Net::HTTPResponse object.
d284 1
d287 2
a288 1
        response, body = http.post( '/cgi-bin/search.rb', 'querytype=subject&target=ruby' )
d290 4
a293 3
        response = http.post( '/cgi-bin/search.rb', 'querytype=subject&target=ruby' )
        # compatible for both version
        response , = http.post( '/cgi-bin/search.rb', 'querytype=subject&target=ruby' )
d297 2
a298 1
            http.post( '/cgi-bin/search.rb', 'querytype=subject&target=ruby' ) do |str|
a301 4
        # same effect
        File.open( 'save.html', 'w' ) {|f|
            http.post '/cgi-bin/search.rb', 'querytype=subject&target=ruby', nil, f
        }
d303 2
a304 2
: get2( path, header = nil )
: get2( path, header = nil ) {|response| .... }
d310 1
a310 1
    This method never raise any ProtocolErrors.
d313 1
a313 1
        response = http.get2( '/index.html' )
d318 1
a318 1
        http.get2( '/index.html' ) {|response|
d325 2
a326 2
: post2( path, header = nil )
: post2( path, header = nil ) {|response| .... }
d332 2
d350 1
a350 1
    sends a HTTPRequest object REQUEST to the (remote) http server.
d354 4
a357 2
    If called with block, passes a HTTPResponse object to the block
    before reading entity body.
a465 1

d472 2
a473 1
    def conn_command( sock )
d477 22
a507 1

d523 1
a523 1
        setvar i
d570 4
a573 4
          include mod
          @@is_proxy_class = true
          @@proxy_address = p_addr
          @@proxy_port    = p_port
d580 6
a585 2
      def conn_socket( addr, port )
        super proxy_address, proxy_port
d589 1
a589 1
        'http://' + addr_port + path
d621 1
a621 1
      def setvar( obj )
d635 49
a683 21
    def self.define_http_method_interface( nm, hasdest, hasdata )
      name = nm.id2name.downcase
      cname = nm.id2name
      lineno = __LINE__ + 2
      src = <<"      ----"

        def #{name}( path, #{hasdata ? 'data,' : ''}
                     u_header = nil #{hasdest ? ',dest = nil, &block' : ''} )
          resp = nil
          request(
              #{cname}.new( path, u_header ) #{hasdata ? ',data' : ''}
          ) do |resp|
            resp.read_body( #{hasdest ? 'dest, &block' : ''} )
          end
          if @@newimpl then
            resp
          else
            resp.value
            #{hasdest ? 'return resp, resp.body' : 'resp'}
          end
        end
d685 2
a686 7
        def #{name}2( path, #{hasdata ? 'data,' : ''}
                      u_header = nil, &block )
          request( #{cname}.new(path, u_header),
                   #{hasdata ? 'data,' : ''} &block )
        end
      ----
      module_eval src, __FILE__, lineno
d689 10
a698 4
    define_http_method_interface :Get,  true,  false
    define_http_method_interface :Head, false, false
    define_http_method_interface :Post, true,  true
    define_http_method_interface :Put,  false, true
d703 2
a704 2
          req['connection'] = 'close'
          return request(req, body, &block)
d709 3
a711 3
        req.__send__( :exec,
                @@socket, @@curr_http_version, edit_path(req.path), body )
        yield req.response if block_given?
a715 7
    def send_request( name, path, body = nil, header = nil )
      r = HTTPGenericRequest.new( name, (body ? true : false), true,
                                  path, header )
      request r, body
    end


a717 1

d720 1
a720 1
        re_connect
a763 19
    public

    def self.get( addr, path, port = nil )
      req = Get.new( path )
      resp = nil
      new( addr, port || HTTP.port ).start {|http|
        resp = http.request( req )
      }
      resp.body
    end

    def self.get_print( addr, path, port = nil )
      new( addr, port || HTTP.port ).start {|http|
        http.get path, nil, $stdout
      }
      nil
    end


a778 2
  HTTPSession = HTTP

d925 1
a925 3
      if fin then
        r = r ... r+fin
      end
d999 1
a999 1
    def initialize( m, reqbody, resbody, path, uhead = nil )
d1007 2
a1008 2
      return unless uhead
      uhead.each do |k,v|
d1052 1
a1052 1
      @@response = r = get_response( sock )
d1062 2
a1063 6
      if data and block then
        raise ArgumentError, 'both of data and block given'
      end
      unless data or block then
        raise ArgumentError, 'str or block required'
      end
d1119 1
a1119 1
    def initialize( path, uhead = nil )
d1123 1
a1123 1
            path, uhead
d1251 1
a1251 1
          line.sub!( /\s+\z/, '' )                 # don't use chop!
d1323 4
a1326 2
      if @@read and (dest or block) then
        raise IOError, "#{type}\#read_body called twice with argument"
d1329 8
a1336 11
      unless @@read then
        to = procdest( dest, block )
        stream_check

        if @@body_exist and code_type.body_exist? then
          read_body_0 to
          @@body = to
        else
          @@body = nil
        end
        @@read = true
d1338 1
a1345 1

a1347 1

d1376 1
a1376 1
        m = /[0-9a-fA-F]+/.match( line )
d1380 1
a1380 1
        @@socket.read( len, dest ); total += len
d1407 3
@


1.64
log
@aamine
* lib/net/pop.rb: new method Net::POP3.APOP
* lib/net/http.rb: set default Content-Type to x-www-form-urlencoded (causes warning)
* lib/net/protocol.rb: remove Net::NetPrivate module.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@@


1.63
log
@aamine
* lib/net/protocol.rb: calls on_connect before conn_command
@
text
@d3 1
a3 1
= net/http.rb version 1.2.3
d17 2
d660 2
a661 3
      r = ::Net::NetPrivate::HTTPGenericRequest.new(
              name, (body ? true : false), true,
              path, header )
a821 2
  net_private {

d838 1
a838 1
    def each( &block )
d842 2
d971 1
a971 1
    include ::Net::NetPrivate::HTTPHeader
d1064 5
d1087 1
a1087 2
        resp = ::Net::NetPrivate::HTTPResponse.new_from_socket(sock,
                                                response_body_permitted?)
a1129 2
  }

d1133 1
a1133 1
    class Get < ::Net::NetPrivate::HTTPRequest
d1139 1
a1139 1
    class Head < ::Net::NetPrivate::HTTPRequest
d1145 1
a1145 1
    class Post < ::Net::NetPrivate::HTTPRequest
d1151 1
a1151 1
    class Put < ::Net::NetPrivate::HTTPRequest
a1164 2
  net_private {

d1167 1
a1167 1
    include ::Net::NetPrivate::HTTPHeader
d1377 1
a1377 1
        ::Net::NetPrivate::ReadAdapter.new block
a1384 1
  }
d1386 9
a1394 3

  HTTPResponse         = NetPrivate::HTTPResponse
  HTTPResponseReceiver = NetPrivate::HTTPResponse
@


1.62
log
@aamine
* lib/net/smtp.rb: SMTP.new requires at least one arg.
* lib/net/pop.rb: POP.new requires at least one arg.
* lib/net/pop.rb: uses "raise *Error.new" instead of simple raise.
* lib/net/http.rb: HTTP.new requires at least one arg.
* lib/net/http.rb: changes implicit start algolithm.
@
text
@d46 2
a47 2
      response , = http.post( '/cgi-bin/any.rhtml',
                              'querytype=subject&target=ruby' )
d97 3
a99 3
      response , = http.get( '/need-auth.cgi',
              'Authentication' => ["#{account}:#{password}"].pack('m').strip )
      print response.body
d109 2
a110 2
      response = http.request( req )
      print response.body
d160 5
a164 5
          :
        proxy_class.start( 'www.ruby-lang.org' ) do |http|
          # connecting proxy.foo.org:8080
          :
        end
d245 3
a247 3
          http.get( '/~foo/', nil ) do |str|
            f.write str
          end
d251 1
a251 1
          http.get '/~foo/', nil, f
d266 1
a266 1
          response = http.head( '/index.html' )
d293 3
a295 3
          http.post( '/cgi-bin/search.rb', 'querytype=subject&target=ruby' ) do |str|
            f.write str
          end
d299 1
a299 1
          http.post '/cgi-bin/search.rb', 'querytype=subject&target=ruby', nil, f
d318 4
a321 4
          p response['content-type']
          response.read_body do |str|   # read body now
            print str
          end
d338 5
a342 5
          p response.status
          p response['content-type']
          response.read_body do |str|   # read body now
            print str
          end
@


1.61
log
@aamine
* lib/net/protocol.rb: Protocol.new requires at least one arg.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@d14 2
a15 3
NOTE: You can get Japanese version of this document from
Ruby Documentation Project (RDP):
((<URL:http://www.ruby-lang.org/~rubikitch/RDP.cgi>))
d641 8
a648 1
    def request( req, body = nil )
d669 1
a669 8
      unless active? then
        implicit = true
        req['connection'] ||= 'close'
      end

      if not @@socket then
        start
      elsif @@socket.closed? then
a692 4
      end

      if implicit then
        finish
@


1.60
log
@aamine
* lib/net/http.rb: HTTP#proxy? did not worked.
@
text
@d135 1
a135 1
: new( address = 'localhost', port = 80, proxy_addr = nil, proxy_port = nil )
d139 2
a140 2
: start( address = 'localhost', port = 80, proxy_addr = nil, proxy_port = nil )
: start( address = 'localhost', port = 80, proxy_addr = nil, proxy_port = nil ) {|http| .... }
d460 1
a460 1
    def initialize( addr = nil, port = nil )
d495 1
a495 1
      def new( address = nil, port = nil, p_addr = nil, p_port = nil )
d502 1
a502 1
      def start( address = nil, port = nil, p_addr = nil, p_port = nil, &block )
@


1.59
log
@aamine
* lib/net/http.rb: rename HTTP#request_by_name to send_request.
* lib/net/protocol.rb (ProtoSocket#read): modify typo.
@
text
@d520 1
a520 1
      type.proxy?
d546 1
a546 1
          @@is_proxy = true
@


1.58
log
@aamine
* lib/net/http.rb (HTTP#request_by_name): arg order changes.
@
text
@d3 1
a3 1
= net/http.rb version 1.2.2
d269 1
a269 4
        response['content-length']   #-> '2554'
        response['content-type']     #-> 'text/html'
        response['Content-Type']     #-> 'text/html'
        response['CoNtEnT-tYpe']     #-> 'text/html'
d286 1
a286 1
        response, body = http.post( '/index.html', 'querytype=subject&target=ruby' )
d288 1
a288 1
        response = http.post( '/index.html', 'querytype=subject&target=ruby' )
d290 1
a290 1
        response , = http.post( '/index.html', 'querytype=subject&target=ruby' )
d294 1
a294 1
          http.post( '/index.html', 'querytype=subject&target=ruby' ) do |str|
d300 44
a343 1
          http.post '/index.html', 'querytype=subject&target=ruby', nil, f
d348 3
a350 4
    sends a HTTPRequest object REQUEST to (remote) http server.
    This method also writes string from DATA string if REQUEST is
    a post/put request. Giving DATA for get/head request causes
    ArgumentError.
d352 2
a353 2
    If called with block, gives a HTTPResponse object to the block
    with connecting server.
a438 1

d651 1
a651 1
    def request_by_name( name, path, body = nil, header = nil )
@


1.57
log
@aamine
* lib/net/http.rb (HTTP#request_by_name): bug fix.
* lib/net/http.rb: does not write Connection: by default.
* lib/net/protocol.rb: "start" for started protocol is an error.
* lib/net/protocol.rb: "finish" for finished protocol is an error.
@
text
@d613 1
a613 1
    def request_by_name( name, path, header = nil, body = nil )
d615 1
a615 1
              name, body ? true : false, true,
@


1.56
log
@aamine
* lib/net/http.rb: new method HTTP#request_by_name (test)
* lib/net/http.rb: new class HTTPGenericRequest
@
text
@d206 1
a206 1
    If HTTP session had not started, do nothing and return false.
d613 1
a613 1
    def request_by_name( name, path, header, body = nil )
d625 5
a629 1
      req['connection'] ||= 'keep-alive'
a631 1
        req['connection'] = 'close'
d638 1
a638 1
      req['host'] = addr_port
d656 4
@


1.55
log
@* protocol.rb,smtp.rb,pop.rb,http.rb: modify document.
@
text
@d3 1
a3 1
= net/http.rb version 1.2.1
d568 1
a568 1
    def self.def_http_method( nm, hasdest, hasdata )
d599 4
a602 4
    def_http_method :Get,  true,  false
    def_http_method :Head, false, false
    def_http_method :Post, true,  true
    def_http_method :Put,  false, true
d604 2
a605 2
    def request( req, *args )
      common_oper( req ) {
d607 1
a607 1
                @@socket, @@curr_http_version, edit_path(req.path), *args )
d613 7
d624 1
a624 1
    def common_oper( req )
a653 2

      req.response
d844 3
a846 3
        if    m[1] and m[2] then arr.push  d1..d2
        elsif m[1]          then arr.push  d1..-1
        elsif          m[2] then arr.push -d2..-1
a922 2
  }

d928 1
a928 3
  net_private {

  class HTTPRequest
d932 4
a935 1
    def initialize( path, uhead = nil )
d937 2
a948 3

      @@socket = nil
      @@response = nil
d951 1
d959 6
a964 2
    def body_exist?
      type::HAS_BODY
d967 2
d976 11
a986 5
    def exec( sock, ver, path )
      ready( sock ) {
        request ver, path
      }
      @@response
d989 3
a991 6
    def ready( sock )
      @@response = nil
      @@socket = sock
      yield
      @@response = get_response
      @@socket = nil
d994 6
a999 4
    def request( ver, path )
      @@socket.writeline sprintf('%s %s HTTP/%s', type::METHOD, path, ver)
      canonical_each do |k,v|
        @@socket.writeline k + ': ' + v
a1000 1
      @@socket.writeline ''
d1003 2
a1004 9
    #
    # read
    #

    def get_response
      begin
        resp = read_response
      end while ContinueCode === resp
      resp
a1006 2
    def read_response
      resp = get_resline
d1008 2
a1009 17
      while true do
        line = @@socket.readuntil( "\n", true )   # ignore EOF
        line.sub!( /\s+\z/, '' )                 # don't use chop!
        break if line.empty?

        m = /\A([^:]+):\s*/.match( line )
        m or raise HTTPBadResponse, 'wrong header line format'
        nm = m[1]
        line = m.post_match
        if resp.key? nm then
          resp[nm] << ', ' << line
        else
          resp[nm] = line
        end
      end

      resp
d1012 1
a1012 22
    def get_resline
      str = @@socket.readline
      m = /\AHTTP(?:\/(\d+\.\d+))?\s+(\d\d\d)\s*(.*)\z/i.match( str )
      m or raise HTTPBadResponse, "wrong status line: #{str}"
      httpver = m[1]
      status  = m[2]
      discrip = m[3]
      
      ::Net::NetPrivate::HTTPResponse.new(
              status, discrip, @@socket, type::HAS_BODY, httpver )
    end
  
  end


  class HTTPRequestWithBody < HTTPRequest
  
    private

    def exec( sock, ver, path, str = nil )
      check_arg str, block_given?

d1018 1
a1018 1
        data = str
d1023 2
a1024 5
      ready( sock ) {
        request ver, path
        @@socket.write data
      }
      @@response
d1027 4
a1030 6
    def check_arg( data, blkp )
      if data and blkp then
        raise ArgumentError, 'both of data and block given'
      end
      unless data or blkp then
        raise ArgumentError, 'str or block required'
d1032 13
d1050 12
a1090 1
      HAS_BODY = true
d1092 2
a1096 1
      HAS_BODY = false
d1098 2
d1102 1
a1102 2
    class Post < ::Net::NetPrivate::HTTPRequestWithBody
      HAS_BODY = true
d1104 2
d1108 1
a1108 2
    class Put < ::Net::NetPrivate::HTTPRequestWithBody
      HAS_BODY = true
d1110 2
d1179 39
@


1.54
log
@aamine
* lib/net/pop.rb: new methods POP3.auth_only, POP3#auth_only
* lib/net/http.rb: HTTP.Proxy returns self if ADDRESS is nil.
* lib/net/protocol.rb: new method ProtocolError#response
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: add document.
@
text
@d30 1
a30 1
This is required for feature compatibility.
d76 1
d79 2
a80 1
        response , = http.get('/')
d83 4
a86 3
      if m = %r<http:([^/]+)>.match( err.response['location'] ) then
        host = m[1].strip
        retry
d137 1
a137 2
    If proxy_addr is given, this method is equals to
    Net::HTTP::Proxy(proxy_addr,proxy_port).
d150 1
a150 2
    gets entity body from path and print it.
    return value is an entity body (a String).
d155 1
a155 1
    You can replace HTTP class by this proxy class.
d157 1
a157 1
    If ADDRESS is nil, this method returns self (Net::HTTP class).
d172 1
a172 1
    HTTP default port (80).
d212 1
a212 1
    address of proxy host. If self is not a proxy, nil.
d215 1
a215 1
    port number of proxy host. If self is not a proxy, nil.
d219 4
a222 3
    gets data from "path" on connecting host.
    "header" must be a Hash like { 'Accept' => '*/*', ... }.
    Response body is written into "dest" by using "<<" method.
d225 2
a226 1
    If called with block, give a part String of entity body.
d229 2
a230 2
    3xx (redirect). On the case you can get response object by
    err.response.
d234 1
a234 1
        # version 1.1 (Ruby 1.6)
d237 1
a237 1
        # version 1.2 (Ruby 1.7 or later)
d250 1
a250 1
        # some effect
d256 3
a258 2
    gets only header from "path" on connecting host.
    "header" is a Hash like { 'Accept' => '*/*', ... }.
d260 4
a263 1
    You can http header from this object like:
d284 4
d306 6
a311 5
: request( request, [data] )
: request( request, [src] ) {|response| .... }
    sends REQUEST to (remote) http server. This method also writes
    string from DATA string if REQUEST is a post/put request.
    (giving DATA for get/head request causes ArgumentError.)
d313 2
a314 1
    If called with block, gives a HTTPResponse object to the block.
@


1.53
log
@aamine
* lib/net/http.rb: add HTTPRequest#basic_auth.
* lib/net/smtp.rb: raise if only account or password is given.
* lib/net/protocol.rb: WriteAdapter#<< returns self.
@
text
@d3 1
a3 1
= net/http.rb version 1.2.0
d5 1
a5 1
  Copyright (C) 1999-2001 Yukihiro Matsumoto
d7 2
a8 2
  written & maintained by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
  This file is derived from "http-access.rb".
d10 3
a12 3
  This program is free software. You can re-distribute and/or
  modify this program under the same terms as Ruby itself,
  GNU General Public License or Ruby License.
d14 3
a16 3
  Japanese version of this document is in "net" full package.
  You can get it from RAA (Ruby Application Archive). RAA is:
  http://www.ruby-lang.org/en/raa.html
d18 109
d133 3
a135 3
  creates a new Net::HTTP object.
  If proxy_addr is given, this method is equals to
  Net::HTTP::Proxy(proxy_addr,proxy_port).
d139 1
a139 1
  is equals to
d141 1
a141 1
    Net::HTTP.new( address, port, proxy_addr, proxy_port ).start(&block)
d144 2
a145 2
  gets entity body from path and returns it.
  return value is a String.
d148 2
a149 2
  gets entity body from path and print it.
  return value is an entity body (a String).
d151 14
a164 12
: Proxy( address, port )
  creates a HTTP proxy class.
  Arguments are address/port of proxy host.
  You can replace HTTP class by this proxy class.

    # example
    proxy_http = HTTP::Proxy( 'proxy.foo.org', 8080 )
      :
    proxy_http.start( 'www.ruby-lang.org' ) do |http|
      # connecting proxy.foo.org:8080
      :
    end
d167 2
a168 2
  If self is HTTP, false.
  If self is a class which was created by HTTP::Proxy(), true.
d171 1
a171 2
  HTTP default port (80).

d177 13
a189 1
  creates a new Net::HTTP object and starts HTTP session.
d191 15
a205 2
  When this method is called with block, gives HTTP object to block
  and close HTTP session after block call finished.
d208 1
a208 1
  true if self is a HTTP proxy class
d211 1
a211 1
  address of proxy host. If self is not a proxy, nil.
d214 1
a214 1
  port number of proxy host. If self is not a proxy, nil.
d218 33
a250 9
  gets data from "path" on connecting host.
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
  Response body is written into "dest" by using "<<" method.
  This method returns Net::HTTPResponse object.

    # example
    response = http.get( '/index.html' )

  If called with block, give a part String of entity body.
d253 13
a265 9
  gets only header from "path" on connecting host.
  "header" is a Hash like { 'Accept' => '*/*', ... }.
  This method returns a Net::HTTPResponse object.
  You can http header from this object like:

    response['content-length']   #-> '2554'
    response['content-type']     #-> 'text/html'
    response['Content-Type']     #-> 'text/html'
    response['CoNtEnT-tYpe']     #-> 'text/html'
d269 25
a293 7
  posts "data" (must be String) to "path".
  If the body exists, also gets entity body.
  Response body is written into "dest" by using "<<" method.
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
  This method returns Net::HTTPResponse object.

  If called with block, gives a part of entity body string.
d295 1
a295 2

: request( request, [src] )
d297 3
a299 5
  sends REQUEST to (remote) http server. This method also writes
  string from SRC before it if REQUEST is a post/put request.
  (giving SRC for get/head request causes ArgumentError.)

  If called with block, gives a HTTP response object to the block.
d301 1
d313 1
a313 1
=== Methods
d322 19
d347 1
a347 1
=== Methods
d367 1
a367 1
    iterates for each canonical field name and value pair.
d376 1
a376 1
    gets response body and write it into DEST using "<<" method.
d381 1
a381 1
    gets response body little by little and pass it to block.
d384 2
a385 10
    response body. If #read_body has been called, this method
    returns arg of #read_body, DEST. Else gets body as String
    and returns it.


== Switching Net::HTTP versions

You can use Net::HTTP 1.1 features by calling HTTP.version_1_1 .
And calling Net::HTTP.version_1_2 allows you to use 1.2 features
again.
a386 8
  # example
  HTTP.start {|http1| ...(http1 has 1.2 features)... }

  HTTP.version_1_1
  HTTP.start {|http2| ...(http2 has 1.1 features)... }

  HTTP.version_1_2
  HTTP.start {|http3| ...(http3 has 1.2 features)... }
a408 1

a411 3
      @@proxy_address = nil
      @@proxy_port = nil

a415 1

d435 5
a439 1
        ProxyMod.create_proxy_class( p_addr, p_port || self.port )
d455 4
d460 1
a460 1
        false
d463 2
a464 7
      def proxy_address
        nil
      end

      def proxy_port
        nil
      end
d469 1
a469 1
      false
d473 1
a473 1
      nil
d477 1
a477 1
      nil
d480 3
d490 10
a499 25
      class << self

        def create_proxy_class( p_addr, p_port )
          mod = self
          klass = Class.new( HTTP )
          klass.module_eval {
            include mod
            @@proxy_address = p_addr
            @@proxy_port    = p_port
          }
          def klass.proxy_class?
            true
          end

          def klass.proxy_address
            @@proxy_address
          end

          def klass.proxy_port
            @@proxy_port
          end

          klass
        end

a501 15
      def initialize( addr, port )
        super
        @@proxy_address = type.proxy_address
        @@proxy_port    = type.proxy_port
      end
    
      attr_reader :proxy_address, :proxy_port

      alias proxyaddr proxy_address
      alias proxyport proxy_port

      def proxy?
        true
      end
    
d505 1
a505 1
        super @@proxy_address, @@proxy_port
d519 5
a523 1
    @@@@newimpl = true
d535 4
d826 3
a828 3
        if    m[1] and m[2] then arr.push (d1 .. d2)
        elsif m[1]          then arr.push (d1 .. -1)
        elsif          m[2] then arr.push (-d2 .. -1)
d834 1
a834 1
      return *arr
d1070 4
a1073 1
    alias << write
d1195 1
a1195 1
      SuccessCode === self or error! self
d1300 4
@


1.52
log
@aamine
* lib/net/protocol.rb: one write(2) per one line.
@
text
@d507 4
a510 1
      print get( addr, path, port )
d739 1
a739 1
      @@header['authorization'] = ["#{acc}:#{pass}"].pack('m').gsub(/\s+/, '')
@


1.51
log
@aamine
* lib/net/http.rb: always close connection on request without body.
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: change copyright.
@
text
@d127 6
a132 1
entity path. All "key" is case-insensitive.
d137 2
a138 1
  returns header field for "key".
d141 1
a141 1
  set header to "val".
d152 4
a155 3
    returns header field for KEY.
    for HTTP, value is a string like 'text/plain' (for Content-Type),
    '2045' (for Content-Length), 'bytes 0-1024/10024' (for Content-Range).
a156 1
    KEY is case insensitive.
d159 1
a159 2
    set field value for KEY.
    KEY is inseisitive.
d191 1
a191 1
== Swithing Net::HTTP versions
d662 3
a664 3
        if    m[1] and m[2] then arr.push d1 .. d2
        elsif m[1]          then arr.push d1 .. -1
        elsif          m[2] then arr.push -d2 .. -1
d1036 1
a1036 1
    def read_header
d1040 2
a1041 2
    alias header read_header
    alias response read_header
@


1.50
log
@aamine
* lib/net/protocol.rb: clear read buffer after reopen.
* lib/net/protocol.rb: refactoring.
* lib/net/http.rb: split module HTTPHeader from HTTPResponse.
@
text
@d5 3
a7 1
  maintained by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d10 3
a12 3
  This program is free software.
  You can distribute/modify this program under
  the terms of the Ruby Distribute License.
d15 2
a16 2
  You can get it from RAA
  (Ruby Application Archive: http://www.ruby-lang.org/en/raa.html).
d19 1
a19 1
= class Net::HTTP
d21 1
a21 1
== Class Methods
d63 1
a63 1
== Instance Methods
d124 1
a124 1
= class Net::HTTP::Get, Head, Post
d129 1
a129 1
== Methods
d138 1
a138 1
= class Net::HTTPResponse
d141 1
a141 3
All "key" is case-insensitive.

== Methods
d143 1
a143 2
: body
  the entity body. ("dest" argument for HTTP#get, post, put)
d146 5
a150 4
  returns header field for "key".
  for HTTP, value is a string like 'text/plain'(for Content-Type),
  '2045'(for Content-Length), 'bytes 0-1024/10024'(for Content-Range).
  Multiple header had be joined by HTTP1.1 scheme.
d153 2
a154 1
  set field value for "key".
d157 2
a158 1
  true if key exists
d161 4
a164 1
  iterates for each field name and value pair
d167 1
a167 1
  HTTP result code string. For example, '302'
d170 1
a170 1
  HTTP result message. For example, 'Not Found'
d173 3
a175 5
: body( dest = '' )
  gets response body.
  It is written into "dest" using "<<" method.
  If this method is called twice or more, nothing will be done and
  returns first "dest".
d178 6
a183 2
: body {|str| .... }
  gets response body with block.
d186 1
a186 1
= Swithing Net::HTTP versions
d188 2
a189 2
You can use Net::HTTP 1.1 features by calling HTTP.old_implementation.
And calling Net::HTTP.new_implementation allows you to use 1.2 features
d216 3
a218 3
    ###
    ### connection
    ###
d233 1
d243 3
a245 3
    ###
    ### proxy
    ###
d428 1
a428 3
                      @@socket, @@curr_http_version,
                      edit_path(req.path),
                      header_defaults, *args )
d439 1
d446 1
a446 1
      if @@seems_1_0_server then
d449 1
d455 6
a460 2
      if keep_alive? req, req.response then
        if @@socket.closed? then
d465 1
d472 8
a479 26
    def header_defaults
      h = {}
      h['host']       = addr_port
      h['connection'] = 'Keep-Alive'
      h['accept']     = '*/*'
      h
    end

    def keep_alive?( request, response )
      if response.key? 'connection' then
        if /keep-alive/i === response['connection'] then
          return true
        end
      elsif response.key? 'proxy-connection' then
        if /keep-alive/i === response['proxy-connection'] then
          return true
        end
      elsif request.key? 'Connection' then
        if /keep-alive/i === request['Connection'] then
          return true
        end
      else
        if @@curr_http_version == '1.1' then
          return true
        end
      end
d481 1
a484 4
    def addr_port
      address + (port == HTTP.port ? '' : ":#{port}")
    end

d490 2
d505 14
d591 1
a591 1
  ### request
d668 5
a672 1
    def range=( r )
d699 2
d712 1
a712 1
      s and /(?:\A|[^\-\w])chunked(?:[^\-\w]|\z)/i === s
d730 4
d736 8
d760 1
d773 4
d784 3
a786 3
    def exec( sock, ver, path, ihead )
      ready( sock, ihead ) {|header|
        request ver, path, header
d791 1
a791 1
    def ready( sock, ihead )
d794 1
a794 2
      ihead.update @@header
      yield ihead
d796 1
a796 1
      @@sock = nil
d799 1
a799 1
    def request( ver, path, header )
d801 2
a802 2
      header.each do |n,v|
        @@socket.writeline canonical(n) + ': ' + v
d855 1
a855 1
  class HTTPRequestWithData < HTTPRequest
d859 1
a859 1
    def exec( sock, ver, path, ihead, str = nil )
d869 2
d872 2
a873 4
      ready( sock, ihead ) {|header|
        header['Content-Length'] = data.size.to_s
        header.delete 'Transfer-Encoding'
        request ver, path, header
d926 1
a926 1
    class Post < ::Net::NetPrivate::HTTPRequestWithData
d931 1
a931 1
    class Put < ::Net::NetPrivate::HTTPRequestWithData
d1023 1
a1023 3
      unless SuccessCode === self then
        error! self
      end
d1111 1
a1111 3
      if @@socket.closed? then
        raise IOError, 'try to read body out of block'
      end
@


1.49
log
@aamine
* lib/net/http.rb: Response#range_length was not debugged.
@
text
@d29 1
d32 8
d202 1
a408 1
#puts src
d461 3
a463 3
      h['Host']       = addr_port
      h['Connection'] = 'Keep-Alive'
      h['Accept']     = '*/*'
d493 18
d588 131
d721 2
d725 1
a725 1
      @@u_header = tmp = {}
d728 1
a728 1
        key = canonical(k)
a745 28
    def []( key )
      @@u_header[ canonical key ]
    end

    def []=( key, val )
      @@u_header[ canonical key ] = val
    end

    def key?( key )
      @@u_header.key? canonical(key)
    end

    def delete( key )
      @@u_header.delete canonical(key)
    end

    def each( &block )
      @@u_header.each( &block )
    end

    def each_key( &block )
      @@u_header.each_key( &block )
    end

    def each_value( &block )
      @@u_header.each_value( &block )
    end

a748 4
    def canonical( k )
      k.split('-').collect {|i| i.capitalize }.join('-')
    end

d763 1
a763 1
      ihead.update @@u_header
d772 1
a772 1
        @@socket.writeline n + ': ' + v
d813 1
a813 3
      unless m then
        raise HTTPBadResponse, "wrong status line: #{str}"
      end
d918 2
a971 1

a991 32
    def []( key )
      @@header[ key.downcase ]
    end

    def []=( key, val )
      @@header[ key.downcase ] = val
    end

    def each( &block )
      @@header.each( &block )
    end

    def each_key( &block )
      @@header.each_key( &block )
    end

    def each_value( &block )
      @@header.each_value( &block )
    end

    def delete( key )
      @@header.delete key.downcase
    end

    def key?( key )
      @@header.key? key.downcase
    end

    def to_hash
      @@header.dup
    end

d1071 1
a1071 3
        unless m then
          raise HTTPBadResponse, "wrong chunk size line: #{line}"
        end
a1081 31
    def content_length
      if @@header.key? 'content-length' then
        m = /\d+/.match( @@header['content-length'] )
        unless m then
          raise HTTPBadResponse, 'wrong Content-Length format'
        end
        m[0].to_i
      else
        nil
      end
    end

    def chunked?
      tmp = @@header['transfer-encoding']
      tmp and /\bchunked\b/i === tmp
     end

    def range_length
      s = @@header['content-range']
      s or return nil

      m = %r<bytes\s+(\d+)-(\d+)/(?:\d+|\*)>.match( s )
      m or raise HTTPBadResponse, 'wrong Content-Range format'

      low = m[1].to_i
      up  = m[2].to_i
      return nil if low > up

      up - low + 1
    end

d1090 1
a1090 2
        raise ArgumentError,
              'both of arg and block are given for HTTP method'
@


1.48
log
@aamine
* lib/net/http.rb: join HTTPReadResponse into HTTPResponse again.
* lib/net/http.rb: move http_version() from HTTPRequest to HTTPResponse.
* lib/net/protocol.rb: refactoring.
@
text
@d1007 11
a1017 15
      if @@header.key? 'content-range' then
        m = %r<bytes\s+(\d+)-(\d+)/\d+>.match( @@header['content-range'] )
        unless m then
          raise HTTPBadResponse, 'wrong Content-Range format'
        end
        l = m[2].to_i
        u = m[1].to_i
        if l > u then
          nil
        else
          u - l
        end
      else
        nil
      end
d1034 1
a1034 1
        dest or ''
@


1.47
log
@aamine
* lib/net/http.rb: split HTTPResponse into HTTPReadResponse module.
* lib/net/protocol.rb: add Net::net_private.
* lib/net/protocol.rb: Socket#reopen takes arg, open_timeout.
@
text
@a223 5
    def re_connect
      @@socket.reopen @@open_timeout
      on_connect
    end

d436 1
a436 1
      @@curr_http_version = req.http_version
a576 1
      @@http_version = nil
a580 1
    attr_reader :http_version
d629 1
a659 6
  end

  module HTTPReadResponse

    private

d688 1
a688 1
      @@http_version = m[1]
d693 1
a693 1
              status, discrip, @@socket, type::HAS_BODY )
a697 4
  class HTTPRequest
    include ::Net::NetPrivate::HTTPReadResponse
  end

d720 1
d780 1
a780 1
  end   # HTTP::
d792 1
a792 1
    HTTPCODE_CLASS_TO_OBJ = {
d800 1
a800 1
    HTTPCODE_TO_OBJ = {
d845 3
a847 3
    def initialize( status, msg, sock, be )
      code = HTTPCODE_TO_OBJ[status] ||
             HTTPCODE_CLASS_TO_OBJ[status[0,1]] ||
d849 1
a849 1
      super code, status, msg
d852 1
d858 2
@


1.46
log
@aamine
* lib/net/http.rb: Proxy did not work.
@
text
@d224 5
d433 1
a433 2
        @@socket.reopen
        on_connect
a559 2
  class HTTP

d564 2
a584 2
  public

d621 2
a622 1
  private
d643 1
a643 1
      @@response = read_response
d659 4
a662 3
    def read_response
      resp = rdresp0
      resp = rdresp0 while ContinueCode === resp
d666 7
a672 1
    def rdresp0
d707 2
d710 2
d717 1
a717 1
  private
d770 4
d775 4
a778 4
  class Get < HTTPRequest
    HAS_BODY = true
    METHOD = 'GET'
  end
d780 4
a783 4
  class Head < HTTPRequest
    HAS_BODY = false
    METHOD = 'HEAD'
  end
d785 4
a788 4
  class Post < HTTPRequestWithData
    HAS_BODY = true
    METHOD = 'POST'
  end
d790 4
a793 4
  class Put < HTTPRequestWithData
    HAS_BODY = true
    METHOD = 'PUT'
  end
a798 2
  module NetPrivate

d803 2
d1048 1
a1048 1
        ReadAdapter.new block
d1056 1
a1056 2

  end   # module Net::NetPrivate
@


1.45
log
@aamine
* lib/net/http.rb: call on_connect() on re-opening socket.
* lib/net/pop.rb: also POP3 can use APOP auth.
@
text
@d287 1
d290 1
a290 1
            include HTTPProxy
a1033 12
    end

  end


  class Dummy

    def initialize( *args )
    end

    def critical?
      false
@


1.44
log
@aamine
* lib/net/http.rb: add HTTP#request.
* lib/net/http.rb: take HTTP 1.0 server into account (incomplete).
* lib/net/protocol.rb: timeout for open/read.
* lib/net/protocol.rb: add Protocol#on_connect,on_disconnect.
@
text
@d428 1
@


1.43
log
@aamine
* lib/net/protocol.rb: ignore EOFError for read.
* lib/net/http.rb: user specified header was not used.
@
text
@d17 1
a17 1
= class HTTP
d52 1
a52 1
== Methods
a102 11
: new_get( path, header = nil ) {|req| .... }
  creates a new GET request object and gives it to the block.
  see also for Get class reference.

    # example
    http.new_get( '/~foo/bar.html' ) do |req|
      req['accept'] = 'text/html'
      response = req.dispatch
      p response['Content-Type']
      puts response.read_header
    end
d104 5
a108 3
: new_head( path, header = nil ) {|req| .... }
  creates a new HEAD request object and gives it to the block.
  see also Head class reference.
d110 1
a110 3
: new_post( path, header = nil ) {|req| .... }
  creates a new POST request object and gives it to the block.
  see also Post class reference.
d113 1
a113 1
= class Get, Head, Post
d115 2
a116 2
HTTP request class. This class wraps request header and entity path.
All "key" is case-insensitive.
d123 3
a125 7
: dispatch   [only Get, Head]
  dispatches request.
  This method returns HTTPResponse object.

: dispatch( data = '' )        [only Post]
: dispatch {|adapter| .... }   [only Post]
  dispatches request. "data" is 
d127 1
a127 1
= class HTTPResponse
d197 1
a197 1
    protocol_param :port,         '80'
d199 18
a216 1
    HTTPVersion = '1.1'
d218 2
d221 1
a221 2
    def addr_port
      address + (port == HTTP.port ? '' : ":#{port}")
d229 3
d235 1
a235 2
        ::Net::NetPrivate::HTTPProxy.create_proxy_class(
            p_addr, p_port || self.port )
d282 59
a340 3
    ###
    ### for compatibility
    ###
d364 5
a368 3
    ###
    ### http operations
    ###
d370 1
a370 1
    def self.defrequest( nm, hasdest, hasdata )
d374 1
a374 1
      src = <<S
d378 4
a381 3
          resp = #{name}2( path,
                           #{hasdata ? 'data,' : ''}
                           u_header ) {|resp|
d383 1
a383 1
          }
d393 3
a395 9
                      u_header = nil )
          new_#{name}( path, u_header ) do |req|
            resp = req.dispatch#{hasdata ? '(data)' : ''}
            yield resp if block_given?
          end
        end

        def new_#{name}( path, u_header = nil, &block )
          common_oper ::Net::NetPrivate::#{cname}, path, u_header, &block
d397 2
a398 2
S
      # puts src
d402 15
a416 5

    defrequest :Get,  true,  false
    defrequest :Head, false, false
    defrequest :Post, true,  true
    defrequest :Put,  false, true
d422 1
a422 25
    def initialize( addr = nil, port = nil )
      super
      @@command = ::Net::NetPrivate::Switch.new
      @@curr_http_version = HTTPVersion
    end

    def connect( addr = @@address, port = @@port )
      @@socket = type.socket_type.open( addr, port, @@pipe )
    end

    def disconnect
      if @@socket and not @@socket.closed? then
        @@socket.close
      end
      @@socket = nil
    end

    def do_finish
    end


    def common_oper( reqc, path, u_header )
      req = nil

      @@command.on
d425 1
d429 3
d433 2
a434 5
      req = reqc.new( @@curr_http_version,
                      @@socket, inihead,
                      edit_path(path), u_header )
      yield req if block_given?
      req.terminate
d437 6
a442 1
      unless keep_alive? req, req.response then
a444 1
      @@command.off
d449 1
a449 1
    def inihead
d479 2
a480 19
  end

  HTTPSession = HTTP



  module NetPrivate

  class Switch
    def initialize
      @@critical = false
    end

    def critical?
      @@critical
    end

    def on
      @@critical = true
a482 3
    def off
      @@critical = false
    end
d485 1
a485 18
  module HTTPProxy

    class << self

      def create_proxy_class( p_addr, p_port )
        klass = Class.new( HTTP )
        klass.module_eval {
          include HTTPProxy
          @@proxy_address = p_addr
          @@proxy_port    = p_port
        }
        def klass.proxy_class?
          true
        end

        def klass.proxy_address
          @@proxy_address
        end
a486 36
        def klass.proxy_port
          @@proxy_port
        end

        klass
      end

    end


    def initialize( addr, port )
      super
      @@proxy_address = type.proxy_address
      @@proxy_port    = type.proxy_port
    end

    attr_reader :proxy_address, :proxy_port

    alias proxyaddr proxy_address
    alias proxyport proxy_port

    def proxy?
      true
    end
  
    def connect( addr = nil, port = nil )
      super @@proxy_address, @@proxy_port
    end

    def edit_path( path )
      'http://' + addr_port + path
    end
  
  end

  end   # net private
d554 1
a554 2
  module NetPrivate

d562 1
a562 3
    def initialize( httpver, sock, inith, path, uhead )
      @@http_version = httpver
      @@socket = sock
d564 1
a564 3
      @@response = nil

      @@u_header = inith
a565 1
      tmp = {}
d573 4
a576 1
      @@u_header.update tmp
d579 1
a579 1
    attr_reader :http_version
d583 1
d617 1
a617 7

    def terminate
      @@response.terminate
    end


    private
d623 9
d633 5
a637 7
    # write request & header

    def do_dispatch
      if @@response then
        raise IOError, "#{type}\#dispatch called twice"
      end
      yield
d639 1
d642 3
a644 3
    def request( req )
      @@socket.writeline req
      @@u_header.each do |n,v|
d650 3
a652 1
    # read response & header
d664 2
a665 1
        line = @@socket.readline
d669 1
a669 3
        unless m then
          raise HTTPBadResponse, 'wrong header line format'
        end
d684 1
a684 1
      m = /\AHTTP\/(\d+\.\d+)?\s+(\d\d\d)\s*(.*)\z/i.match( str )
d692 2
a693 1
      HTTPResponse.new( status, discrip, @@socket, type::HAS_BODY )
a697 1
  class Get < HTTPRequest
d699 1
a699 19
    HAS_BODY = true

    def dispatch
      do_dispatch {
        request sprintf('GET %s HTTP/%s', @@path, @@http_version)
      }
    end

  end

  class Head < HTTPRequest

    HAS_BODY = false

    def dispatch
      do_dispatch {
        request sprintf('HEAD %s HTTP/%s', @@path, @@http_version)
      }
    end
d701 1
a701 1
  end
d703 1
a703 3
  class HTTPRequestWithData < HTTPRequest

    def dispatch( str = nil )
d708 1
a708 1
        yield ac              # must be yield, not block.call
d714 4
a717 4
      do_dispatch {
        @@u_header['Content-Length'] = data.size.to_s
        @@u_header.delete 'Transfer-Encoding'
        request sprintf('%s %s HTTP/%s', type::METHOD, @@path, @@http_version)
a732 15
  class Post < HTTPRequestWithData

    HAS_BODY = true

    METHOD = 'POST'
  
  end

  class Put < HTTPRequestWithData

    HAS_BODY = true

    METHOD = 'PUT'
  
  end
d755 25
d896 1
d898 1
d907 1
a907 1

d909 1
d936 3
a938 1
    # internal use only
a942 4

    private


d949 1
a949 1
          @@socket.read clen, dest
d1032 12
@


1.42
log
@aamine
* lib/net/protocol.rb (adding): too few "yield" in case of arg is not String/File.
* lib/net/http.rb: add http request object.
@
text
@a599 1
          tmp[ key ] = v.strip
d601 1
@


1.41
log
@aamine
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: wrongly version 1.2 sources
  were checked in.
@
text
@d3 1
a3 1
= net/http.rb version 1.1.32
d5 2
a6 2
maintained by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
This file is derived from "http-access.rb".
d8 7
a14 7
This program is free software.
You can distribute/modify this program under
the terms of the Ruby Distribute License.

Japanese version of this document is in "net" full package.
You can get it from RAA
(Ruby Application Archive: http://www.ruby-lang.org/en/raa.html).
d58 2
a59 2
  When this method is called with block, gives a HTTP object to block
  and close HTTP session after returning from the block.
d72 1
a72 1
  get data from "path" on connecting host.
d74 2
a75 2
  Data is written to "dest" by using "<<" method.
  This method returns Net::HTTPResponse object, and "dest".
d78 1
a78 1
    response, body = http.get( '/index.html' )
a81 13
  Note:
  If status is not 2xx(success), ProtocolError exception is
  raised. At that time, you can get HTTPResponse object from 
  exception object. (same in head/post)

    # example
    begin
      response, body = http.get( '/index.html' )
    rescue Net::ProtoRetriableError => err
      response = err.data
      ...
    end

d95 1
a95 1
  posts "data" (must be String now) to "path".
d97 1
a97 1
  Data is written to "dest" by using "<<" method.
d99 1
a99 1
  This method returns Net::HTTPResponse object and "dest".
d103 3
a105 6
: get2( path, header = nil )
: get2( path, header = nil ) {|recv| .... }
  send GET request for "path".
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
  If this method is called with block, one gives
  a HTTPResponseReceiver object to block.
d108 5
a112 4
    http.get2( '/index.html' ) do |recv|
      # "recv" is a HTTPResponseReceiver object
      recv.header
      recv.body
d115 3
a117 4
    # another way
    response = http.get2( '/index.html' )
    response['content-type']
    response.body
d119 3
a121 4
    # this is wrong
    http.get2( '/index.html' ) do |recv|
      print recv.response.body   # body is not read yet!!!
    end
a122 5
    # but this is ok
    http.get2( '/index.html' ) do |recv|
      recv.body                  # read body and set recv.response.body
      print recv.response.body   # ref
    end
d124 1
a124 6
: head2( path, header = nil )
: head2( path, header = nil ) {|recv| .... }
  send HEAD request for "path".
  "header" must be a Hash like { 'Accept' => 'text/html', ... }.
  The difference between "head" method is that
  "head2" does not raise exceptions.
d126 2
a127 2
  If this method is called with block, one gives
  a HTTPResponseReceiver object to block.
d129 1
a129 2
    # example
    response = http.head2( '/index.html' )
d131 2
a132 23
    # another way
    http.head2( '/index.html' ) do |recv|
      recv.response
    end

: post2( path, data, header = nil )
: post2( path, data, header = nil ) {|recv| .... }
  posts "data" (must be String now) to "path".
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
  If this method is called with block, one gives
  a HTTPResponseReceiver object to block.

    # example
    http.post2( '/anycgi.rb', 'data data data...' ) do |recv|
      # "recv" is a HTTPResponseReceiver object
      recv.header
      recv.body
    end

    # another way
    response = http.post2( '/anycgi.rb', 'important data' )
    response['content-type']
    response.body
d134 7
d144 1
a144 1
HTTP response object.
d173 1
a173 9

= class HTTPResponseReceiver

== Methods

: header
: response
  Net::HTTPResponse object

d175 4
a178 2
: entity( dest = '' )
  entity body. A body is written to "dest" using "<<" method.
d180 3
a182 4
: body {|str| ... }
  gets entity body with block.
  If this method is called twice, block is not executed and
  returns first "dest".
d185 1
a185 1
= http.rb version 1.2 features
d187 3
a189 2
You can use 1.2 features by calling HTTP.version_1_2. And
calling Net::HTTP.version_1_1 allows to use 1.1 features.
d192 1
a192 4
  HTTP.start {|http1| ...(http1 has 1.1 features)... }

  HTTP.version_1_2
  HTTP.start {|http2| ...(http2 has 1.2 features)... }
d195 1
a195 1
  HTTP.start {|http3| ...(http3 has 1.1 features)... }
d197 2
a198 15
== Method (only diff to 1.1)

: get( path, u_header = nil )
: get( path, u_header = nil ) {|str| .... }
  gets document from "path".
  returns HTTPResponse object.

: head( path, u_header = nil )
  gets only document header from "path".
  returns HTTPResponse object.

: post( path, data, u_header = nil )
: post( path, data, u_header = nil ) {|str| .... }
  posts "data" to "path" entity and gets document.
  returns HTTPResponse object.
d213 7
a219 1
    protocol_param :command_type, '::Net::NetPrivate::HTTPCommand'
d238 1
a238 1
        setimplv i
d278 1
a278 1
    ### 1.2 implementation
d281 1
a281 1
    @@@@newimpl = false
d283 1
a283 1
    #class << self
d285 1
a285 1
      def self.version_1_2
d289 1
a289 1
      def self.version_1_1
d293 1
a293 1
      #private
d295 1
a295 1
      def self.setimplv( obj )
d300 1
a300 1
    #end
d307 35
a341 8
    def get( path, u_header = nil, dest = nil, &block )
      resp = get2( path, u_header ) {|f| f.body( dest, &block ) }
      if @@newimpl then
        resp
      else
        resp.value
        return resp, resp.body
      end
a343 5
    def get2( path, u_header = nil, &block )
      common_oper( u_header, true, block ) {|uh|
        @@command.get edit_path(path), uh
      }
    end
d345 4
a349 7
    def head( path, u_header = nil )
      resp = head2( path, u_header )
      unless @@newimpl then
        resp.value
      end
      resp
    end
d351 1
a351 5
    def head2( path, u_header = nil, &block )
      common_oper( u_header, false, block ) {|uh|
        @@command.head edit_path(path), uh
      }
    end
d354 4
a357 8
    def post( path, data, u_header = nil, dest = nil, &block )
      resp = post2( path, data, u_header ) {|f| f.body( dest, &block ) }
      if @@newimpl then
        resp
      else
        resp.value
        return resp, resp.body
      end
d360 2
a361 4
    def post2( path, data, u_header = nil, &block )
      common_oper( u_header, true, block ) {|uh|
        @@command.post edit_path(path), uh, data
      }
d364 3
a366 9

    # not tested because I could not setup apache  (__;;;
    def put( path, src, u_header = nil )
      resp = put2( path, src, u_header ) {|f| f.body }
      if @@newimpl then
        resp
      else
        resp.value
        return resp, resp.body
d368 1
d371 1
a371 4
    def put2( path, src, u_header = nil, &block )
      common_oper( u_header, true, block ) {|uh|
        @@command.put path, uh, src
      }
d375 2
a376 23
    private


    def common_oper( u_header, body_exist, block )
      header = procheader( u_header )
      recv = err = nil

      connecting( header ) {
        recv = HTTPResponseReceiver.new( @@command, body_exist )
        yield header
        begin
          block.call recv if block
        rescue Exception => err
          ;
        end
        recv.terminate

        recv.response
      }
      raise err if err

      recv.response
    end
d378 1
a378 1
    def connecting( header )
a379 1
        header['Connection'] = 'close'
d385 6
a390 1
      resp = yield
d392 1
a392 1
      unless keep_alive? header, resp then
d395 11
d408 3
a410 3
    def keep_alive?( header, resp )
      if resp.key? 'connection' then
        if /keep-alive/i === resp['connection'] then
d413 2
a414 2
      elsif resp.key? 'proxy-connection' then
        if /keep-alive/i === resp['proxy-connection'] then
d417 2
a418 2
      elsif header.key? 'Connection' then
        if /keep-alive/i === header['Connection'] then
d422 1
a422 1
        if @@command.http_version == '1.1' then
d430 5
a434 6
    def procheader( h )
      ret = {}
      ret[ 'Host' ]       = address +
                            ((port == HTTP.port) ? '' : ":#{port}")
      ret[ 'Connection' ] = 'Keep-Alive'
      ret[ 'Accept' ]     = '*/*'
d436 1
a436 10
      return ret unless h
      tmp = {}
      h.each do |k,v|
        key = k.split('-').collect {|i| i.capitalize }.join('-')
        if tmp[key] then
          $stderr.puts "'#{key}' http header appered twice" if $VERBOSE
        end
        tmp[key] = v
      end
      ret.update tmp
d438 3
a440 1
      ret
d443 3
d447 2
a448 1
    def do_finish
d451 3
a455 5
  HTTPSession = HTTP


  module NetPrivate

d505 1
a505 1
      'http://' + address + (port == type.port ? '' : ":#{port}") + path
a512 133

  class HTTPResponseReceiver

    def initialize( command, body_exist )
      @@command = command
      @@body_exist = body_exist
      @@header = @@body = nil
    end

    def inspect
      "#<#{type}>"
    end

    def read_header
      unless @@header then
        stream_check
        @@header = @@command.get_response
      end
      @@header
    end

    alias header read_header
    alias response read_header

    def read_body( dest = nil, &block )
      unless @@body then
        read_header

        to = procdest( dest, block )
        stream_check

        if @@body_exist and @@header.code_type.body_exist? then
          @@command.get_body @@header, to
          @@header.body = @@body = to
        else
          @@command.no_body
          @@header.body = nil
          @@body = 1
        end
      end
      @@body == 1 ? nil : @@body
    end

    alias body read_body
    alias entity read_body

    def terminate
      read_header
      read_body
      @@command = nil
    end


    private

    def stream_check
      unless @@command then
        raise IOError, 'receiver was used out of block'
      end
    end

    def procdest( dest, block )
      if dest and block then
        raise ArgumentError,
          'both of arg and block are given for HTTP method'
      end
      if block then
        NetPrivate::ReadAdapter.new block
      else
        dest or ''
      end
    end

  end

  HTTPReadAdapter = HTTPResponseReceiver


  class HTTPResponse < Response

    def initialize( code_type, code, msg )
      super
      @@data = {}
      @@body = nil
    end

    attr_accessor :body

    def inspect
      "#<#{type.name} #{code}>"
    end

    def []( key )
      @@data[ key.downcase ]
    end

    def []=( key, val )
      @@data[ key.downcase ] = val
    end

    def each( &block )
      @@data.each( &block )
    end

    def each_key( &block )
      @@data.each_key( &block )
    end

    def each_value( &block )
      @@data.each_value( &block )
    end

    def delete( key )
      @@data.delete key.downcase
    end

    def key?( key )
      @@data.key? key.downcase
    end

    def to_hash
      @@data.dup
    end

    def value
      unless SuccessCode === self then
        error! self
      end
    end

  end


d577 1
d581 11
a591 1
  class HTTPCommand < Command
d593 11
a603 5
    HTTPVersion = '1.1'

    def initialize( sock )
      @@http_version = HTTPVersion
      super sock
d608 3
d612 1
a612 1
      "#<Net::HTTPCommand>"
d615 3
d619 3
a621 3
    ###
    ### request
    ###
d623 3
a625 1
    public
d627 2
a628 3
    def get( path, u_header )
      return unless begin_critical
      request sprintf('GET %s HTTP/%s', path, HTTPVersion), u_header
d630 3
a632 4
      
    def head( path, u_header )
      return unless begin_critical
      request sprintf('HEAD %s HTTP/%s', path, HTTPVersion), u_header
d635 2
a636 5
    def post( path, u_header, data )
      return unless begin_critical
      u_header[ 'Content-Length' ] = data.size.to_s
      request sprintf('POST %s HTTP/%s', path, HTTPVersion), u_header
      @@socket.write data
d639 2
a640 4
    def put( path, u_header, src )
      return unless begin_critical
      request sprintf('PUT %s HTTP/%s', path, HTTPVersion), u_header
      @@socket.write_bin src
a642 1
    # def delete
d644 4
a647 1
    # def trace
d649 1
a649 1
    # def options
d651 2
a652 1
    def quit
d656 9
a664 1
    private
d666 1
a666 1
    def request( req, u_header )
d668 1
a668 1
      u_header.each do |n,v|
d674 1
d676 3
a678 9
    ###
    ### response line & header
    ###

    public

    def get_response
      resp = get_resp0
      resp = get_resp0 while ContinueCode === resp
d682 2
a683 5

    private

    def get_resp0
      resp = get_reply
d705 1
a705 1
    def get_reply
d715 93
a807 4
      code = HTTPCODE_TO_OBJ[status] ||
             HTTPCODE_CLASS_TO_OBJ[status[0,1]] ||
             UnknownCode
      HTTPResponse.new( code, status, discrip )
d809 10
d873 100
a972 3
    ###
    ### body
    ###
a973 1
    public
d975 2
a976 2
    def get_body( resp, dest )
      if chunked? resp then
d979 1
a979 1
        clen = content_length( resp )
d983 1
a983 1
          clen = range_length( resp )
a990 5
      end_critical
    end

    def no_body
      end_critical
a992 3

    private

d1013 3
a1015 3
    def content_length( resp )
      if resp.key? 'content-length' then
        m = /\d+/.match( resp['content-length'] )
d1025 3
a1027 3
    def chunked?( resp )
      tmp = resp['transfer-encoding']
      tmp and /(?:\A|\s+)chunked(?:\s+|\z)/i === tmp
d1030 3
a1032 3
    def range_length( resp )
      if resp.key? 'content-range' then
        m = %r<bytes\s+(\d+)-(\d+)/\d+>.match( resp['content-range'] )
d1045 18
@


1.41.2.1
log
@aamine
* lib/net/protocol.rb: ignore EOFError on only specified case.
* lib/net/http.rb: take HTTP 1.0 server into account.
@
text
@a434 8
    def do_start
      @@seems_1_0 = false
    end

    def do_finish
    end


a462 3
      if @@seems_1_0 then
        header['Connection'] = 'close'
      end
d466 1
a466 6
      if keep_alive? header, resp then
        if @@socket.closed? then
          @@seems_1_0 = true
          @@socket.close
        end
      else
d514 4
d867 1
a867 2
        line = @@socket.readuntil( "\n", true )   # ignore EOF
        line.sub!( /\s+\z/, '' )                 # don't use chop!
d967 1
a967 1
          @@socket.read clen, dest, true
@


1.41.2.2
log
@aamine
* lib/net/http.rb: supports HTTP 1.0 server.
@
text
@d3 1
a3 1
= net/http.rb version 1.1.33
a476 3
      if @@command.http_version == '1.0' then
        @@seems_1_0 = true
      end
@


1.41.2.3
log
@aamine
* lib/net/protocol.rb: clear read buffer after reopen.
* lib/net/http.rb: update RD document.
@
text
@d17 1
a17 1
== http.rb version 1.2 features
d19 1
a19 26
You can use 1.2 features by calling HTTP.version_1_2. And
calling Net::HTTP.version_1_1 allows to use 1.1 features.

  # example
  HTTP.start {|http1| ...(http1 has 1.1 features)... }

  HTTP.version_1_2
  HTTP.start {|http2| ...(http2 has 1.2 features)... }

  HTTP.version_1_1
  HTTP.start {|http3| ...(http3 has 1.1 features)... }

Changes are:

  * HTTP#get, head, post does not raise ProtocolError
  * HTTP#get, head, post returns only one object, a HTTPResponse object
  * HTTPResponseReceiver is joined into HTTPResponse
  * request object: HTTP::Get, Head, Post; and HTTP#request(req)

WARNING: These features are not definite yet.
They will change without notice!


== class HTTP

=== Class Methods
d52 1
a52 1
=== Methods
d184 1
a184 1
== class HTTPResponse
d189 1
a189 1
=== Methods
d192 1
a192 1
  the entity body (String).
d197 2
a198 2
  '2045'(for Content-Length), 'bytes 0-1023/10024'(for Content-Range).
  If there's some fields which has same name, they are joined with ','.
d207 1
a207 1
  iterates for each field name and value pair.
d210 1
a210 1
  HTTP result code string. For example, '302'.
d213 1
a213 1
  HTTP result message. For example, 'Not Found'.
d216 1
a216 1
== class HTTPResponseReceiver
d218 1
a218 1
=== Methods
d224 3
a226 7
: read_body( dest = '' )
  reads entity body into DEST by calling "<<" method and
  returns DEST.

: read_body {|string| ... }
  reads entity body little by little and gives it to block
  until entity ends.
d228 21
a248 4
: body
: entity
  entity body. If #read_body is called already, returns its
  argument DEST. Else returns entity body as String.
d250 13
a262 2
  Calling this method any times causes returning same
  object (does not read entity again).
@


1.41.2.4
log
@aamine
* lib/net/http.rb: keep-alive detection was incomplete.
@
text
@d477 1
d481 1
a481 2

      unless keep_alive? resp then
a483 1
        else
d486 2
d491 18
a508 8
    def keep_alive?( resp )
      /close/i === resp['connection'].to_s            and return false
      /close/i === resp['proxy-connection'].to_s      and return false
      @@seems_1_0                                      and return false

      /keep-alive/i === resp['connection'].to_s       and return true
      /keep-alive/i === resp['proxy-connection'].to_s and return true
      @@command.http_version == '1.1'                  and return true
d515 3
a517 1
      ret[ 'Host' ]       = address + ((port == HTTP.port) ? '' : ":#{port}")
@


1.41.2.5
log
@aamine
* lib/net/http.rb: always close connection if body is not exist.
@
text
@d448 1
a448 1
      connecting( header, body_exist ) {
d458 1
a458 1
        recv
d465 1
a465 1
    def connecting( header, body_exist )
d472 1
a472 1
      if not body_exist or @@seems_1_0 then
d476 1
a476 1
      recv = yield
d481 1
a481 4
      if not recv.body then
        # close connection always (for corrupted server)
        @@socket.close
      elsif not keep_alive? header, recv.response then
d490 1
a490 1
    def keep_alive?( header, resp )
a492 1
      /close/i === header['connection'].to_s          and return false
d641 3
a643 1
      @@command or raise IOError, 'receiver was used out of block'
d648 2
a649 1
        raise ArgumentError, 'both of arg and block are given for HTTP method'
@


1.41.2.6
log
@aamine
* lib/net/protocol.rb: use net 1.2 for also ruby 1.6 branch.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@d3 1
a3 3
= net/http.rb version 1.1.34

written by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d5 1
d100 1
a100 1
  This method returns HTTPResponse object, and "dest".
d123 1
a123 1
  This method returns a HTTPResponse object.
d137 1
a137 1
  This method returns HTTPResponse object and "dest".
d247 1
a247 1
  HTTPResponse object
a272 1
  class HTTPHeaderSyntaxError < StandardError; end
d277 2
a278 11
    HTTPVersion = '1.1'

    #
    # connection
    #

    protocol_param :port, '80'


    def initialize( addr = nil, port = nil )
      super
a279 22
      @@proxy_address = nil
      @@proxy_port = nil

      @@curr_http_version = HTTPVersion
      @@seems_1_0_server = false
    end


    private

    def conn_command( sock )
    end

    def do_finish
    end


    #
    # proxy
    #

    public
d281 3
d288 2
a289 1
        ProxyMod.create_proxy_class( p_addr, p_port || self.port )
d297 1
a297 1
        setvar i
d336 3
a338 1
    module ProxyMod
d340 1
a340 1
      class << self
d342 1
a342 11
        def create_proxy_class( p_addr, p_port )
          mod = self
          klass = Class.new( HTTP )
          klass.module_eval {
            include mod
            @@proxy_address = p_addr
            @@proxy_port    = p_port
          }
          def klass.proxy_class?
            true
          end
d344 3
a346 3
          def klass.proxy_address
            @@proxy_address
          end
d348 3
a350 3
          def klass.proxy_port
            @@proxy_port
          end
d352 1
a352 2
          klass
        end
d354 3
d359 2
a360 7
      def initialize( addr, port )
        super
        @@proxy_address = type.proxy_address
        @@proxy_port    = type.proxy_port
      end
    
      attr_reader :proxy_address, :proxy_port
d362 3
a364 2
      alias proxyaddr proxy_address
      alias proxyport proxy_port
d366 7
a372 8
      def proxy?
        true
      end
    
      private
    
      def conn_socket( addr, port )
        super @@proxy_address, @@proxy_port
d374 1
d376 5
a380 5
      def edit_path( path )
        'http://' + addr_port + path
      end
    
    end   # module ProxyMod
d383 7
a389 3
    #
    # for backward compatibility
    #
d391 5
a395 1
    @@@@newimpl = false
a396 1
    class << self
d398 7
a404 2
      def version_1_2
        @@@@newimpl = true
d406 1
d408 5
a412 3
      def version_1_1
        @@@@newimpl = false
      end
a413 1
      private
d415 8
a422 3
      def setvar( obj )
        f = @@@@newimpl
        obj.instance_eval { @@newimpl = f }
d424 1
d426 4
d433 1
a433 3
    #
    # http operations
    #
a434 1
    public
d436 3
a438 21
    def self.def_http_method( nm, hasdest, hasdata )
      name = nm.id2name.downcase
      cname = nm.id2name
      lineno = __LINE__ + 2
      src = <<"      ----"

        def #{name}( path, #{hasdata ? 'data,' : ''}
                     u_header = nil #{hasdest ? ',dest = nil, &block' : ''} )
          resp = nil
          request(
              #{cname}.new( path, u_header ) #{hasdata ? ',data' : ''}
          ) do |resp|
            resp.read_body( #{hasdest ? 'dest, &block' : ''} )
          end
          if @@newimpl then
            resp
          else
            resp.value
            #{hasdest ? 'return resp, resp.body' : 'resp'}
          end
        end
d440 1
a440 7
        def #{name}2( path, #{hasdata ? 'data,' : ''}
                      u_header = nil, &block )
          request( #{cname}.new(path, u_header),
                   #{hasdata ? 'data,' : ''} &block )
        end
      ----
      module_eval src, __FILE__, lineno
a442 13
    def_http_method :Get,  true,  false
    def_http_method :Head, false, false
    def_http_method :Post, true,  true
    def_http_method :Put,  false, true

    def request( req, *args )
      common_oper( req ) {
        req.__send__( :exec,
                @@socket, @@curr_http_version, edit_path(req.path), *args )
        yield req.response if block_given?
      }
      req.response
    end
d444 13
d458 3
a460 1
    private
d462 2
d465 1
a465 2
    def common_oper( req )
      req['connection'] ||= 'keep-alive'
d467 1
a468 1
        req['connection'] = 'close'
d470 1
a470 1
        re_connect
d472 2
a473 2
      if not req.body_exist? or @@seems_1_0_server then
        req['connection'] = 'close'
a474 1
      req['host'] = addr_port
d476 4
a479 3
      yield req
      req.response.__send__ :terminate
      @@curr_http_version = req.response.http_version
d481 2
a482 1
      if not req.response.body then
d484 4
a487 5
      elsif keep_alive? req, req.response then
        D 'Conn keep-alive'
        if @@socket.closed? then   # (only) read stream had been closed
          D 'Conn (but seems 1.0 server)'
          @@seems_1_0_server = true
a489 3
      else
        D 'Conn close'
        @@socket.close
d491 68
d560 5
a564 1
      req.response
d567 21
a587 3
    def keep_alive?( req, res )
      /close/i === req['connection'].to_s            and return false
      @@seems_1_0_server                              and return false
a588 4
      /keep-alive/i === res['connection'].to_s       and return true
      /close/i      === res['connection'].to_s       and return false
      /keep-alive/i === res['proxy-connection'].to_s and return true
      /close/i      === res['proxy-connection'].to_s and return false
d590 18
a607 2
      @@curr_http_version == '1.1'                    and return true
      false
d610 2
d613 3
a615 3
    #
    # utils
    #
d617 2
a618 1
    public
d620 10
a629 7
    def self.get( addr, path, port = nil )
      req = Get.new( path )
      resp = nil
      new( addr, port || HTTP.port ).start {|http|
        resp = http.request( req )
      }
      resp.body
d632 7
a638 2
    def self.get_print( addr, path, port = nil )
      print get( addr, path, port )
d644 2
a645 2
    def addr_port
      address + (port == HTTP.port ? '' : ":#{port}")
d648 8
a655 4
    def D( msg )
      if @@dout then
        @@dout << msg
        @@dout << "\n"
d661 54
a714 1
  HTTPSession = HTTP
d716 1
d783 1
a784 3
  ###
  ### header
  ###
d786 1
a786 1
  net_private {
d788 1
a788 1
  module HTTPHeader
d790 3
a792 2
    def size
      @@header.size
d795 1
a795 1
    alias length size
d797 2
a798 2
    def []( key )
      @@header[ key.downcase ]
a800 3
    def []=( key, val )
      @@header[ key.downcase ] = val
    end
d802 3
a804 3
    def each( &block )
      @@header.each( &block )
    end
d806 1
a806 3
    def each_key( &block )
      @@header.each_key( &block )
    end
d808 3
a810 2
    def each_value( &block )
      @@header.each_value( &block )
d812 4
a815 3

    def delete( key )
      @@header.delete key.downcase
d818 5
a822 2
    def key?( key )
      @@header.key? key.downcase
d825 4
a828 2
    def to_hash
      @@header.dup
d831 1
a831 5
    def canonical_each
      @@header.each do |k,v|
        yield canonical(k), v
      end
    end
d833 1
a833 3
    def canonical( k )
      k.split('-').collect {|i| i.capitalize }.join('-')
    end
d835 1
a835 3
    def range
      s = @@header['range']
      s or return nil
d837 2
a838 4
      arr = []
      s.split(',').each do |spec|
        m = /bytes\s*=\s*(\d+)?\s*-\s*(\d+)?/i.match( spec )
        m or raise HTTPHeaderSyntaxError, "wrong Range: #{spec}"
a839 9
        d1 = m[1].to_i
        d2 = m[2].to_i
        if    m[1] and m[2] then arr.push d1 .. d2
        elsif m[1]          then arr.push d1 .. -1
        elsif          m[2] then arr.push -d2 .. -1
        else
          raise HTTPHeaderSyntaxError, 'range is not specified'
        end
      end
d841 1
a841 2
      return *arr
    end
d843 4
a846 25
    def range=( r, fin = nil )
      if fin then
        r = r ... r+fin
      end

      case r
      when Numeric
        s = r > 0 ? "0-#{r - 1}" : "-#{-r}"
      when Range
        first = r.first
        last = r.last
        if r.exclude_end? then
          last -= 1
        end

        if last == -1 then
          s = first > 0 ? "#{first}-" : "-#{-first}"
        else
          first >= 0 or raise HTTPHeaderSyntaxError, 'range.first is negative' 
          last > 0  or raise HTTPHeaderSyntaxError, 'range.last is negative' 
          first < last or raise HTTPHeaderSyntaxError, 'must be .first < .last'
          s = "#{first}-#{last}"
        end
      else
        raise TypeError, 'Range/Integer is required'
d848 1
a848 3

      @@header['range'] = "bytes=#{s}"
      r
a850 1
    alias set_range range=
d852 3
a854 3
    def content_length
      s = @@header['content-length']
      s or return nil
d856 1
a856 4
      m = /\d+/.match(s)
      m or raise HTTPHeaderSyntaxError, 'wrong Content-Length format'
      m[0].to_i
    end
d858 4
a861 65
    def chunked?
      s = @@header['transfer-encoding']
      (s and /(?:\A|[^\-\w])chunked(?:[^\-\w]|\z)/i === s) ? true : false
    end

    def content_range
      s = @@header['content-range']
      s or return nil

      m = %r<bytes\s+(\d+)-(\d+)/(?:\d+|\*)>i.match( s )
      m or raise HTTPHeaderSyntaxError, 'wrong Content-Range format'

      m[1].to_i .. m[2].to_i + 1
    end

    def range_length
      r = content_range
      r and r.length
    end

    def basic_auth( acc, pass )
      @@header['authorization'] = ["#{acc}:#{pass}"].pack('m').gsub(/\s+/, '')
    end

  end

  }


  ###
  ### request
  ###

  net_private {

  class HTTPRequest

    include ::Net::NetPrivate::HTTPHeader

    def initialize( path, uhead = nil )
      @@path = path
      @@header = tmp = {}
      return unless uhead
      uhead.each do |k,v|
        key = k.downcase
        if tmp.key? key then
          $stderr.puts "WARNING: duplicated HTTP header: #{k}" if $VERBOSE
        end
        tmp[ key ] = v.strip
      end
      tmp['accept'] ||= '*/*'

      @@socket = nil
      @@response = nil
    end

    attr_reader :path
    attr_reader :response

    def inspect
      "\#<#{type}>"
    end

    def body_exist?
      type::HAS_BODY
d867 2
a868 40
    #
    # write
    #

    def exec( sock, ver, path )
      ready( sock ) {
        request ver, path
      }
      @@response
    end

    def ready( sock )
      @@response = nil
      @@socket = sock
      yield
      @@response = get_response
      @@socket = nil
    end

    def request( ver, path )
      @@socket.writeline sprintf('%s %s HTTP/%s', type::METHOD, path, ver)
      canonical_each do |k,v|
        @@socket.writeline k + ': ' + v
      end
      @@socket.writeline ''
    end

    #
    # read
    #

    def get_response
      begin
        resp = read_response
      end while ContinueCode === resp
      resp
    end

    def read_response
      resp = get_resline
d876 3
a878 1
        m or raise HTTPBadResponse, 'wrong header line format'
d891 1
a891 1
    def get_resline
d893 5
a897 3
      m = /\AHTTP(?:\/(\d+\.\d+))?\s+(\d\d\d)\s*(.*)\z/i.match( str )
      m or raise HTTPBadResponse, "wrong status line: #{str}"
      httpver = m[1]
d901 4
a904 29
      ::Net::NetPrivate::HTTPResponse.new(
              status, discrip, @@socket, type::HAS_BODY, httpver )
    end
  
  end


  class HTTPRequestWithBody < HTTPRequest
  
    private

    def exec( sock, ver, path, str = nil )
      check_arg str, block_given?

      if block_given? then
        ac = Accumulator.new
        yield ac              # must be yield, DO NOT USE block.call
        data = ac.terminate
      else
        data = str
      end
      @@header['content-length'] = data.size.to_s
      @@header.delete 'transfer-encoding'

      ready( sock ) {
        request ver, path
        @@socket.write data
      }
      @@response
d907 1
a907 72
    def check_arg( data, blkp )
      if data and blkp then
        raise ArgumentError, 'both of data and block given'
      end
      unless data or blkp then
        raise ArgumentError, 'str or block required'
      end
    end
  
  end


  class Accumulator
  
    def initialize
      @@buf = ''
    end

    def write( s )
      @@buf.concat s
    end

    alias << write

    def terminate
      ret = @@buf
      @@buf = nil
      ret
    end
  
  end

  }


  class HTTP

    class Get < ::Net::NetPrivate::HTTPRequest
      HAS_BODY = true
      METHOD = 'GET'
    end

    class Head < ::Net::NetPrivate::HTTPRequest
      HAS_BODY = false
      METHOD = 'HEAD'
    end

    class Post < ::Net::NetPrivate::HTTPRequestWithBody
      HAS_BODY = true
      METHOD = 'POST'
    end

    class Put < ::Net::NetPrivate::HTTPRequestWithBody
      HAS_BODY = true
      METHOD = 'PUT'
    end

  end



  ###
  ### response
  ###

  net_private {

  class HTTPResponse < Response

    include ::Net::NetPrivate::HTTPHeader

    CODE_CLASS_TO_OBJ = {
d915 1
a915 1
    CODE_TO_OBJ = {
a958 15
    def initialize( stat, msg, sock, be, hv )
      code = CODE_TO_OBJ[stat] ||
             CODE_CLASS_TO_OBJ[stat[0,1]] ||
             UnknownCode
      super code, stat, msg
      @@socket = sock
      @@body_exist = be
      @@http_version = hv

      @@header = {}
      @@body = nil
      @@read = false
    end

    attr_reader :http_version
d960 3
a962 3
    def inspect
      "#<#{type} #{code}>"
    end
d964 1
a964 15
    def value
      SuccessCode === self or error! self
    end


    #
    # header (for backward compatibility)
    #

    def read_header
      self
    end

    alias header read_header
    alias response read_header
d966 2
a967 38
    #
    # body
    #

    def read_body( dest = nil, &block )
      if @@read and (dest or block) then
        raise IOError, "#{type}\#read_body called twice with argument"
      end

      unless @@read then
        to = procdest( dest, block )
        stream_check

        if @@body_exist and code_type.body_exist? then
          read_body_0 to
          @@body = to
        else
          @@body = nil
        end
        @@read = true
      end

      @@body
    end

    alias body read_body
    alias entity read_body


    private


    def terminate
      read_body
    end

    def read_body_0( dest )
      if chunked? then
d970 1
a970 1
        clen = content_length
d972 1
a972 1
          @@socket.read clen, dest, true   # ignore EOF
d974 1
a974 1
          clen = range_length
d982 1
d985 7
d999 3
a1001 1
        m or raise HTTPBadResponse, "wrong chunk size line: #{line}"
d1012 10
a1021 2
    def stream_check
      @@socket.closed? and raise IOError, 'try to read body out of block'
d1024 18
a1041 6
    def procdest( dest, block )
      if dest and block then
        raise ArgumentError, 'both of arg and block are given for HTTP method'
      end
      if block then
        ::Net::NetPrivate::ReadAdapter.new block
d1043 1
a1043 1
        dest || ''
a1048 2
  }

d1050 1
a1050 2
  HTTPResponse         = NetPrivate::HTTPResponse
  HTTPResponseReceiver = NetPrivate::HTTPResponse
@


1.41.2.7
log
@aamine
* lib/net/http.rb: add HTTPRequest#basic_auth.
* lib/net/smtp.rb: raise if only account or password is given.
* lib/net/protocol.rb: WriteAdapter#<< returns self.
@
text
@d722 3
a724 3
        if    m[1] and m[2] then arr.push (d1 .. d2)
        elsif m[1]          then arr.push (d1 .. -1)
        elsif          m[2] then arr.push (-d2 .. -1)
d796 1
a796 2
      @@header['authorization'] =
              'Basic ' + ["#{acc}:#{pass}"].pack('m').gsub(/\s+/, '')
@


1.41.2.8
log
@aamine
* lib/net/pop.rb: new methods POP3.auth_only, POP3#auth_only
* lib/net/http.rb: HTTP.Proxy returns self if ADDRESS is nil.
* lib/net/protocol.rb: new method ProtocolError#response
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: add document.
@
text
@d3 1
a3 1
= net/http.rb version 1.1.35
d5 1
a5 1
Copyright (c) 1999-2001 Yukihiro Matsumoto
a6 1
written & maintained by Minero Aoki <aamine@@loveruby.net>
d9 3
a11 3
This program is free software. You can re-distribute and/or
modify this program under the same terms as Ruby itself,
Ruby Distribute License or GNU General Public License.
d13 3
a15 3
NOTE: You can get Japanese version of this document from
Ruby Documentation Project (RDP):
((<URL:http://www.ruby-lang.org/~rubikitch/RDP.cgi>))
a16 1
== What is this module?
d18 1
a18 4
This module provide your program the functions to access WWW
documents via HTTP, Hyper Text Transfer Protocol version 1.1.
For details of HTTP, refer [RFC2616]
((<URL:http://www.ietf.org/rfc/rfc2616.txt>)).
d20 2
a21 1
== Examples
d23 2
a24 1
=== Getting Document From Server
d26 2
a27 2
Be care to ',' (comma) putted after "response".
This is required for feature compatibility.
d29 2
a30 78
    require 'net/http'
    Net::HTTP.start( 'some.www.server', 80 ) {|http|
      response , = http.get('/index.html')
      puts response.body
    }

(shorter version)

    require 'net/http'
    Net::HTTP.get_print 'some.www.server', '/index.html'

=== Posting Form Data

    require 'net/http'
    Net::HTTP.start( 'some.www.server', 80 ) {|http|
      response , = http.post( '/cgi-bin/any.rhtml',
                              'querytype=subject&target=ruby' )
    }

=== Accessing via Proxy

Net::HTTP.Proxy() creates http proxy class. It has same
methods of Net::HTTP but its instances always connect to
proxy, instead of given host.

    require 'net/http'

    $proxy_addr = 'your.proxy.addr'
    $proxy_port = 8080
          :
    Net::HTTP::Proxy($proxy_addr, $proxy_port).start( 'some.www.server' ) {|http|
      # always connect to your.proxy.addr:8080
          :
    }

Since Net::HTTP.Proxy() returns Net::HTTP itself when $proxy_addr is nil,
there's no need to change code if there's proxy or not.

=== Redirect

    require 'net/http'
    Net::HTTP.version_1_1

    host = 'www.ruby-lang.org'
    begin
      Net::HTTP.start( host, 80 ) {|http|
        response , = http.get('/')
      }
    rescue Net::ProtoRetriableError => err
      if m = %r<http:([^/]+)>.match( err.response['location'] ) then
        host = m[1].strip
        retry
      end
    end

NOTE: This code is using ad-hoc way to extract host name, but in future
URI class will be included in ruby standard library.

=== Basic Authentication

    require 'net/http'

    Net::HTTP.start( 'auth.some.domain' ) {|http|
      response , = http.get( '/need-auth.cgi',
              'Authentication' => ["#{account}:#{password}"].pack('m').strip )
      print response.body
    }

In version 1.2 (Ruby 1.7 or later), you can write like this:

    require 'net/http'

    req = Net::HTTP::Get.new('/need-auth.cgi')
    req.basic_auth 'account', 'password'
    Net::HTTP.start( 'auth.some.domain' ) {|http|
      response = http.request( req )
      print response.body
    }
d32 1
a32 1
== Switching Net::HTTP versions
d34 4
a37 3
You can use old Net::HTTP (in Ruby 1.6) features by calling
HTTP.version_1_1. And calling Net::HTTP.version_1_2 allows
you to use 1.2 features again.
d39 2
a40 5
    # example
    Net::HTTP.start {|http1| ...(http1 has 1.2 features)... }

    Net::HTTP.version_1_1
    Net::HTTP.start {|http2| ...(http2 has 1.1 features)... }
a41 2
    Net::HTTP.version_1_2
    Net::HTTP.start {|http3| ...(http3 has 1.2 features)... }
d43 1
a43 3
Yes, this is not thread-safe.

== class Net::HTTP
d48 3
a50 3
    creates a new Net::HTTP object.
    If proxy_addr is given, this method is equals to
    Net::HTTP::Proxy(proxy_addr,proxy_port).
d54 2
a55 1
    is equals to
d57 4
a60 1
        Net::HTTP.new(address, port, proxy_addr, proxy_port).start(&block)
d62 7
a68 22
: get( address, path, port = 80 )
    gets entity body from path and returns it.
    return value is a String.

: get_print( address, path, port = 80 )
    gets entity body from path and print it.
    return value is an entity body (a String).

: Proxy( address, port = 80 )
    creates a HTTP proxy class.
    Arguments are address/port of proxy host.
    You can replace HTTP class by this proxy class.

    If ADDRESS is nil, this method returns self (Net::HTTP class).

        # example
        proxy_class = Net::HTTP::Proxy( 'proxy.foo.org', 8080 )
          :
        proxy_class.start( 'www.ruby-lang.org' ) do |http|
          # connecting proxy.foo.org:8080
          :
        end
d71 2
a72 2
    If self is HTTP, false.
    If self is a class which was created by HTTP::Proxy(), true.
d75 2
a76 1
    HTTP default port (80).
d78 1
a78 1
=== Instance Methods
d82 1
a82 1
    creates a new Net::HTTP object and starts HTTP session.
d84 2
a85 27
    When this method is called with block, gives a HTTP object to block
    and close the HTTP session after block call finished.

: active?
    true if HTTP session is started.

: address
    the address to connect

: port
    the port number to connect

: open_timeout
: open_timeout=(n)
    seconds to wait until connection is opened.
    If HTTP object cannot open a conection in this seconds,
    it raises TimeoutError exception.

: read_timeout
: read_timeout=(n)
    seconds to wait until reading one block (by one read(1) call).
    If HTTP object cannot open a conection in this seconds,
    it raises TimeoutError exception.

: finish
    finishes HTTP session.
    If HTTP session had not started, do nothing and return false.
d88 1
a88 1
    true if self is a HTTP proxy class
d91 1
a91 1
    address of proxy host. If self is not a proxy, nil.
d94 1
a94 1
    port number of proxy host. If self is not a proxy, nil.
d98 22
a119 33
    gets data from "path" on connecting host.
    "header" must be a Hash like { 'Accept' => '*/*', ... }.
    Response body is written into "dest" by using "<<" method.
    This method returns Net::HTTPResponse object.

    If called with block, give a part String of entity body.

    In version 1.1, this method might raises exception for also
    3xx (redirect). On the case you can get response object by
    err.response.

    In version 1.2, this method never raises exception.

        # version 1.1 (Ruby 1.6)
        response, body = http.get( '/index.html' )

        # version 1.2 (Ruby 1.7 or later)
        response = http.get( '/index.html' )

        # compatible in both version
        response , = http.get( '/index.html' )
        response.body
        
        # using block
        File.open( 'save.txt', 'w' ) {|f|
          http.get( '/~foo/', nil ) do |str|
            f.write str
          end
        }
        # some effect
        File.open( 'save.txt', 'w' ) {|f|
          http.get '/~foo/', nil, f
        }
d122 9
a130 13
    gets only header from "path" on connecting host.
    "header" is a Hash like { 'Accept' => '*/*', ... }.
    This method returns a Net::HTTPResponse object.
    You can http header from this object like:

        response = nil
        Net::HTTP.start( 'some.www.server', 80 ) {|http|
          response = http.head( '/index.html' )
        }
        response['content-length']   #-> '2554'
        response['content-type']     #-> 'text/html'
        response['Content-Type']     #-> 'text/html'
        response['CoNtEnT-tYpe']     #-> 'text/html'
d134 14
a147 31
    posts "data" (must be String) to "path".
    If the body exists, also gets entity body.
    Response body is written into "dest" by using "<<" method.
    "header" must be a Hash like { 'Accept' => '*/*', ... }.
    This method returns Net::HTTPResponse object.

    If called with block, gives a part of entity body string.

        # version 1.1
        response, body = http.post( '/index.html', 'querytype=subject&target=ruby' )
        # version 1.2
        response = http.post( '/index.html', 'querytype=subject&target=ruby' )
        # compatible for both version
        response , = http.post( '/index.html', 'querytype=subject&target=ruby' )

        # using block
        File.open( 'save.html', 'w' ) {|f|
          http.post( '/index.html', 'querytype=subject&target=ruby' ) do |str|
            f.write str
          end
        }
        # same effect
        File.open( 'save.html', 'w' ) {|f|
          http.post '/index.html', 'querytype=subject&target=ruby', nil, f
        }

: request( request, [data] )
: request( request, [src] ) {|response| .... }
    sends REQUEST to (remote) http server. This method also writes
    string from DATA string if REQUEST is a post/put request.
    (giving DATA for get/head request causes ArgumentError.)
d149 6
a154 1
    If called with block, gives a HTTPResponse object to the block.
d156 4
a159 1
== class Net::HTTP::Get, Head, Post
d161 4
a164 2
HTTP request classes. These classes wraps request header and
entity path. All arguments named "key" is case-insensitive.
d166 5
a170 1
=== Class Methods
d172 6
a177 2
: new
    creats HTTP request object.
d179 2
a180 1
=== Instance Methods
d182 2
a183 3
: self[ key ]
    returns the header field corresponding to the case-insensitive key.
    For example, a key of "Content-Type" might return "text/html"
d185 4
a188 2
: self[ key ] = val
    sets the header field corresponding to the case-insensitive key.
d190 6
a195 2
: each {|name, val| .... }
    iterates for each field name and value pair.
d197 6
a202 2
: basic_auth( account, password )
    set Authorization: header for basic auth.
d204 4
a207 2
: range
    returns a Range object which represents Range: header field.
a208 4
: range = r
: set_range( i, len )
    set Range: header from Range (arg r) or beginning index and
    length from it (arg i&len).
d210 1
a210 2
: content_length
    returns a Integer object which represents Content-Length: header field.
d212 2
a213 2
: content_range
    returns a Range object which represents Content-Range: header field.
d215 1
a215 1
== class Net::HTTPResponse
d217 2
a218 4
HTTP response class. This class wraps response header and entity.
All arguments named KEY is case-insensitive.

=== Instance Methods
d221 4
a224 5
    returns the header field corresponding to the case-insensitive key.
    For example, a key of "Content-Type" might return "text/html".
    A key of "Content-Length" might do "2045".

    More than one fields which has same names are joined with ','.
d227 1
a227 1
    sets the header field corresponding to the case-insensitive key.
d230 1
a230 2
    true if key exists.
    KEY is case insensitive.
d233 1
a233 4
    iterates for each field name and value pair.

: canonical_each {|name,value| .... }
    iterates for each "canonical" field name and value pair.
d236 1
a236 1
    HTTP result code string. For example, '302'.
d239 10
a248 1
    HTTP result message. For example, 'Not Found'.
d251 2
a252 3
    gets entity body and write it into DEST using "<<" method.
    If this method is called twice or more, nothing will be done
    and returns first DEST.
d254 3
a256 2
: read_body {|str| .... }
    gets entity body little by little and pass it to block.
d259 3
a261 2
    response body. If #read_body has been called, this method returns
    arg of #read_body DEST. Else gets body as String and returns it.
d263 2
d287 1
d291 3
d298 1
d318 1
a318 5
        if p_addr then
          ProxyMod.create_proxy_class( p_addr, p_port || self.port )
        else
          self
        end
d334 3
a336 3
      @@is_proxy_class = false
      @@proxy_addr = nil
      @@proxy_port = nil
d338 2
a339 2
      def proxy_class?
        @@is_proxy_class
d342 3
a344 2
      attr_reader :proxy_address
      attr_reader :proxy_port
d349 1
a349 1
      type.proxy?
d353 1
a353 1
      type.proxy_address
d357 1
a357 1
      type.proxy_port
a359 3
    alias proxyaddr proxy_address
    alias proxyport proxy_port

d367 25
a391 10
      def self.create_proxy_class( p_addr, p_port )
        mod = self
        klass = Class.new( HTTP )
        klass.module_eval {
          include mod
          @@is_proxy = true
          @@proxy_address = p_addr
          @@proxy_port    = p_port
        }
        klass
d394 15
d412 1
a412 1
        super proxy_address, proxy_port
d426 1
a426 5
    if Version < '1.2.0' then   ###noupdate
      @@@@newimpl = false
    else
      @@@@newimpl = true
    end
a437 4
      def is_version_1_2?
        @@@@newimpl
      end

d567 1
a567 4
      new( addr, port || HTTP.port ).start {|http|
        http.get path, nil, $stdout
      }
      nil
d722 3
a724 3
        if    m[1] and m[2] then arr.push  d1..d2
        elsif m[1]          then arr.push  d1..-1
        elsif          m[2] then arr.push -d2..-1
d730 1
a730 1
      return arr
d796 2
a797 1
      @@header['authorization'] = 'Basic ' + ["#{acc}:#{pass}"].pack('m').strip
d967 1
a967 4
    def <<( s )
      @@buf.concat s
      self
    end
d1089 1
a1089 1
      SuccessCode === self or error!
d1097 1
a1097 1
    def response
d1101 2
a1102 2
    alias header response
    alias read_header response
@


1.41.2.9
log
@* smtp.rb, pop.rb, http.rb: modify document.
@
text
@d30 1
a30 1
This is required for compatibility.
a75 1
    path = '/'
d78 1
a78 2
	response , = http.get(path)
        print response.body
d81 3
a83 4
      if m = %r<http://([^/]+)>.match( err.response['location'] ) then
	host = m[1].strip
	path = m.post_match
	retry
d134 2
a135 1
    If proxy_addr is given, creates an Net::HTTP object with proxy support.
d148 2
a149 1
    gets entity body from path and output it to $stdout.
d154 1
a154 1
    You can replace HTTP class with created proxy class.
d156 1
a156 1
    If ADDRESS is nil, this method returns self (Net::HTTP).
d171 1
a171 1
    default HTTP port (80).
d211 1
a211 1
    address of proxy host. If self does not use a proxy, nil.
d214 1
a214 1
    port number of proxy host. If self does not use a proxy, nil.
d218 3
a220 4
    gets data from PATH on the connecting host.
    HEADER must be a Hash like { 'Accept' => '*/*', ... }.
    Response body is written into DEST by using "<<" method.

d223 1
a223 2
    If called with block, gives entity body little by little
    to the block (as String).
d226 2
a227 2
    3xx (redirect). On the case you can get a HTTPResponse object
    by "anException.response".
d231 1
a231 1
        # version 1.1 (bundled with Ruby 1.6)
d234 1
a234 1
        # version 1.2 (bundled with Ruby 1.7 or later)
d247 1
a247 1
        # same effect
d253 2
a254 3
    gets only header from PATH on the connecting host.
    HEADER is a Hash like { 'Accept' => '*/*', ... }.

d256 1
a256 4

    In version 1.1, this method might raises exception for also
    3xx (redirect). On the case you can get a HTTPResponse object
    by "anException.response".
a276 4
    In version 1.1, this method might raises exception for also
    3xx (redirect). On the case you can get a HTTPResponse object
    by "anException.response".

d295 5
a299 6
: request( request [, data] )
: request( request [, data] ) {|response| .... }
    sends a HTTPRequest object REQUEST to (remote) http server.
    This method also writes string from DATA string if REQUEST is
    a post/put request. Giving DATA for get/head request causes
    ArgumentError.
d301 1
a301 2
    If called with block, gives a HTTPResponse object to the block
    with connecting server.
@


1.41.2.10
log
@aamine
* lib/net/protocol.rb (ProtoSocket#read): modify typo.
@
text
@d3 1
a3 1
= net/http.rb version 1.1.36
d206 1
a206 1
    If HTTP session had not started, raises an IOError.
d269 4
a272 1
        p response['content-type']
d289 1
a289 1
        response, body = http.post( '/cgi-bin/search.rb', 'querytype=subject&target=ruby' )
d291 1
a291 1
        response = http.post( '/cgi-bin/search.rb', 'querytype=subject&target=ruby' )
d293 1
a293 1
        response , = http.post( '/cgi-bin/search.rb', 'querytype=subject&target=ruby' )
d297 1
a297 1
          http.post( '/cgi-bin/search.rb', 'querytype=subject&target=ruby' ) do |str|
d303 1
a303 1
          http.post '/cgi-bin/search.rb', 'querytype=subject&target=ruby', nil, f
d306 6
a311 3
: get2( path, header = nil )
: get2( path, header = nil ) {|response| .... }
    gets entity from PATH. This method returns a HTTPResponse object.
d313 2
a314 2
    When called with block, keep connection while block is executed
    and gives a HTTPResponse object to the block.
d316 1
a316 1
    This method never raise any ProtocolErrors.
d318 16
a333 4
        # example
        response = http.get2( '/index.html' )
        p response['content-type']
        puts response.body          # body is already read
d335 2
a336 7
        # using block
        http.get2( '/index.html' ) {|response|
          p response['content-type']
          response.read_body do |str|   # read body now
            print str
          end
        }
d338 2
a339 3
: post2( path, header = nil )
: post2( path, header = nil ) {|response| .... }
    posts data to PATH. This method returns a HTTPResponse object.
d341 2
a342 2
    When called with block, gives a HTTPResponse object to the block
    before reading entity body, with keeping connection.
d344 4
a347 4
        # example
        response = http.post2( '/cgi-bin/nice.rb', 'datadatadata...' )
        p response.status
        puts response.body          # body is already read
d349 2
a350 8
        # using block
        http.post2( '/cgi-bin/nice.rb', 'datadatadata...' ) {|response|
          p response.status
          p response['content-type']
          response.read_body do |str|   # read body now
            print str
          end
        }
d352 2
d400 1
d568 1
a568 1
    def self.define_http_method_interface( nm, hasdest, hasdata )
d599 4
a602 4
    define_http_method_interface :Get,  true,  false
    define_http_method_interface :Head, false, false
    define_http_method_interface :Post, true,  true
    define_http_method_interface :Put,  false, true
d604 2
a605 2
    def request( req, body = nil )
      connecting( req ) {
d607 1
a607 1
                @@socket, @@curr_http_version, edit_path(req.path), body )
a612 7
    def send_request( name, path, body = nil, header = nil )
      r = ::Net::NetPrivate::HTTPGenericRequest.new(
              name, (body ? true : false), true,
              path, header )
      request r, body
    end

d617 2
a618 6
    def connecting( req )
      unless active? then
        implicit = true
        req['connection'] ||= 'close'
      end

d621 1
d628 1
a628 1
      req['host'] = addr_port()
d648 1
a648 3
      if implicit then
        finish
      end
d839 3
a841 3
        if    m[1] and m[2] then arr.push(  d1..d2 )
        elsif m[1]          then arr.push(  d1..-1 )
        elsif          m[2] then arr.push( -d2..-1 )
d918 2
d925 3
a927 1
  class HTTPGenericRequest
d931 1
a931 4
    def initialize( m, reqbody, resbody, path, uhead = nil )
      @@method = m
      @@request_has_body = reqbody
      @@response_has_body = resbody
a932 2
      @@response = nil

d943 3
a947 1
    attr_reader :method
d955 2
a956 2
    def request_body_permitted?
      @@request_has_body
a958 6
    def response_body_permitted?
      @@response_has_body
    end

    alias body_exist? response_body_permitted?

d966 19
a984 8
    def exec( sock, ver, path, body, &block )
      if body then
        check_body_premitted
        check_arg_b body, block
        sendreq_with_body sock, ver, path, body, &block
      else
        check_arg_n body
        sendreq_no_body sock, ver, path
d986 1
a986 2
      @@response = r = get_response( sock )
      r
d989 9
a997 3
    def check_body_premitted
      request_body_permitted? or
          raise ArgumentError, 'HTTP request body is not premitted'
d1000 17
a1016 6
    def check_arg_b( data, block )
      if data and block then
        raise ArgumentError, 'both of data and block given'
      end
      unless data or block then
        raise ArgumentError, 'str or block required'
d1018 2
d1022 10
a1031 2
    def check_arg_n( data )
      data and raise ArgumentError, "data is not permitted for #{@@method}"
d1033 3
d1037 3
d1041 2
a1042 3
    def sendreq_no_body( sock, ver, path )
      request sock, ver, path
    end
a1043 1
    def sendreq_with_body( sock, ver, path, body )
d1049 1
a1049 1
        data = body
d1054 5
a1058 2
      request sock, ver, path
      sock.write data
d1061 6
a1066 4
    def request( sock, ver, path )
      sock.writeline sprintf('%s %s HTTP/%s', @@method, path, ver)
      canonical_each do |k,v|
        sock.writeline k + ': ' + v
a1067 13
      sock.writeline ''
    end

    #
    # read
    #

    def get_response( sock )
      begin
        resp = ::Net::NetPrivate::HTTPResponse.new_from_socket(sock,
                                                response_body_permitted?)
      end while ContinueCode === resp
      resp
a1072 12
  class HTTPRequest < HTTPGenericRequest

    def initialize( path, uhead = nil )
      super type::METHOD,
            type::REQUEST_HAS_BODY,
            type::RESPONSE_HAS_BODY,
            path, uhead
    end

  end


d1102 1
a1103 2
      REQUEST_HAS_BODY  = false
      RESPONSE_HAS_BODY = true
d1107 1
a1108 2
      REQUEST_HAS_BODY = false
      RESPONSE_HAS_BODY = false
d1111 2
a1112 1
    class Post < ::Net::NetPrivate::HTTPRequest
a1113 2
      REQUEST_HAS_BODY = true
      RESPONSE_HAS_BODY = true
d1116 2
a1117 1
    class Put < ::Net::NetPrivate::HTTPRequest
a1118 2
      REQUEST_HAS_BODY = true
      RESPONSE_HAS_BODY = true
a1185 39


    class << self

      def new_from_socket( sock, hasbody )
        resp = readnew( sock, hasbody )

        while true do
          line = sock.readuntil( "\n", true )   # ignore EOF
          line.sub!( /\s+\z/, '' )                 # don't use chop!
          break if line.empty?

          m = /\A([^:]+):\s*/.match( line )
          m or raise HTTPBadResponse, 'wrong header line format'
          nm = m[1]
          line = m.post_match
          if resp.key? nm then
            resp[nm] << ', ' << line
          else
            resp[nm] = line
          end
        end

        resp
      end

      private

      def readnew( sock, hasbody )
        str = sock.readline
        m = /\AHTTP(?:\/(\d+\.\d+))?\s+(\d\d\d)\s*(.*)\z/in.match( str )
        m or raise HTTPBadResponse, "wrong status line: #{str}"
        discard, httpv, stat, desc = *m.to_a
        
        new( stat, desc, sock, hasbody, httpv )
      end

    end

@


1.41.2.11
log
@aamine
* lib/net/http.rb: HTTP#proxy? did not worked.
@
text
@d473 1
a473 1
      type.proxy_class?
d499 1
a499 1
          @@is_proxy_class = true
@


1.41.2.12
log
@aamine
* lib/net/smtp.rb: SMTP.new requires at least one arg.
* lib/net/pop.rb: POP.new requires at least one arg.
* lib/net/pop.rb: uses "raise *Error.new" instead of simple raise.
* lib/net/http.rb: HTTP.new requires at least one arg.
* lib/net/http.rb: changes implicit start algolithm.
@
text
@d14 3
a16 2
NOTE: You can find Japanese version of this document in
the doc/net directory of the standard ruby interpreter package.
d135 1
a135 1
: new( address, port = 80, proxy_addr = nil, proxy_port = nil )
d139 2
a140 2
: start( address, port = 80, proxy_addr = nil, proxy_port = nil )
: start( address, port = 80, proxy_addr = nil, proxy_port = nil ) {|http| .... }
d413 1
a413 1
    def initialize( addr, port = nil )
d448 1
a448 1
      def new( address, port = nil, p_addr = nil, p_port = nil )
d455 1
a455 1
      def start( address, port = nil, p_addr = nil, p_port = nil, &block )
a595 7
      unless active? then
        start {
          req['connection'] = 'close'
          return request(req, body)
        }
      end
        
d616 8
a623 1
      if @@socket.closed? then
d647 4
@


1.41.2.13
log
@aamine
* lib/net/smtp.rb: uses Digest::MD5 instead of MD5 (again).
* lib/net/pop.rb: ditto.
* lib/net/http.rb (HTTP#request): must pass block.
@
text
@d3 1
a3 1
= net/http.rb version 1.1.37
d594 1
a594 1
    def request( req, body = nil, &block )
d598 1
a598 1
          return request(req, body, &block)
@


1.41.2.14
log
@aamine
* lib/net/protocol.rb: calls on_connect before conn_command
@
text
@d46 2
a47 2
        response , = http.post( '/cgi-bin/any.rhtml',
                                'querytype=subject&target=ruby' )
d97 3
a99 3
        response , = http.get( '/need-auth.cgi',
                'Authentication' => ["#{account}:#{password}"].pack('m').strip )
        print response.body
d109 2
a110 2
        response = http.request(req)
        print response.body
d160 5
a164 5
                        :
        proxy_class.start( 'www.ruby-lang.org' ) {|http|
            # connecting proxy.foo.org:8080
                        :
        }
d245 3
a247 3
            http.get( '/~foo/', nil ) do |str|
              f.write str
            end
d251 1
a251 1
            http.get '/~foo/', nil, f
d266 1
a266 1
            response = http.head( '/index.html' )
d293 3
a295 3
            http.post( '/cgi-bin/search.rb', 'querytype=subject&target=ruby' ) do |str|
              f.write str
            end
d299 1
a299 1
            http.post '/cgi-bin/search.rb', 'querytype=subject&target=ruby', nil, f
d318 4
a321 4
            p response['content-type']
            response.read_body do |str|   # read body now
              print str
            end
d338 5
a342 5
            p response.status
            p response['content-type']
            response.read_body do |str|   # read body now
              print str
	    end
@


1.41.2.15
log
@aamine
* lib/net/protocol.rb: Protocol#start returns the return value of block.
* lib/net/protocol.rb: set timeout limit by default.
* lib/net/protocol.rb: new methods WriteAdapter#write, puts, print, printf.
* lib/net/protocol.rb: change template method scheme.
* lib/net/http.rb: rename HTTP#get2 to request_get, post2 to request_post ...
* lib/net/pop.rb: POP#auth_only did not work.
* lib/net/smtp.rb: should not resolve HELO domain automatically.
@
text
@d3 1
a3 1
= net/http.rb
a16 2
$Id: header.rd,v 1.2 2001/12/10 12:37:16 aamine Exp $

d216 1
a216 1
: get( path, header = nil )
d220 1
d222 1
a222 4
    In version 1.1, this method returns a pair of objects,
    a Net::HTTPResponse object and entity body string.
    In version 1.2, this method returns a Net::HTTPResponse
    object.
d224 2
a225 2
    If called with block, gives entity body string to the block
    little by little.
d230 1
d249 4
a262 1
    In version 1.2, this method never raises exception.
d270 1
a270 1
: post( path, data, header = nil )
d272 5
a276 6
    posts DATA (must be String) to PATH. HEADER must be a Hash
    like { 'Accept' => '*/*', ... }.

    In version 1.1, this method returns a pair of objects, a
    Net::HTTPResponse object and an entity body string.
    In version 1.2, this method returns a Net::HTTPReponse object.
a282 1
    In version 1.2, this method never raises exception.
d285 1
a285 2
        response, body = http.post( '/cgi-bin/search.rb', 'query=subject&target=ruby' )

d287 3
a289 4
        response = http.post( '/cgi-bin/search.rb', 'query=subject&target=ruby' )

        # compatible in both version
        response , = http.post( '/cgi-bin/search.rb', 'query=subject&target=ruby' )
d293 1
a293 2
            http.post( '/cgi-bin/search.rb',
                       'query=subject&target=ruby' ) do |str|
d297 4
d302 2
a303 2
: request_get( path, header = nil )
: request_get( path, header = nil ) {|response| .... }
d309 1
a309 1
    This method never raises Net::* exceptions.
d312 1
a312 1
        response = http.request_get( '/index.html' )
d317 1
a317 1
        http.request_get( '/index.html' ) {|response|
d324 2
a325 2
: request_post( path, data, header = nil )
: request_post( path, data, header = nil ) {|response| .... }
a330 2
    This method never raises Net::* exceptions.

d414 1
d421 1
a421 2
    def do_start
      conn_socket
a424 22
      disconn_socket
    end


    #
    # short cut methods
    #

    def HTTP.get( addr, path, port = nil )
      req = Get.new( path )
      resp = nil
      new( addr, port || HTTP.port ).start {|http|
          resp = http.request( req )
      }
      resp.body
    end

    def HTTP.get_print( addr, path, port = nil )
      new( addr, port || HTTP.port ).start {|http|
          http.get path, nil, $stdout
      }
      nil
d434 1
d450 1
a450 1
        setimplversion i
d497 4
a500 4
            include mod
            @@is_proxy_class = true
            @@proxy_address = p_addr
            @@proxy_port    = p_port
d507 2
a508 6
      def conn_address
        proxy_address()
      end

      def conn_port
        proxy_port()
d512 1
a512 1
        'http://' + addr_port() + path
d544 1
a544 1
      def setimplversion( obj )
d558 21
a578 9
    def get( path, initheader = nil, dest = nil, &block )
      res = nil
      request( Get.new(path,initheader) ) {|res|
          res.read_body dest, &block
      }
      unless @@newimpl then
        res.value
        return res, res.body
      end
d580 7
a586 30
      res
    end

    def head( path, initheader = nil )
      res = request( Head.new(path,initheader) )
      @@newimpl or res.value
      res
    end

    def post( path, data, initheader = nil, dest = nil, &block )
      res = nil
      request( Post.new(path,initheader), data ) {|res|
          res.read_body dest, &block
      }
      unless @@newimpl then
        res.value
        return res, res.body
      end

      res
    end

    def put( path, data, initheader = nil )
      res = request( Put.new(path,initheader), data )
      @@newimpl or res.value
      res
    end

    def request_get( path, initheader = nil, &block )
      request Get.new(path,initheader), &block
d589 4
a592 22
    def request_head( path, initheader = nil, &block )
      request Head.new(path,initheader), &block
    end

    def request_post( path, data, initheader = nil, &block )
      request Post.new(path,initheader), data, &block
    end

    def request_put( path, data, initheader = nil, &block )
      request Put.new(path,initheader), data, &block
    end

    alias get2   request_get
    alias head2  request_head
    alias post2  request_post
    alias put2   request_put

    def send_request( name, path, body = nil, header = nil )
      r = HTTPGenericRequest.new( name, (body ? true : false), true,
                                  path, header )
      request r, body
    end
d597 2
a598 2
            req['connection'] = 'close'
            return request(req, body, &block)
d603 3
a605 3
          req.__send__( :exec,
                  @@socket, @@curr_http_version, edit_path(req.path), body )
          yield req.response if block_given?
d610 8
d620 1
d623 1
a623 1
        reconn_socket
d667 19
d701 2
d774 2
d792 1
a792 1
    def each_header( &block )
a795 2
    alias each each_header

d849 3
a851 1
      r = (r ... r + fin) if fin
d923 1
a923 1
    include HTTPHeader
d925 1
a925 1
    def initialize( m, reqbody, resbody, path, initheader = nil )
d933 2
a934 2
      return unless initheader
      initheader.each do |k,v|
d978 1
a978 1
      @@response = r = get_response(sock)
d988 6
a993 2
      (data and block) and raise ArgumentError, 'both of data and block given'
      (data or block) or raise ArgumentError, 'str or block required'
a1015 5
      unless @@header['content-type'] then
        $stderr.puts 'Content-Type did not set; using application/x-www-form-urlencoded' if $VERBOSE
        @@header['content-type'] = 'application/x-www-form-urlencoded'
      end

d1034 2
a1035 1
        resp = HTTPResponse.new_from_socket(sock, response_body_permitted?)
d1045 1
a1045 1
    def initialize( path, initheader = nil )
d1049 1
a1049 1
            path, initheader
d1078 2
d1083 1
a1083 1
    class Get < HTTPRequest
d1089 1
a1089 1
    class Head < HTTPRequest
d1095 1
a1095 1
    class Post < HTTPRequest
d1101 1
a1101 1
    class Put < HTTPRequest
d1115 2
d1119 1
a1119 1
    include HTTPHeader
d1181 1
a1181 1
          line.sub!( /\s+\z/, '' )              # don't use chop!
d1253 2
a1254 4
      if @@read then
        (dest or block) and
                raise IOError, "#{type}\#read_body called twice with argument"
        return @@body
d1257 11
a1267 8
      to = procdest(dest, block)
      stream_check

      if @@body_exist and code_type.body_exist? then
        read_body_0 to
        @@body = to
      else
        @@body = nil
a1268 1
      @@read = true
d1276 1
d1279 1
d1308 1
a1308 1
        m = /[0-9a-fA-F]+/.match(line)
d1312 1
a1312 1
        @@socket.read len, dest; total += len
d1329 1
a1329 1
        ReadAdapter.new block
d1337 1
a1338 1
  # for backward compatibility
d1340 2
a1341 10
  HTTPSession = HTTP

  module NetPrivate
    HTTPResponse         = ::Net::HTTPResponse
    HTTPGenericRequest   = ::Net::HTTPGenericRequest
    HTTPRequest          = ::Net::HTTPRequest
    Accumulator          = ::Net::Accumulator
    HTTPHeader           = ::Net::HTTPHeader
  end
  HTTPResponceReceiver = HTTPResponse
@


1.41.2.16
log
@aamine
* lib/net/http.rb: HTTP.Proxy should use self for proxy-class's super class.
* lib/net/http.rb: initialize HTTP.proxy_port by HTTP.port.
@
text
@d407 2
d410 1
a410 1
    # constructors
d413 1
a413 15
    class << self

      def start( address, port = nil, p_addr = nil, p_port = nil, &block )
        new( address, port, p_addr, p_port ).start( &block )
      end

      alias newobj new

      def new( address, port = nil, p_addr = nil, p_port = nil )
        obj = Proxy(p_addr, p_port).newobj(address, port)
        setimplversion obj
        obj
      end

    end
a420 9

    #
    # connection
    #

    protocol_param :port, '80'

    HTTPVersion = '1.1'

d460 1
d462 6
a467 1
        p_addr or return self
d469 11
a479 10
        p_port ||= port()
        mod = ProxyDelta
        proxyclass = Class.new(self)
        proxyclass.module_eval {
            include mod
            @@is_proxy_class = true
            @@proxy_address = p_addr
            @@proxy_port    = p_port
        }
        proxyclass
d492 1
d510 3
a512 3
    private

    # without proxy
a513 3
    def conn_address
      address
    end
d515 1
a515 3
    def conn_port
      port
    end
d517 11
a527 3
    def edit_path( path )
      path
    end
a528 1
    module ProxyDelta
a529 2

      # with proxy
d532 1
a532 1
        proxy_address
d536 1
a536 1
        proxy_port
d542 2
a543 1
    end
@


1.41.2.17
log
@aamine
* lib/net/http.rb: remove unused class Accumulator.
* lib/net/http.rb: read response in HTTP#request. not HTTPRequest#exec.
* lib/net/http.rb: proxy related class instance variables are not initialized correctly.
* doc/net/http.rb: modify typo in the description of basic auth.
@
text
@d5 1
a5 1
Copyright (c) 1999-2002 Yukihiro Matsumoto
d17 1
a17 1
$Id: header.rd,v 1.2.2.1 2002/02/19 13:15:22 aamine Exp $
d30 3
a33 1
    Net::HTTP.version_1_1   # declear to use 1.1 features.
d35 2
a36 2
        response, body = http.get('/index.html')
        print body
a46 1
    Net::HTTP.version_1_1   # declear to use 1.1 features.
d48 1
a48 1
        response, body = http.post( '/cgi-bin/any.rhtml',
a58 1
    Net::HTTP.version_1_1   # declear to use 1.1 features.
d64 1
a64 1
        # always connect to your.proxy.addr:8080
d74 1
a74 1
    Net::HTTP.version_1_1   # declear to use 1.1 features.
a96 1
    Net::HTTP.version_1_1   # declear to use 1.1 features.
d99 3
a101 3
        response, body = http.get( '/need-auth.cgi',
                'Authorization' => 'Basic ' + ["#{account}:#{password}"].pack('m').strip )
        print body
a106 1
    Net::HTTP.version_1_2   # declear to use 1.2 features.
d130 1
a130 1
This function is not thread-safe.
a406 56
    HTTPVersion = '1.1'

    protocol_param :port, '80'


    #
    # for backward compatibility
    #

    @@@@newimpl = false

    class << self

      def version_1_2
        @@@@newimpl = true
      end

      def version_1_1
        @@@@newimpl = false
      end

      def is_version_1_2?
        @@@@newimpl
      end

      private

      def setimplversion( obj )
        f = @@@@newimpl
        obj.instance_eval { @@newimpl = f }
      end

    end


    #
    # short cut methods
    #

    def HTTP.get( addr, path, port = nil )
      req = Get.new( path )
      resp = nil
      new( addr, port || HTTP.port ).start {|http|
          resp = http.request( req )
      }
      resp.body
    end

    def HTTP.get_print( addr, path, port = nil )
      new( addr, port || HTTP.port ).start {|http|
          http.get path, nil, $stdout
      }
      nil
    end


d438 4
d454 21
a479 5
    # without proxy
    @@is_proxy_class = false
    @@proxy_addr = nil
    @@proxy_port = nil

a488 1
            # with proxy
d496 4
d559 34
d671 6
a676 10
      begin_transport(req)
          req.__send__(:exec,
                       @@socket, @@curr_http_version, edit_path(req.path), body)
          begin
            res = HTTPResponse.read_new(@@socket, req.response_body_permitted?)
          end while ContinueCode === res
          yield res if block_given?
      end_transport(req, res)

      res
d681 1
a681 1
    def begin_transport( req )
a688 1
    end
d690 3
a692 3
    def end_transport( req, res )
      res.__send__ :terminate
      @@curr_http_version = res.http_version
d694 1
a694 1
      if not res.body then
d696 1
a696 1
      elsif keep_alive? req, res then
a741 1
  HTTPSession = HTTP
d1006 1
a1006 1
    def exec( sock, ver, path, body )
d1008 3
a1010 3
        raise ArgumentError, 'HTTP request body is not premitted'\
                                        unless request_body_permitted?
        send_request_with_body sock, ver, path, body
d1012 2
a1013 1
        request sock, ver, path
d1015 16
d1033 6
a1038 1
    def send_request_with_body( sock, ver, path, body )
d1065 11
d1092 24
d1209 14
a1222 6
      def read_new( sock, hasbody )
        httpv, code, msg = read_status(sock)
        res = new(code, msg, sock, hasbody, httpv)
        each_response_header(sock) do |k,v|
          if res.key? k then
            res[k] << ', ' << v
d1224 1
a1224 1
            res[k] = v
d1227 2
a1228 1
        res
d1233 1
a1233 1
      def read_status( sock )
d1237 3
a1239 13
        m.to_a[1,3]
      end

      def each_response_header( sock )
        while true do
          line = sock.readuntil( "\n", true )   # ignore EOF
          line.sub!( /\s+\z/, '' )              # don't use chop!
          break if line.empty?

          m = /\A([^:]+):\s*/.match(line) or
                  raise HTTPBadResponse, 'wrong header line format'
          yield m[1], m.post_match
        end
d1370 3
d1377 1
@


1.41.2.18
log
@* lib/net/protocol.rb: set read_timeout dynamically.
@
text
@@


1.40
log
@aamine
* lib/net/http.rb: does not send HEAD on closing socket.
@
text
@d3 1
a3 1
= net/http.rb version 1.2.0
d5 2
a6 2
  maintained by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
  This file is derived from "http-access.rb".
d8 7
a14 7
  This program is free software.
  You can distribute/modify this program under
  the terms of the Ruby Distribute License.

  Japanese version of this document is in "net" full package.
  You can get it from RAA
  (Ruby Application Archive: http://www.ruby-lang.org/en/raa.html).
d58 2
a59 2
  When this method is called with block, gives HTTP object to block
  and close HTTP session after block call finished.
d72 1
a72 1
  gets data from "path" on connecting host.
d74 2
a75 2
  Response body is written into "dest" by using "<<" method.
  This method returns Net::HTTPResponse object.
d78 1
a78 1
    response = http.get( '/index.html' )
d82 13
d108 1
a108 1
  posts "data" (must be String) to "path".
d110 1
a110 1
  Response body is written into "dest" by using "<<" method.
d112 1
a112 1
  This method returns Net::HTTPResponse object.
d116 6
a121 3
: new_get( path, header = nil ) {|req| .... }
  creates a new GET request object and gives it to the block.
  see also for Get class reference.
d124 20
a143 5
    http.new_get( '/~foo/bar.html' ) do |req|
      req['accept'] = 'text/html'
      response = req.dispatch
      p response['Content-Type']
      puts response.read_header
d146 6
a151 3
: new_head( path, header = nil ) {|req| .... }
  creates a new HEAD request object and gives it to the block.
  see also Head class reference.
d153 2
a154 3
: new_post( path, header = nil ) {|req| .... }
  creates a new POST request object and gives it to the block.
  see also Post class reference.
d156 2
d159 4
a162 1
= class Get, Head, Post
d164 6
a169 2
HTTP request class. This class wraps request header and entity path.
All "key" is case-insensitive.
d171 6
a176 1
== Methods
d178 4
a181 2
: self[ key ]
  returns header field for "key".
a182 7
: dispatch   [only Get, Head]
  dispatches request.
  This method returns HTTPResponse object.

: dispatch( data = '' )        [only Post]
: dispatch {|adapter| .... }   [only Post]
  dispatches request. "data" is 
d186 1
a186 1
HTTP response class. This class wraps response header and entity.
d215 9
a223 1
: read_body( dest = '' )
d225 6
a230 3
  gets response body.
  It is written into "dest" using "<<" method.
  If this method is called twice or more, nothing will be done and
a232 3
: read_body {|str| .... }
: body {|str| .... }
  gets response body with block.
d234 1
d236 2
a237 1
= Swithing Net::HTTP versions
d239 2
a240 3
You can use Net::HTTP 1.1 features by calling HTTP.old_implementation.
And calling Net::HTTP.new_implementation allows you to use 1.2 features
again.
d242 2
a243 2
  # example
  HTTP.start {|http1| ...(http1 has 1.2 features)... }
d246 3
a248 1
  HTTP.start {|http2| ...(http2 has 1.1 features)... }
d250 13
a262 2
  HTTP.version_1_2
  HTTP.start {|http3| ...(http3 has 1.2 features)... }
d277 1
a277 2

    HTTPVersion = '1.1'
d296 1
a296 1
        setvar i
d336 1
a336 1
    ### for compatibility
d339 1
a339 1
    @@@@newimpl = true
d341 1
a341 1
    class << self
d343 1
a343 1
      def version_1_2
d347 1
a347 1
      def version_1_1
d351 1
a351 1
      private
d353 1
a353 1
      def setvar( obj )
d358 1
a358 1
    end
d365 9
a373 20
    def self.defrequest( nm, hasdest, hasdata )
      name = nm.id2name.downcase
      cname = nm.id2name
      lineno = __LINE__ + 2
      src = <<S

        def #{name}( path, #{hasdata ? 'data,' : ''}
                     u_header = nil #{hasdest ? ',dest = nil, &block' : ''} )
          resp = #{name}2( path,
                           #{hasdata ? 'data,' : ''}
                           u_header ) {|resp|
            resp.read_body( #{hasdest ? 'dest, &block' : ''} )
          }
          if @@newimpl then
            resp
          else
            resp.value
            #{hasdest ? 'return resp, resp.body' : 'resp'}
          end
        end
d375 4
a378 14
        def #{name}2( path, #{hasdata ? 'data,' : ''}
                      u_header = nil )
          new_#{name}( path, u_header ) do |req|
            resp = req.dispatch#{hasdata ? '(data)' : ''}
            yield resp if block_given?
          end
        end

        def new_#{name}( path, u_header = nil, &block )
          common_oper ::Net::NetPrivate::#{cname}, path, u_header, &block
        end
S
      # puts src
      module_eval src, __FILE__, lineno
d382 7
a388 4
    defrequest :Get,  true,  false
    defrequest :Head, false, false
    defrequest :Post, true,  true
    defrequest :Put,  false, true
d390 5
a395 1
    private
d397 9
d407 4
a410 4
    def initialize( addr = nil, port = nil )
      super
      @@command = ::Net::NetPrivate::Switch.new
      @@curr_http_version = HTTPVersion
a412 3
    def connect( addr = @@address, port = @@port )
      @@socket = type.socket_type.open( addr, port, @@pipe )
    end
d414 8
a421 3
    def disconnect
      if @@socket and not @@socket.closed? then
        @@socket.close
a422 1
      @@socket = nil
d425 4
a428 1
    def do_finish
d432 23
a454 2
    def common_oper( reqc, path, u_header )
      req = nil
d456 1
a456 1
      @@command.on
d458 1
d464 1
a464 6
      req = reqc.new( @@curr_http_version,
                      @@socket, inihead,
                      edit_path(path), u_header )
      yield req if block_given?
      req.terminate
      @@curr_http_version = req.http_version
d466 1
a466 1
      unless keep_alive? req, req.response then
a468 3
      @@command.off

      req.response
d471 3
a473 12
    def inihead
      h = {}
      h['Host']       = address +
                        ((port == HTTP.port) ? '' : ":#{port}")
      h['Connection'] = 'Keep-Alive'
      h['Accept']     = '*/*'
      h
    end

    def keep_alive?( request, response )
      if response.key? 'connection' then
        if /keep-alive/i === response['connection'] then
d476 2
a477 2
      elsif response.key? 'proxy-connection' then
        if /keep-alive/i === response['proxy-connection'] then
d480 2
a481 2
      elsif request.key? 'Connection' then
        if /keep-alive/i === request['Connection'] then
d485 1
a485 1
        if @@curr_http_version == '1.1' then
d493 6
a498 1
  end
d500 10
a509 1
  HTTPSession = HTTP
d511 2
d515 2
a516 1
  module NetPrivate
d518 1
a518 4
  class Switch
    def initialize
      @@critical = false
    end
d520 1
a520 3
    def critical?
      @@critical
    end
a521 3
    def on
      @@critical = true
    end
d523 1
a523 4
    def off
      @@critical = false
    end
  end
d574 1
a574 1
      'http://' + address + (port == HTTP.port ? '' : ":#{port}") + path
d582 133
a778 1

d782 1
a782 11
  ###
  ### request
  ###

  class HTTPRequest

    def initialize( httpver, sock, inith, path, uhead )
      @@http_version = httpver
      @@socket = sock
      @@path = path
      @@response = nil
d784 5
a788 11
      @@u_header = inith
      return unless uhead
      tmp = {}
      uhead.each do |k,v|
        key = canonical(k)
        if tmp.key? key then
          $stderr.puts "WARNING: duplicated HTTP header: #{k}" if $VERBOSE
          tmp[ key ] = v.strip
        end
      end
      @@u_header.update tmp
a792 3
    attr_reader :path
    attr_reader :response

d794 1
a794 1
      "\#<#{type}>"
a796 3
    def []( key )
      @@u_header[ canonical key ]
    end
d798 3
a800 3
    def []=( key, val )
      @@u_header[ canonical key ] = val
    end
d802 1
a802 3
    def key?( key )
      @@u_header.key? canonical(key)
    end
d804 3
a806 2
    def delete( key )
      @@u_header.delete canonical(key)
d808 4
a811 3

    def each( &block )
      @@u_header.each( &block )
d814 5
a818 2
    def each_key( &block )
      @@u_header.each_key( &block )
d821 4
a824 2
    def each_value( &block )
      @@u_header.each_value( &block )
d827 1
d829 1
a829 4
    def terminate
      @@response.terminate
    end

d831 1
a831 1
    private
d833 1
a833 2
    def canonical( k )
      k.split('-').collect {|i| i.capitalize }.join('-')
d837 1
a837 1
    # write request & header
d839 1
a839 9
    def do_dispatch
      if @@response then
        raise IOError, "#{type}\#dispatch called twice"
      end
      yield
      @@response = read_response
    end

    def request( req )
d841 1
a841 1
      @@u_header.each do |n,v|
a846 1
    # read response & header
d848 9
a856 3
    def read_response
      resp = rdresp0
      resp = rdresp0 while ContinueCode === resp
d860 5
a864 2
    def rdresp0
      resp = get_resline
d886 1
a886 1
    def get_resline
d896 4
a899 57
      HTTPResponse.new( status, discrip, @@socket, type::HAS_BODY )
    end

  end

  class Get < HTTPRequest

    HAS_BODY = true

    def dispatch
      do_dispatch {
        request sprintf('GET %s HTTP/%s', @@path, @@http_version)
      }
    end

  end

  class Head < HTTPRequest

    HAS_BODY = false

    def dispatch
      do_dispatch {
        request sprintf('HEAD %s HTTP/%s', @@path, @@http_version)
      }
    end
  
  end

  class HTTPRequestWithData < HTTPRequest

    def dispatch( str = nil )
      check_arg str, block_given?

      if block_given? then
        ac = Accumulator.new
        yield ac              # must be yield, not block.call
        data = ac.terminate
      else
        data = str
      end

      do_dispatch {
        @@u_header['Content-Length'] = data.size.to_s
        @@u_header.delete 'Transfer-Encoding'
        request sprintf('%s %s HTTP/%s', type::METHOD, @@path, @@http_version)
        @@socket.write data
      }
    end

    def check_arg( data, blkp )
      if data and blkp then
        raise ArgumentError, 'both of data and block given'
      end
      unless data or blkp then
        raise ArgumentError, 'str or block required'
      end
a900 46
  
  end

  class Post < HTTPRequestWithData

    HAS_BODY = true

    METHOD = 'POST'
  
  end

  class Put < HTTPRequestWithData

    HAS_BODY = true

    METHOD = 'PUT'
  
  end

  class Accumulator
  
    def initialize
      @@buf = ''
    end

    def write( s )
      @@buf.concat s
    end

    alias << write

    def terminate
      ret = @@buf
      @@buf = nil
      ret
    end
  
  end



  ###
  ### response
  ###

  class HTTPResponse < Response
d955 3
a957 28
    def initialize( status, msg, sock, be )
      code = HTTPCODE_TO_OBJ[status] ||
             HTTPCODE_CLASS_TO_OBJ[status[0,1]] ||
             UnknownCode
      super code, status, msg
      @@socket = sock
      @@body_exist = be

      @@header = {}
      @@body = nil
      @@read = false
    end

    def inspect
      "#<#{type} #{code}>"
    end

    def []( key )
      @@header[ key.downcase ]
    end

    def []=( key, val )
      @@header[ key.downcase ] = val
    end

    def each( &block )
      @@header.each( &block )
    end
d959 1
a959 3
    def each_key( &block )
      @@header.each_key( &block )
    end
d961 2
a962 71
    def each_value( &block )
      @@header.each_value( &block )
    end

    def delete( key )
      @@header.delete key.downcase
    end

    def key?( key )
      @@header.key? key.downcase
    end

    def to_hash
      @@header.dup
    end

    def value
      unless SuccessCode === self then
        error! self
      end
    end


    # header (for backward compatibility)

    def read_header
      self
    end

    alias header read_header
    alias response read_header


    # body

    def read_body( dest = nil, &block )
      if @@read and (dest or block) then
        raise IOError, "#{type}\#read_body called twice with argument"
      end

      unless @@read then
        to = procdest( dest, block )
        stream_check

        if @@body_exist and code_type.body_exist? then
          read_body_0 to
          @@body = to
        else
          @@body = nil
        end
        @@read = true
      end

      @@body
    end

    alias body read_body
    alias entity read_body


    # internal use only
    def terminate
      read_body
    end


    private


    def read_body_0( dest )
      if chunked? then
d965 1
a965 1
        clen = content_length
d969 1
a969 1
          clen = range_length
d977 5
d984 3
d1007 3
a1009 3
    def content_length
      if @@header.key? 'content-length' then
        m = /\d+/.match( @@header['content-length'] )
d1019 3
a1021 3
    def chunked?
      tmp = @@header['transfer-encoding']
      tmp and /\bchunked\b/i === tmp
d1024 3
a1026 3
    def range_length
      if @@header.key? 'content-range' then
        m = %r<bytes\s+(\d+)-(\d+)/\d+>.match( @@header['content-range'] )
a1038 18
      end
    end

    def stream_check
      if @@socket.closed? then
        raise IOError, 'try to read body out of block'
      end
    end

    def procdest( dest, block )
      if dest and block then
        raise ArgumentError,
              'both of arg and block are given for HTTP method'
      end
      if block then
        ReadAdapter.new block
      else
        dest or ''
@


1.39
log
@aamine
* lib/net/protocol.rb: set @@closed false in Socket#reopen.
* lib/net/pop.rb: add POP3.foreach, delete_all.
* lib/net/pop.rb: add POP3#delete_all.
* lib/net/http.rb: add HTTP.version_1_1, version_1_2
* lib/net/http.rb: refactoring.
@
text
@d3 1
a3 1
= net/http.rb version 1.1.32
d5 2
a6 2
maintained by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
This file is derived from "http-access.rb".
d8 7
a14 7
This program is free software.
You can distribute/modify this program under
the terms of the Ruby Distribute License.

Japanese version of this document is in "net" full package.
You can get it from RAA
(Ruby Application Archive: http://www.ruby-lang.org/en/raa.html).
d58 2
a59 2
  When this method is called with block, gives a HTTP object to block
  and close HTTP session after returning from the block.
d72 1
a72 1
  get data from "path" on connecting host.
d74 2
a75 2
  Data is written to "dest" by using "<<" method.
  This method returns Net::HTTPResponse object, and "dest".
d78 1
a78 1
    response, body = http.get( '/index.html' )
a81 13
  Note:
  If status is not 2xx(success), ProtocolError exception is
  raised. At that time, you can get HTTPResponse object from 
  exception object. (same in head/post)

    # example
    begin
      response, body = http.get( '/index.html' )
    rescue Net::ProtoRetriableError => err
      response = err.data
      ...
    end

d95 1
a95 1
  posts "data" (must be String now) to "path".
d97 1
a97 1
  Data is written to "dest" by using "<<" method.
d99 1
a99 1
  This method returns Net::HTTPResponse object and "dest".
d103 3
a105 6
: get2( path, header = nil )
: get2( path, header = nil ) {|recv| .... }
  send GET request for "path".
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
  If this method is called with block, one gives
  a HTTPResponseReceiver object to block.
d108 5
a112 4
    http.get2( '/index.html' ) do |recv|
      # "recv" is a HTTPResponseReceiver object
      recv.header
      recv.body
d115 3
a117 4
    # another way
    response = http.get2( '/index.html' )
    response['content-type']
    response.body
d119 3
a121 4
    # this is wrong
    http.get2( '/index.html' ) do |recv|
      print recv.response.body   # body is not read yet!!!
    end
a122 5
    # but this is ok
    http.get2( '/index.html' ) do |recv|
      recv.body                  # read body and set recv.response.body
      print recv.response.body   # ref
    end
d124 1
a124 6
: head2( path, header = nil )
: head2( path, header = nil ) {|recv| .... }
  send HEAD request for "path".
  "header" must be a Hash like { 'Accept' => 'text/html', ... }.
  The difference between "head" method is that
  "head2" does not raise exceptions.
d126 2
a127 2
  If this method is called with block, one gives
  a HTTPResponseReceiver object to block.
d129 1
a129 2
    # example
    response = http.head2( '/index.html' )
d131 2
a132 23
    # another way
    http.head2( '/index.html' ) do |recv|
      recv.response
    end

: post2( path, data, header = nil )
: post2( path, data, header = nil ) {|recv| .... }
  posts "data" (must be String now) to "path".
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
  If this method is called with block, one gives
  a HTTPResponseReceiver object to block.

    # example
    http.post2( '/anycgi.rb', 'data data data...' ) do |recv|
      # "recv" is a HTTPResponseReceiver object
      recv.header
      recv.body
    end

    # another way
    response = http.post2( '/anycgi.rb', 'important data' )
    response['content-type']
    response.body
d134 7
d144 1
a144 1
HTTP response object.
d173 1
a173 9

= class HTTPResponseReceiver

== Methods

: header
: response
  Net::HTTPResponse object

d175 4
a178 2
: entity( dest = '' )
  entity body. A body is written to "dest" using "<<" method.
d180 3
a182 4
: body {|str| ... }
  gets entity body with block.
  If this method is called twice, block is not executed and
  returns first "dest".
d185 1
a185 1
= http.rb version 1.2 features
d187 3
a189 2
You can use 1.2 features by calling HTTP.version_1_2. And
calling Net::HTTP.version_1_1 allows to use 1.1 features.
d192 1
a192 4
  HTTP.start {|http1| ...(http1 has 1.1 features)... }

  HTTP.version_1_2
  HTTP.start {|http2| ...(http2 has 1.2 features)... }
d195 1
a195 1
  HTTP.start {|http3| ...(http3 has 1.1 features)... }
d197 2
a198 15
== Method (only diff to 1.1)

: get( path, u_header = nil )
: get( path, u_header = nil ) {|str| .... }
  gets document from "path".
  returns HTTPResponse object.

: head( path, u_header = nil )
  gets only document header from "path".
  returns HTTPResponse object.

: post( path, data, u_header = nil )
: post( path, data, u_header = nil ) {|str| .... }
  posts "data" to "path" entity and gets document.
  returns HTTPResponse object.
d213 2
a214 1
    protocol_param :command_type, '::Net::NetPrivate::HTTPCommand'
d233 1
a233 1
        setimplv i
d273 1
a273 1
    ### 1.2 implementation
d276 1
a276 1
    @@@@newimpl = false
d278 1
a278 1
    #class << self
d280 1
a280 1
      def self.version_1_2
d284 1
a284 1
      def self.version_1_1
d288 1
a288 1
      #private
d290 1
a290 1
      def self.setimplv( obj )
d295 1
a295 1
    #end
d302 35
a336 8
    def get( path, u_header = nil, dest = nil, &block )
      resp = get2( path, u_header ) {|f| f.body( dest, &block ) }
      if @@newimpl then
        resp
      else
        resp.value
        return resp, resp.body
      end
a338 5
    def get2( path, u_header = nil, &block )
      common_oper( u_header, true, block ) {|uh|
        @@command.get edit_path(path), uh
      }
    end
d340 4
a344 7
    def head( path, u_header = nil )
      resp = head2( path, u_header )
      unless @@newimpl then
        resp.value
      end
      resp
    end
d346 1
a346 5
    def head2( path, u_header = nil, &block )
      common_oper( u_header, false, block ) {|uh|
        @@command.head edit_path(path), uh
      }
    end
d349 4
a352 8
    def post( path, data, u_header = nil, dest = nil, &block )
      resp = post2( path, data, u_header ) {|f| f.body( dest, &block ) }
      if @@newimpl then
        resp
      else
        resp.value
        return resp, resp.body
      end
d355 2
a356 4
    def post2( path, data, u_header = nil, &block )
      common_oper( u_header, true, block ) {|uh|
        @@command.post edit_path(path), uh, data
      }
d359 3
a361 9

    # not tested because I could not setup apache  (__;;;
    def put( path, src, u_header = nil )
      resp = put2( path, src, u_header ) {|f| f.body }
      if @@newimpl then
        resp
      else
        resp.value
        return resp, resp.body
d363 1
d366 1
a366 4
    def put2( path, src, u_header = nil, &block )
      common_oper( u_header, true, block ) {|uh|
        @@command.put path, uh, src
      }
d370 2
a371 23
    private


    def common_oper( u_header, body_exist, block )
      u_header = procheader( u_header )
      recv = err = nil

      connecting( u_header ) {
        recv = HTTPResponseReceiver.new( @@command, body_exist )
        yield u_header
        begin
          block.call recv if block
        rescue Exception => err
          ;
        end
        recv.terminate

        recv.response
      }
      raise err if err

      recv.response
    end
d373 1
a373 1
    def connecting( u_header )
a374 1
        u_header['Connection'] = 'close'
d380 6
a385 1
      resp = yield
d387 1
a387 1
      unless keep_alive? u_header, resp then
d390 3
d395 12
a406 3
    def keep_alive?( header, resp )
      if resp.key? 'connection' then
        if /keep-alive/i === resp['connection'] then
d409 2
a410 2
      elsif resp.key? 'proxy-connection' then
        if /keep-alive/i === resp['proxy-connection'] then
d413 2
a414 2
      elsif header.key? 'Connection' then
        if /keep-alive/i === header['Connection'] then
d418 1
a418 1
        if @@command.http_version == '1.1' then
d426 5
a430 6
    def procheader( h )
      ret = {}
      ret[ 'Host' ]       = address +
                            ((port == HTTP.port) ? '' : ":#{port}")
      ret[ 'Connection' ] = 'Keep-Alive'
      ret[ 'Accept' ]     = '*/*'
d432 1
a432 10
      return ret unless h
      tmp = {}
      h.each do |k,v|
        key = k.split('-').collect {|i| i.capitalize }.join('-')
        if tmp[key] then
          $stderr.puts "'#{key}' http header appered twice" if $VERBOSE
        end
        tmp[key] = v
      end
      ret.update tmp
d434 3
a436 1
      ret
d439 3
d443 2
a444 5
    # called when connecting
    def do_finish
      unless @@socket.closed? then
        head2 '/', { 'Connection' => 'close' }
      end
d447 3
a451 5
  HTTPSession = HTTP


  module NetPrivate

d501 1
a501 1
      'http://' + address + (port == type.port ? '' : ":#{port}") + path
a508 133

  class HTTPResponseReceiver

    def initialize( command, body_exist )
      @@command = command
      @@body_exist = body_exist
      @@header = @@body = nil
    end

    def inspect
      "#<#{type}>"
    end

    def read_header
      unless @@header then
        stream_check
        @@header = @@command.get_response
      end
      @@header
    end

    alias header read_header
    alias response read_header

    def read_body( dest = nil, &block )
      unless @@body then
        read_header

        to = procdest( dest, block )
        stream_check

        if @@body_exist and @@header.code_type.body_exist? then
          @@command.get_body @@header, to
          @@header.body = @@body = to
        else
          @@command.no_body
          @@header.body = nil
          @@body = 1
        end
      end
      @@body == 1 ? nil : @@body
    end

    alias body read_body
    alias entity read_body

    def terminate
      read_header
      read_body
      @@command = nil
    end


    private

    def stream_check
      unless @@command then
        raise IOError, 'receiver was used out of block'
      end
    end

    def procdest( dest, block )
      if dest and block then
        raise ArgumentError,
          'both of arg and block are given for HTTP method'
      end
      if block then
        NetPrivate::ReadAdapter.new block
      else
        dest or ''
      end
    end

  end

  HTTPReadAdapter = HTTPResponseReceiver


  class HTTPResponse < Response

    def initialize( code_type, code, msg )
      super
      @@data = {}
      @@body = nil
    end

    attr_accessor :body

    def inspect
      "#<#{type.name} #{code}>"
    end

    def []( key )
      @@data[ key.downcase ]
    end

    def []=( key, val )
      @@data[ key.downcase ] = val
    end

    def each( &block )
      @@data.each( &block )
    end

    def each_key( &block )
      @@data.each_key( &block )
    end

    def each_value( &block )
      @@data.each_value( &block )
    end

    def delete( key )
      @@data.delete key.downcase
    end

    def key?( key )
      @@data.key? key.downcase
    end

    def to_hash
      @@data.dup
    end

    def value
      unless SuccessCode === self then
        error! self
      end
    end

  end


d573 1
d577 11
a587 1
  class HTTPCommand < Command
d589 11
a599 5
    HTTPVersion = '1.1'

    def initialize( sock )
      @@http_version = HTTPVersion
      super sock
d604 3
d608 1
a608 1
      "#<Net::HTTPCommand>"
d611 3
d615 3
a617 3
    ###
    ### request
    ###
d619 3
a621 1
    public
d623 2
a624 3
    def get( path, u_header )
      return unless begin_critical
      request sprintf('GET %s HTTP/%s', path, HTTPVersion), u_header
d626 3
a628 4
      
    def head( path, u_header )
      return unless begin_critical
      request sprintf('HEAD %s HTTP/%s', path, HTTPVersion), u_header
d631 2
a632 5
    def post( path, u_header, data )
      return unless begin_critical
      u_header[ 'Content-Length' ] = data.size.to_s
      request sprintf('POST %s HTTP/%s', path, HTTPVersion), u_header
      @@socket.write data
d635 2
a636 4
    def put( path, u_header, src )
      return unless begin_critical
      request sprintf('PUT %s HTTP/%s', path, HTTPVersion), u_header
      @@socket.write_bin src
a638 1
    # def delete
d640 4
a643 1
    # def trace
d645 1
a645 1
    # def options
d647 2
a648 1
    def quit
d652 9
a660 1
    private
d662 1
a662 1
    def request( req, u_header )
d664 1
a664 1
      u_header.each do |n,v|
d670 1
d672 3
a674 9
    ###
    ### response line & header
    ###

    public

    def get_response
      resp = get_resp0
      resp = get_resp0 while ContinueCode === resp
d678 2
a679 5

    private

    def get_resp0
      resp = get_reply
d701 1
a701 1
    def get_reply
d711 93
a803 4
      code = HTTPCODE_TO_OBJ[status] ||
             HTTPCODE_CLASS_TO_OBJ[status[0,1]] ||
             UnknownCode
      HTTPResponse.new( code, status, discrip )
d805 10
d869 100
a968 3
    ###
    ### body
    ###
a969 1
    public
d971 2
a972 2
    def get_body( resp, dest )
      if chunked? resp then
d975 1
a975 1
        clen = content_length( resp )
d979 1
a979 1
          clen = range_length( resp )
a986 5
      end_critical
    end

    def no_body
      end_critical
a988 3

    private

d1009 3
a1011 3
    def content_length( resp )
      if resp.key? 'content-length' then
        m = /\d+/.match( resp['content-length'] )
d1021 3
a1023 3
    def chunked?( resp )
      tmp = resp['transfer-encoding']
      tmp and /(?:\A|\s+)chunked(?:\s+|\z)/i === tmp
d1026 3
a1028 3
    def range_length( resp )
      if resp.key? 'content-range' then
        m = %r<bytes\s+(\d+)-(\d+)/\d+>.match( resp['content-range'] )
d1041 18
@


1.38
log
@aamine
* lib/net/http.rb: can call {old,new}_implementation any times.
* lib/net/http.rb: HTTP#connecting, receive ->
  common_oper, connecting.
* lib/net/http.rb: output warning if u_header includes
  duplicated header.
* lib/net/http.rb: not check Connection:/Proxy-Connection;
  always read until eof.
* lib/net/protocol: detects and catches "break" from block.
@
text
@d3 1
a3 1
= net/http.rb version 1.1.31
d58 2
a59 2
  When this method is called with block, gives HTTP object to block
  and close HTTP session after block call finished.
d236 2
a237 2
You can use 1.2 features by calling HTTP.new_implementation. And
calling Net::HTTP.old_implementation allows to use 1.1 features.
d242 1
a242 1
  HTTP.new_implementation
d245 1
a245 1
  HTTP.old_implementation
d296 1
a296 1
        setvar i
d343 1
a343 1
      def self.new_implementation
d347 1
a347 1
      def self.old_implementation
d353 1
a353 1
      def self.setvar( obj )
d578 1
a578 1
      'http://' + address + (port == HTTP.port ? '' : ":#{port}") + path
@


1.37
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.31
* lib/net/http.rb: initializes header in HTTP, not HTTPCommand
* lib/net/protocol.rb, http.rb: rewrites proxy code
@
text
@d23 1
a23 1
  if proxy_addr is given, this method is equals to
d28 2
a29 1
  is equals to Net::HTTP.new( address, port, proxy_addr, proxy_port ).start(&block)
d90 2
a91 2
    rescue Net::ProtoRetriableError
      response = $!.data
d96 1
a96 1
  get only header from "path" on connecting host.
d98 1
a98 1
  This method returns Net::HTTPResponse object.
d108 3
a110 3
  post "data"(must be String now) to "path".
  If body exists, also get entity body.
  It is written to "dest" by using "<<" method.
d114 1
a114 1
  If called with block, gives a part String of entity body.
d149 1
a149 1
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
d166 1
a166 1
  post "data"(must be String now) to "path".
d204 1
a204 1
  true if key is exist
d207 1
a207 1
  iterate for each field name and value pair
d236 2
a237 3
You can use these 1.2 features by calling method
Net::HTTP.new_implementation. Or you want to use 1.1 feature,
call Net::HTTP.old_implementation.
d239 2
a240 3
Now old_impl is default and if new_impl was called then Net::HTTP
changes self into new implementation.  In 1.2, new_impl is default
and if old_impl was called then changes self into old implementation.
d242 2
a243 1
== Warning!!!
d245 2
a246 3
You can call new_implementation/old_implementation any times
but CANNOT call both of them at the same time.
You must use one implementation in one application (process).
d248 1
a248 1
== Method
d252 2
a253 1
get document from "path" and returns HTTPResponse object.
d256 2
a257 1
get only document header from "path" and returns HTTPResponse object.
d261 2
a262 2
post "data" to "path" entity and get document,
then returns HTTPResponse object.
d294 4
a297 1
        (p_addr ? self::Proxy(p_addr, p_port) : self).orig_new( address, port )
d339 1
a339 3
    @@new_impl = false

    class << self
d341 1
a341 4
      def new_implementation
        return if @@new_impl
        @@new_impl = true
        module_eval %^
d343 3
a345 2
        undef head
        alias head head2
d347 3
a349 11
        undef get

        def get( path, u_header = nil, dest = nil, &block )
          get2( path, u_header ) {|f| f.body( dest, &block ) }
        end

        undef post

        def post( path, data, u_header = nil, dest = nil, &block )
          post2( path, data, u_header ) {|f| f.body( dest, &block ) }
        end
d351 1
a351 1
        undef put
d353 3
a355 5
        def put( path, src, u_header = nil )
          put2( path, src, u_header ) {|f| f.body }
        end

        ^
d358 1
a358 6
      def old_implementation
        if @@new_impl then
          raise RuntimeError,
                'http.rb is already switched to new implementation'
        end
      end
a359 2
    end
      
d367 6
a372 2
      resp.value
      return resp, resp.body
d376 1
a376 1
      connecting( u_header ) {|uh|
a377 1
        receive true, block
d384 3
a386 1
      resp.value
d391 1
a391 1
      connecting( u_header ) {|uh|
a392 1
        receive false, block
d399 6
a404 2
      resp.value
      return resp, resp.body
d408 1
a408 1
      connecting( u_header ) {|uh|
a409 1
        receive true, block
d417 6
a422 2
      resp.value
      return resp, resp.body
d426 1
a426 1
      connecting( u_header ) {|uh|
a427 1
        receive true, block
d435 21
a456 1
      u_header = procheader( u_header )
d464 1
a464 1
      resp = yield( u_header )
a468 2

      resp
d501 1
d503 5
a507 3
        arr = k.split('-')
        arr.each {|i| i.capitalize! }
        ret[ arr.join('-') ] = v
d509 1
a514 8
    def receive( body_exist, block )
      recv = HTTPResponseReceiver.new( @@command, body_exist )
      block.call recv if block
      recv.terminate
      recv.header
    end


d610 1
a610 1
    def body( dest = nil, &block )
d612 1
a612 1
        self.read_header
d616 4
a619 3
        if @@body_exist and header.code_type.body_exist? then
          @@command.get_body header, to
          header.body = @@body = to
d622 1
a622 1
          header.body = nil
d629 2
a630 1
    alias entity body
d633 2
a634 2
      header
      body
d967 1
a967 1
        read_chunked( dest, resp )
d977 1
a977 9
            tmp = resp['connection']
            if tmp and /close/i === tmp then
              @@socket.read_all dest
            else
              tmp = resp['proxy-connection']
              if tmp and /close/i === tmp then
                @@socket.read_all dest
              end
            end
d991 1
a991 1
    def read_chunked( ret, header )
d1003 1
a1003 1
        @@socket.read( len, ret ); total += len
d1011 3
a1013 3
    def content_length( header )
      if header.key? 'content-length' then
        m = /\d+/.match( header['content-length'] )
d1023 8
a1030 8
    def chunked?( header )
      str = header[ 'transfer-encoding' ]
      str and /(?:\A|\s+)chunked(?:\s+|\z)/i === str
    end

    def range_length( header )
      if header.key? 'content-range' then
        m = %r<bytes\s+(\d+)-(\d+)/\d+>.match( header['content-range'] )
@


1.36
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.30
* lib/net/protocol.rb, smtp.rb: Command#critical_ok -> error_ok
* lib/net/http.rb: read header when also "100 Continue"
@
text
@d3 1
a3 1
= net/http.rb version 1.1.30
d30 17
d48 1
a48 1
  HTTP default port, 80
d60 9
d278 5
d285 5
d300 28
d330 5
d337 9
a345 4
    def HTTP.new_implementation
      return if @@new_impl
      @@new_impl = true
      module_eval %^
d347 1
a347 2
      undef head
      alias head head2
d349 3
a351 1
      undef get
d353 1
a353 3
      def get( path, u_header = nil, dest = nil, &block )
        get2( path, u_header ) {|f| f.body( dest, &block ) }
      end
d355 3
a357 1
      undef post
d359 1
a359 3
      def post( path, data, u_header = nil, dest = nil, &block )
        post2( path, data, u_header ) {|f| f.body( dest, &block ) }
      end
d361 3
a363 1
      undef put
d365 1
a365 2
      def put( path, src, u_header = nil )
        put2( path, src, u_header ) {|f| f.body }
d368 6
a373 2
      ^
    end
a374 4
    def HTTP.old_implementation
      if @@new_impl then
        raise RuntimeError, "http.rb is already switched to new implementation"
      end
d378 4
d383 1
a383 1
      resp = get2( path, u_header ) {|f| dest = f.body( dest, &block ) }
d385 1
a385 1
      return resp, dest
d411 1
a411 2
      resp = post2( path, data, u_header ) {|f|
                    dest = f.body( dest, &block ) }
d413 1
a413 1
      return resp, dest
d483 7
a489 2
      return( {} ) unless h
      new = {}
d492 2
a493 2
        arr.each{|i| i.capitalize! }
        new[ arr.join('-') ] = v
d495 2
d515 40
a554 3
    
    def edit_path( path )
      path
d557 11
a567 10
    def HTTP.Proxy( p_addr, p_port = nil )
      klass = super
      klass.module_eval( <<'SRC', 'http.rb', __LINE__ + 1 )
        def edit_path( path )
          'http://' + address +
              (@@port == HTTP.port ? '' : ":#{@@port}") +
              path
        end
SRC
      klass
d570 4
d576 2
a577 1
  HTTPSession = HTTP
a782 7

      @@in_header = {}
      @@in_header[ 'Host' ] = sock.addr +
                             ((sock.port == HTTP.port) ? '' : ":#{sock.port}")
      @@in_header[ 'Connection' ] = 'Keep-Alive'
      @@in_header[ 'Accept' ]     = '*/*'

d836 1
a836 6
      if u_header then
        header = @@in_header.dup.update( u_header )
      else
        header = @@in_header
      end
      header.each do |n,v|
@


1.35
log
@aamine
* lib/net/http.rb: hex-alpha is not [a-h] but [a-f].
@
text
@d3 1
a3 1
= net/http.rb version 1.1.29
d673 6
d712 22
d735 9
a744 1
      resp = get_reply while ContinueCode === resp
d766 5
a770 24

    def get_body( resp, dest )
      if chunked? resp then
        read_chunked( dest, resp )
      else
        clen = content_length( resp )
        if clen then
          @@socket.read clen, dest
        else
          clen = range_length( resp )
          if clen then
            @@socket.read clen, dest
          else
            tmp = resp['connection']
            if tmp and /close/i === tmp then
              @@socket.read_all dest
            else
              tmp = resp['proxy-connection']
              if tmp and /close/i === tmp then
                @@socket.read_all dest
              end
            end
          end
        end
d772 8
a779 22
      end_critical
    end

    def no_body
      end_critical
    end


    private


    def request( req, u_header )
      @@socket.writeline req
      if u_header then
        header = @@in_header.dup.update( u_header )
      else
        header = @@in_header
      end
      header.each do |n,v|
        @@socket.writeline n + ': ' + v
      end
      @@socket.writeline ''
a781 1

d834 30
a863 5
    def get_reply
      str = @@socket.readline
      m = /\AHTTP\/(\d+\.\d+)?\s+(\d\d\d)\s*(.*)\z/i.match( str )
      unless m then
        raise HTTPBadResponse, "wrong status line: #{str}"
d865 5
a869 8
      @@http_version = m[1]
      status  = m[2]
      discrip = m[3]
      
      code = HTTPCODE_TO_OBJ[status] ||
             HTTPCODE_CLASS_TO_OBJ[status[0,1]] ||
             UnknownCode
      HTTPResponse.new( code, status, discrip )
d872 3
a894 1
    
@


1.34
log
@aamine
* lib/net/pop.rb: POP3#reset
* lib/net/http.rb: a code for "Switch Protocol" was wrongly 100
@
text
@d854 1
a854 1
        m = /[0-9a-hA-H]+/.match( line )
@


1.33
log
@aamine
* lib/net/protocol.rb: 2nd arg for ProtocolError#initialize is optional.
@
text
@d790 1
a790 1
      '100' => HTTPSwitchProtocol,
@


1.32
log
@aamine
* lib/net/protocol.rb, http.rb: typo.
@
text
@a253 9
      def procdest( dest, block )
        if block then
          return NetPrivate::ReadAdapter.new( block ), nil
        else
          dest ||= ''
          return dest, dest
        end
      end

d453 75
d530 2
a531 2
    def initialize( code_type, bexist, code, msg )
      super( code_type, code, msg )
a532 1
      @@http_body_exist = bexist
a535 1
    attr_reader :http_body_exist
d583 1
a583 46
  HTTPSuccessCode                   = SuccessCode.mkchild
  HTTPRetriableCode                 = RetriableCode.mkchild
  HTTPFatalErrorCode                = FatalErrorCode.mkchild


  HTTPSwitchProtocol                = HTTPSuccessCode.mkchild

  HTTPOK                            = HTTPSuccessCode.mkchild
  HTTPCreated                       = HTTPSuccessCode.mkchild
  HTTPAccepted                      = HTTPSuccessCode.mkchild
  HTTPNonAuthoritativeInformation   = HTTPSuccessCode.mkchild
  HTTPNoContent                     = HTTPSuccessCode.mkchild
  HTTPResetContent                  = HTTPSuccessCode.mkchild
  HTTPPartialContent                = HTTPSuccessCode.mkchild

  HTTPMultipleChoice                = HTTPRetriableCode.mkchild
  HTTPMovedPermanently              = HTTPRetriableCode.mkchild
  HTTPMovedTemporarily              = HTTPRetriableCode.mkchild
  HTTPNotModified                   = HTTPRetriableCode.mkchild
  HTTPUseProxy                      = HTTPRetriableCode.mkchild
  
  HTTPBadRequest                    = HTTPRetriableCode.mkchild
  HTTPUnauthorized                  = HTTPRetriableCode.mkchild
  HTTPPaymentRequired               = HTTPRetriableCode.mkchild
  HTTPForbidden                     = HTTPFatalErrorCode.mkchild
  HTTPNotFound                      = HTTPFatalErrorCode.mkchild
  HTTPMethodNotAllowed              = HTTPFatalErrorCode.mkchild
  HTTPNotAcceptable                 = HTTPFatalErrorCode.mkchild
  HTTPProxyAuthenticationRequired   = HTTPRetriableCode.mkchild
  HTTPRequestTimeOut                = HTTPFatalErrorCode.mkchild
  HTTPConflict                      = HTTPFatalErrorCode.mkchild
  HTTPGone                          = HTTPFatalErrorCode.mkchild
  HTTPLengthRequired                = HTTPFatalErrorCode.mkchild
  HTTPPreconditionFailed            = HTTPFatalErrorCode.mkchild
  HTTPRequestEntityTooLarge         = HTTPFatalErrorCode.mkchild
  HTTPRequestURITooLarge            = HTTPFatalErrorCode.mkchild
  HTTPUnsupportedMediaType          = HTTPFatalErrorCode.mkchild

  HTTPNotImplemented                = HTTPFatalErrorCode.mkchild
  HTTPBadGateway                    = HTTPFatalErrorCode.mkchild
  HTTPServiceUnavailable            = HTTPFatalErrorCode.mkchild
  HTTPGatewayTimeOut                = HTTPFatalErrorCode.mkchild
  HTTPVersionNotSupported           = HTTPFatalErrorCode.mkchild


  class HTTPResponseReceiver
d585 5
a589 4
    def initialize( command, body_exist )
      @@command = command
      @@body_exist = body_exist
      @@header = @@body = nil
d592 2
a593 36
    def inspect
      "#<#{type}>"
    end

    def header
      unless @@header then
        stream_check
        @@header = @@body_exist ? @@command.get_response :
                                @@command.get_response_no_body
      end
      @@header
    end
    alias response header

    def body( dest = nil, &block )
      dest, ret = HTTP.procdest( dest, block )
      unless @@body then
        stream_check
        @@body = @@command.get_body( header, dest )
      end
      @@body
    end
    alias entity body

    def terminate
      header
      body if @@body_exist
      @@command = nil
    end

    private

    def stream_check
      unless @@command then
        raise IOError, 'receiver was used out of block'
      end
d598 47
a644 2
  HTTPReadAdapter = HTTPResponseReceiver

d672 1
d730 1
d732 6
a737 5
      resp.body = dest

      if resp.http_body_exist then
        if chunked? resp then
          read_chunked( dest, resp )
d739 1
a739 1
          clen = content_length( resp )
d743 3
a745 3
            clen = range_length( resp )
            if clen then
              @@socket.read clen, dest
d747 1
a747 1
              tmp = resp['connection']
a749 5
              else
                tmp = resp['proxy-connection']
                if tmp and /close/i === tmp then
                  @@socket.read_all dest
                end
a755 2

      dest
d758 1
a758 2
    def get_response_no_body
      resp = get_response
a759 1
      resp
d780 8
d789 2
a790 2
      '100' => [ContinueCode,                        false],
      '100' => [HTTPSwitchProtocol,                  false],
d792 38
a829 38
      '200' => [HTTPOK,                              true],
      '201' => [HTTPCreated,                         true],
      '202' => [HTTPAccepted,                        true],
      '203' => [HTTPNonAuthoritativeInformation,     true],
      '204' => [HTTPNoContent,                       false],
      '205' => [HTTPResetContent,                    false],
      '206' => [HTTPPartialContent,                  true],

      '300' => [HTTPMultipleChoice,                  true],
      '301' => [HTTPMovedPermanently,                true],
      '302' => [HTTPMovedTemporarily,                true],
      '303' => [HTTPMovedPermanently,                true],
      '304' => [HTTPNotModified,                     false],
      '305' => [HTTPUseProxy,                        false],

      '400' => [HTTPBadRequest,                      true],
      '401' => [HTTPUnauthorized,                    true],
      '402' => [HTTPPaymentRequired,                 true],
      '403' => [HTTPForbidden,                       true],
      '404' => [HTTPNotFound,                        true],
      '405' => [HTTPMethodNotAllowed,                true],
      '406' => [HTTPNotAcceptable,                   true],
      '407' => [HTTPProxyAuthenticationRequired,     true],
      '408' => [HTTPRequestTimeOut,                  true],
      '409' => [HTTPConflict,                        true],
      '410' => [HTTPGone,                            true],
      '411' => [HTTPFatalErrorCode,                  true],
      '412' => [HTTPPreconditionFailed,              true],
      '413' => [HTTPRequestEntityTooLarge,           true],
      '414' => [HTTPRequestURITooLarge,              true],
      '415' => [HTTPUnsupportedMediaType,            true],

      '500' => [HTTPFatalErrorCode,                  true],
      '501' => [HTTPNotImplemented,                  true],
      '502' => [HTTPBadGateway,                      true],
      '503' => [HTTPServiceUnavailable,              true],
      '504' => [HTTPGatewayTimeOut,                  true],
      '505' => [HTTPVersionNotSupported,             true]
d842 4
a845 2
      klass, bodyexist = HTTPCODE_TO_OBJ[status] || [UnknownCode, true]
      HTTPResponse.new( klass, bodyexist, status, discrip )
d883 1
a883 5
      if str and /(?:\A|\s+)chunked(?:\s+|\z)/i === str then
        true
      else
        false
      end
@


1.31
log
@aamine
* lib/net/http.rb: too early parameter expantion in string.
@
text
@d58 1
a58 1
  execption object. (same in head/post)
d115 1
a115 1
      recv.body                  # read body and set recv.header.body
d447 1
a447 1
      klass.module_eval( <<SRC, 'http.rb', __LINE__ + 1 )
d450 1
a450 1
              (@@port == HTTP.port ? '' : ':' + @@port.to_s) +
@


1.30
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.28.
* lib/net/http.rb: HTTPReadAdapter -> HTTPResponseReceiver
* lib/net/http.rb (connecting): response is got in receive()
@
text
@d110 1
a110 1
      print recv.header.body   # body is not read yet!!!
d115 2
a116 2
      recv.body                # read body and set recv.header.body
      print recv.header.body   # ref
d183 1
a183 1
  HTTP result code. For example, '302'
d447 1
a447 1
      klass.module_eval %-
d450 1
a450 1
              (@@port == HTTP.port ? '' : ":#{@@port}") +
d453 1
a453 1
      -
@


1.29
log
@matz - net library bug (by me)
@
text
@d3 1
a3 1
= net/http.rb version 1.1.28
d12 4
d40 1
a40 1
  When this method is called with a block, gives HTTP object to block
d53 1
a53 1
  If called with a block, give a part String of entity body.
d57 1
a57 1
  raised. At that time, you can get Response object from 
d62 1
a62 1
      response, body = http.get(...)
a67 1

d87 1
a87 1
  If called with a block, gives a part String of entity body.
d89 2
a90 1
: get2( path, header = nil ) {|adapter| .... }
d93 2
a94 1
  This method gives HTTPReadAdapter object to block.
d96 21
a116 6
    ex.
    
    http.get2( '/index.html' ) do |f|
      # f is a HTTPReadAdapter object
      f.header
      f.body
d120 1
d126 9
a134 4
    ex.
    
    http.head2( '/index.html' ) do |f|
      f.header
d137 2
a138 1
: post2( path, data, header = nil ) {|adapter| .... }
d141 2
a142 1
  This method gives HTTPReadAdapter object to block.
d144 5
a148 5
    ex.
    
    http.post2( '/index.html', 'data data data...' ) do |adapter|
      adapter.header
      adapter.body
d151 5
d188 2
a189 1
= class HTTPReadAdapter
d202 2
a203 2
  get entity body by using block.
  If this method is called twice, block is not called and
d320 1
a320 1
      connecting( u_header, block ) {|uh|
d322 1
d333 2
a334 2
    def head2( path, u_header = nil )
      connecting( u_header, nil ) {|uh|
d336 1
a336 1
        @@command.get_response_no_body
d349 1
a349 1
      connecting( u_header, block ) {|uh|
d351 1
d364 1
a364 1
      connecting( u_header, block ) {|uh|
d366 1
d374 1
a374 8
    # called when connecting
    def do_finish
      unless @@socket.closed? then
        head2 '/', { 'Connection' => 'close' }
      end
    end

    def connecting( u_header, ublock )
d384 1
a384 6
      if ublock then
        adapter = HTTPReadAdapter.new( @@command )
        ublock.call adapter
        resp = adapter.off
      end
      
d424 16
d445 10
a454 11
    class << self
      def Proxy( p_addr, p_port )
        klass = super
        klass.module_eval %-
          def edit_path( path )
            'http://' + address +
              (@@port == #{self.port} ? '' : ':' + @@port.to_s) + path
          end
        -
        klass
      end
d564 1
a564 1
  class HTTPReadAdapter
d566 1
a566 1
    def initialize( command )
d568 1
d578 3
a580 1
        @@header = @@command.get_response
d589 2
a590 1
        @@body = @@command.get_body( response, dest )
d596 3
a598 2
    def off
      body
d600 8
a607 1
      @@header
d612 2
d627 2
a628 5
      if sock.port == HTTP.port
        @@in_header[ 'Host' ] = sock.addr
      else
        @@in_header[ 'Host' ] = sock.addr + ':' + sock.port
      end
@


1.28
log
@matz: 1.6.0 final (hopufully)
@
text
@d353 1
a353 1
      yield( u_header )
a357 2
      else
	resp = @@command.get_response
@


1.27
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.27.
* lib/net/protocol.rb: writing methods returns written byte size.
* lib/net/smtp.rb: send_mail accepts many destinations.
@
text
@d36 1
a36 1
  When this method is called as iterator, gives HTTP object to block
d49 1
a49 1
  If called as iterator, give a part String of entity body.
d84 1
a84 1
  If called as iterator, gives a part String of entity body.
d168 1
a168 1
  get entity body by using iterator.
d353 1
a353 1
      resp = yield( u_header )
d358 2
@


1.26
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.26.
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb:
  add module Net::NetPrivate and its inner classes
  {Read,Write}Adapter, Command, Socket,
  SMTPCommand, POP3Command, APOPCommand, HTTPCommand
@
text
@d3 1
a3 1
= net/http.rb version 1.1.27
d8 3
a10 2
This library is distributed under the terms of the Ruby license.
You can freely distribute/modify this library.
@


1.25
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.26.
* lib/net/protocol.rb (finish): do nothing unless active.
* lib/net/http.rb: HTTP#{get,post}2 again (for new impl).
@
text
@d3 1
a3 1
= net/http.rb
a27 2
: command_type
  Command class for Net::HTTP, HTTPCommand
d117 3
a119 3
    http.post2( '/index.html', 'data data data...' ) do |f|
      f.header
      f.body
d215 1
a215 1
    protocol_param :command_type, '::Net::HTTPCommand'
d221 1
a221 1
          return ReadAdapter.new( block ), nil
a420 37
  class HTTPReadAdapter

    def initialize( command )
      @@command = command
      @@header = @@body = nil
    end

    def inspect
      "#<#{type}>"
    end

    def header
      unless @@header then
        @@header = @@command.get_response
      end
      @@header
    end
    alias response header

    def body( dest = nil, &block )
      dest, ret = HTTP.procdest( dest, block )
      unless @@body then
        @@body = @@command.get_body( response, dest )
      end
      @@body
    end
    alias entity body

    def off
      body
      @@command = nil
      @@header
    end
  
  end


d434 1
a434 1
      "#<Net::HTTPResponse #{code}>"
d523 41
d823 2
@


1.24
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.24.
* lib/net/protocol.rb: modified each_crlf_line again.
* lib/net/protocol.rb: do_write_beg,do_write_end -> writing{}
  do_write_do -> do_write
* lib/net/http.rb: can make proxy connection by passing
  addresses to HTTP.new, start.
* lib/net/http.rb: HTTP.new_implementation, old_implementation:
  can use 1.2 implementation of head, get, post, put.
  (see document)
@
text
@a250 1
      undef head2
a251 2
      alias old_get2 get2
      undef get2
d255 1
a255 1
        old_get2( path, u_header ) {|f| f.body( dest, &block ) }
a257 2
      alias old_post2 post2
      undef post2
d261 1
a261 1
        old_post2( path, data, u_header ) {|f| f.body( dest, &block ) }
a263 2
      alias old_put2 put2
      undef put2
d267 1
a267 1
        old_put2( path, src, u_header ) {|f| f.body }
@


1.23
log
@o  protocol.rb, smtp.rb, pop.rb, http.rb:  define all#inspect()
o  protocol.rb, smtp.rb, pop.rb, http.rb:  modify/add documents
@
text
@d16 1
a16 1
: new( address = 'localhost', port = 80 )
d18 2
d21 3
a23 3
: start( address = 'localhost', port = 80 )
: start( address = 'localhost', port = 80 ) {|http| .... }
  equals to Net::HTTP.new( address, port ).start
d132 2
a133 5
: code
  HTTP result code. For example, '302'

: message
  HTTP result message. For example, 'Not Found'
d150 2
a151 2
: body
  "dest" argument for HTTP#get, post, put
d153 2
d173 31
d219 19
a237 6
    def HTTP.procdest( dest, block )
      if block then
        return ReadAdapter.new( block ), nil
      else
        dest ||= ''
        return dest, dest
d239 1
d242 44
d330 1
a330 2
      ret = nil
      resp = put2( path, src, u_header ) {|f| ret = f.body }
d332 1
a332 1
      return resp, ret
@


1.22
log
@o  http.rb:  body is in HTTPResponse
@
text
@a10 10
=end

require 'net/protocol'


module Net

  class HTTPBadResponse < StandardError; end

=begin
d43 4
a46 1
  This method returns Net::HTTPResponse object and "dest".
d55 1
a55 2
    ex.

d57 2
a58 2
      head, body = http.get(...)
    rescue ProtoRetriableError
d63 1
d90 8
d104 6
d115 7
a124 2
== Methods

d128 2
d151 3
d174 8
d348 4
d390 4
d499 1
d501 3
a503 1
    attr_reader :http_version
a504 1
      
@


1.21
log
@o  protocol.rb:  ProtocolError can take data
o  http.rb:  raise exception with response
@
text
@d355 1
d359 1
d528 2
@


1.20
log
@o  smtp.rb:  not catch NameError in auth
o  http.rb:  not close connection in get_body,
   Only connection() closes socket
@
text
@d57 14
d392 3
a394 1
      error! unless SuccessCode === self
@


1.19
log
@p  http.rb:  do not use Regexp "p" option
@
text
@d159 1
a159 1
      resp = get2( path, u_header ) {|f| dest = f.entity( dest, &block ) }
d187 1
a187 1
                    dest = f.entity( dest, &block ) }
d202 1
a202 1
      resp = put2( path, src, u_header ) {|f| ret = f.entity }
d252 4
d257 1
a257 1
        if /\A\s*keep-alive/i === header['Connection'] then
a524 1
                @@socket.close
a528 1
                  @@socket.close
@


1.18
log
@o  protocol.rb, http.rb, smtp.rb, pop.rb:  update RD documents
@
text
@d489 1
a489 1
        m = /\A([^:]+):\s*(.*)/p.match( line )
d494 1
a494 1
        line = m[2]
@


1.17
log
@protocol.rb version 1.1.17
o  http.rb:  'Host:' field includes port if port != 80
o  http.rb:  see also 'proxy-connection:' field
@
text
@d26 6
a31 2
: new( address, port = 80 )
  create new HTTP object.
d34 1
a34 1
  returns HTTP default port, 80
d37 3
a39 1
  returns Command class, HTTPCommand
d41 3
d45 2
a46 1
== Methods
@


1.16
log
@{protocol,smtp,pop,http}.rb 1.1.15
o  http.rb: (keep_alive?)  use both user header and response
o  http.rb: (connecting)  returns response
o  http.rb: (connecting)  proc u_header and yield it
o  http.rb: (connecting)  call user block in conecting
@
text
@d423 5
a427 1
      @@in_header[ 'Host' ]       = sock.addr
d512 6
@


1.15
log
@{protocol,smtp,pop}.rb version 1.1.14
o  http.rb:  HTTP#head2
o  http.rb:  HTTPResponse#value
o  http.rb:  get2/post2 returns response header
o  http.rb:  *2 does not raise exceptions
o  smtp.rb:  try esmtp only first time
o  protocol.rb:  remove error_occured
o  protocol.rb:  Command#error! does not take argument
@
text
@d73 6
d154 3
a156 8
    def get2( path, u_header = nil )
      u_header = procheader( u_header )
      resp = nil
      connecting( u_header ) {
        @@command.get edit_path(path), u_header
        tmp = HTTPReadAdapter.new( @@command )
        yield tmp
        resp = tmp.off
a157 2

      resp
d168 3
a170 5
      u_header = procheader( u_header )
      resp = nil
      connecting( u_header ) {
        @@command.head( edit_path(path), u_header )
        resp = @@command.get_response_no_body
a171 2

      resp
d182 3
a184 8
    def post2( path, data, u_header = nil )
      u_header = procheader( u_header )
      resp = nil
      connecting( u_header ) {
        @@command.post edit_path(path), u_header, data
        tmp = HTTPReadAdapter.new( @@command )
        yield tmp
        resp = tmp.off
a185 2

      resp
d197 3
a199 9
    def put2( path, src, u_header = nil )
      u_header = procheader( u_header )
      ret = ''
      resp = nil
      connecting( u_header ) {
        @@command.put path, u_header, src, dest
        tmp = HTTPReadAdapter.new( @@command )
        yield tmp
        resp = tmp.off
a200 2

      resp
d210 1
a210 4
        begin
          @@command.head '/', { 'Connection' => 'Close' }
        rescue EOFError
        end
d214 2
a215 1
    def connecting( u_header )
d217 1
a217 1
        u_header['Connection'] = 'Close'
d223 5
a227 4
      if iterator? then
        ret = yield
        ensure_termination u_header
        ret
d229 2
a230 4
    end

    def ensure_termination( u_header )
      unless keep_alive? u_header and not @@socket.closed? then
d233 2
a234 1
      @@u_header = @@response = nil
d237 7
a243 3
    def keep_alive?( header )
      if header.key? 'connection' then
        if /\A\s*keep-alive/i === header['connection'] then
@


1.14
log
@o pop.rb:  accept illegal timestamp (reported by WATANABE Hirofumi)
o http.rb:  when body was chunked, does not set 'Content-Length'
@
text
@d68 1
a68 1
: get2( path, header = nil ) {|writer| .... }
d73 1
a73 1
: post2( path, data, header = nil ) {|writer| .... }
d87 1
a87 1
  HTTP result code. ex. '302'
d90 1
a90 1
  HTTP result message. ex. 'Not Found'
d104 3
d116 1
d118 1
a118 2
: body( dest = '' )
  entity body
d120 1
a120 1
: entity {|str| ... }
d122 2
a123 1
  If this method is called twice, block is not called.
d143 3
a145 10
      u_header = procheader( u_header )
      dest, ret = HTTP.procdest( dest, block )
      resp = nil
      connecting( u_header ) {
        @@command.get edit_path(path), u_header
        resp = @@command.get_response
        @@command.get_body( resp, dest )
      }

      return resp, ret
d150 1
d155 1
a155 1
        tmp.off
d157 2
d163 6
d181 4
a184 10
      u_header = procheader( u_header )
      dest, ret = HTTP.procdest( dest, block )
      resp = nil
      connecting( u_header ) {
        @@command.post edit_path(path), u_header, data
        resp = @@command.get_response
        @@command.get_body( resp, dest )
      }

      return resp, ret
d189 1
d194 1
a194 1
        tmp.off
d196 2
d203 7
d215 3
a217 2
        resp = @@comman.get_response
        @@command.get_body( resp, ret )
d220 1
a220 1
      return resp, ret
d333 1
d341 2
a342 2
    def initialize( code_type, code, msg )
      super
d344 1
a344 1
      @@http_body_exist = true
d347 1
a347 1
    attr_accessor :http_body_exist
d381 4
d464 1
a508 4
    def check_response( resp )
      reply_must resp, SuccessCode
    end

a531 1
      reply_must resp, SuccessCode
a538 1
      reply_must resp, SuccessCode
d590 1
a590 1
      '411' => [FatalErrorCode,                      true],
d596 1
a596 1
      '500' => [FatalErrorCode,                      true],
d615 1
a615 3
      resp = HTTPResponse.new( klass, status, discrip )
      resp.http_body_exist = bodyexist
      resp
@


1.13
log
@protocol.rb smtp.rb pop.rb http.rb version 1.1.12

o protocol.rb:  update Net::Protocol::Proxy#connect
o protocol.rb:  ReplyCode is not a class
o http.rb:  header value does not include header name
o http.rb:  header is not a Hash, but HTTPResponse
@
text
@d173 1
d197 1
d597 1
a597 1
        raise HTTPBadResponse, "wrong status line format: #{str}"
a609 1
      line = nil
d617 1
a617 1
          raise HTTPBadResponse, "chunk size not given"
d624 2
a625 3
      while true do
        line = @@socket.readline
        break if line.empty?
a626 3

      header.delete 'transfer-encoding'
      header[ 'content-length' ] = total.to_s
d644 1
a644 1
      if str and /(\A|\s+)chunked(?:\s+|\z)/i === str then
@


1.12
log
@v1.1.11
o  all:  use "critical" to avoid duplicated command dispatch
o  http.rb:  change get2, post2 usage (HTTPWriter)
o  http.rb:  entity reading algorithm is better
o  http.rb:  more reply code (4xx, 5xx)
o  protocol.rb:  arguments of "connect" can be omitted
o  protocol.rb:  "quit" is not template method (now do_quit is removed)
o  protocol.rb:  ReplyCode.error_type was not work: using module_eval
@
text
@d18 1
a18 4

class HTTPError < ProtocolError; end
class HTTPBadResponse < HTTPError; end

d43 1
a43 1
  This method returns response header (Hash) and "dest".
d50 2
a51 1
  This method returns header as a Hash like
d53 4
a56 3
    { 'content-length' => 'Content-Length: 2554',
      'content-type'   => 'Content-Type: text/html',
      ... }
d64 1
a64 1
  This method returns response header (Hash) and "dest".
d71 1
a71 9
  This method gives HTTPWriter object to block.

: get_body( dest = '' )
: get_body {|str| .... }
  gets entity body of forwarded 'get2' or 'post2' methods.
  Data is written in "dest" by using "<<" method.
  This method returns "dest".

  If called as iterator, gives a part String of entity body.
d76 9
a84 1
  This method gives HTTPWriter object to block.
d86 2
d89 17
a105 1
= class HTTPWriter
a109 2
  HTTP header.

d111 1
a111 1
  ReplyCode object.
d115 1
a115 1
  entity body.
d148 1
a148 1
      return resp['http-header'], ret
d155 1
a155 1
        tmp = HTTPWriter.new( @@command )
a160 11
=begin c
    def get_body( dest = '', &block )
      if block then
        dest = ReadAdapter.new( block )
      end
      @@command.get_body @@response, dest
      ensure_termination @@u_header

      dest
    end
=end
d170 1
a170 1
      resp['http-header']
d183 1
a183 1
      return resp['http-header'], ret
d190 1
a190 1
        tmp = HTTPWriter.new( @@command )
d200 1
d207 1
a207 1
      return header, ret
a213 16
=begin c
    def only_header( mid, path, u_header, data = nil )
      @@u_header = u_header
      @@response = nil
      connecting u_header
      if data then
        @@command.send mid, edit_path(path), u_header, data
      else
        @@command.send mid, edit_path(path), u_header
      end
      @@response = @@command.get_response
      @@response['http-header']
    end
=end


d247 2
a248 2
      if str = header['Connection'] then
        if /\A\s*keep-alive/i === str then
d293 1
a293 1
  class HTTPWriter
d297 1
a297 8
      @@response = @@header = @@entity = nil
    end

    def response
      unless @@resp then
        @@resp = @@command.get_response
      end
      @@resp
d302 1
a302 1
        @@header = response['http-header']
d306 1
d308 1
a308 1
    def entity( dest = nil, &block )
d310 2
a311 2
      unless @@entity then
        @@entity = @@command.get_body( response, dest )
d313 1
a313 1
      @@entity
d315 1
a315 1
    alias body entity
d318 1
a318 1
      entity
d325 7
a331 1
  class HTTPSwitchProtocol                < SuccessCode; end
d333 57
a389 13
  class HTTPOK                            < SuccessCode; end
  class HTTPCreated                       < SuccessCode; end
  class HTTPAccepted                      < SuccessCode; end
  class HTTPNonAuthoritativeInformation   < SuccessCode; end
  class HTTPNoContent                     < SuccessCode; end
  class HTTPResetContent                  < SuccessCode; end
  class HTTPPartialContent                < SuccessCode; end

  class HTTPMultipleChoice                < RetryCode; end
  class HTTPMovedPermanently              < RetryCode; end
  class HTTPMovedTemporarily              < RetryCode; end
  class HTTPNotModified                   < RetryCode; end
  class HTTPUseProxy                      < RetryCode; end
d391 22
a412 22
  class HTTPBadRequest                    < RetryCode; end
  class HTTPUnauthorized                  < RetryCode; end
  class HTTPPaymentRequired               < RetryCode; end
  class HTTPForbidden                     < FatalErrorCode; end
  class HTTPNotFound                      < FatalErrorCode; end
  class HTTPMethodNotAllowed              < FatalErrorCode; end
  class HTTPNotAcceptable                 < FatalErrorCode; end
  class HTTPProxyAuthenticationRequired   < RetryCode; end
  class HTTPRequestTimeOut                < FatalErrorCode; end
  class HTTPConflict                      < FatalErrorCode; end
  class HTTPGone                          < FatalErrorCode; end
  class HTTPLengthRequired                < FatalErrorCode; end
  class HTTPPreconditionFailed            < FatalErrorCode; end
  class HTTPRequestEntityTooLarge         < FatalErrorCode; end
  class HTTPRequestURITooLarge            < FatalErrorCode; end
  class HTTPUnsupportedMediaType          < FatalErrorCode; end

  class HTTPNotImplemented                < FatalErrorCode; end
  class HTTPBadGateway                    < FatalErrorCode; end
  class HTTPServiceUnavailable            < FatalErrorCode; end
  class HTTPGatewayTimeOut                < FatalErrorCode; end
  class HTTPVersionNotSupported           < FatalErrorCode; end
d467 3
a469 3
      rep = get_reply
      rep = get_reply while ContinueCode === rep
      header = {}
d473 12
a484 2
        nm = /\A[^:]+/.match( line )[0].strip.downcase
        header[nm] = line
a485 1
      rep['http-header'] = header
d487 1
a487 1
      rep
d494 4
a497 6
    def get_body( rep, dest )
      header = rep['http-header']

      if rep['body-exist'] then
        if chunked? header then
          read_chunked( dest, header )
d499 2
a500 1
          if clen = content_length( header ) then
d503 3
a505 1
            if false then # "multipart/byteranges" check should be done
d507 2
a508 2
              if header['Connection'] and
                 /connection:\s*close/i === header['Connection'] then
d517 1
a517 1
      reply_must rep, SuccessCode
d547 1
a547 1
    CODE_TO_CLASS = {
d593 2
a594 1
      unless /\AHTTP\/(\d+\.\d+)?\s+(\d\d\d)\s*(.*)\z/i === str then
d597 3
a599 3
      @@http_version = $1
      status  = $2
      discrip = $3
d601 4
a604 4
      klass, bodyexist = CODE_TO_CLASS[status] || [UnknownCode, true]
      code = klass.new( status, discrip )
      code['body-exist'] = bodyexist
      code
d614 2
a615 1
        unless /[0-9a-hA-H]+/ === line then
d618 1
a618 1
        len = $&.hex
d629 1
a629 1
      header[ 'content-length' ] = "Content-Length: #{total}"
d634 8
a641 2
      unless str = header[ 'content-length' ] then
        return nil
d643 8
a650 2
      unless /\Acontent-length:\s*(\d+)/i === str then
        raise HTTPBadResponse, "content-length format error"
a651 1
      $1.to_i
d654 12
a665 4
    def chunked?( header )
      if str = header[ 'transfer-encoding' ] then
        if /\Atransfer-encoding:\s*chunked/i === str then
          return true
d667 2
a669 2

      false
@


1.11
log
@o  http.rb:  return value of 'head' was wrong
@
text
@d61 3
a63 1
  post "data"(must be String now) to "path" (and get entity body).
a64 1
  Data is written to "dest" by using "<<" method.
d67 1
a67 1
  If called as iterator, give a part String of entity body.
d69 1
a69 3
  ATTENTION: entity body could be empty

: get2( path, header = nil )
d72 1
a72 1
  This method returns response header (Hash).
d80 25
a104 1
  If called as iterator, give a part String of entity body.
d113 9
d125 1
a125 6
      if block then
        dest = ReadAdapter.new( block )
        ret = nil
      else
        dest = ret =  ''
      end
d130 1
a130 1
        @@command.try_get_body( resp, dest )
d138 6
a143 1
      only_header( :get, path, u_header )
d146 1
d151 1
a151 1
      @@command.try_get_body @@response, dest
d156 1
d160 7
a166 3
      header = only_header( :head, path, u_header )
      ensure_termination u_header
      header
d171 1
a171 6
      if block then
        dest = ReadAdapter.new( block )
        ret = nil
      else
        dest = ret = ''
      end
d173 2
a174 2
      connecting( u_header, true ) {
        @@command.post path, u_header, data
d176 1
a176 1
        @@command.try_get_body( resp, dest )
d182 1
a182 1
    def post2( path, data, u_header = {} )
d184 6
a189 1
      only_header :post, path, u_header, data
d193 1
a193 1
    def put( path, src = nil, u_header = nil, &block )
d195 2
a196 1
      connecting( u_header, true ) {
d198 2
d202 1
a202 1
      header
d209 1
d213 1
a213 1
      ensure_connection u_header
d222 1
d235 1
a235 7
    def connecting( u_header, putp = false )
      ensure_connection u_header
      yield
      ensure_termination u_header
    end

    def ensure_connection( u_header )
d242 6
d304 76
a379 12
  class HTTPSuccessCode < SuccessCode; end
  class HTTPCreatedCode < SuccessCode; end
  class HTTPAcceptedCode < SuccessCode; end
  class HTTPNoContentCode < SuccessCode; end
  class HTTPResetContentCode < SuccessCode; end
  class HTTPPartialContentCode < SuccessCode; end

  class HTTPMultipleChoiceCode < RetryCode; end
  class HTTPMovedPermanentlyCode < RetryCode; end
  class HTTPMovedTemporarilyCode < RetryCode; end
  class HTTPNotModifiedCode < RetryCode; end
  class HTTPUseProxyCode < RetryCode; end
d402 1
d407 1
d412 1
d418 1
a422 1

d429 3
a442 1

a443 1
      reply_must rep, SuccessCode
d448 4
d454 4
a457 5
      if chunked? header then
        read_chunked( dest, header )
      else
        if clen = content_length( header ) then
          @@socket.read clen, dest
d459 12
a470 5
          ##### "multipart/byteranges" check should be done here ...

          # now, length is designated by closing socket
          @@socket.read_all dest
          @@socket.close
d473 4
d479 5
a483 5
    def try_get_body( rep, dest )
      rep = get_reply while ContinueCode === rep
      return nil unless rep['body-exist']

      get_body rep, dest
d504 44
d557 1
a557 33
      be = false
      klass = case status[0]
              when ?1 then
                case status[2]
                when ?0 then ContinueCode
                when ?1 then HTTPSuccessCode
                else         UnknownCode
                end
              when ?2 then
                case status[2]
                when ?0 then be = true;  HTTPSuccessCode
                when ?1 then be = false; HTTPSuccessCode
                when ?2 then be = true;  HTTPSuccessCode
                when ?3 then be = true;  HTTPSuccessCode
                when ?4 then be = false; HTTPNoContentCode
                when ?5 then be = false; HTTPResetContentCode
                when ?6 then be = true;  HTTPPartialContentCode
                else         UnknownCode
                end
              when ?3 then
                case status[2]
                when ?0 then be = true;  HTTPMultipleChoiceCode
                when ?1 then be = true;  HTTPMovedPermanentryCode
                when ?2 then be = true;  HTTPMovedTemporarilyCode
                when ?3 then be = true;  HTTPMovedPermanentryCode
                when ?4 then be = false; HTTPNotModifiedCode
                when ?5 then be = false; HTTPUseProxyCode
                else         UnknownCode
                end
              when ?4 then ServerBusyCode
              when ?5 then FatalErrorCode
              else         UnknownCode
              end
d559 1
a559 1
      code['body-exist'] = be
@


1.10
log
@o  protocol.rb:  version 1.1.9
o  smtp.rb:  arguments discription of do_ready was wrongly void
@
text
@d92 1
a92 1
      u_header ||= {}
d109 2
a110 1
    def get2( path, u_header = {} )
d124 3
a126 2
    def head( path, u_header = {} )
      ret = only_header( :head, path, u_header )['http-header']
d128 1
a128 1
      ret
d132 1
a132 1
      u_header ||= {}
d150 1
d155 2
a156 2
    def put( path, src = nil, u_header = {}, &block )
      u_header ||= u_header
d169 1
a169 1
      @@u_header = u_header ?  procheader(u_header) : {}
d171 1
a171 1
      ensure_connection @@u_header
d173 1
a173 1
        @@command.send mid, edit_path(path), @@u_header, data
d175 1
a175 1
        @@command.send mid, edit_path(path), @@u_header
a192 1
      u_header = procheader( u_header )
d208 1
a208 1
      unless keep_alive? u_header then
d229 1
d345 3
a347 3
          ###
          ### "multipart/bytelenges" check should be done here ...
          ###
d349 1
@


1.9
log
@net Version 1.1.7
o  http.rb:  HTTP#connecting() returns header again
@
text
@d41 2
a42 1
: get( path, header = nil, ret = '' )
d44 5
a48 3
  "header" is a Hash like { 'Accept' => '*/*', ... }.
  The data will be written to "ret" using "<<" method.
  This method returns response header (Hash) and "ret".
d59 24
d91 1
a91 1
    def get( path, u_header = nil, ret = '' )
d93 11
a103 2
      header = connecting( u_header ) {
        @@command.get ret, edit_path(path), u_header
d106 15
a120 1
      return header, ret
d123 7
a129 1
    def head( path, u_header = nil )
d131 25
a155 2
      header = connecting( u_header ) {
        @@command.head edit_path(path), u_header
d165 14
d182 4
a185 1
        @@command.head '/', { 'Connection' => 'Close' }
d189 1
a189 1
    def connecting( u_header )
d191 4
d196 1
d203 1
d205 1
a205 2
      header = yield

d209 1
a209 2

      header
d258 14
a289 3
    def get( ret, path, u_header = nil )
      header = get_response(
        sprintf( 'GET %s HTTP/%s', path, HTTPVersion ), u_header )
d291 6
a296 13
      if chunked? header then
        clen = read_chunked_body( ret )
        header.delete 'transfer-encoding'
        header[ 'content-length' ] = "Content-Length: #{clen}"
      else
        if clen = content_length( header ) then
          @@socket.read clen, ret
        else
          @@socket.read_all ret
        end
      end

      header
d299 3
a301 3

    def head( path, u_header = nil )
      get_response sprintf( 'HEAD %s HTTP/%s', path, HTTPVersion ), u_header
d304 3
a306 4

    # not work
    def post( path, u_header = nil )
      get_response sprintf( 'POST %s HTTP/%s', path, HTTPVersion ), u_header
a308 4
    # not work
    def put( path, u_header = nil )
      get_response sprintf( 'PUT %s HTTP/%s', path, HTTPVersion ), u_header
    end
d317 41
d361 12
a372 6
    def get_response( line, u_header )
      @@socket.writeline line
      write_header u_header
      rep = get_reply
      header = read_header
      reply_must rep, SuccessCode
a373 2
      header
    end
d384 1
d389 22
a410 1
                when ?1 then SuccessCode
a412 2
              when ?2 then SuccessCode
              when ?3 then RetryCode
d417 27
a443 1
      klass.new( status, discrip )
a464 57
    end


    def read_header
      header = {}
      while true do
        line = @@socket.readline
        break if line.empty?
        /\A[^:]+/ === line
        nm = $&
        nm.strip!
        nm.downcase!
        header[ nm ] = line
      end

      header
    end

    def write_header( user )
      if user then
        header = @@in_header.dup.update user
      else
        header = @@in_header
      end
      header.each do |n,v|
        @@socket.writeline n + ': ' + v
      end
      @@socket.writeline ''

      if tmp = header['Connection'] then
        /close/i === tmp
      else
        false
      end
    end

    def read_chunked_body( ret )
      line = nil
      len = nil
      total = 0

      while true do
        line = @@socket.readline
        unless /[0-9a-hA-H]+/ === line then
          raise HTTPBadResponse, "chunk size not given"
        end
        len = $&.hex
        break if len == 0
        @@socket.read( len, ret ); total += len
        @@socket.read 2   # \r\n
      end
      while true do
        line = @@socket.readline
        break if line.empty?
      end

      total
@


1.8
log
@Version 1.1.6

o  all:  use 'attr_reader/writer' instead of 'attr'
o  http.rb:  get/head allow implicit 'start'
o  http.rb:  change connection state algorithm
o  http.rb:  process user header before write
o  protocol.rb:  refine start/finish
o  protocol.rb:  Command#last_reply
o  protocol.rb:  ReplyCode.error!
@
text
@d103 1
a103 1
      yield
d108 2
@


1.7
log
@o  session.rb -> protocol.rb
o  write, write_pendstr takes block
o  smtp.ready
o  popmail.pop takes block
@
text
@d6 1
a6 1
This file is derived from http-access.rb
d25 1
a25 1
= HTTP class
d65 2
a66 1
      header = connecting {
d69 1
d74 2
a75 1
      connecting {
d78 2
d86 14
a99 2
    def connecting
      if @@socket.closed? then
a101 2
      header = yield
      @@socket.close unless keep_alive? header
d103 5
a107 1
      header
d111 2
a112 2
      if str = header[ 'connection' ] then
        if /\Aconnection:\s*keep-alive/i === str then
d116 1
a116 1
        if @@http_version == '1.1' then
d124 6
a129 4
    
    def do_finish
      unless @@command.error_occured or @@socket.closed? then
        head '/', { 'Connection' => 'Close' }
d133 1
a133 1

d172 1
a172 1
    attr :http_version
a218 6
    def do_quit
      unless @@socket.closed? then
        @@socket.close
      end
    end

d249 1
a249 1
              else UnknownCode
@


1.6
log
@Version 1.1.4

o  (HTTP) allow no content-length data
@
text
@d13 1
a13 1
require 'net/session'
d178 9
a186 1
    # def put
@


1.5
log
@o  remove RD white lines
@
text
@a59 2
    Version = '1.1.3'

d144 1
a144 1
      @@in_header[ 'Connection' ] = 'keep-alive'
d162 5
a166 1
        @@socket.read content_length( header ), ret
d234 1
a234 1
        raise HTTPBadResponce, "content-length not given"
d237 1
a237 1
        raise HTTPBadResponce, "content-length format error"
d294 1
a294 1
          raise HTTPBadResponce, "chunk size not given"
@


1.5.2.1
log
@net/ version 1.1.3 for ruby 1.4
@
text
@@


1.5.2.2
log
@Version 1.1.4

o (HTTP) allow no content-length message
@
text
@d60 2
d146 1
a146 1
      @@in_header[ 'Connection' ] = 'Keep-Alive'
d164 1
a164 5
        if clen = content_length( header ) then
          @@socket.read clen, ret
        else
          @@socket.read_all ret
        end
d232 1
a232 1
        return nil
d235 1
a235 1
        raise HTTPBadResponse, "content-length format error"
d292 1
a292 1
          raise HTTPBadResponse, "chunk size not given"
@


1.5.2.3
log
@version 1.1.7 for ruby-1.4
protocol.rb smtp.rb pop.rb http.rb
@
text
@d6 1
a6 1
This file is derived from "http-access.rb".
d13 1
a13 1
require 'net/protocol'
d25 1
a25 1
= class HTTP
d65 1
a65 2
      u_header ||= {}
      header = connecting( u_header ) {
a67 1

d72 1
a72 2
      u_header ||= {}
      header = connecting( u_header ) {
a74 2

      header
d81 2
a82 14
    # called when connecting
    def do_finish
      unless @@socket.closed? then
        @@command.head '/', { 'Connection' => 'Close' }
      end
    end

    def connecting( u_header )
      u_header = procheader( u_header )

      if not @@socket then
        u_header['Connection'] = 'Close'
        start
      elsif @@socket.closed? then
a84 1

d86 1
a86 4

      unless keep_alive? u_header then
        @@socket.close
      end
d92 2
a93 2
      if str = header['Connection'] then
        if /\A\s*keep-alive/i === str then
d97 1
a97 1
        if @@command.http_version == '1.1' then
d105 4
a108 6
    def procheader( h )
      new = {}
      h.each do |k,v|
        arr = k.split('-')
        arr.each{|i| i.capitalize! }
        new[ arr.join('-') ] = v
d112 1
a112 1
    
d151 1
a151 1
    attr_reader :http_version
d178 1
a178 9
    # not work
    def post( path, u_header = nil )
      get_response sprintf( 'POST %s HTTP/%s', path, HTTPVersion ), u_header
    end

    # not work
    def put( path, u_header = nil )
      get_response sprintf( 'PUT %s HTTP/%s', path, HTTPVersion ), u_header
    end
d190 6
d226 1
a226 1
              else         UnknownCode
@


1.5.2.4
log
@protocol.rb/smtp.rb/pop.rb/http.rb 1.1.8
o  http.rb:  post, get2, post2, get_body
@
text
@d41 1
a41 2
: get( path, header = nil, dest = '' )
: get( path, header = nil ) {|str| .... }
d43 3
a45 5
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
  Data is written to "dest" by using "<<" method.
  This method returns response header (Hash) and "dest".

  If called as iterator, give a part String of entity body.
a55 24
: post( path, data, header = nil, dest = '' )
: post( path, data, header = nil ) {|str| .... }
  post "data"(must be String now) to "path" (and get entity body).
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
  Data is written to "dest" by using "<<" method.
  This method returns response header (Hash) and "dest".

  If called as iterator, give a part String of entity body.

  ATTENTION: entity body could be empty

: get2( path, header = nil )
  send GET request for "path".
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
  This method returns response header (Hash).

: get_body( dest = '' )
: get_body {|str| .... }
  gets entity body of forwarded 'get2' or 'post2' methods.
  Data is written in "dest" by using "<<" method.
  This method returns "dest".

  If called as iterator, give a part String of entity body.

d64 1
a64 1
    def get( path, u_header = nil, dest = nil, &block )
d66 2
a67 11
      if block then
        dest = ReadAdapter.new( block )
        ret = nil
      else
        dest = ret =  ''
      end
      resp = nil
      connecting( u_header ) {
        @@command.get edit_path(path), u_header
        resp = @@command.get_response
        @@command.try_get_body( resp, dest )
d70 1
a70 15
      return resp['http-header'], ret
    end

    def get2( path, u_header = {} )
      only_header( :get, path, u_header )
    end

    def get_body( dest = '', &block )
      if block then
        dest = ReadAdapter.new( block )
      end
      @@command.try_get_body @@response, dest
      ensure_termination @@u_header

      dest
d73 1
a73 7
    def head( path, u_header = {} )
      ret = only_header( :head, path, u_header )['http-header']
      ensure_termination u_header
      ret
    end

    def post( path, data, u_header = nil, dest = nil, &block )
d75 2
a76 25
      if block then
        dest = ReadAdapter.new( block )
        ret = nil
      else
        dest = ret = ''
      end
      resp = nil
      connecting( u_header, true ) {
        @@command.post path, u_header, data
        resp = @@command.get_response
        @@command.try_get_body( resp, dest )
      }

      return resp['http-header'], ret
    end

    def post2( path, data, u_header = {} )
      only_header :post, path, u_header, data
    end

    # not tested because I could not setup apache  (__;;;
    def put( path, src = nil, u_header = {}, &block )
      u_header ||= u_header
      connecting( u_header, true ) {
        @@command.put path, u_header, src, dest
a85 14
    def only_header( mid, path, u_header, data = nil )
      @@u_header = u_header ?  procheader(u_header) : {}
      @@response = nil
      ensure_connection @@u_header
      if data then
        @@command.send mid, edit_path(path), @@u_header, data
      else
        @@command.send mid, edit_path(path), @@u_header
      end
      @@response = @@command.get_response
      @@response['http-header']
    end


d89 1
a89 4
        begin
          @@command.head '/', { 'Connection' => 'Close' }
        rescue EOFError
        end
d93 1
a93 1
    def connecting( u_header, putp = false )
a94 4
      ensure_connection u_header
      yield
      ensure_termination u_header
    end
a95 1
    def ensure_connection( u_header )
a101 1
    end
d103 2
a104 1
    def ensure_termination( u_header )
d108 2
a109 1
      @@u_header = @@response = nil
a157 14
  class HTTPSuccessCode < SuccessCode; end
  class HTTPCreatedCode < SuccessCode; end
  class HTTPAcceptedCode < SuccessCode; end
  class HTTPNoContentCode < SuccessCode; end
  class HTTPResetContentCode < SuccessCode; end
  class HTTPPartialContentCode < SuccessCode; end

  class HTTPMultipleChoiceCode < RetryCode; end
  class HTTPMovedPermanentlyCode < RetryCode; end
  class HTTPMovedTemporarilyCode < RetryCode; end
  class HTTPNotModifiedCode < RetryCode; end
  class HTTPUseProxyCode < RetryCode; end


d176 3
d180 13
a192 2
    def get( path, u_header )
      request sprintf('GET %s HTTP/%s', path, HTTPVersion), u_header
d194 4
a197 3
      
    def head( path, u_header )
      request sprintf('HEAD %s HTTP/%s', path, HTTPVersion), u_header
d200 4
a203 3
    def post( path, u_header, data )
      request sprintf('POST %s HTTP/%s', path, HTTPVersion), u_header
      @@socket.write data
d206 3
a208 3
    def put( path, u_header, src )
      request sprintf('PUT %s HTTP/%s', path, HTTPVersion), u_header
      @@socket.write_bin src
a210 1

d218 6
a223 1
    def get_response
d225 1
a225 10
      rep = get_reply while ContinueCode === rep
      header = {}
      while true do
        line = @@socket.readline
        break if line.empty?
        nm = /\A[^:]+/.match( line )[0].strip.downcase
        header[nm] = line
      end

      rep['http-header'] = header
d228 1
a228 1
      rep
a230 41
    def get_body( rep, dest )
      header = rep['http-header']
      if chunked? header then
        read_chunked( dest, header )
      else
        if clen = content_length( header ) then
          @@socket.read clen, dest
        else
          ###
          ### "multipart/bytelenges" check should be done here ...
          ###
          @@socket.read_all dest
        end
      end
    end

    def try_get_body( rep, dest )
      rep = get_reply while ContinueCode === rep
      return nil unless rep['body-exist']

      get_body rep, dest
    end


    private


    def request( req, u_header )
      @@socket.writeline req
      if u_header then
        header = @@in_header.dup.update( u_header )
      else
        header = @@in_header
      end
      header.each do |n,v|
        @@socket.writeline n + ': ' + v
      end
      @@socket.writeline ''
    end


a239 1
      be = false
d244 1
a244 22
                when ?1 then HTTPSuccessCode
                else         UnknownCode
                end
              when ?2 then
                case status[2]
                when ?0 then be = true;  HTTPSuccessCode
                when ?1 then be = false; HTTPSuccessCode
                when ?2 then be = true;  HTTPSuccessCode
                when ?3 then be = true;  HTTPSuccessCode
                when ?4 then be = false; HTTPNoContentCode
                when ?5 then be = false; HTTPResetContentCode
                when ?6 then be = true;  HTTPPartialContentCode
                else         UnknownCode
                end
              when ?3 then
                case status[2]
                when ?0 then be = true;  HTTPMultipleChoiceCode
                when ?1 then be = true;  HTTPMovedPermanentryCode
                when ?2 then be = true;  HTTPMovedTemporarilyCode
                when ?3 then be = true;  HTTPMovedPermanentryCode
                when ?4 then be = false; HTTPNotModifiedCode
                when ?5 then be = false; HTTPUseProxyCode
d247 2
d253 38
a290 3
      code = klass.new( status, discrip )
      code['body-exist'] = be
      code
d293 19
a311 1
    def read_chunked( ret, header )
d331 1
a331 23
      header.delete 'transfer-encoding'
      header[ 'content-length' ] = "Content-Length: #{total}"
    end

    
    def content_length( header )
      unless str = header[ 'content-length' ] then
        return nil
      end
      unless /\Acontent-length:\s*(\d+)/i === str then
        raise HTTPBadResponse, "content-length format error"
      end
      $1.to_i
    end

    def chunked?( header )
      if str = header[ 'transfer-encoding' ] then
        if /\Atransfer-encoding:\s*chunked/i === str then
          return true
        end
      end

      false
@


1.5.2.5
log
@protocol.rb smtp.rb pop.rb http.rb for ruby 1.4 branch
@
text
@d92 1
a92 1
      u_header = procheader( u_header )
d109 1
a109 2
    def get2( path, u_header = nil )
      u_header = procheader( u_header )
d123 2
a124 3
    def head( path, u_header = nil )
      u_header = procheader( u_header )
      header = only_header( :head, path, u_header )
d126 1
a126 1
      header
d130 1
a130 1
      u_header = procheader( u_header )
a147 1
      u_header = procheader( u_header )
d152 2
a153 2
    def put( path, src = nil, u_header = nil, &block )
      u_header = procheader( u_header )
d166 1
a166 1
      @@u_header = u_header
d168 1
a168 1
      ensure_connection u_header
d170 1
a170 1
        @@command.send mid, edit_path(path), u_header, data
d172 1
a172 1
        @@command.send mid, edit_path(path), u_header
d190 1
d206 1
a206 1
      unless keep_alive? u_header and not @@socket.closed? then
a226 1
      return( {} ) unless h
d342 3
a344 3
          ##### "multipart/byteranges" check should be done here ...

          # now, length is designated by closing socket
a345 1
          @@socket.close
@


1.5.2.6
log
@o  all:  use "critical" to avoid duplicated command dispatch
o  http.rb:  change get2, post2 usage (HTTPWriter)
o  http.rb:  entity reading algorithm is better
o  http.rb:  more reply code (4xx, 5xx)
o  protocol.rb:  arguments of "connect" can be omitted
o  protocol.rb:  "quit" is not template method (now do_quit is removed)
o  protocol.rb:  ReplyCode.error_type was not work: using module_eval
@
text
@d61 1
a61 3
  post "data"(must be String now) to "path".
  If body exists, also get entity body.
  It is written to "dest" by using "<<" method.
d63 1
d66 1
a66 1
  If called as iterator, gives a part String of entity body.
d68 3
a70 1
: get2( path, header = nil ) {|writer| .... }
d73 1
a73 1
  This method gives HTTPWriter object to block.
d81 1
a81 25
  If called as iterator, gives a part String of entity body.

: post2( path, data, header = nil ) {|writer| .... }
  post "data"(must be String now) to "path".
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
  This method gives HTTPWriter object to block.


= class HTTPWriter

== Methods

: header
  HTTP header.

: response
  ReplyCode object.

: entity( dest = '' )
: body( dest = '' )
  entity body.

: entity {|str| ... }
  get entity body by using iterator.
  If this method is called twice, block is not called.
d90 3
a92 1
    def HTTP.procdest( dest, block )
d94 2
a95 1
        return ReadAdapter.new( block ), nil
d97 1
a97 2
        dest ||= ''
        return dest, dest
a98 6
    end


    def get( path, u_header = nil, dest = nil, &block )
      u_header = procheader( u_header )
      dest, ret = HTTP.procdest( dest, block )
d103 1
a103 1
        @@command.get_body( resp, dest )
d111 1
a111 6
      connecting( u_header ) {
        @@command.get edit_path(path), u_header
        tmp = HTTPWriter.new( @@command )
        yield tmp
        tmp.off
      }
a113 1
=begin c
d118 1
a118 1
      @@command.get_body @@response, dest
a122 1
=end
d126 3
a128 7
      resp = nil
      connecting( u_header ) {
        @@command.head( edit_path(path), u_header )
        resp = @@command.get_response_no_body
      }

      resp['http-header']
d133 6
a138 1
      dest, ret = HTTP.procdest( dest, block )
d140 2
a141 2
      connecting( u_header ) {
        @@command.post edit_path(path), u_header, data
d143 1
a143 1
        @@command.get_body( resp, dest )
d149 1
a149 1
    def post2( path, data, u_header = nil )
d151 1
a151 6
      connecting( u_header ) {
        @@command.post edit_path(path), u_header, data
        tmp = HTTPWriter.new( @@command )
        yield tmp
        tmp.off
      }
d155 1
a155 1
    def put( path, src, u_header = nil )
d157 1
a157 2
      ret = ''
      connecting( u_header ) {
a158 2
        resp = @@comman.get_response
        @@command.get_body( resp, ret )
d161 1
a161 1
      return header, ret
a167 1
=begin c
d171 1
a171 1
      connecting u_header
a179 1
=end
d192 7
a198 1
    def connecting( u_header )
a204 6

      if iterator? then
        ret = yield
        ensure_termination u_header
        ret
      end
d261 12
a272 76
  class HTTPWriter

    def initialize( command )
      @@command = command
      @@response = @@header = @@entity = nil
    end

    def response
      unless @@resp then
        @@resp = @@command.get_response
      end
      @@resp
    end

    def header
      unless @@header then
        @@header = response['http-header']
      end
      @@header
    end

    def entity( dest = nil, &block )
      dest, ret = HTTP.procdest( dest, block )
      unless @@entity then
        @@entity = @@command.get_body( response, dest )
      end
      @@entity
    end
    alias body entity

    def off
      entity
      @@command = nil
    end
  
  end


  class HTTPSwitchProtocol                < SuccessCode; end

  class HTTPOK                            < SuccessCode; end
  class HTTPCreated                       < SuccessCode; end
  class HTTPAccepted                      < SuccessCode; end
  class HTTPNonAuthoritativeInformation   < SuccessCode; end
  class HTTPNoContent                     < SuccessCode; end
  class HTTPResetContent                  < SuccessCode; end
  class HTTPPartialContent                < SuccessCode; end

  class HTTPMultipleChoice                < RetryCode; end
  class HTTPMovedPermanently              < RetryCode; end
  class HTTPMovedTemporarily              < RetryCode; end
  class HTTPNotModified                   < RetryCode; end
  class HTTPUseProxy                      < RetryCode; end
  
  class HTTPBadRequest                    < RetryCode; end
  class HTTPUnauthorized                  < RetryCode; end
  class HTTPPaymentRequired               < RetryCode; end
  class HTTPForbidden                     < FatalErrorCode; end
  class HTTPNotFound                      < FatalErrorCode; end
  class HTTPMethodNotAllowed              < FatalErrorCode; end
  class HTTPNotAcceptable                 < FatalErrorCode; end
  class HTTPProxyAuthenticationRequired   < RetryCode; end
  class HTTPRequestTimeOut                < FatalErrorCode; end
  class HTTPConflict                      < FatalErrorCode; end
  class HTTPGone                          < FatalErrorCode; end
  class HTTPLengthRequired                < FatalErrorCode; end
  class HTTPPreconditionFailed            < FatalErrorCode; end
  class HTTPRequestEntityTooLarge         < FatalErrorCode; end
  class HTTPRequestURITooLarge            < FatalErrorCode; end
  class HTTPUnsupportedMediaType          < FatalErrorCode; end

  class HTTPNotImplemented                < FatalErrorCode; end
  class HTTPBadGateway                    < FatalErrorCode; end
  class HTTPServiceUnavailable            < FatalErrorCode; end
  class HTTPGatewayTimeOut                < FatalErrorCode; end
  class HTTPVersionNotSupported           < FatalErrorCode; end
a294 1
      return unless begin_critical
a298 1
      return unless begin_critical
a302 1
      return unless begin_critical
a307 1
      return unless begin_critical
d312 1
a318 3
    def quit
    end

d330 1
d332 1
a336 4
    def check_response( resp )
      reply_must resp, SuccessCode
    end

d339 7
d347 3
a349 16
      if rep['body-exist'] then
        if chunked? header then
          read_chunked( dest, header )
        else
          if clen = content_length( header ) then
            @@socket.read clen, dest
          else
            if false then # "multipart/byteranges" check should be done
            else
              if header['Connection'] and
                 /connection:\s*close/i === header['Connection'] then
                @@socket.read_all dest
                @@socket.close
              end
            end
          end
d352 1
a352 2
      end_critical
      reply_must rep, SuccessCode
d354 3
a356 2
      dest
    end
d358 1
a358 5
    def get_response_no_body
      resp = get_response
      end_critical
      reply_must resp, SuccessCode
      resp
a378 44
    CODE_TO_CLASS = {
      '100' => [ContinueCode,                        false],
      '100' => [HTTPSwitchProtocol,                  false],

      '200' => [HTTPOK,                              true],
      '201' => [HTTPCreated,                         true],
      '202' => [HTTPAccepted,                        true],
      '203' => [HTTPNonAuthoritativeInformation,     true],
      '204' => [HTTPNoContent,                       false],
      '205' => [HTTPResetContent,                    false],
      '206' => [HTTPPartialContent,                  true],

      '300' => [HTTPMultipleChoice,                  true],
      '301' => [HTTPMovedPermanently,                true],
      '302' => [HTTPMovedTemporarily,                true],
      '303' => [HTTPMovedPermanently,                true],
      '304' => [HTTPNotModified,                     false],
      '305' => [HTTPUseProxy,                        false],

      '400' => [HTTPBadRequest,                      true],
      '401' => [HTTPUnauthorized,                    true],
      '402' => [HTTPPaymentRequired,                 true],
      '403' => [HTTPForbidden,                       true],
      '404' => [HTTPNotFound,                        true],
      '405' => [HTTPMethodNotAllowed,                true],
      '406' => [HTTPNotAcceptable,                   true],
      '407' => [HTTPProxyAuthenticationRequired,     true],
      '408' => [HTTPRequestTimeOut,                  true],
      '409' => [HTTPConflict,                        true],
      '410' => [HTTPGone,                            true],
      '411' => [FatalErrorCode,                      true],
      '412' => [HTTPPreconditionFailed,              true],
      '413' => [HTTPRequestEntityTooLarge,           true],
      '414' => [HTTPRequestURITooLarge,              true],
      '415' => [HTTPUnsupportedMediaType,            true],

      '500' => [FatalErrorCode,                      true],
      '501' => [HTTPNotImplemented,                  true],
      '502' => [HTTPBadGateway,                      true],
      '503' => [HTTPServiceUnavailable,              true],
      '504' => [HTTPGatewayTimeOut,                  true],
      '505' => [HTTPVersionNotSupported,             true]
    }

d388 33
a420 1
      klass, bodyexist = CODE_TO_CLASS[status] || [UnknownCode, true]
d422 1
a422 1
      code['body-exist'] = bodyexist
@


1.5.2.7
log
@protocol.rb smtp.rb pop.rb http.rb 1.1.12 for ruby 1.4 branch
@
text
@d18 4
a21 1
  class HTTPBadResponse < StandardError; end
d46 1
a46 1
  This method returns Net::HTTPResponse object and "dest".
d53 1
a53 2
  This method returns Net::HTTPResponse object.
  You can http header from this object like:
d55 3
a57 4
    response['content-length']   #-> '2554'
    response['content-type']     #-> 'text/html'
    response['Content-Type']     #-> 'text/html'
    response['CoNtEnT-tYpe']     #-> 'text/html'
d65 1
a65 1
  This method returns Net::HTTPResponse object and "dest".
d72 9
a80 1
  This method gives HTTPReadAdapter object to block.
d85 1
a85 1
  This method gives HTTPReadAdapter object to block.
d88 1
a88 1
= class HTTPResponse
d92 2
a93 17
HTTP response object.
All "key" is case-insensitive.

: code
  HTTP result code. ex. '302'

: message
  HTTP result message. ex. 'Not Found'

: self[ key ]
  returns header field for "key".
  for HTTP, value is a string like 'text/plain'(for Content-Type),
  '2045'(for Content-Length), 'bytes 0-1024/10024'(for Content-Range).
  Multiple header had be joined by HTTP1.1 scheme.

: self[ key ] = val
  set field value for "key".
a94 9
: key?( key )
  true if key is exist


= class HTTPReadAdapter

== Methods

: header
d96 1
a96 1
  Net::HTTPResponse object
d100 1
a100 1
  entity body
d133 1
a133 1
      return resp, ret
d140 1
a140 1
        tmp = HTTPReadAdapter.new( @@command )
d146 11
d166 1
a166 1
      resp
d179 1
a179 1
      return resp, ret
d186 1
a186 1
        tmp = HTTPReadAdapter.new( @@command )
a195 1
      resp = nil
d202 1
a202 1
      return resp, ret
d209 16
d258 2
a259 2
      if header.key? 'connection' then
        if /\A\s*keep-alive/i === header['connection'] then
d304 1
a304 1
  class HTTPReadAdapter
d308 8
a315 1
      @@header = @@body = nil
d320 1
a320 1
        @@header = @@command.get_response
a323 1
    alias response header
d325 1
a325 1
    def body( dest = nil, &block )
d327 2
a328 2
      unless @@body then
        @@body = @@command.get_body( response, dest )
d330 1
a330 1
      @@body
d332 1
a332 1
    alias entity body
d335 1
a335 1
      body
d342 1
a342 7
  class HTTPResponse < Response

    def initialize( code_type, code, msg )
      super
      @@data = {}
      @@http_body_exist = true
    end
d344 13
a356 57
    attr_accessor :http_body_exist

    def []( key )
      @@data[ key.downcase ]
    end

    def []=( key, val )
      @@data[ key.downcase ] = val
    end

    def each( &block )
      @@data.each( &block )
    end

    def each_key( &block )
      @@data.each_key( &block )
    end

    def each_value( &block )
      @@data.each_value( &block )
    end

    def delete( key )
      @@data.delete key.downcase
    end

    def key?( key )
      @@data.key? key.downcase
    end

    def to_hash
      @@data.dup
    end

  end


  HTTPSuccessCode                   = SuccessCode.mkchild
  HTTPRetriableCode                 = RetriableCode.mkchild
  HTTPFatalErrorCode                = FatalErrorCode.mkchild


  HTTPSwitchProtocol                = HTTPSuccessCode.mkchild

  HTTPOK                            = HTTPSuccessCode.mkchild
  HTTPCreated                       = HTTPSuccessCode.mkchild
  HTTPAccepted                      = HTTPSuccessCode.mkchild
  HTTPNonAuthoritativeInformation   = HTTPSuccessCode.mkchild
  HTTPNoContent                     = HTTPSuccessCode.mkchild
  HTTPResetContent                  = HTTPSuccessCode.mkchild
  HTTPPartialContent                = HTTPSuccessCode.mkchild

  HTTPMultipleChoice                = HTTPRetriableCode.mkchild
  HTTPMovedPermanently              = HTTPRetriableCode.mkchild
  HTTPMovedTemporarily              = HTTPRetriableCode.mkchild
  HTTPNotModified                   = HTTPRetriableCode.mkchild
  HTTPUseProxy                      = HTTPRetriableCode.mkchild
d358 22
a379 22
  HTTPBadRequest                    = HTTPRetriableCode.mkchild
  HTTPUnauthorized                  = HTTPRetriableCode.mkchild
  HTTPPaymentRequired               = HTTPRetriableCode.mkchild
  HTTPForbidden                     = HTTPFatalErrorCode.mkchild
  HTTPNotFound                      = HTTPFatalErrorCode.mkchild
  HTTPMethodNotAllowed              = HTTPFatalErrorCode.mkchild
  HTTPNotAcceptable                 = HTTPFatalErrorCode.mkchild
  HTTPProxyAuthenticationRequired   = HTTPRetriableCode.mkchild
  HTTPRequestTimeOut                = HTTPFatalErrorCode.mkchild
  HTTPConflict                      = HTTPFatalErrorCode.mkchild
  HTTPGone                          = HTTPFatalErrorCode.mkchild
  HTTPLengthRequired                = HTTPFatalErrorCode.mkchild
  HTTPPreconditionFailed            = HTTPFatalErrorCode.mkchild
  HTTPRequestEntityTooLarge         = HTTPFatalErrorCode.mkchild
  HTTPRequestURITooLarge            = HTTPFatalErrorCode.mkchild
  HTTPUnsupportedMediaType          = HTTPFatalErrorCode.mkchild

  HTTPNotImplemented                = HTTPFatalErrorCode.mkchild
  HTTPBadGateway                    = HTTPFatalErrorCode.mkchild
  HTTPServiceUnavailable            = HTTPFatalErrorCode.mkchild
  HTTPGatewayTimeOut                = HTTPFatalErrorCode.mkchild
  HTTPVersionNotSupported           = HTTPFatalErrorCode.mkchild
d434 3
a436 3
      resp = get_reply
      resp = get_reply while ContinueCode === resp

d440 2
a441 12

        m = /\A([^:]+):\s*(.*)/p.match( line )
        unless m then
          raise HTTPBadResponse, 'wrong header line format'
        end
        nm = m[1]
        line = m[2]
        if resp.key? nm then
          resp[nm] << ', ' << line
        else
          resp[nm] = line
        end
d443 1
d445 1
a445 1
      resp
d452 6
a457 4
    def get_body( resp, dest )
      if resp.http_body_exist then
        if chunked? resp then
          read_chunked( dest, resp )
d459 1
a459 2
          clen = content_length( resp )
          if clen then
d462 1
a462 3
            clen = range_length( resp )
            if clen then
              @@socket.read clen, dest
d464 2
a465 2
              tmp = resp['connection']
              if tmp and /close/i === tmp then
d474 1
a474 1
      reply_must resp, SuccessCode
d504 1
a504 1
    HTTPCODE_TO_OBJ = {
d550 1
a550 2
      m = /\AHTTP\/(\d+\.\d+)?\s+(\d\d\d)\s*(.*)\z/i.match( str )
      unless m then
d553 3
a555 3
      @@http_version = m[1]
      status  = m[2]
      discrip = m[3]
d557 4
a560 4
      klass, bodyexist = HTTPCODE_TO_OBJ[status] || [UnknownCode, true]
      resp = HTTPResponse.new( klass, status, discrip )
      resp.http_body_exist = bodyexist
      resp
d570 1
a570 2
        m = /[0-9a-hA-H]+/.match( line )
        unless m then
d573 1
a573 1
        len = m[0].hex
d584 1
a584 1
      header[ 'content-length' ] = total.to_s
d589 5
a593 8
      if header.key? 'content-length' then
        m = /\d+/.match( header['content-length'] )
        unless m then
          raise HTTPBadResponse, 'wrong Content-Length format'
        end
        m[0].to_i
      else
        nil
d595 1
d599 4
a602 5
      str = header[ 'transfer-encoding' ]
      if str and /(\A|\s+)chunked(?:\s+|\z)/i === str then
        true
      else
        false
a603 1
    end
d605 1
a605 16
    def range_length( header )
      if header.key? 'content-range' then
        m = %r<bytes\s+(\d+)-(\d+)/\d+>.match( header['content-range'] )
        unless m then
          raise HTTPBadResponse, 'wrong Content-Range format'
        end
        l = m[2].to_i
        u = m[1].to_i
        if l > u then
          nil
        else
          u - l
        end
      else
        nil
      end
@


1.5.2.8
log
@{protocol,smtp,pop,http}.rb 1.1.13 for ruby 1.4 branch
@
text
@a172 1

a195 1

d595 1
a595 1
        raise HTTPBadResponse, "wrong status line: #{str}"
d608 1
d616 1
a616 1
          raise HTTPBadResponse, "wrong chunk size line: #{line}"
d623 3
a625 2
      until @@socket.readline.empty? do
        ;
d627 3
d647 1
a647 1
      if str and /(?:\A|\s+)chunked(?:\s+|\z)/i === str then
@


1.5.2.9
log
@{protocol,smtp,pop,http}.rb for ruby 1.4 branch
@
text
@d68 1
a68 1
: get2( path, header = nil ) {|adapter| .... }
d73 1
a73 1
: post2( path, data, header = nil ) {|adapter| .... }
d87 1
a87 1
  HTTP result code. For example, '302'
d90 1
a90 1
  HTTP result message. For example, 'Not Found'
a103 3
: each {|name,value| .... }
  iterate for each field name and value pair

d113 1
d115 1
a115 2
: entity( dest = '' )
  entity body. A body is written to "dest" using "<<" method.
d117 1
a117 1
: body {|str| ... }
d119 1
a119 2
  If this method is called twice, block is not called and
  returns first "dest".
d139 10
a148 3
      resp = get2( path, u_header ) {|f| dest = f.entity( dest, &block ) }
      resp.value
      return resp, dest
a152 1
      resp = nil
d157 1
a157 1
        resp = tmp.off
a158 2

      resp
a162 6
      resp = head2( path, u_header )
      resp.value
      resp
    end

    def head2( path, u_header = nil )
d175 10
a184 4
      resp = post2( path, data, u_header ) {|f|
                    dest = f.entity( dest, &block ) }
      resp.value
      return resp, dest
a188 1
      resp = nil
d193 1
a193 1
        resp = tmp.off
a194 2

      resp
a199 7
      ret = nil
      resp = put2( path, src, u_header ) {|f| ret = f.entity }
      resp.value
      return resp, ret
    end

    def put2( path, src, u_header = nil )
d205 2
a206 3
        tmp = HTTPReadAdapter.new( @@command )
        yield tmp
        resp = tmp.off
d209 1
a209 1
      resp
a321 1
      @@header
d329 2
a330 2
    def initialize( code_type, bexist, code, msg )
      super( code_type, code, msg )
d332 1
a332 1
      @@http_body_exist = bexist
d335 1
a335 1
    attr_reader :http_body_exist
a368 4
    def value
      error! unless SuccessCode === self
    end

a447 1
      u_header[ 'Content-Length' ] = data.size.to_s
d492 4
d519 1
d527 1
d579 1
a579 1
      '411' => [HTTPFatalErrorCode,                  true],
d585 1
a585 1
      '500' => [HTTPFatalErrorCode,                  true],
d604 3
a606 1
      HTTPResponse.new( klass, bodyexist, status, discrip )
@


1.5.2.10
log
@{protocol,smtp,pop,http}.rb 1.1.15 for ruby 1.4 branch
@
text
@a72 6
: head2( path, header = nil )
  send HEAD request for "path".
  "header" must be a Hash like { 'Accept' => '*/*', ... }.
  The difference between "head" method is that
  "head2" does not raise exceptions.

d148 8
a155 3
    def get2( path, u_header = nil, &block )
      connecting( u_header, block ) {|uh|
        @@command.get edit_path(path), uh
d157 2
d169 5
a173 3
      connecting( u_header, nil ) {|uh|
        @@command.head edit_path(path), uh
        @@command.get_response_no_body
d175 2
d187 8
a194 3
    def post2( path, data, u_header = nil, &block )
      connecting( u_header, block ) {|uh|
        @@command.post edit_path(path), uh, data
d196 2
d209 9
a217 3
    def put2( path, src, u_header = nil, &block )
      connecting( u_header, block ) {|uh|
        @@command.put path, uh, src
d219 2
d230 4
a233 1
        head2 '/', { 'Connection' => 'close' }
d237 1
a237 2
    def connecting( u_header, ublock )
      u_header = procheader( u_header )
d239 1
a239 1
        u_header['Connection'] = 'close'
d245 4
a248 5
      resp = yield( u_header )
      if ublock then
        adapter = HTTPReadAdapter.new( @@command )
        ublock.call adapter
        resp = adapter.off
d250 4
a253 2
      
      unless keep_alive? u_header, resp then
d256 1
a256 2

      resp
d259 3
a261 7
    def keep_alive?( header, resp )
      if resp.key? 'connection' then
        if /keep-alive/i === resp['connection'] then
          return true
        end
      elsif header.key? 'Connection' then
        if /\A\s*keep-alive/i === header['Connection'] then
@


1.5.2.11
log
@protocol.rb version 1.1.17 for ruby 1.4 branch
@
text
@d423 1
a423 5
      if sock.port == HTTP.port
        @@in_header[ 'Host' ] = sock.addr
      else
        @@in_header[ 'Host' ] = sock.addr + ':' + sock.port
      end
a507 6
              else
                tmp = resp['proxy-connection']
                if tmp and /close/i === tmp then
                  @@socket.read_all dest
                  @@socket.close
                end
@


1.5.2.12
log
@o  protocol.rb, http.rb, smtp.rb, pop.rb:  update RD documents
@
text
@d26 2
a27 6
: new( address = 'localhost', port = 80 )
  creates a new Net::HTTP object.

: start( address = 'localhost', port = 80 )
: start( address = 'localhost', port = 80 ) {|http| .... }
  equals to Net::HTTP.new( address, port ).start
d30 1
a30 1
  HTTP default port, 80
d33 2
a34 1
  Command class for Net::HTTP, HTTPCommand
a36 7

: start
: start {|http| .... }
  creates a new Net::HTTP object and starts HTTP session.

  When this method is called as iterator, gives HTTP object to block
  and close HTTP session after block call finished.
@


1.5.2.13
log
@p  http.rb:  do not use Regexp "p" option
@
text
@d489 1
a489 1
        m = /\A([^:]+):\s*/.match( line )
d494 1
a494 1
        line = m.post_match
@


1.5.2.14
log
@o  http.rb:  not close connection in get_body,
   Only connection() closes socket
@
text
@d159 1
a159 1
      resp = get2( path, u_header ) {|f| dest = f.body( dest, &block ) }
d187 1
a187 1
                    dest = f.body( dest, &block ) }
d202 1
a202 1
      resp = put2( path, src, u_header ) {|f| ret = f.body }
a251 4
      elsif resp.key? 'proxy-connection' then
        if /keep-alive/i === resp['proxy-connection'] then
          return true
        end
d253 1
a253 1
        if /keep-alive/i === header['Connection'] then
d521 1
d526 1
@


1.5.2.15
log
@o  protocol.rb:  ProtocolError can take data
o  http.rb:  raise exception with response
@
text
@a56 14
  Note:
  If status is not 2xx(success), ProtocolError exception is
  raised. At that time, you can get Response object from 
  execption object. (same in head/post)

    ex.

    begin
      head, body = http.get(...)
    rescue ProtoRetriableError
      response = $!.data
      ...
    end

d378 1
a378 3
      unless SuccessCode === self then
        error! self
      end
@


1.5.2.16
log
@o  http.rb:  body is in HTTPResponse object
@
text
@a354 1
      @@body = nil
a357 1
    attr_accessor :body
a525 2
      resp.body = dest

@


1.5.2.17
log
@o  protocol.rb, smtp.rb, pop.rb, http.rb:  define all#inspect()
o  protocol.rb, smtp.rb, pop.rb, http.rb:  modify/add documents
@
text
@d11 10
d53 1
a53 4
  This method returns Net::HTTPResponse object, and "dest".

    # example
    response, body = http.get( '/index.html' )
d62 2
a63 1
    # example
d65 2
a66 2
      response, body = http.get(...)
    rescue Net::ProtoRetriableError
a70 1

a96 8
    ex.
    
    http.get2( '/index.html' ) do |f|
      # f is a HTTPReadAdapter object
      f.header
      f.body
    end

a102 6
    ex.
    
    http.head2( '/index.html' ) do |f|
      f.header
    end

a107 6
    ex.
    
    http.post2( '/index.html', 'data data data...' ) do |f|
      f.header
      f.body
    end
d109 1
d111 1
a111 1
= class HTTPResponse
a115 2
== Methods

a136 3
: body
  "dest" argument for HTTP#get, post, put

a156 8
require 'net/protocol'


module Net

  class HTTPBadResponse < StandardError; end


a322 4
    def inspect
      "#<#{type}>"
    end

a360 4
    def inspect
      "#<Net::HTTPResponse #{code}>"
    end

d466 1
d469 1
a469 4
    def inspect
      "#<Net::HTTPCommand>"
    end

@


1.5.2.18
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.24.
* lib/net/protocol.rb: modified each_crlf_line again.
* lib/net/protocol.rb: do_write_beg,do_write_end -> writing{}
  do_write_do -> do_write
* lib/net/http.rb: can make proxy connection by passing
  addresses to HTTP.new, start.
* lib/net/http.rb: HTTP.new_implementation, old_implementation:
  can use 1.2 implementation of head, get, post, put.
  (see document)
@
text
@d16 1
a16 1
: new( address = 'localhost', port = 80, proxy_addr = nil, proxy_port = nil )
a17 2
  if proxy_addr is given, this method is equals to
  Net::HTTP::Proxy(proxy_addr,proxy_port).
d19 3
a21 3
: start( address = 'localhost', port = 80, proxy_addr = nil, proxy_port = nil )
: start( address = 'localhost', port = 80, proxy_addr = nil, proxy_port = nil ) {|http| .... }
  is equals to Net::HTTP.new( address, port, proxy_addr, proxy_port ).start(&block)
d130 5
a134 2
: body
  the entity body. ("dest" argument for HTTP#get, post, put)
d151 2
a152 2
: code
  HTTP result code. For example, '302'
a153 2
: message
  HTTP result message. For example, 'Not Found'
a171 31

= http.rb version 1.2 features

You can use these 1.2 features by calling method
Net::HTTP.new_implementation. Or you want to use 1.1 feature,
call Net::HTTP.old_implementation.

Now old_impl is default and if new_impl was called then Net::HTTP
changes self into new implementation.  In 1.2, new_impl is default
and if old_impl was called then changes self into old implementation.

== Warning!!!

You can call new_implementation/old_implementation any times
but CANNOT call both of them at the same time.
You must use one implementation in one application (process).

== Method

: get( path, u_header = nil )
: get( path, u_header = nil ) {|str| .... }
get document from "path" and returns HTTPResponse object.

: head( path, u_header = nil )
get only document header from "path" and returns HTTPResponse object.

: post( path, data, u_header = nil )
: post( path, data, u_header = nil ) {|str| .... }
post "data" to "path" entity and get document,
then returns HTTPResponse object.

d187 6
a192 19
    class << self

      def procdest( dest, block )
        if block then
          return ReadAdapter.new( block ), nil
        else
          dest ||= ''
          return dest, dest
        end
      end

      alias orig_new new

      def new( address = nil, port = nil, p_addr = nil, p_port = nil )
        (p_addr ? self::Proxy(p_addr, p_port) : self).orig_new( address, port )
      end

      def start( address = nil, port = nil, p_addr = nil, p_port = nil, &block )
        new( address, port, p_addr, p_port ).start( &block )
a193 1

a195 44
    @@new_impl = false

    def HTTP.new_implementation
      return if @@new_impl
      @@new_impl = true
      module_eval %^

      undef head
      alias head head2
      undef head2

      alias old_get2 get2
      undef get2
      undef get

      def get( path, u_header = nil, dest = nil, &block )
        old_get2( path, u_header ) {|f| f.body( dest, &block ) }
      end

      alias old_post2 post2
      undef post2
      undef post

      def post( path, data, u_header = nil, dest = nil, &block )
        old_post2( path, data, u_header ) {|f| f.body( dest, &block ) }
      end

      alias old_put2 put2
      undef put2
      undef put

      def put( path, src, u_header = nil )
        old_put2( path, src, u_header ) {|f| f.body }
      end

      ^
    end

    def HTTP.old_implementation
      if @@new_impl then
        raise RuntimeError, "http.rb is already switched to new implementation"
      end
    end
      
d240 2
a241 1
      resp = put2( path, src, u_header ) {|f| f.body }
d243 1
a243 1
      return resp, resp.body
@


1.5.2.19
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.26.
* lib/net/protocol.rb (finish): do nothing unless active.
* lib/net/http.rb: HTTP#{get,post}2 again (for new impl).
@
text
@d251 1
d253 2
d258 1
a258 1
        get2( path, u_header ) {|f| f.body( dest, &block ) }
d261 2
d266 1
a266 1
        post2( path, data, u_header ) {|f| f.body( dest, &block ) }
d269 2
d274 1
a274 1
        put2( path, src, u_header ) {|f| f.body }
@


1.4
log
@Net version 1.1.3

o  http.rb rd
o  Session -> Protocol
@
text
@a29 1
  
a32 1

a35 1

a41 1
  
a47 1
  
@


1.3
log
@Version 1.1.2

o  proxy, version 1
o  use fullpath shvar
@
text
@d8 3
d23 3
a25 1
class HTTPSession < Session
d27 1
a27 1
  Version = '1.1.2'
d29 3
a31 2
  session_setvar :port,         '80'
  session_setvar :command_type, 'Net::HTTPCommand'
d33 1
d35 3
a37 4
  def get( path = '/', header = nil, ret = '' )
    confirm_connection
    @@proto.get edit_path(path), header, ret
  end
d39 1
a39 4
  def head( path = '/', header = nil )
    confirm_connection
    @@proto.head edit_path(path), header
  end
d42 1
a42 1
  private
d44 6
d51 1
a51 5
  def confirm_connection
    if @@socket.closed? then
      @@socket.reopen
    end
  end
d53 16
a68 5
  def do_finish
    unless @@proto.error_occured or @@socket.closed? then
      head '/', { 'Connection' => 'Close' }
    end
  end
d71 6
a76 3
  def edit_path( path )
    path
  end
d78 4
a81 9
  class << self
    def Proxy( addr, port )
      klass = super
      klass.module_eval %-
        def edit_path( path )
          'http://' + address + (port == self.port ? '' : ":\#{port}") + path
        end
      -
      klass
a82 1
  end
a83 1
end
d85 1
a85 1
HTTP = HTTPSession
d88 6
a93 1
class HTTPCommand < Command
d95 2
a96 1
  HTTPVersion = '1.1'
d98 10
a107 2
  def initialize( sock )
    @@http_version = HTTPVersion
d109 2
a110 5
    @@in_header = {}
    @@in_header[ 'Host' ]       = sock.addr
    #@@in_header[ 'User-Agent' ] = "Ruby http version #{HTTPSession::Version}"
    @@in_header[ 'Connection' ] = 'keep-alive'
    @@in_header[ 'Accept' ]     = '*/*'
d112 6
a117 2
    super sock
  end
d120 3
a122 1
  attr :http_version
d124 11
a134 10
  def get( path, u_header = nil, ret = '' )
    header = get_response(
      sprintf( 'GET %s HTTP/%s', path, HTTPVersion ), u_header )
    
    if chunked? header then
      clen = read_chunked_body( ret )
      header.delete 'transfer-encoding'
      header[ 'content-length' ] = "Content-Length: #{clen}"
    else
      @@socket.read content_length( header ), ret
a135 1
    @@socket.close unless keep_alive? header
a136 1
    return header, ret
d139 1
a140 4
  def head( path, u_header = nil )
    header = get_response(
      sprintf( 'HEAD %s HTTP/%s', path, HTTPVersion ), u_header )
    @@socket.close unless keep_alive? header
d142 3
a144 2
    header
  end
d146 2
d149 4
a152 1
  # def put
d154 2
a155 1
  # def delete
a156 1
  # def trace
d158 1
a158 1
  # def options
d160 11
d172 2
a173 1
  private
d176 2
a177 3
  def do_quit
    unless @@socket.closed? then
      @@socket.close
a178 1
  end
a179 6
  def get_response( line, u_header )
    @@socket.writeline line
    write_header u_header
    rep = get_reply
    header = read_header
    reply_must rep, SuccessCode
d181 11
a191 2
    header
  end
d193 5
a197 24
  def get_reply
    str = @@socket.readline
    unless /\AHTTP\/(\d+\.\d+)?\s+(\d\d\d)\s*(.*)\z/i === str then
      raise HTTPBadResponse, "wrong status line format: #{str}"
    end
    @@http_version = $1
    status  = $2
    discrip = $3
    
    klass = case status[0]
            when ?1 then
              case status[2]
              when ?0 then ContinueCode
              when ?1 then SuccessCode
              else         UnknownCode
              end
            when ?2 then SuccessCode
            when ?3 then RetryCode
            when ?4 then ServerBusyCode
            when ?5 then FatalErrorCode
            else UnknownCode
            end
    klass.new( status, discrip )
  end
d199 8
a206 4
  
  def content_length( header )
    unless str = header[ 'content-length' ] then
      raise HTTPBadResponce, "content-length not given"
d208 24
a231 2
    unless /\Acontent-length:\s*(\d+)/i === str then
      raise HTTPBadResponce, "content-length format error"
a232 2
    $1.to_i
  end
d234 4
a237 4
  def keep_alive?( header )
    if str = header[ 'connection' ] then
      if /\Aconnection:\s*keep-alive/i === str then
        return true
d239 2
a240 3
    else
      if @@http_version == '1.1' then
        return true
d242 1
d245 6
a250 2
    false
  end
d252 1
a252 5
  def chunked?( header )
    if str = header[ 'transfer-encoding' ] then
      if /\Atransfer-encoding:\s*chunked/i === str then
        return true
      end
a254 2
    false
  end
d256 11
d268 1
a268 10
  def read_header
    header = {}
    while true do
      line = @@socket.readline
      break if line.empty?
      /\A[^:]+/ === line
      nm = $&
      nm.strip!
      nm.downcase!
      header[ nm ] = line
d271 10
a280 2
    header
  end
d282 5
a286 15
  def write_header( user )
    if user then
      header = @@in_header.dup.update user
    else
      header = @@in_header
    end
    header.each do |n,v|
      @@socket.writeline n + ': ' + v
    end
    @@socket.writeline ''

    if tmp = header['Connection'] then
      /close/i === tmp
    else
      false
a287 1
  end
d289 21
a309 18
  def read_chunked_body( ret )
    line = nil
    len = nil
    total = 0

    while true do
      line = @@socket.readline
      unless /[0-9a-hA-H]+/ === line then
        raise HTTPBadResponce, "chunk size not given"
      end
      len = $&.hex
      break if len == 0
      @@socket.read( len, ret ); total += len
      @@socket.read 2   # \r\n
    end
    while true do
      line = @@socket.readline
      break if line.empty?
a311 1
    total
a312 2

end
@


1.2
log
@Version 1.1.1

o  HTTP chunk data
@
text
@d22 1
a22 1
  Version = '1.1.1'
d25 1
a25 1
  session_setvar :command_type, 'HTTPCommand'
d30 1
a30 1
    @@proto.get path, header, ret
d35 1
a35 1
    @@proto.head path, header
d47 23
a75 1

d86 1
a86 1
    @@in_header[ 'Connection' ] = 'Keep-Alive'
d96 3
a98 4
    @@socket.writeline sprintf( 'GET %s HTTP/%s', path, HTTPVersion )
    write_header u_header
    check_reply SuccessCode
    header = read_header
d113 2
a114 4
    @@socket.writeline sprintf( 'HEAD %s HTTP/%s', path, HTTPVersion )
    write_header u_header
    check_reply SuccessCode
    header = read_header
d135 1
a135 1
      head '/', { 'Connection' => 'Close' }
d139 9
d151 3
a153 1
    /\AHTTP\/(\d+\.\d+)?\s+(\d\d\d)\s+(.*)\z/i === str
@


1.1
log
@Version 1.1.0
o  http.rb
o  support class swap
o  Net.quote
@
text
@d22 1
a22 1
  Version = '1.1.0'
d64 2
a65 2
    #@@in_header[ 'Connection' ] = 'Keep-Alive'
    #@@in_header[ 'Accept' ]     = '*/*'
d78 7
a84 1
    @@socket.read content_length( header ), ret
d149 1
a149 1
    unless /content-length:\s*(\d+)/i === str then
d157 1
a157 1
      if /connection:\s*keep-alive/i === str then
d169 10
d211 23
@
