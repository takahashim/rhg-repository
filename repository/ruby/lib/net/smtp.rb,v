head	1.52;
access;
symbols
	v1_6_7:1.31.2.15
	v1_6_6:1.31.2.11
	v1_6_5:1.31.2.7
	v1_6_4:1.31.2.4
	v1_7_1:1.35
	v1_6_4_preview4:1.31.2.4
	v1_6_4_preview3:1.31.2.4
	v1_6_4_preview2:1.31.2.4
	v1_6_4_preview1:1.31.2.4
	v1_6_3:1.31.2.4
	ruby_m17n:1.31.0.4
	ruby_1_6:1.31.0.2
	v1_6_2:1.31
	v1_6_1:1.25
	v1_6_0:1.23
	v1_4_6:1.1.2.15
	v1_4_5:1.1.2.14
	v1_4_4:1.1.2.3
	V1-1-3:1.7
	V1-1-1:1.5
	ruby_1_4_3:1.1.2.1
	ruby1_4_3:1.1.2.1
	v1_4_3:1.1.2.1
	v1_5_0:1.3
	ruby_1_4_3_pre1:1.1.2.1
	ruby_1_4:1.1.0.2;
locks; strict;
comment	@# @;


1.52
date	2002.07.29.06.14.10;	author matz;	state Exp;
branches;
next	1.51;

1.51
date	2002.03.26.11.18.02;	author aamine;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.22.12.10.58;	author aamine;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.19.12.33.52;	author aamine;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.07.20.22.39;	author aamine;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.30.19.18.45;	author aamine;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.20.05.00.20;	author aamine;	state Exp;
branches;
next	1.45;

1.45
date	2001.12.13.19.15.21;	author aamine;	state Exp;
branches;
next	1.44;

1.44
date	2001.12.09.08.58.30;	author aamine;	state Exp;
branches;
next	1.43;

1.43
date	2001.12.07.10.04.25;	author aamine;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.01.14.03.19;	author knu;	state Exp;
branches;
next	1.41;

1.41
date	2001.08.17.03.08.45;	author aamine;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.08.07.00.23;	author aamine;	state Exp;
branches;
next	1.39;

1.39
date	2001.07.03.19.03.16;	author aamine;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.03.18.13.13;	author aamine;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.27.00.59.08;	author aamine;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.26.23.49.21;	author aamine;	state Exp;
branches;
next	1.35;

1.35
date	2001.03.13.05.48.58;	author aamine;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.24.04.53.50;	author aamine;	state Exp;
branches;
next	1.33;

1.33
date	2001.02.06.11.14.51;	author aamine;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.13.19.07.15;	author aamine;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.24.20.01.44;	author aamine;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2000.12.24.19.39.15;	author aamine;	state Exp;
branches;
next	1.29;

1.29
date	2000.12.22.18.40.55;	author aamine;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.10.23.31.32;	author aamine;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.07.11.27.16;	author aamine;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.25.17.40.30;	author aamine;	state Exp;
branches;
next	1.25;

1.25
date	2000.09.21.06.58.01;	author aamine;	state Exp;
branches;
next	1.24;

1.24
date	2000.09.12.05.37.35;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.16.19.26.06;	author aamine;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.12.06.04.40;	author aamine;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.01.18.28.24;	author aamine;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.12.16.42.46;	author aamine;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.01.13.43.43;	author aamine;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.18.08.57.37;	author aamine;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.17.18.39.43;	author aamine;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.25.09.22.56;	author aamine;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.18.09.39.02;	author aamine;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.31.13.02.40;	author aamine;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.27.15.52.27;	author aamine;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.26.08.48.15;	author aamine;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.05.10.25.53;	author aamine;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.21.15.25.37;	author aamine;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.21.12.52.24;	author aamine;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.05.07.55.36;	author aamine;	state Exp;
branches;
next	1.7;

1.7
date	99.12.29.11.14.04;	author aamine;	state Exp;
branches;
next	1.6;

1.6
date	99.12.22.13.49.13;	author aamine;	state Exp;
branches;
next	1.5;

1.5
date	99.12.20.20.48.49;	author aamine;	state Exp;
branches;
next	1.4;

1.4
date	99.12.17.15.00.13;	author aamine;	state Exp;
branches;
next	1.3;

1.3
date	99.10.18.09.03.01;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.10.13.07.28.09;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	99.09.22.07.32.33;	author matz;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	99.10.13.07.29.15;	author matz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2000.01.16.08.15.50;	author aamine;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2000.01.21.12.53.38;	author aamine;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2000.03.15.13.30.27;	author aamine;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2000.03.23.21.56.16;	author aamine;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2000.03.26.08.45.01;	author aamine;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2000.03.27.15.52.56;	author aamine;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2000.03.31.13.03.16;	author aamine;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2000.04.18.09.39.41;	author aamine;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2000.04.25.09.23.21;	author aamine;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2000.05.17.18.37.29;	author aamine;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2000.05.18.08.56.59;	author aamine;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2000.06.01.13.41.36;	author aamine;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	2000.06.12.16.42.24;	author aamine;	state Exp;
branches;
next	1.1.2.15;

1.1.2.15
date	2000.07.01.18.27.36;	author aamine;	state Exp;
branches;
next	;

1.31.2.1
date	2001.02.13.07.55.16;	author aamine;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2001.02.22.23.19.50;	author aamine;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2001.02.24.06.38.35;	author aamine;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2001.03.13.05.55.31;	author aamine;	state Exp;
branches;
next	1.31.2.5;

1.31.2.5
date	2001.06.26.23.49.02;	author aamine;	state Exp;
branches;
next	1.31.2.6;

1.31.2.6
date	2001.06.27.00.59.52;	author aamine;	state Exp;
branches;
next	1.31.2.7;

1.31.2.7
date	2001.07.08.07.01.21;	author aamine;	state Exp;
branches;
next	1.31.2.8;

1.31.2.8
date	2001.12.01.14.07.01;	author knu;	state Exp;
branches;
next	1.31.2.9;

1.31.2.9
date	2001.12.07.09.40.16;	author aamine;	state Exp;
branches;
next	1.31.2.10;

1.31.2.10
date	2001.12.07.10.12.52;	author aamine;	state Exp;
branches;
next	1.31.2.11;

1.31.2.11
date	2001.12.09.08.58.06;	author aamine;	state Exp;
branches;
next	1.31.2.12;

1.31.2.12
date	2002.01.15.03.34.59;	author aamine;	state Exp;
branches;
next	1.31.2.13;

1.31.2.13
date	2002.02.07.20.29.58;	author aamine;	state Exp;
branches;
next	1.31.2.14;

1.31.2.14
date	2002.02.19.13.40.23;	author aamine;	state Exp;
branches;
next	1.31.2.15;

1.31.2.15
date	2002.02.22.12.50.22;	author aamine;	state Exp;
branches;
next	;


desc
@@


1.52
log
@* numeric.c (num_to_int): default to_int implementaion for every
  numeric class.

* re.c (rb_reg_quote): initial part of the string was never copied
  to the quoted string.
@
text
@=begin

= net/smtp.rb

Copyright (c) 1999-2002 Yukihiro Matsumoto

written & maintained by Minero Aoki <aamine@@loveruby.net>

This program is free software. You can re-distribute and/or
modify this program under the same terms as Ruby itself,
Ruby Distribute License or GNU General Public License.

NOTE: You can find Japanese version of this document in
the doc/net directory of the standard ruby interpreter package.

$Id: smtp.rb,v 1.51 2002/03/26 11:18:02 aamine Exp $

== What is This Module?

This module provides your program the functions to send internet
mail via SMTP, Simple Mail Transfer Protocol. For details of
SMTP itself, refer [RFC2821] ((<URL:http://www.ietf.org/rfc/rfc2821.txt>)).

== What This Module is NOT?

This module does NOT provide the functions to compose internet
mail. You must create it by yourself. For details of internet mail
format, see [RFC2822] ((<URL:http://www.ietf.org/rfc/rfc2822.txt>)).

== Examples

=== Sending Mail

You must open connection to SMTP server before sending mails.
First argument is the address of SMTP server, and second argument
is port number. Using SMTP.start with block is the most simple way
to do it. SMTP Connection is closed automatically after block is
executed.

    require 'net/smtp'
    Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
        # use smtp object only in this block
    }

Replace 'your.smtp.server' by your SMTP server. Normally
your system manager or internet provider is supplying a server
for you.

Then you can send mail.

    require 'net/smtp'

    Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
        smtp.send_mail <<EndOfMail, 'your@@mail.address', 'to@@some.domain'
    From: Your Name <your@@mail.address>
    To: Dest Address <to@@some.domain>
    Subject: test mail
    Date: Sat, 23 Jun 2001 16:26:43 +0900
    Message-Id: <unique.message.id.string@@some.domain>

    This is test mail.
    EndOfMail
    }

=== Closing Session

You MUST close SMTP session after sending mails, by calling #finish
method. You can also use block form of SMTP.start/SMTP#start, which
closes session automatically. I strongly recommend later one. It is
more beautiful and simple.

    # using SMTP#finish
    smtp = Net::SMTP.start( 'your.smtp.server', 25 )
    smtp.send_mail mail_string, 'from@@address', 'to@@address'
    smtp.finish

    # using block form of SMTP.start
    Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
        smtp.send_mail mail_string, 'from@@address', 'to@@address'
    }

=== Sending Mails from Any Sources

In an example above I sent mail from String (here document literal).
SMTP#send_mail accepts any objects which has "each" method
like File and Array.

    require 'net/smtp'
    Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
        File.open( 'Mail/draft/1' ) {|f|
            smtp.send_mail f, 'your@@mail.address', 'to@@some.domain'
        }
    }

=== HELO domain

In almost all situation, you must designate the third argument
of SMTP.start/SMTP#start. It is the domain name which you are on
(the host to send mail from). It is called "HELO domain".
SMTP server will judge if he/she should send or reject
the SMTP session by inspecting HELO domain.

    Net::SMTP.start( 'your.smtp.server', 25,
                     'mail.from.domain' ) {|smtp|


== class Net::SMTP

=== Class Methods

: new( address, port = 25 )
    creates a new Net::SMTP object.

: start( address, port = 25, helo_domain = 'localhost.localdomain', account = nil, password = nil, authtype = nil )
: start( address, port = 25, helo_domain = 'localhost.localdomain', account = nil, password = nil, authtype = nil ) {|smtp| .... }
    is equal to
        Net::SMTP.new(address,port).start(helo_domain,account,password,authtype)

        # example
        Net::SMTP.start( 'your.smtp.server' ) {
            smtp.send_mail mail_string, 'from@@mail.address', 'dest@@mail.address'
        }

=== Instance Methods

: start( helo_domain = <local host name>, account = nil, password = nil, authtype = nil )
: start( helo_domain = <local host name>, account = nil, password = nil, authtype = nil ) {|smtp| .... }
    opens TCP connection and starts SMTP session.
    HELO_DOMAIN is a domain that you'll dispatch mails from.
    If protocol had been started, raises IOError.

    When this methods is called with block, give a SMTP object to block and
    close session after block call finished.

    If both of account and password are given, is trying to get
    authentication by using AUTH command. :plain or :cram_md5 is
    allowed for AUTHTYPE.

: active?
    true if SMTP session is started.

: address
    the address to connect

: port
    the port number to connect

: open_timeout
: open_timeout=(n)
    seconds to wait until connection is opened.
    If SMTP object cannot open a conection in this seconds,
    it raises TimeoutError exception.

: read_timeout
: read_timeout=(n)
    seconds to wait until reading one block (by one read(1) call).
    If SMTP object cannot open a conection in this seconds,
    it raises TimeoutError exception.

: finish
    finishes SMTP session.
    If SMTP session had not started, raises an IOError.

: send_mail( mailsrc, from_addr, *to_addrs )
    This method sends MAILSRC as mail. A SMTP object read strings
    from MAILSRC by calling "each" iterator, with converting them
    into CRLF ("\r\n") terminated string when write.

    FROM_ADDR must be a String, representing source mail address.
    TO_ADDRS must be Strings or an Array of Strings, representing
    destination mail addresses.

        # example
        Net::SMTP.start( 'your.smtp.server' ) {|smtp|
            smtp.send_mail mail_string,
                           'from@@mail.address',
                           'dest@@mail.address' 'dest2@@mail.address'
        }

: ready( from_addr, *to_addrs ) {|adapter| .... }
    This method stands by the SMTP object for sending mail and
    gives adapter object to the block. ADAPTER has these 5 methods:

        puts print printf write <<

    FROM_ADDR must be a String, representing source mail address.
    TO_ADDRS must be Strings or an Array of Strings, representing
    destination mail addresses.

        # example
        Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
	    smtp.ready( 'from@@mail.addr', 'dest@@mail.addr' ) {|f|
                f.puts 'From: aamine@@loveruby.net'
                f.puts 'To: someone@@somedomain.org'
                f.puts 'Subject: test mail'
                f.puts
                f.puts 'This is test mail.'
	    }
        }

== Exceptions

SMTP objects raise these exceptions:
: Net::ProtoSyntaxError
    syntax error (errno.500)
: Net::ProtoFatalError
    fatal error (errno.550)
: Net::ProtoUnknownError
    unknown error. (is probably bug)
: Net::ProtoServerBusy
    temporary error (errno.420/450)

=end

require 'net/protocol'
require 'digest/md5'


module Net

  class SMTP < Protocol

    protocol_param :default_port, '25'
    protocol_param :command_type, '::Net::SMTPCommand'
    protocol_param :socket_type,  '::Net::InternetMessageIO'
  

    def initialize( addr, port = nil )
      super
      @@esmtp = true
    end

    def esmtp?
      @@esmtp
    end

    def esmtp=( bool )
      @@esmtp = bool
    end

    alias esmtp esmtp?

    private

    def do_start( helo = 'localhost.localdomain',
                  user = nil, secret = nil, authtype = nil )
      conn_socket
      conn_command

      begin
        if @@esmtp then
          command().ehlo helo
        else
          command().helo helo
        end
      rescue ProtocolError
        if @@esmtp then
          @@esmtp = false
          command().error_ok
          retry
        else
          raise
        end
      end

      if user or secret then
        (user and secret) or
            raise ArgumentError, 'both of account and password are required'

        mid = 'auth_' + (authtype || 'cram_md5').to_s
        command().respond_to? mid or
            raise ArgumentError, "wrong auth type #{authtype.to_s}"

        command().__send__ mid, user, secret
      end
    end

    def do_finish
      disconn_command
      disconn_socket
    end


    #
    # SMTP operations
    #

    public

    def send_mail( mailsrc, from_addr, *to_addrs )
      do_ready from_addr, to_addrs.flatten
      command().write_mail(mailsrc)
    end

    alias sendmail send_mail

    def ready( from_addr, *to_addrs, &block )
      do_ready from_addr, to_addrs.flatten
      command().through_mail(&block)
    end

    private

    def do_ready( from_addr, to_addrs )
      raise ArgumentError, 'mail destination does not given' if to_addrs.empty?
      command().mailfrom from_addr
      command().rcpt(to_addrs)
    end

  end

  SMTPSession = SMTP


  class SMTPCommand < Command

    def initialize( sock )
      super
      atomic {
          check_reply SuccessCode
      }
    end

    def helo( domain )
      atomic {
          getok sprintf('HELO %s', domain)
      }
    end

    def ehlo( domain )
      atomic {
          getok sprintf('EHLO %s', domain)
      }
    end

    # "PLAIN" authentication [RFC2554]
    def auth_plain( user, secret )
      atomic {
          getok sprintf('AUTH PLAIN %s',
                        ["\0#{user}\0#{secret}"].pack('m').chomp)
      }
    end

    # "CRAM-MD5" authentication [RFC2195]
    def auth_cram_md5( user, secret )
      atomic {
          rep = getok( 'AUTH CRAM-MD5', ContinueCode )
          challenge = rep.msg.split(' ')[1].unpack('m')[0]
          secret = Digest::MD5.digest(secret) if secret.size > 64

          isecret = secret + "\0" * (64 - secret.size)
          osecret = isecret.dup
          0.upto( 63 ) do |i|
            isecret[i] ^= 0x36
            osecret[i] ^= 0x5c
          end
          tmp = Digest::MD5.digest( isecret + challenge )
          tmp = Digest::MD5.hexdigest( osecret + tmp )

          getok [user + ' ' + tmp].pack('m').chomp
      }
    end

    def mailfrom( fromaddr )
      atomic {
          getok sprintf('MAIL FROM:<%s>', fromaddr)
      }
    end

    def rcpt( toaddrs )
      toaddrs.each do |i|
        atomic {
            getok sprintf('RCPT TO:<%s>', i)
        }
      end
    end

    def write_mail( src )
      atomic {
          getok 'DATA', ContinueCode
          @@socket.write_message src
          check_reply SuccessCode
      }
    end

    def through_mail( &block )
      atomic {
          getok 'DATA', ContinueCode
          @@socket.through_message(&block)
          check_reply SuccessCode
      }
    end

    def quit
      atomic {
          getok 'QUIT'
      }
    end

    private

    def get_reply
      arr = read_reply
      stat = arr[0][0,3]

      klass = case stat[0]
              when ?2 then SuccessCode
              when ?3 then ContinueCode
              when ?4 then ServerErrorCode
              when ?5 then
                case stat[1]
                when ?0 then SyntaxErrorCode
                when ?3 then AuthErrorCode
                when ?5 then FatalErrorCode
                end
              end
      klass ||= UnknownCode

      Response.new( klass, stat, arr.join('') )
    end

    def read_reply
      arr = []
      while true do
        str = @@socket.readline
        break unless str[3] == ?-   # ex: "210-..."
        arr.push str
      end
      arr.push str

      arr
    end

  end


  # for backward compatibility
  module NetPrivate
    SMTPCommand = ::Net::SMTPCommand
  end

end   # module Net
@


1.51
log
@* lib/net/http.rb: HTTP.get accepts URI.
* lib/net/http.rb: add some HTTP 1.1 response codes.
@
text
@d16 1
a16 1
$Id: header.rd,v 1.3 2002/02/19 12:23:15 aamine Exp $
d292 1
a292 1
      command().write_mail mailsrc
d299 1
a299 1
      command().through_mail &block
d307 1
a307 1
      command().rcpt to_addrs
@


1.50
log
@* lib/net/protocol.rb: set read_timeout dynamically.
* lib/net/http.rb: @@@@newimpl is always true in the main trunk.
* lib/net/http.rb: HTTP.port -> default_port
* lib/net/http.rb: HTTPResponse.read_response_status -> read_status_line
@
text
@@


1.49
log
@aamine
* lib/net/protocol.rb: rename Protocol.port to default_port.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
* lib/net/protocol.rb: rename BufferedSocket class to InternetMessageIO.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#write_pendstr to write_message.
* lib/net/smtp.rb: ditto.
* lib/net/protocol.rb: new method InternetMessageIO#through_message.
* lib/net/smtp.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#read_pendstr to read_message_to.
* lib/net/pop.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#read_pendlist to each_list_item
* lib/net/pop.rb: ditto.
* lib/net/protocol.rb: Now block size is 1024.
* lib/net/smtp.rb: new methods SMTP#esmtp? and #esmtp=.
* lib/net/http.rb: Using singleton method syntax instead of singleton class clause, to avoid behavior change of class variables in ruby 1.7.
* lib/net/http.rb: HTTPResponse class does not inherit from Net::Response.
* lib/net/http.rb: devide HTTP#connecting into {begin,end}_transport.
* lib/net/http.rb: unused class Accumulator removed.
* lib/net/http.rb: Net::HTTP reads response. not HTTPRequest.
* lib/net/http.rb: proxy related class-instance-variables are not initialized correctly.
@
text
@@


1.48
log
@aamine
* lib/net/http.rb: HTTP.Proxy should use self for proxy-class's super class.
* lib/net/http.rb: initialize HTTP.proxy_port by HTTP.port.
@
text
@d5 1
a5 1
Copyright (c) 1999-2001 Yukihiro Matsumoto
d16 1
a16 1
$Id: header.rd,v 1.2 2001/12/10 12:37:16 aamine Exp $
d223 1
a223 1
    protocol_param :port,         '25'
d225 2
d233 9
a241 1
    attr :esmtp
d292 1
a292 1
      command().write_mail mailsrc, nil
d299 1
a299 1
      command().write_mail nil, block
d305 1
a305 3
      if to_addrs.empty? then
        raise ArgumentError, 'mail destination does not given'
      end
a307 1
      command().data
d312 2
d378 6
a383 3
    def data
      return unless begin_atomic
      getok 'DATA', ContinueCode
d386 6
a391 4
    def write_mail( mailsrc, block )
      @@socket.write_pendstr mailsrc, &block
      check_reply SuccessCode
      end_atomic
a437 3

  SMTPSession = SMTP

@


1.47
log
@aamine
* lib/net/protocol.rb: Protocol#start returns the return value of block.
* lib/net/protocol.rb: set timeout limit by default.
* lib/net/protocol.rb: new methods WriteAdapter#write, puts, print, printf.
* lib/net/http.rb: rename HTTP#get2 to request_get, post2 to request_post ...
* lib/net/smtp.rb: should not resolve HELO domain automatically.
@
text
@@


1.46
log
@aamine
* lib/net/protocol.rb: rename Net::Socket to Net::BufferedSocket
@
text
@d95 1
a95 1
=== Giving "Hello" Domain
d97 5
a101 2
If your machine does not have canonical host name, maybe you
must designate the third argument of SMTP.start.
a105 3
This argument gives MAILFROM domain, the domain name that
you send mail from. SMTP server might judge if he (or she?)
send or reject SMTP session by this data.
d114 2
a115 2
: start( address, port = 25, helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil )
: start( address, port = 25, helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil ) {|smtp| .... }
d182 3
a184 2
    give adapter object to the block. ADAPTER accepts only "write"
    method.
d192 7
a198 5
	    smtp.ready( 'from@@mail.addr', 'dest@@mail.addr' ) do |adapter|
	      adapter.write str1
	      adapter.write str2
	      adapter.write str3
	    end
a220 1

a225 1

a232 13
    def send_mail( mailsrc, from_addr, *to_addrs )
      do_ready from_addr, to_addrs.flatten
      @@command.write_mail mailsrc, nil
    end

    alias sendmail send_mail

    def ready( from_addr, *to_addrs, &block )
      do_ready from_addr, to_addrs.flatten
      @@command.write_mail nil, block
    end


d235 1
a235 11

    def do_ready( from_addr, to_addrs )
      if to_addrs.empty? then
        raise ArgumentError, 'mail destination does not given'
      end
      @@command.mailfrom from_addr
      @@command.rcpt to_addrs
      @@command.data
    end

    def do_start( helodom = nil,
d237 2
a238 5
      helodom ||= ::Socket.gethostname
      unless helodom then
        raise ArgumentError,
          "cannot get localhost name; try 'smtp.start(local_host_name)'"
      end
d242 1
a242 1
          @@command.ehlo helodom
d244 1
a244 1
          @@command.helo helodom
d249 1
a249 1
          @@command.error_ok
d261 1
a261 1
        @@command.respond_to? mid or
d264 1
a264 1
        @@command.__send__ mid, user, secret
d268 25
a292 1
  end
d294 8
a301 1
  SMTPSession = SMTP
d303 1
d310 2
a311 2
      critical {
        check_reply SuccessCode
d315 3
a317 4

    def helo( fromdom )
      critical {
        getok sprintf( 'HELO %s', fromdom )
d321 3
a323 4

    def ehlo( fromdom )
      critical {
        getok sprintf( 'EHLO %s', fromdom )
a326 1

d329 3
a331 3
      critical {
        getok sprintf( 'AUTH PLAIN %s',
                       ["\0#{user}\0#{secret}"].pack('m').chomp )
d337 13
a349 13
      critical {
        rep = getok( 'AUTH CRAM-MD5', ContinueCode )
        challenge = rep.msg.split(' ')[1].unpack('m')[0]
        secret = Digest::MD5.digest( secret ) if secret.size > 64

        isecret = secret + "\0" * (64 - secret.size)
        osecret = isecret.dup
        0.upto( 63 ) do |i|
          isecret[i] ^= 0x36
          osecret[i] ^= 0x5c
        end
        tmp = Digest::MD5.digest( isecret + challenge )
        tmp = Digest::MD5.hexdigest( osecret + tmp )
d351 1
a351 1
        getok [user + ' ' + tmp].pack('m').chomp
a354 1

d356 2
a357 2
      critical {
        getok sprintf( 'MAIL FROM:<%s>', fromaddr )
a360 1

d363 2
a364 2
        critical {
          getok sprintf( 'RCPT TO:<%s>', i )
a368 1

d370 1
a370 1
      return unless begin_critical
d375 1
a375 1
      @@socket.write_pendstr mailsrc, block
d377 1
a377 1
      end_critical
a379 1

d381 2
a382 2
      critical {
        getok 'QUIT'
a385 1

a387 1

a407 1

d424 3
@


1.45
log
@aamine
* lib/net/pop.rb: new method Net::POP3.APOP
* lib/net/http.rb: set default Content-Type to x-www-form-urlencoded (causes warning)
* lib/net/protocol.rb: remove Net::NetPrivate module.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@@


1.44
log
@aamine
* lib/net/protocol.rb: calls on_connect before conn_command
@
text
@d3 1
a3 1
= net/smtp.rb version 1.2.3
d16 2
d222 1
a222 1
    protocol_param :command_type, '::Net::NetPrivate::SMTPCommand'
a298 3
  module NetPrivate


d426 4
a429 1
  end   # module Net::NetPrivate
@


1.43
log
@aamine
* lib/net/smtp.rb: SMTP.new requires at least one arg.
* lib/net/pop.rb: POP.new requires at least one arg.
* lib/net/pop.rb: uses "raise *Error.new" instead of simple raise.
* lib/net/http.rb: HTTP.new requires at least one arg.
* lib/net/http.rb: changes implicit start algolithm.
@
text
@d40 1
a40 1
      # use smtp object only in this block
d52 1
a52 1
      smtp.send_mail <<EndOfMail, 'your@@mail.address', 'to@@some.domain'
d63 17
d88 3
a90 3
      File.open( 'Mail/draft/1' ) {|f|
        smtp.send_mail f, 'your@@mail.address', 'to@@some.domain'
      }
d119 1
a119 1
          smtp.send_mail mail_string, 'from@@mail.address', 'dest@@mail.address'
d173 3
a175 3
          smtp.send_mail mail_string,
                         'from@@mail.address',
                         'dest@@mail.address' 'dest2@@mail.address'
d189 5
a193 5
          smtp.ready( 'from@@mail.addr', 'dest@@mail.addr' ) do |adapter|
            adapter.write str1
            adapter.write str2
            adapter.write str3
          end
@


1.42
log
@Reflect the update of the MD5 module which is now Digest::MD5.
@
text
@d13 2
a14 3
NOTE: You can get Japanese version of this document from
Ruby Documentation Project (RDP):
((<URL:http://www.ruby-lang.org/~rubikitch/RDP.cgi>))
@


1.41
log
@aamine
* lib/net/protocol.rb: Protocol.new requires at least one arg.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@d195 1
a195 1
require 'md5'
d321 1
a321 1
        secret = MD5.new( secret ).digest if secret.size > 64
d329 2
a330 2
        tmp = MD5.new( isecret + challenge ).digest
        tmp = MD5.new( osecret + tmp ).hexdigest
@


1.40
log
@aamine
* lib/net/http.rb: rename HTTP#request_by_name to send_request.
* lib/net/protocol.rb (ProtoSocket#read): modify typo.
@
text
@d93 1
a93 1
: new( address = 'localhost', port = 25 )
d96 2
a97 2
: start( address = 'localhost', port = 25, helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil )
: start( address = 'localhost', port = 25, helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil ) {|smtp| .... }
d207 1
a207 1
    def initialize( addr = nil, port = nil )
@


1.39
log
@aamine
* lib/net/http.rb (HTTP#request_by_name): bug fix.
* lib/net/http.rb: does not write Connection: by default.
* lib/net/protocol.rb: "start" for started protocol is an error.
* lib/net/protocol.rb: "finish" for finished protocol is an error.
@
text
@d3 1
a3 1
= net/smtp.rb version 1.2.2
@


1.38
log
@aamine
* lib/net/http.rb: new method HTTP#request_by_name (test)
* lib/net/http.rb: new class HTTPGenericRequest
@
text
@a110 1
    If protocol had been started, do nothing and return false.
d112 1
d144 1
a144 1
    If SMTP session had not started, do nothing and return false.
@


1.37
log
@* protocol.rb,smtp.rb,pop.rb,http.rb: modify document.
@
text
@d3 1
a3 1
= net/smtp.rb version 1.2.1
@


1.36
log
@aamine
* lib/net/pop.rb: new methods POP3.auth_only, POP3#auth_only
* lib/net/http.rb: HTTP.Proxy returns self if ADDRESS is nil.
* lib/net/protocol.rb: new method ProtocolError#response
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: add document.
@
text
@d39 4
a42 4
  require 'net/smtp'
  Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
    # use smtp object only in this block
  }
d50 9
a58 1
  require 'net/smtp'
d60 3
a62 11
  Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
    smtp.send_mail <<EndOfMail, 'your@@mail.address', 'to@@some.domain'
  From: Your Name <your@@mail.address>
  To: Dest Address <to@@some.domain>
  Subject: test mail
  Date: Sat, 23 Jun 2001 16:26:43 +0900
  Message-Id: <unique.message.id.string@@some.domain>

  This is test mail.
  EndOfMail
  }
d70 5
a74 4
  require 'net/smtp'
  Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
    File.open( 'Mail/draft/1' ) {|f|
      smtp.send_mail f, 'your@@mail.address', 'to@@some.domain'
a75 1
  }
d82 2
a83 2
  Net::SMTP.start( 'your.smtp.server', 25,
                   'mail.from.domain' ) {|smtp|
d94 1
a94 1
  creates a new Net::SMTP object.
d98 2
a99 2
  is equal to
    Net::SMTP.new(address,port).start(helo_domain,account,password,authtype)
d101 4
a104 4
    # example
    Net::SMTP.start( 'your.smtp.server' ) {
      smtp.send_mail mail_string, 'from@@mail.address', 'dest@@mail.address'
    }
d110 10
a119 10
  opens TCP connection and starts SMTP session.
  If protocol had been started, do nothing and return false.
  HELO_DOMAIN is a domain that you'll dispatch mails from.

  When this methods is called with block, give a SMTP object to block and
  close session after block call finished.

  If both of account and password are given, is trying to get
  authentication by using AUTH command. :plain or :cram_md5 is
  allowed for AUTHTYPE.
d147 14
a160 14
  This method sends MAILSRC as mail. A SMTP object read strings
  from MAILSRC by calling "each" iterator, with converting them
  into CRLF ("\r\n") terminated string when write.

  FROM_ADDR must be a String, representing source mail address.
  TO_ADDRS must be Strings or an Array of Strings, representing
  destination mail addresses.

    # example
    Net::SMTP.start( 'your.smtp.server' ) {|smtp|
      smtp.send_mail mail_string,
                     'from@@mail.address',
                     'dest@@mail.address' 'dest2@@mail.address'
    }
d163 16
a178 16
  This method stands by the SMTP object for sending mail and
  give adapter object to the block. ADAPTER accepts only "write"
  method.

  FROM_ADDR must be a String, representing source mail address.
  TO_ADDRS must be Strings or an Array of Strings, representing
  destination mail addresses.

    # example
    Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
      smtp.ready( 'from@@mail.addr', 'dest@@mail.addr' ) do |adapter|
        adapter.write str1
        adapter.write str2
        adapter.write str3
      end
    }
@


1.35
log
@aamine
* lib/net/http.rb: add HTTPRequest#basic_auth.
* lib/net/smtp.rb: raise if only account or password is given.
* lib/net/protocol.rb: WriteAdapter#<< returns self.
@
text
@d3 1
a3 1
= net/smtp.rb version 1.2.0
d5 1
a5 1
  Copyright (C) 1999-2001 Yukihiro Matsumoto
d7 1
a7 1
  written & maintained by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d9 3
a11 3
  This program is free software. You can re-distribute and/or
  modify this program under the same terms as Ruby itself,
  GNU General Public License or Ruby License.
d13 3
a15 3
  Japanese version of this document is in "net" full package.
  You can get it from RAA (Ruby Application Archive). RAA is:
  http://www.ruby-lang.org/en/raa.html
d17 1
d19 3
a21 1
== Net::SMTP
d23 1
a23 1
=== Super Class
d25 65
a89 1
Net::Protocol
d96 9
a104 3
: start( address = 'localhost', port = 25, *protoargs )
: start( address = 'localhost', port = 25, *protoargs ) {|smtp| .... }
  is equal to Net::SMTP.new( address, port ).start( *protoargs )
d106 1
a106 1
=== Methods
d108 2
a109 2
: start( helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil )
: start( helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil ) {|smtp| .... }
d112 1
d117 28
a144 2
  If account and password are given, is trying to get authentication
  by using AUTH command. "authtype" is :plain (symbol) or :cram_md5.
d147 27
a173 28
: sendmail( mailsrc, from_addr, *to_addrs )
  This method sends 'mailsrc' as mail. SMTP read strings
  from 'mailsrc' by calling 'each' iterator, and convert them
  into "\r\n" terminated string when write.

  from_addr must be String.
  to_addrs must be a String(s) or an Array of String.

  Exceptions which SMTP raises are:
      * Net::ProtoSyntaxError: syntax error (errno.500)
      * Net::ProtoFatalError: fatal error (errno.550)
      * Net::ProtoUnknownError: unknown error
      * Net::ProtoServerBusy: temporary error (errno.420/450)

    # usage example

    Net::SMTP.start( 'localhost', 25 ) do |smtp|
      smtp.send_mail mail_string, 'from-addr@@foo.or.jp', 'to-addr@@bar.or.jp'
    end

: ready( from_addr, to_addrs ) {|adapter| .... }
  This method stands by the SMTP object for sending mail.
  "adapter" object accepts only "write" method.

    # usage example

    Net::SMTP.start( 'localhost', 25 ) do |smtp|
      smtp.ready( from, to ) do |adapter|
d178 3
a180 1
    end
d182 9
a190 3
: finish
  finishes SMTP session.
  If SMTP session had not started, do nothing and return false.
d265 1
a265 1
            raise ArgumentError, "both of account and password are required"
@


1.34
log
@aamine
* lib/net/http.rb: always close connection on request without body.
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: change copyright.
@
text
@d156 4
a159 1
      if user and secret then
d161 4
a164 4
        unless @@command.respond_to? mid then
          raise ArgumentError, "wrong auth type #{authtype.to_s}"
        end
        @@command.send mid, user, secret
@


1.33
log
@aamine
* lib/net/http.rb: add HTTP#request.
* lib/net/http.rb: take HTTP 1.0 server into account (incomplete).
* lib/net/protocol.rb: timeout for open/read.
* lib/net/protocol.rb: add Protocol#on_connect,on_disconnect.
@
text
@d5 1
a5 1
written by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d7 1
a7 3
This program is free software.
You can distribute/modify this program under
the terms of the Ruby Distribute License.
d9 7
a15 3
Japanese version of this document is in "net" full package.
You can get it from RAA
(Ruby Application Archive: http://www.ruby-lang.org/en/raa.html).
@


1.32
log
@aamine
* lib/net/protocol.rb (adding): too few "yield" in case of arg is not String/File.
* lib/net/http.rb: add http request object.
@
text
@d33 2
a34 4
: start( helo_domain = Socket.gethostname, \
         account = nil, password = nil, authtype = nil )
: start( helo_domain = Socket.gethostname, \
         account = nil, password = nil, authtype = nil ) {|smtp| .... }
d54 4
a57 4
  * Net::ProtoSyntaxError: syntax error (errno.500)
  * Net::ProtoFatalError: fatal error (errno.550)
  * Net::ProtoUnknownError: unknown error
  * Net::ProtoServerBusy: temporary error (errno.420/450)
@


1.31
log
@aamine
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: wrongly version 1.2 sources
  were checked in.
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.32
@


1.31.2.1
log
@aamine
* lib/net/http.rb: supports HTTP 1.0 server.
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.33
@


1.31.2.2
log
@aamine
* lib/net/protocol.rb: clear read buffer after reopen.
* lib/net/http.rb: update RD document.
@
text
@d33 4
a36 2
: start( helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil )
: start( helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil ) {|smtp| .... }
d56 4
a59 4
      * Net::ProtoSyntaxError: syntax error (errno.500)
      * Net::ProtoFatalError: fatal error (errno.550)
      * Net::ProtoUnknownError: unknown error
      * Net::ProtoServerBusy: temporary error (errno.420/450)
@


1.31.2.3
log
@aamine
* lib/net/protocol.rb: use net 1.2 for also ruby 1.6 branch.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.34
@


1.31.2.4
log
@aamine
* lib/net/http.rb: add HTTPRequest#basic_auth.
* lib/net/smtp.rb: raise if only account or password is given.
* lib/net/protocol.rb: WriteAdapter#<< returns self.
@
text
@d154 1
a154 4
      if user or secret then
        (user and secret) or
            raise ArgumentError, 'both of account and password are required'

d156 4
a159 4
        @@command.respond_to? mid or
            raise ArgumentError, "wrong auth type #{authtype.to_s}"

        @@command.__send__ mid, user, secret
@


1.31.2.5
log
@aamine
* lib/net/pop.rb: new methods POP3.auth_only, POP3#auth_only
* lib/net/http.rb: HTTP.Proxy returns self if ADDRESS is nil.
* lib/net/protocol.rb: new method ProtocolError#response
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: add document.
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.35
d5 1
a5 1
Copyright (c) 1999-2001 Yukihiro Matsumoto
d7 3
a9 1
written & maintained by Minero Aoki <aamine@@loveruby.net>
d11 3
a13 3
This program is free software. You can re-distribute and/or
modify this program under the same terms as Ruby itself,
Ruby Distribute License or GNU General Public License.
a14 3
NOTE: You can get Japanese version of this document from
Ruby Documentation Project (RDP):
((<URL:http://www.ruby-lang.org/~rubikitch/RDP.cgi>))
d16 1
a16 1
== What is This Module?
d18 1
a18 3
This module provides your program the functions to send internet
mail via SMTP, Simple Mail Transfer Protocol. For details of
SMTP itself, refer [RFC2821] ((<URL:http://www.ietf.org/rfc/rfc2821.txt>)).
d20 1
a20 67
== What This Module is NOT?

This module does NOT provide the functions to compose internet
mail. You must create it by yourself. For details of internet mail
format, see [RFC2822] ((<URL:http://www.ietf.org/rfc/rfc2822.txt>)).

== Examples

=== Sending Mail

You must open connection to SMTP server before sending mails.
First argument is the address of SMTP server, and second argument
is port number. Using SMTP.start with block is the most simple way
to do it. SMTP Connection is closed automatically after block is
executed.

  require 'net/smtp'
  Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
    # use smtp object only in this block
  }

Replace 'your.smtp.server' by your SMTP server. Normally
your system manager or internet provider is supplying a server
for you.

Then you can send mail.

  require 'net/smtp'

  Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
    smtp.send_mail <<EndOfMail, 'your@@mail.address', 'to@@some.domain'
  From: Your Name <your@@mail.address>
  To: Dest Address <to@@some.domain>
  Subject: test mail
  Date: Sat, 23 Jun 2001 16:26:43 +0900
  Message-Id: <unique.message.id.string@@some.domain>

  This is test mail.
  EndOfMail
  }

=== Sending Mails from Any Sources

In an example above I sent mail from String (here document literal).
SMTP#send_mail accepts any objects which has "each" method
like File and Array.

  require 'net/smtp'
  Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
    File.open( 'Mail/draft/1' ) {|f|
      smtp.send_mail f, 'your@@mail.address', 'to@@some.domain'
    }
  }

=== Giving "Hello" Domain

If your machine does not have canonical host name, maybe you
must designate the third argument of SMTP.start.

  Net::SMTP.start( 'your.smtp.server', 25,
                   'mail.from.domain' ) {|smtp|

This argument gives MAILFROM domain, the domain name that
you send mail from. SMTP server might judge if he (or she?)
send or reject SMTP session by this data.

== class Net::SMTP
d27 3
a29 9
: start( address = 'localhost', port = 25, helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil )
: start( address = 'localhost', port = 25, helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil ) {|smtp| .... }
  is equal to
    Net::SMTP.new(address,port).start(helo_domain,account,password,authtype)

    # example
    Net::SMTP.start( 'your.smtp.server' ) {
      smtp.send_mail mail_string, 'from@@mail.address', 'dest@@mail.address'
    }
d31 1
a31 1
=== Instance Methods
d33 2
a34 2
: start( helo_domain = <local host name>, account = nil, password = nil, authtype = nil )
: start( helo_domain = <local host name>, account = nil, password = nil, authtype = nil ) {|smtp| .... }
a36 1
  HELO_DOMAIN is a domain that you'll dispatch mails from.
d41 2
a42 24
  If both of account and password are given, is trying to get
  authentication by using AUTH command. :plain or :cram_md5 is
  allowed for AUTHTYPE.

: active?
    true if SMTP session is started.

: address
    the address to connect

: port
    the port number to connect

: open_timeout
: open_timeout=(n)
    seconds to wait until connection is opened.
    If SMTP object cannot open a conection in this seconds,
    it raises TimeoutError exception.

: read_timeout
: read_timeout=(n)
    seconds to wait until reading one block (by one read(1) call).
    If SMTP object cannot open a conection in this seconds,
    it raises TimeoutError exception.
d44 26
a69 3
: finish
    finishes SMTP session.
    If SMTP session had not started, do nothing and return false.
d71 2
a72 28
: send_mail( mailsrc, from_addr, *to_addrs )
  This method sends MAILSRC as mail. A SMTP object read strings
  from MAILSRC by calling "each" iterator, with converting them
  into CRLF ("\r\n") terminated string when write.

  FROM_ADDR must be a String, representing source mail address.
  TO_ADDRS must be Strings or an Array of Strings, representing
  destination mail addresses.

    # example
    Net::SMTP.start( 'your.smtp.server' ) {|smtp|
      smtp.send_mail mail_string,
                     'from@@mail.address',
                     'dest@@mail.address' 'dest2@@mail.address'
    }

: ready( from_addr, *to_addrs ) {|adapter| .... }
  This method stands by the SMTP object for sending mail and
  give adapter object to the block. ADAPTER accepts only "write"
  method.

  FROM_ADDR must be a String, representing source mail address.
  TO_ADDRS must be Strings or an Array of Strings, representing
  destination mail addresses.

    # example
    Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
      smtp.ready( 'from@@mail.addr', 'dest@@mail.addr' ) do |adapter|
d77 1
a77 1
    }
d79 3
a81 11
== Exceptions

SMTP objects raise these exceptions:
: Net::ProtoSyntaxError
    syntax error (errno.500)
: Net::ProtoFatalError
    fatal error (errno.550)
: Net::ProtoUnknownError
    unknown error. (is probably bug)
: Net::ProtoServerBusy
    temporary error (errno.420/450)
@


1.31.2.6
log
@* smtp.rb, pop.rb, http.rb: modify document.
@
text
@d39 4
a42 4
    require 'net/smtp'
    Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
      # use smtp object only in this block
    }
d50 1
a50 9
    require 'net/smtp'

    Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
      smtp.send_mail <<EndOfMail, 'your@@mail.address', 'to@@some.domain'
    From: Your Name <your@@mail.address>
    To: Dest Address <to@@some.domain>
    Subject: test mail
    Date: Sat, 23 Jun 2001 16:26:43 +0900
    Message-Id: <unique.message.id.string@@some.domain>
d52 11
a62 3
    This is test mail.
    EndOfMail
    }
d70 4
a73 5
    require 'net/smtp'
    Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
      File.open( 'Mail/draft/1' ) {|f|
        smtp.send_mail f, 'your@@mail.address', 'to@@some.domain'
      }
d75 1
d82 2
a83 2
    Net::SMTP.start( 'your.smtp.server', 25,
                     'mail.from.domain' ) {|smtp|
d94 1
a94 1
    creates a new Net::SMTP object.
d98 2
a99 2
    is equal to
        Net::SMTP.new(address,port).start(helo_domain,account,password,authtype)
d101 4
a104 4
        # example
        Net::SMTP.start( 'your.smtp.server' ) {
          smtp.send_mail mail_string, 'from@@mail.address', 'dest@@mail.address'
        }
d110 10
a119 10
    opens TCP connection and starts SMTP session.
    If protocol had been started, do nothing and return false.
    HELO_DOMAIN is a domain that you'll dispatch mails from.

    When this methods is called with block, give a SMTP object to block and
    close session after block call finished.

    If both of account and password are given, is trying to get
    authentication by using AUTH command. :plain or :cram_md5 is
    allowed for AUTHTYPE.
d147 14
a160 14
    This method sends MAILSRC as mail. A SMTP object read strings
    from MAILSRC by calling "each" iterator, with converting them
    into CRLF ("\r\n") terminated string when write.

    FROM_ADDR must be a String, representing source mail address.
    TO_ADDRS must be Strings or an Array of Strings, representing
    destination mail addresses.

        # example
        Net::SMTP.start( 'your.smtp.server' ) {|smtp|
          smtp.send_mail mail_string,
                         'from@@mail.address',
                         'dest@@mail.address' 'dest2@@mail.address'
        }
d163 16
a178 16
    This method stands by the SMTP object for sending mail and
    give adapter object to the block. ADAPTER accepts only "write"
    method.

    FROM_ADDR must be a String, representing source mail address.
    TO_ADDRS must be Strings or an Array of Strings, representing
    destination mail addresses.

        # example
        Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
          smtp.ready( 'from@@mail.addr', 'dest@@mail.addr' ) do |adapter|
            adapter.write str1
            adapter.write str2
            adapter.write str3
          end
        }
@


1.31.2.7
log
@aamine
* lib/net/protocol.rb (ProtoSocket#read): modify typo.
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.36
d111 1
a112 1
    If protocol had been started, raises IOError.
d144 1
a144 1
    If SMTP session had not started, raises an IOError.
@


1.31.2.8
log
@Reflect the update of the MD5 module which is now Digest::MD5.
@
text
@d195 1
a195 1
require 'digest/md5'
d321 1
a321 1
        secret = Digest::MD5.digest( secret ) if secret.size > 64
d329 2
a330 2
        tmp = Digest::MD5.digest( isecret + challenge )
        tmp = Digest::MD5.hexdigest( osecret + tmp )
@


1.31.2.9
log
@aamine
* lib/net/smtp.rb: SMTP.new requires at least one arg.
* lib/net/pop.rb: POP.new requires at least one arg.
* lib/net/pop.rb: uses "raise *Error.new" instead of simple raise.
* lib/net/http.rb: HTTP.new requires at least one arg.
* lib/net/http.rb: changes implicit start algolithm.
@
text
@d13 3
a15 2
NOTE: You can find Japanese version of this document in
the doc/net directory of the standard ruby interpreter package.
d93 1
a93 1
: new( address, port = 25 )
d96 2
a97 2
: start( address, port = 25, helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil )
: start( address, port = 25, helo_domain = Socket.gethostname, account = nil, password = nil, authtype = nil ) {|smtp| .... }
d195 1
a195 1
require 'md5'
d207 1
a207 1
    def initialize( addr, port = nil )
d321 1
a321 1
        secret = MD5.new( secret ).digest if secret.size > 64
d329 2
a330 2
        tmp = MD5.new( isecret + challenge ).digest
        tmp = MD5.new( osecret + tmp ).hexdigest
@


1.31.2.10
log
@aamine
* lib/net/smtp.rb: uses Digest::MD5 instead of MD5 (again).
* lib/net/pop.rb: ditto.
* lib/net/http.rb (HTTP#request): must pass block.
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.37
d194 1
a194 1
require 'digest/md5'
d320 1
a320 1
        secret = Digest::MD5.digest( secret ) if secret.size > 64
d328 2
a329 2
        tmp = Digest::MD5.digest( isecret + challenge )
        tmp = Digest::MD5.hexdigest( osecret + tmp )
@


1.31.2.11
log
@aamine
* lib/net/protocol.rb: calls on_connect before conn_command
@
text
@d40 1
a40 1
        # use smtp object only in this block
d52 1
a52 1
        smtp.send_mail <<EndOfMail, 'your@@mail.address', 'to@@some.domain'
a62 17
=== Closing Session

You MUST close SMTP session after sending mails, by calling #finish
method. You can also use block form of SMTP.start/SMTP#start, which
closes session automatically. I strongly recommend later one. It is
more beautiful and simple.

    # using SMTP#finish
    smtp = Net::SMTP.start( 'your.smtp.server', 25 )
    smtp.send_mail mail_string, 'from@@address', 'to@@address'
    smtp.finish

    # using block form of SMTP.start
    Net::SMTP.start( 'your.smtp.server', 25 ) {|smtp|
        smtp.send_mail mail_string, 'from@@address', 'to@@address'
    }

d71 3
a73 3
        File.open( 'Mail/draft/1' ) {|f|
            smtp.send_mail f, 'your@@mail.address', 'to@@some.domain'
        }
d102 1
a102 1
            smtp.send_mail mail_string, 'from@@mail.address', 'dest@@mail.address'
d156 3
a158 3
            smtp.send_mail mail_string,
                           'from@@mail.address',
                           'dest@@mail.address' 'dest2@@mail.address'
d172 5
a176 5
	    smtp.ready( 'from@@mail.addr', 'dest@@mail.addr' ) do |adapter|
	      adapter.write str1
	      adapter.write str2
	      adapter.write str3
	    end
@


1.31.2.12
log
@aamine
* lib/net/protocol.rb: Protocol#start returns the return value of block.
* lib/net/protocol.rb: set timeout limit by default.
* lib/net/protocol.rb: new methods WriteAdapter#write, puts, print, printf.
* lib/net/protocol.rb: change template method scheme.
* lib/net/http.rb: rename HTTP#get2 to request_get, post2 to request_post ...
* lib/net/pop.rb: POP#auth_only did not work.
* lib/net/smtp.rb: should not resolve HELO domain automatically.
@
text
@d3 1
a3 1
= net/smtp.rb
a15 2
$Id: header.rd,v 1.2 2001/12/10 12:37:16 aamine Exp $

d93 1
a93 1
=== HELO domain
d95 2
a96 5
In almost all situation, you must designate the third argument
of SMTP.start/SMTP#start. It is the domain name which you are on
(the host to send mail from). It is called "HELO domain".
SMTP server will judge if he/she should send or reject
the SMTP session by inspecting HELO domain.
d101 3
d112 2
a113 2
: start( address, port = 25, helo_domain = 'localhost.localdomain', account = nil, password = nil, authtype = nil )
: start( address, port = 25, helo_domain = 'localhost.localdomain', account = nil, password = nil, authtype = nil ) {|smtp| .... }
d180 2
a181 3
    gives adapter object to the block. ADAPTER has these 5 methods:

        puts print printf write <<
d189 5
a193 7
	    smtp.ready( 'from@@mail.addr', 'dest@@mail.addr' ) {|f|
                f.puts 'From: aamine@@loveruby.net'
                f.puts 'To: someone@@somedomain.org'
                f.puts 'Subject: test mail'
                f.puts
                f.puts 'This is test mail.'
	    }
d216 1
d220 2
a221 1
    protocol_param :command_type, '::Net::SMTPCommand'
d230 13
d245 11
a255 1
    def do_start( helo = 'localhost.localdomain',
d257 5
a261 2
      conn_socket
      conn_command
d265 1
a265 1
          command().ehlo helo
d267 1
a267 1
          command().helo helo
d272 1
a272 1
          command().error_ok
d284 1
a284 1
        command().respond_to? mid or
d287 1
a287 1
        command().__send__ mid, user, secret
d291 1
a291 4
    def do_finish
      disconn_command
      disconn_socket
    end
d293 1
a294 3
    #
    # SMTP operations
    #
a295 1
    public
d297 1
a297 24
    def send_mail( mailsrc, from_addr, *to_addrs )
      do_ready from_addr, to_addrs.flatten
      command().write_mail mailsrc, nil
    end

    alias sendmail send_mail

    def ready( from_addr, *to_addrs, &block )
      do_ready from_addr, to_addrs.flatten
      command().write_mail nil, block
    end

    private

    def do_ready( from_addr, to_addrs )
      if to_addrs.empty? then
        raise ArgumentError, 'mail destination does not given'
      end
      command().mailfrom from_addr
      command().rcpt to_addrs
      command().data
    end

  end
d304 2
a305 2
      atomic {
          check_reply SuccessCode
d309 4
a312 3
    def helo( domain )
      atomic {
          getok sprintf('HELO %s', domain)
d316 4
a319 3
    def ehlo( domain )
      atomic {
          getok sprintf('EHLO %s', domain)
d323 1
d326 3
a328 3
      atomic {
          getok sprintf('AUTH PLAIN %s',
                        ["\0#{user}\0#{secret}"].pack('m').chomp)
d334 13
a346 13
      atomic {
          rep = getok( 'AUTH CRAM-MD5', ContinueCode )
          challenge = rep.msg.split(' ')[1].unpack('m')[0]
          secret = Digest::MD5.digest(secret) if secret.size > 64

          isecret = secret + "\0" * (64 - secret.size)
          osecret = isecret.dup
          0.upto( 63 ) do |i|
            isecret[i] ^= 0x36
            osecret[i] ^= 0x5c
          end
          tmp = Digest::MD5.digest( isecret + challenge )
          tmp = Digest::MD5.hexdigest( osecret + tmp )
d348 1
a348 1
          getok [user + ' ' + tmp].pack('m').chomp
d352 1
d354 2
a355 2
      atomic {
          getok sprintf('MAIL FROM:<%s>', fromaddr)
d359 1
d362 2
a363 2
        atomic {
            getok sprintf('RCPT TO:<%s>', i)
d368 1
d370 1
a370 1
      return unless begin_atomic
d375 1
a375 1
      @@socket.write_pendstr mailsrc, &block
d377 1
a377 1
      end_atomic
d380 1
d382 2
a383 2
      atomic {
          getok 'QUIT'
d387 1
d390 1
d411 1
d427 1
a427 7
  # for backward compatibility

  SMTPSession = SMTP

  module NetPrivate
    SMTPCommand = ::Net::SMTPCommand
  end
@


1.31.2.13
log
@aamine
* lib/net/http.rb: HTTP.Proxy should use self for proxy-class's super class.
* lib/net/http.rb: initialize HTTP.proxy_port by HTTP.port.
@
text
@@


1.31.2.14
log
@aamine
* lib/net/http.rb: remove unused class Accumulator.
* lib/net/http.rb: read response in HTTP#request. not HTTPRequest#exec.
* lib/net/http.rb: proxy related class instance variables are not initialized correctly.
* doc/net/http.rb: modify typo in the description of basic auth.
@
text
@d5 1
a5 1
Copyright (c) 1999-2002 Yukihiro Matsumoto
d16 1
a16 1
$Id: header.rd,v 1.2.2.1 2002/02/19 13:15:22 aamine Exp $
@


1.31.2.15
log
@* lib/net/protocol.rb: set read_timeout dynamically.
@
text
@@


1.30
log
@aamine
* lib/net/http.rb: does not send HEAD on closing socket.
@
text
@d3 1
a3 1
= net/smtp.rb version 1.2.0
@


1.29
log
@aamine
* lib/net/protocol.rb: set @@closed false in Socket#reopen.
* lib/net/pop.rb: add POP3.foreach, delete_all.
* lib/net/pop.rb: add POP3#delete_all.
* lib/net/http.rb: add HTTP.version_1_1, version_1_2
* lib/net/http.rb: refactoring.
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.32
@


1.28
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.31
* lib/net/http.rb: initializes header in HTTP, not HTTPCommand
* lib/net/protocol.rb, http.rb: rewrites proxy code
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.31
@


1.27
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.30
* lib/net/protocol.rb, smtp.rb: Command#critical_ok -> error_ok
* lib/net/http.rb: read header when also "100 Continue"
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.30
@


1.26
log
@aamine
* lib/net/protocol.rb: Command#critical_ok
* lib/net/smtp.rb: clear critical flag before go to SMTP
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.29
d149 1
a149 1
          @@command.critical_ok
@


1.25
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.28.
* lib/net/http.rb: HTTPReadAdapter -> HTTPResponseReceiver
* lib/net/http.rb (connecting): response is got in receive()
@
text
@d149 1
@


1.24
log
@matz: 1.6.0 final (hopufully)
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.28
d11 4
d40 1
a40 1
  When this methods is called with a block, give a SMTP object to block and
d49 1
a49 1
  from 'mailsrc' by calling 'each' method, and convert them
d69 1
a69 2
  In the block of this method, you can call ONLY 'write' method
  for 'adapter'.
@


1.23
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.27.
* lib/net/protocol.rb: writing methods returns written byte size.
* lib/net/smtp.rb: send_mail accepts many destinations.
@
text
@d36 1
a36 1
  When this methods is called as iterator, give a SMTP object to block and
d45 1
a45 1
  from 'mailsrc' by calling 'each' iterator, and convert them
d65 1
a65 1
  In the block of this iterator, you can call ONLY 'write' method
@


1.22
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.26.
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb:
  add module Net::NetPrivate and its inner classes
  {Read,Write}Adapter, Command, Socket,
  SMTPCommand, POP3Command, APOPCommand, HTTPCommand
@
text
@d3 1
a3 1
= net/smtp.rb version 1.1.27
d7 3
a9 2
This library is distributed under the terms of the Ruby license.
You can freely distribute/modify this library.
d25 1
a25 1
  same to Net::SMTP.new( address, port ).start( *protoargs )
d42 3
a44 3
: send_mail( mailsrc, from_addr, to_addrs )
: sendmail( mailsrc, from_addr, to_addrs )
  This method sends 'mailsrc' as mail. SMTPSession read strings
d49 1
a49 1
  to_addrs must be Array of String, or String.
d57 6
d70 1
a70 1
    SMTP.start( 'localhost', 25 ) do |smtp|
d79 2
a80 2
  This method ends SMTP.
  If protocol had not started, do nothind and return false.
a101 1

d104 2
a105 2
    def send_mail( mailsrc, from_addr, to_addrs )
      do_ready from_addr, to_addrs
d108 1
d111 2
a112 2
    def ready( from_addr, to_addrs, &block )
      do_ready from_addr, to_addrs
d121 3
a123 1
      to_addrs = [to_addrs] if String === to_addrs
d131 1
d133 2
a134 5
        helodom = ::Socket.gethostname
        unless helodom then
          raise ArgumentError,
            "cannot get localhost name; try 'smtp.start(local_host_name)'"
        end
a243 1

a248 1
    alias sendmail write_mail
a283 1

d291 1
a291 1
      return arr
@


1.21
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.25.
* lib/net/protocol.rb (each_crlf_line): beg = 0 is needed in adding{}
* lib/net/smtp.rb: allow String for to_addr of SMTP#sendmail
@
text
@d3 1
a3 1
= net/smtp.rb
d87 1
a87 1
    protocol_param :command_type, '::Net::SMTPCommand'
d160 3
d292 4
a295 1
end
@


1.20
log
@o  protocol.rb, smtp.rb, pop.rb, http.rb:  define all#inspect()
o  protocol.rb, smtp.rb, pop.rb, http.rb:  modify/add documents
@
text
@d41 1
d47 3
d98 2
a99 2
    def sendmail( mailsrc, fromaddr, toaddrs )
      do_ready fromaddr, toaddrs
d102 1
d104 2
a105 2
    def ready( fromaddr, toaddrs, &block )
      do_ready fromaddr, toaddrs
d113 4
a116 3
    def do_ready( fromaddr, toaddrs )
      @@command.mailfrom fromaddr
      @@command.rcpt toaddrs
@


1.19
log
@o  smtp.rb:  not catch NameError in auth
o  http.rb:  not close connection in get_body,
   Only connection() closes socket
@
text
@a9 11
=end


require 'net/protocol'
require 'md5'


module Net


=begin
d72 7
@


1.18
log
@o  protocol.rb, http.rb, smtp.rb, pop.rb:  update RD documents
@
text
@d144 2
a145 4
        begin
          mid = 'auth_' + (authtype || 'cram_md5').to_s
          @@command.send mid, user, secret
        rescue NameError
d148 1
@


1.17
log
@o  protocol.rb:  Protocol#start yields self
o  smtp.rb:  use Socket.gethostname to get localhost name
p  pop.rb:  use MD5#hexdigest
@
text
@d31 1
a31 1
  This method create new SMTP object.
d33 3
d39 5
a43 2
: start( helo_domain = ENV['HOSTNAME'] || ENV['HOST'], account = nil, password = nil, authtype = nil )
  This method opens TCP connection and start SMTP.
d45 3
@


1.16
log
@version 1.1.16
o smtp.rb:  SMTP AUTH (contributed by Kazuhiro Izawa)
@
text
@d112 1
a112 1
        helodom = ENV['HOSTNAME'] || ENV['HOST']
d114 2
a115 1
          raise ArgumentError, "cannot get hostname"
@


1.15
log
@{protocol,smtp,pop}.rb version 1.1.14
o  http.rb:  HTTP#head2
o  http.rb:  HTTPResponse#value
o  http.rb:  get2/post2 returns response header
o  http.rb:  *2 does not raise exceptions
o  smtp.rb:  try esmtp only first time
o  protocol.rb:  remove error_occured
o  protocol.rb:  Command#error! does not take argument
@
text
@d14 1
d36 1
a36 1
: start( helo_domain = ENV['HOSTNAME'] )
d40 3
d109 2
a110 1
    def do_start( helodom = ENV['HOSTNAME'] )
d112 4
a115 1
        raise ArgumentError, "cannot get hostname"
a117 1
      @@esmtp = false
d132 9
d173 29
a245 1
      klass = UnknownCode
d253 1
d257 1
d266 3
a268 1
      while (str = @@socket.readline)[3] == ?- do   # ex: "210-..."
@


1.14
log
@protocol.rb smtp.rb pop.rb http.rb version 1.1.12

o protocol.rb:  update Net::Protocol::Proxy#connect
o protocol.rb:  ReplyCode is not a class
o http.rb:  header value does not include header name
o http.rb:  header is not a Hash, but HTTPResponse
@
text
@d77 8
a95 3
    attr :esmtp


d112 5
a116 2
        @@command.ehlo helodom
        @@esmtp = true
d118 6
a123 1
        @@command.helo helodom
@


1.13
log
@v1.1.11
o  all:  use "critical" to avoid duplicated command dispatch
o  http.rb:  change get2, post2 usage (HTTPWriter)
o  http.rb:  entity reading algorithm is better
o  http.rb:  more reply code (4xx, 5xx)
o  protocol.rb:  arguments of "connect" can be omitted
o  protocol.rb:  "quit" is not template method (now do_quit is removed)
o  protocol.rb:  ReplyCode.error_type was not work: using module_eval
@
text
@d79 1
a79 1
      @@command.write_mail mailsrc
d84 1
a84 1
      @@command.write_mail( &block )
d166 2
a167 2
    def write_mail( mailsrc = nil, &block )
      @@socket.write_pendstr mailsrc, &block
d192 1
a192 1
              when ?4 then ServerBusyCode
d200 1
a200 1
      klass.new( stat, arr.join('') )
@


1.12
log
@o  protocol.rb:  version 1.1.9
o  smtp.rb:  arguments discription of do_ready was wrongly void
@
text
@d124 3
a126 1
      check_reply SuccessCode
d131 3
a133 1
      getok sprintf( 'HELO %s', fromdom )
d138 3
a140 1
      getok sprintf( 'EHLO %s', fromdom )
d145 3
a147 1
      getok sprintf( 'MAIL FROM:<%s>', fromaddr )
d153 3
a155 1
        getok sprintf( 'RCPT TO:<%s>', i )
d161 1
d169 1
d174 5
a178 1
    private
d181 1
a181 3
    def do_quit
      getok 'QUIT'
    end
@


1.11
log
@Version 1.1.6

o  all:  use 'attr_reader/writer' instead of 'attr'
o  http.rb:  get/head allow implicit 'start'
o  http.rb:  change connection state algorithm
o  http.rb:  process user header before write
o  protocol.rb:  refine start/finish
o  protocol.rb:  Command#last_reply
o  protocol.rb:  ReplyCode.error!
@
text
@d77 3
a79 5
    def sendmail( mailsrc, fromaddr, toaddrs, &block )
      @@command.mailfrom fromaddr
      @@command.rcpt toaddrs
      @@command.data
      @@command.write_mail( mailsrc, &block )
d83 2
a84 1
      sendmail nil, fromaddr, toaddrs, &block
d94 6
a118 42
=begin

== Net::SMTPCommand

=== Super Class

Net::Command

=== Class Methods

: new( socket )
  This method creates new SMTPCommand object, and open SMTP.


=== Methods

: helo( helo_domain )
  This method send "HELO" command and start SMTP.
  helo_domain is localhost's FQDN.

: mailfrom( from_addr )
  This method sends "MAIL FROM" command.
  from_addr is your mail address (xxxx@@xxxx)

: rcpt( to_addrs )
  This method sends "RCPT TO" command.
  to_addrs is array of mail address (xxxx@@xxxx) of destination.

: data
  This method sends "DATA" command.

: write_mail( mailsrc )
: write_mail {|socket| ... }
  send 'mailsrc' as mail.
  SMTPCommand reads strings from 'mailsrc' by calling 'each' iterator. 
  When iterator, SMTPCommand only stand by socket and pass it.
  (The socket will accepts only 'in_write' method in the block)

: quit
  This method sends "QUIT" command and ends SMTP session.

=end
d155 1
a155 1
    def write_mail( mailsrc, &block )
@


1.10
log
@o  session.rb -> protocol.rb
o  write, write_pendstr takes block
o  smtp.ready
o  popmail.pop takes block
@
text
@d39 1
a39 1
: sendmail( mailsrc, from_domain, to_addrs )
d50 1
a50 1
: ready( from_domain, to_addrs ) {|adapter| .... }
d136 1
a136 1
  from_addr is your mail address(????@@????).
d140 1
a140 1
  to_addrs is array of mail address(???@@???) of destination.
@


1.9
log
@Version 1.1.4

o  (HTTP) allow no content-length data
@
text
@d13 1
a13 1
require 'net/session'
d50 15
d77 1
a77 1
    def sendmail( mailsrc, fromaddr, toaddrs )
d81 1
a81 1
      @@command.sendmail mailsrc
d84 7
d99 8
a106 1
      @@command.helo helodom
d142 9
a150 3
: data( mailsrc )
  This method send 'mailsrc' as mail. SMTP reads strings from 'mailsrc'
  by calling 'each' iterator. 
d170 5
d192 2
a193 2
    def writemail( mailsrc )
      @@socket.write_pendstr mailsrc
d196 1
a196 1
    alias sendmail writemail
@


1.8
log
@o  remove RD white lines
@
text
@a57 2
    Version = '1.1.3'

@


1.7
log
@Net version 1.1.3

o  http.rb rd
o  Session -> Protocol
@
text
@a29 1

a35 1

d40 3
a42 3

  This method sends 'mailsrc' as mail. SMTPSession read strings from 'mailsrc'
  by calling 'each' iterator, and convert them into "\r\n" terminated string when write.
a50 1

a97 1

a103 1

a107 1

a111 1

a115 1

a119 1

@


1.6
log
@Version 1.1.2

o  proxy, version 1
o  use fullpath shvar
@
text
@d7 2
a8 2
This library is distributed under the terms of Ruby license.
You can freely distribute/modify this file.
d21 1
a21 1
== Net::SMTPSession
d25 1
a25 1
Net::Session
d31 1
a31 1
  This method create new SMTPSession object.
d38 2
a39 2
  This method opens TCP connection and start SMTP session.
  If session had been started, do nothing and return false.
d46 5
a50 5
  SMTPSession's Exceptions are:
  * Protocol::ProtoSyntaxError: syntax error (errno.500)
  * Protocol::ProtoFatalError: fatal error (errno.550)
  * Protocol::ProtoUnknownError: unknown error
  * Protocol::ProtoServerBusy: temporary error (errno.420/450)
d54 2
a55 2
  This method closes SMTP session.
  If session had not started, do nothind and return false.
d59 1
a59 1
  class SMTPSession < Session
d61 1
a61 1
    Version = '1.1.2'
d63 2
a64 2
    session_setvar :port,         '25'
    session_setvar :command_type, 'Net::SMTPCommand'
d68 4
a71 4
      @@proto.mailfrom fromaddr
      @@proto.rcpt toaddrs
      @@proto.data
      @@proto.sendmail mailsrc
d82 1
a82 1
      @@proto.helo helodom
d87 1
a87 1
  SMTP = SMTPSession
d102 1
a102 1
  This method creates new SMTPCommand object, and open SMTP session.
d109 1
a109 1
  This method send "HELO" command and start SMTP session.
d142 1
a142 2
      @@socket.writeline( 'HELO ' << fromdom )
      check_reply( SuccessCode )
d147 1
a147 2
      @@socket.writeline( 'MAIL FROM:<' + fromaddr + '>' )
      check_reply( SuccessCode )
d153 1
a153 2
        @@socket.writeline( 'RCPT TO:<' + i + '>' )
        check_reply( SuccessCode )
d159 1
a159 2
      @@socket.writeline( 'DATA' )
      check_reply( ContinueCode )
d164 2
a165 2
      @@socket.write_pendstr( mailsrc )
      check_reply( SuccessCode )
d174 1
a174 2
      @@socket.writeline( 'QUIT' )
      check_reply( SuccessCode )
d182 11
a192 11
      cls = UnknownCode
      case stat[0]
      when ?2 then cls = SuccessCode
      when ?3 then cls = ContinueCode
      when ?4 then cls = ServerBusyCode
      when ?5 then
        case stat[1]
        when ?0 then cls = SyntaxErrorCode
        when ?5 then cls = FatalErrorCode
        end
      end
d194 1
a194 1
      return cls.new( stat, arr.join('') )
@


1.5
log
@Version 1.1.1

o  HTTP chunk data
@
text
@d61 1
a61 1
    Version = '1.1.1'
d64 1
a64 1
    session_setvar :command_type, 'SMTPCommand'
@


1.4
log
@Version 1.1.0
o  http.rb
o  support class swap
o  Net.quote
@
text
@d61 1
a61 1
    Version = '1.1.0'
@


1.3
log
@19991018
@
text
@d3 1
a3 1
= Net module version 1.0.3 reference manual
d5 1
a5 1
smtp.rb written by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d7 2
a8 2
This library is distributed under the terms of Ruby style license.
You can freely redistribute/modify/copy this file.
d16 3
a32 12
=end

module Net

  class SMTPSession < Session

    def proto_initialize
      @@proto_type = SMTPCommand
      @@port       = 25
    end

=begin
d59 8
d68 2
a69 2
      @@proto.mailfrom( fromaddr )
      @@proto.rcpt( toaddrs )
d71 1
a71 1
      @@proto.sendmail( mailsrc )
d78 1
a78 1
    def do_start( helodom = nil )
d80 1
a80 1
        helodom = ENV[ 'HOSTNAME' ]
d82 1
a82 5
      @@proto.helo( helodom )
    end

    def do_finish
      @@proto.quit
d109 1
a109 1
  This method send "HELO" command and start SMTP session.<br>
d114 1
a114 1
  This method sends "MAIL FROM" command.<br>
d119 1
a119 1
  This method sends "RCPT TO" command.<br>
d135 6
d167 1
a167 1
    def sendmail( mailsrc )
d171 1
a213 5
  end


  unless Session::Version == '1.0.3' then
    $stderr.puts "WARNING: wrong version of session.rb & smtp.rb"
@


1.2
log
@maillib-1.0.2
@
text
@d3 1
a3 1
= Net module version 1.0.2 reference manual
d215 1
a215 1
  unless Session::Version == '1.0.2' then
@


1.1
log
@maillib-1.0.1
@
text
@d1 11
a11 5
#
# smtp.rb  version 1.0.1
#
#   author Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
#
d16 16
d41 27
d95 42
d215 1
a215 1
  unless Session::Version == '1.0.1' then
@


1.1.2.1
log
@maillib-1.0.2
@
text
@d1 5
a5 11
=begin

= Net module version 1.0.2 reference manual

smtp.rb written by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>

This library is distributed under the terms of Ruby style license.
You can freely redistribute/modify/copy this file.

=end

a9 16
=begin

== Net::SMTPSession

=== Super Class

Net::Session

=== Class Methods

: new( address = 'localhost', port = 25 )

  This method create new SMTPSession object.

=end

a18 27
=begin

=== Methods

: start( helo_domain = ENV['HOSTNAME'] )

  This method opens TCP connection and start SMTP session.
  If session had been started, do nothing and return false.

: sendmail( mailsrc, from_domain, to_addrs )

  This method sends 'mailsrc' as mail. SMTPSession read strings from 'mailsrc'
  by calling 'each' iterator, and convert them into "\r\n" terminated string when write.

  SMTPSession's Exceptions are:
  * Protocol::ProtoSyntaxError: syntax error (errno.500)
  * Protocol::ProtoFatalError: fatal error (errno.550)
  * Protocol::ProtoUnknownError: unknown error
  * Protocol::ProtoServerBusy: temporary error (errno.420/450)

: finish

  This method closes SMTP session.
  If session had not started, do nothind and return false.

=end

a45 42
=begin

== Net::SMTPCommand

=== Super Class

Net::Command

=== Class Methods

: new( socket )

  This method creates new SMTPCommand object, and open SMTP session.


=== Methods

: helo( helo_domain )

  This method send "HELO" command and start SMTP session.<br>
  helo_domain is localhost's FQDN.

: mailfrom( from_addr )

  This method sends "MAIL FROM" command.<br>
  from_addr is your mail address(????@@????).

: rcpt( to_addrs )

  This method sends "RCPT TO" command.<br>
  to_addrs is array of mail address(???@@???) of destination.

: data( mailsrc )

  This method send 'mailsrc' as mail. SMTP reads strings from 'mailsrc'
  by calling 'each' iterator. 

: quit

  This method sends "QUIT" command and ends SMTP session.

=end
d124 1
a124 1
  unless Session::Version == '1.0.2' then
@


1.1.2.2
log
@net/ version 1.1.3 for ruby 1.4
@
text
@d3 1
a3 1
= net/smtp.rb
d5 1
a5 1
written by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d7 2
a8 2
This library is distributed under the terms of the Ruby license.
You can freely distribute/modify this library.
a15 3
module Net


d18 1
a18 1
== Net::SMTP
d22 1
a22 1
Net::Protocol
a26 1
  This method create new SMTP object.
d28 14
d46 3
a48 2
  This method opens TCP connection and start SMTP.
  If protocol had been started, do nothing and return false.
a50 9
  This method sends 'mailsrc' as mail. SMTPSession read strings
  from 'mailsrc' by calling 'each' iterator, and convert them
  into "\r\n" terminated string when write.

  Exceptions which SMTP raises are:
  * Net::ProtoSyntaxError: syntax error (errno.500)
  * Net::ProtoFatalError: fatal error (errno.550)
  * Net::ProtoUnknownError: unknown error
  * Net::ProtoServerBusy: temporary error (errno.420/450)
d52 2
a53 3
: finish
  This method ends SMTP.
  If protocol had not started, do nothind and return false.
d55 5
a59 1
=end
d61 1
a61 1
  class SMTP < Protocol
d63 2
a64 4
    Version = '1.1.3'

    protocol_param :port,         '25'
    protocol_param :command_type, '::Net::SMTPCommand'
d66 1
d69 4
a72 4
      @@command.mailfrom fromaddr
      @@command.rcpt toaddrs
      @@command.data
      @@command.sendmail mailsrc
d79 1
a79 1
    def do_start( helodom = ENV['HOSTNAME'] )
d81 1
a81 1
        raise ArgumentError, "cannot get hostname"
d83 5
a87 1
      @@command.helo helodom
d92 1
a92 1
  SMTPSession = SMTP
d106 2
a107 1
  This method creates new SMTPCommand object, and open SMTP.
d113 2
a114 1
  This method send "HELO" command and start SMTP.
d118 2
a119 1
  This method sends "MAIL FROM" command.
d123 2
a124 1
  This method sends "RCPT TO" command.
d128 1
d133 1
a139 6
    def initialize( sock )
      super
      check_reply SuccessCode
    end


d141 2
a142 1
      getok sprintf( 'HELO %s', fromdom )
d147 2
a148 1
      getok sprintf( 'MAIL FROM:<%s>', fromaddr )
d154 2
a155 1
        getok sprintf( 'RCPT TO:<%s>', i )
d161 2
a162 1
      getok 'DATA', ContinueCode
d166 3
a168 3
    def writemail( mailsrc )
      @@socket.write_pendstr mailsrc
      check_reply SuccessCode
a169 1
    alias sendmail writemail
d176 2
a177 1
      getok 'QUIT'
d185 11
a195 11
      klass = UnknownCode
      klass = case stat[0]
              when ?2 then SuccessCode
              when ?3 then ContinueCode
              when ?4 then ServerBusyCode
              when ?5 then
                case stat[1]
                when ?0 then SyntaxErrorCode
                when ?5 then FatalErrorCode
                end
              end
d197 1
a197 1
      klass.new( stat, arr.join('') )
d212 5
@


1.1.2.3
log
@Version 1.1.4

o (HTTP) allow no content-length message
@
text
@d58 2
@


1.1.2.4
log
@version 1.1.7 for ruby-1.4
protocol.rb smtp.rb pop.rb http.rb
@
text
@d13 1
a13 1
require 'net/protocol'
d39 1
a39 1
: sendmail( mailsrc, from_addr, to_addrs )
a49 15
: ready( from_addr, to_addrs ) {|adapter| .... }
  This method stands by the SMTP object for sending mail.
  In the block of this iterator, you can call ONLY 'write' method
  for 'adapter'.

    # usage example

    SMTP.start( 'localhost', 25 ) do |smtp|
      smtp.ready( from, to ) do |adapter|
        adapter.write str1
        adapter.write str2
        adapter.write str3
      end
    end

d62 1
a62 1
    def sendmail( mailsrc, fromaddr, toaddrs, &block )
d66 1
a66 1
      @@command.write_mail( mailsrc, &block )
a68 7
    def ready( fromaddr, toaddrs, &block )
      sendmail nil, fromaddr, toaddrs, &block
    end


    attr :esmtp

d77 1
a77 8

      @@esmtp = false
      begin
        @@command.ehlo helodom
        @@esmtp = true
      rescue ProtocolError
        @@command.helo helodom
      end
d107 1
a107 1
  from_addr is your mail address (xxxx@@xxxx)
d111 1
a111 4
  to_addrs is array of mail address (xxxx@@xxxx) of destination.

: data
  This method sends "DATA" command.
d113 3
a115 6
: write_mail( mailsrc )
: write_mail {|socket| ... }
  send 'mailsrc' as mail.
  SMTPCommand reads strings from 'mailsrc' by calling 'each' iterator. 
  When iterator, SMTPCommand only stand by socket and pass it.
  (The socket will accepts only 'in_write' method in the block)
a134 5
    def ehlo( fromdom )
      getok sprintf( 'EHLO %s', fromdom )
    end


d152 2
a153 2
    def write_mail( mailsrc, &block )
      @@socket.write_pendstr mailsrc, &block
d156 1
a156 1
    alias sendmail write_mail
@


1.1.2.5
log
@protocol.rb/smtp.rb/pop.rb/http.rb 1.1.8
o  http.rb:  post, get2, post2, get_body
@
text
@d77 5
a81 3
    def sendmail( mailsrc, fromaddr, toaddrs )
      do_ready fromaddr, toaddrs
      @@command.write_mail mailsrc
d85 1
a85 2
      do_ready fromaddr, toaddrs
      @@command.write_mail( &block )
a94 6
    def do_ready
      @@command.mailfrom fromaddr
      @@command.rcpt toaddrs
      @@command.data
    end

d114 42
d192 1
a192 1
    def write_mail( mailsrc = nil, &block )
@


1.1.2.6
log
@protocol.rb smtp.rb pop.rb http.rb 1.1.9 for ruby 1.4 branch
@
text
@d94 1
a94 1
    def do_ready( fromaddr, toaddrs )
@


1.1.2.7
log
@o  all:  use "critical" to avoid duplicated command dispatch
o  http.rb:  change get2, post2 usage (HTTPWriter)
o  http.rb:  entity reading algorithm is better
o  http.rb:  more reply code (4xx, 5xx)
o  protocol.rb:  arguments of "connect" can be omitted
o  protocol.rb:  "quit" is not template method (now do_quit is removed)
o  protocol.rb:  ReplyCode.error_type was not work: using module_eval
@
text
@d124 1
a124 3
      critical {
        check_reply SuccessCode
      }
d129 1
a129 3
      critical {
        getok sprintf( 'HELO %s', fromdom )
      }
d134 1
a134 3
      critical {
        getok sprintf( 'EHLO %s', fromdom )
      }
d139 1
a139 3
      critical {
        getok sprintf( 'MAIL FROM:<%s>', fromaddr )
      }
d145 1
a145 3
        critical {
          getok sprintf( 'RCPT TO:<%s>', i )
        }
a150 1
      return unless begin_critical
a157 1
      end_critical
d162 1
a162 5
    def quit
      critical {
        getok 'QUIT'
      }
    end
d165 3
a167 1
    private
@


1.1.2.8
log
@protocol.rb smtp.rb pop.rb http.rb 1.1.12 for ruby 1.4 branch
@
text
@d79 1
a79 1
      @@command.write_mail mailsrc, nil
d84 1
a84 1
      @@command.write_mail nil, block
d166 2
a167 2
    def write_mail( mailsrc, block )
      @@socket.write_pendstr mailsrc, block
d192 1
a192 1
              when ?4 then ServerErrorCode
d200 1
a200 1
      Response.new( klass, stat, arr.join('') )
@


1.1.2.9
log
@{protocol,smtp,pop,http}.rb for ruby 1.4 branch
@
text
@a76 8
    def initialize( addr = nil, port = nil )
      super
      @@esmtp = true
    end


    attr :esmtp

d88 3
d107 2
a108 5
        if @@esmtp then
          @@command.ehlo helodom
        else
          @@command.helo helodom
        end
d110 1
a110 6
        if @@esmtp then
          @@esmtp = false
          retry
        else
          raise
        end
@


1.1.2.10
log
@version 1.1.16
o smtp.rb:  SMTP AUTH (contributed by Kazuhiro Izawa)
@
text
@a13 1
require 'md5'
d35 1
a35 1
: start( helo_domain = ENV['HOSTNAME'] || ENV['HOST'], account = nil, password = nil, authtype = nil )
a38 3
  If account and password are given, is trying to get authentication
  by using AUTH command. "authtype" is :plain (symbol) or :cram_md5.

d105 1
a105 2
    def do_start( helodom = nil,
                  user = nil, secret = nil, authtype = nil )
d107 1
a107 4
        helodom = ENV['HOSTNAME'] || ENV['HOST']
        unless helodom then
          raise ArgumentError, "cannot get hostname"
        end
d110 1
a124 9

      if user and secret then
        begin
          mid = 'auth_' + (authtype || 'cram_md5').to_s
          @@command.send mid, user, secret
        rescue NameError
          raise ArgumentError, "wrong auth type #{authtype.to_s}"
        end
      end
a156 29
    # "PLAIN" authentication [RFC2554]
    def auth_plain( user, secret )
      critical {
        getok sprintf( 'AUTH PLAIN %s',
                       ["\0#{user}\0#{secret}"].pack('m').chomp )
      }
    end

    # "CRAM-MD5" authentication [RFC2195]
    def auth_cram_md5( user, secret )
      critical {
        rep = getok( 'AUTH CRAM-MD5', ContinueCode )
        challenge = rep.msg.split(' ')[1].unpack('m')[0]
        secret = MD5.new( secret ).digest if secret.size > 64

        isecret = secret + "\0" * (64 - secret.size)
        osecret = isecret.dup
        0.upto( 63 ) do |i|
          isecret[i] ^= 0x36
          osecret[i] ^= 0x5c
        end
        tmp = MD5.new( isecret + challenge ).digest
        tmp = MD5.new( osecret + tmp ).hexdigest

        getok [user + ' ' + tmp].pack('m').chomp
      }
    end


d201 1
a208 1
                when ?3 then AuthErrorCode
a211 1
      klass ||= UnknownCode
d220 1
a220 3
      while true do
        str = @@socket.readline
        break unless str[3] == ?-   # ex: "210-..."
@


1.1.2.11
log
@o  protocol.rb:  Protocol#start yields self
o  smtp.rb:  use Socket.gethostname to get localhost name
@
text
@d112 1
a112 1
        helodom = ::Socket.gethostname
d114 1
a114 2
          raise ArgumentError,
            "cannot get localhost name; try 'smtp.start(local_host_name)'"
@


1.1.2.12
log
@o  protocol.rb, http.rb, smtp.rb, pop.rb:  update RD documents
@
text
@d31 1
a31 1
  creates a new Net::SMTP object.
a32 3
: start( address = 'localhost', port = 25, *protoargs )
: start( address = 'localhost', port = 25, *protoargs ) {|smtp| .... }
  same to Net::SMTP.new( address, port ).start( *protoargs )
d36 2
a37 5
: start( helo_domain = Socket.gethostname, \
         account = nil, password = nil, authtype = nil )
: start( helo_domain = Socket.gethostname, \
         account = nil, password = nil, authtype = nil ) {|smtp| .... }
  opens TCP connection and starts SMTP session.
a38 3

  When this methods is called as iterator, give a SMTP object to block and
  close session after block call finished.
@


1.1.2.13
log
@o  http.rb:  not close connection in get_body,
   Only connection() closes socket
@
text
@d144 4
a147 2
        mid = 'auth_' + (authtype || 'cram_md5').to_s
        unless @@command.respond_to? mid then
a149 1
        @@command.send mid, user, secret
@


1.1.2.14
log
@o  protocol.rb, smtp.rb, pop.rb, http.rb:  define all#inspect()
o  protocol.rb, smtp.rb, pop.rb, http.rb:  modify/add documents
@
text
@d10 11
a82 7

require 'net/protocol'
require 'md5'


module Net

@


1.1.2.15
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.25.
* lib/net/protocol.rb (each_crlf_line): beg = 0 is needed in adding{}
* lib/net/smtp.rb: allow String for to_addr of SMTP#sendmail
@
text
@a40 1
: send_mail( mailsrc, from_addr, to_addrs )
a45 3
  from_addr must be String.
  to_addrs must be Array of String, or String.

d94 2
a95 2
    def send_mail( mailsrc, from_addr, to_addrs )
      do_ready from_addr, to_addrs
a97 1
    alias sendmail send_mail
d99 2
a100 2
    def ready( from_addr, to_addrs, &block )
      do_ready from_addr, to_addrs
d108 3
a110 4
    def do_ready( from_addr, to_addrs )
      to_addrs = [to_addrs] if String === to_addrs
      @@command.mailfrom from_addr
      @@command.rcpt to_addrs
@
