head	1.48;
access;
symbols
	v1_6_7:1.27.2.13
	v1_6_6:1.27.2.9
	v1_6_5:1.27.2.5
	v1_6_4:1.27.2.2
	v1_7_1:1.31
	v1_6_4_preview4:1.27.2.2
	v1_6_4_preview3:1.27.2.2
	v1_6_4_preview2:1.27.2.2
	v1_6_4_preview1:1.27.2.2
	v1_6_3:1.27.2.2
	ruby_m17n:1.27.0.4
	ruby_1_6:1.27.0.2
	v1_6_2:1.27
	v1_6_1:1.21
	v1_6_0:1.19
	v1_4_6:1.1.2.11
	v1_4_5:1.1.2.11
	v1_4_4:1.1.2.3
	V1-1-3:1.7
	V1-1-1:1.5
	ruby_1_4_3:1.1.2.1
	ruby1_4_3:1.1.2.1
	v1_4_3:1.1.2.1
	v1_5_0:1.3
	ruby_1_4_3_pre1:1.1.2.1
	ruby_1_4:1.1.0.2;
locks; strict;
comment	@# @;


1.48
date	2002.10.02.16.45.35;	author nobu;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.26.11.18.02;	author aamine;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.22.12.10.58;	author aamine;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.19.12.33.52;	author aamine;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.07.20.22.39;	author aamine;	state Exp;
branches;
next	1.43;

1.43
date	2001.12.30.19.18.45;	author aamine;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.20.05.00.20;	author aamine;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.13.19.15.21;	author aamine;	state Exp;
branches;
next	1.40;

1.40
date	2001.12.09.08.58.30;	author aamine;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.07.10.04.25;	author aamine;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.01.14.03.19;	author knu;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.17.03.08.45;	author aamine;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.08.07.00.23;	author aamine;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.03.19.03.16;	author aamine;	state Exp;
branches;
next	1.34;

1.34
date	2001.07.03.18.13.13;	author aamine;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.27.00.59.08;	author aamine;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.26.23.49.21;	author aamine;	state Exp;
branches;
next	1.31;

1.31
date	2001.02.24.04.53.50;	author aamine;	state Exp;
branches;
next	1.30;

1.30
date	2001.02.06.12.26.25;	author aamine;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.06.11.14.51;	author aamine;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.13.19.07.15;	author aamine;	state Exp;
branches;
next	1.27;

1.27
date	2000.12.24.20.01.43;	author aamine;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2000.12.24.19.39.15;	author aamine;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.22.18.40.55;	author aamine;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.10.23.31.32;	author aamine;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.07.11.27.16;	author aamine;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.12.09.54.32;	author aamine;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.21.06.58.01;	author aamine;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.12.05.37.35;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.16.19.26.07;	author aamine;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.12.06.04.40;	author aamine;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.12.16.42.46;	author aamine;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.18.08.57.37;	author aamine;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.17.18.39.43;	author aamine;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.14.10.41.35;	author aamine;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.31.13.02.40;	author aamine;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.27.15.52.27;	author aamine;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.26.08.48.15;	author aamine;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.21.15.25.37;	author aamine;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.21.12.52.24;	author aamine;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.05.07.55.36;	author aamine;	state Exp;
branches;
next	1.7;

1.7
date	99.12.29.11.14.04;	author aamine;	state Exp;
branches;
next	1.6;

1.6
date	99.12.22.13.49.13;	author aamine;	state Exp;
branches;
next	1.5;

1.5
date	99.12.20.20.48.49;	author aamine;	state Exp;
branches;
next	1.4;

1.4
date	99.12.17.15.00.13;	author aamine;	state Exp;
branches;
next	1.3;

1.3
date	99.10.18.09.03.01;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.10.13.07.28.09;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	99.09.22.07.32.33;	author matz;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	99.10.13.07.29.15;	author matz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2000.01.16.08.15.50;	author aamine;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2000.01.21.12.53.38;	author aamine;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2000.03.15.13.30.27;	author aamine;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2000.03.23.21.56.16;	author aamine;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2000.03.27.15.52.56;	author aamine;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2000.03.31.13.03.16;	author aamine;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2000.04.14.10.42.57;	author aamine;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2000.05.17.18.37.28;	author aamine;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2000.05.18.08.56.59;	author aamine;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2000.06.12.16.42.24;	author aamine;	state Exp;
branches;
next	;

1.27.2.1
date	2001.02.13.07.55.16;	author aamine;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2001.02.24.06.38.35;	author aamine;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2001.06.26.23.49.02;	author aamine;	state Exp;
branches;
next	1.27.2.4;

1.27.2.4
date	2001.06.27.00.59.52;	author aamine;	state Exp;
branches;
next	1.27.2.5;

1.27.2.5
date	2001.07.08.07.01.21;	author aamine;	state Exp;
branches;
next	1.27.2.6;

1.27.2.6
date	2001.12.01.14.07.01;	author knu;	state Exp;
branches;
next	1.27.2.7;

1.27.2.7
date	2001.12.07.09.40.16;	author aamine;	state Exp;
branches;
next	1.27.2.8;

1.27.2.8
date	2001.12.07.10.12.52;	author aamine;	state Exp;
branches;
next	1.27.2.9;

1.27.2.9
date	2001.12.09.08.58.06;	author aamine;	state Exp;
branches;
next	1.27.2.10;

1.27.2.10
date	2002.01.15.03.34.59;	author aamine;	state Exp;
branches;
next	1.27.2.11;

1.27.2.11
date	2002.02.07.20.29.58;	author aamine;	state Exp;
branches;
next	1.27.2.12;

1.27.2.12
date	2002.02.19.13.40.23;	author aamine;	state Exp;
branches;
next	1.27.2.13;

1.27.2.13
date	2002.02.22.12.50.22;	author aamine;	state Exp;
branches;
next	;


desc
@@


1.48
log
@use Object#class instead of deprecated Object#type.
@
text
@=begin

= net/pop.rb

Copyright (c) 1999-2002 Yukihiro Matsumoto

written & maintained by Minero Aoki <aamine@@loveruby.net>

This program is free software. You can re-distribute and/or
modify this program under the same terms as Ruby itself,
Ruby Distribute License or GNU General Public License.

NOTE: You can find Japanese version of this document in
the doc/net directory of the standard ruby interpreter package.

$Id: pop.rb,v 1.47 2002/03/26 11:18:02 aamine Exp $

== What is This Module?

This module provides your program the functions to retrieve
mails via POP3, Post Office Protocol version 3. For details
of POP3, refer [RFC1939] ((<URL:http://www.ietf.org/rfc/rfc1939.txt>)).

== Examples

=== Retrieving Mails

This example retrieves mails from server and delete it (on server).
Mails are written in file named 'inbox/1', 'inbox/2', ....
Replace 'pop3.server.address' your POP3 server address.

    require 'net/pop'

    pop = Net::POP3.new( 'pop3.server.address', 110 )
    pop.start( 'YourAccount', 'YourPassword' )          ###
    if pop.mails.empty? then
      puts 'no mail.'
    else
      i = 0
      pop.each_mail do |m|   # or "pop.mails.each ..."
	File.open( 'inbox/' + i.to_s, 'w' ) {|f|
            f.write m.pop
        }
        m.delete
        i += 1
      end
      puts "#{pop.mails.size} mails popped."
    end
    pop.finish                                           ###

(1) call Net::POP3#start and start POP session
(2) access mails by using POP3#each_mail and/or POP3#mails
(3) close POP session by calling POP3#finish or use block form #start.

This example is using block form #start to close the session.
=== Enshort Code

The example above is very verbose. You can enshort code by using
some utility methods. At first, block form of Net::POP3.start can
alternates POP3.new, POP3#start and POP3#finish.

    require 'net/pop'

    Net::POP3.start( 'pop3.server.address', 110 )
                     'YourAccount', 'YourPassword' )
	if pop.mails.empty? then
	  puts 'no mail.'
	else
	  i = 0
	  pop.each_mail do |m|   # or "pop.mails.each ..."
	    File.open( 'inbox/' + i.to_s, 'w' ) {|f|
                f.write m.pop
	    }
	    m.delete
	    i += 1
	  end
          puts "#{pop.mails.size} mails popped."
	end
    }

POP3#delete_all alternates #each_mail and m.delete.

    require 'net/pop'

    Net::POP3.start( 'pop3.server.address', 110,
                     'YourAccount', 'YourPassword' ) {|pop|
	if pop.mails.empty? then
	  puts 'no mail.'
	else
	  i = 0
	  pop.delete_all do |m|
	    File.open( 'inbox/' + i.to_s, 'w' ) {|f|
		f.write m.pop
	    }
	    i += 1
	  end
	end
    }

And here is more shorter example.

    require 'net/pop'

    i = 0
    Net::POP3.delete_all( 'pop3.server.address', 110,
                          'YourAccount', 'YourPassword' ) do |m|
      File.open( 'inbox/' + i.to_s, 'w' ) {|f|
          f.write m.pop
      }
      i += 1
    end

=== Writing to File directly

All examples above get mail as one big string.
This example does not create such one.

    require 'net/pop'
    Net::POP3.delete_all( 'pop3.server.address', 110,
                          'YourAccount', 'YourPassword' ) do |m|
      File.open( 'inbox', 'w' ) {|f|
          m.pop f   ####
      }
    end

=== Using APOP

The net/pop library supports APOP authentication.
To use APOP, use Net::APOP class instead of Net::POP3 class.
You can use utility method, Net::POP3.APOP(). Example:

    require 'net/pop'

    # use APOP authentication if $isapop == true
    pop = Net::POP3.APOP($isapop).new( 'apop.server.address', 110 )
    pop.start( YourAccount', 'YourPassword' ) {|pop|
        # Rest code is same.
    }


== Net::POP3 class

=== Class Methods

: new( address, port = 110, apop = false )
    creates a new Net::POP3 object.
    This method does not open TCP connection yet.

: start( address, port = 110, account, password )
: start( address, port = 110, account, password ) {|pop| .... }
    equals to Net::POP3.new( address, port ).start( account, password )

        Net::POP3.start( addr, port, account, password ) {|pop|
	    pop.each_mail do |m|
	      file.write m.pop
	      m.delete
	    end
        }

: APOP( is_apop )
    returns Net::APOP class object if IS_APOP is true.
    returns Net::POP3 class object if false.
    Use this method like:

        # example 1
        pop = Net::POP3::APOP($isapop).new( addr, port )

        # example 2
        Net::POP3::APOP($isapop).start( addr, port ) {|pop|
            ....
        }

: foreach( address, port = 110, account, password ) {|mail| .... }
    starts POP3 protocol and iterates for each POPMail object.
    This method equals to

        Net::POP3.start( address, port, account, password ) {|pop|
            pop.each_mail do |m|
	      yield m
	    end
        }

        # example
        Net::POP3.foreach( 'your.pop.server', 110,
                           'YourAccount', 'YourPassword' ) do |m|
          file.write m.pop
          m.delete if $DELETE
        end

: delete_all( address, port = 110, account, password )
: delete_all( address, port = 110, account, password ) {|mail| .... }
    starts POP3 session and delete all mails.
    If block is given, iterates for each POPMail object before delete.

        # example
        Net::POP3.delete_all( addr, nil, 'YourAccount', 'YourPassword' ) do |m|
          m.pop file
        end

: auth_only( address, port = 110, account, password )
    (just for POP-before-SMTP)
    opens POP3 session and does autholize and quit.
    This method must not be called while POP3 session is opened.

        # example
        Net::POP3.auth_only( 'your.pop3.server',
                             nil,     # using default (110)
                             'YourAccount',
                             'YourPassword' )

=== Instance Methods

: start( account, password )
: start( account, password ) {|pop| .... }
    starts POP3 session.

    When called with block, gives a POP3 object to block and
    closes the session after block call finish.

: active?
    true if POP3 session is started.

: address
    the address to connect

: port
    the port number to connect

: open_timeout
: open_timeout=(n)
    seconds to wait until connection is opened.
    If POP3 object cannot open a conection in this seconds,
    it raises TimeoutError exception.

: read_timeout
: read_timeout=(n)
    seconds to wait until reading one block (by one read(1) call).
    If POP3 object cannot open a conection in this seconds,
    it raises TimeoutError exception.

: finish
    finishes POP3 session.
    If POP3 session had not be started, raises an IOError.

: mails
    an array of Net::POPMail objects.
    This array is renewed when session started.

: each_mail {|popmail| .... }
: each {|popmail| .... }
    is equals to "pop3.mails.each"

: delete_all
: delete_all {|popmail| .... }
    deletes all mails on server.
    If called with block, gives mails to the block before deleting.

        # example
        n = 1
        pop.delete_all do |m|
          File.open("inbox/#{n}") {|f| f.write m.pop }
          n += 1
        end

: auth_only( account, password )
    (just for POP-before-SMTP)
    opens POP3 session and does autholize and quit.
    This method must not be called while POP3 session is opened.
        # example
        pop = Net::POP3.new( 'your.pop3.server' )
        pop.auth_only 'YourAccount', 'YourPassword'

: reset
    reset the session. All "deleted mark" are removed.

== Net::APOP

This class defines no new methods.
Only difference from POP3 is using APOP authentification.

=== Super Class
Net::POP3

== Net::POPMail

A class of mail which exists on POP server.

=== Instance Methods

: pop( dest = '' )
    This method fetches a mail and write to 'dest' using '<<' method.

        # example
        allmails = nil
        POP3.start( 'your.pop3.server', 110,
                    'YourAccount, 'YourPassword' ) {|pop|
            allmails = pop.mails.collect {|popmail| popmail.pop }
        }

: pop {|str| .... }
    gives the block part strings of a mail.

        # example
        POP3.start( 'localhost', 110 ) {|pop3|
	    pop3.each_mail do |m|
	      m.pop do |str|
		# do anything
	      end
	    end
        }

: header
    This method fetches only mail header.

: top( lines )
    This method fetches mail header and LINES lines of body.

: delete
    deletes mail on server.

: size
    mail size (bytes)

: deleted?
    true if mail was deleted

=end

require 'net/protocol'
require 'digest/md5'


module Net

  class POP3 < Protocol

    protocol_param :default_port,      '110'
    protocol_param :command_type,      '::Net::POP3Command'
    protocol_param :apop_command_type, '::Net::APOPCommand'
    protocol_param :mail_type,         '::Net::POPMail'
    protocol_param :socket_type,       '::Net::InternetMessageIO'


    def POP3.APOP( bool )
      bool ? APOP : POP3
    end

    def POP3.foreach( address, port = nil,
                 account = nil, password = nil, &block )
      start( address, port, account, password ) {|pop|
          pop.each_mail( &block )
      }
    end

    def POP3.delete_all( address, port = nil,
                    account = nil, password = nil, &block )
      start( address, port, account, password ) {|pop|
          pop.delete_all( &block )
      }
    end

    def POP3.auth_only( address, port = nil,
                   account = nil, password = nil )
      new( address, port ).auth_only account, password
    end


    def auth_only( account, password )
      raise IOError, 'opening already opened POP session' if active?
      start( account, password ) {
          # none
      }
    end


    #
    # connection
    #

    def initialize( addr, port = nil, apop = false )
      super addr, port
      @@mails = nil
      @@apop = false
    end

    private

    def do_start( account, password )
      conn_socket
      @@command = (@@apop ? self.class.apop_command_type : self.class.command_type).new(socket())
      @@command.auth account, password
    end

    def do_finish
      @@mails = nil
      disconn_command
      disconn_socket
    end


    #
    # POP operations
    #

    public

    def mails
      return @@mails if @@mails

      mails = []
      mtype = self.class.mail_type
      command().list.each_with_index do |size,idx|
        mails.push mtype.new(idx, size, command()) if size
      end
      @@mails = mails.freeze
    end

    def each_mail( &block )
      mails().each( &block )
    end

    alias each each_mail

    def delete_all
      mails().each do |m|
        yield m if block_given?
        m.delete unless m.deleted?
      end
    end

    def reset
      command().rset
      mails().each do |m|
        m.instance_eval { @@deleted = false }
      end
    end


    def command
      io_check
      super
    end

    def io_check
      (not socket() or socket().closed?) and
              raise IOError, 'POP session is not opened yet'
    end

  end

  POP         = POP3
  POPSession  = POP3
  POP3Session = POP3


  class APOP < POP3
    def APOP.command_type
      APOPCommand
    end
  end

  APOPSession = APOP


  class POPMail

    def initialize( n, s, cmd )
      @@num     = n
      @@size    = s
      @@command = cmd

      @@deleted = false
    end

    attr :size

    def inspect
      "#<#{self.class} #{@@num}#{@@deleted ? ' deleted' : ''}>"
    end

    def pop( dest = '', &block )
      if block then
        dest = ReadAdapter.new(block)
      end
      @@command.retr @@num, dest
    end

    alias all pop
    alias mail pop

    def top( lines, dest = '' )
      @@command.top @@num, lines, dest
    end

    def header( dest = '' )
      top 0, dest
    end

    def delete
      @@command.dele @@num
      @@deleted = true
    end

    alias delete! delete

    def deleted?
      @@deleted
    end

    def uidl
      @@command.uidl @@num
    end

  end


  class POP3Command < Command

    def initialize( sock )
      super
      atomic {
          check_reply SuccessCode
      }
    end

    def auth( account, pass )
      atomic {
          @@socket.writeline 'USER ' + account
          check_reply_auth

          @@socket.writeline 'PASS ' + pass
          check_reply_auth
      }
    end

    def list
      arr = []
      atomic {
          getok 'LIST'
          @@socket.each_list_item do |line|
            m = /\A(\d+)[ \t]+(\d+)/.match(line) or
                    raise BadResponse, "illegal response: #{line}"
            arr[ m[1].to_i ] = m[2].to_i
          end
      }
      arr
    end

    def rset
      atomic {
          getok 'RSET'
      }
    end


    def top( num, lines = 0, dest = '' )
      atomic {
          getok sprintf('TOP %d %d', num, lines)
          @@socket.read_message_to dest
      }
    end

    def retr( num, dest = '' )
      atomic {
          getok sprintf('RETR %d', num)
          @@socket.read_message_to dest
      }
    end
    
    def dele( num )
      atomic {
          getok sprintf('DELE %d', num)
      }
    end

    def uidl( num )
      atomic {
          getok( sprintf('UIDL %d', num) ).message.split(' ')[1]
      }
    end

    def quit
      atomic {
          getok 'QUIT'
      }
    end

    private

    def check_reply_auth
      begin
        return check_reply(SuccessCode)
      rescue ProtocolError => err
        raise ProtoAuthError.new('Fail to POP authentication', err.response)
      end
    end

    def get_reply
      str = @@socket.readline

      if /\A\+/ === str then
        Response.new( SuccessCode, str[0,3], str[3, str.size - 3].strip )
      else
        Response.new( ErrorCode, str[0,4], str[4, str.size - 4].strip )
      end
    end

  end


  class APOPCommand < POP3Command

    def initialize( sock )
      response = super(sock)
      m = /<.+>/.match(response.msg) or
              raise ProtoAuthError.new("not APOP server: cannot login", nil)
      @@stamp = m[0]
    end

    def auth( account, pass )
      atomic {
          @@socket.writeline sprintf('APOP %s %s',
                                    account,
                                    Digest::MD5.hexdigest(@@stamp + pass))
          check_reply_auth
      }
    end

  end

end   # module Net
@


1.47
log
@* lib/net/http.rb: HTTP.get accepts URI.
* lib/net/http.rb: add some HTTP 1.1 response codes.
@
text
@d16 1
a16 1
$Id: header.rd,v 1.3 2002/02/19 12:23:15 aamine Exp $
d390 1
a390 1
      @@command = (@@apop ? type.apop_command_type : type.command_type).new(socket())
d411 1
a411 1
      mtype = type.mail_type
d478 1
a478 1
      "#<#{type} #{@@num}#{@@deleted ? ' deleted' : ''}>"
@


1.46
log
@* lib/net/protocol.rb: set read_timeout dynamically.
* lib/net/http.rb: @@@@newimpl is always true in the main trunk.
* lib/net/http.rb: HTTP.port -> default_port
* lib/net/http.rb: HTTPResponse.read_response_status -> read_status_line
@
text
@@


1.45
log
@aamine
* lib/net/protocol.rb: rename Protocol.port to default_port.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
* lib/net/protocol.rb: rename BufferedSocket class to InternetMessageIO.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#write_pendstr to write_message.
* lib/net/smtp.rb: ditto.
* lib/net/protocol.rb: new method InternetMessageIO#through_message.
* lib/net/smtp.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#read_pendstr to read_message_to.
* lib/net/pop.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#read_pendlist to each_list_item
* lib/net/pop.rb: ditto.
* lib/net/protocol.rb: Now block size is 1024.
* lib/net/smtp.rb: new methods SMTP#esmtp? and #esmtp=.
* lib/net/http.rb: Using singleton method syntax instead of singleton class clause, to avoid behavior change of class variables in ruby 1.7.
* lib/net/http.rb: HTTPResponse class does not inherit from Net::Response.
* lib/net/http.rb: devide HTTP#connecting into {begin,end}_transport.
* lib/net/http.rb: unused class Accumulator removed.
* lib/net/http.rb: Net::HTTP reads response. not HTTPRequest.
* lib/net/http.rb: proxy related class-instance-variables are not initialized correctly.
@
text
@@


1.44
log
@aamine
* lib/net/http.rb: HTTP.Proxy should use self for proxy-class's super class.
* lib/net/http.rb: initialize HTTP.proxy_port by HTTP.port.
@
text
@d5 1
a5 1
Copyright (c) 1999-2001 Yukihiro Matsumoto
d16 1
a16 1
$Id: header.rd,v 1.2 2001/12/10 12:37:16 aamine Exp $
d337 1
a337 1
    protocol_param :port,              '110'
d341 1
a342 1
    class << self
d344 3
a346 3
      def APOP( bool )
        bool ? APOP : POP3
      end
d348 3
a350 3
      def foreach( address, port = nil,
                   account = nil, password = nil, &block )
        start( address, port, account, password ) do |pop|
d352 2
a353 2
        end
      end
d355 3
a357 3
      def delete_all( address, port = nil,
                      account = nil, password = nil, &block )
        start( address, port, account, password ) do |pop|
d359 2
a360 7
        end
      end

      def auth_only( address, port = nil,
                     account = nil, password = nil )
        new( address, port ).auth_only account, password
      end
d362 3
d369 1
a369 1
      active? and raise IOError, 'opening already opened POP session'
d371 1
a371 1
          ;
d451 3
a453 1
  POP = POP3
d457 3
a459 1
    protocol_param :command_type, '::Net::APOPCommand'
d462 2
d483 1
a483 1
        dest = ReadAdapter.new( block )
d485 1
a485 1
      @@command.retr( @@num, dest )
d492 1
a492 1
      @@command.top( @@num, lines, dest )
d540 1
a540 1
          @@socket.read_pendlist do |line|
d558 2
a559 2
          getok sprintf( 'TOP %d %d', num, lines )
          @@socket.read_pendstr dest
d563 1
a563 1
    def retr( num, dest = '', &block )
d566 1
a566 1
          @@socket.read_pendstr dest, &block
d578 1
a578 1
          getok( sprintf('UIDL %d', num) ).msg.split(' ')[1]
a629 7


  # for backward compatibility

  POPSession  = POP3
  POP3Session = POP3
  APOPSession = APOP
@


1.43
log
@aamine
* lib/net/protocol.rb: Protocol#start returns the return value of block.
* lib/net/protocol.rb: set timeout limit by default.
* lib/net/protocol.rb: new methods WriteAdapter#write, puts, print, printf.
* lib/net/http.rb: rename HTTP#get2 to request_get, post2 to request_post ...
* lib/net/smtp.rb: should not resolve HELO domain automatically.
@
text
@@


1.42
log
@aamine
* lib/net/protocol.rb: rename Net::Socket to Net::BufferedSocket
@
text
@d370 12
d388 28
a415 9
    def auth_only( account, password )
      begin
        connect
        @@active = true
        @@command.auth address(), port()
        @@command.quit
      ensure
        @@active = false
        disconnect
d417 1
a419 2
    attr :mails

d421 1
a421 2
      io_check
      @@mails.each( &block )
d427 1
a427 2
      io_check
      @@mails.each do |m|
d434 2
a435 3
      io_check
      @@command.rset
      @@mails.each do |m|
d441 3
a443 16
    private

    def conn_command( sock )
      @@command =
          (@@apop ? type.apop_command_type : type.command_type).new(sock)
    end

    def do_start( account, password )
      @@command.auth account, password

      mails = []
      mtype = type.mail_type
      @@command.list.each_with_index do |size,idx|
        mails.push mtype.new(idx, size, @@command) if size
      end
      @@mails = mails.freeze
d447 2
a448 2
      (not @@socket or @@socket.closed?) and
              raise IOError, 'pop session is not opened yet'
d453 1
a453 3
  POP         = POP3
  POPSession  = POP3
  POP3Session = POP3
a459 2
  APOPSession = APOP

a512 1

d517 2
a518 2
      critical {
        check_reply SuccessCode
d523 3
a525 3
      critical {
        @@socket.writeline 'USER ' + account
        check_reply_auth
d527 2
a528 2
        @@socket.writeline 'PASS ' + pass
        check_reply_auth
d534 7
a540 7
      critical {
        getok 'LIST'
        @@socket.read_pendlist do |line|
          m = /\A(\d+)[ \t]+(\d+)/.match(line) or
                  raise BadResponse, "illegal response: #{line}"
          arr[ m[1].to_i ] = m[2].to_i
        end
d546 2
a547 2
      critical {
        getok 'RSET'
d553 3
a555 3
      critical {
        getok sprintf( 'TOP %d %d', num, lines )
        @@socket.read_pendstr dest
d560 3
a562 3
      critical {
        getok sprintf('RETR %d', num)
        @@socket.read_pendstr dest, &block
d567 2
a568 2
      critical {
        getok sprintf('DELE %d', num)
d573 2
a574 2
      critical {
        getok( sprintf('UIDL %d', num) ).msg.split(' ')[1]
d579 2
a580 2
      critical {
        getok 'QUIT'
a583 1

d588 1
a588 1
        return check_reply( SuccessCode )
d590 1
a590 1
        raise ProtoAuthError.new( 'Fail to POP authentication', err.response )
d610 3
a612 4
      rep = super( sock )

      m = /<.+>/.match( rep.msg ) or
              raise ProtoAuthError.new( "not APOP server: cannot login", nil )
d617 5
a621 5
      critical {
        @@socket.writeline sprintf( 'APOP %s %s',
                                   account,
                                   Digest::MD5.hexdigest(@@stamp + pass) )
        check_reply_auth
d626 7
@


1.41
log
@aamine
* lib/net/pop.rb: new method Net::POP3.APOP
* lib/net/http.rb: set default Content-Type to x-www-form-urlencoded (causes warning)
* lib/net/protocol.rb: remove Net::NetPrivate module.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@@


1.40
log
@aamine
* lib/net/protocol.rb: calls on_connect before conn_command
@
text
@d3 1
a3 1
= net/pop.rb version 1.2.3
d16 2
d128 3
a130 3
net/pop also supports APOP authentication. There's two way to use APOP:
(1) using APOP class instead of POP3
(2) passing true for fifth argument of POP3.start
a131 1
    # (1)
d133 4
a136 2
    Net::APOP.start( 'apop.server.address', 110,
                     'YourAccount', 'YourPassword' ) {|pop|
a139 8
    # (2)
    require 'net/pop'
    Net::POP3.start( 'apop.server.address', 110,
                     'YourAccount', 'YourPassword',
                     true   ####
    ) {|pop|
        # Rest code is same.
    }
d160 13
d337 4
a340 3
    protocol_param :port,         '110'
    protocol_param :command_type, '::Net::NetPrivate::POP3Command'
    protocol_param :apop_command_type, '::Net::NetPrivate::APOPCommand'
d342 1
a342 1
    protocol_param :mail_type,    '::Net::POPMail'
d344 3
a346 1
    class << self
d380 1
a380 1
        @@command.auth address, port
d445 1
a445 1
    protocol_param :command_type, 'Net::NetPrivate::APOPCommand'
d469 1
a469 1
        dest = NetPrivate::ReadAdapter.new( block )
a503 3
  module NetPrivate


a618 3


  end   # module Net::NetPrivate
@


1.39
log
@aamine
* lib/net/smtp.rb: SMTP.new requires at least one arg.
* lib/net/pop.rb: POP.new requires at least one arg.
* lib/net/pop.rb: uses "raise *Error.new" instead of simple raise.
* lib/net/http.rb: HTTP.new requires at least one arg.
* lib/net/http.rb: changes implicit start algolithm.
@
text
@d32 8
a39 8
    Net::POP3.start( 'pop3.server.address', 110,
                     'YourAccount', 'YourPassword' ) {|pop|
      if pop.mails.empty? then
        puts 'no mail.'
      else
        i = 0
        pop.each_mail do |m|   # or "pop.mails.each ..."
          File.open( 'inbox/' + i.to_s, 'w' ) {|f|
d41 3
a43 4
          }
          m.delete
          i += 1
        end
d46 31
d79 1
a79 1
=== Shorter Version
d82 1
d85 11
a95 11
      if pop.mails.empty? then
        puts 'no mail.'
      else
        i = 0
        pop.delete_all do |m|
          File.open( 'inbox/' + i.to_s, 'w' ) {|f|
            f.write m.pop
          }
          i += 1
        end
      end
d101 1
d106 1
a106 1
        f.write m.pop
d120 1
a120 1
        m.pop f   ####
d134 1
a134 1
      # Rest code is same.
d143 1
a143 1
      # Rest code is same.
d158 6
a163 6
        Net::POP3.start( addr, port, account, password ) do |pop|
          pop.each_mail do |m|
            file.write m.pop
            m.delete
          end
        end
d170 3
a172 3
          pop.each_mail do |m|
            yield m
          end
d198 4
a201 4
        pop = Net::POP3.auth_only( 'your.pop3.server',
                                    nil,     # using default (110)
                                   'YourAccount',
                                   'YourPassword' )
d288 3
a290 3
                    'YourAccount, 'YourPassword' ) do |pop|
          allmails = pop.mails.collect {|popmail| popmail.pop }
        end
d297 5
a301 5
          pop3.each_mail do |m|
            m.pop do |str|
              # do anything
            end
          end
@


1.38
log
@Reflect the update of the MD5 module which is now Digest::MD5.
@
text
@d13 2
a14 3
NOTE: You can get Japanese version of this document from
Ruby Documentation Project (RDP):
((<URL:http://www.ruby-lang.org/~rubikitch/RDP.cgi>))
d424 3
a426 3
    def all( dest = '' )
      if block_given? then
        dest = NetPrivate::ReadAdapter.new( Proc.new )
d430 3
a432 2
    alias pop all
    alias mail all
d443 1
a443 1
      @@command.dele( @@num )
d473 1
a473 1
    def auth( acnt, pass )
d475 1
a475 1
        @@socket.writeline 'USER ' + acnt
d540 3
a542 3
        cod = check_reply( SuccessCode )
      rescue ProtocolError
        raise ProtoAuthError, 'Fail to POP authentication'
a543 2

      return cod
d550 1
a550 1
        return Response.new( SuccessCode, str[0,3], str[3, str.size - 3].strip )
d552 1
a552 1
        return Response.new( ErrorCode, str[0,4], str[4, str.size - 4].strip )
d565 1
a565 1
              raise ProtoAuthError, "not APOP server: cannot login"
@


1.37
log
@aamine
* lib/net/protocol.rb: Protocol.new requires at least one arg.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@d291 1
a291 1
require 'md5'
d575 1
a575 1
                                   MD5.new(@@stamp + pass).hexdigest )
@


1.36
log
@aamine
* lib/net/http.rb: rename HTTP#request_by_name to send_request.
* lib/net/protocol.rb (ProtoSocket#read): modify typo.
@
text
@d119 1
a119 1
: new( address = 'localhost', port = 110, apop = false )
d123 2
a124 2
: start( address = 'localhost', port = 110, account, password )
: start( address = 'localhost', port = 110, account, password ) {|pop| .... }
d134 1
a134 1
: foreach( address = 'localhost', port = 110, account, password ) {|mail| .... }
d151 2
a152 2
: delete_all( address = 'localhost', port = 110, account, password )
: delete_all( address = 'localhost', port = 110, account, password ) {|mail| .... }
d161 1
a161 1
: auth_only( address = 'localhost', port = 110, account, password )
d306 1
a306 1
      def foreach( address = nil, port = nil,
d313 1
a313 1
      def delete_all( address = nil, port = nil,
d320 1
a320 1
      def auth_only( address = nil, port = nil,
d328 1
a328 1
    def initialize( addr = nil, port = nil, apop = false )
d334 1
a334 1
    def auth_only( account = nil, password = nil )
@


1.35
log
@aamine
* lib/net/http.rb (HTTP#request_by_name): bug fix.
* lib/net/http.rb: does not write Connection: by default.
* lib/net/protocol.rb: "start" for started protocol is an error.
* lib/net/protocol.rb: "finish" for finished protocol is an error.
@
text
@d3 1
a3 1
= net/pop.rb version 1.2.2
@


1.34
log
@aamine
* lib/net/http.rb: new method HTTP#request_by_name (test)
* lib/net/http.rb: new class HTTPGenericRequest
@
text
@d204 1
a204 1
    If POP3 session had not be started, does nothing and return false.
@


1.33
log
@* protocol.rb,smtp.rb,pop.rb,http.rb: modify document.
@
text
@d3 1
a3 1
= net/pop.rb version 1.2.1
@


1.32
log
@aamine
* lib/net/pop.rb: new methods POP3.auth_only, POP3#auth_only
* lib/net/http.rb: HTTP.Proxy returns self if ADDRESS is nil.
* lib/net/protocol.rb: new method ProtocolError#response
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: add document.
@
text
@d31 1
d33 16
a48 1
  require 'net/pop'
d50 14
a63 9
  Net::POP3.start( 'pop3.server.address', 110,
                   'YourAccount', 'YourPassword' ) {|pop|
    if pop.mails.empty? then
      puts 'no mail.'
    else
      i = 0
      pop.each_mail do |m|   # or "pop.mails.each ..."
        File.open( 'inbox/' + i.to_s, 'w' ) do |f|
          f.write m.pop
a64 2
        m.delete
        i += 1
d66 1
a66 3
    end
    puts "#{pop.mails.size} mails popped."
  }
d68 1
a68 1
=== Shorter Version
d70 4
a73 5
  require 'net/pop'
  i = 0
  Net::POP3.start( 'pop3.server.address', 110,
                   'YourAccount', 'YourPassword' ) {|pop|
    pop.delete_all do |m|
a78 13
  }

And this is more shorter example.

  require 'net/pop'
  i = 0
  Net::POP3.delete_all( 'pop3.server.address', 110,
                        'YourAccount', 'YourPassword' ) do |m|
    File.open( 'inbox/' + i.to_s, 'w' ) {|f|
      f.write m.pop
    }
    i += 1
  end
d85 7
a91 7
  require 'net/pop'
  Net::POP3.delete_all( 'pop3.server.address', 110,
                        'YourAccount', 'YourPassword' ) do |m|
    File.open( 'inbox', 'w' ) {|f|
      m.pop f   ####
    }
  end
d99 15
a113 15
  # (1)
  require 'net/pop'
  Net::APOP.start( 'apop.server.address', 110,
                   'YourAccount', 'YourPassword' ) {|pop|
    # Rest code is same.
  }

  # (2)
  require 'net/pop'
  Net::POP3.start( 'apop.server.address', 110,
                   'YourAccount', 'YourPassword',
                   true   ####
  ) {|pop|
    # Rest code is same.
  }
d120 2
a121 2
  creates a new Net::POP3 object.
  This method does not open TCP connection yet.
d125 1
a125 1
  equals to Net::POP3.new( address, port ).start( account, password )
d127 6
a132 6
    Net::POP3.start( addr, port, account, password ) do |pop|
      pop.each_mail do |m|
        file.write m.pop
        m.delete
      end
    end
d135 2
a136 2
  starts protocol and iterate for each POPMail object.
  This method equals to
d138 5
a142 5
    Net::POP3.start( address, port, account, password ) do |pop|
      pop.each do |m|
        yield m
      end
    end
d144 6
a149 6
  Typical usage:

    Net::POP3.foreach( addr, nil, acnt, pass ) do |m|
      m.pop file
      m.delete
    end
d235 1
a235 1
  reset the session. All "deleted mark" are removed.
@


1.31
log
@aamine
* lib/net/http.rb: always close connection on request without body.
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: change copyright.
@
text
@d3 1
a3 1
= net/pop.rb version 1.2.0
d5 1
a5 1
  Copyright (C) 1999-2001 Yukihiro Matsumoto
d7 1
a7 1
  written & maintained by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d9 3
a11 3
  This program is free software. You can re-distribute and/or
  modify this program under the same terms as Ruby itself,
  GNU General Public License or Ruby License.
d13 3
a15 3
  Japanese version of this document is in "net" full package.
  You can get it from RAA (Ruby Application Archive). RAA is:
  http://www.ruby-lang.org/en/raa.html
d17 1
d19 3
a21 1
== Net::POP3
d23 88
a110 1
=== Super Class
d112 1
a112 1
Net::Protocol
d124 1
a124 2
    # typical usage
    Net::POP3.start( addr, port, acnt, pass ) do |pop|
d126 1
a126 1
        any_file.write m.pop
d141 1
a141 1
  .
a142 1
    # typical usage
d150 18
a167 2
  starts POP3 session and delete all mails.
  If block is given, iterates for each POPMail object before delete.
a168 5
    # typical usage
    Net::POP3.delete_all( addr, nil, acnt, pass ) do |m|
      m.pop file
    end
  
d173 4
a176 1
  starts POP3 session.
d178 24
a201 2
  When called with block, gives a POP3 object to block and
  closes the session after block call finish.
d204 2
a205 2
  an array of ((URL:#POPMail)).
  This array is renewed when session started.
d209 1
a209 1
  is equals to "pop3.mails.each"
d213 2
a214 2
  deletes all mails.
  If called with block, gives mails to the block before deleting.
d216 6
a221 7
    # example 1
    # pop and delete all mails
    n = 1
    pop.delete_all do |m|
      File.open("inbox/#{n}") {|f| f.write m.pop }
      n += 1
    end
d223 7
a229 5
    # example 2
    # clear all mails on server
    Net::POP3.start( addr, port, acc, pass ) do |pop|
      pop.delete_all
    end
a233 1

a239 1

a241 1

d246 1
a246 6
=== Super Class

Object


=== Methods
d249 1
a249 1
  This method fetches a mail and write to 'dest' using '<<' method.
d251 6
a256 13
    # usage example

    mailarr = []
    POP3.start( 'localhost', 110 ) do |pop|
      pop.each_mail do |popm|
        mailarr.push popm.pop   # all() returns 'dest' (this time, string)
        # or, you can also
        # popm.pop( $stdout )   # write mail to stdout

        # maybe you also want to delete mail after popping
        popm.delete
      end
    end
d259 1
a259 1
  If pop() is called with block, it gives the block part strings of a mail.
d261 8
a268 9
    # usage example

    POP3.start( 'localhost', 110 ) do |pop3|
      pop3.each_mail do |m|
        m.pop do |str|
          # do anything
        end
      end
    end
d271 1
a271 1
  This method fetches only mail header.
d274 1
a274 1
  This method fetches mail header and 'lines' lines body.
d277 1
a277 2
: delete!
  This method deletes mail.
d280 1
a280 1
  size of mail(bytes)
d283 1
a283 1
  true if mail was deleted
d316 6
a321 1
    
d331 12
d353 1
d376 2
a377 2
    def do_start( acnt, pwd )
      @@command.auth( acnt, pwd )
d379 1
a379 1
      @@mails = []
d382 1
a382 3
        if size then
          @@mails.push mtype.new( idx, size, @@command )
        end
d384 1
a384 1
      @@mails.freeze
d388 2
a389 3
      if not @@socket or @@socket.closed? then
        raise IOError, 'pop session is not opened yet'
      end
d485 3
a487 2
          num, siz = line.split( / +/o )
          arr[ num.to_i ] = siz.to_i
d503 1
a503 1
        @@socket.read_pendstr( dest )
d509 2
a510 2
        getok sprintf( 'RETR %d', num )
        @@socket.read_pendstr( dest, &block )
d516 1
a516 1
        getok sprintf( 'DELE %d', num )
d522 1
a522 1
        getok( sprintf 'UIDL %d', num ).msg.split(' ')[1]
d563 2
a564 4
      m = /<.+>/.match( rep.msg )
      unless m then
        raise ProtoAuthError, "This is not APOP server: can't login"
      end
d571 2
a572 1
                            account, MD5.new(@@stamp + pass).hexdigest )
@


1.30
log
@aamine
* lib/net/http.rb: call on_connect() on re-opening socket.
* lib/net/pop.rb: also POP3 can use APOP auth.
@
text
@d5 1
a5 1
written by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d7 1
a7 3
This program is free software.
You can distribute/modify this program under
the terms of the Ruby Distribute License.
d9 7
a15 3
Japanese version of this document is in "net" full package.
You can get it from RAA
(Ruby Application Archive: http://www.ruby-lang.org/en/raa.html).
@


1.29
log
@aamine
* lib/net/http.rb: add HTTP#request.
* lib/net/http.rb: take HTTP 1.0 server into account (incomplete).
* lib/net/protocol.rb: timeout for open/read.
* lib/net/protocol.rb: add Protocol#on_connect,on_disconnect.
@
text
@d24 1
a24 1
: new( address = 'localhost', port = 110 )
d187 1
d210 2
a211 2
    def initialize( addr = nil, port = nil )
      super
d213 1
d242 5
@


1.28
log
@aamine
* lib/net/protocol.rb (adding): too few "yield" in case of arg is not String/File.
* lib/net/http.rb: add http request object.
@
text
@d68 1
a68 1
=== Methods
@


1.27
log
@aamine
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: wrongly version 1.2 sources
  were checked in.
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.32
@


1.27.2.1
log
@aamine
* lib/net/http.rb: supports HTTP 1.0 server.
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.33
@


1.27.2.2
log
@aamine
* lib/net/protocol.rb: use net 1.2 for also ruby 1.6 branch.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.34
a186 1
    protocol_param :apop_command_type, '::Net::NetPrivate::APOPCommand'
d209 2
a210 2
    def initialize( addr = nil, port = nil, apop = false )
      super addr, port
a211 1
      @@apop = false
a239 5

    def conn_command( sock )
      @@command =
          (@@apop ? type.apop_command_type : type.command_type).new(sock)
    end
@


1.27.2.3
log
@aamine
* lib/net/pop.rb: new methods POP3.auth_only, POP3#auth_only
* lib/net/http.rb: HTTP.Proxy returns self if ADDRESS is nil.
* lib/net/protocol.rb: new method ProtocolError#response
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: add document.
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.35
d5 1
a5 1
Copyright (c) 1999-2001 Yukihiro Matsumoto
d7 3
a9 1
written & maintained by Minero Aoki <aamine@@loveruby.net>
d11 3
a13 3
This program is free software. You can re-distribute and/or
modify this program under the same terms as Ruby itself,
Ruby Distribute License or GNU General Public License.
a14 3
NOTE: You can get Japanese version of this document from
Ruby Documentation Project (RDP):
((<URL:http://www.ruby-lang.org/~rubikitch/RDP.cgi>))
d16 1
a16 1
== What is This Module?
d18 1
a18 45
This module provides your program the functions to retrieve
mails via POP3, Post Office Protocol version 3. For details
of POP3, refer [RFC1939] ((<URL:http://www.ietf.org/rfc/rfc1939.txt>)).

== Examples

=== Retrieving Mails

This example retrieves mails from server and delete it (on server).
Mails are written in file named 'inbox/1', 'inbox/2', ....
Replace 'pop3.server.address' your POP3 server address.


  require 'net/pop'

  Net::POP3.start( 'pop3.server.address', 110,
                   'YourAccount', 'YourPassword' ) {|pop|
    if pop.mails.empty? then
      puts 'no mail.'
    else
      i = 0
      pop.each_mail do |m|   # or "pop.mails.each ..."
        File.open( 'inbox/' + i.to_s, 'w' ) do |f|
          f.write m.pop
        end
        m.delete
        i += 1
      end
    end
    puts "#{pop.mails.size} mails popped."
  }

=== Shorter Version

  require 'net/pop'
  i = 0
  Net::POP3.start( 'pop3.server.address', 110,
                   'YourAccount', 'YourPassword' ) {|pop|
    pop.delete_all do |m|
      File.open( 'inbox/' + i.to_s, 'w' ) {|f|
        f.write m.pop
      }
      i += 1
    end
  }
d20 1
a20 48
And this is more shorter example.

  require 'net/pop'
  i = 0
  Net::POP3.delete_all( 'pop3.server.address', 110,
                        'YourAccount', 'YourPassword' ) do |m|
    File.open( 'inbox/' + i.to_s, 'w' ) {|f|
      f.write m.pop
    }
    i += 1
  end

=== Writing to File directly

All examples above get mail as one big string.
This example does not create such one.

  require 'net/pop'
  Net::POP3.delete_all( 'pop3.server.address', 110,
                        'YourAccount', 'YourPassword' ) do |m|
    File.open( 'inbox', 'w' ) {|f|
      m.pop f   ####
    }
  end

=== Using APOP

net/pop also supports APOP authentication. There's two way to use APOP:
(1) using APOP class instead of POP3
(2) passing true for fifth argument of POP3.start

  # (1)
  require 'net/pop'
  Net::APOP.start( 'apop.server.address', 110,
                   'YourAccount', 'YourPassword' ) {|pop|
    # Rest code is same.
  }

  # (2)
  require 'net/pop'
  Net::POP3.start( 'apop.server.address', 110,
                   'YourAccount', 'YourPassword',
                   true   ####
  ) {|pop|
    # Rest code is same.
  }

== Net::POP3 class
d24 1
a24 1
: new( address = 'localhost', port = 110, apop = false )
d32 2
a33 1
    Net::POP3.start( addr, port, account, password ) do |pop|
d35 1
a35 1
        file.write m.pop
d50 1
a50 1
  Typical usage:
d52 1
d60 2
a61 2
    starts POP3 session and delete all mails.
    If block is given, iterates for each POPMail object before delete.
d63 6
a68 17
        # example
        Net::POP3.delete_all( addr, nil, 'YourAccount', 'YourPassword' ) do |m|
          m.pop file
        end

: auth_only( address = 'localhost', port = 110, account, password )
    (just for POP-before-SMTP)
    opens POP3 session and does autholize and quit.
    This method must not be called while POP3 session is opened.

        # example
        pop = Net::POP3.auth_only( 'your.pop3.server',
                                    nil,     # using default (110)
                                   'YourAccount',
                                   'YourPassword' )

=== Instance Methods
d72 1
a72 7
    starts POP3 session.

    When called with block, gives a POP3 object to block and
    closes the session after block call finish.

: active?
    true if POP3 session is started.
d74 2
a75 21
: address
    the address to connect

: port
    the port number to connect

: open_timeout
: open_timeout=(n)
    seconds to wait until connection is opened.
    If POP3 object cannot open a conection in this seconds,
    it raises TimeoutError exception.

: read_timeout
: read_timeout=(n)
    seconds to wait until reading one block (by one read(1) call).
    If POP3 object cannot open a conection in this seconds,
    it raises TimeoutError exception.

: finish
    finishes POP3 session.
    If POP3 session had not be started, does nothing and return false.
d78 2
a79 2
    an array of Net::POPMail objects.
    This array is renewed when session started.
d83 1
a83 1
    is equals to "pop3.mails.each"
d87 2
a88 2
    deletes all mails on server.
    If called with block, gives mails to the block before deleting.
d90 7
a96 6
        # example
        n = 1
        pop.delete_all do |m|
          File.open("inbox/#{n}") {|f| f.write m.pop }
          n += 1
        end
d98 5
a102 7
: auth_only( account, password )
    (just for POP-before-SMTP)
    opens POP3 session and does autholize and quit.
    This method must not be called while POP3 session is opened.
        # example
        pop = Net::POP3.new( 'your.pop3.server' )
        pop.auth_only 'YourAccount', 'YourPassword'
d107 1
d114 1
d117 1
d122 6
a127 1
=== Instance Methods
d130 3
a132 1
    This method fetches a mail and write to 'dest' using '<<' method.
d134 11
a144 6
        # example
        allmails = nil
        POP3.start( 'your.pop3.server', 110,
                    'YourAccount, 'YourPassword' ) do |pop|
          allmails = pop.mails.collect {|popmail| popmail.pop }
        end
d147 1
a147 1
    gives the block part strings of a mail.
d149 9
a157 8
        # example
        POP3.start( 'localhost', 110 ) {|pop3|
          pop3.each_mail do |m|
            m.pop do |str|
              # do anything
            end
          end
        }
d160 1
a160 1
    This method fetches only mail header.
d163 1
a163 1
    This method fetches mail header and LINES lines of body.
d166 2
a167 1
    deletes mail on server.
d170 1
a170 1
    mail size (bytes)
d173 1
a173 1
    true if mail was deleted
d206 1
a206 6

      def auth_only( address = nil, port = nil,
                     account = nil, password = nil )
        new( address, port ).auth_only account, password
      end

a215 12
    def auth_only( account = nil, password = nil )
      begin
        connect
        @@active = true
        @@command.auth address, port
        @@command.quit
      ensure
        @@active = false
        disconnect
      end
    end

a225 1
      io_check
d248 2
a249 2
    def do_start( account, password )
      @@command.auth account, password
d251 1
a251 1
      mails = []
d254 3
a256 1
        mails.push mtype.new(idx, size, @@command) if size
d258 1
a258 1
      @@mails = mails.freeze
d262 3
a264 2
      (not @@socket or @@socket.closed?) and
              raise IOError, 'pop session is not opened yet'
d360 2
a361 3
          m = /\A(\d+)[ \t]+(\d+)/.match(line) or
                  raise BadResponse, "illegal response: #{line}"
          arr[ m[1].to_i ] = m[2].to_i
d377 1
a377 1
        @@socket.read_pendstr dest
d383 2
a384 2
        getok sprintf('RETR %d', num)
        @@socket.read_pendstr dest, &block
d390 1
a390 1
        getok sprintf('DELE %d', num)
d396 1
a396 1
        getok( sprintf('UIDL %d', num) ).msg.split(' ')[1]
d437 4
a440 2
      m = /<.+>/.match( rep.msg ) or
              raise ProtoAuthError, "not APOP server: cannot login"
d447 1
a447 2
                                   account,
                                   MD5.new(@@stamp + pass).hexdigest )
@


1.27.2.4
log
@* smtp.rb, pop.rb, http.rb: modify document.
@
text
@a30 1
    require 'net/pop'
d32 11
a42 12
    Net::POP3.start( 'pop3.server.address', 110,
                     'YourAccount', 'YourPassword' ) {|pop|
      if pop.mails.empty? then
        puts 'no mail.'
      else
        i = 0
        pop.each_mail do |m|   # or "pop.mails.each ..."
          File.open( 'inbox/' + i.to_s, 'w' ) {|f|
            f.write m.pop
          }
          m.delete
          i += 1
d44 2
d47 3
a49 2
      puts "#{pop.mails.size} mails popped."
    }
d53 5
a57 22
    require 'net/pop'
    Net::POP3.start( 'pop3.server.address', 110,
                     'YourAccount', 'YourPassword' ) {|pop|
      if pop.mails.empty? then
        puts 'no mail.'
      else
        i = 0
        pop.delete_all do |m|
          File.open( 'inbox/' + i.to_s, 'w' ) {|f|
            f.write m.pop
          }
          i += 1
        end
      end
    }

And here is more shorter example.

    require 'net/pop'
    i = 0
    Net::POP3.delete_all( 'pop3.server.address', 110,
                          'YourAccount', 'YourPassword' ) do |m|
d63 13
d82 7
a88 7
    require 'net/pop'
    Net::POP3.delete_all( 'pop3.server.address', 110,
                          'YourAccount', 'YourPassword' ) do |m|
      File.open( 'inbox', 'w' ) {|f|
        m.pop f   ####
      }
    end
d96 15
a110 15
    # (1)
    require 'net/pop'
    Net::APOP.start( 'apop.server.address', 110,
                     'YourAccount', 'YourPassword' ) {|pop|
      # Rest code is same.
    }

    # (2)
    require 'net/pop'
    Net::POP3.start( 'apop.server.address', 110,
                     'YourAccount', 'YourPassword',
                     true   ####
    ) {|pop|
      # Rest code is same.
    }
d117 2
a118 2
    creates a new Net::POP3 object.
    This method does not open TCP connection yet.
d122 1
a122 1
    equals to Net::POP3.new( address, port ).start( account, password )
d124 6
a129 6
        Net::POP3.start( addr, port, account, password ) do |pop|
          pop.each_mail do |m|
            file.write m.pop
            m.delete
          end
        end
d132 2
a133 2
    starts POP3 protocol and iterates for each POPMail object.
    This method equals to
d135 7
a141 5
        Net::POP3.start( address, port, account, password ) {|pop|
          pop.each_mail do |m|
            yield m
          end
        }
d143 4
a146 6
        # example
        Net::POP3.foreach( 'your.pop.server', 110,
                           'YourAccount', 'YourPassword' ) do |m|
          file.write m.pop
          m.delete if $DELETE
        end
d232 1
a232 1
    reset the session. All "deleted mark" are removed.
@


1.27.2.5
log
@aamine
* lib/net/protocol.rb (ProtoSocket#read): modify typo.
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.36
d204 1
a204 1
    If POP3 session had not be started, raises an IOError.
@


1.27.2.6
log
@Reflect the update of the MD5 module which is now Digest::MD5.
@
text
@d291 1
a291 1
require 'digest/md5'
d575 1
a575 1
                                   Digest::MD5.hexdigest(@@stamp + pass) )
@


1.27.2.7
log
@aamine
* lib/net/smtp.rb: SMTP.new requires at least one arg.
* lib/net/pop.rb: POP.new requires at least one arg.
* lib/net/pop.rb: uses "raise *Error.new" instead of simple raise.
* lib/net/http.rb: HTTP.new requires at least one arg.
* lib/net/http.rb: changes implicit start algolithm.
@
text
@d13 3
a15 2
NOTE: You can find Japanese version of this document in
the doc/net directory of the standard ruby interpreter package.
d119 1
a119 1
: new( address, port = 110, apop = false )
d123 2
a124 2
: start( address, port = 110, account, password )
: start( address, port = 110, account, password ) {|pop| .... }
d134 1
a134 1
: foreach( address, port = 110, account, password ) {|mail| .... }
d151 2
a152 2
: delete_all( address, port = 110, account, password )
: delete_all( address, port = 110, account, password ) {|mail| .... }
d161 1
a161 1
: auth_only( address, port = 110, account, password )
d291 1
a291 1
require 'md5'
d306 1
a306 1
      def foreach( address, port = nil,
d313 1
a313 1
      def delete_all( address, port = nil,
d320 1
a320 1
      def auth_only( address, port = nil,
d328 1
a328 1
    def initialize( addr, port = nil, apop = false )
d334 1
a334 1
    def auth_only( account, password )
d425 3
a427 3
    def pop( dest = '', &block )
      if block then
        dest = NetPrivate::ReadAdapter.new( block )
d431 2
a432 3

    alias all pop
    alias mail pop
d443 1
a443 1
      @@command.dele @@num
d473 1
a473 1
    def auth( account, pass )
d475 1
a475 1
        @@socket.writeline 'USER ' + account
d540 3
a542 3
        return check_reply( SuccessCode )
      rescue ProtocolError => err
        raise ProtoAuthError.new( 'Fail to POP authentication', err.response )
d544 2
d552 1
a552 1
        Response.new( SuccessCode, str[0,3], str[3, str.size - 3].strip )
d554 1
a554 1
        Response.new( ErrorCode, str[0,4], str[4, str.size - 4].strip )
d567 1
a567 1
              raise ProtoAuthError.new( "not APOP server: cannot login", nil )
d575 1
a575 1
                                   MD5.new(@@stamp + pass).hexdigest )
@


1.27.2.8
log
@aamine
* lib/net/smtp.rb: uses Digest::MD5 instead of MD5 (again).
* lib/net/pop.rb: ditto.
* lib/net/http.rb (HTTP#request): must pass block.
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.37
d290 1
a290 1
require 'digest/md5'
d573 1
a573 1
                                   Digest::MD5.hexdigest(@@stamp + pass) )
@


1.27.2.9
log
@aamine
* lib/net/protocol.rb: calls on_connect before conn_command
@
text
@d32 8
a39 8
    pop = Net::POP3.new( 'pop3.server.address', 110 )
    pop.start( 'YourAccount', 'YourPassword' )          ###
    if pop.mails.empty? then
      puts 'no mail.'
    else
      i = 0
      pop.each_mail do |m|   # or "pop.mails.each ..."
	File.open( 'inbox/' + i.to_s, 'w' ) {|f|
d41 4
a44 3
        }
        m.delete
        i += 1
a46 31
    end
    pop.finish                                           ###

(1) call Net::POP3#start and start POP session
(2) access mails by using POP3#each_mail and/or POP3#mails
(3) close POP session by calling POP3#finish or use block form #start.

This example is using block form #start to close the session.
=== Enshort Code

The example above is very verbose. You can enshort code by using
some utility methods. At first, block form of Net::POP3.start can
alternates POP3.new, POP3#start and POP3#finish.

    require 'net/pop'

    Net::POP3.start( 'pop3.server.address', 110 )
                     'YourAccount', 'YourPassword' )
	if pop.mails.empty? then
	  puts 'no mail.'
	else
	  i = 0
	  pop.each_mail do |m|   # or "pop.mails.each ..."
	    File.open( 'inbox/' + i.to_s, 'w' ) {|f|
                f.write m.pop
	    }
	    m.delete
	    i += 1
	  end
          puts "#{pop.mails.size} mails popped."
	end
d49 1
a49 1
POP3#delete_all alternates #each_mail and m.delete.
a51 1

d54 11
a64 11
	if pop.mails.empty? then
	  puts 'no mail.'
	else
	  i = 0
	  pop.delete_all do |m|
	    File.open( 'inbox/' + i.to_s, 'w' ) {|f|
		f.write m.pop
	    }
	    i += 1
	  end
	end
a69 1

d74 1
a74 1
          f.write m.pop
d88 1
a88 1
          m.pop f   ####
d102 1
a102 1
        # Rest code is same.
d111 1
a111 1
        # Rest code is same.
d126 6
a131 6
        Net::POP3.start( addr, port, account, password ) {|pop|
	    pop.each_mail do |m|
	      file.write m.pop
	      m.delete
	    end
        }
d138 3
a140 3
            pop.each_mail do |m|
	      yield m
	    end
d166 4
a169 4
        Net::POP3.auth_only( 'your.pop3.server',
                             nil,     # using default (110)
                             'YourAccount',
                             'YourPassword' )
d256 3
a258 3
                    'YourAccount, 'YourPassword' ) {|pop|
            allmails = pop.mails.collect {|popmail| popmail.pop }
        }
d265 5
a269 5
	    pop3.each_mail do |m|
	      m.pop do |str|
		# do anything
	      end
	    end
@


1.27.2.10
log
@aamine
* lib/net/protocol.rb: Protocol#start returns the return value of block.
* lib/net/protocol.rb: set timeout limit by default.
* lib/net/protocol.rb: new methods WriteAdapter#write, puts, print, printf.
* lib/net/protocol.rb: change template method scheme.
* lib/net/http.rb: rename HTTP#get2 to request_get, post2 to request_post ...
* lib/net/pop.rb: POP#auth_only did not work.
* lib/net/smtp.rb: should not resolve HELO domain automatically.
@
text
@d3 1
a3 1
= net/pop.rb
a15 2
$Id: header.rd,v 1.2 2001/12/10 12:37:16 aamine Exp $

d126 3
a128 3
The net/pop library supports APOP authentication.
To use APOP, use Net::APOP class instead of Net::POP3 class.
You can use utility method, Net::POP3.APOP(). Example:
d130 1
d132 4
d137 6
a142 3
    # use APOP authentication if $isapop == true
    pop = Net::POP3.APOP($isapop).new( 'apop.server.address', 110 )
    pop.start( YourAccount', 'YourPassword' ) {|pop|
a145 1

a164 13
: APOP( is_apop )
    returns Net::APOP class object if IS_APOP is true.
    returns Net::POP3 class object if false.
    Use this method like:

        # example 1
        pop = Net::POP3::APOP($isapop).new( addr, port )

        # example 2
        Net::POP3::APOP($isapop).start( addr, port ) {|pop|
            ....
        }

d329 5
a333 4
    protocol_param :port,              '110'
    protocol_param :command_type,      '::Net::POP3Command'
    protocol_param :apop_command_type, '::Net::APOPCommand'
    protocol_param :mail_type,         '::Net::POPMail'
a336 4
      def APOP( bool )
        bool ? APOP : POP3
      end

a358 12
    def auth_only( account, password )
      active? and raise IOError, 'opening already opened POP session'
      start( account, password ) {
          ;
      }
    end


    #
    # connection
    #

d365 10
a374 12
    private

    def do_start( account, password )
      conn_socket
      @@command = (@@apop ? type.apop_command_type : type.command_type).new(socket())
      @@command.auth account, password
    end

    def do_finish
      @@mails = nil
      disconn_command
      disconn_socket
d377 1
a377 17

    #
    # POP operations
    #

    public

    def mails
      return @@mails if @@mails

      mails = []
      mtype = type.mail_type
      command().list.each_with_index do |size,idx|
        mails.push mtype.new(idx, size, command()) if size
      end
      @@mails = mails.freeze
    end
d380 2
a381 1
      mails().each( &block )
d387 2
a388 1
      mails().each do |m|
d395 3
a397 2
      command().rset
      mails().each do |m|
d403 16
a418 3
    def command
      io_check
      super
d422 2
a423 2
      (not socket() or socket().closed?) and
              raise IOError, 'POP session is not opened yet'
d428 3
a430 1
  POP = POP3
d434 1
a434 1
    protocol_param :command_type, '::Net::APOPCommand'
d437 2
d458 1
a458 1
        dest = ReadAdapter.new( block )
d492 4
d500 2
a501 2
      atomic {
          check_reply SuccessCode
d506 3
a508 3
      atomic {
          @@socket.writeline 'USER ' + account
          check_reply_auth
d510 2
a511 2
          @@socket.writeline 'PASS ' + pass
          check_reply_auth
d517 7
a523 7
      atomic {
          getok 'LIST'
          @@socket.read_pendlist do |line|
            m = /\A(\d+)[ \t]+(\d+)/.match(line) or
                    raise BadResponse, "illegal response: #{line}"
            arr[ m[1].to_i ] = m[2].to_i
          end
d529 2
a530 2
      atomic {
          getok 'RSET'
d536 3
a538 3
      atomic {
          getok sprintf( 'TOP %d %d', num, lines )
          @@socket.read_pendstr dest
d543 3
a545 3
      atomic {
          getok sprintf('RETR %d', num)
          @@socket.read_pendstr dest, &block
d550 2
a551 2
      atomic {
          getok sprintf('DELE %d', num)
d556 2
a557 2
      atomic {
          getok( sprintf('UIDL %d', num) ).msg.split(' ')[1]
d562 2
a563 2
      atomic {
          getok 'QUIT'
d567 1
d572 1
a572 1
        return check_reply(SuccessCode)
d574 1
a574 1
        raise ProtoAuthError.new('Fail to POP authentication', err.response)
d594 4
a597 3
      response = super(sock)
      m = /<.+>/.match(response.msg) or
              raise ProtoAuthError.new("not APOP server: cannot login", nil)
d602 5
a606 5
      atomic {
          @@socket.writeline sprintf('APOP %s %s',
                                    account,
                                    Digest::MD5.hexdigest(@@stamp + pass))
          check_reply_auth
d613 1
a613 5
  # for backward compatibility

  POPSession  = POP3
  POP3Session = POP3
  APOPSession = APOP
@


1.27.2.11
log
@aamine
* lib/net/http.rb: HTTP.Proxy should use self for proxy-class's super class.
* lib/net/http.rb: initialize HTTP.proxy_port by HTTP.port.
@
text
@@


1.27.2.12
log
@aamine
* lib/net/http.rb: remove unused class Accumulator.
* lib/net/http.rb: read response in HTTP#request. not HTTPRequest#exec.
* lib/net/http.rb: proxy related class instance variables are not initialized correctly.
* doc/net/http.rb: modify typo in the description of basic auth.
@
text
@d5 1
a5 1
Copyright (c) 1999-2002 Yukihiro Matsumoto
d16 1
a16 1
$Id: header.rd,v 1.2.2.1 2002/02/19 13:15:22 aamine Exp $
@


1.27.2.13
log
@* lib/net/protocol.rb: set read_timeout dynamically.
@
text
@@


1.26
log
@aamine
* lib/net/http.rb: does not send HEAD on closing socket.
@
text
@d3 1
a3 1
= net/pop.rb version 1.2.0
d129 1
a129 3
: all( dest = '' )
: pop
: mail
d136 1
a136 1
      pop.each do |popm|
d146 2
a147 3
: all {|str| .... }
  You can call all/pop/mail with block.
  argument 'str' is a read string (a part of mail).
d151 5
a155 3
    POP3.start( 'localhost', 110 ) do |pop|
      pop.mails[0].pop do |str|               # pop only first mail...
        _do_anything_( str )
@


1.25
log
@aamine
* lib/net/protocol.rb: set @@closed false in Socket#reopen.
* lib/net/pop.rb: add POP3.foreach, delete_all.
* lib/net/pop.rb: add POP3#delete_all.
* lib/net/http.rb: add HTTP.version_1_1, version_1_2
* lib/net/http.rb: refactoring.
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.32
d129 3
a131 1
: pop( dest = '' )
d138 1
a138 1
      pop.each_mail do |popm|
d148 3
a150 2
: pop {|str| .... }
  If pop() is called with block, it gives the block part strings of a mail.
d154 3
a156 5
    POP3.start( 'localhost', 110 ) do |pop3|
      pop3.each_mail do |m|
        m.pop do |str|
          # do anything
        end
@


1.24
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.31
* lib/net/http.rb: initializes header in HTTP, not HTTPCommand
* lib/net/protocol.rb, http.rb: rewrites proxy code
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.31
d28 29
a56 3
: start( address = 'localhost', port = 110, *protoargs )
: start( address = 'localhost', port = 110, *protoargs ) {|pop| .... }
  equals to Net::POP3.new( address, port ).start( *protoargs )
d58 10
d74 2
a75 5
  When called with block, give a POP3 object to block and
  close session after block call is finished.

: each {|popmail| .... }
  This method is equals to "pop3.mails.each"
d81 23
d129 1
a129 3
: all( dest = '' )
: pop
: mail
d136 1
a136 1
      pop.each do |popm|
d140 3
d146 2
a147 3
: all {|str| .... }
  You can call all/pop/mail with block.
  argument 'str' is a read string (a part of mail).
d151 5
a155 3
    POP3.start( 'localhost', 110 ) do |pop|
      pop.mails[0].pop do |str|               # pop only first mail...
        _do_anything_( str )
d190 19
d216 1
a216 1
    def each( &block )
d218 10
a227 1
      @@mails.each &block
@


1.23
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.30
* lib/net/protocol.rb, smtp.rb: Command#critical_ok -> error_ok
* lib/net/http.rb: read header when also "100 Continue"
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.30
@


1.22
log
@aamine
* lib/net/pop.rb: POP3#reset
* lib/net/http.rb: a code for "Switch Protocol" was wrongly 100
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.29
@


1.21
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.28.
* lib/net/http.rb: HTTPReadAdapter -> HTTPResponseReceiver
* lib/net/http.rb (connecting): response is got in receive()
@
text
@d48 3
d134 1
a134 1
      @@mails = [].freeze
d139 11
a149 2
    def each
      @@mails.each {|m| yield m }
d159 1
a159 1
      t = type.mail_type
d162 1
a162 1
          @@mails.push t.new( idx, size, @@command )
d168 6
d218 1
a218 1
      top( 0, dest )
d225 1
@


1.20
log
@matz: 1.6.0 final (hopufully)
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.28
d11 4
d38 1
a38 1
  When called with a block, give a POP3 object to block and
d87 1
a87 1
  You can use all/pop/mail with a block.
@


1.19
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.27.
* lib/net/protocol.rb: writing methods returns written byte size.
* lib/net/smtp.rb: send_mail accepts many destinations.
@
text
@d34 1
a34 1
  When called as iterator, give a POP3 object to block and
d83 1
a83 1
  You can use all/pop/mail as the iterator.
d183 1
a183 1
      if iterator? then
@


1.18
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.26.
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb:
  add module Net::NetPrivate and its inner classes
  {Read,Write}Adapter, Command, Socket,
  SMTPCommand, POP3Command, APOPCommand, HTTPCommand
@
text
@d3 1
a3 1
= net/pop.rb version 1.1.27
d7 3
a9 2
This library is distributed under the terms of the Ruby license.
You can freely distribute/modify this library.
@


1.17
log
@o  protocol.rb, smtp.rb, pop.rb, http.rb:  define all#inspect()
o  protocol.rb, smtp.rb, pop.rb, http.rb:  modify/add documents
@
text
@d3 1
a3 1
= net/pop.rb
d120 1
a120 1
    protocol_param :command_type, '::Net::POP3Command'
d158 6
d183 1
a183 1
        dest = ReadAdapter.new( Proc.new )
d216 1
a216 6
  class APOP < POP3
    protocol_param :command_type, 'Net::APOPCommand'
  end

  APOPSession = APOP

a314 1

d337 4
a340 1
end
@


1.16
log
@o  protocol.rb, http.rb, smtp.rb, pop.rb:  update RD documents
@
text
@a9 11
=end


require 'net/protocol'
require 'md5'


module Net


=begin
a42 1
=end
d44 1
a44 1
  class POP3 < Protocol
d46 2
a47 2
    protocol_param :port,         '110'
    protocol_param :command_type, '::Net::POP3Command'
d49 1
a49 1
    protocol_param :mail_type,    '::Net::POPMail'
d51 1
a51 14
    def initialize( addr = nil, port = nil )
      super
      @@mails = [].freeze
    end

        
    attr :mails

    def each
      @@mails.each {|m| yield m }
    end


    private
a53 22
    def do_start( acnt, pwd )
      @@command.auth( acnt, pwd )

      @@mails = []
      t = type.mail_type
      @@command.list.each_with_index do |size,idx|
        if size then
          @@mails.push t.new( idx, size, @@command )
        end
      end
      @@mails.freeze
    end

  end

  POP         = POP3
  POPSession  = POP3
  POP3Session = POP3


=begin

d63 1
a63 1
=== Method
d111 48
d169 1
d171 3
a173 1
    attr :size
a208 12
=begin

== Net::APOP

This class defines no new methods.
Only difference from POP3 is using APOP authentification.

=== Super Class

Net::POP3

=end
a210 1

a211 1

a226 1

a236 1

a248 1

a262 1

a268 1

a275 1

a281 1

a290 1

a300 1

a325 1

@


1.15
log
@o  protocol.rb:  Protocol#start yields self
o  smtp.rb:  use Socket.gethostname to get localhost name
p  pop.rb:  use MD5#hexdigest
@
text
@d31 2
a32 2
  This method create a new POP3 object.
  This will not open connection yet.
d34 3
d41 2
a42 1
  This method start POP3.
d44 4
a47 1
: each{|popmail| ...}
d51 2
a52 2
  This method returns an array of ((URL:#POPMail)).
  This array is renewed when login.
@


1.14
log
@o pop.rb:  accept illegal timestamp (reported by WATANABE Hirofumi)
o http.rb:  when body was chunked, does not set 'Content-Length'
@
text
@d340 1
a340 1
    def auth( acnt, pass )
d342 2
a343 1
        @@socket.writeline( "APOP #{acnt} #{digest(@@stamp + pass)}" )
a347 7

    def digest( str )
      ret = ''
      MD5.new( str ).digest.each_byte {|i| ret << sprintf('%02x', i) }
      ret
    end
      
@


1.13
log
@protocol.rb smtp.rb pop.rb http.rb version 1.1.12

o protocol.rb:  update Net::Protocol::Proxy#connect
o protocol.rb:  ReplyCode is not a class
o http.rb:  header value does not include header name
o http.rb:  header is not a Hash, but HTTPResponse
@
text
@d332 2
a333 3
      /<[^@@]+@@[^@@>]+>/o === rep.msg
      @@stamp = $&
      unless @@stamp then
d336 1
@


1.12
log
@v1.1.11
o  all:  use "critical" to avoid duplicated command dispatch
o  http.rb:  change get2, post2 usage (HTTPWriter)
o  http.rb:  entity reading algorithm is better
o  http.rb:  more reply code (4xx, 5xx)
o  protocol.rb:  arguments of "connect" can be omitted
o  protocol.rb:  "quit" is not template method (now do_quit is removed)
o  protocol.rb:  ReplyCode.error_type was not work: using module_eval
@
text
@d317 1
a317 1
        return SuccessCode.new( str[0,3], str[3, str.size - 3].strip )
d319 1
a319 1
        return ErrorCode.new( str[0,4], str[4, str.size - 4].strip )
@


1.11
log
@o  protocol.rb:  version 1.1.9
o  smtp.rb:  arguments discription of do_ready was wrongly void
@
text
@d74 1
a74 1
      t = self.type.mail_type
d76 1
d225 3
a227 1
      check_reply SuccessCode
d232 7
a238 7
      @@socket.writeline 'USER ' + acnt
      check_reply_auth

      @@socket.writeline( 'PASS ' + pass )
      ret = check_reply_auth

      return ret
a242 2
      getok 'LIST'
      
d244 8
a251 6
      @@socket.read_pendlist do |line|
        num, siz = line.split( / +/o )
        arr[ num.to_i ] = siz.to_i
      end

      return arr
d256 3
a258 1
      getok 'RSET'
d263 4
a266 2
      getok sprintf( 'TOP %d %d', num, lines )
      @@socket.read_pendstr( dest )
d271 4
a274 2
      getok sprintf( 'RETR %d', num )
      @@socket.read_pendstr( dest, &block )
d279 3
a281 1
      getok sprintf( 'DELE %d', num )
d286 4
a289 2
      rep = getok( sprintf 'UIDL %d', num )
      uid = rep.msg.split(' ')[1]
d291 5
a295 1
      uid
a301 5
    def do_quit
      getok 'QUIT'
    end


d341 4
a344 2
      @@socket.writeline( "APOP #{acnt} #{digest(@@stamp + pass)}" )
      return check_reply_auth
a348 2
      temp = MD5.new( str ).digest

d350 2
a351 4
      temp.each_byte do |i|
        ret << sprintf( '%02x', i )
      end
      return ret
@


1.10
log
@o  session.rb -> protocol.rb
o  write, write_pendstr takes block
o  smtp.ready
o  popmail.pop takes block
@
text
@a218 60
=begin

== Net::POP3Command

POP3 command class.

=== Super Class

Net::Command

=== Class Methods

: new( socket )
  This method creates new POP3Command object. 'socket' must be ProtocolSocket.


=== Methods

: auth( account, password )
  This method do POP authorization (no RPOP)
  In case of failed authorization, raises Protocol::ProtocolError exception.

: list
  a list of mails which existing on server.
  The list is an array like "array[ number ] = size".

  ex:

    The list from server is

    1 2452
    2 3355
    4 9842
       :

    then, an array is

    [ nil, 2452, 3355, nil, 9842, ... ]

: quit
  This method ends POP using 'QUIT' commmand.

: rset
  This method reset all changes done in current session,
  by sending 'RSET' command.

: top( num, lines = 0 )
  This method gets all mail header and 'lines' lines body
  by sending 'TOP' command.  'num' is mail number.

  WARNING: the TOP command is 'Optional' in RFC1939 (POP3)

: retr( num : Integer )
  This method gets a mail by 'RETR' command. 'num' is mail number.

: dele( num : Integer )
  This method deletes a mail on server by 'DELE'.

=end

a313 16
=begin

== APOPCommand

=== Super Class

POP3Command

=== Methods

: auth( account, password )
  This method do authorization by sending 'APOP' command.
  If server is not APOP server, this raises Net::ProtoAuthError exception.
  On other errors, raises Net::ProtocolError.

=end
@


1.9
log
@Version 1.1.4

o  (HTTP) allow no content-length data
@
text
@d13 1
a13 1
require 'net/session'
d104 1
a104 1
: all
d107 24
a130 1
  This method fetches a mail and return it.
d164 3
d201 2
a202 1
This class has no new methods. Only way of authetication is changed.
@


1.8
log
@o  remove RD white lines
@
text
@a50 2
    Version = '1.1.3'

@


1.7
log
@Net version 1.1.3

o  http.rb rd
o  Session -> Protocol
@
text
@a30 1

a37 1

a40 1

a43 1

a108 1

a111 1

a114 1

a118 1

a121 1

a124 1

a206 1

a212 1

a216 1

a233 1

a236 1

a240 1

a245 1

a246 1

a248 1

a249 1

a359 1

@


1.6
log
@Version 1.1.2

o  proxy, version 1
o  use fullpath shvar
@
text
@d7 2
a8 2
This library is distributed under the terms of Ruby license.
You can freely distribute/modify this file.
d22 1
a22 1
== Net::POP3Session
d26 1
a26 1
Net::Session
d32 1
a32 1
  This method create a new POP3Session object.
d40 1
a40 1
  This method start POP session.
d44 1
a44 1
  This method is equals to "pop3session.mails.each"
d53 1
a53 1
  class POP3Session < Session
d55 1
a55 1
    Version = '1.1.2'
d57 9
a65 2
    session_setvar :port,         '110'
    session_setvar :command_type, 'Net::POP3Command'
a77 4
    def proto_initialize
      @@mails      = [].freeze
    end

d79 2
a80 1
      @@proto.auth( acnt, pwd )
d82 1
a82 1
      @@proto.list.each_with_index do |size,idx|
d84 1
a84 1
          @@mails.push POPMail.new( idx, size, @@proto )
d90 1
a90 1
  end   # POP3Session
d92 3
a94 2
  POPSession = POP3Session
  POP3       = POP3Session
d141 4
a144 4
    def initialize( idx, siz, pro )
      @@num     = idx
      @@size    = siz
      @@proto   = pro
d153 1
a153 1
      @@proto.retr( @@num, dest )
d159 1
a159 1
      @@proto.top( @@num, lines, dest )
d167 1
a167 1
      @@proto.dele( @@num )
d177 1
a177 1
      @@proto.uidl @@num
d185 1
a185 1
== Net::APOP3Session
d191 1
a191 1
Net::POP3Session
d195 1
a195 1
  class APOPSession < POP3Session
d197 1
a197 1
    session_setvar :command_type, 'Net::APOPCommand'
d201 1
a201 1
  APOP = APOPSession
d208 1
a208 1
POP3 protocol class.
d248 1
a248 1
  This method finishes POP3 session.
d284 1
a284 1
      @@socket.writeline( 'USER ' + acnt )
d295 1
a295 2
      @@socket.writeline( 'LIST' )
      check_reply( SuccessCode )
d308 1
a308 2
      @@socket.writeline( 'RSET' )
      check_reply( SuccessCode )
d313 2
a314 4
      @@socket.writeline( sprintf( 'TOP %d %d', num, lines ) )
      check_reply( SuccessCode )

      return @@socket.read_pendstr( dest )
d319 2
a320 4
      @@socket.writeline( sprintf( 'RETR %d', num ) )
      check_reply( SuccessCode )

      return @@socket.read_pendstr( dest, &block )
d325 1
a325 2
      @@socket.writeline( 'DELE ' + num.to_s )
      check_reply( SuccessCode )
d330 1
a330 2
      @@socket.writeline( 'UIDL ' + num.to_s )
      rep = check_reply( SuccessCode )
d341 1
a341 2
      @@socket.writeline( 'QUIT' )
      check_reply( SuccessCode )
@


1.5
log
@Version 1.1.1

o  HTTP chunk data
@
text
@d55 1
a55 1
    Version = '1.1.1'
d58 1
a58 1
    session_setvar :command_type, 'POP3Command'
d192 1
a192 1
    session_setvar :command_type, 'APOPCommand'
@


1.4
log
@Version 1.1.0
o  http.rb
o  support class swap
o  Net.quote
@
text
@d55 2
@


1.3
log
@19991018
@
text
@d3 1
a3 1
= Net module version 1.0.3 reference manual
d5 1
a5 1
pop.rb written by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d7 2
a8 2
This library is distributed under the terms of Ruby style license.
You can freely distribute/modify/copy this file.
d19 1
d32 2
a33 5
  This method create a new POP3Session object but this will not open connection.

=end

  class POP3Session < Session
a35 2
=begin

d44 1
a44 1
  This method is equals to "POP3Session.mails.each"
d48 1
a48 1
  This method returns an array of <a href="#popi">POP3Session::POPMail</a>.
d53 6
d61 3
a63 1
    def each() @@mails.each{|m| yield m} end
a69 2
      @@proto_type = POP3Command
      @@port       = 110
a72 1

d84 1
d86 2
a87 3
    def do_finish
      @@proto.quit
    end
d92 1
a92 1
== Net::POP3Session::POPMail
a99 13
=end

    class POPMail

      def initialize( idx, siz, pro )
        @@num     = idx
        @@size    = siz
        @@proto   = pro

        @@deleted = false
      end

=begin
d132 9
a140 1
      attr :size
a141 5
      def all( dest = '' )
        @@proto.retr( @@num, dest )
      end
      alias pop all
      alias mail all
d143 1
a143 3
      def top( lines, dest = '' )
        @@proto.top( @@num, lines, dest )
      end
d145 5
a149 3
      def header( dest = '' )
        top( 0, dest )
      end
d151 3
a153 5
      def delete
        @@proto.dele( @@num )
        @@deleted = true
      end
      alias delete! delete
d155 3
a157 3
      def deleted?
        @@deleted
      end
d159 5
a163 3
      def uidl
        @@proto.uidl @@num
      end
d165 2
d169 3
a171 1
  end   # POP3Session
d173 1
a173 2
  POPSession = POP3Session
  POP3       = POP3Session
d190 1
a190 4
    def proto_initialize
      super
      @@proto_type = APOPCommand
    end
a212 11
=end

  class POP3Command < Command

    def initialize( sock )
      @@uidl = nil
      super
    end


=begin
d267 9
d377 1
a377 1
POP3
a417 5
  end


  unless Session::Version == '1.0.3' then
    $stderr.puts "WARNING: wrong version of session.rb & pop.rb"
@


1.2
log
@maillib-1.0.2
@
text
@d3 1
a3 1
= Net module version 1.0.2 reference manual
d170 4
d226 5
d335 1
a335 1
      @@socket.writeline( sprintf( 'DELE %s', num ) )
d340 8
d432 1
a432 1
  unless Session::Version == '1.0.2' then
@


1.1
log
@maillib-1.0.1
@
text
@d1 11
a11 5
#
# pop.rb  version 1.0.1
#
#   author: Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
#
d19 16
d37 20
d89 11
d111 33
d172 15
a186 1
  end
d188 1
d199 14
d214 1
a214 2
  POPSession = POP3Session
  POP3       = POP3Session
d216 1
d218 1
d222 56
d365 17
d415 1
a415 1
  unless Session::Version == '1.0.1' then
@


1.1.2.1
log
@maillib-1.0.2
@
text
@d1 5
a5 11
=begin

= Net module version 1.0.2 reference manual

pop.rb written by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>

This library is distributed under the terms of Ruby style license.
You can freely distribute/modify/copy this file.

=end

a12 16
=begin

== Net::POP3Session

=== Super Class

Net::Session

=== Class Methods

: new( address = 'localhost', port = 110 )

  This method create a new POP3Session object but this will not open connection.

=end

a14 20

=begin

=== Methods

: start( account, password )

  This method start POP session.

: each{|popmail| ...}

  This method is equals to "POP3Session.mails.each"

: mails

  This method returns an array of <a href="#popi">POP3Session::POPMail</a>.
  This array is renewed when login.

=end

a46 11
=begin

== Net::POP3Session::POPMail

A class of mail which exists on POP server.

=== Super Class

Object

=end
a57 33
=begin

=== Method

: all
: pop
: mail

  This method fetches a mail and return it.

: header

  This method fetches only mail header.

: top( lines )

  This method fetches mail header and 'lines' lines body.

: delete
: delete!

  This method deletes mail.

: size

  size of mail(bytes)

: deleted?

  true if mail was deleted

=end

d86 1
a86 5
  end   # POP3Session

  POPSession = POP3Session
  POP3       = POP3Session

a87 11
=begin

== Net::APOP3Session

This class has no new methods. Only way of authetication is changed.

=== Super Class

Net::POP3Session

=end
a97 1
  APOP = APOPSession
d99 2
a101 11
=begin

== Net::POP3Command

POP3 protocol class.

=== Super Class

Net::Command

=== Class Methods
a102 5
: new( socket )

  This method creates new POP3Command object. 'socket' must be ProtocolSocket.

=end
a105 56

=begin

=== Methods

: auth( account, password )

  This method do POP authorization (no RPOP)
  In case of failed authorization, raises Protocol::ProtocolError exception.

: list

  a list of mails which existing on server.
  The list is an array like "array[ number ] = size".

  ex:

    The list from server is

    1 2452
    2 3355
    4 9842
       :

    then, an array is

    [ nil, 2452, 3355, nil, 9842, ... ]

: quit

  This method finishes POP3 session.

: rset

  This method reset all changes done in current session,
  by sending 'RSET' command.

: top( num, lines = 0 )

  This method gets all mail header and 'lines' lines body
  by sending 'TOP' command.  'num' is mail number.

  WARNING: the TOP command is 'Optional' in RFC1939 (POP3)


: retr( num : Integer )

  This method gets a mail by 'RETR' command. 'num' is mail number.


: dele( num : Integer )

  This method deletes a mail on server by 'DELE'.

=end

a192 17
=begin

== APOPCommand

=== Super Class

POP3

=== Methods

: auth( account, password )

  This method do authorization by sending 'APOP' command.
  If server is not APOP server, this raises Net::ProtoAuthError exception.
  On other errors, raises Net::ProtocolError.

=end
d226 1
a226 1
  unless Session::Version == '1.0.2' then
@


1.1.2.2
log
@net/ version 1.1.3 for ruby 1.4
@
text
@d3 1
a3 1
= net/pop.rb
d5 1
a5 1
written by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d7 2
a8 2
This library is distributed under the terms of the Ruby license.
You can freely distribute/modify this library.
a18 1

d21 1
a21 1
== Net::POP3
d25 1
a25 1
Net::Protocol
d30 6
a35 2
  This method create a new POP3 object.
  This will not open connection yet.
d38 2
d43 2
a44 1
  This method start POP3.
d47 2
a48 1
  This method is equals to "pop3.mails.each"
d51 2
a52 1
  This method returns an array of ((URL:#POPMail)).
d57 1
a57 1
  class POP3 < Protocol
d59 1
a59 1
    Version = '1.1.3'
a60 2
    protocol_param :port,         '110'
    protocol_param :command_type, '::Net::POP3Command'
d62 1
a62 1
    protocol_param :mail_type,    '::Net::POPMail'
a63 7
    def initialize( addr = nil, port = nil )
      super
      @@mails = [].freeze
    end

        
    attr :mails
d65 4
a68 2
    def each
      @@mails.each {|m| yield m }
a71 3
    private


d73 1
a73 2
      @@command.auth( acnt, pwd )
      t = self.type.mail_type
d75 1
a75 1
      @@command.list.each_with_index do |size,idx|
d77 1
a77 1
          @@mails.push t.new( idx, size, @@command )
a82 1
  end
d84 3
a86 3
  POP         = POP3
  POPSession  = POP3
  POP3Session = POP3
d91 1
a91 1
== Net::POPMail
d99 13
d118 1
d122 1
d126 1
d131 1
d135 1
d139 1
d144 1
a144 1
  class POPMail
d146 5
a150 4
    def initialize( n, s, cmd )
      @@num     = n
      @@size    = s
      @@command = cmd
d152 3
a154 2
      @@deleted = false
    end
d156 3
d160 5
a164 1
    attr :size
d166 3
a168 13
    def all( dest = '' )
      @@command.retr( @@num, dest )
    end
    alias pop all
    alias mail all

    def top( lines, dest = '' )
      @@command.top( @@num, lines, dest )
    end

    def header( dest = '' )
      top( 0, dest )
    end
a169 3
    def delete
      @@command.dele( @@num )
      @@deleted = true
a170 1
    alias delete! delete
d172 1
a172 3
    def deleted?
      @@deleted
    end
d174 2
a175 5
    def uidl
      @@command.uidl @@num
    end

  end
d180 1
a180 1
== Net::APOP
d186 1
a186 1
Net::POP3
d190 1
a190 1
  class APOP < POP3
d192 4
a195 1
    protocol_param :command_type, 'Net::APOPCommand'
d199 1
a199 1
  APOPSession = APOP
d206 1
a206 1
POP3 command class.
d215 1
d218 6
d228 1
d233 1
d251 2
a252 1
  This method ends POP using 'QUIT' commmand.
d255 1
d260 1
d266 1
d268 1
d271 1
d273 1
a277 9

  class POP3Command < Command

    def initialize( sock )
      super
      check_reply SuccessCode
    end


d279 1
a279 1
      @@socket.writeline 'USER ' + acnt
d290 2
a291 1
      getok 'LIST'
d304 2
a305 1
      getok 'RSET'
d310 4
a313 2
      getok sprintf( 'TOP %d %d', num, lines )
      @@socket.read_pendstr( dest )
d318 4
a321 2
      getok sprintf( 'RETR %d', num )
      @@socket.read_pendstr( dest, &block )
d326 2
a327 1
      getok sprintf( 'DELE %d', num )
a330 7
    def uidl( num )
      rep = getok( sprintf 'UIDL %d', num )
      uid = rep.msg.split(' ')[1]

      uid
    end

d336 2
a337 1
      getok 'QUIT'
d371 1
a371 1
POP3Command
d376 1
d412 5
@


1.1.2.3
log
@Version 1.1.4

o (HTTP) allow no content-length message
@
text
@d51 2
@


1.1.2.4
log
@version 1.1.7 for ruby-1.4
protocol.rb smtp.rb pop.rb http.rb
@
text
@d13 1
a13 1
require 'net/protocol'
d104 1
a104 1
: all( dest = '' )
d107 1
a107 24
  This method fetches a mail and write to 'dest' using '<<' method.

    # usage example

    mailarr = []
    POP3.start( 'localhost', 110 ) do |pop|
      pop.each do |popm|
        mailarr.push popm.pop   # all() returns 'dest' (this time, string)
        # or, you can also
        # popm.pop( $stdout )   # write mail to stdout
      end
    end

: all {|str| .... }
  You can use all/pop/mail as the iterator.
  argument 'str' is a read string (a part of mail).

    # usage example

    POP3.start( 'localhost', 110 ) do |pop|
      pop.mails[0].pop do |str|               # pop only first mail...
        _do_anything_( str )
      end
    end
a140 3
      if iterator? then
        dest = ReadAdapter.new( Proc.new )
      end
d175 1
a175 2
This class defines no new methods.
Only difference from POP3 is using APOP authentification.
@


1.1.2.5
log
@protocol.rb/smtp.rb/pop.rb/http.rb 1.1.8
o  http.rb:  post, get2, post2, get_body
@
text
@d219 60
d374 16
@


1.1.2.6
log
@o  all:  use "critical" to avoid duplicated command dispatch
o  http.rb:  change get2, post2 usage (HTTPWriter)
o  http.rb:  entity reading algorithm is better
o  http.rb:  more reply code (4xx, 5xx)
o  protocol.rb:  arguments of "connect" can be omitted
o  protocol.rb:  "quit" is not template method (now do_quit is removed)
o  protocol.rb:  ReplyCode.error_type was not work: using module_eval
@
text
@d74 1
a74 1

a75 1
      t = type.mail_type
d224 1
a224 3
      critical {
        check_reply SuccessCode
      }
d229 7
a235 7
      critical {
        @@socket.writeline 'USER ' + acnt
        check_reply_auth

        @@socket.writeline 'PASS ' + pass
        check_reply_auth
      }
d240 2
d243 6
a248 8
      critical {
        getok 'LIST'
        @@socket.read_pendlist do |line|
          num, siz = line.split( / +/o )
          arr[ num.to_i ] = siz.to_i
        end
      }
      arr
d253 1
a253 3
      critical {
        getok 'RSET'
      }
d258 2
a259 4
      critical {
        getok sprintf( 'TOP %d %d', num, lines )
        @@socket.read_pendstr( dest )
      }
d264 2
a265 4
      critical {
        getok sprintf( 'RETR %d', num )
        @@socket.read_pendstr( dest, &block )
      }
d270 1
a270 3
      critical {
        getok sprintf( 'DELE %d', num )
      }
d275 4
a278 3
      critical {
        getok( sprintf 'UIDL %d', num ).msg.split(' ')[1]
      }
d282 1
a282 5
    def quit
      critical {
        getok 'QUIT'
      }
    end
d285 3
a287 1
    private
d329 2
a330 4
      critical {
        @@socket.writeline( "APOP #{acnt} #{digest(@@stamp + pass)}" )
        check_reply_auth
      }
d335 2
d338 4
a341 2
      MD5.new( str ).digest.each_byte {|i| ret << sprintf('%02x', i) }
      ret
@


1.1.2.7
log
@protocol.rb smtp.rb pop.rb http.rb 1.1.12 for ruby 1.4 branch
@
text
@d317 1
a317 1
        return Response.new( SuccessCode, str[0,3], str[3, str.size - 3].strip )
d319 1
a319 1
        return Response.new( ErrorCode, str[0,4], str[4, str.size - 4].strip )
@


1.1.2.8
log
@{protocol,smtp,pop,http}.rb 1.1.13 for ruby 1.4 branch
@
text
@d332 3
a334 2
      m = /<.+>/.match( rep.msg )
      unless m then
a336 1
      @@stamp = m[0]
@


1.1.2.9
log
@o  protocol.rb:  Protocol#start yields self
o  smtp.rb:  use Socket.gethostname to get localhost name
@
text
@d340 1
a340 1
    def auth( account, pass )
d342 1
a342 2
        @@socket.writeline sprintf( 'APOP %s %s',
                            account, MD5.new(@@stamp + pass).hexdigest )
d347 7
@


1.1.2.10
log
@o  protocol.rb, http.rb, smtp.rb, pop.rb:  update RD documents
@
text
@d31 2
a32 2
  creates a new Net::POP3 object.
  This method does not open TCP connection yet.
a33 3
: start( address = 'localhost', port = 110, *protoargs )
: start( address = 'localhost', port = 110, *protoargs ) {|pop| .... }
  equals to Net::POP3.new( address, port ).start( *protoargs )
d38 1
a38 2
: start( account, password ) {|pop| .... }
  starts POP3 session.
d40 1
a40 4
  When called as iterator, give a POP3 object to block and
  close session after block call is finished.

: each {|popmail| .... }
d44 2
a45 2
  an array of ((URL:#POPMail)).
  This array is renewed when session started.
@


1.1.2.11
log
@o  protocol.rb, smtp.rb, pop.rb, http.rb:  define all#inspect()
o  protocol.rb, smtp.rb, pop.rb, http.rb:  modify/add documents
@
text
@d10 11
d54 24
d79 12
a90 1
== Net::APOP
d92 1
a92 2
This class defines no new methods.
Only difference from POP3 is using APOP authentification.
d94 3
a96 1
=== Super Class
a97 1
Net::POP3
d99 1
d110 1
a110 1
=== Methods
a157 48
require 'net/protocol'
require 'md5'


module Net

  class POP3 < Protocol

    protocol_param :port,         '110'
    protocol_param :command_type, '::Net::POP3Command'

    protocol_param :mail_type,    '::Net::POPMail'

    def initialize( addr = nil, port = nil )
      super
      @@mails = [].freeze
    end

    attr :mails

    def each
      @@mails.each {|m| yield m }
    end


    private

    def do_start( acnt, pwd )
      @@command.auth( acnt, pwd )

      @@mails = []
      t = type.mail_type
      @@command.list.each_with_index do |size,idx|
        if size then
          @@mails.push t.new( idx, size, @@command )
        end
      end
      @@mails.freeze
    end

  end

  POP         = POP3
  POPSession  = POP3
  POP3Session = POP3



d168 1
a170 4
    def inspect
      "#<#{type} #{@@num}#{@@deleted ? ' deleted' : ''}>"
    end

d205 12
d219 1
d221 1
d237 1
d248 1
d261 1
d276 1
d283 1
d291 1
d298 1
d308 1
d319 1
d345 1
@
