head	1.64;
access;
symbols
	v1_6_7:1.37.2.19
	v1_6_6:1.37.2.15
	v1_6_5:1.37.2.12
	v1_6_4:1.37.2.9
	v1_7_1:1.46
	v1_6_4_preview4:1.37.2.9
	v1_6_4_preview3:1.37.2.9
	v1_6_4_preview2:1.37.2.9
	v1_6_4_preview1:1.37.2.9
	v1_6_3:1.37.2.9
	ruby_m17n:1.37.0.4
	ruby_1_6:1.37.0.2
	v1_6_2:1.37
	v1_6_1:1.28
	v1_6_0:1.25
	v1_4_6:1.3.2.22
	v1_4_5:1.3.2.19
	v1_4_4:1.3.2.2
	ruby_1_4:1.3.0.2;
locks; strict;
comment	@# @;


1.64
date	2002.10.02.16.45.35;	author nobu;	state Exp;
branches;
next	1.63;

1.63
date	2002.07.11.08.22.16;	author matz;	state Exp;
branches;
next	1.62;

1.62
date	2002.03.26.11.18.02;	author aamine;	state Exp;
branches;
next	1.61;

1.61
date	2002.03.22.05.24.00;	author aamine;	state Exp;
branches;
next	1.60;

1.60
date	2002.02.22.12.10.58;	author aamine;	state Exp;
branches;
next	1.59;

1.59
date	2002.02.19.12.33.52;	author aamine;	state Exp;
branches;
next	1.58;

1.58
date	2002.02.07.20.22.39;	author aamine;	state Exp;
branches;
next	1.57;

1.57
date	2001.12.30.19.18.45;	author aamine;	state Exp;
branches;
next	1.56;

1.56
date	2001.12.20.05.00.20;	author aamine;	state Exp;
branches;
next	1.55;

1.55
date	2001.12.13.19.15.21;	author aamine;	state Exp;
branches;
next	1.54;

1.54
date	2001.12.09.08.58.30;	author aamine;	state Exp;
branches;
next	1.53;

1.53
date	2001.12.07.10.04.25;	author aamine;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.17.03.08.45;	author aamine;	state Exp;
branches;
next	1.51;

1.51
date	2001.07.13.21.16.11;	author aamine;	state Exp;
branches;
next	1.50;

1.50
date	2001.07.08.07.00.23;	author aamine;	state Exp;
branches;
next	1.49;

1.49
date	2001.07.03.19.03.16;	author aamine;	state Exp;
branches;
next	1.48;

1.48
date	2001.07.03.18.13.13;	author aamine;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.26.23.49.21;	author aamine;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.13.05.48.58;	author aamine;	state Exp;
branches;
next	1.45;

1.45
date	2001.03.08.08.39.40;	author aamine;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.24.04.53.50;	author aamine;	state Exp;
branches;
next	1.43;

1.43
date	2001.02.22.23.23.57;	author aamine;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.07.17.17.51;	author aamine;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.07.07.23.09;	author aamine;	state Exp;
branches;
next	1.40;

1.40
date	2001.02.06.11.14.51;	author aamine;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.16.07.57.43;	author aamine;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.13.19.07.15;	author aamine;	state Exp;
branches;
next	1.37;

1.37
date	2000.12.24.20.01.43;	author aamine;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2000.12.24.19.39.15;	author aamine;	state Exp;
branches;
next	1.35;

1.35
date	2000.12.22.18.40.55;	author aamine;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.18.05.04.36;	author aamine;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.16.14.03.20;	author aamine;	state Exp;
branches;
next	1.32;

1.32
date	2000.11.10.23.31.32;	author aamine;	state Exp;
branches;
next	1.31;

1.31
date	2000.11.07.11.27.16;	author aamine;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.25.17.40.30;	author aamine;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.11.05.27.56;	author aamine;	state Exp;
branches;
next	1.28;

1.28
date	2000.09.23.18.00.28;	author aamine;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.21.06.58.00;	author aamine;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.12.05.37.35;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.16.19.26.06;	author aamine;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.12.06.04.40;	author aamine;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.03.09.20.35;	author aamine;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.01.18.28.24;	author aamine;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.27.13.36.17;	author aamine;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.16.13.47.38;	author aamine;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.12.16.42.46;	author aamine;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.12.15.45.58;	author aamine;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.09.07.53.59;	author aamine;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.01.13.43.43;	author aamine;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.22.13.39.24;	author aamine;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.18.08.57.37;	author aamine;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.17.18.39.43;	author aamine;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.05.08.53.06;	author aamine;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.25.09.22.55;	author aamine;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.22.07.29.53;	author aamine;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.18.09.39.02;	author aamine;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.14.10.41.35;	author aamine;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.31.13.02.40;	author aamine;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.27.15.52.27;	author aamine;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.26.16.29.02;	author aamine;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.26.08.48.15;	author aamine;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.08.10.40.11;	author aamine;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.03.05.10.25.53;	author aamine;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.21.15.27.49;	author aamine;	state Exp;
branches;
next	;

1.3.2.1
date	2000.03.15.13.30.55;	author aamine;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2000.03.23.21.56.16;	author aamine;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2000.03.26.08.45.01;	author aamine;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2000.03.26.16.35.03;	author aamine;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2000.03.27.15.52.56;	author aamine;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2000.03.31.13.03.16;	author aamine;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2000.04.14.10.42.57;	author aamine;	state Exp;
branches;
next	1.3.2.8;

1.3.2.8
date	2000.04.18.09.39.41;	author aamine;	state Exp;
branches;
next	1.3.2.9;

1.3.2.9
date	2000.04.22.07.30.29;	author aamine;	state Exp;
branches;
next	1.3.2.10;

1.3.2.10
date	2000.04.25.09.23.21;	author aamine;	state Exp;
branches;
next	1.3.2.11;

1.3.2.11
date	2000.05.05.08.53.37;	author aamine;	state Exp;
branches;
next	1.3.2.12;

1.3.2.12
date	2000.05.17.18.37.28;	author aamine;	state Exp;
branches;
next	1.3.2.13;

1.3.2.13
date	2000.05.18.08.56.59;	author aamine;	state Exp;
branches;
next	1.3.2.14;

1.3.2.14
date	2000.05.22.13.39.01;	author aamine;	state Exp;
branches;
next	1.3.2.15;

1.3.2.15
date	2000.06.01.13.41.36;	author aamine;	state Exp;
branches;
next	1.3.2.16;

1.3.2.16
date	2000.06.09.07.52.24;	author aamine;	state Exp;
branches;
next	1.3.2.17;

1.3.2.17
date	2000.06.12.15.45.21;	author aamine;	state Exp;
branches;
next	1.3.2.18;

1.3.2.18
date	2000.06.12.16.42.24;	author aamine;	state Exp;
branches;
next	1.3.2.19;

1.3.2.19
date	2000.06.16.13.44.04;	author aamine;	state Exp;
branches;
next	1.3.2.20;

1.3.2.20
date	2000.06.27.13.35.46;	author aamine;	state Exp;
branches;
next	1.3.2.21;

1.3.2.21
date	2000.07.01.18.27.35;	author aamine;	state Exp;
branches;
next	1.3.2.22;

1.3.2.22
date	2000.07.03.09.19.45;	author aamine;	state Exp;
branches;
next	;

1.37.2.1
date	2001.01.13.17.46.45;	author aamine;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2001.01.16.07.56.06;	author aamine;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2001.02.06.11.57.09;	author aamine;	state Exp;
branches;
next	1.37.2.4;

1.37.2.4
date	2001.02.13.07.55.16;	author aamine;	state Exp;
branches;
next	1.37.2.5;

1.37.2.5
date	2001.02.22.23.19.50;	author aamine;	state Exp;
branches;
next	1.37.2.6;

1.37.2.6
date	2001.02.23.04.22.04;	author aamine;	state Exp;
branches;
next	1.37.2.7;

1.37.2.7
date	2001.02.24.06.38.35;	author aamine;	state Exp;
branches;
next	1.37.2.8;

1.37.2.8
date	2001.03.08.08.38.20;	author aamine;	state Exp;
branches;
next	1.37.2.9;

1.37.2.9
date	2001.03.13.05.55.31;	author aamine;	state Exp;
branches;
next	1.37.2.10;

1.37.2.10
date	2001.06.26.23.49.02;	author aamine;	state Exp;
branches;
next	1.37.2.11;

1.37.2.11
date	2001.07.08.07.01.21;	author aamine;	state Exp;
branches;
next	1.37.2.12;

1.37.2.12
date	2001.07.13.21.20.41;	author aamine;	state Exp;
branches;
next	1.37.2.13;

1.37.2.13
date	2001.12.07.09.40.16;	author aamine;	state Exp;
branches;
next	1.37.2.14;

1.37.2.14
date	2001.12.07.10.12.52;	author aamine;	state Exp;
branches;
next	1.37.2.15;

1.37.2.15
date	2001.12.09.08.58.06;	author aamine;	state Exp;
branches;
next	1.37.2.16;

1.37.2.16
date	2002.01.15.03.34.59;	author aamine;	state Exp;
branches;
next	1.37.2.17;

1.37.2.17
date	2002.02.07.20.29.58;	author aamine;	state Exp;
branches;
next	1.37.2.18;

1.37.2.18
date	2002.02.19.13.40.22;	author aamine;	state Exp;
branches;
next	1.37.2.19;

1.37.2.19
date	2002.02.22.12.50.22;	author aamine;	state Exp;
branches;
next	1.37.2.20;

1.37.2.20
date	2002.03.22.05.34.59;	author aamine;	state Exp;
branches;
next	;


desc
@@


1.64
log
@use Object#class instead of deprecated Object#type.
@
text
@=begin

= net/protocol.rb

Copyright (c) 1999-2002 Yukihiro Matsumoto

written & maintained by Minero Aoki <aamine@@loveruby.net>

This program is free software. You can re-distribute and/or
modify this program under the same terms as Ruby itself,
Ruby Distribute License or GNU General Public License.

NOTE: You can find Japanese version of this document in
the doc/net directory of the standard ruby interpreter package.

$Id: protocol.rb,v 1.63 2002/07/11 08:22:16 matz Exp $

=end

require 'socket'
require 'timeout'


module Net

  class Protocol

    Version = '1.2.3'
    Revision = %q$Revision: 1.63 $.split(/\s+/)[1]


    class << self

      def port
        default_port
      end

      private

      def protocol_param( name, val )
        module_eval <<-End, __FILE__, __LINE__ + 1
            def self.#{name.id2name}
              #{val}
            end
        End
      end
        
    end


    #
    # --- Configuration Staffs for Sub Classes ---
    #
    #   class method default_port
    #   class method command_type
    #   class method socket_type
    #
    #   private method do_start
    #   private method do_finish
    #
    #   private method conn_address
    #   private method conn_port
    #


    def Protocol.start( address, port = nil, *args )
      instance = new(address, port)

      if block_given? then
        instance.start(*args) { return yield(instance) }
      else
        instance.start(*args)
        instance
      end
    end

    def initialize( addr, port = nil )
      @@address = addr
      @@port    = port || self.class.default_port

      @@command = nil
      @@socket  = nil

      @@started = false

      @@open_timeout = 30
      @@read_timeout = 60

      @@debug_output = nil
    end

    attr_reader :address
    attr_reader :port

    attr_reader :command
    attr_reader :socket

    attr_accessor :open_timeout

    attr_reader :read_timeout

    def read_timeout=( sec )
      @@socket.read_timeout = sec if @@socket
      @@read_timeout = sec
    end

    def started?
      @@started
    end

    alias active? started?

    def set_debug_output( arg )   # un-documented
      @@debug_output = arg
    end

    def inspect
      "#<#{self.class} #{@@address}:#{@@port} open=#{active?}>"
    end

    #
    # open
    #

    def start( *args )
      @@started and raise IOError, 'protocol has been opened already'

      if block_given? then
        begin
          do_start( *args )
          @@started = true
          return yield(self)
        ensure
          finish if @@started
        end
      end

      do_start( *args )
      @@started = true
      self
    end

    private

    # abstract do_start()

    def conn_socket
      @@socket = self.class.socket_type.open(
              conn_address(), conn_port(),
              @@open_timeout, @@read_timeout, @@debug_output )
      on_connect
    end

    alias conn_address address
    alias conn_port    port

    def reconn_socket
      @@socket.reopen @@open_timeout
      on_connect
    end

    def conn_command
      @@command = self.class.command_type.new(@@socket)
    end

    def on_connect
    end

    #
    # close
    #

    public

    def finish
      @@started or raise IOError, 'closing already closed protocol'
      do_finish
      @@started = false
      nil
    end

    private

    # abstract do_finish()

    def disconn_command
      @@command.quit if @@command and not @@command.critical?
      @@command = nil
    end

    def disconn_socket
      if @@socket and not @@socket.closed? then
        @@socket.close
      end
      @@socket = nil
    end
    
  end

  Session = Protocol


  class Response

    def initialize( ctype, code, msg )
      @@code_type = ctype
      @@code      = code
      @@message   = msg
      super()
    end

    attr_reader :code_type
    attr_reader :code
    attr_reader :message
    alias msg message

    def inspect
      "#<#{self.class} #{@@code}>"
    end

    def error!
      raise error_type().new(code + ' ' + @@message.dump, self)
    end

    def error_type
      @@code_type.error_type
    end

  end


  class ProtocolError          < StandardError; end
  class ProtoSyntaxError       < ProtocolError; end
  class ProtoFatalError        < ProtocolError; end
  class ProtoUnknownError      < ProtocolError; end
  class ProtoServerError       < ProtocolError; end
  class ProtoAuthError         < ProtocolError; end
  class ProtoCommandError      < ProtocolError; end
  class ProtoRetriableError    < ProtocolError; end
  ProtocRetryError = ProtoRetriableError

  class ProtocolError
  
    def initialize( msg, resp )
      super msg
      @@response = resp
    end

    attr_reader :response
    alias data response

    def inspect
      "#<#{self.class} #{self.message}>"
    end
  
  end


  class Code

    def initialize( paren, err )
      @@parents = [self] + paren
      @@error_type = err
    end

    def parents
      @@parents.dup
    end

    attr_reader :error_type

    def inspect
      "#<#{self.class} #{sprintf '0x%x', __id__}>"
    end

    def ===( response )
      response.code_type.parents.each {|c| c == self and return true }
      false
    end

    def mkchild( err = nil )
      self.class.new(@@parents, err || @@error_type)
    end
  
  end
  
  ReplyCode       = Code.new( [], ProtoUnknownError )
  InformationCode = ReplyCode.mkchild( ProtoUnknownError )
  SuccessCode     = ReplyCode.mkchild( ProtoUnknownError )
  ContinueCode    = ReplyCode.mkchild( ProtoUnknownError )
  ErrorCode       = ReplyCode.mkchild( ProtocolError )
  SyntaxErrorCode = ErrorCode.mkchild( ProtoSyntaxError )
  FatalErrorCode  = ErrorCode.mkchild( ProtoFatalError )
  ServerErrorCode = ErrorCode.mkchild( ProtoServerError )
  AuthErrorCode   = ErrorCode.mkchild( ProtoAuthError )
  RetriableCode   = ReplyCode.mkchild( ProtoRetriableError )
  UnknownCode     = ReplyCode.mkchild( ProtoUnknownError )


  class Command

    def initialize( sock )
      @@socket = sock
      @@last_reply = nil
      @@atomic = false
    end

    attr_accessor :socket
    attr_reader :last_reply

    def inspect
      "#<#{self.class} socket=#{@@socket.inspect} critical=#{@@atomic}>"
    end

    # abstract quit()

    private

    def check_reply( *oks )
      @@last_reply = get_reply()
      reply_must @@last_reply, *oks
    end

    # abstract get_reply()

    def reply_must( rep, *oks )
      oks.each do |i|
        return rep if i === rep
      end
      rep.error!
    end

    def getok( line, expect = SuccessCode )
      @@socket.writeline line
      check_reply expect
    end

    #
    # critical session
    #

    public

    def critical?
      @@atomic
    end

    def error_ok
      @@atomic = false
    end

    private

    def atomic
      @@atomic = true
      ret = yield
      @@atomic = false
      ret
    end

  end


  class InternetMessageIO

    class << self
      alias open new
    end

    def initialize( addr, port, otime = nil, rtime = nil, dout = nil )
      @@address      = addr
      @@port         = port
      @@read_timeout = rtime
      @@debug_output = dout

      @@socket  = nil
      @@rbuf    = nil

      connect otime
      D 'opened'
    end

    attr_reader :address
    attr_reader :port

    def ip_address
      @@socket or return ''
      @@socket.addr[3]
    end

    attr_accessor :read_timeout

    attr_reader :socket

    def connect( otime )
      D "opening connection to #{@@address}..."
      timeout( otime ) {
          @@socket = TCPSocket.new( @@address, @@port )
      }
      @@rbuf = ''
    end
    private :connect

    def close
      if @@socket then
        @@socket.close
        D 'closed'
      else
        D 'close call for already closed socket'
      end
      @@socket = nil
      @@rbuf = ''
    end

    def reopen( otime = nil )
      D 'reopening...'
      close
      connect otime
      D 'reopened'
    end

    def closed?
      not @@socket
    end

    def inspect
      "#<#{self.class} #{closed? ? 'closed' : 'opened'}>"
    end

    ###
    ###  READ
    ###

    public

    def read( len, dest = '', ignore = false )
      D_off "reading #{len} bytes..."

      rsize = 0
      begin
        while rsize + @@rbuf.size < len do
          rsize += rbuf_moveto(dest, @@rbuf.size)
          rbuf_fill
        end
        rbuf_moveto dest, len - rsize
      rescue EOFError
        raise unless ignore
      end

      D_on "read #{len} bytes"
      dest
    end

    def read_all( dest = '' )
      D_off 'reading all...'

      rsize = 0
      begin
        while true do
          rsize += rbuf_moveto(dest, @@rbuf.size)
          rbuf_fill
        end
      rescue EOFError
        ;
      end

      D_on "read #{rsize} bytes"
      dest
    end

    def readuntil( target, ignore = false )
      dest = ''
      begin
        while true do
          idx = @@rbuf.index(target)
          break if idx
          rbuf_fill
        end
        rbuf_moveto dest, idx + target.size
      rescue EOFError
        raise unless ignore
        rbuf_moveto dest, @@rbuf.size
      end
      dest
    end
        
    def readline
      ret = readuntil("\n")
      ret.chop!
      ret
    end

    private

    BLOCK_SIZE = 1024

    def rbuf_fill
      until IO.select [@@socket], nil, nil, @@read_timeout do
        on_read_timeout
      end
      @@rbuf << @@socket.sysread(BLOCK_SIZE)
    end

    def on_read_timeout
      raise TimeoutError, "socket read timeout (#{@@read_timeout} sec)"
    end

    def rbuf_moveto( dest, len )
      dest << (s = @@rbuf.slice!(0, len))
      @@debug_output << %Q[-> #{s.dump}\n] if @@debug_output
      len
    end

    #
    # message read
    #

    public

    def read_message_to( dest )
      D_off 'reading text...'

      rsize = 0
      while (str = readuntil("\r\n")) != ".\r\n" do
        rsize += str.size
        dest << str.sub(/\A\./, '')
      end

      D_on "read #{rsize} bytes"
      dest
    end
  
    # private use only (cannot handle 'break')
    def each_list_item
      while (str = readuntil("\r\n")) != ".\r\n" do
        yield str.chop
      end
    end


    ###
    ###  WRITE
    ###

    #
    # basic write
    #

    public

    def write( str )
      writing {
          do_write str
      }
    end

    def writeline( str )
      writing {
          do_write str + "\r\n"
      }
    end

    private

    def writing
      @@writtensize = 0
      @@debug_output << '<- ' if @@debug_output
      yield
      @@socket.flush
      @@debug_output << "\n" if @@debug_output
      @@writtensize
    end

    def do_write( str )
      @@debug_output << str.dump if @@debug_output
      @@writtensize += (n = @@socket.write(str))
      n
    end

    #
    # message write
    #

    public

    def write_message( src )
      D_off "writing text from #{src.class}"

      wsize = using_each_crlf_line {
          wpend_in src
      }

      D_on "wrote #{wsize} bytes text"
      wsize
    end

    def through_message
      D_off 'writing text from block'

      wsize = using_each_crlf_line {
          yield WriteAdapter.new(self, :wpend_in)
      }

      D_on "wrote #{wsize} bytes text"
      wsize
    end

    private

    def wpend_in( src )
      line = nil
      pre = @@writtensize
      each_crlf_line( src ) do |line|
        do_write '.' if line[0] == ?.
        do_write line
      end

      @@writtensize - pre
    end

    def using_each_crlf_line
      writing {
          @@wbuf = ''

          yield

          if not @@wbuf.empty? then       # unterminated last line
            if @@wbuf[-1] == ?\r then
              @@wbuf.chop!
            end
            @@wbuf.concat "\r\n"
            do_write @@wbuf
          elsif @@writtensize == 0 then   # empty src
            do_write "\r\n"
          end
          do_write ".\r\n"

          @@wbuf = nil
      }
    end

    def each_crlf_line( src )
      str = m = beg = nil

      adding( src ) do
        beg = 0
        buf = @@wbuf
        while buf.index( /\n|\r\n|\r/, beg ) do
          m = Regexp.last_match
          if m.begin(0) == buf.size - 1 and buf[-1] == ?\r then
            # "...\r" : can follow "\n..."
            break
          end
          str = buf[ beg ... m.begin(0) ]
          str.concat "\r\n"
          yield str
          beg = m.end(0)
        end
        @@wbuf = buf[ beg ... buf.size ]
      end
    end

    def adding( src )
      i = nil

      case src
      when String
        0.step( src.size - 1, 2048 ) do |i|
          @@wbuf << src[i,2048]
          yield
        end

      when File
        while true do
          i = src.read(2048)
          break unless i
          i[0,0] = @@wbuf
          @@wbuf = i
          yield
        end

      else
        src.each do |i|
          @@wbuf << i
          if @@wbuf.size > 2048 then
            yield
          end
        end
        yield unless @@wbuf.empty?
      end
    end

    ###
    ### DEBUG
    ###

    private

    def D_off( msg )
      D msg
      @@savedo, @@debug_output = @@debug_output, nil
    end

    def D_on( msg )
      @@debug_output = @@savedo
      D msg
    end

    def D( msg )
      @@debug_output or return
      @@debug_output << msg
      @@debug_output << "\n"
    end
  
  end


  class WriteAdapter

    def initialize( sock, mid )
      @@socket = sock
      @@mid = mid
    end

    def inspect
      "#<#{self.class} socket=#{@@socket.inspect}>"
    end

    def write( str )
      @@socket.__send__ @@mid, str
    end

    alias print write

    def <<( str )
      write str
      self
    end

    def puts( str = '' )
      write str.sub(/\n?/, "\n")
    end

    def printf( *args )
      write sprintf(*args)
    end
  
  end


  class ReadAdapter

    def initialize( block )
      @@block = block
    end

    def inspect
      "#<#{self.class}>"
    end

    def <<( str )
      call_block str, &@@block if @@block
    end

    private

    def call_block( str )
      yield str
    end
  
  end


  # for backward compatibility
  module NetPrivate
    Response = ::Net::Response
    Command = ::Net::Command
    Socket = ::Net::InternetMessageIO
    BufferedSocket = ::Net::InternetMessageIO
    WriteAdapter = ::Net::WriteAdapter
    ReadAdapter = ::Net::ReadAdapter
  end
  BufferedSocket = ::Net::InternetMessageIO

end   # module Net
@


1.63
log
@* string.c (rb_str_slice_bang): if there's no corresponding
  substring, slice! should return nil without exception.

* array.c (rb_ary_insert): type fixed.

* string.c (rb_str_split_m): accept separator value nil as well.

* string.c (rb_str_become): was leaking memory.

* class.c (rb_include_module): should not alter other
  classes/modules by inclusion.  by this fix, local order may not
  be preserved for some cases.

* class.c (include_class_new): module may be T_ICLASS; retrieve
  original module information.
@
text
@d16 1
a16 1
$Id: protocol.rb,v 1.62 2002/03/26 11:18:02 aamine Exp $
d29 1
a29 1
    Revision = %q$Revision: 1.62 $.split(/\s+/)[1]
d427 1
a427 1
      "#<#{type} #{closed? ? 'closed' : 'opened'}>"
d587 1
a587 1
      D_off "writing text from #{src.type}"
d726 1
a726 1
      "#<#{type} socket=#{@@socket.inspect}>"
d758 1
a758 1
      "#<#{type}>"
@


1.62
log
@* lib/net/http.rb: HTTP.get accepts URI.
* lib/net/http.rb: add some HTTP 1.1 response codes.
@
text
@d16 1
a16 1
$Id: header.rd,v 1.3 2002/02/19 12:23:15 aamine Exp $
d29 1
a29 1
    Revision = %q$Revision: 1.45 $.split(/\s+/)[1]
d398 1
a398 1
          @@socket = TCPsocket.new( @@address, @@port )
@


1.61
log
@net/protocol.rb: Protocol#start should return self.
@
text
@d16 1
a16 1
$Id: protocol.rb,v 1.60 2002/02/22 12:10:58 aamine Exp $
d29 1
a29 1
    Revision = %q$Revision: 1.60 $.split(/\s+/)[1]
d79 1
a79 1
      @@port    = port || type.default_port
d84 1
a84 1
      @@active = false
d89 1
a89 1
      @@dout = nil
d99 1
d107 2
a108 2
    def active?
      @@active
d111 2
d114 1
a114 1
      @@dout = arg
a116 2
    alias set_pipe set_debug_output

d118 1
a118 1
      "#<#{type} #{address}:#{port} open=#{active?}>"
d126 1
a126 1
      @@active and raise IOError, 'protocol has been opened already'
d131 1
a131 1
          @@active = true
d134 1
a134 1
          finish if @@active
d139 1
a139 1
      @@active = true
d148 1
a148 1
      @@socket = type.socket_type.open(
d150 1
a150 1
              @@open_timeout, @@read_timeout, @@dout )
d163 1
a163 1
      @@command = type.command_type.new(@@socket)
d176 1
a176 1
      active? or raise IOError, 'closing already closed protocol'
d178 1
a178 1
      @@active = false
d212 3
a214 1
    attr_reader :code_type, :code, :message
d218 1
a218 1
      "#<#{type} #{code}>"
d222 5
a226 1
      raise @@code_type.error_type.new( code + ' ' + msg.dump, self )
d253 1
a253 1
      "#<#{type}>"
d263 1
a263 1
      @@err = err
d270 2
d273 1
a273 5
      "#<#{type} #{sprintf '0x%x', __id__}>"
    end

    def error_type
      @@err
d277 1
a277 1
      response.code_type.parents.each {|c| return true if c == self }
d282 1
a282 1
      type.new( @@parents, err || @@err )
d312 1
a312 1
      "#<#{type}>"
d339 1
a339 1
    # error handle
d374 1
a374 1
      @@debugout = dout
d510 1
a510 1
      @@debugout << %Q[-> #{s.dump}\n] if @@debugout
d567 1
a567 1
      @@debugout << '<- ' if @@debugout
d570 1
a570 1
      @@debugout << "\n" if @@debugout
d575 1
a575 1
      @@debugout << str.dump if @@debugout
d701 1
a701 1
      @@savedo, @@debugout = @@debugout, nil
d705 1
a705 1
      @@debugout = @@savedo
d710 3
a712 3
      @@debugout or return
      @@debugout << msg
      @@debugout << "\n"
@


1.60
log
@* lib/net/protocol.rb: set read_timeout dynamically.
* lib/net/http.rb: @@@@newimpl is always true in the main trunk.
* lib/net/http.rb: HTTP.port -> default_port
* lib/net/http.rb: HTTPResponse.read_response_status -> read_status_line
@
text
@d16 1
a16 1
$Id: header.rd,v 1.3 2002/02/19 12:23:15 aamine Exp $
d29 1
a29 1
    Revision = %q$Revision: 1.44 $.split(/\s+/)[1]
d139 1
a139 1
      nil
@


1.59
log
@aamine
* lib/net/protocol.rb: rename Protocol.port to default_port.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
* lib/net/protocol.rb: rename BufferedSocket class to InternetMessageIO.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#write_pendstr to write_message.
* lib/net/smtp.rb: ditto.
* lib/net/protocol.rb: new method InternetMessageIO#through_message.
* lib/net/smtp.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#read_pendstr to read_message_to.
* lib/net/pop.rb: ditto.
* lib/net/protocol.rb: rename InternetMessageIO#read_pendlist to each_list_item
* lib/net/pop.rb: ditto.
* lib/net/protocol.rb: Now block size is 1024.
* lib/net/smtp.rb: new methods SMTP#esmtp? and #esmtp=.
* lib/net/http.rb: Using singleton method syntax instead of singleton class clause, to avoid behavior change of class variables in ruby 1.7.
* lib/net/http.rb: HTTPResponse class does not inherit from Net::Response.
* lib/net/http.rb: devide HTTP#connecting into {begin,end}_transport.
* lib/net/http.rb: unused class Accumulator removed.
* lib/net/http.rb: Net::HTTP reads response. not HTTPRequest.
* lib/net/http.rb: proxy related class-instance-variables are not initialized correctly.
@
text
@d29 1
a29 1
    Revision = %q$Revision: 1.42 $.split(/\s+/)[1]
d99 6
a104 1
    attr_accessor :read_timeout
d385 2
@


1.58
log
@aamine
* lib/net/http.rb: HTTP.Proxy should use self for proxy-class's super class.
* lib/net/http.rb: initialize HTTP.proxy_port by HTTP.port.
@
text
@d5 1
a5 1
Copyright (c) 1999-2001 Yukihiro Matsumoto
d16 1
a16 1
$Id: header.rd,v 1.2 2001/12/10 12:37:16 aamine Exp $
d29 1
a29 1
    Revision = %q$Revision: 1.41 $.split(/\s+/)[1]
d34 4
d54 3
a56 3
    #   protocol_param port
    #   protocol_param command_type
    #   protocol_param socket_type   (optional)
a64 4
    protocol_param :port,         'nil'
    protocol_param :command_type, 'nil'
    protocol_param :socket_type,  '::Net::BufferedSocket'

d67 1
a67 1
      instance = new( address, port )
d70 1
a70 3
        ret = nil
        instance.start( *args ) { ret = yield(instance) }
        ret
d72 1
a72 1
        instance.start( *args )
d79 1
a79 1
      @@port    = port || type.port
d237 1
a237 1
    attr :response
a289 58

  class WriteAdapter

    def initialize( sock, mid )
      @@socket = sock
      @@mid = mid
    end

    def inspect
      "#<#{type} socket=#{@@socket.inspect}>"
    end

    def <<( str )
      @@socket.__send__ @@mid, str
      self
    end

    def write( str )
      @@socket.__send__ @@mid, str
    end

    alias print write

    def puts( str = '' )
      @@socket.__send__ @@mid, str.sub(/\n?/, "\n")
    end

    def printf( *args )
      @@socket.__send__ @@mid, sprintf(*args)
    end
  
  end


  class ReadAdapter

    def initialize( block )
      @@block = block
    end

    def inspect
      "#<#{type}>"
    end

    def <<( str )
      call_block str, &@@block if @@block
    end

    private

    def call_block( str )
      yield str
    end
  
  end



a350 14
    def begin_atomic
      ret = @@atomic
      @@atomic = true
      not ret
    end

    def end_atomic
      @@atomic = false
    end

    alias critical       atomic
    alias begin_critical begin_atomic
    alias end_critical   end_atomic

d354 1
a354 2

  class BufferedSocket
a421 4
    #
    # basic reader
    #

d481 21
d503 1
a503 1
    # line oriented reader
d508 1
a508 1
    def read_pendstr( dest )
d514 1
a514 2
        str.gsub!( /\A\./, '' )
        dest << str
d521 2
a522 6
    # private use only (can not handle 'break')
    def read_pendlist
    #  D_off 'reading list...'

      str = nil
      i = 0
d524 1
a524 3
        i += 1
        str.chop!
        yield str
a525 27

    #  D_on "read #{i} items"
    end

    #
    # lib (reader)
    #

    private

    BLOCK_SIZE = 1024 * 2

    def rbuf_fill
      until IO.select [@@socket], nil, nil, @@read_timeout do
        on_read_timeout
      end
      @@rbuf << @@socket.sysread(BLOCK_SIZE)
    end

    def on_read_timeout
      raise TimeoutError, "socket read timeout (#{@@read_timeout} sec)"
    end

    def rbuf_moveto( dest, len )
      dest << (s = @@rbuf.slice!(0, len))
      @@debugout << %Q[-> #{s.dump}\n] if @@debugout
      len
d534 1
a534 1
    # basic writer
d551 15
a565 10
    def write_bin( src, block )
      writing {
          if block then
            block.call WriteAdapter.new(self, :do_write)
          else
            src.each do |bin|
              do_write bin
            end
          end
      }
d569 1
a569 1
    # line oriented writer
d574 1
a574 1
    def write_pendstr( src, &block )
d578 12
a589 5
          if block_given? then
            yield WriteAdapter.new(self, :wpend_in)
          else
            wpend_in src
          end
a680 21
    #
    # lib (writer)
    #

    private

    def writing
      @@writtensize = 0
      @@debugout << '<- ' if @@debugout
      yield
      @@socket.flush
      @@debugout << "\n" if @@debugout
      @@writtensize
    end

    def do_write( str )
      @@debugout << str.dump if @@debugout
      @@writtensize += (n = @@socket.write(str))
      n
    end

d702 42
d745 14
d764 6
a769 5
    Response       = ::Net::Response
    WriteAdapter   = ::Net::WriteAdapter
    ReadAdapter    = ::Net::ReadAdapter
    Command        = ::Net::Command
    Socket         = ::Net::BufferedSocket
d771 1
@


1.57
log
@aamine
* lib/net/protocol.rb: Protocol#start returns the return value of block.
* lib/net/protocol.rb: set timeout limit by default.
* lib/net/protocol.rb: new methods WriteAdapter#write, puts, print, printf.
* lib/net/http.rb: rename HTTP#get2 to request_get, post2 to request_post ...
* lib/net/smtp.rb: should not resolve HELO domain automatically.
@
text
@d29 1
a29 1
    Revision = %q$Revision: 1.40 $.split(/\s+/)[1]
d604 1
a604 1
      unless IO.select [@@socket], nil, nil, @@read_timeout then
@


1.56
log
@aamine
* lib/net/protocol.rb: rename Net::Socket to Net::BufferedSocket
@
text
@d29 2
a30 1
    Revision = %q$Revision: 1.36 $.split(/\s+/)[1]
a33 11
      def start( address, port = nil, *args )
        instance = new( address, port )

        if block_given? then
          instance.start( *args ) { yield instance }
        else
          instance.start( *args )
          instance
        end
      end

d37 5
a41 5
        module_eval %-
          def self.#{name.id2name}
            #{val}
          end
        -
d54 2
a55 2
    #   private method do_start      (optional)
    #   private method do_finish     (optional)
d57 2
a58 2
    #   private method on_connect    (optional)
    #   private method on_disconnect (optional)
d66 13
d88 2
a89 2
      @@open_timeout = nil
      @@read_timeout = nil
d118 1
a118 1
    # open session
d122 1
a122 1
      active? and raise IOError, 'protocol has been opened already'
d126 3
a128 2
          _start args
          yield self
d130 1
a130 1
          finish if active?
a131 2
      else
        _start args
d133 3
d141 1
a141 5
    def _start( args )
      connect
      do_start( *args )
      @@active = true
    end
d143 4
a146 2
    def connect
      conn_socket @@address, @@port
a147 1
      conn_command @@socket
d150 4
a153 1
    def re_connect
d158 2
a159 7
    def conn_socket( addr, port )
      @@socket = type.socket_type.open(
              addr, port, @@open_timeout, @@read_timeout, @@dout )
    end

    def conn_command( sock )
      @@command = type.command_type.new( sock )
a164 3
    def do_start
    end

d166 1
a166 1
    # close session
d172 2
a173 4
      active? or raise IOError, 'already closed protocol'

      do_finish if @@command and not @@command.critical?
      disconnect
d180 5
a184 2
    def do_finish
      @@command.quit
d187 1
a187 2
    def disconnect
      @@command = nil
a191 4
      on_disconnect
    end

    def on_disconnect
d216 1
a216 1
      raise @@code_type.error_type.new( code + ' ' + Net.quote(msg), self )
d301 6
a306 1
      "#<#{type}>"
d313 8
a320 3
    def <<( str )
      @@socket.__send__ @@mid, str
      self
d325 1
d337 1
a337 1
      callblock( str, &@@block ) if @@block
d342 2
a343 14
    def callblock( str )
      begin
        user_break = true
        yield str
        user_break = false
      rescue Exception
        user_break = false
        raise
      ensure
        if user_break then
          @@block = nil
          return   # stop breaking
        end
      end
d355 1
a355 1
      @@critical = false
d365 1
a365 2
    # abstract quit

a368 2
    # abstract get_reply()

d370 2
a371 2
      @@last_reply = get_reply
      reply_must( @@last_reply, *oks )
d374 2
d378 1
a378 3
        if i === rep then
          return rep
        end
a387 1

d395 1
a395 1
      @@critical
d399 1
a399 1
      @@critical = false
a401 1

d404 2
a405 2
    def critical
      @@critical = true
d407 1
a407 1
      @@critical = false
d411 3
a413 3
    def begin_critical
      ret = @@critical
      @@critical = true
d417 2
a418 2
    def end_critical
      @@critical = false
d421 4
d428 1
d431 4
d436 2
a437 3
      @@addr = addr
      @@port = port

a438 1

d441 2
a442 3
      @@socket = nil
      @@sending = ''
      @@rbuf  = ''
d448 10
d459 1
a459 1
      D "opening connection to #{@@addr}..."
d461 1
a461 1
        @@socket = TCPsocket.new( @@addr, @@port )
d463 1
a466 19
    attr :pipe, true

    class << self
      alias open new
    end

    def inspect
      "#<#{type} #{closed? ? 'closed' : 'opened'}>"
    end

    def reopen( otime = nil )
      D 'reopening...'
      close
      connect otime
      D 'reopened'
    end

    attr :socket, true

d478 7
d489 2
a490 2
    def address
      @@addr.dup
d493 3
a495 13
    alias addr address

    attr_reader :port

    def ip_address
      @@socket or return ''
      @@socket.addr[3]
    end

    alias ipaddr ip_address

    attr_reader :sending

d498 1
a498 1
    # input
d503 1
a503 3
    CRLF = "\r\n"

    def read( len, dest = '', igneof = false )
d509 1
a509 1
          rsize += rbuf_moveto( dest, @@rbuf.size )
d514 1
a514 1
        raise unless igneof
d527 1
a527 1
          rsize += rbuf_moveto( dest, @@rbuf.size )
d538 1
a538 1
    def readuntil( target, igneof = false )
d542 1
a542 1
          idx = @@rbuf.index( target )
d548 1
a548 1
        raise unless igneof
d555 1
a555 1
      ret = readuntil( "\n" )
d560 6
d579 1
a579 1

d595 4
d616 1
a616 1
      @@debugout << %Q<read  "#{Net.quote s}"\n> if @@debugout
d621 4
d626 1
a626 1
    # output
d633 1
a633 1
        do_write str
d639 1
a639 1
        do_write str + "\r\n"
d645 6
a650 5
        if block then
          block.call WriteAdapter.new(self, :do_write)
        else
          src.each do |bin|
            do_write bin
a651 1
        end
d655 7
a661 1
    def write_pendstr( src, block )
d665 5
a669 5
        if block then
          block.call WriteAdapter.new(self, :wpend_in)
        else
          wpend_in src
        end
d691 1
a691 1
        @@wbuf = ''
d693 1
a693 1
        yield
d695 8
a702 3
        if not @@wbuf.empty? then       # unterminated last line
          if @@wbuf[-1] == ?\r then
            @@wbuf.chop!
d704 1
a704 6
          @@wbuf.concat "\r\n"
          do_write @@wbuf
        elsif @@writtensize == 0 then   # empty src
          do_write "\r\n"
        end
        do_write ".\r\n"
d706 1
a706 1
        @@wbuf = nil
d761 5
d769 1
a769 2
      @@sending = ''

a770 6

      if @@debugout then
        @@debugout << 'write "'
        @@debugout << @@sending
        @@debugout << "\"\n"
      end
d772 1
d776 4
a779 10
    def do_write( arg )
      if @@debugout or @@sending.size < 128 then
        @@sending << Net.quote( arg )
      else
        @@sending << '...' unless @@sending[-1] == ?.
      end

      s = @@socket.write( arg )
      @@writtensize += s
      s
d782 5
a803 8
  end


  def Net.quote( str )
    str = str.gsub( "\n", '\\n' )
    str.gsub!( "\r", '\\r' )
    str.gsub!( "\t", '\\t' )
    str
@


1.55
log
@aamine
* lib/net/pop.rb: new method Net::POP3.APOP
* lib/net/http.rb: set default Content-Type to x-www-form-urlencoded (causes warning)
* lib/net/protocol.rb: remove Net::NetPrivate module.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@d29 1
a29 1
    Revision = %q$Revision: 1.35 $.split(/\s+/)[1]
d73 1
a73 1
    protocol_param :socket_type,  '::Net::Socket'
d437 1
a437 1
  class Socket
d743 1
a743 1
          i = src.read( 2048 )
d823 1
a823 1
    Socket         = ::Net::Socket
@


1.54
log
@aamine
* lib/net/protocol.rb: calls on_connect before conn_command
@
text
@d3 1
a3 1
= net/protocol.rb version 1.2.3
d16 2
a25 8
  module NetPrivate
  end

  def self.net_private( &block )
    ::Net::NetPrivate.module_eval( &block )
  end


d29 1
d73 1
a73 1
    protocol_param :socket_type,  '::Net::NetPrivate::Socket'
a205 2
  net_private {

d223 1
a223 1
      raise code_type.error_type.new( code + ' ' + Net.quote(msg), self )
a227 2
  }

d259 1
a259 1
      @@parents = paren
d261 1
d263 2
a264 1
      @@parents.push self
a266 2
    attr_reader :parents

d268 1
a268 1
      "#<#{type}>"
d276 1
a276 1
      response.code_type.parents.reverse_each {|i| return true if i == self }
d281 1
a281 1
      type.new( @@parents + [self], err || @@err )
a299 2
  net_private {

d303 1
a303 1
      @@sock = sock
d312 1
a312 1
      @@sock.__send__ @@mid, str
d316 1
a316 1
      @@sock.__send__ @@mid, str
d349 1
a349 1
          return   # stop break
d449 1
a449 1
      @@buffer  = ''
d490 1
a490 1
      @@buffer = ''
d516 1
a516 1
    # read
d528 2
a529 2
        while rsize + @@buffer.size < len do
          rsize += rbuf_moveto( dest, @@buffer.size )
d547 1
a547 1
          rsize += rbuf_moveto( dest, @@buffer.size )
d562 1
a562 1
          idx = @@buffer.index( target )
d569 1
a569 1
        rbuf_moveto dest, @@buffer.size
a608 1

d611 1
a611 2

    READ_SIZE = 1024 * 4
d617 1
a617 1
      @@buffer << @@socket.sysread( READ_SIZE )
d625 2
a626 6
      bsi = @@buffer.size
      s = @@buffer[ 0, len ]
      dest << s
      @@buffer = @@buffer[ len, bsi - len ]

      @@debugout << %<read  "#{Net.quote s}"\n> if @@debugout
d632 1
a632 1
    # write interfece
d652 1
a652 1
          block.call ::Net::NetPrivate::WriteAdapter.new( self, :do_write )
d664 1
a664 1
      wsize = use_each_crlf_line {
d666 1
a666 1
          block.call ::Net::NetPrivate::WriteAdapter.new( self, :wpend_in )
a675 1

a677 1

d689 1
a689 1
    def use_each_crlf_line
d695 1
a695 1
        if not @@wbuf.empty? then       # un-terminated last line
a807 2
  }

d814 10
@


1.53
log
@aamine
* lib/net/smtp.rb: SMTP.new requires at least one arg.
* lib/net/pop.rb: POP.new requires at least one arg.
* lib/net/pop.rb: uses "raise *Error.new" instead of simple raise.
* lib/net/http.rb: HTTP.new requires at least one arg.
* lib/net/http.rb: changes implicit start algolithm.
@
text
@d149 1
a150 1
      on_connect
@


1.52
log
@aamine
* lib/net/protocol.rb: Protocol.new requires at least one arg.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@d13 2
a14 3
NOTE: You can get Japanese version of this document from
Ruby Documentation Project (RDP):
((<URL:http://www.ruby-lang.org/~rubikitch/RDP.cgi>))
d82 1
a82 1
      @@address = addr || 'localhost'
d215 1
a215 1
    def initialize( ctype, cno, msg )
d217 1
a217 1
      @@code      = cno
@


1.51
log
@aamine
* lib/net/http.rb: HTTP#proxy? did not worked.
@
text
@d39 1
a39 1
      def start( address = 'localhost', port = nil, *args )
d82 1
a82 1
    def initialize( addr = nil, port = nil )
@


1.50
log
@aamine
* lib/net/http.rb: rename HTTP#request_by_name to send_request.
* lib/net/protocol.rb (ProtoSocket#read): modify typo.
@
text
@d132 1
a132 1
          finish
@


1.49
log
@aamine
* lib/net/http.rb (HTTP#request_by_name): bug fix.
* lib/net/http.rb: does not write Connection: by default.
* lib/net/protocol.rb: "start" for started protocol is an error.
* lib/net/protocol.rb: "finish" for finished protocol is an error.
@
text
@d3 1
a3 1
= net/protocol.rb version 1.2.2
d35 1
a35 1
    Version = '1.2.2'
d535 1
a535 1
    def read( len, dest = '', ignerr = false )
@


1.48
log
@aamine
* lib/net/http.rb: new method HTTP#request_by_name (test)
* lib/net/http.rb: new class HTTPGenericRequest
@
text
@d125 1
a125 1
      return false if active?
d137 1
d181 1
a181 1
      return false unless active?
d186 1
a186 1
      true
@


1.47
log
@aamine
* lib/net/pop.rb: new methods POP3.auth_only, POP3#auth_only
* lib/net/http.rb: HTTP.Proxy returns self if ADDRESS is nil.
* lib/net/protocol.rb: new method ProtocolError#response
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: add document.
@
text
@d3 1
a3 1
= net/protocol.rb version 1.2.1
d35 1
a35 1
    Version = '1.2.1'
@


1.46
log
@aamine
* lib/net/http.rb: add HTTPRequest#basic_auth.
* lib/net/smtp.rb: raise if only account or password is given.
* lib/net/protocol.rb: WriteAdapter#<< returns self.
@
text
@d3 1
a3 1
= net/protocol.rb version 1.2.0
d5 1
a5 1
  Copyright (C) 1999-2001 Yukihiro Matsumoto
d7 1
a7 1
  written & maintained by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d9 3
a11 3
  This program is free software. You can re-distribute and/or
  modify this program under the same terms as Ruby itself,
  GNU General Public License or Ruby License.
d13 3
a15 47
  Japanese version of this document is in "net" full package.
  You can get it from RAA (Ruby Application Archive). RAA is:
  http://www.ruby-lang.org/en/raa.html


== Net::Protocol

the abstract class for some internet protocols

=== Super Class

Object

=== Class Methods

: new( address = 'localhost', port = nil )
  This method Creates a new protocol object.

: start( address = 'localhost', port = nil, *protoargs )
: start( address = 'localhost', port = nil, *protoargs ) {|proto| .... }
  This method creates a new Protocol object and opens a session.
  equals to Net::Protocol.new( address, port ).start( *protoargs )

=== Methods

: address
  the address of connecting server (FQDN).

: port
  connecting port number

: start( *args )
: start( *args ) {|proto| .... }
  This method starts protocol. If protocol was already started,
  do nothing and returns false.

  '*args' are specified in subclasses.

  When is called with block, gives Protocol object to block and
  close session when block finished.

: finish
  This method ends protocol. If you call this method before protocol starts,
  it only return false without doing anything.

: active?
  true if session have been started
d35 1
a35 2
    Version = '1.2.0'

d64 5
a68 1
    # sub-class requirements
d70 2
a71 2
    # protocol_param command_type
    # protocol_param port
d73 2
a74 2
    # private method do_start  (optional)
    # private method do_finish (optional)
d229 2
a230 2
    def error!( data = nil )
      raise code_type.error_type.new( code + ' ' + Net.quote(msg), data )
d250 1
a250 1
    def initialize( msg, data = nil )
d252 1
a252 1
      @@data = data
d255 2
a256 1
    attr :data
d607 1
a607 1
      D_off 'reading list...'
d617 1
a617 1
      D_on "read #{i} items"
@


1.45
log
@aamine
* lib/net/protocol.rb: one write(2) per one line.
@
text
@d366 4
a369 1
    alias << write
@


1.44
log
@aamine
* lib/net/http.rb: always close connection on request without body.
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: change copyright.
@
text
@d699 1
a699 2
        do_write str
        do_write "\r\n"
@


1.43
log
@aamine
* lib/net/protocol.rb: clear read buffer after reopen.
* lib/net/protocol.rb: refactoring.
* lib/net/http.rb: split module HTTPHeader from HTTPResponse.
@
text
@d5 1
a5 1
written by Minero Aoki <aamine@@dp.u-netsurf.ne.jp>
d7 1
a7 3
This program is free software.
You can distribute/modify this program under
the terms of the Ruby Distribute License.
d9 7
a15 3
Japanese version of this document is in "net" full package.
You can get it from RAA
(Ruby Application Archive: http://www.ruby-lang.org/en/raa.html).
@


1.42
log
@aamine
* lib/net/http.rb: join HTTPReadResponse into HTTPResponse again.
* lib/net/http.rb: move http_version() from HTTPRequest to HTTPResponse.
* lib/net/protocol.rb: refactoring.
@
text
@d493 1
a493 2
      @@closed  = true
      @@ipaddr  = ''
d497 6
d504 1
a504 1
        @@socket = TCPsocket.new( addr, port )
a505 2
      @@closed = false
      @@ipaddr = @@socket.addr[3]
d507 1
d516 1
a516 1
      "#<#{type} open=#{!@@closed}>"
d520 4
a523 8
      unless closed? then
        close
        @@buffer = ''
      end
      timeout( otime ) {
        @@socket = TCPsocket.new( @@addr, @@port )
      }
      @@closed = false
d529 8
a536 2
      @@socket.close
      @@closed = true
d540 1
a540 1
      @@closed
d552 2
a553 1
      @@ipaddr.dup
d570 1
a570 1
      D_off "reading #{len} bytes...\n"
d583 1
a583 1
      D_on "read #{len} bytes\n"
d588 1
a588 1
      D_off "reading all...\n"
d600 1
a600 1
      D_on "read #{rsize} bytes\n"
d627 1
a627 1
      D_off "reading text...\n"
d636 1
a636 1
      D_on "read #{rsize} bytes\n"
d642 1
a642 1
      D_off "reading list...\n"
d652 1
a652 1
      D_on "read #{i} items\n"
d715 1
a715 1
      D_off "writing text from #{src.type}\n"
d725 1
a725 1
      D_on "wrote #{wsize} bytes text\n"
d772 1
a772 1
          m = $~
d777 1
a777 1
          str = buf[ beg, m.begin(0) - beg ]
d782 1
a782 1
        @@wbuf = buf[ beg, buf.size - beg ]
d846 1
a846 1
      @@debugout << msg if @@debugout
d852 7
a858 2
      @@savedo = nil
      @@debugout << msg if @@debugout
@


1.41
log
@aamine
* lib/net/http.rb: split HTTPResponse into HTTPReadResponse module.
* lib/net/protocol.rb: add Net::net_private.
* lib/net/protocol.rb: Socket#reopen takes arg, open_timeout.
@
text
@d133 1
a133 1
      @@pipe = nil
d149 2
a150 2
    def set_pipe( arg )   # un-documented
      @@pipe = arg
d153 2
d192 5
d199 1
a199 1
              addr, port, @@open_timeout, @@read_timeout, @@pipe )
d485 1
a485 1
    def initialize( addr, port, otime = nil, rtime = nil, pipe = nil )
d491 1
a491 2
      @@pipe = pipe
      @@prepipe = nil
d563 1
a563 1
      @@pipe << "reading #{len} bytes...\n" if @@pipe; pipeoff
d568 2
a569 2
          rsize += writeinto( dest, @@buffer.size )
          fill_rbuf
d571 1
a571 1
        writeinto( dest, len - rsize )
d576 1
a576 1
      @@pipe << "read #{len} bytes\n" if pipeon
d581 1
a581 1
      @@pipe << "reading all...\n" if @@pipe; pipeoff
d586 2
a587 2
          rsize += writeinto( dest, @@buffer.size )
          fill_rbuf
d593 1
a593 1
      @@pipe << "read #{rsize} bytes\n" if pipeon
d603 1
a603 1
          fill_rbuf
d605 1
a605 1
        writeinto( dest, idx + target.size )
d608 1
a608 1
        writeinto( dest, @@buffer.size )
d620 1
a620 1
      @@pipe << "reading text...\n" if @@pipe; pipeoff
d629 1
a629 1
      @@pipe << "read #{rsize} bytes\n" if pipeon
d635 1
a635 1
      @@pipe << "reading list...\n" if @@pipe; pipeoff
d645 1
a645 1
      @@pipe << "read #{i} items\n" if pipeon
d654 1
a654 1
    def fill_rbuf
d665 1
a665 1
    def writeinto( dest, len )
d667 2
a668 1
      dest << @@buffer[ 0, len ]
d671 1
a671 1
      @@pipe << %{read  "#{Net.quote dest}"\n} if @@pipe
d708 1
a708 1
      @@pipe << "writing text from #{src.type}\n" if @@pipe; pipeoff
d718 1
a718 1
      @@pipe << "wrote #{wsize} bytes text\n" if pipeon
d816 4
a819 4
      if @@pipe then
        @@pipe << 'write "'
        @@pipe << @@sending
        @@pipe << "\"\n"
d826 1
a826 1
      if @@pipe or @@sending.size < 128 then
d838 3
a840 4
    def pipeoff
      @@prepipe = @@pipe
      @@pipe = nil
      @@prepipe
d843 4
a846 4
    def pipeon
      @@pipe = @@prepipe
      @@prepipe = nil
      @@pipe
@


1.40
log
@aamine
* lib/net/http.rb: add HTTP#request.
* lib/net/http.rb: take HTTP 1.0 server into account (incomplete).
* lib/net/protocol.rb: timeout for open/read.
* lib/net/protocol.rb: add Protocol#on_connect,on_disconnect.
@
text
@d67 8
d243 1
d267 2
d340 1
a340 2
  module NetPrivate

d509 1
a509 1
    def reopen
d514 3
a516 1
      @@socket = TCPsocket.new( @@addr, @@port )
d691 1
a691 1
          block.call WriteAdapter.new( self, :do_write )
d705 1
a705 1
          block.call WriteAdapter.new( self, :wpend_in )
d845 1
a845 2

  end   # module Net::NetPrivate
@


1.39
log
@aamine
* lib/net/protocol.rb: ignore EOFError for read.
* lib/net/http.rb: user specified header was not used.
@
text
@d18 1
a18 1
the abstract class for Internet protocol
d62 1
d120 6
a125 2
      @@active  = false
      @@pipe    = nil
d134 11
d149 3
d168 2
a174 1
    private :_start
d176 10
a185 2
    def finish
      return false unless active?
d187 2
a188 4
      do_finish unless @@command.critical?
      disconnect
      @@active = false
      true
d191 1
a191 2
    def active?
      @@active
d194 1
a194 2
    def set_pipe( arg )   # un-documented
      @@pipe = arg
d197 3
d201 1
a201 1
    private
d203 2
d206 4
a209 1
    def do_start
d212 2
a217 6

    def connect( addr = @@address, port = @@port )
      @@socket  = type.socket_type.open( addr, port, @@pipe )
      @@command = type.command_type.new( @@socket )
    end

d223 5
a227 1
      @@socket  = nil
d346 1
d443 1
d468 1
a468 1
    def initialize( addr, port, pipe = nil )
d471 3
d482 3
a484 1
      @@socket = TCPsocket.new( addr, port )
d536 5
a540 3
    ###
    ### read
    ###
d544 1
a544 1
    def read( len, dest = '' )
d553 1
d555 1
a555 1
        len = rsize
a556 1
      writeinto( dest, len - rsize )
a561 1

d579 1
a579 2

    def readuntil( target )
d589 1
a593 1

a600 1

a614 1

d634 1
a634 1
    READ_BLOCK = 1024 * 8
d637 8
a644 1
      @@buffer << @@socket.sysread( READ_BLOCK )
d657 3
a659 3
    ###
    ### write
    ###
a662 1

a668 1

a675 1

a686 1

@


1.38
log
@aamine
* lib/net/protocol.rb (adding): too few "yield" in case of arg is not String/File.
* lib/net/http.rb: add http request object.
@
text
@d507 7
a513 3
      while rsize + @@buffer.size < len do
        rsize += writeinto( dest, @@buffer.size )
        fill_rbuf
d541 10
a550 4
      while true do
        idx = @@buffer.index( target )
        break if idx
        fill_rbuf
a551 3

      dest = ''
      writeinto( dest, idx + target.size )
@


1.37
log
@aamine
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: wrongly version 1.2 sources
  were checked in.
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.32
d68 1
a68 1
    Version = '1.1.32'
d739 1
@


1.37.2.1
log
@aamine
* lib/net/protocol.rb (adding): too few "yield" in case of arg is not String/File.
@
text
@a738 1
        yield unless @@wbuf.empty?
@


1.37.2.2
log
@aamine
* lib/net/protocol.rb: ignore EOFError for read
@
text
@d507 3
a509 7
      begin
        while rsize + @@buffer.size < len do
          rsize += writeinto( dest, @@buffer.size )
          fill_rbuf
        end
      rescue EOFError
        len = rsize
d537 6
d544 1
a544 10
      begin
        while true do
          idx = @@buffer.index( target )
          break if idx
          fill_rbuf
        end
        writeinto( dest, idx + target.size )
      rescue EOFError
        writeinto( dest, @@buffer.size )
      end
@


1.37.2.3
log
@aamine
* lib/net/protocol.rb: ignore EOFError on only specified case.
* lib/net/http.rb: take HTTP 1.0 server into account.
@
text
@d503 1
a503 1
    def read( len, dest = '', igneof = false )
a511 1
        writeinto( dest, len - rsize )
d513 1
a513 1
        raise unless igneof
d515 1
d540 1
a540 1
    def readuntil( target, igneof = false )
a549 1
        raise unless igneof
@


1.37.2.4
log
@aamine
* lib/net/http.rb: supports HTTP 1.0 server.
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.33
d68 1
a68 1
    Version = '1.1.33'
@


1.37.2.5
log
@aamine
* lib/net/protocol.rb: clear read buffer after reopen.
* lib/net/http.rb: update RD document.
@
text
@d463 1
a464 1
      @@buffer = ''
@


1.37.2.6
log
@aamine
* lib/net/http.rb: keep-alive detection was incomplete.
@
text
@a460 1
      d 'reopen'
a471 1
      d 'close'
a789 7
    end

    def d( s )
      if @@pipe then
        @@pipe << s
        @@pipe << "\n"
      end
@


1.37.2.7
log
@aamine
* lib/net/protocol.rb: use net 1.2 for also ruby 1.6 branch.
* lib/net/smtp.rb: ditto.
* lib/net/pop.rb: ditto.
* lib/net/http.rb: ditto.
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.34
a61 1
require 'timeout'
a65 8
  module NetPrivate
  end

  def self.net_private( &block )
    ::Net::NetPrivate.module_eval( &block )
  end


d68 1
a68 1
    Version = '1.1.34'
d119 2
a120 6
      @@active = false

      @@open_timeout = nil
      @@read_timeout = nil

      @@dout = nil
a128 13
    attr_accessor :open_timeout
    attr_accessor :read_timeout

    def active?
      @@active
    end

    def set_debug_output( arg )   # un-documented
      @@dout = arg
    end

    alias set_pipe set_debug_output

a132 3
    #
    # open session
    #
a148 2
    private

d154 4
d159 4
a162 4
    def connect
      conn_socket @@address, @@port
      conn_command @@socket
      on_connect
d165 2
a166 3
    def re_connect
      @@socket.reopen @@open_timeout
      on_connect
d169 2
a170 3
    def conn_socket( addr, port )
      @@socket = type.socket_type.open(
              addr, port, @@open_timeout, @@read_timeout, @@dout )
a172 3
    def conn_command( sock )
      @@command = type.command_type.new( sock )
    end
d174 2
a175 2
    def on_connect
    end
d180 2
a181 13
    #
    # close session
    #

    public

    def finish
      return false unless active?

      do_finish if @@command and not @@command.critical?
      disconnect
      @@active = false
      true
a183 1
    private
d185 3
a187 2
    def do_finish
      @@command.quit
d195 1
a195 5
      @@socket = nil
      on_disconnect
    end

    def on_disconnect
a202 1
  net_private {
a225 2
  }

d297 2
a298 1
  net_private {
a313 1

a409 1

d434 1
a434 1
    def initialize( addr, port, otime = nil, rtime = nil, dout = nil )
d437 2
d440 2
a441 5
      @@read_timeout = rtime

      @@debugout = dout

      @@socket = nil
d445 3
a447 9
      connect otime
      D 'opened'
    end

    def connect( otime )
      D "opening connection to #{@@addr}..."
      timeout( otime ) {
        @@socket = TCPsocket.new( @@addr, @@port )
      }
a448 1
    private :connect
d457 1
a457 1
      "#<#{type} #{closed? ? 'closed' : 'opened'}>"
d460 8
a467 5
    def reopen( otime = nil )
      D 'reopening...'
      close
      connect otime
      D 'reopened'
d473 3
a475 8
      if @@socket then
        @@socket.close
        D 'closed'
      else
        D 'close call for already closed socket'
      end
      @@socket = nil
      @@buffer = ''
d479 1
a479 1
      not @@socket
d491 1
a491 2
      @@socket or return ''
      @@socket.addr[3]
d499 3
a501 5
    #
    # read
    #

    public
d505 2
a506 2
    def read( len, dest = '', ignerr = false )
      D_off "reading #{len} bytes..."
d511 2
a512 2
          rsize += rbuf_moveto( dest, @@buffer.size )
          rbuf_fill
d514 1
a514 1
        rbuf_moveto dest, len - rsize
d519 1
a519 1
      D_on "read #{len} bytes"
d523 1
d525 1
a525 1
      D_off 'reading all...'
d530 2
a531 2
          rsize += rbuf_moveto( dest, @@buffer.size )
          rbuf_fill
d537 1
a537 1
      D_on "read #{rsize} bytes"
d541 1
d548 1
a548 1
          rbuf_fill
d550 1
a550 1
        rbuf_moveto dest, idx + target.size
d553 1
a553 1
        rbuf_moveto dest, @@buffer.size
d557 1
d565 1
d567 1
a567 1
      D_off 'reading text...'
d576 1
a576 1
      D_on "read #{rsize} bytes"
d580 1
d583 1
a583 1
      D_off 'reading list...'
d593 1
a593 1
      D_on "read #{i} items"
d600 1
a600 8
    READ_SIZE = 1024 * 4

    def rbuf_fill
      unless IO.select [@@socket], nil, nil, @@read_timeout then
        on_read_timeout
      end
      @@buffer << @@socket.sysread( READ_SIZE )
    end
d602 2
a603 2
    def on_read_timeout
      raise TimeoutError, "socket read timeout (#{@@read_timeout} sec)"
d606 1
a606 1
    def rbuf_moveto( dest, len )
d608 1
a608 2
      s = @@buffer[ 0, len ]
      dest << s
d611 1
a611 1
      @@debugout << %<read  "#{Net.quote s}"\n> if @@debugout
d616 3
a618 3
    #
    # write interfece
    #
d622 1
d629 1
d637 1
d641 1
a641 1
          block.call ::Net::NetPrivate::WriteAdapter.new( self, :do_write )
d650 1
d652 1
a652 1
      D_off "writing text from #{src.type}"
d656 1
a656 1
          block.call ::Net::NetPrivate::WriteAdapter.new( self, :wpend_in )
d662 1
a662 1
      D_on "wrote #{wsize} bytes text"
d709 1
a709 1
          m = Regexp.last_match
d714 1
a714 1
          str = buf[ beg ... m.begin(0) ]
d719 1
a719 1
        @@wbuf = buf[ beg ... buf.size ]
d760 4
a763 4
      if @@debugout then
        @@debugout << 'write "'
        @@debugout << @@sending
        @@debugout << "\"\n"
d770 1
a770 1
      if @@debugout or @@sending.size < 128 then
d782 17
a798 3
    def D_off( msg )
      D msg
      @@savedo, @@debugout = @@debugout, nil
d801 1
a801 4
    def D_on( msg )
      @@debugout = @@savedo
      D msg
    end
a802 7
    def D( msg )
      @@debugout or return
      @@debugout << msg
      @@debugout << "\n"
    end

  end
d804 1
a804 1
  }
@


1.37.2.8
log
@aamine
* lib/net/protocol.rb: one write(2) per one line.
@
text
@d697 2
a698 1
        do_write str + "\r\n"
@


1.37.2.9
log
@aamine
* lib/net/http.rb: add HTTPRequest#basic_auth.
* lib/net/smtp.rb: raise if only account or password is given.
* lib/net/protocol.rb: WriteAdapter#<< returns self.
@
text
@d364 1
a364 4
    def <<( str )
      @@sock.__send__ @@mid, str
      self
    end
@


1.37.2.10
log
@aamine
* lib/net/pop.rb: new methods POP3.auth_only, POP3#auth_only
* lib/net/http.rb: HTTP.Proxy returns self if ADDRESS is nil.
* lib/net/protocol.rb: new method ProtocolError#response
* lib/net/protocol.rb,smtp.rb,pop.rb,http.rb: add document.
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.35
d5 1
a5 1
Copyright (c) 1999-2001 Yukihiro Matsumoto
d7 3
a9 1
written & maintained by Minero Aoki <aamine@@loveruby.net>
d11 3
a13 3
This program is free software. You can re-distribute and/or
modify this program under the same terms as Ruby itself,
Ruby Distribute License or GNU General Public License.
d15 43
a57 3
NOTE: You can get Japanese version of this document from
Ruby Documentation Project (RDP):
((<URL:http://www.ruby-lang.org/~rubikitch/RDP.cgi>))
d77 2
a78 1
    Version = '1.1.35'
d107 1
a107 5
    # --- Configuration Staffs for Sub Classes ---
    #
    #   protocol_param port
    #   protocol_param command_type
    #   protocol_param socket_type   (optional)
d109 2
a110 2
    #   private method do_start      (optional)
    #   private method do_finish     (optional)
d112 2
a113 2
    #   private method on_connect    (optional)
    #   private method on_disconnect (optional)
d268 2
a269 2
    def error!
      raise code_type.error_type.new( code + ' ' + Net.quote(msg), self )
d289 1
a289 1
    def initialize( msg, resp )
d291 1
a291 1
      @@response = resp
d294 1
a294 2
    attr :response
    alias data response
d645 1
a645 1
    #  D_off 'reading list...'
d655 1
a655 1
    #  D_on "read #{i} items"
@


1.37.2.11
log
@aamine
* lib/net/protocol.rb (ProtoSocket#read): modify typo.
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.36
d35 1
a35 1
    Version = '1.1.36'
d125 1
a125 1
      active? and raise IOError, 'protocol has been opened already'
a136 1
      nil
d180 1
a180 1
      active? or raise IOError, 'already closed protocol'
d185 1
a185 1
      nil
d534 1
a534 1
    def read( len, dest = '', igneof = false )
@


1.37.2.12
log
@aamine
* lib/net/http.rb: HTTP#proxy? did not worked.
@
text
@d132 1
a132 1
          finish if active?
@


1.37.2.13
log
@aamine
* lib/net/smtp.rb: SMTP.new requires at least one arg.
* lib/net/pop.rb: POP.new requires at least one arg.
* lib/net/pop.rb: uses "raise *Error.new" instead of simple raise.
* lib/net/http.rb: HTTP.new requires at least one arg.
* lib/net/http.rb: changes implicit start algolithm.
@
text
@d13 3
a15 2
NOTE: You can find Japanese version of this document in
the doc/net directory of the standard ruby interpreter package.
d39 1
a39 1
      def start( address, port = nil, *args )
d82 2
a83 2
    def initialize( addr, port = nil )
      @@address = addr
d216 1
a216 1
    def initialize( ctype, code, msg )
d218 1
a218 1
      @@code      = code
@


1.37.2.14
log
@aamine
* lib/net/smtp.rb: uses Digest::MD5 instead of MD5 (again).
* lib/net/pop.rb: ditto.
* lib/net/http.rb (HTTP#request): must pass block.
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.37
d34 1
a34 1
    Version = '1.1.37'
@


1.37.2.15
log
@aamine
* lib/net/protocol.rb: calls on_connect before conn_command
@
text
@d149 1
a150 1
      conn_command @@socket
@


1.37.2.16
log
@aamine
* lib/net/protocol.rb: Protocol#start returns the return value of block.
* lib/net/protocol.rb: set timeout limit by default.
* lib/net/protocol.rb: new methods WriteAdapter#write, puts, print, printf.
* lib/net/protocol.rb: change template method scheme.
* lib/net/http.rb: rename HTTP#get2 to request_get, post2 to request_post ...
* lib/net/pop.rb: POP#auth_only did not work.
* lib/net/smtp.rb: should not resolve HELO domain automatically.
@
text
@d3 1
a3 1
= net/protocol.rb
a15 2
$Id: header.rd,v 1.2 2001/12/10 12:37:16 aamine Exp $

d24 8
a34 1
    Revision = %q$Revision: 1.41 $.split(/\s+/)[1]
d36 4
d41 7
a47 1
    class << self
d52 5
a56 5
        module_eval <<-End, __FILE__, __LINE__ + 1
            def self.#{name.id2name}
              #{val}
            end
        End
d69 2
a70 2
    #   private method do_start
    #   private method do_finish
d72 2
a73 2
    #   private method conn_address
    #   private method conn_port
d78 1
a78 2
    protocol_param :socket_type,  '::Net::BufferedSocket'

a79 12
    def Protocol.start( address, port = nil, *args )
      instance = new( address, port )

      if block_given? then
        ret = nil
        instance.start( *args ) { ret = yield(instance) }
        ret
      else
        instance.start( *args )
        instance
      end
    end
d90 2
a91 2
      @@open_timeout = 30
      @@read_timeout = 60
d120 1
a120 1
    # open
d124 1
a124 1
      @@active and raise IOError, 'protocol has been opened already'
d128 2
a129 3
          do_start( *args )
          @@active = true
          return yield(self)
d131 1
a131 1
          finish if @@active
d133 2
a135 3

      do_start( *args )
      @@active = true
d141 5
a145 1
    # abstract do_start()
d147 2
a148 4
    def conn_socket
      @@socket = type.socket_type.open(
              conn_address(), conn_port(),
              @@open_timeout, @@read_timeout, @@dout )
d150 1
d153 1
a153 4
    alias conn_address address
    alias conn_port    port

    def reconn_socket
d158 7
a164 2
    def conn_command
      @@command = type.command_type.new(@@socket)
d170 3
d174 1
a174 1
    # close
d180 4
a183 2
      active? or raise IOError, 'closing already closed protocol'
      do_finish
d190 3
a192 1
    # abstract do_finish()
d194 1
a194 2
    def disconn_command
      @@command.quit if @@command and not @@command.critical?
a195 3
    end

    def disconn_socket
d200 4
d211 2
d230 1
a230 1
      raise @@code_type.error_type.new( code + ' ' + msg.dump, self )
d235 2
d268 1
a268 1
      @@parents = [self] + paren
d270 2
d274 1
a274 3
    def parents
      @@parents.dup
    end
d277 1
a277 1
      "#<#{type} #{sprintf '0x%x', __id__}>"
d285 1
a285 1
      response.code_type.parents.each {|c| return true if c == self }
d290 1
a290 1
      type.new( @@parents, err || @@err )
d309 2
d314 1
a314 1
      @@socket = sock
d319 1
a319 6
      "#<#{type} socket=#{@@socket.inspect}>"
    end

    def <<( str )
      @@socket.__send__ @@mid, str
      self
d323 1
a323 1
      @@socket.__send__ @@mid, str
d326 3
a328 8
    alias print write

    def puts( str = '' )
      @@socket.__send__ @@mid, str.sub(/\n?/, "\n")
    end

    def printf( *args )
      @@socket.__send__ @@mid, sprintf(*args)
a332 1

d344 1
a344 1
      call_block str, &@@block if @@block
d349 14
a362 2
    def call_block( str )
      yield str
d374 1
a374 1
      @@atomic = false
d384 2
a385 1
    # abstract quit()
d389 2
d392 2
a393 2
      @@last_reply = get_reply()
      reply_must @@last_reply, *oks
a395 2
    # abstract get_reply()

d398 3
a400 1
        return rep if i === rep
d410 1
d418 1
a418 1
      @@atomic
d422 1
a422 1
      @@atomic = false
d425 1
d428 2
a429 2
    def atomic
      @@atomic = true
d431 1
a431 1
      @@atomic = false
d435 3
a437 3
    def begin_atomic
      ret = @@atomic
      @@atomic = true
d441 2
a442 2
    def end_atomic
      @@atomic = false
a444 4
    alias critical       atomic
    alias begin_critical begin_atomic
    alias end_critical   end_atomic

d448 1
d450 3
a452 1
  class BufferedSocket
d454 1
a454 3
    class << self
      alias open new
    end
a455 4
    def initialize( addr, port, otime = nil, rtime = nil, dout = nil )
      @@address      = addr
      @@port         = port
      @@read_timeout = rtime
d458 3
a460 2
      @@socket  = nil
      @@rbuf    = nil
d466 9
a474 2
    attr_reader :address
    attr_reader :port
d476 2
a477 3
    def ip_address
      @@socket or return ''
      @@socket.addr[3]
d480 3
a482 1
    attr_reader :socket
d484 5
a488 6
    def connect( otime )
      D "opening connection to #{@@address}..."
      timeout( otime ) {
          @@socket = TCPsocket.new( @@address, @@port )
      }
      @@rbuf = ''
d490 2
a491 1
    private :connect
d501 1
a501 1
      @@rbuf = ''
d504 2
a505 5
    def reopen( otime = nil )
      D 'reopening...'
      close
      connect otime
      D 'reopened'
d508 2
a509 2
    def closed?
      not @@socket
d512 7
a518 2
    def inspect
      "#<#{type} #{closed? ? 'closed' : 'opened'}>"
d521 4
a524 3
    ###
    ###  READ
    ###
d527 1
a527 1
    # basic reader
d532 3
a534 1
    def read( len, dest = '', ignore = false )
d539 2
a540 2
        while rsize + @@rbuf.size < len do
          rsize += rbuf_moveto(dest, @@rbuf.size)
d545 1
a545 1
        raise unless ignore
d558 1
a558 1
          rsize += rbuf_moveto(dest, @@rbuf.size)
d569 1
a569 1
    def readuntil( target, ignore = false )
d573 1
a573 1
          idx = @@rbuf.index(target)
d579 2
a580 2
        raise unless ignore
        rbuf_moveto dest, @@rbuf.size
d586 1
a586 1
      ret = readuntil("\n")
a590 6
    #
    # line oriented reader
    #

    public

d604 1
a604 1
  
a619 3
    #
    # lib (reader)
    #
d623 2
a624 1
    BLOCK_SIZE = 1024 * 2
d627 1
a627 1
      until IO.select [@@socket], nil, nil, @@read_timeout do
d630 1
a630 1
      @@rbuf << @@socket.sysread(BLOCK_SIZE)
d638 6
a643 2
      dest << (s = @@rbuf.slice!(0, len))
      @@debugout << %Q[-> #{s.dump}\n] if @@debugout
a647 4
    ###
    ###  WRITE
    ###

d649 1
a649 1
    # basic writer
d656 1
a656 1
          do_write str
d662 1
a662 1
          do_write str + "\r\n"
d668 5
a672 6
          if block then
            block.call WriteAdapter.new(self, :do_write)
          else
            src.each do |bin|
              do_write bin
            end
d674 1
d678 1
a678 7
    #
    # line oriented writer
    #

    public

    def write_pendstr( src, &block )
d681 6
a686 6
      wsize = using_each_crlf_line {
          if block_given? then
            yield WriteAdapter.new(self, :wpend_in)
          else
            wpend_in src
          end
d693 1
d696 1
d708 1
a708 1
    def using_each_crlf_line
d710 1
a710 1
          @@wbuf = ''
d712 1
a712 1
          yield
d714 3
a716 8
          if not @@wbuf.empty? then       # unterminated last line
            if @@wbuf[-1] == ?\r then
              @@wbuf.chop!
            end
            @@wbuf.concat "\r\n"
            do_write @@wbuf
          elsif @@writtensize == 0 then   # empty src
            do_write "\r\n"
d718 6
a723 1
          do_write ".\r\n"
d725 1
a725 1
          @@wbuf = nil
d762 1
a762 1
          i = src.read(2048)
a779 5
    #
    # lib (writer)
    #

    private
d783 2
a784 1
      @@debugout << '<- ' if @@debugout
d786 6
a792 1
      @@debugout << "\n" if @@debugout
d796 10
a805 4
    def do_write( str )
      @@debugout << str.dump if @@debugout
      @@writtensize += (n = @@socket.write(str))
      n
a807 5
    ###
    ### DEBUG
    ###

    private
d827 1
d829 6
a834 7
  # for backward compatibility
  module NetPrivate
    Response       = ::Net::Response
    WriteAdapter   = ::Net::WriteAdapter
    ReadAdapter    = ::Net::ReadAdapter
    Command        = ::Net::Command
    Socket         = ::Net::BufferedSocket
@


1.37.2.17
log
@aamine
* lib/net/http.rb: HTTP.Proxy should use self for proxy-class's super class.
* lib/net/http.rb: initialize HTTP.proxy_port by HTTP.port.
@
text
@@


1.37.2.18
log
@aamine
* lib/net/http.rb: remove unused class Accumulator.
* lib/net/http.rb: read response in HTTP#request. not HTTPRequest#exec.
* lib/net/http.rb: proxy related class instance variables are not initialized correctly.
* doc/net/http.rb: modify typo in the description of basic auth.
@
text
@d5 1
a5 1
Copyright (c) 1999-2002 Yukihiro Matsumoto
d16 1
a16 1
$Id: header.rd,v 1.2.2.1 2002/02/19 13:15:22 aamine Exp $
@


1.37.2.19
log
@* lib/net/protocol.rb: set read_timeout dynamically.
@
text
@d29 1
a29 1
    Revision = %q$Revision: 1.41.2.1 $.split(/\s+/)[1]
d101 1
a101 6
    attr_reader :read_timeout

    def read_timeout=( sec )
      @@socket.read_timeout = sec if @@socket
      @@read_timeout = sec
    end
a454 2

    attr_accessor :read_timeout
@


1.37.2.20
log
@lib/net/protocol.rb: Protocol#start should return self.
@
text
@d16 1
a16 1
$Id: protocol.rb,v 1.37.2.19 2002/02/22 12:50:22 aamine Exp $
d29 1
a29 1
    Revision = %q$Revision: 1.37.2.19 $.split(/\s+/)[1]
d141 1
a141 1
      self
@


1.36
log
@aamine
* lib/net/http.rb: does not send HEAD on closing socket.
@
text
@d3 1
a3 1
= net/protocol.rb version 1.2.0
d68 1
a68 1
    Version = '1.2.0'
@


1.35
log
@aamine
* lib/net/protocol.rb: set @@closed false in Socket#reopen.
* lib/net/pop.rb: add POP3.foreach, delete_all.
* lib/net/pop.rb: add POP3#delete_all.
* lib/net/http.rb: add HTTP.version_1_1, version_1_2
* lib/net/http.rb: refactoring.
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.32
d68 1
a68 1
    Version = '1.1.32'
@


1.34
log
@aamine
* lib/net/http.rb: Socket#readline() reads until "\n", not "\r\n"
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.31
d68 1
a68 1
    Version = '1.1.31'
d116 3
d121 1
d123 2
a124 3
      @@command = nil
      @@socket  = nil
    end
d126 2
a127 2
    attr_reader :address, :port,
                :command, :socket
d137 9
a145 7
      begin
        connect
        do_start( *args )
        @@active = true
        yield self if block_given?
      ensure
        finish if block_given?
d149 7
d159 1
a159 1
      do_finish
d390 1
a390 1
    def getok( line, ok = SuccessCode )
d392 12
a403 1
      check_reply ok
d406 5
a412 1
      return if @@critical
a418 4
    def critical?
      @@critical
    end

a428 5
    def error_ok
      @@critical = false
    end
    public :error_ok

d462 1
a462 1
        @@socket.close
d466 1
@


1.33
log
@aamine
* lib/net/http.rb: can call {old,new}_implementation any times.
* lib/net/http.rb: HTTP#connecting, receive ->
  common_oper, connecting.
* lib/net/http.rb: output warning if u_header includes
  duplicated header.
* lib/net/http.rb: not check Connection:/Proxy-Connection;
  always read until eof.
* lib/net/protocol: detects and catches "break" from block.
@
text
@d531 1
a531 1
      ret = readuntil( "\r\n" )
a540 1

d559 1
a561 1
        i += 1
@


1.32
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.31
* lib/net/http.rb: initializes header in HTTP, not HTTPCommand
* lib/net/protocol.rb, http.rb: rewrites proxy code
@
text
@d317 19
a335 1
      @@block.call str
d341 1
d464 1
d472 1
d478 5
a482 1
    CRLF    = "\r\n"
d542 1
a542 1
      while (str = readuntil( "\r\n" )) != ".\r\n" do
d553 1
a556 1
      arr = []
d558 2
a559 2

      while (str = readuntil( "\r\n" )) != ".\r\n" do
d561 2
a562 2
        arr.push str
        yield str if block_given?
d565 1
a565 2
      @@pipe << "read #{arr.size} lines\n" if pipeon
      arr
d587 4
@


1.31
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.30
* lib/net/protocol.rb, smtp.rb: Command#critical_ok -> error_ok
* lib/net/http.rb: read header when also "100 Continue"
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.30
a33 4
: Proxy( address, port )
  This method creates a proxy class of its protocol.
  Arguments are address/port of proxy host.

d68 1
a68 1
    Version = '1.1.30'
a83 32
      def Proxy( p_addr, p_port = nil )
        p_port ||= self.port
        klass = Class.new( self )
        klass.module_eval %-

          def initialize( addr, port )
            @@proxyaddr = '#{p_addr}'
            @@proxyport = '#{p_port}'
            super @@proxyaddr, @@proxyport
            @@address = addr
            @@port    = port
          end

          def connect( addr = nil, port = nil )
            super @@proxyaddr, @@proxyport
          end
          private :connect
            
          attr_reader :proxyaddr, :proxyport
        -
        def klass.proxy?
          true
        end

        klass
      end

      def proxy?
        false
      end


a188 1

@


1.30
log
@aamine
* lib/net/protocol.rb: Command#critical_ok
* lib/net/smtp.rb: clear critical flag before go to SMTP
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.29
d72 1
a72 1
    Version = '1.1.29'
d424 1
a424 1
    def critical_ok
d427 1
a427 1
    public :critical_ok
@


1.29
log
@aamine
* lib/net/protocol.rb: 2nd arg for ProtocolError#initialize is optional.
@
text
@d405 1
a405 1
      r = yield
d407 1
a407 1
      r
d423 5
@


1.28
log
@aamine
* lib/net/protocol.rb, http.rb: typo.
@
text
@d264 1
a264 1
    def initialize( msg, data )
d309 1
@


1.27
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.28.
* lib/net/http.rb: HTTPReadAdapter -> HTTPResponseReceiver
* lib/net/http.rb (connecting): response is got in receive()
@
text
@d18 1
a18 1
the abstruct class for Internet protocol
@


1.26
log
@matz: 1.6.0 final (hopufully)
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.28
d11 4
d53 1
a53 1
  When is called with a block, gives Protocol object to block and
d72 1
a72 1
    Version = '1.1.28'
@


1.25
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.27.
* lib/net/protocol.rb: writing methods returns written byte size.
* lib/net/smtp.rb: send_mail accepts many destinations.
@
text
@d49 1
a49 1
  When is called as iterator, gives Protocol object to block and
d76 1
a76 1
        if iterator? then
d170 1
a170 1
        yield self if iterator?
d172 1
a172 1
        finish if iterator?
d564 1
a564 1
        yield str if iterator?
@


1.24
log
@aamine
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.26.
* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb:
  add module Net::NetPrivate and its inner classes
  {Read,Write}Adapter, Command, Socket,
  SMTPCommand, POP3Command, APOPCommand, HTTPCommand
@
text
@d3 1
a3 1
= net/protocol.rb version 1.1.27
d7 3
a9 2
This library is distributed under the terms of the Ruby license.
You can freely distribute/modify this library.
d68 1
a68 1
    Version = '1.1.27'
d79 1
a79 1
          instance.start *args
d168 1
a168 1
        do_start *args
d643 1
d648 2
@


1.23
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.26.
* lib/net/protocol.rb (finish): do nothing unless active.
* lib/net/http.rb: HTTP#{get,post}2 again (for new impl).
@
text
@d3 1
a3 1
= net/protocol.rb
d67 1
a67 1
    Version = '1.1.26'
d140 1
a140 1
    protocol_param :socket_type,  '::Net::Socket'
a222 66
  class Command

    def initialize( sock )
      @@socket = sock
      @@last_reply = nil
      @@critical = false
    end

    attr_accessor :socket
    attr_reader :last_reply

    def inspect
      "#<#{type}>"
    end

    # abstract quit


    private

    # abstract get_reply()

    def check_reply( *oks )
      @@last_reply = get_reply
      reply_must( @@last_reply, *oks )
    end

    def reply_must( rep, *oks )
      oks.each do |i|
        if i === rep then
          return rep
        end
      end
      rep.error!
    end

    def getok( line, ok = SuccessCode )
      @@socket.writeline line
      check_reply ok
    end


    def critical
      return if @@critical
      @@critical = true
      r = yield
      @@critical = false
      r
    end

    def critical?
      @@critical
    end

    def begin_critical
      ret = @@critical
      @@critical = true
      not ret
    end

    def end_critical
      @@critical = false
    end

  end

d316 3
d354 67
d761 3
@


1.22
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.25.
* lib/net/protocol.rb (each_crlf_line): beg = 0 is needed in adding{}
* lib/net/smtp.rb: allow String for to_addr of SMTP#sendmail
@
text
@d67 1
a67 1
    Version = '1.1.25'
d176 1
a176 1
      ret = active?
d181 1
a181 2

      ret
@


1.21
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.24.
* lib/net/protocol.rb: modified each_crlf_line again.
* lib/net/protocol.rb: do_write_beg,do_write_end -> writing{}
  do_write_do -> do_write
* lib/net/http.rb: can make proxy connection by passing
  addresses to HTTP.new, start.
* lib/net/http.rb: HTTP.new_implementation, old_implementation:
  can use 1.2 implementation of head, get, post, put.
  (see document)
@
text
@d67 1
a67 1
    Version = '1.1.24'
d667 1
a667 2
      str = m = nil
      beg = 0
d670 1
@


1.20
log
@Fri Jun 16 22:56:02 2000  Minero Aoki <aamine@@dp.u-netsurf.ne.jp>

	*  protocol.rb (each_crlf_line): too many CRLF is concat-ed:
	   remove each_crlf_line2(), @@wbuf
	*  protocol.rb:  CRLF -> "\r\n", D_CRLF -> ".\r\n", strip //o
@
text
@d67 1
a67 1
    Version = '1.1.23'
d83 2
a84 1
      def Proxy( p_addr, p_port )
d113 1
a113 1
            
d591 3
a593 3
      do_write_beg
      do_write_do str
      do_write_fin
d598 4
a601 4
      do_write_beg
      do_write_do str
      do_write_do "\r\n"
      do_write_fin
d606 7
a612 6
      do_write_beg
      if block then
        block.call WriteAdapter.new( self, :do_write_do )
      else
        src.each do |bin|
          do_write_do bin
d614 1
a614 2
      end
      do_write_fin
d621 7
a627 8
      do_write_beg
      if block then
        block.call WriteAdapter.new( self, :write_pendstr_inner )
      else
        write_pendstr_inner src
      end
      do_write_do ".\r\n"
      wsize = do_write_fin
d637 6
a642 2
    def write_inner( src )
      each_crlf_line( src, :do_write_do )
d645 5
d651 10
a660 3
    def write_pendstr_inner( src )
      each_crlf_line src, :i_w_pend
    end
d662 2
a663 3
    def i_w_pend( line )
      do_write_do '.' if line[0] == ?.
      do_write_do line
d666 1
a666 3

    def each_crlf_line( src, mid )
      buf = ''
d668 1
d670 5
a674 7
      adding( src, buf ) do
        while true do
          m = /[^\r\n]*(\n|\r\n|\r)/.match( buf )
          break unless m

          str = m[0]
          if str.size == buf.size and buf[-1] == ?\r then
d678 1
a678 2
          buf[ 0, str.size ] = ''
          str.chop!
d680 2
a681 1
          __send__ mid, str
d683 1
a683 6
      end
      if not buf.empty? then    # un-terminated last line
        buf.concat "\r\n"
        __send__ mid, buf
      elsif not str then        # empty src
        __send__ mid, "\r\n"
d687 1
a687 1
    def adding( src, buf )
d692 2
a693 2
        0.step( src.size, 512 ) do |i|
          buf << src[ i, 512 ]
d699 1
a699 1
          i = src.read( 512 )
d701 2
a702 1
          buf << i
d707 5
a711 3
        src.each do |bin|
          buf << bin
          yield if buf.size > 512
d717 1
a717 1
    def do_write_beg
d720 10
d732 1
a732 1
    def do_write_do( arg )
a741 11
    end

    def do_write_fin
      if @@pipe then
        @@pipe << 'write "'
        @@pipe << @@sending
        @@pipe << "\"\n"
      end

      @@socket.flush
      @@writtensize
@


1.19
log
@o  protocol.rb, smtp.rb, pop.rb, http.rb:  define all#inspect()
o  protocol.rb, smtp.rb, pop.rb, http.rb:  modify/add documents
@
text
@a9 9
=end


require 'socket'


module Net

=begin
d60 5
d67 2
a68 1
    Version = '1.1.22'
a479 3
    D_CRLF  = ".\r\n"
    TERMEXP = /\n|\r\n|\r/o

d528 1
a528 1
      ret = readuntil( CRLF )
d539 1
a539 1
      while (str = readuntil( CRLF )) != D_CRLF do
d541 1
a541 1
        str.gsub!( /\A\./o, '' )
d556 1
a556 1
      while (str = readuntil( CRLF )) != D_CRLF do
d599 1
a599 1
      do_write_do CRLF
d626 1
a626 2
      each_crlf_line2( :i_w_pend )
      do_write_do D_CRLF
d653 2
a654 2
      beg = 0
      buf = pos = s = bin = nil
d656 1
a656 3
      adding( src ) do
        beg = 0
        buf = @@wbuf
d658 2
a659 4
          pos = buf.index( TERMEXP, beg )
          break unless pos
          s = $&.size
          break if pos + s == buf.size - 1 and buf[-1] == ?\r
d661 9
a669 2
          __send__ mid, buf[ beg, pos - beg ] << CRLF
          beg = pos + s
d671 6
a676 1
        @@wbuf = buf[ beg, buf.size - beg ] if beg != 0
d680 1
a680 1
    def adding( src )
d686 1
a686 1
          @@wbuf << src[ i, 512 ]
d694 1
a694 1
          @@wbuf << i
d700 2
a701 2
          @@wbuf << bin
          yield if @@wbuf.size > 512
a705 15
    def each_crlf_line2( mid )
      buf = @@wbuf
      beg = pos = nil

      buf << "\n" unless /\n|\r/o === buf[-1,1]

      beg = 0
      while true do
        pos = buf.index( TERMEXP, beg )
        break unless pos
        __send__ mid, buf[ beg, pos - beg ] << CRLF
        beg = pos + $&.size
      end
    end

a709 1
      @@wbuf = ''
@


1.18
log
@o  http.rb:  body is in HTTPResponse
@
text
@a155 1

d159 4
d237 4
d305 4
d334 4
d353 4
d392 4
d409 4
d442 4
@


1.17
log
@o  protocol.rb:  ProtocolError can take data
o  http.rb:  raise exception with response
@
text
@d71 1
a71 1
    Version = '1.1.21'
@


1.16
log
@o  smtp.rb:  not catch NameError in auth
o  http.rb:  not close connection in get_body,
   Only connection() closes socket
@
text
@d71 1
a71 1
    Version = '1.1.20'
d298 2
a299 2
    def error!
      raise @@code_type.error_type, @@code + ' ' + Net.quote(@@message)
d314 11
@


1.15
log
@p  http.rb:  do not use Regexp "p" option
@
text
@d71 1
a71 1
    Version = '1.1.19'
@


1.14
log
@o  protocol.rb, http.rb, smtp.rb, pop.rb:  update RD documents
@
text
@d71 1
a71 1
    Version = '1.1.18'
@


1.13
log
@o  protocol.rb:  Protocol#start yields self
o  smtp.rb:  use Socket.gethostname to get localhost name
p  pop.rb:  use MD5#hexdigest
@
text
@d33 4
a36 5
: start( address = 'localhost', port = nil, *args )
: start( address = 'localhost', port = nil, *args ){|proto| .... }
  This method creates a new Protocol object and start session.
  If you call this method with block, Protocol object give itself
  to block and finish session when block returns.
a41 1

d51 3
a53 2
  This method start protocol. If you call this method when the protocol
  is already started, this only returns false without doing anything.
d56 3
@


1.12
log
@protocol.rb version 1.1.17
o  http.rb:  'Host:' field includes port if port != 80
o  http.rb:  see also 'proxy-connection:' field
@
text
@a17 2
  Version = '1.1.17'

d69 1
a69 1
    Version = ::Net::Version
d166 1
a166 1
        yield if iterator?
d592 1
a592 1
      @@pipe << "wrote #{wsize} bytes text" if pipeon
@


1.11
log
@version 1.1.16
o smtp.rb:  SMTP AUTH (contributed by Kazuhiro Izawa)
@
text
@d18 1
a18 1
  Version = '1.1.16'
@


1.10
log
@{protocol,smtp,pop,http}.rb 1.1.15
o  http.rb: (keep_alive?)  use both user header and response
o  http.rb: (connecting)  returns response
o  http.rb: (connecting)  proc u_header and yield it
o  http.rb: (connecting)  call user block in conecting
@
text
@d18 1
a18 1
  Version = '1.1.15'
d349 1
@


1.9
log
@{protocol,smtp,pop}.rb version 1.1.14
o  http.rb:  HTTP#head2
o  http.rb:  HTTPResponse#value
o  http.rb:  get2/post2 returns response header
o  http.rb:  *2 does not raise exceptions
o  smtp.rb:  try esmtp only first time
o  protocol.rb:  remove error_occured
o  protocol.rb:  Command#error! does not take argument
@
text
@d18 1
a18 1
  Version = '1.1.14'
@


1.8
log
@o pop.rb:  accept illegal timestamp (reported by WATANABE Hirofumi)
o http.rb:  when body was chunked, does not set 'Content-Length'
@
text
@d18 1
a18 1
  Version = '1.1.13'
a226 1
      @@error_occured = false
d231 2
a232 2
    attr_reader :socket, :error_occured, :last_reply
    attr_writer :socket
d252 1
a252 3

      @@error_occured = true
      rep.error! @@socket.sending
d298 2
a299 11
    def error!( sending )
      raise @@code_type.error_type,
            sprintf( <<MSG, @@code, Net.quote(sending), Net.quote(@@message) )

status %s
writing string is:
%s

error message from server is:
%s
MSG
@


1.7
log
@protocol.rb smtp.rb pop.rb http.rb version 1.1.12

o protocol.rb:  update Net::Protocol::Proxy#connect
o protocol.rb:  ReplyCode is not a class
o http.rb:  header value does not include header name
o http.rb:  header is not a Hash, but HTTPResponse
@
text
@d18 1
a18 1
  Version = '1.1.12'
@


1.6
log
@v1.1.11
o  all:  use "critical" to avoid duplicated command dispatch
o  http.rb:  change get2, post2 usage (HTTPWriter)
o  http.rb:  entity reading algorithm is better
o  http.rb:  more reply code (4xx, 5xx)
o  protocol.rb:  arguments of "connect" can be omitted
o  protocol.rb:  "quit" is not template method (now do_quit is removed)
o  protocol.rb:  ReplyCode.error_type was not work: using module_eval
@
text
@d18 1
a18 1
  Version = '1.1.11'
d98 1
a98 1
          def connect( addr, port )
d289 1
a289 8
  class ProtocolError        < StandardError   ; end
  class   ProtoSyntaxError   <   ProtocolError ; end
  class   ProtoFatalError    <   ProtocolError ; end
  class   ProtoUnknownError  <   ProtocolError ; end
  class   ProtoServerError   <   ProtocolError ; end
  class   ProtoAuthError     <   ProtocolError ; end
  class   ProtoCommandError  <   ProtocolError ; end
  class   ProtoRetryError    <   ProtocolError ; end
d291 5
a295 35
  class ReplyCode

    class << self

      def error_type( err )
        module_eval "def self.get_error_type() #{err.name} end"
      end

      def error!( mes )
        raise get_error_type, mes
      end

    end
        
    def initialize( cod, mes )
      @@code = cod
      @@msg  = mes
      @@data = nil
    end

    attr_reader :code, :msg

    def []( key )
      if @@data then
        @@data[key]
      else
        nil
      end
    end

    def []=( key, val )
      unless h = @@data then
        @@data = h = {}
      end
      h[key] = val
d298 2
d302 2
a303 1
      mes = <<MES
d311 1
a311 2
MES
      type.error! sprintf( mes, @@code, Net.quote(sending), Net.quote(@@msg) )
a315 3
  class SuccessCode < ReplyCode
    error_type ProtoUnknownError
  end
d317 12
a328 3
  class ContinueCode < SuccessCode
    error_type ProtoUnknownError
  end
d330 3
a332 3
  class ErrorCode < ReplyCode
    error_type ProtocolError
  end
d334 2
a335 3
  class SyntaxErrorCode < ErrorCode
    error_type ProtoSyntaxError
  end
d337 1
a337 3
  class FatalErrorCode < ErrorCode
    error_type ProtoFatalError
  end
d339 3
a341 3
  class ServerBusyCode < ErrorCode
    error_type ProtoServerError
  end
d343 4
a346 3
  class RetryCode < ReplyCode
    error_type ProtoRetryError
  end
d348 4
a351 2
  class UnknownCode < ReplyCode
    error_type ProtoUnknownError
d353 10
d399 1
d456 2
a457 2
    def read( len, ret = '' )
      @@pipe << "reading #{len} bytes...\n" if pre = @@pipe ; @@pipe = nil
d461 1
a461 1
        rsize += writeinto( ret, @@buffer.size )
d464 1
a464 1
      writeinto( ret, len - rsize )
d466 2
a467 2
      @@pipe << "read #{len} bytes\n" if @@pipe = pre
      ret
d471 2
a472 2
    def read_all( ret = '' )
      @@pipe << "reading all...\n" if pre = @@pipe; @@pipe = nil
d477 1
a477 1
          rsize += writeinto( ret, @@buffer.size )
d484 2
a485 2
      @@pipe << "read #{rsize} bytes\n" if @@pipe = pre
      ret
d490 3
a492 1
      until idx = @@buffer.index( target ) do
d496 3
a498 3
      ret = ''
      writeinto( ret, idx + target.size )
      ret
d509 2
a510 2
    def read_pendstr( dest = '' )
      @@pipe << "reading text...\n" if pre = @@pipe ; @@pipe = nil
d520 1
a520 1
      @@pipe << "read #{rsize} bytes\n" if @@pipe = pre
d526 1
a526 1
      @@pipe << "reading list...\n" if pre = @@pipe ; @@pipe = nil
a529 1
      call = iterator?
d537 1
a537 1
      @@pipe << "read #{arr.size} lines\n" if @@pipe = pre
d551 1
a551 1
    def writeinto( ret, len )
d553 1
a553 1
      ret << @@buffer[ 0, len ]
d556 1
a556 1
      @@pipe << %{read  "#{Net.quote ret}"\n} if @@pipe
d579 1
a579 1
    def write_bin( src, block = nil )
d592 2
a593 2
    def write_pendstr( src )
      @@pipe << "writing text from #{src.type}\n" if pre = @@pipe ; @@pipe = nil
d596 2
a597 2
      if iterator? then
        yield WriteAdapter.new( self, :write_pendstr_inner )
d605 1
a605 1
      @@pipe << "wrote #{wsize} bytes text" if @@pipe = pre
d635 3
a637 1
        while pos = buf.index( TERMEXP, beg ) do
d641 1
a641 1
          send mid, buf[ beg, pos - beg ] << CRLF
d659 3
a661 1
        while i = src.read( 512 ) do
d681 4
a684 2
      while pos = buf.index( TERMEXP, beg ) do
        send mid, buf[ beg, pos - beg ] << CRLF
d717 13
@


1.5
log
@o  http.rb:  return value of 'head' was wrong
@
text
@d18 1
a18 1
  Version = '1.1.10'
d147 1
a147 1
      @@port    = port || self.type.port
a162 1
      @@active = true
d165 1
a165 1
        connect @@address, @@port
d167 1
d177 1
a177 1
      do_finish if @@command
d204 3
a206 3
    def connect( addr, port )
      @@socket  = self.type.socket_type.open( addr, port, @@pipe )
      @@command = self.type.command_type.new( @@socket )
d216 1
a216 1

d229 1
d235 1
a235 6
    def quit
      if @@socket and not @@socket.closed? then
        do_quit
        @@error_occured = false
      end
    end
a239 3
    def do_quit
    end

d262 24
a285 1
    
d303 1
a303 1
        @@err = err
d307 1
a307 1
        raise @@err, mes
@


1.4
log
@o  protocol.rb:  version 1.1.9
o  smtp.rb:  arguments discription of do_ready was wrongly void
@
text
@d18 1
a18 1
  Version = '1.1.9'
@


1.3
log
@net Version 1.1.7
o  http.rb:  HTTP#connecting() returns header again
@
text
@d18 1
a18 1
  Version = '1.1.7'
a221 21
=begin

== Net::Command

=== Super Class

Object

=== Class Methods

: new( socket )
  This method create new Command object. 'socket' must be ProtocolSocket.
  This method is abstract class.


=== Methods

: quit
  This method dispatch command which ends the protocol.

=end
d299 1
d304 15
a367 72
=begin

== Net::ProtocolSocket

=== Super Class

Object

=== Class Methods

: new( address = 'localhost', port = nil )
  This create new ProtocolSocket object, and connect to server.


=== Methods

: close
  This method closes socket.

: address, addr
  a FQDN address of server

: ip_address, ipaddr
  an IP address of server

: port
  connecting port number.

: closed?
  true if ProtocolSokcet have been closed already


: read( length )
  This method read 'length' bytes and return the string.

: readuntil( target )
  This method read until find 'target'. Returns read string.

: readline
  read until "\r\n" and returns it without "\r\n".

: read_pendstr
  This method read until "\r\n.\r\n".
  At the same time, delete period at line head and final line ("\r\n.\r\n").

: read_pendlist
: read_pendlist{|line| .... }
  This method read until "\r\n.\r\n". This method resembles to 'read_pendstr',
  but 'read_pendlist' don't check period at line head, and returns array which
  each element is one line.

  When this method was called with block, evaluate it for each reading a line.


: write( src )
  This method send 'src'. ProtocolSocket read strings from 'src' by 'each'
  iterator. This method returns written bytes.

: writebin( src )
  This method send 'src'. ProtocolSokcet read string from 'src' by 'each'
  iterator. This method returns written bytes.

: writeline( str )
  This method writes 'str'. There has not to be bare "\r" or "\n" in 'str'.

: write_pendstr( src )
  This method writes 'src' as a mail.
  ProtocolSocket reads strings from 'src' by 'each' iterator.
  This returns written bytes.

=end

d565 7
d580 1
a580 1
    def writebin( src )
d582 2
a583 2
      if iterator? then
        yield WriteAdapter.new( self, :do_write_do )
a588 12
      do_write_fin
    end


    def write( src )
      do_write_beg
      if iterator? then
        yield WriteAdapter.new( self, :write_inner )
      else
        write_inner src
      end
      each_crlf_line2( :i_w )
@


1.3.2.1
log
@add protocol.rb for ruby-1.4
@
text
@@


1.3.2.2
log
@protocol.rb/smtp.rb/pop.rb/http.rb 1.1.8
o  http.rb:  post, get2, post2, get_body
@
text
@d18 1
a18 1
  Version = '1.1.8'
d222 21
a319 1
      @@data = nil
a323 15
    def []( key )
      if @@data then
        @@data[key]
      else
        nil
      end
    end

    def []=( key, val )
      unless h = @@data then
        @@data = h = {}
      end
      h[key] = val
    end

d373 72
d642 1
a642 1
    def write( str )
d645 1
d650 1
a650 1
    def writeline( str )
d652 7
a658 2
      do_write_do str
      do_write_do CRLF
d663 1
a663 1
    def write_bin( src, block = nil )
d665 2
a666 2
      if block then
        block.call WriteAdapter.new( self, :do_write_do )
d668 1
a668 3
        src.each do |bin|
          do_write_do bin
        end
d670 1
@


1.3.2.3
log
@protocol.rb smtp.rb pop.rb http.rb 1.1.9 for ruby 1.4 branch
@
text
@d18 1
a18 1
  Version = '1.1.9'
@


1.3.2.4
log
@protocol.rb smtp.rb pop.rb http.rb for ruby 1.4 branch
@
text
@d18 1
a18 1
  Version = '1.1.10'
@


1.3.2.5
log
@o  all:  use "critical" to avoid duplicated command dispatch
o  http.rb:  change get2, post2 usage (HTTPWriter)
o  http.rb:  entity reading algorithm is better
o  http.rb:  more reply code (4xx, 5xx)
o  protocol.rb:  arguments of "connect" can be omitted
o  protocol.rb:  "quit" is not template method (now do_quit is removed)
o  protocol.rb:  ReplyCode.error_type was not work: using module_eval
@
text
@d18 1
a18 1
  Version = '1.1.11'
d147 1
a147 1
      @@port    = port || type.port
d163 1
d166 1
a166 1
        connect
a167 1
        @@active = true
d177 1
a177 1
      do_finish
d204 3
a206 3
    def connect( addr = @@address, port = @@port )
      @@socket  = type.socket_type.open( addr, port, @@pipe )
      @@command = type.command_type.new( @@socket )
d216 1
a216 1
    
a228 1
      @@critical = false
d234 6
a239 1
    # abstract quit
d244 3
d269 1
a269 24


    def critical
      return if @@critical
      @@critical = true
      r = yield
      @@critical = false
      r
    end

    def critical?
      @@critical
    end

    def begin_critical
      ret = @@critical
      @@critical = true
      not ret
    end

    def end_critical
      @@critical = false
    end

d287 1
a287 1
        module_eval "def self.get_error_type() #{err.name} end"
d291 1
a291 1
        raise get_error_type, mes
@


1.3.2.6
log
@protocol.rb smtp.rb pop.rb http.rb 1.1.12 for ruby 1.4 branch
@
text
@d18 1
a18 1
  Version = '1.1.12'
d98 1
a98 1
          def connect( addr = nil, port = nil )
d289 8
a296 1
  class Response
d298 35
a332 5
    def initialize( ctype, cno, msg )
      @@code_type = ctype
      @@code      = cno
      @@message   = msg
      super()
a334 2
    attr_reader :code_type, :code, :message
    alias msg message
d337 1
a337 2
      raise @@code_type.error_type,
            sprintf( <<MSG, @@code, Net.quote(sending), Net.quote(@@message) )
d345 2
a346 1
MSG
d351 3
d355 3
a357 9
  class ProtocolError          < StandardError; end
  class ProtoSyntaxError       < ProtocolError; end
  class ProtoFatalError        < ProtocolError; end
  class ProtoUnknownError      < ProtocolError; end
  class ProtoServerError       < ProtocolError; end
  class ProtoAuthError         < ProtocolError; end
  class ProtoCommandError      < ProtocolError; end
  class ProtoRetriableError    < ProtocolError; end
  ProtocRetryError = ProtoRetriableError
d359 3
d363 3
a365 1
  class Code
d367 3
a369 3
    def initialize( paren, err )
      @@parents = paren
      @@err = err
d371 3
a373 2
      @@parents.push self
    end
d375 3
a377 10
    attr_reader :parents

    def error_type
      @@err
    end

    def ===( response )
      response.code_type.parents.reverse_each {|i| return true if i == self }
      false
    end
d379 2
a380 4
    def mkchild( err = nil )
      type.new( @@parents + [self], err || @@err )
    end
  
a381 10
  
  ReplyCode       = Code.new( [], ProtoUnknownError )
  SuccessCode     = ReplyCode.mkchild( ProtoUnknownError )
  ContinueCode    = ReplyCode.mkchild( ProtoUnknownError )
  ErrorCode       = ReplyCode.mkchild( ProtocolError )
  SyntaxErrorCode = ErrorCode.mkchild( ProtoSyntaxError )
  FatalErrorCode  = ErrorCode.mkchild( ProtoFatalError )
  ServerErrorCode = ErrorCode.mkchild( ProtoServerError )
  RetriableCode   = ReplyCode.mkchild( ProtoRetriableError )
  UnknownCode     = ReplyCode.mkchild( ProtoUnknownError )
a417 1
      @@prepipe = nil
d474 2
a475 2
    def read( len, dest = '' )
      @@pipe << "reading #{len} bytes...\n" if @@pipe; pipeoff
d479 1
a479 1
        rsize += writeinto( dest, @@buffer.size )
d482 1
a482 1
      writeinto( dest, len - rsize )
d484 2
a485 2
      @@pipe << "read #{len} bytes\n" if pipeon
      dest
d489 2
a490 2
    def read_all( dest = '' )
      @@pipe << "reading all...\n" if @@pipe; pipeoff
d495 1
a495 1
          rsize += writeinto( dest, @@buffer.size )
d502 2
a503 2
      @@pipe << "read #{rsize} bytes\n" if pipeon
      dest
d508 1
a508 3
      while true do
        idx = @@buffer.index( target )
        break if idx
d512 3
a514 3
      dest = ''
      writeinto( dest, idx + target.size )
      dest
d525 2
a526 2
    def read_pendstr( dest )
      @@pipe << "reading text...\n" if @@pipe; pipeoff
d536 1
a536 1
      @@pipe << "read #{rsize} bytes\n" if pipeon
d542 1
a542 1
      @@pipe << "reading list...\n" if @@pipe; pipeoff
d546 1
d554 1
a554 1
      @@pipe << "read #{arr.size} lines\n" if pipeon
d568 1
a568 1
    def writeinto( dest, len )
d570 1
a570 1
      dest << @@buffer[ 0, len ]
d573 1
a573 1
      @@pipe << %{read  "#{Net.quote dest}"\n} if @@pipe
d596 1
a596 1
    def write_bin( src, block )
d609 2
a610 2
    def write_pendstr( src, block )
      @@pipe << "writing text from #{src.type}\n" if @@pipe; pipeoff
d613 2
a614 2
      if block then
        block.call WriteAdapter.new( self, :write_pendstr_inner )
d622 1
a622 1
      @@pipe << "wrote #{wsize} bytes text" if pipeon
d652 1
a652 3
        while true do
          pos = buf.index( TERMEXP, beg )
          break unless pos
d656 1
a656 1
          __send__ mid, buf[ beg, pos - beg ] << CRLF
d674 1
a674 3
        while true do
          i = src.read( 512 )
          break unless i
d694 2
a695 4
      while true do
        pos = buf.index( TERMEXP, beg )
        break unless pos
        __send__ mid, buf[ beg, pos - beg ] << CRLF
a727 13
    end


    def pipeoff
      @@prepipe = @@pipe
      @@pipe = nil
      @@prepipe
    end

    def pipeon
      @@pipe = @@prepipe
      @@prepipe = nil
      @@pipe
@


1.3.2.7
log
@{protocol,smtp,pop,http}.rb 1.1.13 for ruby 1.4 branch
@
text
@d18 1
a18 1
  Version = '1.1.13'
@


1.3.2.8
log
@{protocol,smtp,pop,http}.rb for ruby 1.4 branch
@
text
@d18 1
a18 1
  Version = '1.1.14'
d227 1
d232 2
a233 2
    attr_accessor :socket
    attr_reader :last_reply
d253 3
a255 1
      rep.error!
d301 11
a311 2
    def error!
      raise @@code_type.error_type, @@code + ' ' + Net.quote(@@message)
@


1.3.2.9
log
@{protocol,smtp,pop,http}.rb 1.1.15 for ruby 1.4 branch
@
text
@d18 1
a18 1
  Version = '1.1.15'
@


1.3.2.10
log
@version 1.1.16
o smtp.rb:  SMTP AUTH (contributed by Kazuhiro Izawa)
@
text
@d18 1
a18 1
  Version = '1.1.16'
a348 1
  AuthErrorCode   = ErrorCode.mkchild( ProtoAuthError )
@


1.3.2.11
log
@protocol.rb version 1.1.17 for ruby 1.4 branch
@
text
@d18 1
a18 1
  Version = '1.1.17'
@


1.3.2.12
log
@o  protocol.rb:  Protocol#start yields self
o  smtp.rb:  use Socket.gethostname to get localhost name
@
text
@d18 2
d71 1
a71 1
    Version = '1.1.18'
d168 1
a168 1
        yield self if iterator?
d594 1
a594 1
      @@pipe << "wrote #{wsize} bytes text\n" if pipeon
@


1.3.2.13
log
@o  protocol.rb, http.rb, smtp.rb, pop.rb:  update RD documents
@
text
@d33 5
a37 4
: start( address = 'localhost', port = nil, *protoargs )
: start( address = 'localhost', port = nil, *protoargs ) {|proto| .... }
  This method creates a new Protocol object and opens a session.
  equals to Net::Protocol.new( address, port ).start( *protoargs )
d43 1
d53 2
a54 3
: start( *args ) {|proto| .... }
  This method starts protocol. If protocol was already started,
  do nothing and returns false.
a56 3

  When is called as iterator, gives Protocol object to block and
  close session when block finished.
@


1.3.2.14
log
@p  http.rb:  do not use Regexp "p" option
@
text
@d71 1
a71 1
    Version = '1.1.19'
@


1.3.2.15
log
@o  http.rb:  not close connection in get_body,
   Only connection() closes socket
@
text
@d71 1
a71 1
    Version = '1.1.20'
@


1.3.2.16
log
@o  protocol.rb:  ProtocolError can take data
o  http.rb:  raise exception with response
@
text
@d71 1
a71 1
    Version = '1.1.21'
d298 2
a299 2
    def error!( data = nil )
      raise code_type.error_type.new( code + ' ' + Net.quote(msg), data )
a313 11

  class ProtocolError
  
    def initialize( msg, data )
      super msg
      @@data = data
    end

    attr :data
  
  end
@


1.3.2.17
log
@o  http.rb:  body is in HTTPResponse object
@
text
@d71 1
a71 1
    Version = '1.1.22'
@


1.3.2.18
log
@o  protocol.rb, smtp.rb, pop.rb, http.rb:  define all#inspect()
o  protocol.rb, smtp.rb, pop.rb, http.rb:  modify/add documents
@
text
@d156 1
a159 4
    def inspect
      "#<#{type} #{address}:#{port} open=#{active?}>"
    end

a233 4
    def inspect
      "#<#{type}>"
    end

a297 4
    def inspect
      "#<#{type} #{code}>"
    end

a322 4

    def inspect
      "#<#{type}>"
    end
a337 4
    def inspect
      "#<#{type}>"
    end

a372 4
    def inspect
      "#<#{type}>"
    end

a385 4
    def inspect
      "#<#{type}>"
    end

a414 4
    end

    def inspect
      "#<#{type} open=#{!@@closed}>"
@


1.3.2.19
log
@o  protocol.rb (each_crlf_line): too many CRLF is concat-ed:
   remove each_crlf_line2(), @@wbuf
o  protocol.rb:  CRLF -> "\r\n", D_CRLF -> ".\r\n", strip //o
@
text
@d10 9
a68 5
require 'socket'


module Net

d71 1
a71 2
    Version = '1.1.23'

d483 3
d534 1
a534 1
      ret = readuntil( "\r\n" )
d545 1
a545 1
      while (str = readuntil( "\r\n" )) != ".\r\n" do
d547 1
a547 1
        str.gsub!( /\A\./, '' )
d562 1
a562 1
      while (str = readuntil( "\r\n" )) != ".\r\n" do
d605 1
a605 1
      do_write_do "\r\n"
d632 2
a633 1
      do_write_do ".\r\n"
d660 2
a661 2
      buf = ''
      str = m = nil
d663 3
a665 1
      adding( src, buf ) do
d667 4
a670 2
          m = /[^\r\n]*(\n|\r\n|\r)/.match( buf )
          break unless m
d672 2
a673 9
          str = m[0]
          if str.size == buf.size and buf[-1] == ?\r then
            # "...\r" : can follow "\n..."
            break
          end
          buf[ 0, str.size ] = ''
          str.chop!
          str.concat "\r\n"
          __send__ mid, str
d675 1
a675 6
      end
      if not buf.empty? then    # un-terminated last line
        buf.concat "\r\n"
        __send__ mid, buf
      elsif not str then        # empty src
        __send__ mid, "\r\n"
d679 1
a679 1
    def adding( src, buf )
d685 1
a685 1
          buf << src[ i, 512 ]
d693 1
a693 1
          buf << i
d699 2
a700 2
          buf << bin
          yield if buf.size > 512
d705 15
d724 1
@


1.3.2.20
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.24.
* lib/net/protocol.rb: modified each_crlf_line again.
* lib/net/protocol.rb: do_write_beg,do_write_end -> writing{}
  do_write_do -> do_write
* lib/net/http.rb: can make proxy connection by passing
  addresses to HTTP.new, start.
* lib/net/http.rb: HTTP.new_implementation, old_implementation:
  can use 1.2 implementation of head, get, post, put.
  (see document)
@
text
@d67 1
a67 1
    Version = '1.1.24'
d83 1
a83 2
      def Proxy( p_addr, p_port = nil )
        p_port ||= self.port
d112 1
a112 1

d590 3
a592 3
      writing {
        do_write str
      }
d597 4
a600 4
      writing {
        do_write str
        do_write "\r\n"
      }
d605 6
a610 7
      writing {
        if block then
          block.call WriteAdapter.new( self, :do_write )
        else
          src.each do |bin|
            do_write bin
          end
d612 2
a613 1
      }
d620 8
a627 7
      wsize = use_each_crlf_line {
        if block then
          block.call WriteAdapter.new( self, :wpend_in )
        else
          wpend_in src
        end
      }
d637 2
a638 6
    def wpend_in( src )
      line = nil
      each_crlf_line( src ) do |line|
        do_write '.' if line[0] == ?.
        do_write line
      end
a640 3
    def use_each_crlf_line
      writing {
        @@wbuf = ''
d642 3
a644 1
        yield
d646 4
a649 10
        if not @@wbuf.empty? then       # un-terminated last line
          if @@wbuf[-1] == ?\r then
            @@wbuf.chop!
          end
          @@wbuf.concat "\r\n"
          do_write @@wbuf
        elsif @@writtensize == 0 then   # empty src
          do_write "\r\n"
        end
        do_write ".\r\n"
a650 3
        @@wbuf = nil
      }
    end
d652 2
a653 1
    def each_crlf_line( src )
a654 1
      beg = 0
d656 7
a662 5
      adding( src ) do
        buf = @@wbuf
        while buf.index( /\n|\r\n|\r/, beg ) do
          m = $~
          if m.begin(0) == buf.size - 1 and buf[-1] == ?\r then
d666 2
a667 1
          str = buf[ beg, m.begin(0) - beg ]
d669 1
a669 2
          yield str
          beg = m.end(0)
d671 6
a676 1
        @@wbuf = buf[ beg, buf.size - beg ]
d680 1
a680 1
    def adding( src )
d685 2
a686 2
        0.step( src.size - 1, 2048 ) do |i|
          @@wbuf << src[i,2048]
d692 1
a692 1
          i = src.read( 2048 )
d694 1
a694 2
          i[0,0] = @@wbuf
          @@wbuf = i
d699 3
a701 5
        src.each do |i|
          @@wbuf << i
          if @@wbuf.size > 2048 then
            yield
          end
d707 1
a707 1
    def writing
a709 10

      yield

      if @@pipe then
        @@pipe << 'write "'
        @@pipe << @@sending
        @@pipe << "\"\n"
      end
      @@socket.flush
      @@writtensize
d712 1
a712 1
    def do_write( arg )
d722 11
@


1.3.2.21
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.25.
* lib/net/protocol.rb (each_crlf_line): beg = 0 is needed in adding{}
* lib/net/smtp.rb: allow String for to_addr of SMTP#sendmail
@
text
@d67 1
a67 1
    Version = '1.1.25'
d667 2
a668 1
      str = m = beg = nil
a670 1
        beg = 0
@


1.3.2.22
log
@* lib/net/protocol.rb, smtp.rb, pop.rb, http.rb: 1.1.26.
* lib/net/protocol.rb (finish): do nothing unless active.
* lib/net/http.rb: HTTP#{get,post}2 again (for new impl).
@
text
@d67 1
a67 1
    Version = '1.1.26'
d176 1
a176 1
      return false unless active?
d181 2
a182 1
      true
@


1.2
log
@Version 1.1.6

o  all:  use 'attr_reader/writer' instead of 'attr'
o  http.rb:  get/head allow implicit 'start'
o  http.rb:  change connection state algorithm
o  http.rb:  process user header before write
o  protocol.rb:  refine start/finish
o  protocol.rb:  Command#last_reply
o  protocol.rb:  ReplyCode.error!
@
text
@d18 1
a18 1
  Version = '1.1.6'
@


1.1
log
@Version 1.1.5

o  session.rb -> protocol.rb
@
text
@d18 1
a18 1
  Version = '1.1.5'
d103 1
a103 2
          attr :proxyaddr
          attr :proxyport
d157 2
a158 5
    attr :address
    attr :port

    attr :command
    attr :socket
d175 1
a175 4
      if @@command then
        do_finish
        disconnect
      end
d177 3
a179 7
      if @@socket and not @@socket.closed? then
        @@socket.close
        @@socket = nil
      end

      if active? then
        @@active = false
d181 1
a181 4
        return true
      else
        return false
      end
d200 1
a209 1
      @@command.quit
d211 3
d249 1
d252 2
a253 2
    attr :socket, true
    attr :error_occured
d257 1
a257 6
        begin
          do_quit
        ensure
          @@socket.close unless @@socket.closed?
          @@socket = nil
        end
d262 1
d265 5
d271 2
a272 1
      reply_must( get_reply, *oks )
d305 12
d322 2
a323 2
    attr :code
    attr :msg
d335 1
a335 2
      raise self.type::Error,
        sprintf( mes, @@code, Net.quote(sending), Net.quote(@@msg) )
d341 1
a341 1
    Error = ProtoUnknownError
d345 1
a345 1
    Error = ProtoUnknownError
d349 1
a349 1
    Error = ProtocolError
d353 1
a353 1
    Error = ProtoSyntaxError
d357 1
a357 1
    Error = ProtoFatalError
d361 1
a361 1
    Error = ProtoServerError
d365 1
a365 1
    Error = ProtoRetryError
d369 1
a369 1
    Error = ProtoUnknownError
a503 1

d520 1
a520 1
    attr :port
d527 1
a527 1
    attr :sending
@
