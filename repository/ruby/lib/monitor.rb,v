head	1.5;
access;
symbols
	v1_6_7:1.2.4.3
	v1_6_6:1.2.4.3
	v1_6_5:1.2.4.3
	v1_6_4:1.2.4.3
	v1_7_1:1.5
	v1_6_4_preview4:1.2.4.3
	v1_6_4_preview3:1.2.4.3
	v1_6_4_preview2:1.2.4.3
	v1_6_4_preview1:1.2.4.3
	v1_6_3:1.2.4.1
	ruby_m17n:1.2.0.6
	ruby_1_6:1.2.0.4
	v1_6_2:1.2
	v1_6_1:1.2
	v1_6_0:1.2
	v1_4_6:1.2
	v1_4_5:1.2
	v1_4_4:1.2
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.2
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.1
	v1_3_6_repack:1.1.1.1.2.1
	v1_3_6:1.1.1.1.2.1
	v1_3_5:1.1.1.1.2.1
	v1_2_6repack:1.1.2.1
	v1_3_4_990625:1.1.1.1.2.1
	v1_3_4_990624:1.1.1.1.2.1
	v1_2_6:1.1.2.1
	v1_3_4_990611:1.1.1.1.2.1
	v1_3_4_990531:1.1.1.1.2.1
	v1_3_3_990518:1.1.1.1.2.1
	v1_3_3_990513:1.1.1.1.2.1
	v1_3_3_990507:1.1.1.1.2.1
	v1_2_5:1.1.2.1
	v1_2_4:1.1.2.1
	v1_3_1_990225:1.1.1.1
	v1_3_1_990224:1.1.1.1
	v1_3_1_990215:1.1.1.1
	v1_3_1_990212:1.1.1.1
	v1_3_1_990210:1.1.1.1
	v1_3_1_:1.1.1.1
	v1_3_1_990209:1.1.1.1
	v1_3_1_990205:1.1.1.1
	v1_3_1_990203:1.1.1.1
	v1_3_1_990201:1.1.1.1
	v1_3_1"_990201:1.1.1.1
	v1_3_1_990128:1.1.1.1
	v1_3_1_990127:1.1.1.1
	v1_3_1_990126:1.1.1.1
	ruby_1_3:1.1.1.1.0.2
	v1_2_2:1.1.2.1
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_2_2_pr1:1.1.2.1
	v1_2_1repack:1.1.2.1
	v1_2_1:1.1.2.1
	v1_2_stable:1.1.2.1
	v1_1d1:1.1.2.1
	v1_1d0:1.1.2.1
	v1_1c9_1:1.1.2.1
	v1_1c9:1.1.2.1
	v1_1c8:1.1.2.1
	v1_1c7:1.1.2.1
	v1_1c6:1.1.2.1
	v1_1d-start:1.1.2.1
	v1_1c5:1.1.2.1
	v1_1dev:1.1.2.1.0.2
	v1_1c4:1.1.2.1
	v1_1c3:1.1.2.1
	v1_1c2:1.1.2.1
	v1_1c1:1.1.2.1
	v1_1c0:1.1.2.1
	v1_1b9_31:1.1.2.1
	v1_1b9_30:1.1.2.1
	v1_1b9_28:1.1.2.1
	v1_1b9_27:1.1.2.1
	v1_1b9_26:1.1.2.1
	r1_1b9_25:1.1.2.1
	r1_1b9_24:1.1.2.1
	v1_1b9_23:1.1.2.1
	v1_1b9_22:1.1.2.1
	v1_1b9_20:1.1.2.1
	v1_1b9_18:1.1.2.1
	v1_1b9_16:1.1.2.1
	v1_1b9_15:1.1.2.1
	v1_1b9_13:1.1.2.1
	v1_1b9_12:1.1.2.1
	v1_1b9_11:1.1.2.1
	v1_1b9_08:1.1.2.1
	v1_1b9_07:1.1.2.1
	v1_1r:1.1.0.2;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2001.04.02.05.26.31;	author shugo;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.02.04.57.24;	author shugo;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.06.09.03.59;	author shugo;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.16;	author matz;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	98.03.02.04.03.33;	author matz;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	99.01.20.04.59.35;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.03.24.08.52.35;	author matz;	state Exp;
branches;
next	;

1.1.2.1
date	98.03.02.04.03.33;	author matz;	state Exp;
branches;
next	;

1.2.4.1
date	2001.03.06.09.10.02;	author shugo;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.04.02.04.59.43;	author shugo;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.04.02.05.27.49;	author shugo;	state Exp;
branches;
next	;


desc
@@


1.5
log
@* lib/monitor.rb (wait): fix timeout support.
@
text
@=begin

= monitor.rb

Copyright (C) 2001  Shugo Maeda <shugo@@ruby-lang.org>

This library is distributed under the terms of the Ruby license.
You can freely distribute/modify this library.

== example

This is a simple example.

  require 'monitor.rb'
  
  buf = []
  buf.extend(MonitorMixin)
  empty_cond = buf.new_cond
  
  # consumer
  Thread.start do
    loop do
      buf.synchronize do
        empty_cond.wait_while { buf.empty? }
        print buf.shift
      end
    end
  end
  
  # producer
  while line = ARGF.gets
    buf.synchronize do
      buf.push(line)
      empty_cond.signal
    end
  end

The consumer thread waits for the producer thread to push a line
to buf while buf.empty?, and the producer thread (main thread)
reads a line from ARGF and push it to buf, then call
empty_cond.signal.

=end
  
module MonitorMixin
  module Accessible
  protected
    attr_accessor :mon_owner, :mon_count
    attr_reader :mon_entering_queue, :mon_waiting_queue
  end
  
  module Initializable
  protected
    def mon_initialize
      @@mon_owner = nil
      @@mon_count = 0
      @@mon_entering_queue = []
      @@mon_waiting_queue = []
    end
  end
  
  class ConditionVariable
    class Timeout < Exception; end
    
    include Accessible
    
    def wait(timeout = nil)
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      
      if timeout
	ct = Thread.current
	timeout_thread = Thread.start {
	  Thread.pass
	  sleep(timeout)
	  ct.raise(Timeout.new)
	}
      end

      Thread.critical = true
      count = @@monitor.mon_count
      @@monitor.mon_count = 0
      @@monitor.mon_owner = nil
      if @@monitor.mon_waiting_queue.empty?
	t = @@monitor.mon_entering_queue.shift
      else
	t = @@monitor.mon_waiting_queue.shift
      end
      t.wakeup if t
      @@waiters.push(Thread.current)

      begin
	Thread.stop
      rescue Timeout
      ensure
	Thread.critical = true
	if timeout && timeout_thread.alive?
	  Thread.kill(timeout_thread)
	end
	if @@waiters.include?(Thread.current)  # interrupted?
	  @@waiters.delete(Thread.current)
	end
	while @@monitor.mon_owner &&
	    @@monitor.mon_owner != Thread.current
	  @@monitor.mon_waiting_queue.push(Thread.current)
	  Thread.stop
	  Thread.critical = true
	end
	@@monitor.mon_owner = Thread.current
	@@monitor.mon_count = count
	Thread.critical = false
      end
    end
    
    def wait_while
      while yield
	wait
      end
    end
    
    def wait_until
      until yield
	wait
      end
    end
    
    def signal
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      Thread.critical = true
      t = @@waiters.shift
      t.wakeup if t
      Thread.critical = false
      Thread.pass
    end
    
    def broadcast
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      Thread.critical = true
      for t in @@waiters
	t.wakeup
      end
      @@waiters.clear
      Thread.critical = false
      Thread.pass
    end
    
    def count_waiters
      return @@waiters.length
    end
    
  private
    def initialize(monitor)
      @@monitor = monitor
      @@waiters = []
    end
  end
  
  include Accessible
  include Initializable
  extend Initializable
  
  def self.extend_object(obj)
    super(obj)
    obj.mon_initialize
  end
  
  def try_mon_enter
    result = false
    Thread.critical = true
    if mon_owner.nil?
      self.mon_owner = Thread.current
    end
    if mon_owner == Thread.current
      self.mon_count += 1
      result = true
    end
    Thread.critical = false
    return result
  end

  def mon_enter
    Thread.critical = true
    while mon_owner != nil && mon_owner != Thread.current
      mon_entering_queue.push(Thread.current)
      Thread.stop
      Thread.critical = true
    end
    self.mon_owner = Thread.current
    self.mon_count += 1
    Thread.critical = false
  end
  
  def mon_exit
    if mon_owner != Thread.current
      raise ThreadError, "current thread not owner"
    end
    Thread.critical = true
    self.mon_count -= 1
    if mon_count == 0
      self.mon_owner = nil
      if mon_waiting_queue.empty?
	t = mon_entering_queue.shift
      else
	t = mon_waiting_queue.shift
      end
    end
    t.wakeup if t
    Thread.critical = false
    Thread.pass
  end

  def mon_synchronize
    mon_enter
    begin
      yield
    ensure
      mon_exit
    end
  end
  alias synchronize mon_synchronize
  
  def new_cond
    return ConditionVariable.new(self)
  end
  
private
  def initialize(*args)
    super
    mon_initialize
  end
end

class Monitor
  include MonitorMixin
  alias try_enter try_mon_enter
  alias enter mon_enter
  alias exit mon_exit
  alias owner mon_owner
end

# Local variables:
# mode: Ruby
# tab-width: 8
# End:
@


1.4
log
@* lib/monitor.rb (wait): ensure reentrance.
@
text
@d72 9
d92 1
a92 8
      
      if timeout
	t = Thread.current
	timeout_thread = Thread.start {
	  sleep(timeout)
	  t.raise(Timeout.new)
	}
      end
a95 1
	@@waiters.delete(Thread.current)
d100 3
@


1.3
log
@* lib/monitor.rb: fixed the example code.
@
text
@d96 1
d100 9
a109 11
      
      Thread.critical = true
      while @@monitor.mon_owner &&
	  @@monitor.mon_owner != Thread.current
	@@monitor.mon_waiting_queue.push(Thread.current)
	Thread.stop
	Thread.critical = true
      end
      @@monitor.mon_owner = Thread.current
      @@monitor.mon_count = count
      Thread.critical = false
@


1.2
log
@1.4.0
@
text
@d3 39
a41 22
monitor.rb
Author: Shugo Maeda <shugo@@netlab.co.jp>
Version: 1.2.1

USAGE:

  foo = Foo.new
  foo.extend(MonitorMixin)
  cond = foo.new_cond

  thread1:
  foo.synchronize {
    ...
    cond.wait_until { foo.done? }
    ...
  }

  thread2:
  foo.synchronize {
    foo.do_something
    cond.signal
  }
@


1.2.4.1
log
@* lib/monitor.rb: fixed the example code.
@
text
@d3 22
a24 39
= monitor.rb

Copyright (C) 2001  Shugo Maeda <shugo@@ruby-lang.org>

This library is distributed under the terms of the Ruby license.
You can freely distribute/modify this library.

== example

This is a simple example.

  require 'monitor.rb'
  
  buf = []
  buf.extend(MonitorMixin)
  empty_cond = buf.new_cond
  
  # consumer
  Thread.start do
    loop do
      buf.synchronize do
        empty_cond.wait_while { buf.empty? }
        print buf.shift
      end
    end
  end
  
  # producer
  while line = ARGF.gets
    buf.synchronize do
      buf.push(line)
      empty_cond.signal
    end
  end

The consumer thread waits for the producer thread to push a line
to buf while buf.empty?, and the producer thread (main thread)
reads a line from ARGF and push it to buf, then call
empty_cond.signal.
@


1.2.4.2
log
@* lib/monitor.rb (wait): ensure reentrance.
@
text
@a95 1
	Thread.critical = true
a98 9
	while @@monitor.mon_owner &&
	    @@monitor.mon_owner != Thread.current
	  @@monitor.mon_waiting_queue.push(Thread.current)
	  Thread.stop
	  Thread.critical = true
	end
	@@monitor.mon_owner = Thread.current
	@@monitor.mon_count = count
	Thread.critical = false
d100 11
@


1.2.4.3
log
@* lib/monitor.rb (wait): fix timeout support.
@
text
@a71 9
      if timeout
	ct = Thread.current
	timeout_thread = Thread.start {
	  Thread.pass
	  sleep(timeout)
	  ct.raise(Timeout.new)
	}
      end

d83 8
a90 1

d94 1
a98 3
	end
	if @@waiters.include?(Thread.current)  # interrupted?
	  @@waiters.delete(Thread.current)
@


1.1
log
@file monitor.rb was initially added on branch v1_1r.
@
text
@d1 229
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@a0 325
## monitor.rb

# Author: Shugo Maeda <shugo@@po.aianet.ne.jp>
# Version: $Revision: 0.1 $

# USAGE:
#
#   foo = Foo.new
#   foo.extend(MonitorMixin)
#   cond = foo.new_cond
#
#   thread1:
#   foo.synchronize {
#     ...
#     cond.wait_until { foo.done? }
#     ...
#   }
#
#   thread2:
#   foo.synchronize {
#     foo.do_something
#     cond.signal
#   }

# ATTENTION:
#
#   If you include MonitorMixin and override `initialize', you should
#   call `super'.
#   If you include MonitorMixin to built-in classes, you should override
#   `new' to call `mon_initialize'.

## Code:
  
require "final"

module MonitorMixin
  
  RCS_ID = %q$Id: monitor.rb,v 0.1 1998/03/01 08:40:18 shugo Exp shugo $
  
  module Primitive
    
    include MonitorMixin
    
    MON_OWNER_TABLE = {}
    MON_COUNT_TABLE = {}
    MON_ENTERING_QUEUE_TABLE = {}
    MON_WAITING_QUEUE_TABLE = {}
    
    FINALIZER = Proc.new { |id|
      MON_OWNER_TABLE.delete(id)
      MON_COUNT_TABLE.delete(id)
      MON_ENTERING_QUEUE_TABLE.delete(id)
      MON_WAITING_QUEUE_TABLE.delete(id)
    }
  
    def self.extend_object(obj)
      super(obj)
      obj.mon_initialize
    end
    
    def mon_initialize
      MON_OWNER_TABLE[id] = nil
      MON_COUNT_TABLE[id] = 0
      MON_ENTERING_QUEUE_TABLE[id] = []
      MON_WAITING_QUEUE_TABLE[id] = []
      ObjectSpace.define_finalizer(self, FINALIZER)
    end
    
    def mon_owner
      return MON_OWNER_TABLE[id]
    end
    
    def mon_count
      return MON_COUNT_TABLE[id]
    end
    
    def mon_entering_queue
      return MON_ENTERING_QUEUE_TABLE[id]
    end
    
    def mon_waiting_queue
      return MON_WAITING_QUEUE_TABLE[id]
    end
    
    def set_mon_owner(val)
      return MON_OWNER_TABLE[id] = val
    end
    
    def set_mon_count(val)
      return MON_COUNT_TABLE[id] = val
    end
    
    private :mon_count, :mon_entering_queue, :mon_waiting_queue,
      :set_mon_owner, :set_mon_count
  end
  
  module NonPrimitive
    
    include MonitorMixin
      
    attr_reader :mon_owner, :mon_count,
      :mon_entering_queue, :mon_waiting_queue
  
    def self.extend_object(obj)
      super(obj)
      obj.mon_initialize
    end
  
    def mon_initialize
      @@mon_owner = nil
      @@mon_count = 0
      @@mon_entering_queue = []
      @@mon_waiting_queue = []
    end
    
    def set_mon_owner(val)
      @@mon_owner = val
    end
    
    def set_mon_count(val)
      @@mon_count = val
    end
    
    private :mon_count, :mon_entering_queue, :mon_waiting_queue,
      :set_mon_owner, :set_mon_count
  end
  
  def self.extendable_module(obj)
    if Fixnum === obj or TrueClass === obj or FalseClass === obj or
	NilClass === obj
      raise TypeError, "MonitorMixin can't extend #{obj.type}"
    else
      begin
	obj.instance_eval("@@mon_owner")
	return NonPrimitive
      rescue TypeError
	return Primitive
      end
    end
  end
  
  def self.extend_object(obj)
    obj.extend(extendable_module(obj))
  end
  
  def self.includable_module(klass)
    if klass.instance_of?(Module)
      return NonPrimitive
    end
    begin
      dummy = klass.new
      return extendable_module(dummy)
    rescue ArgumentError
      if klass.singleton_methods.include?("new")
	return Primitive
      else
	return NonPrimitive
      end
    rescue NameError
      raise TypeError, "#{klass} can't include MonitorMixin"
    end
  end
  
  def self.append_features(klass)
    mod = includable_module(klass)
    klass.module_eval("include mod")
  end
  
  def initialize(*args)
    super
    mon_initialize
  end
  
  def try_mon_enter
    result = false
    Thread.critical = true
    if mon_owner.nil?
      set_mon_owner(Thread.current)
    end
    if mon_owner == Thread.current
      set_mon_count(mon_count + 1)
      result = true
    end
    Thread.critical = false
    return result
  end

  def mon_enter
    Thread.critical = true
    while mon_owner != nil && mon_owner != Thread.current
      mon_entering_queue.push(Thread.current)
      Thread.stop
      Thread.critical = true
    end
    set_mon_owner(Thread.current)
    set_mon_count(mon_count + 1)
    Thread.critical = false
  end
  
  def mon_exit
    if mon_owner != Thread.current
      raise ThreadError, "current thread not owner"
    end
    Thread.critical = true
    set_mon_count(mon_count - 1)
    if mon_count == 0
      set_mon_owner(nil)
      if mon_waiting_queue.empty?
	t = mon_entering_queue.shift
      else
	t = mon_waiting_queue.shift
      end
    end
    t.wakeup if t
    Thread.critical = false
    Thread.pass
  end

  def mon_synchronize
    mon_enter
    begin
      yield
    ensure
      mon_exit
    end
  end
  alias synchronize mon_synchronize

  class ConditionVariable
    def initialize(monitor)
      @@monitor = monitor
      @@waiters = []
    end
    
    def wait
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      
      @@monitor.instance_eval(<<MON_EXIT)
      Thread.critical = true
      _count = mon_count
      set_mon_count(0)
      set_mon_owner(nil)
      if mon_waiting_queue.empty?
	t = mon_entering_queue.shift
      else
	t = mon_waiting_queue.shift
      end
      t.wakeup if t
      Thread.critical = false
MON_EXIT
      
      Thread.critical = true
      @@waiters.push(Thread.current)
      Thread.stop
      
      @@monitor.instance_eval(<<MON_ENTER)
      Thread.critical = true
      while mon_owner != nil && mon_owner != Thread.current
	mon_waiting_queue.push(Thread.current)
	Thread.stop
	Thread.critical = true
      end
      set_mon_owner(Thread.current)
      set_mon_count(_count)
      Thread.critical = false
MON_ENTER
    end
    
    def wait_while
      while yield
	wait
      end
    end
    
    def wait_until
      until yield
	wait
      end
    end
    
    def signal
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      Thread.critical = true
      t = @@waiters.shift
      t.wakeup if t
      Thread.critical = false
      Thread.pass
    end
    
    def broadcast
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      Thread.critical = true
      for t in @@waiters
	t.wakeup
      end
      @@waiters.clear
      Thread.critical = false
      Thread.pass
    end
    
    def count_waiters
      return @@waiters.length
    end
  end
  
  def new_cond
    return ConditionVariable.new(self)
  end
end

class Monitor
  include MonitorMixin
  alias try_enter try_mon_enter
  alias enter mon_enter
  alias exit mon_exit
  alias owner mon_owner
end

## monitor.rb ends here
@


1.1.1.1.2.1
log
@990324
@
text
@d1 1
a1 1
=begin
d3 2
a4 22
monitor.rb
Author: Shugo Maeda <shugo@@netlab.co.jp>
Version: 1.2.1

USAGE:

  foo = Foo.new
  foo.extend(MonitorMixin)
  cond = foo.new_cond

  thread1:
  foo.synchronize {
    ...
    cond.wait_until { foo.done? }
    ...
  }

  thread2:
  foo.synchronize {
    foo.do_something
    cond.signal
  }
d6 27
a32 1
=end
d34 2
a36 5
  module Accessible
  protected
    attr_accessor :mon_owner, :mon_count
    attr_reader :mon_entering_queue, :mon_waiting_queue
  end
d38 23
a60 2
  module Initializable
  protected
d62 9
a70 4
      @@mon_owner = nil
      @@mon_count = 0
      @@mon_entering_queue = []
      @@mon_waiting_queue = []
a71 4
  end
  
  class ConditionVariable
    class Timeout < Exception; end
d73 3
a75 1
    include Accessible
d77 2
a78 44
    def wait(timeout = nil)
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      
      Thread.critical = true
      count = @@monitor.mon_count
      @@monitor.mon_count = 0
      @@monitor.mon_owner = nil
      if @@monitor.mon_waiting_queue.empty?
	t = @@monitor.mon_entering_queue.shift
      else
	t = @@monitor.mon_waiting_queue.shift
      end
      t.wakeup if t
      @@waiters.push(Thread.current)
      
      if timeout
	t = Thread.current
	timeout_thread = Thread.start {
	  sleep(timeout)
	  t.raise(Timeout.new)
	}
      end
      begin
	Thread.stop
      rescue Timeout
	@@waiters.delete(Thread.current)
      ensure
	if timeout && timeout_thread.alive?
	  Thread.kill(timeout_thread)
	end
      end
      
      Thread.critical = true
      while @@monitor.mon_owner &&
	  @@monitor.mon_owner != Thread.current
	@@monitor.mon_waiting_queue.push(Thread.current)
	Thread.stop
	Thread.critical = true
      end
      @@monitor.mon_owner = Thread.current
      @@monitor.mon_count = count
      Thread.critical = false
d81 2
a82 4
    def wait_while
      while yield
	wait
      end
d85 2
a86 4
    def wait_until
      until yield
	wait
      end
d89 2
a90 9
    def signal
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      Thread.critical = true
      t = @@waiters.shift
      t.wakeup if t
      Thread.critical = false
      Thread.pass
d93 21
a113 11
    def broadcast
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      Thread.critical = true
      for t in @@waiters
	t.wakeup
      end
      @@waiters.clear
      Thread.critical = false
      Thread.pass
d116 2
a117 2
    def count_waiters
      return @@waiters.length
d120 2
a121 4
  private
    def initialize(monitor)
      @@monitor = monitor
      @@waiters = []
d123 3
d128 13
a140 3
  include Accessible
  include Initializable
  extend Initializable
d143 29
a171 2
    super(obj)
    obj.mon_initialize
d178 1
a178 1
      self.mon_owner = Thread.current
d181 1
a181 1
      self.mon_count += 1
d195 2
a196 2
    self.mon_owner = Thread.current
    self.mon_count += 1
d205 1
a205 1
    self.mon_count -= 1
d207 1
a207 1
      self.mon_owner = nil
d228 83
a314 6
  
private
  def initialize(*args)
    super
    mon_initialize
  end
d325 1
a325 4
# Local variables:
# mode: Ruby
# tab-width: 8
# End:
@


1.1.2.1
log
@*** empty log message ***
@
text
@a0 325
## monitor.rb

# Author: Shugo Maeda <shugo@@po.aianet.ne.jp>
# Version: $Revision: 0.1 $

# USAGE:
#
#   foo = Foo.new
#   foo.extend(MonitorMixin)
#   cond = foo.new_cond
#
#   thread1:
#   foo.synchronize {
#     ...
#     cond.wait_until { foo.done? }
#     ...
#   }
#
#   thread2:
#   foo.synchronize {
#     foo.do_something
#     cond.signal
#   }

# ATTENTION:
#
#   If you include MonitorMixin and override `initialize', you should
#   call `super'.
#   If you include MonitorMixin to built-in classes, you should override
#   `new' to call `mon_initialize'.

## Code:
  
require "final"

module MonitorMixin
  
  RCS_ID = %q$Id: monitor.rb,v 0.1 1998/03/01 08:40:18 shugo Exp shugo $
  
  module Primitive
    
    include MonitorMixin
    
    MON_OWNER_TABLE = {}
    MON_COUNT_TABLE = {}
    MON_ENTERING_QUEUE_TABLE = {}
    MON_WAITING_QUEUE_TABLE = {}
    
    FINALIZER = Proc.new { |id|
      MON_OWNER_TABLE.delete(id)
      MON_COUNT_TABLE.delete(id)
      MON_ENTERING_QUEUE_TABLE.delete(id)
      MON_WAITING_QUEUE_TABLE.delete(id)
    }
  
    def self.extend_object(obj)
      super(obj)
      obj.mon_initialize
    end
    
    def mon_initialize
      MON_OWNER_TABLE[id] = nil
      MON_COUNT_TABLE[id] = 0
      MON_ENTERING_QUEUE_TABLE[id] = []
      MON_WAITING_QUEUE_TABLE[id] = []
      ObjectSpace.define_finalizer(self, FINALIZER)
    end
    
    def mon_owner
      return MON_OWNER_TABLE[id]
    end
    
    def mon_count
      return MON_COUNT_TABLE[id]
    end
    
    def mon_entering_queue
      return MON_ENTERING_QUEUE_TABLE[id]
    end
    
    def mon_waiting_queue
      return MON_WAITING_QUEUE_TABLE[id]
    end
    
    def set_mon_owner(val)
      return MON_OWNER_TABLE[id] = val
    end
    
    def set_mon_count(val)
      return MON_COUNT_TABLE[id] = val
    end
    
    private :mon_count, :mon_entering_queue, :mon_waiting_queue,
      :set_mon_owner, :set_mon_count
  end
  
  module NonPrimitive
    
    include MonitorMixin
      
    attr_reader :mon_owner, :mon_count,
      :mon_entering_queue, :mon_waiting_queue
  
    def self.extend_object(obj)
      super(obj)
      obj.mon_initialize
    end
  
    def mon_initialize
      @@mon_owner = nil
      @@mon_count = 0
      @@mon_entering_queue = []
      @@mon_waiting_queue = []
    end
    
    def set_mon_owner(val)
      @@mon_owner = val
    end
    
    def set_mon_count(val)
      @@mon_count = val
    end
    
    private :mon_count, :mon_entering_queue, :mon_waiting_queue,
      :set_mon_owner, :set_mon_count
  end
  
  def self.extendable_module(obj)
    if Fixnum === obj or TrueClass === obj or FalseClass === obj or
	NilClass === obj
      raise TypeError, "MonitorMixin can't extend #{obj.type}"
    else
      begin
	obj.instance_eval("@@mon_owner")
	return NonPrimitive
      rescue TypeError
	return Primitive
      end
    end
  end
  
  def self.extend_object(obj)
    obj.extend(extendable_module(obj))
  end
  
  def self.includable_module(klass)
    if klass.instance_of?(Module)
      return NonPrimitive
    end
    begin
      dummy = klass.new
      return extendable_module(dummy)
    rescue ArgumentError
      if klass.singleton_methods.include?("new")
	return Primitive
      else
	return NonPrimitive
      end
    rescue NameError
      raise TypeError, "#{klass} can't include MonitorMixin"
    end
  end
  
  def self.append_features(klass)
    mod = includable_module(klass)
    klass.module_eval("include mod")
  end
  
  def initialize(*args)
    super
    mon_initialize
  end
  
  def try_mon_enter
    result = false
    Thread.critical = true
    if mon_owner.nil?
      set_mon_owner(Thread.current)
    end
    if mon_owner == Thread.current
      set_mon_count(mon_count + 1)
      result = true
    end
    Thread.critical = false
    return result
  end

  def mon_enter
    Thread.critical = true
    while mon_owner != nil && mon_owner != Thread.current
      mon_entering_queue.push(Thread.current)
      Thread.stop
      Thread.critical = true
    end
    set_mon_owner(Thread.current)
    set_mon_count(mon_count + 1)
    Thread.critical = false
  end
  
  def mon_exit
    if mon_owner != Thread.current
      raise ThreadError, "current thread not owner"
    end
    Thread.critical = true
    set_mon_count(mon_count - 1)
    if mon_count == 0
      set_mon_owner(nil)
      if mon_waiting_queue.empty?
	t = mon_entering_queue.shift
      else
	t = mon_waiting_queue.shift
      end
    end
    t.wakeup if t
    Thread.critical = false
    Thread.pass
  end

  def mon_synchronize
    mon_enter
    begin
      yield
    ensure
      mon_exit
    end
  end
  alias synchronize mon_synchronize

  class ConditionVariable
    def initialize(monitor)
      @@monitor = monitor
      @@waiters = []
    end
    
    def wait
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      
      @@monitor.instance_eval(<<MON_EXIT)
      Thread.critical = true
      _count = mon_count
      set_mon_count(0)
      set_mon_owner(nil)
      if mon_waiting_queue.empty?
	t = mon_entering_queue.shift
      else
	t = mon_waiting_queue.shift
      end
      t.wakeup if t
      Thread.critical = false
MON_EXIT
      
      Thread.critical = true
      @@waiters.push(Thread.current)
      Thread.stop
      
      @@monitor.instance_eval(<<MON_ENTER)
      Thread.critical = true
      while mon_owner != nil && mon_owner != Thread.current
	mon_waiting_queue.push(Thread.current)
	Thread.stop
	Thread.critical = true
      end
      set_mon_owner(Thread.current)
      set_mon_count(_count)
      Thread.critical = false
MON_ENTER
    end
    
    def wait_while
      while yield
	wait
      end
    end
    
    def wait_until
      until yield
	wait
      end
    end
    
    def signal
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      Thread.critical = true
      t = @@waiters.shift
      t.wakeup if t
      Thread.critical = false
      Thread.pass
    end
    
    def broadcast
      if @@monitor.mon_owner != Thread.current
	raise ThreadError, "current thread not owner"
      end
      Thread.critical = true
      for t in @@waiters
	t.wakeup
      end
      @@waiters.clear
      Thread.critical = false
      Thread.pass
    end
    
    def count_waiters
      return @@waiters.length
    end
  end
  
  def new_cond
    return ConditionVariable.new(self)
  end
end

class Monitor
  include MonitorMixin
  alias try_enter try_mon_enter
  alias enter mon_enter
  alias exit mon_exit
  alias owner mon_owner
end

## monitor.rb ends here
@
