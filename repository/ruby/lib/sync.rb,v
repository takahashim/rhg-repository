head	1.4;
access;
symbols
	v1_6_7:1.2
	v1_6_6:1.2
	v1_6_5:1.2
	v1_6_4:1.2
	v1_7_1:1.3
	v1_6_4_preview4:1.2
	v1_6_4_preview3:1.2
	v1_6_4_preview2:1.2
	v1_6_4_preview1:1.2
	v1_6_3:1.2
	ruby_m17n:1.2.0.6
	ruby_1_6:1.2.0.4
	v1_6_2:1.2
	v1_6_1:1.2
	v1_6_0:1.2
	v1_4_6:1.2
	v1_4_5:1.2
	v1_4_4:1.2
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.2
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.2
	v1_3_6_repack:1.1.1.3.2.2
	v1_3_6:1.1.1.3.2.2
	v1_3_5:1.1.1.3.2.2
	v1_2_6repack:1.1.1.2.2.5
	v1_3_4_990625:1.1.1.3.2.2
	v1_3_4_990624:1.1.1.3.2.2
	v1_2_6:1.1.1.2.2.5
	v1_3_4_990611:1.1.1.3.2.2
	v1_3_4_990531:1.1.1.3.2.2
	v1_3_3_990518:1.1.1.3.2.2
	v1_3_3_990513:1.1.1.3.2.2
	v1_3_3_990507:1.1.1.3.2.2
	v1_2_5:1.1.1.2.2.5
	v1_2_4:1.1.1.2.2.5
	v1_3_1_990225:1.1.1.3.2.1
	v1_3_1_990224:1.1.1.3.2.1
	v1_3_1_990215:1.1.1.3.2.1
	v1_3_1_990212:1.1.1.3.2.1
	v1_3_1_990210:1.1.1.3.2.1
	v1_3_1_:1.1.1.3.2.1
	v1_3_1_990209:1.1.1.3.2.1
	v1_3_1_990205:1.1.1.3
	v1_3_1_990203:1.1.1.3
	v1_3_1_990201:1.1.1.3
	v1_3_1"_990201:1.1.1.3
	v1_3_1_990128:1.1.1.3
	v1_3_1_990127:1.1.1.3
	v1_3_1_990126:1.1.1.3
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.5
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.5
	v1_2_1repack:1.1.1.2.2.5
	v1_2_1:1.1.1.2.2.5
	v1_2_stable:1.1.1.2.2.5
	v1_1d1:1.1.1.2.2.5
	v1_1d0:1.1.1.2.2.5
	v1_1c9_1:1.1.1.2.2.5
	v1_1c9:1.1.1.2.2.5
	v1_1c8:1.1.1.2.2.5
	v1_1c7:1.1.1.2.2.5
	v1_1c6:1.1.1.2.2.5
	v1_1d-start:1.1.1.2.2.5
	v1_1c5:1.1.1.2.2.5
	v1_1dev:1.1.1.2.2.5.0.2
	v1_1c4:1.1.1.2.2.5
	v1_1c3:1.1.1.2.2.5
	v1_1c2:1.1.1.2.2.5
	v1_1c1:1.1.1.2.2.5
	v1_1c0:1.1.1.2.2.5
	v1_1b9_31:1.1.1.2.2.5
	v1_1b9_30:1.1.1.2.2.5
	v1_1b9_28:1.1.1.2.2.5
	v1_1b9_27:1.1.1.2.2.5
	v1_1b9_26:1.1.1.2.2.5
	r1_1b9_25:1.1.1.2.2.5
	r1_1b9_24:1.1.1.2.2.5
	v1_1b9_23:1.1.1.2.2.5
	v1_1b9_22:1.1.1.2.2.5
	v1_1b9_20:1.1.1.2.2.5
	v1_1b9_18:1.1.1.2.2.5
	v1_1b9_16:1.1.1.2.2.4
	v1_1b9_15:1.1.1.2.2.4
	v1_1b9_13:1.1.1.2.2.4
	v1_1b9_12:1.1.1.2.2.4
	v1_1b9_11:1.1.1.2.2.4
	v1_1b9_08:1.1.1.2.2.4
	v1_1b9_07:1.1.1.2.2.4
	r1_1b9:1.1.1.2.2.3
	v1_1b8:1.1.1.2.2.3
	v1_1b7:1.1.1.2.2.3
	v1_1b6:1.1.1.2.2.2
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2001.06.06.14.19.33;	author keiju;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.06.15.04.52;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.17;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.17;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.35;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.02.09.06.08.24;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.03.24.08.52.35;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.36.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.19.05.08.25;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.02.06.10.03.24;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.03.03.02.39.34;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.05.01.08.56.44;	author matz;	state Exp;
branches;
next	;


desc
@@


1.4
log
@
* lib/sync.rb: bug fix if obj.initialize has parameters when
  obj.extend(Sync_m)

* lib/mutex_m.rb: modified bit
@
text
@#
#   sync.rb - 2 phase lock with counter
#   	$Release Version: 1.0$
#   	$Revision: 1.8 $
#   	$Date: 1998/01/09 08:08:51 $
#   	by Keiju ISHITSUKA(keiju@@ishitsuka.com)
#
# --
#  Sync_m, Synchronizer_m
#  Usage:
#   obj.extend(Sync_m)
#   or
#   class Foo
#	include Sync_m
#	:
#   end
#
#   Sync_m#sync_mode
#   Sync_m#sync_locked?, locked?
#   Sync_m#sync_shared?, shared?
#   Sync_m#sync_exclusive?, sync_exclusive?
#   Sync_m#sync_try_lock, try_lock
#   Sync_m#sync_lock, lock
#   Sync_m#sync_unlock, unlock
#
#   Sync, Synchronicer:
#	include Sync_m
#   Usage:
#   sync = Sync.new
#
#   Sync#mode
#   Sync#locked?
#   Sync#shared?
#   Sync#exclusive?
#   Sync#try_lock(mode) -- mode = :EX, :SH, :UN
#   Sync#lock(mode)     -- mode = :EX, :SH, :UN
#   Sync#unlock
#   Sync#synchronize(mode) {...}
#   
#

unless defined? Thread
  fail "Thread not available for this ruby interpreter"
end

module Sync_m
  RCS_ID='-$Header: /home/keiju/var/src/var.lib/ruby/RCS/sync.rb,v 1.8 1998/01/09 08:08:51 keiju Exp keiju $-'
  
  # lock mode
  UN = :UN
  SH = :SH
  EX = :EX
  
  # exceptions
  class Err < StandardError
    def Err.Fail(*opt)
      fail self, sprintf(self::Message, *opt)
    end
    
    class UnknownLocker < Err
      Message = "Thread(%s) not locked."
      def UnknownLocker.Fail(th)
	super(th.inspect)
      end
    end
    
    class LockModeFailer < Err
      Message = "Unknown lock mode(%s)"
      def LockModeFailer.Fail(mode)
	if mode.id2name
	  mode = id2name
	end
	super(mode)
      end
    end
  end
  
  def Sync_m.define_aliases(cl)
    cl.module_eval %q{
      alias locked? sync_locked?
      alias shared? sync_shared?
      alias exclusive? sync_exclusive?
      alias lock sync_lock
      alias unlock sync_unlock
      alias try_lock sync_try_lock
      alias synchronize sync_synchronize
    }
  end
  
  def Sync_m.append_features(cl)
    super
    unless cl.instance_of?(Module)
      # do nothing for Modules
      # make aliases and include the proper module.
      define_aliases(cl)
    end
  end
  
  def Sync_m.extend_object(obj)
    super
    obj.sync_extended
  end

  def sync_extended
    unless (defined? locked? and
	    defined? shared? and
	    defined? exclusive? and
	    defined? lock and
	    defined? unlock and
	    defined? try_lock and
	    defined? synchronize)
      Sync_m.define_aliases(class<<self;self;end)
    end
    sync_initialize
  end

  # accessing
  def sync_locked?
    sync_mode != UN
  end
  
  def sync_shared?
    sync_mode == SH
  end
  
  def sync_exclusive?
    sync_mode == EX
  end
  
  # locking methods.
  def sync_try_lock(mode = EX)
    return unlock if sync_mode == UN
    
    Thread.critical = true
    ret = sync_try_lock_sub(sync_mode)
    Thread.critical = false
    ret
  end
  
  def sync_lock(m = EX)
    return unlock if m == UN

    until (Thread.critical = true; sync_try_lock_sub(m))
      if sync_sh_locker[Thread.current]
	sync_upgrade_waiting.push [Thread.current, sync_sh_locker[Thread.current]]
	sync_sh_locker.delete(Thread.current)
      else
	sync_waiting.push Thread.current
      end
      Thread.stop
    end
    Thread.critical = false
    self
  end
  
  def sync_unlock(m = EX)
    Thread.critical = true
    if sync_mode == UN
      Thread.critical = false
      Err::UnknownLocker.Fail(Thread.current)
    end
    
    m = sync_mode if m == EX and sync_mode == SH
    
    runnable = false
    case m
    when UN
      Thread.critical = false
      Err::UnknownLocker.Fail(Thread.current)
      
    when EX
      if sync_ex_locker == Thread.current
	if (self.sync_ex_count = sync_ex_count - 1) == 0
	  self.sync_ex_locker = nil
	  if sync_sh_locker.include?(Thread.current)
	    self.sync_mode = SH
	  else
	    self.sync_mode = UN
	  end
	  runnable = true
	end
      else
	Err::UnknownLocker.Fail(Thread.current)
      end
      
    when SH
      if (count = sync_sh_locker[Thread.current]).nil?
	Err::UnknownLocker.Fail(Thread.current)
      else
	if (sync_sh_locker[Thread.current] = count - 1) == 0 
	  sync_sh_locker.delete(Thread.current)
	  if sync_sh_locker.empty? and sync_ex_count == 0
	    self.sync_mode = UN
	    runnable = true
	  end
	end
      end
    end
    
    if runnable
      if sync_upgrade_waiting.size > 0
	for k, v in sync_upgrade_waiting
	  sync_sh_locker[k] = v
	end
	wait = sync_upgrade_waiting
	self.sync_upgrade_waiting = []
	Thread.critical = false
	
	for w, v in wait
	  w.run
	end
      else
	wait = sync_waiting
	self.sync_waiting = []
	Thread.critical = false
	for w in wait
	  w.run
	end
      end
    end
    
    Thread.critical = false
    self
  end
  
  def sync_synchronize(mode = EX)
    begin
      sync_lock(mode)
      yield
    ensure
      sync_unlock
    end
  end

  attr :sync_mode, true
    
  attr :sync_waiting, true
  attr :sync_upgrade_waiting, true
  attr :sync_sh_locker, true
  attr :sync_ex_locker, true
  attr :sync_ex_count, true
    
  private

  def sync_initialize
    @@sync_mode = UN
    @@sync_waiting = []
    @@sync_upgrade_waiting = []
    @@sync_sh_locker = Hash.new
    @@sync_ex_locker = nil
    @@sync_ex_count = 0
  end

  def initialize(*args)
    sync_initialize
    super
  end
    
  def sync_try_lock_sub(m)
    case m
    when SH
      case sync_mode
      when UN
	self.sync_mode = m
	sync_sh_locker[Thread.current] = 1
	ret = true
      when SH
	count = 0 unless count = sync_sh_locker[Thread.current]
	sync_sh_locker[Thread.current] = count + 1
	ret = true
      when EX
	# in EX mode, lock will upgrade to EX lock
	if sync_ex_locker == Thread.current
	  self.sync_ex_count = sync_ex_count + 1
	  ret = true
	else
	  ret = false
	end
      end
    when EX
      if sync_mode == UN or
	sync_mode == SH && sync_sh_locker.size == 1 && sync_sh_locker.include?(Thread.current) 
	self.sync_mode = m
	self.sync_ex_locker = Thread.current
	self.sync_ex_count = 1
	ret = true
      elsif sync_mode == EX && sync_ex_locker == Thread.current
	self.sync_ex_count = sync_ex_count + 1
	ret = true
      else
	ret = false
      end
    else
      Thread.critical = false
      Err::LockModeFailer.Fail mode
    end
    return ret
  end
end
Synchronizer_m = Sync_m

class Sync
  #Sync_m.extend_class self
  include Sync_m
    
  def initialize
    super
  end
    
end
Synchronizer = Sync
@


1.3
log
@forgot some checkins.
@
text
@d3 4
a6 5
#   	$Release Version: 0.2$
#   	$Revision: 1.2 $
#   	$Date: 1999/08/13 05:45:17 $
#   	by Keiju ISHITSUKA
#   	modified by matz
d14 1
a14 1
#	Sync_m.include_to self
d47 1
a47 1
  RCS_ID='-$Header: /ruby/ruby/lib/sync.rb,v 1.2 1999/08/13 05:45:17 matz Exp $-'
d78 14
a91 1
  def Sync_m.included(cl)
d95 1
a95 9
      cl.module_eval %q{
	alias locked? sync_locked?
	alias shared? sync_shared?
	alias exclusive? sync_exclusive?
	alias lock sync_lock
	alias unlock sync_unlock
	alias try_lock sync_try_lock
	alias synchronize sync_synchronize
      }
a96 1
    return self
d103 1
a103 1
  
d112 1
a112 9
      eval "class << self
	alias locked? sync_locked?
        alias shared? sync_shared?
        alias exclusive? sync_exclusive?
	alias lock sync_lock
	alias unlock sync_unlock
	alias try_lock sync_try_lock
	alias synchronize sync_synchronize
      end"
d114 1
a114 1
    initialize
d116 1
a116 1
  
a226 1
    sync_lock(mode)
d228 1
d234 1
a234 1
  
d236 1
d242 1
a242 1

d245 1
a245 2
  def initialize(*args)
    ret = super
a251 1
    return ret
d253 6
a258 1
  
d303 1
a304 2
  
  private
d309 1
@


1.2
log
@1.4.0
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.3.2.2 $
#   	$Date: 1999/03/24 08:52:35 $
d48 1
a48 1
  RCS_ID='-$Header: /home/cvs/ruby/lib/sync.rb,v 1.1.1.3.2.2 1999/03/24 08:52:35 matz Exp $-'
d79 1
a79 2
  def Sync_m.append_features(cl)
    super
@


1.1
log
@Initial revision
@
text
@d2 4
a5 4
#   sync.rb - カウント付2-フェーズロッククラス
#   	$Release Version: 0.1$
#   	$Revision: 1.3 $
#   	$Date: 1997/08/18 07:17:08 $
d7 1
d10 1
d12 6
a17 1
#   Sync_m, Synchronizer_m
d29 2
a31 1
#   sync = Sync.new
a46 2
require "finalize.rb"

d48 1
a48 1
  RCS_ID='-$Header: /home/keiju/var/src/var.lib/ruby/RCS/sync.rb,v 1.3 1997/08/18 07:17:08 keiju Exp keiju $-'
d50 1
d55 2
a56 1
  class Err < Exception
d79 18
d98 2
a99 12
    if Fixnum === obj or TRUE === obj or FALSE === obj or nil == obj
      raise TypeError, "Sync_m can't extend to this class(#{obj.type})"
    else
      begin
	eval "class << obj
		@@sync_locked
	      end"
	obj.extend(For_primitive_object)
      rescue TypeError
	obj.extend(For_general_object)
      end
    end
d113 1
a113 1
        alias excluive? sync_exclusive?
d120 1
d123 1
d136 1
d140 1
a140 1
    Thread.critical = TRUE
d142 1
a142 1
    Thread.critical = FALSE
d149 1
a149 1
    until (Thread.critical = TRUE; sync_try_lock_sub(m))
d158 1
a158 1
    Thread.critical = FALSE
d163 1
a163 1
    Thread.critical = TRUE
d165 1
a165 1
      Thread.critical = FALSE
d171 1
a171 1
    runnable = FALSE
d174 1
a174 1
      Thread.critical = FALSE
d186 1
a186 1
	  runnable = TRUE
d200 1
a200 1
	    runnable = TRUE
d213 1
a213 1
	Thread.critical = FALSE
d221 1
a221 1
	Thread.critical = FALSE
d228 1
a228 1
    Thread.critical = FALSE
d232 29
d268 1
a268 1
	ret = TRUE
d272 1
a272 1
	ret = TRUE
d274 1
a274 1
	# 既に, モードがEXである時は, 必ずEXロックとなる.
d277 1
a277 1
	  ret = TRUE
d279 1
a279 1
	  ret = FALSE
d288 1
a288 2
	ret = TRUE
	
d291 1
a291 1
	ret = TRUE
d293 1
a293 1
	ret = FALSE
d296 1
a296 1
      Thread.critical = FALSE
a300 111
  private :sync_try_lock_sub
  
  def sync_synchronize(mode = EX)
    begin
      sync_lock(mode)
      yield
    ensure
      sync_unlock
    end
  end
  
  module For_primitive_object
    include Sync_m
    
    LockState = Struct.new("LockState",
			   :mode,
			   :waiting,
			   :upgrade_waiting,
			   :sh_locker,
			   :ex_locker,
			   :ex_count)
    
    Sync_Locked = Hash.new
    
    def For_primitive_object.extend_object(obj)
      super
      obj.sync_extended
      Finalizer.add(obj, For_primitive_object, :sync_finalize)
    end
    
    def sync_extended
      super
      Sync_Locked[id] = LockState.new(UN, [], [], Hash.new, nil, 0 )
    end
    
    def sync_finalize
      wait = Sync_Locked.delete(id)
      # waiting == [] ときだけ GCされるので, 待ち行列の解放は意味がない.
    end
    
    def sync_mode
      Sync_Locked[id].mode
    end
    def sync_mode=(value)
      Sync_Locked[id].mode = value
    end

    def sync_waiting
      Sync_Locked[id].waiting
    end
    def sync_waiting=(v)
      Sync_Locked[id].waiting = v
    end
    
    def sync_upgrade_waiting
      Sync_Locked[id].upgrade_waiting
    end
    def sync_upgrade_waiting=(v)
      Sync_Locked[id].upgrade_waiting = v
    end
    
    def sync_sh_locker
      Sync_Locked[id].sh_locker
    end
    def sync_sh_locker=(v)
      Sync_Locked[id].sh_locker = v
    end
    
    def sync_ex_locker
      Sync_Locked[id].ex_locker
    end
    def sync_ex_locker=(value)
      Sync_Locked[id].ex_locker = value
    end
    
    def sync_ex_count
      Sync_Locked[id].ex_count
    end
    def sync_ex_count=(value)
      Sync_Locked[id].ex_count = value
    end
    
  end
  
  module For_general_object
    include Sync_m
    
    def For_general_object.extend_object(obj)
      super
      obj.sync_extended
    end
    
    def sync_extended
      super
      @@sync_mode = UN
      @@sync_waiting = []
      @@sync_upgrade_waiting = []
      @@sync_sh_locker = Hash.new
      @@sync_ex_locker = nil
      @@sync_ex_count = 0
    end
    
    attr :sync_mode, TRUE
    
    attr :sync_waiting, TRUE
    attr :sync_upgrade_waiting, TRUE
    attr :sync_sh_locker, TRUE
    attr :sync_ex_locker, TRUE
    attr :sync_ex_count, TRUE
    
  end
d305 3
a307 1
  include Sync_m::For_general_object
d310 1
a310 1
    sync_extended
a311 1
    
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d3 3
a5 3
#   	$Release Version: 0.2$
#   	$Revision: 1.8 $
#   	$Date: 1998/01/09 08:08:51 $
a8 1
#  Sync_m, Synchronizer_m
d10 1
a10 6
#   obj.extend(Sync_m)
#   or
#   class Foo
#	Sync_m.include_to self
#	:
#   end
d22 1
a22 1
#   Usage:
a23 1
#
d39 1
a39 1
require "finalize"
d42 1
a42 1
  RCS_ID='-$Header: /home/keiju/var/src/var.lib/ruby/RCS/sync.rb,v 1.8 1998/01/09 08:08:51 keiju Exp keiju $-'
a43 1
  # lock mode
a47 1
  # 例外定義
d71 1
a71 2
  # include and extend initialize methods.
  def Sync_m.extendable_module(obj)
d76 4
a79 2
	obj.instance_eval "@@sync_locked"
	For_general_object
d81 1
a81 1
	For_primitive_object
a85 33
  def Sync_m.includable_module(cl)
    begin
      dummy = cl.new
      Sync_m.extendable_module(dummy)
    rescue NameError
      # newが定義されていない時は, DATAとみなす.
      For_primitive_object
    end
  end
  
  def Sync_m.extend_class(cl)
    return super if cl.instance_of?(Module)
    
    # モジュールの時は何もしない. クラスの場合, 適切なモジュールの決定
    # とaliasを行う.  
    real = includable_module(cl)
    cl.module_eval %q{
      include real

      alias locked? sync_locked?
      alias shared? sync_shared?
      alias exclusive? sync_exclusive?
      alias lock sync_lock
      alias unlock sync_unlock
      alias try_lock sync_try_lock
      alias synchronize sync_synchronize
    }
  end
  
  def Sync_m.extend_object(obj)
    obj.extend(Sync_m.extendable_module(obj))
  end
  
d97 1
a97 1
        alias exclusive? sync_exclusive?
a105 1
  # accessing
a117 1
  # locking methods.
d241 1
a264 1
  # internal class
d284 1
a284 1
    def initialize
a286 6
      self
    end
    
    def sync_extended
      super
      initialize
d289 1
a289 1
    def For_primitive_object.sync_finalize(id)
d346 1
a346 1
    def initialize
a353 6
      self
    end
    
    def sync_extended
      super
      initialize
d369 1
a369 2
  Sync_m.extend_class self
  #include Sync_m
d372 1
a372 1
    super
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.2.2.5 $
#   	$Date: 1998/05/01 08:56:44 $
a6 1
#   	modified by matz
d46 1
a46 1
require "final"
d49 1
a49 1
  RCS_ID='-$Header: /home/cvsroot/ruby/lib/sync.rb,v 1.1.1.2.2.5 1998/05/01 08:56:44 matz Exp $-'
d57 1
a57 1
  class Err < StandardError
a298 1
    sync_lock(mode)
d300 1
d324 1
a324 5
      # Changed to use `final.rb'.
      # Finalizer.add(obj, For_primitive_object, :sync_finalize)
      ObjectSpace.define_finalizer(obj) do |id|
	For_primitive_object.sync_finalize(id)
      end
@


1.1.1.3.2.1
log
@990209
@
text
@d2 1
a2 1
#   sync.rb - 2 phase lock with counter
d4 2
a5 2
#   	$Revision: 1.1.1.3 $
#   	$Date: 1999/01/20 04:59:35 $
d50 1
a50 1
  RCS_ID='-$Header: /home/cvsroot/ruby/lib/sync.rb,v 1.1.1.3 1999/01/20 04:59:35 matz Exp $-'
d57 1
a57 1
  # exceptions
d100 1
a100 1
      # if new is not defined, cl must be Data.
d108 2
a109 2
    # do nothing for Modules
    # make aliases and include the proper module.
d270 1
a270 1
	# in EX mode, lock will upgrade to EX lock
d345 1
a345 1
      # need not to free waiting
@


1.1.1.3.2.2
log
@990324
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.3.2.1 $
#   	$Date: 1999/02/09 06:08:24 $
d47 2
d50 1
a50 1
  RCS_ID='-$Header: /home/cvsroot/ruby/lib/sync.rb,v 1.1.1.3.2.1 1999/02/09 06:08:24 matz Exp $-'
d81 21
a101 14
  def Sync_m.append_features(cl)
    super
    unless cl.instance_of?(Module)
      # do nothing for Modules
      # make aliases and include the proper module.
      cl.module_eval %q{
	alias locked? sync_locked?
	alias shared? sync_shared?
	alias exclusive? sync_exclusive?
	alias lock sync_lock
	alias unlock sync_unlock
	alias try_lock sync_try_lock
	alias synchronize sync_synchronize
      }
d103 19
a121 1
    return self
d125 1
a125 2
    super
    obj.sync_extended
a145 1
    initialize
d165 1
a165 1
    Thread.critical = true
d167 1
a167 1
    Thread.critical = false
d174 1
a174 1
    until (Thread.critical = true; sync_try_lock_sub(m))
d183 1
a183 1
    Thread.critical = false
d188 1
a188 1
    Thread.critical = true
d190 1
a190 1
      Thread.critical = false
d196 1
a196 1
    runnable = false
d199 1
a199 1
      Thread.critical = false
d211 1
a211 1
	  runnable = true
d225 1
a225 1
	    runnable = true
d238 1
a238 1
	Thread.critical = false
d246 1
a246 1
	Thread.critical = false
d253 1
a253 1
    Thread.critical = false
a256 29
  def sync_synchronize(mode = EX)
    sync_lock(mode)
    begin
      yield
    ensure
      sync_unlock
    end
  end
  
  attr :sync_mode, true
  attr :sync_waiting, true
  attr :sync_upgrade_waiting, true
  attr :sync_sh_locker, true
  attr :sync_ex_locker, true
  attr :sync_ex_count, true

  private

  def initialize(*args)
    ret = super
    @@sync_mode = UN
    @@sync_waiting = []
    @@sync_upgrade_waiting = []
    @@sync_sh_locker = Hash.new
    @@sync_ex_locker = nil
    @@sync_ex_count = 0
    return ret
  end
  
d264 1
a264 1
	ret = true
d268 1
a268 1
	ret = true
d273 1
a273 1
	  ret = true
d275 1
a275 1
	  ret = false
d284 1
a284 1
	ret = true
d287 1
a287 1
	ret = true
d289 1
a289 1
	ret = false
d292 1
a292 1
      Thread.critical = false
d297 128
d429 2
a430 3
  include Sync_m
  
  private
d435 1
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.2 $
#   	$Date: 1998/01/16 04:14:53 $
d49 1
a49 1
  RCS_ID='-$Header: /home/cvsroot/ruby/lib/sync.rb,v 1.1.1.2 1998/01/16 04:14:53 matz Exp $-'
@


1.1.1.2.2.2
log
@Mon Jan 19 14:06:13 JST 1998
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.2.2.1 $
#   	$Date: 1998/01/16 12:36:05 $
d46 1
a46 1
require "final"
d49 1
a49 1
  RCS_ID='-$Header: /home/cvsroot/ruby/lib/sync.rb,v 1.1.1.2.2.1 1998/01/16 12:36:05 matz Exp $-'
d324 1
a324 5
      # Changed to use `final.rb'.
      # Finalizer.add(obj, For_primitive_object, :sync_finalize)
      ObjectSpace.define_finalizer(obj) do |id|
	For_primitive_object.sync_finalize(id)
      end
@


1.1.1.2.2.3
log
@-ko for keiju's files
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.2.2.2 $
#   	$Date: 1998/01/19 05:08:25 $
a6 1
#   	modified by matz
d49 1
a49 1
  RCS_ID='-$Header: /home/cvsroot/ruby/lib/sync.rb,v 1.1.1.2.2.2 1998/01/19 05:08:25 matz Exp $-'
@


1.1.1.2.2.4
log
@*** empty log message ***
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.2.2.3 $
#   	$Date: 1998/02/06 10:03:24 $
d50 1
a50 1
  RCS_ID='-$Header: /home/cvsroot/ruby/lib/sync.rb,v 1.1.1.2.2.3 1998/02/06 10:03:24 matz Exp $-'
a299 1
    sync_lock(mode)
d301 1
@


1.1.1.2.2.5
log
@exception model changed
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.2.2.4 $
#   	$Date: 1998/03/03 02:39:34 $
d50 1
a50 1
  RCS_ID='-$Header: /home/cvsroot/ruby/lib/sync.rb,v 1.1.1.2.2.4 1998/03/03 02:39:34 matz Exp $-'
d58 1
a58 1
  class Err < StandardError
@

