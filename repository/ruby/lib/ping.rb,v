head	1.4;
access;
symbols
	v1_6_7:1.2.2.1
	v1_6_6:1.2.2.1
	v1_6_5:1.2.2.1
	v1_6_4:1.2.2.1
	v1_7_1:1.3
	v1_6_4_preview4:1.2.2.1
	v1_6_4_preview3:1.2.2.1
	v1_6_4_preview2:1.2.2.1
	v1_6_4_preview1:1.2.2.1
	v1_6_3:1.2.2.1
	ruby_m17n:1.2.0.4
	ruby_1_6:1.2.0.2
	v1_6_2:1.2
	v1_6_1:1.2
	v1_6_0:1.2
	v1_4_6:1.1.1.2
	v1_4_5:1.1.1.2
	v1_4_4:1.1.1.2
	ruby_1_4_3:1.1.1.2
	ruby1_4_3:1.1.1.2
	v1_4_3:1.1.1.2
	v1_5_0:1.1.1.2
	ruby_1_4_3_pre1:1.1.1.2
	ruby_1_4:1.1.1.2.0.4
	v1_4_2:1.1.1.2
	v1_4_1:1.1.1.2
	v1_4_0:1.1.1.2
	v1_3_7:1.1.1.2
	v1_3_6_repack:1.1.1.2
	v1_3_6:1.1.1.2
	v1_3_5:1.1.1.2
	v1_2_6repack:1.1.1.1.4.1
	v1_3_4_990625:1.1.1.2
	v1_3_4_990624:1.1.1.2
	v1_2_6:1.1.1.1.4.1
	v1_3_4_990611:1.1.1.2
	v1_3_4_990531:1.1.1.2
	v1_3_3_990518:1.1.1.2
	v1_3_3_990513:1.1.1.2
	v1_3_3_990507:1.1.1.2
	v1_2_5:1.1.1.1.4.1
	v1_2_4:1.1.1.1.4.1
	v1_3_1_990225:1.1.1.2
	v1_3_1_990224:1.1.1.2
	v1_3_1_990215:1.1.1.2
	v1_3_1_990212:1.1.1.2
	v1_3_1_990210:1.1.1.2
	v1_3_1_:1.1.1.2
	v1_3_1_990209:1.1.1.2
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.4.1
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.4.1
	v1_2_1repack:1.1.1.1.4.1
	v1_2_1:1.1.1.1.4.1
	v1_2_stable:1.1.1.1.4.1
	v1_1d1:1.1.1.1.6.1
	v1_1d0:1.1.1.1.6.1
	v1_1c9_1:1.1.1.1.4.1
	v1_1c9:1.1.1.1.4.1
	v1_1c8:1.1.1.1.4.1
	v1_1c7:1.1.1.1.4.1
	v1_1c6:1.1.1.1
	v1_1d-start:1.1.1.1
	v1_1c5:1.1.1.1
	v1_1dev:1.1.1.1.0.6
	v1_1c4:1.1.1.1
	v1_1c3:1.1.1.1
	v1_1c2:1.1.1.1
	v1_1c1:1.1.1.1
	v1_1c0:1.1.1.1
	v1_1b9_31:1.1.1.1
	v1_1b9_30:1.1.1.1
	v1_1b9_28:1.1.1.1
	v1_1b9_27:1.1.1.1
	v1_1b9_26:1.1.1.1
	r1_1b9_25:1.1.1.1
	r1_1b9_24:1.1.1.1
	v1_1b9_23:1.1.1.1
	v1_1b9_22:1.1.1.1
	v1_1b9_20:1.1.1.1
	v1_1b9_18:1.1.1.1
	v1_1b9_16:1.1.1.1
	v1_1b9_15:1.1.1.1
	v1_1b9_13:1.1.1.1
	v1_1b9_12:1.1.1.1
	v1_1b9_11:1.1.1.1
	v1_1b9_08:1.1.1.1
	v1_1b9_07:1.1.1.1
	r1_1b9:1.1.1.1
	v1_1b8:1.1.1.1
	v1_1b7:1.1.1.1
	v1_1b6:1.1.1.1
	v1_1r:1.1.1.1.0.4
	v1_1:1.1.1.1
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2002.07.11.08.22.14;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.15.06.01.00;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.18.06.00.44;	author matz;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1.4.1
	1.1.1.1.6.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.35;	author matz;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	98.11.09.09.11.52;	author matz;	state Exp;
branches;
next	;

1.1.1.1.6.1
date	98.11.25.03.31.18;	author matz;	state Exp;
branches;
next	;

1.2.2.1
date	2001.02.14.05.53.56;	author matz;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.09.11.07.51.48;	author knu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@* string.c (rb_str_slice_bang): if there's no corresponding
  substring, slice! should return nil without exception.

* array.c (rb_ary_insert): type fixed.

* string.c (rb_str_split_m): accept separator value nil as well.

* string.c (rb_str_become): was leaking memory.

* class.c (rb_include_module): should not alter other
  classes/modules by inclusion.  by this fix, local order may not
  be preserved for some cases.

* class.c (include_class_new): module may be T_ICLASS; retrieve
  original module information.
@
text
@#
# ping.rb -- check a host for upness
#
#= SYNOPSIS
#
#   require 'ping'
#    print "'jimmy' is alive and kicking\n" if Ping.pingecho('jimmy', 10) ;
#
#= DESCRIPTION
#
# This module contains routines to test for the reachability of remote hosts.
# Currently the only routine implemented is pingecho(). 
#
# pingecho() uses a TCP echo (I<not> an ICMP one) to determine if the
# remote host is reachable. This is usually adequate to tell that a remote
# host is available to rsh(1), ftp(1), or telnet(1) onto.
#
#== Parameters
#
#  : hostname
#
#    The remote host to check, specified either as a hostname or as an
#    IP address.
#
#  : timeout
#
#    The timeout in seconds. If not specified it will default to 5 seconds.
#
#  : service
#
#    The service port to connect.  The default is "echo".
#
#= WARNING
#
# pingecho() uses user-level thread to implement the timeout, so it may block
# for long period if named does not respond for some reason.
#
#=end

require 'timeout'
require "socket"

module Ping
  def pingecho(host, timeout=5, service="echo")
    begin
      timeout(timeout) do
	s = TCPSocket.new(host, service)
	s.close
      end
    rescue Errno::ECONNREFUSED
      return true
    rescue
      return false
    end
    return true
  end
  module_function :pingecho
end

if $0 == __FILE__
  host = ARGV[0]
  host ||= "localhost"
  printf("%s alive? - %s\n", host,  Ping::pingecho(host, 5))
end
@


1.3
log
@* process.c (proc_waitall): new method based on a patch from Brian
  Fundakowski Feldman <green@@green.dyndns.org>.

* process.c (last_status_set): objectify $? value (Process::Status).
@
text
@d47 1
a47 1
	s = TCPsocket.new(host, service)
@


1.2
log
@matz
@
text
@d50 2
@


1.2.2.1
log
@ping.rb patch
@
text
@a49 2
    rescue Errno::ECONNREFUSED
      return true
@


1.2.2.2
log
@* lib/open3.rb: Merge from 1.7: Turn sync on for the writer
  handle.

* lib/ping.rb: Merge from 1.7: Fix a typo.
@
text
@d47 1
a47 1
	s = TCPSocket.new(host, service)
@


1.1
log
@Initial revision
@
text
@d29 4
d40 3
d44 1
a44 2
  require "socket"
  def pingecho(host, timeout=5)
d46 4
a49 8
      x = Thread.current
      y = Thread.start {
	sleep timeout
	x.raise RuntimeError if x.status
      }
      s = TCPsocket.new(host, "echo")
      s.close
      return TRUE
d51 1
a51 3
      return FALSE;
    ensure
      Thread.kill y if y.status
d53 1
d55 7
a61 1
  module_function "pingecho"
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@a28 4
#  : service
#
#    The service port to connect.  The default is "echo".
#
a35 2
require 'timeout'

d38 1
a38 1
  def pingecho(host, timeout=5, service="echo")
d40 8
a47 4
      timeout(timeout) do
	s = TCPsocket.new(host, service)
	s.close
      end
d49 3
a51 1
      return false
a52 1
    return true
d54 1
a54 7
  module_function :pingecho
end

if $0 == __FILE__
  host = ARGV[0]
  host ||= "localhost"
  printf("%s alive? - %s\n", host,  Ping::pingecho(host, 5))
@


1.1.1.1.6.1
log
@*** empty log message ***
@
text
@a28 4
#  : service
#
#    The service port to connect.  The default is "echo".
#
a35 2
require 'timeout'

d38 1
a38 1
  def pingecho(host, timeout=5, service="echo")
d40 8
a47 4
      timeout(timeout) do
	s = TCPsocket.new(host, "echo")
	s.close
      end
d49 3
a51 1
      return false
a52 1
    return true
a54 6
end

if $0 == __FILE__
  host = ARGV[0]
  host ||= "localhost"
  printf("%s alive? - %s\n", host,  Ping.pingecho(host, 5))
@


1.1.1.1.4.1
log
@1.1c7
@
text
@a35 2
require 'timeout'

d40 8
a47 4
      timeout(timeout) do
	s = TCPsocket.new(host, "echo")
	s.close
      end
d49 3
a51 1
      return false
a52 1
    return true
a54 6
end

if $0 == __FILE__
  host = ARGV[0]
  host ||= "localhost"
  printf("%s alive? - %s\n", host,  Ping.pingecho(host, 5))
@
