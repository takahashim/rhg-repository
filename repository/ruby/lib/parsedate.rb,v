head	1.14;
access;
symbols
	v1_6_7:1.11.2.1
	v1_6_6:1.11.2.1
	v1_6_5:1.11.2.1
	v1_6_4:1.11.2.1
	v1_7_1:1.12
	v1_6_4_preview4:1.11.2.1
	v1_6_4_preview3:1.11.2.1
	v1_6_4_preview2:1.11.2.1
	v1_6_4_preview1:1.11.2.1
	v1_6_3:1.11.2.1
	ruby_m17n:1.11.0.4
	ruby_1_6:1.11.0.2
	v1_6_2:1.11
	v1_6_1:1.10
	v1_6_0:1.10
	v1_4_6:1.5.2.3
	v1_4_5:1.5.2.3
	v1_4_4:1.5.2.2
	ruby_1_4_3:1.5
	ruby1_4_3:1.5
	v1_4_3:1.5
	v1_5_0:1.5
	ruby_1_4_3_pre1:1.5
	ruby_1_4:1.5.0.2
	v1_4_2:1.5
	v1_4_1:1.5
	v1_4_0:1.2
	v1_3_7:1.1.1.2.2.3
	v1_3_6_repack:1.1.1.2.2.3
	v1_3_6:1.1.1.2.2.3
	v1_3_5:1.1.1.2.2.3
	v1_2_6repack:1.1.1.1.4.5
	v1_3_4_990625:1.1.1.2.2.3
	v1_3_4_990624:1.1.1.2.2.3
	v1_2_6:1.1.1.1.4.5
	v1_3_4_990611:1.1.1.2.2.2
	v1_3_4_990531:1.1.1.2.2.2
	v1_3_3_990518:1.1.1.2.2.2
	v1_3_3_990513:1.1.1.2.2.2
	v1_3_3_990507:1.1.1.2.2.2
	v1_2_5:1.1.1.1.4.5
	v1_2_4:1.1.1.1.4.5
	v1_3_1_990225:1.1.1.2.2.2
	v1_3_1_990224:1.1.1.2.2.2
	v1_3_1_990215:1.1.1.2.2.2
	v1_3_1_990212:1.1.1.2.2.2
	v1_3_1_990210:1.1.1.2.2.2
	v1_3_1_:1.1.1.2.2.2
	v1_3_1_990209:1.1.1.2.2.2
	v1_3_1_990205:1.1.1.2.2.2
	v1_3_1_990203:1.1.1.2.2.1
	v1_3_1_990201:1.1.1.2.2.1
	v1_3_1"_990201:1.1.1.2.2.1
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.4.5
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.4.5
	v1_2_1repack:1.1.1.1.4.5
	v1_2_1:1.1.1.1.4.5
	v1_2_stable:1.1.1.1.4.5
	v1_1d1:1.1.1.1.4.5
	v1_1d0:1.1.1.1.4.5
	v1_1c9_1:1.1.1.1.4.5
	v1_1c9:1.1.1.1.4.5
	v1_1c8:1.1.1.1.4.5
	v1_1c7:1.1.1.1.4.5
	v1_1c6:1.1.1.1.4.5
	v1_1d-start:1.1.1.1.4.5
	v1_1c5:1.1.1.1.4.5
	v1_1dev:1.1.1.1.4.5.0.2
	v1_1c4:1.1.1.1.4.5
	v1_1c3:1.1.1.1.4.5
	v1_1c2:1.1.1.1.4.5
	v1_1c1:1.1.1.1.4.5
	v1_1c0:1.1.1.1.4.5
	v1_1b9_31:1.1.1.1.4.5
	v1_1b9_30:1.1.1.1.4.5
	v1_1b9_28:1.1.1.1.4.5
	v1_1b9_27:1.1.1.1.4.5
	v1_1b9_26:1.1.1.1.4.5
	r1_1b9_25:1.1.1.1.4.5
	r1_1b9_24:1.1.1.1.4.5
	v1_1b9_23:1.1.1.1.4.4
	v1_1b9_22:1.1.1.1.4.4
	v1_1b9_20:1.1.1.1.4.4
	v1_1b9_18:1.1.1.1.4.4
	v1_1b9_16:1.1.1.1.4.4
	v1_1b9_15:1.1.1.1.4.4
	v1_1b9_13:1.1.1.1.4.4
	v1_1b9_12:1.1.1.1.4.4
	v1_1b9_11:1.1.1.1.4.4
	v1_1b9_08:1.1.1.1.4.4
	v1_1b9_07:1.1.1.1.4.4
	r1_1b9:1.1.1.1.4.4
	v1_1b8:1.1.1.1.4.4
	v1_1b7:1.1.1.1.4.2
	v1_1b6:1.1.1.1
	v1_1r:1.1.1.1.0.4
	v1_1:1.1.1.1
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2002.05.18.12.57.54;	author tadf;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.18.12.41.50;	author tadf;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.19.19.00.28;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.22.03.22.22;	author matz;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.07.18.07.37.02;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.10.05.44.26;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.23.08.37.33;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.01.03.12.19;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.17.08.37.53;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.09.16.09.40.33;	author matz;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.09.01.09.48.02;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.08.24.08.21.56;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.16;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.35;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	;

1.1.1.2.2.1
date	99.02.01.07.34.58;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	99.02.05.10.27.34;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	99.06.24.04.24.08;	author matz;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	98.02.02.04.49.13;	author matz;	state Exp;
branches;
next	1.1.1.1.4.2;

1.1.1.1.4.2
date	98.02.03.10.02.57;	author matz;	state Exp;
branches;
next	1.1.1.1.4.3;

1.1.1.1.4.3
date	98.02.16.06.05.45;	author matz;	state Exp;
branches;
next	1.1.1.1.4.4;

1.1.1.1.4.4
date	98.02.18.01.56.47;	author matz;	state Exp;
branches;
next	1.1.1.1.4.5;

1.1.1.1.4.5
date	98.06.09.07.23.50;	author matz;	state Exp;
branches;
next	;

1.5.2.1
date	2000.01.17.08.24.21;	author matz;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2000.01.24.03.46.13;	author matz;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2000.06.20.06.08.52;	author matz;	state Exp;
branches;
next	;

1.11.2.1
date	2001.01.23.09.54.38;	author matz;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.05.22.12.44.45;	author tadf;	state Exp;
branches;
next	;


desc
@@


1.14
log
@use Array#select instead of Array#indexes.
@
text
@# parsedate.rb: Written by Tadayoshi Funaba 2001, 2002
# $Id: parsedate.rb,v 2.6 2002-05-14 07:43:18+09 tadf Exp $

require 'date/format'

module ParseDate

  def parsedate(str, comp=false)
    Date._parse(str, comp).
      select(:year, :mon, :mday, :hour, :min, :sec, :zone, :wday)
  end

  module_function :parsedate

end
@


1.13
log
@updated to the new version (based on date2 3.2.1).
@
text
@d10 1
a10 1
      indexes(:year, :mon, :mday, :hour, :min, :sec, :zone, :wday)
@


1.12
log
@* parse.y (yylex): fixed serious syntax misbehavior.  do's
  preceding was too high.  a block in `foo bar do .. end' should
  be passed to `foo', not `bar'.
@
text
@d1 4
a4 2
# parsedate3.rb: Written by Tadayoshi Funaba 2000, 2001
# $Id: parsedate3.rb,v 1.3 2001-01-18 12:09:47+09 tadf Exp $
d8 3
a10 171
  MONTHS = {
    'jan' => 1, 'feb' => 2, 'mar' => 3, 'apr' => 4,
    'may' => 5, 'jun' => 6, 'jul' => 7, 'aug' => 8,
    'sep' => 9, 'oct' =>10, 'nov' =>11, 'dec' =>12
  }
  MONTHPAT = MONTHS.keys.join('|')

  DAYS = {
    'sun' => 0, 'mon' => 1, 'tue' => 2, 'wed' => 3,
    'thu' => 4, 'fri' => 5, 'sat' => 6
  }
  DAYPAT = DAYS.keys.join('|')

  def parsedate(date, cyear=false)
    date = date.dup

    # day
    if date.sub!(/(#{DAYPAT})\S*/ino, ' ')
      wday = DAYS[$1.downcase]
    end

    # time
    if date.sub!(
		 /(\d+):(\d+)(?::(\d+))?
		  (?:
		    \s*
		    ([ap])\.?m\.?
		    \b
		  )?
		  (?:
		    \s*
		    (
		      [a-z]+(?:\s+dst)?
		    |
		      [-+]\d+(?::?\d+)
		    )
		    \b
		  )?
		 /inox,
		 ' ')
      hour = $1.to_i
      min = $2.to_i
      sec = $3.to_i if $3
      if $4
	hour %= 12
	if $4.downcase == 'p'
	  hour += 12
	end
      end
      zone = $5
    end

    # eu
    if date.sub!(
		 /(\d+)\S*
		  \s+
		  (#{MONTHPAT})\S*
		  (?:
		    \s+
		    (\d+)
		  )?
		 /inox,
		 ' ')
      mday = $1.to_i
      mon = MONTHS[$2.downcase]
      year = $3.to_i if $3

    # us
    elsif date.sub!(
		    /(#{MONTHPAT})\S*
		     \s+
		     (\d+)\S*
		     (?:
		       \s+
		       (\d+)
		     )?
		    /inox,
		    ' ')
      mon = MONTHS[$1.downcase]
      mday = $2.to_i
      year = $3.to_i if $3

    # iso
    elsif date.sub!(/(\d+)-(\d+)-(\d+)/no, ' ')
      year = $1.to_i
      mon = $2.to_i
      mday = $3.to_i
      mday, mon, year = year, mon, mday if $3.size >= 4

    # jis
    elsif date.sub!(/([MTSH])(\d+)\.(\d+)\.(\d+)/no, ' ')
      e = { 'M'=>1867,
	    'T'=>1911,
	    'S'=>1925,
	    'H'=>1988
	  }[$1]
      year, mon, mday = $2.to_i + e, $3.to_i, $4.to_i

    # vms
    elsif date.sub!(/(\d+)-(#{MONTHPAT})\S*-(\d+)/ino, ' ')
      mday = $1.to_i
      mon = MONTHS[$2.downcase]
      year = $3.to_i
      year, mon, mday = mday, mon, year if $1.size >= 4

    # sla
    elsif date.sub!(%r|(\d+)/(\d+)(?:/(\d+))?|no, ' ')
      mon = $1.to_i
      mday = $2.to_i
      year = $3.to_i if $3
      year, mon, mday = mon, mday, year if $1.size >= 4

    # ddd
    elsif date.sub!(
		    /(\d{4,14})
		     (?:
		       \s*
		       T?
		       \s*
		       (\d{2,6})
		     )?
		     (?:
		       \s*
		       (
			 Z
		       |
			 [-+]\d{2,4}
		       )
		       \b
		     )?
		    /nox,
		    ' ')
      case $1.size
      when 4
	mon  = $1[ 0, 2].to_i
	mday = $1[ 2, 2].to_i
      when 6
	year = $1[ 0, 2].to_i
	mon  = $1[ 2, 2].to_i
	mday = $1[ 4, 2].to_i
      when 8, 10, 12, 14
	year = $1[ 0, 4].to_i
	mon  = $1[ 4, 2].to_i
	mday = $1[ 6, 2].to_i
	hour = $1[ 8, 2].to_i if $1.size >= 10
	min  = $1[10, 2].to_i if $1.size >= 12
	sec  = $1[12, 2].to_i if $1.size >= 14
      end
      if $2
	case $2.size
	when 2, 4, 6
	  hour = $2[ 0, 2].to_i
	  min  = $2[ 2, 2].to_i if $2.size >= 4
	  sec  = $2[ 4, 2].to_i if $2.size >= 6
	end
      end
      zone = $3
    end

    if cyear and year
      if year < 100
	if year >= 69
	  year += 1900
	else
	  year += 2000
	end
      end
    end

    return year, mon, mday, hour, min, sec, zone, wday

@


1.11
log
@matz
@
text
@d1 2
a2 2
# parsedate.rb: Written by Tadayoshi Funaba 2000
# $Id: parsedate.rb,v 1.2 2000-04-01 12:16:56+09 tadf Exp $
d49 6
a54 1
      hour += 12 if $4 and $4.downcase == 'p'
@


1.11.2.1
log
@* gc.c (rb_gc_call_finalizer_at_exit): should finalize objects in
  deferred_final_list too.
@
text
@d1 2
a2 2
# parsedate3.rb: Written by Tadayoshi Funaba 2000, 2001
# $Id: parsedate3.rb,v 1.3 2001-01-18 12:09:47+09 tadf Exp $
d49 1
a49 6
      if $4
	hour %= 12
	if $4.downcase == 'p'
	  hour += 12
	end
      end
@


1.11.2.2
log
@updated to the new version (based on date2 2.6.1).
@
text
@d1 2
a2 2
# parsedate3.rb: Written by Tadayoshi Funaba 2000-2002
# $Id: parsedate3.rb,v 1.6 2002-05-16 20:03:28+09 tadf Exp $
a21 2
    date.gsub!(/[^-+.\/:0-9a-z]+/ino, ' ')

d32 2
a33 1
		    ([ap])(?:m\b|\.m\.)
d38 1
a38 1
		      [a-z]+(?:\s+dst)?\b
d42 1
d65 1
a65 1
		    (-?\d+)
d80 1
a80 1
		       (-?\d+)
d89 1
a89 1
    elsif date.sub!(/([-+]?\d+)-(\d+)-(-?\d+)/no, ' ')
d105 1
a105 1
    elsif date.sub!(/(-?\d+)-(#{MONTHPAT})[^-]*-(-?\d+)/ino, ' ')
d112 1
a112 1
    elsif date.sub!(%r|(-?\d+)/(\d+)(?:/(-?\d+))?|no, ' ')
d120 1
a120 1
		    /([-+]?)(\d{4,14})
d138 1
a138 1
      case $2.size
d140 2
a141 2
	mon  = $2[ 0, 2].to_i
	mday = $2[ 2, 2].to_i
d143 3
a145 3
	year = ($1 + $2[ 0, 2]).to_i
	mon  = $2[ 2, 2].to_i
	mday = $2[ 4, 2].to_i
d147 6
a152 6
	year = ($1 + $2[ 0, 4]).to_i
	mon  = $2[ 4, 2].to_i
	mday = $2[ 6, 2].to_i
	hour = $2[ 8, 2].to_i if $2.size >= 10
	min  = $2[10, 2].to_i if $2.size >= 12
	sec  = $2[12, 2].to_i if $2.size >= 14
d154 2
a155 2
      if $3
	case $3.size
d157 3
a159 3
	  hour = $3[ 0, 2].to_i
	  min  = $3[ 2, 2].to_i if $3.size >= 4
	  sec  = $3[ 4, 2].to_i if $3.size >= 6
d162 1
a162 1
      zone = $4
d166 1
a166 1
      if year >= 0 and year <= 99
@


1.10
log
@matz - date/date2 integration
@
text
@d1 2
a2 2
# parsedate3.rb: Written by Tadayoshi Funaba 2000
# $Id: parsedate3.rb,v 1.2 2000-04-01 12:16:56+09 tadf Exp $
@


1.9
log
@2000-04-10
@
text
@d2 1
a2 1
# $Id: parsedate3.rb,v 1.2 2000/04/01 03:16:56 tadf Exp $
@


1.8
log
@2000-03-23
@
text
@d1 2
a2 159
# parsedate2.ry: Written by Tadayoshi Funaba 1999, 2000
# $Id: parsedate2.ry,v 1.5 2000/03/20 16:23:46 tadf Exp $
## Generated by rbison version 0.0.5.

class ParseDatePar

    class ParseError < StandardError ; end
    class LexError < StandardError ; end
    NULL = nil

    attr :yydebug, true

    DAY = 257
    DIGITS = 258
    MON = 259
    LETTERS = 260
    MERID = 261

    ## Parser declarations begin
    ## Parser declarations end

    YYFINAL = 84
    YYFLAG = -32768
    YYNTBASE = 14
    YYTRANSLATE = [ 0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,    13,     8,     9,    10,    11,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,    12,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
     7
    ]
    YYPRHS = [ 0,
     0,     1,     3,     6,     8,    12,    14,    20,    26,    32,
    34,    38,    40,    44,    45,    48,    50,    51,    53,    55,
    57,    60,    63,    65,    67,    69,    71,    73,    80,    88,
    94,    98,   104,   108,   115,   116,   119,   122,   123,   125,
   128,   129,   131,   132,   134,   136,   139,   142,   147,   149
    ]
    YYRHS = [ -1,
    17,     0,    16,    15,     0,    19,     0,    19,    18,    22,
     0,    28,     0,    28,    18,    19,    18,    22,     0,    19,
    18,    28,    18,    22,     0,    19,    18,    22,    18,    28,
     0,    23,     0,    23,    18,    28,     0,    30,     0,    30,
    18,    32,     0,     0,    17,    18,     0,     3,     0,     0,
     8,     0,    20,     0,    21,     0,     4,     5,     0,     5,
     4,     0,     4,     0,    24,     0,    25,     0,    26,     0,
    27,     0,     4,     9,     4,     9,     4,    31,     0,     6,
     4,    10,     4,    10,     4,    31,     0,     4,     9,     5,
     9,     4,     0,     4,    11,     4,     0,     4,    11,     4,
    11,     4,     0,     4,     7,    34,     0,     4,    12,     4,
    29,    33,    34,     0,     0,    12,     4,     0,     4,    31,
     0,     0,     6,     0,     4,    34,     0,     0,     7,     0,
     0,    35,     0,     6,     0,     6,     6,     0,    36,     4,
     0,    36,     4,    12,     4,     0,     9,     0,    13,     0
    ]
    YYRLINE = [ 0,
    14,    14,    14,    16,    17,    18,    19,    20,    21,    22,
    23,    24,    25,    28,    28,    30,    32,    32,    34,    34,
    36,    38,    40,    42,    42,    42,    42,    44,    58,    72,
    86,    91,   105,   109,   116,   116,   118,   141,   141,   143,
   156,   156,   158,   158,   160,   161,   166,   167,   170,   170
    ]
    YYTNAME = [ "$","error","$undefined.","DAY","DIGITS",
"MON","LETTERS","MERID","','","'-'","'.'","'/'","':'","'+'","repr","dat","odaycom",
"day","ocom","woy","eu","us","year","wy","iso","jis","vms","sla","time","osec",
"ddd","otee","ttt","omerid","ozone","zone","sign", NULL
    ]
    YYR1 = [ 0,
    14,    14,    14,    15,    15,    15,    15,    15,    15,    15,
    15,    15,    15,    16,    16,    17,    18,    18,    19,    19,
    20,    21,    22,    23,    23,    23,    23,    24,    25,    26,
    27,    27,    28,    28,    29,    29,    30,    31,    31,    32,
    33,    33,    34,    34,    35,    35,    35,    35,    36,    36
    ]
    YYR2 = [ 0,
     0,     1,     2,     1,     3,     1,     5,     5,     5,     1,
     3,     1,     3,     0,     2,     1,     0,     1,     1,     1,
     2,     2,     1,     1,     1,     1,     1,     6,     7,     5,
     3,     5,     3,     6,     0,     2,     2,     0,     1,     2,
     0,     1,     0,     1,     1,     2,     2,     4,     1,     1
    ]
    YYDEFACT = [ 14,
    16,     0,    17,    38,     0,     0,     3,     4,    19,    20,
    10,    24,    25,    26,    27,    17,    12,    18,    15,    21,
    39,    43,     0,     0,     0,    37,    22,     0,     0,     0,
     0,     0,    45,    49,    50,    33,    44,     0,     0,     0,
    31,    35,     0,    23,     5,    17,     0,    11,     0,    17,
    43,    13,    46,    47,     0,     0,     0,     0,    41,     0,
     0,     0,     0,    40,     0,    38,    30,    32,    36,    42,
    43,     0,     9,    23,     8,     7,    48,    28,    34,    38,
    29,     0,     0,     0
    ]
    YYDEFGOTO = [ 82,
     7,     2,     3,    19,     8,     9,    10,    45,    11,    12,
    13,    14,    15,    16,    59,    17,    26,    52,    71,    36,
    37,    38
    ]
    YYPACT = [ 10,
-32768,    30,     6,    11,    37,    39,-32768,    23,-32768,-32768,
    23,-32768,-32768,-32768,-32768,     7,    23,-32768,-32768,-32768,
-32768,    19,    25,    40,    41,-32768,-32768,    36,    43,    44,
    35,    45,    46,-32768,-32768,-32768,-32768,    47,    48,    49,
    42,    38,    50,    14,    23,    51,    14,-32768,    55,    51,
    19,-32768,-32768,    52,    57,    58,    59,    61,    60,    56,
    44,    64,    64,-32768,    65,    66,-32768,-32768,-32768,-32768,
    19,    67,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    66,
-32768,    70,    73,-32768
    ]
    YYPGOTO = [ -32768,
-32768,-32768,-32768,    -8,    24,-32768,-32768,   -51,-32768,-32768,
-32768,-32768,-32768,   -28,-32768,-32768,   -61,-32768,-32768,   -47,
-32768,-32768
    ]
    YYLAST = 73
    YYTABLE = [ 29,
    46,    48,    30,    64,    78,    -2,    -6,    31,    32,    -1,
    75,    76,     1,    18,    18,    20,    21,    22,    81,    23,
    22,    24,    25,    79,    33,    25,   -17,    34,    39,    40,
    18,    35,    73,     4,     5,     6,    61,    62,    49,     5,
    27,    63,    28,    41,    42,    43,    44,    47,    51,    58,
    54,    53,    57,    60,    50,     0,    55,    56,    18,    20,
    66,    67,    68,    65,    69,    72,    70,    74,    77,    83,
    80,    21,    84
    ]
    YYCHECK = [ 8,
    29,    30,    11,    51,    66,     0,     0,    16,    17,     0,
    62,    63,     3,     8,     8,     5,     6,     7,    80,     9,
     7,    11,    12,    71,     6,    12,     4,     9,     4,     5,
     8,    13,    61,     4,     5,     6,    45,    46,     4,     5,
     4,    50,     4,     4,     4,    10,     4,     4,     4,    12,
     4,     6,    11,     4,    31,    -1,     9,     9,     8,     5,
     4,     4,     4,    12,     4,    10,     7,     4,     4,     0,
     4,     6,     0
    ]
    YYEMPTY = -2
    YYEOF = 0
    YYTERROR = 1
d4 1
a4 371
    def initialize
	@@yydebug = false
    end

    def yyparse(lexer)
	yyerrstatus = 0
	yychar = YYEMPTY
	yystate = 0
	yyss = []
	yyvs = ["nil"]
	yyval = 0
	jump = :YYNEWSTATE

	while true

	    case jump

	    when :YYNEWSTATE
		if @@yydebug
		    printf($stderr, "Entering state %d\n", yystate)
		end
		yyss.push(yystate)
		jump = :YYBACKUP
		next

	    when :YYBACKUP
		yyn = YYPACT[yystate]
		if yyn == YYFLAG
		    jump = :YYDEFAULT
		    next
		end

		## get a lookahead token if we don't already have one
		if yychar == YYEMPTY
		    if @@yydebug
			printf($stderr, "Reading a token: ")
		    end
		    begin
			yychar, yylval = lexer.yylex
		    rescue LexError
			raise ParseError, "lex error"
		    end
		end

		## if lookahead <= 0, end of input
		if yychar <= 0
		    yychar1 = 0
		    yychar = YYEOF
		    if @@yydebug
			printf($stderr, "Now at end of input.\n")
		    end
		else
		    yychar1 = yychar < 0 || yychar > 261 ? 37 : YYTRANSLATE[yychar]
		    if @@yydebug
			printf($stderr, "Next token is %d (%s,%s)\n", yychar,
			       YYTNAME[yychar1], yylval)
		    end
		end

		## see if we know what to do with this token in this state
		yyn += yychar1
		if yyn < 0 || yyn > YYLAST || YYCHECK[yyn] != yychar1
		    jump = :YYDEFAULT
		    next
		end

		## yyn is what to do for this token type in this state
		## negative -> reduce, - yyn is the rule number
		## positive -> shift, yyn is the new state
		##    New state is final state, don't bother to shift, just
		##    return success
		## 0, or most negative number -> error
		yyn = YYTABLE[yyn]
		if yyn < 0
		    if yyn == YYFLAG
			jump = :YYERRLAB
			next
		    end
		    yyn = - yyn
		    jump = :YYREDUCE
		    next
		elsif yyn == 0
		    jump = :YYERRLAB
		    next
		end

		if yyn == YYFINAL
		    return ## accept
		end

		## shift the lookahead token
		if @@yydebug
		    printf($stderr, "Shifting token %d (%s), ", yychar,
			   YYTNAME[yychar1])
		end

		## discard the token being shifted unless it is eof
		if yychar != YYEOF
		    yychar = YYEMPTY
		end
		yyvs.push(yylval)

		## count tokens shifted since error; after, three turn off
		## error status
		yyerrstatus -= 1 if yyerrstatus > 0

		yystate = yyn
		jump = :YYNEWSTATE
		next

	    when :YYDEFAULT
		yyn = YYDEFACT[yystate]
		if yyn == 0
		    jump = :YYERRLAB
		    next
		else
		    jump = :YYREDUCE
		    next
		end

	    ## do a reduction. yyn is the number of the rule to reduce with
	    when :YYREDUCE
		yylen = YYR2[yyn]
		if yylen > 0
		    yyval = yyvs[yyvs.size - yylen]
		end

		if @@yydebug
		    printf($stderr, "Reducing via rule %d (line %d), ", yyn,
			   YYRLINE[yyn])
		    i = YYPRHS[yyn]
		    while YYRHS[i] > 0
			printf($stderr, "%s ", YYTNAME[YYRHS[i]])
			i += 1
		    end
		    printf($stderr, " -> %s\n", YYTNAME[YYR1[yyn]])
		end

		case yyn
		when 16
		     store(:wday, yyvs[-1].to_i)
		when 21
		     store(:mday, yyvs[-2].to_i); store(:mon, yyvs[-1])
		when 22
		     store(:mon, yyvs[-2]); store(:mday, yyvs[-1].to_i)
		when 23
		     store(:year, yyvs[-1].to_i)
		when 28

		    if yyvs[-1 + -1].size >= 4
		    store(:mday, yyvs[-1 + -5].to_i)
		    store(:mon,  yyvs[-1 + -3].to_i)
		    store(:year, yyvs[-1 + -1].to_i)
		    else
		    store(:year, yyvs[-1 + -5].to_i)
		    store(:mon,  yyvs[-1 + -3].to_i)
		    store(:mday, yyvs[-1 + -1].to_i)
		    end

		when 29

		    e = { 'M'=>1867,
		    'T'=>1911,
		    'S'=>1925,
		    'H'=>1988
		    }[yyvs[-1 + -6]]
		    raise ParseError, 'YYERROR' unless e
		    store(:year, yyvs[-1 + -5].to_i + e)
		    store(:mon,  yyvs[-1 + -3].to_i)
		    store(:mday, yyvs[-1 + -1].to_i)

		when 30

		    if yyvs[-1 + -4].size >= 4
		    store(:year, yyvs[-1 + -4].to_i)
		    store(:mon,  yyvs[-1 + -2])
		    store(:mday, yyvs[-1 + 0].to_i)
		    else
		    store(:mday, yyvs[-1 + -4].to_i)
		    store(:mon,  yyvs[-1 + -2])
		    store(:year, yyvs[-1 + 0].to_i)
		    end

		when 31

		    store(:mon,  yyvs[-1 + -2].to_i)
		    store(:mday, yyvs[-1 + 0].to_i)

		when 32

		    if yyvs[-1 + -4].size >= 4
		    store(:year, yyvs[-1 + -4].to_i)
		    store(:mon,  yyvs[-1 + -2].to_i)
		    store(:mday, yyvs[-1 + 0].to_i)
		    else
		    store(:mon,  yyvs[-1 + -4].to_i)
		    store(:mday, yyvs[-1 + -2].to_i)
		    store(:year, yyvs[-1 + 0].to_i)
		    end

		when 33

		    store(:hour, yyvs[-1 + -2].to_i + yyvs[-1 + -1])

		when 34

		    store(:hour, yyvs[-1 + -5].to_i + yyvs[-1 + -1])
		    store(:min,  yyvs[-1 + -3].to_i)

		when 36
		     store(:sec, yyvs[-1].to_i)
		when 37

		    case yyvs[-1 + -1].size
		    when 4
		    store(:mon,  yyvs[-1 + -1][ 0, 2].to_i)
		    store(:mday, yyvs[-1 + -1][ 2, 2].to_i)
		    when 6
		    store(:year, yyvs[-1 + -1][ 0, 2].to_i)
		    store(:mon,  yyvs[-1 + -1][ 2, 2].to_i)
		    store(:mday, yyvs[-1 + -1][ 4, 2].to_i)
		    when 8, 10, 12, 14
		    store(:year, yyvs[-1 + -1][ 0, 4].to_i)
		    store(:mon,  yyvs[-1 + -1][ 4, 2].to_i)
		    store(:mday, yyvs[-1 + -1][ 6, 2].to_i)
		    store(:hour, yyvs[-1 + -1][ 8, 2].to_i) if yyvs[-1 + -1].size >= 10
		    store(:min,  yyvs[-1 + -1][10, 2].to_i) if yyvs[-1 + -1].size >= 12
		    store(:sec,  yyvs[-1 + -1][12, 2].to_i) if yyvs[-1 + -1].size >= 14
		    else
		    raise ParseError, 'YYERROR'
		    end

		when 39
		     raise ParseError, 'YYERROR' unless yyvs[-1] == 'T'
		when 40

		    case yyvs[-1 + -1].size
		    when 2, 4, 6
		    store(:hour, yyvs[-1 + -1][ 0, 2].to_i)
		    store(:min,  yyvs[-1 + -1][ 2, 2].to_i) if yyvs[-1 + -1].size >= 4
		    store(:sec,  yyvs[-1 + -1][ 4, 2].to_i) if yyvs[-1 + -1].size >= 6
		    else
		    raise ParseError, 'YYERROR'
		    end

		when 41
		     yyval = 0
		when 45
		     store(:zone, yyvs[-1])
		when 46

		    raise ParseError, 'YYERROR' unless yyvs[-1 + 0] == 'DST'
		    store(:zone, yyvs[-1 + -1] + ' ' + yyvs[-1 + 0])

		when 47
		     store(:zone, yyvs[-2] + yyvs[-1])
		when 48
		     store(:zone, yyvs[-4] + yyvs[-3] + yyvs[-2] + yyvs[-1])
		when -65536 ## never used, placeholder for ruby
		end

		if yylen > 0
		    yyss[(yyss.size - yylen) .. (yyss.size - 1)] = []
		    yyvs[(yyvs.size - yylen) .. (yyvs.size - 1)] = []
		end

		yyvs.push(yyval)

		if @@yydebug
		    printf($stderr, "State stack now: %s\n", yyss.join(' '))
		    printf($stderr, "Value stack now: %s\n", yyvs.join(' '))
		end

		## "Shift" the result of the reduction.
		yyn = YYR1[yyn]
		yystate = YYPGOTO[yyn - YYNTBASE] + yyss[-1]
		if yystate >=0 && yystate <= YYLAST &&
			YYCHECK[yystate] == yyss[-1]
		    yystate = YYTABLE[yystate]
		else
		    yystate = YYDEFGOTO[yyn - YYNTBASE]
		end
		jump = :YYNEWSTATE
		next

	    when :YYERRLAB
		if yyerrstatus == 0 && @@yydebug
		    printf($stderr, "Parse error!\n")
		end
		jump = :YYERRLAB1
		next

	    when :YYERRLAB1
		if yyerrstatus == 3
		    if yychar == YYEOF
			raise ParseError, "parse error"
		    end
		    if @@yydebug
			printf($stderr, "Discarding token %d (%s).\n", yychar,
			       YYTNAME[yychar1])
		    end
		    yychar = YYEMPTY
		end

		yyerrstatus = 3
		jump = :YYERRHANDLE
		next

	    when :YYERRPOP
		if yyvs.empty?
		    raise ParseError, "parse error"
		end
		## don't pop if the state on top of the stack can handle
		## the error token
		yystate = yyss[-1]
		if YYCHECK[YYPACT[yystate] + YYTERROR] != YYTERROR
		    yyvs.pop
		    yyss.pop
		    if @@yydebug
			printf($stderr, "Error: state stack now: %s\n",
			       yyss.join(' '))
			printf($stderr, "Error: Value stack now: %s\n",
			       yyvs.join(' '))
		    end
		end
		jump = :YYERRHANDLE
		next

	    when :YYERRHANDLE
		yyn = YYPACT[yystate]
		if yyn == YYFLAG
		    jump = :YYERRPOP
		    next
		end

		yyn += YYTERROR
		if yyn < 0 || yyn > YYLAST || YYCHECK[yyn] != YYTERROR
		    jump = :YYERRPOP
		    next
		end

		yyn = YYTABLE[yyn]
		if yyn < 0
		    if yyn == YYFLAG
			jump = :YYERRPOP
			next
		    end
		    yyn = -yyn
		    jump = :YYREDUCE
		    next
		elsif yyn == 0
		    jump = :YYERRPOP
		    next
		end

		if yyn == YYFINAL
		    return ## accept
		end

		if @@yydebug
		    printf($stderr, "Shifting error token, ")
		end

		yyvs.push(yylval)
		yystate = yyn
		jump = :YYNEWSTATE
		next

	    end ## case

	end ## while true
a5 6
    end ## yyparse

end ## class

## Additional user code
class ParseDateLex
d11 2
a12 1
  MONTHPAT = MONTHS.keys.sort.reverse.join('|')
d17 141
a157 9
  DAYPAT = DAYS.keys.sort.reverse.join('|')
  def initialize(str) @@str = str end
  def reset(str) @@str = str end
  def yylex
    @@str = @@str.sub(/\A\s+/, '')
    return [-1, nil] if @@str.size == 0
    if /\A(#{DAYPAT})[a-z]*\.?/i =~ @@str
      @@str = $'
      return [ParseDatePar::DAY, DAYS[$1[0, 3].downcase]]
d159 1
a159 28
    if /\A(\d+)(?:(?:th|st|nd|rd)\b)?/ =~ @@str
      @@str = $'
      return [ParseDatePar::DIGITS, $1]
    end
    if /\A(#{MONTHPAT})[a-z]*\.?/i =~ @@str
      @@str = $'
      return [ParseDatePar::MON, MONTHS[$1[0, 3].downcase]]
    end
    if /\A([ap]\.?m\.?\b)/i =~ @@str
      @@str = $'
      return [ParseDatePar::MERID,
        if $1[0, 1].downcase == 'a' then 0 else 12 end]
    end
    if /\A([a-z]+)/i =~ @@str
      @@str = $'
      return [ParseDatePar::LETTERS, $1]
    end
    if /\A(.)/ =~ @@str
      @@str = $'
      return [$1[0], $1]
    end
  end
end
class ParseDatePar
  def clear() @@values = {} end
  def store(key, val) @@values[key] = val end
  def values(cyear)
    year = @@values[:year]
d169 3
a171 12
    @@values[:year] = year
    @@values.indexes(:year, :mon, :mday,
		    :hour, :min, :sec, :zone, :wday)
  end
end
module ParseDate
  def parsedate(date, cyear=false)
    lex = ParseDateLex.new(date)
    par = ParseDatePar.new
    par.clear
    begin par.yyparse(lex); rescue; end
    par.values(cyear)
d173 1
d175 1
@


1.7
log
@2000-02-01
@
text
@d1 538
a538 1
module ParseDate
d542 3
a544 2
    'sep' => 9, 'oct' =>10, 'nov' =>11, 'dec' =>12 }
  MONTHPAT = MONTHS.keys.join('|')
d547 28
a574 33
    'thu' => 4, 'fri' => 5, 'sat' => 6 }
  DAYPAT = DAYS.keys.join('|')

  def parsedate(date, guess=false) 
    # part of ISO 8601
    # yyyy-mm-dd | yyyy-mm | yyyy
    # date hh:mm:ss | date Thh:mm:ss
    if date =~ /^(\d\d\d\d)-?(?:(\d\d)-?(\d\d)?)? *T?(?:(\d\d):?(\d\d):?(\d\d)?)?$/
      return $1.to_i,
	if $2 then $2.to_i else 1 end,
	if $3 then $3.to_i else 1 end,
	if $4 then $4.to_i end,
	if $5 then $5.to_i end,
	if $6 then $6.to_i end,
	nil,
	nil
    end
    date = date.dup
    if date.sub!(/(#{DAYPAT})[a-z]*,?/i, ' ')
      wday = DAYS[$1.downcase]
    end
    if date.sub!(/(\d+):(\d+)(?::(\d+))?(?:\s*(am|pm))?(?:\s+([a-z]{1,4}(?:\s+[a-z]{1,4}|[-+]\d{4})?|[-+]\d{4}))?/i, ' ')
      hour = $1.to_i
      min = $2.to_i
      if $3
	sec = $3.to_i
      end
      if $4 == 'pm'
	hour += 12
      end
      if $5
	zone = $5
      end
d576 3
a578 31
    if date.sub!(/(\d+)\S*\s+(#{MONTHPAT})\S*(?:\s+(\d+))?/i, ' ')
      mday = $1.to_i
      mon = MONTHS[$2.downcase]
      if $3
	year = $3.to_i
      end
    elsif date.sub!(/(#{MONTHPAT})\S*\s+(\d+)\S*,?(?:\s+(\d+))?/i, ' ')
      mon = MONTHS[$1.downcase]
      mday = $2.to_i
      if $3
	year = $3.to_i
      end
    elsif date.sub!(/(\d+)\/(\d+)(?:\/(\d+))/, ' ')
      mon = $1.to_i
      mday = $2.to_i
      if $3
	year = $3.to_i
      end
    elsif date.sub!(/(\d+)-(#{MONTHPAT})-(\d+)/i, ' ')
      mday = $1.to_i
      mon = MONTHS[$2.downcase]
      year = $3.to_i
    elsif date.sub!(/(\d+)-(#{MONTHPAT})-(\d+)/i, ' ')
      mday = $1.to_i
      mon = MONTHS[$2.downcase]
      year = $3.to_i
    end
    if date.sub!(/\d{4}/i, ' ')
      year = $&.to_i
    elsif date.sub!(/\d\d/i, ' ')
      year = $&.to_i
d580 8
a587 1
    if guess and year
d596 12
a607 1
    return year, mon, mday, hour, min, sec, zone, wday
a608 1

a609 5
end

if __FILE__ == $0
  p Time.now.asctime
  p ParseDate.parsedate(Time.now.asctime)
@


1.6
log
@2000-01-17
@
text
@d30 1
a30 1
    if date.sub!(/(\d+):(\d+)(?::(\d+))?(?:\s*(am|pm))?(?:\s+([a-z]{1,4}(?:\s+[a-z]{1,4}|[-+]\d{4})?))?/i, ' ')
@


1.5
log
@1.4.1
@
text
@d30 1
a30 1
    if date.sub!(/(\d+):(\d+)(?::(\d+))?(?:\s*(am|pm))?(?:\s+([a-z]{1,4}(?:\s+[a-z]{1,4})?|[-+]\d{4}))?/i, ' ')
@


1.5.2.1
log
@2000-01-17
@
text
@d30 1
a30 1
    if date.sub!(/(\d+):(\d+)(?::(\d+))?(?:\s*(am|pm))?(?:\s+([a-z]{1,4}(?:\s+[a-z]{1,4}|[-+]\d{4})?))?/i, ' ')
@


1.5.2.2
log
@2000-01-24
@
text
@d30 1
a30 1
    if date.sub!(/(\d+):(\d+)(?::(\d+))?(?:\s*(am|pm))?(?:\s+([a-z]{1,4}(?:\s+[a-z]{1,4}|[-+]\d{4})?|[-+]\d{4}))?/i, ' ')
@


1.5.2.3
log
@2000-06-20
@
text
@d70 1
a70 1
    if !year && date.sub!(/\d{4}/i, ' ')
d72 1
a72 1
    elsif !year && date.sub!(/\d\d/i, ' ')
@


1.4
log
@regexp literal (e.g. \202) match, etc.
@
text
@a69 1
    p date
@


1.3
log
@1.4.1 to be
@
text
@d76 1
a76 1
    if guess
@


1.2
log
@1.4.0
@
text
@d30 1
a30 1
    if date.sub!(/(\d+):(\d+)(?::(\d+))?\s*(am|pm)?\s*(?:\s+([a-z]{1,4}(?:\s+[a-z]{1,4})?|[-+]\d{4}))?/i, ' ')
d65 10
a83 4
    elsif date.sub!(/(\d+)-(#{MONTHPAT})-(\d+)/i, ' ')
      mday = $1.to_i
      mon = MONTHS[$2.downcase]
      year = $3.to_i
@


1.1
log
@Initial revision
@
text
@d7 71
a77 24
  DAYPAT = 'mon|tue|wed|thu|fri|sat|sun'
  
  def parsedate(date) 
    if date.sub!(/(#{DAYPAT})/i, ' ')
      dayofweek = $1
    end
    if date.sub!(/\s+(\d+:\d+(:\d+)?)/, ' ')
      time = $1
    end
    if date =~ /19(\d\d)/
      year = Integer($1)
    end
    if date.sub!(/\s*(\d+)\s+(#{MONTHPAT})\S*\s+/i, ' ')
      dayofmonth = $1.to_i
      monthname  = $2
    elsif date.sub!(/\s*(#{MONTHPAT})\S*\s+(\d+)\s+/i, ' ')
      monthname  = $1
      dayofmonth = $2.to_i
    elsif date.sub!(/\s*(#{MONTHPAT})\S*\s+(\d+)\D+/i, ' ')
      monthname  = $1
      dayofmonth = $2.to_i
    elsif date.sub!(/\s*(\d\d?)\/(\d\d?)/, ' ')
      month  = $1
      dayofmonth = $2.to_i
d79 1
a79 7
    if monthname
      month = MONTHS[monthname.downcase]
    end
    if ! year && date =~ /\d\d/
      year = Integer($&)
    end
    return year, month, dayofmonth
d83 5
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@d7 1
a7 4
  DAYS = {
    'sun' => 0, 'mon' => 1, 'tue' => 2, 'wed' => 3,
    'thu' => 4, 'fri' => 5, 'sat' => 6 }
  DAYPAT = DAYS.keys.join('|')
d10 2
a11 48
    # part of ISO 8601
    # yyyy-mm-dd | yyyy-mm | yyyy
    # date hh:mm:ss | date Thh:mm:ss
    if date =~ /^(\d\d\d\d)-?(?:(\d\d)-?(\d\d)?)? *T?(?:(\d\d):?(\d\d):?(\d\d)?)?$/
      return $1.to_i,
	if $2 then $2.to_i else 1 end,
	if $3 then $3.to_i else 1 end,
	if $4 then $4.to_i end,
	if $5 then $5.to_i end,
	if $6 then $6.to_i end,
	nil,
	nil
    end
    date = date.dup
    if date.sub!(/(#{DAYPAT})[a-z]*,?/i, ' ')
      wday = DAYS[$1.downcase]
    end
    if date.sub!(/(\d+):(\d+)(?::(\d+))?\s*(am|pm)?\s*(?:\s+([a-z]{1,4}(?:\s+[a-z]{1,4})?|[-+]\d{4}))?/i, ' ')
      hour = $1.to_i
      min = $2.to_i
      if $3
	sec = $3.to_i
      end
      if $4 == 'pm'
	hour += 12
      end
      if $5
	zone = $5
      end
    end
    if date.sub!(/(\d+)\S*\s+(#{MONTHPAT})\S*(?:\s+(\d+))?/i, ' ')
      mday = $1.to_i
      mon = MONTHS[$2.downcase]
      if $3
	year = $3.to_i
      end
    elsif date.sub!(/(#{MONTHPAT})\S*\s+(\d+)\S*\s*,?(?:\s+(\d+))?/i, ' ')
      mon = MONTHS[$1.downcase]
      mday = $2.to_i
      if $3
	year = $3.to_i
      end
    elsif date.sub!(/(\d+)\/(\d+)(?:\/(\d+))/, ' ')
      mon = $1.to_i
      mday = $2.to_i
      if $3
	year = $3.to_i
      end
d13 26
a38 1
    return year, mon, mday, hour, min, sec, zone, wday
a41 5
end

if __FILE__ == $0
  p Time.now.asctime
  p ParseDate.parsedate(Time.now.asctime)
@


1.1.1.2.2.1
log
@990201
@
text
@d11 1
a11 1

a60 4
    elsif date.sub!(/(\d+)-(#{MONTHPAT})-(\d+)/i, ' ')
      mday = $1.to_i
      mon = MONTHS[$2.downcase]
      year = $3.to_i
@


1.1.1.2.2.2
log
@990205
@
text
@d12 1
a12 1
  def parsedate(date, guess=false) 
a59 13
      end
    elsif date.sub!(/(\d+)-(#{MONTHPAT})-(\d+)/i, ' ')
      mday = $1.to_i
      mon = MONTHS[$2.downcase]
      year = $3.to_i
    end
    if guess
      if year < 100
	if year >= 69
	  year += 1900
	else
	  year += 2000
	end
@


1.1.1.2.2.3
log
@990624
@
text
@d49 1
a49 1
    elsif date.sub!(/(#{MONTHPAT})\S*\s+(\d+)\S*,?(?:\s+(\d+))?/i, ' ')
@


1.1.1.1.4.1
log
@__FILE__,__LINE__
@
text
@d16 2
a17 2
    if date =~ /(19|20)(\d\d)/
      year = Integer($2)
@


1.1.1.1.4.2
log
@*** empty log message ***
@
text
@d7 1
a7 4
  DAYS = {
    'sun' => 0, 'mon' => 1, 'tue' => 2, 'wed' => 3,
    'thu' => 4, 'fri' => 5, 'sat' => 6 }
  DAYPAT = DAYS.keys.join('|')
d10 2
a11 46
    # ISO 8601?
    if date =~ /(\d\d\d\d)-?(?:(\d\d)-?(\d\d)?)? *(?:(\d\d):(\d\d)(?::(\d\d))?)?/
      return $1.to_i,
	if $2 then $2.to_i else 1 end,
	if $3 then $3.to_i else 1 end,
	nil,
	if $4 then $4.to_i end,
	if $5 then $5.to_i end,
	if $6 then $6.to_i end,
	nil
    end
    date = date.dup
    if date.sub!(/(#{DAYPAT})[a-z]*,?/i, ' ')
      wday = DAYS[$1.downcase]
    end
    if date.sub!(/(\d+):(\d+)(?::(\d+))?\s*(am|pm)?\s*(?:\s+([a-z]{1,4}(?:\s+[a-z]{1,4})|[-+]\d{4}))?/i, ' ')
      hour = $1.to_i
      min = $2.to_i
      if $3
	sec = $3.to_i
      end
      if $4 == 'pm'
	hour += 12
      end
      if $5
	zone = $5
      end
    end
    if date.sub!(/(\d+)\S*\s+(#{MONTHPAT})\S*(?:\s+(\d+))?/i, ' ')
      mday = $1.to_i
      mon = MONTHS[$2.downcase]
      if $3
	year = $3.to_i
      end
    elsif date.sub!(/(#{MONTHPAT})\S*\s+(\d+)\S*\s*,?(?:\s+(\d+))?/i, ' ')
      mon = MONTHS[$1.downcase]
      mday = $2.to_i
      if $3
	year = $3.to_i
      end
    elsif date.sub!(/(\d+)\/(\d+)(?:\/(\d+))/, ' ')
      mon = $1.to_i
      mday = $2.to_i
      if $3
	year = $3.to_i
      end
d13 26
a38 1
    return year, mon, mday, wday, hour, min, sec, zone
a41 5
end

if __FILE__ == $0
  p Time.now.asctime
  p ParseDate.parsedate(Time.now.asctime)
@


1.1.1.1.4.3
log
@pass_block, etc.
@
text
@d14 1
a14 1
    if date =~ /^(\d\d\d\d)-?(?:(\d\d)-?(\d\d)?)? *(?:(\d\d):(\d\d)(?::(\d\d))?)?$/
d28 1
a28 1
    if date.sub!(/(\d+):(\d+)(?::(\d+))?\s*(am|pm)?\s*(?:\s+([a-z]{1,4}(?:\s+[a-z]{1,4})?|[-+]\d{4}))?/i, ' ')
@


1.1.1.1.4.4
log
@1.1b8pre1
@
text
@d13 2
a14 4
    # part of ISO 8601
    # yyyy-mm-dd | yyyy-mm | yyyy
    # date hh:mm:ss | date Thh:mm:ss
    if date =~ /^(\d\d\d\d)-?(?:(\d\d)-?(\d\d)?)? *T?(?:(\d\d):?(\d\d):?(\d\d)?)?$/
@


1.1.1.1.4.5
log
@parsedate
@
text
@d20 1
a23 1
	nil,
d62 1
a62 1
    return year, mon, mday, hour, min, sec, zone, wday
@
