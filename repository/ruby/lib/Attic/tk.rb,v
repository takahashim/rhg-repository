head	1.2;
access;
symbols
	v1_6_3:1.2
	ruby_1_6:1.2.0.2
	v1_1d1:1.1.1.2.2.25.2.3
	v1_1d0:1.1.1.2.2.25.2.3
	v1_1c7:1.1.1.2.2.26
	v1_1c6:1.1.1.2.2.26
	v1_1d-start:1.1.1.2.2.25.2.1
	v1_1c5:1.1.1.2.2.25
	v1_1dev:1.1.1.2.2.25.0.2
	v1_1c4:1.1.1.2.2.25
	v1_1c3:1.1.1.2.2.25
	v1_1c2:1.1.1.2.2.25
	v1_1c1:1.1.1.2.2.23
	v1_1c0:1.1.1.2.2.21
	v1_1b9_31:1.1.1.2.2.20
	v1_1b9_30:1.1.1.2.2.19
	v1_1b9_28:1.1.1.2.2.17
	v1_1b9_27:1.1.1.2.2.16
	v1_1b9_26:1.1.1.2.2.15
	r1_1b9_25:1.1.1.2.2.13
	r1_1b9_24:1.1.1.2.2.12
	v1_1b9_23:1.1.1.2.2.11
	v1_1b9_22:1.1.1.2.2.11
	v1_1b9_20:1.1.1.2.2.11
	v1_1b9_18:1.1.1.2.2.11
	v1_1b9_16:1.1.1.2.2.10
	v1_1b9_15:1.1.1.2.2.9
	v1_1b9_13:1.1.1.2.2.9
	v1_1b9_12:1.1.1.2.2.8
	v1_1b9_11:1.1.1.2.2.7
	v1_1b9_08:1.1.1.2.2.6
	v1_1b9_07:1.1.1.2.2.6
	r1_1b9:1.1.1.2.2.5
	v1_1b8:1.1.1.2.2.5
	v1_1b7:1.1.1.2.2.4
	v1_1b6:1.1.1.2.2.3
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;


1.2
date	99.08.13.06.09.53;	author matz;	state dead;
branches;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.18;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	;

1.1.1.2.2.1
date	98.01.16.12.36.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.21.06.35.17;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.01.22.03.34.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.01.30.10.18.25;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.02.13.09.40.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.03.30.09.41.18;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.04.16.10.39.21;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.04.17.09.29.35;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.04.21.08.41.09;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.04.27.10.04.11;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.04.30.07.41.22;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.06.05.09.54.27;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.06.11.10.03.20;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.06.16.04.24.38;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.06.18.07.47.07;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.06.19.09.32.12;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.06.26.09.45.00;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.07.03.07.06.43;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.07.09.08.40.39;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.07.15.06.13.02;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.07.17.05.12.44;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.07.21.09.18.01;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.07.24.04.42.06;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.07.29.09.50.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	98.08.10.05.41.25;	author matz;	state Exp;
branches
	1.1.1.2.2.25.2.1;
next	1.1.1.2.2.26;

1.1.1.2.2.26
date	98.10.06.02.45.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.27;

1.1.1.2.2.27
date	98.11.17.09.12.46;	author matz;	state dead;
branches;
next	;

1.1.1.2.2.25.2.1
date	98.09.08.07.09.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25.2.2;

1.1.1.2.2.25.2.2
date	98.10.06.03.28.26;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25.2.3;

1.1.1.2.2.25.2.3
date	98.11.25.03.31.18;	author matz;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove obsolete files
@
text
@#
#		tk.rb - Tk interface for ruby
#			$Date: 1998/01/16 12:13:07 $
#			by Yukihiro Matsumoto <matz@@caelum.co.jp>

if defined? Thread and $tk_thread_safe
  require "tkthcore"
else
  require "tkcore"
end

module TkSelection
  include Tk
  extend Tk
  def clear(win=Tk.root)
    tk_call 'selection', 'clear', win.path
  end
  def get(type=None)
    tk_call 'selection', 'get', type
  end
  def TkSelection.handle(win, func, type=None, format=None)
    id = install_cmd(func)
    tk_call 'selection', 'handle', win.path, id, type, format
  end
  def handle(func, type=None, format=None)
    TkSelection.handle self, func, type, format
  end
  def TkSelection.own(win, func=None)
    id = install_cmd(func)
    tk_call 'selection', 'own', win.path, id
  end
  def own(func=None)
    TkSelection.own self, func
  end

  module_function :clear, :get
end

module TkWinfo
  include Tk
  extend Tk
  def TkWinfo.atom(name)
    tk_call 'winfo', name
  end
  def winfo_atom(name)
    TkWinfo.atom name
  end
  def TkWinfo.atomname(id)
    tk_call 'winfo', id
  end
  def winfo_atomname(id)
    TkWinfo.atomname id
  end
  def TkWinfo.cells(window)
    number(tk_call('winfo', window.path))
  end
  def winfo_cells
    TkWinfo.cells self
  end
  def TkWinfo.children(window)
    c = tk_call('winfo', 'children', window.path)
    list(c)
  end
  def winfo_children
    TkWinfo.children self
  end
  def TkWinfo.classname(window)
    tk_call 'winfo', 'class', window.path
  end
  def winfo_classname
    TkWinfo.classname self
  end
  def TkWinfo.containing(rootX, rootY)
    path = tk_call('winfo', 'class', window.path)
    window(path)
  end
  def winfo_containing(x, y)
    TkWinfo.containing x, y
  end
  def TkWinfo.depth(window)
    number(tk_call('winfo', 'depth', window.path))
  end
  def winfo_depth(window)
    TkWinfo.depth self
  end
  def TkWinfo.exist?(window)
    bool(tk_call('winfo', 'exists', window.path))
  end
  def winfo_exist?(window)
    TkWinfo.exist? self
  end
  def TkWinfo.fpixels(window, number)
    number(tk_call('winfo', 'fpixels', window.path, number))
  end
  def winfo_fpixels(window, number)
    TkWinfo.fpixels self
  end
  def TkWinfo.geometry(window)
    list(tk_call('winfo', 'geometry', window.path))
  end
  def winfo_geometry(window)
    TkWinfo.geometry self
  end
  def TkWinfo.height(window)
    number(tk_call('winfo', 'height', window.path))
  end
  def winfo_height(window)
    TkWinfo.height self
  end
  def TkWinfo.id(window)
    number(tk_call('winfo', 'id', window.path))
  end
  def winfo_id(window)
    TkWinfo.id self
  end
  def TkWinfo.mapped?(window)
    bool(tk_call('winfo', 'ismapped', window.path))
  end
  def winfo_mapped?(window)
    TkWinfo.mapped? self
  end
  def TkWinfo.parent(window)
    window(tk_call('winfo', 'parent', window.path))
  end
  def winfo_parent(window)
    TkWinfo.parent self
  end
  def TkWinfo.widget(id)
    window(tk_call('winfo', 'pathname', id))
  end
  def winfo_widget(id)
    TkWinfo.widget id
  end
  def TkWinfo.pixels(window, number)
    number(tk_call('winfo', 'pixels', window.path, number))
  end
  def winfo_pixels(window, number)
    TkWinfo.pixels self, number
  end
  def TkWinfo.reqheight(window)
    number(tk_call('winfo', 'reqheight', window.path))
  end
  def winfo_reqheight(window)
    TkWinfo.reqheight self
  end
  def TkWinfo.reqwidth(window)
    number(tk_call('winfo', 'reqwidth', window.path))
  end
  def winfo_reqwidth(window)
    TkWinfo.reqwidth self
  end
  def TkWinfo.rgb(window, color)
    list(tk_call('winfo', 'rgb', window.path, color))
  end
  def winfo_rgb(window, color)
    TkWinfo.rgb self, color
  end
  def TkWinfo.rootx(window)
    number(tk_call('winfo', 'rootx', window.path))
  end
  def winfo_rootx(window)
    TkWinfo.rootx self
  end
  def TkWinfo.rooty(window)
    number(tk_call('winfo', 'rooty', window.path))
  end
  def winfo_rooty(window)
    TkWinfo.rooty self
  end
  def TkWinfo.screen(window)
    tk_call 'winfo', 'screen', window.path
  end
  def winfo_screen(window)
    TkWinfo.screen self
  end
  def TkWinfo.screencells(window)
    number(tk_call('winfo', 'screencells', window.path))
  end
  def winfo_screencells(window)
    TkWinfo.screencells self
  end
  def TkWinfo.screendepth(window)
    number(tk_call('winfo', 'screendepth', window.path))
  end
  def winfo_screendepth(window)
    TkWinfo.screendepth self
  end
  def TkWinfo.screenheight (window)
    number(tk_call('winfo', 'screenheight', window.path))
  end
  def winfo_screenheight(window)
    TkWinfo.screenheight self
  end
  def TkWinfo.screenmmheight(window)
    number(tk_call('winfo', 'screenmmheight', window.path))
  end
  def winfo_screenmmheight(window)
    TkWinfo.screenmmheight self
  end
  def TkWinfo.screenmmwidth(window)
    number(tk_call('winfo', 'screenmmwidth', window.path))
  end
  def winfo_screenmmwidth(window)
    TkWinfo.screenmmwidth self
  end
  def TkWinfo.screenvisual(window)
    tk_call 'winfo', 'screenvisual', window.path
  end
  def winfo_screenvisual(window)
    TkWinfo.screenvisual self
  end
  def TkWinfo.screenwidth(window)
    number(tk_call('winfo', 'screenwidth', window.path))
  end
  def winfo_screenwidth(window)
    TkWinfo.screenwidth self
  end
  def TkWinfo.toplevel(window)
    window(tk_call('winfo', 'toplevel', window.path))
  end
  def winfo_toplevel(window)
    TkWinfo.toplevel self
  end
  def TkWinfo.visual(window)
    tk_call 'winfo', 'visual', window.path
  end
  def winfo_visual(window)
    TkWinfo.visual self
  end
  def TkWinfo.vrootheigh(window)
    number(tk_call('winfo', 'vrootheight', window.path))
  end
  def winfo_vrootheight(window)
    TkWinfo.vrootheight self
  end
  def TkWinfo.vrootwidth(window)
    number(tk_call('winfo', 'vrootwidth', window.path))
  end
  def winfo_vrootwidth(window)
    TkWinfo.vrootwidth self
  end
  def TkWinfo.vrootx(window)
    number(tk_call('winfo', 'vrootx', window.path))
  end
  def winfo_vrootx(window)
    TkWinfo.vrootx self
  end
  def TkWinfo.vrooty(window)
    number(tk_call('winfo', 'vrooty', window.path))
  end
  def winfo_vrooty(window)
    TkWinfo.vrooty self
  end
  def TkWinfo.width(window)
    number(tk_call('winfo', 'width', window.path))
  end
  def winfo_width(window)
    TkWinfo.width self
  end
  def TkWinfo.x(window)
    number(tk_call('winfo', 'x', window.path))
  end
  def winfo_x(window)
    TkWinfo.x self
  end
  def TkWinfo.y(window)
    number(tk_call('winfo', 'y', window.path))
  end
  def winfo_y(window)
    TkWinfo.y self
  end
end

module TkPack
  include Tk
  extend Tk
  def configure(win, *args)
    if args[-1].kind_of?(Hash)
      keys = args.pop
    end
    wins = [win.epath]
    for i in args
      wins.push i.epath
    end
    tk_call "pack", 'configure', *(wins+hash_kv(keys))
  end

  def forget(*args)
    tk_call 'pack', 'forget' *args
  end

  def propagate(master, bool=None)
    bool(tk_call('pack', 'propagate', mastaer.epath, bool))
  end
  module_function :configure, :forget, :propagate
end

module TkOption
  include Tk
  extend Tk
  def add pat, value, pri=None
    tk_call 'option', 'add', pat, value, pri
  end
  def clear
    tk_call 'option', 'clear'
  end
  def get win, classname, name
    tk_call 'option', 'get', classname, name
  end
  def readfile file, pri=None
    tk_call 'option', 'readfile', file, pri
  end
  module_function :add, :clear, :get, :readfile
end

class TkObject<TkKernel
  include Tk

  def path
    return @@path
  end

  def epath
    return @@path
  end

  def tk_send(cmd, *rest)
    tk_call path, cmd, *rest
  end
  private :tk_send

  def method_missing(id, *args)
    if (args.length == 1)
      configure id.id2name, args[0]
    else
      $@@ = error_at
      super
    end
  end

  def []=(id, val)
    configure id, val
  end

  def configure(slot, value)
    if value == FALSE
      value = "0"
    elsif value.kind_of? Proc
      value = install_cmd(value)
    end
    tk_call path, 'configure', "-#{slot}", value
  end

  def configure_cmd(slot, value)
    configure slot, install_cmd(value)
  end

  def bind(context, cmd=Proc.new, args=nil)
    _bind path, context, cmd, args
  end

  def tk_trace_variable(v)
    unless v.kind_of?(TkVariable)
      fail ArgumentError, format("requires TkVariable given %s", v.type)
    end
    v
  end
  private :tk_trace_variable

  def destroy
    tk_call 'trace', 'vdelete', @@tk_vn, 'w', @@var_id if @@var_id
  end
end


class TkVariable
  include Tk
  $tk_variable_id = "v00000"
  def initialize(val="")
    @@id = $tk_variable_id
    $tk_variable_id = $tk_variable_id.succ
    tk_call(format('global %s; set %s', @@id, @@id), val)
  end

  def id
    @@id
  end

  def value
    tk_call(format('global %s; set', @@id), @@id)
  end

  def value=(val)
    tk_call(format('global %s; set %s', @@id, @@id), val)
  end

  def to_i
    Integer(number(value))
  end

  def to_f
    Float(number(value))
  end

  def to_s
    String(string(value))
  end

  def inspect
    format "<TkVariable: %s>", @@id
  end

  def to_a
    list(value)
  end
end

class TkWindow<TkObject
  $tk_window_id = "w00000"
  def initialize(parent=nil, keys=nil)
    id = $tk_window_id
    $tk_window_id = $tk_window_id.succ
    if !parent or parent == Tk.root
      @@path = format(".%s", id);
    else
      @@path = format("%s.%s", parent.path, id)
    end
    $tk_window_list[@@path] = self
    create_self
    if keys
      tk_call @@path, 'configure', *hash_kv(keys)
    end
  end

  def create_self
  end
  private :create_self

  def pack(keys = nil)
    tk_call 'pack', epath, *hash_kv(keys)
    self
  end

  def unpack(keys = nil)
    tk_call 'pack', 'forget', epath
    self
  end

  def place(keys = nil)
    tk_call 'place', epath, *hash_kv(keys)
    self
  end

  def unplace(keys = nil)
    tk_call 'place', 'forget', epath, *hash_kv(keys)
    self
  end
  alias place_forget unplace

  def place_config(keys)
    tk_call "place", 'configure', epath, *hash_kv(keys)
  end

  def place_info()
    ilist = list(tk_call('place', 'info', epath))
    info = {}
    while key = ilist.shift
      info[key[1,-1]] = ilist.shift
    end
    return info
  end

  def place_slaves()
    list(tk_call('place', 'slaves', epath)).collect { |w|
      window(w)
    }
  end

  def focus
    tk_call 'focus', path
    self
  end

  def grab(*args)
    if !args or args.length == 0
      tk_call 'grab', 'set', path
    elsif args.length == 1
      case args[0]
      when 'global'
	tk_call 'grab', 'set', '-global', path
      else
	val = tk_call('grab', arg[0], path)
      end
      case args[0]
      when 'current'
	return window(val)
      when 'status'
	return val
      end
    else
      fail ArgumentError, 'wrong # of args'
    end
  end

  def lower(below=None)
    tk_call 'lower', path, below
    self
  end
  def raise(above=None)
    tk_call 'raise', path, above
    self
  end

  def command(cmd=Proc.new)
    configure_cmd 'command', cmd
  end

  def colormodel model=None
    tk_call 'tk', 'colormodel', path, model
    self
  end

  def destroy
    tk_call 'destroy', path
    if @@cmdtbl
      for id in @@cmdtbl
	uninstall_cmd id
      end
    end
    $tk_window_list[path] = nil
    super
  end
end

class TkRoot<TkWindow
  include Wm
  def TkRoot.new
    return $tk_root if $tk_root
    super
  end
  def path
    "."
  end
  $tk_root = TkRoot.new
  $tk_window_list['.'] = $tk_root
end

class TkToplevel<TkWindow
  include Wm
  def initialize(parent=nil, screen=nil, classname=nil)
    @@screen = screen if screen
    @@classname = classname if classname
    super
  end

  def create_self
    s = []
    s.push "-screen #@@screen" if @@screen 
    s.push "-class #@@classname" if @@classname
    tk_call 'toplevel', path, *s
  end
end

class TkFrame<TkWindow
  def create_self
    tk_call 'frame', @@path
  end
end

class TkLabel<TkWindow
  def create_self
    tk_call 'label', @@path
  end
  def textvariable(v)
    configure 'textvariable', tk_trace_variable(v)
  end
end

class TkButton<TkLabel
  def create_self
    tk_call 'button', @@path
  end
  def invoke
    tk_send 'invoke'
  end
  def flash
    tk_send 'flash'
  end
end

class TkRadioButton<TkButton
  def create_self
    tk_call 'radiobutton', @@path
  end
  def deselect
    tk_send 'deselect'
  end
  def select
    tk_send 'select'
  end
  def variable(v)
    configure 'variable', tk_trace_variable(v)
  end
end

class TkCheckButton<TkRadioButton
  def create_self
    tk_call 'checkbutton', @@path
  end
  def toggle
    tk_send 'toggle'
  end
end

class TkMessage<TkLabel
  def create_self
    tk_call 'message', @@path
  end
end

class TkScale<TkWindow
  def create_self
    tk_call 'scale', path
  end

  def get
    number(tk_send('get'))
  end

  def set(val)
    tk_send "set", val
  end

  def value
    get
  end

  def value= (val)
    set val
  end
end

class TkScrollbar<TkWindow
  def create_self
    tk_call 'scrollbar', path
  end

  def delta(deltax=None, deltay=None)
    number(tk_send('delta', deltax, deltay))
  end

  def fraction(x=None, y=None)
    number(tk_send('fraction', x, y))
  end

  def identify(x=None, y=None)
    tk_send('fraction', x, y)
  end

  def get
    ary1 = tk_send('get', path).split
    ary2 = []
    for i in ary1
      push number(i)
    end
    ary2
  end

  def set(first, last)
    tk_send "set", first, last
  end
end

# abstract class for Text and Listbox
class TkTextWin<TkWindow
  def bbox(index)
    tk_send 'bbox', index
  end
  def delete(first, last=None)
    tk_send 'delete', first, last
  end
  def get(*index)
    tk_send 'get', *index
  end
  def insert(index, *rest)
    tk_send 'insert', index, *rest
  end
  def index(index)
    tk_send 'index', index
  end
  def insert(index, chars, *args)
    tk_send 'insert', index, chars, *args
  end
  def scan_mark(x, y)
    tk_send 'scan', 'mark', x, y
  end
  def scan_dragto(x, y)
    tk_send 'scan', 'dragto', x, y
  end
  def see(index)
    tk_send 'see', index
  end
end

class TkListbox<TkTextWin
  def create_self
    tk_call 'listbox', path
  end

  def curselection
    tk_send 'curselection'
  end
  def nearest(y)
    tk_send 'nearest', y
  end
  def selection_anchor(index)
    tk_send 'selection', 'anchor', index
  end
  def selection_clear(first, last=None)
    tk_send 'selection', 'clear', first, last
  end
  def selection_includes
    bool(tk_send('selection', 'includes'))
  end
  def selection_set(first, last=None)
    tk_send 'selection', 'set', first, last
  end
  def xview(cmd, index, *more)
    tk_send 'xview', cmd, index, *more
  end
  def yview(cmd, index, *more)
    tk_send 'yview', cmd, index, *more
  end
end

class TkMenu<TkWindow
  def create_self
    tk_call 'menu', path
  end
  def activate(index)
    tk_send 'activate', index
  end
  def add(type, keys=nil)
    tk_send 'add', type, *hash_kv(keys)
  end
  def index(index)
    tk_send 'index', index
  end
  def invoke
    tk_send 'invoke'
  end
  def insert(index, type, *keys)
    tk_send 'add', index, type, *hash_kv(keys)
  end
  def post(x, y)
    tk_send 'post', x, y
  end
  def postcascade(index)
    tk_send 'postcascade', index
  end
  def postcommand(cmd=Proc.new)
    configure_cmd 'postcommand', cmd
  end
  def menutype(index)
    tk_send 'type', index
  end
  def unpost
    tk_send 'unpost'
  end
  def yposition(index)
    number(tk_send('yposition', index))
  end
end

class TkMenubutton<TkLabel
  def create_self
    tk_call 'menubutton', path
  end
end

module TkComposite
  def initialize(parent=nil, *args)
    @@frame = TkFrame.new(parent)
    @@path = @@epath = @@frame.path
    initialize_composite(*args)
  end

  def epath
    @@epath
  end

  def initialize_composite(*args) end
  private :initialize_composite

  def delegate(option, *wins)
    @@delegates = {} if not @@delegates
    @@delegates['DEFAULT'] = @@frame
    if option.kind_of?(String)
      @@delegates[option] = wins
    else
      for i in option
	@@delegates[i] = wins
      end
    end
  end

  def configure(slot, value)
    if @@delegates and @@delegates[slot]
      for i in @@delegates[slot]
	if not i
	  i = @@delegates['DEFALUT']
	  redo
	else
	  last = i.configure(slot, value)
	end
      end
      last
    else
      super
    end
  end
end

autoload :TkCanvas, 'tkcanvas'
autoload :TkImage, 'tkcanvas'
autoload :TkBitmapImage, 'tkcanvas'
autoload :TkPhotoImage, 'tkcanvas'
autoload :TkEntry, 'tkentry'
autoload :TkText, 'tktext'
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
#			$Date: 1995/11/03 08:17:15 $
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d2 8
a9 479
#		tk.rb - Tk interface modue using tcltklib
#			$Date: 1997/10/24 15:44:15 $
#			by Yukihiro Matsumoto <matz@@netlab.co.jp>

# use Shigehiro's tcltklib
require "tcltklib"
require "tkutil"

module TkComm
  None = Object.new
  def None.to_s
    'None'
  end

  Tk_CMDTBL = {}
  Tk_WINDOWS = {}

  def error_at
    frames = caller(1)
    frames.delete_if do |c|
      c =~ %r!/tk(|core|thcore|canvas|text|entry|scrollbox)\.rb:\d+!
    end
    frames
  end
  private :error_at

  def tk_tcl2ruby(val)
    case val
    when /^-?\d+$/
      val.to_i
    when /^\./
      Tk_WINDOWS[val]
    when /^rb_out (c\d+)/
      Tk_CMDTBL[$1]
    when / /
      val.split.collect{|elt|
	tk_tcl2ruby(elt)
      }
    when /^-?\d+\.\d*$/
      val.to_f
    else
      val
    end
  end

  def tk_split_list(str)
    idx = str.index('{')
    return tk_tcl2ruby(str) if not idx

    list = tk_tcl2ruby(str[0,idx])
    str = str[idx+1..-1]
    i = -1
    brace = 1
    str.each_byte {|c|
      i += 1
      brace += 1 if c == ?{
      brace -= 1 if c == ?}
      break if brace == 0
    }
    if str[0, i] == ' '
      list.push ' '
    else
      list.push tk_split_list(str[0, i])
    end
    list += tk_split_list(str[i+1..-1])
    list
  end
  private :tk_tcl2ruby, :tk_split_list

  def hash_kv(keys)
    conf = []
    if keys and keys != None
      for k, v in keys
	 conf.push("-#{k}")
	 v = install_cmd(v) if v.kind_of? Proc
	 conf.push(v)
      end
    end
    conf
  end
  private :hash_kv

  def bool(val)
    case val
    when "1", 1, 'yes', 'true'
      TRUE
    else
      FALSE
    end
  end
  def number(val)
    case val
    when /^-?\d+$/
      val.to_i
    when /^-?\d+\.\d*$/
      val.to_f
    else
      val
    end
  end
  def string(val)
    if val == "{}"
      ''
    elsif val[0] == ?{
      val[1..-2]
    else
      val
    end
  end
  def list(val)
    tk_split_list(val)
  end
  def window(val)
    Tk_WINDOWS[val]
  end
  def procedure(val)
    if val =~ /^rb_out (c\d+)/
      Tk_CMDTBL[$1]
    else
      nil
    end
  end
  private :bool, :number, :string, :list, :window, :procedure

  Tk_IDs = [0]		# [0]-cmdid, [1]-winid
  def _curr_cmd_id
    id = format("c%.4d", Tk_IDs[0])
  end
  def _next_cmd_id
    id = _curr_cmd_id
    Tk_IDs[0] += 1
  end
  def install_cmd(cmd)
    return '' if cmd == ''
    id = _next_cmd_id
    Tk_CMDTBL[id] = cmd
    @@cmdtbl = [] if not @@cmdtbl
    @@cmdtbl.push id
    return format("rb_out %s", id);
  end
  def uninstall_cmd(id)
    Tk_CMDTBL[id] = nil
  end
  private :install_cmd, :uninstall_cmd

  def install_win(ppath)
    id = format("w%.4d", Tk_IDs[0])
    Tk_IDs[0] += 1
    if !ppath or ppath == "."
      @@path = format(".%s", id);
    else
      @@path = format("%s.%s", ppath, id)
    end
    Tk_WINDOWS[@@path] = self
  end

  def uninstall_win()
    Tk_WINDOWS[@@path] = nil
  end

  class Event
    def initialize(seq,b,f,h,k,s,t,w,x,y,aa,ee,kk,nn,ww,tt,xx,yy)
      @@serial = seq
      @@num = b
      @@focus = (f == 1)
      @@height = h
      @@keycode = k
      @@state = s
      @@time = t
      @@width = w
      @@x = x
      @@y = y
      @@char = aa
      @@send_event = (ee == 1)
      @@keysym = kk
      @@keysym_num = nn
      @@type = tt
      @@widget = ww
      @@x_root = xx
      @@y_root = yy
    end
    attr :serial
    attr :num
    attr :focus
    attr :height
    attr :keycode
    attr :state
    attr :time
    attr :width
    attr :x
    attr :y
    attr :char
    attr :send_event
    attr :keysym
    attr :keysym_num
    attr :type
    attr :widget
    attr :x_root
    attr :y_root
  end

  def install_bind(cmd, args=nil)
    if args
      id = install_cmd(proc{|arg|
	TkUtil.eval_cmd cmd, *arg
      })
      id + " " + args
    else
      id = install_cmd(proc{|arg|
	TkUtil.eval_cmd cmd, Event.new(*arg)
      })
      id + ' %# %b %f %h %k %s %t %w %x %y %A %E %K %N %W %T %X %Y'
    end
  end

  def _bind(path, context, cmd, args=nil)
    begin
      id = install_bind(cmd, args)
      tk_call 'bind', path, "<#{context}>", id
    rescue
      uninstall_cmd(id)
      fail
    end
  end
  private :install_bind, :_bind

  def bind_all(context, cmd=Proc.new, args=nil)
    _bind 'all', context, cmd, args
  end

  def pack(*args)
    TkPack.configure *args
  end

  def after(ms, cmd=Proc.new)
    myid = _curr_cmd_id
    tk_call 'after', ms,
      install_cmd(proc{
		    TkUtil.eval_cmd cmd
		    uninstall_cmd myid
		  })
  end
end

module TkCore
  include TkComm
  extend TkComm

  INTERP = TclTkIp.new
  INTERP._eval("proc rb_out {args} { ruby [format \"TkCore.callback %%Q!%s!\" $args] }")

  def TkCore.callback(arg)
    arg = Array(tk_split_list(arg))
    TkUtil.eval_cmd Tk_CMDTBL[arg.shift], *arg
  end

  def mainloop
    TclTkLib.mainloop
  end

  def _get_eval_string(*args)
    argstr = ""
    args.each{|arg|
      next if arg == None
      if arg.kind_of?(Hash)
	str = hash_kv(arg).join(" ")
      elsif arg == nil
	str = ""
      elsif arg == false
	str = "0"
      elsif arg == true
	str = "1"
      elsif (arg.respond_to?(:to_eval))
	str = arg.to_eval()
      else
	str = arg.to_s()
      end
      argstr += " " if argstr != ""
      argstr += '"' + str.gsub(/[][$"]/, '\\\\\&') + '"'
    }
    return argstr
  end

  def tk_call(*args)
    argstr = _get_eval_string(*args)

    res = INTERP._eval(argstr)
    if  INTERP._return_value() != 0
      fail RuntimeError, res, error_at
    end
    return res
  end
end

module Tk
  include TkCore
  extend Tk

  def root
    TkRoot.new
  end

  def bell
    tk_call 'bell'
  end

  def mainloop
    TclTkLib.mainloop
  end

  module Scrollable
    def xscrollcommand(cmd=Proc.new)
      configure_cmd 'xscrollcommand', cmd
    end
    def yscrollcommand(cmd=Proc.new)
      configure_cmd 'yscrollcommand', cmd
    end
  end

  module Wm
    def aspect(*args)
      w = window(tk_call('wm', 'grid', path, *args))
      w.split.collect{|s|s.to_i} if args.length == 0
    end
    def client(name=None)
      tk_call 'wm', 'client', path, name
    end
    def colormapwindows(*args)
      list(tk_call('wm', 'colormapwindows', path, *args))
    end
    def wm_command(value=None)
      string(tk_call('wm', 'command', path, value))
    end
    def deiconify
      tk_call 'wm', 'deiconify', path
    end
    def focusmodel(*args)
      tk_call 'wm', 'focusmodel', path, *args
    end
    def frame
      tk_call 'wm', 'frame', path
    end
    def geometry(*args)
      list(tk_call('wm', 'geometry', path, *args))
    end
    def grid(*args)
      w = tk_call('wm', 'grid', path, *args)
      list(w) if args.size == 0
    end
    def group(*args)
      tk_call 'wm', 'path', path, *args
    end
    def iconbitmap(*args)
      tk_call 'wm', 'bitmap', path, *args
    end
    def iconify
      tk_call 'wm', 'iconify'
    end
    def iconmask(*args)
      tk_call 'wm', 'iconmask', path, *args
    end
    def iconname(*args)
      tk_call 'wm', 'iconname', path, *args
    end
    def iconposition(*args)
      w = tk_call('wm', 'iconposition', path, *args)
      list(w) if args.size == 0
    end
    def iconwindow(*args)
      tk_call 'wm', 'iconwindow', path, *args
    end
    def maxsize(*args)
      w = tk_call('wm', 'maxsize', path, *args)
      list(w) if not args.size == 0
    end
    def minsize(*args)
      w = tk_call('wm', 'minsize', path, *args)
      list(w) if args.size == 0
    end
    def overrideredirect(bool=None)
      if bool == None
	bool(tk_call('wm', 'overrideredirect', path))
      else
	tk_call 'wm', 'overrideredirect', path, bool
      end
    end
    def positionfrom(*args)
      tk_call 'wm', 'positionfrom', path, *args
    end
    def protocol(name, func=None)
      func = install_cmd(func) if not func == None
      tk_call 'wm', 'command', path, name, func
    end
    def resizable(*args)
      w = tk_call('wm', 'resizable', path, *args)
      if args.length == 0
	list(w).collect{|e| bool(e)}
      end
    end
    def sizefrom(*args)
      list(tk_call('wm', 'sizefrom', path, *args))
    end
    def state
      tk_call 'wm', 'state', path
    end
    def title(*args)
      tk_call 'wm', 'title', path, *args
    end
    def transient(*args)
      tk_call 'wm', 'transient', path, *args
    end
    def withdraw
      tk_call 'wm', 'withdraw', path
    end
  end
end

class TkVariable
  include Tk

  Tk_VARIABLE_ID = ["v00000"]
  def initialize(val="")
    @@id = Tk_VARIABLE_ID[0]
    Tk_VARIABLE_ID[0] = Tk_VARIABLE_ID[0].succ
    INTERP._eval(format('global %s; set %s %s', @@id, @@id, _get_eval_string(val)))
  end

  def id
    @@id
  end

  def value
    INTERP._eval(format('global %s; set %s', @@id, @@id))
  end

  def value=(val)
    INTERP._eval(format('global %s; set %s %s', @@id, @@id, _get_eval_string(val)))
  end

  def to_i
    Integer(number(value))
  end

  def to_f
    Float(number(value))
  end

  def to_s
    String(string(value))
  end

  def inspect
    format "<TkVariable: %s>", @@id
  end

  def ==(other)
    case other
    when TkVariable
      self.equal(self)
    when String
      self.to_s == other
    when Integer
      self.to_i == other
    when Float
      self.to_f == other
    when Array
      self.to_a == other
    else
      false
    end
  end

  def to_a
    list(value)
  end

  def to_eval
    @@id
  end
d293 1
a293 1
    bool(tk_call('pack', 'propagate', master.epath, bool))
a326 4
  def to_eval
    @@path
  end

d375 43
d419 1
a419 1

d421 8
a428 1
    install_win(if parent then parent.path end)
d530 2
a531 1
    uninstall_win
a536 1
  ROOT = []
d538 2
a539 6
    return ROOT[0] if ROOT[0]
    new = super
    ROOT[0] = new
  end
  def create_self
    @@path = '.'
d544 2
d550 1
a550 1
  def initialize(parent=nil, screen=nil, classname=nil, keys=nil)
d553 1
a553 1
    super(parent, keys)
d664 1
a664 1
      ary2.push number(i)
d674 1
d685 3
d796 2
a797 4
    unless @@delegates
      @@delegates = {} 
      @@delegates['DEFAULT'] = @@frame
    end
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d3 1
a3 1
#			$Date: 1998/01/16 04:14:53 $
@


1.1.1.2.2.2
log
@tk.rb: update dropped
@
text
@d3 1
a3 1
#			$Date: 1998/01/16 12:36:05 $
a243 9

  def update(idle=nil)
    if idle
      tk_call 'update', 'idletasks'
    else
      tk_call 'update'
    end
  end

@


1.1.1.2.2.3
log
@tkmenubar
@
text
@d3 1
a3 1
#			$Date: 1998/01/21 06:35:17 $
a974 1
    Tk_WINDOWS["."] = new
d1232 5
a1236 3
    if @@delegates[option].kind_of?(Array)
      for i in wins
	@@delegates[option].push(i)
a1237 2
    else
      @@delegates[option] = wins
a1263 2
autoload :TkDialog, 'tkdialog'
autoload :TkMenubar, 'tkmenubar'
@


1.1.1.2.2.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
#			$Date: 1998/01/22 03:34:28 $
a28 3
    if val.include? ? 
      return val.split.collect{|v| tk_tcl2ruby(v)}
    end
@


1.1.1.2.2.5
log
@\s and assignment in conditional
@
text
@d3 1
a3 1
#			$Date: 1998/01/30 10:18:25 $
d29 1
a29 1
    if val.include? ?\s
@


1.1.1.2.2.6
log
@instance_eva/module_eval
@
text
@d3 1
a3 1
#			$Date: 1998/02/13 09:40:28 $
d292 1
a292 1
      argstr += '"' + str.gsub(/[][$"]/, '\\\\\&') + '"' #'
@


1.1.1.2.2.7
log
@*** empty log message ***
@
text
@d3 1
a3 1
#			$Date: 1998/03/30 09:41:18 $
a270 7
    if defined?(Thread)
      INTERP._eval("proc rb_after {} {
                      ruby {Thread.pass};
                      after 200 rb_after
                    }")
      INTERP._eval("rb_after")
    end
d318 4
@


1.1.1.2.2.8
log
@*** empty log message ***
@
text
@d3 1
a3 1
#			$Date: 1998/04/16 10:39:21 $
d271 7
@


1.1.1.2.2.9
log
@ruby 1.1b9_13
@
text
@d3 1
a3 1
#			$Date: 1998/04/17 09:29:35 $
d366 1
a366 1
      tk_call 'wm', 'iconify', path
@


1.1.1.2.2.10
log
@tcltklib/gtk
@
text
@d3 1
a3 1
#			$Date: 1998/04/21 08:41:09 $
a50 1
    return [] if str == ""
d52 1
a52 1
    return tk_tcl2ruby(str) unless idx
d115 1
a115 2
    p val
    tk_split_list(val).to_a
d263 1
a263 1
  INTERP._invoke("proc", "rb_out", "args", "ruby [format \"TkCore.callback %%Q!%s!\" $args]")
d274 21
a294 16
  def _get_eval_string(str)
    return str if str == None
    if str.kind_of?(Hash)
      str = hash_kv(str).join(" ")
    elsif str == nil
      str = ""
    elsif str == false
      str = "0"
    elsif str == true
      str = "1"
    elsif (str.respond_to?(:to_eval))
      str = str.to_eval()
    else
      str = str.to_s()
    end
    return str
d298 3
a300 6
    print args.join(" "), "\n" if $DEBUG
    args.filter {|x|_get_eval_string(x)}
    args.delete!(None)
    args.flatten!
    args.compact!
    res = INTERP._invoke(*args)
a303 1
    print "==> ", res, "\n" if $DEBUG
d379 1
a379 2
      w = tk_call('wm', 'iconwindow', path, *args)
      window(w) if args.size == 0
d434 1
a434 2
    s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
    INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
a818 2
      p caller
      p id.id2name
a1141 3
  def activate(y)
    tk_send 'activate', y
  end
d1143 1
a1143 1
    list(tk_send('curselection'))
d1146 1
a1146 4
    tk_send('nearest', y).to_i
  end
  def size(y)
    tk_send('size').to_i
d1161 1
a1161 2
    v = tk_send('xview', cmd, index, *more)
    v.to_i if more.size == 0
d1164 1
a1164 2
    v = tk_send('yview', cmd, index, *more)
    v.to_i if more.size == 0
@


1.1.1.2.2.11
log
@new exception model
@
text
@d3 1
a3 1
#			$Date: 1998/04/27 10:04:11 $
d116 1
d277 1
a277 1
    return nil if str == None
d297 2
d300 1
a300 13
    args.flatten!
    begin
      res = INTERP._invoke(*args)
    rescue NameError
      err = $!
      begin
        args.unshift "unknown"
        res = INTERP._invoke(*args)
      rescue
	raise unless /^invalid command/ =~ $!
	raise err
      end
    end
d822 2
@


1.1.1.2.2.12
log
@regex
@
text
@d3 1
a3 1
#			$Date: 1998/04/30 07:41:22 $
d913 1
a913 14
      info[key[1..-1]] = ilist.shift
    end
    return info
  end

  def pack_slaves()
    list(tk_call('pack', 'slaves', epath))
  end

  def pack_info()
    ilist = list(tk_call('pack', 'info', epath))
    info = {}
    while key = ilist.shift
      info[key[1..-1]] = ilist.shift
d919 3
a921 1
    list(tk_call('place', 'slaves', epath))
@


1.1.1.2.2.13
log
@1.1b9_25
@
text
@d3 1
a3 1
#			$Date: 1998/06/05 09:54:27 $
a28 3
    if val =~ /^rb_out (c\d+)/
      return Tk_CMDTBL[$1]
    end
d37 2
a136 1
    id
a239 4
  def grid(*args)
    TkGrid.configure *args
  end

a788 64
module TkGrid
  include Tk
  extend Tk

  def bbox(*args)
    list(tk_call('grid', 'bbox', *args))
  end

  def configure(widget, *args)
    if args[-1].kind_of?(Hash)
      keys = args.pop
    end
    wins = [widget.path]
    for i in args
      wins.push i.epath
    end
    tk_call "grid", 'configure', *(wins+hash_kv(keys))
  end

  def columnconfigure(master, index, *args)
    tk_call "grid", 'columnconfigure', master, index, *hash_kv(keys)
  end

  def rowconfigure(master, index, *args)
    tk_call "grid", 'rowconfigure', master, index, *hash_kv(keys)
  end

  def add(widget, *args)
    configure(widget, *args)
  end

  def forget(*args)
    tk_call 'grid', 'forget', *args
  end

  def info(slave)
    list(tk_call('grid', 'info', slave))
  end

  def location(master, x, y)
    list(tk_call('grid', 'location', master, x, y))
  end

  def propagate(master, bool=None)
    bool(tk_call('grid', 'propagate', master.epath, bool))
  end

  def remove(*args)
    tk_call 'grid', 'remove', *args
  end

  def size(master)
    tk_call 'grid', 'size', master
  end

  def slaves(*args)
    list(tk_call('grid', 'slaves', *hash_kv(args)))
  end

  module_function :bbox, :forget, :propagate, :info
  module_function :remove, :size, :slaves, :location
  module_function :configure, :columnconfigure, :rowconfigure
end

a835 4
  def [](id)
    cget id
  end

a839 4
  def cget(slot)
    tk_tcl2ruby tk_call path, 'cget', "-#{slot}"
  end

a893 10
  def grid(keys = nil)
    tk_call 'grid', epath, *hash_kv(keys)
    self
  end

  def ungrid(keys = nil)
    tk_call 'grid', 'forget', epath
    self
  end

a1133 4
  def create_self
    raise TypeError, "TkTextWin is abstract class"
  end

@


1.1.1.2.2.14
log
@baseline
@
text
@d3 1
a3 1
#			$Date: 1998/06/11 10:03:20 $
d815 1
a815 1
    tk_call "grid", 'columnconfigure', master, index, *hash_kv(args)
d819 1
a819 1
    tk_call "grid", 'rowconfigure', master, index, *hash_kv(args)
d1304 2
a1305 2
  def invoke(index)
    tk_send 'invoke', index
d1307 1
a1307 1
  def insert(index, type, keys=nil)
@


1.1.1.2.2.15
log
@1.1b9_26
@
text
@d3 1
a3 1
#			$Date: 1998/06/16 04:24:38 $
a56 1
    list = [] if list == ""
d81 1
a88 14
  def array2tk_list(ary)
    ary.collect{|e|
      if e.kind_of? Array
	"{#{array2tk_list(e)}}"
      elsif e.kind_of? Hash
	"{#{e.to_a.collect{|ee| array2tk_list(ee)}.join(' ')}}"
      else
	s = _get_eval_string(e)
	(s.index(/\s/))? "{#{s}}": s
      end
    }.join(" ")
  end
  private :array2tk_list

a223 5
    context = context.join("><") if context.kind_of? Array
    if /,/ =~ context
      context = context.split(/\s*,\s*/).join("><")
    end
    id = install_bind(cmd, args)
d225 1
d274 1
a274 1
    _get_eval_string(TkUtil.eval_cmd(Tk_CMDTBL[arg.shift], *arg))
a284 4
    elsif str.kind_of?(Array)
      str = array2tk_list(str)
    elsif str.kind_of?(Proc)
      str = install_cmd(v)
a327 3
  TCL_VERSION = INTERP._invoke("info", "tclversion")
  TK_VERSION  = INTERP._invoke("set", "tk_version")

d451 2
a452 14
    if val == []
      INTERP._eval(format('global %s; set %s(0) 0; unset %s(0)', 
			  @@id, @@id, @@id))
    elsif val.kind_of?(Array)
	s = '"' + array2tk_list(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
	INTERP._eval(format('global %s; array set %s %s', @@id, @@id, s))
    elsif  val.kind_of?(Hash)
      s = '"' + val.to_a.collect{|e| array2tk_list(e)}.join(" ")\
                   ..gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; array set %s %s', @@id, @@id, s))
    else
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
    end
d460 1
a460 9
    begin
      INTERP._eval(format('global %s; set %s', @@id, @@id))
    rescue
      if INTERP._eval(format('global %s; array exists %s', @@id, @@id)) != "1"
	raise
      else
	INTERP._eval(format('global %s; array get %s', @@id, @@id))
      end
    end
d464 1
a464 32
    begin
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, _get_eval_string(val)))
    rescue
      if INTERP._eval(format('global %s; array exists %s', @@id, @@id)) != "1"
	raise
      else
	INTERP._eval(format('global %s; unset %s'), @@id, @@id)
	if val == []
	  INTERP._eval(format('global %s; set %s(0) 0; unset %s(0)', 
			      @@id, @@id, @@id))
	elsif val.kind_of?(Array)
	  s = '"' + array2tk_list(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
	  INTERP._eval(format('global %s; array set %s %s', @@id, @@id, s))
	elsif  val.kind_of?(Hash)
	  s = '"' + val.to_a.collect{|e| array2tk_list(e)}.join(" ")\
	                        .gsub(/[][$"]/, '\\\\\&') + '"' #'
	  INTERP._eval(format('global %s; array set %s %s', @@id, @@id, s))
	else
	  raise
	end
      end
    end
  end

  def [](index)
    INTERP._eval(format('global %s; set %s(%s)', 
			@@id, @@id, _get_eval_string(index)))
  end

  def []=(index,val)
    INTERP._eval(format('global %s; set %s(%s) %s', @@id, @@id, 
			_get_eval_string(index), _get_eval_string(val)))
a508 10
class TkVarAccess<TkVariable
  def initialize(varname, val=nil)
    @@id = varname
    if val
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
    end
  end
end

d580 1
a580 1
  def winfo_depth
d586 1
a586 1
  def winfo_exist?
d592 1
a592 1
  def winfo_fpixels(number)
d598 1
a598 1
  def winfo_geometry
d604 1
a604 1
  def winfo_height
d610 1
a610 1
  def winfo_id
d616 1
a616 1
  def winfo_mapped?
d622 1
a622 1
  def winfo_parent
d634 1
a634 1
  def winfo_pixels(number)
d640 1
a640 1
  def winfo_reqheight
d646 1
a646 1
  def winfo_reqwidth
d652 1
a652 1
  def winfo_rgb(color)
d658 1
a658 1
  def winfo_rootx
d664 1
a664 1
  def winfo_rooty
d670 1
a670 1
  def winfo_screen
d676 1
a676 1
  def winfo_screencells
d682 1
a682 1
  def winfo_screendepth
d688 1
a688 1
  def winfo_screenheight
d694 1
a694 1
  def winfo_screenmmheight
d700 1
a700 1
  def winfo_screenmmwidth
d706 1
a706 1
  def winfo_screenvisual
d712 1
a712 1
  def winfo_screenwidth
d718 1
a718 1
  def winfo_toplevel
d724 1
a724 1
  def winfo_visual
d730 1
a730 1
  def winfo_vrootheight
d736 1
a736 1
  def winfo_vrootwidth
d742 1
a742 1
  def winfo_vrootx
d748 1
a748 1
  def winfo_vrooty
d754 1
a754 1
  def winfo_width
d760 1
a760 1
  def winfo_x
d766 1
a766 1
  def winfo_y
d807 1
a807 1
    wins = [widget.epath]
a928 13
  end

  def configinfo(slot = nil)
    if slot
      conf = tk_split_list(tk_send('configure', "-#{slot}") )
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_send('configure') ).collect{|conf|
        conf[0] = conf[0][1..-1]
        conf
      }
    end
@


1.1.1.2.2.16
log
@1.1b9_27
@
text
@d3 1
a3 1
#			$Date: 1998/06/18 07:47:07 $
a144 23
  def _get_eval_string(str)
    return nil if str == None
    if str.kind_of?(Hash)
      str = hash_kv(str).join(" ")
    elsif str.kind_of?(Array)
      str = array2tk_list(str)
    elsif str.kind_of?(Proc)
      str = install_cmd(str)
    elsif str == nil
      str = ""
    elsif str == false
      str = "0"
    elsif str == true
      str = "1"
    elsif (str.respond_to?(:to_eval))
      str = str.to_eval()
    else
      str = str.to_s()
    end
    return str
  end
  private :_get_eval_string

d265 6
a270 20
      myid = _curr_cmd_id
      INTERP._eval('after '+ms+' '+_get_eval_string(install_cmd(proc{
		      TkUtil.eval_cmd cmd
		      uninstall_cmd myid
		    })))
    return
    if false #defined? Thread
      Thread.start do
	ms = Float(ms)/1000
	ms = 10 if ms == 0
	sleep ms/1000
	cmd.call
      end
    else
      myid = _curr_cmd_id
      INTERP._eval('after '+ms+' '+_get_eval_string(install_cmd(proc{
		      TkUtil.eval_cmd cmd
		      uninstall_cmd myid
		    })))
    end
d299 22
d984 2
a985 6
    name = id.id2name
    case args.length
    when 1
      configure name, args[0]
    when 0
      fail NameError, "undefined local variable or method `#{name}' for #{self.to_s}", error_at
d987 2
a988 1
      fail NameError, "undefined method `#{name}' for #{self.to_s}", error_at
@


1.1.1.2.2.17
log
@980626
@
text
@d3 1
a3 1
#			$Date: 1998/06/19 09:32:12 $
d168 1
a168 1
  Tk_IDs = [0, 0]		# [0]-cmdid, [1]-winid
d191 2
a192 2
    id = format("w%.4d", Tk_IDs[1])
    Tk_IDs[1] += 1
d416 1
a416 1
      tk_call 'wm', 'group', path, *args
d419 1
a419 1
      tk_call 'wm', 'iconbitmap', path, *args
a506 4
  def wait
    INTERP._eval("tkwait variable #{@@id}")
  end

a869 6
  def TkWinfo.viewable(window)
    bool(tk_call 'winfo', 'viewable', window.path)
  end
  def winfo_viewable
    TkWinfo.viewable self
  end
d915 1
a915 1
  def columnconfigure(master, index, args)
d919 1
a919 1
  def rowconfigure(master, index, args)
d951 1
a951 1
  def slaves(args)
a1192 9

  def wait_visibility
    tk_call 'tkwait', 'visibility', path
  end
  alias wait wait_visibility

  def wait_destroy
    tk_call 'tkwait', 'window', path
  end
a1444 3
  def entryconfigure(index, keys=nil)
    tk_send 'entryconfigure', index, *hash_kv(keys)
  end
a1495 25
end

module TkClipboard
  include Tk
  extend Tk

  def clear
    tk_call 'clipboard', 'clear'
  end
  def get
    begin
      tk_call 'selection', 'get', '-selection', 'CLIPBOARD'
    rescue
      ''
    end
  end
  def set(data)
    clear
    append(data)
  end
  def append(data)
    tk_call 'clipboard', 'append', data
  end

  module_function :clear, :set, :get, :append
@


1.1.1.2.2.18
log
@1.1b9_29
@
text
@d3 1
a3 1
#			$Date: 1998/06/26 09:45:00 $
d287 23
a326 18
  def after(ms, cmd=Proc.new)
    myid = _curr_cmd_id
    cmdid = install_cmd(cmd)
    tk_call("after",ms,cmdid)
    return
    if false #defined? Thread
      Thread.start do
	ms = Float(ms)/1000
	ms = 10 if ms == 0
	sleep ms/1000
	cmd.call
      end
    else
      cmdid = install_cmd(cmd)
      tk_call("after",ms,cmdid)
    end
  end

d1032 7
a1038 6
 def configure(slot, value=None)
   if slot.kind_of? Hash
     tk_call path, 'configure', *hash_kv(slot)
   else
     tk_call path, 'configure', "-#{slot}", value
   end
d1503 8
a1510 12
  def configure(slot, value=None)
    if slot.kind_of? Hash
      slot.each{|slot,value| configure slot, value}
    else
      if @@delegates and @@delegates[slot]
	for i in @@delegates[slot]
	  if not i
	    i = @@delegates['DEFALUT']
	    redo
	  else
	    last = i.configure(slot, value)
	  end
a1511 3
	last
      else
	super
d1513 3
a1552 2
autoload :TkAfter, 'tkafter'
autoload :TkPalette, 'tkpalette'
@


1.1.1.2.2.19
log
@1.1b9_30
@
text
@d3 1
a3 1
#			$Date: 1998/07/03 07:06:43 $
d260 1
a260 1
  def tk_event_sequence(context)
a263 2
    else
      context
a264 3
  end

  def _bind_core(mode, path, context, cmd, args=nil)
d267 1
a267 1
      tk_call 'bind', path, "<#{tk_event_sequence(context)}>", mode + id
d273 1
a273 9

  def _bind(path, context, cmd, args=nil)
    _bind_core('', path, context, cmd, args=nil)
  end

  def _bind_append(path, context, cmd, args=nil)
    _bind_core('+', path, context, cmd, args=nil)
  end
  private :install_bind, :tk_event_sequence, :_bind_core, :_bind, :_bind_append
a278 29
  def bind_append_all(context, cmd=Proc.new, args=nil)
    _bind_append 'all', context, cmd, args
  end

  def bind(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind tagOrClass, context, cmd, args
  end

  def bind_append(tagOrClass, context, cmd=Proc.new, args=nil)
    _bind_append tagOrClass, context, cmd, args
  end

  def bindinfo(tagOrClass, context=nil)
    if context
      (tk_call('bind', tagOrClass, 
	       "<#{tk_event_sequence(context)}>")).collect{|cmdline|
	if cmdline =~ /^rb_out (c\d+)\s+(.*)$/
	  [Tk_CMDTBL[$1], $2]
	else
	  cmdline
	end
      }
    else
      tk_split_list(tk_call 'bind', tagOrClass).collect{|seq|
	seq[1..-2].gsub(/></,',')
      }
    end
  end

d302 1
a302 10

  INTERP._invoke("proc", "rb_out", "args", "if {[set st [catch {ruby [format \"TkCore.callback %%Q!%s!\" $args]} ret]] != 0} {return -code $st $ret} {return $ret}")

  def callback_break
    raise TkCallbackBreak, "Tk callback returns 'break' status"
  end

  def callback_continue
    raise TkCallbackContinue, "Tk callback returns 'continue' status"
  end
a326 33
  def appname(name=None)
    tk_call('tk', 'appname', name)
  end

  def appsend(interp, async, *args)
    if async
      tk_call('send', '-async', '--', interp, *args)
    else
      tk_call('send', '--', interp, *args)
    end
  end

  def rb_appsend(interp, async, *args)
    args.unshift('ruby {')
    args.push('}')
    appsend(interp, async, *args)
  end

  def appsend_displayof(interp, win, async, *args)
    win = '.' if win == nil
    if async
      tk_call('send', '-async', '-displayof', win, '--', interp, *args)
    else
      tk_call('send', '-displayor', win, '--', interp, *args)
    end
  end

  def rb_appsend_displayof(interp, win, async, *args)
    args.unshift('ruby {')
    args.push('}')
    appsend_displayof(interp, win, async, *args)
  end

a480 1
  extend TkCore
a481 1
  TkVar_CB_TBL = {}
a482 12

  INTERP._invoke("proc", "rb_var", "args", "ruby [format \"TkVariable.callback %%Q!%s!\" $args]")

  def TkVariable.callback(args)
    name1,name2,op = tk_split_list(args)
    if TkVar_CB_TBL[name1]
      _get_eval_string(TkVar_CB_TBL[name1].trace_callback(name2,op))
    else
      ''
    end
  end

d490 2
a491 4
      a = []
      val.each_with_index{|e,i| a.push(i); a.push(array2tk_list(e))}
      s = '"' + a.join(" ").gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; array set %s %s', @@id, @@id, s))
d494 1
a494 1
                   .gsub(/[][$"]/, '\\\\\&') + '"' #'
d517 1
a517 2
	Hash(*tk_tcl2ruby(INTERP._eval(format('global %s; array get %s', 
					      @@id, @@id))))
d524 1
a524 2
      s = '"' + _get_eval_string(val).gsub(/[][$"]/, '\\\\\&') + '"' #'
      INTERP._eval(format('global %s; set %s %s', @@id, @@id, s))
d534 2
a535 5
	  a = []
	  val.each_with_index{|e,i| a.push(i); a.push(array2tk_list(e))}
	  s = '"' + a.join(" ").gsub(/[][$"]/, '\\\\\&') + '"' #'
	  INTERP._eval(format('global %s; unset %s; array set %s %s', 
			      @@id, @@id, @@id, s))
d539 1
a539 2
	  INTERP._eval(format('global %s; unset %s; array set %s %s', 
			      @@id, @@id, @@id, s))
a596 141

  def unset(elem=nil)
    if elem
      INTERP._eval(format('global %s; unset %s(%s)', 
			  @@id, @@id, tk_tcl2ruby(elem)))
    else
      INTERP._eval(format('global %s; unset %s', @@id, @@id))
    end
  end
  alias remove unset

  def trace_callback(elem, op)
    if @@trace_var.kind_of? Array
      @@trace_var.each{|m,e| e.call(self,elem,op) if m.index(op)}
    end
    if elem.kind_of? String
      if @@trace_elem[elem].kind_of? Array
	@@trace_elem[elem].each{|m,e| e.call(self,elem,op) if m.index(op)}
      end
    end
  end

  def trace(opts, cmd)
    @@trace_var = [] if @@trace_var == nil
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    @@trace_var.unshift([opts,cmd])
    if @@trace_opts == nil
      TkVar_CB_TBL[@@id] = self
      @@trace_opts = opts
      Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
    else
      newopts = @@trace_opts.dup
      opts.each_byte{|c| newopts += c.chr unless @@newopts.index(c)}
      if newopts != @@trace_opts
	Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
	@@trace_opts.replace(newopts)
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_element(elem, opts, cmd)
    @@trace_elem = {} if @@trace_elem == nil
    @@trace_elem[elem] = [] if @@trace_elem[elem] == nil
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    @@trace_elem[elem].unshift([opts,cmd])
    if @@trace_opts == nil
      TkVar_CB_TBL[@@id] = self
      @@trace_opts = opts
      Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
    else
      newopts = @@trace_opts.dup
      opts.each_byte{|c| newopts += c.chr unless @@newopts.index(c)}
      if newopts != @@trace_opts
	Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
	@@trace_opts.replace(newopts)
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_vinfo
    return [] unless @@trace_var
    @@trace_var.dup
  end
  def trace_vinfo_for_element(elem)
    return [] unless @@trace_elem
    return [] unless @@trace_elem[elem]
    @@trace_elem[elem].dup
  end

  def trace_vdelete(opts,cmd)
    return unless @@trace_var.kind_of? Array
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    idx = -1
    newopts = ''
    @@trace_var.each_with_index{|i,e| 
      if idx < 0 && e[0] == opts && e[1] == cmd
	idx = i
	continue
      end
      e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
    }
    if idx >= 0
      @@trace_var.delete_at(idx) 
    else
      return
    end

    @@trace_elem.each{|elem|
      @@trace_elem[elem].each{|e|
	e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
      }
    }

    newopts = ['r','w','u'].find_all{|c| newopts.index(c)}.join('')
    if newopts != @@trace_opts
      Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
      @@trace_opts.replace(newopts)
      if @@trace_opts != ''
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end

  def trace_vdelete_for_element(elem,opts,cmd)
    return unless @@trace_elem.kind_of? Hash
    return unless @@trace_elem[elem].kind_of? Array
    opts = ['r','w','u'].find_all{|c| opts.index(c)}.join('')
    idx = -1
    @@trace_elem[elem].each_with_index{|i,e| 
      if idx < 0 && e[0] == opts && e[1] == cmd
	idx = i
	continue
      end
    }
    if idx >= 0
      @@trace_elem[elem].delete_at(idx)
    else
      return
    end

    newopts = ''
    @@trace_var.each{|e| 
      e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
    }
    @@trace_elem.each{|elem|
      @@trace_elem[elem].each{|e|
	e[0].each_byte{|c| newopts += c.chr unless newopts.index(c)}
      }
    }

    newopts = ['r','w','u'].find_all{|c| newopts.index(c)}.join('')
    if newopts != @@trace_opts
      Tk.tk_call('trace', 'vdelete', @@id, @@trace_opts, 'rb_var')
      @@trace_opts.replace(newopts)
      if @@trace_opts != ''
	Tk.tk_call('trace', 'variable', @@id, @@trace_opts, 'rb_var')
      end
    end
  end
a635 62
module TkKinput
  include Tk
  extend Tk

  def TkKinput.start(window, style=None)
    tk_call 'kinput_start', window.path, style
  end
  def kinput_start(style=None)
    TkKinput.start(self, style)
  end

  def TkKinput.send_spot(window)
    tk_call 'kinput_send_spot', window.path
  end
  def kinput_send_spot
    TkKinput.send_spot(self)
  end

  def TkKinput.input_start(window, keys=nil)
    tk_call 'kanjiInput', 'start', window.path, *hash_kv(keys)
  end
  def kanji_input_start(keys=nil)
    TkKinput.input_start(self, keys)
  end

  def TkKinput.attribute_config(window, slot, value=None)
    if slot.kind_of? Hash
      tk_call 'kanjiInput', 'attribute', window.path, *hash_kv(slot)
    else
      tk_call 'kanjiInput', 'attribute', window.path, "-#{slot}", value
    end
  end
  def kinput_attribute_config(slot, value=None)
    TkKinput.attribute_config(self, slot, value)
  end

  def TkKinput.attribute_info(window, slot=nil)
    if slot
      conf = tk_split_list(tk_call('kanjiInput', 'attribute', 
				   window.path, "-#{slot}"))
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_call('kanjiInput', 'attribute', 
			    window.path)).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
  end
  def kinput_attribute_info(slot=nil)
    TkKinput.attribute_info(self, slot)
  end

  def TkKinput.input_end(window)
    tk_call 'kanjiInput', 'end', window.path
  end
  def kanji_input_end
    TkKinput.input_end(self)
  end
end

d693 1
a693 1
    TkWinfo.fpixels self, number
a712 23
  def TkWinfo.interps(window=nil)
    if window
      tk_split_list(tk_call('winfo', '-displayof', window.path, 
			    'interps')).collect{|ip|
	if ip.kind_of? Array
	  ip.flatten.join(' ')
	else
	  ip
	end
      }
    else
      tk_split_list(tk_call('winfo', 'interps')).collect{|ip|
	if ip.kind_of? Array
	  ip.flatten.join(' ')
	else
	  ip
	end
      }
    end
  end
  def winfo_interps
    TkWinfo.interps self
  end
a1055 4
  def bind_append(context, cmd=Proc.new, args=nil)
    _bind_append path, context, cmd, args
  end

a1068 20
module TkClassBind
  WidgetClassNameTBL = {}

  def TkClassBind.name2class(name)
    WidgetClassNameTBL[name]
  end

  def bind(context, cmd=Proc.new, args=nil)
    Tk.bind to_eval, context, cmd, args
  end

  def bind_append(context, cmd=Proc.new, args=nil)
    Tk.bind_append to_eval, context, cmd, args
  end

  def bindinfo(context=nil)
    Tk.bind to_eval, context
  end
end

a1069 1
  extend TkClassBind
a1205 17

  def bindtags(taglist=nil)
    if taglist
      fail unless taglist.kind_of? Array
      tk_call('bindtags', path, taglist)
    else
      tk_split_list(tk_call('bindtags', path)).collect{|tag|
	if tag == nil
	  '.'
	elsif tag.kind_of?(String) && (cls = TkClassBind.name2class(tag))
	  cls
	else
	  tag
	end
      }
    end
  end
a1216 7

  WidgetClassName = 'Tk'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

a1226 7

  WidgetClassName = 'Toplevel'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

a1238 4

  def specific_class
    @@classname
  end
a1241 5
  WidgetClassName = 'Frame'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end
a1247 5
  WidgetClassName = 'Label'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end
a1256 6
  WidgetClassName = 'Button'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
#  def TkButton.to_eval
  def self.to_eval
    WidgetClassName
  end
a1268 5
  WidgetClassName = 'Radiobutton'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def TkRadioButton.to_eval
    WidgetClassName
  end
a1283 4
  TkClassBind::WidgetClassNameTBL['Checkbutton'] = self
  def TkCheckButton.to_eval
    'Checkbutton'
  end
a1292 4
  TkClassBind::WidgetClassNameTBL['Message'] = self
  def TkMessage.to_eval
    'Message'
  end
a1298 6
  WidgetClassName = 'Scale'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

a1320 6
  WidgetClassName = 'Scrollbar'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end

a1382 4
  TkClassBind::WidgetClassNameTBL['Listbox'] = self
  def TkListbox.to_eval
    'Listbox'
  end
a1421 5
  WidgetClassName = 'Menu'.freeze
  TkClassBind::WidgetClassNameTBL[WidgetClassName] = self
  def self.to_eval
    WidgetClassName
  end
a1463 4
  TkClassBind::WidgetClassNameTBL['Menubutton'] = self
  def TkMenubutton.to_eval
    'Menubutton'
  end
@


1.1.1.2.2.20
log
@1.1b9_31
@
text
@d3 1
a3 1
#			$Date: 1998/07/09 08:40:39 $
a35 2
    when /^@@font/
      TkFont.get_obj(val)
d280 1
a280 1
    _bind_core('', path, context, cmd, args)
d284 1
a284 1
    _bind_core('+', path, context, cmd, args)
a414 4
  def messageBox(keys)
    tk_call 'tk_messageBox', *hash_kv(keys)
  end

a445 1
  JAPANIZED_TK = (INTERP._invoke("info", "commands", "kanji") != "")
a454 8
  def toUTF8(str,encoding)
    INTERP._toUTF8(str,encoding)
  end
  
  def fromUTF8(str,encoding)
    INTERP._fromUTF8(str,encoding)
  end

a1314 100
module TkTreatFont
  def font_configinfo
    ret = TkFont.used_on(self.path)
    if ret == nil
      ret = TkFont.init_widget_font(self.path, self.path, 'configure')
    end
    ret
  end
  alias fontobj font_configinfo

  def font_configure(slot)
    if (fnt = slot['font'])
      slot['font'] = nil
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(self.path, self.path,'configure',slot)
      else
	latinfont_configure(fnt) if fnt
      end
    end
    if (ltn = slot['latinfont'])
      slot['latinfont'] = nil
      latinfont_configure(ltn) if ltn
    end
    if (ltn = slot['asciifont'])
      slot['asciifont'] = nil
      latinfont_configure(ltn) if ltn
    end
    if (knj = slot['kanjifont'])
      slot['kanjifont'] = nil
      kanjifont_configure(knj) if knj
    end

    tk_call(self.path, 'configure', *hash_kv(slot)) if slot != {}
    self
  end

  def latinfont_configure(ltn, keys=nil)
    fobj = fontobj
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val}
      if keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciifont_configure latinfont_configure

  def kanjifont_configure(knj, keys=nil)
    fobj = fontobj
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val}
      if keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(cond)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def font_copy(window, tag=nil)
    if tag
      window.tagfontobj(tag).configinfo.each{|key,value|
	fontobj.configure(key,value)
      }
      fontobj.replace(window.tagfontobj(tag).latin_font, 
		      window.tagfontobj(tag).kanji_font)
    else
      window.fontobj.configinfo.each{|key,value|
	fontobj.configure(key,value)
      }
      fontobj.replace(window.fontobj.latin_font, window.fontobj.kanji_font)
    end
  end

  def latinfont_copy(window, tag=nil)
    if tag
      fontobj.latin_replace(window.tagfontobj(tag).latin_font)
    else
      fontobj.latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciifont_copy latinfont_copy

  def kanjifont_copy(window, tag=nil)
    if tag
      fontobj.kanji_replace(window.tagfontobj(tag).kanji_font)
    else
      fontobj.kanji_replace(window.fontobj.kanji_font)
    end
  end
end

a1316 1
  include TkTreatFont
d1359 6
a1364 17
  def configure(slot, value=None)
    if slot.kind_of? Hash
      if ( slot['font'] || slot['kanjifont'] \
	  || slot['latinfont'] || slot['asciifont'] )
	font_configure(slot.dup)
      else
	tk_call path, 'configure', *hash_kv(slot)
      end

    else
      if ( slot == 'font' || slot == 'kanjifont' \
	  || slot == 'latinfont' || slot == 'asciifont' )
	font_configure({slot=>value})
      else
	tk_call path, 'configure', "-#{slot}", value
      end
    end
d1372 4
a1375 3
    if slot == 'font' || slot == 'kanjifont'
      fontobj

d1377 4
a1380 17
      if slot
	conf = tk_split_list(tk_send('configure', "-#{slot}") )
	conf[0] = conf[0][1..-1]
	conf

      else
	ret = tk_split_list(tk_send('configure') ).collect{|conf|
	  conf[0] = conf[0][1..-1]
	  conf
	}
	if ret.assoc('font')
	  ret.delete_if{|item| item[0] == 'font' || item[0] == 'kanjifont'}
	  ret.push(['font', fontobj])
	else
	  ret
	end
      end
d1432 1
a1432 2
      # tk_call @@path, 'configure', *hash_kv(keys)
      configure(keys)
a1998 1
autoload :TkFont, 'tkfont'
@


1.1.1.2.2.21
log
@1.1c0
@
text
@d3 1
a3 1
#			$Date: 1998/07/15 06:13:02 $
d263 1
a263 12
    if context.kind_of? TkVirtualEvent
      context = context.path
    end
    if context.kind_of? Array
      context = context.collect{|ev|
	if context.kind_of? TkVirtualEvent
	  ev.path
	else
	  ev
	end
      }.join("><")
    end
d306 1
a306 1
  def _bindinfo(tagOrClass, context=nil)
a322 4
  def bindinfo(tagOrClass, context=nil)
    _bindinfo tagOrClass, context
  end

a416 10
  def event_generate(window, context, keys=nil)
    window = window.path if window.kind_of? TkObject
    if keys
      tk_call('event', 'generate', window, 
	      "<#{tk_event_sequence(context)}>", *hash_kv(keys))
    else
      tk_call('event', 'generate', window, "<#{tk_event_sequence(context)}>")
    end
  end

a420 12
  def getOpenFile(keys)
    tk_call 'tk_getOpenFile', *hash_kv(keys)
  end

  def getSaveFile(keys)
    tk_call 'tk_getSaveFile', *hash_kv(keys)
  end

  def chooseColor(keys)
    tk_call 'tk_chooseColor', *hash_kv(keys)
  end

d632 2
a633 2
	Hash[*tk_tcl2ruby(INTERP._eval(format('global %s; array get %s', 
					      @@id, @@id)))]
a1530 13
  def bindinfo(context=nil)
    _bindinfo path, context
  end

  def event_generate(context, keys=nil)
    if keys
      tk_call('event', 'generate', path, 
	      "<#{tk_event_sequence(context)}>", *hash_kv(keys))
    else
      tk_call('event', 'generate', path, "<#{tk_event_sequence(context)}>")
    end
  end

d1560 1
a1560 1
    Tk.bindinfo to_eval, context
d1654 1
a1654 1
	val = tk_call('grab', args[0], path)
a2139 1
autoload :TkVirtualEvent, 'tkvirtevent'
@


1.1.1.2.2.22
log
@st.c(rehash)
@
text
@d3 1
a3 1
#			$Date: 1998/07/17 05:12:44 $
a27 22
  def _genobj_for_tkwidget(path)
    return TkRoot.new if path == '.'

    begin
      tk_class = TkCore::INTERP._invoke('winfo', 'class', path)
    rescue
      return path
    end

    ruby_class = TkClassBind::WidgetClassNameTBL[tk_class]
    gen_class_name = ruby_class.name + 'GeneratedOnTk'
    unless Object.const_defined? gen_class_name
      eval "class #{gen_class_name}<#{ruby_class.name}
              def initialize(path)
                @@path=path
                Tk_WINDOWS[@@path] = self
              end
            end"
    end
    eval "#{gen_class_name}.new('#{path}')"
  end

d41 1
a41 1
      Tk_WINDOWS[val] ? Tk_WINDOWS[val] : _genobj_for_tkwidget(val)
d77 1
a77 27

  def tk_split_simplelist(str)
    return [] if str == ""
    idx = str.index('{')
    return str.split unless idx

    list = str[0,idx].split
    str = str[idx+1..-1]
    i = -1
    brace = 1
    str.each_byte {|c|
      i += 1
      brace += 1 if c == ?{
      brace -= 1 if c == ?}
      break if brace == 0
    }
    if i == 0
      list.push ''
    elsif str[0, i] == ' '
      list.push ' '
    else
      list.push str[0..i-1]
    end
    list += tk_split_simplelist(str[i+1..-1])
    list
  end
  private :tk_tcl2ruby, :tk_split_list, :tk_split_simplelist
a427 4
  def info(*args)
    tk_call('info', *args)
  end

d664 1
a664 1
      tk_tcl2ruby(INTERP._eval(format('global %s; set %s', @@id, @@id)))
d1032 1
a1032 1
    path = tk_call('winfo', 'containing', rootX, rootY)
d1076 8
a1083 2
      tk_split_simplelist(tk_call('winfo', '-displayof', window.path, 
				  'interps'))
d1085 7
a1091 1
      tk_split_simplelist(tk_call('winfo', 'interps'))
a1102 6
  def TkWinfo.appname(window)
    bool(tk_call('winfo', 'name', window.path))
  end
  def winfo_appname
    TkWinfo.appname self
  end
d1806 2
a1807 33
    if screen.kind_of? Hash
      keys = screen.dup
    else
      @@screen = screen
    end
    @@classname = classname
    if keys.kind_of? Hash
      keys = keys.dup
      if keys['classname']
	@@classname = keys['classname']
	keys['classname'] = nil
      end
      if keys['colormap']
	@@colormap = keys['colormap']
	keys['colormap'] = nil
      end
      if keys['container']
	@@classname = keys['container']
	keys['classname'] = nil
      end
      if keys['screen']
	@@screen = keys['screen']
	keys['screen'] = nil
      end
      if keys['use']
	@@use = keys['use']
	keys['use'] = nil
      end
      if keys['visual']
	@@screen = keys['visual']
	keys['visual'] = nil
      end
    end
d1813 3
a1815 7
    s.push << "-class"     << @@classname if @@classname
    s.push << "-colormap"  << @@colormap  if @@colormap
    s.push << "-container" << @@container if @@container
    s.push << "-screen"    << @@screen    if @@screen 
    s.push << "-use"       << @@use       if @@use
    s.push << "-visual"    << @@visual    if @@visual
    tk_call 'toplevel', @@path, *s
a1828 24

  def initialize(parent=nil, keys=nil)
    if keys.kind_of? Hash
      keys = keys.dup
      if keys['classname']
	@@classname = keys['classname']
	keys['classname'] = nil
      end
      if keys['colormap']
	@@colormap = keys['colormap']
	keys['colormap'] = nil
      end
      if keys['container']
      @@classname = keys['container']
	keys['classname'] = nil
      end
      if keys['visual']
	@@screen = keys['visual']
	keys['visual'] = nil
      end
    end
    super(parent, keys)
  end

d1830 1
a1830 6
    s = []
    s.push << "-class"     << @@classname if @@classname
    s.push << "-colormap"  << @@colormap  if @@colormap
    s.push << "-container" << @@container if @@container
    s.push << "-visual"    << @@visual    if @@visual
    tk_call 'frame', @@path, *s
a2047 111
module TkTreatMenuEntryFont
  def tagfont_configinfo(index)
    pathname = self.path + ';' + index
    ret = TkFont.used_on(pathname)
    if ret == nil
      ret = TkFont.init_widget_font(pathname, 
				    self.path, 'entryconfigure', index)
    end
    ret
  end
  alias tagfontobj tagfont_configinfo

  def tagfont_configure(index, slot)
    pathname = self.path + ';' + index
    if (fnt = slot['font'])
      slot['font'] = nil
      if fnt.kind_of? TkFont
	return fnt.call_font_configure(pathname, 
				       self.path,'entryconfigure',index,slot)
      else
	latintagfont_configure(index, fnt) if fnt
      end
    end
    if (ltn = slot['latinfont'])
      slot['latinfont'] = nil
      latintagfont_configure(index, ltn) if ltn
    end
    if (ltn = slot['asciifont'])
      slot['asciifont'] = nil
      latintagfont_configure(index, ltn) if ltn
    end
    if (knj = slot['kanjifont'])
      slot['kanjifont'] = nil
      kanjitagfont_configure(index, knj) if knj
    end

    tk_call(self.path, 'entryconfigure', index, *hash_kv(slot)) if slot != {}
    self
  end

  def latintagfont_configure(index, ltn, keys=nil)
    fobj = tagfontobj(index)
    if ltn.kind_of? TkFont
      conf = {}
      ltn.latin_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.latin_replace(ltn)
	fobj.latin_configure(keys) if keys
      elsif keys
	fobj.latin_configure(conf.update(keys))
      else
	fobj.latin_configure(conf)
      end
    else
      fobj.latin_replace(ltn)
    end
  end
  alias asciitagfont_configure latintagfont_configure

  def kanjitagfont_configure(index, knj, keys=nil)
    fobj = tagfontobj(index)
    if knj.kind_of? TkFont
      conf = {}
      knj.kanji_configinfo.each{|key,val| conf[key] = val if val != []}
      if conf == {}
	fobj.kanji_replace(knj)
	fobj.kanji_configure(keys) if keys
      elsif keys
	fobj.kanji_configure(conf.update(keys))
      else
	fobj.kanji_configure(conf)
      end
    else
      fobj.kanji_replace(knj)
    end
  end

  def tagfont_copy(index, window, wintag=nil)
    if wintag
      window.tagfontobj(wintag).configinfo.each{|key,value|
	tagfontobj(index).configure(key,value)
      }
      tagfontobj(index).replace(window.tagfontobj(wintag).latin_font, 
			      window.tagfontobj(wintag).kanji_font)
    else
      window.tagfont(wintag).configinfo.each{|key,value|
	tagfontobj(index).configure(key,value)
      }
      tagfontobj(index).replace(window.fontobj.latin_font, 
			      window.fontobj.kanji_font)
    end
  end

  def latintagfont_copy(index, window, wintag=nil)
    if wintag
      tagfontobj(index).latin_replace(window.tagfontobj(wintag).latin_font)
    else
      tagfontobj(index).latin_replace(window.fontobj.latin_font)
    end
  end
  alias asciitagfont_copy latintagfont_copy

  def kanjitagfont_copy(index, window, wintag=nil)
    if wintag
      tagfontobj(index).kanji_replace(window.tagfontobj(wintag).kanji_font)
    else
      tagfontobj(index).kanji_replace(window.fontobj.kanji_font)
    end
  end
end

a2048 2
  include TkTreatMenuEntryFont

a2071 3
  def delete(index, last=None)
    tk_send 'delete', index, last
  end
a2091 37
  end
#  def entryconfigure(index, keys=nil)
#    tk_send 'entryconfigure', index, *hash_kv(keys)
#  end
  def entrycget(index, key)
    tk_tcl2ruby tk_send 'entrycget', index, "-#{key}"
  end
  def entryconfigure(index, key, val=None)
    if key.kind_of? Hash
      if ( key['font'] || key['kanjifont'] \
	  || key['latinfont'] || key['asciifont'] )
	tagfont_configure(index, key.dup)
      else
	tk_send 'entryconfigure', index, *hash_kv(key)
      end

    else
      if ( key == 'font' || key == 'kanjifont' \
	  || key == 'latinfont' || key == 'asciifont' )
	tagfont_configure({key=>val})
      else
	tk_call 'entryconfigure', index, "-#{key}", val
      end
    end
  end

  def entryconfiginfo(index, key=nil)
    if key
      conf = tk_split_list(tk_send('entryconfigure',index,"-#{key}"))
      conf[0] = conf[0][1..-1]
      conf
    else
      tk_split_list(tk_send('entryconfigure', index)).collect{|conf|
	conf[0] = conf[0][1..-1]
	conf
      }
    end
@


1.1.1.2.2.23
log
@1.1c1
@
text
@d3 1
a3 1
#			$Date: 1998/07/21 09:18:01 $
d456 3
a458 3
    args = args.filter{|c| _get_eval_string(c).gsub(/[][$"]/, '\\\\\&')}
    args.push(').to_s"')
    appsend(interp, async, 'ruby "(', *args)
d471 3
a473 3
    args = args.filter{|c| _get_eval_string(c).gsub(/[][$"]/, '\\\\\&')}
    args.push(').to_s"')
    appsend_displayof(interp, win, async, 'ruby "(', *args)
d716 1
a716 1
      INTERP._eval(format('global %s; set %s', @@id, @@id))
d721 2
a722 3
	Hash[*tk_split_simplelist(INTERP\
				  ._eval(format('global %s; array get %s', 
						@@id, @@id)))]
@


1.1.1.2.2.24
log
@sync ev
@
text
@d3 1
a3 1
#			$Date: 1998/07/24 04:42:06 $
a550 13
  def Tk.focus(display=nil)
    if display == nil
      r = tk_call('focus')
    else
      r = tk_call('focus', '-displayof', display)
    end
    tk_tcl2ruby(r)
  end

  def Tk.focus_lastfor(win)
    tk_tcl2ruby(tk_call('focus', '-lastfor', win))
  end

d639 3
a641 9
    def protocol(name=nil, cmd=nil)
      if cmd
	tk_call('wm', 'protocol', path, name, cmd)
      elsif name
	result = tk_call('wm', 'protocol', path, name)
	(result == "")? nil : tk_tcl2ruby(result)
      else
	tk_split_simplelist(tk_call('wm', 'protocol', path))
      end
d1405 2
a1406 2
  def get win, name, klass
    tk_call 'option', 'get', win ,name, klass
d1738 2
a1739 6
  def focus(force=false)
    if force
      tk_call 'focus', '-force', path
    else
      tk_call 'focus', path
    end
@


1.1.1.2.2.25
log
@1.1c2
@
text
@d3 1
a3 1
#			$Date: 1998/07/29 09:50:46 $
d906 1
a906 1
	next
d940 1
a940 1
	next
a1323 18
  end
  def TkWinfo.pointerx(window)
    number(tk_call('winfo', 'pointerx', window.path))
  end
  def winfo_pointerx
    TkWinfo.pointerx self
  end
  def TkWinfo.pointery(window)
    number(tk_call('winfo', 'pointery', window.path))
  end
  def winfo_pointery
    TkWinfo.pointery self
  end
  def TkWinfo.pointerxy(window)
    list(tk_call('winfo', 'pointerxy', window.path))
  end
  def winfo_pointerxy
    TkWinfo.pointerxy self
@


1.1.1.2.2.26
log
@1.1c6
@
text
@d3 1
a3 1
#			$Date: 1998/08/10 05:41:25 $
d20 1
a20 1
    frames = caller()
d1578 1
a1578 5
      begin
	cget name
      rescue
	fail NameError, "undefined local variable or method `#{name}' for #{self.to_s}", error_at
      end
@


1.1.1.2.2.27
log
@1.1c8
@
text
@d3 1
a3 1
#			$Date: 1998/10/06 02:45:14 $
@


1.1.1.2.2.25.2.1
log
@1.1d series
@
text
@d3 1
a3 1
#			$Date: 1998/08/10 05:41:25 $
d1551 1
a1551 1
class TkObject
a1553 6

  def TkObject.new(*args, &block)
    obj = super
    obj.instance_eval(&block) if block
    obj
  end
@


1.1.1.2.2.25.2.2
log
@join 1.1c6
@
text
@d3 1
a3 1
#			$Date: 1998/10/06 02:45:14 $
d20 1
a20 1
    frames = caller()
d1584 1
a1584 5
      begin
	cget name
      rescue
	fail NameError, "undefined local variable or method `#{name}' for #{self.to_s}", error_at
      end
@


1.1.1.2.2.25.2.3
log
@*** empty log message ***
@
text
@@


