head	1.10;
access;
symbols
	v1_6_7:1.10
	v1_6_6:1.10
	v1_6_5:1.10
	v1_6_4:1.10
	v1_7_1:1.10
	v1_6_4_preview4:1.10
	v1_6_4_preview3:1.10
	v1_6_4_preview2:1.10
	v1_6_4_preview1:1.10
	v1_6_3:1.10
	ruby_m17n:1.10.0.4
	ruby_1_6:1.10.0.2
	v1_6_2:1.10
	v1_6_1:1.10
	v1_6_0:1.10
	v1_4_6:1.4.2.1
	v1_4_5:1.4.2.1
	v1_4_4:1.4
	ruby_1_4_3:1.4
	ruby1_4_3:1.4
	v1_4_3:1.4
	v1_5_0:1.4
	ruby_1_4_3_pre1:1.4
	ruby_1_4:1.4.0.2
	v1_4_2:1.4
	v1_4_1:1.4
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.2
	v1_3_6_repack:1.1.1.1.2.2
	v1_3_6:1.1.1.1.2.2
	v1_3_5:1.1.1.1.2.2
	v1_2_6repack:1.1.2.4
	v1_3_4_990625:1.1.1.1.2.2
	v1_3_4_990624:1.1.1.1.2.2
	v1_2_6:1.1.2.4
	v1_3_4_990611:1.1.1.1.2.2
	v1_3_4_990531:1.1.1.1.2.2
	v1_3_3_990518:1.1.1.1.2.2
	v1_3_3_990513:1.1.1.1.2.2
	v1_3_3_990507:1.1.1.1.2.2
	v1_2_5:1.1.2.4
	v1_2_4:1.1.2.4
	v1_3_1_990225:1.1.1.1.2.1
	v1_3_1_990224:1.1.1.1.2.1
	v1_3_1_990215:1.1.1.1.2.1
	v1_3_1_990212:1.1.1.1.2.1
	v1_3_1_990210:1.1.1.1.2.1
	v1_3_1_:1.1.1.1.2.1
	v1_3_1_990209:1.1.1.1
	v1_3_1_990205:1.1.1.1
	v1_3_1_990203:1.1.1.1
	v1_3_1_990201:1.1.1.1
	v1_3_1"_990201:1.1.1.1
	v1_3_1_990128:1.1.1.1
	v1_3_1_990127:1.1.1.1
	v1_3_1_990126:1.1.1.1
	ruby_1_3:1.1.1.1.0.2
	v1_2_2:1.1.2.3
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_2_2_pr1:1.1.2.3
	v1_2_1repack:1.1.2.3
	v1_2_1:1.1.2.3
	v1_2_stable:1.1.2.3
	v1_1d1:1.1.2.3
	v1_1d0:1.1.2.3
	v1_1c9_1:1.1.2.3
	v1_1c9:1.1.2.3
	v1_1c8:1.1.2.3
	v1_1c7:1.1.2.3
	v1_1c6:1.1.2.3
	v1_1d-start:1.1.2.3
	v1_1c5:1.1.2.3
	v1_1dev:1.1.2.3.0.2
	v1_1c4:1.1.2.3
	v1_1c3:1.1.2.3
	v1_1c2:1.1.2.3
	v1_1c1:1.1.2.3
	v1_1c0:1.1.2.3
	v1_1b9_31:1.1.2.3
	v1_1b9_30:1.1.2.3
	v1_1b9_28:1.1.2.3
	v1_1b9_27:1.1.2.3
	v1_1b9_26:1.1.2.3
	r1_1b9_25:1.1.2.3
	r1_1b9_24:1.1.2.3
	v1_1b9_23:1.1.2.2
	v1_1b9_22:1.1.2.2
	v1_1b9_20:1.1.2.2
	v1_1b9_18:1.1.2.2
	v1_1b9_16:1.1.2.2
	v1_1b9_15:1.1.2.2
	v1_1b9_13:1.1.2.2
	v1_1b9_12:1.1.2.2
	v1_1b9_11:1.1.2.2
	v1_1b9_08:1.1.2.2
	v1_1b9_07:1.1.2.2
	v1_1r:1.1.0.2;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2000.07.18.07.37.02;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.10.04.49.21;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.24.04.34.24;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.21.07.52.05;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.23.08.37.33;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.13.07.18.44;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.09.16.09.40.33;	author matz;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.09.01.09.48.02;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.16;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.03.09.08.38.24;	author matz;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	99.01.20.04.59.35;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.02.10.08.44.28;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.03.24.08.52.35;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.08.11.07.24.10;	author matz;	state Exp;
branches;
next	;

1.1.2.1
date	98.03.09.08.38.24;	author matz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	98.03.11.07.33.06;	author matz;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	98.06.05.09.54.26;	author matz;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	99.02.16.03.42.20;	author matz;	state Exp;
branches;
next	;

1.4.2.1
date	2000.05.30.04.21.35;	author matz;	state Exp;
branches;
next	;


desc
@@


1.10
log
@matz - date/date2 integration
@
text
@# date2 was overridden by date.
# To be precise, date was overridden by date2,
# and date2 was renamed to date.

require 'date'
@


1.9
log
@matz
@
text
@d1 3
a3 2
# date2.rb: Written by Tadayoshi Funaba 1998-2000
# $Id: date2.rb,v 1.21 2000/05/14 15:47:09 tadf Exp $
d5 1
a5 343
class Date

  include Comparable

  IDENT = 2

  MONTHNAMES = [ nil, 'January', 'February', 'March',
    'April', 'May', 'June', 'July', 'August',
    'September', 'October', 'November', 'December' ]

  DAYNAMES = [ 'Sunday', 'Monday', 'Tuesday',
    'Wednesday', 'Thursday', 'Friday', 'Saturday' ]

  ITALY     = 2299161 # 1582-10-15
  ENGLAND   = 2361222 # 1752-09-14
  JULIAN    = false
  GREGORIAN = true

  class << self

    def os? (jd, sg)
      case sg
      when Numeric; jd < sg
      else;         not sg
      end
    end

    def ns? (jd, sg) not os?(jd, sg) end

    def civil_to_jd(y, m, d, sg=GREGORIAN)
      if m <= 2
	y -= 1
	m += 12
      end
      a = (y / 100.0).floor
      b = 2 - a + (a / 4.0).floor
      jd = (365.25 * (y + 4716)).floor +
	(30.6001 * (m + 1)).floor +
	d + b - 1524
      if os?(jd, sg)
	jd -= b
      end
      jd
    end

    def jd_to_civil(jd, sg=GREGORIAN)
      if os?(jd, sg)
	a = jd
      else
	x = ((jd - 1867216.25) / 36524.25).floor
	a = jd + 1 + x - (x / 4.0).floor
      end
      b = a + 1524
      c = ((b - 122.1) / 365.25).floor
      d = (365.25 * c).floor
      e = ((b - d) / 30.6001).floor
      dom = b - d - (30.6001 * e).floor
      if e <= 13
	m = e - 1
	y = c - 4716
      else
	m = e - 13
	y = c - 4715
      end
      return y, m, dom
    end

    def ordinal_to_jd(y, d, sg=GREGORIAN)
      civil_to_jd(y, 1, d, sg)
    end

    def jd_to_ordinal(jd, sg=GREGORIAN)
      y = jd_to_civil(jd, sg)[0]
      doy = jd - civil_to_jd(y - 1, 12, 31, ns?(jd, sg))
      return y, doy
    end

    def jd_to_commercial(jd, sg=GREGORIAN)
      ns = ns?(jd, sg)
      a = jd_to_civil(jd - 3, ns)[0]
      y = if jd >= commercial_to_jd(a + 1, 1, 1, ns) then a + 1 else a end
      w = 1 + (jd - commercial_to_jd(y, 1, 1, ns)) / 7
      d = (jd + 1) % 7
      if d.zero? then d = 7 end
      return y, w, d
    end

    def commercial_to_jd(y, w, d, ns=GREGORIAN)
      jd = civil_to_jd(y, 1, 4, ns)
      (jd - (((jd - 1) + 1) % 7)) +
	7 * (w - 1) +
	(d - 1)
    end

    def clfloor(x, y=1)
      q = (x / y).to_i
      z = (q * y)
      q -= 1 if (y > 0 and x < z) or (y < 0 and x > z)
      r = x - q * y
      return q, r
    end

    def rjd_to_jd(rjd) clfloor(rjd + 0.5) end
    def jd_to_rjd(jd, fr) jd + fr - 0.5 end

    def mjd_to_jd(mjd) mjd + 2400000.5 end
    def jd_to_mjd(jd) jd - 2400000.5 end
    def tjd_to_jd(tjd) tjd + 2440000.5 end
    def jd_to_tjd(jd) jd - 2440000.5 end
    def tjd2_to_jd(cycle, tjd) tjd_to_jd(cycle * 10000 + tjd) end
    def jd_to_tjd2(jd) clfloor(jd_to_tjd(jd), 10000) end
    def ld_to_jd(ld) ld + 2299160 end
    def jd_to_ld(jd) jd - 2299160 end

    def jd_to_wday(jd) (jd + 1) % 7 end

    def julian_leap? (y) y % 4 == 0 end
    def gregorian_leap? (y) y % 4 == 0 and y % 100 != 0 or y % 400 == 0 end

    alias_method :leap?, :gregorian_leap?

    def new1(jd=0, sg=ITALY) new(jd, sg) end

    def exist3? (y, m, d, sg=ITALY)
      if m < 0
	m += 13
      end
      if d < 0
	ny, nm = clfloor(y * 12 + m, 12)
	nm,    = clfloor(m + 1, 1)
	la = nil
	31.downto 1 do |z|
	  break if la = exist3?(y, m, z, sg)
	end
	ns = ns?(la, sg)
	d = jd_to_civil(civil_to_jd(ny, nm, 1, ns) + d, ns)[-1]
      end
      jd = civil_to_jd(y, m, d, sg)
      return unless [y, m, d] == jd_to_civil(jd, sg)
      jd
    end

    alias_method :exist?, :exist3?

    def new3(y=-4712, m=1, d=1, sg=ITALY)
      unless jd = exist3?(y, m, d, sg)
	raise ArgumentError, 'invalid date'
      end
      new(jd, sg)
    end

    def exist2? (y, d, sg=ITALY)
      if d < 0
	ny = y + 1
	la = nil
	366.downto 1 do |z|
	  break if la = exist2?(y, z, sg)
	end
	ns = ns?(la, sg)
	d = jd_to_ordinal(ordinal_to_jd(ny, 1, ns) + d, ns)[-1]
      end
      jd = ordinal_to_jd(y, d, sg)
      return unless [y, d] == jd_to_ordinal(jd, sg)
      jd
    end

    def new2(y=-4712, d=1, sg=ITALY)
      unless jd = exist2?(y, d, sg)
	raise ArgumentError, 'invalid date'
      end
      new(jd, sg)
    end

    def existw? (y, w, d, sg=ITALY)
      if d < 0
	d += 8
      end
      if w < 0
	w = jd_to_commercial(commercial_to_jd(y + 1, 1, 1) + w * 7)[1]
      end
      jd = commercial_to_jd(y, w, d)
      return unless ns?(jd, sg)
      return unless [y, w, d] == jd_to_commercial(jd)
      jd
    end

    def neww(y=1582, w=41, d=5, sg=ITALY)
      unless jd = existw?(y, w, d, sg)
	raise ArgumentError, 'invalid date'
      end
      new(jd, sg)
    end

    def today(sg=ITALY)
      new(civil_to_jd(*(Time.now.to_a[3..5].reverse << sg)), sg)
    end

    def once(*ids)
      for id in ids
	module_eval <<-"end;"
	  alias_method :__#{id.to_i}__, :#{id.id2name}
	  def #{id.id2name}(*args, &block)
	    (@@__#{id.to_i}__ ||= [__#{id.to_i}__(*args, &block)])[0]
	  end
	end;
      end
    end

    private :once

  end

  def initialize(rjd=0, sg=ITALY) @@rjd, @@sg = rjd, sg end

  def rjd() @@rjd end
  def rmjd() type.jd_to_mjd(@@rjd) end
  def rtjd() type.jd_to_tjd(@@rjd) end
  def rtjd2() type.jd_to_tjd2(@@rjd) end

  once :rmjd, :rtjd, :rtjd2

  def jd() type.rjd_to_jd(@@rjd)[0] end
  def fr1() type.rjd_to_jd(@@rjd)[1] end
  def mjd() type.jd_to_mjd(jd) end
  def tjd() type.jd_to_tjd(jd) end
  def tjd2() type.jd_to_tjd2(jd) end
  def ld() type.jd_to_ld(jd) end

  once :jd, :fr1, :mjd, :tjd, :tjd2, :ld

  def civil() type.jd_to_civil(jd, @@sg) end
  def ordinal() type.jd_to_ordinal(jd, @@sg) end
  def commercial() type.jd_to_commercial(jd, @@sg) end

  once :civil, :ordinal, :commercial
  private :civil, :ordinal, :commercial

  def year() civil[0] end
  def yday() ordinal[1] end
  def mon() civil[1] end

  alias_method :month, :mon

  def mday() civil[2] end

  alias_method :day, :mday

  def cwyear() commercial[0] end
  def cweek() commercial[1] end
  def cwday() commercial[2] end

  def wday() type.jd_to_wday(jd) end

  once :wday

  def os? () type.os?(jd, @@sg) end
  def ns? () type.ns?(jd, @@sg) end

  once :os?, :ns?

  def leap?
    type.jd_to_civil(type.civil_to_jd(year, 3, 1, ns?) - 1,
		     ns?)[-1] == 29
  end

  once :leap?

  def sg() @@sg end
  def newsg(sg=type::ITALY) type.new(@@rjd, sg) end

  def italy() newsg(type::ITALY) end
  def england() newsg(type::ENGLAND) end
  def julian() newsg(type::JULIAN) end
  def gregorian() newsg(type::GREGORIAN) end

  def + (n)
    case n
    when Numeric; return type.new(@@rjd + n, @@sg)
    end
    raise TypeError, 'expected numeric'
  end

  def - (x)
    case x
    when Numeric; return type.new(@@rjd - x, @@sg)
    when Date;    return @@rjd - x.rjd
    end
    raise TypeError, 'expected numeric or date'
  end

  def <=> (other)
    case other
    when Numeric; return @@rjd <=> other
    when Date;    return @@rjd <=> other.rjd
    end
    raise TypeError, 'expected numeric or date'
  end

  def === (other)
    case other
    when Numeric; return jd == other
    when Date;    return jd == other.jd
    end
    raise TypeError, 'expected numeric or date'
  end

  def >> (n)
    y, m = type.clfloor(year * 12 + (mon - 1) + n, 12)
    m,   = type.clfloor(m + 1, 1)
    d = mday
    d -= 1 until jd2 = type.exist3?(y, m, d, ns?)
    self + (jd2 - jd)
  end

  def << (n) self >> -n end

  def step(limit, step)
    da = self
    op = [:-,:<=,:>=][step<=>0]
    while da.__send__(op, limit)
      yield da
      da += step
    end
    self
  end

  def upto(max, &block) step(max, +1, &block) end
  def downto(min, &block) step(min, -1, &block) end

  def succ() self + 1 end

  alias_method :next, :succ

  def eql? (other) Date === other and self == other end
  def hash() type.clfloor(@@rjd)[0] end

  def inspect() format('#<%s: %s,%s>', type, @@rjd, @@sg) end
  def to_s() format('%.4d-%02d-%02d', year, mon, mday) end

  def _dump(limit) Marshal.dump([@@rjd, @@sg], -1) end
  def self._load(str) new(*Marshal.load(str)) end

end
@


1.8
log
@2000-05-24
@
text
@d150 1
a150 1
	fail ArgumentError, 'invalid date'
d172 1
a172 1
	fail ArgumentError, 'invalid date'
d192 1
a192 1
	fail ArgumentError, 'invalid date'
d283 1
a283 1
    fail TypeError, 'expected numeric'
d291 1
a291 1
    fail TypeError, 'expected numeric or date'
d299 1
a299 1
    fail TypeError, 'expected numeric or date'
d307 1
a307 1
    fail TypeError, 'expected numeric or date'
@


1.7
log
@2000-04-21
@
text
@d2 1
a2 1
# $Id: date2.rb,v 1.18 2000/03/20 16:23:32 tadf Exp $
d118 2
d132 2
a133 2
	ny, nm = Date.clfloor(y * 12 + m, 12)
	nm,    = Date.clfloor(m + 1, 1)
d204 1
a204 1
	  alias_method :__#{id.to_i}__, #{id.inspect}
d206 1
a206 2
	    def self.#{id.id2name}(*args, &block); @@__#{id.to_i}__ end
	    @@__#{id.to_i}__ = __#{id.to_i}__(*args, &block)
d219 3
a221 3
  def rmjd() Date.jd_to_mjd(@@rjd) end
  def rtjd() Date.jd_to_tjd(@@rjd) end
  def rtjd2() Date.jd_to_tjd2(@@rjd) end
d225 6
a230 6
  def jd() Date.rjd_to_jd(@@rjd)[0] end
  def fr1() Date.rjd_to_jd(@@rjd)[1] end
  def mjd() Date.jd_to_mjd(jd) end
  def tjd() Date.jd_to_tjd(jd) end
  def tjd2() Date.jd_to_tjd2(jd) end
  def ld() Date.jd_to_ld(jd) end
d234 3
a236 3
  def civil() Date.jd_to_civil(jd, @@sg) end
  def ordinal() Date.jd_to_ordinal(jd, @@sg) end
  def commercial() Date.jd_to_commercial(jd, @@sg) end
d239 1
a245 1
  once :year, :yday, :mon, :month
a249 1
  once :mday, :day
d255 1
a255 3
  once :cwyear, :cweek, :cwday

  def wday() (jd + 1) % 7 end
d259 2
a260 2
  def os? () Date.os?(jd, @@sg) end
  def ns? () Date.ns?(jd, @@sg) end
d265 1
a265 1
    Date.jd_to_civil(Date.civil_to_jd(year, 3, 1, ns?) - 1,
d272 1
a272 1
  def newsg(sg=Date::ITALY) Date.new(@@rjd, sg) end
d274 4
a277 4
  def italy() newsg(Date::ITALY) end
  def england() newsg(Date::ENGLAND) end
  def julian() newsg(Date::JULIAN) end
  def gregorian() newsg(Date::GREGORIAN) end
d281 1
a281 1
    when Numeric; return Date.new(@@rjd + n, @@sg)
d288 1
a288 1
    when Numeric; return Date.new(@@rjd - x, @@sg)
d311 2
a312 2
    y, m = Date.clfloor(year * 12 + (mon - 1) + n, 12)
    m,   = Date.clfloor(m + 1, 1)
d314 1
a314 1
    d -= 1 until jd2 = Date.exist3?(y, m, d, ns?)
d321 5
a325 11
    rjd = @@rjd
    if (step > 0)
      while rjd <= limit.rjd
	yield Date.new(rjd, @@sg)
	rjd += step
      end
    else
      while rjd >= limit.rjd
	yield Date.new(rjd, @@sg)
	rjd += step
      end
d338 3
a340 2
  def hash() Date.clfloor(@@rjd)[0] end
  def inspect() format('#<Date: %s,%s>', @@rjd, @@sg) end
d344 1
a344 1
  def Date._load(str) Date.new(*Marshal.load(str)) end
@


1.6
log
@2000-03-23
@
text
@d202 1
a202 1
	  alias_method :__#{id.to_i}__, #{id}
@


1.5
log
@2000-03-13
@
text
@d1 2
a2 2
# date2.rb: Written by Tadayoshi Funaba 1998, 1999
# $Id: date2.rb,v 1.17 1999/09/15 05:34:07 tadf Exp $
d113 4
d220 1
d222 1
a222 1
  once :rmjd, :rtjd
d228 2
d231 1
a231 1
  once :jd, :fr1, :mjd, :tjd
@


1.4
log
@1.4.1
@
text
@d198 1
a198 1
	  alias_method :__#{id}__, #{id}
d200 2
a201 2
	    def self.#{id.id2name}(*args, &block); @@__#{id}__ end
	    @@__#{id}__ = __#{id}__(*args, &block)
@


1.4.2.1
log
@2000-05-30
@
text
@d1 2
a2 2
# date2.rb: Written by Tadayoshi Funaba 1998-2000
# $Id: date2.rb,v 1.21 2000/05/14 15:47:09 tadf Exp $
a112 6
    def tjd2_to_jd(cycle, tjd) tjd_to_jd(cycle * 10000 + tjd) end
    def jd_to_tjd2(jd) clfloor(jd_to_tjd(jd), 10000) end
    def ld_to_jd(ld) ld + 2299160 end
    def jd_to_ld(jd) jd - 2299160 end

    def jd_to_wday(jd) (jd + 1) % 7 end
d126 2
a127 2
	ny, nm = clfloor(y * 12 + m, 12)
	nm,    = clfloor(m + 1, 1)
d198 1
a198 1
	  alias_method :__#{id.to_i}__, :#{id.id2name}
d200 2
a201 1
	    (@@__#{id.to_i}__ ||= [__#{id.to_i}__(*args, &block)])[0]
d214 15
a228 18
  def rmjd() type.jd_to_mjd(@@rjd) end
  def rtjd() type.jd_to_tjd(@@rjd) end
  def rtjd2() type.jd_to_tjd2(@@rjd) end

  once :rmjd, :rtjd, :rtjd2

  def jd() type.rjd_to_jd(@@rjd)[0] end
  def fr1() type.rjd_to_jd(@@rjd)[1] end
  def mjd() type.jd_to_mjd(jd) end
  def tjd() type.jd_to_tjd(jd) end
  def tjd2() type.jd_to_tjd2(jd) end
  def ld() type.jd_to_ld(jd) end

  once :jd, :fr1, :mjd, :tjd, :tjd2, :ld

  def civil() type.jd_to_civil(jd, @@sg) end
  def ordinal() type.jd_to_ordinal(jd, @@sg) end
  def commercial() type.jd_to_commercial(jd, @@sg) end
a230 1
  private :civil, :ordinal, :commercial
d237 1
d242 1
d248 3
a250 1
  def wday() type.jd_to_wday(jd) end
d254 2
a255 2
  def os? () type.os?(jd, @@sg) end
  def ns? () type.ns?(jd, @@sg) end
d260 1
a260 1
    type.jd_to_civil(type.civil_to_jd(year, 3, 1, ns?) - 1,
d267 1
a267 1
  def newsg(sg=type::ITALY) type.new(@@rjd, sg) end
d269 4
a272 4
  def italy() newsg(type::ITALY) end
  def england() newsg(type::ENGLAND) end
  def julian() newsg(type::JULIAN) end
  def gregorian() newsg(type::GREGORIAN) end
d276 1
a276 1
    when Numeric; return type.new(@@rjd + n, @@sg)
d283 1
a283 1
    when Numeric; return type.new(@@rjd - x, @@sg)
d306 2
a307 2
    y, m = type.clfloor(year * 12 + (mon - 1) + n, 12)
    m,   = type.clfloor(m + 1, 1)
d309 1
a309 1
    d -= 1 until jd2 = type.exist3?(y, m, d, ns?)
d316 11
a326 5
    da = self
    op = [:-,:<=,:>=][step<=>0]
    while da.__send__(op, limit)
      yield da
      da += step
d339 2
a340 3
  def hash() type.clfloor(@@rjd)[0] end

  def inspect() format('#<%s: %s,%s>', type, @@rjd, @@sg) end
d344 1
a344 1
  def self._load(str) new(*Marshal.load(str)) end
@


1.3
log
@regexp literal (e.g. \202) match, etc.
@
text
@d2 1
a2 1
# $Id: date2.rb,v 1.15 1999/08/29 15:23:52 tadf Exp $
d8 2
d17 4
a20 2
  ITALY   = 2299161 # Oct  15, 1582
  ENGLAND = 2361222 # Sept 14, 1752
d33 1
a33 1
    def civil_to_jd(y, m, d, sg=true)
d49 1
a49 1
    def jd_to_civil(jd, sg=true)
d71 1
a71 1
    def ordinal_to_jd(y, d, sg=true)
d75 1
a75 1
    def jd_to_ordinal(jd, sg=true)
d81 28
d119 2
d126 5
a130 3
	ljd = nil
	31.downto 1 do |ld|
	  break if ljd = exist3?(y, m, ld, sg)
d132 2
a133 5
	x  = y * 12 + m
	ny = x / 12
	nm = x % 12 + 1
	d = jd_to_civil(civil_to_jd(ny, nm, 1, ns?(ljd, sg)) + d,
			ns?(ljd, sg))[-1]
d136 2
a137 3
      if [y, m, d] == jd_to_civil(jd, sg)
	jd
      end
d151 4
a154 3
	ljd = nil
	366.downto 1 do |ld|
	  break if ljd = exist2?(y, ld, sg)
d156 2
a157 3
	ny = y + 1
	d = jd_to_ordinal(ordinal_to_jd(ny, 1, ns?(ljd, sg)) + d,
			  ns?(ljd, sg))[-1]
d160 2
a161 3
      if [y, d] == jd_to_ordinal(jd, sg)
	jd
      end
d171 20
d195 14
d211 1
a211 1
  def initialize(jd=0, sg=ITALY) @@jd, @@sg = jd, sg end
d213 3
a215 1
  def jd() @@jd end
d217 1
a217 4
  def mjd
    def self.mjd() @@mjd end
    @@mjd = Date.jd_to_mjd(@@jd)
  end
d219 4
a222 4
  def tjd
    def self.tjd() @@tjd end
    @@tjd = Date.jd_to_tjd(@@jd)
  end
d224 1
a224 8
  def civil
    def self.year() @@year end
    def self.mon() @@mon end
    def self.month() @@mon end
    def self.mday() @@mday end
    def self.day() @@mday end
    @@year, @@mon, @@mday = Date.jd_to_civil(@@jd, @@sg)
  end
d226 3
a228 1
  private :civil
d230 1
a230 4
  def year
    civil
    @@year
  end
d232 3
a234 10
  def yday
    def self.yday() @@yday end
    @@yday = Date.jd_to_ordinal(@@jd, @@sg)[-1]
    @@yday
  end

  def mon
    civil
    @@mon
  end
d237 1
d239 1
a239 4
  def mday
    civil
    @@mday
  end
d242 7
d250 6
a255 4
  def wday
    def self.wday() @@wday end
    @@wday = (@@jd + 1) % 7
  end
d257 1
a257 2
  def os? () Date.os?(@@jd, @@sg) end
  def ns? () Date.ns?(@@jd, @@sg) end
d260 2
a261 3
    def self.leap?() @@leap_p end
    @@leap_p = Date.jd_to_civil(Date.civil_to_jd(year, 3, 1, ns?) - 1,
			       ns?)[-1] == 29
d264 13
a276 3
  def + (other)
    case other
    when Numeric; return Date.new(@@jd + other, @@sg)
d281 4
a284 4
  def - (other)
    case other
    when Numeric; return Date.new(@@jd - other, @@sg)
    when Date;    return @@jd - other.jd
d291 2
a292 2
    when Numeric; return @@jd <=> other
    when Date;    return @@jd <=> other.jd
d297 4
a300 3
  def downto(min)
    @@jd.downto(min.jd) do |jd|
      yield Date.new(jd, @@sg)
d302 1
a302 1
    self
d305 6
a310 5
  def upto(max)
    @@jd.upto(max.jd) do |jd|
      yield Date.new(jd, @@sg)
    end
    self
d313 2
d316 11
a326 2
    @@jd.step(limit.jd, step) do |jd|
      yield Date.new(jd, @@sg)
d331 3
d338 3
a340 3
  def eql? (other) self == other end
  def hash() @@jd end
  def inspect() format('#<Date: %s,%s>', @@jd, @@sg) end
d343 1
a343 1
  def _dump(limit) Marshal.dump([@@jd, @@sg], -1) end
@


1.2
log
@1.4.0
@
text
@d2 1
a2 1
# $Id: date2.rb,v 1.13 1999/08/11 01:10:02 tadf Exp $
d34 4
a37 4
      a = (y / 100).to_i
      b = 2 - a + (a / 4).to_i
      jd = (365.25 * (y + 4716)).to_i +
	(30.6001 * (m + 1)).to_i +
d49 2
a50 2
	x = ((jd - 1867216.25) / 36524.25).to_i
	a = jd + 1 + x - (x / 4).to_i
d53 4
a56 4
      c = ((b - 122.1) / 365.25).to_i
      d = (365.25 * c).to_i
      e = ((b - d) / 30.6001).to_i
      dom = b - d - (30.6001 * e).to_i
d73 1
a73 2
      pl = civil_to_jd(y - 1, 12, 31, ns?(jd, sg))
      doy = jd - pl
@


1.1
log
@file date2.rb was initially added on branch v1_1r.
@
text
@d1 267
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@a0 219
# date.rb: Written by Tadayoshi Funaba 1998
# $Id: date.rb,v 1.4 1998/06/01 12:52:33 tadf Exp $

class Date

  include Comparable

  MONTHNAMES = [ '', 'January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December' ]

  DAYNAMES = [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
    'Friday', 'Saturday' ]

  ITALY   = 2299161 # Oct 15, 1582
  ENGLAND = 2361222 # Sept 14, 1752

  def Date.civil_to_jd(y, m, d, gs = true)
    if m <= 2 then
      y -= 1
      m += 12
    end
    a = (y / 100).to_i
    b = 2 - a + (a / 4).to_i
    jd = (365.25 * (y + 4716)).to_i +
      (30.6001 * (m + 1)).to_i +
      d + b - 1524
    unless
      (if gs.kind_of? Numeric then jd >= gs else gs end) then
      jd -= b
    end
    jd
  end

  def Date.jd_to_civil(jd, gs = true)
    unless
      (if gs.kind_of? Numeric then jd >= gs else gs end) then
      a = jd
    else
      x = ((jd - 1867216.25) / 36524.25).to_i
      a = jd + 1 + x - (x / 4).to_i
    end
    b = a + 1524
    c = ((b - 122.1) / 365.25).to_i
    d = (365.25 * c).to_i
    e = ((b - d) / 30.6001).to_i
    dom = b - d - (30.6001 * e).to_i
    if e <= 13 then
      m = e - 1
      y = c - 4716
    else
      m = e - 13
      y = c - 4715
    end
    return y, m, dom
  end

  def Date.mjd_to_jd(mjd)
    mjd + 2400000.5
  end

  def Date.jd_to_mjd(jd)
    jd - 2400000.5
  end

  def Date.tjd_to_jd(tjd)
    tjd + 2440000.5
  end

  def Date.jd_to_tjd(jd)
    jd - 2440000.5
  end

  def Date.julian_leap? (y)
    y % 4 == 0
  end

  def Date.gregorian_leap? (y)
    y % 4 == 0 and y % 100 != 0 or y % 400 == 0
  end

  def Date.leap? (y)
    Date.gregorian_leap?(y)
  end

  def initialize(jd = 0, gs = ITALY)
    @@jd, @@gs = jd, gs
  end

  def Date.exist? (y, m, d, gs = true)
    jd = Date.civil_to_jd(y, m, d, gs)
    if [y, m, d] == Date.jd_to_civil(jd, gs) then
      jd
    end
  end

  def Date.new3(y = -4712, m = 1, d = 1, gs = ITALY)
    unless jd = Date.exist?(y, m, d, gs) then
      fail ArgumentError, 'invalid date'
    end
    Date.new(jd, gs)
  end

  def Date.today(gs = ITALY)
    Date.new(Date.civil_to_jd(*(Time.now.to_a[3..5].reverse << gs)), gs)
  end

  def jd
    @@jd
  end

  def mjd
    def self.mjd; @@mjd end
    @@mjd = Date.jd_to_mjd(@@jd)
  end

  def tjd
    def self.tjd; @@tjd end
    @@tjd = Date.jd_to_tjd(@@jd)
  end

  def civil
    def self.year; @@year end
    def self.mon; @@mon end
    def self.mday; @@mday end
    @@year, @@mon, @@mday = Date.jd_to_civil(@@jd, @@gs)
  end

  private :civil

  def year
    civil
    @@year
  end

  def yday
    def self.yday; @@yday end
    ns = if @@gs.kind_of? Numeric then @@jd >= @@gs else @@gs end
    jd = Date.civil_to_jd(year - 1, 12, 31, ns)
    @@yday = @@jd - jd
  end

  def mon
    civil
    @@mon
  end

  def mday
    civil
    @@mday
  end

  def wday
    def self.wday; @@wday end
    @@wday = (@@jd + 1) % 7
  end

  def leap?
    def self.leap?; @@leap_p end
    ns = if @@gs.kind_of? Numeric then @@jd >= @@gs else @@gs end
    jd = Date.civil_to_jd(year, 2, 28, ns)
    @@leap_p = Date.jd_to_civil(jd + 1, ns)[1] == 2
  end

  def + (other)
    if other.kind_of? Numeric then
      return Date.new(@@jd + other, @@gs)
    end
    fail TypeError, 'expected numeric'
  end

  def - (other)
    if other.kind_of? Numeric then
      return Date.new(@@jd - other, @@gs)
    elsif other.kind_of? Date then
      return @@jd - other.jd
    end
    fail TypeError, 'expected numeric or date'
  end

  def <=> (other)
    if other.kind_of? Numeric then
      return @@jd <=> other
    elsif other.kind_of? Date then
      return @@jd <=> other.jd
    end
    fail TypeError, 'expected numeric or date'
  end

  def downto(min)
    @@jd.downto(min.jd) do |jd|
      yield Date.new(jd, @@gs)
    end
  end

  def upto(max)
    @@jd.upto(max.jd) do |jd|
      yield Date.new(jd, @@gs)
    end
  end

  def step(max, step)
    @@jd.step(max.jd, step) do |jd|
      yield Date.new(jd, @@gs)
    end
  end

  def eql? (other)
    self == other
  end

  def hash
    @@jd
  end

  def to_s
    format('%04d-%02d-%02d', year, mon, mday)
  end

end
@


1.1.1.1.2.1
log
@*** empty log message ***
@
text
@d1 2
a2 2
# date.rb: Written by Tadayoshi Funaba 1998, 1999
# $Id: date.rb,v 1.5 1999/02/06 08:51:56 tadf Exp $
d8 1
a8 1
  MONTHNAMES = [ nil, 'January', 'February', 'March', 'April', 'May', 'June',
d165 2
a166 2
    case other
    when Numeric; return Date.new(@@jd + other, @@gs)
d172 4
a175 3
    case other
    when Numeric; return Date.new(@@jd - other, @@gs)
    when Date;    return @@jd - other.jd
d181 4
a184 3
    case other
    when Numeric; return @@jd <=> other
    when Date;    return @@jd <=> other.jd
@


1.1.1.1.2.2
log
@990324
@
text
@d2 1
a2 1
# $Id: date.rb,v 1.7 1999/03/06 02:05:59 tadf Exp $
d8 2
a9 3
  MONTHNAMES = [ nil, 'January', 'February', 'March',
    'April', 'May', 'June', 'July', 'August',
    'September', 'October', 'November', 'December' ]
d11 2
a12 2
  DAYNAMES = [ 'Sunday', 'Monday', 'Tuesday',
    'Wednesday', 'Thursday', 'Friday', 'Saturday' ]
d17 4
a20 17
  class << self

    def civil_to_jd(y, m, d, gs=true)
      if m <= 2
	y -= 1
	m += 12
      end
      a = (y / 100).to_i
      b = 2 - a + (a / 4).to_i
      jd = (365.25 * (y + 4716)).to_i +
	(30.6001 * (m + 1)).to_i +
	d + b - 1524
      unless
	(if gs.kind_of? Numeric then jd >= gs else gs end)
	jd -= b
      end
      jd
d22 8
a29 22

    def jd_to_civil(jd, gs=true)
      unless
	(if gs.kind_of? Numeric then jd >= gs else gs end)
	a = jd
      else
	x = ((jd - 1867216.25) / 36524.25).to_i
	a = jd + 1 + x - (x / 4).to_i
      end
      b = a + 1524
      c = ((b - 122.1) / 365.25).to_i
      d = (365.25 * c).to_i
      e = ((b - d) / 30.6001).to_i
      dom = b - d - (30.6001 * e).to_i
      if e <= 13
	m = e - 1
	y = c - 4716
      else
	m = e - 13
	y = c - 4715
      end
      return y, m, dom
d31 2
d34 7
a40 2
    def ordinal_to_jd(y, d, gs=true)
      civil_to_jd(y, 1, d, gs)
d42 11
a52 7

    def jd_to_ordinal(jd, gs=true)
      y, *_ = jd_to_civil(jd, gs)
      ns = if gs.kind_of? Numeric then jd >= gs else gs end
      pl = civil_to_jd(y - 1, 12, 31, ns)
      doy = jd - pl
      return y, doy
d54 2
d57 3
a59 3
    def mjd_to_jd(mjd)
      mjd + 2400000.5
    end
d61 3
a63 3
    def jd_to_mjd(jd)
      jd - 2400000.5
    end
d65 3
a67 3
    def tjd_to_jd(tjd)
      tjd + 2440000.5
    end
d69 3
a71 3
    def jd_to_tjd(jd)
      jd - 2440000.5
    end
d73 3
a75 3
    def julian_leap? (y)
      y % 4 == 0
    end
d77 3
a79 3
    def gregorian_leap? (y)
      y % 4 == 0 and y % 100 != 0 or y % 400 == 0
    end
d81 3
a83 1
    alias_method :leap?, :gregorian_leap?
d85 3
a87 6
    def exist3? (y, m, d, gs=true)
      jd = civil_to_jd(y, m, d, gs)
      if [y, m, d] == jd_to_civil(jd, gs)
	jd
      end
    end
d89 4
a92 14
    alias_method :exist?, :exist3?

    def new3(y=-4712, m=1, d=1, gs=ITALY)
      unless jd = exist3?(y, m, d, gs)
	fail ArgumentError, 'invalid date'
      end
      new(jd, gs)
    end

    def exist2? (y, d, gs=true)
      jd = ordinal_to_jd(y, d, gs)
      if [y, d] == jd_to_ordinal(jd, gs)
	jd
      end
d94 1
d96 3
a98 5
    def new2(y=-4712, d=1, gs=ITALY)
      unless jd = exist2?(y, d, gs)
	fail ArgumentError, 'invalid date'
      end
      new(jd, gs)
d100 1
a100 5

    def today(gs=ITALY)
      new(civil_to_jd(*(Time.now.to_a[3..5].reverse << gs)), gs)
    end

d103 2
a104 2
  def initialize(jd=0, gs=ITALY)
    @@jd, @@gs = jd, gs
d112 1
a112 1
    def self.mjd() @@mjd end
d117 1
a117 1
    def self.tjd() @@tjd end
d122 3
a124 3
    def self.year() @@year end
    def self.mon() @@mon end
    def self.mday() @@mday end
d136 4
a139 3
    def self.yday() @@yday end
    _, @@yday = Date.jd_to_ordinal(@@jd, @@gs)
    @@yday
d153 1
a153 1
    def self.wday() @@wday end
d158 1
a158 1
    def self.leap?() @@leap_p end
a214 8
  end

  def _dump(limit)
    Marshal.dump([@@jd, @@gs], -1)
  end

  def Date._load(str)
    Date.new(*Marshal.load(str))
@


1.1.1.1.2.3
log
@1.3.8 to be, final beta (hopefully)
@
text
@d1 2
a2 2
# date2.rb: Written by Tadayoshi Funaba 1998, 1999
# $Id: date2.rb,v 1.13 1999/08/11 01:10:02 tadf Exp $
d15 1
a15 1
  ITALY   = 2299161 # Oct  15, 1582
d20 1
a20 10
    def os? (jd, sg)
      case sg
      when Numeric; jd < sg
      else;         not sg
      end
    end

    def ns? (jd, sg) not os?(jd, sg) end

    def civil_to_jd(y, m, d, sg=true)
d30 2
a31 1
      if os?(jd, sg)
d37 3
a39 2
    def jd_to_civil(jd, sg=true)
      if os?(jd, sg)
d60 2
a61 2
    def ordinal_to_jd(y, d, sg=true)
      civil_to_jd(y, 1, d, sg)
d64 4
a67 3
    def jd_to_ordinal(jd, sg=true)
      y = jd_to_civil(jd, sg)[0]
      pl = civil_to_jd(y - 1, 12, 31, ns?(jd, sg))
d72 15
a86 4
    def mjd_to_jd(mjd) mjd + 2400000.5 end
    def jd_to_mjd(jd) jd - 2400000.5 end
    def tjd_to_jd(tjd) tjd + 2440000.5 end
    def jd_to_tjd(jd) jd - 2440000.5 end
d88 7
a94 2
    def julian_leap? (y) y % 4 == 0 end
    def gregorian_leap? (y) y % 4 == 0 and y % 100 != 0 or y % 400 == 0 end
d98 3
a100 17
    def exist3? (y, m, d, sg=ITALY)
      if m < 0
	m += 13
      end
      if d < 0
	ljd = nil
	31.downto 1 do |ld|
	  break if ljd = exist3?(y, m, ld, sg)
	end
	x  = y * 12 + m
	ny = x / 12
	nm = x % 12 + 1
	d = jd_to_civil(civil_to_jd(ny, nm, 1, ns?(ljd, sg)) + d,
			ns?(ljd, sg))[-1]
      end
      jd = civil_to_jd(y, m, d, sg)
      if [y, m, d] == jd_to_civil(jd, sg)
d107 2
a108 2
    def new3(y=-4712, m=1, d=1, sg=ITALY)
      unless jd = exist3?(y, m, d, sg)
d111 1
a111 1
      new(jd, sg)
d114 3
a116 12
    def exist2? (y, d, sg=ITALY)
      if d < 0
	ljd = nil
	366.downto 1 do |ld|
	  break if ljd = exist2?(y, ld, sg)
	end
	ny = y + 1
	d = jd_to_ordinal(ordinal_to_jd(ny, 1, ns?(ljd, sg)) + d,
			  ns?(ljd, sg))[-1]
      end
      jd = ordinal_to_jd(y, d, sg)
      if [y, d] == jd_to_ordinal(jd, sg)
d121 2
a122 2
    def new2(y=-4712, d=1, sg=ITALY)
      unless jd = exist2?(y, d, sg)
d125 1
a125 1
      new(jd, sg)
d128 2
a129 2
    def today(sg=ITALY)
      new(civil_to_jd(*(Time.now.to_a[3..5].reverse << sg)), sg)
d134 3
a136 1
  def initialize(jd=0, sg=ITALY) @@jd, @@sg = jd, sg end
d138 3
a140 1
  def jd() @@jd end
a154 1
    def self.month() @@mon end
d156 1
a156 2
    def self.day() @@mday end
    @@year, @@mon, @@mday = Date.jd_to_civil(@@jd, @@sg)
d168 1
a168 1
    @@yday = Date.jd_to_ordinal(@@jd, @@sg)[-1]
a176 2
  alias_method :month, :mon

a181 2
  alias_method :day, :mday

a186 3
  def os? () Date.os?(@@jd, @@sg) end
  def ns? () Date.ns?(@@jd, @@sg) end

d189 3
a191 2
    @@leap_p = Date.jd_to_civil(Date.civil_to_jd(year, 3, 1, ns?) - 1,
			       ns?)[-1] == 29
d196 1
a196 1
    when Numeric; return Date.new(@@jd + other, @@sg)
d203 1
a203 1
    when Numeric; return Date.new(@@jd - other, @@sg)
d219 1
a219 1
      yield Date.new(jd, @@sg)
a220 1
    self
d225 1
a225 1
      yield Date.new(jd, @@sg)
a226 1
    self
d229 3
a231 3
  def step(limit, step)
    @@jd.step(limit.jd, step) do |jd|
      yield Date.new(jd, @@sg)
a232 1
    self
d235 3
a237 1
  def succ() self + 1 end
d239 3
a241 1
  alias_method :next, :succ
d243 3
a245 4
  def eql? (other) self == other end
  def hash() @@jd end
  def inspect() format('#<Date: %s,%s>', @@jd, @@sg) end
  def to_s() format('%.4d-%02d-%02d', year, mon, mday) end
d247 7
a253 2
  def _dump(limit) Marshal.dump([@@jd, @@sg], -1) end
  def Date._load(str) Date.new(*Marshal.load(str)) end
@


1.1.2.1
log
@1.1b9_00 picachu
@
text
@a0 243
# date.rb: Written by Tadayoshi Funaba 1998
# $Id: date.rb,v 1.3 1998/03/08 09:43:54 tadf Exp $

class Date

  include Comparable

  MONTHNAMES = [ '', 'January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December' ]

  DAYNAMES = [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
    'Friday', 'Saturday' ]

  GREGORY = 2299161	# Oct 15, 1582
  ENGLAND = 2361222	# Sept 14, 1752

  def Date.civil_to_jd(y, m, d, gs = true)
    if m <= 2 then
      y -= 1
      m += 12
    end
    a = (y / 100).to_i
    b = (a / 4).to_i
    c = 2 - a + b
    e = (365.25 * (y + 4716)).to_i
    f = (30.6001 * (m + 1)).to_i
    jd = c + d + e + f - 1524
    unless
      (if gs.kind_of? Numeric then jd >= gs else gs end) then
      jd -= c
    end
    return jd
  end

  def Date.jd_to_civil(jd, gs = true)
    unless
      (if gs.kind_of? Numeric then jd >= gs else gs end) then
      a = jd
    else
      w = ((jd - 1867216.25) / 36524.25).to_i
      x = (w / 4).to_i
      a = jd + 1 + w - x
    end
    b = a + 1524
    c = ((b - 122.1) / 365.25).to_i
    d = (365.25 * c).to_i
    e = ((b - d) / 30.6001).to_i
    f = (30.6001 * e).to_i
    day = b - d - f
    if e <= 13 then
      m = e - 1
    else
      m = e - 13
    end
    if m <= 2 then
      y = c - 4715
    else
      y = c - 4716
    end
    return y, m, day
  end

  def Date.mjd_to_jd(mjd)
    mjd + 2400000.5
  end

  def Date.jd_to_mjd(jd)
    jd - 2400000.5
  end

  def Date.tjd_to_jd(tjd)
    tjd + 2440000.5
  end

  def Date.jd_to_tjd(jd)
    jd - 2440000.5
  end

  def initialize(jd = 0, gs = GREGORY)
    @@jd = jd
    @@gs = gs
  end

  def Date.new3(y = -4712, m = 1, d = 1, gs = GREGORY)
    jd = Date.civil_to_jd(y, m, d, gs)
    y2, m2, d2 = Date.jd_to_civil(jd, gs)
    unless y == y2 and m == m2 and d == d2 then
      raise ArgumentError, 'invalid date'
    end
    Date.new(jd, gs)
  end

  def Date.today(gs = GREGORY)
    Date.new3(*(Time.now.to_a[3..5].reverse << gs))
  end

  def jd
    @@jd
  end

  def mjd
    Date.jd_to_mjd(@@jd)
  end

  def tjd
    Date.jd_to_tjd(@@jd)
  end

  def year
    Date.jd_to_civil(@@jd, @@gs)[0]
  end

  def yday
    gs = if @@gs.kind_of? Numeric then @@jd >= @@gs else @@gs end
    jd = Date.civil_to_jd(year - 1, 12, 31, gs)
    @@jd - jd
  end

  def mon
    Date.jd_to_civil(@@jd, @@gs)[1]
  end

  def mday
    Date.jd_to_civil(@@jd, @@gs)[2]
  end

  def wday
    k = (@@jd + 1) % 7
    k += 7 if k < 0
    k
  end

  def leap?
    gs = if @@gs.kind_of? Numeric then @@jd >= @@gs else @@gs end
    jd = Date.civil_to_jd(year, 2, 28, gs)
    Date.jd_to_civil(jd + 1, gs)[1] == 2
  end

  def + (other)
    if other.kind_of? Numeric then
      return Date.new(@@jd + other, @@gs)
    end
    raise TypeError, 'expected numeric'
  end

  def - (other)
    if other.kind_of? Numeric then
      return Date.new(@@jd - other, @@gs)
    elsif other.kind_of? Date then
      return @@jd - other.jd
    end
    raise TypeError, 'expected numeric or date'
  end

  def <=> (other)
    if other.kind_of? Numeric then
      return @@jd <=> other
    elsif other.kind_of? Date then
      return @@jd <=> other.jd
    end
    raise TypeError, 'expected numeric or date'
  end

  def downto(min)
    @@jd.downto(min.jd) do |jd|
      yield Date.new(jd, @@gs)
    end
  end

  def upto(max)
    @@jd.upto(max.jd) do |jd|
      yield Date.new(jd, @@gs)
    end
  end

  def step(max, step)
    @@jd.step(max.jd, step) do |jd|
      yield Date.new(jd, @@gs)
    end
  end

  def eql? (other)
    self == other
  end

  def hash
    @@jd
  end

  def to_s
    format('%04d-%02d-%02d', *Date.jd_to_civil(@@jd, @@gs))
  end

end
[3 goodfriday.rb <text/plain; us-ascii (7bit)>]
#! /usr/local/bin/ruby

# goodfriday.rb: Written by Tadayoshi Funaba 1998
# $Id: goodfriday.rb,v 1.1 1998/03/08 09:44:44 tadf Exp $

require 'date'

def easter(y)
  g = (y % 19) + 1
  c = (y / 100) + 1
  x = (3 * c / 4) - 12
  z = ((8 * c + 5) / 25) - 5
  d = (5 * y / 4) - x - 10
  e = (11 * g + 20 + z - x) % 30
  e += 1 if e == 25 and g > 11 or e == 24
  n = 44 - e
  n += 30 if n < 21
  n = n + 7 - ((d + n) % 7)
  if n <= 31 then [y, 3, n] else [y, 4, n - 31] end
end

es = Date.new3(*easter(Time.now.year))
[[-9*7, 'Septuagesima Sunday'],
 [-8*7, 'Sexagesima Sunday'],
 [-7*7, 'Quinquagesima Sunday (Shrove Sunday)'],
 [-48,  'Shrove Monday'],
 [-47,  'Shrove Tuesday'],
 [-46,  'Ash Wednesday'],
 [-6*7, 'Quadragesima Sunday'],
 [-3*7, 'Mothering Sunday'],
 [-2*7, 'Passion Sunday'],
 [-7,   'Palm Sunday'],
 [-3,   'Maunday Thursday'],
 [-2,   'Good Friday'],
 [-1,   'Easter Eve'],
 [0,    'Easter Day'],
 [1,    'Easter Monday'],
 [7,    'Low Sunday'],
 [5*7,  'Rogation Sunday'],
 [39,   'Ascension Day (Holy Thursday)'],
 [42,   'Sunday after Ascension Day'],
 [7*7,  'Pentecost (Whitsunday)'],
 [50,   'Whitmonday'],
 [8*7,  'Trinity Sunday'],
 [60,   'Corpus Christi (Thursday after Trinity)']].
each do |xs|
  puts ((es + xs.shift).to_s + '  ' + xs.shift)
end
@


1.1.2.2
log
@gets speed up patch
@
text
@d195 49
@


1.1.2.3
log
@regex
@
text
@d2 1
a2 1
# $Id: date.rb,v 1.4 1998/06/01 12:52:33 tadf Exp $
d14 2
a15 2
  ITALY   = 2299161 # Oct 15, 1582
  ENGLAND = 2361222 # Sept 14, 1752
d23 5
a27 4
    b = 2 - a + (a / 4).to_i
    jd = (365.25 * (y + 4716)).to_i +
      (30.6001 * (m + 1)).to_i +
      d + b - 1524
d30 1
a30 1
      jd -= b
d32 1
a32 1
    jd
d40 3
a42 2
      x = ((jd - 1867216.25) / 36524.25).to_i
      a = jd + 1 + x - (x / 4).to_i
d48 2
a49 1
    dom = b - d - (30.6001 * e).to_i
a51 1
      y = c - 4716
d54 2
d57 2
d60 1
a60 1
    return y, m, dom
d79 3
a81 10
  def Date.julian_leap? (y)
    y % 4 == 0
  end

  def Date.gregorian_leap? (y)
    y % 4 == 0 and y % 100 != 0 or y % 400 == 0
  end

  def Date.leap? (y)
    Date.gregorian_leap?(y)
d84 1
a84 5
  def initialize(jd = 0, gs = ITALY)
    @@jd, @@gs = jd, gs
  end

  def Date.exist? (y, m, d, gs = true)
d86 3
a88 8
    if [y, m, d] == Date.jd_to_civil(jd, gs) then
      jd
    end
  end

  def Date.new3(y = -4712, m = 1, d = 1, gs = ITALY)
    unless jd = Date.exist?(y, m, d, gs) then
      fail ArgumentError, 'invalid date'
d93 2
a94 2
  def Date.today(gs = ITALY)
    Date.new(Date.civil_to_jd(*(Time.now.to_a[3..5].reverse << gs)), gs)
d102 1
a102 2
    def self.mjd; @@mjd end
    @@mjd = Date.jd_to_mjd(@@jd)
d106 1
a106 9
    def self.tjd; @@tjd end
    @@tjd = Date.jd_to_tjd(@@jd)
  end

  def civil
    def self.year; @@year end
    def self.mon; @@mon end
    def self.mday; @@mday end
    @@year, @@mon, @@mday = Date.jd_to_civil(@@jd, @@gs)
a108 2
  private :civil

d110 1
a110 2
    civil
    @@year
d114 3
a116 4
    def self.yday; @@yday end
    ns = if @@gs.kind_of? Numeric then @@jd >= @@gs else @@gs end
    jd = Date.civil_to_jd(year - 1, 12, 31, ns)
    @@yday = @@jd - jd
d120 1
a120 2
    civil
    @@mon
d124 1
a124 2
    civil
    @@mday
d128 3
a130 2
    def self.wday; @@wday end
    @@wday = (@@jd + 1) % 7
d134 3
a136 4
    def self.leap?; @@leap_p end
    ns = if @@gs.kind_of? Numeric then @@jd >= @@gs else @@gs end
    jd = Date.civil_to_jd(year, 2, 28, ns)
    @@leap_p = Date.jd_to_civil(jd + 1, ns)[1] == 2
d143 1
a143 1
    fail TypeError, 'expected numeric'
d152 1
a152 1
    fail TypeError, 'expected numeric or date'
d161 1
a161 1
    fail TypeError, 'expected numeric or date'
d191 1
a191 1
    format('%04d-%02d-%02d', year, mon, mday)
@


1.1.2.4
log
@1.2.3
@
text
@d1 2
a2 2
# date.rb: Written by Tadayoshi Funaba 1998, 1999
# $Id: date.rb,v 1.5 1999/02/06 08:51:56 tadf Exp $
d8 1
a8 1
  MONTHNAMES = [ nil, 'January', 'February', 'March', 'April', 'May', 'June',
d165 2
a166 2
    case other
    when Numeric; return Date.new(@@jd + other, @@gs)
d172 4
a175 3
    case other
    when Numeric; return Date.new(@@jd - other, @@gs)
    when Date;    return @@jd - other.jd
d181 4
a184 3
    case other
    when Numeric; return @@jd <=> other
    when Date;    return @@jd <=> other.jd
@


