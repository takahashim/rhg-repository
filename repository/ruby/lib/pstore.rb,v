head	1.15;
access;
symbols
	v1_6_7:1.8.2.5
	v1_6_6:1.8.2.4
	v1_6_5:1.8.2.3
	v1_6_4:1.8.2.3
	v1_7_1:1.9
	v1_6_4_preview4:1.8.2.3
	v1_6_4_preview3:1.8.2.3
	v1_6_4_preview2:1.8
	v1_6_4_preview1:1.8
	v1_6_3:1.8
	ruby_m17n:1.8.0.4
	ruby_1_6:1.8.0.2
	v1_6_2:1.8
	v1_6_1:1.7
	v1_6_0:1.6
	v1_4_6:1.1.1.2.4.6
	v1_4_5:1.1.1.2.4.6
	v1_4_4:1.1.1.2.4.5
	ruby_1_4_3:1.1.1.2.4.4
	ruby1_4_3:1.1.1.2.4.4
	v1_4_3:1.1.1.2.4.4
	v1_5_0:1.4
	ruby_1_4_3_pre1:1.1.1.2.4.2
	ruby_1_4:1.1.1.2.0.4
	v1_4_2:1.1.1.2
	v1_4_1:1.1.1.2
	v1_4_0:1.1.1.2
	v1_3_7:1.1.1.2
	v1_3_6_repack:1.1.1.2
	v1_3_6:1.1.1.2
	v1_3_5:1.1.1.2
	v1_2_6repack:1.1.1.1.2.4
	v1_3_4_990625:1.1.1.2
	v1_3_4_990624:1.1.1.2
	v1_2_6:1.1.1.1.2.4
	v1_3_4_990611:1.1.1.2
	v1_3_4_990531:1.1.1.2
	v1_3_3_990518:1.1.1.2
	v1_3_3_990513:1.1.1.2
	v1_3_3_990507:1.1.1.2
	v1_2_5:1.1.1.1.2.4
	v1_2_4:1.1.1.1.2.4
	v1_3_1_990225:1.1.1.2
	v1_3_1_990224:1.1.1.2
	v1_3_1_990215:1.1.1.2
	v1_3_1_990212:1.1.1.2
	v1_3_1_990210:1.1.1.2
	v1_3_1_:1.1.1.2
	v1_3_1_990209:1.1.1.2
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.2.4
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.2.4
	v1_2_1repack:1.1.1.1.2.4
	v1_2_1:1.1.1.1.2.4
	v1_2_stable:1.1.1.1.2.4
	v1_1d1:1.1.1.1.2.4.2.2
	v1_1d0:1.1.1.1.2.4.2.2
	v1_1c9_1:1.1.1.1.2.4
	v1_1c9:1.1.1.1.2.4
	v1_1c8:1.1.1.1.2.4
	v1_1c7:1.1.1.1.2.4
	v1_1c6:1.1.1.1.2.4
	v1_1d-start:1.1.1.1.2.4
	v1_1c5:1.1.1.1.2.4
	v1_1dev:1.1.1.1.2.4.0.2
	v1_1c4:1.1.1.1.2.4
	v1_1c3:1.1.1.1.2.4
	v1_1c2:1.1.1.1.2.4
	v1_1c1:1.1.1.1.2.4
	v1_1c0:1.1.1.1.2.4
	v1_1b9_31:1.1.1.1.2.4
	v1_1b9_30:1.1.1.1.2.3
	v1_1b9_28:1.1.1.1.2.3
	v1_1b9_27:1.1.1.1.2.3
	v1_1b9_26:1.1.1.1.2.3
	r1_1b9_25:1.1.1.1.2.3
	r1_1b9_24:1.1.1.1.2.3
	v1_1b9_23:1.1.1.1.2.3
	v1_1b9_22:1.1.1.1.2.3
	v1_1b9_20:1.1.1.1.2.3
	v1_1b9_18:1.1.1.1.2.3
	v1_1b9_16:1.1.1.1.2.2
	v1_1b9_15:1.1.1.1.2.2
	v1_1b9_13:1.1.1.1.2.1
	v1_1b9_12:1.1.1.1.2.1
	v1_1b9_11:1.1.1.1
	v1_1b9_08:1.1.1.1
	v1_1b9_07:1.1.1.1
	r1_1b9:1.1.1.1
	v1_1b8:1.1.1.1
	v1_1b7:1.1.1.1
	v1_1b6:1.1.1.1
	v1_1r:1.1.1.1.0.2
	v1_1:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;


1.15
date	2002.07.11.08.22.14;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.24.07.59.02;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.01.14.03.19;	author knu;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.19.05.02.19;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.03.07.19.19;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.31.06.24.45;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.06.15.04.52;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.11.06.29.14;	author matz;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.09.19.07.54.27;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.13.09.04.40;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.06.04.15.42;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.11.29.06.33.01;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.11.25.09.03.08;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.11.17.07.30.37;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.19.17;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.19.17;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.35;	author matz;	state Exp;
branches
	1.1.1.2.4.1;
next	;

1.1.1.2.4.1
date	99.11.17.07.29.53;	author matz;	state Exp;
branches;
next	1.1.1.2.4.2;

1.1.1.2.4.2
date	99.11.24.07.13.53;	author matz;	state Exp;
branches;
next	1.1.1.2.4.3;

1.1.1.2.4.3
date	99.11.29.06.31.05;	author matz;	state Exp;
branches;
next	1.1.1.2.4.4;

1.1.1.2.4.4
date	99.12.02.07.49.28;	author matz;	state Exp;
branches;
next	1.1.1.2.4.5;

1.1.1.2.4.5
date	2000.03.02.03.51.50;	author matz;	state Exp;
branches;
next	1.1.1.2.4.6;

1.1.1.2.4.6
date	2000.06.13.09.51.01;	author matz;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	98.04.20.05.55.38;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	98.04.22.08.55.40;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	98.05.06.03.09.01;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	98.07.15.06.13.01;	author matz;	state Exp;
branches
	1.1.1.1.2.4.2.1;
next	;

1.1.1.1.2.4.2.1
date	98.10.06.03.28.25;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4.2.2;

1.1.1.1.2.4.2.2
date	98.12.16.07.30.36;	author matz;	state Exp;
branches;
next	;

1.8.2.1
date	2001.04.19.09.16.07;	author matz;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.05.01.08.45.23;	author matz;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.05.02.04.16.31;	author matz;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.11.19.04.58.09;	author matz;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.01.04.14.20.20;	author matz;	state Exp;
branches;
next	;


desc
@@


1.15
log
@* string.c (rb_str_slice_bang): if there's no corresponding
  substring, slice! should return nil without exception.

* array.c (rb_ary_insert): type fixed.

* string.c (rb_str_split_m): accept separator value nil as well.

* string.c (rb_str_become): was leaking memory.

* class.c (rb_include_module): should not alter other
  classes/modules by inclusion.  by this fix, local order may not
  be preserved for some cases.

* class.c (include_class_new): module may be T_ICLASS; retrieve
  original module information.
@
text
@#
# How to use:
#
# db = PStore.new("/tmp/foo")
# db.transaction do
#   p db.roots
#   ary = db["root"] = [1,2,3,4]
#   ary[0] = [1,1.5]
# end

# db.transaction do
#   p db["root"]
# end

require "ftools"
require "digest/md5"

class PStore
  class Error < StandardError
  end

  def initialize(file)
    dir = File::dirname(file)
    unless File::directory? dir
      raise PStore::Error, format("directory %s does not exist", dir)
    end
    unless File::writable? dir
      raise PStore::Error, format("directory %s not writable", dir)
    end
    if File::exist? file and not File::readable? file
      raise PStore::Error, format("file %s not readable", file)
    end
    @@transaction = false
    @@filename = file
    @@abort = false
  end

  def in_transaction
    raise PStore::Error, "not in transaction" unless @@transaction
  end
  private :in_transaction

  def [](name)
    in_transaction
    @@table[name]
  end
  def fetch(name, default=PStore::Error)
    unless @@table.key? name
      if default==PStore::Error
	raise PStore::Error, format("undefined root name `%s'", name)
      else
	default
      end
    end
    self[name]
  end
  def []=(name, value)
    in_transaction
    @@table[name] = value
  end
  def delete(name)
    in_transaction
    @@table.delete name
  end

  def roots
    in_transaction
    @@table.keys
  end
  def root?(name)
    in_transaction
    @@table.key? name
  end
  def path
    @@filename
  end

  def commit
    in_transaction
    @@abort = false
    throw :pstore_abort_transaction
  end
  def abort
    in_transaction
    @@abort = true
    throw :pstore_abort_transaction
  end

  def transaction(read_only=false)
    raise PStore::Error, "nested transaction" if @@transaction
    begin
      @@transaction = true
      value = nil
      backup = @@filename+"~"
      begin
	file = File::open(@@filename, "rb+")
	orig = true
      rescue Errno::ENOENT
	raise if read_only
	file = File::open(@@filename, "wb+")
      end
      file.flock(read_only ? File::LOCK_SH : File::LOCK_EX)
      if read_only
	@@table = Marshal::load(file)
      elsif orig and (content = file.read) != nil
	@@table = Marshal::load(content)
	size = content.size
	md5 = Digest::MD5.digest(content)
	content = nil		# unreference huge data
      else
	@@table = {}
      end
      begin
	catch(:pstore_abort_transaction) do
	  value = yield(self)
	end
      rescue Exception
	@@abort = true
	raise
      ensure
	if !read_only && !@@abort
	  file.rewind
	  content = Marshal::dump(@@table)
	  if !md5 || size != content.size || md5 != Digest::MD5.digest(content)
	    File::copy @@filename, backup
	    begin
	      file.write(content)
	      file.truncate(file.pos)
	      content = nil		# unreference huge data
	    rescue
	      File::rename backup, @@filename if File::exist?(backup)
	      raise
	    end
	  end
	end
	@@abort = false
      end
    ensure
      @@table = nil
      @@transaction = false
      file.close if file
    end
    value
  end
end

if __FILE__ == $0
  db = PStore.new("/tmp/foo")
  db.transaction do
    p db.roots
    ary = db["root"] = [1,2,3,4]
    ary[1] = [1,1.5]
  end

  1000.times do
    db.transaction do
      db["root"][0] += 1
      p db["root"][0]
    end
  end

  db.transaction(true) do
    p db["root"]
  end
end
@


1.14
log
@* parse.y (yylex): __END__ should not be effective within
  string literals.

* parse.y (here_document): should be aware of __END__ within here
  documents.
@
text
@d45 3
d49 5
a53 1
      raise PStore::Error, format("undefined root name `%s'", name)
d55 1
a55 1
    @@table[name]
@


1.13
log
@Reflect the update of the MD5 module which is now Digest::MD5.
@
text
@d98 1
a98 2
      elsif orig
	content = file.read
@


1.12
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* massages: replace "wrong #" by "wrong number".

* marshal.c (w_float): output Infinity and NaN explicitly.

* marshal.c (r_object): support new explicit float format.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.

* array.c (rb_ary_join): dumped core if sep is not T_STRING nor T_NIL.

* array.c (rb_ary_join): buffer size calculattion was wrong.

* array.c (rb_ary_to_s): if rb_output_fs is nil, insert newlines
  between array elements (use rb_default_rs as newline litral)
  [experimental].

* gc.c (init_mark_stack): no need to clear mark_stack.

* gc.c (gc_mark_all): need to handle finalizer mark.

* gc.c (gc_mark_rest): use MEMCPY instead of memcpy.

* gc.c (rb_gc_mark): earlier const check to avoid pusing special
  constants into mark stack.

* numeric.c (fix_to_s): 'to_s' now takes optional argument to
  specify radix. [new]

* bignum.c (rb_big_to_s): ditto. [new]
@
text
@d16 1
a16 1
require "md5"
d102 1
a102 1
	md5 = MD5.new(content).digest
d118 1
a118 1
	  if !md5 || size != content.size || md5 != MD5.new(content).digest
@


1.11
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d135 1
a135 1
      file.close
@


1.10
log
@* marshal.c (Init_marshal): new constant Marshal::MAJOR_VERSION
  and Marshal::MINOR_VERSION.

* marshal.c (marshal_load): ruby_verbose test should be wrapped by
  RTEST().

* hash.c (rb_hash_index): should return nil (not the default
  value) if value is not in the hash.

* numeric.c (num_div): new method added.  alias to '/' which
  should be preserved even if '/' is redefined (e.g. by
  mathn). [new]

* bignum.c (rb_cstr2inum): "0 ff".hex should return 0, not 255.

* file.c (rb_file_s_expand_path): fixed using CharNext().
@
text
@d89 1
a89 1
	file = File::open(@@filename, "r+")
d93 1
a93 1
	file = File::open(@@filename, "w+")
@


1.9
log
@forgot some checkins.
@
text
@d82 1
a82 1
  def transaction
d92 1
d95 4
a98 2
      file.flock(File::LOCK_EX)
      if orig
d115 1
a115 1
	unless @@abort
d156 1
a156 1
  db.transaction do
@


1.8
log
@matz
@
text
@d16 1
d45 1
a45 2
    value = @@table[name]
    if value == nil
d48 1
a48 1
    value
d72 1
d77 1
d88 1
a88 1
      if File::exist?(@@filename)
d91 1
a91 2
      else
	@@table = {}
a92 1
	Marshal::dump(@@table, file)
d96 7
a102 2
	File::copy @@filename, backup
	@@table = Marshal::load(file)
d113 12
a124 7
	  begin
	    file.rewind
	    Marshal::dump(@@table, file)
	    file.truncate(file.pos)
	  rescue
	    File::rename backup, @@filename if File::exist?(backup)
	    raise
d151 4
@


1.8.2.1
log
@m68m frame_pointer patch
@
text
@d44 2
a45 1
    if @@table.key? name
d48 1
a48 1
    @@table[name]
@


1.8.2.2
log
@* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): inifinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe leve 4.
@
text
@d44 1
a44 1
    unless @@table.key? name
@


1.8.2.3
log
@* eval.c (block_pass): should not downgrade safe level.
@
text
@a70 1
    in_transaction
a74 1
    in_transaction
@


1.8.2.4
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.
@
text
@d123 1
a123 1
      file.close if file
@


1.8.2.5
log
@forgot to commit everything bug ChangeLog
@
text
@d88 1
a88 1
	file = File::open(@@filename, "rb+")
d92 1
a92 1
	file = File::open(@@filename, "wb+")
@


1.7
log
@000919
@
text
@d111 1
@


1.6
log
@pstore abort handle
@
text
@a14 1
require "marshal"
@


1.5
log
@2000-03-06
@
text
@d91 1
d93 1
a98 2
      else
	@@table = {}
@


1.4
log
@19991129
@
text
@d55 4
@


1.3
log
@19991125
@
text
@d110 1
@


1.2
log
@19991117
@
text
@d16 1
d81 7
a87 10
      value = file = nil
      lock = @@filename + ".lock"
      loop do
	begin
	  File::symlink("pstore::#$$", lock)
	  break
	rescue Errno::EEXIST
	rescue
	  sleep 1
	end
d89 5
a93 5
      begin
	File::open(@@filename, "r") do |file|
	  @@table = Marshal.load(file)
	end
      rescue Errno::ENOENT
d106 2
a107 8
	    File::rename @@filename, @@filename+"~"
	  rescue Errno::ENOENT
	    no_orig = true
	  end
	  begin
	    File::open(@@filename, "w") do |file|
	      Marshal::dump(@@table, file)
	    end
d109 1
a109 1
	    File::rename @@filename+"~", @@filename unless no_orig
d117 1
a117 1
      File::unlink(lock)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 2
#!/usr/local/bin/ruby

d18 2
a19 1
  Exception(:Error)
d81 10
d102 3
d107 5
a111 1
	  File::rename @@filename, @@filename+"~"
d117 1
a117 1
	    File::rename @@filename+"~", @@filename
d123 1
d125 1
d131 7
a137 6
db = PStore.new("/tmp/foo")
db.transaction do
  p db.roots
  ary = db["root"] = [1,2,3,4]
  ary[0] = [1,1.5]
end
d139 6
a144 2
db.transaction do
  p db["root"]
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@d1 2
a2 1
#
d19 1
a19 2
  class Error < StandardError
  end
a91 3
      rescue Exception
	@@abort = true
	raise
d94 1
a94 5
	  begin
	    File::rename @@filename, @@filename+"~"
	  rescue Errno::ENOENT
	    no_orig = true
	  end
d100 1
a100 1
	    File::rename @@filename+"~", @@filename unless no_orig
a105 1
      @@table = nil
d112 6
a117 7
if __FILE__ == $0
  db = PStore.new("/tmp/foo")
  db.transaction do
    p db.roots
    ary = db["root"] = [1,2,3,4]
    ary[1] = [1,1.5]
  end
d119 2
a120 6
  1000.times do
    db.transaction do
      db["root"][0] += 1
      p db["root"][0]
    end
  end
@


1.1.1.2.4.1
log
@19991117
@
text
@a80 10
      lock = @@filename + ".lock"
      loop do
	begin
	  File::symlink("pstore::#$$", lock)
	  break
	rescue Errno::EEXIST
	rescue
	  sleep 1
	end
      end
a114 1
      File::unlink(lock)
@


1.1.1.2.4.2
log
@19991124-1.4.3pre1
@
text
@a15 1
require "ftools"
d80 10
a89 7
      value = nil
      backup = @@filename+"~"
      if File::exist?(@@filename)
	file = File::open(@@filename, "r+")
	orig = true
      else
	file = File::open(@@filename, "w+")
d91 5
a95 5
      file.flock(File::LOCK_EX)
      if orig
	File::copy @@filename, backup
	@@table = Marshal::load(file)
      else
d108 8
a115 2
	    file.rewind
	    Marshal::dump(@@table, file)
d117 1
a117 1
	    File::rename backup, @@filename if File::exist?(backup)
d125 1
a125 1
      file.close
@


1.1.1.2.4.3
log
@19991129
@
text
@a109 1
	    raise
@


1.1.1.2.4.4
log
@19991202
@
text
@d118 1
a118 1
      file.close if file
@


1.1.1.2.4.5
log
@2000-03-02
@
text
@a54 4
  def delete(name)
    in_transaction
    @@table.delete name
  end
@


1.1.1.2.4.6
log
@2000-06-13
@
text
@a90 1
	@@table = {}
a91 1
	Marshal::dump(@@table, file)
d97 2
@


1.1.1.1.2.1
log
@*** empty log message ***
@
text
@d1 2
a2 1
#
@


1.1.1.1.2.2
log
@find.rb
@
text
@d111 6
a116 7
if __FILE__ == $0
  db = PStore.new("/tmp/foo")
  db.transaction do
    p db.roots
    ary = db["root"] = [1,2,3,4]
    ary[0] = [1,1.5]
  end
d118 2
a119 3
  db.transaction do
    p db["root"]
  end
@


1.1.1.1.2.3
log
@new exception model
@
text
@d18 1
a18 2
  class Error < StandardError
  end
d93 1
a93 5
	  begin
	    File::rename @@filename, @@filename+"~"
	  rescue Errno::ENOENT
	    no_orig = true
	  end
d99 1
a99 1
	    File::rename @@filename+"~", @@filename unless no_orig
@


1.1.1.1.2.4
log
@1.1b9_31
@
text
@a91 3
      rescue Exception
	@@abort = true
	raise
@


1.1.1.1.2.4.2.1
log
@join 1.1c6
@
text
@d124 1
a124 1
    ary[1] = [1,1.5]
d127 2
a128 5
  1000.times do
    db.transaction do
      db["root"][0] += 1
      p db["root"][0]
    end
@


1.1.1.1.2.4.2.2
log
@first public release of 1.1d (pre1.2) series
@
text
@a112 1
      @@table = nil
@
