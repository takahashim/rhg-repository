head	1.12;
access;
symbols
	v1_6_7:1.6.2.1
	v1_6_6:1.6.2.1
	v1_6_5:1.6.2.1
	v1_6_4:1.6.2.1
	v1_7_1:1.9
	v1_6_4_preview4:1.6.2.1
	v1_6_4_preview3:1.6.2.1
	v1_6_4_preview2:1.6.2.1
	v1_6_4_preview1:1.6.2.1
	v1_6_3:1.6.2.1
	ruby_m17n:1.6.0.4
	ruby_1_6:1.6.0.2
	v1_6_2:1.6
	v1_6_1:1.4
	v1_6_0:1.4
	v1_4_6:1.1.1.2
	v1_4_5:1.1.1.2
	v1_4_4:1.1.1.2
	ruby_1_4_3:1.1.1.2
	ruby1_4_3:1.1.1.2
	v1_4_3:1.1.1.2
	v1_5_0:1.1.1.2
	ruby_1_4_3_pre1:1.1.1.2
	ruby_1_4:1.1.1.2.0.4
	v1_4_2:1.1.1.2
	v1_4_1:1.1.1.2
	v1_4_0:1.1.1.2
	v1_3_7:1.1.1.2
	v1_3_6_repack:1.1.1.2
	v1_3_6:1.1.1.2
	v1_3_5:1.1.1.2
	v1_2_6repack:1.1.1.1.4.5
	v1_3_4_990625:1.1.1.2
	v1_3_4_990624:1.1.1.2
	v1_2_6:1.1.1.1.4.5
	v1_3_4_990611:1.1.1.2
	v1_3_4_990531:1.1.1.2
	v1_3_3_990518:1.1.1.2
	v1_3_3_990513:1.1.1.2
	v1_3_3_990507:1.1.1.2
	v1_2_5:1.1.1.1.4.5
	v1_2_4:1.1.1.1.4.5
	v1_3_1_990225:1.1.1.2
	v1_3_1_990224:1.1.1.2
	v1_3_1_990215:1.1.1.2
	v1_3_1_990212:1.1.1.2
	v1_3_1_990210:1.1.1.2
	v1_3_1_:1.1.1.2
	v1_3_1_990209:1.1.1.2
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.4.5
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.4.5
	v1_2_1repack:1.1.1.1.4.5
	v1_2_1:1.1.1.1.4.5
	v1_2_stable:1.1.1.1.4.5
	v1_1d1:1.1.1.1.4.5
	v1_1d0:1.1.1.1.4.5
	v1_1c9_1:1.1.1.1.4.5
	v1_1c9:1.1.1.1.4.5
	v1_1c8:1.1.1.1.4.5
	v1_1c7:1.1.1.1.4.5
	v1_1c6:1.1.1.1.4.5
	v1_1d-start:1.1.1.1.4.5
	v1_1c5:1.1.1.1.4.5
	v1_1dev:1.1.1.1.4.5.0.2
	v1_1c4:1.1.1.1.4.5
	v1_1c3:1.1.1.1.4.5
	v1_1c2:1.1.1.1.4.5
	v1_1c1:1.1.1.1.4.5
	v1_1c0:1.1.1.1.4.5
	v1_1b9_31:1.1.1.1.4.5
	v1_1b9_30:1.1.1.1.4.5
	v1_1b9_28:1.1.1.1.4.5
	v1_1b9_27:1.1.1.1.4.5
	v1_1b9_26:1.1.1.1.4.5
	r1_1b9_25:1.1.1.1.4.5
	r1_1b9_24:1.1.1.1.4.5
	v1_1b9_23:1.1.1.1.4.5
	v1_1b9_22:1.1.1.1.4.5
	v1_1b9_20:1.1.1.1.4.5
	v1_1b9_18:1.1.1.1.4.5
	v1_1b9_16:1.1.1.1.4.5
	v1_1b9_15:1.1.1.1.4.5
	v1_1b9_13:1.1.1.1.4.5
	v1_1b9_12:1.1.1.1.4.5
	v1_1b9_11:1.1.1.1.4.5
	v1_1b9_08:1.1.1.1.4.5
	v1_1b9_07:1.1.1.1.4.5
	r1_1b9:1.1.1.1.4.4
	v1_1b8:1.1.1.1.4.4
	v1_1b7:1.1.1.1.4.3
	v1_1b6:1.1.1.1.4.1
	v1_1r:1.1.1.1.0.4
	v1_1:1.1.1.1
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2002.10.02.16.45.34;	author nobu;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.22.15.26.58;	author tadf;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.18.12.41.50;	author tadf;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.07.09.26.29;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.06.15.04.52;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.18.08.43.12;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.25.06.29.24;	author matz;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.12.18.09.46.18;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.18.07.37.02;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.10.04.49.21;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.06.07.21.23;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.35;	author matz;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	98.01.16.12.36.04;	author matz;	state Exp;
branches;
next	1.1.1.1.4.2;

1.1.1.1.4.2
date	98.02.02.04.49.13;	author matz;	state Exp;
branches;
next	1.1.1.1.4.3;

1.1.1.1.4.3
date	98.02.03.10.02.57;	author matz;	state Exp;
branches;
next	1.1.1.1.4.4;

1.1.1.1.4.4
date	98.02.18.01.56.47;	author matz;	state Exp;
branches;
next	1.1.1.1.4.5;

1.1.1.1.4.5
date	98.03.03.02.39.34;	author matz;	state Exp;
branches;
next	;

1.6.2.1
date	2001.01.23.09.54.38;	author matz;	state Exp;
branches;
next	;


desc
@@


1.12
log
@use Object#class instead of deprecated Object#type.
@
text
@# date.rb: Written by Tadayoshi Funaba 1998-2002
# $Id: date.rb,v 2.8 2002-06-08 00:39:51+09 tadf Exp $

require 'rational'
require 'date/format'

class Date

  include Comparable

  MONTHNAMES = [nil] + %w(January February March April May June July
			  August September October November December)

  DAYNAMES = %w(Sunday Monday Tuesday Wednesday Thursday Friday Saturday)

  ABBR_MONTHNAMES = [nil] + %w(Jan Feb Mar Apr May Jun
			       Jul Aug Sep Oct Nov Dec)

  ABBR_DAYNAMES = %w(Sun Mon Tue Wed Thu Fri Sat)

  ITALY     = 2299161 # 1582-10-15
  ENGLAND   = 2361222 # 1752-09-14
  JULIAN    = false
  GREGORIAN = true

  def self.os? (jd, sg)
    case sg
    when Numeric; jd < sg
    else;         not sg
    end
  end

  def self.ns? (jd, sg) not os?(jd, sg) end

  def self.civil_to_jd(y, m, d, sg=GREGORIAN)
    if m <= 2
      y -= 1
      m += 12
    end
    a = (y / 100.0).floor
    b = 2 - a + (a / 4.0).floor
    jd = (365.25 * (y + 4716)).floor +
      (30.6001 * (m + 1)).floor +
      d + b - 1524
    if os?(jd, sg)
      jd -= b
    end
    jd
  end

  def self.jd_to_civil(jd, sg=GREGORIAN)
    if os?(jd, sg)
      a = jd
    else
      x = ((jd - 1867216.25) / 36524.25).floor
      a = jd + 1 + x - (x / 4.0).floor
    end
    b = a + 1524
    c = ((b - 122.1) / 365.25).floor
    d = (365.25 * c).floor
    e = ((b - d) / 30.6001).floor
    dom = b - d - (30.6001 * e).floor
    if e <= 13
      m = e - 1
      y = c - 4716
    else
      m = e - 13
      y = c - 4715
    end
    return y, m, dom
  end

  def self.ordinal_to_jd(y, d, sg=GREGORIAN)
    civil_to_jd(y, 1, d, sg)
  end

  def self.jd_to_ordinal(jd, sg=GREGORIAN)
    y = jd_to_civil(jd, sg)[0]
    doy = jd - civil_to_jd(y - 1, 12, 31, ns?(jd, sg))
    return y, doy
  end

  def self.jd_to_commercial(jd, sg=GREGORIAN)
    ns = ns?(jd, sg)
    a = jd_to_civil(jd - 3, ns)[0]
    y = if jd >= commercial_to_jd(a + 1, 1, 1, ns) then a + 1 else a end
    w = 1 + (jd - commercial_to_jd(y, 1, 1, ns)) / 7
    d = (jd + 1) % 7
    if d.zero? then d = 7 end
    return y, w, d
  end

  def self.commercial_to_jd(y, w, d, ns=GREGORIAN)
    jd = civil_to_jd(y, 1, 4, ns)
    (jd - (((jd - 1) + 1) % 7)) +
      7 * (w - 1) +
      (d - 1)
  end

  %w(self.clfloor clfloor).each do |name|
    module_eval <<-"end;"
      def #{name}(x, y=1)
	q, r = x.divmod(y)
	q = q.to_i
	return q, r
      end
    end;
  end

  private_class_method :clfloor
  private              :clfloor

  def self.ajd_to_jd(ajd, of=0) clfloor(ajd + of + 1.to_r/2) end
  def self.jd_to_ajd(jd, fr, of=0) jd + fr - of - 1.to_r/2 end

  def self.day_fraction_to_time(fr)
    h,   fr = clfloor(fr, 1.to_r/24)
    min, fr = clfloor(fr, 1.to_r/1440)
    s,   fr = clfloor(fr, 1.to_r/86400)
    return h, min, s, fr
  end

  def self.time_to_day_fraction(h, min, s)
    h.to_r/24 + min.to_r/1440 + s.to_r/86400
  end

  def self.amjd_to_ajd(amjd) amjd + 4800001.to_r/2 end
  def self.ajd_to_amjd(ajd) ajd - 4800001.to_r/2 end
  def self.mjd_to_jd(mjd) mjd + 2400001 end
  def self.jd_to_mjd(jd) jd - 2400001 end
  def self.ld_to_jd(ld) ld + 2299160 end
  def self.jd_to_ld(jd) jd - 2299160 end

  def self.jd_to_wday(jd) (jd + 1) % 7 end

  def self.julian_leap? (y) y % 4 == 0 end
  def self.gregorian_leap? (y) y % 4 == 0 and y % 100 != 0 or y % 400 == 0 end

  class << self; alias_method :leap?, :gregorian_leap? end
  class << self; alias_method :new0, :new end

  def self.valid_jd? (jd, sg=ITALY) jd end

  def self.jd(jd=0, sg=ITALY)
    jd = valid_jd?(jd, sg)
    new0(jd_to_ajd(jd, 0, 0), 0, sg)
  end

  def self.valid_ordinal? (y, d, sg=ITALY)
    if d < 0
      ny, = clfloor(y + 1, 1)
      jd = ordinal_to_jd(ny, d + 1, sg)
      ns = ns?(jd, sg)
      return unless [y] == jd_to_ordinal(jd, sg)[0..0]
      return unless [ny, 1] == jd_to_ordinal(jd - d, ns)
    else
      jd = ordinal_to_jd(y, d, sg)
      return unless [y, d] == jd_to_ordinal(jd, sg)
    end
    jd
  end

  def self.ordinal(y=-4712, d=1, sg=ITALY)
    unless jd = valid_ordinal?(y, d, sg)
      raise ArgumentError, 'invalid date'
    end
    new0(jd_to_ajd(jd, 0, 0), 0, sg)
  end

  def self.valid_civil? (y, m, d, sg=ITALY)
    if m < 0
      m += 13
    end
    if d < 0
      ny, nm = clfloor(y * 12 + m, 12)
      nm,    = clfloor(nm + 1, 1)
      jd = civil_to_jd(ny, nm, d + 1, sg)
      ns = ns?(jd, sg)
      return unless [y, m] == jd_to_civil(jd, sg)[0..1]
      return unless [ny, nm, 1] == jd_to_civil(jd - d, ns)
    else
      jd = civil_to_jd(y, m, d, sg)
      return unless [y, m, d] == jd_to_civil(jd, sg)
    end
    jd
  end

  class << self; alias_method :valid_date?, :valid_civil? end

  def self.civil(y=-4712, m=1, d=1, sg=ITALY)
    unless jd = valid_civil?(y, m, d, sg)
      raise ArgumentError, 'invalid date'
    end
    new0(jd_to_ajd(jd, 0, 0), 0, sg)
  end

  class << self; alias_method :new, :civil end

  def self.valid_commercial? (y, w, d, sg=ITALY)
    if d < 0
      d += 8
    end
    if w < 0
      w = jd_to_commercial(commercial_to_jd(y + 1, 1, 1) + w * 7)[1]
    end
    jd = commercial_to_jd(y, w, d)
    return unless ns?(jd, sg)
    return unless [y, w, d] == jd_to_commercial(jd)
    jd
  end

  def self.commercial(y=1582, w=41, d=5, sg=ITALY)
    unless jd = valid_commercial?(y, w, d, sg)
      raise ArgumentError, 'invalid date'
    end
    new0(jd_to_ajd(jd, 0, 0), 0, sg)
  end

  def self.new_with_hash(elem, sg)
    elem ||= {}
    y, m, d = elem.select(:year, :mon, :mday)
    if [y, m, d].include? nil
      raise ArgumentError, 'invalid date'
    else
      civil(y, m, d, sg)
    end
  end

  private_class_method :new_with_hash

  def self.strptime(str='-4712-01-01', fmt='%F', sg=ITALY)
    elem = _strptime(str, fmt)
    new_with_hash(elem, sg)
  end

  def self.parse(str='-4712-01-01', comp=false, sg=ITALY)
    elem = _parse(str, comp)
    new_with_hash(elem, sg)
  end

  def self.today(sg=ITALY)
    jd = civil_to_jd(*(Time.now.to_a[3..5].reverse << sg))
    new0(jd_to_ajd(jd, 0, 0), 0, sg)
  end

  class << self

    def once(*ids)
      for id in ids
	module_eval <<-"end;"
	  alias_method :__#{id.to_i}__, :#{id.to_s}
	  private :__#{id.to_i}__
	  def #{id.to_s}(*args, &block)
	    (@@__#{id.to_i}__ ||= [__#{id.to_i}__(*args, &block)])[0]
	  end
	end;
      end
    end

    private :once

  end

  def initialize(ajd=0, of=0, sg=ITALY) @@ajd, @@of, @@sg = ajd, of, sg end

  def ajd() @@ajd end
  def amjd() self.class.ajd_to_amjd(@@ajd) end

  once :amjd

  def jd() self.class.ajd_to_jd(@@ajd, @@of)[0] end
  def day_fraction() self.class.ajd_to_jd(@@ajd, @@of)[1] end
  def mjd() self.class.jd_to_mjd(jd) end
  def ld() self.class.jd_to_ld(jd) end

  once :jd, :day_fraction, :mjd, :ld

  def civil() self.class.jd_to_civil(jd, @@sg) end
  def ordinal() self.class.jd_to_ordinal(jd, @@sg) end
  def commercial() self.class.jd_to_commercial(jd, @@sg) end

  once :civil, :ordinal, :commercial
  private :civil, :ordinal, :commercial

  def year() civil[0] end
  def yday() ordinal[1] end
  def mon() civil[1] end
  def mday() civil[2] end

  alias_method :month, :mon
  alias_method :day, :mday

  def time() self.class.day_fraction_to_time(day_fraction) end

  once :time
  private :time

  def hour() time[0] end
  def min() time[1] end
  def sec() time[2] end
  def sec_fraction() time[3] end

  private :hour, :min, :sec, :sec_fraction

  def zone
    ['Z',
      format('%+.2d%02d',
	     (@@of     / (1.to_r/24)).to_i,
	     (@@of.abs % (1.to_r/24) / (1.to_r/1440)).to_i)
    ][@@of<=>0]
  end

  private :zone

  def cwyear() commercial[0] end
  def cweek() commercial[1] end
  def cwday() commercial[2] end

  def wday() self.class.jd_to_wday(jd) end

  once :wday

  def os? () self.class.os?(jd, @@sg) end
  def ns? () self.class.ns?(jd, @@sg) end

  once :os?, :ns?

  def leap?
    self.class.jd_to_civil(self.class.civil_to_jd(year, 3, 1, ns?) - 1,
		     ns?)[-1] == 29
  end

  once :leap?

  def start() @@sg end
  def new_start(sg=self.class::ITALY) self.class.new0(@@ajd, @@of, sg) end

  def italy() new_start(self.class::ITALY) end
  def england() new_start(self.class::ENGLAND) end
  def julian() new_start(self.class::JULIAN) end
  def gregorian() new_start(self.class::GREGORIAN) end

  def offset() @@of end
  def new_offset(of=0) self.class.new0(@@ajd, of, @@sg) end

  private :offset, :new_offset

  def + (n)
    case n
    when Numeric; return self.class.new0(@@ajd + n, @@of, @@sg)
    end
    raise TypeError, 'expected numeric'
  end

  def - (x)
    case x
    when Numeric; return self.class.new0(@@ajd - x, @@of, @@sg)
    when Date;    return @@ajd - x.ajd
    end
    raise TypeError, 'expected numeric or date'
  end

  def <=> (other)
    case other
    when Numeric; return @@ajd <=> other
    when Date;    return @@ajd <=> other.ajd
    end
    raise TypeError, 'expected numeric or date'
  end

  def === (other)
    case other
    when Numeric; return jd == other
    when Date;    return jd == other.jd
    end
    raise TypeError, 'expected numeric or date'
  end

  def >> (n)
    y, m = clfloor(year * 12 + (mon - 1) + n, 12)
    m,   = clfloor(m + 1, 1)
    d = mday
    d -= 1 until jd2 = self.class.valid_civil?(y, m, d, ns?)
    self + (jd2 - jd)
  end

  def << (n) self >> -n end

  def step(limit, step)
    da = self
    op = [:-,:<=,:>=][step<=>0]
    while da.__send__(op, limit)
      yield da
      da += step
    end
    self
  end

  def upto(max, &block) step(max, +1, &block) end
  def downto(min, &block) step(min, -1, &block) end

  def succ() self + 1 end

  alias_method :next, :succ

  def eql? (other) Date === other and self == other end
  def hash() @@ajd.hash end

  def inspect() format('#<%s: %s,%s,%s>', self.class, @@ajd, @@of, @@sg) end
  def to_s() strftime end

  def _dump(limit) Marshal.dump([@@ajd, @@of, @@sg], -1) end

# def self._load(str) new0(*Marshal.load(str)) end

  def self._load(str)
    a = Marshal.load(str)
    if a.size == 2
      ajd,     sg = a
           of = 0
      ajd -= 1.to_r/2
    else
      ajd, of, sg = a
    end
    new0(ajd, of, sg)
  end

end

class DateTime < Date

  def self.valid_time? (h, min, s)
    h   += 24 if h   < 0
    min += 60 if min < 0
    s   += 60 if s   < 0
    return unless (0..24) === h and
		  (0..59) === min and
		  (0..59) === s
    time_to_day_fraction(h, min, s)
  end

  def self.jd(jd=0, h=0, min=0, s=0, of=0, sg=ITALY)
    unless (jd = valid_jd?(jd, sg)) and
	   (fr = valid_time?(h, min, s))
      raise ArgumentError, 'invalid date'
    end
    new0(jd_to_ajd(jd, fr, of), of, sg)
  end

  def self.ordinal(y=-4712, d=1, h=0, min=0, s=0, of=0, sg=ITALY)
    unless (jd = valid_ordinal?(y, d, sg)) and
	   (fr = valid_time?(h, min, s))
      raise ArgumentError, 'invalid date'
    end
    new0(jd_to_ajd(jd, fr, of), of, sg)
  end

  def self.civil(y=-4712, m=1, d=1, h=0, min=0, s=0, of=0, sg=ITALY)
    unless (jd = valid_civil?(y, m, d, sg)) and
	   (fr = valid_time?(h, min, s))
      raise ArgumentError, 'invalid date'
    end
    new0(jd_to_ajd(jd, fr, of), of, sg)
  end

  class << self; alias_method :new, :civil end

  def self.commercial(y=1582, w=41, d=5, h=0, min=0, s=0, of=0, sg=ITALY)
    unless (jd = valid_commercial?(y, w, d, sg)) and
	   (fr = valid_time?(h, min, s))
      raise ArgumentError, 'invalid date'
    end
    new0(jd_to_ajd(jd, fr, of), of, sg)
  end

  def self.new_with_hash(elem, sg)
    elem ||= {}
    y, m, d, h, min, s, of =
      elem.select(:year, :mon, :mday, :hour, :min, :sec, :offset)
    h   ||= 0
    min ||= 0
    s   ||= 0
    of  ||= 0
    if [y, m, d].include? nil
      raise ArgumentError, 'invalid date'
    else
      civil(y, m, d, h, min, s, of.to_r/86400, sg)
    end
  end

  private_class_method :new_with_hash

  def self.strptime(str='-4712-01-01T00:00:00Z', fmt='%FT%T%Z', sg=ITALY)
    elem = _strptime(str, fmt)
    new_with_hash(elem, sg)
  end

  def self.parse(str='-4712-01-01T00:00:00Z', comp=false, sg=ITALY)
    elem = _parse(str, comp)
    new_with_hash(elem, sg)
  end

  class << self; undef_method :today end

  def self.now(sg=ITALY)
    i = Time.now
    a = i.to_a[0..5].reverse
    jd = civil_to_jd(*(a[0,3] << sg))
    fr = time_to_day_fraction(*(a[3,3])) + i.usec.to_r/86400000000
    d = Time.gm(*i.to_a).to_i - i.to_i
    d += d / d.abs if d.nonzero?
    of = (d / 60).to_r/1440
    new0(jd_to_ajd(jd, fr, of), of, sg)
  end

  public :hour, :min, :sec, :sec_fraction, :zone, :offset, :new_offset

end

class Date

  [ %w(exist1?	valid_jd?),
    %w(exist2?	valid_ordinal?),
    %w(exist3?	valid_date?),
    %w(exist?	valid_date?),
    %w(existw?	valid_commercial?),
    %w(new1	jd),
    %w(new2	ordinal),
    %w(new3	new),
    %w(neww	commercial)
  ].each do |old, new|
    module_eval <<-"end;"
      def self.#{old}(*args, &block)
	if $VERBOSE
	  $stderr.puts("\#{caller.shift.sub(/:in .*/, '')}: " \
		       "warning: \#{self}::#{old} is deprecated; " \
		       "use \#{self}::#{new}")
	end
	#{new}(*args, &block)
      end
    end;
  end

  [ %w(sg	start),
    %w(newsg	new_start),
    %w(of	offset),
    %w(newof	new_offset)
  ].each do |old, new|
    module_eval <<-"end;"
      def #{old}(*args, &block)
	if $VERBOSE
	  $stderr.puts("\#{caller.shift.sub(/:in .*/, '')}: " \
		       "warning: \#{self.class}\##{old} is deprecated; " \
		       "use \#{self.class}\##{new}")
	end
	#{new}(*args, &block)
      end
    end;
  end

  private :of, :newof

end

class DateTime < Date

  public :of, :newof

end
@


1.11
log
@updated to the new version (based on date2 3.3).
@
text
@d267 1
a267 1
  def amjd() type.ajd_to_amjd(@@ajd) end
d271 4
a274 4
  def jd() type.ajd_to_jd(@@ajd, @@of)[0] end
  def day_fraction() type.ajd_to_jd(@@ajd, @@of)[1] end
  def mjd() type.jd_to_mjd(jd) end
  def ld() type.jd_to_ld(jd) end
d278 3
a280 3
  def civil() type.jd_to_civil(jd, @@sg) end
  def ordinal() type.jd_to_ordinal(jd, @@sg) end
  def commercial() type.jd_to_commercial(jd, @@sg) end
d293 1
a293 1
  def time() type.day_fraction_to_time(day_fraction) end
d319 1
a319 1
  def wday() type.jd_to_wday(jd) end
d323 2
a324 2
  def os? () type.os?(jd, @@sg) end
  def ns? () type.ns?(jd, @@sg) end
d329 1
a329 1
    type.jd_to_civil(type.civil_to_jd(year, 3, 1, ns?) - 1,
d336 1
a336 1
  def new_start(sg=type::ITALY) type.new0(@@ajd, @@of, sg) end
d338 4
a341 4
  def italy() new_start(type::ITALY) end
  def england() new_start(type::ENGLAND) end
  def julian() new_start(type::JULIAN) end
  def gregorian() new_start(type::GREGORIAN) end
d344 1
a344 1
  def new_offset(of=0) type.new0(@@ajd, of, @@sg) end
d350 1
a350 1
    when Numeric; return type.new0(@@ajd + n, @@of, @@sg)
d357 1
a357 1
    when Numeric; return type.new0(@@ajd - x, @@of, @@sg)
d383 1
a383 1
    d -= 1 until jd2 = type.valid_civil?(y, m, d, ns?)
d409 1
a409 1
  def inspect() format('#<%s: %s,%s,%s>', type, @@ajd, @@of, @@sg) end
d553 2
a554 2
		       "warning: \#{type}\##{old} is deprecated; " \
		       "use \#{type}\##{new}")
@


1.10
log
@updated to the new version (based on date2 3.2.1).
@
text
@d2 1
a2 1
# $Id: date.rb,v 2.6 2002-05-14 07:43:18+09 tadf Exp $
d100 8
a107 4
  def self.clfloor(x, y=1)
    q, r = x.divmod(y)
    q = q.to_i
    return q, r
d110 5
a114 2
  def self.rjd_to_jd(rjd, of=0) clfloor(rjd + of + 1.to_r/2) end
  def self.jd_to_rjd(jd, fr, of=0) jd + fr - of - 1.to_r/2 end
d127 4
a130 6
  def self.mjd_to_jd(mjd) mjd + 4800001.to_r/2 end
  def self.jd_to_mjd(jd) jd - 4800001.to_r/2 end
  def self.tjd_to_jd(tjd) tjd + 4880001.to_r/2 end
  def self.jd_to_tjd(jd) jd - 4880001.to_r/2 end
  def self.tjd2_to_jd(cycle, tjd) tjd_to_jd(cycle * 10000 + tjd) end
  def self.jd_to_tjd2(jd) clfloor(jd_to_tjd(jd), 10000) end
d142 1
a142 3
  def self.exist1? (jd, sg=ITALY) jd end

  class << self; alias_method :valid_jd?, :exist1? end
d144 3
a146 3
  def self.new1(jd=0, sg=ITALY)
    jd = exist1?(jd, sg)
    new0(jd_to_rjd(jd, 0, 0), 0, sg)
d149 1
a149 3
  class << self; alias_method :jd, :new1 end

  def self.exist2? (y, d, sg=ITALY)
d163 2
a164 4
  class << self; alias_method :valid_ordinal?, :exist2? end

  def self.new2(y=-4712, d=1, sg=ITALY)
    unless jd = exist2?(y, d, sg)
d167 1
a167 1
    new0(jd_to_rjd(jd, 0, 0), 0, sg)
d170 1
a170 3
  class << self; alias_method :ordinal, :new2 end

  def self.exist3? (y, m, d, sg=ITALY)
d188 1
a188 2
  class << self; alias_method :exist?, :exist3? end
  class << self; alias_method :valid_civil?, :exist3? end
d190 2
a191 2
  def self.new3(y=-4712, m=1, d=1, sg=ITALY)
    unless jd = exist3?(y, m, d, sg)
d194 1
a194 1
    new0(jd_to_rjd(jd, 0, 0), 0, sg)
d197 1
a197 2
  class << self; alias_method :new, :new3 end
  class << self; alias_method :civil, :new3 end
d199 1
a199 1
  def self.existw? (y, w, d, sg=ITALY)
d212 2
a213 4
  class << self; alias_method :valid_commercial?, :existw? end

  def self.neww(y=1582, w=41, d=5, sg=ITALY)
    unless jd = existw?(y, w, d, sg)
d216 1
a216 1
    new0(jd_to_rjd(jd, 0, 0), 0, sg)
a218 2
  class << self; alias_method :commercial, :neww end

d225 1
a225 1
      new3(y, m, d, sg)
d243 1
a243 1
    new0(jd_to_rjd(jd, 0, 0), 0, sg)
d251 1
a251 1
	  alias_method :__#{id.to_i}__, :#{id.id2name}
d253 1
a253 1
	  def #{id.id2name}(*args, &block)
d264 1
a264 1
  def initialize(rjd=0, of=0, sg=ITALY) @@rjd, @@of, @@sg = rjd, of, sg end
d266 2
a267 4
  def rjd() @@rjd end
  def rmjd() type.jd_to_mjd(@@rjd) end
  def rtjd() type.jd_to_tjd(@@rjd) end
  def rtjd2() type.jd_to_tjd2(@@rjd) end
d269 1
a269 1
  once :rmjd, :rtjd, :rtjd2
d271 2
a272 2
  def jd() type.rjd_to_jd(@@rjd, @@of)[0] end
  def day_fraction() type.rjd_to_jd(@@rjd, @@of)[1] end
a273 2
  def tjd() type.jd_to_tjd(jd) end
  def tjd2() type.jd_to_tjd2(jd) end
d276 1
a276 1
  once :jd, :day_fraction, :mjd, :tjd, :tjd2, :ld
d308 3
a310 3
	     (of     / (1.to_r/24)).to_i,
	     (of.abs % (1.to_r/24) / (1.to_r/1440)).to_i)
    ][of<=>0]
d335 2
a336 5
  def sg() @@sg end
  def newsg(sg=type::ITALY) type.new0(@@rjd, @@of, sg) end

  alias_method :start, :sg
  alias_method :new_start, :newsg
d338 4
a341 4
  def italy() newsg(type::ITALY) end
  def england() newsg(type::ENGLAND) end
  def julian() newsg(type::JULIAN) end
  def gregorian() newsg(type::GREGORIAN) end
d343 2
a344 2
  def of() @@of end
  def newof(of=0) type.new0(@@rjd, of, @@sg) end
d346 1
a346 4
  alias_method :offset, :of
  alias_method :new_offset, :newof

  private :of, :newof, :offset, :new_offset
d350 1
a350 1
    when Numeric; return type.new0(@@rjd + n, @@of, @@sg)
d357 2
a358 2
    when Numeric; return type.new0(@@rjd - x, @@of, @@sg)
    when Date;    return @@rjd - x.rjd
d365 2
a366 2
    when Numeric; return @@rjd <=> other
    when Date;    return @@rjd <=> other.rjd
d380 2
a381 2
    y, m = type.clfloor(year * 12 + (mon - 1) + n, 12)
    m,   = type.clfloor(m + 1, 1)
d383 1
a383 1
    d -= 1 until jd2 = type.exist3?(y, m, d, ns?)
d407 1
a407 1
  def hash() @@rjd.hash end
d409 1
a409 1
  def inspect() format('#<%s: %s,%s,%s>', type, @@rjd, @@of, @@sg) end
d412 15
a426 2
  def _dump(limit) Marshal.dump([@@rjd, @@of, @@sg], -1) end
  def self._load(str) new0(*Marshal.load(str)) end
d432 1
a432 1
  def self.existt? (h, min, s)
d442 3
a444 5
  class << self; alias_method :valid_time?, :existt? end

  def self.new1(jd=0, h=0, min=0, s=0, of=0, sg=ITALY)
    unless (jd = exist1?(jd, sg)) and
	   (fr = existt?(h, min, s))
d447 1
a447 1
    new0(jd_to_rjd(jd, fr, of), of, sg)
d450 3
a452 5
  class << self; alias_method :jd, :new1 end

  def self.new2(y=-4712, d=1, h=0, min=0, s=0, of=0, sg=ITALY)
    unless (jd = exist2?(y, d, sg)) and
	   (fr = existt?(h, min, s))
d455 1
a455 1
    new0(jd_to_rjd(jd, fr, of), of, sg)
d458 3
a460 5
  class << self; alias_method :ordinal, :new2 end

  def self.new3(y=-4712, m=1, d=1, h=0, min=0, s=0, of=0, sg=ITALY)
    unless (jd = exist3?(y, m, d, sg)) and
	   (fr = existt?(h, min, s))
d463 1
a463 1
    new0(jd_to_rjd(jd, fr, of), of, sg)
d466 1
a466 2
  class << self; alias_method :new, :new3 end
  class << self; alias_method :civil, :new3 end
d468 3
a470 3
  def self.neww(y=1582, w=41, d=5, h=0, min=0, s=0, of=0, sg=ITALY)
    unless (jd = existw?(y, w, d, sg)) and
	   (fr = existt?(h, min, s))
d473 1
a473 1
    new0(jd_to_rjd(jd, fr, of), of, sg)
a475 2
  class << self; alias_method :commercial, :neww end

d487 1
a487 1
      new3(y, m, d, h, min, s, of.to_r/86400, sg)
d513 29
a541 1
    new0(jd_to_rjd(jd, fr, of), of, sg)
d544 24
a567 2
  public :hour, :min, :sec, :sec_fraction, :zone,
    :of, :newof, :offset, :new_offset
@


1.9
log
@* parse.y (arg): "||=" should not warn for uninitialized instance
  variables.

* eval.c (rb_eval): ditto.

* eval.c (eval): preserve and restore ruby_cref as well.
@
text
@d1 5
a5 2
# date2.rb: Written by Tadayoshi Funaba 1998-2001
# $Id: date2.rb,v 1.23 2001-01-18 12:09:47+09 tadf Exp $
a10 2
  IDENT = 2

d16 5
d26 4
a29 7
  class << self

    def os? (jd, sg)
      case sg
      when Numeric; jd < sg
      else;         not sg
      end
d31 1
d33 1
a33 1
    def ns? (jd, sg) not os?(jd, sg) end
d35 12
a46 14
    def civil_to_jd(y, m, d, sg=GREGORIAN)
      if m <= 2
	y -= 1
	m += 12
      end
      a = (y / 100.0).floor
      b = 2 - a + (a / 4.0).floor
      jd = (365.25 * (y + 4716)).floor +
	(30.6001 * (m + 1)).floor +
	d + b - 1524
      if os?(jd, sg)
	jd -= b
      end
      jd
d48 2
d51 18
a68 20
    def jd_to_civil(jd, sg=GREGORIAN)
      if os?(jd, sg)
	a = jd
      else
	x = ((jd - 1867216.25) / 36524.25).floor
	a = jd + 1 + x - (x / 4.0).floor
      end
      b = a + 1524
      c = ((b - 122.1) / 365.25).floor
      d = (365.25 * c).floor
      e = ((b - d) / 30.6001).floor
      dom = b - d - (30.6001 * e).floor
      if e <= 13
	m = e - 1
	y = c - 4716
      else
	m = e - 13
	y = c - 4715
      end
      return y, m, dom
d70 2
d73 3
a75 3
    def ordinal_to_jd(y, d, sg=GREGORIAN)
      civil_to_jd(y, 1, d, sg)
    end
d77 5
a81 5
    def jd_to_ordinal(jd, sg=GREGORIAN)
      y = jd_to_civil(jd, sg)[0]
      doy = jd - civil_to_jd(y - 1, 12, 31, ns?(jd, sg))
      return y, doy
    end
d83 9
a91 9
    def jd_to_commercial(jd, sg=GREGORIAN)
      ns = ns?(jd, sg)
      a = jd_to_civil(jd - 3, ns)[0]
      y = if jd >= commercial_to_jd(a + 1, 1, 1, ns) then a + 1 else a end
      w = 1 + (jd - commercial_to_jd(y, 1, 1, ns)) / 7
      d = (jd + 1) % 7
      if d.zero? then d = 7 end
      return y, w, d
    end
d93 6
a98 6
    def commercial_to_jd(y, w, d, ns=GREGORIAN)
      jd = civil_to_jd(y, 1, 4, ns)
      (jd - (((jd - 1) + 1) % 7)) +
	7 * (w - 1) +
	(d - 1)
    end
d100 5
a104 5
    def clfloor(x, y=1)
      q, r = x.divmod(y)
      q = q.to_i
      return q, r
    end
d106 2
a107 2
    def rjd_to_jd(rjd) clfloor(rjd + 0.5) end
    def jd_to_rjd(jd, fr) jd + fr - 0.5 end
d109 6
a114 8
    def mjd_to_jd(mjd) mjd + 2400000.5 end
    def jd_to_mjd(jd) jd - 2400000.5 end
    def tjd_to_jd(tjd) tjd + 2440000.5 end
    def jd_to_tjd(jd) jd - 2440000.5 end
    def tjd2_to_jd(cycle, tjd) tjd_to_jd(cycle * 10000 + tjd) end
    def jd_to_tjd2(jd) clfloor(jd_to_tjd(jd), 10000) end
    def ld_to_jd(ld) ld + 2299160 end
    def jd_to_ld(jd) jd - 2299160 end
d116 3
a118 1
    def jd_to_wday(jd) (jd + 1) % 7 end
d120 25
a144 2
    def julian_leap? (y) y % 4 == 0 end
    def gregorian_leap? (y) y % 4 == 0 and y % 100 != 0 or y % 400 == 0 end
d146 1
a146 1
    alias_method :leap?, :gregorian_leap?
d148 13
a160 1
    alias_method :new0, :new
d162 1
a162 1
    def new1(jd=0, sg=ITALY) new0(jd, sg) end
d164 3
a166 16
    def exist3? (y, m, d, sg=ITALY)
      if m < 0
	m += 13
      end
      if d < 0
	ny, nm = clfloor(y * 12 + m, 12)
	nm,    = clfloor(nm + 1, 1)
	jd = civil_to_jd(ny, nm, d + 1, sg)
	ns = ns?(jd, sg)
	return unless [y, m] == jd_to_civil(jd, sg)[0..1]
	return unless [ny, nm, 1] == jd_to_civil(jd - d, ns)
      else
	jd = civil_to_jd(y, m, d, sg)
	return unless [y, m, d] == jd_to_civil(jd, sg)
      end
      jd
d168 2
d171 1
a171 1
    alias_method :exist?, :exist3?
d173 14
a186 5
    def new3(y=-4712, m=1, d=1, sg=ITALY)
      unless jd = exist3?(y, m, d, sg)
	raise ArgumentError, 'invalid date'
      end
      new0(jd, sg)
d188 2
d191 2
a192 1
    alias_method :new, :new3
d194 3
a196 12
    def exist2? (y, d, sg=ITALY)
      if d < 0
	ny, = clfloor(y + 1, 1)
	jd = ordinal_to_jd(ny, d + 1, sg)
	ns = ns?(jd, sg)
	return unless [y] == jd_to_ordinal(jd, sg)[0..0]
	return unless [ny, 1] == jd_to_ordinal(jd - d, ns)
      else
	jd = ordinal_to_jd(y, d, sg)
	return unless [y, d] == jd_to_ordinal(jd, sg)
      end
      jd
d198 2
d201 21
a221 5
    def new2(y=-4712, d=1, sg=ITALY)
      unless jd = exist2?(y, d, sg)
	raise ArgumentError, 'invalid date'
      end
      new0(jd, sg)
d223 4
d228 7
a234 11
    def existw? (y, w, d, sg=ITALY)
      if d < 0
	d += 8
      end
      if w < 0
	w = jd_to_commercial(commercial_to_jd(y + 1, 1, 1) + w * 7)[1]
      end
      jd = commercial_to_jd(y, w, d)
      return unless ns?(jd, sg)
      return unless [y, w, d] == jd_to_commercial(jd)
      jd
d236 8
d245 9
a253 6
    def neww(y=1582, w=41, d=5, sg=ITALY)
      unless jd = existw?(y, w, d, sg)
	raise ArgumentError, 'invalid date'
      end
      new0(jd, sg)
    end
d255 1
a255 3
    def today(sg=ITALY)
      new0(civil_to_jd(*(Time.now.to_a[3..5].reverse << sg)), sg)
    end
d273 1
a273 1
  def initialize(rjd=0, sg=ITALY) @@rjd, @@sg = rjd, sg end
d282 2
a283 2
  def jd() type.rjd_to_jd(@@rjd)[0] end
  def fr1() type.rjd_to_jd(@@rjd)[1] end
d289 1
a289 1
  once :jd, :fr1, :mjd, :tjd, :tjd2, :ld
d301 1
d304 3
d308 17
a324 1
  def mday() civil[2] end
d326 1
a326 1
  alias_method :day, :mday
d349 4
a352 1
  def newsg(sg=type::ITALY) type.new0(@@rjd, sg) end
d359 8
d369 1
a369 1
    when Numeric; return type.new0(@@rjd + n, @@sg)
d376 1
a376 1
    when Numeric; return type.new0(@@rjd - x, @@sg)
d426 1
a426 1
  def hash() type.clfloor(@@rjd)[0] end
d428 2
a429 2
  def inspect() format('#<%s: %s,%s>', type, @@rjd, @@sg) end
  def to_s() format('%.4d-%02d-%02d', year, mon, mday) end
d431 1
a431 1
  def _dump(limit) Marshal.dump([@@rjd, @@sg], -1) end
d433 100
@


1.8
log
@forgot some checkins.
@
text
@d205 1
a205 4
	    unless defined? @@__#{id.to_i}__
	      @@__#{id.to_i}__ = __#{id.to_i}__(*args, &block)
	    end
	    @@__#{id.to_i}__
@


1.7
log
@* io.c (rb_io_s_read): new method to call IO#read from
  pathname.  In addition, it accepts third optional argument to
  specify starting point.
@
text
@d205 4
a208 1
	    (@@__#{id.to_i}__ ||= [__#{id.to_i}__(*args, &block)])[0]
@


1.6
log
@001225
@
text
@d1 2
a2 2
# date.rb: Written by Tadayoshi Funaba 1998-2000
# $Id: date.rb,v 1.22 2000-07-16 10:23:40+09 tadf Exp $
d131 8
a138 7
	nm,    = clfloor(m + 1, 1)
	la = nil
	31.downto 1 do |z|
	  break if la = exist3?(y, m, z, sg)
	end
	ns = ns?(la, sg)
	d = jd_to_civil(civil_to_jd(ny, nm, 1, ns) + d, ns)[-1]
a139 2
      jd = civil_to_jd(y, m, d, sg)
      return unless [y, m, d] == jd_to_civil(jd, sg)
d156 8
a163 7
	ny = y + 1
	la = nil
	366.downto 1 do |z|
	  break if la = exist2?(y, z, sg)
	end
	ns = ns?(la, sg)
	d = jd_to_ordinal(ordinal_to_jd(ny, 1, ns) + d, ns)[-1]
a164 2
      jd = ordinal_to_jd(y, d, sg)
      return unless [y, d] == jd_to_ordinal(jd, sg)
@


1.6.2.1
log
@* gc.c (rb_gc_call_finalizer_at_exit): should finalize objects in
  deferred_final_list too.
@
text
@d1 2
a2 2
# date2.rb: Written by Tadayoshi Funaba 1998-2001
# $Id: date2.rb,v 1.23 2001-01-18 12:09:47+09 tadf Exp $
d131 7
a137 8
	nm,    = clfloor(nm + 1, 1)
	jd = civil_to_jd(ny, nm, d + 1, sg)
	ns = ns?(jd, sg)
	return unless [y, m] == jd_to_civil(jd, sg)[0..1]
	return unless [ny, nm, 1] == jd_to_civil(jd - d, ns)
      else
	jd = civil_to_jd(y, m, d, sg)
	return unless [y, m, d] == jd_to_civil(jd, sg)
d139 2
d157 7
a163 8
	ny, = clfloor(y + 1, 1)
	jd = ordinal_to_jd(ny, d + 1, sg)
	ns = ns?(jd, sg)
	return unless [y] == jd_to_ordinal(jd, sg)[0..0]
	return unless [ny, 1] == jd_to_ordinal(jd - d, ns)
      else
	jd = ordinal_to_jd(y, d, sg)
	return unless [y, d] == jd_to_ordinal(jd, sg)
d165 2
@


1.5
log
@matz
@
text
@d205 1
@


1.4
log
@matz - date/date2 integration
@
text
@d1 2
a2 2
# date2.rb: Written by Tadayoshi Funaba 1998-2000
# $Id: date2.rb,v 1.22 2000-07-16 10:23:40+09 tadf Exp $
@


1.3
log
@matz
@
text
@d1 2
a2 15
#
#               Date.rb - 
#                       $Release Version: $
#                       $Revision: 1.2 $
#                       $Date: 2000/07/06 07:21:23 $
#                       by Yasuo OHBA(SHL Japan Inc. Technology Dept.)
#
# --
#
#    September 1752
#  S  M Tu  W Th  F  S
#        1  2 14 15 16
# 17 18 19 20 21 22 23
# 24 25 26 27 28 29 30
#       
d5 1
d7 19
a25 25
  
  Weektag = [
    "Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"
  ]

  Monthtag = [
    "January","February","March","April", "May", "June","July",
    "August", "September", "October", "November", "December"
  ]

  Monthtab = {
    "jan"=>1, "feb"=>2, "mar"=>3, "apr"=>4, "may"=>5, "jun"=>6,
    "jul"=>7, "aug"=>8, "sep"=>9, "oct"=>10, "nov"=>11, "dec"=>12
  }

  def initialize(y = 1, m = 1, d = 1)
    if y.kind_of?(String)
      case y
      when /(\d\d\d\d)-?(?:(\d\d)-?(\d\d)?)?/
	@@year = $1.to_i
	@@month = if $2 then $2.to_i else 1 end
	@@day = if $3 then $3.to_i else 1 end
      else
	require 'parsedate'
	@@year, @@month, @@day = ParseDate.parsedate(y)
a26 10
    else
      if m.kind_of?(String)
        m = Monthtab[m.downcase]
        if m.nil?
          raise ArgumentError, "Wrong argument. (month)"
        end
      end
      @@year = y.to_i
      @@month = m.to_i
      @@day = d.to_i
a27 22
    _check_date
    return self
  end
  
  def year
    return @@year
  end
  
  def month
    return @@month
  end
  alias mon month
  
  def day
    return @@day
  end
  alias mday day
  
  def period
    return Date.period!(@@year, @@month, @@day)
  end
  protected :period
d29 1
a29 3
  def jd
    return period + 1721423
  end
d31 15
a45 3
  def mjd
    return jd - 2400000.5
  end
d47 21
a67 3
  def to_s
    format("%.3s, %.3s %2d %4d", name_of_week, name_of_month, @@day, @@year)
  end
d69 3
a71 3
  def inspect
    to_s
  end
d73 5
a77 4
  def wday
    return (period + 5) % 7
  end
  alias day_of_week wday
d79 9
a87 3
  def yday
    return period - Date.new(@@year-1,12,31).period
  end
d89 5
a93 15
  def name_of_week
    return Weektag[self.day_of_week]
  end
  
  def name_of_month
    return Monthtag[@@month-1]
  end
  
  def +(o)
    if o.kind_of?(Numeric)
      d = Integer(self.period + o)
    elsif o.kind_of?(Date)
      d = self.period + o.period
    else
      raise TypeError, "Illegal type. (Integer or Date)"
d95 5
a99 2
    if d <= 0
      raise ArgumentError, "argument out of range. (self > other)"
d101 41
a141 10
    return Date.at(d)
  end
  
  def -(o)
    if o.kind_of?(Numeric)
      d = Integer(self.period - o)
    elsif o.kind_of?(Date)
      return Integer(self.period - o.period)
    else
      raise TypeError, "Illegal type. (Integer or Date)"
d143 8
a150 2
    if d <= 0
      raise ArgumentError, "argument out of range. (self > other)"
d152 16
a167 10
    return Date.at(d)
  end
  
  def <=>(o)
    if o.kind_of?(Integer)
      d = o
    elsif o.kind_of?(Date)
      d = o.period
    else
      raise TypeError, "Illegal type. (Integer or Date)"
a168 2
    return self.period <=> d
  end
d170 6
a175 12
  def eql?(o)
    self == o
  end
  
  def hash
    return @@year ^ @@month ^ @@day
  end
  
  def leap?
    Date.leapyear(@@year) != 1
  end
  alias leapyear? leap?
d177 11
a187 3
  def _check_date
    if @@year == nil or @@month == nil or @@day == nil
      raise ArgumentError, "argument contains nil"
d189 4
a192 7
    m = Date.daylist(@@year)
    if @@month < 1 || @@month > 12
      raise ArgumentError, "argument(month) out of range."
    end
    if @@year == 1752 && @@month == 9
      if @@day >= 3 && @@day <= 13
        raise ArgumentError, "argument(1752/09/3-13) out of range."
d194 1
a194 3
      d = 30
    else
      d = m[@@month]
d196 3
a198 2
    if @@day < 1 || @@day > d
      raise ArgumentError, "argument(day) out of range."
a199 2
    return self
  end
d201 8
a208 20
  def << (n)
    self >> -n
  end
  
  def >> (n)
    y = @@year
    m = @@month-1
    d = @@day

    m += n
    y += m/12
    m = m%12
    m += 1

    if y == 1752 && m == 9 && d >= 3 && d <= 13
      d = 2
    else
      lasts = Date.daylist(y)
      if d > lasts[m]
	d = lasts[m]
d211 3
a213 1
    Date.new(y,m,d)
d215 52
a266 7
  
  private :_check_date
end

def Date.at(d)
  if d.kind_of? Time
    return Date.new(d.year, d.mon, d.mday)
d268 16
a283 2
  if d.kind_of? Date
    return Date.at(d.period)
d285 7
a291 7
  mm = 1
  yy = (d / 366.0).to_i
  if yy != 0
    dd = d - (Date.period!(yy, 1, 1) - 1)
  else
    dd = d
    yy = 1
d293 5
a297 9
  dl = Date.daylist(yy)
  while dd > dl[mm]
    if dd > dl[0]
      dd -= dl[0]
      yy += 1
      dl = Date.daylist(yy)
    else
      dd -= dl[mm]
      mm += 1
d299 1
d301 7
a307 2
  if yy == 1752 && mm == 9 && dd >= 3 && dd <= 19
    dd += (14 - 3)              # 1752/09/03-19 -> 1752/09/14-30
d309 7
a315 18
  
  return Date.new(yy, mm, dd)
end

def Date.new3(year,mon=1,day=1)
  Date.new(year,mon,day)
end

def Date.today
  Date.new(*Time.now.to_a[3,3].reverse!)
end

## private class methods - do not call
def Date.period!(y, m, d)
  p = d
  dl = Date.daylist(y)
  for mm in 1..(m - 1)
    p += dl[mm]
d317 11
a327 7
  p += (y - 1) * 365 + ((y - 1) / 4.0).to_i
  if y > 1752
    p -= ((y - 1) / 100.0).to_i
    p += ((y - 1) / 400.0).to_i
    p += 2
  elsif y == 1752 && m == 9 && d >= 14 && d <= 30
    p -= (14 - 3)
a328 2
  return p
end
d330 15
a344 14
def Date.leapyear(yy)
  return ((Date.jan1!(yy + 1) + 7 - Date.jan1!(yy)) % 7)
end

def Date.daylist(yy)
  case (Date.leapyear(yy))
  when 1 # non-leapyear
    return [365, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  when 2 # leapyear
    return [366, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  else   # 1752
    return [355, 31, 29, 31, 30, 31, 30, 31, 31, 19, 31, 30, 31]
  end
end
a345 10
def Date.jan1!(y)
  d = 4 + y + (y + 3) / 4
  if y > 1800
    d -= (y - 1701) / 100
    d += (y - 1601) / 400
  end
  if y > 1752
    d += 3
  end
  return (d % 7)
@


1.2
log
@matz
@
text
@d4 2
a5 2
#                       $Revision: 1.1.1.2 $
#                       $Date: 1999/01/20 04:59:35 $
a170 1
      return nil
a174 1
        return nil
a181 1
      return nil
a298 1

@


1.1
log
@Initial revision
@
text
@d4 2
a5 2
#                       $Revision: 1.2 $
#                       $Date: 1997/02/14 11:05:29 $
d20 14
d35 10
a44 4
    if y.kind_of?(String) && y.size == 8
      @@year = y[0,4].to_i
      @@month = y[4,2].to_i
      @@day = y[6,2].to_i
d47 1
a47 2
        ml = {"jan"=>1, "feb"=>2, "mar"=>3, "apr"=>4, "may"=>5, "jun"=>6, "jul"=>7, "aug"=>8, "sep"=>9, "oct"=>10, "nov"=>11, "dec"=>12}
        m = ml[m.downcase]
d67 1
d72 1
d77 25
a101 12
  
  def day_of_week
    dl = Date.daylist(@@year)
    d = Date.jan1!(@@year)
    for m in 1..(@@month - 1)
      d += dl[m]
    end
    d += @@day - 1
    if @@year == 1752 && @@month == 9 && @@day >= 14
      d -= (14 - 3)
    end
    return (d % 7)
d103 1
a103 2
  
  Weektag = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
d108 4
d120 3
d159 2
a160 6
  def leapyear?
    if Date.leapyear(@@year) == 1
      return FALSE
    else
      return TRUE
    end
d162 1
d165 3
d188 25
d219 1
a219 1
    return Date.new(1900+d.year, d.mon+1, d.mday)
d250 9
d266 4
a269 4
  if (y - 1) > 1752
    p -= ((y - 1 - 1752) / 100.0).to_i
    p += ((y - 1 - 1752) / 400.0).to_i
    p -= (14 - 3)
d302 1
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@d4 2
a5 2
#                       $Revision: 1.1.1.1.4.5 $
#                       $Date: 1998/03/03 02:39:34 $
a19 14
  Weektag = [
    "Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"
  ]

  Monthtag = [
    "January","February","March","April", "May", "June","July",
    "August", "September", "October", "November", "December"
  ]

  Monthtab = {
    "jan"=>1, "feb"=>2, "mar"=>3, "apr"=>4, "may"=>5, "jun"=>6,
    "jul"=>7, "aug"=>8, "sep"=>9, "oct"=>10, "nov"=>11, "dec"=>12
  }

d21 4
a24 10
    if y.kind_of?(String)
      case y
      when /(\d\d\d\d)-?(?:(\d\d)-?(\d\d)?)?/
	@@year = $1.to_i
	@@month = if $2 then $2.to_i else 1 end
	@@day = if $3 then $3.to_i else 1 end
      else
	require 'parsedate'
	@@year, @@month, @@day = ParseDate.parsedate(y)
      end
d27 2
a28 1
        m = Monthtab[m.downcase]
d56 1
a56 17

  def jd
    return period + 1721423
  end

  def mjd
    return jd - 2400000.5
  end

  def to_s
    format("%.3s, %.3s %2d %4d", name_of_week, name_of_month, @@day, @@year)
  end

  def inspect
    to_s
  end

d58 10
a67 1
    return (period + 5) % 7
d70 1
a74 4
  def name_of_month
    return Monthtag[@@month-1]
  end
  
a82 3
    if d <= 0
      raise ArgumentError, "argument out of range. (self > other)"
    end
d120 5
a124 1
    Date.leapyear(@@year) != 1
a127 3
    if @@year == nil or @@month == nil or @@day == nil
      raise ArgumentError, "argument contains nil"
    end
d154 1
a154 1
    return Date.new(d.year, d.mon, d.mday)
d192 4
a195 4
  if y > 1752
    p -= ((y - 1) / 100.0).to_i
    p += ((y - 1) / 400.0).to_i
    p += 2
@


1.1.1.1.4.1
log
@*** empty log message ***
@
text
@d4 2
a5 2
#                       $Revision: 1.1.1.1 $
#                       $Date: 1998/01/16 04:05:49 $
@


1.1.1.1.4.2
log
@__FILE__,__LINE__
@
text
@d4 2
a5 2
#                       $Revision: 1.1.1.1.4.1 $
#                       $Date: 1998/01/16 12:36:04 $
a19 14
  Weektag = [
    "Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"
  ]

  Monthtag = [
    "January","February","March","April", "May", "June","July",
    "August", "September", "October", "November", "December"
  ]

  Monthtab = {
    "jan"=>1, "feb"=>2, "mar"=>3, "apr"=>4, "may"=>5, "jun"=>6,
    "jul"=>7, "aug"=>8, "sep"=>9, "oct"=>10, "nov"=>11, "dec"=>12
  }

d27 2
a28 1
        m = Monthtab[m.downcase]
d70 1
a72 4
  end
  
  def name_of_month
    return Monthtag[@@month-1]
@


1.1.1.1.4.3
log
@*** empty log message ***
@
text
@d4 2
a5 2
#                       $Revision: 1.1.1.1.4.2 $
#                       $Date: 1998/02/02 04:49:13 $
d35 4
a38 10
    if y.kind_of?(String)
      case y
      when /(\d\d\d\d)-?(?:(\d\d)-?(\d\d)?)?/
	@@year = $1.to_i
	@@month = if $2 then $2.to_i else 1 end
	@@day = if $3 then $3.to_i else 1 end
      else
	require 'parsedate'
	@@year, @@month, @@day = ParseDate.parsedate(y)
      end
d69 1
a69 17

  def jd
    return period + 1721423
  end

  def mjd
    return jd - 2400000.5
  end

  def to_s
    format("%.3s, %.3s %2d %4d", name_of_week, name_of_month, @@day, @@year)
  end

  def inspect
    to_s
  end

d71 10
a80 1
    return (period + 5) % 7
a143 3
    if @@year == nil or @@month == nil or @@day == nil
      raise ArgumentError, "argument contains nil"
    end
@


1.1.1.1.4.4
log
@1.1b8pre1
@
text
@d4 2
a5 2
#                       $Revision: 1.1.1.1.4.3 $
#                       $Date: 1998/02/03 10:02:57 $
d186 1
a186 1
    return Date.new(d.year, d.mon, d.mday)
@


1.1.1.1.4.5
log
@*** empty log message ***
@
text
@d4 2
a5 2
#                       $Revision: 1.1.1.1.4.4 $
#                       $Date: 1998/02/18 01:56:47 $
a111 3
    if d <= 0
      raise ArgumentError, "argument out of range. (self > other)"
    end
d149 5
a153 1
    Date.leapyear(@@year) != 1
d224 4
a227 4
  if y > 1752
    p -= ((y - 1) / 100.0).to_i
    p += ((y - 1) / 400.0).to_i
    p += 2
@
