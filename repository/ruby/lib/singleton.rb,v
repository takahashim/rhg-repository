head	1.17;
access;
symbols
	v1_6_7:1.6
	v1_6_6:1.6
	v1_6_5:1.6
	v1_6_4:1.6
	v1_7_1:1.7
	v1_6_4_preview4:1.6
	v1_6_4_preview3:1.6
	v1_6_4_preview2:1.6
	v1_6_4_preview1:1.6
	v1_6_3:1.6
	ruby_m17n:1.6.0.4
	ruby_1_6:1.6.0.2
	v1_6_2:1.6
	v1_6_1:1.5
	v1_6_0:1.5
	v1_4_6:1.2.2.2
	v1_4_5:1.2.2.2
	v1_4_4:1.2.2.2
	ruby_1_4_3:1.2.2.1
	ruby1_4_3:1.2.2.1
	v1_4_3:1.2.2.1
	v1_5_0:1.4
	ruby_1_4_3_pre1:1.2.2.1
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.1
	v1_3_6_repack:1.1.1.1
	v1_3_6:1.1.1.1
	v1_3_5:1.1.1.1
	v1_2_6repack:1.1.2.1
	v1_3_4_990625:1.1.1.1
	v1_3_4_990624:1.1.1.1
	v1_2_6:1.1.2.1
	v1_3_4_990611:1.1.1.1
	v1_3_4_990531:1.1.1.1
	v1_3_3_990518:1.1.1.1
	v1_3_3_990513:1.1.1.1
	v1_3_3_990507:1.1.1.1
	v1_2_5:1.1.2.1
	v1_2_4:1.1.2.1
	v1_3_1_990225:1.1.1.1
	v1_3_1_990224:1.1.1.1
	v1_3_1_990215:1.1.1.1
	v1_3_1_990212:1.1.1.1
	v1_3_1_990210:1.1.1.1
	v1_3_1_:1.1.1.1
	v1_3_1_990209:1.1.1.1
	v1_3_1_990205:1.1.1.1
	v1_3_1_990203:1.1.1.1
	v1_3_1_990201:1.1.1.1
	v1_3_1"_990201:1.1.1.1
	v1_3_1_990128:1.1.1.1
	v1_3_1_990127:1.1.1.1
	v1_3_1_990126:1.1.1.1
	ruby_1_3:1.1.1.1.0.2
	v1_2_2:1.1.2.1
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_2_2_pr1:1.1.2.1
	v1_2_1repack:1.1.2.1
	v1_2_1:1.1.2.1
	v1_2_stable:1.1.2.1
	v1_1d1:1.1.2.1
	v1_1d0:1.1.2.1
	v1_1c9_1:1.1.2.1
	v1_1c9:1.1.2.1
	v1_1c8:1.1.2.1
	v1_1c7:1.1.2.1
	v1_1c6:1.1.2.1
	v1_1d-start:1.1.2.1
	v1_1c5:1.1.2.1
	v1_1dev:1.1.2.1.0.2
	v1_1c4:1.1.2.1
	v1_1c3:1.1.2.1
	v1_1c2:1.1.2.1
	v1_1c1:1.1.2.1
	v1_1c0:1.1.2.1
	v1_1b9_31:1.1.2.1
	v1_1b9_30:1.1.2.1
	v1_1r:1.1.0.2;
locks; strict;
comment	@# @;


1.17
date	2002.10.02.16.45.34;	author nobu;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.13.04.53.37;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.04.07.34.19;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.01.06.03.01;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.29.07.16.07;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.28.08.44.45;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.03.10.07.48;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.28.14.56.22;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.27.10.00.35;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.31.06.24.45;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.06.15.04.52;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.25.06.29.24;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.29.08.05.31;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.11.25.09.03.08;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.11.17.07.30.37;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.17;	author matz;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	98.07.09.08.40.37;	author matz;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	99.01.20.04.59.35;	author matz;	state Exp;
branches;
next	;

1.1.2.1
date	98.07.09.08.40.37;	author matz;	state Exp;
branches;
next	;

1.2.2.1
date	99.11.17.07.29.53;	author matz;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.03.02.03.51.50;	author matz;	state Exp;
branches;
next	;


desc
@@


1.17
log
@use Object#class instead of deprecated Object#type.
@
text
@# The Singleton module implements the Singleton pattern.
#
# Usage:
#    class Klass
#       include Singleton
#       # ...
#    end
#
# *  this ensures that only one instance of Klass lets call it
#    ``the instance'' can be created.
#
#    a,b  = Klass.instance, Klass.instance
#    a == b   # => true
#    a.new     #  NoMethodError - new is private ...
#
# *  ``The instance'' is created at instanciation time, in other words
#    the first call of Klass.instance(), thus
#
#    class OtherKlass
#        include Singleton
#        # ...
#    end
#    ObjectSpace.each_object(OtherKlass){} # => 0.
#
# *  This behavior is preserved under inheritance and cloning.
#
#
# This is achieved by marking
# *  Klass.new and Klass.allocate - as private
# *  removing #clone and #dup and modifying 
# *  Klass.inherited(sub_klass) and Klass.clone()  - 
#    to ensure that the Singleton pattern is properly
#    inherited and cloned.
#
# In addition Klass is providing the additional class methods
# *  Klass.instance()  -  returning ``the instance''. After a successful
#    self modifying instanciating first call the method body is a simple
#           def Klass.instance()
#               return @@__instance__
#           end
# *  Klass._load(str)  -  calls instance()
# *  Klass._instanciate?()  -  returning ``the instance'' or nil
#    This hook method puts a second (or nth) thread calling
#    Klass.instance() on a waiting loop. The return value signifies
#    the successful completion or premature termination of the
#    first, or more generally, current instanciating thread.
#
# The sole instance method of Singleton is
# *  _dump(depth) - returning the empty string.  Marshalling strips
#    by default all state information, e.g. instance variables and taint
#    state, from ``the instance''.  Providing custom _load(str) and
#    _dump(depth) hooks allows the (partially) resurrections of a
#    previous state of ``the instance''.

module Singleton
    private 
    #  default marshalling strategy
    def _dump(depth=-1) '' end
    
    class << self
        #  extending an object with Singleton is a bad idea
        undef_method :extend_object
        private
        def append_features(mod)
            #  This catches ill advisted inclusions of Singleton in
            #  singletons types (sounds like an oxymoron) and 
            #  helps out people counting on transitive mixins
            unless mod.instance_of?(Class)
                raise TypeError, "Inclusion of the OO-Singleton module in module #{mod}"
            end 
            unless (class << mod; self end) <= (class << Object; self end)
                raise TypeError, "Inclusion of the OO-Singleton module in singleton type"
            end
            super
        end
        def included(klass)
            #  remove build in copying methods
            klass.class_eval do 
	      define_method(:clone) {raise TypeError, "can't clone singleton #{self.class}"}
            end
            
            #  initialize the ``klass instance variable'' @@__instance__ to nil
            klass.instance_eval do @@__instance__ = nil end
            class << klass
                #  a main point of the whole exercise - make
                #  new and allocate private
                private  :new, :allocate
                
                #  declare the self modifying klass#instance method
                define_method(:instance, Singleton::FirstInstanceCall) 
                 
                #  simple waiting loop hook - should do in most cases
                #  note the pre/post-conditions of a thread-critical state
                private   
                def _instanciate?()
                    while false.equal?(@@__instance__)
                        Thread.critical = false
                        sleep(0.08)  
                        Thread.critical = true
                    end
                    @@__instance__
                end
                
                #  default Marshalling strategy
                def _load(str) instance end    
                 
               #  ensure that the Singleton pattern is properly inherited   
                def inherited(sub_klass)
                    super
                    sub_klass.instance_eval do @@__instance__ = nil end
                    class << sub_klass
                        define_method(:instance, Singleton::FirstInstanceCall) 
                    end
                end 
                
                public
                #  properly clone the Singleton pattern. Question - Did
                #  you know that duping doesn't copy class methods?
                def clone
                    res = super
                    res.instance_eval do @@__instance__ = nil end
                    class << res
                        define_method(:instance, Singleton::FirstInstanceCall)
                    end
                    res
                end
            end   #  of << klass
        end       #  of included
    end           #  of << Singleton
    
    FirstInstanceCall = proc do
        #  @@__instance__ takes on one of the following values
        #  * nil     -  before and after a failed creation
        #  * false  -  during creation
        #  * sub_class instance  -  after a successful creation
        #  the form makes up for the lack of returns in progs
        Thread.critical = true
        if  @@__instance__.nil?
            @@__instance__  = false
            Thread.critical = false
            begin
                @@__instance__ = new
            ensure
                if @@__instance__
                    def self.instance() @@__instance__ end
                else
                    @@__instance__ = nil #  failed instance creation
                end
            end
        elsif  _instanciate?()
            Thread.critical = false    
        else
            @@__instance__  = false
            Thread.critical = false
            begin
                @@__instance__ = new
            ensure
                if @@__instance__
                    def self.instance() @@__instance__ end
                else
                    @@__instance__ = nil
                end
            end
        end
        @@__instance__ 
    end
end




if __FILE__ == $0

def num_of_instances(klass)
    "#{ObjectSpace.each_object(klass){}} #{klass} instance(s)"
end 

# The basic and most important example.  The latter examples demonstrate
# advanced features that have no relevance for the general usage

class SomeSingletonClass
    include Singleton
end
puts "There are #{num_of_instances(SomeSingletonClass)}" 

a = SomeSingletonClass.instance
b = SomeSingletonClass.instance # a and b are same object
puts "basic test is #{a == b}"

begin
    SomeSingletonClass.new
rescue  NoMethodError => mes
    puts mes
end



puts "\nThreaded example with exception and customized #_instanciate?() hook"; p
Thread.abort_on_exception = false

class Ups < SomeSingletonClass
    def initialize
        self.class.__sleep
        puts "initialize called by thread ##{Thread.current[:i]}"
    end
    class << self
        def _instanciate?
            @@enter.push Thread.current[:i]
            while false.equal?(@@__instance__)
                Thread.critical = false
                sleep 0.04 
                Thread.critical = true
            end
            @@leave.push Thread.current[:i]
            @@__instance__
        end
        def __sleep
            sleep(rand(0.08))
        end 
        def allocate
            __sleep
            def self.allocate; __sleep; super() end
            raise  "boom - allocation in thread ##{Thread.current[:i]} aborted"
        end
        def instanciate_all
            @@enter = []
            @@leave = []
            1.upto(9) do |i|  
                Thread.new do 
                    begin
                        Thread.current[:i] = i
                        __sleep
                        instance
                    rescue RuntimeError => mes
                        puts mes
                    end
                end
            end
            puts "Before there were #{num_of_instances(self)}"
            sleep 5
            puts "Now there is #{num_of_instances(self)}"
            puts "#{@@enter.join '; '} was the order of threads entering the waiting loop"
            puts "#{@@leave.join '; '} was the order of threads leaving the waiting loop"
        end
    end
end

Ups.instanciate_all
#  results in message like
#  Before there were 0 Ups instances
#  boom - allocation in thread #8 aborted
#  initialize called by thread #3
#  Now there is 1 Ups instance
#  2; 3; 6; 1; 7; 5; 9; 4 was the order of threads entering the waiting loop
#  3; 2; 1; 7; 6; 5; 4; 9 was the order of threads leaving the waiting loop

puts "\nLets see if class level cloning really works"
Yup = Ups.clone
def Yup.allocate
    __sleep
    def self.allocate; __sleep; super() end
    raise  "boom - allocation in thread ##{Thread.current[:i]} aborted"
end
Yup.instanciate_all


puts "\n","Customized marshalling"
class A
    include Singleton
    attr_accessor :persist, :die
    def _dump(depth)
        # this strips the @@die information from the instance
        Marshal.dump(@@persist,depth)
    end
end
def A._load(str)
    instance.persist = Marshal.load(str)
    instance
end

a = A.instance
a.persist = ["persist"]
a.die = "die"
a.taint

stored_state = Marshal.dump(a)
# change state
a.persist = nil
a.die = nil
b = Marshal.load(stored_state)
p a == b  #  => true
p a.persist  #  => ["persist"]
p a.die      #  => nil

puts "\n\nSingleton with overridden default #inherited() hook"
class Up
    def Up.inherited(sub_klass)
        puts "#{sub_klass} subclasses #{self}"
    end
end


class Middle < Up
    undef_method :dup
    include Singleton
end
class Down < Middle; end

puts  "basic test is #{Down.instance == Down.instance}"  


puts "\n","Various exceptions"

begin
    module AModule
        include Singleton
    end
rescue TypeError => mes
    puts mes  #=> Inclusion of the OO-Singleton module in module AModule
end

begin
    class << 'aString'
        include Singleton
    end
rescue TypeError => mes
    puts mes  # => Inclusion of the OO-Singleton module in singleton type
end

begin
    'aString'.extend Singleton
rescue NoMethodError => mes
    puts mes  #=> undefined method `extend_object' for Singleton:Module
end

end
@


1.16
log
@ext/exmk.rb.in, lib/singleton.rb: remove nested ""s.
@
text
@d79 1
a79 1
	      define_method(:clone) {raise TypeError, "can't clone singleton #{self.type}"}
d203 1
a203 1
        type.__sleep
@


1.15
log
@* string.c (rb_str_aset): should raise error if an indexing string
  is not found in the receiver.

* sprintf.c (rb_f_sprintf): "%d" should convert objects into
  integers using Integer().

* lib/tempfile.rb (Tempfile::size): added.
@
text
@d242 2
a243 2
            puts "#{@@enter.join "; "} was the order of threads entering the waiting loop"
            puts "#{@@leave.join "; "} was the order of threads leaving the waiting loop"
@


1.14
log
@* file.c (rb_stat_inspect): print dev, rdev in hexadecimal.
@
text
@d68 1
a68 1
            unless mod.instance_of? (Class)
d76 1
a76 1
        def included (klass)
d90 1
a90 1
                define_method (:instance, Singleton::FirstInstanceCall) 
d112 1
a112 1
                        define_method (:instance, Singleton::FirstInstanceCall) 
d123 1
a123 1
                        define_method (:instance, Singleton::FirstInstanceCall)
d218 1
a218 1
            sleep (rand(0.08))
@


1.13
log
@* file.c (rb_stat_rdev_major): added. [new]

* file.c (rb_stat_rdev_minor): added. [new]

* file.c (rb_stat_inspect): print mode in octal.
@
text
@d69 1
a69 1
                raise TypeError.new "Inclusion of the OO-Singleton module in module #{mod}"
d72 1
a72 1
                raise TypeError.new "Inclusion of the OO-Singleton module in singleton type"
d79 1
a79 2
                undef_method(:clone) rescue nil
                undef_method(:dup)   rescue nil
@


1.12
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.

* object.c (Init_Object): remove dup and clone from TrueClass,
  FalseClass, and NilClass.

* array.c (rb_ary_fill): Array#fill takes block to get the value to
  fill.

* string.c (rb_str_to_i): to_i(0) auto-detects base radix.

* array.c (rb_ary_initialize): fill by the block evaluation value
  if block is given.
@
text
@d1 1
a1 1
# The Singleton module implements the Singleton pattern - i.e.
d3 5
a7 4
# class Klass
#    include Singleton
#    # ...
# end
d9 2
a10 2
# *  ensures that only one instance of Klass called ``the instance''
#    can be created.
d16 2
a17 2
# *  ``The instance'' is created at instanciation time - i.e. the first call
#    of Klass.instance().
d23 1
a23 1
#    p "#{ObjectSpace.each_object(OtherKlass) {}}" # => 0
d25 1
a25 1
# *  This behavior is preserved under inheritance.
d28 19
a46 11
# This achieved by marking
# *  Klass.new and Klass.allocate - as private and modifying 
# *  Klass.inherited(sub_klass)     - to ensure
#     that the Singleton pattern is properly inherited.
#
# In addition Klass is provided with the class methods
# *  Klass.instance()  - returning ``the instance''
# *  Klass._load(str)  - returning ``the instance''
# *  Klass._wait()     -  a hook method putting a second (or n-th)
#    thread calling Klass.instance on a waiting loop if the first call
#    to Klass.instance is still in progress.
d49 5
a53 6
# *  _dump(depth) - returning the empty string
#    The default Marshalling strategy is to strip all state information - i.e.
#    instance variables from ``the instance''.  Providing custom
#    _dump(depth) and _load(str) method allows the (partial) resurrection
#    of a previous state of ``the instance'' - see third example.
#
d56 112
a167 58
  def Singleton.included (klass)
    # should this be checked?
    # raise TypeError.new "..."  if klass.type == Module
    klass.module_eval {
      undef_method :clone
      undef_method :dup
    }
    class << klass
      def inherited(sub_klass)
	# @@__instance__ takes on one of the following values
	# * nil    - before (and after a failed) creation
	# * false - during creation
	# * sub_class instance - after a successful creation
	sub_klass.instance_eval { @@__instance__ = nil }
	def sub_klass.instance
	  unless @@__instance__.nil?
	    # is the extra flexiblity having the hook method
	    # _wait() around ever useful?
	    _wait() 
	    # check for instance creation
	    return @@__instance__ if @@__instance__
	  end
	  Thread.critical = true
	  unless @@__instance__
	    @@__instance__  = false
	    Thread.critical = false
	    begin
	      @@__instance__ = new
	    ensure
	      if @@__instance__
		define_method(:instance) {@@__instance__ }
	      else
		# failed instance creation
		@@__instance__ = nil
	      end
	    end
	  else
	    Thread.critical = false
	  end
	  return @@__instance__
	end
      end
      def _load(str)
	instance
      end
      def _wait
	sleep(0.05)  while false.equal?(@@__instance__)
      end
      private  :new, :allocate
      # hook methods are also marked private
      private :_load,:_wait
    end
    klass.inherited klass
  end
  private
  def _dump(depth)
    return ""
  end
d170 3
d175 7
a181 1
#basic example
d185 2
d189 2
a190 1
p a == b # => true
d197 3
a199 1
# threaded example with exception and customized hook #_wait method
a200 3
def num_of_instances(mod)
    "#{ObjectSpace.each_object(mod){}} #{mod} instance"
end 
d208 1
a208 1
        def _wait
d210 5
a214 1
            sleep 0.02 while false.equal?(@@__instance__)
d216 1
d219 1
a219 1
            sleep (rand(0.1))
d224 1
a224 1
            raise  "allocation in thread ##{Thread.current[:i]} aborted"
d240 3
a242 3
            puts "Before there were #{num_of_instances(Ups)}s"
            sleep 3
            puts "Now there is #{num_of_instances(Ups)}"
d258 8
d267 2
a268 1
# Customized marshalling
d285 1
d294 42
a335 1
p a.die     #  => nil
@


1.11
log
@* time.c (time_plus): must detect result overflow.

* time.c (time_minus): ditto.

* time.c (time_new_internal): round usec overflow and underflow
  here.

* time.c (time_plus): move operand overflow/underflow check to
  time_new_internal().

* time.c (time_minus): ditto.

* time.c (time_cmp): should consider tv_usec too.

* time.c (time_gmtime): time_modify() should be called even if tm
  struct is not calculated yet.
@
text
@d33 1
a33 1
# * Klass.instance()  - returning ``the instance''
d46 1
@


1.10
log
@* eval.c (rb_thread_select): should subtract timeofday() from
  limit, not reverse.

* util.c (scan_hex): x is not a hexadecimal digit.

* eval.c (rb_thread_schedule): should treat the case that
  select(2) returns 0, if a thread is under both WAIT_SELECT and
  WAIT_TIME.  Jakub Travnik <J.Travnik@@sh.cvut.cz> actually fixed
  this bug.
@
text
@d47 51
a97 53
    def Singleton.included (klass)
        # should this be checked?
        # raise TypeError.new "..."  if klass.type == Module
        class << klass
            def inherited(sub_klass)
                # @@__instance__ takes on one of the following values
                # * nil    - before (and after a failed) creation
                # * false - during creation
                # * sub_class instance - after a successful creation
                sub_klass.instance_eval { @@__instance__ = nil }
                def sub_klass.instance
                    unless @@__instance__.nil?
                        # is the extra flexiblity having the hook method
                        # _wait() around ever useful?
                        _wait() 
                        # check for instance creation
                        return @@__instance__ if @@__instance__
                    end
                    Thread.critical = true
                    unless @@__instance__
                        @@__instance__  = false
                        Thread.critical = false
                        begin
                            @@__instance__ = new
                        ensure
                            if @@__instance__
                                define_method(:instance) {@@__instance__ }
                            else
                                # failed instance creation
                                @@__instance__ = nil
                            end
                        end
                    else
                        Thread.critical = false
                    end
                    return @@__instance__
                end
            end
            def _load(str)
                instance
            end
            def _wait
                sleep(0.05)  while false.equal?(@@__instance__)
            end
            private  :new, :allocate
            # hook methods are also marked private
            private :_load,:_wait
        end
        klass.inherited klass
    end
    private
    def _dump(depth)
        return ""
d99 6
@


1.9
log
@* marshal.c (w_float): must distinguish -0.0 from 0.0.

* gc.c (gc_mark_all): tweak mark order for little bit better scan.

* gc.c (rb_gc_mark): ditto.

* gc.c (rb_gc): ditto.

* enum.c (sort_by_i): slight performance boost.

* gc.c (gc_mark_rest): should call gc_mark_children(), not gc_mark().

* gc.c (rb_gc_mark): may cause infinite looop.
@
text
@d28 2
a29 2
# *  Klass.new and Klass.allocate - as private and
# *  Klass.inherited(sub_klass)     - modifying to ensure
d42 1
a42 1
#    instance variables from ``the instance''.  Providing costume
d56 1
a56 1
                @@__instance__ = nil
d61 1
a61 1
                        _wait() while false.equal?(@@__instance__)
d89 1
a89 1
                sleep(0.05)
d118 6
a123 2
# threaded example with exception
Thread.abort_on_exception = true
a124 4
    @@__threads__=  []
    @@__flip__ = nil
    @@@@__index__ = nil

d126 2
a127 2
        sleep(rand(0.1)/10.0)
        Thread.current[:index] = @@@@__index__
d130 8
d139 3
a141 5
            unless @@__flip__
                @@__flip__ = true
                raise "boom - allocation in thread ##{@@@@__index__} aborted"
            end
            super()
d144 11
a154 9
            1.upto(5) do |@@@@__index__|
                sleep(rand(0.1)/10.0)
                    @@__threads__.push Thread.new {
                        begin
                            instance
                        rescue RuntimeError => mes
                            puts mes
                        end
                    }
d157 5
a161 6
        def join
            @@__threads__.each do |t|
                t.join
                puts "initialize called by thread ##{t[:index]}" if
t[:index]
            end
d166 8
a174 7
puts "There is(are) #{ObjectSpace.each_object(Ups) {}} Ups instance(s)"
    # => The is(are) 0 Ups instance(s)
Ups.instanciate_all
Ups.join # => initialize called by thread # i - where  i = 2 ... 5
p Marshal.load(Marshal.dump(Ups.instance))  == Ups.instance # => true
puts "There is(are) #{ObjectSpace.each_object(Ups) {}} Ups instance(s)"
   # => The is(are) 1 Ups instance(s)
@


1.8
log
@* marshal.c (Init_marshal): new constant Marshal::MAJOR_VERSION
  and Marshal::MINOR_VERSION.

* marshal.c (marshal_load): ruby_verbose test should be wrapped by
  RTEST().

* hash.c (rb_hash_index): should return nil (not the default
  value) if value is not in the hash.

* numeric.c (num_div): new method added.  alias to '/' which
  should be preserved even if '/' is redefined (e.g. by
  mathn). [new]

* bignum.c (rb_cstr2inum): "0 ff".hex should return 0, not 255.

* file.c (rb_file_s_expand_path): fixed using CharNext().
@
text
@d1 44
a44 1
#  Singleton module that ensures only one object to be allocated.
a45 10
# Usage:
#   class SomeSingletonClass
#     include Singleton
#    #....
#   end
#   a = SomeSingletonClass.instance
#   b = SomeSingletonClass.instance	# a and b are same object
#   p [a,b]
#   a = SomeSingletonClass.new		# error (`new' is private)

d47 54
a100 23
  def Singleton.included(klass)
    klass.private_class_method(:new)
    klass.instance_eval %{
      @@__instance__ = nil
      def instance
	if defined? @@__allocating__
	  until @@__instance__
	    sleep 0.5
	  end
	elsif ! @@__instance__
	  Thread.critical = true
	  @@__allocating__ = true
	  Thread.critical = false
	  begin
	    @@__instance__ = new
	  ensure
	    remove_instance_variable(:@@__allocating__)
	  end
	end
	return @@__instance__
      end
    }
  end
d104 3
a106 1
  class SomeSingletonClass
d108 86
a193 2
    #....
  end
a194 4
  a = SomeSingletonClass.instance
  b = SomeSingletonClass.instance	# a and b are same object
  p [a,b]
  a = SomeSingletonClass.new		# error (`new' is private)
@


1.7
log
@forgot some checkins.
@
text
@d19 5
a23 1
	unless @@__instance__
d25 2
d28 1
a28 1
	    @@__instance__ ||= new
d30 1
a30 1
	    Thread.critical = false
@


1.6
log
@001225
@
text
@d14 1
a14 1
  def Singleton.append_features(klass)
@


1.5
log
@2000-02-29
@
text
@a18 1
	Thread.critical = true
d20 1
d22 1
a22 1
	    @@__instance__ = new
@


1.4
log
@19991125
@
text
@d19 1
a20 1
	  Thread.critical = true
@


1.3
log
@19991117
@
text
@d20 6
a25 1
	  @@__instance__ = new
@


1.2
log
@1.4.0
@
text
@d17 1
@


1.2.2.1
log
@19991117
@
text
@a16 1
      @@__instance__ = nil
@


1.2.2.2
log
@2000-03-02
@
text
@a18 1
	Thread.critical = true
d20 1
a20 5
	  begin
	    @@__instance__ = new
	  ensure
	    Thread.critical = false
	  end
@


1.1
log
@file singleton.rb was initially added on branch v1_1r.
@
text
@d1 37
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@a0 37
#  Singleton module that ensures only one object to be allocated.
#
# Usage:
#   class SomeSingletonClass
#     include Singleton
#    #....
#   end
#   a = SomeSingletonClass.instance
#   b = SomeSingletonClass.instance	# a and b are same object
#   p [a,b]
#   a = SomeSingletonClass.new		# error (`new' is private)

module Singleton
  def Singleton.append_features(klass)
    klass.private_class_method(:new)
    klass.instance_eval %{
      def instance
	unless @@__instance__
	  @@__instance__ = new
	end
	return @@__instance__
      end
    }
  end
end

if __FILE__ == $0
  class SomeSingletonClass
    include Singleton
    #....
  end

  a = SomeSingletonClass.instance
  b = SomeSingletonClass.instance	# a and b are same object
  p [a,b]
  a = SomeSingletonClass.new		# error (`new' is private)
end
@


1.1.2.1
log
@1.1b9_30
@
text
@a0 37
#  Singleton module that ensures only one object to be allocated.
#
# Usage:
#   class SomeSingletonClass
#     include Singleton
#    #....
#   end
#   a = SomeSingletonClass.instance
#   b = SomeSingletonClass.instance	# a and b are same object
#   p [a,b]
#   a = SomeSingletonClass.new		# error (`new' is private)

module Singleton
  def Singleton.append_features(klass)
    klass.private_class_method(:new)
    klass.instance_eval %{
      def instance
	unless @@__instance__
	  @@__instance__ = new
	end
	return @@__instance__
      end
    }
  end
end

if __FILE__ == $0
  class SomeSingletonClass
    include Singleton
    #....
  end

  a = SomeSingletonClass.instance
  b = SomeSingletonClass.instance	# a and b are same object
  p [a,b]
  a = SomeSingletonClass.new		# error (`new' is private)
end
@
