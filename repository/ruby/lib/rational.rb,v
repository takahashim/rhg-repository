head	1.5;
access;
symbols
	v1_6_7:1.3
	v1_6_6:1.3
	v1_6_5:1.3
	v1_6_4:1.3
	v1_7_1:1.3
	v1_6_4_preview4:1.3
	v1_6_4_preview3:1.3
	v1_6_4_preview2:1.3
	v1_6_4_preview1:1.3
	v1_6_3:1.3
	ruby_m17n:1.3.0.6
	ruby_1_6:1.3.0.4
	v1_6_2:1.3
	v1_6_1:1.3
	v1_6_0:1.3
	v1_4_6:1.3
	v1_4_5:1.3
	v1_4_4:1.3
	ruby_1_4_3:1.3
	ruby1_4_3:1.3
	v1_4_3:1.3
	v1_5_0:1.3
	ruby_1_4_3_pre1:1.3
	ruby_1_4:1.3.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.2.2.1
	v1_3_6_repack:1.1.1.2.2.1
	v1_3_6:1.1.1.2.2.1
	v1_3_5:1.1.1.2.2.1
	v1_2_6repack:1.1.1.1.4.2
	v1_3_4_990625:1.1.1.2.2.1
	v1_3_4_990624:1.1.1.2.2.1
	v1_2_6:1.1.1.1.4.2
	v1_3_4_990611:1.1.1.2.2.1
	v1_3_4_990531:1.1.1.2.2.1
	v1_3_3_990518:1.1.1.2.2.1
	v1_3_3_990513:1.1.1.2.2.1
	v1_3_3_990507:1.1.1.2.2.1
	v1_2_5:1.1.1.1.4.2
	v1_2_4:1.1.1.1.4.2
	v1_3_1_990225:1.1.1.2
	v1_3_1_990224:1.1.1.2
	v1_3_1_990215:1.1.1.2
	v1_3_1_990212:1.1.1.2
	v1_3_1_990210:1.1.1.2
	v1_3_1_:1.1.1.2
	v1_3_1_990209:1.1.1.2
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.4.2
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.4.2
	v1_2_1repack:1.1.1.1.4.2
	v1_2_1:1.1.1.1.4.2
	v1_2_stable:1.1.1.1.4.2
	v1_1d1:1.1.1.1.4.2
	v1_1d0:1.1.1.1.4.2
	v1_1c9_1:1.1.1.1.4.2
	v1_1c9:1.1.1.1.4.2
	v1_1c8:1.1.1.1.4.2
	v1_1c7:1.1.1.1.4.2
	v1_1c6:1.1.1.1.4.2
	v1_1d-start:1.1.1.1.4.2
	v1_1c5:1.1.1.1.4.2
	v1_1dev:1.1.1.1.4.2.0.2
	v1_1c4:1.1.1.1.4.2
	v1_1c3:1.1.1.1.4.2
	v1_1c2:1.1.1.1.4.2
	v1_1c1:1.1.1.1.4.2
	v1_1c0:1.1.1.1.4.2
	v1_1b9_31:1.1.1.1.4.2
	v1_1b9_30:1.1.1.1.4.2
	v1_1b9_28:1.1.1.1.4.2
	v1_1b9_27:1.1.1.1.4.2
	v1_1b9_26:1.1.1.1.4.2
	r1_1b9_25:1.1.1.1.4.2
	r1_1b9_24:1.1.1.1.4.2
	v1_1b9_23:1.1.1.1.4.2
	v1_1b9_22:1.1.1.1.4.2
	v1_1b9_20:1.1.1.1.4.2
	v1_1b9_18:1.1.1.1.4.2
	v1_1b9_16:1.1.1.1.4.2
	v1_1b9_15:1.1.1.1.4.2
	v1_1b9_13:1.1.1.1.4.2
	v1_1b9_12:1.1.1.1.4.2
	v1_1b9_11:1.1.1.1.4.2
	v1_1b9_08:1.1.1.1.4.2
	v1_1b9_07:1.1.1.1.4.2
	r1_1b9:1.1.1.1.4.1
	v1_1b8:1.1.1.1.4.1
	v1_1b7:1.1.1.1.4.1
	v1_1b6:1.1.1.1.4.1
	v1_1r:1.1.1.1.0.4
	v1_1:1.1.1.1
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2002.08.15.07.36.35;	author keiju;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.11.07.01.19;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.09.01.09.48.03;	author matz;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.08.13.05.45.16;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.35;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	;

1.1.1.2.2.1
date	99.03.24.08.52.35;	author matz;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	98.01.16.12.36.05;	author matz;	state Exp;
branches;
next	1.1.1.1.4.2;

1.1.1.1.4.2
date	98.03.12.07.23.23;	author matz;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.05.09.54.09;	author matz;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.08.15.07.35.57;	author keiju;	state Exp;
branches;
next	;


desc
@@


1.5
log
@* lib/rational.rb(Rational#hash): modify algorism for hash-function.
@
text
@#
#   rational.rb - 
#   	$Release Version: 0.5 $
#   	$Revision: 1.7 $
#   	$Date: 1999/08/24 12:49:28 $
#   	by Keiju ISHITSUKA(SHL Japan Inc.)
#
# --
#   Usage:
#   class Rational < Numeric
#      (include Comparable)
#
#   Rational(a, b) --> a/b
#
#   Rational::+
#   Rational::-
#   Rational::*
#   Rational::/
#   Rational::**
#   Rational::%
#   Rational::divmod
#   Rational::abs
#   Rational::<=>
#   Rational::to_i
#   Rational::to_f
#   Rational::to_s
#
#   Integer::gcd
#   Integer::lcm
#   Integer::gcdlcm
#   Integer::to_r
#
#   Fixnum::**
#   Bignum::**
#   
#

def Rational(a, b = 1)
  if a.kind_of?(Rational) && b == 1
    a
  else
    Rational.reduce(a, b)
  end
end
  
class Rational < Numeric
  @@RCS_ID='-$Id: rational.rb,v 1.7 1999/08/24 12:49:28 keiju Exp keiju $-'

  def Rational.reduce(num, den = 1)
    raise ZeroDivisionError, "denominator is 0" if den == 0

    if den < 0
      num = -num
      den = -den
    end
    gcd = num.gcd(den)
    num = num.div(gcd)
    den = den.div(gcd)
    if den == 1 && defined?(Unify)
      num
    else
      new!(num, den)
    end
  end
  
  def Rational.new!(num, den = 1)
    new(num, den)
  end
  
  def initialize(num, den)
    if den < 0
      num = -num
      den = -den
    end
    if num.kind_of?(Integer) and den.kind_of?(Integer)
      @@numerator = num
      @@denominator = den
    else
      @@numerator = num.to_i
      @@denominator = den.to_i
    end
  end
  
  def + (a)
    if a.kind_of?(Rational)
      num = @@numerator * a.denominator
      num_a = a.numerator * @@denominator
      Rational(num + num_a, @@denominator * a.denominator)
    elsif a.kind_of?(Integer)
      self + Rational.new!(a, 1)
    elsif a.kind_of?(Float)
      Float(self) + a
    else
      x , y = a.coerce(self)
      x + y
    end
  end
  
  def - (a)
    if a.kind_of?(Rational)
      num = @@numerator * a.denominator
      num_a = a.numerator * @@denominator
      Rational(num - num_a, @@denominator*a.denominator)
    elsif a.kind_of?(Integer)
      self - Rational.new!(a, 1)
    elsif a.kind_of?(Float)
      Float(self) - a
    else
      x , y = a.coerce(self)
      x - y
    end
  end
  
  def * (a)
    if a.kind_of?(Rational)
      num = @@numerator * a.numerator
      den = @@denominator * a.denominator
      Rational(num, den)
    elsif a.kind_of?(Integer)
      self * Rational.new!(a, 1)
    elsif a.kind_of?(Float)
      Float(self) * a
    else
      x , y = a.coerce(self)
      x * y
    end
  end
  
  def / (a)
    if a.kind_of?(Rational)
      num = @@numerator * a.denominator
      den = @@denominator * a.numerator
      Rational(num, den)
    elsif a.kind_of?(Integer)
      raise ZeroDivisionError, "divided by 0" if a == 0
      self / Rational.new!(a, 1)
    elsif a.kind_of?(Float)
      Float(self) / a
    else
      x , y = a.coerce(self)
      x / y
    end
  end
  
  def ** (other)
    if other.kind_of?(Rational)
      Float(self) ** other
    elsif other.kind_of?(Integer)
      if other > 0
	num = @@numerator ** other
	den = @@denominator ** other
      elsif other < 0
	num = @@denominator ** -other
	den = @@numerator ** -other
      elsif other == 0
	num = 1
	den = 1
      end
      Rational.new!(num, den)
    elsif other.kind_of?(Float)
      Float(self) ** other
    else
      x , y = other.coerce(self)
      x ** y
    end
  end
  
  def % (other)
    value = (self / other).to_i
    return self - other * value
  end
  
  def divmod(other)
    value = (self / other).to_i
    return value, self - other * value
  end
  
  def abs
    if @@numerator > 0
      Rational.new!(@@numerator, @@denominator)
    else
      Rational.new!(-@@numerator, @@denominator)
    end
  end

  def <=> (other)
    if other.kind_of?(Rational)
      num = @@numerator * other.denominator
      num_a = other.numerator * @@denominator
      v = num - num_a
      if v > 0
	return 1
      elsif v < 0
	return  -1
      else
	return 0
      end
    elsif other.kind_of?(Integer)
      return self <=> Rational.new!(other, 1)
    elsif other.kind_of?(Float)
      return Float(self) <=> other
    else
      x , y = other.coerce(self)
      return x <=> y
    end
  end

  def coerce(other)
    if other.kind_of?(Float)
      return other, self.to_f
    elsif other.kind_of?(Integer)
      return Rational.new!(other, 1), self
    else
      super
    end
  end

  def to_i
    Integer(@@numerator.div(@@denominator))
  end
  
  def to_f
    @@numerator.to_f/@@denominator.to_f
  end
  
  def to_s
    if @@denominator == 1
      @@numerator.to_s
    else
      @@numerator.to_s+"/"+@@denominator.to_s
    end
  end
  
  def to_r
    self
  end
  
  def inspect
    sprintf("Rational(%s, %s)", @@numerator.inspect, @@denominator.inspect)
  end
  
  def hash
    @@numerator.hash ^ @@denominator.hash
  end
  
  attr :numerator
  attr :denominator
  
  private :initialize
end

class Integer
  def numerator
    self
  end
  
  def denomerator
    1
  end
  
  def to_r
    Rational(self, 1)
  end
  
  def gcd(n)
    m = self.abs
    n = n.abs

    return n if m == 0
    return m if n == 0

    b = 0
    while n[0] == 0 && m[0] == 0
      b += 1; n >>= 1; m >>= 1
    end
    m >>= 1 while m[0] == 0
    n >>= 1 while n[0] == 0
    while m != n
      m, n = n, m if n > m
      m -= n; m >>= 1 while m[0] == 0
    end
    m << b
  end
  
  def gcd2(int)
    a = self.abs
    b = int.abs
  
    a, b = b, a if a < b
  
    while b != 0
      void, a = a.divmod(b)
      a, b = b, a
    end
    return a
  end

  def lcm(int)
    a = self.abs
    b = int.abs
    gcd = a.gcd(b)
    (a.div(gcd)) * b
  end
  
  def gcdlcm(int)
    a = self.abs
    b = int.abs
    gcd = a.gcd(b)
    return gcd, (a.div(gcd)) * b
  end
  
end

class Fixnum
  alias div! /;
  def div(other)
    if other.kind_of?(Fixnum)
      self.div!(other)
    elsif other.kind_of?(Bignum)
      x, y = other.coerce(self)
      x.div!(y)
    else
      x, y = other.coerce(self)
      x / y
    end
  end
  
#  alias divmod! divmod
  
  if not defined? Complex
    alias power! **;
  end
  
#   def rdiv(other)
#     if other.kind_of?(Fixnum)
#       Rational(self, other)
#     elsif
#       x, y = other.coerce(self)
#       if defined?(x.div())
# 	x.div(y)
#       else
# 	x / y
#       end
#     end
  #   end
  
  def rdiv(other)
    Rational.new!(self,1) / other
  end
  
  def rpower (other)
    if other >= 0
      self.power!(other)
    else
      Rational.new!(self,1)**other
    end
  end
    
  if not defined? Complex
    alias ** rpower
  end
end

class Bignum
  alias div! /;
  alias div /;
  alias divmod! divmod
  
  if not defined? power!
    alias power! **
  end
  
  def rdiv(other)
    Rational.new!(self,1) / other
  end
  
  def rpower (other)
    if other >= 0
      self.power!(other)
    else
      Rational.new!(self, 1)**other
    end
  end
  
  if not defined? Complex
    alias ** rpower
  end
  
end

@


1.4
log
@* eval.c (rb_eval): ruby_frame->last_func may be null, if it's
  called outside of a method.

* parse.y (arg): use INT2NUM, not INT2FIX for tUMINUS.

* parse.y (arg): unnecessary negative tPOW treatment.

* parse.y (tokadd_escape): wrong backslash escapement.

* parse.y (stmt,arg): too much void value check.

* parse.y (stmt,arg): need to check void value on rules which does
  not use node_assign().

* ext/socket/socket.c (ipaddr): need not to taint hostnames.

* range.c (range_include): should be based on "<=>", whereas
  member? still is based on "each".

* range.c (range_min,range_max): redefine methods based on "<=>".
@
text
@d243 1
a243 1
    @@numerator ^ @@denominator
@


1.3
log
@regexp literal (e.g. \202) match, etc.
@
text
@d11 1
a11 1
#      (include Compareable)
d50 1
a50 1
    raise ZeroDivisionError, "denometor is 0" if den == 0
d135 1
a135 1
      raise ZeroDivisionError, "devided by 0" if a == 0
@


1.3.4.1
log
@* math.c (Init_Math): backport asin, acos, atan.
@
text
@d11 1
a11 1
#      (include Comparable)
d50 1
a50 1
    raise ZeroDivisionError, "denominator is 0" if den == 0
d135 1
a135 1
      raise ZeroDivisionError, "divided by 0" if a == 0
@


1.3.4.2
log
@* lib/rational.rb(Rational#hash): modify algorism for hash-function.
@
text
@d243 1
a243 1
    @@numerator.hash ^ @@denominator.hash
@


1.2
log
@1.4.0
@
text
@d4 2
a5 2
#   	$Revision: 1.3 $
#   	$Date: 1998/03/11 14:09:03 $
d47 1
a47 1
  @@RCS_ID='-$Id: rational.rb,v 1.3 1998/03/11 14:09:03 keiju Exp keiju $-'
d238 4
d265 21
a285 1
  def gcd(int)
d297 1
a297 1
  
@


1.1
log
@Initial revision
@
text
@d4 2
a5 2
#   	$Revision: 1.1 $
#   	$Date: 1996/11/11 04:25:14 $
d47 2
d50 2
d80 1
a80 1
      @@denoninator = den.to_i
d135 1
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@d4 2
a5 2
#   	$Revision: 1.3 $
#   	$Date: 1998/03/11 14:09:03 $
a46 2
  @@RCS_ID='-$Id: rational.rb,v 1.3 1998/03/11 14:09:03 keiju Exp keiju $-'

a47 2
    raise ZeroDivisionError, "denometor is 0" if den == 0

a130 1
      raise ZeroDivisionError, "devided by 0" if a == 0
@


1.1.1.2.2.1
log
@990324
@
text
@d80 1
a80 1
      @@denominator = den.to_i
@


1.1.1.1.4.1
log
@*** empty log message ***
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.1 $
#   	$Date: 1998/01/16 04:05:49 $
@


1.1.1.1.4.2
log
@*** empty log message ***
@
text
@d4 2
a5 2
#   	$Revision: 1.3 $
#   	$Date: 1998/03/11 14:09:03 $
a46 2
  @@RCS_ID='-$Id: rational.rb,v 1.3 1998/03/11 14:09:03 keiju Exp keiju $-'

a47 2
    raise ZeroDivisionError, "denometor is 0" if den == 0

a130 1
      raise ZeroDivisionError, "devided by 0" if a == 0
@
