head	1.42;
access;
symbols
	v1_6_7:1.23.2.8
	v1_6_6:1.23.2.8
	v1_6_5:1.23.2.6
	v1_6_4:1.23.2.5
	v1_7_1:1.29
	v1_6_4_preview4:1.23.2.5
	v1_6_4_preview3:1.23.2.5
	v1_6_4_preview2:1.23.2.4
	v1_6_4_preview1:1.23.2.4
	v1_6_3:1.23.2.4
	ruby_m17n:1.23.0.4
	ruby_1_6:1.23.0.2
	v1_6_2:1.23
	v1_6_1:1.18
	v1_6_0:1.15
	v1_4_6:1.7.2.7
	v1_4_5:1.7.2.7
	ruby_1_4:1.7.0.2
	v1_5_0:1.3;
locks; strict;
comment	@# @;


1.42
date	2002.08.25.20.15.05;	author wakou;	state Exp;
branches;
next	1.41;

1.41
date	2002.08.12.07.39.12;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.05.05.04.25;	author wakou;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.03.02.36.46;	author wakou;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.02.14.19.51;	author wakou;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.30.00.21.05;	author wakou;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.29.05.39.09;	author wakou;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.29.04.48.32;	author wakou;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.11.10.03.01;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.21.03.30.22;	author shugo;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.18.20.08.14;	author wakou;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.30.17.48.24;	author wakou;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.06.22.18.11;	author wakou;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.17.19.43.27;	author wakou;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.18.01.20.56;	author wakou;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.18.01.07.00;	author wakou;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.18.00.01.57;	author wakou;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.25.19.57.56;	author wakou;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.24.06.01.47;	author knu;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.24.20.20.45;	author wakou;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2000.12.22.09.00.19;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.14.00.26.01;	author wakou;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.11.16.28.15;	author wakou;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.10.07.03.31;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.12.21.23.27;	author wakou;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.12.21.16.08;	author wakou;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.11.22.02.35;	author wakou;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.09.04.32.22;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.23.07.01.34;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.19.21.16.44;	author wakou;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.17.17.50.54;	author wakou;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.13.15.52.04;	author wakou;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.03.18.19.00;	author wakou;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.30.19.15.27;	author wakou;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.24.07.10.24;	author wakou;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.09.04.53.11;	author matz;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.05.01.09.41.38;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.06.04.15.41;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.05.04.37.22;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.12.07.09.23.33;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.12.01.09.24.17;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	99.11.04.08.39.38;	author matz;	state Exp;
branches;
next	;

1.7.2.1
date	2000.05.10.20.41.23;	author wakou;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2000.05.24.07.19.39;	author wakou;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2000.05.30.19.18.06;	author wakou;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2000.06.03.18.22.23;	author wakou;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2000.06.13.15.53.19;	author wakou;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2000.06.17.17.52.47;	author wakou;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2000.06.19.21.18.39;	author wakou;	state Exp;
branches;
next	;

1.23.2.1
date	2001.02.25.19.56.55;	author wakou;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2001.03.18.00.00.21;	author wakou;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2001.03.18.01.06.25;	author wakou;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2001.03.18.01.20.21;	author wakou;	state Exp;
branches;
next	1.23.2.5;

1.23.2.5
date	2001.04.17.19.41.49;	author wakou;	state Exp;
branches;
next	1.23.2.6;

1.23.2.6
date	2001.09.06.22.16.49;	author wakou;	state Exp;
branches;
next	1.23.2.7;

1.23.2.7
date	2001.10.30.17.45.51;	author wakou;	state Exp;
branches;
next	1.23.2.8;

1.23.2.8
date	2001.11.18.20.06.05;	author wakou;	state Exp;
branches;
next	1.23.2.9;

1.23.2.9
date	2002.05.01.09.38.01;	author matz;	state Exp;
branches;
next	1.23.2.10;

1.23.2.10
date	2002.05.29.04.47.19;	author wakou;	state Exp;
branches;
next	1.23.2.11;

1.23.2.11
date	2002.05.29.05.38.28;	author wakou;	state Exp;
branches;
next	1.23.2.12;

1.23.2.12
date	2002.05.30.00.19.43;	author wakou;	state Exp;
branches;
next	1.23.2.13;

1.23.2.13
date	2002.07.02.14.18.36;	author wakou;	state Exp;
branches;
next	1.23.2.14;

1.23.2.14
date	2002.07.03.02.35.58;	author wakou;	state Exp;
branches;
next	1.23.2.15;

1.23.2.15
date	2002.07.05.05.03.36;	author wakou;	state Exp;
branches;
next	1.23.2.16;

1.23.2.16
date	2002.08.12.07.40.41;	author matz;	state Exp;
branches;
next	1.23.2.17;

1.23.2.17
date	2002.08.25.20.15.54;	author wakou;	state Exp;
branches;
next	;


desc
@@


1.42
log
@	* lib/cgi.rb (CGI#form): fix ruby-bugs-ja:PR#280, add default action.
@
text
@=begin

== NAME

cgi.rb - cgi support library

Copyright (C) 2000  Network Applied Communication Laboratory, Inc.

Copyright (C) 2000  Information-technology Promotion Agency, Japan

Wakou Aoyama <wakou@@ruby-lang.org>



== EXAMPLE

=== GET FORM VALUES

  require "cgi"
  cgi = CGI.new
  values = cgi['field_name']   # <== array of 'field_name'
    # if not 'field_name' included, then return [].
  fields = cgi.keys            # <== array of field names

  # returns true if form has 'field_name'
  cgi.has_key?('field_name')
  cgi.has_key?('field_name')
  cgi.include?('field_name')


=== GET FORM VALUES AS HASH

  require "cgi"
  cgi = CGI.new
  params = cgi.params

cgi.params is a hash.

  cgi.params['new_field_name'] = ["value"]  # add new param
  cgi.params['field_name'] = ["new_value"]  # change value
  cgi.params.delete('field_name')           # delete param
  cgi.params.clear                          # delete all params


=== SAVE FORM VALUES TO FILE

  require "pstore"
  db = PStore.new("query.db")
  db.transaction do
    db["params"] = cgi.params
  end


=== RESTORE FORM VALUES FROM FILE

  require "pstore"
  db = PStore.new("query.db")
  db.transaction do
    cgi.params = db["params"]
  end


=== GET MULTIPART FORM VALUES

  require "cgi"
  cgi = CGI.new
  values = cgi['field_name']   # <== array of 'field_name'
  values[0].read               # <== body of values[0]
  values[0].local_path         # <== path to local file of values[0]
  values[0].original_filename  # <== original filename of values[0]
  values[0].content_type       # <== content_type of values[0]

and values[0] has StringIO or Tempfile class methods.


=== GET COOKIE VALUES

  require "cgi"
  cgi = CGI.new
  values = cgi.cookies['name']  # <== array of 'name'
    # if not 'name' included, then return [].
  names = cgi.cookies.keys      # <== array of cookie names

and cgi.cookies is a hash.


=== GET COOKIE OBJECTS

  require "cgi"
  cgi = CGI.new
  for name, cookie in cgi.cookies
    cookie.expires = Time.now + 30
  end
  cgi.out("cookie" => cgi.cookies){"string"}

  cgi.cookies # { "name1" => cookie1, "name2" => cookie2, ... }

  require "cgi"
  cgi = CGI.new
  cgi.cookies['name'].expires = Time.now + 30
  cgi.out("cookie" => cgi.cookies['name']){"string"}

and see MAKE COOKIE OBJECT.


=== GET ENVIRONMENT VALUE

  require "cgi"
  cgi = CGI.new
  value = cgi.auth_type
    # ENV["AUTH_TYPE"]

see http://www.w3.org/CGI/

AUTH_TYPE CONTENT_LENGTH CONTENT_TYPE GATEWAY_INTERFACE PATH_INFO
PATH_TRANSLATED QUERY_STRING REMOTE_ADDR REMOTE_HOST REMOTE_IDENT
REMOTE_USER REQUEST_METHOD SCRIPT_NAME SERVER_NAME SERVER_PORT
SERVER_PROTOCOL SERVER_SOFTWARE

content_length and server_port return Integer. and the others return String.

and HTTP_COOKIE, HTTP_COOKIE2

  value = cgi.raw_cookie
    # ENV["HTTP_COOKIE"]
  value = cgi.raw_cookie2
    # ENV["HTTP_COOKIE2"]

and other HTTP_*

  value = cgi.accept
    # ENV["HTTP_ACCEPT"]
  value = cgi.accept_charset
    # ENV["HTTP_ACCEPT_CHARSET"]

HTTP_ACCEPT HTTP_ACCEPT_CHARSET HTTP_ACCEPT_ENCODING HTTP_ACCEPT_LANGUAGE
HTTP_CACHE_CONTROL HTTP_FROM HTTP_HOST HTTP_NEGOTIATE HTTP_PRAGMA
HTTP_REFERER HTTP_USER_AGENT


=== PRINT HTTP HEADER AND HTML STRING TO $DEFAULT_OUTPUT ($>)

  require "cgi"
  cgi = CGI.new("html3")  # add HTML generation methods
  cgi.out() do
    cgi.html() do
      cgi.head{ cgi.title{"TITLE"} } +
      cgi.body() do
        cgi.form() do
          cgi.textarea("get_text") +
          cgi.br +
          cgi.submit
        end +
        cgi.pre() do
          CGI::escapeHTML(
            "params: " + cgi.params.inspect + "\n" +
            "cookies: " + cgi.cookies.inspect + "\n" +
            ENV.collect() do |key, value|
              key + " --> " + value + "\n"
            end.join("")
          )
        end
      end
    end
  end

  # add HTML generation methods
  CGI.new("html3")    # html3.2
  CGI.new("html4")    # html4.01 (Strict)
  CGI.new("html4Tr")  # html4.01 Transitional
  CGI.new("html4Fr")  # html4.01 Frameset


=end

raise "Please, use ruby1.5.4 or later." if RUBY_VERSION < "1.5.4"

require 'English'

class CGI

  CR  = "\015"
  LF  = "\012"
  EOL = CR + LF
  REVISION = '$Id: cgi.rb,v 1.41 2002/08/12 07:39:12 matz Exp $'

  NEEDS_BINMODE = true if /WIN/ni.match(RUBY_PLATFORM)
  PATH_SEPARATOR = {'UNIX'=>'/', 'WINDOWS'=>'\\', 'MACINTOSH'=>':'}

  HTTP_STATUS = {
    "OK"                  => "200 OK",
    "PARTIAL_CONTENT"     => "206 Partial Content",
    "MULTIPLE_CHOICES"    => "300 Multiple Choices",
    "MOVED"               => "301 Moved Permanently",
    "REDIRECT"            => "302 Found",
    "NOT_MODIFIED"        => "304 Not Modified",
    "BAD_REQUEST"         => "400 Bad Request",
    "AUTH_REQUIRED"       => "401 Authorization Required",
    "FORBIDDEN"           => "403 Forbidden",
    "NOT_FOUND"           => "404 Not Found",
    "METHOD_NOT_ALLOWED"  => "405 Method Not Allowed",
    "NOT_ACCEPTABLE"      => "406 Not Acceptable",
    "LENGTH_REQUIRED"     => "411 Length Required",
    "PRECONDITION_FAILED" => "412 Rrecondition Failed",
    "SERVER_ERROR"        => "500 Internal Server Error",
    "NOT_IMPLEMENTED"     => "501 Method Not Implemented",
    "BAD_GATEWAY"         => "502 Bad Gateway",
    "VARIANT_ALSO_VARIES" => "506 Variant Also Negotiates"
  }

  RFC822_DAYS = %w[ Sun Mon Tue Wed Thu Fri Sat ]
  RFC822_MONTHS = %w[ Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ]

  def env_table
    ENV
  end

  def stdinput
    $stdin
  end

  def stdoutput
    $DEFAULT_OUTPUT
  end

  private :env_table, :stdinput, :stdoutput

=begin
== METHODS
=end

=begin
=== ESCAPE URL ENCODE
  url_encoded_string = CGI::escape("string")
=end
  def CGI::escape(string)
    string.gsub(/([^ a-zA-Z0-9_.-]+)/n) do
      '%' + $1.unpack('H2' * $1.size).join('%').upcase
    end.tr(' ', '+')
  end


=begin
=== UNESCAPE URL ENCODED
  string = CGI::unescape("url encoded string")
=end
  def CGI::unescape(string)
    string.tr('+', ' ').gsub(/((?:%[0-9a-fA-F]{2})+)/n) do
      [$1.delete('%')].pack('H*')
    end
  end


=begin
=== ESCAPE HTML &\"<>
  CGI::escapeHTML("string")
=end
  def CGI::escapeHTML(string)
    string.gsub(/&/n, '&amp;').gsub(/\"/n, '&quot;').gsub(/>/n, '&gt;').gsub(/</n, '&lt;')
  end


=begin
=== UNESCAPE HTML
  CGI::unescapeHTML("HTML escaped string")
=end
  def CGI::unescapeHTML(string)
    string.gsub(/&(.*?);/n) do
      match = $1.dup
      case match
      when /\Aamp\z/ni           then '&'
      when /\Aquot\z/ni          then '"'
      when /\Agt\z/ni            then '>'
      when /\Alt\z/ni            then '<'
      when /\A#0*(\d+)\z/n       then
        if Integer($1) < 256
          Integer($1).chr
        else
          if Integer($1) < 65536 and ($KCODE[0] == ?u or $KCODE[0] == ?U)
            [Integer($1)].pack("U")
          else
            "&##{$1};"
          end
        end
      when /\A#x([0-9a-f]+)\z/ni then
        if $1.hex < 256
          $1.hex.chr
        else
          if $1.hex < 65536 and ($KCODE[0] == ?u or $KCODE[0] == ?U)
            [$1.hex].pack("U")
          else
            "&#x#{$1};"
          end
        end
      else
        "&#{match};"
      end
    end
  end


=begin
=== ESCAPE ELEMENT
  print CGI::escapeElement('<BR><A HREF="url"></A>', "A", "IMG")
    # "<BR>&lt;A HREF="url"&gt;&lt;/A&gt"

  print CGI::escapeElement('<BR><A HREF="url"></A>', ["A", "IMG"])
    # "<BR>&lt;A HREF="url"&gt;&lt;/A&gt"
=end
  def CGI::escapeElement(string, *elements)
    elements = elements[0] if elements[0].kind_of?(Array)
    unless elements.empty?
      string.gsub(/<\/?(?:#{elements.join("|")})(?!\w)(?:.|\n)*?>/ni) do
        CGI::escapeHTML($&)
      end
    else
      string
    end
  end


=begin
=== UNESCAPE ELEMENT
  print CGI::unescapeElement(
          CGI::escapeHTML('<BR><A HREF="url"></A>'), "A", "IMG")
    # "&lt;BR&gt;<A HREF="url"></A>"

  print CGI::unescapeElement(
          CGI::escapeHTML('<BR><A HREF="url"></A>'), ["A", "IMG"])
    # "&lt;BR&gt;<A HREF="url"></A>"
=end
  def CGI::unescapeElement(string, *elements)
    elements = elements[0] if elements[0].kind_of?(Array)
    unless elements.empty?
      string.gsub(/&lt;\/?(?:#{elements.join("|")})(?!\w)(?:.|\n)*?&gt;/ni) do
        CGI::unescapeHTML($&)
      end
    else
      string
    end
  end


=begin
=== MAKE RFC1123 DATE STRING
  CGI::rfc1123_date(Time.now)
    # Sat, 01 Jan 2000 00:00:00 GMT
=end
  def CGI::rfc1123_date(time)
    t = time.clone.gmtime
    return format("%s, %.2d %s %.4d %.2d:%.2d:%.2d GMT",
                RFC822_DAYS[t.wday], t.day, RFC822_MONTHS[t.month-1], t.year,
                t.hour, t.min, t.sec)
  end


=begin
=== MAKE HTTP HEADER STRING
  header
    # Content-Type: text/html

  header("text/plain")
    # Content-Type: text/plain

  header({"nph"        => true,
          "status"     => "OK",  # == "200 OK"
            # "status"     => "200 GOOD",
          "server"     => ENV['SERVER_SOFTWARE'],
          "connection" => "close",
          "type"       => "text/html",
          "charset"    => "iso-2022-jp",
            # Content-Type: text/html; charset=iso-2022-jp
          "language"   => "ja",
          "expires"    => Time.now + 30,
          "cookie"     => [cookie1, cookie2],
          "my_header1" => "my_value"
          "my_header2" => "my_value"})

header will not convert charset.

status:

  "OK"                  --> "200 OK"
  "PARTIAL_CONTENT"     --> "206 Partial Content"
  "MULTIPLE_CHOICES"    --> "300 Multiple Choices"
  "MOVED"               --> "301 Moved Permanently"
  "REDIRECT"            --> "302 Found"
  "NOT_MODIFIED"        --> "304 Not Modified"
  "BAD_REQUEST"         --> "400 Bad Request"
  "AUTH_REQUIRED"       --> "401 Authorization Required"
  "FORBIDDEN"           --> "403 Forbidden"
  "NOT_FOUND"           --> "404 Not Found"
  "METHOD_NOT_ALLOWED"  --> "405 Method Not Allowed"
  "NOT_ACCEPTABLE"      --> "406 Not Acceptable"
  "LENGTH_REQUIRED"     --> "411 Length Required"
  "PRECONDITION_FAILED" --> "412 Rrecondition Failed"
  "SERVER_ERROR"        --> "500 Internal Server Error"
  "NOT_IMPLEMENTED"     --> "501 Method Not Implemented"
  "BAD_GATEWAY"         --> "502 Bad Gateway"
  "VARIANT_ALSO_VARIES" --> "506 Variant Also Negotiates"

=end
  def header(options = "text/html")

    buf = ""

    case options
    when String
      options = { "type" => options }
    when Hash
      options = options.dup
    end

    unless options.has_key?("type")
      options["type"] = "text/html"
    end

    if options.has_key?("charset")
      options["type"] += "; charset=" + options.delete("charset")
    end

    options.delete("nph") if defined?(MOD_RUBY)
    if options.delete("nph") or /IIS/n.match(env_table['SERVER_SOFTWARE'])
      buf += (env_table["SERVER_PROTOCOL"] or "HTTP/1.0")  + " " +
             (HTTP_STATUS[options["status"]] or options["status"] or "200 OK") +
             EOL +
             "Date: " + CGI::rfc1123_date(Time.now) + EOL

      unless options.has_key?("server")
        options["server"] = (env_table['SERVER_SOFTWARE'] or "")
      end

      unless options.has_key?("connection")
        options["connection"] = "close"
      end

      options.delete("status")
    end

    if options.has_key?("status")
      buf += "Status: " +
             (HTTP_STATUS[options["status"]] or options["status"]) + EOL
      options.delete("status")
    end

    if options.has_key?("server")
      buf += "Server: " + options.delete("server") + EOL
    end

    if options.has_key?("connection")
      buf += "Connection: " + options.delete("connection") + EOL
    end

    buf += "Content-Type: " + options.delete("type") + EOL

    if options.has_key?("length")
      buf += "Content-Length: " + options.delete("length").to_s + EOL
    end

    if options.has_key?("language")
      buf += "Content-Language: " + options.delete("language") + EOL
    end

    if options.has_key?("expires")
      buf += "Expires: " + CGI::rfc1123_date( options.delete("expires") ) + EOL
    end

    if options.has_key?("cookie")
      if options["cookie"].kind_of?(String) or
           options["cookie"].kind_of?(Cookie)
        buf += "Set-Cookie: " + options.delete("cookie").to_s + EOL
      elsif options["cookie"].kind_of?(Array)
        options.delete("cookie").each{|cookie|
          buf += "Set-Cookie: " + cookie.to_s + EOL
        }
      elsif options["cookie"].kind_of?(Hash)
        options.delete("cookie").each_value{|cookie|
          buf += "Set-Cookie: " + cookie.to_s + EOL
        }
      end
    end
    if @@output_cookies
      for cookie in @@output_cookies
        buf += "Set-Cookie: " + cookie.to_s + EOL
      end
    end

    options.each{|key, value|
      buf += key + ": " + value.to_s + EOL
    }

    if defined?(MOD_RUBY)
      table = Apache::request.headers_out
      buf.scan(/([^:]+): (.+)#{EOL}/n){ |name, value|
        $stderr.printf("name:%s value:%s\n", name, value) if $DEBUG
        case name
        when 'Set-Cookie'
          table.add($1, $2)
        when /^status$/ni
          Apache::request.status_line = value
          Apache::request.status = value.to_i
        when /^content-type$/ni
          Apache::request.content_type = value
        when /^content-encoding$/ni
          Apache::request.content_encoding = value
        when /^location$/ni
	  if Apache::request.status == 200
	    Apache::request.status = 302
	  end
          Apache::request.headers_out[name] = value
        else
          Apache::request.headers_out[name] = value
        end
      }
      Apache::request.send_http_header
      ''
    else
      buf + EOL
    end

  end # header()


=begin
=== PRINT HTTP HEADER AND STRING TO $DEFAULT_OUTPUT ($>)
  cgi = CGI.new
  cgi.out{ "string" }
    # Content-Type: text/html
    # Content-Length: 6
    #
    # string

  cgi.out("text/plain"){ "string" }
    # Content-Type: text/plain
    # Content-Length: 6
    #
    # string

  cgi.out({"nph"        => true,
           "status"     => "OK",  # == "200 OK"
           "server"     => ENV['SERVER_SOFTWARE'],
           "connection" => "close",
           "type"       => "text/html",
           "charset"    => "iso-2022-jp",
             # Content-Type: text/html; charset=iso-2022-jp
           "language"   => "ja",
           "expires"    => Time.now + (3600 * 24 * 30),
           "cookie"     => [cookie1, cookie2],
           "my_header1" => "my_value",
           "my_header2" => "my_value"}){ "string" }

if "HEAD" == REQUEST_METHOD then output only HTTP header.

if charset is "iso-2022-jp" or "euc-jp" or "shift_jis" then
convert string charset, and set language to "ja".

=end
  def out(options = "text/html")

    options = { "type" => options } if options.kind_of?(String)
    content = yield

    if options.has_key?("charset")
      require "nkf"
      case options["charset"]
      when /iso-2022-jp/ni
        content = NKF::nkf('-j', content)
        options["language"] = "ja" unless options.has_key?("language")
      when /euc-jp/ni
        content = NKF::nkf('-e', content)
        options["language"] = "ja" unless options.has_key?("language")
      when /shift_jis/ni
        content = NKF::nkf('-s', content)
        options["language"] = "ja" unless options.has_key?("language")
      end
    end

    options["length"] = content.length.to_s
    output = stdoutput
    output.binmode if defined? output.binmode
    output.print header(options)
    output.print content unless "HEAD" == env_table['REQUEST_METHOD']
  end


=begin
=== PRINT
  cgi = CGI.new
  cgi.print    # default:  cgi.print == $DEFAULT_OUTPUT.print
=end
  def print(*options)
    stdoutput.print(*options)
  end


=begin
=== MAKE COOKIE OBJECT
  cookie1 = CGI::Cookie::new("name", "value1", "value2", ...)
  cookie1 = CGI::Cookie::new({"name" => "name", "value" => "value"})
  cookie1 = CGI::Cookie::new({'name'    => 'name',
                              'value'   => ['value1', 'value2', ...],
                              'path'    => 'path',   # optional
                              'domain'  => 'domain', # optional
                              'expires' => Time.now, # optional
                              'secure'  => true      # optional
                             })

  cgi.out({"cookie" => [cookie1, cookie2]}){ "string" }

  name    = cookie1.name
  values  = cookie1.value
  path    = cookie1.path
  domain  = cookie1.domain
  expires = cookie1.expires
  secure  = cookie1.secure

  cookie1.name    = 'name'
  cookie1.value   = ['value1', 'value2', ...]
  cookie1.path    = 'path'
  cookie1.domain  = 'domain'
  cookie1.expires = Time.now + 30
  cookie1.secure  = true
=end
  require "delegate"
  class Cookie < SimpleDelegator

    def initialize(name = "", *value)
      options = if name.kind_of?(String)
                  { "name" => name, "value" => value }
                else
                  name
                end
      unless options.has_key?("name")
        raise ArgumentError, "`name' required"
      end

      @@name = options["name"]
      @@value = Array(options["value"])
      # simple support for IE
      if options["path"]
        @@path = options["path"]
      else
        %r|^(.*/)|.match(ENV["SCRIPT_NAME"])
        @@path = ($1 or "")
      end
      @@domain = options["domain"]
      @@expires = options["expires"]
      @@secure = options["secure"] == true ? true : false

      super(@@value)
    end

    attr_accessor("name", "value", "path", "domain", "expires")
    attr_reader("secure")
    def secure=(val)
      @@secure = val if val == true or val == false
      @@secure
    end

    def to_s
      buf = ""
      buf += @@name + '='

      if @@value.kind_of?(String)
        buf += CGI::escape(@@value)
      else
        buf += @@value.collect{|v| CGI::escape(v) }.join("&")
      end

      if @@domain
        buf += '; domain=' + @@domain
      end

      if @@path
        buf += '; path=' + @@path
      end

      if @@expires
        buf += '; expires=' + CGI::rfc1123_date(@@expires)
      end

      if @@secure == true
        buf += '; secure'
      end

      buf
    end

  end # class Cookie


=begin
=== PARSE RAW COOKIE STRING
  cookies = CGI::Cookie::parse("raw_cookie_string")
    # { "name1" => cookie1, "name2" => cookie2, ... }
=end
  def Cookie::parse(raw_cookie)
    cookies = Hash.new([])
    return cookies unless raw_cookie

    raw_cookie.split('; ').each do |pairs|
      name, values = pairs.split('=',2)
      name = CGI::unescape(name)
      values ||= ""
      values = values.split('&').collect{|v| CGI::unescape(v) }
      unless cookies.has_key?(name)
        cookies[name] = Cookie::new({ "name" => name, "value" => values })
      end
    end

    cookies
  end


=begin
=== PARSE QUERY STRING
  params = CGI::parse("query_string")
    # {"name1" => ["value1", "value2", ...],
    #  "name2" => ["value1", "value2", ...], ... }
=end
  def CGI::parse(query)
    params = Hash.new([])

    query.split(/[&;]/n).each do |pairs|
      key, value = pairs.split('=',2).collect{|v| CGI::unescape(v) }
      if params.has_key?(key)
        params[key].push(value)
      else
        params[key] = [value]
      end
    end

    params
  end


  module QueryExtension

    for env in %w[ CONTENT_LENGTH SERVER_PORT ]
      eval( <<-END )
        def #{env.sub(/^HTTP_/n, '').downcase}
          env_table["#{env}"] && Integer(env_table["#{env}"])
        end
      END
    end

    for env in %w[ AUTH_TYPE CONTENT_TYPE GATEWAY_INTERFACE PATH_INFO
        PATH_TRANSLATED QUERY_STRING REMOTE_ADDR REMOTE_HOST
        REMOTE_IDENT REMOTE_USER REQUEST_METHOD SCRIPT_NAME
        SERVER_NAME SERVER_PROTOCOL SERVER_SOFTWARE

        HTTP_ACCEPT HTTP_ACCEPT_CHARSET HTTP_ACCEPT_ENCODING
        HTTP_ACCEPT_LANGUAGE HTTP_CACHE_CONTROL HTTP_FROM HTTP_HOST
        HTTP_NEGOTIATE HTTP_PRAGMA HTTP_REFERER HTTP_USER_AGENT ]
      eval( <<-END )
        def #{env.sub(/^HTTP_/n, '').downcase}
          env_table["#{env}"]
        end
      END
    end

    def raw_cookie
      env_table["HTTP_COOKIE"]
    end

    def raw_cookie2
      env_table["HTTP_COOKIE2"]
    end

    attr_accessor("cookies")
    attr("params")
    def params=(hash)
      @@params.clear
      @@params.update(hash)
    end

    def read_multipart(boundary, content_length)
      params = Hash.new([])
      boundary = "--" + boundary
      buf = ""
      bufsize = 10 * 1024

      # start multipart/form-data
      stdinput.binmode
      boundary_size = boundary.size + EOL.size
      content_length -= boundary_size
      status = stdinput.read(boundary_size)
      if nil == status
        raise EOFError, "no content body"
      elsif boundary + EOL != status
        raise EOFError, "bad content body"
      end

      until -1 == content_length
        head = nil
        if 10240 < content_length
          require "tempfile"
          body = Tempfile.new("CGI")
        else
          begin
            require "stringio" if not defined? StringIO
            body = StringIO.new
          rescue LoadError
            require "tempfile"
            body = Tempfile.new("CGI")
          end
        end
        body.binmode

        until head and /#{boundary}(?:#{EOL}|--)/n.match(buf)

          if (not head) and /#{EOL}#{EOL}/n.match(buf)
            buf = buf.sub(/\A((?:.|\n)*?#{EOL})#{EOL}/n) do
              head = $1.dup
              ""
            end
            next
          end

          if head and ( (EOL + boundary + EOL).size < buf.size )
            body.print buf[0 ... (buf.size - (EOL + boundary + EOL).size)]
            buf[0 ... (buf.size - (EOL + boundary + EOL).size)] = ""
          end

          c = if bufsize < content_length
                stdinput.read(bufsize) or ''
              else
                stdinput.read(content_length) or ''
              end
          buf += c
          content_length -= c.size

        end

        buf = buf.sub(/\A((?:.|\n)*?)(?:#{EOL})?#{boundary}(#{EOL}|--)/n) do
          body.print $1
          if "--" == $2
            content_length = -1
          end
          ""
        end

        body.rewind

        eval <<-END
          def body.local_path
            #{body.path.dump}
          end
        END

        /Content-Disposition:.* filename="?([^\";]*)"?/ni.match(head)
        eval <<-END
          def body.original_filename
            #{
              filename = ($1 or "").dup
              if /Mac/ni.match(env_table['HTTP_USER_AGENT']) and
                 /Mozilla/ni.match(env_table['HTTP_USER_AGENT']) and
                 (not /MSIE/ni.match(env_table['HTTP_USER_AGENT']))
                CGI::unescape(filename)
              else
                filename
              end.dump.untaint
            }.taint
          end
        END

        /Content-Type: (.*)/ni.match(head)
        eval <<-END
          def body.content_type
            #{($1 or "").dump.untaint}.taint
          end
        END

        /Content-Disposition:.* name="?([^\";]*)"?/ni.match(head)
        name = $1.dup

        if params.has_key?(name)
          params[name].push(body)
        else
          params[name] = [body]
        end

      end

      params
    end # read_multipart
    private :read_multipart

    # offline mode. read name=value pairs on standard input.
    def read_from_cmdline
      require "shellwords"

      string = unless ARGV.empty?
        ARGV.join(' ')
      else
        if STDIN.tty?
          STDERR.print(
            %|(offline mode: enter name=value pairs on standard input)\n|
          )
        end
        readlines.join(' ').gsub(/\n/n, '')
      end.gsub(/\\=/n, '%3D').gsub(/\\&/n, '%26')

      words = Shellwords.shellwords(string)

      if words.find{|x| /=/n.match(x) }
        words.join('&')
      else
        words.join('+')
      end
    end
    private :read_from_cmdline

    def initialize_query()
      if ("POST" == env_table['REQUEST_METHOD']) and
         %r|\Amultipart/form-data.*boundary=\"?([^\";,]+)\"?|n.match(env_table['CONTENT_TYPE'])
        boundary = $1.dup
        @@params = read_multipart(boundary, Integer(env_table['CONTENT_LENGTH']))
      else
        @@params = CGI::parse(
                    case env_table['REQUEST_METHOD']
                    when "GET", "HEAD"
                      if defined?(MOD_RUBY)
                        Apache::request.args or ""
                      else
                        env_table['QUERY_STRING'] or ""
                      end
                    when "POST"
                      stdinput.binmode
                      stdinput.read(Integer(env_table['CONTENT_LENGTH'])) or ''
                    else
                      read_from_cmdline
                    end
                  )
      end

      @@cookies = CGI::Cookie::parse((env_table['HTTP_COOKIE'] or env_table['COOKIE']))

    end
    private :initialize_query

    def [](*args)
      @@params[*args]
    end

    def keys(*args)
      @@params.keys(*args)
    end

    def has_key?(*args)
      @@params.has_key?(*args)
    end
    alias key? has_key?
    alias include? has_key?

  end # QueryExtension


=begin
=== HTML PRETTY FORMAT
  print CGI::pretty("<HTML><BODY></BODY></HTML>")
    # <HTML>
    #   <BODY>
    #   </BODY>
    # </HTML>

  print CGI::pretty("<HTML><BODY></BODY></HTML>", "\t")
    # <HTML>
    #         <BODY>
    #         </BODY>
    # </HTML>
=end
  def CGI::pretty(string, shift = "  ")
    lines = string.gsub(/(?!\A)<(?:.|\n)*?>/n, "\n\\0").gsub(/<(?:.|\n)*?>(?!\n)/n, "\\0\n")
    end_pos = 0
    while end_pos = lines.index(/^<\/(\w+)/n, end_pos)
      element = $1.dup
      start_pos = lines.rindex(/^\s*<#{element}/ni, end_pos)
      lines[start_pos ... end_pos] = "__" + lines[start_pos ... end_pos].gsub(/\n(?!\z)/n, "\n" + shift) + "__"
    end
    lines.gsub(/^((?:#{Regexp::quote(shift)})*)__(?=<\/?\w)/n, '\1')
  end


=begin
== HTML ELEMENTS

  cgi = CGI.new("html3")  # add HTML generation methods
  cgi.element
  cgi.element{ "string" }
  cgi.element({ "ATTRIBUTE1" => "value1", "ATTRIBUTE2" => "value2" })
  cgi.element({ "ATTRIBUTE1" => "value1", "ATTRIBUTE2" => "value2" }){ "string" }

  # add HTML generation methods
  CGI.new("html3")    # html3.2
  CGI.new("html4")    # html4.0 (Strict)
  CGI.new("html4Tr")  # html4.0 Transitional
  CGI.new("html4Fr")  # html4.0 Frameset

=end


  module TagMaker

    # - -
    def nn_element_def(element)
      <<-END.gsub(/element\.downcase/n, element.downcase).gsub(/element\.upcase/n, element.upcase)
          "<element.upcase" + attributes.collect{|name, value|
            next unless value
            " " + CGI::escapeHTML(name) +
            if true == value
              ""
            else
              '="' + CGI::escapeHTML(value) + '"'
            end
          }.to_s + ">" +
          if block_given?
            yield.to_s
          else
            ""
          end +
          "</element.upcase>"
      END
    end

    # - O EMPTY
    def nOE_element_def(element)
      <<-END.gsub(/element\.downcase/n, element.downcase).gsub(/element\.upcase/n, element.upcase)
          "<element.upcase" + attributes.collect{|name, value|
            next unless value
            " " + CGI::escapeHTML(name) +
            if true == value
              ""
            else
              '="' + CGI::escapeHTML(value) + '"'
            end
          }.to_s + ">"
      END
    end

    # O O or - O
    def nO_element_def(element)
      <<-END.gsub(/element\.downcase/n, element.downcase).gsub(/element\.upcase/n, element.upcase)
          "<element.upcase" + attributes.collect{|name, value|
            next unless value
            " " + CGI::escapeHTML(name) +
            if true == value
              ""
            else
              '="' + CGI::escapeHTML(value) + '"'
            end
          }.to_s + ">" +
          if block_given?
            yield.to_s + "</element.upcase>"
          else
            ""
          end
      END
    end

  end # TagMaker


  module HtmlExtension


=begin
=== A ELEMENT
  a("url")
    # = a({ "HREF" => "url" })
=end
    def a(href = "")
      attributes = if href.kind_of?(String)
                     { "HREF" => href }
                   else
                     href
                   end
      if block_given?
        super(attributes){ yield }
      else
        super(attributes)
      end
    end


=begin
=== BASE ELEMENT
  base("url")
    # = base({ "HREF" => "url" })
=end
    def base(href = "")
      attributes = if href.kind_of?(String)
                     { "HREF" => href }
                   else
                     href
                   end
      if block_given?
        super(attributes){ yield }
      else
        super(attributes)
      end
    end


=begin
=== BLOCKQUOTE ELEMENT
  blockquote("url"){ "string" }
    # = blockquote({ "CITE" => "url" }){ "string" }
=end
    def blockquote(cite = nil)
      attributes = if cite.kind_of?(String)
                     { "CITE" => cite }
                   else
                     cite or ""
                   end
      if block_given?
        super(attributes){ yield }
      else
        super(attributes)
      end
    end


=begin
=== CAPTION ELEMENT
  caption("align"){ "string" }
    # = caption({ "ALIGN" => "align" }){ "string" }
=end
    def caption(align = nil)
      attributes = if align.kind_of?(String)
                     { "ALIGN" => align }
                   else
                     align or ""
                   end
      if block_given?
        super(attributes){ yield }
      else
        super(attributes)
      end
    end


=begin
=== CHECKBOX
  checkbox("name")
    # = checkbox({ "NAME" => "name" })

  checkbox("name", "value")
    # = checkbox({ "NAME" => "name", "VALUE" => "value" })

  checkbox("name", "value", true)
    # = checkbox({ "NAME" => "name", "VALUE" => "value", "CHECKED" => true })
=end
    def checkbox(name = "", value = nil, checked = nil)
      attributes = if name.kind_of?(String)
                     { "TYPE" => "checkbox", "NAME" => name,
                       "VALUE" => value, "CHECKED" => checked }
                   else
                     name["TYPE"] = "checkbox"
                     name
                   end
      input(attributes)
    end


=begin
=== CHECKBOX_GROUP
  checkbox_group("name", "foo", "bar", "baz")
    # <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo
    # <INPUT TYPE="checkbox" NAME="name" VALUE="bar">bar
    # <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz

  checkbox_group("name", ["foo"], ["bar", true], "baz")
    # <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo
    # <INPUT TYPE="checkbox" CHECKED NAME="name" VALUE="bar">bar
    # <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz

  checkbox_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
    # <INPUT TYPE="checkbox" NAME="name" VALUE="1">Foo
    # <INPUT TYPE="checkbox" CHECKED NAME="name" VALUE="2">Bar
    # <INPUT TYPE="checkbox" NAME="name" VALUE="Baz">Baz

  checkbox_group({ "NAME" => "name",
                   "VALUES" => ["foo", "bar", "baz"] })

  checkbox_group({ "NAME" => "name",
                   "VALUES" => [["foo"], ["bar", true], "baz"] })

  checkbox_group({ "NAME" => "name",
                   "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
=end
    def checkbox_group(name = "", *values)
      if name.kind_of?(Hash)
        values = name["VALUES"]
        name = name["NAME"]
      end
      values.collect{|value|
        if value.kind_of?(String)
          checkbox(name, value) + value
        else
          if value[value.size - 1] == true
            checkbox(name, value[0], true) +
            value[value.size - 2]
          else
            checkbox(name, value[0]) +
            value[value.size - 1]
          end
        end
      }.to_s
    end


=begin
=== FILE_FIELD
  file_field("name")
    # <INPUT TYPE="file" NAME="name" SIZE="20">

  file_field("name", 40)
    # <INPUT TYPE="file" NAME="name" SIZE="40">

  file_field("name", 40, 100)
    # <INPUT TYPE="file" NAME="name" SIZE="40" MAXLENGTH="100">

  file_field({ "NAME" => "name", "SIZE" => 40 })
    # <INPUT TYPE="file" NAME="name" SIZE="40">
=end
    def file_field(name = "", size = 20, maxlength = nil)
      attributes = if name.kind_of?(String)
                     { "TYPE" => "file", "NAME" => name,
                       "SIZE" => size.to_s }
                   else
                     name["TYPE"] = "file"
                     name
                   end
      attributes["MAXLENGTH"] = maxlength.to_s if maxlength
      input(attributes)
    end


=begin
=== FORM ELEMENT
  form{ "string" }
    # <FORM METHOD="post" ENCTYPE="application/x-www-form-urlencoded">string</FORM>

  form("get"){ "string" }
    # <FORM METHOD="get" ENCTYPE="application/x-www-form-urlencoded">string</FORM>

  form("get", "url"){ "string" }
    # <FORM METHOD="get" ACTION="url" ENCTYPE="application/x-www-form-urlencoded">string</FORM>

  form({"METHOD" => "post", "ENCTYPE" => "enctype"}){ "string" }
    # <FORM METHOD="post" ENCTYPE="enctype">string</FORM>

The hash keys are case sensitive. Ask the samples.
=end
    def form(method = "post", action = script_name, enctype = "application/x-www-form-urlencoded")
      attributes = if method.kind_of?(String)
                     { "METHOD" => method, "ACTION" => action,
                       "ENCTYPE" => enctype } 
                   else
                     unless method.has_key?("METHOD")
                       method["METHOD"] = "post"
                     end
                     unless method.has_key?("ENCTYPE")
                       method["ENCTYPE"] = enctype
                     end
                     method
                   end
      if block_given?
        body = yield
      else
        body = ""
      end
      if @@output_hidden
        hidden = @@output_hidden.collect{|k,v|
          "<INPUT TYPE=HIDDEN NAME=\"#{k}\" VALUE=\"#{v}\">"
        }.to_s
        if defined? fieldset
          body += fieldset{ hidden }
        else
          body += hidden
        end
      end
      super(attributes){body}
    end

=begin
=== HIDDEN FIELD
  hidden("name")
    # <INPUT TYPE="hidden" NAME="name">

  hidden("name", "value")
    # <INPUT TYPE="hidden" NAME="name" VALUE="value">

  hidden({ "NAME" => "name", "VALUE" => "reset", "ID" => "foo" })
    # <INPUT TYPE="hidden" NAME="name" VALUE="value" ID="foo">
=end
    def hidden(name = "", value = nil)
      attributes = if name.kind_of?(String)
                     { "TYPE" => "hidden", "NAME" => name, "VALUE" => value }
                   else
                     name["TYPE"] = "hidden"
                     name
                   end
      input(attributes)
    end


=begin
=== HTML ELEMENT

  html{ "string" }
    # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML>string</HTML>

  html({ "LANG" => "ja" }){ "string" }
    # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML LANG="ja">string</HTML>

  html({ "DOCTYPE" => false }){ "string" }
    # <HTML>string</HTML>

  html({ "DOCTYPE" => '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">' }){ "string" }
    # <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"><HTML>string</HTML>

  html({ "PRETTY" => "  " }){ "<BODY></BODY>" }
    # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
    # <HTML>
    #   <BODY>
    #   </BODY>
    # </HTML>

  html({ "PRETTY" => "\t" }){ "<BODY></BODY>" }
    # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
    # <HTML>
    #         <BODY>
    #         </BODY>
    # </HTML>

  html("PRETTY"){ "<BODY></BODY>" }
    # = html({ "PRETTY" => "  " }){ "<BODY></BODY>" }

  html(if $VERBOSE then "PRETTY" end){ "HTML string" }

=end
    def html(attributes = {})
      if nil == attributes
        attributes = {}
      elsif "PRETTY" == attributes
        attributes = { "PRETTY" => true }
      end
      pretty = attributes.delete("PRETTY")
      pretty = "  " if true == pretty
      buf = ""

      if attributes.has_key?("DOCTYPE")
        if attributes["DOCTYPE"]
          buf += attributes.delete("DOCTYPE")
        else
          attributes.delete("DOCTYPE")
        end
      else
        buf += doctype
      end

      if block_given?
        buf += super(attributes){ yield }
      else
        buf += super(attributes)
      end

      if pretty
        CGI::pretty(buf, pretty)
      else
        buf
      end

    end


=begin
=== IMAGE_BUTTON
  image_button("url")
    # <INPUT TYPE="image" SRC="url">

  image_button("url", "name", "string")
    # <INPUT TYPE="image" SRC="url" NAME="name" ALT="string">

  image_button({ "SRC" => "url", "ATL" => "strng" })
    # <INPUT TYPE="image" SRC="url" ALT="string">
=end
    def image_button(src = "", name = nil, alt = nil)
      attributes = if src.kind_of?(String)
                     { "TYPE" => "image", "SRC" => src, "NAME" => name,
                       "ALT" => alt }
                   else
                     src["TYPE"] = "image"
                     src["SRC"] ||= ""
                     src
                   end
      input(attributes)
    end


=begin
=== IMG ELEMENT
  img("src", "alt", 100, 50)
    # <IMG SRC="src" ALT="alt" WIDTH="100" HEIGHT="50">

  img({ "SRC" => "src", "ALT" => "alt", "WIDTH" => 100, "HEIGHT" => 50 })
    # <IMG SRC="src" ALT="alt" WIDTH="100" HEIGHT="50">
=end
    def img(src = "", alt = "", width = nil, height = nil)
      attributes = if src.kind_of?(String)
                     { "SRC" => src, "ALT" => alt }
                   else
                     src
                   end
      attributes["WIDTH"] = width.to_s if width
      attributes["HEIGHT"] = height.to_s if height
      super(attributes)
    end


=begin
=== MULTIPART FORM
  multipart_form{ "string" }
    # <FORM METHOD="post" ENCTYPE="multipart/form-data">string</FORM>

  multipart_form("url"){ "string" }
    # <FORM METHOD="post" ACTION="url" ENCTYPE="multipart/form-data">string</FORM>
=end
    def multipart_form(action = nil, enctype = "multipart/form-data")
      attributes = if action == nil
                     { "METHOD" => "post", "ENCTYPE" => enctype } 
                   elsif action.kind_of?(String)
                     { "METHOD" => "post", "ACTION" => action,
                       "ENCTYPE" => enctype } 
                   else
                     unless action.has_key?("METHOD")
                       action["METHOD"] = "post"
                     end
                     unless action.has_key?("ENCTYPE")
                       action["ENCTYPE"] = enctype
                     end
                     action
                   end
      if block_given?
        form(attributes){ yield }
      else
        form(attributes)
      end
    end


=begin
=== PASSWORD_FIELD
  password_field("name")
    # <INPUT TYPE="password" NAME="name" SIZE="40">

  password_field("name", "value")
    # <INPUT TYPE="password" NAME="name" VALUE="value" SIZE="40">

  password_field("password", "value", 80, 200)
    # <INPUT TYPE="password" NAME="name" VALUE="value" SIZE="80" MAXLENGTH="200">

  password_field({ "NAME" => "name", "VALUE" => "value" })
    # <INPUT TYPE="password" NAME="name" VALUE="value">
=end
    def password_field(name = "", value = nil, size = 40, maxlength = nil)
      attributes = if name.kind_of?(String)
                     { "TYPE" => "password", "NAME" => name,
                       "VALUE" => value, "SIZE" => size.to_s }
                   else
                     name["TYPE"] = "password"
                     name
                   end
      attributes["MAXLENGTH"] = maxlength.to_s if maxlength
      input(attributes)
    end


=begin
=== POPUP_MENU
  popup_menu("name", "foo", "bar", "baz")
    # <SELECT NAME="name">
    #   <OPTION VALUE="foo">foo</OPTION>
    #   <OPTION VALUE="bar">bar</OPTION>
    #   <OPTION VALUE="baz">baz</OPTION>
    # </SELECT>

  popup_menu("name", ["foo"], ["bar", true], "baz")
    # <SELECT NAME="name">
    #   <OPTION VALUE="foo">foo</OPTION>
    #   <OPTION VALUE="bar" SELECTED>bar</OPTION>
    #   <OPTION VALUE="baz">baz</OPTION>
    # </SELECT>

  popup_menu("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
    # <SELECT NAME="name">
    #   <OPTION VALUE="1">Foo</OPTION>
    #   <OPTION SELECTED VALUE="2">Bar</OPTION>
    #   <OPTION VALUE="Baz">Baz</OPTION>
    # </SELECT>

  popup_menu({"NAME" => "name", "SIZE" => 2, "MULTIPLE" => true,
              "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
    # <SELECT NAME="name" MULTIPLE SIZE="2">
    #   <OPTION VALUE="1">Foo</OPTION>
    #   <OPTION SELECTED VALUE="2">Bar</OPTION>
    #   <OPTION VALUE="Baz">Baz</OPTION>
    # </SELECT>
=end
    def popup_menu(name = "", *values)

      if name.kind_of?(Hash)
        values   = name["VALUES"]
        size     = name["SIZE"].to_s if name["SIZE"]
        multiple = name["MULTIPLE"]
        name     = name["NAME"]
      else
        size = nil
        multiple = nil
      end

      select({ "NAME" => name, "SIZE" => size,
               "MULTIPLE" => multiple }){
        values.collect{|value|
          if value.kind_of?(String)
            option({ "VALUE" => value }){ value }
          else
            if value[value.size - 1] == true
              option({ "VALUE" => value[0], "SELECTED" => true }){
                value[value.size - 2]
              }
            else
              option({ "VALUE" => value[0] }){
                value[value.size - 1]
              }
            end
          end
        }.to_s
      }

    end


=begin
=== RADIO_BUTTON
  radio_button("name", "value")
    # <INPUT TYPE="radio" NAME="name" VALUE="value">

  radio_button("name", "value", true)
    # <INPUT TYPE="radio" NAME="name" VALUE="value" CHECKED>

  radio_button({ "NAME" => "name", "VALUE" => "value", "ID" => "foo" })
    # <INPUT TYPE="radio" NAME="name" VALUE="value" ID="foo">
=end
    def radio_button(name = "", value = nil, checked = nil)
      attributes = if name.kind_of?(String)
                     { "TYPE" => "radio", "NAME" => name,
                       "VALUE" => value, "CHECKED" => checked }
                   else
                     name["TYPE"] = "radio"
                     name
                   end
      input(attributes)
    end


=begin
=== RADIO_GROUP
  radio_group("name", "foo", "bar", "baz")
    # <INPUT TYPE="radio" NAME="name" VALUE="foo">foo
    # <INPUT TYPE="radio" NAME="name" VALUE="bar">bar
    # <INPUT TYPE="radio" NAME="name" VALUE="baz">baz

  radio_group("name", ["foo"], ["bar", true], "baz")
    # <INPUT TYPE="radio" NAME="name" VALUE="foo">foo
    # <INPUT TYPE="radio" CHECKED NAME="name" VALUE="bar">bar
    # <INPUT TYPE="radio" NAME="name" VALUE="baz">baz

  radio_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
    # <INPUT TYPE="radio" NAME="name" VALUE="1">Foo
    # <INPUT TYPE="radio" CHECKED NAME="name" VALUE="2">Bar
    # <INPUT TYPE="radio" NAME="name" VALUE="Baz">Baz

  radio_group({ "NAME" => "name",
                "VALUES" => ["foo", "bar", "baz"] })

  radio_group({ "NAME" => "name",
                "VALUES" => [["foo"], ["bar", true], "baz"] })

  radio_group({ "NAME" => "name",
                "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
=end
    def radio_group(name = "", *values)
      if name.kind_of?(Hash)
        values = name["VALUES"]
        name = name["NAME"]
      end
      values.collect{|value|
        if value.kind_of?(String)
          radio_button(name, value) + value
        else
          if value[value.size - 1] == true
            radio_button(name, value[0], true) +
            value[value.size - 2]
          else
            radio_button(name, value[0]) +
            value[value.size - 1]
          end
        end
      }.to_s
    end


=begin
=== RESET BUTTON
  reset
    # <INPUT TYPE="reset">

  reset("reset")
    # <INPUT TYPE="reset" VALUE="reset">

  reset({ "VALUE" => "reset", "ID" => "foo" })
    # <INPUT TYPE="reset" VALUE="reset" ID="foo">
=end
    def reset(value = nil, name = nil)
      attributes = if (not value) or value.kind_of?(String)
                     { "TYPE" => "reset", "VALUE" => value, "NAME" => name }
                   else
                     value["TYPE"] = "reset"
                     value
                   end
      input(attributes)
    end


=begin
=== SCROLLING_LIST
  scrolling_list({"NAME" => "name", "SIZE" => 2, "MULTIPLE" => true,
                  "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
    # <SELECT NAME="name" MULTIPLE SIZE="2">
    #   <OPTION VALUE="1">Foo</OPTION>
    #   <OPTION SELECTED VALUE="2">Bar</OPTION>
    #   <OPTION VALUE="Baz">Baz</OPTION>
    # </SELECT>
=end
    alias scrolling_list popup_menu


=begin
=== SUBMIT BUTTON
  submit
    # <INPUT TYPE="submit">

  submit("ok")
    # <INPUT TYPE="submit" VALUE="ok">

  submit("ok", "button1")
    # <INPUT TYPE="submit" VALUE="ok" NAME="button1">

  submit({ "VALUE" => "ok", "NAME" => "button1", "ID" => "foo" })
    # <INPUT TYPE="submit" VALUE="ok" NAME="button1" ID="foo">
=end
    def submit(value = nil, name = nil)
      attributes = if (not value) or value.kind_of?(String)
                     { "TYPE" => "submit", "VALUE" => value, "NAME" => name }
                   else
                     value["TYPE"] = "submit"
                     value
                   end
      input(attributes)
    end


=begin
=== TEXT_FIELD
  text_field("name")
    # <INPUT TYPE="text" NAME="name" SIZE="40">

  text_field("name", "value")
    # <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="40">

  text_field("name", "value", 80)
    # <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="80">

  text_field("name", "value", 80, 200)
    # <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="80" MAXLENGTH="200">

  text_field({ "NAME" => "name", "VALUE" => "value" })
    # <INPUT TYPE="text" NAME="name" VALUE="value">
=end
    def text_field(name = "", value = nil, size = 40, maxlength = nil)
      attributes = if name.kind_of?(String)
                     { "TYPE" => "text", "NAME" => name, "VALUE" => value,
                       "SIZE" => size.to_s }
                   else
                     name["TYPE"] = "text"
                     name
                   end
      attributes["MAXLENGTH"] = maxlength.to_s if maxlength
      input(attributes)
    end


=begin
=== TEXTAREA ELEMENT
  textarea("name")
    # = textarea({ "NAME" => "name", "COLS" => 70, "ROWS" => 10 })

  textarea("name", 40, 5)
    # = textarea({ "NAME" => "name", "COLS" => 40, "ROWS" => 5 })
=end
    def textarea(name = "", cols = 70, rows = 10)
      attributes = if name.kind_of?(String)
                     { "NAME" => name, "COLS" => cols.to_s,
                       "ROWS" => rows.to_s }
                   else
                     name
                   end
      if block_given?
        super(attributes){ yield }
      else
        super(attributes)
      end
    end

  end # HtmlExtension


  module Html3

    def doctype
      %|<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">|
    end

    def element_init
      extend TagMaker
      methods = ""
      # - -
      for element in %w[ A TT I B U STRIKE BIG SMALL SUB SUP EM STRONG
          DFN CODE SAMP KBD VAR CITE FONT ADDRESS DIV center MAP
          APPLET PRE XMP LISTING DL OL UL DIR MENU SELECT table TITLE
          STYLE SCRIPT H1 H2 H3 H4 H5 H6 TEXTAREA FORM BLOCKQUOTE
          CAPTION ]
        methods += <<-BEGIN + nn_element_def(element) + <<-END
          def #{element.downcase}(attributes = {})
        BEGIN
          end
        END
      end

      # - O EMPTY
      for element in %w[ IMG BASE BASEFONT BR AREA LINK PARAM HR INPUT
          ISINDEX META ]
        methods += <<-BEGIN + nOE_element_def(element) + <<-END
          def #{element.downcase}(attributes = {})
        BEGIN
          end
        END
      end

      # O O or - O
      for element in %w[ HTML HEAD BODY P PLAINTEXT DT DD LI OPTION tr
          th td ]
        methods += <<-BEGIN + nO_element_def(element) + <<-END
          def #{element.downcase}(attributes = {})
        BEGIN
          end
        END
      end
      eval(methods)
    end

  end # Html3


  module Html4

    def doctype
      %|<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">|
    end

    def element_init
      extend TagMaker
      methods = ""
      # - -
      for element in %w[ TT I B BIG SMALL EM STRONG DFN CODE SAMP KBD
        VAR CITE ABBR ACRONYM SUB SUP SPAN BDO ADDRESS DIV MAP OBJECT
        H1 H2 H3 H4 H5 H6 PRE Q INS DEL DL OL UL LABEL SELECT OPTGROUP
        FIELDSET LEGEND BUTTON TABLE TITLE STYLE SCRIPT NOSCRIPT
        TEXTAREA FORM A BLOCKQUOTE CAPTION ]
        methods += <<-BEGIN + nn_element_def(element) + <<-END
          def #{element.downcase}(attributes = {})
        BEGIN
          end
        END
      end

      # - O EMPTY
      for element in %w[ IMG BASE BR AREA LINK PARAM HR INPUT COL META ]
        methods += <<-BEGIN + nOE_element_def(element) + <<-END
          def #{element.downcase}(attributes = {})
        BEGIN
          end
        END
      end

      # O O or - O
      for element in %w[ HTML BODY P DT DD LI OPTION THEAD TFOOT TBODY
          COLGROUP TR TH TD HEAD]
        methods += <<-BEGIN + nO_element_def(element) + <<-END
          def #{element.downcase}(attributes = {})
        BEGIN
          end
        END
      end
      eval(methods)
    end

  end # Html4


  module Html4Tr

    def doctype
      %|<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">|
    end

    def element_init
      extend TagMaker
      methods = ""
      # - -
      for element in %w[ TT I B U S STRIKE BIG SMALL EM STRONG DFN
          CODE SAMP KBD VAR CITE ABBR ACRONYM FONT SUB SUP SPAN BDO
          ADDRESS DIV CENTER MAP OBJECT APPLET H1 H2 H3 H4 H5 H6 PRE Q
          INS DEL DL OL UL DIR MENU LABEL SELECT OPTGROUP FIELDSET
          LEGEND BUTTON TABLE IFRAME NOFRAMES TITLE STYLE SCRIPT
          NOSCRIPT TEXTAREA FORM A BLOCKQUOTE CAPTION ]
        methods += <<-BEGIN + nn_element_def(element) + <<-END
          def #{element.downcase}(attributes = {})
        BEGIN
          end
        END
      end

      # - O EMPTY
      for element in %w[ IMG BASE BASEFONT BR AREA LINK PARAM HR INPUT
          COL ISINDEX META ]
        methods += <<-BEGIN + nOE_element_def(element) + <<-END
          def #{element.downcase}(attributes = {})
        BEGIN
          end
        END
      end

      # O O or - O
      for element in %w[ HTML BODY P DT DD LI OPTION THEAD TFOOT TBODY
          COLGROUP TR TH TD HEAD ]
        methods += <<-BEGIN + nO_element_def(element) + <<-END
          def #{element.downcase}(attributes = {})
        BEGIN
          end
        END
      end
      eval(methods)
    end

  end # Html4Tr


  module Html4Fr

    def doctype
      %|<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">|
    end

    def element_init
      methods = ""
      # - -
      for element in %w[ FRAMESET ]
        methods += <<-BEGIN + nn_element_def(element) + <<-END
          def #{element.downcase}(attributes = {})
        BEGIN
          end
        END
      end

      # - O EMPTY
      for element in %w[ FRAME ]
        methods += <<-BEGIN + nOE_element_def(element) + <<-END
          def #{element.downcase}(attributes = {})
        BEGIN
          end
        END
      end
      eval(methods)
    end

  end # Html4Fr


  def initialize(type = "query")
    if defined?(MOD_RUBY) && !ENV.key?("GATEWAY_INTERFACE")
      Apache.request.setup_cgi_env
    end

    extend QueryExtension
    if "POST" != env_table['REQUEST_METHOD']
      initialize_query()  # set @@params, @@cookies
    else
      if defined?(CGI_PARAMS)
        @@params  = CGI_PARAMS.nil?  ? nil : CGI_PARAMS.dup
        @@cookies = CGI_COOKIES.nil? ? nil : CGI_COOKIES.dup
      else
        initialize_query()  # set @@params, @@cookies
        eval "CGI_PARAMS  = @@params.nil?  ? nil : @@params.dup"
        eval "CGI_COOKIES = @@cookies.nil? ? nil : @@cookies.dup"
        if defined?(MOD_RUBY) and (RUBY_VERSION < "1.4.3")
          raise "Please, use ruby1.4.3 or later."
        else
          at_exit() do
            if defined?(CGI_PARAMS)
              self.class.class_eval("remove_const(:CGI_PARAMS)")
              self.class.class_eval("remove_const(:CGI_COOKIES)")
            end
          end
        end
      end
    end
    @@output_cookies = nil
    @@output_hidden = nil

    case type
    when "html3"
      extend Html3
      element_init()
      extend HtmlExtension
    when "html4"
      extend Html4
      element_init()
      extend HtmlExtension
    when "html4Tr"
      extend Html4Tr
      element_init()
      extend HtmlExtension
    when "html4Fr"
      extend Html4Tr
      element_init()
      extend Html4Fr
      element_init()
      extend HtmlExtension
    end

  end
end


=begin

== HISTORY

delete. see cvs log.


=end

# vi:set tw=0:
@


1.41
log
@* bignum.c (rb_big_cmp): use dbl2big() for Floats, instead of
  big2dbl().

* bignum.c (Init_Bignum): rb_big_zero_p() removed.  There may be
  Bignum zero.

* eval.c (rb_call0): new argument added for original method name.
  preserve original method name in frame->orig_func.

* eval.c (is_defined): use frame->orig_func, not last_func.

* eval.c (rb_eval): ditto.

* eval.c (method_call): supply data->oid also to rb_call0().

* object.c (rb_class_allocate_instance): call rb_obj_alloc() when
  called from alias, thus invoke original "allocate".

* eval.c (remove_method): removing allocate from classes should
  cause NameError.

* hash.c (rb_hash_equal): should check default values.

* ext/socket/socket.c (s_recvfrom): update RSTRING len.
@
text
@d185 1
a185 1
  REVISION = '$Id: cgi.rb,v 1.40 2002/07/05 05:04:25 wakou Exp $'
d1256 1
a1256 1
    def form(method = "post", action = nil, enctype = "application/x-www-form-urlencoded")
d1276 1
a1276 1
          "<DIV><INPUT TYPE=HIDDEN NAME=\"#{k}\" VALUE=\"#{v}\"></DIV>"
d1278 5
a1282 1
        body += hidden
@


1.40
log
@	* lib/cgi.rb (CGI#initialize): improvement for mod_ruby.
	thanks to Sean Chittenden <sean@@ruby-lang.org>, Shugo Maeda
	<shugo@@modruby.net>
@
text
@d185 1
a185 1
  REVISION = '$Id: cgi.rb,v 1.37 2002/05/30 00:21:05 wakou Exp $'
d1276 1
a1276 1
          "<INPUT TYPE=HIDDEN NAME=\"#{k}\" VALUE=\"#{v}\">"
@


1.39
log
@	* lib/cgi.rb (CGI#initialize): improvement for mod_ruby.
@
text
@d1900 4
a1903 1
    Apache.request.setup_cgi_env if defined?(MOD_RUBY)
@


1.38
log
@	* lib/cgi.rb (CGI#header): accept any type as value.
@
text
@d1900 1
@


1.37
log
@	* lib/cgi.rb: if StringIO is usable then use it.
@
text
@d185 1
a185 1
  REVISION = '$Id: cgi.rb,v 1.34 2002/04/11 10:03:01 matz Exp $'
d489 1
a489 1
      buf += key + ": " + value + EOL
@


1.36
log
@fix for POST method.
@
text
@d73 1
a73 2
and values[0] has Tempfile class methods.
(Tempfile class object has File class methods)
a793 2
      require "tempfile"

d796 12
a807 1
        body = Tempfile.new("CGI")
@


1.35
log
@	* lib/cgi.rb: not use const if GET, HEAD. check multipart form head.
@
text
@d1908 2
a1909 2
              remove_const(:CGI_PARAMS)
              remove_const(:CGI_COOKIES)
@


1.34
log
@* eval.c (assign): ruby_verbose should be surrounded by RTEST().

* object.c (rb_str2cstr): ditto.

* parse.y (void_expr): ditto.

* parse.y (void_stmts): ditto.

* variable.c (rb_ivar_get): ditto.

* variable.c (rb_cvar_set): ditto.

* variable.c (rb_cvar_get): ditto.

* dir.c (glob_helper): should have proceed link when link->path
  was non existing symbolic link.
@
text
@d11 1
a11 1
Wakou Aoyama <wakou@@fsinet.or.jp>
d186 1
a186 1
  REVISION = '$Id: cgi.rb,v 1.33 2001/11/21 03:30:22 shugo Exp $'
a777 4
    def param(name)
      @@params[name].join("\0")
    end

d791 2
d1893 2
a1894 3
    if defined?(CGI_PARAMS)
      @@params  = CGI_PARAMS.nil?  ? nil : CGI_PARAMS.dup
      @@cookies = CGI_COOKIES.nil? ? nil : CGI_COOKIES.dup
d1896 18
a1913 3
      initialize_query()  # set @@params, @@cookies
      eval "CGI_PARAMS  = @@params.nil?  ? nil : @@params.dup"
      eval "CGI_COOKIES = @@cookies.nil? ? nil : @@cookies.dup"
a1939 11

  if defined?(MOD_RUBY) and (RUBY_VERSION < "1.4.3")
    raise "Please, use ruby1.4.3 or later."
  else
    at_exit() do
      if defined?(CGI_PARAMS)
        remove_const(:CGI_PARAMS)
        remove_const(:CGI_COOKIES)
      end
    end
  end
d1951 2
@


1.33
log
@* lib/cgi.rb: CGI#header: do not set Apache.request.status for
Location: if Apache.request.status is already set.
@
text
@d186 1
a186 1
  REVISION = '$Id: cgi.rb,v 1.32 2001/11/18 20:08:14 wakou Exp $'
d1169 1
a1169 1
    # <INPUT TYPE="checkbox" SELECTED NAME="name" VALUE="bar">bar
d1174 1
a1174 1
    # <INPUT TYPE="checkbox" SELECTED NAME="name" VALUE="2">Bar
d1216 1
a1216 1
    # <INPUT TYPE="file" NAME="name" SIZE="40", MAXLENGTH="100">
d1375 1
a1375 1
    # <INPUT TYPE="image" SRC="url" NAME="name", ALT="string">
d1396 1
a1396 1
    # <IMG SRC="src" ALT="alt" WIDTH="100", HEIGHT="50">
d1399 1
a1399 1
    # <IMG SRC="src" ALT="alt" WIDTH="100", HEIGHT="50">
d1453 1
a1453 1
    # <INPUT TYPE="password" NAME="name" VALUE="value", SIZE="80", MAXLENGTH="200">
d1539 1
a1539 1
    # <INPUT TYPE="radio" NAME="name", VALUE="value">
d1542 1
a1542 1
    # <INPUT TYPE="radio" NAME="name", VALUE="value", CHECKED>
d1568 1
a1568 1
    # <INPUT TYPE="radio" SELECTED NAME="name" VALUE="bar">bar
d1573 1
a1573 1
    # <INPUT TYPE="radio" SELECTED NAME="name" VALUE="2">Bar
d1675 1
a1675 1
    # <INPUT TYPE="text" NAME="name" VALUE="value", SIZE="80">
d1678 1
a1678 1
    # <INPUT TYPE="text" NAME="name" VALUE="value", SIZE="80", MAXLENGTH="200">
@


1.32
log
@	* lib/cgi.rb (header): support for Apache. thanks to
	  Shugo Maeda <shugo@@ruby-lang.org>.
@
text
@d186 1
a186 1
  REVISION = '$Id:$'
d508 3
a510 1
          Apache::request.status = 302
@


1.31
log
@	* lib/cgi.rb: CGI::Cookie::parse(): Ignore duplicate keys caused by
	  Netscape bug.
@
text
@d502 1
d507 3
@


1.30
log
@	* lib/cgi.rb: CGI#doctype(): bug fix (html4Fr).

	* lib/net/telnet.rb, lib/cgi.rb: remove VERSION, RELEASE_DATE,
	  VERSION_CODE, RELEASE_CODE. please use REVISION.

	* lib/cgi.rb: CGI#header(): bug fix.

	* lib/net/telnet.rb, lib/cgi.rb: concat --> +=
@
text
@d701 1
a701 3
      if cookies.has_key?(name)
        cookies[name].value.push(*values)
      else
@


1.29
log
@Wed Apr 18 04:37:51 2001  Wakou Aoyama  <wakou@@fsinet.or.jp>

	* lib/cgi.rb: CGI::Cookie: no use PATH_INFO.
@
text
@a6 2
Version 2.1.4

d170 3
a172 3
  CGI.new("html4")    # html4.0 (Strict)
  CGI.new("html4Tr")  # html4.0 Transitional
  CGI.new("html4Fr")  # html4.0 Frameset
a185 4
  VERSION = '2.1.4'
  RELEASE_DATE = '2001-04-18'
  VERSION_CODE = 214
  RELEASE_CODE = 20010418
d408 2
a409 1
    if options.kind_of?(String)
d411 2
d420 1
a420 2
      options["type"].concat( "; charset=" )
      options["type"].concat( options.delete("charset") )
d425 4
a428 9
      buf.concat( (env_table["SERVER_PROTOCOL"] or "HTTP/1.0")  + " " )
      buf.concat( (HTTP_STATUS[options["status"]] or
                      options["status"] or
                      "200 OK"
                     ) + EOL
      )
      buf.concat(
        "Date: " + CGI::rfc1123_date(Time.now) + EOL
      )
d442 2
a443 2
      status = (HTTP_STATUS[options["status"]] or options["status"])
      buf.concat("Status: " + status + EOL)
d448 1
a448 1
      buf.concat("Server: " + options.delete("server") + EOL)
d452 1
a452 1
      buf.concat("Connection: " + options.delete("connection") + EOL)
d455 1
a455 1
    buf.concat("Content-Type: " + options.delete("type") + EOL)
d458 1
a458 1
      buf.concat("Content-Length: " + options.delete("length").to_s + EOL)
d462 1
a462 1
      buf.concat("Content-Language: " + options.delete("language") + EOL)
d466 1
a466 1
      buf.concat("Expires: " + CGI::rfc1123_date( options.delete("expires") ) + EOL)
d472 1
a472 1
        buf.concat("Set-Cookie: " + options.delete("cookie").to_s + EOL)
d475 1
a475 1
          buf.concat("Set-Cookie: " + cookie.to_s + EOL)
d479 1
a479 1
          buf.concat("Set-Cookie: " + cookie.to_s + EOL)
d485 1
a485 1
        buf.concat("Set-Cookie: " + cookie.to_s + EOL)
d490 1
a490 1
      buf.concat(key + ": " + value + EOL)
d657 1
a657 1
      buf.concat(@@name + '=')
d660 1
a660 1
        buf.concat CGI::escape(@@value)
d662 1
a662 1
        buf.concat(@@value.collect{|v| CGI::escape(v) }.join("&"))
d666 1
a666 1
        buf.concat('; domain=' + @@domain)
d670 1
a670 1
        buf.concat('; path=' + @@path)
d674 1
a674 1
        buf.concat('; expires=' + CGI::rfc1123_date(@@expires))
d678 1
a678 1
        buf.concat('; secure')
d820 1
a820 1
          buf.concat c
d1268 1
a1268 1
        body.concat hidden
d1342 1
a1342 1
          buf.concat( attributes.delete("DOCTYPE") )
d1347 1
a1347 1
        buf.concat( doctype )
d1351 1
a1351 1
        buf.concat( super(attributes){ yield } )
d1353 1
a1353 1
        buf.concat( super(attributes) )
d1732 1
a1732 1
        methods.concat( <<-BEGIN + nn_element_def(element) + <<-END )
d1742 1
a1742 1
        methods.concat( <<-BEGIN + nOE_element_def(element) + <<-END )
d1752 1
a1752 1
        methods.concat( <<-BEGIN + nO_element_def(element) + <<-END )
d1779 1
a1779 1
        methods.concat( <<-BEGIN + nn_element_def(element) + <<-END )
d1788 1
a1788 1
        methods.concat( <<-BEGIN + nOE_element_def(element) + <<-END )
d1798 1
a1798 1
        methods.concat( <<-BEGIN + nO_element_def(element) + <<-END )
d1826 1
a1826 1
        methods.concat( <<-BEGIN + nn_element_def(element) + <<-END )
d1836 1
a1836 1
        methods.concat( <<-BEGIN + nOE_element_def(element) + <<-END )
d1846 1
a1846 1
        methods.concat( <<-BEGIN + nO_element_def(element) + <<-END )
a1864 3
      extend TagMaker
      extend Html4Tr
      element_init()
d1868 1
a1868 1
        methods.concat( <<-BEGIN + nn_element_def(element) + <<-END )
d1877 1
a1877 1
        methods.concat( <<-BEGIN + nOE_element_def(element) + <<-END )
d1916 2
@


1.28
log
@very sorry check miss.
@
text
@d188 2
a189 2
  VERSION = '2.1.3'
  RELEASE_DATE = '2001-03-18'
d191 1
a191 1
  RELEASE_CODE = 20010318
a645 5
      elsif ENV["REQUEST_URI"]
        @@path = ENV["REQUEST_URI"].sub(/\?.*/n,'')
        if ENV["PATH_INFO"]
          @@path = @@path[0...@@path.rindex(ENV["PATH_INFO"])]
        end
d647 2
a648 1
        @@path = (ENV["SCRIPT_NAME"] or "")
@


1.27
log
@sorry erase miss.
@
text
@d427 1
a427 1
    options.delete("nph") if MOD_RUBY
@


1.26
log
@Sun Mar 18 08:58:18 2001  Wakou Aoyama  <wakou@@fsinet.or.jp>

	* lib/net/cgi.rb: // === '' --> //.match('')

	* lib/net/cgi.rb: cgi#header(): improvement for mod_ruby.

	* lib/net/cgi.rb: cgi#rfc1123date(): improvement.
	  thanks to TADA Tadashi <sho@@spc.gr.jp>.

	* lib/net/cgi.rb: cgi#rfc1123date(): document bug fix.
	  thanks to Kazuhiro NISHIYAMA <zn@@mbf.nifty.com>.

	* lib/net/cgi.rb: cgi#header(): bug fix.
	  thanks to IWATSUKI Hiroyuki <don@@na.rim.or.jp>.
@
text
@d919 1
a919 1
         (%r|\Amultipart/form-data.*boundary=\"?([^\";,]+)\"?|n.match(env_table['CONTENT_TYPE'])
@


1.25
log
@Mon Feb 26 04:55:50 2001  Wakou Aoyama  <wakou@@fsinet.or.jp>

	* lib/cgi.rb: CGI#form(): bug fix.
	  thanks to MoonWolf <moonwolf@@moonwolf.com>.

	* lib/cgi.rb: CGI#rfc1123_date(): improvement.
	  thanks to Tomoyasu Akita <genzo-@@dm4lab.to>.

	* lib/cgi.rb: CGI#header(): improvement for mod_ruby.
	  thanks to Shugo Maeda <shugo@@ruby-lang.org>.
@
text
@d7 1
a7 1
Version 2.1.3
d189 3
a191 3
  RELEASE_DATE = '2001-02-26'
  VERSION_CODE = 213
  RELEASE_CODE = 20010226
d194 1
a194 1
  NEEDS_BINMODE = true if /WIN/ni === RUBY_PLATFORM
d354 1
a354 1
    # Sat, 1 Jan 2000 00:00:00 GMT
d358 1
a358 1
    return format("%s, %.2d %s %d %.2d:%.2d:%.2d GMT",
d427 2
a428 1
    if options.delete("nph") or (/IIS/n === env_table['SERVER_SOFTWARE'])
d451 1
a451 1
      status = HTTP_STATUS[options["status"]] or options["status"]
d813 1
a813 1
        until head and (/#{boundary}(?:#{EOL}|--)/n === buf)
d815 1
a815 1
          if (not head) and (/#{EOL}#{EOL}/n === buf)
d854 1
a854 1
        /Content-Disposition:.* filename="?([^\";]*)"?/ni === head
d859 3
a861 3
              if (/Mac/ni === env_table['HTTP_USER_AGENT']) and
                 (/Mozilla/ni === env_table['HTTP_USER_AGENT']) and
                 (not /MSIE/ni === env_table['HTTP_USER_AGENT'])
d870 1
a870 1
        /Content-Type: (.*)/ni === head
d877 1
a877 1
        /Content-Disposition:.* name="?([^\";]*)"?/ni === head
d909 1
a909 1
      if words.find{|x| /=/n === x }
d919 1
a919 2
         (%r|\Amultipart/form-data.*boundary=\"?([^\";,]+)\"?|n ===
           env_table['CONTENT_TYPE'])
@


1.24
log
@* lib/cgi.rb: fix the problem that when running under mod_ruby
header() outputs only one Set-Cookie line.

Approved by:	wakou, matz
@
text
@d7 1
a7 1
Version 2.1.2
d188 5
a192 4
  VERSION = "2.1.2"
  RELEASE_DATE = "2000-12-25"
  VERSION_CODE = 212
  RELEASE_CODE = 20001225
d358 1
a358 1
    return format("%s, %d %s %d %.2d:%.2d:%.2d GMT",
d450 3
a452 1
      buf.concat("Status: " + options.delete("status") + EOL)
d503 14
a516 6
      buf.scan(/([^:]+): (.+)#{EOL}/n){
        if $1 == 'Set-Cookie'
	  table.add($1, $2)
	else
	  table.set($1, $2)
	end
d994 2
a995 2
  cgi.element({ "ATTRILUTE1" => "value1", "ATTRIBUTE2" => "value2" })
  cgi.element({ "ATTRILUTE1" => "value1", "ATTRIBUTE2" => "value2" }){ "string" }
d1254 1
a1254 1
  form({"METHOD" => "post", ENCTYPE => "enctype"}){ "string" }
d1256 2
d1265 1
a1265 1
                       method["METHOD"] = method
d1956 2
a1957 155
* Mon Dec 25 05:02:27 JST 2000 - wakou
  * version 2.1.2
  * bug fix: CGI::escapeElement(): didn't accept empty element.
  * bug fix: CGI::unescapeElement(): ditto.
  * bug fix: CGI::unescapeHTML(): support for "&copy;, &hearts;, ..."
    thanks to YANAGAWA Kazuhisa <kjana@@os.xaxon.ne.jp>
  * bug fix: CGI::unescapeHTML(): support for "&#09;"
    thanks to OHSHIMA Ryunosuke <ryu@@jaist.ac.jp>
  * Regexp::last_match[0] --> $&
  * Regexp::last_match[1] --> $1
  * Regexp::last_match[2] --> $2
  * add: CGI#param(): test implement. undocumented.

* Mon Dec 11 00:16:51 JST 2000 - wakou
  * version 2.1.1
  * support -T1 on ruby 1.6.2
    * body.original_filename: eval(str.dump.untaint).taint
    * body.content_type: eval(str.dump.untaint).taint
  * $& --> Regexp::last_match[0]
  * $1 --> Regexp::last_match[1]
  * $2 --> Regexp::last_match[2]

* Thu Oct 12 01:16:59 JST 2000 - wakou
  * version 2.1.0
  * bug fix: CGI::html(): PRETTY option didn't work.
    thanks to akira yamada <akira@@ruby-lang.org>

* Wed Sep 13 06:09:26 JST 2000 - wakou
  * version 2.0.1
  * bug fix: CGI::header(): output status header.
    thanks to Yasuhiro Fukuma <yasuf@@bsdclub.org>

* Tue Sep 12 06:56:51 JST 2000 - wakou
  * version 2.0.0
  * require ruby1.5.4 or later. (ruby1.4 doesn't have block_given? method.)
  * improvement: CGI::escape(), CGI::unescape().
    thanks to WATANABE Hirofumi <eban@@os.rim.or.jp>
  * bug fix: CGI::escapeElement().
  * improvement: CGI::unescapeHTML().
    thanks to Kazuhiro NISHIYAMA <zn@@mbf.nifty.com>

* 2000/08/09 04:32:22 - matz
  * improvement: CGI::pretty()

* 2000/06/23 07:01:34 - matz
  * change: iterator? --> block_given?

* Sun Jun 18 23:31:44 JST 2000 - wakou
  * version 1.7.0
  * change: version syntax. old: x.yz, now: x.y.z

* 2000/06/13 15:49:27 - wakou
  * version 1.61
  * read_multipart(): if no content body then raise EOFError.

* 2000/06/03 18:16:17 - wakou
  * version 1.60
  * improve: CGI::pretty()

* 2000/05/30 19:04:08 - wakou
  * version 1.50
  * CGI#out(): if "HEAD" == REQUEST_METHOD then output only HTTP header.

* 2000/05/24 06:58:51 - wakou
  * version 1.40
  * typo: CGI::Cookie::new()
  * bug fix: CGI::escape():  bad: " " --> "%2B";  true: " " --> "+";
    thanks to Ryunosuke Ohshima <ryu@@jaist.ac.jp>

* 2000/05/08 21:51:30 - wakou
  * version 1.31
  * improvement of time forming new CGI object accompanied with HTML generation methods.

* 2000/05/07 21:51:14 - wakou
  * version 1.30
  * require English.rb
  * improvement of load time.

* 2000/05/02 21:44:12 - wakou
  * version 1.21
  * support for ruby 1.5.3 (2000-05-01) (Array#filter --> Array#collect!)

* 2000/04/03 18:31:42 - wakou
  * version 1.20
  * bug fix: CGI#image_button() can't get Hash option.
    thanks to Takashi Ikeda <ikeda@@auc.co.jp>
  * CGI::unescapeHTML(): simple support for "&#12345;"
  * CGI::Cookie::new(): simple support for IE
  * CGI::escape(): ' ' replaced by '+'

* 1999/12/06 20:16:34 - wakou
  * version 1.10
  * can make many CGI objects.
  * if use mod_ruby, then require ruby1.4.3 or later.

* 1999/11/29 21:35:58 - wakou
  * version 1.01
  * support for ruby 1.5.0 (1999-11-20)

* 1999/09/13 23:00:58 - wakou
  * version 1.00
  * COUTION! name change. CGI.rb --> cgi.rb
  * CGI#auth_type, CGI#content_length, CGI#content_type, ...
    if not ENV included it, then return nil.
  * CGI#content_length and CGI#server_port return Integer.
  * if not CGI#params.include?('name'), then CGI#params['name'] return [].
  * if not CGI#cookies.include?('name'), then CGI#cookies['name'] return [].

* 1999/08/05 18:04:59 - wakou
  * version 0.41
  * typo. thanks to MJ Ray <markj@@altern.org>
      HTTP_STATUS["NOT_INPLEMENTED"] --> HTTP_STATUS["NOT_IMPLEMENTED"]

* 1999/07/20 20:44:31 - wakou
  * version 0.40
  * COUTION! incompatible change.
    sorry, but probably this change is last big incompatible change.
  * CGI::print  -->  CGI#out
      cgi = CGI.new
      cgi.out{"string"}             # old: CGI::print{"string"}
  * CGI::cookie  --> CGI::Cookie::new
      cookie1 = CGI::Cookie::new    # old: CGI::cookie
  * CGI::header  -->  CGI#header

* 1999/06/29 06:50:21 - wakou
  * version 0.30
  * COUTION! incompatible change.
      query = CGI.new
      cookies = query.cookies       # old: query.cookie
      values = query.cookies[name]  # old: query.cookie[name]

* 1999/06/21 21:05:57 - wakou
  * version 0.24
  * CGI::Cookie::parse() return { name => CGI::Cookie object } pairs.

* 1999/06/20 23:29:12 - wakou
  * version 0.23
  * modified a bit to clear module separation.

* Mon Jun 14 17:49:32 JST 1999 - matz
  * version 0.22
  * Cookies are now CGI::Cookie objects.
  * Cookie modeled after CGI::Cookie.pm.

* Fri Jun 11 11:19:11 JST 1999 - matz
  * version 0.21
  * modified a bit to clear module separation.

* 1999/06/03 06:48:15 - wakou
  * version 0.20
  * support for multipart form.

* 1999/05/24 07:05:41 - wakou
  * version 0.10
  * first release.
a1958 1
$Date: 2000/12/24 20:20:45 $
@


1.23
log
@wakou
@
text
@d499 1
d501 5
a505 1
        Apache::request[$1] = $2
d2099 1
a2099 1
$Date: 2000/12/22 09:00:19 $
@


1.23.2.1
log
@Mon Feb 26 04:55:50 2001  Wakou Aoyama  <wakou@@fsinet.or.jp>

	* lib/cgi.rb: CGI#form(): bug fix.
	  thanks to MoonWolf <moonwolf@@moonwolf.com>.

	* lib/cgi.rb: CGI#rfc1123_date(): improvement.
	  thanks to Tomoyasu Akita <genzo-@@dm4lab.to>.

	* lib/cgi.rb: CGI#header(): improvement for mod_ruby.
	  thanks to Shugo Maeda <shugo@@ruby-lang.org>.
@
text
@d7 1
a7 1
Version 2.1.3
d188 4
a191 5
  VERSION = '2.1.3'
  RELEASE_DATE = '2001-02-26'
  VERSION_CODE = 213
  RELEASE_CODE = 20010226
  REVISION = '$Id:$'
d357 1
a357 1
    return format("%s, %.2d %s %d %.2d:%.2d:%.2d GMT",
d449 1
a449 3
      status = HTTP_STATUS[options["status"]] or options["status"]
      buf.concat("Status: " + status + EOL)
      options.delete("status")
d499 2
a500 15
      table = Apache::request.headers_out
      buf.scan(/([^:]+): (.+)#{EOL}/n){ |name, value|
        $stderr.printf("name:%s value:%s\n", name, value) if $DEBUG
        case name
        when 'Set-Cookie'
          table.add($1, $2)
        when /^status$/ni
          Apache::request.status_line = value
        when /^content-type$/ni
          Apache::request.content_type = value
        when /^content-encoding$/ni
          Apache::request.content_encoding = value
        else
          Apache::request.headers_out[name] = value
        end
d978 2
a979 2
  cgi.element({ "ATTRIBUTE1" => "value1", "ATTRIBUTE2" => "value2" })
  cgi.element({ "ATTRIBUTE1" => "value1", "ATTRIBUTE2" => "value2" }){ "string" }
d1238 1
a1238 1
  form({"METHOD" => "post", "ENCTYPE" => "enctype"}){ "string" }
a1239 2

The hash keys are case sensitive. Ask the samples.
d1247 1
a1247 1
                       method["METHOD"] = "post"
d1938 155
a2092 2
delete. see cvs log.

d2094 1
@


1.23.2.2
log
@Sun Mar 18 08:58:18 2001  Wakou Aoyama  <wakou@@fsinet.or.jp>

	* lib/net/cgi.rb: // === '' --> //.match('')

	* lib/net/cgi.rb: cgi#header(): improvement for mod_ruby.

	* lib/net/cgi.rb: cgi#rfc1123date(): improvement.
	  thanks to TADA Tadashi <sho@@spc.gr.jp>.

	* lib/net/cgi.rb: cgi#rfc1123date(): document bug fix.
	  thanks to Kazuhiro NISHIYAMA <zn@@mbf.nifty.com>.

	* lib/net/cgi.rb: cgi#header(): bug fix.
	  thanks to IWATSUKI Hiroyuki <don@@na.rim.or.jp>.
@
text
@d7 1
a7 1
Version 2.1.4
d189 3
a191 3
  RELEASE_DATE = '2001-03-18'
  VERSION_CODE = 214
  RELEASE_CODE = 20010318
d194 1
a194 1
  NEEDS_BINMODE = true if /WIN/ni.match(RUBY_PLATFORM)
d354 1
a354 1
    # Sat, 01 Jan 2000 00:00:00 GMT
d358 1
a358 1
    return format("%s, %.2d %s %.4d %.2d:%.2d:%.2d GMT",
d427 1
a427 2
    options.delete("nph") if MOD_RUBY
    if options.delete("nph") or /IIS/n.match(env_table['SERVER_SOFTWARE'])
d450 1
a450 1
      status = (HTTP_STATUS[options["status"]] or options["status"])
d812 1
a812 1
        until head and /#{boundary}(?:#{EOL}|--)/n.match(buf)
d814 1
a814 1
          if (not head) and /#{EOL}#{EOL}/n.match(buf)
d853 1
a853 1
        /Content-Disposition:.* filename="?([^\";]*)"?/ni.match(head)
d858 3
a860 3
              if /Mac/ni.match(env_table['HTTP_USER_AGENT']) and
                 /Mozilla/ni.match(env_table['HTTP_USER_AGENT']) and
                 (not /MSIE/ni.match(env_table['HTTP_USER_AGENT']))
d869 1
a869 1
        /Content-Type: (.*)/ni.match(head)
d876 1
a876 1
        /Content-Disposition:.* name="?([^\";]*)"?/ni.match(head)
d908 1
a908 1
      if words.find{|x| /=/n.match(x) }
d918 2
a919 1
         (%r|\Amultipart/form-data.*boundary=\"?([^\";,]+)\"?|n.match(env_table['CONTENT_TYPE'])
@


1.23.2.3
log
@sorry erase miss.
@
text
@d919 1
a919 1
         %r|\Amultipart/form-data.*boundary=\"?([^\";,]+)\"?|n.match(env_table['CONTENT_TYPE'])
@


1.23.2.4
log
@very sorry check miss.
@
text
@d427 1
a427 1
    options.delete("nph") if defined?(MOD_RUBY)
@


1.23.2.5
log
@Wed Apr 18 04:37:51 2001  Wakou Aoyama  <wakou@@fsinet.or.jp>

	* lib/cgi.rb: CGI::Cookie: no use PATH_INFO.
@
text
@d188 2
a189 2
  VERSION = '2.1.4'
  RELEASE_DATE = '2001-04-18'
d191 1
a191 1
  RELEASE_CODE = 20010418
d646 5
d652 1
a652 2
        %r|^(.*/)|.match(ENV["SCRIPT_NAME"])
        @@path = ($1 or "")
@


1.23.2.6
log
@	* lib/cgi.rb: CGI#doctype(): bug fix (html4Fr).

	* lib/net/telnet.rb, lib/cgi.rb: remove VERSION, RELEASE_DATE,
	  VERSION_CODE, RELEASE_CODE. please use REVISION.

	* lib/cgi.rb: CGI#header(): bug fix.

	* lib/net/telnet.rb, lib/cgi.rb: concat --> +=
@
text
@d7 2
d172 3
a174 3
  CGI.new("html4")    # html4.01 (Strict)
  CGI.new("html4Tr")  # html4.01 Transitional
  CGI.new("html4Fr")  # html4.01 Frameset
d188 4
d414 1
a414 2
    case options
    when String
a415 2
    when Hash
      options = options.dup
d423 2
a424 1
      options["type"] += "; charset=" + options.delete("charset")
d429 9
a437 4
      buf += (env_table["SERVER_PROTOCOL"] or "HTTP/1.0")  + " " +
             (HTTP_STATUS[options["status"]] or options["status"] or "200 OK") +
             EOL +
             "Date: " + CGI::rfc1123_date(Time.now) + EOL
d451 2
a452 2
      buf += "Status: " +
             (HTTP_STATUS[options["status"]] or options["status"]) + EOL
d457 1
a457 1
      buf += "Server: " + options.delete("server") + EOL
d461 1
a461 1
      buf += "Connection: " + options.delete("connection") + EOL
d464 1
a464 1
    buf += "Content-Type: " + options.delete("type") + EOL
d467 1
a467 1
      buf += "Content-Length: " + options.delete("length").to_s + EOL
d471 1
a471 1
      buf += "Content-Language: " + options.delete("language") + EOL
d475 1
a475 1
      buf += "Expires: " + CGI::rfc1123_date( options.delete("expires") ) + EOL
d481 1
a481 1
        buf += "Set-Cookie: " + options.delete("cookie").to_s + EOL
d484 1
a484 1
          buf += "Set-Cookie: " + cookie.to_s + EOL
d488 1
a488 1
          buf += "Set-Cookie: " + cookie.to_s + EOL
d494 1
a494 1
        buf += "Set-Cookie: " + cookie.to_s + EOL
d499 1
a499 1
      buf += key + ": " + value + EOL
d666 1
a666 1
      buf += @@name + '='
d669 1
a669 1
        buf += CGI::escape(@@value)
d671 1
a671 1
        buf += @@value.collect{|v| CGI::escape(v) }.join("&")
d675 1
a675 1
        buf += '; domain=' + @@domain
d679 1
a679 1
        buf += '; path=' + @@path
d683 1
a683 1
        buf += '; expires=' + CGI::rfc1123_date(@@expires)
d687 1
a687 1
        buf += '; secure'
d829 1
a829 1
          buf += c
d1277 1
a1277 1
        body += hidden
d1351 1
a1351 1
          buf += attributes.delete("DOCTYPE")
d1356 1
a1356 1
        buf += doctype
d1360 1
a1360 1
        buf += super(attributes){ yield }
d1362 1
a1362 1
        buf += super(attributes)
d1741 1
a1741 1
        methods += <<-BEGIN + nn_element_def(element) + <<-END
d1751 1
a1751 1
        methods += <<-BEGIN + nOE_element_def(element) + <<-END
d1761 1
a1761 1
        methods += <<-BEGIN + nO_element_def(element) + <<-END
d1788 1
a1788 1
        methods += <<-BEGIN + nn_element_def(element) + <<-END
d1797 1
a1797 1
        methods += <<-BEGIN + nOE_element_def(element) + <<-END
d1807 1
a1807 1
        methods += <<-BEGIN + nO_element_def(element) + <<-END
d1835 1
a1835 1
        methods += <<-BEGIN + nn_element_def(element) + <<-END
d1845 1
a1845 1
        methods += <<-BEGIN + nOE_element_def(element) + <<-END
d1855 1
a1855 1
        methods += <<-BEGIN + nO_element_def(element) + <<-END
d1874 3
d1880 1
a1880 1
        methods += <<-BEGIN + nn_element_def(element) + <<-END
d1889 1
a1889 1
        methods += <<-BEGIN + nOE_element_def(element) + <<-END
a1927 2
      extend Html4Tr
      element_init()
@


1.23.2.7
log
@	* lib/cgi.rb: CGI::Cookie::parse(): Ignore duplicate keys caused by
	  Netscape bug.
@
text
@d701 3
a703 1
      unless cookies.has_key?(name)
@


1.23.2.8
log
@	* lib/cgi.rb (header): support for Apache. thanks to
	  Shugo Maeda <shugo@@ruby-lang.org>.
@
text
@a501 1
          Apache::request.status = value.to_i
a505 3
        when /^location$/ni
          Apache::request.status = 302
          Apache::request.headers_out[name] = value
@


1.23.2.9
log
@* file.c (rb_find_file): load must be done from an abolute path if
  $SAFE >= 4.

* re.c (rb_reg_s_quote): quote whitespaces for /x cases.

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* eval.c (rb_thread_cleanup): current thread may be THREAD_STOPPED,
  for example when terminated from signal handler.

* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.

* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* marshal.c (w_uclass): should check based on rb_obj_class(), not
  CLASS_OF().

* io.c (io_write): check error if written data is less than
  specified size to detect EPIPE.

* eval.c (assign): ruby_verbose should be surrounded by RTEST().

* object.c (rb_str2cstr): ditto.

* parse.y (void_expr): ditto.

* parse.y (void_stmts): ditto.

* variable.c (rb_ivar_get): ditto.

* variable.c (rb_cvar_set): ditto.

* variable.c (rb_cvar_get): ditto.
@
text
@d186 1
a186 1
  REVISION = '$Id: cgi.rb,v 1.23.2.8 2001/11/18 20:06:05 wakou Exp $'
d1167 1
a1167 1
    # <INPUT TYPE="checkbox" CHECKED NAME="name" VALUE="bar">bar
d1172 1
a1172 1
    # <INPUT TYPE="checkbox" CHECKED NAME="name" VALUE="2">Bar
d1214 1
a1214 1
    # <INPUT TYPE="file" NAME="name" SIZE="40" MAXLENGTH="100">
d1373 1
a1373 1
    # <INPUT TYPE="image" SRC="url" NAME="name" ALT="string">
d1394 1
a1394 1
    # <IMG SRC="src" ALT="alt" WIDTH="100" HEIGHT="50">
d1397 1
a1397 1
    # <IMG SRC="src" ALT="alt" WIDTH="100" HEIGHT="50">
d1451 1
a1451 1
    # <INPUT TYPE="password" NAME="name" VALUE="value" SIZE="80" MAXLENGTH="200">
d1537 1
a1537 1
    # <INPUT TYPE="radio" NAME="name" VALUE="value">
d1540 1
a1540 1
    # <INPUT TYPE="radio" NAME="name" VALUE="value" CHECKED>
d1566 1
a1566 1
    # <INPUT TYPE="radio" CHECKED NAME="name" VALUE="bar">bar
d1571 1
a1571 1
    # <INPUT TYPE="radio" CHECKED NAME="name" VALUE="2">Bar
d1673 1
a1673 1
    # <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="80">
d1676 1
a1676 1
    # <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="80" MAXLENGTH="200">
@


1.23.2.10
log
@	* lib/cgi.rb: not use const if GET, HEAD. check multipart form head.
@
text
@d11 1
a11 1
Wakou Aoyama <wakou@@ruby-lang.org>
d186 1
a186 1
  REVISION = '$Id: cgi.rb,v 1.34 2002/04/11 10:03:01 matz Exp $'
d508 1
a508 3
	  if Apache::request.status == 200
	    Apache::request.status = 302
	  end
d776 4
a792 2
      elsif boundary + EOL != status
        raise EOFError, "bad content body"
d1893 4
a1896 1
    if "POST" != env_table['REQUEST_METHOD']
d1898 2
a1899 19
    else
      if defined?(CGI_PARAMS)
        @@params  = CGI_PARAMS.nil?  ? nil : CGI_PARAMS.dup
        @@cookies = CGI_COOKIES.nil? ? nil : CGI_COOKIES.dup
      else
        initialize_query()  # set @@params, @@cookies
        eval "CGI_PARAMS  = @@params.nil?  ? nil : @@params.dup"
        eval "CGI_COOKIES = @@cookies.nil? ? nil : @@cookies.dup"
        if defined?(MOD_RUBY) and (RUBY_VERSION < "1.4.3")
          raise "Please, use ruby1.4.3 or later."
        else
          at_exit() do
            if defined?(CGI_PARAMS)
              remove_const(:CGI_PARAMS)
              remove_const(:CGI_COOKIES)
            end
          end
        end
      end
d1926 11
a1947 2

# vi:set tw=0:
@


1.23.2.11
log
@fix for POST method.
@
text
@d1908 2
a1909 2
              self.class.class_eval("remove_const(:CGI_PARAMS)")
              self.class.class_eval("remove_const(:CGI_COOKIES)")
@


1.23.2.12
log
@	* lib/cgi.rb: if StringIO is usable then use it.
@
text
@d73 2
a74 1
and values[0] has StringIO or Tempfile class methods.
d795 2
d799 1
a799 12
        if 10240 < content_length
          require "tempfile"
          body = Tempfile.new("CGI")
        else
          begin
            require "stringio" if not defined? StringIO
            body = StringIO.new
          rescue LoadError
            require "tempfile"
            body = Tempfile.new("CGI")
          end
        end
@


1.23.2.13
log
@	* lib/cgi.rb (CGI#header): accept any type as value.
@
text
@d185 1
a185 1
  REVISION = '$Id: cgi.rb,v 1.37 2002/05/30 00:21:05 wakou Exp $'
d489 1
a489 1
      buf += key + ": " + value.to_s + EOL
@


1.23.2.14
log
@	* lib/cgi.rb (CGI#initialize): improvement for mod_ruby.
@
text
@a1899 1
    Apache.request.setup_cgi_env if defined?(MOD_RUBY)
@


1.23.2.15
log
@	* lib/cgi.rb (CGI#initialize): improvement for mod_ruby.
	thanks to Sean Chittenden <sean@@ruby-lang.org>, Shugo Maeda
	<shugo@@modruby.net>
@
text
@d1900 1
a1900 4
    if defined?(MOD_RUBY) && !ENV.key?("GATEWAY_INTERFACE")
      Apache.request.setup_cgi_env
    end

@


1.23.2.16
log
@* hash.c (rb_hash_equal): should check default values.

* ext/socket/socket.c (s_recvfrom): update RSTRING len.
@
text
@d185 1
a185 1
  REVISION = '$Id: cgi.rb,v 1.23.2.15 2002/07/05 05:03:36 wakou Exp $'
d1276 1
a1276 1
          "<DIV><INPUT TYPE=HIDDEN NAME=\"#{k}\" VALUE=\"#{v}\"></DIV>"
@


1.23.2.17
log
@	* lib/cgi.rb (CGI#form): fix ruby-bugs-ja:PR#280, add default action.
@
text
@d185 1
a185 1
  REVISION = '$Id: cgi.rb,v 1.41 2002/08/12 07:39:12 matz Exp $'
d1256 1
a1256 1
    def form(method = "post", action = script_name, enctype = "application/x-www-form-urlencoded")
d1276 1
a1276 1
          "<INPUT TYPE=HIDDEN NAME=\"#{k}\" VALUE=\"#{v}\">"
d1278 1
a1278 5
        if defined? fieldset
          body += fieldset{ hidden }
        else
          body += hidden
        end
@


1.22
log
@matz
@
text
@d7 1
a7 1
Version 2.1.1
d188 4
a191 4
  VERSION = "2.1.1"
  RELEASE_DATE = "2000-12-14"
  VERSION_CODE = 211
  RELEASE_CODE = 20001214
d244 1
a244 1
      '%' + Regexp::last_match[1].unpack('H2' * Regexp::last_match[1].size).join('%').upcase
d255 1
a255 1
      [Regexp::last_match[1].delete('%')].pack('H*')
d275 1
a275 1
      match = Regexp::last_match[1].dup
d281 3
a283 3
      when /\A#(\d+)\z/n         then
        if Integer(Regexp::last_match[1]) < 256
          Integer(Regexp::last_match[1]).chr
d285 2
a286 2
          if Integer(Regexp::last_match[1]) < 65536 and ($KCODE[0] == ?u or $KCODE[0] == ?U)
            [Integer(Regexp::last_match[1])].pack("U")
d288 1
a288 1
            "&##{Regexp::last_match[1]};"
d292 2
a293 2
        if Regexp::last_match[1].hex < 256
          Regexp::last_match[1].hex.chr
d295 2
a296 2
          if Regexp::last_match[1].hex < 65536 and ($KCODE[0] == ?u or $KCODE[0] == ?U)
            [Regexp::last_match[1].hex].pack("U")
d298 1
a298 1
            "&#x#{Regexp::last_match[1]};"
d302 1
a302 1
        "&#{Regexp::last_match[1]};"
d316 5
a320 4
  def CGI::escapeElement(string, *element)
    unless element.empty?
      string.gsub(/<\/?(?:#{element.join("|")})(?!\w)(?:.|\n)*?>/ni) do
        CGI::escapeHTML(Regexp::last_match[0])
d338 8
a345 3
  def CGI::unescapeElement(string, *element)
    string.gsub(/&lt;\/?(?:#{element.join("|")})(?!\w)(?:.|\n)*?&gt;/ni) do
      CGI::unescapeHTML(Regexp::last_match[0])
d500 1
a500 1
        Apache::request[Regexp::last_match[1]] = Regexp::last_match[2]
d770 4
d800 1
a800 1
              head = Regexp::last_match[1].dup
d822 2
a823 2
          body.print Regexp::last_match[1]
          if "--" == Regexp::last_match[2]
d856 1
a856 1
            #{(Regexp::last_match[1] or "").dump.untaint}.taint
d861 1
a861 1
        name = Regexp::last_match[1].dup
d904 1
a904 1
        boundary = Regexp::last_match[1].dup
d964 1
a964 1
      element = Regexp::last_match[1].dup
d1938 13
d2094 1
a2094 1
$Date: 2000/12/14 00:26:01 $
@


1.21
log
@wakou
@
text
@d831 1
a831 1
              filename = (Regexp::last_match[1] or "").dup
d2071 1
a2071 1
$Date: 2000/10/11 16:28:15 $
@


1.20
log
@wakou
@
text
@d7 1
a7 1
Version 2.1.0
d188 4
a191 4
  VERSION = "2.1.0"
  RELEASE_DATE = "2000-10-12"
  VERSION_CODE = 210
  RELEASE_CODE = 20001012
d244 1
a244 1
      '%' + $1.unpack('H2' * $1.size).join('%').upcase
d255 1
a255 1
      [$1.delete('%')].pack('H*')
d275 1
a275 1
      match = $1.dup
d282 2
a283 2
        if Integer($1) < 256
          Integer($1).chr
d285 2
a286 2
          if Integer($1) < 65536 and ($KCODE[0] == ?u or $KCODE[0] == ?U)
            [Integer($1)].pack("U")
d288 1
a288 1
            "&##{$1};"
d292 2
a293 2
        if $1.hex < 256
          $1.hex.chr
d295 2
a296 2
          if $1.hex < 65536 and ($KCODE[0] == ?u or $KCODE[0] == ?U)
            [$1.hex].pack("U")
d298 1
a298 1
            "&#x#{$1};"
d302 1
a302 1
        "&#{$1};"
d319 1
a319 1
        CGI::escapeHTML($&)
d339 1
a339 1
      CGI::unescapeHTML($&)
d494 1
a494 1
        Apache::request[$1] = $2
d790 1
a790 1
              head = $1.dup
d812 2
a813 2
          body.print $1
          if "--" == $2
d831 1
a831 1
              filename = ($1 or "").dup
d838 2
a839 2
              end.dump
            }
d846 1
a846 1
            #{($1 or "").dump}
d851 1
a851 1
        name = $1.dup
d894 1
a894 1
        boundary = $1.dup
d954 1
a954 1
      element = $1.dup
d1928 9
d2071 1
a2071 1
$Date: 2000/09/11 22:02:35 $
@


1.19
log
@matz
@
text
@d7 1
a7 1
Version 2.0.1
d188 4
a191 4
  VERSION = "2.0.1"
  RELEASE_DATE = "2000-09-13"
  VERSION_CODE = 201
  RELEASE_CODE = 20000913
d1322 1
d1928 5
d2062 1
a2062 1
$Date: 2000/09/12 21:23:27 $
@


1.18
log
@wakou
@
text
@d261 1
a261 1
=== ESCAPE HTML &"<>
d2056 1
a2056 1
$Date: 2000/09/11 22:02:35 $
@


1.17
log
@wakou
@
text
@d188 4
a191 4
  VERSION = "2.0.0"
  RELEASE_DATE = "2000-09-12"
  VERSION_CODE = 200
  RELEASE_CODE = 20000912
@


1.16
log
@wakou
@
text
@d7 1
a7 1
Version 2.0.0
d439 5
a444 1
    options.delete("status")
d1927 5
d2056 1
a2056 1
$Date: 2000/08/09 04:32:22 $
@


1.15
log
@matz
@
text
@d3 1
a3 1
== CGI SUPPORT LIBRARY
d5 1
a5 1
cgi.rb
d7 1
a7 1
Version 1.7.0
d179 1
d188 4
a191 4
  VERSION = "1.7.0"
  RELEASE_DATE = "2000-06-19"
  VERSION_CODE = 170
  RELEASE_CODE = 20000619
d243 3
a245 7
    string.gsub(/([^a-zA-Z0-9_.-])/n) do
      if " " == $1
        "+"
      else
        sprintf("%%%02X", $1.unpack("C")[0])
      end
    end
d254 2
a255 2
    string.gsub(/\+/n, ' ').gsub(/%([0-9a-fA-F]{2})/n) do
      [$1.hex].pack("c")
d285 1
a285 1
          if $KCODE[0] == ?u or $KCODE[0] == ?U
d288 11
a298 1
            "#" + $1
d301 2
a302 1
      when /\A#x([0-9a-f]+)\z/ni then $1.hex.chr
d310 1
a310 1
  print CGI::escapeElement("<BR><A HREF="url"></A>", "A", "IMG")
d313 1
a313 1
  print CGI::escapeElement("<BR><A HREF="url"></A>", ["A", "IMG"])
d317 6
a322 2
    string.gsub(/<\/?(?:#{element.join("|")})(?!\w)(?:.|\n)*?>/ni) do
      CGI::escapeHTML($&)
d330 1
a330 1
          CGI::escapeHTML("<BR><A HREF="url"></A>"), "A", "IMG")
d334 1
a334 1
          CGI::escapeHTML("<BR><A HREF="url"></A>"), ["A", "IMG"])
d347 1
a347 1
    # Sut, 1 Jan 2000 00:00:00 GMT
d351 1
a351 1
    return format("%s, %.2d %s %d %.2d:%.2d:%.2d GMT",
d1747 1
a1747 1
      %|<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">|
d1793 1
a1793 1
      %|<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">|
d1841 1
a1841 1
      %|<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN" "http://www.w3.org/TR/REC-html40/frameset.dtd">|
d1923 15
d2047 1
a2047 1
$Date: 2000/06/23 07:01:34 $
@


1.14
log
@2000-06-23
@
text
@d942 1
a942 1
    lines.gsub(/^(\s*)__(?=<\/?\w)/n, '\1')
d2020 1
a2020 1
$Date: 2000/06/19 21:16:44 $
@


1.13
log
@Tue Jun 20 06:14:43 2000  Wakou Aoyama <wakou@@fsinet.or.jp>

        * lib/cgi.rb: change: version syntax. old: x.yz, now: x.y.z

        * lib/net/telnet.rb: ditto.
@
text
@d978 1
a978 1
          if iterator?
d1014 1
a1014 1
          if iterator?
d1039 1
a1039 1
      if iterator?
d1058 1
a1058 1
      if iterator?
d1077 1
a1077 1
      if iterator?
d1096 1
a1096 1
      if iterator?
d1228 1
a1228 1
      if iterator?
d1318 1
a1318 1
      if iterator?
d1400 1
a1400 1
      if iterator?
d1675 1
a1675 1
      if iterator?
d2020 1
a2020 1
$Date: 2000/06/18 14:36:32 $
@


1.12
log
@expand tabs: lib/cgi.rb, lib/net/telnet.rb
@
text
@a1 1
$Date: 2000/06/13 15:52:04 $
d7 1
a7 1
Version 1.61
d10 1
d16 1
d21 10
a30 10
        require "cgi"
        cgi = CGI.new
        values = cgi['field_name']   # <== array of 'field_name'
          # if not 'field_name' included, then return [].
        fields = cgi.keys            # <== array of field names

        # returns true if form has 'field_name'
        cgi.has_key?('field_name')
        cgi.has_key?('field_name')
        cgi.include?('field_name')
d35 3
a37 3
        require "cgi"
        cgi = CGI.new
        params = cgi.params
d41 4
a44 4
        cgi.params['new_field_name'] = ["value"]  # add new param
        cgi.params['field_name'] = ["new_value"]  # change value
        cgi.params.delete('field_name')           # delete param
        cgi.params.clear                          # delete all params
d49 5
a53 5
        require "pstore"
        db = PStore.new("query.db")
        db.transaction do
          db["params"] = cgi.params
        end
d58 5
a62 5
        require "pstore"
        db = PStore.new("query.db")
        db.transaction do
          cgi.params = db["params"]
        end
d67 7
a73 7
        require "cgi"
        cgi = CGI.new
        values = cgi['field_name']   # <== array of 'field_name'
        values[0].read               # <== body of values[0]
        values[0].local_path         # <== path to local file of values[0]
        values[0].original_filename  # <== original filename of values[0]
        values[0].content_type       # <== content_type of values[0]
a75 1

d81 5
a85 5
        require "cgi"
        cgi = CGI.new
        values = cgi.cookies['name']  # <== array of 'name'
          # if not 'name' included, then return [].
        names = cgi.cookies.keys      # <== array of cookie names
d92 6
a97 6
        require "cgi"
        cgi = CGI.new
        for name, cookie in cgi.cookies
          cookie.expires = Time.now + 30
        end
        cgi.out("cookie" => cgi.cookies){"string"}
d99 1
a99 1
        cgi.cookies # { "name1" => cookie1, "name2" => cookie2, ... }
d101 4
a104 4
        require "cgi"
        cgi = CGI.new
        cgi.cookies['name'].expires = Time.now + 30
        cgi.out("cookie" => cgi.cookies['name']){"string"}
d111 4
a114 4
        require "cgi"
        cgi = CGI.new
        value = cgi.auth_type
          # ENV["AUTH_TYPE"]
d116 1
a116 1
http://www.w3.org/CGI/
d127 4
a130 4
        value = cgi.raw_cookie
          # ENV["HTTP_COOKIE"]
        value = cgi.raw_cookie2
          # ENV["HTTP_COOKIE2"]
d134 4
a137 4
        value = cgi.accept
          # ENV["HTTP_ACCEPT"]
        value = cgi.accept_charset
          # ENV["HTTP_ACCEPT_CHARSET"]
d146 19
a164 22
        require "cgi"
        cgi = CGI.new("html3")  # add HTML generation methods
        cgi.out() do
          cgi.html() do
            cgi.head{ cgi.title{"TITLE"} } +
            cgi.body() do
              cgi.form() do
                cgi.textarea("get_text") +
                cgi.br +
                cgi.submit
              end +
              cgi.pre() do
                CGI::escapeHTML(
                  "params: " + cgi.params.inspect + "\n" +
                  "cookies: " + cgi.cookies.inspect + "\n" +
                  ENV.collect() do |key, value|
                    key + " --> " + value + "\n"
                  end.join("")
                )
              end
            end
          end
d166 9
a175 5
        # add HTML generation methods
        CGI.new("html3")    # html3.2
        CGI.new("html4")    # html4.0 (Strict)
        CGI.new("html4Tr")  # html4.0 Transitional
        CGI.new("html4Fr")  # html4.0 Frameset
d187 4
a190 5
v = $-v
$-v = false
  VERSION = "1.61"
  RELEASE_DATE = "$Date: 2000/06/13 15:52:04 $"
$-v = v
d239 1
a239 1
        url_encoded_string = CGI::escape("string")
d254 1
a254 1
        string = CGI::unescape("url encoded string")
d265 1
a265 1
        CGI::escapeHTML("string")
d274 1
a274 1
        CGI::unescapeHTML("HTML escaped string")
d302 2
a303 2
        print CGI::escapeElement("<BR><A HREF="url"></A>", "A", "IMG")
          # "<BR>&lt;A HREF="url"&gt;&lt;/A&gt"
d305 2
a306 2
        print CGI::escapeElement("<BR><A HREF="url"></A>", ["A", "IMG"])
          # "<BR>&lt;A HREF="url"&gt;&lt;/A&gt"
d317 7
a323 7
        print CGI::unescapeElement(
                CGI::escapeHTML("<BR><A HREF="url"></A>"), "A", "IMG")
          # "&lt;BR&gt;<A HREF="url"></A>"

        print CGI::unescapeElement(
                CGI::escapeHTML("<BR><A HREF="url"></A>"), ["A", "IMG"])
          # "&lt;BR&gt;<A HREF="url"></A>"
d334 2
a335 2
        CGI::rfc1123_date(Time.now)
          # Sut, 1 Jan 2000 00:00:00 GMT
d347 2
a348 2
        header
          # Content-Type: text/html
d350 2
a351 2
        header("text/plain")
          # Content-Type: text/plain
d353 13
a365 13
        header({"nph"        => true,
                "status"     => "OK",  # == "200 OK"
                  # "status"     => "200 GOOD",
                "server"     => ENV['SERVER_SOFTWARE'],
                "connection" => "close",
                "type"       => "text/html",
                "charset"    => "iso-2022-jp",
                  # Content-Type: text/html; charset=iso-2022-jp
                "language"   => "ja",
                "expires"    => Time.now + 30,
                "cookie"     => [cookie1, cookie2],
                "my_header1" => "my_value"
                "my_header2" => "my_value"})
d370 19
a388 18
        "OK"                  --> "200 OK"
        "PARTIAL_CONTENT"     --> "206 Partial Content"
        "MULTIPLE_CHOICES"    --> "300 Multiple Choices"
        "MOVED"               --> "301 Moved Permanently"
        "REDIRECT"            --> "302 Found"
        "NOT_MODIFIED"        --> "304 Not Modified"
        "BAD_REQUEST"         --> "400 Bad Request"
        "AUTH_REQUIRED"       --> "401 Authorization Required"
        "FORBIDDEN"           --> "403 Forbidden"
        "NOT_FOUND"           --> "404 Not Found"
        "METHOD_NOT_ALLOWED"  --> "405 Method Not Allowed"
        "NOT_ACCEPTABLE"      --> "406 Not Acceptable"
        "LENGTH_REQUIRED"     --> "411 Length Required"
        "PRECONDITION_FAILED" --> "412 Rrecondition Failed"
        "SERVER_ERROR"        --> "500 Internal Server Error"
        "NOT_IMPLEMENTED"     --> "501 Method Not Implemented"
        "BAD_GATEWAY"         --> "502 Bad Gateway"
        "VARIANT_ALSO_VARIES" --> "506 Variant Also Negotiates"
d491 25
a515 25
        cgi = CGI.new
        cgi.out{ "string" }
          # Content-Type: text/html
          # Content-Length: 6
          #
          # string

        cgi.out("text/plain"){ "string" }
          # Content-Type: text/plain
          # Content-Length: 6
          #
          # string

        cgi.out({"nph"        => true,
                 "status"     => "OK",  # == "200 OK"
                 "server"     => ENV['SERVER_SOFTWARE'],
                 "connection" => "close",
                 "type"       => "text/html",
                 "charset"    => "iso-2022-jp",
                   # Content-Type: text/html; charset=iso-2022-jp
                 "language"   => "ja",
                 "expires"    => Time.now + (3600 * 24 * 30),
                 "cookie"     => [cookie1, cookie2],
                 "my_header1" => "my_value",
                 "my_header2" => "my_value"}){ "string" }
d553 2
a554 2
        cgi = CGI.new
        cgi.print    # default:  cgi.print == $DEFAULT_OUTPUT.print
d563 25
a587 25
        cookie1 = CGI::Cookie::new("name", "value1", "value2", ...)
        cookie1 = CGI::Cookie::new({"name" => "name", "value" => "value"})
        cookie1 = CGI::Cookie::new({'name'    => 'name',
                                    'value'   => ['value1', 'value2', ...],
                                    'path'    => 'path',   # optional
                                    'domain'  => 'domain', # optional
                                    'expires' => Time.now, # optional
                                    'secure'  => true      # optional
                                   })

        cgi.out({"cookie" => [cookie1, cookie2]}){ "string" }

        name    = cookie1.name
        values  = cookie1.value
        path    = cookie1.path
        domain  = cookie1.domain
        expires = cookie1.expires
        secure  = cookie1.secure

        cookie1.name    = 'name'
        cookie1.value   = ['value1', 'value2', ...]
        cookie1.path    = 'path'
        cookie1.domain  = 'domain'
        cookie1.expires = Time.now + 30
        cookie1.secure  = true
d663 2
a664 2
        cookies = CGI::Cookie::parse("raw_cookie_string")
          # { "name1" => cookie1, "name2" => cookie2, ... }
d688 3
a690 3
        params = CGI::parse("query_string")
          # {"name1" => ["value1", "value2", ...],
          #  "name2" => ["value1", "value2", ...], ... }
d922 11
a932 11
        print CGI::pretty("<HTML><BODY></BODY></HTML>")
          # <HTML>
          #   <BODY>
          #   </BODY>
          # </HTML>

        print CGI::pretty("<HTML><BODY></BODY></HTML>", "\t")
          # <HTML>
          #         <BODY>
          #         </BODY>
          # </HTML>
d949 11
a959 11
        cgi = CGI.new("html3")  # add HTML generation methods
        cgi.element
        cgi.element{ "string" }
        cgi.element({ "ATTRILUTE1" => "value1", "ATTRIBUTE2" => "value2" })
        cgi.element({ "ATTRILUTE1" => "value1", "ATTRIBUTE2" => "value2" }){ "string" }

        # add HTML generation methods
        CGI.new("html3")    # html3.2
        CGI.new("html4")    # html4.0 (Strict)
        CGI.new("html4Tr")  # html4.0 Transitional
        CGI.new("html4Fr")  # html4.0 Frameset
d1030 2
a1031 2
        a("url")
          # = a({ "HREF" => "url" })
d1049 2
a1050 2
        base("url")
          # = base({ "HREF" => "url" })
d1068 2
a1069 2
        blockquote("url"){ "string" }
          # = blockquote({ "CITE" => "url" }){ "string" }
d1087 2
a1088 2
        caption("align"){ "string" }
          # = caption({ "ALIGN" => "align" }){ "string" }
d1106 2
a1107 2
        checkbox("name")
          # = checkbox({ "NAME" => "name" })
d1109 2
a1110 2
        checkbox("name", "value")
          # = checkbox({ "NAME" => "name", "VALUE" => "value" })
d1112 2
a1113 2
        checkbox("name", "value", true)
          # = checkbox({ "NAME" => "name", "VALUE" => "value", "CHECKED" => true })
d1129 14
a1142 14
        checkbox_group("name", "foo", "bar", "baz")
          # <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo
          # <INPUT TYPE="checkbox" NAME="name" VALUE="bar">bar
          # <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz

        checkbox_group("name", ["foo"], ["bar", true], "baz")
          # <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo
          # <INPUT TYPE="checkbox" SELECTED NAME="name" VALUE="bar">bar
          # <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz

        checkbox_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
          # <INPUT TYPE="checkbox" NAME="name" VALUE="1">Foo
          # <INPUT TYPE="checkbox" SELECTED NAME="name" VALUE="2">Bar
          # <INPUT TYPE="checkbox" NAME="name" VALUE="Baz">Baz
d1144 2
a1145 2
        checkbox_group({ "NAME" => "name",
                         "VALUES" => ["foo", "bar", "baz"] })
d1147 2
a1148 2
        checkbox_group({ "NAME" => "name",
                         "VALUES" => [["foo"], ["bar", true], "baz"] })
d1150 2
a1151 2
        checkbox_group({ "NAME" => "name",
                         "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
d1176 2
a1177 2
        file_field("name")
          # <INPUT TYPE="file" NAME="name" SIZE="20">
d1179 2
a1180 2
        file_field("name", 40)
          # <INPUT TYPE="file" NAME="name" SIZE="40">
d1182 2
a1183 2
        file_field("name", 40, 100)
          # <INPUT TYPE="file" NAME="name" SIZE="40", MAXLENGTH="100">
d1185 2
a1186 2
        file_field({ "NAME" => "name", "SIZE" => 40 })
          # <INPUT TYPE="file" NAME="name" SIZE="40">
d1203 2
a1204 2
        form{ "string" }
          # <FORM METHOD="post" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1206 2
a1207 2
        form("get"){ "string" }
          # <FORM METHOD="get" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1209 2
a1210 2
        form("get", "url"){ "string" }
          # <FORM METHOD="get" ACTION="url" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1212 2
a1213 2
        form({"METHOD" => "post", ENCTYPE => "enctype"}){ "string" }
          # <FORM METHOD="post" ENCTYPE="enctype">string</FORM>
d1244 2
a1245 2
        hidden("name")
          # <INPUT TYPE="hidden" NAME="name">
d1247 2
a1248 2
        hidden("name", "value")
          # <INPUT TYPE="hidden" NAME="name" VALUE="value">
d1250 2
a1251 2
        hidden({ "NAME" => "name", "VALUE" => "reset", "ID" => "foo" })
          # <INPUT TYPE="hidden" NAME="name" VALUE="value" ID="foo">
d1267 2
a1268 2
        html{ "string" }
          # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML>string</HTML>
d1270 2
a1271 2
        html({ "LANG" => "ja" }){ "string" }
          # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML LANG="ja">string</HTML>
d1273 2
a1274 2
        html({ "DOCTYPE" => false }){ "string" }
          # <HTML>string</HTML>
d1276 16
a1291 16
        html({ "DOCTYPE" => '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">' }){ "string" }
          # <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"><HTML>string</HTML>

        html({ "PRETTY" => "  " }){ "<BODY></BODY>" }
          # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
          # <HTML>
          #   <BODY>
          #   </BODY>
          # </HTML>

        html({ "PRETTY" => "\t" }){ "<BODY></BODY>" }
          # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
          # <HTML>
          #         <BODY>
          #         </BODY>
          # </HTML>
d1293 2
a1294 2
        html("PRETTY"){ "<BODY></BODY>" }
          # = html({ "PRETTY" => "  " }){ "<BODY></BODY>" }
d1296 1
a1296 1
        html(if $VERBOSE then "PRETTY" end){ "HTML string" }
d1335 2
a1336 2
        image_button("url")
          # <INPUT TYPE="image" SRC="url">
d1338 2
a1339 2
        image_button("url", "name", "string")
          # <INPUT TYPE="image" SRC="url" NAME="name", ALT="string">
d1341 2
a1342 2
        image_button({ "SRC" => "url", "ATL" => "strng" })
          # <INPUT TYPE="image" SRC="url" ALT="string">
d1359 2
a1360 2
        img("src", "alt", 100, 50)
          # <IMG SRC="src" ALT="alt" WIDTH="100", HEIGHT="50">
d1362 2
a1363 2
        img({ "SRC" => "src", "ALT" => "alt", "WIDTH" => 100, "HEIGHT" => 50 })
          # <IMG SRC="src" ALT="alt" WIDTH="100", HEIGHT="50">
d1379 2
a1380 2
        multipart_form{ "string" }
          # <FORM METHOD="post" ENCTYPE="multipart/form-data">string</FORM>
d1382 2
a1383 2
        multipart_form("url"){ "string" }
          # <FORM METHOD="post" ACTION="url" ENCTYPE="multipart/form-data">string</FORM>
d1410 2
a1411 2
        password_field("name")
          # <INPUT TYPE="password" NAME="name" SIZE="40">
d1413 2
a1414 2
        password_field("name", "value")
          # <INPUT TYPE="password" NAME="name" VALUE="value" SIZE="40">
d1416 2
a1417 2
        password_field("password", "value", 80, 200)
          # <INPUT TYPE="password" NAME="name" VALUE="value", SIZE="80", MAXLENGTH="200">
d1419 2
a1420 2
        password_field({ "NAME" => "name", "VALUE" => "value" })
          # <INPUT TYPE="password" NAME="name" VALUE="value">
d1437 28
a1464 28
        popup_menu("name", "foo", "bar", "baz")
          # <SELECT NAME="name">
          #   <OPTION VALUE="foo">foo</OPTION>
          #   <OPTION VALUE="bar">bar</OPTION>
          #   <OPTION VALUE="baz">baz</OPTION>
          # </SELECT>

        popup_menu("name", ["foo"], ["bar", true], "baz")
          # <SELECT NAME="name">
          #   <OPTION VALUE="foo">foo</OPTION>
          #   <OPTION VALUE="bar" SELECTED>bar</OPTION>
          #   <OPTION VALUE="baz">baz</OPTION>
          # </SELECT>

        popup_menu("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
          # <SELECT NAME="name">
          #   <OPTION VALUE="1">Foo</OPTION>
          #   <OPTION SELECTED VALUE="2">Bar</OPTION>
          #   <OPTION VALUE="Baz">Baz</OPTION>
          # </SELECT>

        popup_menu({"NAME" => "name", "SIZE" => 2, "MULTIPLE" => true,
                    "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
          # <SELECT NAME="name" MULTIPLE SIZE="2">
          #   <OPTION VALUE="1">Foo</OPTION>
          #   <OPTION SELECTED VALUE="2">Bar</OPTION>
          #   <OPTION VALUE="Baz">Baz</OPTION>
          # </SELECT>
d1502 2
a1503 2
        radio_button("name", "value")
          # <INPUT TYPE="radio" NAME="name", VALUE="value">
d1505 2
a1506 2
        radio_button("name", "value", true)
          # <INPUT TYPE="radio" NAME="name", VALUE="value", CHECKED>
d1508 2
a1509 2
        radio_button({ "NAME" => "name", "VALUE" => "value", "ID" => "foo" })
          # <INPUT TYPE="radio" NAME="name" VALUE="value" ID="foo">
d1525 14
a1538 14
        radio_group("name", "foo", "bar", "baz")
          # <INPUT TYPE="radio" NAME="name" VALUE="foo">foo
          # <INPUT TYPE="radio" NAME="name" VALUE="bar">bar
          # <INPUT TYPE="radio" NAME="name" VALUE="baz">baz

        radio_group("name", ["foo"], ["bar", true], "baz")
          # <INPUT TYPE="radio" NAME="name" VALUE="foo">foo
          # <INPUT TYPE="radio" SELECTED NAME="name" VALUE="bar">bar
          # <INPUT TYPE="radio" NAME="name" VALUE="baz">baz

        radio_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
          # <INPUT TYPE="radio" NAME="name" VALUE="1">Foo
          # <INPUT TYPE="radio" SELECTED NAME="name" VALUE="2">Bar
          # <INPUT TYPE="radio" NAME="name" VALUE="Baz">Baz
d1540 2
a1541 2
        radio_group({ "NAME" => "name",
                      "VALUES" => ["foo", "bar", "baz"] })
d1543 2
a1544 2
        radio_group({ "NAME" => "name",
                      "VALUES" => [["foo"], ["bar", true], "baz"] })
d1546 2
a1547 2
        radio_group({ "NAME" => "name",
                      "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
d1572 2
a1573 2
        reset
          # <INPUT TYPE="reset">
d1575 2
a1576 2
        reset("reset")
          # <INPUT TYPE="reset" VALUE="reset">
d1578 2
a1579 2
        reset({ "VALUE" => "reset", "ID" => "foo" })
          # <INPUT TYPE="reset" VALUE="reset" ID="foo">
d1594 7
a1600 7
        scrolling_list({"NAME" => "name", "SIZE" => 2, "MULTIPLE" => true,
                        "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
          # <SELECT NAME="name" MULTIPLE SIZE="2">
          #   <OPTION VALUE="1">Foo</OPTION>
          #   <OPTION SELECTED VALUE="2">Bar</OPTION>
          #   <OPTION VALUE="Baz">Baz</OPTION>
          # </SELECT>
d1607 2
a1608 2
        submit
          # <INPUT TYPE="submit">
d1610 2
a1611 2
        submit("ok")
          # <INPUT TYPE="submit" VALUE="ok">
d1613 2
a1614 2
        submit("ok", "button1")
          # <INPUT TYPE="submit" VALUE="ok" NAME="button1">
d1616 2
a1617 2
        submit({ "VALUE" => "ok", "NAME" => "button1", "ID" => "foo" })
          # <INPUT TYPE="submit" VALUE="ok" NAME="button1" ID="foo">
d1632 2
a1633 2
        text_field("name")
          # <INPUT TYPE="text" NAME="name" SIZE="40">
d1635 2
a1636 2
        text_field("name", "value")
          # <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="40">
d1638 2
a1639 2
        text_field("name", "value", 80)
          # <INPUT TYPE="text" NAME="name" VALUE="value", SIZE="80">
d1641 2
a1642 2
        text_field("name", "value", 80, 200)
          # <INPUT TYPE="text" NAME="name" VALUE="value", SIZE="80", MAXLENGTH="200">
d1644 2
a1645 2
        text_field({ "NAME" => "name", "VALUE" => "value" })
          # <INPUT TYPE="text" NAME="name" VALUE="value">
d1662 2
d1665 2
a1666 5
        textarea("name")
          # = textarea({ "NAME" => "name", "COLS" => 70, "ROWS" => 10 })

        textarea("name", 40, 5)
          # = textarea({ "NAME" => "name", "COLS" => 40, "ROWS" => 5 })
d1911 108
a2018 158
=== Version 1.61 - wakou

2000/06/13 15:49:27

- read_multipart(): if no content body then raise EOFError.

=== Version 1.60 - wakou

2000/06/03 18:16:17

- improve: CGI::pretty()

=== Version 1.50 - wakou

2000/05/30 19:04:08

- CGI#out()
  if "HEAD" == REQUEST_METHOD then output only HTTP header.

=== Version 1.40 - wakou

2000/05/24 06:58:51

- typo: CGI::Cookie::new()
- bug fix: CGI::escape()
  bad: " " --> "%2B"  true: " " --> "+"
  thanks to Ryunosuke Ohshima <ryu@@jaist.ac.jp>

=== Version 1.31 - wakou

2000/05/08 21:51:30

- improvement of time forming new CGI object accompanied with HTML generation methods.

=== Version 1.30 - wakou

2000/05/07 21:51:14

- require English.rb
- improvement of load time.

=== Version 1.21 - wakou

2000/05/02 21:44:12

- support for ruby 1.5.3 (2000-05-01) (Array#filter --> Array#collect!)

=== Version 1.20 - wakou

2000/04/03 18:31:42

- bug fix: CGI#image_button() can't get Hash option
  thanks to Takashi Ikeda <ikeda@@auc.co.jp>
- CGI::unescapeHTML()
  simple support for "&#12345;"
- CGI::Cookie::new()
  simple support for IE
- CGI::escape()
  ' ' replaced by '+'

=== Version 1.10 - wakou

1999/12/06 20:16:34

- can make many CGI objects.
- if use mod_ruby, then require ruby1.4.3 or later.

=== Version 1.01 - wakou

1999/11/29 21:35:58

- support for ruby 1.5.0 (1999-11-20)

=== Version 1.00 - wakou

1999/09/13 23:00:58

- COUTION! name change. CGI.rb --> cgi.rb

- CGI#auth_type, CGI#content_length, CGI#content_type, ...
if not ENV included it, then return nil.

- CGI#content_length and CGI#server_port return Integer.

- if not CGI#params.include?('name'), then CGI#params['name'] return [].

- if not CGI#cookies.include?('name'), then CGI#cookies['name'] return [].

=== Version 0.41 - wakou

1999/08/05 18:04:59

- typo. thanks to MJ Ray <markj@@altern.org>
        HTTP_STATUS["NOT_INPLEMENTED"] --> HTTP_STATUS["NOT_IMPLEMENTED"]

=== Version 0.40 - wakou

1999/07/20 20:44:31

- COUTION! incompatible change.
  sorry, but probably this change is last big incompatible change.

- CGI::print  -->  CGI#out

        cgi = CGI.new
        cgi.out{"string"}             # old: CGI::print{"string"}

- CGI::cookie  --> CGI::Cookie::new

        cookie1 = CGI::Cookie::new    # old: CGI::cookie

- CGI::header  -->  CGI#header

=== Version 0.30 - wakou

1999/06/29 06:50:21

- COUTION! incompatible change.
        query = CGI.new
        cookies = query.cookies       # old: query.cookie
        values = query.cookies[name]  # old: query.cookie[name]

=== Version 0.24 - wakou

1999/06/21 21:05:57

- CGI::Cookie::parse() return { name => CGI::Cookie object } pairs.

=== Version 0.23 - wakou

1999/06/20 23:29:12

- modified a bit to clear module separation.

=== Version 0.22 - matz

Mon Jun 14 17:49:32 JST 1999

- Cookies are now CGI::Cookie objects.
- Cookie modeled after CGI::Cookie.pm.

=== Version 0.21 - matz

Fri Jun 11 11:19:11 JST 1999

- modified a bit to clear module separation.

=== Version 0.20 - wakou

1999/06/03 06:48:15

- support for multipart form.

=== Version 0.10 - wakou

1999/05/24 07:05:41

- first release.
d2020 1
@


1.11
log
@Wed Jun 14 00:50:14 2000  Wakou Aoyama <wakou@@fsinet.or.jp>

        * lib/cig.rb: read_multipart(): if no content body then raise EOFError.
@
text
@d2 1
a2 1
$Date: 2000/06/13 15:49:27 $
d20 10
a29 10
	require "cgi"
	cgi = CGI.new
	values = cgi['field_name']   # <== array of 'field_name'
	  # if not 'field_name' included, then return [].
	fields = cgi.keys            # <== array of field names

	# returns true if form has 'field_name'
	cgi.has_key?('field_name')
	cgi.has_key?('field_name')
	cgi.include?('field_name')
d34 3
a36 3
	require "cgi"
	cgi = CGI.new
	params = cgi.params
d40 4
a43 4
	cgi.params['new_field_name'] = ["value"]  # add new param
	cgi.params['field_name'] = ["new_value"]  # change value
	cgi.params.delete('field_name')           # delete param
	cgi.params.clear                          # delete all params
d48 5
a52 5
	require "pstore"
	db = PStore.new("query.db")
	db.transaction do
	  db["params"] = cgi.params
	end
d57 5
a61 5
	require "pstore"
	db = PStore.new("query.db")
	db.transaction do
	  cgi.params = db["params"]
	end
d66 7
a72 7
	require "cgi"
	cgi = CGI.new
	values = cgi['field_name']   # <== array of 'field_name'
	values[0].read               # <== body of values[0]
	values[0].local_path         # <== path to local file of values[0]
	values[0].original_filename  # <== original filename of values[0]
	values[0].content_type       # <== content_type of values[0]
d81 5
a85 5
	require "cgi"
	cgi = CGI.new
	values = cgi.cookies['name']  # <== array of 'name'
	  # if not 'name' included, then return [].
	names = cgi.cookies.keys      # <== array of cookie names
d92 13
a104 13
	require "cgi"
	cgi = CGI.new
	for name, cookie in cgi.cookies
	  cookie.expires = Time.now + 30
	end
	cgi.out("cookie" => cgi.cookies){"string"}

	cgi.cookies # { "name1" => cookie1, "name2" => cookie2, ... }

	require "cgi"
	cgi = CGI.new
	cgi.cookies['name'].expires = Time.now + 30
	cgi.out("cookie" => cgi.cookies['name']){"string"}
d111 4
a114 4
	require "cgi"
	cgi = CGI.new
	value = cgi.auth_type
	  # ENV["AUTH_TYPE"]
d127 4
a130 4
	value = cgi.raw_cookie
	  # ENV["HTTP_COOKIE"]
	value = cgi.raw_cookie2
	  # ENV["HTTP_COOKIE2"]
d134 4
a137 4
	value = cgi.accept
	  # ENV["HTTP_ACCEPT"]
	value = cgi.accept_charset
	  # ENV["HTTP_ACCEPT_CHARSET"]
d146 29
a174 29
	require "cgi"
	cgi = CGI.new("html3")  # add HTML generation methods
	cgi.out() do
	  cgi.html() do
	    cgi.head{ cgi.title{"TITLE"} } +
	    cgi.body() do
	      cgi.form() do
	        cgi.textarea("get_text") +
	        cgi.br +
	        cgi.submit
	      end +
	      cgi.pre() do
	        CGI::escapeHTML(
	          "params: " + cgi.params.inspect + "\n" +
	          "cookies: " + cgi.cookies.inspect + "\n" +
	          ENV.collect() do |key, value|
	            key + " --> " + value + "\n"
	          end.join("")
	        )
	      end
	    end
	  end
	end

	# add HTML generation methods
	CGI.new("html3")    # html3.2
	CGI.new("html4")    # html4.0 (Strict)
	CGI.new("html4Tr")  # html4.0 Transitional
	CGI.new("html4Fr")  # html4.0 Frameset
d189 1
a189 1
  RELEASE_DATE = "$Date: 2000/06/13 15:49:27 $"
d239 1
a239 1
	url_encoded_string = CGI::escape("string")
d254 1
a254 1
	string = CGI::unescape("url encoded string")
d265 1
a265 1
	CGI::escapeHTML("string")
d274 1
a274 1
	CGI::unescapeHTML("HTML escaped string")
d302 2
a303 2
	print CGI::escapeElement("<BR><A HREF="url"></A>", "A", "IMG")
	  # "<BR>&lt;A HREF="url"&gt;&lt;/A&gt"
d305 2
a306 2
	print CGI::escapeElement("<BR><A HREF="url"></A>", ["A", "IMG"])
	  # "<BR>&lt;A HREF="url"&gt;&lt;/A&gt"
d317 7
a323 7
	print CGI::unescapeElement(
	        CGI::escapeHTML("<BR><A HREF="url"></A>"), "A", "IMG")
	  # "&lt;BR&gt;<A HREF="url"></A>"

	print CGI::unescapeElement(
	        CGI::escapeHTML("<BR><A HREF="url"></A>"), ["A", "IMG"])
	  # "&lt;BR&gt;<A HREF="url"></A>"
d334 2
a335 2
	CGI::rfc1123_date(Time.now)
	  # Sut, 1 Jan 2000 00:00:00 GMT
d347 2
a348 2
	header
	  # Content-Type: text/html
d350 2
a351 2
	header("text/plain")
	  # Content-Type: text/plain
d353 13
a365 13
	header({"nph"        => true,
	        "status"     => "OK",  # == "200 OK"
	          # "status"     => "200 GOOD",
	        "server"     => ENV['SERVER_SOFTWARE'],
	        "connection" => "close",
	        "type"       => "text/html",
	        "charset"    => "iso-2022-jp",
	          # Content-Type: text/html; charset=iso-2022-jp
	        "language"   => "ja",
	        "expires"    => Time.now + 30,
	        "cookie"     => [cookie1, cookie2],
	        "my_header1" => "my_value"
	        "my_header2" => "my_value"})
d370 18
a387 18
	"OK"                  --> "200 OK"
	"PARTIAL_CONTENT"     --> "206 Partial Content"
	"MULTIPLE_CHOICES"    --> "300 Multiple Choices"
	"MOVED"               --> "301 Moved Permanently"
	"REDIRECT"            --> "302 Found"
	"NOT_MODIFIED"        --> "304 Not Modified"
	"BAD_REQUEST"         --> "400 Bad Request"
	"AUTH_REQUIRED"       --> "401 Authorization Required"
	"FORBIDDEN"           --> "403 Forbidden"
	"NOT_FOUND"           --> "404 Not Found"
	"METHOD_NOT_ALLOWED"  --> "405 Method Not Allowed"
	"NOT_ACCEPTABLE"      --> "406 Not Acceptable"
	"LENGTH_REQUIRED"     --> "411 Length Required"
	"PRECONDITION_FAILED" --> "412 Rrecondition Failed"
	"SERVER_ERROR"        --> "500 Internal Server Error"
	"NOT_IMPLEMENTED"     --> "501 Method Not Implemented"
	"BAD_GATEWAY"         --> "502 Bad Gateway"
	"VARIANT_ALSO_VARIES" --> "506 Variant Also Negotiates"
d467 1
a467 1
	buf.concat("Set-Cookie: " + cookie.to_s + EOL)
d490 25
a514 25
	cgi = CGI.new
	cgi.out{ "string" }
	  # Content-Type: text/html
	  # Content-Length: 6
	  #
	  # string

	cgi.out("text/plain"){ "string" }
	  # Content-Type: text/plain
	  # Content-Length: 6
	  #
	  # string

	cgi.out({"nph"        => true,
	         "status"     => "OK",  # == "200 OK"
	         "server"     => ENV['SERVER_SOFTWARE'],
	         "connection" => "close",
	         "type"       => "text/html",
	         "charset"    => "iso-2022-jp",
	           # Content-Type: text/html; charset=iso-2022-jp
	         "language"   => "ja",
	         "expires"    => Time.now + (3600 * 24 * 30),
	         "cookie"     => [cookie1, cookie2],
	         "my_header1" => "my_value",
	         "my_header2" => "my_value"}){ "string" }
d552 2
a553 2
	cgi = CGI.new
	cgi.print    # default:  cgi.print == $DEFAULT_OUTPUT.print
d562 25
a586 25
	cookie1 = CGI::Cookie::new("name", "value1", "value2", ...)
	cookie1 = CGI::Cookie::new({"name" => "name", "value" => "value"})
	cookie1 = CGI::Cookie::new({'name'    => 'name',
	                            'value'   => ['value1', 'value2', ...],
	                            'path'    => 'path',   # optional
	                            'domain'  => 'domain', # optional
	                            'expires' => Time.now, # optional
	                            'secure'  => true      # optional
	                           })

	cgi.out({"cookie" => [cookie1, cookie2]}){ "string" }

	name    = cookie1.name
	values  = cookie1.value
	path    = cookie1.path
	domain  = cookie1.domain
	expires = cookie1.expires
	secure  = cookie1.secure

	cookie1.name    = 'name'
	cookie1.value   = ['value1', 'value2', ...]
	cookie1.path    = 'path'
	cookie1.domain  = 'domain'
	cookie1.expires = Time.now + 30
	cookie1.secure  = true
d662 2
a663 2
	cookies = CGI::Cookie::parse("raw_cookie_string")
	  # { "name1" => cookie1, "name2" => cookie2, ... }
d687 3
a689 3
	params = CGI::parse("query_string")
	  # {"name1" => ["value1", "value2", ...],
	  #  "name2" => ["value1", "value2", ...], ... }
d921 11
a931 11
	print CGI::pretty("<HTML><BODY></BODY></HTML>")
	  # <HTML>
	  #   <BODY>
	  #   </BODY>
	  # </HTML>

	print CGI::pretty("<HTML><BODY></BODY></HTML>", "\t")
	  # <HTML>
	  # 	<BODY>
	  # 	</BODY>
	  # </HTML>
d948 11
a958 11
	cgi = CGI.new("html3")  # add HTML generation methods
	cgi.element
	cgi.element{ "string" }
	cgi.element({ "ATTRILUTE1" => "value1", "ATTRIBUTE2" => "value2" })
	cgi.element({ "ATTRILUTE1" => "value1", "ATTRIBUTE2" => "value2" }){ "string" }

	# add HTML generation methods
	CGI.new("html3")    # html3.2
	CGI.new("html4")    # html4.0 (Strict)
	CGI.new("html4Tr")  # html4.0 Transitional
	CGI.new("html4Fr")  # html4.0 Frameset
d1029 2
a1030 2
	a("url")
	  # = a({ "HREF" => "url" })
d1048 2
a1049 2
	base("url")
	  # = base({ "HREF" => "url" })
d1067 2
a1068 2
	blockquote("url"){ "string" }
	  # = blockquote({ "CITE" => "url" }){ "string" }
d1086 2
a1087 2
	caption("align"){ "string" }
	  # = caption({ "ALIGN" => "align" }){ "string" }
d1105 2
a1106 2
	checkbox("name")
	  # = checkbox({ "NAME" => "name" })
d1108 2
a1109 2
	checkbox("name", "value")
	  # = checkbox({ "NAME" => "name", "VALUE" => "value" })
d1111 2
a1112 2
	checkbox("name", "value", true)
	  # = checkbox({ "NAME" => "name", "VALUE" => "value", "CHECKED" => true })
d1128 14
a1141 14
	checkbox_group("name", "foo", "bar", "baz")
	  # <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo
	  # <INPUT TYPE="checkbox" NAME="name" VALUE="bar">bar
	  # <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz

	checkbox_group("name", ["foo"], ["bar", true], "baz")
	  # <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo
	  # <INPUT TYPE="checkbox" SELECTED NAME="name" VALUE="bar">bar
	  # <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz

	checkbox_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
	  # <INPUT TYPE="checkbox" NAME="name" VALUE="1">Foo
	  # <INPUT TYPE="checkbox" SELECTED NAME="name" VALUE="2">Bar
	  # <INPUT TYPE="checkbox" NAME="name" VALUE="Baz">Baz
d1143 2
a1144 2
	checkbox_group({ "NAME" => "name",
	                 "VALUES" => ["foo", "bar", "baz"] })
d1146 2
a1147 2
	checkbox_group({ "NAME" => "name",
	                 "VALUES" => [["foo"], ["bar", true], "baz"] })
d1149 2
a1150 2
	checkbox_group({ "NAME" => "name",
	                 "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
d1175 2
a1176 2
	file_field("name")
	  # <INPUT TYPE="file" NAME="name" SIZE="20">
d1178 2
a1179 2
	file_field("name", 40)
	  # <INPUT TYPE="file" NAME="name" SIZE="40">
d1181 2
a1182 2
	file_field("name", 40, 100)
	  # <INPUT TYPE="file" NAME="name" SIZE="40", MAXLENGTH="100">
d1184 2
a1185 2
	file_field({ "NAME" => "name", "SIZE" => 40 })
	  # <INPUT TYPE="file" NAME="name" SIZE="40">
d1202 2
a1203 2
	form{ "string" }
	  # <FORM METHOD="post" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1205 2
a1206 2
	form("get"){ "string" }
	  # <FORM METHOD="get" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1208 2
a1209 2
	form("get", "url"){ "string" }
	  # <FORM METHOD="get" ACTION="url" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1211 2
a1212 2
	form({"METHOD" => "post", ENCTYPE => "enctype"}){ "string" }
	  # <FORM METHOD="post" ENCTYPE="enctype">string</FORM>
d1228 1
a1228 1
	body = yield
d1233 4
a1236 4
	hidden = @@output_hidden.collect{|k,v|
	  "<INPUT TYPE=HIDDEN NAME=\"#{k}\" VALUE=\"#{v}\">"
	}.to_s
	body.concat hidden
d1243 2
a1244 2
	hidden("name")
	  # <INPUT TYPE="hidden" NAME="name">
d1246 2
a1247 2
	hidden("name", "value")
	  # <INPUT TYPE="hidden" NAME="name" VALUE="value">
d1249 2
a1250 2
	hidden({ "NAME" => "name", "VALUE" => "reset", "ID" => "foo" })
	  # <INPUT TYPE="hidden" NAME="name" VALUE="value" ID="foo">
d1266 2
a1267 2
	html{ "string" }
	  # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML>string</HTML>
d1269 2
a1270 2
	html({ "LANG" => "ja" }){ "string" }
	  # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML LANG="ja">string</HTML>
d1272 2
a1273 2
	html({ "DOCTYPE" => false }){ "string" }
	  # <HTML>string</HTML>
d1275 16
a1290 16
	html({ "DOCTYPE" => '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">' }){ "string" }
	  # <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"><HTML>string</HTML>

	html({ "PRETTY" => "  " }){ "<BODY></BODY>" }
	  # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
	  # <HTML>
	  #   <BODY>
	  #   </BODY>
	  # </HTML>

	html({ "PRETTY" => "\t" }){ "<BODY></BODY>" }
	  # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
	  # <HTML>
	  # 	<BODY>
	  # 	</BODY>
	  # </HTML>
d1292 2
a1293 2
	html("PRETTY"){ "<BODY></BODY>" }
	  # = html({ "PRETTY" => "  " }){ "<BODY></BODY>" }
d1295 1
a1295 1
	html(if $VERBOSE then "PRETTY" end){ "HTML string" }
d1334 2
a1335 2
	image_button("url")
	  # <INPUT TYPE="image" SRC="url">
d1337 2
a1338 2
	image_button("url", "name", "string")
	  # <INPUT TYPE="image" SRC="url" NAME="name", ALT="string">
d1340 2
a1341 2
	image_button({ "SRC" => "url", "ATL" => "strng" })
	  # <INPUT TYPE="image" SRC="url" ALT="string">
d1358 2
a1359 2
	img("src", "alt", 100, 50)
	  # <IMG SRC="src" ALT="alt" WIDTH="100", HEIGHT="50">
d1361 2
a1362 2
	img({ "SRC" => "src", "ALT" => "alt", "WIDTH" => 100, "HEIGHT" => 50 })
	  # <IMG SRC="src" ALT="alt" WIDTH="100", HEIGHT="50">
d1378 2
a1379 2
	multipart_form{ "string" }
	  # <FORM METHOD="post" ENCTYPE="multipart/form-data">string</FORM>
d1381 2
a1382 2
	multipart_form("url"){ "string" }
	  # <FORM METHOD="post" ACTION="url" ENCTYPE="multipart/form-data">string</FORM>
d1409 2
a1410 2
	password_field("name")
	  # <INPUT TYPE="password" NAME="name" SIZE="40">
d1412 2
a1413 2
	password_field("name", "value")
	  # <INPUT TYPE="password" NAME="name" VALUE="value" SIZE="40">
d1415 2
a1416 2
	password_field("password", "value", 80, 200)
	  # <INPUT TYPE="password" NAME="name" VALUE="value", SIZE="80", MAXLENGTH="200">
d1418 2
a1419 2
	password_field({ "NAME" => "name", "VALUE" => "value" })
	  # <INPUT TYPE="password" NAME="name" VALUE="value">
d1436 28
a1463 28
	popup_menu("name", "foo", "bar", "baz")
	  # <SELECT NAME="name">
	  #   <OPTION VALUE="foo">foo</OPTION>
	  #   <OPTION VALUE="bar">bar</OPTION>
	  #   <OPTION VALUE="baz">baz</OPTION>
	  # </SELECT>

	popup_menu("name", ["foo"], ["bar", true], "baz")
	  # <SELECT NAME="name">
	  #   <OPTION VALUE="foo">foo</OPTION>
	  #   <OPTION VALUE="bar" SELECTED>bar</OPTION>
	  #   <OPTION VALUE="baz">baz</OPTION>
	  # </SELECT>

	popup_menu("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
	  # <SELECT NAME="name">
	  #   <OPTION VALUE="1">Foo</OPTION>
	  #   <OPTION SELECTED VALUE="2">Bar</OPTION>
	  #   <OPTION VALUE="Baz">Baz</OPTION>
	  # </SELECT>

	popup_menu({"NAME" => "name", "SIZE" => 2, "MULTIPLE" => true,
	            "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
	  # <SELECT NAME="name" MULTIPLE SIZE="2">
	  #   <OPTION VALUE="1">Foo</OPTION>
	  #   <OPTION SELECTED VALUE="2">Bar</OPTION>
	  #   <OPTION VALUE="Baz">Baz</OPTION>
	  # </SELECT>
d1501 2
a1502 2
	radio_button("name", "value")
	  # <INPUT TYPE="radio" NAME="name", VALUE="value">
d1504 2
a1505 2
	radio_button("name", "value", true)
	  # <INPUT TYPE="radio" NAME="name", VALUE="value", CHECKED>
d1507 2
a1508 2
	radio_button({ "NAME" => "name", "VALUE" => "value", "ID" => "foo" })
	  # <INPUT TYPE="radio" NAME="name" VALUE="value" ID="foo">
d1524 14
a1537 14
	radio_group("name", "foo", "bar", "baz")
	  # <INPUT TYPE="radio" NAME="name" VALUE="foo">foo
	  # <INPUT TYPE="radio" NAME="name" VALUE="bar">bar
	  # <INPUT TYPE="radio" NAME="name" VALUE="baz">baz

	radio_group("name", ["foo"], ["bar", true], "baz")
	  # <INPUT TYPE="radio" NAME="name" VALUE="foo">foo
	  # <INPUT TYPE="radio" SELECTED NAME="name" VALUE="bar">bar
	  # <INPUT TYPE="radio" NAME="name" VALUE="baz">baz

	radio_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
	  # <INPUT TYPE="radio" NAME="name" VALUE="1">Foo
	  # <INPUT TYPE="radio" SELECTED NAME="name" VALUE="2">Bar
	  # <INPUT TYPE="radio" NAME="name" VALUE="Baz">Baz
d1539 2
a1540 2
	radio_group({ "NAME" => "name",
	              "VALUES" => ["foo", "bar", "baz"] })
d1542 2
a1543 2
	radio_group({ "NAME" => "name",
	              "VALUES" => [["foo"], ["bar", true], "baz"] })
d1545 2
a1546 2
	radio_group({ "NAME" => "name",
	              "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
d1571 2
a1572 2
	reset
	  # <INPUT TYPE="reset">
d1574 2
a1575 2
	reset("reset")
	  # <INPUT TYPE="reset" VALUE="reset">
d1577 2
a1578 2
	reset({ "VALUE" => "reset", "ID" => "foo" })
	  # <INPUT TYPE="reset" VALUE="reset" ID="foo">
d1593 7
a1599 7
	scrolling_list({"NAME" => "name", "SIZE" => 2, "MULTIPLE" => true,
	                "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
	  # <SELECT NAME="name" MULTIPLE SIZE="2">
	  #   <OPTION VALUE="1">Foo</OPTION>
	  #   <OPTION SELECTED VALUE="2">Bar</OPTION>
	  #   <OPTION VALUE="Baz">Baz</OPTION>
	  # </SELECT>
d1606 2
a1607 2
	submit
	  # <INPUT TYPE="submit">
d1609 2
a1610 2
	submit("ok")
	  # <INPUT TYPE="submit" VALUE="ok">
d1612 2
a1613 2
	submit("ok", "button1")
	  # <INPUT TYPE="submit" VALUE="ok" NAME="button1">
d1615 2
a1616 2
	submit({ "VALUE" => "ok", "NAME" => "button1", "ID" => "foo" })
	  # <INPUT TYPE="submit" VALUE="ok" NAME="button1" ID="foo">
d1631 2
a1632 2
	text_field("name")
	  # <INPUT TYPE="text" NAME="name" SIZE="40">
d1634 2
a1635 2
	text_field("name", "value")
	  # <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="40">
d1637 2
a1638 2
	text_field("name", "value", 80)
	  # <INPUT TYPE="text" NAME="name" VALUE="value", SIZE="80">
d1640 2
a1641 2
	text_field("name", "value", 80, 200)
	  # <INPUT TYPE="text" NAME="name" VALUE="value", SIZE="80", MAXLENGTH="200">
d1643 2
a1644 2
	text_field({ "NAME" => "name", "VALUE" => "value" })
	  # <INPUT TYPE="text" NAME="name" VALUE="value">
d1662 2
a1663 2
	textarea("name")
	  # = textarea({ "NAME" => "name", "COLS" => 70, "ROWS" => 10 })
d1665 2
a1666 2
	textarea("name", 40, 5)
	  # = textarea({ "NAME" => "name", "COLS" => 40, "ROWS" => 5 })
d2004 1
a2004 1
	HTTP_STATUS["NOT_INPLEMENTED"] --> HTTP_STATUS["NOT_IMPLEMENTED"]
d2015 2
a2016 2
	cgi = CGI.new
	cgi.out{"string"}             # old: CGI::print{"string"}
d2020 1
a2020 1
	cookie1 = CGI::Cookie::new    # old: CGI::cookie
d2029 3
a2031 3
	query = CGI.new
	cookies = query.cookies       # old: query.cookie
	values = query.cookies[name]  # old: query.cookie[name]
@


1.10
log
@Sun Jun  4 03:17:36 2000  Wakou Aoyama <wakou@@fsinet.or.jp>

        * lib/cig.rb: improve: CGI::pretty()
@
text
@d2 1
a2 1
$Date: 2000/06/03 18:16:17 $
d8 1
a8 1
Version 1.60
d188 2
a189 2
  VERSION = "1.60"
  RELEASE_DATE = "$Date: 2000/06/03 18:16:17 $"
d755 6
a760 1
      content_length -= stdinput.read((boundary + EOL).size).size
d1910 6
@


1.9
log
@Wed May 31 04:06:41 2000  Wakou Aoyama <wakou@@fsinet.or.jp>

        * lib/cgi.rb: change: CGI#out()
          if "HEAD" == REQUEST_METHOD then output only HTTP header.
@
text
@d2 1
a2 1
$Date: 2000/05/30 19:04:08 $
d8 1
a8 1
Version 1.50
d97 1
a97 1
	cgi.out({ "cookie" => cgi.cookies }){}
d104 1
a104 1
	cgi.out({ "cookie" => cgi.cookies['name'] }){}
d148 2
a149 2
	cgi.out{
	  cgi.html{
d151 2
a152 2
	    cgi.body{
	      cgi.form{
d156 2
a157 2
	      } +
	      cgi.pre{
d161 1
a161 1
	          ENV.collect{|key, value|
d163 1
a163 1
	          }.to_s
d165 4
a168 4
	      }
	    }
	  }
	}
d188 2
a189 2
  VERSION = "1.50"
  RELEASE_DATE = "$Date: 2000/05/30 19:04:08 $"
d928 7
a934 7
  def CGI::pretty_shift(string, shift = "  ")
    shift = "  " if true == shift
    string.gsub(/\n(?!\z)/n, "\n" + shift)
  end
  def CGI::pretty_nest(string, shift = "  ")
    string.gsub(/(<(\w+).*?>)((?:.|\n)*?)(<\/\2>)/n) do
      $1 + CGI::pretty_shift(CGI::pretty_nest($3, shift), shift) + $4
d936 1
a936 5
  end
  def CGI::pretty(string, shift = "  ")
    CGI::pretty_nest(
      string.gsub(/<(?:.|\n)*?>/n, "\n\\0").gsub(/<(?:.|\n)*?>(?!\n)/n, "\\0\n"), shift
    )
d1905 6
@


1.8
log
@Wed May 24 16:03:06 2000  Wakou Aoyama <wakou@@fsinet.or.jp>

        * lib/cgi.rb bug fix: CGI::escape(), CGI::Cookie::new()
        * lib/net/telnet.rb improve: binmode(), telnetmode() interface
@
text
@d2 1
a2 1
$Date: 2000/05/24 06:58:51 $
d8 1
a8 1
Version 1.40
d188 2
a189 2
  VERSION = "1.40"
  RELEASE_DATE = "$Date: 2000/05/24 06:58:51 $"
d516 2
d546 1
a546 1
    output.print content
d1909 7
@


1.7
log
@2000-05-09
@
text
@d2 1
a2 1
$Date: 2000/05/08 21:51:30 $
d8 1
a8 1
Version 1.31
d188 2
a189 2
  VERSION = "1.31"
  RELEASE_DATE = "$Date: 2000/05/08 21:51:30 $"
d242 6
a247 2
    string.gsub(/ /n, '+').gsub(/([^a-zA-Z0-9_.-])/n) do
      sprintf("%%%02X", $1.unpack("C")[0])
d610 1
a610 1
        @@path = ENV["SCRIPT_NAME"] or ""
d1907 9
@


1.7.2.1
log
@add cgi.rb
@
text
@d2 1
a2 1
$Date: 2000/05/09 04:53:11 $
d189 1
a189 1
  RELEASE_DATE = "$Date: 2000/05/09 04:53:11 $"
@


1.7.2.2
log
@Wed May 24 16:03:06 2000  Wakou Aoyama <wakou@@fsinet.or.jp>

        * lib/cgi.rb bug fix: CGI::escape(), CGI::Cookie::new()
        * lib/net/telnet.rb improve: binmode(), telnetmode() interface
@
text
@d2 1
a2 1
$Date: 2000/05/24 06:58:51 $
d8 1
a8 1
Version 1.40
d188 2
a189 2
  VERSION = "1.40"
  RELEASE_DATE = "$Date: 2000/05/24 06:58:51 $"
d242 2
a243 6
    string.gsub(/([^a-zA-Z0-9_.-])/n) do
      if " " == $1
        "+"
      else
        sprintf("%%%02X", $1.unpack("C")[0])
      end
d606 1
a606 1
        @@path = (ENV["SCRIPT_NAME"] or "")
a1902 9

=== Version 1.40 - wakou

2000/05/24 06:58:51

- typo: CGI::Cookie::new()
- bug fix: CGI::escape()
  bad: " " --> "%2B"  true: " " --> "+"
  thanks to Ryunosuke Ohshima <ryu@@jaist.ac.jp>
@


1.7.2.3
log
@Wed May 31 04:06:41 2000  Wakou Aoyama <wakou@@fsinet.or.jp>

        * lib/cgi.rb: change: CGI#out()
          if "HEAD" == REQUEST_METHOD then output only HTTP header.
@
text
@d2 1
a2 1
$Date: 2000/05/30 19:15:27 $
d8 1
a8 1
Version 1.50
d188 2
a189 2
  VERSION = "1.50"
  RELEASE_DATE = "$Date: 2000/05/30 19:15:27 $"
a515 2
if "HEAD" == REQUEST_METHOD then output only HTTP header.

d544 1
a544 1
    output.print content unless "HEAD" == env_table['REQUEST_METHOD']
a1906 7

=== Version 1.50 - wakou

2000/05/30 19:04:08

- CGI#out()
  if "HEAD" == REQUEST_METHOD then output only HTTP header.
@


1.7.2.4
log
@Sun Jun  4 03:17:36 2000  Wakou Aoyama <wakou@@fsinet.or.jp>

        * lib/cig.rb: improve: CGI::pretty()
@
text
@d2 1
a2 1
$Date: 2000/06/03 18:16:17 $
d8 1
a8 1
Version 1.60
d97 1
a97 1
	cgi.out("cookie" => cgi.cookies){"string"}
d104 1
a104 1
	cgi.out("cookie" => cgi.cookies['name']){"string"}
d148 2
a149 2
	cgi.out() do
	  cgi.html() do
d151 2
a152 2
	    cgi.body() do
	      cgi.form() do
d156 2
a157 2
	      end +
	      cgi.pre() do
d161 1
a161 1
	          ENV.collect() do |key, value|
d163 1
a163 1
	          end.join("")
d165 4
a168 4
	      end
	    end
	  end
	end
d188 2
a189 2
  VERSION = "1.60"
  RELEASE_DATE = "$Date: 2000/06/03 18:16:17 $"
d928 9
d938 3
a940 8
    lines = string.gsub(/(?!\A)<(?:.|\n)*?>/n, "\n\\0").gsub(/<(?:.|\n)*?>(?!\n)/n, "\\0\n")
    end_pos = 0
    while end_pos = lines.index(/^<\/(\w+)/n, end_pos)
      element = $1.dup
      start_pos = lines.rindex(/^\s*<#{element}/ni, end_pos)
      lines[start_pos ... end_pos] = "__" + lines[start_pos ... end_pos].gsub(/\n(?!\z)/n, "\n" + shift) + "__"
    end
    lines.gsub(/^(\s*)__(?=<\/?\w)/n, '\1')
a1908 6

=== Version 1.60 - wakou

2000/06/03 18:16:17

- improve: CGI::pretty()
@


1.7.2.5
log
@Wed Jun 14 00:50:14 2000  Wakou Aoyama <wakou@@fsinet.or.jp>

        * lib/cig.rb: read_multipart(): if no content body then raise EOFError.
@
text
@d2 1
a2 1
$Date: 2000/06/13 15:49:27 $
d8 1
a8 1
Version 1.61
d188 2
a189 2
  VERSION = "1.61"
  RELEASE_DATE = "$Date: 2000/06/13 15:49:27 $"
d755 1
a755 6
      boundary_size = boundary.size + EOL.size
      content_length -= boundary_size
      status = stdinput.read(boundary_size)
      if nil == status
        raise EOFError, "no content body"
      end
a1904 6

=== Version 1.61 - wakou

2000/06/13 15:49:27

- read_multipart(): if no content body then raise EOFError.
@


1.7.2.6
log
@expand tabs: lib/cgi.rb, lib/net/telnet.rb
@
text
@d2 1
a2 1
$Date: 2000/06/17 17:50:54 $
d20 10
a29 10
        require "cgi"
        cgi = CGI.new
        values = cgi['field_name']   # <== array of 'field_name'
          # if not 'field_name' included, then return [].
        fields = cgi.keys            # <== array of field names

        # returns true if form has 'field_name'
        cgi.has_key?('field_name')
        cgi.has_key?('field_name')
        cgi.include?('field_name')
d34 3
a36 3
        require "cgi"
        cgi = CGI.new
        params = cgi.params
d40 4
a43 4
        cgi.params['new_field_name'] = ["value"]  # add new param
        cgi.params['field_name'] = ["new_value"]  # change value
        cgi.params.delete('field_name')           # delete param
        cgi.params.clear                          # delete all params
d48 5
a52 5
        require "pstore"
        db = PStore.new("query.db")
        db.transaction do
          db["params"] = cgi.params
        end
d57 5
a61 5
        require "pstore"
        db = PStore.new("query.db")
        db.transaction do
          cgi.params = db["params"]
        end
d66 7
a72 7
        require "cgi"
        cgi = CGI.new
        values = cgi['field_name']   # <== array of 'field_name'
        values[0].read               # <== body of values[0]
        values[0].local_path         # <== path to local file of values[0]
        values[0].original_filename  # <== original filename of values[0]
        values[0].content_type       # <== content_type of values[0]
d81 5
a85 5
        require "cgi"
        cgi = CGI.new
        values = cgi.cookies['name']  # <== array of 'name'
          # if not 'name' included, then return [].
        names = cgi.cookies.keys      # <== array of cookie names
d92 13
a104 13
        require "cgi"
        cgi = CGI.new
        for name, cookie in cgi.cookies
          cookie.expires = Time.now + 30
        end
        cgi.out("cookie" => cgi.cookies){"string"}

        cgi.cookies # { "name1" => cookie1, "name2" => cookie2, ... }

        require "cgi"
        cgi = CGI.new
        cgi.cookies['name'].expires = Time.now + 30
        cgi.out("cookie" => cgi.cookies['name']){"string"}
d111 4
a114 4
        require "cgi"
        cgi = CGI.new
        value = cgi.auth_type
          # ENV["AUTH_TYPE"]
d127 4
a130 4
        value = cgi.raw_cookie
          # ENV["HTTP_COOKIE"]
        value = cgi.raw_cookie2
          # ENV["HTTP_COOKIE2"]
d134 4
a137 4
        value = cgi.accept
          # ENV["HTTP_ACCEPT"]
        value = cgi.accept_charset
          # ENV["HTTP_ACCEPT_CHARSET"]
d146 29
a174 29
        require "cgi"
        cgi = CGI.new("html3")  # add HTML generation methods
        cgi.out() do
          cgi.html() do
            cgi.head{ cgi.title{"TITLE"} } +
            cgi.body() do
              cgi.form() do
                cgi.textarea("get_text") +
                cgi.br +
                cgi.submit
              end +
              cgi.pre() do
                CGI::escapeHTML(
                  "params: " + cgi.params.inspect + "\n" +
                  "cookies: " + cgi.cookies.inspect + "\n" +
                  ENV.collect() do |key, value|
                    key + " --> " + value + "\n"
                  end.join("")
                )
              end
            end
          end
        end

        # add HTML generation methods
        CGI.new("html3")    # html3.2
        CGI.new("html4")    # html4.0 (Strict)
        CGI.new("html4Tr")  # html4.0 Transitional
        CGI.new("html4Fr")  # html4.0 Frameset
d189 1
a189 1
  RELEASE_DATE = "$Date: 2000/06/17 17:50:54 $"
d239 1
a239 1
        url_encoded_string = CGI::escape("string")
d254 1
a254 1
        string = CGI::unescape("url encoded string")
d265 1
a265 1
        CGI::escapeHTML("string")
d274 1
a274 1
        CGI::unescapeHTML("HTML escaped string")
d302 2
a303 2
        print CGI::escapeElement("<BR><A HREF="url"></A>", "A", "IMG")
          # "<BR>&lt;A HREF="url"&gt;&lt;/A&gt"
d305 2
a306 2
        print CGI::escapeElement("<BR><A HREF="url"></A>", ["A", "IMG"])
          # "<BR>&lt;A HREF="url"&gt;&lt;/A&gt"
d317 7
a323 7
        print CGI::unescapeElement(
                CGI::escapeHTML("<BR><A HREF="url"></A>"), "A", "IMG")
          # "&lt;BR&gt;<A HREF="url"></A>"

        print CGI::unescapeElement(
                CGI::escapeHTML("<BR><A HREF="url"></A>"), ["A", "IMG"])
          # "&lt;BR&gt;<A HREF="url"></A>"
d334 2
a335 2
        CGI::rfc1123_date(Time.now)
          # Sut, 1 Jan 2000 00:00:00 GMT
d347 2
a348 2
        header
          # Content-Type: text/html
d350 2
a351 2
        header("text/plain")
          # Content-Type: text/plain
d353 13
a365 13
        header({"nph"        => true,
                "status"     => "OK",  # == "200 OK"
                  # "status"     => "200 GOOD",
                "server"     => ENV['SERVER_SOFTWARE'],
                "connection" => "close",
                "type"       => "text/html",
                "charset"    => "iso-2022-jp",
                  # Content-Type: text/html; charset=iso-2022-jp
                "language"   => "ja",
                "expires"    => Time.now + 30,
                "cookie"     => [cookie1, cookie2],
                "my_header1" => "my_value"
                "my_header2" => "my_value"})
d370 18
a387 18
        "OK"                  --> "200 OK"
        "PARTIAL_CONTENT"     --> "206 Partial Content"
        "MULTIPLE_CHOICES"    --> "300 Multiple Choices"
        "MOVED"               --> "301 Moved Permanently"
        "REDIRECT"            --> "302 Found"
        "NOT_MODIFIED"        --> "304 Not Modified"
        "BAD_REQUEST"         --> "400 Bad Request"
        "AUTH_REQUIRED"       --> "401 Authorization Required"
        "FORBIDDEN"           --> "403 Forbidden"
        "NOT_FOUND"           --> "404 Not Found"
        "METHOD_NOT_ALLOWED"  --> "405 Method Not Allowed"
        "NOT_ACCEPTABLE"      --> "406 Not Acceptable"
        "LENGTH_REQUIRED"     --> "411 Length Required"
        "PRECONDITION_FAILED" --> "412 Rrecondition Failed"
        "SERVER_ERROR"        --> "500 Internal Server Error"
        "NOT_IMPLEMENTED"     --> "501 Method Not Implemented"
        "BAD_GATEWAY"         --> "502 Bad Gateway"
        "VARIANT_ALSO_VARIES" --> "506 Variant Also Negotiates"
d467 1
a467 1
        buf.concat("Set-Cookie: " + cookie.to_s + EOL)
d490 25
a514 25
        cgi = CGI.new
        cgi.out{ "string" }
          # Content-Type: text/html
          # Content-Length: 6
          #
          # string

        cgi.out("text/plain"){ "string" }
          # Content-Type: text/plain
          # Content-Length: 6
          #
          # string

        cgi.out({"nph"        => true,
                 "status"     => "OK",  # == "200 OK"
                 "server"     => ENV['SERVER_SOFTWARE'],
                 "connection" => "close",
                 "type"       => "text/html",
                 "charset"    => "iso-2022-jp",
                   # Content-Type: text/html; charset=iso-2022-jp
                 "language"   => "ja",
                 "expires"    => Time.now + (3600 * 24 * 30),
                 "cookie"     => [cookie1, cookie2],
                 "my_header1" => "my_value",
                 "my_header2" => "my_value"}){ "string" }
d552 2
a553 2
        cgi = CGI.new
        cgi.print    # default:  cgi.print == $DEFAULT_OUTPUT.print
d562 25
a586 25
        cookie1 = CGI::Cookie::new("name", "value1", "value2", ...)
        cookie1 = CGI::Cookie::new({"name" => "name", "value" => "value"})
        cookie1 = CGI::Cookie::new({'name'    => 'name',
                                    'value'   => ['value1', 'value2', ...],
                                    'path'    => 'path',   # optional
                                    'domain'  => 'domain', # optional
                                    'expires' => Time.now, # optional
                                    'secure'  => true      # optional
                                   })

        cgi.out({"cookie" => [cookie1, cookie2]}){ "string" }

        name    = cookie1.name
        values  = cookie1.value
        path    = cookie1.path
        domain  = cookie1.domain
        expires = cookie1.expires
        secure  = cookie1.secure

        cookie1.name    = 'name'
        cookie1.value   = ['value1', 'value2', ...]
        cookie1.path    = 'path'
        cookie1.domain  = 'domain'
        cookie1.expires = Time.now + 30
        cookie1.secure  = true
d662 2
a663 2
        cookies = CGI::Cookie::parse("raw_cookie_string")
          # { "name1" => cookie1, "name2" => cookie2, ... }
d687 3
a689 3
        params = CGI::parse("query_string")
          # {"name1" => ["value1", "value2", ...],
          #  "name2" => ["value1", "value2", ...], ... }
d921 11
a931 11
        print CGI::pretty("<HTML><BODY></BODY></HTML>")
          # <HTML>
          #   <BODY>
          #   </BODY>
          # </HTML>

        print CGI::pretty("<HTML><BODY></BODY></HTML>", "\t")
          # <HTML>
          #         <BODY>
          #         </BODY>
          # </HTML>
d948 11
a958 11
        cgi = CGI.new("html3")  # add HTML generation methods
        cgi.element
        cgi.element{ "string" }
        cgi.element({ "ATTRILUTE1" => "value1", "ATTRIBUTE2" => "value2" })
        cgi.element({ "ATTRILUTE1" => "value1", "ATTRIBUTE2" => "value2" }){ "string" }

        # add HTML generation methods
        CGI.new("html3")    # html3.2
        CGI.new("html4")    # html4.0 (Strict)
        CGI.new("html4Tr")  # html4.0 Transitional
        CGI.new("html4Fr")  # html4.0 Frameset
d1029 2
a1030 2
        a("url")
          # = a({ "HREF" => "url" })
d1048 2
a1049 2
        base("url")
          # = base({ "HREF" => "url" })
d1067 2
a1068 2
        blockquote("url"){ "string" }
          # = blockquote({ "CITE" => "url" }){ "string" }
d1086 2
a1087 2
        caption("align"){ "string" }
          # = caption({ "ALIGN" => "align" }){ "string" }
d1105 2
a1106 2
        checkbox("name")
          # = checkbox({ "NAME" => "name" })
d1108 2
a1109 2
        checkbox("name", "value")
          # = checkbox({ "NAME" => "name", "VALUE" => "value" })
d1111 2
a1112 2
        checkbox("name", "value", true)
          # = checkbox({ "NAME" => "name", "VALUE" => "value", "CHECKED" => true })
d1128 14
a1141 14
        checkbox_group("name", "foo", "bar", "baz")
          # <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo
          # <INPUT TYPE="checkbox" NAME="name" VALUE="bar">bar
          # <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz

        checkbox_group("name", ["foo"], ["bar", true], "baz")
          # <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo
          # <INPUT TYPE="checkbox" SELECTED NAME="name" VALUE="bar">bar
          # <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz

        checkbox_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
          # <INPUT TYPE="checkbox" NAME="name" VALUE="1">Foo
          # <INPUT TYPE="checkbox" SELECTED NAME="name" VALUE="2">Bar
          # <INPUT TYPE="checkbox" NAME="name" VALUE="Baz">Baz
d1143 2
a1144 2
        checkbox_group({ "NAME" => "name",
                         "VALUES" => ["foo", "bar", "baz"] })
d1146 2
a1147 2
        checkbox_group({ "NAME" => "name",
                         "VALUES" => [["foo"], ["bar", true], "baz"] })
d1149 2
a1150 2
        checkbox_group({ "NAME" => "name",
                         "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
d1175 2
a1176 2
        file_field("name")
          # <INPUT TYPE="file" NAME="name" SIZE="20">
d1178 2
a1179 2
        file_field("name", 40)
          # <INPUT TYPE="file" NAME="name" SIZE="40">
d1181 2
a1182 2
        file_field("name", 40, 100)
          # <INPUT TYPE="file" NAME="name" SIZE="40", MAXLENGTH="100">
d1184 2
a1185 2
        file_field({ "NAME" => "name", "SIZE" => 40 })
          # <INPUT TYPE="file" NAME="name" SIZE="40">
d1202 2
a1203 2
        form{ "string" }
          # <FORM METHOD="post" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1205 2
a1206 2
        form("get"){ "string" }
          # <FORM METHOD="get" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1208 2
a1209 2
        form("get", "url"){ "string" }
          # <FORM METHOD="get" ACTION="url" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1211 2
a1212 2
        form({"METHOD" => "post", ENCTYPE => "enctype"}){ "string" }
          # <FORM METHOD="post" ENCTYPE="enctype">string</FORM>
d1228 1
a1228 1
        body = yield
d1233 4
a1236 4
        hidden = @@output_hidden.collect{|k,v|
          "<INPUT TYPE=HIDDEN NAME=\"#{k}\" VALUE=\"#{v}\">"
        }.to_s
        body.concat hidden
d1243 2
a1244 2
        hidden("name")
          # <INPUT TYPE="hidden" NAME="name">
d1246 2
a1247 2
        hidden("name", "value")
          # <INPUT TYPE="hidden" NAME="name" VALUE="value">
d1249 2
a1250 2
        hidden({ "NAME" => "name", "VALUE" => "reset", "ID" => "foo" })
          # <INPUT TYPE="hidden" NAME="name" VALUE="value" ID="foo">
d1266 2
a1267 2
        html{ "string" }
          # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML>string</HTML>
d1269 2
a1270 2
        html({ "LANG" => "ja" }){ "string" }
          # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML LANG="ja">string</HTML>
d1272 2
a1273 2
        html({ "DOCTYPE" => false }){ "string" }
          # <HTML>string</HTML>
d1275 16
a1290 16
        html({ "DOCTYPE" => '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">' }){ "string" }
          # <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"><HTML>string</HTML>

        html({ "PRETTY" => "  " }){ "<BODY></BODY>" }
          # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
          # <HTML>
          #   <BODY>
          #   </BODY>
          # </HTML>

        html({ "PRETTY" => "\t" }){ "<BODY></BODY>" }
          # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
          # <HTML>
          #         <BODY>
          #         </BODY>
          # </HTML>
d1292 2
a1293 2
        html("PRETTY"){ "<BODY></BODY>" }
          # = html({ "PRETTY" => "  " }){ "<BODY></BODY>" }
d1295 1
a1295 1
        html(if $VERBOSE then "PRETTY" end){ "HTML string" }
d1334 2
a1335 2
        image_button("url")
          # <INPUT TYPE="image" SRC="url">
d1337 2
a1338 2
        image_button("url", "name", "string")
          # <INPUT TYPE="image" SRC="url" NAME="name", ALT="string">
d1340 2
a1341 2
        image_button({ "SRC" => "url", "ATL" => "strng" })
          # <INPUT TYPE="image" SRC="url" ALT="string">
d1358 2
a1359 2
        img("src", "alt", 100, 50)
          # <IMG SRC="src" ALT="alt" WIDTH="100", HEIGHT="50">
d1361 2
a1362 2
        img({ "SRC" => "src", "ALT" => "alt", "WIDTH" => 100, "HEIGHT" => 50 })
          # <IMG SRC="src" ALT="alt" WIDTH="100", HEIGHT="50">
d1378 2
a1379 2
        multipart_form{ "string" }
          # <FORM METHOD="post" ENCTYPE="multipart/form-data">string</FORM>
d1381 2
a1382 2
        multipart_form("url"){ "string" }
          # <FORM METHOD="post" ACTION="url" ENCTYPE="multipart/form-data">string</FORM>
d1409 2
a1410 2
        password_field("name")
          # <INPUT TYPE="password" NAME="name" SIZE="40">
d1412 2
a1413 2
        password_field("name", "value")
          # <INPUT TYPE="password" NAME="name" VALUE="value" SIZE="40">
d1415 2
a1416 2
        password_field("password", "value", 80, 200)
          # <INPUT TYPE="password" NAME="name" VALUE="value", SIZE="80", MAXLENGTH="200">
d1418 2
a1419 2
        password_field({ "NAME" => "name", "VALUE" => "value" })
          # <INPUT TYPE="password" NAME="name" VALUE="value">
d1436 28
a1463 28
        popup_menu("name", "foo", "bar", "baz")
          # <SELECT NAME="name">
          #   <OPTION VALUE="foo">foo</OPTION>
          #   <OPTION VALUE="bar">bar</OPTION>
          #   <OPTION VALUE="baz">baz</OPTION>
          # </SELECT>

        popup_menu("name", ["foo"], ["bar", true], "baz")
          # <SELECT NAME="name">
          #   <OPTION VALUE="foo">foo</OPTION>
          #   <OPTION VALUE="bar" SELECTED>bar</OPTION>
          #   <OPTION VALUE="baz">baz</OPTION>
          # </SELECT>

        popup_menu("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
          # <SELECT NAME="name">
          #   <OPTION VALUE="1">Foo</OPTION>
          #   <OPTION SELECTED VALUE="2">Bar</OPTION>
          #   <OPTION VALUE="Baz">Baz</OPTION>
          # </SELECT>

        popup_menu({"NAME" => "name", "SIZE" => 2, "MULTIPLE" => true,
                    "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
          # <SELECT NAME="name" MULTIPLE SIZE="2">
          #   <OPTION VALUE="1">Foo</OPTION>
          #   <OPTION SELECTED VALUE="2">Bar</OPTION>
          #   <OPTION VALUE="Baz">Baz</OPTION>
          # </SELECT>
d1501 2
a1502 2
        radio_button("name", "value")
          # <INPUT TYPE="radio" NAME="name", VALUE="value">
d1504 2
a1505 2
        radio_button("name", "value", true)
          # <INPUT TYPE="radio" NAME="name", VALUE="value", CHECKED>
d1507 2
a1508 2
        radio_button({ "NAME" => "name", "VALUE" => "value", "ID" => "foo" })
          # <INPUT TYPE="radio" NAME="name" VALUE="value" ID="foo">
d1524 14
a1537 14
        radio_group("name", "foo", "bar", "baz")
          # <INPUT TYPE="radio" NAME="name" VALUE="foo">foo
          # <INPUT TYPE="radio" NAME="name" VALUE="bar">bar
          # <INPUT TYPE="radio" NAME="name" VALUE="baz">baz

        radio_group("name", ["foo"], ["bar", true], "baz")
          # <INPUT TYPE="radio" NAME="name" VALUE="foo">foo
          # <INPUT TYPE="radio" SELECTED NAME="name" VALUE="bar">bar
          # <INPUT TYPE="radio" NAME="name" VALUE="baz">baz

        radio_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
          # <INPUT TYPE="radio" NAME="name" VALUE="1">Foo
          # <INPUT TYPE="radio" SELECTED NAME="name" VALUE="2">Bar
          # <INPUT TYPE="radio" NAME="name" VALUE="Baz">Baz
d1539 2
a1540 2
        radio_group({ "NAME" => "name",
                      "VALUES" => ["foo", "bar", "baz"] })
d1542 2
a1543 2
        radio_group({ "NAME" => "name",
                      "VALUES" => [["foo"], ["bar", true], "baz"] })
d1545 2
a1546 2
        radio_group({ "NAME" => "name",
                      "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
d1571 2
a1572 2
        reset
          # <INPUT TYPE="reset">
d1574 2
a1575 2
        reset("reset")
          # <INPUT TYPE="reset" VALUE="reset">
d1577 2
a1578 2
        reset({ "VALUE" => "reset", "ID" => "foo" })
          # <INPUT TYPE="reset" VALUE="reset" ID="foo">
d1593 7
a1599 7
        scrolling_list({"NAME" => "name", "SIZE" => 2, "MULTIPLE" => true,
                        "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
          # <SELECT NAME="name" MULTIPLE SIZE="2">
          #   <OPTION VALUE="1">Foo</OPTION>
          #   <OPTION SELECTED VALUE="2">Bar</OPTION>
          #   <OPTION VALUE="Baz">Baz</OPTION>
          # </SELECT>
d1606 2
a1607 2
        submit
          # <INPUT TYPE="submit">
d1609 2
a1610 2
        submit("ok")
          # <INPUT TYPE="submit" VALUE="ok">
d1612 2
a1613 2
        submit("ok", "button1")
          # <INPUT TYPE="submit" VALUE="ok" NAME="button1">
d1615 2
a1616 2
        submit({ "VALUE" => "ok", "NAME" => "button1", "ID" => "foo" })
          # <INPUT TYPE="submit" VALUE="ok" NAME="button1" ID="foo">
d1631 2
a1632 2
        text_field("name")
          # <INPUT TYPE="text" NAME="name" SIZE="40">
d1634 2
a1635 2
        text_field("name", "value")
          # <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="40">
d1637 2
a1638 2
        text_field("name", "value", 80)
          # <INPUT TYPE="text" NAME="name" VALUE="value", SIZE="80">
d1640 2
a1641 2
        text_field("name", "value", 80, 200)
          # <INPUT TYPE="text" NAME="name" VALUE="value", SIZE="80", MAXLENGTH="200">
d1643 2
a1644 2
        text_field({ "NAME" => "name", "VALUE" => "value" })
          # <INPUT TYPE="text" NAME="name" VALUE="value">
d1662 2
a1663 2
        textarea("name")
          # = textarea({ "NAME" => "name", "COLS" => 70, "ROWS" => 10 })
d1665 2
a1666 2
        textarea("name", 40, 5)
          # = textarea({ "NAME" => "name", "COLS" => 40, "ROWS" => 5 })
d2004 1
a2004 1
        HTTP_STATUS["NOT_INPLEMENTED"] --> HTTP_STATUS["NOT_IMPLEMENTED"]
d2015 2
a2016 2
        cgi = CGI.new
        cgi.out{"string"}             # old: CGI::print{"string"}
d2020 1
a2020 1
        cookie1 = CGI::Cookie::new    # old: CGI::cookie
d2029 3
a2031 3
        query = CGI.new
        cookies = query.cookies       # old: query.cookie
        values = query.cookies[name]  # old: query.cookie[name]
@


1.7.2.7
log
@Tue Jun 20 06:14:43 2000  Wakou Aoyama <wakou@@fsinet.or.jp>

        * lib/cgi.rb: change: version syntax. old: x.yz, now: x.y.z

        * lib/net/telnet.rb: ditto.
@
text
@d2 1
d8 1
a8 1
Version 1.7.0
a10 1

a15 1

d20 10
a29 10
  require "cgi"
  cgi = CGI.new
  values = cgi['field_name']   # <== array of 'field_name'
    # if not 'field_name' included, then return [].
  fields = cgi.keys            # <== array of field names

  # returns true if form has 'field_name'
  cgi.has_key?('field_name')
  cgi.has_key?('field_name')
  cgi.include?('field_name')
d34 3
a36 3
  require "cgi"
  cgi = CGI.new
  params = cgi.params
d40 4
a43 4
  cgi.params['new_field_name'] = ["value"]  # add new param
  cgi.params['field_name'] = ["new_value"]  # change value
  cgi.params.delete('field_name')           # delete param
  cgi.params.clear                          # delete all params
d48 5
a52 5
  require "pstore"
  db = PStore.new("query.db")
  db.transaction do
    db["params"] = cgi.params
  end
d57 5
a61 5
  require "pstore"
  db = PStore.new("query.db")
  db.transaction do
    cgi.params = db["params"]
  end
d66 7
a72 7
  require "cgi"
  cgi = CGI.new
  values = cgi['field_name']   # <== array of 'field_name'
  values[0].read               # <== body of values[0]
  values[0].local_path         # <== path to local file of values[0]
  values[0].original_filename  # <== original filename of values[0]
  values[0].content_type       # <== content_type of values[0]
d75 1
d81 5
a85 5
  require "cgi"
  cgi = CGI.new
  values = cgi.cookies['name']  # <== array of 'name'
    # if not 'name' included, then return [].
  names = cgi.cookies.keys      # <== array of cookie names
d92 6
a97 6
  require "cgi"
  cgi = CGI.new
  for name, cookie in cgi.cookies
    cookie.expires = Time.now + 30
  end
  cgi.out("cookie" => cgi.cookies){"string"}
d99 1
a99 1
  cgi.cookies # { "name1" => cookie1, "name2" => cookie2, ... }
d101 4
a104 4
  require "cgi"
  cgi = CGI.new
  cgi.cookies['name'].expires = Time.now + 30
  cgi.out("cookie" => cgi.cookies['name']){"string"}
d111 4
a114 4
  require "cgi"
  cgi = CGI.new
  value = cgi.auth_type
    # ENV["AUTH_TYPE"]
d116 1
a116 1
see http://www.w3.org/CGI/
d127 4
a130 4
  value = cgi.raw_cookie
    # ENV["HTTP_COOKIE"]
  value = cgi.raw_cookie2
    # ENV["HTTP_COOKIE2"]
d134 4
a137 4
  value = cgi.accept
    # ENV["HTTP_ACCEPT"]
  value = cgi.accept_charset
    # ENV["HTTP_ACCEPT_CHARSET"]
d146 22
a167 19
  require "cgi"
  cgi = CGI.new("html3")  # add HTML generation methods
  cgi.out() do
    cgi.html() do
      cgi.head{ cgi.title{"TITLE"} } +
      cgi.body() do
        cgi.form() do
          cgi.textarea("get_text") +
          cgi.br +
          cgi.submit
        end +
        cgi.pre() do
          CGI::escapeHTML(
            "params: " + cgi.params.inspect + "\n" +
            "cookies: " + cgi.cookies.inspect + "\n" +
            ENV.collect() do |key, value|
              key + " --> " + value + "\n"
            end.join("")
          )
a168 9
      end
    end
  end

  # add HTML generation methods
  CGI.new("html3")    # html3.2
  CGI.new("html4")    # html4.0 (Strict)
  CGI.new("html4Tr")  # html4.0 Transitional
  CGI.new("html4Fr")  # html4.0 Frameset
d170 5
d186 5
a190 4
  VERSION = "1.7.0"
  RELEASE_DATE = "2000-06-19"
  VERSION_CODE = 170
  RELEASE_CODE = 20000619
d239 1
a239 1
  url_encoded_string = CGI::escape("string")
d254 1
a254 1
  string = CGI::unescape("url encoded string")
d265 1
a265 1
  CGI::escapeHTML("string")
d274 1
a274 1
  CGI::unescapeHTML("HTML escaped string")
d302 2
a303 2
  print CGI::escapeElement("<BR><A HREF="url"></A>", "A", "IMG")
    # "<BR>&lt;A HREF="url"&gt;&lt;/A&gt"
d305 2
a306 2
  print CGI::escapeElement("<BR><A HREF="url"></A>", ["A", "IMG"])
    # "<BR>&lt;A HREF="url"&gt;&lt;/A&gt"
d317 7
a323 7
  print CGI::unescapeElement(
          CGI::escapeHTML("<BR><A HREF="url"></A>"), "A", "IMG")
    # "&lt;BR&gt;<A HREF="url"></A>"

  print CGI::unescapeElement(
          CGI::escapeHTML("<BR><A HREF="url"></A>"), ["A", "IMG"])
    # "&lt;BR&gt;<A HREF="url"></A>"
d334 2
a335 2
  CGI::rfc1123_date(Time.now)
    # Sut, 1 Jan 2000 00:00:00 GMT
d347 2
a348 2
  header
    # Content-Type: text/html
d350 2
a351 2
  header("text/plain")
    # Content-Type: text/plain
d353 13
a365 13
  header({"nph"        => true,
          "status"     => "OK",  # == "200 OK"
            # "status"     => "200 GOOD",
          "server"     => ENV['SERVER_SOFTWARE'],
          "connection" => "close",
          "type"       => "text/html",
          "charset"    => "iso-2022-jp",
            # Content-Type: text/html; charset=iso-2022-jp
          "language"   => "ja",
          "expires"    => Time.now + 30,
          "cookie"     => [cookie1, cookie2],
          "my_header1" => "my_value"
          "my_header2" => "my_value"})
d370 18
a387 19

  "OK"                  --> "200 OK"
  "PARTIAL_CONTENT"     --> "206 Partial Content"
  "MULTIPLE_CHOICES"    --> "300 Multiple Choices"
  "MOVED"               --> "301 Moved Permanently"
  "REDIRECT"            --> "302 Found"
  "NOT_MODIFIED"        --> "304 Not Modified"
  "BAD_REQUEST"         --> "400 Bad Request"
  "AUTH_REQUIRED"       --> "401 Authorization Required"
  "FORBIDDEN"           --> "403 Forbidden"
  "NOT_FOUND"           --> "404 Not Found"
  "METHOD_NOT_ALLOWED"  --> "405 Method Not Allowed"
  "NOT_ACCEPTABLE"      --> "406 Not Acceptable"
  "LENGTH_REQUIRED"     --> "411 Length Required"
  "PRECONDITION_FAILED" --> "412 Rrecondition Failed"
  "SERVER_ERROR"        --> "500 Internal Server Error"
  "NOT_IMPLEMENTED"     --> "501 Method Not Implemented"
  "BAD_GATEWAY"         --> "502 Bad Gateway"
  "VARIANT_ALSO_VARIES" --> "506 Variant Also Negotiates"
d490 25
a514 25
  cgi = CGI.new
  cgi.out{ "string" }
    # Content-Type: text/html
    # Content-Length: 6
    #
    # string

  cgi.out("text/plain"){ "string" }
    # Content-Type: text/plain
    # Content-Length: 6
    #
    # string

  cgi.out({"nph"        => true,
           "status"     => "OK",  # == "200 OK"
           "server"     => ENV['SERVER_SOFTWARE'],
           "connection" => "close",
           "type"       => "text/html",
           "charset"    => "iso-2022-jp",
             # Content-Type: text/html; charset=iso-2022-jp
           "language"   => "ja",
           "expires"    => Time.now + (3600 * 24 * 30),
           "cookie"     => [cookie1, cookie2],
           "my_header1" => "my_value",
           "my_header2" => "my_value"}){ "string" }
d552 2
a553 2
  cgi = CGI.new
  cgi.print    # default:  cgi.print == $DEFAULT_OUTPUT.print
d562 25
a586 25
  cookie1 = CGI::Cookie::new("name", "value1", "value2", ...)
  cookie1 = CGI::Cookie::new({"name" => "name", "value" => "value"})
  cookie1 = CGI::Cookie::new({'name'    => 'name',
                              'value'   => ['value1', 'value2', ...],
                              'path'    => 'path',   # optional
                              'domain'  => 'domain', # optional
                              'expires' => Time.now, # optional
                              'secure'  => true      # optional
                             })

  cgi.out({"cookie" => [cookie1, cookie2]}){ "string" }

  name    = cookie1.name
  values  = cookie1.value
  path    = cookie1.path
  domain  = cookie1.domain
  expires = cookie1.expires
  secure  = cookie1.secure

  cookie1.name    = 'name'
  cookie1.value   = ['value1', 'value2', ...]
  cookie1.path    = 'path'
  cookie1.domain  = 'domain'
  cookie1.expires = Time.now + 30
  cookie1.secure  = true
d662 2
a663 2
  cookies = CGI::Cookie::parse("raw_cookie_string")
    # { "name1" => cookie1, "name2" => cookie2, ... }
d687 3
a689 3
  params = CGI::parse("query_string")
    # {"name1" => ["value1", "value2", ...],
    #  "name2" => ["value1", "value2", ...], ... }
d921 11
a931 11
  print CGI::pretty("<HTML><BODY></BODY></HTML>")
    # <HTML>
    #   <BODY>
    #   </BODY>
    # </HTML>

  print CGI::pretty("<HTML><BODY></BODY></HTML>", "\t")
    # <HTML>
    #         <BODY>
    #         </BODY>
    # </HTML>
d948 11
a958 11
  cgi = CGI.new("html3")  # add HTML generation methods
  cgi.element
  cgi.element{ "string" }
  cgi.element({ "ATTRILUTE1" => "value1", "ATTRIBUTE2" => "value2" })
  cgi.element({ "ATTRILUTE1" => "value1", "ATTRIBUTE2" => "value2" }){ "string" }

  # add HTML generation methods
  CGI.new("html3")    # html3.2
  CGI.new("html4")    # html4.0 (Strict)
  CGI.new("html4Tr")  # html4.0 Transitional
  CGI.new("html4Fr")  # html4.0 Frameset
d1029 2
a1030 2
  a("url")
    # = a({ "HREF" => "url" })
d1048 2
a1049 2
  base("url")
    # = base({ "HREF" => "url" })
d1067 2
a1068 2
  blockquote("url"){ "string" }
    # = blockquote({ "CITE" => "url" }){ "string" }
d1086 2
a1087 2
  caption("align"){ "string" }
    # = caption({ "ALIGN" => "align" }){ "string" }
d1105 2
a1106 2
  checkbox("name")
    # = checkbox({ "NAME" => "name" })
d1108 2
a1109 2
  checkbox("name", "value")
    # = checkbox({ "NAME" => "name", "VALUE" => "value" })
d1111 2
a1112 2
  checkbox("name", "value", true)
    # = checkbox({ "NAME" => "name", "VALUE" => "value", "CHECKED" => true })
d1128 14
a1141 14
  checkbox_group("name", "foo", "bar", "baz")
    # <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo
    # <INPUT TYPE="checkbox" NAME="name" VALUE="bar">bar
    # <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz

  checkbox_group("name", ["foo"], ["bar", true], "baz")
    # <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo
    # <INPUT TYPE="checkbox" SELECTED NAME="name" VALUE="bar">bar
    # <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz

  checkbox_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
    # <INPUT TYPE="checkbox" NAME="name" VALUE="1">Foo
    # <INPUT TYPE="checkbox" SELECTED NAME="name" VALUE="2">Bar
    # <INPUT TYPE="checkbox" NAME="name" VALUE="Baz">Baz
d1143 2
a1144 2
  checkbox_group({ "NAME" => "name",
                   "VALUES" => ["foo", "bar", "baz"] })
d1146 2
a1147 2
  checkbox_group({ "NAME" => "name",
                   "VALUES" => [["foo"], ["bar", true], "baz"] })
d1149 2
a1150 2
  checkbox_group({ "NAME" => "name",
                   "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
d1175 2
a1176 2
  file_field("name")
    # <INPUT TYPE="file" NAME="name" SIZE="20">
d1178 2
a1179 2
  file_field("name", 40)
    # <INPUT TYPE="file" NAME="name" SIZE="40">
d1181 2
a1182 2
  file_field("name", 40, 100)
    # <INPUT TYPE="file" NAME="name" SIZE="40", MAXLENGTH="100">
d1184 2
a1185 2
  file_field({ "NAME" => "name", "SIZE" => 40 })
    # <INPUT TYPE="file" NAME="name" SIZE="40">
d1202 2
a1203 2
  form{ "string" }
    # <FORM METHOD="post" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1205 2
a1206 2
  form("get"){ "string" }
    # <FORM METHOD="get" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1208 2
a1209 2
  form("get", "url"){ "string" }
    # <FORM METHOD="get" ACTION="url" ENCTYPE="application/x-www-form-urlencoded">string</FORM>
d1211 2
a1212 2
  form({"METHOD" => "post", ENCTYPE => "enctype"}){ "string" }
    # <FORM METHOD="post" ENCTYPE="enctype">string</FORM>
d1243 2
a1244 2
  hidden("name")
    # <INPUT TYPE="hidden" NAME="name">
d1246 2
a1247 2
  hidden("name", "value")
    # <INPUT TYPE="hidden" NAME="name" VALUE="value">
d1249 2
a1250 2
  hidden({ "NAME" => "name", "VALUE" => "reset", "ID" => "foo" })
    # <INPUT TYPE="hidden" NAME="name" VALUE="value" ID="foo">
d1266 2
a1267 2
  html{ "string" }
    # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML>string</HTML>
d1269 2
a1270 2
  html({ "LANG" => "ja" }){ "string" }
    # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML LANG="ja">string</HTML>
d1272 2
a1273 2
  html({ "DOCTYPE" => false }){ "string" }
    # <HTML>string</HTML>
d1275 16
a1290 16
  html({ "DOCTYPE" => '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">' }){ "string" }
    # <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"><HTML>string</HTML>

  html({ "PRETTY" => "  " }){ "<BODY></BODY>" }
    # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
    # <HTML>
    #   <BODY>
    #   </BODY>
    # </HTML>

  html({ "PRETTY" => "\t" }){ "<BODY></BODY>" }
    # <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
    # <HTML>
    #         <BODY>
    #         </BODY>
    # </HTML>
d1292 2
a1293 2
  html("PRETTY"){ "<BODY></BODY>" }
    # = html({ "PRETTY" => "  " }){ "<BODY></BODY>" }
d1295 1
a1295 1
  html(if $VERBOSE then "PRETTY" end){ "HTML string" }
d1334 2
a1335 2
  image_button("url")
    # <INPUT TYPE="image" SRC="url">
d1337 2
a1338 2
  image_button("url", "name", "string")
    # <INPUT TYPE="image" SRC="url" NAME="name", ALT="string">
d1340 2
a1341 2
  image_button({ "SRC" => "url", "ATL" => "strng" })
    # <INPUT TYPE="image" SRC="url" ALT="string">
d1358 2
a1359 2
  img("src", "alt", 100, 50)
    # <IMG SRC="src" ALT="alt" WIDTH="100", HEIGHT="50">
d1361 2
a1362 2
  img({ "SRC" => "src", "ALT" => "alt", "WIDTH" => 100, "HEIGHT" => 50 })
    # <IMG SRC="src" ALT="alt" WIDTH="100", HEIGHT="50">
d1378 2
a1379 2
  multipart_form{ "string" }
    # <FORM METHOD="post" ENCTYPE="multipart/form-data">string</FORM>
d1381 2
a1382 2
  multipart_form("url"){ "string" }
    # <FORM METHOD="post" ACTION="url" ENCTYPE="multipart/form-data">string</FORM>
d1409 2
a1410 2
  password_field("name")
    # <INPUT TYPE="password" NAME="name" SIZE="40">
d1412 2
a1413 2
  password_field("name", "value")
    # <INPUT TYPE="password" NAME="name" VALUE="value" SIZE="40">
d1415 2
a1416 2
  password_field("password", "value", 80, 200)
    # <INPUT TYPE="password" NAME="name" VALUE="value", SIZE="80", MAXLENGTH="200">
d1418 2
a1419 2
  password_field({ "NAME" => "name", "VALUE" => "value" })
    # <INPUT TYPE="password" NAME="name" VALUE="value">
d1436 28
a1463 28
  popup_menu("name", "foo", "bar", "baz")
    # <SELECT NAME="name">
    #   <OPTION VALUE="foo">foo</OPTION>
    #   <OPTION VALUE="bar">bar</OPTION>
    #   <OPTION VALUE="baz">baz</OPTION>
    # </SELECT>

  popup_menu("name", ["foo"], ["bar", true], "baz")
    # <SELECT NAME="name">
    #   <OPTION VALUE="foo">foo</OPTION>
    #   <OPTION VALUE="bar" SELECTED>bar</OPTION>
    #   <OPTION VALUE="baz">baz</OPTION>
    # </SELECT>

  popup_menu("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
    # <SELECT NAME="name">
    #   <OPTION VALUE="1">Foo</OPTION>
    #   <OPTION SELECTED VALUE="2">Bar</OPTION>
    #   <OPTION VALUE="Baz">Baz</OPTION>
    # </SELECT>

  popup_menu({"NAME" => "name", "SIZE" => 2, "MULTIPLE" => true,
              "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
    # <SELECT NAME="name" MULTIPLE SIZE="2">
    #   <OPTION VALUE="1">Foo</OPTION>
    #   <OPTION SELECTED VALUE="2">Bar</OPTION>
    #   <OPTION VALUE="Baz">Baz</OPTION>
    # </SELECT>
d1501 2
a1502 2
  radio_button("name", "value")
    # <INPUT TYPE="radio" NAME="name", VALUE="value">
d1504 2
a1505 2
  radio_button("name", "value", true)
    # <INPUT TYPE="radio" NAME="name", VALUE="value", CHECKED>
d1507 2
a1508 2
  radio_button({ "NAME" => "name", "VALUE" => "value", "ID" => "foo" })
    # <INPUT TYPE="radio" NAME="name" VALUE="value" ID="foo">
d1524 14
a1537 14
  radio_group("name", "foo", "bar", "baz")
    # <INPUT TYPE="radio" NAME="name" VALUE="foo">foo
    # <INPUT TYPE="radio" NAME="name" VALUE="bar">bar
    # <INPUT TYPE="radio" NAME="name" VALUE="baz">baz

  radio_group("name", ["foo"], ["bar", true], "baz")
    # <INPUT TYPE="radio" NAME="name" VALUE="foo">foo
    # <INPUT TYPE="radio" SELECTED NAME="name" VALUE="bar">bar
    # <INPUT TYPE="radio" NAME="name" VALUE="baz">baz

  radio_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")
    # <INPUT TYPE="radio" NAME="name" VALUE="1">Foo
    # <INPUT TYPE="radio" SELECTED NAME="name" VALUE="2">Bar
    # <INPUT TYPE="radio" NAME="name" VALUE="Baz">Baz
d1539 2
a1540 2
  radio_group({ "NAME" => "name",
                "VALUES" => ["foo", "bar", "baz"] })
d1542 2
a1543 2
  radio_group({ "NAME" => "name",
                "VALUES" => [["foo"], ["bar", true], "baz"] })
d1545 2
a1546 2
  radio_group({ "NAME" => "name",
                "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
d1571 2
a1572 2
  reset
    # <INPUT TYPE="reset">
d1574 2
a1575 2
  reset("reset")
    # <INPUT TYPE="reset" VALUE="reset">
d1577 2
a1578 2
  reset({ "VALUE" => "reset", "ID" => "foo" })
    # <INPUT TYPE="reset" VALUE="reset" ID="foo">
d1593 7
a1599 7
  scrolling_list({"NAME" => "name", "SIZE" => 2, "MULTIPLE" => true,
                  "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"] })
    # <SELECT NAME="name" MULTIPLE SIZE="2">
    #   <OPTION VALUE="1">Foo</OPTION>
    #   <OPTION SELECTED VALUE="2">Bar</OPTION>
    #   <OPTION VALUE="Baz">Baz</OPTION>
    # </SELECT>
d1606 2
a1607 2
  submit
    # <INPUT TYPE="submit">
d1609 2
a1610 2
  submit("ok")
    # <INPUT TYPE="submit" VALUE="ok">
d1612 2
a1613 2
  submit("ok", "button1")
    # <INPUT TYPE="submit" VALUE="ok" NAME="button1">
d1615 2
a1616 2
  submit({ "VALUE" => "ok", "NAME" => "button1", "ID" => "foo" })
    # <INPUT TYPE="submit" VALUE="ok" NAME="button1" ID="foo">
d1631 2
a1632 2
  text_field("name")
    # <INPUT TYPE="text" NAME="name" SIZE="40">
d1634 2
a1635 2
  text_field("name", "value")
    # <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="40">
d1637 2
a1638 2
  text_field("name", "value", 80)
    # <INPUT TYPE="text" NAME="name" VALUE="value", SIZE="80">
d1640 2
a1641 2
  text_field("name", "value", 80, 200)
    # <INPUT TYPE="text" NAME="name" VALUE="value", SIZE="80", MAXLENGTH="200">
d1643 2
a1644 2
  text_field({ "NAME" => "name", "VALUE" => "value" })
    # <INPUT TYPE="text" NAME="name" VALUE="value">
a1660 2
  textarea("name")
    # = textarea({ "NAME" => "name", "COLS" => 70, "ROWS" => 10 })
d1662 5
a1666 2
  textarea("name", 40, 5)
    # = textarea({ "NAME" => "name", "COLS" => 40, "ROWS" => 5 })
d1911 158
a2068 108
* Sun Jun 18 23:31:44 JST 2000 - wakou
  * version 1.7.0
  * change: version syntax. old: x.yz, now: x.y.z

* 2000/06/13 15:49:27 - wakou
  * version 1.61
  * read_multipart(): if no content body then raise EOFError.

* 2000/06/03 18:16:17 - wakou
  * version 1.60
  * improve: CGI::pretty()

* 2000/05/30 19:04:08 - wakou
  * version 1.50
  * CGI#out(): if "HEAD" == REQUEST_METHOD then output only HTTP header.

* 2000/05/24 06:58:51 - wakou
  * version 1.40
  * typo: CGI::Cookie::new()
  * bug fix: CGI::escape():  bad: " " --> "%2B";  true: " " --> "+";
    thanks to Ryunosuke Ohshima <ryu@@jaist.ac.jp>

* 2000/05/08 21:51:30 - wakou
  * version 1.31
  * improvement of time forming new CGI object accompanied with HTML generation methods.

* 2000/05/07 21:51:14 - wakou
  * version 1.30
  * require English.rb
  * improvement of load time.

* 2000/05/02 21:44:12 - wakou
  * version 1.21
  * support for ruby 1.5.3 (2000-05-01) (Array#filter --> Array#collect!)

* 2000/04/03 18:31:42 - wakou
  * version 1.20
  * bug fix: CGI#image_button() can't get Hash option.
    thanks to Takashi Ikeda <ikeda@@auc.co.jp>
  * CGI::unescapeHTML(): simple support for "&#12345;"
  * CGI::Cookie::new(): simple support for IE
  * CGI::escape(): ' ' replaced by '+'

* 1999/12/06 20:16:34 - wakou
  * version 1.10
  * can make many CGI objects.
  * if use mod_ruby, then require ruby1.4.3 or later.

* 1999/11/29 21:35:58 - wakou
  * version 1.01
  * support for ruby 1.5.0 (1999-11-20)

* 1999/09/13 23:00:58 - wakou
  * version 1.00
  * COUTION! name change. CGI.rb --> cgi.rb
  * CGI#auth_type, CGI#content_length, CGI#content_type, ...
    if not ENV included it, then return nil.
  * CGI#content_length and CGI#server_port return Integer.
  * if not CGI#params.include?('name'), then CGI#params['name'] return [].
  * if not CGI#cookies.include?('name'), then CGI#cookies['name'] return [].

* 1999/08/05 18:04:59 - wakou
  * version 0.41
  * typo. thanks to MJ Ray <markj@@altern.org>
      HTTP_STATUS["NOT_INPLEMENTED"] --> HTTP_STATUS["NOT_IMPLEMENTED"]

* 1999/07/20 20:44:31 - wakou
  * version 0.40
  * COUTION! incompatible change.
    sorry, but probably this change is last big incompatible change.
  * CGI::print  -->  CGI#out
      cgi = CGI.new
      cgi.out{"string"}             # old: CGI::print{"string"}
  * CGI::cookie  --> CGI::Cookie::new
      cookie1 = CGI::Cookie::new    # old: CGI::cookie
  * CGI::header  -->  CGI#header

* 1999/06/29 06:50:21 - wakou
  * version 0.30
  * COUTION! incompatible change.
      query = CGI.new
      cookies = query.cookies       # old: query.cookie
      values = query.cookies[name]  # old: query.cookie[name]

* 1999/06/21 21:05:57 - wakou
  * version 0.24
  * CGI::Cookie::parse() return { name => CGI::Cookie object } pairs.

* 1999/06/20 23:29:12 - wakou
  * version 0.23
  * modified a bit to clear module separation.

* Mon Jun 14 17:49:32 JST 1999 - matz
  * version 0.22
  * Cookies are now CGI::Cookie objects.
  * Cookie modeled after CGI::Cookie.pm.

* Fri Jun 11 11:19:11 JST 1999 - matz
  * version 0.21
  * modified a bit to clear module separation.

* 1999/06/03 06:48:15 - wakou
  * version 0.20
  * support for multipart form.

* 1999/05/24 07:05:41 - wakou
  * version 0.10
  * first release.
a2069 1
$Date: 2000/06/18 14:36:32 $
@


1.6
log
@2000-05-01
@
text
@d2 1
a2 1
$Date: 2000/04/03 18:31:42 $
d8 1
a8 1
Version 1.20
d11 1
a11 1
Copyright (C) 2000  Information-technology Promotion Agancy, Japan
d111 1
a111 1
	require "CGI"
d144 1
a144 1
=== PRINT HTTP HEADER AND HTML STRING TO $>
d179 2
d188 2
a189 2
  VERSION = "1.20"
  RELEASE_DATE = "$Date: 2000/04/03 18:31:42 $"
d228 1
a228 1
    $>
d242 3
a244 4
    str = string.dup
    str.gsub!(/ /n, '+')
    str.gsub!(/([^a-zA-Z0-9_.-])/n){ sprintf("%%%02X", $1.unpack("C")[0]) }
    str
d253 3
a255 4
    str = string.dup
    str.gsub!(/\+/n, ' ')
    str.gsub!(/%([0-9a-fA-F]{2})/n){ [$1.hex].pack("c") }
    str
d264 1
a264 6
    str = string.dup
    str.gsub!(/&/n, '&amp;')
    str.gsub!(/\"/n, '&quot;')
    str.gsub!(/>/n, '&gt;')
    str.gsub!(/</n, '&lt;')
    str
d273 1
a273 2
    str = string.dup
    str.gsub!(/&(.*?);/n){
d292 1
a292 2
    }
    str
d305 1
a305 2
    str = string.dup
    str.gsub!(/<\/?(?:#{element.join("|")})(?!\w)(?:.|\n)*?>/ni){
d307 1
a307 2
    }
    str
d322 1
a322 2
    str = string.dup
    str.gsub!(/&lt;\/?(?:#{element.join("|")})(?!\w)(?:.|\n)*?&gt;/ni){
d324 1
a324 2
    }
    str
d485 1
a485 1
=== PRINT HTTP HEADER AND STRING TO $>
d547 1
a547 1
	cgi.print    # default:  cgi.print == $>.print
d629 1
a629 1
        buf.concat(@@value.filter{|v| CGI::escape(v) }.join("&"))
d667 1
a667 1
      values = values.split('&').filter{|v| CGI::unescape(v) }
d689 1
a689 1
      key, value = pairs.split('=',2).filter{|v| CGI::unescape(v) }
d703 1
a703 2
    %w[ CONTENT_LENGTH SERVER_PORT ].
    each{|env|
d709 1
a709 1
    }
d711 1
a711 1
    %w[ AUTH_TYPE CONTENT_TYPE GATEWAY_INTERFACE PATH_INFO
d718 1
a718 2
        HTTP_NEGOTIATE HTTP_PRAGMA HTTP_REFERER HTTP_USER_AGENT ].
    each{|env|
d724 1
a724 1
    }
d751 1
a751 1
      require "tempfile.rb"
d761 1
a761 1
            buf.sub!(/\A((?:.|\n)*?#{EOL})#{EOL}/n){
d764 1
a764 1
            }
d783 1
a783 1
        buf.sub!(/\A((?:.|\n)*?)(?:#{EOL})?#{boundary}(#{EOL}|--)/n){
d789 1
a789 1
        }
d839 1
a839 1
      require "shellwords.rb"
d841 2
a842 2
      unless ARGV.empty?
        str = ARGV.join(' ')
d849 2
a850 3
        str = readlines.join(' ')
        str.gsub!(/\n/n, '')
      end
d852 1
a852 4
      str.gsub!(/\\=/n, '%3D')
      str.gsub!(/\\&/n, '%26')

      words = Shellwords.shellwords(str)
d924 1
a924 3
    str = string.dup
    str.gsub!(/\n(?!\z)/n, "\n" + shift)
    str
d927 1
a927 2
    str = string.dup
    str.gsub!(/(<(\w+).*?>)((?:.|\n)*?)(<\/\2>)/n){
d929 1
a929 2
    }
    str
d932 3
a934 4
    str = string.dup
    str.gsub!(/<(?:.|\n)*?>/n, "\n\\0")
    str.gsub!(/<(?:.|\n)*?>(?!\n)/n, "\\0\n")
    CGI::pretty_nest(str, shift)
a1017 1
    extend TagMaker
a1678 1
    extend TagMaker
d1684 15
a1698 12
    # - -
    %w[ A TT I B U STRIKE BIG SMALL SUB SUP EM STRONG DFN CODE SAMP KBD VAR
      CITE FONT ADDRESS DIV center MAP APPLET PRE XMP LISTING DL OL UL DIR
      MENU SELECT table TITLE STYLE SCRIPT H1 H2 H3 H4 H5 H6 TEXTAREA FORM
      BLOCKQUOTE CAPTION ].
    each{|element|
      eval( <<-BEGIN + nn_element_def(element) + <<-END )
        def #{element.downcase}(attributes = {})
      BEGIN
        end
      END
    }
d1700 9
a1708 9
    # - O EMPTY
    %w[ IMG BASE BASEFONT BR AREA LINK PARAM HR INPUT ISINDEX META ].
    each{|element|
      eval( <<-BEGIN + nOE_element_def(element) + <<-END )
        def #{element.downcase}(attributes = {})
      BEGIN
        end
      END
    }
d1710 11
a1720 9
    # O O or - O
    %w[ HTML HEAD BODY P PLAINTEXT DT DD LI OPTION tr th td ].
    each{|element|
      eval( <<-BEGIN + nO_element_def(element) + <<-END )
        def #{element.downcase}(attributes = {})
      BEGIN
        end
      END
    }
a1725 1
    extend TagMaker
d1731 15
a1745 12
    # - -
    %w[ TT I B BIG SMALL EM STRONG DFN CODE SAMP KBD VAR CITE ABBR ACRONYM
      SUB SUP SPAN BDO ADDRESS DIV MAP OBJECT H1 H2 H3 H4 H5 H6 PRE Q
      INS DEL DL OL UL LABEL SELECT OPTGROUP FIELDSET LEGEND BUTTON TABLE
      TITLE STYLE SCRIPT NOSCRIPT TEXTAREA FORM A BLOCKQUOTE CAPTION ].
    each{|element|
      eval( <<-BEGIN + nn_element_def(element) + <<-END )
        def #{element.downcase}(attributes = {})
      BEGIN
        end
      END
    }
d1747 8
a1754 9
    # - O EMPTY
    %w[ IMG BASE BR AREA LINK PARAM HR INPUT COL META ].
    each{|element|
      eval( <<-BEGIN + nOE_element_def(element) + <<-END )
        def #{element.downcase}(attributes = {})
      BEGIN
        end
      END
    }
d1756 11
a1766 9
    # O O or - O
    %w[ HTML BODY P DT DD LI OPTION THEAD TFOOT TBODY COLGROUP TR TH TD HEAD].
    each{|element|
      eval( <<-BEGIN + nO_element_def(element) + <<-END )
        def #{element.downcase}(attributes = {})
      BEGIN
        end
      END
    }
a1771 1
    extend TagMaker
d1777 16
a1792 13
    # - -
    %w[ TT I B U S STRIKE BIG SMALL EM STRONG DFN CODE SAMP KBD VAR CITE
      ABBR ACRONYM FONT SUB SUP SPAN BDO ADDRESS DIV CENTER MAP OBJECT
      APPLET H1 H2 H3 H4 H5 H6 PRE Q INS DEL DL OL UL DIR MENU LABEL SELECT
      OPTGROUP FIELDSET LEGEND BUTTON TABLE IFRAME NOFRAMES TITLE STYLE
      SCRIPT NOSCRIPT TEXTAREA FORM A BLOCKQUOTE CAPTION ].
    each{|element|
      eval( <<-BEGIN + nn_element_def(element) + <<-END )
        def #{element.downcase}(attributes = {})
      BEGIN
        end
      END
    }
d1794 9
a1802 9
    # - O EMPTY
    %w[ IMG BASE BASEFONT BR AREA LINK PARAM HR INPUT COL ISINDEX META ].
    each{|element|
      eval( <<-BEGIN + nOE_element_def(element) + <<-END )
        def #{element.downcase}(attributes = {})
      BEGIN
        end
      END
    }
d1804 11
a1814 9
    # O O or - O
    %w[ HTML BODY P DT DD LI OPTION THEAD TFOOT TBODY COLGROUP TR TH TD HEAD ].
    each{|element|
      eval( <<-BEGIN + nO_element_def(element) + <<-END )
        def #{element.downcase}(attributes = {})
      BEGIN
        end
      END
    }
a1819 2
    include Html4Tr
    extend TagMaker
d1825 13
a1837 9
    # - -
    %w[ FRAMESET ].
    each{|element|
      eval( <<-BEGIN + nn_element_def(element) + <<-END )
        def #{element.downcase}(attributes = {})
      BEGIN
        end
      END
    }
d1839 10
a1848 9
    # - O EMPTY
    %w[ FRAME ].
    each{|element|
      eval( <<-BEGIN + nOE_element_def(element) + <<-END )
        def #{element.downcase}(attributes = {})
      BEGIN
        end
      END
    }
d1869 1
d1873 1
d1877 1
d1881 1
d1884 1
d1903 19
@


1.5
log
@2000-03-06
@
text
@d2 1
a2 1
$Date: 2000/01/05 04:37:22 $
d6 1
a6 1
CGI.rb
d8 1
a8 1
Version 1.10
d10 2
a11 1
Copyright (C) 1999  Network Applied Communication Laboratory, Inc.
d186 2
a187 2
  VERSION = "1.10"
  RELEASE_DATE = "$Date: 2000/01/05 04:37:22 $"
d241 2
a242 1
    str.gsub!(/[^a-zA-Z0-9_.-]/n){ sprintf("%%%02X", $&.unpack("C")[0]) }
d286 10
a295 1
      when /\A#(\d+)\z/n         then Integer($1).chr
d608 11
a618 1
      @@path = options["path"]
d984 1
a984 1
            next if value == nil
d1005 1
a1005 1
            next if value == nil
d1020 1
a1020 1
            next if value == nil
d1364 3
a1366 2
                     name["TYPE"] = "image"
                     name
d1906 14
a1919 1
== HISTRY
@


1.4
log
@20000105
@
text
@d2 1
a2 1
$Date: 1999/12/07 09:23:33 $
d186 1
a186 1
  RELEASE_DATE = "$Date: 1999/12/07 09:23:33 $"
d651 1
d656 1
d882 1
a882 2
      @@cookies = CGI::Cookie::parse((env_table['HTTP_COOKIE'] or
        env_table['COOKIE'] or ""))
@


1.3
log
@991207
@
text
@d2 1
a2 1
$Date: 1999/12/06 20:16:34 $
d186 1
a186 1
  RELEASE_DATE = "$Date: 1999/12/06 20:16:34 $"
d189 1
a189 1
  NEEDS_BINMODE = true if /WIN/ni === PLATFORM
@


1.2
log
@19991201
@
text
@d2 1
a2 1
$Date: 1999/11/29 21:35:58 $
d8 1
a8 1
Version 1.01
d27 1
a27 1
	cgi.key?('field_name')
d185 2
a186 2
  VERSION = "1.01"
  RELEASE_DATE = "$Date: 1999/11/29 21:35:58 $"
d394 1
a394 1
    unless options.key?("type")
d398 1
a398 1
    if options.key?("charset")
d414 1
a414 1
      unless options.key?("server")
d418 1
a418 1
      unless options.key?("connection")
d425 1
a425 1
    if options.key?("server")
d429 1
a429 1
    if options.key?("connection")
d435 1
a435 1
    if options.key?("length")
d439 1
a439 1
    if options.key?("language")
d443 1
a443 1
    if options.key?("expires")
d447 1
a447 1
    if options.key?("cookie")
d471 1
a471 1
    if env_table['MOD_RUBY']
d521 1
a521 1
    if options.key?("charset")
d526 1
a526 1
        options["language"] = "ja" unless options.key?("language")
d529 1
a529 1
        options["language"] = "ja" unless options.key?("language")
d532 1
a532 1
        options["language"] = "ja" unless options.key?("language")
d591 1
a591 1
      unless options.key?("name")
d656 1
a656 1
      if cookies.key?(name)
d678 1
a678 1
      if params.key?(key)
d815 1
a815 1
        if params.key?(name)
d866 1
a866 1
                      if env_table['MOD_RUBY']
a960 1
          attributes.delete_if{|k,v| v == nil }
d962 1
a981 1
          attributes.delete_if{|k,v| v == nil }
d983 1
a996 1
          attributes.delete_if{|k,v| v == nil }
d998 1
d1213 1
a1213 1
                     unless method.key?("METHOD")
d1216 1
a1216 1
                     unless method.key?("ENCTYPE")
d1301 1
a1301 1
      if attributes.key?("DOCTYPE")
d1384 1
a1384 1
                     unless action.key?("METHOD")
d1387 1
a1387 1
                     unless action.key?("ENCTYPE")
d1840 9
a1848 2
    @@params = nil
    @@cookies = nil
a1851 16
    extend QueryExtension

    #if defined? CGI::PARAMS
    #  @@params = "C" + (CGI::PARAMS.nil? ? nil : CGI::PARAMS.dup).inspect
    #  @@cookies = "C" + (CGI::COOKIES.nil? ? nil : CGI::COOKIES.dup).inspect
    #else
      initialize_query()
    #   @@params, @@cookies initialized in initialize_query
    #  eval "PARAMS = @@params.nil? ? nil : @@params.dup"
    #  eval "COOKIES = @@cookies.nil? ? nil : @@cookies.dup"
    #  at_exit {
    #    remove_const(PARAMS)
    #    remove_const(COOKIES)
    #  }
    #end

d1867 11
d1884 7
@


1.1
log
@19991104
@
text
@d2 1
a2 1
$Date: 1999/09/13 23:00:58 $
d8 1
a8 1
Version 1.00
d185 2
a186 2
  VERSION = "1.00"
  RELEASE_DATE = "$Date: 1999/09/13 23:00:58 $"
d961 1
d982 1
d997 2
a998 1
         "<element.upcase" + attributes.collect{|name, value|
d1840 5
d1846 14
a1859 2
    initialize_query()
    # @@params, @@cookies initialized in initialize_query
d1882 6
@
