head	1.9;
access;
symbols
	v1_6_7:1.9
	v1_6_6:1.9
	v1_6_5:1.9
	v1_6_4:1.9
	v1_7_1:1.9
	v1_6_4_preview4:1.9
	v1_6_4_preview3:1.9
	v1_6_4_preview2:1.9
	v1_6_4_preview1:1.9
	v1_6_3:1.9
	ruby_m17n:1.9.0.4
	ruby_1_6:1.9.0.2
	v1_6_2:1.9
	v1_6_1:1.9
	v1_6_0:1.9
	v1_4_6:1.2.2.4
	v1_4_5:1.2.2.4
	v1_4_4:1.2.2.3
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.2
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.2.2.2
	v1_3_6_repack:1.1.1.2.2.2
	v1_3_6:1.1.1.2.2.2
	v1_3_5:1.1.1.2.2.2
	v1_2_6repack:1.1.1.1.4.9
	v1_3_4_990625:1.1.1.2.2.2
	v1_3_4_990624:1.1.1.2.2.2
	v1_2_6:1.1.1.1.4.9
	v1_3_4_990611:1.1.1.2.2.2
	v1_3_4_990531:1.1.1.2.2.2
	v1_3_3_990518:1.1.1.2.2.2
	v1_3_3_990513:1.1.1.2.2.2
	v1_3_3_990507:1.1.1.2.2.2
	v1_2_5:1.1.1.1.4.9
	v1_2_4:1.1.1.1.4.9
	v1_3_1_990225:1.1.1.2
	v1_3_1_990224:1.1.1.2
	v1_3_1_990215:1.1.1.2
	v1_3_1_990212:1.1.1.2
	v1_3_1_990210:1.1.1.2
	v1_3_1_:1.1.1.2
	v1_3_1_990209:1.1.1.2
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.4.9
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.4.9
	v1_2_1repack:1.1.1.1.4.9
	v1_2_1:1.1.1.1.4.9
	v1_2_stable:1.1.1.1.4.9
	v1_1d1:1.1.1.1.4.9
	v1_1d0:1.1.1.1.4.9
	v1_1c9_1:1.1.1.1.4.9
	v1_1c9:1.1.1.1.4.9
	v1_1c8:1.1.1.1.4.9
	v1_1c7:1.1.1.1.4.9
	v1_1c6:1.1.1.1.4.9
	v1_1d-start:1.1.1.1.4.9
	v1_1c5:1.1.1.1.4.9
	v1_1dev:1.1.1.1.4.9.0.2
	v1_1c4:1.1.1.1.4.9
	v1_1c3:1.1.1.1.4.9
	v1_1c2:1.1.1.1.4.9
	v1_1c1:1.1.1.1.4.9
	v1_1c0:1.1.1.1.4.9
	v1_1b9_31:1.1.1.1.4.9
	v1_1b9_30:1.1.1.1.4.9
	v1_1b9_28:1.1.1.1.4.9
	v1_1b9_27:1.1.1.1.4.9
	v1_1b9_26:1.1.1.1.4.9
	r1_1b9_25:1.1.1.1.4.9
	r1_1b9_24:1.1.1.1.4.9
	v1_1b9_23:1.1.1.1.4.9
	v1_1b9_22:1.1.1.1.4.8
	v1_1b9_20:1.1.1.1.4.8
	v1_1b9_18:1.1.1.1.4.8
	v1_1b9_16:1.1.1.1.4.7
	v1_1b9_15:1.1.1.1.4.7
	v1_1b9_13:1.1.1.1.4.7
	v1_1b9_12:1.1.1.1.4.7
	v1_1b9_11:1.1.1.1.4.7
	v1_1b9_08:1.1.1.1.4.5
	v1_1b9_07:1.1.1.1.4.5
	r1_1b9:1.1.1.1.4.4
	v1_1b8:1.1.1.1.4.4
	v1_1b7:1.1.1.1.4.3
	v1_1b6:1.1.1.1.4.2
	v1_1r:1.1.1.1.0.4
	v1_1:1.1.1.1
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.9
date	2000.02.23.05.23.12;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.08.06.03.42;	author shugo;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.07.03.34.02;	author shugo;	state Exp;
branches;
next	1.6;

1.6
date	99.12.20.03.38.30;	author shugo;	state Exp;
branches;
next	1.5;

1.5
date	99.12.20.03.30.48;	author shugo;	state Exp;
branches;
next	1.4;

1.4
date	99.12.20.03.29.45;	author shugo;	state Exp;
branches;
next	1.3;

1.3
date	99.12.20.03.27.48;	author shugo;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.16;	author matz;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.35;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	;

1.1.1.2.2.1
date	99.04.09.17.57.43;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	99.04.30.06.19.20;	author matz;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	98.01.16.12.36.05;	author matz;	state Exp;
branches;
next	1.1.1.1.4.2;

1.1.1.1.4.2
date	98.01.19.05.08.25;	author matz;	state Exp;
branches;
next	1.1.1.1.4.3;

1.1.1.1.4.3
date	98.02.06.10.03.24;	author matz;	state Exp;
branches;
next	1.1.1.1.4.4;

1.1.1.1.4.4
date	98.02.18.10.01.47;	author matz;	state Exp;
branches;
next	1.1.1.1.4.5;

1.1.1.1.4.5
date	98.03.03.02.39.34;	author matz;	state Exp;
branches;
next	1.1.1.1.4.6;

1.1.1.1.4.6
date	98.04.09.09.58.00;	author matz;	state Exp;
branches;
next	1.1.1.1.4.7;

1.1.1.1.4.7
date	98.04.16.10.20.26;	author matz;	state Exp;
branches;
next	1.1.1.1.4.8;

1.1.1.1.4.8
date	98.05.01.08.56.43;	author matz;	state Exp;
branches;
next	1.1.1.1.4.9;

1.1.1.1.4.9
date	98.05.25.09.42.42;	author matz;	state Exp;
branches;
next	;

1.2.2.1
date	99.12.20.03.39.42;	author shugo;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.01.07.03.31.29;	author shugo;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2000.02.08.05.58.21;	author shugo;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2000.04.10.05.48.43;	author matz;	state Exp;
branches;
next	;


desc
@@


1.9
log
@2000-02-23
@
text
@#
# ftplib.rb
#

$stderr.puts 'Warning: ftplib.rb is obsolete: use net/ftp'

require 'net/ftp'

FTP           = ::Net::FTP
FTPError      = ::Net::FTPError
FTPReplyError = ::Net::FTPReplyError
FTPTempError  = ::Net::FTPTempError
FTPPermError  = ::Net::FTPPermError
FTPProtoError = ::Net::FTPProtoError
@


1.8
log
@*** empty log message ***
@
text
@d5 1
a5 1
$stderr.puts 'Warning: ftplib.rb is obsolute: use net/ftp'
@


1.7
log
@*** empty log message ***
@
text
@d1 14
a14 629
# ftplib.rb by Shugo Maeda <shugo@@netlab.co.jp>

require "socket"
require "monitor"

class FTPError < StandardError; end
class FTPReplyError < FTPError; end
class FTPTempError < FTPError; end
class FTPPermError < FTPError; end
class FTPProtoError < FTPError; end

class FTP
  include MonitorMixin
  
  FTP_PORT = 21
  CRLF = "\r\n"
  
  attr_accessor :passive, :return_code, :debug_mode
  attr_reader :welcome, :lastresp
  
  def FTP.open(host, user = nil, passwd = nil, acct = nil)
    new(host, user, passwd, acct)
  end
    
  def initialize(host = nil, user = nil, passwd = nil, acct = nil)
    super
    @@passive = false
    @@return_code = "\n"
    @@debug_mode = false
    if host
      connect(host)
      if user
	login(user, passwd, acct)
      end
    end
  end
  
  def open_socket(host, port)
    if defined? SOCKSsocket and ENV["SOCKS_SERVER"]
      @@passive = true
      return SOCKSsocket.open(host, port)
    else
      return TCPsocket.open(host, port)
    end
  end
  private :open_socket
   
  def connect(host, port = FTP_PORT)
    if @@debug_mode
      print "connect: ", host, ", ", port, "\n"
    end
    synchronize do
      @@sock = open_socket(host, port)
      voidresp
    end
  end
  
  def sanitize(s)
    if s =~ /^PASS /i
      return s[0, 5] + "*" * (s.length - 5)
    else
      return s
    end
  end
  private :sanitize
  
  def putline(line)
    if @@debug_mode
      print "put: ", sanitize(line), "\n"
    end
    line = line + CRLF
    @@sock.write(line)
  end
  private :putline
   
  def getline
    line = @@sock.readline # if get EOF, raise EOFError
    if line[-2, 2] == CRLF
      line = line[0 .. -3]
    elsif line[-1] == ?\r or
	line[-1] == ?\n
      line = line[0 .. -2]
    end
    if @@debug_mode
      print "get: ", sanitize(line), "\n"
    end
    return line
  end
  private :getline
  
  def getmultiline
    line = getline
    buff = line
    if line[3] == ?-
      code = line[0, 3]
      begin
	line = getline
	buff << "\n" << line
      end until line[0, 3] == code and line[3] != ?-
    end
    return buff << "\n"
  end
  private :getmultiline
  
  def getresp
    resp = getmultiline
    @@lastresp = resp[0, 3]
    c = resp[0]
    case c
    when ?1, ?2, ?3
      return resp
    when ?4
      raise FTPTempError, resp
    when ?5
      raise FTPPermError, resp
    else
      raise FTPProtoError, resp
    end
  end
  private :getresp
  
  def voidresp
    resp = getresp
    if resp[0] != ?2
      raise FTPReplyError, resp
    end
  end
  private :voidresp
  
  def sendcmd(cmd)
    synchronize do
      putline(cmd)
      return getresp
    end
  end
   
  def voidcmd(cmd)
    synchronize do
      putline(cmd)
      voidresp
    end
  end
   
  def sendport(host, port)
    af = (@@sock.peeraddr)[0]
    if af == "AF_INET"
      hbytes = host.split(".")
      pbytes = [port / 256, port % 256]
      bytes = hbytes + pbytes
      cmd = "PORT " + bytes.join(",")
    elsif af == "AF_INET6"
      cmd = "EPRT |2|" + host + "|" + sprintf("%d", port) + "|"
    else
      raise FTPProtoError, host
    end
    voidcmd(cmd)
  end
  private :sendport
   
  def makeport
    sock = TCPserver.open(@@sock.addr[3], 0)
    port = sock.addr[1]
    host = TCPsocket.getaddress(@@sock.addr[2])
    resp = sendport(host, port)
    return sock
  end
  private :makeport
   
  def makepasv
    if @@sock.peeraddr[0] == "AF_INET"
      host, port = parse227(sendcmd("PASV"))
    else
      host, port = parse229(sendcmd("EPSV"))
#     host, port = parse228(sendcmd("LPSV"))
    end
    return host, port
  end
  private :makepasv
   
  def transfercmd(cmd)
    if @@passive
      host, port = makepasv
      conn = open_socket(host, port)
      resp = sendcmd(cmd)
      if resp[0] != ?1
	raise FTPReplyError, resp
      end
    else
      sock = makeport
      resp = sendcmd(cmd)
      if resp[0] != ?1
	raise FTPReplyError, resp
      end
      conn = sock.accept
    end
    return conn
  end
  private :transfercmd
   
  def getaddress
    thishost = Socket.gethostname
    if not thishost.index(".")
      thishost = Socket.gethostbyname(thishost)[0]
    end
    if ENV.has_key?("LOGNAME")
      realuser = ENV["LOGNAME"]
    elsif ENV.has_key?("USER")
      realuser = ENV["USER"]
    else
      realuser = "anonymous"
    end
    return realuser + "@@" + thishost
  end
  private :getaddress
   
  def login(user = "anonymous", passwd = nil, acct = nil)
    if user == "anonymous" and passwd == nil
      passwd = getaddress
    end
    
    resp = ""
    synchronize do
      resp = sendcmd('USER ' + user)
      if resp[0] == ?3
	resp = sendcmd('PASS ' + passwd)
      end
      if resp[0] == ?3
	resp = sendcmd('ACCT ' + acct)
      end
    end
    if resp[0] != ?2
      raise FTPReplyError, resp
    end
    @@welcome = resp
  end
  
  def retrbinary(cmd, blocksize, callback = Proc.new)
    synchronize do
      voidcmd("TYPE I")
      conn = transfercmd(cmd)
      loop do
	data = conn.read(blocksize)
	break if data == nil
	callback.call(data)
      end
      conn.close
      voidresp
    end
  end
   
  def retrlines(cmd, callback = nil)
    if iterator?
      callback = Proc.new
    elsif not callback.is_a?(Proc)
      callback = Proc.new {|line| print line, "\n"}
    end
    synchronize do
      voidcmd("TYPE A")
      conn = transfercmd(cmd)
      loop do
	line = conn.gets
	break if line == nil
	if line[-2, 2] == CRLF
	  line = line[0 .. -3]
	elsif line[-1] == ?\n
	  line = line[0 .. -2]
	end
	callback.call(line)
      end
      conn.close
      voidresp
    end
  end
  
  def storbinary(cmd, file, blocksize, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    synchronize do
      voidcmd("TYPE I")
      conn = transfercmd(cmd)
      loop do
	buf = file.read(blocksize)
	break if buf == nil
	conn.write(buf)
	callback.call(buf) if use_callback
      end
      conn.close
      voidresp
    end
  end
   
  def storlines(cmd, file, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    synchronize do
      voidcmd("TYPE A")
      conn = transfercmd(cmd)
      loop do
	buf = file.gets
	break if buf == nil
	if buf[-2, 2] != CRLF
	  buf = buf.chomp + CRLF
	end
	conn.write(buf)
	callback.call(buf) if use_callback
      end
      conn.close
      voidresp
    end
  end
  
  def getbinaryfile(remotefile, localfile, blocksize, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile, "w")
    begin
      f.binmode
      retrbinary("RETR " + remotefile, blocksize) do |data|
	f.write(data)
	callback.call(data) if use_callback
      end
    ensure
      f.close
    end
  end
   
  def gettextfile(remotefile, localfile, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile, "w")
    begin
      retrlines("RETR " + remotefile) do |line|
	line = line + @@return_code
	f.write(line)
	callback.call(line) if use_callback
      end
    ensure
      f.close
    end
  end
   
  def putbinaryfile(localfile, remotefile, blocksize, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile)
    begin
      f.binmode
      storbinary("STOR " + remotefile, f, blocksize) do |data|
	callback.call(data) if use_callback
      end
    ensure
      f.close
    end
  end
  
  def puttextfile(localfile, remotefile, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile)
    begin
      storlines("STOR " + remotefile, f) do |line|
	callback.call(line) if use_callback
      end
    ensure
      f.close
    end
  end
   
  def acct(account)
    cmd = "ACCT " + account
    voidcmd(cmd)
  end
  
  def nlst(dir = nil)
    cmd = "NLST"
    if dir
      cmd = cmd + " " + dir
    end
    files = []
    retrlines(cmd) do |line|
      files.push(line)
    end
    return files
  end
  
  def list(*args, &block)
    cmd = "LIST"
    args.each do |arg|
      cmd = cmd + " " + arg
    end
    if block
      retrlines(cmd, &block)
    else
      lines = []
      retrlines(cmd) do |line|
	lines << line
      end
      return lines
    end
  end
  alias ls list
  alias dir list
  
  def rename(fromname, toname)
    resp = sendcmd("RNFR " + fromname)
    if resp[0] != ?3
      raise FTPReplyError, resp
    end
    voidcmd("RNTO " + toname)
  end
  
  def delete(filename)
    resp = sendcmd("DELE " + filename)
    if resp[0, 3] == "250"
      return
    elsif resp[0] == ?5
      raise FTPPermError, resp
    else
      raise FTPReplyError, resp
    end
  end
  
  def chdir(dirname)
    if dirname == ".."
      begin
	voidcmd("CDUP")
	return
      rescue FTPPermError
	if $![0, 3] != "500"
	  raise FTPPermError, $!
	end
      end
    end
    cmd = "CWD " + dirname
    voidcmd(cmd)
  end
   
  def size(filename)
    voidcmd("TYPE I")
    resp = sendcmd("SIZE " + filename)
    if resp[0, 3] != "213" 
      raise FTPReplyError, resp
    end
    return resp[3..-1].strip.to_i
  end

  MDTM_REGEXP = /^(\d\d\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/

  def mtime(filename, local = false)
    str = mdtm(filename)
    ary = str.scan(MDTM_REGEXP)[0].collect {|i| i.to_i}
    return local ? Time.local(*ary) : Time.gm(*ary)
  end

  def mkdir(dirname)
    resp = sendcmd("MKD " + dirname)
    return parse257(resp)
  end
  
  def rmdir(dirname)
    voidcmd("RMD " + dirname)
  end
  
  def pwd
    resp = sendcmd("PWD")
      return parse257(resp)
  end
  alias getdir pwd
  
  def system
    resp = sendcmd("SYST")
    if resp[0, 3] != "215"
      raise FTPReplyError, resp
    end
    return resp[4 .. -1]
  end
  
  def abort
    line = "ABOR" + CRLF
    print "put: ABOR\n" if @@debug_mode
    @@sock.send(line, Socket::MSG_OOB)
    resp = getmultiline
    unless ["426", "226", "225"].include?(resp[0, 3])
      raise FTPProtoError, resp
    end
    return resp
  end
   
  def status
    line = "STAT" + CRLF
    print "put: STAT\n" if @@debug_mode
    @@sock.send(line, Socket::MSG_OOB)
    return getresp
  end
  
  def mdtm(filename)
    resp = sendcmd("MDTM " + filename)
    if resp[0, 3] == "213"
      return resp[3 .. -1].strip
    end
  end
  
  def help(arg = nil)
    cmd = "HELP"
    if arg
      cmd = cmd + " " + arg
    end
    sendcmd(cmd)
  end
  
  def quit
    voidcmd("QUIT")
  end
  
  def close
    @@sock.close if @@sock and not @@sock.closed?
  end
  
  def closed?
    @@sock == nil or @@sock.closed?
  end
  
  def parse227(resp)
    if resp[0, 3] != "227"
      raise FTPReplyError, resp
    end
    left = resp.index("(")
    right = resp.index(")")
    if left == nil or right == nil
      raise FTPProtoError, resp
    end
    numbers = resp[left + 1 .. right - 1].split(",")
    if numbers.length != 6
      raise FTPProtoError, resp
    end
    host = numbers[0, 4].join(".")
    port = (numbers[4].to_i << 8) + numbers[5].to_i
    return host, port
  end
  private :parse227
  
  def parse228(resp)
    if resp[0, 3] != "228"
      raise FTPReplyError, resp
    end
    left = resp.index("(")
    right = resp.index(")")
    if left == nil or right == nil
      raise FTPProtoError, resp
    end
    numbers = resp[left + 1 .. right - 1].split(",")
    if numbers[0] == "4"
      if numbers.length != 9 || numbers[1] != "4" || numbers[2 + 4] != "2"
	raise FTPProtoError, resp
      end
      host = numbers[2, 4].join(".")
      port = (numbers[7].to_i << 8) + numbers[8].to_i
    elsif numbers[0] == "6"
      if numbers.length != 21 || numbers[1] != "16" || numbers[2 + 16] != "2"
	raise FTPProtoError, resp
      end
      v6 = ["", "", "", "", "", "", "", ""]
      for i in 0 .. 7
	v6[i] = sprintf("%02x%02x", numbers[(i * 2) + 2].to_i,
			numbers[(i * 2) + 3].to_i)
      end
      host = v6[0, 8].join(":")
      port = (numbers[19].to_i << 8) + numbers[20].to_i
    end 
    return host, port
  end
  private :parse228
  
  def parse229(resp)
    if resp[0, 3] != "229"
      raise FTPReplyError, resp
    end
    left = resp.index("(")
    right = resp.index(")")
    if left == nil or right == nil
      raise FTPProtoError, resp
    end
    numbers = resp[left + 1 .. right - 1].split(resp[left + 1, 1])
    if numbers.length != 4
      raise FTPProtoError, resp
    end
    port = numbers[3].to_i
    host = (@@sock.peeraddr())[3]
    return host, port
  end
  private :parse228
  
  def parse257(resp)
    if resp[0, 3] != "257"
      raise FTPReplyError, resp
    end
    if resp[3, 2] != ' "'
      return ""
    end
    dirname = ""
    i = 5
    n = resp.length
    while i < n
      c = resp[i, 1]
      i = i + 1
      if c == '"'
	if i > n or resp[i, 1] != '"'
	  break
	end
	i = i + 1
      end
      dirname = dirname + c
    end
    return dirname
  end
  private :parse257
end
@


1.6
log
@*** empty log message ***
@
text
@d456 1
a456 1
    return resp[3..-1].strip 
@


1.5
log
@*** empty log message ***
@
text
@d1 1
a1 6
## ftplib.rb

# Author: Shugo Maeda <shugo@@netlab.co.jp>
# Version: $Revision$

## Code:
a629 2

## ftplib.rb ends here
@


1.4
log
@*** empty log message ***
@
text
@d4 1
a4 1
# Version: $Revision:$
@


1.3
log
@*** empty log message ***
@
text
@d4 1
a4 1
# Version: 1.7.1
@


1.2
log
@1.4.0
@
text
@d3 2
a4 2
# Author: Shugo Maeda <shugo@@po.aianet.ne.jp>
# Version: $Revision: 1.7 $
a17 3
  
  RCS_ID = %q$Id: ftplib.rb,v 1.7 1998/04/13 12:34:24 shugo Exp shugo $ 
  
d311 1
a311 1
	  buf = buf.chop + CRLF
@


1.2.2.1
log
@*** empty log message ***
@
text
@d1 6
a6 1
# ftplib.rb by Shugo Maeda <shugo@@netlab.co.jp>
d18 3
d314 1
a314 1
	  buf = buf.chomp + CRLF
d638 2
@


1.2.2.2
log
@*** empty log message ***
@
text
@d456 1
a456 1
    return resp[3..-1].strip.to_i
@


1.2.2.3
log
@*** empty log message ***
@
text
@d1 629
a629 14
#
# ftplib.rb
#

$stderr.puts 'Warning: ftplib.rb is obsolute: use net/ftp'

require 'net/ftp'

FTP           = ::Net::FTP
FTPError      = ::Net::FTPError
FTPReplyError = ::Net::FTPReplyError
FTPTempError  = ::Net::FTPTempError
FTPPermError  = ::Net::FTPPermError
FTPProtoError = ::Net::FTPProtoError
@


1.2.2.4
log
@2000-04-10
@
text
@d5 1
a5 1
$stderr.puts 'Warning: ftplib.rb is obsolete: use net/ftp'
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
### ftplib.rb			-*- Mode: ruby; tab-width: 8; -*-
d3 2
a4 3
## $Revision: 1.5 $
## $Date: 1997/09/16 08:03:31 $
## by maeda shugo <shugo@@po.aianet.ne.jp>
d6 1
a6 1
### Code:
d9 1
a9 1
require "sync" if defined? Thread
d11 1
a11 1
class FTPError < Exception; end
d18 37
d56 27
a82 1
  RCS_ID = '$Id: ftplib.rb,v 1.5 1997/09/16 08:03:31 shugo Exp $'
d84 60
a143 2
   FTP_PORT = 21
   CRLF = "\r\n"
d145 6
a150 168
   attr :passive, TRUE
   attr :return_code, TRUE
   attr :debug_mode, TRUE
   attr :welcome
   attr :lastresp
   
   THREAD_SAFE = defined?(Thread) != FALSE
   
   if THREAD_SAFE
      def synchronize(mode = :EX)
	 if @@sync
	    @@sync.synchronize(mode) do
	       yield
	    end
	 end
      end
      
      def sock_synchronize(mode = :EX)
	 if @@sock
	    @@sock.synchronize(mode) do
	       yield
	    end
	 end
      end
   else
      def synchronize(mode = :EX)
	 yield
      end
      
      def sock_synchronize(mode = :EX)
	 yield
      end
   end
   private :sock_synchronize
   
   def FTP.open(host, user = nil, passwd = nil, acct = nil)
      new(host, user, passwd, acct)
   end
    
   def initialize(host = nil, user = nil,
		  passwd = nil, acct = nil)
      if THREAD_SAFE
	 @@sync = Sync.new
      end
      @@passive = FALSE
      @@return_code = "\n"
      @@debug_mode = FALSE
      if host
	 connect(host)
	 if user
	    login(user, passwd, acct)
	 end
      end
   end
   
   def open_socket(host, port)
      if defined? SOCKSsocket and ENV["SOCKS_SERVER"]
	 @@passive = TRUE
	 SOCKSsocket.open(host, port)
      else
	 TCPsocket.open(host, port)
      end
   end
   private :open_socket
   
   def connect(host, port = FTP_PORT)
      if @@debug_mode
	 print "connect: ", host, ", ", port, "\n"
      end
      synchronize do
	 @@sock = open_socket(host, port)
	 if THREAD_SAFE
	    @@sock.extend Sync_m
	 end
	 voidresp
      end
   end
   
   def sanitize(s)
      if s =~ /^PASS /i
	 s[0, 5] + "*" * (s.length - 5)
      else
	 s
      end
   end
   private :sanitize
   
   def putline(line)
      if @@debug_mode
	 print "put: ", sanitize(line), "\n"
      end
      line = line + CRLF
      @@sock.write(line)
   end
   private :putline
   
   def getline
      line = @@sock.readline # if get EOF, raise EOFError
      if line[-2, 2] == CRLF
	 line = line[0 .. -3]
      elsif line[-1] == ?\r or
	    line[-1] == ?\n
	 line = line[0 .. -2]
      end
      if @@debug_mode
	 print "get: ", sanitize(line), "\n"
      end
      line
   end
   private :getline
   
   def getmultiline
      line = getline
      buff = line
      if line[3] == ?-
	 code = line[0, 3]
	 begin
	    line = getline
	    buff << "\n" << line
	 end until line[0, 3] == code and line[3] != ?-
      end
      buff << "\n"
   end
   private :getmultiline

   def getresp
      resp = getmultiline
      @@lastresp = resp[0, 3]
      c = resp[0]
      case c
      when ?1, ?2, ?3
	 return resp
      when ?4
	 raise FTPTempError, resp
      when ?5
	 raise FTPPermError, resp
      else
	 raise FTPProtoError, resp
      end
   end
   private :getresp
   
   def voidresp
      resp = getresp
      if resp[0] != ?2
	 raise FTPReplyError, resp
      end
   end
   private :voidresp
   
   def sendcmd(cmd)
      synchronize do
	 sock_synchronize do
	    putline(cmd)
	    getresp
	 end
      end
   end
   
   def voidcmd(cmd)
      synchronize do
	 sock_synchronize do
	    putline(cmd)
	    voidresp
	 end
      end
      nil
   end
d152 3
a154 1
   def sendport(host, port)
d159 172
a330 165
      voidcmd(cmd)
   end
   private :sendport
   
   def makeport
      sock = TCPserver.open(0)
      port = sock.addr[1]
      host = TCPsocket.getaddress(@@sock.addr[2])
      resp = sendport(host, port)
      sock
   end
   private :makeport
   
   def transfercmd(cmd)
      if @@passive
	 host, port = parse227(sendcmd("PASV"))
	 conn = open_socket(host, port)
	 resp = sendcmd(cmd)
	 if resp[0] != ?1
	    raise FTPReplyError, resp
	 end
      else
	 sock = makeport
	 resp = sendcmd(cmd)
	 if resp[0] != ?1
	    raise FTPReplyError, resp
	 end
	 conn = sock.accept
      end
      conn
   end
   private :transfercmd
   
   def getaddress
      thishost = Socket.gethostname
      if not thishost.index(".")
	 thishost = Socket.gethostbyname(thishost)[0]
      end
      if ENV.has_key?("LOGNAME")
	 realuser = ENV["LOGNAME"]
      elsif ENV.has_key?("USER")
	 realuser = ENV["USER"]
      else
	 realuser = "anonymous"
      end
      realuser + "@@" + thishost
   end
   private :getaddress
   
   def login(user = "anonymous", passwd = nil, acct = nil)
      if user == "anonymous" and passwd == nil
	 passwd = getaddress
      end
      
      resp = ""
      synchronize do
	 resp = sendcmd('USER ' + user)
	 if resp[0] == ?3
	    resp = sendcmd('PASS ' + passwd)
	 end
	 if resp[0] == ?3
	    resp = sendcmd('ACCT ' + acct)
	 end
      end
      if resp[0] != ?2
	 raise FTPReplyError, resp
      end
      @@welcome = resp
   end
   
   def retrbinary(cmd, blocksize, callback = Proc.new)
      synchronize do
	 voidcmd("TYPE I")
	 conn = transfercmd(cmd)
	 while TRUE
	    data = conn.read(blocksize)
	    break if data == nil
	    callback.call(data)
	 end
	 conn.close
	 voidresp
      end
   end
   
   def retrlines(cmd, callback = nil)
      if iterator?
	 callback = Proc.new
      elsif not callback.is_a?(Proc)
	 callback = Proc.new {|line| print line, "\n"}
      end
      synchronize do
	 voidcmd("TYPE A")
	 conn = transfercmd(cmd)
	 while TRUE
	    line = conn.gets
	    break if line == nil
	    if line[-2, 2] == CRLF
	       line = line[0 .. -3]
	    elsif line[-1] == ?\n
	       line = line[0 .. -2]
	    end
	    callback.call(line)
	 end
	 conn.close
	 voidresp
      end
   end
   
   def storbinary(cmd, file, blocksize, callback = nil)
      if iterator?
	 callback = Proc.new
      end
      use_callback = callback.is_a?(Proc)
      synchronize do
	 voidcmd("TYPE I")
	 conn = transfercmd(cmd)
	 while TRUE
	    buf = file.read(blocksize)
	    break if buf == nil
	    conn.write(buf)
	    if use_callback
	       callback.call(buf)
	    end
	 end
	 conn.close
	 voidresp
      end
   end
   
   def storlines(cmd, file, callback = nil)
      if iterator?
	 callback = Proc.new
      end
      use_callback = callback.is_a?(Proc)
      synchronize do
	 voidcmd("TYPE A")
	 conn = transfercmd(cmd)
	 while TRUE
	    buf = file.gets
	    break if buf == nil
	    if buf[-2, 2] != CRLF
	       if buf[-1] == ?\r or
		     buf[-1] == ?\n
		  buf = buf[0 .. -2]
	       end
	       buf = buf + CRLF
	    end
	    conn.write(buf)
	    if use_callback
	       callback.call(buf)
	    end
	 end
	 conn.close
	 voidresp
      end
   end
   
   def getbinaryfile(remotefile, localfile,
		     blocksize, callback = nil)
      if iterator?
	 callback = Proc.new
      end
      use_callback = callback.is_a?(Proc)
      f = open(localfile, "w")
      begin
d332 33
a364 38
	 retrbinary("RETR " + remotefile, blocksize) do |data|
	    f.write(data)
	    if use_callback
	       callback.call(data)
	    end
	 end
      ensure
	 f.close
      end
   end
   
   def gettextfile(remotefile, localfile, callback = nil)
      if iterator?
	 callback = Proc.new
      end
      use_callback = callback.is_a?(Proc)
      f = open(localfile, "w")
      begin
	 retrlines("RETR " + remotefile) do |line|
	    line = line + @@return_code
	    f.write(line)
	    if use_callback
	       callback.call(line)
	    end
	 end
      ensure
	 f.close
      end
   end
   
   def putbinaryfile(localfile, remotefile,
		     blocksize, callback = nil)
      if iterator?
	 callback = Proc.new
      end
      use_callback = callback.is_a?(Proc)
      f = open(localfile)
      begin
d366 2
a367 13
	 storbinary("STOR " + remotefile, f, blocksize) do |data|
	    if use_callback
	       callback.call(data)
	    end
	 end
      ensure
	 f.close
      end
   end
   
   def puttextfile(localfile, remotefile, callback = nil)
      if iterator?
	 callback = Proc.new
d369 46
a414 24
      use_callback = callback.is_a?(Proc)
      f = open(localfile)
      begin
	 storlines("STOR " + remotefile, f) do |line|
	    if use_callback
	       callback.call(line)
	    end
	 end
      ensure
	 f.close
      end
   end
   
   def acct(account)
      cmd = "ACCT " + account
      voidcmd(cmd)
   end
   
   def nlst(dir = nil)
      cmd = "NLST"
      if dir
	 cmd = cmd + " " + dir
      end
      files = []
d416 1
a416 1
	 files.push(line)
d418 39
a456 2
      files
   end
d458 28
a485 60
   def list(*args)
      cmd = "LIST"
      if iterator?
	 callback = Proc.new
      elsif args[-1].is_a?(Proc)
	 callback = args.pop
      else
	 callback = nil
      end
      args.each do |arg|
	 cmd = cmd + " " + arg
      end
      retrlines(cmd, callback)
   end
   alias ls list
   alias dir list
   
   def rename(fromname, toname)
      resp = sendcmd("RNFR " + fromname)
      if resp[0] != ?3
	 raise FTPReplyError, resp
      end
      voidcmd("RNTO " + toname)
   end
   
   def delete(filename)
      resp = sendcmd("DELE " + filename)
      if resp[0, 3] == "250"
	 return
      elsif resp[0] == ?5
	 raise FTPPermError, resp
      else
	 raise FTPReplyError, resp
      end
   end
   
   def chdir(dirname)
      if dirname == ".."
	 begin
	    voidcmd("CDUP")
	    return
	 rescue FTPPermError
	    if $![0, 3] != "500"
	       raise FTPPermError, $!
	    end
	 end
      end
      cmd = "CWD " + dirname
      voidcmd(cmd)
   end
   
   def size(filename)
      resp = sendcmd("SIZE " + filename)
      if resp[0, 3] == "213"
	 return Integer(resp[3 .. -1].strip)
      end
   end
   
   def mkdir(dirname)
      resp = sendcmd("MKD " + dirname)
d487 21
a507 60
   end
   
   def rmdir(dirname)
      voidcmd("RMD " + dirname)
   end
   
   def pwd
      resp = sendcmd("PWD")
      return parse257(resp)
   end
   alias getdir pwd
   
   def system
      resp = sendcmd("SYST")
      if resp[0, 3] != "215"
	 raise FTPReplyError, resp
      end
      return resp[4 .. -1]
   end
   
   def abort
      line = "ABOR" + CRLF
      resp = ""
      sock_synchronize do
	 print "put: ABOR\n" if @@debug_mode
	 @@sock.send(line, Socket::MSG_OOB)
	 resp = getmultiline
      end
      unless ["426", "226", "225"].include?(resp[0, 3])
	 raise FTPProtoError, resp
      end
      resp
   end
   
   def status
      line = "STAT" + CRLF
      resp = ""
      sock_synchronize do
	 print "put: STAT\n" if @@debug_mode
	 @@sock.send(line, Socket::MSG_OOB)
	 resp = getresp
      end
      resp
   end
   
   def help(arg = nil)
      cmd = "HELP"
      if arg
	 cmd = cmd + " " + arg
      end
      sendcmd(cmd)
   end
   
   def quit
      voidcmd("QUIT")
   end
   
   def close
      @@sock.close if @@sock and not @@sock.closed?
   end
d509 30
d543 94
a636 43
   def parse227(resp)
      if resp[0, 3] != "227"
	 raise FTPReplyError, resp
      end
      left = resp.index("(")
      right = resp.index(")")
      if left == nil or right == nil
	 raise FTPProtoError, resp
      end
      numbers = resp[left + 1 .. right - 1].split(",")
      if numbers.length != 6
	 raise FTPProtoError, resp
      end
      host = numbers[0, 4].join(".")
      port = (Integer(numbers[4]) << 8) + Integer(numbers[5])
      return host, port
   end
   private :parse227
   
   def parse257(resp)
      if resp[0, 3] != "257"
	 raise FTPReplyError, resp
      end
      if resp[3, 2] != ' "'
	 return ""
      end
      dirname = ""
      i = 5
      n = resp.length
      while i < n
	 c = resp[i, 1]
	 i = i + 1
	 if c == '"'
	    if i > n or resp[i, 1] != '"'
	       break
	    end
	    i = i + 1
	 end
	 dirname = dirname + c
      end
      return dirname
   end
   private :parse257
d638 2
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@d1 1
a1 1
## ftplib.rb
d3 3
a5 2
# Author: Shugo Maeda <shugo@@po.aianet.ne.jp>
# Version: $Revision: 1.7 $
d7 1
a7 1
## Code:
d10 1
a10 1
require "monitor"
d12 1
a12 1
class FTPError < StandardError; end
a18 65
  
  RCS_ID = %q$Id: ftplib.rb,v 1.7 1998/04/13 12:34:24 shugo Exp shugo $ 
  
  include MonitorMixin
  
  FTP_PORT = 21
  CRLF = "\r\n"
  
  attr_accessor :passive, :return_code, :debug_mode
  attr_reader :welcome, :lastresp
  
  def FTP.open(host, user = nil, passwd = nil, acct = nil)
    new(host, user, passwd, acct)
  end
    
  def initialize(host = nil, user = nil, passwd = nil, acct = nil)
    super
    @@passive = false
    @@return_code = "\n"
    @@debug_mode = false
    if host
      connect(host)
      if user
	login(user, passwd, acct)
      end
    end
  end
  
  def open_socket(host, port)
    if defined? SOCKSsocket and ENV["SOCKS_SERVER"]
      @@passive = true
      return SOCKSsocket.open(host, port)
    else
      return TCPsocket.open(host, port)
    end
  end
  private :open_socket
   
  def connect(host, port = FTP_PORT)
    if @@debug_mode
      print "connect: ", host, ", ", port, "\n"
    end
    synchronize do
      @@sock = open_socket(host, port)
      voidresp
    end
  end
  
  def sanitize(s)
    if s =~ /^PASS /i
      return s[0, 5] + "*" * (s.length - 5)
    else
      return s
    end
  end
  private :sanitize
  
  def putline(line)
    if @@debug_mode
      print "put: ", sanitize(line), "\n"
    end
    line = line + CRLF
    @@sock.write(line)
  end
  private :putline
d20 1
a20 60
  def getline
    line = @@sock.readline # if get EOF, raise EOFError
    if line[-2, 2] == CRLF
      line = line[0 .. -3]
    elsif line[-1] == ?\r or
	line[-1] == ?\n
      line = line[0 .. -2]
    end
    if @@debug_mode
      print "get: ", sanitize(line), "\n"
    end
    return line
  end
  private :getline
  
  def getmultiline
    line = getline
    buff = line
    if line[3] == ?-
      code = line[0, 3]
      begin
	line = getline
	buff << "\n" << line
      end until line[0, 3] == code and line[3] != ?-
    end
    return buff << "\n"
  end
  private :getmultiline
  
  def getresp
    resp = getmultiline
    @@lastresp = resp[0, 3]
    c = resp[0]
    case c
    when ?1, ?2, ?3
      return resp
    when ?4
      raise FTPTempError, resp
    when ?5
      raise FTPPermError, resp
    else
      raise FTPProtoError, resp
    end
  end
  private :getresp
  
  def voidresp
    resp = getresp
    if resp[0] != ?2
      raise FTPReplyError, resp
    end
  end
  private :voidresp
  
  def sendcmd(cmd)
    synchronize do
      putline(cmd)
      return getresp
    end
  end
d22 2
a23 6
  def voidcmd(cmd)
    synchronize do
      putline(cmd)
      voidresp
    end
  end
d25 38
a62 58
  def sendport(host, port)
    hbytes = host.split(".")
    pbytes = [port / 256, port % 256]
    bytes = hbytes + pbytes
    cmd = "PORT " + bytes.join(",")
    voidcmd(cmd)
  end
  private :sendport
   
  def makeport
    sock = TCPserver.open(0)
    port = sock.addr[1]
    host = TCPsocket.getaddress(@@sock.addr[2])
    resp = sendport(host, port)
    return sock
  end
  private :makeport
   
  def transfercmd(cmd)
    if @@passive
      host, port = parse227(sendcmd("PASV"))
      conn = open_socket(host, port)
      resp = sendcmd(cmd)
      if resp[0] != ?1
	raise FTPReplyError, resp
      end
    else
      sock = makeport
      resp = sendcmd(cmd)
      if resp[0] != ?1
	raise FTPReplyError, resp
      end
      conn = sock.accept
    end
    return conn
  end
  private :transfercmd
   
  def getaddress
    thishost = Socket.gethostname
    if not thishost.index(".")
      thishost = Socket.gethostbyname(thishost)[0]
    end
    if ENV.has_key?("LOGNAME")
      realuser = ENV["LOGNAME"]
    elsif ENV.has_key?("USER")
      realuser = ENV["USER"]
    else
      realuser = "anonymous"
    end
    return realuser + "@@" + thishost
  end
  private :getaddress
   
  def login(user = "anonymous", passwd = nil, acct = nil)
    if user == "anonymous" and passwd == nil
      passwd = getaddress
    end
d64 300
a363 106
    resp = ""
    synchronize do
      resp = sendcmd('USER ' + user)
      if resp[0] == ?3
	resp = sendcmd('PASS ' + passwd)
      end
      if resp[0] == ?3
	resp = sendcmd('ACCT ' + acct)
      end
    end
    if resp[0] != ?2
      raise FTPReplyError, resp
    end
    @@welcome = resp
  end
  
  def retrbinary(cmd, blocksize, callback = Proc.new)
    synchronize do
      voidcmd("TYPE I")
      conn = transfercmd(cmd)
      loop do
	data = conn.read(blocksize)
	break if data == nil
	callback.call(data)
      end
      conn.close
      voidresp
    end
  end
   
  def retrlines(cmd, callback = nil)
    if iterator?
      callback = Proc.new
    elsif not callback.is_a?(Proc)
      callback = Proc.new {|line| print line, "\n"}
    end
    synchronize do
      voidcmd("TYPE A")
      conn = transfercmd(cmd)
      loop do
	line = conn.gets
	break if line == nil
	if line[-2, 2] == CRLF
	  line = line[0 .. -3]
	elsif line[-1] == ?\n
	  line = line[0 .. -2]
	end
	callback.call(line)
      end
      conn.close
      voidresp
    end
  end
  
  def storbinary(cmd, file, blocksize, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    synchronize do
      voidcmd("TYPE I")
      conn = transfercmd(cmd)
      loop do
	buf = file.read(blocksize)
	break if buf == nil
	conn.write(buf)
	callback.call(buf) if use_callback
      end
      conn.close
      voidresp
    end
  end
   
  def storlines(cmd, file, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    synchronize do
      voidcmd("TYPE A")
      conn = transfercmd(cmd)
      loop do
	buf = file.gets
	break if buf == nil
	if buf[-2, 2] != CRLF
	  if buf[-1] == ?\r or
	      buf[-1] == ?\n
	    buf = buf[0 .. -2]
	  end
	  buf = buf + CRLF
	end
	conn.write(buf)
	callback.call(buf) if use_callback
      end
      conn.close
      voidresp
    end
  end
  
  def getbinaryfile(remotefile, localfile, blocksize, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile, "w")
    begin
d365 38
a402 33
      retrbinary("RETR " + remotefile, blocksize) do |data|
	f.write(data)
	callback.call(data) if use_callback
      end
    ensure
      f.close
    end
  end
   
  def gettextfile(remotefile, localfile, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile, "w")
    begin
      retrlines("RETR " + remotefile) do |line|
	line = line + @@return_code
	f.write(line)
	callback.call(line) if use_callback
      end
    ensure
      f.close
    end
  end
   
  def putbinaryfile(localfile, remotefile, blocksize, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile)
    begin
d404 36
a439 2
      storbinary("STOR " + remotefile, f, blocksize) do |data|
	callback.call(data) if use_callback
d441 6
a446 19
    ensure
      f.close
    end
  end
  
  def puttextfile(localfile, remotefile, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile)
    begin
      storlines("STOR " + remotefile, f) do |line|
	callback.call(line) if use_callback
      end
    ensure
      f.close
    end
  end
d448 55
a502 28
  def acct(account)
    cmd = "ACCT " + account
    voidcmd(cmd)
  end
  
  def nlst(dir = nil)
    cmd = "NLST"
    if dir
      cmd = cmd + " " + dir
    end
    files = []
    retrlines(cmd) do |line|
      files.push(line)
    end
    return files
  end
  
  def list(*args, &block)
    cmd = "LIST"
    args.each do |arg|
      cmd = cmd + " " + arg
    end
    if block
      retrlines(cmd, &block)
    else
      lines = []
      retrlines(cmd) do |line|
	lines << line
d504 10
a513 39
      return lines
    end
  end
  alias ls list
  alias dir list
  
  def rename(fromname, toname)
    resp = sendcmd("RNFR " + fromname)
    if resp[0] != ?3
      raise FTPReplyError, resp
    end
    voidcmd("RNTO " + toname)
  end
  
  def delete(filename)
    resp = sendcmd("DELE " + filename)
    if resp[0, 3] == "250"
      return
    elsif resp[0] == ?5
      raise FTPPermError, resp
    else
      raise FTPReplyError, resp
    end
  end
  
  def chdir(dirname)
    if dirname == ".."
      begin
	voidcmd("CDUP")
	return
      rescue FTPPermError
	if $![0, 3] != "500"
	  raise FTPPermError, $!
	end
      end
    end
    cmd = "CWD " + dirname
    voidcmd(cmd)
  end
d515 2
a516 28
  def size(filename)
    voidcmd("TYPE I")
    resp = sendcmd("SIZE " + filename)
    if resp[0, 3] != "213" 
      raise FTPReplyError, resp
    end
    return resp[3..-1].strip 
  end

  MDTM_REGEXP = /^(\d\d\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/

  def mtime(filename, local = false)
    str = mdtm(filename)
    ary = str.scan(MDTM_REGEXP)[0].collect {|i| i.to_i}
    return local ? Time.local(*ary) : Time.gm(*ary)
  end

  def mkdir(dirname)
    resp = sendcmd("MKD " + dirname)
    return parse257(resp)
  end
  
  def rmdir(dirname)
    voidcmd("RMD " + dirname)
  end
  
  def pwd
    resp = sendcmd("PWD")
d518 51
a568 21
  end
  alias getdir pwd
  
  def system
    resp = sendcmd("SYST")
    if resp[0, 3] != "215"
      raise FTPReplyError, resp
    end
    return resp[4 .. -1]
  end
  
  def abort
    line = "ABOR" + CRLF
    print "put: ABOR\n" if @@debug_mode
    @@sock.send(line, Socket::MSG_OOB)
    resp = getmultiline
    unless ["426", "226", "225"].include?(resp[0, 3])
      raise FTPProtoError, resp
    end
    return resp
  end
a569 30
  def status
    line = "STAT" + CRLF
    print "put: STAT\n" if @@debug_mode
    @@sock.send(line, Socket::MSG_OOB)
    return getresp
  end
  
  def mdtm(filename)
    resp = sendcmd("MDTM " + filename)
    if resp[0, 3] == "213"
      return resp[3 .. -1].strip
    end
  end
  
  def help(arg = nil)
    cmd = "HELP"
    if arg
      cmd = cmd + " " + arg
    end
    sendcmd(cmd)
  end
  
  def quit
    voidcmd("QUIT")
  end
  
  def close
    @@sock.close if @@sock and not @@sock.closed?
  end
  
d574 43
a616 43
  def parse227(resp)
    if resp[0, 3] != "227"
      raise FTPReplyError, resp
    end
    left = resp.index("(")
    right = resp.index(")")
    if left == nil or right == nil
      raise FTPProtoError, resp
    end
    numbers = resp[left + 1 .. right - 1].split(",")
    if numbers.length != 6
      raise FTPProtoError, resp
    end
    host = numbers[0, 4].join(".")
    port = (numbers[4].to_i << 8) + numbers[5].to_i
    return host, port
  end
  private :parse227
  
  def parse257(resp)
    if resp[0, 3] != "257"
      raise FTPReplyError, resp
    end
    if resp[3, 2] != ' "'
      return ""
    end
    dirname = ""
    i = 5
    n = resp.length
    while i < n
      c = resp[i, 1]
      i = i + 1
      if c == '"'
	if i > n or resp[i, 1] != '"'
	  break
	end
	i = i + 1
      end
      dirname = dirname + c
    end
    return dirname
  end
  private :parse257
a617 2

## ftplib.rb ends here
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d296 5
a300 1
	  buf = buf.chop + CRLF
@


1.1.1.2.2.2
log
@ipv6
@
text
@d153 4
a156 11
    af = (@@sock.peeraddr)[0]
    if af == "AF_INET"
      hbytes = host.split(".")
      pbytes = [port / 256, port % 256]
      bytes = hbytes + pbytes
      cmd = "PORT " + bytes.join(",")
    elsif af == "AF_INET6"
      cmd = "EPRT |2|" + host + "|" + sprintf("%d", port) + "|"
    else
      raise FTPProtoError, host
    end
d162 1
a162 1
    sock = TCPserver.open(@@sock.addr[3], 0)
a169 11
  def makepasv
    if @@sock.peeraddr[0] == "AF_INET"
      host, port = parse227(sendcmd("PASV"))
    else
      host, port = parse229(sendcmd("EPSV"))
#     host, port = parse228(sendcmd("LPSV"))
    end
    return host, port
  end
  private :makepasv
   
d172 1
a172 1
      host, port = makepasv
a542 51
  
  def parse228(resp)
    if resp[0, 3] != "228"
      raise FTPReplyError, resp
    end
    left = resp.index("(")
    right = resp.index(")")
    if left == nil or right == nil
      raise FTPProtoError, resp
    end
    numbers = resp[left + 1 .. right - 1].split(",")
    if numbers[0] == "4"
      if numbers.length != 9 || numbers[1] != "4" || numbers[2 + 4] != "2"
	raise FTPProtoError, resp
      end
      host = numbers[2, 4].join(".")
      port = (numbers[7].to_i << 8) + numbers[8].to_i
    elsif numbers[0] == "6"
      if numbers.length != 21 || numbers[1] != "16" || numbers[2 + 16] != "2"
	raise FTPProtoError, resp
      end
      v6 = ["", "", "", "", "", "", "", ""]
      for i in 0 .. 7
	v6[i] = sprintf("%02x%02x", numbers[(i * 2) + 2].to_i,
			numbers[(i * 2) + 3].to_i)
      end
      host = v6[0, 8].join(":")
      port = (numbers[19].to_i << 8) + numbers[20].to_i
    end 
    return host, port
  end
  private :parse228
  
  def parse229(resp)
    if resp[0, 3] != "229"
      raise FTPReplyError, resp
    end
    left = resp.index("(")
    right = resp.index(")")
    if left == nil or right == nil
      raise FTPProtoError, resp
    end
    numbers = resp[left + 1 .. right - 1].split(resp[left + 1, 1])
    if numbers.length != 4
      raise FTPProtoError, resp
    end
    port = numbers[3].to_i
    host = (@@sock.peeraddr())[3]
    return host, port
  end
  private :parse228
@


1.1.1.1.4.1
log
@*** empty log message ***
@
text
@d3 2
a4 2
## $Revision: 1.1.1.1 $
## $Date: 1998/01/16 04:05:49 $
d20 1
a20 1
  RCS_ID = '$Id: ftplib.rb,v 1.1.1.1 1998/01/16 04:05:49 matz Exp $'
@


1.1.1.1.4.2
log
@Mon Jan 19 14:06:13 JST 1998
@
text
@d3 2
a4 2
## $Revision: 1.1.1.1.4.1 $
## $Date: 1998/01/16 12:36:05 $
d20 1
a20 1
  RCS_ID = '$Id: ftplib.rb,v 1.1.1.1.4.1 1998/01/16 12:36:05 matz Exp $ '
@


1.1.1.1.4.3
log
@-ko for keiju's files
@
text
@d3 2
a4 2
## $Revision: 1.5 $
## $Date: 1997/09/16 08:03:31 $
d20 1
a20 1
  RCS_ID = %q$Id: ftplib.rb,v 1.5 1997/09/16 08:03:31 shugo Exp $
@


1.1.1.1.4.4
log
@cygwin patches
@
text
@a553 7
   def mdtm(filename)
     resp = sendcmd("MDTM " + filename)
     if resp[0, 3] == "213"
       return resp[3 .. -1].strip
     end
   end

@


1.1.1.1.4.5
log
@*** empty log message ***
@
text
@d1 1
a1 1
## ftplib.rb
d3 3
a5 2
# Author: Shugo Maeda <shugo@@po.aianet.ne.jp>
# Version: $Revision: 1.6 $
d7 1
a7 1
## Code:
d10 1
a10 1
require "monitor"
a18 37
  
  RCS_ID = %q$Id: ftplib.rb,v 1.6 1998/03/01 08:49:57 shugo Exp shugo $
  
  include MonitorMixin
  
  FTP_PORT = 21
  CRLF = "\r\n"
  
  attr_accessor :passive, :return_code, :debug_mode
  attr_reader :welcome, :lastresp
  
  def FTP.open(host, user = nil, passwd = nil, acct = nil)
    new(host, user, passwd, acct)
  end
    
  def initialize(host = nil, user = nil, passwd = nil, acct = nil)
    super
    @@passive = false
    @@return_code = "\n"
    @@debug_mode = false
    if host
      connect(host)
      if user
	login(user, passwd, acct)
      end
    end
  end
  
  def open_socket(host, port)
    if defined? SOCKSsocket and ENV["SOCKS_SERVER"]
      @@passive = true
      return SOCKSsocket.open(host, port)
    else
      return TCPsocket.open(host, port)
    end
  end
  private :open_socket
d20 1
a20 27
  def connect(host, port = FTP_PORT)
    if @@debug_mode
      print "connect: ", host, ", ", port, "\n"
    end
    synchronize do
      @@sock = open_socket(host, port)
      voidresp
    end
  end
  
  def sanitize(s)
    if s =~ /^PASS /i
      return s[0, 5] + "*" * (s.length - 5)
    else
      return s
    end
  end
  private :sanitize
  
  def putline(line)
    if @@debug_mode
      print "put: ", sanitize(line), "\n"
    end
    line = line + CRLF
    @@sock.write(line)
  end
  private :putline
d22 2
a23 60
  def getline
    line = @@sock.readline # if get EOF, raise EOFError
    if line[-2, 2] == CRLF
      line = line[0 .. -3]
    elsif line[-1] == ?\r or
	line[-1] == ?\n
      line = line[0 .. -2]
    end
    if @@debug_mode
      print "get: ", sanitize(line), "\n"
    end
    return line
  end
  private :getline
  
  def getmultiline
    line = getline
    buff = line
    if line[3] == ?-
      code = line[0, 3]
      begin
	line = getline
	buff << "\n" << line
      end until line[0, 3] == code and line[3] != ?-
    end
    return buff << "\n"
  end
  private :getmultiline
  
  def getresp
    resp = getmultiline
    @@lastresp = resp[0, 3]
    c = resp[0]
    case c
    when ?1, ?2, ?3
      return resp
    when ?4
      raise FTPTempError, resp
    when ?5
      raise FTPPermError, resp
    else
      raise FTPProtoError, resp
    end
  end
  private :getresp
  
  def voidresp
    resp = getresp
    if resp[0] != ?2
      raise FTPReplyError, resp
    end
  end
  private :voidresp
  
  def sendcmd(cmd)
    synchronize do
      putline(cmd)
      return getresp
    end
  end
d25 38
a62 65
  def voidcmd(cmd)
    synchronize do
      putline(cmd)
      voidresp
    end
  end
   
  def sendport(host, port)
    hbytes = host.split(".")
    pbytes = [port / 256, port % 256]
    bytes = hbytes + pbytes
    cmd = "PORT " + bytes.join(",")
    voidcmd(cmd)
  end
  private :sendport
   
  def makeport
    sock = TCPserver.open(0)
    port = sock.addr[1]
    host = TCPsocket.getaddress(@@sock.addr[2])
    resp = sendport(host, port)
    return sock
  end
  private :makeport
   
  def transfercmd(cmd)
    if @@passive
      host, port = parse227(sendcmd("PASV"))
      conn = open_socket(host, port)
      resp = sendcmd(cmd)
      if resp[0] != ?1
	raise FTPReplyError, resp
      end
    else
      sock = makeport
      resp = sendcmd(cmd)
      if resp[0] != ?1
	raise FTPReplyError, resp
      end
      conn = sock.accept
    end
    return conn
  end
  private :transfercmd
   
  def getaddress
    thishost = Socket.gethostname
    if not thishost.index(".")
      thishost = Socket.gethostbyname(thishost)[0]
    end
    if ENV.has_key?("LOGNAME")
      realuser = ENV["LOGNAME"]
    elsif ENV.has_key?("USER")
      realuser = ENV["USER"]
    else
      realuser = "anonymous"
    end
    return realuser + "@@" + thishost
  end
  private :getaddress
   
  def login(user = "anonymous", passwd = nil, acct = nil)
    if user == "anonymous" and passwd == nil
      passwd = getaddress
    end
d64 300
a363 106
    resp = ""
    synchronize do
      resp = sendcmd('USER ' + user)
      if resp[0] == ?3
	resp = sendcmd('PASS ' + passwd)
      end
      if resp[0] == ?3
	resp = sendcmd('ACCT ' + acct)
      end
    end
    if resp[0] != ?2
      raise FTPReplyError, resp
    end
    @@welcome = resp
  end
  
  def retrbinary(cmd, blocksize, callback = Proc.new)
    synchronize do
      voidcmd("TYPE I")
      conn = transfercmd(cmd)
      loop do
	data = conn.read(blocksize)
	break if data == nil
	callback.call(data)
      end
      conn.close
      voidresp
    end
  end
   
  def retrlines(cmd, callback = nil)
    if iterator?
      callback = Proc.new
    elsif not callback.is_a?(Proc)
      callback = Proc.new {|line| print line, "\n"}
    end
    synchronize do
      voidcmd("TYPE A")
      conn = transfercmd(cmd)
      loop do
	line = conn.gets
	break if line == nil
	if line[-2, 2] == CRLF
	  line = line[0 .. -3]
	elsif line[-1] == ?\n
	  line = line[0 .. -2]
	end
	callback.call(line)
      end
      conn.close
      voidresp
    end
  end
  
  def storbinary(cmd, file, blocksize, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    synchronize do
      voidcmd("TYPE I")
      conn = transfercmd(cmd)
      loop do
	buf = file.read(blocksize)
	break if buf == nil
	conn.write(buf)
	callback.call(buf) if use_callback
      end
      conn.close
      voidresp
    end
  end
   
  def storlines(cmd, file, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    synchronize do
      voidcmd("TYPE A")
      conn = transfercmd(cmd)
      loop do
	buf = file.gets
	break if buf == nil
	if buf[-2, 2] != CRLF
	  if buf[-1] == ?\r or
	      buf[-1] == ?\n
	    buf = buf[0 .. -2]
	  end
	  buf = buf + CRLF
	end
	conn.write(buf)
	callback.call(buf) if use_callback
      end
      conn.close
      voidresp
    end
  end
  
  def getbinaryfile(remotefile, localfile, blocksize, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile, "w")
    begin
d365 38
a402 33
      retrbinary("RETR " + remotefile, blocksize) do |data|
	f.write(data)
	callback.call(data) if use_callback
      end
    ensure
      f.close
    end
  end
   
  def gettextfile(remotefile, localfile, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile, "w")
    begin
      retrlines("RETR " + remotefile) do |line|
	line = line + @@return_code
	f.write(line)
	callback.call(line) if use_callback
      end
    ensure
      f.close
    end
  end
   
  def putbinaryfile(localfile, remotefile, blocksize, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile)
    begin
d404 13
a416 2
      storbinary("STOR " + remotefile, f, blocksize) do |data|
	callback.call(data) if use_callback
d418 87
a504 19
    ensure
      f.close
    end
  end
  
  def puttextfile(localfile, remotefile, callback = nil)
    if iterator?
      callback = Proc.new
    end
    use_callback = callback.is_a?(Proc)
    f = open(localfile)
    begin
      storlines("STOR " + remotefile, f) do |line|
	callback.call(line) if use_callback
      end
    ensure
      f.close
    end
  end
d506 4
a509 67
  def acct(account)
    cmd = "ACCT " + account
    voidcmd(cmd)
  end
  
  def nlst(dir = nil)
    cmd = "NLST"
    if dir
      cmd = cmd + " " + dir
    end
    files = []
    retrlines(cmd) do |line|
      files.push(line)
    end
    return files
  end
  
  def list(*args)
    cmd = "LIST"
    if iterator?
      callback = Proc.new
    elsif args[-1].is_a?(Proc)
      callback = args.pop
    else
      callback = nil
    end
    args.each do |arg|
      cmd = cmd + " " + arg
    end
    retrlines(cmd, callback)
  end
  alias ls list
  alias dir list
  
  def rename(fromname, toname)
    resp = sendcmd("RNFR " + fromname)
    if resp[0] != ?3
      raise FTPReplyError, resp
    end
    voidcmd("RNTO " + toname)
  end
  
  def delete(filename)
    resp = sendcmd("DELE " + filename)
    if resp[0, 3] == "250"
      return
    elsif resp[0] == ?5
      raise FTPPermError, resp
    else
      raise FTPReplyError, resp
    end
  end
  
  def chdir(dirname)
    if dirname == ".."
      begin
	voidcmd("CDUP")
	return
      rescue FTPPermError
	if $![0, 3] != "500"
	  raise FTPPermError, $!
	end
      end
    end
    cmd = "CWD " + dirname
    voidcmd(cmd)
  end
d511 3
a513 6
  def size(filename)
    resp = sendcmd("SIZE " + filename)
    if resp[0, 3] == "213"
      return resp[3 .. -1].strip.to_i
    end
  end
d515 2
a516 11
  def mkdir(dirname)
    resp = sendcmd("MKD " + dirname)
    return parse257(resp)
  end
  
  def rmdir(dirname)
    voidcmd("RMD " + dirname)
  end
  
  def pwd
    resp = sendcmd("PWD")
d518 58
a575 21
  end
  alias getdir pwd
  
  def system
    resp = sendcmd("SYST")
    if resp[0, 3] != "215"
      raise FTPReplyError, resp
    end
    return resp[4 .. -1]
  end
  
  def abort
    line = "ABOR" + CRLF
    print "put: ABOR\n" if @@debug_mode
    @@sock.send(line, Socket::MSG_OOB)
    resp = getmultiline
    unless ["426", "226", "225"].include?(resp[0, 3])
      raise FTPProtoError, resp
    end
    return resp
  end
a576 30
  def status
    line = "STAT" + CRLF
    print "put: STAT\n" if @@debug_mode
    @@sock.send(line, Socket::MSG_OOB)
    return getresp
  end
  
  def mdtm(filename)
    resp = sendcmd("MDTM " + filename)
    if resp[0, 3] == "213"
      return resp[3 .. -1].strip
    end
  end
  
  def help(arg = nil)
    cmd = "HELP"
    if arg
      cmd = cmd + " " + arg
    end
    sendcmd(cmd)
  end
  
  def quit
    voidcmd("QUIT")
  end
  
  def close
    @@sock.close if @@sock and not @@sock.closed?
  end
  
d581 43
a623 43
  def parse227(resp)
    if resp[0, 3] != "227"
      raise FTPReplyError, resp
    end
    left = resp.index("(")
    right = resp.index(")")
    if left == nil or right == nil
      raise FTPProtoError, resp
    end
    numbers = resp[left + 1 .. right - 1].split(",")
    if numbers.length != 6
      raise FTPProtoError, resp
    end
    host = numbers[0, 4].join(".")
    port = (numbers[4].to_i << 8) + numbers[5].to_i
    return host, port
  end
  private :parse227
  
  def parse257(resp)
    if resp[0, 3] != "257"
      raise FTPReplyError, resp
    end
    if resp[3, 2] != ' "'
      return ""
    end
    dirname = ""
    i = 5
    n = resp.length
    while i < n
      c = resp[i, 1]
      i = i + 1
      if c == '"'
	if i > n or resp[i, 1] != '"'
	  break
	end
	i = i + 1
      end
      dirname = dirname + c
    end
    return dirname
  end
  private :parse257
a624 2

## ftplib.rb ends here
@


1.1.1.1.4.6
log
@1.1b9_09
@
text
@d392 1
a392 1
  def list(*args, &block)
d394 7
d404 1
a404 9
    if block
      retrlines(cmd, &block)
    else
      lines = []
      retrlines(cmd) do |line|
	lines << line
      end
      return lines
    end
a443 1
    voidcmd("TYPE I")
@


1.1.1.1.4.7
log
@exception name on -d
@
text
@d4 1
a4 1
# Version: $Revision: 1.7 $
d19 1
a19 1
  RCS_ID = %q$Id: ftplib.rb,v 1.7 1998/04/13 12:34:24 shugo Exp shugo $ 
d447 2
a448 2
    if resp[0, 3] != "213" 
      raise FTPReplyError, resp
a449 1
    return resp[3..-1].strip 
d451 1
a451 9

  MDTM_REGEXP = /^(\d\d\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/

  def mtime(filename) 
    str = mdtm(filename)
    ary = str.scan(MDTM_REGEXP)[0].collect {|i| i.to_i} 
    return Time.gm(*ary) 
  end

@


1.1.1.1.4.8
log
@exception model changed
@
text
@d11 1
a11 1
class FTPError < StandardError; end
@


1.1.1.1.4.9
log
@*** empty log message ***
@
text
@d455 1
a455 1
  def mtime(filename, local = false)
d457 2
a458 2
    ary = str.scan(MDTM_REGEXP)[0].collect {|i| i.to_i}
    return local ? Time.local(*ary) : Time.gm(*ary)
@


