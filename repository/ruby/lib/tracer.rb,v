head	1.11;
access;
symbols
	v1_6_7:1.7
	v1_6_6:1.7
	v1_6_5:1.7
	v1_6_4:1.7
	v1_7_1:1.7
	v1_6_4_preview4:1.7
	v1_6_4_preview3:1.7
	v1_6_4_preview2:1.7
	v1_6_4_preview1:1.7
	v1_6_3:1.7
	ruby_m17n:1.7.0.4
	ruby_1_6:1.7.0.2
	v1_6_2:1.7
	v1_6_1:1.5
	v1_6_0:1.5
	v1_4_6:1.2
	v1_4_5:1.2
	v1_4_4:1.2
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.3
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.2.2.1
	v1_3_6_repack:1.1.1.2.2.1
	v1_3_6:1.1.1.2.2.1
	v1_3_5:1.1.1.2.2.1
	v1_2_6repack:1.1.1.1.4.4
	v1_3_4_990625:1.1.1.2.2.1
	v1_3_4_990624:1.1.1.2.2.1
	v1_2_6:1.1.1.1.4.4
	v1_3_4_990611:1.1.1.2
	v1_3_4_990531:1.1.1.2
	v1_3_3_990518:1.1.1.2
	v1_3_3_990513:1.1.1.2
	v1_3_3_990507:1.1.1.2
	v1_2_5:1.1.1.1.4.4
	v1_2_4:1.1.1.1.4.4
	v1_3_1_990225:1.1.1.2
	v1_3_1_990224:1.1.1.2
	v1_3_1_990215:1.1.1.2
	v1_3_1_990212:1.1.1.2
	v1_3_1_990210:1.1.1.2
	v1_3_1_:1.1.1.2
	v1_3_1_990209:1.1.1.2
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.4.4
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.4.4
	v1_2_1repack:1.1.1.1.4.4
	v1_2_1:1.1.1.1.4.4
	v1_2_stable:1.1.1.1.4.4
	v1_1d1:1.1.1.1.4.4
	v1_1d0:1.1.1.1.4.4
	v1_1c9_1:1.1.1.1.4.4
	v1_1c9:1.1.1.1.4.4
	v1_1c8:1.1.1.1.4.4
	v1_1c7:1.1.1.1.4.4
	v1_1c6:1.1.1.1.4.4
	v1_1d-start:1.1.1.1.4.4
	v1_1c5:1.1.1.1.4.4
	v1_1dev:1.1.1.1.4.4.0.2
	v1_1c4:1.1.1.1.4.4
	v1_1c3:1.1.1.1.4.4
	v1_1c2:1.1.1.1.4.4
	v1_1c1:1.1.1.1.4.4
	v1_1c0:1.1.1.1.4.3
	v1_1b9_31:1.1.1.1.4.3
	v1_1b9_30:1.1.1.1.4.3
	v1_1b9_28:1.1.1.1.4.3
	v1_1b9_27:1.1.1.1.4.3
	v1_1b9_26:1.1.1.1.4.3
	r1_1b9_25:1.1.1.1.4.3
	r1_1b9_24:1.1.1.1.4.3
	v1_1b9_23:1.1.1.1.4.3
	v1_1b9_22:1.1.1.1.4.3
	v1_1b9_20:1.1.1.1.4.2
	v1_1b9_18:1.1.1.1.4.2
	v1_1b9_16:1.1.1.1.4.2
	v1_1b9_15:1.1.1.1.4.2
	v1_1b9_13:1.1.1.1.4.2
	v1_1b9_12:1.1.1.1.4.2
	v1_1b9_11:1.1.1.1.4.1
	v1_1b9_08:1.1.1.1.4.1
	v1_1b9_07:1.1.1.1.4.1
	r1_1b9:1.1.1.1.4.1
	v1_1b8:1.1.1.1.4.1
	v1_1b7:1.1.1.1.4.1
	v1_1b6:1.1.1.1
	v1_1r:1.1.1.1.0.4
	v1_1:1.1.1.1
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.11
date	2002.10.02.16.45.34;	author nobu;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.28.14.42.46;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.21.09.23.26;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.29.05.07.26;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.22.03.22.22;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.11.06.29.14;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.10.04.49.21;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.28.08.27.00;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.10.15.08.52.18;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.18;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.36;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	;

1.1.1.2.2.1
date	99.06.24.04.24.08;	author matz;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	98.02.03.10.02.57;	author matz;	state Exp;
branches;
next	1.1.1.1.4.2;

1.1.1.1.4.2
date	98.04.20.05.55.38;	author matz;	state Exp;
branches;
next	1.1.1.1.4.3;

1.1.1.1.4.3
date	98.05.19.07.39.57;	author matz;	state Exp;
branches;
next	1.1.1.1.4.4;

1.1.1.1.4.4
date	98.07.24.04.42.07;	author matz;	state Exp;
branches;
next	;


desc
@@


1.11
log
@use Object#class instead of deprecated Object#type.
@
text
@#
#   tracer.rb - 
#   	$Release Version: 0.2$
#   	$Revision: 1.8 $
#   	$Date: 1998/05/19 03:42:49 $
#   	by Keiju ISHITSUKA(Nippon Rational Inc.)
#
# --
#
#   
#

#
# tracer main class
#
class Tracer
  @@RCS_ID='-$Id: tracer.rb,v 1.8 1998/05/19 03:42:49 keiju Exp keiju $-'

  @@stdout = STDOUT
  @@verbose = false
  class << self
    attr :verbose, true
    alias verbose? verbose
    attr :stdout, true
  end
  
  MY_FILE_NAME = caller(0)[0].scan(/^(.*):[0-9]+$/)[0][0]
  
  EVENT_SYMBOL = {
    "line" => "-",
    "call" => ">",
    "return" => "<",
    "class" => "C",
    "end" => "E",
    "c-call" => ">",
    "c-return" => "<",
  }
  
  def initialize
    @@threads = Hash.new
    if defined? Thread.main
      @@threads[Thread.main.id] = 0
    else
      @@threads[Thread.current.id] = 0
    end

    @@get_line_procs = {}

    @@filters = []
  end
  
  def stdout
    Tracer.stdout
  end

  def on
    if block_given?
      on
      begin
	yield
      ensure
	off
      end
    else
      set_trace_func method(:trace_func).to_proc
      stdout.print "Trace on\n" if Tracer.verbose?
    end
  end
  
  def off
    set_trace_func nil
    stdout.print "Trace off\n" if Tracer.verbose?
  end

  def add_filter(p = proc)
    @@filters.push p
  end

  def set_get_line_procs(file, p = proc)
    @@get_line_procs[file] = p
  end
  
  def get_line(file, line)
    if p = @@get_line_procs[file]
      return p.call(line)
    end

    unless list = SCRIPT_LINES__[file]
      begin
	f = open(file)
	begin 
	  SCRIPT_LINES__[file] = list = f.readlines
	ensure
	  f.close
	end
      rescue
	SCRIPT_LINES__[file] = list = []
      end
    end
    if l = list[line - 1]
      l
    else
      "-\n"
    end
  end
  
  def get_thread_no
    if no = @@threads[Thread.current.id]
      no
    else
      @@threads[Thread.current.id] = @@threads.size
    end
  end
  
  def trace_func(event, file, line, id, binding, klass, *)
    return if file == MY_FILE_NAME
    
    for p in @@filters
      return unless p.call event, file, line, id, binding, klass
    end
    
    Thread.critical = true
    stdout.printf("#%d:%s:%d:%s:%s: %s",
      get_thread_no,
      file,
      line,
      klass || '',
      EVENT_SYMBOL[event],
      get_line(file, line))
    Thread.critical = false
  end

  Single = new
  def Tracer.on
    if block_given?
      Single.on{yield}
    else
      Single.on
    end
  end
  
  def Tracer.off
    Single.off
  end
  
  def Tracer.set_get_line_procs(file_name, p = proc)
    Single.set_get_line_procs(file_name, p)
  end

  def Tracer.add_filter(p = proc)
    Single.add_filter(p)
  end
  
end

SCRIPT_LINES__ = {} unless defined? SCRIPT_LINES__

if caller(0).size == 1
  if $0 == Tracer::MY_FILE_NAME
    # direct call
    
    $0 = ARGV[0]
    ARGV.shift
    Tracer.on
    require $0
  else
    Tracer.on
  end
end
@


1.10
log
@* re.c (rb_reg_expr_str): need to process backslashes properly.

* object.c (rb_any_to_a): declare Object#to_a to be obsolete.

* object.c (rb_Array): do not convert nil into [] automagically.

* object.c (rb_Integer): use "to_int" instead of
  "to_i". [experimental]

* object.c (nil_to_f): new method.

* object.c (rb_Integer): Symbols and nil should cause error.

* object.c (rb_Float): nil should cause error.
@
text
@d65 1
a65 3
      set_trace_func proc{|event, file, line, id, binding, klass, *rest|
	trace_func event, file, line, id, binding, klass
      }
d115 1
a115 1
  def trace_func(event, file, line, id, binding, klass)
@


1.9
log
@* time.c (time_plus): result should not be negative unless
  NEGATIVE_TIME_T is defined.

* time.c (time_new_internal): should check tv_sec overflow too.

* time.c (time_timeval): should check time_t range when time is
  initialized from float.

* time.c (time_plus): uses modf(3).

* variable.c (rb_cvar_set): add frozen class/module check.

* variable.c (rb_cvar_declare): add frozen class/module check.

* re.c (match_to_a): should propagate taint.

* re.c (rb_reg_s_quote): ditto.
@
text
@d87 1
a87 1
      return p.call line
@


1.8
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* variable.c (rb_cvar_set): empty iv_tbl may cause infinite loop.

* variable.c (rb_cvar_get): ditto.

* variable.c (cvar_override_check): ditto.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.

* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.
@
text
@d90 1
a90 1
    unless list = LINES__[file]
d94 1
a94 1
	  LINES__[file] = list = f.readlines
d99 1
a99 1
	LINES__[file] = list = []
@


1.7
log
@matz
@
text
@d20 1
a25 1
  verbose = true
d158 1
a158 1
LINES__ = {} unless defined? LINES__
@


1.6
log
@matz
@
text
@d34 4
a37 1
    "end" => "E"}
d65 2
a66 2
      set_trace_func proc{|event, file, line, id, binding, klass|
	trace_func event, file, line, id, binding
a90 1
#      stdout.print file if $DEBUG
d117 1
a117 1
  def trace_func(event, file, line, id, binding)
a118 1
    #stdout.printf "Th: %s\n", Thread.current.inspect
d121 1
a121 1
      return unless p.call event, file, line, id, binding
d125 7
a131 6
    stdout.printf("#%d:%s:%d:%s: %s",
	   get_thread_no,
	   file,
	   line,
	   EVENT_SYMBOL[event],
	   get_line(file, line))
@


1.5
log
@matz
@
text
@d19 1
d23 1
d49 4
d65 1
a65 1
      print "Trace on\n" if Tracer.verbose?
d71 1
a71 1
    print "Trace off\n" if Tracer.verbose?
d88 1
a88 1
#      print file if $DEBUG
d117 1
a117 1
    #printf "Th: %s\n", Thread.current.inspect
d124 1
a124 1
    printf("#%d:%s:%d:%s: %s",
@


1.4
log
@matz
@
text
@d20 1
a20 1
    attr :verbose, TRUE
d23 1
a23 1
  verbose = TRUE
d117 1
a117 1
    Thread.critical = TRUE
d124 1
a124 1
    Thread.critical = FALSE
@


1.3
log
@-r debug, -s, etc.
@
text
@d48 1
a48 1
    if iterator?
d129 1
a129 1
    if iterator?
@


1.2
log
@1.4.0
@
text
@a42 1
    @@sources = {}
d81 1
a81 1
    unless list = @@sources[file]
d86 1
a86 1
	  @@sources[file] = list = f.readlines
d91 1
a91 1
	@@sources[file] = list = []
d149 2
@


1.1
log
@Initial revision
@
text
@d1 15
d17 9
a25 3
  MY_FILE_NAME_PATTERN = /^tracer\.(rb)?/
  Threads = Hash.new
  Sources = Hash.new
d34 14
d49 13
a61 4
    set_trace_func proc{|event, file, line, id, binding|
      trace_func event, file, line, id, binding
    }
    print "Trace on\n"
d66 9
a74 1
    print "Trace off\n"
d77 22
a98 3
  def get_thread_no
    unless no =  Threads[Thread.current.id]
      Threads[Thread.current.id] = no = Threads.size
a99 1
    no
d102 5
a106 8
  def get_line(file, line)
    unless list = Sources[file]
      f =open(file)
      begin 
	Sources[file] = list = f.readlines
      ensure
	f.close
      end
a107 1
    list[line - 1]
d111 6
a116 1
    return if File.basename(file) =~ MY_FILE_NAME_PATTERN
d130 5
a134 1
    Single.on
d141 8
d151 11
a161 7
if File.basename($0) =~ Tracer::MY_FILE_NAME_PATTERN
  $0 = ARGV.shift
  
  Tracer.on
  load $0
else
  Tracer.on
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@a0 15
#
#   tracer.rb - 
#   	$Release Version: 0.2$
#   	$Revision: 1.8 $
#   	$Date: 1998/05/19 03:42:49 $
#   	by Keiju ISHITSUKA(Nippon Rational Inc.)
#
# --
#
#   
#

#
# tracer main class
#
d2 3
a4 9
  @@RCS_ID='-$Id: tracer.rb,v 1.8 1998/05/19 03:42:49 keiju Exp keiju $-'

  class << self
    attr :verbose, TRUE
    alias verbose? verbose
  end
  verbose = TRUE
  
  MY_FILE_NAME = caller(0)[0].scan(/^(.*):[0-9]+$/)[0][0]
a12 14
  def initialize
    @@threads = Hash.new
    if defined? Thread.main
      @@threads[Thread.main.id] = 0
    else
      @@threads[Thread.current.id] = 0
    end

    @@get_line_procs = {}
    @@sources = {}

    @@filters = []
  end
  
d14 4
a17 13
    if iterator?
      on
      begin
	yield
      ensure
	off
      end
    else
      set_trace_func proc{|event, file, line, id, binding|
	trace_func event, file, line, id, binding
      }
      print "Trace on\n" if Tracer.verbose?
    end
d22 1
a22 1
    print "Trace off\n" if Tracer.verbose?
d24 6
a29 7

  def add_filter(p = proc)
    @@filters.push p
  end

  def set_get_line_procs(file, p = proc)
    @@get_line_procs[file] = p
d33 6
a38 15
    if p = @@get_line_procs[file]
      return p.call line
    end

    unless list = @@sources[file]
#      print file if $DEBUG
      begin
	f = open(file)
	begin 
	  @@sources[file] = list = f.readlines
	ensure
	  f.close
	end
      rescue
	@@sources[file] = list = []
d41 1
a41 13
    if l = list[line - 1]
      l
    else
      "-\n"
    end
  end
  
  def get_thread_no
    if no = @@threads[Thread.current.id]
      no
    else
      @@threads[Thread.current.id] = @@threads.size
    end
d45 1
a45 6
    return if file == MY_FILE_NAME
    #printf "Th: %s\n", Thread.current.inspect
    
    for p in @@filters
      return unless p.call event, file, line, id, binding
    end
d59 1
a59 5
    if iterator?
      Single.on{yield}
    else
      Single.on
    end
d66 1
a66 3
  def Tracer.set_get_line_procs(file_name, p = proc)
    Single.set_get_line_procs(file_name, p)
  end
d68 2
a69 3
  def Tracer.add_filter(p = proc)
    Single.add_filter(p)
  end
d71 4
a74 13
end

if caller(0).size == 1
  if $0 == Tracer::MY_FILE_NAME
    # direct call
    
    $0 = ARGV[0]
    ARGV.shift
    Tracer.on
    require $0
  else
    Tracer.on
  end
@


1.1.1.2.2.1
log
@990624
@
text
@d57 1
a57 1
      set_trace_func proc{|event, file, line, id, binding, klass|
@


1.1.1.1.4.1
log
@*** empty log message ***
@
text
@a0 16
#!/usr/local/bin/ruby
#
#   tracer.rb - 
#   	$Release Version: 0.2$
#   	$Revision: 1.6 $
#   	$Date: 1998/02/02 08:12:02 $
#   	by Keiju ISHITSUKA(Nippon Rational Inc.)
#
# --
#
#   
#

#
# tracer main class
#
d2 3
a4 3
  RCS_ID='-$Id: tracer.rb,v 1.6 1998/02/02 08:12:02 keiju Exp keiju $-'
  
  MY_FILE_NAME = caller(0)[0].scan(/^(.*):[0-9]+$/)[0]
a12 11
  def initialize
    @@threads = Hash.new
    if defined? Thread.main
      @@threads[Thread.main.id] = 0
    else
      @@threads[Thread.current.id] = 0
    end

    @@sources = Hash.new
  end
  
d14 4
a17 13
    if iterator?
      on
      begin
	yield
      ensure
	off
      end
    else
      set_trace_func proc{|event, file, line, id, binding|
	trace_func event, file, line, id, binding
      }
      print "Trace on\n"
    end
d25 3
a27 18
  def get_line(file, line)
    unless list = @@sources[file]
#      print file if $DEBUG
      begin
	f = open(file)
	begin 
	  @@sources[file] = list = f.readlines
	ensure
	  f.close
	end
      rescue
	@@sources[file] = list = []
      end
    end
    if l = list[line - 1]
      l
    else
      "-\n"
d29 1
d32 8
a39 5
  def get_thread_no
    if no = @@threads[Thread.current.id]
      no
    else
      @@threads[Thread.current.id] = @@threads.size
d41 1
d45 1
a45 2
    return if file == MY_FILE_NAME
    #printf "Th: %s\n", Thread.current.inspect
d68 7
a74 11
if caller(0).size == 1
  if $0 == Tracer::MY_FILE_NAME
    # direct call
    
    $0 = ARGV[0]
    ARGV.shift
    Tracer.on
    require $0
  else
    Tracer.on
  end
@


1.1.1.1.4.2
log
@*** empty log message ***
@
text
@d1 1
d5 2
a6 2
#   	$Revision: 1.1.1.1.4.1 $
#   	$Date: 1998/02/03 10:02:57 $
d18 1
a18 1
  RCS_ID='-$Id: tracer.rb,v 1.1.1.1.4.1 1998/02/03 10:02:57 matz Exp $-'
@


1.1.1.1.4.3
log
@1.1b9_22
@
text
@a0 1
#!/usr/local/bin/ruby
d4 2
a5 2
#   	$Revision: 1.8 $
#   	$Date: 1998/05/19 03:42:49 $
d17 1
a17 7
  @@RCS_ID='-$Id: tracer.rb,v 1.8 1998/05/19 03:42:49 keiju Exp keiju $-'

  class << self
    attr :verbose, TRUE
    alias verbose? verbose
  end
  verbose = TRUE
d19 1
a19 1
  MY_FILE_NAME = caller(0)[0].scan(/^(.*):[0-9]+$/)[0][0]
d36 1
a36 4
    @@get_line_procs = {}
    @@sources = {}

    @@filters = []
d51 1
a51 1
      print "Trace on\n" if Tracer.verbose?
d57 1
a57 9
    print "Trace off\n" if Tracer.verbose?
  end

  def add_filter(p = proc)
    @@filters.push p
  end

  def set_get_line_procs(file, p = proc)
    @@get_line_procs[file] = p
a60 4
    if p = @@get_line_procs[file]
      return p.call line
    end

a92 4
    for p in @@filters
      return unless p.call event, file, line, id, binding
    end
    
d105 1
a105 5
    if iterator?
      Single.on{yield}
    else
      Single.on
    end
a109 8
  end
  
  def Tracer.set_get_line_procs(file_name, p = proc)
    Single.set_get_line_procs(file_name, p)
  end

  def Tracer.add_filter(p = proc)
    Single.add_filter(p)
@


1.1.1.1.4.4
log
@1.1c1
@
text
@d1 1
@
