head	1.3;
access;
symbols
	v1_6_7:1.2.4.1
	v1_6_6:1.2.4.1
	v1_6_5:1.2.4.1
	v1_6_4:1.2
	v1_7_1:1.3
	v1_6_4_preview4:1.2
	v1_6_4_preview3:1.2
	v1_6_4_preview2:1.2
	v1_6_4_preview1:1.2
	v1_6_3:1.2
	ruby_m17n:1.2.0.6
	ruby_1_6:1.2.0.4
	v1_6_2:1.2
	v1_6_1:1.2
	v1_6_0:1.2
	v1_4_6:1.2
	v1_4_5:1.2
	v1_4_4:1.2
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.2
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.2.2.1
	v1_3_6_repack:1.1.1.2.2.1
	v1_3_6:1.1.1.2.2.1
	v1_3_5:1.1.1.2
	v1_2_6repack:1.1.1.1.4.2
	v1_3_4_990625:1.1.1.2
	v1_3_4_990624:1.1.1.2
	v1_2_6:1.1.1.1.4.2
	v1_3_4_990611:1.1.1.2
	v1_3_4_990531:1.1.1.2
	v1_3_3_990518:1.1.1.2
	v1_3_3_990513:1.1.1.2
	v1_3_3_990507:1.1.1.2
	v1_2_5:1.1.1.1.4.2
	v1_2_4:1.1.1.1.4.2
	v1_3_1_990225:1.1.1.2
	v1_3_1_990224:1.1.1.2
	v1_3_1_990215:1.1.1.2
	v1_3_1_990212:1.1.1.2
	v1_3_1_990210:1.1.1.2
	v1_3_1_:1.1.1.2
	v1_3_1_990209:1.1.1.2
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.4.2
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.4.2
	v1_2_1repack:1.1.1.1.4.2
	v1_2_1:1.1.1.1.4.2
	v1_2_stable:1.1.1.1.4.2
	v1_1d1:1.1.1.1.4.2
	v1_1d0:1.1.1.1.4.2
	v1_1c9_1:1.1.1.1.4.2
	v1_1c9:1.1.1.1.4.2
	v1_1c8:1.1.1.1.4.2
	v1_1c7:1.1.1.1.4.2
	v1_1c6:1.1.1.1.4.2
	v1_1d-start:1.1.1.1.4.2
	v1_1c5:1.1.1.1.4.2
	v1_1dev:1.1.1.1.4.2.0.2
	v1_1c4:1.1.1.1.4.2
	v1_1c3:1.1.1.1.4.2
	v1_1c2:1.1.1.1.4.2
	v1_1c1:1.1.1.1.4.2
	v1_1c0:1.1.1.1.4.2
	v1_1b9_31:1.1.1.1.4.2
	v1_1b9_30:1.1.1.1.4.2
	v1_1b9_28:1.1.1.1.4.2
	v1_1b9_27:1.1.1.1.4.2
	v1_1b9_26:1.1.1.1.4.2
	r1_1b9_25:1.1.1.1.4.2
	r1_1b9_24:1.1.1.1.4.2
	v1_1b9_23:1.1.1.1.4.2
	v1_1b9_22:1.1.1.1.4.2
	v1_1b9_20:1.1.1.1.4.2
	v1_1b9_18:1.1.1.1.4.2
	v1_1b9_16:1.1.1.1.4.2
	v1_1b9_15:1.1.1.1.4.2
	v1_1b9_13:1.1.1.1.4.2
	v1_1b9_12:1.1.1.1.4.2
	v1_1b9_11:1.1.1.1.4.2
	v1_1b9_08:1.1.1.1.4.2
	v1_1b9_07:1.1.1.1.4.2
	r1_1b9:1.1.1.1.4.1
	v1_1b8:1.1.1.1.4.1
	v1_1b7:1.1.1.1.4.1
	v1_1b6:1.1.1.1.4.1
	v1_1r:1.1.1.1.0.4
	v1_1:1.1.1.1
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2001.05.06.15.04.52;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.16;	author matz;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.07;	author matz;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.35;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	;

1.1.1.2.2.1
date	99.07.22.10.37.25;	author matz;	state Exp;
branches;
next	;

1.1.1.1.4.1
date	98.01.16.12.36.05;	author matz;	state Exp;
branches;
next	1.1.1.1.4.2;

1.1.1.1.4.2
date	98.03.05.06.37.50;	author matz;	state Exp;
branches;
next	;

1.2.4.1
date	2001.07.03.15.10.42;	author knu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@forgot some checkins.
@
text
@#
#   mathn.rb - 
#   	$Release Version: 0.5 $
#   	$Revision: 1.1.1.1.4.1 $
#   	$Date: 1998/01/16 12:36:05 $
#   	by Keiju ISHITSUKA(SHL Japan Inc.)
#
# --
#
#   
#

require "rational.rb"
require "complex.rb"
require "matrix.rb"

class Integer

  def gcd2(int)
    a = self.abs
    b = int.abs
    a, b = b, a if a < b
    
    pd_a = a.prime_division
    pd_b = b.prime_division
    
    gcd = 1
    for pair in pd_a
      as = pd_b.assoc(pair[0])
      if as
	gcd *= as[0] ** [as[1], pair[1]].min
      end
    end
    return gcd
  end
  
  def Integer.from_prime_division(pd)
    value = 1
    for prime, index in pd
      value *= prime**index
    end
    value
  end
  
  def prime_division
    ps = Prime.new
    value = self
    pv = []
    for prime in ps
      count = 0
      while (value1, mod = value.divmod(prime)
	     mod) == 0
	value = value1
	count += 1
      end
      if count != 0
	pv.push [prime, count]
      end
      break if prime * prime  >= value
    end
    if value > 1
      pv.push [value, 1]
    end
    return pv
  end
end
  
class Prime
  include Enumerable

  def initialize
    @@seed = 1
    @@primes = []
    @@counts = []
  end
  
  def succ
    i = -1
    size = @@primes.size
    while i < size
      if i == -1
	@@seed += 1
	i += 1
      else
	while @@seed > @@counts[i]
	  @@counts[i] += @@primes[i]
	end
	if @@seed != @@counts[i]
	  i += 1
	else
	  i = -1
	end
      end
    end
    @@primes.push @@seed
    @@counts.push @@seed + @@seed
    return @@seed
  end
  alias next succ

  def each
    loop do
      yield succ
    end
  end
end

class Fixnum
  alias divmod! divmod
  alias / rdiv
  def divmod(other)
    a = self.div(other)
    b = self % other
    return a,b
  end
end

class Bignum
  alias divmod! divmod
  alias / rdiv
end

class Rational
  Unify = true

  def inspect
    format "%s/%s", @@numerator.inspect, @@denominator.inspect
  end

  alias power! **

  def ** (other)
    if other.kind_of?(Rational)
      if self < 0
	return Complex(self, 0) ** other
      elsif other == 0
	return Rational(1,1)
      elsif self == 0
	return Rational(0,1)
      elsif self == 1
	return Rational(1,1)
      end
      
      npd = @@numerator.prime_division
      dpd = @@denominator.prime_division
      if other < 0
	other = -other
	npd, dpd = dpd, npd
      end
      
      for elm in npd
	elm[1] = elm[1] * other
	if !elm[1].kind_of?(Integer) and elm[1].denominator != 1
	  return Float(self) ** other
	end
	elm[1] = elm[1].to_i
      end
      
      for elm in dpd
	elm[1] = elm[1] * other
	if !elm[1].kind_of?(Integer) and elm[1].denominator != 1
	  return Float(self) ** other
	end
	elm[1] = elm[1].to_i
      end
      
      num = Integer.from_prime_division(npd)
      den = Integer.from_prime_division(dpd)
      
      Rational(num,den)
      
    elsif other.kind_of?(Integer)
      if other > 0
	num = @@numerator ** other
	den = @@denominator ** other
      elsif other < 0
	num = @@denominator ** -other
	den = @@numerator ** -other
      elsif other == 0
	num = 1
	den = 1
      end
      Rational.new!(num, den)
    elsif other.kind_of?(Float)
      Float(self) ** other
    else
      x , y = other.coerce(self)
      x ** y
    end
  end

  def power2(other)
    if other.kind_of?(Rational)
      if self < 0
	return Complex(self, 0) ** other
      elsif other == 0
	return Rational(1,1)
      elsif self == 0
	return Rational(0,1)
      elsif self == 1
	return Rational(1,1)
      end
      
      dem = nil
      x = self.denominator.to_f.to_i
      neard = self.denominator.to_f ** (1.0/other.denominator.to_f)
      loop do
	if (neard**other.denominator == self.denominator)
	  dem = neaed
	  break
	end
      end
      nearn = self.numerator.to_f ** (1.0/other.denominator.to_f)
      Rational(num,den)
      
    elsif other.kind_of?(Integer)
      if other > 0
	num = @@numerator ** other
	den = @@denominator ** other
      elsif other < 0
	num = @@denominator ** -other
	den = @@numerator ** -other
      elsif other == 0
	num = 1
	den = 1
      end
      Rational.new!(num, den)
    elsif other.kind_of?(Float)
      Float(self) ** other
    else
      x , y = other.coerce(self)
      x ** y
    end
  end
end

module Math
  def sqrt(a)
    if a.kind_of?(Complex)
      abs = sqrt(a.real*a.real + a.image*a.image)
#      if not abs.kind_of?(Rational)
#	return a**Rational(1,2)
#      end
      x = sqrt((a.real + abs)/Rational(2))
      y = sqrt((-a.real + abs)/Rational(2))
#      if !(x.kind_of?(Rational) and y.kind_of?(Rational))
#	return a**Rational(1,2)
#      end
      if a.image >= 0 
	Complex(x, y)
      else
	Complex(x, -y)
      end
    elsif a >= 0
      rsqrt(a)
    else
      Complex(0,rsqrt(-a))
    end
  end
  
  def rsqrt(a)
    if a.kind_of?(Float)
      sqrt!(a)
    elsif a.kind_of?(Rational)
      rsqrt(a.numerator)/rsqrt(a.denominator)
    else
      src = a
      max = 2 ** 32
      byte_a = [src & 0xffffffff]
      # ruby's bug
      while (src >= max) and (src >>= 32)
	byte_a.unshift src & 0xffffffff
      end
      
      answer = 0
      main = 0
      side = 0
      for elm in byte_a
	main = (main << 32) + elm
	side <<= 16
	if answer != 0
	  if main * 4  < side * side
	    applo = main.div(side)
	  else 
	    applo = ((sqrt!(side * side + 4 * main) - side)/2.0).to_i + 1
	  end
	else
	  applo = sqrt!(main).to_i + 1
	end
	
	while (x = (side + applo) * applo) > main
	  applo -= 1
	end
	main -= x
	answer = (answer << 16) + applo
	side += applo * 2
      end
      if main == 0
	answer
      else
	sqrt!(a)
      end
    end
  end

  module_function :sqrt
  module_function :rsqrt
end

class Complex
  Unify = true
end

@


1.2
log
@1.4.0
@
text
@d125 5
a129 1
  
@


1.2.4.1
log
@* lib/mathn.rb: merge from 1.7: add Rational#inspect().
@
text
@d125 1
a125 5

  def inspect
    format "%s/%s", @@numerator.inspect, @@denominator.inspect
  end

@


1.1
log
@Initial revision
@
text
@d4 2
a5 2
#   	$Revision: 1.1 $
#   	$Date: 1997/07/03 04:43:47 $
d99 1
d124 1
a124 1
  Unify = TRUE
d307 1
a307 1
  Unify = TRUE
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.1.4.1 $
#   	$Date: 1998/01/16 12:36:05 $
a98 1
  alias next succ
@


1.1.1.2.2.1
log
@backtrace may be Qnil
@
text
@d124 1
a124 1
  Unify = true
d307 1
a307 1
  Unify = true
@


1.1.1.1.4.1
log
@*** empty log message ***
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.1 $
#   	$Date: 1998/01/16 04:05:49 $
@


1.1.1.1.4.2
log
@block arg etc.
@
text
@d4 2
a5 2
#   	$Revision: 1.1.1.1.4.1 $
#   	$Date: 1998/01/16 12:36:05 $
a98 1
  alias next succ
@
