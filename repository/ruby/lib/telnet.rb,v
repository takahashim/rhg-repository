head	1.8;
access;
symbols
	v1_6_7:1.8
	v1_6_6:1.8
	v1_6_5:1.8
	v1_6_4:1.8
	v1_7_1:1.8
	v1_6_4_preview4:1.8
	v1_6_4_preview3:1.8
	v1_6_4_preview2:1.8
	v1_6_4_preview1:1.8
	v1_6_3:1.8
	ruby_m17n:1.8.0.4
	ruby_1_6:1.8.0.2
	v1_6_2:1.8
	v1_6_1:1.8
	v1_6_0:1.8
	v1_4_6:1.6.2.2
	v1_4_5:1.6.2.2
	v1_4_4:1.6.2.1
	ruby_1_4_3:1.6
	ruby1_4_3:1.6
	v1_4_3:1.6
	v1_5_0:1.6
	ruby_1_4_3_pre1:1.6
	ruby_1_4:1.6.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.8
	v1_3_6_repack:1.1.1.1.2.8
	v1_3_6:1.1.1.1.2.8
	v1_3_5:1.1.1.1.2.7
	v1_2_6repack:1.1.2.12
	v1_3_4_990625:1.1.1.1.2.6
	v1_3_4_990624:1.1.1.1.2.6
	v1_2_6:1.1.2.12
	v1_3_4_990611:1.1.1.1.2.6
	v1_3_4_990531:1.1.1.1.2.5
	v1_3_3_990518:1.1.1.1.2.5
	v1_3_3_990513:1.1.1.1.2.5
	v1_3_3_990507:1.1.1.1.2.5
	v1_2_5:1.1.2.10
	v1_2_4:1.1.2.9
	v1_3_1_990225:1.1.1.1.2.2
	v1_3_1_990224:1.1.1.1.2.2
	v1_3_1_990215:1.1.1.1.2.2
	v1_3_1_990212:1.1.1.1.2.2
	v1_3_1_990210:1.1.1.1.2.2
	v1_3_1_:1.1.1.1.2.2
	v1_3_1_990209:1.1.1.1.2.2
	v1_3_1_990205:1.1.1.1.2.2
	v1_3_1_990203:1.1.1.1.2.1
	v1_3_1_990201:1.1.1.1
	v1_3_1"_990201:1.1.1.1
	v1_3_1_990128:1.1.1.1
	v1_3_1_990127:1.1.1.1
	v1_3_1_990126:1.1.1.1
	ruby_1_3:1.1.1.1.0.2
	v1_2_2:1.1.2.9
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_2_2_pr1:1.1.2.9
	v1_2_1repack:1.1.2.9
	v1_2_1:1.1.2.9
	v1_2_stable:1.1.2.9
	v1_1d1:1.1.2.7.2.2
	v1_1d0:1.1.2.7.2.2
	v1_1c9_1:1.1.2.9
	v1_1c9:1.1.2.9
	v1_1c8:1.1.2.9
	v1_1c7:1.1.2.9
	v1_1c6:1.1.2.8
	v1_1d-start:1.1.2.7
	v1_1c5:1.1.2.7
	v1_1dev:1.1.2.7.0.2
	v1_1c4:1.1.2.7
	v1_1c3:1.1.2.6
	v1_1c2:1.1.2.5
	v1_1c1:1.1.2.4
	v1_1c0:1.1.2.4
	v1_1b9_31:1.1.2.4
	v1_1b9_30:1.1.2.4
	v1_1b9_28:1.1.2.3
	v1_1b9_27:1.1.2.3
	v1_1b9_26:1.1.2.3
	r1_1b9_25:1.1.2.3
	r1_1b9_24:1.1.2.3
	v1_1b9_23:1.1.2.3
	v1_1b9_22:1.1.2.3
	v1_1b9_20:1.1.2.3
	v1_1b9_18:1.1.2.3
	v1_1b9_16:1.1.2.3
	v1_1b9_15:1.1.2.2
	v1_1r:1.1.0.2;
locks; strict;
comment	@# @;
expand	@o@;


1.8
date	2000.05.01.09.41.38;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.08.08.49.00;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.10.12.04.53.35;	author matz;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.22.04.30.11;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.09.18.04.48.51;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.09.16.09.40.33;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.18;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.04.22.09.01.12;	author matz;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	99.01.20.04.59.35;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.02.03.09.48.00;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.02.05.10.27.34;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.03.24.08.52.35;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.04.16.06.03.35;	author matz;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.04.30.07.55.47;	author matz;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	99.06.09.09.21.36;	author matz;	state Exp;
branches;
next	1.1.1.1.2.7;

1.1.1.1.2.7
date	99.07.15.07.59.59;	author matz;	state Exp;
branches;
next	1.1.1.1.2.8;

1.1.1.1.2.8
date	99.07.22.10.37.26;	author matz;	state Exp;
branches;
next	1.1.1.1.2.9;

1.1.1.1.2.9
date	99.08.11.07.24.11;	author matz;	state Exp;
branches;
next	;

1.1.2.1
date	98.04.22.09.01.12;	author matz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	98.04.22.09.01.41;	author matz;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	98.04.27.10.04.10;	author matz;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	98.07.09.08.40.38;	author matz;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	98.08.10.05.41.24;	author matz;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	98.08.27.03.55.49;	author matz;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	98.09.03.07.43.52;	author matz;	state Exp;
branches
	1.1.2.7.2.1;
next	1.1.2.8;

1.1.2.8
date	98.10.06.02.45.14;	author matz;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	98.11.09.09.11.52;	author matz;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	99.04.09.18.04.08;	author matz;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	99.04.20.08.20.56;	author matz;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	99.05.14.08.56.50;	author matz;	state Exp;
branches;
next	;

1.1.2.7.2.1
date	98.10.06.03.28.26;	author matz;	state Exp;
branches;
next	1.1.2.7.2.2;

1.1.2.7.2.2
date	98.11.25.03.31.18;	author matz;	state Exp;
branches;
next	;

1.6.2.1
date	2000.02.08.08.54.01;	author matz;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.04.14.14.35.48;	author matz;	state Exp;
branches;
next	;


desc
@@


1.8
log
@2000-05-01
@
text
@#
# telnet.rb
#

$stderr.puts 'Warning: telnet.rb is obsolete: use net/telnet'

require 'net/telnet'

Telnet = ::Net::Telnet
@


1.7
log
@2000-02-08
@
text
@d1 3
a3 2
=begin
$Date: 2000/01/24 17:02:57 $
d5 1
a5 1
== SIMPLE TELNET CLIENT LIBRARY
d7 1
a7 1
telnet.rb
d9 1
a9 732
Version 1.20

Wakou Aoyama <wakou@@fsinet.or.jp>


=== MAKE NEW TELNET OBJECT

	host = Telnet.new({"Binmode" => false,           # default: false
	                   "Host" => "localhost",        # default: "localhost"
	                   "Output_log" => "output_log", # default: not output
	                   "Dump_log" => "dump_log",     # default: not output
	                   "Port" => 23,                 # default: 23
	                   "Prompt" => /[$%#>] \z/n,     # default: /[$%#>] \z/n
	                   "Telnetmode" => true,         # default: true
	                   "Timeout" => 10,              # default: 10
	                     # if ignore timeout then set "Timeout" to false.
	                   "Waittime" => 0,              # default: 0
	                   "Proxy" => proxy})            # default: nil
                                    # proxy is Telnet or TCPsocket object

Telnet object has socket class methods.

if set "Telnetmode" option to false. not telnet command interpretation.
"Waittime" is time to confirm "Prompt". There is a possibility that
the same character as "Prompt" is included in the data, and, when
the network or the host is very heavy, the value is enlarged.

=== STATUS OUTPUT

	host = Telnet.new({"Host" => "localhost"}){|c| print c }

connection status output.

example

	Trying localhost...
	Connected to localhost.


=== WAIT FOR MATCH

	line = host.waitfor(/match/)
	line = host.waitfor({"Match"   => /match/,
	                     "String"  => "string",
	                     "Timeout" => secs})
	                       # if ignore timeout then set "Timeout" to false.

if set "String" option, then Match == Regexp.new(quote("string"))


==== REALTIME OUTPUT

	host.waitfor(/match/){|c| print c }
	host.waitfor({"Match"   => /match/,
	              "String"  => "string",
	              "Timeout" => secs}){|c| print c}

of cource, set sync=true or flush is necessary.


=== SEND STRING AND WAIT PROMPT

	line = host.cmd("string")
	line = host.cmd({"String" => "string",
	                 "Prompt" => /[$%#>] \z/n,
	                 "Timeout" => 10})


==== REALTIME OUTPUT

	host.cmd("string"){|c| print c }
	host.cmd({"String" => "string",
	          "Prompt" => /[$%#>] \z/n,
	          "Timeout" => 10}){|c| print c }

of cource, set sync=true or flush is necessary.


=== SEND STRING

	host.print("string")
	  # == host.write("string\n")


=== TURN TELNET COMMAND INTERPRETATION

	host.telnetmode        # turn on/off
	host.telnetmode(true)  # on
	host.telnetmode(false) # off


=== TOGGLE NEWLINE TRANSLATION

	host.binmode        # turn true/false
	host.binmode(true)  # no translate newline
	host.binmode(false) # translate newline


=== LOGIN

	host.login("username", "password")
	host.login({"Name" => "username",
	            "Password" => "password",
	            "Prompt" => /[$%#>] \z/n,
	            "Timeout" => 10})

if no password prompt.

	host.login("username")
	host.login({"Name" => "username",
	            "Prompt" => /[$%#>] \z/n,
	            "Timeout" => 10})


==== REALTIME OUTPUT

	host.login("username", "password"){|c| print c }
	host.login({"Name" => "username",
	            "Password" => "password",
	            "Prompt" => /[$%#>] \z/n,
	            "Timeout" => 10}){|c| print c }

of cource, set sync=true or flush is necessary.


== EXAMPLE

=== LOGIN AND SEND COMMAND

	localhost = Telnet.new({"Host" => "localhost",
	                        "Timeout" => 10,
	                        "Prompt" => /[$%#>] \z/n})
	localhost.login("username", "password"){|c| print c }
	localhost.cmd("command"){|c| print c }
	localhost.close


=== CHECKS A POP SERVER TO SEE IF YOU HAVE MAIL

	pop = Telnet.new({"Host" => "your_destination_host_here",
	                  "Port" => 110,
	                  "Telnetmode" => false,
	                  "Prompt" => /^\+OK/n})
	pop.cmd("user " + "your_username_here"){|c| print c}
	pop.cmd("pass " + "your_password_here"){|c| print c}
	pop.cmd("list"){|c| print c}


== HISTORY

=== Version 1.20

2000/01/24 17:02:57

- respond to "IAC WILL x" with "IAC DONT x"
- respond to "IAC WONT x" with "IAC DONT x"
- better dumplog format
  thanks to WATANABE Hirofumi <Hirofumi.Watanabe@@jp.sony.com>

=== Version 1.10

2000/01/18 17:47:31

- bug fix: write method
- respond to "IAC WILL BINARY" with "IAC DO BINARY"

=== Version 1.00

1999/10/04 22:51:26

- bug fix: waitfor(preprocess) method
  thanks to Shin-ichiro Hara <sinara@@blade.nagaokaut.ac.jp>
- add simple support for AO, DM, IP, NOP, SB, SE
- COUTION! TimeOut --> TimeoutError

=== Version 0.50

1999/09/21 21:24:07

- add write method

=== Version 0.40

1999/09/17 17:41:41

- bug fix: preprocess method

=== Version 0.30

1999/09/14 23:09:05

- change prompt check order.
	not IO::select([@@sock], nil, nil, waittime) and prompt === line
	--> prompt === line and not IO::select([@@sock], nil, nil, waittime)

=== Version 0.24

1999/09/13 22:28:33

- Telnet#login
if ommit password, then not require password prompt.

=== Version 0.232

1999/08/10 05:20:21

- STATUS OUTPUT sample code typo. thanks to Tadayoshi Funaba <tadf@@kt.rim.or.jp>
	host = Telnet.new({"Hosh" => "localhost"){|c| print c }
	--> host = Telnet.new({"Host" => "localhost"){|c| print c }

=== Version 0.231

1999/07/16 13:39:42

- TRUE --> true, FALSE --> false

=== Version 0.23

1999/07/15 22:32:09

- waitfor: if end of file reached, then return nil.

=== Version 0.22

1999/06/29 09:08:51

- new, waitfor, cmd: {"Timeout" => false}  # ignore timeout

=== Version 0.21

1999/06/28 18:18:55

- waitfor: not rescue (EOFError)

=== Version 0.20

1999/06/04 06:24:58

- waitfor: support for divided telnet command

=== Version 0.181

1999/05/22

- bug fix: print method

=== Version 0.18

1999/05/14

- respond to "IAC WON'T SGA" with "IAC DON'T SGA"
- DON'T SGA : end of line --> CR + LF
- bug fix: preprocess method

=== Version 0.17

1999/04/30

- bug fix: $! + "\n"  -->  $!.to_s + "\n"

=== Version 0.163

1999/04/11

- STDOUT.write(message) --> yield(message) if iterator?

=== Version 0.162

1999/03/17

- add "Proxy" option
- required timeout.rb

=== Version 0.161

1999/02/03

- select --> IO::select

=== Version 0.16

1998/10/09

- preprocess method change for the better
- add binmode method.
- change default Binmode. TRUE --> FALSE

=== Version 0.15

1998/10/04

- add telnetmode method.

=== Version 0.141

1998/09/22

- change default prompt. /[$%#>] $/ --> /[$%#>] \Z/

=== Version 0.14

1998/09/01

- IAC WILL SGA             send EOL --> CR+NULL
- IAC WILL SGA IAC DO BIN  send EOL --> CR
- NONE                     send EOL --> LF
- add Dump_log option.

=== Version 0.13

1998/08/25

- add print method.

=== Version 0.122

1998/08/05

- support for HP-UX 10.20    thanks to WATANABE Tetsuya <tetsu@@jpn.hp.com>
- socket.<< --> socket.write

=== Version 0.121

1998/07/15

- string.+= --> string.concat

=== Version 0.12

1998/06/01

- add timeout, waittime.

=== Version 0.11

1998/04/21

- add realtime output.

=== Version 0.10

1998/04/13

- first release.

=end

require "socket"
require "delegate"
require "timeout"

class Telnet < SimpleDelegator

  IAC   = 255.chr # "\377" # "\xff" # interpret as command:
  DONT  = 254.chr # "\376" # "\xfe" # you are not to use option
  DO    = 253.chr # "\375" # "\xfd" # please, you use option
  WONT  = 252.chr # "\374" # "\xfc" # I won't use option
  WILL  = 251.chr # "\373" # "\xfb" # I will use option
  SB    = 250.chr # "\372" # "\xfa" # interpret as subnegotiation
  GA    = 249.chr # "\371" # "\xf9" # you may reverse the line
  EL    = 248.chr # "\370" # "\xf8" # erase the current line
  EC    = 247.chr # "\367" # "\xf7" # erase the current character
  AYT   = 246.chr # "\366" # "\xf6" # are you there
  AO    = 245.chr # "\365" # "\xf5" # abort output--but let prog finish
  IP    = 244.chr # "\364" # "\xf4" # interrupt process--permanently
  BREAK = 243.chr # "\363" # "\xf3" # break
  DM    = 242.chr # "\362" # "\xf2" # data mark--for connect. cleaning
  NOP   = 241.chr # "\361" # "\xf1" # nop
  SE    = 240.chr # "\360" # "\xf0" # end sub negotiation
  EOR   = 239.chr # "\357" # "\xef" # end of record (transparent mode)
  ABORT = 238.chr # "\356" # "\xee" # Abort process
  SUSP  = 237.chr # "\355" # "\xed" # Suspend process
  EOF   = 236.chr # "\354" # "\xec" # End of file
  SYNCH = 242.chr # "\362" # "\xf2" # for telfunc calls

  OPT_BINARY         =   0.chr # "\000" # "\x00" # Binary Transmission
  OPT_ECHO           =   1.chr # "\001" # "\x01" # Echo
  OPT_RCP            =   2.chr # "\002" # "\x02" # Reconnection
  OPT_SGA            =   3.chr # "\003" # "\x03" # Suppress Go Ahead
  OPT_NAMS           =   4.chr # "\004" # "\x04" # Approx Message Size Negotiation
  OPT_STATUS         =   5.chr # "\005" # "\x05" # Status
  OPT_TM             =   6.chr # "\006" # "\x06" # Timing Mark
  OPT_RCTE           =   7.chr # "\a"   # "\x07" # Remote Controlled Trans and Echo
  OPT_NAOL           =   8.chr # "\010" # "\x08" # Output Line Width
  OPT_NAOP           =   9.chr # "\t"   # "\x09" # Output Page Size
  OPT_NAOCRD         =  10.chr # "\n"   # "\x0a" # Output Carriage-Return Disposition
  OPT_NAOHTS         =  11.chr # "\v"   # "\x0b" # Output Horizontal Tab Stops
  OPT_NAOHTD         =  12.chr # "\f"   # "\x0c" # Output Horizontal Tab Disposition
  OPT_NAOFFD         =  13.chr # "\r"   # "\x0d" # Output Formfeed Disposition
  OPT_NAOVTS         =  14.chr # "\016" # "\x0e" # Output Vertical Tabstops
  OPT_NAOVTD         =  15.chr # "\017" # "\x0f" # Output Vertical Tab Disposition
  OPT_NAOLFD         =  16.chr # "\020" # "\x10" # Output Linefeed Disposition
  OPT_XASCII         =  17.chr # "\021" # "\x11" # Extended ASCII
  OPT_LOGOUT         =  18.chr # "\022" # "\x12" # Logout
  OPT_BM             =  19.chr # "\023" # "\x13" # Byte Macro
  OPT_DET            =  20.chr # "\024" # "\x14" # Data Entry Terminal
  OPT_SUPDUP         =  21.chr # "\025" # "\x15" # SUPDUP
  OPT_SUPDUPOUTPUT   =  22.chr # "\026" # "\x16" # SUPDUP Output
  OPT_SNDLOC         =  23.chr # "\027" # "\x17" # Send Location
  OPT_TTYPE          =  24.chr # "\030" # "\x18" # Terminal Type
  OPT_EOR            =  25.chr # "\031" # "\x19" # End of Record
  OPT_TUID           =  26.chr # "\032" # "\x1a" # TACACS User Identification
  OPT_OUTMRK         =  27.chr # "\e"   # "\x1b" # Output Marking
  OPT_TTYLOC         =  28.chr # "\034" # "\x1c" # Terminal Location Number
  OPT_3270REGIME     =  29.chr # "\035" # "\x1d" # Telnet 3270 Regime
  OPT_X3PAD          =  30.chr # "\036" # "\x1e" # X.3 PAD
  OPT_NAWS           =  31.chr # "\037" # "\x1f" # Negotiate About Window Size
  OPT_TSPEED         =  32.chr # " "    # "\x20" # Terminal Speed
  OPT_LFLOW          =  33.chr # "!"    # "\x21" # Remote Flow Control
  OPT_LINEMODE       =  34.chr # "\""   # "\x22" # Linemode
  OPT_XDISPLOC       =  35.chr # "#"    # "\x23" # X Display Location
  OPT_OLD_ENVIRON    =  36.chr # "$"    # "\x24" # Environment Option
  OPT_AUTHENTICATION =  37.chr # "%"    # "\x25" # Authentication Option
  OPT_ENCRYPT        =  38.chr # "&"    # "\x26" # Encryption Option
  OPT_NEW_ENVIRON    =  39.chr # "'"    # "\x27" # New Environment Option
  OPT_EXOPL          = 255.chr # "\377" # "\xff" # Extended-Options-List

  NULL = "\000"
  CR   = "\015"
  LF   = "\012"
  EOL  = CR + LF
v = $-v
$-v = false
  VERSION = "1.20"
  RELEASE_DATE = "$Date: 2000/01/24 17:02:57 $"
$-v = v

  def initialize(options)
    @@options = options
    @@options["Binmode"]    = false         unless @@options.has_key?("Binmode")
    @@options["Host"]       = "localhost"   unless @@options.has_key?("Host")
    @@options["Port"]       = 23            unless @@options.has_key?("Port")
    @@options["Prompt"]     = /[$%#>] \z/n  unless @@options.has_key?("Prompt")
    @@options["Telnetmode"] = true          unless @@options.has_key?("Telnetmode")
    @@options["Timeout"]    = 10            unless @@options.has_key?("Timeout")
    @@options["Waittime"]   = 0             unless @@options.has_key?("Waittime")

    @@telnet_option = { "SGA" => false, "BINARY" => false }

    if @@options.has_key?("Output_log")
      @@log = File.open(@@options["Output_log"], 'a+')
      @@log.sync = true
      @@log.binmode
    end

    if @@options.has_key?("Dump_log")
      @@dumplog = File.open(@@options["Dump_log"], 'a+')
      @@dumplog.sync = true
      @@dumplog.binmode
      def @@dumplog.log_dump(dir, x)
        len = x.length
        addr = 0
        offset = 0
        while 0 < len
          if len < 16
            line = x[offset, len]
          else
            line = x[offset, 16]
          end
          hexvals = line.unpack('H*')[0]
          hexvals.concat ' ' * (32 - hexvals.length)
          hexvals = format "%s %s %s %s  " * 4, *hexvals.unpack('a2' * 16)
          line.gsub! /[\000-\037\177-\377]/n, '.'
          printf "%s 0x%5.5x: %s%s\n", dir, addr, hexvals, line
          addr += 16
          offset += 16
          len -= 16
        end
        print "\n"
      end
    end

    if @@options.has_key?("Proxy")
      if @@options["Proxy"].kind_of?(Telnet)
        @@sock = @@options["Proxy"].sock
      elsif @@options["Proxy"].kind_of?(TCPsocket)
        @@sock = @@options["Proxy"]
      else
        raise "Error; Proxy is Telnet or TCPSocket object."
      end
    else
      message = "Trying " + @@options["Host"] + "...\n"
      yield(message) if iterator?
      @@log.write(message) if @@options.has_key?("Output_log")
      @@dumplog.log_dump('#', message) if @@options.has_key?("Dump_log")

      begin
        if @@options["Timeout"] == false
          @@sock = TCPsocket.open(@@options["Host"], @@options["Port"])
        else
          timeout(@@options["Timeout"]){
            @@sock = TCPsocket.open(@@options["Host"], @@options["Port"])
          }
        end
      rescue TimeoutError
        raise TimeoutError, "timed-out; opening of the host"
      rescue
        @@log.write($!.to_s + "\n") if @@options.has_key?("Output_log")
        @@dumplog.log_dump('#', $!.to_s + "\n") if @@options.has_key?("Dump_log")
        raise
      end
      @@sock.sync = true
      @@sock.binmode

      message = "Connected to " + @@options["Host"] + ".\n"
      yield(message) if iterator?
      @@log.write(message) if @@options.has_key?("Output_log")
      @@dumplog.log_dump('#', message) if @@options.has_key?("Dump_log")
    end

    super(@@sock)
  end # initialize

  attr :sock

  def telnetmode(mode = 'turn')
    if 'turn' == mode
      @@options["Telnetmode"] = @@options["Telnetmode"] ? false : true
    else
      @@options["Telnetmode"] = mode ? true : false
    end
  end

  def binmode(mode = 'turn')
    if 'turn' == mode
      @@options["Binmode"] = @@options["Binmode"] ? false : true
    else
      @@options["Binmode"] = mode ? true : false
    end
  end

  def preprocess(string)
    str = string.dup

    # combine CR+NULL into CR
    str.gsub!(/#{CR}#{NULL}/no, CR) if @@options["Telnetmode"]

    # combine EOL into "\n"
    str.gsub!(/#{EOL}/no, "\n") unless @@options["Binmode"]

    str.gsub!(/#{IAC}(
                 [#{IAC}#{AO}#{AYT}#{DM}#{IP}#{NOP}]|
                 [#{DO}#{DONT}#{WILL}#{WONT}]
                   [#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}]|
                 #{SB}[^#{IAC}]*#{IAC}#{SE}
               )/xno){
      if    IAC == $1         # handle escaped IAC characters
        IAC
      elsif AYT == $1         # respond to "IAC AYT" (are you there)
        self.write("nobody here but us pigeons" + EOL)
        ''
      elsif DO[0] == $1[0]    # respond to "IAC DO x"
        if OPT_BINARY[0] == $1[1]
          @@telnet_option["BINARY"] = true
          self.write(IAC + WILL + OPT_BINARY)
        else
          self.write(IAC + WONT + $1[1..1])
        end
        ''
      elsif DONT[0] == $1[0]  # respond to "IAC DON'T x" with "IAC WON'T x"
        self.write(IAC + WONT + $1[1..1])
        ''
      elsif WILL[0] == $1[0]  # respond to "IAC WILL x"
        if    OPT_BINARY[0] == $1[1]
          self.write(IAC + DO + OPT_BINARY)
        elsif OPT_ECHO[0] == $1[1]
          self.write(IAC + DO + OPT_ECHO)
        elsif OPT_SGA[0]  == $1[1]
          @@telnet_option["SGA"] = true
          self.write(IAC + DO + OPT_SGA)
        else
          self.write(IAC + DONT + $1[1..1])
        end
        ''
      elsif WONT[0] == $1[0]  # respond to "IAC WON'T x"
        if    OPT_ECHO[0] == $1[1]
          self.write(IAC + DONT + OPT_ECHO)
        elsif OPT_SGA[0]  == $1[1]
          @@telnet_option["SGA"] = false
          self.write(IAC + DONT + OPT_SGA)
        else
          self.write(IAC + DONT + $1[1..1])
        end
        ''
      else
        ''
      end
    }

    str
  end # preprocess

  def waitfor(options)
    time_out = @@options["Timeout"]
    waittime = @@options["Waittime"]

    if options.kind_of?(Hash)
      prompt   = if options.has_key?("Match")
                   options["Match"]
                 elsif options.has_key?("Prompt")
                   options["Prompt"]
                 elsif options.has_key?("String")
                   Regexp.new( Regexp.quote(options["String"]) )
                 end
      time_out = options["Timeout"]  if options.has_key?("Timeout")
      waittime = options["Waittime"] if options.has_key?("Waittime")
    else
      prompt = options
    end

    if time_out == false
      time_out = nil
    end

    line = ''
    buf = ''
    rest = ''
    until(prompt === line and not IO::select([@@sock], nil, nil, waittime))
      unless IO::select([@@sock], nil, nil, time_out)
        raise TimeoutError, "timed-out; wait for the next data"
      end
      begin
        c = @@sock.sysread(1024 * 1024)
        @@dumplog.log_dump('<', c) if @@options.has_key?("Dump_log")
        if @@options["Telnetmode"]
          if Integer(c.rindex(/#{IAC}#{SE}/no)) <
             Integer(c.rindex(/#{IAC}#{SB}/no))
            buf = preprocess(rest + c[0 ... c.rindex(/#{IAC}#{SB}/no)])
            rest = c[c.rindex(/#{IAC}#{SB}/no) .. -1]
          elsif pt = c.rindex(/#{IAC}[^#{IAC}#{AO}#{AYT}#{DM}#{IP}#{NOP}]?\z/no)
            buf = preprocess(rest + c[0 ... pt])
            rest = c[pt .. -1]
          else
            buf = preprocess(c)
            rest = ''
          end
        end
        @@log.print(buf) if @@options.has_key?("Output_log")
        line.concat(buf)
        yield buf if iterator?
      rescue EOFError # End of file reached
        if line == ''
          line = nil
          yield nil if iterator?
        end
        break
      end
    end
    line
  end

  def write(string)
    length = string.length
    while 0 < length
      IO::select(nil, [@@sock])
      @@dumplog.log_dump('>', string[-length..-1]) if @@options.has_key?("Dump_log")
      length -= @@sock.syswrite(string[-length..-1])
    end
  end

  def print(string)
    str = string.dup + "\n"

    str.gsub!(/#{IAC}/no, IAC + IAC) if @@options["Telnetmode"]

    unless @@options["Binmode"]
      if @@telnet_option["BINARY"] and @@telnet_option["SGA"]
        # IAC WILL SGA IAC DO BIN send EOL --> CR
        str.gsub!(/\n/n, CR)
      elsif @@telnet_option["SGA"]
        # IAC WILL SGA send EOL --> CR+NULL
        str.gsub!(/\n/n, CR + NULL)
      else
        # NONE send EOL --> CR+LF
        str.gsub!(/\n/n, EOL)
      end
    end

    self.write(str)
  end

  def cmd(options)
    match    = @@options["Prompt"]
    time_out = @@options["Timeout"]

    if options.kind_of?(Hash)
      string   = options["String"]
      match    = options["Match"]   if options.has_key?("Match")
      time_out = options["Timeout"] if options.has_key?("Timeout")
    else
      string = options
    end

    self.print(string)
    if iterator?
      waitfor({"Prompt" => match, "Timeout" => time_out}){|c| yield c }
    else
      waitfor({"Prompt" => match, "Timeout" => time_out})
    end
  end

  def login(options, password = nil)
    if options.kind_of?(Hash)
      username = options["Name"]
      password = options["Password"]
    else
      username = options
    end

    if iterator?
      line = waitfor(/login[: ]*\z/n){|c| yield c }
      if password
        line.concat( cmd({"String" => username,
                          "Match" => /Password[: ]*\z/n}){|c| yield c } )
        line.concat( cmd(password){|c| yield c } )
      else
        line.concat( cmd(username){|c| yield c } )
      end
    else
      line = waitfor(/login[: ]*\z/n)
      if password
        line.concat( cmd({"String" => username,
                          "Match" => /Password[: ]*\z/n}) )
        line.concat( cmd(password) )
      else
        line.concat( cmd(username) )
      end
    end
    line
  end

end
@


1.6
log
@19991012
@
text
@d2 1
a2 1
$Date: 1999/10/04 22:51:26 $
d4 1
a4 1
== SIMPLE TELNET CLIANT LIBRARY
d8 1
a8 1
Version 1.00
d158 16
a356 1
require "thread"
d361 63
a423 63
  IAC   = 255.chr # "\377" # interpret as command:
  DONT  = 254.chr # "\376" # you are not to use option
  DO    = 253.chr # "\375" # please, you use option
  WONT  = 252.chr # "\374" # I won't use option
  WILL  = 251.chr # "\373" # I will use option
  SB    = 250.chr # "\372" # interpret as subnegotiation
  GA    = 249.chr # "\371" # you may reverse the line
  EL    = 248.chr # "\370" # erase the current line
  EC    = 247.chr # "\367" # erase the current character
  AYT   = 246.chr # "\366" # are you there
  AO    = 245.chr # "\365" # abort output--but let prog finish
  IP    = 244.chr # "\364" # interrupt process--permanently
  BREAK = 243.chr # "\363" # break
  DM    = 242.chr # "\362" # data mark--for connect. cleaning
  NOP   = 241.chr # "\361" # nop
  SE    = 240.chr # "\360" # end sub negotiation
  EOR   = 239.chr # "\357" # end of record (transparent mode)
  ABORT = 238.chr # "\356" # Abort process
  SUSP  = 237.chr # "\355" # Suspend process
  EOF   = 236.chr # "\354" # End of file
  SYNCH = 242.chr # "\362" # for telfunc calls

  OPT_BINARY         =   0.chr # "\000" # Binary Transmission
  OPT_ECHO           =   1.chr # "\001" # Echo
  OPT_RCP            =   2.chr # "\002" # Reconnection
  OPT_SGA            =   3.chr # "\003" # Suppress Go Ahead
  OPT_NAMS           =   4.chr # "\004" # Approx Message Size Negotiation
  OPT_STATUS         =   5.chr # "\005" # Status
  OPT_TM             =   6.chr # "\006" # Timing Mark
  OPT_RCTE           =   7.chr # "\a"   # Remote Controlled Trans and Echo
  OPT_NAOL           =   8.chr # "\010" # Output Line Width
  OPT_NAOP           =   9.chr # "\t"   # Output Page Size
  OPT_NAOCRD         =  10.chr # "\n"   # Output Carriage-Return Disposition
  OPT_NAOHTS         =  11.chr # "\v"   # Output Horizontal Tab Stops
  OPT_NAOHTD         =  12.chr # "\f"   # Output Horizontal Tab Disposition
  OPT_NAOFFD         =  13.chr # "\r"   # Output Formfeed Disposition
  OPT_NAOVTS         =  14.chr # "\016" # Output Vertical Tabstops
  OPT_NAOVTD         =  15.chr # "\017" # Output Vertical Tab Disposition
  OPT_NAOLFD         =  16.chr # "\020" # Output Linefeed Disposition
  OPT_XASCII         =  17.chr # "\021" # Extended ASCII
  OPT_LOGOUT         =  18.chr # "\022" # Logout
  OPT_BM             =  19.chr # "\023" # Byte Macro
  OPT_DET            =  20.chr # "\024" # Data Entry Terminal
  OPT_SUPDUP         =  21.chr # "\025" # SUPDUP
  OPT_SUPDUPOUTPUT   =  22.chr # "\026" # SUPDUP Output
  OPT_SNDLOC         =  23.chr # "\027" # Send Location
  OPT_TTYPE          =  24.chr # "\030" # Terminal Type
  OPT_EOR            =  25.chr # "\031" # End of Record
  OPT_TUID           =  26.chr # "\032" # TACACS User Identification
  OPT_OUTMRK         =  27.chr # "\e"   # Output Marking
  OPT_TTYLOC         =  28.chr # "\034" # Terminal Location Number
  OPT_3270REGIME     =  29.chr # "\035" # Telnet 3270 Regime
  OPT_X3PAD          =  30.chr # "\036" # X.3 PAD
  OPT_NAWS           =  31.chr # "\037" # Negotiate About Window Size
  OPT_TSPEED         =  32.chr # " "    # Terminal Speed
  OPT_LFLOW          =  33.chr # "!"    # Remote Flow Control
  OPT_LINEMODE       =  34.chr # "\""   # Linemode
  OPT_XDISPLOC       =  35.chr # "#"    # X Display Location
  OPT_OLD_ENVIRON    =  36.chr # "$"    # Environment Option
  OPT_AUTHENTICATION =  37.chr # "%"    # Authentication Option
  OPT_ENCRYPT        =  38.chr # "&"    # Encryption Option
  OPT_NEW_ENVIRON    =  39.chr # "'"    # New Environment Option
  OPT_EXOPL          = 255.chr # "\377" # Extended-Options-List
d431 2
a432 2
  VERSION = "1.00"
  RELEASE_DATE = "$Date: 1999/10/04 22:51:26 $"
d437 7
a443 7
    @@options["Binmode"]    = false         unless @@options.key?("Binmode")
    @@options["Host"]       = "localhost"   unless @@options.key?("Host")
    @@options["Port"]       = 23            unless @@options.key?("Port")
    @@options["Prompt"]     = /[$%#>] \z/n  unless @@options.key?("Prompt")
    @@options["Telnetmode"] = true          unless @@options.key?("Telnetmode")
    @@options["Timeout"]    = 10            unless @@options.key?("Timeout")
    @@options["Waittime"]   = 0             unless @@options.key?("Waittime")
d447 1
a447 1
    if @@options.key?("Output_log")
d453 1
a453 1
    if @@options.key?("Dump_log")
d457 21
d480 1
a480 1
    if @@options.key?("Proxy")
d491 2
a492 2
      @@log.write(message) if @@options.key?("Output_log")
      @@dumplog.write(message) if @@options.key?("Dump_log")
d505 2
a506 2
        @@log.write($!.to_s + "\n") if @@options.key?("Output_log")
        @@dumplog.write($!.to_s + "\n") if @@options.key?("Dump_log")
d514 2
a515 2
      @@log.write(message) if @@options.key?("Output_log")
      @@dumplog.write(message) if @@options.key?("Dump_log")
d571 3
a573 1
        if    OPT_ECHO[0] == $1[1]
d578 2
d588 2
d605 1
a605 1
      prompt   = if options.key?("Match")
d607 1
a607 1
                 elsif options.key?("Prompt")
d609 1
a609 1
                 elsif options.key?("String")
d612 2
a613 2
      time_out = options["Timeout"]  if options.key?("Timeout")
      waittime = options["Waittime"] if options.key?("Waittime")
d631 1
a631 1
        @@dumplog.print(c) if @@options.key?("Dump_log")
d645 1
a645 1
        @@log.print(buf) if @@options.key?("Output_log")
d663 2
a664 1
      length -= @@sock.syswrite(string)
d695 2
a696 2
      match    = options["Match"]   if options.key?("Match")
      time_out = options["Timeout"] if options.key?("Timeout")
@


1.6.2.1
log
@2000-02-08
@
text
@d2 1
a2 1
$Date: 2000/01/24 17:02:57 $
d4 1
a4 1
== SIMPLE TELNET CLIENT LIBRARY
d8 1
a8 1
Version 1.20
a157 16
=== Version 1.20

2000/01/24 17:02:57

- respond to "IAC WILL x" with "IAC DONT x"
- respond to "IAC WONT x" with "IAC DONT x"
- better dumplog format
  thanks to WATANABE Hirofumi <Hirofumi.Watanabe@@jp.sony.com>

=== Version 1.10

2000/01/18 17:47:31

- bug fix: write method
- respond to "IAC WILL BINARY" with "IAC DO BINARY"

d341 1
d346 63
a408 63
  IAC   = 255.chr # "\377" # "\xff" # interpret as command:
  DONT  = 254.chr # "\376" # "\xfe" # you are not to use option
  DO    = 253.chr # "\375" # "\xfd" # please, you use option
  WONT  = 252.chr # "\374" # "\xfc" # I won't use option
  WILL  = 251.chr # "\373" # "\xfb" # I will use option
  SB    = 250.chr # "\372" # "\xfa" # interpret as subnegotiation
  GA    = 249.chr # "\371" # "\xf9" # you may reverse the line
  EL    = 248.chr # "\370" # "\xf8" # erase the current line
  EC    = 247.chr # "\367" # "\xf7" # erase the current character
  AYT   = 246.chr # "\366" # "\xf6" # are you there
  AO    = 245.chr # "\365" # "\xf5" # abort output--but let prog finish
  IP    = 244.chr # "\364" # "\xf4" # interrupt process--permanently
  BREAK = 243.chr # "\363" # "\xf3" # break
  DM    = 242.chr # "\362" # "\xf2" # data mark--for connect. cleaning
  NOP   = 241.chr # "\361" # "\xf1" # nop
  SE    = 240.chr # "\360" # "\xf0" # end sub negotiation
  EOR   = 239.chr # "\357" # "\xef" # end of record (transparent mode)
  ABORT = 238.chr # "\356" # "\xee" # Abort process
  SUSP  = 237.chr # "\355" # "\xed" # Suspend process
  EOF   = 236.chr # "\354" # "\xec" # End of file
  SYNCH = 242.chr # "\362" # "\xf2" # for telfunc calls

  OPT_BINARY         =   0.chr # "\000" # "\x00" # Binary Transmission
  OPT_ECHO           =   1.chr # "\001" # "\x01" # Echo
  OPT_RCP            =   2.chr # "\002" # "\x02" # Reconnection
  OPT_SGA            =   3.chr # "\003" # "\x03" # Suppress Go Ahead
  OPT_NAMS           =   4.chr # "\004" # "\x04" # Approx Message Size Negotiation
  OPT_STATUS         =   5.chr # "\005" # "\x05" # Status
  OPT_TM             =   6.chr # "\006" # "\x06" # Timing Mark
  OPT_RCTE           =   7.chr # "\a"   # "\x07" # Remote Controlled Trans and Echo
  OPT_NAOL           =   8.chr # "\010" # "\x08" # Output Line Width
  OPT_NAOP           =   9.chr # "\t"   # "\x09" # Output Page Size
  OPT_NAOCRD         =  10.chr # "\n"   # "\x0a" # Output Carriage-Return Disposition
  OPT_NAOHTS         =  11.chr # "\v"   # "\x0b" # Output Horizontal Tab Stops
  OPT_NAOHTD         =  12.chr # "\f"   # "\x0c" # Output Horizontal Tab Disposition
  OPT_NAOFFD         =  13.chr # "\r"   # "\x0d" # Output Formfeed Disposition
  OPT_NAOVTS         =  14.chr # "\016" # "\x0e" # Output Vertical Tabstops
  OPT_NAOVTD         =  15.chr # "\017" # "\x0f" # Output Vertical Tab Disposition
  OPT_NAOLFD         =  16.chr # "\020" # "\x10" # Output Linefeed Disposition
  OPT_XASCII         =  17.chr # "\021" # "\x11" # Extended ASCII
  OPT_LOGOUT         =  18.chr # "\022" # "\x12" # Logout
  OPT_BM             =  19.chr # "\023" # "\x13" # Byte Macro
  OPT_DET            =  20.chr # "\024" # "\x14" # Data Entry Terminal
  OPT_SUPDUP         =  21.chr # "\025" # "\x15" # SUPDUP
  OPT_SUPDUPOUTPUT   =  22.chr # "\026" # "\x16" # SUPDUP Output
  OPT_SNDLOC         =  23.chr # "\027" # "\x17" # Send Location
  OPT_TTYPE          =  24.chr # "\030" # "\x18" # Terminal Type
  OPT_EOR            =  25.chr # "\031" # "\x19" # End of Record
  OPT_TUID           =  26.chr # "\032" # "\x1a" # TACACS User Identification
  OPT_OUTMRK         =  27.chr # "\e"   # "\x1b" # Output Marking
  OPT_TTYLOC         =  28.chr # "\034" # "\x1c" # Terminal Location Number
  OPT_3270REGIME     =  29.chr # "\035" # "\x1d" # Telnet 3270 Regime
  OPT_X3PAD          =  30.chr # "\036" # "\x1e" # X.3 PAD
  OPT_NAWS           =  31.chr # "\037" # "\x1f" # Negotiate About Window Size
  OPT_TSPEED         =  32.chr # " "    # "\x20" # Terminal Speed
  OPT_LFLOW          =  33.chr # "!"    # "\x21" # Remote Flow Control
  OPT_LINEMODE       =  34.chr # "\""   # "\x22" # Linemode
  OPT_XDISPLOC       =  35.chr # "#"    # "\x23" # X Display Location
  OPT_OLD_ENVIRON    =  36.chr # "$"    # "\x24" # Environment Option
  OPT_AUTHENTICATION =  37.chr # "%"    # "\x25" # Authentication Option
  OPT_ENCRYPT        =  38.chr # "&"    # "\x26" # Encryption Option
  OPT_NEW_ENVIRON    =  39.chr # "'"    # "\x27" # New Environment Option
  OPT_EXOPL          = 255.chr # "\377" # "\xff" # Extended-Options-List
d416 2
a417 2
  VERSION = "1.20"
  RELEASE_DATE = "$Date: 2000/01/24 17:02:57 $"
d422 7
a428 7
    @@options["Binmode"]    = false         unless @@options.has_key?("Binmode")
    @@options["Host"]       = "localhost"   unless @@options.has_key?("Host")
    @@options["Port"]       = 23            unless @@options.has_key?("Port")
    @@options["Prompt"]     = /[$%#>] \z/n  unless @@options.has_key?("Prompt")
    @@options["Telnetmode"] = true          unless @@options.has_key?("Telnetmode")
    @@options["Timeout"]    = 10            unless @@options.has_key?("Timeout")
    @@options["Waittime"]   = 0             unless @@options.has_key?("Waittime")
d432 1
a432 1
    if @@options.has_key?("Output_log")
d438 1
a438 1
    if @@options.has_key?("Dump_log")
a441 21
      def @@dumplog.log_dump(dir, x)
        len = x.length
        addr = 0
        offset = 0
        while 0 < len
          if len < 16
            line = x[offset, len]
          else
            line = x[offset, 16]
          end
          hexvals = line.unpack('H*')[0]
          hexvals.concat ' ' * (32 - hexvals.length)
          hexvals = format "%s %s %s %s  " * 4, *hexvals.unpack('a2' * 16)
          line.gsub! /[\000-\037\177-\377]/n, '.'
          printf "%s 0x%5.5x: %s%s\n", dir, addr, hexvals, line
          addr += 16
          offset += 16
          len -= 16
        end
        print "\n"
      end
d444 1
a444 1
    if @@options.has_key?("Proxy")
d455 2
a456 2
      @@log.write(message) if @@options.has_key?("Output_log")
      @@dumplog.log_dump('#', message) if @@options.has_key?("Dump_log")
d469 2
a470 2
        @@log.write($!.to_s + "\n") if @@options.has_key?("Output_log")
        @@dumplog.log_dump('#', $!.to_s + "\n") if @@options.has_key?("Dump_log")
d478 2
a479 2
      @@log.write(message) if @@options.has_key?("Output_log")
      @@dumplog.log_dump('#', message) if @@options.has_key?("Dump_log")
d535 1
a535 3
        if    OPT_BINARY[0] == $1[1]
          self.write(IAC + DO + OPT_BINARY)
        elsif OPT_ECHO[0] == $1[1]
a539 2
        else
          self.write(IAC + DONT + $1[1..1])
a547 2
        else
          self.write(IAC + DONT + $1[1..1])
d563 1
a563 1
      prompt   = if options.has_key?("Match")
d565 1
a565 1
                 elsif options.has_key?("Prompt")
d567 1
a567 1
                 elsif options.has_key?("String")
d570 2
a571 2
      time_out = options["Timeout"]  if options.has_key?("Timeout")
      waittime = options["Waittime"] if options.has_key?("Waittime")
d589 1
a589 1
        @@dumplog.log_dump('<', c) if @@options.has_key?("Dump_log")
d603 1
a603 1
        @@log.print(buf) if @@options.has_key?("Output_log")
d621 1
a621 2
      @@dumplog.log_dump('>', string[-length..-1]) if @@options.has_key?("Dump_log")
      length -= @@sock.syswrite(string[-length..-1])
d652 2
a653 2
      match    = options["Match"]   if options.has_key?("Match")
      time_out = options["Timeout"] if options.has_key?("Timeout")
@


1.6.2.2
log
@000414
@
text
@d1 2
a2 3
#
# telnet.rb
#
d4 1
a4 1
$stderr.puts 'Warning: telnet.rb is obsolete: use net/telnet'
d6 1
a6 1
require 'net/telnet'
d8 732
a739 1
Telnet = ::Net::Telnet
@


1.5
log
@19990922
@
text
@d2 1
a2 1
$Date: 1999/09/21 21:24:07 $
d8 1
a8 1
Version 0.50
d158 9
a342 1
TimeOut = TimeoutError
d416 2
a417 2
  VERSION = "0.50"
  RELEASE_DATE = "$Date: 1999/09/21 21:24:07 $"
d467 1
a467 1
        raise TimeOut, "timed-out; opening of the host"
d513 1
a513 2
                 #{IAC}|
                 #{AYT}|
d515 2
a516 1
                   [#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}]
d550 2
d564 1
a564 1
                   options["Match"]   
d582 1
d585 1
a585 1
        raise TimeOut, "timed-out; wait for the next data"
a589 1
        buf.concat c
d591 12
a602 5
          buf = preprocess(buf) 
          if /#{IAC}.?\z/no === buf
            next
          end 
        end 
d604 1
a605 2
        line.concat(buf)
        buf = ''
@


1.4
log
@990918-repack
@
text
@d2 1
a2 1
$Date: 1999/09/17 17:41:41 $
d8 1
a8 1
Version 0.40
d89 1
d158 6
d408 2
a409 2
  VERSION = "0.40"
  RELEASE_DATE = "$Date: 1999/09/17 17:41:41 $"
d513 1
a513 1
        @@sock.write("nobody here but us pigeons" + EOL)
d518 1
a518 1
          @@sock.write(IAC + WILL + OPT_BINARY)
d520 1
a520 1
          @@sock.write(IAC + WONT + $1[1..1])
d524 1
a524 1
        @@sock.write(IAC + WONT + $1[1..1])
d528 1
a528 1
          @@sock.write(IAC + DO + OPT_ECHO)
d531 1
a531 1
          @@sock.write(IAC + DO + OPT_SGA)
d536 1
a536 1
          @@sock.write(IAC + DONT + OPT_ECHO)
d539 1
a539 1
          @@sock.write(IAC + DONT + OPT_SGA)
d601 8
d627 1
a627 1
    @@sock.write(str)
a641 1
    IO::select(nil, [@@sock])
@


1.3
log
@1.4.1
@
text
@d2 1
a2 1
$Date: 1999/09/14 23:09:05 $
d8 1
a8 1
Version 0.30
d157 6
d401 2
a402 2
  VERSION = "0.30"
  RELEASE_DATE = "$Date: 1999/09/14 23:09:05 $"
d497 38
a534 35
    # respond to "IAC DO x"
    str.gsub!(/([^#{IAC}]?)#{IAC}#{DO}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_BINARY == $2
        @@telnet_option["BINARY"] = true
        @@sock.write(IAC + WILL + OPT_BINARY)
      else
        @@sock.write(IAC + WONT + $2)
      end
      $1
    }

    # respond to "IAC DON'T x" with "IAC WON'T x"
    str.gsub!(/([^#{IAC}]?)#{IAC}#{DONT}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      @@sock.write(IAC + WONT + $2)
      $1
    }

    # respond to "IAC WILL x"
    str.gsub!(/([^#{IAC}]?)#{IAC}#{WILL}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_ECHO == $2
        @@sock.write(IAC + DO + OPT_ECHO)
      elsif OPT_SGA == $2
        @@telnet_option["SGA"] = true
        @@sock.write(IAC + DO + OPT_SGA)
      end
      $1
    }

    # respond to "IAC WON'T x"
    str.gsub!(/([^#{IAC}]?)#{IAC}#{WONT}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_ECHO == $2
        @@sock.write(IAC + DONT + OPT_ECHO)
      elsif OPT_SGA == $2
        @@telnet_option["SGA"] = false
        @@sock.write(IAC + DONT + OPT_SGA)
a535 1
      $1
a536 8

    # respond to "IAC AYT" (are you there)
    str.gsub!(/([^#{IAC}]?)#{IAC}#{AYT}/no){
      @@sock.write("nobody here but us pigeons" + EOL)
      $1
    }

    str.gsub!(/#{IAC}#{IAC}/no, IAC) # handle escaped IAC characters
@


1.2
log
@1.4.0
@
text
@d2 1
a2 1
$Date: 1999/08/10 05:20:21 $
d8 1
a8 1
Version 0.232
d37 1
a37 1
	host = Telnet.new({"Host" => "localhost"){|c| print c }
d113 7
d157 15
d178 1
a178 1
	host = Telnet.new({"Host" => "localhost"){|c| print c }
d395 2
a396 2
  VERSION = "0.232"
  RELEASE_DATE = "$Date: 1999/08/10 05:20:21 $"
d565 1
a565 1
    until(not IO::select([@@sock], nil, nil, waittime) and prompt === line)
d636 1
a636 1
  def login(options, password = '')
d646 7
a652 3
      line.concat( cmd({"String" => username,
                        "Match" => /Password[: ]*\z/n}){|c| yield c } )
      line.concat( cmd(password){|c| yield c } )
d655 7
a661 3
      line.concat( cmd({"String" => username,
                        "Match" => /Password[: ]*\z/n}) )
      line.concat( cmd(password) )
@


1.1
log
@file telnet.rb was initially added on branch v1_1r.
@
text
@d1 636
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@a0 439
#
# telnet.rb
# ver0.16 1998/10/09
# Wakou Aoyama <wakou@@fsinet.or.jp>
#
# ver0.16 1998/10/09
# preprocess method change for the better
# add binmode method.
# change default Binmode
# TRUE --> FALSE
#
# ver0.15 1998/10/04
# add telnetmode method.
#
# ver0.141 1998/09/22
# change default prompt
# /[$%#>] $/ --> /[$%#>] \Z/
#
# ver0.14 1998/09/01
# IAC WILL SGA             send EOL --> CR+NULL
# IAC WILL SGA IAC DO BIN  send EOL --> CR
# NONE                     send EOL --> LF
# add Dump_log option.
#
# ver0.13 1998/08/25
# add print method.
#
# ver0.122 1998/08/05
# support for HP-UX 10.20    thanks to WATANABE Tetsuya <tetsu@@jpn.hp.com>
# socket.<< --> socket.write
#
# ver0.121 1998/07/15
# string.+= --> string.concat
#
# ver0.12 1998/06/01
# add timeout, waittime.
#
# ver0.11 1998/04/21
# add realtime output.
#
# ver0.10 1998/04/13
# first release.
#
# == make new Telnet object
# host = Telnet.new({"Binmode" => FALSE,             default: FALSE
#                    "Host" => "localhost",          default: "localhost"
#                    "Output_log" => "output_log",   default: not output
#                    "Dump_log" => "dump_log",       default: not output
#                    "Port" => 23,                   default: 23
#                    "Prompt" => /[$%#>] \Z/,        default: /[$%#>] \Z/
#                    "Telnetmode" => TRUE,           default: TRUE
#                    "Timeout" => 10,                default: 10
#                    "Waittime" => 0})               default: 0
#
# if set "Telnetmode" option FALSE. not TELNET command interpretation.
# "Waittime" is time to confirm "Prompt". There is a possibility that
# the same character as "Prompt" is included in the data, and, when
# the network or the host is very heavy, the value is enlarged.
#
# == wait for match
# line = host.waitfor(/match/)
# line = host.waitfor({"Match"   => /match/,
#                      "String"  => "string",
#                      "Timeout" => secs})
# if set "String" option. Match = Regexp.new(quote(string))
#
# realtime output. of cource, set sync=TRUE or flush is necessary.
# host.waitfor(/match/){|c| print c }
# host.waitfor({"Match"   => /match/,
#               "String"  => "string",
#               "Timeout" => secs}){|c| print c}
#
# == send string and wait prompt
# line = host.cmd("string")
# line = host.cmd({"String" => "string",
#                  "Prompt" => /[$%#>] \Z/,
#                  "Timeout" => 10})
#
# realtime output. of cource, set sync=TRUE or flush is necessary.
# host.cmd("string"){|c| print c }
# host.cmd({"String" => "string",
#           "Prompt" => /[$%#>] \Z/,
#           "Timeout" => 10}){|c| print c }
#
# == send string
# host.print("string")
#
# == turn telnet command interpretation
# host.telnetmode        # turn on/off
# host.telnetmode(TRUE)  # on
# host.telnetmode(FALSE) # off
#
# == toggle newline translation
# host.binmode        # turn TRUE/FALSE
# host.binmode(TRUE)  # no translate newline
# host.binmode(FALSE) # translate newline
#
# == login
# host.login("username", "password")
# host.login({"Name" => "username",
#             "Password" => "password",
#             "Prompt" => /[$%#>] \Z/,
#             "Timeout" => 10})
#
# realtime output. of cource, set sync=TRUE or flush is necessary.
# host.login("username", "password"){|c| print c }
# host.login({"Name" => "username",
#             "Password" => "password",
#             "Prompt" => /[$%#>] \Z/,
#             "Timeout" => 10}){|c| print c }
#
# and Telnet object has socket class methods
#
# == sample
# localhost = Telnet.new({"Host" => "localhost",
#                         "Timeout" => 10,
#                         "Prompt" => /[$%#>] \Z/})
# localhost.login("username", "password"){|c| print c }
# localhost.cmd("command"){|c| print c }
# localhost.close
#
# == sample 2
# checks a POP server to see if you have mail.
#
# pop = Telnet.new({"Host" => "your_destination_host_here",
#                   "Port" => 110,
#                   "Telnetmode" => FALSE,
#                   "Prompt" => /^\+OK/})
# pop.cmd("user " + "your_username_here"){|c| print c}
# pop.cmd("pass " + "your_password_here"){|c| print c}
# pop.cmd("list"){|c| print c}

require "socket"
require "delegate"
require "thread"

class TimeOut < Exception
end

class Telnet < SimpleDelegator

  def timeout(sec)
    is_timeout = FALSE 
    begin
      x = Thread.current
      y = Thread.start {
        sleep sec
        if x.alive?
          #print "timeout!\n"
          x.raise TimeOut, "timeout"
        end
      }
      begin
        yield
      rescue TimeOut
        is_timeout = TRUE
      end
    ensure
      Thread.kill y if y && y.alive?
    end
    is_timeout
  end

  IAC   = 255.chr  # interpret as command:
  DONT  = 254.chr  # you are not to use option
  DO    = 253.chr  # please, you use option
  WONT  = 252.chr  # I won't use option
  WILL  = 251.chr  # I will use option
  SB    = 250.chr  # interpret as subnegotiation
  GA    = 249.chr  # you may reverse the line
  EL    = 248.chr  # erase the current line
  EC    = 247.chr  # erase the current character
  AYT   = 246.chr  # are you there
  AO    = 245.chr  # abort output--but let prog finish
  IP    = 244.chr  # interrupt process--permanently
  BREAK = 243.chr  # break
  DM    = 242.chr  # data mark--for connect. cleaning
  NOP   = 241.chr  # nop
  SE    = 240.chr  # end sub negotiation
  EOR   = 239.chr  # end of record (transparent mode)
  ABORT = 238.chr  # Abort process
  SUSP  = 237.chr  # Suspend process
  EOF   = 236.chr  # End of file
  SYNCH = 242.chr  # for telfunc calls

  OPT_BINARY         =   0.chr  # Binary Transmission
  OPT_ECHO           =   1.chr  # Echo
  OPT_RCP            =   2.chr  # Reconnection
  OPT_SGA            =   3.chr  # Suppress Go Ahead
  OPT_NAMS           =   4.chr  # Approx Message Size Negotiation
  OPT_STATUS         =   5.chr  # Status
  OPT_TM             =   6.chr  # Timing Mark
  OPT_RCTE           =   7.chr  # Remote Controlled Trans and Echo
  OPT_NAOL           =   8.chr  # Output Line Width
  OPT_NAOP           =   9.chr  # Output Page Size
  OPT_NAOCRD         =  10.chr  # Output Carriage-Return Disposition
  OPT_NAOHTS         =  11.chr  # Output Horizontal Tab Stops
  OPT_NAOHTD         =  12.chr  # Output Horizontal Tab Disposition
  OPT_NAOFFD         =  13.chr  # Output Formfeed Disposition
  OPT_NAOVTS         =  14.chr  # Output Vertical Tabstops
  OPT_NAOVTD         =  15.chr  # Output Vertical Tab Disposition
  OPT_NAOLFD         =  16.chr  # Output Linefeed Disposition
  OPT_XASCII         =  17.chr  # Extended ASCII
  OPT_LOGOUT         =  18.chr  # Logout
  OPT_BM             =  19.chr  # Byte Macro
  OPT_DET            =  20.chr  # Data Entry Terminal
  OPT_SUPDUP         =  21.chr  # SUPDUP
  OPT_SUPDUPOUTPUT   =  22.chr  # SUPDUP Output
  OPT_SNDLOC         =  23.chr  # Send Location
  OPT_TTYPE          =  24.chr  # Terminal Type
  OPT_EOR            =  25.chr  # End of Record
  OPT_TUID           =  26.chr  # TACACS User Identification
  OPT_OUTMRK         =  27.chr  # Output Marking
  OPT_TTYLOC         =  28.chr  # Terminal Location Number
  OPT_3270REGIME     =  29.chr  # Telnet 3270 Regime
  OPT_X3PAD          =  30.chr  # X.3 PAD
  OPT_NAWS           =  31.chr  # Negotiate About Window Size
  OPT_TSPEED         =  32.chr  # Terminal Speed
  OPT_LFLOW          =  33.chr  # Remote Flow Control
  OPT_LINEMODE       =  34.chr  # Linemode
  OPT_XDISPLOC       =  35.chr  # X Display Location
  OPT_OLD_ENVIRON    =  36.chr  # Environment Option
  OPT_AUTHENTICATION =  37.chr  # Authentication Option
  OPT_ENCRYPT        =  38.chr  # Encryption Option
  OPT_NEW_ENVIRON    =  39.chr  # New Environment Option
  OPT_EXOPL          = 255.chr  # Extended-Options-List

  NULL = "\000"
  CR   = "\015"
  LF   = "\012"
  EOL  = CR + LF

  def initialize(options)
    @@options = options
    @@options["Binmode"]    = FALSE        if not @@options.include?("Binmode")
    @@options["Host"]       = "localhost"  if not @@options.include?("Host")
    @@options["Port"]       = 23           if not @@options.include?("Port")
    @@options["Prompt"]     = /[$%#>] \Z/  if not @@options.include?("Prompt")
    @@options["Telnetmode"] = TRUE         if not @@options.include?("Telnetmode")
    @@options["Timeout"]    = 10           if not @@options.include?("Timeout")
    @@options["Waittime"]   = 0            if not @@options.include?("Waittime")

    @@telnet_option = { "SGA" => FALSE, "BINARY" => FALSE }

    if @@options.include?("Output_log")
      @@log = File.open(@@options["Output_log"], 'a+')
      @@log.sync = TRUE
      @@log.binmode
    end

    if @@options.include?("Dump_log")
      @@dumplog = File.open(@@options["Dump_log"], 'a+')
      @@dumplog.sync = TRUE
      @@dumplog.binmode
    end

    message = "Trying " + @@options["Host"] + "...\n"
    STDOUT.write(message)
    @@log.write(message) if @@options.include?("Output_log")
    @@dumplog.write(message) if @@options.include?("Dump_log")

    is_timeout = timeout(@@options["Timeout"]){
      begin
        @@sock = TCPsocket.open(@@options["Host"], @@options["Port"])
      rescue
        @@log.write($! + "\n") if @@options.include?("Output_log")
        @@dumplog.write($! + "\n") if @@options.include?("Dump_log")
        raise
      end
    }
    raise TimeOut, "timed-out; opening of the host" if is_timeout
    @@sock.sync = TRUE
    @@sock.binmode

    message = "Connected to " + @@options["Host"] + ".\n"
    STDOUT.write(message)
    @@log.write(message) if @@options.include?("Output_log")
    @@dumplog.write(message) if @@options.include?("Dump_log")

    super(@@sock)
  end

  def telnetmode(mode = 'turn')
    if 'turn' == mode
      @@options["Telnetmode"] = @@options["Telnetmode"] ? FALSE : TRUE
    else
      @@options["Telnetmode"] = mode ? TRUE : FALSE
    end
  end

  def binmode(mode = 'turn')
    if 'turn' == mode
      @@options["Binmode"] = @@options["Binmode"] ? FALSE : TRUE
    else
      @@options["Binmode"] = mode ? TRUE : FALSE
    end
  end

  def preprocess(str)

    if not @@options["Binmode"]
      str.gsub!(/#{CR}#{NULL}/no, CR) # combine CR+NULL into CR
      str.gsub!(/#{EOL}/no, "\n")     # combine EOL into "\n"
    end

    # respond to "IAC DO x"
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{DO}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_BINARY == $1
        @@telnet_option["BINARY"] = TRUE
        @@sock.write(IAC + WILL + OPT_BINARY)
      else
        @@sock.write(IAC + WONT + $1)
      end
      ''
    }

    # respond to "IAC DON'T x" with "IAC WON'T x"
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{DONT}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      @@sock.write(IAC + WONT + $1)
      ''
    }

    # respond to "IAC WILL x"
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{WILL}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_SGA == $1
        @@telnet_option["SGA"] = TRUE
        @@sock.write(IAC + DO + OPT_SGA)
      end
      ''
    }

    # ignore "IAC WON'T x"
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{WONT}[#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}]/no, '')

    # respond to "IAC AYT" (are you there)
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{AYT}/no){
      @@sock.write("nobody here but us pigeons" + EOL)
      ''
    }

    str.gsub(/#{IAC}#{IAC}/no, IAC) # handle escaped IAC characters
  end

  def waitfor(options)
    timeout  = @@options["Timeout"]
    waittime = @@options["Waittime"]

    if options.kind_of?(Hash)
      prompt   = options["Prompt"]   if options.include?("Prompt")
      timeout  = options["Timeout"]  if options.include?("Timeout")
      waittime = options["Waittime"] if options.include?("Waittime")
      prompt   = Regexp.new( Regexp.quote(options["String"]) ) if
        options.include?("String")
    else
      prompt = options
    end

    line = ''
    until(not select([@@sock], nil, nil, waittime) and prompt === line)
      raise TimeOut, "timed-out; wait for the next data" if
        not select([@@sock], nil, nil, timeout)
      buf = ''
      begin
        buf = @@sock.sysread(1024 * 1024)
        @@dumplog.print(buf) if @@options.include?("Dump_log")
        buf = preprocess(buf) if @@options["Telnetmode"]
      rescue EOFError # End of file reached
        break
      ensure
        @@log.print(buf) if @@options.include?("Output_log")
        yield buf if iterator?
        line.concat(buf)
      end
    end
    line
  end

  def print(string)
    string.gsub!(/#{IAC}/no, IAC + IAC) if @@options["Telnetmode"]
    if @@options["Binmode"]
      @@sock.write(string)
    else
      if @@telnet_option["BINARY"] and @@telnet_option["SGA"]
        # IAC WILL SGA IAC DO BIN send EOL --> CR
        @@sock.write(string.gsub(/\n/, CR) + CR)
      elsif @@telnet_option["SGA"]
        # IAC WILL SGA send EOL --> CR+NULL
        @@sock.write(string.gsub(/\n/, CR + NULL) + CR + NULL)
      else
        # NONE send EOL --> LF
        @@sock.write(string.gsub(/\n/, LF) + LF)
      end
    end
  end

  def cmd(options)
    match   = @@options["Prompt"]
    timeout = @@options["Timeout"]

    if options.kind_of?(Hash)
      string  = options["String"]
      match   = options["Match"]   if options.include?("Match")
      timeout = options["Timeout"] if options.include?("Timeout")
    else
      string = options
    end

    select(nil, [@@sock])
    print(string)
    if iterator?
      waitfor({"Prompt" => match, "Timeout" => timeout}){|c| yield c }
    else
      waitfor({"Prompt" => match, "Timeout" => timeout})
    end
  end

  def login(options, password = '')
    if options.kind_of?(Hash)
      username = options["Name"]
      password = options["Password"]
    else
      username = options
    end

    if iterator?
      line = waitfor(/login[: ]*\Z/){|c| yield c }
      line.concat( cmd({"String" => username,
                        "Match" => /Password[: ]*\Z/}){|c| yield c } )
      line.concat( cmd(password){|c| yield c } )
    else
      line = waitfor(/login[: ]*\Z/)
      line.concat( cmd({"String" => username,
                        "Match" => /Password[: ]*\Z/}) )
      line.concat( cmd(password) )
    end
    line
  end

end
@


1.1.1.1.2.1
log
@990203
@
text
@d359 1
a359 1
    until(not IO::select([@@sock], nil, nil, waittime) and prompt === line)
d361 1
a361 1
        not IO::select([@@sock], nil, nil, timeout)
d408 1
a408 1
    IO::select(nil, [@@sock])
@


1.1.1.1.2.2
log
@990205
@
text
@d1 131
a131 136
=begin

telnet.rb ver0.161 1999/02/03
Wakou Aoyama <wakou@@fsinet.or.jp>

ver0.161 1999/02/03
select --> IO::select

ver0.16 1998/10/09
preprocess method change for the better
add binmode method.
change default Binmode
TRUE --> FALSE

ver0.15 1998/10/04
add telnetmode method.

ver0.141 1998/09/22
change default prompt
/[$%#>] $/ --> /[$%#>] \Z/

ver0.14 1998/09/01
IAC WILL SGA             send EOL --> CR+NULL
IAC WILL SGA IAC DO BIN  send EOL --> CR
NONE                     send EOL --> LF
add Dump_log option.

ver0.13 1998/08/25
add print method.

ver0.122 1998/08/05
support for HP-UX 10.20    thanks to WATANABE Tetsuya <tetsu@@jpn.hp.com>
socket.<< --> socket.write

ver0.121 1998/07/15
string.+= --> string.concat

ver0.12 1998/06/01
add timeout, waittime.

ver0.11 1998/04/21
add realtime output.

ver0.10 1998/04/13
first release.

== make new Telnet object
host = Telnet.new({"Binmode" => FALSE,             default: FALSE
                   "Host" => "localhost",          default: "localhost"
                   "Output_log" => "output_log",   default: not output
                   "Dump_log" => "dump_log",       default: not output
                   "Port" => 23,                   default: 23
                   "Prompt" => /[$%#>] \Z/,        default: /[$%#>] \Z/
                   "Telnetmode" => TRUE,           default: TRUE
                   "Timeout" => 10,                default: 10
                   "Waittime" => 0})               default: 0

if set "Telnetmode" option FALSE. not TELNET command interpretation.
"Waittime" is time to confirm "Prompt". There is a possibility that
the same character as "Prompt" is included in the data, and, when
the network or the host is very heavy, the value is enlarged.

== wait for match
line = host.waitfor(/match/)
line = host.waitfor({"Match"   => /match/,
                     "String"  => "string",
                     "Timeout" => secs})
if set "String" option. Match = Regexp.new(quote(string))

realtime output. of cource, set sync=TRUE or flush is necessary.
host.waitfor(/match/){|c| print c }
host.waitfor({"Match"   => /match/,
              "String"  => "string",
              "Timeout" => secs}){|c| print c}

== send string and wait prompt
line = host.cmd("string")
line = host.cmd({"String" => "string",
                 "Prompt" => /[$%#>] \Z/,
                 "Timeout" => 10})

realtime output. of cource, set sync=TRUE or flush is necessary.
host.cmd("string"){|c| print c }
host.cmd({"String" => "string",
          "Prompt" => /[$%#>] \Z/,
          "Timeout" => 10}){|c| print c }

== send string
host.print("string")

== turn telnet command interpretation
host.telnetmode        # turn on/off
host.telnetmode(TRUE)  # on
host.telnetmode(FALSE) # off

== toggle newline translation
host.binmode        # turn TRUE/FALSE
host.binmode(TRUE)  # no translate newline
host.binmode(FALSE) # translate newline

== login
host.login("username", "password")
host.login({"Name" => "username",
            "Password" => "password",
            "Prompt" => /[$%#>] \Z/,
            "Timeout" => 10})

realtime output. of cource, set sync=TRUE or flush is necessary.
host.login("username", "password"){|c| print c }
host.login({"Name" => "username",
            "Password" => "password",
            "Prompt" => /[$%#>] \Z/,
            "Timeout" => 10}){|c| print c }

and Telnet object has socket class methods

== sample
localhost = Telnet.new({"Host" => "localhost",
                        "Timeout" => 10,
                        "Prompt" => /[$%#>] \Z/})
localhost.login("username", "password"){|c| print c }
localhost.cmd("command"){|c| print c }
localhost.close

== sample 2
checks a POP server to see if you have mail.

pop = Telnet.new({"Host" => "your_destination_host_here",
                  "Port" => 110,
                  "Telnetmode" => FALSE,
                  "Prompt" => /^\+OK/})
pop.cmd("user " + "your_username_here"){|c| print c}
pop.cmd("pass " + "your_password_here"){|c| print c}
pop.cmd("list"){|c| print c}

=end
@


1.1.1.1.2.3
log
@990324
@
text
@d3 1
a3 4
= simple telnet cliant library

telnet.rb ver0.162 1999/03/18

a5 131

= methods

== new (make new Telnet object)

	host = Telnet.new({"Binmode" => FALSE,           # default: FALSE
	                   "Host" => "localhost",        # default: "localhost"
	                   "Output_log" => "output_log", # default: not output
	                   "Dump_log" => "dump_log",     # default: not output
	                   "Port" => 23,                 # default: 23
	                   "Prompt" => /[$%#>] \Z/,      # default: /[$%#>] \Z/
	                   "Telnetmode" => TRUE,         # default: TRUE
	                   "Timeout" => 10,              # default: 10
	                   "Waittime" => 0,              # default: 0
	                   "Proxy" => proxy})            # default: nil
                                    # proxy is Telnet or TCPsocket object

Telnet object has socket class methods.

if set "Telnetmode" option FALSE. not TELNET command interpretation.
"Waittime" is time to confirm "Prompt". There is a possibility that
the same character as "Prompt" is included in the data, and, when
the network or the host is very heavy, the value is enlarged.


== waitfor (wait for match)

	line = host.waitfor(/match/)
	line = host.waitfor({"Match"   => /match/,
	                     "String"  => "string",
	                     "Timeout" => secs})

if set "String" option. Match = Regexp.new(quote(string))


=== realtime output

	host.waitfor(/match/){|c| print c }
	host.waitfor({"Match"   => /match/,
	              "String"  => "string",
	              "Timeout" => secs}){|c| print c}

of cource, set sync=TRUE or flush is necessary.


== cmd (send string and wait prompt)

	line = host.cmd("string")
	line = host.cmd({"String" => "string",
	                 "Prompt" => /[$%#>] \Z/,
	                 "Timeout" => 10})


=== realtime output

	host.cmd("string"){|c| print c }
	host.cmd({"String" => "string",
	          "Prompt" => /[$%#>] \Z/,
	          "Timeout" => 10}){|c| print c }

of cource, set sync=TRUE or flush is necessary.


== print (send string)

	host.print("string")


== telnetmode (turn telnet command interpretation)

	host.telnetmode        # turn on/off
	host.telnetmode(TRUE)  # on
	host.telnetmode(FALSE) # off


== binmode (toggle newline translation)

	host.binmode        # turn TRUE/FALSE
	host.binmode(TRUE)  # no translate newline
	host.binmode(FALSE) # translate newline


== login

	host.login("username", "password")
	host.login({"Name" => "username",
	            "Password" => "password",
	            "Prompt" => /[$%#>] \Z/,
	            "Timeout" => 10})


=== realtime output

	host.login("username", "password"){|c| print c }
	host.login({"Name" => "username",
	            "Password" => "password",
	            "Prompt" => /[$%#>] \Z/,
	            "Timeout" => 10}){|c| print c }

of cource, set sync=TRUE or flush is necessary.


= sample

== login and send command

	localhost = Telnet.new({"Host" => "localhost",
	                        "Timeout" => 10,
	                        "Prompt" => /[$%#>] \Z/})
	localhost.login("username", "password"){|c| print c }
	localhost.cmd("command"){|c| print c }
	localhost.close


== checks a POP server to see if you have mail

	pop = Telnet.new({"Host" => "your_destination_host_here",
	                  "Port" => 110,
	                  "Telnetmode" => FALSE,
	                  "Prompt" => /^\+OK/})
	pop.cmd("user " + "your_username_here"){|c| print c}
	pop.cmd("pass " + "your_password_here"){|c| print c}
	pop.cmd("list"){|c| print c}


= history

ver0.162 1999/03/17
add "Proxy" option
required timeout.rb

d47 89
d141 3
a143 2
require "timeout"
TimeOut = TimeoutError
d147 22
d262 4
a265 13
    if @@options.include?("Proxy")
      if @@options["Proxy"].kind_of?(Telnet)
        @@sock = @@options["Proxy"].sock
      elsif @@options["Proxy"].kind_of?(TCPsocket)
        @@sock = @@options["Proxy"]
      else
        raise "Error; Proxy is Telnet or TCPSocket object."
      end
    else
      message = "Trying " + @@options["Host"] + "...\n"
      STDOUT.write(message)
      @@log.write(message) if @@options.include?("Output_log")
      @@dumplog.write(message) if @@options.include?("Dump_log")
d267 1
d269 1
a269 5
        timeout(@@options["Timeout"]){
          @@sock = TCPsocket.open(@@options["Host"], @@options["Port"])
        }
      rescue TimeoutError
        raise TimeOut, "timed-out; opening of the host"
d275 9
a283 8
      @@sock.sync = TRUE
      @@sock.binmode

      message = "Connected to " + @@options["Host"] + ".\n"
      STDOUT.write(message)
      @@log.write(message) if @@options.include?("Output_log")
      @@dumplog.write(message) if @@options.include?("Dump_log")
    end
a287 2
  attr :sock

d350 1
a350 1
    time_out = @@options["Timeout"]
d355 1
a355 1
      time_out = options["Timeout"]  if options.include?("Timeout")
d366 1
a366 1
        not IO::select([@@sock], nil, nil, time_out)
d402 2
a403 2
    match    = @@options["Prompt"]
    time_out = @@options["Timeout"]
d406 3
a408 3
      string   = options["String"]
      match    = options["Match"]   if options.include?("Match")
      time_out = options["Timeout"] if options.include?("Timeout")
d416 1
a416 1
      waitfor({"Prompt" => match, "Timeout" => time_out}){|c| yield c }
d418 1
a418 1
      waitfor({"Prompt" => match, "Timeout" => time_out})
@


1.1.1.1.2.4
log
@prepare to alpha
@
text
@d5 1
a5 1
telnet.rb ver0.163 1999/04/11
a32 11
=== status output

	host = Telnet.new({"Hosh" => "localhost"){|c| print c }

connection status output.

example

Trying localhost...
Connected to localhost.

a135 3
ver0.163 1999/04/11
STDOUT.write(message) --> yield(message) if iterator?

d294 1
a294 1
      yield(message) if iterator?
d313 1
a313 1
      yield(message) if iterator?
@


1.1.1.1.2.5
log
@glibc 2.1
@
text
@d5 2
a6 1
telnet.rb ver0.17 1999/04/30
a146 4
ver0.17 1999/04/30
bug fix
$! + "\n"  -->  $!.to_s + "\n"

d319 2
a320 2
        @@log.write($!.to_s + "\n") if @@options.include?("Output_log")
        @@dumplog.write($!.to_s + "\n") if @@options.include?("Dump_log")
d403 1
a403 7
      prompt   = if options.include?("Match")
                   options["Match"]   
                 elsif options.include?("Prompt")
                   options["Prompt"]
                 elsif options.include?("String")
                   Regexp.new( Regexp.quote(options["String"]) )
                 end
d406 2
@


1.1.1.1.2.6
log
@thread bugs
@
text
@a1 1
$Date: 1999/06/04 06:24:58 $
d3 1
a3 1
== SIMPLE TELNET CLIANT LIBRARY
d5 2
a6 3
telnet.rb

Version 0.20
a7 1
Wakou Aoyama <wakou@@fsinet.or.jp>
d9 1
d11 1
a11 1
=== MAKE NEW TELNET OBJECT
d18 1
a18 1
	                   "Prompt" => /[$%#>] \z/n,     # default: /[$%#>] \z/n
d32 1
a32 1
=== STATUS OUTPUT
d40 2
a41 2
	Trying localhost...
	Connected to localhost.
d44 1
a44 1
=== WAIT FOR MATCH
d54 1
a54 1
==== REALTIME OUTPUT
d64 1
a64 1
=== SEND STRING AND WAIT PROMPT
d68 1
a68 1
	                 "Prompt" => /[$%#>] \z/n,
d72 1
a72 1
==== REALTIME OUTPUT
d76 1
a76 1
	          "Prompt" => /[$%#>] \z/n,
d82 1
a82 1
=== SEND STRING
d87 1
a87 1
=== TURN TELNET COMMAND INTERPRETATION
d94 1
a94 1
=== TOGGLE NEWLINE TRANSLATION
d101 1
a101 1
=== LOGIN
d106 1
a106 1
	            "Prompt" => /[$%#>] \z/n,
d110 1
a110 1
==== REALTIME OUTPUT
d115 1
a115 1
	            "Prompt" => /[$%#>] \z/n,
d121 1
a121 1
== EXAMPLE
d123 1
a123 1
=== LOGIN AND SEND COMMAND
d127 1
a127 1
	                        "Prompt" => /[$%#>] \z/n})
d133 1
a133 1
=== CHECKS A POP SERVER TO SEE IF YOU HAVE MAIL
d138 1
a138 1
	                  "Prompt" => /^\+OK/n})
d144 1
a144 14
== HISTORY

=== Version 0.20
waitfor: support for divided telnet command

=== Version 0.181 1999/05/22
bug fix: print method

=== Version 0.18 1999/05/14
respond to "IAC WON'T SGA" with "IAC DON'T SGA"

DON'T SGA : end of line --> CR + LF

bug fix: preprocess method
d146 3
a148 2
=== Version 0.17 1999/04/30
bug fix: $! + "\n"  -->  $!.to_s + "\n"
d150 1
a150 1
=== Version 0.163 1999/04/11
d153 1
a153 1
=== Version 0.162 1999/03/17
a154 1

d157 1
a157 1
=== Version 0.161 1999/02/03
d160 1
a160 1
=== Version 0.16 1998/10/09
a161 1

d163 1
a163 2

change default Binmode 
d166 1
a166 1
=== Version 0.15 1998/10/04
d169 1
a169 1
=== Version 0.141 1998/09/22
d171 1
a171 1
	/[$%#>] $/ --> /[$%#>] \Z/
d173 1
a173 1
=== Version 0.14 1998/09/01
a174 1

a175 1

a176 1

d179 1
a179 1
=== Version 0.13 1998/08/25
d182 1
a182 1
=== Version 0.122 1998/08/05
a183 1

d186 1
a186 1
=== Version 0.121 1998/07/15
d189 1
a189 1
=== Version 0.12 1998/06/01
d192 1
a192 1
=== Version 0.11 1998/04/21
d195 1
a195 1
=== Version 0.10 1998/04/13
d208 63
a270 63
  IAC   = 255.chr # "\377" # interpret as command:
  DONT  = 254.chr # "\376" # you are not to use option
  DO    = 253.chr # "\375" # please, you use option
  WONT  = 252.chr # "\374" # I won't use option
  WILL  = 251.chr # "\373" # I will use option
  SB    = 250.chr # "\372" # interpret as subnegotiation
  GA    = 249.chr # "\371" # you may reverse the line
  EL    = 248.chr # "\370" # erase the current line
  EC    = 247.chr # "\367" # erase the current character
  AYT   = 246.chr # "\366" # are you there
  AO    = 245.chr # "\365" # abort output--but let prog finish
  IP    = 244.chr # "\364" # interrupt process--permanently
  BREAK = 243.chr # "\363" # break
  DM    = 242.chr # "\362" # data mark--for connect. cleaning
  NOP   = 241.chr # "\361" # nop
  SE    = 240.chr # "\360" # end sub negotiation
  EOR   = 239.chr # "\357" # end of record (transparent mode)
  ABORT = 238.chr # "\356" # Abort process
  SUSP  = 237.chr # "\355" # Suspend process
  EOF   = 236.chr # "\354" # End of file
  SYNCH = 242.chr # "\362" # for telfunc calls

  OPT_BINARY         =   0.chr # "\000" # Binary Transmission
  OPT_ECHO           =   1.chr # "\001" # Echo
  OPT_RCP            =   2.chr # "\002" # Reconnection
  OPT_SGA            =   3.chr # "\003" # Suppress Go Ahead
  OPT_NAMS           =   4.chr # "\004" # Approx Message Size Negotiation
  OPT_STATUS         =   5.chr # "\005" # Status
  OPT_TM             =   6.chr # "\006" # Timing Mark
  OPT_RCTE           =   7.chr # "\a"   # Remote Controlled Trans and Echo
  OPT_NAOL           =   8.chr # "\010" # Output Line Width
  OPT_NAOP           =   9.chr # "\t"   # Output Page Size
  OPT_NAOCRD         =  10.chr # "\n"   # Output Carriage-Return Disposition
  OPT_NAOHTS         =  11.chr # "\v"   # Output Horizontal Tab Stops
  OPT_NAOHTD         =  12.chr # "\f"   # Output Horizontal Tab Disposition
  OPT_NAOFFD         =  13.chr # "\r"   # Output Formfeed Disposition
  OPT_NAOVTS         =  14.chr # "\016" # Output Vertical Tabstops
  OPT_NAOVTD         =  15.chr # "\017" # Output Vertical Tab Disposition
  OPT_NAOLFD         =  16.chr # "\020" # Output Linefeed Disposition
  OPT_XASCII         =  17.chr # "\021" # Extended ASCII
  OPT_LOGOUT         =  18.chr # "\022" # Logout
  OPT_BM             =  19.chr # "\023" # Byte Macro
  OPT_DET            =  20.chr # "\024" # Data Entry Terminal
  OPT_SUPDUP         =  21.chr # "\025" # SUPDUP
  OPT_SUPDUPOUTPUT   =  22.chr # "\026" # SUPDUP Output
  OPT_SNDLOC         =  23.chr # "\027" # Send Location
  OPT_TTYPE          =  24.chr # "\030" # Terminal Type
  OPT_EOR            =  25.chr # "\031" # End of Record
  OPT_TUID           =  26.chr # "\032" # TACACS User Identification
  OPT_OUTMRK         =  27.chr # "\e"   # Output Marking
  OPT_TTYLOC         =  28.chr # "\034" # Terminal Location Number
  OPT_3270REGIME     =  29.chr # "\035" # Telnet 3270 Regime
  OPT_X3PAD          =  30.chr # "\036" # X.3 PAD
  OPT_NAWS           =  31.chr # "\037" # Negotiate About Window Size
  OPT_TSPEED         =  32.chr # " "    # Terminal Speed
  OPT_LFLOW          =  33.chr # "!"    # Remote Flow Control
  OPT_LINEMODE       =  34.chr # "\""   # Linemode
  OPT_XDISPLOC       =  35.chr # "#"    # X Display Location
  OPT_OLD_ENVIRON    =  36.chr # "$"    # Environment Option
  OPT_AUTHENTICATION =  37.chr # "%"    # Authentication Option
  OPT_ENCRYPT        =  38.chr # "&"    # Encryption Option
  OPT_NEW_ENVIRON    =  39.chr # "'"    # New Environment Option
  OPT_EXOPL          = 255.chr # "\377" # Extended-Options-List
a275 5
v = $-v
$-v = false
  VERSION = "0.20"
  RELEASE_DATE = "$Date: 1999/06/04 06:24:58 $"
$-v = v
d279 7
a285 7
    @@options["Binmode"]    = FALSE         if not @@options.include?("Binmode")
    @@options["Host"]       = "localhost"   if not @@options.include?("Host")
    @@options["Port"]       = 23            if not @@options.include?("Port")
    @@options["Prompt"]     = /[$%#>] \z/n  if not @@options.include?("Prompt")
    @@options["Telnetmode"] = TRUE          if not @@options.include?("Telnetmode")
    @@options["Timeout"]    = 10            if not @@options.include?("Timeout")
    @@options["Waittime"]   = 0             if not @@options.include?("Waittime")
d336 1
a336 1
  end # initialize
d356 1
a356 2
  def preprocess(string)
    str = string.dup
d358 4
a361 5
    # combine CR+NULL into CR
    str.gsub!(/#{CR}#{NULL}/no, CR) if @@options["Telnetmode"]

    # combine EOL into "\n"
    str.gsub!(/#{EOL}/no, "\n") if not @@options["Binmode"]
d364 2
a365 2
    str.gsub!(/([^#{IAC}]?)#{IAC}#{DO}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_BINARY == $2
d369 1
a369 1
        @@sock.write(IAC + WONT + $2)
d371 1
a371 1
      $1
d375 3
a377 3
    str.gsub!(/([^#{IAC}]?)#{IAC}#{DONT}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      @@sock.write(IAC + WONT + $2)
      $1
d381 2
a382 4
    str.gsub!(/([^#{IAC}]?)#{IAC}#{WILL}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_ECHO == $2
        @@sock.write(IAC + DO + OPT_ECHO)
      elsif OPT_SGA == $2
d386 1
a386 1
      $1
d389 2
a390 10
    # respond to "IAC WON'T x"
    str.gsub!(/([^#{IAC}]?)#{IAC}#{WONT}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_ECHO == $2
        @@sock.write(IAC + DONT + OPT_ECHO)
      elsif OPT_SGA == $2
        @@telnet_option["SGA"] = FALSE
        @@sock.write(IAC + DONT + OPT_SGA)
      end
      $1
    }
d393 1
a393 1
    str.gsub!(/([^#{IAC}]?)#{IAC}#{AYT}/no){
d395 1
a395 1
      $1
d398 2
a399 4
    str.gsub!(/#{IAC}#{IAC}/no, IAC) # handle escaped IAC characters

    str
  end # preprocess
a419 1
    buf = ''
d423 1
d425 6
a430 9
        c = @@sock.sysread(1024 * 1024)
        @@dumplog.print(c) if @@options.include?("Dump_log")
        buf.concat c
        if @@options["Telnetmode"]
          buf = preprocess(buf) 
          if /#{IAC}.?\z/no === buf
            next
          end 
        end 
a433 3
        buf = ''
      rescue EOFError # End of file reached
        break
d440 4
a443 5
    str = string.dup + "\n"

    str.gsub!(/#{IAC}/no, IAC + IAC) if @@options["Telnetmode"]

    if not @@options["Binmode"]
d446 1
a446 1
        str.gsub!(/\n/n, CR)
d449 1
a449 1
        str.gsub!(/\n/n, CR + NULL)
d451 2
a452 2
        # NONE send EOL --> CR+LF
        str.gsub!(/\n/n, EOL)
a454 2

    @@sock.write(str)
d487 1
a487 1
      line = waitfor(/login[: ]*\z/n){|c| yield c }
d489 1
a489 1
                        "Match" => /Password[: ]*\z/n}){|c| yield c } )
d492 1
a492 1
      line = waitfor(/login[: ]*\z/n)
d494 1
a494 1
                        "Match" => /Password[: ]*\z/n}) )
@


1.1.1.1.2.7
log
@990715
@
text
@d2 1
a2 1
$Date: 1999/06/29 09:08:51 $
d8 1
a8 1
Version 0.22
a22 1
	                     # if ignore timeout then set "Timeout" to FALSE.
a51 1
	                       # if ignore timeout then set "Timeout" to FALSE.
a147 12
=== Version 0.22

1999/06/29 09:08:51

- new, waitfor, cmd: {"Timeout" => FALSE}  # ignore timeout

=== Version 0.21

1999/06/28 18:18:55

- waitfor: not rescue (EOFError)

d149 1
d151 2
a152 27
1999/06/04 06:24:58

- waitfor: support for divided telnet command

=== Version 0.181

1999/05/22

- bug fix: print method

=== Version 0.18

1999/05/14

- respond to "IAC WON'T SGA" with "IAC DON'T SGA"
- DON'T SGA : end of line --> CR + LF
- bug fix: preprocess method

=== Version 0.17

1999/04/30

- bug fix: $! + "\n"  -->  $!.to_s + "\n"

=== Version 0.163

1999/04/11
d154 2
a155 1
- STDOUT.write(message) --> yield(message) if iterator?
d157 1
a157 1
=== Version 0.162
d159 1
a159 1
1999/03/17
d161 2
a162 2
- add "Proxy" option
- required timeout.rb
d164 2
a165 1
=== Version 0.161
d167 2
a168 1
1999/02/03
d170 1
a170 1
- select --> IO::select
d172 2
a173 1
=== Version 0.16
d175 2
a176 1
1998/10/09
d178 1
a178 3
- preprocess method change for the better
- add binmode method.
- change default Binmode. TRUE --> FALSE
d180 2
a181 1
=== Version 0.15
d183 2
a184 1
1998/10/04
d186 3
a188 1
- add telnetmode method.
d190 2
a191 1
=== Version 0.141
d193 1
a193 1
1998/09/22
d195 1
a195 1
- change default prompt. /[$%#>] $/ --> /[$%#>] \Z/
d197 1
a197 1
=== Version 0.14
d199 2
a200 1
1998/09/01
d202 2
a203 4
- IAC WILL SGA             send EOL --> CR+NULL
- IAC WILL SGA IAC DO BIN  send EOL --> CR
- NONE                     send EOL --> LF
- add Dump_log option.
d205 1
a205 1
=== Version 0.13
d207 2
a208 1
1998/08/25
d210 2
a211 1
- add print method.
d213 2
a214 1
=== Version 0.122
d216 2
a217 28
1998/08/05

- support for HP-UX 10.20    thanks to WATANABE Tetsuya <tetsu@@jpn.hp.com>
- socket.<< --> socket.write

=== Version 0.121

1998/07/15

- string.+= --> string.concat

=== Version 0.12

1998/06/01

- add timeout, waittime.

=== Version 0.11

1998/04/21

- add realtime output.

=== Version 0.10

1998/04/13

- first release.
d299 2
a300 2
  VERSION = "0.22"
  RELEASE_DATE = "$Date: 1999/06/29 09:08:51 $"
d305 7
a311 7
    @@options["Binmode"]    = FALSE         unless @@options.key?("Binmode")
    @@options["Host"]       = "localhost"   unless @@options.key?("Host")
    @@options["Port"]       = 23            unless @@options.key?("Port")
    @@options["Prompt"]     = /[$%#>] \z/n  unless @@options.key?("Prompt")
    @@options["Telnetmode"] = TRUE          unless @@options.key?("Telnetmode")
    @@options["Timeout"]    = 10            unless @@options.key?("Timeout")
    @@options["Waittime"]   = 0             unless @@options.key?("Waittime")
d315 1
a315 1
    if @@options.key?("Output_log")
d321 1
a321 1
    if @@options.key?("Dump_log")
d327 1
a327 1
    if @@options.key?("Proxy")
d338 2
a339 2
      @@log.write(message) if @@options.key?("Output_log")
      @@dumplog.write(message) if @@options.key?("Dump_log")
d342 1
a342 1
        if @@options["Timeout"] == FALSE
d344 1
a344 5
        else
          timeout(@@options["Timeout"]){
            @@sock = TCPsocket.open(@@options["Host"], @@options["Port"])
          }
        end
d348 2
a349 2
        @@log.write($!.to_s + "\n") if @@options.key?("Output_log")
        @@dumplog.write($!.to_s + "\n") if @@options.key?("Dump_log")
d357 2
a358 2
      @@log.write(message) if @@options.key?("Output_log")
      @@dumplog.write(message) if @@options.key?("Dump_log")
d389 1
a389 1
    str.gsub!(/#{EOL}/no, "\n") unless @@options["Binmode"]
d446 1
a446 1
      prompt   = if options.key?("Match")
d448 1
a448 1
                 elsif options.key?("Prompt")
d450 1
a450 1
                 elsif options.key?("String")
d453 2
a454 2
      time_out = options["Timeout"]  if options.key?("Timeout")
      waittime = options["Waittime"] if options.key?("Waittime")
a458 4
    if time_out == FALSE
      time_out = nil
    end

d462 18
a479 2
      unless IO::select([@@sock], nil, nil, time_out)
        raise TimeOut, "timed-out; wait for the next data"
a480 13
      c = @@sock.sysread(1024 * 1024)
      @@dumplog.print(c) if @@options.key?("Dump_log")
      buf.concat c
      if @@options["Telnetmode"]
        buf = preprocess(buf) 
        if /#{IAC}.?\z/no === buf
          next
        end 
      end 
      @@log.print(buf) if @@options.key?("Output_log")
      yield buf if iterator?
      line.concat(buf)
      buf = ''
d490 1
a490 1
    unless @@options["Binmode"]
d512 2
a513 2
      match    = options["Match"]   if options.key?("Match")
      time_out = options["Timeout"] if options.key?("Timeout")
@


1.1.1.1.2.8
log
@backtrace may be Qnil
@
text
@d2 1
a2 1
$Date: 1999/07/16 13:39:42 $
d8 1
a8 1
Version 0.231
d15 1
a15 1
	host = Telnet.new({"Binmode" => false,           # default: false
d21 1
a21 1
	                   "Telnetmode" => true,         # default: true
d23 1
a23 1
	                     # if ignore timeout then set "Timeout" to false.
d30 1
a30 1
if set "Telnetmode" option to false. not telnet command interpretation.
d53 1
a53 1
	                       # if ignore timeout then set "Timeout" to false.
d55 1
a55 1
if set "String" option, then Match == Regexp.new(quote("string"))
d65 1
a65 1
of cource, set sync=true or flush is necessary.
d83 1
a83 1
of cource, set sync=true or flush is necessary.
d94 2
a95 2
	host.telnetmode(true)  # on
	host.telnetmode(false) # off
d100 3
a102 3
	host.binmode        # turn true/false
	host.binmode(true)  # no translate newline
	host.binmode(false) # translate newline
d122 1
a122 1
of cource, set sync=true or flush is necessary.
d141 1
a141 1
	                  "Telnetmode" => false,
a149 12
=== Version 0.231

1999/07/16 13:39:42

- TRUE --> true, FALSE --> false

=== Version 0.23

1999/07/15 22:32:09

- waitfor: if end of file reached, then return nil.

d154 1
a154 1
- new, waitfor, cmd: {"Timeout" => false}  # ignore timeout
d353 2
a354 2
  VERSION = "0.231"
  RELEASE_DATE = "$Date: 1999/07/16 13:39:42 $"
d359 1
a359 1
    @@options["Binmode"]    = false         unless @@options.key?("Binmode")
d363 1
a363 1
    @@options["Telnetmode"] = true          unless @@options.key?("Telnetmode")
d367 1
a367 1
    @@telnet_option = { "SGA" => false, "BINARY" => false }
d371 1
a371 1
      @@log.sync = true
d377 1
a377 1
      @@dumplog.sync = true
d396 1
a396 1
        if @@options["Timeout"] == false
d410 1
a410 1
      @@sock.sync = true
d426 1
a426 1
      @@options["Telnetmode"] = @@options["Telnetmode"] ? false : true
d428 1
a428 1
      @@options["Telnetmode"] = mode ? true : false
d434 1
a434 1
      @@options["Binmode"] = @@options["Binmode"] ? false : true
d436 1
a436 1
      @@options["Binmode"] = mode ? true : false
d452 1
a452 1
        @@telnet_option["BINARY"] = true
d471 1
a471 1
        @@telnet_option["SGA"] = true
d482 1
a482 1
        @@telnet_option["SGA"] = false
d517 1
a517 1
    if time_out == false
d527 7
a533 9
      begin
        c = @@sock.sysread(1024 * 1024)
        @@dumplog.print(c) if @@options.key?("Dump_log")
        buf.concat c
        if @@options["Telnetmode"]
          buf = preprocess(buf) 
          if /#{IAC}.?\z/no === buf
            next
          end 
d535 5
a539 11
        @@log.print(buf) if @@options.key?("Output_log")
        yield buf if iterator?
        line.concat(buf)
        buf = ''
      rescue EOFError # End of file reached
        if line == ''
          line = nil
          yield nil if iterator?
        end
        break
      end
d578 1
a578 1
    self.print(string)
@


1.1.1.1.2.9
log
@1.3.8 to be, final beta (hopefully)
@
text
@d2 1
a2 1
$Date: 1999/08/10 05:20:21 $
d8 1
a8 1
Version 0.232
d37 1
a37 1
	host = Telnet.new({"Host" => "localhost"){|c| print c }
a149 8
=== Version 0.232

1999/08/10 05:20:21

- STATUS OUTPUT sample code typo. thanks to Tadayoshi Funaba <tadf@@kt.rim.or.jp>
	host = Telnet.new({"Hosh" => "localhost"){|c| print c }
	host = Telnet.new({"Host" => "localhost"){|c| print c }

d365 2
a366 2
  VERSION = "0.232"
  RELEASE_DATE = "$Date: 1999/08/10 05:20:21 $"
@


1.1.2.1
log
@telnet.rb
@
text
@a0 201
#!/usr/local/bin/ruby
#
# telnet.rb
# ver0.11 1998/04/21
# Wakou Aoyama <wakou@@fsinet.or.jp>
#
# == make new Telnet object
# host = Telnet.new({"Binmode" => TRUE,              default: TRUE
#                    "Host" => "localhost",          default: "localhost"
#                    "Output_log"] => "output_log",  default: not output
#                    "Port" => 23,                   default: 23
#                    "Prompt" => /[$%#>] $/,         default: /[$%#>] $/
#                    "Telnetmode"] => TRUE,          default: TRUE
#                    "Timeout"] => 10}               default: 10
#
# if set "Telnetmode" option FALSE. not TELNET command interpretation.
#
# == wait for match
# print host.waitfor(/match/)
# print host.waitfor({"Match"   => /match/,
#                     "String"  => "string",
#                     "Timeout" => secs})
# if set "String" option. Match = Regexp.new(quote(string))
#
# realtime output. of cource, set sync=TRUE or flush is necessary.
# host.waitfor(/match/){|c| print c }
# host.waitfor({"Match"   => /match/,
#               "String"  => "string",
#               "Timeout" => secs}){|c| print c}
#
# == send string and wait prompt
# print host.cmd("string")
# print host.cmd({"String" => "string",
#                 "Prompt" => /[$%#>] $//,
#                 "Timeout" => 10})
#
# realtime output. of cource, set sync=TRUE or flush is necessary.
# host.cmd("string"){|c| print c }
# host.cmd({"String" => "string",
#           "Prompt" => /[$%#>] $//,
#           "Timeout" => 10}){|c| print c }
#
# == login
# host.login("username", "password")
# host.login({"Name" => "username",
#             "Password" => "password",
#             "Prompt" => /[$%#>] $/,
#             "Timeout" => 10})
#
# and Telnet object has socket class methods
#
# == sample
# localhost = Telnet.new({"Host" => "localhost",
#                         "Timeout" => 10,
#                         "Prompt" => /[$%#>] $/})
# localhost.login("username", "password")
# print localhost.cmd("command")
# localhost.close

require "socket"
require "delegate"

class Telnet < SimpleDelegator
  # For those who are curious, here are some of the special characters
  # interpretted by the telnet protocol:
  # Name     Octal    Dec.  Description
    CR    = "\015"
    LF    = "\012"
    EOL   = CR + LF #       /* end of line */
    IAC   = "\377"  # 255   /* interpret as command: */
    DONT  = "\376"  # 254   /* you are not to use option */
    DO    = "\375"  # 253   /* please, you use option */
    WONT  = "\374"  # 252   /* I won't use option */
    WILL  = "\373"  # 251   /* I will use option */
  # SB    = "\372"  # 250   /* interpret as subnegotiation */
  # GA    = "\371"  # 249   /* you may reverse the line */
  # EL    = "\370"  # 248   /* erase the current line */
  # EC    = "\367"  # 247   /* erase the current character */
    AYT   = "\366"  # 246   /* are you there */
  # AO    = "\365"  # 245   /* abort output--but let prog finish */
  # IP    = "\364"  # 244   /* interrupt process--permanently */
  # BREAK = "\363"  # 243   /* break */
  # DM    = "\362"  # 242   /* data mark--for connect. cleaning */
  # NOP   = "\361"  # 241   /* nop */
  # SE    = "\360"  # 240   /* end sub negotiation */
  # EOR   = "\357"  # 239   /* end of record (transparent mode) */

  def initialize(options)
    @@options = {}
    @@options["Binmode"] = options["Binmode"] || TRUE
    @@options["Dump_Log"] = options["Dump_Log"]
    @@options["Errmode"] = options["Errmode"]
    @@options["Fhopen"] = options["Fhopen"]
    @@options["Host"] = options["Host"] || "localhost"
    @@options["Input_log"] = options["Input_log"]
    @@options["Input_record_separator"] = options["Input_record_separator"]
    @@options["Output_log"] = options["Output_log"]
    @@options["Output_record_separator"] = options["Output_record_separator"]
    @@options["Port"] = options["Port"] || 23
    @@options["Prompt"] = options["Prompt"] || /[$%#>] $/
    @@options["Telnetmode"] = options["Telnetmode"] || TRUE
    @@options["Timeout"] = options["Timeout"] || 10

    if @@options.include?("Output_log")
      @@log = File.open(@@options["Output_log"], 'a+')
      @@log.sync = TRUE
      @@log.binmode if @@options["Binmode"]
    end
    @@sock = TCPsocket.open(@@options["Host"], @@options["Port"])
    @@sock.sync = TRUE
    @@sock.binmode if @@options["Binmode"]
    super(@@sock)
  end

  def preprocess(str)
    str.gsub!(/#{EOL}/no, "\n") # combine EOL into "\n"

    # respond to "IAC DO x" or "IAC DON'T x" with "IAC WON'T x"
    str.gsub!(/([^#{IAC}])?#{IAC}[#{DO}#{DONT}](.|\n)/no){
        @@sock << IAC << WONT << $2
        $1
    }

    # ignore "IAC WILL x" or "IAC WON'T x"
    str.gsub!(/([^#{IAC}])?#{IAC}[#{WILL}#{WONT}](.|\n)/no, '\1')

    # respond to "IAC AYT" (are you there)
    str.gsub!(/([^#{IAC}])?#{IAC}#{AYT}/no){
        @@sock << "nobody here but us pigeons" << CR
        $1
    }

    str.gsub(/#{IAC}#{IAC}/no, IAC) # handle escaped IAC characters
  end

  def waitfor(options)
    prompt = @@options["Prompt"]
    timeout = @@options["Timeout"]
    if options.kind_of?(Hash)
      prompt = options["Prompt"] if options.include?("Prompt")
      timeout = options["Timeout"] if options.include?("Timeout")
      prompt = Regexp.new( Regexp.quote(options["String"]) ) if
        options.include?("String")
    else
      prompt = options
    end
    line = ''
    while (not prompt === line and not @@sock.closed?)
      next if not select([@@sock], nil, nil, timeout)
      begin
        buf = if @@options["Telnetmode"]
                preprocess( @@sock.sysread(1024 * 1024) )
              else
                @@sock.sysread(1024 * 1024)
              end
      rescue
        buf = "\nConnection closed by foreign host.\n"
        @@sock.close
      end
      @@log.print(buf) if @@options.include?("Output_log")
      if iterator?
        yield buf
      end
      line += buf
    end
    line
  end

  def cmd(options)
    match = @@options["Prompt"]
    timeout = @@options["Timeout"]
    if options.kind_of?(Hash)
      string = options["String"]
      match = options["Match"] if options.include?("Match")
      timeout = options["Timeout"] if options.include?("Timeout")
    else
      string = options
    end
    @@sock << string.gsub(/\n/, CR) << CR
    if iterator?
      waitfor({"Prompt" => match, "Timeout" => timeout}){|c| yield c }
    else
      waitfor({"Prompt" => match, "Timeout" => timeout})
    end
  end

  def login(options, password = nil)
    if options.kind_of?(Hash)
      username = options["Name"]
      password = options["Password"]
    else
      username = options
    end

    line = waitfor(/login[: ]*$/)
    line += cmd({"String" => username, "Match" => /Password[: ]*$/})
    line += cmd(password)
    line
  end

end
@


1.1.2.2
log
@telnet.rb
@
text
@d1 1
@


1.1.2.3
log
@tcltklib/gtk
@
text
@d7 7
a13 7
# host = Telnet.new("Binmode" => TRUE,              default: TRUE
#                   "Host" => "localhost",          default: "localhost"
#                   "Output_log" => "output_log",   default: not output
#                   "Port" => 23,                   default: 23
#                   "Prompt" => /[$%#>] $/,         default: /[$%#>] $/
#                   "Telnetmode" => TRUE,           default: TRUE
#                   "Timeout" => 10)                default: 10
d19 3
a21 3
# print host.waitfor("Match"   => /match/,
#                    "String"  => "string",
#                    "Timeout" => secs)
d26 3
a28 3
# host.waitfor("Match"   => /match/,
#              "String"  => "string",
#              "Timeout" => secs){|c| print c}
d32 3
a34 3
# print host.cmd("String" => "string",
#                "Prompt" => /[$%#>] $//,
#                "Timeout" => 10)
d38 3
a40 3
# host.cmd("String" => "string",
#          "Prompt" => /[$%#>] $//,
#          "Timeout" => 10){|c| print c }
d44 4
a47 4
# host.login("Name" => "username",
#            "Password" => "password",
#            "Prompt" => /[$%#>] $/,
#            "Timeout" => 10)
d52 3
a54 3
# localhost = Telnet.new("Host" => "localhost",
#                        "Timeout" => 10,
#                        "Prompt" => /[$%#>] $/)
@


1.1.2.4
log
@1.1b9_30
@
text
@d3 1
a3 1
# ver0.12 1998/06/01
d7 7
a13 8
# host = Telnet.new({"Binmode" => TRUE,              default: TRUE
#                    "Host" => "localhost",          default: "localhost"
#                    "Output_log" => "output_log",   default: not output
#                    "Port" => 23,                   default: 23
#                    "Prompt" => /[$%#>] $/,         default: /[$%#>] $/
#                    "Telnetmode" => TRUE,           default: TRUE
#                    "Timeout" => 10,                default: 10
#                    "Waittime" => 0})               default: 0
a15 3
# "Waittime" is time to confirm "Prompt". There is a possibility that
# the same character as "Prompt" is included in the data, and, when
# the network or the host is very heavy, the value is enlarged.
d18 4
a21 4
# line = host.waitfor(/match/)
# line = host.waitfor({"Match"   => /match/,
#                      "String"  => "string",
#                      "Timeout" => secs})
d26 3
a28 3
# host.waitfor({"Match"   => /match/,
#               "String"  => "string",
#               "Timeout" => secs}){|c| print c}
d31 4
a34 4
# line = host.cmd("string")
# line = host.cmd({"String" => "string",
#                  "Prompt" => /[$%#>] $//,
#                  "Timeout" => 10})
d38 3
a40 3
# host.cmd({"String" => "string",
#           "Prompt" => /[$%#>] $//,
#           "Timeout" => 10}){|c| print c }
d44 4
a47 11
# host.login({"Name" => "username",
#             "Password" => "password",
#             "Prompt" => /[$%#>] $/,
#             "Timeout" => 10})
#
# realtime output. of cource, set sync=TRUE or flush is necessary.
# host.login("username", "password"){|c| print c }
# host.login({"Name" => "username",
#             "Password" => "password",
#             "Prompt" => /[$%#>] $/,
#             "Timeout" => 10}){|c| print c }
d52 5
a56 5
# localhost = Telnet.new({"Host" => "localhost",
#                         "Timeout" => 10,
#                         "Prompt" => /[$%#>] $/})
# localhost.login("username", "password"){|c| print c }
# localhost.cmd("command"){|c| print c }
a60 4
require "thread"

class TimeOut < Exception
end
a62 23

  def timeout(sec)
    is_timeout = FALSE 
    begin
      x = Thread.current
      y = Thread.start {
        sleep sec
        if x.alive?
          #print "timeout!\n"
          x.raise TimeOut, "timeout"
        end
      }
      begin
        yield
      rescue TimeOut
        is_timeout = TRUE
      end
    ensure
      Thread.kill y if y && y.alive?
    end
    is_timeout
  end

d88 14
a101 8
    @@options = options
    @@options["Binmode"]    = TRUE        if not @@options.include?("Binmode")
    @@options["Host"]       = "localhost" if not @@options.include?("Host")
    @@options["Port"]       = 23          if not @@options.include?("Port")
    @@options["Prompt"]     = /[$%#>] $/  if not @@options.include?("Prompt")
    @@options["Telnetmode"] = TRUE        if not @@options.include?("Telnetmode")
    @@options["Timeout"]    = 10          if not @@options.include?("Timeout")
    @@options["Waittime"]   = 0           if not @@options.include?("Waittime")
d108 1
a108 14

    message = "Trying " + @@options["Host"] + "...\n"
    STDOUT << message
    @@log << message if @@options.include?("Output_log")

    is_timeout = timeout(@@options["Timeout"]){
      begin
        @@sock = TCPsocket.open(@@options["Host"], @@options["Port"])
      rescue
        @@log << $! << "\n" if @@options.include?("Output_log")
        raise
      end
    }
    raise TimeOut, "timed-out; opening of the host" if is_timeout
a110 5

    message = "Connected to " + @@options["Host"] + ".\n"
    STDOUT << message
    @@log << message if @@options.include?("Output_log")

d136 2
a137 3
    timeout  = @@options["Timeout"]
    waittime = @@options["Waittime"]

d139 3
a141 4
      prompt   = options["Prompt"]   if options.include?("Prompt")
      timeout  = options["Timeout"]  if options.include?("Timeout")
      waittime = options["Waittime"] if options.include?("Waittime")
      prompt   = Regexp.new( Regexp.quote(options["String"]) ) if
a145 1

d147 2
a148 4
    until(not select([@@sock], nil, nil, waittime) and prompt === line)
      raise TimeOut, "timed-out; wait for the next data" if
        not select([@@sock], nil, nil, timeout)
      buf = ''
d155 7
a161 6
      rescue EOFError # End of file reached
        break
      ensure
        @@log.print(buf) if @@options.include?("Output_log")
        yield buf if iterator?
        line += buf
d163 1
d169 1
a169 1
    match   = @@options["Prompt"]
a170 1

d172 2
a173 2
      string  = options["String"]
      match   = options["Match"]   if options.include?("Match")
a177 2

    select(nil, [@@sock])
d186 1
a186 1
  def login(options, password = '')
d194 3
a196 11
    if iterator?
      line = waitfor(/login[: ]*$/){|c| yield c }
      line += cmd({"String" => username,
                   "Match" => /Password[: ]*$/}){|c| yield c }
      line += cmd(password){|c| yield c }
    else
      line = waitfor(/login[: ]*$/)
      line += cmd({"String" => username,
                   "Match" => /Password[: ]*$/})
      line += cmd(password)
    end
@


1.1.2.5
log
@1.1c2
@
text
@d3 1
a3 1
# ver0.122 1998/08/05
a5 16
# ver0.122 1998/08/05
# support for HP-UX 10.20    thanks to WATANABE Tetsuya <tetsu@@jpn.hp.com>
# socket.<< --> socket.write
#
# ver0.121 1998/07/15
# string.+= --> string.concat
#
# ver0.12 1998/06/01
# add timeout, waittime.
#
# ver0.11 1998/04/21
# add realtime output.
#
# ver0.10 1998/04/13
# first release.
#
d142 2
a143 2
    STDOUT.write(message)
    @@log.write(message) if @@options.include?("Output_log")
d149 1
a149 1
        @@log.write($! + "\n") if @@options.include?("Output_log")
d158 2
a159 2
    STDOUT.write(message)
    @@log.write(message) if @@options.include?("Output_log")
d169 1
a169 1
        @@sock.write(IAC + WONT + $2)
d178 1
a178 1
        @@sock.write("nobody here but us pigeons" + CR)
d215 1
a215 1
        line.concat(buf)
d234 1
a234 1
    @@sock.write(string.gsub(/\n/, CR) + CR)
d252 3
a254 3
      line.concat( cmd({"String" => username,
                        "Match" => /Password[: ]*$/}){|c| yield c } )
      line.concat( cmd(password){|c| yield c } )
d257 3
a259 3
      line.concat( cmd({"String" => username,
                        "Match" => /Password[: ]*$/}) )
      line.concat( cmd(password) )
@


1.1.2.6
log
@1.1c3
@
text
@d3 1
a3 1
# ver0.13 1998/08/25
a5 3
# ver0.13 1998/08/25
# add print method.
#
a61 3
# == send string
# host.print("string")
#
a84 11
#
# == sample 2
# checks a POP server to see if you have mail.
#
# pop = Telnet.new({"Host" => "your_destination_host_here",
#                   "Port" => 110,
#                   "Telnetmode" => FALSE,
#                   "Prompt" => /^\+OK/})
# pop.cmd("user " + "your_username_here"){|c| print c}
# pop.cmd("pass " + "your_password_here"){|c| print c}
# pop.cmd("list"){|c| print c}
d194 1
a194 1
        @@sock.write("nobody here but us pigeons" + EOL)
a236 4
  def print(string)
    @@sock.write(string.gsub(/\n/, EOL) + EOL)
  end

d250 1
a250 1
    @@sock.write(string.gsub(/\n/, EOL) + EOL)
@


1.1.2.7
log
@1.1c4
@
text
@d3 1
a3 1
# ver0.14 1998/09/01
a5 6
# ver0.14 1998/09/01
# IAC WILL SGA             send EOL --> CR+NULL
# IAC WILL SGA IAC DO BIN  send EOL --> CR
# NONE                     send EOL --> LF
# add Dump_log option.
#
a28 1
#                    "Dump_log" => "dump_log",       default: not output
d134 23
a156 67
  IAC   = 255.chr  # interpret as command:
  DONT  = 254.chr  # you are not to use option
  DO    = 253.chr  # please, you use option
  WONT  = 252.chr  # I won't use option
  WILL  = 251.chr  # I will use option
  SB    = 250.chr  # interpret as subnegotiation
  GA    = 249.chr  # you may reverse the line
  EL    = 248.chr  # erase the current line
  EC    = 247.chr  # erase the current character
  AYT   = 246.chr  # are you there
  AO    = 245.chr  # abort output--but let prog finish
  IP    = 244.chr  # interrupt process--permanently
  BREAK = 243.chr  # break
  DM    = 242.chr  # data mark--for connect. cleaning
  NOP   = 241.chr  # nop
  SE    = 240.chr  # end sub negotiation
  EOR   = 239.chr  # end of record (transparent mode)
  ABORT = 238.chr  # Abort process
  SUSP  = 237.chr  # Suspend process
  EOF   = 236.chr  # End of file
  SYNCH = 242.chr  # for telfunc calls

  OPT_BINARY         =   0.chr  # Binary Transmission
  OPT_ECHO           =   1.chr  # Echo
  OPT_RCP            =   2.chr  # Reconnection
  OPT_SGA            =   3.chr  # Suppress Go Ahead
  OPT_NAMS           =   4.chr  # Approx Message Size Negotiation
  OPT_STATUS         =   5.chr  # Status
  OPT_TM             =   6.chr  # Timing Mark
  OPT_RCTE           =   7.chr  # Remote Controlled Trans and Echo
  OPT_NAOL           =   8.chr  # Output Line Width
  OPT_NAOP           =   9.chr  # Output Page Size
  OPT_NAOCRD         =  10.chr  # Output Carriage-Return Disposition
  OPT_NAOHTS         =  11.chr  # Output Horizontal Tab Stops
  OPT_NAOHTD         =  12.chr  # Output Horizontal Tab Disposition
  OPT_NAOFFD         =  13.chr  # Output Formfeed Disposition
  OPT_NAOVTS         =  14.chr  # Output Vertical Tabstops
  OPT_NAOVTD         =  15.chr  # Output Vertical Tab Disposition
  OPT_NAOLFD         =  16.chr  # Output Linefeed Disposition
  OPT_XASCII         =  17.chr  # Extended ASCII
  OPT_LOGOUT         =  18.chr  # Logout
  OPT_BM             =  19.chr  # Byte Macro
  OPT_DET            =  20.chr  # Data Entry Terminal
  OPT_SUPDUP         =  21.chr  # SUPDUP
  OPT_SUPDUPOUTPUT   =  22.chr  # SUPDUP Output
  OPT_SNDLOC         =  23.chr  # Send Location
  OPT_TTYPE          =  24.chr  # Terminal Type
  OPT_EOR            =  25.chr  # End of Record
  OPT_TUID           =  26.chr  # TACACS User Identification
  OPT_OUTMRK         =  27.chr  # Output Marking
  OPT_TTYLOC         =  28.chr  # Terminal Location Number
  OPT_3270REGIME     =  29.chr  # Telnet 3270 Regime
  OPT_X3PAD          =  30.chr  # X.3 PAD
  OPT_NAWS           =  31.chr  # Negotiate About Window Size
  OPT_TSPEED         =  32.chr  # Terminal Speed
  OPT_LFLOW          =  33.chr  # Remote Flow Control
  OPT_LINEMODE       =  34.chr  # Linemode
  OPT_XDISPLOC       =  35.chr  # X Display Location
  OPT_OLD_ENVIRON    =  36.chr  # Environment Option
  OPT_AUTHENTICATION =  37.chr  # Authentication Option
  OPT_ENCRYPT        =  38.chr  # Encryption Option
  OPT_NEW_ENVIRON    =  39.chr  # New Environment Option

  NULL = "\000"
  CR   = "\015"
  LF   = "\012"
  EOL  = CR + LF
a167 2
    @@telnet_option = { "SGA" => FALSE, "BINARY" => FALSE }

a173 6
    if @@options.include?("Dump_log")
      @@dumplog = File.open(@@options["Dump_log"], 'a+')
      @@dumplog.sync = TRUE
      @@dumplog.binmode
    end

a176 1
    @@dumplog.write(message) if @@options.include?("Dump_log")
a182 1
        @@dumplog.write($! + "\n") if @@options.include?("Dump_log")
a192 1
    @@dumplog.write(message) if @@options.include?("Dump_log")
d198 1
a198 2
    str.gsub!(/#{CR}#{NULL}/no, CR) # combine CR+NULL into CR
    str.gsub!(/#{EOL}/no, "\n")     # combine EOL into "\n"
d200 2
a201 7
    # respond to "IAC DO x"
    str.gsub!(/([^#{IAC}])?#{IAC}#{DO}(.|\n)/no){
      if OPT_BINARY == $2
        @@telnet_option["BINARY"] = TRUE
        @@sock.write(IAC + WILL + OPT_BINARY)
        $1
      else
a203 1
      end
d206 2
a207 19
    # respond to "IAC DON'T x" with "IAC WON'T x"
    str.gsub!(/([^#{IAC}])?#{IAC}#{DONT}(.|\n)/no){
      @@sock.write(IAC + WONT + $2)
      $1
    }

    # respond to "IAC WILL x"
    str.gsub!(/([^#{IAC}])?#{IAC}#{WILL}(.|\n)/no){
      if OPT_SGA == $2
        @@telnet_option["SGA"] = TRUE
        @@sock.write(IAC + DO + OPT_SGA)
        $1
      else
        $1
      end
    }

    # ignore "IAC WON'T x"
    str.gsub!(/([^#{IAC}])?#{IAC}#{WONT}(.|\n)/no, '\1')
d211 2
a212 2
      @@sock.write("nobody here but us pigeons" + EOL)
      $1
d238 5
a242 3
        buf = @@sock.sysread(1024 * 1024)
        @@dumplog.print(buf) if @@options.include?("Dump_log")
        buf = preprocess(buf) if @@options["Telnetmode"]
d255 1
a255 10
    if @@telnet_option["BINARY"] and @@telnet_option["SGA"]
      # IAC WILL SGA IAC DO BIN send EOL --> CR
      @@sock.write(string.gsub(/\n/, CR) + CR)
    elsif @@telnet_option["SGA"]
      # IAC WILL SGA send EOL --> CR+NULL
      @@sock.write(string.gsub(/\n/, CR + NULL) + CR + NULL)
    else
      # NONE send EOL --> LF
      @@sock.write(string.gsub(/\n/, LF) + LF)
    end
d271 1
a271 1
    print(string)
@


1.1.2.7.2.1
log
@join 1.1c6
@
text
@d3 1
a3 1
# ver0.141 1998/09/22
a5 4
# ver0.141 1998/09/22
# change default prompt
# /[$%#>] $/ --> /[$%#>] \Z/
#
d37 1
a37 1
#                    "Prompt" => /[$%#>] \Z/,        default: /[$%#>] \Z/
d63 1
a63 1
#                  "Prompt" => /[$%#>] \Z/,
d69 1
a69 1
#           "Prompt" => /[$%#>] \Z/,
d79 1
a79 1
#             "Prompt" => /[$%#>] \Z/,
d86 1
a86 1
#             "Prompt" => /[$%#>] \Z/,
d94 1
a94 1
#                         "Prompt" => /[$%#>] \Z/})
d211 7
a217 7
    @@options["Binmode"]    = TRUE         if not @@options.include?("Binmode")
    @@options["Host"]       = "localhost"  if not @@options.include?("Host")
    @@options["Port"]       = 23           if not @@options.include?("Port")
    @@options["Prompt"]     = /[$%#>] \Z/  if not @@options.include?("Prompt")
    @@options["Telnetmode"] = TRUE         if not @@options.include?("Telnetmode")
    @@options["Timeout"]    = 10           if not @@options.include?("Timeout")
    @@options["Waittime"]   = 0            if not @@options.include?("Waittime")
d381 1
a381 1
      line = waitfor(/login[: ]*\Z/){|c| yield c }
d383 1
a383 1
                        "Match" => /Password[: ]*\Z/}){|c| yield c } )
d386 1
a386 1
      line = waitfor(/login[: ]*\Z/)
d388 1
a388 1
                        "Match" => /Password[: ]*\Z/}) )
@


1.1.2.7.2.2
log
@*** empty log message ***
@
text
@d3 1
a3 1
# ver0.16 1998/10/09
a5 9
# ver0.16 1998/10/09
# preprocess method change for the better
# add binmode method.
# change default Binmode
# TRUE --> FALSE
#
# ver0.15 1998/10/04
# add telnetmode method.
#
d36 1
a36 1
# host = Telnet.new({"Binmode" => FALSE,             default: FALSE
a78 10
# == turn telnet command interpretation
# host.telnetmode        # turn on/off
# host.telnetmode(TRUE)  # on
# host.telnetmode(FALSE) # off
#
# == toggle newline translation
# host.binmode        # turn TRUE/FALSE
# host.binmode(TRUE)  # no translate newline
# host.binmode(FALSE) # translate newline
#
a206 1
  OPT_EXOPL          = 255.chr  # Extended-Options-List
d215 1
a215 1
    @@options["Binmode"]    = FALSE        if not @@options.include?("Binmode")
d228 1
a228 1
      @@log.binmode
d253 1
a253 1
    @@sock.binmode
a262 16
  def telnetmode(mode = 'turn')
    if 'turn' == mode
      @@options["Telnetmode"] = @@options["Telnetmode"] ? FALSE : TRUE
    else
      @@options["Telnetmode"] = mode ? TRUE : FALSE
    end
  end

  def binmode(mode = 'turn')
    if 'turn' == mode
      @@options["Binmode"] = @@options["Binmode"] ? FALSE : TRUE
    else
      @@options["Binmode"] = mode ? TRUE : FALSE
    end
  end

d264 2
a265 5

    if not @@options["Binmode"]
      str.gsub!(/#{CR}#{NULL}/no, CR) # combine CR+NULL into CR
      str.gsub!(/#{EOL}/no, "\n")     # combine EOL into "\n"
    end
d268 2
a269 2
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{DO}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_BINARY == $1
d272 1
d274 2
a275 1
        @@sock.write(IAC + WONT + $1)
a276 1
      ''
d280 3
a282 3
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{DONT}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      @@sock.write(IAC + WONT + $1)
      ''
d286 2
a287 2
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{WILL}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_SGA == $1
d290 3
a293 1
      ''
d297 1
a297 1
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{WONT}[#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}]/no, '')
d300 1
a300 1
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{AYT}/no){
d302 1
a302 1
      ''
d343 6
a348 3
    string.gsub!(/#{IAC}/no, IAC + IAC) if @@options["Telnetmode"]
    if @@options["Binmode"]
      @@sock.write(string)
d350 2
a351 10
      if @@telnet_option["BINARY"] and @@telnet_option["SGA"]
        # IAC WILL SGA IAC DO BIN send EOL --> CR
        @@sock.write(string.gsub(/\n/, CR) + CR)
      elsif @@telnet_option["SGA"]
        # IAC WILL SGA send EOL --> CR+NULL
        @@sock.write(string.gsub(/\n/, CR + NULL) + CR + NULL)
      else
        # NONE send EOL --> LF
        @@sock.write(string.gsub(/\n/, LF) + LF)
      end
@


1.1.2.8
log
@1.1c6
@
text
@d3 1
a3 1
# ver0.141 1998/09/22
a5 4
# ver0.141 1998/09/22
# change default prompt
# /[$%#>] $/ --> /[$%#>] \Z/
#
d37 1
a37 1
#                    "Prompt" => /[$%#>] \Z/,        default: /[$%#>] \Z/
d63 1
a63 1
#                  "Prompt" => /[$%#>] \Z/,
d69 1
a69 1
#           "Prompt" => /[$%#>] \Z/,
d79 1
a79 1
#             "Prompt" => /[$%#>] \Z/,
d86 1
a86 1
#             "Prompt" => /[$%#>] \Z/,
d94 1
a94 1
#                         "Prompt" => /[$%#>] \Z/})
d211 7
a217 7
    @@options["Binmode"]    = TRUE         if not @@options.include?("Binmode")
    @@options["Host"]       = "localhost"  if not @@options.include?("Host")
    @@options["Port"]       = 23           if not @@options.include?("Port")
    @@options["Prompt"]     = /[$%#>] \Z/  if not @@options.include?("Prompt")
    @@options["Telnetmode"] = TRUE         if not @@options.include?("Telnetmode")
    @@options["Timeout"]    = 10           if not @@options.include?("Timeout")
    @@options["Waittime"]   = 0            if not @@options.include?("Waittime")
d381 1
a381 1
      line = waitfor(/login[: ]*\Z/){|c| yield c }
d383 1
a383 1
                        "Match" => /Password[: ]*\Z/}){|c| yield c } )
d386 1
a386 1
      line = waitfor(/login[: ]*\Z/)
d388 1
a388 1
                        "Match" => /Password[: ]*\Z/}) )
@


1.1.2.9
log
@1.1c7
@
text
@d3 1
a3 1
# ver0.16 1998/10/09
a5 9
# ver0.16 1998/10/09
# preprocess method change for the better
# add binmode method.
# change default Binmode
# TRUE --> FALSE
#
# ver0.15 1998/10/04
# add telnetmode method.
#
d36 1
a36 1
# host = Telnet.new({"Binmode" => FALSE,             default: FALSE
a78 10
# == turn telnet command interpretation
# host.telnetmode        # turn on/off
# host.telnetmode(TRUE)  # on
# host.telnetmode(FALSE) # off
#
# == toggle newline translation
# host.binmode        # turn TRUE/FALSE
# host.binmode(TRUE)  # no translate newline
# host.binmode(FALSE) # translate newline
#
a206 1
  OPT_EXOPL          = 255.chr  # Extended-Options-List
d215 1
a215 1
    @@options["Binmode"]    = FALSE        if not @@options.include?("Binmode")
d228 1
a228 1
      @@log.binmode
d253 1
a253 1
    @@sock.binmode
a262 16
  def telnetmode(mode = 'turn')
    if 'turn' == mode
      @@options["Telnetmode"] = @@options["Telnetmode"] ? FALSE : TRUE
    else
      @@options["Telnetmode"] = mode ? TRUE : FALSE
    end
  end

  def binmode(mode = 'turn')
    if 'turn' == mode
      @@options["Binmode"] = @@options["Binmode"] ? FALSE : TRUE
    else
      @@options["Binmode"] = mode ? TRUE : FALSE
    end
  end

d264 2
a265 5

    if not @@options["Binmode"]
      str.gsub!(/#{CR}#{NULL}/no, CR) # combine CR+NULL into CR
      str.gsub!(/#{EOL}/no, "\n")     # combine EOL into "\n"
    end
d268 2
a269 2
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{DO}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_BINARY == $1
d272 1
d274 2
a275 1
        @@sock.write(IAC + WONT + $1)
a276 1
      ''
d280 3
a282 3
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{DONT}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      @@sock.write(IAC + WONT + $1)
      ''
d286 2
a287 2
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{WILL}([#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}])/no){
      if OPT_SGA == $1
d290 3
a293 1
      ''
d297 1
a297 1
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{WONT}[#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}]/no, '')
d300 1
a300 1
    str.gsub!(/(?:(?!#{IAC}))?#{IAC}#{AYT}/no){
d302 1
a302 1
      ''
d343 6
a348 3
    string.gsub!(/#{IAC}/no, IAC + IAC) if @@options["Telnetmode"]
    if @@options["Binmode"]
      @@sock.write(string)
d350 2
a351 10
      if @@telnet_option["BINARY"] and @@telnet_option["SGA"]
        # IAC WILL SGA IAC DO BIN send EOL --> CR
        @@sock.write(string.gsub(/\n/, CR) + CR)
      elsif @@telnet_option["SGA"]
        # IAC WILL SGA send EOL --> CR+NULL
        @@sock.write(string.gsub(/\n/, CR + NULL) + CR + NULL)
      else
        # NONE send EOL --> LF
        @@sock.write(string.gsub(/\n/, LF) + LF)
      end
@


1.1.2.10
log
@*** empty log message ***
@
text
@d1 131
a131 181
=begin

= simple telnet cliant library

telnet.rb ver0.162 1999/03/18

Wakou Aoyama <wakou@@fsinet.or.jp>


= methods

== new (make new Telnet object)

	host = Telnet.new({"Binmode" => FALSE,           # default: FALSE
	                   "Host" => "localhost",        # default: "localhost"
	                   "Output_log" => "output_log", # default: not output
	                   "Dump_log" => "dump_log",     # default: not output
	                   "Port" => 23,                 # default: 23
	                   "Prompt" => /[$%#>] \Z/,      # default: /[$%#>] \Z/
	                   "Telnetmode" => TRUE,         # default: TRUE
	                   "Timeout" => 10,              # default: 10
	                   "Waittime" => 0,              # default: 0
	                   "Proxy" => proxy})            # default: nil
                                    # proxy is Telnet or TCPsocket object

Telnet object has socket class methods.

if set "Telnetmode" option FALSE. not TELNET command interpretation.
"Waittime" is time to confirm "Prompt". There is a possibility that
the same character as "Prompt" is included in the data, and, when
the network or the host is very heavy, the value is enlarged.


== waitfor (wait for match)

	line = host.waitfor(/match/)
	line = host.waitfor({"Match"   => /match/,
	                     "String"  => "string",
	                     "Timeout" => secs})

if set "String" option. Match = Regexp.new(quote(string))


=== realtime output

	host.waitfor(/match/){|c| print c }
	host.waitfor({"Match"   => /match/,
	              "String"  => "string",
	              "Timeout" => secs}){|c| print c}

of cource, set sync=TRUE or flush is necessary.


== cmd (send string and wait prompt)

	line = host.cmd("string")
	line = host.cmd({"String" => "string",
	                 "Prompt" => /[$%#>] \Z/,
	                 "Timeout" => 10})


=== realtime output

	host.cmd("string"){|c| print c }
	host.cmd({"String" => "string",
	          "Prompt" => /[$%#>] \Z/,
	          "Timeout" => 10}){|c| print c }

of cource, set sync=TRUE or flush is necessary.


== print (send string)

	host.print("string")


== telnetmode (turn telnet command interpretation)

	host.telnetmode        # turn on/off
	host.telnetmode(TRUE)  # on
	host.telnetmode(FALSE) # off


== binmode (toggle newline translation)

	host.binmode        # turn TRUE/FALSE
	host.binmode(TRUE)  # no translate newline
	host.binmode(FALSE) # translate newline


== login

	host.login("username", "password")
	host.login({"Name" => "username",
	            "Password" => "password",
	            "Prompt" => /[$%#>] \Z/,
	            "Timeout" => 10})


=== realtime output

	host.login("username", "password"){|c| print c }
	host.login({"Name" => "username",
	            "Password" => "password",
	            "Prompt" => /[$%#>] \Z/,
	            "Timeout" => 10}){|c| print c }

of cource, set sync=TRUE or flush is necessary.


= sample

== login and send command

	localhost = Telnet.new({"Host" => "localhost",
	                        "Timeout" => 10,
	                        "Prompt" => /[$%#>] \Z/})
	localhost.login("username", "password"){|c| print c }
	localhost.cmd("command"){|c| print c }
	localhost.close


== checks a POP server to see if you have mail

	pop = Telnet.new({"Host" => "your_destination_host_here",
	                  "Port" => 110,
	                  "Telnetmode" => FALSE,
	                  "Prompt" => /^\+OK/})
	pop.cmd("user " + "your_username_here"){|c| print c}
	pop.cmd("pass " + "your_password_here"){|c| print c}
	pop.cmd("list"){|c| print c}


= history

ver0.162 1999/03/17
add "Proxy" option
required timeout.rb

ver0.161 1999/02/03
select --> IO::select

ver0.16 1998/10/09
preprocess method change for the better
add binmode method.
change default Binmode
TRUE --> FALSE

ver0.15 1998/10/04
add telnetmode method.

ver0.141 1998/09/22
change default prompt
/[$%#>] $/ --> /[$%#>] \Z/

ver0.14 1998/09/01
IAC WILL SGA             send EOL --> CR+NULL
IAC WILL SGA IAC DO BIN  send EOL --> CR
NONE                     send EOL --> LF
add Dump_log option.

ver0.13 1998/08/25
add print method.

ver0.122 1998/08/05
support for HP-UX 10.20    thanks to WATANABE Tetsuya <tetsu@@jpn.hp.com>
socket.<< --> socket.write

ver0.121 1998/07/15
string.+= --> string.concat

ver0.12 1998/06/01
add timeout, waittime.

ver0.11 1998/04/21
add realtime output.

ver0.10 1998/04/13
first release.

=end
d136 3
a138 2
require "timeout"
TimeOut = TimeoutError
d142 22
d257 4
a260 13
    if @@options.include?("Proxy")
      if @@options["Proxy"].kind_of?(Telnet)
        @@sock = @@options["Proxy"].sock
      elsif @@options["Proxy"].kind_of?(TCPsocket)
        @@sock = @@options["Proxy"]
      else
        raise "Error; Proxy is Telnet or TCPSocket object."
      end
    else
      message = "Trying " + @@options["Host"] + "...\n"
      STDOUT.write(message)
      @@log.write(message) if @@options.include?("Output_log")
      @@dumplog.write(message) if @@options.include?("Dump_log")
d262 1
d264 1
a264 5
        timeout(@@options["Timeout"]){
          @@sock = TCPsocket.open(@@options["Host"], @@options["Port"])
        }
      rescue TimeoutError
        raise TimeOut, "timed-out; opening of the host"
d270 9
a278 8
      @@sock.sync = TRUE
      @@sock.binmode

      message = "Connected to " + @@options["Host"] + ".\n"
      STDOUT.write(message)
      @@log.write(message) if @@options.include?("Output_log")
      @@dumplog.write(message) if @@options.include?("Dump_log")
    end
a282 2
  attr :sock

d345 1
a345 1
    time_out = @@options["Timeout"]
d350 1
a350 1
      time_out = options["Timeout"]  if options.include?("Timeout")
d359 1
a359 1
    until(not IO::select([@@sock], nil, nil, waittime) and prompt === line)
d361 1
a361 1
        not IO::select([@@sock], nil, nil, time_out)
d397 2
a398 2
    match    = @@options["Prompt"]
    time_out = @@options["Timeout"]
d401 3
a403 3
      string   = options["String"]
      match    = options["Match"]   if options.include?("Match")
      time_out = options["Timeout"] if options.include?("Timeout")
d408 1
a408 1
    IO::select(nil, [@@sock])
d411 1
a411 1
      waitfor({"Prompt" => match, "Timeout" => time_out}){|c| yield c }
d413 1
a413 1
      waitfor({"Prompt" => match, "Timeout" => time_out})
@


1.1.2.11
log
@to open CVS
@
text
@d5 1
a5 1
telnet.rb ver0.163 1999/04/11
a32 11
=== status output

	host = Telnet.new({"Hosh" => "localhost"){|c| print c }

connection status output.

example

Trying localhost...
Connected to localhost.

a135 3
ver0.163 1999/04/11
STDOUT.write(message) --> yield(message) if iterator?

d294 1
a294 1
      yield(message) if iterator?
d313 1
a313 1
      yield(message) if iterator?
@


1.1.2.12
log
@moving
@
text
@d5 2
a6 1
telnet.rb ver0.17 1999/04/30
a146 4
ver0.17 1999/04/30
bug fix
$! + "\n"  -->  $!.to_s + "\n"

d319 2
a320 2
        @@log.write($!.to_s + "\n") if @@options.include?("Output_log")
        @@dumplog.write($!.to_s + "\n") if @@options.include?("Dump_log")
d403 1
a403 7
      prompt   = if options.include?("Match")
                   options["Match"]   
                 elsif options.include?("Prompt")
                   options["Prompt"]
                 elsif options.include?("String")
                   Regexp.new( Regexp.quote(options["String"]) )
                 end
d406 2
@


