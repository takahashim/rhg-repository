head	1.10;
access;
symbols
	v1_6_7:1.5.2.2
	v1_6_6:1.5.2.2
	v1_6_5:1.5.2.1
	v1_6_4:1.5
	v1_7_1:1.5
	v1_6_4_preview4:1.5
	v1_6_4_preview3:1.5
	v1_6_4_preview2:1.5
	v1_6_4_preview1:1.5
	v1_6_3:1.5
	ruby_m17n:1.5.0.4
	ruby_1_6:1.5.0.2
	v1_6_2:1.5
	v1_6_1:1.5
	v1_6_0:1.5
	v1_4_6:1.2
	v1_4_5:1.2
	v1_4_4:1.2
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.3
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.2.2.1
	v1_3_6_repack:1.1.1.2.2.1
	v1_3_6:1.1.1.2.2.1
	v1_3_5:1.1.1.2.2.1
	v1_2_6repack:1.1.1.1.2.2
	v1_3_4_990625:1.1.1.2.2.1
	v1_3_4_990624:1.1.1.2.2.1
	v1_2_6:1.1.1.1.2.2
	v1_3_4_990611:1.1.1.2.2.1
	v1_3_4_990531:1.1.1.2.2.1
	v1_3_3_990518:1.1.1.2.2.1
	v1_3_3_990513:1.1.1.2
	v1_3_3_990507:1.1.1.2
	v1_2_5:1.1.1.1.2.1
	v1_2_4:1.1.1.1.2.1
	v1_3_1_990225:1.1.1.2
	v1_3_1_990224:1.1.1.2
	v1_3_1_990215:1.1.1.2
	v1_3_1_990212:1.1.1.2
	v1_3_1_990210:1.1.1.2
	v1_3_1_:1.1.1.2
	v1_3_1_990209:1.1.1.2
	v1_3_1_990205:1.1.1.2
	v1_3_1_990203:1.1.1.2
	v1_3_1_990201:1.1.1.2
	v1_3_1"_990201:1.1.1.2
	v1_3_1_990128:1.1.1.2
	v1_3_1_990127:1.1.1.2
	v1_3_1_990126:1.1.1.2
	ruby_1_3:1.1.1.2.0.2
	v1_2_2:1.1.1.1.2.1
	RUBY_1_3:1.1.1.2
	v1_2_2_pr1:1.1.1.1.2.1
	v1_2_1repack:1.1.1.1.2.1
	v1_2_1:1.1.1.1.2.1
	v1_2_stable:1.1.1.1.2.1
	v1_1d1:1.1.1.1.2.1
	v1_1d0:1.1.1.1.2.1
	v1_1c9_1:1.1.1.1.2.1
	v1_1c9:1.1.1.1.2.1
	v1_1c8:1.1.1.1.2.1
	v1_1c7:1.1.1.1.2.1
	v1_1c6:1.1.1.1.2.1
	v1_1d-start:1.1.1.1.2.1
	v1_1c5:1.1.1.1.2.1
	v1_1dev:1.1.1.1.2.1.0.2
	v1_1c4:1.1.1.1.2.1
	v1_1c3:1.1.1.1.2.1
	v1_1c2:1.1.1.1.2.1
	v1_1c1:1.1.1.1.2.1
	v1_1c0:1.1.1.1.2.1
	v1_1b9_31:1.1.1.1.2.1
	v1_1b9_30:1.1.1.1.2.1
	v1_1b9_28:1.1.1.1.2.1
	v1_1b9_27:1.1.1.1.2.1
	v1_1b9_26:1.1.1.1.2.1
	r1_1b9_25:1.1.1.1.2.1
	r1_1b9_24:1.1.1.1.2.1
	v1_1b9_23:1.1.1.1.2.1
	v1_1b9_22:1.1.1.1.2.1
	v1_1b9_20:1.1.1.1.2.1
	v1_1b9_18:1.1.1.1.2.1
	v1_1b9_16:1.1.1.1.2.1
	v1_1b9_15:1.1.1.1.2.1
	v1_1b9_13:1.1.1.1.2.1
	v1_1b9_12:1.1.1.1.2.1
	v1_1b9_11:1.1.1.1.2.1
	v1_1b9_08:1.1.1.1.2.1
	v1_1b9_07:1.1.1.1.2.1
	r1_1b9:1.1.1.1.2.1
	v1_1b8:1.1.1.1.2.1
	v1_1b7:1.1.1.1.2.1
	v1_1b6:1.1.1.1
	v1_1r:1.1.1.1.0.2
	v1_1:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2002.09.28.11.08.59;	author nobu;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.24.07.59.00;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.17.07.52.35;	author nobu;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.20.04.29.56;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.02.08.46.21;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.30.04.24.01;	author matz;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.05.24.07.10.23;	author wakou;	state Exp;
branches;
next	1.3;

1.3
date	99.11.10.06.47.08;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.06;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.19.10;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.19.10;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	99.01.20.04.59.24;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	;

1.1.1.2.2.1
date	99.05.17.09.54.03;	author matz;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	98.02.02.04.49.12;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.06.21.06.31.04;	author matz;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.29.08.32.52;	author matz;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.12.17.08.13.17;	author nobu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@* keywords: add braces around initializers.
@
text
@/* C code produced by gperf version 2.7.2 */
/* Command-line: gperf -p -j1 -i 1 -g -o -t -N rb_reserved_word -k'1,3,$' ./keywords  */
struct kwtable {char *name; int id[2]; enum lex_state state;};

#define TOTAL_KEYWORDS 40
#define MIN_WORD_LENGTH 2
#define MAX_WORD_LENGTH 8
#define MIN_HASH_VALUE 6
#define MAX_HASH_VALUE 55
/* maximum key range = 50, duplicates = 0 */

#ifdef __GNUC__
__inline
#else
#ifdef __cplusplus
inline
#endif
#endif
static unsigned int
hash (str, len)
     register const char *str;
     register unsigned int len;
{
  static unsigned char asso_values[] =
    {
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 11, 56, 56, 36, 56,  1, 37,
      31,  1, 56, 56, 56, 56, 29, 56,  1, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56,  1, 56, 32,  1,  2,
       1,  1,  4, 23, 56, 17, 56, 20,  9,  2,
       9, 26, 14, 56,  5,  1,  1, 16, 56, 21,
      20,  9, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56
    };
  register int hval = len;

  switch (hval)
    {
      default:
      case 3:
        hval += asso_values[(unsigned char)str[2]];
      case 2:
      case 1:
        hval += asso_values[(unsigned char)str[0]];
        break;
    }
  return hval + asso_values[(unsigned char)str[len - 1]];
}

#ifdef __GNUC__
__inline
#endif
struct kwtable *
rb_reserved_word (str, len)
     register const char *str;
     register unsigned int len;
{
  static struct kwtable wordlist[] =
    {
      {""}, {""}, {""}, {""}, {""}, {""},
      {"end", {kEND, kEND}, EXPR_END},
      {"else", {kELSE, kELSE}, EXPR_BEG},
      {"case", {kCASE, kCASE}, EXPR_BEG},
      {"ensure", {kENSURE, kENSURE}, EXPR_BEG},
      {"module", {kMODULE, kMODULE}, EXPR_BEG},
      {"elsif", {kELSIF, kELSIF}, EXPR_BEG},
      {"def", {kDEF, kDEF}, EXPR_FNAME},
      {"rescue", {kRESCUE, kRESCUE_MOD}, EXPR_MID},
      {"not", {kNOT, kNOT}, EXPR_BEG},
      {"then", {kTHEN, kTHEN}, EXPR_BEG},
      {"yield", {kYIELD, kYIELD}, EXPR_ARG},
      {"for", {kFOR, kFOR}, EXPR_BEG},
      {"self", {kSELF, kSELF}, EXPR_END},
      {"false", {kFALSE, kFALSE}, EXPR_END},
      {"retry", {kRETRY, kRETRY}, EXPR_END},
      {"return", {kRETURN, kRETURN}, EXPR_MID},
      {"true", {kTRUE, kTRUE}, EXPR_END},
      {"if", {kIF, kIF_MOD}, EXPR_BEG},
      {"defined?", {kDEFINED, kDEFINED}, EXPR_ARG},
      {"super", {kSUPER, kSUPER}, EXPR_ARG},
      {"undef", {kUNDEF, kUNDEF}, EXPR_FNAME},
      {"break", {kBREAK, kBREAK}, EXPR_MID},
      {"in", {kIN, kIN}, EXPR_BEG},
      {"do", {kDO, kDO}, EXPR_BEG},
      {"nil", {kNIL, kNIL}, EXPR_END},
      {"until", {kUNTIL, kUNTIL_MOD}, EXPR_BEG},
      {"unless", {kUNLESS, kUNLESS_MOD}, EXPR_BEG},
      {"or", {kOR, kOR}, EXPR_BEG},
      {"next", {kNEXT, kNEXT}, EXPR_MID},
      {"when", {kWHEN, kWHEN}, EXPR_BEG},
      {"redo", {kREDO, kREDO}, EXPR_END},
      {"and", {kAND, kAND}, EXPR_BEG},
      {"begin", {kBEGIN, kBEGIN}, EXPR_BEG},
      {"__LINE__", {k__LINE__, k__LINE__}, EXPR_END},
      {"class", {kCLASS, kCLASS}, EXPR_CLASS},
      {"__FILE__", {k__FILE__, k__FILE__}, EXPR_END},
      {"END", {klEND, klEND}, EXPR_END},
      {"BEGIN", {klBEGIN, klBEGIN}, EXPR_END},
      {"while", {kWHILE, kWHILE_MOD}, EXPR_BEG},
      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
      {""},
      {"alias", {kALIAS, kALIAS}, EXPR_FNAME}
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      register int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= 0)
        {
          register const char *s = wordlist[key].name;

          if (*str == *s && !strcmp (str + 1, s + 1))
            return &wordlist[key];
        }
    }
  return 0;
}
@


1.9
log
@* parse.y (yylex): __END__ should not be effective within
  string literals.

* parse.y (here_document): should be aware of __END__ within here
  documents.
@
text
@d79 39
a117 39
      {"end", kEND, kEND, EXPR_END},
      {"else", kELSE, kELSE, EXPR_BEG},
      {"case", kCASE, kCASE, EXPR_BEG},
      {"ensure", kENSURE, kENSURE, EXPR_BEG},
      {"module", kMODULE, kMODULE, EXPR_BEG},
      {"elsif", kELSIF, kELSIF, EXPR_BEG},
      {"def", kDEF, kDEF, EXPR_FNAME},
      {"rescue", kRESCUE, kRESCUE_MOD, EXPR_MID},
      {"not", kNOT, kNOT, EXPR_BEG},
      {"then", kTHEN, kTHEN, EXPR_BEG},
      {"yield", kYIELD, kYIELD, EXPR_ARG},
      {"for", kFOR, kFOR, EXPR_BEG},
      {"self", kSELF, kSELF, EXPR_END},
      {"false", kFALSE, kFALSE, EXPR_END},
      {"retry", kRETRY, kRETRY, EXPR_END},
      {"return", kRETURN, kRETURN, EXPR_MID},
      {"true", kTRUE, kTRUE, EXPR_END},
      {"if", kIF, kIF_MOD, EXPR_BEG},
      {"defined?", kDEFINED, kDEFINED, EXPR_ARG},
      {"super", kSUPER, kSUPER, EXPR_ARG},
      {"undef", kUNDEF, kUNDEF, EXPR_FNAME},
      {"break", kBREAK, kBREAK, EXPR_MID},
      {"in", kIN, kIN, EXPR_BEG},
      {"do", kDO, kDO, EXPR_BEG},
      {"nil", kNIL, kNIL, EXPR_END},
      {"until", kUNTIL, kUNTIL_MOD, EXPR_BEG},
      {"unless", kUNLESS, kUNLESS_MOD, EXPR_BEG},
      {"or", kOR, kOR, EXPR_BEG},
      {"next", kNEXT, kNEXT, EXPR_MID},
      {"when", kWHEN, kWHEN, EXPR_BEG},
      {"redo", kREDO, kREDO, EXPR_END},
      {"and", kAND, kAND, EXPR_BEG},
      {"begin", kBEGIN, kBEGIN, EXPR_BEG},
      {"__LINE__", k__LINE__, k__LINE__, EXPR_END},
      {"class", kCLASS, kCLASS, EXPR_CLASS},
      {"__FILE__", k__FILE__, k__FILE__, EXPR_END},
      {"END", klEND, klEND, EXPR_END},
      {"BEGIN", klBEGIN, klBEGIN, EXPR_END},
      {"while", kWHILE, kWHILE_MOD, EXPR_BEG},
d120 1
a120 1
      {"alias", kALIAS, kALIAS, EXPR_FNAME}
@


1.8
log
@* intern.h: add prototypes.
  rb_gc_enable(), rb_gc_disable(), rb_gc_start(), rb_str_new5()
  rb_str_buf_append(), rb_str_buf_cat(), rb_str_buf_cat2(),
  rb_str_dup_frozen()

* ruby.h: added declaration.
  rb_defout, rb_stdin, rb_stdout, rb_stderr, ruby_errinfo

* rubyio.h: changed double include guard macro to RUBYIO_H.

* array.c (inspect_call): make static.

* eval.c (dvar_asgn): ditto.

* io.c (rb_io_close_read): ditto.

* lex.c (rb_reserved_word): ditto.

* ruby.c: (req_list_head, req_list_last): ditto.

* ruby.c (require_libraries): ditto.
@
text
@a67 1
static
@


1.7
log
@* range.c (range_step): 'iter' here should be an array.

* marshal.c (w_object): should retrieve __member__ data from
  non-singleton class.

* variable.c (rb_cvar_get): class variable override check added.

* variable.c (rb_cvar_set): ditto

* variable.c (rb_cvar_declare): ditto.

* parse.y (parse_regx): handle backslash escaping of delimiter here.
@
text
@d68 1
@


1.6
log
@* error.c (exc_exception): clone the receiver exception instead of
  creating brand new exception object of the receiver.

* eval.c (rb_eval_string_wrap): extend new ruby_top_self, not
  original self.

* eval.c (rb_eval_cmd): respect ruby_wrapper if set.

* eval.c (eval): do not update ruby_class unless scope is not
  provided.

* eval.c (eval): preserve wrapper information.

* eval.c (proc_invoke): ditto.

* eval.c (block_pass): ditto.

* parse.y (void_expr): too much warnings for void context
  (e.g. foo[1] that can be mere Proc call).

* error.c (rb_name_error): new function to raise NameError with
  name attribute set.

* eval.c (rb_f_missing): set name and args in the exception
  object. [new]

* error.c (name_name): NameError#name - new method.

* error.c (nometh_args): NoMethodError#args - new method.

* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.

* dir.c (isdelim): space, tab, and newline are no longer
  delimiters for glob patterns.

* eval.c (svalue_to_avalue): new conversion scheme between single
  value and array values.

* eval.c (avalue_to_svalue): ditto.

* eval.c (rb_eval): REXPAND now uses avalue_to_svalue(), return
  and yield too.

* eval.c (rb_yield_0): use avalue_to_svalue().

* eval.c (proc_invoke): Proc#call gives avaules, whereas
  Proc#yield gives mvalues.

* eval.c (bmcall): convert given value (svalue) to avalue.
@
text
@d100 1
a100 1
      {"break", kBREAK, kBREAK, EXPR_END},
d107 1
a107 1
      {"next", kNEXT, kNEXT, EXPR_END},
@


1.5
log
@2000-05-30
@
text
@d1 2
a2 2
/* C code produced by gperf version 2.7.1 (19981006 egcs) */
/* Command-line: gperf -p -j1 -i 1 -g -o -t -N rb_reserved_word -k1,3,$ ./keywords  */
d14 4
d86 1
a86 1
      {"rescue", kRESCUE, kRESCUE_MOD, EXPR_END},
@


1.5.2.1
log
@* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.
@
text
@d1 2
a2 2
/* C code produced by gperf version 2.7.2 */
/* Command-line: gperf -p -j1 -i 1 -g -o -t -N rb_reserved_word -k'1,3,$' ./keywords  */
a13 4
#else
#ifdef __cplusplus
inline
#endif
d82 1
a82 1
      {"rescue", kRESCUE, kRESCUE_MOD, EXPR_MID},
@


1.5.2.2
log
@* intern.h: add prototypes.
  rb_str_dup_frozen()

* ruby.h: added declaration.
  rb_defout, rb_stdin, rb_stdout, rb_stderr, ruby_errinfo

* rubyio.h: changed double include guard macro to RUBYIO_H.

* array.c (inspect_call): make static.

* eval.c (dvar_asgn): ditto.

* io.c (rb_io_close_read): ditto.

* lex.c (rb_reserved_word): ditto.

* ruby.c: (req_list_head, req_list_last): ditto.

* ruby.c (require_libraries): ditto.
@
text
@a67 1
static
@


1.4
log
@Wed May 24 16:03:06 2000  Wakou Aoyama <wakou@@fsinet.or.jp>

        * lib/cgi.rb bug fix: CGI::escape(), CGI::Cookie::new()
        * lib/net/telnet.rb improve: binmode(), telnetmode() interface
@
text
@d1 1
a1 1
/* C code produced by gperf version 2.7 */
d82 1
a82 1
      {"rescue", kRESCUE, kRESCUE_MOD, EXPR_MID},
d85 1
a85 1
      {"yield", kYIELD, kYIELD, EXPR_END},
d93 2
a94 2
      {"defined?", kDEFINED, kDEFINED, EXPR_END},
      {"super", kSUPER, kSUPER, EXPR_END},
@


1.3
log
@19991110
@
text
@d1 1
a1 1
/* C code produced by gperf version 2.7.1 (19981006 egcs) */
@


1.2
log
@1.4.0
@
text
@d82 1
a82 1
      {"rescue", kRESCUE, kRESCUE, EXPR_MID},
@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
/* C code produced by gperf version 2.5 (GNU C++ version) */
/* Command-line: gperf -p -j1 -i 1 -g -o -t -N rb_reserved_word -k1,3,$ keywords  */
d5 1
a5 1
#define TOTAL_KEYWORDS 38
d9 2
a10 2
#define MAX_HASH_VALUE 52
/* maximum key range = 47, duplicates = 0 */
d13 1
a13 1
inline
d17 2
a18 2
     register char *str;
     register int unsigned len;
d22 26
a47 13
     53, 53, 53, 53, 53, 53, 53, 53, 53, 53,
     53, 53, 53, 53, 53, 53, 53, 53, 53, 53,
     53, 53, 53, 53, 53, 53, 53, 53, 53, 53,
     53, 53, 53, 53, 53, 53, 53, 53, 53, 53,
     53, 53, 53, 53, 53, 53, 53, 53, 53, 53,
     53, 53, 53, 53, 53, 53, 53, 53, 53, 53,
     53, 53, 53, 11, 53, 53, 34, 53,  1, 35,
     53,  1, 53, 53, 53, 53, 53, 53,  1, 53,
     53, 53, 53, 53, 53, 53, 53, 53, 53, 53,
     53, 53, 53, 53, 53, 53, 53, 29,  1,  2,
      1,  1,  4, 24, 53, 17, 53, 20,  9,  2,
      9, 26, 14, 53,  5,  1,  1, 16, 53, 21,
     24,  9, 53, 53, 53, 53, 53, 53,
d55 1
a55 1
        hval += asso_values[str[2]];
d58 1
a58 1
        hval += asso_values[str[0]];
d61 1
a61 1
  return hval + asso_values[str[len - 1]];
d65 1
a65 1
inline
d69 1
a69 1
     register char *str;
d74 43
a116 41
      {"",}, {"",}, {"",}, {"",}, {"",}, {"",}, 
      {"end",  kEND, kEND, EXPR_END},
      {"else",  kELSE, kELSE, EXPR_BEG},
      {"case",  kCASE, kCASE, EXPR_BEG},
      {"ensure",  kENSURE, kENSURE, EXPR_BEG},
      {"module",  kMODULE, kMODULE, EXPR_BEG},
      {"elsif",  kELSIF, kELSIF, EXPR_BEG},
      {"def",  kDEF, kDEF, EXPR_FNAME},
      {"rescue",  kRESCUE, kRESCUE, EXPR_MID},
      {"not",  kNOT, kNOT, EXPR_BEG},
      {"then",  kTHEN, kTHEN, EXPR_BEG},
      {"yield",  kYIELD, kYIELD, EXPR_END},
      {"for",  kFOR, kFOR, EXPR_BEG},
      {"self",  kSELF, kSELF, EXPR_END},
      {"false",  kFALSE, kFALSE, EXPR_END},
      {"retry",  kRETRY, kRETRY, EXPR_END},
      {"return",  kRETURN, kRETURN, EXPR_MID},
      {"true",  kTRUE, kTRUE, EXPR_END},
      {"if",  kIF, kIF_MOD, EXPR_BEG},
      {"defined?",  kDEFINED, kDEFINED, EXPR_END},
      {"super",  kSUPER, kSUPER, EXPR_END},
      {"undef",  kUNDEF, kUNDEF, EXPR_FNAME},
      {"break",  kBREAK, kBREAK, EXPR_END},
      {"in",  kIN, kIN, EXPR_BEG},
      {"do",  kDO, kDO, EXPR_BEG},
      {"nil",  kNIL, kNIL, EXPR_END},
      {"until",  kUNTIL, kUNTIL_MOD, EXPR_BEG},
      {"unless",  kUNLESS, kUNLESS_MOD, EXPR_BEG},
      {"or",  kOR, kOR, EXPR_BEG},
      {"and",  kAND, kAND, EXPR_BEG},
      {"when",  kWHEN, kWHEN, EXPR_BEG},
      {"redo",  kREDO, kREDO, EXPR_END},
      {"class",  kCLASS, kCLASS, EXPR_CLASS},
      {"next",  kNEXT, kNEXT, EXPR_END},
      {"begin",  kBEGIN, kBEGIN, EXPR_BEG},
      {"END",  klEND, klEND, EXPR_END},
      {"BEGIN",  klBEGIN, klBEGIN, EXPR_END},
      {"",}, {"",}, 
      {"while",  kWHILE, kWHILE_MOD, EXPR_BEG},
      {"",}, {"",}, {"",}, {"",}, {"",}, {"",}, {"",}, 
      {"alias",  kALIAS, kALIAS, EXPR_FNAME},
d125 1
a125 1
          register char *s = wordlist[key].name;
d127 1
a127 1
          if (*s == *str && !strcmp (str + 1, s + 1))
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@ruby 1.3 cycle
@
text
@d5 1
a5 1
#define TOTAL_KEYWORDS 40
d9 2
a10 2
#define MAX_HASH_VALUE 55
/* maximum key range = 50, duplicates = 0 */
d22 13
a34 13
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 11, 56, 56, 36, 56,  1, 37,
     31,  1, 56, 56, 56, 56, 29, 56,  1, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56,  1, 56, 32,  1,  2,
      1,  1,  4, 23, 56, 17, 56, 20,  9,  2,
      9, 26, 14, 56,  5,  1,  1, 16, 56, 21,
     20,  9, 56, 56, 56, 56, 56, 56,
d90 1
a90 1
      {"next",  kNEXT, kNEXT, EXPR_END},
d93 2
a94 1
      {"and",  kAND, kAND, EXPR_BEG},
a95 3
      {"__LINE__",  k__LINE__, k__LINE__, EXPR_END},
      {"class",  kCLASS, kCLASS, EXPR_CLASS},
      {"__FILE__",  k__FILE__, k__FILE__, EXPR_END},
d98 1
d100 1
a100 2
      {"",}, {"",}, {"",}, {"",}, {"",}, {"",}, {"",}, {"",}, {"",}, 
      {"",}, 
@


1.1.1.2.2.1
log
@arity/strict yield
@
text
@d1 2
a2 2
/* C code produced by gperf version 2.7.1 (19981006 egcs) */
/* Command-line: gperf -p -j1 -i 1 -g -o -t -N rb_reserved_word -k1,3,$ ./keywords  */
d13 1
a13 1
__inline
d17 2
a18 2
     register const char *str;
     register unsigned int len;
d22 13
a34 26
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 11, 56, 56, 36, 56,  1, 37,
      31,  1, 56, 56, 56, 56, 29, 56,  1, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56,  1, 56, 32,  1,  2,
       1,  1,  4, 23, 56, 17, 56, 20,  9,  2,
       9, 26, 14, 56,  5,  1,  1, 16, 56, 21,
      20,  9, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56
d42 1
a42 1
        hval += asso_values[(unsigned char)str[2]];
d45 1
a45 1
        hval += asso_values[(unsigned char)str[0]];
d48 1
a48 1
  return hval + asso_values[(unsigned char)str[len - 1]];
d52 1
a52 1
__inline
d56 1
a56 1
     register const char *str;
d61 43
a103 43
      {""}, {""}, {""}, {""}, {""}, {""},
      {"end", kEND, kEND, EXPR_END},
      {"else", kELSE, kELSE, EXPR_BEG},
      {"case", kCASE, kCASE, EXPR_BEG},
      {"ensure", kENSURE, kENSURE, EXPR_BEG},
      {"module", kMODULE, kMODULE, EXPR_BEG},
      {"elsif", kELSIF, kELSIF, EXPR_BEG},
      {"def", kDEF, kDEF, EXPR_FNAME},
      {"rescue", kRESCUE, kRESCUE, EXPR_MID},
      {"not", kNOT, kNOT, EXPR_BEG},
      {"then", kTHEN, kTHEN, EXPR_BEG},
      {"yield", kYIELD, kYIELD, EXPR_END},
      {"for", kFOR, kFOR, EXPR_BEG},
      {"self", kSELF, kSELF, EXPR_END},
      {"false", kFALSE, kFALSE, EXPR_END},
      {"retry", kRETRY, kRETRY, EXPR_END},
      {"return", kRETURN, kRETURN, EXPR_MID},
      {"true", kTRUE, kTRUE, EXPR_END},
      {"if", kIF, kIF_MOD, EXPR_BEG},
      {"defined?", kDEFINED, kDEFINED, EXPR_END},
      {"super", kSUPER, kSUPER, EXPR_END},
      {"undef", kUNDEF, kUNDEF, EXPR_FNAME},
      {"break", kBREAK, kBREAK, EXPR_END},
      {"in", kIN, kIN, EXPR_BEG},
      {"do", kDO, kDO, EXPR_BEG},
      {"nil", kNIL, kNIL, EXPR_END},
      {"until", kUNTIL, kUNTIL_MOD, EXPR_BEG},
      {"unless", kUNLESS, kUNLESS_MOD, EXPR_BEG},
      {"or", kOR, kOR, EXPR_BEG},
      {"next", kNEXT, kNEXT, EXPR_END},
      {"when", kWHEN, kWHEN, EXPR_BEG},
      {"redo", kREDO, kREDO, EXPR_END},
      {"and", kAND, kAND, EXPR_BEG},
      {"begin", kBEGIN, kBEGIN, EXPR_BEG},
      {"__LINE__", k__LINE__, k__LINE__, EXPR_END},
      {"class", kCLASS, kCLASS, EXPR_CLASS},
      {"__FILE__", k__FILE__, k__FILE__, EXPR_END},
      {"END", klEND, klEND, EXPR_END},
      {"BEGIN", klBEGIN, klBEGIN, EXPR_END},
      {"while", kWHILE, kWHILE_MOD, EXPR_BEG},
      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
      {""},
      {"alias", kALIAS, kALIAS, EXPR_FNAME}
d112 1
a112 1
          register const char *s = wordlist[key].name;
d114 1
a114 1
          if (*str == *s && !strcmp (str + 1, s + 1))
@


1.1.1.1.2.1
log
@__FILE__,__LINE__
@
text
@d5 1
a5 1
#define TOTAL_KEYWORDS 40
d9 2
a10 2
#define MAX_HASH_VALUE 55
/* maximum key range = 50, duplicates = 0 */
d22 13
a34 13
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 11, 56, 56, 36, 56,  1, 37,
     31,  1, 56, 56, 56, 56, 29, 56,  1, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56,  1, 56, 32,  1,  2,
      1,  1,  4, 23, 56, 17, 56, 20,  9,  2,
      9, 26, 14, 56,  5,  1,  1, 16, 56, 21,
     20,  9, 56, 56, 56, 56, 56, 56,
d90 1
a90 1
      {"next",  kNEXT, kNEXT, EXPR_END},
d93 2
a94 1
      {"and",  kAND, kAND, EXPR_BEG},
a95 3
      {"__LINE__",  k__LINE__, k__LINE__, EXPR_END},
      {"class",  kCLASS, kCLASS, EXPR_CLASS},
      {"__FILE__",  k__FILE__, k__FILE__, EXPR_END},
d98 1
d100 1
a100 2
      {"",}, {"",}, {"",}, {"",}, {"",}, {"",}, {"",}, {"",}, {"",}, 
      {"",}, 
@


1.1.1.1.2.2
log
@1.2.6
@
text
@d1 2
a2 2
/* C code produced by gperf version 2.7.1 (19981006 egcs) */
/* Command-line: gperf -p -j1 -i 1 -g -o -t -N rb_reserved_word -k1,3,$ ./keywords  */
d13 1
a13 1
__inline
d17 2
a18 2
     register const char *str;
     register unsigned int len;
d22 13
a34 26
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 11, 56, 56, 36, 56,  1, 37,
      31,  1, 56, 56, 56, 56, 29, 56,  1, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56,  1, 56, 32,  1,  2,
       1,  1,  4, 23, 56, 17, 56, 20,  9,  2,
       9, 26, 14, 56,  5,  1,  1, 16, 56, 21,
      20,  9, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
      56, 56, 56, 56, 56, 56
d42 1
a42 1
        hval += asso_values[(unsigned char)str[2]];
d45 1
a45 1
        hval += asso_values[(unsigned char)str[0]];
d48 1
a48 1
  return hval + asso_values[(unsigned char)str[len - 1]];
d52 1
a52 1
__inline
d56 1
a56 1
     register const char *str;
d61 43
a103 43
      {""}, {""}, {""}, {""}, {""}, {""},
      {"end", kEND, kEND, EXPR_END},
      {"else", kELSE, kELSE, EXPR_BEG},
      {"case", kCASE, kCASE, EXPR_BEG},
      {"ensure", kENSURE, kENSURE, EXPR_BEG},
      {"module", kMODULE, kMODULE, EXPR_BEG},
      {"elsif", kELSIF, kELSIF, EXPR_BEG},
      {"def", kDEF, kDEF, EXPR_FNAME},
      {"rescue", kRESCUE, kRESCUE, EXPR_MID},
      {"not", kNOT, kNOT, EXPR_BEG},
      {"then", kTHEN, kTHEN, EXPR_BEG},
      {"yield", kYIELD, kYIELD, EXPR_END},
      {"for", kFOR, kFOR, EXPR_BEG},
      {"self", kSELF, kSELF, EXPR_END},
      {"false", kFALSE, kFALSE, EXPR_END},
      {"retry", kRETRY, kRETRY, EXPR_END},
      {"return", kRETURN, kRETURN, EXPR_MID},
      {"true", kTRUE, kTRUE, EXPR_END},
      {"if", kIF, kIF_MOD, EXPR_BEG},
      {"defined?", kDEFINED, kDEFINED, EXPR_END},
      {"super", kSUPER, kSUPER, EXPR_END},
      {"undef", kUNDEF, kUNDEF, EXPR_FNAME},
      {"break", kBREAK, kBREAK, EXPR_END},
      {"in", kIN, kIN, EXPR_BEG},
      {"do", kDO, kDO, EXPR_BEG},
      {"nil", kNIL, kNIL, EXPR_END},
      {"until", kUNTIL, kUNTIL_MOD, EXPR_BEG},
      {"unless", kUNLESS, kUNLESS_MOD, EXPR_BEG},
      {"or", kOR, kOR, EXPR_BEG},
      {"next", kNEXT, kNEXT, EXPR_END},
      {"when", kWHEN, kWHEN, EXPR_BEG},
      {"redo", kREDO, kREDO, EXPR_END},
      {"and", kAND, kAND, EXPR_BEG},
      {"begin", kBEGIN, kBEGIN, EXPR_BEG},
      {"__LINE__", k__LINE__, k__LINE__, EXPR_END},
      {"class", kCLASS, kCLASS, EXPR_CLASS},
      {"__FILE__", k__FILE__, k__FILE__, EXPR_END},
      {"END", klEND, klEND, EXPR_END},
      {"BEGIN", klBEGIN, klBEGIN, EXPR_END},
      {"while", kWHILE, kWHILE_MOD, EXPR_BEG},
      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
      {""},
      {"alias", kALIAS, kALIAS, EXPR_FNAME}
d112 1
a112 1
          register const char *s = wordlist[key].name;
d114 1
a114 1
          if (*str == *s && !strcmp (str + 1, s + 1))
@
