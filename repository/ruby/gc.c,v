head	1.112;
access;
symbols
	v1_6_7:1.48.2.21
	v1_6_6:1.48.2.20
	v1_6_5:1.48.2.20
	v1_6_4:1.48.2.15
	v1_7_1:1.67
	v1_6_4_preview4:1.48.2.15
	v1_6_4_preview3:1.48.2.15
	v1_6_4_preview2:1.48.2.12
	v1_6_4_preview1:1.48.2.12
	v1_6_3:1.48.2.9
	ruby_m17n:1.49.0.2
	ruby_1_6:1.48.0.2
	v1_6_2:1.48
	v1_6_1:1.38
	v1_6_0:1.32
	v1_4_6:1.5.2.9
	v1_4_5:1.5.2.9
	v1_4_4:1.5.2.7
	ruby_1_4_3:1.5.2.2
	ruby1_4_3:1.5.2.2
	v1_4_3:1.5.2.2
	v1_5_0:1.8
	ruby_1_4_3_pre1:1.5
	ruby_1_4:1.5.0.2
	v1_4_2:1.4
	v1_4_1:1.4
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.12
	v1_3_6_repack:1.1.1.3.2.11
	v1_3_6:1.1.1.3.2.11
	v1_3_5:1.1.1.3.2.11
	v1_2_6repack:1.1.1.2.2.29
	v1_3_4_990625:1.1.1.3.2.10
	v1_3_4_990624:1.1.1.3.2.9
	v1_2_6:1.1.1.2.2.29
	v1_3_4_990611:1.1.1.3.2.8
	v1_3_4_990531:1.1.1.3.2.7
	v1_3_3_990518:1.1.1.3.2.5
	v1_3_3_990513:1.1.1.3.2.5
	v1_3_3_990507:1.1.1.3.2.5
	v1_2_5:1.1.1.2.2.29
	v1_2_4:1.1.1.2.2.29
	v1_3_1_990225:1.1.1.3.2.4
	v1_3_1_990224:1.1.1.3.2.4
	v1_3_1_990215:1.1.1.3.2.4
	v1_3_1_990212:1.1.1.3.2.4
	v1_3_1_990210:1.1.1.3.2.3
	v1_3_1_:1.1.1.3.2.3
	v1_3_1_990209:1.1.1.3.2.3
	v1_3_1_990205:1.1.1.3.2.2
	v1_3_1_990203:1.1.1.3.2.2
	v1_3_1_990201:1.1.1.3.2.2
	v1_3_1"_990201:1.1.1.3.2.2
	v1_3_1_990128:1.1.1.3.2.2
	v1_3_1_990127:1.1.1.3.2.2
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.29
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.29
	v1_2_1repack:1.1.1.2.2.29
	v1_2_1:1.1.1.2.2.29
	v1_2_stable:1.1.1.2.2.28
	v1_1d1:1.1.1.2.2.25.2.4
	v1_1d0:1.1.1.2.2.25.2.4
	v1_1c9_1:1.1.1.2.2.27
	v1_1c9:1.1.1.2.2.27
	v1_1c8:1.1.1.2.2.27
	v1_1c7:1.1.1.2.2.27
	v1_1c6:1.1.1.2.2.26
	v1_1d-start:1.1.1.2.2.25.2.1
	v1_1c5:1.1.1.2.2.26
	v1_1dev:1.1.1.2.2.25.0.2
	v1_1c4:1.1.1.2.2.25
	v1_1c3:1.1.1.2.2.24
	v1_1c2:1.1.1.2.2.23
	v1_1c1:1.1.1.2.2.23
	v1_1c0:1.1.1.2.2.21
	v1_1b9_31:1.1.1.2.2.20
	v1_1b9_30:1.1.1.2.2.19
	v1_1b9_28:1.1.1.2.2.19
	v1_1b9_27:1.1.1.2.2.18
	v1_1b9_26:1.1.1.2.2.18
	r1_1b9_25:1.1.1.2.2.17
	r1_1b9_24:1.1.1.2.2.16
	v1_1b9_23:1.1.1.2.2.15
	v1_1b9_22:1.1.1.2.2.14
	v1_1b9_20:1.1.1.2.2.14
	v1_1b9_18:1.1.1.2.2.12
	v1_1b9_16:1.1.1.2.2.11
	v1_1b9_15:1.1.1.2.2.11
	v1_1b9_13:1.1.1.2.2.10
	v1_1b9_12:1.1.1.2.2.10
	v1_1b9_11:1.1.1.2.2.10
	v1_1b9_08:1.1.1.2.2.9
	v1_1b9_07:1.1.1.2.2.9
	r1_1b9:1.1.1.2.2.6
	v1_1b8:1.1.1.2.2.5
	v1_1b7:1.1.1.2.2.4
	v1_1b6:1.1.1.2.2.3
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.112
date	2002.10.29.21.35.27;	author knu;	state Exp;
branches;
next	1.111;

1.111
date	2002.10.25.18.39.30;	author knu;	state Exp;
branches;
next	1.110;

1.110
date	2002.10.17.07.26.59;	author matz;	state Exp;
branches;
next	1.109;

1.109
date	2002.10.10.17.11.18;	author nobu;	state Exp;
branches;
next	1.108;

1.108
date	2002.10.10.15.48.06;	author nobu;	state Exp;
branches;
next	1.107;

1.107
date	2002.10.10.15.26.58;	author nobu;	state Exp;
branches;
next	1.106;

1.106
date	2002.10.09.06.12.54;	author nobu;	state Exp;
branches;
next	1.105;

1.105
date	2002.10.03.11.23.34;	author nobu;	state Exp;
branches;
next	1.104;

1.104
date	2002.10.02.06.02.14;	author matz;	state Exp;
branches;
next	1.103;

1.103
date	2002.09.06.08.59.38;	author matz;	state Exp;
branches;
next	1.102;

1.102
date	2002.09.05.20.00.52;	author aamine;	state Exp;
branches;
next	1.101;

1.101
date	2002.09.04.09.23.51;	author michal;	state Exp;
branches;
next	1.100;

1.100
date	2002.09.02.12.19.30;	author aamine;	state Exp;
branches;
next	1.99;

1.99
date	2002.08.29.09.08.16;	author matz;	state Exp;
branches;
next	1.98;

1.98
date	2002.08.28.08.05.23;	author michal;	state Exp;
branches;
next	1.97;

1.97
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.96;

1.96
date	2002.08.12.07.39.08;	author matz;	state Exp;
branches;
next	1.95;

1.95
date	2002.07.26.06.12.38;	author matz;	state Exp;
branches;
next	1.94;

1.94
date	2002.05.14.06.22.26;	author matz;	state Exp;
branches;
next	1.93;

1.93
date	2002.05.14.05.59.34;	author eban;	state Exp;
branches;
next	1.92;

1.92
date	2002.04.25.13.55.58;	author matz;	state Exp;
branches;
next	1.91;

1.91
date	2002.04.24.05.07.07;	author eban;	state Exp;
branches;
next	1.90;

1.90
date	2002.04.24.04.54.13;	author matz;	state Exp;
branches;
next	1.89;

1.89
date	2002.03.07.11.19.37;	author nobu;	state Exp;
branches;
next	1.88;

1.88
date	2002.02.15.04.43.05;	author matz;	state Exp;
branches;
next	1.87;

1.87
date	2002.02.13.09.01.09;	author matz;	state Exp;
branches;
next	1.86;

1.86
date	2002.01.23.07.30.39;	author matz;	state Exp;
branches;
next	1.85;

1.85
date	2002.01.19.14.21.44;	author matz;	state Exp;
branches;
next	1.84;

1.84
date	2002.01.11.09.18.49;	author matz;	state Exp;
branches;
next	1.83;

1.83
date	2002.01.04.14.14.34;	author matz;	state Exp;
branches;
next	1.82;

1.82
date	2001.12.11.03.48.08;	author matz;	state Exp;
branches;
next	1.81;

1.81
date	2001.12.10.07.18.12;	author matz;	state Exp;
branches;
next	1.80;

1.80
date	2001.11.27.10.00.30;	author matz;	state Exp;
branches;
next	1.79;

1.79
date	2001.11.21.15.41.26;	author matz;	state Exp;
branches;
next	1.78;

1.78
date	2001.11.19.14.42.44;	author matz;	state Exp;
branches;
next	1.77;

1.77
date	2001.11.19.05.03.03;	author matz;	state Exp;
branches;
next	1.76;

1.76
date	2001.11.13.08.19.51;	author matz;	state Exp;
branches;
next	1.75;

1.75
date	2001.11.02.07.20.58;	author matz;	state Exp;
branches;
next	1.74;

1.74
date	2001.11.01.04.51.22;	author matz;	state Exp;
branches;
next	1.73;

1.73
date	2001.10.31.06.53.22;	author matz;	state Exp;
branches;
next	1.72;

1.72
date	2001.07.20.15.19.28;	author knu;	state Exp;
branches;
next	1.71;

1.71
date	2001.07.02.08.46.21;	author matz;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.19.15.41.18;	author eban;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.12.05.31.46;	author matz;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.08.14.20.19;	author matz;	state Exp;
branches;
next	1.67;

1.67
date	2001.05.07.09.26.24;	author matz;	state Exp;
branches;
next	1.66;

1.66
date	2001.05.02.04.22.10;	author matz;	state Exp;
branches;
next	1.65;

1.65
date	2001.03.26.08.57.10;	author matz;	state Exp;
branches;
next	1.64;

1.64
date	2001.03.22.08.59.02;	author matz;	state Exp;
branches;
next	1.63;

1.63
date	2001.03.21.03.41.41;	author matz;	state Exp;
branches;
next	1.62;

1.62
date	2001.03.19.03.20.21;	author matz;	state Exp;
branches;
next	1.61;

1.61
date	2001.02.28.06.30.03;	author matz;	state Exp;
branches;
next	1.60;

1.60
date	2001.02.11.07.12.02;	author eban;	state Exp;
branches;
next	1.59;

1.59
date	2001.02.08.09.19.17;	author matz;	state Exp;
branches;
next	1.58;

1.58
date	2001.02.02.11.38.10;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2001.01.29.05.10.42;	author matz;	state Exp;
branches;
next	1.56;

1.56
date	2001.01.23.09.55.10;	author matz;	state Exp;
branches;
next	1.55;

1.55
date	2001.01.23.08.08.59;	author matz;	state Exp;
branches;
next	1.54;

1.54
date	2001.01.10.10.07.31;	author matz;	state Exp;
branches;
next	1.53;

1.53
date	2001.01.10.07.52.45;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2001.01.09.07.26.16;	author matz;	state Exp;
branches;
next	1.51;

1.51
date	2000.12.29.18.23.22;	author matz;	state Exp;
branches;
next	1.50;

1.50
date	2000.12.29.02.47.07;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2000.12.26.08.08.50;	author matz;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2000.12.22.03.21.56;	author matz;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2000.12.08.07.10.18;	author matz;	state Exp;
branches;
next	1.46;

1.46
date	2000.11.27.09.23.18;	author matz;	state Exp;
branches;
next	1.45;

1.45
date	2000.11.21.14.26.20;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2000.11.20.08.26.48;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2000.11.14.07.10.21;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2000.10.31.08.37.38;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2000.10.16.09.13.16;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2000.10.10.09.12.43;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.10.07.03.19;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2000.09.27.03.43.13;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.25.17.51.21;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.25.09.15.02;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.12.05.37.21;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.01.03.30.58;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2000.08.31.09.08.14;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.29.07.29.46;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.29.02.52.30;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.28.09.53.26;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.09.04.32.17;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.07.06.11.33;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.07.05.01.52;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.02.04.54.11;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.27.09.49.16;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.17.09.37.56;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.15.13.36.57;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.04.04.17.09;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.28.08.26.54;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.26.15.16.03;	author eban;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.17.04.38.12;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.16.02.46.52;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.12.09.07.38;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.09.04.52.57;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.01.09.41.19;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.10.05.44.10;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.07.08.37.35;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.08.08.48.47;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.01.03.12.04;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.05.04.37.03;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	99.12.14.06.49.44;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.12.06.09.03.53;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.11.29.06.32.58;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.11.26.09.07.23;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.10.12.04.53.33;	author matz;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.09.01.09.48.01;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.08.24.08.21.53;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.05;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.10;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.23;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.12;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.01.27.08.08.37;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.09.06.08.20;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.02.12.11.17.03;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.03.24.08.52.28;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.05.25.08.25.59;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.05.31.09.13.11;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.06.11.06.29.53;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.06.24.04.23.54;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.06.25.09.02.41;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.07.15.07.59.45;	author matz;	state Exp;
branches;
next	1.1.1.3.2.12;

1.1.1.3.2.12
date	99.08.06.06.48.17;	author matz;	state Exp;
branches;
next	1.1.1.3.2.13;

1.1.1.3.2.13
date	99.08.11.07.24.02;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.45;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.22.08.12.09;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.01.22.10.28.03;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.02.09.10.56.20;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.02.18.01.56.39;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.02.25.06.52.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.03.05.06.37.44;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.03.11.07.32.55;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.03.13.09.04.30;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.04.09.09.30.21;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.04.22.08.57.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.05.08.09.38.07;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.05.13.05.57.57;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.05.13.07.26.16;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.05.25.04.57.36;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.06.02.10.05.22;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.06.11.10.03.02;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.06.16.04.23.30;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.06.26.09.44.20;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.07.15.06.12.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.07.17.05.12.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.07.22.03.00.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.07.24.04.41.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.08.27.03.55.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	98.09.03.07.43.32;	author matz;	state Exp;
branches
	1.1.1.2.2.25.2.1;
next	1.1.1.2.2.26;

1.1.1.2.2.26
date	98.09.08.09.17.38;	author matz;	state Exp;
branches;
next	1.1.1.2.2.27;

1.1.1.2.2.27
date	98.11.09.09.11.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.28;

1.1.1.2.2.28
date	98.12.25.04.35.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.29;

1.1.1.2.2.29
date	99.01.11.07.55.26;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.25.2.1
date	98.09.08.07.08.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25.2.2;

1.1.1.2.2.25.2.2
date	98.10.06.03.28.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25.2.3;

1.1.1.2.2.25.2.3
date	98.11.25.03.31.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25.2.4;

1.1.1.2.2.25.2.4
date	98.12.16.07.30.31;	author matz;	state Exp;
branches;
next	;

1.5.2.1
date	99.11.29.06.31.00;	author matz;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	99.12.06.09.03.32;	author matz;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	99.12.08.05.35.57;	author matz;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	99.12.14.06.50.37;	author matz;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2000.01.05.04.41.03;	author matz;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2000.01.17.08.24.01;	author matz;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2000.03.13.09.15.39;	author matz;	state Exp;
branches;
next	1.5.2.8;

1.5.2.8
date	2000.04.10.05.48.32;	author matz;	state Exp;
branches;
next	1.5.2.9;

1.5.2.9
date	2000.06.05.09.00.53;	author matz;	state Exp;
branches;
next	;

1.48.2.1
date	2000.12.29.03.48.35;	author matz;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2001.01.09.07.29.03;	author matz;	state Exp;
branches;
next	1.48.2.3;

1.48.2.3
date	2001.01.09.08.17.11;	author matz;	state Exp;
branches;
next	1.48.2.4;

1.48.2.4
date	2001.01.09.08.19.42;	author matz;	state Exp;
branches;
next	1.48.2.5;

1.48.2.5
date	2001.01.10.05.05.09;	author matz;	state Exp;
branches;
next	1.48.2.6;

1.48.2.6
date	2001.01.23.09.54.35;	author matz;	state Exp;
branches;
next	1.48.2.7;

1.48.2.7
date	2001.02.02.11.39.51;	author matz;	state Exp;
branches;
next	1.48.2.8;

1.48.2.8
date	2001.02.08.09.17.57;	author matz;	state Exp;
branches;
next	1.48.2.9;

1.48.2.9
date	2001.02.11.07.11.47;	author eban;	state Exp;
branches;
next	1.48.2.10;

1.48.2.10
date	2001.03.21.09.43.10;	author matz;	state Exp;
branches;
next	1.48.2.11;

1.48.2.11
date	2001.03.22.08.59.26;	author matz;	state Exp;
branches;
next	1.48.2.12;

1.48.2.12
date	2001.04.10.06.09.00;	author matz;	state Exp;
branches;
next	1.48.2.13;

1.48.2.13
date	2001.04.19.09.16.07;	author matz;	state Exp;
branches;
next	1.48.2.14;

1.48.2.14
date	2001.04.24.06.44.13;	author matz;	state Exp;
branches;
next	1.48.2.15;

1.48.2.15
date	2001.05.01.08.45.11;	author matz;	state Exp;
branches;
next	1.48.2.16;

1.48.2.16
date	2001.06.11.06.26.17;	author matz;	state Exp;
branches;
next	1.48.2.17;

1.48.2.17
date	2001.06.19.15.42.00;	author eban;	state Exp;
branches;
next	1.48.2.18;

1.48.2.18
date	2001.06.29.08.32.52;	author matz;	state Exp;
branches;
next	1.48.2.19;

1.48.2.19
date	2001.07.20.15.20.25;	author knu;	state Exp;
branches;
next	1.48.2.20;

1.48.2.20
date	2001.08.06.03.10.23;	author matz;	state Exp;
branches;
next	1.48.2.21;

1.48.2.21
date	2002.02.13.09.02.15;	author matz;	state Exp;
branches;
next	1.48.2.22;

1.48.2.22
date	2002.03.07.11.19.28;	author nobu;	state Exp;
branches;
next	1.48.2.23;

1.48.2.23
date	2002.05.04.12.04.52;	author knu;	state Exp;
branches;
next	1.48.2.24;

1.48.2.24
date	2002.05.14.06.10.49;	author eban;	state Exp;
branches;
next	1.48.2.25;

1.48.2.25
date	2002.06.12.09.24.58;	author matz;	state Exp;
branches;
next	1.48.2.26;

1.48.2.26
date	2002.08.12.07.40.32;	author matz;	state Exp;
branches;
next	1.48.2.27;

1.48.2.27
date	2002.09.02.15.20.12;	author aamine;	state Exp;
branches;
next	1.48.2.28;

1.48.2.28
date	2002.09.05.20.08.48;	author aamine;	state Exp;
branches;
next	1.48.2.29;

1.48.2.29
date	2002.10.10.07.01.11;	author nobu;	state Exp;
branches;
next	1.48.2.30;

1.48.2.30
date	2002.10.10.14.15.59;	author eban;	state Exp;
branches;
next	1.48.2.31;

1.48.2.31
date	2002.10.25.19.37.49;	author knu;	state Exp;
branches;
next	1.48.2.32;

1.48.2.32
date	2002.10.26.15.57.23;	author knu;	state Exp;
branches;
next	;

1.49.2.1
date	2001.01.12.04.36.00;	author matz;	state Exp;
branches;
next	;


desc
@@


1.112
log
@* eval.c, file.c, gc.c, io.c, object.c, ruby.c, ruby.h, struct.c,
  ext/socket/socket.c: differentiate long and int; use proper
  printf type specifiers and do casts where appropriate.
@
text
@/**********************************************************************

  gc.c -

  $Author: knu $
  $Date: 2002/10/25 18:39:30 $
  created at: Tue Oct  5 09:44:46 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#include "ruby.h"
#include "rubysig.h"
#include "st.h"
#include "node.h"
#include "env.h"
#include "re.h"
#include <stdio.h>
#include <setjmp.h>
#include <sys/types.h>

#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#endif

#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#endif

void re_free_registers _((struct re_registers*));
void rb_io_fptr_finalize _((struct OpenFile*));

#if !defined(setjmp) && defined(HAVE__SETJMP)
#define setjmp(env) _setjmp(env)
#endif

/* Make alloca work the best possible way.  */
#ifdef __GNUC__
# ifndef atarist
#  ifndef alloca
#   define alloca __builtin_alloca
#  endif
# endif /* atarist */
#else
# ifdef HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifdef _AIX
 #pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
void *alloca ();
#   endif
#  endif /* AIX */
# endif /* HAVE_ALLOCA_H */
#endif /* __GNUC__ */

#ifndef GC_MALLOC_LIMIT
#if defined(MSDOS) || defined(__human68k__)
#define GC_MALLOC_LIMIT 200000
#else
#define GC_MALLOC_LIMIT 8000000
#endif
#endif

static unsigned long malloc_increase = 0;
static unsigned long malloc_limit = GC_MALLOC_LIMIT;
static void run_final();
static VALUE nomem_error;

void
rb_memerror()
{
    static int recurse = 0;

    if (recurse > 0 && rb_safe_level() < 4) {
	fprintf(stderr, "[FATAL] failed to allocate memory\n");
	exit(1);
    }
    recurse++;
    rb_exc_raise(nomem_error);
}

void *
ruby_xmalloc(size)
    long size;
{
    void *mem;

    if (size < 0) {
	rb_raise(rb_eNoMemError, "negative allocation size (or too big)");
    }
    if (size == 0) size = 1;
    malloc_increase += size;

    if (malloc_increase > malloc_limit) {
	rb_gc();
    }
    RUBY_CRITICAL(mem = malloc(size));
    if (!mem) {
	rb_gc();
	RUBY_CRITICAL(mem = malloc(size));
	if (!mem) {
	    rb_memerror();
	}
    }

    return mem;
}

void *
ruby_xcalloc(n, size)
    long n, size;
{
    void *mem;

    mem = xmalloc(n * size);
    memset(mem, 0, n * size);

    return mem;
}

void *
ruby_xrealloc(ptr, size)
    void *ptr;
    long size;
{
    void *mem;

    if (size < 0) {
	rb_raise(rb_eArgError, "negative re-allocation size");
    }
    if (!ptr) return xmalloc(size);
    if (size == 0) size = 1;
    malloc_increase += size;
    RUBY_CRITICAL(mem = realloc(ptr, size));
    if (!mem) {
	rb_gc();
	RUBY_CRITICAL(mem = realloc(ptr, size));
	if (!mem) {
	    rb_memerror();
        }
    }

    return mem;
}

void
ruby_xfree(x)
    void *x;
{
    if (x)
	RUBY_CRITICAL(free(x));
}

extern int ruby_in_compile;
static int dont_gc;
static int during_gc;
static int need_call_final = 0;
static st_table *finalizer_table = 0;

VALUE
rb_gc_enable()
{
    int old = dont_gc;

    dont_gc = Qfalse;
    return old;
}

VALUE
rb_gc_disable()
{
    int old = dont_gc;

    dont_gc = Qtrue;
    return old;
}

VALUE rb_mGC;

static struct gc_list {
    VALUE *varptr;
    struct gc_list *next;
} *global_List = 0;

void
rb_gc_register_address(addr)
    VALUE *addr;
{
    struct gc_list *tmp;

    tmp = ALLOC(struct gc_list);
    tmp->next = global_List;
    tmp->varptr = addr;
    global_List = tmp;
}

void
rb_gc_unregister_address(addr)
    VALUE *addr;
{
    struct gc_list *tmp = global_List;

    if (tmp->varptr == addr) {
	global_List = tmp->next;
	RUBY_CRITICAL(free(tmp));
	return;
    }
    while (tmp->next) {
	if (tmp->next->varptr == addr) {
	    struct gc_list *t = tmp->next;

	    tmp->next = tmp->next->next;
	    RUBY_CRITICAL(free(t));
	    break;
	}
	tmp = tmp->next;
    }
}

void
rb_global_variable(var)
    VALUE *var;
{
    rb_gc_register_address(var);
}

typedef struct RVALUE {
    union {
	struct {
	    unsigned long flags;	/* always 0 for freed obj */
	    struct RVALUE *next;
	} free;
	struct RBasic  basic;
	struct RObject object;
	struct RClass  klass;
	struct RFloat  flonum;
	struct RString string;
	struct RArray  array;
	struct RRegexp regexp;
	struct RHash   hash;
	struct RData   data;
	struct RStruct rstruct;
	struct RBignum bignum;
	struct RFile   file;
	struct RNode   node;
	struct RMatch  match;
	struct RVarmap varmap; 
	struct SCOPE   scope;
    } as;
} RVALUE;

static RVALUE *freelist = 0;
static RVALUE *deferred_final_list = 0;

#define HEAPS_INCREMENT 10
static RVALUE **heaps;
static int heaps_length = 0;
static int heaps_used   = 0;

#define HEAP_MIN_SLOTS 10000
static int *heaps_limits;
static int heap_slots = HEAP_MIN_SLOTS;

#define FREE_MIN  4096

static RVALUE *himem, *lomem;

static void
add_heap()
{
    RVALUE *p, *pend;

    if (heaps_used == heaps_length) {
	/* Realloc heaps */
	heaps_length += HEAPS_INCREMENT;
	RUBY_CRITICAL(heaps = (heaps_used>0)?
			(RVALUE**)realloc(heaps, heaps_length*sizeof(RVALUE*)):
			(RVALUE**)malloc(heaps_length*sizeof(RVALUE*)));
	if (heaps == 0) rb_memerror();
	RUBY_CRITICAL(heaps_limits = (heaps_used>0)?
			(int*)realloc(heaps_limits, heaps_length*sizeof(int)):
			(int*)malloc(heaps_length*sizeof(int)));
	if (heaps_limits == 0) rb_memerror();
    }

    for (;;) {
	RUBY_CRITICAL(p = heaps[heaps_used] = (RVALUE*)malloc(sizeof(RVALUE)*heap_slots));
	heaps_limits[heaps_used] = heap_slots;
	if (p == 0) {
	    if (heap_slots == HEAP_MIN_SLOTS) {
		rb_memerror();
	    }
	    heap_slots = HEAP_MIN_SLOTS;
	    continue;
	}
	break;
    }
    pend = p + heap_slots;
    if (lomem == 0 || lomem > p) lomem = p;
    if (himem < pend) himem = pend;
    heaps_used++;
    heap_slots *= 1.8;

    while (p < pend) {
	p->as.free.flags = 0;
	p->as.free.next = freelist;
	freelist = p;
	p++;
    }
}
#define RANY(o) ((RVALUE*)(o))

VALUE
rb_newobj()
{
    VALUE obj;

    if (!freelist) rb_gc();

    obj = (VALUE)freelist;
    freelist = freelist->as.free.next;
    MEMZERO((void*)obj, RVALUE, 1);
    return obj;
}

VALUE
rb_data_object_alloc(klass, datap, dmark, dfree)
    VALUE klass;
    void *datap;
    RUBY_DATA_FUNC dmark;
    RUBY_DATA_FUNC dfree;
{
    NEWOBJ(data, struct RData);
    OBJSETUP(data, klass, T_DATA);
    data->data = datap;
    data->dfree = dfree;
    data->dmark = dmark;

    return (VALUE)data;
}

extern st_table *rb_class_tbl;
VALUE *rb_gc_stack_start = 0;

#ifdef DJGPP
static unsigned int STACK_LEVEL_MAX = 65535;
#else
#ifdef __human68k__
extern unsigned int _stacksize;
# define STACK_LEVEL_MAX (_stacksize - 4096)
# undef HAVE_GETRLIMIT
#else
#ifdef HAVE_GETRLIMIT
static unsigned int STACK_LEVEL_MAX = 655300;
#else
# define STACK_LEVEL_MAX 655300
#endif
#endif
#endif

#ifdef C_ALLOCA
# define SET_STACK_END VALUE stack_end; alloca(0);
# define STACK_END (&stack_end)
#else
# if defined(__GNUC__) && defined(USE_BUILTIN_FRAME_ADDRESS)
#  define  SET_STACK_END    VALUE *stack_end = __builtin_frame_address(0)
# else
#  define  SET_STACK_END    VALUE *stack_end = alloca(1)
# endif
# define STACK_END (stack_end)
#endif
#ifdef __sparc__
# define STACK_LENGTH  (rb_gc_stack_start - STACK_END + 0x80)
#else
# define STACK_LENGTH  ((STACK_END < rb_gc_stack_start) ? rb_gc_stack_start - STACK_END\
                                           : STACK_END - rb_gc_stack_start)
#endif

#define CHECK_STACK(ret) do {\
    SET_STACK_END;\
    (ret) = (STACK_LENGTH > STACK_LEVEL_MAX);\
} while (0)

int
ruby_stack_length(p)
    VALUE **p;
{
    SET_STACK_END;
    if (p) *p = STACK_END;
    return STACK_LENGTH;
}

int
ruby_stack_check()
{
    int ret;

    CHECK_STACK(ret);
    return ret;
}

#define MARK_STACK_MAX 1024
static VALUE mark_stack[MARK_STACK_MAX];
static VALUE *mark_stack_ptr;
static int mark_stack_overflow;

static void
init_mark_stack()
{
    mark_stack_overflow = 0;
    mark_stack_ptr = mark_stack;
}

#define MARK_STACK_EMPTY (mark_stack_ptr == mark_stack)
            
static void rb_gc_mark_children(VALUE ptr);

static st_table *source_filenames;

char *
rb_source_filename(f)
    const char *f;
{
    char *name;

    if (!st_lookup(source_filenames, f, &name)) {
	long len = strlen(f) + 1;
	char *ptr = name = ALLOC_N(char, len + 1);
	*ptr++ = 0;
	MEMCPY(ptr, f, char, len);
	st_add_direct(source_filenames, ptr, name);
	return ptr;
    }
    return name + 1;
}

static void
mark_source_filename(f)
    char *f;
{
    if (f) {
	f[-1] = 1;
    }
}

static enum st_retval
sweep_source_filename(key, value)
    char *key, *value;
{
    if (*value) {
	*value = 0;
	return ST_CONTINUE;
    }
    else {
	free(value);
	return ST_DELETE;
    }
}

static void
gc_mark_all()
{
    RVALUE *p, *pend;
    int i;

    init_mark_stack();
    for (i = 0; i < heaps_used; i++) {
	p = heaps[i]; pend = p + heaps_limits[i];
	while (p < pend) {
	    if ((p->as.basic.flags & FL_MARK) &&
		(p->as.basic.flags != FL_MARK)) {
		rb_gc_mark_children((VALUE)p);
	    }
	    p++;
	}
    }
}

static void
gc_mark_rest()
{
    VALUE tmp_arry[MARK_STACK_MAX];
    VALUE *p;

    p = (mark_stack_ptr - mark_stack) + tmp_arry;
    MEMCPY(tmp_arry, mark_stack, VALUE, MARK_STACK_MAX);

    init_mark_stack();
    
    while(p != tmp_arry){
	p--;
	rb_gc_mark_children(*p);
    }
}

static inline int
is_pointer_to_heap(ptr)
    void *ptr;
{
    register RVALUE *p = RANY(ptr);
    register RVALUE *heap_org;
    register long i;

    if (p < lomem || p > himem) return Qfalse;

    /* check if p looks like a pointer */
    for (i=0; i < heaps_used; i++) {
	heap_org = heaps[i];
	if (heap_org <= p && p < heap_org + heaps_limits[i] &&
	    ((((char*)p)-((char*)heap_org))%sizeof(RVALUE)) == 0)
	    return Qtrue;
    }
    return Qfalse;
}

static void
mark_locations_array(x, n)
    register VALUE *x;
    register long n;
{
    while (n--) {
	if (is_pointer_to_heap((void *)*x)) {
	    rb_gc_mark(*x);
	}
	x++;
    }
}

void
rb_gc_mark_locations(start, end)
    VALUE *start, *end;
{
    VALUE *tmp;
    long n;

    if (start > end) {
	tmp = start;
	start = end;
	end = tmp;
    }
    n = end - start + 1;
    mark_locations_array(start,n);
}

static int
mark_entry(key, value)
    ID key;
    VALUE value;
{
    rb_gc_mark(value);
    return ST_CONTINUE;
}

void
rb_mark_tbl(tbl)
    st_table *tbl;
{
    if (!tbl) return;
    st_foreach(tbl, mark_entry, 0);
}

static int
mark_hashentry(key, value)
    VALUE key;
    VALUE value;
{
    rb_gc_mark(key);
    rb_gc_mark(value);
    return ST_CONTINUE;
}

void
rb_mark_hash(tbl)
    st_table *tbl;
{
    if (!tbl) return;
    st_foreach(tbl, mark_hashentry, 0);
}

void
rb_gc_mark_maybe(obj)
    VALUE obj;
{
    if (is_pointer_to_heap((void *)obj)) {
	rb_gc_mark(obj);
    }
}

void
rb_gc_mark(ptr)
    VALUE ptr;
{
    int ret;
    register RVALUE *obj = RANY(ptr);

    if (rb_special_const_p(ptr)) return; /* special const not marked */
    if (obj->as.basic.flags == 0) return;       /* free cell */
    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */ 

    obj->as.basic.flags |= FL_MARK;

    CHECK_STACK(ret);
    if (ret) {
	if (!mark_stack_overflow) {
	    if (mark_stack_ptr - mark_stack < MARK_STACK_MAX) {
		*mark_stack_ptr = ptr;
		mark_stack_ptr++;		
	    }
	    else {
		mark_stack_overflow = 1;
	    }
	}
    }
    else {
	rb_gc_mark_children(ptr);
    }
}

void
rb_gc_mark_children(ptr)
    VALUE ptr;
{
    register RVALUE *obj = RANY(ptr);	
    
    if (FL_TEST(obj, FL_EXIVAR)) {
	rb_mark_generic_ivar((VALUE)obj);
    }

    switch (obj->as.basic.flags & T_MASK) {
      case T_NIL:
      case T_FIXNUM:
	rb_bug("rb_gc_mark() called for broken object");
	break;

      case T_NODE:
	mark_source_filename(obj->as.node.nd_file);
	switch (nd_type(obj)) {
	  case NODE_IF:		/* 1,2,3 */
	  case NODE_FOR:
	  case NODE_ITER:
	  case NODE_CREF:
	  case NODE_WHEN:
	  case NODE_MASGN:
	  case NODE_RESCUE:
	  case NODE_RESBODY:
	    rb_gc_mark((VALUE)obj->as.node.u2.node);
	    /* fall through */
	  case NODE_BLOCK:	/* 1,3 */
	  case NODE_ARRAY:
	  case NODE_DSTR:
	  case NODE_DXSTR:
	  case NODE_DREGX:
	  case NODE_DREGX_ONCE:
	  case NODE_FBODY:
	  case NODE_ENSURE:
	  case NODE_CALL:
	  case NODE_DEFS:
	  case NODE_OP_ASGN1:
	    rb_gc_mark((VALUE)obj->as.node.u1.node);
	    /* fall through */
	  case NODE_SUPER:	/* 3 */
	  case NODE_FCALL:
	  case NODE_DEFN:
	  case NODE_NEWLINE:
	    rb_gc_mark((VALUE)obj->as.node.u3.node);	    
	    break;

	  case NODE_WHILE:	/* 1,2 */
	  case NODE_UNTIL:
	  case NODE_AND:
	  case NODE_OR:
	  case NODE_CASE:
	  case NODE_SCLASS:
	  case NODE_DOT2:
	  case NODE_DOT3:
	  case NODE_FLIP2:
	  case NODE_FLIP3:
	  case NODE_MATCH2:
	  case NODE_MATCH3:
	  case NODE_OP_ASGN_OR:
	  case NODE_OP_ASGN_AND:
	    rb_gc_mark((VALUE)obj->as.node.u1.node);
	    /* fall through */
	  case NODE_METHOD:	/* 2 */
	  case NODE_NOT:
	  case NODE_GASGN:
	  case NODE_LASGN:
	  case NODE_DASGN:
	  case NODE_DASGN_CURR:
	  case NODE_IASGN:
	  case NODE_CDECL:
	  case NODE_CVDECL:
	  case NODE_CVASGN:
	  case NODE_MODULE:
	  case NODE_COLON3:
	  case NODE_OPT_N:
	  case NODE_EVSTR:
	    rb_gc_mark((VALUE)obj->as.node.u2.node);
	    break;

	  case NODE_HASH:	/* 1 */
	  case NODE_LIT:
	  case NODE_STR:
	  case NODE_XSTR:
	  case NODE_DEFINED:
	  case NODE_MATCH:
	  case NODE_RETURN:
	  case NODE_BREAK:
	  case NODE_NEXT:
	  case NODE_YIELD:
	  case NODE_COLON2:
	  case NODE_ARGS:
	    rb_gc_mark((VALUE)obj->as.node.u1.node);
	    break;

	  case NODE_SCOPE:	/* 2,3 */
	  case NODE_CLASS:
	  case NODE_BLOCK_PASS:
	    rb_gc_mark((VALUE)obj->as.node.u3.node);
	    rb_gc_mark((VALUE)obj->as.node.u2.node);
	    break;

	  case NODE_ZARRAY:	/* - */
	  case NODE_ZSUPER:
	  case NODE_CFUNC:
	  case NODE_VCALL:
	  case NODE_GVAR:
	  case NODE_LVAR:
	  case NODE_DVAR:
	  case NODE_IVAR:
	  case NODE_CVAR:
	  case NODE_NTH_REF:
	  case NODE_BACK_REF:
	  case NODE_ALIAS:
	  case NODE_VALIAS:
	  case NODE_REDO:
	  case NODE_RETRY:
	  case NODE_UNDEF:
	  case NODE_SELF:
	  case NODE_NIL:
	  case NODE_TRUE:
	  case NODE_FALSE:
	  case NODE_ATTRSET:
	  case NODE_BLOCK_ARG:
	  case NODE_POSTEXE:
	    break;
#ifdef C_ALLOCA
	  case NODE_ALLOCA:
	    mark_locations_array((VALUE*)obj->as.node.u1.value,
				 obj->as.node.u3.cnt);
	    rb_gc_mark((VALUE)obj->as.node.u2.node);	    
	    break;
#endif

	  default:
	    if (is_pointer_to_heap(obj->as.node.u1.node)) {
		rb_gc_mark((VALUE)obj->as.node.u1.node);
	    }
	    if (is_pointer_to_heap(obj->as.node.u2.node)) {
		rb_gc_mark((VALUE)obj->as.node.u2.node);
	    }
	    if (is_pointer_to_heap(obj->as.node.u3.node)) {
		rb_gc_mark((VALUE)obj->as.node.u3.node);
	    }
	}
	return;			/* no need to mark class. */
    }

    rb_gc_mark(obj->as.basic.klass);
    switch (obj->as.basic.flags & T_MASK) {
      case T_ICLASS:
      case T_CLASS:
      case T_MODULE:
	rb_gc_mark(obj->as.klass.super);
	rb_mark_tbl(obj->as.klass.m_tbl);
	rb_mark_tbl(obj->as.klass.iv_tbl);
	break;

      case T_ARRAY:
	if (FL_TEST(obj, ELTS_SHARED)) {
	    rb_gc_mark(obj->as.array.aux.shared);
	}
	else {
	    long i, len = obj->as.array.len;
	    VALUE *ptr = obj->as.array.ptr;

	    for (i=0; i < len; i++) {
		rb_gc_mark(*ptr++);
	    }
	}
	break;

      case T_HASH:
	rb_mark_hash(obj->as.hash.tbl);
	rb_gc_mark(obj->as.hash.ifnone);
	break;

      case T_STRING:
#define STR_ASSOC FL_USER3   /* copied from string.c */
	if (FL_TEST(obj, ELTS_SHARED|STR_ASSOC)) {
	    rb_gc_mark(obj->as.string.aux.shared);
	}
	break;

      case T_DATA:
	if (obj->as.data.dmark) (*obj->as.data.dmark)(DATA_PTR(obj));
	break;

      case T_OBJECT:
	rb_mark_tbl(obj->as.object.iv_tbl);
	break;

      case T_FILE:
      case T_REGEXP:
      case T_FLOAT:
      case T_BIGNUM:
      case T_BLKTAG:
	break;

      case T_MATCH:
	if (obj->as.match.str) {
	    rb_gc_mark((VALUE)obj->as.match.str);
	}
	break;

      case T_VARMAP:
	rb_gc_mark(obj->as.varmap.val);
	rb_gc_mark((VALUE)obj->as.varmap.next);
	break;

      case T_SCOPE:
	if (obj->as.scope.local_vars && (obj->as.scope.flags & SCOPE_MALLOC)) {
	    int n = obj->as.scope.local_tbl[0]+1;
	    VALUE *vars = &obj->as.scope.local_vars[-1];

	    while (n--) {
		rb_gc_mark(*vars);
		vars++;
	    }
	}
	break;

      case T_STRUCT:
	{
	    long i, len = obj->as.rstruct.len;
	    VALUE *ptr = obj->as.rstruct.ptr;

	    for (i=0; i < len; i++)
		rb_gc_mark(*ptr++);
	}
	break;

      default:
	rb_bug("rb_gc_mark(): unknown data type 0x%lx(0x%lx) %s",
	       obj->as.basic.flags & T_MASK, obj,
	       is_pointer_to_heap(obj) ? "corrupted object" : "non object");
    }
}

static void obj_free _((VALUE));

static unsigned long
size_of_table(tbl)
    struct st_table *tbl;
{
    if (!tbl) return 0;
    return tbl->num_bins * sizeof(struct st_table_entry *) +
	tbl->num_entries * 4 * sizeof(VALUE);
}

static void
gc_sweep()
{
    RVALUE *p, *pend, *final_list;
    int freed = 0;
    int i, j;
    unsigned long live = 0;

    if (ruby_in_compile && ruby_parser_stack_on_heap()) {
	/* should not reclaim nodes during compilation
           if yacc's semantic stack is not allocated on machine stack */
	for (i = 0; i < heaps_used; i++) {
	    p = heaps[i]; pend = p + heaps_limits[i];
	    while (p < pend) {
		if (!(p->as.basic.flags&FL_MARK) && BUILTIN_TYPE(p) == T_NODE)
		    rb_gc_mark((VALUE)p);
		p++;
	    }
	}
    }

    mark_source_filename(ruby_sourcefile);
    st_foreach(source_filenames, sweep_source_filename, 0);

    freelist = 0;
    final_list = deferred_final_list;
    deferred_final_list = 0;
    for (i = 0; i < heaps_used; i++) {
	int n = 0;
	RVALUE *free = freelist;
	RVALUE *final = final_list;

	p = heaps[i]; pend = p + heaps_limits[i];
	while (p < pend) {
	    if (!(p->as.basic.flags & FL_MARK)) {
		if (p->as.basic.flags) {
		    obj_free((VALUE)p);
		}
		if (need_call_final && FL_TEST(p, FL_FINALIZE)) {
		    p->as.free.flags = FL_MARK; /* remain marked */
		    p->as.free.next = final_list;
		    final_list = p;
		}
		else {
		    p->as.free.flags = 0;
		    p->as.free.next = freelist;
		    freelist = p;
		}
		n++;
	    }
	    else if (RBASIC(p)->flags == FL_MARK) {
		/* objects to be finalized */
		/* do notning remain marked */
	    }
	    else {
		RBASIC(p)->flags &= ~FL_MARK;
		live += sizeof(VALUE);
		switch (BUILTIN_TYPE(p)) {
		  case T_OBJECT:
		    live += size_of_table(ROBJECT(p)->iv_tbl);
		    break;
		  case T_CLASS:
		  case T_ICLASS:
		    live += size_of_table(RCLASS(p)->iv_tbl);
		    live += size_of_table(RCLASS(p)->m_tbl);
		    break;
		  case T_STRING:
		    live += RSTRING(p)->len+1;
		    break;
		  case T_ARRAY:
		    live += RARRAY(p)->len * sizeof(VALUE);
		    break;
		  case T_HASH:
		    live += size_of_table(RHASH(p)->tbl);
		    break;
		  case T_BIGNUM:
		    live += RBIGNUM(p)->len * sizeof(BDIGIT);
		    break;
		  case T_STRUCT:
		    live += RSTRUCT(p)->len * sizeof(VALUE);
		    break;
		}
	    }
	    p++;
	}
	if (n == heaps_limits[i] && freed + n > FREE_MIN) {
	    RVALUE *pp;

	    heaps_limits[i] = 0;
	    for (pp = final_list; pp != final; pp = pp->as.free.next) {
		p->as.free.flags |= FL_SINGLETON; /* freeing page mark */
	    }
	    freelist = free;	/* cancel this page from freelist */
	}
	else {
	    freed += n;
	}
    }
    malloc_limit = live;
    malloc_increase = 0;
    if (freed < FREE_MIN) {
	add_heap();
    }
    during_gc = 0;

    /* clear finalization list */
    if (final_list) {
	RVALUE *tmp;

	if (rb_prohibit_interrupt || ruby_in_compile) {
	    deferred_final_list = final_list;
	    return;
	}

	for (p = final_list; p; p = tmp) {
	    tmp = p->as.free.next;
	    run_final((VALUE)p);
	    if (!FL_TEST(p, FL_SINGLETON)) { /* not freeing page */
		p->as.free.flags = 0;
		p->as.free.next = freelist;
		freelist = p;
	    }
	}
    }
    for (i = j = 1; j < heaps_used; i++) {
	if (heaps_limits[i] == 0) {
	    free(heaps[i]);
	    heaps_used--;
	}
	else {
	    if (i != j) {
		heaps[j] = heaps[i];
		heaps_limits[j] = heaps_limits[i];
	    }
	    j++;
	}
    }
}

void
rb_gc_force_recycle(p)
    VALUE p;
{
    RANY(p)->as.free.flags = 0;
    RANY(p)->as.free.next = freelist;
    freelist = RANY(p);
}

static void
obj_free(obj)
    VALUE obj;
{
    switch (RANY(obj)->as.basic.flags & T_MASK) {
      case T_NIL:
      case T_FIXNUM:
      case T_TRUE:
      case T_FALSE:
	rb_bug("obj_free() called for broken object");
	break;
    }

    if (FL_TEST(obj, FL_EXIVAR)) {
	rb_free_generic_ivar((VALUE)obj);
    }

    switch (RANY(obj)->as.basic.flags & T_MASK) {
      case T_OBJECT:
	if (RANY(obj)->as.object.iv_tbl) {
	    st_free_table(RANY(obj)->as.object.iv_tbl);
	}
	break;
      case T_MODULE:
      case T_CLASS:
	st_free_table(RANY(obj)->as.klass.m_tbl);
	if (RANY(obj)->as.object.iv_tbl) {
	    st_free_table(RANY(obj)->as.object.iv_tbl);
	}
	break;
      case T_STRING:
	if (RANY(obj)->as.string.ptr && !FL_TEST(obj, ELTS_SHARED)) {
	    RUBY_CRITICAL(free(RANY(obj)->as.string.ptr));
	}
	break;
      case T_ARRAY:
	if (RANY(obj)->as.array.ptr && !FL_TEST(obj, ELTS_SHARED)) {
	    RUBY_CRITICAL(free(RANY(obj)->as.array.ptr));
	}
	break;
      case T_HASH:
	if (RANY(obj)->as.hash.tbl) {
	    st_free_table(RANY(obj)->as.hash.tbl);
	}
	break;
      case T_REGEXP:
	if (RANY(obj)->as.regexp.ptr) {
	    re_free_pattern(RANY(obj)->as.regexp.ptr);
	}
	if (RANY(obj)->as.regexp.str) {
	    RUBY_CRITICAL(free(RANY(obj)->as.regexp.str));
	}
	break;
      case T_DATA:
	if (DATA_PTR(obj)) {
	    if ((long)RANY(obj)->as.data.dfree == -1) {
		RUBY_CRITICAL(free(DATA_PTR(obj)));
	    }
	    else if (RANY(obj)->as.data.dfree) {
		(*RANY(obj)->as.data.dfree)(DATA_PTR(obj));
	    }
	}
	break;
      case T_MATCH:
	if (RANY(obj)->as.match.regs) {
	    re_free_registers(RANY(obj)->as.match.regs);
	    RUBY_CRITICAL(free(RANY(obj)->as.match.regs));
	}
	break;
      case T_FILE:
	if (RANY(obj)->as.file.fptr) {
	    rb_io_fptr_finalize(RANY(obj)->as.file.fptr);
	    RUBY_CRITICAL(free(RANY(obj)->as.file.fptr));
	}
	break;
      case T_ICLASS:
	/* iClass shares table with the module */
	break;

      case T_FLOAT:
      case T_VARMAP:
      case T_BLKTAG:
	break;

      case T_BIGNUM:
	if (RANY(obj)->as.bignum.digits) {
	    RUBY_CRITICAL(free(RANY(obj)->as.bignum.digits));
	}
	break;
      case T_NODE:
	switch (nd_type(obj)) {
	  case NODE_SCOPE:
	    if (RANY(obj)->as.node.u1.tbl) {
		RUBY_CRITICAL(free(RANY(obj)->as.node.u1.tbl));
	    }
	    break;
#ifdef C_ALLOCA
	  case NODE_ALLOCA:
	    RUBY_CRITICAL(free(RANY(obj)->as.node.u1.node));
	    break;
#endif
	}
	return;			/* no need to free iv_tbl */

      case T_SCOPE:
	if (RANY(obj)->as.scope.local_vars &&
            RANY(obj)->as.scope.flags != SCOPE_ALLOCA) {
	    VALUE *vars = RANY(obj)->as.scope.local_vars-1;
	    if (vars[0] == 0)
		RUBY_CRITICAL(free(RANY(obj)->as.scope.local_tbl));
	    if (RANY(obj)->as.scope.flags & SCOPE_MALLOC)
		RUBY_CRITICAL(free(vars));
	}
	break;

      case T_STRUCT:
	if (RANY(obj)->as.rstruct.ptr) {
	    RUBY_CRITICAL(free(RANY(obj)->as.rstruct.ptr));
	}
	break;

      default:
	rb_bug("gc_sweep(): unknown data type 0x%lx(%ld)", obj,
	       RANY(obj)->as.basic.flags & T_MASK);
    }
}

void
rb_gc_mark_frame(frame)
    struct FRAME *frame;
{
    mark_locations_array(frame->argv, frame->argc);
    rb_gc_mark(frame->cbase);
}

#ifdef __GNUC__
#if defined(__human68k__) || defined(DJGPP)
#if defined(__human68k__)
typedef unsigned long rb_jmp_buf[8];
__asm__ (".even\n\
_rb_setjmp:\n\
	move.l	4(sp),a0\n\
	movem.l	d3-d7/a3-a5,(a0)\n\
	moveq.l	#0,d0\n\
	rts");
#ifdef setjmp
#undef setjmp
#endif
#else
#if defined(DJGPP)
typedef unsigned long rb_jmp_buf[6];
__asm__ (".align 4\n\
_rb_setjmp:\n\
	pushl	%ebp\n\
	movl	%esp,%ebp\n\
	movl	8(%ebp),%ebp\n\
	movl	%eax,(%ebp)\n\
	movl	%ebx,4(%ebp)\n\
	movl	%ecx,8(%ebp)\n\
	movl	%edx,12(%ebp)\n\
	movl	%esi,16(%ebp)\n\
	movl	%edi,20(%ebp)\n\
	popl	%ebp\n\
	xorl	%eax,%eax\n\
	ret");
#endif
#endif
int rb_setjmp (rb_jmp_buf);
#define jmp_buf rb_jmp_buf
#define setjmp rb_setjmp
#endif /* __human68k__ or DJGPP */
#endif /* __GNUC__ */

void
rb_gc()
{
    struct gc_list *list;
    struct FRAME * volatile frame; /* gcc 2.7.2.3 -O2 bug??  */
    jmp_buf save_regs_gc_mark;
    SET_STACK_END;

    if (dont_gc || during_gc) {
	if (!freelist) {
	    add_heap();
	}
	return;
    }

    if (during_gc) return;
    during_gc++;

    init_mark_stack();
    
    /* mark frame stack */
    for (frame = ruby_frame; frame; frame = frame->prev) {
	rb_gc_mark_frame(frame); 
	if (frame->tmp) {
	    struct FRAME *tmp = frame->tmp;
	    while (tmp) {
		rb_gc_mark_frame(tmp);
		tmp = tmp->prev;
	    }
	}
    }
    rb_gc_mark((VALUE)ruby_class);
    rb_gc_mark((VALUE)ruby_scope);
    rb_gc_mark((VALUE)ruby_dyna_vars);
    if (finalizer_table) {
	rb_mark_tbl(finalizer_table);
    }

    FLUSH_REGISTER_WINDOWS;
    /* This assumes that all registers are saved into the jmp_buf */
    setjmp(save_regs_gc_mark);
    mark_locations_array((VALUE*)save_regs_gc_mark, sizeof(save_regs_gc_mark) / sizeof(VALUE *));
    rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END);
#if defined(__human68k__)
    rb_gc_mark_locations((VALUE*)((char*)rb_gc_stack_start + 2),
			 (VALUE*)((char*)STACK_END + 2));
#endif
    rb_gc_mark_threads();

    /* mark protected global variables */
    for (list = global_List; list; list = list->next) {
	rb_gc_mark(*list->varptr);
    }
    rb_mark_end_proc();
    rb_gc_mark_global_tbl();

    rb_mark_tbl(rb_class_tbl);
    rb_gc_mark_trap_list();

    /* mark generic instance variables for special constants */
    rb_mark_generic_ivar_tbl();

    rb_gc_mark_parser();
    
    /* gc_mark objects whose marking are not completed*/
    while (!MARK_STACK_EMPTY){
	if (mark_stack_overflow){
	    gc_mark_all();
	}
	else {
	    gc_mark_rest();
	}
    }
    gc_sweep();
}

VALUE
rb_gc_start()
{
    rb_gc();
    return Qnil;
}

void
Init_stack(addr)
    VALUE *addr;
{
#if defined(__human68k__)
    extern void *_SEND;
    rb_gc_stack_start = _SEND;
#else
    if (!addr) addr = (VALUE *)&addr;
    rb_gc_stack_start = addr;
#endif
#ifdef HAVE_GETRLIMIT
    {
	struct rlimit rlim;

	if (getrlimit(RLIMIT_STACK, &rlim) == 0) {
	    double space = (double)rlim.rlim_cur*0.2;

	    if (space > 1024*1024) space = 1024*1024;
	    STACK_LEVEL_MAX = (rlim.rlim_cur - space) / sizeof(VALUE);
	}
    }
#endif
}

void
Init_heap()
{
    if (!rb_gc_stack_start) {
	Init_stack(0);
    }
    add_heap();
}

static VALUE
os_live_obj()
{
    int i;
    int n = 0;

    for (i = 0; i < heaps_used; i++) {
	RVALUE *p, *pend;

	p = heaps[i]; pend = p + heaps_limits[i];
	for (;p < pend; p++) {
	    if (p->as.basic.flags) {
		switch (TYPE(p)) {
		  case T_ICLASS:
		  case T_VARMAP:
		  case T_SCOPE:
		  case T_NODE:
		    continue;
		  case T_CLASS:
		    if (FL_TEST(p, FL_SINGLETON)) continue;
		  default:
		    if (!p->as.basic.klass) continue;
		    rb_yield((VALUE)p);
		    n++;
		}
	    }
	}
    }

    return INT2FIX(n);
}

static VALUE
os_obj_of(of)
    VALUE of;
{
    int i;
    int n = 0;

    for (i = 0; i < heaps_used; i++) {
	RVALUE *p, *pend;

	p = heaps[i]; pend = p + heaps_limits[i];
	for (;p < pend; p++) {
	    if (p->as.basic.flags) {
		switch (TYPE(p)) {
		  case T_ICLASS:
		  case T_VARMAP:
		  case T_SCOPE:
		  case T_NODE:
		    continue;
		  case T_CLASS:
		    if (FL_TEST(p, FL_SINGLETON)) continue;
		  default:
		    if (!p->as.basic.klass) continue;
		    if (rb_obj_is_kind_of((VALUE)p, of)) {
			rb_yield((VALUE)p);
			n++;
		    }
		}
	    }
	}
    }

    return INT2FIX(n);
}

static VALUE
os_each_obj(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE of;

    if (rb_scan_args(argc, argv, "01", &of) == 0) {
	return os_live_obj();
    }
    else {
	return os_obj_of(of);
    }
}

static VALUE finalizers;

static VALUE
add_final(os, proc)
    VALUE os, proc;
{
    rb_warn("ObjectSpace::add_finalizer is deprecated; use define_finalizer");
    if (!rb_obj_is_kind_of(proc, rb_cProc)) {
	rb_raise(rb_eArgError, "wrong type argument %s (Proc required)",
		 rb_class2name(CLASS_OF(proc)));
    }
    rb_ary_push(finalizers, proc);
    return proc;
}

static VALUE
rm_final(os, proc)
    VALUE os, proc;
{
    rb_warn("ObjectSpace::remove_finalizer is deprecated; use undefine_finalizer");
    rb_ary_delete(finalizers, proc);
    return proc;
}

static VALUE
finals()
{
    rb_warn("ObjectSpace::finalizers is deprecated");
    return finalizers;
}

static VALUE
call_final(os, obj)
    VALUE os, obj;
{
    rb_warn("ObjectSpace::call_finalizer is deprecated; use define_finalizer");
    need_call_final = 1;
    FL_SET(obj, FL_FINALIZE);
    return obj;
}

static VALUE
undefine_final(os, obj)
    VALUE os, obj;
{
    if (finalizer_table) {
	st_delete(finalizer_table, &obj, 0);
    }
    return obj;
}

static VALUE
define_final(argc, argv, os)
    int argc;
    VALUE *argv;
    VALUE os;
{
    VALUE obj, proc, table;

    rb_scan_args(argc, argv, "11", &obj, &proc);
    if (argc == 1) {
	proc = rb_f_lambda();
    }
    else if (!rb_obj_is_kind_of(proc, rb_cProc)) {
	rb_raise(rb_eArgError, "wrong type argument %s (Proc required)",
		 rb_class2name(CLASS_OF(proc)));
    }
    need_call_final = 1;
    FL_SET(obj, FL_FINALIZE);

    if (!finalizer_table) {
	finalizer_table = st_init_numtable();
    }
    if (st_lookup(finalizer_table, obj, &table)) {
	rb_ary_push(table, proc);
    }
    else {
	st_add_direct(finalizer_table, obj, rb_ary_new3(1, proc));
    }
    return proc;
}

static VALUE
run_single_final(args)
    VALUE *args;
{
    rb_eval_cmd(args[0], args[1], 0);
    return Qnil;
}

static void
run_final(obj)
    VALUE obj;
{
    long i;
    int status;
    VALUE args[2], table;

    args[1] = rb_ary_new3(1, rb_obj_id(obj)); /* make obj into id */
    for (i=0; i<RARRAY(finalizers)->len; i++) {
	args[0] = RARRAY(finalizers)->ptr[i];
	rb_protect((VALUE(*)_((VALUE)))run_single_final, (VALUE)args, &status);
    }
    if (finalizer_table && st_delete(finalizer_table, &obj, &table)) {
	for (i=0; i<RARRAY(table)->len; i++) {
	    args[0] = RARRAY(table)->ptr[i];
	    rb_protect((VALUE(*)_((VALUE)))run_single_final, (VALUE)args, &status);
	}
    }
}

void
rb_gc_call_finalizer_at_exit()
{
    RVALUE *p, *pend;
    int i;

    /* run finalizers */
    if (need_call_final) {
	if (deferred_final_list) {
	    p = deferred_final_list;
	    while (p) {
		RVALUE *tmp = p;
		p = p->as.free.next;
		run_final((VALUE)tmp);
	    }
	}
	for (i = 0; i < heaps_used; i++) {
	    p = heaps[i]; pend = p + heaps_limits[i];
	    while (p < pend) {
		if (FL_TEST(p, FL_FINALIZE)) {
		    FL_UNSET(p, FL_FINALIZE);
		    p->as.basic.klass = 0;
		    run_final((VALUE)p);
		}
		p++;
	    }
	}
    }
    /* run data object's finaliers */
    for (i = 0; i < heaps_used; i++) {
	p = heaps[i]; pend = p + heaps_limits[i];
	while (p < pend) {
	    if (BUILTIN_TYPE(p) == T_DATA &&
		DATA_PTR(p) && RANY(p)->as.data.dfree) {
		p->as.free.flags = 0;
		(*RANY(p)->as.data.dfree)(DATA_PTR(p));
	    }
	    else if (BUILTIN_TYPE(p) == T_FILE) {
		p->as.free.flags = 0;
		rb_io_fptr_finalize(RANY(p)->as.file.fptr);
	    }
	    p++;
	}
    }
}

static VALUE
id2ref(obj, id)
    VALUE obj, id;
{
    unsigned long ptr, p0;

    rb_secure(4);
    p0 = ptr = NUM2ULONG(id);
    if (ptr == Qtrue) return Qtrue;
    if (ptr == Qfalse) return Qfalse;
    if (ptr == Qnil) return Qnil;
    if (FIXNUM_P(ptr)) return (VALUE)ptr;
    if (SYMBOL_P(ptr) && rb_id2name(SYM2ID((VALUE)ptr)) != 0) {
	return (VALUE)ptr;
    }

    ptr = id ^ FIXNUM_FLAG;	/* unset FIXNUM_FLAG */
    if (!is_pointer_to_heap((void *)ptr)) {
	rb_raise(rb_eRangeError, "0x%lx is not id value", p0);
    }
    if (BUILTIN_TYPE(ptr) == 0) {
	rb_raise(rb_eRangeError, "0x%lx is recycled object", p0);
    }
    return (VALUE)ptr;
}

void
Init_GC()
{
    VALUE rb_mObSpace;

    rb_mGC = rb_define_module("GC");
    rb_define_singleton_method(rb_mGC, "start", rb_gc_start, 0);
    rb_define_singleton_method(rb_mGC, "enable", rb_gc_enable, 0);
    rb_define_singleton_method(rb_mGC, "disable", rb_gc_disable, 0);
    rb_define_method(rb_mGC, "garbage_collect", rb_gc_start, 0);

    rb_mObSpace = rb_define_module("ObjectSpace");
    rb_define_module_function(rb_mObSpace, "each_object", os_each_obj, -1);
    rb_define_module_function(rb_mObSpace, "garbage_collect", rb_gc_start, 0);
    rb_define_module_function(rb_mObSpace, "add_finalizer", add_final, 1);
    rb_define_module_function(rb_mObSpace, "remove_finalizer", rm_final, 1);
    rb_define_module_function(rb_mObSpace, "finalizers", finals, 0);
    rb_define_module_function(rb_mObSpace, "call_finalizer", call_final, 1);

    rb_define_module_function(rb_mObSpace, "define_finalizer", define_final, -1);
    rb_define_module_function(rb_mObSpace, "undefine_finalizer", undefine_final, 1);

    rb_define_module_function(rb_mObSpace, "_id2ref", id2ref, 1);

    rb_gc_register_address(&rb_mObSpace);
    rb_global_variable(&finalizers);
    rb_gc_unregister_address(&rb_mObSpace);
    finalizers = rb_ary_new();

    source_filenames = st_init_strtable();

    nomem_error = rb_exc_new2(rb_eNoMemError, "failed to allocate memory");
    rb_global_variable(&nomem_error);
}
@


1.111
log
@* eval.c, gc.c: adopt a common set of alloca() #ifdef's.  This
  fixes the build with Intel C Compiler for Linux.

* eval.c (rb_f_require): declare old_func with a real type, not
  just type modifiers.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/10/17 07:26:59 $
d859 1
a859 1
	rb_bug("rb_gc_mark(): unknown data type 0x%x(0x%x) %s",
d1146 1
a1146 1
	rb_bug("gc_sweep(): unknown data type 0x%x(%d)", obj,
d1571 1
a1571 1
	rb_raise(rb_eRangeError, "0x%x is not id value", p0);
d1574 1
a1574 1
	rb_raise(rb_eRangeError, "0x%x is recycled object", p0);
@


1.110
log
@* object.c (rb_str_to_dbl): RString ptr might be NULL.

* object.c (rb_cstr_to_dbl): p pointer might be NULL.

* bignum.c (rb_str_to_inum): RString ptr might be NULL.

* bignum.c (rb_cstr_to_inum): str pointer might be NULL.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/10/10 17:11:18 $
d41 8
a48 2
#ifndef __GNUC__
# if HAVE_ALLOCA_H
d52 1
a52 1
#   pragma alloca
d57 3
a59 3
#  endif
# endif
#endif
@


1.109
log
@rename malloc_memories to malloc_increase. [ruby-cvs:05237]
@
text
@d6 1
a6 1
  $Date: 2002/10/10 15:48:06 $
d994 1
a994 1
    for (i = j = 0; j < heaps_used; i++) {
@


1.108
log
@use BUITIN_TYPE() rather than TYPE().
@
text
@d6 1
a6 1
  $Date: 2002/10/10 15:26:58 $
d63 1
a63 1
static unsigned long malloc_memories = 0;
d91 1
a91 1
    malloc_memories += size;
d93 1
a93 1
    if (malloc_memories > malloc_limit) {
d132 1
a132 1
    malloc_memories += size;
d969 1
a969 1
    malloc_memories = 0;
@


1.107
log
@* gc.c (ruby_xmalloc, ruby_xrealloc): restrict total allocation
  size according to memories consumed by live objects.
  [ruby-dev:18482]

* gc.c (gc_sweep): estimate how live objects consume memories.
@
text
@d6 1
a6 1
  $Date: 2002/10/09 06:12:54 $
d927 1
a927 1
		switch (TYPE(p)) {
@


1.106
log
@* gc.c (gc_sweep): also adjust heaps_limits when free unused heap
  page.  [ruby-core:00526]

* io.c (io_fflush): condition to retry can occur.

* io.c (io_write): returned 0 wrongly if no error occurred.
@
text
@d6 1
a6 1
  $Date: 2002/10/03 11:23:34 $
d55 10
d91 1
d93 3
d132 1
d861 9
d876 1
d926 26
d968 2
@


1.105
log
@* gc.c (Init_stack): prefer address of argument rather than local
  variable to initialize rb_gc_stack_start.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/10/02 06:02:14 $
d949 1
@


1.104
log
@* commit miss;  and tcltklib fix too.
@
text
@d6 1
a6 1
  $Date: 2002/09/06 08:59:38 $
d1228 1
a1228 3
    VALUE start;

    if (!addr) addr = &start;
@


1.103
log
@* gc.c (ruby_xmalloc): remove MALLOC_LIMIT to avoid frequent
  garabage collection.
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/09/05 20:00:52 $
d851 1
a851 1
    int i, used = heaps_used;
d856 1
a856 1
	for (i = 0; i < used; i++) {
d872 1
a872 1
    for (i = 0; i < used; i++) {
d874 2
d904 12
a915 1
	freed += n;
d934 17
a950 3
	    p->as.free.flags = 0;
	    p->as.free.next = freelist;
	    freelist = p;
@


1.102
log
@* gc.c (gc_sweep): should mark parser.
* parse.y (rb_gc_mark_parser): new function.
* intern.h (rb_gc_mark_parser): added.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/09/04 09:23:51 $
a55 10

#ifndef GC_MALLOC_LIMIT
#if defined(MSDOS) || defined(__human68k__)
#define GC_MALLOC_LIMIT 200000
#else
#define GC_MALLOC_LIMIT 8000000
#endif
#endif

static unsigned long malloc_memories = 0;
a80 1
    malloc_memories += size;
a81 3
    if (malloc_memories > GC_MALLOC_LIMIT) {
	rb_gc();
    }
a117 1
    malloc_memories += size;
d1119 1
a1119 2
	if (!freelist || malloc_memories > GC_MALLOC_LIMIT) {
	    malloc_memories = 0;
a1123 2

    malloc_memories = 0;
@


1.101
log
@Opt for Array in rb_gc_mark_children() (ruby-core:410)
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/09/02 12:19:30 $
d1189 2
@


1.100
log
@* gc.c (gc_sweep): does reclaim nodes in also compile time, if we can.
* ruby.c (load_file): omit GC if we can.
* parse.y (ruby_parser_stack_on_heap): new function.
* intern.h (ruby_parser_stack_on_heap): added.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/29 09:08:16 $
d779 4
a782 1
	{
d786 1
a786 1
	    for (i=0; i < len; i++)
d788 1
a789 2
	if (FL_TEST(obj, ELTS_SHARED))
	    rb_gc_mark(obj->as.array.aux.shared);
@


1.99
log
@* array.c (rb_ary_become): should not free ptr if it's shared.

* eval.c (rb_alias): prohibit making an alias named "allocate" if
  klass is a metaclass.

* string.c (rb_string_value_ptr): StringValuePtr() should never
  return NULL pointer.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/28 08:05:23 $
d866 3
a868 2
    if (ruby_in_compile) {
	/* should not reclaim nodes during compilation */
@


1.98
log
@Int vs Long cleanup #3 (ruby-core:352)
@
text
@d6 1
a6 1
  $Date: 2002/08/21 15:47:54 $
d1359 1
a1359 1
    rb_warn("ObjectSpace::call_final is deprecated; use define_finalizer");
@


1.97
log
@*.c: Int vs Long cleanup
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/12 07:39:08 $
d780 1
a780 1
	    int i, len = obj->as.array.len;
d842 1
a842 1
	    int i, len = obj->as.rstruct.len;
@


1.96
log
@* bignum.c (rb_big_cmp): use dbl2big() for Floats, instead of
  big2dbl().

* bignum.c (Init_Bignum): rb_big_zero_p() removed.  There may be
  Bignum zero.

* eval.c (rb_call0): new argument added for original method name.
  preserve original method name in frame->orig_func.

* eval.c (is_defined): use frame->orig_func, not last_func.

* eval.c (rb_eval): ditto.

* eval.c (method_call): supply data->oid also to rb_call0().

* object.c (rb_class_allocate_instance): call rb_obj_alloc() when
  called from alias, thus invoke original "allocate".

* eval.c (remove_method): removing allocate from classes should
  cause NameError.

* hash.c (rb_hash_equal): should check default values.

* ext/socket/socket.c (s_recvfrom): update RSTRING len.
@
text
@d6 1
a6 1
  $Date: 2002/07/26 06:12:38 $
d1418 2
a1419 1
    int i, status;
@


1.95
log
@* random.c: replace with Mersenne Twister RNG.

* eval.c (jump_tag_but_local_jump): preserve retval in
  LocalJumpError exceptions.

* parse.y (command): no more check for "super outside of method".

* eval.c (rb_mod_define_method): should set last_class and
  last_func in the block->frame.

* eval.c (error_handle): should handle TAG_THROW as well.

* parse.y (yylex): new decimal notation '0d4567'.

* parse.y (yylex): new octal notation '0o777'.

* parse.y (string_content): every string_content node should
  return string only.  use NODE_EVSTR to coercing.

* eval.c (rb_eval): NODE_EVSTR support.

* re.c (rb_reg_quote): avoid unnecessary string allocation.

* string.c (get_pat): quote metachracters before compiling a
  string into a regex.

* string.c (rb_str_split_m): special treatment of strings of size
  1, but AWK emulation.  now uses get_pat().

* string.c (rb_str_match_m): quote metacharacters.

* string.c (rb_str_match2): ditto.

* ext/socket/socket.c (sock_addrinfo): make all 3 versions of
  getaddrinfo happy.  [ruby-core:00184]
@
text
@d6 1
a6 1
  $Date: 2002/05/14 06:22:26 $
d36 1
a36 2
#ifndef setjmp
#ifdef HAVE__SETJMP
a37 2
#define longjmp(env,val) _longjmp(env,val)
#endif
@


1.94
log
@* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* numeric.c (flo_to_s): default format precision to be "%.16g".

* util.c (ruby_strtod): use own strtod(3) implementation to avoid
  locale hell.  Due to this change "0xff".to_f no longer returns 255.0

* eval.c (avalue_to_yvalue): new function to distinguish yvalue
  (no-arg == Qundef) from svalue (no-arg == Qnil).

* eval.c (rb_yield_0): use avalue_to_yvalue().

* eval.c (assign): warn if val == Qundef where it means rhs is
  void (e.g. yield without value or call without argument).

* parse.y (value_expr): need not to warn for WHILE and UNTIL,
  since they can have return value (via valued break).
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/05/14 05:59:34 $
a653 1
	  case NODE_EVSTR:
d699 1
@


1.93
log
@* gc.c (is_pointer_to_heap): avoid GCC 3.1 warnings.
* missing/strftime.c (timezone): it should take no argument on Cygwin.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/04/25 13:55:58 $
d1131 1
a1131 12
#ifdef C_ALLOCA
    VALUE stack_end;
    alloca(0);
# define STACK_END (&stack_end)
#else
# if defined(__GNUC__) && defined(USE_BUILTIN_FRAME_ADDRESS)
    VALUE *stack_end = __builtin_frame_address(0);
# else
    VALUE *stack_end = alloca(1);
# endif
# define STACK_END (stack_end)
#endif
@


1.92
log
@* various files: macro fix-up by Michal Rokos.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/04/24 05:07:07 $
d524 1
a524 1
	if (is_pointer_to_heap(*x)) {
d586 1
a586 1
    if (is_pointer_to_heap(obj)) {
d1511 1
a1511 1
    if (!is_pointer_to_heap(ptr)) {
@


1.91
log
@* gc.c (init_GC): typo fix(rb_exc_new -> rb_exc_new2).
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/04/24 04:54:13 $
d368 1
a368 1
#  define  SET_STACK_END    VALUE *stack_end = __builtin_frame_address(0);
d370 1
a370 1
#  define  SET_STACK_END    VALUE *stack_end = alloca(1);
d384 1
a384 1
} while (0)\
@


1.90
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/07 11:19:37 $
d1551 1
a1551 1
    nomem_error = rb_exc_new(rb_eNoMemError, "failed to allocate memory");
@


1.89
log
@* gc.c (rb_source_filename): added. holds unique strings for file
  names with GC space.

* gc.c (rb_gc_mark): mark source file name.

* gc.c (gc_sweep): ditto.

* gc.c (Init_GC): initialize source file name table.

* intern.h (rb_source_filename): added.

* eval.c (rb_eval_string): use rb_source_filename().

* parse.y (yycompile): ditto.

* ruby.c (proc_options): ditto.

* ruby.c (load_file): ditto.

* ruby.c (ruby_script): ditto.

* ruby.c (ruby_prog_init): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/15 04:43:05 $
d69 1
d71 2
a72 3
static void
mem_error(mesg)
    char *mesg;
d76 3
a78 2
    if (rb_safe_level() >= 4) {
	rb_raise(rb_eNoMemError, mesg);
d80 2
a81 6
    if (recurse == 0) {
	recurse++;
	rb_fatal(mesg);
    }
    fprintf(stderr, "[FATAL] failed to allocate memory\n");
    exit(1);
d104 1
a104 4
	    if (size >= 10 * 1024 * 1024) {
		mem_error("tried to allocate too big memory");
	    }
	    mem_error("failed to allocate memory");
d141 1
a141 4
	    if (size >= 10 * 1024 * 1024) {
		rb_raise(rb_eNoMemError, "tried to re-allocate too big memory");
	    }
	    mem_error("failed to allocate memory(realloc)");
d281 1
a281 1
	if (heaps == 0) mem_error("heaps: can't alloc memory");
d285 1
a285 1
	if (heaps_limits == 0) mem_error("heaps_limits: can't alloc memory");
d293 1
a293 1
		mem_error("add_heap: can't alloc memory");
a389 2
    int ret;

d1550 3
@


1.88
log
@* bignum.c (rb_big_rshift): should properly convert the nagative
  value to 2's compliment.
@
text
@d6 1
a6 1
  $Date: 2002/02/13 09:01:09 $
d431 42
d649 1
d892 3
d1559 2
@


1.87
log
@* parse.y (stmt): local variable declaration order was changed
  since 1.6

* parse.y (arg): ditto.

* pack.c (pack_pack): add templates 'q' and 'Q'.

* pack.c (pack_unpack): ditto.

* bignum.c (rb_quad_pack): new utility function.

* bignum.c (rb_quad_unpack): ditto.

* parse.y (assignable): should emit CVASGN within the method
  body.

* dir.c (dir_s_glob): should not warn even if no match found.

* eval.c (rb_eval): clean up class variable behavior.

* eval.c (assign): ditto.

* eval.c (is_defined): ditto.

* variable.c (rb_mod_class_variables): need not to call rb_cvar_singleton().

* variable.c (rb_cvar_singleton): removed.
@
text
@d6 1
a6 1
  $Date: 2002/01/23 07:30:39 $
a260 1
    int type;
@


1.86
log
@* array.c (Init_Array): remove Array#filter.

* object.c (rb_mod_initialize): should accept zero argument.

* object.c (rb_mod_cmp): should raise ArgumentError if
  inheritance/inclusion relation between two classes/modules is
  not defined. [new]

* io.c (rb_io_fsync): new method. [new]
@
text
@d6 1
a6 1
  $Date: 2002/01/19 14:21:44 $
a702 1
	  case NODE_CVAR2:
@


1.85
log
@* eval.c (rb_eval): need not to clar method cache for NODE_CLASS,
  NODE_SCLASS.

* gc.c (obj_free): need not to clear method cache on class/module
  finalization.
@
text
@d6 1
a6 1
  $Date: 2002/01/11 09:18:49 $
d826 1
a826 1
	       is_pointer_to_heap(obj)?"corrupted object":"non object");
@


1.84
log
@* re.c (match_select): should propagate taintness.

* hash.c (rb_hash_set_default): Hash#default= should return the
  new value.

* string.c (rb_str_to_i): accepts optional base argument. [new]

* numeric.c (rb_fix2str): should not handle negative fixnum values
  int32 via calling sprintf() directly.
@
text
@d6 1
a6 1
  $Date: 2002/01/04 14:14:34 $
a943 1
	rb_clear_cache();
@


1.83
log
@* process.c (rb_f_system): abandon vfork.

* io.c (pipe_open): ditto.

* defines.h: sparc linux needs different FLUSH_REGISTER_WINDOWS

* regex.c (re_search): abandon stclass optimization.

* bignum.c (rb_cstr2inum): deny "0_".

* bignum.c (rb_cstr2inum): allow "0\n" and so on.

* error.c (rb_invalid_str): utility function to show inspect()'ed
  string.

* bignum.c (rb_cstr2inum): prints invalid strings in inspect()'ed
  format.

* object.c (rb_Float): ditto.

* object.c (rb_convert_type): no longer use rb_rescue().

* re.c (rb_reg_search): initialize taint status of match object.
@
text
@d6 1
a6 1
  $Date: 2001/12/11 03:48:08 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
@


1.82
log
@* string.c (rb_str_match_m): should convert an argument into
  regexp if it's a string.

* array.c (rb_ary_select): Array#select(n,m,...) now works like
  Array#indexes(n,m,..). [new, experimental]

* hash.c (rb_hash_select): ditto.

* hash.c (env_select): ditto.

* re.c (match_select): ditto.

* struct.c (rb_struct_select): ditto.

* gc.c (STR_ASSOC): use FL_USER3 instead of FL_USER2.

* parse.y (str_extend): make up pushback call.
@
text
@d6 1
a6 1
  $Date: 2001/12/10 07:18:12 $
d108 1
a108 1
		rb_raise(rb_eNoMemError, "tried to allocate too big memory");
@


1.81
log
@* array.c (rb_ary_modify): should copy the internal buffer if the
  modifying buffer is shared.

* array.c (ary_make_shared): make an internal buffer of an array
  to be shared.

* array.c (rb_ary_shift): avoid sliding an internal buffer by
  using shared buffer.

* array.c (rb_ary_subseq): avoid copying the buffer.

* parse.y (gettable): should freeze __LINE__ string.

* io.c (rb_io_puts): old behavoir restored.  rationale: a) if you
  want to call to_s for arrays, you can just call print a, "\n".
  b) to_s wastes memory if array (and sum of its contents) is
  huge.  c) now any object that has to_ary is treated as an array,
  using rb_check_convert_type().

* hash.c (rb_hash_initialize): now accepts a block to calculate
  the default value. [new]

* hash.c (rb_hash_aref): call "default" method to get the value
  corrensponding to the non existing key.

* hash.c (rb_hash_default): get the default value based on the
  block given to 'new'.  Now it takes an optinal "key" argument.
  "default" became the method to get the value for non existing
  key.  Users may override "default" method to change the hash
  behavior.

* hash.c (rb_hash_set_default): clear the flag if a block is given
  to 'new'

* object.c (Init_Object): undef Data.allocate, left Data.new.

* ext/curses/curses.c (window_scrollok): use RTEST().

* ext/curses/curses.c (window_idlok): ditto.

* ext/curses/curses.c (window_keypad): ditto.

* ext/curses/curses.c (window_idlok): idlok() may return void on
  some platforms; so don't use return value.

* ext/curses/curses.c (window_scrollok): ditto for consistency.

* ext/curses/curses.c: replace FIX2INT() by typechecking NUM2INT().

* parse.y (str_extend): should not process immature #$x and
  #@@x interpolation, e.g #@@#@@ etc.

* enum.c (enum_sort_by): sort_by does not have to be stable always.

* enum.c (enum_sort_by): call qsort directly to gain performance.

* util.c (ruby_qsort): ruby_qsort(qs6) is now native thread safe.

* error.c (rb_sys_fail): it must be a bug if it's called when
  errno == 0.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@d6 1
a6 1
  $Date: 2001/11/27 10:00:30 $
d769 1
a769 1
#define STR_ASSOC FL_USER2   /* copied from string.c */
@


1.80
log
@* marshal.c (w_float): must distinguish -0.0 from 0.0.

* gc.c (gc_mark_all): tweak mark order for little bit better scan.

* gc.c (rb_gc_mark): ditto.

* gc.c (rb_gc): ditto.

* enum.c (sort_by_i): slight performance boost.

* gc.c (gc_mark_rest): should call gc_mark_children(), not gc_mark().

* gc.c (rb_gc_mark): may cause infinite looop.
@
text
@d6 1
a6 1
  $Date: 2001/11/21 15:41:26 $
d759 2
d769 3
a771 2
	if (obj->as.string.orig) {
	    rb_gc_mark((VALUE)obj->as.string.orig);
d951 1
a951 2
#define STR_NO_ORIG FL_USER2   /* copied from string.c */
	if (!RANY(obj)->as.string.orig || FL_TEST(obj, STR_NO_ORIG)) {
d956 1
a956 1
	if (RANY(obj)->as.array.ptr) {
@


1.79
log
@* parse.y (str_extend): should check nesting parentheses in #{}.

* process.c (pst_wstopsig): returns nil unless WIFSTOPPED() is
  non-zero.

* process.c (pst_wtermsig): returns nil unless WIFSIGNALED() is
  non-zero.

* process.c (pst_wexitstatus): returns nil unless WIFEXITED() is
  non-zero.

* eval.c (rb_thread_select): tv_sec and tv_usec should not be
  negative.

* signal.c (posix_signal): do not set SA_RESTART for SIGVTALRM.

* parse.y (call_args2): block_arg may follow the first argument in
  call_args2.

* eval.c (stack_check): should avoid stack length check during
  raising SystemStackError exception.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 14:42:44 $
d430 1
a430 1
static int mark_all;
a431 1
static void rb_gc_mark_children(VALUE ptr);
d437 8
a444 11
    mark_all = 0;
    while(!mark_all){
	mark_all = 1;
	for (i = 0; i < heaps_used; i++) {
	    p = heaps[i]; pend = p + heaps_limits[i];
	    while (p < pend) {
		if ((p->as.basic.flags & FL_MARK) &&
		    (p->as.basic.flags != FL_MARK)) {
		    rb_gc_mark_children((VALUE)p);
		}
		p++;
d446 1
d464 1
a464 1
	rb_gc_mark(*p);
d565 1
d572 5
a576 4
    if (!mark_stack_overflow){
	int ret;
	CHECK_STACK(ret);
	if (ret) {
d579 3
a581 3
		mark_stack_ptr++;
		return;
	    }else{
d586 1
a586 7

    obj->as.basic.flags |= FL_MARK;

    if (mark_stack_overflow){
	mark_all &= 0;
	return;
    }else{
d1171 2
a1172 2
	    break;
	}else{
@


1.78
log
@* eval.c (rb_mod_modfunc): should follow NODE_ZSUPER link; based
  on Guy Decoux's patch in [ruby-talk:25478].

* string.c (rb_str_succ): there was buffer overrun.

* parse.y (str_extend): term can be any character.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 05:03:03 $
d407 1
a407 3
static VALUE rb_eSysStackError;

void
d413 1
a413 3
    if (ret) {
	rb_raise(rb_eSysStackError, "stack level too deep");
    }
a1520 2

    rb_eSysStackError = rb_define_class("SystemStackError", rb_eStandardError);
@


1.77
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* massages: replace "wrong #" by "wrong number".

* marshal.c (w_float): output Infinity and NaN explicitly.

* marshal.c (r_object): support new explicit float format.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.

* array.c (rb_ary_join): dumped core if sep is not T_STRING nor T_NIL.

* array.c (rb_ary_join): buffer size calculattion was wrong.

* array.c (rb_ary_to_s): if rb_output_fs is nil, insert newlines
  between array elements (use rb_default_rs as newline litral)
  [experimental].

* gc.c (init_mark_stack): no need to clear mark_stack.

* gc.c (gc_mark_all): need to handle finalizer mark.

* gc.c (gc_mark_rest): use MEMCPY instead of memcpy.

* gc.c (rb_gc_mark): earlier const check to avoid pusing special
  constants into mark stack.

* numeric.c (fix_to_s): 'to_s' now takes optional argument to
  specify radix. [new]

* bignum.c (rb_big_to_s): ditto. [new]
@
text
@d6 1
a6 1
  $Date: 2001/11/13 08:19:51 $
d23 5
@


1.76
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* eval.c (rb_eval_cmd): should not upgrade safe level unless
  explicitly specified by argument newly added.

* signal.c (sig_trap): should not allow tainted trap closure.

* variable.c (rb_f_trace_var): should not allow trace_var on safe
  level higher than 3.

* variable.c (rb_f_trace_var): should not allow tainted trace
  closure.

* gc.c: do not use static stack until system stack overflows.

* eval.c (eval): should call Exception#exception instead of
  calling rb_exc_new3() directly.

* error.c (exc_exception): set "mesg" directly to the clone.  it
  might be better to set mesg via some method for flexibility.

* variable.c (cvar_override_check): should print original module
  name, if 'a' is T_ICLASS.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2001/07/20 15:19:28 $
d24 4
d352 62
a424 1
    memset(mark_stack, 0, MARK_STACK_MAX);
d443 2
a444 2
		if (!(rb_special_const_p((VALUE)p))
		    && p->as.basic.flags&FL_MARK) {
d460 2
a461 2
    memcpy(tmp_arry, mark_stack, MARK_STACK_MAX);
	
a469 33
#if defined(DJGPP)
# define STACK_LEVEL_MAX 65535;
#elif defined(__human68k__)
extern unsigned int _stacksize;
# define STACK_LEVEL_MAX (_stacksize - 4096)
#else
# define STACK_LEVEL_MAX 655300
#endif

#ifdef C_ALLOCA
# define SET_STACK_END VALUE stack_end; alloca(0);
# define STACK_END (&stack_end)
#else
# if defined(__GNUC__) && defined(USE_BUILTIN_FRAME_ADDRESS)
#  define  SET_STACK_END    VALUE *stack_end = __builtin_frame_address(0);
# else
#  define  SET_STACK_END    VALUE *stack_end = alloca(1);
# endif
# define STACK_END (stack_end)
#endif
#ifdef __sparc__
# define STACK_LENGTH  (rb_gc_stack_start - STACK_END + 0x80)
#else
# define STACK_LENGTH  ((STACK_END < rb_gc_stack_start) ? rb_gc_stack_start - STACK_END\
                                           : STACK_END - rb_gc_stack_start)
#endif

#define CHECK_STACK(ret) do {\
    SET_STACK_END;\
    ret = (STACK_LENGTH > STACK_LEVEL_MAX);\
} while (0)\


d569 4
a582 1
		printf("mark_stack_overflow\n");
a586 4
    if (rb_special_const_p((VALUE)obj)) return; /* special const not marked */
    if (obj->as.basic.flags == 0) return;       /* free cell */
    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */ 
    
d1205 12
d1520 2
@


1.75
log
@gc patch
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/11/01 04:51:22 $
d348 90
a457 67
#define MARK_STACK_SIZE 4096
static VALUE mark_stack_base[MARK_STACK_SIZE];
static VALUE *mark_stack;
static int mark_stack_overflow = 0;

#define PUSH_MARK(obj) do {\
    if (mark_stack_overflow) {\
        FL_SET((obj),FL_MARK);\
    }\
    else {\
	if (mark_stack - mark_stack_base >= MARK_STACK_SIZE) {\
	    mark_stack_overflow = 1;\
	}\
	else {\
	    if (   rb_special_const_p(obj) /* special const not marked */\
		|| FL_TEST((obj),FL_MARK)) /* already marked */ {\
	    }\
	    else {\
		*mark_stack++ = (obj);\
	    }\
	}\
    }\
} while (0)

#define POP_MARK() (*--mark_stack)

#define MARK_EMPTY() (mark_stack == mark_stack_base)

#ifdef NO_REGION

#define PUSH_MARK_REGION(a,b) do {\
	VALUE *tmp_beg_ptr = (a);\
	while (tmp_beg_ptr < (b)) {\
	    PUSH_MARK(*tmp_beg_ptr);\
            tmp_beg_ptr++;\
	}\
} while (0)

#else

#define MARK_REGION_STACK_SIZE 1024
static VALUE *mark_region_stack_base[MARK_REGION_STACK_SIZE];
static VALUE **mark_region_stack;

#define PUSH_MARK_REGION(a,b) do {\
    if (mark_region_stack - mark_region_stack_base >= MARK_REGION_STACK_SIZE || (b) - (a) < 3) {\
	VALUE *tmp_beg_ptr = (a);\
	while (tmp_beg_ptr < (b)) {\
	    PUSH_MARK(*tmp_beg_ptr);\
            tmp_beg_ptr++;\
	}\
    }\
    else {\
	*mark_region_stack++ = (a);\
	*mark_region_stack++ = (b);\
    }\
} while (0)

#define POP_MARK_REGION(a,b) do {\
    (b) = (*--mark_region_stack);\
    (a) = (*--mark_region_stack);\
} while (0)

#define MARK_REGION_EMPTY() (mark_region_stack == mark_region_stack_base)

#endif

a504 17
push_entry(key, value)
    ID key;
    VALUE value;
{
    PUSH_MARK(value);
    return ST_CONTINUE;
}

static void
push_mark_tbl(tbl)
    st_table *tbl;
{
    if (!tbl) return;
    st_foreach(tbl, push_entry, 0);
}

static int
a521 18
static int
push_hashentry(key, value)
    VALUE key;
    VALUE value;
{
    PUSH_MARK(key);
    PUSH_MARK(value);
    return ST_CONTINUE;
}

static void
push_mark_hash(tbl)
    st_table *tbl;
{
    if (!tbl) return;
    st_foreach(tbl, push_hashentry, 0);
}

d531 2
a532 2
static void
gc_mark_children(ptr)
d537 19
a555 1
  Top:
d557 15
d592 1
a592 1
	    PUSH_MARK((VALUE)obj->as.node.u2.node);
d606 1
a606 1
	    PUSH_MARK((VALUE)obj->as.node.u1.node);
d612 2
a613 2
	    obj = RANY(obj->as.node.u3.node);
	    goto Again;
d629 1
a629 1
	    PUSH_MARK((VALUE)obj->as.node.u1.node);
d644 2
a645 2
	    obj = RANY(obj->as.node.u2.node);
	    goto Again;
d659 2
a660 2
	    obj = RANY(obj->as.node.u1.node);
	    goto Again;
d665 3
a667 3
	    PUSH_MARK((VALUE)obj->as.node.u3.node);
	    obj = RANY(obj->as.node.u2.node);
	    goto Again;
d698 2
a699 2
	    obj = RANY(obj->as.node.u2.node);
	    goto Again;
d704 1
a704 1
		PUSH_MARK((VALUE)obj->as.node.u1.node);
d707 1
a707 1
		PUSH_MARK((VALUE)obj->as.node.u2.node);
d710 1
a710 2
		obj = RANY(obj->as.node.u3.node);
		goto Again;
d716 1
a716 1
    PUSH_MARK(obj->as.basic.klass);
d721 3
a723 3
	PUSH_MARK(obj->as.klass.super);
	push_mark_tbl(obj->as.klass.m_tbl);
	push_mark_tbl(obj->as.klass.iv_tbl);
d727 8
a734 7
      {
	  int i, len = obj->as.array.len;
	  VALUE *ptr = obj->as.array.ptr;

	  PUSH_MARK_REGION(ptr,ptr+len);
      }
      break;
d737 3
a739 3
	push_mark_hash(obj->as.hash.tbl);
	obj = RANY(obj->as.hash.ifnone);
	goto Again;
d742 3
a744 2
	obj = RANY(obj->as.string.orig);
	goto Again;
d752 1
a752 1
	push_mark_tbl(obj->as.object.iv_tbl);
d764 1
a764 2
	    obj = RANY(obj->as.match.str);
	    goto Again;
d769 3
a771 3
	PUSH_MARK(obj->as.varmap.val);
	obj = RANY(obj->as.varmap.next);
	goto Again;
d778 4
a781 2

	    PUSH_MARK_REGION(vars,vars+n);
d786 8
a793 7
      {
	  int i, len = obj->as.rstruct.len;
	  VALUE *ptr = obj->as.rstruct.ptr;

	  PUSH_MARK_REGION(ptr,ptr+len);
      }
      break;
a799 39
    return;

  Again:    
    if (rb_special_const_p(obj)) return; /* special const not marked */
    if (RBASIC(obj)->flags == 0) return; /* free cell */
    if (FL_TEST((obj),FL_MARK)) return;  /* already marked */
    goto Top;
}

void
rb_gc_mark(ptr)
    VALUE ptr;
{
    if (rb_special_const_p(ptr)) return; /* special const not marked */
    if (RBASIC(ptr)->flags == 0) return; /* free cell */
    if (RBASIC(ptr)->flags & FL_MARK) return; /* already marked */
    gc_mark_children(ptr);
}

static void
gc_mark()
{
    while (!MARK_EMPTY()) {
	rb_gc_mark(POP_MARK());
#ifndef NO_REGION
	while (!MARK_REGION_EMPTY()) {
	    VALUE *p, *pend;

	    POP_MARK_REGION(p, pend);
	    while (p < pend) {
		rb_gc_mark(*p);
		p++;
	    }
	    while (!MARK_EMPTY()) {
		rb_gc_mark(POP_MARK());
	    }
	}
#endif
    }
d809 1
a809 1
    int i;
a811 2
	int marked = 0;

d813 1
a813 1
	for (i = 0; i < heaps_used; i++) {
d816 1
a816 1
		if (!(p->as.basic.flags&FL_MARK) && BUILTIN_TYPE(p) == T_NODE) {
a817 2
		    marked = 1;
		}
a820 3
	if (marked) {
	    gc_mark();
	}
d826 1
a826 1
    for (i = 0; i < heaps_used; i++) {
a885 1
    RANY(p)->type = BUILTIN_TYPE(p);
d1098 2
a1099 5
    mark_stack_overflow = 0;
    mark_stack = mark_stack_base;
#ifndef NO_REGION
    mark_region_stack = mark_region_stack_base;
#endif
d1141 8
a1148 15

    gc_mark();
    while (mark_stack_overflow) {
	RVALUE *p, *pend;
	int i;

	mark_stack_overflow = 0;
	for (i = 0; i < heaps_used; i++) {
	    p = heaps[i]; pend = p + heaps_limits[i];
	    while (p < pend) {
		if (p->as.basic.flags&FL_MARK) {
		    gc_mark_children((VALUE)p);
		}
		p++;
	    }
a1149 1
	gc_mark();
a1150 1

d1353 1
a1353 1
    rb_eval_cmd(args[0], args[1]);
@


1.74
log
@* gc.c (gc_mark_children): should NOT treat last element of
  structs and arrays specially.
@
text
@d6 1
a6 1
  $Date: 2001/10/31 06:53:22 $
d305 1
a305 1
    heap_slots *= 1.5;
d374 4
a377 1
    if (!mark_stack_overflow) {\
a379 1
printf("mark stack overflow\n");\
a382 1
		|| RBASIC(obj)->flags == 0 /* free cell */\
d396 39
d482 17
d516 18
d702 2
a703 2
	rb_mark_tbl(obj->as.klass.m_tbl);
	rb_mark_tbl(obj->as.klass.iv_tbl);
d711 1
a711 4
	  for (i=0; i < len; i++) {
	      PUSH_MARK(*ptr);
	      ptr++;
	  }
d716 3
a718 3
	rb_mark_hash(obj->as.hash.tbl);
	PUSH_MARK(obj->as.hash.ifnone);
	break;
d721 2
a722 4
	if (obj->as.string.orig) {
	    obj = RANY(obj->as.string.orig);
	    goto Again;
	}
d730 1
a730 1
	rb_mark_tbl(obj->as.object.iv_tbl);
a750 1
	break;
d757 2
a758 4
	    while (n--) {
		PUSH_MARK(*vars);
		vars++;
	    }
d767 1
a767 4
	  for (i=0; i < len; i++) {
	      PUSH_MARK(*ptr);
	      ptr++;
	  }
d791 1
a791 1
    if (FL_TEST((ptr),FL_MARK)) return;  /* already marked */
d800 14
d1121 1
d1123 3
a1125 1
    mark_stack_overflow = 0;
@


1.73
log
@* eval.c (POP_VARS): should not set DVAR_DONT_RECYCLE if _old
  ruby_vars is already force_recycled.

* gc.c (rb_gc): handles mark stack overflow.

* gc.c (PUSH_MARK): use static mark stack, no more recursion.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2001/07/20 15:19:28 $
d633 1
a633 1
	  int i, len = obj->as.array.len - 1;
a639 4
	  if (len >= 0) {
	      obj = RANY(*ptr);
	      goto Again;
	  }
d697 1
a697 1
	  int i, len = obj->as.rstruct.len - 1;
a702 4
	  }
	  if (len >= 0) {
	      obj = RANY(ptr);
	      goto Again;
@


1.72
log
@* gc.c (ruby_xrealloc): fix a dangling bug which led memory
  reallocation to fail even though the second try after a GC
  succeeds.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/07/02 08:46:21 $
d138 1
a138 1
	    if (size >= 50 * 1024 * 1024) {
d185 1
a185 1
} *Global_List = 0;
d194 1
a194 1
    tmp->next = Global_List;
d196 1
a196 1
    Global_List = tmp;
d203 1
a203 1
    struct gc_list *tmp = Global_List;
d206 1
a206 1
	Global_List = tmp->next;
d252 1
d305 1
a305 1
    heap_slots *= 2;
d368 27
d468 2
a469 2
void
rb_gc_mark(ptr)
a474 4
    if (rb_special_const_p((VALUE)obj)) return; /* special const not marked */
    if (obj->as.basic.flags == 0) return;       /* free cell */
    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */

a475 1

d496 1
a496 1
	    rb_gc_mark((VALUE)obj->as.node.u2.node);
d510 1
a510 1
	    rb_gc_mark((VALUE)obj->as.node.u1.node);
d517 1
a517 1
	    goto Top;
d533 1
a533 1
	    rb_gc_mark((VALUE)obj->as.node.u1.node);
d549 1
a549 1
	    goto Top;
d564 1
a564 1
	    goto Top;
d569 1
a569 1
	    rb_gc_mark((VALUE)obj->as.node.u3.node);
d571 1
a571 1
	    goto Top;
d603 1
a603 1
	    goto Top;
d608 1
a608 1
		rb_gc_mark((VALUE)obj->as.node.u1.node);
d611 1
a611 1
		rb_gc_mark((VALUE)obj->as.node.u2.node);
d615 1
a615 1
		goto Top;
d621 1
a621 1
    rb_gc_mark(obj->as.basic.klass);
d626 1
a626 1
	rb_gc_mark(obj->as.klass.super);
d632 14
a645 8
	{
	    int i, len = obj->as.array.len;
	    VALUE *ptr = obj->as.array.ptr;

	    for (i=0; i < len; i++)
		rb_gc_mark(*ptr++);
	}
	break;
d649 1
a649 1
	rb_gc_mark(obj->as.hash.ifnone);
d655 1
a655 1
	    goto Top;
d677 1
a677 1
	    goto Top;
d682 1
a682 1
	rb_gc_mark(obj->as.varmap.val);
d684 1
a684 1
	goto Top;
d693 1
a693 1
		rb_gc_mark(*vars);
d700 14
a713 8
	{
	    int i, len = obj->as.rstruct.len;
	    VALUE *ptr = obj->as.rstruct.ptr;

	    for (i=0; i < len; i++)
		rb_gc_mark(*ptr++);
	}
	break;
d720 25
d754 1
a754 1
    int i, used = heaps_used;
d757 2
d760 1
a760 1
	for (i = 0; i < used; i++) {
d763 1
a763 1
		if (!(p->as.basic.flags&FL_MARK) && BUILTIN_TYPE(p) == T_NODE)
d765 2
d770 3
d778 1
a778 1
    for (i = 0; i < used; i++) {
d838 1
d968 1
a968 1
	rb_bug("gc_sweep(): unknown data type %d",
d1051 2
d1083 1
a1083 1
    for (list = Global_List; list; list = list->next) {
d1094 18
@


1.71
log
@* error.c (exc_exception): clone the receiver exception instead of
  creating brand new exception object of the receiver.

* eval.c (rb_eval_string_wrap): extend new ruby_top_self, not
  original self.

* eval.c (rb_eval_cmd): respect ruby_wrapper if set.

* eval.c (eval): do not update ruby_class unless scope is not
  provided.

* eval.c (eval): preserve wrapper information.

* eval.c (proc_invoke): ditto.

* eval.c (block_pass): ditto.

* parse.y (void_expr): too much warnings for void context
  (e.g. foo[1] that can be mere Proc call).

* error.c (rb_name_error): new function to raise NameError with
  name attribute set.

* eval.c (rb_f_missing): set name and args in the exception
  object. [new]

* error.c (name_name): NameError#name - new method.

* error.c (nometh_args): NoMethodError#args - new method.

* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.

* dir.c (isdelim): space, tab, and newline are no longer
  delimiters for glob patterns.

* eval.c (svalue_to_avalue): new conversion scheme between single
  value and array values.

* eval.c (avalue_to_svalue): ditto.

* eval.c (rb_eval): REXPAND now uses avalue_to_svalue(), return
  and yield too.

* eval.c (rb_yield_0): use avalue_to_svalue().

* eval.c (proc_invoke): Proc#call gives avaules, whereas
  Proc#yield gives mvalues.

* eval.c (bmcall): convert given value (svalue) to avalue.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/06/19 15:41:18 $
d137 1
a137 1
	if (!mem)
d142 1
@


1.70
log
@* gc.c (rb_setjmp): avoid GCC 3.0 warnings.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/06/12 05:31:46 $
d261 4
a264 1
#define HEAP_SLOTS 10000
d281 4
d287 13
a299 3
    RUBY_CRITICAL(p = heaps[heaps_used++] = (RVALUE*)malloc(sizeof(RVALUE)*HEAP_SLOTS));
    if (p == 0) mem_error("add_heap: can't alloc memory");
    pend = p + HEAP_SLOTS;
d302 2
d359 2
a360 2
	if (heap_org <= p && p < heap_org + HEAP_SLOTS
	    && ((((char*)p)-((char*)heap_org))%sizeof(RVALUE)) == 0)
d534 2
a562 2
	  case NODE_BREAK:
	  case NODE_NEXT:
d698 1
a698 1
	    p = heaps[i]; pend = p + HEAP_SLOTS;
d713 1
a713 1
	p = heaps[i]; pend = p + HEAP_SLOTS;
d1067 1
a1067 1
	p = heaps[i]; pend = p + HEAP_SLOTS;
d1100 1
a1100 1
	p = heaps[i]; pend = p + HEAP_SLOTS;
d1267 1
a1267 1
	    p = heaps[i]; pend = p + HEAP_SLOTS;
d1280 1
a1280 1
	p = heaps[i]; pend = p + HEAP_SLOTS;
@


1.69
log
@* eval.c (method_eq): new method Method#==. [new]

* gc.c (STR_NO_ORIG): STR_NO_ORIG value was different between
  string.c and gc.c

* eval.c (rb_eval): should convert *non-array at the end of
  arguments by using Array().

* hash.c (ruby_setenv): readline library leaves their environment
  strings uncopied.  "free" check revised.
@
text
@d6 1
a6 1
  $Date: 2001/06/08 14:20:19 $
d897 5
a901 5
__asm__ (".even
_rb_setjmp:
	move.l	4(sp),a0
	movem.l	d3-d7/a3-a5,(a0)
	moveq.l	#0,d0
d909 13
a921 13
__asm__ (".align 4
_rb_setjmp:
	pushl	%ebp
	movl	%esp,%ebp
	movl	8(%ebp),%ebp
	movl	%eax,(%ebp)
	movl	%ebx,4(%ebp)
	movl	%ecx,8(%ebp)
	movl	%edx,12(%ebp)
	movl	%esi,16(%ebp)
	movl	%edi,20(%ebp)
	popl	%ebp
	xorl	%eax,%eax
@


1.68
log
@* gc.c (Init_stack): avoid __builtin_frame_address(2) to retrieve
  stack bottom line.

* st.c (numhash): should shuffle bits by dividing by prime number.

* eval.c (rb_eval): multiple assignment behavior fixed, which
  results "*a = nil" makes "a == []" now.

* eval.c (rb_f_require): should set SCOPE_PUBLIC before calling
  dln_load().
@
text
@d6 1
a6 1
  $Date: 2001/05/07 09:26:24 $
d788 1
a788 1
#define STR_NO_ORIG FL_USER0	/* copied from string.c */
@


1.67
log
@* parse.y (arg): "||=" should not warn for uninitialized instance
  variables.

* eval.c (rb_eval): ditto.

* eval.c (eval): preserve and restore ruby_cref as well.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:10 $
a1021 2
#elif defined(__GNUC__) && defined(USE_BUILTIN_FRAME_ADDRESS)
    rb_gc_stack_start = __builtin_frame_address(2);
@


1.66
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d6 1
a6 1
  $Date: 2001/03/26 08:57:10 $
d1223 1
a1223 1
	rb_protect(run_single_final, (VALUE)args, &status);
d1228 1
a1228 1
	    rb_protect(run_single_final, (VALUE)args, &status);
@


1.65
log
@* eval.c: remove TMP_PROTECT_END to prevent C_ALLOCA crash.

* file.c (rb_file_flock): do not trap EINTR.

* missing/flock.c (flock): returns the value from lockf(2)
  directly.

* eval.c (ev_const_defined): should ignore toplevel cbase (Object).

* eval.c (ev_const_get): ditto.

* ext/md5/md5.h: replace by independent md5 implementation
  contributed by L. Peter Deutsch (thanks).

* ext/md5/md5init.c: adopted to Deutsch's md5 implementation.

* pack.c (pack_unpack): string from P/p should be tainted.

* ext/curses/curses.c: curses on Mac OS X public beta does not
  have _maxx etc.

* marshal.c (w_object): should truncate trailing zero short for
  bignums.

* object.c (sym_intern): new method.
@
text
@d6 1
a6 1
  $Date: 2001/03/22 08:59:02 $
d1150 1
a1150 1
    rb_warn("ObjectSpace::finals is deprecated");
d1286 1
a1286 1
    p0 = ptr = NUM2UINT(id);
a1332 34
}

#undef xmalloc
#undef xcalloc
#undef xrealloc
#undef xfree

void*
xmalloc(size)
    long size;
{
    return ruby_xmalloc(size);
}

void*
xcalloc(n,size)
    long n,size;
{
    return ruby_xcalloc(n, size);
}

void*
xrealloc(ptr,size)
    void *ptr;
    long size;
{
    return ruby_xrealloc(ptr, size);
}

void
xfree(ptr)
    void *ptr;
{
    ruby_xfree(ptr);
@


1.64
log
@* ruby.h: better inline function support.

* configure.in (NO_C_INLINE): check if inline is available for the
  C compiler.

* marshal.c (r_object): len calculation patch was wrong for
  machines SIZEOF_BDIGITS == SIZEOF_SHORT.

* gc.c: alloca prototype reorganized for C_ALLOCA machine.
@
text
@d6 1
a6 1
  $Date: 2001/03/21 03:41:41 $
d35 10
a44 4
#ifdef __GNUC__
# ifndef atarist
#  ifndef alloca
#   define alloca __builtin_alloca
a45 6
# endif /* atarist */
#else
# if defined(HAVE_ALLOCA_H)
#  include <alloca.h>
# elif !defined(alloca)
void *alloca();
a46 4
#endif /* __GNUC__ */

#ifdef _AIX
#pragma alloca
d856 1
a856 1
	    RUBY_CRITICAL(free(RANY(obj)->as.node.u1.value));
@


1.63
log
@* gc.c (id2ref): sometimes confused symbol and reference.

* dir.c (glob_helper): breaks loop after calling recusive
  glob_helper; all wild cards should be consumed; no need for
  further match.

* dir.c (dir_s_glob): gives warning if no match found.

* object.c (sym_inspect): did allocate extra byte space.

* marshal.c (shortlen): shortlen should return number of bytes
  written.

* eval.c (ev_const_defined): need not to check if cbase->nd_class
  is rb_cObject.

* eval.c (ev_const_get): ditto.

* time.c (time_zone): return "UTC" for UTC time objects.

* eval.c (THREAD_ALLOC): flags should be initialized.

* signal.c (rb_f_kill): should use FIX2INT, not FIX2UINT.
@
text
@d6 1
a6 1
  $Date: 2001/03/19 03:20:21 $
a50 6
#endif

#ifdef C_ALLOCA
#ifndef alloca
void *alloca();
#endif
@


1.62
log
@* dir.c (glob_helper): replace lstat() by stat() to follow symlink
  in the case like 'symlink/*'.

* dir.c (glob_helper): gave warning too much.
@
text
@d6 1
a6 1
  $Date: 2001/02/28 06:30:03 $
d45 1
a45 1
char *alloca();
a1296 2
    if (FIXNUM_P(ptr)) return (VALUE)ptr;
    if (SYMBOL_P(ptr)) return (VALUE)ptr;
d1300 4
@


1.61
log
@* string.c (rb_str_delete_bang): delete! should take at least 1
  argument.

* ruby.c (load_file): add rb_gc() after loading to avoid
  extraordinary memory growth.

* dir.c (rb_glob_helper): "./foo" should match "foo", not "./foo".

* eval.c (ev_const_get): retrieve Object's constant if no current
  class is available (e.g. defining singleton class for Fixnums).

* eval.c (ev_const_defined): check Object's constant if no current
  class is available (e.g. defining singleton class for Fixnums).

* time.c (time_timeval): negative time interval shoule not be
  allowed.

* eval.c (proc_call): ignore block to `call' always, despite of
  being orphan or not.

* eval.c (rb_yield_0): should check based on rb_block_given_p()
  and rb_f_block_given_p().

* configure.in (frame-address): --enable-frame-address to allow
  __builtin_frame_address() to be used.

* eval.c (stack_length): use __builtin_frame_address() based on
  the macro USE_BUILTIN_FRAME_ADDRESS.

* gc.c (rb_gc): ditto.

* gc.c (Init_stack): ditto.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/02/11 07:12:02 $
d423 1
a423 1
    void *obj;
d432 1
a432 1
    void *ptr;
d463 1
a463 1
	    rb_gc_mark(obj->as.node.u2.node);
d477 1
a477 1
	    rb_gc_mark(obj->as.node.u1.node);
d500 1
a500 1
	    rb_gc_mark(obj->as.node.u1.node);
d534 1
a534 1
	    rb_gc_mark(obj->as.node.u3.node);
d575 1
a575 1
		rb_gc_mark(obj->as.node.u1.node);
d578 1
a578 1
		rb_gc_mark(obj->as.node.u2.node);
d692 1
a692 1
		    rb_gc_mark(p);
d984 3
a986 3
    rb_gc_mark(ruby_class);
    rb_gc_mark(ruby_scope);
    rb_gc_mark(ruby_dyna_vars);
@


1.60
log
@* eval.c (stack_length): use __builtin_frame_address() only if
  GCC and i386 CPU.
* gc.c (rb_gc, Init_stack): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/02/08 09:19:17 $
d952 1
a952 1
# if defined(__GNUC__) && defined(__i386__)
d1032 1
a1032 1
#elif defined(__GNUC__) && defined(__i386__)
@


1.59
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_options): new method to give an option values.

* parse.y (cond0): disable special treating of integer literal in
  conditional unless option -e is supplied.  changes current
  behavior.  experimental.

* parse.y (cond0): give warning for string/integer literals and
  dot operators in conditionals unless option -e is supplied.

* re.c (rb_reg_equal): all option flags should be same to be equal.

* error.c (Init_Exception): make Interrupt a subclass of
  SignalException.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:38:10 $
d34 19
d952 1
a952 1
# if defined(__GNUC__) && !defined(__alpha__) && !defined(__APPLE__)
d1032 1
a1032 1
#elif defined(__GNUC__) && !defined(__alpha__) && !defined(__APPLE__)
@


1.58
log
@* array.c (rb_ary_sort_bang): returns self, even if its length is
  less than 2.

* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2001/01/29 05:10:42 $
a1217 1
	    printf("n finals=>%d\n", finalizer_table->num_entries);
a1245 1
		    printf("%p\n", p);
@


1.57
log
@* string.c (str_independent): should not clear str->orig here.
  it's too early.
@
text
@d6 1
a6 1
  $Date: 2001/01/23 09:55:10 $
d222 1
a222 1
	    unsigned long flag;	/* always 0 for freed obj */
d278 1
a278 1
	p->as.free.flag = 0;
d630 1
a630 1
	if (obj->as.scope.local_vars && (obj->as.scope.flag & SCOPE_MALLOC)) {
d692 1
a692 1
		    p->as.free.flag = FL_MARK; /* remain marked */
d697 1
a697 1
		    p->as.free.flag = 0;
d731 1
a731 1
	    p->as.free.flag = 0;
d742 1
a742 1
    RANY(p)->as.free.flag = 0;
d855 1
a855 1
            RANY(obj)->as.scope.flag != SCOPE_ALLOCA) {
d859 1
a859 1
	    if (RANY(obj)->as.scope.flag&SCOPE_MALLOC)
d1260 1
a1260 1
		p->as.free.flag = 0;
d1264 1
a1264 1
		p->as.free.flag = 0;
@


1.56
log
@* gc.c (rb_gc_call_finalizer_at_exit): should finalize objects in
  deferred_final_list too.
@
text
@d6 1
a6 1
  $Date: 2001/01/23 08:08:59 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
d152 2
a153 2
static VALUE
gc_enable()
d161 2
a162 2
static VALUE
gc_disable()
d999 2
a1000 2
static VALUE
gc_start()
d1302 4
a1305 4
    rb_define_singleton_method(rb_mGC, "start", gc_start, 0);
    rb_define_singleton_method(rb_mGC, "enable", gc_enable, 0);
    rb_define_singleton_method(rb_mGC, "disable", gc_disable, 0);
    rb_define_method(rb_mGC, "garbage_collect", gc_start, 0);
d1309 1
a1309 1
    rb_define_module_function(rb_mObSpace, "garbage_collect", gc_start, 0);
@


1.55
log
@* gc.c (os_live_obj): do not list terminated object.

* gc.c (os_obj_of): ditto.

* gc.c (rb_gc_mark): support new T_BLKTAG tag.

* gc.c (obj_free): ditto.

* eval.c (new_blktag): creation of new block tag, which holds
  destination of global jump and orphan status.

* eval.c (block_pass): break from orphan Proc object will raise a
  LocalJumpError exception.

* eval.c (block_pass): behavior consistency with proc_call(). do
  not propagate `break'.
@
text
@d6 1
a6 1
  $Date: 2001/01/10 10:07:31 $
d720 1
a720 1
    if (need_call_final && final_list) {
d1216 1
a1216 2
    if (finalizer_table && st_lookup(finalizer_table, obj, &table)) {
	st_delete(finalizer_table, &obj, 0);
d1218 1
d1232 19
a1250 7
    for (i = 0; i < heaps_used; i++) {
	p = heaps[i]; pend = p + HEAP_SLOTS;
	while (p < pend) {
	    if (FL_TEST(p, FL_FINALIZE)) {
		FL_UNSET(p, FL_FINALIZE);
		p->as.basic.klass = 0;
		run_final((VALUE)p);
a1251 1
	    p++;
@


1.54
log
@inline fix
@
text
@d6 1
a6 1
  $Date: 2001/01/10 07:52:45 $
d613 1
d830 1
d1053 1
d1086 1
@


1.53
log
@* m17n baseline.
@
text
@d6 1
a6 1
  $Date: 2001/01/09 07:26:16 $
d318 1
a318 1
static INLINE int
@


1.52
log
@* enum.c (enum_inject): new method.

* gc.c (rb_gc_call_finalizer_at_exit): clear klass member of
  terminating object.

* eval.c (rb_call): raise exception for terminated object.

* bignum.c (bigdivrem): t2 might be too big for signed long; do
  not use rb_int2big(), but rb_uint2big().

* error.c (rb_load_fail): new func to report LoadError.

* ruby.c (load_file): use rb_load_fail.

* eval.c (ruby_finalize): should enclosed by PUSH_TAG/POP_TAG.

* gc.c (rb_gc_mark): link 2 of NODE_IFUNC should not be explicitly
  marked.  it may contain non object pointer.

* re.c (reg_s_last_match): Regexp::last_match(nth) returns nth
  substring of the match  (alternative for $& and $<digit>).

* eval.c (rb_mod_define_method): wrong comparison for blocks.

* gc.c (id2ref): should handle Symbol too.

* gc.c (id2ref): should print original ptr value

* eval.c (rb_iterate): NODE_CFUNC does not protect its data
  (nd_tval), so create new node NODE_IFUNC for iteration C
  function.

* eval.c (rb_yield_0): use NODE_IFUNC.

* gc.c (rb_gc_mark): support NODE_IFUNC.

* gc.c (mem_error): prohibit recursive mem_error().
  (ruby-bugs-ja:PR#36)

* eval.c (rb_thread_fd_writable): should not switch context if
  rb_thread_critical is set.

* eval.c (rb_thread_wait_fd): ditto.

* eval.c (rb_thread_wait_for): ditto.

* eval.c (rb_thread_select): ditto.

* eval.c (rb_thread_join): join during critical section causes
  deadlock.
@
text
@d6 1
a6 1
  $Date: 2000/12/29 18:23:22 $
d778 1
a778 1
#define STR_NO_ORIG FL_USER2	/* copied from string.c */
a1154 2
    VALUE table;

@


1.51
log
@* eval.c (rb_iterate): NODE_CFUNC does not protect its data
  (nd_tval), so create new node NODE_IFUNC for iteration C
  function.

* eval.c (rb_yield_0): use NODE_IFUNC.

* gc.c (rb_gc_mark): support NODE_IFUNC.
@
text
@d6 1
a6 1
  $Date: 2000/12/29 02:47:07 $
a482 1
	  case NODE_IFUNC:
d1234 2
a1235 1
		p->as.free.flag = 0;
d1263 1
a1263 1
    unsigned long ptr;
d1266 1
a1266 1
    ptr = NUM2UINT(id);
d1268 1
d1275 1
a1275 1
	rb_raise(rb_eRangeError, "0x%x is not id value", ptr);
d1278 1
a1278 1
	rb_raise(rb_eRangeError, "0x%x is recycled object", ptr);
@


1.50
log
@* gc.c (mem_error): prohibit recursive mem_error().
  (ruby-bugs-ja:PR#36)
@
text
@d6 1
a6 1
  $Date: 2000/12/26 08:08:50 $
d483 1
@


1.49
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/22 03:21:56 $
d56 2
d61 6
a66 1
    rb_fatal(mesg);
@


1.49.2.1
log
@m17n fix
@
text
@d6 1
a6 1
  $Date: 2001/01/10 10:07:31 $
a55 2
    static int recurse = 0;

d59 1
a59 6
    if (recurse == 0) {
	recurse++;
	rb_fatal(mesg);
    }
    fprintf(stderr, "[FATAL] failed to allocate memory\n");
    exit(1);
d311 1
a311 1
static inline int
d771 1
a771 1
#define STR_NO_ORIG FL_USER0	/* copied from string.c */
d1148 2
d1227 1
a1227 2
		FL_UNSET(p, FL_FINALIZE);
		p->as.basic.klass = 0;
d1255 1
a1255 1
    unsigned long ptr, p0;
d1258 1
a1258 1
    p0 = ptr = NUM2UINT(id);
a1259 1
    if (SYMBOL_P(ptr)) return (VALUE)ptr;
d1266 1
a1266 1
	rb_raise(rb_eRangeError, "0x%x is not id value", p0);
d1269 1
a1269 1
	rb_raise(rb_eRangeError, "0x%x is recycled object", p0);
@


1.48
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/08 07:10:18 $
d311 1
a311 4
#if defined(__GNUC__) && __GNUC__ >= 2
__inline__
#endif
static int
@


1.48.2.1
log
@* gc.c (mem_error): prohibit recursive mem_error().
  (ruby-bugs-ja:PR#36)

* eval.c (rb_thread_fd_writable): should not switch context if
  rb_thread_critical is set.

* eval.c (rb_thread_wait_fd): ditto.

* eval.c (rb_thread_wait_for): ditto.

* eval.c (rb_thread_select): ditto.

* eval.c (rb_thread_join): join during critical section causes
  deadlock.
@
text
@d6 1
a6 1
  $Date: 2000/12/22 03:21:56 $
a55 2
    static int recurse = 0;

d59 1
a59 6
    if (recurse == 0) {
	recurse++;
	rb_fatal(mesg);
    }
    fprintf(stderr, "[FATAL] failed to allocate memory\n");
    exit(1);
@


1.48.2.2
log
@* pack.c (pack_pack): template "m2" or "u2" caused inifinite loop.

* eval.c (ruby_finalize): should enclosed by PUSH_TAG/POP_TAG.

* eval.c (rb_mod_define_method): wrong comparison for blocks.

* gc.c (id2ref): should handle Symbol too.

* gc.c (id2ref): should print original ptr value

* eval.c (rb_iterate): NODE_CFUNC does not protect its data
  (nd_tval), so create new node NODE_IFUNC for iteration C
  function.

* eval.c (rb_yield_0): use NODE_IFUNC.

* gc.c (rb_gc_mark): support NODE_IFUNC.
@
text
@d6 1
a6 1
  $Date: 2000/12/29 18:23:22 $
d318 4
a321 1
static INLINE int
a485 1
	  case NODE_IFUNC:
d1265 1
a1265 1
    unsigned long ptr, p0;
d1268 1
a1268 1
    p0 = ptr = NUM2UINT(id);
a1269 1
    if (SYMBOL_P(ptr)) return (VALUE)ptr;
d1276 1
a1276 1
	rb_raise(rb_eRangeError, "0x%x is not id value", p0);
d1279 1
a1279 1
	rb_raise(rb_eRangeError, "0x%x is recycled object", p0);
@


1.48.2.3
log
@NODE_IFUNC bug
@
text
@d6 1
a6 1
  $Date: 2001/01/09 07:26:16 $
d483 1
d1235 1
a1235 2
		FL_UNSET(p, FL_FINALIZE);
		p->as.basic.klass = 0;
@


1.48.2.4
log
@gc.c INLINE bug
@
text
@d6 1
a6 1
  $Date: 2001/01/09 08:17:11 $
d318 1
a318 1
static inline int
@


1.48.2.5
log
@* gc.c: wrap inline by #if.
@
text
@d6 1
a6 1
  $Date: 2001/01/09 08:19:42 $
d318 1
a318 4
#if defined(__GNUC__) && __GNUC__ >= 2
__inline__
#endif
static int
@


1.48.2.6
log
@* gc.c (rb_gc_call_finalizer_at_exit): should finalize objects in
  deferred_final_list too.
@
text
@d6 1
a6 1
  $Date: 2001/01/10 05:05:09 $
d722 1
a722 1
    if (final_list) {
d1217 2
a1218 1
    if (finalizer_table && st_delete(finalizer_table, &obj, &table)) {
a1219 1
	    printf("n finals=>%d\n", finalizer_table->num_entries);
d1233 7
a1239 19
    if (need_call_final) {
	if (deferred_final_list) {
	    p = deferred_final_list;
	    while (p) {
		RVALUE *tmp = p;
		p = p->as.free.next;
		run_final((VALUE)tmp);
	    }
	}
	for (i = 0; i < heaps_used; i++) {
	    p = heaps[i]; pend = p + HEAP_SLOTS;
	    while (p < pend) {
		if (FL_TEST(p, FL_FINALIZE)) {
		    FL_UNSET(p, FL_FINALIZE);
		    p->as.basic.klass = 0;
		    printf("%p\n", p);
		    run_final((VALUE)p);
		}
		p++;
d1241 1
@


1.48.2.7
log
@* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2001/01/23 09:54:35 $
a615 1
      case T_BLKTAG:
a831 1
      case T_BLKTAG:
@


1.48.2.8
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_equal): all option flags should be same to be equal.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:39:51 $
d318 4
a321 1
static inline int
a1055 1
		    if (!p->as.basic.klass) continue;
a1087 1
		    if (!p->as.basic.klass) continue;
d1221 1
d1250 1
@


1.48.2.9
log
@* eval.c (stack_length): use __builtin_frame_address() only if
  GCC and i386 CPU.
* gc.c (rb_gc, Init_stack): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/02/08 09:17:57 $
a33 19
/* Make alloca work the best possible way.  */
#ifdef __GNUC__
# ifndef atarist
#  ifndef alloca
#   define alloca __builtin_alloca
#  endif
# endif /* atarist */
#else
# if defined(HAVE_ALLOCA_H)
#  include <alloca.h>
# elif !defined(alloca)
char *alloca();
# endif
#endif /* __GNUC__ */

#ifdef _AIX
#pragma alloca
#endif

d933 1
a933 1
# if defined(__GNUC__) && defined(__i386__)
d1013 1
a1013 1
#elif defined(__GNUC__) && defined(__i386__)
@


1.48.2.10
log
@fix screw-ups in gc.c and marshal.c.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/02/11 07:11:47 $
d45 1
a45 1
void *alloca();
d1299 2
a1303 4
    if (FIXNUM_P(ptr)) return (VALUE)ptr;
    if (SYMBOL_P(ptr) && rb_id2name(SYM2ID((VALUE)ptr)) != 0) {
	return (VALUE)ptr;
    }
@


1.48.2.11
log
@* ruby.h: better inline function support.

* configure.in (NO_C_INLINE): check if inline is available for the
  C compiler.

* marshal.c (r_object): len calculation patch was wrong for
  machines SIZEOF_BDIGITS == SIZEOF_SHORT.

* gc.c: alloca prototype reorganized for C_ALLOCA machine.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/03/21 09:43:10 $
d51 6
@


1.48.2.12
log
@* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.
@
text
@d6 1
a6 1
  $Date: 2001/03/22 08:59:26 $
d1339 34
@


1.48.2.13
log
@m68m frame_pointer patch
@
text
@d6 1
a6 1
  $Date: 2001/04/10 06:09:00 $
d946 1
a946 1
# if defined(__GNUC__) && (defined(__i386__) || defined(__m68k__))
d1026 1
a1026 1
#elif defined(__GNUC__) && (defined(__i386__) || defined(__m68k__))
@


1.48.2.14
log
@* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.
@
text
@d6 1
a6 1
  $Date: 2001/04/19 09:16:07 $
d1292 1
a1292 1
    p0 = ptr = NUM2ULONG(id);
@


1.48.2.15
log
@* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): inifinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe leve 4.
@
text
@d6 1
a6 1
  $Date: 2001/04/24 06:44:13 $
d1154 1
a1154 1
    rb_warn("ObjectSpace::finalizers is deprecated");
@


1.48.2.16
log
@* hash.c (ruby_setenv): readline library leaves their environment
  strings uncopied.  "free" check revised.

* st.c (numhash): should shuffle bits by dividing by prime number.
@
text
@d6 1
a6 1
  $Date: 2001/05/01 08:45:11 $
d1026 2
@


1.48.2.17
log
@* gc.c (rb_setjmp): avoid GCC 3.0 warnings.
@
text
@d6 1
a6 1
  $Date: 2001/06/11 06:26:17 $
d901 5
a905 5
__asm__ (".even\n\
_rb_setjmp:\n\
	move.l	4(sp),a0\n\
	movem.l	d3-d7/a3-a5,(a0)\n\
	moveq.l	#0,d0\n\
d913 13
a925 13
__asm__ (".align 4\n\
_rb_setjmp:\n\
	pushl	%ebp\n\
	movl	%esp,%ebp\n\
	movl	8(%ebp),%ebp\n\
	movl	%eax,(%ebp)\n\
	movl	%ebx,4(%ebp)\n\
	movl	%ecx,8(%ebp)\n\
	movl	%edx,12(%ebp)\n\
	movl	%esi,16(%ebp)\n\
	movl	%edi,20(%ebp)\n\
	popl	%ebp\n\
	xorl	%eax,%eax\n\
@


1.48.2.18
log
@* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/06/19 15:42:00 $
d265 1
a265 4
#define HEAP_MIN_SLOTS 10000
static int *heaps_limits;
static int heap_slots = HEAP_MIN_SLOTS;

a281 4
	RUBY_CRITICAL(heaps_limits = (heaps_used>0)?
			(int*)realloc(heaps_limits, heaps_length*sizeof(int)):
			(int*)malloc(heaps_length*sizeof(int)));
	if (heaps_limits == 0) mem_error("heaps_limits: can't alloc memory");
d284 3
a286 13
    for (;;) {
	RUBY_CRITICAL(p = heaps[heaps_used] = (RVALUE*)malloc(sizeof(RVALUE)*heap_slots));
	heaps_limits[heaps_used] = heap_slots;
	if (p == 0) {
	    if (heap_slots == HEAP_MIN_SLOTS) {
		mem_error("add_heap: can't alloc memory");
	    }
	    heap_slots = HEAP_MIN_SLOTS;
	    continue;
	}
	break;
    }
    pend = p + heap_slots;
a288 2
    heaps_used++;
    heap_slots *= 2;
d344 2
a345 2
	if (heap_org <= p && p < heap_org + heaps_limits[i] &&
	    ((((char*)p)-((char*)heap_org))%sizeof(RVALUE)) == 0)
a518 2
	  case NODE_BREAK:
	  case NODE_NEXT:
d546 2
d683 1
a683 1
	    p = heaps[i]; pend = p + heaps_limits[i];
d698 1
a698 1
	p = heaps[i]; pend = p + heaps_limits[i];
d1052 1
a1052 1
	p = heaps[i]; pend = p + heaps_limits[i];
d1085 1
a1085 1
	p = heaps[i]; pend = p + heaps_limits[i];
d1254 1
a1254 1
	    p = heaps[i]; pend = p + heaps_limits[i];
d1267 1
a1267 1
	p = heaps[i]; pend = p + heaps_limits[i];
@


1.48.2.19
log
@* gc.c (ruby_xrealloc): fix a dangling bug which led memory
  reallocation to fail even though the second try after a GC
  succeeds.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/06/29 08:32:52 $
d141 1
a141 1
	if (!mem) {
a145 1
	}
@


1.48.2.20
log
@* struct.c (rb_struct_modify): should check frozen and taint
  status.

* eval.c (rb_undefined): do not recurse if method_missing is
  undefined.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2001/07/20 15:20:25 $
d966 1
a966 1
# if defined(__GNUC__) && (defined(__i386__) || defined(__mc68000__))
@


1.48.2.21
log
@* parse.y (assignable): should emit CVASGN within the method
  body.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/08/06 03:10:23 $
d563 1
@


1.48.2.22
log
@* gc.c (rb_source_filename): added. holds unique strings for file
  names with GC space.

* gc.c (rb_gc_mark): mark source file name.

* gc.c (gc_sweep): ditto.

* gc.c (Init_GC): initialize source file name table.

* intern.h (rb_source_filename): added.

* eval.c (rb_eval_string): use rb_source_filename().

* parse.y (yycompile): ditto.

* ruby.c (proc_options): ditto.

* ruby.c (load_file): ditto.

* ruby.c (ruby_script): ditto.

* ruby.c (ruby_prog_init): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/02/13 09:02:15 $
a370 42
static st_table *source_filenames;

char *
rb_source_filename(f)
    const char *f;
{
    char *name;

    if (!st_lookup(source_filenames, f, &name)) {
	long len = strlen(f) + 1;
	char *ptr = name = ALLOC_N(char, len + 1);
	*ptr++ = 0;
	MEMCPY(ptr, f, char, len);
	st_add_direct(source_filenames, ptr, name);
	return ptr;
    }
    return name + 1;
}

static void
mark_source_filename(f)
    char *f;
{
    if (f) {
	f[-1] = 1;
    }
}

static enum st_retval
sweep_source_filename(key, value)
    char *key, *value;
{
    if (*value) {
	*value = 0;
	return ST_CONTINUE;
    }
    else {
	free(value);
	return ST_DELETE;
    }
}

a467 1
	mark_source_filename(obj->as.node.nd_file);
a710 3
    mark_source_filename(ruby_sourcefile);
    st_foreach(source_filenames, sweep_source_filename, 0);

a1355 2

    source_filenames = st_init_strtable();
@


1.48.2.23
log
@* eval.c, gc.c, intern.h, variable.c: declare rb_gc_mark{,maybe}()
  canonically in order not to confuse C++ compilers. (backported
  from 1.7, problem noted by ttate)
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/07 11:19:28 $
d479 1
a479 1
    VALUE obj;
d488 1
a488 1
    VALUE ptr;
d520 1
a520 1
	    rb_gc_mark((VALUE)obj->as.node.u2.node);
d534 1
a534 1
	    rb_gc_mark((VALUE)obj->as.node.u1.node);
d557 1
a557 1
	    rb_gc_mark((VALUE)obj->as.node.u1.node);
d593 1
a593 1
	    rb_gc_mark((VALUE)obj->as.node.u3.node);
d631 1
a631 1
		rb_gc_mark((VALUE)obj->as.node.u1.node);
d634 1
a634 1
		rb_gc_mark((VALUE)obj->as.node.u2.node);
d748 1
a748 1
		    rb_gc_mark((VALUE)p);
d1044 2
a1045 2
    rb_gc_mark((VALUE)ruby_scope);
    rb_gc_mark((VALUE)ruby_dyna_vars);
@


1.48.2.24
log
@* gc.c (is_pointer_to_heap): avoid GCC 3.1 warnings.
* missing/strftime.c (timezone): it should take no argument on Cygwin.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2002/05/04 12:04:52 $
d419 1
a419 1
	if (is_pointer_to_heap((void *)*x)) {
d481 1
a481 1
    if (is_pointer_to_heap((void *)obj)) {
d1365 1
a1365 1
    if (!is_pointer_to_heap((void *)ptr)) {
@


1.48.2.25
log
@* parse.y (yylex): 'do' should return kDO_BLOCK on EXPR_ENDARG.

* parse.y (singleton): "def (()).a end" dumped core.

* parse.y (range_op): node may be null.

* parse.y (match_gen): ditto.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/05/14 06:10:49 $
d729 1
a729 1
	       is_pointer_to_heap(obj) ? "corrupted object" : "non object");
@


1.48.2.26
log
@* hash.c (rb_hash_equal): should check default values.

* ext/socket/socket.c (s_recvfrom): update RSTRING len.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/12 09:24:58 $
d27 2
a28 1
#if !defined(setjmp) && defined(HAVE__SETJMP)
d30 2
@


1.48.2.27
log
@* gc.c (gc_sweep): does reclaim nodes in also compile time, if we can.
* ruby.c (load_file): omit GC if we can.
* parse.y (ruby_parser_stack_on_heap): new function.
* intern.h (ruby_parser_stack_on_heap): added.
@
text
@d6 1
a6 1
  $Date: 2002/08/12 07:40:32 $
d739 2
a740 3
    if (ruby_in_compile && ruby_parser_stack_on_heap()) {
	/* should not reclaim nodes during compilation
           if yacc's semantic stack is not allocated on machine stack */
@


1.48.2.28
log
@* gc.c (rb_gc): should mark parser.
* parse.y (rb_gc_mark_parser): new function.
* intern.h (rb_gc_mark_parser): added.
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/09/02 15:20:12 $
a1070 2

    rb_gc_mark_parser();
@


1.48.2.29
log
@* eval.c (ruby_init): Init_stack() with local location.
  (ruby-bugs-ja:PR#277)

* gc.c (Init_stack): prefer address of argument rather than local
  variable to initialize rb_gc_stack_start.

* lib/weakref.rb (WeakRef::@@@@final): use Hash#delete.

* lib/weakref.rb (WeakRef::__getobj__): examin if alive or not by
  ID_REV_MAP to deal with recycled object.  [ruby-dev:18472]

* lib/weakref.rb (WeakRef::weakref_alive?): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/09/05 20:08:48 $
d1092 3
a1094 1
    if (!addr) addr = &addr;
@


1.48.2.30
log
@gc.c (Init_stack): avoid warning
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/10/10 07:01:11 $
d1092 1
a1092 1
    if (!addr) addr = (VALUE *)&addr;
@


1.48.2.31
log
@* eval.c, gc.c: use a common set of alloca() #ifdef's.  This fixes
  the build with Intel C Compiler for Linux.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/10/10 14:15:59 $
d39 1
a39 1
# ifdef HAVE_ALLOCA_H
d41 3
a43 9
# else
#  ifdef _AIX
 #pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
void *alloca ();
#   endif
#  endif /* AIX */
# endif /* HAVE_ALLOCA_H */
d45 4
@


1.48.2.32
log
@* array.c, class.c, eval.c, file.c, gc.c, node.h, numeric.c,
  object.c, parse.y, range.c, re.c, string.c, struct.c, util.c,
  ext/socket/socket.c: merge from 1.7: treat long values as long
  instead of int.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2002/10/25 19:37:49 $
d726 2
a727 2
	rb_bug("rb_gc_mark(): unknown data type 0x%lx(0x%lx) %s",
	       obj->as.basic.flags & T_MASK, (unsigned long)obj,
d1366 1
a1366 1
	rb_raise(rb_eRangeError, "0x%lx is not id value", p0);
d1369 1
a1369 1
	rb_raise(rb_eRangeError, "0x%lx is recycled object", p0);
@


1.47
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/27 09:23:18 $
a413 1
    if (FIXNUM_P(obj)) return;	                /* fixnum not marked */
@


1.46
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/21 14:26:20 $
d928 1
a928 1
# if defined(__GNUC__) && !defined(__alpha__)
d1008 1
a1008 1
#elif defined(__GNUC__) && !defined(__alpha__)
@


1.45
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/20 08:26:48 $
d64 1
a64 1
    size_t size;
d94 1
a94 1
    size_t n, size;
d107 1
a107 1
    size_t size;
d1243 1
d1247 1
d1315 1
a1315 1
    size_t size;
d1322 1
a1322 1
    size_t n,size;
d1330 1
a1330 1
    size_t size;
@


1.44
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/14 07:10:21 $
d489 1
a489 1
	  case NODE_CVASGN2:
d664 1
a664 1
	/* sould not reclaim nodes during compilation */
@


1.43
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/31 08:37:38 $
d238 1
d663 12
d676 2
a677 1
    final_list = 0;
d716 1
a716 1
    if (need_call_final) {
d719 5
d936 1
a936 1
    if (dont_gc || during_gc || rb_prohibit_interrupt || ruby_in_compile) {
@


1.42
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/16 09:13:16 $
d77 1
a77 1
    mem = malloc(size);
d80 1
a80 1
	mem = malloc(size);
d117 1
a117 1
    mem = realloc(ptr, size);
d120 1
a120 1
	mem = realloc(ptr, size);
d135 2
a136 1
    if (x) free(x);
d190 1
a190 1
	free(tmp);
d198 1
a198 1
	    free(t);
d257 3
a259 3
	heaps = (heaps_used>0)?
	    (RVALUE**)realloc(heaps, heaps_length*sizeof(RVALUE*)):
	    (RVALUE**)malloc(heaps_length*sizeof(RVALUE*));
d263 1
a263 1
    p = heaps[heaps_used++] = (RVALUE*)malloc(sizeof(RVALUE)*HEAP_SLOTS);
d758 1
a758 1
	    free(RANY(obj)->as.string.ptr);
d763 1
a763 1
	    free(RANY(obj)->as.array.ptr);
d776 1
a776 1
	    free(RANY(obj)->as.regexp.str);
d782 1
a782 1
		free(DATA_PTR(obj));
d792 1
a792 1
	    free(RANY(obj)->as.match.regs);
d798 1
a798 1
	    free(RANY(obj)->as.file.fptr);
d811 1
a811 1
	    free(RANY(obj)->as.bignum.digits);
d818 1
a818 1
		free(RANY(obj)->as.node.u1.tbl);
d823 1
a823 1
	    free(RANY(obj)->as.node.u1.value);
d834 1
a834 1
		free(RANY(obj)->as.scope.local_tbl);
d836 1
a836 1
		free(vars);
d842 1
a842 1
	    free(RANY(obj)->as.rstruct.ptr);
@


1.41
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/10 09:12:43 $
d83 1
a83 1
		rb_raise(rb_eNoMemError, "tryed to allocate too big memory");
d123 1
a123 1
		rb_raise(rb_eNoMemError, "tryed to re-allocate too big memory");
@


1.40
log
@nakada
@
text
@d6 1
a6 1
  $Date: 2000/10/10 07:03:19 $
d908 1
a908 1
# if defined(__GNUC__)
d988 1
a988 1
#elif defined(__GNUC__)
@


1.39
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/27 03:43:13 $
d988 1
a988 1
#elsif defined(__GNUC__)
@


1.38
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/25 17:51:21 $
d908 3
d912 1
d985 1
a985 1
#ifdef __human68k__
d988 2
@


1.37
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/25 09:15:02 $
d756 1
a756 1
	if (!RANY(obj)->as.string.orig || FL_TEST(obj, STR_NO_ORIG))
d758 1
d761 3
a763 1
	if (RANY(obj)->as.array.ptr) free(RANY(obj)->as.array.ptr);
d766 1
a766 1
	if (RANY(obj)->as.hash.tbl)
d768 1
d771 6
a776 2
	if (RANY(obj)->as.regexp.ptr) re_free_pattern(RANY(obj)->as.regexp.ptr);
	if (RANY(obj)->as.regexp.str) free(RANY(obj)->as.regexp.str);
d809 3
a811 1
	if (RANY(obj)->as.bignum.digits) free(RANY(obj)->as.bignum.digits);
d840 1
a840 1
	if (RANY(obj)->as.rstruct.ptr)
d842 1
@


1.36
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/12 05:37:21 $
d44 1
a44 1
#define GC_MALLOC_LIMIT 100000
d46 1
a46 1
#define GC_MALLOC_LIMIT 4000000
d73 1
d122 1
a122 1
	    if (size >= 10 * 1024 * 1024) {
@


1.35
log
@matz: 1.6.0 final (hopufully)
@
text
@d6 1
a6 1
  $Date: 2000/09/01 03:30:58 $
a1300 1

@


1.34
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/31 09:08:14 $
d754 1
a754 1
#define STR_NO_ORIG FL_USER3	/* copied from string.c */
@


1.33
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/29 07:29:46 $
d623 1
a623 2
	if (obj->as.scope.local_vars &&
            (obj->as.scope.flag & SCOPE_MALLOC) != 0) {
@


1.32
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/29 02:52:30 $
d624 1
a624 1
            obj->as.scope.flag != SCOPE_ALLOCA) {
@


1.31
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/28 09:53:26 $
a486 1
	  case NODE_CVASGN3:
a522 1
	  case NODE_CVAR3:
@


1.30
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/09 04:32:17 $
a485 1
	  case NODE_CVASGN:
@


1.29
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/07 06:11:33 $
d484 5
a488 1
	  case NODE_CASGN:
d524 2
@


1.28
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/07 05:01:52 $
a282 1
    if (freelist->as.free.next && freelist->as.free.next->as.free.flag != 0) abort();
d285 1
@


1.27
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/02 04:54:11 $
d283 1
d669 1
a669 1
	if (need_call_final && FL_TEST(p, FL_FINALIZE)) {
@


1.26
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/27 09:49:16 $
d281 1
a281 7
    if (freelist) {
      retry:
	obj = (VALUE)freelist;
	freelist = freelist->as.free.next;
	return obj;
    }
    rb_gc();
d283 3
a285 1
    goto retry;
a646 2

#define MIN_FREE_OBJ 512
@


1.25
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/17 09:37:56 $
d904 4
a907 1
	add_heap();
@


1.24
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/15 13:36:57 $
d287 1
a287 2
    if (dont_gc || during_gc || rb_prohibit_interrupt) add_heap();
    else rb_gc();
a662 12
    if (ruby_in_compile) {
	/* sould not reclaim nodes during compilation */
	for (i = 0; i < used; i++) {
	    p = heaps[i]; pend = p + HEAP_SLOTS;
	    while (p < pend) {
		if (!(p->as.basic.flags&FL_MARK) && BUILTIN_TYPE(p) == T_NODE)
		    rb_gc_mark(p);
		p++;
	    }
	}
    }

d902 5
@


1.23
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/04 04:17:09 $
d1174 1
a1174 1
    VALUE id, args[2], table;
d1176 1
a1176 2
    id = rb_obj_id(obj);	/* make obj into id */
    args[1] = rb_ary_new3(1, id);
@


1.22
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/28 08:26:54 $
d141 1
d935 3
d1083 1
d1096 1
d1104 1
d1112 1
d1119 43
d1174 1
a1174 1
    VALUE args[2];
d1176 2
a1177 2
    obj = rb_obj_id(obj);	/* make obj into id */
    args[1] = rb_ary_new3(1, obj);
d1182 7
d1265 4
@


1.21
log
@matz
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/06/26 15:16:03 $
d46 1
a46 1
#define GC_MALLOC_LIMIT 400000
a50 1
static unsigned long alloc_objects = 0;
a283 1
	alloc_objects++;
a914 1
    alloc_objects = 0;
@


1.20
log
@2000-06-27
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/05/17 04:38:12 $
a48 1
#define GC_NEWOBJ_LIMIT 10000
a52 2
static int malloc_called = 0;

d74 1
a74 1
    if (malloc_memories > GC_MALLOC_LIMIT && alloc_objects > GC_NEWOBJ_LIMIT) {
a76 1
    malloc_called++;
d83 1
a83 1
		rb_raise(rb_eNoMemError, "try to allocate too big memory");
d123 1
a123 1
		rb_raise(rb_eNoMemError, "try to re-allocate too big memory");
d243 1
a243 1
#define FREE_MIN  512
@


1.19
log
@2000-05-17
@
text
@d6 1
a6 1
  $Date: 2000/05/16 02:46:52 $
d302 2
a303 2
    void (*dfree)();
    void (*dmark)();
@


1.18
log
@remove configure from repositry
@
text
@d6 1
a6 1
  $Date: 2000/05/12 09:07:38 $
d1253 1
a1253 1
    return ruby_xfree(ptr);
@


1.17
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/09 04:52:57 $
a65 1
#ifndef xmalloc
d67 1
a67 1
xmalloc(size)
d97 1
a97 1
xcalloc(n, size)
d109 1
a109 1
xrealloc(ptr, size)
d136 1
a136 1
xfree(x)
a140 1
#endif
d1221 35
@


1.16
log
@2000-05-09
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:19 $
a54 1
static int second_mem_error = 0;
d949 1
a949 5
#if defined(THINK_C) || defined(__human68k__)
#ifndef __human68k__
    mark_locations_array((VALUE*)((char*)save_regs_gc_mark+2),
			 sizeof(save_regs_gc_mark) / sizeof(VALUE *));
#endif
@


1.15
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:44:10 $
d11 1
a11 1
  Copyright (C) 2000  Information-technology Promotion Agancy, Japan
a144 30
/* The way of garbage collecting which allows use of the cstack is due to */
/* Scheme In One Defun, but in C this time.

 *			  COPYRIGHT (c) 1989 BY				    *
 *	  PARADIGM ASSOCIATES INCORPORATED, CAMBRIDGE, MASSACHUSETTS.	    *
 *			   ALL RIGHTS RESERVED				    *

Permission to use, copy, modify, distribute and sell this software
and its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all copies
and that both that copyright notice and this permission notice appear
in supporting documentation, and that the name of Paradigm Associates
Inc not be used in advertising or publicity pertaining to distribution
of the software without specific, written prior permission.

PARADIGM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
PARADIGM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

gjc@@paradigm.com

Paradigm Associates Inc		 Phone: 617-492-6079
29 Putnam Ave, Suite 6
Cambridge, MA 02138
*/

d324 1
a324 1
looks_pointerp(ptr)
d349 1
a349 1
	if (looks_pointerp(*x)) {
d411 1
a411 1
    if (looks_pointerp(obj)) {
d558 1
a558 1
	    if (looks_pointerp(obj->as.node.u1.node)) {
d561 1
a561 1
	    if (looks_pointerp(obj->as.node.u2.node)) {
d564 1
a564 1
	    if (looks_pointerp(obj->as.node.u3.node)) {
d657 1
a657 1
	       looks_pointerp(obj)?"corrupted object":"non object");
d1193 2
a1194 2
    ptr = id ^ FIXNUM_FLAG;
    if (!looks_pointerp(ptr)) {
@


1.14
log
@2000-04-10
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/03/07 08:37:35 $
d10 2
d13 1
a13 1
************************************************/
@


1.13
log
@2000-03-07
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:48:47 $
d1185 2
a1186 1
	    if (FL_TEST(p, FL_FINALIZE))
d1188 1
@


1.12
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:12:04 $
a452 1
    if ((VALUE)obj == Qundef) return;           /* special placeholder */
d1221 1
a1221 1
	rb_raise(rb_eIndexError, "0x%x is not id value", ptr);
d1224 1
a1224 1
	rb_raise(rb_eIndexError, "0x%x is recycled object", ptr);
@


1.11
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:37:03 $
a52 1
static int free_called = 0;
d135 1
a135 1
static void
d139 1
a139 2
    free_called++;
    free(x);
d204 2
a205 2
rb_global_variable(var)
    VALUE *var;
d211 1
a211 1
    tmp->varptr = var;
d215 30
d1250 1
d1252 1
@


1.10
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:49:44 $
d495 1
a495 1
	  case NODE_DASGN_PUSH:
@


1.9
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/12/06 09:03:53 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d74 1
a74 1
	rb_raise(rb_eArgError, "negative allocation size (or too big)");
d425 1
d882 3
@


1.8
log
@19991206
@
text
@d6 1
a6 1
  $Date: 1999/11/29 06:32:58 $
d54 11
d86 6
a91 2
	if (!mem)
	    rb_fatal("failed to allocate memory");
d127 4
a130 1
	    rb_fatal("failed to allocate memory(realloc)");
d265 1
a265 1
	if (heaps == 0) rb_fatal("can't alloc memory");
d269 1
a269 1
    if (p == 0) rb_fatal("add_heap: can't alloc memory");
d391 1
a391 1
    ID key;
@


1.7
log
@19991129
@
text
@d6 1
a6 1
  $Date: 1999/11/26 09:07:23 $
d245 2
a246 2
	    (RVALUE**)realloc(heaps, heaps_length*sizeof(RVALUE)):
	    (RVALUE**)malloc(heaps_length*sizeof(RVALUE));
@


1.6
log
@mark_end_proc
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:33 $
d899 2
a900 1
# define STACK_END alloca(1)
@


1.5
log
@19991012
@
text
@d6 1
a6 1
  $Date: 1999/09/01 09:48:01 $
d896 4
a907 4
#ifdef C_ALLOCA
    alloca(0);
#endif

d927 1
a927 5
#ifdef C_ALLOCA
    rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)&stack_end);
#else
    rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)alloca(1));
#endif
d934 1
a934 1
		   (VALUE*)((char*)&stack_end + 2));
d942 1
@


1.5.2.1
log
@19991129
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:33 $
a895 4
    alloca(0);
# define STACK_END (&stack_end)
#else
# define STACK_END alloca(1)
d904 4
d927 5
a931 1
    rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END);
d938 1
a938 1
			 (VALUE*)((char*)STACK_END + 2));
a945 1
    rb_mark_end_proc();
@


1.5.2.2
log
@19991206
@
text
@d6 1
a6 1
  $Date: 1999/11/29 06:31:00 $
d245 2
a246 2
	    (RVALUE**)realloc(heaps, heaps_length*sizeof(RVALUE*)):
	    (RVALUE**)malloc(heaps_length*sizeof(RVALUE*));
@


1.5.2.3
log
@19991208
@
text
@d6 1
a6 1
  $Date: 1999/12/06 09:03:32 $
d899 1
a899 2
    VALUE *stack_end = alloca(1);
# define STACK_END (stack_end)
@


1.5.2.4
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/12/08 05:35:57 $
d373 1
a373 1
    VALUE key;
@


1.5.2.5
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:50:37 $
a862 3
#ifdef setjmp
#undef setjmp
#endif
@


1.5.2.6
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:41:03 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.5.2.7
log
@2000-03-13
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:24:01 $
d53 1
d118 1
a118 1
void
d122 2
a123 1
    if (x) free(x);
@


1.5.2.8
log
@2000-04-10
@
text
@d6 1
a6 1
  $Date: 2000/03/13 09:15:39 $
d1137 1
a1137 2
	    if (FL_TEST(p, FL_FINALIZE)) {
		p->as.free.flag = 0;
a1138 1
	    }
@


1.5.2.9
log
@2000-06-05
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:48:32 $
d54 1
d56 1
a56 1
ruby_xmalloc(size)
d82 1
a82 1
ruby_xcalloc(n, size)
d94 1
a94 1
ruby_xrealloc(ptr, size)
d118 1
a118 1
ruby_xfree(x)
d123 1
a1204 34
}

#undef xmalloc
#undef xcalloc
#undef xrealloc
#undef xfree

void*
xmalloc(size)
    size_t size;
{
    return ruby_xmalloc(size);
}

void*
xcalloc(n,size)
    size_t n,size;
{
    return ruby_xcalloc(n, size);
}

void*
xrealloc(ptr,size)
    void *ptr;
    size_t size;
{
    return ruby_xrealloc(ptr, size);
}

void
xfree(ptr)
    void *ptr;
{
    ruby_xfree(ptr);
@


1.4
log
@regexp literal (e.g. \202) match, etc.
@
text
@d6 1
a6 1
  $Date: 1999/08/24 08:21:53 $
a12 1
#define RUBY_NO_INLINE
@


1.3
log
@1.4.1 to be
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:05 $
d895 1
d897 1
d928 1
d930 3
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/11 07:24:02 $
d893 1
a893 1
    struct FRAME *frame;
a909 2
    }
    for (frame = ruby_frame; frame; frame = frame->prev) {
d925 1
a925 1
    mark_locations_array((VALUE*)&save_regs_gc_mark, sizeof(save_regs_gc_mark) / sizeof(VALUE *));
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1996/12/25 09:54:47 $
d9 1
a9 1
  Copyright (C) 1993-1996 Yukihiro Matsumoto
d13 1
d15 1
a15 1
#include "sig.h"
d23 3
a32 4
#ifdef _AIX
#pragma alloca
#endif

d34 1
d37 1
a38 2
void gc();
void gc_mark();
d43 1
a43 1
#define GC_MALLOC_LIMIT 200000
d48 1
d51 1
d53 4
d59 1
a59 1
    unsigned long size;
d63 3
d68 2
a69 2
    if (malloc_memories > GC_MALLOC_LIMIT) {
	gc();
d71 1
d74 1
a74 1
	gc();
d77 1
a77 1
	    Fatal("failed to allocate memory");
d85 1
a85 1
    unsigned long n, size;
d98 1
a98 1
    unsigned long size;
d102 3
d106 2
d110 1
a110 1
	gc();
d113 1
a113 1
	    Fatal("failed to allocate memory(realloc)");
d119 9
d158 1
a158 1
extern int rb_in_compile;
d160 2
d163 2
a164 2
VALUE
gc_s_enable()
d168 1
a168 1
    dont_gc = FALSE;
d172 2
a173 2
VALUE
gc_s_disable()
d177 1
a177 1
    dont_gc = TRUE;
d181 1
a181 1
VALUE mGC;
d203 1
a203 1
	    UINT flag;		/* always 0 for freed obj */
d208 1
a208 1
	struct RClass  class;
d225 1
a225 1
RVALUE *freelist = 0;
d248 1
a248 1
	if (heaps == 0) Fatal("can't alloc memory");
d252 1
a252 1
    if (p == 0) Fatal("can't alloc memory");
d264 1
d266 1
a266 1
struct RBasic *
d269 2
a270 1
    struct RBasic *obj;
d273 1
a273 1
	obj = (struct RBasic*)freelist;
d275 1
d278 2
a279 2
    if (dont_gc) add_heap();
    else gc();
d285 2
a286 2
data_object_alloc(class, datap, dmark, dfree)
    VALUE class;
d291 2
a292 3
    struct RData *data = (struct RData*)rb_newobj();

    OBJSETUP(data, class, T_DATA);
d301 1
a301 1
VALUE *gc_stack_start;
d303 3
d307 2
a308 2
looks_pointerp(p)
    register RVALUE *p;
d310 1
d314 1
a314 1
    if (p < lomem || p > himem) return FALSE;
d321 1
a321 1
	    return TRUE;
d323 1
a323 1
    return FALSE;
d328 2
a329 2
    VALUE *x;
    long n;
d333 1
a333 1
	    gc_mark(*x);
d340 1
a340 1
gc_mark_locations(start, end)
d351 1
a351 1
    n = end - start;
d360 1
a360 1
    gc_mark(value);
d364 2
a365 2
static void
mark_tbl(tbl)
d377 2
a378 2
    gc_mark(key);
    gc_mark(value);
d382 2
a383 2
static void
mark_hash(tbl)
d391 1
a391 1
gc_mark_maybe(obj)
d395 1
a395 1
	gc_mark(obj);
d400 2
a401 2
gc_mark(obj)
    register RVALUE *obj;
d403 2
d406 1
a406 1
    if (FIXNUM_P(obj)) return;	/* fixnum not marked */
d408 2
a409 2
    if (obj->as.basic.flags == 0) return; /* free cell */
    if (obj->as.basic.flags & FL_MARK) return; /* marked */
d413 4
d420 1
a420 1
	Bug("gc_mark() called for broken object");
d428 6
a433 1
	    gc_mark(obj->as.node.u2.node);
d443 1
d445 3
a447 1
	    gc_mark(obj->as.node.u1.node);
d451 1
d453 1
a453 1
	    obj = (RVALUE*)obj->as.node.u3.node;
d458 13
a470 1
	    gc_mark(obj->as.node.u1.node);
d474 10
a483 1
	    obj = (RVALUE*)obj->as.node.u2.node;
d491 6
a496 1
	    obj = (RVALUE*)obj->as.node.u1.node;
d500 4
a503 2
	    gc_mark(obj->as.node.u3.node);
	    obj = (RVALUE*)obj->as.node.u2.node;
d507 1
d519 4
d526 5
d532 7
d542 1
a542 1
		gc_mark(obj->as.node.u1.node);
d545 1
a545 1
		gc_mark(obj->as.node.u2.node);
d548 1
a548 1
		obj = (RVALUE*)obj->as.node.u3.node;
d555 1
a555 1
    gc_mark(obj->as.basic.class);
a557 5
	gc_mark(obj->as.class.super);
	mark_tbl(obj->as.class.iv_tbl);
	mark_tbl(obj->as.class.m_tbl);
	break;

d560 3
a562 3
	gc_mark(obj->as.class.super);
	mark_tbl(obj->as.class.m_tbl);
	mark_tbl(obj->as.class.iv_tbl);
d571 1
a571 1
		gc_mark(*ptr++);
d576 2
a577 1
	mark_hash(obj->as.hash.tbl);
d582 1
a582 1
	    obj = (RVALUE*)obj->as.string.orig;
d592 1
a592 1
	mark_tbl(obj->as.object.iv_tbl);
d603 1
a603 1
	    obj = (RVALUE*)obj->as.match.str;
d609 2
a610 2
	gc_mark(obj->as.varmap.val);
	obj = (RVALUE*)obj->as.varmap.next;
d615 2
a616 1
	if (obj->as.scope.local_vars) {
d621 1
a621 1
		gc_mark_maybe(*vars);
d633 1
a633 1
		gc_mark(*ptr++);
d638 3
a640 3
	Bug("gc_mark(): unknown data type 0x%x(0x%x) %s",
	    obj->as.basic.flags & T_MASK, obj,
	    looks_pointerp(obj)?"corrupted object":"non object");
d646 1
a646 1
static void obj_free();
d651 1
a651 1
    RVALUE *p, *pend;
d653 1
a653 1
    int  i;
d655 3
a657 2
    if (rb_in_compile) {
	for (i = 0; i < heaps_used; i++) {
d661 1
a661 1
		    gc_mark(p);
d668 2
a669 2
    for (i = 0; i < heaps_used; i++) {
	RVALUE *nfreelist;
a671 1
	nfreelist = freelist;
a672 1

d675 13
a687 4
		if (p->as.basic.flags) obj_free(p);
		p->as.free.flag = 0;
		p->as.free.next = nfreelist;
		nfreelist = p;
d690 5
a694 1
	    else
d696 1
a699 1
	freelist = nfreelist;
d704 14
d721 2
a722 2
gc_force_recycle(p)
    RVALUE *p;
d724 3
a726 3
    p->as.free.flag = 0;
    p->as.free.next = freelist;
    freelist = p;
a728 2
static int need_call_final = 0;

d731 1
a731 1
    RVALUE *obj;
d733 1
a733 1
    switch (obj->as.basic.flags & T_MASK) {
d738 1
a738 1
	Bug("obj_free() called for broken object");
d742 2
a743 2
    if (need_call_final) {
	run_final(obj);
d745 2
a746 1
    switch (obj->as.basic.flags & T_MASK) {
d748 3
a750 1
	if (obj->as.object.iv_tbl) st_free_table(obj->as.object.iv_tbl);
d755 4
a758 2
	st_free_table(obj->as.class.m_tbl);
	if (obj->as.object.iv_tbl) st_free_table(obj->as.object.iv_tbl);
d761 3
a763 1
	if (!obj->as.string.orig) free(obj->as.string.ptr);
d766 1
a766 1
	if (obj->as.array.ptr) free(obj->as.array.ptr);
d769 2
a770 1
	st_free_table(obj->as.hash.tbl);
d773 2
a774 2
	reg_free(obj->as.regexp.ptr);
	free(obj->as.regexp.str);
d777 8
a784 2
	if (obj->as.data.dfree && DATA_PTR(obj))
	    (*obj->as.data.dfree)(DATA_PTR(obj));
d787 4
a790 2
	re_free_registers(obj->as.match.regs);
	free(obj->as.match.regs);
d793 4
a796 2
	io_fptr_finalize(obj->as.file.fptr);
	free(obj->as.file.fptr);
d807 1
a807 1
	if (obj->as.bignum.digits) free(obj->as.bignum.digits);
d810 11
a820 2
	if (nd_type(obj) == NODE_SCOPE && obj->as.node.u1.tbl) {
	    free(obj->as.node.u1.tbl);
d825 3
a827 2
	if (obj->as.scope.local_vars) {
	    VALUE *vars = obj->as.scope.local_vars-1;
d829 2
a830 2
		free(obj->as.scope.local_tbl);
	    if (obj->as.scope.flag&SCOPE_MALLOC)
d836 2
a837 1
	free(obj->as.rstruct.ptr);
d841 2
a842 1
	Bug("gc_sweep(): unknown data type %d", obj->as.basic.flags & T_MASK);
d847 1
a847 1
gc_mark_frame(frame)
d850 2
a851 8
    int n = frame->argc;
    VALUE *tbl = frame->argv;

    while (n--) {
	gc_mark_maybe(*tbl);
	tbl++;
    }
    gc_mark(frame->cbase);
d890 1
a890 1
gc()
d897 5
a901 2
    if (dont_gc) return;
    dont_gc++;
a902 1
    malloc_memories = 0;
d908 11
a918 2
    for (frame = the_frame; frame; frame = frame->prev) {
	gc_mark_frame(frame);
d920 3
a922 2
    gc_mark(the_scope);
    gc_mark(the_dyna_vars);
d928 1
a928 1
    gc_mark_locations(gc_stack_start, (VALUE*)&stack_end);
d934 1
a934 1
    gc_mark_locations((VALUE*)((char*)gc_stack_start + 2),
d937 1
a937 4

#ifdef THREAD
    gc_mark_threads();
#endif
d941 1
a941 1
	gc_mark(*list->varptr);
d943 1
d945 5
a949 3
    gc_mark_global_tbl();
    mark_tbl(rb_class_tbl);
    gc_mark_trap_list();
a951 1
    dont_gc--;
d955 1
a955 1
gc_method()
d957 1
a957 1
    gc();
d962 2
a963 1
init_stack()
d967 1
a967 1
    gc_stack_start = _SEND;
d971 2
a972 1
    gc_stack_start = &start;
d977 1
a977 1
init_heap()
d979 3
a981 1
    init_stack();
d1006 1
a1006 1
		    rb_yield(p);
d1038 2
a1039 2
		    if (obj_is_kind_of(p, of)) {
			rb_yield(p);
d1071 3
a1073 5
    extern VALUE cProc;

    if (!obj_is_kind_of(proc, cProc)) {
	ArgError("wrong type argument %s (Proc required)",
		  rb_class2name(CLASS_OF(proc)));
d1075 1
a1075 1
    ary_push(finalizers, proc);
d1083 1
a1083 1
    ary_delete(finalizers, proc);
d1102 8
d1114 15
d1131 30
a1160 1
    if (!FL_TEST(obj, FL_FINALIZE)) return;
d1162 13
a1174 3
    obj |= FIXNUM_FLAG;		/* make obj into id */
    for (i=0; i<RARRAY(finalizers)->len; i++) {
	rb_eval_cmd(RARRAY(finalizers)->ptr[i], obj);
d1176 1
a1178 2
extern VALUE cModule;

d1182 1
a1182 1
    VALUE mObSpace;
d1184 14
a1197 13
    mGC = rb_define_module("GC");
    rb_define_singleton_method(mGC, "start", gc_method, 0);
    rb_define_singleton_method(mGC, "enable", gc_s_enable, 0);
    rb_define_singleton_method(mGC, "disable", gc_s_disable, 0);
    rb_define_method(mGC, "garbage_collect", gc_method, 0);

    mObSpace = rb_define_module("ObjectSpace");
    rb_define_module_function(mObSpace, "each_object", os_each_obj, -1);
    rb_define_module_function(mObSpace, "garbage_collect", gc, 0);
    rb_define_module_function(mObSpace, "add_finalizer", add_final, 1);
    rb_define_module_function(mObSpace, "remove_finalizer", rm_final, 1);
    rb_define_module_function(mObSpace, "finalizers", finals, 0);
    rb_define_module_function(mObSpace, "call_finalizer", call_final, 1);
d1200 1
a1200 1
    finalizers = ary_new();
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d37 2
d60 1
a60 1
	gc_gc();
d64 1
a64 1
	gc_gc();
d95 1
a95 1
	gc_gc();
a237 1
#define RANY(o) ((RVALUE*)(o))
d239 1
a239 1
VALUE
d242 1
a242 2
    VALUE obj;

d245 1
a245 1
	obj = (VALUE)freelist;
d250 1
a250 1
    else gc_gc();
d262 2
a263 1
    NEWOBJ(data, struct RData);
d276 2
a277 2
looks_pointerp(ptr)
    void *ptr;
a278 1
    register RVALUE *p = RANY(ptr);
d368 2
a369 2
gc_mark(ptr)
    void *ptr;
a370 2
    register RVALUE *obj = RANY(ptr);

d406 1
a406 1
	    obj = RANY(obj->as.node.u3.node);
a410 2
	  case NODE_MATCH2:
	  case NODE_MATCH3:
d415 1
a415 1
	    obj = RANY(obj->as.node.u2.node);
d423 1
a423 2
	  case NODE_MATCH:
	    obj = RANY(obj->as.node.u1.node);
d428 1
a428 1
	    obj = RANY(obj->as.node.u2.node);
a445 1
	  case NODE_POSTEXE:
d456 1
a456 1
		obj = RANY(obj->as.node.u3.node);
d494 1
a494 1
	    obj = RANY(obj->as.string.orig);
d515 1
a515 1
	    obj = RANY(obj->as.match.str);
d522 1
a522 1
	obj = RANY(obj->as.varmap.next);
d607 1
a607 1
    VALUE p;
d609 3
a611 3
    RANY(p)->as.free.flag = 0;
    RANY(p)->as.free.next = freelist;
    freelist = RANY(p);
d618 1
a618 1
    VALUE obj;
d620 1
a620 1
    switch (RANY(obj)->as.basic.flags & T_MASK) {
d632 1
a632 1
    switch (RANY(obj)->as.basic.flags & T_MASK) {
d634 1
a634 3
	if (RANY(obj)->as.object.iv_tbl) {
	    st_free_table(RANY(obj)->as.object.iv_tbl);
	}
d639 2
a640 4
	st_free_table(RANY(obj)->as.class.m_tbl);
	if (RANY(obj)->as.object.iv_tbl) {
	    st_free_table(RANY(obj)->as.object.iv_tbl);
	}
d643 1
a643 1
	if (!RANY(obj)->as.string.orig) free(RANY(obj)->as.string.ptr);
d646 1
a646 1
	if (RANY(obj)->as.array.ptr) free(RANY(obj)->as.array.ptr);
d649 1
a649 1
	st_free_table(RANY(obj)->as.hash.tbl);
d652 2
a653 2
	reg_free(RANY(obj)->as.regexp.ptr);
	free(RANY(obj)->as.regexp.str);
d656 2
a657 2
	if (RANY(obj)->as.data.dfree && DATA_PTR(obj))
	    (*RANY(obj)->as.data.dfree)(DATA_PTR(obj));
d660 2
a661 2
	re_free_registers(RANY(obj)->as.match.regs);
	free(RANY(obj)->as.match.regs);
d664 2
a665 2
	io_fptr_finalize(RANY(obj)->as.file.fptr);
	free(RANY(obj)->as.file.fptr);
d676 1
a676 1
	if (RANY(obj)->as.bignum.digits) free(RANY(obj)->as.bignum.digits);
d679 2
a680 2
	if (nd_type(obj) == NODE_SCOPE && RANY(obj)->as.node.u1.tbl) {
	    free(RANY(obj)->as.node.u1.tbl);
d685 2
a686 2
	if (RANY(obj)->as.scope.local_vars) {
	    VALUE *vars = RANY(obj)->as.scope.local_vars-1;
d688 2
a689 2
		free(RANY(obj)->as.scope.local_tbl);
	    if (RANY(obj)->as.scope.flag&SCOPE_MALLOC)
d695 1
a695 1
	free(RANY(obj)->as.rstruct.ptr);
d699 1
a699 1
	Bug("gc_sweep(): unknown data type %d", RANY(obj)->as.basic.flags & T_MASK);
d753 1
a753 1
gc_gc()
d809 1
a809 1
    gc_gc();
d854 1
a854 1
		    rb_yield((VALUE)p);
d886 2
a887 2
		    if (obj_is_kind_of((VALUE)p, of)) {
			rb_yield((VALUE)p);
d960 1
a960 1
    obj = INT2NUM((int)obj);	/* make obj into id */
d962 1
a962 35
	rb_eval_cmd(RARRAY(finalizers)->ptr[i], ary_new3(1,obj));
    }
}

void
gc_call_finalizer_at_exit()
{
    RVALUE *p, *pend;
    int i;

    for (i = 0; i < heaps_used; i++) {
	p = heaps[i]; pend = p + HEAP_SLOTS;
	while (p < pend) {
	    run_final(p);
	    if (BUILTIN_TYPE(p) == T_DATA &&
		DATA_PTR(p) &&
		RANY(p)->as.data.dfree)
		(*RANY(p)->as.data.dfree)(DATA_PTR(p));
	    p++;
	}
    }
}

static VALUE
id2ref(obj, id)
    VALUE obj, id;
{
    INT ptr = NUM2INT(id);

    if (FIXNUM_P(ptr)) return (VALUE)ptr;
    if (!looks_pointerp(ptr)) {
	IndexError("0x%x is not the id value", ptr);
    }
    if (RANY(ptr)->as.free.flag == 0) {
	IndexError("0x%x is recycled object", ptr);
a963 1
    return (VALUE)ptr;
d981 1
a981 1
    rb_define_module_function(mObSpace, "garbage_collect", gc_method, 0);
a985 1
    rb_define_module_function(mObSpace, "id2ref", id2ref, 1);
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/12/16 07:30:31 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
a12 1
#define RUBY_NO_INLINE
d14 1
a14 1
#include "rubysig.h"
a21 3
void re_free_registers _((struct re_registers*));
void rb_io_fptr_finalize _((struct OpenFile*));

d29 4
a33 1
#ifndef alloca
a35 1
#endif
d41 1
a41 1
#define GC_MALLOC_LIMIT 100000
d43 1
a43 1
#define GC_MALLOC_LIMIT 200000
a45 1
#define GC_NEWOBJ_LIMIT 1000
a47 1
static unsigned long alloc_objects = 0;
d51 1
a51 1
    size_t size;
a54 3
    if (size < 0) {
	rb_raise(rb_eArgError, "negative allocation size (or too big)");
    }
d57 2
a58 2
    if (malloc_memories > GC_MALLOC_LIMIT && alloc_objects > GC_NEWOBJ_LIMIT) {
	rb_gc();
d62 1
a62 1
	rb_gc();
d65 1
a65 1
	    rb_fatal("failed to allocate memory");
d73 1
a73 1
    size_t n, size;
d86 1
a86 1
    size_t size;
a89 3
    if (size < 0) {
	rb_raise(rb_eArgError, "negative re-allocation size");
    }
a90 2
    if (size == 0) size = 1;
    malloc_memories += size;
d93 1
a93 1
	rb_gc();
d96 1
a96 1
	    rb_fatal("failed to allocate memory(realloc)");
d132 1
a132 1
extern int ruby_in_compile;
a133 2
static int during_gc;
static int need_call_final = 0;
d135 2
a136 2
static VALUE
gc_enable()
d140 1
a140 1
    dont_gc = Qfalse;
d144 2
a145 2
static VALUE
gc_disable()
d149 1
a149 1
    dont_gc = Qtrue;
d153 1
a153 1
VALUE rb_mGC;
d175 1
a175 1
	    unsigned long flag;	/* always 0 for freed obj */
d180 1
a180 1
	struct RClass  klass;
d197 1
a197 1
static RVALUE *freelist = 0;
d220 1
a220 1
	if (heaps == 0) rb_fatal("can't alloc memory");
d224 1
a224 1
    if (p == 0) rb_fatal("add_heap: can't alloc memory");
a246 1
	alloc_objects++;
d249 2
a250 2
    if (dont_gc || during_gc || rb_prohibit_interrupt) add_heap();
    else rb_gc();
d256 2
a257 2
rb_data_object_alloc(klass, datap, dmark, dfree)
    VALUE klass;
d263 1
a263 1
    OBJSETUP(data, klass, T_DATA);
d272 1
a272 1
VALUE *rb_gc_stack_start;
a273 3
#if defined(__GNUC__) && __GNUC__ >= 2
__inline__
#endif
d282 1
a282 1
    if (p < lomem || p > himem) return Qfalse;
d289 1
a289 1
	    return Qtrue;
d291 1
a291 1
    return Qfalse;
d296 2
a297 2
    register VALUE *x;
    register long n;
d301 1
a301 1
	    rb_gc_mark(*x);
d308 1
a308 1
rb_gc_mark_locations(start, end)
d328 1
a328 1
    rb_gc_mark(value);
d332 2
a333 2
void
rb_mark_tbl(tbl)
d345 2
a346 2
    rb_gc_mark(key);
    rb_gc_mark(value);
d350 2
a351 2
void
rb_mark_hash(tbl)
d359 1
a359 1
rb_gc_mark_maybe(obj)
d363 1
a363 1
	rb_gc_mark(obj);
d368 1
a368 1
rb_gc_mark(ptr)
d377 1
a377 1
    if (obj->as.basic.flags & FL_MARK) return; /* already marked */
a380 4
    if (FL_TEST(obj, FL_EXIVAR)) {
	rb_mark_generic_ivar((VALUE)obj);
    }

d384 1
a384 1
	rb_bug("rb_gc_mark() called for broken object");
d392 1
a392 6
	  case NODE_CREF:
	  case NODE_WHEN:
	  case NODE_MASGN:
	  case NODE_RESCUE:
	  case NODE_RESBODY:
	    rb_gc_mark(obj->as.node.u2.node);
a401 1
	  case NODE_ENSURE:
d403 1
a403 3
	  case NODE_DEFS:
	  case NODE_OP_ASGN1:
	    rb_gc_mark(obj->as.node.u1.node);
a406 1
	  case NODE_DEFN:
a412 9
	  case NODE_AND:
	  case NODE_OR:
	  case NODE_CASE:
	  case NODE_SCLASS:
	  case NODE_ARGS:
	  case NODE_DOT2:
	  case NODE_DOT3:
	  case NODE_FLIP2:
	  case NODE_FLIP3:
d415 1
a415 3
	  case NODE_OP_ASGN_OR:
	  case NODE_OP_ASGN_AND:
	    rb_gc_mark(obj->as.node.u1.node);
a418 9
	  case NODE_GASGN:
	  case NODE_LASGN:
	  case NODE_DASGN:
	  case NODE_DASGN_PUSH:
	  case NODE_IASGN:
	  case NODE_CASGN:
	  case NODE_MODULE:
	  case NODE_COLON3:
	  case NODE_OPT_N:
a427 3
	  case NODE_RETURN:
	  case NODE_YIELD:
	  case NODE_COLON2:
d432 1
a432 3
	  case NODE_CLASS:
	  case NODE_BLOCK_PASS:
	    rb_gc_mark(obj->as.node.u3.node);
a436 1
	  case NODE_ZSUPER:
a447 4
	  case NODE_BREAK:
	  case NODE_NEXT:
	  case NODE_REDO:
	  case NODE_RETRY:
a450 4
	  case NODE_TRUE:
	  case NODE_FALSE:
	  case NODE_ATTRSET:
	  case NODE_BLOCK_ARG:
a452 7
#ifdef C_ALLOCA
	  case NODE_ALLOCA:
	    mark_locations_array((VALUE*)obj->as.node.u1.value,
				 obj->as.node.u3.cnt);
	    obj = RANY(obj->as.node.u2.node);
	    goto Top;
#endif
d456 1
a456 1
		rb_gc_mark(obj->as.node.u1.node);
d459 1
a459 1
		rb_gc_mark(obj->as.node.u2.node);
d469 1
a469 1
    rb_gc_mark(obj->as.basic.klass);
d472 5
d479 3
a481 3
	rb_gc_mark(obj->as.klass.super);
	rb_mark_tbl(obj->as.klass.m_tbl);
	rb_mark_tbl(obj->as.klass.iv_tbl);
d490 1
a490 1
		rb_gc_mark(*ptr++);
d495 1
a495 2
	rb_mark_hash(obj->as.hash.tbl);
	rb_gc_mark(obj->as.hash.ifnone);
d510 1
a510 1
	rb_mark_tbl(obj->as.object.iv_tbl);
d527 1
a527 1
	rb_gc_mark(obj->as.varmap.val);
d538 1
a538 1
		rb_gc_mark(*vars);
d550 1
a550 1
		rb_gc_mark(*ptr++);
d555 3
a557 3
	rb_bug("rb_gc_mark(): unknown data type 0x%x(0x%x) %s",
	       obj->as.basic.flags & T_MASK, obj,
	       looks_pointerp(obj)?"corrupted object":"non object");
d563 1
a563 1
static void obj_free _((VALUE));
d568 1
a568 1
    RVALUE *p, *pend, *final_list;
d570 1
a570 1
    int i, used = heaps_used;
d572 2
a573 3
    if (ruby_in_compile) {
	/* sould not reclaim nodes during compilation */
	for (i = 0; i < used; i++) {
d577 1
a577 1
		    rb_gc_mark(p);
d584 2
a585 2
    final_list = 0;
    for (i = 0; i < used; i++) {
d588 1
d590 1
d593 4
a596 13
		if (p->as.basic.flags) {
		    obj_free((VALUE)p);
		}
		if (need_call_final && FL_TEST(p, FL_FINALIZE)) {
		    p->as.free.flag = FL_MARK; /* remain marked */
		    p->as.free.next = final_list;
		    final_list = p;
		}
		else {
		    p->as.free.flag = 0;
		    p->as.free.next = freelist;
		    freelist = p;
		}
d599 1
a599 5
	    else if (RBASIC(p)->flags == FL_MARK) {
		/* objects to be finalized */
		/* do notning remain marked */
	    }
	    else {
a600 1
	    }
d604 1
a608 14
    during_gc = 0;

    /* clear finalization list */
    if (need_call_final) {
	RVALUE *tmp;

	for (p = final_list; p; p = tmp) {
	    tmp = p->as.free.next;
	    run_final((VALUE)p);
	    p->as.free.flag = 0;
	    p->as.free.next = freelist;
	    freelist = p;
	}
    }
d612 1
a612 1
rb_gc_force_recycle(p)
d620 2
d631 1
a631 1
	rb_bug("obj_free() called for broken object");
d635 2
a636 2
    if (FL_TEST(obj, FL_EXIVAR)) {
	rb_free_generic_ivar((VALUE)obj);
a637 1

d647 1
a647 1
	st_free_table(RANY(obj)->as.klass.m_tbl);
d653 1
a653 3
#define STR_NO_ORIG FL_USER3	/* copied from string.c */
	if (!RANY(obj)->as.string.orig || FL_TEST(obj, STR_NO_ORIG))
	    free(RANY(obj)->as.string.ptr);
d659 1
a659 2
	if (RANY(obj)->as.hash.tbl)
	    st_free_table(RANY(obj)->as.hash.tbl);
d662 2
a663 2
	if (RANY(obj)->as.regexp.ptr) re_free_pattern(RANY(obj)->as.regexp.ptr);
	if (RANY(obj)->as.regexp.str) free(RANY(obj)->as.regexp.str);
d666 2
a667 8
	if (DATA_PTR(obj)) {
	    if ((long)RANY(obj)->as.data.dfree == -1) {
		free(DATA_PTR(obj));
	    }
	    else if (RANY(obj)->as.data.dfree) {
		(*RANY(obj)->as.data.dfree)(DATA_PTR(obj));
	    }
	}
d670 2
a671 4
	if (RANY(obj)->as.match.regs)
	    re_free_registers(RANY(obj)->as.match.regs);
	if (RANY(obj)->as.match.regs)
	    free(RANY(obj)->as.match.regs);
d674 2
a675 4
	if (RANY(obj)->as.file.fptr) {
	    rb_io_fptr_finalize(RANY(obj)->as.file.fptr);
	    free(RANY(obj)->as.file.fptr);
	}
d689 2
a690 11
	switch (nd_type(obj)) {
	  case NODE_SCOPE:
	    if (RANY(obj)->as.node.u1.tbl) {
		free(RANY(obj)->as.node.u1.tbl);
	    }
	    break;
#ifdef C_ALLOCA
	  case NODE_ALLOCA:
	    free(RANY(obj)->as.node.u1.value);
	    break;
#endif
d705 1
a705 2
	if (RANY(obj)->as.rstruct.ptr)
	    free(RANY(obj)->as.rstruct.ptr);
d709 1
a709 2
	rb_bug("gc_sweep(): unknown data type %d",
	       RANY(obj)->as.basic.flags & T_MASK);
d714 1
a714 1
rb_gc_mark_frame(frame)
d717 8
a724 2
    mark_locations_array(frame->argv, frame->argc);
    rb_gc_mark(frame->cbase);
d763 1
a763 1
rb_gc()
d770 3
a772 1
    alloc_objects = 0;
a773 4

    if (during_gc) return;
    during_gc++;

d779 2
a780 2
    for (frame = ruby_frame; frame; frame = frame->prev) {
	rb_gc_mark_frame(frame);
d782 2
a783 3
    rb_gc_mark(ruby_class);
    rb_gc_mark(ruby_scope);
    rb_gc_mark(ruby_dyna_vars);
d789 1
a789 1
    rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)&stack_end);
d795 1
a795 1
    rb_gc_mark_locations((VALUE*)((char*)rb_gc_stack_start + 2),
d799 2
a800 2
#ifdef USE_THREAD
    rb_gc_mark_threads();
d805 1
a805 1
	rb_gc_mark(*list->varptr);
a806 1
    rb_gc_mark_global_tbl();
d808 3
a810 5
    rb_mark_tbl(rb_class_tbl);
    rb_gc_mark_trap_list();

    /* mark generic instance variables for special constants */
    rb_mark_generic_ivar_tbl();
d813 1
d817 1
a817 1
gc_start()
d819 1
a819 1
    rb_gc();
d824 1
a824 1
Init_stack()
d832 1
a832 1
    rb_gc_stack_start = &start;
d837 1
a837 1
Init_heap()
d839 1
a839 1
    Init_stack();
d896 1
a896 1
		    if (rb_obj_is_kind_of((VALUE)p, of)) {
d929 5
a933 3
    if (!rb_obj_is_kind_of(proc, rb_cProc)) {
	rb_raise(rb_eArgError, "wrong type argument %s (Proc required)",
		 rb_class2name(CLASS_OF(proc)));
d935 1
a935 1
    rb_ary_push(finalizers, proc);
d943 1
a943 1
    rb_ary_delete(finalizers, proc);
d968 3
a970 1
    obj = rb_obj_id(obj);	/* make obj into id */
d972 1
a972 1
	rb_eval_cmd(RARRAY(finalizers)->ptr[i], rb_ary_new3(1, obj));
d977 1
a977 1
rb_gc_call_finalizer_at_exit()
a981 10
    /* run finalizers */
    for (i = 0; i < heaps_used; i++) {
	p = heaps[i]; pend = p + HEAP_SLOTS;
	while (p < pend) {
	    if (FL_TEST(p, FL_FINALIZE))
		run_final((VALUE)p);
	    p++;
	}
    }
    /* run data object's finaliers */
d985 1
d999 1
a999 1
    unsigned long ptr;
a1000 2
    rb_secure(4);
    ptr = NUM2UINT(id);
a1001 5
    if (ptr == Qtrue) return Qtrue;
    if (ptr == Qfalse) return Qfalse;
    if (ptr == Qnil) return Qnil;

    ptr = id ^ FIXNUM_FLAG;
d1003 1
a1003 1
	rb_raise(rb_eIndexError, "0x%x is not id value", ptr);
d1005 2
a1006 2
    if (BUILTIN_TYPE(ptr) == 0) {
	rb_raise(rb_eIndexError, "0x%x is recycled object", ptr);
d1011 2
d1016 1
a1016 1
    VALUE rb_mObSpace;
d1018 14
a1031 14
    rb_mGC = rb_define_module("GC");
    rb_define_singleton_method(rb_mGC, "start", gc_start, 0);
    rb_define_singleton_method(rb_mGC, "enable", gc_enable, 0);
    rb_define_singleton_method(rb_mGC, "disable", gc_disable, 0);
    rb_define_method(rb_mGC, "garbage_collect", gc_start, 0);

    rb_mObSpace = rb_define_module("ObjectSpace");
    rb_define_module_function(rb_mObSpace, "each_object", os_each_obj, -1);
    rb_define_module_function(rb_mObSpace, "garbage_collect", gc_start, 0);
    rb_define_module_function(rb_mObSpace, "add_finalizer", add_final, 1);
    rb_define_module_function(rb_mObSpace, "remove_finalizer", rm_final, 1);
    rb_define_module_function(rb_mObSpace, "finalizers", finals, 0);
    rb_define_module_function(rb_mObSpace, "call_finalizer", call_final, 1);
    rb_define_module_function(rb_mObSpace, "_id2ref", id2ref, 1);
d1034 1
a1034 1
    finalizers = rb_ary_new();
@


1.1.1.3.2.1
log
@990126
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:23 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
@


1.1.1.3.2.2
log
@990127
@
text
@d6 1
a6 1
  $Date: 1999/01/26 10:08:12 $
d601 1
a601 2
	if (obj->as.scope.local_vars &&
            obj->as.scope.flag != SCOPE_ALLOCA) {
d810 1
a810 2
	if (RANY(obj)->as.scope.local_vars &&
            RANY(obj)->as.scope.flag != SCOPE_ALLOCA) {
@


1.1.1.3.2.3
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/01/27 08:08:37 $
d45 1
a45 1
#define GC_MALLOC_LIMIT 400000
d48 1
a48 1
#define GC_NEWOBJ_LIMIT 10000
@


1.1.1.3.2.4
log
@990212
@
text
@d6 1
a6 1
  $Date: 1999/02/09 06:08:20 $
d392 1
a392 1
    if (FIXNUM_P(obj)) return;	                /* fixnum not marked */
d394 2
a395 2
    if (obj->as.basic.flags == 0) return;       /* free cell */
    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */
d773 1
a773 1
	if (RANY(obj)->as.match.regs) {
d775 1
a776 1
	}
@


1.1.1.3.2.5
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/12 11:17:03 $
d914 2
d917 1
@


1.1.1.3.2.6
log
@regexp null pattern
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:28 $
a1074 8
static VALUE
run_single_final(args)
    VALUE *args;
{
    rb_eval_cmd(args[0], args[1]);
    return Qnil;
}

d1079 1
a1079 2
    int i, status;
    VALUE args[2];
a1081 1
    args[1] = rb_ary_new3(1, obj);
d1083 1
a1083 2
	args[0] = RARRAY(finalizers)->ptr[i];
	rb_protect(run_single_final, (VALUE)args, &status);
@


1.1.1.3.2.7
log
@990531
@
text
@d6 1
a6 1
  $Date: 1999/05/25 08:25:59 $
a52 4
static int malloc_called = 0;
static int free_called = 0;

#ifndef xmalloc
a66 1
    malloc_called++;
a113 9
static void
xfree(x)
    void *x;
{
    free_called++;
    free(x);
}
#endif

d664 1
a664 1
	if (need_call_final && FL_TEST(p, FL_FINALIZE)) {
a1120 4
#if 0
	    else if (BUILTIN_TYPE(p))
		obj_free((VALUE)p);
#endif
@


1.1.1.3.2.8
log
@990611
@
text
@d6 1
a6 1
  $Date: 1999/05/31 09:13:11 $
d301 1
a301 1
VALUE *rb_gc_stack_start = 0;
d953 1
a953 2
Init_stack(addr)
    VALUE *addr;
d957 1
a957 1
    rb_gc_stack_start = _SEND;
d961 1
a961 2
    if (!addr) addr = &start;
    rb_gc_stack_start = addr;
d968 1
a968 3
    if (!rb_gc_stack_start) {
	Init_stack(0);
    }
@


1.1.1.3.2.9
log
@990624
@
text
@d6 1
a6 1
  $Date: 1999/06/11 06:29:53 $
d351 1
a351 1
    n = end - start + 1;
@


1.1.1.3.2.10
log
@990625
@
text
@d6 1
a6 1
  $Date: 1999/06/24 04:23:54 $
d462 1
a495 1
	  case NODE_ARGS:
@


1.1.1.3.2.11
log
@990715
@
text
@d6 1
a6 1
  $Date: 1999/06/25 09:02:41 $
d1136 2
a1137 1
		DATA_PTR(p) && RANY(p)->as.data.dfree) {
d1139 4
a1142 4
	    }
	    else if (BUILTIN_TYPE(p) == T_FILE) {
		rb_io_fptr_finalize(RANY(p)->as.file.fptr);
	    }
@


1.1.1.3.2.12
log
@990806
@
text
@d6 1
a6 1
  $Date: 1999/07/15 07:59:45 $
d909 1
a909 4
	rb_gc_mark_frame(frame); 
    }
    for (frame = ruby_frame; frame; frame = frame->prev) {
	if (frame->tmp) rb_gc_mark_frame(frame->tmp); 
@


1.1.1.3.2.13
log
@1.3.8 to be, final beta (hopefully)
@
text
@d6 1
a6 1
  $Date: 1999/08/06 06:48:17 $
d912 1
a912 7
	if (frame->tmp) {
	    struct FRAME *tmp = frame->tmp;
	    while (tmp) {
		rb_gc_mark_frame(tmp);
		tmp = tmp->prev;
	    }
	}
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:04:56 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:45 $
d29 4
a402 4
	  case NODE_CREF:
#ifdef C_ALLOCA
	  case NODE_ALLOCA:
#endif
@


1.1.1.2.2.3
log
@forget to protect cref from gc
@
text
@d6 1
a6 1
  $Date: 1998/01/22 08:12:09 $
a387 1
	  case NODE_CREF:
d399 1
@


1.1.1.2.2.4
log
@1.1b7 pre
@
text
@d6 1
a6 1
  $Date: 1998/01/22 10:28:03 $
d176 1
a176 1
	struct RClass  klass;
d252 2
a253 2
data_object_alloc(klass, datap, dmark, dfree)
    VALUE klass;
d259 1
a259 1
    OBJSETUP(data, klass, T_DATA);
d469 1
a469 1
    gc_mark(obj->as.basic.klass);
d472 3
a474 3
	gc_mark(obj->as.klass.super);
	mark_tbl(obj->as.klass.iv_tbl);
	mark_tbl(obj->as.klass.m_tbl);
d479 3
a481 3
	gc_mark(obj->as.klass.super);
	mark_tbl(obj->as.klass.m_tbl);
	mark_tbl(obj->as.klass.iv_tbl);
d647 1
a647 1
	st_free_table(RANY(obj)->as.klass.m_tbl);
@


1.1.1.2.2.5
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/02/09 10:56:20 $
d666 2
a667 11
	if (DATA_PTR(obj)) {
	    if (RANY(obj)->as.data.dfree == (void*)-1) {
		free(DATA_PTR(obj));
	    }
	    if (RANY(obj)->as.data.dfree) {
		(*RANY(obj)->as.data.dfree)(DATA_PTR(obj));
	    }
	    else {
		free(DATA_PTR(obj));
	    }
	}
@


1.1.1.2.2.6
log
@reserved words & etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:39 $
a990 1
    /* run finalizers */
a994 7
	    p++;
	}
    }
    /* run data object's finaliers */
    for (i = 0; i < heaps_used; i++) {
	p = heaps[i]; pend = p + HEAP_SLOTS;
	while (p < pend) {
@


1.1.1.2.2.7
log
@block arg etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/25 06:52:42 $
a263 3
    /* turn on premitive flag for the class */
    FL_SET(klass, FL_PRIMITIVE);

d373 1
a373 1
    if (obj->as.basic.flags & FL_MARK) return; /* already marked */
@


1.1.1.2.2.8
log
@gets speed up patch
@
text
@d6 1
a6 1
  $Date: 1998/03/05 06:37:44 $
d263 3
@


1.1.1.2.2.9
log
@1.1b9_02
@
text
@d6 1
a6 1
  $Date: 1998/03/11 07:32:55 $
a1018 4
    if (ptr == TRUE) return TRUE;
    if (ptr == FALSE) return FALSE;
    if (ptr == Qnil) return Qnil;

d1048 1
a1048 1
    rb_define_module_function(mObSpace, "_id2ref", id2ref, 1);
@


1.1.1.2.2.10
log
@1.1b9_09 pre
@
text
@d6 1
a6 1
  $Date: 1998/03/13 09:04:30 $
a51 1
#if 0
a55 1
#endif
@


1.1.1.2.2.11
log
@1.1b9_14
@
text
@d6 1
a6 1
  $Date: 1998/04/09 09:30:21 $
a420 5
	  case NODE_GASGN:
	  case NODE_LASGN:
	  case NODE_DASGN:
	  case NODE_IASGN:
	  case NODE_CASGN:
d655 1
a655 3
#define STR_NO_ORIG FL_USER3	/* copied from string.c */
	if (!RANY(obj)->as.string.orig && FL_TEST(obj, STR_NO_ORIG))
	    free(RANY(obj)->as.string.ptr);
@


1.1.1.2.2.12
log
@pack/unpack unsigned
@
text
@d6 1
a6 1
  $Date: 1998/04/22 08:57:29 $
d661 1
a661 1
	if (!RANY(obj)->as.string.orig || FL_TEST(obj, STR_NO_ORIG))
d1025 1
a1025 1
    INT ptr = NUM2UINT(id);
@


1.1.1.2.2.13
log
@no INT,UINT
@
text
@d6 1
a6 1
  $Date: 1998/05/08 09:38:07 $
d173 1
a173 1
	    unsigned long flag;	/* always 0 for freed obj */
d988 1
a988 1
    obj = INT2NUM((long)obj);	/* make obj into id */
d1025 1
a1025 1
    unsigned long ptr = NUM2UINT(id);
@


1.1.1.2.2.14
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/05/13 05:57:57 $
a20 3

void re_free_registers _((struct re_registers*));
void io_fptr_finalize _((struct OpenFile*));
@


1.1.1.2.2.15
log
@remove unused variables
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:16 $
d671 1
a671 2
	if (RANY(obj)->as.hash.tbl)
	    st_free_table(RANY(obj)->as.hash.tbl);
d674 2
a675 2
	if (RANY(obj)->as.regexp.ptr) reg_free(RANY(obj)->as.regexp.ptr);
	if (RANY(obj)->as.regexp.str) free(RANY(obj)->as.regexp.str);
d691 2
a692 4
	if (RANY(obj)->as.match.regs)
	    re_free_registers(RANY(obj)->as.match.regs);
	if (RANY(obj)->as.match.regs)
	    free(RANY(obj)->as.match.regs);
d695 2
a696 4
	if (RANY(obj)->as.file.fptr) {
	    io_fptr_finalize(RANY(obj)->as.file.fptr);
	    free(RANY(obj)->as.file.fptr);
	}
d726 1
a726 2
	if (RANY(obj)->as.rstruct.ptr)
	    free(RANY(obj)->as.rstruct.ptr);
@


1.1.1.2.2.16
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 04:57:36 $
d1049 2
@


1.1.1.2.2.17
log
@1.1b9_25
@
text
@d6 1
a6 1
  $Date: 1998/06/02 10:05:22 $
d50 1
a50 1
    int size;
a53 3
    if (size < 0) {
	ArgError("negative allocation size (or too big)");
    }
d74 1
a74 1
    int n, size;
d87 1
a87 1
    int size;
a90 3
    if (size < 0) {
	ArgError("negative re-allocation size");
    }
@


1.1.1.2.2.18
log
@baseline
@
text
@d6 1
a6 1
  $Date: 1998/06/11 10:03:02 $
d14 1
a14 1
#include "rubysig.h"
@


1.1.1.2.2.19
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/16 04:23:30 $
d962 2
@


1.1.1.2.2.20
log
@1.1b9_31
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:20 $
d40 1
a40 1
#define GC_MALLOC_LIMIT 100000
d42 1
a42 1
#define GC_MALLOC_LIMIT 200000
d58 1
d63 1
a97 4
    malloc_memories += size;
    if (malloc_memories > GC_MALLOC_LIMIT) {
	gc_gc();
    }
@


1.1.1.2.2.21
log
@1.1c0
@
text
@d6 1
a6 1
  $Date: 1998/07/15 06:12:49 $
a44 1
#define GC_NEWOBJ_LIMIT 1000
a46 1
static unsigned long alloc_objects = 0;
d59 1
a59 1
    if (malloc_memories > GC_MALLOC_LIMIT && alloc_objects > GC_NEWOBJ_LIMIT) {
d97 3
a255 1
	alloc_objects++;
a623 1
    alloc_objects = 0;
@


1.1.1.2.2.22
log
@rehash
@
text
@d6 1
a6 1
  $Date: 1998/07/17 05:12:40 $
d258 1
a258 1
    if (dont_gc || prohibit_interrupt) add_heap();
@


1.1.1.2.2.23
log
@1.1c1
@
text
@d6 1
a6 1
  $Date: 1998/07/22 03:00:41 $
d689 1
a689 1
	    if ((long)RANY(obj)->as.data.dfree == -1) {
@


1.1.1.2.2.24
log
@1.1c3
@
text
@d6 1
a6 1
  $Date: 1998/07/24 04:41:56 $
d611 1
a611 1
		if (p->as.basic.flags) obj_free((VALUE)p);
d1020 1
a1020 1
	    run_final((VALUE)p);
@


1.1.1.2.2.25
log
@1.1c4
@
text
@d6 1
a6 1
  $Date: 1998/08/27 03:55:14 $
d684 1
a684 1
	if (RANY(obj)->as.regexp.ptr) re_free_pattern(RANY(obj)->as.regexp.ptr);
@


1.1.1.2.2.26
log
@1.1c5
@
text
@d6 1
a6 1
  $Date: 1998/09/03 07:43:32 $
d692 1
a692 1
	    else if (RANY(obj)->as.data.dfree) {
d694 3
@


1.1.1.2.2.27
log
@1.1c7
@
text
@d6 1
a6 1
  $Date: 1998/09/08 09:17:38 $
a97 1
    if (size == 0) size = 1;
@


1.1.1.2.2.28
log
@1.2 stable
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:49 $
a32 1
#ifndef alloca
a34 1
#endif
d414 3
a471 7
#ifdef C_ALLOCA
	  case NODE_ALLOCA:
	    mark_locations_array((VALUE*)obj->as.node.u1.value,
				 obj->as.node.u3.cnt);
	    obj = RANY(obj->as.node.u2.node);
	    goto Top;
#endif
@


1.1.1.2.2.29
log
@1.2.1 stable
@
text
@d6 1
a6 1
  $Date: 1998/12/25 04:35:41 $
d595 1
a595 1
    int i, used = heaps_used;
d598 1
a598 1
	for (i = 0; i < used; i++) {
d609 2
a610 1
    for (i = 0; i < used; i++) {
d613 1
d620 2
a621 2
		p->as.free.next = freelist;
		freelist = p;
d629 1
d728 2
a729 11
	switch (nd_type(obj)) {
	  case NODE_SCOPE:
	    if (RANY(obj)->as.node.u1.tbl) {
		free(RANY(obj)->as.node.u1.tbl);
	    }
	    break;
#ifdef C_ALLOCA
	  case NODE_ALLOCA:
	    free(RANY(obj)->as.node.u1.value);
	    break;
#endif
@


1.1.1.2.2.25.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/09/03 07:43:32 $
d23 1
a23 1
void rb_io_fptr_finalize _((struct OpenFile*));
d57 1
a57 1
	rb_raise(rb_eArgError, "negative allocation size (or too big)");
d62 1
a62 1
	rb_gc();
d66 1
a66 1
	rb_gc();
d69 1
a69 1
	    rb_fatal("failed to allocate memory");
d95 1
a95 1
	rb_raise(rb_eArgError, "negative re-allocation size");
d101 1
a101 1
	rb_gc();
d104 1
a104 1
	    rb_fatal("failed to allocate memory(realloc)");
d143 2
a144 2
static VALUE
gc_enable()
d148 1
a148 1
    dont_gc = Qfalse;
d152 2
a153 2
static VALUE
gc_disable()
d157 1
a157 1
    dont_gc = Qtrue;
d161 1
a161 1
VALUE rb_mGC;
d228 1
a228 1
	if (heaps == 0) rb_fatal("can't alloc memory");
d232 1
a232 1
    if (p == 0) rb_fatal("add_heap: can't alloc memory");
d258 2
a259 2
    if (dont_gc || rb_prohibit_interrupt) add_heap();
    else rb_gc();
d265 1
a265 1
rb_data_object_alloc(klass, datap, dmark, dfree)
d281 1
a281 1
VALUE *rb_gc_stack_start;
d291 1
a291 1
    if (p < lomem || p > himem) return Qfalse;
d298 1
a298 1
	    return Qtrue;
d300 1
a300 1
    return Qfalse;
d310 1
a310 1
	    rb_gc_mark(*x);
d317 1
a317 1
rb_gc_mark_locations(start, end)
d337 1
a337 1
    rb_gc_mark(value);
d354 2
a355 2
    rb_gc_mark(key);
    rb_gc_mark(value);
d368 1
a368 1
rb_gc_mark_maybe(obj)
d372 1
a372 1
	rb_gc_mark(obj);
d377 1
a377 1
rb_gc_mark(ptr)
d393 1
a393 1
	rb_bug("rb_gc_mark() called for broken object");
d402 1
a402 1
	    rb_gc_mark(obj->as.node.u2.node);
d416 1
a416 1
	    rb_gc_mark(obj->as.node.u1.node);
d428 1
a428 1
	    rb_gc_mark(obj->as.node.u1.node);
d450 1
a450 1
	    rb_gc_mark(obj->as.node.u3.node);
d474 1
a474 1
		rb_gc_mark(obj->as.node.u1.node);
d477 1
a477 1
		rb_gc_mark(obj->as.node.u2.node);
d487 1
a487 1
    rb_gc_mark(obj->as.basic.klass);
d490 1
a490 1
	rb_gc_mark(obj->as.klass.super);
d497 1
a497 1
	rb_gc_mark(obj->as.klass.super);
d508 1
a508 1
		rb_gc_mark(*ptr++);
a513 1
	rb_gc_mark(obj->as.hash.ifnone);
d545 1
a545 1
	rb_gc_mark(obj->as.varmap.val);
d556 1
a556 1
		rb_gc_mark(*vars);
d568 1
a568 1
		rb_gc_mark(*ptr++);
d573 3
a575 3
	rb_bug("rb_gc_mark(): unknown data type 0x%x(0x%x) %s",
	       obj->as.basic.flags & T_MASK, obj,
	       looks_pointerp(obj)?"corrupted object":"non object");
a590 1
	/* sould not reclaim nodes during compilation */
d595 1
a595 1
		    rb_gc_mark(p);
d631 1
a631 1
rb_gc_force_recycle(p)
d650 1
a650 1
	rb_bug("obj_free() called for broken object");
d654 1
a654 1
    if (need_call_final && FL_TEST(obj, FL_FINALIZE)) {
d708 1
a708 1
	    rb_io_fptr_finalize(RANY(obj)->as.file.fptr);
d745 1
a745 2
	rb_bug("gc_sweep(): unknown data type %d",
	       RANY(obj)->as.basic.flags & T_MASK);
d750 1
a750 1
rb_gc_mark_frame(frame)
d757 1
a757 1
	rb_gc_mark_maybe(*tbl);
d760 1
a760 1
    rb_gc_mark(frame->cbase);
d799 1
a799 1
rb_gc()
d815 2
a816 2
    for (frame = ruby_frame; frame; frame = frame->prev) {
	rb_gc_mark_frame(frame);
d818 2
a819 2
    rb_gc_mark(ruby_scope);
    rb_gc_mark(ruby_dyna_vars);
d825 1
a825 1
    rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)&stack_end);
d831 1
a831 1
    rb_gc_mark_locations((VALUE*)((char*)rb_gc_stack_start + 2),
d836 1
a836 1
    rb_gc_mark_threads();
d841 1
a841 1
	rb_gc_mark(*list->varptr);
d844 1
a844 1
    rb_gc_mark_global_tbl();
d846 1
a846 1
    rb_gc_mark_trap_list();
d853 1
a853 1
gc_start()
d855 1
a855 1
    rb_gc();
d860 1
a860 1
Init_stack()
d868 1
a868 1
    rb_gc_stack_start = &start;
d873 1
a873 1
Init_heap()
d875 1
a875 1
    Init_stack();
d932 1
a932 1
		    if (rb_obj_is_kind_of((VALUE)p, of)) {
d965 3
a967 3
    if (!rb_obj_is_kind_of(proc, rb_cProc)) {
	rb_raise(rb_eArgError, "wrong type argument %s (Proc required)",
		 rb_class2name(CLASS_OF(proc)));
d969 1
a969 1
    rb_ary_push(finalizers, proc);
d977 1
a977 1
    rb_ary_delete(finalizers, proc);
d1002 2
d1006 1
a1006 1
	rb_eval_cmd(RARRAY(finalizers)->ptr[i], rb_ary_new3(1,obj));
d1011 1
a1011 1
rb_gc_call_finalizer_at_exit()
d1020 1
a1020 2
	    if (FL_TEST(p, FL_FINALIZE))
		run_final((VALUE)p);
d1044 2
a1045 2
    if (ptr == Qtrue) return Qtrue;
    if (ptr == Qfalse) return Qfalse;
d1049 1
a1049 1
	rb_raise(rb_eIndexError, "0x%x is not the id value", ptr);
d1052 1
a1052 1
	rb_raise(rb_eIndexError, "0x%x is recycled object", ptr);
d1060 1
a1060 1
    VALUE rb_mObSpace;
d1062 14
a1075 14
    rb_mGC = rb_define_module("GC");
    rb_define_singleton_method(rb_mGC, "start", gc_start, 0);
    rb_define_singleton_method(rb_mGC, "enable", gc_enable, 0);
    rb_define_singleton_method(rb_mGC, "disable", gc_disable, 0);
    rb_define_method(rb_mGC, "garbage_collect", gc_start, 0);

    rb_mObSpace = rb_define_module("ObjectSpace");
    rb_define_module_function(rb_mObSpace, "each_object", os_each_obj, -1);
    rb_define_module_function(rb_mObSpace, "garbage_collect", gc_start, 0);
    rb_define_module_function(rb_mObSpace, "add_finalizer", add_final, 1);
    rb_define_module_function(rb_mObSpace, "remove_finalizer", rm_final, 1);
    rb_define_module_function(rb_mObSpace, "finalizers", finals, 0);
    rb_define_module_function(rb_mObSpace, "call_finalizer", call_final, 1);
    rb_define_module_function(rb_mObSpace, "_id2ref", id2ref, 1);
d1078 1
a1078 1
    finalizers = rb_ary_new();
@


1.1.1.2.2.25.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/09/08 09:17:38 $
a12 1
#define RUBY_NO_INLINE
d305 2
a306 2
    register VALUE *x;
    register long n;
a401 3
	  case NODE_WHEN:
	  case NODE_MASGN:
	  case NODE_RESBODY:
a411 1
	  case NODE_ENSURE:
a412 2
	  case NODE_DEFS:
	  case NODE_OP_ASGN1:
a419 1
	  case NODE_DEFN:
a425 9
	  case NODE_AND:
	  case NODE_OR:
	  case NODE_CASE:
	  case NODE_RESCUE:
	  case NODE_ARGS:
	  case NODE_DOT2:
	  case NODE_DOT3:
	  case NODE_FLIP2:
	  case NODE_FLIP3:
a427 1
	  case NODE_SCLASS:
a430 1
	  case NODE_MODULE:
a434 1
	  case NODE_DASGN_PUSH:
a436 5
	  case NODE_OP_ASGN_OR:
	  case NODE_OP_ASGN_AND:
	  case NODE_COLON3:
	  case NODE_OPT_N:
	  case NODE_BLOCK_PASS:
a445 3
	  case NODE_RETURN:
	  case NODE_YIELD:
	  case NODE_COLON2:
a449 1
	  case NODE_CLASS:
a454 1
	  case NODE_ZSUPER:
a465 4
	  case NODE_BREAK:
	  case NODE_NEXT:
	  case NODE_REDO:
	  case NODE_RETRY:
a468 4
	  case NODE_TRUE:
	  case NODE_FALSE:
	  case NODE_ATTRSET:
	  case NODE_BLOCK_ARG:
d490 5
d694 1
a694 1
	    else if (RANY(obj)->as.data.dfree) {
d697 3
d756 7
a762 1
    mark_locations_array(frame->argv, frame->argc);
d838 1
a838 1
#ifdef USE_THREAD
@


1.1.1.2.2.25.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:49 $
a98 1
    if (size == 0) size = 1;
a283 3
#if defined(__GNUC__) && __GNUC__ >= 2
__inline__
#endif
a404 1
	  case NODE_RESCUE:
d437 1
a437 1
	  case NODE_SCLASS:
d445 1
d449 1
a456 1
	  case NODE_MODULE:
d461 1
a478 1
	  case NODE_BLOCK_PASS:
d1031 1
a1031 1
	rb_eval_cmd(RARRAY(finalizers)->ptr[i], rb_ary_new3(1, obj));
@


1.1.1.2.2.25.2.4
log
@first public release of 1.1d (pre1.2) series
@
text
@d6 1
a6 1
  $Date: 1998/11/25 03:31:13 $
a394 4
    if (FL_TEST(obj, FL_EXIVAR)) {
	return rb_mark_generic_ivar((VALUE)obj);
    }

d619 1
a619 1
static void obj_free _((VALUE));
a695 4
    if (FL_TEST(obj, FL_EXIVAR)) {
	rb_free_generic_ivar((VALUE)obj);
    }

d874 1
a875 1

a878 3
    /* mark generic instance variables for special constants */
    rb_mark_generic_ivar_tbl();

a1072 1
    rb_secure(4);
@
