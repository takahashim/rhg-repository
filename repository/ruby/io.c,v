head	1.167;
access;
symbols
	v1_6_7:1.69.2.21
	v1_6_6:1.69.2.16
	v1_6_5:1.69.2.12
	v1_6_4:1.69.2.8
	v1_7_1:1.86
	v1_6_4_preview4:1.69.2.8
	v1_6_4_preview3:1.69.2.8
	v1_6_4_preview2:1.69.2.8
	v1_6_4_preview1:1.69.2.6
	v1_6_3:1.69.2.4
	ruby_m17n:1.71.0.2
	ruby_1_6:1.69.0.2
	v1_6_2:1.69
	v1_6_1:1.59
	v1_6_0:1.57
	v1_4_6:1.5.2.18
	v1_4_5:1.5.2.17
	v1_4_4:1.5.2.10
	ruby_1_4_3:1.5.2.5
	ruby1_4_3:1.5.2.5
	v1_4_3:1.5.2.5
	v1_5_0:1.11
	ruby_1_4_3_pre1:1.5.2.5
	ruby_1_4:1.5.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.25
	v1_3_6_repack:1.1.1.3.2.24
	v1_3_6:1.1.1.3.2.24
	v1_3_5:1.1.1.3.2.22
	v1_2_6repack:1.1.1.2.2.55
	v1_3_4_990625:1.1.1.3.2.21
	v1_3_4_990624:1.1.1.3.2.21
	v1_2_6:1.1.1.2.2.55
	v1_3_4_990611:1.1.1.3.2.20
	v1_3_4_990531:1.1.1.3.2.18
	v1_3_3_990518:1.1.1.3.2.16
	v1_3_3_990513:1.1.1.3.2.15
	v1_3_3_990507:1.1.1.3.2.14
	v1_2_5:1.1.1.2.2.53
	v1_2_4:1.1.1.2.2.51
	v1_3_1_990225:1.1.1.3.2.8
	v1_3_1_990224:1.1.1.3.2.7
	v1_3_1_990215:1.1.1.3.2.6
	v1_3_1_990212:1.1.1.3.2.5
	v1_3_1_990210:1.1.1.3.2.4
	v1_3_1_:1.1.1.3.2.4
	v1_3_1_990209:1.1.1.3.2.3
	v1_3_1_990205:1.1.1.3.2.2
	v1_3_1_990203:1.1.1.3.2.2
	v1_3_1_990201:1.1.1.3.2.2
	v1_3_1"_990201:1.1.1.3.2.2
	v1_3_1_990128:1.1.1.3.2.2
	v1_3_1_990127:1.1.1.3.2.1
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.50
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.50
	v1_2_1repack:1.1.1.2.2.50
	v1_2_1:1.1.1.2.2.50
	v1_2_stable:1.1.1.2.2.50
	v1_1d1:1.1.1.2.2.47.2.5
	v1_1d0:1.1.1.2.2.47.2.4
	v1_1c9_1:1.1.1.2.2.50
	v1_1c9:1.1.1.2.2.50
	v1_1c8:1.1.1.2.2.49
	v1_1c7:1.1.1.2.2.49
	v1_1c6:1.1.1.2.2.48
	v1_1d-start:1.1.1.2.2.47.2.1
	v1_1c5:1.1.1.2.2.47
	v1_1dev:1.1.1.2.2.47.0.2
	v1_1c4:1.1.1.2.2.47
	v1_1c3:1.1.1.2.2.47
	v1_1c2:1.1.1.2.2.45
	v1_1c1:1.1.1.2.2.45
	v1_1c0:1.1.1.2.2.43
	v1_1b9_31:1.1.1.2.2.43
	v1_1b9_30:1.1.1.2.2.42
	v1_1b9_28:1.1.1.2.2.41
	v1_1b9_27:1.1.1.2.2.39
	v1_1b9_26:1.1.1.2.2.39
	r1_1b9_25:1.1.1.2.2.37
	r1_1b9_24:1.1.1.2.2.36
	v1_1b9_23:1.1.1.2.2.35
	v1_1b9_22:1.1.1.2.2.33
	v1_1b9_20:1.1.1.2.2.32
	v1_1b9_18:1.1.1.2.2.29
	v1_1b9_16:1.1.1.2.2.27
	v1_1b9_15:1.1.1.2.2.26
	v1_1b9_13:1.1.1.2.2.25
	v1_1b9_12:1.1.1.2.2.24
	v1_1b9_11:1.1.1.2.2.24
	v1_1b9_08:1.1.1.2.2.21
	v1_1b9_07:1.1.1.2.2.21
	r1_1b9:1.1.1.2.2.7
	v1_1b8:1.1.1.2.2.6
	v1_1b7:1.1.1.2.2.6
	v1_1b6:1.1.1.2.2.3
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.167
date	2002.10.29.21.35.28;	author knu;	state Exp;
branches;
next	1.166;

1.166
date	2002.10.27.09.04.55;	author eban;	state Exp;
branches;
next	1.165;

1.165
date	2002.10.09.06.12.54;	author nobu;	state Exp;
branches;
next	1.164;

1.164
date	2002.10.08.05.34.45;	author nobu;	state Exp;
branches;
next	1.163;

1.163
date	2002.10.02.14.59.25;	author nobu;	state Exp;
branches;
next	1.162;

1.162
date	2002.10.02.14.13.58;	author nobu;	state Exp;
branches;
next	1.161;

1.161
date	2002.09.30.11.31.28;	author nobu;	state Exp;
branches;
next	1.160;

1.160
date	2002.09.25.07.03.01;	author matz;	state Exp;
branches;
next	1.159;

1.159
date	2002.09.17.13.52.45;	author michal;	state Exp;
branches;
next	1.158;

1.158
date	2002.09.16.15.56.31;	author aamine;	state Exp;
branches;
next	1.157;

1.157
date	2002.09.11.01.09.04;	author nobu;	state Exp;
branches;
next	1.156;

1.156
date	2002.09.06.01.58.32;	author aamine;	state Exp;
branches;
next	1.155;

1.155
date	2002.09.03.05.20.06;	author matz;	state Exp;
branches;
next	1.154;

1.154
date	2002.09.02.08.05.39;	author michal;	state Exp;
branches;
next	1.153;

1.153
date	2002.08.29.04.38.37;	author eban;	state Exp;
branches;
next	1.152;

1.152
date	2002.08.28.14.36.38;	author nobu;	state Exp;
branches;
next	1.151;

1.151
date	2002.08.28.09.41.58;	author nobu;	state Exp;
branches;
next	1.150;

1.150
date	2002.08.28.08.05.23;	author michal;	state Exp;
branches;
next	1.149;

1.149
date	2002.08.27.08.31.06;	author matz;	state Exp;
branches;
next	1.148;

1.148
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.147;

1.147
date	2002.08.21.08.30.05;	author matz;	state Exp;
branches;
next	1.146;

1.146
date	2002.08.20.13.03.22;	author H_Konishi;	state Exp;
branches;
next	1.145;

1.145
date	2002.08.20.07.36.01;	author matz;	state Exp;
branches;
next	1.144;

1.144
date	2002.08.16.07.23.04;	author eban;	state Exp;
branches;
next	1.143;

1.143
date	2002.08.16.02.52.25;	author nobu;	state Exp;
branches;
next	1.142;

1.142
date	2002.06.28.18.26.00;	author usa;	state Exp;
branches;
next	1.141;

1.141
date	2002.06.11.01.27.46;	author H_Konishi;	state Exp;
branches;
next	1.140;

1.140
date	2002.05.29.05.20.33;	author matz;	state Exp;
branches;
next	1.139;

1.139
date	2002.05.23.05.35.26;	author matz;	state Exp;
branches;
next	1.138;

1.138
date	2002.05.20.04.33.59;	author nobu;	state Exp;
branches;
next	1.137;

1.137
date	2002.05.02.07.50.36;	author matz;	state Exp;
branches;
next	1.136;

1.136
date	2002.04.24.04.54.13;	author matz;	state Exp;
branches;
next	1.135;

1.135
date	2002.04.18.08.46.18;	author matz;	state Exp;
branches;
next	1.134;

1.134
date	2002.04.15.07.48.45;	author matz;	state Exp;
branches;
next	1.133;

1.133
date	2002.04.12.08.45.02;	author matz;	state Exp;
branches;
next	1.132;

1.132
date	2002.04.11.10.11.53;	author eban;	state Exp;
branches;
next	1.131;

1.131
date	2002.04.02.06.48.41;	author matz;	state Exp;
branches;
next	1.130;

1.130
date	2002.04.01.08.31.45;	author matz;	state Exp;
branches;
next	1.129;

1.129
date	2002.04.01.07.39.09;	author matz;	state Exp;
branches;
next	1.128;

1.128
date	2002.03.29.14.50.09;	author matz;	state Exp;
branches;
next	1.127;

1.127
date	2002.03.28.09.17.51;	author matz;	state Exp;
branches;
next	1.126;

1.126
date	2002.03.27.05.55.01;	author eban;	state Exp;
branches;
next	1.125;

1.125
date	2002.03.27.05.52.36;	author nobu;	state Exp;
branches;
next	1.124;

1.124
date	2002.03.27.05.27.57;	author matz;	state Exp;
branches;
next	1.123;

1.123
date	2002.03.25.14.50.40;	author nobu;	state Exp;
branches;
next	1.122;

1.122
date	2002.03.25.06.18.04;	author matz;	state Exp;
branches;
next	1.121;

1.121
date	2002.03.22.07.26.35;	author matz;	state Exp;
branches;
next	1.120;

1.120
date	2002.03.14.06.23.44;	author matz;	state Exp;
branches;
next	1.119;

1.119
date	2002.02.27.04.29.10;	author eban;	state Exp;
branches;
next	1.118;

1.118
date	2002.02.22.10.28.45;	author matz;	state Exp;
branches;
next	1.117;

1.117
date	2002.02.20.06.33.24;	author nobu;	state Exp;
branches;
next	1.116;

1.116
date	2002.02.20.04.42.49;	author usa;	state Exp;
branches;
next	1.115;

1.115
date	2002.02.20.04.31.50;	author matz;	state Exp;
branches;
next	1.114;

1.114
date	2002.02.19.04.19.06;	author nobu;	state Exp;
branches;
next	1.113;

1.113
date	2002.02.07.04.18.08;	author matz;	state Exp;
branches;
next	1.112;

1.112
date	2002.02.06.07.30.13;	author matz;	state Exp;
branches;
next	1.111;

1.111
date	2002.02.05.17.10.54;	author nobu;	state Exp;
branches;
next	1.110;

1.110
date	2002.02.05.07.56.29;	author matz;	state Exp;
branches;
next	1.109;

1.109
date	2002.01.23.07.30.39;	author matz;	state Exp;
branches;
next	1.108;

1.108
date	2002.01.21.07.44.05;	author matz;	state Exp;
branches;
next	1.107;

1.107
date	2002.01.18.14.23.06;	author matz;	state Exp;
branches;
next	1.106;

1.106
date	2002.01.11.09.18.50;	author matz;	state Exp;
branches;
next	1.105;

1.105
date	2002.01.04.14.14.34;	author matz;	state Exp;
branches;
next	1.104;

1.104
date	2001.12.21.09.23.21;	author matz;	state Exp;
branches;
next	1.103;

1.103
date	2001.12.19.07.48.30;	author matz;	state Exp;
branches;
next	1.102;

1.102
date	2001.12.17.07.52.35;	author nobu;	state Exp;
branches;
next	1.101;

1.101
date	2001.12.10.07.18.12;	author matz;	state Exp;
branches;
next	1.100;

1.100
date	2001.11.19.05.03.03;	author matz;	state Exp;
branches;
next	1.99;

1.99
date	2001.10.30.08.43.25;	author matz;	state Exp;
branches;
next	1.98;

1.98
date	2001.10.29.05.07.18;	author matz;	state Exp;
branches;
next	1.97;

1.97
date	2001.10.16.03.27.06;	author matz;	state Exp;
branches;
next	1.96;

1.96
date	2001.10.03.07.19.10;	author matz;	state Exp;
branches;
next	1.95;

1.95
date	2001.09.05.06.54.53;	author matz;	state Exp;
branches;
next	1.94;

1.94
date	2001.09.03.05.37.42;	author matz;	state Exp;
branches;
next	1.93;

1.93
date	2001.08.23.06.02.15;	author matz;	state Exp;
branches;
next	1.92;

1.92
date	2001.08.06.03.05.13;	author matz;	state Exp;
branches;
next	1.91;

1.91
date	2001.07.24.09.07.33;	author matz;	state Exp;
branches;
next	1.90;

1.90
date	2001.07.14.15.17.18;	author matz;	state Exp;
branches;
next	1.89;

1.89
date	2001.06.22.09.12.19;	author matz;	state Exp;
branches;
next	1.88;

1.88
date	2001.06.19.04.35.13;	author matz;	state Exp;
branches;
next	1.87;

1.87
date	2001.06.05.07.19.38;	author matz;	state Exp;
branches;
next	1.86;

1.86
date	2001.05.30.09.12.34;	author matz;	state Exp;
branches;
next	1.85;

1.85
date	2001.05.16.09.05.50;	author matz;	state Exp;
branches;
next	1.84;

1.84
date	2001.05.06.15.01.59;	author matz;	state Exp;
branches;
next	1.83;

1.83
date	2001.05.02.04.22.11;	author matz;	state Exp;
branches;
next	1.82;

1.82
date	2001.03.28.08.43.24;	author matz;	state Exp;
branches;
next	1.81;

1.81
date	2001.03.26.08.57.10;	author matz;	state Exp;
branches;
next	1.80;

1.80
date	2001.03.13.09.00.01;	author matz;	state Exp;
branches;
next	1.79;

1.79
date	2001.03.13.05.45.09;	author matz;	state Exp;
branches;
next	1.78;

1.78
date	2001.02.26.05.29.00;	author matz;	state Exp;
branches;
next	1.77;

1.77
date	2001.02.16.07.53.19;	author matz;	state Exp;
branches;
next	1.76;

1.76
date	2001.02.13.05.08.59;	author matz;	state Exp;
branches;
next	1.75;

1.75
date	2001.02.02.11.38.10;	author matz;	state Exp;
branches;
next	1.74;

1.74
date	2001.01.29.05.10.42;	author matz;	state Exp;
branches;
next	1.73;

1.73
date	2001.01.18.08.43.07;	author matz;	state Exp;
branches;
next	1.72;

1.72
date	2001.01.15.07.00.54;	author matz;	state Exp;
branches;
next	1.71;

1.71
date	2000.12.26.08.32.35;	author matz;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2000.12.26.08.08.50;	author matz;	state Exp;
branches;
next	1.69;

1.69
date	2000.12.22.03.22.01;	author matz;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2000.12.12.07.42.23;	author matz;	state Exp;
branches;
next	1.67;

1.67
date	2000.11.27.09.23.21;	author matz;	state Exp;
branches;
next	1.66;

1.66
date	2000.11.20.07.31.42;	author matz;	state Exp;
branches;
next	1.65;

1.65
date	2000.11.17.04.41.11;	author matz;	state Exp;
branches;
next	1.64;

1.64
date	2000.11.16.16.56.57;	author matz;	state Exp;
branches;
next	1.63;

1.63
date	2000.11.13.10.11.27;	author eban;	state Exp;
branches;
next	1.62;

1.62
date	2000.11.13.05.39.32;	author matz;	state Exp;
branches;
next	1.61;

1.61
date	2000.11.10.07.16.49;	author matz;	state Exp;
branches;
next	1.60;

1.60
date	2000.11.08.05.29.23;	author matz;	state Exp;
branches;
next	1.59;

1.59
date	2000.09.21.09.30.55;	author matz;	state Exp;
branches;
next	1.58;

1.58
date	2000.09.04.08.24.01;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2000.08.30.05.20.36;	author matz;	state Exp;
branches;
next	1.56;

1.56
date	2000.08.25.08.26.02;	author matz;	state Exp;
branches;
next	1.55;

1.55
date	2000.08.15.06.22.40;	author matz;	state Exp;
branches;
next	1.54;

1.54
date	2000.08.09.07.35.01;	author matz;	state Exp;
branches;
next	1.53;

1.53
date	2000.08.07.05.01.53;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2000.07.27.09.49.19;	author matz;	state Exp;
branches;
next	1.51;

1.51
date	2000.07.25.07.21.49;	author matz;	state Exp;
branches;
next	1.50;

1.50
date	2000.07.17.09.38.00;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2000.07.14.07.18.57;	author matz;	state Exp;
branches;
next	1.48;

1.48
date	2000.07.10.06.47.04;	author eban;	state Exp;
branches;
next	1.47;

1.47
date	2000.07.10.06.30.11;	author eban;	state Exp;
branches;
next	1.46;

1.46
date	2000.07.06.09.18.54;	author matz;	state Exp;
branches;
next	1.45;

1.45
date	2000.07.06.07.21.08;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2000.07.04.04.17.11;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2000.06.19.08.38.07;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2000.06.16.07.44.02;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2000.06.14.08.08.48;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2000.06.14.05.30.21;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2000.06.13.09.42.39;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2000.06.13.02.50.34;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.12.07.48.20;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.05.08.46.49;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2000.05.25.05.55.03;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2000.05.24.04.34.01;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2000.05.17.04.38.13;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2000.05.16.15.50.46;	author eban;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.16.02.46.55;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.15.06.38.42;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.05.13.16.12.16;	author eban;	state Exp;
branches;
next	1.28;

1.28
date	2000.05.12.09.07.41;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.05.10.02.58.34;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.05.09.04.52.59;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.01.09.41.20;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.10.05.44.13;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.23.08.37.27;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.07.08.37.37;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.29.08.05.25;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.18.06.59.30;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.17.07.11.11;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.08.08.48.50;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.02.01.03.18.02;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.01.03.12.05;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.17.08.37.42;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.08.05.00.18;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.05.04.37.04;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	99.12.14.06.49.45;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	99.11.25.09.03.05;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	99.11.17.07.30.30;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	99.11.04.08.39.37;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.10.29.09.25.31;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.10.16.10.33.06;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.10.13.06.44.41;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.09.22.04.30.09;	author matz;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.09.20.07.14.18;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.08.24.08.21.53;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.06;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.10;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.24;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.12;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.01.28.07.55.30;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.09.06.08.21;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.02.10.08.44.25;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.02.12.11.17.03;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.02.15.07.31.51;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.02.24.04.31.20;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.02.25.06.39.07;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.03.24.08.52.29;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.04.09.17.57.39;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.04.16.06.03.31;	author matz;	state Exp;
branches;
next	1.1.1.3.2.12;

1.1.1.3.2.12
date	99.04.20.08.21.36;	author matz;	state Exp;
branches;
next	1.1.1.3.2.13;

1.1.1.3.2.13
date	99.04.26.09.42.31;	author matz;	state Exp;
branches;
next	1.1.1.3.2.14;

1.1.1.3.2.14
date	99.05.06.08.31.30;	author matz;	state Exp;
branches;
next	1.1.1.3.2.15;

1.1.1.3.2.15
date	99.05.12.05.27.32;	author matz;	state Exp;
branches;
next	1.1.1.3.2.16;

1.1.1.3.2.16
date	99.05.18.06.06.12;	author matz;	state Exp;
branches;
next	1.1.1.3.2.17;

1.1.1.3.2.17
date	99.05.25.07.28.31;	author matz;	state Exp;
branches;
next	1.1.1.3.2.18;

1.1.1.3.2.18
date	99.05.31.09.13.11;	author matz;	state Exp;
branches;
next	1.1.1.3.2.19;

1.1.1.3.2.19
date	99.06.09.09.21.14;	author matz;	state Exp;
branches;
next	1.1.1.3.2.20;

1.1.1.3.2.20
date	99.06.11.06.29.54;	author matz;	state Exp;
branches;
next	1.1.1.3.2.21;

1.1.1.3.2.21
date	99.06.24.04.23.55;	author matz;	state Exp;
branches;
next	1.1.1.3.2.22;

1.1.1.3.2.22
date	99.07.15.07.59.46;	author matz;	state Exp;
branches;
next	1.1.1.3.2.23;

1.1.1.3.2.23
date	99.07.22.10.37.16;	author matz;	state Exp;
branches;
next	1.1.1.3.2.24;

1.1.1.3.2.24
date	99.07.28.09.26.41;	author matz;	state Exp;
branches;
next	1.1.1.3.2.25;

1.1.1.3.2.25
date	99.08.06.06.48.19;	author matz;	state Exp;
branches;
next	1.1.1.3.2.26;

1.1.1.3.2.26
date	99.08.10.08.47.16;	author matz;	state Exp;
branches;
next	1.1.1.3.2.27;

1.1.1.3.2.27
date	99.08.13.05.17.39;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.19.05.22.20;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.01.19.05.37.15;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.01.29.08.18.02;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.02.02.04.49.12;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.02.09.10.56.21;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.02.23.05.36.37;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.03.03.10.16.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.03.05.06.37.45;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.03.11.07.32.57;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.03.12.01.15.16;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.03.13.09.04.30;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.03.16.06.00.12;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.03.16.06.37.12;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.03.17.10.06.57;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.03.23.09.49.16;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.03.25.09.36.58;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.03.28.10.57.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.03.28.11.05.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.03.30.09.32.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.04.02.10.03.50;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.04.14.04.55.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.04.16.07.42.43;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.04.16.10.41.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	98.04.21.08.37.03;	author matz;	state Exp;
branches;
next	1.1.1.2.2.26;

1.1.1.2.2.26
date	98.04.23.06.53.17;	author matz;	state Exp;
branches;
next	1.1.1.2.2.27;

1.1.1.2.2.27
date	98.04.27.10.03.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.28;

1.1.1.2.2.28
date	98.05.01.08.56.32;	author matz;	state Exp;
branches;
next	1.1.1.2.2.29;

1.1.1.2.2.29
date	98.05.12.08.38.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.30;

1.1.1.2.2.30
date	98.05.13.05.57.59;	author matz;	state Exp;
branches;
next	1.1.1.2.2.31;

1.1.1.2.2.31
date	98.05.13.07.26.20;	author matz;	state Exp;
branches;
next	1.1.1.2.2.32;

1.1.1.2.2.32
date	98.05.15.05.43.21;	author matz;	state Exp;
branches;
next	1.1.1.2.2.33;

1.1.1.2.2.33
date	98.05.18.04.56.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.34;

1.1.1.2.2.34
date	98.05.25.04.57.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.35;

1.1.1.2.2.35
date	98.05.25.09.42.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.36;

1.1.1.2.2.36
date	98.06.02.10.05.23;	author matz;	state Exp;
branches;
next	1.1.1.2.2.37;

1.1.1.2.2.37
date	98.06.11.10.03.04;	author matz;	state Exp;
branches;
next	1.1.1.2.2.38;

1.1.1.2.2.38
date	98.06.16.04.23.33;	author matz;	state Exp;
branches;
next	1.1.1.2.2.39;

1.1.1.2.2.39
date	98.06.18.07.46.50;	author matz;	state Exp;
branches;
next	1.1.1.2.2.40;

1.1.1.2.2.40
date	98.06.24.04.37.59;	author matz;	state Exp;
branches;
next	1.1.1.2.2.41;

1.1.1.2.2.41
date	98.06.26.09.44.25;	author matz;	state Exp;
branches;
next	1.1.1.2.2.42;

1.1.1.2.2.42
date	98.07.03.07.06.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.43;

1.1.1.2.2.43
date	98.07.13.04.37.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.44;

1.1.1.2.2.44
date	98.07.22.03.00.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.45;

1.1.1.2.2.45
date	98.07.24.04.41.57;	author matz;	state Exp;
branches;
next	1.1.1.2.2.46;

1.1.1.2.2.46
date	98.08.11.04.06.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.47;

1.1.1.2.2.47
date	98.08.27.03.55.18;	author matz;	state Exp;
branches
	1.1.1.2.2.47.2.1;
next	1.1.1.2.2.48;

1.1.1.2.2.48
date	98.10.06.02.44.58;	author matz;	state Exp;
branches;
next	1.1.1.2.2.49;

1.1.1.2.2.49
date	98.11.09.09.11.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.50;

1.1.1.2.2.50
date	98.11.26.08.25.44;	author matz;	state Exp;
branches;
next	1.1.1.2.2.51;

1.1.1.2.2.51
date	99.04.08.10.14.32;	author matz;	state Exp;
branches;
next	1.1.1.2.2.52;

1.1.1.2.2.52
date	99.04.09.18.04.07;	author matz;	state Exp;
branches;
next	1.1.1.2.2.53;

1.1.1.2.2.53
date	99.04.13.05.54.23;	author matz;	state Exp;
branches;
next	1.1.1.2.2.54;

1.1.1.2.2.54
date	99.04.20.08.20.54;	author matz;	state Exp;
branches;
next	1.1.1.2.2.55;

1.1.1.2.2.55
date	99.06.21.06.31.03;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.47.2.1
date	98.09.08.07.08.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.47.2.2;

1.1.1.2.2.47.2.2
date	98.10.06.03.28.11;	author matz;	state Exp;
branches;
next	1.1.1.2.2.47.2.3;

1.1.1.2.2.47.2.3
date	98.11.25.03.31.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.47.2.4;

1.1.1.2.2.47.2.4
date	98.12.16.07.30.31;	author matz;	state Exp;
branches;
next	1.1.1.2.2.47.2.5;

1.1.1.2.2.47.2.5
date	98.12.22.09.01.51;	author matz;	state Exp;
branches;
next	;

1.5.2.1
date	99.10.13.03.42.12;	author matz;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	99.10.18.09.03.16;	author matz;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	99.10.25.05.09.12;	author matz;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	99.11.04.08.39.55;	author matz;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	99.11.24.07.13.51;	author matz;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	99.12.14.06.50.38;	author matz;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2000.01.05.04.41.07;	author matz;	state Exp;
branches;
next	1.5.2.8;

1.5.2.8
date	2000.01.17.08.24.02;	author matz;	state Exp;
branches;
next	1.5.2.9;

1.5.2.9
date	2000.02.08.08.53.51;	author matz;	state Exp;
branches;
next	1.5.2.10;

1.5.2.10
date	2000.02.17.08.28.55;	author matz;	state Exp;
branches;
next	1.5.2.11;

1.5.2.11
date	2000.04.10.05.48.36;	author matz;	state Exp;
branches;
next	1.5.2.12;

1.5.2.12
date	2000.04.17.06.24.43;	author matz;	state Exp;
branches;
next	1.5.2.13;

1.5.2.13
date	2000.05.01.09.42.26;	author matz;	state Exp;
branches;
next	1.5.2.14;

1.5.2.14
date	2000.06.05.09.00.55;	author matz;	state Exp;
branches;
next	1.5.2.15;

1.5.2.15
date	2000.06.13.09.50.47;	author matz;	state Exp;
branches;
next	1.5.2.16;

1.5.2.16
date	2000.06.14.04.19.20;	author eban;	state Exp;
branches;
next	1.5.2.17;

1.5.2.17
date	2000.06.20.06.08.38;	author matz;	state Exp;
branches;
next	1.5.2.18;

1.5.2.18
date	2000.07.24.07.16.08;	author matz;	state Exp;
branches;
next	1.5.2.19;

1.5.2.19
date	2000.08.15.08.57.48;	author matz;	state Exp;
branches;
next	1.5.2.20;

1.5.2.20
date	2000.08.28.03.12.07;	author matz;	state Exp;
branches;
next	1.5.2.21;

1.5.2.21
date	2000.09.12.05.33.04;	author matz;	state Exp;
branches;
next	;

1.69.2.1
date	2000.12.28.04.45.15;	author matz;	state Exp;
branches;
next	1.69.2.2;

1.69.2.2
date	2001.01.15.07.33.12;	author matz;	state Exp;
branches;
next	1.69.2.3;

1.69.2.3
date	2001.02.16.08.06.26;	author matz;	state Exp;
branches;
next	1.69.2.4;

1.69.2.4
date	2001.03.13.05.48.33;	author matz;	state Exp;
branches;
next	1.69.2.5;

1.69.2.5
date	2001.03.28.08.44.37;	author matz;	state Exp;
branches;
next	1.69.2.6;

1.69.2.6
date	2001.04.10.06.09.00;	author matz;	state Exp;
branches;
next	1.69.2.7;

1.69.2.7
date	2001.04.16.06.54.36;	author matz;	state Exp;
branches;
next	1.69.2.8;

1.69.2.8
date	2001.04.17.08.26.13;	author matz;	state Exp;
branches;
next	1.69.2.9;

1.69.2.9
date	2001.06.05.06.40.50;	author matz;	state Exp;
branches;
next	1.69.2.10;

1.69.2.10
date	2001.06.19.04.36.34;	author matz;	state Exp;
branches;
next	1.69.2.11;

1.69.2.11
date	2001.09.03.05.29.18;	author matz;	state Exp;
branches;
next	1.69.2.12;

1.69.2.12
date	2001.09.05.06.53.27;	author matz;	state Exp;
branches;
next	1.69.2.13;

1.69.2.13
date	2001.12.04.04.53.31;	author matz;	state Exp;
branches;
next	1.69.2.14;

1.69.2.14
date	2001.12.17.08.13.17;	author nobu;	state Exp;
branches;
next	1.69.2.15;

1.69.2.15
date	2001.12.18.08.40.31;	author matz;	state Exp;
branches;
next	1.69.2.16;

1.69.2.16
date	2001.12.21.09.20.53;	author matz;	state Exp;
branches;
next	1.69.2.17;

1.69.2.17
date	2002.01.04.14.19.47;	author matz;	state Exp;
branches;
next	1.69.2.18;

1.69.2.18
date	2002.01.21.07.43.40;	author matz;	state Exp;
branches;
next	1.69.2.19;

1.69.2.19
date	2002.02.19.04.18.38;	author nobu;	state Exp;
branches;
next	1.69.2.20;

1.69.2.20
date	2002.02.20.06.35.37;	author nobu;	state Exp;
branches;
next	1.69.2.21;

1.69.2.21
date	2002.02.27.04.30.19;	author eban;	state Exp;
branches;
next	1.69.2.22;

1.69.2.22
date	2002.03.25.06.15.59;	author matz;	state Exp;
branches;
next	1.69.2.23;

1.69.2.23
date	2002.03.27.05.41.18;	author eban;	state Exp;
branches;
next	1.69.2.24;

1.69.2.24
date	2002.04.11.09.46.53;	author eban;	state Exp;
branches;
next	1.69.2.25;

1.69.2.25
date	2002.05.01.09.37.58;	author matz;	state Exp;
branches;
next	1.69.2.26;

1.69.2.26
date	2002.05.14.06.08.43;	author matz;	state Exp;
branches;
next	1.69.2.27;

1.69.2.27
date	2002.05.20.04.32.54;	author nobu;	state Exp;
branches;
next	1.69.2.28;

1.69.2.28
date	2002.08.01.04.54.35;	author nobu;	state Exp;
branches;
next	;

1.71.2.1
date	2001.01.12.04.36.00;	author matz;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2002.07.09.05.26.49;	author matz;	state Exp;
branches;
next	;


desc
@@


1.167
log
@* eval.c, file.c, gc.c, io.c, object.c, ruby.c, ruby.h, struct.c,
  ext/socket/socket.c: differentiate long and int; use proper
  printf type specifiers and do casts where appropriate.
@
text
@/**********************************************************************

  io.c -

  $Author: eban $
  $Date: 2002/10/27 09:04:55 $
  created at: Fri Oct 15 18:08:59 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#if defined(__VMS)
#define _XOPEN_SOURCE
#define _POSIX_C_SOURCE 2
#endif

#include "ruby.h"
#include "rubyio.h"
#include "rubysig.h"
#include "env.h"
#include <ctype.h>
#include <errno.h>

#if defined(MSDOS) || defined(__BOW__) || defined(__CYGWIN__) || defined(NT) || defined(__human68k__) || defined(__EMX__) || defined(__BEOS__)
# define NO_SAFE_RENAME
#endif

#if defined(MSDOS) || defined(__CYGWIN__) || defined(NT)
# define NO_LONG_FNAME
#endif

#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(sun) || defined(_nec_ews)
# define USE_SETVBUF
#endif

#ifdef __QNXNTO__
#include "unix.h"
#endif

#include <sys/types.h>
#if !defined(DJGPP) && !defined(NT) && !defined(__human68k__)
#include <sys/ioctl.h>
#endif
#if defined(HAVE_FCNTL_H) || defined(NT)
#include <fcntl.h>
#elif defined(HAVE_SYS_FCNTL_H)
#include <sys/fcntl.h>
#endif

#if !HAVE_OFF_T && !defined(off_t)
# define off_t  long
#endif
#if !HAVE_FSEEKO && !defined(fseeko)
# define fseeko  fseek
#endif
#if !HAVE_FTELLO && !defined(ftello)
# define ftello  ftell
#endif

#include <sys/stat.h>

/* EMX has sys/param.h, but.. */
#if defined(HAVE_SYS_PARAM_H) && !(defined(__EMX__) || defined(__HIUX_MPP__))
# include <sys/param.h>
#endif

#if !defined NOFILE
# define NOFILE 64
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

extern void Init_File _((void));

#ifdef __BEOS__
# ifndef NOFILE
#  define NOFILE (OPEN_MAX)
# endif
#include <net/socket.h>
#endif

#include "util.h"

#if SIZEOF_OFF_T > SIZEOF_LONG && !defined(HAVE_LONG_LONG)
# error off_t is bigger than long, but you have no long long...
#endif

VALUE rb_cIO;
VALUE rb_eEOFError;
VALUE rb_eIOError;

VALUE rb_stdin, rb_stdout, rb_stderr, rb_defout;
static VALUE orig_stdin, orig_stdout, orig_stderr;
static int saved_fd[3] = {0, 1, 2};

VALUE rb_output_fs;
VALUE rb_rs;
VALUE rb_output_rs;
VALUE rb_default_rs;

static VALUE argf;

static ID id_write;

extern char *ruby_inplace_mode;

struct timeval rb_time_interval _((VALUE));

static VALUE filename, current_file;
static int gets_lineno;
static int init_p = 0, next_p = 0, first_p = 1;
static VALUE lineno;

#ifdef _STDIO_USES_IOSTREAM  /* GNU libc */
#  ifdef _IO_fpos_t
#    define READ_DATA_PENDING(fp) ((fp)->_IO_read_ptr != (fp)->_IO_read_end)
#    define READ_DATA_PENDING_COUNT(fp) ((fp)->_IO_read_end - (fp)->_IO_read_ptr)
#    define READ_DATA_PENDING_PTR(fp) ((fp)->_IO_read_ptr)
#  else
#    define READ_DATA_PENDING(fp) ((fp)->_gptr < (fp)->_egptr)
#    define READ_DATA_PENDING_COUNT(fp) ((fp)->_egptr - (fp)->_gptr)
#    define READ_DATA_PENDING_PTR(fp) ((fp)->_gptr)
#  endif
#elif defined(FILE_COUNT)
#  define READ_DATA_PENDING(fp) ((fp)->FILE_COUNT > 0)
#  define READ_DATA_PENDING_COUNT(fp) ((fp)->FILE_COUNT)
#elif defined(FILE_READEND)
#  define READ_DATA_PENDING(fp) ((fp)->FILE_READPTR < (fp)->FILE_READEND)
#  define READ_DATA_PENDING_COUNT(fp) ((fp)->FILE_READEND - (fp)->FILE_READPTR)
#elif defined(__BEOS__)
#  define READ_DATA_PENDING(fp) (fp->_state._eof == 0)
#elif defined(__VMS)
#  define READ_DATA_PENDING(fp) (((unsigned int)((*(fp))->_flag) & _IOEOF) == 0)
#else
/* requires systems own version of the ReadDataPending() */
extern int ReadDataPending();
#  define READ_DATA_PENDING(fp) (!feof(fp))
#endif

#ifndef READ_DATA_PENDING_PTR
# ifdef FILE_READPTR
#  define READ_DATA_PENDING_PTR(fp) ((fp)->FILE_READPTR)
# endif
#endif

#if defined __DJGPP__
# undef READ_DATA_PENDING_COUNT
# undef READ_DATA_PENDING_PTR
#endif

#define READ_CHECK(fp) do {\
    if (!READ_DATA_PENDING(fp)) {\
	rb_thread_wait_fd(fileno(fp));\
        rb_io_check_closed(fptr);\
     }\
} while(0)

void
rb_eof_error()
{
    rb_raise(rb_eEOFError, "End of file reached");
}

VALUE
rb_io_taint_check(io)
    VALUE io;
{
    if (!OBJ_TAINTED(io) && rb_safe_level() >= 4)
	rb_raise(rb_eSecurityError, "Insecure: operation on untainted IO");
    rb_check_frozen(io);
    return io;
}

void
rb_io_check_closed(fptr)
    OpenFile *fptr;
{
    if (!fptr) {
	rb_raise(rb_eIOError, "uninitialized stream");
    }
    if (!fptr->f && !fptr->f2) {
	rb_raise(rb_eIOError, "closed stream");
    }
}

static void io_fflush _((FILE *, OpenFile *));

#if NEED_IO_FLUSH_BEFORE_SEEK
static OpenFile *
flush_before_seek(fptr)
    OpenFile *fptr;
{
    int mode = fptr->mode;
    if (mode & FMODE_RBUF) {
	if (!fptr->f2) io_fflush(fptr->f, fptr);
    }
    if (mode & FMODE_WBUF) {
	io_fflush((fptr->f2 ? fptr->f2 : fptr->f), fptr);
    }
    return fptr;
}
#else
#define flush_before_seek(fptr) fptr
#endif

#define io_seek(fptr, ofs, whence) fseeko(flush_before_seek(fptr)->f, ofs, whence)
#define io_tell(fptr) ftello(flush_before_seek(fptr)->f)

void
rb_io_check_readable(fptr)
    OpenFile *fptr;
{
    if (!(fptr->mode & FMODE_READABLE)) {
	rb_raise(rb_eIOError, "not opened for reading");
    }
#if NEED_IO_FLUSH_BETWEEN_RW
    if ((fptr->mode & FMODE_WBUF) && !fptr->f2) {
	io_fflush(fptr->f, fptr);
    }
    fptr->mode |= FMODE_RBUF;
#endif
}

void
rb_io_check_writable(fptr)
    OpenFile *fptr;
{
    if (!(fptr->mode & FMODE_WRITABLE)) {
	rb_raise(rb_eIOError, "not opened for writing");
    }
#if NEED_IO_FLUSH_BETWEEN_RW
    if ((fptr->mode & FMODE_RBUF) && !fptr->f2) {
	io_fflush(fptr->f, fptr);
    }
#endif
}

int
rb_read_pending(fp)
    FILE *fp;
{
    return READ_DATA_PENDING(fp);
}

void
rb_read_check(fp)
    FILE *fp;
{
    if (!READ_DATA_PENDING(fp)) {
	rb_thread_wait_fd(fileno(fp));
    }
}

static int
ruby_dup(orig)
    int orig;
{
    int fd;

    fd = dup(orig);
    if (fd < 0) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    fd = dup(orig);
	}
	if (fd < 0) {
	    rb_sys_fail(0);
	}
    }
    return fd;
}

static void
io_fflush(f, fptr)
    FILE *f;
    OpenFile *fptr;
{
    int n;

    rb_thread_fd_writable(fileno(f));
    for (;;) {
	TRAP_BEG;
	n = fflush(f);
	TRAP_END;
	if (n != EOF) break;
	if (!rb_io_wait_writable(fileno(f)))
	    rb_sys_fail(fptr->path);
    }
    fptr->mode &= ~FMODE_WBUF;
}

int
rb_io_wait_readable(f)
    int f;
{
    fd_set rfds;

    switch (errno) {
      case EINTR:
#if defined(ERESTART)
      case ERESTART:
#endif
	rb_thread_wait_fd(f);
	return Qtrue;

      case EAGAIN:
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
      case EWOULDBLOCK:
#endif
	FD_ZERO(&rfds);
	FD_SET(f, &rfds);
	rb_thread_select(f + 1, &rfds, NULL, NULL, NULL);
	return Qtrue;

      default:
	return Qfalse;
    }
}

int
rb_io_wait_writable(f)
    int f;
{
    fd_set wfds;

    switch (errno) {
      case EINTR:
#if defined(ERESTART)
      case ERESTART:
#endif
	rb_thread_fd_writable(f);
	return Qtrue;

      case EAGAIN:
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
      case EWOULDBLOCK:
#endif
	FD_ZERO(&wfds);
	FD_SET(f, &wfds);
	rb_thread_select(f + 1, NULL, &wfds, NULL, NULL);
	return Qtrue;

      default:
	return Qfalse;
    }
}

/* writing functions */
static VALUE
io_write(io, str)
    VALUE io, str;
{
    OpenFile *fptr;
    FILE *f;
    long n, r;
    register char *ptr;

    rb_secure(4);
    if (TYPE(str) != T_STRING)
	str = rb_obj_as_string(str);
    if (RSTRING(str)->len == 0) return INT2FIX(0);

    if (TYPE(io) != T_FILE) {
	/* port is not IO, call write method for it. */
	return rb_funcall(io, id_write, 1, str);
    }

    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);
    f = GetWriteFile(fptr);

    ptr = RSTRING(str)->ptr;
    n = RSTRING(str)->len;
#ifdef __human68k__
    do {
	if (fputc(*ptr++, f) == EOF) {
	    if (ferror(f)) rb_sys_fail(fptr->path);
	    break;
	}
    } while (--n > 0);
#else
    while (ptr += (r = fwrite(ptr, 1, n, f)), (n -= r) > 0) {
	if (ferror(f)) {
	    if (rb_io_wait_writable(fileno(f))) {
		clearerr(f);
		continue;
	    }
	    rb_sys_fail(fptr->path);
	}
    }
#endif
    n = ptr - RSTRING(str)->ptr;
    if (fptr->mode & FMODE_SYNC) {
	io_fflush(f, fptr);
    }
    else {
	fptr->mode |= FMODE_WBUF;
    }

    return LONG2FIX(n);
}

VALUE
rb_io_write(io, str)
    VALUE io, str;
{
    return rb_funcall(io, id_write, 1, str);
}

VALUE
rb_io_addstr(io, str)
    VALUE io, str;
{
    rb_io_write(io, str);
    return io;
}

static VALUE
rb_io_flush(io)
    VALUE io;
{
    OpenFile *fptr;
    FILE *f;

    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);
    f = GetWriteFile(fptr);

    io_fflush(f, fptr);

    return io;
}

static VALUE
rb_io_tell(io)
     VALUE io;
{
    OpenFile *fptr;
    off_t pos;

    GetOpenFile(io, fptr);
    pos = io_tell(fptr);
    if (ferror(fptr->f)) rb_sys_fail(fptr->path);
    return OFFT2NUM(pos);
}

#ifndef SEEK_CUR
# define SEEK_SET 0
# define SEEK_CUR 1
# define SEEK_END 2
#endif

static VALUE
rb_io_seek(io, offset, whence)
    VALUE io, offset;
    int whence;
{
    OpenFile *fptr;
    off_t pos;

    GetOpenFile(io, fptr);
    pos = io_seek(fptr, NUM2OFFT(offset), whence);
    if (pos != 0) rb_sys_fail(fptr->path);
    clearerr(fptr->f);

    return INT2FIX(0);
}

static VALUE
rb_io_seek_m(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE offset, ptrname;
    int whence = SEEK_SET;

    if (rb_scan_args(argc, argv, "11", &offset, &ptrname) == 2) {
	whence = NUM2INT(ptrname);
    }

    return rb_io_seek(io, offset, whence);
}

static VALUE
rb_io_set_pos(io, offset)
     VALUE io, offset;
{
    OpenFile *fptr;
    off_t pos;

    GetOpenFile(io, fptr);
    pos = io_seek(fptr, NUM2OFFT(offset), SEEK_SET);
    if (pos != 0) rb_sys_fail(fptr->path);
    clearerr(fptr->f);

    return OFFT2NUM(pos);
}

static VALUE
rb_io_rewind(io)
    VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    if (io_seek(fptr, 0L, 0) != 0) rb_sys_fail(fptr->path);
    clearerr(fptr->f);
    if (io == current_file) {
	gets_lineno -= fptr->lineno;
    }
    fptr->lineno = 0;

    return INT2FIX(0);
}

VALUE
rb_io_eof(io)
    VALUE io;
{
    OpenFile *fptr;
    int ch;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);

    if (feof(fptr->f)) return Qtrue;
    if (READ_DATA_PENDING(fptr->f)) return Qfalse;
    READ_CHECK(fptr->f);
    TRAP_BEG;
    ch = getc(fptr->f);
    TRAP_END;

    if (ch != EOF) {
	ungetc(ch, fptr->f);
	return Qfalse;
    }
    return Qtrue;
}

static VALUE
rb_io_sync(io)
    VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    return (fptr->mode & FMODE_SYNC) ? Qtrue : Qfalse;
}

static VALUE
rb_io_set_sync(io, mode)
    VALUE io, mode;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    if (RTEST(mode)) {
	fptr->mode |= FMODE_SYNC;
    }
    else {
	fptr->mode &= ~FMODE_SYNC;
    }
    return mode;
}

static VALUE
rb_io_fsync(io)
    VALUE io;
{
#ifdef HAVE_FSYNC
    OpenFile *fptr;
    FILE *f;

    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);
    f = GetWriteFile(fptr);

    io_fflush(f, fptr);
    if (fsync(fileno(f)) < 0)
	rb_sys_fail(fptr->path);
    return INT2FIX(0);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

static VALUE
rb_io_fileno(io)
    VALUE io;
{
    OpenFile *fptr;
    int fd;

    GetOpenFile(io, fptr);
    fd = fileno(fptr->f);
    return INT2FIX(fd);
}

static VALUE
rb_io_pid(io)
    VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    if (!fptr->pid)
	return Qnil;
    return INT2FIX(fptr->pid);
}

static VALUE
rb_io_inspect(obj)
    VALUE obj;
{
    OpenFile *fptr;
    char *buf, *cname;

    fptr = RFILE(rb_io_taint_check(obj))->fptr;
    if (!fptr || !(fptr->f || fptr->f2) || !fptr->path) return rb_any_to_s(obj);
    cname = rb_class2name(CLASS_OF(obj));
    buf = ALLOCA_N(char, strlen(cname) + strlen(fptr->path) + 5);
    sprintf(buf, "#<%s:%s>", cname, fptr->path);
    return rb_str_new2(buf);
}

static VALUE
rb_io_to_io(io)
    VALUE io;
{
    return io;
}

/* reading functions */
long
rb_io_fread(ptr, len, f)
    char *ptr;
    long len;
    FILE *f;
{
    long n = len;
    int c;

    while (n > 0) {
#ifdef READ_DATA_PENDING_COUNT
	long i = READ_DATA_PENDING_COUNT(f);
	if (i <= 0) {
	    rb_thread_wait_fd(fileno(f));
	    i = READ_DATA_PENDING_COUNT(f);
	}
	if (i > 0) {
	    if (i > n) i = n;
	    TRAP_BEG;
	    c = fread(ptr, 1, i, f);
	    TRAP_END;
	    if (c < 0) goto eof;
	    ptr += c;
	    n -= c;
	    if (c < i) goto eof;
	    continue;
	}
#else
	if (!READ_DATA_PENDING(f)) {
	    rb_thread_wait_fd(fileno(f));
	}
#endif
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c == EOF) {
	  eof:
	    if (ferror(f)) {
		switch (errno) {
		  case EINTR:
#if defined(ERESTART)
		  case ERESTART:
#endif
		    clearerr(f);
		    continue;
		  case EAGAIN:
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
		  case EWOULDBLOCK:
#endif
		    clearerr(f);
		    return len - n;
		}
		return 0;
	    }
	    *ptr = '\0';
	    break;
	}
	*ptr++ = c;
	n--;
    }
    return len - n;
}

#ifndef S_ISREG
#   define S_ISREG(m) ((m & S_IFMT) == S_IFREG)
#endif

#define SMALLBUF 100

static long
remain_size(fptr)
    OpenFile *fptr;
{
    struct stat st;
    off_t siz = BUFSIZ;
    off_t pos;

    if (feof(fptr->f)) return 0;
    if (fstat(fileno(fptr->f), &st) == 0  && S_ISREG(st.st_mode)
#ifdef __BEOS__
	&& (st.st_dev > 3)
#endif
	)
    {
	pos = io_tell(fptr);
	if (st.st_size > pos && pos >= 0) {
	    siz = st.st_size - pos + 1;
	    if (siz > LONG_MAX) {
		rb_raise(rb_eIOError, "file too big for single read");
	    }
	}
    }
    return (long)siz;
}

static VALUE
read_all(fptr, siz)
    OpenFile *fptr;
    long siz;
{
    VALUE str;
    long bytes = 0;
    long n;
    off_t pos = 0;

    if (feof(fptr->f)) return Qnil;
    READ_CHECK(fptr->f);
    if (!siz) siz = BUFSIZ;
    str = rb_tainted_str_new(0, siz);
    pos = io_tell(fptr);
    for (;;) {
	n = rb_io_fread(RSTRING(str)->ptr+bytes, siz-bytes, fptr->f);
	if (pos > 0 && n == 0 && bytes == 0) {
	    if (feof(fptr->f)) return Qnil;
	    if (!ferror(fptr->f)) return rb_str_new(0, 0);
	    rb_sys_fail(fptr->path);
	}
	bytes += n;
	if (bytes < siz) break;
	siz += BUFSIZ;
	rb_str_resize(str, siz);
    }
    if (bytes == 0) return rb_str_new(0,0);
    if (bytes != siz) rb_str_resize(str, bytes);

    return str;
}

static VALUE
io_read(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    OpenFile *fptr;
    long n, len;
    VALUE length, str;

    rb_scan_args(argc, argv, "01", &length);

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    if (NIL_P(length)) {
	return read_all(fptr, remain_size(fptr));
    }

    len = NUM2LONG(length);
    if (len < 0) {
	rb_raise(rb_eArgError, "negative length %ld given", len);
    }

    if (feof(fptr->f)) return Qnil;
    str = rb_str_new(0, len);
    if (len == 0) return str;

    READ_CHECK(fptr->f);
    n = rb_io_fread(RSTRING(str)->ptr, len, fptr->f);
    if (n == 0) {
	if (feof(fptr->f)) return Qnil;
	rb_sys_fail(fptr->path);
    }
    RSTRING(str)->len = n;
    RSTRING(str)->ptr[n] = '\0';
    OBJ_TAINT(str);

    return str;
}

static int
appendline(fptr, delim, strp)
    OpenFile *fptr;
    int delim;
    VALUE *strp;
{
    FILE *f = fptr->f;
    VALUE str = *strp;
    int c = EOF;
#ifndef READ_DATA_PENDING_PTR
    char buf[8192];
    char *bp = buf, *bpe = buf + sizeof buf - 3;
    int cnt;
#endif

    do {
#ifdef READ_DATA_PENDING_PTR
	long pending = READ_DATA_PENDING_COUNT(f);
	if (pending > 0) {
	    const char *p = READ_DATA_PENDING_PTR(f);
	    const char *e = memchr(p, delim, pending);
	    long last = 0, len = (c != EOF);
	    if (e) pending = e - p + 1;
	    len += pending;
	    if (!NIL_P(str)) {
		last = RSTRING(str)->len;
		rb_str_resize(str, last + len);
	    }
	    else {
		*strp = str = rb_str_buf_new(len);
		RSTRING(str)->len = len;
		RSTRING(str)->ptr[len] = '\0';
	    }
	    if (c != EOF) {
		RSTRING(str)->ptr[last++] = c;
	    }
	    fread(RSTRING(str)->ptr + last, 1, pending, f); /* must not fail */
	    if (e) return delim;
	}
	else if (c != EOF) {
	    if (!NIL_P(str)) {
		char ch = c;
		rb_str_buf_cat(str, &ch, 1);
	    }
	    else {
		*strp = str = rb_str_buf_new(1);
		RSTRING(str)->ptr[RSTRING(str)->len++] = c;
	    }
	}
	rb_thread_wait_fd(fileno(f));
	rb_io_check_closed(fptr);
#else
	READ_CHECK(f);
#endif
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c == EOF) {
	    if (ferror(f)) {
		if (!rb_io_wait_readable(fileno(f)))
		    rb_sys_fail(fptr->path);
		clearerr(f);
		continue;
	    }
	    return c;
	}
#ifndef READ_DATA_PENDING_PTR
	if ((*bp++ = c) == delim || bp == bpe) {
	    cnt = bp - buf;

	    if (cnt > 0) {
		if (!NIL_P(str))
		    rb_str_cat(str, buf, cnt);
		else
		    *strp = str = rb_str_new(buf, cnt);
	    }
	    bp = buf;
	}
#endif
    } while (c != delim);

#ifdef READ_DATA_PENDING_PTR
    {
	char ch = c;
	if (!NIL_P(str)) {
	    rb_str_cat(str, &ch, 1);
	}
	else {
	    *strp = str = rb_str_new(&ch, 1);
	}
    }
#endif

    return c;
}

static inline int
swallow(fptr, term)
    OpenFile *fptr;
    int term;
{
    FILE *f = fptr->f;
    int c;

    do {
#ifdef READ_DATA_PENDING_PTR
	long cnt;
	while ((cnt = READ_DATA_PENDING_COUNT(f)) > 0) {
	    char buf[1024];
	    const char *p = READ_DATA_PENDING_PTR(f);
	    int i;
	    if (cnt > sizeof buf) cnt = sizeof buf;
	    if (*p != term) return Qtrue;
	    i = cnt;
	    while (--i && *++p == term);
	    if (!fread(buf, 1, cnt - i, f)) /* must not fail */
		rb_sys_fail(fptr->path);
	}
	rb_thread_wait_fd(fileno(f));
	rb_io_check_closed(fptr);
#else
	READ_CHECK(f);
#endif
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c != term) {
	    ungetc(c, f);
	    return Qtrue;
	}
    } while (c != EOF);
    return Qfalse;
}

static VALUE
rb_io_getline_fast(fptr, delim)
    OpenFile *fptr;
    int delim;
{
    VALUE str = Qnil;
    int c;

    while ((c = appendline(fptr, delim, &str)) != EOF && c != delim);

    if (!NIL_P(str)) {
	fptr->lineno++;
	lineno = INT2FIX(fptr->lineno);
	OBJ_TAINT(str);
    }

    return str;
}

static VALUE
rb_io_getline(rs, fptr)
    VALUE rs;
    OpenFile *fptr;
{
    VALUE str = Qnil;

    if (NIL_P(rs)) {
	str = read_all(fptr, 0);
    }
    else if (rs == rb_default_rs) {
	return rb_io_getline_fast(fptr, '\n');
    }
    else {
	int c, newline;
	char *rsptr;
	long rslen;
	int rspara = 0;

	StringValue(rs);
	rslen = RSTRING(rs)->len;
	if (rslen == 0) {
	    rsptr = "\n\n";
	    rslen = 2;
	    rspara = 1;
	    swallow(fptr, '\n');
	}
	else if (rslen == 1) {
	    return rb_io_getline_fast(fptr, RSTRING(rs)->ptr[0]);
	}
	else {
	    rsptr = RSTRING(rs)->ptr;
	}
	newline = rsptr[rslen - 1];

	while ((c = appendline(fptr, newline, &str)) != EOF &&
	       (c != newline || RSTRING(str)->len < rslen ||
		memcmp(RSTRING(str)->ptr+RSTRING(str)->len-rslen,rsptr,rslen)));

	if (rspara) {
	    if (c != EOF) {
		swallow(fptr, '\n');
	    }
	}
    }

    if (!NIL_P(str)) {
	fptr->lineno++;
	lineno = INT2FIX(fptr->lineno);
	OBJ_TAINT(str);
    }

    return str;
}

VALUE
rb_io_gets(io)
    VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    return rb_io_getline_fast(fptr, '\n');
}

static VALUE
rb_io_gets_m(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE rs, str;
    OpenFile *fptr;

    if (argc == 0) {
	rs = rb_rs;
    }
    else {
	rb_scan_args(argc, argv, "1", &rs);
    }
    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    str = rb_io_getline(rs, fptr);

    if (!NIL_P(str)) {
	rb_lastline_set(str);
    }
    return str;
}

static VALUE
rb_io_lineno(io)
    VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    return INT2NUM(fptr->lineno);
}

static VALUE
rb_io_set_lineno(io, lineno)
    VALUE io, lineno;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    fptr->lineno = NUM2INT(lineno);
    return lineno;
}

static void
lineno_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    gets_lineno = NUM2INT(val);
    *var = INT2FIX(gets_lineno);
}

static VALUE
argf_set_lineno(argf, val)
    VALUE argf, val;
{
    gets_lineno = NUM2INT(val);
    lineno = INT2FIX(gets_lineno);
    return Qnil;
}

static VALUE
argf_lineno()
{
    return lineno;
}

static VALUE
rb_io_readline(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE line = rb_io_gets_m(argc, argv, io);

    if (NIL_P(line)) {
	rb_eof_error();
    }
    return line;
}

static VALUE
rb_io_readlines(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE line, ary;
    VALUE rs;
    OpenFile *fptr;

    if (argc == 0) {
	rs = rb_rs;
    }
    else {
	rb_scan_args(argc, argv, "1", &rs);
    }
    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    ary = rb_ary_new();
    while (!NIL_P(line = rb_io_getline(rs, fptr))) {
	rb_ary_push(ary, line);
    }
    return ary;
}

static VALUE
rb_io_each_line(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE str;
    OpenFile *fptr;
    VALUE rs;

    if (argc == 0) {
	rs = rb_rs;
    }
    else {
	rb_scan_args(argc, argv, "1", &rs);
    }
    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    while (!NIL_P(str = rb_io_getline(rs, fptr))) {
	rb_yield(str);
    }
    return io;
}

static VALUE
rb_io_each_byte(io)
    VALUE io;
{
    OpenFile *fptr;
    FILE *f;
    int c;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    f = fptr->f;

    for (;;) {
	READ_CHECK(f);
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c == EOF) {
	    if (ferror(f)) {
		if (!rb_io_wait_readable(fileno(f)))
		    rb_sys_fail(fptr->path);
		clearerr(f);
		continue;
	    }
	    break;
	}
	rb_yield(INT2FIX(c & 0xff));
    }
    if (ferror(f)) rb_sys_fail(fptr->path);
    return io;
}

VALUE
rb_io_getc(io)
    VALUE io;
{
    OpenFile *fptr;
    FILE *f;
    int c;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    f = fptr->f;

  retry:
    READ_CHECK(f);
    TRAP_BEG;
    c = getc(f);
    TRAP_END;

    if (c == EOF) {
	if (ferror(f)) {
	    if (!rb_io_wait_readable(fileno(f)))
		rb_sys_fail(fptr->path);
	    clearerr(f);
	    goto retry;
	}
	return Qnil;
    }
    return INT2FIX(c & 0xff);
}

int
rb_getc(f)
    FILE *f;
{
    int c;

    if (!READ_DATA_PENDING(f)) {
	rb_thread_wait_fd(fileno(f));
    }
    TRAP_BEG;
    c = getc(f);
    TRAP_END;

    return c;
}

static VALUE
rb_io_readchar(io)
    VALUE io;
{
    VALUE c = rb_io_getc(io);

    if (NIL_P(c)) {
	rb_eof_error();
    }
    return c;
}

VALUE
rb_io_ungetc(io, c)
    VALUE io, c;
{
    OpenFile *fptr;
    int cc = NUM2INT(c);

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);

    if (ungetc(cc, fptr->f) == EOF && cc != EOF)
	rb_sys_fail(fptr->path);
    return Qnil;
}

static VALUE
rb_io_isatty(io)
    VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    if (isatty(fileno(fptr->f)) == 0)
	return Qfalse;
    return Qtrue;
}

static void
fptr_finalize(fptr, fin)
    OpenFile *fptr;
    int fin;
{
    int n1 = 0, n2 = 0, e = 0, f1, f2 = -1;

    if (fptr->f2) {
	f2 = fileno(fptr->f2);
	while ((n2 = fclose(fptr->f2)) < 0) {
	    if (!rb_io_wait_writable(f2)) {
		e = errno;
		break;
	    }
	}
	fptr->f2 = 0;
    }
    if (fptr->f) {
	f1 = fileno(fptr->f);
	while ((n1 = fclose(fptr->f)) < 0) {
	    if (f2 != -1 || !(fptr->mode & FMODE_WBUF)) break;
	    if (!rb_io_wait_writable(f1)) break;
	}
	fptr->f = 0;
	if (n1 < 0 && errno == EBADF) {
	    if (f1 == f2 || !(fptr->mode & FMODE_WBUF)) {
		n1 = 0;
	    }
	}
    }
    if (!fin && (n1 < 0 || n2 < 0)) {
	if (n1 == 0) errno = e;
	rb_sys_fail(fptr->path);
    }
}

static void
rb_io_fptr_cleanup(fptr, fin)
    OpenFile *fptr;
    int fin;
{
    if (fptr->finalize) {
	(*fptr->finalize)(fptr);
    }
    else {
	fptr_finalize(fptr, fin);
    }

    if (fptr->path) {
	free(fptr->path);
	fptr->path = 0;
    }
}

void
rb_io_fptr_finalize(fptr)
    OpenFile *fptr;
{
    if (!fptr) return;
    if (!fptr->f && !fptr->f2) return;
    if (fileno(fptr->f) < 3) return;

    rb_io_fptr_cleanup(fptr, Qtrue);
}

VALUE
rb_io_close(io)
    VALUE io;
{
    OpenFile *fptr;
    int fd;

    fptr = RFILE(io)->fptr;
    if (!fptr) return Qnil;
    if (!fptr->f && !fptr->f2) return Qnil;

    fd = fileno(fptr->f);
    rb_io_fptr_cleanup(fptr, Qfalse);
    rb_thread_fd_close(fd);

    if (fptr->pid) {
	rb_syswait(fptr->pid);
	fptr->pid = 0;
    }

    return Qnil;
}

static VALUE
rb_io_close_m(io)
    VALUE io;
{
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(io)) {
	rb_raise(rb_eSecurityError, "Insecure: can't close");
    }
    rb_io_check_closed(RFILE(io)->fptr);
    rb_io_close(io);
    return Qnil;
}

static VALUE
rb_io_closed(io)
    VALUE io;
{
    OpenFile *fptr;

    fptr = RFILE(io)->fptr;
    return (fptr->f || fptr->f2)?Qfalse:Qtrue;
}

static VALUE
rb_io_close_read(io)
    VALUE io;
{
    OpenFile *fptr;
    int n;

    if (rb_safe_level() >= 4 && !OBJ_TAINTED(io)) {
	rb_raise(rb_eSecurityError, "Insecure: can't close");
    }
    GetOpenFile(io, fptr);
    if (fptr->f2 == 0 && (fptr->mode & FMODE_WRITABLE)) {
	rb_raise(rb_eIOError, "closing non-duplex IO for reading");
    }
    if (fptr->f2 == 0) {
	return rb_io_close(io);
    }
    n = fclose(fptr->f);
    fptr->mode &= ~FMODE_READABLE;
    fptr->f = fptr->f2;
    fptr->f2 = 0;
    if (n != 0) rb_sys_fail(fptr->path);

    return Qnil;
}

static VALUE
rb_io_close_write(io)
    VALUE io;
{
    OpenFile *fptr;
    int n;

    if (rb_safe_level() >= 4 && !OBJ_TAINTED(io)) {
	rb_raise(rb_eSecurityError, "Insecure: can't close");
    }
    GetOpenFile(io, fptr);
    if (fptr->f2 == 0 && (fptr->mode & FMODE_READABLE)) {
	rb_raise(rb_eIOError, "closing non-duplex IO for writing");
    }
    if (fptr->f2 == 0) {
	return rb_io_close(io);
    }
    n = fclose(fptr->f2);
    fptr->f2 = 0;
    fptr->mode &= ~FMODE_WRITABLE;
    if (n != 0) rb_sys_fail(fptr->path);

    return Qnil;
}

static VALUE
rb_io_sysseek(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE offset, ptrname;
    int whence = SEEK_SET;
    OpenFile *fptr;
    off_t pos;

    if (rb_scan_args(argc, argv, "11", &offset, &ptrname) == 2) {
	whence = NUM2INT(ptrname);
    }

    GetOpenFile(io, fptr);
    if ((fptr->mode & FMODE_READABLE) && READ_DATA_PENDING(fptr->f)) {
	rb_raise(rb_eIOError, "sysseek for buffered IO");
    }
    if ((fptr->mode & FMODE_WRITABLE) && (fptr->mode & FMODE_WBUF)) {
	rb_warn("sysseek for buffered IO");
    }
    pos = lseek(fileno(fptr->f), NUM2OFFT(offset), whence);
    if (pos == -1) rb_sys_fail(fptr->path);
    clearerr(fptr->f);

    return OFFT2NUM(pos);
}

static VALUE
rb_io_syswrite(io, str)
    VALUE io, str;
{
    OpenFile *fptr;
    FILE *f;
    long n;

    rb_secure(4);
    if (TYPE(str) != T_STRING)
	str = rb_obj_as_string(str);

    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);
    f = GetWriteFile(fptr);

    if (fptr->mode & FMODE_WBUF) {
	rb_warn("syswrite for buffered IO");
    }
    if (!rb_thread_fd_writable(fileno(f))) {
        rb_io_check_closed(fptr);
    }
    n = write(fileno(f), RSTRING(str)->ptr, RSTRING(str)->len);

    if (n == -1) rb_sys_fail(fptr->path);

    return LONG2FIX(n);
}

static VALUE
rb_io_sysread(io, len)
    VALUE io, len;
{
    OpenFile *fptr;
    long n, ilen;
    VALUE str;

    ilen = NUM2LONG(len);
    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);

    if (READ_DATA_PENDING(fptr->f)) {
	rb_raise(rb_eIOError, "sysread for buffered IO");
    }
    str = rb_str_new(0, ilen);

    n = fileno(fptr->f);
    rb_thread_wait_fd(fileno(fptr->f));
    TRAP_BEG;
    n = read(fileno(fptr->f), RSTRING(str)->ptr, RSTRING(str)->len);
    TRAP_END;

    if (n == -1) rb_sys_fail(fptr->path);
    if (n == 0 && ilen > 0) {
	rb_eof_error();
    }

    RSTRING(str)->len = n;
    RSTRING(str)->ptr[n] = '\0';
    OBJ_TAINT(str);

    return str;
}

VALUE
rb_io_binmode(io)
    VALUE io;
{
#if defined(NT) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__) || defined(__EMX__)
    OpenFile *fptr;

    GetOpenFile(io, fptr);
#ifdef __human68k__
    if (fptr->f)
	fmode(fptr->f, _IOBIN);
    if (fptr->f2)
	fmode(fptr->f2, _IOBIN);
#else
    if (fptr->f && setmode(fileno(fptr->f), O_BINARY) == -1)
	rb_sys_fail(fptr->path);
    if (fptr->f2 && setmode(fileno(fptr->f2), O_BINARY) == -1)
	rb_sys_fail(fptr->path);
#endif

    fptr->mode |= FMODE_BINMODE;
#endif
    return io;
}

int
rb_io_mode_flags(mode)
    const char *mode;
{
    int flags = 0;
    const char *m = mode;

    switch (*m++) {
      case 'r':
	flags |= FMODE_READABLE;
	break;
      case 'w':
	flags |= FMODE_WRITABLE;
	break;
      case 'a':
	flags |= FMODE_WRITABLE;
	break;
      default:
      error:
	rb_raise(rb_eArgError, "illegal access mode %s", mode);
    }

    while (*m) {
        switch (*m++) {
        case 'b':
            flags |= FMODE_BINMODE;
            break;
        case '+':
            flags |= FMODE_READWRITE;
            break;
        default:
            goto error;
        }
    }

    return flags;
}

static int
rb_io_modenum_flags(mode)
    int mode;
{
    int flags = 0;

    switch (mode & (O_RDONLY|O_WRONLY|O_RDWR)) {
      case O_RDONLY:
	flags = FMODE_READABLE;
	break;
      case O_WRONLY:
	flags = FMODE_WRITABLE;
	break;
      case O_RDWR:
	flags = FMODE_WRITABLE|FMODE_READABLE;
	break;
    }

#ifdef O_BINARY
    if (mode & O_BINARY) {
	flags |= FMODE_BINMODE;
    }
#endif

    return flags;
}

static int
rb_io_mode_modenum(mode)
    const char *mode;
{
    int flags = 0;
    const char *m = mode;

    switch (*m++) {
      case 'r':
	flags |= O_RDONLY;
	break;
      case 'w':
	flags |= O_WRONLY | O_CREAT | O_TRUNC;
	break;
      case 'a':
	flags |= O_WRONLY | O_CREAT | O_APPEND;
	break;
      default:
      error:
	rb_raise(rb_eArgError, "illegal access mode %s", mode);
    }

    while (*m) {
        switch (*m++) {
        case 'b':
#ifdef O_BINARY
            flags |= O_BINARY;
#endif
            break;
        case '+':
            flags |= O_RDWR;
            break;
        default:
            goto error;
        }
    }

    return flags;
}

static char*
rb_io_modenum_mode(flags, mode)
    int flags;
    char *mode;
{
    char *p = mode;

    switch (flags & (O_RDONLY|O_WRONLY|O_RDWR)) {
      case O_RDONLY:
	*p++ = 'r';
	break;
      case O_WRONLY:
	*p++ = 'w';
	break;
      case O_RDWR:
	*p++ = 'r';
	*p++ = '+';
	break;
    }
    *p++ = '\0';
#ifdef O_BINARY
    if (flags & O_BINARY) {
	if (mode[1] == '+') {
	    mode[1] = 'b'; mode[2] = '+'; mode[3] = '\0';
	}
	else {
	    mode[1] = 'b'; mode[2] = '\0';
	}
    }
#endif
    return mode;
}

static int
rb_sysopen(fname, flags, mode)
    char *fname;
    int flags;
    unsigned int mode;
{
    int fd;

    fd = open(fname, flags, mode);
    if (fd < 0) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    fd = open(fname, flags, mode);
	}
	if (fd < 0) {
	    rb_sys_fail(fname);
	}
    }
    return fd;
}

FILE *
rb_fopen(fname, mode)
    const char *fname;
    const char *mode;
{
    FILE *file;

    file = fopen(fname, mode);
    if (!file) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    file = fopen(fname, mode);
	}
	if (!file) {
	    rb_sys_fail(fname);
	}
    }
#ifdef USE_SETVBUF
    if (setvbuf(file, NULL, _IOFBF, 0) != 0)
	rb_warn("setvbuf() can't be honered for %s", fname);
#endif
#ifdef __human68k__
    fmode(file, _IOTEXT);
#endif
    return file;
}

FILE *
rb_fdopen(fd, mode)
    int fd;
    const char *mode;
{
    FILE *file;

    file = fdopen(fd, mode);
    if (!file) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    file = fdopen(fd, mode);
	}
	if (!file) {
	    rb_sys_fail(0);
	}
    }

#ifdef USE_SETVBUF
    if (setvbuf(file, NULL, _IOFBF, 0) != 0)
	rb_warn("setvbuf() can't be honered (fd=%d)", fd);
#endif
    return file;
}

static VALUE
rb_file_open_internal(io, fname, mode)
    VALUE io;
    const char *fname, *mode;
{
    OpenFile *fptr;

    MakeOpenFile(io, fptr);

    fptr->mode = rb_io_mode_flags(mode);
    fptr->f = rb_fopen(fname, mode);
    fptr->path = strdup(fname);

    return io;
}

VALUE
rb_file_open(fname, mode)
    const char *fname, *mode;
{
    VALUE io = rb_obj_alloc(rb_cFile);

    return rb_file_open_internal(io, fname, mode);
}

static VALUE
rb_file_sysopen_internal(io, fname, flags, mode)
    VALUE io;
    char *fname;
    int flags, mode;
{
    OpenFile *fptr;
    int fd;
    char *m;
    char mbuf[4];

    MakeOpenFile(io, fptr);

    fd = rb_sysopen(fname, flags, mode);
    m = rb_io_modenum_mode(flags, mbuf);
    fptr->mode = rb_io_modenum_flags(flags);
    fptr->f = rb_fdopen(fd, m);
    fptr->path = strdup(fname);

    return io;
}

VALUE
rb_file_sysopen(fname, flags, mode)
    const char *fname;
    int flags, mode;
{
    VALUE io = rb_obj_alloc(rb_cFile);

    return rb_file_sysopen_internal(io, fname, flags, mode);
}

#if defined (NT) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__) || defined(__VMS)
static struct pipe_list {
    OpenFile *fptr;
    struct pipe_list *next;
} *pipe_list;

static void
pipe_add_fptr(fptr)
    OpenFile *fptr;
{
    struct pipe_list *list;

    list = ALLOC(struct pipe_list);
    list->fptr = fptr;
    list->next = pipe_list;
    pipe_list = list;
}

static void
pipe_del_fptr(fptr)
    OpenFile *fptr;
{
    struct pipe_list *list = pipe_list;
    struct pipe_list *tmp;

    if (list->fptr == fptr) {
	pipe_list = list->next;
	free(list);
	return;
    }

    while (list->next) {
	if (list->next->fptr == fptr) {
	    tmp = list->next;
	    list->next = list->next->next;
	    free(tmp);
	    return;
	}
	list = list->next;
    }
}

#if defined (NT) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__) || defined(__VMS)
static void
pipe_atexit _((void))
{
    struct pipe_list *list = pipe_list;
    struct pipe_list *tmp;

    while (list) {
	tmp = list->next;
	rb_io_fptr_finalize(list->fptr);
	list = tmp;
    }
}
#endif

static void pipe_finalize _((OpenFile *fptr));

static void
pipe_finalize(fptr)
    OpenFile *fptr;
{
#if !defined (__CYGWIN__) && !defined(NT)
    extern VALUE rb_last_status;
    int status;
    if (fptr->f) {
	status = pclose(fptr->f);
    }
    if (fptr->f2) {
	status = pclose(fptr->f2);
    }
    fptr->f = fptr->f2 = 0;
#if defined DJGPP
    status <<= 8;
#endif
    rb_last_status = INT2FIX(status);
#else
    fptr_finalize(fptr, Qtrue);
#endif
    pipe_del_fptr(fptr);
}
#endif

void
rb_io_synchronized(fptr)
    OpenFile *fptr;
{
    fptr->mode |= FMODE_SYNC;
}

void
rb_io_unbuffered(fptr)
    OpenFile *fptr;
{
    rb_io_synchronized(fptr);
}

static VALUE
pipe_open(pname, mode)
    char *pname, *mode;
{
    int modef = rb_io_mode_flags(mode);
    OpenFile *fptr;

#if defined(DJGPP) || defined(__human68k__) || defined(__VMS)
    FILE *f = popen(pname, mode);

    if (!f) rb_sys_fail(pname);
    else {
	VALUE port = rb_obj_alloc(rb_cIO);

	MakeOpenFile(port, fptr);
	fptr->finalize = pipe_finalize;
	fptr->mode = modef;

	pipe_add_fptr(fptr);
	if (modef & FMODE_READABLE) fptr->f  = f;
	if (modef & FMODE_WRITABLE) {
	    if (fptr->f) fptr->f2 = f;
	    else fptr->f = f;
	    rb_io_synchronized(fptr);
	}
	return (VALUE)port;
    }
#else
#if defined(NT)
    int pid;
    FILE *fpr, *fpw;

retry:
    pid = pipe_exec(pname, rb_io_mode_modenum(mode), &fpr, &fpw);
    if (pid == -1) {		/* exec failed */
	if (errno == EAGAIN) {
	    rb_thread_sleep(1);
	    goto retry;
	}
	rb_sys_fail(pname);
    }
    else {
        VALUE port = rb_obj_alloc(rb_cIO);

	MakeOpenFile(port, fptr);
	fptr->mode = modef;
	fptr->mode |= FMODE_SYNC;
	fptr->pid = pid;

	if (modef & FMODE_READABLE) {
	    fptr->f = fpr;
	}
	if (modef & FMODE_WRITABLE) {
	    if (fptr->f) fptr->f2 = fpw;
	    else fptr->f = fpw;
	}
	fptr->finalize = pipe_finalize;
	pipe_add_fptr(fptr);
	return (VALUE)port;
    }
#else
    int pid, pr[2], pw[2];
    volatile int doexec;

    if (((modef & FMODE_READABLE) && pipe(pr) == -1) ||
	((modef & FMODE_WRITABLE) && pipe(pw) == -1))
	rb_sys_fail(pname);

    doexec = (strcmp("-", pname) != 0);
    if (!doexec) {
	fflush(stdin);		/* is it really needed? */
	fflush(stdout);
	fflush(stderr);
    }

  retry:
    switch ((pid = fork())) {
      case 0:			/* child */
	if (modef & FMODE_READABLE) {
	    close(pr[0]);
	    if (pr[1] != 1) {
		dup2(pr[1], 1);
		close(pr[1]);
	    }
	}
	if (modef & FMODE_WRITABLE) {
	    close(pw[1]);
	    if (pw[0] != 0) {
		dup2(pw[0], 0);
		close(pw[0]);
	    }
	}

	if (doexec) {
	    int fd;

	    for (fd = 3; fd < NOFILE; fd++)
		close(fd);
	    rb_proc_exec(pname);
	    fprintf(stderr, "%s:%d: command not found: %s\n",
		    ruby_sourcefile, ruby_sourceline, pname);
	    _exit(127);
	}
	rb_io_synchronized(RFILE(orig_stdout)->fptr);
	rb_io_synchronized(RFILE(orig_stderr)->fptr);
	return Qnil;

      case -1:			/* fork failed */
	if (errno == EAGAIN) {
	    rb_thread_sleep(1);
	    goto retry;
	}
	close(pr[0]); close(pw[1]);
	rb_sys_fail(pname);
	break;

      default:			/* parent */
	if (pid < 0) rb_sys_fail(pname);
	else {
	    VALUE port = rb_obj_alloc(rb_cIO);

	    MakeOpenFile(port, fptr);
	    fptr->mode = modef;
	    fptr->mode |= FMODE_SYNC;
	    fptr->pid = pid;

	    if (modef & FMODE_READABLE) {
		close(pr[1]);
		fptr->f  = rb_fdopen(pr[0], "r");
	    }
	    if (modef & FMODE_WRITABLE) {
		FILE *f = rb_fdopen(pw[1], "w");

		close(pw[0]);
		if (fptr->f) fptr->f2 = f;
		else fptr->f = f;
	    }
#if defined (__CYGWIN__)
	    fptr->finalize = pipe_finalize;
	    pipe_add_fptr(fptr);
#endif
	    return port;
	}
    }
#endif
#endif
}

static VALUE
rb_io_popen(str, argc, argv, klass)
    char *str;
    int argc;
    VALUE *argv;
    VALUE klass;
{
    char *mode;
    VALUE pname, pmode, port;
    char mbuf[4];

    if (rb_scan_args(argc, argv, "11", &pname, &pmode) == 1) {
	mode = "r";
    }
    else if (FIXNUM_P(pmode)) {
	mode = rb_io_modenum_mode(FIX2INT(pmode), mbuf);
    }
    else {
	mode = StringValuePtr(pmode);
    }
    SafeStringValue(pname);
    port = pipe_open(str, mode);
    if (NIL_P(port)) {
	/* child */
	if (rb_block_given_p()) {
	    rb_yield(Qnil);
	    fflush(stdout);
	    fflush(stderr);
	    _exit(0);
	}
	return Qnil;
    }
    RBASIC(port)->klass = klass;
    if (rb_block_given_p()) {
	return rb_ensure(rb_yield, port, rb_io_close, port);
    }
    return port;
}

static VALUE
rb_io_s_popen(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    char *str = 0;

    if (argc >= 1) {
	str = StringValuePtr(argv[0]);
    }
    return rb_io_popen(str, argc, argv, klass);
}

static VALUE
rb_open_file(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE fname, vmode, perm;
    char *path, *mode;
    int flags, fmode;

    rb_scan_args(argc, argv, "12", &fname, &vmode, &perm);
    SafeStringValue(fname);
    path = RSTRING(fname)->ptr;

    if (FIXNUM_P(vmode) || !NIL_P(perm)) {
	flags = FIXNUM_P(vmode) ? NUM2INT(vmode) : rb_io_mode_modenum(StringValuePtr(vmode));
	fmode = NIL_P(perm) ? 0666 :  NUM2INT(perm);

	rb_file_sysopen_internal(io, path, flags, fmode);
    }
    else {
	mode = NIL_P(vmode) ? "r" : StringValuePtr(vmode);
	rb_file_open_internal(io, RSTRING(fname)->ptr, mode);
    }
    return io;
}

static VALUE
rb_io_s_open(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE io = rb_class_new_instance(argc, argv, klass);

    if (rb_block_given_p()) {
	return rb_ensure(rb_yield, io, rb_io_close, io);
    }

    return io;
}

static VALUE
rb_io_s_sysopen(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE fname, vmode, perm;
    int flags, fmode, fd;

    rb_scan_args(argc, argv, "12", &fname, &vmode, &perm);
    SafeStringValue(fname);

    if (NIL_P(vmode)) flags = O_RDONLY;
    else if (FIXNUM_P(vmode)) flags = NUM2INT(vmode);
    else {
	flags = rb_io_mode_modenum(StringValuePtr(vmode));
    }
    if (NIL_P(perm)) fmode = 0666;
    else             fmode = NUM2INT(perm);

    fd = rb_sysopen(RSTRING(fname)->ptr, flags, fmode);
    return INT2NUM(fd);
}

static VALUE
rb_f_open(argc, argv)
    int argc;
    VALUE *argv;
{
    if (argc >= 1) {
	char *str = StringValuePtr(argv[0]);

	if (str[0] == '|') {
	    return rb_io_popen(str+1, argc, argv, rb_cIO);
	}
    }
    return rb_io_s_open(argc, argv, rb_cFile);
}

static VALUE
rb_io_open(fname, mode)
    char *fname, *mode;
{
    if (fname[0] == '|') {
	return pipe_open(fname+1, mode);
    }
    else {
	return rb_file_open(fname, mode);
    }
}

static VALUE
rb_io_get_io(io)
    VALUE io;
{
    return rb_convert_type(io, T_FILE, "IO", "to_io");
}

static char*
rb_io_mode_string(fptr)
    OpenFile *fptr;
{
    switch (fptr->mode & FMODE_READWRITE) {
      case FMODE_READABLE:
      default:
	return "r";
      case FMODE_WRITABLE:
	return "w";
      case FMODE_READWRITE:
	return "r+";
    }
}

static VALUE
io_reopen(io, nfile)
    VALUE io, nfile;
{
    OpenFile *fptr, *orig;
    char *mode;
    int fd;
    off_t pos = 0;

    nfile = rb_io_get_io(nfile);
    if (rb_safe_level() >= 4 && (!OBJ_TAINTED(io) || !OBJ_TAINTED(nfile))) {
	rb_raise(rb_eSecurityError, "Insecure: can't reopen");
    }
    GetOpenFile(io, fptr);
    GetOpenFile(nfile, orig);

    if (fptr == orig) return io;
    if (orig->mode & FMODE_READABLE) {
	pos = io_tell(orig);
    }
    if (orig->f2) {
	io_fflush(orig->f2, orig);
    }
    else if (orig->mode & FMODE_WRITABLE) {
	io_fflush(orig->f, orig);
    }
    rb_thread_fd_close(fileno(fptr->f));

    /* copy OpenFile structure */
    fptr->mode = orig->mode;
    fptr->pid = orig->pid;
    fptr->lineno = orig->lineno;
    if (fptr->path) free(fptr->path);
    if (orig->path) fptr->path = strdup(orig->path);
    else fptr->path = 0;
    fptr->finalize = orig->finalize;

    mode = rb_io_mode_string(fptr);
    fd = fileno(fptr->f);
    if (fd < 3) {
	clearerr(fptr->f);
	/* need to keep stdio objects */
	if (dup2(fileno(orig->f), fd) < 0)
	    rb_sys_fail(orig->path);
    }
    else {
	fclose(fptr->f);
	if (dup2(fileno(orig->f), fd) < 0)
	    rb_sys_fail(orig->path);
	fptr->f = rb_fdopen(fd, mode);
    }
    if ((orig->mode & FMODE_READABLE) && pos >= 0) {
	io_seek(fptr, pos, SEEK_SET);
	io_seek(orig, pos, SEEK_SET);
    }

    if (fptr->f2) {
	fd = fileno(fptr->f2);
	fclose(fptr->f2);
	if (orig->f2) {
	    if (dup2(fileno(orig->f2), fd) < 0)
		rb_sys_fail(orig->path);
	    fptr->f2 = rb_fdopen(fd, "w");
	}
	else {
	    fptr->f2 = 0;
	}
    }

    if (fptr->mode & FMODE_BINMODE) {
	rb_io_binmode(io);
    }

    RBASIC(io)->klass = RBASIC(nfile)->klass;
    return io;
}

static VALUE
rb_io_reopen(argc, argv, file)
    int argc;
    VALUE *argv;
    VALUE file;
{
    VALUE fname, nmode;
    char *mode;
    OpenFile *fptr;

    rb_secure(4);
    if (rb_scan_args(argc, argv, "11", &fname, &nmode) == 1) {
	if (TYPE(fname) != T_STRING) { /* fname must be IO */
	    return io_reopen(file, fname);
	}
    }

    SafeStringValue(fname);
    if (!NIL_P(nmode)) {
	mode = StringValuePtr(nmode);
    }
    else {
	mode = "r";
    }

    GetOpenFile(file, fptr);
    if (fptr->path) {
	free(fptr->path);
	fptr->path = 0;
    }

    fptr->path = strdup(RSTRING(fname)->ptr);
    fptr->mode = rb_io_mode_flags(mode);
    if (!fptr->f) {
	fptr->f = rb_fopen(RSTRING(fname)->ptr, mode);
	if (fptr->f2) {
	    fclose(fptr->f2);
	    fptr->f2 = 0;
	}

	return file;
    }

    if (freopen(RSTRING(fname)->ptr, mode, fptr->f) == 0) {
	rb_sys_fail(fptr->path);
    }
#ifdef USE_SETVBUF
    if (setvbuf(fptr->f, NULL, _IOFBF, 0) != 0)
	rb_warn("setvbuf() can't be honered for %s", RSTRING(fname)->ptr);
#endif

    if (fptr->f2) {
	if (freopen(RSTRING(fname)->ptr, "w", fptr->f2) == 0) {
	    rb_sys_fail(fptr->path);
	}
    }

    return file;
}

static VALUE
rb_io_become(clone, io)
    VALUE clone, io;
{
    OpenFile *fptr, *orig;
    int fd;
    char *mode;

    io = rb_io_get_io(io);
    if (clone == io) return clone;
    GetOpenFile(io, orig);
    MakeOpenFile(clone, fptr);

    if (orig->f2) {
	io_fflush(orig->f2, orig);
    }
    else if (orig->mode & FMODE_WRITABLE) {
	io_fflush(orig->f, orig);
    }

    /* copy OpenFile structure */
    fptr->mode = orig->mode;
    fptr->pid = orig->pid;
    fptr->lineno = orig->lineno;
    if (orig->path) fptr->path = strdup(orig->path);
    fptr->finalize = orig->finalize;

    switch (fptr->mode & FMODE_READWRITE) {
      case FMODE_READABLE:
      default:
	mode = "r"; break;
      case FMODE_WRITABLE:
	mode = "w"; break;
      case FMODE_READWRITE:
	if (orig->f2) mode = "r";
	else          mode = "r+";
	break;
    }
    fd = ruby_dup(fileno(orig->f));
    fptr->f = rb_fdopen(fd, mode);
    if (orig->f2) {
	if (fileno(orig->f) != fileno(orig->f2)) {
	    fd = ruby_dup(fileno(orig->f2));
	}
	fptr->f2 = rb_fdopen(fd, "w");
    }
    if (fptr->mode & FMODE_BINMODE) {
	rb_io_binmode(clone);
    }

    return clone;
}

VALUE
rb_io_printf(argc, argv, out)
    int argc;
    VALUE argv[];
    VALUE out;
{
    rb_io_write(out, rb_f_sprintf(argc, argv));
    return Qnil;
}

static VALUE
rb_f_printf(argc, argv)
    int argc;
    VALUE argv[];
{
    VALUE out;

    if (argc == 0) return Qnil;
    if (TYPE(argv[0]) == T_STRING) {
	out = rb_defout;
    }
    else {
	out = argv[0];
	argv++;
	argc--;
    }
    rb_io_write(out, rb_f_sprintf(argc, argv));

    return Qnil;
}

VALUE
rb_io_print(argc, argv, out)
    int argc;
    VALUE *argv;
    VALUE out;
{
    int i;
    VALUE line;

    /* if no argument given, print `$_' */
    if (argc == 0) {
	argc = 1;
	line = rb_lastline_get();
	argv = &line;
    }
    for (i=0; i<argc; i++) {
	if (!NIL_P(rb_output_fs) && i>0) {
	    rb_io_write(out, rb_output_fs);
	}
	switch (TYPE(argv[i])) {
	  case T_NIL:
	    rb_io_write(out, rb_str_new2("nil"));
	    break;
	  default:
	    rb_io_write(out, argv[i]);
	    break;
	}
    }
    if (!NIL_P(rb_output_rs)) {
	rb_io_write(out, rb_output_rs);
    }

    return Qnil;
}

static VALUE
rb_f_print(argc, argv)
    int argc;
    VALUE *argv;
{
    rb_io_print(argc, argv, rb_defout);
    return Qnil;
}

static VALUE
rb_io_putc(io, ch)
    VALUE io, ch;
{
    char c = NUM2CHR(ch);

    rb_io_write(io, rb_str_new(&c, 1));
    return ch;
}

static VALUE
rb_f_putc(recv, ch)
    VALUE recv, ch;
{
    return rb_io_putc(rb_defout, ch);
}

static VALUE
io_puts_ary(ary, out)
    VALUE ary, out;
{
    VALUE tmp;
    long i;

    for (i=0; i<RARRAY(ary)->len; i++) {
	tmp = RARRAY(ary)->ptr[i];
	if (rb_inspecting_p(tmp)) {
	    tmp = rb_str_new2("[...]");
	}
	rb_io_puts(1, &tmp, out);
    }
    return Qnil;
}

VALUE
rb_io_puts(argc, argv, out)
    int argc;
    VALUE *argv;
    VALUE out;
{
    int i;
    VALUE line;

    /* if no argument given, print newline. */
    if (argc == 0) {
	rb_io_write(out, rb_default_rs);
	return Qnil;
    }
    for (i=0; i<argc; i++) {
	if (NIL_P(argv[i])) {
	    line = rb_str_new2("nil");
	}
	else {
	    line = rb_check_convert_type(argv[i], T_ARRAY, "Array", "to_ary");
	    if (!NIL_P(line)) {
		rb_protect_inspect(io_puts_ary, line, out);
		continue;
	    }
	    line = rb_obj_as_string(argv[i]);
	}
	rb_io_write(out, line);
	if (RSTRING(line)->len == 0 ||
            RSTRING(line)->ptr[RSTRING(line)->len-1] != '\n') {
	    rb_io_write(out, rb_default_rs);
	}
    }

    return Qnil;
}

static VALUE
rb_f_puts(argc, argv)
    int argc;
    VALUE *argv;
{
    rb_io_puts(argc, argv, rb_defout);
    return Qnil;
}

void
rb_p(obj)			/* for debug print within C code */
    VALUE obj;
{
    rb_io_write(rb_defout, rb_obj_as_string(rb_inspect(obj)));
    rb_io_write(rb_defout, rb_default_rs);
}

static VALUE
rb_f_p(argc, argv)
    int argc;
    VALUE *argv;
{
    int i;

    for (i=0; i<argc; i++) {
	rb_p(argv[i]);
    }
    if (TYPE(rb_defout) == T_FILE) {
	rb_io_flush(rb_defout);
    }
    return Qnil;
}

static VALUE
rb_obj_display(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE out;

    if (rb_scan_args(argc, argv, "01", &out) == 0) {
	out = rb_defout;
    }

    rb_io_write(out, self);

    return Qnil;
}

static void
rb_io_defset(val, id)
    VALUE val;
    ID id;
{
    if (!rb_respond_to(val, id_write)) {
	rb_raise(rb_eTypeError, "$> must have write method, %s given",
		 rb_class2name(CLASS_OF(val)));
    }
    rb_defout = val;
}

static void
set_stdin(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    OpenFile *fptr;

    if (val == *var) return;
    if (TYPE(val) != T_FILE) {
	*var = val;
	return;
    }
    if (TYPE(*var) != T_FILE) {
	*var = orig_stdin;
    }

    GetOpenFile(val, fptr);
    rb_io_check_readable(fptr);
    if (fileno(fptr->f) == 0 && saved_fd[0] != 0) {
	dup2(saved_fd[0], 0);
	close(saved_fd[0]);
	saved_fd[0] = 0;
    }
    else {
	saved_fd[0] = dup(0);
	dup2(fileno(fptr->f), 0);
    }

    *var = val;
}

static void
set_outfile(val, var, orig, stdf)
    VALUE val;
    VALUE *var;
    VALUE orig;
    FILE *stdf;
{
    OpenFile *fptr;
    FILE *f;
    int fd;

    if (val == *var) return;

    if (TYPE(*var) == T_FILE && !rb_io_closed(*var)) {
	rb_io_flush(*var);
    }
    if (TYPE(val) != T_FILE) {
	*var = val;
	return;
    }
    if (TYPE(*var) != T_FILE) {
	*var = orig;
    }

    GetOpenFile(val, fptr);
    rb_io_check_writable(fptr);
    f = GetWriteFile(fptr);
    fd = fileno(stdf);
    if (fileno(fptr->f) == fd && saved_fd[fd] != fd) {
	dup2(saved_fd[fd], fd);
	close(saved_fd[fd]);
	saved_fd[fd] = fd;
    }
    else {
	saved_fd[fd] = dup(fd);
	dup2(fileno(fptr->f), fd);
    }

    *var = val;
}

static void
set_stdout(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    set_outfile(val, var, orig_stdout, stdout);
}

static void
set_stderr(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    set_outfile(val, var, orig_stderr, stderr);
}

static VALUE
prep_stdio(f, mode, klass)
    FILE *f;
    int mode;
    VALUE klass;
{
    OpenFile *fp;
    VALUE io = rb_obj_alloc(klass);

    MakeOpenFile(io, fp);
    fp->f = f;
    fp->mode = mode;

    return io;
}

static void
prep_path(io, path)
    VALUE io;
    char *path;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    if (fptr->path) rb_bug("illegal prep_path() call");
    fptr->path = strdup(path);
}

static VALUE
rb_io_s_alloc(klass)
    VALUE klass;
{
    NEWOBJ(io, struct RFile);
    OBJSETUP(io, klass, T_FILE);

    io->fptr = 0;

    return (VALUE)io;
}

static VALUE
rb_io_initialize(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE fnum, mode;
    OpenFile *fp;
    int fd, flags;
    char mbuf[4];

    rb_scan_args(argc, argv, "11", &fnum, &mode);
    fd = NUM2INT(fnum);
    if (argc == 2) {
	SafeStringValue(mode);
	flags = rb_io_mode_modenum(RSTRING(mode)->ptr);
    }
    else {
#if defined(HAVE_FCNTL) && defined(F_GETFL)
	flags = fcntl(fd, F_GETFL);
#else
	flags = O_RDONLY;
#endif
    }
    MakeOpenFile(io, fp);
    fp->mode = rb_io_modenum_flags(flags);
    fp->f = rb_fdopen(fd, rb_io_modenum_mode(flags, mbuf));

    return io;
}

static VALUE
rb_file_initialize(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    if (RFILE(io)->fptr) {
	rb_io_close_m(io);
	free(RFILE(io)->fptr);
	RFILE(io)->fptr = 0;
    }
    if (0 < argc && argc < 3) {
	VALUE fd = rb_check_convert_type(argv[0], T_FIXNUM, "Fixnum", "to_int");

	if (!NIL_P(fd)) {
	    argv[0] = fd;
	    return rb_io_initialize(argc, argv, io);
	}
    }
    rb_open_file(argc, argv, io);

    return io;
}

static VALUE
rb_io_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    if (rb_block_given_p()) {
	char *cname = rb_class2name(klass);

	rb_warn("%s::new() does not take block; use %s::open() instead",
		cname, cname);
    }
    return rb_class_new_instance(argc, argv, klass);
}

static int binmode = 0;

static VALUE
argf_forward()
{
    return rb_funcall3(current_file, ruby_frame->last_func,
		       ruby_frame->argc, ruby_frame->argv);
}

static int
next_argv()
{
    extern VALUE rb_argv;
    char *fn;

    if (init_p == 0) {
	if (RARRAY(rb_argv)->len > 0) {
	    next_p = 1;
	}
	else {
	    next_p = -1;
	    current_file = rb_stdin;
	    filename = rb_str_new2("-");
	}
	init_p = 1;
	first_p = 0;
	gets_lineno = 0;
    }

  retry:
    if (next_p == 1) {
	next_p = 0;
	if (RARRAY(rb_argv)->len > 0) {
	    filename = rb_ary_shift(rb_argv);
	    fn = StringValuePtr(filename);
	    if (strlen(fn) == 1 && fn[0] == '-') {
		current_file = rb_stdin;
		if (ruby_inplace_mode) {
		    rb_warn("Can't do inplace edit for stdio");
		    rb_defout = rb_stdout;
		}
	    }
	    else {
		FILE *fr = rb_fopen(fn, "r");

		if (ruby_inplace_mode) {
		    struct stat st, st2;
		    VALUE str;
		    FILE *fw;

		    if (TYPE(rb_defout) == T_FILE && rb_defout != rb_stdout) {
			rb_io_close(rb_defout);
		    }
		    fstat(fileno(fr), &st);
		    if (*ruby_inplace_mode) {
			str = rb_str_new2(fn);
#ifdef NO_LONG_FNAME
                        ruby_add_suffix(str, ruby_inplace_mode);
#else
			rb_str_cat2(str, ruby_inplace_mode);
#endif
#ifdef NO_SAFE_RENAME
			(void)fclose(fr);
			(void)unlink(RSTRING(str)->ptr);
			(void)rename(fn, RSTRING(str)->ptr);
			fr = rb_fopen(RSTRING(str)->ptr, "r");
#else
			if (rename(fn, RSTRING(str)->ptr) < 0) {
			    rb_warn("Can't rename %s to %s: %s, skipping file",
				    fn, RSTRING(str)->ptr, strerror(errno));
			    fclose(fr);
			    goto retry;
			}
#endif
		    }
		    else {
#ifdef NO_SAFE_RENAME
			rb_fatal("Can't do inplace edit without backup");
#else
			if (unlink(fn) < 0) {
			    rb_warn("Can't remove %s: %s, skipping file",
				    fn, strerror(errno));
			    fclose(fr);
			    goto retry;
			}
#endif
		    }
		    fw = rb_fopen(fn, "w");
#ifndef NO_SAFE_RENAME
		    fstat(fileno(fw), &st2);
#ifdef HAVE_FCHMOD
		    fchmod(fileno(fw), st.st_mode);
#else
		    chmod(fn, st.st_mode);
#endif
		    if (st.st_uid!=st2.st_uid || st.st_gid!=st2.st_gid) {
			fchown(fileno(fw), st.st_uid, st.st_gid);
		    }
#endif
		    rb_defout = prep_stdio(fw, FMODE_WRITABLE, rb_cFile);
		    prep_path(rb_defout, fn);
		}
		current_file = prep_stdio(fr, FMODE_READABLE, rb_cFile);
		prep_path(current_file, fn);
	    }
	    if (binmode) rb_io_binmode(current_file);
	}
	else {
	    init_p = 0;
	    return Qfalse;
	}
    }
    return Qtrue;
}

static void
any_close(file)
    VALUE file;
{
    if (TYPE(file) == T_FILE)
	rb_io_close(file);
    else
	rb_funcall3(file, rb_intern("close"), 0, 0);
}

static VALUE
argf_getline(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE line;

  retry:
    if (!next_argv()) return Qnil;
    if (TYPE(current_file) != T_FILE) {
	line = rb_funcall3(current_file, rb_intern("gets"), argc, argv);
    }
    else if (argc == 0 && rb_rs == rb_default_rs) {
	line = rb_io_gets(current_file);
    }
    else {
	VALUE rs;
	OpenFile *fptr;

	if (argc == 0) {
	    rs = rb_rs;
	}
	else {
	    rb_scan_args(argc, argv, "1", &rs);
	}
	GetOpenFile(current_file, fptr);
	rb_io_check_readable(fptr);
	line = rb_io_getline(rs, fptr);
    }
    if (NIL_P(line) && next_p != -1) {
	any_close(current_file);
	next_p = 1;
	goto retry;
    }
    gets_lineno++;
    lineno = INT2FIX(gets_lineno);

    return line;
}

static VALUE
rb_f_gets(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE line = argf_getline(argc, argv);

    rb_lastline_set(line);
    return line;
}

VALUE
rb_gets()
{
    VALUE line;

    if (rb_rs != rb_default_rs) {
	return rb_f_gets(0, 0);
    }

  retry:
    if (!next_argv()) return Qnil;
    line = rb_io_gets(current_file);
    if (NIL_P(line) && next_p != -1) {
	any_close(current_file);
	next_p = 1;
	goto retry;
    }
    rb_lastline_set(line);
    if (!NIL_P(line)) {
	gets_lineno++;
	lineno = INT2FIX(gets_lineno);
    }

    return line;
}

static VALUE
rb_f_readline(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE line = rb_f_gets(argc, argv);

    if (NIL_P(line)) {
	rb_eof_error();
    }

    return line;
}

static VALUE
rb_f_getc()
{
    rb_warn("getc is obsolete; use STDIN.getc instead");
    return rb_io_getc(rb_stdin);
}

static VALUE
rb_f_readlines(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE line, ary;

    ary = rb_ary_new();
    while (!NIL_P(line = argf_getline(argc, argv))) {
	rb_ary_push(ary, line);
    }

    return ary;
}

static VALUE
rb_f_backquote(obj, str)
    VALUE obj, str;
{
    VALUE port, result;
    OpenFile *fptr;

    SafeStringValue(str);
    port = pipe_open(RSTRING(str)->ptr, "r");
    if (NIL_P(port)) return rb_str_new(0,0);

    GetOpenFile(port, fptr);
    result = read_all(fptr, remain_size(fptr));

    rb_io_close(port);

    if (NIL_P(result)) return rb_str_new(0,0);
    return result;
}

#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif

static VALUE
rb_f_select(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE read, write, except, timeout, res, list;
    fd_set rset, wset, eset, pset;
    fd_set *rp, *wp, *ep;
    struct timeval *tp, timerec;
    OpenFile *fptr;
    long i;
    int max = 0, n;
    int interrupt_flag = 0;
    int pending = 0;

    rb_scan_args(argc, argv, "13", &read, &write, &except, &timeout);
    if (NIL_P(timeout)) {
	tp = 0;
    }
    else {
	timerec = rb_time_interval(timeout);
	tp = &timerec;
    }

    FD_ZERO(&pset);
    if (!NIL_P(read)) {
	Check_Type(read, T_ARRAY);
	rp = &rset;
	FD_ZERO(rp);
	for (i=0; i<RARRAY(read)->len; i++) {
	    GetOpenFile(rb_io_get_io(RARRAY(read)->ptr[i]), fptr);
	    FD_SET(fileno(fptr->f), rp);
	    if (READ_DATA_PENDING(fptr->f)) { /* check for buffered data */
		pending++;
		FD_SET(fileno(fptr->f), &pset);
	    }
	    if (max < fileno(fptr->f)) max = fileno(fptr->f);
	}
	if (pending) {		/* no blocking if there's buffered data */
	    timerec.tv_sec = timerec.tv_usec = 0;
	    tp = &timerec;
	}
    }
    else
	rp = 0;

    if (!NIL_P(write)) {
	Check_Type(write, T_ARRAY);
	wp = &wset;
	FD_ZERO(wp);
	for (i=0; i<RARRAY(write)->len; i++) {
	    GetOpenFile(rb_io_get_io(RARRAY(write)->ptr[i]), fptr);
	    FD_SET(fileno(fptr->f), wp);
	    if (max < fileno(fptr->f)) max = fileno(fptr->f);
	    if (fptr->f2) {
		FD_SET(fileno(fptr->f2), wp);
		if (max < fileno(fptr->f2)) max = fileno(fptr->f2);
	    }
	}
    }
    else
	wp = 0;

    if (!NIL_P(except)) {
	Check_Type(except, T_ARRAY);
	ep = &eset;
	FD_ZERO(ep);
	for (i=0; i<RARRAY(except)->len; i++) {
	    GetOpenFile(rb_io_get_io(RARRAY(except)->ptr[i]), fptr);
	    FD_SET(fileno(fptr->f), ep);
	    if (max < fileno(fptr->f)) max = fileno(fptr->f);
	    if (fptr->f2) {
		FD_SET(fileno(fptr->f2), ep);
		if (max < fileno(fptr->f2)) max = fileno(fptr->f2);
	    }
	}
    }
    else {
	ep = 0;
    }

    max++;

    n = rb_thread_select(max, rp, wp, ep, tp);
    if (n < 0) {
	rb_sys_fail(0);
    }
    if (!pending && n == 0) return Qnil; /* returns nil on timeout */

    res = rb_ary_new2(3);
    rb_ary_push(res, rp?rb_ary_new():rb_ary_new2(0));
    rb_ary_push(res, wp?rb_ary_new():rb_ary_new2(0));
    rb_ary_push(res, ep?rb_ary_new():rb_ary_new2(0));

    if (interrupt_flag == 0) {
	if (rp) {
	    list = RARRAY(res)->ptr[0];
	    for (i=0; i< RARRAY(read)->len; i++) {
		GetOpenFile(rb_io_get_io(RARRAY(read)->ptr[i]), fptr);
		if (FD_ISSET(fileno(fptr->f), rp)
		    || FD_ISSET(fileno(fptr->f), &pset)) {
		    rb_ary_push(list, RARRAY(read)->ptr[i]);
		}
	    }
	}

	if (wp) {
	    list = RARRAY(res)->ptr[1];
	    for (i=0; i< RARRAY(write)->len; i++) {
		GetOpenFile(rb_io_get_io(RARRAY(write)->ptr[i]), fptr);
		if (FD_ISSET(fileno(fptr->f), wp)) {
		    rb_ary_push(list, RARRAY(write)->ptr[i]);
		}
		else if (fptr->f2 && FD_ISSET(fileno(fptr->f2), wp)) {
		    rb_ary_push(list, RARRAY(write)->ptr[i]);
		}
	    }
	}

	if (ep) {
	    list = RARRAY(res)->ptr[2];
	    for (i=0; i< RARRAY(except)->len; i++) {
		GetOpenFile(rb_io_get_io(RARRAY(except)->ptr[i]), fptr);
		if (FD_ISSET(fileno(fptr->f), ep)) {
		    rb_ary_push(list, RARRAY(except)->ptr[i]);
		}
		else if (fptr->f2 && FD_ISSET(fileno(fptr->f2), ep)) {
		    rb_ary_push(list, RARRAY(except)->ptr[i]);
		}
	    }
	}
    }

    return res;			/* returns an empty array on interrupt */
}

#if !defined(MSDOS) && !defined(__human68k__)
static int
io_cntl(fd, cmd, narg, io_p)
    int fd, cmd, io_p;
    long narg;
{
    int retval;

#ifdef HAVE_FCNTL
    TRAP_BEG;
# if defined(__CYGWIN__)
    retval = io_p?ioctl(fd, cmd, (void*)narg):fcntl(fd, cmd, narg);
# else
    retval = io_p?ioctl(fd, cmd, narg):fcntl(fd, cmd, narg);
# endif
    TRAP_END;
#else
    if (!io_p) {
	rb_notimplement();
    }
    TRAP_BEG;
    retval = ioctl(fd, cmd, narg);
    TRAP_END;
#endif
    return retval;
}
#endif

static VALUE
rb_io_ctl(io, req, arg, io_p)
    VALUE io, req, arg;
    int io_p;
{
#if !defined(MSDOS) && !defined(__human68k__)
    int cmd = NUM2ULONG(req);
    OpenFile *fptr;
    long len = 0;
    long narg = 0;
    int retval;

    rb_secure(2);
    GetOpenFile(io, fptr);

    if (NIL_P(arg) || arg == Qfalse) {
	narg = 0;
    }
    else if (FIXNUM_P(arg)) {
	narg = FIX2LONG(arg);
    }
    else if (arg == Qtrue) {
	narg = 1;
    }
    else if (rb_obj_is_kind_of(arg, rb_cInteger)) {
	narg = NUM2LONG(arg);
    }
    else {
	StringValue(arg);

#ifdef IOCPARM_MASK
#ifndef IOCPARM_LEN
#define IOCPARM_LEN(x)  (((x) >> 16) & IOCPARM_MASK)
#endif
#endif
#ifdef IOCPARM_LEN
	len = IOCPARM_LEN(cmd);	/* on BSDish systems we're safe */
#else
	len = 256;		/* otherwise guess at what's safe */
#endif
	rb_str_modify(arg);

	if (len <= RSTRING(arg)->len) {
	    len = RSTRING(arg)->len;
	}
	if (RSTRING(arg)->len < len) {
	    rb_str_resize(arg, len+1);
	}
	RSTRING(arg)->ptr[len] = 17;	/* a little sanity check here */
	narg = (long)RSTRING(arg)->ptr;
    }
    retval = io_cntl(fileno(fptr->f), cmd, narg, io_p);
    if (retval < 0) rb_sys_fail(fptr->path);
    if (TYPE(arg) == T_STRING && RSTRING(arg)->ptr[len] != 17) {
	rb_raise(rb_eArgError, "return value overflowed string");
    }

    if (fptr->f2 && fileno(fptr->f) != fileno(fptr->f2)) {
	/* call on f2 too; ignore result */
	io_cntl(fileno(fptr->f2), cmd, narg, io_p);
    }

    return INT2NUM(retval);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

static VALUE
rb_io_ioctl(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE req, arg;

    rb_scan_args(argc, argv, "11", &req, &arg);
    return rb_io_ctl(io, req, arg, 1);
}

static VALUE
rb_io_fcntl(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
#ifdef HAVE_FCNTL
    VALUE req, arg;

    rb_scan_args(argc, argv, "11", &req, &arg);
    return rb_io_ctl(io, req, arg, 0);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

static VALUE
rb_f_syscall(argc, argv)
    int argc;
    VALUE *argv;
{
#if defined(HAVE_SYSCALL) && !defined(__CHECKER__)
#ifdef atarist
    unsigned long arg[14]; /* yes, we really need that many ! */
#else
    unsigned long arg[8];
#endif
    int retval = -1;
    int i = 1;
    int items = argc - 1;

    /* This probably won't work on machines where sizeof(long) != sizeof(int)
     * or where sizeof(long) != sizeof(char*).  But such machines will
     * not likely have syscall implemented either, so who cares?
     */

    rb_secure(2);
    if (argc == 0)
	rb_raise(rb_eArgError, "too few arguments for syscall");
    arg[0] = NUM2LONG(argv[0]); argv++;
    while (items--) {
	if (FIXNUM_P(*argv)) {
	    arg[i] = (unsigned long)NUM2LONG(*argv);
	}
	else {
	    VALUE v = *argv;

	    StringValue(v);
	    rb_str_modify(v);
	    arg[i] = (unsigned long)RSTRING(v)->ptr;
	}
	argv++;
	i++;
    }
    TRAP_BEG;
    switch (argc) {
      case 1:
	retval = syscall(arg[0]);
	break;
      case 2:
	retval = syscall(arg[0],arg[1]);
	break;
      case 3:
	retval = syscall(arg[0],arg[1],arg[2]);
	break;
      case 4:
	retval = syscall(arg[0],arg[1],arg[2],arg[3]);
	break;
      case 5:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4]);
	break;
      case 6:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5]);
	break;
      case 7:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6]);
	break;
      case 8:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7]);
	break;
#ifdef atarist
      case 9:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8]);
	break;
      case 10:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8], arg[9]);
	break;
      case 11:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8], arg[9], arg[10]);
	break;
      case 12:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8], arg[9], arg[10], arg[11]);
	break;
      case 13:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8], arg[9], arg[10], arg[11], arg[12]);
	break;
      case 14:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8], arg[9], arg[10], arg[11], arg[12], arg[13]);
	break;
#endif /* atarist */
    }
    TRAP_END;
    if (retval < 0) rb_sys_fail(0);
    return INT2NUM(retval);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

static VALUE
rb_io_s_pipe()
{
#ifndef __human68k__
    int pipes[2];
    VALUE r, w;

#ifdef NT
    if (_pipe(pipes, 1024, O_BINARY) == -1)
#else
    if (pipe(pipes) == -1)
#endif
	rb_sys_fail(0);

    r = prep_stdio(rb_fdopen(pipes[0], "r"), FMODE_READABLE, rb_cIO);
    w = prep_stdio(rb_fdopen(pipes[1], "w"), FMODE_WRITABLE|FMODE_SYNC, rb_cIO);

    return rb_assoc_new(r, w);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

struct foreach_arg {
    int argc;
    VALUE sep;
    VALUE io;
    OpenFile *fptr;
};

static VALUE
io_s_foreach(arg)
    struct foreach_arg *arg;
{
    VALUE str;

    while (!NIL_P(str = rb_io_getline(arg->sep, arg->fptr))) {
	rb_yield(str);
    }
    return Qnil;
}

static VALUE
rb_io_s_foreach(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE fname, io;
    OpenFile *fptr;
    struct foreach_arg arg;

    rb_scan_args(argc, argv, "11", &fname, &arg.sep);
    SafeStringValue(fname);

    if (argc == 1) {
	arg.sep = rb_default_rs;
    }
    io = rb_io_open(RSTRING(fname)->ptr, "r");
    if (NIL_P(io)) return Qnil;
    GetOpenFile(io, fptr);
    arg.fptr = fptr;

    return rb_ensure(io_s_foreach, (VALUE)&arg, rb_io_close, io);
}

static VALUE
io_s_readlines(arg)
    struct foreach_arg *arg;
{
    return rb_io_readlines(arg->argc, &arg->sep, arg->io);
}

static VALUE
rb_io_s_readlines(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE fname;
    struct foreach_arg arg;

    rb_scan_args(argc, argv, "11", &fname, &arg.sep);
    SafeStringValue(fname);

    arg.argc = argc - 1;
    arg.io = rb_io_open(RSTRING(fname)->ptr, "r");
    if (NIL_P(arg.io)) return Qnil;
    return rb_ensure(io_s_readlines, (VALUE)&arg, rb_io_close, arg.io);
}

static VALUE
io_s_read(arg)
    struct foreach_arg *arg;
{
    return io_read(arg->argc, &arg->sep, arg->io);
}

static VALUE
rb_io_s_read(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE fname, offset;
    struct foreach_arg arg;

    rb_scan_args(argc, argv, "12", &fname, &arg.sep, &offset);
    SafeStringValue(fname);

    arg.argc = argc ? 1 : 0;
    arg.io = rb_io_open(RSTRING(fname)->ptr, "r");
    if (NIL_P(arg.io)) return Qnil;
    if (!NIL_P(offset)) {
	rb_io_seek(arg.io, offset, SEEK_SET);
    }
    return rb_ensure(io_s_read, (VALUE)&arg, rb_io_close, arg.io);
}

static VALUE
argf_tell()
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, "no stream to tell");
    }

    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_tell(current_file);
}

static VALUE
argf_seek_m(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, "no stream to seek");
    }

    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_seek_m(argc, argv, current_file);
}

static VALUE
argf_set_pos(self, offset)
     VALUE self, offset;
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, "no stream to set position");
    }

    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_set_pos(current_file, offset);
}

static VALUE
argf_rewind()
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, "no stream to rewind");
    }
    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_rewind(current_file);
}

static VALUE
argf_fileno()
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, "no stream");
    }
    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_fileno(current_file);
}

static VALUE
argf_to_io()
{
    return current_file;
}

static VALUE
argf_read(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE tmp, str;
    long len = 0;

    if (argc == 1) len = NUM2LONG(argv[0]);
    str = Qnil;

  retry:
    if (!next_argv()) return str;
    if (TYPE(current_file) != T_FILE) {
	tmp = argf_forward();
	StringValue(tmp);
    }
    else {
	tmp = io_read(argc, argv, current_file);
    }
    if (NIL_P(tmp) && next_p != -1) {
	any_close(current_file);
	next_p = 1;
	goto retry;
    }
    if (NIL_P(tmp) || RSTRING(tmp)->len == 0) return str;
    else if (NIL_P(str)) str = tmp;
    else rb_str_append(str, tmp);
    if (argc == 0) {
	goto retry;
    }
    if (RSTRING(tmp)->len < len) {
	len -= RSTRING(tmp)->len;
	argv[0] = LONG2FIX(len);
	goto retry;
    }

    return str;
}

static VALUE
argf_getc()
{
    VALUE byte;

  retry:
    if (!next_argv()) return Qnil;
    if (TYPE(current_file) != T_FILE) {
	byte = rb_funcall3(current_file, rb_intern("getc"), 0, 0);
    }
    else {
	byte = rb_io_getc(current_file);
    }
    if (NIL_P(byte) && next_p != -1) {
	any_close(current_file);
	next_p = 1;
	goto retry;
    }

    return byte;
}

static VALUE
argf_readchar()
{
    VALUE c = argf_getc();

    if (NIL_P(c)) {
	rb_eof_error();
    }
    return c;
}

static VALUE
argf_eof()
{
    if (!next_argv()) return Qtrue;
    if (next_p == 1) {
	return Qtrue;
    }
    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    if (rb_io_eof(current_file)) {
	next_p = 1;
	return Qtrue;
    }
    return Qfalse;
}

static VALUE
argf_each_line(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE str;

    while (RTEST(str = argf_getline(argc, argv))) {
	rb_yield(str);
    }
    return argf;
}

static VALUE
argf_each_byte()
{
    VALUE byte;

    while (!NIL_P(byte = argf_getc())) {
	rb_yield(byte);
    }
    return Qnil;
}

static VALUE
argf_filename()
{
    next_argv();
    return filename;
}

static VALUE
argf_file()
{
    next_argv();
    return current_file;
}

static VALUE
argf_binmode()
{
    binmode = 1;
    next_argv();
    if (TYPE(current_file) != T_FILE) {
	argf_forward();
    }
    else {
	rb_io_binmode(current_file);
    }
    return argf;
}

static VALUE
argf_skip()
{
    if (next_p != -1) {
	any_close(current_file);
	next_p = 1;
    }
    return argf;
}

static VALUE
argf_close()
{
    any_close(current_file);
    if (next_p != -1) {
	next_p = 1;
    }
    gets_lineno = 0;
    return argf;
}

static VALUE
argf_closed()
{
    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_closed(current_file);
}

static VALUE
opt_i_get()
{
    if (!ruby_inplace_mode) return Qnil;
    return rb_str_new2(ruby_inplace_mode);
}

static void
opt_i_set(val)
    VALUE val;
{
    if (!RTEST(val)) {
	if (ruby_inplace_mode) free(ruby_inplace_mode);
	ruby_inplace_mode = 0;
	return;
    }
    StringValue(val);
    if (ruby_inplace_mode) free(ruby_inplace_mode);
    ruby_inplace_mode = 0;
    ruby_inplace_mode = strdup(RSTRING(val)->ptr);
}

void
Init_IO()
{
    rb_eIOError = rb_define_class("IOError", rb_eStandardError);
    rb_eEOFError = rb_define_class("EOFError", rb_eIOError);

    id_write = rb_intern("write");

    rb_define_global_function("syscall", rb_f_syscall, -1);

    rb_define_global_function("open", rb_f_open, -1);
    rb_define_global_function("printf", rb_f_printf, -1);
    rb_define_global_function("print", rb_f_print, -1);
    rb_define_global_function("putc", rb_f_putc, 1);
    rb_define_global_function("puts", rb_f_puts, -1);
    rb_define_global_function("gets", rb_f_gets, -1);
    rb_define_global_function("readline", rb_f_readline, -1);
    rb_define_global_function("getc", rb_f_getc, 0);
    rb_define_global_function("select", rb_f_select, -1);

    rb_define_global_function("readlines", rb_f_readlines, -1);

    rb_define_global_function("`", rb_f_backquote, 1);

    rb_define_global_function("p", rb_f_p, -1);
    rb_define_method(rb_mKernel, "display", rb_obj_display, -1);

    rb_cIO = rb_define_class("IO", rb_cObject);
    rb_include_module(rb_cIO, rb_mEnumerable);

    rb_define_singleton_method(rb_cIO, "allocate", rb_io_s_alloc, 0);
    rb_define_singleton_method(rb_cIO, "new", rb_io_s_new, -1);
    rb_define_singleton_method(rb_cIO, "open",  rb_io_s_open, -1);
    rb_define_singleton_method(rb_cIO, "sysopen",  rb_io_s_sysopen, -1);
    rb_define_singleton_method(rb_cIO, "for_fd", rb_class_new_instance, -1);
    rb_define_singleton_method(rb_cIO, "popen", rb_io_s_popen, -1);
    rb_define_singleton_method(rb_cIO, "foreach", rb_io_s_foreach, -1);
    rb_define_singleton_method(rb_cIO, "readlines", rb_io_s_readlines, -1);
    rb_define_singleton_method(rb_cIO, "read", rb_io_s_read, -1);
    rb_define_singleton_method(rb_cIO, "select", rb_f_select, -1);
    rb_define_singleton_method(rb_cIO, "pipe", rb_io_s_pipe, 0);

    rb_define_method(rb_cIO, "initialize", rb_io_initialize, -1);

    rb_output_fs = Qnil;
    rb_define_hooked_variable("$,", &rb_output_fs, 0, rb_str_setter);

    rb_rs = rb_default_rs = rb_str_new2("\n");
    rb_output_rs = Qnil;
    rb_global_variable(&rb_default_rs);
    OBJ_FREEZE(rb_default_rs);	/* avoid modifying RS_default */
    rb_define_variable("$/", &rb_rs);
    rb_define_variable("$-0", &rb_rs);
    rb_define_variable("$\\", &rb_output_rs);

    rb_define_hooked_variable("$.", &lineno, 0, lineno_setter);
    rb_define_virtual_variable("$_", rb_lastline_get, rb_lastline_set);

    rb_define_method(rb_cIO, "become", rb_io_become, 1);
    rb_define_method(rb_cIO, "reopen", rb_io_reopen, -1);

    rb_define_method(rb_cIO, "print", rb_io_print, -1);
    rb_define_method(rb_cIO, "putc", rb_io_putc, 1);
    rb_define_method(rb_cIO, "puts", rb_io_puts, -1);
    rb_define_method(rb_cIO, "printf", rb_io_printf, -1);

    rb_define_method(rb_cIO, "each",  rb_io_each_line, -1);
    rb_define_method(rb_cIO, "each_line",  rb_io_each_line, -1);
    rb_define_method(rb_cIO, "each_byte",  rb_io_each_byte, 0);

    rb_define_method(rb_cIO, "syswrite", rb_io_syswrite, 1);
    rb_define_method(rb_cIO, "sysread",  rb_io_sysread, 1);

    rb_define_method(rb_cIO, "fileno", rb_io_fileno, 0);
    rb_define_alias(rb_cIO, "to_i", "fileno");
    rb_define_method(rb_cIO, "to_io", rb_io_to_io, 0);

    rb_define_method(rb_cIO, "fsync",   rb_io_fsync, 0);
    rb_define_method(rb_cIO, "sync",   rb_io_sync, 0);
    rb_define_method(rb_cIO, "sync=",  rb_io_set_sync, 1);

    rb_define_method(rb_cIO, "lineno",   rb_io_lineno, 0);
    rb_define_method(rb_cIO, "lineno=",  rb_io_set_lineno, 1);

    rb_define_method(rb_cIO, "readlines",  rb_io_readlines, -1);

    rb_define_method(rb_cIO, "read",  io_read, -1);
    rb_define_method(rb_cIO, "write", io_write, 1);
    rb_define_method(rb_cIO, "gets",  rb_io_gets_m, -1);
    rb_define_method(rb_cIO, "readline",  rb_io_readline, -1);
    rb_define_method(rb_cIO, "getc",  rb_io_getc, 0);
    rb_define_method(rb_cIO, "readchar",  rb_io_readchar, 0);
    rb_define_method(rb_cIO, "ungetc",rb_io_ungetc, 1);
    rb_define_method(rb_cIO, "<<",    rb_io_addstr, 1);
    rb_define_method(rb_cIO, "flush", rb_io_flush, 0);
    rb_define_method(rb_cIO, "tell", rb_io_tell, 0);
    rb_define_method(rb_cIO, "seek", rb_io_seek_m, -1);
    rb_define_const(rb_cIO, "SEEK_SET", INT2FIX(SEEK_SET));
    rb_define_const(rb_cIO, "SEEK_CUR", INT2FIX(SEEK_CUR));
    rb_define_const(rb_cIO, "SEEK_END", INT2FIX(SEEK_END));
    rb_define_method(rb_cIO, "rewind", rb_io_rewind, 0);
    rb_define_method(rb_cIO, "pos", rb_io_tell, 0);
    rb_define_method(rb_cIO, "pos=", rb_io_set_pos, 1);
    rb_define_method(rb_cIO, "eof", rb_io_eof, 0);
    rb_define_method(rb_cIO, "eof?", rb_io_eof, 0);

    rb_define_method(rb_cIO, "close", rb_io_close_m, 0);
    rb_define_method(rb_cIO, "closed?", rb_io_closed, 0);
    rb_define_method(rb_cIO, "close_read", rb_io_close_read, 0);
    rb_define_method(rb_cIO, "close_write", rb_io_close_write, 0);

    rb_define_method(rb_cIO, "isatty", rb_io_isatty, 0);
    rb_define_method(rb_cIO, "tty?", rb_io_isatty, 0);
    rb_define_method(rb_cIO, "binmode",  rb_io_binmode, 0);
    rb_define_method(rb_cIO, "sysseek", rb_io_sysseek, -1);

    rb_define_method(rb_cIO, "ioctl", rb_io_ioctl, -1);
    rb_define_method(rb_cIO, "fcntl", rb_io_fcntl, -1);
    rb_define_method(rb_cIO, "pid", rb_io_pid, 0);
    rb_define_method(rb_cIO, "inspect",  rb_io_inspect, 0);

    rb_stdin = orig_stdin = prep_stdio(stdin, FMODE_READABLE, rb_cIO);
    rb_define_hooked_variable("$stdin", &rb_stdin, 0, set_stdin);
    rb_stdout = orig_stdout = prep_stdio(stdout, FMODE_WRITABLE, rb_cIO);
    rb_define_hooked_variable("$stdout", &rb_stdout, 0, set_stdout);
    rb_stderr = orig_stderr = prep_stdio(stderr, FMODE_WRITABLE, rb_cIO);
    rb_define_hooked_variable("$stderr", &rb_stderr, 0, set_stderr);
    rb_defout = rb_stdout;
    rb_define_hooked_variable("$>", &rb_defout, 0, rb_io_defset);
    rb_define_hooked_variable("$defout", &rb_defout, 0, rb_io_defset);

    rb_define_global_const("STDIN", rb_stdin);
    rb_define_global_const("STDOUT", rb_stdout);
    rb_define_global_const("STDERR", rb_stderr);

    argf = rb_obj_alloc(rb_cObject);
    rb_extend_object(argf, rb_mEnumerable);

    rb_define_readonly_variable("$<", &argf);
    rb_define_global_const("ARGF", argf);

    rb_define_singleton_method(argf, "fileno", argf_fileno, 0);
    rb_define_singleton_method(argf, "to_i", argf_fileno, 0);
    rb_define_singleton_method(argf, "to_io", argf_to_io, 0);
    rb_define_singleton_method(argf, "each",  argf_each_line, -1);
    rb_define_singleton_method(argf, "each_line",  argf_each_line, -1);
    rb_define_singleton_method(argf, "each_byte",  argf_each_byte, 0);

    rb_define_singleton_method(argf, "read",  argf_read, -1);
    rb_define_singleton_method(argf, "readlines", rb_f_readlines, -1);
    rb_define_singleton_method(argf, "to_a", rb_f_readlines, -1);
    rb_define_singleton_method(argf, "gets", rb_f_gets, -1);
    rb_define_singleton_method(argf, "readline", rb_f_readline, -1);
    rb_define_singleton_method(argf, "getc", argf_getc, 0);
    rb_define_singleton_method(argf, "readchar", argf_readchar, 0);
    rb_define_singleton_method(argf, "tell", argf_tell, 0);
    rb_define_singleton_method(argf, "seek", argf_seek_m, -1);
    rb_define_singleton_method(argf, "rewind", argf_rewind, 0);
    rb_define_singleton_method(argf, "pos", argf_tell, 0);
    rb_define_singleton_method(argf, "pos=", argf_set_pos, 1);
    rb_define_singleton_method(argf, "eof", argf_eof, 0);
    rb_define_singleton_method(argf, "eof?", argf_eof, 0);
    rb_define_singleton_method(argf, "binmode", argf_binmode, 0);

    rb_define_singleton_method(argf, "to_s", argf_filename, 0);
    rb_define_singleton_method(argf, "filename", argf_filename, 0);
    rb_define_singleton_method(argf, "file", argf_file, 0);
    rb_define_singleton_method(argf, "skip", argf_skip, 0);
    rb_define_singleton_method(argf, "close", argf_close, 0);
    rb_define_singleton_method(argf, "closed?", argf_closed, 0);

    rb_define_singleton_method(argf, "lineno",   argf_lineno, 0);
    rb_define_singleton_method(argf, "lineno=",  argf_set_lineno, 1);

    current_file = rb_stdin;
    rb_global_variable(&current_file);
    filename = rb_str_new2("-");
    rb_define_readonly_variable("$FILENAME", &filename);

    rb_define_virtual_variable("$-i", opt_i_get, opt_i_set);

#if defined (NT) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__)
    atexit(pipe_atexit);
#endif

    Init_File();

    rb_define_method(rb_cFile, "initialize",  rb_file_initialize, -1);

    rb_file_const("RDONLY", INT2FIX(O_RDONLY));
    rb_file_const("WRONLY", INT2FIX(O_WRONLY));
    rb_file_const("RDWR", INT2FIX(O_RDWR));
    rb_file_const("APPEND", INT2FIX(O_APPEND));
    rb_file_const("CREAT", INT2FIX(O_CREAT));
    rb_file_const("EXCL", INT2FIX(O_EXCL));
#if defined(O_NDELAY) || defined(O_NONBLOCK)
#   ifdef O_NONBLOCK
    rb_file_const("NONBLOCK", INT2FIX(O_NONBLOCK));
#   else
    rb_file_const("NONBLOCK", INT2FIX(O_NDELAY));
#   endif
#endif
    rb_file_const("TRUNC", INT2FIX(O_TRUNC));
#ifdef O_NOCTTY
    rb_file_const("NOCTTY", INT2FIX(O_NOCTTY));
#endif
#ifdef O_BINARY
    rb_file_const("BINARY", INT2FIX(O_BINARY));
#endif
#ifdef O_SYNC
    rb_file_const("SYNC", INT2FIX(O_SYNC));
#endif
}
@


1.166
log
@* djgpp/*: sync with the latest.
* ext/extmk.rb, lib/mkmf.rb: flush $stdout.
* io.c (READ_DATA_PENDING_COUNT, READ_DATA_PENDING_PTR):
  undef these macros on DJGPP.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/10/09 06:12:54 $
d789 1
a789 1
	rb_raise(rb_eArgError, "negative length %d given", len);
@


1.165
log
@* gc.c (gc_sweep): also adjust heaps_limits when free unused heap
  page.  [ruby-core:00526]

* io.c (io_fflush): condition to retry can occur.

* io.c (io_write): returned 0 wrongly if no error occurred.
@
text
@d6 1
a6 1
  $Date: 2002/10/08 05:34:45 $
d144 1
d149 5
@


1.164
log
@* io.c (io_write): must check returned value from fwrite() before
  test with ferror().  (ruby-bugs-ja:PR#350)
@
text
@d6 1
a6 1
  $Date: 2002/10/02 14:59:25 $
d280 8
a287 4
    TRAP_BEG;
    n = fflush(f);
    TRAP_END;
    if (n == EOF) rb_sys_fail(fptr->path);
d381 1
a381 1
    for (; (r = fwrite(ptr, 1, n, f)) < n; ptr += r, n -= r) {
d1284 6
a1289 1
	n2 = fclose(fptr->f2);
a1290 1
	if (n2 < 0) e = errno;
d1294 4
a1297 1
	n1 = fclose(fptr->f);
@


1.163
log
@* configure.in (RUBY_CHECK_IO_NEED_FLUSH): check whether fflush()
  is needed.

* io.c (flush_before_seek): flush before seek if buffered data
  may remain.

* io.c (rb_io_check_readable): flush if the last operation was
  write.

* io.c (rb_io_check_writable): flush if the last operation was
  read.

* rubyio.h (FMODE_RBUF): added.
@
text
@d6 1
a6 1
  $Date: 2002/10/02 14:13:58 $
d369 1
a370 1
#ifdef __human68k__
d375 1
a375 1
	--n;
d377 1
a377 3
	r = fwrite(ptr, 1, n, f);
	ptr += r;
	n -= r;
d385 1
a386 1
    } while (n > 0);
@


1.162
log
@* io.c (rb_io_wait_readable): handle retryable errors.

* io.c (rb_io_wait_writable): ditto.

* ext/socket/socket.c (bsock_send): ditto.

* ext/socket/socket.c (s_recvfrom): ditto.

* ext/socket/socket.c (s_accept): ditto.

* ext/socket/socket.c (udp_send): ditto.

* ext/socket/getaddrinfo.c (afdl): made private structures constant.

* rubyio.h: prototype; rb_io_wait_readable(), rb_io_wait_writable().
@
text
@d6 1
a6 1
  $Date: 2002/09/30 11:31:28 $
d185 23
d215 6
d230 5
d439 1
a439 1
    pos = ftello(fptr->f);
d459 1
a459 1
    pos = fseeko(fptr->f, NUM2OFFT(offset), whence);
d490 1
a490 1
    pos = fseeko(fptr->f, NUM2OFFT(offset), SEEK_SET);
d504 1
a504 1
    if (fseeko(fptr->f, 0L, 0) != 0) rb_sys_fail(fptr->path);
d717 1
a717 1
	pos = ftello(fptr->f);
d742 1
a742 1
    pos = ftello(fptr->f);
d2244 1
a2244 1
	pos = ftello(orig->f);
d2278 2
a2279 2
	fseeko(fptr->f, pos, SEEK_SET);
	fseeko(orig->f, pos, SEEK_SET);
@


1.161
log
@* io.c (rb_io_inspect): not need to raise IOError for closed stream.  [ruby-talk:51871]
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/25 07:03:01 $
d253 1
a253 1
void
d258 21
a278 3
    FD_ZERO(&rfds);
    FD_SET(f, &rfds);
    rb_thread_select(f + 1, &rfds, NULL, NULL, NULL);
d281 1
a281 1
void
d286 21
a306 3
    FD_ZERO(&wfds);
    FD_SET(f, &wfds);
    rb_thread_select(f + 1, NULL, &wfds, NULL, NULL);
d347 1
a347 5
	    switch (errno) {
	      case EINTR:
#if defined(ERESTART)
	      case ERESTART:
#endif
a349 7
	      case EAGAIN:
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
	      case EWOULDBLOCK:
#endif
		clearerr(f);
		rb_io_wait_writable(fileno(f));
		continue;
a598 25
static void
io_read_retryable(f, path)
    FILE *f;
    const char *path;
{
    switch (errno) {
      case EINTR:
#if defined(ERESTART)
      case ERESTART:
#endif
	clearerr(f);
	break;
      case EAGAIN:
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
      case EWOULDBLOCK:
#endif
	clearerr(f);
	rb_io_wait_readable(fileno(f));
	break;
      default:
	rb_sys_fail(path);
	break;
    }
}

d639 3
d826 3
a828 1
		io_read_retryable(f, fptr->path);
d1141 3
a1143 1
		io_read_retryable(f, fptr->path);
d1174 3
a1176 1
	    io_read_retryable(f, fptr->path);
@


1.160
log
@* io.c (appendline): forget to terminate with nul.

* eval.c (ruby_run): should set toplevel visibility again here.

* eval.c (rb_eval): should not rely on ruby_class == rb_cObject
  check.   Besides allow implicit publicity for attribute set
  methods.

* parse.y (primary): need not to check class_nest, just set
  whether method is an attrset or not.

* string.c (rb_str_each_line): p might be at the top of the
  string.

* class.c (rb_make_metaclass): class of metaclass should be
  metaclass of superclass, unless class itself is a metaclass;
  class of metaclass of metaclass should point back to self.
  eh, confusing, isn't it.

* class.c (rb_singleton_class): check if its class is singleton
  AND attached to self.

* eval.c (rb_eval): should define class/module under ruby_cbase.

* eval.c (rb_eval): should set class/module path based on
  ruby_cbase, not ruby_class.

* eval.c (module_setup): use ruby_cbase instead of ruby_class.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/09/17 13:52:45 $
d558 2
a559 2
    GetOpenFile(obj, fptr);
    if (!fptr->path) return rb_any_to_s(obj);
@


1.159
log
@move struct timeval to missing.h
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/09/16 15:56:31 $
d795 1
@


1.158
log
@* io.c: add parameter prototype.
* re.c: ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/09/11 01:09:04 $
a60 11
#endif

#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
#else
#ifndef NT
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};
#endif
@


1.157
log
@retry on EINTR, ERESTART and EWOULDBLOCK.  [ruby-dev:17855], [ruby-dev:17878], [ruby-core:00444]
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/09/06 01:58:32 $
d2332 1
a2332 1
    VALUE io;
@


1.156
log
@* io.c (rb_io_puts): RSTRING(line)->ptr might be NULL.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/03 05:20:06 $
d264 20
d291 2
a292 1
    long n;
d308 3
d312 5
a316 10
    {
	register char *ptr = RSTRING(str)->ptr;
	n = RSTRING(str)->len;
	while (--n >= 0)
	    if (fputc(*ptr++, f) == EOF)
		break;
	n = ptr - RSTRING(str)->ptr;
    }
    if (n != RSTRING(str)->len && ferror(f))
	rb_sys_fail(fptr->path);
d318 21
a338 4
    n = fwrite(RSTRING(str)->ptr, 1, RSTRING(str)->len, f);
    if (n != RSTRING(str)->len && ferror(f)) {
	rb_sys_fail(fptr->path);
    }
d340 2
d585 24
d650 1
d656 1
d721 1
d833 2
a834 2
		if (errno == EINTR) continue;
		rb_sys_fail(fptr->path);
d1146 2
a1147 2
		if (errno == EINTR) continue;
		rb_sys_fail(fptr->path);
d1177 2
a1178 2
	    if (errno == EINTR) goto retry;
	    rb_sys_fail(fptr->path);
@


1.155
log
@	* variable.c (rb_copy_generic_ivar): remove old generic instance
	  variable table if it existes.

	* class.c (rb_make_metaclass): metaclass of a metaclass is a
	  metaclass itself.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/09/02 08:05:39 $
d2454 2
a2455 1
	if (RSTRING(line)->ptr[RSTRING(line)->len-1] != '\n') {
@


1.154
log
@read_all ftello (instead ftell) (ruby-core:392)
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/08/29 04:38:37 $
d180 1
d2274 1
@


1.153
log
@* io.c (read_all): should use off_t instead of long.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/08/28 14:36:38 $
d651 1
a651 1
    pos = ftell(fptr->f);
@


1.152
log
@* io.c (appendline): data was lost when raw mode.
@
text
@d6 1
a6 1
  $Date: 2002/08/28 09:41:58 $
d645 1
a645 1
    long pos = 0;
@


1.151
log
@adjust indet
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/28 08:05:23 $
d730 1
a730 1
	    long last = 0;
d732 1
d735 1
a735 1
		rb_str_resize(str, last + (c != EOF) + pending);
d738 2
a739 1
		*strp = str = rb_str_new(0, (c != EOF) + pending);
d746 10
@


1.150
log
@Int vs Long cleanup #3 (ruby-core:352)
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/27 08:31:06 $
d1851 1
a1851 1
    }
@


1.149
log
@* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.

* class.c (rb_mod_dup): need to preserve metaclass and flags.

* object.c (rb_cstr_to_dbl): had a buffer overrun.

* marshal.c (w_class): integrate singleton check into a funciton
  to follow DRY principle.

* marshal.c (w_uclass): should check singleton method.

* object.c (rb_obj_dup): dmark and dfree functions must be match
  for T_DATA type.

* object.c (rb_obj_dup): class of the duped object must be match
  to the class of the original.

* re.c (rb_reg_quote): do not escape \t, \f, \r, \n, for they are
  not regular expression metacharacters.

* time.c (time_s_alloc): use time_free instead of free (null check,
  also serves for type mark).

* time.c (time_s_at): check dfree function too.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/21 15:47:54 $
d558 1
a558 1
	int i = READ_DATA_PENDING_COUNT(f);
a601 1

d726 1
a726 1
	int pending = READ_DATA_PENDING_COUNT(f);
d800 1
a800 1
	int cnt;
@


1.148
log
@*.c: Int vs Long cleanup
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/21 08:30:05 $
d646 1
d652 1
d655 1
a655 1
	if (n == 0 && bytes == 0) {
d2254 1
a2254 1
rb_io_clone(io)
a2259 1
    VALUE clone = rb_obj_clone(io);
d2261 1
d3782 1
a3782 1
    rb_define_method(rb_cIO, "clone", rb_io_clone, 0);
@


1.147
log
@* eval.c (rb_thread_cleanup): should not modify the global
  variable curr_thread.
@
text
@d5 2
a6 2
  $Author: H_Konishi $
  $Date: 2002/08/20 13:03:22 $
d675 1
a675 1
    int n, len;
d686 1
a686 1
    len = NUM2INT(length);
d862 2
a863 1
	int rslen, rspara = 0;
d1350 1
a1350 1
    int n;
d1370 1
a1370 1
    return INT2FIX(n);
d1378 1
a1378 1
    int n, ilen;
d1381 1
a1381 1
    ilen = NUM2INT(len);
d2400 1
a2400 1
    int i;
d2983 2
a2984 1
    int i, max = 0, n;
d3145 1
a3145 1
    int len = 0;
d3156 1
a3156 1
	narg = FIX2INT(arg);
d3258 1
a3258 1
    arg[0] = NUM2INT(argv[0]); argv++;
d3261 1
a3261 1
	    arg[i] = (unsigned long)NUM2INT(*argv);
d3534 1
a3534 1
    int len = 0;
d3536 1
a3536 1
    if (argc == 1) len = NUM2INT(argv[0]);
d3561 1
a3561 1
	argv[0] = INT2FIX(len);
@


1.146
log
@* replace of check EPIPE error(in getc()) rutine on bcc32.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/20 07:36:01 $
d2381 3
a2383 4
    char c[2];
    c[0] = NUM2CHR(ch);
    c[1] = '\0';
    rb_io_write(io, rb_str_new(c, 1));
@


1.145
log
@* io.c (rb_io_putc): output via rb_io_write().

* re.c (rb_reg_initialize_m): frozen check should be moved here
  from rb_reg_initialize().
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/08/16 07:23:04 $
a590 3
#endif
#ifdef __BORLANDC__
		  case EPIPE:
@


1.144
log
@* io.c (NOFILE): define NOFILE as 64 if not defined.
* signal.c (sighandler_t): rename to sh_t on dietlibc.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/08/16 02:52:25 $
d2384 4
a2387 18
    OpenFile *fptr;
    FILE *f;
    int c = NUM2CHR(ch);

    rb_secure(4);
    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);
    f = GetWriteFile(fptr);

    if (fputc(c, f) == EOF)
	rb_sys_fail(fptr->path);
    if (fptr->mode & FMODE_SYNC) {
	io_fflush(f, fptr);
    }
    else {
	fptr->mode |= FMODE_WBUF;
    }

@


1.143
log
@* io.c (rb_io_fread): renamed from io_fread and made extern.

* marshal.c (r_bytes0): check if successfully read, use
  rb_io_fread() instead of fread() to be preemptive.
  (ruby-bugs-ja:PR#294, 295)

* rubyio.h (rb_io_fread): added.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2002/06/28 18:26:00 $
d79 3
a81 1
#else
@


1.142
log
@* io.c (pipe_finalize, pipe_popen): two-way pipe support for win32.

* win32/win32.c (ChildRecord, FindFreeChildSlot): ditto.

* win32/win32.c, win32/win32.h (pipe_exec): new function for two-way
  pipe support for win32.

* win32/win32.c, win32/win32.h (FindPipedChildSlot, rb_w32_popen,
  rb_w32_pclose): removed functions for two-way pipe support for win32.
@
text
@d5 2
a6 2
  $Author: H_Konishi $
  $Date: 2002/06/11 01:27:46 $
d545 2
a546 2
static long
io_fread(ptr, len, f)
d653 1
a653 1
	n = io_fread(RSTRING(str)->ptr+bytes, siz-bytes, fptr->f);
d697 1
a697 1
    n = io_fread(RSTRING(str)->ptr, len, fptr->f);
@


1.141
log
@new platform [bccwin32] merged.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/29 05:20:33 $
d1764 1
a1764 1
#if !defined (__CYGWIN__)
d1806 1
a1806 1
#if defined(NT) || defined(DJGPP) || defined(__human68k__) || defined(__VMS)
d1824 34
a1857 1
	return port;
d1943 1
@


1.140
log
@* parse.y: yyparse #defines moved from intern.h

* ruby.c (proc_options): access prefixed "ruby_yydebug".

* applied modifies to pacify some of gcc -Wall warnings.

* parse.y (arg): no more ugly hack for "**", so that "-2**2" to be
  parsed as "(-2)**2", whereas "- 2**2" or "-(2)**2" to be parsed
  as "-(2**2)".

* parse.y (yylex): '-2' to be literal fixnum. [new]

* time.c (time_succ): new method for Range support.

* time.c (time_arg): nil test against v[6] (usec).
@
text
@d6 1
a6 1
  $Date: 2002/05/23 05:35:26 $
d589 3
@


1.139
log
@* ruby.c (proc_options): removed "-*-" support for #! line.

* io.c (rb_io_s_sysopen): new method to get a raw file
  descriptor. [new]

* ext/socket/socket.c (tcp_sysaccept): new method to return an
  accepted socket fd (integer). [new]

* ext/socket/socket.c (unix_sysaccept,sock_sysaccept): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/05/20 04:33:59 $
d2084 1
a2084 1
    off_t pos;
d3511 1
a3511 1
    int len;
@


1.138
log
@* io.c (rb_io_clone): writing stream was not copied properly.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/02 07:50:36 $
d1969 1
a1969 1
    VALUE fname, vmode, file, perm;
d1981 1
a1981 1
	file = rb_file_sysopen_internal(io, path, flags, fmode);
d1985 1
a1985 1
	file = rb_file_open_internal(io, RSTRING(fname)->ptr, mode);
d2006 23
d3732 1
@


1.137
log
@* error.c: use HAVE_DECL_SYS_NERR instead of platform names.
@
text
@d6 1
a6 1
  $Date: 2002/04/24 04:54:13 $
d2230 1
a2230 1
    if (fptr->f2) {
d2234 1
a2234 1
	fptr->f = rb_fdopen(fd, "w");
@


1.136
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d6 1
a6 1
  $Date: 2002/04/18 08:46:18 $
d76 2
a77 2
/* EMX has sys/parm.h, but.. */
#if defined(HAVE_SYS_PARAM_H) && !defined(__EMX__)
@


1.135
log
@* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* io.c: complete off_t handling; missing argument for
  fptr_finalize(); polished rb_scan_args call.

* dir.c: wrap multi-statment macro by do { } while (0)

* eval.c, numeric,c, sprintf.c, util.c: ditto.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.
@
text
@d6 1
a6 1
  $Date: 2002/04/15 07:48:45 $
d268 1
a268 1
    int n;
d287 1
a287 1
	n = (int)RSTRING(str)->len;
d308 1
a308 1
    return INT2FIX(n);
d616 1
a616 2
    long bytes = 0;
    int n;
a624 2
	off_t pos;

d643 1
a643 1
    int n;
d650 1
a650 1
	n = io_fread(RSTRING(str)->ptr+bytes, (long)siz-bytes, fptr->f);
d1003 1
a1003 1
    VALUE rs, str;
d1452 11
a1462 8
    if (*m == 'b') {
	flags |= FMODE_BINMODE;
	m++;
    }

    if (*m == '+') {
	flags |= FMODE_READWRITE;
	if (m[1] != 0) goto error;
a1463 1
    else if (*m != 0) goto error;
d1472 1
a1472 1
    int flags;
d1517 3
a1519 1
    if (*m == 'b') {
d1521 1
a1521 1
	flags |= O_BINARY;
d1523 7
a1529 6
	m++;
    }

    if (*m == '+') {
	flags |= O_RDWR;
	if (m[1] != 0) goto error;
a1530 1
    else if (*m != 0) goto error;
a3557 2
    int first = first_p;

@


1.134
log
@* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* error.c (exc_initialize): should clear backtrace information.

* io.c (rb_io_fptr_cleanup): should close IO created by IO.new(fd).

* rubyio.h: remove FMODE_FDOPEN
@
text
@d6 1
a6 1
  $Date: 2002/04/12 08:45:02 $
d367 1
a367 1
    long pos;
d384 1
a384 1
    int whence;
d386 3
a388 3
    rb_scan_args(argc, argv, "11", &offset, &ptrname);
    if (argc == 1) whence = SEEK_SET;
    else whence = NUM2INT(ptrname);
d398 1
a398 1
    long pos;
d405 1
a405 1
    return INT2NUM(pos);
d1164 1
d1322 1
a1322 1
    int whence;
d1326 3
a1328 3
    rb_scan_args(argc, argv, "11", &offset, &ptrname);
    if (argc == 1) whence = SEEK_SET;
    else whence = NUM2INT(ptrname);
@


1.133
log
@* struct.c (rb_struct_select): fix typo.

* io.c (io_write): check error if written data is less than
  specified size to detect EPIPE.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/04/11 10:11:53 $
a1193 6
    if (fptr->mode & FMODE_FDOPEN) {
	if (fptr->mode & FMODE_WRITABLE) {
	    io_fflush(GetWriteFile(fptr), fptr);
	}
	return;
    }
d2618 1
a2618 1
    fp->mode = rb_io_modenum_flags(flags) | FMODE_FDOPEN;
@


1.132
log
@* io.c (remain_size): IO#read returns "" if file.size == 0.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/04/02 06:48:41 $
d293 1
a293 1
    if (n == 0 && ferror(f))
d297 1
a297 1
    if (n == 0 && ferror(f)) {
@


1.131
log
@* Makefile.in (CPPFLAGS): remove @@includedir@@.

* lib/mkmf.rb (create_makefile): ditto.

* ext/extmk.rb.in (create_makefile): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/04/01 08:31:45 $
a627 3
	if (st.st_size == 0) {
	    return 1;		/* force EOF */
	}
@


1.130
log
@* io.c (rb_io_fptr_cleanup): need flush even when io will not be
  closed.

* io.c (rb_io_initialize): was calling wrong function
  rb_io_mode_flags().
@
text
@d6 1
a6 1
  $Date: 2002/04/01 07:39:09 $
d1198 3
a1200 1
	io_fflush(GetWriteFile(fptr), fptr);
@


1.129
log
@* re.c (match_setter): it's OK to assign nil to $~.

* io.c (rb_io_fptr_cleanup): do not close IO created by for_fd().

* io.c (rb_io_initialize): mark IO created by for_fd

* ext/socket/socket.c (bsock_s_for_fd): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/29 14:50:09 $
d1197 4
a1200 1
    if (fptr->mode & FMODE_FDOPEN) return;
d2615 1
a2615 1
	flags = rb_io_mode_flags(RSTRING(mode)->ptr);
@


1.128
log
@* io.c (io_fflush): DRY patch from /Christoph applied.
@
text
@d6 1
a6 1
  $Date: 2002/03/28 09:17:51 $
d1197 1
d1473 1
a1473 1
rb_io_binmode_flags(mode)
d1500 1
a1500 1
rb_io_mode_binmode(mode)
d1538 1
a1538 1
rb_io_binmode_mode(flags, mode)
d1552 1
a1552 1
	*p++ = 'w';
d1682 2
a1683 2
    m = rb_io_binmode_mode(flags, mbuf);
    fptr->mode = rb_io_binmode_flags(flags);
d1927 1
a1927 1
	mode = rb_io_binmode_mode(FIX2INT(pmode), mbuf);
d1980 1
a1980 1
	flags = FIXNUM_P(vmode) ? NUM2INT(vmode) : rb_io_mode_binmode(StringValuePtr(vmode));
d2605 2
a2606 1
    char *m = "r";
d2608 3
a2610 1
    if (rb_scan_args(argc, argv, "11", &fnum, &mode) == 2) {
d2612 8
a2619 1
	m = RSTRING(mode)->ptr;
d2622 2
a2623 2
    fp->f = rb_fdopen(NUM2INT(fnum), m);
    fp->mode = rb_io_mode_flags(m);
d2661 1
a2661 1
	rb_warn("%s::new() does not take block; use %::open() instead",
@


1.127
log
@* ext/socket/socket.c (sock_addrinfo): should specify socktype
  from outside.

* io.c (argf_binmode): should call next_argv() to initialize ARGF.

* io.c (argf_filename): ditto.

* io.c (argf_file): ditto.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/03/27 05:55:01 $
d247 1
a247 1
io_fflush(f, path)
d249 1
a249 1
    const char *path;
d257 1
a257 1
    if (n == EOF) rb_sys_fail(path);
d302 1
a302 1
	io_fflush(f, fptr->path);
d336 2
a337 3
    
    io_fflush(f, fptr->path);
    fptr->mode &= ~FMODE_WBUF;
d486 2
a487 3
    
    io_fflush(f, fptr->path);
    fptr->mode &= ~FMODE_WBUF;
d1478 1
a1478 1
      case O_RDONLY:	
d1544 1
a1544 1
      case O_RDONLY:	
d2076 1
a2076 1
	io_fflush(orig->f2, orig->path);
d2079 1
a2079 1
	io_fflush(orig->f, orig->path);
a2080 1
    orig->mode &= ~FMODE_WBUF;
d2205 1
a2205 1
	io_fflush(orig->f2, orig->path);
d2208 1
a2208 1
	io_fflush(orig->f, orig->path);
a2209 1
    orig->mode &= ~FMODE_WBUF;
a2333 1
    fptr->mode |= FMODE_WBUF;
d2335 1
a2335 2
	io_fflush(f, fptr->path);
	fptr->mode &= ~FMODE_WBUF;
d2590 1
a2590 1
    
@


1.126
log
@* io.c (READ_DATA_PENDING): configure.in has supported for uClibc,
  so remove uClibc stuff.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/27 05:52:36 $
d258 1
a302 1
	fptr->mode &= ~FMODE_WBUF;
a2670 13
static VALUE
argf_binmode()
{
    if (TYPE(current_file) != T_FILE) {
	argf_forward();
    }
    else {
	rb_io_binmode(current_file);
    }
    binmode = 1;
    return argf;
}

d3598 1
d3605 1
d3607 14
@


1.125
log
@typo
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/27 05:27:57 $
a145 4
#elif defined(__UCLIBC__)
#  define READ_DATA_PENDING(fp) ((fp)->bufpos < (fp)->bufend)
#  define READ_DATA_PENDING_COUNT(fp) ((fp)->bufend - (fp)->bufpos)
#  define READ_DATA_PENDING_PTR(fp) ((fp)->bufpos)
@


1.124
log
@* io.c (rb_io_sysseek): new method based on a patch from Aristarkh
  A Zagorodnikov <xm@@bolotov-team.ru>. [new]

* io.c (READ_DATA_PENDING): use !feof(fp) for default behavior.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/25 14:50:40 $
d1340 1
a1340 1
	rb_raise(rb_eIOError, "syseek for buffered IO");
@


1.123
log
@* configure.in (FILE_READPTR): new.  for IO#gets improvement.

* io.c (READ_DATA_PENDING_PTR): ditto.

* io.c (remain_size): separated from read_all().

* io.c (read_all): argument chagend.

* io.c (appendline): new.  get a line and append to string.

* io.c (swallow): new.  swallow continuous line delimiters.

* io.c (rb_io_getline_fast): add delimiter argument.

* io.c (rb_io_getline): performance improvement.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/25 06:18:04 $
d98 4
d155 1
a155 1
#  define READ_DATA_PENDING(fp) ReadDataPending(fp)
d357 1
a357 9

#if SIZEOF_OFF_T > SIZEOF_LONG
# if !HAVE_LONG_LONG
#  error off_t is bigger than long, but you have no long long...
# endif
    return rb_ll2inum(pos);
#else
    return rb_int2inum(pos);
#endif
d1324 29
d3789 1
@


1.122
log
@* ext/socket/socket.c (bsock_do_not_rev_lookup_set): should not be
  allowed when $SAFE > 3.

* eval.c (rb_thread_ready): THREAD_TO_KILL threads should not turn
  into THREAD_RUNNABLE on wakeup.

* eval.c (rb_thread_list): THREAD_TO_KILL threads should be in the
  list.

* eval.c (thgroup_list): ditto; by moving gid clearance from
  rb_thread_cleanup().

* dir.c (fnmatch): "*/bar" (with FNM_PATHNAME flag) does not
  match "foo/bar".

* io.c (read_all): files on /proc filesystem with zero stat size,
  may have contents.

* ext/socket/socket.c (tcp_s_gethostbyname): refactored.

* ext/socket/socket.c (sock_s_gethostbyname): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/22 07:26:35 $
d128 1
d132 1
d137 3
d144 2
d153 5
d620 3
a622 3
static VALUE
read_all(port)
    VALUE port;
a623 2
    OpenFile *fptr;
    VALUE str = Qnil;
d629 1
a629 4
    GetOpenFile(port, fptr);
    rb_io_check_readable(fptr);

    if (feof(fptr->f)) return Qnil;
d639 1
a639 6
	    int c = getc(fptr->f);

	    if (c == EOF) {
		return rb_str_new(0, 0);
	    }
	    ungetc(c, fptr->f);
d649 13
a661 1
    str = rb_tainted_str_new(0, (long)siz);
d663 2
d693 3
d697 1
a697 1
	return read_all(io);
a703 2
    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
d722 2
a723 2
static VALUE
rb_io_getline_fast(fptr)
d725 2
d729 3
a731 2
    VALUE str = Qnil;
    int c;
d733 1
a733 1
    char *bp, *bpe = buf + sizeof buf - 3;
d735 1
a735 1
    int append = 0;
d737 24
a760 3
  again:
    bp = buf;
    for (;;) {
d762 1
d771 25
a795 1
	    break;
a796 2
	if ((*bp++ = c) == '\n') break;
	if (bp == bpe) break;
d798 4
a801 1
    cnt = bp - buf;
d803 37
a839 4
    if (c == EOF && !append && cnt == 0) {
	str = Qnil;
	goto return_gets;
    }
d841 7
a847 4
    if (append)
	rb_str_cat(str, buf, cnt);
    else
	str = rb_str_new(buf, cnt);
d849 1
a849 4
    if (c != EOF && RSTRING(str)->ptr[RSTRING(str)->len-1] != '\n') {
	append = 1;
	goto again;
    }
a850 1
  return_gets:
a864 1
    FILE *f;
a865 3
    int c, newline;
    char *rsptr;
    int rslen, rspara = 0;
d868 1
a868 2
	rsptr = 0;
	rslen = 0;
d871 1
a871 1
	return rb_io_getline_fast(fptr);
d874 4
d884 1
d886 2
a887 2
	else if (rslen == 1 && RSTRING(rs)->ptr[0] == '\n') {
	    return rb_io_getline_fast(fptr);
d892 1
a892 1
    }
d894 7
a900 83
    f = fptr->f;
    if (rspara) {
	do {
	    READ_CHECK(f);
	    TRAP_BEG;
	    c = getc(f);
	    TRAP_END;
	    if (c != '\n') {
		ungetc(c,f);
		break;
	    }
	} while (c != EOF);
    }

    newline = rslen ? rsptr[rslen - 1] : 0777;
    {
	char buf[8192];
	char *bp, *bpe = buf + sizeof buf - 3;
	int cnt;
	int append = 0;

      again:
	bp = buf;

	if (rslen) {
	    for (;;) {
		READ_CHECK(f);
		TRAP_BEG;
		c = getc(f);
		TRAP_END;
		if (c == EOF) {
		    if (ferror(f)) {
			if (errno == EINTR) continue;
			rb_sys_fail(fptr->path);
		    }
		    break;
		}
		if ((*bp++ = c) == newline) break;
		if (bp == bpe) break;
	    }
	    cnt = bp - buf;
	}
	else {
	    READ_CHECK(f);
	    cnt = io_fread(buf, sizeof(buf), f);
	    if (cnt == 0) {
		if (ferror(f)) rb_sys_fail(fptr->path);
		c = EOF;
	    }
	    else {
		c = 0;
	    }
	}

	if (c == EOF && !append && cnt == 0) {
	    str = Qnil;
	    goto return_gets;
	}

	if (append)
	    rb_str_cat(str, buf, cnt);
	else
	    str = rb_str_new(buf, cnt);

	if (c != EOF &&
	    (!rslen ||
	     RSTRING(str)->len < rslen ||
	     memcmp(RSTRING(str)->ptr+RSTRING(str)->len-rslen,rsptr,rslen))) {
	    append = 1;
	    goto again;
	}
    }

  return_gets:
    if (rspara) {
	while (c != EOF) {
	    READ_CHECK(f);
	    TRAP_BEG;
	    c = getc(f);
	    TRAP_END;
	    if (c != '\n') {
		ungetc(c, f);
		break;
d922 1
a922 1
    return rb_io_getline_fast(fptr);
d2897 1
d2902 3
a2904 1
    result = read_all(port);
@


1.121
log
@* the VMS support patch submitted by Akiyoshi, Masamichi
  <Masamichi.Akiyoshi@@jp.compaq.com> is merged.

* eval.c (exec_under): changing ruby_class is OK, but should not
  alter cbase.

* eval.c (yield_under_i): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/14 06:23:44 $
d629 2
d632 6
a637 2
	    getc(fptr->f);	/* force EOF */
	    return rb_str_new(0, 0);
d639 5
a643 7
	else {
	    off_t pos = ftello(fptr->f);
	    if (st.st_size > pos && pos >= 0) {
		siz = st.st_size - pos + 1;
		if (siz > LONG_MAX) {
		    rb_raise(rb_eIOError, "file too big for single read");
		}
@


1.120
log
@* re.c (rb_reg_match): should clear $~ if operand is nil.

* re.c (rb_reg_match2): ditto.

* configure: merge Jonathan Baker's large file support patch
  [ruby-talk:35316], with read_all patch in [ruby-talk:35470].

* eval.c (rb_f_abort): optional message argument that be printed
  on termination. [new]
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/02/27 04:29:10 $
d15 5
d139 2
d1653 1
a1653 1
#if defined (NT) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__)
d1695 1
a1695 1
#if defined (NT) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__)
d1758 1
a1758 1
#if defined(NT) || defined(DJGPP) || defined(__human68k__)
@


1.119
log
@* io.c (READ_DATA_PENDING): uClibc support.
* random.c (rand_init): ditto.
* ext/socket/{addinfo.h,getaddrinfo.c} (gai_strerror): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/22 10:28:45 $
d48 10
d329 1
a329 1
    long pos;
d332 1
a332 1
    pos = ftell(fptr->f);
d335 6
d342 1
d360 1
a360 1
    pos = fseek(fptr->f, NUM2LONG(offset), whence);
d391 1
a391 1
    pos = fseek(fptr->f, NUM2LONG(offset), SEEK_SET);
d400 1
a400 1
     VALUE io;
d405 1
a405 1
    if (fseek(fptr->f, 0L, 0) != 0) rb_sys_fail(fptr->path);
d608 1
a608 1
    long siz = BUFSIZ;
d627 1
a627 1
	    long pos = ftell(fptr->f);
d630 3
d636 1
a636 1
    str = rb_tainted_str_new(0, siz);
d639 1
a639 1
	n = io_fread(RSTRING(str)->ptr+bytes, siz-bytes, fptr->f);
d2009 1
a2009 1
    long pos;
d2020 1
a2020 1
	pos = ftell(orig->f);
d2055 2
a2056 2
	fseek(fptr->f, pos, SEEK_SET);
	fseek(orig->f, pos, SEEK_SET);
@


1.118
log
@* bignum.c (get2comp): need to specify to carry or not.

* io.c (rb_io_inspect): embed path info.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/02/20 06:33:24 $
d122 2
@


1.117
log
@* intern.h: prototypes; rb_io_addstr(), rb_io_printf(),
  rb_io_print(), rb_io_puts()

* io.c (rb_io_addstr): make extern.

* io.c (rb_io_printf): ditto.

* io.c (rb_io_print): ditto.

* io.c (rb_io_puts): ditto.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2002/02/20 04:42:49 $
d494 15
d3709 1
@


1.116
log
@* io.c (rb_io_close): return Qnil.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/20 04:31:50 $
d287 1
a287 1
static VALUE
d2156 1
a2156 1
static VALUE
d2187 1
a2187 1
static VALUE
a2264 2
static VALUE rb_io_puts _((int, VALUE*, VALUE));

d2282 1
a2282 1
static VALUE
@


1.115
log
@* hash.c (rb_any_cmp): should handle Qundef in keys.

* eval.c (remove_method): should not remove a empty method to
  implement "undef".

* eval.c (rb_eval): should allow singleton class def for
  true/false/nil.

* parse.y (str_extend): backslash escape was done wrong.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/02/19 04:19:06 $
d1169 1
a1169 1
    if (!fptr->f && !fptr->f2) return;
@


1.114
log
@* io.c (rb_io_ungetc): don't fail pushed EOF back.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/07 04:18:08 $
d1168 1
a1168 1
    if (!fptr) return;
@


1.113
log
@* io.c (io_write): flag when buffered write is done.

* io.c (fptr_finalize): do not raise error on EBADF if write
  buffer is empty.
@
text
@d6 1
a6 1
  $Date: 2002/02/06 07:30:13 $
d1086 1
a1086 1
    if (ungetc(cc, fptr->f) == EOF)
@


1.112
log
@* io.c (rb_io_readlines): avoid calling GetOpenFile() repeatedly.

* io.c (rb_io_each_line): ditto.

* io.c (argf_getline): ditto.

* process.c: should include <time.h> to get proper CLK_TCK.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/02/05 17:10:54 $
d271 4
d307 1
d459 1
d1112 1
d1115 1
a1115 1
    if (fptr->f && fptr->f != fptr->f2) {
d1118 6
a1123 2
	if (n1 < 0 && (e = errno) == EBADF && f1 == f2)
	    n1 = 0;
a1141 1
    fptr->f = fptr->f2 = 0;
d1272 3
d1991 1
d2121 1
d2246 1
d2249 4
@


1.111
log
@* io.c (fptr_finalize): ignore EBADF when f and f2 use same
  descriptor.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/05 07:56:29 $
a536 1

d652 2
a653 4
rb_io_gets_internal(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
d655 55
d711 1
a716 8
    VALUE rs;

    if (argc == 0) {
	rs = rb_rs;
    }
    else {
	rb_scan_args(argc, argv, "1", &rs);
    }
d723 1
a723 1
	return rb_io_gets(io);
d734 1
a734 1
	    return rb_io_gets(io);
a740 2
    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
a741 1

a841 7
    FILE *f;
    VALUE str = Qnil;
    int c;
    char buf[8192];
    char *bp, *bpe = buf + sizeof buf - 3;
    int cnt;
    int append = 0;
d845 1
a845 44
    f = fptr->f;

  again:
    bp = buf;
    for (;;) {
	READ_CHECK(f);
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c == EOF) {
	    if (ferror(f)) {
		if (errno == EINTR) continue;
		rb_sys_fail(fptr->path);
	    }
	    break;
	}
	if ((*bp++ = c) == '\n') break;
	if (bp == bpe) break;
    }
    cnt = bp - buf;

    if (c == EOF && !append && cnt == 0) {
	str = Qnil;
	goto return_gets;
    }

    if (append)
	rb_str_cat(str, buf, cnt);
    else
	str = rb_str_new(buf, cnt);

    if (c != EOF && RSTRING(str)->ptr[RSTRING(str)->len-1] != '\n') {
	append = 1;
	goto again;
    }

  return_gets:
    if (!NIL_P(str)) {
	fptr->lineno++;
	lineno = INT2FIX(fptr->lineno);
	OBJ_TAINT(str);
    }

    return str;
d854 12
a865 1
    VALUE str = rb_io_gets_internal(argc, argv, io);
d942 2
d945 8
d954 1
a954 1
    while (!NIL_P(line = rb_io_gets_internal(argc, argv, io))) {
d967 2
d970 9
a978 1
    while (!NIL_P(str = rb_io_gets_internal(argc, argv, io))) {
d2691 1
a2691 1
rb_f_gets_internal(argc, argv)
d2706 12
a2717 1
	line = rb_io_gets_internal(argc, argv, current_file);
d2735 1
a2735 1
    VALUE line = rb_f_gets_internal(argc, argv);
d2796 1
a2796 1
    while (!NIL_P(line = rb_f_gets_internal(argc, argv))) {
d3215 1
d3224 1
a3224 1
    while (!NIL_P(str = rb_io_gets_internal(arg->argc, &arg->sep, arg->io))) {
d3231 1
a3231 1
rb_io_s_foreach(argc, argv, io)
a3233 1
    VALUE io;
d3235 2
a3236 1
    VALUE fname;
d3242 9
a3250 4
    arg.argc = argc - 1;
    arg.io = rb_io_open(RSTRING(fname)->ptr, "r");
    if (NIL_P(arg.io)) return Qnil;
    return rb_ensure(io_s_foreach, (VALUE)&arg, rb_io_close, arg.io);
d3478 1
a3478 1
    while (RTEST(str = rb_f_gets_internal(argc, argv))) {
@


1.110
log
@* io.c (fptr_finalize): should raise error when fclose fails.

* eval.c (method_inspect): proper output format to distinguish
  methods and singleton methods.
@
text
@d6 1
a6 1
  $Date: 2002/01/23 07:30:39 $
d1078 1
a1078 1
    int n1 = 0, n2 = 0, e = 0;
a1079 4
    if (fptr->f) {
	n1 = fclose(fptr->f);
	if (n1 < 0) e = errno;
    }
d1081 1
d1083 7
d1092 1
a1092 1
	if (n2 == 0) errno = e;
d1651 1
a1651 1
    fptr_finalize(fptr);
@


1.109
log
@* array.c (Init_Array): remove Array#filter.

* object.c (rb_mod_initialize): should accept zero argument.

* object.c (rb_mod_cmp): should raise ArgumentError if
  inheritance/inclusion relation between two classes/modules is
  not defined. [new]

* io.c (rb_io_fsync): new method. [new]
@
text
@d6 1
a6 1
  $Date: 2002/01/21 07:44:05 $
d1075 1
a1075 1
fptr_finalize(fptr)
d1078 2
d1081 2
a1082 1
	fclose(fptr->f);
d1085 5
a1089 1
	fclose(fptr->f2);
d1094 1
a1094 1
rb_io_fptr_cleanup(fptr)
d1096 1
d1102 1
a1102 1
	fptr_finalize(fptr);
d1120 1
a1120 1
    rb_io_fptr_cleanup(fptr);
d1123 4
a1126 2
static void
rb_io_fptr_close(fptr)
a1127 1
{
d1130 1
d1135 1
a1135 1
    rb_io_fptr_cleanup(fptr);
a1136 1
}
a1137 8
VALUE
rb_io_close(io)
    VALUE io;
{
    OpenFile *fptr;

    fptr = RFILE(io)->fptr;
    rb_io_fptr_close(fptr);
d2496 8
@


1.108
log
@* eval.c (ruby_stop): should not trace error handler.

* signal.c (install_sighandler): do not install sighandler unless
  the old value is SIG_DFL.

* io.c (io_write): should not raise exception on O_NONBLOCK io.

* dir.c (dir_set_pos): seek should return dir, pos= should not.
@
text
@d6 1
a6 1
  $Date: 2002/01/18 14:23:06 $
d442 22
d3582 1
@


1.107
log
@* io.c (rb_io_s_new): block check moved from initialize to this
  method.

* io.c (rb_io_s_open): open should call initialize too. IO#for_fd
  also calls initialize. [new]

* error.c (rb_sys_fail): replace INT2FIX() by INT2NUM() since
  errno value may not fit in Fixnum size on Hurd.

* error.c (set_syserr): ditto.

* dir.c (dir_s_glob): returns nil if block given.

* io.c (rb_io_each_byte): should return self.

* io.c (rb_io_close_m): close check added.

* dir.c (dir_seek): should return pos.

* parse.y (fixpos): orig may be (NODE*)1, which should not be
  dereferenced.
@
text
@d6 1
a6 1
  $Date: 2002/01/11 09:18:50 $
d258 1
a258 1
		rb_sys_fail(fptr->path);
d261 1
a261 1
    if (ferror(f))
d265 1
a265 1
    if (ferror(f)) {
@


1.106
log
@* re.c (match_select): should propagate taintness.

* hash.c (rb_hash_set_default): Hash#default= should return the
  new value.

* string.c (rb_str_to_i): accepts optional base argument. [new]

* numeric.c (rb_fix2str): should not handle negative fixnum values
  int32 via calling sprintf() directly.
@
text
@d6 1
a6 1
  $Date: 2002/01/04 14:14:34 $
d966 1
a966 1
    return Qnil;
d1130 1
d1669 1
a1669 1
	return (VALUE)port;
d1752 1
a1752 1
	    return (VALUE)port;
d1839 1
a1839 1
rb_file_s_open(argc, argv, klass)
d1844 1
a1844 1
    VALUE io = rb_obj_alloc(klass);
a1845 2
    RFILE(io)->fptr = 0;
    rb_open_file(argc, argv, (VALUE)io);
d1847 1
a1847 1
	return rb_ensure(rb_yield, (VALUE)io, rb_io_close, (VALUE)io);
d1850 1
a1850 1
    return (VALUE)io;
d1865 1
a1865 1
    return rb_file_s_open(argc, argv, rb_cFile);
d2085 1
a2085 1
	rb_io_binmode((VALUE)clone);
d2088 1
a2088 1
    return (VALUE)clone;
d2415 1
a2415 1
    return (VALUE)io;
a2474 3
    if (rb_block_given_p()) {
	rb_warn("File::new() does not take block; use File::open() instead");
    }
d2480 1
a2480 1
rb_io_s_for_fd(argc, argv, klass)
d2485 2
a2486 4
    VALUE fnum, mode;
    OpenFile *fp;
    char *m = "r";
    VALUE io = rb_obj_alloc(klass);
d2488 2
a2489 3
    if (rb_scan_args(argc, argv, "11", &fnum, &mode) == 2) {
	SafeStringValue(mode);
	m = RSTRING(mode)->ptr;
d2491 1
a2491 6
    MakeOpenFile(io, fp);

    fp->f = rb_fdopen(NUM2INT(fnum), m);
    fp->mode = rb_io_mode_flags(m);

    return io;
d3515 3
a3517 2
    rb_define_singleton_method(rb_cIO, "for_fd", rb_io_s_for_fd, -1);
    rb_define_method(rb_cIO, "initialize", rb_io_initialize, -1);
d3525 2
a3666 1
    rb_define_singleton_method(rb_cFile, "open",  rb_file_s_open, -1);
@


1.105
log
@* process.c (rb_f_system): abandon vfork.

* io.c (pipe_open): ditto.

* defines.h: sparc linux needs different FLUSH_REGISTER_WINDOWS

* regex.c (re_search): abandon stclass optimization.

* bignum.c (rb_cstr2inum): deny "0_".

* bignum.c (rb_cstr2inum): allow "0\n" and so on.

* error.c (rb_invalid_str): utility function to show inspect()'ed
  string.

* bignum.c (rb_cstr2inum): prints invalid strings in inspect()'ed
  format.

* object.c (rb_Float): ditto.

* object.c (rb_convert_type): no longer use rb_rescue().

* re.c (rb_reg_search): initialize taint status of match object.
@
text
@d6 1
a6 1
  $Date: 2001/12/21 09:23:21 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
@


1.104
log
@* time.c (time_plus): result should not be negative unless
  NEGATIVE_TIME_T is defined.

* time.c (time_new_internal): should check tv_sec overflow too.

* time.c (time_timeval): should check time_t range when time is
  initialized from float.

* time.c (time_plus): uses modf(3).

* variable.c (rb_cvar_set): add frozen class/module check.

* variable.c (rb_cvar_declare): add frozen class/module check.

* re.c (match_to_a): should propagate taint.

* re.c (rb_reg_s_quote): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/12/19 07:48:30 $
a57 3
#ifdef HAVE_VFORK_H
#include <vfork.h>
#endif
d1686 1
a1686 1
    switch (pid = (doexec?vfork():fork())) {
@


1.103
log
@* eval.c (rb_mod_define_method): define_method should follow
  default method visibility.

* eval.c (rb_attr): should warn if the default method visibility
  is "module_function" (can be error).

* eval.c (rb_mod_define_method): should define class/module method
  also if the visibility is "module_function".

* eval.c (rb_mod_define_method): should call hook method
  "method_added", and "singleton_method_added".

* string.c: use RESIZE_CAPA for capacity change.

* ext/socket/socket.c (Init_socket): add listen method to
  TCPServer and UNIXServer.

* ext/socket/socket.c (bsock_send): should raise EWOULDBLOCK
  exception.

* ext/socket/socket.c (s_recvfrom): ditto.

* ext/socket/socket.c (s_accept): ditto.

* ext/socket/socket.c (udp_send): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/12/17 07:52:35 $
d525 1
a525 1
		rb_sys_fail(0);
@


1.102
log
@* intern.h: add prototypes.
  rb_gc_enable(), rb_gc_disable(), rb_gc_start(), rb_str_new5()
  rb_str_buf_append(), rb_str_buf_cat(), rb_str_buf_cat2(),
  rb_str_dup_frozen()

* ruby.h: added declaration.
  rb_defout, rb_stdin, rb_stdout, rb_stderr, ruby_errinfo

* rubyio.h: changed double include guard macro to RUBYIO_H.

* array.c (inspect_call): make static.

* eval.c (dvar_asgn): ditto.

* io.c (rb_io_close_read): ditto.

* lex.c (rb_reserved_word): ditto.

* ruby.c: (req_list_head, req_list_last): ditto.

* ruby.c (require_libraries): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/12/10 07:18:12 $
d515 5
a519 2
		if (errno == EINTR) continue;
		if (errno == EAGAIN) return len - n;
d521 1
a521 1
		if (errno == EWOULDBLOCK) return len - n;
d523 2
@


1.101
log
@* array.c (rb_ary_modify): should copy the internal buffer if the
  modifying buffer is shared.

* array.c (ary_make_shared): make an internal buffer of an array
  to be shared.

* array.c (rb_ary_shift): avoid sliding an internal buffer by
  using shared buffer.

* array.c (rb_ary_subseq): avoid copying the buffer.

* parse.y (gettable): should freeze __LINE__ string.

* io.c (rb_io_puts): old behavoir restored.  rationale: a) if you
  want to call to_s for arrays, you can just call print a, "\n".
  b) to_s wastes memory if array (and sum of its contents) is
  huge.  c) now any object that has to_ary is treated as an array,
  using rb_check_convert_type().

* hash.c (rb_hash_initialize): now accepts a block to calculate
  the default value. [new]

* hash.c (rb_hash_aref): call "default" method to get the value
  corrensponding to the non existing key.

* hash.c (rb_hash_default): get the default value based on the
  block given to 'new'.  Now it takes an optinal "key" argument.
  "default" became the method to get the value for non existing
  key.  Users may override "default" method to change the hash
  behavior.

* hash.c (rb_hash_set_default): clear the flag if a block is given
  to 'new'

* object.c (Init_Object): undef Data.allocate, left Data.new.

* ext/curses/curses.c (window_scrollok): use RTEST().

* ext/curses/curses.c (window_idlok): ditto.

* ext/curses/curses.c (window_keypad): ditto.

* ext/curses/curses.c (window_idlok): idlok() may return void on
  some platforms; so don't use return value.

* ext/curses/curses.c (window_scrollok): ditto for consistency.

* ext/curses/curses.c: replace FIX2INT() by typechecking NUM2INT().

* parse.y (str_extend): should not process immature #$x and
  #@@x interpolation, e.g #@@#@@ etc.

* enum.c (enum_sort_by): sort_by does not have to be stable always.

* enum.c (enum_sort_by): call qsort directly to gain performance.

* util.c (ruby_qsort): ruby_qsort(qs6) is now native thread safe.

* error.c (rb_sys_fail): it must be a bug if it's called when
  errno == 0.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 05:03:03 $
d1142 1
a1142 1
VALUE
@


1.100
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* massages: replace "wrong #" by "wrong number".

* marshal.c (w_float): output Infinity and NaN explicitly.

* marshal.c (r_object): support new explicit float format.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.

* array.c (rb_ary_join): dumped core if sep is not T_STRING nor T_NIL.

* array.c (rb_ary_join): buffer size calculattion was wrong.

* array.c (rb_ary_to_s): if rb_output_fs is nil, insert newlines
  between array elements (use rb_default_rs as newline litral)
  [experimental].

* gc.c (init_mark_stack): no need to clear mark_stack.

* gc.c (gc_mark_all): need to handle finalizer mark.

* gc.c (gc_mark_rest): use MEMCPY instead of memcpy.

* gc.c (rb_gc_mark): earlier const check to avoid pusing special
  constants into mark stack.

* numeric.c (fix_to_s): 'to_s' now takes optional argument to
  specify radix. [new]

* bignum.c (rb_big_to_s): ditto. [new]
@
text
@d6 1
a6 1
  $Date: 2001/10/30 08:43:25 $
d516 4
d2194 19
d2232 4
a2235 3
#if 0
	    if (TYPE(argv[i]) == T_ARRAY) {
		rb_warn("puts behavior changed for Array");
a2236 1
#endif
@


1.99
log
@* string.c (rb_str_chomp_bang): do smart chomp if $/ == '\n'.

* io.c (rb_io_puts): don't treat Array specially.

* bignum.c (rb_big_cmp): should convert bignum to float.

* eval.c (rb_f_eval): can't modify untainted binding.

* regex.c (re_compile_pattern): should preverve p0 value.
@
text
@d6 1
a6 1
  $Date: 2001/10/29 05:07:18 $
d2209 5
@


1.98
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* variable.c (rb_cvar_set): empty iv_tbl may cause infinite loop.

* variable.c (rb_cvar_get): ditto.

* variable.c (cvar_override_check): ditto.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.

* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.
@
text
@d6 1
a6 1
  $Date: 2001/10/16 03:27:06 $
a2189 19
static VALUE rb_io_puts _((int, VALUE*, VALUE));

static VALUE
io_puts_ary(ary, out)
    VALUE ary, out;
{
    VALUE tmp;
    int i;

    for (i=0; i<RARRAY(ary)->len; i++) {
	tmp = RARRAY(ary)->ptr[i];
	if (rb_inspecting_p(tmp)) {
	    tmp = rb_str_new2("[...]");
	}
	rb_io_puts(1, &tmp, out);
    }
    return Qnil;
}

d2205 1
a2205 2
	switch (TYPE(argv[i])) {
	  case T_NIL:
a2206 7
	    break;
	  case T_ARRAY:
	    rb_protect_inspect(io_puts_ary, argv[i], out);
	    continue;
	  default:
	    line = argv[i];
	    break;
d2208 3
a2210 1
	line = rb_obj_as_string(line);
@


1.97
log
@* string.c (rb_str_index): wrong increment for non alphanumeric
  string.
@
text
@d6 1
a6 1
  $Date: 2001/10/03 07:19:10 $
d3534 2
a3535 1
    rb_rs = rb_default_rs = rb_str_new2("\n"); rb_output_rs = Qnil;
@


1.96
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/09/05 06:54:53 $
a1233 4
    if (fptr->f == 0) {
	fprintf(stderr, "bingo\n");
	exit(1);
    }
@


1.95
log
@* re.c (Init_Regexp): to_s to be alias to inspect.

* parse.y (yylex): should support 'keyword='.

* ruby.c (proc_options): should not adjust argc/argv if -e option
  is supplied.
@
text
@d6 1
a6 1
  $Date: 2001/09/03 05:37:42 $
d1506 3
a1508 3
    NEWOBJ(io, struct RFile);
    OBJSETUP(io, rb_cFile, T_FILE);
    return rb_file_open_internal((VALUE)io, fname, mode);
d1538 3
a1540 3
    NEWOBJ(io, struct RFile);
    OBJSETUP(io, rb_cFile, T_FILE);
    return rb_file_sysopen_internal((VALUE)io, fname, flags, mode);
d1653 2
a1654 2
	NEWOBJ(port, struct RFile);
	OBJSETUP(port, rb_cIO, T_FILE);
d1727 2
a1728 2
	    NEWOBJ(port, struct RFile);
	    OBJSETUP(port, rb_cIO, T_FILE);
d1841 2
a1842 2
    NEWOBJ(io, struct RFile);
    OBJSETUP(io, klass, T_FILE);
a1843 1

d2045 1
a2045 3

    NEWOBJ(clone, struct RFile);
    CLONESETUP(clone, io);
d2409 1
a2409 2
    NEWOBJ(io, struct RFile);
    OBJSETUP(io, klass, T_FILE);
d2431 1
a2431 3
rb_io_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
a2437 1
    rb_obj_call_init((VALUE)io, argc, argv);
a2451 5
    if (RFILE(io)->fptr) {
	rb_io_close_m(io);
	free(RFILE(io)->fptr);
	RFILE(io)->fptr = 0;
    }
d2491 2
a2492 3
    NEWOBJ(io, struct RFile);
    OBJSETUP(io, klass, T_FILE);
    
d2502 1
a2502 1
    return (VALUE)io;
d3525 1
a3525 1
    rb_define_singleton_method(rb_cIO, "new", rb_io_s_new, -1);
@


1.94
log
@* ruby.c (proc_options): should not alter origargv[].

* ruby.c (set_arg0): long strings for $0 dumped core.

* ruby.c (set_arg0): use setprogtitle() if it's available.

* io.c (rb_io_popen): accept integer flags as mode.

* file.c (rb_find_file_ext): extension table can be supplied from
  outside.  renamed.

* eval.c (rb_f_require): replace rb_find_file_noext by
  rb_find_file_ext.

* eval.c (rb_provided): should also check feature without
  extension.

* numeric.c (flo_to_s): do not rely on decimal point to be '.'
@
text
@d6 1
a6 1
  $Date: 2001/08/23 06:02:15 $
d30 1
a30 1
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(sun)
d1383 1
@


1.93
log
@* eval.c (is_defined): should not dump core for "defined?(())".

* eval.c (umethod_bind): recv can be an instance of descender of
  oklass if oklass is a Module.

* hash.c (rb_hash_equal): check identiry equality first.

* file.c (group_member): should check real gid only.

* file.c (eaccess): do not cache euid, since effective euid may be
  changed via Process.euid=().

* file.c (eaccess): return -1 unless every specified access mode
  is permitted.

* eval.c (rb_eval): while/until returns the value which is given
  to break.

* parse.y (value_expr): using while/until/class/def as an
  expression is now gives a warning, not an error.

* range.c (range_eqq): should compare strings based on magical
  increment (using String#upto), not dictionary order.

* enum.c (enum_sort_by): new method for Schewartzian transformed
  stable sort.

* variable.c (mod_av_set): detect constant overriding for built-in
  classes/modules.
@
text
@d6 1
a6 1
  $Date: 2001/08/06 03:05:13 $
d1342 1
a1342 1
int
d1381 1
a1381 1
rb_io_modestr(flags)
a1383 1
    static char mode[4];
d1519 1
d1524 1
a1524 1
    m = rb_io_modestr(flags);
d1763 1
d1768 3
d1824 1
a1824 1
	
@


1.92
log
@* string.c (rb_str_lstrip_bang): new method.

* string.c (rb_str_rstrip_bang): new method.

* string.c (rb_str_associate): should consider STR_ASSOC too.

* eval.c (rb_undefined): do not recurse if method_missing is
  undefined.

* process.c (proc_waitpid): now all arguments are optional.

* process.c (Init_process): waitpid is now alias to wait.

* process.c (Init_process): waitpid2 is now alias to wait2.

* process.c (rb_waitpid): made public.

* ext/pty/pty.c (pty_getpty): avoid disturbing SIGCHLD using
  thread and rb_waitpid.

* process.c (proc_getpgrp): now takes no argument on all
  platforms.

* process.c (proc_setpgrp): ditto.

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::pack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::pack_sockaddr_un(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::unpack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::unpack_sockaddr_un(). [new]
@
text
@d6 1
a6 1
  $Date: 2001/07/24 09:07:33 $
d3402 1
a3402 1
    if (!first && next_p == -1) {
@


1.91
log
@* eval.c (rb_provide_feature): should not tweak extension used for
  loading.

* io.c (io_fread): use fread(3) if PENDING_COUND is available.

* class.c (rb_mod_include_p): Module#include? added. [new]

* re.c (ignorecase_setter): give warning on modifying $=.

* string.c (rb_str_casecmp): new method. [new]

* string.c (rb_str_eql): separated from rb_str_equal(), make it
  always be case sensitive. [new]

* string.c (rb_str_hash): made it always be case sensitive.

* eval.c (rb_f_require): should not include path in $" value

* file.c (rb_find_file): should return 0 explicitly on failure.
@
text
@d6 1
a6 1
  $Date: 2001/07/14 15:17:18 $
d32 4
@


1.90
log
@* regex.c (re_search): should consider reverse search.

* dir.c (dir_s_chdir): warn only when invoked from multiple
  threads or block is not given.

* object.c (rb_convert_type): should use rb_rescue(), not rb_rescue2().

* range.c (range_init): ditto.

* object.c (rb_obj_dup): should free generic_ivar if original owns
  them.

* string.c (rb_str_each_line): should propagate taint mark.

* ext/nkf/nkf.c (rb_nkf_kconv): ditto.

* eval.c (rb_f_require): revamp for simpler implementation.

* file.c (rb_find_file_noext): use String object, instead of
  passing char* around.

* file.c (rb_find_file): ditto.

* dln.c (dln_load): should use NSLINKMODULE_OPTION_BINDNOW.

* ruby.c (load_file): local variables 'c' remain uninitialized on
  xflag.

* regex.c (re_match): prefetched escaped character too early.

* eval.c (rb_call0): add argument check for attr_readers.
@
text
@d6 1
a6 1
  $Date: 2001/06/22 09:12:19 $
d111 1
d114 1
d118 1
d482 19
a500 1
    while (n--) {
d504 1
d509 1
d518 1
d521 1
a521 1
    return len - n - 1;
@


1.89
log
@* eval.c (rb_yield_0): no mvalue_to_svalue conversion here.

* eval.c (massign): takes svalue, convert it to mvalue inside.

* eval.c (rb_eval): parameters for yield/return are always
  svalues now.

* eval.c (svalue_to_mvalue): more strict conversion.

* eval.c (mvalue_to_svalue): ditto.

* st.c (new_size): prime hash size enabled.

* ext/socket/socket.c (Init_socket): SO_* constants added.
@
text
@d6 1
a6 1
  $Date: 2001/06/19 04:35:13 $
d193 1
a193 1
rb_dup(orig)
d332 1
a332 1
    pos = fseek(fptr->f, NUM2INT(offset), whence);
d363 1
a363 1
    pos = fseek(fptr->f, NUM2INT(offset), SEEK_SET);
d2045 1
a2045 1
    fd = rb_dup(fileno(orig->f));
d2049 1
a2049 1
	    fd = rb_dup(fileno(orig->f2));
@


1.88
log
@* eval.c (rb_f_require): searches ".rb" and ".so" at the same
  time.  previous behavior (search ".rb", then ".so") has a
  security risk (ruby-bugs#PR140).

* array.c (rb_ary_to_ary): new function to replace internal
  rb_Array(), which never calls to_a, but to_ary (rb_Array() might
  call both). [new]

* regex.c (PUSH_FAILURE_POINT): push option status again.

* regex.c (re_compile_pattern): avoid pushing unnecessary
  option_set.

* eval.c (rb_load): tainted string is OK if wrapped *and*
  $SAFE >= 4.

* eval.c (rb_thread_start_0): should not nail down higher blocks
  before preserving original context (i.e. should not alter
  original context).

* eval.c (proc_yield): new method equivalent to Proc#call but no
  check for number of arguments. [new]
@
text
@d6 1
a6 1
  $Date: 2001/06/05 07:19:38 $
d3464 6
a3471 2
    if (!RTEST(val)) return;
    StringValue(val);
@


1.87
log
@* variable.c (rb_mod_const_at): use hash table as internal
  data. [new]

* variable.c (rb_mod_const_of): ditto.

* variable.c (rb_const_list): new function to convert internal
  data (hash table) to array of strings.

* eval.c (rb_mod_s_constants): data handling scheme has changed.

* eval.c (rb_add_method): should not call rb_secure(), for
  last_func may not be set.

* io.c (rb_io_ctl): ioctl should accept any integer within C long
  range.

* marshal.c (r_object): wrong type check for modules.

* marshal.c (w_object): should not dump anonymous classes/modules.

* io.c (rb_open_file): use rb_file_sysopen_internal() if the 3rd
  argument (permission flags) is given. [new, should be backported?]

* io.c (rb_io_mode_binmode): mode string (e.g. "r+") to flags to
  open(2).

* eval.c (rb_eval): NODE_REXPAND expand an array of 1 element as
  the element itself. [new, should be backported?]

* parse.y (ret_args): should treat "*[a]" in rhs expression as
  "a", not "[a]".

* regex.c (re_compile_pattern): should push option modifier at the
  right place.
@
text
@d6 1
a6 1
  $Date: 2001/05/30 09:12:34 $
d3465 2
a3466 4
    if (!RTEST(val)) {
	ruby_inplace_mode = 0;
	return;
    }
@


1.86
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d6 1
a6 1
  $Date: 2001/05/16 09:05:50 $
d1256 1
d1258 1
a1258 1
    switch (mode[0]) {
d1273 1
a1273 1
    if (mode[1] == 'b') {
d1275 1
a1275 1
	mode++;
d1278 1
a1278 1
    if (mode[1] == '+') {
d1280 1
a1280 1
	if (mode[2] != 0) goto error;
d1282 1
a1282 1
    else if (mode[1] != 0) goto error;
d1288 1
a1288 1
rb_io_mode_flags2(mode)
d1314 38
d1353 1
a1353 1
rb_io_flags_mode(flags)
d1496 2
a1497 2
    m = rb_io_flags_mode(flags);
    fptr->mode = rb_io_mode_flags2(flags);
d1776 1
a1776 1
rb_file_s_open(argc, argv, klass)
d1779 1
a1779 1
    VALUE klass;
d1783 1
a1784 2
    NEWOBJ(io, struct RFile);
    OBJSETUP(io, klass, T_FILE);
d1789 5
a1793 6
    RFILE(io)->fptr = 0;
    if (FIXNUM_P(vmode)) {
	int flags = NUM2INT(vmode);
	int fmode = NIL_P(perm) ? 0666 : NUM2INT(perm);

	file = rb_file_sysopen_internal((VALUE)io, path, flags, fmode);
d1797 1
a1797 1
	file = rb_file_open_internal((VALUE)io, RSTRING(fname)->ptr, mode);
d1799 2
d1802 11
d1814 1
a1814 1
	return rb_ensure(rb_yield, file, rb_io_close, file);
d1817 1
a1817 1
    return file;
a2447 7
    VALUE fname, vmode, file, perm;
    char *path, *mode;

    rb_scan_args(argc, argv, "12", &fname, &vmode, &perm);
    SafeStringValue(fname);
    path = RSTRING(fname)->ptr;

d2453 1
a2453 15
    if (FIXNUM_P(vmode)) {
	int flags = NUM2INT(vmode);
	int fmode = NIL_P(perm) ? 0666 : NUM2INT(perm);

	file = rb_file_sysopen_internal(io, path, flags, fmode);
    }
    else {
	if (NIL_P(vmode)) {
	    mode = "r";
	}
	else {
	    mode = StringValuePtr(vmode);
	}
	file = rb_file_open_internal(io, RSTRING(fname)->ptr, mode);
    }
d2458 1
a2458 1
    return file;
d2884 1
a2884 1
io_cntl(fd,cmd,narg,io_p)
d2933 3
@


1.85
log
@* array.c (rb_ary_and): should not push frozen key string.

* array.c (rb_ary_or): ditto.

* eval.c (rb_thread_schedule): should save context before raising
  deadlock, saved context for current thread might be obsolete.

* time.c (make_time_t): non DST timezone shift supported (hopefully).

* time.c (make_time_t): strict range detection for negative time_t.

* signal.c: SIGINFO added.

* eval.c (rb_ensure): should not SEGV when prot_tag is NULL.
@
text
@d6 1
a6 1
  $Date: 2001/05/06 15:01:59 $
d611 1
a611 1
	rs = rb_default_rs;
@


1.84
log
@forgot some checkins.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:11 $
a346 2
    OpenFile *fptr;
    long pos;
a1959 1
    VALUE klass;
d3082 1
a3082 1
    VALUE r, w, ary;
@


1.83
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d6 1
a6 1
  $Date: 2001/03/28 08:43:24 $
d1533 2
@


1.82
log
@* object.c (rb_str2cstr): warn if string contains \0 and length
  value is ignored.

* class.c (rb_singleton_class_clone): should copy class constant
  table as well.

* class.c (rb_include_module): sometimes cache was mistakenly left
  uncleared - based on the patch by K.Kosako.

* ruby.h: all Check_SafeStr()'s are replaced by SafeStr() to
  ensure 'to_str' be always effective.
@
text
@d6 1
a6 1
  $Date: 2001/03/26 08:57:10 $
d30 4
d613 1
a613 1
	rs = rb_str_to_str(rb_rs);
a616 1
	if (!NIL_P(rs)) rs = rb_str_to_str(rs);
d627 1
d1386 4
d1413 5
d1701 1
a1701 1
	mode = STR2CSTR(pmode);
d1703 1
a1703 1
    SafeStr(pname);
d1731 1
a1731 1
	str = STR2CSTR(argv[0]);
d1748 1
a1748 1
    SafeStr(fname);
d1759 1
a1759 1
	mode = NIL_P(vmode) ? "r" : STR2CSTR(vmode);
d1776 1
a1776 1
	char *str = STR2CSTR(argv[0]);
d1913 1
a1913 1
    SafeStr(fname);
d1915 1
a1915 1
	mode = STR2CSTR(nmode);
d1935 1
d1942 5
d2277 1
a2277 1
    if (TYPE(*var) == T_FILE) {
d2383 1
a2383 1
	SafeStr(mode);
d2403 1
a2403 1
    SafeStr(fname);
d2422 1
a2422 1
	    mode = STR2CSTR(vmode);
d2446 1
a2446 1
	SafeStr(mode);
d2504 1
a2504 1
	    fn = STR2CSTR(filename);
d2703 1
a2703 1
    SafeStr(str);
d2907 1
a2907 1
	arg = rb_str_to_str(arg);
d3006 1
a3006 1
	    VALUE v = rb_str_to_str(*argv);
d3008 1
d3010 1
a3010 1
	    arg[i] = (unsigned long)RSTRING(*argv)->ptr;
d3130 1
a3130 1
    SafeStr(fname);
d3155 1
a3155 1
    SafeStr(fname);
d3180 1
a3180 1
    SafeStr(fname);
d3279 1
a3279 1
	STR2CSTR(tmp);
d3433 1
d3438 2
a3439 1
    ruby_inplace_mode = STR2CSTR(val);
d3488 3
a3490 3
    rb_define_hooked_variable("$/", &rb_rs, 0, rb_str_setter);
    rb_define_hooked_variable("$-0", &rb_rs, 0, rb_str_setter);
    rb_define_hooked_variable("$\\", &rb_output_rs, 0, rb_str_setter);
@


1.81
log
@* eval.c: remove TMP_PROTECT_END to prevent C_ALLOCA crash.

* file.c (rb_file_flock): do not trap EINTR.

* missing/flock.c (flock): returns the value from lockf(2)
  directly.

* eval.c (ev_const_defined): should ignore toplevel cbase (Object).

* eval.c (ev_const_get): ditto.

* ext/md5/md5.h: replace by independent md5 implementation
  contributed by L. Peter Deutsch (thanks).

* ext/md5/md5init.c: adopted to Deutsch's md5 implementation.

* pack.c (pack_unpack): string from P/p should be tainted.

* ext/curses/curses.c: curses on Mac OS X public beta does not
  have _maxx etc.

* marshal.c (w_object): should truncate trailing zero short for
  bignums.

* object.c (sym_intern): new method.
@
text
@d6 1
a6 1
  $Date: 2001/03/13 09:00:01 $
d609 1
a609 1
	rs = rb_rs;
d613 1
a613 1
	if (!NIL_P(rs)) Check_Type(rs, T_STRING);
d1690 1
a1690 1
    Check_SafeStr(pname);
d1735 1
a1735 1
    Check_SafeStr(fname);
d1900 1
a1900 1
    Check_SafeStr(fname);
d2364 1
a2364 1
	Check_SafeStr(mode);
d2384 1
a2384 1
    Check_SafeStr(fname);
d2427 1
a2427 1
	Check_SafeStr(mode);
d2684 1
a2684 1
    Check_SafeStr(str);
d2835 1
d2861 1
d2984 1
a2984 1
	    arg[i] = (unsigned long)NUM2INT(*argv); argv++;
d2987 4
a2990 3
	    Check_Type(*argv, T_STRING);
	    rb_str_modify(*argv);
	    arg[i] = (unsigned long)RSTRING(*argv)->ptr; argv++;
d2992 1
d3110 1
a3110 1
    Check_SafeStr(fname);
d3135 1
a3135 1
    Check_SafeStr(fname);
d3160 1
a3160 1
    Check_SafeStr(fname);
@


1.80
log
@* eval.c (ev_const_defined): add new parameter self for special
  const fallback.

* eval.c (ev_const_get): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/03/13 05:45:09 $
d2886 1
a2886 1
	Check_Type(arg, T_STRING);
@


1.79
log
@* io.c (argf_seek_m): wrong calling sequence of rb_io_seek().

* parse.y (cond0): no special treatment of string literal in
  condition.

* math.c: add acos, asin, atan, conh, sinh, tanh and hypot to Math.

* configure.in: check hypot availablility.

* missing/hypot.c: public domain rewrite of hypot.

* parse.y (warn_unless_e_option): warning condition was wrong.

* parse.y (warning_unless_e_option): ditto.

* enum.c (enum_all): new method 'all?', which returns true if
  block returns true for all elements.

* enum.c (enum_any): new method 'any?', which returns true if
  block retruns true for any of elements.

* marshal.c (marshal_load): do not give warning unless explicitly
  set to verbose.

* eval.c (rb_exit): give string value "exit" to SystemExit.

* ruby.c (proc_options): -v should not print version if
  proc_options called via moreswitches().

* parse.y (stmt): while/until modifier must work for empty body.
@
text
@d6 1
a6 1
  $Date: 2001/02/26 05:29:00 $
a3185 2
    VALUE args[2];

@


1.78
log
@* eval.c (proc_call): should not modify ruby_block->frame.iter
  based on ruby_frame->iter altered by PUSH_ITER().

* eval.c (rb_thread_fd_close): should save current context before
  raising exception.

* io.c (set_stdin): preserve original stdin.

* io.c (set_outfile): preserve original stdout/stderr.
@
text
@d6 1
a6 1
  $Date: 2001/02/16 07:53:19 $
d320 17
a336 1
rb_io_seek(argc, argv, io)
d350 1
a350 6
    GetOpenFile(io, fptr);
    pos = fseek(fptr->f, NUM2INT(offset), whence);
    if (pos != 0) rb_sys_fail(fptr->path);
    clearerr(fptr->f);

    return INT2FIX(0);
d3162 1
a3162 1
	rb_io_seek(1, &offset, arg.io);
d3181 4
a3184 2
argf_seek(self, offset, ptrname)
     VALUE self, offset, ptrname;
d3186 2
d3195 1
a3195 1
    return rb_io_seek(current_file, offset, ptrname);
d3508 1
a3508 1
    rb_define_method(rb_cIO, "seek", rb_io_seek, -1);
d3566 1
a3566 1
    rb_define_singleton_method(argf, "seek", argf_seek, 2);
@


1.77
log
@* io.c (set_outfile): f should be the FILE* from the assigning value.

* ext/socket/socket.c (tcp_s_open): should not give default value
  to local_host.

* time.c (time_s_times): move to Process::times.

* file.c (rb_file_s_lchmod): new method File::lchmod.

* file.c (rb_file_s_lchown): new method File::lchown.
@
text
@d6 1
a6 1
  $Date: 2001/02/13 05:08:59 $
d84 1
d1191 1
d1193 4
d2221 9
a2229 1
    dup2(fileno(fptr->f), 0);
d2243 1
d2261 10
a2270 1
    dup2(fileno(f), fileno(stdf));
@


1.76
log
@* io.c (rb_io_ctl): do not call ioctl/fcntl for f2, if f and f2
  have same fileno.

* eval.c (rb_load): raise LocaJumpError if unexpected local jumps
  appear during load.

* ext/socket/socket.c (bsock_close_read): don't call rb_thread_fd_close();
  it's supposed to be called by io_io_close().

* ext/socket/socket.c (bsock_close_read): do not modify f and f2.

* ext/socket/socket.c (bsock_close_write): ditto.

* ext/socket/socket.c (sock_new): avoid dup(2) on sockets.

* parse.y (primary): preserve and clear in_single and in_def using
  stack to prevent nested method errors in singleton class bodies.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:38:10 $
a2244 2

    GetOpenFile(*var, fptr);
@


1.75
log
@* array.c (rb_ary_sort_bang): returns self, even if its length is
  less than 2.

* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2001/01/29 05:10:42 $
d1963 3
a1965 1
	fd = rb_dup(fileno(orig->f2));
d2381 24
d2882 2
a2883 1
    if (fptr->f2) {		/* call on f2 too; ignore result */
d3412 1
@


1.74
log
@* string.c (str_independent): should not clear str->orig here.
  it's too early.
@
text
@d6 1
a6 1
  $Date: 2001/01/18 08:43:07 $
d1328 1
a1328 1
rb_sysopen(fname, flag, mode)
d1330 1
a1330 1
    int flag;
d1335 1
a1335 1
    fd = open(fname, flag, mode);
d1339 1
a1339 1
	    fd = open(fname, flag, mode);
@


1.73
log
@* io.c (rb_io_s_read): new method to call IO#read from
  pathname.  In addition, it accepts third optional argument to
  specify starting point.
@
text
@d6 1
a6 1
  $Date: 2001/01/15 07:00:54 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.72
log
@Mon Jan 15 16:00:07 2001  Yukihiro Matsumoto  <matz@@ruby-lang.org>

	* pack.c (pack_unpack): should check associated pointer packed by
	  pack("P").  restriction added.

Sun Jan 14 21:49:28 2001  Koji Arai  <JCA02266@@nifty.ne.jp>

	* sprintf.c (rb_f_sprintf): simple typo.  binary base should be 2,
	  not '2'.

	* re.c (rb_reg_s_last_match): should explicitly return nth match.
@
text
@d6 1
a6 1
  $Date: 2000/12/26 08:32:35 $
d3025 1
a3025 1
rb_io_foreach_line(arg)
d3051 1
a3051 1
    return rb_ensure(rb_io_foreach_line, (VALUE)&arg, rb_io_close, arg.io);
d3055 1
a3055 1
rb_io_readline_line(arg)
d3058 1
a3058 8
    VALUE line, ary;

    ary = rb_ary_new();
    while (!NIL_P(line = rb_io_gets_internal(arg->argc, &arg->sep, arg->io))) {
	rb_ary_push(ary, line);
    }

    return ary;
d3076 29
a3104 1
    return rb_ensure(rb_io_readline_line, (VALUE)&arg, rb_io_close, arg.io);
d3139 1
a3139 1
	rb_raise(rb_eArgError, "no stream to pos");
d3389 1
@


1.71
log
@matz
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2000/12/26 08:08:50 $
d2286 1
a2286 1
static VALUE
@


1.71.2.1
log
@m17n fix
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/01/10 07:52:45 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
d99 1
a99 3
static int argf_lineno;
static VALUE argf_encname = Qnil;

a186 20
static VALUE
rb_io_str_new(p, len, fptr)
    const char *p;
    long len;
    OpenFile *fptr;
{
    VALUE s = rb_tainted_str_new(p, len);
    if (fptr->enc) {
	rb_m17n_associate_encoding(s, fptr->enc);
    }
    return s;
}

static m17n_encoding*
io_encoding(fptr)
    OpenFile *fptr;
{
    return fptr->enc ? fptr->enc : ruby_default_encoding;
}

d366 1
a366 1
	argf_lineno -= fptr->lineno;
d398 1
a398 1
rb_io_get_sync(io)
d515 1
a515 1
	    return rb_io_str_new(0, 0, fptr);
d524 1
a524 1
    str = rb_io_str_new(0, siz, fptr);
d537 1
a537 1
    if (bytes == 0) return rb_io_str_new(0, 0, fptr);
d566 1
a566 1
    str = rb_io_str_new(0, len, fptr);
d577 1
d691 1
a691 1
	    str = rb_io_str_new(buf, cnt, fptr);
d719 1
d769 1
a769 1
	str = rb_io_str_new(buf, cnt, fptr);
d780 1
d801 1
a801 1
rb_io_get_lineno(io)
d829 2
a830 2
    argf_lineno = NUM2INT(val);
    *var = INT2FIX(argf_lineno);
d837 2
a838 2
    argf_lineno = NUM2INT(val);
    lineno = INT2FIX(argf_lineno);
d843 1
a843 1
argf_get_lineno()
a848 50
rb_io_get_encoding(io)
    VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    if (fptr->enc) {
	return rb_str_new2(fptr->enc->name);
    }
    return Qnil;
}

static VALUE
rb_io_set_encoding(io, encname)
    VALUE io, encname;
{
    OpenFile *fptr;
    m17n_encoding *enc;

    if (NIL_P(encname)) {
	enc = ruby_default_encoding;
    }
    else {
	enc = m17n_find_encoding(STR2CSTR(encname));
	if (!enc) {
	    rb_raise(rb_eArgError, "undefined encoding `%s'", STR2CSTR(encname));
	}
    }
    GetOpenFile(io, fptr);
    fptr->enc = enc;

    return encname;
}

static VALUE
argf_set_encoding(argf, encname)
    VALUE argf, encname;
{
    rb_io_set_encoding(current_file, encname);
    argf_encname = encname;
    return Qnil;
}

static VALUE
argf_get_encoding()
{
    return argf_encname;
}

static VALUE
a965 42
io_readchar(io)
    VALUE io;
{
    m17n_encoding *enc;
    OpenFile *fptr;
    char *buf;
    FILE *f;
    int c, i, n;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    f = fptr->f;
    enc = io_encoding(fptr);
    n = m17n_mbmaxlen(enc);
    if (n == 0) n = 6;
    buf = ALLOCA_N(char, n);

  retry:
    READ_CHECK(f);
    c = rb_getc(f);
    if (c == EOF) {
      eof:
	if (ferror(f)) {
	    if (errno == EINTR) goto retry;
	    rb_sys_fail(fptr->path);
	}
	return Qnil;
    }
    buf[0] = c;

    n = m17n_mbclen(enc, c);
    for (i=1; i<n; i++) {
	c = rb_getc(f);
	if (c == EOF) goto eof;
	buf[i] = c;
    }

    c = m17n_codepoint(enc, buf, buf+n);
    return INT2NUM(c);
}

static VALUE
a968 12
    VALUE c = io_readchar(io);

    if (NIL_P(c)) {
	rb_eof_error();
    }
    return c;
}

static VALUE
rb_io_readbyte(io)
    VALUE io;
{
d1188 1
a1188 1
    str = rb_io_str_new(0, ilen, fptr);
d1202 1
d1924 1
d2286 1
a2286 1
static void
d2418 1
a2418 1
	argf_lineno = 0;
d2447 1
a2447 1
			str = rb_tainted_str_new2(fn);
a2497 2
	    if (!NIL_P(argf_encname))
		rb_io_set_encoding(current_file, argf_encname);
d2540 2
a2541 2
    argf_lineno++;
    lineno = INT2FIX(argf_lineno);
d2576 2
a2577 2
	argf_lineno++;
	lineno = INT2FIX(argf_lineno);
d2999 1
a2999 1
    VALUE r, w;
a3221 21
    VALUE c;

  retry:
    if (!next_argv()) rb_eof_error();
    if (TYPE(current_file) != T_FILE) {
	c = rb_funcall3(current_file, rb_intern("readchar"), 0, 0);
    }
    else {
	c = io_readchar(current_file);
    }
    if (NIL_P(c) && next_p != -1) {
	any_close(current_file);
	next_p = 1;
	goto retry;
    }
    return c;
}

static VALUE
argf_readbyte()
{
d3302 1
a3302 1
    argf_lineno = 0;
d3403 1
a3403 1
    rb_define_method(rb_cIO, "sync",   rb_io_get_sync, 0);
d3406 1
a3406 1
    rb_define_method(rb_cIO, "lineno",   rb_io_get_lineno, 0);
a3408 3
    rb_define_method(rb_cIO, "encoding",   rb_io_get_encoding, 0);
    rb_define_method(rb_cIO, "encoding=",  rb_io_set_encoding, 1);

a3416 1
    rb_define_method(rb_cIO, "readbyte",  rb_io_readbyte, 0);
a3477 1
    rb_define_singleton_method(argf, "readbyte", argf_readbyte, 0);
d3494 2
a3495 5
    rb_define_singleton_method(argf, "lineno",  argf_get_lineno, 0);
    rb_define_singleton_method(argf, "lineno=", argf_set_lineno, 1);

    rb_define_singleton_method(argf, "encoding",  argf_get_encoding, 0);
    rb_define_singleton_method(argf, "encoding=", argf_set_encoding, 1);
@


1.71.2.2
log
@several minor fixes.
@
text
@d6 1
a6 1
  $Date: 2001/01/12 04:36:00 $
d1333 1
a1336 1
#if defined(NT) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__) || defined(__EMX__)
a1350 1
    fptr->enc = m17n_find_encoding("binary");
d1671 1
a1672 1

@


1.70
log
@matz
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/12/22 03:22:01 $
d2159 1
a2159 1
    if (TYPE(rb_defout) != T_FILE) {
@


1.69
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/12 07:42:23 $
d2159 3
a2161 1
    rb_io_flush(rb_defout);
@


1.69.2.1
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/22 03:22:01 $
a2158 1
    if (TYPE(rb_defout) == T_FILE) {
a2159 1
    }
@


1.69.2.2
log
@Sun Jan 14 21:49:28 2001  Koji Arai  <JCA02266@@nifty.ne.jp>

	* sprintf.c (rb_f_sprintf): simple typo.  binary base should be 2,
	  not '2'.
@
text
@d6 1
a6 1
  $Date: 2000/12/28 04:45:15 $
d2286 1
a2286 1
static void
@


1.69.2.3
log
@* io.c (set_outfile): f should be the FILE* from the assigning value.
@
text
@d6 1
a6 1
  $Date: 2001/01/15 07:33:12 $
d2243 2
@


1.69.2.4
log
@* io.c (argf_seek): wrong calling sequence of rb_io_seek().

* parse.y (stmt): while/until modifier must work for empty body.

* ruby.c (ruby_set_argv): clear ARGV contents before adding args.
@
text
@d6 1
a6 1
  $Date: 2001/02/16 08:06:26 $
d3098 2
a3099 3
argf_seek(argc, argv)
    int argc;
    VALUE *argv;
d3108 1
a3108 1
    return rb_io_seek(argc, argv, current_file);
d3477 1
a3477 1
    rb_define_singleton_method(argf, "seek", argf_seek, -1);
@


1.69.2.5
log
@* object.c (rb_str2cstr): warn if string contains \0 and length
  value is ignored.

* class.c (rb_singleton_class_clone): should copy class constant
  table as well.

* class.c (rb_include_module): sometimes cache was mistakenly left
  uncleared - based on the patch by K.Kosako.
@
text
@d6 1
a6 1
  $Date: 2001/03/13 05:48:33 $
a2773 1
#if !defined(MSDOS) && !defined(__human68k__)
a2798 1
#endif
@


1.69.2.6
log
@* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.
@
text
@d6 1
a6 1
  $Date: 2001/03/28 08:44:37 $
a3326 1
    if (ruby_inplace_mode) free(ruby_inplace_mode);
d3331 1
a3331 1
    ruby_inplace_mode = strdup(STR2CSTR(val));
@


1.69.2.7
log
@* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).
@
text
@d6 1
a6 1
  $Date: 2001/04/10 06:09:00 $
a29 4
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(sun)
# define USE_SETVBUF
#endif

a1364 3
#ifdef USE_SETVBUF
    setvbuf(file, NULL, _IOFBF, 0);
#endif
a1387 4
#ifdef USE_SETVBUF
    setvbuf(file, NULL, _IOFBF, 0);
#endif

a1904 1

a1910 1

@


1.69.2.8
log
@	* eval.c (safe_getter): should use INT2NUM().

	* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.
@
text
@d6 1
a6 1
  $Date: 2001/04/16 06:54:36 $
d1370 1
a1370 2
    if (setvbuf(file, NULL, _IOFBF, 0) != 0)
	rb_warn("setvbuf() can't be honered for %s", fname);
d1396 1
a1396 2
    if (setvbuf(file, NULL, _IOFBF, 0) != 0)
	rb_warn("setvbuf() can't be honered (fd=%d)", fd);
a1922 4
#ifdef USE_SETVBUF
    if (setvbuf(fptr->f, NULL, _IOFBF, 0) != 0)
	rb_warn("setvbuf() can't be honered for %s", RSTRING(fname)->ptr);
#endif
@


1.69.2.9
log
@* eval.c (rb_add_method): should not call rb_secure(), for
  last_func may not be set.

* io.c (rb_io_ctl): ioctl should accept any integer within C long
  range.
@
text
@d6 1
a6 1
  $Date: 2001/04/17 08:26:13 $
a2843 3
    }
    else if (rb_obj_is_kind_of(arg, rb_cInteger)) {
	narg = NUM2LONG(arg);
@


1.69.2.10
log
@* eval.c (rb_f_require): searches ".rb" and ".so" at the same
  time.  previous behavior (search ".rb", then ".so") has a
  security risk (ruby-bugs#PR140).

* regex.c (re_compile_pattern): avoid pushing unnecessary
  option_set.

* eval.c (rb_load): tainted string is OK if wrapped *and*
  $SAFE >= 4.

* eval.c (rb_thread_start_0): should not nail down higher blocks
  before preserving original context (i.e. should not alter
  original context).
@
text
@d6 1
a6 1
  $Date: 2001/06/05 06:40:50 $
d3349 1
a3349 2
    long len;

a3350 1
	if (ruby_inplace_mode) free(ruby_inplace_mode);
d3354 1
a3354 4
    STR2CSTR(val);
    len = RSTRING(val)->len;
    REALLOC_N(ruby_inplace_mode, char, len + 1);
    ((char *)MEMCPY(ruby_inplace_mode, RSTRING(val)->ptr, char, len))[len] = '\0';
@


1.69.2.11
log
@* io.c (rb_io_popen): accept integer flags as mode.

* file.c (rb_find_file_ext): extension table can be supplied from
  outside.  renamed.

* eval.c (rb_f_require): replace rb_find_file_noext by
  rb_find_file_ext.

* eval.c (rb_provided): should also check feature without
  extension.

* numeric.c (flo_to_s): do not rely on decimal point to be '.'

* parse.y (yylex): ternary ? can be followed by newline.
@
text
@d6 1
a6 1
  $Date: 2001/06/19 04:36:34 $
a1681 3
    }
    else if (FIXNUM_P(pmode)) {
	mode = rb_io_flags_mode(NUM2INT(pmode));
@


1.69.2.12
log
@* ruby.c (proc_options): should not adjust argc/argv if -e option
  is supplied.
@
text
@d6 1
a6 1
  $Date: 2001/09/03 05:29:18 $
d30 1
a30 1
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(sun) || defined(_nec_ews)
@


1.69.2.13
log
@* io.c (io_fread): EAGAIN/EWOULDBLOCK should not terminate and
  throw away the input.

* time.c (time_new_internal): underflow adjustment must not use
  negative div/mod.

* time.c (time_cmp): should consider tv_usec on non Fixnum number
  comparison.
@
text
@d6 1
a6 1
  $Date: 2001/09/05 06:53:27 $
a478 4
		if (errno == EAGAIN) return len - n;
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
		if (errno == EWOULDBLOCK) return len - n;
#endif
@


1.69.2.14
log
@* intern.h: add prototypes.
  rb_str_dup_frozen()

* ruby.h: added declaration.
  rb_defout, rb_stdin, rb_stdout, rb_stderr, ruby_errinfo

* rubyio.h: changed double include guard macro to RUBYIO_H.

* array.c (inspect_call): make static.

* eval.c (dvar_asgn): ditto.

* io.c (rb_io_close_read): ditto.

* lex.c (rb_reserved_word): ditto.

* ruby.c: (req_list_head, req_list_last): ditto.

* ruby.c (require_libraries): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/12/04 04:53:31 $
d1104 1
a1104 1
static VALUE
@


1.69.2.15
log
@* eval.c (rb_thread_schedule): should not select a thread which is
  not yet initialized.

* variable.c (find_class_path): should initialize iv_tbl if it's
  NULL.

* class.c (rb_define_class): should return the existing class if
  the class is already defined and its superclass is ideintical to
  the specified superclass.

* class.c (rb_define_class_under): ditto.

* class.c (rb_define_module): should return the existing module if
  the module is already defined.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/12/17 08:13:17 $
d2137 2
a2138 1
	if (NIL_P(argv[i])) {
d2140 7
d2148 1
a2148 8
	else {
	    line = rb_check_convert_type(argv[i], T_ARRAY, "Array", "to_ary");
	    if (!NIL_P(line)) {
		rb_protect_inspect(io_puts_ary, line, out);
		continue;
	    }
	    line = rb_obj_as_string(argv[i]);
	}
@


1.69.2.16
log
@* variable.c (rb_cvar_set): add frozen class/module check.

* variable.c (rb_cvar_declare): add frozen class/module check.

* re.c (match_to_a): should propagate taint.

* re.c (rb_reg_s_quote): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/12/18 08:40:31 $
d483 1
a483 1
		return 0;
@


1.69.2.17
log
@forgot to commit everything bug ChangeLog
@
text
@d6 1
a6 1
  $Date: 2001/12/21 09:20:53 $
d54 3
d1603 1
a1603 1
    switch ((pid = fork())) {
@


1.69.2.18
log
@* eval.c (ruby_stop): should not trace error handler.

* io.c (io_write): should not raise exception on O_NONBLOCK io.

* dir.c (dir_set_pos): seek should return dir, pos= should not.
@
text
@d6 1
a6 1
  $Date: 2002/01/04 14:19:47 $
d250 1
a250 1
		break;
d253 1
a253 1
    if (n == 0 && ferror(f))
d257 1
a257 1
    if (n == 0 && ferror(f)) {
d923 1
a923 1
    return io;
a1086 1
    rb_io_check_closed(RFILE(io)->fptr);
@


1.69.2.19
log
@* io.c (rb_io_ungetc): don't fail pushed EOF back.
@
text
@d6 1
a6 1
  $Date: 2002/01/21 07:43:40 $
d992 1
a992 1
    if (ungetc(cc, fptr->f) == EOF && cc != EOF)
@


1.69.2.20
log
@* intern.h: prototypes; rb_io_addstr(), rb_io_printf(),
  rb_io_print(), rb_io_puts()

* io.c (rb_io_addstr): make extern.

* io.c (rb_io_printf): ditto.

* io.c (rb_io_print): ditto.

* io.c (rb_io_puts): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/02/19 04:18:38 $
d275 1
a275 1
VALUE
d1997 1
a1997 1
VALUE
d2028 1
a2028 1
VALUE
d2101 2
d2120 1
a2120 1
VALUE
@


1.69.2.21
log
@* io.c (READ_DATA_PENDING): uClibc support.
* random.c (rand_init): ditto.
* ext/socket/{addinfo.h,getaddrinfo.c} (gai_strerror): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/02/20 06:35:37 $
a113 2
#elif defined(__UCLIBC__)
#  define READ_DATA_PENDING(fp) ((fp)->bufpos < (fp)->bufend)
@


1.69.2.22
log
@* ext/socket/socket.c (bsock_do_not_rev_lookup_set): should not be
  allowed when $SAFE > 3.

* dir.c (fnmatch): "*/bar" (with FNM_PATHNAME flag) does not
  match "foo/bar".

* io.c (read_all): files on /proc filesystem with zero stat size,
  may have contents.

* eval.c (exec_under): changing ruby_class is OK, but should not
  alter cbase.

* eval.c (yield_under_i): ditto.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/02/27 04:30:19 $
d520 9
a528 3
	long pos = ftell(fptr->f);
	if (st.st_size > pos && pos >= 0) {
	    siz = st.st_size - pos + 1;
@


1.69.2.23
log
@* io.c (READ_DATA_PENDING): uClibc 0.9.10 support.
  use !feof(fp) for default behavior.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/25 06:15:59 $
d114 2
a115 2
#elif defined(__UCLIBC__) && !defined(_UC_IOFBF)
#  define READ_DATA_PENDING(fp) ((fp)->bufpos < (fp)->bufread)
d117 3
a119 1
#  define READ_DATA_PENDING(fp) (!feof(fp))
@


1.69.2.24
log
@* io.c (read_all): return "" if file.size == 0.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/03/27 05:41:18 $
a506 1
    long pos = 0;
d518 1
a518 1
	pos = ftell(fptr->f);
d527 1
a527 1
	if (pos > 0 && n == 0 && bytes == 0) {
@


1.69.2.25
log
@* file.c (rb_find_file): load must be done from an abolute path if
  $SAFE >= 4.

* re.c (rb_reg_s_quote): quote whitespaces for /x cases.

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* eval.c (rb_thread_cleanup): current thread may be THREAD_STOPPED,
  for example when terminated from signal handler.

* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.

* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* marshal.c (w_uclass): should check based on rb_obj_class(), not
  CLASS_OF().

* io.c (io_write): check error if written data is less than
  specified size to detect EPIPE.

* eval.c (assign): ruby_verbose should be surrounded by RTEST().

* object.c (rb_str2cstr): ditto.

* parse.y (void_expr): ditto.

* parse.y (void_stmts): ditto.

* variable.c (rb_ivar_get): ditto.

* variable.c (rb_cvar_set): ditto.

* variable.c (rb_cvar_get): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/04/11 09:46:53 $
d253 1
a253 1
    if (n != RSTRING(str)->len && ferror(f))
d257 1
a257 1
    if (n != RSTRING(str)->len && ferror(f)) {
@


1.69.2.26
log
@* eval.c (blk_orphan): the wrong condition; backported from 1.7

* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* re.c (rb_reg_s_quote): # also should be quoted.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/01 09:37:58 $
d57 2
a58 2
/* EMX has sys/param.h, but.. */
#if defined(HAVE_SYS_PARAM_H) && !(defined(__EMX__) || defined(__HIUX_MPP__))
@


1.69.2.27
log
@* io.c (rb_io_clone): writing stream was not copied properly.
@
text
@d6 1
a6 1
  $Date: 2002/05/14 06:08:43 $
d1981 1
a1981 1
    if (orig->f2) {
d1983 1
a1983 1
	fptr->f2 = rb_fdopen(fd, "w");
@


1.69.2.28
log
@* io.c (io_fread): return value was longer when EWOULDBLOCK
  occurred.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/05/20 04:32:54 $
d466 1
a466 1
    while (n > 0) {
d476 1
a476 1
		if (errno == EAGAIN) break;
d478 1
a478 1
		if (errno == EWOULDBLOCK) break;
a485 1
	--n;
d488 1
a488 1
    return len - n;
@


1.68
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/27 09:23:21 $
d2159 1
a2159 1
    fflush(stdout);
@


1.67
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/20 07:31:42 $
d1016 2
a1017 2
void
rb_io_fptr_finalize(fptr)
a1019 3
    if (!fptr) return;
    if (!fptr->f && !fptr->f2) return;

d1034 11
d1055 1
a1055 1
    rb_io_fptr_finalize(fptr);
@


1.66
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/17 04:41:11 $
d2766 26
a2800 1
    int fd;
d2840 1
a2840 17
    fd = fileno(fptr->f);
#ifdef HAVE_FCNTL
    TRAP_BEG;
# if defined(__CYGWIN__)
    retval = io_p?ioctl(fd, cmd, (void*)narg):fcntl(fd, cmd, narg);
# else
    retval = io_p?ioctl(fd, cmd, narg):fcntl(fd, cmd, narg);
# endif
    TRAP_END;
#else
    if (!io_p) {
	rb_notimplement();
    }
    TRAP_BEG;
    retval = ioctl(fd, cmd, narg);
    TRAP_END;
#endif
d2845 5
@


1.65
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/16 16:56:57 $
d456 1
a456 1
static size_t
d459 1
a459 1
    size_t len;
d462 1
a462 1
    size_t n = len;
@


1.64
log
@001117
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/11/13 10:11:27 $
d211 2
d214 4
a217 1
    if (fflush(f) == EOF) rb_sys_fail(path);
a1057 3
    if (fptr->mode & FMODE_WRITABLE) {
	rb_io_flush(io);
    }
@


1.63
log
@eban
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/11/13 05:39:32 $
a124 14

#ifndef EWOULDBLOCK
#define EWOULDBLOCK EAGAIN
#endif

#ifdef O_NDELAY 
# define NONBLOCKING O_NDELAY
#else
#ifdef O_NBIO
# define NONBLOCKING O_NBIO
#else
# define NONBLOCKING O_NONBLOCK
#endif
#endif
@


1.62
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/10 07:16:49 $
d1522 1
a1522 1
#if defined DJGPP || (defined NT && !defined __BORLANDC__)
@


1.61
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/08 05:29:23 $
d2484 1
d2486 3
@


1.60
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/21 09:30:55 $
d144 9
@


1.59
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/04 08:24:01 $
d126 14
d211 9
d261 1
a261 1
	if (fflush(f) == EOF) rb_sys_fail(fptr->path);
d292 2
a293 2

    if (fflush(f) == EOF) rb_sys_fail(fptr->path);
d1805 1
a1805 1
	if (fflush(orig->f2) == EOF) rb_sys_fail(orig->path);
d1808 1
a1808 1
	if (fflush(orig->f) == EOF) rb_sys_fail(orig->path);
d1931 1
a1931 1
	if (fflush(orig->f2) == EOF) rb_sys_fail(orig->path);
d1934 1
a1934 1
	if (fflush(orig->f) == EOF) rb_sys_fail(orig->path);
d2059 1
a2059 1
	if (fflush(f) == EOF) rb_sys_fail(fptr->path);
@


1.58
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/30 05:20:36 $
d2795 1
a2795 1
    retval = io_p?ioctl(fd, cmd, (void*) narg):fcntl(fd, cmd, narg);
@


1.57
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/25 08:26:02 $
d22 1
a22 1
#if defined(MSDOS) || defined(__BOW__) || defined(__CYGWIN__) || defined(NT) || defined(__human68k__) || defined(__EMX__)
@


1.56
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/15 06:22:40 $
d2131 1
@


1.55
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/09 07:35:01 $
d22 8
d2256 12
d2383 1
d2399 1
d2417 1
a2417 1
#if defined(MSDOS) || defined(__CYGWIN__) || defined(NT)
d2422 1
a2422 1
#if defined(MSDOS) || defined(__BOW__) || defined(__CYGWIN__) || defined(NT) || defined(__human68k__) || defined(__EMX__)
d2437 3
a2439 1
#if !defined(MSDOS) && !defined(__BOW__) && !defined(__CYGWIN__) && !defined(NT) && !defined(__human68k__)
a2445 2
#else
			rb_fatal("Can't do inplace edit without backup");
d2449 1
a2449 1
#if !defined(MSDOS) && !defined(__CYGWIN__) && !(NT) && !defined(__human68k__) && !defined(__BEOS__) && !defined(__EMX__)
d2457 1
d2460 1
a2581 12
}

void
rb_str_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    if (!NIL_P(val) && TYPE(val) != T_STRING) {
	rb_raise(rb_eTypeError, "value of %s must be String", rb_id2name(id));
    }
    *var = val;
@


1.54
log
@matz(ruby-bugs PR#51)
@
text
@d6 1
a6 1
  $Date: 2000/08/07 05:01:53 $
d92 1
a92 1
static int init_p = 0, next_p = 0;
d2365 1
d3172 4
a3175 1
    if (init_p == 0 && !next_argv())
d3177 1
@


1.53
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/27 09:49:19 $
d2839 1
a2839 1
#ifdef HAVE_SYSCALL
@


1.52
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/25 07:21:49 $
d1453 1
d1455 1
a1455 1
pipe_atexit()
d1466 1
@


1.51
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/17 09:38:00 $
a56 4
#endif

#ifndef strdup
char *strdup();
@


1.50
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/14 07:18:57 $
d2111 2
a2112 4
    obj = rb_obj_as_string(rb_inspect(obj));
    fwrite(RSTRING(obj)->ptr, 1, RSTRING(obj)->len, stdout);
    obj = rb_default_rs;
    fwrite(RSTRING(obj)->ptr, 1, RSTRING(obj)->len, stdout);
@


1.49
log
@matz
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/07/10 06:47:04 $
d1796 1
a1796 1
	/* need to keep stdio */
d1805 4
a1808 4
	if (orig->mode & FMODE_READABLE && pos >= 0) {
	    fseek(fptr->f, pos, SEEK_SET);
	    fseek(orig->f, pos, SEEK_SET);
	}
d1890 1
@


1.48
log
@eban
@
text
@d6 1
a6 1
  $Date: 2000/07/10 06:30:11 $
d429 30
d497 2
a498 1
    str = rb_str_new(0, siz);
d500 1
a500 4
	READ_CHECK(fptr->f);
	TRAP_BEG;
	n = fread(RSTRING(str)->ptr+bytes, 1, siz-bytes, fptr->f);
	TRAP_END;
a511 1
    OBJ_TAINT(str);
a515 30
static size_t
io_fread(ptr, len, f)
    char *ptr;
    size_t len;
    FILE *f;
{
    size_t n = len;
    int c;

    while (n--) {
	if (!READ_DATA_PENDING(f)) {
	    rb_thread_wait_fd(fileno(f));
	}
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c == EOF) {
	    if (ferror(f)) {
		if (errno == EINTR) continue;
		rb_sys_fail(0);
	    }
	    *ptr = '\0';
	    break;
	}
	*ptr++ = c;
    }

    return len - n - 1;
}

d1795 1
a3174 2
	return Qtrue;
    if (next_p == -1)
@


1.47
log
@eban
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/07/06 09:18:54 $
d1487 3
@


1.46
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/06 07:21:08 $
d1478 2
d1481 1
a1481 1
	pclose(fptr->f);
d1484 1
a1484 1
	pclose(fptr->f2);
d1487 1
@


1.45
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/04 04:17:11 $
d1684 1
a1684 5
    if (RFILE(io)->fptr) {
	rb_io_close_m(io);
	free(RFILE(io)->fptr);
	RFILE(io)->fptr = 0;
    }
@


1.44
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/19 08:38:07 $
d135 1
a135 1
    if (fptr->f == NULL && fptr->f2 == NULL)
d137 1
d984 1
a984 1
    if (fptr->f != NULL) {
d987 1
a987 1
    if (fptr->f2 != NULL) {
d997 1
a997 1
    if (fptr->f == NULL && fptr->f2 == NULL) return;
d1005 1
a1005 1
    fptr->f = fptr->f2 = NULL;
d1009 1
a1009 1
	fptr->path = NULL;
d1020 1
a1020 1
    if (fptr->f == NULL && fptr->f2 == NULL) return;
d1299 1
a1299 1
rb_open(fname, flag, mode)
d1327 1
a1327 1
    if (file == NULL) {
d1332 1
a1332 1
	if (file == NULL) {
d1350 1
a1350 1
    if (file == NULL) {
d1355 1
a1355 1
	if (file == NULL) {
d1399 1
a1399 1
    fd = rb_open(fname, flags, mode);
d1478 1
a1478 1
    if (fptr->f != NULL) {
d1481 1
a1481 1
    if (fptr->f2 != NULL) {
d1484 1
a1484 1
    fptr->f = fptr->f2 = NULL;
d1516 1
a1516 1
    if (f == NULL) rb_sys_fail(pname);
d1684 5
d1696 1
a1696 6
	if (NIL_P(vmode)) {
	    mode = "r";
	}
	else {
	    mode = STR2CSTR(vmode);
	}
d1858 5
a1862 1
    if (fptr->path) free(fptr->path);
d1869 1
a1869 1
	    fptr->f2 = NULL;
d1874 1
a1874 1
    if (freopen(RSTRING(fname)->ptr, mode, fptr->f) == NULL) {
d1878 1
a1878 1
	if (freopen(RSTRING(fname)->ptr, "w", fptr->f2) == NULL) {
d2304 5
d2612 1
a2612 1
	tp = NULL;
d2639 1
a2639 1
	rp = NULL;
d2656 1
a2656 1
	wp = NULL;
d2672 3
a2674 2
    else
	ep = NULL;
@


1.43
log
@2000-06-19
@
text
@d6 1
a6 1
  $Date: 2000/06/16 07:44:02 $
d2941 1
a2941 5
    ary = rb_ary_new2(2);
    rb_ary_push(ary, r);
    rb_ary_push(ary, w);

    return ary;
@


1.42
log
@2000-06-16
@
text
@d6 1
a6 1
  $Date: 2000/06/14 08:08:48 $
d337 4
@


1.41
log
@2000-06-14-2
@
text
@d6 1
a6 1
  $Date: 2000/06/14 05:30:21 $
d1802 1
@


1.40
log
@2000-06-14
@
text
@d6 1
a6 1
  $Date: 2000/06/13 09:42:39 $
d1758 1
d1768 3
d1800 3
@


1.39
log
@2000-06-13
@
text
@d6 1
a6 1
  $Date: 2000/06/13 02:50:34 $
d790 2
a791 1
    return fptr->lineno = NUM2INT(lineno);
@


1.38
log
@IO#seek segv
@
text
@d6 1
a6 1
  $Date: 2000/06/12 07:48:20 $
d501 4
d631 4
a634 1
		    if (ferror(f) && errno == EINTR) continue;
d721 4
a724 1
	    if (ferror(f) && errno == EINTR) continue;
d878 7
a884 1
	if (c == EOF) break;
d903 1
d910 4
a913 1
	if (ferror(f)) rb_sys_fail(fptr->path);
@


1.37
log
@2000-06-12
@
text
@d6 1
a6 1
  $Date: 2000/06/05 08:46:49 $
d3320 1
a3320 1
    rb_define_method(rb_cIO, "seek", rb_io_seek, 2);
@


1.36
log
@2000-06-05
@
text
@d6 1
a6 1
  $Date: 2000/05/25 05:55:03 $
d284 6
d291 4
a294 2
rb_io_seek(io, offset, ptrname)
     VALUE io, offset, ptrname;
d296 2
d301 4
d306 1
a306 1
    pos = fseek(fptr->f, NUM2INT(offset), NUM2INT(ptrname));
a311 6

#ifndef SEEK_CUR
# define SEEK_SET 0
# define SEEK_CUR 1
# define SEEK_END 2
#endif
@


1.35
log
@2000-05-25
@
text
@d6 1
a6 1
  $Date: 2000/05/24 04:34:01 $
d1616 1
a1616 2
	rb_ensure(rb_yield, port, rb_io_close, port);
	return Qnil;
d1667 1
a1667 2
	rb_ensure(rb_yield, file, rb_io_close, file);
	return Qnil;
@


1.34
log
@2000-05-24
@
text
@d6 1
a6 1
  $Date: 2000/05/17 04:38:13 $
d1594 1
a1594 1
    VALUE pname, pmode, port, proc;
d1596 1
a1596 1
    if (rb_scan_args(argc, argv, "12", &pname, &pmode, &proc) == 1) {
d1606 1
a1606 4
	if (!NIL_P(proc)) {
	    rb_eval_cmd(proc, rb_ary_new2(0));
	}
	else if (rb_block_given_p()) {
d1608 3
d1612 1
a1612 3
	fflush(stdout);
	fflush(stderr);
	_exit(0);
@


1.33
log
@2000-05-17
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/05/16 15:50:46 $
d108 1
a108 1
#  define ReadDataPending(fp) (fp->_state._eof == 0)
d396 12
d1587 2
a1588 1
rb_io_s_popen(argc, argv, self)
d1591 1
a1591 1
    VALUE self;
a1599 2
	int len;

a1600 3
	len = strlen(mode);
	if (len == 0 || len > 3)
	    rb_raise(rb_eArgError, "illegal access mode");
d1603 1
a1603 1
    port = pipe_open(RSTRING(pname)->ptr, mode);
a1607 1
	    _exit(0);
d1609 1
a1609 1
	else if (rb_iterator_p()) {
d1612 7
a1620 3
    else if (rb_iterator_p()) {
	return rb_ensure(rb_yield, port, rb_io_close, port);
    }
d1625 1
a1625 1
rb_file_initialize(argc, argv, io)
d1628 1
a1628 1
    VALUE io;
d1630 1
a1630 6
    VALUE fname, vmode, file, perm;
    char *path, *mode;

    rb_scan_args(argc, argv, "12", &fname, &vmode, &perm);
    Check_SafeStr(fname);
    path = RSTRING(fname)->ptr;
d1632 2
a1633 18
    if (FIXNUM_P(vmode)) {
	int flags = NUM2INT(vmode);
	int fmode = NIL_P(perm) ? 0666 : NUM2INT(perm);

	file = rb_file_sysopen_internal(io, path, flags, fmode);
    }
    else {
	if (!NIL_P(vmode)) {
	    mode = STR2CSTR(vmode);
	}
	else {
	    mode = "r";
	}
	file = rb_file_open_internal(io, RSTRING(fname)->ptr, mode);
    }

    if (rb_iterator_p()) {
	return rb_ensure(rb_yield, file, rb_io_close, file);
d1635 1
a1635 2

    return file;
d1660 2
a1661 2
	if (!NIL_P(vmode)) {
	    mode = STR2CSTR(vmode);
d1664 1
a1664 1
	    mode = "r";
d1669 3
a1671 2
    if (rb_iterator_p()) {
	return rb_ensure(rb_yield, file, rb_io_close, file);
d1682 2
a1683 3
    char *mode;
    VALUE pname, pmode, perm;
    VALUE port;
d1685 3
a1687 25
    rb_scan_args(argc, argv, "12", &pname, &pmode, &perm);
    Check_SafeStr(pname);
    if (RSTRING(pname)->ptr[0] != '|') /* open file */
	return rb_file_s_open(argc, argv, rb_cFile);

    /* open pipe */
    if (NIL_P(pmode)) {
	mode = "r";
    }
    else if (FIXNUM_P(pmode)) {
	mode = rb_io_flags_mode(NUM2INT(pmode));
    }
    else {
	int len;

	mode = STR2CSTR(pmode);
	len = strlen(mode);
	if (len == 0 || len > 3)
	    rb_raise(rb_eArgError, "illegal access mode %s", mode);
    }

    port = pipe_open(RSTRING(pname)->ptr+1, mode);
    if (!rb_iterator_p()) return port;
    if (NIL_P(port)) {
	rb_yield(port);
d1689 1
a1689 5
    else if (rb_iterator_p()) {
	return rb_ensure(rb_yield, port, rb_io_close, port);
    }

    return port;
d2246 21
a2266 2
    if (rb_iterator_p()) {
	return rb_ensure(rb_yield, io, rb_io_close, io);
d2268 14
a2281 1
    return io;
d3337 1
@


1.32
log
@mswin32 DLEXT2
O_BINARY
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/05/16 02:46:55 $
d1530 2
@


1.31
log
@remove configure from repositry
@
text
@d6 1
a6 1
  $Date: 2000/05/15 06:38:42 $
d1136 1
a1136 1
#if defined _IOBIN || defined O_BINARY
@


1.30
log
@2000-05-15
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/05/13 16:12:16 $
d66 1
a66 1
# ifdef NOFILE
@


1.29
log
@support mingw32.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/05/12 09:07:41 $
d1595 1
d1598 1
d1600 2
a1601 2
	else {
	    rb_yield(port);
d1603 1
@


1.28
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/10 02:58:34 $
d1136 1
a1136 1
#if defined(NT) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__) || defined(__EMX__)
@


1.27
log
@2000-05-10
@
text
@d6 1
a6 1
  $Date: 2000/05/09 04:52:59 $
d66 1
a66 1
# ifdef _X86_
d173 19
d1915 1
a1915 1
    fd = dup(fileno(orig->f));
d1918 1
a1918 1
	fd = dup(fileno(orig->f2));
a2147 19
static int
rb_dup(orig)
    int orig;
{
    int fd;

    fd = dup(orig);
    if (fd < 0) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    fd = dup(orig);
	}
	if (fd < 0) {
	    rb_sys_fail(0);
	}
    }
    return fd;
}

a2154 2
    int fd;
    char *mode;
a2180 2
    int fd;
    char *mode;
a2245 1
    OpenFile *fp;
@


1.26
log
@2000-05-09
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:20 $
d1560 1
a1560 1
    VALUE pname, pmode, port;
d1562 1
a1562 1
    if (rb_scan_args(argc, argv, "11", &pname, &pmode) == 1) {
d1576 6
a1581 1
	rb_yield(port);
d2283 3
@


1.25
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:44:13 $
d11 1
a11 1
  Copyright (C) 2000  Information-technology Promotion Agancy, Japan
@


1.24
log
@2000-04-10
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/03/23 08:37:27 $
d10 2
d13 1
a13 1
************************************************/
d214 1
a214 1
	fflush(f);
d246 1
a246 1
    if (fflush(f) == EOF) rb_sys_fail(0);
d536 3
d927 2
a928 2
static void
rb_io_fptr_close(fptr)
d931 1
a931 2
    int fd;

a933 1
    fd = fileno(fptr->f);
d941 5
a945 1
    rb_thread_fd_close(fd);
d948 2
a949 2
void
rb_io_fptr_finalize(fptr)
d952 2
d955 5
a959 5
    rb_io_fptr_close(fptr);
    if (fptr->path) {
	free(fptr->path);
	fptr->path = NULL;
    }
d969 3
d1350 1
a1350 1
    return rb_file_sysopen_internal((VALUE)io, fname, mode);
d1751 1
a1751 1
	fflush(orig->f2);
d1754 1
a1754 1
	fflush(orig->f);
d1867 1
a1867 1
	fflush(orig->f2);
d1870 1
a1870 1
	fflush(orig->f);
d1994 3
a1996 2
    if (fptr->mode & FMODE_SYNC)
	fflush(f);
d2266 1
a2266 1
	rb_io_fptr_finalize(RFILE(io)->fptr);
d2899 1
a2899 1
    w = prep_stdio(rb_fdopen(pipes[1], "w"), FMODE_WRITABLE, rb_cIO);
@


1.23
log
@2000-03-23
@
text
@d6 1
a6 1
  $Date: 2000/03/07 08:37:37 $
d1802 1
a1802 1
	if (TYPE(fname) == T_FILE) { /* fname must be IO */
d1898 1
a1898 1
    io_write(out, rb_f_sprintf(argc, argv));
d1918 1
a1918 1
    io_write(out, rb_f_sprintf(argc, argv));
d2337 1
a2337 2
			rb_str_cat(str, ruby_inplace_mode,
				   strlen(ruby_inplace_mode));
d3065 1
a3065 1
    else rb_str_cat(str, RSTRING(tmp)->ptr, RSTRING(tmp)->len);
@


1.22
log
@2000-03-07
@
text
@d6 1
a6 1
  $Date: 2000/02/29 08:05:25 $
d945 1
d1286 2
a1287 2
rb_file_open_internal(klass, fname, mode)
    VALUE klass;
d1291 2
a1292 3
    NEWOBJ(port, struct RFile);
    OBJSETUP(port, klass, T_FILE);
    MakeOpenFile(port, fptr);
d1298 1
a1298 1
    return (VALUE)port;
d1305 3
a1307 1
    return rb_file_open_internal(rb_cFile, fname, mode);
d1310 3
a1312 3
VALUE
rb_file_sysopen_internal(klass, fname, flags, mode)
    VALUE klass;
d1319 2
a1320 3
    NEWOBJ(port, struct RFile);
    OBJSETUP(port, klass, T_FILE);
    MakeOpenFile(port, fptr);
d1328 1
a1328 1
    return (VALUE)port;
d1336 3
a1338 1
    return rb_file_sysopen_internal(rb_cFile, fname, flags, mode);
d1573 36
d1617 2
d1627 1
a1627 1
	file = rb_file_sysopen_internal(klass, path, flags, fmode);
d1636 1
a1636 1
	file = rb_file_open_internal(klass, RSTRING(fname)->ptr, mode);
d2232 16
d2249 1
d2252 5
d2261 5
a2265 1
    return prep_stdio(rb_fdopen(NUM2INT(fnum), m), rb_io_mode_flags(m), klass);
d3244 1
a3388 1
    rb_define_singleton_method(rb_cFile, "new",  rb_file_s_open, -1);
d3390 1
@


1.21
log
@2000-02-29
@
text
@d6 1
a6 1
  $Date: 2000/02/18 06:59:30 $
a56 6
#ifdef USE_CWGUSI
 #include <sys/errno.h>
 #include <unix.mac.h>
 #include <compat.h>
#endif

a106 2
#elif defined(USE_CWGUSI)
#  define READ_DATA_PENDING(fp) (fp->state.eof == 0)
d1104 1
a1104 2
#if defined(NT) || defined(DJGPP) || defined(__CYGWIN__)\
    || defined(__human68k__) || defined(USE_CWGUSI) || defined(__EMX__)
a1113 1
# ifndef USE_CWGUSI
a1117 6
# else  /* USE_CWGUSI */
	if (fptr->f)
		fptr->f->mode.binary_io = 1;
	if (fptr->f2)
		fptr->f2->mode.binary_io = 1;
# endif /* USE_CWGUSI */
a1313 6
#ifdef USE_CWGUSI
    if (mode != 0666) {
	rb_warn("can't specify file mode on this platform");
    }
    return rb_file_open_internal(klass, fname, rb_io_flags_mode(flags));
#else
a1327 1
#endif
a1429 1
#ifndef USE_CWGUSI
a1535 4
#else /* USE_CWGUSI */
    rb_notimplement();  
    return Qnil;		/* not reached */
#endif
a2109 10

    GetOpenFile(*var, fptr);
    mode = rb_io_mode_string(fptr);
    fd = rb_dup(fileno(fptr->f));
    if (fileno(fptr->f) > 2) {
	fclose(fptr->f);
    }
    fptr->f = rb_fdopen(fd, mode);

    GetOpenFile(val, fptr);
a2110 2
    fclose(fptr->f);
    fptr->f = stdin;
a2143 11
    mode = rb_io_mode_string(fptr);
    f = GetWriteFile(fptr);
    fd = rb_dup(fileno(f));
    if (fileno(f) > 2) {
	fclose(fptr->f);
    }
    f = rb_fdopen(fd, mode);
    if (fptr->f2) fptr->f2 = f;
    else          fptr->f = f;

    GetOpenFile(val, fptr);
a2145 3
    fclose(f);
    if (fptr->f2) fptr->f2 = stdf;
    else          fptr->f = stdf;
d2300 1
a2300 1
#if !defined(MSDOS) && !defined(__CYGWIN__) && !(NT) && !defined(__human68k__) && !defined(USE_CWGUSI) && !defined(__BEOS__) && !defined(__EMX__)
d2653 1
a2653 1
# if defined(USE_CWGUSI) || defined(__CYGWIN__)
@


1.20
log
@2000-02-18
@
text
@d6 1
a6 1
  $Date: 2000/02/17 07:11:11 $
d1710 1
a1710 1
rb_io_reopen(io, nfile)
d1778 1
a1778 1
rb_file_reopen(argc, argv, file)
d1790 1
a1790 1
	    return rb_io_reopen(file, fname);
d3251 1
a3251 1
    rb_define_method(rb_cIO, "reopen", rb_io_reopen, 1);
a3373 2

    rb_define_method(rb_cFile, "reopen",  rb_file_reopen, -1);
@


1.19
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:48:50 $
d3401 1
a3401 1
    rb_file_const("BINARY", INT2FIX(O_SYNC));
@


1.18
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:18:02 $
d1611 2
a1612 2
	int flags = FIX2INT(vmode);
	int fmode = NIL_P(perm) ? 0666 : FIX2INT(perm);
d1652 1
a1652 1
	mode = rb_io_flags_mode(FIX2INT(pmode));
d1664 1
d3399 3
@


1.17
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:12:05 $
d966 1
a966 1
    GetOpenFile(io, fptr);
d2396 1
a2396 1
    if (argc == 0 && rb_rs == rb_default_rs) {
@


1.16
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:37:42 $
d168 9
@


1.15
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/08 05:00:18 $
d1579 6
a1584 1
    if (NIL_P(port)) return Qnil;
d1655 4
a1658 2
    if (NIL_P(port)) return Qnil;
    if (rb_iterator_p()) {
d3232 1
a3232 1
    rb_str_freeze(rb_default_rs);	/* avoid modifying RS_default */
@


1.14
log
@2000-01-08
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:37:04 $
d163 2
a164 2
void
rb_read_check(fp)
d167 1
a167 3
    if (!READ_DATA_PENDING(fp)) {
	rb_thread_wait_fd(fileno(fp));
    }
d1077 3
@


1.13
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:49:45 $
d457 1
d459 1
d1461 2
a1462 1
	    fptr->f2 = f;
@


1.12
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/11/25 09:03:05 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
a84 1
VALUE rb_fs;
d703 1
a703 1
rb_io_gets_method(argc, argv, io)
d769 1
a769 1
    VALUE line = rb_io_gets_method(argc, argv, io);
d887 1
a888 1
    Check_Type(c, T_FIXNUM);
d892 1
a892 1
    if (ungetc(FIX2INT(c), fptr->f) == EOF)
d968 1
a968 1
rb_io_close_method(io)
d1262 3
d1814 2
a1815 2
    NEWOBJ(obj, struct RFile);
    CLONESETUP(obj, io);
d1818 1
a1818 1
    MakeOpenFile(obj, fptr);
d1852 1
a1852 1
	rb_io_binmode((VALUE)obj);
d1855 1
a1855 1
    return (VALUE)obj;
d3216 1
a3216 3
    rb_fs = rb_output_fs = Qnil;
    rb_define_hooked_variable("$;", &rb_fs, 0, rb_str_setter);
    rb_define_hooked_variable("$-F", &rb_fs, 0, rb_str_setter);
d3258 1
a3258 1
    rb_define_method(rb_cIO, "gets",  rb_io_gets_method, -1);
d3276 1
a3276 1
    rb_define_method(rb_cIO, "close", rb_io_close_method, 0);
@


1.11
log
@19991125
@
text
@d6 1
a6 1
  $Date: 1999/11/17 07:30:30 $
d972 3
a974 1
    rb_secure(4);
d996 3
a998 1
    rb_secure(4);
d1022 3
a1024 1
    rb_secure(4);
d1694 4
a1697 1
    rb_secure(4);
a1698 1
    nfile = rb_io_get_io(nfile);
d3080 2
@


1.10
log
@19991117
@
text
@d6 1
a6 1
  $Date: 1999/11/04 08:39:37 $
d429 1
a429 1
	if (n == 0) {
d1095 1
a1095 1
#if defined(NT) || defined(DJGPP) || defined(__CYGWIN32__)\
d1341 1
a1341 1
#if defined (NT) || defined(DJGPP) || defined(__CYGWIN32__) || defined(__human68k__)
d1400 1
a1400 1
#if !defined (__CYGWIN32__)
d1531 1
a1531 1
#if defined (__CYGWIN32__)
d2290 1
a2290 1
#if defined(MSDOS) || defined(__CYGWIN32__) || defined(NT)
d2296 1
a2296 1
#if defined(MSDOS) || defined(__BOW__) || defined(__CYGWIN32__) || defined(NT) || defined(__human68k__) || defined(__EMX__)
d2311 1
a2311 1
#if !defined(MSDOS) && !defined(__BOW__) && !defined(__CYGWIN32__) && !defined(NT) && !defined(__human68k__)
d2323 1
a2323 1
#if !defined(MSDOS) && !defined(__CYGWIN32__) && !(NT) && !defined(__human68k__) && !defined(USE_CWGUSI) && !defined(__BEOS__) && !defined(__EMX__)
d2676 1
a2676 1
# ifdef USE_CWGUSI
d3338 1
a3338 1
#if defined (NT) || defined(DJGPP) || defined(__CYGWIN32__) || defined(__human68k__)
@


1.9
log
@19991104
@
text
@d6 1
a6 1
  $Date: 1999/10/29 09:25:31 $
d3286 1
@


1.8
log
@19991029
@
text
@d6 1
a6 1
  $Date: 1999/10/16 10:33:06 $
d3257 3
a3259 3
    rb_define_const(rb_cIO, "SEEK_SET", SEEK_SET);
    rb_define_const(rb_cIO, "SEEK_CUR", SEEK_CUR);
    rb_define_const(rb_cIO, "SEEK_END", SEEK_END);
@


1.7
log
@ruby -v
@
text
@d6 1
a6 1
  $Date: 1999/10/13 06:44:41 $
d455 3
a463 3
	if (!READ_DATA_PENDING(f)) {
	    rb_thread_wait_fd(fileno(f));
	}
@


1.6
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/09/22 04:30:09 $
d2630 1
a2630 1
    int cmd = NUM2INT(req);
@


1.5
log
@19990922
@
text
@d6 1
a6 1
  $Date: 1999/09/20 07:14:18 $
d485 3
d493 1
@


1.5.2.1
log
@19991013
@
text
@d6 1
a6 1
  $Date: 1999/09/22 04:30:09 $
a484 3
    if (len < 0) {
	rb_raise(rb_eArgError, "negative length %d given", len);
    }
a489 1
    if (len == 0) return str;
@


1.5.2.2
log
@19991018
@
text
@d6 1
a6 1
  $Date: 1999/10/13 03:42:12 $
d2630 1
a2630 1
    int cmd = NUM2ULONG(req);
@


1.5.2.3
log
@19991025
@
text
@d6 1
a6 1
  $Date: 1999/10/18 09:03:16 $
a454 3
	if (!READ_DATA_PENDING(f)) {
	    rb_thread_wait_fd(fileno(f));
	}
d461 3
@


1.5.2.4
log
@19991104
@
text
@d6 1
a6 1
  $Date: 1999/10/25 05:09:12 $
d3257 3
a3259 3
    rb_define_const(rb_cIO, "SEEK_SET", INT2FIX(SEEK_SET));
    rb_define_const(rb_cIO, "SEEK_CUR", INT2FIX(SEEK_CUR));
    rb_define_const(rb_cIO, "SEEK_END", INT2FIX(SEEK_END));
@


1.5.2.5
log
@19991124-1.4.3pre1
@
text
@d6 1
a6 1
  $Date: 1999/11/04 08:39:55 $
d429 1
a429 1
	if (n == 0 && bytes == 0) {
d1095 1
a1095 1
#if defined(NT) || defined(DJGPP) || defined(__CYGWIN__)\
d1341 1
a1341 1
#if defined (NT) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__)
d1400 1
a1400 1
#if !defined (__CYGWIN__)
d1531 1
a1531 1
#if defined (__CYGWIN__)
d2290 1
a2290 1
#if defined(MSDOS) || defined(__CYGWIN__) || defined(NT)
d2296 1
a2296 1
#if defined(MSDOS) || defined(__BOW__) || defined(__CYGWIN__) || defined(NT) || defined(__human68k__) || defined(__EMX__)
d2311 1
a2311 1
#if !defined(MSDOS) && !defined(__BOW__) && !defined(__CYGWIN__) && !defined(NT) && !defined(__human68k__)
d2323 1
a2323 1
#if !defined(MSDOS) && !defined(__CYGWIN__) && !(NT) && !defined(__human68k__) && !defined(USE_CWGUSI) && !defined(__BEOS__) && !defined(__EMX__)
d2676 1
a2676 1
# if defined(USE_CWGUSI) || defined(__CYGWIN__)
d3337 1
a3337 1
#if defined (NT) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__)
@


1.5.2.6
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/11/24 07:13:51 $
a3071 2
	return Qtrue;
    if (next_p == -1)
@


1.5.2.7
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:50:38 $
a1256 3
#ifdef __human68k__
    fmode(file, _IOTEXT);
#endif
@


1.5.2.8
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:41:07 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
a457 1
	TRAP_BEG;
a458 1
	TRAP_END;
d1454 1
a1454 2
	    if (fptr->f) fptr->f2 = f;
	    else fptr->f = f;
@


1.5.2.9
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:24:02 $
d960 1
a960 1
    fptr = RFILE(io)->fptr;
d2372 1
a2372 1
    else if (argc == 0 && rb_rs == rb_default_rs) {
@


1.5.2.10
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:53:51 $
d1591 2
a1592 2
	int flags = NUM2INT(vmode);
	int fmode = NIL_P(perm) ? 0666 : NUM2INT(perm);
d1632 1
a1632 1
	mode = rb_io_flags_mode(NUM2INT(pmode));
@


1.5.2.11
log
@2000-04-10
@
text
@d6 1
a6 1
  $Date: 2000/02/17 08:28:55 $
d1860 1
a1860 1
    rb_io_write(out, rb_f_sprintf(argc, argv));
d1880 1
a1880 1
    rb_io_write(out, rb_f_sprintf(argc, argv));
@


1.5.2.12
log
@2000-04-17
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:48:36 $
d214 1
a214 1
	if (fflush(f) == EOF) rb_sys_fail(fptr->path);
d246 1
a246 1
    if (fflush(f) == EOF) rb_sys_fail(fptr->path);
a960 3
    if (fptr->mode & FMODE_WRITABLE) {
	rb_io_flush(io);
    }
d1701 1
a1701 1
	if (fflush(orig->f2) == EOF) rb_sys_fail(orig->path);
d1704 1
a1704 1
	if (fflush(orig->f) == EOF) rb_sys_fail(orig->path);
d1817 1
a1817 1
	if (fflush(orig->f2) == EOF) rb_sys_fail(orig->path);
d1820 1
a1820 1
	if (fflush(orig->f) == EOF) rb_sys_fail(orig->path);
d1944 2
a1945 3
    if (fptr->mode & FMODE_SYNC) {
	if (fflush(f) == EOF) rb_sys_fail(fptr->path);
    }
@


1.5.2.13
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/17 06:24:43 $
d2853 1
a2853 1
    w = prep_stdio(rb_fdopen(pipes[1], "w"), FMODE_WRITABLE|FMODE_SYNC, rb_cIO);
@


1.5.2.14
log
@2000-06-05
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:42:26 $
d70 1
a70 1
# ifndef NOFILE
d113 1
a113 1
#  define READ_DATA_PENDING(fp) (fp->_state._eof == 0)
@


1.5.2.15
log
@2000-06-13
@
text
@d6 1
a6 1
  $Date: 2000/06/05 09:00:55 $
d585 1
a585 4
		    if (ferror(f)) {
			ig (errno == EINTR) continue;
			rb_sys_fail(fptr->path);
		    }
d672 1
a672 4
	    if (ferror(f)) {
		ig (errno == EINTR) continue;
		rb_sys_fail(fptr->path);
	    }
@


1.5.2.16
log
@2000-06-14
@
text
@d6 1
a6 1
  $Date: 2000/06/13 09:50:47 $
d586 1
a586 1
			if (errno == EINTR) continue;
d676 1
a676 1
		if (errno == EINTR) continue;
@


1.5.2.17
log
@2000-06-20
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/06/14 04:19:20 $
d744 1
a744 2
    fptr->lineno = NUM2INT(lineno);
    return lineno;
@


1.5.2.18
log
@matz
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/06/20 06:08:38 $
a384 26
static size_t
io_fread(ptr, len, f)
    char *ptr;
    size_t len;
    FILE *f;
{
    size_t n = len;
    int c;

    while (n--) {
	if (!READ_DATA_PENDING(f)) {
	    rb_thread_wait_fd(fileno(f));
	}
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c == EOF) {
	    *ptr = '\0';
	    break;
	}
	*ptr++ = c;
    }

    return len - n - 1;
}

a423 1
    READ_CHECK(fptr->f);
d425 4
a428 1
	n = io_fread(RSTRING(str)->ptr+bytes, siz-bytes, fptr->f);
d445 26
a1729 1
	clearerr(fptr->f);
d3089 2
@


1.5.2.19
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/24 07:16:08 $
d101 1
a101 1
static int init_p = 0, next_p = 0, first_p = 1;
a2276 1
	first_p = 0;
a3086 2
    int first = first_p;

a3088 3
    if (!first && next_p == -1) {
	return Qtrue;
    }
@


1.5.2.20
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/15 08:57:48 $
a2274 1
	    filename = rb_str_new2("-");
@


1.5.2.21
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/28 03:12:07 $
a2050 1
    fflush(stdout);
@


1.4
log
@19990920
@
text
@d6 1
a6 1
  $Date: 1999/08/24 08:21:53 $
d452 1
d455 2
a456 2
	*ptr = getc(f);
	if (*ptr == EOF) {
d460 1
a460 1
	ptr++;
@


1.3
log
@1.4.1 to be
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:06 $
d445 23
d491 1
a491 3
    TRAP_BEG;
    n = fread(RSTRING(str)->ptr, 1, len, fptr->f);
    TRAP_END;
d588 1
a588 3
	    TRAP_BEG;
	    cnt = fread(buf, 1, sizeof(buf), f);
	    TRAP_END;
d1411 7
d1421 1
a1421 4
    if (fptr->f2 == 0) rb_raise(rb_eTypeError, "non-writable fptr");
    if (fptr->f != 0) setbuf(fptr->f, NULL);
    setbuf(fptr->f2, NULL);
    fptr->mode |= FMODE_SYNC;
d1447 1
a1447 1
	    rb_io_unbuffered(fptr);
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:17:39 $
d187 1
a187 1
    if (BUILTIN_TYPE(io) != T_FILE) {
d1826 1
a1826 2
    rb_funcall(out, id_write, 1, rb_f_sprintf(argc, argv));

d1831 1
a1831 1
rb_rb_f_printf(argc, argv)
d1841 1
a1841 1
    else if (rb_respond_to(argv[0], id_write)) {
d1846 1
a1846 4
    else {
	rb_raise(rb_eNameError, "output must responds to `write'");
    }
    rb_funcall(out, id_write, 1, rb_f_sprintf(argc, argv));
d3150 1
a3150 1
    rb_define_global_function("printf", rb_rb_f_printf, -1);
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1996/12/25 10:42:39 $
d9 1
a9 1
  Copyright (C) 1993-1996 Yukihiro Matsumoto
d14 3
a16 1
#include "io.h"
d24 1
a24 1
#if defined(HAVE_FCNTL)
d26 2
d46 2
a47 5
#if defined(DJGPP) || defined(__CYGWIN32__) || defined(NT) || defined(__human68k__)
#include <fcntl.h>
#endif

#ifdef HAVE_SYS_PARAM_H
d53 15
a67 1
VALUE rb_ad_string();
d69 12
a80 4
VALUE cIO;
extern VALUE cFile;
VALUE eEOFError;
VALUE eIOError;
d83 1
d85 5
a89 3
VALUE FS, OFS;
VALUE RS, ORS;
VALUE RS_default;
d93 1
a93 1
ID id_write;
d95 1
a95 2
VALUE lastline_get();
void lastline_set();
d97 1
a97 1
extern char *inplace;
d99 4
a102 1
struct timeval time_timeval();
d110 6
a116 3
#  ifdef FILE_COUNT
#    define READ_DATA_PENDING(fp) ((fp)->FILE_COUNT > 0)
#  else
d119 1
a119 2
#    define READ_DATA_PENDING(fp) ReadDataPending(fp)
#  endif
d122 5
a126 5
#ifndef THREAD
# define READ_CHECK(fp) 0
#else
# define READ_CHECK(fp) do {\
    if (!READ_DATA_PENDING(fp)) thread_wait_fd(fileno(fp));\
a127 1
#endif
d130 1
a130 1
eof_error()
d132 1
a132 1
    Raise(eEOFError, "End of file reached");
d136 1
a136 1
io_writable(fptr)
d139 2
a140 2
    if (!(fptr->mode & FMODE_WRITABLE)) {
	Raise(eIOError, "not opened for writing");
d142 2
d147 1
a147 1
io_readable(fptr)
d151 10
a160 1
	Raise(eIOError, "not opened for reading");
d164 3
a166 2
static void
closed()
d168 3
a170 1
    Raise(eIOError, "closed stream");
d174 1
a174 1
VALUE
d176 1
a176 2
    VALUE io;
    struct RString *str;
d182 1
d184 2
a185 2
	str = (struct RString*)obj_as_string(str);
    if (str->len == 0) return INT2FIX(0);
d188 1
a191 1
    rb_secure(4);
d193 1
a193 2
    io_writable(fptr);

a194 1
    if (f == NULL) closed();
d198 2
a199 2
	register UCHAR *ptr = str->ptr;
	n = (int) str->len;
d203 1
a203 1
	n = ptr - str->ptr;
d208 2
a209 2
    n = fwrite(str->ptr, 1, str->len, f);
    if (n == 0 || ferror(f)) {
d220 7
d228 1
a228 1
io_puts(io, str)
d231 1
a231 1
    io_write(io, str);
d236 1
a236 1
io_flush(io)
d243 1
a243 1
    io_writable(fptr);
a244 1
    if (f == NULL) closed();
d252 64
a315 1
io_eof(io)
d322 1
a322 5
    io_readable(fptr);
    if (fptr->f == NULL) closed();

    if (READ_DATA_PENDING(fptr->f)) return FALSE;
    if (feof(fptr->f)) return TRUE;
d324 3
d332 2
a333 2
	(void)ungetc(ch, fptr->f);
	return FALSE;
d335 1
a335 1
    return TRUE;
d339 1
a339 1
io_sync(io)
d345 1
a345 1
    return (fptr->mode & FMODE_SYNC) ? TRUE : FALSE;
d349 1
a349 1
io_set_sync(io, mode)
d365 1
a365 1
io_fileno(io)
d376 7
d384 7
d397 3
a399 1
    char buf[BUFSIZ];
d403 1
a403 2
    io_readable(fptr);
    if (fptr->f == NULL) closed();
d405 19
d427 1
a427 1
	n = fread(buf, 1, BUFSIZ, fptr->f);
d429 14
a442 6
	if (n == 0) break;
	if (n < 0) rb_sys_fail(0);
	if (NIL_P(str)) str = str_new(buf, n);
	else str_cat(str, buf, n);
    }
    return str_taint(str);
d452 2
a453 2
    int n, lgt;
    VALUE len, str;
d455 2
a456 1
    if (rb_scan_args(argc, argv, "01", &len) == 0) {
d460 1
a460 1
    lgt = NUM2INT(len);
d462 1
a462 2
    io_readable(fptr);
    if (fptr->f == NULL) closed();
d464 2
a465 1
    str = str_new(0, lgt);
d469 1
a469 1
    n = fread(RSTRING(str)->ptr, 1, RSTRING(str)->len, fptr->f);
a474 1

d477 1
d479 1
a479 1
    return str_taint(str);
d482 2
a483 4
static VALUE lineno;

VALUE
io_gets_method(argc, argv, io)
d485 1
a485 1
    VALUE argv;
d490 1
a490 1
    struct RString *str;
d496 3
a498 1
    if (argc == 0) rs = RS;
d504 5
a508 6
    GetOpenFile(io, fptr);
    io_readable(fptr);
    f = fptr->f;
    if (f == NULL) closed();

    if (!NIL_P(rs)) {
d515 3
d522 4
a525 5
    else {
	rsptr = 0;
	rslen = 0;
    }
    newline = rslen ? rsptr[rslen - 1] : 0777;
d540 1
d556 4
a559 1
		if (c == EOF) break;
d570 7
a576 1
	    c = cnt ? 0 : EOF;
d579 3
a581 5
	if (c == EOF) {
	    if (!append && cnt == 0) {
		str = RSTRING(Qnil);
		goto return_gets;
	    }
d585 1
a585 1
	    str_cat(str, buf, cnt);
d587 1
a587 1
	    str = (struct RString*)str_new(buf, cnt);
d591 2
a592 2
	     str->len < rslen ||
	     memcmp(str->ptr+str->len-rslen, rsptr, rslen))) {
d612 1
a612 1
    if (str) {
d615 1
a616 1
    lastline_set(str);
d618 1
a618 1
    return str_taint(str);
d622 61
a682 1
io_gets(io)
d685 47
a731 1
    return io_gets_method(0, 0, io);
d735 7
a741 1
io_readline(argc, argv, io)
d743 1
a743 1
    VALUE argv;
d746 1
a746 1
    VALUE line = io_gets_method(argc, argv, io);
d749 1
a749 1
	eof_error();
d755 1
a755 1
io_readlines(argc, argv, io)
d757 1
a757 1
    VALUE argv;
d762 3
a764 3
    ary = ary_new();
    while (!NIL_P(line = io_gets_method(argc, argv, io))) {
	ary_push(ary, line);
d770 1
a770 1
io_each_line(argc, argv, io)
d772 1
a772 1
    VALUE argv;
d777 1
a777 1
    while (!NIL_P(str = io_gets_method(argc, argv, io))) {
d780 1
a780 1
    return Qnil;
d784 1
a784 1
io_each_byte(io)
d792 1
a792 1
    io_readable(fptr);
a793 1
    if (f == NULL) closed();
d803 1
a803 1
    if (ferror(f) != 0) rb_sys_fail(fptr->path);
d808 1
a808 1
io_getc(io)
d816 1
a816 1
    io_readable(fptr);
a817 1
    if (f == NULL) closed();
d825 1
a825 1
	if (ferror(f) != 0) rb_sys_fail(fptr->path);
d831 16
d848 1
a848 1
io_readchar(io)
d851 1
a851 1
    VALUE c = io_getc(io);
d854 1
a854 1
	eof_error();
d860 1
a860 1
io_ungetc(io, c)
d867 1
a867 2
    io_readable(fptr);
    if (fptr->f == NULL) closed();
d871 1
d875 1
a875 1
io_isatty(io)
a880 1
    if (fptr->f == NULL) closed();
d882 2
a883 2
	return FALSE;
    return TRUE;
d896 26
d926 10
d940 11
d953 4
a956 2
void
io_fptr_finalize(fptr)
d958 3
a960 9
{
    if (fptr->finalize) {
	(*fptr->finalize)(fptr);
	fptr->finalize = 0;
    }
    else {
	fptr_finalize(fptr);
    }
    fptr->f = fptr->f2 = NULL;
d964 1
a964 1
io_close(io)
d968 1
d970 1
d972 11
a982 1
    io_fptr_finalize(fptr);
d988 1
a988 1
io_closed(io)
d992 1
d994 1
d996 12
a1007 1
    return fptr->f?FALSE:TRUE;
d1011 1
a1011 1
io_syswrite(io, str)
d1020 1
a1020 1
	str = obj_as_string(str);
d1023 1
a1023 1
    io_writable(fptr);
a1024 1
    if (f == NULL) closed();
d1026 3
a1028 3
#ifdef THREAD
    thread_fd_writable(fileno(f));
#endif
d1037 1
a1037 1
io_sysread(io, len)
d1046 1
a1046 2
    io_readable(fptr);
    if (fptr->f == NULL) closed();
d1048 1
a1048 1
    str = str_new(0, ilen);
d1050 1
a1050 3
#ifdef THREAD
    thread_wait_fd(fileno(fptr->f));
#endif
d1056 3
a1058 1
    if (n == 0) eof_error();
d1062 3
a1064 1
    return str_taint(str);
d1068 1
a1068 1
io_binmode(io)
d1071 2
a1072 1
#if defined(NT) || defined(DJGPP) || defined(__CYGWIN32__) || defined(__human68k__)
d1079 1
a1079 1
    if (fptr->f2);
d1082 1
d1087 6
d1101 2
a1102 2
io_mode_flags(mode)
    char *mode;
d1117 2
a1118 1
	ArgError("illegal access mode");
d1128 28
d1157 1
d1162 54
d1218 2
a1219 2
    char *fname;
    char *mode;
d1221 1
a1221 1
    FILE *f;
d1223 2
a1224 2
    f = fopen(fname, mode);
    if (f == NULL) {
d1226 2
a1227 2
	    gc();
	    f = fopen(fname, mode);
d1229 1
a1229 1
	if (f == NULL) {
d1233 1
a1233 1
    return f;
d1239 1
a1239 1
    char *mode;
d1241 1
a1241 1
    FILE *f;
d1243 5
a1247 4
    f = fdopen(fd, mode);
    if (f == NULL) {
	if (errno == EMFILE) {
	    f = fdopen(fd, mode);
d1249 1
a1249 1
	if (f == NULL) {
d1253 62
a1314 1
    return f;
d1344 1
d1363 1
d1366 3
a1368 2
	io_fptr_finalize(list->fptr);
	list = list->next;
a1371 1
#if !defined (__CYGWIN32__)
d1376 1
d1384 3
a1389 1
#endif
d1392 1
a1392 1
io_unbuffered(fptr)
d1395 1
a1395 1
    if (fptr->f2 == 0) TypeError("non-writable fptr");
d1405 2
a1406 1
    int modef = io_mode_flags(mode);
d1415 1
a1415 1
	OBJSETUP(port, cIO, T_FILE);
d1424 1
a1424 1
	    io_unbuffered(fptr);
d1462 1
a1462 10
	    VALUE serr = io_fileno(rb_stderr);
	    int fd = FIX2INT(serr);
	    extern char *sourcefile;
	    extern int   sourceline;

	    if (fd != 2) {
		close(2);
		dup2(fd, 2);
		close(fd);
	    }
d1468 1
a1468 1
		    sourcefile, sourceline, pname);
d1475 1
a1475 5
#ifdef THREAD
	    thread_sleep(1);
#else
	    sleep(1);
#endif
d1483 2
a1484 1
	{
d1486 1
a1486 1
	    OBJSETUP(port, cIO, T_FILE);
d1504 1
d1511 4
d1518 1
a1518 1
io_s_popen(argc, argv, self)
d1524 1
a1524 1
    VALUE pname, pmode;
d1526 1
a1526 3
    rb_scan_args(argc, argv, "11", &pname, &pmode);
    Check_SafeStr(pname);
    if (NIL_P(pmode)) {
d1530 11
a1540 6
	Check_Type(pmode, T_STRING);
	if (RSTRING(pmode)->len == 0 || RSTRING(pmode)->len > 3)
	    ArgError("illegal access mode");
	mode = RSTRING(pmode)->ptr;
   }
    return pipe_open(RSTRING(pname)->ptr, mode);
d1544 4
a1547 2
io_open(fname, mode)
    char *fname, *mode;
d1549 12
a1560 2
    if (fname[0] == '|') {
	return pipe_open(fname+1, mode);
d1563 11
a1573 1
	return file_open(fname, mode);
d1575 2
d1580 1
a1580 1
f_open(argc, argv, self)
a1582 1
    VALUE self;
d1585 2
a1586 1
    VALUE pname, pmode;
d1588 1
a1588 1
    rb_scan_args(argc, argv, "11", &pname, &pmode);
d1590 4
d1597 28
d1626 1
a1626 4
	Check_Type(pmode, T_STRING);
	if (RSTRING(pmode)->len == 0 || RSTRING(pmode)->len > 3)
	    ArgError("illegal access mode");
	mode = RSTRING(pmode)->ptr;
a1627 1
    return io_open(RSTRING(pname)->ptr, mode);
d1630 21
a1650 3
#ifndef NT
extern char *strdup();
#endif
d1652 2
a1653 2
VALUE
io_reopen(io, nfile)
d1660 1
d1662 1
a1662 1
    Check_Type(nfile, T_FILE);
d1665 1
d1672 1
d1683 12
a1694 10
    switch (fptr->mode & FMODE_READWRITE) {
      case FMODE_READABLE:
      default:
	mode = "r"; break;
      case FMODE_WRITABLE:
	mode = "w"; break;
      case FMODE_READWRITE:
	if (orig->f2) mode = "r";
	else          mode = "r+";
	break;
a1695 4
    fd = fileno(fptr->f);
    fclose(fptr->f);
    dup2(fileno(orig->f), fd);
    fptr->f = rb_fdopen(fd, mode);
d1701 3
a1703 2
	    dup2(fileno(orig->f2), fd);
	    fptr->f = rb_fdopen(fd, "w");
d1711 1
a1711 1
	io_binmode(io);
d1714 1
a1714 1
    RBASIC(io)->class = RBASIC(nfile)->class;
d1719 51
a1769 1
io_clone(io)
d1777 1
a1777 1
    OBJSETUP(obj, CLASS_OF(io), T_FILE);
d1814 1
a1814 1
	io_binmode(obj);
d1821 1
a1821 1
io_printf(argc, argv, out)
d1826 1
a1826 1
    rb_funcall(out, id_write, 1, f_sprintf(argc, argv));
d1832 1
a1832 1
f_printf(argc, argv)
d1848 1
a1848 1
	NameError("output must responds to `write'");
d1850 1
a1850 1
    rb_funcall(out, id_write, 1, f_sprintf(argc, argv));
d1856 1
a1856 1
io_print(argc, argv, out)
d1867 1
a1867 1
	line = lastline_get();
d1871 69
a1939 2
	if (!NIL_P(OFS) && i>0) {
	    io_write(out, OFS);
d1941 20
d1963 1
a1963 1
	    io_write(out, str_new2("nil"));
d1966 2
a1967 2
	    ary_print_on(argv[i], out);
	    break;
d1969 1
a1969 1
	    io_write(out, argv[i]);
d1972 5
a1976 3
    }
    if (!NIL_P(ORS)) {
	io_write(out, ORS);
d1983 20
a2002 1
f_print(argc, argv)
d2006 5
a2010 1
    io_print(argc, argv, rb_defout);
d2015 4
a2018 2
f_p(obj, val)
    VALUE obj, val;
d2020 7
a2026 1
    VALUE str = rb_inspect(val);
a2027 3
    Check_Type(str, T_STRING);
    io_write(rb_defout, str);
    io_write(rb_defout, str_new2("\n"));
d2032 1
a2032 1
io_defset(val, id)
a2035 3
    if (TYPE(val) == T_STRING) {
	val = io_open(RSTRING(val)->ptr, "w");
    }
d2037 2
a2038 2
	TypeError("$< must have write method, %s given",
		  rb_class2name(CLASS_OF(val)));
d2043 124
d2168 1
a2168 1
prep_stdio(f, mode)
d2171 1
d2174 2
a2175 2
    NEWOBJ(obj, struct RFile);
    OBJSETUP(obj, cIO, T_FILE);
d2177 1
a2177 1
    MakeOpenFile(obj, fp);
d2181 1
a2181 1
    return (VALUE)obj;
d2185 1
a2185 1
io_s_new(argc, argv)
d2188 1
a2190 1
    FILE *f;
d2193 1
a2193 3
    rb_scan_args(argc, argv, "11", &fnum, &mode);

    if (!NIL_P(mode)) {
d2197 10
a2206 2
    f = rb_fdopen(NUM2INT(fnum), m);
    return prep_stdio(f, io_mode_flags(m));
d2209 12
a2220 3
static VALUE filename, file;
static int gets_lineno;
static int init_p = 0, next_p = 0;
d2225 1
a2225 1
    extern VALUE Argv;
d2229 1
a2229 1
	if (RARRAY(Argv)->len > 0) {
d2234 1
a2234 1
	    file = rb_stdin;
d2243 6
a2248 6
	if (RARRAY(Argv)->len > 0) {
	    filename = ary_shift(Argv);
	    fn = RSTRING(filename)->ptr;
	    if (RSTRING(filename)->len == 1 && fn[0] == '-') {
		file = rb_stdin;
		if (inplace) {
d2255 1
a2255 1
		if (inplace) {
d2260 2
a2261 2
		    if (rb_defout != rb_stdout) {
			io_close(rb_defout);
d2264 2
a2265 2
		    if (*inplace) {
			str = str_new2(fn);
d2267 1
a2267 1
			add_suffix(str, inplace);
d2269 2
a2270 1
			str_cat(str, inplace, strlen(inplace));
d2272 1
a2272 1
#if defined(MSDOS) || defined(__BOW__) || defined(__CYGWIN32__) || defined(NT) || defined(__human68k__)
d2279 1
a2279 1
			    Warning("Can't rename %s to %s: %s, skipping file",
d2289 2
a2290 2
			    Warning("Can't remove %s: %s, skipping file",
				fn, strerror(errno));
d2295 1
a2295 1
			Fatal("Can't do inplace edit without backup");
d2299 1
a2299 1
#if !defined(MSDOS) && !defined(__CYGWIN32__) && !(NT) && !defined(__human68k__)
d2306 1
a2306 1
		    rb_defout = prep_stdio(fw, FMODE_WRITABLE);
d2308 1
a2308 1
		file = prep_stdio(fr, FMODE_READABLE);
d2310 1
d2314 1
a2314 1
	    return FALSE;
d2317 11
a2327 1
    return TRUE;
d2331 1
a2331 1
f_gets_method(argc, argv)
d2339 9
a2347 1
    line = io_gets_method(argc, argv, file);
d2349 1
a2349 1
	io_close(file);
a2358 6
VALUE
f_gets()
{
    return f_gets_method(0,0);
}

d2360 1
a2360 1
f_readline(argc, argv)
d2362 1
a2362 1
    VALUE argv;
d2364 1
a2364 5
    VALUE line = f_gets_method(argc, argv);

    if (NIL_P(line)) {
	eof_error();
    }
d2366 1
d2370 2
a2371 2
static VALUE
f_eof()
d2373 11
a2383 3
    if (init_p == 0 && !next_argv())
	return TRUE;
    if (io_eof(file)) {
d2385 6
a2390 1
	return TRUE;
d2392 2
a2393 1
    return FALSE;
d2397 3
a2399 1
f_getc()
d2401 1
a2401 2
    return io_getc(rb_stdin);
}
d2403 2
a2404 6
static VALUE
f_ungetc(obj, c)
    VALUE obj, c;
{
    if (!next_argv()) {
	ArgError("no stream to ungetc");
d2407 1
a2407 1
    return io_ungetc(file, c);
d2411 1
a2411 1
f_readchar()
d2413 2
a2414 6
    VALUE c = f_getc();

    if (NIL_P(c)) {
	eof_error();
    }
    return c;
d2418 1
a2418 1
f_readlines(argc, argv)
d2420 1
a2420 1
    VALUE argv;
d2424 3
a2426 3
    ary = ary_new();
    while (!NIL_P(line = f_gets_method(argc, argv))) {
	ary_push(ary, line);
d2439 1
a2439 1
	TypeError("value of %s must be String", rb_id2name(id));
d2445 2
a2446 3
f_backquote(obj, str)
    VALUE obj;
    struct RString *str;
d2451 2
a2452 1
    port = pipe_open(str->ptr, "r");
d2455 1
a2455 1
    io_close(port);
d2457 1
a2457 1
    if (NIL_P(result)) return str_new(0,0);
a2463 3
#ifdef NT
#define select(v, w, x, y, z) (-1) /* anytime fail */
#endif
d2466 1
a2466 1
f_select(argc, argv, obj)
d2477 1
a2477 1
    int interrupt = 0;
d2485 1
a2485 1
	timerec = time_timeval(timeout);
a2490 1

d2495 1
a2495 3
	    Check_Type(RARRAY(read)->ptr[i], T_FILE);
	    GetOpenFile(RARRAY(read)->ptr[i], fptr);
	    if (fptr->f == NULL) closed();
d2516 1
a2516 3
	    Check_Type(RARRAY(write)->ptr[i], T_FILE);
	    GetOpenFile(RARRAY(write)->ptr[i], fptr);
	    if (fptr->f == NULL) closed();
d2518 1
a2518 1
	    if (max > fileno(fptr->f)) max = fileno(fptr->f);
d2521 1
a2521 1
		if (max < (int)fileno(fptr->f2)) max = fileno(fptr->f2);
d2533 1
a2533 3
	    Check_Type(RARRAY(except)->ptr[i], T_FILE);
	    GetOpenFile(RARRAY(except)->ptr[i], fptr);
	    if (fptr->f == NULL) closed();
d2538 1
a2538 1
		if (max > (int)fileno(fptr->f2)) max = fileno(fptr->f2);
d2547 1
a2547 2
#ifdef THREAD
    n = thread_select(max, rp, wp, ep, tp);
a2550 13
#else
  retry:
    TRAP_BEG;
    n = select(max, rp, wp, ep, tp);
    TRAP_END;
    if (n < 0) {
	if (errno != EINTR) {
	    rb_sys_fail(0);
	}
	if (tp == NULL) goto retry;
	interrupt = 1;
    }
#endif
d2553 4
a2556 4
    res = ary_new2(3);
    ary_push(res, rp?ary_new():ary_new2(0));
    ary_push(res, wp?ary_new():ary_new2(0));
    ary_push(res, ep?ary_new():ary_new2(0));
d2558 1
a2558 1
    if (interrupt == 0) {
d2562 1
a2562 1
		GetOpenFile(RARRAY(read)->ptr[i], fptr);
d2565 1
a2565 1
		    ary_push(list, RARRAY(read)->ptr[i]);
d2573 1
a2573 1
		GetOpenFile(RARRAY(write)->ptr[i], fptr);
d2575 1
a2575 1
		    ary_push(list, RARRAY(write)->ptr[i]);
d2578 1
a2578 1
		    ary_push(list, RARRAY(write)->ptr[i]);
d2586 1
a2586 1
		GetOpenFile(RARRAY(except)->ptr[i], fptr);
d2588 1
a2588 1
		    ary_push(list, RARRAY(except)->ptr[i]);
d2591 1
a2591 1
		    ary_push(list, RARRAY(except)->ptr[i]);
d2601 2
a2602 3
io_ctl(io, req, arg, io_p)
    VALUE io, req;
    struct RString *arg;
d2608 2
a2609 1
    int len, fd;
d2616 1
a2616 1
    if (NIL_P(arg) || (VALUE)arg == FALSE) {
d2622 1
a2622 1
    else if ((VALUE)arg == TRUE) {
d2638 1
a2638 1
	str_modify(arg);
d2640 2
a2641 2
	if (len < arg->len) {
	    len = arg->len;
d2643 5
a2647 3
	str_resize(arg, len+1);
	arg->ptr[len] = 17;	/* a little sanity check here */
	narg = (long)arg->ptr;
d2651 4
d2656 2
d2662 1
d2664 1
d2667 2
a2668 2
    if (TYPE(arg) == T_STRING && arg->ptr[len] != 17) {
	ArgError("return value overflowed string");
d2673 1
d2678 1
a2678 1
io_ioctl(argc, argv, io)
d2686 1
a2686 1
    return io_ctl(io, req, arg, 1);
d2690 1
a2690 1
io_fcntl(argc, argv, io)
d2699 1
a2699 1
    return io_ctl(io, req, arg, 0);
d2702 1
d2707 1
a2707 1
f_syscall(argc, argv)
d2727 2
d2736 1
a2736 1
	    str_modify(*argv);
d2741 1
a2742 2
      case 0:
	ArgError("Too few args to syscall");
d2795 3
a2797 2
    if (retval == -1) rb_sys_fail(0);
    return INT2FIX(0);
d2800 1
d2805 1
a2805 1
io_s_pipe()
d2818 2
a2819 2
    r = prep_stdio(fdopen(pipes[0], "r"), FMODE_READABLE);
    w = prep_stdio(fdopen(pipes[1], "w"), FMODE_WRITABLE);
d2821 3
a2823 3
    ary = ary_new2(2);
    ary_push(ary, r);
    ary_push(ary, w);
d2828 1
d2839 1
a2839 1
io_foreach_line(arg)
d2844 1
a2844 1
    while (!NIL_P(str = io_gets_method(arg->argc, &arg->sep, arg->io))) {
d2851 1
a2851 1
io_s_foreach(argc, argv, io)
d2856 1
a2856 1
    struct RString *fname;
d2863 3
a2865 2
    arg.io = io_open(fname->ptr, "r");
    return rb_ensure(io_foreach_line, &arg, io_close, arg.io);
d2869 1
a2869 1
io_readline_line(arg)
d2874 3
a2876 3
    ary = ary_new();
    while (!NIL_P(line = io_gets_method(arg->argc, &arg->sep, arg->io))) {
	ary_push(ary, line);
d2883 1
a2883 1
io_s_readlines(argc, argv, io)
d2888 1
a2888 1
    struct RString *fname;
d2895 68
a2962 2
    arg.io = io_open(fname->ptr, "r");
    return rb_ensure(io_readline_line, &arg, io_close, arg.io);
d2966 1
a2966 1
arg_fileno()
d2968 1
a2968 1
    return io_fileno(file);
d2972 1
a2972 1
arg_read(argc, argv)
d2984 7
a2990 1
    tmp = io_read(argc, argv, file);
d2992 1
a2992 1
	io_close(file);
d2996 1
a2996 1
    if (NIL_P(tmp)) return str;
d2998 1
a2998 1
    else str_cat(str, RSTRING(tmp)->ptr, RSTRING(tmp)->len);
d3012 1
a3012 1
arg_getc()
d3018 6
a3023 1
    byte = io_getc(file);
d3025 1
a3025 1
	io_close(file);
d3034 1
a3034 1
arg_readchar()
d3036 1
a3036 1
    VALUE c = io_getc(file);
d3039 1
a3039 1
	eof_error();
d3045 16
a3060 1
arg_each_line(argc, argv)
d3062 1
a3062 1
    VALUE argv;
d3066 1
a3066 1
    while (RTEST(str = f_gets_method(argc, argv))) {
d3069 1
a3069 1
    return Qnil;
d3073 1
a3073 1
arg_each_byte()
d3077 1
a3077 1
    while (!NIL_P(byte = arg_getc())) {
d3084 1
a3084 1
arg_filename()
d3090 1
a3090 1
arg_file()
d3092 1
a3092 1
    return file;
d3096 1
a3096 1
arg_skip()
d3099 1
a3099 1
	io_close(file);
d3106 1
a3106 1
arg_close()
d3108 1
a3108 1
    io_close(file);
d3117 1
a3117 1
arg_closed()
d3119 4
a3122 1
    return io_closed(file);
d3128 2
a3129 2
    if (!inplace) return Qnil;
    return str_new2(inplace);
d3134 1
a3134 1
    struct RString *val;
d3136 2
a3137 2
    if (NIL_P(val)) {
	inplace = 0;
d3140 1
a3140 2
    Check_Type(val, T_STRING);
    inplace = val->ptr;
a3142 2
extern VALUE mEnumerable;

d3146 2
a3147 4
    extern VALUE mKernel;
    extern VALUE eException;

    eEOFError = rb_define_class("EOFError", eException);
d3151 1
a3151 1
    rb_define_global_function("syscall", f_syscall, -1);
d3153 107
a3259 92
    rb_define_global_function("open", f_open, -1);
    rb_define_global_function("printf", f_printf, -1);
    rb_define_global_function("print", f_print, -1);
    rb_define_global_function("gets", f_gets_method, -1);
    rb_define_global_function("readline", f_readline, -1);
    rb_define_global_function("eof", f_eof, 0);
    rb_define_global_function("eof?", f_eof, 0);
    rb_define_global_function("getc", f_getc, 0);
    rb_define_global_function("readchar", f_readchar, 0);
    rb_define_global_function("select", f_select, -1);
    rb_define_global_function("ungetc", f_ungetc, 1);

    rb_define_global_function("readlines", f_readlines, -1);

    rb_define_global_function("`", f_backquote, 1);
    rb_define_global_function("pipe", io_s_pipe, 0);

    rb_define_global_function("p", f_p, 1);

    cIO = rb_define_class("IO", cObject);
    rb_include_module(cIO, mEnumerable);

    rb_define_singleton_method(cIO, "new", io_s_new, -1);
    rb_define_singleton_method(cIO, "popen", io_s_popen, -1);
    rb_define_singleton_method(cIO, "foreach", io_s_foreach, -1);
    rb_define_singleton_method(cIO, "readlines", io_s_readlines, -1);
    rb_define_singleton_method(cIO, "select", f_select, -1);

    FS = OFS = Qnil;
    rb_define_hooked_variable("$;", &FS, 0, rb_str_setter);
    rb_define_hooked_variable("$-F", &FS, 0, rb_str_setter);
    rb_define_hooked_variable("$,", &OFS, 0, rb_str_setter);

    RS = RS_default = str_new2("\n"); ORS = Qnil;
    rb_global_variable(&RS_default);
    rb_define_hooked_variable("$/", &RS, 0, rb_str_setter);
    rb_define_hooked_variable("$-0", &RS, 0, rb_str_setter);
    rb_define_hooked_variable("$\\", &ORS, 0, rb_str_setter);

    rb_define_variable("$.", &lineno);
    rb_define_virtual_variable("$_", lastline_get, lastline_set);

    rb_define_method(cIO, "clone", io_clone, 0);
    rb_define_method(cIO, "reopen", io_reopen, 1);

    rb_define_method(cIO, "print", io_print, -1);
    rb_define_method(cIO, "printf", io_printf, -1);

    rb_define_method(cIO, "each",  io_each_line, -1);
    rb_define_method(cIO, "each_line",  io_each_line, -1);
    rb_define_method(cIO, "each_byte",  io_each_byte, 0);

    rb_define_method(cIO, "syswrite", io_syswrite, 1);
    rb_define_method(cIO, "sysread",  io_sysread, 1);

    rb_define_method(cIO, "fileno", io_fileno, 0);
    rb_define_alias(cIO, "to_i", "fileno");

    rb_define_method(cIO, "sync",   io_sync, 0);
    rb_define_method(cIO, "sync=",  io_set_sync, 1);

    rb_define_method(cIO, "readlines",  io_readlines, -1);

    rb_define_method(cIO, "read",  io_read, -1);
    rb_define_method(cIO, "write", io_write, 1);
    rb_define_method(cIO, "gets",  io_gets_method, -1);
    rb_define_method(cIO, "readline",  io_readline, -1);
    rb_define_method(cIO, "getc",  io_getc, 0);
    rb_define_method(cIO, "readchar",  io_readchar, 0);
    rb_define_method(cIO, "ungetc",io_ungetc, 1);
    rb_define_method(cIO, "puts",  io_puts, 1);
    rb_define_method(cIO, "<<",    io_puts, 1);
    rb_define_method(cIO, "flush", io_flush, 0);
    rb_define_method(cIO, "eof", io_eof, 0);
    rb_define_method(cIO, "eof?", io_eof, 0);

    rb_define_method(cIO, "close", io_close, 0);
    rb_define_method(cIO, "closed?", io_closed, 0);

    rb_define_method(cIO, "isatty", io_isatty, 0);
    rb_define_method(cIO, "tty?", io_isatty, 0);
    rb_define_method(cIO, "binmode",  io_binmode, 0);

    rb_define_method(cIO, "ioctl", io_ioctl, -1);
    rb_define_method(cIO, "fcntl", io_fcntl, -1);

    rb_stdin = prep_stdio(stdin, FMODE_READABLE);
    rb_define_readonly_variable("$stdin", &rb_stdin);
    rb_stdout = prep_stdio(stdout, FMODE_WRITABLE);
    rb_define_readonly_variable("$stdout", &rb_stdout);
    rb_stderr = prep_stdio(stderr, FMODE_WRITABLE);
    rb_define_readonly_variable("$stderr", &rb_stderr);
d3261 1
a3261 1
    rb_define_hooked_variable("$>", &rb_defout, 0, io_defset);
d3267 2
a3268 2
    argf = obj_alloc(cObject);
    rb_extend_object(argf, mEnumerable);
d3273 36
a3308 25
    rb_define_singleton_method(argf, "fileno", arg_fileno, 0);
    rb_define_singleton_method(argf, "to_i", arg_fileno, 0);
    rb_define_singleton_method(argf, "each",  arg_each_line, -1);
    rb_define_singleton_method(argf, "each_line",  arg_each_line, -1);
    rb_define_singleton_method(argf, "each_byte",  arg_each_byte, 0);

    rb_define_singleton_method(argf, "read",  arg_read, -1);
    rb_define_singleton_method(argf, "readlines", f_readlines, -1);
    rb_define_singleton_method(argf, "to_a", f_readlines, -1);
    rb_define_singleton_method(argf, "gets", f_gets_method, -1);
    rb_define_singleton_method(argf, "readline", f_readline, -1);
    rb_define_singleton_method(argf, "getc", arg_getc, 0);
    rb_define_singleton_method(argf, "readchar", arg_readchar, 0);
    rb_define_singleton_method(argf, "eof", f_eof, 0);
    rb_define_singleton_method(argf, "eof?", f_eof, 0);
    rb_define_singleton_method(argf, "ungetc", f_ungetc, 1);

    rb_define_singleton_method(argf, "to_s", arg_filename, 0);
    rb_define_singleton_method(argf, "filename", arg_filename, 0);
    rb_define_singleton_method(argf, "file", arg_file, 0);
    rb_define_singleton_method(argf, "skip", arg_skip, 0);
    rb_define_singleton_method(argf, "close", arg_close, 0);
    rb_define_singleton_method(argf, "closed?", arg_closed, 0);

    filename = str_new2("-");
a3309 2
    file = rb_stdin;
    rb_global_variable(&file);
a3311 1
    Init_File();
d3315 28
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@a51 4
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

d133 2
a134 1
    VALUE io, str;
d141 2
a142 2
	str = obj_as_string(str);
    if (RSTRING(str)->len == 0) return INT2FIX(0);
d167 1
a167 1
    n = fwrite(RSTRING(str)->ptr, 1, RSTRING(str)->len, f);
d180 1
a180 1
io_addstr(io, str)
a267 7

#ifndef S_ISREG
#   define S_ISREG(m) ((m & S_IFMT) == S_IFREG)
#endif

#define SMALLBUF 100

d274 1
a274 4
    char *buf;
    struct stat st;
    int siz = BUFSIZ;
    int bytes = 0;
a280 10
    if (fstat(fileno(fptr->f), &st) == 0  && S_ISREG(st.st_mode)) {
	if (st.st_size == 0) return Qnil;
	else {
	    int pos = ftell(fptr->f);
	    if (st.st_size > pos && pos >= 0) {
		siz = st.st_size - pos + 1;
	    }
	}
    }
    str = str_new(0, siz);
d284 1
a284 1
	n = fread(RSTRING(str)->ptr+bytes, 1, siz-bytes, fptr->f);
d287 3
a289 5
	if (n < 0) rb_sys_fail(fptr->path);
	bytes += n;
	if (bytes <  siz) break;
	siz += BUFSIZ;
	str_resize(str, siz);
a290 2
    if (bytes == 0) return Qnil;
    if (bytes != siz) str_resize(str, bytes);
d301 2
a302 2
    int n, len;
    VALUE length, str;
d304 1
a304 1
    if (rb_scan_args(argc, argv, "01", &length) == 0) {
d308 1
a308 1
    len = NUM2INT(length);
d313 1
a313 1
    str = str_new(0, len);
d317 1
a317 1
    n = fread(RSTRING(str)->ptr, 1, len, fptr->f);
d319 2
a320 2
    if (n == 0) return Qnil;
    if (n < 0) {
d335 1
a335 1
    VALUE *argv;
d340 1
a340 1
    VALUE str = Qnil;
d418 1
a418 1
		str = Qnil;
d426 1
a426 1
	    str = str_new(buf, cnt);
d430 2
a431 2
	     RSTRING(str)->len < rslen ||
	     memcmp(RSTRING(str)->ptr+RSTRING(str)->len-rslen, rsptr, rslen))) {
d451 1
a451 1
    if (!NIL_P(str)) {
a453 1
	str_taint(str);
d457 1
a457 1
    return str;
d470 1
a470 1
    VALUE *argv;
d484 1
a484 1
    VALUE *argv;
d499 1
a499 1
    VALUE *argv;
a584 1
    return Qnil;
d780 1
a780 1
	    gc_gc();
d948 2
d952 6
a957 1
	    int fd;
d1046 1
a1046 1
f_open(argc, argv)
d1049 1
a1052 1
    VALUE port;
d1065 1
a1065 7

    port = io_open(RSTRING(pname)->ptr, mode);
    if (iterator_p()) {
	rb_ensure(rb_yield, port, io_close, port);
    }

    return port;
a1071 16
static char*
io_mode_string(fptr)
    OpenFile *fptr;
{
    switch (fptr->mode & FMODE_READWRITE) {
      case FMODE_READABLE:
      default:
	return "r";
      case FMODE_WRITABLE:
	return "w";
      case FMODE_READWRITE:
	return "r+";
    }
    return "r";
}

d1100 11
a1110 1
    mode = io_mode_string(fptr);
d1112 1
a1112 2
    if (fileno(fptr->f) < 3)	/* need to keep stdio */
	fclose(fptr->f);
d1118 1
a1118 2
	if (fileno(fptr->f2) < 3)
	    fclose(fptr->f2);
d1182 1
a1182 1
	io_binmode((VALUE)obj);
d1229 1
a1229 1
    int i, j;
d1247 1
a1247 6
	    for (j=0; j<RARRAY(argv[i])->len; j++) {
		if (!NIL_P(OFS) && j>0) {
		    io_write(out, OFS);
		}
		io_write(out, RARRAY(argv[i])->ptr[j]);
	    }
a1270 47
io_puts(argc, argv, out)
    int argc;
    VALUE *argv;
    VALUE out;
{
    int i, j;
    VALUE line;

    /* if no argument given, print newline. */
    if (argc == 0) {
	io_write(out, str_new2("\n"));
	return Qnil;
    }
    for (i=0; i<argc; i++) {
	switch (TYPE(argv[i])) {
	  case T_NIL:
	    line = str_new2("nil");
	    break;
	  case T_ARRAY:
	    for (j=0; j<RARRAY(argv[i])->len; j++) {
		io_puts(1, &RARRAY(argv[i])->ptr[j], out);
	    }
	    continue;
	  default:
	    line = argv[i];
	    break;
	}
	line = obj_as_string(line);
	io_write(out, line);
	if (RSTRING(line)->ptr[RSTRING(line)->len-1] != '\n') {
	    io_write(out, str_new2("\n"));
	}
    }

    return Qnil;
}

static VALUE
f_puts(argc, argv)
    int argc;
    VALUE *argv;
{
    io_puts(argc, argv, rb_defout);
    return Qnil;
}

static VALUE
a1281 7
void
rb_p(obj)			/* for debug print within C code */
    VALUE obj;
{
    f_p(Qnil, obj);
}

a1296 35
static void
io_errset(val, id)
    VALUE val;
    ID id;
{
    OpenFile *fptr;
    int fd;

    if (TYPE(val) != T_FILE) {
	TypeError("$stderr must be IO Object");
    }
    GetOpenFile(val, fptr);
    io_writable(fptr);
    rb_stderr = val;

    fd = fileno(fptr->f2?fptr->f2:fptr->f);
    if (fd != 2) {
	FILE *f;

	fflush(stderr);
	dup2(fd, 2);
	f = rb_fdopen(2, io_mode_string(fptr));
	if (fptr->f2) {
	    if (fileno(fptr->f2) < 3)	/* need to keep stdio */
		fclose(fptr->f2);
	    fptr->f2 = f;
	}
	else {
	    if (fileno(fptr->f) < 3)
		fclose(fptr->f);
	    fptr->f = f;
	}
    }
}

d1339 1
a1339 1
    extern VALUE rb_argv;
d1343 1
a1343 1
	if (RARRAY(rb_argv)->len > 0) {
d1357 2
a1358 2
	if (RARRAY(rb_argv)->len > 0) {
	    filename = ary_shift(rb_argv);
d1374 1
a1374 1
		    if (TYPE(rb_defout) == T_FILE && rb_defout != rb_stdout) {
d1542 2
a1543 1
    VALUE obj, str;
d1548 1
a1548 1
    port = pipe_open(RSTRING(str)->ptr, "r");
d1722 2
a1723 1
    VALUE io, req, arg;
d1760 2
a1761 2
	if (len <= RSTRING(arg)->len) {
	    len = RSTRING(arg)->len;
d1763 3
a1765 5
	if (RSTRING(arg)->len < len) {
	    str_resize(arg, len+1);
	}
	RSTRING(arg)->ptr[len] = 17;	/* a little sanity check here */
	narg = (long)RSTRING(arg)->ptr;
d1777 1
a1777 1
    if (TYPE(arg) == T_STRING && RSTRING(arg)->ptr[len] != 17) {
d1960 1
a1960 1
    VALUE fname;
d1967 1
a1967 1
    arg.io = io_open(RSTRING(fname)->ptr, "r");
d1991 1
a1991 1
    VALUE fname;
d1998 1
a1998 1
    arg.io = io_open(RSTRING(fname)->ptr, "r");
d2142 1
a2142 1
    VALUE val;
d2149 1
a2149 1
    inplace = RSTRING(val)->ptr;
d2152 2
d2157 1
a2157 1
    extern VALUE mEnumerable;
a2168 1
    rb_define_global_function("puts", f_puts, -1);
a2211 1
    rb_define_method(cIO, "puts", io_puts, -1);
d2236 2
a2237 1
    rb_define_method(cIO, "<<",    io_addstr, 1);
d2257 1
a2257 1
    rb_define_hooked_variable("$stderr", &rb_stderr, 0, io_errset);
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/12/22 09:01:51 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
d14 1
a14 2
#include "rubyio.h"
#include "rubysig.h"
d42 4
d56 1
a56 12
#ifdef USE_CWGUSI
 #include <sys/errno.h>
 #include <unix.mac.h>
 #include <compat.h>
#endif
extern void Init_File _((void));

#ifdef __BEOS__
#include <net/socket.h>
#endif

#include "util.h"
d58 4
a61 3
VALUE rb_cIO;
VALUE rb_eEOFError;
VALUE rb_eIOError;
d65 3
a67 5
VALUE rb_fs;
VALUE rb_output_fs;
VALUE rb_rs;
VALUE rb_output_rs;
VALUE rb_default_rs;
d71 1
a71 1
static ID id_write;
d73 2
a74 1
extern char *ruby_inplace_mode;
d76 1
a76 1
struct timeval rb_time_timeval _((VALUE));
d78 1
a78 4
static VALUE filename, file;
static int gets_lineno;
static int init_p = 0, next_p = 0;
static VALUE lineno;
a85 6
#elif defined(FILE_COUNT)
#  define READ_DATA_PENDING(fp) ((fp)->FILE_COUNT > 0)
#elif defined(__BEOS__)
#  define ReadDataPending(fp) (fp->_state._eof == 0)
#elif defined(USE_CWGUSI)
#  define ReadDataPending(fp) (fp->state.eof == 0)
d87 3
d92 2
a93 1
#  define READ_DATA_PENDING(fp) ReadDataPending(fp)
d96 1
a96 1
#ifndef USE_THREAD
d100 1
a100 1
    if (!READ_DATA_PENDING(fp)) rb_thread_wait_fd(fileno(fp));\
d105 1
a105 1
rb_eof_error()
d107 1
a107 1
    rb_raise(rb_eEOFError, "End of file reached");
d111 1
a111 1
rb_io_check_closed(fptr)
d114 3
a116 2
    if (fptr->f == NULL && fptr->f2 == NULL)
	rb_raise(rb_eIOError, "closed stream");
d120 1
a120 1
rb_io_check_readable(fptr)
d124 1
a124 1
	rb_raise(rb_eIOError, "not opened for reading");
d128 2
a129 3
void
rb_io_check_writable(fptr)
    OpenFile *fptr;
d131 1
a131 3
    if (!(fptr->mode & FMODE_WRITABLE)) {
	rb_raise(rb_eIOError, "not opened for writing");
    }
d136 1
a136 1
rb_io_write(io, str)
a142 1
    rb_secure(4);
d144 1
a144 1
	str = rb_obj_as_string(str);
a147 1
	/* port is not IO, call write method for it. */
d151 1
d153 2
a154 1
    rb_io_check_writable(fptr);
d156 1
d160 2
a161 2
	register char *ptr = RSTRING(str)->ptr;
	n = (int)RSTRING(str)->len;
d165 1
a165 1
	n = ptr - RSTRING(str)->ptr;
d183 1
a183 1
rb_io_addstr(io, str)
d186 1
a186 1
    rb_io_write(io, str);
d191 1
a191 1
rb_io_flush(io)
d198 1
a198 1
    rb_io_check_writable(fptr);
d200 1
d208 1
a208 64
rb_io_tell(io)
     VALUE io;
{
    OpenFile *fptr;
    long pos;

    GetOpenFile(io, fptr);
    pos = ftell(fptr->f);
    if (ferror(fptr->f) != 0) rb_sys_fail(fptr->path);

    return rb_int2inum(pos);
}

static VALUE
rb_io_seek(io, offset, ptrname)
     VALUE io, offset, ptrname;
{
    OpenFile *fptr;
    long pos;

    GetOpenFile(io, fptr);
    pos = fseek(fptr->f, NUM2INT(offset), NUM2INT(ptrname));
    if (pos != 0) rb_sys_fail(fptr->path);
    clearerr(fptr->f);

    return INT2FIX(0);
}

#ifndef SEEK_CUR
# define SEEK_SET 0
# define SEEK_CUR 1
# define SEEK_END 2
#endif

static VALUE
rb_io_set_pos(io, offset)
     VALUE io, offset;
{
    OpenFile *fptr;
    long pos;

    GetOpenFile(io, fptr);
    pos = fseek(fptr->f, NUM2INT(offset), SEEK_SET);
    if (pos != 0) rb_sys_fail(fptr->path);
    clearerr(fptr->f);

    return INT2NUM(pos);
}

static VALUE
rb_io_rewind(io)
     VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    if (fseek(fptr->f, 0L, 0) != 0) rb_sys_fail(fptr->path);
    clearerr(fptr->f);

    return INT2FIX(0);
}

VALUE
rb_io_eof(io)
d215 5
a219 1
    rb_io_check_readable(fptr);
a220 6
    if (READ_DATA_PENDING(fptr->f)) return Qfalse;
#if 0
    if (feof(fptr->f)) return Qtrue;
    return Qfalse;
#else
    READ_CHECK(fptr->f);
d226 2
a227 2
	ungetc(ch, fptr->f);
	return Qfalse;
d229 1
a229 2
    return Qtrue;
#endif
d233 1
a233 1
rb_io_sync(io)
d239 1
a239 1
    return (fptr->mode & FMODE_SYNC) ? Qtrue : Qfalse;
d243 1
a243 1
rb_io_set_sync(io, mode)
d259 1
a259 1
rb_io_fileno(io)
a269 7
static VALUE
rb_io_to_io(io)
    VALUE io;
{
    return io;
}

d284 1
d286 2
a287 2
    long siz = BUFSIZ;
    long bytes = 0;
d291 2
a292 1
    rb_io_check_readable(fptr);
d294 2
a295 7
    if (fstat(fileno(fptr->f), &st) == 0  && S_ISREG(st.st_mode)
#ifdef __BEOS__
	&& (st.st_dev > 3)
#endif
	)
    {
	if (st.st_size == 0) return rb_str_new(0, 0);
d297 1
a297 1
	    long pos = ftell(fptr->f);
d303 1
a303 1
    str = rb_str_new(0, siz);
d309 2
a310 4
	if (n <= 0) {
	    if (ferror(fptr->f)) rb_sys_fail(fptr->path);
	    return rb_str_new(0,0);
	}
d312 1
a312 1
	if (bytes < siz) break;
d314 1
a314 1
	rb_str_resize(str, siz);
d316 3
a318 5
    if (bytes == 0) return rb_str_new(0,0);
    if (bytes != siz) rb_str_resize(str, bytes);
    OBJ_TAINT(str);

    return str;
d322 1
a322 1
rb_io_read(argc, argv, io)
d331 1
a331 2
    rb_scan_args(argc, argv, "01", &length);
    if (NIL_P(length)) {
d337 2
a338 1
    rb_io_check_readable(fptr);
d340 1
a340 1
    str = rb_str_new(0, len);
d346 3
a348 3
    if (n <= 0) {
	if (ferror(fptr->f)) rb_sys_fail(fptr->path);
	return Qnil;
d350 1
a352 1
    OBJ_TAINT(str);
d354 1
a354 1
    return str;
d357 4
a360 2
static VALUE
rb_io_gets_internal(argc, argv, io)
d373 1
a373 3
    if (argc == 0) {
	rs = rb_rs;
    }
d379 6
a384 5
    if (NIL_P(rs)) {
	rsptr = 0;
	rslen = 0;
    }
    else {
a390 3
	else if (rslen == 1 && RSTRING(rs)->ptr[0] == '\n') {
	    return rb_io_gets(io);
	}
d395 5
a399 4

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    f = fptr->f;
a413 1
    newline = rslen ? rsptr[rslen - 1] : 0777;
d429 1
a429 4
		if (c == EOF) {
		    if (errno == EINTR) continue;
		    break;
		}
d440 1
a440 7
	    if (cnt == 0) {
		if (ferror(f)) rb_sys_fail(fptr->path);
		c = EOF;
	    }
	    else {
		c = 0;
	    }
d443 5
a447 3
	if (c == EOF && !append && cnt == 0) {
	    str = Qnil;
	    goto return_gets;
d451 1
a451 1
	    rb_str_cat(str, buf, cnt);
d453 1
a453 1
	    str = rb_str_new(buf, cnt);
d458 1
a458 1
	     memcmp(RSTRING(str)->ptr+RSTRING(str)->len-rslen,rsptr,rslen))) {
d481 1
a481 1
	OBJ_TAINT(str);
d483 1
d489 1
a489 1
rb_io_gets(io)
d492 1
a492 52
    OpenFile *fptr;
    FILE *f;
    VALUE str = Qnil;
    int c;
    char buf[8192];
    char *bp, *bpe = buf + sizeof buf - 3;
    int cnt;
    int append = 0;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    f = fptr->f;

  again:
    bp = buf;
    for (;;) {
	READ_CHECK(f);
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c == EOF) {
	    if (errno == EINTR) continue;
	    break;
	}
	if ((*bp++ = c) == '\n') break;
	if (bp == bpe) break;
    }
    cnt = bp - buf;

    if (c == EOF && !append && cnt == 0) {
	str = Qnil;
	goto return_gets;
    }

    if (append)
	rb_str_cat(str, buf, cnt);
    else
	str = rb_str_new(buf, cnt);

    if (c != EOF && RSTRING(str)->ptr[RSTRING(str)->len-1] != '\n') {
	append = 1;
	goto again;
    }

  return_gets:
    if (!NIL_P(str)) {
	fptr->lineno++;
	lineno = INT2FIX(fptr->lineno);
	OBJ_TAINT(str);
    }

    return str;
d496 1
a496 1
rb_io_gets_method(argc, argv, io)
d501 1
a501 47
    VALUE str = rb_io_gets_internal(argc, argv, io);

    if (!NIL_P(str)) {
	rb_lastline_set(str);
    }
    return str;
}

static VALUE
rb_io_lineno(io)
    VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    return INT2NUM(fptr->lineno);
}

static VALUE
rb_io_set_lineno(io, lineno)
    VALUE io, lineno;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    return fptr->lineno = NUM2INT(lineno);
}

static void
lineno_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    gets_lineno = NUM2INT(val);
    *var = INT2FIX(gets_lineno);
}

static VALUE
rb_io_readline(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE line = rb_io_gets_method(argc, argv, io);
d504 1
a504 1
	rb_eof_error();
d510 1
a510 1
rb_io_readlines(argc, argv, io)
d517 3
a519 3
    ary = rb_ary_new();
    while (!NIL_P(line = rb_io_gets_internal(argc, argv, io))) {
	rb_ary_push(ary, line);
d525 1
a525 1
rb_io_each_line(argc, argv, io)
d532 1
a532 1
    while (!NIL_P(str = rb_io_gets_internal(argc, argv, io))) {
d539 1
a539 1
rb_io_each_byte(io)
d547 1
a547 1
    rb_io_check_readable(fptr);
d549 1
d564 1
a564 1
rb_io_getc(io)
d572 1
a572 1
    rb_io_check_readable(fptr);
d574 1
d589 1
a589 1
rb_io_readchar(io)
d592 1
a592 1
    VALUE c = rb_io_getc(io);
d595 1
a595 1
	rb_eof_error();
d601 1
a601 1
rb_io_ungetc(io, c)
d608 2
a609 1
    rb_io_check_readable(fptr);
d617 1
a617 1
rb_io_isatty(io)
d623 1
d625 2
a626 2
	return Qfalse;
    return Qtrue;
d639 4
d649 2
a650 2
static void
rb_io_fptr_close(fptr)
a652 2
    if (fptr->f == NULL && fptr->f2 == NULL) return;

d655 1
a662 42
void
rb_io_fptr_finalize(fptr)
    OpenFile *fptr;
{
    rb_io_fptr_close(fptr);
    if (fptr->path) {
	free(fptr->path);
	fptr->path = NULL;
    }
}

VALUE
rb_io_close(io)
    VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    rb_io_fptr_close(fptr);

    return Qnil;
}

static VALUE
rb_io_close_method(io)
    VALUE io;
{
    rb_secure(4);
    rb_io_close(io);
    return Qnil;
}

static VALUE
rb_io_closed(io)
    VALUE io;
{
    OpenFile *fptr;

    fptr = RFILE(io)->fptr;
    return (fptr->f || fptr->f2)?Qfalse:Qtrue;
}

d664 1
a664 1
rb_io_close_read(io)
a668 1
    rb_secure(4);
d670 1
a670 10
    if (fptr->f2 == 0 && (fptr->mode & FMODE_WRITABLE)) {
	rb_raise(rb_eIOError, "closing non-duplex IO for reading");
    }
    if (fptr->f2 == 0) {
	return rb_io_close(io);
    }
    fclose(fptr->f);
    fptr->mode &= ~FMODE_READABLE;
    fptr->f = fptr->f2;
    fptr->f2 = 0;
d676 1
a676 1
rb_io_close_write(io)
a680 1
    rb_secure(4);
d682 1
a682 11
    if (fptr->f2 == 0 && (fptr->mode & FMODE_READABLE)) {
	rb_raise(rb_eIOError, "closing non-duplex IO for writing");
    }
    if (fptr->f2 == 0) {
	return rb_io_close(io);
    }
    fclose(fptr->f2);
    fptr->f2 = 0;
    fptr->mode &= ~FMODE_WRITABLE;

    return Qnil;
d686 1
a686 1
rb_io_syswrite(io, str)
d695 1
a695 1
	str = rb_obj_as_string(str);
d698 1
a698 1
    rb_io_check_writable(fptr);
d700 1
d702 2
a703 2
#ifdef USE_THREAD
    rb_thread_fd_writable(fileno(f));
d713 1
a713 1
rb_io_sysread(io, len)
d722 2
a723 1
    rb_io_check_readable(fptr);
d725 1
a725 1
    str = rb_str_new(0, ilen);
d727 2
a728 2
#ifdef USE_THREAD
    rb_thread_wait_fd(fileno(fptr->f));
d735 1
a735 1
    if (n == 0) rb_eof_error();
d739 1
a739 3
    OBJ_TAINT(str);

    return str;
d743 1
a743 1
rb_io_binmode(io)
d746 1
a746 1
#if defined(NT) || defined(DJGPP) || defined(__CYGWIN32__) || defined(__human68k__) || defined(USE_CWGUSI)
d753 1
a753 1
    if (fptr->f2)
a755 1
# ifndef USE_CWGUSI
a759 6
# else  /* USE_CWGUSI */
	if (fptr->f)
		fptr->f->mode.binrb_ary_io = 1;
	if (fptr->f2)
		fptr->f2->mode.binrb_ary_io = 1;
# endif /* USE_CWGUSI */
d768 1
a768 1
rb_io_mode_flags(mode)
d784 1
a784 1
	rb_raise(rb_eArgError, "illegal access mode");
d809 1
a809 1
	    rb_gc();
a864 1
	free(list);
a882 1
    struct pipe_list *tmp;
d885 2
a886 3
	tmp = list->next;
	rb_io_fptr_finalize(list->fptr);
	list = tmp;
d890 1
a894 1
#if !defined (__CYGWIN32__)
a901 3
#else
    fptr_finalize(fptr);
#endif
d905 1
d908 1
a908 1
rb_io_unbuffered(fptr)
d911 1
a911 1
    if (fptr->f2 == 0) rb_raise(rb_eTypeError, "non-writable fptr");
d921 1
a921 2
#ifndef USE_CWGUSI
    int modef = rb_io_mode_flags(mode);
d930 1
a930 1
	OBJSETUP(port, rb_cIO, T_FILE);
d939 1
a939 1
	    rb_io_unbuffered(fptr);
a940 1
	rb_obj_call_init((VALUE)port);
d977 2
a978 2
	    extern char *ruby_sourcefile;
	    extern int   ruby_sourceline;
d985 1
a985 1
		    ruby_sourcefile, ruby_sourceline, pname);
d992 2
a993 2
#ifdef USE_THREAD
	    rb_thread_sleep(1);
d1004 1
a1004 2
	if (pid < 0) rb_sys_fail(pname);
	else {
d1006 1
a1006 1
	    OBJSETUP(port, rb_cIO, T_FILE);
a1023 1
	    fptr->finalize = pipe_finalize;
a1025 1
	    rb_obj_call_init((VALUE)port);
a1029 4
#else /* USE_CWGUSI */
    rb_notimplement();  
    return Qnil;		/* not reached */
#endif
d1033 1
a1033 1
rb_io_s_popen(argc, argv, self)
d1041 3
a1043 1
    if (rb_scan_args(argc, argv, "11", &pname, &pmode) == 1) {
d1047 5
a1051 8
	int len;

	mode = STR2CSTR(pmode);
	len = strlen(mode);
	if (len == 0 || len > 3)
	    rb_raise(rb_eArgError, "illegal access mode");
    }
    Check_SafeStr(pname);
d1056 1
a1056 1
rb_io_open(fname, mode)
d1063 1
a1063 1
	return rb_file_open(fname, mode);
d1068 1
a1068 1
rb_f_open(argc, argv)
d1082 4
a1085 6
	int len;

	mode = STR2CSTR(pmode);
	len = strlen(mode);
	if (len == 0 || len > 3)
	    rb_raise(rb_eArgError, "illegal access mode");
d1088 3
a1090 3
    port = rb_io_open(RSTRING(pname)->ptr, mode);
    if (rb_iterator_p()) {
	return rb_ensure(rb_yield, port, rb_io_close, port);
d1096 3
a1098 6
static VALUE
rb_io_get_io(io)
    VALUE io;
{
    return rb_convert_type(io, T_FILE, "IO", "to_io");
}
d1101 1
a1101 1
rb_io_mode_string(fptr)
d1113 1
d1117 1
a1117 1
rb_io_reopen(io, nfile)
a1123 1
    rb_secure(4);
d1125 1
a1125 1
    nfile = rb_io_get_io(nfile);
d1144 1
a1144 1
    mode = rb_io_mode_string(fptr);
d1146 1
a1146 6
    if (fd < 3) {
	/* need to keep stdio */
	if (dup2(fileno(orig->f), fd) < 0)
	    rb_sys_fail(orig->path);
    }
    else {
d1148 2
a1149 4
	if (dup2(fileno(orig->f), fd) < 0)
	    rb_sys_fail(orig->path);
	fptr->f = rb_fdopen(fd, mode);
    }
d1153 2
a1154 1
	fclose(fptr->f2);
d1156 2
a1157 3
	    if (dup2(fileno(orig->f2), fd) < 0)
		rb_sys_fail(orig->path);
	    fptr->f2 = rb_fdopen(fd, "w");
d1165 1
a1165 1
	rb_io_binmode(io);
d1168 1
a1168 1
    RBASIC(io)->klass = RBASIC(nfile)->klass;
d1173 1
a1173 1
rb_io_clone(io)
d1218 1
a1218 1
	rb_io_binmode((VALUE)obj);
d1225 1
a1225 1
rb_io_printf(argc, argv, out)
d1230 1
a1230 1
    rb_funcall(out, id_write, 1, rb_f_sprintf(argc, argv));
d1236 1
a1236 1
rb_rb_f_printf(argc, argv)
d1252 1
a1252 1
	rb_raise(rb_eNameError, "output must responds to `write'");
d1254 1
a1254 1
    rb_funcall(out, id_write, 1, rb_f_sprintf(argc, argv));
d1260 1
a1260 1
rb_io_print(argc, argv, out)
d1265 1
a1265 1
    int i;
d1271 1
a1271 1
	line = rb_lastline_get();
d1275 2
a1276 2
	if (!NIL_P(rb_output_fs) && i>0) {
	    rb_io_write(out, rb_output_fs);
d1280 9
a1288 1
	    rb_io_write(out, rb_str_new2("nil"));
d1291 1
a1291 1
	    rb_io_write(out, argv[i]);
d1295 2
a1296 2
    if (!NIL_P(rb_output_rs)) {
	rb_io_write(out, rb_output_rs);
d1303 1
a1303 1
rb_f_print(argc, argv)
d1307 1
a1307 48
    rb_io_print(argc, argv, rb_defout);
    return Qnil;
}

static VALUE
rb_io_putc(io, ch)
    VALUE io, ch;
{
    OpenFile *fptr;
    FILE *f;
    int c = NUM2CHR(ch);

    rb_secure(4);
    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);
    f = GetWriteFile(fptr);

    if (fputc(c, f) == EOF || ferror(f))
	rb_sys_fail(fptr->path);
    if (fptr->mode & FMODE_SYNC)
	fflush(f);

    return ch;
}

static VALUE
rb_f_putc(recv, ch)
    VALUE recv, ch;
{
    return rb_io_putc(rb_defout, ch);
}

static VALUE rb_io_puts _((int, VALUE*, VALUE));

static VALUE
io_puts_ary(ary, out)
    VALUE ary, out;
{
    VALUE tmp;
    int i;

    for (i=0; i<RARRAY(ary)->len; i++) {
	tmp = RARRAY(ary)->ptr[i];
	if (rb_inspecting_p(tmp)) {
	    tmp = rb_str_new2("[...]");
	}
	rb_io_puts(1, &tmp, out);
    }
d1312 1
a1312 1
rb_io_puts(argc, argv, out)
d1317 1
a1317 1
    int i;
d1322 1
a1322 1
	rb_io_write(out, rb_default_rs);
d1328 1
a1328 1
	    line = rb_str_new2("nil");
d1331 3
a1333 1
	    rb_protect_inspect(io_puts_ary, argv[i], out);
d1339 2
a1340 2
	line = rb_obj_as_string(line);
	rb_io_write(out, line);
d1342 1
a1342 1
	    rb_io_write(out, rb_default_rs);
d1350 1
a1350 1
rb_f_puts(argc, argv)
d1354 1
a1354 1
    rb_io_puts(argc, argv, rb_defout);
a1357 10
void
rb_p(obj)			/* for debug print within C code */
    VALUE obj;
{
    obj = rb_obj_as_string(rb_inspect(obj));
    fwrite(RSTRING(obj)->ptr, 1, RSTRING(obj)->len, stdout);
    obj = rb_default_rs;
    fwrite(RSTRING(obj)->ptr, 1, RSTRING(obj)->len, stdout);
}

d1359 2
a1360 3
rb_f_p(argc, argv)
    int argc;
    VALUE *argv;
d1362 1
a1362 1
    int i;
d1364 3
a1366 3
    for (i=0; i<argc; i++) {
	rb_p(argv[i]);
    }
d1370 3
a1372 5
static VALUE
rb_obj_display(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
d1374 1
a1374 9
    VALUE out;

    if (rb_scan_args(argc, argv, "01", &out) == 0) {
	out = rb_defout;
    }

    rb_io_write(out, self);

    return Qnil;
d1378 1
a1378 1
rb_io_defset(val, id)
d1383 1
a1383 1
	val = rb_io_open(RSTRING(val)->ptr, "w");
d1386 2
a1387 2
	rb_raise(rb_eTypeError, "$< must have write method, %s given",
		 rb_class2name(CLASS_OF(val)));
d1393 1
a1393 1
rb_io_stdio_set(val, id, var)
a1395 1
    VALUE *var;
d1401 1
a1401 1
	rb_raise(rb_eTypeError, "%s must be IO object", rb_id2name(id));
a1402 2
    GetOpenFile(*var, fptr);
    fd = fileno(fptr->f);
d1404 20
a1423 2
    if (fd == 0) {
	rb_io_check_readable(fptr);
a1424 4
    else {
	rb_io_check_writable(fptr);
    }
    rb_io_reopen(*var, val);
d1428 1
a1428 1
prep_stdio(f, mode, klass)
a1430 1
    VALUE klass;
d1433 2
a1434 2
    NEWOBJ(io, struct RFile);
    OBJSETUP(io, klass, T_FILE);
d1436 1
a1436 1
    MakeOpenFile(io, fp);
a1438 1
    rb_obj_call_init((VALUE)io);
d1440 1
a1440 1
    return (VALUE)io;
d1444 1
a1444 1
rb_io_s_new(argc, argv, klass)
a1446 1
    VALUE klass;
d1449 1
d1452 3
a1454 1
    if (rb_scan_args(argc, argv, "11", &fnum, &mode) == 2) {
d1458 2
a1459 1
    return prep_stdio(rb_fdopen(NUM2INT(fnum), m), rb_io_mode_flags(m), klass);
d1462 4
d1488 1
a1488 1
	    filename = rb_ary_shift(rb_argv);
d1492 1
a1492 1
		if (ruby_inplace_mode) {
d1499 1
a1499 1
		if (ruby_inplace_mode) {
d1505 1
a1505 1
			rb_io_close(rb_defout);
d1508 2
a1509 2
		    if (*ruby_inplace_mode) {
			str = rb_str_new2(fn);
d1511 1
a1511 1
                        ruby_add_suffix(str, ruby_inplace_mode);
d1513 1
a1513 2
			rb_str_cat(str, ruby_inplace_mode,
				   strlen(ruby_inplace_mode));
d1522 1
a1522 1
			    rb_warn("Can't rename %s to %s: %s, skipping file",
d1532 2
a1533 2
			    rb_warn("Can't remove %s: %s, skipping file",
				    fn, strerror(errno));
d1538 1
a1538 1
			rb_fatal("Can't do inplace edit without backup");
d1542 1
a1542 2
#if !defined(MSDOS) && !defined(__CYGWIN32__) && !(NT) && !defined(__human68k__)\
 && !defined(USE_CWGUSI) && !defined(__BEOS__)
d1549 1
a1549 1
		    rb_defout = prep_stdio(fw, FMODE_WRITABLE, rb_cFile);
d1551 1
a1551 1
		file = prep_stdio(fr, FMODE_READABLE, rb_cFile);
d1556 1
a1556 1
	    return Qfalse;
d1559 1
a1559 1
    return Qtrue;
d1563 1
a1563 1
rb_f_gets_internal(argc, argv)
d1571 1
a1571 1
    line = rb_io_gets_internal(argc, argv, file);
d1573 1
a1573 1
	rb_io_close(file);
a1582 11
static VALUE
rb_f_gets(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE line = rb_f_gets_internal(argc, argv);

    if (!NIL_P(line)) rb_lastline_set(line);
    return line;
}

d1584 1
a1584 1
rb_gets()
d1586 1
a1586 17
    VALUE line;

  retry:
    if (!next_argv()) return Qnil;
    line = rb_io_gets(file);
    if (NIL_P(line) && next_p != -1) {
	rb_io_close(file);
	next_p = 1;
	goto retry;
    }
    if (!NIL_P(line)) {
	rb_lastline_set(line);
	gets_lineno++;
	lineno = INT2FIX(gets_lineno);
    }

    return line;
d1590 1
a1590 1
rb_f_readline(argc, argv)
d1592 1
a1592 1
    VALUE *argv;
d1594 1
a1594 1
    VALUE line = rb_f_gets(argc, argv);
d1597 1
a1597 1
	rb_eof_error();
d1604 1
a1604 35
rb_f_tell()
{
  return rb_io_tell(file);
}

static VALUE
rb_f_seek(self, offset, ptrname)
     VALUE self, offset, ptrname;
{
  if (!next_argv()) {
    rb_raise(rb_eArgError, "no stream to seek");
  }

  return rb_io_seek(file, offset, ptrname);
}

static VALUE
rb_f_set_pos(self, offset)
     VALUE self, offset;
{
  if (!next_argv()) {
    rb_raise(rb_eArgError, "no stream to pos");
  }

  return rb_io_set_pos(file, offset);
}

static VALUE
rb_f_rewind()
{
  return rb_io_rewind(file);
}

static VALUE
rb_f_eof()
d1607 2
a1608 2
	return Qtrue;
    if (rb_io_eof(file)) {
d1610 1
a1610 1
	return Qtrue;
d1612 1
a1612 1
    return Qfalse;
d1616 1
a1616 1
rb_f_getc()
d1618 1
a1618 1
    return rb_io_getc(rb_stdin);
d1622 2
a1623 2
rb_f_ungetc(self, c)
    VALUE self, c;
d1625 5
a1629 1
    return rb_io_ungetc(rb_stdin, c);
d1633 1
a1633 1
rb_f_readchar()
d1635 1
a1635 1
    VALUE c = rb_f_getc();
d1638 1
a1638 1
	rb_eof_error();
d1644 1
a1644 1
rb_f_readlines(argc, argv)
d1646 1
a1646 1
    VALUE *argv;
d1650 3
a1652 3
    ary = rb_ary_new();
    while (!NIL_P(line = rb_f_gets_internal(argc, argv))) {
	rb_ary_push(ary, line);
d1665 1
a1665 1
	rb_raise(rb_eTypeError, "value of %s must be String", rb_id2name(id));
d1671 1
a1671 1
rb_f_backquote(obj, str)
d1680 1
a1680 1
    rb_io_close(port);
d1682 1
a1682 1
    if (NIL_P(result)) return rb_str_new(0,0);
d1694 1
a1694 1
rb_f_select(argc, argv, obj)
d1705 1
a1705 1
    int interrupt_flag = 0;
d1713 1
a1713 1
	timerec = rb_time_timeval(timeout);
d1719 1
d1724 3
a1726 3
	    VALUE io = rb_io_get_io(RARRAY(read)->ptr[i]);

	    GetOpenFile(io, fptr);
d1747 3
a1749 3
	    VALUE io = rb_io_get_io(RARRAY(write)->ptr[i]);

	    GetOpenFile(io, fptr);
d1751 1
a1751 1
	    if (max < fileno(fptr->f)) max = fileno(fptr->f);
d1754 1
a1754 1
		if (max < fileno(fptr->f2)) max = fileno(fptr->f2);
d1766 3
a1768 3
	    VALUE io = rb_io_get_io(RARRAY(except)->ptr[i]);

	    GetOpenFile(io, fptr);
d1773 1
a1773 1
		if (max < fileno(fptr->f2)) max = fileno(fptr->f2);
d1782 2
a1783 2
#ifdef USE_THREAD
    n = rb_thread_select(max, rp, wp, ep, tp);
d1797 1
a1797 1
	interrupt_flag = 1;
d1802 4
a1805 4
    res = rb_ary_new2(3);
    rb_ary_push(res, rp?rb_ary_new():rb_ary_new2(0));
    rb_ary_push(res, wp?rb_ary_new():rb_ary_new2(0));
    rb_ary_push(res, ep?rb_ary_new():rb_ary_new2(0));
d1807 1
a1807 1
    if (interrupt_flag == 0) {
d1814 1
a1814 1
		    rb_ary_push(list, RARRAY(read)->ptr[i]);
d1824 1
a1824 1
		    rb_ary_push(list, RARRAY(write)->ptr[i]);
d1827 1
a1827 1
		    rb_ary_push(list, RARRAY(write)->ptr[i]);
d1837 1
a1837 1
		    rb_ary_push(list, RARRAY(except)->ptr[i]);
d1840 1
a1840 1
		    rb_ary_push(list, RARRAY(except)->ptr[i]);
d1850 1
a1850 1
rb_io_ctl(io, req, arg, io_p)
d1857 1
a1857 2
    int len = 0;
    int fd;
d1864 1
a1864 1
    if (NIL_P(arg) || arg == Qfalse) {
d1870 1
a1870 1
    else if (arg == Qtrue) {
d1886 1
a1886 1
	rb_str_modify(arg);
d1892 1
a1892 1
	    rb_str_resize(arg, len+1);
a1898 4
    TRAP_BEG;
# ifdef USE_CWGUSI
    retval = io_p?ioctl(fd, cmd, (void*) narg):fcntl(fd, cmd, narg);
# else
a1899 2
# endif
    TRAP_END;
a1903 1
    TRAP_BEG;
a1904 1
    TRAP_END;
d1908 1
a1908 1
	rb_raise(rb_eArgError, "return value overflowed string");
a1912 1
    return Qnil;		/* not reached */
d1917 1
a1917 1
rb_io_ioctl(argc, argv, io)
d1925 1
a1925 1
    return rb_io_ctl(io, req, arg, 1);
d1929 1
a1929 1
rb_io_fcntl(argc, argv, io)
d1938 1
a1938 1
    return rb_io_ctl(io, req, arg, 0);
a1940 1
    return Qnil;		/* not reached */
d1945 1
a1945 1
rb_f_syscall(argc, argv)
a1964 2
    if (argc == 0)
	rb_raise(rb_eArgError, "too few arguments for syscall");
d1972 1
a1972 1
	    rb_str_modify(*argv);
a1976 1
    TRAP_BEG;
d1978 2
a2031 1
    TRAP_END;
a2035 1
    return Qnil;		/* not reached */
d2040 1
a2040 1
rb_io_s_pipe()
d2053 2
a2054 2
    r = prep_stdio(fdopen(pipes[0], "r"), FMODE_READABLE, rb_cIO);
    w = prep_stdio(fdopen(pipes[1], "w"), FMODE_WRITABLE, rb_cIO);
d2056 3
a2058 3
    ary = rb_ary_new2(2);
    rb_ary_push(ary, r);
    rb_ary_push(ary, w);
a2062 1
    return Qnil;		/* not reached */
d2073 1
a2073 1
rb_io_foreach_line(arg)
d2078 1
a2078 1
    while (!NIL_P(str = rb_io_gets_internal(arg->argc, &arg->sep, arg->io))) {
d2085 1
a2085 1
rb_io_s_foreach(argc, argv, io)
d2097 2
a2098 2
    arg.io = rb_io_open(RSTRING(fname)->ptr, "r");
    return rb_ensure(rb_io_foreach_line, (VALUE)&arg, rb_io_close, arg.io);
d2102 1
a2102 1
rb_io_readline_line(arg)
d2107 3
a2109 3
    ary = rb_ary_new();
    while (!NIL_P(line = rb_io_gets_internal(arg->argc, &arg->sep, arg->io))) {
	rb_ary_push(ary, line);
d2116 1
a2116 1
rb_io_s_readlines(argc, argv, io)
d2128 2
a2129 2
    arg.io = rb_io_open(RSTRING(fname)->ptr, "r");
    return rb_ensure(rb_io_readline_line, (VALUE)&arg, rb_io_close, arg.io);
d2135 1
a2135 7
    return rb_io_fileno(file);
}

static VALUE
arg_to_io()
{
    return file;
d2144 1
a2144 1
    size_t len;
d2151 1
a2151 1
    tmp = rb_io_read(argc, argv, file);
d2153 1
a2153 1
	rb_io_close(file);
d2157 1
a2157 1
    if (NIL_P(tmp) || RSTRING(tmp)->len == 0) return str;
d2159 1
a2159 1
    else rb_str_cat(str, RSTRING(tmp)->ptr, RSTRING(tmp)->len);
d2179 1
a2179 1
    byte = rb_io_getc(file);
d2181 1
a2181 1
	rb_io_close(file);
d2192 1
a2192 1
    VALUE c = rb_io_getc(file);
d2195 1
a2195 1
	rb_eof_error();
d2203 1
a2203 1
    VALUE *argv;
d2207 1
a2207 1
    while (RTEST(str = rb_f_gets_internal(argc, argv))) {
d2240 1
a2240 1
	rb_io_close(file);
d2249 1
a2249 1
    rb_io_close(file);
d2260 1
a2260 1
    return rb_io_closed(file);
d2266 2
a2267 2
    if (!ruby_inplace_mode) return Qnil;
    return rb_str_new2(ruby_inplace_mode);
d2274 2
a2275 2
    if (!RTEST(val)) {
	ruby_inplace_mode = 0;
d2278 2
a2279 1
    ruby_inplace_mode = STR2CSTR(val);
d2285 4
a2288 2
    rb_eIOError = rb_define_class("IOError", rb_eStandardError);
    rb_eEOFError = rb_define_class("EOFError", rb_eIOError);
d2292 1
a2292 1
    rb_define_global_function("syscall", rb_f_syscall, -1);
d2294 93
a2386 114
    rb_define_global_function("open", rb_f_open, -1);
    rb_define_global_function("printf", rb_rb_f_printf, -1);
    rb_define_global_function("print", rb_f_print, -1);
    rb_define_global_function("putc", rb_f_putc, 1);
    rb_define_global_function("puts", rb_f_puts, -1);
    rb_define_global_function("gets", rb_f_gets, -1);
    rb_define_global_function("readline", rb_f_readline, -1);
    rb_define_global_function("tell", rb_f_tell, 0);
    rb_define_global_function("seek", rb_f_seek, 2);
    rb_define_global_function("rewind", rb_f_rewind, 0);
    rb_define_global_function("eof", rb_f_eof, 0);
    rb_define_global_function("eof?", rb_f_eof, 0);
    rb_define_global_function("getc", rb_f_getc, 0);
    rb_define_global_function("readchar", rb_f_readchar, 0);
    rb_define_global_function("select", rb_f_select, -1);
    rb_define_global_function("ungetc", rb_f_ungetc, 1);

    rb_define_global_function("readlines", rb_f_readlines, -1);

    rb_define_global_function("`", rb_f_backquote, 1);
    rb_define_global_function("pipe", rb_io_s_pipe, 0);

    rb_define_global_function("p", rb_f_p, -1);
    rb_define_method(rb_mKernel, "display", rb_obj_display, -1);

    rb_cIO = rb_define_class("IO", rb_cObject);
    rb_include_module(rb_cIO, rb_mEnumerable);

    rb_define_singleton_method(rb_cIO, "new", rb_io_s_new, -1);
    rb_define_singleton_method(rb_cIO, "popen", rb_io_s_popen, -1);
    rb_define_singleton_method(rb_cIO, "foreach", rb_io_s_foreach, -1);
    rb_define_singleton_method(rb_cIO, "readlines", rb_io_s_readlines, -1);
    rb_define_singleton_method(rb_cIO, "select", rb_f_select, -1);

    rb_fs = rb_output_fs = Qnil;
    rb_define_hooked_variable("$;", &rb_fs, 0, rb_str_setter);
    rb_define_hooked_variable("$-F", &rb_fs, 0, rb_str_setter);
    rb_define_hooked_variable("$,", &rb_output_fs, 0, rb_str_setter);

    rb_rs = rb_default_rs = rb_str_new2("\n"); rb_output_rs = Qnil;
    rb_global_variable(&rb_default_rs);
    rb_str_freeze(rb_default_rs);	/* avoid modifying RS_default */
    rb_define_hooked_variable("$/", &rb_rs, 0, rb_str_setter);
    rb_define_hooked_variable("$-0", &rb_rs, 0, rb_str_setter);
    rb_define_hooked_variable("$\\", &rb_output_rs, 0, rb_str_setter);

    rb_define_hooked_variable("$.", &lineno, 0, lineno_setter);
    rb_define_virtual_variable("$_", rb_lastline_get, rb_lastline_set);

    rb_define_method(rb_cIO, "clone", rb_io_clone, 0);
    rb_define_method(rb_cIO, "reopen", rb_io_reopen, 1);

    rb_define_method(rb_cIO, "print", rb_io_print, -1);
    rb_define_method(rb_cIO, "putc", rb_io_putc, 1);
    rb_define_method(rb_cIO, "puts", rb_io_puts, -1);
    rb_define_method(rb_cIO, "printf", rb_io_printf, -1);

    rb_define_method(rb_cIO, "each",  rb_io_each_line, -1);
    rb_define_method(rb_cIO, "each_line",  rb_io_each_line, -1);
    rb_define_method(rb_cIO, "each_byte",  rb_io_each_byte, 0);

    rb_define_method(rb_cIO, "syswrite", rb_io_syswrite, 1);
    rb_define_method(rb_cIO, "sysread",  rb_io_sysread, 1);

    rb_define_method(rb_cIO, "fileno", rb_io_fileno, 0);
    rb_define_alias(rb_cIO, "to_i", "fileno");
    rb_define_method(rb_cIO, "to_io", rb_io_to_io, 0);

    rb_define_method(rb_cIO, "sync",   rb_io_sync, 0);
    rb_define_method(rb_cIO, "sync=",  rb_io_set_sync, 1);

    rb_define_method(rb_cIO, "lineno",   rb_io_lineno, 0);
    rb_define_method(rb_cIO, "lineno=",  rb_io_set_lineno, 1);

    rb_define_method(rb_cIO, "readlines",  rb_io_readlines, -1);

    rb_define_method(rb_cIO, "read",  rb_io_read, -1);
    rb_define_method(rb_cIO, "write", rb_io_write, 1);
    rb_define_method(rb_cIO, "gets",  rb_io_gets_method, -1);
    rb_define_method(rb_cIO, "readline",  rb_io_readline, -1);
    rb_define_method(rb_cIO, "getc",  rb_io_getc, 0);
    rb_define_method(rb_cIO, "readchar",  rb_io_readchar, 0);
    rb_define_method(rb_cIO, "ungetc",rb_io_ungetc, 1);
    rb_define_method(rb_cIO, "<<",    rb_io_addstr, 1);
    rb_define_method(rb_cIO, "flush", rb_io_flush, 0);
    rb_define_method(rb_cIO, "tell", rb_io_tell, 0);
    rb_define_method(rb_cIO, "seek", rb_io_seek, 2);
    rb_define_const(rb_cIO, "SEEK_SET", SEEK_SET);
    rb_define_const(rb_cIO, "SEEK_CUR", SEEK_CUR);
    rb_define_const(rb_cIO, "SEEK_END", SEEK_END);
    rb_define_method(rb_cIO, "rewind", rb_io_rewind, 0);
    rb_define_method(rb_cIO, "pos", rb_io_tell, 0);
    rb_define_method(rb_cIO, "pos=", rb_io_set_pos, 1);
    rb_define_method(rb_cIO, "eof", rb_io_eof, 0);
    rb_define_method(rb_cIO, "eof?", rb_io_eof, 0);

    rb_define_method(rb_cIO, "close", rb_io_close_method, 0);
    rb_define_method(rb_cIO, "closed?", rb_io_closed, 0);
    rb_define_method(rb_cIO, "close_read", rb_io_close_read, 0);
    rb_define_method(rb_cIO, "close_write", rb_io_close_write, 0);

    rb_define_method(rb_cIO, "isatty", rb_io_isatty, 0);
    rb_define_method(rb_cIO, "tty?", rb_io_isatty, 0);
    rb_define_method(rb_cIO, "binmode",  rb_io_binmode, 0);

    rb_define_method(rb_cIO, "ioctl", rb_io_ioctl, -1);
    rb_define_method(rb_cIO, "fcntl", rb_io_fcntl, -1);

    rb_stdin = prep_stdio(stdin, FMODE_READABLE, rb_cIO);
    rb_define_hooked_variable("$stdin", &rb_stdin, 0, rb_io_stdio_set);
    rb_stdout = prep_stdio(stdout, FMODE_WRITABLE, rb_cIO);
    rb_define_hooked_variable("$stdout", &rb_stdout, 0, rb_io_stdio_set);
    rb_stderr = prep_stdio(stderr, FMODE_WRITABLE, rb_cIO);
    rb_define_hooked_variable("$stderr", &rb_stderr, 0, rb_io_stdio_set);
d2388 1
a2388 1
    rb_define_hooked_variable("$>", &rb_defout, 0, rb_io_defset);
d2394 2
a2395 2
    argf = rb_obj_alloc(rb_cObject);
    rb_extend_object(argf, rb_mEnumerable);
a2401 1
    rb_define_singleton_method(argf, "to_io", arg_to_io, 0);
d2407 4
a2410 4
    rb_define_singleton_method(argf, "readlines", rb_f_readlines, -1);
    rb_define_singleton_method(argf, "to_a", rb_f_readlines, -1);
    rb_define_singleton_method(argf, "gets", rb_f_gets, -1);
    rb_define_singleton_method(argf, "readline", rb_f_readline, -1);
d2413 3
a2415 8
    rb_define_singleton_method(argf, "tell", rb_f_tell, 0);
    rb_define_singleton_method(argf, "seek", rb_f_seek, 2);
    rb_define_singleton_method(argf, "rewind", rb_f_rewind, 0);
    rb_define_singleton_method(argf, "pos", rb_f_tell, 0);
    rb_define_singleton_method(argf, "pos=", rb_f_set_pos, 1);
    rb_define_singleton_method(argf, "eof", rb_f_eof, 0);
    rb_define_singleton_method(argf, "eof?", rb_f_eof, 0);
    rb_define_singleton_method(argf, "ungetc", rb_f_ungetc, 1);
d2424 1
a2424 1
    filename = rb_str_new2("-");
d2430 1
a2434 2

    Init_File();
@


1.1.1.3.2.1
log
@990126
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:24 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
a56 1
 extern char* strdup(const char*);
d102 1
a102 1
#  define READ_DATA_PENDING(fp) (fp->state.eof == 0)
d1017 1
a1017 1
		fptr->f->mode.binary_io = 1;
d1019 1
a1019 1
		fptr->f2->mode.binary_io = 1;
d2553 1
a2553 1
    int len;
@


1.1.1.3.2.2
log
@990128
@
text
@d6 1
a6 1
  $Date: 1999/01/26 10:08:12 $
d23 1
a23 1
#if defined(HAVE_FCNTL) || defined(NT)
@


1.1.1.3.2.3
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/01/28 07:55:30 $
d1029 1
a1029 1
static int
d1046 1
a1046 2
      error:
	rb_raise(rb_eArgError, "illegal access mode %s", mode);
a1055 23
	if (mode[2] != 0) goto error;
    }
    else if (mode[1] != 0) goto error;

    return flags;
}

static int
rb_io_mode_flags2(mode)
    int mode;
{
    int flags;

    switch (mode & (O_RDONLY|O_WRONLY|O_RDWR)) {
      case O_RDONLY:	
	flags = FMODE_READABLE;
	break;
      case O_WRONLY:
	flags = FMODE_WRITABLE;
	break;
      case O_RDWR:
	flags = FMODE_WRITABLE|FMODE_READABLE;
	break;
a1057 6
#ifdef O_BINARY
    if (mode & O_BINARY) {
	flags |= FMODE_BINMODE;
    }
#endif

a1060 21
static int
rb_open(fname, flag, mode)
    char *fname;
    int flag;
    mode_t mode;
{
    int fd;

    fd = open(fname, flag, mode);
    if (fd < 0) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    fd = open(fname, flag, mode);
	}
	if (fd < 0) {
	    rb_sys_fail(fname);
	}
    }
    return fd;
}

d1066 1
a1066 1
    FILE *file;
d1068 2
a1069 2
    file = fopen(fname, mode);
    if (file == NULL) {
d1072 1
a1072 1
	    file = fopen(fname, mode);
d1074 1
a1074 1
	if (file == NULL) {
d1078 1
a1078 1
    return file;
d1086 1
a1086 1
    FILE *file;
d1088 4
a1091 5
    file = fdopen(fd, mode);
    if (file == NULL) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    file = fdopen(fd, mode);
d1093 1
a1093 1
	if (file == NULL) {
d1097 1
a1097 39
    return file;
}

VALUE
rb_file_open(fname, mode)
    char *fname, *mode;
{
    OpenFile *fptr;
    NEWOBJ(port, struct RFile);
    OBJSETUP(port, rb_cFile, T_FILE);
    MakeOpenFile(port, fptr);

    fptr->mode = rb_io_mode_flags(mode);
    fptr->f = rb_fopen(fname, mode);
    fptr->path = strdup(fname);
    rb_obj_call_init((VALUE)port);

    return (VALUE)port;
}

VALUE
rb_file_sysopen(fname, flags, mode)
    char *fname;
    int flags, mode;
{
    OpenFile *fptr;
    int fd;
    char *m;
    NEWOBJ(port, struct RFile);
    OBJSETUP(port, rb_cFile, T_FILE);
    MakeOpenFile(port, fptr);

    fd = rb_open(fname, flags, mode);
    fptr->mode = rb_io_mode_flags2(flags);
    fptr->f = rb_fdopen(fd, m);
    fptr->path = strdup(fname);
    rb_obj_call_init((VALUE)port);

    return (VALUE)port;
d1333 2
a1334 4
rb_file_s_open(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
d1336 2
a1337 12
    VALUE fname, vmode, file, perm;
    char *path, *mode;

    rb_scan_args(argc, argv, "12", &fname, &vmode, &perm);
    Check_SafeStr(fname);
    path = RSTRING(fname)->ptr;

    if (FIXNUM_P(vmode)) {
	int flags = FIX2INT(vmode);
	int fmode = NIL_P(perm) ? 0666 : FIX2INT(perm);

	file = rb_file_sysopen(path, flags, fmode);
d1340 1
a1340 13
	if (!NIL_P(vmode)) {
	    mode = STR2CSTR(vmode);
	}
	else {
	    mode = "r";
	}
	file = rb_file_open(RSTRING(fname)->ptr, mode);
    }

    RBASIC(file)->klass = klass;
    rb_obj_call_init(file);
    if (rb_iterator_p()) {
	return rb_ensure(rb_yield, file, rb_io_close, file);
a1341 2

    return file;
d1350 1
a1350 1
    VALUE pname, pmode, perm;
d1353 1
a1353 1
    rb_scan_args(argc, argv, "12", &pname, &pmode, &perm);
a1354 4
    if (RSTRING(pname)->ptr[0] != '|') /* open file */
	return rb_file_s_open(argc, argv, rb_cFile);

    /* open pipe */
a1357 29
    else if (FIXNUM_P(pmode)) {
	int flags = FIX2INT(pmode);
	char *p;

	mode = p = ALLOCA_N(char, 4);
	switch (flags & (O_RDONLY|O_WRONLY|O_RDWR)) {
	  case O_RDONLY:	
	    *p++ = 'r';
	    break;
	  case O_WRONLY:
	    *p++ = 'w';
	    break;
	  case O_RDWR:
	    *p++ = 'w';
	    *p++ = '+';
	    break;
	}
	*p++ = '\0';
#ifdef O_BINARY
	if (flags & O_BINARY) {
	    if (mode[1] == '+') {
		mode[1] = 'b'; mode[2] = '+'; mode[3] = '\0';
	    }
	    else {
		mode[1] = 'b'; mode[2] = '\0';
	    }
	}
#endif
    }
d1364 1
a1364 1
	    rb_raise(rb_eArgError, "illegal access mode %s", mode);
d1367 1
a1367 1
    port = pipe_open(RSTRING(pname)->ptr, mode);
a1375 12
rb_io_open(fname, mode)
    char *fname, *mode;
{
    if (fname[0] == '|') {
	return pipe_open(fname+1, mode);
    }
    else {
	return rb_file_open(fname, mode);
    }
}

static VALUE
d1397 1
a1397 1
static VALUE
a1461 50
rb_file_reopen(argc, argv, file)
    int argc;
    VALUE *argv;
    VALUE file;
{
    VALUE fname, nmode;
    char *mode;
    OpenFile *fptr;

    rb_secure(4);
    if (rb_scan_args(argc, argv, "11", &fname, &nmode) == 1) {
	if (TYPE(fname) == T_FILE) { /* fname must be IO */
	    return rb_io_reopen(file, fname);
	}
    }

    Check_SafeStr(fname);
    if (!NIL_P(nmode)) {
	mode = STR2CSTR(nmode);
    }
    else {
	mode = "r";
    }

    GetOpenFile(file, fptr);
    if (fptr->path) free(fptr->path);
    fptr->path = strdup(RSTRING(fname)->ptr);
    fptr->mode = rb_io_mode_flags(mode);
    if (!fptr->f) {
	fptr->f = rb_fopen(RSTRING(fname)->ptr, mode);
	if (fptr->f2) {
	    fclose(fptr->f2);
	    fptr->f2 = NULL;
	}
	return file;
    }

    if (freopen(RSTRING(fname)->ptr, mode, fptr->f) == NULL) {
	rb_sys_fail(fptr->path);
    }
    if (fptr->f2) {
	if (freopen(RSTRING(fname)->ptr, "w", fptr->f2) == NULL) {
	    rb_sys_fail(fptr->path);
	}
    }

    return file;
}

static VALUE
d1874 2
a1875 1
#if !defined(MSDOS) && !defined(__CYGWIN32__) && !(NT) && !defined(__human68k__) && !defined(USE_CWGUSI) && !defined(__BEOS__)
d1904 1
a1904 6
    if (rb_rs == rb_default_rs) {
	line = rb_io_gets(file);
    }
    else {
	line = rb_io_gets_internal(argc, argv, file);
    }
a1931 4
    if (rb_rs != rb_default_rs) {
	return rb_f_gets(0, 0);
    }

d2456 2
a2457 2
    r = prep_stdio(rb_fdopen(pipes[0], "r"), FMODE_READABLE, rb_cIO);
    w = prep_stdio(rb_fdopen(pipes[1], "w"), FMODE_WRITABLE, rb_cIO);
a2869 26

    rb_define_method(rb_cFile, "reopen",  rb_file_reopen, -1);

    rb_define_singleton_method(rb_cFile, "new",  rb_file_s_open, -1);
    rb_define_singleton_method(rb_cFile, "open",  rb_file_s_open, -1);

    rb_file_const("RDONLY", INT2FIX(O_RDONLY));
    rb_file_const("WRONLY", INT2FIX(O_WRONLY));
    rb_file_const("RDWR", INT2FIX(O_RDWR));
    rb_file_const("APPEND", INT2FIX(O_APPEND));
    rb_file_const("CREAT", INT2FIX(O_CREAT));
    rb_file_const("EXCL", INT2FIX(O_EXCL));
#if defined(O_NDELAY) || defined(O_NONBLOCK)
#   ifdef O_NONBLOCK
    rb_file_const("NONBLOCK", INT2FIX(O_NONBLOCK));
#   else
    rb_file_const("NONBLOCK", INT2FIX(O_NDELAY));
#   endif
#endif
    rb_file_const("TRUNC", INT2FIX(O_TRUNC));
#ifdef O_NOCTTY
    rb_file_const("NOCTTY", INT2FIX(O_NOCTTY));
#endif
#ifdef O_BINARY
    rb_file_const("BINARY", INT2FIX(O_BINARY));
#endif
@


1.1.1.3.2.4
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/02/09 06:08:21 $
a1090 33
static char*
rb_io_flags_mode(flags)
    int flags;
{
    static char mode[4];
    char *p = mode;

    switch (flags & (O_RDONLY|O_WRONLY|O_RDWR)) {
      case O_RDONLY:	
	*p++ = 'r';
	break;
      case O_WRONLY:
	*p++ = 'w';
	break;
      case O_RDWR:
	*p++ = 'w';
	*p++ = '+';
	break;
    }
    *p++ = '\0';
#ifdef O_BINARY
    if (flags & O_BINARY) {
	if (mode[1] == '+') {
	    mode[1] = 'b'; mode[2] = '+'; mode[3] = '\0';
	}
	else {
	    mode[1] = 'b'; mode[2] = '\0';
	}
    }
#endif
    return mode;
}

a1173 6
#ifdef USE_CWGUSI
    if (mode != 0666) {
	rb_warn("can't specify file mode on this platform");
    }
    return rb_file_open(fname, rb_io_flags_mode(flags));
#else
a1187 1
#endif
d1479 27
a1505 1
	mode = rb_io_flags_mode(FIX2INT(pmode));
d1516 1
a1516 1
    port = pipe_open(RSTRING(pname)->ptr+1, mode);
@


1.1.1.3.2.5
log
@990212
@
text
@d6 1
a6 1
  $Date: 1999/02/10 08:44:25 $
d114 1
a114 4
    if (!READ_DATA_PENDING(fp)) {\
	rb_thread_wait_fd(fileno(fp));\
        rb_io_check_closed(fptr);\
     }\
a843 2
    int fd;

a845 4
#ifdef USE_THREAD
    rb_thread_fd_close(fileno(fptr->f));
#endif

d957 1
a957 3
    if (!rb_thread_fd_writable(fileno(f))) {
        rb_io_check_closed(fptr);
    }
a1590 3
#ifdef USE_THREAD
    rb_thread_fd_close(fileno(fptr->f));
#endif
@


1.1.1.3.2.6
log
@990215
@
text
@d6 1
a6 1
  $Date: 1999/02/12 11:17:03 $
d1139 1
a1139 1
    unsigned int mode;
@


1.1.1.3.2.7
log
@990224
@
text
@d6 1
a6 1
  $Date: 1999/02/15 07:31:51 $
a61 3
# ifdef _X86_
#  define NOFILE (OPEN_MAX)
# endif
a1231 1
    m = rb_io_flags_mode(flags);
d2211 46
a2258 1
    rb_warn("getc is obsolete; use STDIN.getc instead");
d2263 18
a2783 34
arg_tell()
{
    return rb_io_tell(file);
}

static VALUE
arg_seek(self, offset, ptrname)
     VALUE self, offset, ptrname;
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, "no stream to seek");
    }

    return rb_io_seek(file, offset, ptrname);
}

static VALUE
arg_set_pos(self, offset)
     VALUE self, offset;
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, "no stream to pos");
    }

    return rb_io_set_pos(file, offset);
}

static VALUE
arg_rewind()
{
    return rb_io_rewind(file);
}

static VALUE
a2857 19
arg_eof()
{
    if (init_p == 0 && !next_argv())
	return Qtrue;
    if (rb_io_eof(file)) {
	next_p = 1;
	return Qtrue;
    }
    return Qfalse;
}

static VALUE
rb_f_eof()
{
    rb_warn("eof? is obsolete; use ARGF.eof? instead");
    return arg_eof();
}

static VALUE
d2955 3
d2961 1
d2963 1
d3089 8
a3096 7
    rb_define_singleton_method(argf, "tell", arg_tell, 0);
    rb_define_singleton_method(argf, "seek", arg_seek, 2);
    rb_define_singleton_method(argf, "rewind", arg_rewind, 0);
    rb_define_singleton_method(argf, "pos", arg_tell, 0);
    rb_define_singleton_method(argf, "pos=", arg_set_pos, 1);
    rb_define_singleton_method(argf, "eof", arg_eof, 0);
    rb_define_singleton_method(argf, "eof?", arg_eof, 0);
@


1.1.1.3.2.8
log
@990225
@
text
@d6 1
a6 1
  $Date: 1999/02/24 04:31:20 $
d1211 1
a1211 1
    rb_obj_call_init((VALUE)port, 0, 0);
d1239 1
a1239 1
    rb_obj_call_init((VALUE)port, 0, 0);
d1354 1
a1354 1
	rb_obj_call_init((VALUE)port, 0, 0);
d1442 1
a1442 1
	    rb_obj_call_init((VALUE)port, 0, 0);
d1507 1
a1507 1
    rb_obj_call_init(file, 0, 0);
d2019 1
a2019 1
    rb_obj_call_init((VALUE)io, 0, 0);
a2657 7
static VALUE
rb_f_pipe()
{
    rb_warn("pipe is obsolete; use IO::pipe instead");
    return rb_io_s_pipe();
}

d2957 1
a2957 1
    rb_define_global_function("pipe", rb_f_pipe, 0);
@


1.1.1.3.2.9
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/25 06:39:07 $
d113 4
a116 1
#define READ_CHECK(fp) do {\
d122 1
d157 2
a158 2
static VALUE
io_write(io, str)
a202 7
VALUE
rb_io_write(io, str)
    VALUE io, str;
{
    return rb_funcall(io, id_write, 1, str);
}

d422 1
a422 1
io_read(argc, argv, io)
d853 2
d856 1
a913 1
    int n;
d923 1
a923 1
    n = fclose(fptr->f);
a926 1
    if (n != 0) rb_sys_fail(fptr->path);
a935 1
    int n;
d945 1
a945 1
    n = fclose(fptr->f2);
a947 1
    if (n != 0) rb_sys_fail(fptr->path);
d968 1
d972 1
d994 1
d996 1
d1161 2
a1162 2
    const char *fname;
    const char *mode;
d1182 1
a1182 1
    const char *mode;
d1201 1
a1201 1
    const char *fname, *mode;
d1391 2
d1406 1
d1408 3
d1606 1
d1608 1
d2063 2
a2064 2
	    fn = STR2CSTR(filename);
	    if (strlen(fn) == 1 && fn[0] == '-') {
a2284 1
    VALUE io;
d2301 3
a2303 1
	    GetOpenFile(rb_io_get_io(RARRAY(read)->ptr[i]), fptr);
d2324 3
a2326 1
	    GetOpenFile(rb_io_get_io(RARRAY(write)->ptr[i]), fptr);
d2343 3
a2345 1
	    GetOpenFile(rb_io_get_io(RARRAY(except)->ptr[i]), fptr);
d2359 1
d2364 13
d2388 1
a2388 1
		GetOpenFile(rb_io_get_io(RARRAY(read)->ptr[i]), fptr);
d2399 1
a2399 1
		GetOpenFile(rb_io_get_io(RARRAY(write)->ptr[i]), fptr);
d2412 1
a2412 1
		GetOpenFile(rb_io_get_io(RARRAY(except)->ptr[i]), fptr);
d2790 1
a2790 1
    tmp = io_read(argc, argv, file);
d3020 2
a3021 2
    rb_define_method(rb_cIO, "read",  io_read, -1);
    rb_define_method(rb_cIO, "write", io_write, 1);
@


1.1.1.3.2.10
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:29 $
d43 1
a43 2
/* EMX has sys/parm.h, but.. */
#if defined(HAVE_SYS_PARAM_H) && !defined(__EMX__)
d188 1
a188 1
    if (ferror(f)) {
d239 1
a239 1
    if (ferror(fptr->f)) rb_sys_fail(fptr->path);
a703 14
arg_set_lineno(argf, val)
    VALUE argf, val;
{
    gets_lineno = NUM2INT(val);
    lineno = INT2FIX(gets_lineno);
}

static VALUE
arg_lineno()
{
    return lineno;
}

static VALUE
d766 1
a766 1
    if (ferror(f)) rb_sys_fail(fptr->path);
d788 1
a788 1
	if (ferror(f)) rb_sys_fail(fptr->path);
d1015 1
a1015 2
#if defined(NT) || defined(DJGPP) || defined(__CYGWIN32__)\
    || defined(__human68k__) || defined(USE_CWGUSI) || defined(__EMX__)
d1840 1
a1840 1
    if (fputc(c, f) == EOF)
d2082 1
a2082 1
#if defined(MSDOS) || defined(__BOW__) || defined(__CYGWIN32__) || defined(NT) || defined(__human68k__) || defined(__EMX__)
d2109 1
a2109 1
#if !defined(MSDOS) && !defined(__CYGWIN32__) && !(NT) && !defined(__human68k__) && !defined(USE_CWGUSI) && !defined(__BEOS__) && !defined(__EMX__)
a2949 1
    rb_define_singleton_method(rb_cIO, "pipe", rb_io_s_pipe, 0);
d3073 2
a3074 3
    rb_define_singleton_method(argf, "lineno",   arg_lineno, 0);
    rb_define_singleton_method(argf, "lineno=",  arg_set_lineno, 1);

a3076 2
    filename = rb_str_new2("-");
    rb_define_readonly_variable("$FILENAME", &filename);
@


1.1.1.3.2.11
log
@prepare to alpha
@
text
@d6 1
a6 1
  $Date: 1999/04/09 17:57:39 $
a1609 1
    if (fptr == orig) return io;
a2000 3
    }
    if (ruby_verbose) {
	rb_warn("assignment for %s is done by reopen", rb_id2name(id));
@


1.1.1.3.2.12
log
@to open CVS
@
text
@d6 1
a6 1
  $Date: 1999/04/16 06:03:31 $
d1215 2
a1216 3
static VALUE
rb_file_open_internal(klass, fname, mode)
    VALUE klass;
d1221 1
a1221 1
    OBJSETUP(port, klass, T_FILE);
d1233 1
a1233 9
rb_file_open(fname, mode)
    const char *fname, *mode;
{
    return rb_file_open_internal(rb_cFile, fname, mode);
}

VALUE
rb_file_sysopen_internal(klass, fname, flags, mode)
    VALUE klass;
d1241 1
a1241 1
    return rb_file_open_internal(klass, fname, rb_io_flags_mode(flags));
d1247 1
a1247 1
    OBJSETUP(port, klass, T_FILE);
a1260 8
VALUE
rb_file_sysopen(fname, flags, mode)
    char *fname;
    int flags, mode;
{
    return rb_file_sysopen_internal(rb_cFile, flags, mode);
}

d1504 1
a1504 1
	file = rb_file_sysopen_internal(klass, path, flags, fmode);
d1513 1
a1513 1
	file = rb_file_open_internal(klass, RSTRING(fname)->ptr, mode);
d1516 2
a1555 1
    if (NIL_P(port)) return Qnil;
d1985 1
a1985 1
	rb_raise(rb_eTypeError, "$> must have write method, %s given",
a2267 1
    if (NIL_P(port)) return rb_str_new(0,0);
a2689 1
    if (NIL_P(arg.io)) return Qnil;
a2720 1
    if (NIL_P(arg.io)) return Qnil;
@


1.1.1.3.2.13
log
@aix shlib link
@
text
@d6 1
a6 1
  $Date: 1999/04/20 08:21:36 $
d705 1
a705 1
argf_set_lineno(argf, val)
d713 1
a713 1
argf_lineno()
a2067 10
static int binmode = 0;

static VALUE
argf_binmode()
{
    rb_io_binmode(file);
    binmode = 1;
    return argf;
}

a2155 1
	    rb_io_binmode(file);
d2744 1
a2744 1
argf_tell()
d2750 1
a2750 1
argf_seek(self, offset, ptrname)
d2761 1
a2761 1
argf_set_pos(self, offset)
d2772 1
a2772 1
argf_rewind()
d2778 1
a2778 1
argf_fileno()
d2784 1
a2784 1
argf_to_io()
d2790 1
a2790 1
argf_read(argc, argv)
d2824 1
a2824 1
argf_getc()
d2841 1
a2841 1
argf_readchar()
d2852 1
a2852 1
argf_eof()
d2867 1
a2867 1
    return argf_eof();
d2871 1
a2871 1
argf_each_line(argc, argv)
d2884 1
a2884 1
argf_each_byte()
d2888 1
a2888 1
    while (!NIL_P(byte = argf_getc())) {
d2895 1
a2895 1
argf_filename()
d2901 1
a2901 1
argf_file()
d2907 1
a2907 1
argf_skip()
d2917 1
a2917 1
argf_close()
d2928 1
a2928 1
argf_closed()
d3084 6
a3089 6
    rb_define_singleton_method(argf, "fileno", argf_fileno, 0);
    rb_define_singleton_method(argf, "to_i", argf_fileno, 0);
    rb_define_singleton_method(argf, "to_io", argf_to_io, 0);
    rb_define_singleton_method(argf, "each",  argf_each_line, -1);
    rb_define_singleton_method(argf, "each_line",  argf_each_line, -1);
    rb_define_singleton_method(argf, "each_byte",  argf_each_byte, 0);
d3091 1
a3091 1
    rb_define_singleton_method(argf, "read",  argf_read, -1);
d3096 16
a3111 17
    rb_define_singleton_method(argf, "getc", argf_getc, 0);
    rb_define_singleton_method(argf, "readchar", argf_readchar, 0);
    rb_define_singleton_method(argf, "tell", argf_tell, 0);
    rb_define_singleton_method(argf, "seek", argf_seek, 2);
    rb_define_singleton_method(argf, "rewind", argf_rewind, 0);
    rb_define_singleton_method(argf, "pos", argf_tell, 0);
    rb_define_singleton_method(argf, "pos=", argf_set_pos, 1);
    rb_define_singleton_method(argf, "eof", argf_eof, 0);
    rb_define_singleton_method(argf, "eof?", argf_eof, 0);
    rb_define_singleton_method(argf, "binmode", argf_binmode, 0);

    rb_define_singleton_method(argf, "to_s", argf_filename, 0);
    rb_define_singleton_method(argf, "filename", argf_filename, 0);
    rb_define_singleton_method(argf, "file", argf_file, 0);
    rb_define_singleton_method(argf, "skip", argf_skip, 0);
    rb_define_singleton_method(argf, "close", argf_close, 0);
    rb_define_singleton_method(argf, "closed?", argf_closed, 0);
d3113 2
a3114 2
    rb_define_singleton_method(argf, "lineno",   argf_lineno, 0);
    rb_define_singleton_method(argf, "lineno=",  argf_set_lineno, 1);
@


1.1.1.3.2.14
log
@small fixes
@
text
@d6 1
a6 1
  $Date: 1999/04/26 09:42:31 $
d1059 1
a1059 1
int
d1061 1
a1061 1
    const char *mode;
@


1.1.1.3.2.15
log
@$/, Struct subclassing
@
text
@d6 1
a6 1
  $Date: 1999/05/06 08:31:30 $
d2185 1
a2185 1
    if (argc == 0 && rb_rs == rb_default_rs) {
@


1.1.1.3.2.16
log
@mbc bug in regex
@
text
@d6 1
a6 1
  $Date: 1999/05/12 05:27:32 $
d2166 1
a2166 1
	    if (binmode) rb_io_binmode(file);
@


1.1.1.3.2.17
log
@syscall bug
@
text
@d6 1
a6 1
  $Date: 1999/05/18 06:06:12 $
a709 1
    return Qnil;
d868 2
d2325 1
d2643 2
a2644 2
    if (retval < 0) rb_sys_fail(0);
    return INT2NUM(retval);
@


1.1.1.3.2.18
log
@990531
@
text
@d6 1
a6 1
  $Date: 1999/05/25 07:28:31 $
d58 1
a59 5

#ifndef strdup
char *strdup();
#endif

a868 2
    int fd;

d870 1
a871 1
    fd = fileno(fptr->f);
a878 1
    rb_thread_fd_close(fd);
@


1.1.1.3.2.19
log
@thread bugs
@
text
@d6 1
a6 1
  $Date: 1999/05/31 09:13:11 $
d309 4
d323 1
a811 16
}

int
rb_getc(f)
    FILE *f;
{
    int c;

    if (!READ_DATA_PENDING(f)) {
	rb_thread_wait_fd(fileno(f));
    }
    TRAP_BEG;
    c = getc(f);
    TRAP_END;

    return c;
@


1.1.1.3.2.20
log
@990611
@
text
@d6 1
a6 1
  $Date: 1999/06/09 09:21:14 $
a134 3
    if (!fptr) {
	rb_raise(rb_eIOError, "uninitialized stream");
    }
a156 9
void
rb_read_check(fp)
    FILE *fp;
{
    if (!READ_DATA_PENDING(fp)) {
	rb_thread_wait_fd(fileno(fp));
    }
}

d1245 1
d1281 1
d1404 1
d1486 1
d1504 1
a1504 1
    VALUE pname, pmode, port;
d1518 1
a1518 3
    port = pipe_open(RSTRING(pname)->ptr, mode);
    if (NIL_P(port)) return Qnil;
    return port;
d2064 1
@


1.1.1.3.2.21
log
@990624
@
text
@d6 1
a6 1
  $Date: 1999/06/11 06:29:54 $
d547 1
a547 1
		    if (ferror(f) && errno == EINTR) continue;
d636 1
a636 1
	    if (ferror(f) && errno == EINTR) continue;
d886 4
a905 4
	if (fptr->pid) {
	    rb_syswait(fptr->pid);
	    fptr->pid = 0;
	}
a2033 19
static int
rb_dup(orig)
    int orig;
{
    int fd;

    fd = dup(orig);
    if (fd < 0) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    fd = dup(orig);
	}
	if (fd < 0) {
	    rb_sys_fail(0);
	}
    }
    return fd;
}

d2035 1
a2035 1
set_stdin(val, id, var)
a2041 1
    char *mode;
a2042 1
    if (val == *var) return;
d2046 3
a2048 4

    GetOpenFile(val, fptr);
    rb_io_check_readable(fptr);

d2050 1
a2050 7
    mode = rb_io_mode_string(fptr);
    fd = rb_dup(fileno(fptr->f));
    if (fileno(fptr->f) > 2) {
	fclose(fptr->f);
    }
    fptr->f = rb_fdopen(fd, mode);

d2052 2
a2053 24
    dup2(fileno(fptr->f), 0);
    fclose(fptr->f);
    fptr->f = stdin;

    *var = val;
}

static void
set_outfile(val, id, var, stdf)
    VALUE val;
    ID id;
    VALUE *var;
    FILE *stdf;
{
    OpenFile *fptr;
    FILE *f;
    int fd;
    char *mode;

    if (val == *var) return;
    rb_io_flush(*var);

    if (TYPE(val) != T_FILE) {
	rb_raise(rb_eTypeError, "%s must be IO object", rb_id2name(id));
d2055 2
a2056 10

    GetOpenFile(val, fptr);
    rb_io_check_writable(fptr);

    GetOpenFile(*var, fptr);
    mode = rb_io_mode_string(fptr);
    f = GetWriteFile(fptr);
    fd = rb_dup(fileno(f));
    if (fileno(f) > 2) {
	fclose(fptr->f);
d2058 1
a2058 30
    f = rb_fdopen(fd, mode);
    if (fptr->f2) fptr->f2 = f;
    else          fptr->f = f;

    GetOpenFile(val, fptr);
    f = GetWriteFile(fptr);
    dup2(fileno(f), fileno(stdf));
    fclose(f);
    if (fptr->f2) fptr->f2 = stdf;
    else          fptr->f = stdf;

    *var = val;
}

static void
set_stdout(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    set_outfile(val, id, var, stdout);
}

static void
set_stderr(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    set_outfile(val, id, var, stderr);
d2333 3
d3102 1
a3102 1
    rb_define_hooked_variable("$stdin", &rb_stdin, 0, set_stdin);
d3104 1
a3104 1
    rb_define_hooked_variable("$stdout", &rb_stdout, 0, set_stdout);
d3106 1
a3106 1
    rb_define_hooked_variable("$stderr", &rb_stderr, 0, set_stderr);
@


1.1.1.3.2.22
log
@990715
@
text
@d6 1
a6 1
  $Date: 1999/06/24 04:23:55 $
d93 1
a93 1
struct timeval rb_time_interval _((VALUE));
d1299 1
a1299 1
    const char *fname;
d1302 1
a1302 1
    return rb_file_sysopen_internal(rb_cFile, fname, flags, mode);
d2441 1
a2441 1
	timerec = rb_time_interval(timeout);
@


1.1.1.3.2.23
log
@backtrace may be Qnil
@
text
@d6 1
a6 1
  $Date: 1999/07/15 07:59:46 $
a319 1
    if (feof(fptr->f)) return Qtrue;
a399 1
    if (feof(fptr->f)) return Qnil;
d406 1
a406 4
	if (st.st_size == 0) {
	    getc(fptr->f);	/* force EOF */
	    return rb_str_new(0, 0);
	}
d420 3
a422 2
	if (n < 0) {
	    rb_sys_fail(fptr->path);
a454 1
    if (feof(fptr->f)) return Qtrue;
d461 3
a463 2
    if (n < 0) {
	rb_sys_fail(fptr->path);
d770 1
a770 1
    return io;
d2322 1
a2322 1
    rb_lastline_set(line);
a2342 1
    rb_lastline_set(line);
d2344 1
d3000 1
a3000 1
    return argf;
@


1.1.1.3.2.24
log
@990728
@
text
@d6 1
a6 1
  $Date: 1999/07/22 10:37:16 $
d23 1
a23 1
#if defined(HAVE_FCNTL_H) || defined(NT)
a24 2
#elif defined(HAVE_SYS_FCNTL_H)
#include <sys/fcntl.h>
d425 1
a425 2
	if (n == 0) {
	    if (feof(fptr->f)) return Qnil;
d459 1
a459 1
    if (feof(fptr->f)) return Qnil;
d466 1
a466 2
    if (n == 0) {
	if (feof(fptr->f)) return Qnil;
d1050 1
a1050 3
    if (n == 0 && ilen > 0) {
	rb_eof_error();
    }
@


1.1.1.3.2.25
log
@990806
@
text
@d6 1
a6 1
  $Date: 1999/07/28 09:26:41 $
d910 4
a937 4
    if (fptr->pid) {
	rb_syswait(fptr->pid);
	fptr->pid = 0;
    }
@


1.1.1.3.2.26
log
@clone
@
text
@d6 1
a6 1
  $Date: 1999/08/06 06:48:19 $
d1775 1
a1775 1
    CLONESETUP(obj, io);
@


1.1.1.3.2.27
log
@pre 1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/10 08:47:16 $
a15 1
#include "env.h"
a81 1
static VALUE orig_stdin, orig_stdout, orig_stderr;
d97 1
a97 1
static VALUE filename, current_file;
d2034 3
d2075 1
a2075 5
	*var = val;
	return;
    }
    if (TYPE(*var) != T_FILE) {
	*var = orig_stdin;
d2098 1
a2098 1
set_outfile(val, var, orig, stdf)
d2100 1
a2101 1
    VALUE orig;
d2110 1
a2111 3
    if (TYPE(*var) == T_FILE) {
	rb_io_flush(*var);
    }
d2113 1
a2113 5
	*var = val;
	return;
    }
    if (TYPE(*var) != T_FILE) {
	*var = orig;
d2146 1
a2146 1
    set_outfile(val, var, orig_stdout, stdout);
d2155 1
a2155 1
    set_outfile(val, var, orig_stderr, stderr);
a2193 7
argf_forward()
{
    return rb_funcall3(current_file, ruby_frame->last_func,
		       ruby_frame->argc, ruby_frame->argv);
}

static VALUE
d2196 1
a2196 6
    if (TYPE(current_file) != T_FILE) {
	argf_forward();
    }
    else {
	rb_io_binmode(current_file);
    }
d2213 1
a2213 1
	    current_file = rb_stdin;
d2226 1
a2226 1
		current_file = rb_stdin;
d2287 1
a2287 1
		current_file = prep_stdio(fr, FMODE_READABLE, rb_cFile);
d2289 1
a2289 1
	    if (binmode) rb_io_binmode(current_file);
a2298 10
static void
any_close(file)
    VALUE file;
{
    if (TYPE(file) == T_FILE)
	rb_io_close(file);
    else
	rb_funcall3(file, rb_intern("close"), 0, 0);
}

a2307 3
    if (TYPE(current_file) != T_FILE) {
	line = rb_funcall3(current_file, rb_intern("gets"), argc, argv);
    }
d2309 1
a2309 1
	line = rb_io_gets(current_file);
d2312 1
a2312 1
	line = rb_io_gets_internal(argc, argv, current_file);
d2315 1
a2315 1
	any_close(current_file);
d2347 1
a2347 1
    line = rb_io_gets(current_file);
d2349 1
a2349 1
	any_close(current_file);
d2798 7
d2876 1
a2876 8
    if (!next_argv()) {
	rb_raise(rb_eArgError, "no stream to tell");
    }

    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_tell(current_file);
d2887 1
a2887 4
    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_seek(current_file, offset, ptrname);
d2898 1
a2898 4
    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_set_pos(current_file, offset);
d2904 1
a2904 7
    if (!next_argv()) {
	rb_raise(rb_eArgError, "no stream to rewind");
    }
    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_rewind(current_file);
d2910 1
a2910 7
    if (!next_argv()) {
	rb_raise(rb_eArgError, "no stream");
    }
    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_fileno(current_file);
d2916 1
a2916 1
    return current_file;
d2932 1
a2932 7
    if (TYPE(current_file) != T_FILE) {
	tmp = argf_forward();
	STR2CSTR(tmp);
    }
    else {
	tmp = io_read(argc, argv, current_file);
    }
d2934 1
a2934 1
	any_close(current_file);
d2960 1
a2960 6
    if (TYPE(current_file) != T_FILE) {
	byte = rb_funcall3(current_file, rb_intern("getc"), 0, 0);
    }
    else {
	byte = rb_io_getc(current_file);
    }
d2962 1
a2962 1
	any_close(current_file);
d2973 1
a2973 1
    VALUE c = argf_getc();
d2986 1
a2986 4
    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    if (rb_io_eof(current_file)) {
d2994 7
d3033 1
a3033 1
    return current_file;
d3040 1
a3040 1
	any_close(current_file);
d3049 1
a3049 1
    any_close(current_file);
d3060 1
a3060 4
    if (TYPE(current_file) != T_FILE) {
	return argf_forward();
    }
    return rb_io_closed(current_file);
d3098 2
d3106 1
d3195 1
a3195 1
    rb_stdin = orig_stdin = prep_stdio(stdin, FMODE_READABLE, rb_cIO);
d3197 1
a3197 1
    rb_stdout = orig_stdout = prep_stdio(stdout, FMODE_WRITABLE, rb_cIO);
d3199 1
a3199 1
    rb_stderr = orig_stderr = prep_stdio(stderr, FMODE_WRITABLE, rb_cIO);
d3247 2
a3248 2
    current_file = rb_stdin;
    rb_global_variable(&current_file);
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:04:57 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:46 $
d1004 1
a1004 2
	if (pid > 0) rb_sys_fail(0);
	else {
@


1.1.1.2.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/19 05:22:20 $
d1004 1
a1004 1
	if (pid < 0) rb_sys_fail(pname);
@


1.1.1.2.2.4
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/19 05:37:15 $
d1147 1
a1147 5
    if (fileno(fptr->f) < 3) {
	/* need to keep stdio */
	dup2(fileno(orig->f), fd);
    }
    else {
d1149 2
a1150 2
	fptr->f = rb_fdopen(fd, mode);
    }
d1154 2
a1155 1
	fclose(fptr->f2);
d1158 1
a1158 1
	    fptr->f2 = rb_fdopen(fd, "w");
a1399 1
    FILE *f;
d1404 22
a1425 1
    io_reopen(rb_stderr, val);
@


1.1.1.2.2.5
log
@__FILE__,__LINE__
@
text
@d6 1
a6 1
  $Date: 1998/01/29 08:18:02 $
d1397 1
a1397 1
io_stdio_set(val, id, var)
a1399 1
    VALUE *var;
d1401 1
a1401 1
    OpenFile *fptr, *fptr2;
d1403 1
d1406 1
a1406 10
	TypeError("%s must be IO object", rb_id2name(id));
    }
    GetOpenFile(*var, fptr);
    fd = fileno(fptr->f);
    GetOpenFile(val, fptr);
    if (fd == 0) {
	io_readable(fptr);
    }
    else {
	io_writable(fptr);
d1408 1
a1408 1
    io_reopen(*var, val);
d2366 1
a2366 1
    rb_define_hooked_variable("$stdin", &rb_stdin, 0, io_stdio_set);
d2368 1
a2368 1
    rb_define_hooked_variable("$stdout", &rb_stdout, 0, io_stdio_set);
d2370 1
a2370 1
    rb_define_hooked_variable("$stderr", &rb_stderr, 0, io_stdio_set);
@


1.1.1.2.2.6
log
@1.1b7 pre
@
text
@d6 1
a6 1
  $Date: 1998/02/02 04:49:12 $
d111 1
a111 1
io_check_closed(fptr)
d114 3
a116 2
    if (fptr->f == NULL)
	Raise(eIOError, "closed stream");
a122 1
    io_check_closed(fptr);
d128 2
a129 3
void
io_writable(fptr)
    OpenFile *fptr;
d131 1
a131 4
    io_check_closed(fptr);
    if (!(fptr->mode & FMODE_WRITABLE)) {
	Raise(eIOError, "not opened for writing");
    }
d156 1
d200 1
d216 1
d292 1
d338 1
d382 1
d549 1
d574 1
d609 1
d623 1
a623 1
    io_check_closed(fptr);
d639 4
d649 2
a650 2
static void
io_fptr_close(fptr)
a652 2
    if (fptr->f == NULL) return;

d655 1
a662 11
void
io_fptr_finalize(fptr)
    OpenFile *fptr;
{
    io_fptr_close(fptr);
    if (fptr->path) {
	free(fptr->path);
	fptr->path = NULL;
    }
}

d670 1
a670 1
    io_fptr_close(fptr);
d700 1
d723 1
d1172 1
a1172 1
    RBASIC(io)->klass = RBASIC(nfile)->klass;
d1712 1
d1719 1
a1719 1
	    io_check_closed(fptr);
d1742 1
a1742 1
	    io_check_closed(fptr);
d1761 1
a1761 1
	    io_check_closed(fptr);
d1857 1
a1857 1
    if (NIL_P(arg) || arg == FALSE) {
d1863 1
a1863 1
    else if (arg == TRUE) {
@


1.1.1.2.2.7
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/02/09 10:56:21 $
a1957 2
    if (argc == 0)
	ArgError("too few arguments for syscall");
d1971 2
@


1.1.1.2.2.8
log
@shugo's method etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/23 05:36:37 $
a1316 29
io_putc(io, ch)
    VALUE io, ch;
{
    OpenFile *fptr;
    FILE *f;
    int c = NUM2CHR(ch);

    rb_secure(4);
    GetOpenFile(io, fptr);
    io_writable(fptr);

    f = GetWriteFile(fptr);

    if (fputc(c, f) == EOF || ferror(f))
	rb_sys_fail(fptr->path);
    if (fptr->mode & FMODE_SYNC)
	fflush(f);

    return ch;
}

static VALUE
f_putc(recv, ch)
    VALUE recv, ch;
{
    return io_putc(rb_defout, ch);
}

static VALUE
a2277 1
    extern VALUE mKernel;
a2289 2
    rb_define_global_function("putc", f_putc, 1);
    rb_define_global_function("putchar", f_putc, 1);
a2333 1
    rb_define_method(cIO, "putc", io_putc, 1);
@


1.1.1.2.2.9
log
@block arg etc.
@
text
@d6 1
a6 1
  $Date: 1998/03/03 10:16:13 $
a151 1
	/* port is not IO, call write method for it. */
d2321 1
d2456 1
a2460 4

    /* turn on premitive flag for the class */
    FL_SET(cIO, FL_PRIMITIVE);
    Init_File();
@


1.1.1.2.2.10
log
@gets speed up patch
@
text
@d6 1
a6 1
  $Date: 1998/03/05 06:37:45 $
d122 1
d132 1
d373 1
a373 3
    if (argc == 0) {
	return io_gets(io);
    }
d379 4
a389 3
	else if (rslen == 1 && RSTRING(rs)->ptr[0] == '\n') {
	    return io_gets(io);
	}
a399 4
    GetOpenFile(io, fptr);
    io_readable(fptr);
    f = fptr->f;

d491 1
a491 52
    OpenFile *fptr;
    FILE *f;
    VALUE str = Qnil;
    int c;
    char buf[8192];
    char *bp, *bpe = buf + sizeof buf - 3;
    int cnt;
    int append = 0;

    GetOpenFile(io, fptr);
    io_readable(fptr);
    f = fptr->f;

  again:
    bp = buf;
    for (;;) {
	READ_CHECK(f);
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c == EOF) break;
	if ((*bp++ = c) == '\n') break;
	if (bp == bpe) break;
    }
    cnt = bp - buf;

    if (c == EOF) {
	if (!append && cnt == 0) {
	    str = Qnil;
	    goto return_gets;
	}
    }

    if (append)
	str_cat(str, buf, cnt);
    else
	str = str_new(buf, cnt);

    if (c != EOF && RSTRING(str)->ptr[RSTRING(str)->len-1] != '\n') {
	append = 1;
	goto again;
    }

  return_gets:
    if (!NIL_P(str)) {
	fptr->lineno++;
	lineno = INT2FIX(fptr->lineno);
	str_taint(str);
    }
    lastline_set(str);

    return str;
d619 1
d1749 1
d1772 1
d1791 1
d2461 2
@


1.1.1.2.2.11
log
@speed up patch 4
@
text
@d6 1
a6 1
  $Date: 1998/03/11 07:32:57 $
d445 5
a449 3
	if (c == EOF && !append && cnt == 0) {
	    str = Qnil;
	    goto return_gets;
d520 5
a524 3
    if (c == EOF && !append && cnt == 0) {
	str = Qnil;
	goto return_gets;
@


1.1.1.2.2.12
log
@1.1b9_02
@
text
@d6 1
a6 1
  $Date: 1998/03/12 01:15:16 $
d372 1
a372 1
	rs = RS;
d397 1
a415 1
    newline = rslen ? rsptr[rslen - 1] : 0777;
@


1.1.1.2.2.13
log
@1.1b9_03 pre
@
text
@d6 1
a6 1
  $Date: 1998/03/13 09:04:30 $
d114 1
a114 1
    if (fptr->f == NULL && fptr->f2 == NULL)
d694 1
a694 1
    if (fptr->f == NULL && fptr->f2 == NULL) return;
d889 1
a889 1
#if defined (NT) || defined(DJGPP) || defined(__CYGWIN32__) || defined(__human68k__) || 1
d2503 1
a2503 1
#if defined (NT) || defined(DJGPP) || defined(__CYGWIN32__) || defined(__human68k__) || 1
@


1.1.1.2.2.14
log
@1.1b9_03 pre2
@
text
@d6 1
a6 1
  $Date: 1998/03/16 06:00:12 $
d889 1
a889 1
#if defined (NT) || defined(DJGPP) || defined(__CYGWIN32__) || defined(__human68k__)
a915 1
	free(list);
a933 1
    struct pipe_list *tmp;
a935 1
	tmp = list->next;
d937 1
a937 1
	list = tmp;
d2503 1
a2503 1
#if defined (NT) || defined(DJGPP) || defined(__CYGWIN32__) || defined(__human68k__)
@


1.1.1.2.2.15
log
@modulo, frexp, ldexp
@
text
@d6 1
a6 1
  $Date: 1998/03/16 06:37:12 $
d944 1
a948 1
#if !defined (__CYGWIN32__)
a954 3
#else
    fptr_finalize(fptr);
#endif
d959 1
a1078 1
	    fptr->finalize = pipe_finalize;
@


1.1.1.2.2.16
log
@String#chomp! etc.
@
text
@d6 1
a6 1
  $Date: 1998/03/17 10:06:57 $
d162 2
a163 2
	register UCHAR *ptr = RSTRING(str)->ptr;
	n = (int) RSTRING(str)->len;
d167 1
a167 1
	n = ptr - RSTRING(str)->ptr;
@


1.1.1.2.2.17
log
@heredoc etc.
@
text
@d6 1
a6 1
  $Date: 1998/03/23 09:49:16 $
d1601 2
a1602 2
			    Warn("Can't rename %s to %s: %s, skipping file",
				 fn, RSTRING(str)->ptr, strerror(errno));
d1611 2
a1612 2
			    Warn("Can't remove %s: %s, skipping file",
				 fn, strerror(errno));
@


1.1.1.2.2.18
log
@1.1b9_05 bug fix
@
text
@d6 1
a6 1
  $Date: 1998/03/25 09:36:58 $
a727 8
VALUE
io_close_method(io)
    VALUE io;
{
    rb_secure(4);
    return io_close(io);
}

d2449 1
a2449 1
    rb_define_method(cIO, "close", io_close_method, 0);
@


1.1.1.2.2.19
log
@1.1b9_05 patches
@
text
@d6 1
a6 1
  $Date: 1998/03/28 10:57:41 $
d742 2
a743 2
    fptr = RFILE(io)->fptr;
    return (fptr->f || fptr->f2)?FALSE:TRUE;
@


1.1.1.2.2.20
log
@gw32 b19 patch
@
text
@d6 1
a6 1
  $Date: 1998/03/28 11:05:46 $
d163 1
a163 1
	n = (int)RSTRING(str)->len;
d812 1
a812 1
    if (fptr->f2)
@


1.1.1.2.2.21
log
@call initialize
@
text
@d6 1
a6 1
  $Date: 1998/03/30 09:32:49 $
d1536 1
a1537 1
    VALUE io;
d1545 2
a1546 4
    io = prep_stdio(rb_fdopen(NUM2INT(fnum), m), io_mode_flags(m));
    obj_call_init(io);

    return io;
@


1.1.1.2.2.22
log
@signal delivered to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:03:50 $
a1004 1
	obj_call_init((VALUE)port);
a1091 1
	    obj_call_init((VALUE)port);
d1457 2
a1458 4
f_p(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
d1460 1
a1460 1
    VALUE str;
a1461 4
    if (argc > 0) {
	rb_scan_args(argc, argv, "1", &self);
    }
    str = rb_inspect(self);
a1464 1

d1472 1
a1472 20
    f_p(0, 0, obj);
}

static VALUE
obj_display(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE out;
    VALUE str;

    rb_scan_args(argc, argv, "01", &out);
    if (NIL_P(out)) {
	out = rb_defout;
    }

    io_write(out, self);

    return Qnil;
d1515 1
a1515 1
prep_stdio(f, mode, klass)
a1517 1
    VALUE klass;
d1521 1
a1521 1
    OBJSETUP(obj, klass, T_FILE);
a1525 1
    obj_call_init((VALUE)obj);
d1531 1
a1531 1
io_s_new(argc, argv, klass)
a1533 1
    VALUE klass;
d1537 1
d1545 4
a1548 1
    return prep_stdio(rb_fdopen(NUM2INT(fnum), m), io_mode_flags(m), klass);
d1638 1
a1638 1
		    rb_defout = prep_stdio(fw, FMODE_WRITABLE, cIO);
d1640 1
a1640 1
		file = prep_stdio(fr, FMODE_READABLE, cIO);
d2138 2
a2139 2
    r = prep_stdio(fdopen(pipes[0], "r"), FMODE_READABLE, cIO);
    w = prep_stdio(fdopen(pipes[1], "w"), FMODE_WRITABLE, cIO);
d2399 1
a2399 2
    rb_define_method(mKernel, "p", f_p, -1);
    rb_define_method(mKernel, "display", obj_display, -1);
d2469 1
a2469 1
    rb_stdin = prep_stdio(stdin, FMODE_READABLE, cIO);
d2471 1
a2471 1
    rb_stdout = prep_stdio(stdout, FMODE_WRITABLE, cIO);
d2473 1
a2473 1
    rb_stderr = prep_stdio(stderr, FMODE_WRITABLE, cIO);
@


1.1.1.2.2.23
log
@flock,flatten,signal to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/14 04:55:48 $
d458 1
a458 1
	     memcmp(RSTRING(str)->ptr+RSTRING(str)->len-rslen,rsptr,rslen))) {
d823 1
a823 1
    return INT2FIX(0);
d1422 1
a1422 1
	io_write(out, RS_default);
d1442 1
a1442 1
	    io_write(out, RS_default);
d1459 4
a1462 2
f_p(self, obj)
    VALUE self, obj;
d1464 9
a1472 2
    io_write(rb_defout, rb_inspect(obj));
    io_write(rb_defout, RS_default);
d1481 1
a1481 1
    f_p(0, obj);
a1502 20
static VALUE
obj_displayln(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE out;
    VALUE str;

    rb_scan_args(argc, argv, "01", &out);
    if (NIL_P(out)) {
	out = rb_defout;
    }

    io_write(out, self);
    io_write(rb_defout, RS_default);

    return Qnil;
}

d1549 2
a1550 2
    NEWOBJ(io, struct RFile);
    OBJSETUP(io, klass, T_FILE);
d1552 1
a1552 1
    MakeOpenFile(io, fp);
d1555 1
a1555 1
    obj_call_init((VALUE)io);
d1557 1
a1557 1
    return (VALUE)io;
d1738 2
a1739 2
f_ungetc(self, c)
    VALUE self, c;
d2426 1
a2426 1
    rb_define_global_function("p", f_p, 1);
a2427 1
    rb_define_method(mKernel, "displayln", obj_displayln, -1);
a2444 1
    str_freeze(RS_default);	/* avoid modifying RS_default */
@


1.1.1.2.2.24
log
@1.1b9_11
@
text
@d6 1
a6 1
  $Date: 1998/04/16 07:42:43 $
d1494 20
d2439 1
@


1.1.1.2.2.25
log
@IO#binmode
@
text
@d6 1
a6 1
  $Date: 1998/04/16 10:41:53 $
d823 1
a823 1
    return io;
@


1.1.1.2.2.26
log
@use to_io
@
text
@d6 1
a6 1
  $Date: 1998/04/21 08:37:03 $
a269 7
static VALUE
io_to_io(io)
    VALUE io;
{
    return io;
}

a1163 11
static VALUE
io_get_io(io)
    VALUE io;
{
    if (TYPE(io) != T_FILE) {
	io = rb_funcall(io, rb_intern("to_io"), 0, 0);
	Check_Type(io, T_FILE);
    }
    return io;
}

d1193 1
a1193 1
    nfile = io_get_io(nfile);
d1830 2
a1831 3
	    VALUE io = io_get_io(RARRAY(read)->ptr[i]);

	    GetOpenFile(io, fptr);
d1852 2
a1853 3
	    VALUE io = io_get_io(RARRAY(write)->ptr[i]);

	    GetOpenFile(io, fptr);
d1870 2
a1871 3
	    VALUE io = io_get_io(RARRAY(except)->ptr[i]);

	    GetOpenFile(io, fptr);
a2241 6
arg_to_io()
{
    return file;
}

static VALUE
a2460 1
    rb_define_method(cIO, "to_io", io_to_io, 0);
a2509 1
    rb_define_singleton_method(argf, "to_io", arg_to_io, 0);
@


1.1.1.2.2.27
log
@tcltklib/gtk
@
text
@d6 1
a6 1
  $Date: 1998/04/23 06:53:17 $
d1175 5
a1179 1
    return rb_convert_type(io, T_FILE, "IO", "to_io");
@


1.1.1.2.2.28
log
@exception model changed
@
text
@d6 1
a6 1
  $Date: 1998/04/27 10:03:56 $
a2407 4
extern VALUE mKernel;
extern VALUE mEnumerable;
extern VALUE eStandardError;

d2411 5
a2415 2
    eIOError = rb_define_class("IOError", eStandardError);
    eEOFError = rb_define_class("EOFError", eIOError);
@


1.1.1.2.2.29
log
@1.1b9_18
@
text
@d6 1
a6 1
  $Date: 1998/05/01 08:56:32 $
a208 57
io_tell(io)
     VALUE io;
{
    OpenFile *fptr;
    long pos;

    GetOpenFile(io, fptr);
    pos = ftell(fptr->f);
    if (ferror(fptr->f) != 0) rb_sys_fail(fptr->path);

    return int2inum(pos);
}

static VALUE
io_seek(io, offset, ptrname)
     VALUE io, offset, ptrname;
{
    OpenFile *fptr;
    long pos;

    GetOpenFile(io, fptr);
    pos = fseek(fptr->f, NUM2INT(offset), NUM2INT(ptrname));
    if (pos != 0) rb_sys_fail(fptr->path);
    clearerr(fptr->f);

    return INT2FIX(0);
}

static VALUE
io_set_pos(io, offset)
     VALUE io, offset;
{
    OpenFile *fptr;
    long pos;

    GetOpenFile(io, fptr);
    pos = fseek(fptr->f, NUM2INT(offset), 0);
    if (pos != 0) rb_sys_fail(fptr->path);
    clearerr(fptr->f);

    return INT2NUM(pos);
}

static VALUE
io_rewind(io)
     VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    if (fseek(fptr->f, 0L, 0) != 0) rb_sys_fail(fptr->path);
    clearerr(fptr->f);

    return INT2FIX(0);
}

static VALUE
a1724 34
f_tell()
{
  return io_tell(file);
}

static VALUE
f_seek(self, offset, ptrname)
     VALUE self, offset, ptrname;
{
  if (!next_argv()) {
    ArgError("no stream to seek");
  }

  return io_seek(file, offset, ptrname);
}

static VALUE
f_set_pos(self, offset)
     VALUE self, offset;
{
  if (!next_argv()) {
    ArgError("no stream to pos");
  }

  return io_set_pos(file, offset);
}

static VALUE
f_rewind()
{
  return io_rewind(file);
}

static VALUE
a2428 5
    rb_define_global_function("tell", f_tell, 0);
    rb_define_global_function("seek", f_seek, 2);
    rb_define_global_function("rewind", f_rewind, 0);
    rb_define_global_function("pos", f_tell, 0);
    rb_define_global_function("pos=", f_set_pos, 1);
a2500 5
    rb_define_method(cIO, "tell", io_tell, 0);
    rb_define_method(cIO, "seek", io_seek, 2);
    rb_define_method(cIO, "rewind", io_rewind, 0);
    rb_define_method(cIO, "pos", io_tell, 0);
    rb_define_method(cIO, "pos=", io_set_pos, 1);
a2546 5
    rb_define_singleton_method(argf, "tell", f_tell, 0);
    rb_define_singleton_method(argf, "seek", f_seek, 2);
    rb_define_singleton_method(argf, "rewind", f_rewind, 0);
    rb_define_singleton_method(argf, "pos", f_tell, 0);
    rb_define_singleton_method(argf, "pos=", f_set_pos, 1);
@


1.1.1.2.2.30
log
@no INT,UINT
@
text
@d6 1
a6 1
  $Date: 1998/05/12 08:38:41 $
d162 1
a162 1
	register char *ptr = RSTRING(str)->ptr;
@


1.1.1.2.2.31
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/05/13 05:57:59 $
a55 11
#ifdef USE_CWGUSI
 #include <sys/errno.h>
 #include <unix.mac.h>
 #include <compat.h>
 extern void Init_File();
#endif

#ifdef __BEOS__
#include <net/socket.h>
#endif

a89 5
#    if defined(__BEOS__)
#      define ReadDataPending(fp) (fp->state._eof == 0)
#    elif defined(USE_CWGUSI)
#      define ReadDataPending(fp) (fp->state.eof == 0)
#    else
a91 1
#    endif
a356 4
#ifdef __BEOS__
    if (fstat(fileno(fptr->f), &st) == 0  && S_ISREG(st.st_mode)
		&& (st.st_dev > 3)) {
#else	
a357 1
#endif
d869 1
a869 1
#if defined(NT) || defined(DJGPP) || defined(__CYGWIN32__) || defined(__human68k__) || defined(USE_CWGUSI)
a878 1
# ifndef USE_CWGUSI
a882 6
# else  /* USE_CWGUSI */
	if (fptr->f)
		fptr->f->mode.binary_io = 1;
	if (fptr->f2)
		fptr->f2->mode.binary_io = 1;
# endif /* USE_CWGUSI */
a1048 1
#ifndef USE_CWGUSI
a1161 3
#else /* USE_CWGUSI */
	rb_notimplement();  
#endif
d1720 1
a1720 2
#if !defined(MSDOS) && !defined(__CYGWIN32__) && !(NT) && !defined(__human68k__)\
 && !defined(USE_CWGUSI) && !defined(__BEOS__)
d1727 1
a1727 1
		    rb_defout = prep_stdio(fw, FMODE_WRITABLE, cFile);
d1729 1
a1729 1
		file = prep_stdio(fr, FMODE_READABLE, cFile);
a2109 3
# ifdef USE_CWGUSI
    retval = io_p?ioctl(fd, cmd, (void*) narg):fcntl(fd, cmd, narg);
# else
a2110 1
# endif
d2309 1
a2309 1
    return rb_ensure(io_foreach_line, (VALUE)&arg, io_close, arg.io);
d2340 1
a2340 1
    return rb_ensure(io_readline_line, (VALUE)&arg, io_close, arg.io);
@


1.1.1.2.2.32
log
@ruby 1.1b9_20
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:20 $
d102 1
a102 1
#      define ReadDataPending(fp) (fp->_state._eof == 0)
@


1.1.1.2.2.33
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/15 05:43:21 $
d67 2
d84 3
d89 1
a89 1
struct timeval time_timeval _((VALUE));
@


1.1.1.2.2.34
log
@remove unused variables
@
text
@d6 1
a6 1
  $Date: 1998/05/18 04:56:05 $
d360 1
d1581 1
d1614 1
a1614 1
    OpenFile *fptr;
d2097 1
a2097 2
    int len = 0;
    int fd;
@


1.1.1.2.2.35
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 04:57:40 $
a85 5
static VALUE filename, file;
static int gets_lineno;
static int init_p = 0, next_p = 0;
static VALUE lineno;

d435 2
a624 32
io_lineno(io)
    VALUE io;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    io_readable(fptr);
    return INT2NUM(fptr->lineno);
}

static VALUE
io_set_lineno(io, lineno)
    VALUE io, lineno;
{
    OpenFile *fptr;

    GetOpenFile(io, fptr);
    io_readable(fptr);
    fptr->lineno = NUM2INT(lineno);
}

static void
lineno_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    gets_lineno = NUM2INT(val);
    *var = INT2FIX(gets_lineno);
}

static VALUE
d1249 1
a1249 1
	return rb_ensure(rb_yield, port, io_close, port);
d1666 4
d2593 1
a2593 1
    rb_define_hooked_variable("$.", &lineno, 0, lineno_setter);
a2616 3

    rb_define_method(cIO, "lineno",   io_lineno, 0);
    rb_define_method(cIO, "lineno=",  io_set_lineno, 1);
@


1.1.1.2.2.36
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 09:42:28 $
d68 1
d2561 4
@


1.1.1.2.2.37
log
@1.1b9_25
@
text
@d6 1
a6 1
  $Date: 1998/06/02 10:05:23 $
a291 1
#if 0
d293 1
a293 3
    return FALSE;
#else
    READ_CHECK(fptr->f);
a302 1
#endif
d392 2
a393 4
	if (n <= 0) {
	    if (ferror(fptr->f)) rb_sys_fail(fptr->path);
	    return Qnil;
	}
d428 3
a430 3
    if (n <= 0) {
	if (ferror(fptr->f)) rb_sys_fail(fptr->path);
	return Qnil;
d432 1
d524 1
a524 7
	    if (cnt == 0) {
		if (ferror(f)) rb_sys_fail(fptr->path);
		c = EOF;
	    }
	    else {
		c = 0;
	    }
a2166 1
    TRAP_BEG;
a2173 1
    TRAP_END;
a2251 1
    TRAP_BEG;
a2304 1
    TRAP_END;
@


1.1.1.2.2.38
log
@baseline
@
text
@d6 1
a6 1
  $Date: 1998/06/11 10:03:04 $
d14 1
a14 1
#include "rubyio.h"
d41 4
@


1.1.1.2.2.39
log
@1.1b9_26
@
text
@d6 1
a6 1
  $Date: 1998/06/16 04:23:33 $
d462 1
a462 5
    if (NIL_P(rs)) {
	rsptr = 0;
	rslen = 0;
    }
    else {
d475 4
@


1.1.1.2.2.40
log
@thread->thred
@
text
@d6 1
a6 1
  $Date: 1998/06/18 07:46:50 $
d112 1
a112 1
    if (!READ_DATA_PENDING(fp)) thred_wait_fd(fileno(fp));\
d884 1
a884 1
    thred_fd_writable(fileno(f));
d908 1
a908 1
    thred_wait_fd(fileno(fptr->f));
d1187 1
a1187 1
	    thred_sleep(1);
d2058 1
a2058 1
    n = thred_select(max, rp, wp, ep, tp);
@


1.1.1.2.2.41
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/24 04:37:59 $
a14 1
#include "rubysig.h"
d112 1
a112 1
    if (!READ_DATA_PENDING(fp)) thread_wait_fd(fileno(fp));\
d884 1
a884 1
    thread_fd_writable(fileno(f));
d908 1
a908 1
    thread_wait_fd(fileno(fptr->f));
d1187 1
a1187 1
	    thread_sleep(1);
d1247 2
a1248 5
	int len;

	mode = STR2CSTR(pmode);
	len = strlen(mode);
	if (len == 0 || len > 3)
d1250 1
d1282 2
a1283 5
	int len;

	mode = STR2CSTR(pmode);
	len = strlen(mode);
	if (len == 0 || len > 3)
d1285 1
d2058 1
a2058 1
    n = thread_select(max, rp, wp, ep, tp);
d2568 2
a2569 1
    inplace = STR2CSTR(val);
@


1.1.1.2.2.42
log
@1.1b9_29
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:25 $
d515 1
a515 4
		if (c == EOF) {
		    if (errno == EINTR) continue;
		    break;
		}
d602 1
a602 4
	if (c == EOF) {
	    if (errno == EINTR) continue;
	    break;
	}
d1602 3
a1604 3
void
rb_p(obj)			/* for debug print within C code */
    VALUE obj;
d1608 2
d1612 3
a1614 4
static VALUE
f_p(argc, argv)
    int argc;
    VALUE *argv;
d1616 1
a1616 6
    int i;

    for (i=0; i<argc; i++) {
	rb_p(argv[i]);
    }
    return Qnil;
d2610 1
a2610 1
    rb_define_global_function("p", f_p, -1);
@


1.1.1.2.2.43
log
@str2cstr
@
text
@d6 1
a6 1
  $Date: 1998/07/03 07:06:29 $
d1248 3
a1250 1
    if (rb_scan_args(argc, argv, "11", &pname, &pmode) == 1) {
d1260 1
a1260 2
    }
    Check_SafeStr(pname);
d1637 2
a1638 1
    if (rb_scan_args(argc, argv, "01", &out) == 0) {
d1713 3
a1715 1
    if (rb_scan_args(argc, argv, "11", &fnum, &mode) == 2) {
d1999 2
a2000 1
    if (rb_scan_args(argc, argv, "13", &read, &write, &except, &timeout)<4) {
d2579 1
a2579 1
    if (!RTEST(val)) {
@


1.1.1.2.2.44
log
@rehash
@
text
@d6 1
a6 1
  $Date: 1998/07/13 04:37:41 $
d2601 2
@


1.1.1.2.2.45
log
@1.1c1
@
text
@d6 1
a6 1
  $Date: 1998/07/22 03:00:42 $
d1330 1
@


1.1.1.2.2.46
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/07/24 04:41:57 $
d1994 1
a1994 2
    rb_scan_args(argc, argv, "13", &read, &write, &except, &timeout);
    if (NIL_P(timeout)) {
@


1.1.1.2.2.47
log
@1.1c3
@
text
@d6 1
a6 1
  $Date: 1998/08/11 04:06:28 $
d1844 1
a1844 1
    VALUE *argv;
d1932 1
a1932 1
    VALUE *argv;
d1991 1
a1991 1
    int interrupt_flag = 0;
d2082 1
a2082 1
	interrupt_flag = 1;
d2092 1
a2092 1
    if (interrupt_flag == 0) {
d2184 1
a2185 1
    TRAP_BEG;
d2191 1
a2192 1
#else
a2195 1
    TRAP_BEG;
a2196 1
    TRAP_END;
d2503 1
a2503 1
    VALUE *argv;
@


1.1.1.2.2.48
log
@1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/08/27 03:55:18 $
d1362 1
a1362 1
    if (fd < 3) {
d1364 1
a1364 2
	if (dup2(fileno(orig->f), fd) < 0)
	    rb_sys_fail(orig->path);
a1367 2
	if (dup2(fileno(orig->f), fd) < 0)
	    rb_sys_fail(orig->path);
d1375 1
a1375 2
	    if (dup2(fileno(orig->f2), fd) < 0)
		rb_sys_fail(orig->path);
@


1.1.1.2.2.49
log
@1.1c7
@
text
@d6 1
a6 1
  $Date: 1998/10/06 02:44:58 $
d373 1
a373 1
    str = str_new(0, siz);
d375 3
a377 2
#ifdef __BEOS__
	&& (st.st_dev > 3)
d379 1
a379 3
	)
    {
	if (st.st_size == 0) return str_new(0, 0);
d387 1
d395 1
a395 1
	    return str_new(0, 0);
d402 1
a402 1
    if (bytes == 0) return str_new(0, 0);
d417 1
a417 1
    if (rb_scan_args(argc, argv, "01", &length) == 0 || NIL_P(length)) {
d2040 1
a2040 1
	    if (max < fileno(fptr->f)) max = fileno(fptr->f);
d2043 1
a2043 1
		if (max < fileno(fptr->f2)) max = fileno(fptr->f2);
d2062 1
a2062 1
		if (max < fileno(fptr->f2)) max = fileno(fptr->f2);
@


1.1.1.2.2.50
log
@1.1c9 - 1.1c final, hopefully
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:49 $
d373 1
a387 1
    str = str_new(0, siz);
d2458 1
a2458 1
    if ((NIL_P(tmp)  || RSTRING(tmp)->len == 0) && next_p != -1) {
d2463 1
a2463 1
    if (NIL_P(tmp) || RSTRING(tmp)->len == 0) return str;
@


1.1.1.2.2.51
log
@1.2.4
@
text
@d6 1
a6 1
  $Date: 1998/11/26 08:25:44 $
a60 3
# ifdef _X86_
#  define NOFILE (OPEN_MAX)
# endif
d2013 3
a2015 1
	    GetOpenFile(io_get_io(RARRAY(read)->ptr[i]), fptr);
d2036 3
a2038 1
	    GetOpenFile(io_get_io(RARRAY(write)->ptr[i]), fptr);
d2055 3
a2057 1
	    GetOpenFile(io_get_io(RARRAY(except)->ptr[i]), fptr);
d2100 1
a2100 1
		GetOpenFile(io_get_io(RARRAY(read)->ptr[i]), fptr);
d2111 1
a2111 1
		GetOpenFile(io_get_io(RARRAY(write)->ptr[i]), fptr);
d2124 1
a2124 1
		GetOpenFile(io_get_io(RARRAY(except)->ptr[i]), fptr);
@


1.1.1.2.2.52
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/04/08 10:14:32 $
d1747 2
a1748 2
	    fn = STR2CSTR(filename);
	    if (strlen(fn) == 1 && fn[0] == '-') {
@


1.1.1.2.2.53
log
@1.2.5 pre
@
text
@d6 1
a6 1
  $Date: 1999/04/09 18:04:07 $
a1346 1
    if (fptr == orig) return io;
@


1.1.1.2.2.54
log
@to open CVS
@
text
@d6 1
a6 1
  $Date: 1999/04/13 05:54:23 $
a1301 1
    if (NIL_P(port)) return Qnil;
d1316 4
d1661 1
a1661 1
	TypeError("$> must have write method, %s given",
a1971 2
    if (NIL_P(port)) return Qnil;

a2395 1
    if (NIL_P(arg.io)) return Qnil;
a2426 1
    if (NIL_P(arg.io)) return Qnil;
@


1.1.1.2.2.55
log
@1.2.6
@
text
@d6 1
a6 1
  $Date: 1999/04/20 08:20:54 $
d2329 2
a2330 2
    if (retval < 0) rb_sys_fail(0);
    return INT2NUM(retval);
@


1.1.1.2.2.47.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/08/27 03:55:18 $
d64 3
a66 3
VALUE rb_cIO;
VALUE rb_eEOFError;
VALUE rb_eIOError;
d70 3
a72 5
VALUE rb_fs;
VALUE rb_output_fs;
VALUE rb_rs;
VALUE rb_output_rs;
VALUE rb_default_rs;
d76 1
a76 1
static ID id_write;
d78 1
a78 1
extern char *ruby_inplace_mode;
d80 1
a80 1
struct timeval rb_time_timeval _((VALUE));
a92 6
#elif defined(FILE_COUNT)
#  define READ_DATA_PENDING(fp) ((fp)->FILE_COUNT > 0)
#elif defined(__BEOS__)
#  define ReadDataPending(fp) (fp->_state._eof == 0)
#elif defined(USE_CWGUSI)
#  define ReadDataPending(fp) (fp->state.eof == 0)
d94 8
d104 3
a106 1
#  define READ_DATA_PENDING(fp) ReadDataPending(fp)
d113 1
a113 1
    if (!READ_DATA_PENDING(fp)) rb_thread_wait_fd(fileno(fp));\
d118 1
a118 1
rb_eof_error()
d120 1
a120 1
    rb_raise(rb_eEOFError, "End of file reached");
d124 1
a124 1
rb_io_check_closed(fptr)
d128 1
a128 1
	rb_raise(rb_eIOError, "closed stream");
d132 1
a132 1
rb_io_check_readable(fptr)
d136 1
a136 1
	rb_raise(rb_eIOError, "not opened for reading");
d141 1
a141 1
rb_io_check_writable(fptr)
d145 1
a145 1
	rb_raise(rb_eIOError, "not opened for writing");
d151 1
a151 1
rb_io_write(io, str)
d159 1
a159 1
	str = rb_obj_as_string(str);
d169 1
a169 1
    rb_io_check_writable(fptr);
d198 1
a198 1
rb_io_addstr(io, str)
d201 1
a201 1
    rb_io_write(io, str);
d206 1
a206 1
rb_io_flush(io)
d213 1
a213 1
    rb_io_check_writable(fptr);
d222 1
a222 1
rb_io_tell(io)
d232 1
a232 1
    return rb_int2inum(pos);
d236 1
a236 1
rb_io_seek(io, offset, ptrname)
d251 1
a251 1
rb_io_set_pos(io, offset)
d266 1
a266 1
rb_io_rewind(io)
d279 1
a279 1
rb_io_eof(io)
d286 1
a286 1
    rb_io_check_readable(fptr);
d288 1
a288 1
    if (READ_DATA_PENDING(fptr->f)) return Qfalse;
d290 2
a291 2
    if (feof(fptr->f)) return Qtrue;
    return Qfalse;
d300 1
a300 1
	return Qfalse;
d302 1
a302 1
    return Qtrue;
d307 1
a307 1
rb_io_sync(io)
d313 1
a313 1
    return (fptr->mode & FMODE_SYNC) ? Qtrue : Qfalse;
d317 1
a317 1
rb_io_set_sync(io, mode)
d333 1
a333 1
rb_io_fileno(io)
d345 1
a345 1
rb_io_to_io(io)
d371 1
a371 1
    rb_io_check_readable(fptr);
d387 1
a387 1
    str = rb_str_new(0, siz);
d400 1
a400 1
	rb_str_resize(str, siz);
d403 2
a404 2
    if (bytes != siz) rb_str_resize(str, bytes);
    return rb_str_taint(str);
d408 1
a408 1
rb_io_read(argc, argv, io)
d423 1
a423 1
    rb_io_check_readable(fptr);
d425 1
a425 1
    str = rb_str_new(0, len);
d438 1
a438 1
    return rb_str_taint(str);
d442 1
a442 1
rb_io_gets_method(argc, argv, io)
d456 1
a456 1
	rs = rb_rs;
d475 1
a475 1
	    return rb_io_gets(io);
d483 1
a483 1
    rb_io_check_readable(fptr);
d544 1
a544 1
	    rb_str_cat(str, buf, cnt);
d546 1
a546 1
	    str = rb_str_new(buf, cnt);
d574 1
a574 1
	rb_str_taint(str);
d576 1
a576 1
    rb_lastline_set(str);
d582 1
a582 1
rb_io_gets(io)
d595 1
a595 1
    rb_io_check_readable(fptr);
d620 1
a620 1
	rb_str_cat(str, buf, cnt);
d622 1
a622 1
	str = rb_str_new(buf, cnt);
d633 1
a633 1
	rb_str_taint(str);
d635 1
a635 1
    rb_lastline_set(str);
d641 1
a641 1
rb_io_lineno(io)
d647 1
a647 1
    rb_io_check_readable(fptr);
d652 1
a652 1
rb_io_set_lineno(io, lineno)
d658 1
a658 1
    rb_io_check_readable(fptr);
d673 1
a673 1
rb_io_readline(argc, argv, io)
d678 1
a678 1
    VALUE line = rb_io_gets_method(argc, argv, io);
d681 1
a681 1
	rb_eof_error();
d687 1
a687 1
rb_io_readlines(argc, argv, io)
d694 3
a696 3
    ary = rb_ary_new();
    while (!NIL_P(line = rb_io_gets_method(argc, argv, io))) {
	rb_ary_push(ary, line);
d702 1
a702 1
rb_io_each_line(argc, argv, io)
d709 1
a709 1
    while (!NIL_P(str = rb_io_gets_method(argc, argv, io))) {
d716 1
a716 1
rb_io_each_byte(io)
d724 1
a724 1
    rb_io_check_readable(fptr);
d740 1
a740 1
rb_io_getc(io)
d748 1
a748 1
    rb_io_check_readable(fptr);
d764 1
a764 1
rb_io_readchar(io)
d767 1
a767 1
    VALUE c = rb_io_getc(io);
d770 1
a770 1
	rb_eof_error();
d776 1
a776 1
rb_io_ungetc(io, c)
d783 1
a783 1
    rb_io_check_readable(fptr);
d791 1
a791 1
rb_io_isatty(io)
d798 2
a799 2
	return Qfalse;
    return Qtrue;
d819 1
a819 1
rb_io_fptr_close(fptr)
d834 1
a834 1
rb_io_fptr_finalize(fptr)
d837 1
a837 1
    rb_io_fptr_close(fptr);
d845 1
a845 1
rb_io_close(io)
a849 1
    rb_secure(4);
d851 1
a851 1
    rb_io_fptr_close(fptr);
d856 8
d865 1
a865 1
rb_io_closed(io)
d871 1
a871 1
    return (fptr->f || fptr->f2)?Qfalse:Qtrue;
d875 1
a875 1
rb_io_syswrite(io, str)
d884 1
a884 1
	str = rb_obj_as_string(str);
d887 1
a887 1
    rb_io_check_writable(fptr);
d891 1
a891 1
    rb_thread_fd_writable(fileno(f));
d901 1
a901 1
rb_io_sysread(io, len)
d910 1
a910 1
    rb_io_check_readable(fptr);
d912 1
a912 1
    str = rb_str_new(0, ilen);
d915 1
a915 1
    rb_thread_wait_fd(fileno(fptr->f));
d922 1
a922 1
    if (n == 0) rb_eof_error();
d926 1
a926 1
    return rb_str_taint(str);
d930 1
a930 1
rb_io_binmode(io)
d950 1
a950 1
		fptr->f->mode.binrb_ary_io = 1;
d952 1
a952 1
		fptr->f2->mode.binrb_ary_io = 1;
d962 1
a962 1
rb_io_mode_flags(mode)
d978 1
a978 1
	rb_raise(rb_eArgError, "illegal access mode");
d1003 1
a1003 1
	    rb_gc();
d1082 1
a1082 1
	rb_io_fptr_finalize(list->fptr);
d1107 1
a1107 1
rb_io_unbuffered(fptr)
d1110 1
a1110 1
    if (fptr->f2 == 0) rb_raise(rb_eTypeError, "non-writable fptr");
d1121 1
a1121 1
    int modef = rb_io_mode_flags(mode);
d1130 1
a1130 1
	OBJSETUP(port, rb_cIO, T_FILE);
d1139 1
a1139 1
	    rb_io_unbuffered(fptr);
d1141 1
a1141 1
	rb_obj_call_init((VALUE)port);
d1178 2
a1179 2
	    extern char *ruby_sourcefile;
	    extern int   ruby_sourceline;
d1186 1
a1186 1
		    ruby_sourcefile, ruby_sourceline, pname);
d1194 1
a1194 1
	    rb_thread_sleep(1);
d1208 1
a1208 1
	    OBJSETUP(port, rb_cIO, T_FILE);
d1229 1
a1229 1
	    rb_obj_call_init((VALUE)port);
d1240 1
a1240 1
rb_io_s_popen(argc, argv, self)
d1257 1
a1257 1
	    rb_raise(rb_eArgError, "illegal access mode");
d1264 1
a1264 1
rb_io_open(fname, mode)
d1271 1
a1271 1
	return rb_file_open(fname, mode);
d1276 1
a1276 1
rb_f_open(argc, argv)
d1295 1
a1295 1
	    rb_raise(rb_eArgError, "illegal access mode");
d1298 3
a1300 3
    port = rb_io_open(RSTRING(pname)->ptr, mode);
    if (rb_iterator_p()) {
	return rb_ensure(rb_yield, port, rb_io_close, port);
d1307 1
a1307 1
rb_io_get_io(io)
d1313 4
d1318 1
a1318 1
rb_io_mode_string(fptr)
d1333 1
a1333 1
rb_io_reopen(io, nfile)
d1341 1
a1341 1
    nfile = rb_io_get_io(nfile);
d1360 1
a1360 1
    mode = rb_io_mode_string(fptr);
d1384 1
a1384 1
	rb_io_binmode(io);
d1392 1
a1392 1
rb_io_clone(io)
d1437 1
a1437 1
	rb_io_binmode((VALUE)obj);
d1444 1
a1444 1
rb_io_printf(argc, argv, out)
d1449 1
a1449 1
    rb_funcall(out, id_write, 1, rb_f_sprintf(argc, argv));
d1455 1
a1455 1
rb_rb_f_printf(argc, argv)
d1471 1
a1471 1
	rb_raise(rb_eNameError, "output must responds to `write'");
d1473 1
a1473 1
    rb_funcall(out, id_write, 1, rb_f_sprintf(argc, argv));
d1479 1
a1479 1
rb_io_print(argc, argv, out)
d1490 1
a1490 1
	line = rb_lastline_get();
d1494 2
a1495 2
	if (!NIL_P(rb_output_fs) && i>0) {
	    rb_io_write(out, rb_output_fs);
d1499 1
a1499 1
	    rb_io_write(out, rb_str_new2("nil"));
d1503 2
a1504 2
		if (!NIL_P(rb_output_fs) && j>0) {
		    rb_io_write(out, rb_output_fs);
d1506 1
a1506 1
		rb_io_write(out, RARRAY(argv[i])->ptr[j]);
d1510 1
a1510 1
	    rb_io_write(out, argv[i]);
d1514 2
a1515 2
    if (!NIL_P(rb_output_rs)) {
	rb_io_write(out, rb_output_rs);
d1522 1
a1522 1
rb_f_print(argc, argv)
d1526 1
a1526 1
    rb_io_print(argc, argv, rb_defout);
d1531 1
a1531 1
rb_io_putc(io, ch)
d1540 1
a1540 1
    rb_io_check_writable(fptr);
d1553 1
a1553 1
rb_f_putc(recv, ch)
d1556 1
a1556 1
    return rb_io_putc(rb_defout, ch);
d1560 1
a1560 1
rb_io_puts(argc, argv, out)
d1570 1
a1570 1
	rb_io_write(out, rb_default_rs);
d1576 1
a1576 1
	    line = rb_str_new2("nil");
d1580 1
a1580 1
		rb_io_puts(1, &RARRAY(argv[i])->ptr[j], out);
d1587 2
a1588 2
	line = rb_obj_as_string(line);
	rb_io_write(out, line);
d1590 1
a1590 1
	    rb_io_write(out, rb_default_rs);
d1598 1
a1598 1
rb_f_puts(argc, argv)
d1602 1
a1602 1
    rb_io_puts(argc, argv, rb_defout);
d1610 2
a1611 2
    rb_io_write(rb_defout, rb_inspect(obj));
    rb_io_write(rb_defout, rb_default_rs);
d1615 1
a1615 1
rb_f_p(argc, argv)
d1628 1
a1628 1
rb_obj_display(argc, argv, self)
d1639 1
a1639 1
    rb_io_write(out, self);
d1645 1
a1645 1
rb_io_defset(val, id)
d1650 1
a1650 1
	val = rb_io_open(RSTRING(val)->ptr, "w");
d1653 2
a1654 2
	rb_raise(rb_eTypeError, "$< must have write method, %s given",
		 rb_class2name(CLASS_OF(val)));
d1660 1
a1660 1
rb_io_stdio_set(val, id, var)
d1669 1
a1669 1
	rb_raise(rb_eTypeError, "%s must be IO object", rb_id2name(id));
d1675 1
a1675 1
	rb_io_check_readable(fptr);
d1678 1
a1678 1
	rb_io_check_writable(fptr);
d1680 1
a1680 1
    rb_io_reopen(*var, val);
d1696 1
a1696 1
    rb_obj_call_init((VALUE)io);
d1702 1
a1702 1
rb_io_s_new(argc, argv, klass)
d1714 1
a1714 1
    return prep_stdio(rb_fdopen(NUM2INT(fnum), m), rb_io_mode_flags(m), klass);
d1739 1
a1739 1
	    filename = rb_ary_shift(rb_argv);
d1743 1
a1743 1
		if (ruby_inplace_mode) {
d1750 1
a1750 1
		if (ruby_inplace_mode) {
d1756 1
a1756 1
			rb_io_close(rb_defout);
d1759 2
a1760 2
		    if (*ruby_inplace_mode) {
			str = rb_str_new2(fn);
d1762 1
a1762 1
			add_suffix(str, ruby_inplace_mode);
d1764 1
a1764 2
			rb_str_cat(str, ruby_inplace_mode,
				   strlen(ruby_inplace_mode));
d1773 2
a1774 2
			    rb_warn("Can't rename %s to %s: %s, skipping file",
				    fn, RSTRING(str)->ptr, strerror(errno));
d1783 2
a1784 2
			    rb_warn("Can't remove %s: %s, skipping file",
				    fn, strerror(errno));
d1789 1
a1789 1
			rb_fatal("Can't do inplace edit without backup");
d1801 1
a1801 1
		    rb_defout = prep_stdio(fw, FMODE_WRITABLE, rb_cFile);
d1803 1
a1803 1
		file = prep_stdio(fr, FMODE_READABLE, rb_cFile);
d1808 1
a1808 1
	    return Qfalse;
d1811 1
a1811 1
    return Qtrue;
d1815 1
a1815 1
rb_f_gets_method(argc, argv)
d1823 1
a1823 1
    line = rb_io_gets_method(argc, argv, file);
d1825 1
a1825 1
	rb_io_close(file);
d1836 1
a1836 1
rb_f_gets()
d1838 1
a1838 14
    VALUE line;

  retry:
    if (!next_argv()) return Qnil;
    line = rb_io_gets(file);
    if (NIL_P(line) && next_p != -1) {
	rb_io_close(file);
	next_p = 1;
	goto retry;
    }
    gets_lineno++;
    lineno = INT2FIX(gets_lineno);

    return line;
d1842 1
a1842 1
rb_f_readline(argc, argv)
d1846 1
a1846 1
    VALUE line = rb_f_gets_method(argc, argv);
d1849 1
a1849 1
	rb_eof_error();
d1856 1
a1856 1
rb_f_tell()
d1858 1
a1858 1
  return rb_io_tell(file);
d1862 1
a1862 1
rb_f_seek(self, offset, ptrname)
d1866 1
a1866 1
    rb_raise(rb_eArgError, "no stream to seek");
d1869 1
a1869 1
  return rb_io_seek(file, offset, ptrname);
d1873 1
a1873 1
rb_f_set_pos(self, offset)
d1877 1
a1877 1
    rb_raise(rb_eArgError, "no stream to pos");
d1880 1
a1880 1
  return rb_io_set_pos(file, offset);
d1884 1
a1884 1
rb_f_rewind()
d1886 1
a1886 1
  return rb_io_rewind(file);
d1890 1
a1890 1
rb_f_eof()
d1893 2
a1894 2
	return Qtrue;
    if (rb_io_eof(file)) {
d1896 1
a1896 1
	return Qtrue;
d1898 1
a1898 1
    return Qfalse;
d1902 1
a1902 1
rb_f_getc()
d1904 1
a1904 1
    return rb_io_getc(rb_stdin);
d1908 1
a1908 1
rb_f_ungetc(self, c)
d1912 1
a1912 1
	rb_raise(rb_eArgError, "no stream to ungetc");
d1915 1
a1915 1
    return rb_io_ungetc(file, c);
d1919 1
a1919 1
rb_f_readchar()
d1921 1
a1921 1
    VALUE c = rb_f_getc();
d1924 1
a1924 1
	rb_eof_error();
d1930 1
a1930 1
rb_f_readlines(argc, argv)
d1936 3
a1938 3
    ary = rb_ary_new();
    while (!NIL_P(line = rb_f_gets_method(argc, argv))) {
	rb_ary_push(ary, line);
d1951 1
a1951 1
	rb_raise(rb_eTypeError, "value of %s must be String", rb_id2name(id));
d1957 1
a1957 1
rb_f_backquote(obj, str)
d1966 1
a1966 1
    rb_io_close(port);
d1968 1
a1968 1
    if (NIL_P(result)) return rb_str_new(0,0);
d1980 1
a1980 1
rb_f_select(argc, argv, obj)
d1999 1
a1999 1
	timerec = rb_time_timeval(timeout);
d2009 1
a2009 1
	    VALUE io = rb_io_get_io(RARRAY(read)->ptr[i]);
d2032 1
a2032 1
	    VALUE io = rb_io_get_io(RARRAY(write)->ptr[i]);
d2051 1
a2051 1
	    VALUE io = rb_io_get_io(RARRAY(except)->ptr[i]);
d2068 1
a2068 1
    n = rb_thread_select(max, rp, wp, ep, tp);
d2087 4
a2090 4
    res = rb_ary_new2(3);
    rb_ary_push(res, rp?rb_ary_new():rb_ary_new2(0));
    rb_ary_push(res, wp?rb_ary_new():rb_ary_new2(0));
    rb_ary_push(res, ep?rb_ary_new():rb_ary_new2(0));
d2099 1
a2099 1
		    rb_ary_push(list, RARRAY(read)->ptr[i]);
d2109 1
a2109 1
		    rb_ary_push(list, RARRAY(write)->ptr[i]);
d2112 1
a2112 1
		    rb_ary_push(list, RARRAY(write)->ptr[i]);
d2122 1
a2122 1
		    rb_ary_push(list, RARRAY(except)->ptr[i]);
d2125 1
a2125 1
		    rb_ary_push(list, RARRAY(except)->ptr[i]);
d2135 1
a2135 1
rb_io_ctl(io, req, arg, io_p)
d2150 1
a2150 1
    if (NIL_P(arg) || arg == Qfalse) {
d2156 1
a2156 1
    else if (arg == Qtrue) {
d2172 1
a2172 1
	rb_str_modify(arg);
d2178 1
a2178 1
	    rb_str_resize(arg, len+1);
d2193 1
a2193 1
    if (!rb_io_p) {
d2202 1
a2202 1
	rb_raise(rb_eArgError, "return value overflowed string");
d2211 1
a2211 1
rb_io_ioctl(argc, argv, io)
d2219 1
a2219 1
    return rb_io_ctl(io, req, arg, 1);
d2223 1
a2223 1
rb_io_fcntl(argc, argv, io)
d2232 1
a2232 1
    return rb_io_ctl(io, req, arg, 0);
d2239 1
a2239 1
rb_f_syscall(argc, argv)
d2260 1
a2260 1
	rb_raise(rb_eArgError, "too few arguments for syscall");
d2268 1
a2268 1
	    rb_str_modify(*argv);
d2336 1
a2336 1
rb_io_s_pipe()
d2349 2
a2350 2
    r = prep_stdio(fdopen(pipes[0], "r"), FMODE_READABLE, rb_cIO);
    w = prep_stdio(fdopen(pipes[1], "w"), FMODE_WRITABLE, rb_cIO);
d2352 3
a2354 3
    ary = rb_ary_new2(2);
    rb_ary_push(ary, r);
    rb_ary_push(ary, w);
d2369 1
a2369 1
rb_io_foreach_line(arg)
d2374 1
a2374 1
    while (!NIL_P(str = rb_io_gets_method(arg->argc, &arg->sep, arg->io))) {
d2381 1
a2381 1
rb_io_s_foreach(argc, argv, io)
d2393 2
a2394 2
    arg.io = rb_io_open(RSTRING(fname)->ptr, "r");
    return rb_ensure(rb_io_foreach_line, (VALUE)&arg, rb_io_close, arg.io);
d2398 1
a2398 1
rb_io_readline_line(arg)
d2403 3
a2405 3
    ary = rb_ary_new();
    while (!NIL_P(line = rb_io_gets_method(arg->argc, &arg->sep, arg->io))) {
	rb_ary_push(ary, line);
d2412 1
a2412 1
rb_io_s_readlines(argc, argv, io)
d2424 2
a2425 2
    arg.io = rb_io_open(RSTRING(fname)->ptr, "r");
    return rb_ensure(rb_io_readline_line, (VALUE)&arg, rb_io_close, arg.io);
d2431 1
a2431 1
    return rb_io_fileno(file);
d2453 1
a2453 1
    tmp = rb_io_read(argc, argv, file);
d2455 1
a2455 1
	rb_io_close(file);
d2461 1
a2461 1
    else rb_str_cat(str, RSTRING(tmp)->ptr, RSTRING(tmp)->len);
d2481 1
a2481 1
    byte = rb_io_getc(file);
d2483 1
a2483 1
	rb_io_close(file);
d2494 1
a2494 1
    VALUE c = rb_io_getc(file);
d2497 1
a2497 1
	rb_eof_error();
d2509 1
a2509 1
    while (RTEST(str = rb_f_gets_method(argc, argv))) {
d2542 1
a2542 1
	rb_io_close(file);
d2551 1
a2551 1
    rb_io_close(file);
d2562 1
a2562 1
    return rb_io_closed(file);
d2568 2
a2569 2
    if (!ruby_inplace_mode) return Qnil;
    return rb_str_new2(ruby_inplace_mode);
d2577 1
a2577 1
	ruby_inplace_mode = 0;
d2580 1
a2580 1
    ruby_inplace_mode = STR2CSTR(val);
d2586 2
a2587 2
    rb_eIOError = rb_define_class("IOError", rb_eStandardError);
    rb_eEOFError = rb_define_class("EOFError", rb_eIOError);
d2591 1
a2591 1
    rb_define_global_function("syscall", rb_f_syscall, -1);
d2593 45
a2637 45
    rb_define_global_function("open", rb_f_open, -1);
    rb_define_global_function("printf", rb_rb_f_printf, -1);
    rb_define_global_function("print", rb_f_print, -1);
    rb_define_global_function("putc", rb_f_putc, 1);
    rb_define_global_function("puts", rb_f_puts, -1);
    rb_define_global_function("gets", rb_f_gets_method, -1);
    rb_define_global_function("readline", rb_f_readline, -1);
    rb_define_global_function("tell", rb_f_tell, 0);
    rb_define_global_function("seek", rb_f_seek, 2);
    rb_define_global_function("rewind", rb_f_rewind, 0);
    rb_define_global_function("eof", rb_f_eof, 0);
    rb_define_global_function("eof?", rb_f_eof, 0);
    rb_define_global_function("getc", rb_f_getc, 0);
    rb_define_global_function("readchar", rb_f_readchar, 0);
    rb_define_global_function("select", rb_f_select, -1);
    rb_define_global_function("ungetc", rb_f_ungetc, 1);

    rb_define_global_function("readlines", rb_f_readlines, -1);

    rb_define_global_function("`", rb_f_backquote, 1);
    rb_define_global_function("pipe", rb_io_s_pipe, 0);

    rb_define_global_function("p", rb_f_p, -1);
    rb_define_method(rb_mKernel, "display", rb_obj_display, -1);

    rb_cIO = rb_define_class("IO", rb_cObject);
    rb_include_module(rb_cIO, rb_mEnumerable);

    rb_define_singleton_method(rb_cIO, "new", rb_io_s_new, -1);
    rb_define_singleton_method(rb_cIO, "popen", rb_io_s_popen, -1);
    rb_define_singleton_method(rb_cIO, "foreach", rb_io_s_foreach, -1);
    rb_define_singleton_method(rb_cIO, "readlines", rb_io_s_readlines, -1);
    rb_define_singleton_method(rb_cIO, "select", rb_f_select, -1);

    rb_fs = rb_output_fs = Qnil;
    rb_define_hooked_variable("$;", &rb_fs, 0, rb_str_setter);
    rb_define_hooked_variable("$-F", &rb_fs, 0, rb_str_setter);
    rb_define_hooked_variable("$,", &rb_output_fs, 0, rb_str_setter);

    rb_rs = rb_default_rs = rb_str_new2("\n"); rb_output_rs = Qnil;
    rb_global_variable(&rb_default_rs);
    rb_str_freeze(rb_default_rs);	/* avoid modifying RS_default */
    rb_define_hooked_variable("$/", &rb_rs, 0, rb_str_setter);
    rb_define_hooked_variable("$-0", &rb_rs, 0, rb_str_setter);
    rb_define_hooked_variable("$\\", &rb_output_rs, 0, rb_str_setter);
d2640 1
a2640 1
    rb_define_virtual_variable("$_", rb_lastline_get, rb_lastline_set);
d2642 2
a2643 2
    rb_define_method(rb_cIO, "clone", rb_io_clone, 0);
    rb_define_method(rb_cIO, "reopen", rb_io_reopen, 1);
d2645 57
a2701 57
    rb_define_method(rb_cIO, "print", rb_io_print, -1);
    rb_define_method(rb_cIO, "putc", rb_io_putc, 1);
    rb_define_method(rb_cIO, "puts", rb_io_puts, -1);
    rb_define_method(rb_cIO, "printf", rb_io_printf, -1);

    rb_define_method(rb_cIO, "each",  rb_io_each_line, -1);
    rb_define_method(rb_cIO, "each_line",  rb_io_each_line, -1);
    rb_define_method(rb_cIO, "each_byte",  rb_io_each_byte, 0);

    rb_define_method(rb_cIO, "syswrite", rb_io_syswrite, 1);
    rb_define_method(rb_cIO, "sysread",  rb_io_sysread, 1);

    rb_define_method(rb_cIO, "fileno", rb_io_fileno, 0);
    rb_define_alias(rb_cIO, "to_i", "fileno");
    rb_define_method(rb_cIO, "to_io", rb_io_to_io, 0);

    rb_define_method(rb_cIO, "sync",   rb_io_sync, 0);
    rb_define_method(rb_cIO, "sync=",  rb_io_set_sync, 1);

    rb_define_method(rb_cIO, "lineno",   rb_io_lineno, 0);
    rb_define_method(rb_cIO, "lineno=",  rb_io_set_lineno, 1);

    rb_define_method(rb_cIO, "readlines",  rb_io_readlines, -1);

    rb_define_method(rb_cIO, "read",  rb_io_read, -1);
    rb_define_method(rb_cIO, "write", rb_io_write, 1);
    rb_define_method(rb_cIO, "gets",  rb_io_gets_method, -1);
    rb_define_method(rb_cIO, "readline",  rb_io_readline, -1);
    rb_define_method(rb_cIO, "getc",  rb_io_getc, 0);
    rb_define_method(rb_cIO, "readchar",  rb_io_readchar, 0);
    rb_define_method(rb_cIO, "ungetc",rb_io_ungetc, 1);
    rb_define_method(rb_cIO, "<<",    rb_io_addstr, 1);
    rb_define_method(rb_cIO, "flush", rb_io_flush, 0);
    rb_define_method(rb_cIO, "tell", rb_io_tell, 0);
    rb_define_method(rb_cIO, "seek", rb_io_seek, 2);
    rb_define_method(rb_cIO, "rewind", rb_io_rewind, 0);
    rb_define_method(rb_cIO, "pos", rb_io_tell, 0);
    rb_define_method(rb_cIO, "pos=", rb_io_set_pos, 1);
    rb_define_method(rb_cIO, "eof", rb_io_eof, 0);
    rb_define_method(rb_cIO, "eof?", rb_io_eof, 0);

    rb_define_method(rb_cIO, "close", rb_io_close, 0);
    rb_define_method(rb_cIO, "closed?", rb_io_closed, 0);

    rb_define_method(rb_cIO, "isatty", rb_io_isatty, 0);
    rb_define_method(rb_cIO, "tty?", rb_io_isatty, 0);
    rb_define_method(rb_cIO, "binmode",  rb_io_binmode, 0);

    rb_define_method(rb_cIO, "ioctl", rb_io_ioctl, -1);
    rb_define_method(rb_cIO, "fcntl", rb_io_fcntl, -1);

    rb_stdin = prep_stdio(stdin, FMODE_READABLE, rb_cIO);
    rb_define_hooked_variable("$stdin", &rb_stdin, 0, rb_io_stdio_set);
    rb_stdout = prep_stdio(stdout, FMODE_WRITABLE, rb_cIO);
    rb_define_hooked_variable("$stdout", &rb_stdout, 0, rb_io_stdio_set);
    rb_stderr = prep_stdio(stderr, FMODE_WRITABLE, rb_cIO);
    rb_define_hooked_variable("$stderr", &rb_stderr, 0, rb_io_stdio_set);
d2703 1
a2703 1
    rb_define_hooked_variable("$>", &rb_defout, 0, rb_io_defset);
d2709 2
a2710 2
    argf = rb_obj_alloc(rb_cObject);
    rb_extend_object(argf, rb_mEnumerable);
d2723 4
a2726 4
    rb_define_singleton_method(argf, "readlines", rb_f_readlines, -1);
    rb_define_singleton_method(argf, "to_a", rb_f_readlines, -1);
    rb_define_singleton_method(argf, "gets", rb_f_gets_method, -1);
    rb_define_singleton_method(argf, "readline", rb_f_readline, -1);
d2729 8
a2736 8
    rb_define_singleton_method(argf, "tell", rb_f_tell, 0);
    rb_define_singleton_method(argf, "seek", rb_f_seek, 2);
    rb_define_singleton_method(argf, "rewind", rb_f_rewind, 0);
    rb_define_singleton_method(argf, "pos", rb_f_tell, 0);
    rb_define_singleton_method(argf, "pos=", rb_f_set_pos, 1);
    rb_define_singleton_method(argf, "eof", rb_f_eof, 0);
    rb_define_singleton_method(argf, "eof?", rb_f_eof, 0);
    rb_define_singleton_method(argf, "ungetc", rb_f_ungetc, 1);
d2745 1
a2745 1
    filename = rb_str_new2("-");
@


1.1.1.2.2.47.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/10/06 02:44:58 $
d107 1
a107 1
#ifndef USE_THREAD
d168 1
d439 2
a440 2
static VALUE
rb_io_gets_internal(argc, argv, io)
d574 1
d633 1
a638 14
rb_io_gets_method(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE str = rb_io_gets_internal(argc, argv, io);

    if (!NIL_P(str)) {
	rb_lastline_set(str);
    }
    return str;
}

static VALUE
d693 1
a693 1
    while (!NIL_P(line = rb_io_gets_internal(argc, argv, io))) {
d707 1
a707 1
    while (!NIL_P(str = rb_io_gets_internal(argc, argv, io))) {
d848 1
a855 9
rb_io_close_method(io)
    VALUE io;
{
    rb_secure(4);
    rb_io_close(io);
    return Qnil;
}

static VALUE
a864 45
VALUE
rb_io_close_read(io)
    VALUE io;
{
    OpenFile *fptr;
    FILE *save;

    rb_secure(4);
    GetOpenFile(io, fptr);
    if (fptr->f2 == 0 && (fptr->mode & FMODE_WRITABLE)) {
	rb_raise(rb_eIOError, "closing non-duplex IO for reading");
    }
    if (fptr->f2 == 0) {
	return rb_io_close(io);
    }
    fclose(fptr->f);
    fptr->mode &= ~FMODE_READABLE;
    fptr->f = fptr->f2;
    fptr->f2 = 0;

    return Qnil;
}

static VALUE
rb_io_close_write(io)
    VALUE io;
{
    OpenFile *fptr;
    FILE *save = 0;

    rb_secure(4);
    GetOpenFile(io, fptr);
    if (fptr->f2 == 0 && (fptr->mode & FMODE_READABLE)) {
	rb_raise(rb_eIOError, "closing non-duplex IO for writing");
    }
    if (fptr->f2 == 0) {
	return rb_io_close(io);
    }
    fclose(fptr->f2);
    fptr->f2 = 0;
    fptr->mode &= ~FMODE_WRITABLE;

    return Qnil;
}

d881 1
a881 1
#ifdef USE_THREAD
d905 1
a905 1
#ifdef USE_THREAD
a1088 1
    fptr->f = fptr->f2 = NULL;
d1092 1
d1184 1
a1184 1
#ifdef USE_THREAD
d1349 1
a1349 1
    if (fd < 3) {
d1351 1
a1351 2
	if (dup2(fileno(orig->f), fd) < 0)
	    rb_sys_fail(orig->path);
a1354 2
	if (dup2(fileno(orig->f), fd) < 0)
	    rb_sys_fail(orig->path);
d1362 1
a1362 2
	    if (dup2(fileno(orig->f2), fd) < 0)
		rb_sys_fail(orig->path);
d1528 1
d1803 1
a1803 1
rb_f_gets_internal(argc, argv)
d1811 1
a1811 1
    line = rb_io_gets_internal(argc, argv, file);
a1822 11
static VALUE
rb_f_gets(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE line = rb_f_gets_internal(argc, argv);

    if (!NIL_P(line)) rb_lastline_set(line);
    return line;
}

d1824 1
a1824 1
rb_gets()
d1836 2
a1837 5
    if (!NIL_P(line)) {
	rb_lastline_set(line);
	gets_lineno++;
	lineno = INT2FIX(gets_lineno);
    }
d1847 1
a1847 1
    VALUE line = rb_f_gets(argc, argv);
d1938 1
a1938 1
    while (!NIL_P(line = rb_f_gets_internal(argc, argv))) {
d2068 1
a2068 1
#ifdef USE_THREAD
d2375 1
a2375 1
    while (!NIL_P(str = rb_io_gets_internal(arg->argc, &arg->sep, arg->io))) {
d2405 1
a2405 1
    while (!NIL_P(line = rb_io_gets_internal(arg->argc, &arg->sep, arg->io))) {
d2510 1
a2510 1
    while (RTEST(str = rb_f_gets_internal(argc, argv))) {
d2599 1
a2599 1
    rb_define_global_function("gets", rb_f_gets, -1);
d2687 1
a2687 1
    rb_define_method(rb_cIO, "close", rb_io_close_method, 0);
a2688 2
    rb_define_method(rb_cIO, "close_read", rb_io_close_read, 0);
    rb_define_method(rb_cIO, "close_write", rb_io_close_write, 0);
d2726 1
a2726 1
    rb_define_singleton_method(argf, "gets", rb_f_gets, -1);
@


1.1.1.2.2.47.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:49 $
a155 1
    rb_secure(4);
d165 1
a246 6
#ifndef SEEK_CUR
# define SEEK_SET 0
# define SEEK_CUR 1
# define SEEK_END 2
#endif

d255 1
a255 1
    pos = fseek(fptr->f, NUM2INT(offset), SEEK_SET);
d363 2
a364 2
    long siz = BUFSIZ;
    long bytes = 0;
d370 1
d372 3
a374 2
#ifdef __BEOS__
	&& (st.st_dev > 3)
d376 1
a376 3
	)
    {
	if (st.st_size == 0) return rb_str_new(0, 0);
d392 1
a392 1
	    return rb_str_new(0,0);
d399 1
a399 1
    if (bytes == 0) return rb_str_new(0,0);
d401 1
a401 1
    return rb_obj_taint(str);
d414 1
a414 2
    rb_scan_args(argc, argv, "01", &length);
    if (NIL_P(length)) {
d435 1
a435 1
    return rb_obj_taint(str);
d571 1
a571 1
	rb_obj_taint(str);
d629 1
a629 1
	rb_obj_taint(str);
d981 1
a981 1
    return rb_obj_taint(str);
a1390 1
    rb_secure(4);
d1664 2
a1665 4
    obj = rb_obj_as_string(rb_inspect(obj));
    fwrite(RSTRING(obj)->ptr, 1, RSTRING(obj)->len, stdout);
    obj = rb_default_rs;
    fwrite(RSTRING(obj)->ptr, 1, RSTRING(obj)->len, stdout);
d1993 5
a1997 1
    return rb_io_ungetc(rb_stdin, c);
d2118 1
a2118 1
	    if (max < fileno(fptr->f)) max = fileno(fptr->f);
d2121 1
a2121 1
		if (max < fileno(fptr->f2)) max = fileno(fptr->f2);
d2140 1
a2140 1
		if (max < fileno(fptr->f2)) max = fileno(fptr->f2);
a2761 3
    rb_define_const(rb_cIO, "SEEK_SET", SEEK_SET);
    rb_define_const(rb_cIO, "SEEK_CUR", SEEK_CUR);
    rb_define_const(rb_cIO, "SEEK_END", SEEK_END);
@


1.1.1.2.2.47.2.4
log
@first public release of 1.1d (pre1.2) series
@
text
@d6 1
a6 1
  $Date: 1998/11/26 08:25:44 $
d2547 1
a2547 1
    if (NIL_P(tmp) || RSTRING(tmp)->len == 0) return str;
@


1.1.1.2.2.47.2.5
log
@1.1d1
@
text
@d6 1
a6 1
  $Date: 1998/12/16 07:30:31 $
a63 2
#include "util.h"

d2281 1
a2281 1
    if (!io_p) {
@
