head	1.20;
access;
symbols
	v1_6_7:1.9.2.1
	v1_6_6:1.9.2.1
	v1_6_5:1.9
	v1_6_4:1.9
	v1_7_1:1.11
	v1_6_4_preview4:1.9
	v1_6_4_preview3:1.9
	v1_6_4_preview2:1.9
	v1_6_4_preview1:1.9
	v1_6_3:1.9
	ruby_m17n:1.9.0.4
	ruby_1_6:1.9.0.2
	v1_6_2:1.9
	v1_6_1:1.8
	v1_6_0:1.8
	v1_4_6:1.3.2.1
	v1_4_5:1.3.2.1
	v1_4_4:1.3.2.1
	ruby_1_4_3:1.3
	ruby1_4_3:1.3
	v1_4_3:1.3
	v1_5_0:1.3
	ruby_1_4_3_pre1:1.3
	ruby_1_4:1.3.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.7
	v1_3_6_repack:1.1.1.1.2.7
	v1_3_6:1.1.1.1.2.7
	v1_3_5:1.1.1.1.2.7
	v1_2_6repack:1.1.2.2
	v1_3_4_990625:1.1.1.1.2.7
	v1_3_4_990624:1.1.1.1.2.6
	v1_2_6:1.1.2.2
	v1_3_4_990611:1.1.1.1.2.5
	v1_3_4_990531:1.1.1.1.2.3
	v1_3_3_990518:1.1.1.1.2.3
	v1_3_3_990513:1.1.1.1.2.3
	v1_3_3_990507:1.1.1.1.2.3
	v1_2_5:1.1.2.2
	v1_2_4:1.1.2.2
	v1_3_1_990225:1.1.1.1.2.1
	v1_3_1_990224:1.1.1.1.2.1
	v1_3_1_990215:1.1.1.1.2.1
	v1_3_1_990212:1.1.1.1.2.1
	v1_3_1_990210:1.1.1.1.2.1
	v1_3_1_:1.1.1.1.2.1
	v1_3_1_990209:1.1.1.1.2.1
	v1_3_1_990205:1.1.1.1.2.1
	v1_3_1_990203:1.1.1.1.2.1
	v1_3_1_990201:1.1.1.1.2.1
	v1_3_1"_990201:1.1.1.1.2.1
	v1_3_1_990128:1.1.1.1.2.1
	v1_3_1_990127:1.1.1.1.2.1
	v1_3_1_990126:1.1.1.1.2.1
	ruby_1_3:1.1.1.1.0.2
	v1_2_2:1.1.2.2
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_2_2_pr1:1.1.2.2
	v1_2_1repack:1.1.2.2
	v1_2_1:1.1.2.2
	v1_2_stable:1.1.2.2
	v1_1d1:1.1.2.2.2.2
	v1_1d0:1.1.2.2.2.2
	v1_1c9_1:1.1.2.2
	v1_1c9:1.1.2.2
	v1_1c8:1.1.2.2
	v1_1c7:1.1.2.2
	v1_1c6:1.1.2.2
	v1_1d-start:1.1.2.2.2.1
	v1_1c5:1.1.2.2
	v1_1dev:1.1.2.2.0.2
	v1_1c4:1.1.2.2
	v1_1c3:1.1.2.2
	v1_1c2:1.1.2.2
	v1_1c1:1.1.2.2
	v1_1c0:1.1.2.2
	v1_1b9_31:1.1.2.2
	v1_1b9_30:1.1.2.2
	v1_1b9_28:1.1.2.2
	v1_1b9_27:1.1.2.1
	v1_1b9_26:1.1.2.1
	v1_1r:1.1.0.2;
locks; strict;
comment	@ * @;


1.20
date	2002.10.02.14.59.25;	author nobu;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.02.14.13.58;	author nobu;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.16.02.52.25;	author nobu;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.14.06.22.26;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.15.07.48.45;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.01.07.39.09;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.07.04.18.08;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.17.07.52.35;	author nobu;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.03.07.19.10;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.02.04.22.11;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.14.05.51.57;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.10.07.16.51;	author matz;	state Exp;
branches
	1.9.2.1
	1.9.4.1;
next	1.8;

1.8
date	2000.05.01.09.41.29;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.23.08.37.29;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.01.03.18.03;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.17.08.37.45;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.05.04.37.11;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.09.20.07.14.18;	author matz;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.08.13.05.45.14;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.04.21.13;	author matz;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	99.01.20.04.59.26;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.01.26.10.08.16;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.03.24.08.52.33;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.05.06.08.31.46;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.06.09.09.21.32;	author matz;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.06.11.06.29.57;	author matz;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	99.06.24.04.24.03;	author matz;	state Exp;
branches;
next	1.1.1.1.2.7;

1.1.1.1.2.7
date	99.06.25.09.02.48;	author matz;	state Exp;
branches;
next	1.1.1.1.2.8;

1.1.1.1.2.8
date	99.08.13.05.17.42;	author matz;	state Exp;
branches;
next	;

1.1.2.1
date	98.06.16.04.21.13;	author matz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	98.06.26.09.44.37;	author matz;	state Exp;
branches
	1.1.2.2.2.1;
next	;

1.1.2.2.2.1
date	98.09.08.07.09.12;	author matz;	state Exp;
branches;
next	1.1.2.2.2.2;

1.1.2.2.2.2
date	98.12.16.07.30.33;	author matz;	state Exp;
branches;
next	;

1.3.2.1
date	2000.01.17.08.24.12;	author matz;	state Exp;
branches;
next	;

1.9.2.1
date	2001.12.17.08.13.17;	author nobu;	state Exp;
branches;
next	;

1.9.4.1
date	2001.01.12.04.36.00;	author matz;	state Exp;
branches;
next	;


desc
@@


1.20
log
@* configure.in (RUBY_CHECK_IO_NEED_FLUSH): check whether fflush()
  is needed.

* io.c (flush_before_seek): flush before seek if buffered data
  may remain.

* io.c (rb_io_check_readable): flush if the last operation was
  write.

* io.c (rb_io_check_writable): flush if the last operation was
  read.

* rubyio.h (FMODE_RBUF): added.
@
text
@/**********************************************************************

  rubyio.h -

  $Author: nobu $
  $Date: 2002/10/02 14:13:58 $
  created at: Fri Nov 12 16:47:09 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto

**********************************************************************/

#ifndef RUBYIO_H
#define RUBYIO_H

#include <stdio.h>
#include <errno.h>

typedef struct OpenFile {
    FILE *f;			/* stdio ptr for read/write */
    FILE *f2;			/* additional ptr for rw pipes */
    int mode;			/* mode flags */
    int pid;			/* child's pid (for pipes) */
    int lineno;			/* number of lines read */
    char *path;			/* pathname for file */
    void (*finalize) _((struct OpenFile*)); /* finalize proc */
} OpenFile;

#define FMODE_READABLE  1
#define FMODE_WRITABLE  2
#define FMODE_READWRITE 3
#define FMODE_BINMODE   4
#define FMODE_SYNC      8
#define FMODE_WBUF     16
#define FMODE_RBUF     32

#define GetOpenFile(obj,fp) rb_io_check_closed((fp) = RFILE(rb_io_taint_check(obj))->fptr)

#define MakeOpenFile(obj, fp) do {\
    if (RFILE(obj)->fptr) {\
	rb_io_close(obj);\
	free(RFILE(obj)->fptr);\
	RFILE(obj)->fptr = 0;\
    }\
    fp = 0;\
    fp = RFILE(obj)->fptr = ALLOC(OpenFile);\
    fp->f = fp->f2 = NULL;\
    fp->mode = 0;\
    fp->pid = 0;\
    fp->lineno = 0;\
    fp->path = NULL;\
    fp->finalize = 0;\
} while (0)

#define GetReadFile(fptr) ((fptr)->f)
#define GetWriteFile(fptr) (((fptr)->f2) ? (fptr)->f2 : (fptr)->f)

FILE *rb_fopen _((const char*, const char*));
FILE *rb_fdopen _((int, const char*));
int rb_getc _((FILE*));
long rb_io_fread _((char *, long, FILE *));
int  rb_io_mode_flags _((const char*));
void rb_io_check_writable _((OpenFile*));
void rb_io_check_readable _((OpenFile*));
void rb_io_fptr_finalize _((OpenFile*));
void rb_io_synchronized _((OpenFile*));
void rb_io_check_closed _((OpenFile*));
int rb_io_wait_readable _((int));
int rb_io_wait_writable _((int));

VALUE rb_io_taint_check _((VALUE));
void rb_eof_error _((void));

void rb_read_check _((FILE*));
int rb_read_pending _((FILE*));
#endif
@


1.19
log
@* io.c (rb_io_wait_readable): handle retryable errors.

* io.c (rb_io_wait_writable): ditto.

* ext/socket/socket.c (bsock_send): ditto.

* ext/socket/socket.c (s_recvfrom): ditto.

* ext/socket/socket.c (s_accept): ditto.

* ext/socket/socket.c (udp_send): ditto.

* ext/socket/getaddrinfo.c (afdl): made private structures constant.

* rubyio.h: prototype; rb_io_wait_readable(), rb_io_wait_writable().
@
text
@d6 1
a6 1
  $Date: 2002/08/16 02:52:25 $
d35 1
@


1.18
log
@* io.c (rb_io_fread): renamed from io_fread and made extern.

* marshal.c (r_bytes0): check if successfully read, use
  rb_io_fread() instead of fread() to be preemptive.
  (ruby-bugs-ja:PR#294, 295)

* rubyio.h (rb_io_fread): added.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/14 06:22:26 $
d67 2
@


1.17
log
@* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* numeric.c (flo_to_s): default format precision to be "%.16g".

* util.c (ruby_strtod): use own strtod(3) implementation to avoid
  locale hell.  Due to this change "0xff".to_f no longer returns 255.0

* eval.c (avalue_to_yvalue): new function to distinguish yvalue
  (no-arg == Qundef) from svalue (no-arg == Qnil).

* eval.c (rb_yield_0): use avalue_to_yvalue().

* eval.c (assign): warn if val == Qundef where it means rhs is
  void (e.g. yield without value or call without argument).

* parse.y (value_expr): need not to warn for WHILE and UNTIL,
  since they can have return value (via valued break).
@
text
@d6 1
a6 1
  $Date: 2002/04/15 07:48:45 $
d60 1
@


1.16
log
@* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* error.c (exc_initialize): should clear backtrace information.

* io.c (rb_io_fptr_cleanup): should close IO created by IO.new(fd).

* rubyio.h: remove FMODE_FDOPEN
@
text
@d6 1
a6 1
  $Date: 2002/04/01 07:39:09 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
@


1.15
log
@* re.c (match_setter): it's OK to assign nil to $~.

* io.c (rb_io_fptr_cleanup): do not close IO created by for_fd().

* io.c (rb_io_initialize): mark IO created by for_fd

* ext/socket/socket.c (bsock_s_for_fd): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/02/07 04:18:08 $
a34 1
#define FMODE_FDOPEN   32
@


1.14
log
@* io.c (io_write): flag when buffered write is done.

* io.c (fptr_finalize): do not raise error on EBADF if write
  buffer is empty.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/12/17 07:52:35 $
d35 1
@


1.13
log
@* intern.h: add prototypes.
  rb_gc_enable(), rb_gc_disable(), rb_gc_start(), rb_str_new5()
  rb_str_buf_append(), rb_str_buf_cat(), rb_str_buf_cat2(),
  rb_str_dup_frozen()

* ruby.h: added declaration.
  rb_defout, rb_stdin, rb_stdout, rb_stderr, ruby_errinfo

* rubyio.h: changed double include guard macro to RUBYIO_H.

* array.c (inspect_call): make static.

* eval.c (dvar_asgn): ditto.

* io.c (rb_io_close_read): ditto.

* lex.c (rb_reserved_word): ditto.

* ruby.c: (req_list_head, req_list_last): ditto.

* ruby.c (require_libraries): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/03 07:19:10 $
d34 1
@


1.12
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:11 $
d13 2
a14 2
#ifndef IO_H
#define IO_H
@


1.11
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d6 1
a6 1
  $Date: 2001/02/14 05:51:57 $
d38 5
@


1.10
log
@* dir.c (dir_s_glob): supprt backslash escape of metacharacters
  and delimiters.

* dir.c (remove_backslases): remove backslashes from path before
  calling stat(2).

* dir.c (dir_s_glob): call rb_yield directly (via push_pattern) if
  block is given to the method.

* dir.c (push_pattern): do not call rb_ary_push; yield directly.

* eval.c (blk_copy_prev): reduced ALLOC_N too much.

* eval.c (frame_dup): ditto.
@
text
@d6 1
a6 1
  $Date: 2000/11/10 07:16:51 $
d26 1
a26 1
    void (*finalize)();		/* finalize proc */
@


1.9
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:29 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.9.2.1
log
@* intern.h: add prototypes.
  rb_str_dup_frozen()

* ruby.h: added declaration.
  rb_defout, rb_stdin, rb_stdout, rb_stderr, ruby_errinfo

* rubyio.h: changed double include guard macro to RUBYIO_H.

* array.c (inspect_call): make static.

* eval.c (dvar_asgn): ditto.

* io.c (rb_io_close_read): ditto.

* lex.c (rb_reserved_word): ditto.

* ruby.c: (req_list_head, req_list_last): ditto.

* ruby.c (require_libraries): ditto.
@
text
@d6 1
a6 1
  $Date: 2000/11/10 07:16:51 $
d13 2
a14 2
#ifndef RUBYIO_H
#define RUBYIO_H
@


1.9.4.1
log
@m17n fix
@
text
@d6 1
a6 1
  $Date: 2001/01/10 07:52:46 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
a17 1
#include "m17n.h"
a26 1
    m17n_encoding *enc;
a45 1
    fp->enc = ruby_default_encoding;\
@


1.8
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/03/23 08:37:29 $
d35 1
a35 1
#define GetOpenFile(obj,fp) rb_io_check_closed((fp) = RFILE(obj)->fptr)
d60 2
@


1.7
log
@2000-03-23
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/02/01 03:18:03 $
d11 1
a11 1
************************************************/
@


1.6
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:37:45 $
d38 1
@


1.5
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:37:11 $
d61 1
@


1.4
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/09/20 07:14:18 $
d61 1
a61 2
void rb_read_check _((FILE*));	/* thread aware check */

@


1.3
log
@19990920
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:14 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
@


1.3.2.1
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 1999/09/20 07:14:18 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:17:42 $
d57 1
a57 1
void rb_io_unbuffered _((OpenFile*));
@


1.1
log
@file rubyio.h was initially added on branch v1_1r.
@
text
@d1 63
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@a0 60
/************************************************

  rubyio.h -

  $Author: matz $
  $Revision: 1.1.2.2.2.2 $
  $Date: 1998/12/16 07:30:33 $
  created at: Fri Nov 12 16:47:09 JST 1993

  Copyright (C) 1993-1998 Yukihiro Matsumoto

************************************************/

#ifndef IO_H
#define IO_H

#include <stdio.h>
#include <errno.h>

typedef struct OpenFile {
    FILE *f;			/* stdio ptr for read/write */
    FILE *f2;			/* additional ptr for rw pipes */
    int mode;			/* mode flags */
    int pid;			/* child's pid (for pipes) */
    int lineno;			/* number of lines read */
    char *path;			/* pathname for file */
    void (*finalize)();		/* finalize proc */
} OpenFile;

#define FMODE_READABLE  1
#define FMODE_WRITABLE  2
#define FMODE_READWRITE 3
#define FMODE_BINMODE   4
#define FMODE_SYNC      8

#define GetOpenFile(obj,fp) rb_io_check_closed((fp) = RFILE(obj)->fptr)

#define MakeOpenFile(obj, fp) do {\
    fp = RFILE(obj)->fptr = ALLOC(OpenFile);\
    fp->f = fp->f2 = NULL;\
    fp->mode = 0;\
    fp->pid = 0;\
    fp->lineno = 0;\
    fp->path = NULL;\
    fp->finalize = 0;\
} while (0)

#define GetReadFile(fptr) ((fptr)->f)
#define GetWriteFile(fptr) (((fptr)->f2) ? (fptr)->f2 : (fptr)->f)

FILE *rb_fopen _((char *, char *));
FILE *rb_fdopen _((int, char *));
void rb_io_check_writable _((OpenFile *));
void rb_io_check_readable _((OpenFile *));
void rb_io_fptr_finalize _((OpenFile *));
void rb_io_unbuffered _((OpenFile *));
void rb_io_check_closed _((OpenFile *));
void rb_eof_error _((void));

#endif
@


1.1.1.1.2.1
log
@990126
@
text
@d6 2
a7 2
  $Revision: 1.1.1.1 $
  $Date: 1999/01/20 04:59:26 $
d10 1
a10 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
@


1.1.1.1.2.2
log
@990324
@
text
@d6 2
a7 2
  $Revision: 1.1.1.1.2.1 $
  $Date: 1999/01/26 10:08:16 $
d51 2
a52 2
FILE *rb_fopen _((const char*, const char*));
FILE *rb_fdopen _((int, const char*));
@


1.1.1.1.2.3
log
@small fixes
@
text
@d6 2
a7 2
  $Revision: 1.1.1.1.2.2 $
  $Date: 1999/03/24 08:52:33 $
d53 5
a57 6
int  rb_io_mode_flags _((const char*));
void rb_io_check_writable _((OpenFile*));
void rb_io_check_readable _((OpenFile*));
void rb_io_fptr_finalize _((OpenFile*));
void rb_io_unbuffered _((OpenFile*));
void rb_io_check_closed _((OpenFile*));
@


1.1.1.1.2.4
log
@thread bugs
@
text
@d6 2
a7 2
  $Revision: 1.1.1.1.2.3 $
  $Date: 1999/05/06 08:31:46 $
a52 1
int rb_getc _((FILE*));
@


1.1.1.1.2.5
log
@990611
@
text
@d6 2
a7 2
  $Revision: 1.1.1.1.2.4 $
  $Date: 1999/06/09 09:21:32 $
a60 2

void rb_read_check _((FILE*));	/* thread aware check */
@


1.1.1.1.2.6
log
@990624
@
text
@d6 2
a7 2
  $Revision: 1.1.1.1.2.5 $
  $Date: 1999/06/11 06:29:57 $
a38 1
    RFILE(obj)->iv_tbl = 0;\
@


1.1.1.1.2.7
log
@990625
@
text
@d6 2
a7 2
  $Revision: 1.1.1.1.2.6 $
  $Date: 1999/06/24 04:24:03 $
d39 1
@


1.1.1.1.2.8
log
@pre 1.4.0
@
text
@d6 2
a7 1
  $Date: 1999/06/25 09:02:48 $
@


1.1.2.1
log
@baseline
@
text
@a0 59
/************************************************

  rubyio.h -

  $Author: matz $
  $Revision: 1.1.1.2.2.3 $
  $Date: 1998/03/11 07:32:58 $
  created at: Fri Nov 12 16:47:09 JST 1993

  Copyright (C) 1993-1998 Yukihiro Matsumoto

************************************************/

#ifndef IO_H
#define IO_H

#include "rubysig.h"
#include <stdio.h>
#include <errno.h>

typedef struct OpenFile {
    FILE *f;			/* stdio ptr for read/write */
    FILE *f2;			/* additional ptr for rw pipes */
    int mode;			/* mode flags */
    int pid;			/* child's pid (for pipes) */
    int lineno;			/* number of lines read */
    char *path;			/* pathname for file */
    void (*finalize)();		/* finalize proc */
} OpenFile;

#define FMODE_READABLE  1
#define FMODE_WRITABLE  2
#define FMODE_READWRITE 3
#define FMODE_BINMODE   4
#define FMODE_SYNC      8

#define GetOpenFile(obj,fp) io_check_closed((fp) = RFILE(obj)->fptr)

#define MakeOpenFile(obj, fp) do {\
    fp = RFILE(obj)->fptr = ALLOC(OpenFile);\
    fp->f = fp->f2 = NULL;\
    fp->mode = 0;\
    fp->pid = 0;\
    fp->lineno = 0;\
    fp->path = NULL;\
    fp->finalize = 0;\
} while (0)

#define GetWriteFile(fptr) (((fptr)->f2) ? (fptr)->f2 : (fptr)->f)

FILE *rb_fopen _((char *, char *));
FILE *rb_fdopen _((int, char *));
void io_writable _((OpenFile *));
void io_readable _((OpenFile *));
void io_fptr_finalize _((OpenFile *));
void io_unbuffered _((OpenFile *));
void io_check_closed _((OpenFile *));

#endif
@


1.1.2.2
log
@980626
@
text
@d6 2
a7 2
  $Revision: 1.1.2.1 $
  $Date: 1998/06/16 04:21:13 $
d17 1
@


1.1.2.2.2.1
log
@1.1d series
@
text
@d6 2
a7 2
  $Revision: 1.1.2.2 $
  $Date: 1998/06/26 09:44:37 $
d36 1
a36 1
#define GetOpenFile(obj,fp) rb_io_check_closed((fp) = RFILE(obj)->fptr)
d52 5
a56 6
void rb_io_check_writable _((OpenFile *));
void rb_io_check_readable _((OpenFile *));
void rb_io_fptr_finalize _((OpenFile *));
void rb_io_unbuffered _((OpenFile *));
void rb_io_check_closed _((OpenFile *));
void rb_eof_error _((void));
@


1.1.2.2.2.2
log
@first public release of 1.1d (pre1.2) series
@
text
@d6 2
a7 2
  $Revision: 1.1.2.2.2.1 $
  $Date: 1998/09/08 07:09:12 $
a47 1
#define GetReadFile(fptr) ((fptr)->f)
@
