head	1.12;
access;
symbols
	v1_6_7:1.6.2.1
	v1_6_6:1.6
	v1_6_5:1.6
	v1_6_4:1.6
	v1_7_1:1.9
	v1_6_4_preview4:1.6
	v1_6_4_preview3:1.6
	v1_6_4_preview2:1.6
	v1_6_4_preview1:1.6
	v1_6_3:1.6
	ruby_m17n:1.6.0.4
	ruby_1_6:1.6.0.2
	v1_6_2:1.6
	v1_6_1:1.4
	v1_6_0:1.3
	v1_4_6:1.2
	v1_4_5:1.2
	v1_4_4:1.2
	ruby_1_4_3:1.2
	ruby1_4_3:1.2
	v1_4_3:1.2
	v1_5_0:1.2
	ruby_1_4_3_pre1:1.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.3
	v1_3_6_repack:1.1.1.1.2.2
	v1_3_6:1.1.1.1.2.2
	v1_3_5:1.1.1.1.2.2
	v1_2_6repack:1.1.2.3
	v1_3_4_990625:1.1.1.1.2.2
	v1_3_4_990624:1.1.1.1.2.2
	v1_2_6:1.1.2.3
	v1_3_4_990611:1.1.1.1.2.1
	v1_3_4_990531:1.1.1.1.2.1
	v1_3_3_990518:1.1.1.1.2.1
	v1_3_3_990513:1.1.1.1.2.1
	v1_3_3_990507:1.1.1.1.2.1
	v1_2_5:1.1.2.3
	v1_2_4:1.1.2.3
	v1_3_1_990225:1.1.1.1
	v1_3_1_990224:1.1.1.1
	v1_3_1_990215:1.1.1.1
	v1_3_1_990212:1.1.1.1
	v1_3_1_990210:1.1.1.1
	v1_3_1_:1.1.1.1
	v1_3_1_990209:1.1.1.1
	v1_3_1_990205:1.1.1.1
	v1_3_1_990203:1.1.1.1
	v1_3_1_990201:1.1.1.1
	v1_3_1"_990201:1.1.1.1
	v1_3_1_990128:1.1.1.1
	v1_3_1_990127:1.1.1.1
	v1_3_1_990126:1.1.1.1
	ruby_1_3:1.1.1.1.0.2
	v1_2_2:1.1.2.3
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_2_2_pr1:1.1.2.3
	v1_2_1repack:1.1.2.3
	v1_2_1:1.1.2.3
	v1_2_stable:1.1.2.3
	v1_1d1:1.1.2.3.2.2
	v1_1d0:1.1.2.3.2.2
	v1_1c9_1:1.1.2.3
	v1_1c9:1.1.2.3
	v1_1c8:1.1.2.3
	v1_1c7:1.1.2.3
	v1_1c6:1.1.2.3
	v1_1d-start:1.1.2.3.2.1
	v1_1c5:1.1.2.3
	v1_1dev:1.1.2.3.0.2
	v1_1c4:1.1.2.3
	v1_1c3:1.1.2.3
	v1_1c2:1.1.2.3
	v1_1c1:1.1.2.3
	v1_1c0:1.1.2.3
	v1_1b9_31:1.1.2.3
	v1_1b9_30:1.1.2.3
	v1_1b9_28:1.1.2.3
	v1_1b9_27:1.1.2.1
	v1_1b9_26:1.1.2.1
	v1_1r:1.1.0.2;
locks; strict;
comment	@ * @;


1.12
date	2002.05.29.10.22.18;	author H_Konishi;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.14.06.22.26;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.24.04.54.14;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.02.04.22.11;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.17.15.17.09;	author usa;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.14.05.51.58;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.16.07.24.11;	author matz;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.11.14.07.10.23;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.27.09.11.12;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.01.09.41.29;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.14;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.04.23.44;	author matz;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	99.01.20.04.59.26;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.03.24.08.52.33;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.06.24.04.24.03;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.08.06.06.48.21;	author matz;	state Exp;
branches;
next	;

1.1.2.1
date	98.06.16.04.23.44;	author matz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	98.06.24.04.38.03;	author matz;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	98.06.26.09.44.38;	author matz;	state Exp;
branches
	1.1.2.3.2.1;
next	;

1.1.2.3.2.1
date	98.09.08.07.09.14;	author matz;	state Exp;
branches;
next	1.1.2.3.2.2;

1.1.2.3.2.2
date	98.10.06.03.28.15;	author matz;	state Exp;
branches;
next	;

1.6.2.1
date	2002.02.27.04.50.30;	author matz;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Wed May 29 18:55:47 2002  KONISHI Hiromasa <H_Konishi@@ruby-lang.org>

	* function renames my* and win32_* to rb_w32_* in win32/win32.c
	  fixed files win32/win32.c, win32/win32.h, win32/dir.h,
	              hash.c, rubysig.h, signal.c, ext/socket/socket.c
@
text
@/**********************************************************************

  rubysig.h -

  $Author: matz $
  $Date: 2002/05/14 06:22:26 $
  created at: Wed Aug 16 01:15:38 JST 1995

  Copyright (C) 1993-2002 Yukihiro Matsumoto

**********************************************************************/

#ifndef SIG_H
#define SIG_H

#ifdef NT
typedef LONG rb_atomic_t;

# define ATOMIC_TEST(var) InterlockedExchange(&(var), 0)
# define ATOMIC_SET(var, val) InterlockedExchange(&(var), (val))
# define ATOMIC_INC(var) InterlockedIncrement(&(var))
# define ATOMIC_DEC(var) InterlockedDecrement(&(var))

/* Windows doesn't allow interrupt while system calls */
# define TRAP_BEG do {\
    rb_atomic_t trap_immediate = ATOMIC_SET(rb_trap_immediate, 1)
# define TRAP_END\
	ATOMIC_SET(rb_trap_immediate, trap_immediate);\
} while (0)
# define RUBY_CRITICAL(statements) do {\
    rb_w32_enter_critical();\
    statements;\
    rb_w32_leave_critical();\
} while (0)
#else
typedef int rb_atomic_t;

# define ATOMIC_TEST(var) ((var) ? ((var) = 0, 1) : 0)
# define ATOMIC_SET(var, val) ((var) = (val))
# define ATOMIC_INC(var) (++(var))
# define ATOMIC_DEC(var) (--(var))

# define TRAP_BEG do {\
    int trap_immediate = rb_trap_immediate;\
    rb_trap_immediate = 1
# define TRAP_END rb_trap_immediate = trap_immediate;\
} while (0)

# define RUBY_CRITICAL(statements) do {\
    int trap_immediate = rb_trap_immediate;\
    rb_trap_immediate = 0;\
    statements;\
    rb_trap_immediate = trap_immediate;\
} while (0)
#endif
EXTERN rb_atomic_t rb_trap_immediate;

EXTERN int rb_prohibit_interrupt;
#define DEFER_INTS (rb_prohibit_interrupt++)
#define ALLOW_INTS do {\
    rb_prohibit_interrupt--;\
    CHECK_INTS;\
} while (0)
#define ENABLE_INTS (rb_prohibit_interrupt--)

VALUE rb_with_disable_interrupt _((VALUE(*)(ANYARGS),VALUE));

EXTERN rb_atomic_t rb_trap_pending;
void rb_trap_restore_mask _((void));

EXTERN int rb_thread_critical;
void rb_thread_schedule _((void));
#if defined(HAVE_SETITIMER) && !defined(__BOW__)
EXTERN int rb_thread_pending;
# define CHECK_INTS do {\
    if (!rb_prohibit_interrupt) {\
	if (rb_trap_pending) rb_trap_exec();\
	if (rb_thread_pending && !rb_thread_critical)\
	    rb_thread_schedule();\
    }\
} while (0)
#else
/* pseudo preemptive thread switching */
EXTERN int rb_thread_tick;
#define THREAD_TICK 500
#define CHECK_INTS do {\
    if (!rb_prohibit_interrupt) {\
	if (rb_trap_pending) rb_trap_exec();\
	if (!rb_thread_critical) {\
	    if (rb_thread_tick-- <= 0) {\
		rb_thread_tick = THREAD_TICK;\
		rb_thread_schedule();\
	    }\
	}\
    }\
} while (0)
#endif

#endif
@


1.11
log
@* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* numeric.c (flo_to_s): default format precision to be "%.16g".

* util.c (ruby_strtod): use own strtod(3) implementation to avoid
  locale hell.  Due to this change "0xff".to_f no longer returns 255.0

* eval.c (avalue_to_yvalue): new function to distinguish yvalue
  (no-arg == Qundef) from svalue (no-arg == Qnil).

* eval.c (rb_yield_0): use avalue_to_yvalue().

* eval.c (assign): warn if val == Qundef where it means rhs is
  void (e.g. yield without value or call without argument).

* parse.y (value_expr): need not to warn for WHILE and UNTIL,
  since they can have return value (via valued break).
@
text
@d6 1
a6 1
  $Date: 2002/04/24 04:54:14 $
d31 1
a31 1
    win32_enter_critical();\
d33 1
a33 1
    win32_leave_critical();\
@


1.10
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:11 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
@


1.9
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/02/17 15:17:09 $
d26 3
a28 2
    rb_atomic_t trap_immediate = ATOMIC_SET(rb_trap_immediate, 1);
# define TRAP_END ATOMIC_SET(rb_trap_immediate, trap_immediate);\
d45 1
a45 1
    rb_trap_immediate = 1;
d59 6
a64 3
#define DEFER_INTS {rb_prohibit_interrupt++;}
#define ALLOW_INTS {rb_prohibit_interrupt--; CHECK_INTS;}
#define ENABLE_INTS {rb_prohibit_interrupt--;}
d75 7
a81 4
# define CHECK_INTS if (!rb_prohibit_interrupt) {\
    if (rb_trap_pending) rb_trap_exec();\
    if (rb_thread_pending && !rb_thread_critical) rb_thread_schedule();\
}
d86 8
a93 6
#define CHECK_INTS if (!rb_prohibit_interrupt) {\
    if (rb_trap_pending) rb_trap_exec();\
    if (!rb_thread_critical) {\
	if (rb_thread_tick-- <= 0) {\
	    rb_thread_tick = THREAD_TICK;\
	    rb_thread_schedule();\
d96 1
a96 1
}
@


1.8
log
@* win32/win32.c: fasten file I/O on mswin32/mingw32.

* win32/win32.h: ditto.

* rubysig.h: ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/02/14 05:51:58 $
d62 1
a62 1
VALUE rb_with_disable_interrupt _((VALUE(*)(),VALUE));
@


1.7
log
@* dir.c (dir_s_glob): supprt backslash escape of metacharacters
  and delimiters.

* dir.c (remove_backslases): remove backslashes from path before
  calling stat(2).

* dir.c (dir_s_glob): call rb_yield directly (via push_pattern) if
  block is given to the method.

* dir.c (push_pattern): do not call rb_ary_push; yield directly.

* eval.c (blk_copy_prev): reduced ALLOC_N too much.

* eval.c (frame_dup): ditto.
@
text
@d6 1
a6 1
  $Date: 2000/11/16 07:24:11 $
d25 4
a28 2
# define TRAP_BEG win32_enter_syscall()
# define TRAP_END win32_leave_syscall()
d30 1
a30 1
    win32_disable_interrupt();\
d32 1
a32 1
    win32_enable_interrupt();\
@


1.6
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/14 07:10:23 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.6.2.1
log
@* eval.c (rb_f_missing): NoMethod error messages for true, false,
  nil must respond visibility like for other objects.
@
text
@d6 1
a6 1
  $Date: 2000/11/16 07:24:11 $
d60 1
a60 1
VALUE rb_with_disable_interrupt _((VALUE(*)(ANYARGS),VALUE));
@


1.5
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/27 09:11:12 $
d40 6
a45 2
# define TRAP_BEG (rb_trap_immediate=1)
# define TRAP_END (rb_trap_immediate=0)
@


1.4
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:29 $
a15 1
EXTERN int rb_trap_immediate;
d17 15
a31 2
#define TRAP_BEG (rb_trap_immediate=1, SetEvent(rb_InterruptEvent))
#define TRAP_END (rb_trap_immediate=0, ResetEvent(rb_InterruptEvent))
d33 15
a47 2
#define TRAP_BEG (rb_trap_immediate=1)
#define TRAP_END (rb_trap_immediate=0)
d49 1
d58 1
a58 1
EXTERN int rb_trap_pending;
@


1.3
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:14 $
d17 4
d23 1
@


1.2
log
@1.4.0
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 1999/08/06 06:48:21 $
d9 4
a12 1
************************************************/
@


1.1
log
@file rubysig.h was initially added on branch v1_1r.
@
text
@d1 50
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@a0 54
/************************************************

  rubysig.h -

  $Author: matz $
  $Date: 1998/10/06 03:28:15 $
  created at: Wed Aug 16 01:15:38 JST 1995

************************************************/
#ifndef SIG_H
#define SIG_H

extern int rb_trap_immediate;
#define TRAP_BEG (rb_trap_immediate=1)
#define TRAP_END (rb_trap_immediate=0)

extern int rb_prohibit_interrupt;
#define DEFER_INTS {rb_prohibit_interrupt++;}
#define ALLOW_INTS {rb_prohibit_interrupt--; CHECK_INTS;}
#define ENABLE_INTS {rb_prohibit_interrupt--;}

extern int rb_trap_pending;
void rb_trap_restore_mask _((void));

#ifdef USE_THREAD
extern int rb_thread_critical;
void rb_thread_schedule _((void));
#if defined(HAVE_SETITIMER) && !defined(__BOW__)
extern int rb_thread_pending;
# define CHECK_INTS if (!rb_prohibit_interrupt) {\
    if (rb_trap_pending) rb_trap_exec();\
    if (rb_thread_pending && !rb_thread_critical) rb_thread_schedule();\
}
# else
/* pseudo preemptive thread switching */
extern int rb_thread_tick;
#define THREAD_TICK 500
# define CHECK_INTS if (!rb_prohibit_interrupt) {\
    if (rb_trap_pending) rb_trap_exec();\
    if (!rb_thread_critical) {\
	if (rb_thread_tick-- <= 0) {\
	    rb_thread_tick = THREAD_TICK;\
	    rb_thread_schedule();\
	}\
    }\
}
# endif
#else
# define CHECK_INTS if (!rb_prohibit_interrupt) {\
    if (rb_trap_pending) rb_trap_exec();\
}
#endif

#endif
@


1.1.1.1.2.1
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:26 $
d25 1
d34 1
a34 1
#else
d38 1
a38 1
#define CHECK_INTS if (!rb_prohibit_interrupt) {\
d46 5
@


1.1.1.1.2.2
log
@990624
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:33 $
d13 1
a13 1
EXTERN int rb_trap_immediate;
@


1.1.1.1.2.3
log
@990806
@
text
@d6 1
a6 1
  $Date: 1999/06/24 04:24:03 $
d17 1
a17 1
EXTERN int rb_prohibit_interrupt;
d22 1
a22 3
VALUE rb_with_disable_interrupt _((VALUE(*)(),VALUE));

EXTERN int rb_trap_pending;
d25 1
a25 1
EXTERN int rb_thread_critical;
d28 1
a28 1
EXTERN int rb_thread_pending;
d35 1
a35 1
EXTERN int rb_thread_tick;
@


1.1.2.1
log
@baseline
@
text
@a0 54
/************************************************

  rubysig.h -

  $Author: matz $
  $Date: 1998/05/18 04:56:18 $
  created at: Wed Aug 16 01:15:38 JST 1995

************************************************/
#ifndef SIG_H
#define SIG_H

extern int trap_immediate;
#define TRAP_BEG (trap_immediate=1)
#define TRAP_END (trap_immediate=0)

extern int prohibit_interrupt;
#define DEFER_INTS {prohibit_interrupt++;}
#define ALLOW_INTS {prohibit_interrupt--; CHECK_INTS;}
#define ENABLE_INTS {prohibit_interrupt--;}

extern int trap_pending;
void trap_restore_mask _((void));

#ifdef THREAD
extern int thread_critical;
void thread_schedule _((void));
#if defined(HAVE_SETITIMER) && !defined(__BOW__)
extern int thread_pending;
# define CHECK_INTS if (!prohibit_interrupt) {\
    if (trap_pending) rb_trap_exec();\
    if (thread_pending && !thread_critical) thread_schedule();\
}
# else
/* pseudo preemptive thread switching */
extern int thread_tick;
#define THREAD_TICK 500
# define CHECK_INTS if (!prohibit_interrupt) {\
    if (trap_pending) rb_trap_exec();\
    if (!thread_critical) {\
	if (thread_tick-- <= 0) {\
	    thread_tick = THREAD_TICK;\
	    thread_schedule();\
	}\
    }\
}
# endif
#else
# define CHECK_INTS if (!prohibit_interrupt) {\
    if (trap_pending) rb_trap_exec();\
}
#endif

#endif
@


1.1.2.2
log
@thread->thred
@
text
@d6 1
a6 1
  $Date: 1998/06/16 04:23:44 $
d26 2
a27 2
extern int thred_critical;
void thred_schedule _((void));
d29 1
a29 1
extern int thred_pending;
d32 1
a32 1
    if (thred_pending && !thred_critical) thred_schedule();\
d36 1
a36 1
extern int thred_tick;
d40 4
a43 4
    if (!thred_critical) {\
	if (thred_tick-- <= 0) {\
	    thred_tick = THREAD_TICK;\
	    thred_schedule();\
@


1.1.2.3
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/24 04:38:03 $
d26 2
a27 2
extern int thread_critical;
void thread_schedule _((void));
d29 1
a29 1
extern int thread_pending;
d32 1
a32 1
    if (thread_pending && !thread_critical) thread_schedule();\
d36 1
a36 1
extern int thread_tick;
d40 4
a43 4
    if (!thread_critical) {\
	if (thread_tick-- <= 0) {\
	    thread_tick = THREAD_TICK;\
	    thread_schedule();\
@


1.1.2.3.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:38 $
d13 3
a15 3
extern int rb_trap_immediate;
#define TRAP_BEG (rb_trap_immediate=1)
#define TRAP_END (rb_trap_immediate=0)
d17 4
a20 4
extern int rb_prohibit_interrupt;
#define DEFER_INTS {rb_prohibit_interrupt++;}
#define ALLOW_INTS {rb_prohibit_interrupt--; CHECK_INTS;}
#define ENABLE_INTS {rb_prohibit_interrupt--;}
d22 2
a23 2
extern int rb_trap_pending;
void rb_trap_restore_mask _((void));
d26 2
a27 2
extern int rb_thread_critical;
void rb_thread_schedule _((void));
d29 4
a32 4
extern int rb_thread_pending;
# define CHECK_INTS if (!rb_prohibit_interrupt) {\
    if (rb_trap_pending) rb_trap_exec();\
    if (rb_thread_pending && !rb_thread_critical) rb_thread_schedule();\
d36 1
a36 1
extern int rb_thread_tick;
d38 6
a43 6
# define CHECK_INTS if (!rb_prohibit_interrupt) {\
    if (rb_trap_pending) rb_trap_exec();\
    if (!rb_thread_critical) {\
	if (rb_thread_tick-- <= 0) {\
	    rb_thread_tick = THREAD_TICK;\
	    rb_thread_schedule();\
d49 2
a50 2
# define CHECK_INTS if (!rb_prohibit_interrupt) {\
    if (rb_trap_pending) rb_trap_exec();\
@


1.1.2.3.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/09/08 07:09:14 $
d25 1
a25 1
#ifdef USE_THREAD
@
