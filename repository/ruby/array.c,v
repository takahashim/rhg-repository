head	1.96;
access;
symbols
	v1_6_7:1.37.2.11
	v1_6_6:1.37.2.11
	v1_6_5:1.37.2.8
	v1_6_4:1.37.2.6
	v1_7_1:1.49
	v1_6_4_preview4:1.37.2.6
	v1_6_4_preview3:1.37.2.6
	v1_6_4_preview2:1.37.2.3
	v1_6_4_preview1:1.37.2.3
	v1_6_3:1.37.2.3
	ruby_m17n:1.37.0.4
	ruby_1_6:1.37.0.2
	v1_6_2:1.37
	v1_6_1:1.29
	v1_6_0:1.27
	v1_4_6:1.2.2.5
	v1_4_5:1.2.2.5
	v1_4_4:1.2.2.3
	ruby_1_4_3:1.2.2.2
	ruby1_4_3:1.2.2.2
	v1_4_3:1.2.2.2
	v1_5_0:1.7
	ruby_1_4_3_pre1:1.2.2.2
	ruby_1_4:1.2.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.13
	v1_3_6_repack:1.1.1.3.2.11
	v1_3_6:1.1.1.3.2.11
	v1_3_5:1.1.1.3.2.10
	v1_2_6repack:1.1.1.2.2.35
	v1_3_4_990625:1.1.1.3.2.10
	v1_3_4_990624:1.1.1.3.2.10
	v1_2_6:1.1.1.2.2.35
	v1_3_4_990611:1.1.1.3.2.10
	v1_3_4_990531:1.1.1.3.2.9
	v1_3_3_990518:1.1.1.3.2.8
	v1_3_3_990513:1.1.1.3.2.8
	v1_3_3_990507:1.1.1.3.2.8
	v1_2_5:1.1.1.2.2.34
	v1_2_4:1.1.1.2.2.34
	v1_3_1_990225:1.1.1.3.2.6
	v1_3_1_990224:1.1.1.3.2.5
	v1_3_1_990215:1.1.1.3.2.4
	v1_3_1_990212:1.1.1.3.2.3
	v1_3_1_990210:1.1.1.3.2.3
	v1_3_1_:1.1.1.3.2.3
	v1_3_1_990209:1.1.1.3.2.3
	v1_3_1_990205:1.1.1.3.2.3
	v1_3_1_990203:1.1.1.3.2.3
	v1_3_1_990201:1.1.1.3.2.2
	v1_3_1"_990201:1.1.1.3.2.2
	v1_3_1_990128:1.1.1.3.2.1
	v1_3_1_990127:1.1.1.3.2.1
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.32
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.31
	v1_2_1repack:1.1.1.2.2.31
	v1_2_1:1.1.1.2.2.31
	v1_2_stable:1.1.1.2.2.30
	v1_1d1:1.1.1.2.2.29.2.3
	v1_1d0:1.1.1.2.2.29.2.3
	v1_1c9_1:1.1.1.2.2.30
	v1_1c9:1.1.1.2.2.30
	v1_1c8:1.1.1.2.2.30
	v1_1c7:1.1.1.2.2.30
	v1_1c6:1.1.1.2.2.29
	v1_1d-start:1.1.1.2.2.29.2.1
	v1_1c5:1.1.1.2.2.29
	v1_1dev:1.1.1.2.2.29.0.2
	v1_1c4:1.1.1.2.2.29
	v1_1c3:1.1.1.2.2.29
	v1_1c2:1.1.1.2.2.28
	v1_1c1:1.1.1.2.2.27
	v1_1c0:1.1.1.2.2.27
	v1_1b9_31:1.1.1.2.2.27
	v1_1b9_30:1.1.1.2.2.25
	v1_1b9_28:1.1.1.2.2.25
	v1_1b9_27:1.1.1.2.2.25
	v1_1b9_26:1.1.1.2.2.25
	r1_1b9_25:1.1.1.2.2.25
	r1_1b9_24:1.1.1.2.2.24
	v1_1b9_23:1.1.1.2.2.23
	v1_1b9_22:1.1.1.2.2.21
	v1_1b9_20:1.1.1.2.2.21
	v1_1b9_18:1.1.1.2.2.19
	v1_1b9_16:1.1.1.2.2.18
	v1_1b9_15:1.1.1.2.2.17
	v1_1b9_13:1.1.1.2.2.16
	v1_1b9_12:1.1.1.2.2.15
	v1_1b9_11:1.1.1.2.2.14
	v1_1b9_08:1.1.1.2.2.8
	v1_1b9_07:1.1.1.2.2.8
	r1_1b9:1.1.1.2.2.4
	v1_1b8:1.1.1.2.2.4
	v1_1b7:1.1.1.2.2.3
	v1_1b6:1.1.1.2.2.1
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.96
date	2002.09.03.05.20.06;	author matz;	state Exp;
branches;
next	1.95;

1.95
date	2002.08.29.09.08.15;	author matz;	state Exp;
branches;
next	1.94;

1.94
date	2002.08.27.08.31.05;	author matz;	state Exp;
branches;
next	1.93;

1.93
date	2002.08.27.08.05.06;	author michal;	state Exp;
branches;
next	1.92;

1.92
date	2002.08.23.15.04.27;	author michal;	state Exp;
branches;
next	1.91;

1.91
date	2002.08.23.07.48.48;	author michal;	state Exp;
branches;
next	1.90;

1.90
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.89;

1.89
date	2002.08.19.06.43.58;	author matz;	state Exp;
branches;
next	1.88;

1.88
date	2002.08.19.06.41.02;	author matz;	state Exp;
branches;
next	1.87;

1.87
date	2002.08.19.05.56.05;	author matz;	state Exp;
branches;
next	1.86;

1.86
date	2002.08.13.09.21.13;	author matz;	state Exp;
branches;
next	1.85;

1.85
date	2002.07.11.08.22.10;	author matz;	state Exp;
branches;
next	1.84;

1.84
date	2002.05.28.18.11.07;	author michal;	state Exp;
branches;
next	1.83;

1.83
date	2002.05.22.05.57.08;	author matz;	state Exp;
branches;
next	1.82;

1.82
date	2002.05.21.05.39.18;	author matz;	state Exp;
branches;
next	1.81;

1.81
date	2002.04.24.04.54.13;	author matz;	state Exp;
branches;
next	1.80;

1.80
date	2002.04.18.08.46.17;	author matz;	state Exp;
branches;
next	1.79;

1.79
date	2002.03.08.07.03.03;	author matz;	state Exp;
branches;
next	1.78;

1.78
date	2002.01.28.10.18.14;	author nobu;	state Exp;
branches;
next	1.77;

1.77
date	2002.01.28.08.44.37;	author matz;	state Exp;
branches;
next	1.76;

1.76
date	2002.01.25.08.22.04;	author matz;	state Exp;
branches;
next	1.75;

1.75
date	2002.01.23.07.30.39;	author matz;	state Exp;
branches;
next	1.74;

1.74
date	2002.01.19.14.21.44;	author matz;	state Exp;
branches;
next	1.73;

1.73
date	2002.01.11.09.18.49;	author matz;	state Exp;
branches;
next	1.72;

1.72
date	2001.12.28.05.42.23;	author nobu;	state Exp;
branches;
next	1.71;

1.71
date	2001.12.17.07.52.34;	author nobu;	state Exp;
branches;
next	1.70;

1.70
date	2001.12.13.08.19.07;	author matz;	state Exp;
branches;
next	1.69;

1.69
date	2001.12.11.03.48.08;	author matz;	state Exp;
branches;
next	1.68;

1.68
date	2001.12.10.07.18.12;	author matz;	state Exp;
branches;
next	1.67;

1.67
date	2001.11.27.10.00.30;	author matz;	state Exp;
branches;
next	1.66;

1.66
date	2001.11.19.14.42.44;	author matz;	state Exp;
branches;
next	1.65;

1.65
date	2001.11.19.05.03.02;	author matz;	state Exp;
branches;
next	1.64;

1.64
date	2001.11.15.15.56.08;	author nobu;	state Exp;
branches;
next	1.63;

1.63
date	2001.11.13.08.19.51;	author matz;	state Exp;
branches;
next	1.62;

1.62
date	2001.10.29.05.07.17;	author matz;	state Exp;
branches;
next	1.61;

1.61
date	2001.10.16.03.27.06;	author matz;	state Exp;
branches;
next	1.60;

1.60
date	2001.10.05.06.30.42;	author matz;	state Exp;
branches;
next	1.59;

1.59
date	2001.10.03.07.19.10;	author matz;	state Exp;
branches;
next	1.58;

1.58
date	2001.10.02.04.31.18;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2001.08.29.06.28.44;	author matz;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.23.06.02.14;	author matz;	state Exp;
branches;
next	1.55;

1.55
date	2001.08.20.04.29.56;	author matz;	state Exp;
branches;
next	1.54;

1.54
date	2001.08.14.08.13.26;	author matz;	state Exp;
branches;
next	1.53;

1.53
date	2001.08.06.03.05.12;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2001.07.14.15.17.18;	author matz;	state Exp;
branches;
next	1.51;

1.51
date	2001.07.02.08.46.21;	author matz;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.19.04.35.13;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2001.05.30.09.12.33;	author matz;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.16.09.05.49;	author matz;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.06.15.01.58;	author matz;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.02.04.22.10;	author matz;	state Exp;
branches;
next	1.45;

1.45
date	2001.03.13.05.45.08;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.26.05.29.00;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2001.02.19.09.14.58;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.19.07.03.05;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.14.05.51.57;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2001.02.02.11.38.10;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.10.07.52.45;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2000.12.29.02.46.09;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2000.12.25.06.28.55;	author matz;	state Exp;
branches
	1.37.2.1
	1.37.4.1;
next	1.36;

1.36
date	2000.12.12.07.42.21;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2000.12.08.07.10.15;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2000.12.05.09.36.24;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.20.07.31.38;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.31.08.37.37;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2000.10.25.04.48.39;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.10.07.03.15;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.09.12.07.08.40;	author eban;	state Exp;
branches;
next	1.28;

1.28
date	2000.09.12.05.37.19;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.24.06.21.27;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.07.05.01.46;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.17.09.37.55;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.22.08.29.40;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.30.04.23.53;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.24.04.33.52;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.05.12.09.07.31;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.10.02.58.32;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.09.04.52.51;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.01.09.41.10;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.10.05.44.05;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.17.08.58.09;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.29.08.05.24;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.23.05.23.03;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.17.07.11.06;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.01.03.11.58;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.18.06.09.02;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.08.05.00.17;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.05.04.36.56;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.12.14.06.49.39;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.10.29.09.25.30;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.10.20.07.10.22;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.10.18.09.03.00;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.10.16.10.33.05;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.10.13.06.44.40;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.02;	author matz;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.08;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.21;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.08;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.01.07.34.53;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.03.09.47.57;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.02.15.07.31.48;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.02.24.04.31.17;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.02.25.06.39.02;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.03.24.08.52.23;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.05.06.08.31.25;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.05.25.08.25.46;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.06.11.06.29.46;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.07.22.10.37.03;	author matz;	state Exp;
branches;
next	1.1.1.3.2.12;

1.1.1.3.2.12
date	99.07.30.06.43.06;	author matz;	state Exp;
branches;
next	1.1.1.3.2.13;

1.1.1.3.2.13
date	99.08.06.06.48.02;	author matz;	state Exp;
branches;
next	1.1.1.3.2.14;

1.1.1.3.2.14
date	99.08.11.07.23.48;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.43;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.02.04.05.02.43;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.02.09.10.56.17;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.02.18.01.56.27;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.03.05.06.37.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.03.11.07.32.52;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.04.02.10.03.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.04.07.08.34.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.04.07.10.18.09;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.04.10.10.09.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.04.13.06.06.11;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.04.14.04.55.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.04.14.09.08.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.04.16.07.42.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.04.17.09.29.33;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.04.21.08.41.03;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.04.22.08.57.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.04.27.10.03.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.04.30.07.41.07;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.05.13.07.25.57;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.05.14.04.10.21;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.05.25.04.57.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.05.25.09.42.16;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.06.02.10.05.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	98.06.11.10.02.55;	author matz;	state Exp;
branches;
next	1.1.1.2.2.26;

1.1.1.2.2.26
date	98.07.10.09.44.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.27;

1.1.1.2.2.27
date	98.07.13.04.37.22;	author matz;	state Exp;
branches;
next	1.1.1.2.2.28;

1.1.1.2.2.28
date	98.07.29.09.50.23;	author matz;	state Exp;
branches;
next	1.1.1.2.2.29;

1.1.1.2.2.29
date	98.08.14.03.56.17;	author matz;	state Exp;
branches
	1.1.1.2.2.29.2.1;
next	1.1.1.2.2.30;

1.1.1.2.2.30
date	98.11.09.09.11.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.31;

1.1.1.2.2.31
date	99.01.11.07.55.24;	author matz;	state Exp;
branches;
next	1.1.1.2.2.32;

1.1.1.2.2.32
date	99.01.21.09.04.50;	author matz;	state Exp;
branches;
next	1.1.1.2.2.33;

1.1.1.2.2.33
date	99.02.09.03.29.20;	author matz;	state Exp;
branches;
next	1.1.1.2.2.34;

1.1.1.2.2.34
date	99.04.08.10.14.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.35;

1.1.1.2.2.35
date	99.05.14.08.56.46;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.29.2.1
date	98.09.08.07.08.30;	author matz;	state Exp;
branches;
next	1.1.1.2.2.29.2.2;

1.1.1.2.2.29.2.2
date	98.10.06.03.28.02;	author matz;	state Exp;
branches;
next	1.1.1.2.2.29.2.3;

1.1.1.2.2.29.2.3
date	98.11.25.03.31.09;	author matz;	state Exp;
branches;
next	;

1.2.2.1
date	99.10.18.09.03.15;	author matz;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	99.10.18.09.07.13;	author matz;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2000.01.17.08.23.51;	author matz;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2000.03.23.04.14.07;	author matz;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2000.06.05.09.00.39;	author matz;	state Exp;
branches;
next	;

1.37.2.1
date	2001.02.19.07.41.24;	author matz;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2001.02.19.09.15.27;	author matz;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2001.03.13.05.51.40;	author matz;	state Exp;
branches;
next	1.37.2.4;

1.37.2.4
date	2001.05.01.08.45.10;	author matz;	state Exp;
branches;
next	1.37.2.5;

1.37.2.5
date	2001.05.15.08.49.20;	author matz;	state Exp;
branches;
next	1.37.2.6;

1.37.2.6
date	2001.05.16.06.01.14;	author matz;	state Exp;
branches;
next	1.37.2.7;

1.37.2.7
date	2001.08.14.08.10.59;	author matz;	state Exp;
branches;
next	1.37.2.8;

1.37.2.8
date	2001.08.24.06.36.14;	author matz;	state Exp;
branches;
next	1.37.2.9;

1.37.2.9
date	2001.10.02.04.25.51;	author matz;	state Exp;
branches;
next	1.37.2.10;

1.37.2.10
date	2001.11.13.08.22.26;	author matz;	state Exp;
branches;
next	1.37.2.11;

1.37.2.11
date	2001.12.17.08.13.16;	author nobu;	state Exp;
branches;
next	1.37.2.12;

1.37.2.12
date	2002.08.19.05.59.05;	author matz;	state Exp;
branches;
next	1.37.2.13;

1.37.2.13
date	2002.08.19.06.40.41;	author matz;	state Exp;
branches;
next	1.37.2.14;

1.37.2.14
date	2002.08.19.06.44.09;	author matz;	state Exp;
branches;
next	1.37.2.15;

1.37.2.15
date	2002.10.26.15.57.20;	author knu;	state Exp;
branches;
next	;

1.37.4.1
date	2001.01.12.04.35.59;	author matz;	state Exp;
branches;
next	;


desc
@@


1.96
log
@	* variable.c (rb_copy_generic_ivar): remove old generic instance
	  variable table if it existes.

	* class.c (rb_make_metaclass): metaclass of a metaclass is a
	  metaclass itself.
@
text
@/**********************************************************************

  array.c -

  $Author: matz $
  $Date: 2002/08/29 09:08:15 $
  created at: Fri Aug  6 09:46:12 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#include "ruby.h"
#include "util.h"
#include "st.h"

VALUE rb_cArray;
static ID id_cmp;

#define ARY_DEFAULT_SIZE 16

void
rb_mem_clear(mem, size)
    register VALUE *mem;
    register long size;
{
    while (size--) {
	*mem++ = Qnil;
    }
}

static void
memfill(mem, size, val)
    register VALUE *mem;
    register long size;
    register VALUE val;
{
    while (size--) {
	*mem++ = val;
    }
}

#define ARY_TMPLOCK  FL_USER1

static void
rb_ary_modify_check(ary)
    VALUE ary;
{
    if (OBJ_FROZEN(ary)) rb_error_frozen("array");
    if (FL_TEST(ary, ARY_TMPLOCK))
	rb_raise(rb_eTypeError, "can't modify array during sort");
    if (!OBJ_TAINTED(ary) && rb_safe_level() >= 4)
	rb_raise(rb_eSecurityError, "Insecure: can't modify array");
}

static void
rb_ary_modify(ary)
    VALUE ary;
{
    VALUE *ptr;

    rb_ary_modify_check(ary);
    if (FL_TEST(ary, ELTS_SHARED)) {
	ptr = ALLOC_N(VALUE, RARRAY(ary)->len);
	FL_UNSET(ary, ELTS_SHARED);
	RARRAY(ary)->aux.capa = RARRAY(ary)->len;
	MEMCPY(ptr, RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);
	RARRAY(ary)->ptr = ptr;
    }
}
VALUE
rb_ary_freeze(ary)
    VALUE ary;
{
    return rb_obj_freeze(ary);
}

static VALUE
rb_ary_frozen_p(ary)
    VALUE ary;
{
    if (FL_TEST(ary, FL_FREEZE|ARY_TMPLOCK))
	return Qtrue;
    return Qfalse;
}

static VALUE
rb_ary_s_alloc(klass)
    VALUE klass;
{
    NEWOBJ(ary, struct RArray);
    OBJSETUP(ary, klass, T_ARRAY);

    ary->len = 0;
    ary->ptr = 0;
    ary->aux.capa = 0;

    return (VALUE)ary;
}

static VALUE
ary_new(klass, len)
    VALUE klass;
    long len;
{
    VALUE ary = rb_obj_alloc(klass);

    if (len < 0) {
	rb_raise(rb_eArgError, "negative array size (or size too big)");
    }
    if (len > 0 && len * sizeof(VALUE) <= len) {
	rb_raise(rb_eArgError, "array size too big");
    }
    if (len == 0) len++;
    RARRAY(ary)->ptr = ALLOC_N(VALUE, len);
    RARRAY(ary)->aux.capa = len;

    return ary;
}

VALUE
rb_ary_new2(len)
    long len;
{
    return ary_new(rb_cArray, len);
}


VALUE
rb_ary_new()
{
    return rb_ary_new2(ARY_DEFAULT_SIZE);
}

#ifdef HAVE_STDARG_PROTOTYPES
#include <stdarg.h>
#define va_init_list(a,b) va_start(a,b)
#else
#include <varargs.h>
#define va_init_list(a,b) va_start(a)
#endif

VALUE
#ifdef HAVE_STDARG_PROTOTYPES
rb_ary_new3(long n, ...)
#else
rb_ary_new3(n, va_alist)
    long n;
    va_dcl
#endif
{
    va_list ar;
    VALUE ary;
    long i;

    ary = rb_ary_new2(n);

    va_init_list(ar, n);
    for (i=0; i<n; i++) {
	RARRAY(ary)->ptr[i] = va_arg(ar, VALUE);
    }
    va_end(ar);

    RARRAY(ary)->len = n;
    return ary;
}

VALUE
rb_ary_new4(n, elts)
    long n;
    const VALUE *elts;
{
    VALUE ary;

    ary = rb_ary_new2(n);
    if (n > 0 && elts) {
	MEMCPY(RARRAY(ary)->ptr, elts, VALUE, n);
    }
    RARRAY(ary)->len = n;

    return ary;
}

VALUE
rb_assoc_new(car, cdr)
    VALUE car, cdr;
{
    VALUE ary;

    ary = rb_ary_new2(2);
    RARRAY(ary)->ptr[0] = car;
    RARRAY(ary)->ptr[1] = cdr;
    RARRAY(ary)->len = 2;

    return ary;
}

static VALUE
to_ary(ary)
    VALUE ary;
{
    return rb_convert_type(ary, T_ARRAY, "Array", "to_ary");
}

static VALUE rb_ary_replace _((VALUE, VALUE));

static VALUE
rb_ary_initialize(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long len;
    VALUE size, val;

    rb_ary_modify(ary);
    if (rb_scan_args(argc, argv, "02", &size, &val) == 0) {
	RARRAY(ary)->len = 0;
	if (rb_block_given_p()) {
	    rb_warning("given block not used");
	}
	return ary;
    }

    if (argc == 1 && !FIXNUM_P(size)) {
	val = rb_check_convert_type(size, T_ARRAY, "Array", "to_ary");
	if (!NIL_P(val)) {
	    rb_ary_replace(ary, val);
	    return ary;
	}
    }

    len = NUM2LONG(size);
    if (len < 0) {
	rb_raise(rb_eArgError, "negative array size");
    }
    if (len > 0 && len * (long)sizeof(VALUE) <= len) {
	rb_raise(rb_eArgError, "array size too big");
    }
    if (len > RARRAY(ary)->aux.capa) {
	REALLOC_N(RARRAY(ary)->ptr, VALUE, len);
	RARRAY(ary)->aux.capa = len;
    }
    if (rb_block_given_p()) {
	long i;

	if (argc > 1) {
	    rb_raise(rb_eArgError, "wrong number of arguments");
	}
	for (i=0; i<len; i++) {
	    RARRAY(ary)->ptr[i] = rb_yield(LONG2NUM(i));
	    RARRAY(ary)->len = i + 1;
	}
    }
    else {
	memfill(RARRAY(ary)->ptr, len, val);
	RARRAY(ary)->len = len;
    }

    return ary;
}

static VALUE
rb_ary_s_create(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE ary = rb_obj_alloc(klass);

    if (argc < 0) {
	rb_raise(rb_eArgError, "negative number of arguments");
    }
    if (argc > 0) {
	RARRAY(ary)->ptr = ALLOC_N(VALUE, argc);
	MEMCPY(RARRAY(ary)->ptr, argv, VALUE, argc);
    }
    RARRAY(ary)->len = RARRAY(ary)->aux.capa = argc;

    return ary;
}

void
rb_ary_store(ary, idx, val)
    VALUE ary;
    long idx;
    VALUE val;
{
    rb_ary_modify(ary);
    if (idx < 0) {
	idx += RARRAY(ary)->len;
	if (idx < 0) {
	    rb_raise(rb_eIndexError, "index %ld out of array",
		    idx - RARRAY(ary)->len);
	}
    }

    if (idx >= RARRAY(ary)->aux.capa) {
	long new_capa = RARRAY(ary)->aux.capa / 2;

	if (new_capa < ARY_DEFAULT_SIZE) {
	    new_capa = ARY_DEFAULT_SIZE;
	}
	new_capa += idx;
	if (new_capa * (long)sizeof(VALUE) <= new_capa) {
	    rb_raise(rb_eArgError, "index too big");
	}
	REALLOC_N(RARRAY(ary)->ptr, VALUE, new_capa);
	RARRAY(ary)->aux.capa = new_capa;
    }
    if (idx > RARRAY(ary)->len) {
	rb_mem_clear(RARRAY(ary)->ptr + RARRAY(ary)->len,
		     idx-RARRAY(ary)->len + 1);
    }

    if (idx >= RARRAY(ary)->len) {
	RARRAY(ary)->len = idx + 1;
    }
    RARRAY(ary)->ptr[idx] = val;
}

VALUE
rb_ary_push(ary, item)
    VALUE ary;
    VALUE item;
{
    rb_ary_store(ary, RARRAY(ary)->len, item);
    return ary;
}

static VALUE
rb_ary_push_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    if (argc <= 0) {
	rb_raise(rb_eArgError, "wrong number arguments (at least 1)");
    }
    while (argc--) {
	rb_ary_push(ary, *argv++);
    }
    return ary;
}

VALUE
rb_ary_pop(ary)
    VALUE ary;
{
    rb_ary_modify_check(ary);
    if (RARRAY(ary)->len == 0) return Qnil;
    if (!FL_TEST(ary, ELTS_SHARED) &&
	    RARRAY(ary)->len * 2 < RARRAY(ary)->aux.capa &&
	    RARRAY(ary)->aux.capa > ARY_DEFAULT_SIZE) {
	RARRAY(ary)->aux.capa = RARRAY(ary)->len * 2;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->aux.capa);
    }
    return RARRAY(ary)->ptr[--RARRAY(ary)->len];
}

static void
ary_make_shared(ary)
    VALUE ary;
{
    if (!FL_TEST(ary, ELTS_SHARED)) {
	NEWOBJ(shared, struct RArray);
	OBJSETUP(shared, rb_cArray, T_ARRAY);

	shared->len = RARRAY(ary)->len;
	shared->ptr = RARRAY(ary)->ptr;
	shared->aux.capa = RARRAY(ary)->aux.capa;
	RARRAY(ary)->aux.shared = (VALUE)shared;
	FL_SET(ary, ELTS_SHARED);
    }
}

VALUE
rb_ary_shift(ary)
    VALUE ary;
{
    VALUE top;

    rb_ary_modify_check(ary);
    if (RARRAY(ary)->len == 0) return Qnil;
    top = RARRAY(ary)->ptr[0];
    ary_make_shared(ary);
    RARRAY(ary)->ptr++;		/* shift ptr */
    RARRAY(ary)->len--;

    return top;
}

VALUE
rb_ary_unshift(ary, item)
    VALUE ary, item;
{
    rb_ary_modify(ary);
    if (RARRAY(ary)->len == RARRAY(ary)->aux.capa) {
	long capa_inc = RARRAY(ary)->aux.capa / 2;
	if (capa_inc < ARY_DEFAULT_SIZE) {
	    capa_inc = ARY_DEFAULT_SIZE;
	}
	RARRAY(ary)->aux.capa += capa_inc;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->aux.capa);
    }

    /* sliding items */
    MEMMOVE(RARRAY(ary)->ptr + 1, RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);

    RARRAY(ary)->len++;
    RARRAY(ary)->ptr[0] = item;

    return ary;
}

static VALUE
rb_ary_unshift_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long len = RARRAY(ary)->len;
    
    if (argc <= 0) {
	rb_raise(rb_eArgError, "wrong number of arguments (at least 1)");
    }

    /* make rooms by setting the last item */
    rb_ary_store(ary, len + argc - 1, Qnil);

    /* sliding items */
    MEMMOVE(RARRAY(ary)->ptr + argc, RARRAY(ary)->ptr, VALUE, len);
    MEMCPY(RARRAY(ary)->ptr, argv, VALUE, argc);
    
    return ary;
}

VALUE
rb_ary_entry(ary, offset)
    VALUE ary;
    long offset;
{
    if (RARRAY(ary)->len == 0) return Qnil;

    if (offset < 0) {
	offset += RARRAY(ary)->len;
    }
    if (offset < 0 || RARRAY(ary)->len <= offset) {
	return Qnil;
    }

    return RARRAY(ary)->ptr[offset];
}

static VALUE
rb_ary_subseq(ary, beg, len)
    VALUE ary;
    long beg, len;
{
    VALUE klass, ary2;

    if (beg > RARRAY(ary)->len) return Qnil;
    if (beg < 0 || len < 0) return Qnil;

    if (beg + len > RARRAY(ary)->len) {
	len = RARRAY(ary)->len - beg;
	if (len < 0)
	    len = 0;
    }
    klass = rb_obj_class(ary);
    if (len == 0) return ary_new(klass, 0);

    ary_make_shared(ary);
    ary2 = rb_obj_alloc(klass);
    RARRAY(ary2)->ptr = RARRAY(ary)->ptr + beg;
    RARRAY(ary2)->len = len;
    RARRAY(ary2)->aux.shared = RARRAY(ary)->aux.shared;
    FL_SET(ary2, ELTS_SHARED);

    return ary2;
}

VALUE
rb_ary_aref(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE arg;
    long beg, len;

    if (argc == 2) {
	beg = NUM2LONG(argv[0]);
	len = NUM2LONG(argv[1]);
	if (beg < 0) {
	    beg += RARRAY(ary)->len;
	}
	return rb_ary_subseq(ary, beg, len);
    }
    if (argc != 1) {
	rb_scan_args(argc, argv, "11", 0, 0);
    }
    arg = argv[0];
    /* special case - speeding up */
    if (FIXNUM_P(arg)) {
	return rb_ary_entry(ary, FIX2LONG(arg));
    }
    /* check if idx is Range */
    switch (rb_range_beg_len(arg, &beg, &len, RARRAY(ary)->len, 0)) {
      case Qfalse:
	break;
      case Qnil:
	return Qnil;
      default:
	return rb_ary_subseq(ary, beg, len);
    }
    return rb_ary_entry(ary, NUM2LONG(arg));
}

static VALUE
rb_ary_at(ary, pos)
    VALUE ary, pos;
{
    return rb_ary_entry(ary, NUM2LONG(pos));
}

static VALUE
rb_ary_first(ary)
    VALUE ary;
{
    if (RARRAY(ary)->len == 0) return Qnil;
    return RARRAY(ary)->ptr[0];
}

static VALUE
rb_ary_last(ary)
    VALUE ary;
{
    if (RARRAY(ary)->len == 0) return Qnil;
    return RARRAY(ary)->ptr[RARRAY(ary)->len-1];
}

static VALUE
rb_ary_fetch(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE pos, ifnone;
    long idx;

    rb_scan_args(argc, argv, "11", &pos, &ifnone);
    idx = NUM2LONG(pos);

    if (idx < 0) {
	idx +=  RARRAY(ary)->len;
    }
    if (idx < 0 || RARRAY(ary)->len <= idx) {
	if (rb_block_given_p()) {
	    if (argc > 1) {
		rb_raise(rb_eArgError, "wrong number of arguments");
	    }
	    return rb_yield(pos);
	}
	if (argc == 1) {
	    rb_raise(rb_eIndexError, "index %ld out of array", idx);
	}
	return ifnone;
    }
    return RARRAY(ary)->ptr[idx];
}

static VALUE
rb_ary_index(ary, val)
    VALUE ary;
    VALUE val;
{
    long i;

    for (i=0; i<RARRAY(ary)->len; i++) {
	if (rb_equal(RARRAY(ary)->ptr[i], val))
	    return LONG2NUM(i);
    }
    return Qnil;
}

static VALUE
rb_ary_rindex(ary, val)
    VALUE ary;
    VALUE val;
{
    long i = RARRAY(ary)->len;

    while (i--) {
	if (rb_equal(RARRAY(ary)->ptr[i], val))
	    return LONG2NUM(i);
    }
    return Qnil;
}

static VALUE
rb_ary_indexes(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE new_ary;
    long i;

    rb_warn("Array#%s is deprecated; use Array#select",
	    rb_id2name(rb_frame_last_func()));
    new_ary = rb_ary_new2(argc);
    for (i=0; i<argc; i++) {
	rb_ary_push(new_ary, rb_ary_aref(1, argv+i, ary));
    }

    return new_ary;
}

VALUE
rb_ary_to_ary(obj)
    VALUE obj;
{
    if (NIL_P(obj)) return rb_ary_new2(0);
    if (TYPE(obj) == T_ARRAY) {
	return obj;
    }
    if (rb_respond_to(obj, rb_intern("to_ary"))) {
	return rb_convert_type(obj, T_ARRAY, "Array", "to_ary");
    }
    return rb_ary_new3(1, obj);
}

static void
rb_ary_update(ary, beg, len, rpl)
    VALUE ary;
    long beg, len;
    VALUE rpl;
{
    long rlen;

    rpl = rb_ary_to_ary(rpl);
    rlen = RARRAY(rpl)->len;

    if (len < 0) rb_raise(rb_eIndexError, "negative length (%ld)", len);
    if (beg < 0) {
	beg += RARRAY(ary)->len;
	if (beg < 0) {
	    beg -= RARRAY(ary)->len;
	    rb_raise(rb_eIndexError, "index %ld out of array", beg);
	}
    }
    if (beg + len > RARRAY(ary)->len) {
	len = RARRAY(ary)->len - beg;
    }

    rb_ary_modify(ary);
    if (beg >= RARRAY(ary)->len) {
	len = beg + rlen;
	if (len >= RARRAY(ary)->aux.capa) {
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, len);
	    RARRAY(ary)->aux.capa = len;
	}
	rb_mem_clear(RARRAY(ary)->ptr + RARRAY(ary)->len, beg - RARRAY(ary)->len);
	MEMCPY(RARRAY(ary)->ptr + beg, RARRAY(rpl)->ptr, VALUE, rlen);
	RARRAY(ary)->len = len;
    }
    else {
	long alen;

	if (beg + len > RARRAY(ary)->len) {
	    len = RARRAY(ary)->len - beg;
	}

	alen = RARRAY(ary)->len + rlen - len;
	if (alen >= RARRAY(ary)->aux.capa) {
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, alen);
	    RARRAY(ary)->aux.capa = alen;
	}

	if (len != rlen) {
	    MEMMOVE(RARRAY(ary)->ptr + beg + rlen, RARRAY(ary)->ptr + beg + len,
		    VALUE, RARRAY(ary)->len - (beg + len));
	    RARRAY(ary)->len = alen;
	}
	MEMMOVE(RARRAY(ary)->ptr + beg, RARRAY(rpl)->ptr, VALUE, rlen);
    }
}

static VALUE
rb_ary_aset(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long offset, beg, len;

    if (argc == 3) {
	rb_ary_update(ary, NUM2LONG(argv[0]), NUM2LONG(argv[1]), argv[2]);
	return argv[2];
    }
    if (argc != 2) {
	rb_raise(rb_eArgError, "wrong number of arguments (%d for 2)", argc);
    }
    if (FIXNUM_P(argv[0])) {
	offset = FIX2LONG(argv[0]);
	goto fixnum;
    }
    if (rb_range_beg_len(argv[0], &beg, &len, RARRAY(ary)->len, 1)) {
	/* check if idx is Range */
	rb_ary_update(ary, beg, len, argv[1]);
	return argv[1];
    }

    offset = NUM2LONG(argv[0]);
fixnum:
    rb_ary_store(ary, offset, argv[1]);
    return argv[1];
}

static VALUE
rb_ary_insert(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long pos;

    if (argc < 2) {
	rb_raise(rb_eArgError, "wrong number of arguments (at least 2)");
    }
    pos = NUM2LONG(argv[0]);
    if (pos == -1) {
	pos = RARRAY(ary)->len;
    }
    else if (pos < 0) {
	pos++;
    }

    rb_ary_update(ary, pos, 0, rb_ary_new4(argc - 1, argv + 1));
    return ary;
}

VALUE
rb_ary_each(ary)
    VALUE ary;
{
    long i;

    for (i=0; i<RARRAY(ary)->len; i++) {
	rb_yield(RARRAY(ary)->ptr[i]);
    }
    return ary;
}

static VALUE
rb_ary_each_index(ary)
    VALUE ary;
{
    long i;

    for (i=0; i<RARRAY(ary)->len; i++) {
	rb_yield(LONG2NUM(i));
    }
    return ary;
}

static VALUE
rb_ary_reverse_each(ary)
    VALUE ary;
{
    long len = RARRAY(ary)->len;

    while (len--) {
	rb_yield(RARRAY(ary)->ptr[len]);
    }
    return ary;
}

static VALUE
rb_ary_length(ary)
    VALUE ary;
{
    return LONG2NUM(RARRAY(ary)->len);
}

static VALUE
rb_ary_empty_p(ary)
    VALUE ary;
{
    if (RARRAY(ary)->len == 0)
	return Qtrue;
    return Qfalse;
}

VALUE
rb_ary_dup(ary)
    VALUE ary;
{
    VALUE dup = rb_ary_new2(RARRAY(ary)->len);

    DUPSETUP(dup, ary);
    MEMCPY(RARRAY(dup)->ptr, RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);
    RARRAY(dup)->len = RARRAY(ary)->len;
    return dup;
}

extern VALUE rb_output_fs;

static VALUE
inspect_join(ary, arg)
    VALUE ary;
    VALUE *arg;
{
    return rb_ary_join(arg[0], arg[1]);
}

VALUE
rb_ary_join(ary, sep)
    VALUE ary, sep;
{
    long len = 1, i;
    int taint = Qfalse;
    VALUE result, tmp;

    if (RARRAY(ary)->len == 0) return rb_str_new(0, 0);
    if (OBJ_TAINTED(ary) || OBJ_TAINTED(sep)) taint = Qtrue;

    for (i=0; i<RARRAY(ary)->len; i++) {
	if (TYPE(RARRAY(ary)->ptr[i]) == T_STRING) {
	    len += RSTRING(RARRAY(ary)->ptr[i])->len;
	}
	else {
	    len += 10;
	}
    }
    if (!NIL_P(sep)) {
	StringValue(sep);
	len += RSTRING(sep)->len * (RARRAY(ary)->len - 1);
    }
    result = rb_str_buf_new(len);
    for (i=0; i<RARRAY(ary)->len; i++) {
	tmp = RARRAY(ary)->ptr[i];
	switch (TYPE(tmp)) {
	  case T_STRING:
	    break;
	  case T_ARRAY:
	    if (rb_inspecting_p(tmp)) {
		tmp = rb_str_new2("[...]");
	    }
	    else {
		VALUE args[2];

		args[0] = tmp;
		args[1] = sep;
		tmp = rb_protect_inspect(inspect_join, ary, (VALUE)args);
	    }
	    break;
	  default:
	    tmp = rb_obj_as_string(tmp);
	}
	if (i > 0 && !NIL_P(sep))
	    rb_str_buf_append(result, sep);
	rb_str_buf_append(result, tmp);
	if (OBJ_TAINTED(tmp)) taint = Qtrue;
    }

    if (taint) OBJ_TAINT(result);
    return result;
}

static VALUE
rb_ary_join_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE sep;

    rb_scan_args(argc, argv, "01", &sep);
    if (NIL_P(sep)) sep = rb_output_fs;
    
    return rb_ary_join(ary, sep);
}

VALUE
rb_ary_to_s(ary)
    VALUE ary;
{
    if (RARRAY(ary)->len == 0) return rb_str_new(0, 0);
    
    return rb_ary_join(ary, rb_output_fs);
}

static ID inspect_key;

struct inspect_arg {
    VALUE (*func)();
    VALUE arg1, arg2;
};

static VALUE
inspect_call(arg)
    struct inspect_arg *arg;
{
    return (*arg->func)(arg->arg1, arg->arg2);
}

static VALUE
inspect_ensure(obj)
    VALUE obj;
{
    VALUE inspect_tbl;

    inspect_tbl = rb_thread_local_aref(rb_thread_current(), inspect_key);
    rb_ary_pop(inspect_tbl);
    return 0;
}

VALUE
rb_protect_inspect(func, obj, arg)
    VALUE (*func)(ANYARGS);
    VALUE obj, arg;
{
    struct inspect_arg iarg;
    VALUE inspect_tbl;
    VALUE id;

    inspect_tbl = rb_thread_local_aref(rb_thread_current(), inspect_key);
    if (NIL_P(inspect_tbl)) {
	inspect_tbl = rb_ary_new();
	rb_thread_local_aset(rb_thread_current(), inspect_key, inspect_tbl);
    }
    id = rb_obj_id(obj);
    if (rb_ary_includes(inspect_tbl, id)) {
	return (*func)(obj, arg);
    }
    rb_ary_push(inspect_tbl, id);
    iarg.func = func;
    iarg.arg1 = obj;
    iarg.arg2 = arg;

    return rb_ensure(inspect_call, (VALUE)&iarg, inspect_ensure, obj);
}

VALUE
rb_inspecting_p(obj)
    VALUE obj;
{
    VALUE inspect_tbl;

    inspect_tbl = rb_thread_local_aref(rb_thread_current(), inspect_key);
    if (NIL_P(inspect_tbl)) return Qfalse;
    return rb_ary_includes(inspect_tbl, rb_obj_id(obj));
}

static VALUE
inspect_ary(ary)
    VALUE ary;
{
    int tainted = OBJ_TAINTED(ary);
    long i;
    VALUE s, str;

    str = rb_str_buf_new2("[");
    for (i=0; i<RARRAY(ary)->len; i++) {
	s = rb_inspect(RARRAY(ary)->ptr[i]);
	if (OBJ_TAINTED(s)) tainted = Qtrue;
	if (i > 0) rb_str_buf_cat2(str, ", ");
	rb_str_buf_append(str, s);
    }
    rb_str_buf_cat2(str, "]");
    if (tainted) OBJ_TAINT(str);
    return str;
}

static VALUE
rb_ary_inspect(ary)
    VALUE ary;
{
    if (RARRAY(ary)->len == 0) return rb_str_new2("[]");
    if (rb_inspecting_p(ary)) return rb_str_new2("[...]");
    return rb_protect_inspect(inspect_ary, ary, 0);
}

static VALUE
rb_ary_to_a(ary)
    VALUE ary;
{
    return ary;
}

VALUE
rb_ary_reverse(ary)
    VALUE ary;
{
    VALUE *p1, *p2;
    VALUE tmp;

    rb_ary_modify(ary);
    if (RARRAY(ary)->len <= 1) return ary;

    p1 = RARRAY(ary)->ptr;
    p2 = p1 + RARRAY(ary)->len - 1;	/* points last item */

    while (p1 < p2) {
	tmp = *p1;
	*p1++ = *p2;
	*p2-- = tmp;
    }

    return ary;
}

static VALUE
rb_ary_reverse_bang(ary)
    VALUE ary;
{
    if (RARRAY(ary)->len <= 1) return Qnil;
    return rb_ary_reverse(ary);
}

static VALUE
rb_ary_reverse_m(ary)
    VALUE ary;
{
    return rb_ary_reverse(rb_ary_dup(ary));
}

int
rb_cmpint(cmp)
    VALUE cmp;
{
    if (FIXNUM_P(cmp)) return FIX2INT(cmp);
    if (TYPE(cmp) == T_BIGNUM) {
	if (RBIGNUM(cmp)->sign) return 1;
	return -1;
    }
    if (RTEST(rb_funcall(cmp, '>', 1, INT2FIX(0)))) return 1;
    if (RTEST(rb_funcall(cmp, '<', 1, INT2FIX(0)))) return -1;
    return 0;
}

static int
sort_1(a, b)
    VALUE *a, *b;
{
    VALUE retval = rb_yield(rb_assoc_new(*a, *b));
    return rb_cmpint(retval);
}

static int
sort_2(ap, bp)
    VALUE *ap, *bp;
{
    VALUE retval;
    long a = (long)*ap, b = (long)*bp;

    if (FIXNUM_P(a) && FIXNUM_P(b)) {
	if (a > b) return 1;
	if (a < b) return -1;
	return 0;
    }
    if (TYPE(a) == T_STRING && TYPE(b) == T_STRING) {
	return rb_str_cmp(a, b);
    }

    retval = rb_funcall(a, id_cmp, 1, b);
    return rb_cmpint(retval);
}

static VALUE
sort_internal(ary)
    VALUE ary;
{
    qsort(RARRAY(ary)->ptr, RARRAY(ary)->len, sizeof(VALUE),
	  rb_block_given_p()?sort_1:sort_2);
    return ary;
}

static VALUE
sort_unlock(ary)
    VALUE ary;
{
    FL_UNSET(ary, ARY_TMPLOCK);
    return ary;
}

VALUE
rb_ary_sort_bang(ary)
    VALUE ary;
{
    rb_ary_modify(ary);
    if (RARRAY(ary)->len <= 1) return ary;

    FL_SET(ary, ARY_TMPLOCK);	/* prohibit modification during sort */
    rb_ensure(sort_internal, ary, sort_unlock, ary);
    return ary;
}

VALUE
rb_ary_sort(ary)
    VALUE ary;
{
    ary = rb_ary_dup(ary);
    rb_ary_sort_bang(ary);
    return ary;
}

static VALUE
rb_ary_collect(ary)
    VALUE ary;
{
    long len, i;
    VALUE collect;

    if (!rb_block_given_p()) {
	return rb_ary_new4(RARRAY(ary)->len, RARRAY(ary)->ptr);
    }

    len = RARRAY(ary)->len;
    collect = rb_ary_new2(len);
    for (i=0; i<len; i++) {
	rb_ary_push(collect, rb_yield(RARRAY(ary)->ptr[i]));
    }
    return collect;
}

static VALUE
rb_ary_collect_bang(ary)
    VALUE ary;
{
    long i;

    rb_ary_modify(ary);
    for (i = 0; i < RARRAY(ary)->len; i++) {
	RARRAY(ary)->ptr[i] = rb_yield(RARRAY(ary)->ptr[i]);
    }
    return ary;
}

static VALUE
rb_ary_select(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE result;
    long i;

    if (rb_block_given_p()) {
	if (argc > 0) {
	    rb_raise(rb_eArgError, "wrong number arguments (%d for 0)", argc);
	}
	result = rb_ary_new2(RARRAY(ary)->len);
	for (i = 0; i < RARRAY(ary)->len; i++) {
	    if (RTEST(rb_yield(RARRAY(ary)->ptr[i]))) {
		rb_ary_push(result, RARRAY(ary)->ptr[i]);
	    }
	}
    }
    else {
	result = rb_ary_new2(argc);
	for (i=0; i<argc; i++) {
	    rb_ary_push(result, rb_ary_entry(ary, NUM2LONG(argv[i])));
	}
    }
    return result;
}

VALUE
rb_ary_delete(ary, item)
    VALUE ary;
    VALUE item;
{
    long i1, i2;

    rb_ary_modify(ary);
    for (i1 = i2 = 0; i1 < RARRAY(ary)->len; i1++) {
	if (rb_equal(RARRAY(ary)->ptr[i1], item)) continue;
	if (i1 != i2) {
	    RARRAY(ary)->ptr[i2] = RARRAY(ary)->ptr[i1];
	}
	i2++;
    }
    if (RARRAY(ary)->len == i2) {
	if (rb_block_given_p()) {
	    return rb_yield(item);
	}
	return Qnil;
    }

    RARRAY(ary)->len = i2;
    if (i2 * 2 < RARRAY(ary)->aux.capa &&
	    RARRAY(ary)->aux.capa > ARY_DEFAULT_SIZE) {
	REALLOC_N(RARRAY(ary)->ptr, VALUE, i2 * 2);
	RARRAY(ary)->aux.capa = i2 * 2;
    }

    return item;
}

VALUE
rb_ary_delete_at(ary, pos)
    VALUE ary;
    long pos;
{
    long i, len = RARRAY(ary)->len;
    VALUE del;

    rb_ary_modify(ary);
    if (pos >= len) return Qnil;
    if (pos < 0) {
	pos += len;
	if (pos < 0) return Qnil;
    }

    del = RARRAY(ary)->ptr[pos];
    for (i = pos + 1; i < len; i++, pos++) {
	RARRAY(ary)->ptr[pos] = RARRAY(ary)->ptr[i];
    }
    RARRAY(ary)->len = pos;

    return del;
}

static VALUE
rb_ary_delete_at_m(ary, pos)
    VALUE ary, pos;
{
    return rb_ary_delete_at(ary, NUM2LONG(pos));
}

static VALUE
rb_ary_slice_bang(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE arg1, arg2;
    long pos, len;

    rb_ary_modify(ary);
    if (rb_scan_args(argc, argv, "11", &arg1, &arg2) == 2) {
	pos = NUM2LONG(arg1);
	len = NUM2LONG(arg2);
      delete_pos_len:
	if (pos < 0) {
	    pos = RARRAY(ary)->len + pos;
	}
	arg2 = rb_ary_subseq(ary, pos, len);
	rb_ary_update(ary, pos, len, Qnil);	/* Qnil/rb_ary_new2(0) */
	return arg2;
    }

    if (!FIXNUM_P(arg1) && rb_range_beg_len(arg1, &pos, &len, RARRAY(ary)->len, 1)) {
	goto delete_pos_len;
    }

    return rb_ary_delete_at(ary, NUM2LONG(arg1));
}

static VALUE
rb_ary_reject_bang(ary)
    VALUE ary;
{
    long i1, i2;

    rb_ary_modify(ary);
    for (i1 = i2 = 0; i1 < RARRAY(ary)->len; i1++) {
	if (RTEST(rb_yield(RARRAY(ary)->ptr[i1]))) continue;
	if (i1 != i2) {
	    RARRAY(ary)->ptr[i2] = RARRAY(ary)->ptr[i1];
	}
	i2++;
    }
    if (RARRAY(ary)->len == i2) return Qnil;
    RARRAY(ary)->len = i2;

    return ary;
}

static VALUE
rb_ary_reject(ary)
    VALUE ary;
{
    ary = rb_ary_dup(ary);
    rb_ary_reject_bang(ary);
    return ary;
}

static VALUE
rb_ary_delete_if(ary)
    VALUE ary;
{
    rb_ary_reject_bang(ary);
    return ary;
}

static VALUE
rb_ary_replace(copy, orig)
    VALUE copy, orig;
{
    rb_ary_modify(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;
    ary_make_shared(orig);
    if (RARRAY(copy)->ptr && !FL_TEST(copy, ELTS_SHARED))
	free(RARRAY(copy)->ptr);
    RARRAY(copy)->ptr = RARRAY(orig)->ptr;
    RARRAY(copy)->len = RARRAY(orig)->len;
    RARRAY(copy)->aux.shared = RARRAY(orig)->aux.shared;
    FL_SET(copy, ELTS_SHARED);

    return copy;
}

VALUE
rb_ary_clear(ary)
    VALUE ary;
{
    rb_ary_modify(ary);
    RARRAY(ary)->len = 0;
    if (ARY_DEFAULT_SIZE * 2 < RARRAY(ary)->aux.capa) {
	REALLOC_N(RARRAY(ary)->ptr, VALUE, ARY_DEFAULT_SIZE * 2);
	RARRAY(ary)->aux.capa = ARY_DEFAULT_SIZE * 2;
    }
    return ary;
}

static VALUE
rb_ary_fill(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE item, arg1, arg2;
    long beg, end, len;
    VALUE *p, *pend;
    int block_p = Qfalse;

    if (rb_block_given_p()) {
	block_p = Qtrue;
	rb_scan_args(argc, argv, "02", &arg1, &arg2);
	argc += 1;		/* hackish */
    }
    else {
	rb_scan_args(argc, argv, "12", &item, &arg1, &arg2);
    }
    switch (argc) {
      case 1:
	beg = 0;
	len = RARRAY(ary)->len;
	break;
      case 2:
	if (rb_range_beg_len(arg1, &beg, &len, RARRAY(ary)->len, 1)) {
	    break;
	}
	/* fall through */
      case 3:
	beg = NIL_P(arg1) ? 0 : NUM2LONG(arg1);
	if (beg < 0) {
	    beg = RARRAY(ary)->len + beg;
	    if (beg < 0) beg = 0;
	}
	len = NIL_P(arg2) ? RARRAY(ary)->len - beg : NUM2LONG(arg2);
	break;
    }
    rb_ary_modify(ary);
    end = beg + len;
    if (end > RARRAY(ary)->len) {
	if (end >= RARRAY(ary)->aux.capa) {
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, end);
	    RARRAY(ary)->aux.capa = end;
	}
	if (beg > RARRAY(ary)->len) {
	    rb_mem_clear(RARRAY(ary)->ptr + RARRAY(ary)->len, end - RARRAY(ary)->len);
	}
	RARRAY(ary)->len = end;
    }
    p = RARRAY(ary)->ptr + beg;
    pend = p + len;

    if (block_p) {
	while (p < pend) {
	    *p++ = rb_yield(LONG2NUM(beg++));
	}
    }
    else {
	while (p < pend) {
	    *p++ = item;
	}
    }
    return ary;
}

VALUE
rb_ary_plus(x, y)
    VALUE x, y;
{
    VALUE z;
    long len;

    y = to_ary(y);
    len = RARRAY(x)->len + RARRAY(y)->len;
    z = rb_ary_new2(len);
    MEMCPY(RARRAY(z)->ptr, RARRAY(x)->ptr, VALUE, RARRAY(x)->len);
    MEMCPY(RARRAY(z)->ptr + RARRAY(x)->len, RARRAY(y)->ptr, VALUE, RARRAY(y)->len);
    RARRAY(z)->len = len;
    return z;
}

VALUE
rb_ary_concat(x, y)
    VALUE x, y;
{
    y = to_ary(y);
    if (RARRAY(y)->len > 0) {
	rb_ary_update(x, RARRAY(x)->len, 0, y);
    }
    return x;
}

static VALUE
rb_ary_times(ary, times)
    VALUE ary, times;
{
    VALUE ary2;
    long i, len;

    if (TYPE(times) == T_STRING) {
	return rb_ary_join(ary, times);
    }

    len = NUM2LONG(times);
    if (len < 0) {
	rb_raise(rb_eArgError, "negative argument");
    }
    len *= RARRAY(ary)->len;

    ary2 = ary_new(rb_obj_class(ary), len);
    RARRAY(ary2)->len = len;

    for (i=0; i<len; i+=RARRAY(ary)->len) {
	MEMCPY(RARRAY(ary2)->ptr+i, RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);
    }
    OBJ_INFECT(ary2, ary);

    return ary2;
}

VALUE
rb_ary_assoc(ary, key)
    VALUE ary, key;
{
    VALUE *p, *pend;

    p = RARRAY(ary)->ptr;
    pend = p + RARRAY(ary)->len;
    
    while (p < pend) {
	if (TYPE(*p) == T_ARRAY &&
		RARRAY(*p)->len > 0 &&
		rb_equal(RARRAY(*p)->ptr[0], key))
	    return *p;
	p++;
    }
    return Qnil;
}

VALUE
rb_ary_rassoc(ary, value)
    VALUE ary, value;
{
    VALUE *p, *pend;

    p = RARRAY(ary)->ptr;
    pend = p + RARRAY(ary)->len;

    while (p < pend) {
	if (TYPE(*p) == T_ARRAY
	    && RARRAY(*p)->len > 1
	    && rb_equal(RARRAY(*p)->ptr[1], value))
	    return *p;
	p++;
    }
    return Qnil;
}

static VALUE
rb_ary_equal(ary1, ary2)
    VALUE ary1, ary2;
{
    long i;

    if (ary1 == ary2) return Qtrue;
    if (TYPE(ary2) != T_ARRAY) return Qfalse;
    if (RARRAY(ary1)->len != RARRAY(ary2)->len) return Qfalse;
    for (i=0; i<RARRAY(ary1)->len; i++) {
	if (!rb_equal(RARRAY(ary1)->ptr[i], RARRAY(ary2)->ptr[i]))
	    return Qfalse;
    }
    return Qtrue;
}

static VALUE
rb_ary_eql(ary1, ary2)
    VALUE ary1, ary2;
{
    long i;

    if (TYPE(ary2) != T_ARRAY) return Qfalse;
    if (RARRAY(ary1)->len != RARRAY(ary2)->len) return Qfalse;
    for (i=0; i<RARRAY(ary1)->len; i++) {
	if (!rb_eql(RARRAY(ary1)->ptr[i], RARRAY(ary2)->ptr[i]))
	    return Qfalse;
    }
    return Qtrue;
}

static VALUE
rb_ary_hash(ary)
    VALUE ary;
{
    long i, h;
    VALUE n;

    h = RARRAY(ary)->len;
    for (i=0; i<RARRAY(ary)->len; i++) {
	h = (h << 1) | (h<0 ? 1 : 0);
	n = rb_hash(RARRAY(ary)->ptr[i]);
	h ^= NUM2LONG(n);
    }
    return LONG2FIX(h);
}

VALUE
rb_ary_includes(ary, item)
    VALUE ary;
    VALUE item;
{
    long i;
    
    for (i=0; i<RARRAY(ary)->len; i++) {
	if (rb_equal(RARRAY(ary)->ptr[i], item)) {
	    return Qtrue;
	}
    }
    return Qfalse;
}

VALUE
rb_ary_cmp(ary1, ary2)
    VALUE ary1, ary2;
{
    long i, len;

    ary2 = to_ary(ary2);
    len = RARRAY(ary1)->len;
    if (len > RARRAY(ary2)->len) {
	len = RARRAY(ary2)->len;
    }
    for (i=0; i<len; i++) {
	VALUE v = rb_funcall(RARRAY(ary1)->ptr[i], id_cmp, 1, RARRAY(ary2)->ptr[i]);
	if (v != INT2FIX(0)) {
	    return v;
	}
    }
    len = RARRAY(ary1)->len - RARRAY(ary2)->len;
    if (len == 0) return INT2FIX(0);
    if (len > 0) return INT2FIX(1);
    return INT2FIX(-1);
}

static VALUE
rb_ary_diff(ary1, ary2)
    VALUE ary1, ary2;
{
    VALUE ary3;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new();
    for (i=0; i<RARRAY(ary1)->len; i++) {
	if (rb_ary_includes(ary2, RARRAY(ary1)->ptr[i])) continue;
	if (rb_ary_includes(ary3, RARRAY(ary1)->ptr[i])) continue;
	rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
    }
    return ary3;
}

static VALUE
ary_make_hash(ary1, ary2)
    VALUE ary1, ary2;
{
    VALUE hash = rb_hash_new();
    long i;

    for (i=0; i<RARRAY(ary1)->len; i++) {
	rb_hash_aset(hash, RARRAY(ary1)->ptr[i], Qtrue);
    }
    if (ary2) {
	for (i=0; i<RARRAY(ary2)->len; i++) {
	    rb_hash_aset(hash, RARRAY(ary2)->ptr[i], Qtrue);
	}
    }
    return hash;
}

static VALUE
rb_ary_and(ary1, ary2)
    VALUE ary1, ary2;
{
    VALUE hash, ary3;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new2(RARRAY(ary1)->len < RARRAY(ary2)->len ?
	    RARRAY(ary1)->len : RARRAY(ary2)->len);
    hash = ary_make_hash(ary2, 0);

    for (i=0; i<RARRAY(ary1)->len; i++) {
	VALUE v = RARRAY(ary1)->ptr[i];
	if (st_delete(RHASH(hash)->tbl, &v, 0)) {
	    rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
	}
    }

    return ary3;
}

static VALUE
rb_ary_or(ary1, ary2)
    VALUE ary1, ary2;
{
    VALUE hash, ary3;
    VALUE v;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new2(RARRAY(ary1)->len+RARRAY(ary2)->len);
    hash = ary_make_hash(ary1, ary2);

    for (i=0; i<RARRAY(ary1)->len; i++) {
	v = RARRAY(ary1)->ptr[i];
	if (st_delete(RHASH(hash)->tbl, &v, 0)) {
	    rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
	}
    }
    for (i=0; i<RARRAY(ary2)->len; i++) {
	v = RARRAY(ary2)->ptr[i];
	if (st_delete(RHASH(hash)->tbl, &v, 0)) {
	    rb_ary_push(ary3, RARRAY(ary2)->ptr[i]);
	}
    }
    return ary3;
}

static VALUE
rb_ary_uniq_bang(ary)
    VALUE ary;
{
    VALUE hash;
    VALUE *p, *q, *end;

    rb_ary_modify(ary); 

    hash = ary_make_hash(ary, 0);

    if (RARRAY(ary)->len == RHASH(hash)->tbl->num_entries) {
	return Qnil;
    }
    p = q = RARRAY(ary)->ptr;
    end = p + RARRAY(ary)->len;
    while (p < end) {
	VALUE v = *p;
	if (st_delete(RHASH(hash)->tbl, &v, 0)) {
	    *q++ = *p;
	}
	p++;
    }
    RARRAY(ary)->len = (q - RARRAY(ary)->ptr);

    return ary;
}

static VALUE
rb_ary_uniq(ary)
    VALUE ary;
{
    ary = rb_ary_dup(ary);
    rb_ary_uniq_bang(ary);
    return ary;
}

static VALUE
rb_ary_compact_bang(ary)
    VALUE ary;
{
    VALUE *p, *t, *end;

    rb_ary_modify(ary);
    p = t = RARRAY(ary)->ptr;
    end = p + RARRAY(ary)->len;
    
    while (t < end) {
	if (NIL_P(*t)) t++;
	else *p++ = *t++;
    }
    if (RARRAY(ary)->len == (p - RARRAY(ary)->ptr)) {
	return Qnil;
    }
    RARRAY(ary)->len = RARRAY(ary)->aux.capa = (p - RARRAY(ary)->ptr);
    REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);

    return ary;
}

static VALUE
rb_ary_compact(ary)
    VALUE ary;
{
    ary = rb_ary_dup(ary);
    rb_ary_compact_bang(ary);
    return ary;
}

static VALUE
rb_ary_nitems(ary)
    VALUE ary;
{
    long n = 0;
    VALUE *p, *pend;

    p = RARRAY(ary)->ptr;
    pend = p + RARRAY(ary)->len;

    while (p < pend) {
	if (!NIL_P(*p)) n++;
	p++;
    }
    return LONG2NUM(n);
}

static long
flatten(ary, idx, ary2, memo)
    VALUE ary;
    long idx;
    VALUE ary2, memo;
{
    VALUE id;
    long i = idx;
    long n, lim = idx + RARRAY(ary2)->len;

    id = rb_obj_id(ary2);
    if (rb_ary_includes(memo, id)) {
	rb_raise(rb_eArgError, "tried to flatten recursive array");
    }
    rb_ary_push(memo, id);
    rb_ary_update(ary, idx, 1, ary2);
    while (i < lim) {
	if (TYPE(RARRAY(ary)->ptr[i]) == T_ARRAY) {
	    n = flatten(ary, i, RARRAY(ary)->ptr[i], memo);
	    i += n; lim += n;
	}
	i++;
    }
    rb_ary_pop(memo);

    return lim - idx - 1;	/* returns number of increased items */
}

static VALUE
rb_ary_flatten_bang(ary)
    VALUE ary;
{
    long i = 0;
    int mod = 0;
    VALUE memo = Qnil;

    rb_ary_modify(ary);
    while (i<RARRAY(ary)->len) {
	VALUE ary2 = RARRAY(ary)->ptr[i];

	if (TYPE(ary2) == T_ARRAY) {
	    if (NIL_P(memo)) {
		memo = rb_ary_new();
	    }
	    i += flatten(ary, i, ary2, memo);
	    mod = 1;
	}
	i++;
    }
    if (mod == 0) return Qnil;
    return ary;
}

static VALUE
rb_ary_flatten(ary)
    VALUE ary;
{
    ary = rb_ary_dup(ary);
    rb_ary_flatten_bang(ary);
    return ary;
}

void
Init_Array()
{
    rb_cArray  = rb_define_class("Array", rb_cObject);
    rb_include_module(rb_cArray, rb_mEnumerable);

    rb_define_singleton_method(rb_cArray, "allocate", rb_ary_s_alloc, 0);
    rb_define_singleton_method(rb_cArray, "[]", rb_ary_s_create, -1);
    rb_define_method(rb_cArray, "initialize", rb_ary_initialize, -1);
    rb_define_method(rb_cArray, "to_s", rb_ary_to_s, 0);
    rb_define_method(rb_cArray, "inspect", rb_ary_inspect, 0);
    rb_define_method(rb_cArray, "to_a", rb_ary_to_a, 0);
    rb_define_method(rb_cArray, "to_ary", rb_ary_to_a, 0);
    rb_define_method(rb_cArray, "frozen?",  rb_ary_frozen_p, 0);

    rb_define_method(rb_cArray, "==", rb_ary_equal, 1);
    rb_define_method(rb_cArray, "eql?", rb_ary_eql, 1);
    rb_define_method(rb_cArray, "hash", rb_ary_hash, 0);
    rb_define_method(rb_cArray, "===", rb_ary_equal, 1);

    rb_define_method(rb_cArray, "[]", rb_ary_aref, -1);
    rb_define_method(rb_cArray, "[]=", rb_ary_aset, -1);
    rb_define_method(rb_cArray, "at", rb_ary_at, 1);
    rb_define_method(rb_cArray, "fetch", rb_ary_fetch, -1);
    rb_define_method(rb_cArray, "first", rb_ary_first, 0);
    rb_define_method(rb_cArray, "last", rb_ary_last, 0);
    rb_define_method(rb_cArray, "concat", rb_ary_concat, 1);
    rb_define_method(rb_cArray, "<<", rb_ary_push, 1);
    rb_define_method(rb_cArray, "push", rb_ary_push_m, -1);
    rb_define_method(rb_cArray, "pop", rb_ary_pop, 0);
    rb_define_method(rb_cArray, "shift", rb_ary_shift, 0);
    rb_define_method(rb_cArray, "unshift", rb_ary_unshift_m, -1);
    rb_define_method(rb_cArray, "insert", rb_ary_insert, -1);
    rb_define_method(rb_cArray, "each", rb_ary_each, 0);
    rb_define_method(rb_cArray, "each_index", rb_ary_each_index, 0);
    rb_define_method(rb_cArray, "reverse_each", rb_ary_reverse_each, 0);
    rb_define_method(rb_cArray, "length", rb_ary_length, 0);
    rb_define_alias(rb_cArray,  "size", "length");
    rb_define_method(rb_cArray, "empty?", rb_ary_empty_p, 0);
    rb_define_method(rb_cArray, "index", rb_ary_index, 1);
    rb_define_method(rb_cArray, "rindex", rb_ary_rindex, 1);
    rb_define_method(rb_cArray, "indexes", rb_ary_indexes, -1);
    rb_define_method(rb_cArray, "indices", rb_ary_indexes, -1);
    rb_define_method(rb_cArray, "become", rb_ary_replace, 1);
    rb_define_method(rb_cArray, "join", rb_ary_join_m, -1);
    rb_define_method(rb_cArray, "reverse", rb_ary_reverse_m, 0);
    rb_define_method(rb_cArray, "reverse!", rb_ary_reverse_bang, 0);
    rb_define_method(rb_cArray, "sort", rb_ary_sort, 0);
    rb_define_method(rb_cArray, "sort!", rb_ary_sort_bang, 0);
    rb_define_method(rb_cArray, "collect", rb_ary_collect, 0);
    rb_define_method(rb_cArray, "collect!", rb_ary_collect_bang, 0);
    rb_define_method(rb_cArray, "select", rb_ary_select, -1);
    rb_define_method(rb_cArray, "map", rb_ary_collect, 0);
    rb_define_method(rb_cArray, "map!", rb_ary_collect_bang, 0);
    rb_define_method(rb_cArray, "delete", rb_ary_delete, 1);
    rb_define_method(rb_cArray, "delete_at", rb_ary_delete_at_m, 1);
    rb_define_method(rb_cArray, "delete_if", rb_ary_delete_if, 0);
    rb_define_method(rb_cArray, "reject", rb_ary_reject, 0);
    rb_define_method(rb_cArray, "reject!", rb_ary_reject_bang, 0);
    rb_define_method(rb_cArray, "replace", rb_ary_replace, 1);
    rb_define_method(rb_cArray, "clear", rb_ary_clear, 0);
    rb_define_method(rb_cArray, "fill", rb_ary_fill, -1);
    rb_define_method(rb_cArray, "include?", rb_ary_includes, 1);
    rb_define_method(rb_cArray, "<=>", rb_ary_cmp, 1);

    rb_define_method(rb_cArray, "slice", rb_ary_aref, -1);
    rb_define_method(rb_cArray, "slice!", rb_ary_slice_bang, -1);

    rb_define_method(rb_cArray, "assoc", rb_ary_assoc, 1);
    rb_define_method(rb_cArray, "rassoc", rb_ary_rassoc, 1);

    rb_define_method(rb_cArray, "+", rb_ary_plus, 1);
    rb_define_method(rb_cArray, "*", rb_ary_times, 1);

    rb_define_method(rb_cArray, "-", rb_ary_diff, 1);
    rb_define_method(rb_cArray, "&", rb_ary_and, 1);
    rb_define_method(rb_cArray, "|", rb_ary_or, 1);

    rb_define_method(rb_cArray, "uniq", rb_ary_uniq, 0);
    rb_define_method(rb_cArray, "uniq!", rb_ary_uniq_bang, 0);
    rb_define_method(rb_cArray, "compact", rb_ary_compact, 0);
    rb_define_method(rb_cArray, "compact!", rb_ary_compact_bang, 0);
    rb_define_method(rb_cArray, "flatten", rb_ary_flatten, 0);
    rb_define_method(rb_cArray, "flatten!", rb_ary_flatten_bang, 0);
    rb_define_method(rb_cArray, "nitems", rb_ary_nitems, 0);

    id_cmp = rb_intern("<=>");
    inspect_key = rb_intern("__inspect_key__");
}
@


1.95
log
@* array.c (rb_ary_become): should not free ptr if it's shared.

* eval.c (rb_alias): prohibit making an alias named "allocate" if
  klass is a metaclass.

* string.c (rb_string_value_ptr): StringValuePtr() should never
  return NULL pointer.
@
text
@d6 1
a6 1
  $Date: 2002/08/27 08:31:05 $
a797 16
static VALUE
rb_ary_become(copy, orig)
    VALUE copy, orig;
{
    orig = to_ary(orig);
    ary_make_shared(orig);
    if (RARRAY(copy)->ptr && !FL_TEST(copy, ELTS_SHARED))
	free(RARRAY(copy)->ptr);
    RARRAY(copy)->ptr = RARRAY(orig)->ptr;
    RARRAY(copy)->len = RARRAY(orig)->len;
    RARRAY(copy)->aux.shared = RARRAY(orig)->aux.shared;
    FL_SET(copy, ELTS_SHARED);

    return copy;
}

d1303 2
a1304 2
rb_ary_replace(ary, ary2)
    VALUE ary, ary2;
d1306 12
a1317 4
    if (ary == ary2) return ary;
    ary2 = to_ary(ary2);
    rb_ary_update(ary, 0, RARRAY(ary)->len, ary2);
    return ary;
d1852 1
a1852 1
    rb_define_method(rb_cArray, "become", rb_ary_become, 1);
@


1.94
log
@* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.

* class.c (rb_mod_dup): need to preserve metaclass and flags.

* object.c (rb_cstr_to_dbl): had a buffer overrun.

* marshal.c (w_class): integrate singleton check into a funciton
  to follow DRY principle.

* marshal.c (w_uclass): should check singleton method.

* object.c (rb_obj_dup): dmark and dfree functions must be match
  for T_DATA type.

* object.c (rb_obj_dup): class of the duped object must be match
  to the class of the original.

* re.c (rb_reg_quote): do not escape \t, \f, \r, \n, for they are
  not regular expression metacharacters.

* time.c (time_s_alloc): use time_free instead of free (null check,
  also serves for type mark).

* time.c (time_s_at): check dfree function too.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/27 08:05:06 $
d804 2
a805 1
    if (RARRAY(copy)->ptr) free(RARRAY(copy)->ptr);
@


1.93
log
@array small opt. changes (ruby-core:355)
@
text
@d6 1
a6 1
  $Date: 2002/08/23 15:04:27 $
d799 2
a800 3
ary_copy(ary, clone)
    VALUE ary;
    int clone;
d802 6
a807 9
    VALUE copy;

    ary_make_shared(ary);
    copy = rb_obj_alloc(rb_cArray);
    if (clone) CLONESETUP(copy, ary);
    else DUPSETUP(copy, ary);
    RARRAY(copy)->ptr = RARRAY(ary)->ptr;
    RARRAY(copy)->len = RARRAY(ary)->len;
    RARRAY(copy)->aux.shared = RARRAY(ary)->aux.shared;
a812 7
static VALUE
rb_ary_clone(ary)
    VALUE ary;
{
    return ary_copy(ary, Qtrue);
}

a816 7
    return ary_copy(ary, Qfalse);
}

static VALUE
ary_dup(ary)
    VALUE ary;
{
d1044 1
a1044 1
    return rb_ary_reverse(ary_dup(ary));
d1122 1
a1122 1
    ary = ary_dup(ary);
d1304 1
a1304 1
    ary = ary_dup(ary);
d1700 1
a1700 1
    ary = ary_dup(ary);
d1732 1
a1732 1
    ary = ary_dup(ary);
d1811 1
a1811 1
    ary = ary_dup(ary);
d1859 1
a1859 2
    rb_define_method(rb_cArray, "clone", rb_ary_clone, 0);
    rb_define_method(rb_cArray, "dup", rb_ary_dup, 0);
@


1.92
log
@array.c: Mem optim for Array#select
@
text
@d6 1
a6 1
  $Date: 2002/08/23 07:48:48 $
d243 1
a244 1
	REALLOC_N(RARRAY(ary)->ptr, VALUE, len);
d310 1
a311 1
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->aux.capa);
d314 1
a314 1
	rb_mem_clear(RARRAY(ary)->ptr+RARRAY(ary)->len,
d663 1
a664 1
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, len);
d679 1
a680 1
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, alen);
d1231 1
a1232 1
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->aux.capa);
d1352 1
a1353 1
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->aux.capa);
d1400 1
a1401 1
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, end);
@


1.91
log
@array.c: Int vs Long #2
@
text
@d6 1
a6 1
  $Date: 2002/08/21 15:47:54 $
d1183 1
a1183 1
    VALUE result = rb_ary_new();
d1190 1
d1198 1
@


1.90
log
@*.c: Int vs Long cleanup
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/19 06:43:58 $
d1451 1
a1451 2
    VALUE ary;
    VALUE times;
d1498 1
a1498 2
    VALUE ary;
    VALUE value;
d1550 1
a1550 1
    long i;
a1551 1
    long h;
d1568 1
d1578 2
a1579 3
rb_ary_cmp(ary, ary2)
    VALUE ary;
    VALUE ary2;
d1583 2
a1584 4
    if (TYPE(ary2) != T_ARRAY) {
	ary2 = to_ary(ary2);
    }
    len = RARRAY(ary)->len;
d1589 1
a1589 1
	VALUE v = rb_funcall(RARRAY(ary)->ptr[i],id_cmp,1,RARRAY(ary2)->ptr[i]);
d1594 1
a1594 1
    len = RARRAY(ary)->len - RARRAY(ary2)->len;
d1622 1
a1622 1
    int i;
d1639 1
a1639 2
    VALUE hash;
    VALUE ary3 = rb_ary_new();
d1643 2
d1661 1
a1661 2
    VALUE hash;
    VALUE ary3 = rb_ary_new();
d1666 1
a1680 1

d1688 1
a1688 1
    VALUE hash = ary_make_hash(ary, 0);
d1691 4
a1697 2

    rb_ary_modify(ary);
@


1.89
log
@* array.c (sort_2): fatal typo.
@
text
@d6 1
a6 1
  $Date: 2002/08/19 06:41:02 $
d253 1
a253 1
	    RARRAY(ary)->ptr[i] = rb_yield(INT2NUM(i));
d598 1
a598 1
	    return INT2NUM(i);
d765 1
a765 1
	rb_yield(INT2NUM(i));
d786 1
a786 1
    return INT2NUM(RARRAY(ary)->len);
d1411 1
a1411 1
	    *p++ = rb_yield(INT2NUM(beg++));
d1770 1
a1770 1
    return INT2NUM(n);
@


1.88
log
@* array.c (sort_2): comparison should be done as signed long.

* array.c (sort_2): should return int, not VALUE.
@
text
@d6 1
a6 1
  $Date: 2002/08/19 05:56:05 $
d1092 1
a1092 1
    long a = (long)*ap, b = (long)*ap;
@


1.87
log
@* array.c (sort_2): *a - *b may overflow.

* array.c (ary_new): len*sizeof(VALUE) may be a positive value.

* array.c (rb_ary_initialize): ditto.

* object.c (rb_class_allocate_instance): move singleton class
  check from rb_obj_alloc().

* re.c (rb_reg_initialize): should not modify frozen Regexp.

* ext/tcltklib/tcltklib.c (ip_init): allocation framework.
@
text
@d6 1
a6 1
  $Date: 2002/08/13 09:21:13 $
d1092 1
a1092 1
    VALUE a = *ap, b = *ap;
d1095 3
a1097 3
	if (a > b) return INT2FIX(1);
	if (a < b) return INT2FIX(-1);
	return INT2FIX(0);
@


1.86
log
@* hash.c (rb_hash_replace): should copy ifnone.

* hash.c (rb_hash_dup): should preserve HASH_PROC_DEFAULT and
  HASH_DELETED flags.

* hash.c (rb_hash_shift): shift from empty hash should not return
  its default proc.

* hash.c (rb_hash_default_proc): new method. [new]

* array.c (rb_ary_aref): no need for Bignum check.

* array.c (rb_ary_aset): explicit Bignum check removd.

* numeric.c (fix_aref): normalize bignum before bit-op.

* bignum.c (rb_big_rand): max may be Bignum zero.

* bignum.c (rb_cstr_to_inum): should normalize bignums, to avoid
  returning fixable bignum value.

* bignum.c (rb_uint2big): there should be no zero sized bignum.

* ext/extmk.rb.in: extmake() that works properly for both tkutil
  (tk/tkutil.so) and digest/sha1.

* hash.c (rb_hash_equal): should check HASH_PROC_DEFAULT too.
@
text
@d6 1
a6 1
  $Date: 2002/07/11 08:22:10 $
d113 1
a113 1
    if (len > 0 && len * sizeof(VALUE) <= 0) {
d239 1
a239 1
    if (len > 0 && len * sizeof(VALUE) <= 0) {
d307 1
a307 1
	if (new_capa > new_capa * (long)sizeof(VALUE)) {
d1088 2
a1089 2
sort_2(a, b)
    VALUE *a, *b;
d1092 1
d1094 4
a1097 2
    if (FIXNUM_P(*a) && FIXNUM_P(*b)) {
	return *a - *b;
d1099 2
a1100 2
    if (TYPE(*a) == T_STRING && TYPE(*b) == T_STRING) {
	return rb_str_cmp(*a, *b);
d1103 1
a1103 1
    retval = rb_funcall(*a, id_cmp, 1, *b);
@


1.85
log
@* string.c (rb_str_slice_bang): if there's no corresponding
  substring, slice! should return nil without exception.

* array.c (rb_ary_insert): type fixed.

* string.c (rb_str_split_m): accept separator value nil as well.

* string.c (rb_str_become): was leaking memory.

* class.c (rb_include_module): should not alter other
  classes/modules by inclusion.  by this fix, local order may not
  be preserved for some cases.

* class.c (include_class_new): module may be T_ICLASS; retrieve
  original module information.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/05/28 18:11:07 $
d301 8
a308 3
	long capa_inc = RARRAY(ary)->aux.capa / 2;
	if (capa_inc < ARY_DEFAULT_SIZE) {
	    capa_inc = ARY_DEFAULT_SIZE;
d310 1
a310 1
	RARRAY(ary)->aux.capa = idx + capa_inc;
d315 1
a315 1
		idx-RARRAY(ary)->len + 1);
a509 3
    if (TYPE(arg) == T_BIGNUM) {
	rb_raise(rb_eIndexError, "index too big");
    }
a709 3
    }
    if (TYPE(argv[0]) == T_BIGNUM) {
	rb_raise(rb_eIndexError, "index too big");
@


1.84
log
@	* array.c: fixed format string for 'long' args (%d -> %ld).

	* class.c: ditto.

	* eval.c: ditto.

	* numeric.c: ditto.

	* pack.c: ditto.

	* parse.y: ditto.

	* range.c: ditto.

	* string.c: ditto.

	* util.c: ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/22 05:57:08 $
d737 1
a737 1
	pos = RSTRING(ary)->len;
@


1.83
log
@minor bug fixes.
@
text
@d6 1
a6 1
  $Date: 2002/05/21 05:39:18 $
d295 1
a295 1
	    rb_raise(rb_eIndexError, "index %d out of array",
d566 1
a566 1
	    rb_raise(rb_eIndexError, "index %d out of array", idx);
d645 1
a645 1
    if (len < 0) rb_raise(rb_eIndexError, "negative length (%d)", len);
d650 1
a650 1
	    rb_raise(rb_eIndexError, "index %d out of array", beg);
@


1.82
log
@* object.c (Init_Object): should do exact match for Module#==.

* compar.c (cmp_eq): returns 'false' if <=> returns 'nil'.

* compar.c (cmp_gt,cmp_ge,cmp_lt,cmp_le,cmp_between): ditto.

* pack.c (pack_pack): should propagate taintedness.

* pack.c (pack_unpack): ditto.

* eval.c (rb_thread_schedule): need to preserve errno before
  calling rb_trap_exec().

* regex.c (calculate_must_string): a bug in charset/charset_not
  parsing.
@
text
@d6 1
a6 1
  $Date: 2002/04/24 04:54:13 $
d1278 1
a1278 1
delete_pos_len:
d1291 1
a1291 3
    rb_ary_delete_at(ary, NUM2LONG(arg1));

    return arg2;
@


1.81
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d6 1
a6 1
  $Date: 2002/04/18 08:46:17 $
d65 7
a71 6
    if (!FL_TEST(ary, ELTS_SHARED)) return;
    ptr = ALLOC_N(VALUE, RARRAY(ary)->len);
    FL_UNSET(ary, ELTS_SHARED);
    RARRAY(ary)->aux.capa = RARRAY(ary)->len;
    MEMCPY(ptr, RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);
    RARRAY(ary)->ptr = ptr;
a72 1

d113 1
a113 1
    if (len > 0 && len*sizeof(VALUE) <= 0) {
d158 1
a158 4
    if (n < 0) {
	rb_raise(rb_eIndexError, "negative number of items(%d)", n);
    }
    ary = rb_ary_new2(n<ARY_DEFAULT_SIZE?ARY_DEFAULT_SIZE:n);
d239 1
a239 1
    if (len > 0 && len*sizeof(VALUE) <= 0) {
d244 1
a244 1
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->aux.capa);
d254 1
a254 1
	    RARRAY(ary)->len = i+1;
d273 4
a276 1
    if (argc != 0) {
d296 1
a296 1
		     idx - RARRAY(ary)->len);
d310 1
a310 1
		     idx-RARRAY(ary)->len+1);
d334 2
a335 2
    if (argc == 0) {
	rb_raise(rb_eArgError, "wrong number arguments(at least 1)");
d337 2
a338 4
    if (argc > 0) {
	while (argc--) {
	    rb_ary_push(ary, *argv++);
	}
d350 2
a351 2
	RARRAY(ary)->len * 10 < RARRAY(ary)->aux.capa &&
	RARRAY(ary)->aux.capa > ARY_DEFAULT_SIZE) {
d362 1
a362 2
    if (FL_TEST(ary, ELTS_SHARED)) return;
    else {
d400 1
a400 1
	RARRAY(ary)->aux.capa+=capa_inc;
d405 1
a405 1
    MEMMOVE(RARRAY(ary)->ptr+1, RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);
d419 4
a422 2
    if (argc == 0) {
	rb_raise(rb_eArgError, "wrong number of arguments(at least 1)");
a423 2
    if (argc > 0) {
	long len = RARRAY(ary)->len;
d425 2
a426 2
	/* make rooms by setting the last item */
	rb_ary_store(ary, len + argc - 1, Qnil);
d428 4
a431 4
	/* sliding items */
	MEMMOVE(RARRAY(ary)->ptr + argc, RARRAY(ary)->ptr, VALUE, len);
	MEMCPY(RARRAY(ary)->ptr, argv, VALUE, argc);
    }
d464 2
a465 3
    }
    if (len < 0) {
	len = 0;
d468 1
a468 1
    if (len == 0) return ary_new(klass,0);
d472 1
a472 1
    RARRAY(ary2)->ptr = RARRAY(ary)->ptr+beg;
d505 1
a505 1
    else if (TYPE(arg) == T_BIGNUM) {
d508 8
a515 10
    else {
	/* check if idx is Range */
	switch (rb_range_beg_len(arg, &beg, &len, RARRAY(ary)->len, 0)) {
	  case Qfalse:
	    break;
	  case Qnil:
	    return Qnil;
	  default:
	    return rb_ary_subseq(ary, beg, len);
	}
d582 1
a582 1
	    return INT2NUM(i);
d645 1
a645 1
    if (len < 0) rb_raise(rb_eIndexError, "negative length %d", len);
d648 4
a651 4
    }
    if (beg < 0) {
	beg -= RARRAY(ary)->len;
	rb_raise(rb_eIndexError, "index %d out of array", beg);
d661 2
a662 2
	    RARRAY(ary)->aux.capa=len;
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->aux.capa);
d664 2
a665 2
	rb_mem_clear(RARRAY(ary)->ptr+RARRAY(ary)->len, beg-RARRAY(ary)->len);
	MEMCPY(RARRAY(ary)->ptr+beg, RARRAY(rpl)->ptr, VALUE, rlen);
d678 1
a678 1
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->aux.capa);
d682 2
a683 2
	    MEMMOVE(RARRAY(ary)->ptr+beg+rlen, RARRAY(ary)->ptr+beg+len,
		    VALUE, RARRAY(ary)->len-(beg+len));
d686 1
a686 1
	MEMMOVE(RARRAY(ary)->ptr+beg, RARRAY(rpl)->ptr, VALUE, rlen);
d703 1
a703 1
	rb_raise(rb_eArgError, "wrong number of arguments(%d for 2)", argc);
d709 4
a712 1
    else if (rb_range_beg_len(argv[0], &beg, &len, RARRAY(ary)->len, 1)) {
a716 3
    if (TYPE(argv[0]) == T_BIGNUM) {
	rb_raise(rb_eIndexError, "index too big");
    }
d719 1
a719 1
  fixnum:
d733 1
a733 1
	rb_raise(rb_eArgError, "wrong number of arguments(at least 2)");
d743 1
a743 1
    rb_ary_update(ary, pos, 0, rb_ary_new4(argc-1, argv+1));
d858 2
a859 2
    long len, i;
    int taint = 0;
d863 1
a863 2
    if (OBJ_TAINTED(ary)) taint = 1;
    if (OBJ_TAINTED(sep)) taint = 1;
a864 1
    len = 1;
d901 1
a901 1
	if (OBJ_TAINTED(tmp)) taint = 1;
d918 1
a925 2
    VALUE str, sep;

d927 2
a928 3
    sep = rb_output_fs;
    str = rb_ary_join(ary, sep);
    return str;
a964 3
    if (!inspect_key) {
	inspect_key = rb_intern("__inspect_key__");
    }
a987 3
    if (!inspect_key) {
	inspect_key = rb_intern("__inspect_key__");
    }
d998 1
a998 1
    long i = 0;
d1004 1
a1004 1
	if (OBJ_TAINTED(s)) tainted = 1;
d1036 1
a1037 1
    rb_ary_modify(ary);
d1070 1
a1070 1
    if (FIXNUM_P(cmp)) return NUM2LONG(cmp);
d1075 2
a1076 2
    if (rb_funcall(cmp, '>', 1, INT2FIX(0))) return 1;
    if (rb_funcall(cmp, '<', 1, INT2FIX(0))) return -1;
d1094 2
a1095 2
    if (FIXNUM_P(*a)) {
	if (FIXNUM_P(*b)) return *a - *b;
d1097 1
a1097 1
    else if (TYPE(*a) == T_STRING && TYPE(*b) == T_STRING) {
d1186 1
a1186 1
	    rb_raise(rb_eArgError, "wrong number arguments(%d for 0)", argc);
d1223 6
a1228 2
    else {
	RARRAY(ary)->len = i2;
d1240 1
a1240 1
    VALUE del = Qnil;
d1244 4
a1247 2
    if (pos < 0) pos += len;
    if (pos < 0) return Qnil;
d1272 1
a1272 1
    long pos, len, i;
d1278 1
a1278 1
      delete_pos_len:
d1291 1
a1291 12
    pos = NUM2LONG(arg1);
    len = RARRAY(ary)->len;

    if (pos >= len) return Qnil;
    if (pos < 0) pos += len;
    if (pos < 0) return Qnil;

    arg2 = RARRAY(ary)->ptr[pos];
    for (i = pos + 1; i < len; i++, pos++) {
	RARRAY(ary)->ptr[pos] = RARRAY(ary)->ptr[i];
    }
    RARRAY(ary)->len = pos;
d1349 1
a1349 1
    if (ARY_DEFAULT_SIZE*3 < RARRAY(ary)->aux.capa) {
d1386 1
a1386 1
	beg = NIL_P(arg1)?0:NUM2LONG(arg1);
d1391 1
a1391 1
	len = NIL_P(arg2)?RARRAY(ary)->len - beg:NUM2LONG(arg2);
d1399 1
a1399 1
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->aux.capa);
d1402 1
a1402 1
	    rb_mem_clear(RARRAY(ary)->ptr+RARRAY(ary)->len,end-RARRAY(ary)->len);
d1406 2
a1407 1
    p = RARRAY(ary)->ptr + beg; pend = p + len;
d1411 1
a1411 2
	    *p++ = rb_yield(INT2NUM(beg));
	    beg++;
d1427 1
d1430 2
a1431 1
    z = rb_ary_new2(RARRAY(x)->len + RARRAY(y)->len);
d1433 2
a1434 2
    MEMCPY(RARRAY(z)->ptr+RARRAY(x)->len, RARRAY(y)->ptr, VALUE, RARRAY(y)->len);
    RARRAY(z)->len = RARRAY(x)->len + RARRAY(y)->len;
d1480 1
a1480 2
    VALUE ary;
    VALUE key;
d1484 3
a1486 1
    p = RARRAY(ary)->ptr; pend = p + RARRAY(ary)->len;
d1488 3
a1490 3
	if (TYPE(*p) == T_ARRAY
	    && RARRAY(*p)->len > 0
	    && rb_equal(RARRAY(*p)->ptr[0], key))
d1504 3
a1506 1
    p = RARRAY(ary)->ptr; pend = p + RARRAY(ary)->len;
d1558 1
a1558 1
	h = (h<<1) | (h<0 ? 1 : 0);
d1562 1
a1562 1
    return INT2FIX(h);
d1733 1
d1765 1
d1773 1
a1773 1
static int
d1923 1
@


1.80
log
@* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* io.c: complete off_t handling; missing argument for
  fptr_finalize(); polished rb_scan_args call.

* dir.c: wrap multi-statment macro by do { } while (0)

* eval.c, numeric,c, sprintf.c, util.c: ditto.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.
@
text
@d6 1
a6 1
  $Date: 2002/03/08 07:03:03 $
a207 7
}

static VALUE
to_ary_failed(failed)
    int *failed;
{
    *failed = Qtrue;
@


1.79
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.

* class.c (rb_mod_clone): should not call rb_obj_clone(), since
  Module does not provide "allocate".

* class.c (rb_singleton_class): should crate new singleton class
  if obj is a class or module and attached object is different,
  which means metaclass of singleton class is sought.

* time.c (time_s_alloc): now follows allocation framework.

* eval.c (rb_eval): should initialize outer class variables from
  methods in singleton class definitions.

* eval.c (assign): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/01/28 10:18:14 $
d176 1
a176 1
    VALUE *elts;
@


1.78
log
@* array.c (rb_ary_fill): shouldn't yield unless block given.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/28 08:44:37 $
d405 1
a405 1
    if (RARRAY(ary)->len >= RARRAY(ary)->aux.capa) {
@


1.77
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.

* object.c (Init_Object): remove dup and clone from TrueClass,
  FalseClass, and NilClass.

* array.c (rb_ary_fill): Array#fill takes block to get the value to
  fill.

* string.c (rb_str_to_i): to_i(0) auto-detects base radix.

* array.c (rb_ary_initialize): fill by the block evaluation value
  if block is given.
@
text
@d6 1
a6 1
  $Date: 2002/01/25 08:22:04 $
d1393 1
a1393 1
    int block_p;
@


1.76
log
@* class.c (rb_include_module): detect cyclic module inclusion.

* eval.c (rb_thread_cleanup): need not to free thread stacks at
  process termination.

* array.c (rb_ary_fetch): use the block to get the default value
  if the block is given.

* eval.c (rb_thread_schedule): should check time only if BOTH
  WAIT_SELECT and WAIT_TIME.

* eval.c (umethod_bind): should update rklass field.

* hash.c (rb_hash_update): if a block is given, yields [key,
  value1, value2] to the block to resolve conflict.

* string.c (rb_str_split_m): no need to consider KANJI
characters, if the length of separator is 1 (byte).
@
text
@d6 1
a6 1
  $Date: 2002/01/23 07:30:39 $
d231 3
d237 6
a242 3
    if (argc == 1 && !FIXNUM_P(size) && rb_respond_to(size, rb_intern("to_ary"))) {
	rb_ary_replace(ary, rb_convert_type(size, T_ARRAY, "Array", "to_ary"));
	return ary;
d256 15
a270 2
    memfill(RARRAY(ary)->ptr, len, val);
    RARRAY(ary)->len = len;
d1365 1
d1393 1
d1395 8
a1402 1
    rb_scan_args(argc, argv, "12", &item, &arg1, &arg2);
d1406 1
a1406 1
	len = RARRAY(ary)->len - beg;
d1436 10
a1445 2
    while (p < pend) {
	*p++ = item;
@


1.75
log
@* array.c (Init_Array): remove Array#filter.

* object.c (rb_mod_initialize): should accept zero argument.

* object.c (rb_mod_cmp): should raise ArgumentError if
  inheritance/inclusion relation between two classes/modules is
  not defined. [new]

* io.c (rb_io_fsync): new method. [new]
@
text
@d6 1
a6 1
  $Date: 2002/01/19 14:21:44 $
d553 10
a562 2
	if (argc == 2) return ifnone;
	rb_raise(rb_eIndexError, "index %d out of array", idx);
@


1.74
log
@* eval.c (rb_eval): need not to clar method cache for NODE_CLASS,
  NODE_SCLASS.

* gc.c (obj_free): need not to clear method cache on class/module
  finalization.
@
text
@d6 1
a6 1
  $Date: 2002/01/11 09:18:49 $
a1171 8
rb_ary_filter(ary)
    VALUE ary;
{
    rb_warn("Array#filter is deprecated; use Array#collect!");
    return rb_ary_collect_bang(ary);
}

static VALUE
a1866 1
    rb_define_method(rb_cArray, "filter", rb_ary_filter, 0);
@


1.73
log
@* re.c (match_select): should propagate taintness.

* hash.c (rb_hash_set_default): Hash#default= should return the
  new value.

* string.c (rb_str_to_i): accepts optional base argument. [new]

* numeric.c (rb_fix2str): should not handle negative fixnum values
  int32 via calling sprintf() directly.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/12/28 05:42:23 $
d553 2
a554 1
	return ifnone;
@


1.72
log
@* array.c (rb_cmpint): fixed typo.
@
text
@d6 1
a6 1
  $Date: 2001/12/17 07:52:34 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
@


1.71
log
@* intern.h: add prototypes.
  rb_gc_enable(), rb_gc_disable(), rb_gc_start(), rb_str_new5()
  rb_str_buf_append(), rb_str_buf_cat(), rb_str_buf_cat2(),
  rb_str_dup_frozen()

* ruby.h: added declaration.
  rb_defout, rb_stdin, rb_stdout, rb_stderr, ruby_errinfo

* rubyio.h: changed double include guard macro to RUBYIO_H.

* array.c (inspect_call): make static.

* eval.c (dvar_asgn): ditto.

* io.c (rb_io_close_read): ditto.

* lex.c (rb_reserved_word): ditto.

* ruby.c: (req_list_head, req_list_last): ditto.

* ruby.c (require_libraries): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/12/13 08:19:07 $
d1070 2
a1071 2
    if (rb_funcall(id_cmp, '>', 1, INT2FIX(0))) return 1;
    if (rb_funcall(id_cmp, '<', 1, INT2FIX(0))) return -1;
@


1.70
log
@* time.c (time_new_internal): avoid loop to calculate negative
  div, mod.

* time.c (time_cmp): should handle Bignums.

* array.c (rb_ary_pop): should ELTS_SHARED flag check before
  REALLOC.
@
text
@d6 1
a6 1
  $Date: 2001/12/11 03:48:08 $
d927 1
a927 1
VALUE
@


1.69
log
@* string.c (rb_str_match_m): should convert an argument into
  regexp if it's a string.

* array.c (rb_ary_select): Array#select(n,m,...) now works like
  Array#indexes(n,m,..). [new, experimental]

* hash.c (rb_hash_select): ditto.

* hash.c (env_select): ditto.

* re.c (match_select): ditto.

* struct.c (rb_struct_select): ditto.

* gc.c (STR_ASSOC): use FL_USER3 instead of FL_USER2.

* parse.y (str_extend): make up pushback call.
@
text
@d6 1
a6 1
  $Date: 2001/12/10 07:18:12 $
d339 3
a341 1
    if (RARRAY(ary)->len * 10 < RARRAY(ary)->aux.capa && RARRAY(ary)->aux.capa > ARY_DEFAULT_SIZE) {
@


1.68
log
@* array.c (rb_ary_modify): should copy the internal buffer if the
  modifying buffer is shared.

* array.c (ary_make_shared): make an internal buffer of an array
  to be shared.

* array.c (rb_ary_shift): avoid sliding an internal buffer by
  using shared buffer.

* array.c (rb_ary_subseq): avoid copying the buffer.

* parse.y (gettable): should freeze __LINE__ string.

* io.c (rb_io_puts): old behavoir restored.  rationale: a) if you
  want to call to_s for arrays, you can just call print a, "\n".
  b) to_s wastes memory if array (and sum of its contents) is
  huge.  c) now any object that has to_ary is treated as an array,
  using rb_check_convert_type().

* hash.c (rb_hash_initialize): now accepts a block to calculate
  the default value. [new]

* hash.c (rb_hash_aref): call "default" method to get the value
  corrensponding to the non existing key.

* hash.c (rb_hash_default): get the default value based on the
  block given to 'new'.  Now it takes an optinal "key" argument.
  "default" became the method to get the value for non existing
  key.  Users may override "default" method to change the hash
  behavior.

* hash.c (rb_hash_set_default): clear the flag if a block is given
  to 'new'

* object.c (Init_Object): undef Data.allocate, left Data.new.

* ext/curses/curses.c (window_scrollok): use RTEST().

* ext/curses/curses.c (window_idlok): ditto.

* ext/curses/curses.c (window_keypad): ditto.

* ext/curses/curses.c (window_idlok): idlok() may return void on
  some platforms; so don't use return value.

* ext/curses/curses.c (window_scrollok): ditto for consistency.

* ext/curses/curses.c: replace FIX2INT() by typechecking NUM2INT().

* parse.y (str_extend): should not process immature #$x and
  #@@x interpolation, e.g #@@#@@ etc.

* enum.c (enum_sort_by): sort_by does not have to be stable always.

* enum.c (enum_sort_by): call qsort directly to gain performance.

* util.c (ruby_qsort): ruby_qsort(qs6) is now native thread safe.

* error.c (rb_sys_fail): it must be a bug if it's called when
  errno == 0.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@d6 1
a6 1
  $Date: 2001/11/27 10:00:30 $
d593 2
d1176 27
d1869 1
@


1.67
log
@* marshal.c (w_float): must distinguish -0.0 from 0.0.

* gc.c (gc_mark_all): tweak mark order for little bit better scan.

* gc.c (rb_gc_mark): ditto.

* gc.c (rb_gc): ditto.

* enum.c (sort_by_i): slight performance boost.

* gc.c (gc_mark_rest): should call gc_mark_children(), not gc_mark().

* gc.c (rb_gc_mark): may cause infinite looop.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 14:42:44 $
d20 1
a20 1
static ID cmp;
d48 1
a48 1
rb_ary_modify(ary)
d58 15
a96 1
    ary->capa = 0;
d98 1
d103 2
a104 2
VALUE
rb_ary_new0(klass, len)
d118 1
a118 1
    RARRAY(ary)->capa = len;
d127 1
a127 1
    return rb_ary_new0(rb_cArray, len);
d246 3
a248 3
    if (len > RARRAY(ary)->capa) {
	RARRAY(ary)->capa = len;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d268 1
a268 1
    RARRAY(ary)->len = RARRAY(ary)->capa = argc;
d288 2
a289 2
    if (idx >= RARRAY(ary)->capa) {
	long capa_inc = RARRAY(ary)->capa / 2;
d293 2
a294 2
	RARRAY(ary)->capa = idx + capa_inc;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d337 1
a337 1
    rb_ary_modify(ary);
d339 3
a341 3
    if (RARRAY(ary)->len * 10 < RARRAY(ary)->capa && RARRAY(ary)->capa > ARY_DEFAULT_SIZE) {
	RARRAY(ary)->capa = RARRAY(ary)->len * 2;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d346 17
d369 1
a369 1
    rb_ary_modify(ary);
a370 1

d372 2
a375 7
    /* sliding items */
    MEMMOVE(RARRAY(ary)->ptr, RARRAY(ary)->ptr+1, VALUE, RARRAY(ary)->len);
    if (RARRAY(ary)->len * 10 < RARRAY(ary)->capa && RARRAY(ary)->capa > ARY_DEFAULT_SIZE) {
	RARRAY(ary)->capa = RARRAY(ary)->len * 2;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
    }

d384 2
a385 2
    if (RARRAY(ary)->len >= RARRAY(ary)->capa) {
	long capa_inc = RARRAY(ary)->capa / 2;
d389 2
a390 2
	RARRAY(ary)->capa+=capa_inc;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d458 1
a458 1
    if (len == 0) return rb_ary_new0(klass,0);
d460 3
a462 2
    ary2 = rb_ary_new0(klass, len);
    MEMCPY(RARRAY(ary2)->ptr, RARRAY(ary)->ptr+beg, VALUE, len);
d464 2
d641 3
a643 3
	if (len >= RARRAY(ary)->capa) {
	    RARRAY(ary)->capa=len;
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d657 3
a659 3
	if (alen >= RARRAY(ary)->capa) {
	    RARRAY(ary)->capa = alen;
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d781 19
d803 1
a803 6
    VALUE clone = rb_ary_new2(RARRAY(ary)->len);

    CLONESETUP(clone, ary);
    MEMCPY(RARRAY(clone)->ptr, RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);
    RARRAY(clone)->len = RARRAY(ary)->len;
    return clone;
d810 7
d819 1
a819 1
    OBJSETUP(dup, rb_obj_class(ary), T_ARRAY);
a821 1
    OBJ_INFECT(dup, ary);
a825 1
extern VALUE rb_default_rs;
a911 3
#if 1
    if (NIL_P(rb_output_fs)) sep = rb_default_rs; /* newline */
#endif
d1054 1
a1054 1
    return rb_ary_reverse(rb_ary_dup(ary));
d1066 2
a1067 2
    if (rb_funcall(cmp, '>', 1, INT2FIX(0))) return 1;
    if (rb_funcall(cmp, '<', 1, INT2FIX(0))) return -1;
d1092 1
a1092 1
    retval = rb_funcall(*a, cmp, 1, *b);
d1129 1
a1129 1
    ary = rb_ary_dup(ary);
a1134 20
sort_inplace(ary)
    VALUE ary;
{
    qsort(RARRAY(ary)->ptr, RARRAY(ary)->len, sizeof(VALUE),sort_2);
    return ary;
}

VALUE
rb_ary_sort_inplace(ary)
    VALUE ary;
{
    rb_ary_modify(ary);
    if (RARRAY(ary)->len <= 1) return ary;

    FL_SET(ary, ARY_TMPLOCK);	/* prohibit modification during sort */
    rb_ensure(sort_inplace, ary, sort_unlock, ary);
    return ary;
}

static VALUE
d1297 1
a1297 1
    ary = rb_ary_dup(ary);
d1325 3
a1327 3
    if (ARY_DEFAULT_SIZE*3 < RARRAY(ary)->capa) {
	RARRAY(ary)->capa = ARY_DEFAULT_SIZE * 2;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d1365 3
a1367 3
	if (end >= RARRAY(ary)->capa) {
	    RARRAY(ary)->capa = end;
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d1425 1
a1425 1
    ary2 = rb_ary_new0(rb_obj_class(ary), len);
d1549 1
a1549 1
	VALUE v = rb_funcall(RARRAY(ary)->ptr[i],cmp,1,RARRAY(ary2)->ptr[i]);
d1674 1
a1674 1
    ary = rb_ary_dup(ary);
d1695 1
a1695 1
    RARRAY(ary)->len = RARRAY(ary)->capa = (p - RARRAY(ary)->ptr);
d1705 1
a1705 1
    ary = rb_ary_dup(ary);
d1783 1
a1783 1
    ary = rb_ary_dup(ary);
d1875 1
a1875 1
    cmp = rb_intern("<=>");
@


1.66
log
@* eval.c (rb_mod_modfunc): should follow NODE_ZSUPER link; based
  on Guy Decoux's patch in [ruby-talk:25478].

* string.c (rb_str_succ): there was buffer overrun.

* parse.y (str_extend): term can be any character.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 05:03:02 $
d1090 20
d1516 3
a1518 1
    ary2 = to_ary(ary2);
@


1.65
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* massages: replace "wrong #" by "wrong number".

* marshal.c (w_float): output Infinity and NaN explicitly.

* marshal.c (r_object): support new explicit float format.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.

* array.c (rb_ary_join): dumped core if sep is not T_STRING nor T_NIL.

* array.c (rb_ary_join): buffer size calculattion was wrong.

* array.c (rb_ary_to_s): if rb_output_fs is nil, insert newlines
  between array elements (use rb_default_rs as newline litral)
  [experimental].

* gc.c (init_mark_stack): no need to clear mark_stack.

* gc.c (gc_mark_all): need to handle finalizer mark.

* gc.c (gc_mark_rest): use MEMCPY instead of memcpy.

* gc.c (rb_gc_mark): earlier const check to avoid pusing special
  constants into mark stack.

* numeric.c (fix_to_s): 'to_s' now takes optional argument to
  specify radix. [new]

* bignum.c (rb_big_to_s): ditto. [new]
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/11/15 15:56:08 $
d863 4
a866 2
    if (!NIL_P(rb_output_fs)) sep = rb_output_fs;
    else sep = rb_default_rs;
@


1.64
log
@* array.c (rb_ary_join): non-nil separator must be converted to
  String.  and separators' total length was wrong.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/11/13 08:19:51 $
d308 1
a308 1
	rb_raise(rb_eArgError, "wrong # of arguments(at least 1)");
d383 1
a383 1
	rb_raise(rb_eArgError, "wrong # of arguments(at least 1)");
d655 1
a655 1
	rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)", argc);
d685 1
a685 1
	rb_raise(rb_eArgError, "wrong # of arguments(at least 2)");
d777 1
d860 1
a860 1
    VALUE str;
d863 3
a865 2
    str = rb_ary_join(ary, rb_output_fs);
    if (NIL_P(str)) return rb_str_new(0, 0);
@


1.63
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* eval.c (rb_eval_cmd): should not upgrade safe level unless
  explicitly specified by argument newly added.

* signal.c (sig_trap): should not allow tainted trap closure.

* variable.c (rb_f_trace_var): should not allow trace_var on safe
  level higher than 3.

* variable.c (rb_f_trace_var): should not allow tainted trace
  closure.

* gc.c: do not use static stack until system stack overflows.

* eval.c (eval): should call Exception#exception instead of
  calling rb_exc_new3() directly.

* error.c (exc_exception): set "mesg" directly to the clone.  it
  might be better to set mesg via some method for flexibility.

* variable.c (cvar_override_check): should print original module
  name, if 'a' is T_ICLASS.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/10/29 05:07:17 $
d807 3
a809 2
    if (!NIL_P(sep) && TYPE(sep) == T_STRING) {
	len += RSTRING(sep)->len * RARRAY(ary)->len - 1;
@


1.62
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* variable.c (rb_cvar_set): empty iv_tbl may cause infinite loop.

* variable.c (rb_cvar_get): ditto.

* variable.c (cvar_override_check): ditto.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.

* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.
@
text
@d6 1
a6 1
  $Date: 2001/10/16 03:27:06 $
d1007 14
d1026 1
a1026 1
    return NUM2INT(retval);
d1043 1
a1043 1
    return NUM2INT(retval);
@


1.61
log
@* string.c (rb_str_index): wrong increment for non alphanumeric
  string.
@
text
@d6 1
a6 1
  $Date: 2001/10/05 06:30:42 $
d893 1
a893 1
    VALUE (*func)();
@


1.60
log
@* marshal.c (w_unique): should not dump anonymous class.
@
text
@d6 1
a6 1
  $Date: 2001/10/03 07:19:10 $
d89 2
a90 1
rb_ary_new2(len)
d93 1
a93 1
    VALUE ary = rb_obj_alloc(rb_cArray);
d109 8
d420 1
a420 1
    VALUE ary2;
d431 2
a432 1
    if (len == 0) return rb_ary_new2(0);
d434 1
a434 1
    ary2 = rb_ary_new2(len);
a436 1
    RBASIC(ary2)->klass = rb_obj_class(ary);
d1230 9
d1361 1
a1361 1
    ary2 = rb_ary_new2(len);
a1367 1
    RBASIC(ary2)->klass = rb_obj_class(ary);
d1780 1
@


1.59
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/10/02 04:31:18 $
d79 1
a79 1
    OBJSETUP(ary, rb_cArray, T_ARRAY);
@


1.58
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* string.c (rb_str_subpat_set): support function for new argument
  pattern String#[re,offset] = val. [new]

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_aref_m): new argument pattern
  String#[re,offset]. [new]

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* array.c (rb_ary_initialize): Array.new([1,2,3]) => [1,2,3]. [new]

* string.c (rb_str_reverse): should return an instance of
  receiver's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.

* eval.c (eval): retrieves file, line information from binding.

* eval.c (intersect_fds): counts intersecting fds.

* eval.c (rb_thread_schedule): only fds requested by
  each thread count as select_value.
@
text
@d6 1
a6 1
  $Date: 2001/08/29 06:28:44 $
d74 14
d92 1
a92 2
    NEWOBJ(ary, struct RArray);
    OBJSETUP(ary, rb_cArray, T_ARRAY);
a99 3
    ary->len = 0;
    ary->capa = len;
    ary->ptr = 0;
d101 2
a102 1
    ary->ptr = ALLOC_N(VALUE, len);
d104 1
a104 1
    return (VALUE)ary;
d157 1
a157 1
    if (elts) {
a179 13
rb_ary_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE ary = rb_ary_new();
    OBJSETUP(ary, klass, T_ARRAY);
    rb_obj_call_init(ary, argc, argv);

    return ary;
}

static VALUE
d238 1
a238 2
    NEWOBJ(ary, struct RArray);
    OBJSETUP(ary, klass, T_ARRAY);
d240 3
a242 3
    ary->len = ary->capa = 0;
    if (argc == 0) {
	ary->ptr = 0;
d244 1
a244 5
    else {
	ary->ptr = ALLOC_N(VALUE, argc);
	MEMCPY(ary->ptr, argv, VALUE, argc);
    }
    ary->len = ary->capa = argc;
d246 1
a246 1
    return (VALUE)ary;
d1711 1
a1711 1
    rb_define_singleton_method(rb_cArray, "new", rb_ary_s_new, -1);
@


1.57
log
@* parse.y (yylex): ternary ? can be followed by newline.

* eval.c (rb_f_require): should check static linked libraries
  before raising exception.

* array.c (rb_ary_equal): check identiry equality first.

* string.c (rb_str_equal): ditto.

* struct.c (rb_struct_equal): ditto.

* numeric.c (Init_Numeric): undef Integer::new.

* eval.c (rb_eval): NODE_WHILE should update result for each
  conditional evaluation.

* eval.c (rb_eval): NODE_UNTIL should return last evaluated value
  (or value given to break).
@
text
@d6 1
a6 1
  $Date: 2001/08/23 06:02:14 $
d182 16
d206 1
d208 6
a216 1
    rb_ary_modify(ary);
d434 1
d570 14
d592 1
a592 6
    if (NIL_P(rpl)) {
	rpl = rb_ary_new2(0);
    }
    else if (TYPE(rpl) != T_ARRAY) {
	rpl = rb_ary_new3(1, rpl);
    }
a773 21
static VALUE
to_ary(ary)
    VALUE ary;
{
    return rb_convert_type(ary, T_ARRAY, "Array", "to_ary");
}

VALUE
rb_ary_to_ary(obj)
    VALUE obj;
{
    if (NIL_P(obj)) return rb_ary_new2(0);
    if (TYPE(obj) == T_ARRAY) {
	return obj;
    }
    if (rb_respond_to(obj, rb_intern("to_ary"))) {
	return rb_convert_type(obj, T_ARRAY, "Array", "to_ary");
    }
    return rb_ary_new3(1, obj);
}

d1356 2
@


1.56
log
@* eval.c (is_defined): should not dump core for "defined?(())".

* eval.c (umethod_bind): recv can be an instance of descender of
  oklass if oklass is a Module.

* hash.c (rb_hash_equal): check identiry equality first.

* file.c (group_member): should check real gid only.

* file.c (eaccess): do not cache euid, since effective euid may be
  changed via Process.euid=().

* file.c (eaccess): return -1 unless every specified access mode
  is permitted.

* eval.c (rb_eval): while/until returns the value which is given
  to break.

* parse.y (value_expr): using while/until/class/def as an
  expression is now gives a warning, not an error.

* range.c (range_eqq): should compare strings based on magical
  increment (using String#upto), not dictionary order.

* enum.c (enum_sort_by): new method for Schewartzian transformed
  stable sort.

* variable.c (mod_av_set): detect constant overriding for built-in
  classes/modules.
@
text
@d6 1
a6 1
  $Date: 2001/08/20 04:29:56 $
d1391 1
@


1.55
log
@* range.c (range_step): 'iter' here should be an array.

* marshal.c (w_object): should retrieve __member__ data from
  non-singleton class.

* variable.c (rb_cvar_get): class variable override check added.

* variable.c (rb_cvar_set): ditto

* variable.c (rb_cvar_declare): ditto.

* parse.y (parse_regx): handle backslash escaping of delimiter here.
@
text
@d6 1
a6 1
  $Date: 2001/08/14 08:13:26 $
d1446 1
a1446 1
static VALUE
@


1.54
log
@* range.c (range_step): new method.

* string.c (rb_str_cmp): remove needless conditional.

* string.c (rb_str_lstrip_bang) `return Qnil' was missing.
@
text
@d6 1
a6 1
  $Date: 2001/08/06 03:05:12 $
d735 1
a735 1
    OBJSETUP(dup, rb_obj_type(ary), T_ARRAY);
@


1.53
log
@* string.c (rb_str_lstrip_bang): new method.

* string.c (rb_str_rstrip_bang): new method.

* string.c (rb_str_associate): should consider STR_ASSOC too.

* eval.c (rb_undefined): do not recurse if method_missing is
  undefined.

* process.c (proc_waitpid): now all arguments are optional.

* process.c (Init_process): waitpid is now alias to wait.

* process.c (Init_process): waitpid2 is now alias to wait2.

* process.c (rb_waitpid): made public.

* ext/pty/pty.c (pty_getpty): avoid disturbing SIGCHLD using
  thread and rb_waitpid.

* process.c (proc_getpgrp): now takes no argument on all
  platforms.

* process.c (proc_setpgrp): ditto.

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::pack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::pack_sockaddr_un(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::unpack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::unpack_sockaddr_un(). [new]
@
text
@d6 1
a6 1
  $Date: 2001/07/14 15:17:18 $
d913 3
a915 1
    if (!inspect_key) return Qfalse;
@


1.52
log
@* regex.c (re_search): should consider reverse search.

* dir.c (dir_s_chdir): warn only when invoked from multiple
  threads or block is not given.

* object.c (rb_convert_type): should use rb_rescue(), not rb_rescue2().

* range.c (range_init): ditto.

* object.c (rb_obj_dup): should free generic_ivar if original owns
  them.

* string.c (rb_str_each_line): should propagate taint mark.

* ext/nkf/nkf.c (rb_nkf_kconv): ditto.

* eval.c (rb_f_require): revamp for simpler implementation.

* file.c (rb_find_file_noext): use String object, instead of
  passing char* around.

* file.c (rb_find_file): ditto.

* dln.c (dln_load): should use NSLINKMODULE_OPTION_BINDNOW.

* ruby.c (load_file): local variables 'c' remain uninitialized on
  xflag.

* regex.c (re_match): prefetched escaped character too early.

* eval.c (rb_call0): add argument check for attr_readers.
@
text
@d6 1
a6 1
  $Date: 2001/07/02 08:46:21 $
d738 1
d1740 1
a1740 1
    rb_define_method(rb_cArray, "clone", rb_ary_dup, 0);
@


1.51
log
@* error.c (exc_exception): clone the receiver exception instead of
  creating brand new exception object of the receiver.

* eval.c (rb_eval_string_wrap): extend new ruby_top_self, not
  original self.

* eval.c (rb_eval_cmd): respect ruby_wrapper if set.

* eval.c (eval): do not update ruby_class unless scope is not
  provided.

* eval.c (eval): preserve wrapper information.

* eval.c (proc_invoke): ditto.

* eval.c (block_pass): ditto.

* parse.y (void_expr): too much warnings for void context
  (e.g. foo[1] that can be mere Proc call).

* error.c (rb_name_error): new function to raise NameError with
  name attribute set.

* eval.c (rb_f_missing): set name and args in the exception
  object. [new]

* error.c (name_name): NameError#name - new method.

* error.c (nometh_args): NoMethodError#args - new method.

* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.

* dir.c (isdelim): space, tab, and newline are no longer
  delimiters for glob patterns.

* eval.c (svalue_to_avalue): new conversion scheme between single
  value and array values.

* eval.c (avalue_to_svalue): ditto.

* eval.c (rb_eval): REXPAND now uses avalue_to_svalue(), return
  and yield too.

* eval.c (rb_yield_0): use avalue_to_svalue().

* eval.c (proc_invoke): Proc#call gives avaules, whereas
  Proc#yield gives mvalues.

* eval.c (bmcall): convert given value (svalue) to avalue.
@
text
@d6 1
a6 1
  $Date: 2001/06/19 04:35:13 $
d729 12
d988 1
a988 1
    return rb_ary_reverse(rb_obj_dup(ary));
d1049 1
a1049 1
    ary = rb_obj_dup(ary);
d1062 1
a1062 1
	return rb_obj_dup(ary);
d1581 1
a1581 1
    ary = rb_obj_dup(ary);
d1612 1
a1612 1
    ary = rb_obj_dup(ary);
d1690 1
a1690 1
    ary = rb_obj_dup(ary);
d1739 1
d1747 1
@


1.50
log
@* eval.c (rb_f_require): searches ".rb" and ".so" at the same
  time.  previous behavior (search ".rb", then ".so") has a
  security risk (ruby-bugs#PR140).

* array.c (rb_ary_to_ary): new function to replace internal
  rb_Array(), which never calls to_a, but to_ary (rb_Array() might
  call both). [new]

* regex.c (PUSH_FAILURE_POINT): push option status again.

* regex.c (re_compile_pattern): avoid pushing unnecessary
  option_set.

* eval.c (rb_load): tainted string is OK if wrapped *and*
  $SAFE >= 4.

* eval.c (rb_thread_start_0): should not nail down higher blocks
  before preserving original context (i.e. should not alter
  original context).

* eval.c (proc_yield): new method equivalent to Proc#call but no
  check for number of arguments. [new]
@
text
@d6 1
a6 1
  $Date: 2001/05/30 09:12:33 $
d422 1
a422 1
    VALUE arg1, arg2;
d425 3
a427 3
    if (rb_scan_args(argc, argv, "11", &arg1, &arg2) == 2) {
	beg = NUM2LONG(arg1);
	len = NUM2LONG(arg2);
d433 4
a436 1

d438 2
a439 2
    if (FIXNUM_P(arg1)) {
	return rb_ary_entry(ary, FIX2LONG(arg1));
d441 1
a441 1
    else if (TYPE(arg1) == T_BIGNUM) {
d446 1
a446 1
	switch (rb_range_beg_len(arg1, &beg, &len, RARRAY(ary)->len, 0)) {
d455 1
a455 1
    return rb_ary_entry(ary, NUM2LONG(arg1));
@


1.49
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d6 1
a6 1
  $Date: 2001/05/16 09:05:49 $
d20 1
d733 14
a974 2

static ID cmp;
@


1.48
log
@* array.c (rb_ary_and): should not push frozen key string.

* array.c (rb_ary_or): ditto.

* eval.c (rb_thread_schedule): should save context before raising
  deadlock, saved context for current thread might be obsolete.

* time.c (make_time_t): non DST timezone shift supported (hopefully).

* time.c (make_time_t): strict range detection for negative time_t.

* signal.c: SIGINFO added.

* eval.c (rb_ensure): should not SEGV when prot_tag is NULL.
@
text
@d6 1
a6 1
  $Date: 2001/05/06 15:01:58 $
a741 15
static long
str_cpy(str, idx, str2)
    VALUE str;
    long idx;
    VALUE str2;
{
    long len = idx + RSTRING(str2)->len;

    if (RSTRING(str)->len < len) {
	rb_str_resize(str, len);
    }
    memcpy(RSTRING(str)->ptr+idx, RSTRING(str2)->ptr, RSTRING(str2)->len);
    return len;
}

d746 1
a746 1
    long len, i, j;
d766 2
a767 3
    result = rb_str_new(0, len);

    for (i=0, j=0; i<RARRAY(ary)->len; i++) {
d787 3
a789 2
	if (i > 0 && !NIL_P(sep)) j = str_cpy(result, j, sep);
	j = str_cpy(result, j, tmp);
a791 1
    rb_str_resize(result, j);
d896 1
a896 2
    str = rb_str_new2("[");

d899 3
a901 3
	tainted = OBJ_TAINTED(s);
	if (i > 0) rb_str_cat2(str, ", ");
	rb_str_append(str, s);
d903 1
a903 2
    rb_str_cat(str, "]", 1);

@


1.47
log
@forgot some checkins.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:10 $
d742 15
d761 1
a761 1
    long i;
d769 4
a772 9
    tmp = RARRAY(ary)->ptr[0];
    if (OBJ_TAINTED(tmp)) taint = 1;
    switch (TYPE(tmp)) {
      case T_STRING:
	result = rb_str_dup(tmp);
	break;
      case T_ARRAY:
	if (rb_inspecting_p(tmp)) {
	    result = rb_str_new2("[...]");
d775 1
a775 5
	    VALUE args[2];

	    args[0] = tmp;
	    args[1] = sep;
	    result = rb_protect_inspect(inspect_join, ary, (VALUE)args);
a776 4
	break;
      default:
	result = rb_str_dup(rb_obj_as_string(tmp));
	break;
d778 4
d783 1
a783 1
    for (i=1; i<RARRAY(ary)->len; i++) {
d803 2
a804 2
	if (!NIL_P(sep)) rb_str_append(result, sep);
	rb_str_append(result, tmp);
d807 1
a1300 2
    long ylen;

d1506 1
a1506 1
	    rb_ary_push(ary3, v);
d1528 1
a1528 1
	    rb_ary_push(ary3, v);
d1534 1
a1534 1
	    rb_ary_push(ary3, v);
d1556 1
a1556 1
	VALUE v = *p++;
d1558 1
a1558 1
	    *q++ = v;
d1560 1
@


1.46
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d6 1
a6 1
  $Date: 2001/03/13 05:45:08 $
d544 1
a544 1
rb_ary_update(ary, beg, len, rpl, rlen)
d547 2
a548 1
    VALUE *rpl;
d550 9
a558 1
{
d579 1
a579 1
	MEMCPY(RARRAY(ary)->ptr+beg, rpl, VALUE, rlen);
d591 1
a591 1
	    RARRAY(ary)->capa=alen;
d600 1
a600 16
	MEMMOVE(RARRAY(ary)->ptr+beg, rpl, VALUE, rlen);
    }
}

static void
rb_ary_replace(ary, beg, len, rpl)
    VALUE ary, rpl;
    long beg, len;
{
    long rlen;

    if (NIL_P(rpl)) {
	rpl = rb_ary_new2(0);
    }
    else if (TYPE(rpl) != T_ARRAY) {
	rpl = rb_ary_new3(1, rpl);
a601 1
    rb_ary_update(ary, beg, len, RARRAY(rpl)->ptr, RARRAY(rpl)->len);
d613 1
a613 1
	rb_ary_replace(ary, NUM2LONG(argv[0]), NUM2LONG(argv[1]), argv[2]);
d625 1
a625 1
	rb_ary_replace(ary, beg, len, argv[1]);
d644 2
d649 9
a657 1
    rb_ary_update(ary, NUM2LONG(argv[0]), 0, argv+1, argc-1);
d1152 1
a1152 1
	rb_ary_replace(ary, pos, len, Qnil);	/* Qnil/rb_ary_new2(0) */
d1205 1
a1205 1
rb_ary_replace_m(ary, ary2)
d1209 1
a1209 1
    rb_ary_replace(ary, 0, RARRAY(ary)->len, ary2);
d1298 1
a1298 1
	rb_ary_replace(x, RARRAY(x)->len, 0, y);
d1632 1
a1632 1
    rb_ary_replace(ary, idx, 1, ary2);
d1736 1
a1736 1
    rb_define_method(rb_cArray, "replace", rb_ary_replace_m, 1);
@


1.45
log
@* io.c (argf_seek_m): wrong calling sequence of rb_io_seek().

* parse.y (cond0): no special treatment of string literal in
  condition.

* math.c: add acos, asin, atan, conh, sinh, tanh and hypot to Math.

* configure.in: check hypot availablility.

* missing/hypot.c: public domain rewrite of hypot.

* parse.y (warn_unless_e_option): warning condition was wrong.

* parse.y (warning_unless_e_option): ditto.

* enum.c (enum_all): new method 'all?', which returns true if
  block returns true for all elements.

* enum.c (enum_any): new method 'any?', which returns true if
  block retruns true for any of elements.

* marshal.c (marshal_load): do not give warning unless explicitly
  set to verbose.

* eval.c (rb_exit): give string value "exit" to SystemExit.

* ruby.c (proc_options): -v should not print version if
  proc_options called via moreswitches().

* parse.y (stmt): while/until modifier must work for empty body.
@
text
@d6 1
a6 1
  $Date: 2001/02/26 05:29:00 $
d544 2
a545 2
rb_ary_replace(ary, beg, len, rpl)
    VALUE ary, rpl;
d547 2
a549 2
    long rlen;

a561 8
    if (NIL_P(rpl)) {
	rpl = rb_ary_new2(0);
    }
    else if (TYPE(rpl) != T_ARRAY) {
	rpl = rb_ary_new3(1, rpl);
    }
    rlen = RARRAY(rpl)->len;

d570 1
a570 1
	MEMCPY(RARRAY(ary)->ptr+beg, RARRAY(rpl)->ptr, VALUE, rlen);
d586 1
a586 1
	if (len != RARRAY(rpl)->len) {
d591 16
a606 1
	MEMMOVE(RARRAY(ary)->ptr+beg, RARRAY(rpl)->ptr, VALUE, rlen);
d608 1
d645 13
d1257 1
a1257 1
	    RARRAY(ary)->capa=end;
a1290 1
    long xlen = RARRAY(x)->len;
d1294 2
a1295 9
    ylen = RARRAY(y)->len;
    if (ylen > 0) {
	rb_ary_modify(x);
	if (xlen + ylen > RARRAY(x)->capa) {
	    RARRAY(x)->capa = xlen + ylen;
	    REALLOC_N(RARRAY(x)->ptr, VALUE, RARRAY(x)->capa);
	}
	MEMCPY(RARRAY(x)->ptr+xlen, RARRAY(y)->ptr, VALUE, ylen);
	RARRAY(x)->len = xlen + ylen;
d1614 28
d1646 1
a1646 1
    long i;
d1648 1
a1648 1
    VALUE flattening = Qnil;
d1651 1
a1651 1
    for (i=0; i<RARRAY(ary)->len; i++) {
d1653 1
d1655 2
a1656 13
	    if (ary == ary2) {
		ary2 = Qnil;
	    } else {
		VALUE id;

		if (NIL_P(flattening)) {
		    flattening = rb_ary_new();
		}
		id = rb_obj_id(ary2);
		if (rb_ary_includes(flattening, id)) {
		    rb_raise(rb_eArgError, "tried to flatten recursive array");
		}
		rb_ary_push(flattening, id);
d1658 1
a1658 1
	    rb_ary_replace(ary, i--, 1, ary2);
d1661 1
d1708 1
@


1.44
log
@* eval.c (proc_call): should not modify ruby_block->frame.iter
  based on ruby_frame->iter altered by PUSH_ITER().

* eval.c (rb_thread_fd_close): should save current context before
  raising exception.

* io.c (set_stdin): preserve original stdin.

* io.c (set_outfile): preserve original stdout/stderr.
@
text
@d6 1
a6 1
  $Date: 2001/02/19 09:14:58 $
d1103 1
a1103 1
VALUE
d1189 1
a1189 1
static VALUE
@


1.43
log
@* string.c (rb_str_substr): "a"[1,2] should return ""; need
  rubicon upgrade.
@
text
@d6 1
a6 1
  $Date: 2001/02/19 07:03:05 $
d286 2
a287 8
	long len = RARRAY(ary)->len;

	--argc;
	/* make rooms by copying the last item */
	rb_ary_store(ary, len + argc, argv[argc]);

	if (argc) {		/* if any rest */
	    MEMCPY(RARRAY(ary)->ptr + len, argv, VALUE, argc);
@


1.42
log
@* eval.c (secure_visibility): visibility check for untainted modules.

* signal.c (sigpipe): sighandler which does nothing.

* signal.c (trap): set sigpipe function for SIGPIPE.

* signal.c (Init_signal): default SIGPIPE handler should be
  sigpipe function.

* array.c (rb_ary_subseq): wrong boundary check.

* parse.y (cond0): integer literal in condition should not be
  compared to lineno ($.).
@
text
@d6 1
a6 1
  $Date: 2001/02/14 05:51:57 $
d403 1
a403 1
    if (beg >= RARRAY(ary)->len) return Qnil;
@


1.41
log
@* dir.c (dir_s_glob): supprt backslash escape of metacharacters
  and delimiters.

* dir.c (remove_backslases): remove backslashes from path before
  calling stat(2).

* dir.c (dir_s_glob): call rb_yield directly (via push_pattern) if
  block is given to the method.

* dir.c (push_pattern): do not call rb_ary_push; yield directly.

* eval.c (blk_copy_prev): reduced ALLOC_N too much.

* eval.c (frame_dup): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:38:10 $
d403 1
a403 1
    if (beg > RARRAY(ary)->len) return Qnil;
@


1.40
log
@* array.c (rb_ary_sort_bang): returns self, even if its length is
  less than 2.

* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2001/01/10 07:52:45 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.39
log
@* m17n baseline.
@
text
@d6 1
a6 1
  $Date: 2000/12/29 02:46:09 $
d387 1
a387 1
	offset = RARRAY(ary)->len + offset;
d434 1
a434 1
	    beg = RARRAY(ary)->len + beg;
d484 21
d1003 1
a1003 1
    if (RARRAY(ary)->len <= 1) return Qnil;
d1673 1
@


1.38
log
@thread_critical bug reported by Dave - matz
@
text
@d6 1
a6 1
  $Date: 2000/12/25 06:28:55 $
d1443 1
a1443 1
    int i, n;
@


1.37
log
@001225
@
text
@d6 1
a6 1
  $Date: 2000/12/12 07:42:21 $
d1358 1
a1358 2
    if (RARRAY(ary1)->len != RARRAY(ary2)->len)
	return Qfalse;
@


1.37.2.1
log
@commit miss; sorry
@
text
@d6 1
a6 1
  $Date: 2000/12/25 06:28:55 $
d403 1
a403 1
    if (beg >= RARRAY(ary)->len) return Qnil;
@


1.37.2.2
log
@* string.c (rb_str_substr): "a"[1,2] should return ""; need
  rubicon upgrade.
@
text
@d6 1
a6 1
  $Date: 2001/02/19 07:41:24 $
d403 1
a403 1
    if (beg > RARRAY(ary)->len) return Qnil;
@


1.37.2.3
log
@export rb_ary_clear()
@
text
@d6 1
a6 1
  $Date: 2001/02/19 09:15:27 $
d1174 1
a1174 1
VALUE
@


1.37.2.4
log
@* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): inifinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe leve 4.
@
text
@d6 1
a6 1
  $Date: 2001/03/13 05:51:40 $
a1586 28
static int
flatten(ary, idx, ary2, memo)
    VALUE ary;
    long idx;
    VALUE ary2, memo;
{
    VALUE id;
    long i = idx;
    long n, lim = idx + RARRAY(ary2)->len;

    id = rb_obj_id(ary2);
    if (rb_ary_includes(memo, id)) {
	rb_raise(rb_eArgError, "tried to flatten recursive array");
    }
    rb_ary_push(memo, id);
    rb_ary_replace(ary, idx, 1, ary2);
    while (i < lim) {
	if (TYPE(RARRAY(ary)->ptr[i]) == T_ARRAY) {
	    n = flatten(ary, i, RARRAY(ary)->ptr[i], memo);
	    i += n; lim += n;
	}
	i++;
    }
    rb_ary_pop(memo);

    return lim - idx - 1;	/* returns number of increased items */
}

d1591 1
a1591 1
    long i = 0;
d1593 1
a1593 1
    VALUE memo = Qnil;
d1596 1
a1596 1
    while (i<RARRAY(ary)->len) {
a1597 1

d1599 13
a1611 2
	    if (NIL_P(memo)) {
		memo = rb_ary_new();
d1613 1
a1613 1
	    i += flatten(ary, i, ary2, memo);
a1615 1
	i++;
@


1.37.2.5
log
@* array.c (rb_ary_and): should not push frozen key string.

* array.c (rb_ary_or): ditto.

* eval.c (rb_thread_schedule): should save context before raising
  deadlock, saved context for current thread might be obsolete.

* time.c (make_time_t): non DST timezone shift supported (hopefully).

* signal.c: SIGINFO added.

* eval.c (rb_ensure): should not SEGV when prot_tag is NULL.
@
text
@d6 1
a6 1
  $Date: 2001/05/01 08:45:10 $
d1471 1
a1471 1
	    rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1493 1
a1493 1
	    rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1499 1
a1499 1
	    rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
@


1.37.2.6
log
@array.c typo fixed.
@
text
@d6 1
a6 1
  $Date: 2001/05/15 08:49:20 $
d1499 1
a1499 1
	    rb_ary_push(ary3, RARRAY(ary2)->ptr[i]);
d1523 1
a1523 1
	    *q++ = *(p-1);
@


1.37.2.7
log
@* string.c (rb_str_cmp): remove needless conditional.

* array.c (rb_inspecting_p): initialize inspect_key if it is
  not initialized yet.
@
text
@d6 1
a6 1
  $Date: 2001/05/16 06:01:14 $
d852 1
a852 3
    if (!inspect_key) {
	inspect_key = rb_intern("__inspect_key__");
    }
@


1.37.2.8
log
@* array.c (rb_ary_equal): check identiry equality first.

* string.c (rb_str_equal): ditto.

* struct.c (rb_struct_equal): ditto.

* numeric.c (Init_Numeric): undef Integer::new.
@
text
@d6 1
a6 1
  $Date: 2001/08/14 08:10:59 $
a1343 1
    if (ary1 == ary2) return Qtrue;
@


1.37.2.9
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* string.c (rb_str_reverse): should return an instance of
  reciever's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/08/24 06:36:14 $
a416 1
    RBASIC(ary2)->klass = rb_obj_class(ary);
a1297 3

    OBJ_INFECT(ary2, ary);
    RBASIC(ary2)->klass = rb_obj_class(ary);
@


1.37.2.10
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.

* mkconfig.rb: use String#dump to generate Ruby string literal.

* range.c (range_eql): should override 'eql?'
@
text
@d6 1
a6 1
  $Date: 2001/10/02 04:25:51 $
a935 14
int
rb_cmpint(cmp)
    VALUE cmp;
{
    if (FIXNUM_P(cmp)) return NUM2LONG(cmp);
    if (TYPE(cmp) == T_BIGNUM) {
	if (RBIGNUM(cmp)->sign) return 1;
	return -1;
    }
    if (rb_funcall(cmp, '>', 1, INT2FIX(0))) return 1;
    if (rb_funcall(cmp, '<', 1, INT2FIX(0))) return -1;
    return 0;
}

d943 1
a943 1
    return rb_cmpint(retval);
d960 1
a960 1
    return rb_cmpint(retval);
@


1.37.2.11
log
@* intern.h: add prototypes.
  rb_str_dup_frozen()

* ruby.h: added declaration.
  rb_defout, rb_stdin, rb_stdout, rb_stderr, ruby_errinfo

* rubyio.h: changed double include guard macro to RUBYIO_H.

* array.c (inspect_call): make static.

* eval.c (dvar_asgn): ditto.

* io.c (rb_io_close_read): ditto.

* lex.c (rb_reserved_word): ditto.

* ruby.c: (req_list_head, req_list_last): ditto.

* ruby.c (require_libraries): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/11/13 08:22:26 $
d800 1
a800 1
static VALUE
@


1.37.2.12
log
@* array.c (sort_2): *a - *b may overflow.

* array.c (rb_ary_new2): len*sizeof(VALUE) may be a positive value.

* array.c (rb_ary_initialize): ditto.

* re.c (rb_reg_initialize): should not modify frozen Regexp.

* bignum.c (rb_uint2big): there should be no zero sized bignum.

* ext/extmk.rb.in: extmake() that works properly for both tkutil
  (tk/tkutil.so) and digest/sha1.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/12/17 08:13:16 $
d83 1
a83 1
    if (len > 0 && len*sizeof(VALUE) <= len) {
d198 1
a198 1
    if (len > 0 && len*sizeof(VALUE) <= len) {
d961 2
a962 2
sort_2(ap, bp)
    VALUE *ap, *bp;
a964 1
    VALUE a = *ap, b = *ap;
d966 2
a967 4
    if (FIXNUM_P(a) && FIXNUM_P(b)) {
	if (a > b) return INT2FIX(1);
	if (a < b) return INT2FIX(-1);
	return INT2FIX(0);
d969 2
a970 2
    if (TYPE(a) == T_STRING && TYPE(b) == T_STRING) {
	return rb_str_cmp(a, b);
d973 1
a973 1
    retval = rb_funcall(a, id_cmp, 1, b);
@


1.37.2.13
log
@* array.c (sort_2): comparison should be done as signed long.

* array.c (sort_2): should return int, not VALUE.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/19 05:59:05 $
d965 1
a965 1
    long a = (long)*ap, b = (long)*ap;
d968 3
a970 3
	if (a > b) return 1;
	if (a < b) return -1;
	return 0;
d976 1
a976 1
    retval = rb_funcall(a, cmp, 1, b);
@


1.37.2.14
log
@* array.c (sort_2): fatal typo.
@
text
@d6 1
a6 1
  $Date: 2002/08/19 06:40:41 $
d965 1
a965 1
    long a = (long)*ap, b = (long)*bp;
@


1.37.2.15
log
@* array.c, class.c, eval.c, file.c, gc.c, node.h, numeric.c,
  object.c, parse.y, range.c, re.c, string.c, struct.c, util.c,
  ext/socket/socket.c: merge from 1.7: treat long values as long
  instead of int.
@
text
@d6 1
a6 1
  $Date: 2002/08/19 06:44:09 $
d123 1
a123 1
	rb_raise(rb_eIndexError, "negative number of items(%ld)", n);
d243 1
a243 1
	    rb_raise(rb_eIndexError, "index %ld out of array",
d536 1
a536 1
    if (len < 0) rb_raise(rb_eIndexError, "negative length %ld", len);
d542 1
a542 1
	rb_raise(rb_eIndexError, "index %ld out of array", beg);
@


1.37.4.1
log
@m17n fix
@
text
@d6 1
a6 1
  $Date: 2000/12/25 06:28:55 $
d1444 1
a1444 1
    int i;
@


1.36
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/08 07:10:15 $
a1465 3
    if (RARRAY(ary1)->len < RARRAY(ary2)->len) { /* swap */
	VALUE tmp = ary1; ary1 = ary2; ary2 = tmp;
    }
@


1.35
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/05 09:36:24 $
d1440 1
a1440 1
ary_make_hash(ary1, ary2, func)
a1441 1
    int (*func)();
@


1.34
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/20 07:31:38 $
d1439 1
a1439 1
static st_table*
d1444 1
a1444 1
    st_table *tbl = st_init_numtable();
d1448 1
a1448 3
	if (!st_lookup(tbl, RARRAY(ary1)->ptr[i], &n)) {
	    st_add_direct(tbl, RARRAY(ary1)->ptr[i], 0);
	}
d1452 1
a1452 6
	    if (st_lookup(tbl, RARRAY(ary2)->ptr[i], &n)) {
		st_insert(tbl, RARRAY(ary2)->ptr[i], 2);
	    }
	    else {
		st_add_direct(tbl, RARRAY(ary2)->ptr[i], 1);
	    }
d1455 1
a1455 1
    return tbl;
d1462 1
a1462 1
    st_table *tbl = ary_make_hash(ary1, to_ary(ary2));
a1463 1
    VALUE v;
d1465 6
a1470 1
    int n;
d1473 3
a1475 3
	v = RARRAY(ary1)->ptr[i];
	if (st_delete(tbl, &v, &n)) {
	    if (n == 2) rb_ary_push(ary3, v);
a1477 1
    st_free_table(tbl);
d1486 1
a1486 1
    st_table *tbl;
d1492 1
a1492 1
    tbl = ary_make_hash(ary1, ary2);
d1496 1
a1496 1
	if (st_delete(tbl, &v, 0)) {
d1502 1
a1502 1
	if (st_delete(tbl, &v, 0)) {
a1505 1
    st_free_table(tbl);
d1514 1
a1514 1
    st_table *tbl = ary_make_hash(ary, 0);
a1515 1
    VALUE v;
d1517 1
a1517 2
    if (RARRAY(ary)->len == tbl->num_entries) {
	st_free_table(tbl);
d1520 1
a1521 1

d1525 2
a1526 2
	v = *p++;
	if (st_delete(tbl, &v, 0)) {
@


1.33
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/31 08:37:37 $
d17 1
d1439 26
d1469 3
a1471 1
    VALUE ary3;
d1473 1
a1474 2
    ary2 = to_ary(ary2);
    ary3 = rb_ary_new();
d1476 3
a1478 3
	if (rb_ary_includes(ary2, RARRAY(ary1)->ptr[i])
	    && !rb_ary_includes(ary3, RARRAY(ary1)->ptr[i])) {
	    rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1481 2
d1490 3
a1492 1
    VALUE ary3;
d1495 2
a1496 4
    if (TYPE(ary2) != T_ARRAY) {
	if (rb_ary_includes(ary1, ary2)) return ary1;
	else return rb_ary_push(ary1, ary2);
    }
a1497 1
    ary3 = rb_ary_new();
d1499 4
a1502 2
	if (!rb_ary_includes(ary3, RARRAY(ary1)->ptr[i]))
		rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1505 4
a1508 2
	if (!rb_ary_includes(ary3, RARRAY(ary2)->ptr[i]))
		rb_ary_push(ary3, RARRAY(ary2)->ptr[i]);
d1510 2
d1519 2
a1520 1
    VALUE *p, *q, *t, *end;
d1523 4
d1528 2
a1529 1
    p = RARRAY(ary)->ptr;
a1530 1

d1533 2
a1534 4
	q = t = p;
	while (q < end) {
	    if (rb_equal(*q, v)) q++;
	    else *t++ = *q++;
a1535 4
	end = t;
    }
    if (RARRAY(ary)->len == (end - RARRAY(ary)->ptr)) {
	return Qnil;
d1537 1
a1537 2

    RARRAY(ary)->len = (end - RARRAY(ary)->ptr);
@


1.32
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/25 04:48:39 $
d25 1
a25 1
    register size_t size;
d35 1
a35 1
    register size_t size;
d403 2
a404 5
    if (beg < 0) {
	len += beg;
	beg = 0;
    }
    if (len < 0) return Qnil;
d532 1
a532 1
    int rlen;
d1254 2
a1255 2
    int xlen = RARRAY(x)->len;
    int ylen;
d1371 2
a1372 1
    int n, h;
@


1.31
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/10 07:03:15 $
d1589 1
a1589 1
		    rb_raise(rb_eArgError, "tryed to flatten recursive array");
@


1.30
log
@matz
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/09/12 07:08:40 $
d291 1
a291 1
	if (argc)		/* if any rest */
d293 1
d535 2
d555 1
d559 1
a559 1
	len = beg + RARRAY(rpl)->len;
d565 1
a565 1
	MEMCPY(RARRAY(ary)->ptr+beg, RARRAY(rpl)->ptr, VALUE, RARRAY(rpl)->len);
d575 1
a575 1
	alen = RARRAY(ary)->len + RARRAY(rpl)->len - len;
d582 1
a582 1
	    MEMMOVE(RARRAY(ary)->ptr+beg+RARRAY(rpl)->len, RARRAY(ary)->ptr+beg+len,
d586 1
a586 1
	MEMCPY(RARRAY(ary)->ptr+beg, RARRAY(rpl)->ptr, VALUE, RARRAY(rpl)->len);
d1257 3
d1261 9
a1269 2
    if (RARRAY(y)->len > 0) {
	rb_ary_push_m(RARRAY(y)->len, RARRAY(y)->ptr, x);
@


1.29
log
@eban
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/09/12 05:37:19 $
d281 3
d909 2
a910 3
	*p1 = *p2;
	*p2 = tmp;
	p1++; p2--;
d1241 1
a1241 2
    Check_Type(y, T_ARRAY);

d1253 4
a1256 3
    Check_Type(y, T_ARRAY);

    rb_ary_push_m(RARRAY(y)->len, RARRAY(y)->ptr, x);
@


1.28
log
@matz: 1.6.0 final (hopufully)
@
text
@d6 1
a6 1
  $Date: 2000/08/24 06:21:27 $
d361 1
a361 1
    if (argc > 1) {
@


1.27
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/07 05:01:46 $
d358 4
a361 1
    if (argc > 0) {
a368 1

@


1.26
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/17 09:37:55 $
d896 1
a897 1
    if (RARRAY(ary)->len == 0) return ary;
d913 8
d976 1
a976 1
    if (RARRAY(ary)->len <= 1) return ary;
d1636 1
a1636 1
    rb_define_method(rb_cArray, "reverse!", rb_ary_reverse, 0);
@


1.25
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/22 08:29:40 $
d1124 1
a1124 1
rb_ary_delete_if(ary)
d1137 1
d1144 8
d1286 1
a1286 1
	    && RARRAY(*p)->len > 1
d1638 1
a1638 1
    rb_define_method(rb_cArray, "reject!", rb_ary_delete_if, 0);
@


1.24
log
@2000-06-22
@
text
@d6 1
a6 1
  $Date: 2000/05/30 04:23:53 $
a679 15
rb_ary_dup(ary)
    VALUE ary;
{
    VALUE klass = CLASS_OF(ary);
    VALUE dup;

    while (TYPE(klass) == T_ICLASS || FL_TEST(klass, FL_SINGLETON)) {
	klass = (VALUE)RCLASS(klass)->super;
    }
    dup = rb_ary_s_create(RARRAY(ary)->len, RARRAY(ary)->ptr, klass);
    if (OBJ_TAINTED(ary)) OBJ_TAINT(dup);
    return dup;
}

static VALUE
d916 1
a916 1
    return rb_ary_reverse(rb_ary_dup(ary));
d979 1
a979 1
    ary = rb_ary_dup(ary);
d992 1
a992 1
	return rb_ary_dup(ary);
d1480 1
a1480 1
    ary = rb_ary_dup(ary);
d1511 1
a1511 1
    ary = rb_ary_dup(ary);
d1570 1
a1570 1
    ary = rb_ary_dup(ary);
a1616 1
    rb_define_method(rb_cArray, "dup", rb_ary_dup, 0);
@


1.23
log
@2000-05-30
@
text
@d6 1
a6 1
  $Date: 2000/05/24 04:33:52 $
d683 1
d686 4
a689 1
    dup = rb_ary_s_create(RARRAY(ary)->len, RARRAY(ary)->ptr, CLASS_OF(ary));
@


1.22
log
@2000-05-24
@
text
@d6 1
a6 1
  $Date: 2000/05/12 09:07:31 $
d1085 7
d1639 1
a1639 1
    rb_define_method(rb_cArray, "delete_at", rb_ary_delete_at, -1);
@


1.21
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/10 02:58:32 $
a586 1
    VALUE arg1, arg2, arg3;
d589 3
a591 3
    if (rb_scan_args(argc, argv, "21", &arg1, &arg2, &arg3) == 3) {
	rb_ary_replace(ary, NUM2LONG(arg1), NUM2LONG(arg2), arg3);
	return arg3;
d593 5
a597 2
    else if (FIXNUM_P(arg1)) {
	offset = FIX2LONG(arg1);
d600 1
a600 1
    else if (rb_range_beg_len(arg1, &beg, &len, RARRAY(ary)->len, 1)) {
d602 2
a603 2
	rb_ary_replace(ary, beg, len, arg2);
	return arg2;
d605 1
a605 1
    if (TYPE(arg1) == T_BIGNUM) {
d609 1
a609 1
    offset = NUM2LONG(arg1);
d611 2
a612 2
    rb_ary_store(ary, offset, arg2);
    return arg2;
d962 1
a962 1
	  rb_iterator_p()?sort_1:sort_2);
d1002 1
a1002 1
    if (!rb_iterator_p()) {
d1051 1
a1051 1
	if (rb_iterator_p()) {
d1086 1
a1086 1
rb_ary_delete_at_m(argc, argv, ary)
d1632 1
a1632 1
    rb_define_method(rb_cArray, "delete_at", rb_ary_delete_at_m, -1);
d1642 1
a1642 1
    rb_define_method(rb_cArray, "slice!", rb_ary_delete_at_m, -1);
@


1.20
log
@2000-05-10
@
text
@d6 1
a6 1
  $Date: 2000/05/09 04:52:51 $
a1603 1
    rb_define_method(rb_cArray, "append", rb_ary_push_m, -1);
@


1.19
log
@2000-05-09
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:10 $
d1604 1
@


1.18
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:44:05 $
d11 1
a11 1
  Copyright (C) 2000  Information-technology Promotion Agancy, Japan
@


1.17
log
@2000-04-10
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/03/17 08:58:09 $
d10 2
d13 1
a13 1
************************************************/
d281 9
a289 2
    while (argc--) {
	rb_ary_store(ary, RARRAY(ary)->len, *argv++);
d352 20
d1012 21
a1144 13
rb_ary_filter(ary)
    VALUE ary;
{
    long i;

    rb_ary_modify(ary);
    for (i = 0; i < RARRAY(ary)->len; i++) {
	RARRAY(ary)->ptr[i] = rb_yield(RARRAY(ary)->ptr[i]);
    }
    return ary;
}

static VALUE
a1234 3
    VALUE *p, *pend;

    rb_ary_modify(x);
d1237 1
a1237 6
    p = RARRAY(y)->ptr;
    pend = p + RARRAY(y)->len;
    while (p < pend) {
	rb_ary_store(x, RARRAY(x)->len, *p);
	p++;
    }
d1607 1
a1607 1
    rb_define_method(rb_cArray, "unshift", rb_ary_unshift, 1);
d1626 3
a1632 1
    rb_define_method(rb_cArray, "filter", rb_ary_filter, 0);
@


1.16
log
@2000-03-17
@
text
@d6 1
a6 1
  $Date: 2000/02/29 08:05:24 $
d731 2
a732 2
	if (!NIL_P(sep)) rb_str_concat(result, sep);
	rb_str_cat(result, RSTRING(tmp)->ptr, RSTRING(tmp)->len);
d844 2
a845 2
	if (i > 0) rb_str_cat(str, ", ", 2);
	rb_str_cat(str, RSTRING(s)->ptr, RSTRING(s)->len);
@


1.15
log
@2000-02-29
@
text
@d6 1
a6 1
  $Date: 2000/02/23 05:23:03 $
d707 1
a707 1
	result = rb_obj_as_string(tmp);
@


1.14
log
@2000-02-23
@
text
@d6 1
a6 1
  $Date: 2000/02/17 07:11:06 $
d170 14
a183 1
    long len = 0;
a184 2
    NEWOBJ(ary, struct RArray);
    OBJSETUP(ary, klass, T_ARRAY);
a185 2
    ary->len = 0;
    ary->ptr = 0;
d187 1
a187 1
	ary->capa = ARY_DEFAULT_SIZE;
a188 2
    else {
	long capa = NUM2LONG(size);
d190 11
a200 8
	if (capa < 0) {
	    rb_raise(rb_eArgError, "negative array size");
	}
	if (capa > 0 && capa*sizeof(VALUE) <= 0) {
	    rb_raise(rb_eArgError, "array size too big");
	}
	ary->capa = capa;
	len = capa;
d202 2
a203 3
    ary->ptr = ALLOC_N(VALUE, ary->capa);
    memfill(ary->ptr, len, val);
    ary->len = len;
d205 1
a205 1
    return (VALUE)ary;
d1556 1
@


1.13
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:11:58 $
d672 1
a672 1
    int taint;
d826 1
d834 1
d840 1
@


1.12
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/18 06:09:02 $
d52 7
@


1.11
log
@2000-01-18
@
text
@d6 1
a6 1
  $Date: 2000/01/08 05:00:17 $
d41 1
a41 2
#define ARY_FREEZE   FL_USER1
#define ARY_TMPLOCK  FL_USER2
d47 1
a47 2
    if (FL_TEST(ary, ARY_FREEZE))
	rb_raise(rb_eTypeError, "can't modify frozen array");
a53 11
VALUE
rb_ary_freeze(ary)
    VALUE ary;
{
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(ary))
	rb_raise(rb_eSecurityError, "Insecure: can't freeze array");
	
    FL_SET(ary, ARY_FREEZE);
    return ary;
}

d58 1
a58 1
    if (FL_TEST(ary, ARY_FREEZE|ARY_TMPLOCK))
d345 1
a345 1
rb_ary_subary(ary, beg, len)
d387 1
a387 1
	return rb_ary_subary(ary, beg, len);
d405 1
a405 1
	    return rb_ary_subary(ary, beg, len);
a779 1

d781 1
d791 2
a792 1
    if (rb_ary_includes(inspect_tbl, obj)) {
d795 1
a795 1
    rb_ary_push(inspect_tbl, obj);
d812 1
a812 1
    return rb_ary_includes(inspect_tbl, obj);
d1031 1
a1031 1
	arg2 = rb_ary_subary(ary, pos, len);
d1055 1
d1492 1
d1498 14
a1540 2

    rb_define_method(rb_cArray, "freeze",  rb_ary_freeze, 0);
d1587 3
@


1.10
log
@2000-01-08
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:36:56 $
d1304 1
a1304 1
    int h;
d1308 2
a1309 1
	int n = rb_hash(RARRAY(ary)->ptr[i]);
@


1.9
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:49:39 $
a294 25
static VALUE
rb_ary_pop_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    int n = 1;
    VALUE result;

    if (argc == 0) {
	return rb_ary_pop(ary);
    }
    if (argc > 2) {
	rb_raise(rb_eArgError, "wrong # of arguments (%d for 1)", argc);
    }
    n = NUM2INT(argv[0]);
    if (RARRAY(ary)->len < n)
	n = RARRAY(ary)->len;
    result = rb_ary_new2(n);
    while (n--) {
	rb_ary_store(result, n, rb_ary_pop(ary));
    }
    return result;
}

a316 25
static VALUE
rb_ary_shift_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    int n = 1;
    VALUE result;

    if (argc == 0) {
	return rb_ary_shift(ary);
    }
    if (argc > 2) {
	rb_raise(rb_eArgError, "wrong # of arguments (%d for 1)", argc);
    }
    n = NUM2INT(argv[0]);
    if (RARRAY(ary)->len < n)
	n = RARRAY(ary)->len;
    result = rb_ary_new2(n);
    while (n--) {
	rb_ary_push(result, rb_ary_shift(ary));
    }
    return result;
}

d1553 2
a1554 2
    rb_define_method(rb_cArray, "pop", rb_ary_pop_m, -1);
    rb_define_method(rb_cArray, "shift", rb_ary_shift_m, -1);
@


1.8
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/10/29 09:25:30 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d271 1
a271 1
rb_ary_push_method(argc, argv, ary)
d295 25
d342 25
d559 5
a563 2
    if (TYPE(rpl) != T_ARRAY) {
	rpl = rb_Array(rpl);
d687 1
a687 1
    VALUE ary2 = rb_ary_new2(RARRAY(ary)->len);
d689 4
a692 4
    CLONESETUP(ary2, ary);
    MEMCPY(RARRAY(ary2)->ptr, RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);
    RARRAY(ary2)->len = RARRAY(ary)->len;
    return ary2;
d699 5
a703 1
    return rb_ary_s_create(RARRAY(ary)->len, RARRAY(ary)->ptr, CLASS_OF(ary));
d728 1
d730 1
d732 2
d736 1
d780 1
a780 1
	if (OBJ_TAINTED(tmp)) OBJ_TAINT(result);
d783 1
d788 1
a788 1
rb_ary_join_method(argc, argv, ary)
d854 3
d861 1
d936 1
a936 1
rb_ary_reverse_method(ary)
d1055 1
a1055 1
rb_ary_delete_at(ary, at)
d1057 1
a1057 1
    VALUE at;
d1059 1
a1059 1
    long i, pos = NUM2LONG(at), len = RARRAY(ary)->len;
d1077 41
d1150 1
a1150 1
rb_ary_replace_method(ary, ary2)
d1227 1
a1227 3
    if (TYPE(y) != T_ARRAY) {
	y = rb_Array(y);
    }
d1243 1
a1243 3
    if (TYPE(y) != T_ARRAY) {
	y = rb_Array(y);
    }
d1446 1
a1446 1
	else return rb_ary_plus(ary1, ary2);
d1602 3
a1604 3
    rb_define_method(rb_cArray, "push", rb_ary_push_method, -1);
    rb_define_method(rb_cArray, "pop", rb_ary_pop, 0);
    rb_define_method(rb_cArray, "shift", rb_ary_shift, 0);
d1618 2
a1619 2
    rb_define_method(rb_cArray, "join", rb_ary_join_method, -1);
    rb_define_method(rb_cArray, "reverse", rb_ary_reverse_method, 0);
d1625 1
a1625 1
    rb_define_method(rb_cArray, "delete_at", rb_ary_delete_at, 1);
d1629 1
a1629 1
    rb_define_method(rb_cArray, "replace", rb_ary_replace_method, 1);
@


1.7
log
@19991029
@
text
@d6 1
a6 1
  $Date: 1999/10/20 07:10:22 $
d52 1
a52 1
    if (!FL_TEST(ary, FL_TAINT) && rb_safe_level() >= 4)
d60 3
@


1.6
log
@marshal load GC protect
@
text
@d6 1
a6 1
  $Date: 1999/10/18 09:03:00 $
d937 19
d1516 1
@


1.5
log
@19991018
@
text
@d6 1
a6 1
  $Date: 1999/10/16 10:33:05 $
d933 2
a934 2
    if (RARRAY(ary)->len == 0) return ary;
    return rb_ary_sort_bang(ary);
d1368 3
a1370 4
    VALUE v = rb_ary_uniq_bang(rb_ary_dup(ary));

    if (NIL_P(v)) return ary;
    return v;
d1399 3
a1401 4
    VALUE v = rb_ary_compact_bang(rb_ary_dup(ary));

    if (NIL_P(v)) return ary;
    return v;
d1443 3
a1445 4
    VALUE v = rb_ary_flatten_bang(rb_ary_dup(ary));

    if (NIL_P(v)) return ary;
    return v;
@


1.4
log
@ruby -v
@
text
@d6 1
a6 1
  $Date: 1999/10/13 06:44:40 $
d283 1
d298 1
d849 1
d1032 1
@


1.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:02 $
d917 1
a919 1
    rb_ary_modify(ary);
d929 1
d931 1
a931 1
    return rb_ary_sort_bang(rb_ary_dup(ary));
d970 1
a974 1
    rb_ary_modify(ary);
d1094 1
a1094 1
	return rb_ary_plus(x, rb_Array(y));
d1110 1
d1112 1
a1112 1
	return rb_ary_concat(x, rb_Array(y));
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/11 07:23:48 $
d420 23
d966 1
a966 1
    long i1, i2, pos;
d969 4
d974 3
a976 10
    pos = NUM2LONG(at);
    for (i1 = i2 = 0; i1 < RARRAY(ary)->len; i1++) {
	if (i1 == pos) {
	    del = RARRAY(ary)->ptr[i1];
	    continue;
	}
	if (i1 != i2) {
	    RARRAY(ary)->ptr[i2] = RARRAY(ary)->ptr[i1];
	}
	i2++;
d978 1
a978 1
    RARRAY(ary)->len = i2;
d1468 3
@


1.2.2.1
log
@19991018
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:02 $
a282 1
    rb_ary_modify(ary);
a296 1
    rb_ary_modify(ary);
a823 1
    rb_ary_modify(ary);
a945 4
    if (pos >= len) return Qnil;
    if (pos < 0) pos += len;
    if (pos < 0) return Qnil;

a1007 1
    rb_ary_modify(ary);
@


1.2.2.2
log
@19991018
@
text
@d6 1
a6 1
  $Date: 1999/10/18 09:03:15 $
d946 1
a946 1
    long i, pos = NUM2LONG(at), len = RARRAY(ary)->len;
a948 1
    rb_ary_modify(ary);
d953 11
a963 3
    del = RARRAY(ary)->ptr[pos];
    for (i = pos + 1; i < len; i++, pos++) {
	RARRAY(ary)->ptr[pos] = RARRAY(ary)->ptr[i];
d965 1
a965 1
    RARRAY(ary)->len = pos;
@


1.2.2.3
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 1999/10/18 09:07:13 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
@


1.2.2.4
log
@2000-03-23
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:23:51 $
d666 1
a666 1
	result = rb_str_dup(rb_obj_as_string(tmp));
@


1.2.2.5
log
@2000-06-05
@
text
@d6 1
a6 1
  $Date: 2000/03/23 04:14:07 $
a1476 1
    rb_define_method(rb_cArray, "collect!", rb_ary_filter, 0);
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1996/12/25 10:42:18 $
d9 1
a9 1
  Copyright (C) 1993-1996 Yukihiro Matsumoto
d14 1
d16 1
a16 3
VALUE cArray;

VALUE rb_to_a();
d21 1
a21 1
memclear(mem, size)
d23 1
a23 1
    register int size;
d30 11
d42 1
d45 1
a45 1
ary_modify(ary)
d48 6
a53 4
    rb_secure(5);
    if (FL_TEST(ary, ARY_FREEZE)) {
	TypeError("can't modify frozen array");
    }
d57 1
a57 1
ary_freeze(ary)
d65 1
a65 1
ary_frozen_p(ary)
d68 3
a70 3
    if (FL_TEST(ary, ARY_FREEZE))
	return TRUE;
    return FALSE;
d74 2
a75 2
ary_new2(len)
    int len;
d78 1
a78 1
    OBJSETUP(ary, cArray, T_ARRAY);
d80 6
d88 3
a90 6
    if (len == 0)
	ary->ptr = 0;
    else {
	ary->ptr = ALLOC_N(VALUE, len);
	memclear(ary->ptr, len);
    }
d96 1
a96 1
ary_new()
d98 1
a98 1
    return ary_new2(ARY_DEFAULT_SIZE);
d101 4
d106 2
d110 5
a114 2
ary_new3(n, va_alist)
    int n;
d116 1
d119 2
a120 2
    struct RArray* ary;
    int i;
d123 1
a123 1
	IndexError("Negative number of items(%d)", n);
d125 1
a125 1
    ary = (struct RArray*)ary_new2(n<ARY_DEFAULT_SIZE?ARY_DEFAULT_SIZE:n);
d127 1
a127 1
    va_start(ar);
d129 1
a129 1
	ary->ptr[i] = va_arg(ar, VALUE);
d133 2
a134 2
    ary->len = n;
    return (VALUE)ary;
d138 2
a139 2
ary_new4(n, elts)
    int n;
d142 1
a142 1
    struct RArray* ary;
d144 5
a148 3
    ary = (struct RArray*)ary_new2(n);
    MEMCPY(ary->ptr, elts, VALUE, n);
    ary->len = n;
d150 1
a150 1
    return (VALUE)ary;
d154 1
a154 1
assoc_new(car, cdr)
d157 1
a157 1
    struct RArray* ary;
d159 4
a162 4
    ary = (struct RArray*)ary_new2(2);
    ary->ptr[0] = car;
    ary->ptr[1] = cdr;
    ary->len = 2;
d164 1
a164 1
    return (VALUE)ary;
d168 1
a168 1
ary_s_new(argc, argv, class)
d171 1
a171 1
    VALUE class;
d173 2
a174 1
    VALUE size;
d176 1
a176 1
    OBJSETUP(ary, class, T_ARRAY);
a177 1
    rb_scan_args(argc, argv, "01", &size);
d179 16
a194 1
    ary->capa = NIL_P(size)?ARY_DEFAULT_SIZE:NUM2INT(size);
d196 2
a197 1
    memclear(ary->ptr, ary->capa);
d203 1
a203 1
ary_s_create(argc, argv, class)
d206 1
a206 1
    VALUE class;
d209 1
a209 1
    OBJSETUP(ary, class, T_ARRAY);
d211 1
a211 2
    ary->len = argc;
    ary->capa = argc;
d219 1
d225 3
a227 3
ary_store(ary, idx, val)
    struct RArray *ary;
    int idx;
d230 1
a230 1
    ary_modify(ary);
d232 5
a236 1
	IndexError("negative index for array");
d239 7
a245 3
    if (idx >= ary->capa) {
	ary->capa = idx + ARY_DEFAULT_SIZE;
	REALLOC_N(ary->ptr, VALUE, ary->capa);
d247 3
a249 2
    if (idx > ary->len) {
	memclear(ary->ptr+ary->len, idx-ary->len+1);
d252 2
a253 2
    if (idx >= ary->len) {
	ary->len = idx + 1;
d255 1
a255 1
    ary->ptr[idx] = val;
d259 2
a260 2
ary_push(ary, item)
    struct RArray *ary;
d263 2
a264 2
    ary_store(ary, ary->len, item);
    return (VALUE)ary;
d268 1
a268 1
ary_push_method(argc, argv, ary)
d271 1
a271 1
    struct RArray *ary;
d274 1
a274 1
	ary_store(ary, ary->len, *argv++);
d276 1
a276 1
    return (VALUE)ary;
d280 2
a281 2
ary_pop(ary)
    struct RArray *ary;
d283 4
a286 4
    if (ary->len == 0) return Qnil;
    if (ary->len * 10 < ary->capa && ary->capa > ARY_DEFAULT_SIZE) {
	ary->capa = ary->len * 2;
	REALLOC_N(ary->ptr, VALUE, ary->capa);
d288 1
a288 1
    return ary->ptr[--ary->len];
d292 2
a293 2
ary_shift(ary)
    struct RArray *ary;
d297 1
a297 1
    if (ary->len == 0) return Qnil;
d299 2
a300 2
    top = ary->ptr[0];
    ary->len--;
d303 4
a306 4
    MEMMOVE(ary->ptr, ary->ptr+1, VALUE, ary->len);
    if (ary->len * 10 < ary->capa && ary->capa > ARY_DEFAULT_SIZE) {
	ary->capa = ary->len * 2;
	REALLOC_N(ary->ptr, VALUE, ary->capa);
d313 11
a323 8
ary_unshift(ary, item)
    struct RArray *ary;
    int item;
{
    ary_modify(ary);
    if (ary->len >= ary->capa) {
	ary->capa+=ARY_DEFAULT_SIZE;
	REALLOC_N(ary->ptr, VALUE, ary->capa);
d327 1
a327 1
    MEMMOVE(ary->ptr+1, ary->ptr, VALUE, ary->len);
d329 4
a332 2
    ary->len++;
    return ary->ptr[0] = item;
d336 3
a338 3
ary_entry(ary, offset)
    struct RArray *ary;
    int offset;
d340 1
a340 1
    if (ary->len == 0) return Qnil;
d343 1
a343 1
	offset = ary->len + offset;
d345 1
a345 1
    if (offset < 0 || ary->len <= offset) {
d349 1
a349 1
    return ary->ptr[offset];
d353 3
a355 3
ary_subseq(ary, beg, len)
    struct RArray *ary;
    int beg, len;
d357 1
a357 1
    struct RArray *ary2;
d359 1
d361 6
a366 2
	beg = ary->len + beg;
	if (beg < 0) beg = 0;
d369 1
a369 7
	IndexError("negative length %d", ary->len);
    }
    if (len == 0) {
	return ary_new2(0);
    }
    if (beg + len > ary->len) {
	len = ary->len - beg;
d371 1
d373 3
a375 3
    ary2 = (struct RArray*)ary_new2(len);
    MEMCPY(ary2->ptr, ary->ptr+beg, VALUE, len);
    ary2->len = len;
d377 1
a377 1
    return (VALUE)ary2;
d380 2
a381 40
static VALUE
beg_len(range, begp, lenp, len)
    VALUE range;
    int *begp, *lenp;
    int len;
{
    int beg, end;

    if (!range_beg_end(range, &beg, &end)) return FALSE;

    if ((beg > 0 && end > 0 || beg < 0 && end < 0) && beg > end) {
	IndexError("end smaller than beg [%d..%d]", beg, end);
    }

    if (beg < 0) {
	beg = len + beg;
	if (beg < 0) beg = 0;
    }
    *begp = beg;
    if (beg > len) {
	*lenp = 0;
    }
    else {
	if (end < 0) {
	    end = len + end;
	    if (end < 0) end = -1;
	}
	if (end > len) end = len;
	if (beg > end) {
	    *lenp = 0;
	}
	else {
	    *lenp = end - beg +1;
	}
    }
    return TRUE;
}

static VALUE
ary_aref(argc, argv, ary)
d384 1
a384 1
    struct RArray *ary;
d387 1
a387 1
    int beg, len;
d390 4
a393 4
	beg = NUM2INT(arg1);
	len = NUM2INT(arg2);
	if (len <= 0) {
	    return ary_new();
d395 1
a395 1
	return ary_subseq(ary, beg, len);
d400 4
a403 1
	return ary_entry(ary, FIX2INT(arg1));
d407 7
a413 2
	if (beg_len(arg1, &beg, &len, ary->len)) {
	    return ary_subseq(ary, beg, len);
d416 13
a428 2
    if (TYPE(arg1) == T_BIGNUM) {
	IndexError("index too big");
d430 1
a430 1
    return ary_entry(ary, NUM2INT(arg1));
d434 2
a435 2
ary_index(ary, val)
    struct RArray *ary;
d438 1
a438 1
    int i;
d440 3
a442 3
    for (i=0; i<ary->len; i++) {
	if (rb_equal(ary->ptr[i], val))
	    return INT2FIX(i);
d448 4
a451 2
ary_indexes(ary, args)
    struct RArray *ary, *args;
a452 1
    VALUE *p, *pend;
d454 1
a454 1
    int i = 0;
d456 3
a458 2
    if (!args || NIL_P(args)) {
	return ary_new2(0);
a460 7
    new_ary = ary_new2(args->len);

    p = args->ptr; pend = p + args->len;
    while (p < pend) {
	ary_store(new_ary, i++, ary_entry(ary, NUM2INT(*p)));
	p++;
    }
d465 3
a467 3
ary_replace(ary, beg, len, rpl)
    struct RArray *ary, *rpl;
    int beg, len;
d469 3
a471 3
    ary_modify(ary);
    if (TYPE(rpl) != T_ARRAY) {
	rpl = (struct RArray*)rb_to_a(rpl);
d474 2
a475 2
	beg = ary->len + beg;
	if (beg < 0) beg = 0;
d477 18
a494 9
    if (beg >= ary->len) {
	len = beg + rpl->len;
	if (len >= ary->capa) {
	    ary->capa=len;
	    REALLOC_N(ary->ptr, VALUE, ary->capa);
	}
	memclear(ary->ptr+ary->len, beg-ary->len);
	MEMCPY(ary->ptr+beg, rpl->ptr, VALUE, rpl->len);
	ary->len = len;
d497 1
a497 1
	int alen;
d499 2
a500 5
	if (beg + len > ary->len) {
	    len = ary->len - beg;
	}
	if (len < 0) {
	    IndexError("negative length %d", ary->len);
d503 4
a506 4
	alen = ary->len + rpl->len - len;
	if (alen >= ary->capa) {
	    ary->capa=alen;
	    REALLOC_N(ary->ptr, VALUE, ary->capa);
d510 3
a512 3
	    MEMMOVE(ary->ptr+beg+rpl->len, ary->ptr+beg+len,
		    VALUE, ary->len-(beg+len));
	    ary->len = alen;
d514 1
a514 1
	MEMCPY(ary->ptr+beg, rpl->ptr, VALUE, rpl->len);
d519 1
a519 1
ary_aset(argc, argv, ary)
d522 1
a522 1
    struct RArray *ary;
d524 2
a525 4
    VALUE arg1, arg2;
    struct RArray *arg3;
    int offset;
    int beg, len;
d528 2
a529 4
	beg = NUM2INT(arg1);
	len = NUM2INT(arg2);
	ary_replace(ary, beg, len, arg3);
	return (VALUE)arg3;
d532 1
a532 1
	offset = FIX2INT(arg1);
d535 1
a535 1
    else if (beg_len(arg1, &beg, &len, ary->len)) {
d537 1
a537 1
	ary_replace(ary, beg, len, arg2);
d541 1
a541 1
	IndexError("index too big");
d544 1
a544 1
    offset = NUM2INT(arg1);
d546 1
a546 4
    if (offset < 0) {
	offset = ary->len + offset;
    }
    ary_store(ary, offset, arg2);
d551 2
a552 2
ary_each(ary)
    struct RArray *ary;
d554 1
a554 1
    int i;
d556 2
a557 2
    for (i=0; i<ary->len; i++) {
	rb_yield(ary->ptr[i]);
d559 1
a559 1
    return Qnil;
d563 2
a564 2
ary_each_index(ary)
    struct RArray *ary;
d566 1
a566 1
    int i;
d568 2
a569 2
    for (i=0; i<ary->len; i++) {
	rb_yield(INT2FIX(i));
d571 1
a571 1
    return Qnil;
d575 2
a576 2
ary_reverse_each(ary)
    struct RArray *ary;
d578 1
a578 1
    int len = ary->len;
d581 1
a581 1
	rb_yield(ary->ptr[len]);
d583 1
a583 1
    return Qnil;
d587 2
a588 2
ary_length(ary)
    struct RArray *ary;
d590 1
a590 1
    return INT2FIX(ary->len);
d594 2
a595 2
ary_empty_p(ary)
    struct RArray *ary;
d597 3
a599 3
    if (ary->len == 0)
	return TRUE;
    return FALSE;
d603 2
a604 2
ary_clone(ary)
    struct RArray *ary;
d606 1
a606 1
    VALUE ary2 = ary_new2(ary->len);
d609 2
a610 2
    MEMCPY(RARRAY(ary2)->ptr, ary->ptr, VALUE, ary->len);
    RARRAY(ary2)->len = ary->len;
d614 23
a636 1
extern VALUE OFS;
d639 2
a640 3
ary_join(ary, sep)
    struct RArray *ary;
    struct RString *sep;
d642 1
a642 1
    int i;
d644 1
a644 1
    if (ary->len == 0) return str_new(0, 0);
d646 2
a647 1
    switch (TYPE(ary->ptr[0])) {
d649 1
a649 1
	result = str_dup(ary->ptr[0]);
d652 10
a661 1
	result = ary_join(ary->ptr[0], sep);
d664 1
a664 1
	result = obj_as_string(ary->ptr[0]);
d668 2
a669 2
    for (i=1; i<ary->len; i++) {
	tmp = ary->ptr[i];
d674 10
a683 1
	    tmp = ary_join(tmp, sep);
d686 1
a686 1
	    tmp = obj_as_string(tmp);
d688 3
a690 3
	if (!NIL_P(sep)) str_cat(result, sep->ptr, sep->len);
	str_cat(result, RSTRING(tmp)->ptr, RSTRING(tmp)->len);
	if (str_tainted(tmp)) str_taint(result);
d697 1
a697 1
ary_join_method(argc, argv, ary)
d700 1
a700 1
    struct RArray *ary;
d705 2
a706 4
    if (NIL_P(sep)) sep = OFS;
    if (!NIL_P(sep)) Check_Type(sep, T_STRING);

    return ary_join(ary, sep);
d710 1
a710 1
ary_to_s(ary)
d713 5
a717 2
    VALUE str = ary_join(ary, OFS);
    if (NIL_P(str)) return str_new(0, 0);
d721 25
d747 3
a749 3
ary_print_on(ary, port)
    struct RArray *ary;
    VALUE port;
d751 1
a751 1
    int i;
d753 9
a761 5
    for (i=0; i<ary->len; i++) {
	if (!NIL_P(OFS) && i>0) {
	    io_write(port, OFS);
	}
	io_write(port, ary->ptr[i]);
d763 17
a779 1
    return port;
d783 2
a784 2
ary_inspect(ary)
    struct RArray *ary;
d786 1
a786 1
    int i, len;
d789 6
a794 9
    if (ary->len == 0) return str_new2("[]");
    str = str_new2("[");
    len = 1;

    for (i=0; i<ary->len; i++) {
	s = rb_inspect(ary->ptr[i]);
	if (i > 0) str_cat(str, ", ", 2);
	str_cat(str, RSTRING(s)->ptr, RSTRING(s)->len);
	len += RSTRING(s)->len + 2;
d796 1
a796 1
    str_cat(str, "]", 1);
d802 1
a802 1
ary_to_a(ary)
d805 3
a807 1
    return ary;
d810 3
a812 3
VALUE
rb_to_a(obj)
    VALUE obj;
d814 1
a814 6
    if (TYPE(obj) == T_ARRAY) return obj;
    obj = rb_funcall(obj, rb_intern("to_a"), 0);
    if (TYPE(obj) != T_ARRAY) {
	Bug("`to_a' did not return Array");
    }
    return obj;
d818 2
a819 2
ary_reverse(ary)
    struct RArray *ary;
d824 4
a827 2
    p1 = ary->ptr;
    p2 = p1 + ary->len - 1;	/* points last item */
d836 1
a836 1
    return (VALUE)ary;
d840 2
a841 2
ary_reverse_method(ary)
    struct RArray *ary;
d843 1
a843 1
    return ary_reverse(ary_clone(ary));
d852 1
a852 1
    VALUE retval = rb_yield(assoc_new(*a, *b));
d865 2
a866 2
    else if (TYPE(*a) == T_STRING) {
	if (TYPE(*b) == T_STRING) return str_cmp(*a, *b);
d873 17
d891 2
a892 2
ary_sort_bang(ary)
    struct RArray *ary;
d894 6
a899 3
    ary_modify(ary);
    qsort(ary->ptr, ary->len, sizeof(VALUE), iterator_p()?sort_1:sort_2);
    return (VALUE)ary;
d903 1
a903 1
ary_sort(ary)
d906 2
a907 1
    return ary_sort_bang(ary_clone(ary));
d911 2
a912 2
ary_delete(ary, item)
    struct RArray *ary;
d915 1
a915 1
    int i1, i2;
d917 3
a919 3
    ary_modify(ary);
    for (i1 = i2 = 0; i1 < ary->len; i1++) {
	if (rb_equal(ary->ptr[i1], item)) continue;
d921 1
a921 1
	    ary->ptr[i2] = ary->ptr[i1];
d925 4
a928 2
    if (ary->len == i2) {
	if (iterator_p()) rb_yield(item);
d932 1
a932 1
	ary->len = i2;
d939 2
a940 2
ary_delete_at(ary, at)
    struct RArray *ary;
d943 1
a943 1
    int i1, i2, pos;
d946 3
a948 3
    ary_modify(ary);
    pos = NUM2INT(at);
    for (i1 = i2 = 0; i1 < ary->len; i1++) {
d950 1
a950 1
	    del = ary->ptr[i1];
d954 1
a954 1
	    ary->ptr[i2] = ary->ptr[i1];
d958 1
a958 1
    ary->len = i2;
d964 2
a965 2
ary_delete_if(ary)
    struct RArray *ary;
d967 1
a967 1
    int i1, i2;
d969 3
a971 3
    ary_modify(ary);
    for (i1 = i2 = 0; i1 < ary->len; i1++) {
	if (rb_yield(ary->ptr[i1])) continue;
d973 1
a973 1
	    ary->ptr[i2] = ary->ptr[i1];
d977 1
a977 1
    ary->len = i2;
d979 1
a979 1
    return (VALUE)ary;
a981 1
#if 0
d983 2
a984 2
ary_replace(ary)
    struct RArray *ary;
d986 1
a986 1
    int i;
d988 3
a990 2
    for (i = 0; i < ary->len; i++) {
	ary->ptr[i] = rb_yield(ary->ptr[i]);
d992 2
d995 7
a1001 1
    return (VALUE)ary;
a1002 1
#endif
d1005 2
a1006 2
ary_clear(ary)
    struct RArray *ary;
d1008 4
a1011 4
    ary->len = 0;
    if (ARY_DEFAULT_SIZE*3 < ary->capa) {
	ary->capa = ARY_DEFAULT_SIZE * 2;
	REALLOC_N(ary->ptr, VALUE, ary->capa);
d1013 1
a1013 1
    return (VALUE)ary;
d1017 1
a1017 1
ary_fill(argc, argv, ary)
d1020 1
a1020 1
    struct RArray *ary;
d1023 1
a1023 1
    int beg, len, end;
d1027 12
a1038 5
    if (NIL_P(arg2) && beg_len(arg1, &beg, &len, ary->len)) {
	/* beg and len set already */
    }
    else {
	beg = NUM2INT(arg1);
d1040 1
a1040 1
	    beg = ary->len + beg;
d1043 2
a1044 6
	if (arg2) {
	    len = NUM2INT(arg2);
	}
	else {
	    len = ary->len - beg;
	}
d1046 1
d1048 4
a1051 4
    if (end > ary->len) {
	if (end >= ary->capa) {
	    ary->capa=end;
	    REALLOC_N(ary->ptr, VALUE, ary->capa);
d1053 2
a1054 2
	if (beg > ary->len) {
	    memclear(ary->ptr+ary->len, end-ary->len);
d1056 1
a1056 1
	ary->len = end;
d1058 1
a1058 1
    p = ary->ptr + beg; pend = p + len;
d1063 1
a1063 1
    return (VALUE)ary;
d1067 2
a1068 2
ary_plus(x, y)
    struct RArray *x, *y;
d1070 1
a1070 1
    struct RArray *z;
d1073 1
a1073 1
	return ary_plus(x, rb_to_a(y));
d1076 5
a1080 5
    z = (struct RArray*)ary_new2(x->len + y->len);
    MEMCPY(z->ptr, x->ptr, VALUE, x->len);
    MEMCPY(z->ptr+x->len, y->ptr, VALUE, y->len);
    z->len = x->len + RARRAY(y)->len;
    return (VALUE)z;
d1084 2
a1085 2
ary_concat(x, y)
    struct RArray *x, *y;
d1090 1
a1090 1
	return ary_concat(x, rb_to_a(y));
d1093 2
a1094 2
    p = y->ptr;
    pend = p + y->len;
d1096 1
a1096 1
	ary_store(x, x->len, *p);
d1099 1
a1099 1
    return (VALUE)x;
d1103 2
a1104 2
ary_times(ary, times)
    struct RArray *ary;
d1107 2
a1108 2
    struct RArray *ary2;
    int i, len;
d1111 1
a1111 1
	return ary_join(ary, times);
d1114 1
a1114 4
    len = NUM2INT(times) * ary->len;
    ary2 = (struct RArray*)ary_new2(len);
    ary2->len = len;

d1116 1
a1116 1
	ArgError("negative argument");
d1118 1
d1120 5
a1124 2
    for (i=0; i<len; i+=ary->len) {
	MEMCPY(ary2->ptr+i, ary->ptr, VALUE, ary->len);
d1127 1
a1127 1
    return (VALUE)ary2;
d1131 2
a1132 2
ary_assoc(ary, key)
    struct RArray *ary;
d1137 1
a1137 1
    p = ary->ptr; pend = p + ary->len;
d1149 2
a1150 2
ary_rassoc(ary, value)
    struct RArray *ary;
d1155 1
a1155 1
    p = ary->ptr; pend = p + ary->len;
d1167 2
a1168 2
ary_equal(ary1, ary2)
    struct RArray *ary1, *ary2;
d1170 1
a1170 1
    int i;
d1172 5
a1176 5
    if (TYPE(ary2) != T_ARRAY) return FALSE;
    if (ary1->len != ary2->len) return FALSE;
    for (i=0; i<ary1->len; i++) {
	if (!rb_equal(ary1->ptr[i], ary2->ptr[i]))
	    return FALSE;
d1178 1
a1178 1
    return TRUE;
d1182 2
a1183 2
ary_eql(ary1, ary2)
    struct RArray *ary1, *ary2;
d1185 1
a1185 1
    int i;
d1187 6
a1192 5
    if (TYPE(ary2) != T_ARRAY) return FALSE;
    if (ary1->len != ary2->len) return FALSE;
    for (i=0; i<ary1->len; i++) {
	if (!rb_eql(ary1->ptr[i], ary2->ptr[i]))
	    return FALSE;
d1194 1
a1194 1
    return TRUE;
d1198 2
a1199 2
ary_hash(ary)
    struct RArray *ary;
d1201 2
a1202 1
    int h, i;
d1204 4
a1207 3
    h = ary->len;
    for (i=0; i<ary->len; i++) {
	h ^= rb_hash(ary->ptr[i]);
d1213 2
a1214 2
ary_includes(ary, item)
    struct RArray *ary;
d1217 25
a1241 4
    int i;
    for (i=0; i<ary->len; i++) {
	if (rb_equal(ary->ptr[i], item)) {
	    return TRUE;
d1244 4
a1247 1
    return FALSE;
d1251 2
a1252 2
ary_diff(ary1, ary2)
    struct RArray *ary1, *ary2;
d1255 1
a1255 1
    int i;
d1257 6
a1262 6
    Check_Type(ary2, T_ARRAY);
    ary3 = ary_new();
    for (i=0; i<ary1->len; i++) {
	if (ary_includes(ary2, ary1->ptr[i])) continue;
	if (ary_includes(ary3, ary1->ptr[i])) continue;
	ary_push(ary3, ary1->ptr[i]);
d1268 2
a1269 2
ary_and(ary1, ary2)
    struct RArray *ary1, *ary2;
d1272 1
a1272 1
    int i;
d1274 6
a1279 6
    Check_Type(ary2, T_ARRAY);
    ary3 = ary_new();
    for (i=0; i<ary1->len; i++) {
	if (ary_includes(ary2, ary1->ptr[i])
	    && !ary_includes(ary3, ary1->ptr[i])) {
	    ary_push(ary3, ary1->ptr[i]);
d1286 2
a1287 2
ary_or(ary1, ary2)
    struct RArray *ary1, *ary2;
d1290 1
a1290 1
    int i;
d1293 2
a1294 2
	if (ary_includes(ary1, ary2)) return (VALUE)ary1;
	else return ary_plus(ary1, ary2);
d1297 8
a1304 8
    ary3 = ary_new();
    for (i=0; i<ary1->len; i++) {
	if (!ary_includes(ary3, ary1->ptr[i]))
		ary_push(ary3, ary1->ptr[i]);
    }
    for (i=0; i<ary2->len; i++) {
	if (!ary_includes(ary3, ary2->ptr[i]))
		ary_push(ary3, ary2->ptr[i]);
d1310 41
a1350 2
ary_compact_bang(ary)
    struct RArray *ary;
d1354 3
a1356 3
    ary_modify(ary);
    p = t = ary->ptr;
    end = p + ary->len;
d1361 5
a1365 2
    ary->len = ary->capa = (p - ary->ptr);
    REALLOC_N(ary->ptr, VALUE, ary->len);
d1367 1
a1367 1
    return (VALUE)ary;
d1371 2
a1372 2
ary_compact(ary)
    struct RArray *ary;
d1374 4
a1377 1
    return ary_compact_bang(ary_clone(ary));
d1381 2
a1382 2
ary_nitems(ary)
    struct RArray *ary;
d1384 1
a1384 1
    int n = 0;
d1387 2
a1388 2
    p = ary->ptr;
    pend = p + ary->len;
d1393 1
a1393 1
    return INT2FIX(n);
d1396 28
a1423 1
extern VALUE mEnumerable;
d1428 2
a1429 2
    cArray  = rb_define_class("Array", cObject);
    rb_include_module(cArray, mEnumerable);
d1431 68
a1498 58
    rb_define_singleton_method(cArray, "new", ary_s_new, -1);
    rb_define_singleton_method(cArray, "[]", ary_s_create, -1);
    rb_define_method(cArray, "to_s", ary_to_s, 0);
    rb_define_method(cArray, "inspect", ary_inspect, 0);
    rb_define_method(cArray, "to_a", ary_to_a, 0);

    rb_define_method(cArray, "freeze",  ary_freeze, 0);
    rb_define_method(cArray, "frozen?",  ary_frozen_p, 0);

    rb_define_method(cArray, "==", ary_equal, 1);
    rb_define_method(cArray, "eql?", ary_eql, 1);
    rb_define_method(cArray, "hash", ary_hash, 0);

    rb_define_method(cArray, "[]", ary_aref, -1);
    rb_define_method(cArray, "[]=", ary_aset, -1);
    rb_define_method(cArray, "concat", ary_concat, 1);
    rb_define_method(cArray, "<<", ary_push, 1);
    rb_define_method(cArray, "push", ary_push_method, -1);
    rb_define_method(cArray, "pop", ary_pop, 0);
    rb_define_method(cArray, "shift", ary_shift, 0);
    rb_define_method(cArray, "unshift", ary_unshift, 1);
    rb_define_method(cArray, "each", ary_each, 0);
    rb_define_method(cArray, "each_index", ary_each_index, 0);
    rb_define_method(cArray, "reverse_each", ary_reverse_each, 0);
    rb_define_method(cArray, "length", ary_length, 0);
    rb_define_alias(cArray,  "size", "length");
    rb_define_method(cArray, "empty?", ary_empty_p, 0);
    rb_define_method(cArray, "index", ary_index, 1);
    rb_define_method(cArray, "indexes", ary_indexes, -2);
    rb_define_method(cArray, "clone", ary_clone, 0);
    rb_define_method(cArray, "join", ary_join_method, -1);
    rb_define_method(cArray, "reverse", ary_reverse_method, 0);
    rb_define_method(cArray, "reverse!", ary_reverse, 0);
    rb_define_method(cArray, "sort", ary_sort, 0);
    rb_define_method(cArray, "sort!", ary_sort_bang, 0);
    rb_define_method(cArray, "delete", ary_delete, 1);
    rb_define_method(cArray, "delete_at", ary_delete_at, 1);
    rb_define_method(cArray, "delete_if", ary_delete_if, 0);
#if 0
    rb_define_method(cArray, "replace", ary_replace, 0);
#endif
    rb_define_method(cArray, "clear", ary_clear, 0);
    rb_define_method(cArray, "fill", ary_fill, -1);
    rb_define_method(cArray, "include?", ary_includes, 1);

    rb_define_method(cArray, "assoc", ary_assoc, 1);
    rb_define_method(cArray, "rassoc", ary_rassoc, 1);

    rb_define_method(cArray, "+", ary_plus, 1);
    rb_define_method(cArray, "*", ary_times, 1);

    rb_define_method(cArray, "-", ary_diff, 1);
    rb_define_method(cArray, "&", ary_and, 1);
    rb_define_method(cArray, "|", ary_or, 1);

    rb_define_method(cArray, "compact", ary_compact, 0);
    rb_define_method(cArray, "compact!", ary_compact_bang, 0);
    rb_define_method(cArray, "nitems", ary_nitems, 0);
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d15 1
d17 1
a17 1
VALUE cArray;
d93 1
a93 1
    VALUE ary;
d99 1
a99 1
    ary = ary_new2(n<ARY_DEFAULT_SIZE?ARY_DEFAULT_SIZE:n);
d103 1
a103 1
	RARRAY(ary)->ptr[i] = va_arg(ar, VALUE);
d107 2
a108 2
    RARRAY(ary)->len = n;
    return ary;
d116 1
a116 1
    VALUE ary;
d118 3
a120 3
    ary = ary_new2(n);
    MEMCPY(RARRAY(ary)->ptr, elts, VALUE, n);
    RARRAY(ary)->len = n;
d122 1
a122 1
    return ary;
d129 1
a129 1
    VALUE ary;
d131 4
a134 4
    ary = ary_new2(2);
    RARRAY(ary)->ptr[0] = car;
    RARRAY(ary)->ptr[1] = cdr;
    RARRAY(ary)->len = 2;
d136 1
a136 1
    return ary;
d182 1
a182 1
    VALUE ary;
d191 3
a193 3
    if (idx >= RARRAY(ary)->capa) {
	RARRAY(ary)->capa = idx + ARY_DEFAULT_SIZE;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d195 2
a196 2
    if (idx > RARRAY(ary)->len) {
	memclear(RARRAY(ary)->ptr+RARRAY(ary)->len, idx-RARRAY(ary)->len+1);
d199 2
a200 2
    if (idx >= RARRAY(ary)->len) {
	RARRAY(ary)->len = idx + 1;
d202 1
a202 1
    RARRAY(ary)->ptr[idx] = val;
d207 1
a207 1
    VALUE ary;
d210 2
a211 2
    ary_store(ary, RARRAY(ary)->len, item);
    return ary;
d218 1
a218 1
    VALUE ary;
d221 1
a221 1
	ary_store(ary, RARRAY(ary)->len, *argv++);
d223 1
a223 1
    return ary;
d228 1
a228 1
    VALUE ary;
d230 4
a233 4
    if (RARRAY(ary)->len == 0) return Qnil;
    if (RARRAY(ary)->len * 10 < RARRAY(ary)->capa && RARRAY(ary)->capa > ARY_DEFAULT_SIZE) {
	RARRAY(ary)->capa = RARRAY(ary)->len * 2;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d235 1
a235 1
    return RARRAY(ary)->ptr[--RARRAY(ary)->len];
d240 1
a240 1
    VALUE ary;
d244 1
a244 1
    if (RARRAY(ary)->len == 0) return Qnil;
d246 2
a247 2
    top = RARRAY(ary)->ptr[0];
    RARRAY(ary)->len--;
d250 4
a253 4
    MEMMOVE(RARRAY(ary)->ptr, RARRAY(ary)->ptr+1, VALUE, RARRAY(ary)->len);
    if (RARRAY(ary)->len * 10 < RARRAY(ary)->capa && RARRAY(ary)->capa > ARY_DEFAULT_SIZE) {
	RARRAY(ary)->capa = RARRAY(ary)->len * 2;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d261 2
a262 1
    VALUE ary, item;
d265 3
a267 3
    if (RARRAY(ary)->len >= RARRAY(ary)->capa) {
	RARRAY(ary)->capa+=ARY_DEFAULT_SIZE;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d271 1
a271 1
    MEMMOVE(RARRAY(ary)->ptr+1, RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);
d273 2
a274 2
    RARRAY(ary)->len++;
    return RARRAY(ary)->ptr[0] = item;
d279 1
a279 1
    VALUE ary;
d282 1
a282 1
    if (RARRAY(ary)->len == 0) return Qnil;
d285 1
a285 1
	offset = RARRAY(ary)->len + offset;
d287 1
a287 1
    if (offset < 0 || RARRAY(ary)->len <= offset) {
d291 1
a291 1
    return RARRAY(ary)->ptr[offset];
d296 1
a296 1
    VALUE ary;
d299 1
a299 1
    VALUE ary2;
d302 1
a302 1
	beg = RARRAY(ary)->len + beg;
d306 1
a306 1
	IndexError("negative length %d", RARRAY(ary)->len);
d311 2
a312 2
    if (beg + len > RARRAY(ary)->len) {
	len = RARRAY(ary)->len - beg;
d315 3
a317 3
    ary2 = ary_new2(len);
    MEMCPY(RARRAY(ary2)->ptr, RARRAY(ary)->ptr+beg, VALUE, len);
    RARRAY(ary2)->len = len;
d319 1
a319 1
    return ary2;
d349 1
d360 1
a360 1
VALUE
d364 1
a364 1
    VALUE ary;
d384 1
a384 1
	if (beg_len(arg1, &beg, &len, RARRAY(ary)->len)) {
d396 1
a396 1
    VALUE ary;
d401 2
a402 2
    for (i=0; i<RARRAY(ary)->len; i++) {
	if (rb_equal(RARRAY(ary)->ptr[i], val))
d410 1
a410 1
    VALUE ary, args;
d420 1
a420 1
    new_ary = ary_new2(RARRAY(args)->len);
d422 1
a422 1
    p = RARRAY(args)->ptr; pend = p + RARRAY(args)->len;
d432 1
a432 1
    VALUE ary, rpl;
d437 1
a437 1
	rpl = rb_Array(rpl);
d440 1
a440 1
	beg = RARRAY(ary)->len + beg;
d443 9
a451 9
    if (beg >= RARRAY(ary)->len) {
	len = beg + RARRAY(rpl)->len;
	if (len >= RARRAY(ary)->capa) {
	    RARRAY(ary)->capa=len;
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
	}
	memclear(RARRAY(ary)->ptr+RARRAY(ary)->len, beg-RARRAY(ary)->len);
	MEMCPY(RARRAY(ary)->ptr+beg, RARRAY(rpl)->ptr, VALUE, RARRAY(rpl)->len);
	RARRAY(ary)->len = len;
d456 2
a457 2
	if (beg + len > RARRAY(ary)->len) {
	    len = RARRAY(ary)->len - beg;
d460 1
a460 1
	    IndexError("negative length %d", RARRAY(ary)->len);
d463 4
a466 4
	alen = RARRAY(ary)->len + RARRAY(rpl)->len - len;
	if (alen >= RARRAY(ary)->capa) {
	    RARRAY(ary)->capa=alen;
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d470 3
a472 3
	    MEMMOVE(RARRAY(ary)->ptr+beg+RARRAY(rpl)->len, RARRAY(ary)->ptr+beg+len,
		    VALUE, RARRAY(ary)->len-(beg+len));
	    RARRAY(ary)->len = alen;
d474 1
a474 1
	MEMCPY(RARRAY(ary)->ptr+beg, RARRAY(rpl)->ptr, VALUE, RARRAY(rpl)->len);
d482 1
a482 1
    VALUE ary;
d484 2
a485 1
    VALUE arg1, arg2, arg3;
d493 1
a493 1
	return arg3;
d499 1
a499 1
    else if (beg_len(arg1, &beg, &len, RARRAY(ary)->len)) {
d511 1
a511 1
	offset = RARRAY(ary)->len + offset;
d519 1
a519 1
    VALUE ary;
d523 2
a524 2
    for (i=0; i<RARRAY(ary)->len; i++) {
	rb_yield(RARRAY(ary)->ptr[i]);
d531 1
a531 1
    VALUE ary;
d535 1
a535 1
    for (i=0; i<RARRAY(ary)->len; i++) {
d543 1
a543 1
    VALUE ary;
d545 1
a545 1
    int len = RARRAY(ary)->len;
d548 1
a548 1
	rb_yield(RARRAY(ary)->ptr[len]);
d555 1
a555 1
    VALUE ary;
d557 1
a557 1
    return INT2FIX(RARRAY(ary)->len);
d562 1
a562 1
    VALUE ary;
d564 1
a564 1
    if (RARRAY(ary)->len == 0)
d571 1
a571 1
    VALUE ary;
d573 1
a573 1
    VALUE ary2 = ary_new2(RARRAY(ary)->len);
d576 2
a577 2
    MEMCPY(RARRAY(ary2)->ptr, RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);
    RARRAY(ary2)->len = RARRAY(ary)->len;
a580 7
static VALUE
ary_dup(ary)
    VALUE ary;
{
    return ary_new4(RARRAY(ary)->len, RARRAY(ary)->ptr);
}

d585 2
a586 2
    VALUE ary;
    VALUE sep;
d590 1
a590 1
    if (RARRAY(ary)->len == 0) return str_new(0, 0);
d592 1
a592 1
    switch (TYPE(RARRAY(ary)->ptr[0])) {
d594 1
a594 1
	result = str_dup(RARRAY(ary)->ptr[0]);
d597 1
a597 1
	result = ary_join(RARRAY(ary)->ptr[0], sep);
d600 1
a600 1
	result = obj_as_string(RARRAY(ary)->ptr[0]);
d604 2
a605 2
    for (i=1; i<RARRAY(ary)->len; i++) {
	tmp = RARRAY(ary)->ptr[i];
d615 1
a615 1
	if (!NIL_P(sep)) str_cat(result, RSTRING(sep)->ptr, RSTRING(sep)->len);
d627 1
a627 1
    VALUE ary;
d647 16
d665 1
a665 1
    VALUE ary;
d670 1
a670 1
    if (RARRAY(ary)->len == 0) return str_new2("[]");
d674 2
a675 2
    for (i=0; i<RARRAY(ary)->len; i++) {
	s = rb_inspect(RARRAY(ary)->ptr[i]);
d693 12
d706 1
a706 1
    VALUE ary;
d711 2
a712 2
    p1 = RARRAY(ary)->ptr;
    p2 = p1 + RARRAY(ary)->len - 1;	/* points last item */
d721 1
a721 1
    return ary;
d726 1
a726 1
    VALUE ary;
d760 1
a760 1
    VALUE ary;
d763 2
a764 2
    qsort(RARRAY(ary)->ptr, RARRAY(ary)->len, sizeof(VALUE), iterator_p()?sort_1:sort_2);
    return ary;
d776 1
a776 1
    VALUE ary;
d782 2
a783 2
    for (i1 = i2 = 0; i1 < RARRAY(ary)->len; i1++) {
	if (rb_equal(RARRAY(ary)->ptr[i1], item)) continue;
d785 1
a785 1
	    RARRAY(ary)->ptr[i2] = RARRAY(ary)->ptr[i1];
d789 1
a789 1
    if (RARRAY(ary)->len == i2) {
d794 1
a794 1
	RARRAY(ary)->len = i2;
d802 1
a802 1
    VALUE ary;
d810 1
a810 1
    for (i1 = i2 = 0; i1 < RARRAY(ary)->len; i1++) {
d812 1
a812 1
	    del = RARRAY(ary)->ptr[i1];
d816 1
a816 1
	    RARRAY(ary)->ptr[i2] = RARRAY(ary)->ptr[i1];
d820 1
a820 1
    RARRAY(ary)->len = i2;
d827 1
a827 1
    VALUE ary;
d832 2
a833 2
    for (i1 = i2 = 0; i1 < RARRAY(ary)->len; i1++) {
	if (rb_yield(RARRAY(ary)->ptr[i1])) continue;
d835 1
a835 1
	    RARRAY(ary)->ptr[i2] = RARRAY(ary)->ptr[i1];
d839 1
a839 1
    RARRAY(ary)->len = i2;
d841 1
a841 1
    return ary;
d847 1
a847 1
    VALUE ary;
d851 2
a852 2
    for (i = 0; i < RARRAY(ary)->len; i++) {
	RARRAY(ary)->ptr[i] = rb_yield(RARRAY(ary)->ptr[i]);
d855 1
a855 1
    return ary;
d861 1
a861 1
    VALUE ary;
d863 4
a866 4
    RARRAY(ary)->len = 0;
    if (ARY_DEFAULT_SIZE*3 < RARRAY(ary)->capa) {
	RARRAY(ary)->capa = ARY_DEFAULT_SIZE * 2;
	REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d868 1
a868 1
    return ary;
d875 1
a875 1
    VALUE ary;
d882 1
a882 1
    if (NIL_P(arg2) && beg_len(arg1, &beg, &len, RARRAY(ary)->len)) {
d888 1
a888 1
	    beg = RARRAY(ary)->len + beg;
d891 1
a891 1
	if (!NIL_P(arg2)) {
d895 1
a895 1
	    len = RARRAY(ary)->len - beg;
d899 4
a902 4
    if (end > RARRAY(ary)->len) {
	if (end >= RARRAY(ary)->capa) {
	    RARRAY(ary)->capa=end;
	    REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->capa);
d904 2
a905 2
	if (beg > RARRAY(ary)->len) {
	    memclear(RARRAY(ary)->ptr+RARRAY(ary)->len, end-RARRAY(ary)->len);
d907 1
a907 1
	RARRAY(ary)->len = end;
d909 1
a909 1
    p = RARRAY(ary)->ptr + beg; pend = p + len;
d914 1
a914 1
    return ary;
d919 1
a919 1
    VALUE x, y;
d921 1
a921 1
    VALUE z;
d924 1
a924 1
	return ary_plus(x, rb_Array(y));
d927 5
a931 5
    z = ary_new2(RARRAY(x)->len + RARRAY(y)->len);
    MEMCPY(RARRAY(z)->ptr, RARRAY(x)->ptr, VALUE, RARRAY(x)->len);
    MEMCPY(RARRAY(z)->ptr+RARRAY(x)->len, RARRAY(y)->ptr, VALUE, RARRAY(y)->len);
    RARRAY(z)->len = RARRAY(x)->len + RARRAY(y)->len;
    return z;
d936 1
a936 1
    VALUE x, y;
d941 1
a941 1
	return ary_concat(x, rb_Array(y));
d944 2
a945 2
    p = RARRAY(y)->ptr;
    pend = p + RARRAY(y)->len;
d947 1
a947 1
	ary_store(x, RARRAY(x)->len, *p);
d950 1
a950 1
    return x;
d955 1
a955 1
    VALUE ary;
d958 1
a958 1
    VALUE ary2;
d965 3
a967 3
    len = NUM2INT(times) * RARRAY(ary)->len;
    ary2 = ary_new2(len);
    RARRAY(ary2)->len = len;
d973 2
a974 2
    for (i=0; i<len; i+=RARRAY(ary)->len) {
	MEMCPY(RARRAY(ary2)->ptr+i, RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);
d977 1
a977 1
    return ary2;
d982 1
a982 1
    VALUE ary;
d987 1
a987 1
    p = RARRAY(ary)->ptr; pend = p + RARRAY(ary)->len;
d1000 1
a1000 1
    VALUE ary;
d1005 1
a1005 1
    p = RARRAY(ary)->ptr; pend = p + RARRAY(ary)->len;
d1018 1
a1018 1
    VALUE ary1, ary2;
d1023 3
a1025 3
    if (RARRAY(ary1)->len != RARRAY(ary2)->len) return FALSE;
    for (i=0; i<RARRAY(ary1)->len; i++) {
	if (!rb_equal(RARRAY(ary1)->ptr[i], RARRAY(ary2)->ptr[i]))
d1033 1
a1033 1
    VALUE ary1, ary2;
d1038 3
a1040 4
    if (RARRAY(ary1)->len != RARRAY(ary2)->len)
	return FALSE;
    for (i=0; i<RARRAY(ary1)->len; i++) {
	if (!rb_eql(RARRAY(ary1)->ptr[i], RARRAY(ary2)->ptr[i]))
d1048 1
a1048 1
    VALUE ary;
d1052 3
a1054 3
    h = RARRAY(ary)->len;
    for (i=0; i<RARRAY(ary)->len; i++) {
	h ^= rb_hash(RARRAY(ary)->ptr[i]);
d1061 1
a1061 1
    VALUE ary;
d1065 2
a1066 2
    for (i=0; i<RARRAY(ary)->len; i++) {
	if (rb_equal(RARRAY(ary)->ptr[i], item)) {
d1075 1
a1075 1
    VALUE ary1, ary2;
d1082 4
a1085 4
    for (i=0; i<RARRAY(ary1)->len; i++) {
	if (ary_includes(ary2, RARRAY(ary1)->ptr[i])) continue;
	if (ary_includes(ary3, RARRAY(ary1)->ptr[i])) continue;
	ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1092 1
a1092 1
    VALUE ary1, ary2;
d1099 4
a1102 4
    for (i=0; i<RARRAY(ary1)->len; i++) {
	if (ary_includes(ary2, RARRAY(ary1)->ptr[i])
	    && !ary_includes(ary3, RARRAY(ary1)->ptr[i])) {
	    ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1110 1
a1110 1
    VALUE ary1, ary2;
d1116 1
a1116 1
	if (ary_includes(ary1, ary2)) return ary1;
d1121 7
a1127 7
    for (i=0; i<RARRAY(ary1)->len; i++) {
	if (!ary_includes(ary3, RARRAY(ary1)->ptr[i]))
		ary_push(ary3, RARRAY(ary1)->ptr[i]);
    }
    for (i=0; i<RARRAY(ary2)->len; i++) {
	if (!ary_includes(ary3, RARRAY(ary2)->ptr[i]))
		ary_push(ary3, RARRAY(ary2)->ptr[i]);
d1134 1
a1134 1
    VALUE ary;
d1139 2
a1140 2
    p = t = RARRAY(ary)->ptr;
    end = p + RARRAY(ary)->len;
d1145 2
a1146 2
    RARRAY(ary)->len = RARRAY(ary)->capa = (p - RARRAY(ary)->ptr);
    REALLOC_N(RARRAY(ary)->ptr, VALUE, RARRAY(ary)->len);
d1148 1
a1148 1
    return ary;
d1153 1
a1153 1
    VALUE ary;
d1160 1
a1160 1
    VALUE ary;
d1165 2
a1166 2
    p = RARRAY(ary)->ptr;
    pend = p + RARRAY(ary)->len;
a1211 1
    rb_define_method(cArray, "dup", ary_dup, 0);
a1225 1
    rb_define_method(cArray, "===", ary_includes, 1);
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/11/25 03:31:09 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
a13 1
#include "util.h"
d15 2
a16 1
VALUE rb_cArray;
d21 1
a21 1
rb_mem_clear(mem, size)
d23 1
a23 1
    register size_t size;
a29 11
static void
memfill(mem, size, val)
    register VALUE *mem;
    register size_t size;
    register VALUE val;
{
    while (size--) {
	*mem++ = val;
    }
}

a30 1
#define ARY_TMPLOCK  FL_USER2
d33 1
a33 1
rb_ary_modify(ary)
d36 4
a39 6
    if (FL_TEST(ary, ARY_FREEZE))
	rb_raise(rb_eTypeError, "can't modify frozen array");
    if (FL_TEST(ary, ARY_TMPLOCK))
	rb_raise(rb_eTypeError, "can't modify array during sort");
    if (rb_safe_level() >= 4 && !FL_TEST(ary, FL_TAINT))
	rb_raise(rb_eSecurityError, "Insecure: can't modify array");
d43 1
a43 1
rb_ary_freeze(ary)
d51 1
a51 1
rb_ary_frozen_p(ary)
d54 3
a56 3
    if (FL_TEST(ary, ARY_FREEZE|ARY_TMPLOCK))
	return Qtrue;
    return Qfalse;
d60 2
a61 2
rb_ary_new2(len)
    size_t len;
d64 1
a64 1
    OBJSETUP(ary, rb_cArray, T_ARRAY);
a65 6
    if (len < 0) {
	rb_raise(rb_eArgError, "negative array size (or size too big)");
    }
    if (len > 0 && len*sizeof(VALUE) <= 0) {
	rb_raise(rb_eArgError, "array size too big");
    }
d68 6
a73 2
    ary->ptr = 0;
    ary->ptr = ALLOC_N(VALUE, len);
d79 1
a79 1
rb_ary_new()
d81 1
a81 1
    return rb_ary_new2(ARY_DEFAULT_SIZE);
a83 4
#ifdef HAVE_STDARG_PROTOTYPES
#include <stdarg.h>
#define va_init_list(a,b) va_start(a,b)
#else
a84 2
#define va_init_list(a,b) va_start(a)
#endif
d87 2
a88 5
#ifdef HAVE_STDARG_PROTOTYPES
rb_ary_new3(size_t n, ...)
#else
rb_ary_new3(n, va_alist)
    size_t n;
a89 1
#endif
d93 1
a93 1
    size_t i;
d96 1
a96 1
	rb_raise(rb_eIndexError, "negative number of items(%d)", n);
d98 1
a98 1
    ary = rb_ary_new2(n<ARY_DEFAULT_SIZE?ARY_DEFAULT_SIZE:n);
d100 1
a100 1
    va_init_list(ar, n);
d111 2
a112 2
rb_ary_new4(n, elts)
    size_t n;
d117 2
a118 4
    ary = rb_ary_new2(n);
    if (elts) {
	MEMCPY(RARRAY(ary)->ptr, elts, VALUE, n);
    }
d125 1
a125 1
rb_assoc_new(car, cdr)
d130 1
a130 1
    ary = rb_ary_new2(2);
d139 1
a139 1
rb_ary_s_new(argc, argv, klass)
d142 1
a142 1
    VALUE klass;
d144 1
a144 2
    size_t len = 0;
    VALUE size, val;
d146 1
a146 1
    OBJSETUP(ary, klass, T_ARRAY);
d148 1
d150 1
a150 16
    ary->ptr = 0;
    if (rb_scan_args(argc, argv, "02", &size, &val) == 0) {
	ary->capa = ARY_DEFAULT_SIZE;
    }
    else {
	size_t capa = NUM2UINT(size);

	if (capa < 0) {
	    rb_raise(rb_eArgError, "negative array size");
	}
	if (capa > 0 && capa*sizeof(VALUE) <= 0) {
	    rb_raise(rb_eArgError, "array size too big");
	}
	ary->capa = capa;
	len = capa;
    }
d152 1
a152 3
    memfill(ary->ptr, len, val);
    ary->len = len;
    rb_obj_call_init((VALUE)ary);
d158 1
a158 1
rb_ary_s_create(argc, argv, klass)
d161 1
a161 1
    VALUE klass;
d164 1
a164 1
    OBJSETUP(ary, klass, T_ARRAY);
d180 1
a180 1
rb_ary_store(ary, idx, val)
d182 1
a182 1
    size_t idx;
d185 1
a185 1
    rb_ary_modify(ary);
d187 1
a187 4
	idx = RARRAY(ary)->len + idx;
	if (idx < 0) {
	    rb_raise(rb_eIndexError, "negative index of array");
	}
d195 1
a195 2
	rb_mem_clear(RARRAY(ary)->ptr+RARRAY(ary)->len,
		     idx-RARRAY(ary)->len+1);
d205 1
a205 1
rb_ary_push(ary, item)
d209 1
a209 1
    rb_ary_store(ary, RARRAY(ary)->len, item);
d214 1
a214 1
rb_ary_push_method(argc, argv, ary)
d220 1
a220 1
	rb_ary_store(ary, RARRAY(ary)->len, *argv++);
d226 1
a226 1
rb_ary_pop(ary)
d238 1
a238 1
rb_ary_shift(ary)
d259 1
a259 1
rb_ary_unshift(ary, item)
d262 1
a262 1
    rb_ary_modify(ary);
d272 1
a272 3
    RARRAY(ary)->ptr[0] = item;

    return ary;
d276 1
a276 1
rb_ary_entry(ary, offset)
d278 1
a278 1
    size_t offset;
d293 1
a293 1
rb_ary_subseq(ary, beg, len)
d295 1
a295 1
    size_t beg, len;
d299 3
a301 2
    if (len <= 0) {
	return rb_ary_new2(0);
d303 5
a307 3
    if (beg < 0) {
	len += beg;
	beg = 0;
a311 3
    if (len < 0) {
	len = 0;
    }
d313 1
a313 1
    ary2 = rb_ary_new2(len);
d323 2
a324 2
    size_t *begp, *lenp;
    size_t len;
d326 3
a328 2
    size_t beg, end;
    size_t b, e;
d330 3
a332 2
    if (!rb_range_beg_end(range, &beg, &end)) return Qfalse;
    b = beg; e = end;
d336 1
a337 7
    if (end < 0) {
	end = len + end;
    }
    if (beg > end) {
	rb_raise(rb_eIndexError, "end smaller than beg [%d..%d]", b, e);
    }

d343 10
a352 2
	len = end - beg +1;
	*lenp = len;
d354 1
a354 1
    return Qtrue;
d358 1
a358 1
rb_ary_aref(argc, argv, ary)
d364 1
a364 1
    size_t beg, len;
d367 4
a370 4
	beg = NUM2UINT(arg1);
	len = NUM2UINT(arg2);
	if (beg < 0) {
	    beg = RARRAY(ary)->len + beg;
d372 1
a372 1
	return rb_ary_subseq(ary, beg, len);
d377 1
a377 1
	return rb_ary_entry(ary, FIX2UINT(arg1));
d379 5
a383 2
    else if (TYPE(arg1) == T_BIGNUM) {
	rb_raise(rb_eIndexError, "index too big");
d385 2
a386 3
    else if (beg_len(arg1, &beg, &len, RARRAY(ary)->len)) {
	/* check if idx is Range */
	return rb_ary_subseq(ary, beg, len);
d388 1
a388 1
    return rb_ary_entry(ary, NUM2UINT(arg1));
d392 1
a392 1
rb_ary_index(ary, val)
d396 1
a396 1
    size_t i;
d406 2
a407 3
rb_ary_rindex(ary, val)
    VALUE ary;
    VALUE val;
d409 3
a411 1
    size_t i = RARRAY(ary)->len;
d413 2
a414 3
    while (i--) {
	if (rb_equal(RARRAY(ary)->ptr[i], val))
	    return INT2FIX(i);
a415 2
    return Qnil;
}
d417 1
a417 8
static VALUE
rb_ary_indexes(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE new_ary;
    size_t i;
d419 4
a422 3
    new_ary = rb_ary_new2(argc);
    for (i=0; i<argc; i++) {
	rb_ary_store(new_ary, i, rb_ary_entry(ary, NUM2UINT(argv[i])));
a423 1

d428 1
a428 1
rb_ary_replace(ary, beg, len, rpl)
d430 1
a430 1
    size_t beg, len;
d432 1
a432 4
    if (len < 0) {
	rb_raise(rb_eIndexError, "negative length %d", len);
    }

a435 4

    if (beg + len < 0 || (beg < 0 && beg <= -len)) {
	rb_raise(rb_eIndexError, "index %d out of range", beg);
    }
d437 2
a438 2
	len += beg;
	beg = 0;
a439 2

    rb_ary_modify(ary);
d446 1
a446 1
	rb_mem_clear(RARRAY(ary)->ptr+RARRAY(ary)->len, beg-RARRAY(ary)->len);
d451 1
a451 1
	size_t alen;
d456 3
d476 1
a476 1
rb_ary_aset(argc, argv, ary)
d482 2
a483 2
    size_t offset;
    size_t beg, len;
d486 3
a488 7
	beg = NUM2UINT(arg1);
	len = NUM2UINT(arg2);

	if (beg < 0) {
	    beg = RARRAY(ary)->len + beg;
	}
	rb_ary_replace(ary, beg, len, arg3);
d492 1
a492 1
	offset = FIX2UINT(arg1);
d497 1
a497 1
	rb_ary_replace(ary, beg, len, arg2);
d501 1
a501 1
	rb_raise(rb_eIndexError, "index too big");
d504 1
a504 1
    offset = NUM2UINT(arg1);
d506 4
a509 1
    rb_ary_store(ary, offset, arg2);
d514 1
a514 1
rb_ary_each(ary)
d517 1
a517 1
    size_t i;
d526 1
a526 1
rb_ary_each_index(ary)
d529 1
a529 1
    size_t i;
d538 1
a538 1
rb_ary_reverse_each(ary)
d541 1
a541 1
    size_t len = RARRAY(ary)->len;
d550 1
a550 1
rb_ary_length(ary)
d557 1
a557 1
rb_ary_empty_p(ary)
d561 2
a562 2
	return Qtrue;
    return Qfalse;
d566 1
a566 1
rb_ary_clone(ary)
d569 1
a569 1
    VALUE ary2 = rb_ary_new2(RARRAY(ary)->len);
d578 1
a578 1
rb_ary_dup(ary)
d581 1
a581 1
    return rb_ary_new4(RARRAY(ary)->len, RARRAY(ary)->ptr);
d584 1
a584 6
static VALUE
to_ary(ary)
    VALUE ary;
{
    return rb_convert_type(ary, T_ARRAY, "Array", "to_ary");
}
d586 2
a587 4
extern VALUE rb_output_fs;

static VALUE
inspect_join(ary, arg)
d589 1
a589 8
    VALUE *arg;
{
    return rb_ary_join(arg[0], arg[1]);
}

VALUE
rb_ary_join(ary, sep)
    VALUE ary, sep;
d591 1
a591 1
    size_t i;
d593 1
a593 1
    if (RARRAY(ary)->len == 0) return rb_str_new(0, 0);
d595 1
a595 2
    tmp = RARRAY(ary)->ptr[0];
    switch (TYPE(tmp)) {
d597 1
a597 1
	result = rb_str_dup(tmp);
d600 1
a600 10
	if (rb_inspecting_p(tmp)) {
	    result = rb_str_new2("[...]");
	}
	else {
	    VALUE args[2];

	    args[0] = tmp;
	    args[1] = sep;
	    result = rb_protect_inspect(inspect_join, ary, (VALUE)args);
	}
d603 1
a603 1
	result = rb_obj_as_string(tmp);
d613 1
a613 10
	    if (rb_inspecting_p(tmp)) {
		tmp = rb_str_new2("[...]");
	    }
	    else {
		VALUE args[2];

		args[0] = tmp;
		args[1] = sep;
		tmp = rb_protect_inspect(inspect_join, ary, (VALUE)args);
	    }
d616 1
a616 1
	    tmp = rb_obj_as_string(tmp);
d618 3
a620 3
	if (!NIL_P(sep)) rb_str_concat(result, sep);
	rb_str_cat(result, RSTRING(tmp)->ptr, RSTRING(tmp)->len);
	if (OBJ_TAINTED(tmp)) OBJ_TAINT(result);
d627 1
a627 1
rb_ary_join_method(argc, argv, ary)
d635 4
a638 2
    if (NIL_P(sep)) sep = rb_output_fs;
    return rb_ary_join(ary, sep);
d642 1
a642 1
rb_ary_to_s(ary)
d645 2
a646 5
    VALUE str;

    if (RARRAY(ary)->len == 0) return rb_str_new(0, 0);
    str = rb_ary_join(ary, rb_output_fs);
    if (NIL_P(str)) return rb_str_new(0, 0);
a649 18
#ifdef USE_THREAD
static ID inspect_key;
#else
static VALUE inspect_tbl;
#endif

struct inspect_arg {
    VALUE (*func)();
    VALUE arg1, arg2;
};

VALUE
inspect_call(arg)
    struct inspect_arg *arg;
{
    return (*arg->func)(arg->arg1, arg->arg2);
}

d651 1
a651 61
inspect_ensure(obj)
    VALUE obj;
{
#ifdef USE_THREAD
    VALUE inspect_tbl;

    inspect_tbl = rb_thread_local_aref(rb_thread_current(), inspect_key);
#endif
    rb_ary_pop(inspect_tbl);
    return 0;
}

VALUE
rb_protect_inspect(func, obj, arg)
    VALUE (*func)();
    VALUE obj, arg;
{
    struct inspect_arg iarg;

#ifdef USE_THREAD
    VALUE inspect_tbl;

    if (!inspect_key) {
	inspect_key = rb_intern("__inspect_key__");
    }
    inspect_tbl = rb_thread_local_aref(rb_thread_current(), inspect_key);
    if (NIL_P(inspect_tbl)) {
	inspect_tbl = rb_ary_new();
	rb_thread_local_aset(rb_thread_current(), inspect_key, inspect_tbl);
    }
#else
    if (!inspect_tbl) {
	inspect_tbl = rb_ary_new();
	rb_global_variable(&inspect_tbl);
    }
#endif
    rb_ary_push(inspect_tbl, obj);
    iarg.func = func;
    iarg.arg1 = obj;
    iarg.arg2 = arg;
    return rb_ensure(inspect_call, (VALUE)&iarg, inspect_ensure, obj);
}

VALUE
rb_inspecting_p(obj)
    VALUE obj;
{
#ifdef USE_THREAD
    VALUE inspect_tbl;

    if (!inspect_key) return Qfalse;
    inspect_tbl = rb_thread_local_aref(rb_thread_current(), inspect_key);
    if (NIL_P(inspect_tbl)) return Qfalse;
#else
    if (!inspect_tbl) return Qnil;
#endif
    return rb_ary_includes(inspect_tbl, obj);
}

static VALUE
inspect_ary(ary)
d654 1
a654 1
    size_t i = 0;
d657 3
a659 1
    str = rb_str_new2("[");
d663 3
a665 2
	if (i > 0) rb_str_cat(str, ", ", 2);
	rb_str_cat(str, RSTRING(s)->ptr, RSTRING(s)->len);
d667 1
a667 1
    rb_str_cat(str, "]", 1);
d673 1
a673 10
rb_ary_inspect(ary)
    VALUE ary;
{
    if (RARRAY(ary)->len == 0) return rb_str_new2("[]");
    if (rb_inspecting_p(ary)) return rb_str_new2("[...]");
    return rb_protect_inspect(inspect_ary, ary, 0);
}

static VALUE
rb_ary_to_a(ary)
d680 1
a680 1
rb_ary_reverse(ary)
a685 2
    if (RARRAY(ary)->len == 0) return ary;

d700 1
a700 1
rb_ary_reverse_method(ary)
d703 1
a703 1
    return rb_ary_reverse(rb_ary_dup(ary));
d712 1
a712 1
    VALUE retval = rb_yield(rb_assoc_new(*a, *b));
d725 2
a726 2
    else if (TYPE(*a) == T_STRING && TYPE(*b) == T_STRING) {
	return rb_str_cmp(*a, *b);
a732 17
static VALUE
sort_internal(ary)
    VALUE ary;
{
    qsort(RARRAY(ary)->ptr, RARRAY(ary)->len, sizeof(VALUE),
	  rb_iterator_p()?sort_1:sort_2);
    return ary;
}

static VALUE
sort_unlock(ary)
    VALUE ary;
{
    FL_UNSET(ary, ARY_TMPLOCK);
    return ary;
}

d734 1
a734 1
rb_ary_sort_bang(ary)
d737 2
a738 5
    if (RARRAY(ary)->len <= 1) return ary;

    rb_ary_modify(ary);
    FL_SET(ary, ARY_TMPLOCK);	/* prohibit modification during sort */
    rb_ensure(sort_internal, ary, sort_unlock, ary);
d743 1
a743 1
rb_ary_sort(ary)
d746 1
a746 2
    if (RARRAY(ary)->len == 0) return ary;
    return rb_ary_sort_bang(rb_ary_dup(ary));
d750 1
a750 1
rb_ary_delete(ary, item)
d754 1
a754 1
    size_t i1, i2;
d756 1
a756 1
    rb_ary_modify(ary);
d765 1
a765 3
	if (rb_iterator_p()) {
	    return rb_yield(item);
	}
d776 1
a776 1
rb_ary_delete_at(ary, at)
d780 1
a780 1
    size_t i1, i2, pos;
d783 2
a784 2
    rb_ary_modify(ary);
    pos = NUM2UINT(at);
d801 1
a801 1
rb_ary_delete_if(ary)
d804 1
a804 1
    size_t i1, i2;
d806 1
a806 1
    rb_ary_modify(ary);
d819 1
d821 1
a821 1
rb_ary_filter(ary)
d824 1
a824 1
    size_t i;
a825 1
    rb_ary_modify(ary);
a828 2
    return ary;
}
a829 6
static VALUE
rb_ary_replace_method(ary, ary2)
    VALUE ary, ary2;
{
    ary2 = to_ary(ary2);
    rb_ary_replace(ary, 0, RARRAY(ary2)->len, ary2);
d832 1
d835 1
a835 1
rb_ary_clear(ary)
d847 1
a847 1
rb_ary_fill(argc, argv, ary)
d853 1
a853 1
    size_t beg, len, end;
d856 2
a857 2
    if (rb_scan_args(argc, argv, "12", &item, &arg1, &arg2) == 2 &&
	beg_len(arg1, &beg, &len, RARRAY(ary)->len)) {
d861 1
a861 1
	beg = NIL_P(arg1)?0:NUM2UINT(arg1);
d866 6
a871 1
	len = NIL_P(arg2)?RARRAY(ary)->len - beg:NUM2UINT(arg2);
a872 1
    rb_ary_modify(ary);
d880 1
a880 1
	    rb_mem_clear(RARRAY(ary)->ptr+RARRAY(ary)->len,end-RARRAY(ary)->len);
d893 1
a893 1
rb_ary_plus(x, y)
d899 1
a899 1
	return rb_ary_plus(x, rb_Array(y));
d902 1
a902 1
    z = rb_ary_new2(RARRAY(x)->len + RARRAY(y)->len);
d910 1
a910 1
rb_ary_concat(x, y)
d916 1
a916 1
	return rb_ary_concat(x, rb_Array(y));
d922 1
a922 1
	rb_ary_store(x, RARRAY(x)->len, *p);
d929 1
a929 1
rb_ary_times(ary, times)
d934 1
a934 1
    size_t i, len;
d937 1
a937 1
	return rb_ary_join(ary, times);
d940 4
a943 1
    len = NUM2UINT(times);
d945 1
a945 1
	rb_raise(rb_eArgError, "negative argument");
a946 4
    len *= RARRAY(ary)->len;

    ary2 = rb_ary_new2(len);
    RARRAY(ary2)->len = len;
d956 1
a956 1
rb_ary_assoc(ary, key)
d974 1
a974 1
rb_ary_rassoc(ary, value)
d992 1
a992 1
rb_ary_equal(ary1, ary2)
d995 1
a995 1
    size_t i;
d997 2
a998 2
    if (TYPE(ary2) != T_ARRAY) return Qfalse;
    if (RARRAY(ary1)->len != RARRAY(ary2)->len) return Qfalse;
d1001 1
a1001 1
	    return Qfalse;
d1003 1
a1003 1
    return Qtrue;
d1007 1
a1007 1
rb_ary_eql(ary1, ary2)
d1010 1
a1010 1
    size_t i;
d1012 1
a1012 1
    if (TYPE(ary2) != T_ARRAY) return Qfalse;
d1014 1
a1014 1
	return Qfalse;
d1017 1
a1017 1
	    return Qfalse;
d1019 1
a1019 1
    return Qtrue;
d1023 1
a1023 1
rb_ary_hash(ary)
d1026 1
a1026 2
    size_t i;
    int h;
d1030 1
a1030 2
	int n = rb_hash(RARRAY(ary)->ptr[i]);
	h ^= NUM2LONG(n);
d1036 1
a1036 1
rb_ary_includes(ary, item)
d1040 1
a1040 1
    size_t i;
d1043 1
a1043 22
	    return Qtrue;
	}
    }
    return Qfalse;
}

static VALUE
rb_ary_cmp(ary, ary2)
    VALUE ary;
    VALUE ary2;
{
    size_t i, len;

    ary2 = to_ary(ary2);
    len = RARRAY(ary)->len;
    if (len > RARRAY(ary2)->len) {
	len = RARRAY(ary2)->len;
    }
    for (i=0; i<len; i++) {
	VALUE v = rb_funcall(RARRAY(ary)->ptr[i],cmp,1,RARRAY(ary2)->ptr[i]);
	if (v != INT2FIX(0)) {
	    return v;
d1046 1
a1046 4
    len = RARRAY(ary)->len - RARRAY(ary2)->len;
    if (len == 0) return INT2FIX(0);
    if (len > 0) return INT2FIX(1);
    return INT2FIX(-1);
d1050 1
a1050 1
rb_ary_diff(ary1, ary2)
d1054 1
a1054 1
    size_t i;
d1056 2
a1057 2
    ary2 = to_ary(ary2);
    ary3 = rb_ary_new();
d1059 3
a1061 3
	if (rb_ary_includes(ary2, RARRAY(ary1)->ptr[i])) continue;
	if (rb_ary_includes(ary3, RARRAY(ary1)->ptr[i])) continue;
	rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1067 1
a1067 1
rb_ary_and(ary1, ary2)
d1071 1
a1071 1
    size_t i;
d1073 2
a1074 2
    ary2 = to_ary(ary2);
    ary3 = rb_ary_new();
d1076 3
a1078 3
	if (rb_ary_includes(ary2, RARRAY(ary1)->ptr[i])
	    && !rb_ary_includes(ary3, RARRAY(ary1)->ptr[i])) {
	    rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1085 1
a1085 1
rb_ary_or(ary1, ary2)
d1089 1
a1089 1
    size_t i;
d1092 2
a1093 2
	if (rb_ary_includes(ary1, ary2)) return ary1;
	else return rb_ary_plus(ary1, ary2);
d1096 1
a1096 1
    ary3 = rb_ary_new();
d1098 2
a1099 2
	if (!rb_ary_includes(ary3, RARRAY(ary1)->ptr[i]))
		rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1102 2
a1103 2
	if (!rb_ary_includes(ary3, RARRAY(ary2)->ptr[i]))
		rb_ary_push(ary3, RARRAY(ary2)->ptr[i]);
d1109 1
a1109 40
rb_ary_uniq_bang(ary)
    VALUE ary;
{
    VALUE *p, *q, *t, *end;
    VALUE v;

    rb_ary_modify(ary);
    p = RARRAY(ary)->ptr;
    end = p + RARRAY(ary)->len;

    while (p < end) {
	v = *p++;
	q = t = p;
	while (q < end) {
	    if (rb_equal(*q, v)) q++;
	    else *t++ = *q++;
	}
	end = t;
    }
    if (RARRAY(ary)->len == (end - RARRAY(ary)->ptr)) {
	return Qnil;
    }

    RARRAY(ary)->len = (end - RARRAY(ary)->ptr);

    return ary;
}

static VALUE
rb_ary_uniq(ary)
    VALUE ary;
{
    VALUE v = rb_ary_uniq_bang(rb_ary_dup(ary));

    if (NIL_P(v)) return ary;
    return v;
}

static VALUE
rb_ary_compact_bang(ary)
d1114 1
a1114 1
    rb_ary_modify(ary);
a1120 3
    if (RARRAY(ary)->len == (p - RARRAY(ary)->ptr)) {
	return Qnil;
    }
d1128 1
a1128 1
rb_ary_compact(ary)
d1131 1
a1131 4
    VALUE v = rb_ary_compact_bang(rb_ary_dup(ary));

    if (NIL_P(v)) return ary;
    return v;
d1135 1
a1135 1
rb_ary_nitems(ary)
d1138 1
a1138 1
    size_t n = 0;
d1150 1
a1150 28
static VALUE
rb_ary_flatten_bang(ary)
    VALUE ary;
{
    size_t i;
    int mod = 0;

    rb_ary_modify(ary);
    for (i=0; i<RARRAY(ary)->len; i++) {
	VALUE ary2 = RARRAY(ary)->ptr[i];
	if (TYPE(ary2) == T_ARRAY) {
	    rb_ary_replace(ary, i--, 1, ary2);
	    mod = 1;
	}
    }
    if (mod == 0) return Qnil;
    return ary;
}

static VALUE
rb_ary_flatten(ary)
    VALUE ary;
{
    VALUE v = rb_ary_flatten_bang(rb_ary_dup(ary));

    if (NIL_P(v)) return ary;
    return v;
}
d1155 2
a1156 2
    rb_cArray  = rb_define_class("Array", rb_cObject);
    rb_include_module(rb_cArray, rb_mEnumerable);
d1158 60
a1217 67
    rb_define_singleton_method(rb_cArray, "new", rb_ary_s_new, -1);
    rb_define_singleton_method(rb_cArray, "[]", rb_ary_s_create, -1);
    rb_define_method(rb_cArray, "to_s", rb_ary_to_s, 0);
    rb_define_method(rb_cArray, "inspect", rb_ary_inspect, 0);
    rb_define_method(rb_cArray, "to_a", rb_ary_to_a, 0);
    rb_define_method(rb_cArray, "to_ary", rb_ary_to_a, 0);

    rb_define_method(rb_cArray, "freeze",  rb_ary_freeze, 0);
    rb_define_method(rb_cArray, "frozen?",  rb_ary_frozen_p, 0);

    rb_define_method(rb_cArray, "==", rb_ary_equal, 1);
    rb_define_method(rb_cArray, "eql?", rb_ary_eql, 1);
    rb_define_method(rb_cArray, "hash", rb_ary_hash, 0);
    rb_define_method(rb_cArray, "===", rb_ary_equal, 1);

    rb_define_method(rb_cArray, "[]", rb_ary_aref, -1);
    rb_define_method(rb_cArray, "[]=", rb_ary_aset, -1);
    rb_define_method(rb_cArray, "concat", rb_ary_concat, 1);
    rb_define_method(rb_cArray, "<<", rb_ary_push, 1);
    rb_define_method(rb_cArray, "push", rb_ary_push_method, -1);
    rb_define_method(rb_cArray, "pop", rb_ary_pop, 0);
    rb_define_method(rb_cArray, "shift", rb_ary_shift, 0);
    rb_define_method(rb_cArray, "unshift", rb_ary_unshift, 1);
    rb_define_method(rb_cArray, "each", rb_ary_each, 0);
    rb_define_method(rb_cArray, "each_index", rb_ary_each_index, 0);
    rb_define_method(rb_cArray, "reverse_each", rb_ary_reverse_each, 0);
    rb_define_method(rb_cArray, "length", rb_ary_length, 0);
    rb_define_alias(rb_cArray,  "size", "length");
    rb_define_method(rb_cArray, "empty?", rb_ary_empty_p, 0);
    rb_define_method(rb_cArray, "index", rb_ary_index, 1);
    rb_define_method(rb_cArray, "rindex", rb_ary_rindex, 1);
    rb_define_method(rb_cArray, "indexes", rb_ary_indexes, -1);
    rb_define_method(rb_cArray, "indices", rb_ary_indexes, -1);
    rb_define_method(rb_cArray, "clone", rb_ary_clone, 0);
    rb_define_method(rb_cArray, "dup", rb_ary_dup, 0);
    rb_define_method(rb_cArray, "join", rb_ary_join_method, -1);
    rb_define_method(rb_cArray, "reverse", rb_ary_reverse_method, 0);
    rb_define_method(rb_cArray, "reverse!", rb_ary_reverse, 0);
    rb_define_method(rb_cArray, "sort", rb_ary_sort, 0);
    rb_define_method(rb_cArray, "sort!", rb_ary_sort_bang, 0);
    rb_define_method(rb_cArray, "delete", rb_ary_delete, 1);
    rb_define_method(rb_cArray, "delete_at", rb_ary_delete_at, 1);
    rb_define_method(rb_cArray, "delete_if", rb_ary_delete_if, 0);
    rb_define_method(rb_cArray, "filter", rb_ary_filter, 0);
    rb_define_method(rb_cArray, "replace", rb_ary_replace_method, 1);
    rb_define_method(rb_cArray, "clear", rb_ary_clear, 0);
    rb_define_method(rb_cArray, "fill", rb_ary_fill, -1);
    rb_define_method(rb_cArray, "include?", rb_ary_includes, 1);
    rb_define_method(rb_cArray, "<=>", rb_ary_cmp, 1);

    rb_define_method(rb_cArray, "assoc", rb_ary_assoc, 1);
    rb_define_method(rb_cArray, "rassoc", rb_ary_rassoc, 1);

    rb_define_method(rb_cArray, "+", rb_ary_plus, 1);
    rb_define_method(rb_cArray, "*", rb_ary_times, 1);

    rb_define_method(rb_cArray, "-", rb_ary_diff, 1);
    rb_define_method(rb_cArray, "&", rb_ary_and, 1);
    rb_define_method(rb_cArray, "|", rb_ary_or, 1);

    rb_define_method(rb_cArray, "uniq", rb_ary_uniq, 0);
    rb_define_method(rb_cArray, "uniq!", rb_ary_uniq_bang, 0);
    rb_define_method(rb_cArray, "compact", rb_ary_compact, 0);
    rb_define_method(rb_cArray, "compact!", rb_ary_compact_bang, 0);
    rb_define_method(rb_cArray, "flatten", rb_ary_flatten, 0);
    rb_define_method(rb_cArray, "flatten!", rb_ary_flatten_bang, 0);
    rb_define_method(rb_cArray, "nitems", rb_ary_nitems, 0);
@


1.1.1.3.2.1
log
@990126
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:21 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d75 1
a75 1
    int len;
d110 1
a110 1
rb_ary_new3(int n, ...)
d113 1
a113 1
    int n;
d119 1
a119 1
    int i;
d138 1
a138 1
    int n;
d172 1
a172 1
    int len = 0;
d183 1
a183 1
	int capa = NUM2INT(size);
d227 1
a227 1
    int idx;
d329 1
a329 1
    int offset;
d346 1
a346 1
    int beg, len;
d374 2
a375 1
    int *begp, *lenp, len;
d377 2
a378 2
    int beg, end;
    int b, e;
d411 1
a411 1
    int beg, len;
d414 2
a415 2
	beg = NUM2INT(arg1);
	len = NUM2INT(arg2);
d424 1
a424 1
	return rb_ary_entry(ary, FIX2INT(arg1));
d433 1
a433 1
    return rb_ary_entry(ary, NUM2INT(arg1));
d441 1
a441 1
    int i;
d455 1
a455 1
    int i = RARRAY(ary)->len;
d471 1
a471 1
    int i;
d475 1
a475 1
	rb_ary_store(new_ary, i, rb_ary_entry(ary, NUM2INT(argv[i])));
d484 1
a484 1
    int beg, len;
d514 1
a514 1
	int alen;
d542 2
a543 1
    int offset, beg, len;
d546 2
a547 2
	beg = NUM2INT(arg1);
	len = NUM2INT(arg2);
d556 1
a556 1
	offset = FIX2INT(arg1);
d568 1
a568 1
    offset = NUM2INT(arg1);
d578 1
a578 1
    int i;
d590 1
a590 1
    int i;
d602 1
a602 1
    int len = RARRAY(ary)->len;
d666 1
a666 1
    int i;
d827 1
a827 1
    int i = 0;
d956 1
a956 1
    int i1, i2;
d984 1
a984 1
    int i1, i2, pos;
d988 1
a988 1
    pos = NUM2INT(at);
d1008 1
a1008 1
    int i1, i2;
d1027 1
a1027 1
    int i;
d1064 1
a1064 1
    int beg, end, len;
d1072 1
a1072 1
	beg = NIL_P(arg1)?0:NUM2INT(arg1);
d1077 1
a1077 1
	len = NIL_P(arg2)?RARRAY(ary)->len - beg:NUM2INT(arg2);
d1141 1
a1141 1
    int i, len;
d1147 1
a1147 1
    len = NUM2INT(times);
d1203 1
a1203 1
    int i;
d1218 1
a1218 1
    int i;
d1234 2
a1235 1
    int i, h;
d1250 1
a1250 1
    int i;
d1264 1
a1264 1
    int i, len;
d1288 1
a1288 1
    int i;
d1305 1
a1305 1
    int i;
d1323 1
a1323 1
    int i;
d1417 1
a1417 1
    int n = 0;
d1433 1
a1433 1
    int i;
@


1.1.1.3.2.2
log
@990201
@
text
@d6 1
a6 1
  $Date: 1999/01/26 10:08:08 $
d52 1
a52 1
    if (!FL_TEST(ary, FL_TAINT) && rb_safe_level() >= 4)
d239 1
a239 5
	int capa_inc = RARRAY(ary)->capa / 2;
	if (capa_inc < ARY_DEFAULT_SIZE) {
	    capa_inc = ARY_DEFAULT_SIZE;
	}
	RARRAY(ary)->capa = idx + capa_inc;
d313 1
a313 5
	int capa_inc = RARRAY(ary)->capa / 2;
	if (capa_inc < ARY_DEFAULT_SIZE) {
	    capa_inc = ARY_DEFAULT_SIZE;
	}
	RARRAY(ary)->capa+=capa_inc;
d1010 1
a1010 1
	if (RTEST(rb_yield(RARRAY(ary)->ptr[i1]))) continue;
@


1.1.1.3.2.3
log
@990203
@
text
@d6 1
a6 1
  $Date: 1999/02/01 07:34:53 $
a1511 1
    rb_define_method(rb_cArray, "reject!", rb_ary_delete_if, 0);
@


1.1.1.3.2.4
log
@990215
@
text
@d6 1
a6 1
  $Date: 1999/02/03 09:47:57 $
d824 1
a824 1
    if (!inspect_tbl) return Qfalse;
@


1.1.1.3.2.5
log
@990224
@
text
@d6 1
a6 1
  $Date: 1999/02/15 07:31:48 $
d358 2
a359 3
    if (len == 0) return rb_ary_new2(0);
    if (len < 0) {
	rb_raise(rb_eIndexError, "negative length %d", len);
a395 1
    *begp = beg;
a396 4
	if (e == -1) {
	    *lenp = 0;
	    return Qtrue;
	}
d400 1
d405 2
a406 1
	*lenp = end - beg + 1;
a557 3
#ifdef INABA
	if (len < 0) return Qnil;
#endif
a566 3
#ifdef INABA
	if (len < 0) return Qnil;
#endif
@


1.1.1.3.2.6
log
@990225
@
text
@d6 1
a6 1
  $Date: 1999/02/24 04:31:17 $
d197 1
a197 1
    rb_obj_call_init((VALUE)ary, argc, argv);
@


1.1.1.3.2.7
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/25 06:39:02 $
d232 1
a232 1
	idx += RARRAY(ary)->len;
d234 1
a234 2
	    rb_raise(rb_eIndexError, "index %d out of array",
		     idx - RARRAY(ary)->len);
d352 1
a352 1
rb_ary_subary(ary, beg, len)
d358 8
a365 3
    if (len < 0) return Qnil;
    if (beg > RARRAY(ary)->len) return Qnil;
    if (beg < 0) return Qnil;
a371 1
    if (len == 0) return rb_ary_new2(0);
d380 35
d430 1
a430 1
	return rb_ary_subary(ary, beg, len);
d440 1
a440 1
    else {
d442 1
a442 8
	switch (rb_range_beg_len(arg1, &beg, &len, RARRAY(ary)->len, 0)) {
	  case Qfalse:
	    break;
	  case Qnil:
	    return Qnil;
	  default:
	    return rb_ary_subary(ary, beg, len);
	}
a485 1
#if 0
a486 4
#else
	VALUE v = argv[i];
	rb_ary_concat(new_ary, rb_ary_aref(1, &v, ary));
#endif
d497 2
a498 10
    if (len < 0) rb_raise(rb_eIndexError, "negative length %d", len);
    if (beg < 0) {
	beg += RARRAY(ary)->len;
    }
    if (beg < 0) {
	beg -= RARRAY(ary)->len;
	rb_raise(rb_eIndexError, "index %d out of array", beg);
    }
    if (beg + len > RARRAY(ary)->len) {
	len = RARRAY(ary)->len - beg;
d505 8
d553 1
a553 1
    int offset, beg, end, len;
d556 10
a565 1
	rb_ary_replace(ary, NUM2INT(arg1), NUM2INT(arg2), arg3);
d572 1
a572 1
    else if (rb_range_beg_len(arg1, &beg, &len, RARRAY(ary)->len, 1)) {
d574 3
d658 1
a658 1
    return rb_ary_s_create(RARRAY(ary)->len, RARRAY(ary)->ptr, CLASS_OF(ary));
d761 1
d763 3
d783 1
d787 1
d799 1
d810 6
d827 1
d833 3
d1057 1
a1057 1
    rb_ary_replace(ary, 0, RARRAY(ary)->len, ary2);
d1083 5
a1087 12
    rb_scan_args(argc, argv, "12", &item, &arg1, &arg2);
    switch (argc) {
      case 1:
	beg = 0;
	len = RARRAY(ary)->len - beg;
	break;
      case 2:
	if (rb_range_beg_len(arg1, &beg, &len, RARRAY(ary)->len, 1)) {
	    break;
	}
	/* fall through */
      case 3:
a1093 1
	break;
@


1.1.1.3.2.8
log
@small fixes
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:23 $
d211 2
a212 1
    ary->len = ary->capa = 0;
a219 1
    ary->len = ary->capa = argc;
d455 6
a460 1
	rb_ary_push(new_ary, rb_ary_aref(1, argv+i, ary));
@


1.1.1.3.2.9
log
@regexp null pattern
@
text
@d6 1
a6 1
  $Date: 1999/05/06 08:31:25 $
d75 1
a75 1
    long len;
d110 1
a110 1
rb_ary_new3(long n, ...)
d113 1
a113 1
    long n;
d119 1
a119 1
    long i;
d138 1
a138 1
    long n;
d172 1
a172 1
    long len = 0;
d183 1
a183 1
	long capa = NUM2LONG(size);
d227 1
a227 1
    long idx;
d240 1
a240 1
	long capa_inc = RARRAY(ary)->capa / 2;
d318 1
a318 1
	long capa_inc = RARRAY(ary)->capa / 2;
d338 1
a338 1
    long offset;
d355 1
a355 1
    long beg, len;
d384 1
a384 1
    long beg, len;
d387 2
a388 2
	beg = NUM2LONG(arg1);
	len = NUM2LONG(arg2);
d397 1
a397 1
	return rb_ary_entry(ary, FIX2LONG(arg1));
d413 1
a413 1
    return rb_ary_entry(ary, NUM2LONG(arg1));
d421 1
a421 1
    long i;
d425 1
a425 1
	    return INT2NUM(i);
d435 1
a435 1
    long i = RARRAY(ary)->len;
d439 1
a439 1
	    return INT2NUM(i);
d451 1
a451 1
    long i;
d464 1
a464 1
    long beg, len;
d494 1
a494 1
	long alen;
d522 1
a522 1
    long offset, beg, len;
d525 1
a525 1
	rb_ary_replace(ary, NUM2LONG(arg1), NUM2LONG(arg2), arg3);
d529 1
a529 1
	offset = FIX2LONG(arg1);
d541 1
a541 1
    offset = NUM2LONG(arg1);
d551 1
a551 1
    long i;
d563 1
a563 1
    long i;
d566 1
a566 1
	rb_yield(INT2NUM(i));
d575 1
a575 1
    long len = RARRAY(ary)->len;
d587 1
a587 1
    return INT2NUM(RARRAY(ary)->len);
d639 1
a639 1
    long i;
d783 1
a783 1
    long i = 0;
d912 1
a912 1
    long i1, i2;
d940 1
a940 1
    long i1, i2, pos;
d944 1
a944 1
    pos = NUM2LONG(at);
d964 1
a964 1
    long i1, i2;
d983 1
a983 1
    long i;
d1020 1
a1020 1
    long beg, end, len;
d1035 1
a1035 1
	beg = NIL_P(arg1)?0:NUM2LONG(arg1);
d1040 1
a1040 1
	len = NIL_P(arg2)?RARRAY(ary)->len - beg:NUM2LONG(arg2);
d1105 1
a1105 1
    long i, len;
d1111 1
a1111 1
    len = NUM2LONG(times);
d1167 1
a1167 1
    long i;
d1182 1
a1182 1
    long i;
d1198 1
a1198 2
    long i;
    int h;
d1213 1
a1213 1
    long i;
d1227 1
a1227 1
    long i, len;
d1251 1
a1251 1
    long i;
d1268 1
a1268 1
    long i;
d1286 1
a1286 1
    long i;
d1380 1
a1380 1
    long n = 0;
d1389 1
a1389 1
    return INT2NUM(n);
d1396 1
a1396 1
    long i;
@


1.1.1.3.2.10
log
@990611
@
text
@d6 1
a6 1
  $Date: 1999/05/25 08:25:46 $
d197 1
@


1.1.1.3.2.11
log
@backtrace may be Qnil
@
text
@d6 1
a6 1
  $Date: 1999/06/11 06:29:46 $
d555 1
a555 1
    return ary;
d567 1
a567 1
    return ary;
d579 1
a579 1
    return ary;
d925 1
a925 1
	return ary;
@


1.1.1.3.2.12
log
@Array#delete return value
@
text
@d6 1
a6 1
  $Date: 1999/07/22 10:37:03 $
d925 1
a925 1
	return Qnil;
@


1.1.1.3.2.13
log
@990806
@
text
@d6 1
a6 1
  $Date: 1999/07/30 06:43:06 $
d358 1
d360 1
a360 5
    if (beg < 0) {
	len += beg;
	beg = 0;
    }
    if (len < 0) return Qnil;
@


1.1.1.3.2.14
log
@1.3.8 to be, final beta (hopefully)
@
text
@d6 1
a6 1
  $Date: 1999/08/06 06:48:02 $
a88 1
    if (len == 0) len++;
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:04:55 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@segv on empty arrays
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:43 $
d413 1
a413 1
    if (!args || NIL_P(args) || RARRAY(args)->len == 0) {
a685 2
    if (RARRAY(ary)->len == 0) return ary;

a736 2
    if (RARRAY(ary)->len == 0) return ary;

a745 1
    if (RARRAY(ary)->len == 0) return ary;
@


1.1.1.2.2.3
log
@1.1b7 pre
@
text
@d6 1
a6 1
  $Date: 1998/02/04 05:02:43 $
d406 2
a407 4
ary_indexes(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
d409 1
d411 1
a411 1
    int i;
d413 2
a414 3
    new_ary = ary_new2(argc);
    for (i=0; i<argc; i++) {
	ary_store(new_ary, i, ary_entry(ary, NUM2INT(argv[i])));
d417 7
d824 1
d826 1
a826 1
ary_filter(ary)
a830 1
    ary_modify(ary);
a833 2
    return ary;
}
a834 6
static VALUE
ary_replace_method(ary, ary2)
    VALUE ary, ary2;
{
    Check_Type(ary2, T_ARRAY);
    ary_replace(ary, 0, RARRAY(ary2)->len, ary2);
d837 1
d1191 1
a1191 2
    rb_define_method(cArray, "indexes", ary_indexes, -1);
    rb_define_method(cArray, "indices", ary_indexes, -1);
d1202 3
a1204 2
    rb_define_method(cArray, "filter", ary_filter, 0);
    rb_define_method(cArray, "replace", ary_replace_method, 1);
@


1.1.1.2.2.4
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/02/09 10:56:17 $
d118 1
a118 6
    if (elts) {
	MEMCPY(RARRAY(ary)->ptr, elts, VALUE, n);
    }
    else {
	memclear(RARRAY(ary)->ptr, n);
    }
d139 1
a139 1
ary_s_new(argc, argv, klass)
d142 1
a142 1
    VALUE klass;
d146 1
a146 1
    OBJSETUP(ary, klass, T_ARRAY);
d158 1
a158 1
ary_s_create(argc, argv, klass)
d161 1
a161 1
    VALUE klass;
d164 1
a164 1
    OBJSETUP(ary, klass, T_ARRAY);
@


1.1.1.2.2.5
log
@block arg etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:27 $
a1231 3

    /* turn on premitive flag for the class */
    FL_SET(cArray, FL_PRIMITIVE);
@


1.1.1.2.2.6
log
@gets speed up patch
@
text
@d6 1
a6 1
  $Date: 1998/03/05 06:37:42 $
d1232 3
@


1.1.1.2.2.7
log
@call initialize
@
text
@d6 1
a6 1
  $Date: 1998/03/11 07:32:52 $
a157 1
    obj_call_init((VALUE)ary);
d742 1
a742 2
    qsort(RARRAY(ary)->ptr, RARRAY(ary)->len, sizeof(VALUE),
	  iterator_p()?sort_1:sort_2);
a1120 40
ary_uniq_bang(ary)
    VALUE ary;
{
    VALUE *p, *q, *t, *end;
    VALUE v;
    int i;

    ary_modify(ary);
    p = RARRAY(ary)->ptr;
    end = p + RARRAY(ary)->len;

    while (p < end) {
	v = *p++;
	q = t = p;
	while (q < end) {
	    if (rb_equal(*q, v)) q++;
	    else *t++ = *q++;
	}
	end = t;
    }
    if (RARRAY(ary)->len = (end - RARRAY(ary)->ptr)) {
	return Qnil;
    }

    RARRAY(ary)->len = (end - RARRAY(ary)->ptr);

    return ary;
}

static VALUE
ary_uniq(ary)
    VALUE ary;
{
    VALUE v = ary_uniq_bang(ary_clone(ary));

    if (NIL_P(v)) return ary;
    return v;
}

static VALUE
a1132 3
    if (RARRAY(ary)->len == (p - RARRAY(ary)->ptr)) {
	return Qnil;
    }
d1143 1
a1143 4
    VALUE v = ary_compact_bang(ary_clone(ary));

    if (NIL_P(v)) return ary;
    return v;
d1227 1
a1227 2
    rb_define_method(cArray, "uniq!", ary_uniq_bang, 0);
    rb_define_method(cArray, "uniq", ary_uniq, 0);
@


1.1.1.2.2.8
log
@dynamic (nested) local variables
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:03:47 $
a1062 21
VALUE
ary_cmp(ary, ary2)
    VALUE ary;
    VALUE ary2;
{
    int i, len;

    Check_Type(ary2, T_ARRAY);
    len = RARRAY(ary)->len;
    if (len > RARRAY(ary2)->len) {
	len = RARRAY(ary2)->len;
    }
    for (i=0; i<len; i++) {
	VALUE v = rb_funcall(RARRAY(ary)->ptr[i],cmp,1,RARRAY(ary2)->ptr[i]);
	if (v != INT2FIX(0)) {
	    return v;
	}
    }
    return INT2FIX(0);
}

a1263 1
    rb_define_method(cArray, "<=>", ary_cmp, 1);
@


1.1.1.2.2.9
log
@Array#cmp
@
text
@d6 1
a6 1
  $Date: 1998/04/07 08:34:05 $
d1081 1
a1081 4
    len = RARRAY(ary)->len - RARRAY(ary2)->len;
    if (len == 0) return INT2FIX(0);
    if (len > 0) return INT2FIX(1);
    return INT2FIX(-1);
@


1.1.1.2.2.10
log
@1.1b9_10 pre0
@
text
@d6 1
a6 1
  $Date: 1998/04/07 10:18:09 $
a1301 1
    rb_define_method(cArray, "compact", ary_compact, 0);
@


1.1.1.2.2.11
log
@signal to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/10 10:09:48 $
a308 3
    if (beg >= RARRAY(ary)->len) {
	IndexError("out of range %d", beg);
    }
d1167 1
a1167 1
    if (RARRAY(ary)->len == (end - RARRAY(ary)->ptr)) {
@


1.1.1.2.2.12
log
@signal delivered to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/13 06:06:11 $
d309 3
a319 3
    }
    if (len < 0) {
	len = 0;
@


1.1.1.2.2.13
log
@1.1b9_10 tobe
@
text
@d6 1
a6 1
  $Date: 1998/04/14 04:55:46 $
d1303 1
a1304 1
    rb_define_method(cArray, "uniq!", ary_uniq_bang, 0);
@


1.1.1.2.2.14
log
@flock,flatten,signal to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/14 09:08:14 $
a1236 38
static VALUE
ary_flatten_bang(ary)
    VALUE ary;
{
    int i;
    int mod = 0;

    ary_modify(ary);
    for (;;) {
	int lmod = 0;

	for (i=0; i<RARRAY(ary)->len; i++) {
	    if (TYPE(RARRAY(ary)->ptr[i]) == T_ARRAY) {
		VALUE ary2 = RARRAY(ary)->ptr[i];

		ary_replace(ary, i, RARRAY(ary2)->len, ary2);
		i += RARRAY(ary2)->len - 1;
		lmod++;
	    }
	}
	if (lmod == 0) break;
	mod = lmod;
    }

    if (mod == 0) return Qnil;
    return ary;
}

static VALUE
ary_flatten(ary)
    VALUE ary;
{
    VALUE v = ary_flatten_bang(ary_clone(ary));

    if (NIL_P(v)) return ary;
    return v;
}

a1306 2
    rb_define_method(cArray, "flatten", ary_flatten, 0);
    rb_define_method(cArray, "flatten!", ary_flatten_bang, 0);
@


1.1.1.2.2.15
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/04/16 07:42:41 $
d1245 11
a1255 5
    for (i=0; i<RARRAY(ary)->len; i++) {
	VALUE ary2 = RARRAY(ary)->ptr[i];
	if (TYPE(ary2) == T_ARRAY) {
	    ary_replace(ary, i--, 1, ary2);
	    mod = 1;
d1257 2
d1260 1
@


1.1.1.2.2.16
log
@ruby 1.1b9_13
@
text
@d6 1
a6 1
  $Date: 1998/04/17 09:29:33 $
a414 14
ary_rindex(ary, val)
    VALUE ary;
    VALUE val;
{
    int i = i<RARRAY(ary)->len;

    while (i--) {
	if (rb_equal(RARRAY(ary)->ptr[i], val))
	    return INT2FIX(i);
    }
    return Qnil;
}

static VALUE
a1301 1
    rb_define_method(cArray, "rindex", ary_rindex, 1);
@


1.1.1.2.2.17
log
@1.1b9_14
@
text
@d6 1
a6 1
  $Date: 1998/04/21 08:41:03 $
d419 1
a419 1
    int i = RARRAY(ary)->len;
@


1.1.1.2.2.18
log
@tcltklib/gtk
@
text
@d6 1
a6 1
  $Date: 1998/04/22 08:57:28 $
a601 7
static VALUE
to_ary(ary)
    VALUE ary;
{
    return rb_convert_type(ary, T_ARRAY, "Array", "to_ary");
}

d723 1
a723 1
    return ary_reverse(ary_dup(ary));
d770 1
a770 1
    return ary_sort_bang(ary_dup(ary));
d860 1
a860 1
    ary2 = to_ary(ary2);
d1087 1
a1087 1
    ary2 = to_ary(ary2);
d1111 1
a1111 1
    ary2 = to_ary(ary2);
d1128 1
a1128 1
    ary2 = to_ary(ary2);
d1197 1
a1197 1
    VALUE v = ary_uniq_bang(ary_dup(ary));
d1229 1
a1229 1
    VALUE v = ary_compact_bang(ary_dup(ary));
d1274 1
a1274 1
    VALUE v = ary_flatten_bang(ary_dup(ary));
a1292 1
    rb_define_method(cArray, "to_ary", ary_to_a, 0);
@


1.1.1.2.2.19
log
@new exception model
@
text
@d6 1
a6 1
  $Date: 1998/04/27 10:03:48 $
d643 1
a643 1
	if (!NIL_P(sep)) str_concat(result, sep);
d661 1
@


1.1.1.2.2.20
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/04/30 07:41:07 $
a83 4
#ifdef __STDC__
#include <stdarg.h>
#define va_init_list(a,b) va_start(a,b)
#else
a84 2
#define va_init_list(a,b) va_start(a)
#endif
a86 3
#ifdef __STDC__
ary_new3(int n, ...)
#else
a89 1
#endif
d100 1
a100 1
    va_init_list(ar, n);
@


1.1.1.2.2.21
log
@prototypes
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:25:57 $
d84 1
a84 1
#ifdef HAVE_STDARG_PROTOTYPES
d93 1
a93 1
#ifdef HAVE_STDARG_PROTOTYPES
@


1.1.1.2.2.22
log
@remove unused variables
@
text
@d6 1
a6 1
  $Date: 1998/05/14 04:10:21 $
d1185 1
@


1.1.1.2.2.23
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 04:57:28 $
d805 1
a805 3
	if (iterator_p()) {
	    return rb_yield(item);
	}
@


1.1.1.2.2.24
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 09:42:16 $
d1296 2
@


1.1.1.2.2.25
log
@1.1b9_25
@
text
@d6 1
a6 1
  $Date: 1998/06/02 10:05:14 $
a65 6
    if (len < 0) {
	ArgError("negative array size (or size too big)");
    }
    if (len > 0 && len*sizeof(VALUE) <= 0) {
	ArgError("array size too big");
    }
d68 6
a73 3
    ary->ptr = 0;
    ary->ptr = ALLOC_N(VALUE, len);
    memclear(ary->ptr, len);
d165 1
a165 13
    ary->ptr = 0;
    if (NIL_P(size)) {
	ary->capa = ARY_DEFAULT_SIZE;
    }
    else {
	ary->capa = NUM2INT(size);
	if (ary->capa < 0) {
	    ArgError("negative array size");
	}
	if (ary->capa*sizeof(VALUE) < 0) {
	    ArgError("array size too big");
	}
    }
d989 4
a992 1
    len = NUM2INT(times);
a995 4
    len *= RARRAY(ary)->len;

    ary2 = ary_new2(len);
    RARRAY(ary2)->len = len;
@


1.1.1.2.2.26
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/06/11 10:02:55 $
d925 1
a925 1
	beg = NIL_P(arg1)?0:NUM2INT(arg1);
@


1.1.1.2.2.27
log
@str2cstr
@
text
@d6 1
a6 1
  $Date: 1998/07/10 09:44:40 $
d166 1
d169 1
a169 1
    if (rb_scan_args(argc, argv, "01", &size) == 0) {
d173 2
a174 3
	int capa = NUM2INT(size);

	if (capa < 0) {
d177 1
a177 1
	if (capa*sizeof(VALUE) < 0) {
a179 1
	ary->capa = capa;
d413 7
a419 1
    else if (TYPE(arg1) == T_BIGNUM) {
a421 4
    else if (beg_len(arg1, &beg, &len, RARRAY(ary)->len)) {
	/* check if idx is Range */
	return ary_subseq(ary, beg, len);
    }
d920 2
a921 2
    if (rb_scan_args(argc, argv, "12", &item, &arg1, &arg2) == 2 &&
	beg_len(arg1, &beg, &len, RARRAY(ary)->len)) {
d930 6
a935 1
	len = NIL_P(arg2)?RARRAY(ary)->len - beg:NUM2INT(arg2);
d944 1
a944 1
	    memclear(RARRAY(ary)->ptr+RARRAY(ary)->len,end-RARRAY(ary)->len);
@


1.1.1.2.2.28
log
@sync ev
@
text
@d6 1
a6 1
  $Date: 1998/07/13 04:37:22 $
a29 11
static void
memfill(mem, size, val)
    register VALUE *mem;
    register int size;
    register VALUE val;
{
    while (size--) {
	*mem++ = val;
    }
}

d134 3
d162 1
a162 1
    VALUE size, val;
d168 1
a168 1
    if (rb_scan_args(argc, argv, "02", &size, &val) == 0) {
d177 1
a177 1
	if (capa > 0 && capa*sizeof(VALUE) <= 0) {
a180 1
	ary->len = capa;
d183 1
a183 1
    memfill(ary->ptr, ary->len, val);
@


1.1.1.2.2.29
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/07/29 09:50:23 $
a169 1
    int len = 0;
d189 1
a189 1
	len = capa;
d192 1
a192 2
    memfill(ary->ptr, len, val);
    ary->len = len;
@


1.1.1.2.2.30
log
@1.1c7
@
text
@d6 1
a6 1
  $Date: 1998/08/14 03:56:17 $
a372 1
    int b, e;
d375 4
a378 1
    b = beg; e = end;
a383 8
    if (end < 0) {
	end = len + end;
	if (end < 0) end = -1;
    }
    if (beg > end) {
	IndexError("end smaller than beg [%d..%d]", b, e);
    }

d389 10
a398 1
	*lenp = end - beg +1;
@


1.1.1.2.2.31
log
@1.2.1 stable
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:48 $
d798 1
a798 1
    rb_qsort(RARRAY(ary)->ptr, RARRAY(ary)->len, sizeof(VALUE),
@


1.1.1.2.2.32
log
@1.2.2 release
@
text
@d6 1
a6 1
  $Date: 1999/01/11 07:55:24 $
d391 6
a396 1
    *lenp = end - beg + 1;
@


1.1.1.2.2.33
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/01/21 09:04:50 $
d867 1
a867 1
	if (RTEST(rb_yield(RARRAY(ary)->ptr[i1]))) continue;
@


1.1.1.2.2.34
log
@1.2.4
@
text
@d6 1
a6 1
  $Date: 1999/02/09 03:29:20 $
d896 1
a896 1
    ary_replace(ary, 0, RARRAY(ary)->len, ary2);
@


1.1.1.2.2.35
log
@moving
@
text
@d6 1
a6 1
  $Date: 1999/04/08 10:14:29 $
d209 2
a210 1
    ary->len = ary->capa = 0;
a217 1
    ary->len = ary->capa = argc;
@


1.1.1.2.2.29.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/08/14 03:56:17 $
d15 2
a16 1
VALUE rb_cArray;
d21 1
a21 1
rb_mem_clear(mem, size)
a41 1
#define ARY_TMPLOCK  FL_USER2
d44 1
a44 1
rb_ary_modify(ary)
d48 2
a49 2
    if (FL_TEST(ary, ARY_FREEZE|ARY_TMPLOCK)) {
	rb_raise(rb_eTypeError, "can't modify frozen array");
d54 1
a54 1
rb_ary_freeze(ary)
d62 1
a62 1
rb_ary_frozen_p(ary)
d65 3
a67 3
    if (FL_TEST(ary, ARY_FREEZE|ARY_TMPLOCK))
	return Qtrue;
    return Qfalse;
d71 1
a71 1
rb_ary_new2(len)
d75 1
a75 1
    OBJSETUP(ary, rb_cArray, T_ARRAY);
d78 1
a78 1
	rb_raise(rb_eArgError, "negative array size (or size too big)");
d81 1
a81 1
	rb_raise(rb_eArgError, "array size too big");
d87 1
d93 1
a93 1
rb_ary_new()
d95 1
a95 1
    return rb_ary_new2(ARY_DEFAULT_SIZE);
d108 1
a108 1
rb_ary_new3(int n, ...)
d110 1
a110 1
rb_ary_new3(n, va_alist)
d120 1
a120 1
	rb_raise(rb_eIndexError, "Negative number of items(%d)", n);
d122 1
a122 1
    ary = rb_ary_new2(n<ARY_DEFAULT_SIZE?ARY_DEFAULT_SIZE:n);
d135 1
a135 1
rb_ary_new4(n, elts)
d141 1
a141 1
    ary = rb_ary_new2(n);
d151 1
a151 1
rb_assoc_new(car, cdr)
d156 1
a156 1
    ary = rb_ary_new2(2);
d165 1
a165 1
rb_ary_s_new(argc, argv, klass)
d184 1
a184 1
	    rb_raise(rb_eArgError, "negative array size");
d187 1
a187 1
	    rb_raise(rb_eArgError, "array size too big");
d195 1
a195 1
    rb_obj_call_init((VALUE)ary);
d201 1
a201 1
rb_ary_s_create(argc, argv, klass)
d223 1
a223 1
rb_ary_store(ary, idx, val)
d228 1
a228 1
    rb_ary_modify(ary);
d230 1
a230 1
	rb_raise(rb_eIndexError, "negative index for array");
d238 1
a238 2
	rb_mem_clear(RARRAY(ary)->ptr+RARRAY(ary)->len,
		     idx-RARRAY(ary)->len+1);
d248 1
a248 1
rb_ary_push(ary, item)
d252 1
a252 1
    rb_ary_store(ary, RARRAY(ary)->len, item);
d257 1
a257 1
rb_ary_push_method(argc, argv, ary)
d263 1
a263 1
	rb_ary_store(ary, RARRAY(ary)->len, *argv++);
d269 1
a269 1
rb_ary_pop(ary)
d281 1
a281 1
rb_ary_shift(ary)
d302 1
a302 1
rb_ary_unshift(ary, item)
d305 1
a305 1
    rb_ary_modify(ary);
d319 1
a319 1
rb_ary_entry(ary, offset)
d336 1
a336 1
rb_ary_subseq(ary, beg, len)
d347 1
a347 1
	rb_raise(rb_eIndexError, "negative length %d", RARRAY(ary)->len);
d350 1
a350 1
	return rb_ary_new2(0);
d359 1
a359 1
    ary2 = rb_ary_new2(len);
d374 1
a374 1
    if (!rb_range_beg_end(range, &beg, &end)) return Qfalse;
d377 1
a377 1
	rb_raise(rb_eIndexError, "end smaller than beg [%d..%d]", beg, end);
d400 1
a400 1
    return Qtrue;
d404 1
a404 1
rb_ary_aref(argc, argv, ary)
d416 1
a416 1
	    return rb_ary_new();
d418 1
a418 1
	return rb_ary_subseq(ary, beg, len);
d423 1
a423 1
	return rb_ary_entry(ary, FIX2INT(arg1));
d426 1
a426 1
	rb_raise(rb_eIndexError, "index too big");
d430 1
a430 1
	return rb_ary_subseq(ary, beg, len);
d432 1
a432 1
    return rb_ary_entry(ary, NUM2INT(arg1));
d436 1
a436 1
rb_ary_index(ary, val)
d450 1
a450 1
rb_ary_rindex(ary, val)
d464 1
a464 1
rb_ary_indexes(argc, argv, ary)
d472 1
a472 1
    new_ary = rb_ary_new2(argc);
d474 1
a474 1
	rb_ary_store(new_ary, i, rb_ary_entry(ary, NUM2INT(argv[i])));
d481 1
a481 1
rb_ary_replace(ary, beg, len, rpl)
d485 1
a485 1
    rb_ary_modify(ary);
d499 1
a499 1
	rb_mem_clear(RARRAY(ary)->ptr+RARRAY(ary)->len, beg-RARRAY(ary)->len);
d510 1
a510 1
	    rb_raise(rb_eIndexError, "negative length %d", RARRAY(ary)->len);
d529 1
a529 1
rb_ary_aset(argc, argv, ary)
d541 1
a541 1
	rb_ary_replace(ary, beg, len, arg3);
d550 1
a550 1
	rb_ary_replace(ary, beg, len, arg2);
d554 1
a554 1
	rb_raise(rb_eIndexError, "index too big");
d562 1
a562 1
    rb_ary_store(ary, offset, arg2);
d567 1
a567 1
rb_ary_each(ary)
d579 1
a579 1
rb_ary_each_index(ary)
d591 1
a591 1
rb_ary_reverse_each(ary)
d603 1
a603 1
rb_ary_length(ary)
d610 1
a610 1
rb_ary_empty_p(ary)
d614 2
a615 2
	return Qtrue;
    return Qfalse;
d619 1
a619 1
rb_ary_clone(ary)
d622 1
a622 1
    VALUE ary2 = rb_ary_new2(RARRAY(ary)->len);
d631 1
a631 1
rb_ary_dup(ary)
d634 1
a634 1
    return rb_ary_new4(RARRAY(ary)->len, RARRAY(ary)->ptr);
d644 1
a644 1
extern VALUE rb_output_fs;
d647 1
a647 1
rb_ary_join(ary, sep)
d653 1
a653 1
    if (RARRAY(ary)->len == 0) return rb_str_new(0, 0);
d657 1
a657 1
	result = rb_str_dup(RARRAY(ary)->ptr[0]);
d660 1
a660 1
	result = rb_ary_join(RARRAY(ary)->ptr[0], sep);
d663 1
a663 1
	result = rb_obj_as_string(RARRAY(ary)->ptr[0]);
d673 1
a673 1
	    tmp = rb_ary_join(tmp, sep);
d676 1
a676 1
	    tmp = rb_obj_as_string(tmp);
d678 3
a680 3
	if (!NIL_P(sep)) rb_str_concat(result, sep);
	rb_str_cat(result, RSTRING(tmp)->ptr, RSTRING(tmp)->len);
	if (rb_str_tainted(tmp)) rb_str_taint(result);
d687 1
a687 1
rb_ary_join_method(argc, argv, ary)
d695 1
a695 1
    if (NIL_P(sep)) sep = rb_output_fs;
d697 1
a697 1
    return rb_ary_join(ary, sep);
d701 1
a701 1
rb_ary_to_s(ary)
d704 2
a705 2
    VALUE str = rb_ary_join(ary, rb_output_fs);
    if (NIL_P(str)) return rb_str_new(0, 0);
d710 1
a710 1
rb_ary_inspect(ary)
d716 2
a717 2
    if (RARRAY(ary)->len == 0) return rb_str_new2("[]");
    str = rb_str_new2("[");
d722 2
a723 2
	if (i > 0) rb_str_cat(str, ", ", 2);
	rb_str_cat(str, RSTRING(s)->ptr, RSTRING(s)->len);
d726 1
a726 1
    rb_str_cat(str, "]", 1);
d732 1
a732 1
rb_ary_to_a(ary)
d739 1
a739 1
rb_ary_reverse(ary)
d761 1
a761 1
rb_ary_reverse_method(ary)
d764 1
a764 1
    return rb_ary_reverse(rb_ary_dup(ary));
d773 1
a773 1
    VALUE retval = rb_yield(rb_assoc_new(*a, *b));
d786 2
a787 2
    else if (TYPE(*a) == T_STRING && TYPE(*b) == T_STRING) {
	return rb_str_cmp(*a, *b);
a793 17
static VALUE
sort_internal(ary)
    VALUE ary;
{
    qsort(RARRAY(ary)->ptr, RARRAY(ary)->len, sizeof(VALUE),
	  rb_iterator_p()?sort_1:sort_2);
    return ary;
}

static VALUE
sort_unlock(ary)
    VALUE ary;
{
    FL_UNSET(ary, ARY_TMPLOCK);
    return ary;
}

d795 1
a795 1
rb_ary_sort_bang(ary)
d800 3
a802 3
    rb_ary_modify(ary);
    FL_SET(ary, ARY_TMPLOCK);	/* prohibit modification during sort */
    rb_ensure(sort_internal, ary, sort_unlock, ary);
d807 1
a807 1
rb_ary_sort(ary)
d811 1
a811 1
    return rb_ary_sort_bang(rb_ary_dup(ary));
d815 1
a815 1
rb_ary_delete(ary, item)
d821 1
a821 1
    rb_ary_modify(ary);
d830 1
a830 1
	if (rb_iterator_p()) {
d843 1
a843 1
rb_ary_delete_at(ary, at)
d850 1
a850 1
    rb_ary_modify(ary);
d868 1
a868 1
rb_ary_delete_if(ary)
d873 1
a873 1
    rb_ary_modify(ary);
d887 1
a887 1
rb_ary_filter(ary)
d892 1
a892 1
    rb_ary_modify(ary);
d900 1
a900 1
rb_ary_replace_method(ary, ary2)
d904 1
a904 1
    rb_ary_replace(ary, 0, RARRAY(ary2)->len, ary2);
d909 1
a909 1
rb_ary_clear(ary)
d921 1
a921 1
rb_ary_fill(argc, argv, ary)
a941 1
    rb_ary_modify(ary);
d949 1
a949 1
	    rb_mem_clear(RARRAY(ary)->ptr+RARRAY(ary)->len,end-RARRAY(ary)->len);
d962 1
a962 1
rb_ary_plus(x, y)
d968 1
a968 1
	return rb_ary_plus(x, rb_Array(y));
d971 1
a971 1
    z = rb_ary_new2(RARRAY(x)->len + RARRAY(y)->len);
d979 1
a979 1
rb_ary_concat(x, y)
d985 1
a985 1
	return rb_ary_concat(x, rb_Array(y));
d991 1
a991 1
	rb_ary_store(x, RARRAY(x)->len, *p);
d998 1
a998 1
rb_ary_times(ary, times)
d1006 1
a1006 1
	return rb_ary_join(ary, times);
d1011 1
a1011 1
	rb_raise(rb_eArgError, "negative argument");
d1015 1
a1015 1
    ary2 = rb_ary_new2(len);
d1026 1
a1026 1
rb_ary_assoc(ary, key)
d1044 1
a1044 1
rb_ary_rassoc(ary, value)
d1062 1
a1062 1
rb_ary_equal(ary1, ary2)
d1067 2
a1068 2
    if (TYPE(ary2) != T_ARRAY) return Qfalse;
    if (RARRAY(ary1)->len != RARRAY(ary2)->len) return Qfalse;
d1071 1
a1071 1
	    return Qfalse;
d1073 1
a1073 1
    return Qtrue;
d1077 1
a1077 1
rb_ary_eql(ary1, ary2)
d1082 1
a1082 1
    if (TYPE(ary2) != T_ARRAY) return Qfalse;
d1084 1
a1084 1
	return Qfalse;
d1087 1
a1087 1
	    return Qfalse;
d1089 1
a1089 1
    return Qtrue;
d1093 1
a1093 1
rb_ary_hash(ary)
d1100 1
a1100 2
	int n = rb_hash(RARRAY(ary)->ptr[i]);
	h ^= NUM2LONG(n);
d1106 1
a1106 1
rb_ary_includes(ary, item)
d1113 1
a1113 1
	    return Qtrue;
d1116 1
a1116 1
    return Qfalse;
d1119 2
a1120 2
static VALUE
rb_ary_cmp(ary, ary2)
d1144 1
a1144 1
rb_ary_diff(ary1, ary2)
d1151 1
a1151 1
    ary3 = rb_ary_new();
d1153 3
a1155 3
	if (rb_ary_includes(ary2, RARRAY(ary1)->ptr[i])) continue;
	if (rb_ary_includes(ary3, RARRAY(ary1)->ptr[i])) continue;
	rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1161 1
a1161 1
rb_ary_and(ary1, ary2)
d1168 1
a1168 1
    ary3 = rb_ary_new();
d1170 3
a1172 3
	if (rb_ary_includes(ary2, RARRAY(ary1)->ptr[i])
	    && !rb_ary_includes(ary3, RARRAY(ary1)->ptr[i])) {
	    rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1179 1
a1179 1
rb_ary_or(ary1, ary2)
d1186 2
a1187 2
	if (rb_ary_includes(ary1, ary2)) return ary1;
	else return rb_ary_plus(ary1, ary2);
d1190 1
a1190 1
    ary3 = rb_ary_new();
d1192 2
a1193 2
	if (!rb_ary_includes(ary3, RARRAY(ary1)->ptr[i]))
		rb_ary_push(ary3, RARRAY(ary1)->ptr[i]);
d1196 2
a1197 2
	if (!rb_ary_includes(ary3, RARRAY(ary2)->ptr[i]))
		rb_ary_push(ary3, RARRAY(ary2)->ptr[i]);
d1203 1
a1203 1
rb_ary_uniq_bang(ary)
d1209 1
a1209 1
    rb_ary_modify(ary);
d1232 1
a1232 1
rb_ary_uniq(ary)
d1235 1
a1235 1
    VALUE v = rb_ary_uniq_bang(rb_ary_dup(ary));
d1242 1
a1242 1
rb_ary_compact_bang(ary)
d1247 1
a1247 1
    rb_ary_modify(ary);
d1264 1
a1264 1
rb_ary_compact(ary)
d1267 1
a1267 1
    VALUE v = rb_ary_compact_bang(rb_ary_dup(ary));
d1274 1
a1274 1
rb_ary_nitems(ary)
d1290 1
a1290 1
rb_ary_flatten_bang(ary)
d1296 1
a1296 1
    rb_ary_modify(ary);
d1300 1
a1300 1
	    rb_ary_replace(ary, i--, 1, ary2);
d1309 1
a1309 1
rb_ary_flatten(ary)
d1312 1
a1312 1
    VALUE v = rb_ary_flatten_bang(rb_ary_dup(ary));
d1321 2
a1322 2
    rb_cArray  = rb_define_class("Array", rb_cObject);
    rb_include_module(rb_cArray, rb_mEnumerable);
d1324 67
a1390 67
    rb_define_singleton_method(rb_cArray, "new", rb_ary_s_new, -1);
    rb_define_singleton_method(rb_cArray, "[]", rb_ary_s_create, -1);
    rb_define_method(rb_cArray, "to_s", rb_ary_to_s, 0);
    rb_define_method(rb_cArray, "inspect", rb_ary_inspect, 0);
    rb_define_method(rb_cArray, "to_a", rb_ary_to_a, 0);
    rb_define_method(rb_cArray, "to_ary", rb_ary_to_a, 0);

    rb_define_method(rb_cArray, "freeze",  rb_ary_freeze, 0);
    rb_define_method(rb_cArray, "frozen?",  rb_ary_frozen_p, 0);

    rb_define_method(rb_cArray, "==", rb_ary_equal, 1);
    rb_define_method(rb_cArray, "eql?", rb_ary_eql, 1);
    rb_define_method(rb_cArray, "hash", rb_ary_hash, 0);

    rb_define_method(rb_cArray, "[]", rb_ary_aref, -1);
    rb_define_method(rb_cArray, "[]=", rb_ary_aset, -1);
    rb_define_method(rb_cArray, "concat", rb_ary_concat, 1);
    rb_define_method(rb_cArray, "<<", rb_ary_push, 1);
    rb_define_method(rb_cArray, "push", rb_ary_push_method, -1);
    rb_define_method(rb_cArray, "pop", rb_ary_pop, 0);
    rb_define_method(rb_cArray, "shift", rb_ary_shift, 0);
    rb_define_method(rb_cArray, "unshift", rb_ary_unshift, 1);
    rb_define_method(rb_cArray, "each", rb_ary_each, 0);
    rb_define_method(rb_cArray, "each_index", rb_ary_each_index, 0);
    rb_define_method(rb_cArray, "reverse_each", rb_ary_reverse_each, 0);
    rb_define_method(rb_cArray, "length", rb_ary_length, 0);
    rb_define_alias(rb_cArray,  "size", "length");
    rb_define_method(rb_cArray, "empty?", rb_ary_empty_p, 0);
    rb_define_method(rb_cArray, "index", rb_ary_index, 1);
    rb_define_method(rb_cArray, "rindex", rb_ary_rindex, 1);
    rb_define_method(rb_cArray, "indexes", rb_ary_indexes, -1);
    rb_define_method(rb_cArray, "indices", rb_ary_indexes, -1);
    rb_define_method(rb_cArray, "clone", rb_ary_clone, 0);
    rb_define_method(rb_cArray, "dup", rb_ary_dup, 0);
    rb_define_method(rb_cArray, "join", rb_ary_join_method, -1);
    rb_define_method(rb_cArray, "reverse", rb_ary_reverse_method, 0);
    rb_define_method(rb_cArray, "reverse!", rb_ary_reverse, 0);
    rb_define_method(rb_cArray, "sort", rb_ary_sort, 0);
    rb_define_method(rb_cArray, "sort!", rb_ary_sort_bang, 0);
    rb_define_method(rb_cArray, "delete", rb_ary_delete, 1);
    rb_define_method(rb_cArray, "delete_at", rb_ary_delete_at, 1);
    rb_define_method(rb_cArray, "delete_if", rb_ary_delete_if, 0);
    rb_define_method(rb_cArray, "filter", rb_ary_filter, 0);
    rb_define_method(rb_cArray, "replace", rb_ary_replace_method, 1);
    rb_define_method(rb_cArray, "clear", rb_ary_clear, 0);
    rb_define_method(rb_cArray, "fill", rb_ary_fill, -1);
    rb_define_method(rb_cArray, "include?", rb_ary_includes, 1);
    rb_define_method(rb_cArray, "===", rb_ary_includes, 1);
    rb_define_method(rb_cArray, "<=>", rb_ary_cmp, 1);

    rb_define_method(rb_cArray, "assoc", rb_ary_assoc, 1);
    rb_define_method(rb_cArray, "rassoc", rb_ary_rassoc, 1);

    rb_define_method(rb_cArray, "+", rb_ary_plus, 1);
    rb_define_method(rb_cArray, "*", rb_ary_times, 1);

    rb_define_method(rb_cArray, "-", rb_ary_diff, 1);
    rb_define_method(rb_cArray, "&", rb_ary_and, 1);
    rb_define_method(rb_cArray, "|", rb_ary_or, 1);

    rb_define_method(rb_cArray, "uniq", rb_ary_uniq, 0);
    rb_define_method(rb_cArray, "uniq!", rb_ary_uniq_bang, 0);
    rb_define_method(rb_cArray, "compact", rb_ary_compact, 0);
    rb_define_method(rb_cArray, "compact!", rb_ary_compact_bang, 0);
    rb_define_method(rb_cArray, "flatten", rb_ary_flatten, 0);
    rb_define_method(rb_cArray, "flatten!", rb_ary_flatten_bang, 0);
    rb_define_method(rb_cArray, "nitems", rb_ary_nitems, 0);
@


1.1.1.2.2.29.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/09/08 07:08:30 $
a13 1
#include "util.h"
d47 1
@


1.1.1.2.2.29.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:48 $
d48 1
a48 1
    if (FL_TEST(ary, ARY_FREEZE|ARY_TMPLOCK))
d50 1
a50 2
    if (rb_safe_level() >= 4 && !FL_TEST(ary, FL_TAINT))
	rb_raise(rb_eSecurityError, "Insecure: can't modify array");
d119 1
a119 1
	rb_raise(rb_eIndexError, "negative number of items(%d)", n);
d229 1
a229 4
	idx = RARRAY(ary)->len + idx;
	if (idx < 0) {
	    rb_raise(rb_eIndexError, "negative index of array");
	}
d342 8
a349 1
    if (len <= 0) {
a351 4
    if (beg < 0) {
	len += beg;
	beg = 0;
    }
a372 1
    int b, e;
d375 4
a378 1
    b = beg; e = end;
d382 1
a383 7
    if (end < 0) {
	end = len + end;
    }
    if (beg > end) {
	rb_raise(rb_eIndexError, "end smaller than beg [%d..%d]", b, e);
    }

d389 10
a398 2
	len = end - beg +1;
	*lenp = len;
d415 2
a416 2
	if (beg < 0) {
	    beg = RARRAY(ary)->len + beg;
d485 1
a485 4
    if (len < 0) {
	rb_raise(rb_eIndexError, "negative length %d", len);
    }

a488 4

    if (beg + len < 0 || (beg < 0 && beg <= -len)) {
	rb_raise(rb_eIndexError, "index %d out of range", beg);
    }
d490 2
a491 2
	len += beg;
	beg = 0;
a492 2

    rb_ary_modify(ary);
d509 3
a540 4

	if (beg < 0) {
	    beg = RARRAY(ary)->len + beg;
	}
d559 3
d680 1
a680 1
	if (rb_obj_tainted(tmp)) rb_obj_taint(result);
a1355 1
    rb_define_method(rb_cArray, "===", rb_ary_equal, 1);
d1390 1
@
