head	1.224;
access;
symbols
	v1_6_7:1.74.2.42
	v1_6_6:1.74.2.31
	v1_6_5:1.74.2.15
	v1_6_4:1.74.2.12
	v1_7_1:1.102
	v1_6_4_preview4:1.74.2.12
	v1_6_4_preview3:1.74.2.12
	v1_6_4_preview2:1.74.2.10
	v1_6_4_preview1:1.74.2.9
	v1_6_3:1.74.2.8
	ruby_m17n:1.77.0.2
	ruby_1_6:1.74.0.2
	v1_6_2:1.74
	v1_6_1:1.60
	v1_6_0:1.53
	v1_4_6:1.6.2.14
	v1_4_5:1.6.2.11
	v1_4_4:1.6.2.6
	ruby_1_4_3:1.6
	ruby1_4_3:1.6
	v1_4_3:1.6
	v1_5_0:1.10
	ruby_1_4_3_pre1:1.6
	ruby_1_4:1.6.0.2
	v1_4_2:1.4
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.28
	v1_3_6_repack:1.1.1.3.2.28
	v1_3_6:1.1.1.3.2.28
	v1_3_5:1.1.1.3.2.27
	v1_2_6repack:1.1.1.2.2.62
	v1_3_4_990625:1.1.1.3.2.26
	v1_3_4_990624:1.1.1.3.2.25
	v1_2_6:1.1.1.2.2.62
	v1_3_4_990611:1.1.1.3.2.24
	v1_3_4_990531:1.1.1.3.2.22
	v1_3_3_990518:1.1.1.3.2.20
	v1_3_3_990513:1.1.1.3.2.19
	v1_3_3_990507:1.1.1.3.2.19
	v1_2_5:1.1.1.2.2.60
	v1_2_4:1.1.1.2.2.58
	v1_3_1_990225:1.1.1.3.2.10
	v1_3_1_990224:1.1.1.3.2.9
	v1_3_1_990215:1.1.1.3.2.8
	v1_3_1_990212:1.1.1.3.2.8
	v1_3_1_990210:1.1.1.3.2.7
	v1_3_1_:1.1.1.3.2.7
	v1_3_1_990209:1.1.1.3.2.5
	v1_3_1_990205:1.1.1.3.2.4
	v1_3_1_990203:1.1.1.3.2.3
	v1_3_1_990201:1.1.1.3.2.2
	v1_3_1"_990201:1.1.1.3.2.2
	v1_3_1_990128:1.1.1.3.2.1
	v1_3_1_990127:1.1.1.3.2.1
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.56
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.55
	v1_2_1repack:1.1.1.2.2.54
	v1_2_1:1.1.1.2.2.54
	v1_2_stable:1.1.1.2.2.54
	v1_1d1:1.1.1.2.2.50.2.5
	v1_1d0:1.1.1.2.2.50.2.4
	v1_1c9_1:1.1.1.2.2.54
	v1_1c9:1.1.1.2.2.54
	v1_1c8:1.1.1.2.2.53
	v1_1c7:1.1.1.2.2.52
	v1_1c6:1.1.1.2.2.51
	v1_1d-start:1.1.1.2.2.50.2.1
	v1_1c5:1.1.1.2.2.50
	v1_1dev:1.1.1.2.2.50.0.2
	v1_1c4:1.1.1.2.2.50
	v1_1c3:1.1.1.2.2.50
	v1_1c2:1.1.1.2.2.49
	v1_1c1:1.1.1.2.2.49
	v1_1c0:1.1.1.2.2.49
	v1_1b9_31:1.1.1.2.2.49
	v1_1b9_30:1.1.1.2.2.48
	v1_1b9_28:1.1.1.2.2.47
	v1_1b9_27:1.1.1.2.2.43
	v1_1b9_26:1.1.1.2.2.42
	r1_1b9_25:1.1.1.2.2.39
	r1_1b9_24:1.1.1.2.2.38
	v1_1b9_23:1.1.1.2.2.37
	v1_1b9_22:1.1.1.2.2.34
	v1_1b9_20:1.1.1.2.2.32
	v1_1b9_18:1.1.1.2.2.31
	v1_1b9_16:1.1.1.2.2.30
	v1_1b9_15:1.1.1.2.2.30
	v1_1b9_13:1.1.1.2.2.29
	v1_1b9_12:1.1.1.2.2.28
	v1_1b9_11:1.1.1.2.2.28
	v1_1b9_08:1.1.1.2.2.25
	v1_1b9_07:1.1.1.2.2.25
	r1_1b9:1.1.1.2.2.14
	v1_1b8:1.1.1.2.2.10
	v1_1b7:1.1.1.2.2.6
	v1_1b6:1.1.1.2.2.4
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.224
date	2002.10.23.10.17.29;	author nobu;	state Exp;
branches;
next	1.223;

1.223
date	2002.10.18.14.13.41;	author nobu;	state Exp;
branches;
next	1.222;

1.222
date	2002.10.17.07.26.59;	author matz;	state Exp;
branches;
next	1.221;

1.221
date	2002.09.27.04.26.21;	author matz;	state Exp;
branches;
next	1.220;

1.220
date	2002.09.25.07.03.01;	author matz;	state Exp;
branches;
next	1.219;

1.219
date	2002.09.23.15.48.42;	author nobu;	state Exp;
branches;
next	1.218;

1.218
date	2002.09.22.12.52.18;	author nobu;	state Exp;
branches;
next	1.217;

1.217
date	2002.09.20.15.47.06;	author nobu;	state Exp;
branches;
next	1.216;

1.216
date	2002.09.20.14.03.45;	author nobu;	state Exp;
branches;
next	1.215;

1.215
date	2002.09.13.09.36.28;	author nobu;	state Exp;
branches;
next	1.214;

1.214
date	2002.09.10.14.38.20;	author nobu;	state Exp;
branches;
next	1.213;

1.213
date	2002.09.06.23.39.02;	author aamine;	state Exp;
branches;
next	1.212;

1.212
date	2002.09.06.03.09.07;	author aamine;	state Exp;
branches;
next	1.211;

1.211
date	2002.09.06.02.44.51;	author aamine;	state Exp;
branches;
next	1.210;

1.210
date	2002.09.06.01.24.41;	author aamine;	state Exp;
branches;
next	1.209;

1.209
date	2002.09.05.20.00.52;	author aamine;	state Exp;
branches;
next	1.208;

1.208
date	2002.09.04.06.37.35;	author matz;	state Exp;
branches;
next	1.207;

1.207
date	2002.09.02.12.19.30;	author aamine;	state Exp;
branches;
next	1.206;

1.206
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.205;

1.205
date	2002.08.15.11.49.39;	author nobu;	state Exp;
branches;
next	1.204;

1.204
date	2002.08.01.09.42.36;	author matz;	state Exp;
branches;
next	1.203;

1.203
date	2002.07.26.06.12.38;	author matz;	state Exp;
branches;
next	1.202;

1.202
date	2002.07.26.03.13.06;	author aamine;	state Exp;
branches;
next	1.201;

1.201
date	2002.07.17.21.49.40;	author aamine;	state Exp;
branches;
next	1.200;

1.200
date	2002.07.15.01.33.36;	author aamine;	state Exp;
branches;
next	1.199;

1.199
date	2002.07.13.00.32.46;	author nobu;	state Exp;
branches;
next	1.198;

1.198
date	2002.07.04.14.41.36;	author aamine;	state Exp;
branches;
next	1.197;

1.197
date	2002.07.02.09.58.13;	author michal;	state Exp;
branches;
next	1.196;

1.196
date	2002.06.28.14.39.59;	author matz;	state Exp;
branches;
next	1.195;

1.195
date	2002.06.27.17.16.39;	author nobu;	state Exp;
branches;
next	1.194;

1.194
date	2002.06.26.23.29.10;	author nobu;	state Exp;
branches;
next	1.193;

1.193
date	2002.06.26.08.00.55;	author nobu;	state Exp;
branches;
next	1.192;

1.192
date	2002.06.25.09.56.36;	author nobu;	state Exp;
branches;
next	1.191;

1.191
date	2002.06.24.15.18.00;	author nobu;	state Exp;
branches;
next	1.190;

1.190
date	2002.06.24.07.59.00;	author matz;	state Exp;
branches;
next	1.189;

1.189
date	2002.06.24.07.20.42;	author nobu;	state Exp;
branches;
next	1.188;

1.188
date	2002.06.18.15.53.57;	author nobu;	state Exp;
branches;
next	1.187;

1.187
date	2002.06.18.15.46.24;	author nobu;	state Exp;
branches;
next	1.186;

1.186
date	2002.06.18.06.29.04;	author matz;	state Exp;
branches;
next	1.185;

1.185
date	2002.06.18.03.53.23;	author nobu;	state Exp;
branches;
next	1.184;

1.184
date	2002.06.14.06.27.18;	author nobu;	state Exp;
branches;
next	1.183;

1.183
date	2002.06.13.03.55.44;	author matz;	state Exp;
branches;
next	1.182;

1.182
date	2002.06.12.09.22.20;	author matz;	state Exp;
branches;
next	1.181;

1.181
date	2002.06.11.17.39.38;	author nobu;	state Exp;
branches;
next	1.180;

1.180
date	2002.06.11.07.26.03;	author eban;	state Exp;
branches;
next	1.179;

1.179
date	2002.06.11.07.01.13;	author matz;	state Exp;
branches;
next	1.178;

1.178
date	2002.06.10.10.06.12;	author nobu;	state Exp;
branches;
next	1.177;

1.177
date	2002.06.05.06.10.57;	author michal;	state Exp;
branches;
next	1.176;

1.176
date	2002.06.04.07.34.14;	author matz;	state Exp;
branches;
next	1.175;

1.175
date	2002.06.02.22.16.54;	author nobu;	state Exp;
branches;
next	1.174;

1.174
date	2002.05.29.05.20.33;	author matz;	state Exp;
branches;
next	1.173;

1.173
date	2002.05.28.18.11.07;	author michal;	state Exp;
branches;
next	1.172;

1.172
date	2002.05.22.09.37.45;	author aamine;	state Exp;
branches;
next	1.171;

1.171
date	2002.05.20.16.22.23;	author nobu;	state Exp;
branches;
next	1.170;

1.170
date	2002.05.14.06.22.26;	author matz;	state Exp;
branches;
next	1.169;

1.169
date	2002.05.10.10.05.30;	author nobu;	state Exp;
branches;
next	1.168;

1.168
date	2002.04.25.13.55.58;	author matz;	state Exp;
branches;
next	1.167;

1.167
date	2002.04.24.04.54.14;	author matz;	state Exp;
branches;
next	1.166;

1.166
date	2002.04.19.04.14.07;	author matz;	state Exp;
branches;
next	1.165;

1.165
date	2002.04.11.10.02.59;	author matz;	state Exp;
branches;
next	1.164;

1.164
date	2002.03.26.06.18.49;	author matz;	state Exp;
branches;
next	1.163;

1.163
date	2002.03.20.10.21.23;	author nobu;	state Exp;
branches;
next	1.162;

1.162
date	2002.03.20.09.43.15;	author matz;	state Exp;
branches;
next	1.161;

1.161
date	2002.03.19.09.03.07;	author matz;	state Exp;
branches;
next	1.160;

1.160
date	2002.03.18.02.04.22;	author nobu;	state Exp;
branches;
next	1.159;

1.159
date	2002.03.12.09.28.48;	author matz;	state Exp;
branches;
next	1.158;

1.158
date	2002.03.08.07.03.03;	author matz;	state Exp;
branches;
next	1.157;

1.157
date	2002.03.07.11.19.37;	author nobu;	state Exp;
branches;
next	1.156;

1.156
date	2002.02.20.04.31.50;	author matz;	state Exp;
branches;
next	1.155;

1.155
date	2002.02.19.05.39.06;	author matz;	state Exp;
branches;
next	1.154;

1.154
date	2002.02.18.09.52.45;	author matz;	state Exp;
branches;
next	1.153;

1.153
date	2002.02.14.08.47.58;	author nobu;	state Exp;
branches;
next	1.152;

1.152
date	2002.02.14.07.49.27;	author matz;	state Exp;
branches;
next	1.151;

1.151
date	2002.02.13.16.39.37;	author matz;	state Exp;
branches;
next	1.150;

1.150
date	2002.02.13.09.01.09;	author matz;	state Exp;
branches;
next	1.149;

1.149
date	2002.02.09.14.44.20;	author matz;	state Exp;
branches;
next	1.148;

1.148
date	2002.02.08.05.19.47;	author matz;	state Exp;
branches;
next	1.147;

1.147
date	2002.02.01.10.23.22;	author nobu;	state Exp;
branches;
next	1.146;

1.146
date	2002.01.28.09.33.56;	author nobu;	state Exp;
branches;
next	1.145;

1.145
date	2002.01.28.08.44.37;	author matz;	state Exp;
branches;
next	1.144;

1.144
date	2002.01.21.07.44.06;	author matz;	state Exp;
branches;
next	1.143;

1.143
date	2002.01.18.14.23.07;	author matz;	state Exp;
branches;
next	1.142;

1.142
date	2002.01.16.09.25.54;	author matz;	state Exp;
branches;
next	1.141;

1.141
date	2002.01.11.09.18.50;	author matz;	state Exp;
branches;
next	1.140;

1.140
date	2002.01.04.15.20.48;	author nobu;	state Exp;
branches;
next	1.139;

1.139
date	2002.01.04.14.14.34;	author matz;	state Exp;
branches;
next	1.138;

1.138
date	2001.12.31.05.23.53;	author nobu;	state Exp;
branches;
next	1.137;

1.137
date	2001.12.22.02.51.00;	author matz;	state Exp;
branches;
next	1.136;

1.136
date	2001.12.11.03.48.08;	author matz;	state Exp;
branches;
next	1.135;

1.135
date	2001.12.10.07.18.12;	author matz;	state Exp;
branches;
next	1.134;

1.134
date	2001.11.25.12.09.21;	author usa;	state Exp;
branches;
next	1.133;

1.133
date	2001.11.21.15.41.26;	author matz;	state Exp;
branches;
next	1.132;

1.132
date	2001.11.19.16.20.06;	author matz;	state Exp;
branches;
next	1.131;

1.131
date	2001.11.19.14.42.45;	author matz;	state Exp;
branches;
next	1.130;

1.130
date	2001.11.18.10.49.28;	author nobu;	state Exp;
branches;
next	1.129;

1.129
date	2001.11.13.08.19.52;	author matz;	state Exp;
branches;
next	1.128;

1.128
date	2001.11.08.06.43.08;	author matz;	state Exp;
branches;
next	1.127;

1.127
date	2001.10.30.08.43.25;	author matz;	state Exp;
branches;
next	1.126;

1.126
date	2001.10.29.05.07.18;	author matz;	state Exp;
branches;
next	1.125;

1.125
date	2001.10.15.15.11.51;	author nobu;	state Exp;
branches;
next	1.124;

1.124
date	2001.10.10.08.21.13;	author matz;	state Exp;
branches;
next	1.123;

1.123
date	2001.10.02.04.31.19;	author matz;	state Exp;
branches;
next	1.122;

1.122
date	2001.09.26.17.09.47;	author ts;	state Exp;
branches;
next	1.121;

1.121
date	2001.09.20.06.23.50;	author nobu;	state Exp;
branches;
next	1.120;

1.120
date	2001.09.19.06.54.10;	author matz;	state Exp;
branches;
next	1.119;

1.119
date	2001.09.05.06.54.53;	author matz;	state Exp;
branches;
next	1.118;

1.118
date	2001.08.29.06.28.44;	author matz;	state Exp;
branches;
next	1.117;

1.117
date	2001.08.23.06.02.15;	author matz;	state Exp;
branches;
next	1.116;

1.116
date	2001.08.20.06.15.53;	author matz;	state Exp;
branches;
next	1.115;

1.115
date	2001.08.20.04.29.56;	author matz;	state Exp;
branches;
next	1.114;

1.114
date	2001.08.14.08.13.26;	author matz;	state Exp;
branches;
next	1.113;

1.113
date	2001.08.06.03.05.13;	author matz;	state Exp;
branches;
next	1.112;

1.112
date	2001.07.02.08.46.21;	author matz;	state Exp;
branches;
next	1.111;

1.111
date	2001.06.23.15.14.14;	author matz;	state Exp;
branches;
next	1.110;

1.110
date	2001.06.22.09.12.20;	author matz;	state Exp;
branches;
next	1.109;

1.109
date	2001.06.08.14.20.20;	author matz;	state Exp;
branches;
next	1.108;

1.108
date	2001.06.07.08.40.54;	author matz;	state Exp;
branches;
next	1.107;

1.107
date	2001.06.07.08.29.59;	author matz;	state Exp;
branches;
next	1.106;

1.106
date	2001.06.06.07.40.31;	author matz;	state Exp;
branches;
next	1.105;

1.105
date	2001.06.06.06.42.21;	author matz;	state Exp;
branches;
next	1.104;

1.104
date	2001.06.05.07.50.59;	author matz;	state Exp;
branches;
next	1.103;

1.103
date	2001.06.05.07.19.38;	author matz;	state Exp;
branches;
next	1.102;

1.102
date	2001.06.01.07.52.34;	author matz;	state Exp;
branches;
next	1.101;

1.101
date	2001.06.01.06.47.30;	author matz;	state Exp;
branches;
next	1.100;

1.100
date	2001.05.30.09.12.34;	author matz;	state Exp;
branches;
next	1.99;

1.99
date	2001.05.24.06.10.32;	author matz;	state Exp;
branches;
next	1.98;

1.98
date	2001.05.22.08.28.11;	author matz;	state Exp;
branches;
next	1.97;

1.97
date	2001.05.21.04.22.54;	author matz;	state Exp;
branches;
next	1.96;

1.96
date	2001.05.16.09.05.50;	author matz;	state Exp;
branches;
next	1.95;

1.95
date	2001.05.07.09.26.24;	author matz;	state Exp;
branches;
next	1.94;

1.94
date	2001.05.02.04.22.11;	author matz;	state Exp;
branches;
next	1.93;

1.93
date	2001.03.13.09.00.01;	author matz;	state Exp;
branches;
next	1.92;

1.92
date	2001.03.13.06.00.50;	author eban;	state Exp;
branches;
next	1.91;

1.91
date	2001.03.13.05.45.09;	author matz;	state Exp;
branches;
next	1.90;

1.90
date	2001.03.06.08.17.16;	author matz;	state Exp;
branches;
next	1.89;

1.89
date	2001.02.26.05.29.00;	author matz;	state Exp;
branches;
next	1.88;

1.88
date	2001.02.19.07.03.06;	author matz;	state Exp;
branches;
next	1.87;

1.87
date	2001.02.13.05.08.59;	author matz;	state Exp;
branches;
next	1.86;

1.86
date	2001.02.08.09.19.17;	author matz;	state Exp;
branches;
next	1.85;

1.85
date	2001.02.02.11.38.10;	author matz;	state Exp;
branches;
next	1.84;

1.84
date	2001.01.29.05.10.42;	author matz;	state Exp;
branches;
next	1.83;

1.83
date	2001.01.26.05.02.17;	author matz;	state Exp;
branches;
next	1.82;

1.82
date	2001.01.23.08.08.59;	author matz;	state Exp;
branches;
next	1.81;

1.81
date	2001.01.20.14.02.28;	author matz;	state Exp;
branches;
next	1.80;

1.80
date	2001.01.19.19.00.07;	author matz;	state Exp;
branches;
next	1.79;

1.79
date	2001.01.10.10.07.31;	author matz;	state Exp;
branches;
next	1.78;

1.78
date	2001.01.09.07.26.17;	author matz;	state Exp;
branches;
next	1.77;

1.77
date	2000.12.28.05.00.39;	author matz;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2000.12.27.05.59.03;	author matz;	state Exp;
branches;
next	1.75;

1.75
date	2000.12.26.08.08.50;	author matz;	state Exp;
branches;
next	1.74;

1.74
date	2000.12.25.06.29.05;	author matz;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2000.12.22.03.22.02;	author matz;	state Exp;
branches;
next	1.72;

1.72
date	2000.12.18.09.46.05;	author matz;	state Exp;
branches;
next	1.71;

1.71
date	2000.12.12.07.42.28;	author matz;	state Exp;
branches;
next	1.70;

1.70
date	2000.12.05.09.36.34;	author matz;	state Exp;
branches;
next	1.69;

1.69
date	2000.11.27.09.23.22;	author matz;	state Exp;
branches;
next	1.68;

1.68
date	2000.11.21.14.26.23;	author matz;	state Exp;
branches;
next	1.67;

1.67
date	2000.11.13.05.39.34;	author matz;	state Exp;
branches;
next	1.66;

1.66
date	2000.11.10.07.16.50;	author matz;	state Exp;
branches;
next	1.65;

1.65
date	2000.10.31.08.37.39;	author matz;	state Exp;
branches;
next	1.64;

1.64
date	2000.10.20.16.36.53;	author matz;	state Exp;
branches;
next	1.63;

1.63
date	2000.10.16.09.13.20;	author matz;	state Exp;
branches;
next	1.62;

1.62
date	2000.10.11.06.29.07;	author matz;	state Exp;
branches;
next	1.61;

1.61
date	2000.10.10.07.03.21;	author matz;	state Exp;
branches;
next	1.60;

1.60
date	2000.09.22.18.15.44;	author matz;	state Exp;
branches;
next	1.59;

1.59
date	2000.09.19.07.54.22;	author matz;	state Exp;
branches;
next	1.58;

1.58
date	2000.09.18.08.47.09;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2000.09.15.06.00.26;	author matz;	state Exp;
branches;
next	1.56;

1.56
date	2000.09.12.05.37.24;	author matz;	state Exp;
branches;
next	1.55;

1.55
date	2000.09.04.08.24.02;	author matz;	state Exp;
branches;
next	1.54;

1.54
date	2000.09.01.09.18.11;	author matz;	state Exp;
branches;
next	1.53;

1.53
date	2000.08.31.05.29.47;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2000.08.30.05.20.36;	author matz;	state Exp;
branches;
next	1.51;

1.51
date	2000.08.29.07.29.48;	author matz;	state Exp;
branches;
next	1.50;

1.50
date	2000.08.29.02.52.34;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2000.08.28.09.53.29;	author matz;	state Exp;
branches;
next	1.48;

1.48
date	2000.08.02.04.54.14;	author matz;	state Exp;
branches;
next	1.47;

1.47
date	2000.07.27.09.49.21;	author matz;	state Exp;
branches;
next	1.46;

1.46
date	2000.07.21.08.45.32;	author matz;	state Exp;
branches;
next	1.45;

1.45
date	2000.07.18.06.00.36;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2000.07.12.06.06.47;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2000.07.11.08.27.06;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2000.07.07.03.20.51;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2000.07.04.04.17.13;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.03.05.46.36;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2000.07.01.06.51.28;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2000.07.01.06.46.35;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.23.07.01.26;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.05.08.46.51;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2000.05.30.04.24.01;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2000.05.25.05.55.05;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2000.05.24.04.34.04;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2000.05.22.07.29.50;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.18.04.32.06;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.17.06.33.46;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.05.17.04.38.13;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2000.05.12.09.07.43;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.05.09.04.53.01;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.05.01.09.41.25;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.10.05.44.16;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.23.08.37.29;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.13.07.18.37;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.09.08.59.54;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.08.06.23.16;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.07.08.37.42;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.26.01.16.48;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.18.06.59.33;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.02.17.07.11.13;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.08.08.48.50;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.01.03.12.10;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.17.08.37.44;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.08.05.00.20;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.05.04.37.08;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	99.12.14.06.49.47;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	99.11.17.07.30.34;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	99.11.10.06.47.08;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.10.15.08.52.16;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.10.13.06.44.41;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.10.12.04.53.33;	author matz;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.10.04.04.51.05;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.09.16.16.11.25;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.09.16.09.40.32;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.09;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.11;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.24;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.13;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.01.07.34.56;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.03.09.47.59;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.02.05.10.27.32;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.02.09.06.08.22;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.02.09.08.10.57;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.02.10.08.44.27;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.02.12.11.17.05;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.02.24.04.31.23;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.02.25.06.39.08;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.03.24.08.52.30;	author matz;	state Exp;
branches;
next	1.1.1.3.2.12;

1.1.1.3.2.12
date	99.04.09.17.57.41;	author matz;	state Exp;
branches;
next	1.1.1.3.2.13;

1.1.1.3.2.13
date	99.04.12.09.59.31;	author matz;	state Exp;
branches;
next	1.1.1.3.2.14;

1.1.1.3.2.14
date	99.04.13.05.12.04;	author matz;	state Exp;
branches;
next	1.1.1.3.2.15;

1.1.1.3.2.15
date	99.04.20.08.21.39;	author matz;	state Exp;
branches;
next	1.1.1.3.2.16;

1.1.1.3.2.16
date	99.04.26.09.42.39;	author matz;	state Exp;
branches;
next	1.1.1.3.2.17;

1.1.1.3.2.17
date	99.04.27.07.03.31;	author matz;	state Exp;
branches;
next	1.1.1.3.2.18;

1.1.1.3.2.18
date	99.04.27.07.11.46;	author matz;	state Exp;
branches;
next	1.1.1.3.2.19;

1.1.1.3.2.19
date	99.05.06.08.31.40;	author matz;	state Exp;
branches;
next	1.1.1.3.2.20;

1.1.1.3.2.20
date	99.05.17.09.54.12;	author matz;	state Exp;
branches;
next	1.1.1.3.2.21;

1.1.1.3.2.21
date	99.05.25.08.26.10;	author matz;	state Exp;
branches;
next	1.1.1.3.2.22;

1.1.1.3.2.22
date	99.05.31.09.13.22;	author matz;	state Exp;
branches;
next	1.1.1.3.2.23;

1.1.1.3.2.23
date	99.06.01.06.59.15;	author matz;	state Exp;
branches;
next	1.1.1.3.2.24;

1.1.1.3.2.24
date	99.06.09.09.21.26;	author matz;	state Exp;
branches;
next	1.1.1.3.2.25;

1.1.1.3.2.25
date	99.06.24.04.23.57;	author matz;	state Exp;
branches;
next	1.1.1.3.2.26;

1.1.1.3.2.26
date	99.06.25.09.02.42;	author matz;	state Exp;
branches;
next	1.1.1.3.2.27;

1.1.1.3.2.27
date	99.07.15.07.59.48;	author matz;	state Exp;
branches;
next	1.1.1.3.2.28;

1.1.1.3.2.28
date	99.07.28.09.26.43;	author matz;	state Exp;
branches;
next	1.1.1.3.2.29;

1.1.1.3.2.29
date	99.08.11.07.24.03;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.20.06.10.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.01.21.06.34.30;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.01.22.07.57.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.02.02.04.49.12;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.02.09.10.56.22;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.02.13.09.40.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.02.18.01.56.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.02.20.02.10.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.02.20.08.28.45;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.02.24.03.55.01;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.02.25.06.52.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.02.26.07.43.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.02.26.08.22.02;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.03.05.06.37.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.03.06.10.07.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.03.09.07.56.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.03.11.09.19.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.03.11.09.27.52;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.03.12.01.15.17;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.03.19.06.22.54;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.03.19.06.25.33;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.03.25.09.36.58;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.04.02.10.05.16;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	98.04.07.08.34.09;	author matz;	state Exp;
branches;
next	1.1.1.2.2.26;

1.1.1.2.2.26
date	98.04.09.09.30.21;	author matz;	state Exp;
branches;
next	1.1.1.2.2.27;

1.1.1.2.2.27
date	98.04.14.04.55.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.28;

1.1.1.2.2.28
date	98.04.16.07.42.45;	author matz;	state Exp;
branches;
next	1.1.1.2.2.29;

1.1.1.2.2.29
date	98.04.21.08.41.06;	author matz;	state Exp;
branches;
next	1.1.1.2.2.30;

1.1.1.2.2.30
date	98.04.24.09.33.17;	author matz;	state Exp;
branches;
next	1.1.1.2.2.31;

1.1.1.2.2.31
date	98.04.30.07.41.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.32;

1.1.1.2.2.32
date	98.05.13.07.26.25;	author matz;	state Exp;
branches;
next	1.1.1.2.2.33;

1.1.1.2.2.33
date	98.05.18.04.56.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.34;

1.1.1.2.2.34
date	98.05.19.07.39.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.35;

1.1.1.2.2.35
date	98.05.25.04.57.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.36;

1.1.1.2.2.36
date	98.05.25.09.42.30;	author matz;	state Exp;
branches;
next	1.1.1.2.2.37;

1.1.1.2.2.37
date	98.05.26.08.24.45;	author matz;	state Exp;
branches;
next	1.1.1.2.2.38;

1.1.1.2.2.38
date	98.05.27.09.31.52;	author matz;	state Exp;
branches;
next	1.1.1.2.2.39;

1.1.1.2.2.39
date	98.06.11.10.03.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.40;

1.1.1.2.2.40
date	98.06.12.09.35.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.41;

1.1.1.2.2.41
date	98.06.16.04.23.39;	author matz;	state Exp;
branches;
next	1.1.1.2.2.42;

1.1.1.2.2.42
date	98.06.18.07.46.54;	author matz;	state Exp;
branches;
next	1.1.1.2.2.43;

1.1.1.2.2.43
date	98.06.19.09.32.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.44;

1.1.1.2.2.44
date	98.06.22.05.53.21;	author matz;	state Exp;
branches;
next	1.1.1.2.2.45;

1.1.1.2.2.45
date	98.06.23.10.30.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.46;

1.1.1.2.2.46
date	98.06.24.04.38.00;	author matz;	state Exp;
branches;
next	1.1.1.2.2.47;

1.1.1.2.2.47
date	98.06.26.09.44.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.48;

1.1.1.2.2.48
date	98.07.09.08.40.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.49;

1.1.1.2.2.49
date	98.07.15.06.12.52;	author matz;	state Exp;
branches;
next	1.1.1.2.2.50;

1.1.1.2.2.50
date	98.08.27.03.55.22;	author matz;	state Exp;
branches
	1.1.1.2.2.50.2.1;
next	1.1.1.2.2.51;

1.1.1.2.2.51
date	98.10.06.02.44.59;	author matz;	state Exp;
branches;
next	1.1.1.2.2.52;

1.1.1.2.2.52
date	98.11.09.09.11.50;	author matz;	state Exp;
branches;
next	1.1.1.2.2.53;

1.1.1.2.2.53
date	98.11.17.09.12.36;	author matz;	state Exp;
branches;
next	1.1.1.2.2.54;

1.1.1.2.2.54
date	98.11.26.08.25.45;	author matz;	state Exp;
branches;
next	1.1.1.2.2.55;

1.1.1.2.2.55
date	99.01.18.09.08.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.56;

1.1.1.2.2.56
date	99.01.21.09.04.54;	author matz;	state Exp;
branches;
next	1.1.1.2.2.57;

1.1.1.2.2.57
date	99.02.09.03.29.23;	author matz;	state Exp;
branches;
next	1.1.1.2.2.58;

1.1.1.2.2.58
date	99.04.08.10.14.33;	author matz;	state Exp;
branches;
next	1.1.1.2.2.59;

1.1.1.2.2.59
date	99.04.09.18.04.07;	author matz;	state Exp;
branches;
next	1.1.1.2.2.60;

1.1.1.2.2.60
date	99.04.13.05.54.24;	author matz;	state Exp;
branches;
next	1.1.1.2.2.61;

1.1.1.2.2.61
date	99.04.20.08.20.54;	author matz;	state Exp;
branches;
next	1.1.1.2.2.62;

1.1.1.2.2.62
date	99.06.21.06.31.05;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.50.2.1
date	98.09.08.07.08.59;	author matz;	state Exp;
branches;
next	1.1.1.2.2.50.2.2;

1.1.1.2.2.50.2.2
date	98.10.06.03.28.12;	author matz;	state Exp;
branches;
next	1.1.1.2.2.50.2.3;

1.1.1.2.2.50.2.3
date	98.11.25.03.31.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.50.2.4;

1.1.1.2.2.50.2.4
date	98.12.16.07.30.32;	author matz;	state Exp;
branches;
next	1.1.1.2.2.50.2.5;

1.1.1.2.2.50.2.5
date	98.12.22.09.01.52;	author matz;	state Exp;
branches;
next	;

1.6.2.1
date	2000.01.05.04.41.09;	author matz;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.01.17.08.24.07;	author matz;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2000.02.01.03.11.22;	author matz;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2000.02.17.08.28.59;	author matz;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2000.03.08.06.25.12;	author matz;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2000.03.13.09.15.43;	author matz;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2000.05.09.04.50.11;	author matz;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2000.05.12.09.06.11;	author matz;	state Exp;
branches;
next	1.6.2.9;

1.6.2.9
date	2000.05.30.04.21.08;	author matz;	state Exp;
branches;
next	1.6.2.10;

1.6.2.10
date	2000.06.05.09.00.59;	author matz;	state Exp;
branches;
next	1.6.2.11;

1.6.2.11
date	2000.06.23.07.05.56;	author matz;	state Exp;
branches;
next	1.6.2.12;

1.6.2.12
date	2000.07.01.06.47.45;	author matz;	state Exp;
branches;
next	1.6.2.13;

1.6.2.13
date	2000.07.10.08.01.34;	author matz;	state Exp;
branches;
next	1.6.2.14;

1.6.2.14
date	2000.07.24.07.16.10;	author matz;	state Exp;
branches;
next	;

1.74.2.1
date	2001.01.23.09.54.35;	author matz;	state Exp;
branches;
next	1.74.2.2;

1.74.2.2
date	2001.02.02.11.39.51;	author matz;	state Exp;
branches;
next	1.74.2.3;

1.74.2.3
date	2001.02.08.09.17.57;	author matz;	state Exp;
branches;
next	1.74.2.4;

1.74.2.4
date	2001.02.13.05.10.43;	author matz;	state Exp;
branches;
next	1.74.2.5;

1.74.2.5
date	2001.02.19.07.41.24;	author matz;	state Exp;
branches;
next	1.74.2.6;

1.74.2.6
date	2001.02.26.04.07.48;	author matz;	state Exp;
branches;
next	1.74.2.7;

1.74.2.7
date	2001.03.06.08.17.54;	author matz;	state Exp;
branches;
next	1.74.2.8;

1.74.2.8
date	2001.03.13.05.48.33;	author matz;	state Exp;
branches;
next	1.74.2.9;

1.74.2.9
date	2001.04.06.05.42.40;	author matz;	state Exp;
branches;
next	1.74.2.10;

1.74.2.10
date	2001.04.16.06.54.36;	author matz;	state Exp;
branches;
next	1.74.2.11;

1.74.2.11
date	2001.05.01.08.57.59;	author matz;	state Exp;
branches;
next	1.74.2.12;

1.74.2.12
date	2001.05.07.09.24.34;	author matz;	state Exp;
branches;
next	1.74.2.13;

1.74.2.13
date	2001.07.02.08.43.27;	author matz;	state Exp;
branches;
next	1.74.2.14;

1.74.2.14
date	2001.08.17.05.06.31;	author matz;	state Exp;
branches;
next	1.74.2.15;

1.74.2.15
date	2001.09.03.05.29.18;	author matz;	state Exp;
branches;
next	1.74.2.16;

1.74.2.16
date	2001.09.27.07.10.54;	author ts;	state Exp;
branches;
next	1.74.2.17;

1.74.2.17
date	2001.10.02.04.25.52;	author matz;	state Exp;
branches;
next	1.74.2.18;

1.74.2.18
date	2001.10.10.08.23.47;	author matz;	state Exp;
branches;
next	1.74.2.19;

1.74.2.19
date	2001.10.15.15.15.45;	author nobu;	state Exp;
branches;
next	1.74.2.20;

1.74.2.20
date	2001.10.29.05.04.41;	author matz;	state Exp;
branches;
next	1.74.2.21;

1.74.2.21
date	2001.11.07.09.01.31;	author matz;	state Exp;
branches;
next	1.74.2.22;

1.74.2.22
date	2001.11.13.08.22.27;	author matz;	state Exp;
branches;
next	1.74.2.23;

1.74.2.23
date	2001.11.18.10.48.18;	author nobu;	state Exp;
branches;
next	1.74.2.24;

1.74.2.24
date	2001.11.19.14.36.40;	author matz;	state Exp;
branches;
next	1.74.2.25;

1.74.2.25
date	2001.11.19.16.16.13;	author matz;	state Exp;
branches;
next	1.74.2.26;

1.74.2.26
date	2001.11.21.15.35.58;	author matz;	state Exp;
branches;
next	1.74.2.27;

1.74.2.27
date	2001.11.25.12.09.36;	author usa;	state Exp;
branches;
next	1.74.2.28;

1.74.2.28
date	2001.12.10.07.22.50;	author matz;	state Exp;
branches;
next	1.74.2.29;

1.74.2.29
date	2001.12.10.10.06.20;	author eban;	state Exp;
branches;
next	1.74.2.30;

1.74.2.30
date	2001.12.12.09.07.35;	author matz;	state Exp;
branches;
next	1.74.2.31;

1.74.2.31
date	2001.12.25.15.09.05;	author matz;	state Exp;
branches;
next	1.74.2.32;

1.74.2.32
date	2001.12.31.05.26.24;	author nobu;	state Exp;
branches;
next	1.74.2.33;

1.74.2.33
date	2002.01.04.14.19.47;	author matz;	state Exp;
branches;
next	1.74.2.34;

1.74.2.34
date	2002.01.04.15.23.26;	author nobu;	state Exp;
branches;
next	1.74.2.35;

1.74.2.35
date	2002.01.16.09.22.39;	author matz;	state Exp;
branches;
next	1.74.2.36;

1.74.2.36
date	2002.01.21.07.43.40;	author matz;	state Exp;
branches;
next	1.74.2.37;

1.74.2.37
date	2002.01.28.15.14.18;	author nobu;	state Exp;
branches;
next	1.74.2.38;

1.74.2.38
date	2002.02.08.05.20.33;	author matz;	state Exp;
branches;
next	1.74.2.39;

1.74.2.39
date	2002.02.09.14.47.52;	author matz;	state Exp;
branches;
next	1.74.2.40;

1.74.2.40
date	2002.02.13.09.02.15;	author matz;	state Exp;
branches;
next	1.74.2.41;

1.74.2.41
date	2002.02.19.06.43.34;	author matz;	state Exp;
branches;
next	1.74.2.42;

1.74.2.42
date	2002.02.20.04.28.51;	author matz;	state Exp;
branches;
next	1.74.2.43;

1.74.2.43
date	2002.03.07.11.19.28;	author nobu;	state Exp;
branches;
next	1.74.2.44;

1.74.2.44
date	2002.03.08.06.59.53;	author matz;	state Exp;
branches;
next	1.74.2.45;

1.74.2.45
date	2002.03.15.08.55.58;	author matz;	state Exp;
branches;
next	1.74.2.46;

1.74.2.46
date	2002.03.18.02.00.05;	author nobu;	state Exp;
branches;
next	1.74.2.47;

1.74.2.47
date	2002.03.19.09.02.03;	author matz;	state Exp;
branches;
next	1.74.2.48;

1.74.2.48
date	2002.04.04.06.47.39;	author eban;	state Exp;
branches;
next	1.74.2.49;

1.74.2.49
date	2002.05.01.09.37.58;	author matz;	state Exp;
branches;
next	1.74.2.50;

1.74.2.50
date	2002.05.10.10.05.18;	author nobu;	state Exp;
branches;
next	1.74.2.51;

1.74.2.51
date	2002.05.22.09.40.17;	author aamine;	state Exp;
branches;
next	1.74.2.52;

1.74.2.52
date	2002.06.02.22.16.49;	author nobu;	state Exp;
branches;
next	1.74.2.53;

1.74.2.53
date	2002.06.10.10.15.00;	author nobu;	state Exp;
branches;
next	1.74.2.54;

1.74.2.54
date	2002.06.11.06.58.37;	author matz;	state Exp;
branches;
next	1.74.2.55;

1.74.2.55
date	2002.06.12.06.06.17;	author nobu;	state Exp;
branches;
next	1.74.2.56;

1.74.2.56
date	2002.06.12.09.24.58;	author matz;	state Exp;
branches;
next	1.74.2.57;

1.74.2.57
date	2002.06.13.03.54.39;	author matz;	state Exp;
branches;
next	1.74.2.58;

1.74.2.58
date	2002.06.14.06.26.59;	author nobu;	state Exp;
branches;
next	1.74.2.59;

1.74.2.59
date	2002.07.11.08.24.53;	author matz;	state Exp;
branches;
next	1.74.2.60;

1.74.2.60
date	2002.07.11.12.31.37;	author nobu;	state Exp;
branches;
next	1.74.2.61;

1.74.2.61
date	2002.07.11.15.51.48;	author nobu;	state Exp;
branches;
next	1.74.2.62;

1.74.2.62
date	2002.09.02.15.20.12;	author aamine;	state Exp;
branches;
next	1.74.2.63;

1.74.2.63
date	2002.09.05.20.08.48;	author aamine;	state Exp;
branches;
next	1.74.2.64;

1.74.2.64
date	2002.09.06.02.58.55;	author aamine;	state Exp;
branches;
next	1.74.2.65;

1.74.2.65
date	2002.09.06.23.41.43;	author aamine;	state Exp;
branches;
next	1.74.2.66;

1.74.2.66
date	2002.09.25.07.07.37;	author matz;	state Exp;
branches;
next	1.74.2.67;

1.74.2.67
date	2002.10.18.14.40.56;	author nobu;	state Exp;
branches;
next	1.74.2.68;

1.74.2.68
date	2002.10.25.19.46.02;	author knu;	state Exp;
branches;
next	1.74.2.69;

1.74.2.69
date	2002.10.26.15.57.23;	author knu;	state Exp;
branches;
next	;

1.77.2.1
date	2001.01.10.09.24.27;	author matz;	state Exp;
branches;
next	1.77.2.2;

1.77.2.2
date	2001.01.12.04.36.00;	author matz;	state Exp;
branches;
next	;


desc
@@


1.224
log
@* eval.c (rb_eval): added NODE_DSYM, symbol literal with
  interpolation.

* node.h: ditto.

* intern.h: prototypes; rb_is_junk_id, rb_str_dump, rb_str_intern

* object.c (sym_inspect): escape and quote for non-alphanumeric
  symbols.

* parse.y (dsym, tokadd_string, yylex): extended symbol literals.

* parse.y (rb_is_junk_id): added.

* string.c (rb_str_dump, rb_str_intern) : make extern.

* lib/mkmf.rb (create_makefile): deffile should be removed by
  distclean, not clean.
@
text
@/**********************************************************************

  parse.y -

  $Author: nobu $
  $Date: 2002/10/18 14:13:41 $
  created at: Fri May 28 18:02:42 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto

**********************************************************************/

%{

#define YYDEBUG 1

#include "ruby.h"
#include "env.h"
#include "intern.h"
#include "node.h"
#include "st.h"
#include <stdio.h>
#include <errno.h>
#include <ctype.h>

#define yyparse ruby_yyparse
#define yylex ruby_yylex
#define yyerror ruby_yyerror
#define yylval ruby_yylval
#define yychar ruby_yychar
#define yydebug ruby_yydebug

#define ID_SCOPE_SHIFT 3
#define ID_SCOPE_MASK 0x07
#define ID_LOCAL    0x01
#define ID_INSTANCE 0x02
#define ID_GLOBAL   0x03
#define ID_ATTRSET  0x04
#define ID_CONST    0x05
#define ID_CLASS    0x06
#define ID_JUNK     0x07
#define ID_INTERNAL ID_JUNK

#define is_notop_id(id) ((id)>LAST_TOKEN)
#define is_local_id(id) (is_notop_id(id)&&((id)&ID_SCOPE_MASK)==ID_LOCAL)
#define is_global_id(id) (is_notop_id(id)&&((id)&ID_SCOPE_MASK)==ID_GLOBAL)
#define is_instance_id(id) (is_notop_id(id)&&((id)&ID_SCOPE_MASK)==ID_INSTANCE)
#define is_attrset_id(id) (is_notop_id(id)&&((id)&ID_SCOPE_MASK)==ID_ATTRSET)
#define is_const_id(id) (is_notop_id(id)&&((id)&ID_SCOPE_MASK)==ID_CONST)
#define is_class_id(id) (is_notop_id(id)&&((id)&ID_SCOPE_MASK)==ID_CLASS)
#define is_junk_id(id) (is_notop_id(id)&&((id)&ID_SCOPE_MASK)==ID_JUNK)

#define is_asgn_or_id(id) ((is_notop_id(id)) && \
	(((id)&ID_SCOPE_MASK) == ID_GLOBAL || \
	 ((id)&ID_SCOPE_MASK) == ID_INSTANCE || \
	 ((id)&ID_SCOPE_MASK) == ID_CLASS))

NODE *ruby_eval_tree_begin = 0;
NODE *ruby_eval_tree = 0;

char *ruby_sourcefile;		/* current source file */
int   ruby_sourceline;		/* current line no. */

static int yylex();
static int yyerror();

static enum lex_state {
    EXPR_BEG,			/* ignore newline, +/- is a sign. */
    EXPR_END,			/* newline significant, +/- is a operator. */
    EXPR_ARG,			/* newline significant, +/- is a operator. */
    EXPR_CMDARG,		/* newline significant, +/- is a operator. */
    EXPR_ENDARG,		/* newline significant, +/- is a operator. */
    EXPR_MID,			/* newline significant, +/- is a operator. */
    EXPR_FNAME,			/* ignore newline, no reserved words. */
    EXPR_DOT,			/* right after `.' or `::', no reserved words. */
    EXPR_CLASS,			/* immediate after `class', no here document. */
} lex_state;
static NODE *lex_strterm;
static int lex_strnest;

#ifdef HAVE_LONG_LONG
typedef unsigned LONG_LONG stack_type;
#else
typedef unsigned long stack_type;
#endif

static stack_type cond_stack = 0;
#define COND_PUSH(n) (cond_stack = (cond_stack<<1)|((n)&1))
#define COND_POP() (cond_stack >>= 1)
#define COND_LEXPOP() do {\
    int last = COND_P();\
    cond_stack >>= 1;\
    if (last) cond_stack |= 1;\
} while (0)
#define COND_P() (cond_stack&1)

static stack_type cmdarg_stack = 0;
#define CMDARG_PUSH(n) (cmdarg_stack = (cmdarg_stack<<1)|((n)&1))
#define CMDARG_POP() (cmdarg_stack >>= 1)
#define CMDARG_LEXPOP() do {\
    int last = CMDARG_P();\
    cmdarg_stack >>= 1;\
    if (last) cmdarg_stack |= 1;\
} while (0)
#define CMDARG_P() (cmdarg_stack&1)

static int class_nest = 0;
static int in_single = 0;
static int in_def = 0;
static int compile_for_eval = 0;
static ID cur_mid = 0;
static int quoted_term;
#define quoted_term_char ((unsigned char)quoted_term)
#define WHEN_QUOTED_TERM(x) ((quoted_term >= 0) && (x))
#define QUOTED_TERM_P(c) WHEN_QUOTED_TERM((c) == quoted_term_char)

static NODE *cond();
static NODE *logop();

static NODE *newline_node();
static void fixpos();

static int value_expr0();
static void void_expr0();
static void void_stmts();
static NODE *remove_begin();
#define value_expr(node) value_expr0((node) = remove_begin(node))
#define void_expr(node) void_expr0((node) = remove_begin(node))

static NODE *block_append();
static NODE *list_append();
static NODE *list_concat();
static NODE *arg_concat();
static NODE *arg_prepend();
static NODE *literal_concat();
static NODE *new_evstr();
static NODE *call_op();
static int in_defined = 0;

static NODE *ret_args();
static NODE *arg_blk_pass();
static NODE *new_call();
static NODE *new_fcall();
static NODE *new_super();

static NODE *gettable();
static NODE *assignable();
static NODE *aryset();
static NODE *attrset();
static void rb_backref_error();
static NODE *node_assign();

static NODE *match_gen();
static void local_push();
static void local_pop();
static int  local_append();
static int  local_cnt();
static int  local_id();
static ID  *local_tbl();
static ID   internal_id();

static struct RVarmap *dyna_push();
static void dyna_pop();
static int dyna_in_block();

static void top_local_init();
static void top_local_setup();

#define RE_OPTION_ONCE 0x80

#define NODE_STRTERM NODE_ZARRAY	/* nothing to gc */
#define NODE_HEREDOC NODE_ARRAY 	/* 1, 3 to gc */
#define nd_func u1.id
#define nd_term u2.id
#define nd_paren u3.id

%}

%union {
    NODE *node;
    ID id;
    int num;
    struct RVarmap *vars;
}

%token  kCLASS
	kMODULE
	kDEF
	kUNDEF
	kBEGIN
	kRESCUE
	kENSURE
	kEND
	kIF
	kUNLESS
	kTHEN
	kELSIF
	kELSE
	kCASE
	kWHEN
	kWHILE
	kUNTIL
	kFOR
	kBREAK
	kNEXT
	kREDO
	kRETRY
	kIN
	kDO
	kDO_COND
	kDO_BLOCK
	kRETURN
	kYIELD
	kSUPER
	kSELF
	kNIL
	kTRUE
	kFALSE
	kAND
	kOR
	kNOT
	kIF_MOD
	kUNLESS_MOD
	kWHILE_MOD
	kUNTIL_MOD
	kRESCUE_MOD
	kALIAS
	kDEFINED
	klBEGIN
	klEND
	k__LINE__
	k__FILE__

%token <id>   tIDENTIFIER tFID tGVAR tIVAR tCONSTANT tCVAR
%token <node> tINTEGER tFLOAT tSTRING_CONTENT
%token <node> tNTH_REF tBACK_REF
%token <num>  tREGEXP_END

%type <node> singleton strings string string1 xstring regexp
%type <node> string_contents xstring_contents string_content
%type <node> words qwords word_list qword_list word
%type <node> literal numeric dsym
%type <node> bodystmt compstmt stmts stmt expr arg primary command command_call method_call
%type <node> expr_value arg_value primary_value
%type <node> if_tail opt_else case_body cases opt_rescue exc_list exc_var opt_ensure
%type <node> args when_args call_args call_args2 open_args paren_args opt_paren_args
%type <node> command_args aref_args opt_block_arg block_arg var_ref var_lhs
%type <node> mrhs mrhs_basic superclass block_call block_command
%type <node> f_arglist f_args f_optarg f_opt f_block_arg opt_f_block_arg
%type <node> assoc_list assocs assoc undef_list backref string_dvar
%type <node> block_var opt_block_var brace_block do_block lhs none
%type <node> mlhs mlhs_head mlhs_basic mlhs_entry mlhs_item mlhs_node
%type <id>   fitem variable sym symbol operation operation2 operation3
%type <id>   cname fname op f_rest_arg
%type <num>  f_norm_arg f_arg term_push
%token tUPLUS 		/* unary+ */
%token tUMINUS 		/* unary- */
%token tPOW		/* ** */
%token tCMP  		/* <=> */
%token tEQ  		/* == */
%token tEQQ  		/* === */
%token tNEQ  		/* != */
%token tGEQ  		/* >= */
%token tLEQ  		/* <= */
%token tANDOP tOROP	/* && and || */
%token tMATCH tNMATCH	/* =~ and !~ */
%token tDOT2 tDOT3	/* .. and ... */
%token tAREF tASET	/* [] and []= */
%token tLSHFT tRSHFT	/* << and >> */
%token tCOLON2		/* :: */
%token tCOLON3		/* :: at EXPR_BEG */
%token <id> tOP_ASGN	/* +=, -=  etc. */
%token tASSOC		/* => */
%token tLPAREN		/* ( */
%token tLPAREN_ARG	/* ( */
%token tRPAREN		/* ) */
%token tLBRACK		/* [ */
%token tLBRACE		/* { */
%token tLBRACE_ARG	/* { */
%token tSTAR		/* * */
%token tAMPER		/* & */
%token tSYMBEG tSTRING_BEG tXSTRING_BEG tREGEXP_BEG tWORDS_BEG tQWORDS_BEG
%token tSTRING_DBEG tSTRING_DVAR tSTRING_END

/*
 *	precedence table
 */

%left  kIF_MOD kUNLESS_MOD kWHILE_MOD kUNTIL_MOD
%left  kOR kAND
%right kNOT
%nonassoc kDEFINED
%right '=' tOP_ASGN
%left kRESCUE_MOD
%right '?' ':'
%nonassoc tDOT2 tDOT3
%left  tOROP
%left  tANDOP
%nonassoc  tCMP tEQ tEQQ tNEQ tMATCH tNMATCH
%left  '>' tGEQ '<' tLEQ
%left  '|' '^'
%left  '&'
%left  tLSHFT tRSHFT
%left  '+' '-'
%left  '*' '/' '%'
%right '!' '~' tUPLUS tUMINUS
%right tPOW

%token LAST_TOKEN

%%
program		:  {
			lex_state = EXPR_BEG;
                        top_local_init();
			if ((VALUE)ruby_class == rb_cObject) class_nest = 0;
			else class_nest = 1;
		    }
		  compstmt
		    {
			if ($2 && !compile_for_eval) {
                            /* last expression should not be void */
			    if (nd_type($2) != NODE_BLOCK) void_expr($2);
			    else {
				NODE *node = $2;
				while (node->nd_next) {
				    node = node->nd_next;
				}
				void_expr(node->nd_head);
			    }
			}
			ruby_eval_tree = block_append(ruby_eval_tree, $2);
                        top_local_setup();
			class_nest = 0;
		    }
		;

bodystmt	: compstmt
		  opt_rescue
		  opt_else
		  opt_ensure
		    {
		        $$ = $1;
			if ($2) {
			    $$ = NEW_RESCUE($1, $2, $3);
			}
			else if ($3) {
			    rb_warn("else without rescue is useless");
			    $$ = block_append($$, $3);
			}
			if ($4) {
			    $$ = NEW_ENSURE($$, $4);
			}
			fixpos($$, $1);
		    }
		;

compstmt	: stmts opt_terms
		    {
			void_stmts($1);
		        $$ = $1;
		    }
		;

stmts		: none
		| stmt
		    {
			$$ = newline_node($1);
		    }
		| stmts terms stmt
		    {
			$$ = block_append($1, newline_node($3));
		    }
		| error stmt
		    {
			$$ = $2;
		    }
		;

stmt		: kALIAS fitem {lex_state = EXPR_FNAME;} fitem
		    {
		        $$ = NEW_ALIAS($2, $4);
		    }
		| kALIAS tGVAR tGVAR
		    {
		        $$ = NEW_VALIAS($2, $3);
		    }
		| kALIAS tGVAR tBACK_REF
		    {
			char buf[3];

			sprintf(buf, "$%c", $3->nd_nth);
		        $$ = NEW_VALIAS($2, rb_intern(buf));
		    }
		| kALIAS tGVAR tNTH_REF
		    {
		        yyerror("can't make alias for the number variables");
		        $$ = 0;
		    }
		| kUNDEF undef_list
		    {
			$$ = $2;
		    }
		| stmt kIF_MOD expr_value
		    {
			$$ = NEW_IF(cond($3), $1, 0);
		        fixpos($$, $3);
		    }
		| stmt kUNLESS_MOD expr_value
		    {
			$$ = NEW_UNLESS(cond($3), $1, 0);
		        fixpos($$, $3);
		    }
		| stmt kWHILE_MOD expr_value
		    {
			if ($1 && nd_type($1) == NODE_BEGIN) {
			    $$ = NEW_WHILE(cond($3), $1->nd_body, 0);
			}
			else {
			    $$ = NEW_WHILE(cond($3), $1, 1);
			}
		    }
		| stmt kUNTIL_MOD expr_value
		    {
			if ($1 && nd_type($1) == NODE_BEGIN) {
			    $$ = NEW_UNTIL(cond($3), $1->nd_body, 0);
			}
			else {
			    $$ = NEW_UNTIL(cond($3), $1, 1);
			}
		    }
		| klBEGIN
		    {
			if (in_def || in_single) {
			    yyerror("BEGIN in method");
			}
			local_push(0);
		    }
		  '{' compstmt '}'
		    {
			ruby_eval_tree_begin = block_append(ruby_eval_tree_begin,
						            NEW_PREEXE($4));
		        local_pop();
		        $$ = 0;
		    }
		| klEND '{' compstmt '}'
		    {
			if (compile_for_eval && (in_def || in_single)) {
			    yyerror("END in method; use at_exit");
			}

			$$ = NEW_ITER(0, NEW_POSTEXE(), $3);
		    }
		| lhs '=' command_call
		    {
			$$ = node_assign($1, $3);
		    }
		| mlhs '=' command_call
		    {
			value_expr($3);
			$1->nd_value = $3;
			$$ = $1;
		    }
		| var_lhs tOP_ASGN command_call
		    {
			value_expr($3);
			if ($1) {
			    ID vid = $1->nd_vid;
			    if ($2 == tOROP) {
				$1->nd_value = $3;
				$$ = NEW_OP_ASGN_OR(gettable(vid), $1);
				if (is_asgn_or_id(vid)) {
				    $$->nd_aid = vid;
				}
			    }
			    else if ($2 == tANDOP) {
				$1->nd_value = $3;
				$$ = NEW_OP_ASGN_AND(gettable(vid), $1);
			    }
			    else {
				$$ = $1;
				$$->nd_value = call_op(gettable(vid),$2,1,$3);
			    }
			}
			else {
			    $$ = 0;
			}
		    }
		| primary_value '[' aref_args ']' tOP_ASGN command_call
		    {
                        NODE *args;

			value_expr($6);
		        args = NEW_LIST($6);
			$3 = list_append($3, NEW_NIL());
			list_concat(args, $3);
			if ($5 == tOROP) {
			    $5 = 0;
			}
			else if ($5 == tANDOP) {
			    $5 = 1;
			}
			$$ = NEW_OP_ASGN1($1, $5, args);
		        fixpos($$, $1);
		    }
		| primary_value '.' tIDENTIFIER tOP_ASGN command_call
		    {
			value_expr($5);
			if ($4 == tOROP) {
			    $4 = 0;
			}
			else if ($4 == tANDOP) {
			    $4 = 1;
			}
			$$ = NEW_OP_ASGN2($1, $3, $4, $5);
		        fixpos($$, $1);
		    }
		| primary_value '.' tCONSTANT tOP_ASGN command_call
		    {
			value_expr($5);
			if ($4 == tOROP) {
			    $4 = 0;
			}
			else if ($4 == tANDOP) {
			    $4 = 1;
			}
			$$ = NEW_OP_ASGN2($1, $3, $4, $5);
		        fixpos($$, $1);
		    }
		| primary_value tCOLON2 tIDENTIFIER tOP_ASGN command_call
		    {
			value_expr($5);
			if ($4 == tOROP) {
			    $4 = 0;
			}
			else if ($4 == tANDOP) {
			    $4 = 1;
			}
			$$ = NEW_OP_ASGN2($1, $3, $4, $5);
		        fixpos($$, $1);
		    }
		| backref tOP_ASGN command_call
		    {
		        rb_backref_error($1);
			$$ = 0;
		    }
		| lhs '=' mrhs_basic
		    {
			$$ = node_assign($1, NEW_REXPAND($3));
		    }
		| mlhs '=' mrhs
		    {
			$1->nd_value = $3;
			$$ = $1;
		    }
		| expr
		;

expr		: kRETURN call_args
		    {
			$$ = NEW_RETURN(ret_args($2));
		    }
		| kBREAK call_args
		    {
			$$ = NEW_BREAK(ret_args($2));
		    }
		| kNEXT call_args
		    {
			$$ = NEW_NEXT(ret_args($2));
		    }
		| command_call
		| expr kAND expr
		    {
			$$ = logop(NODE_AND, $1, $3);
		    }
		| expr kOR expr
		    {
			$$ = logop(NODE_OR, $1, $3);
		    }
		| kNOT expr
		    {
			$$ = NEW_NOT(cond($2));
		    }
		| '!' command_call
		    {
			$$ = NEW_NOT(cond($2));
		    }
		| arg
		;

expr_value	: expr
		    {
			value_expr($$);
			$$ = $1;
		    }
		;

command_call	: command
		| block_command
		;

block_command	: block_call
		| block_call '.' operation2 command_args
		    {
			$$ = new_call($1, $3, $4);
		    }
		| block_call tCOLON2 operation2 command_args
		    {
			$$ = new_call($1, $3, $4);
		    }
		;

command		: operation command_args
		    {
			$$ = new_fcall($1, $2);
		        fixpos($$, $2);
		   }
		| primary_value '.' operation2 command_args
		    {
			$$ = new_call($1, $3, $4);
		        fixpos($$, $1);
		    }
		| primary_value tCOLON2 operation2 command_args
		    {
			$$ = new_call($1, $3, $4);
		        fixpos($$, $1);
		    }
		| kSUPER command_args
		    {
			$$ = new_super($2);
		        fixpos($$, $2);
		    }
		| kYIELD command_args
		    {
			$$ = NEW_YIELD(ret_args($2));
		        fixpos($$, $2);
		    }
		;

mlhs		: mlhs_basic
		| tLPAREN mlhs_entry ')'
		    {
			$$ = $2;
		    }
		;

mlhs_entry	: mlhs_basic
		| tLPAREN mlhs_entry ')'
		    {
			$$ = NEW_MASGN(NEW_LIST($2), 0);
		    }
		;

mlhs_basic	: mlhs_head
		    {
			$$ = NEW_MASGN($1, 0);
		    }
		| mlhs_head mlhs_item
		    {
			$$ = NEW_MASGN(list_append($1,$2), 0);
		    }
		| mlhs_head tSTAR mlhs_node
		    {
			$$ = NEW_MASGN($1, $3);
		    }
		| mlhs_head tSTAR
		    {
			$$ = NEW_MASGN($1, -1);
		    }
		| tSTAR mlhs_node
		    {
			$$ = NEW_MASGN(0, $2);
		    }
		| tSTAR
		    {
			$$ = NEW_MASGN(0, -1);
		    }
		;

mlhs_item	: mlhs_node
		| tLPAREN mlhs_entry ')'
		    {
			$$ = $2;
		    }
		;

mlhs_head	: mlhs_item ','
		    {
			$$ = NEW_LIST($1);
		    }
		| mlhs_head mlhs_item ','
		    {
			$$ = list_append($1, $2);
		    }
		;

mlhs_node	: variable
		    {
			$$ = assignable($1, 0);
		    }
		| primary_value '[' aref_args ']'
		    {
			$$ = aryset($1, $3);
		    }
		| primary_value '.' tIDENTIFIER
		    {
			$$ = attrset($1, $3);
		    }
		| primary_value tCOLON2 tIDENTIFIER
		    {
			$$ = attrset($1, $3);
		    }
		| primary_value '.' tCONSTANT
		    {
			$$ = attrset($1, $3);
		    }
		| backref
		    {
		        rb_backref_error($1);
			$$ = 0;
		    }
		;

lhs		: variable
		    {
			$$ = assignable($1, 0);
		    }
		| primary_value '[' aref_args ']'
		    {
			$$ = aryset($1, $3);
		    }
		| primary_value '.' tIDENTIFIER
		    {
			$$ = attrset($1, $3);
		    }
		| primary_value tCOLON2 tIDENTIFIER
		    {
			$$ = attrset($1, $3);
		    }
		| primary_value '.' tCONSTANT
		    {
			$$ = attrset($1, $3);
		    }
		| backref
		    {
		        rb_backref_error($1);
			$$ = 0;
		    }
		;

cname		: tIDENTIFIER
		    {
			yyerror("class/module name must be CONSTANT");
		    }
		| tCONSTANT
		;

fname		: tIDENTIFIER
		| tCONSTANT
		| tFID
		| op
		    {
			lex_state = EXPR_END;
			$$ = $1;
		    }
		| reswords
		    {
			lex_state = EXPR_END;
			$$ = $<id>1;
		    }
		;

fitem		: fname
		| symbol
		;

undef_list	: fitem
		    {
			$$ = NEW_UNDEF($1);
		    }
		| undef_list ',' {lex_state = EXPR_FNAME;} fitem
		    {
			$$ = block_append($1, NEW_UNDEF($4));
		    }
		;

op		: '|'		{ $$ = '|'; }
		| '^'		{ $$ = '^'; }
		| '&'		{ $$ = '&'; }
		| tCMP		{ $$ = tCMP; }
		| tEQ		{ $$ = tEQ; }
		| tEQQ		{ $$ = tEQQ; }
		| tMATCH	{ $$ = tMATCH; }
		| '>'		{ $$ = '>'; }
		| tGEQ		{ $$ = tGEQ; }
		| '<'		{ $$ = '<'; }
		| tLEQ		{ $$ = tLEQ; }
		| tLSHFT	{ $$ = tLSHFT; }
		| tRSHFT	{ $$ = tRSHFT; }
		| '+'		{ $$ = '+'; }
		| '-'		{ $$ = '-'; }
		| '*'		{ $$ = '*'; }
		| tSTAR		{ $$ = '*'; }
		| '/'		{ $$ = '/'; }
		| '%'		{ $$ = '%'; }
		| tPOW		{ $$ = tPOW; }
		| '~'		{ $$ = '~'; }
		| tUPLUS	{ $$ = tUPLUS; }
		| tUMINUS	{ $$ = tUMINUS; }
		| tAREF		{ $$ = tAREF; }
		| tASET		{ $$ = tASET; }
		| '`'		{ $$ = '`'; }
		;

reswords	: k__LINE__ | k__FILE__  | klBEGIN | klEND
		| kALIAS | kAND | kBEGIN | kBREAK | kCASE | kCLASS | kDEF
		| kDEFINED | kDO | kELSE | kELSIF | kEND | kENSURE | kFALSE
		| kFOR | kIF_MOD | kIN | kMODULE | kNEXT | kNIL | kNOT
		| kOR | kREDO | kRESCUE | kRETRY | kRETURN | kSELF | kSUPER
		| kTHEN | kTRUE | kUNDEF | kUNLESS_MOD | kUNTIL_MOD | kWHEN
		| kWHILE_MOD | kYIELD | kRESCUE_MOD
		;

arg		: lhs '=' arg
		    {
			$$ = node_assign($1, $3);
		    }
		| var_lhs tOP_ASGN arg
		    {
			value_expr($3);
			if ($1) {
			    ID vid = $1->nd_vid;
			    if ($2 == tOROP) {
				$1->nd_value = $3;
				$$ = NEW_OP_ASGN_OR(gettable(vid), $1);
				if (is_asgn_or_id(vid)) {
				    $$->nd_aid = vid;
				}
			    }
			    else if ($2 == tANDOP) {
				$1->nd_value = $3;
				$$ = NEW_OP_ASGN_AND(gettable(vid), $1);
			    }
			    else {
				$$ = $1;
				$$->nd_value = call_op(gettable(vid),$2,1,$3);
			    }
			}
			else {
			    $$ = 0;
			}
		    }
		| primary_value '[' aref_args ']' tOP_ASGN arg
		    {
                        NODE *args;

			value_expr($6);
			args = NEW_LIST($6);
			$3 = list_append($3, NEW_NIL());
			list_concat(args, $3);
			if ($5 == tOROP) {
			    $5 = 0;
			}
			else if ($5 == tANDOP) {
			    $5 = 1;
			}
			$$ = NEW_OP_ASGN1($1, $5, args);
		        fixpos($$, $1);
		    }
		| primary_value '.' tIDENTIFIER tOP_ASGN arg
		    {
			value_expr($5);
			if ($4 == tOROP) {
			    $4 = 0;
			}
			else if ($4 == tANDOP) {
			    $4 = 1;
			}
			$$ = NEW_OP_ASGN2($1, $3, $4, $5);
		        fixpos($$, $1);
		    }
		| primary_value '.' tCONSTANT tOP_ASGN arg
		    {
			value_expr($5);
			if ($4 == tOROP) {
			    $4 = 0;
			}
			else if ($4 == tANDOP) {
			    $4 = 1;
			}
			$$ = NEW_OP_ASGN2($1, $3, $4, $5);
		        fixpos($$, $1);
		    }
		| primary_value tCOLON2 tIDENTIFIER tOP_ASGN arg
		    {
			value_expr($5);
			if ($4 == tOROP) {
			    $4 = 0;
			}
			else if ($4 == tANDOP) {
			    $4 = 1;
			}
			$$ = NEW_OP_ASGN2($1, $3, $4, $5);
		        fixpos($$, $1);
		    }
		| backref tOP_ASGN arg
		    {
		        rb_backref_error($1);
			$$ = 0;
		    }
		| arg tDOT2 arg
		    {
			value_expr($1);
			value_expr($3);
			$$ = NEW_DOT2($1, $3);
		    }
		| arg tDOT3 arg
		    {
			value_expr($1);
			value_expr($3);
			$$ = NEW_DOT3($1, $3);
		    }
		| arg '+' arg
		    {
			$$ = call_op($1, '+', 1, $3);
		    }
		| arg '-' arg
		    {
		        $$ = call_op($1, '-', 1, $3);
		    }
		| arg '*' arg
		    {
		        $$ = call_op($1, '*', 1, $3);
		    }
		| arg '/' arg
		    {
			$$ = call_op($1, '/', 1, $3);
		    }
		| arg '%' arg
		    {
			$$ = call_op($1, '%', 1, $3);
		    }
		| arg tPOW arg
		    {
			$$ = call_op($1, tPOW, 1, $3);
		    }
		| tUPLUS arg
		    {
			if ($2 && nd_type($2) == NODE_LIT) {
			    $$ = $2;
			}
			else {
			    $$ = call_op($2, tUPLUS, 0, 0);
			}
		    }
		| tUMINUS arg
		    {
			if ($2 && nd_type($2) == NODE_LIT && FIXNUM_P($2->nd_lit)) {
			    long i = FIX2LONG($2->nd_lit);

			    $2->nd_lit = LONG2NUM(-i);
			    $$ = $2;
			}
			else {
			    $$ = call_op($2, tUMINUS, 0, 0);
			}
		    }
		| arg '|' arg
		    {
		        $$ = call_op($1, '|', 1, $3);
		    }
		| arg '^' arg
		    {
			$$ = call_op($1, '^', 1, $3);
		    }
		| arg '&' arg
		    {
			$$ = call_op($1, '&', 1, $3);
		    }
		| arg tCMP arg
		    {
			$$ = call_op($1, tCMP, 1, $3);
		    }
		| arg '>' arg
		    {
			$$ = call_op($1, '>', 1, $3);
		    }
		| arg tGEQ arg
		    {
			$$ = call_op($1, tGEQ, 1, $3);
		    }
		| arg '<' arg
		    {
			$$ = call_op($1, '<', 1, $3);
		    }
		| arg tLEQ arg
		    {
			$$ = call_op($1, tLEQ, 1, $3);
		    }
		| arg tEQ arg
		    {
			$$ = call_op($1, tEQ, 1, $3);
		    }
		| arg tEQQ arg
		    {
			$$ = call_op($1, tEQQ, 1, $3);
		    }
		| arg tNEQ arg
		    {
			$$ = NEW_NOT(call_op($1, tEQ, 1, $3));
		    }
		| arg tMATCH arg
		    {
			$$ = match_gen($1, $3);
		    }
		| arg tNMATCH arg
		    {
			$$ = NEW_NOT(match_gen($1, $3));
		    }
		| '!' arg
		    {
			$$ = NEW_NOT(cond($2));
		    }
		| '~' arg
		    {
			$$ = call_op($2, '~', 0, 0);
		    }
		| arg tLSHFT arg
		    {
			$$ = call_op($1, tLSHFT, 1, $3);
		    }
		| arg tRSHFT arg
		    {
			$$ = call_op($1, tRSHFT, 1, $3);
		    }
		| arg tANDOP arg
		    {
			$$ = logop(NODE_AND, $1, $3);
		    }
		| arg tOROP arg
		    {
			$$ = logop(NODE_OR, $1, $3);
		    }
		| arg kRESCUE_MOD arg
		    {
			$$ = NEW_RESCUE($1, NEW_RESBODY(0,$3,0), 0);
		    }
		| kDEFINED opt_nl {in_defined = 1;} arg
		    {
		        in_defined = 0;
			$$ = NEW_DEFINED($4);
		    }
		| arg '?' arg ':' arg
		    {
			$$ = NEW_IF(cond($1), $3, $5);
		        fixpos($$, $1);
		    }
		| primary
		    {
			$$ = $1;
		    }
		;

arg_value	: arg
		    {
			value_expr($1);
			$$ = $1;
		    }
		;

aref_args	: none
		| command opt_nl
		    {
		        rb_warn("parenthesize argument(s) for future version");
			$$ = NEW_LIST($1);
		    }
		| args trailer
		    {
			$$ = $1;
		    }
		| args ',' tSTAR arg opt_nl
		    {
			value_expr($4);
			$$ = arg_concat($1, $4);
		    }
		| assocs trailer
		    {
			$$ = NEW_LIST(NEW_HASH($1));
		    }
		| tSTAR arg opt_nl
		    {
			value_expr($2);
			$$ = NEW_RESTARY($2);
		    }
		;

paren_args	: '(' none ')'
		    {
			$$ = $2;
		    }
		| '(' call_args opt_nl ')'
		    {
			$$ = $2;
		    }
		| '(' block_call opt_nl ')'
		    {
		        rb_warn("parenthesize argument for future version");
			$$ = NEW_LIST($2);
		    }
		| '(' args ',' block_call opt_nl ')'
		    {
		        rb_warn("parenthesize argument for future version");
			$$ = list_append($2, $4);
		    }
		;

opt_paren_args	: none
		| paren_args
		;

call_args	: command
		    {
		        rb_warn("parenthesize argument(s) for future version");
			$$ = NEW_LIST($1);
		    }
		| args opt_block_arg
		    {
			$$ = arg_blk_pass($1, $2);
		    }
		| args ',' tSTAR arg_value opt_block_arg
		    {
			$$ = arg_concat($1, $4);
			$$ = arg_blk_pass($$, $5);
		    }
		| assocs opt_block_arg
		    {
			$$ = NEW_LIST(NEW_HASH($1));
			$$ = arg_blk_pass($$, $2);
		    }
		| assocs ',' tSTAR arg_value opt_block_arg
		    {
			$$ = arg_concat(NEW_LIST(NEW_HASH($1)), $4);
			$$ = arg_blk_pass($$, $5);
		    }
		| args ',' assocs opt_block_arg
		    {
			$$ = list_append($1, NEW_HASH($3));
			$$ = arg_blk_pass($$, $4);
		    }
		| args ',' assocs ',' tSTAR arg opt_block_arg
		    {
			value_expr($6);
			$$ = arg_concat(list_append($1, NEW_HASH($3)), $6);
			$$ = arg_blk_pass($$, $7);
		    }
		| tSTAR arg_value opt_block_arg
		    {
			$$ = arg_blk_pass(NEW_RESTARGS($2), $3);
		    }
		| block_arg
		;

call_args2	: arg_value ',' args opt_block_arg
		    {
			$$ = arg_blk_pass(list_concat(NEW_LIST($1),$3), $4);
		    }
		| arg_value ',' block_arg
		    {
                        $$ = arg_blk_pass($1, $3);
                    }
		| arg_value ',' tSTAR arg_value opt_block_arg
		    {
			$$ = arg_concat(NEW_LIST($1), $4);
			$$ = arg_blk_pass($$, $5);
		    }
		| arg_value ',' args ',' tSTAR arg_value opt_block_arg
		    {
			$$ = arg_concat(list_concat($1,$3), $6);
			$$ = arg_blk_pass($$, $7);
		    }
		| assocs opt_block_arg
		    {
			$$ = NEW_LIST(NEW_HASH($1));
			$$ = arg_blk_pass($$, $2);
		    }
		| assocs ',' tSTAR arg_value opt_block_arg
		    {
			$$ = arg_concat(NEW_LIST(NEW_HASH($1)), $4);
			$$ = arg_blk_pass($$, $5);
		    }
		| arg_value ',' assocs opt_block_arg
		    {
			$$ = list_append(NEW_LIST($1), NEW_HASH($3));
			$$ = arg_blk_pass($$, $4);
		    }
		| arg_value ',' args ',' assocs opt_block_arg
		    {
			$$ = list_append(list_concat(NEW_LIST($1),$3), NEW_HASH($5));
			$$ = arg_blk_pass($$, $6);
		    }
		| arg_value ',' assocs ',' tSTAR arg_value opt_block_arg
		    {
			$$ = arg_concat(list_append(NEW_LIST($1), NEW_HASH($3)), $6);
			$$ = arg_blk_pass($$, $7);
		    }
		| arg_value ',' args ',' assocs ',' tSTAR arg_value opt_block_arg
		    {
			$$ = arg_concat(list_append(list_concat(NEW_LIST($1), $3), NEW_HASH($5)), $8);
			$$ = arg_blk_pass($$, $9);
		    }
		| tSTAR arg_value opt_block_arg
		    {
			$$ = arg_blk_pass(NEW_RESTARGS($2), $3);
		    }
		| block_arg
		;

command_args	:  {
			$<num>$ = cmdarg_stack;
			CMDARG_PUSH(1);
		    }
		  open_args
		    {
			/* CMDARG_POP() */
		        cmdarg_stack = $<num>1;
			$$ = $2;
		    }
		;

open_args	: call_args
		| tLPAREN_ARG  {lex_state = EXPR_ENDARG;} ')'
		    {
		        rb_warning("%s (...) interpreted as method call",
		                   rb_id2name($<id>1));
			$$ = 0;
		    }
		| tLPAREN_ARG call_args2 {lex_state = EXPR_ENDARG;} ')'
		    {
		        rb_warning("%s (...) interpreted as method call",
		                   rb_id2name($<id>1));
			$$ = $2;
		    }
		;

block_arg	: tAMPER arg_value
		    {
			$$ = NEW_BLOCK_PASS($2);
		    }
		;

opt_block_arg	: ',' block_arg
		    {
			$$ = $2;
		    }
		| none
		;

args 		: arg_value
		    {
			$$ = NEW_LIST($1);
		    }
		| args ',' arg_value
		    {
			$$ = list_append($1, $3);
		    }
		;

mrhs		: arg_value
		    {
			$$ = $1;
		    }
		| mrhs_basic
		    {
			$$ = NEW_REXPAND($1);
		    }
		;

mrhs_basic	: args ',' arg_value
		    {
			$$ = list_append($1, $3);
		    }
		| args ',' tSTAR arg_value
		    {
			$$ = arg_concat($1, $4);
		    }
		| tSTAR arg_value
		    {
			$$ = $2;
		    }
		;

primary		: literal
		| strings
		| xstring
		| regexp
		| words
		| qwords
		| var_ref
		| backref
		| tFID
		    {
			$$ = NEW_VCALL($1);
		    }
		| kBEGIN
		  bodystmt
		  kEND
		    {
			$$ = NEW_BEGIN($2);
		    }
		| tLPAREN_ARG expr {lex_state = EXPR_ENDARG;} ')'
		    {
		        rb_warning("(...) interpreted as grouped expression");
			$$ = $2;
		    }
		| tLPAREN compstmt ')'
		    {
			$$ = $2;
		    }
		| primary_value tCOLON2 tCONSTANT
		    {
			$$ = NEW_COLON2($1, $3);
		    }
		| tCOLON3 cname
		    {
			$$ = NEW_COLON3($2);
		    }
		| primary_value '[' aref_args ']'
		    {
			$$ = NEW_CALL($1, tAREF, $3);
		    }
		| tLBRACK aref_args ']'
		    {
		        if ($2 == 0) {
			    $$ = NEW_ZARRAY(); /* zero length array*/
			}
			else {
			    $$ = $2;
			}
		    }
		| tLBRACE assoc_list '}'
		    {
			$$ = NEW_HASH($2);
		    }
		| kRETURN
		    {
			$$ = NEW_RETURN(0);
		    }
		| kYIELD '(' call_args ')'
		    {
			$$ = NEW_YIELD(ret_args($3));
		    }
		| kYIELD '(' ')'
		    {
			$$ = NEW_YIELD(0);
		    }
		| kYIELD
		    {
			$$ = NEW_YIELD(0);
		    }
		| kDEFINED opt_nl '(' {in_defined = 1;} expr ')'
		    {
		        in_defined = 0;
			$$ = NEW_DEFINED($5);
		    }
		| operation brace_block
		    {
			$2->nd_iter = NEW_FCALL($1, 0);
			$$ = $2;
		    }
		| method_call
		| method_call brace_block
		    {
			if ($1 && nd_type($1) == NODE_BLOCK_PASS) {
			    rb_compile_error("both block arg and actual block given");
			}
			$2->nd_iter = $1;
			$$ = $2;
		        fixpos($$, $1);
		    }
		| kIF expr_value then
		  compstmt
		  if_tail
		  kEND
		    {
			$$ = NEW_IF(cond($2), $4, $5);
		        fixpos($$, $2);
		    }
		| kUNLESS expr_value then
		  compstmt
		  opt_else
		  kEND
		    {
			$$ = NEW_UNLESS(cond($2), $4, $5);
		        fixpos($$, $2);
		    }
		| kWHILE {COND_PUSH(1);} expr_value do {COND_POP();}
		  compstmt
		  kEND
		    {
			$$ = NEW_WHILE(cond($3), $6, 1);
		        fixpos($$, $3);
		    }
		| kUNTIL {COND_PUSH(1);} expr_value do {COND_POP();} 
		  compstmt
		  kEND
		    {
			$$ = NEW_UNTIL(cond($3), $6, 1);
		        fixpos($$, $3);
		    }
		| kCASE expr_value opt_terms
		  case_body
		  kEND
		    {
			$$ = NEW_CASE($2, $4);
		        fixpos($$, $2);
		    }
		| kCASE opt_terms case_body kEND
		    {
			$$ = $3;
		    }
		| kFOR block_var kIN {COND_PUSH(1);} expr_value do {COND_POP();}
		  compstmt
		  kEND
		    {
			$$ = NEW_FOR($2, $5, $8);
		        fixpos($$, $2);
		    }
		| kCLASS cname superclass
		    {
			if (in_def || in_single)
			    yyerror("class definition in method body");
			class_nest++;
			local_push(0);
		        $<num>$ = ruby_sourceline;
		    }
		  bodystmt
		  kEND
		    {
		        $$ = NEW_CLASS($2, $5, $3);
		        nd_set_line($$, $<num>4);
		        local_pop();
			class_nest--;
		    }
		| kCLASS tLSHFT expr
		    {
			$<num>$ = in_def;
		        in_def = 0;
		    }
		  term
		    {
		        $<num>$ = in_single;
		        in_single = 0;
			class_nest++;
			local_push(0);
		    }
		  bodystmt
		  kEND
		    {
		        $$ = NEW_SCLASS($3, $7);
		        fixpos($$, $3);
		        local_pop();
			class_nest--;
		        in_def = $<num>4;
		        in_single = $<num>6;
		    }
		| kMODULE cname
		    {
			if (in_def || in_single)
			    yyerror("module definition in method body");
			class_nest++;
			local_push(0);
		        $<num>$ = ruby_sourceline;
		    }
		  bodystmt
		  kEND
		    {
		        $$ = NEW_MODULE($2, $4);
		        nd_set_line($$, $<num>3);
		        local_pop();
			class_nest--;
		    }
		| kDEF fname
		    {
			$<id>$ = cur_mid;
			cur_mid = $2;
			in_def++;
			local_push(0);
		    }
		  f_arglist
		  bodystmt
		  kEND
		    {
			$$ = NEW_DEFN($2, $4, $5, NOEX_PRIVATE);
			if (is_attrset_id($2)) $$->nd_noex = NOEX_PUBLIC;
		        fixpos($$, $4);
		        local_pop();
			in_def--;
			cur_mid = $<id>3;
		    }
		| kDEF singleton dot_or_colon {lex_state = EXPR_FNAME;} fname
		    {
			in_single++;
			local_push(0);
		        lex_state = EXPR_END; /* force for args */
		    }
		  f_arglist
		  bodystmt
		  kEND
		    {
			$$ = NEW_DEFS($2, $5, $7, $8);
		        fixpos($$, $2);
		        local_pop();
			in_single--;
		    }
		| kBREAK
		    {
			$$ = NEW_BREAK(0);
		    }
		| kNEXT
		    {
			$$ = NEW_NEXT(0);
		    }
		| kREDO
		    {
			$$ = NEW_REDO();
		    }
		| kRETRY
		    {
			$$ = NEW_RETRY();
		    }
		;

primary_value 	: primary
		    {
			value_expr($1);
			$$ = $1;
		    }
		;

then		: term
		| kTHEN
		| term kTHEN
		;

do		: term
		| kDO_COND
		;

if_tail		: opt_else
		| kELSIF expr_value then
		  compstmt
		  if_tail
		    {
			$$ = NEW_IF(cond($2), $4, $5);
		        fixpos($$, $2);
		    }
		;

opt_else	: none
		| kELSE compstmt
		    {
			$$ = $2;
		    }
		;

block_var	: lhs
		| mlhs
		;

opt_block_var	: none
		| '|' /* none */ '|'
		    {
			$$ = (NODE*)1;
		    }
		| tOROP
		    {
			$$ = (NODE*)1;
		    }
		| '|' block_var '|'
		    {
			$$ = $2;
		    }
		;

do_block	: kDO_BLOCK
		    {
		        $<vars>$ = dyna_push();
		    }
		  opt_block_var
		  compstmt
		  kEND
		    {
			$$ = NEW_ITER($3, 0, $4);
		        fixpos($$, $3?$3:$4);
			dyna_pop($<vars>2);
		    }
		| tLBRACE_ARG {$<vars>$ = dyna_push();}
		  opt_block_var
		  compstmt
		  '}'
		    {
			$$ = NEW_ITER($3, 0, $4);
		        fixpos($$, $3?$3:$4);
			dyna_pop($<vars>2);
		    }

		;

block_call	: command do_block
		    {
			if ($1 && nd_type($1) == NODE_BLOCK_PASS) {
			    rb_compile_error("both block arg and actual block given");
			}
			$2->nd_iter = $1;
			$$ = $2;
		        fixpos($$, $2);
		    }
		| block_call '.' operation2 opt_paren_args
		    {
			$$ = new_call($1, $3, $4);
		    }
		| block_call tCOLON2 operation2 opt_paren_args
		    {
			$$ = new_call($1, $3, $4);
		    }
		;

method_call	: operation paren_args
		    {
			$$ = new_fcall($1, $2);
		        fixpos($$, $2);
		    }
		| primary_value '.' operation2 opt_paren_args
		    {
			$$ = new_call($1, $3, $4);
		        fixpos($$, $1);
		    }
		| primary_value tCOLON2 operation2 paren_args
		    {
			$$ = new_call($1, $3, $4);
		        fixpos($$, $1);
		    }
		| primary_value tCOLON2 operation3
		    {
			$$ = new_call($1, $3, 0);
		    }
		| kSUPER paren_args
		    {
			$$ = new_super($2);
		    }
		| kSUPER
		    {
			$$ = NEW_ZSUPER();
		    }
		;

brace_block	: '{'
		    {
		        $<vars>$ = dyna_push();
		    }
		  opt_block_var
		  compstmt '}'
		    {
			$$ = NEW_ITER($3, 0, $4);
		        fixpos($$, $4);
			dyna_pop($<vars>2);
		    }
		| kDO
		    {
		        $<vars>$ = dyna_push();
		    }
		  opt_block_var
		  compstmt kEND
		    {
			$$ = NEW_ITER($3, 0, $4);
		        fixpos($$, $4);
			dyna_pop($<vars>2);
		    }
		;

case_body	: kWHEN when_args then
		  compstmt
		  cases
		    {
			$$ = NEW_WHEN($2, $4, $5);
		    }
		;

when_args	: args
		| args ',' tSTAR arg_value
		    {
			$$ = list_append($1, NEW_WHEN($4, 0, 0));
		    }
		| tSTAR arg_value
		    {
			$$ = NEW_LIST(NEW_WHEN($2, 0, 0));
		    }
		;

cases		: opt_else
		| case_body
		;

opt_rescue	: kRESCUE exc_list exc_var then
		  compstmt
		  opt_rescue
		    {
		        if ($3) {
		            $3 = node_assign($3, NEW_GVAR(rb_intern("$!")));
			    $5 = block_append($3, $5);
			}
			$$ = NEW_RESBODY($2, $5, $6);
		        fixpos($$, $2?$2:$5);
		    }
		| none
		;

exc_list	: args
		| none
		;

exc_var		: tASSOC lhs
		    {
			$$ = $2;
		    }
		| none
		;

opt_ensure	: kENSURE compstmt
		    {
			if ($2)
			    $$ = $2;
			else
			    /* place holder */
			    $$ = NEW_NIL();
		    }
		| none
		;

literal		: numeric
		| symbol
		    {
			$$ = NEW_LIT(ID2SYM($1));
		    }
		| dsym
		;

strings		: string
		    {
			NODE *node = $1;
			if (!node) {
			    node = NEW_STR(rb_str_new(0, 0));
			}
			$$ = node;
		    }
		;

string		: string1
		| string string1
		    {
			$$ = literal_concat($1, $2);
		    }
		;

string1		: tSTRING_BEG string_contents tSTRING_END
		    {
			$$ = $2;
		    }
		;

xstring		: tXSTRING_BEG xstring_contents tSTRING_END
		    {
			NODE *node = $2;
			if (!node) {
			    node = NEW_XSTR(rb_str_new(0, 0));
			}
			else {
			    switch (nd_type(node)) {
			      case NODE_STR:
				nd_set_type(node, NODE_XSTR);
				break;
			      case NODE_DSTR:
				nd_set_type(node, NODE_DXSTR);
				break;
			      default:
				node = rb_node_newnode(NODE_DXSTR, rb_str_new(0, 0),
						       1, NEW_LIST(node));
				break;
			    }
			}
			$$ = node;
		    }
		;

regexp		: tREGEXP_BEG xstring_contents tREGEXP_END
		    {
			int options = $3;
			NODE *node = $2;
			if (!node) {
			    node = NEW_LIT(rb_reg_new("", 0, options & ~RE_OPTION_ONCE));
			}
			else switch (nd_type(node)) {
			  case NODE_STR:
			    {
				VALUE src = node->nd_lit;
				nd_set_type(node, NODE_LIT);
				node->nd_lit = rb_reg_new(RSTRING(src)->ptr,
							  RSTRING(src)->len,
							  options & ~RE_OPTION_ONCE);
			    }
			    break;
			  default:
			    node = rb_node_newnode(NODE_DSTR, rb_str_new(0, 0),
						   1, NEW_LIST(node));
			  case NODE_DSTR:
			    if (options & RE_OPTION_ONCE) {
				nd_set_type(node, NODE_DREGX_ONCE);
			    }
			    else {
				nd_set_type(node, NODE_DREGX);
			    }
			    node->nd_cflag = options & ~RE_OPTION_ONCE;
			    break;
			}
			$$ = node;
		    }
		;

words		: tWORDS_BEG ' ' tSTRING_END
		    {
			$$ = NEW_ZARRAY();
		    }
		| tWORDS_BEG word_list tSTRING_END
		    {
			$$ = $2;
		    }
		;

word_list	: /* none */
		    {
			lex_strnest = 0;
			$$ = 0;
		    }
		| word_list word ' '
		    {
			$$ = list_append($1, $2);
		    }
		;

word		: string_content
		| word string_content
		    {
			$$ = literal_concat($1, $2);
		    }
		;

qwords		: tQWORDS_BEG ' ' tSTRING_END
		    {
			$$ = NEW_ZARRAY();
		    }
		| tQWORDS_BEG qword_list tSTRING_END
		    {
			$$ = $2;
		    }
		;

qword_list	: /* none */
		    {
			lex_strnest = 0;
			$$ = 0;
		    }
		| qword_list tSTRING_CONTENT ' '
		    {
			$$ = list_append($1, $2);
		    }
		;

string_contents : /* none */
		    {
			lex_strnest = 0;
			$$ = 0;
		    }
		| string_contents string_content
		    {
			$$ = literal_concat($1, $2);
		    }
		;

xstring_contents: /* none */
		    {
			lex_strnest = 0;
			$$ = 0;
		    }
		| xstring_contents string_content
		    {
			$$ = literal_concat($1, $2);
		    }
		;

string_content	: tSTRING_CONTENT
		| tSTRING_DVAR
		    {
			$<num>1 = lex_strnest;
			$<node>$ = lex_strterm;
			lex_strterm = 0;
			lex_state = EXPR_BEG;
		    }
		  string_dvar
		    {
			lex_strnest = $<num>1;
			lex_strterm = $<node>2;
		        $$ = NEW_EVSTR($3);
		    }
		| tSTRING_DBEG term_push
		    {
			$<num>1 = lex_strnest;
			$<node>$ = lex_strterm;
			lex_strterm = 0;
			lex_state = EXPR_BEG;
		    }
		  compstmt '}'
		    {
			lex_strnest = $<num>1;
			quoted_term = $2;
			lex_strterm = $<node>3;
			if (($$ = $4) && nd_type($$) == NODE_NEWLINE) {
			    $$ = $$->nd_next;
			    rb_gc_force_recycle((VALUE)$4);
			}
			$$ = new_evstr($$);
		    }
		;

string_dvar	: tGVAR {$$ = NEW_GVAR($1);}
		| tIVAR {$$ = NEW_IVAR($1);}
		| tCVAR {$$ = NEW_CVAR($1);}
		| backref
		;

term_push	: /* none */
		    {
			if (($$ = quoted_term) == -1 &&
			    nd_type(lex_strterm) == NODE_STRTERM &&
			    !lex_strterm->nd_paren) {
			    quoted_term = lex_strterm->nd_term;
			}
		    }
		;

symbol		: tSYMBEG sym
		    {
		        lex_state = EXPR_END;
			$$ = $2;
		    }
		;

sym		: fname
		| tIVAR
		| tGVAR
		| tCVAR
		;

dsym		: tSYMBEG xstring_contents tSTRING_END
		    {
		        lex_state = EXPR_END;
			if (!$2) {
			    yyerror("empty symbol literal");
			}
			else {
			    $$ = $2;
			    switch (nd_type($$)) {
			      case NODE_STR:
				$$->nd_lit = ID2SYM(rb_intern(RSTRING($$->nd_lit)->ptr));
				nd_set_type($$, NODE_LIT);
				break;
			      case NODE_DSTR:
				nd_set_type($$, NODE_DSYM);
				break;
			      default:
				$$ = rb_node_newnode(NODE_DSYM, rb_str_new(0, 0),
						     1, NEW_LIST($$));
				break;
			    }
			}
		    }
		;

numeric		: tINTEGER
		| tFLOAT
		;

variable	: tIDENTIFIER
		| tIVAR
		| tGVAR
		| tCONSTANT
		| tCVAR
		| kNIL {$$ = kNIL;}
		| kSELF {$$ = kSELF;}
		| kTRUE {$$ = kTRUE;}
		| kFALSE {$$ = kFALSE;}
		| k__FILE__ {$$ = k__FILE__;}
		| k__LINE__ {$$ = k__LINE__;}
		;

var_ref		: variable
		    {
			$$ = gettable($1);
		    }
		;

var_lhs		: variable
		    {
			$$ = assignable($1, 0);
		    }
		;

backref		: tNTH_REF
		| tBACK_REF
		;

superclass	: term
		    {
			$$ = 0;
		    }
		| '<'
		    {
			lex_state = EXPR_BEG;
		    }
		  expr_value term
		    {
			$$ = $3;
		    }
		| error term {yyerrok; $$ = 0;}
		;

f_arglist	: '(' f_args opt_nl ')'
		    {
			$$ = $2;
			lex_state = EXPR_BEG;
		    }
		| f_args term
		    {
			$$ = $1;
		    }
		;

f_args		: f_arg ',' f_optarg ',' f_rest_arg opt_f_block_arg
		    {
			$$ = block_append(NEW_ARGS($1, $3, $5), $6);
		    }
		| f_arg ',' f_optarg opt_f_block_arg
		    {
			$$ = block_append(NEW_ARGS($1, $3, -1), $4);
		    }
		| f_arg ',' f_rest_arg opt_f_block_arg
		    {
			$$ = block_append(NEW_ARGS($1, 0, $3), $4);
		    }
		| f_arg opt_f_block_arg
		    {
			$$ = block_append(NEW_ARGS($1, 0, -1), $2);
		    }
		| f_optarg ',' f_rest_arg opt_f_block_arg
		    {
			$$ = block_append(NEW_ARGS(0, $1, $3), $4);
		    }
		| f_optarg opt_f_block_arg
		    {
			$$ = block_append(NEW_ARGS(0, $1, -1), $2);
		    }
		| f_rest_arg opt_f_block_arg
		    {
			$$ = block_append(NEW_ARGS(0, 0, $1), $2);
		    }
		| f_block_arg
		    {
			$$ = block_append(NEW_ARGS(0, 0, -1), $1);
		    }
		| /* none */
		    {
			$$ = NEW_ARGS(0, 0, -1);
		    }
		;

f_norm_arg	: tCONSTANT
		    {
			yyerror("formal argument cannot be a constant");
		    }
                | tIVAR
		    {
                        yyerror("formal argument cannot be an instance variable");
		    }
                | tGVAR
		    {
                        yyerror("formal argument cannot be a global variable");
		    }
                | tCVAR
		    {
                        yyerror("formal argument cannot be a class variable");
		    }
		| tIDENTIFIER
		    {
			if (!is_local_id($1))
			    yyerror("formal argument must be local variable");
			else if (local_id($1))
			    yyerror("duplicate argument name");
			local_cnt($1);
			$$ = 1;
		    }
		;

f_arg		: f_norm_arg
		| f_arg ',' f_norm_arg
		    {
			$$ += 1;
		    }
		;

f_opt		: tIDENTIFIER '=' arg_value
		    {
			if (!is_local_id($1))
			    yyerror("formal argument must be local variable");
			else if (local_id($1))
			    yyerror("duplicate optional argument name");
			$$ = assignable($1, $3);
		    }
		;

f_optarg	: f_opt
		    {
			$$ = NEW_BLOCK($1);
			$$->nd_end = $$;
		    }
		| f_optarg ',' f_opt
		    {
			$$ = block_append($1, $3);
		    }
		;

f_rest_arg	: tSTAR tIDENTIFIER
		    {
			if (!is_local_id($2))
			    yyerror("rest argument must be local variable");
			else if (local_id($2))
			    yyerror("duplicate rest argument name");
			$$ = local_cnt($2);
		    }
		| tSTAR
		    {
			$$ = -2;
		    }
		;

f_block_arg	: tAMPER tIDENTIFIER
		    {
			if (!is_local_id($2))
			    yyerror("block argument must be local variable");
			else if (local_id($2))
			    yyerror("duplicate block argument name");
			$$ = NEW_BLOCK_ARG($2);
		    }
		;

opt_f_block_arg	: ',' f_block_arg
		    {
			$$ = $2;
		    }
		| none
		;

singleton	: var_ref
		    {
			if (nd_type($1) == NODE_SELF) {
			    $$ = NEW_SELF();
			}
			else {
			    $$ = $1;
		            value_expr($$);
			}
		    }
		| '(' {lex_state = EXPR_BEG;} expr opt_nl ')'
		    {
			if ($3 == 0) {
			    yyerror("can't define single method for ().");
			}
			else {
			    switch (nd_type($3)) {
			      case NODE_STR:
			      case NODE_DSTR:
			      case NODE_XSTR:
			      case NODE_DXSTR:
			      case NODE_DREGX:
			      case NODE_LIT:
			      case NODE_ARRAY:
			      case NODE_ZARRAY:
				yyerror("can't define single method for literals");
			      default:
				value_expr($3);
				break;
			    }
			}
			$$ = $3;
		    }
		;

assoc_list	: none
		| assocs trailer
		    {
			$$ = $1;
		    }
		| args trailer
		    {
			if ($1->nd_alen%2 != 0) {
			    yyerror("odd number list for Hash");
			}
			$$ = $1;
		    }
		;

assocs		: assoc
		| assocs ',' assoc
		    {
			$$ = list_concat($1, $3);
		    }
		;

assoc		: arg_value tASSOC arg_value
		    {
			$$ = list_append(NEW_LIST($1), $3);
		    }
		;

operation	: tIDENTIFIER
		| tCONSTANT
		| tFID
		;

operation2	: tIDENTIFIER
		| tCONSTANT
		| tFID
		| op
		;

operation3	: tIDENTIFIER
		| tFID
		| op
		;

dot_or_colon	: '.'
		| tCOLON2
		;

opt_terms	: /* none */
		| terms
		;

opt_nl		: /* none */
		| '\n'
		;

trailer		: /* none */
		| '\n'
		| ','
		;

term		: ';' {yyerrok;}
		| '\n'
		;

terms		: term
		| terms ';' {yyerrok;}
		;

none		: /* none */ {$$ = 0;}
		;
%%
#include "regex.h"
#include "util.h"

/* We remove any previous definition of `SIGN_EXTEND_CHAR',
   since ours (we hope) works properly with all combinations of
   machines, compilers, `char' and `unsigned char' argument types.
   (Per Bothner suggested the basic approach.)  */
#undef SIGN_EXTEND_CHAR
#if __STDC__
# define SIGN_EXTEND_CHAR(c) ((signed char)(c))
#else  /* not __STDC__ */
/* As in Harbison and Steele.  */
# define SIGN_EXTEND_CHAR(c) ((((unsigned char)(c)) ^ 128) - 128)
#endif
#define is_identchar(c) (SIGN_EXTEND_CHAR(c)!=-1&&(ISALNUM(c) || (c) == '_' || ismbchar(c)))

static char *tokenbuf = NULL;
static int   tokidx, toksiz = 0;

#define LEAVE_BS 1

static VALUE (*lex_gets)();	/* gets function */
static VALUE lex_input;		/* non-nil if File */
static VALUE lex_lastline;	/* gc protect */
static char *lex_pbeg;
static char *lex_p;
static char *lex_pend;

static int
yyerror(msg)
    char *msg;
{
    char *p, *pe, *buf;
    int len, i;

    rb_compile_error("%s", msg);
    p = lex_p;
    while (lex_pbeg <= p) {
	if (*p == '\n') break;
	p--;
    }
    p++;

    pe = lex_p;
    while (pe < lex_pend) {
	if (*pe == '\n') break;
	pe++;
    }

    len = pe - p;
    if (len > 4) {
	buf = ALLOCA_N(char, len+2);
	MEMCPY(buf, p, char, len);
	buf[len] = '\0';
	rb_compile_error_append("%s", buf);

	i = lex_p - p;
	p = buf; pe = p + len;

	while (p < pe) {
	    if (*p != '\t') *p = ' ';
	    p++;
	}
	buf[i] = '^';
	buf[i+1] = '\0';
	rb_compile_error_append("%s", buf);
    }

    return 0;
}

static int heredoc_end;
static int command_start = Qtrue;

int ruby_in_compile = 0;
int ruby__end__seen;

static VALUE ruby_debug_lines;

static NODE*
yycompile(f, line)
    char *f;
    int line;
{
    int n;
    NODE *node = 0;
    struct RVarmap *vp, *vars = ruby_dyna_vars;

    ruby_in_compile = 1;
    if (!compile_for_eval && rb_safe_level() == 0 &&
	rb_const_defined(rb_cObject, rb_intern("SCRIPT_LINES__"))) {
	VALUE hash, fname;

	hash = rb_const_get(rb_cObject, rb_intern("SCRIPT_LINES__"));
	if (TYPE(hash) == T_HASH) {
	    fname = rb_str_new2(f);
	    ruby_debug_lines = rb_hash_aref(hash, fname);
	    if (NIL_P(ruby_debug_lines)) {
		ruby_debug_lines = rb_ary_new();
		rb_hash_aset(hash, fname, ruby_debug_lines);
	    }
	}
	if (line > 1) {
	    VALUE str = rb_str_new(0,0);
	    while (line > 1) {
		rb_ary_push(ruby_debug_lines, str);
		line--;
	    }
	}
    }

    ruby__end__seen = 0;
    ruby_eval_tree = 0;
    heredoc_end = 0;
    lex_strterm = 0;
    lex_strnest = 0;
    quoted_term = -1;
    ruby_current_node = 0;
    ruby_sourcefile = rb_source_filename(f);
    n = yyparse();
    ruby_debug_lines = 0;
    compile_for_eval = 0;
    ruby_in_compile = 0;
    cond_stack = 0;
    cmdarg_stack = 0;
    command_start = 1;		  
    class_nest = 0;
    in_single = 0;
    in_def = 0;
    cur_mid = 0;

    vp = ruby_dyna_vars;
    ruby_dyna_vars = vars;
    lex_strterm = 0;
    while (vp && vp != vars) {
	struct RVarmap *tmp = vp;
	vp = vp->next;
	rb_gc_force_recycle((VALUE)tmp);
    }
    if (n == 0) node = ruby_eval_tree;
    return node;
}

static int lex_gets_ptr;

static VALUE
lex_get_str(s)
    VALUE s;
{
    char *beg, *end, *pend;

    beg = RSTRING(s)->ptr;
    if (lex_gets_ptr) {
	if (RSTRING(s)->len == lex_gets_ptr) return Qnil;
	beg += lex_gets_ptr;
    }
    pend = RSTRING(s)->ptr + RSTRING(s)->len;
    end = beg;
    while (end < pend) {
	if (*end++ == '\n') break;
    }
    lex_gets_ptr = end - RSTRING(s)->ptr;
    return rb_str_new(beg, end - beg);
}

static VALUE
lex_getline()
{
    VALUE line = (*lex_gets)(lex_input);
    if (ruby_debug_lines && !NIL_P(line)) {
	rb_ary_push(ruby_debug_lines, line);
    }
    return line;
}

NODE*
rb_compile_string(f, s, line)
    const char *f;
    VALUE s;
    int line;
{
    lex_gets = lex_get_str;
    lex_gets_ptr = 0;
    lex_input = s;
    lex_pbeg = lex_p = lex_pend = 0;
    ruby_sourceline = line - 1;
    compile_for_eval = ruby_in_eval;

    return yycompile(f, line);
}

NODE*
rb_compile_cstr(f, s, len, line)
    const char *f, *s;
    int len, line;
{
    return rb_compile_string(f, rb_str_new(s, len), line);
}

NODE*
rb_compile_file(f, file, start)
    const char *f;
    VALUE file;
    int start;
{
    lex_gets = rb_io_gets;
    lex_input = file;
    lex_pbeg = lex_p = lex_pend = 0;
    ruby_sourceline = start - 1;

    return yycompile(f, start);
}

static inline int
nextc()
{
    int c;

    if (lex_p == lex_pend) {
	if (lex_input) {
	    VALUE v = lex_getline();

	    if (NIL_P(v)) return -1;
	    if (heredoc_end > 0) {
		ruby_sourceline = heredoc_end;
		heredoc_end = 0;
	    }
	    ruby_sourceline++;
	    lex_pbeg = lex_p = RSTRING(v)->ptr;
	    lex_pend = lex_p + RSTRING(v)->len;
	    lex_lastline = v;
	}
	else {
	    lex_lastline = 0;
	    return -1;
	}
    }
    c = (unsigned char)*lex_p++;
    if (c == '\r' && lex_p <= lex_pend && *lex_p == '\n') {
	lex_p++;
	c = '\n';
    }

    return c;
}

static void
pushback(c)
    int c;
{
    if (c == -1) return;
    lex_p--;
}

#define peek(c) (lex_p != lex_pend && (c) == *lex_p)

#define tokfix() (tokenbuf[tokidx]='\0')
#define tok() tokenbuf
#define toklen() tokidx
#define toklast() (tokidx>0?tokenbuf[tokidx-1]:0)

static char*
newtok()
{
    tokidx = 0;
    if (!tokenbuf) {
	toksiz = 60;
	tokenbuf = ALLOC_N(char, 60);
    }
    if (toksiz > 4096) {
	toksiz = 60;
	REALLOC_N(tokenbuf, char, 60);
    }
    return tokenbuf;
}

static void
tokadd(c)
    char c;
{
    tokenbuf[tokidx++] = c;
    if (tokidx >= toksiz) {
	toksiz *= 2;
	REALLOC_N(tokenbuf, char, toksiz);
    }
}

static int
read_escape()
{
    int c;

    switch (c = nextc()) {
      case '\\':	/* Backslash */
	return c;

      case 'n':	/* newline */
	return '\n';

      case 't':	/* horizontal tab */
	return '\t';

      case 'r':	/* carriage-return */
	return '\r';

      case 'f':	/* form-feed */
	return '\f';

      case 'v':	/* vertical tab */
	return '\13';

      case 'a':	/* alarm(bell) */
	return '\007';

      case 'e':	/* escape */
	return 033;

      case '0': case '1': case '2': case '3': /* octal constant */
      case '4': case '5': case '6': case '7':
	{
	    int numlen;

	    pushback(c);
	    c = scan_oct(lex_p, 3, &numlen);
	    lex_p += numlen;
	}
	return c;

      case 'x':	/* hex constant */
	{
	    int numlen;

	    c = scan_hex(lex_p, 2, &numlen);
	    if (numlen == 0) {
		yyerror("Invalid escape character syntax");
		return 0;
	    }
	    lex_p += numlen;
	}
	return c;

      case 'b':	/* backspace */
	return '\010';

      case 's':	/* space */
	return ' ';

      case 'M':
	if ((c = nextc()) != '-') {
	    yyerror("Invalid escape character syntax");
	    pushback(c);
	    return '\0';
	}
	if ((c = nextc()) == '\\') {
	    return read_escape() | 0x80;
	}
	else if (c == -1) goto eof;
	else {
	    return ((c & 0xff) | 0x80);
	}

      case 'C':
	if ((c = nextc()) != '-') {
	    yyerror("Invalid escape character syntax");
	    pushback(c);
	    return '\0';
	}
      case 'c':
	if ((c = nextc())== '\\') {
	    c = read_escape();
	}
	else if (c == '?')
	    return 0177;
	else if (c == -1) goto eof;
	return c & 0x9f;

      eof:
      case -1:
        yyerror("Invalid escape character syntax");
	return '\0';

      default:
	return c;
    }
}

static int
tokadd_escape(term)
    int term;
{
    int c;

    switch (c = nextc()) {
      case '\n':
	return 0;		/* just ignore */

      case '0': case '1': case '2': case '3': /* octal constant */
      case '4': case '5': case '6': case '7':
	{
	    int i;

	    tokadd('\\');
	    tokadd(c);
	    for (i=0; i<2; i++) {
		c = nextc();
		if (c == -1) goto eof;
		if (c < '0' || '7' < c) {
		    pushback(c);
		    break;
		}
		tokadd(c);
	    }
	}
	return 0;

      case 'x':	/* hex constant */
	{
	    int numlen;

	    tokadd('\\');
	    tokadd(c);
	    scan_hex(lex_p, 2, &numlen);
	    if (numlen == 0) {
		yyerror("Invalid escape character syntax");
		return -1;
	    }
	    while (numlen--)
		tokadd(nextc());
	}
	return 0;

      case 'M':
	if ((c = nextc()) != '-') {
	    yyerror("Invalid escape character syntax");
	    pushback(c);
	    return 0;
	}
	tokadd('\\'); tokadd('M'); tokadd('-');
	goto escaped;

      case 'C':
	if ((c = nextc()) != '-') {
	    yyerror("Invalid escape character syntax");
	    pushback(c);
	    return 0;
	}
	tokadd('\\'); tokadd('C'); tokadd('-');
	goto escaped;

      case 'c':
	tokadd('\\'); tokadd('c');
      escaped:
	if ((c = nextc()) == '\\') {
	    return tokadd_escape(term);
	}
	else if (c == -1) goto eof;
	tokadd(c);
	return 0;

      eof:
      case -1:
        yyerror("Invalid escape character syntax");
	return -1;

      default:
	if (c != '\\' || c != term)
	    tokadd('\\');
	tokadd(c);
    }
    return 0;
}

static int
regx_options()
{
    char kcode = 0;
    int options = 0;
    int c;

    newtok();
    while (c = nextc(), ISALPHA(c)) {
	switch (c) {
	  case 'i':
	    options |= RE_OPTION_IGNORECASE;
	    break;
	  case 'x':
	    options |= RE_OPTION_EXTENDED;
	    break;
	  case 'm':
	    options |= RE_OPTION_MULTILINE;
	    break;
	  case 'o':
	    options |= RE_OPTION_ONCE;
	    break;
	  case 'n':
	    kcode = 16;
	    break;
	  case 'e':
	    kcode = 32;
	    break;
	  case 's':
	    kcode = 48;
	    break;
	  case 'u':
	    kcode = 64;
	    break;
	  default:
	    tokadd(c);
	    break;
	}
    }
    pushback(c);
    if (toklen()) {
	tokfix();
	rb_compile_error("unknown regexp option%s - %s",
			 toklen() > 1 ? "s" : "", tok());
    }
    return options | kcode;
}

#define STR_FUNC_ESCAPE 0x01
#define STR_FUNC_EXPAND 0x02
#define STR_FUNC_REGEXP 0x04
#define STR_FUNC_QWORDS 0x08
#define STR_FUNC_SYMBOL 0x10
#define STR_FUNC_INDENT 0x20

enum string_type {
    str_squote = (0),
    str_dquote = (STR_FUNC_EXPAND),
    str_xquote = (STR_FUNC_ESCAPE|STR_FUNC_EXPAND),
    str_regexp = (STR_FUNC_REGEXP|STR_FUNC_ESCAPE|STR_FUNC_EXPAND),
    str_sword  = (STR_FUNC_QWORDS),
    str_dword  = (STR_FUNC_QWORDS|STR_FUNC_EXPAND),
    str_ssym   = (STR_FUNC_SYMBOL),
    str_dsym   = (STR_FUNC_SYMBOL|STR_FUNC_EXPAND),
};

static int
tokadd_string(func, term, paren)
    int func, term, paren;
{
    int c;

    while ((c = nextc()) != -1) {
	if (paren && c == paren) {
	    lex_strnest++;
	}
	else if (c == term) {
	    if (!lex_strnest) {
		pushback(c);
		break;
	    }
	    --lex_strnest;
	}
	else if ((func & STR_FUNC_EXPAND) && c == '#' && lex_p < lex_pend) {
	    int c2 = *lex_p;
	    if (c2 == '$' || c2 == '@@' || c2 == '{') {
		pushback(c);
		break;
	    }
	}
	else if (c == '\\') {
	    c = nextc();
	    if (QUOTED_TERM_P(c)) {
		pushback(c);
		return c;
	    }
	    switch (c) {
	      case '\n':
		continue;

	      case '\\':
		if (func & STR_FUNC_ESCAPE) tokadd(c);
		break;

	      default:
		if (func & STR_FUNC_REGEXP) {
		    pushback(c);
		    if (tokadd_escape(term) < 0)
			return -1;
		    continue;
		}
		else if (func & STR_FUNC_EXPAND) {
		    pushback(c);
		    if (func & STR_FUNC_ESCAPE) tokadd('\\');
		    c = read_escape();
		}
		else if ((func & STR_FUNC_QWORDS) && ISSPACE(c)) {
		    /* ignore backslashed spaces in %w */
		}
		else if (c != term && !(paren && c == paren)) {
		    tokadd('\\');
		}
	    }
	}
	else if (ismbchar(c)) {
	    int i, len = mbclen(c)-1;

	    for (i = 0; i < len; i++) {
		tokadd(c);
		c = nextc();
	    }
	}
	else if ((func & STR_FUNC_QWORDS) && ISSPACE(c)) {
	    pushback(c);
	    break;
	}
	if (!c && (func & STR_FUNC_SYMBOL)) {
	    func &= ~STR_FUNC_SYMBOL;
	    rb_compile_error("symbol cannot contain '\\0'");
	    continue;
	}
	tokadd(c);
    }
    return c;
}

#define NEW_STRTERM(func, term, paren) \
	rb_node_newnode(NODE_STRTERM, (func), (term), (paren))

static int
parse_string(quote)
    NODE *quote;
{
    int func = quote->nd_func;
    int term = quote->nd_term;
    int paren = quote->nd_paren;
    int c, space = 0;

    if (func == -1) return tSTRING_END;
    c = nextc();
    if ((func & STR_FUNC_QWORDS) && ISSPACE(c)) {
	do {c = nextc();} while (ISSPACE(c));
	space = 1;
    }
    if (c == term) {
	if (!lex_strnest) {
	  eos:
	    if (func & STR_FUNC_QWORDS) {
		quote->nd_func = -1;
		return ' ';
	    }
	    if (!(func & STR_FUNC_REGEXP)) return tSTRING_END;
	    yylval.num = regx_options();
	    return tREGEXP_END;
	}
    }
    if (c == '\\' && WHEN_QUOTED_TERM(peek(quoted_term_char))) {
	if ((c = nextc()) == term) goto eos;
    }
    if (space) {
	pushback(c);
	return ' ';
    }
    newtok();
    if ((func & STR_FUNC_EXPAND) && c == '#') {
	switch (c = nextc()) {
	  case '$':
	  case '@@':
	    pushback(c);
	    return tSTRING_DVAR;
	  case '{':
	    return tSTRING_DBEG;
	}
	tokadd('#');
    }
    pushback(c);
    if (tokadd_string(func, term, paren) == -1) {
	ruby_sourceline = nd_line(quote);
	rb_compile_error("unterminated string meets end of file");
	return tSTRING_END;
    }

    tokfix();
    yylval.node = NEW_STR(rb_str_new(tok(), toklen()));
    return tSTRING_CONTENT;
}

static int
heredoc_identifier()
{
    int c = nextc(), term, func = 0, len;

    if (c == '-') {
	c = nextc();
	if (ISSPACE(c)) {
	    pushback(c);
	    pushback('-');
	    return 0;
	}
	func = STR_FUNC_INDENT;
    }
    else if (ISSPACE(c)) {
      not_heredoc:
	pushback(c);
	return 0;
    }
    switch (c) {
      case '\'':
	func |= str_squote; goto quoted;
      case '"':
	func |= str_dquote; goto quoted;
      case '`':
	func |= str_xquote;
      quoted:
	newtok();
	tokadd(func);
	term = c;
	while ((c = nextc()) != -1 && c != term) {
	    len = mbclen(c);
	    do {tokadd(c);} while (--len > 0 && (c = nextc()) != -1);
	}
	if (c == -1) {
	    rb_compile_error("unterminated here document identifier");
	    return 0;
	}
	break;

      default:
	if (!is_identchar(c)) goto not_heredoc;
	newtok();
	term = '"';
	tokadd(func |= str_dquote);
	do {
	    len = mbclen(c);
	    do {tokadd(c);} while (--len > 0 && (c = nextc()) != -1);
	} while ((c = nextc()) != -1 && is_identchar(c));
	pushback(c);
	break;
    }

    tokfix();
    len = lex_p - lex_pbeg;
    lex_p = lex_pend;
    lex_strterm = rb_node_newnode(NODE_HEREDOC,
				  rb_str_new(tok(), toklen()),	/* nd_lit */
				  len,				/* nd_nth */
				  lex_lastline);		/* nd_orig */
    return term == '`' ? tXSTRING_BEG : tSTRING_BEG;
}

static void
heredoc_restore(here)
    NODE *here;
{
    VALUE line = here->nd_orig;
    lex_lastline = line;
    lex_pbeg = RSTRING(line)->ptr;
    lex_pend = lex_pbeg + RSTRING(line)->len;
    lex_p = lex_pbeg + here->nd_nth;
    heredoc_end = ruby_sourceline;
    ruby_sourceline = nd_line(here);
    rb_gc_force_recycle(here->nd_lit);
    rb_gc_force_recycle((VALUE)here);
}

static int
whole_match_p(eos, len, indent)
    char *eos;
    int len, indent;
{
    char *p = lex_pbeg;

    if (indent) {
	while (*p && ISSPACE(*p)) p++;
    }
    if (strncmp(eos, p, len) == 0) {
	if (p[len] == '\n' || p[len] == '\r') return Qtrue;
	if (p + len == lex_pend) return Qtrue;
    }
    return Qfalse;
}

static int
here_document(here)
    NODE *here;
{
    int c, func, indent = 0;
    char *eos;
    long len;
    VALUE str = 0, line;

    eos = RSTRING(here->nd_lit)->ptr;
    len = RSTRING(here->nd_lit)->len - 1;
    indent = (func = *eos++) & STR_FUNC_INDENT;

    if ((c = nextc()) == -1) {
      error:
	rb_compile_error("can't find string \"%s\" anywhere before EOF", eos);
	heredoc_restore(lex_strterm);
	lex_strterm = 0;
	return 0;
    }
    if (lex_p - 1 == lex_pbeg && whole_match_p(eos, len, indent)) {
	heredoc_restore(lex_strterm);
	return tSTRING_END;
    }

    if (!(func & STR_FUNC_EXPAND)) {
	do {
	    line = lex_lastline;
	    if (str)
		rb_str_cat(str, RSTRING(line)->ptr, RSTRING(line)->len);
	    else
		str = rb_str_new(RSTRING(line)->ptr, RSTRING(line)->len);
	    lex_p = lex_pend;
	    if (nextc() == -1) {
		if (str) rb_gc_force_recycle(str);
		goto error;
	    }
	} while (!whole_match_p(eos, len, indent));
    }
    else {
	newtok();
	if (c == '#') {
	    switch (c = nextc()) {
	      case '$':
	      case '@@':
		pushback(c);
		return tSTRING_DVAR;
	      case '{':
		return tSTRING_DBEG;
	    }
	    tokadd('#');
	}
	do {
	    pushback(c);
	    if ((c = tokadd_string(func, '\n', 0)) == -1) goto error;
	    if (c != '\n') {
		yylval.node = NEW_STR(rb_str_new(tok(), toklen()));
		return tSTRING_CONTENT;
	    }
	    tokadd(nextc());
	    if ((c = nextc()) == -1) goto error;
	} while (!whole_match_p(eos, len, indent));
	str = rb_str_new(tok(), toklen());
    }
    heredoc_restore(lex_strterm);
    lex_strterm = NEW_STRTERM(-1, 0, 0);
    yylval.node = NEW_STR(str);
    return tSTRING_CONTENT;
}

#include "lex.c"

static void
arg_ambiguous()
{
    rb_warning("ambiguous first argument; make sure");
}

#if !defined(strtod) && !defined(HAVE_STDLIB_H)
double strtod ();
#endif

#define IS_ARG() (lex_state == EXPR_ARG || lex_state == EXPR_CMDARG)

static int
yylex()
{
    static ID last_id = 0;
    register int c;
    int space_seen = 0;
    int cmd_state;

    if (lex_strterm) {
	int token;
	if (nd_type(lex_strterm) == NODE_HEREDOC) {
	    token = here_document(lex_strterm);
	    if (token == tSTRING_END) {
		lex_strterm = 0;
		lex_state = EXPR_END;
	    }
	}
	else {
	    token = parse_string(lex_strterm);
	    if (token == tSTRING_END || token == tREGEXP_END) {
		rb_gc_force_recycle((VALUE)lex_strterm);
		lex_strterm = 0;
		lex_state = EXPR_END;
	    }
	}
	return token;
    }
    cmd_state = command_start;
    command_start = Qfalse;
  retry:
    switch (c = nextc()) {
      case '\0':		/* NUL */
      case '\004':		/* ^D */
      case '\032':		/* ^Z */
      case -1:			/* end of script. */
	return 0;

	/* white spaces */
      case ' ': case '\t': case '\f': case '\r':
      case '\13': /* '\v' */
	space_seen++;
	goto retry;

      case '#':		/* it's a comment */
	while ((c = nextc()) != '\n') {
	    if (c == -1)
		return 0;
	}
	/* fall through */
      case '\n':
	switch (lex_state) {
	  case EXPR_BEG:
	  case EXPR_FNAME:
	  case EXPR_DOT:
	  case EXPR_CLASS:
	    goto retry;
	  default:
	    break;
	}
	command_start = Qtrue;
	lex_state = EXPR_BEG;
	return '\n';

      case '*':
	if ((c = nextc()) == '*') {
	    if ((c = nextc()) == '=') {
		yylval.id = tPOW;
		lex_state = EXPR_BEG;
		return tOP_ASGN;
	    }
	    pushback(c);
	    c = tPOW;
	}
	else {
	    if (c == '=') {
		yylval.id = '*';
		lex_state = EXPR_BEG;
		return tOP_ASGN;
	    }
	    pushback(c);
	    if (IS_ARG() && space_seen && !ISSPACE(c)){
		rb_warning("`*' interpreted as argument prefix");
		c = tSTAR;
	    }
	    else if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
		c = tSTAR;
	    }
	    else {
		c = '*';
	    }
	}
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
	return c;

      case '!':
	lex_state = EXPR_BEG;
	if ((c = nextc()) == '=') {
	    return tNEQ;
	}
	if (c == '~') {
	    return tNMATCH;
	}
	pushback(c);
	return '!';

      case '=':
	if (lex_p == lex_pbeg + 1) {
	    /* skip embedded rd document */
	    if (strncmp(lex_p, "begin", 5) == 0 && ISSPACE(lex_p[5])) {
		for (;;) {
		    lex_p = lex_pend;
		    c = nextc();
		    if (c == -1) {
			rb_compile_error("embedded document meets end of file");
			return 0;
		    }
		    if (c != '=') continue;
		    if (strncmp(lex_p, "end", 3) == 0 &&
			(lex_p + 3 == lex_pend || ISSPACE(lex_p[3]))) {
			break;
		    }
		}
		lex_p = lex_pend;
		goto retry;
	    }
	}

	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
	if ((c = nextc()) == '=') {
	    if ((c = nextc()) == '=') {
		return tEQQ;
	    }
	    pushback(c);
	    return tEQ;
	}
	if (c == '~') {
	    return tMATCH;
	}
	else if (c == '>') {
	    return tASSOC;
	}
	pushback(c);
	return '=';

      case '<':
	c = nextc();
	if (c == '<' &&
	    lex_state != EXPR_END &&
	    lex_state != EXPR_DOT &&
	    lex_state != EXPR_ENDARG && 
	    lex_state != EXPR_CLASS &&
	    (!IS_ARG() || space_seen)) {
	    int token = heredoc_identifier();
	    if (token) return token;
	}
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
	if (c == '=') {
	    if ((c = nextc()) == '>') {
		return tCMP;
	    }
	    pushback(c);
	    return tLEQ;
	}
	if (c == '<') {
	    if ((c = nextc()) == '=') {
		yylval.id = tLSHFT;
		lex_state = EXPR_BEG;
		return tOP_ASGN;
	    }
	    pushback(c);
	    return tLSHFT;
	}
	pushback(c);
	return '<';

      case '>':
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
	if ((c = nextc()) == '=') {
	    return tGEQ;
	}
	if (c == '>') {
	    if ((c = nextc()) == '=') {
		yylval.id = tRSHFT;
		lex_state = EXPR_BEG;
		return tOP_ASGN;
	    }
	    pushback(c);
	    return tRSHFT;
	}
	pushback(c);
	return '>';

      case '"':
	lex_strterm = NEW_STRTERM(str_dquote, '"', 0);
	return tSTRING_BEG;

      case '`':
	if (lex_state == EXPR_FNAME) {
	    lex_state = EXPR_END;
	    return c;
	}
	if (lex_state == EXPR_DOT) {
	    if (cmd_state)
		lex_state = EXPR_CMDARG;
	    else
		lex_state = EXPR_ARG;
	    return c;
	}
	lex_strterm = NEW_STRTERM(str_xquote, '`', 0);
	return tXSTRING_BEG;

      case '\'':
	lex_strterm = NEW_STRTERM(str_squote, '\'', 0);
	return tSTRING_BEG;

      case '?':
	if (lex_state == EXPR_END || lex_state == EXPR_ENDARG) {
	    lex_state = EXPR_BEG;
	    return '?';
	}
	c = nextc();
	if (c == -1) {
	    rb_compile_error("incomplete character syntax");
	    return 0;
	}
	if (ISSPACE(c)){
	    if (!IS_ARG()){
		int c2 = 0;
		switch (c) {
		  case ' ':
		    c2 = 's';
		    break;
		  case '\n':
		    c2 = 'n';
		    break;
		  case '\t':
		    c2 = 't';
		    break;
		  case '\v':
		    c2 = 'v';
		    break;
		  case '\r':
		    c2 = 'r';
		    break;
		  case '\f':
		    c2 = 'f';
		    break;
		}
		if (c2) {
		    rb_warn("invalid character syntax; use ?\\%c", c2);
		}
	    }
	  ternary:
	    pushback(c);
	    lex_state = EXPR_BEG;
	    return '?';
	}
	else if (ismbchar(c)) {
	    rb_warn("multibyte character literal not supported yet; use ?\\%.3o", c);
	    goto ternary;
	}
	else if ((ISALNUM(c) || c == '_') && lex_p < lex_pend && is_identchar(*lex_p)) {
	    goto ternary;
	}
	else if (c == '\\') {
	    c = read_escape();
	}
	c &= 0xff;
	lex_state = EXPR_END;
	yylval.node = NEW_LIT(INT2FIX(c));
	return tINTEGER;

      case '&':
	if ((c = nextc()) == '&') {
	    lex_state = EXPR_BEG;
	    if ((c = nextc()) == '=') {
		yylval.id = tANDOP;
		lex_state = EXPR_BEG;
		return tOP_ASGN;
	    }
	    pushback(c);
	    return tANDOP;
	}
	else if (c == '=') {
	    yylval.id = '&';
	    lex_state = EXPR_BEG;
	    return tOP_ASGN;
	}
	pushback(c);
	if (IS_ARG() && space_seen && !ISSPACE(c)){
	    rb_warning("`&' interpreted as argument prefix");
	    c = tAMPER;
	}
	else if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
	    c = tAMPER;
	}
	else {
	    c = '&';
	}
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG;
	}
	return c;

      case '|':
	if ((c = nextc()) == '|') {
	    lex_state = EXPR_BEG;
	    if ((c = nextc()) == '=') {
		yylval.id = tOROP;
		lex_state = EXPR_BEG;
		return tOP_ASGN;
	    }
	    pushback(c);
	    return tOROP;
	}
	if (c == '=') {
	    yylval.id = '|';
	    lex_state = EXPR_BEG;
	    return tOP_ASGN;
	}
	if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
	    lex_state = EXPR_ARG;
	}
	else {
	    lex_state = EXPR_BEG;
	}
	pushback(c);
	return '|';

      case '+':
	c = nextc();
	if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
	    lex_state = EXPR_ARG;
	    if (c == '@@') {
		return tUPLUS;
	    }
	    pushback(c);
	    return '+';
	}
	if (c == '=') {
	    yylval.id = '+';
	    lex_state = EXPR_BEG;
	    return tOP_ASGN;
	}
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID ||
	    (IS_ARG() && space_seen && !ISSPACE(c))) {
	    if (IS_ARG()) arg_ambiguous();
	    lex_state = EXPR_BEG;
	    pushback(c);
	    if (ISDIGIT(c)) {
		c = '+';
		goto start_num;
	    }
	    return tUPLUS;
	}
	lex_state = EXPR_BEG;
	pushback(c);
	return '+';

      case '-':
	c = nextc();
	if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
	    lex_state = EXPR_ARG;
	    if (c == '@@') {
		return tUMINUS;
	    }
	    pushback(c);
	    return '-';
	}
	if (c == '=') {
	    yylval.id = '-';
	    lex_state = EXPR_BEG;
	    return tOP_ASGN;
	}
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID ||
	    (IS_ARG() && space_seen && !ISSPACE(c))) {
	    if (IS_ARG()) arg_ambiguous();
	    lex_state = EXPR_BEG;
	    pushback(c);
	    if (ISDIGIT(c)) {
		c = '-';
		goto start_num;
	    }
	    return tUMINUS;
	}
	lex_state = EXPR_BEG;
	pushback(c);
	return '-';

      case '.':
	lex_state = EXPR_BEG;
	if ((c = nextc()) == '.') {
	    if ((c = nextc()) == '.') {
		return tDOT3;
	    }
	    pushback(c);
	    return tDOT2;
	}
	pushback(c);
	if (!ISDIGIT(c)) {
	    lex_state = EXPR_DOT;
	    return '.';
	}
	c = '.';
	/* fall through */

      start_num:
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9':
	{
	    int is_float, seen_point, seen_e, nondigit;

	    is_float = seen_point = seen_e = nondigit = 0;
	    lex_state = EXPR_END;
	    newtok();
	    if (c == '-' || c == '+') {
		tokadd(c);
		c = nextc();
	    }
	    if (c == '0') {
		int start = toklen();
		c = nextc();
		if (c == 'x' || c == 'X') {
		    /* hexadecimal */
		    c = nextc();
		    if (ISXDIGIT(c)) {
			do {
			    if (c == '_') {
				if (nondigit) break;
				nondigit = c;
				continue;
			    }
			    if (!ISXDIGIT(c)) break;
			    nondigit = 0;
			    tokadd(c);
			} while ((c = nextc()) != -1);
		    }
		    pushback(c);
		    tokfix();
		    if (toklen() == start) {
			yyerror("numeric literal without digits");
		    }
		    else if (nondigit) goto trailing_uc;
		    yylval.node = NEW_LIT(rb_cstr_to_inum(tok(), 16, Qfalse));
		    return tINTEGER;
		}
		if (c == 'b' || c == 'B') {
		    /* binary */
		    c = nextc();
		    if (c == '0' || c == '1') {
			do {
			    if (c == '_') {
				if (nondigit) break;
				nondigit = c;
				continue;
			    }
			    if (c != '0' && c != '1') break;
			    nondigit = 0;
			    tokadd(c);
			} while ((c = nextc()) != -1);
		    }
		    pushback(c);
		    tokfix();
		    if (toklen() == start) {
			yyerror("numeric literal without digits");
		    }
		    else if (nondigit) goto trailing_uc;
		    yylval.node = NEW_LIT(rb_cstr_to_inum(tok(), 2, Qfalse));
		    return tINTEGER;
		}
		if (c == 'd' || c == 'D') {
		    /* decimal */
		    c = nextc();
		    if (ISDIGIT(c)) {
			do {
			    if (c == '_') {
				if (nondigit) break;
				nondigit = c;
				continue;
			    }
			    if (!ISDIGIT(c)) break;
			    nondigit = 0;
			    tokadd(c);
			} while ((c = nextc()) != -1);
		    }
		    pushback(c);
		    tokfix();
		    if (toklen() == start) {
			yyerror("numeric literal without digits");
		    }
		    else if (nondigit) goto trailing_uc;
		    yylval.node = NEW_LIT(rb_cstr_to_inum(tok(), 10, Qfalse));
		    return tINTEGER;
		}
		if (c == '_') {
		    /* 0_0 */
		    goto octal_number;
		}
		if (c == 'o' || c == 'O') {
		    /* prefixed octal */
		    c = nextc();
		    if (c == '_') {
			yyerror("numeric literal without digits");
		    }
		}
		if (c >= '0' && c <= '7') {
		    /* octal */
		  octal_number:
	            do {
			if (c == '_') {
			    if (nondigit) break;
			    nondigit = c;
			    continue;
			}
			if (c < '0' || c > '7') break;
			nondigit = 0;
			tokadd(c);
		    } while ((c = nextc()) != -1);
		    if (toklen() > start) {
			pushback(c);
			tokfix();
			if (nondigit) goto trailing_uc;
			yylval.node = NEW_LIT(rb_cstr_to_inum(tok(), 8, Qfalse));
			return tINTEGER;
		    }
		    if (nondigit) {
			pushback(c);
			goto trailing_uc;
		    }
		}
		if (c > '7' && c <= '9') {
		    yyerror("Illegal octal digit");
		}
		else if (c == '.' || c == 'e' || c == 'E') {
		    tokadd('0');
		}
		else {
		    pushback(c);
		    yylval.node = NEW_LIT(INT2FIX(0));
		    return tINTEGER;
		}
	    }

	    for (;;) {
		switch (c) {
		  case '0': case '1': case '2': case '3': case '4':
		  case '5': case '6': case '7': case '8': case '9':
		    nondigit = 0;
		    tokadd(c);
		    break;

		  case '.':
		    if (nondigit) goto trailing_uc;
		    if (seen_point || seen_e) {
			goto decode_num;
		    }
		    else {
			int c0 = nextc();
			if (!ISDIGIT(c0)) {
			    pushback(c0);
			    goto decode_num;
			}
			c = c0;
		    }
		    tokadd('.');
		    tokadd(c);
		    is_float++;
		    seen_point++;
		    nondigit = 0;
		    break;

		  case 'e':
		  case 'E':
		    if (nondigit) {
			pushback(c);
			c = nondigit;
			goto decode_num;
		    }
		    if (seen_e) {
			goto decode_num;
		    }
		    tokadd(c);
		    seen_e++;
		    is_float++;
		    nondigit = c;
		    c = nextc();
		    if (c != '-' && c != '+') continue;
		    tokadd(c);
		    nondigit = c;
		    break;

		  case '_':	/* `_' in number just ignored */
		    if (nondigit) goto decode_num;
		    nondigit = c;
		    break;

		  default:
		    goto decode_num;
		}
		c = nextc();
	    }

	  decode_num:
	    pushback(c);
	    tokfix();
	    if (nondigit) {
		char tmp[30];
	      trailing_uc:
		sprintf(tmp, "trailing `%c' in number", nondigit);
		yyerror(tmp);
	    }
	    if (is_float) {
		double d = strtod(tok(), 0);
		if (errno == ERANGE) {
		    rb_warn("Float %s out of range", tok());
		    errno = 0;
		}
		yylval.node = NEW_LIT(rb_float_new(d));
		return tFLOAT;
	    }
	    yylval.node = NEW_LIT(rb_cstr_to_inum(tok(), 10, Qfalse));
	    return tINTEGER;
	}

      case ']':
      case '}':
      case ')':
	COND_LEXPOP();
	CMDARG_LEXPOP();
	lex_state = EXPR_END;
	return c;

      case ':':
	c = nextc();
	if (c == ':') {
	    if (lex_state == EXPR_BEG ||  lex_state == EXPR_MID ||
		(IS_ARG() && space_seen)) {
		lex_state = EXPR_BEG;
		return tCOLON3;
	    }
	    lex_state = EXPR_DOT;
	    return tCOLON2;
	}
	if (lex_state == EXPR_END || lex_state == EXPR_ENDARG || ISSPACE(c)) {
	    pushback(c);
	    lex_state = EXPR_BEG;
	    return ':';
	}
	switch (c) {
	  case '\'':
	    lex_strterm = NEW_STRTERM(str_ssym, c, 0);
	    break;
	  case '"':
	    lex_strterm = NEW_STRTERM(str_dsym, c, 0);
	    break;
	  default:
	    pushback(c);
	    break;
	}
	lex_state = EXPR_FNAME;
	return tSYMBEG;

      case '/':
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
	    lex_strterm = NEW_STRTERM(str_regexp, '/', 0);
	    return tREGEXP_BEG;
	}
	if ((c = nextc()) == '=') {
	    yylval.id = '/';
	    lex_state = EXPR_BEG;
	    return tOP_ASGN;
	}
	pushback(c);
	if (IS_ARG() && space_seen) {
	    if (!ISSPACE(c)) {
		arg_ambiguous();
		lex_strterm = NEW_STRTERM(str_regexp, '/', 0);
		return tREGEXP_BEG;
	    }
	}
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
	return '/';

      case '^':
	if ((c = nextc()) == '=') {
	    yylval.id = '^';
	    lex_state = EXPR_BEG;
	    return tOP_ASGN;
	}
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
	pushback(c);
	return '^';

      case ';':
	command_start = Qtrue;
      case ',':
	lex_state = EXPR_BEG;
	return c;

      case '~':
	if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
	    if ((c = nextc()) != '@@') {
		pushback(c);
	    }
	}
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
	return '~';

      case '(':
	command_start = Qtrue;
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
	    c = tLPAREN;
	}
	else if (space_seen) {
	    if (lex_state == EXPR_CMDARG) {
		c = tLPAREN_ARG;
	    }
	    else if (lex_state == EXPR_ARG) {
		c = tLPAREN_ARG;
		yylval.id = last_id;
	    }
	}
	COND_PUSH(0);
	CMDARG_PUSH(0);
	lex_state = EXPR_BEG;
	return c;

      case '[':
	if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
	    lex_state = EXPR_ARG;
	    if ((c = nextc()) == ']') {
		if ((c = nextc()) == '=') {
		    return tASET;
		}
		pushback(c);
		return tAREF;
	    }
	    pushback(c);
	    return '[';
	}
	else if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
	    c = tLBRACK;
	}
	else if (IS_ARG() && space_seen) {
	    c = tLBRACK;
	}
	lex_state = EXPR_BEG;
	COND_PUSH(0);
	CMDARG_PUSH(0);
	return c;

      case '{':
	if (IS_ARG() || lex_state == EXPR_END)
	    c = '{';          /* block (primary) */
	else if (lex_state == EXPR_ENDARG)
	    c = tLBRACE_ARG;  /* block (expr) */
	else
	    c = tLBRACE;      /* hash */
	COND_PUSH(0);
	CMDARG_PUSH(0);
	lex_state = EXPR_BEG;
	return c;

      case '\\':
	c = nextc();
	if (c == '\n') {
	    space_seen = 1;
	    goto retry; /* skip \\n */
	}
	pushback(c);
	if (QUOTED_TERM_P(c)) {
	    if (!(quoted_term & (1 << CHAR_BIT))) {
		rb_warn("escaped terminator '%c' inside string interpolation", c);
		quoted_term |= 1 << CHAR_BIT;
	    }
	    goto retry;
	}
	return '\\';

      case '%':
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
	    int term;
	    int paren;

	    c = nextc();
	  quotation:
	    if (c == '\\' && WHEN_QUOTED_TERM(peek(quoted_term_char))) {
		c = nextc();
		if (!(quoted_term & (1 << CHAR_BIT))) {
		    rb_warn("escaped terminator '%s%c' inside string interpolation",
			    (c == '\'' ? "\\" : ""), c);
		    quoted_term |= 1 << CHAR_BIT;
		}
	    }
	    if (!ISALNUM(c)) {
		term = c;
		c = 'Q';
	    }
	    else {
		term = nextc();
		if (ISALNUM(term) || ismbchar(term)) {
		    yyerror("unknown type of %string");
		    return 0;
		}
	    }
	    if (c == -1 || term == -1) {
		rb_compile_error("unterminated quoted string meets end of file");
		return 0;
	    }
	    paren = term;
	    if (term == '(') term = ')';
	    else if (term == '[') term = ']';
	    else if (term == '{') term = '}';
	    else if (term == '<') term = '>';
	    else paren = 0;

	    switch (c) {
	      case 'Q':
		lex_strterm = NEW_STRTERM(str_dquote, term, paren);
		return tSTRING_BEG;

	      case 'q':
		lex_strterm = NEW_STRTERM(str_squote, term, paren);
		return tSTRING_BEG;

	      case 'W':
		lex_strterm = NEW_STRTERM(str_dquote | STR_FUNC_QWORDS, term, paren);
		do {c = nextc();} while (ISSPACE(c));
		pushback(c);
		return tWORDS_BEG;

	      case 'w':
		lex_strterm = NEW_STRTERM(str_squote | STR_FUNC_QWORDS, term, paren);
		do {c = nextc();} while (ISSPACE(c));
		pushback(c);
		return tQWORDS_BEG;

	      case 'x':
		lex_strterm = NEW_STRTERM(str_xquote, term, paren);
		return tXSTRING_BEG;

	      case 'r':
		lex_strterm = NEW_STRTERM(str_regexp, term, paren);
		return tREGEXP_BEG;

	      case 's':
		lex_strterm = NEW_STRTERM(str_ssym, term, paren);
		lex_state = EXPR_FNAME;
		return tSYMBEG;

	      default:
		yyerror("unknown type of %string");
		return 0;
	    }
	}
	if ((c = nextc()) == '=') {
	    yylval.id = '%';
	    lex_state = EXPR_BEG;
	    return tOP_ASGN;
	}
	if (IS_ARG() && space_seen && !ISSPACE(c)) {
	    goto quotation;
	}
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
	pushback(c);
	return '%';

      case '$':
	lex_state = EXPR_END;
	newtok();
	c = nextc();
	switch (c) {
	  case '_':		/* $_: last read line string */
	    c = nextc();
	    if (is_identchar(c)) {
		tokadd('$');
		tokadd('_');
		break;
	    }
	    pushback(c);
	    c = '_';
	    /* fall through */
	  case '~':		/* $~: match-data */
	    local_cnt(c);
	    /* fall through */
	  case '*':		/* $*: argv */
	  case '$':		/* $$: pid */
	  case '?':		/* $?: last status */
	  case '!':		/* $!: error string */
	  case '@@':		/* $@@: error position */
	  case '/':		/* $/: input record separator */
	  case '\\':		/* $\: output record separator */
	  case ';':		/* $;: field separator */
	  case ',':		/* $,: output field separator */
	  case '.':		/* $.: last read line number */
	  case '=':		/* $=: ignorecase */
	  case ':':		/* $:: load path */
	  case '<':		/* $<: reading filename */
	  case '>':		/* $>: default output handle */
	  case '\"':		/* $": already loaded files */
	    tokadd('$');
	    tokadd(c);
	    tokfix();
	    yylval.id = rb_intern(tok());
	    return tGVAR;

	  case '-':
	    tokadd('$');
	    tokadd(c);
	    c = nextc();
	    tokadd(c);
	    tokfix();
	    yylval.id = rb_intern(tok());
	    /* xxx shouldn't check if valid option variable */
	    return tGVAR;

	  case '&':		/* $&: last match */
	  case '`':		/* $`: string before last match */
	  case '\'':		/* $': string after last match */
	  case '+':		/* $+: string matches last paren. */
	    yylval.node = NEW_BACK_REF(c);
	    return tBACK_REF;

	  case '1': case '2': case '3':
	  case '4': case '5': case '6':
	  case '7': case '8': case '9':
	    tokadd('$');
	    while (ISDIGIT(c)) {
		tokadd(c);
		c = nextc();
	    }
	    if (is_identchar(c))
		break;
	    pushback(c);
	    tokfix();
	    yylval.node = NEW_NTH_REF(atoi(tok()+1));
	    return tNTH_REF;

	  default:
	    if (!is_identchar(c)) {
		pushback(c);
		return '$';
	    }
	  case '0':
	    tokadd('$');
	}
	break;

      case '@@':
	c = nextc();
	newtok();
	tokadd('@@');
	if (c == '@@') {
	    tokadd('@@');
	    c = nextc();
	}
	if (ISDIGIT(c)) {
	    if (tokidx == 1) {
		rb_compile_error("`@@%c' is not a valid instance variable name", c);
	    }
	    else {
		rb_compile_error("`@@@@%c' is not a valid class variable name", c);
	    }
	}
	if (!is_identchar(c)) {
	    pushback(c);
	    return '@@';
	}
	break;

      default:
	if (!is_identchar(c) || ISDIGIT(c)) {
	    rb_compile_error("Invalid char `\\%03o' in expression", c);
	    goto retry;
	}

	newtok();
	break;
    }

    while (is_identchar(c)) {
	tokadd(c);
	if (ismbchar(c)) {
	    int i, len = mbclen(c)-1;

	    for (i = 0; i < len; i++) {
		c = nextc();
		tokadd(c);
	    }
	}
	c = nextc();
    }
    if ((c == '!' || c == '?') && is_identchar(tok()[0]) && !peek('=')) {
	tokadd(c);
    }
    else {
	pushback(c);
    }
    tokfix();

    {
	int result = 0;

	switch (tok()[0]) {
	  case '$':
	    lex_state = EXPR_END;
	    result = tGVAR;
	    break;
	  case '@@':
	    lex_state = EXPR_END;
	    if (tok()[1] == '@@')
		result = tCVAR;
	    else
		result = tIVAR;
	    break;

	  default:
	    if (toklast() == '!' || toklast() == '?') {
		result = tFID;
	    }
	    else {
		if (lex_state == EXPR_FNAME) {
		    if ((c = nextc()) == '=' && !peek('~') && !peek('>') &&
			(!peek('=') || (lex_p + 1 < lex_pend && lex_p[1] == '>'))) {
			result = tIDENTIFIER;
			tokadd(c);
		    }
		    else {
			pushback(c);
		    }
		}
		if (result == 0 && ISUPPER(tok()[0])) {
		    result = tCONSTANT;
		}
		else {
		    result = tIDENTIFIER;
		}
	    }

	    if (lex_state != EXPR_DOT) {
		struct kwtable *kw;

		/* See if it is a reserved word.  */
		kw = rb_reserved_word(tok(), toklen());
		if (kw) {
		    enum lex_state state = lex_state;
		    lex_state = kw->state;
		    if (state == EXPR_FNAME) {
			yylval.id = rb_intern(kw->name);
		    }
		    if (kw->id[0] == kDO) {
			if (COND_P()) return kDO_COND;
			if (CMDARG_P() && state != EXPR_CMDARG)
			    return kDO_BLOCK;
			if (state == EXPR_ENDARG)
			    return kDO_BLOCK;
			return kDO;
		    }
		    if (state == EXPR_BEG)
			return kw->id[0];
		    else {
			if (kw->id[0] != kw->id[1])
			    lex_state = EXPR_BEG;
			return kw->id[1];
		    }
		}
	    }

	    if (lex_state == EXPR_BEG ||
		lex_state == EXPR_MID ||
		lex_state == EXPR_DOT ||
		lex_state == EXPR_ARG ||
		lex_state == EXPR_CMDARG) {
		if (cmd_state)
		    lex_state = EXPR_CMDARG;
		else
		    lex_state = EXPR_ARG;
	    }
	    else {
		lex_state = EXPR_END;
	    }
	}
	tokfix();
	if (strcmp(tok(), "__END__") == 0 &&
	    lex_p - lex_pbeg == 7 &&
	    (lex_pend == lex_p || *lex_p == '\n' || *lex_p == '\r')) {
	    ruby__end__seen = 1;
	    lex_lastline = 0;
	    return -1;
	}
	last_id = yylval.id = rb_intern(tok());
	return result;
    }
}

NODE*
rb_node_newnode(type, a0, a1, a2)
    enum node_type type;
    NODE *a0, *a1, *a2;
{
    NODE *n = (NODE*)rb_newobj();

    n->flags |= T_NODE;
    nd_set_type(n, type);
    nd_set_line(n, ruby_sourceline);
    n->nd_file = ruby_sourcefile;

    n->u1.node = a0;
    n->u2.node = a1;
    n->u3.node = a2;

    return n;
}

static enum node_type
nodetype(node)			/* for debug */
    NODE *node;
{
    return (enum node_type)nd_type(node);
}

static int
nodeline(node)
    NODE *node;
{
    return nd_line(node);
}

static NODE*
newline_node(node)
    NODE *node;
{
    NODE *nl = 0;
    if (node) {
	if (nd_type(node) == NODE_NEWLINE) return node;
        nl = NEW_NEWLINE(node);
        fixpos(nl, node);
        nl->nd_nth = nd_line(node);
    }
    return nl;
}

static void
fixpos(node, orig)
    NODE *node, *orig;
{
    if (!node) return;
    if (!orig) return;
    if (orig == (NODE*)1) return;
    node->nd_file = orig->nd_file;
    nd_set_line(node, nd_line(orig));
}

static NODE*
block_append(head, tail)
    NODE *head, *tail;
{
    NODE *end, *h = head;

    if (tail == 0) return head;

  again:
    if (h == 0) return tail;
    switch (nd_type(h)) {
      case NODE_NEWLINE:
	h = h->nd_next;
	goto again;
      case NODE_LIT:
      case NODE_STR:
	return tail;
      default:
	end = NEW_BLOCK(head);
	end->nd_end = end;
	fixpos(end, head);
	head = end;
	break;
      case NODE_BLOCK:
	end = h->nd_end;
	break;
    }

    if (RTEST(ruby_verbose)) {
	NODE *nd = end->nd_head;
      newline:
	switch (nd_type(nd)) {
	  case NODE_RETURN:
	  case NODE_BREAK:
	  case NODE_NEXT:
	  case NODE_REDO:
	  case NODE_RETRY:
	    rb_warning("statement not reached");
	    break;

	case NODE_NEWLINE:
	    nd = nd->nd_next;
	    goto newline;

	  default:
	    break;
	}
    }

    if (nd_type(tail) != NODE_BLOCK) {
	tail = NEW_BLOCK(tail);
	tail->nd_end = tail;
    }
    end->nd_next = tail;
    head->nd_end = tail->nd_end;
    return head;
}

/* append item to the list */
static NODE*
list_append(list, item)
    NODE *list, *item;
{
    NODE *last;

    if (list == 0) return NEW_LIST(item);

    last = list;
    while (last->nd_next) {
	last = last->nd_next;
    }

    last->nd_next = NEW_LIST(item);
    list->nd_alen += 1;
    return list;
}

/* concat two lists */
static NODE*
list_concat(head, tail)
    NODE *head, *tail;
{
    NODE *last;

    last = head;
    while (last->nd_next) {
	last = last->nd_next;
    }

    last->nd_next = tail;
    head->nd_alen += tail->nd_alen;

    return head;
}

/* concat two string literals */
static NODE *
literal_concat(head, tail)
    NODE *head, *tail;
{
    enum node_type htype;

    if (!head) return tail;
    if (!tail) return head;

    htype = nd_type(head);
    if (htype == NODE_EVSTR) {
	NODE *node = NEW_DSTR(rb_str_new(0, 0));
	node->nd_next = NEW_LIST(head);
	node->nd_alen += 1;
	head = node;
    }
    switch (nd_type(tail)) {
      case NODE_STR:
	if (htype == NODE_STR) {
	    rb_str_concat(head->nd_lit, tail->nd_lit);
	    rb_gc_force_recycle((VALUE)tail);
	}
	else {
	    list_append(head, tail);
	}
	break;

      case NODE_DSTR:
	if (htype == NODE_STR) {
	    rb_str_concat(head->nd_lit, tail->nd_lit);
	    tail->nd_lit = head->nd_lit;
	    rb_gc_force_recycle((VALUE)head);
	    head = tail;
	}
	else {
	    nd_set_type(tail, NODE_ARRAY);
	    tail->nd_head = NEW_STR(tail->nd_lit);
	    list_concat(head, tail);
	}
	break;

      case NODE_EVSTR:
	if (htype == NODE_STR) {
	    nd_set_type(head, NODE_DSTR);
	}
	list_append(head, tail);
	break;
    }
    return head;
}

static NODE *
new_evstr(node)
    NODE *node;
{
    NODE *head = node;

  again:
    if (node) {
	switch (nd_type(node)) {
	  case NODE_STR: case NODE_DSTR: case NODE_EVSTR:
	    return node;
	  case NODE_NEWLINE:
	    node = node->nd_next;
	    goto again;
	}
    }
    return NEW_EVSTR(head);
}

static NODE *
call_op(recv, id, narg, arg1)
    NODE *recv;
    ID id;
    int narg;
    NODE *arg1;
{
    value_expr(recv);
    if (narg == 1) {
	value_expr(arg1);
    }

    return NEW_CALL(recv, id, narg==1?NEW_LIST(arg1):0);
}

static NODE*
match_gen(node1, node2)
    NODE *node1;
    NODE *node2;
{
    local_cnt('~');

    value_expr(node1);
    value_expr(node2);
    if (node1) {
	switch (nd_type(node1)) {
	  case NODE_DREGX:
	  case NODE_DREGX_ONCE:
	    return NEW_MATCH2(node1, node2);

	  case NODE_LIT:
	    if (TYPE(node1->nd_lit) == T_REGEXP) {
		return NEW_MATCH2(node1, node2);
	    }
	}
    }

    if (node2) {
	switch (nd_type(node2)) {
	  case NODE_DREGX:
	  case NODE_DREGX_ONCE:
	    return NEW_MATCH3(node2, node1);

	  case NODE_LIT:
	    if (TYPE(node2->nd_lit) == T_REGEXP) {
		return NEW_MATCH3(node2, node1);
	    }
	}
    }

    return NEW_CALL(node1, tMATCH, NEW_LIST(node2));
}

static NODE*
gettable(id)
    ID id;
{
    if (id == kSELF) {
	return NEW_SELF();
    }
    else if (id == kNIL) {
	return NEW_NIL();
    }
    else if (id == kTRUE) {
	return NEW_TRUE();
    }
    else if (id == kFALSE) {
	return NEW_FALSE();
    }
    else if (id == k__FILE__) {
	return NEW_STR(rb_str_new2(ruby_sourcefile));
    }
    else if (id == k__LINE__) {
	return NEW_LIT(INT2FIX(ruby_sourceline));
    }
    else if (is_local_id(id)) {
	if (dyna_in_block() && rb_dvar_defined(id)) return NEW_DVAR(id);
	if (local_id(id)) return NEW_LVAR(id);
	/* method call without arguments */
#if 0
	/* Rite will warn this */
	rb_warn("ambiguous identifier; %s() or self.%s is better for method call",
		rb_id2name(id), rb_id2name(id));
#endif
	return NEW_VCALL(id);
    }
    else if (is_global_id(id)) {
	return NEW_GVAR(id);
    }
    else if (is_instance_id(id)) {
	return NEW_IVAR(id);
    }
    else if (is_const_id(id)) {
	return NEW_CONST(id);
    }
    else if (is_class_id(id)) {
	return NEW_CVAR(id);
    }
    rb_compile_error("identifier %s is not valid", rb_id2name(id));
    return 0;
}

static NODE*
assignable(id, val)
    ID id;
    NODE *val;
{
    value_expr(val);
    if (id == kSELF) {
	yyerror("Can't change the value of self");
    }
    else if (id == kNIL) {
	yyerror("Can't assign to nil");
    }
    else if (id == kTRUE) {
	yyerror("Can't assign to true");
    }
    else if (id == kFALSE) {
	yyerror("Can't assign to false");
    }
    else if (id == k__FILE__) {
	yyerror("Can't assign to __FILE__");
    }
    else if (id == k__LINE__) {
	yyerror("Can't assign to __LINE__");
    }
    else if (is_local_id(id)) {
	if (rb_dvar_curr(id)) {
	    return NEW_DASGN_CURR(id, val);
	}
	else if (rb_dvar_defined(id)) {
	    return NEW_DASGN(id, val);
	}
	else if (local_id(id) || !dyna_in_block()) {
	    return NEW_LASGN(id, val);
	}
	else{
	    rb_dvar_push(id, Qnil);
	    return NEW_DASGN_CURR(id, val);
	}
    }
    else if (is_global_id(id)) {
	return NEW_GASGN(id, val);
    }
    else if (is_instance_id(id)) {
	return NEW_IASGN(id, val);
    }
    else if (is_const_id(id)) {
	if (in_def || in_single)
	    yyerror("dynamic constant assignment");
	return NEW_CDECL(id, val);
    }
    else if (is_class_id(id)) {
	if (in_def || in_single) return NEW_CVASGN(id, val);
	return NEW_CVDECL(id, val);
    }
    else {
	rb_bug("bad id for variable");
    }
    return 0;
}

static NODE *
aryset(recv, idx)
    NODE *recv, *idx;
{
    value_expr(recv);
    return NEW_CALL(recv, tASET, idx);
}

ID
rb_id_attrset(id)
    ID id;
{
    id &= ~ID_SCOPE_MASK;
    id |= ID_ATTRSET;
    return id;
}

static NODE *
attrset(recv, id)
    NODE *recv;
    ID id;
{
    value_expr(recv);
    return NEW_CALL(recv, rb_id_attrset(id), 0);
}

static void
rb_backref_error(node)
    NODE *node;
{
    switch (nd_type(node)) {
      case NODE_NTH_REF:
	rb_compile_error("Can't set variable $%d", node->nd_nth);
	break;
      case NODE_BACK_REF:
	rb_compile_error("Can't set variable $%c", node->nd_nth);
	break;
    }
}

static NODE *
arg_concat(node1, node2)
    NODE *node1;
    NODE *node2;
{
    if (!node2) return node1;
    return NEW_ARGSCAT(node1, node2);
}

static NODE *
arg_add(node1, node2)
    NODE *node1;
    NODE *node2;
{
    if (!node1) return NEW_LIST(node2);
    if (nd_type(node1) == NODE_ARRAY) {
	return list_append(node1, node2);
    }
    else {
	return NEW_ARGSPUSH(node1, node2);
    }
}

static NODE*
node_assign(lhs, rhs)
    NODE *lhs, *rhs;
{
    if (!lhs) return 0;

    value_expr(rhs);
    switch (nd_type(lhs)) {
      case NODE_GASGN:
      case NODE_IASGN:
      case NODE_LASGN:
      case NODE_DASGN:
      case NODE_DASGN_CURR:
      case NODE_MASGN:
      case NODE_CDECL:
      case NODE_CVDECL:
      case NODE_CVASGN:
	lhs->nd_value = rhs;
	break;

      case NODE_CALL:
	lhs->nd_args = arg_add(lhs->nd_args, rhs);
	break;

      default:
	/* should not happen */
	break;
    }

    return lhs;
}

static int
value_expr0(node)
    NODE *node;
{
    int cond = 0;

    while (node) {
	switch (nd_type(node)) {
	  case NODE_CLASS:
	  case NODE_MODULE:
	  case NODE_DEFN:
	  case NODE_DEFS:
	    rb_warning("void value expression");
	    return Qfalse;

	  case NODE_RETURN:
	  case NODE_BREAK:
	  case NODE_NEXT:
	  case NODE_REDO:
	  case NODE_RETRY:
	    if (!cond) yyerror("void value expression");
	    /* or "control never reach"? */
	    return Qfalse;

	  case NODE_BLOCK:
	    while (node->nd_next) {
		node = node->nd_next;
	    }
	    node = node->nd_head;
	    break;

	  case NODE_BEGIN:
	    node = node->nd_body;
	    break;

	  case NODE_IF:
	    if (!value_expr(node->nd_body)) return Qfalse;
	    node = node->nd_else;
	    break;

	  case NODE_AND:
	  case NODE_OR:
	    cond = 1;
	    node = node->nd_2nd;
	    break;

	  case NODE_NEWLINE:
	    node = node->nd_next;
	    break;

	  default:
	    return Qtrue;
	}
    }

    return Qtrue;
}

static void
void_expr0(node)
    NODE *node;
{
    char *useless = 0;

    if (!RTEST(ruby_verbose)) return;
    if (!node) return;

  again:
    switch (nd_type(node)) {
      case NODE_NEWLINE:
	node = node->nd_next;
	goto again;

      case NODE_CALL:
	switch (node->nd_mid) {
	  case '+':
	  case '-':
	  case '*':
	  case '/':
	  case '%':
	  case tPOW:
	  case tUPLUS:
	  case tUMINUS:
	  case '|':
	  case '^':
	  case '&':
	  case tCMP:
	  case '>':
	  case tGEQ:
	  case '<':
	  case tLEQ:
	  case tEQ:
	  case tNEQ:
	    useless = rb_id2name(node->nd_mid);
	    break;
	}
	break;

      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_CVAR:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
	useless = "a variable";
	break;
      case NODE_CONST:
      case NODE_CREF:
	useless = "a constant";
	break;
      case NODE_LIT:
      case NODE_STR:
      case NODE_DSTR:
      case NODE_DREGX:
      case NODE_DREGX_ONCE:
	useless = "a literal";
	break;
      case NODE_COLON2:
      case NODE_COLON3:
	useless = "::";
	break;
      case NODE_DOT2:
	useless = "..";
	break;
      case NODE_DOT3:
	useless = "...";
	break;
      case NODE_SELF:
	useless = "self";
	break;
      case NODE_NIL:
	useless = "nil";
	break;
      case NODE_TRUE:
	useless = "true";
	break;
      case NODE_FALSE:
	useless = "false";
	break;
      case NODE_DEFINED:
	useless = "defined?";
	break;
    }

    if (useless) {
	int line = ruby_sourceline;

	ruby_sourceline = nd_line(node);
	rb_warn("useless use of %s in void context", useless);
	ruby_sourceline = line;
    }
}

static void
void_stmts(node)
    NODE *node;
{
    if (!RTEST(ruby_verbose)) return;
    if (!node) return;
    if (nd_type(node) != NODE_BLOCK) return;

    for (;;) {
	if (!node->nd_next) return;
	void_expr(node->nd_head);
	node = node->nd_next;
    }
}

static NODE *
remove_begin(node)
    NODE *node;
{
    NODE **n = &node;
    while (*n) {
	switch (nd_type(*n)) {
	  case NODE_NEWLINE:
	    n = &(*n)->nd_next;
	    continue;
	  case NODE_BEGIN:
	    *n = (*n)->nd_body;
	  default:
	    return node;
	}
    }
    return node;
}

static int
assign_in_cond(node)
    NODE *node;
{
    switch (nd_type(node)) {
      case NODE_MASGN:
	yyerror("multiple assignment in conditional");
	return 1;

      case NODE_LASGN:
      case NODE_DASGN:
      case NODE_GASGN:
      case NODE_IASGN:
	break;

      case NODE_NEWLINE:
      default:
	return 0;
    }

    switch (nd_type(node->nd_value)) {
      case NODE_LIT:
      case NODE_STR:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
	/* reports always */
	rb_warn("found = in conditional, should be ==");
	return 1;

      case NODE_DSTR:
      case NODE_XSTR:
      case NODE_DXSTR:
      case NODE_EVSTR:
      case NODE_DREGX:
      default:
	break;
    }
#if 0
    if (assign_in_cond(node->nd_value) == 0) {
	rb_warning("assignment in condition");
    }
#endif
    return 1;
}

static int
e_option_supplied()
{
    if (strcmp(ruby_sourcefile, "-e") == 0)
	return Qtrue;
    return Qfalse;
}

static void
warn_unless_e_option(str)
    const char *str;
{
    if (!e_option_supplied()) rb_warn(str);
}

static void
warning_unless_e_option(str)
    const char *str;
{
    if (!e_option_supplied()) rb_warning(str);
}

static NODE *cond0();

static NODE*
range_op(node)
    NODE *node;
{
    enum node_type type;

    if (!e_option_supplied()) return node;
    if (node == 0) return 0;

    value_expr(node);
    node = cond0(node);
    type = nd_type(node);
    if (type == NODE_NEWLINE) {
	node = node->nd_next;
	type = nd_type(node);
    }
    if (type == NODE_LIT && FIXNUM_P(node->nd_lit)) {
	warn_unless_e_option("integer literal in conditional range");
	return call_op(node,tEQ,1,NEW_GVAR(rb_intern("$.")));
    }
    return node;
}

static NODE*
cond0(node)
    NODE *node;
{
    enum node_type type = nd_type(node);

    assign_in_cond(node);

    switch (type) {
      case NODE_DSTR:
      case NODE_STR:
	rb_warn("string literal in condition");
	break;

      case NODE_DREGX:
      case NODE_DREGX_ONCE:
	warning_unless_e_option("regex literal in condition");
	local_cnt('_');
	local_cnt('~');
	return NEW_MATCH2(node, NEW_GVAR(rb_intern("$_")));

      case NODE_AND:
      case NODE_OR:
	node->nd_1st = cond0(node->nd_1st);
	node->nd_2nd = cond0(node->nd_2nd);
	break;

      case NODE_DOT2:
      case NODE_DOT3:
	node->nd_beg = range_op(node->nd_beg);
	node->nd_end = range_op(node->nd_end);
	if (type == NODE_DOT2) nd_set_type(node,NODE_FLIP2);
	else if (type == NODE_DOT3) nd_set_type(node, NODE_FLIP3);
	node->nd_cnt = local_append(internal_id());
	warning_unless_e_option("range literal in condition");
	break;

      case NODE_LIT:
	if (TYPE(node->nd_lit) == T_REGEXP) {
	    warn_unless_e_option("regex literal in condition");
	    nd_set_type(node, NODE_MATCH);
	    local_cnt('_');
	    local_cnt('~');
	}
	else {
	    rb_warning("literal in condition");
	}
      default:
	break;
    }
    return node;
}

static NODE*
cond(node)
    NODE *node;
{
    if (node == 0) return 0;
    value_expr(node);
    if (nd_type(node) == NODE_NEWLINE){
	node->nd_next = cond0(node->nd_next);
	return node;
    }
    return cond0(node);
}

static NODE*
logop(type, left, right)
    enum node_type type;
    NODE *left, *right;
{
    value_expr(left);
    if (nd_type(left) == type) {
	NODE *node = left, *second;
	while ((second = node->nd_2nd) != 0 && nd_type(second) == type) {
	    node = second;
	}
	node->nd_2nd = rb_node_newnode(type, second, right, 0);
	return left;
    }
    return rb_node_newnode(type, left, right, 0);
}

static NODE *
ret_args(node)
    NODE *node;
{
    if (node) {
	if (nd_type(node) == NODE_BLOCK_PASS) {
	    rb_compile_error("block argument should not be given");
	}
    }
    return node;
}

static NODE *
arg_blk_pass(node1, node2)
    NODE *node1;
    NODE *node2;
{
    if (node2) {
	node2->nd_head = node1;
	return node2;
    }
    return node1;
}

static NODE*
arg_prepend(node1, node2)
    NODE *node1, *node2;
{
    switch (nodetype(node2)) {
      case NODE_ARRAY:
	return list_concat(NEW_LIST(node1), node2);

      case NODE_RESTARGS:
	return arg_concat(node1, node2->nd_head);

      case NODE_BLOCK_PASS:
	node2->nd_body = arg_prepend(node1, node2->nd_body);
	return node2;

      default:
	rb_bug("unknown nodetype(%d) for arg_prepend", nodetype(node2));
    }
    return 0;			/* not reached */
}

static NODE*
new_call(r,m,a)
    NODE *r;
    ID m;
    NODE *a;
{
    if (a && nd_type(a) == NODE_BLOCK_PASS) {
	a->nd_iter = NEW_CALL(r,m,a->nd_head);
	return a;
    }
    return NEW_CALL(r,m,a);
}

static NODE*
new_fcall(m,a)
    ID m;
    NODE *a;
{
    if (a && nd_type(a) == NODE_BLOCK_PASS) {
	a->nd_iter = NEW_FCALL(m,a->nd_head);
	return a;
    }
    return NEW_FCALL(m,a);
}

static NODE*
new_super(a)
    NODE *a;
{
    if (a && nd_type(a) == NODE_BLOCK_PASS) {
	a->nd_iter = NEW_SUPER(a->nd_head);
	return a;
    }
    return NEW_SUPER(a);
}

static struct local_vars {
    ID *tbl;
    int nofree;
    int cnt;
    int dlev;
    struct RVarmap* dyna_vars;
    struct local_vars *prev;
} *lvtbl;

static void
local_push(top)
    int top;
{
    struct local_vars *local;

    local = ALLOC(struct local_vars);
    local->prev = lvtbl;
    local->nofree = 0;
    local->cnt = 0;
    local->tbl = 0;
    local->dlev = 0;
    local->dyna_vars = ruby_dyna_vars;
    lvtbl = local;
    if (!top) {
	/* preserve reference for GC, but link should be cut. */
	rb_dvar_push(0, (VALUE)ruby_dyna_vars);
	ruby_dyna_vars->next = 0;
    }
}

static void
local_pop()
{
    struct local_vars *local = lvtbl->prev;

    if (lvtbl->tbl) {
	if (!lvtbl->nofree) free(lvtbl->tbl);
	else lvtbl->tbl[0] = lvtbl->cnt;
    }
    ruby_dyna_vars = lvtbl->dyna_vars;
    free(lvtbl);
    lvtbl = local;
}

static ID*
local_tbl()
{
    lvtbl->nofree = 1;
    return lvtbl->tbl;
}

static int
local_append(id)
    ID id;
{
    if (lvtbl->tbl == 0) {
	lvtbl->tbl = ALLOC_N(ID, 4);
	lvtbl->tbl[0] = 0;
	lvtbl->tbl[1] = '_';
	lvtbl->tbl[2] = '~';
	lvtbl->cnt = 2;
	if (id == '_') return 0;
	if (id == '~') return 1;
    }
    else {
	REALLOC_N(lvtbl->tbl, ID, lvtbl->cnt+2);
    }

    lvtbl->tbl[lvtbl->cnt+1] = id;
    return lvtbl->cnt++;
}

static int
local_cnt(id)
    ID id;
{
    int cnt, max;

    if (id == 0) return lvtbl->cnt;

    for (cnt=1, max=lvtbl->cnt+1; cnt<max;cnt++) {
	if (lvtbl->tbl[cnt] == id) return cnt-1;
    }
    return local_append(id);
}

static int
local_id(id)
    ID id;
{
    int i, max;

    if (lvtbl == 0) return Qfalse;
    for (i=3, max=lvtbl->cnt+1; i<max; i++) {
	if (lvtbl->tbl[i] == id) return Qtrue;
    }
    return Qfalse;
}

static void
top_local_init()
{
    local_push(1);
    lvtbl->cnt = ruby_scope->local_tbl?ruby_scope->local_tbl[0]:0;
    if (lvtbl->cnt > 0) {
	lvtbl->tbl = ALLOC_N(ID, lvtbl->cnt+3);
	MEMCPY(lvtbl->tbl, ruby_scope->local_tbl, ID, lvtbl->cnt+1);
    }
    else {
	lvtbl->tbl = 0;
    }
    if (ruby_dyna_vars)
	lvtbl->dlev = 1;
    else
	lvtbl->dlev = 0;
}

static void
top_local_setup()
{
    int len = lvtbl->cnt;
    int i;

    if (len > 0) {
	i = ruby_scope->local_tbl?ruby_scope->local_tbl[0]:0;

	if (i < len) {
	    if (i == 0 || (ruby_scope->flags & SCOPE_MALLOC) == 0) {
		VALUE *vars = ALLOC_N(VALUE, len+1);
		if (ruby_scope->local_vars) {
		    *vars++ = ruby_scope->local_vars[-1];
		    MEMCPY(vars, ruby_scope->local_vars, VALUE, i);
		    rb_mem_clear(vars+i, len-i);
		}
		else {
		    *vars++ = 0;
		    rb_mem_clear(vars, len);
		}
		ruby_scope->local_vars = vars;
		ruby_scope->flags |= SCOPE_MALLOC;
	    }
	    else {
		VALUE *vars = ruby_scope->local_vars-1;
		REALLOC_N(vars, VALUE, len+1);
		ruby_scope->local_vars = vars+1;
		rb_mem_clear(ruby_scope->local_vars+i, len-i);
	    }
	    if (ruby_scope->local_tbl && ruby_scope->local_vars[-1] == 0) {
		free(ruby_scope->local_tbl);
	    }
	    ruby_scope->local_vars[-1] = 0;
	    ruby_scope->local_tbl = local_tbl();
	}
    }
    local_pop();
}

static struct RVarmap*
dyna_push()
{
    struct RVarmap* vars = ruby_dyna_vars;

    rb_dvar_push(0, 0);
    lvtbl->dlev++;
    return vars;
}

static void
dyna_pop(vars)
    struct RVarmap* vars;
{
    lvtbl->dlev--;
    ruby_dyna_vars = vars;
}

static int
dyna_in_block()
{
    return (lvtbl->dlev > 0);
}

int
ruby_parser_stack_on_heap()
{
#if defined(YYBISON) && !defined(C_ALLOCA)
    return Qfalse;
#else
    return Qtrue;
#endif
}

void
rb_gc_mark_parser()
{
    if (!ruby_in_compile) return;

    rb_gc_mark_maybe((VALUE)yylval.node);
    rb_gc_mark(ruby_debug_lines);
    rb_gc_mark(lex_lastline);
    rb_gc_mark(lex_input);
    rb_gc_mark((VALUE)lex_strterm);
}

void
rb_parser_append_print()
{
    ruby_eval_tree =
	block_append(ruby_eval_tree,
		     NEW_FCALL(rb_intern("print"),
			       NEW_ARRAY(NEW_GVAR(rb_intern("$_")))));
}

void
rb_parser_while_loop(chop, split)
    int chop, split;
{
    if (split) {
	ruby_eval_tree =
	    block_append(NEW_GASGN(rb_intern("$F"),
				   NEW_CALL(NEW_GVAR(rb_intern("$_")),
					    rb_intern("split"), 0)),
				   ruby_eval_tree);
    }
    if (chop) {
	ruby_eval_tree =
	    block_append(NEW_CALL(NEW_GVAR(rb_intern("$_")),
				  rb_intern("chop!"), 0), ruby_eval_tree);
    }
    ruby_eval_tree = NEW_OPT_N(ruby_eval_tree);
}

static struct {
    ID token;
    char *name;
} op_tbl[] = {
    {tDOT2,	".."},
    {tDOT3,	"..."},
    {'+',	"+"},
    {'-',	"-"},
    {'+',	"+(binary)"},
    {'-',	"-(binary)"},
    {'*',	"*"},
    {'/',	"/"},
    {'%',	"%"},
    {tPOW,	"**"},
    {tUPLUS,	"+@@"},
    {tUMINUS,	"-@@"},
    {tUPLUS,	"+(unary)"},
    {tUMINUS,	"-(unary)"},
    {'|',	"|"},
    {'^',	"^"},
    {'&',	"&"},
    {tCMP,	"<=>"},
    {'>',	">"},
    {tGEQ,	">="},
    {'<',	"<"},
    {tLEQ,	"<="},
    {tEQ,	"=="},
    {tEQQ,	"==="},
    {tNEQ,	"!="},
    {tMATCH,	"=~"},
    {tNMATCH,	"!~"},
    {'!',	"!"},
    {'~',	"~"},
    {'!',	"!(unary)"},
    {'~',	"~(unary)"},
    {'!',	"!@@"},
    {'~',	"~@@"},
    {tAREF,	"[]"},
    {tASET,	"[]="},
    {tLSHFT,	"<<"},
    {tRSHFT,	">>"},
    {tCOLON2,	"::"},
    {'`',	"`"},
    {0,	0}
};

static st_table *sym_tbl;
static st_table *sym_rev_tbl;

void
Init_sym()
{
    sym_tbl = st_init_strtable_with_size(200);
    sym_rev_tbl = st_init_numtable_with_size(200);
}

static ID last_id = LAST_TOKEN;

static ID
internal_id()
{
    return ID_INTERNAL | (++last_id << ID_SCOPE_SHIFT);
}

ID
rb_intern(name)
    const char *name;
{
    const char *m = name;
    ID id;
    int last;

    if (st_lookup(sym_tbl, name, &id))
	return id;

    id = 0;
    switch (*name) {
      case '$':
	id |= ID_GLOBAL;
	m++;
	if (!is_identchar(*m)) m++;
	break;
      case '@@':
	if (name[1] == '@@') {
	    m++;
	    id |= ID_CLASS;
	}
	else {
	    id |= ID_INSTANCE;
	}
	m++;
	break;
      default:
	if (name[0] != '_' && !ISALPHA(name[0]) && !ismbchar(name[0])) {
	    /* operators */
	    int i;

	    for (i=0; op_tbl[i].token; i++) {
		if (*op_tbl[i].name == *name &&
		    strcmp(op_tbl[i].name, name) == 0) {
		    id = op_tbl[i].token;
		    goto id_regist;
		}
	    }
	}

	last = strlen(name)-1;
	if (name[last] == '=') {
	    /* attribute assignment */
	    char *buf = ALLOCA_N(char,last+1);

	    strncpy(buf, name, last);
	    buf[last] = '\0';
	    id = rb_intern(buf);
	    if (id > LAST_TOKEN && !is_attrset_id(id)) {
		id = rb_id_attrset(id);
		goto id_regist;
	    }
	    id = ID_ATTRSET;
	}
	else if (ISUPPER(name[0])) {
	    id = ID_CONST;
        }
	else {
	    id = ID_LOCAL;
	}
	break;
    }
    while (*m && is_identchar(*m)) {
	m++;
    }
    if (*m) id = ID_JUNK;
    id |= ++last_id << ID_SCOPE_SHIFT;
  id_regist:
    name = strdup(name);
    st_add_direct(sym_tbl, name, id);
    st_add_direct(sym_rev_tbl, id, name);
    return id;
}

char *
rb_id2name(id)
    ID id;
{
    char *name;

    if (id < LAST_TOKEN) {
	int i = 0;

	for (i=0; op_tbl[i].token; i++) {
	    if (op_tbl[i].token == id)
		return op_tbl[i].name;
	}
    }

    if (st_lookup(sym_rev_tbl, id, &name))
	return name;

    if (is_attrset_id(id)) {
	ID id2 = (id & ~ID_SCOPE_MASK) | ID_LOCAL;

      again:
	name = rb_id2name(id2);
	if (name) {
	    char *buf = ALLOCA_N(char, strlen(name)+2);

	    strcpy(buf, name);
	    strcat(buf, "=");
	    rb_intern(buf);
	    return rb_id2name(id);
	}
	if (is_local_id(id2)) {
	    id2 = (id & ~ID_SCOPE_MASK) | ID_CONST;
	    goto again;
	}
    }
    return 0;
}

static int
symbols_i(key, value, ary)
    char *key;
    ID value;
    VALUE ary;
{
    rb_ary_push(ary, ID2SYM(value));
    return ST_CONTINUE;
}

VALUE
rb_sym_all_symbols()
{
    VALUE ary = rb_ary_new2(sym_tbl->num_entries);

    st_foreach(sym_tbl, symbols_i, ary);
    return ary;
}

int
rb_is_const_id(id)
    ID id;
{
    if (is_const_id(id)) return Qtrue;
    return Qfalse;
}

int
rb_is_class_id(id)
    ID id;
{
    if (is_class_id(id)) return Qtrue;
    return Qfalse;
}

int
rb_is_instance_id(id)
    ID id;
{
    if (is_instance_id(id)) return Qtrue;
    return Qfalse;
}

int
rb_is_local_id(id)
    ID id;
{
    if (is_local_id(id)) return Qtrue;
    return Qfalse;
}

int
rb_is_junk_id(id)
    ID id;
{
    if (is_junk_id(id)) return Qtrue;
    return Qfalse;
}

static void
special_local_set(c, val)
    char c;
    VALUE val;
{
    int cnt;

    top_local_init();
    cnt = local_cnt(c);
    top_local_setup();
    ruby_scope->local_vars[cnt] = val;
}

VALUE
rb_backref_get()
{
    VALUE *var = rb_svar(1);
    if (var) {
	return *var;
    }
    return Qnil;
}

void
rb_backref_set(val)
    VALUE val;
{
    VALUE *var = rb_svar(1);
    if (var) {
	*var = val;
    }
    else {
	special_local_set('~', val);
    }
}

VALUE
rb_lastline_get()
{
    VALUE *var = rb_svar(0);
    if (var) {
	return *var;
    }
    return Qnil;
}

void
rb_lastline_set(val)
    VALUE val;
{
    VALUE *var = rb_svar(0);
    if (var) {
	*var = val;
    }
    else {
	special_local_set('_', val);
    }
}
@


1.223
log
@* parse.y (value_expr0): allow return/break/next/redo/retry in rhs
  of logical operator.  [ruby-dev:18534]

* parse.y (remove_begin): eliminate useless NODE_BEGIN.
  [ruby-dev:18535]
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/10/17 07:26:59 $
d51 1
d242 1
a242 1
%type <node> literal numeric
d1744 1
d1962 25
d2800 1
d2810 2
d2884 5
a3799 1
	pushback(c);
d3801 1
d3805 11
d4017 5
d5656 8
@


1.222
log
@* object.c (rb_str_to_dbl): RString ptr might be NULL.

* object.c (rb_cstr_to_dbl): p pointer might be NULL.

* bignum.c (rb_str_to_inum): RString ptr might be NULL.

* bignum.c (rb_cstr_to_inum): str pointer might be NULL.
@
text
@d6 1
a6 1
  $Date: 2002/09/27 04:26:21 $
d122 2
a123 2
static int value_expr();
static void void_expr();
d125 3
d4703 1
a4703 1
value_expr(node)
d4706 2
d4722 1
a4722 1
	    yyerror("void value expression");
d4744 1
d4761 1
a4761 1
void_expr(node)
d4869 19
@


1.221
log
@* eval.c (rb_eval): Class#inherited should be called after the
  execution of the class body.

* parse.y (primary): remove "return outside of method" check at
  compile time.
@
text
@d6 1
a6 1
  $Date: 2002/09/25 07:03:01 $
d285 1
a285 1
%left  kIF_MOD kUNLESS_MOD kWHILE_MOD kUNTIL_MOD kRESCUE_MOD
d290 1
a426 4
		| stmt kRESCUE_MOD stmt
		    {
			$$ = NEW_RESCUE($1, NEW_RESBODY(0,$3,0), 0);
		    }
d1038 4
@


1.220
log
@* io.c (appendline): forget to terminate with nul.

* eval.c (ruby_run): should set toplevel visibility again here.

* eval.c (rb_eval): should not rely on ruby_class == rb_cObject
  check.   Besides allow implicit publicity for attribute set
  methods.

* parse.y (primary): need not to check class_nest, just set
  whether method is an attrset or not.

* string.c (rb_str_each_line): p might be at the top of the
  string.

* class.c (rb_make_metaclass): class of metaclass should be
  metaclass of superclass, unless class itself is a metaclass;
  class of metaclass of metaclass should point back to self.
  eh, confusing, isn't it.

* class.c (rb_singleton_class): check if its class is singleton
  AND attached to self.

* eval.c (rb_eval): should define class/module under ruby_cbase.

* eval.c (rb_eval): should set class/module path based on
  ruby_cbase, not ruby_class.

* eval.c (module_setup): use ruby_cbase instead of ruby_class.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/09/23 15:48:42 $
a558 2
			if (!compile_for_eval && !in_def && !in_single)
			    yyerror("return appeared outside of method");
a1339 2
			if (!compile_for_eval && !in_def && !in_single)
			    yyerror("return appeared outside of method");
@


1.219
log
@* eval.c (rb_call0): must not clear ruby_current_node, or
  backtrace cannot be genetated.

* intern.h (ruby_yyparse): rather than yyparse().

* parse.y (yylex): nextc() returns -1 at end of input, not 0.

* parse.y (newline_node): reduce deplicated newline node.

* parse.y (literal_concat): get rid of warning.

* parse.y (new_evstr): fixed junk code.
@
text
@d6 1
a6 1
  $Date: 2002/09/22 12:52:18 $
d1491 1
a1491 2
		        /* NOEX_PRIVATE for toplevel */
			$$ = NEW_DEFN($2, $4, $5, class_nest?NOEX_PUBLIC:NOEX_PRIVATE);
@


1.218
log
@* eval.c (call_trace_func): should not call trace function while
  compilation.

* eval.c (rb_call0): also inside c-func.

* parse.y (yycompile): ditto.

* ruby.c (require_libraries): preserve source file/line for each
  require.
@
text
@d6 1
a6 1
  $Date: 2002/09/20 15:47:06 $
d3558 1
a3558 1
			} while (c = nextc());
d3582 1
a3582 1
			} while (c = nextc());
d3606 1
a3606 1
			} while (c = nextc());
d3640 1
a3640 1
		    } while (c = nextc());
d4150 1
a4150 1
			(!peek('=') || lex_p + 1 < lex_pend && lex_p[1] == '>')) {
d4261 1
d4401 1
a4401 1
	return head;
d4415 1
a4415 1
	return head;
d4422 1
a4422 1
	return head;
d4424 1
d4431 1
a4431 1
    NODE *n;
d4433 1
d4438 3
a4440 8
	  case NODE_BLOCK:
	    for (n = node; n->nd_next; n = n->nd_next) {
		NODE *h = n->nd_head;
		enum node_type t;
		if (!h) continue;
		if (t != NODE_STR && t != NODE_LIT) goto evstr;
	    }
	    return n->nd_head;
d4443 1
a4443 2
  evstr:
    return NEW_EVSTR(node);
@


1.217
log
@literal_append: remove.
@
text
@d6 1
a6 1
  $Date: 2002/09/20 14:03:45 $
d2338 1
a2368 1
    ruby_in_compile = 1;
@


1.216
log
@* parse.y (block_append): eliminate unused literal nodes.

* parse.y (literal_concat): refined literal concatination.
@
text
@d6 1
a6 1
  $Date: 2002/09/13 09:36:28 $
a131 1
static NODE *literal_append();
@


1.215
log
@* eval.c (rb_eval): avoid uninitialized global/class variable
  warnings at `||='.  [ruby-dev:18278]

* parse.y (stmt, arg): ditto
@
text
@d6 1
a6 1
  $Date: 2002/09/10 14:38:20 $
d133 1
a1752 10
			else {
			    switch (nd_type(node)) {
			      case NODE_STR: case NODE_DSTR:
				break;
			      default:
				node = rb_node_newnode(NODE_DSTR, rb_str_new(0, 0),
						       1, NEW_LIST(node));
				break;
			    }
			}
d1895 1
a1895 1
			$$ = literal_append($1, $2);
d1929 1
a1929 1
		        $$ = NEW_EVSTR($$);
d4284 1
a4284 1
    NODE *end;
a4286 1
    if (head == 0) return tail;
d4288 10
a4297 1
    if (nd_type(head) != NODE_BLOCK) {
d4302 4
a4305 3
    }
    else {
	end = head->nd_end;
d4375 1
d4377 1
a4377 67
literal_concat_string(head, tail, str)
    NODE *head, *tail;
    VALUE str;
{
    NODE *last = head, *last1 = 0, *prev = 0;

    for (;;) {
	switch (nd_type(last)) {
	  case NODE_NEWLINE:
	    last = last->nd_next;
	    break;
	  case NODE_BLOCK:
	  case NODE_DSTR:
	    if (!last1) last1 = prev;
	    prev = last;
	    while (last->nd_next) {
		last = last->nd_next;
	    }
	    last = last->nd_head;
	    break;
	  case NODE_STR:
	    rb_str_concat(last->nd_lit, str);
	    if (tail) rb_gc_force_recycle((VALUE)tail);
	    return head;
	  default:
	    if (!last1) {
		last1 = head;
		head = NEW_DSTR(rb_str_new(0, 0));
		head->nd_next = last1 = NEW_LIST(last1);
		head->nd_alen += 1;
	    }
	    if (!tail) tail = NEW_STR(str);
	    list_append(head, tail);
	    return head;
	}
    }
}

static NODE *
literal_concat_dstr(head, tail)
    NODE *head, *tail;
{
    NODE *last;

    switch (nd_type(head)) {
      case NODE_STR:
	tail->nd_lit = head->nd_lit;
	rb_gc_force_recycle((VALUE)head);
	return tail;
      case NODE_DSTR:
	last = tail->nd_next;
	last->nd_alen = tail->nd_alen;
	rb_gc_force_recycle((VALUE)tail);
	return list_concat(head, last);
      default:
	head = NEW_LIST(head);
      case NODE_ARRAY:
      case NODE_ZARRAY:
	tail->nd_lit = 0;
	tail->nd_alen += head->nd_alen;
	tail->nd_next = list_concat(head, tail->nd_next);
	return tail;
    }
}

static NODE *
literal_concat_list(head, tail)
d4380 1
a4380 14
    tail = NEW_LIST(tail);
    switch (nd_type(head)) {
      case NODE_STR:
	nd_set_type(head, NODE_DSTR);
	head->nd_next = tail;
	head->nd_alen = tail->nd_alen;
	return head;
      case NODE_DSTR:
	return list_concat(head, tail);
      default:
	head = NEW_LIST(head);
	return list_concat(NEW_DSTR(rb_str_new(0, 0)), list_concat(head, tail));
    }
}
a4381 4
static NODE *
literal_append(head, tail)
    NODE *head, *tail;
{
d4385 7
d4394 1
a4394 1
	if (nd_type(head) == NODE_STR) {
a4396 1
	    return head;
d4398 18
d4417 6
a4422 2
      default:
	return literal_concat_list(head, tail);
a4425 1
/* concat two string literals */
d4427 2
a4428 2
literal_concat(head, tail)
    NODE *head, *tail;
d4430 1
a4430 2
    if (!head) return tail;
    if (!tail) return head;
d4432 13
a4444 10
    switch (nd_type(tail)) {
      case NODE_STR:
	return literal_concat_string(head, tail, tail->nd_lit);

      case NODE_DSTR:
	head = literal_concat_string(head, 0, tail->nd_lit);
	return literal_concat_dstr(head, tail);

      default:
	return literal_concat_list(head, tail);
d4446 2
d4955 4
a4958 1
    if (type == NODE_NEWLINE) node = node->nd_next;
@


1.214
log
@* parse.y (nextc): restore line number after here documents.
  (ruby-bugs-ja:PR#331)

* parse.y (heredoc_restore): ditto.
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/09/06 23:39:02 $
d52 5
d470 1
a470 1
				if (is_instance_id(vid)) {
d836 1
a836 1
				if (is_instance_id(vid)) {
@


1.213
log
@* parse.y (rb_gc_mark_parser): ruby_eval_tree is marked in eval.c.
@
text
@d6 1
a6 1
  $Date: 2002/09/06 03:09:07 $
d2326 1
d2367 1
d2478 4
d2998 2
@


1.212
log
@* parse.y (rb_gc_mark_parser): should mark lex_input and ruby_debug_lines.
@
text
@d6 1
a6 1
  $Date: 2002/09/06 02:44:51 $
a5361 2
    rb_gc_mark((VALUE)ruby_eval_tree_begin);
    rb_gc_mark((VALUE)ruby_eval_tree);
@


1.211
log
@* parse.y (rb_gc_mark_parser): should mark parse.y global variables.
@
text
@d6 1
a6 1
  $Date: 2002/09/06 01:24:41 $
d5364 3
a5366 1
    rb_gc_mark((VALUE)lex_lastline);
@


1.210
log
@* parse.y: should not use non-NODE VALUEs in the semantic stack.
@
text
@d6 1
a6 1
  $Date: 2002/09/05 20:00:52 $
d5359 7
a5365 3
    if (ruby_in_compile) {
        rb_gc_mark_maybe((VALUE)yylval.node);
    }
a5449 2
    rb_global_variable((VALUE*)&lex_lastline);
    rb_global_variable((VALUE*)&lex_strterm);
@


1.209
log
@* gc.c (gc_sweep): should mark parser.
* parse.y (rb_gc_mark_parser): new function.
* intern.h (rb_gc_mark_parser): added.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/04 06:37:35 $
a171 1
    VALUE val;
d226 1
a226 1
%token <val>  tINTEGER tFLOAT tSTRING_CONTENT
d233 1
a233 1
%type <val>  literal numeric
a1283 3
		    {
			$$ = NEW_LIT($1);
		    }
d1737 1
a1737 1
			$$ = ID2SYM($1);
d1877 1
a1877 1
			$$ = list_append($1, NEW_STR($2));
d1903 1
a1903 1
string_content	: tSTRING_CONTENT {$$ = NEW_STR($1);}
d2916 1
a2916 1
    yylval.val = rb_str_new(tok(), toklen());
d3069 1
a3069 1
		yylval.val = rb_str_new(tok(), toklen());
d3079 1
a3079 1
    yylval.val = str;
a3384 1
	yylval.val = INT2FIX(c);
d3386 1
d3563 1
a3563 1
		    yylval.val = rb_cstr_to_inum(tok(), 16, Qfalse);
d3587 1
a3587 1
		    yylval.val = rb_cstr_to_inum(tok(), 2, Qfalse);
d3611 1
a3611 1
		    yylval.val = rb_cstr_to_inum(tok(), 10, Qfalse);
d3642 1
a3642 1
			yylval.val = rb_cstr_to_inum(tok(), 8, Qfalse);
d3658 1
a3658 1
		    yylval.val = INT2FIX(0);
d3737 1
a3737 1
		yylval.val = rb_float_new(d);
d3740 1
a3740 1
	    yylval.val = rb_cstr_to_inum(tok(), 10, Qfalse);
d5360 1
a5360 1
        rb_gc_mark_maybe(yylval.val);
@


1.208
log
@* class.c (rb_make_metaclass): obj.meta.super.meta should be equal
  to obj.meta.meta.super (ruby-bugs-ja:PR#324).

* parse.y (yylex): the warning message "invalid
  character syntax" was never issued.

* marshal.c (r_bytes): do not use alloca (ruby-bugs:PR#382).
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/09/02 12:19:30 $
d5358 8
@


1.207
log
@* gc.c (gc_sweep): does reclaim nodes in also compile time, if we can.
* ruby.c (load_file): omit GC if we can.
* parse.y (ruby_parser_stack_on_heap): new function.
* intern.h (ruby_parser_stack_on_heap): added.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/21 15:47:54 $
d3348 1
a3348 1
		int c = 0;
d3351 1
a3351 1
		    c = 's';
d3354 1
a3354 1
		    c = 'n';
d3357 1
a3357 1
		    c = 't';
d3360 7
a3366 1
		    c = 'v';
d3369 2
a3370 2
		if (c) {
		    rb_warn("invalid character syntax; use ?\\%c", c);
@


1.206
log
@*.c: Int vs Long cleanup
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/08/15 11:49:39 $
d5342 10
@


1.205
log
@* eval.c (ruby_current_node) : added to set sourceline on demand.

* eval.c (error_pos, error_print, rb_longjmp, assign): set source
  file/line.

* eval.c (rb_eval): store current node instead of file/line, and
  preserve it at return.

* eval.c (module_setup): ditto.

* eval.c (struct thread): store node instead of file/line.

* eval.c (rb_thread_raise): ditto.

* intern.h (ruby_current_node): added.

* intern.h (ruby_set_current_source): added.

* parse.y (stmt, arg): not fix position of assignment.

* parse.y (node_assign): ditto.

* parse.y (yycompile): clear current node.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/01 09:42:36 $
d957 1
a957 1
			    $2->nd_lit = INT2NUM(-i);
d3023 1
a3023 1
    int len;
@


1.204
log
@* parse.y (tokadd_string): ignore backslashed spaces in %w.

* enum.c (enum_find): do not use rb_eval_cmd(); should not accept
  a string for if_none.
@
text
@d6 1
a6 1
  $Date: 2002/07/26 06:12:38 $
a477 1
			    fixpos($$, $3);
a843 1
			    fixpos($$, $3);
d2373 1
a4739 1
    if (rhs) fixpos(lhs, rhs);
@


1.203
log
@* random.c: replace with Mersenne Twister RNG.

* eval.c (jump_tag_but_local_jump): preserve retval in
  LocalJumpError exceptions.

* parse.y (command): no more check for "super outside of method".

* eval.c (rb_mod_define_method): should set last_class and
  last_func in the block->frame.

* eval.c (error_handle): should handle TAG_THROW as well.

* parse.y (yylex): new decimal notation '0d4567'.

* parse.y (yylex): new octal notation '0o777'.

* parse.y (string_content): every string_content node should
  return string only.  use NODE_EVSTR to coercing.

* eval.c (rb_eval): NODE_EVSTR support.

* re.c (rb_reg_quote): avoid unnecessary string allocation.

* string.c (get_pat): quote metachracters before compiling a
  string into a regex.

* string.c (rb_str_split_m): special treatment of strings of size
  1, but AWK emulation.  now uses get_pat().

* string.c (rb_str_match_m): quote metacharacters.

* string.c (rb_str_match2): ditto.

* ext/socket/socket.c (sock_addrinfo): make all 3 versions of
  getaddrinfo happy.  [ruby-core:00184]
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/07/26 03:13:06 $
d2838 3
@


1.202
log
@* parse.y (yylex): modify to accept a code like "m (a){...}".
@
text
@d6 1
a6 1
  $Date: 2002/07/17 21:49:40 $
a371 2
			if (in_def || in_single)
			    yyerror("alias within method");
a375 2
			if (in_def || in_single)
			    yyerror("alias within method");
a381 2
			if (in_def || in_single)
			    yyerror("alias within method");
a391 2
			if (in_def || in_single)
			    yyerror("undef within method");
a626 2
			if (!compile_for_eval && !in_def && !in_single)
			    yyerror("super called outside of method");
a1482 2
			if (in_def || in_single)
			    yyerror("nested method definition");
a1648 3
			if (!compile_for_eval && !in_def &&
		            !in_single && !in_defined)
			    yyerror("super called outside of method");
a1652 3
			if (!compile_for_eval && !in_def &&
		            !in_single && !in_defined)
			    yyerror("super called outside of method");
d1921 1
a1921 1
			$$ = $3;
d1939 1
d3556 1
a3556 1
			yyerror("hexadecimal number without hex-digits");
d3586 36
a3621 1
		if (c >= '0' && c <= '7' || c == '_') {
d3623 1
d4321 1
d4323 2
a4324 2
list_append(head, tail)
    NODE *head, *tail;
d4328 1
a4328 1
    if (head == 0) return NEW_LIST(tail);
d4330 1
a4330 1
    last = head;
d4335 3
a4337 3
    last->nd_next = NEW_LIST(tail);
    head->nd_alen += 1;
    return head;
d4340 1
d4463 1
@


1.201
log
@* parse.y (yylex): fix typo.
@
text
@d6 1
a6 1
  $Date: 2002/07/15 01:33:36 $
d3853 6
a3858 6
	if (!IS_ARG()) {
	    if (space_seen && lex_state == EXPR_ENDARG)
		c = tLBRACE_ARG;
	    if (lex_state != EXPR_END && lex_state != EXPR_ENDARG)
		c = tLBRACE;
	}
@


1.200
log
@* parse.y (heredoc_identifier): modify typo.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/07/13 00:32:46 $
d3420 1
a3420 1
	    rb_warning("`&' interpeted as argument prefix");
@


1.199
log
@* parse.y (literal_concat_string): wrong optimization.
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/07/04 14:41:36 $
d2960 1
a2960 1
	func |= str_squote; goto qutoed;
d2962 1
a2962 1
	func |= str_dquote; goto qutoed;
d2965 1
a2965 1
      qutoed:
@


1.198
log
@* parse.y: remove useless function str_extend_p().
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/07/02 09:58:13 $
d4370 1
a4370 2
	    last1->nd_next = NEW_LIST(tail);
	    head->nd_alen += 1;
@


1.197
log
@object.c: rb_Integer reformat, nil#to_f added to rb_define_method.
parse.y: Clean unused vars.
range.c: ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/28 14:39:59 $
a2296 2
static int str_extend_p _((void));

a4193 16
}

static int
str_extend_p()
{
    int c = nextc(), t = 0;
    switch (c) {
      case '$':
      case '@@':
	t = tSTRING_DVAR;
      case '{':
	t = tSTRING_DBEG;
    }
    pushback(c);
    pushback('#');
    return t;
@


1.196
log
@* re.c (rb_reg_expr_str): need to process backslashes properly.

* object.c (rb_any_to_a): declare Object#to_a to be obsolete.

* object.c (rb_Array): do not convert nil into [] automagically.

* object.c (rb_Integer): use "to_int" instead of
  "to_i". [experimental]

* object.c (nil_to_f): new method.

* object.c (rb_Integer): Symbols and nil should cause error.

* object.c (rb_Float): nil should cause error.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/27 17:16:39 $
d3039 1
a3039 1
    char *eos, *p;
@


1.195
log
@missing ;
@
text
@d6 1
a6 1
  $Date: 2002/06/26 23:29:10 $
d236 1
a236 1
%type <node> expr_value arg_value primary_value block_call_value
d608 1
a608 1
		| block_call_value '.' operation2 command_args
d612 1
a612 1
		| block_call_value tCOLON2 operation2 command_args
d1078 1
d1111 1
d1116 1
d1127 1
d1630 1
a1630 1
		| block_call_value '.' operation2 opt_paren_args
d1634 1
a1634 1
		| block_call_value tCOLON2 operation2 opt_paren_args
a1636 7
		    }
		;

block_call_value : block_call
		    {
			value_expr($$);
			$$ = $1;
@


1.194
log
@* parse.y (literal_concat_string): non-string last expression in
  #{} was ignored when followed by literal.
@
text
@d6 1
a6 1
  $Date: 2002/06/26 08:00:55 $
d1885 1
@


1.193
log
@* parse.y (words, qwords): word list literal rules.

* parse.y (parse_string): ditto.

* parse.y (yylex): %W: word list literal with interpolation. [new]
@
text
@d6 1
a6 1
  $Date: 2002/06/25 09:56:36 $
d4362 1
a4362 1
    NODE *last = head, *last1 = 0;
d4371 2
a4375 1
	    if (!last1) last1 = last;
@


1.192
log
@* parse.y (string1, xstring, regexp): moved lex_strnest
  initialization to string_contents/xstring_contents.
@
text
@d6 1
a6 1
  $Date: 2002/06/24 15:18:00 $
d164 3
d228 1
a228 1
%token <node> tNTH_REF tBACK_REF tQWORDS
d233 1
d274 1
a274 1
%token tSYMBEG tSTRING_BEG tXSTRING_BEG tREGEXP_BEG
d1299 2
a1300 1
		| tQWORDS
d1859 48
d1972 2
a1973 2
			    !lex_strterm->u3.id) {
			    quoted_term = lex_strterm->u2.id;
d2795 15
d2827 1
a2827 1
	else if (func != '\'' && c == '#' && lex_p < lex_pend) {
d2845 1
a2845 1
		if (func == '/') tokadd(c);
d2849 1
a2849 1
		if (func == '/') {
d2855 1
a2855 1
		else if (func != '\'') {
d2857 1
a2857 1
		    if (func != '"') tokadd('\\');
d2873 1
a2873 67
	tokadd(c);
    }
    return c;
}

static int
parse_quotedwords(term, paren)
    int term, paren;
{
    NODE *qwords = 0;
    int strstart;
    int c;
    int nest = 0;

    strstart = ruby_sourceline;
    newtok();

    while (c = nextc(),ISSPACE(c))
	;		/* skip preceding spaces */
    pushback(c);
    while ((c = nextc()) != term || nest > 0) {
	if (c == -1) {
	    ruby_sourceline = strstart;
	    rb_compile_error("unterminated string meets end of file");
	    return 0;
	}
	if (paren) {
	    if (c == paren) nest++;
	    if (c == term && nest-- == 0) break;
	}
	if (ismbchar(c)) {
	    int i, len = mbclen(c)-1;

	    for (i = 0; i < len; i++) {
		tokadd(c);
		c = nextc();
	    }
	}
	else if (c == '\\') {
	    c = nextc();
	    if (QUOTED_TERM_P(c)) break;
	    switch (c) {
	      case '\n':
		continue;
	      case '\\':
		c = '\\';
		break;
	      default:
		if (c == term || (paren && c == paren)) {
		    tokadd(c);
		    continue;
		}
		if (!ISSPACE(c))
		    tokadd('\\');
		break;
	    }
	}
	else if (ISSPACE(c)) {
	    NODE *str;

	    tokfix();
	    str = NEW_STR(rb_str_new(tok(), toklen()));
	    newtok();
	    if (!qwords) qwords = NEW_LIST(str);
	    else list_append(qwords, str);
	    while (c = nextc(),ISSPACE(c))
		;		/* skip continuous spaces */
d2875 1
a2875 1
	    continue;
d2879 1
a2879 13

    tokfix();
    if (toklen() > 0) {
	NODE *str;

	str = NEW_STR(rb_str_new(tok(), toklen()));
	if (!qwords) qwords = NEW_LIST(str);
	else list_append(qwords, str);
    }
    if (!qwords) qwords = NEW_ZARRAY();
    yylval.node = qwords;
    lex_state = EXPR_END;
    return tQWORDS;
d2889 4
a2892 4
    int func = quote->u1.id;
    int term = quote->u2.id;
    int paren = quote->u3.id;
    int c;
d2896 4
d2903 5
a2907 1
	    if (func != '/') return tSTRING_END;
d2915 4
d2920 1
a2920 1
    if (func != '\'' && c == '#') {
a2942 2
#define INDENTED_HEREDOC 0x20

d2946 1
a2946 1
    int c = nextc(), term, indent = 0, len;
d2955 1
a2955 1
	indent = INDENTED_HEREDOC;
d2964 1
d2966 1
d2968 2
d2971 1
a2971 1
	tokadd(c ^ indent);
d2987 1
a2987 1
	tokadd(term ^ indent);
d3047 1
a3047 9
    switch (func = *eos++) {
      case '\'': case '"': case '`':
	indent = 0;
	break;
      default:
	func ^= INDENTED_HEREDOC;
	indent = 1;
	break;
    }
d3061 1
a3061 1
    if (func == '\'') {
d3333 1
a3333 1
	lex_strterm = NEW_STRTERM('"', '"', 0);
d3348 1
a3348 1
	lex_strterm = NEW_STRTERM('`', '`', 0);
d3352 1
a3352 1
	lex_strterm = NEW_STRTERM('\'', '\'', 0);
d3754 1
a3754 1
	    lex_strterm = NEW_STRTERM('/', '/', 0);
d3766 1
a3766 1
		lex_strterm = NEW_STRTERM('/', '/', 0);
d3923 1
a3923 1
		lex_strterm = NEW_STRTERM('"', term, paren);
d3927 1
a3927 1
		lex_strterm = NEW_STRTERM('\'', term, paren);
d3930 6
d3937 4
a3940 1
		return parse_quotedwords(term, paren);
d3943 1
a3943 1
		lex_strterm = NEW_STRTERM('`', term, paren);
d3947 1
a3947 1
		lex_strterm = NEW_STRTERM('/', term, paren);
@


1.191
log
@* parse.y (string_dvar): allow back references in interpolation.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/24 07:59:00 $
d1790 1
a1790 1
string1		: tSTRING_BEG {lex_strnest = 0;} string_contents tSTRING_END
d1792 1
a1792 1
			$$ = $3;
d1796 1
a1796 1
xstring		: tXSTRING_BEG {lex_strnest = 0;} xstring_contents tSTRING_END
d1798 1
a1798 1
			NODE *node = $3;
d1811 2
a1812 2
				node = rb_node_newnode(NODE_DXSTR,
						       rb_str_new(0, 0), 1, NEW_LIST(node));
d1820 1
a1820 1
regexp		: tREGEXP_BEG {lex_strnest = 0;} xstring_contents tREGEXP_END
d1822 2
a1823 2
			int options = $4;
			NODE *node = $3;
d1856 1
d1867 1
d1915 1
a1915 1
term_push	: /* */
@


1.190
log
@* parse.y (yylex): __END__ should not be effective within
  string literals.

* parse.y (here_document): should be aware of __END__ within here
  documents.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/24 07:20:42 $
d238 1
a238 1
%type <node> assoc_list assocs assoc undef_list backref
d242 1
a242 1
%type <id>   cname fname op f_rest_arg string_dvar
d1886 1
a1886 1
			$$ = gettable($3);
d1907 4
a1910 3
string_dvar	: tGVAR
		| tIVAR
		| tCVAR
@


1.189
log
@* eval.c (rb_eval): NODE_EVSTR is no longer used.

* eval.c (eval): not enforce to make assigned variables dynamic.

* parse.y (string): split rules to strings/xstring/regexp to allow
  arbitrary statements inside string interpolation.

* parse.y (here_document): splitted into three phases.

* parse.y (literall_append, literal_concat): added.
  append/concatinate string literals.

* sample/test.rb (valid_syntax): adjust line number for BEGIN.
@
text
@d6 1
a6 1
  $Date: 2002/06/18 15:53:57 $
d1781 1
a2448 6
	    if (!lex_strterm && strncmp(lex_pbeg, "__END__", 7) == 0 &&
		(RSTRING(v)->len == 7 || lex_pbeg[7] == '\n' || lex_pbeg[7] == '\r')) {
		ruby__end__seen = 1;
		lex_lastline = 0;
		return -1;
	    }
d4180 7
@


1.188
log
@* parse.y (yylex): ? followed by successive word charaters is
  ternary operator not numeric literal.
@
text
@d6 1
a6 1
  $Date: 2002/06/18 15:46:24 $
d72 2
d106 4
d126 2
d160 5
d224 3
a226 2
%token <val>  tINTEGER tFLOAT tSTRING tXSTRING tREGEXP
%token <node> tDSTRING tDXSTRING tDREGEXP tNTH_REF tBACK_REF tQWORDS
d228 2
a229 1
%type <node> singleton string
d242 2
a243 2
%type <id>   cname fname op f_rest_arg
%type <num>  f_norm_arg f_arg
d270 2
a271 1
%token tSYMBEG
d1292 3
a1294 5
		| string
		| tXSTRING
		    {
			$$ = NEW_XSTR($1);
		    }
a1295 2
		| tDXSTRING
		| tDREGEXP
a1760 1
		| tREGEXP
d1763 27
a1789 1
string		: tSTRING
d1791 1
a1791 1
			$$ = NEW_STR($1);
d1793 3
a1795 2
		| tDSTRING
		| string tSTRING
d1797 3
a1799 2
		        if (nd_type($1) == NODE_DSTR) {
			    list_append($1, NEW_STR($2));
d1802 46
a1847 1
			    rb_str_concat($1->nd_lit, $2);
d1849 44
a1892 1
			$$ = $1;
d1894 1
a1894 1
		| string tDSTRING
d1896 6
a1901 2
		        if (nd_type($1) == NODE_STR) {
			    $$ = NEW_DSTR($1->nd_lit);
d1903 14
a1916 2
			else {
			    $$ = $1;
a1917 3
			$2->nd_head = NEW_STR($2->nd_lit);
			nd_set_type($2, NODE_ARRAY);
			list_concat($$, $2);
d2242 1
a2242 1
static NODE *str_extend _((NODE*,int,int));
a2295 1
static int heredoc_end;
d2336 3
a2338 1
    heredoc_end = 0;
d2355 1
a2444 4
	    if (heredoc_end > 0) {
		ruby_sourceline = heredoc_end;
		heredoc_end = 0;
	    }
d2448 1
a2448 1
	    if (strncmp(lex_pbeg, "__END__", 7) == 0 &&
d2697 1
a2697 2
parse_regx(term, paren)
    int term, paren;
a2698 1
    register int c;
a2699 2
    int once = 0;
    int nest = 0;
d2701 1
a2701 2
    int re_start = ruby_sourceline;
    NODE *list = 0;
d2704 1
a2704 5
    while ((c = nextc()) != -1) {
	if (c == term && nest == 0) {
	    goto regx_end;
	}

d2706 24
a2729 13
	  case '#':
	    list = str_extend(list, term, paren);
	    if (list == (NODE*)-1) goto unterminated;
	    continue;

	  case '\\':
	    if (tokadd_escape(term) < 0)
		return 0;
	    continue;

	  case -1:
	    goto unterminated;

d2731 1
a2731 12
	    if (paren)  {
	      if (c == paren) nest++;
	      if (c == term) nest--;
	    }
	    if (ismbchar(c)) {
		int i, len = mbclen(c)-1;

		for (i = 0; i < len; i++) {
		    tokadd(c);
		    c = nextc();
		}
	    }
a2732 52

	  regx_end:
	    for (;;) {
		switch (c = nextc()) {
		  case 'i':
		    options |= RE_OPTION_IGNORECASE;
		    break;
		  case 'x':
		    options |= RE_OPTION_EXTENDED;
		    break;
		  case 'm':
		    options |= RE_OPTION_MULTILINE;
		    break;
		  case 'o':
		    once = 1;
		    break;
		  case 'n':
		    kcode = 16;
		    break;
		  case 'e':
		    kcode = 32;
		    break;
		  case 's':
		    kcode = 48;
		    break;
		  case 'u':
		    kcode = 64;
		    break;
		  default:
		    pushback(c);
		    goto end_options;
		}
	    }

	  end_options:
	    tokfix();
	    lex_state = EXPR_END;
	    if (list) {
		nd_set_line(list, re_start);
		if (toklen() > 0) {
		    VALUE ss = rb_str_new(tok(), toklen());
		    list_append(list, NEW_STR(ss));
		}
		nd_set_type(list, once?NODE_DREGX_ONCE:NODE_DREGX);
		list->nd_cflag = options | kcode;
		yylval.node = list;
		return tDREGEXP;
	    }
	    else {
		yylval.val = rb_reg_new(tok(), toklen(), options | kcode);
		return tREGEXP;
	    }
a2733 1
	tokadd(c);
d2735 7
a2741 4
  unterminated:
    ruby_sourceline = re_start;
    rb_compile_error("unterminated regexp meets end of file");
    return 0;
a2743 2
static int parse_qstring _((int,int));

d2745 1
a2745 1
parse_string(func, term, paren)
a2748 3
    NODE *list = 0;
    int strstart;
    int nest = 0;
d2750 3
a2752 17
    if (func == '\'') {
	return parse_qstring(term, paren);
    }
    if (func == 0) {		/* read 1 line for heredoc */
				/* -1 for chomp */
	yylval.val = rb_str_new(lex_pbeg, lex_pend - lex_pbeg - 1);
	lex_p = lex_pend;
	return tSTRING;
    }
    strstart = ruby_sourceline;
    newtok();
    while ((c = nextc()) != term || nest > 0) {
	if (c == -1) {
	  unterm_str:
	    ruby_sourceline = strstart;
	    rb_compile_error("unterminated string meets end of file");
	    return 0;
d2754 6
a2759 3
	if (paren) {
	    if (c == paren) nest++;
	    if (c == term && nest-- == 0) break;
d2761 5
a2765 6
	if (ismbchar(c)) {
	    int i, len = mbclen(c)-1;

	    for (i = 0; i < len; i++) {
		tokadd(c);
		c = nextc();
a2767 5
	else if (c == '#') {
	    list = str_extend(list, term, paren);
	    if (list == (NODE*)-1) goto unterm_str;
	    continue;
	}
d2770 3
a2772 65
	    if (c == '\n')
		continue;
	    if (c == term) {
		tokadd(c);
	    }
	    else {
                pushback(c);
                if (func != '"') tokadd('\\');
                tokadd(read_escape());
  	    }
	    continue;
	}
	tokadd(c);
    }

    tokfix();
    lex_state = EXPR_END;

    if (list) {
	nd_set_line(list, strstart);
	if (toklen() > 0) {
	    VALUE ss = rb_str_new(tok(), toklen());
	    list_append(list, NEW_STR(ss));
	}
	yylval.node = list;
	if (func == '`') {
	    nd_set_type(list, NODE_DXSTR);
	    return tDXSTRING;
	}
	else {
	    return tDSTRING;
	}
    }
    else {
	yylval.val = rb_str_new(tok(), toklen());
	return (func == '`') ? tXSTRING : tSTRING;
    }
}

static int
parse_qstring(term, paren)
    int term, paren;
{
    int strstart;
    int c;
    int nest = 0;

    strstart = ruby_sourceline;
    newtok();
    while ((c = nextc()) != term || nest > 0) {
	if (c == -1) {
	    ruby_sourceline = strstart;
	    rb_compile_error("unterminated string meets end of file");
	    return 0;
	}
	if (paren) {
	    if (c == paren) nest++;
	    if (c == term && nest-- == 0) break;
	}
	if (ismbchar(c)) {
	    int i, len = mbclen(c)-1;

	    for (i = 0; i < len; i++) {
		tokadd(c);
		c = nextc();
a2773 3
	}
	else if (c == '\\') {
	    c = nextc();
d2779 1
a2779 1
		c = '\\';
d2783 4
a2786 3
		/* fall through */
		if (c == term || (paren && c == paren)) {
		    tokadd(c);
d2789 16
a2804 1
		tokadd('\\');
d2809 1
a2809 5

    tokfix();
    yylval.val = rb_str_new(tok(), toklen());
    lex_state = EXPR_END;
    return tSTRING;
d2847 1
d2894 3
d2898 2
a2899 3
here_document(term, indent)
    char term;
    int indent;
d2901 3
a2904 12
    char *eos, *p;
    int len;
    VALUE str;
    volatile VALUE line = 0;
    VALUE lastline_save;
    int offset_save;
    NODE *list = 0;
    int linesave = ruby_sourceline;
    int firstline;

    if (heredoc_end > 0) ruby_sourceline = heredoc_end;
    firstline = ruby_sourceline;
d2906 13
d2920 8
a2927 14
    switch (term) {
      case '\'':
      case '"':
      case '`':
	while ((c = nextc()) != term) {
	    switch (c) {
	      case -1:
		rb_compile_error("unterminated here document identifier meets end of file");
		return 0;
	      case '\n':
		rb_compile_error("unterminated here document identifier meets end of line");
		return 0;
	    }
	    tokadd(c);
d2929 51
a2979 2
	if (term == '\'') term = 0;
	break;
d2982 2
a2983 1
	c = term;
d2985 5
a2989 8
	if (!is_identchar(c)) {
	    rb_warn("use of bare << to mean <<\"\" is deprecated");
	    break;
	}
	while (is_identchar(c)) {
	    tokadd(c);
	    c = nextc();
	}
d2993 1
d2995 8
a3002 4
    lastline_save = lex_lastline;
    offset_save = lex_p - lex_pbeg;
    eos = strdup(tok());
    len = strlen(eos);
d3004 12
a3015 23
    str = rb_str_new(0,0);
    for (;;) {
	lex_lastline = line = lex_getline();
	if (NIL_P(line)) {
	  error:
	    ruby_sourceline = linesave;
	    rb_compile_error("can't find string \"%s\" anywhere before EOF", eos);
	    free(eos);
	    return 0;
	}
	ruby_sourceline++;
	p = RSTRING(line)->ptr;
	if (indent) {
	    while (*p && (*p == ' ' || *p == '\t')) {
		p++;
	    }
	}
	if (strncmp(eos, p, len) == 0) {
	    if (p[len] == '\n' || p[len] == '\r')
		break;
	    if (len == RSTRING(line)->len)
		break;
	}
d3017 16
a3032 19
	lex_pbeg = lex_p = RSTRING(line)->ptr;
	lex_pend = lex_p + RSTRING(line)->len;
      retry:
	switch (parse_string(term, '\n', 0)) {
	  case tSTRING:
	  case tXSTRING:
	    rb_str_cat2(yylval.val, "\n");
	    if (!list) {
	        rb_str_append(str, yylval.val);
	    }
	    else {
		list_append(list, NEW_STR(yylval.val));
	    }
	    break;
	  case tDSTRING:
	    if (!list) list = NEW_DSTR(str);
	    /* fall through */
	  case tDXSTRING:
	    if (!list) list = NEW_DXSTR(str);
d3034 8
a3041 6
	    list_append(yylval.node, NEW_STR(rb_str_new2("\n")));
	    nd_set_type(yylval.node, NODE_STR);
	    yylval.node = NEW_LIST(yylval.node);
	    yylval.node->nd_next = yylval.node->nd_head->nd_next;
	    list_concat(list, yylval.node);
	    break;
d3043 10
a3052 6
	  case 0:
	    goto error;
	}
	if (lex_p != lex_pend) {
	    goto retry;
	}
a3053 5
    free(eos);
    lex_lastline = lastline_save;
    lex_pbeg = RSTRING(lex_lastline)->ptr;
    lex_pend = lex_pbeg + RSTRING(lex_lastline)->len;
    lex_p = lex_pbeg + offset_save;
d3055 11
a3065 3
    lex_state = EXPR_END;
    heredoc_end = ruby_sourceline;
    ruby_sourceline = linesave;
d3067 13
a3079 3
    if (list) {
	nd_set_line(list, firstline+1);
	yylval.node = list;
d3081 29
a3109 13
    switch (term) {
      case '\0':
      case '\'':
      case '"':
	if (list) return tDSTRING;
	yylval.val = str;
	return tSTRING;
      case '`':
	if (list) return tDXSTRING;
	yylval.val = str;
	return tXSTRING;
    }
    return 0;
d3134 19
d3288 2
a3289 13
 	    int c2 = nextc();
	    int indent = 0;
	    if (c2 == '-') {
		indent = 1;
		c2 = nextc();
	    }
	    if (!ISSPACE(c2) && (strchr("\"'`", c2) || is_identchar(c2))) {
		return here_document(c2, indent);
	    }
	    pushback(c2);
	    if (indent) {
		pushback('-');
	    }
d3339 2
a3340 1
	return parse_string(c,c,0);
d3354 2
a3355 1
	return parse_string(c,c,0);
d3358 2
a3359 1
	return parse_qstring(c,0);
d3397 5
a3401 1
	if ((ISALNUM(c) || c == '_') && lex_p < lex_pend && is_identchar(*lex_p)) {
d3760 2
a3761 1
	    return parse_regx('/', '/');
d3772 2
a3773 1
		return parse_regx('/', '/');
d3881 7
d3897 8
d3929 2
a3930 1
		return parse_string('"', term, paren);
d3933 2
a3934 1
		return parse_qstring(term, paren);
d3940 2
a3941 1
		return parse_string('`', term, paren);
d3944 2
a3945 1
		return parse_regx(term, paren);
d4190 2
a4191 4
static NODE*
str_extend(list, term, paren)
    NODE *list;
    int term, paren;
d4193 1
a4193 8
    int c;
    int brace = -1;
    VALUE ss;
    NODE *node;
    int brace_nest = 0;
    int paren_nest = 0;

    c = nextc();
d4197 1
d4199 1
a4199 5
	break;
      default:
	tokadd('#');
	pushback(c);
	return list;
d4201 3
a4203 181

    ss = rb_str_new(tok(), toklen());
    if (list == 0) {
	list = NEW_DSTR(ss);
    }
    else if (toklen() > 0) {
	list_append(list, NEW_STR(ss));
    }
    newtok();

    switch (c) {
      case '$':
	tokadd('$');
	c = nextc();
	if (c == -1) return (NODE*)-1;
	switch (c) {
	  case '1': case '2': case '3':
	  case '4': case '5': case '6':
	  case '7': case '8': case '9':
	    while (ISDIGIT(c)) {
		tokadd(c);
		c = nextc();
	    }
	    pushback(c);
	    goto fetch_id;

	  case '&': case '+':
	  case '_': case '~':
	  case '*': case '$': case '?':
	  case '!': case '@@': case ',':
	  case '.': case '=': case ':':
	  case '<': case '>': case '\\':
	  case ';':
	  refetch:
	    tokadd(c);
	    goto fetch_id;

	  case '-':
	    tokadd(c);
	    c = nextc();
	    if (!is_identchar(c)) {
		pushback();
		goto invalid_interporate;
	    }
	    tokadd(c);
	    goto fetch_id;

          default:
	    if (c == term) {
		list_append(list, NEW_STR(rb_str_new2("#$")));
		pushback(c);
		newtok();
		return list;
	    }
	    switch (c) {
	      case '\"':
	      case '/':
	      case '\'':
	      case '`':
		goto refetch;
	    }
	    if (!is_identchar(c)) {
	      pushback(c);
	      invalid_interporate:
		{
		    VALUE s = rb_str_new2("#");
		    rb_str_cat(s, tok(), toklen());
		    list_append(list, NEW_STR(s));
		    newtok();
		    return list;
		}
	    }
	}

	while (is_identchar(c)) {
	    tokadd(c);
	    if (ismbchar(c)) {
		int i, len = mbclen(c)-1;

		for (i = 0; i < len; i++) {
		    c = nextc();
		    tokadd(c);
		}
	    }
	    c = nextc();
	}
	pushback(c);
	break;

      case '@@':
	tokadd(c);
	c = nextc();
        if (c == '@@') {
	    tokadd(c);
	    c = nextc();
        }
	while (is_identchar(c)) {
	    tokadd(c);
	    if (ismbchar(c)) {
		int i, len = mbclen(c)-1;

		for (i = 0; i < len; i++) {
		    c = nextc();
		    tokadd(c);
		}
	    }
	    c = nextc();
	}
	pushback(c);
	if (toklen() == 1) {
	    goto invalid_interporate;
	}
	break;

      case '{':
	if (c == '{') brace = '}';
	brace_nest = 0;
	do {
	  loop_again:
	    c = nextc();
	    switch (c) {
	      case -1:
		if (brace_nest > 0) {
		    yyerror("bad substitution in string");
		    newtok();
		    return list;
		}
		return (NODE*)-1;
	      case '}':
		if (c == brace) {
		    if (brace_nest == 0) break;
		    brace_nest--;
		}
		tokadd(c);
		goto loop_again;
	      case '\\':
		c = nextc();
		if (c == -1) return (NODE*)-1;
		if (c == term) {
		    tokadd(c);
		}
		else {
		    tokadd('\\');
		    tokadd(c);
		}
		goto loop_again;
	      case '{':
		if (brace != -1) brace_nest++;
	      default:
		if (c == paren) paren_nest++;
		else if (c == term && (!paren || paren_nest-- == 0)) {
		    pushback(c);
		    list_append(list, NEW_STR(rb_str_new2("#{")));
		    rb_warn("bad substitution in string");
		    tokfix();
		    list_append(list, NEW_STR(rb_str_new(tok(), toklen())));
		    newtok();
		    return list;
		}
		else if (ismbchar(c)) {
		    int i, len = mbclen(c)-1;

		    for (i = 0; i < len; i++) {
			tokadd(c);
			c = nextc();
		    }
		}
	      case '\n':
		tokadd(c);
		break;
	    }
	} while (c != brace);
    }

  fetch_id:
    tokfix();
    node = NEW_EVSTR(tok(),toklen());
    list_append(list, node);
    newtok();

    return list;
d4348 125
d5414 1
a5602 2

VALUE *rb_svar _((int cnt));
@


1.187
log
@* parse.y (yylex): commands after break/next/rescue can take
  arguments.  (ruby-bugs-ja:PR#265)
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/18 06:29:04 $
d3303 1
d3307 3
@


1.186
log
@* parse.y (yylex): obsolete '?<whitespace>'; use '?\s', '?\n',
  etc, instead.

* parse.y (yylex): no here document after a dot.

* parse.y (yylex): should have set lex_state after '`'.

* parse.y (yylex): should have set lex_state properly after
  tOP_ASGN.

* bignum.c (rb_big2dbl): return canonical HUGE_VAL for infinity.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/18 03:53:23 $
d4053 1
@


1.185
log
@* parse.y (yylex): should pushback proper char after '<<'.

* parse.y (range_op, cond0, cond): get rid of doubled warnings.

* parse.y (value_expr): reduce recursion level.

* parse.y (logop): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/06/14 06:27:18 $
d3095 1
a3096 1
		yylval.id = tPOW;
d3187 3
a3189 2
	    lex_state != EXPR_ENDARG
	    && lex_state != EXPR_CLASS &&
d3220 1
a3221 1
		yylval.id = tLSHFT;
d3242 1
a3243 1
		yylval.id = tRSHFT;
d3254 1
d3256 11
a3266 2
	if (lex_state == EXPR_FNAME) return c;
	if (lex_state == EXPR_DOT) return c;
d3282 21
a3302 1
	if (IS_ARG() && ISSPACE(c)){
d3307 1
a3307 1
	if (c == '\\') {
d3320 1
d3355 1
d3362 1
a3363 1
	    yylval.id = '|';
d3386 1
a3387 1
	    yylval.id = '+';
d3416 1
a3417 1
	    yylval.id = '-';
d3666 1
a3667 1
	    yylval.id = '/';
d3687 1
a3688 1
	    yylval.id = '^';
d3836 1
@


1.184
log
@* parse.y (read_escape): deny zero-width hexadecimal character.
  (ruby-bugs-ja:PR#260)

* parse.y (tokadd_escape): ditto.

* regex.c (re_compile_pattern): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/13 03:55:44 $
d3218 1
a3218 1
	    if (nextc() == '=') {
d4646 8
a4653 1
    if (node == 0) return Qtrue;
d4655 15
a4669 16
    switch (nd_type(node)) {
      case NODE_CLASS:
      case NODE_MODULE:
      case NODE_DEFN:
      case NODE_DEFS:
	rb_warning("void value expression");
	return Qfalse;

      case NODE_RETURN:
      case NODE_BREAK:
      case NODE_NEXT:
      case NODE_REDO:
      case NODE_RETRY:
	yyerror("void value expression");
	/* or "control never reach"? */
	return Qfalse;
d4671 3
a4673 5
      case NODE_BLOCK:
	while (node->nd_next) {
	    node = node->nd_next;
	}
	return value_expr(node->nd_head);
d4675 4
a4678 2
      case NODE_BEGIN:
	return value_expr(node->nd_body);
d4680 4
a4683 2
      case NODE_IF:
	return value_expr(node->nd_body) && value_expr(node->nd_else);
d4685 3
a4687 3
      case NODE_AND:
      case NODE_OR:
	return value_expr(node->nd_2nd);
d4689 4
a4692 2
      case NODE_NEWLINE:
	return value_expr(node->nd_next);
d4694 1
a4694 3
      default:
	return Qtrue;
    }
d4887 1
a4904 1
    value_expr(node);
d4956 1
d4970 8
@


1.183
log
@* eval.c (svalue_to_avalue): v may be Qundef.  This fix was
  suggested by Guy Decoux.

* hash.c (rb_hash_s_create): use rb_hash_aset() instead of calling
  st_insert() directly, to dup&freeze string keys.

* parse.y (yylex): proper error message for "@@@@0".

* parse.y (yylex): paren to parse_string() must be zero for
  unparenthesized strings.

* parse.y (str_extend): broken string when unterminated "#{".

* enum.c (enum_sort_by): had a bug in 1 element enumeration.
@
text
@d6 1
a6 1
  $Date: 2002/06/12 09:22:20 $
d2419 4
d2508 4
@


1.182
log
@* parse.y (yylex): 'do' should return kDO_BLOCK on EXPR_ENDARG.

* parse.y (singleton): "def (()).a end" dumped core.

* parse.y (range_op): node may be null.

* parse.y (match_gen): ditto.

* parse.y (arg): void value check for "..", "...", "!", and "not".

* parse.y (match_gen): void value check for "=~".

* parse.y (value_expr): check NODE_AND and NODE_OR recursively.

* parse.y (cond0): void value check added for conditionals.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/11 17:39:38 $
d3244 1
a3244 1
	return parse_string(c,c,c);
d3248 1
a3248 1
	return parse_string(c,c,c);
d3899 6
a3904 1
	    rb_compile_error("`@@%c' is not a valid instance variable name", c);
d4204 1
a4204 1
		    list_append(list, NEW_STR(rb_str_new2("#")));
@


1.181
log
@* parse.y (stmt): fix typo.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/06/11 07:26:03 $
d901 2
d907 2
a1009 1
			value_expr($2);
d1298 1
a1298 1
		        rb_warning("%s (...) interpreted as grouped expression", rb_id2name($<id>1));
d1989 18
a2006 13
			switch (nd_type($3)) {
			  case NODE_STR:
			  case NODE_DSTR:
			  case NODE_XSTR:
			  case NODE_DXSTR:
			  case NODE_DREGX:
			  case NODE_LIT:
			  case NODE_ARRAY:
			  case NODE_ZARRAY:
			    yyerror("can't define single method for literals.");
			  default:
		            value_expr($3);
			    break;
d3991 2
d4393 7
a4399 4
    switch (nd_type(node1)) {
      case NODE_DREGX:
      case NODE_DREGX_ONCE:
	return NEW_MATCH2(node1, node2);
d4401 4
a4404 3
      case NODE_LIT:
	if (TYPE(node1->nd_lit) == T_REGEXP) {
	    return NEW_MATCH2(node1, node2);
d4408 5
a4412 4
    switch (nd_type(node2)) {
      case NODE_DREGX:
      case NODE_DREGX_ONCE:
	return NEW_MATCH3(node2, node1);
d4414 4
a4417 3
      case NODE_LIT:
	if (TYPE(node2->nd_lit) == T_REGEXP) {
	    return NEW_MATCH3(node2, node1);
a4537 1

a4555 1

d4664 4
d4864 1
d4883 1
@


1.180
log
@* parse.y (%%): remove '%%' line on the end of the file(parse error).
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/11 07:01:13 $
d476 1
a476 1
			value_expr($5);
@


1.179
log
@* eval.c (rb_eval): ruby_frame->last_func may be null, if it's
  called outside of a method.

* parse.y (arg): use INT2NUM, not INT2FIX for tUMINUS.

* parse.y (arg): unnecessary negative tPOW treatment.

* parse.y (tokadd_escape): wrong backslash escapement.

* parse.y (stmt,arg): too much void value check.

* parse.y (stmt,arg): need to check void value on rules which does
  not use node_assign().

* ext/socket/socket.c (ipaddr): need not to taint hostnames.

* range.c (range_include): should be based on "<=>", whereas
  member? still is based on "each".

* range.c (range_min,range_max): redefine methods based on "<=>".
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/10 10:06:12 $
a5511 1
%%
@


1.178
log
@* numeric.c (fix_lshift): negative shift count means right shift.

* numeric.c (fix_rshift): return -1 when left side operand is
  negative.

* parse.y (yylex): `0_' should be an error. (ruby-bugs-ja:PR#239)
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/06/05 06:10:57 $
a437 1
			value_expr($3);
d448 1
d474 1
a474 1
                        NODE *args = NEW_LIST($6);
d476 2
d491 1
d503 1
d515 1
a812 1
			value_expr($3);
d817 1
d843 1
a843 1
                        NODE *args = NEW_LIST($6);
d845 2
d860 1
d872 1
d884 1
a928 15
			int need_negate = Qfalse;

			if (nd_type($1) == NODE_LIT) {
			    switch (TYPE($1->nd_lit)) {
			      case T_FIXNUM:
			      case T_FLOAT:
			      case T_BIGNUM:
				if (RTEST(rb_funcall($1->nd_lit,'<',1,INT2FIX(0)))) {
				    $1->nd_lit = rb_funcall($1->nd_lit,rb_intern("-@@"),0,0);
				    need_negate = Qtrue;
				}
			      default:
				break;
			    }
			}
a929 3
			if (need_negate) {
			    $$ = call_op($$, tUMINUS, 0, 0);
			}
d945 1
a945 1
			    $2->nd_lit = INT2FIX(-i);
d2535 1
a2535 1
	if (c != '/' || c != term)
d5512 1
@


1.177
log
@Trivial: GCC3.1 fix (not worth to mention in ChangeLog)
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/04 07:34:14 $
d3493 4
@


1.176
log
@* string.c (rb_str_aset): should raise error if an indexing string
  is not found in the receiver.

* sprintf.c (rb_f_sprintf): "%d" should convert objects into
  integers using Integer().

* lib/tempfile.rb (Tempfile::size): added.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/02 22:16:54 $
d4908 2
@


1.175
log
@* parse.y (here_document): check if identifier is terminated.
  (ruby-bugs-ja:PR#239)

* parse.y (yylex): should pushback proper char after '**'.
  (ruby-bugs-ja:PR#240)
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/29 05:20:33 $
a283 1
		        $<vars>$ = ruby_dyna_vars;
a304 1
		        ruby_dyna_vars = $<vars>1;
d2171 1
d2212 7
@


1.174
log
@* parse.y: yyparse #defines moved from intern.h

* ruby.c (proc_options): access prefixed "ruby_yydebug".

* applied modifies to pacify some of gcc -Wall warnings.

* parse.y (arg): no more ugly hack for "**", so that "-2**2" to be
  parsed as "(-2)**2", whereas "- 2**2" or "-(2)**2" to be parsed
  as "-(2**2)".

* parse.y (yylex): '-2' to be literal fixnum. [new]

* time.c (time_succ): new method for Range support.

* time.c (time_arg): nil test against v[6] (usec).
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/05/28 18:11:07 $
d2900 8
d2940 2
a2941 2
		free(eos);
		return 0;
d3080 1
a3080 1
	    if (nextc() == '=') {
@


1.173
log
@	* array.c: fixed format string for 'long' args (%d -> %ld).

	* class.c: ditto.

	* eval.c: ditto.

	* numeric.c: ditto.

	* pack.c: ditto.

	* parse.y: ditto.

	* range.c: ditto.

	* string.c: ditto.

	* util.c: ditto.
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/05/22 09:37:45 $
d16 1
d19 1
d25 7
@


1.172
log
@* parse.y (yylex): case '<': here-document label ate '-'.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/05/20 16:22:23 $
d4950 1
a4950 1
	rb_bug("unknown nodetype(%d) for arg_prepend");
@


1.171
log
@* parse.y (bodystmt): ensure clause was excuted on else clause
  without rescue clase.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/14 06:22:26 $
d3169 3
@


1.170
log
@* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* numeric.c (flo_to_s): default format precision to be "%.16g".

* util.c (ruby_strtod): use own strtod(3) implementation to avoid
  locale hell.  Due to this change "0xff".to_f no longer returns 255.0

* eval.c (avalue_to_yvalue): new function to distinguish yvalue
  (no-arg == Qundef) from svalue (no-arg == Qnil).

* eval.c (rb_yield_0): use avalue_to_yvalue().

* eval.c (assign): warn if val == Qundef where it means rhs is
  void (e.g. yield without value or call without argument).

* parse.y (value_expr): need not to warn for WHILE and UNTIL,
  since they can have return value (via valued break).
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/05/10 10:05:30 $
d312 1
a312 1
			    $$ = block_append($$, $4);
@


1.169
log
@* parse.y (here_document): preserve line number begins here
  document.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/04/25 13:55:58 $
a4599 2
      case NODE_WHILE:
      case NODE_UNTIL:
d4613 1
@


1.168
log
@* various files: macro fix-up by Michal Rokos.
@
text
@d6 1
a6 1
  $Date: 2002/04/24 04:54:14 $
d2880 4
d2985 1
a2985 1
	nd_set_line(list, linesave+1);
@


1.167
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d6 1
a6 1
  $Date: 2002/04/19 04:14:07 $
d71 2
a72 6
#define COND_PUSH(n) do {\
    cond_stack = (cond_stack<<1)|((n)&1);\
} while(0)
#define COND_POP() do {\
    cond_stack >>= 1;\
} while (0)
d81 2
a82 6
#define CMDARG_PUSH(n) do {\
    cmdarg_stack = (cmdarg_stack<<1)|((n)&1);\
} while(0)
#define CMDARG_POP() do {\
    cmdarg_stack >>= 1;\
} while (0)
@


1.166
log
@* eval.c (rb_thread_cleanup): current thread may be THREAD_STOPPED,
  for example when terminated from signal handler.

* regex.c (re_compile_pattern): remove /p support.

* regex.h: ditto.

* parse.y (parse_regx): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/04/11 10:02:59 $
d475 1
a475 1
                        NODE *tmp, *args = NEW_LIST($6);
d839 1
a839 1
                        NODE *tmp, *args = NEW_LIST($6);
d5206 40
a5245 40
    tDOT2,	"..",
    tDOT3,	"...",
    '+',	"+",
    '-',	"-",
    '+',	"+(binary)",
    '-',	"-(binary)",
    '*',	"*",
    '/',	"/",
    '%',	"%",
    tPOW,	"**",
    tUPLUS,	"+@@",
    tUMINUS,	"-@@",
    tUPLUS,	"+(unary)",
    tUMINUS,	"-(unary)",
    '|',	"|",
    '^',	"^",
    '&',	"&",
    tCMP,	"<=>",
    '>',	">",
    tGEQ,	">=",
    '<',	"<",
    tLEQ,	"<=",
    tEQ,	"==",
    tEQQ,	"===",
    tNEQ,	"!=",
    tMATCH,	"=~",
    tNMATCH,	"!~",
    '!',	"!",
    '~',	"~",
    '!',	"!(unary)",
    '~',	"~(unary)",
    '!',	"!@@",
    '~',	"~@@",
    tAREF,	"[]",
    tASET,	"[]=",
    tLSHFT,	"<<",
    tRSHFT,	">>",
    tCOLON2,	"::",
    '`',	"`",
    0,		0,
@


1.165
log
@* eval.c (assign): ruby_verbose should be surrounded by RTEST().

* object.c (rb_str2cstr): ditto.

* parse.y (void_expr): ditto.

* parse.y (void_stmts): ditto.

* variable.c (rb_ivar_get): ditto.

* variable.c (rb_cvar_set): ditto.

* variable.c (rb_cvar_get): ditto.

* dir.c (glob_helper): should have proceed link when link->path
  was non existing symbolic link.
@
text
@d6 1
a6 1
  $Date: 2002/03/26 06:18:49 $
a2597 4
		    break;
		  case 'p':	/* /p is obsolete */
		    rb_warn("/p option is obsolete; use /m\n\tnote: /m does not change ^, $ behavior");
		    options |= RE_OPTION_POSIXLINE;
@


1.164
log
@* parse.y (primary): while/until statement modifiers to "begin"
  statement now work as "do .. while" even when begin statement
  has "rescue" or "ensure" [new].

* parse.y (bodystmt): rescue/ensure is allowed at every bodies,
  i.e. method bodies, begin bodies, class bodies[new], and module
  bodies[new].

* ext/socket/socket.c (sock_addrinfo): should specify ai_socktype
  for getaddrinfo hints.

* eval.c (rb_f_abort): embed aborting message into exception
  object [new].

* eval.c (terminate_process): utility function for exit and abort.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/20 10:21:23 $
d4651 1
a4651 1
    if (!ruby_verbose) return;
d4745 1
a4745 1
    if (!ruby_verbose) return;
@


1.163
log
@too reverted.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/20 09:43:15 $
d215 1
a215 1
%type <node> compstmt stmts stmt expr arg primary command command_call method_call
d217 1
a217 1
%type <node> if_tail opt_else case_body cases rescue exc_list exc_var ensure
d307 21
d332 1
a332 1
			$$ = $1;
d334 1
d349 1
d536 1
d570 1
d577 1
d581 1
d592 1
d621 1
d628 1
d635 1
d661 1
d668 1
d678 1
d705 1
d732 1
d739 1
d754 1
d758 1
d768 1
d796 1
d805 1
d1052 1
d1059 1
d1084 1
d1102 1
d1106 1
d1147 1
d1202 1
d1214 1
d1229 1
d1235 1
d1242 1
d1252 1
d1262 1
d1276 1
d1297 1
a1297 4
		  compstmt
		  rescue
		  opt_else
		  ensure
d1300 1
a1300 12
			if (!$3 && !$4 && !$5)
			    $$ = NEW_BEGIN($2);
			else {
			    if ($3) $2 = NEW_RESCUE($2, $3, $4);
			    else if ($4) {
				rb_warn("else without rescue is useless");
				$2 = block_append($2, $4);
			    }
			    if ($5) $2 = NEW_ENSURE($2, $5);
			    $$ = $2;
			}
		        fixpos($$, $2);
d1430 1
a1430 1
		  compstmt
d1450 1
a1450 1
		  compstmt
d1468 1
a1468 1
		  compstmt
d1486 1
a1486 4
		  compstmt
		  rescue
		  opt_else
		  ensure
a1488 7
		        if ($6) $5 = NEW_RESCUE($5, $6, $7);
			else if ($7) {
			    rb_warn("else without rescue is useless");
			    $5 = block_append($5, $7);
			}
			if ($8) $5 = NEW_ENSURE($5, $8);

d1504 1
a1504 4
		  compstmt
		  rescue
		  opt_else
		  ensure
a1506 7
		        if ($9) $8 = NEW_RESCUE($8, $9, $10);
			else if ($10) {
			    rb_warn("else without rescue is useless");
			    $8 = block_append($8, $10);
			}
			if ($11) $8 = NEW_ENSURE($8, $11);

d1528 1
d1535 1
d1540 1
d1544 1
d1554 1
d1561 1
d1565 1
d1580 1
d1604 1
d1623 1
d1630 1
d1665 1
d1689 1
d1697 1
d1708 1
d1712 1
d1714 1
a1714 10
exc_list	: none
		| args

exc_var		: tASSOC lhs
		    {
			$$ = $2;
		    }
		| none

rescue		: kRESCUE exc_list exc_var then
d1716 1
a1716 1
		  rescue
d1726 1
d1728 12
a1739 2
ensure		: none
		| kENSURE compstmt
d1747 2
d1756 1
d1785 1
d1792 1
d1798 1
d1802 1
d1815 1
d1821 1
d1827 1
d1831 1
d1846 1
d1857 1
d1895 1
d1922 1
d1929 1
d1939 1
d1950 1
d1964 1
d1974 1
d1981 1
d2011 1
d2025 1
d2032 1
d2038 1
d2043 1
d2049 1
d2054 1
d2058 1
d2062 1
d2066 1
d2071 1
d2075 1
d2079 1
d2081 2
a2082 4
none		: /* none */
		    {
			$$ = 0;
		    }
@


1.162
log
@* eval.c (is_defined): should check receiver only once.

* eval.c (is_defined): should handle NODE_NEWLINE.

* file.c (rb_file_s_expand_path): memory leak fixed.
@
text
@d6 1
a6 1
  $Date: 2002/03/19 09:03:07 $
d5027 1
a5027 1
    local_push();
@


1.161
log
@* re.c (rb_reg_search): should clear last_match if pos is out of
  string range.

* string.c (rb_str_index_m): ditto.

* string.c (rb_str_rindex): ditto.

* class.c (rb_define_class): should handle autoload.

* class.c (rb_define_module): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/18 02:04:22 $
a5023 2
static VALUE last_dyna_vars = 0;

d5027 1
a5027 1
    local_push(1);
d5188 1
a5188 2
    rb_global_variable(&lex_lastline);
    rb_global_variable(&last_dyna_vars);
@


1.160
log
@* parse.y (parse_string): part of multi-byte sequence must not
  match to paren.

* parse.y (parse_qstring): ditto.

* parse.y (parse_quotedwords): ditto.

* parse.y (str_extend): handle multi-byte characters.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/12 09:28:48 $
d397 1
a397 1
			local_push();
d1385 1
a1385 1
			local_push();
d1406 1
a1406 1
			local_push();
d1423 1
a1423 1
			local_push();
d1441 1
a1441 1
			local_push();
d1468 1
a1468 1
			local_push();
d4930 1
d4935 2
a4936 1
local_push()
d4946 1
d4948 5
d4964 1
d5024 2
d5029 1
a5029 1
    local_push();
d5190 2
a5191 1
    rb_global_variable((VALUE*)&lex_lastline);
@


1.159
log
@* regex.c (re_compile_pattern): '\0111' should be '\011' plus '1',
  since octal literals are formed by three digits at most.

* marshal.c (w_object): module inclusion using extend() should
  also be detected.

* eval.c (rb_eval_cmd): cbase should not be NULL; it should be
  either ruby_wrapper or Object.

* enum.c (enum_each_with_index): should return self.

* process.c (proc_setpgrp): should return value for non-void function.

* process.c (proc_getpgid): should raise exception if getpgid() return -1.

* string.c (rb_str_ljust): should return a duplicated string.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/08 07:03:03 $
d2611 4
a2641 4
	if (paren) {
	    if (c == paren) nest++;
	    if (c == term && nest-- == 0) break;
	}
d2685 4
a2715 4
	if (paren) {
	    if (c == paren) nest++;
	    if (c == term && nest-- == 0) break;
	}
d2746 4
a2788 4
	if (paren) {
	    if (c == paren) nest++;
	    if (c == term && nest-- == 0) break;
	}
d4109 8
@


1.158
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.

* class.c (rb_mod_clone): should not call rb_obj_clone(), since
  Module does not provide "allocate".

* class.c (rb_singleton_class): should crate new singleton class
  if obj is a class or module and attached object is different,
  which means metaclass of singleton class is sought.

* time.c (time_s_alloc): now follows allocation framework.

* eval.c (rb_eval): should initialize outer class variables from
  methods in singleton class definitions.

* eval.c (assign): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/07 11:19:37 $
d2327 1
a2327 2
	    char buf[3];
	    int i;
d2330 2
a2331 10
	    for (i=0; i<3; i++) {
		c = nextc();
		if (c == -1) goto eof;
		if (c < '0' || '7' < c) {
		    pushback(c);
		    break;
		}
		buf[i] = c;
	    }
	    c = scan_oct(buf, i, &i);
@


1.157
log
@* gc.c (rb_source_filename): added. holds unique strings for file
  names with GC space.

* gc.c (rb_gc_mark): mark source file name.

* gc.c (gc_sweep): ditto.

* gc.c (Init_GC): initialize source file name table.

* intern.h (rb_source_filename): added.

* eval.c (rb_eval_string): use rb_source_filename().

* parse.y (yycompile): ditto.

* ruby.c (proc_options): ditto.

* ruby.c (load_file): ditto.

* ruby.c (ruby_script): ditto.

* ruby.c (ruby_prog_init): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/20 04:31:50 $
d2997 1
@


1.156
log
@* hash.c (rb_any_cmp): should handle Qundef in keys.

* eval.c (remove_method): should not remove a empty method to
  implement "undef".

* eval.c (rb_eval): should allow singleton class def for
  true/false/nil.

* parse.y (str_extend): backslash escape was done wrong.
@
text
@d6 1
a6 1
  $Date: 2002/02/19 05:39:06 $
d2126 1
a2126 1
    ruby_sourcefile = strdup(f);
@


1.155
log
@* parse.y (yylex): operators in the "op" rule should make
  lex_state EXPR_ARG on EXPR_FNAME and EXPR_DOT.
@
text
@d6 1
a6 1
  $Date: 2002/02/18 09:52:45 $
d4104 1
a4104 1
		break;
@


1.154
log
@* parse.y (expr_value, arg_value, primary_value): value_expr()
  check in place.

* eval.c (block_pass): "&nil" should clear block given.

* dir.c (push_braces): remove MAXPATHLEN dependency.

* dir.c (dir_s_globd): ditto.

* dln.c (init_funcname): ditto.

* dln.c (load_1): ditto.

* dln.c (dln_load): ditto.

* configure.in: add GNU/Hurd switches.

* pack.c (pack_pack): allows comment in template strings.

* pack.c (pack_unpack): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/02/14 08:47:58 $
a3006 1
	    lex_state = EXPR_BEG;
d3008 1
d3013 1
a3013 1
	    return tPOW;
d3015 17
a3031 4
	if (c == '=') {
	    yylval.id = '*';
	    lex_state = EXPR_BEG;
	    return tOP_ASGN;
d3033 5
a3037 4
	pushback(c);
	if (IS_ARG() && space_seen && !ISSPACE(c)){
	    rb_warning("`*' interpreted as argument prefix");
	    c = tSTAR;
a3038 7
	else if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
	    c = tSTAR;
	}
	else {
	    c = '*';
	}
	lex_state = EXPR_BEG;
d3074 6
a3079 1
	lex_state = EXPR_BEG;
d3114 6
a3119 1
	lex_state = EXPR_BEG;
d3129 1
d3140 6
a3145 1
	lex_state = EXPR_BEG;
d3151 1
d3220 6
a3225 1
	lex_state = EXPR_BEG;
a3228 1
	lex_state = EXPR_BEG;
d3230 1
d3238 2
a3239 1
	else if (c == '=') {
d3243 6
d3255 1
d3285 1
d3550 6
a3555 1
	lex_state = EXPR_BEG;
a3558 1
	lex_state = EXPR_BEG;
d3560 1
d3564 6
d3585 6
a3590 1
	lex_state = EXPR_BEG;
d3614 1
d3714 6
a3719 1
	lex_state = EXPR_BEG;
@


1.153
log
@* parse.y: avoid SEGV at OP_ASIGN to pseudo variable.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/14 07:49:27 $
d216 1
d360 1
a360 1
		| stmt kIF_MOD expr
a361 1
			value_expr($3);
d365 1
a365 1
		| stmt kUNLESS_MOD expr
a366 1
			value_expr($3);
d370 1
a370 1
		| stmt kWHILE_MOD expr
a371 1
			value_expr($3);
d379 1
a379 1
		| stmt kUNTIL_MOD expr
a380 1
			value_expr($3);
d450 1
a450 1
		| primary '[' aref_args ']' tOP_ASGN command_call
d465 1
a465 1
		| primary '.' tIDENTIFIER tOP_ASGN command_call
d476 1
a476 1
		| primary '.' tCONSTANT tOP_ASGN command_call
d487 1
a487 1
		| primary tCOLON2 tIDENTIFIER tOP_ASGN command_call
a508 1
			value_expr($3);
a538 1
			value_expr($2);
d547 6
d557 1
a557 1
		| block_call '.' operation2 command_args
a558 1
			value_expr($1);
d561 1
a561 1
		| block_call tCOLON2 operation2 command_args
a562 1
			value_expr($1);
d571 1
a571 1
		| primary '.' operation2 command_args
a572 1
			value_expr($1);
d576 1
a576 1
		| primary tCOLON2 operation2 command_args
a577 1
			value_expr($1);
d650 1
a650 1
		| primary '[' aref_args ']'
d654 1
a654 1
		| primary '.' tIDENTIFIER
d658 1
a658 1
		| primary tCOLON2 tIDENTIFIER
d662 1
a662 1
		| primary '.' tCONSTANT
d676 1
a676 1
		| primary '[' aref_args ']'
d680 1
a680 1
		| primary '.' tIDENTIFIER
d684 1
a684 1
		| primary tCOLON2 tIDENTIFIER
d688 1
a688 1
		| primary '.' tCONSTANT
d795 1
a795 1
		| primary '[' aref_args ']' tOP_ASGN arg
d810 1
a810 1
		| primary '.' tIDENTIFIER tOP_ASGN arg
d821 1
a821 1
		| primary '.' tCONSTANT tOP_ASGN arg
d832 1
a832 1
		| primary tCOLON2 tIDENTIFIER tOP_ASGN arg
a1002 1
			value_expr($1);
d1011 6
d1069 1
a1069 1
		| args ',' tSTAR arg opt_block_arg
a1070 1
			value_expr($4);
d1079 1
a1079 1
		| assocs ',' tSTAR arg opt_block_arg
a1080 1
			value_expr($4);
d1095 1
a1095 1
		| tSTAR arg opt_block_arg
a1096 1
			value_expr($2);
d1101 1
a1101 1
call_args2	: arg ',' args opt_block_arg
d1105 1
a1105 1
		| arg ',' block_arg
d1109 1
a1109 1
		| arg ',' tSTAR arg opt_block_arg
a1110 2
			value_expr($1);
			value_expr($4);
d1114 1
a1114 1
		| arg ',' args ',' tSTAR arg opt_block_arg
a1115 2
			value_expr($1);
			value_expr($6);
d1124 1
a1124 1
		| assocs ',' tSTAR arg opt_block_arg
a1125 1
			value_expr($4);
d1129 1
a1129 1
		| arg ',' assocs opt_block_arg
d1134 1
a1134 1
		| arg ',' args ',' assocs opt_block_arg
a1135 2
			value_expr($1);
			value_expr($6);
d1139 1
a1139 1
		| arg ',' assocs ',' tSTAR arg opt_block_arg
a1140 2
			value_expr($1);
			value_expr($6);
d1144 1
a1144 1
		| arg ',' args ',' assocs ',' tSTAR arg opt_block_arg
a1145 2
			value_expr($1);
			value_expr($8);
d1149 1
a1149 1
		| tSTAR arg opt_block_arg
a1150 1
			value_expr($2);
d1180 1
a1180 1
block_arg	: tAMPER arg
a1181 1
			value_expr($2);
d1191 1
a1191 1
args 		: arg
a1192 1
			value_expr($1);
d1195 1
a1195 1
		| args ',' arg
a1196 1
			value_expr($3);
d1200 1
a1200 1
mrhs		: arg
a1201 1
			value_expr($1);
d1209 1
a1209 1
mrhs_basic	: args ',' arg
a1210 1
			value_expr($3);
d1213 1
a1213 1
		| args ',' tSTAR arg
a1214 1
			value_expr($4);
d1217 1
a1217 1
		| tSTAR arg
a1218 1
			value_expr($2);
d1269 1
a1269 1
		| primary tCOLON2 tCONSTANT
a1270 1
			value_expr($1);
d1277 1
a1277 1
		| primary '[' aref_args ']'
a1278 1
			value_expr($1);
a1301 1
			value_expr($3);
d1332 1
a1332 1
		| kIF expr then
a1336 1
			value_expr($2);
d1340 1
a1340 1
		| kUNLESS expr then
a1344 1
			value_expr($2);
d1348 1
a1348 1
		| kWHILE {COND_PUSH(1);} expr do {COND_POP();}
a1351 1
			value_expr($3);
d1355 1
a1355 1
		| kUNTIL {COND_PUSH(1);} expr do {COND_POP();} 
a1358 1
			value_expr($3);
d1362 1
a1362 1
		| kCASE expr opt_terms
a1365 1
			value_expr($2);
d1373 1
a1373 1
		| kFOR block_var kIN {COND_PUSH(1);} expr do {COND_POP();}
a1376 1
			value_expr($5);
a1466 1
			value_expr($2);
d1507 6
d1521 1
a1521 1
		| kELSIF expr then
a1524 1
			value_expr($2);
d1584 1
a1584 1
		| block_call '.' operation2 opt_paren_args
a1585 1
			value_expr($1);
d1588 1
a1588 1
		| block_call tCOLON2 operation2 opt_paren_args
a1589 1
			value_expr($1);
d1593 6
d1604 1
a1604 1
		| primary '.' operation2 opt_paren_args
a1605 1
			value_expr($1);
d1609 1
a1609 1
		| primary tCOLON2 operation2 paren_args
a1610 1
			value_expr($1);
d1614 1
a1614 1
		| primary tCOLON2 operation3
a1615 1
			value_expr($1);
d1664 1
a1664 1
		| args ',' tSTAR arg
a1665 1
			value_expr($4);
d1668 1
a1668 1
		| tSTAR arg
a1669 1
			value_expr($2);
d1790 1
a1790 1
		  expr term
d1875 1
a1875 1
f_opt		: tIDENTIFIER '=' arg
d1929 1
d1945 1
d1970 1
a1970 1
assoc		: arg tASSOC arg
@


1.152
log
@* struct.c (Init_Struct): should undefine "allocate" for Struct
  class (it's redefined in the subclasses).
@
text
@d6 1
a6 1
  $Date: 2002/02/13 16:39:37 $
a429 1
			ID vid = $1->nd_vid;
d431 1
a774 1
			ID vid = $1->nd_vid;
d776 1
@


1.151
log
@sorry, assignable typo
@
text
@d6 1
a6 1
  $Date: 2002/02/13 09:01:09 $
a883 1

@


1.150
log
@* parse.y (stmt): local variable declaration order was changed
  since 1.6

* parse.y (arg): ditto.

* pack.c (pack_pack): add templates 'q' and 'Q'.

* pack.c (pack_unpack): ditto.

* bignum.c (rb_quad_pack): new utility function.

* bignum.c (rb_quad_unpack): ditto.

* parse.y (assignable): should emit CVASGN within the method
  body.

* dir.c (dir_s_glob): should not warn even if no match found.

* eval.c (rb_eval): clean up class variable behavior.

* eval.c (assign): ditto.

* eval.c (is_defined): ditto.

* variable.c (rb_mod_class_variables): need not to call rb_cvar_singleton().

* variable.c (rb_cvar_singleton): removed.
@
text
@d6 1
a6 1
  $Date: 2002/02/09 14:44:20 $
d1803 1
a1803 1
			$$ = assignable($1);
@


1.149
log
@* eval.c (rb_eval): singleton chech should be moved from yycompile
  to here.

* eval.c (is_defined): check should be added here too.
@
text
@d6 1
a6 1
  $Date: 2002/02/08 05:19:47 $
d218 1
a218 1
%type <node> command_args aref_args opt_block_arg block_arg var_ref
d428 1
a428 1
		| variable tOP_ASGN command_call
d430 2
a431 2
		        NODE *n = assignable($1, 0);
			if (n) {
d433 4
a436 4
				n->nd_value = $3;
				$$ = NEW_OP_ASGN_OR(gettable($1), n);
				if (is_instance_id($1)) {
				    $$->nd_aid = $1;
d440 2
a441 2
				n->nd_value = $3;
				$$ = NEW_OP_ASGN_AND(gettable($1), n);
d444 2
a445 2
				$$ = n;
				$$->nd_value = call_op(gettable($1),$2,1,$3);
d773 1
a773 1
		| variable tOP_ASGN arg
d775 2
a776 2
		        NODE *n = assignable($1, 0);
			if (n) {
d778 4
a781 4
				n->nd_value = $3;
				$$ = NEW_OP_ASGN_OR(gettable($1), n);
				if (is_instance_id($1)) {
				    $$->nd_aid = $1;
d785 2
a786 2
				n->nd_value = $3;
				$$ = NEW_OP_ASGN_AND(gettable($1), n);
d789 2
a790 2
				$$ = n;
				$$->nd_value = call_op(gettable($1),$2,1,$3);
d1801 5
a4329 1
	if (in_single) return NEW_CVAR2(id);
d4387 1
a4387 1
	if (in_single) return NEW_CVASGN(id, val);
@


1.148
log
@* parse.y (yycompile): should inherit "in_single" if eval happened
  in a singleton method.

* eval.c (rb_eval): class variables from singleton methods defined
  within singleton class statement should work like ones defined
  by sington def statements.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/02/01 10:23:22 $
a2147 4
    if (ruby_frame && ruby_frame->last_class &&
	FL_TEST(ruby_frame->last_class, FL_SINGLETON)) {
	in_single = 1;
    }
@


1.147
log
@* intern.h: prototypes for new functions; rb_cstr_to_inum(),
  rb_str_to_inum(), rb_cstr_to_dbl(), rb_str_to_dbl()

* bignum.c (rb_cstr_to_inum): changed from rb_cstr2inum(), and
  added argument badcheck to be consistent with parser. [new]

* bignum.c (rb_str_to_inum): ditto.

* bignum.c (rb_cstr2inum): wapper of rb_cstr_to_inum() now.

* bignum.c (rb_str2inum): ditto.

* object.c (rb_cstr_to_dbl): float number parser. [new]

* object.c (rb_str_to_dbl): ditto.

* object.c (rb_Float): use rb_cstr_to_dbl() for strict check.

* object.c (rb_Integer): use rb_str_to_inum() for strict check.

* string.c (rb_str_to_f): use rb_str_to_dbl() with less check.

* string.c (rb_str_to_i): use rb_str_to_inum() with less check.

* string.c (rb_str_hex): ditto.

* string.c (rb_str_oct): ditto.

* sprintf.c (rb_f_sprintf): ditto.

* time.c (obj2long): ditto.

* parse.y (yylex): use rb_cstr_to_inum() for strict check.
@
text
@d6 1
a6 1
  $Date: 2002/01/28 09:33:56 $
d2148 4
@


1.146
log
@* parse.y (yylex): strict check for numbers.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/28 08:44:37 $
d3348 1
a3348 1
		    yylval.val = rb_cstr2inum(tok(), 16);
d3372 1
a3372 1
		    yylval.val = rb_cstr2inum(tok(), 2);
d3391 1
a3391 1
			yylval.val = rb_cstr2inum(tok(), 8);
d3485 1
a3485 1
	    yylval.val = rb_cstr2inum(tok(), 10);
@


1.145
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.

* object.c (Init_Object): remove dup and clone from TrueClass,
  FalseClass, and NilClass.

* array.c (rb_ary_fill): Array#fill takes block to get the value to
  fill.

* string.c (rb_str_to_i): to_i(0) auto-detects base radix.

* array.c (rb_ary_initialize): fill by the block evaluation value
  if block is given.
@
text
@d6 1
a6 1
  $Date: 2002/01/21 07:44:06 $
d3315 1
a3315 1
	    int is_float, seen_point, seen_e, seen_uc;
d3317 1
a3317 1
	    is_float = seen_point = seen_e = seen_uc = 0;
d3325 1
d3330 12
a3341 9
		    do {
			if (c == '_') {
			    seen_uc = 1;
			    continue;
			}
			if (!ISXDIGIT(c)) break;
			seen_uc = 0;
			tokadd(c);
		    } while (c = nextc());
d3344 1
a3344 1
		    if (toklen() == 0) {
d3347 1
a3347 1
		    else if (seen_uc) goto trailing_uc;
d3354 12
a3365 9
		    do {
			if (c == '_') {
			    seen_uc = 1;
			    continue;
			}
			if (c != '0'&& c != '1') break;
			seen_uc = 0;
			tokadd(c);
		    } while (c = nextc());
d3368 1
a3368 1
		    if (toklen() == 0) {
d3371 1
a3371 1
		    else if (seen_uc) goto trailing_uc;
d3379 2
a3380 1
			    seen_uc = 1;
d3384 1
a3384 1
			seen_uc = 0;
d3387 7
a3393 5
		    pushback(c);
		    tokfix();
		    if (seen_uc) goto trailing_uc;
		    yylval.val = rb_cstr2inum(tok(), 8);
		    return tINTEGER;
d3398 1
a3398 1
		else if (c == '.') {
d3412 1
a3412 1
		    seen_uc = 0;
d3417 1
a3417 1
		    if (seen_uc) goto trailing_uc;
d3433 1
a3433 1
		    seen_uc = 0;
d3438 5
d3449 5
a3453 6
		    while ((c = nextc()) == '_')
			seen_uc = 1;
		    if (c == '-' || c == '+')
			tokadd(c);
		    else 
			continue;
d3457 2
a3458 1
		    seen_uc = 1;
d3470 2
a3471 1
	    if (seen_uc) {
d3473 2
a3474 1
		yyerror("trailing `_' in number");
@


1.144
log
@* eval.c (ruby_stop): should not trace error handler.

* signal.c (install_sighandler): do not install sighandler unless
  the old value is SIG_DFL.

* io.c (io_write): should not raise exception on O_NONBLOCK io.

* dir.c (dir_set_pos): seek should return dir, pos= should not.
@
text
@d6 1
a6 1
  $Date: 2002/01/18 14:23:07 $
d1145 1
a1145 1
			$$ = list_append(list_concat($1,$3), NEW_HASH($5));
@


1.143
log
@* io.c (rb_io_s_new): block check moved from initialize to this
  method.

* io.c (rb_io_s_open): open should call initialize too. IO#for_fd
  also calls initialize. [new]

* error.c (rb_sys_fail): replace INT2FIX() by INT2NUM() since
  errno value may not fit in Fixnum size on Hurd.

* error.c (set_syserr): ditto.

* dir.c (dir_s_glob): returns nil if block given.

* io.c (rb_io_each_byte): should return self.

* io.c (rb_io_close_m): close check added.

* dir.c (dir_seek): should return pos.

* parse.y (fixpos): orig may be (NODE*)1, which should not be
  dereferenced.
@
text
@d6 1
a6 1
  $Date: 2002/01/16 09:25:54 $
d4291 5
@


1.142
log
@* st.c: primes should be primes.

* eval.c (is_defined): method defined? check should honor
  protected too.

* eval.c (block_pass): should not pass tainted block, if $SAFE > 0.

* variable.c (rb_mod_remove_cvar): should pass the char*.
@
text
@d6 1
a6 1
  $Date: 2002/01/11 09:18:50 $
d4129 1
@


1.141
log
@* re.c (match_select): should propagate taintness.

* hash.c (rb_hash_set_default): Hash#default= should return the
  new value.

* string.c (rb_str_to_i): accepts optional base argument. [new]

* numeric.c (rb_fix2str): should not handle negative fixnum values
  int32 via calling sprintf() directly.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/01/04 15:20:48 $
d4281 1
a4281 3
	VALUE f = rb_str_new2(ruby_sourcefile);
	OBJ_FREEZE(f);
	return NEW_LIT(f);
@


1.140
log
@* parse.y (yycompile): strdup()'ed twice.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/04 14:14:34 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
d4283 1
a4283 1
	return NEW_STR(f);
@


1.139
log
@* process.c (rb_f_system): abandon vfork.

* io.c (pipe_open): ditto.

* defines.h: sparc linux needs different FLUSH_REGISTER_WINDOWS

* regex.c (re_search): abandon stclass optimization.

* bignum.c (rb_cstr2inum): deny "0_".

* bignum.c (rb_cstr2inum): allow "0\n" and so on.

* error.c (rb_invalid_str): utility function to show inspect()'ed
  string.

* bignum.c (rb_cstr2inum): prints invalid strings in inspect()'ed
  format.

* object.c (rb_Float): ditto.

* object.c (rb_convert_type): no longer use rb_rescue().

* re.c (rb_reg_search): initialize taint status of match object.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/12/31 05:23:53 $
a2119 2

    f = strdup(f);
@


1.138
log
@* parse.y (yycompile): always store copy of filename.

* parse.y (rb_compile_file): no longer need to strdup() here.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/12/22 02:51:00 $
d2148 1
a2148 1
    ruby_sourcefile = f;
@


1.137
log
@* parse.y (str_extend): make up "#$;" handling.
@
text
@d6 1
a6 1
  $Date: 2001/12/11 03:48:08 $
d2121 2
d2233 1
a2233 1
    return yycompile(strdup(f), start);
@


1.136
log
@* string.c (rb_str_match_m): should convert an argument into
  regexp if it's a string.

* array.c (rb_ary_select): Array#select(n,m,...) now works like
  Array#indexes(n,m,..). [new, experimental]

* hash.c (rb_hash_select): ditto.

* hash.c (env_select): ditto.

* re.c (match_select): ditto.

* struct.c (rb_struct_select): ditto.

* gc.c (STR_ASSOC): use FL_USER3 instead of FL_USER2.

* parse.y (str_extend): make up pushback call.
@
text
@d6 1
a6 1
  $Date: 2001/12/10 07:18:12 $
d3934 1
@


1.135
log
@* array.c (rb_ary_modify): should copy the internal buffer if the
  modifying buffer is shared.

* array.c (ary_make_shared): make an internal buffer of an array
  to be shared.

* array.c (rb_ary_shift): avoid sliding an internal buffer by
  using shared buffer.

* array.c (rb_ary_subseq): avoid copying the buffer.

* parse.y (gettable): should freeze __LINE__ string.

* io.c (rb_io_puts): old behavoir restored.  rationale: a) if you
  want to call to_s for arrays, you can just call print a, "\n".
  b) to_s wastes memory if array (and sum of its contents) is
  huge.  c) now any object that has to_ary is treated as an array,
  using rb_check_convert_type().

* hash.c (rb_hash_initialize): now accepts a block to calculate
  the default value. [new]

* hash.c (rb_hash_aref): call "default" method to get the value
  corrensponding to the non existing key.

* hash.c (rb_hash_default): get the default value based on the
  block given to 'new'.  Now it takes an optinal "key" argument.
  "default" became the method to get the value for non existing
  key.  Users may override "default" method to change the hash
  behavior.

* hash.c (rb_hash_set_default): clear the flag if a block is given
  to 'new'

* object.c (Init_Object): undef Data.allocate, left Data.new.

* ext/curses/curses.c (window_scrollok): use RTEST().

* ext/curses/curses.c (window_idlok): ditto.

* ext/curses/curses.c (window_keypad): ditto.

* ext/curses/curses.c (window_idlok): idlok() may return void on
  some platforms; so don't use return value.

* ext/curses/curses.c (window_scrollok): ditto for consistency.

* ext/curses/curses.c: replace FIX2INT() by typechecking NUM2INT().

* parse.y (str_extend): should not process immature #$x and
  #@@x interpolation, e.g #@@#@@ etc.

* enum.c (enum_sort_by): sort_by does not have to be stable always.

* enum.c (enum_sort_by): call qsort directly to gain performance.

* util.c (ruby_qsort): ruby_qsort(qs6) is now native thread safe.

* error.c (rb_sys_fail): it must be a bug if it's called when
  errno == 0.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/11/25 12:09:21 $
d3963 1
@


1.134
log
@	* parse.y (str_extend): change types of second and third arguments
	  from char to int.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/11/21 15:41:26 $
d3941 4
d3963 8
a3970 3
		yyerror("bad global variable in string");
		newtok();
		return list;
d4009 3
d4279 3
a4281 1
	return NEW_STR(rb_str_new2(ruby_sourcefile));
@


1.133
log
@* parse.y (str_extend): should check nesting parentheses in #{}.

* process.c (pst_wstopsig): returns nil unless WIFSTOPPED() is
  non-zero.

* process.c (pst_wtermsig): returns nil unless WIFSIGNALED() is
  non-zero.

* process.c (pst_wexitstatus): returns nil unless WIFEXITED() is
  non-zero.

* eval.c (rb_thread_select): tv_sec and tv_usec should not be
  negative.

* signal.c (posix_signal): do not set SA_RESTART for SIGVTALRM.

* parse.y (call_args2): block_arg may follow the first argument in
  call_args2.

* eval.c (stack_check): should avoid stack length check during
  raising SystemStackError exception.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 16:20:06 $
d2051 1
a2051 1
static NODE *str_extend _((NODE*,char,char));
d3882 1
a3882 1
    char term, paren;
@


1.132
log
@* parse.y (str_extend): should not terminate string interpolation
  with newlines in here-docs and newline terminated strings.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 14:42:45 $
d1107 4
d2051 1
a2051 1
static NODE *str_extend();
d2520 1
a2520 1
	    list = str_extend(list, term);
d2649 1
a2649 1
	    list = str_extend(list, term);
d3880 1
a3880 1
str_extend(list, term)
d3882 1
a3882 1
    char term;
d3888 2
a3889 1
    int nest;
d4004 1
a4004 1
	nest = 0;
d4010 1
a4010 1
		if (nest > 0) {
d4018 2
a4019 2
		    if (nest == 0) break;
		    nest--;
d4035 1
a4035 1
		if (brace != -1) nest++;
d4037 2
a4038 1
		if (c == term) {
d4291 1
a4291 1
    rb_bug("invalid id for gettable");
@


1.131
log
@* eval.c (rb_mod_modfunc): should follow NODE_ZSUPER link; based
  on Guy Decoux's patch in [ruby-talk:25478].

* string.c (rb_str_succ): there was buffer overrun.

* parse.y (str_extend): term can be any character.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/11/18 10:49:28 $
d2904 1
a2904 1
	switch (parse_string(term, '\n', '\n')) {
d4041 1
@


1.130
log
@* parse.y: needless conditionals.

* parse.y (parse_regx): parse error at unterminated regex /#{.
  (ruby-bugs-ja:PR#142)
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/11/13 08:19:52 $
d4031 1
a4031 3
	      case '\"':
	      case '/':
	      case '`':
d4035 1
a4035 1
		    rb_warning("bad substitution in string");
a4040 1
	      default:
@


1.129
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* eval.c (rb_eval_cmd): should not upgrade safe level unless
  explicitly specified by argument newly added.

* signal.c (sig_trap): should not allow tainted trap closure.

* variable.c (rb_f_trace_var): should not allow trace_var on safe
  level higher than 3.

* variable.c (rb_f_trace_var): should not allow tainted trace
  closure.

* gc.c: do not use static stack until system stack overflows.

* eval.c (eval): should call Exception#exception instead of
  calling rb_exc_new3() directly.

* error.c (exc_exception): set "mesg" directly to the clone.  it
  might be better to set mesg via some method for flexibility.

* variable.c (cvar_override_check): should print original module
  name, if 'a' is T_ICLASS.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/11/08 06:43:08 $
d445 1
a445 3
				if ($$) {
				    $$->nd_value = call_op(gettable($1),$2,1,$3);
				}
d790 1
a790 3
				if ($$) {
				    $$->nd_value = call_op(gettable($1),$2,1,$3);
				}
d2517 1
a2517 1
	    if (list == (NODE*)-1) return 0;
@


1.128
log
@* process.c (security): always give warning for insecure PATH.

* dir.c (my_getcwd): do not rely on MAXPATHLEN.

* file.c (rb_file_s_readlink): ditto.

* file.c (path_check_1): ditto.

* eval.c (rb_yield_0): should not call rb_f_block_given_p().

* string.c (rb_str_chomp_bang): should terminate string by NUL.

* eval.c (rb_yield_0): better error message.
@
text
@d6 1
a6 1
  $Date: 2001/10/30 08:43:25 $
d3407 1
@


1.127
log
@* string.c (rb_str_chomp_bang): do smart chomp if $/ == '\n'.

* io.c (rb_io_puts): don't treat Array specially.

* bignum.c (rb_big_cmp): should convert bignum to float.

* eval.c (rb_f_eval): can't modify untainted binding.

* regex.c (re_compile_pattern): should preverve p0 value.
@
text
@d6 1
a6 1
  $Date: 2001/10/29 05:07:18 $
d431 11
a441 5
			if ($2 == tOROP) {
			    n->nd_value = $3;
			    $$ = NEW_OP_ASGN_OR(gettable($1), n);
			    if (is_instance_id($1)) {
				$$->nd_aid = $1;
d443 7
a449 4
			}
			else if ($2 == tANDOP) {
			    n->nd_value = $3;
			    $$ = NEW_OP_ASGN_AND(gettable($1), n);
d452 1
a452 4
			    $$ = n;
			    if ($$) {
				$$->nd_value = call_op(gettable($1),$2,1,$3);
			    }
a453 1
			fixpos($$, $3);
d778 11
a788 5
			if ($2 == tOROP) {
			    n->nd_value = $3;
			    $$ = NEW_OP_ASGN_OR(gettable($1), n);
			    if (is_instance_id($1)) {
				$$->nd_aid = $1;
d790 7
a796 4
			}
			else if ($2 == tANDOP) {
			    n->nd_value = $3;
			    $$ = NEW_OP_ASGN_AND(gettable($1), n);
d799 1
a799 4
			    $$ = n;
			    if ($$) {
				$$->nd_value = call_op(gettable($1),$2,1,$3);
			    }
a800 1
			fixpos($$, $3);
@


1.126
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* variable.c (rb_cvar_set): empty iv_tbl may cause infinite loop.

* variable.c (rb_cvar_get): ditto.

* variable.c (cvar_override_check): ditto.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.

* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/10/15 15:11:51 $
d428 75
d770 1
a770 1
		| variable tOP_ASGN {$$ = assignable($1, 0);} arg
d772 1
d774 2
a775 2
			    $<node>3->nd_value = $4;
			    $$ = NEW_OP_ASGN_OR(gettable($1), $<node>3);
d781 2
a782 2
			    $<node>3->nd_value = $4;
			    $$ = NEW_OP_ASGN_AND(gettable($1), $<node>3);
d785 1
a785 1
			    $$ = $<node>3;
d787 1
a787 1
				$$->nd_value = call_op(gettable($1),$2,1,$4);
d790 1
a790 1
			fixpos($$, $4);
@


1.125
log
@* parse.y (yylex): disallow alpha-numeric and mbchar for
  terminator of %string.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/10 08:21:13 $
d3847 6
@


1.124
log
@* file.c (rb_stat_clone): should copy internal data too.

* numeric.c (num_clone): Numeric should not be copied by clone.

* object.c (rb_obj_clone): should check immediate values.

* parse.y (command): `yield' should take command_args.

* parse.y (parse_quotedwords): %w(...) is not a string.
@
text
@d6 1
a6 1
  $Date: 2001/10/02 04:31:19 $
d3531 4
@


1.123
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* string.c (rb_str_subpat_set): support function for new argument
  pattern String#[re,offset] = val. [new]

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_aref_m): new argument pattern
  String#[re,offset]. [new]

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* array.c (rb_ary_initialize): Array.new([1,2,3]) => [1,2,3]. [new]

* string.c (rb_str_reverse): should return an instance of
  receiver's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.

* eval.c (eval): retrieves file, line information from binding.

* eval.c (intersect_fds): counts intersecting fds.

* eval.c (rb_thread_schedule): only fds requested by
  each thread count as select_value.
@
text
@d5 2
a6 2
  $Author: ts $
  $Date: 2001/09/26 17:09:47 $
d211 1
a211 1
%token <node> tDSTRING tDXSTRING tDREGEXP tNTH_REF tBACK_REF
d513 1
a513 1
		| kYIELD call_args
d1166 1
d2746 1
a2746 1
    return tDSTRING;
@


1.122
log
@Wed Sep 26 19:02:39 2001  Guy Decoux  <ts@@moulon.inra.fr>

	* parse.y: allow 'primary[] = arg'
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/09/20 06:23:50 $
d718 1
a718 1
			NODE *args = NEW_LIST($6);
@


1.121
log
@* eval.c, intern.h (rb_svar): return reference to special variable
  from local variable index. [new]

* eval.c (rb_eval): use rb_svar() for NODE_FLIP{2,3}.

* parse.y (rb_(backref|lastline)_(get|set)): access via rb_svar().

* eval.c (proc_invoke): push dynamic variables.

* eval.c (rb_thread_yield): push special variables as dynamic
  variables($_, $~ and FLIP states).


* intern.h, parse.y (rb_is_local_id): return true if the ID is
  local symbol. [new]

* parse.y (internal_id): make new ID for internal use. [new]

* parse.y (cond0): allocate internal ID for NODE_FLIP{2,3}.

* eval.c (rb_f_local_variables): use rb_is_local_id() to select
  visible local variables.


* eval.c (rb_thread_start_0): SCOPE_SHARED is removed.

* eval.c, intern.h (rb_thread_scope_shared_p): removed. special
  variables are no longer shared by threads.

* re.c (rb_reg_search): MATCHDATA is no longer shared by threads.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/09/19 06:54:10 $
d720 1
a720 1
			list_append($3, NEW_NIL());
@


1.120
log
@* string.c (rb_str_init): String.new() => ""

* dir.c (dir_path): new method.

* dir.c (dir_initialize): wrap DIR into struct, along with path
  information.
@
text
@d6 1
a6 1
  $Date: 2001/09/05 06:54:53 $
d33 1
d142 1
d4631 1
a4631 1
	node->nd_cnt = local_append(0);
d5008 8
a5019 1
    static ID last_id = LAST_TOKEN;
d5174 8
d5195 2
d5200 3
a5202 2
    if (ruby_scope->local_vars) {
	return ruby_scope->local_vars[1];
d5211 3
a5213 2
    if (ruby_scope->local_vars) {
	ruby_scope->local_vars[1] = val;
d5223 3
a5225 2
    if (ruby_scope->local_vars) {
	return ruby_scope->local_vars[0];
d5234 3
a5236 2
    if (ruby_scope->local_vars) {
	ruby_scope->local_vars[0] = val;
@


1.119
log
@* re.c (Init_Regexp): to_s to be alias to inspect.

* parse.y (yylex): should support 'keyword='.

* ruby.c (proc_options): should not adjust argc/argv if -e option
  is supplied.
@
text
@d6 1
a6 1
  $Date: 2001/08/29 06:28:44 $
a3461 1
		rb_warning("%s (...) interpreted as method call", tok());
@


1.118
log
@* parse.y (yylex): ternary ? can be followed by newline.

* eval.c (rb_f_require): should check static linked libraries
  before raising exception.

* array.c (rb_ary_equal): check identiry equality first.

* string.c (rb_str_equal): ditto.

* struct.c (rb_struct_equal): ditto.

* numeric.c (Init_Numeric): undef Integer::new.

* eval.c (rb_eval): NODE_WHILE should update result for each
  conditional evaluation.

* eval.c (rb_eval): NODE_UNTIL should return last evaluated value
  (or value given to break).
@
text
@d6 1
a6 1
  $Date: 2001/08/23 06:02:15 $
a2899 1
    struct kwtable *kw;
d3716 1
d3718 22
d3741 2
a3766 21
	    if (toklast() == '!' || toklast() == '?') {
		result = tFID;
	    }
	    else {
		if (lex_state == EXPR_FNAME) {
		    if ((c = nextc()) == '=' && !peek('~') && !peek('>') &&
			(!peek('=') || lex_p + 1 < lex_pend && lex_p[1] == '>')) {
			result = tIDENTIFIER;
			tokadd(c);
		    }
		    else {
			pushback(c);
		    }
		}
		if (result == 0 && ISUPPER(tok()[0])) {
		    result = tCONSTANT;
		}
		else {
		    result = tIDENTIFIER;
		}
	    }
@


1.117
log
@* eval.c (is_defined): should not dump core for "defined?(())".

* eval.c (umethod_bind): recv can be an instance of descender of
  oklass if oklass is a Module.

* hash.c (rb_hash_equal): check identiry equality first.

* file.c (group_member): should check real gid only.

* file.c (eaccess): do not cache euid, since effective euid may be
  changed via Process.euid=().

* file.c (eaccess): return -1 unless every specified access mode
  is permitted.

* eval.c (rb_eval): while/until returns the value which is given
  to break.

* parse.y (value_expr): using while/until/class/def as an
  expression is now gives a warning, not an error.

* range.c (range_eqq): should compare strings based on magical
  increment (using String#upto), not dictionary order.

* enum.c (enum_sort_by): new method for Schewartzian transformed
  stable sort.

* variable.c (mod_av_set): detect constant overriding for built-in
  classes/modules.
@
text
@d6 1
a6 1
  $Date: 2001/08/20 06:15:53 $
d3085 1
a3085 1
	if (c == -1 || c == 10) {
@


1.116
log
@* parse.y (tokadd_escape): escaped backslashes too much.
@
text
@d6 1
a6 1
  $Date: 2001/08/20 04:29:56 $
d1194 1
a1194 1
		        rb_warning("%s (...) interpreted as command call", rb_id2name($<id>1));
a4357 5
      case NODE_RETURN:
      case NODE_BREAK:
      case NODE_NEXT:
      case NODE_REDO:
      case NODE_RETRY:
d4364 8
a4373 1
	break;
@


1.115
log
@* range.c (range_step): 'iter' here should be an array.

* marshal.c (w_object): should retrieve __member__ data from
  non-singleton class.

* variable.c (rb_cvar_get): class variable override check added.

* variable.c (rb_cvar_set): ditto

* variable.c (rb_cvar_declare): ditto.

* parse.y (parse_regx): handle backslash escaping of delimiter here.
@
text
@d6 1
a6 1
  $Date: 2001/08/14 08:13:26 $
d2404 1
a2404 1
	if (c == '/' && c != term)
@


1.114
log
@* range.c (range_step): new method.

* string.c (rb_str_cmp): remove needless conditional.

* string.c (rb_str_lstrip_bang) `return Qnil' was missing.
@
text
@d6 1
a6 1
  $Date: 2001/08/06 03:05:13 $
d2330 2
a2331 1
tokadd_escape()
d2392 1
a2392 1
	    return tokadd_escape();
d2404 2
a2405 1
	tokadd('\\');
d2436 1
a2436 1
	    if (tokadd_escape() < 0)
@


1.113
log
@* string.c (rb_str_lstrip_bang): new method.

* string.c (rb_str_rstrip_bang): new method.

* string.c (rb_str_associate): should consider STR_ASSOC too.

* eval.c (rb_undefined): do not recurse if method_missing is
  undefined.

* process.c (proc_waitpid): now all arguments are optional.

* process.c (Init_process): waitpid is now alias to wait.

* process.c (Init_process): waitpid2 is now alias to wait2.

* process.c (rb_waitpid): made public.

* ext/pty/pty.c (pty_getpty): avoid disturbing SIGCHLD using
  thread and rb_waitpid.

* process.c (proc_getpgrp): now takes no argument on all
  platforms.

* process.c (proc_setpgrp): ditto.

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::pack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::pack_sockaddr_un(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::unpack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::unpack_sockaddr_un(). [new]
@
text
@d6 1
a6 1
  $Date: 2001/07/02 08:46:21 $
d4573 1
a4573 1
range_op(node, logop)
a4574 1
    int logop;
a4577 1
    if (logop) return node;
a4579 1
    warn_unless_e_option("integer literal in condition");
d4584 1
d4591 1
a4591 1
cond0(node, logop)
a4592 1
    int logop;
a4596 1
    if (logop) return node;
d4611 6
d4619 2
a4620 2
	node->nd_beg = range_op(node->nd_beg, logop);
	node->nd_end = range_op(node->nd_end, logop);
d4629 1
a4629 1
	    warning_unless_e_option("regex literal in condition");
d4634 3
d4642 1
a4642 1
cond1(node, logop)
a4643 1
    int logop;
d4647 1
a4647 1
	node->nd_next = cond0(node->nd_next, logop);
d4650 1
a4650 8
    return cond0(node, logop);
}

static NODE*
cond(node)
    NODE *node;
{
    return cond1(node, 0);
d4659 1
a4659 1
    return rb_node_newnode(type, cond1(left, 1), cond1(right, 1), 0);
@


1.112
log
@* error.c (exc_exception): clone the receiver exception instead of
  creating brand new exception object of the receiver.

* eval.c (rb_eval_string_wrap): extend new ruby_top_self, not
  original self.

* eval.c (rb_eval_cmd): respect ruby_wrapper if set.

* eval.c (eval): do not update ruby_class unless scope is not
  provided.

* eval.c (eval): preserve wrapper information.

* eval.c (proc_invoke): ditto.

* eval.c (block_pass): ditto.

* parse.y (void_expr): too much warnings for void context
  (e.g. foo[1] that can be mere Proc call).

* error.c (rb_name_error): new function to raise NameError with
  name attribute set.

* eval.c (rb_f_missing): set name and args in the exception
  object. [new]

* error.c (name_name): NameError#name - new method.

* error.c (nometh_args): NoMethodError#args - new method.

* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.

* dir.c (isdelim): space, tab, and newline are no longer
  delimiters for glob patterns.

* eval.c (svalue_to_avalue): new conversion scheme between single
  value and array values.

* eval.c (avalue_to_svalue): ditto.

* eval.c (rb_eval): REXPAND now uses avalue_to_svalue(), return
  and yield too.

* eval.c (rb_yield_0): use avalue_to_svalue().

* eval.c (proc_invoke): Proc#call gives avaules, whereas
  Proc#yield gives mvalues.

* eval.c (bmcall): convert given value (svalue) to avalue.
@
text
@d6 1
a6 1
  $Date: 2001/06/23 15:14:14 $
d4600 2
a4604 1
	if (logop) break;
@


1.111
log
@* eval.c (svalue_to_avalue): new conversion scheme between single
  value and array values.

* eval.c (avalue_to_svalue): ditto.

* eval.c (rb_eval): REXPAND now uses avalue_to_svalue(), return
  and yield too.

* eval.c (rb_yield_0): use avalue_to_svalue().

* eval.c (proc_invoke): Proc#call gives avaules, whereas
  Proc#yield gives mvalues.

* eval.c (bmcall): convert given value (svalue) to avalue.
@
text
@d6 1
a6 1
  $Date: 2001/06/22 09:12:20 $
a101 1
static ID last_id = 0;
d1093 1
a1093 1
		    | tLPAREN_ARG  {lex_state = EXPR_ENDARG;} ')'
d1096 1
a1096 1
		                   rb_id2name(last_id));
d1102 1
a1102 1
		                   rb_id2name(last_id));
d1194 1
a1194 1
		        rb_warning("%s (...) interpreted as command call", rb_id2name(last_id));
d2894 1
d3463 1
a4425 4
	  case tAREF:
	  case tRSHFT:
	  case tCOLON2:
	  case tCOLON3:
@


1.110
log
@* eval.c (rb_yield_0): no mvalue_to_svalue conversion here.

* eval.c (massign): takes svalue, convert it to mvalue inside.

* eval.c (rb_eval): parameters for yield/return are always
  svalues now.

* eval.c (svalue_to_mvalue): more strict conversion.

* eval.c (mvalue_to_svalue): ditto.

* st.c (new_size): prime hash size enabled.

* ext/socket/socket.c (Init_socket): SO_* constants added.
@
text
@d6 1
a6 1
  $Date: 2001/06/08 14:20:20 $
d429 1
a429 1
			$$ = node_assign($1, NEW_SVALUE($3));
d1137 1
a1137 1
			$$ = NEW_SVALUE($1);
@


1.109
log
@* gc.c (Init_stack): avoid __builtin_frame_address(2) to retrieve
  stack bottom line.

* st.c (numhash): should shuffle bits by dividing by prime number.

* eval.c (rb_eval): multiple assignment behavior fixed, which
  results "*a = nil" makes "a == []" now.

* eval.c (rb_f_require): should set SCOPE_PUBLIC before calling
  dln_load().
@
text
@d6 1
a6 1
  $Date: 2001/06/07 08:40:54 $
d429 1
a429 1
			$$ = node_assign($1, $3);
d1136 3
d1153 1
a1153 1
			$$ = NEW_REXPAND($2);
d4672 1
a4672 4
	if (nd_type(node) == NODE_ARRAY && node->nd_next == 0) {
	    node = node->nd_head;
	}
	else if (nd_type(node) == NODE_BLOCK_PASS) {
a4674 3
    }
    if (nd_type(node) == NODE_RESTARGS) {
	nd_set_type(node, NODE_REXPAND);
@


1.108
log
@* parse.y (yylex): incomplete fix.
@
text
@d6 1
a6 1
  $Date: 2001/06/07 08:29:59 $
a428 3
			if (nd_type($3) == NODE_RESTARGS) {
			    nd_set_type($3, NODE_REXPAND);
			}
d954 1
a954 1
			$$ = NEW_RESTARGS($2);
d1150 1
a1150 1
			$$ = NEW_RESTARGS($2);
@


1.107
log
@* parse.y (yylex): exclude kDO_BLOCK too much by false condition.
@
text
@d6 1
a6 1
  $Date: 2001/06/06 07:40:31 $
d3726 2
a3727 1
			if (CMDARG_P()) return kDO_BLOCK;
@


1.106
log
@* eval.c (rb_load): should check if tainted even when wrap is
  specified.

* regex.c (re_compile_pattern): too much optimization for the
  cases like /(.|a)b/.
@
text
@d6 1
a6 1
  $Date: 2001/06/06 06:42:21 $
d429 3
d1153 1
a1153 1
			$$ = NEW_REXPAND($2);
d1218 1
a1218 1
			if ($2 == 0)
d1220 1
d3726 1
a3726 2
			if (CMDARG_P() && state != EXPR_CMDARG && state != EXPR_ARG)
			    return kDO_BLOCK;
@


1.105
log
@* parse.y (aref_args): "*arg" should always be expanded by REXPAND.

* variable.c (fc_i): removed vast string allocation.
@
text
@d6 1
a6 1
  $Date: 2001/06/05 07:50:59 $
d1150 1
a1150 1
			$$ = NEW_RESTARGS($2);
@


1.104
log
@* error.c (Init_Exception): NameError went under StandardError,
  and NoMethodError went under NameError.

* parse.y (rb_intern): non identifier symbols should be
  categorized as ID_JUNK. [new]
@
text
@d6 1
a6 1
  $Date: 2001/06/05 07:19:38 $
d429 1
a429 1
			$$ = node_assign($1, ret_args($3));
@


1.103
log
@* variable.c (rb_mod_const_at): use hash table as internal
  data. [new]

* variable.c (rb_mod_const_of): ditto.

* variable.c (rb_const_list): new function to convert internal
  data (hash table) to array of strings.

* eval.c (rb_mod_s_constants): data handling scheme has changed.

* eval.c (rb_add_method): should not call rb_secure(), for
  last_func may not be set.

* io.c (rb_io_ctl): ioctl should accept any integer within C long
  range.

* marshal.c (r_object): wrong type check for modules.

* marshal.c (w_object): should not dump anonymous classes/modules.

* io.c (rb_open_file): use rb_file_sysopen_internal() if the 3rd
  argument (permission flags) is given. [new, should be backported?]

* io.c (rb_io_mode_binmode): mode string (e.g. "r+") to flags to
  open(2).

* eval.c (rb_eval): NODE_REXPAND expand an array of 1 element as
  the element itself. [new, should be backported?]

* parse.y (ret_args): should treat "*[a]" in rhs expression as
  "a", not "[a]".

* regex.c (re_compile_pattern): should push option modifier at the
  right place.
@
text
@d6 1
a6 1
  $Date: 2001/06/01 07:52:34 $
d32 1
a4991 1
    tCOLON3,	"::",
d5012 1
d5020 1
a5020 1
    switch (name[0]) {
d5023 2
d5027 2
a5028 1
	if (name[1] == '@@')
d5030 2
a5031 1
	else
d5033 2
d5038 1
a5038 1
	    /* operator */
d5072 4
@


1.102
log
@* parse.y (call_args2): confusion with list_append() and
  list_concat() was fixed.
@
text
@d6 1
a6 1
  $Date: 2001/06/01 06:47:30 $
d428 1
a428 1
			$$ = node_assign($1, $3);
d1149 1
a1149 1
			$$ = $2;
d4673 3
@


1.101
log
@* parse.y (yylex): fixed 'print CGI::bar() {}, "\n"' syntax
  breakage, adding new lex_state status.  sigh. [new]

* file.c (rb_file_s_unlink): should not allow if $SAFE >= 2.

* range.c (Init_Range): define "to_ary".
@
text
@d6 1
a6 1
  $Date: 2001/05/30 09:12:34 $
d1021 1
a1021 1
			$$ = arg_blk_pass(list_append(NEW_LIST($1),$3), $4);
d1034 1
a1034 1
			$$ = arg_concat(list_append($1,$3), $6);
d1057 1
a1057 1
			$$ = list_append(list_append($1,$3), NEW_HASH($5));
d1071 1
a1071 1
			$$ = arg_concat(list_append(list_append(NEW_LIST($1), $3), NEW_HASH($5)), $8);
@


1.100
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d6 1
a6 1
  $Date: 2001/05/24 06:10:32 $
d55 1
d1093 1
a1093 1
		| tLPAREN_ARG  ')'
d1099 1
a1099 1
		| tLPAREN_ARG call_args2 ')'
d1189 1
a1189 1
		| tLPAREN_ARG expr ')'
d3012 3
a3014 1
	    lex_state != EXPR_END && lex_state != EXPR_CLASS &&
d3073 1
a3073 1
	if (lex_state == EXPR_END) {
d3396 1
a3396 1
	if (lex_state == EXPR_END || ISSPACE(c)) {
d3490 3
a3492 1
	    if (lex_state != EXPR_END)
a3493 2
	    if (space_seen && CMDARG_P())
		c = tLBRACE_ARG;
@


1.99
log
@* eval.c (rb_yield_0): need argument adjustment for C defined
  blocks too.
@
text
@d6 1
a6 1
  $Date: 2001/05/22 08:28:11 $
d54 1
a66 1
static int cond_nest = 0;
d68 2
a69 3
#define COND_PUSH do {\
    cond_nest++;\
    cond_stack = (cond_stack<<1)|1;\
d71 1
a71 2
#define COND_POP do {\
    cond_nest--;\
d74 6
a79 1
#define COND_P() (cond_nest > 0 && (cond_stack&1))
d82 2
a83 2
#define CMDARG_PUSH do {\
    cmdarg_stack = (cmdarg_stack<<1)|1;\
d85 5
a89 1
#define CMDARG_POP do {\
d91 1
d93 1
a93 1
#define CMDARG_P() (cmdarg_stack && (cmdarg_stack&1))
d100 1
d116 1
d120 1
d147 1
d214 1
a214 1
%type <node> args ret_args when_args call_args paren_args opt_paren_args
d243 1
d247 1
d437 1
a437 1
expr		: kRETURN ret_args
d441 1
a441 1
			$$ = NEW_RETURN($2);
d443 1
a443 1
		| kBREAK ret_args
d445 1
a445 1
			$$ = NEW_BREAK($2);
d447 1
a447 1
		| kNEXT ret_args
d449 1
a449 1
			$$ = NEW_NEXT($2);
d486 1
a486 1
command		:  operation command_args
d510 1
a510 1
		| kYIELD ret_args
d512 1
a512 1
			$$ = NEW_YIELD($2);
d1018 81
a1098 1
command_args	: {CMDARG_PUSH;} call_args
d1100 2
a1101 1
		        CMDARG_POP;
a1150 14
ret_args	: call_args
		    {
			$$ = $1;
			if ($1) {
			    if (nd_type($1) == NODE_ARRAY &&
				$1->nd_next == 0) {
				$$ = $1->nd_head;
			    }
			    else if (nd_type($1) == NODE_BLOCK_PASS) {
				rb_compile_error("block argument should not be given");
			    }
			}
		    }

d1188 5
d1229 1
a1229 1
		| kYIELD '(' ret_args ')'
d1232 1
a1232 1
			$$ = NEW_YIELD($3);
d1280 1
a1280 1
		| kWHILE {COND_PUSH;} expr do {COND_POP;}
d1288 1
a1288 1
		| kUNTIL {COND_PUSH;} expr do {COND_POP;} 
d1308 1
a1308 1
		| kFOR block_var kIN {COND_PUSH;} expr do {COND_POP;}
d1496 10
d2012 1
a2057 1
    cond_nest = 0;
d2060 1
a2810 7
#if 0
	if (indent) {
	    while (*lex_p && *lex_p == '\t') {
		lex_p++;
	    }
	}
#endif
d2884 2
d2891 1
d2894 2
d2925 1
d2945 1
a2945 1
	if (lex_state == EXPR_ARG && space_seen && !ISSPACE(c)){
d3012 1
a3012 1
	    (lex_state != EXPR_ARG || space_seen)) {
d3079 1
a3079 1
	if (lex_state == EXPR_ARG && ISSPACE(c)){
d3108 2
a3109 2
	if (lex_state == EXPR_ARG && space_seen && !ISSPACE(c)){
	    rb_warning("`&' interpreted as argument prefix");
d3153 2
a3154 2
	    (lex_state == EXPR_ARG && space_seen && !ISSPACE(c))) {
	    if (lex_state == EXPR_ARG) arg_ambiguous();
d3182 2
a3183 2
	    (lex_state == EXPR_ARG && space_seen && !ISSPACE(c))) {
	    if (lex_state == EXPR_ARG) arg_ambiguous();
a3374 3
	lex_state = EXPR_END;
	return c;

d3376 2
a3377 3
	if (cond_nest > 0) {
	    cond_stack >>= 1;
	}
d3385 1
a3385 1
		(lex_state == EXPR_ARG && space_seen)) {
d3410 1
a3410 1
	if (lex_state == EXPR_ARG && space_seen) {
d3428 2
a3430 1
      case ';':
d3444 1
a3444 3
	if (cond_nest > 0) {
	    cond_stack = (cond_stack<<1)|0;
	}
d3448 8
a3455 2
	else if (lex_state == EXPR_ARG && space_seen) {
	    rb_warning("%s (...) interpreted as method call", tok());
d3457 2
d3477 1
a3477 1
	else if (lex_state == EXPR_ARG && space_seen) {
d3481 2
d3486 8
a3493 2
	if (lex_state != EXPR_END && lex_state != EXPR_ARG)
	    c = tLBRACE;
d3556 1
a3556 1
	if (lex_state == EXPR_ARG && space_seen && !ISSPACE(c)) {
d3718 2
a3719 1
			if (CMDARG_P()) return kDO_BLOCK;
a3736 3
#if 0
		    if ((c = nextc()) == '=' && !peek('=') && !peek('~') && !peek('>')) {
#else
a3738 1
#endif
d3755 6
a3760 2
		lex_state == EXPR_ARG) {
		lex_state = EXPR_ARG;
d3767 1
a3767 1
	yylval.id = rb_intern(tok());
d4660 15
d4684 21
@


1.98
log
@* variable.c (rb_alias_variable): should not allow variable
  aliasing if $SAFE >= 4.

* parse.y (expr): "break" and "next" to take optional expression,
  which is used as a value for termination. [new, experimental]

* eval.c (rb_eval): "break" can give value to terminating method.

* eval.c (rb_eval): "break" and "next" to take optional expression.

* eval.c (rb_yield_0): "next" can give value to terminating "yield".

* eval.c (rb_iterate): "break" can give value to terminating method.

* eval.c (proc_call): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/05/21 04:22:54 $
a1396 5
		| '<' f_args '>'
		    {
			$$ = (NODE*)2;
		    }

@


1.97
log
@* bignum.c (rb_big2str): t should be protected from GC.

* process.c (rb_proc_times): need not to check retrun value from
  times(2).
@
text
@d6 1
a6 1
  $Date: 2001/05/16 09:05:50 $
d429 1
a429 1
		| kBREAK
d431 1
a431 1
			$$ = NEW_BREAK();
d433 1
a433 9
		| kNEXT
		    {
			$$ = NEW_NEXT();
		    }
		| kREDO
		    {
			$$ = NEW_REDO();
		    }
		| kRETRY
d435 1
a435 1
			$$ = NEW_RETRY();
a1136 13
		| kRETURN '(' ret_args ')'
		    {
			if (!compile_for_eval && !in_def && !in_single)
			    yyerror("return appeared outside of method");
			value_expr($3);
			$$ = NEW_RETURN($3);
		    }
		| kRETURN '(' ')'
		    {
			if (!compile_for_eval && !in_def && !in_single)
			    yyerror("return appeared outside of method");
			$$ = NEW_RETURN(0);
		    }
d1341 16
d1396 4
@


1.96
log
@* array.c (rb_ary_and): should not push frozen key string.

* array.c (rb_ary_or): ditto.

* eval.c (rb_thread_schedule): should save context before raising
  deadlock, saved context for current thread might be obsolete.

* time.c (make_time_t): non DST timezone shift supported (hopefully).

* time.c (make_time_t): strict range detection for negative time_t.

* signal.c: SIGINFO added.

* eval.c (rb_ensure): should not SEGV when prot_tag is NULL.
@
text
@d6 1
a6 1
  $Date: 2001/05/07 09:26:24 $
d429 16
a1360 16
		    }
		| kBREAK
		    {
			$$ = NEW_BREAK();
		    }
		| kNEXT
		    {
			$$ = NEW_NEXT();
		    }
		| kREDO
		    {
			$$ = NEW_REDO();
		    }
		| kRETRY
		    {
			$$ = NEW_RETRY();
@


1.95
log
@* parse.y (arg): "||=" should not warn for uninitialized instance
  variables.

* eval.c (rb_eval): ditto.

* eval.c (eval): preserve and restore ruby_cref as well.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:11 $
d22 1
@


1.94
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d6 1
a6 1
  $Date: 2001/03/13 09:00:01 $
d414 1
a414 3
		| expr

expr		: mlhs '=' mrhs
d420 3
a422 1
		| kRETURN ret_args
d674 3
d909 1
a909 1
		| command_call opt_nl
a912 4
		| args ',' command_call opt_nl
		    {
			$$ = list_append($1, $3);
		    }
a954 4
		    }
		| args ',' command
		    {
			$$ = list_append($1, $3);
@


1.93
log
@* eval.c (ev_const_defined): add new parameter self for special
  const fallback.

* eval.c (ev_const_get): ditto.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/03/13 06:00:50 $
d59 2
a60 4
#if SIZEOF_LONG_LONG > 0
typedef unsigned long long stack_type;
#elif SIZEOF___INT64 > 0
typedef unsigned __int64 stack_type;
a132 4
#define cref_push() NEW_CREF()
static void cref_pop();
static NODE *cur_cref;

a266 1
			NEW_CREF0(); /* initialize constant c-ref */
a284 1
			cur_cref = 0;
a1243 1
			cref_push();
a1252 1
			cref_pop();
a1264 1
			cref_push();
a1272 1
			cref_pop();
a1281 1
			cref_push();
a1290 1
			cref_pop();
d1973 1
d3624 7
a3630 1
		    return kw->id[state != EXPR_BEG];
a4780 6
static void
cref_pop()
{
    cur_cref = cur_cref->nd_next;
}

a4863 1
    rb_global_variable((VALUE*)&cur_cref);
d4970 19
@


1.92
log
@* parse.y: warn -> rb_warn
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/03/13 05:45:09 $
d4525 1
a4525 1
	warn_unless_e_option("range literal in condition");
@


1.91
log
@* io.c (argf_seek_m): wrong calling sequence of rb_io_seek().

* parse.y (cond0): no special treatment of string literal in
  condition.

* math.c: add acos, asin, atan, conh, sinh, tanh and hypot to Math.

* configure.in: check hypot availablility.

* missing/hypot.c: public domain rewrite of hypot.

* parse.y (warn_unless_e_option): warning condition was wrong.

* parse.y (warning_unless_e_option): ditto.

* enum.c (enum_all): new method 'all?', which returns true if
  block returns true for all elements.

* enum.c (enum_any): new method 'any?', which returns true if
  block retruns true for any of elements.

* marshal.c (marshal_load): do not give warning unless explicitly
  set to verbose.

* eval.c (rb_exit): give string value "exit" to SystemExit.

* ruby.c (proc_options): -v should not print version if
  proc_options called via moreswitches().

* parse.y (stmt): while/until modifier must work for empty body.
@
text
@d6 1
a6 1
  $Date: 2001/03/06 08:17:16 $
d4508 1
a4508 1
	warn("string literal in condition");
@


1.90
log
@* parse.y (primary): rescue and ensure clauses should be allowed
  to appear in singleton method body.
@
text
@d6 1
a6 1
  $Date: 2001/02/26 05:29:00 $
d236 1
d364 2
a365 7
			if ($1) {
			    if (nd_type($1) == NODE_BEGIN) {
				$$ = NEW_WHILE(cond($3), $1->nd_body, 0);
			    }
			    else {
				$$ = NEW_WHILE(cond($3), $1, 1);
			    }
d368 1
a368 1
			    $$ = 0;
d374 2
a375 7
			if ($1) {
			    if (nd_type($1) == NODE_BEGIN) {
				$$ = NEW_UNTIL(cond($3), $1->nd_body, 0);
			    }
			    else {
				$$ = NEW_UNTIL(cond($3), $1, 1);
			    }
d378 1
a378 1
			    $$ = 0;
d4464 1
a4464 1
    if (e_option_supplied()) rb_warn(str);
d4471 1
a4471 1
    if (e_option_supplied()) rb_warning(str);
d4477 1
a4477 1
cond2(node, logop)
d4506 1
d4508 2
a4509 3
	nd_set_type(node, NODE_DREGX);
	warn_unless_e_option("string literal in condition");
	goto dregex;
a4513 1
      dregex:
d4520 2
a4521 2
	node->nd_beg = cond2(node->nd_beg, logop);
	node->nd_end = cond2(node->nd_end, logop);
a4527 6
      case NODE_STR:
	if (logop) break;
	node->nd_lit = rb_reg_new(RSTRING(node->nd_lit)->ptr,RSTRING(node->nd_lit)->len,0);
	warn_unless_e_option("string literal in condition");
	goto regexp;

a4530 1
	  regexp:
@


1.89
log
@* eval.c (proc_call): should not modify ruby_block->frame.iter
  based on ruby_frame->iter altered by PUSH_ITER().

* eval.c (rb_thread_fd_close): should save current context before
  raising exception.

* io.c (set_stdin): preserve original stdin.

* io.c (set_outfile): preserve original stdout/stderr.
@
text
@d6 1
a6 1
  $Date: 2001/02/19 07:03:06 $
d1356 3
d1361 7
@


1.88
log
@* eval.c (secure_visibility): visibility check for untainted modules.

* signal.c (sigpipe): sighandler which does nothing.

* signal.c (trap): set sigpipe function for SIGPIPE.

* signal.c (Init_signal): default SIGPIPE handler should be
  sigpipe function.

* array.c (rb_ary_subseq): wrong boundary check.

* parse.y (cond0): integer literal in condition should not be
  compared to lineno ($.).
@
text
@d6 1
a6 1
  $Date: 2001/02/13 05:08:59 $
d1274 6
a1279 1
		| kCLASS tLSHFT expr term
a1286 4
		    {
			$<num>$ = in_def;
		        in_def = 0;
		    }
d1295 2
a1296 2
		        in_single = $<num>5;
		        in_def = $<num>6;
@


1.87
log
@* io.c (rb_io_ctl): do not call ioctl/fcntl for f2, if f and f2
  have same fileno.

* eval.c (rb_load): raise LocaJumpError if unexpected local jumps
  appear during load.

* ext/socket/socket.c (bsock_close_read): don't call rb_thread_fd_close();
  it's supposed to be called by io_io_close().

* ext/socket/socket.c (bsock_close_read): do not modify f and f2.

* ext/socket/socket.c (bsock_close_write): ditto.

* ext/socket/socket.c (sock_new): avoid dup(2) on sockets.

* parse.y (primary): preserve and clear in_single and in_def using
  stack to prevent nested method errors in singleton class bodies.
@
text
@d6 1
a6 1
  $Date: 2001/02/08 09:19:17 $
d4472 22
d4519 2
a4520 2
	node->nd_beg = cond0(node->nd_beg, logop);
	node->nd_end = cond0(node->nd_end, logop);
d4534 1
a4534 2
	switch (TYPE(node->nd_lit)) {
	  case T_REGEXP:
a4539 7
	    break;

	  case T_FIXNUM:
	    if (logop) break;
	    if (!e_option_supplied()) break;
	    warn_unless_e_option("integer literal in condition");
	    return call_op(node,tEQ,1,NEW_GVAR(rb_intern("$.")));
@


1.86
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_options): new method to give an option values.

* parse.y (cond0): disable special treating of integer literal in
  conditional unless option -e is supplied.  changes current
  behavior.  experimental.

* parse.y (cond0): give warning for string/integer literals and
  dot operators in conditionals unless option -e is supplied.

* re.c (rb_reg_equal): all option flags should be same to be equal.

* error.c (Init_Exception): make Interrupt a subclass of
  SignalException.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:38:10 $
d90 1
d318 1
a318 1
			if (cur_mid || in_single)
d324 1
a324 1
			if (cur_mid || in_single)
d332 1
a332 1
			if (cur_mid || in_single)
d344 1
a344 1
			if (cur_mid || in_single)
d396 1
a396 1
			if (cur_mid || in_single) {
d410 1
a410 1
			if (compile_for_eval && (cur_mid || in_single)) {
d441 1
a441 1
			if (!compile_for_eval && !cur_mid && !in_single)
d499 1
a499 1
			if (!compile_for_eval && !cur_mid && !in_single)
d1152 1
a1152 1
			if (!compile_for_eval && !cur_mid && !in_single)
d1159 1
a1159 1
			if (!compile_for_eval && !cur_mid && !in_single)
d1165 1
a1165 1
			if (!compile_for_eval && !cur_mid && !in_single)
d1258 1
a1258 1
			if (cur_mid || in_single)
a1259 1

d1276 2
d1282 4
d1289 1
a1289 1
		        $$ = NEW_SCLASS($3, $6);
d1294 2
d1299 1
a1299 1
			if (cur_mid || in_single)
d1317 1
a1317 1
			if (cur_mid || in_single)
d1319 1
d1321 1
d1343 2
a1344 1
			cur_mid = 0;
d1477 1
a1477 1
			if (!compile_for_eval && !cur_mid &&
d1484 1
a1484 1
			if (!compile_for_eval && !cur_mid &&
d1987 1
d4135 1
a4135 1
	if (cur_mid || in_single)
@


1.85
log
@* array.c (rb_ary_sort_bang): returns self, even if its length is
  less than 2.

* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2001/01/29 05:10:42 $
d2548 5
a2552 4
	      case '\'':
		if (term == '\'') {
		    c = '\'';
		    break;
a2553 2
		/* fall through */
	      default:
d2608 1
a2608 1
		if (c == term) {
d4438 8
d4450 8
a4457 2
    if (strcmp(ruby_sourcefile, "-e") != 0)
	rb_warning(str);
d4472 3
a4474 1
	/* fall through */
d4477 2
a4480 1
	warn_unless_e_option("string/regex literal in condition");
d4496 1
d4502 1
a4506 1
	    warn_unless_e_option("string/regex literal in condition");
d4511 1
@


1.84
log
@* string.c (str_independent): should not clear str->orig here.
  it's too early.
@
text
@d6 1
a6 1
  $Date: 2001/01/26 05:02:17 $
d3395 1
a3395 2
	if (lex_state != EXPR_END &&
	    lex_state != EXPR_ARG)
d4696 1
a4696 1
	    if (i == 0 || (ruby_scope->flag & SCOPE_MALLOC) == 0) {
d4708 1
a4708 1
		ruby_scope->flag |= SCOPE_MALLOC;
@


1.83
log
@* parse.y: clarify do ambiguity, bit more complex but natural
  from my point of view.
@
text
@d6 1
a6 1
  $Date: 2001/01/23 08:08:59 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
d59 8
d68 1
a68 1
static unsigned long cond_stack = 0;
d79 1
a79 2
static int cmdarg_nest = 0;
static unsigned long cmdarg_stack = 0;
a80 1
    cmdarg_nest++;\
a83 1
    cmdarg_nest--;\
d86 1
a86 1
#define CMDARG_P() (cmdarg_nest > 0 && (cmdarg_stack&1))
@


1.82
log
@* gc.c (os_live_obj): do not list terminated object.

* gc.c (os_obj_of): ditto.

* gc.c (rb_gc_mark): support new T_BLKTAG tag.

* gc.c (obj_free): ditto.

* eval.c (new_blktag): creation of new block tag, which holds
  destination of global jump and orphan status.

* eval.c (block_pass): break from orphan Proc object will raise a
  LocalJumpError exception.

* eval.c (block_pass): behavior consistency with proc_call(). do
  not propagate `break'.
@
text
@d6 1
a6 1
  $Date: 2001/01/20 14:02:28 $
d71 12
d169 2
a170 1
	kDO2
d202 2
a203 2
%type <node> aref_args opt_block_arg block_arg var_ref
%type <node> mrhs mrhs_basic superclass generic_call block_call call_block
d460 1
a460 1
		| block_call
d462 2
a463 2
block_call	: call_block
		| call_block '.' operation2 call_args
d468 1
a468 1
		| call_block tCOLON2 operation2 call_args
d474 1
a474 1
command		:  operation call_args
d479 1
a479 1
		| primary '.' operation2 call_args
d485 1
a485 1
		| primary tCOLON2 operation2 call_args
d491 1
a491 1
		| kSUPER call_args
a503 1

d1011 6
d1368 1
a1368 1
		| kDO2
d1404 1
a1404 1
do_block	: kDO
d1417 1
a1417 29
brace_block	: '{'
		    {
		        $<vars>$ = dyna_push();
		    }
		  opt_block_var
		  compstmt '}'
		    {
			$$ = NEW_ITER($3, 0, $4);
		        fixpos($$, $4);
			dyna_pop($<vars>2);
		    }

generic_call	: tIDENTIFIER
		    {
			$$ = NEW_VCALL($1);
		    }
		| tCONSTANT
		    {
			$$ = NEW_VCALL($1);
		    }
		| tFID
		    {
			$$ = NEW_VCALL($1);
		    }
		| method_call
		| command_call


call_block	: generic_call do_block
d1426 1
a1426 1
		| call_block '.' operation2 opt_paren_args
d1431 1
a1431 1
		| call_block tCOLON2 operation2 opt_paren_args
d1474 23
d3615 4
a3618 2
		    if (kw->id[0] == kDO && COND_P()) {
			return kDO2;
@


1.81
log
@* parse.y (block_call): syntax restructure.
@
text
@d6 1
a6 1
  $Date: 2001/01/19 19:00:07 $
a51 1
    EXPR_PAREN,			/* almost like EXPR_END, `do' works as `{'. */
d188 1
a188 1
%type <node> opt_call_args call_args ret_args args when_args
d190 1
a190 1
%type <node> mrhs mrhs_basic superclass generic_call block_call blocklike_call
d447 1
a447 1
		| blocklike_call
d449 2
a450 2
blocklike_call	: block_call
		| block_call '.' operation2 call_args
d455 1
a455 1
		| block_call tCOLON2 operation2 call_args
d932 1
a932 3
opt_call_args	: none
		| call_args opt_nl
		| blocklike_call opt_nl
d934 9
a942 1
			$$ = NEW_LIST($1);
d944 1
a944 1
		| args ',' blocklike_call
d946 1
a946 1
			$$ = list_append($1, $3);
d949 3
d1427 1
a1427 1
block_call	: generic_call do_block
d1436 1
a1436 1
		| block_call '.' operation2 
d1439 1
a1439 1
			$$ = new_call($1, $3, 0);
d1441 1
a1441 1
		| block_call '.' operation2 '(' opt_call_args close_paren
d1444 1
a1444 11
			$$ = new_call($1, $3, $5);
		    }
		| block_call tCOLON2 operation2 
		    {
			value_expr($1);
			$$ = new_call($1, $3, 0);
		    }
		| block_call tCOLON2 operation2 '(' opt_call_args close_paren
		    {
			value_expr($1);
			$$ = new_call($1, $3, $5);
d1447 1
a1447 1
method_call	: operation '(' opt_call_args close_paren
d1449 2
a1450 2
			$$ = new_fcall($1, $3);
		        fixpos($$, $3);
d1452 1
a1452 1
		| primary '.' operation2 '(' opt_call_args close_paren
d1455 1
a1455 1
			$$ = new_call($1, $3, $5);
d1458 1
a1458 1
		| primary '.' operation2
d1461 1
a1461 7
			$$ = new_call($1, $3, 0);
		        fixpos($$, $1);
		    }
		| primary tCOLON2 operation2 '(' opt_call_args close_paren
		    {
			value_expr($1);
			$$ = new_call($1, $3, $5);
d1469 1
a1469 1
		| kSUPER '(' opt_call_args close_paren
d1474 1
a1474 1
			$$ = new_super($3);
a1483 5
close_paren	: ')'
		    {
			if (!COND_P()) lex_state = EXPR_PAREN;
		    }

a1837 2
#define enc ruby_default_encoding

d2907 1
a2907 2
	    lex_state != EXPR_END && lex_state != EXPR_PAREN && 
	    lex_state != EXPR_CLASS &&
d2966 1
a2966 1
	if (lex_state == EXPR_END || lex_state == EXPR_PAREN) {
d3293 1
a3293 1
	if (lex_state == EXPR_END || lex_state == EXPR_PAREN || ISSPACE(c)) {
a3377 1
	    lex_state != EXPR_PAREN &&
@


1.80
log
@* parse.y (yylex): fixed serious syntax misbehavior.  do's
  preceding was too high.  a block in `foo bar do .. end' should
  be passed to `foo', not `bar'.
@
text
@d6 1
a6 1
  $Date: 2001/01/10 10:07:31 $
d187 1
a187 1
%type <node> compstmt stmts stmt expr arg primary command_call method_call
d190 2
a191 2
%type <node> aref_args opt_block_arg block_arg stmt_rhs
%type <node> mrhs mrhs_basic superclass generic_call block_call var_ref
d298 1
a298 2
stmt		: block_call
		| kALIAS fitem {lex_state = EXPR_FNAME;} fitem
d398 1
a398 1
		| lhs '=' stmt_rhs
d403 1
a403 1
		| mlhs '=' stmt_rhs
d447 16
a462 1
command_call	: operation call_args
a913 8
		| block_call opt_nl
		    {
			$$ = NEW_LIST($1);
		    }
		| args ',' block_call opt_nl
		    {
			$$ = list_append($1, $3);
		    }
d935 1
a935 1
		| block_call opt_nl
d939 1
a939 1
		| args ',' block_call
d944 1
a944 1
call_args	: command_call
d947 2
a948 6
		    } /*
		| args ','
		    {
			$$ = $1;
		    } */
		| args ',' command_call
d961 1
a961 5
		    } /*
		| assocs ','
		    {
			$$ = NEW_LIST(NEW_HASH($1));
		    } */
d977 1
a977 5
		    } /*
		| args ',' assocs ','
		    {
			$$ = list_append($1, NEW_HASH($3));
		    } */
d1342 1
a1342 1
		| kDO
a1401 13
		| kDO2
		    {
		        $<vars>$ = dyna_push();
		    }
		  opt_block_var
		  compstmt
		  kEND
		    {
			$$ = NEW_ITER($3, 0, $4);
		        fixpos($$, $4);
			dyna_pop($<vars>2);
		    }

d1418 1
d1428 20
a1496 3
stmt_rhs	: block_call
		| command_call

d3619 1
a3619 1
		    if (kw->id[0] == kDO && !COND_P() && state == EXPR_PAREN) {
@


1.79
log
@inline fix
@
text
@d6 1
a6 1
  $Date: 2001/01/10 07:52:45 $
d70 1
a70 1
#define IN_COND (cond_nest > 0 && (cond_stack&1))
d1492 1
a1492 1
			if (!IN_COND) lex_state = EXPR_PAREN;
d3620 1
a3620 3
		    if (kw->id[0] == kDO &&
			(state == EXPR_PAREN ||
			 (!IN_COND && state == EXPR_ARG))) {
@


1.78
log
@* enum.c (enum_inject): new method.

* gc.c (rb_gc_call_finalizer_at_exit): clear klass member of
  terminating object.

* eval.c (rb_call): raise exception for terminated object.

* bignum.c (bigdivrem): t2 might be too big for signed long; do
  not use rb_int2big(), but rb_uint2big().

* error.c (rb_load_fail): new func to report LoadError.

* ruby.c (load_file): use rb_load_fail.

* eval.c (ruby_finalize): should enclosed by PUSH_TAG/POP_TAG.

* gc.c (rb_gc_mark): link 2 of NODE_IFUNC should not be explicitly
  marked.  it may contain non object pointer.

* re.c (reg_s_last_match): Regexp::last_match(nth) returns nth
  substring of the match  (alternative for $& and $<digit>).

* eval.c (rb_mod_define_method): wrong comparison for blocks.

* gc.c (id2ref): should handle Symbol too.

* gc.c (id2ref): should print original ptr value

* eval.c (rb_iterate): NODE_CFUNC does not protect its data
  (nd_tval), so create new node NODE_IFUNC for iteration C
  function.

* eval.c (rb_yield_0): use NODE_IFUNC.

* gc.c (rb_gc_mark): support NODE_IFUNC.

* gc.c (mem_error): prohibit recursive mem_error().
  (ruby-bugs-ja:PR#36)

* eval.c (rb_thread_fd_writable): should not switch context if
  rb_thread_critical is set.

* eval.c (rb_thread_wait_fd): ditto.

* eval.c (rb_thread_wait_for): ditto.

* eval.c (rb_thread_select): ditto.

* eval.c (rb_thread_join): join during critical section causes
  deadlock.
@
text
@d6 1
a6 1
  $Date: 2000/12/28 05:00:39 $
d1852 2
d2050 1
a2050 1
static INLINE int
@


1.77
log
@changes from personal modifies -- matz
@
text
@d6 1
a6 1
  $Date: 2000/12/27 05:59:03 $
d941 5
a945 1
		    }
d959 1
a959 1
		    }
d963 1
a963 1
		    }
d979 1
a979 1
		    }
d983 1
a983 1
		    }
a1848 2
#include <ctype.h>
#include <sys/types.h>
@


1.77.2.1
log
@m17n baseline
@
text
@d6 1
a6 1
  $Date: 2000/12/28 05:00:39 $
d317 1
a317 1
			sprintf(buf, "$%c", (int)$3->nd_nth);
d1861 1
a1861 1
#define is_identchar(c) (SIGN_EXTEND_CHAR(c)!=-1&&(m17n_isalnum(enc,(c)) || (c) == '_' || ismbchar(c)))
d2577 1
a2577 1
    while (c = nextc(),m17n_isspace(enc, c))
d2607 1
a2607 1
		if (!m17n_isspace(enc, c))
d2612 1
a2612 1
	else if (m17n_isspace(enc, c)) {
d2620 1
a2620 1
	    while (c = nextc(),m17n_isspace(enc, c))
d2853 1
a2853 1
	if (lex_state == EXPR_ARG && space_seen && !m17n_isspace(enc, c)){
d2880 1
a2880 1
	    if (strncmp(lex_p, "begin", 5) == 0 && m17n_isspace(enc, lex_p[5])) {
d2890 1
a2890 1
			(lex_p + 3 == lex_pend || m17n_isspace(enc, lex_p[3]))) {
d2928 1
a2928 1
	    if (!m17n_isspace(enc, c2) && (strchr("\"'`", c2) || is_identchar(c2))) {
d2988 1
a2988 1
	if (lex_state == EXPR_ARG && m17n_isspace(enc, c)){
d3017 1
a3017 1
	if (lex_state == EXPR_ARG && space_seen && !m17n_isspace(enc, c)){
d3062 1
a3062 1
	    (lex_state == EXPR_ARG && space_seen && !m17n_isspace(enc, c))) {
d3066 1
a3066 1
	    if (m17n_isdigit(enc, c)) {
d3091 1
a3091 1
	    (lex_state == EXPR_ARG && space_seen && !m17n_isspace(enc, c))) {
d3095 1
a3095 1
	    if (m17n_isdigit(enc, c)) {
d3115 1
a3115 1
	if (!m17n_isdigit(enc, c)) {
d3145 1
a3145 1
			if (!m17n_isxdigit(enc, c)) break;
d3223 1
a3223 1
			if (!m17n_isdigit(enc, c0)) {
d3306 1
a3306 1
	if (lex_state == EXPR_END || lex_state == EXPR_PAREN || m17n_isspace(enc, c)) {
d3324 1
a3324 1
	    if (!m17n_isspace(enc, c)) {
d3413 1
a3413 1
	    if (!m17n_isalnum(enc, c)) {
d3456 1
a3456 1
	if (lex_state == EXPR_ARG && space_seen && !m17n_isspace(enc, c)) {
d3523 1
a3523 1
	    while (m17n_isdigit(enc, c)) {
d3552 1
a3552 1
	if (m17n_isdigit(enc, c)) {
d3562 1
a3562 1
	if (!is_identchar(c) || m17n_isdigit(enc, c)) {
d3643 1
a3643 1
		if (result == 0 && m17n_isupper(enc, tok()[0])) {
d3706 1
a3706 1
	    while (m17n_isdigit(enc, c)) {
d4863 1
a4863 1
	if (name[0] != '_' && !m17n_isalpha(enc, name[0]) && !ismbchar(name[0])) {
d4890 1
a4890 1
	else if (m17n_isupper(enc, name[0])) {
@


1.77.2.2
log
@m17n fix
@
text
@d6 1
a6 1
  $Date: 2001/01/10 07:52:45 $
d1845 2
a1849 2
#define enc ruby_default_encoding

d1861 1
a1861 1
#define is_identchar(c) (SIGN_EXTEND_CHAR(c)!=-1&&(ISALNUM(c) || (c) == '_' || ismbchar(c)))
d2577 1
a2577 1
    while (c = nextc(),ISSPACE(c))
d2607 1
a2607 1
		if (!ISSPACE(c))
a4837 3

    m17n_init();
    ruby_default_encoding = m17n_find_encoding("euc-jp");
@


1.76
log
@matz
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2000/12/26 08:08:50 $
a4389 2
static NODE *cond2();

d4436 8
d4445 1
a4445 1
cond0(node, log)
d4447 1
a4447 1
    int log;
d4454 1
a4454 1
	if (log) break;
d4461 1
a4461 1
	rb_warn("string/regex literal in condition");
d4466 2
a4467 2
	node->nd_beg = cond0(node->nd_beg, log);
	node->nd_end = cond0(node->nd_end, log);
d4471 2
a4472 2
	rb_warn("range literal in condition");
	return node;
d4475 1
a4475 1
	if (log) break;
d4480 2
a4481 1
	if (TYPE(node->nd_lit) == T_REGEXP) {
d4486 7
a4492 2
	    rb_warn("string/regex literal in condition");
	    return node;
d4499 1
a4499 1
cond1(node, log)
d4501 1
a4501 1
    int log;
d4505 1
a4505 1
	node->nd_next = cond0(node->nd_next, log);
d4508 1
a4508 1
    return cond0(node, log);
@


1.75
log
@matz
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/12/25 06:29:05 $
d4439 1
a4439 1
cond0(node)
d4441 1
d4447 4
d4455 1
d4460 2
a4461 2
	node->nd_beg = cond2(node->nd_beg);
	node->nd_end = cond2(node->nd_end);
d4465 1
d4468 5
d4475 2
d4479 2
a4480 1
	    return NEW_MATCH(node);
a4481 7
	if (TYPE(node->nd_lit) == T_STRING) {
	    local_cnt('_');
	    local_cnt('~');
	    return NEW_MATCH(rb_reg_new(RSTRING(node)->ptr,RSTRING(node)->len,0));
	}
      default:
	return node;
d4483 1
d4487 1
a4487 1
cond(node)
d4489 1
d4493 1
a4493 1
	node->nd_next = cond0(node->nd_next);
d4496 1
a4496 1
    return cond0(node);
d4500 1
a4500 1
cond2(node)
d4503 1
a4503 9
    enum node_type type;

    node = cond(node);
    type = nd_type(node);
    if (type == NODE_NEWLINE) node = node->nd_next;
    if (type == NODE_LIT && FIXNUM_P(node->nd_lit)) {
	return call_op(node,tEQ,1,NEW_GVAR(rb_intern("$.")));
    }
    return node;
d4512 1
a4512 1
    return rb_node_newnode(type, cond(left), cond(right), 0);
@


1.74
log
@001225
@
text
@d6 1
a6 1
  $Date: 2000/12/22 03:22:02 $
d2046 1
a2046 4
#if defined(__GNUC__) && __GNUC__ >= 2
__inline__
#endif
static int
d2794 1
a2794 1
#ifndef strtod
@


1.74.2.1
log
@* gc.c (rb_gc_call_finalizer_at_exit): should finalize objects in
  deferred_final_list too.
@
text
@d6 1
a6 1
  $Date: 2000/12/25 06:29:05 $
d52 1
d70 1
a70 1
#define COND_P() (cond_nest > 0 && (cond_stack&1))
d187 1
a187 1
%type <node> compstmt stmts stmt expr arg primary command command_call method_call
d189 3
a191 3
%type <node> args ret_args when_args call_args paren_args opt_paren_args
%type <node> aref_args opt_block_arg block_arg var_ref
%type <node> mrhs mrhs_basic superclass generic_call block_call call_block
d298 2
a299 1
stmt		: kALIAS fitem {lex_state = EXPR_FNAME;} fitem
d399 1
a399 1
		| lhs '=' command_call
d404 1
a404 1
		| mlhs '=' command_call
d448 1
a448 16
command_call	: command
		| block_call

block_call	: call_block
		| call_block '.' operation2 call_args
		    {
			value_expr($1);
			$$ = new_call($1, $3, $4);
		    }
		| call_block tCOLON2 operation2 call_args
		    {
			value_expr($1);
			$$ = new_call($1, $3, $4);
		    }

command		:  operation call_args
d900 8
d927 3
a929 1
paren_args	: '(' none ')'
d931 1
a931 1
			$$ = $2;
d933 1
a933 1
		| '(' call_args opt_nl ')'
d935 1
a935 9
			$$ = $2;
		    }
		| '(' block_call opt_nl ')'
		    {
			$$ = NEW_LIST($2);
		    }
		| '(' args ',' block_call opt_nl ')'
		    {
			$$ = list_append($2, $4);
d938 1
a938 4
opt_paren_args	: none
		| paren_args

call_args	: command
d942 1
a942 1
		| args ',' command
d956 4
d976 4
d1344 1
a1344 1
		| kDO2
d1404 13
d1433 1
a1433 2

call_block	: generic_call do_block
d1442 2
a1443 1
		| call_block '.' operation2 opt_paren_args
d1445 2
a1446 2
			value_expr($1);
			$$ = new_call($1, $3, $4);
d1448 1
a1448 1
		| call_block tCOLON2 operation2 opt_paren_args
d1451 2
a1452 7
			$$ = new_call($1, $3, $4);
		    }

method_call	: operation paren_args
		    {
			$$ = new_fcall($1, $2);
		        fixpos($$, $2);
d1454 1
a1454 1
		| primary '.' operation2 opt_paren_args
d1457 1
a1457 1
			$$ = new_call($1, $3, $4);
d1460 1
a1460 1
		| primary tCOLON2 operation2 paren_args
d1463 1
a1463 1
			$$ = new_call($1, $3, $4);
d1471 1
a1471 1
		| kSUPER paren_args
d1476 1
a1476 1
			$$ = new_super($2);
d1486 8
d2797 1
a2797 1
#if !defined(strtod) && !defined(HAVE_STDLIB_H)
d2922 2
a2923 1
	    lex_state != EXPR_END && lex_state != EXPR_CLASS &&
d2982 1
a2982 1
	if (lex_state == EXPR_END) {
d3309 1
a3309 1
	if (lex_state == EXPR_END || ISSPACE(c)) {
d3394 1
d3619 3
a3621 1
		    if (kw->id[0] == kDO && COND_P()) {
@


1.74.2.2
log
@* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2001/01/23 09:54:35 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
a58 8
#if SIZEOF_LONG_LONG > 0
typedef unsigned long long stack_type;
#elif SIZEOF___INT64 > 0
typedef unsigned __int64 stack_type;
#else
typedef unsigned long stack_type;
#endif

d60 1
a60 1
static stack_type cond_stack = 0;
a70 9
static stack_type cmdarg_stack = 0;
#define CMDARG_PUSH do {\
    cmdarg_stack = (cmdarg_stack<<1)|1;\
} while(0)
#define CMDARG_POP do {\
    cmdarg_stack >>= 1;\
} while (0)
#define CMDARG_P() (cmdarg_stack && (cmdarg_stack&1))

d157 1
a157 2
	kDO_COND
	kDO_BLOCK
d189 2
a190 2
%type <node> command_args aref_args opt_block_arg block_arg var_ref
%type <node> mrhs mrhs_basic superclass block_call block_command
d447 1
a447 1
		| block_command
d449 2
a450 2
block_command	: block_call
		| block_call '.' operation2 command_args
d455 1
a455 1
		| block_call tCOLON2 operation2 command_args
d461 1
a461 1
command		:  operation command_args
d466 1
a466 1
		| primary '.' operation2 command_args
d472 1
a472 1
		| primary tCOLON2 operation2 command_args
d478 1
a478 1
		| kSUPER command_args
d491 1
a998 6
command_args	: {CMDARG_PUSH;} call_args
		    {
		        CMDARG_POP;
			$$ = $2;
		    }

d1350 1
a1350 1
		| kDO_COND
d1386 1
a1386 1
do_block	: kDO_BLOCK
d1399 29
a1427 1
block_call	: command do_block
d1436 1
a1436 1
		| block_call '.' operation2 opt_paren_args
d1441 1
a1441 1
		| block_call tCOLON2 operation2 opt_paren_args
a1483 23
brace_block	: '{'
		    {
		        $<vars>$ = dyna_push();
		    }
		  opt_block_var
		  compstmt '}'
		    {
			$$ = NEW_ITER($3, 0, $4);
		        fixpos($$, $4);
			dyna_pop($<vars>2);
		    }
		| kDO
		    {
		        $<vars>$ = dyna_push();
		    }
		  opt_block_var
		  compstmt kEND
		    {
			$$ = NEW_ITER($3, 0, $4);
		        fixpos($$, $4);
			dyna_pop($<vars>2);
		    }

d2036 4
a2039 1
static inline int
d3607 2
a3608 4
		    if (kw->id[0] == kDO) {
			if (COND_P()) return kDO_COND;
			if (CMDARG_P()) return kDO_BLOCK;
			return kDO;
a4363 3

static NODE *cond2 _((NODE*));

d4379 2
a4424 8
}

static void
warn_unless_e_option(str)
    const char *str;
{
    if (strcmp(ruby_sourcefile, "-e") != 0)
	rb_warning(str);
@


1.74.2.3
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_equal): all option flags should be same to be equal.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:39:51 $
d2550 6
a2556 5
		/* fall through */
		if (c == term || (paren && c == paren)) {
		    tokadd(c);
		    continue;
		}
d2611 1
a2611 1
		if (c == term || (paren && c == paren)) {
@


1.74.2.4
log
@* parse.y (primary): preserve and clear in_single and in_def using
  stack to prevent nested method errors in singleton class bodies.
@
text
@d6 1
a6 1
  $Date: 2001/02/08 09:17:57 $
a89 1
static int in_def = 0;
d317 1
a317 1
			if (in_def || in_single)
d323 1
a323 1
			if (in_def || in_single)
d331 1
a331 1
			if (in_def || in_single)
d343 1
a343 1
			if (in_def || in_single)
d395 1
a395 1
			if (in_def || in_single) {
d409 1
a409 1
			if (compile_for_eval && (in_def || in_single)) {
d440 1
a440 1
			if (!compile_for_eval && !in_def && !in_single)
d498 1
a498 1
			if (!compile_for_eval && !in_def && !in_single)
d1151 1
a1151 1
			if (!compile_for_eval && !in_def && !in_single)
d1158 1
a1158 1
			if (!compile_for_eval && !in_def && !in_single)
d1164 1
a1164 1
			if (!compile_for_eval && !in_def && !in_single)
d1257 1
a1257 1
			if (in_def || in_single)
d1259 1
a1275 2
		        $<num>$ = in_single;
		        in_single = 0;
a1279 4
		    {
			$<num>$ = in_def;
		        in_def = 0;
		    }
d1283 1
a1283 1
		        $$ = NEW_SCLASS($3, $7);
a1287 2
		        in_single = $<num>5;
		        in_def = $<num>6;
d1291 1
a1291 1
			if (in_def || in_single)
d1309 1
a1309 1
			if (in_def || in_single)
a1310 1
			$<id>$ = cur_mid;
a1311 1
			in_def++;
d1333 1
a1333 2
			in_def--;
			cur_mid = $<id>3;
d1466 1
a1466 1
			if (!compile_for_eval && !in_def &&
d1473 1
a1473 1
			if (!compile_for_eval && !in_def &&
a1977 1
    in_def = 0;
d3396 2
a3397 1
	if (lex_state != EXPR_END && lex_state != EXPR_ARG)
d4126 1
a4126 1
	if (in_def || in_single)
@


1.74.2.5
log
@commit miss; sorry
@
text
@d6 1
a6 1
  $Date: 2001/02/13 05:10:43 $
d4453 8
@


1.74.2.6
log
@* eval.c (proc_call): should not modify ruby_block->frame.iter
  based on ruby_frame->iter altered by PUSH_ITER().

* eval.c (rb_thread_fd_close): should save current context before
  raising exception.
@
text
@d6 1
a6 1
  $Date: 2001/02/19 07:41:24 $
d1274 1
a1274 6
		| kCLASS tLSHFT expr
		    {
			$<num>$ = in_def;
		        in_def = 0;
		    }
		  term
d1282 4
d1294 2
a1295 2
		        in_def = $<num>4;
		        in_single = $<num>6;
@


1.74.2.7
log
@* parse.y (primary): rescue and ensure clauses should be allowed
  to appear in singleton method body.
@
text
@d6 1
a6 1
  $Date: 2001/02/26 04:07:48 $
a1355 3
		  rescue
		  opt_else
		  ensure
a1357 7
		        if ($9) $8 = NEW_RESCUE($8, $9, $10);
			else if ($10) {
			    rb_warn("else without rescue is useless");
			    $8 = block_append($8, $10);
			}
			if ($11) $8 = NEW_ENSURE($8, $11);

@


1.74.2.8
log
@* io.c (argf_seek): wrong calling sequence of rb_io_seek().

* parse.y (stmt): while/until modifier must work for empty body.

* ruby.c (ruby_set_argv): clear ARGV contents before adding args.
@
text
@d6 1
a6 1
  $Date: 2001/03/06 08:17:54 $
d363 7
a369 2
			if ($1 && nd_type($1) == NODE_BEGIN) {
			    $$ = NEW_WHILE(cond($3), $1->nd_body, 0);
d372 1
a372 1
			    $$ = NEW_WHILE(cond($3), $1, 1);
d378 7
a384 2
			if ($1 && nd_type($1) == NODE_BEGIN) {
			    $$ = NEW_UNTIL(cond($3), $1->nd_body, 0);
d387 1
a387 1
			    $$ = NEW_UNTIL(cond($3), $1, 1);
@


1.74.2.9
log
@* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE SUMMER TIME!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.
@
text
@d6 1
a6 1
  $Date: 2001/03/13 05:48:33 $
d135 4
d272 1
d291 1
d1251 1
d1261 1
d1274 1
d1283 1
d1293 1
d1303 1
d4751 6
d4840 1
@


1.74.2.10
log
@* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).
@
text
@d6 1
a6 1
  $Date: 2001/04/06 05:42:40 $
a1975 1
    cmdarg_stack = 0;
@


1.74.2.11
log
@* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.
@
text
@d6 1
a6 1
  $Date: 2001/04/16 06:54:36 $
d3627 1
a3627 7
		    if (state == EXPR_BEG)
			return kw->id[0];
		    else {
			if (kw->id[0] != kw->id[1])
			    lex_state = EXPR_BEG;
			return kw->id[1];
		    }
@


1.74.2.12
log
@* parse.y (arg): "||=" should not warn for uninitialized instance
  variables.

* eval.c (rb_eval): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/05/01 08:57:59 $
a674 3
			    if (is_instance_id($1)) {
				$$->nd_aid = $1;
			    }
@


1.74.2.13
log
@* eval.c (rb_eval_string_wrap): extend new ruby_top_self, not
  original self.

* eval.c (rb_eval_cmd): respect ruby_wrapper if set.

* eval.c (eval): do not update ruby_class unless scope is not
  provided.

* eval.c (eval): preserve wrapper information.

* eval.c (proc_invoke): ditto.

* eval.c (block_pass): ditto.

* parse.y (void_expr): too much warnings for void context
  (e.g. foo[1] that can be mere Proc call).
@
text
@d6 1
a6 1
  $Date: 2001/05/07 09:24:34 $
d4325 4
@


1.74.2.14
log
@* parse.y (parse_regx): handle backslash escaping of delimiter here.
@
text
@d6 1
a6 1
  $Date: 2001/07/02 08:43:27 $
d2244 1
a2244 2
tokadd_escape(term)
    int term;
d2305 1
a2305 1
	    return tokadd_escape(term);
d2317 1
a2317 2
	if (c != term)
	    tokadd('\\');
d2348 1
a2348 1
	    if (tokadd_escape(term) < 0)
@


1.74.2.15
log
@* io.c (rb_io_popen): accept integer flags as mode.

* file.c (rb_find_file_ext): extension table can be supplied from
  outside.  renamed.

* eval.c (rb_f_require): replace rb_find_file_noext by
  rb_find_file_ext.

* eval.c (rb_provided): should also check feature without
  extension.

* numeric.c (flo_to_s): do not rely on decimal point to be '.'

* parse.y (yylex): ternary ? can be followed by newline.
@
text
@d6 1
a6 1
  $Date: 2001/08/17 05:06:31 $
d2997 1
a2997 1
	if (c == -1) {
@


1.74.2.16
log
@Thu Sep 27 09:04:44 2001  Guy Decoux  <ts@@moulon.inra.fr>

	* parse.y: allow 'primary[] += arg'
@
text
@d6 1
a6 1
  $Date: 2001/09/03 05:29:18 $
d695 1
a695 1
			$3 = list_append($3, NEW_NIL());
@


1.74.2.17
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* string.c (rb_str_reverse): should return an instance of
  reciever's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d5 2
a6 2
  $Author: ts $
  $Date: 2001/09/27 07:10:54 $
d693 1
a693 1
                        NODE *tmp, *args = NEW_LIST($6);
@


1.74.2.18
log
@* parse.y (parse_quotedwords): %w(...) is not a string.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/02 04:25:52 $
d197 1
a197 1
%token <node> tDSTRING tDXSTRING tDREGEXP tNTH_REF tBACK_REF tQWORDS
a1078 1
		| tQWORDS
d2657 1
a2657 1
    return tQWORDS;
@


1.74.2.19
log
@* parse.y (yylex): disallow alpha-numeric and mbchar for
  terminator of %string.
@
text
@d6 1
a6 1
  $Date: 2001/10/10 08:23:47 $
a3430 4
		if (ISALNUM(term) || ismbchar(term)) {
		    yyerror("unknown type of %string");
		    return 0;
		}
@


1.74.2.20
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/10/15 15:15:45 $
a3741 6
	    tokadd(c);
	    goto fetch_id;

	  case '-':
	    tokadd(c);
	    c = nextc();
@


1.74.2.21
log
@* dir.c (my_getcwd): do not rely on MAXPATHLEN.

* eval.c (rb_yield_0): should not call rb_f_block_given_p().
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/29 05:04:41 $
d672 5
a676 7
			if ($<node>3) {
			    if ($2 == tOROP) {
				$<node>3->nd_value = $4;
				$$ = NEW_OP_ASGN_OR(gettable($1), $<node>3);
				if (is_instance_id($1)) {
				    $$->nd_aid = $1;
				}
d678 4
a681 11
			    else if ($2 == tANDOP) {
				$<node>3->nd_value = $4;
				$$ = NEW_OP_ASGN_AND(gettable($1), $<node>3);
			    }
			    else {
				$$ = $<node>3;
				if ($$) {
				    $$->nd_value = call_op(gettable($1),$2,1,$4);
				}
			    }
			    fixpos($$, $4);
d684 4
a687 1
			    $$ = 0;
d689 1
@


1.74.2.22
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.

* mkconfig.rb: use String#dump to generate Ruby string literal.

* range.c (range_eql): should override 'eql?'
@
text
@d6 1
a6 1
  $Date: 2001/11/07 09:01:31 $
a3236 1
		    if (seen_uc) goto trailing_uc;
@


1.74.2.23
log
@* parse.y: needless conditional.

* parse.y (parse_regx): parse error at unterminated regex /#{.
  (ruby-bugs-ja:PR#142)
@
text
@d6 1
a6 1
  $Date: 2001/11/13 08:22:27 $
d686 3
a688 1
				$$->nd_value = call_op(gettable($1),$2,1,$4);
d2352 1
a2352 1
	    if (list == (NODE*)-1) goto unterminated;
@


1.74.2.24
log
@* parse.y (str_extend): term can be any character.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/11/18 10:48:18 $
d3847 3
a3849 1
	      default:
d3859 1
@


1.74.2.25
log
@* parse.y (str_extend): should not terminate string interpolation
  with newlines in here-docs and newline terminated strings.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/11/19 14:36:40 $
a3856 1
	      case '\n':
@


1.74.2.26
log
@* parse.y (str_extend): should check nesting parentheses in #{}.

* eval.c (rb_thread_select): tv_sec and tv_usec should not be
  negative.

* signal.c (posix_signal): do not set SA_RESTART for SIGVTALRM.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 16:16:13 $
d1881 1
a1881 1
static NODE *str_extend _((NODE*,char,char));
d2349 1
a2349 1
	    list = str_extend(list, term, paren);
d2478 1
a2478 1
	    list = str_extend(list, term, paren);
d3692 1
a3692 1
str_extend(list, term, paren)
d3694 1
a3694 1
    char term, paren;
d3700 1
a3700 2
    int brace_nest = 0;
    int paren_nest = 0;
d3815 1
a3815 1
	brace_nest = 0;
d3821 1
a3821 1
		if (brace_nest > 0) {
d3829 2
a3830 2
		    if (brace_nest == 0) break;
		    brace_nest--;
d3846 1
a3846 1
		if (brace != -1) brace_nest++;
d3848 1
a3848 2
		if (c == paren) paren_nest++;
		else if (c == term && (!paren || paren_nest-- == 0)) {
@


1.74.2.27
log
@	* parse.y (str_extend): change types of second and third arguments
	  from char to int.
@
text
@d6 1
a6 1
  $Date: 2001/11/21 15:35:58 $
d1881 1
a1881 1
static NODE *str_extend _((NODE*,int,int));
d3694 1
a3694 1
    int term, paren;
@


1.74.2.28
log
@* parse.y (gettable): should freeze __LINE__ string.

* parse.y (str_extend): should not process immature #$x and
  #@@x interportation, e.g #@@#@@ etc.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/11/25 12:09:36 $
a3752 4
	    if (!is_identchar(c)) {
		pushback();
		goto invalid_interporate;
	    }
d3771 3
a3773 8
	      invalid_interporate:
		{
		    VALUE s = rb_str_new2("#");
		    rb_str_cat(s, tok(), toklen());
		    list_append(list, NEW_STR(s));
		    newtok();
		    return list;
		}
a3811 3
	if (toklen() == 1) {
	    goto invalid_interporate;
	}
d4082 1
a4082 3
	VALUE f = rb_str_new2(ruby_sourcefile);
	OBJ_FREEZE(f);
	return NEW_STR(f);
@


1.74.2.29
log
@* parse.y (gettable): should freeze __FILE__ string(__LINE__ is Fixnum).
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/12/10 07:22:50 $
d4091 3
a4096 3
    }
    else if (id == k__LINE__) {
	return NEW_LIT(INT2FIX(ruby_sourceline));
@


1.74.2.30
log
@* parse.y (str_extend): make up pushback call.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/12/10 10:06:20 $
a3774 1
	      pushback(c);
@


1.74.2.31
log
@* stable version 1.6.6 released.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/12/12 09:07:35 $
a3745 1
	  case ';':
@


1.74.2.32
log
@* parse.y (yycompile): always store copy of filename.

* parse.y (rb_compile_file): no longer need to strdup() here.
@
text
@d6 1
a6 1
  $Date: 2001/12/25 15:09:05 $
a1949 2
    f = strdup(f);

d2060 1
a2060 1
    return yycompile(f, start);
@


1.74.2.33
log
@forgot to commit everything bug ChangeLog
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/12/31 05:26:24 $
d1977 1
a1977 1
    ruby_sourcefile = strdup(f);
@


1.74.2.34
log
@* parse.y (yycompile): strdup()'ed twice.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/04 14:19:47 $
d1949 2
@


1.74.2.35
log
@* eval.c (block_pass): should not pass tainted block, if $SAFE > 0.

* variable.c (rb_mod_remove_cvar): should pass the char*.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/01/04 15:23:26 $
d4093 3
a4095 1
	return NEW_STR(rb_str_new2(ruby_sourcefile));
@


1.74.2.36
log
@* eval.c (ruby_stop): should not trace error handler.

* io.c (io_write): should not raise exception on O_NONBLOCK io.

* dir.c (dir_set_pos): seek should return dir, pos= should not.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/16 09:22:39 $
a3940 1
    if (orig == (NODE*)1) return;
@


1.74.2.37
log
@* parse.y (yylex): strict check for numbers.
@
text
@d6 1
a6 1
  $Date: 2002/01/21 07:43:40 $
d3143 1
a3143 1
	    int is_float, seen_point, seen_e, nondigit;
d3145 1
a3145 1
	    is_float = seen_point = seen_e = nondigit = 0;
a3152 1
		int start = toklen();
d3157 9
a3165 12
		    if (ISXDIGIT(c)) {
			do {
			    if (c == '_') {
				if (nondigit) break;
				nondigit = c;
				continue;
			    }
			    if (!ISXDIGIT(c)) break;
			    nondigit = 0;
			    tokadd(c);
			} while (c = nextc());
		    }
d3168 1
a3168 1
		    if (toklen() == start) {
d3171 1
a3171 1
		    else if (nondigit) goto trailing_uc;
d3178 9
a3186 12
		    if (c == '0' || c == '1') {
			do {
			    if (c == '_') {
				if (nondigit) break;
				nondigit = c;
				continue;
			    }
			    if (c != '0' && c != '1') break;
			    nondigit = 0;
			    tokadd(c);
			} while (c = nextc());
		    }
d3189 1
a3189 1
		    if (toklen() == start) {
d3192 1
a3192 1
		    else if (nondigit) goto trailing_uc;
d3200 1
a3200 2
			    if (nondigit) break;
			    nondigit = c;
d3204 1
a3204 1
			nondigit = 0;
d3207 5
a3211 7
		    if (toklen() > start) {
			pushback(c);
			tokfix();
			if (nondigit) goto trailing_uc;
			yylval.val = rb_cstr2inum(tok(), 8);
			return tINTEGER;
		    }
d3216 1
a3216 1
		else if (c == '.' || c == 'e' || c == 'E') {
d3230 1
a3230 1
		    nondigit = 0;
d3235 1
a3235 1
		    if (nondigit) goto trailing_uc;
d3251 1
a3251 1
		    nondigit = 0;
a3255 5
		    if (nondigit) {
			pushback(c);
			c = nondigit;
			goto decode_num;
		    }
d3262 6
a3267 5
		    nondigit = c;
		    c = nextc();
		    if (c != '-' && c != '+') continue;
		    tokadd(c);
		    nondigit = c;
d3271 1
a3271 2
		    if (nondigit) goto decode_num;
		    nondigit = c;
d3283 1
a3283 2
	    if (nondigit) {
		char tmp[30];
d3285 1
a3285 2
		sprintf(tmp, "trailing `%c' in number", nondigit);
		yyerror(tmp);
@


1.74.2.38
log
@* parse.y (yycompile): should inherit "in_single" if eval happened
  in a singleton method.

* eval.c (rb_eval): class variables from singleton methods defined
  within singleton class statement should work like ones defined
  by sington def statements.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/01/28 15:14:18 $
a1976 4
    if (ruby_frame && ruby_frame->last_class &&
	FL_TEST(ruby_frame->last_class, FL_SINGLETON)) {
	in_single = 1;
    }
@


1.74.2.39
log
@* eval.c (rb_eval): singleton chech should be moved from yycompile
  to here.

* eval.c (is_defined): check should be added here too.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/08 05:20:33 $
d1977 4
@


1.74.2.40
log
@* parse.y (assignable): should emit CVASGN within the method
  body.
@
text
@d6 1
a6 1
  $Date: 2002/02/09 14:47:52 $
d4132 1
d4190 1
a4190 1
	if (in_def || in_single) return NEW_CVASGN(id, val);
@


1.74.2.41
log
@* marshal.c (r_object): complete restoration before calling
  r_regist().

* parse.y (yylex): operators in the "op" rule should make
  lex_state EXPR_ARG on EXPR_FNAME and EXPR_DOT.
@
text
@d6 1
a6 1
  $Date: 2002/02/13 09:02:15 $
d2857 1
a2858 1
		lex_state = EXPR_BEG;
d2863 14
a2876 1
	    c = tPOW;
d2879 1
a2879 22
	    if (c == '=') {
		yylval.id = '*';
		lex_state = EXPR_BEG;
		return tOP_ASGN;
	    }
	    pushback(c);
	    if (lex_state == EXPR_ARG && space_seen && !ISSPACE(c)){
		rb_warning("`*' interpreted as argument prefix");
		c = tSTAR;
	    }
	    else if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
		c = tSTAR;
	    }
	    else {
		c = '*';
	    }
	}
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
d2881 1
d2917 1
a2917 6
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
d2950 1
a2950 6
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
a2959 1
		lex_state = EXPR_BEG;
d2970 1
a2970 6
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
a2975 1
		lex_state = EXPR_BEG;
d3044 1
a3044 6
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG;
	}
d3048 1
a3049 1
	    lex_state = EXPR_BEG;
d3057 1
a3057 2
	if (c == '=') {
	    lex_state = EXPR_BEG;
a3060 6
	if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
	    lex_state = EXPR_ARG;
	}
	else {
	    lex_state = EXPR_BEG;
	}
a3066 1
	    lex_state = EXPR_ARG;
a3095 1
	    lex_state = EXPR_ARG;
d3364 1
a3364 6
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
d3368 1
a3369 1
	    lex_state = EXPR_BEG;
a3372 6
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
d3387 1
a3387 6
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
a3404 1
	    lex_state = EXPR_ARG;
d3496 1
a3496 6
	switch (lex_state) {
	  case EXPR_FNAME: case EXPR_DOT:
	    lex_state = EXPR_ARG; break;
	  default:
	    lex_state = EXPR_BEG; break;
	}
@


1.74.2.42
log
@* hash.c (rb_any_cmp): should handle Qundef in keys.

* eval.c (remove_method): should not remove a empty method to
  implement "undef".

* eval.c (rb_eval): should allow singleton class def for
  true/false/nil.

* parse.y (str_extend): backslash escape was done wrong.

* class.c (rb_include_module): should preserve ancestor order in
  the included class/module.
@
text
@d6 1
a6 1
  $Date: 2002/02/19 06:43:34 $
d3936 1
a3936 1
		goto loop_again;
@


1.74.2.43
log
@* gc.c (rb_source_filename): added. holds unique strings for file
  names with GC space.

* gc.c (rb_gc_mark): mark source file name.

* gc.c (gc_sweep): ditto.

* gc.c (Init_GC): initialize source file name table.

* intern.h (rb_source_filename): added.

* eval.c (rb_eval_string): use rb_source_filename().

* parse.y (yycompile): ditto.

* ruby.c (proc_options): ditto.

* ruby.c (load_file): ditto.

* ruby.c (ruby_script): ditto.

* ruby.c (ruby_prog_init): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/02/20 04:28:51 $
d1975 1
a1975 1
    ruby_sourcefile = rb_source_filename(f);
@


1.74.2.44
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/07 11:19:28 $
a2847 1
	  case EXPR_CLASS:
@


1.74.2.45
log
@* class.c (rb_define_class): should handle autoload.

* class.c (rb_define_module): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/08 06:59:53 $
d383 1
a383 1
			local_push(1);
d1252 1
a1252 1
			local_push(1);
d1273 1
a1273 1
			local_push(1);
d1290 1
a1290 1
			local_push(1);
d1308 1
a1308 1
			local_push(1);
d1336 1
a1336 1
			local_push(1);
a4686 1
    struct RVarmap* dyna_vars;
d4691 1
a4691 1
local_push(int dyna_init)
a4700 1
    local->dyna_vars = ruby_dyna_vars;
a4701 2

    if (dyna_init) ruby_dyna_vars = (struct RVarmap* )0;
a4712 1
    ruby_dyna_vars = lvtbl->dyna_vars;
d4775 1
a4775 1
    local_push(0);
@


1.74.2.46
log
@* enum.c (enum_find): catch a value before recycle.

* enum.c (enum_min): ditto.

* enum.c (enum_max): ditto.

* parse.y (parse_string): part of multi-byte sequence must not
  match to paren.

* parse.y (parse_qstring): ditto.

* parse.y (parse_quotedwords): ditto.

* parse.y (str_extend): handle multi-byte characters.
@
text
@d6 1
a6 1
  $Date: 2002/03/15 08:55:58 $
a2468 4
	if (paren) {
	    if (c == paren) nest++;
	    if (c == term && nest-- == 0) break;
	}
d2496 4
a2542 4
	if (paren) {
	    if (c == paren) nest++;
	    if (c == term && nest-- == 0) break;
	}
d2570 4
a2603 4
	if (paren) {
	    if (c == paren) nest++;
	    if (c == term && nest-- == 0) break;
	}
d2643 4
a3949 8
		}
		else if (ismbchar(c)) {
		    int i, len = mbclen(c)-1;

		    for (i = 0; i < len; i++) {
			tokadd(c);
			c = nextc();
		    }
@


1.74.2.47
log
@* re.c (rb_reg_search): should clear last_match if pos is out of
  string range.

* string.c (rb_str_index_m): ditto.

* string.c (rb_str_rindex): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/18 02:00:05 $
d383 1
a383 1
			local_push(0);
d1252 1
a1252 1
			local_push(0);
d1273 1
a1273 1
			local_push(0);
d1290 1
a1290 1
			local_push(0);
d1308 1
a1308 1
			local_push(0);
d1336 1
a1336 1
			local_push(0);
d4700 1
a4700 2
local_push(top)
    int top;
d4712 2
a4713 5
    if (!top) {
	/* preserve reference for GC, but link should be cut. */
	rb_dvar_push(0, (VALUE)ruby_dyna_vars);
	ruby_dyna_vars->next = 0;
    }
d4788 1
a4788 1
    local_push(1);
@


1.74.2.48
log
@* parse.y: avoid binson 1.35 warnings. add ; at the end of a rule.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/19 09:02:03 $
a288 1
		;
a294 1
		;
a308 1
		;
a415 1
		;
a447 1
		;
a450 1
		;
a462 1
		;
a492 1
		;
a498 1
		;
a504 1
		;
a529 1
		;
a535 1
		;
a544 1
		;
a570 1
		;
a596 1
		;
a602 1
		;
a616 1
		;
a619 1
		;
a628 1
		;
a655 1
		;
a663 1
		;
a910 1
		;
a938 1
		;
a955 1
		;
a958 1
		;
a1005 1
		;
a1011 1
		;
a1017 1
		;
a1023 1
		;
a1034 1
		;
a1041 1
		;
a1057 1
		;
a1071 1
		;
a1373 1
		;
a1377 1
		;
a1380 1
		;
a1390 1
		;
a1396 1
		;
a1399 1
		;
a1413 1
		;
a1427 1
		;
a1447 1
		;
a1484 1
		;
a1507 1
		;
a1514 1
		;
a1526 1
		;
a1529 1
		;
a1532 1
		;
a1538 1
		;
a1551 1
		;
a1561 1
		;
a1568 1
		;
a1596 1
		;
a1602 1
		;
a1607 1
		;
a1610 1
		;
a1622 1
		;
a1627 1
		;
a1630 1
		;
a1644 1
		;
a1654 1
		;
a1691 1
		;
a1717 1
		;
a1723 1
		;
a1732 1
		;
a1742 1
		;
a1755 1
		;
a1764 1
		;
a1770 1
		;
a1797 1
		;
a1810 1
		;
a1816 1
		;
a1821 1
		;
a1825 1
		;
a1830 1
		;
a1834 1
		;
a1837 1
		;
a1840 1
		;
a1843 1
		;
a1847 1
		;
a1850 1
		;
a1853 1
		;
a1858 1
		;
@


1.74.2.49
log
@* file.c (rb_find_file): load must be done from an abolute path if
  $SAFE >= 4.

* re.c (rb_reg_s_quote): quote whitespaces for /x cases.

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* eval.c (rb_thread_cleanup): current thread may be THREAD_STOPPED,
  for example when terminated from signal handler.

* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.

* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* marshal.c (w_uclass): should check based on rb_obj_class(), not
  CLASS_OF().

* io.c (io_write): check error if written data is less than
  specified size to detect EPIPE.

* eval.c (assign): ruby_verbose should be surrounded by RTEST().

* object.c (rb_str2cstr): ditto.

* parse.y (void_expr): ditto.

* parse.y (void_stmts): ditto.

* variable.c (rb_ivar_get): ditto.

* variable.c (rb_cvar_set): ditto.

* variable.c (rb_cvar_get): ditto.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/04/04 06:47:39 $
d4496 1
a4496 1
    if (!RTEST(ruby_verbose)) return;
d4593 1
a4593 1
    if (!RTEST(ruby_verbose)) return;
@


1.74.2.50
log
@* parse.y (here_document): preserve line number begins here
  document.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/01 09:37:58 $
a2760 4
    int firstline;

    if (heredoc_end > 0) ruby_sourceline = heredoc_end;
    firstline = ruby_sourceline;
d2869 1
a2869 1
	nd_set_line(list, firstline+1);
@


1.74.2.51
log
@* parse.y (yylex): case '<': here-document label ate '-'.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/05/10 10:05:18 $
a3048 3
	    if (indent) {
		pushback('-');
	    }
@


1.74.2.52
log
@* parse.y (here_document): check if identifier is terminated.
  (ruby-bugs-ja:PR#239)

* parse.y (yylex): should pushback proper char after '**'.
  (ruby-bugs-ja:PR#240)
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/05/22 09:40:17 $
a2771 8
	    switch (c) {
	      case -1:
		rb_compile_error("unterminated here document identifier meets end of file");
		return 0;
	      case '\n':
		rb_compile_error("unterminated here document identifier meets end of line");
		return 0;
	    }
d2804 2
a2805 2
	    free(eos);
	    return 0;
d2945 1
a2945 1
	    if ((c = nextc()) == '=') {
@


1.74.2.53
log
@* numeric.c (fix_lshift): negative shift count means right shift.
  (ruby-bugs-ja:PR#248)

* numeric.c (fix_rshift): return -1 when left side operand is
  negative. (ruby-bugs-ja:PR#247)

* parse.y (yylex): `0_' should be an error. (ruby-bugs-ja:PR#239)
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/02 22:16:49 $
a3357 4
		    }
		    if (nondigit) {
			pushback(c);
			goto trailing_uc;
@


1.74.2.54
log
@* eval.c (rb_eval): ruby_frame->last_func may be null, if it's
  called outside of a method.

* parse.y (arg): use INT2NUM, not INT2FIX for tUMINUS.

* parse.y (arg): $1 may be null for tPOW.

* parse.y (stmt,arg): too much void value check.

* parse.y (arg): need to check void value on rules which does not
  use node_assign().

* ext/socket/socket.c (ipaddr): need not to taint hostnames.
@
text
@d6 1
a6 1
  $Date: 2002/06/10 10:15:00 $
d405 1
d688 1
a692 1
			value_expr($4);
a718 1
			value_expr($5);
a731 1
			value_expr($5);
a742 1
			value_expr($5);
a753 1
			value_expr($5);
d800 1
a800 1
			if ($1 && nd_type($1) == NODE_LIT) {
d833 1
a833 1
			    $2->nd_lit = INT2NUM(-i);
@


1.74.2.55
log
@* parse.y (stmt): fix typo.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/11 06:58:37 $
d718 1
a718 1
			value_expr($6);
@


1.74.2.56
log
@* parse.y (yylex): 'do' should return kDO_BLOCK on EXPR_ENDARG.

* parse.y (singleton): "def (()).a end" dumped core.

* parse.y (range_op): node may be null.

* parse.y (match_gen): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/12 06:06:17 $
a772 2
			value_expr($1);
			value_expr($3);
a776 2
			value_expr($1);
			value_expr($3);
d897 1
d1855 12
a1866 18
					if ($3 == 0) {
			    yyerror("can't define single method for ().");
			}
			else {
			    switch (nd_type($3)) {
			      case NODE_STR:
			      case NODE_DSTR:
			      case NODE_XSTR:
			      case NODE_DXSTR:
			      case NODE_DREGX:
			      case NODE_LIT:
			      case NODE_ARRAY:
			      case NODE_ZARRAY:
				yyerror("can't define single method for literals");
			      default:
				value_expr($3);
				break;
			    }
d4243 7
a4249 6
    value_expr(node1);
    value_expr(node2);
    if (node1) {
	switch (nd_type(node1)) {
	  case NODE_DREGX:
	  case NODE_DREGX_ONCE:
a4250 5

	  case NODE_LIT:
	    if (TYPE(node1->nd_lit) == T_REGEXP) {
		return NEW_MATCH2(node1, node2);
	    }
d4254 7
a4260 4
    if (node2) {
	switch (nd_type(node2)) {
	  case NODE_DREGX:
	  case NODE_DREGX_ONCE:
a4261 5

	  case NODE_LIT:
	    if (TYPE(node2->nd_lit) == T_REGEXP) {
		return NEW_MATCH3(node2, node1);
	    }
d4377 1
d4396 1
a4503 4
      case NODE_AND:
      case NODE_OR:
	return value_expr(node->nd_2nd);

a4678 1
    value_expr(node);
a4728 1
    if (!node) return node;
@


1.74.2.57
log
@* hash.c (rb_hash_s_create): use rb_hash_aset() instead of calling
  st_insert() directly, to dup&freeze string keys.

* parse.y (yylex): proper error message for "@@@@0".

* parse.y (yylex): paren to parse_string() must be zero for
  unparenthesized strings.

* parse.y (str_extend): broken string when unterminated "#{".
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/12 09:24:58 $
a447 1
			value_expr($2);
a900 1
			value_expr($2);
d2851 1
a2851 1
	switch (parse_string(term, '\n', 0)) {
d3121 1
a3121 1
	return parse_string(c,c,0);
d3125 1
a3125 1
	return parse_string(c,c,0);
d3765 1
a3765 6
	    if (tokidx == 1) {
		rb_compile_error("`@@%c' is not a valid instance variable name", c);
	    }
	    else {
		rb_compile_error("`@@@@%c' is not a valid class variable name", c);
	    }
d4058 1
a4058 1
		    list_append(list, NEW_STR(rb_str_new2("#{")));
d4696 1
@


1.74.2.58
log
@* parse.y (read_escape): deny zero-width hexadecimal character.
  (ruby-bugs-ja:PR#260)

* parse.y (tokadd_escape): ditto.

* regex.c (re_compile_pattern): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/06/13 03:54:39 $
a2294 4
	    if (numlen == 0) {
		yyerror("Invalid escape character syntax");
		return 0;
	    }
a2379 4
	    if (numlen == 0) {
		yyerror("Invalid escape character syntax");
		return -1;
	    }
@


1.74.2.59
log
@* string.c (rb_str_slice_bang): if there's no corresponding
  substring, slice! should return nil without exception.

* string.c (rb_str_split_m): accept separator value nil as well.

* class.c (include_class_new): module may be T_ICLASS; retrieve
  original module information.

* re.c (rb_reg_expr_str): need to process backslashes properly.

* parse.y (yylex): no here document after a dot.

* parse.y (yylex): should have set lex_state properly after '`'.

* parse.y (yylex): should have set lex_state properly after
  tOP_ASGN.

* bignum.c (rb_big2dbl): return canonical HUGE_VAL for infinity.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/14 06:26:59 $
d2976 1
a2977 1
		lex_state = EXPR_BEG;
d3067 1
a3067 1
	    lex_state != EXPR_END && lex_state != EXPR_CLASS && lex_state != EXPR_DOT &&
d3098 1
a3099 1
		lex_state = EXPR_BEG;
d3120 1
a3121 1
		lex_state = EXPR_BEG;
d3133 2
a3134 8
	if (lex_state == EXPR_FNAME) {
	    lex_state = EXPR_END;
	    return c;
	}
	if (lex_state == EXPR_DOT) {
	    lex_state = EXPR_ARG;
	    return c;
	}
d3147 6
a3154 27
	if (ISSPACE(c)){
	    if (lex_state != EXPR_ARG){
		int c = 0;
		switch (c) {
		  case ' ':
		    c = 's';
		    break;
		  case '\n':
		    c = 'n';
		    break;
		  case '\t':
		    c = 't';
		    break;
		  case '\v':
		    c = 'v';
		    break;
		}
		if (c) {
		    rb_warn("invalid character syntax; use ?\\%c", c);
		}
	    }
	    else {
		pushback(c);
		lex_state = EXPR_BEG;
		return '?';
	    }
	}
a3167 1
		lex_state = EXPR_BEG;
a3201 1
		lex_state = EXPR_BEG;
d3208 1
a3209 1
	    lex_state = EXPR_BEG;
d3232 1
a3233 1
	    lex_state = EXPR_BEG;
d3262 1
a3263 1
	    lex_state = EXPR_BEG;
d3516 1
a3517 1
	    lex_state = EXPR_BEG;
d3537 1
a3538 1
	    lex_state = EXPR_BEG;
a3670 1
	    lex_state = EXPR_BEG;
@


1.74.2.60
log
@* parse.y (yylex): should pushback proper char after '<<'.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/07/11 08:24:53 $
d3097 1
a3097 1
	    if ((c = nextc()) == '=') {
@


1.74.2.61
log
@* eval.c (rb_eval): fixed line number in string interpolation.

* parse.y (str_extend): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/07/11 12:31:37 $
a3938 1
    int start;
a3951 1
    start = ruby_sourceline;
a4127 1
    nd_set_line(node, start);
@


1.74.2.62
log
@* gc.c (gc_sweep): does reclaim nodes in also compile time, if we can.
* ruby.c (load_file): omit GC if we can.
* parse.y (ruby_parser_stack_on_heap): new function.
* intern.h (ruby_parser_stack_on_heap): added.
@
text
@d6 1
a6 1
  $Date: 2002/07/11 15:51:48 $
a5039 10
}

int
ruby_parser_stack_on_heap()
{
#if defined(YYBISON) && !defined(C_ALLOCA)
    return Qfalse;
#else
    return Qtrue;
#endif
@


1.74.2.63
log
@* gc.c (rb_gc): should mark parser.
* parse.y (rb_gc_mark_parser): new function.
* intern.h (rb_gc_mark_parser): added.
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/09/02 15:20:12 $
a5049 8
}

void
rb_gc_mark_parser()
{
    if (ruby_in_compile) {
        rb_gc_mark_maybe(yylval.val);
    }
@


1.74.2.64
log
@* parse.y (rb_gc_mark_parser): should mark all global variables in parse.y.
@
text
@d6 1
a6 1
  $Date: 2002/09/05 20:08:48 $
d5055 3
a5057 8
    if (!ruby_in_compile) return;

    rb_gc_mark_maybe(yylval.val);
    rb_gc_mark((VALUE)ruby_eval_tree_begin);
    rb_gc_mark((VALUE)ruby_eval_tree);
    rb_gc_mark(ruby_debug_lines);
    rb_gc_mark(lex_lastline);
    rb_gc_mark(lex_input);
d5143 1
@


1.74.2.65
log
@* parse.y (rb_gc_mark_parser): ruby_eval_tree is marked in eval.c.
@
text
@d6 1
a6 1
  $Date: 2002/09/06 02:58:55 $
d5058 2
@


1.74.2.66
log
@* eval.c (ruby_run): should set toplevel visibility again here.

* eval.c (rb_eval): should not rely on ruby_class == rb_cObject
  check.   Besides allow implicit publicity for attribute set
  methods.

* parse.y (primary): need not to check class_nest, just set
  whether method is an attrset or not.

* string.c (rb_str_each_line): p might be at the top of the
  string.

* variable.c (rb_path2class): should not use rb_eval_string().

* parse.y (str_extend): expression substitution can contain string
  terminator again.

* parse.y (yylex): the warning message "invalid
  character syntax" was never issued.

* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/09/06 23:41:43 $
d1365 2
a1366 1
			$$ = NEW_DEFN($2, $4, $5, NOEX_PRIVATE);
d3157 1
a3157 1
		int c2 = 0;
d3160 1
a3160 1
		    c2 = 's';
d3163 1
a3163 1
		    c2 = 'n';
d3166 1
a3166 1
		    c2 = 't';
d3169 1
a3169 1
		    c2 = 'v';
d3172 1
a3172 1
		if (c2) {
d4069 1
a4069 1
	brace_nest = 1;
d4075 1
a4075 1
		if (brace_nest > 1) {
d4083 1
a4084 1
		    if (brace_nest == 0) break;
a4101 16
		/* within brace */
		if (brace_nest > 0) {
		    if (ismbchar(c)) {
			int i, len = mbclen(c)-1;

			for (i = 0; i < len; i++) {
			    tokadd(c);
			    c = nextc();
			}
		    }
		    else {
			tokadd(c);
		    }
		    break;
		}
		/* out of brace */
d4112 8
a4119 1
		break;
@


1.74.2.67
log
@* parse.y (value_expr0): allow return/break/next/redo/retry in rhs
  of logical operator.  [ruby-dev:18534]

* parse.y (remove_begin): eliminate useless NODE_BEGIN.
  [ruby-dev:18535]
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/25 07:07:37 $
d100 2
a101 2
static int value_expr0();
static void void_expr0();
a102 3
static NODE *remove_begin();
#define value_expr(node) value_expr0((node) = remove_begin(node))
#define void_expr(node) void_expr0((node) = remove_begin(node))
d4540 1
a4540 1
value_expr0(node)
d4543 1
a4543 1
    int cond = 0;
d4545 21
a4565 22
    while (node) {
	switch (nd_type(node)) {
	  case NODE_RETURN:
	  case NODE_BREAK:
	  case NODE_NEXT:
	  case NODE_REDO:
	  case NODE_RETRY:
	  case NODE_WHILE:
	  case NODE_UNTIL:
	  case NODE_CLASS:
	  case NODE_MODULE:
	  case NODE_DEFN:
	  case NODE_DEFS:
	    if (!cond) yyerror("void value expression");
	    return Qfalse;

	  case NODE_BLOCK:
	    while (node->nd_next) {
		node = node->nd_next;
	    }
	    node = node->nd_head;
	    break;
d4567 2
a4568 3
	  case NODE_BEGIN:
	    node = node->nd_body;
	    break;
d4570 2
a4571 4
	  case NODE_IF:
	    if (!value_expr(node->nd_body)) return Qfalse;
	    node = node->nd_else;
	    break;
d4573 3
a4575 5
	  case NODE_AND:
	  case NODE_OR:
	    cond = 1;
	    node = node->nd_2nd;
	    break;
d4577 2
a4578 3
	  case NODE_NEWLINE:
	    node = node->nd_next;
	    break;
d4580 2
a4581 3
	  default:
	    return Qtrue;
	}
a4582 1
    return Qtrue;
d4586 1
a4586 1
void_expr0(node)
a4696 19
}

static NODE *
remove_begin(node)
    NODE *node;
{
    NODE **n = &node;
    while (*n) {
	switch (nd_type(*n)) {
	  case NODE_NEWLINE:
	    n = &(*n)->nd_next;
	    continue;
	  case NODE_BEGIN:
	    *n = (*n)->nd_body;
	  default:
	    return node;
	}
    }
    return node;
@


1.74.2.68
log
@* parse.y (str_extend): pushback() takes one argument, so properly
  pass c to it.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/10/18 14:40:56 $
d720 1
a720 1
                        NODE *args = NEW_LIST($6);
d3996 1
a3996 1
		pushback(c);
@


1.74.2.69
log
@* array.c, class.c, eval.c, file.c, gc.c, node.h, numeric.c,
  object.c, parse.y, range.c, re.c, string.c, struct.c, util.c,
  ext/socket/socket.c: merge from 1.7: treat long values as long
  instead of int.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2002/10/25 19:46:02 $
d334 1
a334 1
			sprintf(buf, "$%c", (int)$3->nd_nth);
d4478 1
a4478 1
	rb_compile_error("Can't set variable $%d", (int)node->nd_nth);
d4481 1
a4481 1
	rb_compile_error("Can't set variable $%c", (int)node->nd_nth);
@


1.73
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/18 09:46:05 $
d3247 3
a3249 1
		    if ((c = nextc()) == '-' || c == '+')
d3251 1
a3251 1
		    else
d3633 6
a3638 1
		    if ((c = nextc()) == '=' && !peek('=') && !peek('~')) {
@


1.72
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/12 07:42:28 $
d1025 1
a1025 1
			value_expr($1);
d3129 1
a3129 1
	    int is_float, seen_point, seen_e;
d3131 1
a3131 1
	    is_float = seen_point = seen_e = 0;
a3142 3
		    if (!ISXDIGIT(c)) {
			yyerror("hexadecimal number without hex-digits");
		    }
d3144 4
a3147 1
			if (c == '_') continue;
d3149 1
d3154 4
a3163 3
		    if (c != '0' && c != '1') {
			yyerror("numeric literal without digits");
		    }
d3165 4
a3168 1
			if (c == '_') continue;
d3170 1
d3175 4
d3185 4
a3188 1
			if (c  == '_') continue;
d3190 1
d3195 1
d3216 1
d3236 1
d3253 2
a3254 1
		  case '_':	/* `_' in decimal just ignored */
d3266 4
@


1.71
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/05 09:36:34 $
d1206 1
a1206 1
		| kCASE compstmt
d1211 1
a1211 1
			$$ = NEW_CASE($2, $3);
d1213 4
@


1.70
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/27 09:23:22 $
a1916 1
static int last_newline;
a1955 1
    last_newline = 0;
d2815 1
a2815 1
	space_seen = 1;
d2983 4
a3298 1
	    arg_ambiguous();
d3300 1
a3851 1
	if (nd_line(node) == last_newline) return node;
d3854 1
a3854 1
        last_newline = nl->nd_nth = nd_line(node);
d4649 1
a4649 1
	    if (i == 0 || ruby_scope->flag == SCOPE_ALLOCA) {
@


1.69
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/21 14:26:23 $
d191 1
a191 1
%type <node> mrhs superclass generic_call block_call var_ref
d410 4
d1016 8
a1023 1
mrhs		: args
d1025 2
a1026 9
			if ($1 &&
		            nd_type($1) == NODE_ARRAY &&
		            $1->nd_next == 0)
			{
			    $$ = $1->nd_head;
			}
			else {
			    $$ = $1;
			}
d1218 1
a1218 1
			value_expr($2);
d1364 1
a1364 1
			$$ = 0;
d1368 1
a1368 1
			$$ = 0;
d1397 1
a1397 1
		        fixpos($$, $3?$3:$4);
d1409 1
a1409 1
		        fixpos($$, $3?$3:$4);
@


1.68
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/13 05:39:34 $
a1958 1
    rb_gc();
@


1.67
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/10 07:16:50 $
d4092 1
a4092 1
	if (in_single) return NEW_CVASGN2(id, val);
d4182 1
a4182 1
      case NODE_CVASGN2:
@


1.66
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/31 08:37:39 $
d752 16
d769 3
d1913 1
d1953 1
d3847 1
d3850 1
a3850 1
        nl->nd_nth = nd_line(node);
@


1.65
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/20 16:36:53 $
d3283 1
a3283 1
	if (nextc() == '=') {
d3288 1
a3288 1
	return c;
@


1.64
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/16 09:13:20 $
d2866 2
a2867 1
		    if (strncmp(lex_p, "end", 3) == 0 && ISSPACE(lex_p[3])) {
@


1.63
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/11 06:29:07 $
d1823 12
a1834 1
#define is_identchar(c) (((int)(c))!=-1&&(ISALNUM(c) || (c) == '_' || ismbchar(c)))
@


1.62
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/10 07:03:21 $
d1352 1
d1565 1
a1565 1

@


1.61
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/22 18:15:44 $
d1274 1
@


1.60
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/19 07:54:22 $
a4344 5
      case NODE_DSTR:
      case NODE_XSTR:
      case NODE_DXSTR:
      case NODE_EVSTR:
      case NODE_DREGX:
d4352 5
d4360 1
d4364 1
@


1.59
log
@000919
@
text
@d6 1
a6 1
  $Date: 2000/09/18 08:47:09 $
d1207 1
d1213 1
a1213 1
		        fixpos($$, $3);
d1240 1
d1246 1
a1246 1
		        fixpos($$, $4);
@


1.58
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/15 06:00:26 $
a3400 2
	  case '~':		/* $~: match-data */
            /* fall through */
d3410 3
a3412 1
	    local_cnt('_');
@


1.57
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/12 05:37:24 $
d1510 5
a1514 1
			$$ = $2;
@


1.56
log
@matz: 1.6.0 final (hopufully)
@
text
@d6 1
a6 1
  $Date: 2000/09/04 08:24:02 $
d3400 9
a3408 1
	    local_cnt(c);
@


1.55
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/01 09:18:11 $
d193 1
a193 1
%type <node> array assoc_list assocs assoc undef_list backref
a423 4
		| kYIELD ret_args
		    {
			$$ = NEW_YIELD($2);
		    }
d468 6
a1029 3
array		: none
		| args trailer

d1085 1
a1085 1
		| tLBRACK array ']'
@


1.54
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/31 05:29:47 $
d61 11
a227 2
/*%nonassoc kDO
%nonassoc kDO2*/
d871 4
d879 1
a879 1
		| args opt_nl
d881 1
a881 1
			$$ = $1;
d883 1
a883 1
		| args ',' opt_nl
d892 1
a892 5
		| assocs
		    {
			$$ = NEW_LIST(NEW_HASH($1));
		    }
		| assocs ','
d908 4
d1168 1
a1168 1
		| kWHILE {cond_nest++;} expr do { cond_nest--; }
d1176 1
a1176 1
		| kUNTIL {cond_nest++;} expr do { cond_nest--; } 
d1192 1
a1192 1
		| kFOR block_var kIN {cond_nest++;} expr do {cond_nest--;}
d1458 1
a1458 2
			if (cond_nest == 0)
			    lex_state = EXPR_PAREN;
d1499 1
a1499 1
		        if ($3 && $5) {
d1923 1
d3214 3
d3218 3
d3286 3
d3538 3
a3540 1
		    if (state == EXPR_PAREN && kw->id[0] == kDO) {
@


1.53
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/30 05:20:36 $
d862 4
d895 4
@


1.52
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/29 07:29:48 $
d217 2
a218 2
%nonassoc kDO
%nonassoc kDO2
d394 6
@


1.51
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/29 02:52:34 $
d4095 1
@


1.50
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/28 09:53:29 $
d3947 1
a3947 2
	if (in_single) return NEW_CVAR3(id);
	if (cur_mid) return NEW_CVAR2(id);
d4005 1
a4005 2
	if (in_single) return NEW_CVASGN3(id, val);
	if (cur_mid) return NEW_CVASGN2(id, val);
@


1.49
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/02 04:54:14 $
d3948 2
a3949 3
	if (class_nest ==0 && cur_mid)
	    return NEW_CVAR2(id);
	else return NEW_CVAR(id);
d4007 1
a4007 5
	if (cur_mid) {
	    if (class_nest == 0)
		return NEW_CVASGN2(id, val);
	    return NEW_CVASGN(id, val);
	}
a4095 1
      case NODE_CVASGN:
@


1.48
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/27 09:49:21 $
d3947 4
a3950 1
	return NEW_CVAR(id);
a3960 2
    NODE *lhs = 0;

d3982 1
a3982 1
	    lhs = NEW_DASGN_CURR(id, val);
d3985 1
a3985 1
	    lhs = NEW_DASGN(id, val);
d3988 1
a3988 1
	    lhs = NEW_LASGN(id, val);
d3992 1
a3992 1
	    lhs = NEW_DASGN_CURR(id, val);
d3996 1
a3996 1
	lhs = NEW_GASGN(id, val);
d3999 1
a3999 1
	lhs = NEW_IASGN(id, val);
d4004 1
a4004 1
	lhs = NEW_CDECL(id, val);
d4007 5
a4011 5
	if (cur_mid || in_single) {
	    lhs = NEW_CVASGN(id, val);
	}
	else {
	    lhs = NEW_CVDECL(id, val);
d4013 1
d4018 1
a4018 1
    return lhs;
a4099 1
      case NODE_CASGN:
a4290 1
      case NODE_CASGN:
@


1.47
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/21 08:45:32 $
d1894 1
@


1.46
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/18 06:00:36 $
a1788 3
#ifndef strdup
char *strdup();
#endif
d1862 1
a1898 1
    if (n == 0) return ruby_eval_tree;
d1900 2
a1901 1
    return 0;
@


1.45
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/12 06:06:47 $
d852 4
@


1.44
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/11 08:27:06 $
d1862 1
a1862 1
    if (!ruby_in_eval && rb_safe_level() == 0 &&
@


1.43
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/07 03:20:51 $
d3446 1
a3446 1
	    rb_compile_error("Invalid char '%c'(%03o) in expression", c, c);
@


1.42
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/04 04:17:13 $
d3435 3
d3445 2
a3446 2
	if (c != '_' && !ISALPHA(c) && !ismbchar(c)) {
	    rb_compile_error("Invalid char '%c' in expression", c);
@


1.41
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/03 05:46:36 $
d865 8
d3392 1
@


1.40
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/01 06:51:28 $
d2630 5
a2634 2
	if (strncmp(eos, p, len) == 0 && (p[len] == '\n' || p[len] == '\r')) {
	    break;
@


1.39
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/01 06:46:35 $
a428 1
			value_expr($2);
d851 6
a856 1
aref_args	: opt_call_args
a857 3
			if ($1 && nd_type($1) == NODE_BLOCK_PASS) {
			    rb_compile_error("block argument should not be given");
			}
d860 10
a877 4
		| args ','
		    {
			$$ = $1;
		    }
d888 1
d903 1
d918 1
@


1.38
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/23 07:01:26 $
d864 3
@


1.37
log
@2000-06-23
@
text
@d6 1
a6 1
  $Date: 2000/06/05 08:46:51 $
d864 1
d866 1
a866 2
			value_expr($1);
			$$ = NEW_LIST($1);
d868 1
a868 1
		| args ','
d870 1
a870 1
			$$ = $1;
d1595 13
a1607 1
			yyerror("formal argument must not be constant");
@


1.36
log
@2000-06-05
@
text
@d6 1
a6 1
  $Date: 2000/05/30 04:24:01 $
d86 1
d455 1
a455 1
			$$ = NEW_SUPER($2);
d1394 1
a1394 1
			$$ = NEW_SUPER($3);
d4389 11
@


1.35
log
@2000-05-30
@
text
@d6 1
a6 1
  $Date: 2000/05/25 05:55:05 $
d4740 1
a4740 2
	char *res;
	ID id2;
d4742 4
a4745 2
	id2 = (id & ~ID_SCOPE_MASK) | ID_LOCAL;
	res = rb_id2name(id2);
d4747 1
a4747 4
	if (res) {
	    char *buf = ALLOCA_N(char, strlen(res)+2);

	    strcpy(buf, res);
d4751 4
@


1.34
log
@2000-05-25
@
text
@d6 1
a6 1
  $Date: 2000/05/24 04:34:04 $
a50 1
    EXPR_MID,			/* newline significant, +/- is a sign. */
d54 1
d1434 2
a1435 2
exc_list	: args
		| none
d1437 1
a1437 1
exc_var		: ':' lhs
d1443 1
a1443 1
rescue		: kRESCUE exc_list exc_var do
d1911 1
a1911 1
    compile_for_eval = 1;
d2746 5
a2750 2
	    lex_state = EXPR_BEG;
	    return tSTAR;
d2752 2
a2753 3
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
	    lex_state = EXPR_BEG;
	    return tSTAR;
d2756 1
a2756 1
	return '*';
d2905 5
a2909 2
	    lex_state = EXPR_BEG;
	    return tAMPER;
d2911 2
a2912 3
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
	    lex_state = EXPR_BEG;
	    return tAMPER;
d2915 1
a2915 1
	return '&';
d2950 2
a2952 1
	    if (lex_state == EXPR_ARG) arg_ambiguous();
a2956 1
	    lex_state = EXPR_BEG;
d3154 1
a3154 1
	    if (lex_state == EXPR_BEG || lex_state == EXPR_MID ||
d3179 4
a3182 4
	if (lex_state == EXPR_ARG) {
	    if (space_seen && !ISSPACE(c)) {
		pushback(c);
		arg_ambiguous();
a3186 1
	pushback(c);
a3214 1
	    lex_state = EXPR_BEG;
d3216 2
a3217 5
	else {
	    if (lex_state == EXPR_ARG && space_seen) {
		rb_warning("%s (...) interpreted as function", tok());
	    }
	    lex_state = EXPR_BEG;
d3219 1
@


1.33
log
@2000-05-24
@
text
@d6 1
a6 1
  $Date: 2000/05/22 07:29:50 $
d2157 2
@


1.32
log
@/p is back for transit
@
text
@d6 1
a6 1
  $Date: 2000/05/18 04:32:06 $
d2259 1
a2259 1
		  case 'p':	/* /p is obsolete, works as /m */
@


1.31
log
@2000-05-18
@
text
@d6 1
a6 1
  $Date: 2000/05/17 06:33:46 $
d1437 1
a1437 1
exc_var		: kIN lhs
d2260 2
a2261 1
		    yyerror("/p option is obsolete; use /m\n\tnote: /m does not change ^, $ behavior");
d2270 1
a2270 1
		    kcode = 8;
d2273 1
a2273 1
		    kcode = 16;
d2276 1
a2276 1
		    kcode = 24;
d2279 1
a2279 1
		    kcode = 32;
d4658 1
a4658 1
    int id;
@


1.30
log
@thread problems
@
text
@d6 1
a6 1
  $Date: 2000/05/17 04:38:13 $
d2260 2
@


1.29
log
@2000-05-17
@
text
@d6 1
a6 1
  $Date: 2000/05/12 09:07:43 $
d2259 3
a2261 2
		  case 'p':
		    options |= RE_OPTION_POSIXLINE;
@


1.28
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/09 04:53:01 $
a403 1
			value_expr($2);
a409 1
			value_expr($2);
d4095 3
@


1.27
log
@2000-05-09
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:25 $
d2128 78
a2213 1
    int in_brack = 0;
d2219 1
a2219 1
	if (!in_brack && c == term && nest == 0) {
a2223 7
	  case '[':
	    in_brack = 1;
	    break;
	  case ']':
	    in_brack = 0;
	    break;

d2230 1
a2230 4
	    switch (c = nextc()) {
	      case -1:
		ruby_sourceline = re_start;
		rb_compile_error("unterminated regexp meets end of file");
a2231 35

	      case '\n':
		break;

	      case '\\':
	      case '^':
	      case 's':
		tokadd('\\');
		tokadd(c);
		break;

	      case '1': case '2': case '3':
	      case '4': case '5': case '6':
	      case '7': case '8': case '9':
	      case '0': case 'x':
		tokadd('\\');
		tokadd(c);
		break;

	      case 'b':
		if (!in_brack) {
		    tokadd('\\');
		    tokadd('b');
		    break;
		}
		/* fall through */
	      default:
		if (c == term) {
		    tokadd(c);
		}
		else {
		    tokadd('\\');
		    tokadd(c);
		}
	    }
d2235 1
a2235 2
	    rb_compile_error("unterminated regexp");
	    return 0;
d2238 1
a2238 1
	    if (paren && !in_brack)  {
d2306 3
a2308 1
    rb_compile_error("unterminated regexp");
@


1.26
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:44:16 $
d528 4
d554 4
d3330 1
d3335 2
d3339 1
a3339 1
	    yylval.node = NEW_NTH_REF(atoi(tok()));
@


1.25
log
@2000-04-10
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/03/23 08:37:29 $
d11 1
a11 1
************************************************/
d363 1
a363 1
		| stmt kRESCUE_MOD expr
d1213 1
a1213 1
			$$ = NEW_DEFN($2, $4, $5, class_nest?0:1);
a1657 4
			else if (nd_type($1) == NODE_NIL) {
			    yyerror("Can't define single method for nil.");
			    $$ = 0;
			}
d2453 5
a2457 1
		if (ISSPACE(c))
d2459 1
a2459 1
		tokadd(c);
@


1.24
log
@2000-03-23
@
text
@d6 1
a6 1
  $Date: 2000/03/13 07:18:37 $
d2576 1
a2576 1
	    rb_str_cat(yylval.val, "\n", 1);
d2578 1
a2578 1
	        rb_str_cat(str, RSTRING(yylval.val)->ptr, RSTRING(yylval.val)->len);
d3170 2
a3171 5
	    if (lex_state == EXPR_ARG) {
		if (space_seen) {
		    arg_ambiguous();
		    c = tLPAREN;
		}
d3549 4
@


1.23
log
@2000-03-13
@
text
@d6 1
a6 1
  $Date: 2000/03/09 08:59:54 $
d30 1
a30 1
#define ID_SHARED   0x06
d38 1
a38 1
#define is_shared_id(id) (is_notop_id(id)&&((id)&ID_SCOPE_MASK)==ID_SHARED)
d169 1
a169 1
%token <id>   tIDENTIFIER tFID tGVAR tIVAR tCONSTANT tSHVAR
d176 1
a176 1
%type <node> if_tail opt_else case_body cases rescue ensure
d179 1
a179 1
%type <node> mrhs opt_list superclass generic_call block_call var_ref
a920 3
opt_list	: args
		| none

d1428 10
a1437 1
rescue		: kRESCUE opt_list do
d1441 6
a1446 2
			$$ = NEW_RESBODY($2, $4, $5);
		        fixpos($$, $2?$2:$4);
d1509 1
a1509 1
		| tSHVAR
d3399 1
a3399 1
		result = tSHVAR;
d3851 3
a3855 3
    else if (is_shared_id(id)) {
	return NEW_SHVAR(id);
    }
d3912 1
a3912 1
    else if (is_shared_id(id)) {
d3914 1
a3914 1
	    lhs = NEW_SHASGN(id, val);
d3917 1
a3917 1
	    lhs = NEW_SHDECL(id, val);
d4007 2
a4008 2
      case NODE_SHASGN:
      case NODE_SHDECL:
d4112 1
d4117 1
a4117 1
      case NODE_CVAR:
d4621 1
a4621 1
	    id |= ID_SHARED;
d4715 1
a4715 1
rb_is_shared_id(id)
d4718 1
a4718 1
    if (is_shared_id(id)) return Qtrue;
@


1.22
log
@2000-03-09
@
text
@d6 1
a6 1
  $Date: 2000/03/08 06:23:16 $
d1576 5
a1580 1
f_norm_arg	: tIDENTIFIER
@


1.21
log
@2000-03-08
@
text
@d6 1
a6 1
  $Date: 2000/03/07 08:37:42 $
d183 1
a183 1
%type <node> mlhs mlhs_head mlhs_tail mlhs_basic mlhs_entry mlhs_item mlhs_node
d474 1
a474 1
			$$ = NEW_MASGN(NEW_LIST($1), 0);
d476 1
a476 1
		| mlhs_head tSTAR lhs
d478 1
a478 1
			$$ = NEW_MASGN(NEW_LIST($1), $3);
d480 1
a480 1
		| mlhs_head tSTAR
d482 1
a482 1
			$$ = NEW_MASGN(NEW_LIST($1), -1);
d484 1
a484 9
		| mlhs_head mlhs_tail
		    {
			$$ = NEW_MASGN(list_concat(NEW_LIST($1),$2), 0);
		    }
		| mlhs_head mlhs_tail ',' tSTAR lhs
		    {
			$$ = NEW_MASGN(list_concat(NEW_LIST($1),$2),$5);
		    }
		| mlhs_head mlhs_tail ',' tSTAR
d486 1
a486 1
			$$ = NEW_MASGN(list_concat(NEW_LIST($1),$2),-1);
a504 5
			$$ = $1;
		    }

mlhs_tail	: mlhs_item
		    {
d507 1
a507 1
		| mlhs_tail ',' mlhs_item
d509 1
a509 1
			$$ = list_append($1, $3);
@


1.20
log
@2000-03-07
@
text
@d6 1
a6 1
  $Date: 2000/02/26 01:16:48 $
d2070 1
a2070 5
	    char buf[2];
	    int i;

	    for (i=0; i<2; i++) {
		int cc = nextc();
d2072 2
a2073 8
		if (cc == -1) goto eof;
		buf[i] = cc;
		if (!ISXDIGIT(buf[i])) {
		    pushback(buf[i]);
		    break;
		}
	    }
	    c = scan_hex(buf, i, &i);
d3588 10
a3597 3
		c = read_escape();
		tokadd(c);
		goto loop_again;
@


1.19
log
@+<digit> problem
@
text
@d6 1
a6 1
  $Date: 2000/02/18 06:59:33 $
d1462 1
a1462 1
			$$ = INT2FIX($1);
@


1.18
log
@2000-02-18
@
text
@d6 1
a6 1
  $Date: 2000/02/17 07:11:13 $
d2912 4
a2915 1
	    if (ISDIGIT(c)) goto start_num;
@


1.17
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:48:50 $
d30 1
d38 1
d169 1
a169 1
%token <id>   tIDENTIFIER tFID tGVAR tIVAR tCONSTANT
d1512 1
d1639 4
d3352 6
a3361 2
	newtok();
	tokadd('@@');
d3404 4
a3407 1
	    result = tIVAR;
d3852 3
d3911 8
d4006 2
d4618 4
a4621 1
	id |= ID_INSTANCE;
d4709 8
@


1.16
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:12:10 $
d2433 1
a2433 1
    while ((c = nextc()) == ' ')
a2457 3
	      case ' ':
		tokadd(' ');
		break;
d2459 3
a2461 1
		tokadd('\\');
d2464 1
a2464 1
	else if (c == ' ') {
d2472 1
a2472 1
	    while ((c = nextc()) == ' ')
d3416 2
a3417 2
		if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
		    if ((c = nextc()) == '=' && !peek('=')) {
@


1.15
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:37:44 $
d1123 1
a1123 1
		| kWHILE {cond_nest++;} expr do {cond_nest--;} 
d1131 1
a1131 1
		| kUNTIL {cond_nest++;} expr do {cond_nest--;} 
@


1.14
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/08 05:00:20 $
d535 4
d557 4
d694 11
d990 37
a1035 9
		| string
		| tXSTRING
		    {
			$$ = NEW_XSTR($1);
		    }
		| tDXSTRING
		| tDREGEXP
		| var_ref
		| backref
a1089 4
		| tFID
		    {
			$$ = NEW_VCALL($1);
		    }
a1154 24
		| kBEGIN
		  compstmt
		  rescue
		  opt_else
		  ensure
		  kEND
		    {
			if (!$3 && !$4 && !$5)
			    $$ = NEW_BEGIN($2);
			else {
			    if ($3) $2 = NEW_RESCUE($2, $3, $4);
			    else if ($4) {
				rb_warn("else without rescue is useless");
				$2 = block_append($2, $4);
			    }
			    if ($5) $2 = NEW_ENSURE($2, $5);
			    $$ = $2;
			}
		        fixpos($$, $2);
		    }
		| tLPAREN compstmt ')'
		    {
			$$ = $2;
		    }
d2422 1
a2422 1
parse_quotedword(term, paren)
d2425 71
a2495 2
    if (parse_qstring(term, paren) == 0) return 0;
    yylval.node = NEW_CALL(NEW_STR(yylval.val), rb_intern("split"), 0);
d2905 2
d2930 1
d2933 4
d3170 6
d3251 1
a3251 1
		return parse_quotedword(term, paren);
d3870 4
a3873 1
	if (rb_dvar_defined(id)) {
d3880 2
a3881 2
	    rb_dvar_push(id, 0);
	    lhs = NEW_DASGN_PUSH(id, val);
d3978 1
a3978 1
      case NODE_DASGN_PUSH:
d4461 3
d4465 1
a4465 1
    return ruby_dyna_vars;
@


1.13
log
@2000-01-08
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:37:08 $
d3010 2
a3011 5
	    if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
		lex_state = EXPR_BEG;
		return tCOLON3;
	    }
	    if (lex_state == EXPR_ARG && space_seen) {
d3284 1
a3284 1
	int result;
d3312 1
a3312 4
	    if (ISUPPER(tok()[0])) {
		result = tCONSTANT;
	    }
	    else if (toklast() == '!' || toklast() == '?') {
a3315 1
		result = tIDENTIFIER;
d3318 1
d3325 6
d3844 1
d3858 1
a3858 1
	return NEW_ARGSCAT(node1, node2);
@


1.12
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:49:47 $
d591 1
a591 2
op		: tDOT2		{ $$ = tDOT2; }
		| '|'		{ $$ = '|'; }
@


1.11
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/11/17 07:30:34 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d334 7
a340 2
			if (nd_type($1) == NODE_BEGIN) {
			    $$ = NEW_WHILE(cond($3), $1->nd_body, 0);
d343 1
a343 1
			    $$ = NEW_WHILE(cond($3), $1, 1);
d349 7
a355 2
			if (nd_type($1) == NODE_BEGIN) {
			    $$ = NEW_UNTIL(cond($3), $1->nd_body, 0);
d358 1
a358 1
			    $$ = NEW_UNTIL(cond($3), $1, 1);
d619 1
a619 1
reswords	: k__LINE__ | k__FILE__ | klBEGIN | klEND
d726 1
a726 1
			if (nd_type($2) == NODE_LIT) {
d735 1
a735 1
			if (nd_type($2) == NODE_LIT && FIXNUM_P($2->nd_lit)) {
d1794 1
a1794 1
yycompile(f)
d1796 1
d1801 1
a1801 1
	rb_const_defined(rb_cObject, rb_intern("LINES__"))) {
d1804 1
a1804 1
	hash = rb_const_get(rb_cObject, rb_intern("LINES__"));
d1813 7
d1885 1
a1885 1
    return yycompile(f);
d1907 1
a1907 1
    return yycompile(strdup(f));
d2894 1
a2894 1
		    yylval.val = rb_str2inum(tok(), 16);
d2910 1
a2910 1
		    yylval.val = rb_str2inum(tok(), 2);
d2922 1
a2922 1
		    yylval.val = rb_str2inum(tok(), 8);
d2998 1
a2998 1
	    yylval.val = rb_str2inum(tok(), 10);
@


1.10
log
@19991117
@
text
@d6 1
a6 1
  $Date: 1999/11/10 06:47:08 $
d29 1
a29 1
#define ID_SHARED   0x05
d36 1
a36 1
#define is_shared_id(id) (is_notop_id(id)&&((id)&ID_SCOPE_MASK)==ID_SHARED)
d720 1
a720 1
			    $$ = call_op($2, tUPLUS, 0);
d732 1
a732 1
			    $$ = call_op($2, tUMINUS, 0);
d794 1
a794 1
			$$ = call_op($2, '~', 0);
d1790 1
a1790 1
	rb_shvar_defined(rb_cObject, rb_intern("LINES__"))) {
d1793 1
a1793 1
	hash = rb_shvar_get(rb_cObject, rb_intern("LINES__"));
d2883 1
a2883 1
			yyerror("numeric constant with no digits");
d3718 1
a3718 1
    else if (is_shared_id(id)) {
d3769 1
a3769 1
    else if (is_shared_id(id)) {
d3771 2
a3772 3
	    lhs = NEW_CASGN(id, val);
	else
	    lhs = NEW_CDECL(id, val);
d4498 1
a4498 1
	    id = ID_SHARED;
d4551 1
a4551 1
rb_is_shared_id(id)
d4554 1
a4554 1
    if (is_shared_id(id)) return Qtrue;
a4555 7
}

int
rb_is_const_id(id)
    ID id;
{
    return rb_is_shared_id(id);
@


1.9
log
@19991110
@
text
@d6 1
a6 1
  $Date: 1999/10/15 08:52:16 $
d29 1
a29 1
#define ID_CONST    0x05
d31 6
a36 6
#define is_id_notop(id) ((id)>LAST_TOKEN)
#define is_local_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_LOCAL)
#define is_global_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_GLOBAL)
#define is_instance_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_INSTANCE)
#define is_attrset_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_ATTRSET)
#define is_const_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_CONST)
d1790 1
a1790 1
	rb_const_defined(rb_cObject, rb_intern("LINES__"))) {
d1793 1
a1793 1
	hash = rb_const_get(rb_cObject, rb_intern("LINES__"));
d3718 1
a3718 1
    else if (is_const_id(id)) {
d3769 1
a3769 1
    else if (is_const_id(id)) {
d3771 3
a3773 2
	    yyerror("dynamic constant assignment");
	lhs = NEW_CASGN(id, val);
d3858 1
d3860 1
a3860 1
      case NODE_MASGN:
d4499 1
a4499 1
	    id = ID_CONST;
d4552 8
d4563 1
a4563 2
    if (is_const_id(id)) return Qtrue;
    return Qfalse;
@


1.8
log
@-r debug, -s, etc.
@
text
@d6 1
a6 1
  $Date: 1999/10/13 06:44:41 $
d159 1
d216 1
a216 1
%left  kIF_MOD kUNLESS_MOD kWHILE_MOD kUNTIL_MOD
d351 4
d615 1
a615 1
		| kWHILE_MOD | kYIELD
@


1.7
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:33 $
d170 1
a170 1
%type <node> singleton
d966 1
a966 5
		| tSTRING
		    {
			$$ = NEW_STR($1);
		    }
		| tDSTRING
d1431 28
d1717 1
a1717 1
static NODE *rb_str_extend();
d1776 2
d1784 15
d1805 1
d1839 10
d1897 1
a1897 1
	    VALUE v = (*lex_gets)(lex_input);
d2112 1
a2112 1
	    list = rb_str_extend(list, term);
d2274 1
a2274 1
	    list = rb_str_extend(list, term);
d2437 1
a2437 1
	lex_lastline = line = (*lex_gets)(lex_input);
d3326 1
a3326 1
rb_str_extend(list, term)
@


1.6
log
@19991012
@
text
@d6 1
a6 1
  $Date: 1999/10/04 04:51:05 $
d1185 3
d1190 7
@


1.6.2.1
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:33 $
d333 2
a334 7
			if ($1) {
			    if (nd_type($1) == NODE_BEGIN) {
				$$ = NEW_WHILE(cond($3), $1->nd_body, 0);
			    }
			    else {
				$$ = NEW_WHILE(cond($3), $1, 1);
			    }
d337 1
a337 1
			    $$ = 0;
d343 2
a344 7
			if ($1) {
			    if (nd_type($1) == NODE_BEGIN) {
				$$ = NEW_UNTIL(cond($3), $1->nd_body, 0);
			    }
			    else {
				$$ = NEW_UNTIL(cond($3), $1, 1);
			    }
d347 1
a347 1
			    $$ = 0;
d711 1
a711 1
			if ($2 && nd_type($2) == NODE_LIT) {
d720 1
a720 1
			if ($2 && nd_type($2) == NODE_LIT && FIXNUM_P($2->nd_lit)) {
@


1.6.2.2
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:41:09 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
d586 2
a587 1
op		: '|'		{ $$ = '|'; }
d3783 1
a3783 1
	return NEW_ARGSCAT(node1, NEW_LIST(node2));
@


1.6.2.3
log
@2000-02-01
@
text
@d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
a529 4
		| primary tCOLON2 tIDENTIFIER
		    {
			$$ = attrset($1, $3);
		    }
a547 4
		| primary tCOLON2 tIDENTIFIER
		    {
			$$ = attrset($1, $3);
		    }
a680 11
		| primary tCOLON2 tIDENTIFIER tOP_ASGN arg
		    {
			if ($4 == tOROP) {
			    $4 = 0;
			}
			else if ($4 == tANDOP) {
			    $4 = 1;
			}
			$$ = NEW_OP_ASGN2($1, $3, $4, $5);
		        fixpos($$, $1);
		    }
d724 1
a724 1
			    $$ = call_op($2, tUPLUS, 0, 0);
d736 1
a736 1
			    $$ = call_op($2, tUMINUS, 0, 0);
d798 1
a798 1
			$$ = call_op($2, '~', 0, 0);
d3782 1
a3782 1
	return NEW_ARGSCAT(node1, node2);
@


1.6.2.4
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:11:22 $
d3267 2
a3268 2
		if (lex_state == EXPR_FNAME) {
		    if ((c = nextc()) == '=' && !peek('=') && !peek('~')) {
@


1.6.2.5
log
@2000-03-08
@
text
@d6 1
a6 1
  $Date: 2000/02/17 08:28:59 $
d3425 3
a3427 10
		c = nextc();
		if (c == -1) return (NODE*)-1;
		if (c == term) {
		    tokadd(c);
		}
		else {
		    tokadd('\\');
		    tokadd(c);
		}
		break;
@


1.6.2.6
log
@2000-03-13
@
text
@d6 1
a6 1
  $Date: 2000/03/08 06:25:12 $
d1547 1
a1547 5
f_norm_arg	: tCONSTANT
		    {
			yyerror("formal argument must not be constant");
		    }
		| tIDENTIFIER
@


1.6.2.7
log
@2000-05-09
@
text
@d6 1
a6 1
  $Date: 2000/03/13 09:15:43 $
a533 4
		| primary '.' tCONSTANT
		    {
			$$ = attrset($1, $3);
		    }
a555 4
		| primary '.' tCONSTANT
		    {
			$$ = attrset($1, $3);
		    }
a3174 1
	    tokadd('$');
a3178 2
	    if (is_identchar(c))
		break;
d3181 1
a3181 1
	    yylval.node = NEW_NTH_REF(atoi(tok()+1));
d3235 1
a3235 1
	int result = 0;
d3263 4
a3266 1
	    if (toklast() == '!' || toklast() == '?') {
d3270 1
a3277 6
		}
		if (result == 0 && ISUPPER(tok()[0])) {
		    result = tCONSTANT;
		}
		else {
		    result = tIDENTIFIER;
@


1.6.2.8
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/09 04:50:11 $
a2062 78
tokadd_escape()
{
    int c;

    switch (c = nextc()) {
      case '\n':
	return 0;		/* just ignore */

      case '0': case '1': case '2': case '3': /* octal constant */
      case '4': case '5': case '6': case '7':
	{
	    int i;

	    tokadd('\\');
	    tokadd(c);
	    for (i=0; i<2; i++) {
		c = nextc();
		if (c == -1) goto eof;
		if (c < '0' || '7' < c) {
		    pushback(c);
		    break;
		}
		tokadd(c);
	    }
	}
	return 0;

      case 'x':	/* hex constant */
	{
	    int numlen;

	    scan_hex(lex_p, 2, &numlen);
	    while (numlen--)
		tokadd(nextc());
	}
	return 0;

      case 'M':
	if ((c = nextc()) != '-') {
	    yyerror("Invalid escape character syntax");
	    pushback(c);
	    return 0;
	}
	tokadd('\\'); tokadd('M'); tokadd('-');
	goto escaped;

      case 'C':
	if ((c = nextc()) != '-') {
	    yyerror("Invalid escape character syntax");
	    pushback(c);
	    return 0;
	}
	tokadd('\\'); tokadd('C'); tokadd('-');
	goto escaped;

      case 'c':
	tokadd('\\'); tokadd('c');
      escaped:
	if ((c = nextc()) == '\\') {
	    return tokadd_escape();
	}
	else if (c == -1) goto eof;
	tokadd(c);
	return 0;

      eof:
      case -1:
        yyerror("Invalid escape character syntax");
	return -1;

      default:
	tokadd('\\');
	tokadd(c);
    }
    return 0;
}

static int
d2071 1
d2077 1
a2077 1
	if (c == term && nest == 0) {
d2082 7
d2095 4
a2098 1
	    if (tokadd_escape() < 0)
d2100 35
d2138 2
a2139 1
	    goto unterminated;
d2142 1
a2142 1
	    if (paren)  {
d2210 1
a2210 3
  unterminated:
    ruby_sourceline = re_start;
    rb_compile_error("unterminated regexp meets end of file");
@


1.6.2.9
log
@2000-05-30
@
text
@d6 1
a6 1
  $Date: 2000/05/12 09:06:11 $
d397 1
d404 1
@


1.6.2.10
log
@2000-06-05
@
text
@d6 1
a6 1
  $Date: 2000/05/30 04:21:08 $
d4470 1
a4470 1
    ID id;
@


1.6.2.11
log
@2000-06-23
@
text
@d6 1
a6 1
  $Date: 2000/06/05 09:00:59 $
a83 1
static NODE *new_super();
d447 1
a447 1
			$$ = new_super($2);
d1396 1
a1396 1
			$$ = new_super($3);
a4200 11
}

static NODE*
new_super(a)
    NODE *a;
{
    if (a && nd_type(a) == NODE_BLOCK_PASS) {
	a->nd_iter = NEW_SUPER(a->nd_head);
	return a;
    }
    return NEW_SUPER(a);
@


1.6.2.12
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/23 07:05:56 $
a876 4
		    }
		| args ',' command_call
		    {
			$$ = list_append($1, $3);
@


1.6.2.13
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/01 06:47:45 $
d422 1
d871 1
@


1.6.2.14
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/10 08:01:34 $
a2095 2
	    tokadd('\\');
	    tokadd('x');
@


1.5
log
@19991004
@
text
@d6 1
a6 1
  $Date: 1999/09/16 16:11:25 $
d4423 1
a4423 1
	    if (id > LAST_TOKEN) {
d4427 1
a4427 1
	    id |= ID_ATTRSET;
@


1.4
log
@990917
@
text
@d6 1
a6 1
  $Date: 1999/09/16 09:40:32 $
d2390 1
a2390 1
	if (strncmp(eos, p, len) == 0 && p[len] == '\n') {
@


1.3
log
@1.4.1
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:09 $
d629 3
a631 1
			    $$->nd_value = call_op(gettable($1), $2, 1, $4);
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/11 07:24:03 $
d1843 2
a1844 1
	    if (strncmp(lex_pbeg, "__END__", 7) == 0 && lex_pbeg[7] == '\n') {
d1857 4
d2924 1
a2924 1
	    if (lex_state == EXPR_BEG) {
a3026 4
	if (c == '\r') {
	    c = nextc();
	    if (c != '\n') pushback(c);
	}
d3234 2
a3235 1
	    } else {
d3248 1
a3248 1
		lex_state == EXPR_ARG){
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1996/12/25 08:54:50 $
d9 1
a9 1
  Copyright (C) 1993-1996 Yukihiro Matsumoto
d21 1
a21 5

/* hack for bison */
#ifdef const
# undef const
#endif
d31 6
a36 11
#define is_id_nonop(id) ((id)>LAST_TOKEN)
#define is_local_id(id) (is_id_nonop(id)&&((id)&ID_SCOPE_MASK)==ID_LOCAL)
#define is_global_id(id) (is_id_nonop(id)&&((id)&ID_SCOPE_MASK)==ID_GLOBAL)
#define is_instance_id(id) (is_id_nonop(id)&&((id)&ID_SCOPE_MASK)==ID_INSTANCE)
#define is_attrset_id(id) (is_id_nonop(id)&&((id)&ID_SCOPE_MASK)==ID_ATTRSET)
#define is_const_id(id) (is_id_nonop(id)&&((id)&ID_SCOPE_MASK)==ID_CONST)

struct op_tbl {
    ID token;
    char *name;
};
d38 2
a39 1
NODE *eval_tree = 0;
d41 2
a42 2
char *sourcefile;		/* current source file */
int   sourceline;		/* current line no. */
d51 5
a55 2
    EXPR_ARG,			/* newline significant, +/- may be a sign. */
    EXPR_FNAME,			/* ignore newline, +/- is a operator. */
d58 1
d61 1
a63 1
static int value_expr();
d70 4
d77 1
d81 4
d89 2
a90 1
static void backref_error();
d92 1
d95 1
a103 3
VALUE dyna_var_asgn();
VALUE dyna_var_defined();

d120 49
a168 38
%token  CLASS
	MODULE
	DEF
	UNDEF
	BEGIN
	RESCUE
	ENSURE
	END
	IF
	UNLESS
	THEN
	ELSIF
	ELSE
	CASE
	WHEN
	WHILE
	UNTIL
	FOR
	IN
	DO
	RETURN
	YIELD
	SUPER
	SELF
	NIL
	AND
	OR
	NOT
	IF_MOD
	UNLESS_MOD
	WHILE_MOD
	UNTIL_MOD
	ALIAS
	DEFINED

%token <id>   IDENTIFIER FID GVAR IVAR CONSTANT
%token <val>  INTEGER FLOAT STRING XSTRING REGEXP
%token <node> DSTRING DXSTRING DREGEXP NTH_REF BACK_REF
d172 36
a207 32
%type <node> compexpr exprs expr arg primary command_call method_call
%type <node> if_tail opt_else case_body cases rescue ensure iterator
%type <node> call_args call_args0 ret_args args mrhs opt_args var_ref
%type <node> superclass f_arglist f_args f_optarg f_opt
%type <node> array assoc_list assocs assoc undef_list
%type <node> iter_var opt_iter_var iter_block iter_do_block
%type <node> mlhs mlhs_head mlhs_tail lhs backref
%type <id>   variable symbol operation
%type <id>   cname fname op rest_arg
%type <num>  f_arg
%token UPLUS 		/* unary+ */
%token UMINUS 		/* unary- */
%token POW		/* ** */
%token CMP  		/* <=> */
%token EQ  		/* == */
%token EQQ  		/* === */
%token NEQ  		/* != <> */
%token GEQ  		/* >= */
%token LEQ  		/* <= */
%token ANDOP OROP	/* && and || */
%token MATCH NMATCH	/* =~ and !~ */
%token DOT2 DOT3	/* .. and ... */
%token AREF ASET        /* [] and []= */
%token LSHFT RSHFT      /* << and >> */
%token COLON2           /* :: */
%token <id> OP_ASGN     /* +=, -=  etc. */
%token ASSOC            /* => */
%token LPAREN           /* ( */
%token LBRACK           /* [ */
%token LBRACE           /* { */
%token STAR             /* * */
%token SYMBEG
d213 13
a225 10
%left  IF_MOD UNLESS_MOD WHILE_MOD UNTIL_MOD
%left  OR AND
%right NOT
%nonassoc DEFINED
%right '=' OP_ASGN
%nonassoc DOT2 DOT3
%left  OROP
%left  ANDOP
%nonassoc  CMP EQ EQQ NEQ MATCH NMATCH
%left  '>' GEQ '<' LEQ
d228 1
a228 1
%left  LSHFT RSHFT
d231 2
a232 2
%right '!' '~' UPLUS UMINUS
%right POW
d238 1
d242 1
a242 1
			if ((VALUE)the_class == cObject) class_nest = 0;
d245 1
a245 1
		  compexpr
d247 12
a258 1
			eval_tree = block_append(eval_tree, $2);
d262 1
d265 1
a265 3
compexpr	: exprs opt_terms

exprs		: /* none */
d267 2
a268 1
			$$ = 0;
d270 3
a272 1
		| expr
d276 1
a276 1
		| exprs terms expr
d280 1
a280 1
		| error expr
d285 2
a286 30
expr		: mlhs '=' mrhs
		    {
			value_expr($3);
			$1->nd_value = $3;
			$$ = $1;
		    }
		| assocs
		    {
			$$ = NEW_HASH($1);
		    }
		| RETURN ret_args
		    {
			value_expr($2);
			if (!cur_mid && !in_single)
			    yyerror("return appeared outside of method");
			$$ = NEW_RET($2);
		    }
		| YIELD ret_args
		    {
			value_expr($2);
			$$ = NEW_YIELD($2);
		    }
		| command_call
		| iterator iter_do_block
		    {
			$2->nd_iter = $1;
			$$ = $2;
		        fixpos($$, $2);
		    }
		| ALIAS fname {lex_state = EXPR_FNAME;} fname
d292 1
a292 1
		| ALIAS GVAR GVAR
d298 1
a298 1
		| ALIAS GVAR BACK_REF
d307 1
a307 1
		| ALIAS GVAR NTH_REF
d312 1
a312 1
		| UNDEF undef_list
d318 1
a318 1
		| expr IF_MOD expr
d322 1
d324 1
a324 1
		| expr UNLESS_MOD expr
d328 1
d330 1
a330 1
		| expr WHILE_MOD expr
d340 1
a340 1
		| expr UNTIL_MOD expr
d350 49
a398 1
		| expr AND expr
d402 1
a402 1
		| expr OR expr
d406 1
a406 1
		| NOT expr
d411 1
a411 1
		| '!' command_call	
d418 1
a418 1
command_call	: operation call_args0
d420 1
a420 1
			$$ = NEW_FCALL($1, $2);
d423 7
a429 1
		| primary '.' operation call_args0
d432 1
a432 1
			$$ = NEW_CALL($1, $3, $4);
d435 1
a435 1
		| SUPER call_args0
d437 1
a437 1
			if (!cur_mid && !in_single && !in_defined)
d443 13
a455 1
mlhs		: mlhs_head
d459 1
a459 1
		| mlhs_head STAR lhs
d463 4
d471 1
a471 1
		| mlhs_head mlhs_tail ',' STAR lhs
d475 5
a479 1
		| STAR lhs
d483 10
d494 4
a497 1
mlhs_head	: lhs ','
d499 1
a499 1
mlhs_tail	: lhs
d503 1
a503 1
		| mlhs_tail ',' lhs
d508 1
a508 1
lhs		: variable
d512 15
a526 1
		| primary '[' opt_args opt_nl ']'
d528 1
a528 1
			$$ = aryset($1, $3, 0);
d530 1
a530 1
		| primary '.' IDENTIFIER
d532 1
a532 1
			$$ = attrset($1, $3, 0);
d534 1
a534 1
		| primary '.' CONSTANT
d536 1
a536 1
			$$ = attrset($1, $3, 0);
d540 1
a540 1
		        backref_error($1);
d544 1
a544 1
cname		: IDENTIFIER
d548 1
a548 1
		| CONSTANT
d550 3
a552 3
fname		: IDENTIFIER
		| CONSTANT
		| FID
d558 5
d564 4
a567 1
undef_list	: fname
d571 1
a571 1
		| undef_list ',' {lex_state = EXPR_FNAME;} fname
d576 1
a576 1
op		: DOT2		{ $$ = DOT2; }
d580 4
a583 4
		| CMP		{ $$ = CMP; }
		| EQ		{ $$ = EQ; }
		| EQQ		{ $$ = EQQ; }
		| MATCH		{ $$ = MATCH; }
d585 1
a585 1
		| GEQ		{ $$ = GEQ; }
d587 3
a589 3
		| LEQ		{ $$ = LEQ; }
		| LSHFT		{ $$ = LSHFT; }
		| RSHFT		{ $$ = RSHFT; }
d593 1
a593 1
		| STAR		{ $$ = '*'; }
d596 1
a596 1
		| POW		{ $$ = POW; }
d598 4
a601 4
		| UPLUS		{ $$ = UMINUS; }
		| UMINUS	{ $$ = UPLUS; }
		| AREF		{ $$ = AREF; }
		| ASET		{ $$ = ASET; }
d604 9
a612 1
arg		: variable '=' arg
d615 1
a615 2
			$$ = assignable($1, $3);
		        fixpos($$, $3);
d617 1
a617 1
		| primary '[' opt_args opt_nl ']' '=' arg
d619 13
a631 2
			$$ = aryset($1, $3, $7);
		        fixpos($$, $7);
d633 1
a633 1
		| primary '.' IDENTIFIER '=' arg
d635 12
a646 2
			$$ = attrset($1, $3, $5);
		        fixpos($$, $5);
d648 1
a648 1
		| primary '.' CONSTANT '=' arg
d650 8
a657 2
			$$ = attrset($1, $3, $5);
		        fixpos($$, $5);
d659 1
a659 24
		| backref '=' arg
		    {
			value_expr($3);
		        backref_error($1);
			$$ = 0;
		    }
		| variable OP_ASGN arg
		    {
			value_expr($3);
			if (is_local_id($1)&&!local_id($1)&&dyna_in_block())
			    dyna_var_asgn($1, TRUE);
		  	$$ = assignable($1, call_op(gettable($1), $2, 1, $3));
		        fixpos($$, $3);
		    }
		| primary '[' opt_args opt_nl ']' OP_ASGN arg
		    {
			NODE *args = NEW_LIST($7);

		        list_append($3, NEW_NIL());
			list_concat(args, $3);
			$$ = NEW_OP_ASGN1($1, $6, args);
		        fixpos($$, $7);
		    }
		| primary '.' IDENTIFIER OP_ASGN arg
d661 6
d668 1
a668 1
		        fixpos($$, $5);
d670 1
a670 1
		| backref OP_ASGN arg
d672 1
a672 1
		        backref_error($1);
d675 1
a675 1
		| arg DOT2 arg
d679 1
a679 1
		| arg DOT3 arg
d703 1
a703 1
		| arg POW arg
d705 1
a705 1
			$$ = call_op($1, POW, 1, $3);
d707 1
a707 1
		| UPLUS arg
d709 6
a714 1
			$$ = call_op($2, UPLUS, 0);
d716 1
a716 1
		| UMINUS arg
d718 9
a726 1
		        $$ = call_op($2, UMINUS, 0);
d740 1
a740 1
		| arg CMP arg
d742 1
a742 1
			$$ = call_op($1, CMP, 1, $3);
d748 1
a748 1
		| arg GEQ arg
d750 1
a750 1
			$$ = call_op($1, GEQ, 1, $3);
d756 1
a756 1
		| arg LEQ arg
d758 1
a758 1
			$$ = call_op($1, LEQ, 1, $3);
d760 1
a760 1
		| arg EQ arg
d762 1
a762 1
			$$ = call_op($1, EQ, 1, $3);
d764 1
a764 1
		| arg EQQ arg
d766 1
a766 1
			$$ = call_op($1, EQQ, 1, $3);
d768 1
a768 1
		| arg NEQ arg
d770 1
a770 1
			$$ = NEW_NOT(call_op($1, EQ, 1, $3));
d772 1
a772 1
		| arg MATCH arg
d774 1
a774 2
			local_cnt('~');
			$$ = NEW_CALL($1, MATCH, NEW_LIST($3));
d776 1
a776 1
		| arg NMATCH arg
d778 1
a778 2
			local_cnt('~');
			$$ = NEW_NOT(NEW_CALL($1, MATCH, NEW_LIST($3)));
d789 1
a789 1
		| arg LSHFT arg
d791 1
a791 1
			$$ = call_op($1, LSHFT, 1, $3);
d793 1
a793 1
		| arg RSHFT arg
d795 1
a795 1
			$$ = call_op($1, RSHFT, 1, $3);
d797 1
a797 1
		| arg ANDOP arg
d801 1
a801 1
		| arg OROP arg
d805 1
a805 1
		| DEFINED opt_nl {in_defined = 1;} arg
d810 6
d821 1
a821 1
call_args	: /* none */
d823 4
a826 1
			$$ = 0;
a827 1
		| call_args0 opt_nl
d829 4
a832 2
call_args0	: args
		| command_call
d837 18
a854 1
		| assocs
d857 1
d859 6
a864 1
		| args ',' assocs
d867 1
d869 1
a869 1
		| args ',' assocs ',' STAR arg
a871 1
			$$ = call_op($$, '+', 1, $6);
d873 6
a878 1
		| args ',' STAR arg
d880 2
a881 1
			$$ = call_op($1, '+', 1, $4);
d883 3
a885 1
		| STAR arg
d888 1
a888 1
			$$ = $2;
d891 1
a891 1
opt_args	: /* none */
d893 1
a893 1
			$$ = 0;
d895 4
a898 1
		| args
d913 4
a916 1
			if ($1 && $1->nd_next == 0) {
d923 1
a923 1
		| args ',' STAR arg
d925 2
a926 1
			$$ = call_op($1, '+', 1, $4);
d928 1
a928 1
		| STAR arg
d934 1
a934 1
ret_args	: call_args0
d936 9
a944 7
			if ($1 &&
			    nd_type($1) == NODE_ARRAY &&
			    $1->nd_next == 0) {
			    $$ = $1->nd_head;
			}
			else {
			    $$ = $1;
d948 1
a948 4
array		: /* none */
		    {
			$$ = 0;
		    }
d955 1
a955 1
		| primary COLON2 cname
d957 1
d960 5
a964 1
		| STRING
d968 2
a969 2
		| DSTRING
		| XSTRING
d973 2
a974 2
		| DXSTRING
		| DREGEXP
d977 1
a977 13
		| SUPER '(' call_args ')'
		    {
			if (!cur_mid && !in_single && !in_defined)
			    yyerror("super called outside of method");
			$$ = NEW_SUPER($3);
		    }
		| SUPER
		    {
			if (!cur_mid && !in_single && !in_defined)
			    yyerror("super called outside of method");
			$$ = NEW_ZSUPER();
		    }
		| primary '[' opt_args opt_nl ']'
d980 1
a980 1
			$$ = NEW_CALL($1, AREF, $3);
d982 1
a982 1
		| LBRACK array ']'
d990 1
a990 1
		| LBRACE assoc_list '}'
d994 1
a994 1
		| RETURN '(' ret_args ')'
d996 1
a996 1
			if (!cur_mid && !in_single)
d999 1
a999 1
			$$ = NEW_RET($3);
d1001 1
a1001 1
		| RETURN '(' ')'
d1003 1
a1003 1
			if (!cur_mid && !in_single)
d1005 1
a1005 1
			$$ = NEW_RET(0);
d1007 1
a1007 1
		| RETURN
d1009 1
a1009 1
			if (!cur_mid && !in_single)
d1011 1
a1011 1
			$$ = NEW_RET(0);
d1013 1
a1013 1
		| YIELD '(' ret_args ')'
d1018 1
a1018 1
		| YIELD '(' ')'
d1022 1
a1022 1
		| YIELD
d1026 1
a1026 1
		| DEFINED opt_nl '(' {in_defined = 1;} expr ')'
d1031 1
a1031 1
		| FID
d1033 1
a1033 1
			$$ = NEW_FCALL($1, 0);
d1035 1
a1035 1
		| operation iter_block
d1041 1
a1041 1
		| method_call iter_block
d1043 3
d1050 2
a1051 2
		| IF expr then
		  compexpr
d1053 1
a1053 1
		  END
d1059 2
a1060 2
		| UNLESS expr then
		  compexpr
d1062 1
a1062 1
		  END
d1068 3
a1070 1
		| WHILE expr term compexpr END
d1072 3
a1074 3
			value_expr($2);
			$$ = NEW_WHILE(cond($2), $4, 1);
		        fixpos($$, $2);
d1076 3
a1078 1
		| UNTIL expr term compexpr END
d1080 3
a1082 3
			value_expr($2);
			$$ = NEW_UNTIL(cond($2), $4, 1);
		        fixpos($$, $2);
d1084 1
a1084 1
		| CASE compexpr
d1086 1
a1086 1
		  END
d1092 3
a1094 1
		| FOR iter_var IN expr term compexpr END
d1097 1
a1097 1
			$$ = NEW_FOR($2, $4, $6);
d1100 2
a1101 2
		| BEGIN
		  compexpr
d1103 1
d1105 1
a1105 1
		  END
d1107 1
a1107 1
			if (!$3 && !$4)
d1110 6
a1115 2
			    if ($3) $2 = NEW_RESCUE($2, $3); 
			    if ($4) $2 = NEW_ENSURE($2, $4);
d1120 1
a1120 1
		| LPAREN compexpr ')'
d1124 1
a1124 1
		| CLASS cname superclass
d1133 2
a1134 2
		  compexpr
		  END
d1142 1
a1142 1
		| CLASS LSHFT expr term
a1143 3
			if (cur_mid || in_single)
			    yyerror("class definition in method body");

d1148 2
a1149 2
		  compexpr
		  END
d1157 1
a1157 1
		| MODULE cname
d1165 2
a1166 2
		  compexpr
		  END
d1174 1
a1174 1
		| DEF fname
d1182 2
a1183 2
		  compexpr
		  END
d1185 1
d1191 1
a1191 1
		| DEF singleton '.' {lex_state = EXPR_FNAME;} fname
d1199 2
a1200 2
		  compexpr
		  END
d1207 16
d1225 5
a1229 2
		| THEN
		| term THEN
d1232 2
a1233 2
		| ELSIF expr then
		  compexpr
d1241 2
a1242 5
opt_else	: /* none */
		    {
			$$ = 0;
		    }
		| ELSE compexpr
d1247 1
a1247 1
iter_var	: lhs
d1250 2
a1251 1
opt_iter_var	: /* node */
d1255 1
a1255 1
		| '|' /* none */  '|'
d1259 6
a1264 1
		| OROP
d1266 1
a1266 1
			$$ = 0;
d1268 3
a1270 1
		| '|' iter_var '|'
d1272 3
a1274 1
			$$ = $2;
d1277 1
a1277 1
iter_do_block	: DO
d1281 2
a1282 3
		  opt_iter_var
		  compexpr
		  END
d1288 1
a1288 2

iter_block	: '{' 
d1292 3
a1294 2
		  opt_iter_var
		  compexpr '}'
d1301 2
a1302 1
iterator	: IDENTIFIER
d1304 1
a1304 1
			$$ = NEW_FCALL($1, 0);
d1306 1
a1306 1
		| CONSTANT
d1308 1
a1308 1
			$$ = NEW_FCALL($1, 0);
d1310 1
a1310 1
		| FID
d1312 1
a1312 1
			$$ = NEW_FCALL($1, 0);
d1317 1
a1317 1
method_call	: operation '(' call_args ')'
d1319 11
a1329 1
			$$ = NEW_FCALL($1, $3);
d1332 1
a1332 1
		| primary '.' operation '(' call_args ')'
d1335 1
a1335 1
			$$ = NEW_CALL($1, $3, $5);
d1338 1
a1338 1
		| primary '.' operation
d1341 2
a1342 1
			$$ = NEW_CALL($1, $3, 0);
d1344 1
a1344 1
		| primary COLON2 operation '(' call_args ')'
d1347 1
a1347 1
			$$ = NEW_CALL($1, $3, $5);
d1350 1
a1350 4

case_body	: WHEN args then
		  compexpr
		  cases
d1352 2
a1353 1
			$$ = NEW_WHEN($2, $4, $5);
d1355 1
a1355 6

cases		: opt_else
		| case_body

rescue		: RESCUE opt_args term compexpr
		  rescue	
d1357 4
a1360 2
			$$ = NEW_RESBODY($2, $4, $5);
		        fixpos($$, $2?$2:$4);
d1362 1
a1362 1
		| /* none */
d1364 4
a1367 1
			$$ = 0;
d1370 1
a1370 1
ensure		: /* none */
d1372 2
a1373 1
			$$ = 0;
d1375 7
a1381 1
		| ENSURE compexpr
d1383 1
a1383 1
			$$ = $2;
d1386 7
a1392 2
literal		: numeric
		| SYMBEG {lex_state = EXPR_FNAME;} symbol
d1394 2
a1395 1
			$$ = INT2FIX($3);
a1396 1
		| REGEXP
d1398 11
a1408 3
symbol		: fname
		| IVAR
		| GVAR
d1410 5
a1414 2
numeric		: INTEGER
		| FLOAT
d1416 2
a1417 5
variable	: IDENTIFIER
		| IVAR
		| GVAR
		| CONSTANT
		| NIL
d1419 1
a1419 1
			$$ = NIL;
d1421 3
a1423 1
		| SELF
d1425 2
a1426 1
			$$ = SELF;
d1429 19
d1453 2
a1454 2
backref		: NTH_REF
		| BACK_REF
d1468 1
a1468 1
		| error term {yyerrok;}
d1470 1
a1470 1
f_arglist	: '(' f_args ')'
d1480 5
a1484 1
f_args		: /* no arg */
d1486 1
a1486 1
			$$ = NEW_ARGS(0, 0, -1);
d1488 1
a1488 1
		| f_arg
d1490 1
a1490 1
			$$ = NEW_ARGS($1, 0, -1);
d1492 1
a1492 1
		| f_arg ',' rest_arg
d1494 1
a1494 1
			$$ = NEW_ARGS($1, 0, $3);
d1496 1
a1496 1
		| f_arg ',' f_optarg
d1498 1
a1498 1
			$$ = NEW_ARGS($1, $3, -1);
d1500 1
a1500 1
		| f_arg ',' f_optarg ',' rest_arg
d1502 1
a1502 1
			$$ = NEW_ARGS($1, $3, $5);
d1504 1
a1504 1
		| f_optarg
d1506 1
a1506 1
			$$ = NEW_ARGS(0, $1, -1);
d1508 1
a1508 1
		| f_optarg ',' rest_arg
d1510 1
a1510 1
			$$ = NEW_ARGS(0, $1, $3);
d1512 1
a1512 1
		| rest_arg
d1514 1
a1514 1
			$$ = NEW_ARGS(0, 0, $1);
d1517 1
a1517 1
f_arg		: IDENTIFIER
d1521 2
d1526 3
a1528 1
		| f_arg ',' IDENTIFIER
a1529 3
			if (!is_local_id($3))
			    yyerror("formal argument must be local variable");
			local_cnt($3);
d1533 1
a1533 1
f_opt		: IDENTIFIER '=' arg
d1537 2
d1552 1
a1552 1
rest_arg	: STAR IDENTIFIER
d1556 2
d1560 15
d1589 1
a1589 1
		| LPAREN expr opt_nl ')'
d1591 1
a1591 1
			switch (nd_type($2)) {
d1600 1
a1600 1
			    yyerror("Can't define single method for literals.");
d1604 1
a1604 1
			$$ = $2;
d1607 1
a1607 4
assoc_list	: /* none */
		    {
			$$ = 0;
		    }
d1626 1
a1626 1
assoc		: arg ASSOC arg
d1631 15
a1645 3
operation	: IDENTIFIER
		| CONSTANT
		| FID
d1662 5
d1672 3
d1676 1
a1676 1
#define is_identchar(c) ((c)!=-1&&(isalnum(c) || (c) == '_' || ismbchar(c)))
d1681 1
a1681 7
VALUE newregexp();
VALUE newstring();
VALUE newfloat();
VALUE newinteger();
char *strdup();

static NODE *str_extend();
d1685 1
d1687 1
d1699 1
a1699 1
    Error("%s", msg);
d1718 1
a1718 1
	Error_Append("%s", buf);
d1729 1
a1729 1
	Error_Append("%s", buf);
d1735 1
a1735 1
static int newline_seen;
d1737 2
a1738 1
int rb_in_compile = 0;
d1746 5
a1750 4
    newline_seen = 0;
    sourcefile = strdup(f);
    eval_tree = 0;
    rb_in_compile = 1;
d1752 7
a1758 2
    rb_in_compile = 0;
    if (n == 0) return eval_tree;
d1763 22
d1786 11
a1796 9
compile_string(f, s, len)
    char *f, *s;
    int len;
{
    lex_pbeg = lex_p = s;
    lex_pend = s + len;
    lex_input = 0;
    if (!sourcefile || strcmp(f, sourcefile))	/* not in eval() */
	sourceline = 1;
d1802 10
a1811 2
compile_file(f, file, start)
    char *f;
d1815 1
d1818 1
a1818 1
    sourceline = start;
d1820 1
a1820 1
    return yycompile(f);
d1823 3
d1833 1
a1833 1
	    VALUE v = io_gets(lex_input);
d1836 5
d1843 6
d1851 1
d1860 1
a1860 1
void
d1868 2
d1883 1
a1883 1
    if (toksiz > 1024) {
d1947 1
a1947 1
	    c = scan_oct(buf, i+1, &i);
d1957 5
a1961 3
		buf[i] = nextc();
		if (buf[i] == -1) goto eof;
		if (!isxdigit(buf[i])) {
d1966 1
a1966 1
	    c = scan_hex(buf, i+1, &i);
d1971 4
a1974 1
	return '\b';
a1996 1
      case '^':
d2016 2
a2017 2
parse_regx(term)
    int term;
d2022 2
a2023 1
    int casefold = 0;
d2025 1
a2025 1
    int re_start = sourceline;
d2030 1
a2030 1
	if (!in_brack && c == term) {
d2043 1
a2043 1
	    list = str_extend(list, term);
d2045 1
a2045 1
		continue;
d2050 2
a2051 2
		sourceline = re_start;
		Error("unterminated regexp meets end of file");
a2054 1
		sourceline++;
d2058 2
d2061 1
a2061 1
		tokadd('\\');
a2071 5
	      case '^':		/* no \^ escape in regexp */
		tokadd('\\');
		tokadd('^');
		break;

d2080 1
a2080 4
		if (c == '\n') {
		    sourceline++;
		}
		else if (c == term) {
a2083 1
		    pushback(c);
d2085 1
a2085 1
		    tokadd(read_escape());
d2091 1
a2091 1
	    Error("unterminated regexp");
d2095 4
d2100 6
a2105 2
		tokadd(c);
		c = nextc();
d2113 7
a2119 1
		    casefold = 1;
d2125 1
a2125 1
		    kcode = 2;
d2128 1
a2128 1
		    kcode = 4;
d2131 4
a2134 1
		    kcode = 6;
d2146 1
d2148 1
a2148 1
		    VALUE ss = str_new(tok(), toklen());
d2152 1
a2152 1
		list->nd_cflag = kcode | casefold;
d2154 1
a2154 1
		return DREGEXP;
d2157 2
a2158 2
		yylval.val = reg_new(tok(), toklen(), kcode | casefold);
		return REGEXP;
d2163 1
a2163 1
    Error("unterminated regexp");
d2167 2
d2170 2
a2171 2
parse_string(func,term)
    int func, term;
d2176 1
d2178 10
a2187 1
    strstart = sourceline;
d2189 2
a2190 4

    while ((c = nextc()) != term) {
      str_retry:
	if (c  == -1) {
d2192 2
a2193 2
	    sourceline = strstart;
	    Error("unterminated string meets end of file");
d2197 6
a2202 5
	    tokadd(c);
	    c = nextc();
	}
	else if (c == '\n') {
	    sourceline++;
d2205 1
a2205 1
	    list = str_extend(list, term);
d2211 3
a2213 4
	    if (c == '\n') {
		sourceline++;
	    }
	    else if (c == term) {
d2223 4
d2232 1
d2234 1
d2236 1
a2236 1
	    VALUE ss = str_new(tok(), toklen());
d2242 1
a2242 1
	    return DXSTRING;
d2245 1
a2245 1
	    return DSTRING;
d2249 2
a2250 2
	yylval.val = str_new(tok(), toklen());
	return (func == '`') ? XSTRING : STRING;
d2255 2
a2256 2
parse_qstring(term)
    int term;
d2260 1
d2262 1
a2262 1
    strstart = sourceline;
d2264 4
a2267 4
    while ((c = nextc()) != term) {
	if (c  == -1)  {
	    sourceline = strstart;
	    Error("unterminated string meets end of file");
d2271 6
a2276 5
	    tokadd(c);
	    c = nextc();
	}
	else if (c == '\n') {
	    sourceline++;
a2281 1
		sourceline++;
d2298 4
d2306 1
a2306 1
    yylval.val = str_new(tok(), toklen());
d2308 10
a2317 1
    return STRING;
d2320 136
a2455 1
#define LAST(v) ((v)-1 + sizeof(v)/sizeof(v[0]))
d2457 1
a2457 37
static struct kwtable {
    char *name;
    int id;
    enum lex_state state;
} kwtable [] = {
    "__END__",  0,              EXPR_BEG,
    "alias",	ALIAS,		EXPR_FNAME,
    "and",	AND,		EXPR_BEG,
    "begin",	BEGIN,		EXPR_BEG,
    "case",	CASE,		EXPR_BEG,
    "class",	CLASS,		EXPR_BEG,
    "def",	DEF,		EXPR_FNAME,
    "defined?",	DEFINED,	EXPR_END,
    "do",	DO,		EXPR_BEG,
    "else",	ELSE,		EXPR_BEG,
    "elsif",	ELSIF,		EXPR_BEG,
    "end",	END,		EXPR_END,
    "ensure",	ENSURE,		EXPR_BEG,
    "for", 	FOR,		EXPR_BEG,
    "if",	IF,		EXPR_BEG,
    "in",	IN,		EXPR_BEG,
    "module",	MODULE,		EXPR_BEG,
    "nil",	NIL,		EXPR_END,
    "not",	NOT,		EXPR_BEG,
    "or",	OR,		EXPR_BEG,
    "rescue",	RESCUE,		EXPR_MID,
    "return",	RETURN,		EXPR_MID,
    "self",	SELF,		EXPR_END,
    "super",	SUPER,		EXPR_END,
    "then",     THEN,           EXPR_BEG,
    "undef",	UNDEF,		EXPR_FNAME,
    "unless",	UNLESS,		EXPR_BEG,
    "until",	UNTIL,		EXPR_BEG,
    "when",	WHEN,		EXPR_BEG,
    "while",	WHILE,		EXPR_BEG,
    "yield",	YIELD,		EXPR_END,
};
d2462 1
a2462 1
    Warning("ambiguous first argument; make sure");
d2465 2
a2466 2
#ifndef atof
double atof();
d2474 1
a2474 6
    struct kwtable *low = kwtable, *mid, *high = LAST(kwtable);

    if (newline_seen) {
	sourceline+=newline_seen;
	newline_seen = 0;
    }
d2476 1
a2476 1
retry:
a2493 9
	    if (c == '\\') { /* skip a char */
		c = nextc();
		if (c == '\n') sourceline++;
	    }
	    if (ismbchar(c)) {
		c = nextc();
		if (c == '\n')
		    break;
	    }
d2497 4
a2500 23
	/* skip embedded rd document */
	if ((c = nextc()) == '=' &&
	    strncmp(lex_p, "begin", 5) == 0 &&
	    (lex_p[5] == '\n' || lex_p[5] == '\r')) {
	    for (;;) {
		if (c == -1) return 0;
		c = nextc();
		if (c != '\n') continue;
		c = nextc();
		if (c != '=') continue;
		if (strncmp(lex_p, "end", 3) == 0 &&
		    (lex_p[3] == '\n' || lex_p[3] == '\r')) {
		    lex_p += 3;	/* sizeof "end" */
		    break;
		}
	    }
	}
	else {
	    pushback(c);
	}
	
	if (lex_state == EXPR_BEG || lex_state == EXPR_FNAME) {
	    sourceline++;
d2502 2
a2504 1
	newline_seen++;
d2512 2
a2513 2
		yylval.id = POW;
		return OP_ASGN;
d2516 1
a2516 1
	    return POW;
d2521 1
a2521 1
	    return OP_ASGN;
d2524 1
a2524 2
	if (lex_state == EXPR_ARG && space_seen && !isspace(c)){
	    arg_ambiguous();
d2526 1
a2526 1
	    return STAR;
d2529 2
a2530 1
	    return STAR;
d2538 1
a2538 1
	    return NEQ;
d2541 1
a2541 1
	    return NMATCH;
d2549 1
a2549 2
	    if (strncmp(lex_p, "begin", 5) == 0 && isspace(lex_p[5])) {
		lex_p = lex_pend;
d2551 1
a2551 3
		    if (c == -1) return 0;
		    c = nextc();
		    if (c != '\n') continue;
d2553 4
d2558 1
a2558 2
		    if (strncmp(lex_p, "end", 3) == 0 && isspace(lex_p[3])) {
			lex_p = lex_pend;
d2562 1
d2570 1
a2570 1
		return EQQ;
d2573 1
a2573 1
	    return EQ;
d2576 1
a2576 1
	    return MATCH;
d2579 1
a2579 1
	    return ASSOC;
d2585 16
d2602 1
a2602 1
	if ((c = nextc()) == '=') {
d2604 1
a2604 1
		return CMP;
d2607 1
a2607 1
	    return LEQ;
d2611 2
a2612 2
		yylval.id = LSHFT;
		return OP_ASGN;
d2615 1
a2615 1
	    return LSHFT;
d2623 1
a2623 1
	    return GEQ;
d2627 2
a2628 2
		yylval.id = RSHFT;
		return OP_ASGN;
d2631 1
a2631 1
	    return RSHFT;
d2637 1
a2637 1
	return parse_string(c,c);
d2640 2
a2641 1
	return parse_string(c,c);
d2644 1
a2644 1
	return parse_qstring(c);
d2647 11
a2657 1
	if ((c = nextc()) == '\\') {
d2663 1
a2663 1
	return INTEGER;
a2665 1
	lex_state = EXPR_BEG;
d2667 7
a2673 1
	    return ANDOP;
d2677 2
a2678 1
	    return OP_ASGN;
d2681 9
d2695 6
a2700 1
	    return OROP;
d2704 1
a2704 1
	    return OP_ASGN;
d2711 1
a2711 1
	if (lex_state == EXPR_FNAME) {
d2713 1
a2713 1
		return UPLUS;
d2721 1
a2721 1
	    return OP_ASGN;
d2723 2
a2724 12
	if (lex_state == EXPR_ARG) {
	    if (space_seen && !isspace(c)) {
		arg_ambiguous();
	    }
	    else {
		lex_state = EXPR_END;
	    }
	}
	if (lex_state != EXPR_END) {
 	    if (isdigit(c)) {
		goto start_num;
	    }
d2727 1
a2727 1
	    return UPLUS;
d2735 1
a2735 1
	if (lex_state == EXPR_FNAME) {
d2737 1
a2737 1
		return UMINUS;
d2745 1
a2745 9
	    return OP_ASGN;
	}
	if (lex_state == EXPR_ARG) {
	    if (space_seen && !isspace(c)) {
		arg_ambiguous();
	    }
	    else {
		lex_state = EXPR_END;
	    }
d2747 2
a2748 6
	if (lex_state != EXPR_END) {
	    if (isdigit(c)) {
		pushback(c);
		c = '-';
		goto start_num;
	    }
d2751 1
a2751 1
	    return UMINUS;
d2761 1
a2761 1
		return DOT3;
d2764 1
a2764 1
	    return DOT2;
d2767 2
a2768 1
	if (!isdigit(c)) {
d2791 5
a2795 1
		    while (c = nextc()) {
d2797 1
a2797 1
			if (!isxdigit(c)) break;
d2799 11
d2811 5
d2818 2
a2819 2
		    yylval.val = str2inum(tok(), 16);
		    return INTEGER;
d2821 1
a2821 1
		else if (c >= '0' && c <= '7') {
d2823 3
a2825 1
		    do {
d2827 1
a2827 3
			while ((c = nextc()) == '_')
			    ;
		    } while (c >= '0' && c <= '9');
d2830 2
a2831 2
		    yylval.val = str2inum(tok(), 8);
		    return INTEGER;
d2833 2
a2834 2
		else if (c > '7' && c <= '9') {
		    Error("Illegal octal digit");
d2842 1
a2842 1
		    return INTEGER;
d2854 1
a2854 1
		    if (seen_point) {
d2859 1
a2859 1
			if (!isdigit(c0)) {
d2898 7
a2904 2
		yylval.val = float_new(atof(tok()));
		return FLOAT;
d2906 2
a2907 2
	    yylval.val = str2inum(tok(), 10);
	    return INTEGER;
d2919 10
a2928 2
	    lex_state = EXPR_BEG;
	    return COLON2;
d2931 2
a2932 1
	if (isspace(c))
d2934 3
a2936 1
	return SYMBEG;
d2940 1
a2940 1
	    return parse_regx('/');
d2945 1
a2945 1
	    return OP_ASGN;
d2948 1
a2948 1
	    if (space_seen && !isspace(c)) {
d2951 1
a2951 1
		return parse_regx('/');
d2962 1
a2962 1
	    return OP_ASGN;
a2967 3
	lex_state = EXPR_BEG;
	return c;

d2973 1
a2973 1
	if (lex_state == EXPR_FNAME) {
d2983 1
a2983 6
	    c = LPAREN;
	    lex_state = EXPR_BEG;
	}
	else if (lex_state == EXPR_ARG && space_seen) {
	    arg_ambiguous();
	    c = LPAREN;
d2992 1
a2992 1
	if (lex_state == EXPR_FNAME) {
d2995 1
a2995 1
		    return ASET;
d2998 1
a2998 1
		return AREF;
d3004 1
a3004 1
	    c = LBRACK;
d3007 1
a3007 2
	    arg_ambiguous();
	    c = LBRACK;
d3013 4
a3016 2
	if (lex_state != EXPR_END && lex_state != EXPR_ARG)
	    c = LBRACE;
d3022 4
a3026 1
	    sourceline++;
d3036 1
d3040 1
a3040 1
	    if (!isalnum(c)) {
d3042 1
a3042 10
		switch (c) {
		  case '\'':
		    c = 'q'; break;
		  case '/':
		    c = 'r'; break;
		  case '`':
		    c = 'x'; break;
		  default:
		    c = 'Q';break;
		}
d3048 1
a3048 1
		Error("unterminated quoted string meets end of file");
d3051 1
d3056 1
d3060 1
a3060 1
		return parse_string('"', term);
d3063 4
a3066 1
		return parse_qstring(term);
d3069 1
a3069 1
		return parse_string('`', term);
d3072 1
a3072 1
		return parse_regx(term);
d3075 1
a3075 1
		Error("unknown type of string `%c'", c);
d3081 1
a3081 1
	    return OP_ASGN;
d3083 2
a3084 5
	if (lex_state == EXPR_ARG) {
	    if (space_seen && !isspace(c)) {
		arg_ambiguous();
		goto quotation;
	    }
d3095 2
a3097 1
	  case '~':		/* $~: match-data */
d3119 1
a3119 1
	    return GVAR;
d3128 1
a3128 1
	    return GVAR;
d3135 1
a3135 1
	    return BACK_REF;
d3140 1
a3140 1
	    while (isdigit(c)) {
d3147 1
a3147 1
	    return NTH_REF;
d3170 2
a3171 2
	if (c != '_' && !isalpha(c) && !ismbchar(c)) {
	    Error("Invalid char '%c' in expression", c);
d3182 6
a3187 2
	    c = nextc();
	    tokadd(c);
d3191 1
a3191 1
    if (c == '!' || c == '?') {
d3205 1
a3205 1
	    result = GVAR;
d3209 1
a3209 1
	    result = IVAR;
d3212 4
a3215 4
	    /* See if it is a reserved word.  */
	    while (low <= high) {
		mid = low + (high - low)/2;
		if ((c = strcmp(mid->name, tok())) == 0) {
d3217 3
a3219 6
		    lex_state = mid->state;
		    if (state != EXPR_BEG) {
			if (mid->id == IF) return IF_MOD;
			if (mid->id == UNLESS) return UNLESS_MOD;
			if (mid->id == WHILE) return WHILE_MOD;
			if (mid->id == UNTIL) return UNTIL_MOD;
d3221 4
a3224 7
		    return mid->id;
		}
		else if (c < 0) {
		    low = mid + 1;
		}
		else {
		    high = mid - 1;
d3228 14
a3241 7
	    if (lex_state == EXPR_FNAME) {
		lex_state = EXPR_END;
		if ((c = nextc()) == '=') {
		    tokadd(c);
		}
		else {
		    pushback(c);
d3244 3
a3246 1
	    else if (lex_state == EXPR_BEG){
a3251 8
	    if (isupper(tok()[0])) {
		result = CONSTANT;
	    }
	    else if (toklast() == '!' || toklast() == '?') {
		result = FID;
	    } else {
		result = IDENTIFIER;
	    }
d3260 1
a3260 1
str_extend(list, term)
d3265 1
d3282 1
a3282 1
    ss = str_new(tok(), toklen());
d3300 1
a3300 1
	    while (isdigit(c)) {
d3319 1
a3319 1
		list_append(list, NEW_STR(str_new2("#$")));
a3336 1
	/* through */
d3338 16
a3353 1
      case '@@':	
d3359 6
a3364 2
		c = nextc();
		tokadd(c);
d3372 1
d3380 1
a3380 1
		    Error("bad substitution in string");
d3386 4
a3389 2
		if (nest == 0) break;
		nest--;
d3397 1
a3397 1
		nest++;
d3403 2
a3404 2
		    list_append(list, NEW_STR(str_new2("#")));
		    Warning("bad substitution in string");
d3406 1
a3406 1
		    list_append(list, NEW_STR(str_new(tok(), toklen())));
d3414 1
a3414 1
	} while (c != '}');
d3427 1
a3427 1
node_newnode(type, a0, a1, a2)
d3435 2
a3436 2
    nd_set_line(n, sourceline);
    n->file = sourcefile;
d3445 1
a3445 1
enum node_type
d3452 1
a3452 1
int
d3478 1
a3478 1
    node->file = orig->file;
a3485 1
    extern int verbose;
d3501 1
a3501 1
    if (verbose) {
d3506 5
a3510 1
	    Warning("statement not reached");
d3543 1
a3543 1
    
d3582 32
d3617 1
a3617 1
    if (id == SELF) {
d3620 1
a3620 1
    else if (id == NIL) {
d3623 12
d3636 1
a3637 1
	if (dyna_var_defined(id)) return NEW_DVAR(id);
d3650 1
a3650 1
    Bug("invalid id for gettable");
d3661 2
a3662 1
    if (id == SELF) {
d3665 1
a3665 1
    else if (id == NIL) {
d3668 12
d3681 4
a3684 1
	if (local_id(id) || !dyna_in_block()) {
d3688 2
a3689 2
	    dyna_var_asgn(id, TRUE);
	    lhs = NEW_DASGN(id, val);
d3704 1
a3704 1
	Bug("bad id for variable");
d3710 2
a3711 2
aryset(recv, idx, val)
    NODE *recv, *idx, *val;
d3714 2
a3715 2
    value_expr(val);
    return NEW_CALL(recv, ASET, list_append(idx, val));
d3719 1
a3719 1
id_attrset(id)
d3728 2
a3729 2
attrset(recv, id, val)
    NODE *recv, *val;
a3732 4
    value_expr(val);
 
    id &= ~ID_SCOPE_MASK;
    id |= ID_ATTRSET;
d3734 1
a3734 1
    return NEW_CALL(recv, id, NEW_LIST(val));
d3738 1
a3738 1
backref_error(node)
d3743 1
a3743 1
	Error("Can't set variable $%d", node->nd_nth);
d3746 1
a3746 1
	Error("Can't set variable $%c", node->nd_nth);
d3751 53
d3808 1
a3808 1
    if (node == 0) return TRUE;
d3812 4
d3823 1
a3823 1
	return FALSE;
d3839 115
a3953 1
	return TRUE;
d3959 45
d4010 1
d4016 1
a4016 1
	return call_op(NEW_GVAR(rb_intern("$_")),MATCH,1,node);
d4024 1
d4033 5
d4047 2
a4048 12
    enum node_type type = nd_type(node);

    switch (type) {
      case NODE_MASGN:
      case NODE_LASGN:
      case NODE_DASGN:
      case NODE_GASGN:
      case NODE_IASGN:
      case NODE_CASGN:
	Warning("assignment in condition");
	break;
      case NODE_NEWLINE:
a4050 2
      default:
        break;
a4051 1

d4065 1
a4065 1
	return call_op(node,EQ,1,NEW_GVAR(rb_intern("$.")));
d4076 14
d4091 11
a4101 1
    return node_newnode(type, cond(left), cond(right));
d4104 11
a4114 1
st_table *new_idhash();
d4141 1
a4141 1
    struct local_vars *local = lvtbl;
d4143 3
a4145 4
    lvtbl = local->prev;
    if (local->tbl) {
	local->tbl[0] = local->cnt;
	if (!local->nofree) free(local->tbl);
d4147 2
a4148 1
    free(local);
d4159 1
a4159 1
local_cnt(id)
a4161 9
    int cnt, max;

    if (id == 0) return lvtbl->cnt;

    for (cnt=1, max=lvtbl->cnt+1; cnt<max ;cnt++) {
	if (lvtbl->tbl[cnt] == id) return cnt-1;
    }

    
d4163 1
a4163 1
	lvtbl->tbl = ALLOC_N(ID, 2);
d4165 5
d4180 14
d4199 3
a4201 3
    if (lvtbl == 0) return FALSE;
    for (i=1, max=lvtbl->cnt+1; i<max; i++) {
	if (lvtbl->tbl[i] == id) return TRUE;
d4203 1
a4203 1
    return FALSE;
d4210 1
a4210 1
    lvtbl->cnt = the_scope->local_tbl?the_scope->local_tbl[0]:0;
d4212 2
a4213 2
	lvtbl->tbl = ALLOC_N(ID, lvtbl->cnt+1);
	MEMCPY(lvtbl->tbl, the_scope->local_tbl, ID, lvtbl->cnt+1);
d4218 1
a4218 1
    if (the_dyna_vars && the_dyna_vars->id)
d4231 1
a4231 1
	i = lvtbl->tbl[0];
d4234 1
a4234 1
	    if (i == 0 || the_scope->flag == SCOPE_ALLOCA) {
d4236 4
a4239 4
		if (the_scope->local_vars) {
		    *vars++ = the_scope->local_vars[-1];
		    MEMCPY(vars, the_scope->local_vars, VALUE, i);
		    memclear(vars+i, len-i);
d4243 1
a4243 1
		    memclear(vars, len);
d4245 2
a4246 2
		the_scope->local_vars = vars;
		the_scope->flag |= SCOPE_MALLOC;
d4249 1
a4249 1
		VALUE *vars = the_scope->local_vars-1;
d4251 5
a4255 2
		the_scope->local_vars = vars+1;
		memclear(the_scope->local_vars+i, len-i);
d4257 2
a4258 7
	    lvtbl->tbl[0] = len;
	    if (the_scope->local_tbl && the_scope->local_vars[-1] == 0) {
		free(the_scope->local_tbl);
	    }
	    the_scope->local_vars[-1] = 0;
	    the_scope->local_tbl = lvtbl->tbl;
	    lvtbl->nofree = 1;
d4268 1
a4268 1
    return the_dyna_vars;
d4276 1
a4276 1
    the_dyna_vars = vars;
d4292 1
a4292 1
yyappend_print()
d4294 4
a4297 3
    eval_tree =
	block_append(eval_tree, NEW_FCALL(rb_intern("print"),
					  NEW_ARRAY(NEW_GVAR(rb_intern("$_")))));
d4301 1
a4301 1
yywhile_loop(chop, split)
d4305 1
a4305 1
	eval_tree =
d4309 1
a4309 1
				   eval_tree);
d4312 1
a4312 1
	eval_tree =
d4314 1
a4314 1
				  rb_intern("chop!"), 0), eval_tree);
d4316 1
a4316 1
    eval_tree = NEW_OPT_N(eval_tree);
d4319 6
a4324 2
static struct op_tbl rb_op_tbl[] = {
    DOT2,	"..",
d4332 5
a4336 5
    POW,	"**",
    UPLUS,	"+@@",
    UMINUS,	"-@@",
    UPLUS,	"+(unary)",
    UMINUS,	"-(unary)",
d4340 1
a4340 1
    CMP,	"<=>",
d4342 1
a4342 1
    GEQ,	">=",
d4344 6
a4349 6
    LEQ,	"<=",
    EQ,		"==",
    EQQ,	"===",
    NEQ,	"!=",
    MATCH,	"=~",
    NMATCH,	"!~",
d4356 6
a4361 5
    AREF,	"[]",
    ASET,	"[]=",
    LSHFT,	"<<",
    RSHFT,	">>",
    COLON2,	"::",
d4366 2
a4367 6
char *rb_id2name();
char *rb_class2name();

st_table *rb_symbol_tbl;

#define sym_tbl rb_symbol_tbl
d4372 4
a4375 4
    int strcmp();

    sym_tbl = st_init_strtable();
    rb_global_variable(&cur_cref);
d4380 1
a4380 1
    char *name;
d4389 1
a4389 2
    id = ++last_id;
    id <<= ID_SCOPE_SHIFT;
a4396 1
	/* fall through */
d4398 1
a4398 1
	if (name[0] != '_' && !isalpha(name[0]) && !ismbchar(name[0])) {
d4402 5
a4406 5
	    id = 0;
	    for (i=0; rb_op_tbl[i].token; i++) {
		if (strcmp(rb_op_tbl[i].name, name) == 0) {
		    id = rb_op_tbl[i].token;
		    break;
a4408 2
	    if (id == 0) NameError("Unknown operator `%s'", name);
	    break;
d4410 1
a4410 1
	
d4419 4
a4422 1
	    id &= ~ID_SCOPE_MASK;
d4425 2
a4426 2
	else if (isupper(name[0])) {
	    id |= ID_CONST;
d4429 1
a4429 1
	    id |= ID_LOCAL;
d4433 5
a4437 1
    st_add_direct(sym_tbl, strdup(name), id);
a4440 18
struct find_ok {
    ID id;
    char *name;
};

static int
id_find(name, id1, ok)
    char *name;
    ID id1;
    struct find_ok *ok;
{
    if (id1 == ok->id) {
	ok->name = name;
	return ST_STOP;
    }
    return ST_CONTINUE;
}

d4445 1
a4445 1
    struct find_ok ok;
d4450 3
a4452 3
	for (i=0; rb_op_tbl[i].token; i++) {
	    if (rb_op_tbl[i].token == id)
		return rb_op_tbl[i].name;
d4456 4
a4459 4
    ok.name = 0;
    ok.id = id;
    st_foreach(sym_tbl, id_find, &ok);
    if (!ok.name && is_attrset_id(id)) {
d4461 1
a4461 1
	ID id2; 
d4467 1
a4467 1
	    char *buf = ALLOCA_N(char,strlen(res)+2);
d4475 1
a4475 1
    return ok.name;
d4482 2
a4483 2
    if (is_const_id(id)) return TRUE;
    return FALSE;
d4490 2
a4491 34
    if (is_instance_id(id)) return TRUE;
    return FALSE;
}

void
local_var_append(id)
    ID id;
{
    struct local_vars tmp;
    struct local_vars *save = lvtbl;

    if (the_scope->local_tbl) {
	tmp.cnt = the_scope->local_tbl[0];
	tmp.tbl = the_scope->local_tbl;
	lvtbl->dlev = 0;
    }
    lvtbl = &tmp;
    local_cnt(id);
    lvtbl = save;
}

static VALUE
special_local_get(c)
    char c;
{
    int cnt, max;

    if (!the_scope->local_vars) return Qnil;
    for (cnt=1, max=the_scope->local_tbl[0]+1; cnt<max ;cnt++) {
	if (the_scope->local_tbl[cnt] == c) {
	    return the_scope->local_vars[cnt-1];
	}
    }
    return Qnil;
d4499 1
a4499 1
    int cnt, max;
a4500 8
    if (the_scope->local_tbl) {
	for (cnt=1, max=the_scope->local_tbl[0]+1; cnt<max ;cnt++) {
	    if (the_scope->local_tbl[cnt] == c) {
		the_scope->local_vars[cnt-1] = val;
		return;
	    }
	}
    }
d4504 1
a4504 1
    the_scope->local_vars[cnt] = val;
d4508 1
a4508 1
backref_get()
d4510 4
a4513 1
    return special_local_get('~');
d4517 1
a4517 1
backref_set(val)
d4520 6
a4525 1
    special_local_set('~', val);
d4529 1
a4529 1
lastline_get()
d4531 4
a4534 3
    VALUE v = special_local_get('_');
    if (v == 1) return Qnil;	/* $_ undefined */
    return v;
d4538 1
a4538 1
lastline_set(val)
d4541 6
a4546 1
    special_local_set('_', val);
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@a46 1
NODE *eval_tree0 = 0;
a60 1
    EXPR_CLASS,			/* immediate after `class' no here document. */
a76 1
static NODE *arg_add();
a85 1
static NODE *match_gen();
d115 34
a148 42
%token  kCLASS
	kMODULE
	kDEF
	kUNDEF
	kBEGIN
	kRESCUE
	kENSURE
	kEND
	kIF
	kUNLESS
	kTHEN
	kELSIF
	kELSE
	kCASE
	kWHEN
	kWHILE
	kUNTIL
	kFOR
	kBREAK
	kNEXT
	kREDO
	kRETRY
	kIN
	kDO
	kRETURN
	kYIELD
	kSUPER
	kSELF
	kNIL
	kTRUE
	kFALSE
	kAND
	kOR
	kNOT
	kIF_MOD
	kUNLESS_MOD
	kWHILE_MOD
	kUNTIL_MOD
	kALIAS
	kDEFINED
	klBEGIN
	klEND
d156 1
a156 1
%type <node> compstmt stmts stmt expr arg primary command_call method_call
d158 1
a158 1
%type <node> call_args call_args0 ret_args args mrhs opt_list var_ref
d163 1
a163 1
%type <id>   variable symbol operation assoc_kw
d166 2
a167 2
%token oUPLUS 		/* unary+ */
%token MINUS 		/* unary- */
a182 1
%token KW_ASSOC         /* -> */
d193 4
a196 4
%left  kIF_MOD kUNLESS_MOD kWHILE_MOD kUNTIL_MOD
%left  kOR kAND
%right kNOT
%nonassoc kDEFINED
d221 1
a221 1
		  compstmt
d229 1
a229 1
compstmt	: stmts opt_terms
d231 1
a231 1
stmts		: /* none */
d235 1
a235 1
		| stmt
d239 1
a239 1
		| stmts terms stmt
d243 1
a243 1
		| error stmt
d248 24
a271 1
stmt		: iterator iter_do_block
d277 1
a277 1
		| kALIAS fname {lex_state = EXPR_FNAME;} fname
d283 1
a283 1
		| kALIAS GVAR GVAR
d289 1
a289 1
		| kALIAS GVAR BACK_REF
d298 1
a298 1
		| kALIAS GVAR NTH_REF
d303 1
a303 1
		| kUNDEF undef_list
d309 1
a309 1
		| stmt kIF_MOD expr
d312 1
a312 1
		        $$ = node_newnode(NODE_AND, cond($3), $1);
d314 1
a314 1
		| stmt kUNLESS_MOD expr
d317 1
a317 1
		        $$ = node_newnode(NODE_OR, cond($3), $1);
d319 1
a319 1
		| stmt kWHILE_MOD expr
d329 1
a329 1
		| expr kUNTIL_MOD expr
d339 1
a339 44
		| klBEGIN 
		    {
			if (cur_mid || in_single) {
			    yyerror("BEGIN in method");
			}

			local_push();
		    }
		  '{' compstmt '}'
		    {
			eval_tree0 = block_append(eval_tree0,NEW_PREEXE($4));
		        local_pop();
		        $$ = 0;
		    }
		| klEND '{' compstmt '}'
		    {
			if (cur_mid || in_single) {
			    yyerror("END in method; use at_exit");
			}

			$$ = NEW_ITER(0, NEW_POSTEXE(), $3);
		    }
		| expr

expr		: mlhs '=' mrhs
		    {
			value_expr($3);
			$1->nd_value = $3;
			$$ = $1;
		    }
		| kRETURN ret_args
		    {
			value_expr($2);
			if (!cur_mid && !in_single)
			    yyerror("return appeared outside of method");
			$$ = NEW_RET($2);
		    }
		| kYIELD ret_args
		    {
			value_expr($2);
			$$ = NEW_YIELD($2);
		    }
		| command_call
		| expr kAND expr
d343 1
a343 1
		| expr kOR expr
d347 1
a347 1
		| kNOT expr
d370 1
a370 7
		| primary COLON2 operation call_args0
		    {
			value_expr($1);
			$$ = NEW_CALL($1, $3, $4);
		        fixpos($$, $1);
		    }
		| kSUPER call_args0
d414 1
a414 1
		| primary '[' call_args ']'
d490 1
a490 1
		| primary '[' call_args ']' '=' arg
d492 2
a493 2
			$$ = aryset($1, $3, $6);
		        fixpos($$, $1);
d500 5
d519 1
a519 1
		| primary '[' call_args ']' OP_ASGN arg
d521 1
a521 1
			NODE *args = NEW_LIST($6);
d525 2
a526 2
			$$ = NEW_OP_ASGN1($1, $5, args);
		        fixpos($$, $1);
d531 1
a531 6
		        fixpos($$, $1);
		    }
		| primary '.' CONSTANT OP_ASGN arg
		    {
			$$ = NEW_OP_ASGN2($1, $3, $4, $5);
		        fixpos($$, $1);
d624 2
a625 1
			$$ = match_gen($1, $3);
d629 2
a630 1
			$$ = NEW_NOT(match_gen($1, $3));
d657 1
a657 1
		| kDEFINED opt_nl {in_defined = 1;} arg
d673 2
a674 1
call_args0	: command_call
a678 5
		| args
		| args ',' STAR arg
		    {
			$$ = arg_add($1, $4);
		    }
a682 5
		| assocs ',' STAR arg
		    {
			$$ = NEW_LIST(NEW_HASH($1));
			$$ = arg_add($$, $4);
		    }
d690 5
a694 1
			$$ = arg_add($$, $6);
d702 1
a702 1
opt_list	: /* none */
d721 1
a721 3
			if ($1 &&
		            nd_type($1) == NODE_ARRAY &&
		            $1->nd_next == 0) {
d730 1
a730 1
			$$ = arg_add($1, $4);
d777 13
a789 1
		| primary '[' call_args ']'
d806 1
a806 1
		| kRETURN '(' ret_args ')'
d813 1
a813 1
		| kRETURN '(' ')'
d819 1
a819 1
		| kRETURN
d825 1
a825 1
		| kYIELD '(' ret_args ')'
d830 1
a830 1
		| kYIELD '(' ')'
d834 1
a834 1
		| kYIELD
d838 1
a838 1
		| kDEFINED opt_nl '(' {in_defined = 1;} expr ')'
d859 2
a860 2
		| kIF expr then
		  compstmt
d862 1
a862 1
		  kEND
d868 2
a869 2
		| kUNLESS expr then
		  compstmt
d871 1
a871 1
		  kEND
d877 1
a877 3
		| kWHILE expr do
		  compstmt
		  kEND
d883 1
a883 3
		| kUNTIL expr do
		  compstmt
		  kEND
d889 1
a889 1
		| kCASE compstmt
d891 1
a891 1
		  kEND
d897 1
a897 3
		| kFOR iter_var kIN expr do
		  compstmt
		  kEND
d903 2
a904 2
		| kBEGIN
		  compstmt
d907 1
a907 1
		  kEND
d918 1
a918 1
		| LPAREN compstmt ')'
d922 1
a922 1
		| kCLASS cname superclass
d931 2
a932 2
		  compstmt
		  kEND
d940 1
a940 1
		| kCLASS LSHFT expr term
d949 2
a950 2
		  compstmt
		  kEND
d958 1
a958 1
		| kMODULE cname
d966 2
a967 2
		  compstmt
		  kEND
d975 1
a975 1
		| kDEF fname
d983 2
a984 2
		  compstmt
		  kEND
a985 1
		        /* NOEX_PRIVATE for toplevel */
d991 1
a991 1
		| kDEF singleton '.' {lex_state = EXPR_FNAME;} fname
d999 2
a1000 2
		  compstmt
		  kEND
a1006 16
		| kBREAK
		    {
			$$ = NEW_BREAK();
		    }
		| kNEXT
		    {
			$$ = NEW_NEXT();
		    }
		| kREDO
		    {
			$$ = NEW_REDO();
		    }
		| kRETRY
		    {
			$$ = NEW_RETRY();
		    }
d1009 2
a1010 6
		| kTHEN
		| term kTHEN

do		: term
		| kDO
		| term kDO
d1013 2
a1014 2
		| kELSIF expr then
		  compstmt
d1026 1
a1026 1
		| kELSE compstmt
d1051 1
a1051 1
iter_do_block	: kDO
d1056 2
a1057 2
		  compstmt
		  kEND
d1069 1
a1069 1
		  compstmt '}'
a1112 12
		| kSUPER '(' call_args ')'
		    {
			if (!cur_mid && !in_single && !in_defined)
			    yyerror("super called outside of method");
			$$ = NEW_SUPER($3);
		    }
		| kSUPER
		    {
			if (!cur_mid && !in_single && !in_defined)
			    yyerror("super called outside of method");
			$$ = NEW_ZSUPER();
		    }
d1114 2
a1115 3

case_body	: kWHEN args then
		  compstmt
d1124 1
a1124 2
rescue		: kRESCUE opt_list do
		  compstmt
d1139 1
a1139 1
		| kENSURE compstmt
d1145 1
a1145 1
		| SYMBEG symbol
d1147 1
a1147 1
			$$ = INT2FIX($2);
d1162 8
a1169 4
		| kNIL {$$ = kNIL;}
		| kSELF {$$ = kSELF;}
		| kTRUE {$$ = kTRUE;} 
		| kFALSE {$$ = kFALSE;}
a1331 7
		| assoc_kw KW_ASSOC arg
		    {
			$$ = list_append(NEW_LIST(NEW_STR(str_new2(rb_id2name($1)))), $3);
		    }

assoc_kw	: IDENTIFIER
		| CONSTANT
a1373 1
static VALUE lex_lastline;	/* gc protect */
d1433 1
a1480 6
	    if (RSTRING(v)->len == 8 &&
		strncmp(lex_pbeg, "__END__", 7) == 0) {
		lex_lastline = 0;
		return -1;
	    }
	    lex_lastline = v;
a1482 1
	    lex_lastline = 0;
d1512 1
a1512 1
    if (toksiz > 4096) {
d1669 1
a1669 1
	    continue;
d1675 1
a1675 1
		Error("unterminated regexp meets end of file"); /*  */
a1780 2
static int parse_qstring();

a1788 3
    if (func == '\'') {
	return parse_qstring(term);
    }
d1793 1
d1904 1
a1904 12
char *strdup();

static int
here_document(term)
    char term;
{
    int c;
    char *eos;
    int len;
    VALUE str, line;
    char *save_beg, *save_end, *save_lexp;
    NODE *list = 0;
d1906 37
a1942 96
    newtok();
    switch (term) {
      case '\'':
      case '"':
      case '`':
	while ((c = nextc()) != term) {
	    tokadd(c);
	}
	break;

      default:
	c =  term;
	term = '"';
	if (!is_identchar(c)) {
	    yyerror("illegal here document");
	    return 0;
	}
	while (is_identchar(c)) {
	    tokadd(c);
	    c = nextc();
	}
	pushback(c);
	break;
    }
    tokfix();
    save_lexp = lex_p;
    save_beg = lex_pbeg;
    save_end = lex_pend;
    eos = strdup(tok());
    len = strlen(eos);

    str = str_new(0,0);
    for (;;) {
	line = io_gets(lex_input);
	if (NIL_P(line)) {
	  error:
	    Error("unterminated string meets end of file");
	    free(eos);
	    return 0;
	}
	if (strncmp(eos, RSTRING(line)->ptr, len) == 0 &&
	    (RSTRING(line)->ptr[len] == '\n' ||
	     RSTRING(line)->ptr[len] == '\r')) {
	    break;
	}

	lex_pbeg = lex_p = RSTRING(line)->ptr;
	lex_pend = lex_p + RSTRING(line)->len;
	sourceline++;
	switch (parse_string(term, '\n')) {
	  case STRING:
	  case XSTRING:
	    str_cat(yylval.val, "\n", 1);
	    if (!list) {
	        str_cat(str, RSTRING(yylval.val)->ptr, RSTRING(yylval.val)->len);
	    }
	    else {
		list_append(list, NEW_STR(yylval.val));
	    }
	    break;
	  case DSTRING:
	  case DXSTRING:
	    list_append(yylval.node, NEW_STR(str_new2("\n")));
	    nd_set_type(yylval.node, NODE_STR);
	    if (!list) list = NEW_DSTR(str);
	    yylval.node = NEW_LIST(yylval.node);
	    yylval.node->nd_next = yylval.node->nd_head->nd_next;
	    list_concat(list, yylval.node);
	    break;

	  case 0:
	    goto error;
	}
    }
    free(eos);
    lex_p = save_lexp;
    lex_pbeg = save_beg;
    lex_pend = save_end;

    if (list) {
	yylval.node = list;
    }
    switch (term) {
      case '\'':
      case '"':
	if (list) return DSTRING;
	yylval.val = str;	  
	return STRING;
      case '`':
	if (list) return DXSTRING;
	return XSTRING;
    }
    return 0;
}

#include "lex.c"
d1959 1
a1959 1
    struct kwtable *kw;
d1984 1
a1984 1
	    if (c == '\\') {	/* skip a char */
d1990 1
a1990 2
		if (c == '\n') {
		    sourceline++;
a1991 1
		}
d1996 21
d2067 1
d2069 3
a2071 2
		    sourceline++;
		    lex_p = lex_pend;
a2072 4
		    if (c == -1) {
			Error("embedded document meets end of file");
			return 0;
		    }
d2075 1
a2078 2
		sourceline++;
		lex_p = lex_pend;
a2100 14
	c = nextc();
	if (c == '<' &&
	    lex_state != EXPR_END
	    && lex_state != EXPR_CLASS &&
	    (lex_state != EXPR_ARG || space_seen)) {
 	    int c2 = nextc();
	    if (!isspace(c2) && (strchr("\"'`", c2) || is_identchar(c2))) {
		if (!lex_input) {
		    ArgError("here document not available");
		}
		return here_document(c2);
	    }
	    pushback(c2);
	}
d2102 1
a2102 1
	if (c == '=') {
a2225 4
	if (c == '>') {
	    lex_state = EXPR_BEG;
	    return KW_ASSOC;
	}
d2304 1
a2304 1
		    yyerror("Illegal octal digit");
a2389 1
	lex_state = EXPR_FNAME;
d2536 1
a2536 1
		yyerror("unknown type of string `%c'", c);
d2559 1
a2560 2
            /* fall through */
	  case '_':		/* $_: last read line string */
d2672 19
a2690 5
	    kw = rb_reserved_word(tok(), toklen());
	    if (kw) {
		enum lex_state state = lex_state;
		lex_state = kw->state;
		return kw->id[state != EXPR_BEG];
d2728 1
a2728 1
    int c, brace;
a2816 1
	if (c == '{') brace = '}';
d2824 1
a2824 1
		    yyerror("bad substitution in string");
d2830 2
a2831 5
	      case ')':
		if (c == brace) {
		    if (nest == 0) break;
		    nest--;
		}
d2839 1
a2839 1
		if (brace == c) nest++;
d2856 1
a2856 1
	} while (c != brace);
d2878 1
a2878 1
    n->nd_file = sourcefile;
d2920 1
a2920 1
    node->nd_file = orig->nd_file;
d2928 1
d2944 1
a2944 1
    if (RTEST(verbose)) {
a2948 4
	  case NODE_BREAK:
	  case NODE_NEXT:
	  case NODE_REDO:
	  case NODE_RETRY:
a3020 32
match_gen(node1, node2)
    NODE *node1;
    NODE *node2;
{
    local_cnt('~');

    switch (nd_type(node1)) {
      case NODE_DREGX:
      case NODE_DREGX_ONCE:
	return NEW_MATCH2(node1, node2);

      case NODE_LIT:
	if (TYPE(node1->nd_lit) == T_REGEXP) {
	    return NEW_MATCH2(node1, node2);
	}
    }

    switch (nd_type(node2)) {
      case NODE_DREGX:
      case NODE_DREGX_ONCE:
	return NEW_MATCH3(node2, node1);

      case NODE_LIT:
	if (TYPE(node2->nd_lit) == T_REGEXP) {
	    return NEW_MATCH3(node2, node1);
	}
    }

    return NEW_CALL(node1, MATCH, NEW_LIST(node2));
}

static NODE*
d3024 1
a3024 1
    if (id == kSELF) {
d3027 1
a3027 1
    else if (id == kNIL) {
a3029 6
    else if (id == kTRUE) {
	return NEW_TRUE();
    }
    else if (id == kFALSE) {
	return NEW_FALSE();
    }
d3056 1
a3056 1
    if (id == kSELF) {
d3059 1
a3059 1
    else if (id == kNIL) {
a3061 6
    else if (id == kTRUE) {
	yyerror("Can't assign to true");
    }
    else if (id == kFALSE) {
	yyerror("Can't assign to false");
    }
a3088 8
arg_add(node1, node2)
    NODE *node1;
    NODE *node2;
{
    return call_op(node1, rb_intern("concat"), 1, node2);
}

static NODE *
d3094 1
a3094 9
    if (idx) {
	if (nd_type(idx) == NODE_ARRAY) {
	    idx = list_append(idx, val);
	}
	else {
	    idx = arg_add(idx, val);
	}
    }
    return NEW_CALL(recv, ASET, idx);
a3141 4
      case NODE_BREAK:
      case NODE_NEXT:
      case NODE_REDO:
      case NODE_RETRY:
d3182 1
a3182 1
	return NEW_MATCH2(node, NEW_GVAR(rb_intern("$_")));
a3197 5
	if (TYPE(node->nd_lit) == T_STRING) {
	    local_cnt('_');
	    local_cnt('~');
	    return NEW_MATCH(reg_new(RSTRING(node)->ptr,RSTRING(node)->len,0));
	}
d3426 2
a3427 3
	block_append(eval_tree,
		     NEW_FCALL(rb_intern("print"),
			       NEW_ARRAY(NEW_GVAR(rb_intern("$_")))));
d3494 1
a3494 1
static st_table *rb_symbol_tbl;
d3504 1
a3504 2
    rb_global_variable((VALUE*)&cur_cref);
    rb_global_variable((VALUE*)&lex_lastline);
d3535 1
a3535 2
		if (*rb_op_tbl[i].name == *name &&
		    strcmp(rb_op_tbl[i].name, name) == 0) {
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/12/22 09:01:52 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
d35 6
a40 6
#define is_id_notop(id) ((id)>LAST_TOKEN)
#define is_local_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_LOCAL)
#define is_global_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_GLOBAL)
#define is_instance_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_INSTANCE)
#define is_attrset_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_ATTRSET)
#define is_const_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_CONST)
d42 7
a48 2
NODE *ruby_eval_tree_begin = 0;
NODE *ruby_eval_tree = 0;
d50 2
a51 2
char *ruby_sourcefile;		/* current source file */
int   ruby_sourceline;		/* current line no. */
d60 3
a62 4
    EXPR_ARG,			/* newline significant, +/- is a operator. */
    EXPR_FNAME,			/* ignore newline, +/- is a operator, no reserved words. */
    EXPR_DOT,			/* immediate after `.', no reserved words. */
    EXPR_CLASS,			/* immediate after `class', no here document. */
a82 4
static NODE *arg_blk_pass();
static NODE *new_call();
static NODE *new_fcall();

d87 1
a87 1
static void rb_backref_error();
a91 1
static int  local_append();
d100 3
a160 2
	k__LINE__
	k__FILE__
d162 3
a164 3
%token <id>   tIDENTIFIER tFID tGVAR tIVAR tCONSTANT
%token <val>  tINTEGER tFLOAT tSTRING tXSTRING tREGEXP
%token <node> tDSTRING tDXSTRING tDREGEXP tNTH_REF tBACK_REF
d169 4
a172 6
%type <node> if_tail opt_else case_body cases rescue ensure
%type <node> opt_call_args call_args ret_args args when_args
%type <node> aref_args opt_block_arg block_arg
%type <node> mrhs opt_list superclass iterator var_ref
%type <node> f_arglist f_args f_optarg f_opt f_block_arg opt_f_block_arg
%type <node> array assoc_list assocs assoc undef_list backref
d174 3
a176 3
%type <node> mlhs mlhs_head mlhs_tail mlhs_basic mlhs_entry mlhs_item lhs
%type <id>   variable symbol operation
%type <id>   cname fname op f_rest_arg
d178 23
a200 24
%token tUPLUS 		/* unary+ */
%token tUMINUS 		/* unary- */
%token tPOW		/* ** */
%token tCMP  		/* <=> */
%token tEQ  		/* == */
%token tEQQ  		/* === */
%token tNEQ  		/* != */
%token tGEQ  		/* >= */
%token tLEQ  		/* <= */
%token tANDOP tOROP	/* && and || */
%token tMATCH tNMATCH	/* =~ and !~ */
%token tDOT2 tDOT3	/* .. and ... */
%token tAREF tASET	/* [] and []= */
%token tLSHFT tRSHFT	/* << and >> */
%token tCOLON2		/* :: */
%token tCOLON3		/* :: at EXPR_BEG */
%token <id> tOP_ASGN	/* +=, -=  etc. */
%token tASSOC		/* => */
%token tLPAREN		/* ( */
%token tLBRACK		/* [ */
%token tLBRACE		/* { */
%token tSTAR		/* * */
%token tAMPER		/* & */
%token tSYMBEG
d210 6
a215 7
%right '=' tOP_ASGN
%right '?' ':'
%nonassoc tDOT2 tDOT3
%left  tOROP
%left  tANDOP
%nonassoc  tCMP tEQ tEQQ tNEQ tMATCH tNMATCH
%left  '>' tGEQ '<' tLEQ
d218 1
a218 1
%left  tLSHFT tRSHFT
d221 2
a222 2
%right '!' '~' tUPLUS tUMINUS
%right tPOW
a227 1
		        $<vars>$ = ruby_dyna_vars;
d231 1
a231 1
			if ((VALUE)ruby_class == rb_cObject) class_nest = 0;
d236 1
a236 1
			ruby_eval_tree = block_append(ruby_eval_tree, $2);
a239 1
		        ruby_dyna_vars = $<vars>1;
a262 3
			if ($1 && nd_type($1) == NODE_BLOCK_PASS) {
			    rb_compile_error("both block arg and actual block given");
			}
d273 1
a273 1
		| kALIAS tGVAR tGVAR
d279 1
a279 1
		| kALIAS tGVAR tBACK_REF
d288 1
a288 1
		| kALIAS tGVAR tNTH_REF
d302 1
a302 2
			$$ = NEW_IF(cond($3), $1, 0);
		        fixpos($$, $3);
d307 1
a307 2
			$$ = NEW_UNLESS(cond($3), $1, 0);
		        fixpos($$, $3);
d319 1
a319 1
		| stmt kUNTIL_MOD expr
d329 1
a329 1
		| klBEGIN
d339 1
a339 2
			ruby_eval_tree_begin = block_append(ruby_eval_tree_begin,
						       NEW_PREEXE($4));
d364 1
a364 1
			$$ = NEW_RETURN($2);
d385 1
a385 1
		| '!' command_call
d392 1
a392 1
command_call	: operation call_args
d394 1
a394 1
			$$ = new_fcall($1, $2);
d397 1
a397 1
		| primary '.' operation call_args
d400 1
a400 1
			$$ = new_call($1, $3, $4);
d403 1
a403 1
		| primary tCOLON2 operation call_args
d406 1
a406 1
			$$ = new_call($1, $3, $4);
d409 1
a409 1
		| kSUPER call_args
d417 1
a417 13
mlhs		: mlhs_basic
		| tLPAREN mlhs_entry ')'
		    {
			$$ = $2;
		    }

mlhs_entry	: mlhs_basic
		| tLPAREN mlhs_entry ')'
		    {
			$$ = NEW_MASGN(NEW_LIST($2), 0);
		    }

mlhs_basic	: mlhs_head
d421 1
a421 1
		| mlhs_head tSTAR lhs
d429 1
a429 1
		| mlhs_head mlhs_tail ',' tSTAR lhs
d433 1
a433 1
		| tSTAR lhs
d438 1
a438 10
mlhs_item	: lhs
		| tLPAREN mlhs_entry ')'
		    {
			$$ = $2;
		    }

mlhs_head	: mlhs_item ','
		    {
			$$ = $1;
		    }
d440 1
a440 1
mlhs_tail	: mlhs_item
d444 1
a444 1
		| mlhs_tail ',' mlhs_item
d453 1
a453 1
		| primary '[' aref_args ']'
d457 5
a461 1
		| primary '.' tIDENTIFIER
d467 1
a467 1
		        rb_backref_error($1);
d471 1
a471 1
cname		: tIDENTIFIER
d475 1
a475 1
		| tCONSTANT
d477 3
a479 3
fname		: tIDENTIFIER
		| tCONSTANT
		| tFID
a484 5
		| reswords
		    {
			lex_state = EXPR_END;
			$$ = $<id>1;
		    }
d495 1
a495 1
op		: tDOT2		{ $$ = tDOT2; }
d499 4
a502 4
		| tCMP		{ $$ = tCMP; }
		| tEQ		{ $$ = tEQ; }
		| tEQQ		{ $$ = tEQQ; }
		| tMATCH	{ $$ = tMATCH; }
d504 1
a504 1
		| tGEQ		{ $$ = tGEQ; }
d506 3
a508 3
		| tLEQ		{ $$ = tLEQ; }
		| tLSHFT	{ $$ = tLSHFT; }
		| tRSHFT	{ $$ = tRSHFT; }
d512 1
a512 1
		| tSTAR		{ $$ = '*'; }
d515 1
a515 1
		| tPOW		{ $$ = tPOW; }
d517 4
a520 4
		| tUPLUS	{ $$ = tUPLUS; }
		| tUMINUS	{ $$ = tUMINUS; }
		| tAREF		{ $$ = tAREF; }
		| tASET		{ $$ = tASET; }
d523 5
a527 15
reswords	: k__LINE__ | k__FILE__ | klBEGIN | klEND
		| kALIAS | kAND | kBEGIN | kBREAK | kCASE | kCLASS | kDEF
		| kDEFINED | kDO | kELSE | kELSIF | kEND | kENSURE | kFALSE
		| kFOR | kIF_MOD | kIN | kMODULE | kNEXT | kNIL | kNOT
		| kOR | kREDO | kRESCUE | kRETRY | kRETURN | kSELF | kSUPER
		| kTHEN | kTRUE | kUNDEF | kUNLESS_MOD | kUNTIL_MOD | kWHEN
		| kWHILE_MOD | kYIELD

arg		: variable '=' {$$ = assignable($1, 0);} arg
		    {
			$$ = $<node>3;
			if ($$) {
			    $$->nd_value = $4;
			    fixpos($$, $4);
			}
d529 1
a529 1
		| primary '[' aref_args ']' '=' arg
d534 1
a534 6
		| primary '.' tIDENTIFIER '=' arg
		    {
			$$ = attrset($1, $3, $5);
		        fixpos($$, $5);
		    }
		| primary '.' tCONSTANT '=' arg
d542 1
a542 1
		        rb_backref_error($1);
d545 1
a545 1
		| variable tOP_ASGN {$$ = assignable($1, 0);} arg
d547 5
a551 13
			if ($2 == tOROP) {
			    $<node>3->nd_value = $4;
			    $$ = NEW_OP_ASGN_OR(gettable($1), $<node>3);
			}
			else if ($2 == tANDOP) {
			    $<node>3->nd_value = $4;
			    $$ = NEW_OP_ASGN_AND(gettable($1), $<node>3);
			}
			else {
			    $$ = $<node>3;
			    $$->nd_value = call_op(gettable($1), $2, 1, $4);
			}
			fixpos($$, $4);
d553 1
a553 1
		| primary '[' aref_args ']' tOP_ASGN arg
d557 1
a557 1
			list_append($3, NEW_NIL());
a558 6
			if ($5 == tOROP) {
			    $5 = 0;
			}
			else if ($5 == tANDOP) {
			    $5 = 1;
			}
d562 1
a562 1
		| primary '.' tIDENTIFIER tOP_ASGN arg
a563 6
			if ($4 == tOROP) {
			    $4 = 0;
			}
			else if ($4 == tANDOP) {
			    $4 = 1;
			}
d567 1
a567 1
		| primary '.' tCONSTANT tOP_ASGN arg
a568 6
			if ($4 == tOROP) {
			    $4 = 0;
			}
			else if ($4 == tANDOP) {
			    $4 = 1;
			}
d572 1
a572 1
		| backref tOP_ASGN arg
d574 1
a574 1
		        rb_backref_error($1);
d577 1
a577 1
		| arg tDOT2 arg
d581 1
a581 1
		| arg tDOT3 arg
d605 1
a605 1
		| arg tPOW arg
d607 1
a607 1
			$$ = call_op($1, tPOW, 1, $3);
d609 1
a609 1
		| tUPLUS arg
d611 1
a611 1
			$$ = call_op($2, tUPLUS, 0);
d613 1
a613 1
		| tUMINUS arg
d615 1
a615 1
		        $$ = call_op($2, tUMINUS, 0);
d629 1
a629 1
		| arg tCMP arg
d631 1
a631 1
			$$ = call_op($1, tCMP, 1, $3);
d637 1
a637 1
		| arg tGEQ arg
d639 1
a639 1
			$$ = call_op($1, tGEQ, 1, $3);
d645 1
a645 1
		| arg tLEQ arg
d647 1
a647 1
			$$ = call_op($1, tLEQ, 1, $3);
d649 1
a649 1
		| arg tEQ arg
d651 1
a651 1
			$$ = call_op($1, tEQ, 1, $3);
d653 1
a653 1
		| arg tEQQ arg
d655 1
a655 1
			$$ = call_op($1, tEQQ, 1, $3);
d657 1
a657 1
		| arg tNEQ arg
d659 1
a659 1
			$$ = NEW_NOT(call_op($1, tEQ, 1, $3));
d661 1
a661 1
		| arg tMATCH arg
d665 1
a665 1
		| arg tNMATCH arg
d678 1
a678 1
		| arg tLSHFT arg
d680 1
a680 1
			$$ = call_op($1, tLSHFT, 1, $3);
d682 1
a682 1
		| arg tRSHFT arg
d684 1
a684 1
			$$ = call_op($1, tRSHFT, 1, $3);
d686 1
a686 1
		| arg tANDOP arg
d690 1
a690 1
		| arg tOROP arg
a698 6
		| arg '?' arg ':' arg
		    {
			value_expr($1);
			$$ = NEW_IF(cond($1), $3, $5);
		        fixpos($$, $1);
		    }
d704 1
a704 9
aref_args	: opt_call_args
		    {
			if ($1 && nd_type($1) == NODE_BLOCK_PASS) {
			    rb_compile_error("block argument should not be given");
			}
			$$ = $1;
		    }

opt_call_args	: /* none */
d708 1
a708 1
		| call_args opt_nl
d710 1
a710 1
call_args	: command_call
d715 2
a716 5
		| args opt_block_arg
		    {
			$$ = arg_blk_pass($1, $2);
		    }
		| args ',' tSTAR arg opt_block_arg
a718 1
			$$ = arg_blk_pass($$, $5);
d720 1
a720 1
		| assocs opt_block_arg
a722 1
			$$ = arg_blk_pass($$, $2);
d724 1
a724 1
		| assocs ',' tSTAR arg opt_block_arg
d726 2
a727 2
			$$ = arg_add(NEW_LIST(NEW_HASH($1)), $4);
			$$ = arg_blk_pass($$, $5);
d729 1
a729 1
		| args ',' assocs opt_block_arg
a731 1
			$$ = arg_blk_pass($$, $4);
d733 1
a733 1
		| args ',' assocs ',' tSTAR arg opt_block_arg
d735 2
a736 2
			$$ = arg_add(list_append($1, NEW_HASH($3)), $6);
			$$ = arg_blk_pass($$, $7);
d738 1
a738 1
		| tSTAR arg opt_block_arg
a740 12
			$$ = arg_blk_pass(NEW_RESTARGS($2), $3);
		    }
		| block_arg

block_arg	: tAMPER arg
		    {
			value_expr($2);
			$$ = NEW_BLOCK_PASS($2);
		    }

opt_block_arg	: ',' block_arg
		    {
a742 4
		| /* none */
		    {
			$$ = 0;
		    }
d744 1
a744 2
opt_list	: args
		| /* none */
d748 1
d765 1
a765 2
		            $1->nd_next == 0)
			{
d772 1
a772 1
		| args ',' tSTAR arg
a773 1
			value_expr($4);
d776 1
a776 1
		| tSTAR arg
d782 1
a782 1
ret_args	: call_args
d784 7
a790 9
			$$ = $1;
			if ($1) {
			    if (nd_type($1) == NODE_ARRAY &&
				$1->nd_next == 0) {
				$$ = $1->nd_head;
			    }
			    else if (nd_type($1) == NODE_BLOCK_PASS) {
				rb_compile_error("block argument should not be given");
			    }
d804 1
a804 1
		| primary tCOLON2 tCONSTANT
a805 1
			value_expr($1);
d808 1
a808 10
		| primary tCOLON2 tIDENTIFIER
		    {
			value_expr($1);
			$$ = new_call($1, $3, 0);
		    }
		| tCOLON3 cname
		    {
			$$ = NEW_COLON3($2);
		    }
		| tSTRING
d812 2
a813 2
		| tDSTRING
		| tXSTRING
d817 2
a818 2
		| tDXSTRING
		| tDREGEXP
d821 1
a821 1
		| primary '[' aref_args ']'
d824 1
a824 1
			$$ = NEW_CALL($1, tAREF, $3);
d826 1
a826 1
		| tLBRACK array ']'
d834 1
a834 1
		| tLBRACE assoc_list '}'
d843 1
a843 1
			$$ = NEW_RETURN($3);
d849 1
a849 1
			$$ = NEW_RETURN(0);
d855 1
a855 1
			$$ = NEW_RETURN(0);
d875 1
a875 1
		| tFID
d877 1
a877 1
			$$ = NEW_VCALL($1);
a886 3
			if ($1 && nd_type($1) == NODE_BLOCK_PASS) {
			    rb_compile_error("both block arg and actual block given");
			}
a943 1
		  opt_else
d947 1
a947 1
			if (!$3 && !$4 && !$5)
d950 2
a951 6
			    if ($3) $2 = NEW_RESCUE($2, $3, $4);
			    else if ($4) {
				rb_warn("else without rescue is useless");
				$2 = block_append($2, $4);
			    }
			    if ($5) $2 = NEW_ENSURE($2, $5);
d956 1
a956 1
		| tLPAREN compstmt ')'
d978 1
a978 1
		| kCLASS tLSHFT expr term
d980 3
d1030 1
a1030 1
		| kDEF singleton dot_or_colon {lex_state = EXPR_FNAME;} fname
d1069 1
d1097 1
a1097 1
		| '|' /* none */ '|'
d1101 1
a1101 1
		| tOROP
d1123 1
a1123 1
iter_block	: '{'
d1135 1
a1135 1
iterator	: tIDENTIFIER
d1137 1
a1137 1
			$$ = NEW_VCALL($1);
d1139 1
a1139 1
		| tCONSTANT
d1141 1
a1141 1
			$$ = NEW_VCALL($1);
d1143 1
a1143 1
		| tFID
d1145 1
a1145 1
			$$ = NEW_VCALL($1);
d1150 1
a1150 1
method_call	: operation '(' opt_call_args ')'
d1152 1
a1152 1
			$$ = new_fcall($1, $3);
d1155 1
a1155 1
		| primary '.' operation '(' opt_call_args ')'
d1158 1
a1158 1
			$$ = new_call($1, $3, $5);
d1164 1
a1164 2
			$$ = new_call($1, $3, 0);
		        fixpos($$, $1);
d1166 1
a1166 1
		| primary tCOLON2 operation '(' opt_call_args ')'
d1169 1
a1169 1
			$$ = new_call($1, $3, $5);
d1172 1
a1172 1
		| kSUPER '(' opt_call_args ')'
d1186 1
a1186 1
case_body	: kWHEN when_args then
a1192 12
when_args	: args
		| args ',' tSTAR arg
		    {
			value_expr($4);
			$$ = list_append($1, NEW_WHEN($4, 0, 0));
		    }
		| tSTAR arg
		    {
			value_expr($2);
			$$ = NEW_LIST(NEW_WHEN($2, 0, 0));
		    }

d1198 1
a1198 1
		  rescue
d1218 1
a1218 1
		| tSYMBEG symbol
d1222 1
a1222 1
		| tREGEXP
d1225 2
a1226 2
		| tIVAR
		| tGVAR
d1228 2
a1229 2
numeric		: tINTEGER
		| tFLOAT
d1231 4
a1234 4
variable	: tIDENTIFIER
		| tIVAR
		| tGVAR
		| tCONSTANT
d1237 1
a1237 1
		| kTRUE {$$ = kTRUE;}
a1238 2
		| k__FILE__ {$$ = k__FILE__;}
		| k__LINE__ {$$ = k__LINE__;}
d1245 2
a1246 2
backref		: tNTH_REF
		| tBACK_REF
d1260 1
a1260 1
		| error term {yyerrok; $$ = 0;}
d1262 1
a1262 1
f_arglist	: '(' f_args opt_nl ')'
d1272 1
a1272 1
f_args		: f_arg ',' f_optarg ',' f_rest_arg opt_f_block_arg
d1274 1
a1274 1
			$$ = block_append(NEW_ARGS($1, $3, $5), $6);
d1276 1
a1276 1
		| f_arg ',' f_optarg opt_f_block_arg
d1278 1
a1278 1
			$$ = block_append(NEW_ARGS($1, $3, -1), $4);
d1280 1
a1280 1
		| f_arg ',' f_rest_arg opt_f_block_arg
d1282 1
a1282 1
			$$ = block_append(NEW_ARGS($1, 0, $3), $4);
d1284 1
a1284 1
		| f_arg opt_f_block_arg
d1286 1
a1286 1
			$$ = block_append(NEW_ARGS($1, 0, -1), $2);
d1288 1
a1288 1
		| f_optarg ',' f_rest_arg opt_f_block_arg
d1290 1
a1290 1
			$$ = block_append(NEW_ARGS(0, $1, $3), $4);
d1292 1
a1292 1
		| f_optarg opt_f_block_arg
d1294 1
a1294 1
			$$ = block_append(NEW_ARGS(0, $1, -1), $2);
d1296 1
a1296 1
		| f_rest_arg opt_f_block_arg
d1298 1
a1298 1
			$$ = block_append(NEW_ARGS(0, 0, $1), $2);
d1300 1
a1300 1
		| f_block_arg
d1302 1
a1302 5
			$$ = block_append(NEW_ARGS(0, 0, -1), $1);
		    }
		| /* none */
		    {
			$$ = NEW_ARGS(0, 0, -1);
d1305 1
a1305 1
f_arg		: tIDENTIFIER
d1312 1
a1312 1
		| f_arg ',' tIDENTIFIER
d1320 1
a1320 1
f_opt		: tIDENTIFIER '=' arg
d1337 1
a1337 1
f_rest_arg	: tSTAR tIDENTIFIER
a1343 14
f_block_arg	: tAMPER tIDENTIFIER
		    {
			$$ = NEW_BLOCK_ARG($2);
		    }

opt_f_block_arg	: ',' f_block_arg
		    {
			$$ = $2;
		    }
		| /* none */
		    {
			$$ = 0;
		    }

d1357 1
a1357 1
		| tLPAREN expr opt_nl ')'
d1397 1
a1397 1
assoc		: arg tASSOC arg
d1401 4
d1406 2
a1407 3
operation	: tIDENTIFIER
		| tCONSTANT
		| tFID
d1409 3
a1411 2
dot_or_colon	: '.'
		| tCOLON2
d1434 1
a1434 1
#define is_identchar(c) ((c)!=-1&&(ISALNUM(c) || (c) == '_' || ismbchar(c)))
d1439 4
d1445 1
a1445 1
static NODE *rb_str_extend();
a1448 1
static VALUE (*lex_gets)();	/* gets function */
d1462 1
a1462 1
    rb_compile_error("%s", msg);
d1481 1
a1481 1
	rb_compile_error_append("%s", buf);
d1492 1
a1492 1
	rb_compile_error_append("%s", buf);
a1498 1
static int heredoc_end;
d1500 1
a1500 2
int ruby_in_compile = 0;
int ruby__end__seen;
a1507 2
    ruby__end__seen = 0;
    ruby_eval_tree = 0;
d1509 2
a1510 2
    ruby_sourcefile = f;
    ruby_in_compile = 1;
d1512 2
a1513 2
    ruby_in_compile = 0;
    if (n == 0) return ruby_eval_tree;
a1517 22
static int lex_gets_ptr;

static VALUE
lex_get_str(s)
    VALUE s;
{
    char *beg, *end, *pend;

    beg = RSTRING(s)->ptr;
    if (lex_gets_ptr) {
	if (RSTRING(s)->len == lex_gets_ptr) return Qnil;
	beg += lex_gets_ptr;
    }
    pend = RSTRING(s)->ptr + RSTRING(s)->len;
    end = beg;
    while (end < pend) {
	if (*end++ == '\n') break;
    }
    lex_gets_ptr = end - RSTRING(s)->ptr;
    return rb_str_new(beg, end - beg);
}

d1519 3
a1521 3
rb_compile_string(f, s)
    char *f;
    VALUE s;
d1523 5
a1527 6
    lex_gets = lex_get_str;
    lex_gets_ptr = 0;
    lex_input = s;
    lex_pbeg = lex_p = lex_pend = 0;
    if (!ruby_sourcefile || strcmp(f, ruby_sourcefile))	/* not in eval() */
	ruby_sourceline = 1;
d1533 1
a1533 9
rb_compile_cstr(f, s, len)
    char *f, *s;
    int len;
{
    return rb_compile_string(f, rb_str_new(s, len));
}

NODE*
rb_compile_file(f, file, start)
a1537 1
    lex_gets = rb_io_gets;
d1540 1
a1540 1
    ruby_sourceline = start;
d1542 1
a1542 15
    return yycompile(strdup(f));
}


static void
normalize_newline(line)
    VALUE line;
{
    if (RSTRING(line)->len >= 2 &&
	RSTRING(line)->ptr[RSTRING(line)->len-1] == '\n' &&
	RSTRING(line)->ptr[RSTRING(line)->len-2] == '\r')
    {
	RSTRING(line)->ptr[RSTRING(line)->len-2] = '\n';
	RSTRING(line)->len--;
    }
d1552 1
a1552 1
	    VALUE v = (*lex_gets)(lex_input);
a1554 15
	    if (heredoc_end > 0) {
		ruby_sourceline = heredoc_end+1;
		heredoc_end = 0;
	    }
	    normalize_newline(v);
	    while (RSTRING(v)->len >= 2 &&
		   RSTRING(v)->ptr[RSTRING(v)->len-1] == '\n' &&
		   RSTRING(v)->ptr[RSTRING(v)->len-2] == '\\') {
		VALUE v2 = (*lex_gets)(lex_input);

		if (!NIL_P(v2)) {
		    normalize_newline(v2);
		    rb_str_cat(v, RSTRING(v2)->ptr, RSTRING(v2)->len);
		}
	    }
d1557 2
a1558 2
	    if (strncmp(lex_pbeg, "__END__", 7) == 0 && lex_pbeg[7] == '\n') {
		ruby__end__seen = 1;
d1574 1
a1574 1
static void
d1671 1
a1671 1
		if (!ISXDIGIT(buf[i])) {
a1682 3
      case 's':	/* space */
	return ' ';

d1704 1
d1724 1
a1724 1
parse_regx(term, paren)
d1730 1
a1730 2
    int nest = 0;
    int options = 0;
d1732 1
a1732 1
    int re_start = ruby_sourceline;
d1737 1
a1737 1
	if ((!in_brack && c == term) || nest > 0) {
a1741 3
	  case '\n':
	    ruby_sourceline++;
	    break;
d1750 1
a1750 1
	    list = rb_str_extend(list, term);
d1757 2
a1758 2
		ruby_sourceline = re_start;
		rb_compile_error("unterminated regexp meets end of file");
d1762 1
a1762 1
		ruby_sourceline++;
a1765 2
	      case '^':
	      case 's':
d1767 1
a1767 1
		tokadd(c);
d1778 5
a1790 2
		if (c == paren) nest++;
		if (c == term) nest--;
d1792 1
a1792 1
		    ruby_sourceline++;
d1806 1
a1806 1
	    rb_compile_error("unterminated regexp");
d1811 2
a1812 6
		int i, len = mbclen(c)-1;

		for (i = 0; i < len; i++) {
		    tokadd(c);
		    c = nextc();
		}
d1820 1
a1820 4
		    options |= RE_OPTION_IGNORECASE;
		    break;
		  case 'x':
		    options |= RE_OPTION_EXTENDED;
d1826 1
a1826 1
		    kcode = 4;
d1829 1
a1829 1
		    kcode = 8;
d1832 1
a1832 4
		    kcode = 12;
		    break;
		  case 'u':
		    kcode = 16;
d1845 1
a1845 1
		    VALUE ss = rb_str_new(tok(), toklen());
d1849 1
a1849 1
		list->nd_cflag = options | kcode;
d1851 1
a1851 1
		return tDREGEXP;
d1854 2
a1855 2
		yylval.val = rb_reg_new(tok(), toklen(), options | kcode);
		return tREGEXP;
d1860 1
a1860 1
    rb_compile_error("unterminated regexp");
d1864 1
a1864 1
static int parse_qstring _((int,int));
d1867 2
a1868 2
parse_string(func, term, paren)
    int func, term, paren;
a1872 1
    int nest = 0;
d1875 1
a1875 7
	return parse_qstring(term, paren);
    }
    if (func == 0) {		/* read 1 line for heredoc */
	ruby_sourceline++;
				/* -1 for chomp */
	yylval.val = rb_str_new(lex_pbeg, lex_pend - lex_pbeg - 1);
	return tSTRING;
d1877 1
a1877 1
    strstart = ruby_sourceline;
d1879 3
a1881 2
    while ((c = nextc()) != term || nest > 0) {
	if (c == -1) {
d1883 2
a1884 2
	    ruby_sourceline = strstart;
	    rb_compile_error("unterminated string meets end of file");
d1888 2
a1889 6
	    int i, len = mbclen(c)-1;

	    for (i = 0; i < len; i++) {
		tokadd(c);
		c = nextc();
	    }
d1892 1
a1892 1
	    ruby_sourceline++;
d1895 1
a1895 1
	    list = rb_str_extend(list, term);
d1902 1
a1902 1
		ruby_sourceline++;
a1913 5
	if (c == paren) nest++;
	if (c == term) {
	    nest--;
	    if (nest == 0) break;
	}
d1921 1
a1921 1
	    VALUE ss = rb_str_new(tok(), toklen());
d1927 1
a1927 1
	    return tDXSTRING;
d1930 1
a1930 1
	    return tDSTRING;
d1934 2
a1935 2
	yylval.val = rb_str_new(tok(), toklen());
	return (func == '`') ? tXSTRING : tSTRING;
d1940 2
a1941 2
parse_qstring(term, paren)
    int term, paren;
a1944 1
    int nest = 0;
d1946 1
a1946 1
    strstart = ruby_sourceline;
d1948 4
a1951 4
    while ((c = nextc()) != term || nest > 0) {
	if (c == -1) {
	    ruby_sourceline = strstart;
	    rb_compile_error("unterminated string meets end of file");
d1955 2
a1956 6
	    int i, len = mbclen(c)-1;

	    for (i = 0; i < len; i++) {
		tokadd(c);
		c = nextc();
	    }
d1959 1
a1959 1
	    ruby_sourceline++;
d1965 1
a1965 1
		ruby_sourceline++;
a1981 5
	if (c == paren) nest++;
	if (c == term) {
	    nest--;
	    if (nest == 0) break;
	}
d1986 1
a1986 1
    yylval.val = rb_str_new(tok(), toklen());
d1988 1
a1988 10
    return tSTRING;
}

static int
parse_quotedword(term, paren)
    int term, paren;
{
    if (parse_qstring(term, paren) == 0) return 0;
    yylval.node = NEW_CALL(NEW_STR(yylval.val), rb_intern("split"), 0);
    return tDSTRING;
d1994 1
a1994 1
here_document(term, indent)
a1995 1
    int indent;
d1998 1
a1998 1
    char *eos, *p;
d2000 2
a2001 4
    VALUE str;
    volatile VALUE line;
    VALUE lastline_save;
    int offset_save;
a2002 1
    int linesave = ruby_sourceline;
a2011 1
	if (term == '\'') term = 0;
d2015 1
a2015 1
	c = term;
d2018 2
a2019 2
	    rb_warn("Use of bare << to mean <<\"\" is deprecated");
	    break;
d2029 3
a2031 2
    lastline_save = lex_lastline;
    offset_save = lex_p - lex_pbeg;
d2035 1
a2035 1
    str = rb_str_new(0,0);
d2037 1
a2037 1
	line = (*lex_gets)(lex_input);
d2040 1
a2040 2
	    ruby_sourceline = linesave;
	    rb_compile_error("can't find string \"%s\" anywhere before EOF", eos);
d2044 3
a2046 9
        normalize_newline(line);
	ruby_sourceline++;
	p = RSTRING(line)->ptr;
	if (indent) {
	    while (*p && (*p == ' ' || *p == '\t')) {
		p++;
	    }
	}
	if (strncmp(eos, p, len) == 0 && p[len] == '\n') {
d2052 5
a2056 11
#if 0
	if (indent) {
	    while (*lex_p && *lex_p == '\t') {
		lex_p++;
	    }
	}
#endif
	switch (parse_string(term, '\n', '\n')) {
	  case tSTRING:
	  case tXSTRING:
	    rb_str_cat(yylval.val, "\n", 1);
d2058 1
a2058 1
	        rb_str_cat(str, RSTRING(yylval.val)->ptr, RSTRING(yylval.val)->len);
d2064 3
a2066 3
	  case tDSTRING:
	  case tDXSTRING:
	    list_append(yylval.node, NEW_STR(rb_str_new2("\n")));
d2079 3
a2081 8
    lex_lastline = lastline_save;
    lex_pbeg = RSTRING(lex_lastline)->ptr;
    lex_pend = lex_pbeg + RSTRING(lex_lastline)->len;
    lex_p = lex_pbeg + offset_save;

    lex_state = EXPR_END;
    heredoc_end = ruby_sourceline;
    ruby_sourceline = linesave;
a2086 1
      case '\0':
d2089 3
a2091 3
	if (list) return tDSTRING;
	yylval.val = str;
	return tSTRING;
d2093 2
a2094 2
	if (list) return tDXSTRING;
	return tXSTRING;
d2104 1
a2104 1
    rb_warning("ambiguous first argument; make sure");
d2119 1
a2119 1
	ruby_sourceline += newline_seen;
d2143 1
a2143 1
		if (c == '\n') ruby_sourceline++;
d2146 4
a2149 8
		int i, len = mbclen(c)-1;

		for (i = 0; i < len; i++) {
		    c = nextc();
		    if (c == '\n') {
			ruby_sourceline++;
			break;
		    }
d2155 2
a2156 5
	switch (lex_state) {
	  case EXPR_BEG:
	  case EXPR_FNAME:
	  case EXPR_DOT:
	    ruby_sourceline++;
a2157 2
	  default:
	    break;
d2167 2
a2168 2
		yylval.id = tPOW;
		return tOP_ASGN;
d2171 1
a2171 1
	    return tPOW;
d2176 1
a2176 1
	    return tOP_ASGN;
d2179 1
a2179 1
	if (lex_state == EXPR_ARG && space_seen && !ISSPACE(c)){
d2182 1
a2182 1
	    return tSTAR;
d2185 1
a2185 2
	    lex_state = EXPR_BEG;
	    return tSTAR;
d2193 1
a2193 1
	    return tNEQ;
d2196 1
a2196 1
	    return tNMATCH;
d2204 1
a2204 1
	    if (strncmp(lex_p, "begin", 5) == 0 && ISSPACE(lex_p[5])) {
d2206 1
a2206 1
		    ruby_sourceline++;
d2210 1
a2210 1
			rb_compile_error("embedded document meets end of file");
d2214 1
a2214 1
		    if (strncmp(lex_p, "end", 3) == 0 && ISSPACE(lex_p[3])) {
d2218 1
a2218 1
		ruby_sourceline++;
d2227 1
a2227 1
		return tEQQ;
d2230 1
a2230 1
	    return tEQ;
d2233 1
a2233 1
	    return tMATCH;
d2236 1
a2236 1
	    return tASSOC;
d2244 2
a2245 1
	    lex_state != EXPR_END && lex_state != EXPR_CLASS &&
d2248 5
a2252 7
	    int indent = 0;
	    if (c2 == '-') {
		indent = 1;
		c2 = nextc();
	    }
	    if (!ISSPACE(c2) && (strchr("\"'`", c2) || is_identchar(c2))) {
		return here_document(c2, indent);
d2259 1
a2259 1
		return tCMP;
d2262 1
a2262 1
	    return tLEQ;
d2266 2
a2267 2
		yylval.id = tLSHFT;
		return tOP_ASGN;
d2270 1
a2270 1
	    return tLSHFT;
d2278 1
a2278 1
	    return tGEQ;
d2282 2
a2283 2
		yylval.id = tRSHFT;
		return tOP_ASGN;
d2286 1
a2286 1
	    return tRSHFT;
d2292 1
a2292 1
	return parse_string(c,c,c);
d2295 1
a2295 1
	return parse_string(c,c,c);
d2298 1
a2298 1
	return parse_qstring(c,c);
d2301 1
a2301 12
	if (lex_state == EXPR_END) {
	    lex_state = EXPR_BEG;
	    return '?';
	}
	c = nextc();
	if (lex_state == EXPR_ARG && ISSPACE(c)){
	    pushback(c);
	    arg_ambiguous();
	    lex_state = EXPR_BEG;
	    return '?';
	}
	if (c == '\\') {
d2307 1
a2307 1
	return tINTEGER;
d2310 1
d2312 1
a2312 7
	    lex_state = EXPR_BEG;
	    if ((c = nextc()) == '=') {
		yylval.id = tANDOP;
		return tOP_ASGN;
	    }
	    pushback(c);
	    return tANDOP;
d2316 1
a2316 2
	    lex_state = EXPR_BEG;
	    return tOP_ASGN;
a2318 10
	if (lex_state == EXPR_ARG && space_seen && !ISSPACE(c)){
	    arg_ambiguous();
	    lex_state = EXPR_BEG;
	    return tAMPER;
	}
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
	    lex_state = EXPR_BEG;
	    return tAMPER;
	}
	lex_state = EXPR_BEG;
d2324 1
a2324 6
	    if ((c = nextc()) == '=') {
		yylval.id = tOROP;
		return tOP_ASGN;
	    }
	    pushback(c);
	    return tOROP;
d2328 1
a2328 1
	    return tOP_ASGN;
d2337 1
a2337 1
		return tUPLUS;
d2345 9
a2353 1
	    return tOP_ASGN;
d2355 2
a2356 2
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
 	    if (ISDIGIT(c)) {
d2361 1
a2361 1
	    return tUPLUS;
d2371 1
a2371 1
		return tUMINUS;
d2379 13
a2391 1
	    return tOP_ASGN;
d2393 2
a2394 2
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
	    if (ISDIGIT(c)) {
d2401 1
a2401 1
	    return tUMINUS;
d2411 1
a2411 1
		return tDOT3;
d2414 1
a2414 1
	    return tDOT2;
d2417 1
a2417 2
	if (!ISDIGIT(c)) {
	    lex_state = EXPR_DOT;
d2442 1
a2442 1
			if (!ISXDIGIT(c)) break;
d2447 2
a2448 2
		    yylval.val = rb_str2inum(tok(), 16);
		    return tINTEGER;
d2459 2
a2460 2
		    yylval.val = rb_str2inum(tok(), 8);
		    return tINTEGER;
d2471 1
a2471 1
		    return tINTEGER;
d2483 1
a2483 1
		    if (seen_point || seen_e) {
d2488 1
a2488 1
			if (!ISDIGIT(c0)) {
d2527 2
a2528 2
		yylval.val = rb_float_new(atof(tok()));
		return tFLOAT;
d2530 2
a2531 2
	    yylval.val = rb_str2inum(tok(), 10);
	    return tINTEGER;
d2543 2
a2544 11
	    if (lex_state == EXPR_BEG) {
		lex_state = EXPR_BEG;
		return tCOLON3;
	    }
	    if (lex_state == EXPR_ARG && space_seen) {
		arg_ambiguous();
		lex_state = EXPR_BEG;
		return tCOLON3;
	    }
	    lex_state = EXPR_DOT;
	    return tCOLON2;
d2547 1
a2547 2
	if (lex_state == EXPR_END || ISSPACE(c)) {
	    lex_state = EXPR_BEG;
a2548 1
	}
d2550 1
a2550 1
	return tSYMBEG;
d2554 1
a2554 1
	    return parse_regx('/', '/');
d2559 1
a2559 1
	    return tOP_ASGN;
d2562 1
a2562 1
	    if (space_seen && !ISSPACE(c)) {
d2565 1
a2565 1
		return parse_regx('/', '/');
d2576 1
a2576 1
	    return tOP_ASGN;
d2582 3
d2600 6
a2605 1
	    c = tLPAREN;
d2617 1
a2617 1
		    return tASET;
d2620 1
a2620 1
		return tAREF;
d2626 1
a2626 1
	    c = tLBRACK;
d2630 1
a2630 1
	    c = tLBRACK;
d2637 1
a2637 1
	    c = tLBRACE;
d2644 1
a2644 1
	    ruby_sourceline++;
a2653 1
	    int paren;
d2657 1
a2657 1
	    if (!ISALNUM(c)) {
d2659 10
a2668 1
		c = 'Q';
d2674 1
a2674 1
		rb_compile_error("unterminated quoted string meets end of file");
a2676 1
	    paren = term;
d2684 1
a2684 1
		return parse_string('"', term, paren);
d2687 1
a2687 4
		return parse_qstring(term, paren);

	      case 'w':
		return parse_quotedword(term, paren);
d2690 1
a2690 1
		return parse_string('`', term, paren);
d2693 1
a2693 1
		return parse_regx(term, paren);
d2696 1
a2696 1
		yyerror("unknown type of %string");
d2702 1
a2702 1
	    return tOP_ASGN;
d2705 1
a2705 1
	    if (space_seen && !ISSPACE(c)) {
d2743 1
a2743 1
	    return tGVAR;
d2752 1
a2752 1
	    return tGVAR;
d2759 1
a2759 1
	    return tBACK_REF;
d2764 1
a2764 1
	    while (ISDIGIT(c)) {
d2771 1
a2771 1
	    return tNTH_REF;
d2794 2
a2795 2
	if (c != '_' && !ISALPHA(c) && !ismbchar(c)) {
	    rb_compile_error("Invalid char '%c' in expression", c);
d2806 1
a2806 2
	    int i, len = mbclen(c)-1;

a2807 4
	    for (i = 0; i < len; i++) {
		c = nextc();
		tokadd(c);
	    }
d2811 1
a2811 1
    if ((c == '!' || c == '?') && is_identchar(tok()[0])) {
d2825 1
a2825 1
	    result = tGVAR;
d2829 1
a2829 1
	    result = tIVAR;
d2832 6
a2837 11
	    if (lex_state != EXPR_DOT) {
		/* See if it is a reserved word.  */
		kw = rb_reserved_word(tok(), toklen());
		if (kw) {
		    enum lex_state state = lex_state;
		    if (lex_state == EXPR_FNAME) {
			yylval.id = rb_intern(kw->name);
		    }
		    lex_state = kw->state;
		    return kw->id[state != EXPR_BEG];
		}
d2840 7
a2846 15
	    if (ISUPPER(tok()[0])) {
		result = tCONSTANT;
	    }
	    else if (toklast() == '!' || toklast() == '?') {
		result = tFID;
	    } else {
		result = tIDENTIFIER;
		if (lex_state == EXPR_FNAME) {
		    lex_state = EXPR_END;
		    if ((c = nextc()) == '=') {
			tokadd(c);
		    }
		    else {
			pushback(c);
		    }
d2849 1
a2849 3
	    if (lex_state == EXPR_BEG ||
		lex_state == EXPR_DOT ||
		lex_state == EXPR_ARG){
d2855 8
d2871 1
a2871 1
rb_str_extend(list, term)
d2875 1
a2875 2
    int c;
    int brace = -1;
d2892 1
a2892 1
    ss = rb_str_new(tok(), toklen());
d2910 1
a2910 1
	    while (ISDIGIT(c)) {
d2929 1
a2929 1
		list_append(list, NEW_STR(rb_str_new2("#$")));
d2949 1
a2949 1
      case '@@':
d2955 1
a2955 2
		int i, len = mbclen(c)-1;

a2956 4
		for (i = 0; i < len; i++) {
		    c = nextc();
		    tokadd(c);
		}
d2978 1
d2990 1
a2990 1
		if (brace != -1) nest++;
d2996 2
a2997 2
		    list_append(list, NEW_STR(rb_str_new2("#")));
		    rb_warning("bad substitution in string");
d2999 1
a2999 1
		    list_append(list, NEW_STR(rb_str_new(tok(), toklen())));
d3020 1
a3020 1
rb_node_newnode(type, a0, a1, a2)
d3028 2
a3029 2
    nd_set_line(n, ruby_sourceline);
    n->nd_file = ruby_sourcefile;
d3038 1
a3038 1
static enum node_type
d3045 1
a3045 1
static int
d3094 1
a3094 1
    if (RTEST(rb_verbose)) {
d3103 1
a3103 1
	    rb_warning("statement not reached");
d3136 1
a3136 1

d3203 1
a3203 1
    return NEW_CALL(node1, tMATCH, NEW_LIST(node2));
a3221 6
    else if (id == k__FILE__) {
	return NEW_STR(rb_str_new2(ruby_sourcefile));
    }
    else if (id == k__LINE__) {
	return NEW_LIT(INT2FIX(ruby_sourceline));
    }
a3222 1
	if (dyna_in_block() && rb_dvar_defined(id)) return NEW_DVAR(id);
d3224 1
d3237 1
a3237 1
    rb_bug("invalid id for gettable");
a3247 1
    value_expr(val);
a3259 6
    else if (id == k__FILE__) {
	yyerror("Can't assign to __FILE__");
    }
    else if (id == k__LINE__) {
	yyerror("Can't assign to __LINE__");
    }
d3261 1
a3261 4
	if (rb_dvar_defined(id)) {
	    lhs = NEW_DASGN(id, val);
	}
	else if (local_id(id) || !dyna_in_block()) {
d3265 2
a3266 2
	    rb_dvar_push(id, 0);
	    lhs = NEW_DASGN_PUSH(id, val);
d3281 1
a3281 1
	rb_bug("bad id for variable");
d3291 1
a3291 1
    return NEW_ARGSCAT(node1, node2);
d3308 1
a3308 1
    return NEW_CALL(recv, tASET, idx);
d3312 1
a3312 1
rb_id_attrset(id)
d3327 3
d3331 1
a3331 1
    return NEW_CALL(recv, rb_id_attrset(id), NEW_LIST(val));
d3335 1
a3335 1
rb_backref_error(node)
d3340 1
a3340 1
	rb_compile_error("Can't set variable $%d", node->nd_nth);
d3343 1
a3343 1
	rb_compile_error("Can't set variable $%c", node->nd_nth);
d3352 1
a3352 1
    if (node == 0) return Qtrue;
d3367 1
a3367 1
	return Qfalse;
d3383 1
a3383 1
	return Qtrue;
a3388 45
static int
assign_in_cond(node)
    NODE *node;
{
    switch (nd_type(node)) {
      case NODE_MASGN:
	yyerror("multiple assignment in conditional");
	return 1;

      case NODE_LASGN:
      case NODE_DASGN:
      case NODE_GASGN:
      case NODE_IASGN:
      case NODE_CASGN:
	break;

      case NODE_NEWLINE:
      default:
	return 0;
    }

    switch (nd_type(node->nd_value)) {
      case NODE_LIT:
      case NODE_STR:
      case NODE_DSTR:
      case NODE_XSTR:
      case NODE_DXSTR:
      case NODE_EVSTR:
      case NODE_DREGX:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
	/* reports always */
	rb_warn("found = in conditional, should be ==");
	return 1;

      default:
	break;
    }
    if (assign_in_cond(node->nd_value) == 0) {
	rb_warning("assignment in condition");
    }
    return 1;
}

a3394 1
    assign_in_cond(node);
a3407 1
	node->nd_cnt = local_append(0);
d3419 1
a3419 1
	    return NEW_MATCH(rb_reg_new(RSTRING(node)->ptr,RSTRING(node)->len,0));
d3430 12
a3441 2
    if (node == 0) return 0;
    if (nd_type(node) == NODE_NEWLINE){
d3444 2
d3447 1
d3461 1
a3461 1
	return call_op(node,tEQ,1,NEW_GVAR(rb_intern("$.")));
a3471 2
    return rb_node_newnode(type, cond(left), cond(right), 0);
}
d3473 1
a3473 10
static NODE *
arg_blk_pass(node1, node2)
    NODE *node1;
    NODE *node2;
{
    if (node2) {
	node2->nd_head = node1;
	return node2;
    }
    return node1;
d3476 1
a3476 24
static NODE*
new_call(r,m,a)
    NODE *r;
    ID m;
    NODE *a;
{
    if (a && nd_type(a) == NODE_BLOCK_PASS) {
	a->nd_iter = NEW_CALL(r,m,a->nd_head);
	return a;
    }
    return NEW_CALL(r,m,a);
}

static NODE*
new_fcall(m,a)
    ID m;
    NODE *a;
{
    if (a && nd_type(a) == NODE_BLOCK_PASS) {
	a->nd_iter = NEW_FCALL(m,a->nd_head);
	return a;
    }
    return NEW_FCALL(m,a);
}
d3503 1
a3503 1
    struct local_vars *local = lvtbl->prev;
d3505 4
a3508 3
    if (lvtbl->tbl) {
	if (!lvtbl->nofree) free(lvtbl->tbl);
	else lvtbl->tbl[0] = lvtbl->cnt;
d3510 1
a3510 2
    free(lvtbl);
    lvtbl = local;
d3521 1
a3521 1
local_append(id)
d3524 9
d3534 1
a3534 1
	lvtbl->tbl = ALLOC_N(ID, 4);
a3535 5
	lvtbl->tbl[1] = '_';
	lvtbl->tbl[2] = '~';
	lvtbl->cnt = 2;
	if (id == '_') return 0;
	if (id == '~') return 1;
a3545 14
local_cnt(id)
    ID id;
{
    int cnt, max;

    if (id == 0) return lvtbl->cnt;

    for (cnt=1, max=lvtbl->cnt+1; cnt<max ;cnt++) {
	if (lvtbl->tbl[cnt] == id) return cnt-1;
    }
    return local_append(id);
}

static int
d3551 3
a3553 3
    if (lvtbl == 0) return Qfalse;
    for (i=3, max=lvtbl->cnt+1; i<max; i++) {
	if (lvtbl->tbl[i] == id) return Qtrue;
d3555 1
a3555 1
    return Qfalse;
d3562 1
a3562 1
    lvtbl->cnt = ruby_scope->local_tbl?ruby_scope->local_tbl[0]:0;
d3564 2
a3565 2
	lvtbl->tbl = ALLOC_N(ID, lvtbl->cnt+3);
	MEMCPY(lvtbl->tbl, ruby_scope->local_tbl, ID, lvtbl->cnt+1);
d3570 1
a3570 1
    if (ruby_dyna_vars)
d3586 1
a3586 1
	    if (i == 0 || ruby_scope->flag == SCOPE_ALLOCA) {
d3588 4
a3591 4
		if (ruby_scope->local_vars) {
		    *vars++ = ruby_scope->local_vars[-1];
		    MEMCPY(vars, ruby_scope->local_vars, VALUE, i);
		    rb_mem_clear(vars+i, len-i);
d3595 1
a3595 1
		    rb_mem_clear(vars, len);
d3597 2
a3598 2
		ruby_scope->local_vars = vars;
		ruby_scope->flag |= SCOPE_MALLOC;
d3601 1
a3601 1
		VALUE *vars = ruby_scope->local_vars-1;
d3603 2
a3604 5
		ruby_scope->local_vars = vars+1;
		rb_mem_clear(ruby_scope->local_vars+i, len-i);
	    }
	    if (ruby_scope->local_tbl && ruby_scope->local_vars[-1] == 0) {
		free(ruby_scope->local_tbl);
d3606 7
a3612 2
	    ruby_scope->local_vars[-1] = 0;
	    ruby_scope->local_tbl = local_tbl();
d3622 1
a3622 1
    return ruby_dyna_vars;
d3630 1
a3630 1
    ruby_dyna_vars = vars;
d3646 1
a3646 1
rb_parser_append_print()
d3648 2
a3649 2
    ruby_eval_tree =
	block_append(ruby_eval_tree,
d3655 1
a3655 1
rb_parser_while_loop(chop, split)
d3659 1
a3659 1
	ruby_eval_tree =
d3663 1
a3663 1
				   ruby_eval_tree);
d3666 1
a3666 1
	ruby_eval_tree =
d3668 1
a3668 1
				  rb_intern("chop!"), 0), ruby_eval_tree);
d3670 1
a3670 1
    ruby_eval_tree = NEW_OPT_N(ruby_eval_tree);
d3673 2
a3674 5
static struct {
    ID token;
    char *name;
} op_tbl[] = {
    tDOT2,	"..",
d3682 5
a3686 5
    tPOW,	"**",
    tUPLUS,	"+@@",
    tUMINUS,	"-@@",
    tUPLUS,	"+(unary)",
    tUMINUS,	"-(unary)",
d3690 1
a3690 1
    tCMP,	"<=>",
d3692 1
a3692 1
    tGEQ,	">=",
d3694 6
a3699 6
    tLEQ,	"<=",
    tEQ,	"==",
    tEQQ,	"===",
    tNEQ,	"!=",
    tMATCH,	"=~",
    tNMATCH,	"!~",
d3706 5
a3710 6
    tAREF,	"[]",
    tASET,	"[]=",
    tLSHFT,	"<<",
    tRSHFT,	">>",
    tCOLON2,	"::",
    tCOLON3,	"::",
d3718 3
a3720 2
static st_table *sym_tbl;
static st_table *sym_rev_tbl;
d3725 3
a3727 2
    sym_tbl = st_init_strtable_with_size(200);
    sym_rev_tbl = st_init_numtable_with_size(200);
d3743 2
a3744 1
    id = 0;
d3752 1
d3754 1
a3754 1
	if (name[0] != '_' && !ISALPHA(name[0]) && !ismbchar(name[0])) {
d3758 6
a3763 5
	    for (i=0; op_tbl[i].token; i++) {
		if (*op_tbl[i].name == *name &&
		    strcmp(op_tbl[i].name, name) == 0) {
		    id = op_tbl[i].token;
		    goto id_regist;
d3766 2
d3769 1
a3769 1

d3778 1
a3778 4
	    if (id > LAST_TOKEN) {
		id = rb_id_attrset(id);
		goto id_regist;
	    }
d3781 2
a3782 2
	else if (ISUPPER(name[0])) {
	    id = ID_CONST;
d3785 1
a3785 1
	    id = ID_LOCAL;
d3789 1
a3789 5
    id |= ++last_id << ID_SCOPE_SHIFT;
  id_regist:
    name = strdup(name);
    st_add_direct(sym_tbl, name, id);
    st_add_direct(sym_rev_tbl, id, name);
d3793 18
d3815 1
a3815 1
    char *name;
d3820 3
a3822 3
	for (i=0; op_tbl[i].token; i++) {
	    if (op_tbl[i].token == id)
		return op_tbl[i].name;
d3826 4
a3829 4
    if (st_lookup(sym_rev_tbl, id, &name))
	return name;

    if (is_attrset_id(id)) {
d3831 1
a3831 1
	ID id2;
d3837 1
a3837 1
	    char *buf = ALLOCA_N(char, strlen(res)+2);
d3845 1
a3845 1
    return 0;
d3852 2
a3853 2
    if (is_const_id(id)) return Qtrue;
    return Qfalse;
d3860 34
a3893 2
    if (is_instance_id(id)) return Qtrue;
    return Qfalse;
d3901 1
a3901 1
    int cnt;
d3903 8
d3914 1
a3914 1
    ruby_scope->local_vars[cnt] = val;
d3918 1
a3918 1
rb_backref_get()
d3920 1
a3920 4
    if (ruby_scope->local_vars) {
	return ruby_scope->local_vars[1];
    }
    return Qnil;
d3924 1
a3924 1
rb_backref_set(val)
d3927 1
a3927 6
    if (ruby_scope->local_vars) {
	ruby_scope->local_vars[1] = val;
    }
    else {
	special_local_set('~', val);
    }
d3931 1
a3931 1
rb_lastline_get()
d3933 3
a3935 4
    if (ruby_scope->local_vars) {
	return ruby_scope->local_vars[0];
    }
    return Qnil;
d3939 1
a3939 1
rb_lastline_set(val)
d3942 1
a3942 6
    if (ruby_scope->local_vars) {
	ruby_scope->local_vars[0] = val;
    }
    else {
	special_local_set('_', val);
    }
@


1.1.1.3.2.1
log
@990126
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:24 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
a1747 4
#ifdef __MACOS__
    else if (RSTRING(line)->ptr[RSTRING(line)->len-1] == '\r')
	RSTRING(line)->ptr[RSTRING(line)->len-1] = '\n';
#endif
@


1.1.1.3.2.2
log
@990201
@
text
@d6 1
a6 1
  $Date: 1999/01/26 10:08:13 $
a20 2
#include <string.h>
#include <errno.h>
a803 4
		| args ','
		    {
			$$ = $1;
		    }
a812 4
		| assocs ','
		    {
			$$ = NEW_LIST(NEW_HASH($1));
		    }
a827 4
		| args ',' assocs ','
		    {
			$$ = list_append($1, NEW_HASH($3));
		    }
d2847 1
a2847 5
		double d = strtod(tok(), 0);
		if (errno == ERANGE) {
		    yyerror("Float out of range");
		}
		yylval.val = rb_float_new(d);
d3430 1
a3430 1
    if (RTEST(ruby_verbose)) {
@


1.1.1.3.2.3
log
@990203
@
text
@d6 1
a6 1
  $Date: 1999/02/01 07:34:56 $
d2032 2
a2033 4
		if (paren)  {
		    if (c == paren) nest++;
		    if (c == term) nest--;
		}
d2177 4
a2180 6
	if (paren) {
	    if (c == paren) nest++;
	    if (c == term) {
		nest--;
		if (nest == 0) break;
	    }
d2255 4
a2258 6
	if (paren) {
	    if (c == paren) nest++;
	    if (c == term) {
		nest--;
		if (nest == 0) break;
	    }
d2619 1
a2619 1
	return parse_qstring(c,0);
d3010 1
a3010 1
	    paren = 0;
@


1.1.1.3.2.4
log
@990205
@
text
@d6 1
a6 1
  $Date: 1999/02/03 09:47:59 $
a1681 1
    heredoc_end = 0;
d2423 2
a2424 2
#ifndef strtod
double strtod ();
d2869 1
a2869 2
		    rb_warn("Float %s out of range", tok());
		    errno = 0;
@


1.1.1.3.2.5
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/02/05 10:27:32 $
d2468 1
a2468 1
			pushback(c);
d2781 1
a2781 5
		    c = nextc();
		    if (!ISXDIGIT(c)) {
			yyerror("hexadecimal number without hex-digits");
		    }
		    do {
d2785 1
a2785 1
		    } while (c = nextc());
d2791 2
a2792 6
		if (c == 'b' || c == 'B') {
		    /* binary */
		    c = nextc();
		    if (c != '0' && c != '1') {
			yyerror("numeric constant with no digits");
		    }
a2793 15
			if (c == '_') continue;
			if (c != '0'&& c != '1') break;
			tokadd(c);
		    } while (c = nextc());
		    pushback(c);
		    tokfix();
		    yylval.val = rb_str2inum(tok(), 2);
		    return tINTEGER;
		}
		else if (c >= '0' && c <= '7' || c == '_') {
		    /* octal */
		    tokadd(c);
	            do {
			if (c  == '_') continue;
			if (c < '0' || c > '7') break;
d2795 3
a2797 1
		    } while (c = nextc());
@


1.1.1.3.2.6
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/02/09 06:08:22 $
d2813 1
@


1.1.1.3.2.7
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/02/09 08:10:57 $
d2811 1
a2811 1
		if (c >= '0' && c <= '7' || c == '_') {
d2823 1
a2823 1
		if (c > '7' && c <= '9') {
@


1.1.1.3.2.8
log
@990212
@
text
@d6 1
a6 1
  $Date: 1999/02/10 08:44:27 $
d2296 1
a2296 1
    volatile VALUE line = 0;
d2335 1
a2335 1
	lex_lastline = line = (*lex_gets)(lex_input);
d2340 2
a2341 2
		free(eos);
		return 0;
d2343 1
a2343 1
	normalize_newline(line);
a2363 1
      retry:
a2386 4
	}
	if (lex_lastline != line) {
	    line = lex_lastline;
	    goto retry;
@


1.1.1.3.2.9
log
@990224
@
text
@d6 1
a6 1
  $Date: 1999/02/12 11:17:05 $
a2477 5
	    else if (c >= 0x80) {
		if ((c = nextc()) != '\\') {
		    pushback(c);
		}
	    }
a3187 7
	if (c == '!') {
	    c = nextc();
	    if (c == '=') {
		rb_warn("identifier! immediately followed by `='");
	    }
	    pushback(c);
	}
@


1.1.1.3.2.10
log
@990225
@
text
@d6 1
a6 1
  $Date: 1999/02/24 04:31:23 $
d1533 1
a1533 1
		| '(' expr opt_nl ')'
d1544 1
a1544 1
			    yyerror("can't define single method for literals.");
d1786 1
a1786 3
		   RSTRING(v)->ptr[RSTRING(v)->len-2] == '\\' &&
		   (RSTRING(v)->len == 2 ||
		    RSTRING(v)->ptr[RSTRING(v)->len-3] != '\\')) {
d2389 2
a2390 1
	if (lex_p != lex_pend) {
d2463 4
d2478 2
a2479 6
	    else if (c == ' ') {
		if ((c = nextc()) == '\\') {
		    c = nextc();
		    if (c == '\n') ruby_sourceline++;
		}
		else {
@


1.1.1.3.2.11
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/25 06:39:08 $
d179 1
a179 1
%type <id>   variable symbol operation operation2
d938 5
a1315 5
		| primary tCOLON2 operation2
		    {
			value_expr($1);
			$$ = new_call($1, $3, 0);
		    }
a1581 3
operation2	: tIDENTIFIER
		| tFID

a1610 1
#ifndef strdup
a1611 1
#endif
d1667 1
d1681 1
d1716 1
a1716 1
    const char *f;
d1724 1
a1724 3
	ruby_sourceline = 0;
    else if (ruby_frame)	                        /* in eval() */
	cur_mid = ruby_frame->last_func;
d1731 1
a1731 1
    const char *f, *s;
d1739 1
a1739 1
    const char *f;
d1746 1
a1746 1
    ruby_sourceline = start - 1;
d1780 1
a1780 1
		ruby_sourceline = heredoc_end;
d1784 12
a1795 1
	    ruby_sourceline++;
d1900 1
a1900 1
	    c = scan_oct(buf, i, &i);
d1917 1
a1917 1
	    c = scan_hex(buf, i, &i);
d1986 3
d2009 1
d2039 4
a2042 1
		if (c == term) {
a2045 1
		    int c1;
d2047 2
a2048 8
		    c1 = read_escape();
		    if (c1 != c) {
			tokadd(c1);
		    }
		    else {
			tokadd('\\');
			tokadd(c);
		    }
a2101 1
		nd_set_line(list, re_start-1);
d2137 1
a2139 1
	lex_p = lex_pend;
d2159 3
d2169 4
a2172 1
	    if (c == term) {
a2193 1

a2194 1
	nd_set_line(list, strstart-1);
d2238 3
d2244 4
a2405 1
	nd_set_line(list, linesave);
d2441 6
a2446 1
  retry:
d2464 20
d2491 1
d2496 1
d2544 1
d2556 1
d2718 1
a2718 2
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID ||
	    (lex_state == EXPR_ARG && space_seen && !ISSPACE(c))) {
a2721 1
	    if (lex_state == EXPR_ARG) arg_ambiguous();
d2744 1
a2744 2
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID ||
	    (lex_state == EXPR_ARG && space_seen && !ISSPACE(c))) {
a2749 1
	    if (lex_state == EXPR_ARG) arg_ambiguous();
d3024 1
a3723 3
    else {
	idx = val;
    }
d4208 3
d4225 1
a4225 1
    const char *name;
@


1.1.1.3.2.12
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:30 $
a64 1
static int compile_for_eval = 0;
d67 1
a73 4
static int value_expr();
static void void_expr();
static void void_stmts();

d77 1
a77 1
static NODE *arg_concat();
a89 1
static NODE *node_assign();
d173 2
a174 2
%type <node> aref_args opt_block_arg block_arg stmt_rhs
%type <node> mrhs opt_list superclass generic_call block_call var_ref
d177 2
a178 2
%type <node> block_var opt_block_var brace_block do_block lhs none
%type <node> mlhs mlhs_head mlhs_tail mlhs_basic mlhs_entry mlhs_item mlhs_node
a242 10
			if ($2) { /* last expression is void */
			    if (nd_type($2) != NODE_BLOCK) void_expr($2);
			    else {
				NODE *node = $2;
				while (node->nd_next) {
				    node = node->nd_next;
				}
				void_expr(node->nd_head);
			    }
			}
d251 2
d254 1
a254 2
			void_stmts($1);
			$$ = $1;
a255 2

stmts		: none
d269 9
a277 1
stmt		: block_call
d347 1
d353 1
a353 1
						            NEW_PREEXE($4));
d359 1
a359 1
			if (compile_for_eval && (cur_mid || in_single)) {
a364 5
		| lhs '=' stmt_rhs
		    {
			value_expr($3);
			$$ = node_assign($1, $3);
		    }
d376 1
a376 1
			if (!compile_for_eval && !cur_mid && !in_single)
d425 1
a425 1
			if (!compile_for_eval && !cur_mid && !in_single)
d459 1
a459 1
		| tSTAR mlhs_node
d464 1
a464 1
mlhs_item	: mlhs_node
a483 18
mlhs_node	: variable
		    {
			$$ = assignable($1, 0);
		    }
		| primary '[' aref_args ']'
		    {
			$$ = aryset($1, $3);
		    }
		| primary '.' tIDENTIFIER
		    {
			$$ = attrset($1, $3);
		    }
		| backref
		    {
		        rb_backref_error($1);
			$$ = 0;
		    }

d490 1
a490 1
			$$ = aryset($1, $3);
d494 1
a494 1
			$$ = attrset($1, $3);
d567 24
a590 1
arg		: lhs '=' arg
d593 2
a594 1
			$$ = node_assign($1, $3);
d795 4
a798 1
opt_call_args	: none
d816 1
a816 1
			$$ = arg_concat($1, $4);
d830 1
a830 1
			$$ = arg_concat(NEW_LIST(NEW_HASH($1)), $4);
d844 1
a844 1
			$$ = arg_concat(list_append($1, NEW_HASH($3)), $6);
d864 4
a867 1
		| none
d870 4
a873 1
		| none
d901 1
a901 1
			$$ = arg_concat($1, $4);
d923 4
a926 1
array		: none
d974 1
a974 1
			if (!compile_for_eval && !cur_mid && !in_single)
d981 1
a981 1
			if (!compile_for_eval && !cur_mid && !in_single)
d987 1
a987 1
			if (!compile_for_eval && !cur_mid && !in_single)
d1013 1
a1013 1
		| operation brace_block
d1019 1
a1019 1
		| method_call brace_block
d1070 1
a1070 1
		| kFOR block_var kIN expr do
d1219 4
a1222 1
opt_else	: none
d1228 1
a1228 1
block_var	: lhs
d1231 4
a1234 1
opt_block_var	: none
d1243 1
a1243 1
		| '|' block_var '|'
d1248 1
a1248 1
do_block	: kDO
d1252 1
a1252 1
		  opt_block_var
d1261 1
a1261 1
brace_block	: '{'
d1265 1
a1265 1
		  opt_block_var
d1273 1
a1273 1
generic_call	: tIDENTIFIER
a1287 10
block_call	: generic_call do_block
		    {
			if ($1 && nd_type($1) == NODE_BLOCK_PASS) {
			    rb_compile_error("both block arg and actual block given");
			}
			$2->nd_iter = $1;
			$$ = $2;
		        fixpos($$, $2);
		    }

d1318 1
a1318 2
			if (!compile_for_eval && !cur_mid &&
		            !in_single && !in_defined)
d1324 1
a1324 2
			if (!compile_for_eval && !cur_mid &&
		            !in_single && !in_defined)
a1329 3
stmt_rhs	: block_call
		| command_call

d1359 4
a1362 1
		| none
d1364 4
a1367 1
ensure		: none
d1515 4
a1518 1
		| none
d1551 4
a1554 1
assoc_list	: none
a1602 5

none		: /* none */
		    {
			$$ = 0;
		    }
a1688 1
    compile_for_eval = 0;
d1728 2
a1729 2
    else			                        /* in eval() */
	compile_for_eval = 1;
d1757 17
d1788 1
d2303 1
a2303 1
	    rb_warn("use of bare << to mean <<\"\" is deprecated");
d2329 1
d2475 1
d2603 1
d2632 1
d2679 1
d2709 1
d2885 1
d2969 1
a2982 4
	if (c == '\r') {
	    c = nextc();
	    if (c != '\n') pushback(c);
	}
d3039 5
a3043 2
	if (lex_state == EXPR_ARG && space_seen && !ISSPACE(c)) {
	    goto quotation;
d3662 10
a3671 2
aryset(recv, idx)
    NODE *recv, *idx;
d3674 12
a3685 1

d3699 2
a3700 2
attrset(recv, id)
    NODE *recv;
d3704 1
d3706 1
a3706 1
    return NEW_CALL(recv, rb_id_attrset(id), 0);
a3722 53
static NODE *
arg_concat(node1, node2)
    NODE *node1;
    NODE *node2;
{
    return NEW_ARGSCAT(node1, node2);
}

static NODE *
arg_add(node1, node2)
    NODE *node1;
    NODE *node2;
{
    if (!node1) return NEW_LIST(node2);
    if (nd_type(node1) == NODE_ARRAY) {
	return list_append(node1, node2);
    }
    else {
	return NEW_ARGSCAT(node1, node2);
    }
}

static NODE*
node_assign(lhs, rhs)
    NODE *lhs, *rhs;
{
    if (!lhs) return 0;

    value_expr(rhs);
    switch (nd_type(lhs)) {
      case NODE_GASGN:
      case NODE_IASGN:
      case NODE_LASGN:
      case NODE_DASGN:
      case NODE_DASGN_PUSH:
      case NODE_CASGN:
      case NODE_MASGN:
	lhs->nd_value = rhs;
	break;

      case NODE_CALL:
	lhs->nd_args = arg_add(lhs->nd_args, rhs);
	break;

      default:
	/* should not happen */
	break;
    }

    if (rhs) fixpos(lhs, rhs);
    return lhs;
}

a3761 117
static void
void_expr(node)
    NODE *node;
{
    char *useless = 0;

    if (!ruby_verbose) return;
    if (!node) return;

  again:
    switch (nd_type(node)) {
      case NODE_NEWLINE:
	node = node->nd_next;
	goto again;

      case NODE_CALL:
	switch (node->nd_mid) {
	  case '+':
	  case '-':
	  case '*':
	  case '/':
	  case '%':
	  case tPOW:
	  case tUPLUS:
	  case tUMINUS:
	  case '|':
	  case '^':
	  case '&':
	  case tCMP:
	  case '>':
	  case tGEQ:
	  case '<':
	  case tLEQ:
	  case tEQ:
	  case tEQQ:
	  case tNEQ:
	  case tMATCH:
	  case tNMATCH:
	  case tAREF:
	  case tRSHFT:
	  case tCOLON2:
	  case tCOLON3:
	    useless = rb_id2name(node->nd_mid);
	    break;
	}
	break;

      case NODE_LVAR:
      case NODE_DVAR:
      case NODE_GVAR:
      case NODE_IVAR:
      case NODE_NTH_REF:
      case NODE_BACK_REF:
	useless = "a variable";
	break;
      case NODE_CVAR:
      case NODE_CREF:
	useless = "a constant";
	break;
      case NODE_LIT:
      case NODE_STR:
      case NODE_DSTR:
      case NODE_DREGX:
      case NODE_DREGX_ONCE:
	useless = "a literal";
	break;
      case NODE_COLON2:
      case NODE_COLON3:
	useless = "::";
	break;
      case NODE_DOT2:
	useless = "..";
	break;
      case NODE_DOT3:
	useless = "...";
	break;
      case NODE_SELF:
	useless = "self";
	break;
      case NODE_NIL:
	useless = "nil";
	break;
      case NODE_TRUE:
	useless = "true";
	break;
      case NODE_FALSE:
	useless = "false";
	break;
      case NODE_DEFINED:
	useless = "defined?";
	break;
    }

    if (useless) {
	int line = ruby_sourceline;

	ruby_sourceline = nd_line(node);
	rb_warn("useless use of %s in void context", useless);
	ruby_sourceline = line;
    }
}

static void
void_stmts(node)
    NODE *node;
{
    if (!ruby_verbose) return;
    if (!node) return;
    if (nd_type(node) != NODE_BLOCK) return;

    for (;;) {
	if (!node->nd_next) return;
	void_expr(node->nd_head);
	node = node->nd_next;
    }
}

a4128 1
    tDOT3,	"...",
@


1.1.1.3.2.13
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/04/09 17:57:41 $
d248 1
a248 2
			if ($2 && !compile_for_eval) {
                            /* last expression should not be void */
d1715 1
a1715 1
rb_compile_string(f, s, line)
a1717 1
    int line;
d1723 4
a1726 2
    ruby_sourceline = line;
    compile_for_eval = 1;
d1732 1
a1732 1
rb_compile_cstr(f, s, len, line)
d1734 1
a1734 1
    int len, line;
d1736 1
a1736 1
    return rb_compile_string(f, rb_str_new(s, len), line);
d3801 1
d3803 2
@


1.1.1.3.2.14
log
@remove strdup
@
text
@d6 1
a6 1
  $Date: 1999/04/12 09:59:31 $
d21 1
d1611 1
a1611 1
#ifndef HAVE_STRDUP
d1725 1
a1725 1
    ruby_sourceline = line - 1;
d2075 1
a2075 1
		nd_set_line(list, re_start);
d2164 1
a2164 1
	nd_set_line(list, strstart);
d2250 2
d2368 1
a2368 1
	nd_set_line(list, linesave+1);
@


1.1.1.3.2.15
log
@to open CVS
@
text
@d6 1
a6 1
  $Date: 1999/04/13 05:12:04 $
d1610 4
a2048 3
		  case 'p':
		    options |= RE_OPTION_POSIX;
		    break;
d2053 1
a2053 1
		    kcode = 8;
d2056 1
a2056 1
		    kcode = 16;
d2059 1
a2059 1
		    kcode = 24;
d2062 1
a2062 1
		    kcode = 32;
@


1.1.1.3.2.16
log
@aix shlib link
@
text
@d6 1
a6 1
  $Date: 1999/04/20 08:21:39 $
d57 2
a58 1
    EXPR_FNAME,			/* ignore newline, no reserved words. */
d183 1
a183 1
%type <id>   variable symbol operation operation2 operation3
d423 1
a423 1
		| primary '.' operation2 call_args
d429 1
a429 1
		| primary tCOLON2 operation2 call_args
d546 5
d589 8
d1291 1
a1291 1
		| primary '.' operation2 '(' opt_call_args ')'
d1297 1
a1297 1
		| primary '.' operation2
d1303 1
a1303 1
		| primary tCOLON2 operation2 '(' opt_call_args ')'
d1309 1
a1309 1
		| primary tCOLON2 operation3
a1372 1
		        lex_state = EXPR_END;
a1573 1
		| tCONSTANT
a1574 5
		| op

operation3	: tIDENTIFIER
		| tFID
		| op
d2424 1
d2698 1
a2698 1
	    lex_state = EXPR_FNAME;
d2857 1
a2857 1
	    lex_state = EXPR_FNAME;
d3147 1
a3147 1
	    if (lex_state != EXPR_FNAME) {
d3152 3
d3168 1
a3168 1
		    /* lex_state = EXPR_END; */
d3178 1
a3178 1
		lex_state == EXPR_FNAME ||
@


1.1.1.3.2.17
log
@def self.foo; end
@
text
@d6 1
a6 1
  $Date: 1999/04/26 09:42:39 $
a57 1
    EXPR_DOT,			/* right after `.' or `::', no reserved words. */
a544 5
		| reswords
		    {
			lex_state = EXPR_END;
			$$ = $<id>1;
		    }
a582 8
reswords	: k__LINE__ | k__FILE__ | klBEGIN | klEND
		| kALIAS | kAND | kBEGIN | kBREAK | kCASE | kCLASS | kDEF
		| kDEFINED | kDO | kELSE | kELSIF | kEND | kENSURE | kFALSE
		| kFOR | kIF_MOD | kIN | kMODULE | kNEXT | kNIL | kNOT
		| kOR | kREDO | kRESCUE | kRETRY | kRETURN | kSELF | kSUPER
		| kTHEN | kTRUE | kUNDEF | kUNLESS_MOD | kUNTIL_MOD | kWHEN
		| kWHILE_MOD | kYIELD

d1514 1
a1514 1
		| '(' {lex_state = EXPR_BEG;} expr opt_nl ')'
d1516 1
a1516 1
			switch (nd_type($3)) {
d1529 1
a1529 1
			$$ = $3;
a2416 1
	  case EXPR_DOT:
a2554 1
	if (lex_state == EXPR_DOT) return c;
d2625 1
a2625 1
	if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
d2652 1
a2652 1
	if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
d2690 1
a2690 1
	    lex_state = EXPR_DOT;
d2849 1
a2849 1
	    lex_state = EXPR_DOT;
d2895 1
a2895 1
	if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
d2914 1
a2914 1
	if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
d3139 1
a3139 1
	    if (lex_state != EXPR_DOT) {
a3144 3
		    if (state == EXPR_FNAME) {
			yylval.id = rb_intern(kw->name);
		    }
@


1.1.1.3.2.18
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/04/27 07:03:31 $
d3175 2
a3176 1
		if (lex_state == EXPR_FNAME || lex_state == EXPR_DOT) {
d3186 1
a3186 1
		lex_state == EXPR_DOT ||
@


1.1.1.3.2.19
log
@small fixes
@
text
@d6 1
a6 1
  $Date: 1999/04/27 07:11:46 $
d2053 1
a2053 1
		    options |= RE_OPTION_POSIXLINE;
a2144 2
	    if (c == '\n')
		continue;
a2215 3
	      case '\n':
		continue;

@


1.1.1.3.2.20
log
@arity/strict yield
@
text
@d6 1
a6 1
  $Date: 1999/05/06 08:31:40 $
d1885 2
a1886 4
		int cc = nextc();

		if (cc == -1) goto eof;
		buf[i] = cc;
@


1.1.1.3.2.21
log
@regexp null pattern
@
text
@d6 1
a6 1
  $Date: 1999/05/17 09:54:12 $
a462 4
		| mlhs_head tSTAR
		    {
			$$ = NEW_MASGN(NEW_LIST($1), -1);
		    }
a470 4
		| mlhs_head mlhs_tail ',' tSTAR
		    {
			$$ = NEW_MASGN(list_concat(NEW_LIST($1),$2),-1);
		    }
a474 4
		| tSTAR
		    {
			$$ = NEW_MASGN(0, -1);
		    }
a1502 4
		| tSTAR
		    {
			$$ = -2;
		    }
d1612 1
a1612 1
#define is_identchar(c) (((int)(c))!=-1&&(ISALNUM(c) || (c) == '_' || ismbchar(c)))
a2015 1
#if 0
a2025 4
#else
		    tokadd('\\');
		    tokadd(c);
#endif
@


1.1.1.3.2.22
log
@990531
@
text
@d6 1
a6 1
  $Date: 1999/05/25 08:26:10 $
a1626 3
#ifndef strdup
char *strdup();
#endif
d1771 1
d4186 1
a4186 1
	i = ruby_scope->local_tbl?ruby_scope->local_tbl[0]:0;
@


1.1.1.3.2.23
log
@rb_exec_end_proc, etc.
@
text
@d6 1
a6 1
  $Date: 1999/05/31 09:13:22 $
d22 5
@


1.1.1.3.2.24
log
@thread bugs
@
text
@d6 1
a6 1
  $Date: 1999/06/01 06:59:15 $
a50 1
    EXPR_PAREN,			/* almost like EXPR_END, `do' works as `{'. */
a141 1
	kDO2
a1266 13
		| kDO2
		    {
		        $<vars>$ = dyna_push();
		    }
		  opt_block_var
		  compstmt
		  kEND
		    {
			$$ = NEW_ITER($3, 0, $4);
		        fixpos($$, $3?$3:$4);
			dyna_pop($<vars>2);
		    }

d1293 1
a1293 1
method_call	: operation '(' opt_call_args close_paren
d1298 1
a1298 1
		| primary '.' operation2 '(' opt_call_args close_paren
d1310 1
a1310 1
		| primary tCOLON2 operation2 '(' opt_call_args close_paren
d1321 1
a1321 1
		| kSUPER '(' opt_call_args close_paren
a1335 4
close_paren	: ')'
		    {
			lex_state = EXPR_PAREN;
		    }
a1703 3
    class_nest = 0;
    in_single = 0;
    cur_mid = 0;
d1912 1
a1912 1
	return '\010';
d2543 1
a2543 2
	    lex_state != EXPR_END && lex_state != EXPR_PAREN && 
	    lex_state != EXPR_CLASS &&
d2602 1
a2602 1
	if (lex_state == EXPR_END || lex_state == EXPR_PAREN) {
d2894 1
a2894 1
	if (lex_state == EXPR_END || lex_state == EXPR_PAREN || ISSPACE(c)) {
d2976 1
a2976 3
	if (lex_state != EXPR_END &&
	    lex_state != EXPR_PAREN &&
	    lex_state != EXPR_ARG)
a3187 3
		    }
		    if (state == EXPR_PAREN && kw->id[0] == kDO) {
			return kDO2;
@


1.1.1.3.2.25
log
@990624
@
text
@d6 1
a6 1
  $Date: 1999/06/09 09:21:26 $
a57 1
static int cond_nest = 0;
a211 2
%nonassoc kDO
%nonassoc kDO2
d703 1
a703 6
			if (nd_type($2) == NODE_LIT) {
			    $$ = $2;
			}
			else {
			    $$ = call_op($2, tUPLUS, 0);
			}
d707 1
a707 9
			if (nd_type($2) == NODE_LIT && FIXNUM_P($2->nd_lit)) {
			    long i = FIX2LONG($2->nd_lit);

			    $2->nd_lit = INT2FIX(-i);
			    $$ = $2;
			}
			else {
			    $$ = call_op($2, tUMINUS, 0);
			}
d1049 1
a1049 1
		| kWHILE {cond_nest++;} expr do {cond_nest--;} 
d1053 3
a1055 3
			value_expr($3);
			$$ = NEW_WHILE(cond($3), $6, 1);
		        fixpos($$, $3);
d1057 1
a1057 1
		| kUNTIL {cond_nest++;} expr do {cond_nest--;} 
d1061 3
a1063 3
			value_expr($3);
			$$ = NEW_UNTIL(cond($3), $6, 1);
		        fixpos($$, $3);
d1073 1
a1073 1
		| kFOR block_var kIN {cond_nest++;} expr do {cond_nest--;}
d1078 1
a1078 1
			$$ = NEW_FOR($2, $5, $8);
d1353 1
a1353 2
			if (cond_nest == 0)
			    lex_state = EXPR_PAREN;
a1722 1
    cond_nest = 0;
d1980 1
a1980 1
    int term, paren;
d1993 1
a1993 1
	if (!in_brack && c == term && nest == 0) {
d2043 4
d2051 12
d2065 1
a2074 4
	    if (paren && !in_brack)  {
	      if (c == paren) nest++;
	      if (c == term) nest--;
	    }
d2201 4
a2204 1
	    if (c == term && nest-- == 0) break;
d2279 4
a2282 1
	    if (c == term && nest-- == 0) break;
a2390 2
	    if (!list) list = NEW_DSTR(str);
	    /* fall through */
a2391 2
	    if (!list) list = NEW_DXSTR(str);

d2394 1
a2429 1
	yylval.val = str;
d2730 5
d3037 1
a3037 1
	    paren = term;
a3041 1
	    else paren = 0;
@


1.1.1.3.2.26
log
@990625
@
text
@d6 1
a6 1
  $Date: 1999/06/24 04:23:57 $
d183 1
a183 1
%type <num>  f_norm_arg f_arg
d1508 1
a1508 1
f_norm_arg	: tIDENTIFIER
a1511 2
			else if (local_id($1))
			    yyerror("duplicate argument name");
d1515 1
a1515 3

f_arg		: f_norm_arg
		| f_arg ',' f_norm_arg
d1517 3
a1526 2
			else if (local_id($1))
			    yyerror("duplicate optional argument name");
a1543 2
			else if (local_id($2))
			    yyerror("duplicate rest argument name");
d2706 3
d3168 1
d3329 1
a3329 15

	while (is_identchar(c)) {
	    tokadd(c);
	    if (ismbchar(c)) {
		int i, len = mbclen(c)-1;

		for (i = 0; i < len; i++) {
		    c = nextc();
		    tokadd(c);
		}
	    }
	    c = nextc();
	}
	pushback(c);
	break;
d3339 1
@


1.1.1.3.2.27
log
@990715
@
text
@d6 1
a6 1
  $Date: 1999/06/25 09:02:42 $
d181 1
a181 1
%type <id>   fitem variable sym symbol operation operation2 operation3
d286 1
a286 1
		| kALIAS fitem {lex_state = EXPR_FNAME;} fitem
d564 1
a564 4
fitem		: fname
		| symbol

undef_list	: fitem
d568 1
a568 1
		| undef_list ',' {lex_state = EXPR_FNAME;} fitem
d1414 1
a1414 1
		| symbol
d1416 2
a1417 1
			$$ = INT2FIX($1);
d1421 1
a1421 7
symbol		: tSYMBEG sym
		    {
		        lex_state = EXPR_END;
			$$ = $2;
		    }

sym		: fname
a1424 1

a1813 3
#if defined(__GNUC__) && __GNUC__ >= 2
__inline__
#endif
@


1.1.1.3.2.28
log
@990728
@
text
@d6 1
a6 1
  $Date: 1999/07/15 07:59:48 $
d4192 1
a4192 1
    for (cnt=1, max=lvtbl->cnt+1; cnt<max;cnt++) {
@


1.1.1.3.2.29
log
@1.3.8 to be, final beta (hopefully)
@
text
@d6 1
a6 1
  $Date: 1999/07/28 09:26:43 $
a1867 2
#define peek(c) (lex_p != lex_pend && (c) == *lex_p)

d3189 1
a3189 1
    if ((c == '!' || c == '?') && is_identchar(tok()[0]) && !peek('=')) {
d3191 7
d3241 1
a3241 1
		    if ((c = nextc()) == '=' && !peek('=')) {
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:13:16 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@Tue Jan 20 15:08:03 JST 1998
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:47 $
d178 2
a179 2
%token UPLUS 		/* unary+ */
%token UMINUS 		/* unary- */
d458 4
@


1.1.1.2.2.3
log
@syntax changed: open paren after identifier
@
text
@d6 1
a6 1
  $Date: 1998/01/20 06:10:10 $
a1986 9
static int
parse_quotedword(term)
    int term;
{
    if (parse_qstring(term) == 0) return 0;
    yylval.node = NEW_CALL(NEW_STR(yylval.val), rb_intern("split"), 0);
    return DSTRING;
}

d2599 5
a2684 3
	      case 'w':
		return parse_quotedword(term);

d2692 1
a2692 1
		yyerror("unknown type of %string");
@


1.1.1.2.2.4
log
@here doc line number
@
text
@d6 1
a6 1
  $Date: 1998/01/21 06:34:30 $
a2048 1
	sourceline++;
d2057 1
@


1.1.1.2.2.5
log
@__FILE__,__LINE__
@
text
@d6 1
a6 1
  $Date: 1998/01/22 07:57:42 $
a160 2
	k__LINE__
	k__FILE__
a1234 2
		| k__FILE__ {$$ = k__FILE__;}
		| k__LINE__ {$$ = k__LINE__;}
a3224 6
    else if (id == k__FILE__) {
	return NEW_STR(str_new2(sourcefile));
    }
    else if (id == k__LINE__) {
	return NEW_LIT(INT2FIX(sourceline));
    }
a3261 6
    }
    else if (id == k__FILE__) {
	yyerror("Can't assign to __FILE__");
    }
    else if (id == k__LINE__) {
	yyerror("Can't assign to __LINE__");
@


1.1.1.2.2.6
log
@1.1b7 pre
@
text
@d6 1
a6 1
  $Date: 1998/02/02 04:49:12 $
a212 1
%right '?' ':'
a696 6
		| arg '?' arg ':' arg
		    {
			value_expr($1);
			$$ = NEW_IF(cond($1), $3, $5);
		        fixpos($$, $1);
		    }
d978 3
d1260 1
a1260 1
		| error term {yyerrok; $$ = 0}
d2310 1
a2310 14
	if (lex_state == EXPR_END) {
	    Warning("a?b:c is undocumented feature ^^;;;");
	    lex_state = EXPR_BEG;
	    return '?';
	}
	c = nextc();
	if (lex_state == EXPR_ARG && space_seen && isspace(c)){
	    pushback(c);
	    arg_ambiguous();
	    lex_state = EXPR_BEG;
	    Warning("a?b:c is undocumented feature ^^;;;");
	    return '?';
	}
	if (c == '\\') {
a2390 1
	    Warning("-> is undocumented feature ^^;;;");
d2556 1
a2556 2
	if (lex_state == EXPR_END || isspace(c)) {
	    lex_state = EXPR_BEG;
a2557 1
	}
d2591 3
@


1.1.1.2.2.7
log
@\s and assignment in conditional
@
text
@d6 1
a6 1
  $Date: 1998/02/09 10:56:22 $
a1686 3
      case 's':	/* space */
	return ' ';

a1769 2
	      case '^':		/* no \^ escape in regexp */
	      case 's':
d1771 1
a1771 1
		tokadd(c);
d1782 5
d2320 1
a2320 1
	if (lex_state == EXPR_ARG && isspace(c)){
d3462 2
a3463 2
int
assign_in_cond(node)
d3466 3
a3468 1
    switch (nd_type(node)) {
a3469 3
	Error("multiple assignment in conditional");
	return 0;

a3474 20
	break;
      default:
	return 1;
    }

    switch (nd_type(node->nd_value)) {
      case NODE_LIT:
      case NODE_STR:
      case NODE_DSTR:
      case NODE_XSTR:
      case NODE_DXSTR:
      case NODE_EVSTR:
      case NODE_DREGX:
      case NODE_NIL:
      case NODE_TRUE:
      case NODE_FALSE:
	Error("found = in conditional, should be ==");
	return 0;
	
      default:
d3477 1
a3477 12
    }
    if (assign_in_cond(node->nd_value)) return 1;
}

static NODE*
cond(node)
    NODE *node;
{
    enum node_type type = nd_type(node);

    if (assign_in_cond(node) == 0) return 0;
    if (nd_type(node) == NODE_NEWLINE){
d3480 2
d3483 1
@


1.1.1.2.2.8
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/02/13 09:40:28 $
a194 1
%token COLON3           /* :: at EXPR_BEG */
a810 1
			value_expr($1);
a812 4
		| COLON3 cname
		    {
			$$ = NEW_COLON3($2);
		    }
d1264 1
a1264 1
		| error term {yyerrok; $$ = 0;}
a2569 5
	    if (lex_state == EXPR_BEG ||
		(lex_state == EXPR_ARG && space_seen)) {
		lex_state = EXPR_BEG;
		return COLON3;
	    }
d3425 37
a3476 2
      case NODE_NEWLINE:

d3503 1
a3503 1
cond0(node)
a3508 36
    switch (type) {
      case NODE_DREGX:
      case NODE_DREGX_ONCE:
	local_cnt('_');
	local_cnt('~');
	return NEW_MATCH2(node, NEW_GVAR(rb_intern("$_")));

      case NODE_DOT2:
      case NODE_DOT3:
	node->nd_beg = cond2(node->nd_beg);
	node->nd_end = cond2(node->nd_end);
	if (type == NODE_DOT2) nd_set_type(node,NODE_FLIP2);
	else if (type == NODE_DOT3) nd_set_type(node, NODE_FLIP3);
	return node;

      case NODE_LIT:
	if (TYPE(node->nd_lit) == T_REGEXP) {
	    local_cnt('_');
	    local_cnt('~');
	    return NEW_MATCH(node);
	}
	if (TYPE(node->nd_lit) == T_STRING) {
	    local_cnt('_');
	    local_cnt('~');
	    return NEW_MATCH(reg_new(RSTRING(node)->ptr,RSTRING(node)->len,0));
	}
      default:
	return node;
    }
}

static NODE*
cond(node)
    NODE *node;
{
    if (node == 0) return 0;
@


1.1.1.2.2.9
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:40 $
d306 1
a306 2
			$$ = NEW_IF(cond($3), $1, 0);
		        fixpos($$, $3);
d311 1
a311 2
			$$ = NEW_UNLESS(cond($3), $1, 0);
		        fixpos($$, $3);
@


1.1.1.2.2.10
log
@1.1b8pre2
@
text
@d6 1
a6 1
  $Date: 1998/02/20 02:10:29 $
a2102 1
    lex_state = EXPR_END;
@


1.1.1.2.2.11
log
@dyna_var,regex,line cotinuation
@
text
@d6 1
a6 1
  $Date: 1998/02/20 08:28:45 $
a1566 8
	    while (RSTRING(v)->ptr[RSTRING(v)->len-1] == '\n' &&
		   RSTRING(v)->ptr[RSTRING(v)->len-2] == '\\') {
		VALUE v2 = io_gets(lex_input);

		if (!NIL_P(v2)) {
		    str_cat(v, RSTRING(v2)->ptr, RSTRING(v2)->len);
		}
	    }
d3315 1
a3315 3
	    if (!dyna_var_defined(id)) {
		dyna_var_asgn(id, TRUE);
	    }
@


1.1.1.2.2.12
log
@reserved words & etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/24 03:55:01 $
d61 2
a62 3
    EXPR_FNAME,			/* ignore newline, +/- is a operator, no reserved words. */
    EXPR_DOT,			/* immediate after `.', no reserved words. */
    EXPR_CLASS,			/* immediate after `class', no here document. */
a2461 1
	    lex_state = EXPR_DOT;
d2878 6
a2883 8
	    if (lex_state != EXPR_FNAME && lex_state != EXPR_DOT) {
		/* See if it is a reserved word.  */
		kw = rb_reserved_word(tok(), toklen());
		if (kw) {
		    enum lex_state state = lex_state;
		    lex_state = kw->state;
		    return kw->id[state != EXPR_BEG];
		}
d2895 1
a2895 1
	    else if (lex_state == EXPR_BEG || lex_state == EXPR_DOT){
@


1.1.1.2.2.13
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/02/25 06:52:42 $
a487 5
		| reswords
		    {
			lex_state = EXPR_END;
			$$ = $<id>1;
		    }
a525 8
reswords	: k__LINE__ | k__FILE__ | klBEGIN | klEND
		| kALIAS | kAND | kBEGIN | kBREAK | kCASE | kCLASS | kDEF
		| kDEFINED | kDO | kELSE | kELSIF | kEND | kENSURE | kFALSE
		| kFOR | kIF_MOD | kIN | kMODULE | kNEXT | kNIL | kNOT
		| kOR | kREDO | kRESCUE | kRETRY | kRETURN | kSELF | kSUPER
		| kTHEN | kTRUE | kUNDEF | kUNLESS_MOD | kUNTIL_MOD | kWHEN
		| kWHILE_MOD | kYIELD

d2589 2
a2590 1
	    if (lex_state == EXPR_BEG) {
d2594 1
a2594 6
	    if (lex_state == EXPR_ARG && space_seen) {
		arg_ambiguous();
		lex_state = EXPR_BEG;
		return COLON3;
	    }
	    lex_state = EXPR_DOT;
d2880 1
a2880 1
	    if (lex_state != EXPR_DOT) {
a2885 3
		    if (lex_state == EXPR_FNAME) {
			yylval.id = rb_intern(kw->name);
		    }
@


1.1.1.2.2.14
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/02/26 07:43:10 $
d2902 1
a2905 1
		    lex_state = kw->state;
@


1.1.1.2.2.15
log
@block arg etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/26 08:22:02 $
a83 4
static NODE *arg_blk_pass();
static NODE *new_call();
static NODE *new_fcall();

d172 3
a174 5
%type <node> if_tail opt_else case_body cases rescue ensure
%type <node> opt_call_args call_args ret_args args
%type <node> aref_args opt_block_arg block_arg
%type <node> mrhs opt_list superclass iterator var_ref
%type <node> f_arglist f_args f_optarg f_opt f_block_arg opt_f_block_arg
d178 2
a179 2
%type <id>   variable symbol operation
%type <id>   cname fname op f_rest_arg
d199 1
a203 1
%token AMPER            /* & */
a267 3
			if ($1 && nd_type($1) == NODE_BLOCK_PASS) {
			    Error("both block arg and actual block given");
			}
d399 1
a399 1
command_call	: operation call_args
d401 1
a401 1
			$$ = new_fcall($1, $2);
d404 1
a404 1
		| primary '.' operation call_args
d407 1
a407 1
			$$ = new_call($1, $3, $4);
d410 1
a410 1
		| primary COLON2 operation call_args
d413 1
a413 1
			$$ = new_call($1, $3, $4);
d416 1
a416 1
		| kSUPER call_args
d460 1
a460 1
		| primary '[' aref_args ']'
d545 1
a545 1
		| primary '[' aref_args ']' '=' arg
d569 1
a569 1
		| primary '[' aref_args ']' OP_ASGN arg
d726 1
a726 9
aref_args	: opt_call_args
		    {
			if ($1 && nd_type($1) == NODE_BLOCK_PASS) {
			    Error("block argument should not be given");
			}
			$$ = $1;
		    }

opt_call_args	: /* none */
d730 1
a730 1
		| call_args opt_nl
d732 1
a732 1
call_args	: command_call
d737 2
a738 5
		| args opt_block_arg
		    {
			$$ = arg_blk_pass($1, $2);
		    }
		| args ',' STAR arg opt_block_arg
a740 1
			$$ = arg_blk_pass($$, $5);
d742 1
a742 1
		| assocs opt_block_arg
a744 1
			$$ = arg_blk_pass($$, $2);
d746 1
a746 1
		| assocs ',' STAR arg opt_block_arg
d748 2
a749 2
			$$ = arg_add(NEW_LIST(NEW_HASH($1)), $4);
			$$ = arg_blk_pass($$, $5);
d751 1
a751 1
		| args ',' assocs opt_block_arg
a753 1
			$$ = arg_blk_pass($$, $4);
d755 1
a755 1
		| args ',' assocs ',' STAR arg opt_block_arg
d757 2
a758 2
			$$ = arg_add(list_append($1, NEW_HASH($3)), $6);
			$$ = arg_blk_pass($$, $7);
d760 1
a760 8
		| STAR arg opt_block_arg
		    {
			value_expr($2);
			$$ = arg_blk_pass($2, $3);
		    }
		| block_arg

block_arg	: AMPER arg
a762 5
			$$ = NEW_BLOCK_PASS($2);
		    }

opt_block_arg	: ',' block_arg
		    {
a764 4
		| /* none */
		    {
			$$ = 0;
		    }
d766 1
a766 2
opt_list	: args
		| /* none */
d770 1
d804 1
a804 1
ret_args	: call_args
d806 7
a812 9
			$$ = $1;
			if ($1) {
			    if (nd_type($1) == NODE_ARRAY &&
				$1->nd_next == 0) {
				$$ = $1->nd_head;
			    }
			    else if (nd_type($1) == NODE_BLOCK_PASS) {
				Error("block argument should not be given");
			    }
d848 1
a848 1
		| primary '[' aref_args ']'
d904 1
a904 1
			$$ = NEW_VCALL($1);
a913 3
			if ($1 && nd_type($1) == NODE_BLOCK_PASS) {
			    Error("both block arg and actual block given");
			}
d1161 1
a1161 1
			$$ = NEW_VCALL($1);
d1165 1
a1165 1
			$$ = NEW_VCALL($1);
d1169 1
a1169 1
			$$ = NEW_VCALL($1);
d1174 1
a1174 1
method_call	: operation '(' opt_call_args ')'
d1176 1
a1176 1
			$$ = new_fcall($1, $3);
d1179 1
a1179 1
		| primary '.' operation '(' opt_call_args ')'
d1182 1
a1182 1
			$$ = new_call($1, $3, $5);
d1188 1
a1188 1
			$$ = new_call($1, $3, 0);
d1190 1
a1190 1
		| primary COLON2 operation '(' opt_call_args ')'
d1193 1
a1193 1
			$$ = new_call($1, $3, $5);
d1196 1
a1196 1
		| kSUPER '(' opt_call_args ')'
d1298 1
a1298 1
f_args		: f_arg ',' f_optarg ',' f_rest_arg opt_f_block_arg
d1300 1
a1300 1
			$$ = block_append(NEW_ARGS($1, $3, $5), $6);
d1302 1
a1302 1
		| f_arg ',' f_optarg opt_f_block_arg
d1304 1
a1304 1
			$$ = block_append(NEW_ARGS($1, $3, -1), $4);
d1306 1
a1306 1
		| f_arg ',' f_rest_arg opt_f_block_arg
d1308 1
a1308 1
			$$ = block_append(NEW_ARGS($1, 0, $3), $4);
d1310 1
a1310 1
		| f_arg opt_f_block_arg
d1312 1
a1312 1
			$$ = block_append(NEW_ARGS($1, 0, -1), $2);
d1314 1
a1314 1
		| f_optarg ',' f_rest_arg opt_f_block_arg
d1316 1
a1316 1
			$$ = block_append(NEW_ARGS(0, $1, $3), $4);
d1318 1
a1318 1
		| f_optarg opt_f_block_arg
d1320 1
a1320 1
			$$ = block_append(NEW_ARGS(0, $1, -1), $2);
d1322 1
a1322 1
		| f_rest_arg opt_f_block_arg
d1324 1
a1324 1
			$$ = block_append(NEW_ARGS(0, 0, $1), $2);
d1326 1
a1326 5
		| f_block_arg
		    {
			$$ = block_append(NEW_ARGS(0, 0, -1), $1);
		    }
		| /* none */
d1328 1
a1328 1
			$$ = NEW_ARGS(0, 0, -1);
d1363 1
a1363 1
f_rest_arg	: STAR IDENTIFIER
a1369 14
f_block_arg	: AMPER IDENTIFIER
		    {
			$$ = NEW_BLOCK_ARG($2);
		    }

opt_f_block_arg	: ',' f_block_arg
		    {
			$$ = $2;
		    }
		| /* none */
		    {
			$$ = 0;
		    }

d1427 7
a2228 1
	    lex_state = EXPR_BEG;
d2367 1
a2368 1
	    lex_state = EXPR_BEG;
a2372 1
	    lex_state = EXPR_BEG;
a2375 10
	if (lex_state == EXPR_ARG && space_seen && !isspace(c)){
	    arg_ambiguous();
	    lex_state = EXPR_BEG;
	    return AMPER;
	}
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
	    lex_state = EXPR_BEG;
	    return AMPER;
	}
	lex_state = EXPR_BEG;
d2438 5
a3587 37
}

static NODE *
arg_blk_pass(node1, node2)
    NODE *node1;
    NODE *node2;
{
    if (node2) {
	node2->nd_head = node1;
	return node2;
    }
    return node1;
}

static NODE*
new_call(r,m,a)
    NODE *r;
    ID m;
    NODE *a;
{
    if (a && nd_type(a) == NODE_BLOCK_PASS) {
	a->nd_iter = NEW_CALL(r,m,a->nd_head);
	return a;
    }
    return NEW_CALL(r,m,a);
}

static NODE*
new_fcall(m,a)
    ID m;
    NODE *a;
{
    if (a && nd_type(a) == NODE_BLOCK_PASS) {
	a->nd_iter = NEW_FCALL(m,a->nd_head);
	return a;
    }
    return NEW_FCALL(m,a);
@


1.1.1.2.2.16
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/03/05 06:37:46 $
d2254 1
a2254 4
	switch (lex_state) {
	  case EXPR_BEG:
	  case EXPR_FNAME:
	  case EXPR_DOT:
@


1.1.1.2.2.17
log
@1.1b9_00
@
text
@d6 1
a6 1
  $Date: 1998/03/06 10:07:53 $
a3650 8

    switch (nd_type(left)) {
      case NODE_NIL:		/* always false */
      case NODE_FALSE:
	return type == NODE_OR ? right : left;
      case NODE_LIT:		/* always true */
	return type == NODE_AND ? right : left;
    }
@


1.1.1.2.2.18
log
@speed up patch 2
@
text
@d6 1
a6 1
  $Date: 1998/03/09 07:56:56 $
d534 2
a535 2
		| UPLUS		{ $$ = UPLUS; }
		| UMINUS	{ $$ = UMINUS; }
d3727 1
a3727 1
    struct local_vars *local = lvtbl->prev;
d3729 4
a3732 9
    if (lvtbl->tbl) {
	if (!lvtbl->nofree) free(lvtbl->tbl);
	else {
	    lvtbl->tbl[0] = lvtbl->cnt;
#if 1
	    lvtbl->tbl[lvtbl->cnt+1] = local_cnt('_');
	    lvtbl->tbl[lvtbl->cnt+2] = local_cnt('~');
#endif
	}
d3734 1
a3734 2
    free(lvtbl);
    lvtbl = local;
d3756 1
d3762 1
a3762 1
	REALLOC_N(lvtbl->tbl, ID, lvtbl->cnt+4);
d3788 1
a3788 1
	lvtbl->tbl = ALLOC_N(ID, lvtbl->cnt+3);
a3829 4
#if 1
	    local_cnt('_');
	    local_cnt('~');
#endif
a4126 1
#if 0
a4134 1
#endif
a4143 6
#if 1
    if (the_scope->local_tbl) {
	return the_scope->local_vars[the_scope->local_tbl[the_scope->local_tbl[0]+2]];
    }
    return Qnil;
#else
a4144 1
#endif
a4150 5
#if 1
    if (the_scope->local_tbl) {
	the_scope->local_vars[the_scope->local_tbl[the_scope->local_tbl[0]+2]] = val;
    } else
#endif
a4156 6
#if 1
    if (the_scope->local_tbl) {
	return the_scope->local_vars[the_scope->local_tbl[the_scope->local_tbl[0]+1]];
    }
    return Qnil;
#else
a4159 1
#endif
a4165 5
#if 1
    if (the_scope->local_tbl) {
	the_scope->local_vars[the_scope->local_tbl[the_scope->local_tbl[0]+1]] = val;
    } else
#endif
@


1.1.1.2.2.19
log
@speed-up patch 3
@
text
@d6 1
a6 1
  $Date: 1998/03/11 09:19:49 $
a3745 4
#if 1
    local_cnt('_');
    local_cnt('~');
#endif
d3835 5
d3844 2
a3845 1
	    the_scope->local_tbl = local_tbl();
@


1.1.1.2.2.20
log
@speed up patch 4
@
text
@d6 1
a6 1
  $Date: 1998/03/11 09:27:52 $
d3651 9
d3731 7
a3737 1
	else lvtbl->tbl[0] = lvtbl->cnt;
d3746 4
d3767 1
a3767 1
	lvtbl->tbl = ALLOC_N(ID, 4);
a3768 5
	lvtbl->tbl[1] = '_';
	lvtbl->tbl[2] = '~';
	lvtbl->cnt = 2;
	if (id == '_') return 0;
	if (id == '~') return 1;
d3771 1
a3771 1
	REALLOC_N(lvtbl->tbl, ID, lvtbl->cnt+2);
d4112 15
d4132 1
a4132 1
    int cnt;
d4134 10
d4153 3
a4155 2
    if (the_scope->local_vars) {
	return the_scope->local_vars[1];
d4158 3
d4167 6
a4172 6
    if (the_scope->local_vars) {
	the_scope->local_vars[1] = val;
    }
    else {
	special_local_set('~', val);
    }
d4178 3
a4180 2
    if (the_scope->local_vars) {
	return the_scope->local_vars[0];
d4183 5
d4194 6
a4199 6
    if (the_scope->local_vars) {
	the_scope->local_vars[0] = val;
    }
    else {
	special_local_set('_', val);
    }
@


1.1.1.2.2.21
log
@DATA
@
text
@d6 1
a6 1
  $Date: 1998/03/12 01:15:17 $
d3942 2
@


1.1.1.2.2.22
log
@1.1b9_04
@
text
@d6 1
a6 1
  $Date: 1998/03/19 06:22:54 $
d2607 1
a2607 1
		    if (seen_point || seen_e) {
@


1.1.1.2.2.23
log
@heredoc etc.
@
text
@d6 1
a6 1
  $Date: 1998/03/19 06:25:33 $
a1579 1
static int heredoc_end;
a1635 4
	    if (heredoc_end > 0) {
		sourceline = heredoc_end+1;
		heredoc_end = 0;
	    }
a2100 1
    int linesave = sourceline;
a2180 2
    heredoc_end = sourceline;
    sourceline = linesave;
d3545 1
a3545 1
	return 1;
d3553 1
a3554 1
      case NODE_NEWLINE:
d3556 1
a3556 1
	return 0;
d3570 3
a3572 4
	/* reports always */
	Warn("found = in conditional, should be ==");
	return 1;

a3573 2
    }
    if (assign_in_cond(node->nd_value) == 0) {
d3575 1
d3577 1
a3577 1
    return 1;
d3586 1
a3586 1
    assign_in_cond(node);
@


1.1.1.2.2.24
log
@some patches
@
text
@d6 1
a6 1
  $Date: 1998/03/25 09:36:58 $
d335 1
a335 1
		| stmt kUNTIL_MOD expr
@


1.1.1.2.2.25
log
@dynamic (nested) local variables
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:05:16 $
d3781 1
a3781 1
    for (i=3, max=lvtbl->cnt+1; i<max; i++) {
d3799 1
a3799 1
    if (the_dyna_vars)
@


1.1.1.2.2.26
log
@1.1b9_09 pre
@
text
@d6 1
a6 1
  $Date: 1998/04/07 08:34:09 $
d573 4
a576 10
			if (is_local_id($1)) {
			    if (local_id($1)||!dyna_in_block()) {
				local_cnt($1);
			    }
			    else if (!dyna_var_defined($1)) {
				dyna_var_asgn($1, TRUE);
			    }
			}
			$$ = assignable($1,call_op(gettable($1),$2,1,$3));
			fixpos($$, $3);
@


1.1.1.2.2.27
log
@signal delivered to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/09 09:30:21 $
d169 3
a171 3
%token <id>   tIDENTIFIER tFID tGVAR tIVAR tCONSTANT
%token <val>  tINTEGER tFLOAT tSTRING tXSTRING tREGEXP
%token <node> tDSTRING tDXSTRING tDREGEXP tNTH_REF tBACK_REF
d187 24
a210 24
%token tUPLUS 		/* unary+ */
%token tUMINUS 		/* unary- */
%token tPOW		/* ** */
%token tCMP  		/* <=> */
%token tEQ  		/* == */
%token tEQQ  		/* === */
%token tNEQ  		/* != <> */
%token tGEQ  		/* >= */
%token tLEQ  		/* <= */
%token tANDOP tOROP	/* && and || */
%token tMATCH tNMATCH	/* =~ and !~ */
%token tDOT2 tDOT3	/* .. and ... */
%token tAREF tASET	/* [] and []= */
%token tLSHFT tRSHFT	/* << and >> */
%token tCOLON2		/* :: */
%token tCOLON3		/* :: at EXPR_BEG */
%token <id> tOP_ASGN	/* +=, -=  etc. */
%token tASSOC		/* => */
%token tLPAREN		/* ( */
%token tLBRACK		/* [ */
%token tLBRACE		/* { */
%token tSTAR		/* * */
%token tAMPER		/* & */
%token tSYMBEG
d220 1
a220 1
%right '=' tOP_ASGN
d222 5
a226 5
%nonassoc tDOT2 tDOT3
%left  tOROP
%left  tANDOP
%nonassoc  tCMP tEQ tEQQ tNEQ tMATCH tNMATCH
%left  '>' tGEQ '<' tLEQ
d229 1
a229 1
%left  tLSHFT tRSHFT
d232 2
a233 2
%right '!' '~' tUPLUS tUMINUS
%right tPOW
d287 1
a287 1
		| kALIAS tGVAR tGVAR
d293 1
a293 1
		| kALIAS tGVAR tBACK_REF
d302 1
a302 1
		| kALIAS tGVAR tNTH_REF
d419 1
a419 1
		| primary tCOLON2 operation call_args
d437 1
a437 1
		| mlhs_head tSTAR lhs
d445 1
a445 1
		| mlhs_head mlhs_tail ',' tSTAR lhs
d449 1
a449 1
		| tSTAR lhs
d473 1
a473 1
		| primary '.' tIDENTIFIER
d483 1
a483 1
cname		: tIDENTIFIER
d487 1
a487 1
		| tCONSTANT
d489 3
a491 3
fname		: tIDENTIFIER
		| tCONSTANT
		| tFID
d512 1
a512 1
op		: tDOT2		{ $$ = tDOT2; }
d516 4
a519 4
		| tCMP		{ $$ = tCMP; }
		| tEQ		{ $$ = tEQ; }
		| tEQQ		{ $$ = tEQQ; }
		| tMATCH	{ $$ = tMATCH; }
d521 1
a521 1
		| tGEQ		{ $$ = tGEQ; }
d523 3
a525 3
		| tLEQ		{ $$ = tLEQ; }
		| tLSHFT	{ $$ = tLSHFT; }
		| tRSHFT	{ $$ = tRSHFT; }
d529 1
a529 1
		| tSTAR		{ $$ = '*'; }
d532 1
a532 1
		| tPOW		{ $$ = tPOW; }
d534 4
a537 4
		| tUPLUS	{ $$ = tUPLUS; }
		| tUMINUS	{ $$ = tUMINUS; }
		| tAREF		{ $$ = tAREF; }
		| tASET		{ $$ = tASET; }
d559 1
a559 1
		| primary '.' tIDENTIFIER '=' arg
d570 1
a570 1
		| variable tOP_ASGN arg
d584 1
a584 1
		| primary '[' aref_args ']' tOP_ASGN arg
d593 1
a593 1
		| primary '.' tIDENTIFIER tOP_ASGN arg
d598 1
a598 1
		| primary '.' tCONSTANT tOP_ASGN arg
d603 1
a603 1
		| backref tOP_ASGN arg
d608 1
a608 1
		| arg tDOT2 arg
d612 1
a612 1
		| arg tDOT3 arg
d636 1
a636 1
		| arg tPOW arg
d638 1
a638 1
			$$ = call_op($1, tPOW, 1, $3);
d640 1
a640 1
		| tUPLUS arg
d642 1
a642 1
			$$ = call_op($2, tUPLUS, 0);
d644 1
a644 1
		| tUMINUS arg
d646 1
a646 1
		        $$ = call_op($2, tUMINUS, 0);
d660 1
a660 1
		| arg tCMP arg
d662 1
a662 1
			$$ = call_op($1, tCMP, 1, $3);
d668 1
a668 1
		| arg tGEQ arg
d670 1
a670 1
			$$ = call_op($1, tGEQ, 1, $3);
d676 1
a676 1
		| arg tLEQ arg
d678 1
a678 1
			$$ = call_op($1, tLEQ, 1, $3);
d680 1
a680 1
		| arg tEQ arg
d682 1
a682 1
			$$ = call_op($1, tEQ, 1, $3);
d684 1
a684 1
		| arg tEQQ arg
d686 1
a686 1
			$$ = call_op($1, tEQQ, 1, $3);
d688 1
a688 1
		| arg tNEQ arg
d690 1
a690 1
			$$ = NEW_NOT(call_op($1, tEQ, 1, $3));
d692 1
a692 1
		| arg tMATCH arg
d696 1
a696 1
		| arg tNMATCH arg
d709 1
a709 1
		| arg tLSHFT arg
d711 1
a711 1
			$$ = call_op($1, tLSHFT, 1, $3);
d713 1
a713 1
		| arg tRSHFT arg
d715 1
a715 1
			$$ = call_op($1, tRSHFT, 1, $3);
d717 1
a717 1
		| arg tANDOP arg
d721 1
a721 1
		| arg tOROP arg
d764 1
a764 1
		| args ',' tSTAR arg opt_block_arg
d774 1
a774 1
		| assocs ',' tSTAR arg opt_block_arg
d784 1
a784 1
		| args ',' assocs ',' tSTAR arg opt_block_arg
d789 1
a789 1
		| tSTAR arg opt_block_arg
d796 1
a796 1
block_arg	: tAMPER arg
d839 1
a839 1
		| args ',' tSTAR arg
d843 1
a843 1
		| tSTAR arg
d873 1
a873 1
		| primary tCOLON2 cname
d878 1
a878 1
		| tCOLON3 cname
d882 1
a882 1
		| tSTRING
d886 2
a887 2
		| tDSTRING
		| tXSTRING
d891 2
a892 2
		| tDXSTRING
		| tDREGEXP
d898 1
a898 1
			$$ = NEW_CALL($1, tAREF, $3);
d900 1
a900 1
		| tLBRACK array ']'
d908 1
a908 1
		| tLBRACE assoc_list '}'
d949 1
a949 1
		| tFID
d1033 1
a1033 1
		| tLPAREN compstmt ')'
d1055 1
a1055 1
		| kCLASS tLSHFT expr term
d1175 1
a1175 1
		| tOROP
d1209 1
a1209 1
iterator	: tIDENTIFIER
d1213 1
a1213 1
		| tCONSTANT
d1217 1
a1217 1
		| tFID
d1240 1
a1240 1
		| primary tCOLON2 operation '(' opt_call_args ')'
d1292 1
a1292 1
		| tSYMBEG symbol
d1296 1
a1296 1
		| tREGEXP
d1299 2
a1300 2
		| tIVAR
		| tGVAR
d1302 2
a1303 2
numeric		: tINTEGER
		| tFLOAT
d1305 4
a1308 4
variable	: tIDENTIFIER
		| tIVAR
		| tGVAR
		| tCONSTANT
d1321 2
a1322 2
backref		: tNTH_REF
		| tBACK_REF
d1385 1
a1385 1
f_arg		: tIDENTIFIER
d1392 1
a1392 1
		| f_arg ',' tIDENTIFIER
d1400 1
a1400 1
f_opt		: tIDENTIFIER '=' arg
d1417 1
a1417 1
f_rest_arg	: tSTAR tIDENTIFIER
d1424 1
a1424 1
f_block_arg	: tAMPER tIDENTIFIER
d1451 1
a1451 1
		| tLPAREN expr opt_nl ')'
d1491 1
a1491 1
assoc		: arg tASSOC arg
d1496 3
a1498 3
operation	: tIDENTIFIER
		| tCONSTANT
		| tFID
d1538 3
a1540 3
static UCHAR *lex_pbeg;
static UCHAR *lex_p;
static UCHAR *lex_pend;
d1546 1
a1546 1
    UCHAR *p, *pe, *buf;
d1951 1
a1951 1
		return tDREGEXP;
d1955 1
a1955 1
		return tREGEXP;
d2027 1
a2027 1
	    return tDXSTRING;
d2030 1
a2030 1
	    return tDSTRING;
d2035 1
a2035 1
	return (func == '`') ? tXSTRING : tSTRING;
d2088 1
a2088 1
    return tSTRING;
d2097 1
a2097 1
    return tDSTRING;
d2164 2
a2165 2
	  case tSTRING:
	  case tXSTRING:
d2174 2
a2175 2
	  case tDSTRING:
	  case tDXSTRING:
d2202 1
a2202 1
	if (list) return tDSTRING;
d2204 1
a2204 1
	return tSTRING;
d2206 2
a2207 2
	if (list) return tDXSTRING;
	return tXSTRING;
d2283 2
a2284 2
		yylval.id = tPOW;
		return tOP_ASGN;
d2287 1
a2287 1
	    return tPOW;
d2292 1
a2292 1
	    return tOP_ASGN;
d2298 1
a2298 1
	    return tSTAR;
d2302 1
a2302 1
	    return tSTAR;
d2310 1
a2310 1
	    return tNEQ;
d2313 1
a2313 1
	    return tNMATCH;
d2344 1
a2344 1
		return tEQQ;
d2347 1
a2347 1
	    return tEQ;
d2350 1
a2350 1
	    return tMATCH;
d2353 1
a2353 1
	    return tASSOC;
d2376 1
a2376 1
		return tCMP;
d2379 1
a2379 1
	    return tLEQ;
d2383 2
a2384 2
		yylval.id = tLSHFT;
		return tOP_ASGN;
d2387 1
a2387 1
	    return tLSHFT;
d2395 1
a2395 1
	    return tGEQ;
d2399 2
a2400 2
		yylval.id = tRSHFT;
		return tOP_ASGN;
d2403 1
a2403 1
	    return tRSHFT;
d2437 1
a2437 1
	return tINTEGER;
d2442 1
a2442 1
	    return tANDOP;
d2447 1
a2447 1
	    return tOP_ASGN;
d2453 1
a2453 1
	    return tAMPER;
d2457 1
a2457 1
	    return tAMPER;
d2465 1
a2465 1
	    return tOROP;
d2469 1
a2469 1
	    return tOP_ASGN;
d2478 1
a2478 1
		return tUPLUS;
d2486 1
a2486 1
	    return tOP_ASGN;
d2502 1
a2502 1
	    return tUPLUS;
d2512 1
a2512 1
		return tUMINUS;
d2520 1
a2520 1
	    return tOP_ASGN;
d2538 1
a2538 1
	    return tUMINUS;
d2548 1
a2548 1
		return tDOT3;
d2551 1
a2551 1
	    return tDOT2;
d2586 1
a2586 1
		    return tINTEGER;
d2598 1
a2598 1
		    return tINTEGER;
d2609 1
a2609 1
		    return tINTEGER;
d2666 1
a2666 1
		return tFLOAT;
d2669 1
a2669 1
	    return tINTEGER;
d2683 1
a2683 1
		return tCOLON3;
d2688 1
a2688 1
		return tCOLON3;
d2691 1
a2691 1
	    return tCOLON2;
d2699 1
a2699 1
	return tSYMBEG;
d2708 1
a2708 1
	    return tOP_ASGN;
d2725 1
a2725 1
	    return tOP_ASGN;
d2746 1
a2746 1
	    c = tLPAREN;
d2758 1
a2758 1
		    return tASET;
d2761 1
a2761 1
		return tAREF;
d2767 1
a2767 1
	    c = tLBRACK;
d2771 1
a2771 1
	    c = tLBRACK;
d2778 1
a2778 1
	    c = tLBRACE;
d2846 1
a2846 1
	    return tOP_ASGN;
d2887 1
a2887 1
	    return tGVAR;
d2896 1
a2896 1
	    return tGVAR;
d2903 1
a2903 1
	    return tBACK_REF;
d2915 1
a2915 1
	    return tNTH_REF;
d2969 1
a2969 1
	    result = tGVAR;
d2973 1
a2973 1
	    result = tIVAR;
d3005 1
a3005 1
		result = tCONSTANT;
d3008 1
a3008 1
		result = tFID;
d3010 1
a3010 1
		result = tIDENTIFIER;
d3352 1
a3352 1
    return NEW_CALL(node1, tMATCH, NEW_LIST(node2));
d3471 1
a3471 1
    return NEW_CALL(recv, tASET, idx);
a3588 1
	break;
d3656 1
a3656 1
	return call_op(node,tEQ,1,NEW_GVAR(rb_intern("$.")));
d3907 1
a3907 1
    tDOT2,	"..",
d3915 5
a3919 5
    tPOW,	"**",
    tUPLUS,	"+@@",
    tUMINUS,	"-@@",
    tUPLUS,	"+(unary)",
    tUMINUS,	"-(unary)",
d3923 1
a3923 1
    tCMP,	"<=>",
d3925 1
a3925 1
    tGEQ,	">=",
d3927 6
a3932 6
    tLEQ,	"<=",
    tEQ,	"==",
    tEQQ,	"===",
    tNEQ,	"!=",
    tMATCH,	"=~",
    tNMATCH,	"!~",
d3939 5
a3943 6
    tAREF,	"[]",
    tASET,	"[]=",
    tLSHFT,	"<<",
    tRSHFT,	">>",
    tCOLON2,	"::",
    tCOLON3,	"::",
@


1.1.1.2.2.28
log
@flock,flatten,signal to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/14 04:55:49 $
d1827 1
a1827 1
parse_regx(term, paren)
a1832 1
    int nest = 0;
d1840 1
a1840 1
	if ((!in_brack && c == term) || nest > 0) {
a1890 2
		if (c == paren) nest++;
		if (c == term) nest--;
d1964 1
a1964 1
static int parse_qstring _((int,int));
d1967 2
a1968 2
parse_string(func, term, paren)
    int func, term, paren;
a1972 1
    int nest = 0;
d1975 1
a1975 1
	return parse_qstring(term, paren);
d1980 1
a1980 1
    while ((c = nextc()) != term || nest > 0) {
a2013 2
	if (c == paren) nest++;
	if (c == term) nest--;
d2040 1
a2040 1
parse_qstring(term, paren)
a2044 1
    int nest = 0;
d2048 1
a2048 1
    while ((c = nextc()) != term || nest > 0) {
a2081 2
	if (c == paren) nest++;
	if (c == term) nest--;
d2092 2
a2093 2
parse_quotedword(term, paren)
    int term, paren;
d2095 1
a2095 1
    if (parse_qstring(term, paren) == 0) return 0;
d2409 1
a2409 1
	return parse_string(c,c,c);
d2412 1
a2412 1
	return parse_string(c,c,c);
d2415 1
a2415 1
	return parse_qstring(c,c);
d2703 1
a2703 1
	    return parse_regx('/', '/');
d2714 1
a2714 1
		return parse_regx('/', '/');
a2794 1
	    int paren;
a2817 1
	    paren = term;
d2825 1
a2825 1
		return parse_string('"', term, paren);
d2828 1
a2828 1
		return parse_qstring(term, paren);
d2831 1
a2831 1
		return parse_quotedword(term, paren);
d2834 1
a2834 1
		return parse_string('`', term, paren);
d2837 1
a2837 1
		return parse_regx(term, paren);
@


1.1.1.2.2.29
log
@ruby 1.1b9_13
@
text
@d6 1
a6 1
  $Date: 1998/04/16 07:42:45 $
d193 1
a193 1
%token tNEQ  		/* != */
d345 1
a345 1
		| klBEGIN
d401 1
a401 1
		| '!' command_call
d1027 1
a1027 1
			    if ($3) $2 = NEW_RESCUE($2, $3);
d1171 1
a1171 1
		| '|' /* none */ '|'
d1197 1
a1197 1
iter_block	: '{'
d1272 1
a1272 1
		  rescue
d1311 1
a1311 1
		| kTRUE {$$ = kTRUE;}
d1983 1
d1985 1
a1985 1
	if (c == -1) {
d2047 1
a2047 1
    int term, paren;
d2056 1
a2056 1
	if (c == -1) {
d2134 1
a2134 1
	c = term;
d2172 1
a2172 1
	switch (parse_string(term, '\n', '\n')) {
d2212 1
a2212 1
	yylval.val = str;
d3109 1
a3109 1
      case '@@':
d3296 1
a3296 1

d3501 1
a3501 1

d3996 1
d4013 1
a4013 1

d4075 1
a4075 1
	ID id2;
@


1.1.1.2.2.30
log
@gtk/nested local variables
@
text
@d6 1
a6 1
  $Date: 1998/04/21 08:41:06 $
d3437 1
a3437 1
		dyna_var_asgn(0, id);
@


1.1.1.2.2.31
log
@new exception model
@
text
@d6 1
a6 1
  $Date: 1998/04/24 09:33:17 $
d2369 2
a2370 1
	    lex_state != EXPR_END && lex_state != EXPR_CLASS &&
@


1.1.1.2.2.32
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/04/30 07:41:13 $
a1547 1
    void Error_Append();
@


1.1.1.2.2.33
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:25 $
d1521 1
a1521 1
#define is_identchar(c) ((c)!=-1&&(ISALNUM(c) || (c) == '_' || ismbchar(c)))
d1772 1
a1772 1
		if (!ISXDIGIT(buf[i])) {
d2304 1
a2304 1
	if (lex_state == EXPR_ARG && space_seen && !ISSPACE(c)){
d2330 1
a2330 1
	    if (strncmp(lex_p, "begin", 5) == 0 && ISSPACE(lex_p[5])) {
d2340 1
a2340 1
		    if (strncmp(lex_p, "end", 3) == 0 && ISSPACE(lex_p[3])) {
d2373 1
a2373 1
	    if (!ISSPACE(c2) && (strchr("\"'`", c2) || is_identchar(c2))) {
d2432 1
a2432 1
	if (lex_state == EXPR_ARG && ISSPACE(c)){
d2458 1
a2458 1
	if (lex_state == EXPR_ARG && space_seen && !ISSPACE(c)){
d2497 1
a2497 1
	    if (space_seen && !ISSPACE(c)) {
d2505 1
a2505 1
 	    if (ISDIGIT(c)) {
d2531 1
a2531 1
	    if (space_seen && !ISSPACE(c)) {
d2539 1
a2539 1
	    if (ISDIGIT(c)) {
d2562 1
a2562 1
	if (!ISDIGIT(c)) {
d2588 1
a2588 1
			if (!ISXDIGIT(c)) break;
d2634 1
a2634 1
			if (!ISDIGIT(c0)) {
d2702 1
a2702 1
	if (lex_state == EXPR_END || ISSPACE(c)) {
d2719 1
a2719 1
	    if (space_seen && !ISSPACE(c)) {
d2807 1
a2807 1
	    if (!ISALNUM(c)) {
d2859 1
a2859 1
	    if (space_seen && !ISSPACE(c)) {
d2918 1
a2918 1
	    while (ISDIGIT(c)) {
d2948 1
a2948 1
	if (c != '_' && !ISALPHA(c) && !ismbchar(c)) {
d3014 1
a3014 1
	    if (ISUPPER(tok()[0])) {
d3069 1
a3069 1
	    while (ISDIGIT(c)) {
d3996 1
a3996 1
	if (name[0] != '_' && !ISALPHA(name[0]) && !ismbchar(name[0])) {
d4023 1
a4023 1
	else if (ISUPPER(name[0])) {
@


1.1.1.2.2.34
log
@1.1b9_22
@
text
@d6 1
a6 1
  $Date: 1998/05/18 04:56:10 $
d3034 1
a3034 2
    int c;
    int brace = -1;
d3137 1
d3149 1
a3149 1
		if (brace != -1) nest++;
d3437 1
a3437 1
		dyna_var_asgn(id, 0);
@


1.1.1.2.2.35
log
@remove unused variables
@
text
@d6 1
a6 1
  $Date: 1998/05/19 07:39:53 $
a2282 2
	  default:
	    break;
@


1.1.1.2.2.36
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 04:57:46 $
d1835 1
a1835 1
    int options = 0;
d1924 1
a1924 4
		    options |= RE_OPTION_IGNORECASE;
		    break;
		  case 'x':
		    options |= RE_OPTION_EXTENDED;
d1930 1
a1930 1
		    kcode = 4;
d1933 1
a1933 1
		    kcode = 8;
d1936 1
a1936 1
		    kcode = 12;
d1953 1
a1953 1
		list->nd_cflag = options | kcode;
d1958 1
a1958 1
		yylval.val = reg_new(tok(), toklen(), options | kcode);
@


1.1.1.2.2.37
log
@1.1b9_23
@
text
@d6 1
a6 1
  $Date: 1998/05/25 09:42:30 $
d60 1
a60 1
    EXPR_ARG,			/* newline significant, +/- is a operator. */
d2501 9
a2509 1
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
d2535 9
a2543 1
	if (lex_state == EXPR_BEG || lex_state == EXPR_MID) {
@


1.1.1.2.2.38
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/26 08:24:45 $
d1538 3
a1540 3
static char *lex_pbeg;
static char *lex_p;
static char *lex_pend;
d1546 1
a1546 1
    char *p, *pe, *buf;
@


1.1.1.2.2.39
log
@1.1b9_25
@
text
@d6 1
a6 1
  $Date: 1998/05/27 09:31:52 $
d1648 1
a1648 2
	    while (RSTRING(v)->len >= 2 &&
		   RSTRING(v)->ptr[RSTRING(v)->len-1] == '\n' &&
d3426 1
a3426 1
		dyna_var_asgn(0, id);
@


1.1.1.2.2.40
log
@nested local variables
@
text
@d6 1
a6 1
  $Date: 1998/06/11 10:03:05 $
a238 1
		        $<vars>$ = the_dyna_vars;
a250 1
		        the_dyna_vars = $<vars>1;
d3427 1
a3427 1
		dyna_var_asgn(id, 0);
@


1.1.1.2.2.41
log
@baseline
@
text
@d6 1
a6 1
  $Date: 1998/06/12 09:35:10 $
d47 1
a47 1
NODE *eval_tree_begin = 0;
d357 1
a357 2
			eval_tree_begin = block_append(eval_tree_begin,
						       NEW_PREEXE($4));
a1598 1
    eval_tree = 0;
@


1.1.1.2.2.42
log
@1.1b9_26
@
text
@d6 1
a6 1
  $Date: 1998/06/16 04:23:39 $
d3382 1
a3383 1
	if (local_id(id)) return NEW_LVAR(id);
a3431 4
		lhs = NEW_DASGN_PUSH(id, val);
	    }
	    else {
		lhs = NEW_DASGN(id, val);
d3433 1
@


1.1.1.2.2.43
log
@1.1b9_27
@
text
@d6 1
a6 1
  $Date: 1998/06/18 07:46:54 $
a439 5
		| tLPAREN mlhs ')'
		    {
			$$ = $2;
		    }

a457 4
		| tLPAREN mlhs ')' ','
		    {
			$$ = $2;
		    }
a462 4
		| tLPAREN  mlhs ')'
		    {
			$$ = NEW_LIST($2);
		    }
d3431 1
a3431 1
		dyna_var_push(id, 0);
@


1.1.1.2.2.44
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/06/19 09:32:05 $
d2158 1
a2158 1
	    Error("illegal here document");
d3439 1
a3439 4
	if (dyna_var_defined(id)) {
	    lhs = NEW_DASGN(id, val);
	}
	else if (local_id(id) || !dyna_in_block()) {
d3443 7
a3449 2
	    dyna_var_push(id, 0);
	    lhs = NEW_DASGN_PUSH(id, val);
d3523 1
a3523 1
	yyerror("Can't set variable $%d", node->nd_nth);
d3526 1
a3526 1
	yyerror("Can't set variable $%c", node->nd_nth);
d3578 1
a3578 1
	yyerror("multiple assignment in conditional");
d4018 1
a4018 3
	    if (id == 0) {
		NameError("Unknown operator `%s'", name);
	    }
@


1.1.1.2.2.45
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/06/22 05:53:21 $
d444 1
a2472 5
	    if ((c = nextc()) == '=') {
		yylval.id = tANDOP;
		return tOP_ASGN;
	    }
	    pushback(c);
a2495 5
	    if ((c = nextc()) == '=') {
		yylval.id = tOROP;
		return tOP_ASGN;
	    }
	    pushback(c);
@


1.1.1.2.2.46
log
@thread->thred
@
text
@d6 1
a6 1
  $Date: 1998/06/23 10:30:10 $
d183 1
a183 1
%type <node> mlhs mlhs_head mlhs_tail mlhs_basic mlhs_item lhs backref
d436 1
a436 2
mlhs		: mlhs_basic
		| tLPAREN mlhs_item ')'
d438 1
a438 1
			$$ = $2;
d440 1
a440 3

mlhs_item	: mlhs_basic
		| tLPAREN mlhs_item ')'
d442 1
a442 6
			$$ = NEW_MASGN(NEW_LIST($2), 0);
		    }

mlhs_basic	: mlhs_head
		    {
			$$ = NEW_MASGN(NEW_LIST($1), 0);
d462 1
a462 1
		| tLPAREN mlhs_item ')' ','
d471 1
a471 1
		| tLPAREN  mlhs_item ')'
a855 1
			value_expr($4);
@


1.1.1.2.2.47
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/24 04:38:00 $
d573 1
d595 1
d604 1
a604 9
			if ($2 == tOROP) {
			    $$ = NEW_UNLESS(gettable($1), assignable($1, $3), 0);
			}
			else if ($2 == tANDOP) {
			    $$ = NEW_IF(gettable($1), assignable($1, $3), 0);
			}
			else {
			    $$ = assignable($1,call_op(gettable($1),$2,1,$3));
			}
d609 1
a609 8
			if ($5 == tOROP) {
			    $$ = NEW_UNLESS(NEW_CALL($1, tAREF, $3), aryset($1, $3, $6), 0);
			}
			else if ($5 == tANDOP) {
			    $$ = NEW_IF(NEW_CALL($1, tAREF, $3), aryset($1, $3, $6), 0);
			}
			else {
			    NODE *args = NEW_LIST($6);
d611 3
a613 4
			    list_append($3, NEW_NIL());
			    list_concat(args, $3);
			    $$ = NEW_OP_ASGN1($1, $5, args);
			}
d618 1
a618 9
			if ($4 == tOROP) {
			    $$ = NEW_UNLESS(new_call($1, $3, 0), attrset($1, $3, $5), 0);
			}
			else if ($4 == tANDOP) {
			    $$ = NEW_IF(new_call($1, $3, 0), attrset($1, $3, $5), 0);
			}
			else {
			    $$ = NEW_OP_ASGN2($1, $3, $4, $5);
			}
d623 1
a623 9
			if ($4 == tOROP) {
			    $$ = NEW_UNLESS(new_call($1, $3, 0), attrset($1, $3, $5), 0);
			}
			else if ($4 == tANDOP) {
			    $$ = NEW_IF(new_call($1, $3, 0), attrset($1, $3, $5), 0);
			}
			else {
			    $$ = NEW_OP_ASGN2($1, $3, $4, $5);
			}
a3437 1
    value_expr(val);
@


1.1.1.2.2.48
log
@1.1b9_30
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:29 $
d35 6
a40 6
#define is_id_notop(id) ((id)>LAST_TOKEN)
#define is_local_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_LOCAL)
#define is_global_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_GLOBAL)
#define is_instance_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_INSTANCE)
#define is_attrset_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_ATTRSET)
#define is_const_id(id) (is_id_notop(id)&&((id)&ID_SCOPE_MASK)==ID_CONST)
d603 1
a603 2
			    $$ = NEW_OP_ASGN_OR(gettable($1),
						assignable($1, $3));
d606 1
a606 2
			    $$ = NEW_OP_ASGN_AND(gettable($1),
		                                 assignable($1, $3));
a614 4
			NODE *args = NEW_LIST($6);

			list_append($3, NEW_NIL());
			list_concat(args, $3);
d616 1
a616 1
			    $5 = 0;
d619 8
a626 1
			    $5 = 1;
a627 1
			$$ = NEW_OP_ASGN1($1, $5, args);
d633 1
a633 1
			    $4 = 0;
d636 4
a639 1
			    $4 = 1;
a640 1
			$$ = NEW_OP_ASGN2($1, $3, $4, $5);
d646 1
a646 1
			    $4 = 0;
d649 4
a652 1
			    $4 = 1;
a653 1
			$$ = NEW_OP_ASGN2($1, $3, $4, $5);
@


1.1.1.2.2.49
log
@1.1b9_31
@
text
@d6 1
a6 1
  $Date: 1998/07/09 08:40:19 $
d3439 1
a3439 1
	if (dyna_in_block() && dyna_var_defined(id)) return NEW_DVAR(id);
@


1.1.1.2.2.50
log
@1.1c3
@
text
@d6 1
a6 1
  $Date: 1998/07/15 06:12:52 $
d1388 1
a1388 1
f_arglist	: '(' f_args opt_nl ')'
d3059 1
a3059 3
	    else if (lex_state == EXPR_BEG ||
		     lex_state == EXPR_DOT ||
		     lex_state == EXPR_ARG){
@


1.1.1.2.2.51
log
@1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/08/27 03:55:22 $
d181 1
a181 1
%type <node> array assoc_list assocs assoc undef_list backref
d183 1
a183 1
%type <node> mlhs mlhs_head mlhs_tail mlhs_basic mlhs_entry mlhs_item lhs
d437 1
a437 1
		| tLPAREN mlhs_entry ')'
d442 2
a443 2
mlhs_entry	: mlhs_basic
		| tLPAREN mlhs_entry ')'
d469 2
a470 2
mlhs_item	: lhs
		| tLPAREN mlhs_entry ')'
d475 1
a475 1
mlhs_head	: mlhs_item ','
d477 1
a477 1
			$$ = $1;
d479 1
a479 2

mlhs_tail	: mlhs_item
d481 1
a481 1
			$$ = NEW_LIST($1);
d483 1
a483 1
		| mlhs_tail ',' mlhs_item
d3016 1
a3016 1
    if ((c == '!' || c == '?') && is_identchar(tok()[0])) {
d3050 17
a3073 17
		if (lex_state == EXPR_FNAME) {
		    lex_state = EXPR_END;
		    if ((c = nextc()) == '=') {
			tokadd(c);
		    }
		    else {
			pushback(c);
		    }
		}
	    }
	    if (lex_state == EXPR_BEG ||
		lex_state == EXPR_DOT ||
		lex_state == EXPR_ARG){
		lex_state = EXPR_ARG;
	    }
	    else {
		lex_state = EXPR_END;
d3556 4
a3559 1
    return NEW_CALL(recv, id_attrset(id), NEW_LIST(val));
d3568 1
a3568 1
	Error("Can't set variable $%d", node->nd_nth);
d3571 1
a3571 1
	Error("Can't set variable $%c", node->nd_nth);
d3972 1
a3972 1
static struct op_tbl op_tbl[] = {
d4018 3
a4020 2
static st_table *sym_tbl;
static st_table *sym_rev_tbl;
a4025 1
    sym_rev_tbl = st_init_numtable();
d4041 2
a4042 1
    id = 0;
d4055 6
a4060 5
	    for (i=0; op_tbl[i].token; i++) {
		if (*op_tbl[i].name == *name &&
		    strcmp(op_tbl[i].name, name) == 0) {
		    id = op_tbl[i].token;
		    goto id_regist;
d4063 4
d4076 3
a4078 2
	    id = id_attrset(rb_intern(buf));
	    goto id_regist;
d4081 1
a4081 1
	    id = ID_CONST;
d4084 1
a4084 1
	    id = ID_LOCAL;
d4088 1
a4088 5
    id |= ++last_id << ID_SCOPE_SHIFT;
  id_regist:
    name = strdup(name);
    st_add_direct(sym_tbl, name, id);
    st_add_direct(sym_rev_tbl, id, name);
d4092 18
d4114 1
a4114 1
    char *name;
d4119 3
a4121 3
	for (i=0; op_tbl[i].token; i++) {
	    if (op_tbl[i].token == id)
		return op_tbl[i].name;
d4125 4
a4128 4
    if (st_lookup(sym_rev_tbl, id, &name))
	return name;

    if (is_attrset_id(id)) {
d4136 1
a4136 1
	    char *buf = ALLOCA_N(char, strlen(res)+2);
d4144 1
a4144 1
    return 0;
d4161 17
@


1.1.1.2.2.52
log
@1.1c7
@
text
@d6 1
a6 1
  $Date: 1998/10/06 02:44:59 $
d572 1
a572 1
arg		: variable '=' {$$ = assignable($1, 0);} arg
d574 2
a575 3
		        $$ = $<node>3;
		        $$->nd_value = $4;
		        fixpos($$, $4);
a2386 3
	    if (!lex_input) {
		Error("embedded document not available in eval");
	    }
d2433 1
a2433 1
		    ArgError("here document not available in eval");
d4068 2
a4069 6
	    id = rb_intern(buf);
	    if (id > LAST_TOKEN) {
		id = id_attrset(id);
		goto id_regist;
	    }
	    id |= ID_ATTRSET;
@


1.1.1.2.2.53
log
@1.1c8
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:50 $
a587 5
		| primary '.' tCONSTANT '=' arg
		    {
			$$ = attrset($1, $3, $5);
		        fixpos($$, $5);
		    }
a1900 3
	  case '\n':
	    sourceline++;
	    break;
@


1.1.1.2.2.54
log
@1.1c9 - 1.1c final, hopefully
@
text
@d6 1
a6 1
  $Date: 1998/11/17 09:12:36 $
d1656 1
a1656 1
    sourcefile = f;
d1689 1
a1689 1
    return yycompile(strdup(f));
@


1.1.1.2.2.55
log
@1.2.2 PR1
@
text
@d6 1
a6 1
  $Date: 1998/11/26 08:25:45 $
d575 2
a576 4
			if ($$) {
			    $$->nd_value = $4;
			    fixpos($$, $4);
			}
@


1.1.1.2.2.56
log
@1.2.2 release
@
text
@d6 1
a6 1
  $Date: 1999/01/18 09:08:51 $
d2186 1
a2186 2
    VALUE lastline_save;
    int offset_save;
d2215 3
a2217 2
    lastline_save = lex_lastline;
    offset_save = lex_p - lex_pbeg;
d2265 3
a2267 5
    lex_lastline = lastline_save;
    lex_pbeg = RSTRING(lex_lastline)->ptr;
    lex_pend = lex_pbeg + RSTRING(lex_lastline)->len;
    lex_p = lex_pbeg + offset_save;

@


1.1.1.2.2.57
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/01/21 09:04:54 $
a1657 1
    heredoc_end = 0;
@


1.1.1.2.2.58
log
@1.2.4
@
text
@d6 1
a6 1
  $Date: 1999/02/09 03:29:23 $
d1711 1
a1711 3
		   RSTRING(v)->ptr[RSTRING(v)->len-2] == '\\' &&
		   (RSTRING(v)->len == 2 ||
		   RSTRING(v)->ptr[RSTRING(v)->len-2] != '\\')) {
a1966 2
		    int c1;

d1968 2
a1969 8
		    c1 = read_escape();
		    if (c1 != c) {
			tokadd(c1);
		    }
		    else {
			tokadd('\\');
			tokadd(c);
		    }
a2015 1
		nd_set_line(list, re_start);
a2093 1
	nd_set_line(list, strstart);
d2232 5
a2239 6
      retry:
	if (strncmp(eos, lex_p, len) == 0 &&
	    (lex_p[len] == '\n' || lex_p[len] == '\r')) {
	    break;
	}

a2263 3
	if (lex_p != lex_pend) {
	    goto retry;
	}
a2275 1
	nd_set_line(list, linesave+1);
a3232 2
	      case '\n':
		sourceline++;
a3552 3
    }
    else {
	idx = val;
@


1.1.1.2.2.59
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/04/08 10:14:33 $
a67 1
static int compile_for_eval = 0;
d364 1
a364 1
			if (compile_for_eval && (cur_mid || in_single)) {
d381 1
a381 1
			if (!compile_for_eval && !cur_mid && !in_single)
d430 1
a430 1
			if (!compile_for_eval && !cur_mid && !in_single)
d973 1
a973 1
			if (!compile_for_eval && !cur_mid && !in_single)
d980 1
a980 1
			if (!compile_for_eval && !cur_mid && !in_single)
d986 1
a986 1
			if (!compile_for_eval && !cur_mid && !in_single)
d1307 1
a1307 2
			if (!compile_for_eval && !cur_mid &&
		            !in_single && !in_defined)
d1313 1
a1313 2
			if (!compile_for_eval && !cur_mid &&
		            !in_single && !in_defined)
a1661 1
    cur_mid = 0;
a1677 2
    else		                	/* in eval() */
	compile_for_eval = 1;
@


1.1.1.2.2.60
log
@1.2.5 pre
@
text
@d6 1
a6 1
  $Date: 1999/04/09 18:04:07 $
d1680 1
a1680 1
    if (!sourcefile || strcmp(f, sourcefile))
d1682 2
a1683 1
    compile_for_eval = 1;
@


1.1.1.2.2.61
log
@to open CVS
@
text
@d6 1
a6 1
  $Date: 1999/04/13 05:54:24 $
d1592 1
d2193 2
@


1.1.1.2.2.62
log
@1.2.6
@
text
@d6 1
a6 1
  $Date: 1999/04/20 08:20:54 $
d22 5
d1838 2
a1839 3
		int cc = nextc();
		if (cc == -1) goto eof;
		buf[i] = cc;
a3251 2
		tokadd(c);
		break;
@


1.1.1.2.2.50.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/08/27 03:55:22 $
d42 4
a45 2
NODE *ruby_eval_tree_begin = 0;
NODE *ruby_eval_tree = 0;
d47 5
a51 2
char *ruby_sourcefile;		/* current source file */
int   ruby_sourceline;		/* current line no. */
d92 1
a92 1
static void rb_backref_error();
d105 5
a109 2
#define crerb_f_push() NEW_CREF()
static void crerb_f_pop();
d239 1
a239 1
		        $<vars>$ = ruby_dyna_vars;
d243 1
a243 1
			if ((VALUE)ruby_class == rb_cObject) class_nest = 0;
d248 1
a248 1
			ruby_eval_tree = block_append(ruby_eval_tree, $2);
d252 1
a252 1
		        ruby_dyna_vars = $<vars>1;
d277 1
a277 1
			    rb_compile_error("both block arg and actual block given");
d357 1
a357 1
			ruby_eval_tree_begin = block_append(ruby_eval_tree_begin,
d502 1
a502 1
		        rb_backref_error($1);
d589 1
a589 1
		        rb_backref_error($1);
d598 2
a599 2
			    else if (!rb_dvar_defined($1)) {
				rb_dvar_asgn($1, Qtrue);
d654 1
a654 1
		        rb_backref_error($1);
d793 1
a793 1
			    rb_compile_error("block argument should not be given");
d908 1
a908 1
				rb_compile_error("block argument should not be given");
d1012 1
a1012 1
			    rb_compile_error("both block arg and actual block given");
d1093 1
a1093 1
			crerb_f_push();
d1102 1
a1102 1
			crerb_f_pop();
d1108 1
a1108 1
			crerb_f_push();
d1117 1
a1117 1
			crerb_f_pop();
d1125 1
a1125 1
			crerb_f_push();
d1134 1
a1134 1
			crerb_f_pop();
d1582 1
a1582 1
static NODE *rb_str_extend();
d1598 1
d1600 1
a1600 1
    rb_compile_error("%s", msg);
d1619 1
a1619 1
	rb_compile_error_append("%s", buf);
d1630 1
a1630 1
	rb_compile_error_append("%s", buf);
d1647 1
a1647 1
    ruby_eval_tree = 0;
d1649 1
a1649 1
    ruby_sourcefile = strdup(f);
d1653 1
a1653 1
    if (n == 0) return ruby_eval_tree;
d1659 1
a1659 1
rb_compile_string(f, s, len)
d1666 2
a1667 2
    if (!ruby_sourcefile || strcmp(f, ruby_sourcefile))	/* not in eval() */
	ruby_sourceline = 1;
d1673 1
a1673 1
rb_compile_file(f, file, start)
d1680 1
a1680 1
    ruby_sourceline = start;
d1692 1
a1692 1
	    VALUE v = rb_io_gets(lex_input);
d1696 1
a1696 1
		ruby_sourceline = heredoc_end+1;
d1702 1
a1702 1
		VALUE v2 = rb_io_gets(lex_input);
d1705 1
a1705 1
		    rb_str_cat(v, RSTRING(v2)->ptr, RSTRING(v2)->len);
d1727 1
a1727 1
static void
d1889 1
a1889 1
    int re_start = ruby_sourceline;
d1907 1
a1907 1
	    list = rb_str_extend(list, term);
d1914 2
a1915 2
		ruby_sourceline = re_start;
		rb_compile_error("unterminated regexp meets end of file");
d1919 1
a1919 1
		ruby_sourceline++;
d1948 1
a1948 1
		    ruby_sourceline++;
d1962 1
a1962 1
	    rb_compile_error("unterminated regexp");
d2004 1
a2004 1
		    VALUE ss = rb_str_new(tok(), toklen());
d2013 1
a2013 1
		yylval.val = rb_reg_new(tok(), toklen(), options | kcode);
d2019 1
a2019 1
    rb_compile_error("unterminated regexp");
d2037 1
a2037 1
    strstart = ruby_sourceline;
d2042 2
a2043 2
	    ruby_sourceline = strstart;
	    rb_compile_error("unterminated string meets end of file");
d2051 1
a2051 1
	    ruby_sourceline++;
d2054 1
a2054 1
	    list = rb_str_extend(list, term);
d2061 1
a2061 1
		ruby_sourceline++;
d2082 1
a2082 1
	    VALUE ss = rb_str_new(tok(), toklen());
d2095 1
a2095 1
	yylval.val = rb_str_new(tok(), toklen());
d2108 1
a2108 1
    strstart = ruby_sourceline;
d2112 2
a2113 2
	    ruby_sourceline = strstart;
	    rb_compile_error("unterminated string meets end of file");
d2121 1
a2121 1
	    ruby_sourceline++;
d2127 1
a2127 1
		ruby_sourceline++;
d2150 1
a2150 1
    yylval.val = rb_str_new(tok(), toklen());
d2176 1
a2176 1
    int linesave = ruby_sourceline;
d2192 1
a2192 1
	    rb_compile_error("illegal here document");
d2209 1
a2209 1
    str = rb_str_new(0,0);
d2211 1
a2211 1
	line = rb_io_gets(lex_input);
d2214 1
a2214 1
	    rb_compile_error("unterminated string meets end of file");
d2218 1
a2218 1
	ruby_sourceline++;
d2230 1
a2230 1
	    rb_str_cat(yylval.val, "\n", 1);
d2232 1
a2232 1
	        rb_str_cat(str, RSTRING(yylval.val)->ptr, RSTRING(yylval.val)->len);
d2240 1
a2240 1
	    list_append(yylval.node, NEW_STR(rb_str_new2("\n")));
d2257 2
a2258 2
    heredoc_end = ruby_sourceline;
    ruby_sourceline = linesave;
d2281 1
a2281 1
    rb_warning("ambiguous first argument; make sure");
d2296 1
a2296 1
	ruby_sourceline += newline_seen;
d2320 1
a2320 1
		if (c == '\n') ruby_sourceline++;
d2325 1
a2325 1
		    ruby_sourceline++;
d2336 1
a2336 1
	    ruby_sourceline++;
d2389 1
a2389 1
		    ruby_sourceline++;
d2393 1
a2393 1
			rb_compile_error("embedded document meets end of file");
d2401 1
a2401 1
		ruby_sourceline++;
d2432 1
a2432 1
		    rb_raise(rb_eArgError, "here document not available");
d2484 1
a2484 1
	    rb_warning("a?b:c is undocumented feature ^^;;;");
d2493 1
a2493 1
	    rb_warning("a?b:c is undocumented feature ^^;;;");
d2644 1
a2644 1
		    yylval.val = rb_str2inum(tok(), 16);
d2656 1
a2656 1
		    yylval.val = rb_str2inum(tok(), 8);
d2724 1
a2724 1
		yylval.val = rb_float_new(atof(tok()));
d2727 1
a2727 1
	    yylval.val = rb_str2inum(tok(), 10);
d2844 1
a2844 1
	    ruby_sourceline++;
d2875 1
a2875 1
		rb_compile_error("unterminated quoted string meets end of file");
d3000 1
a3000 1
	    rb_compile_error("Invalid char '%c' in expression", c);
d3083 1
a3083 1
rb_str_extend(list, term)
d3105 1
a3105 1
    ss = rb_str_new(tok(), toklen());
d3142 1
a3142 1
		list_append(list, NEW_STR(rb_str_new2("#$")));
d3208 2
a3209 2
		    list_append(list, NEW_STR(rb_str_new2("#")));
		    rb_warning("bad substitution in string");
d3211 1
a3211 1
		    list_append(list, NEW_STR(rb_str_new(tok(), toklen())));
d3232 1
a3232 1
rb_node_newnode(type, a0, a1, a2)
d3240 2
a3241 2
    nd_set_line(n, ruby_sourceline);
    n->nd_file = ruby_sourcefile;
d3250 1
a3250 1
static enum node_type
d3257 1
a3257 1
static int
d3306 1
a3306 1
    if (RTEST(rb_verbose)) {
d3315 1
a3315 1
	    rb_warning("statement not reached");
d3435 1
a3435 1
	return NEW_STR(rb_str_new2(ruby_sourcefile));
d3438 1
a3438 1
	return NEW_LIT(INT2FIX(ruby_sourceline));
d3441 1
a3441 1
	if (dyna_in_block() && rb_dvar_defined(id)) return NEW_DVAR(id);
d3455 1
a3455 1
    rb_bug("invalid id for gettable");
d3486 1
a3486 1
	if (rb_dvar_defined(id)) {
d3493 1
a3493 1
	    rb_dvar_push(id, 0);
d3509 1
a3509 1
	rb_bug("bad id for variable");
d3540 1
a3540 1
rb_id_attrset(id)
d3563 1
a3563 1
rb_backref_error(node)
d3580 1
a3580 1
    if (node == 0) return Qtrue;
d3595 1
a3595 1
	return Qfalse;
d3611 1
a3611 1
	return Qtrue;
d3617 1
a3617 1
static int
d3650 1
a3650 1
	rb_warn("found = in conditional, should be ==");
d3657 1
a3657 1
	rb_warning("assignment in condition");
d3693 1
a3693 1
	    return NEW_MATCH(rb_reg_new(RSTRING(node)->ptr,RSTRING(node)->len,0));
d3733 1
a3733 1
    return rb_node_newnode(type, cond(left), cond(right));
d3773 2
d3852 1
a3852 1
    if (lvtbl == 0) return Qfalse;
d3854 1
a3854 1
	if (lvtbl->tbl[i] == id) return Qtrue;
d3856 1
a3856 1
    return Qfalse;
d3863 1
a3863 1
    lvtbl->cnt = ruby_scope->local_tbl?ruby_scope->local_tbl[0]:0;
d3866 1
a3866 1
	MEMCPY(lvtbl->tbl, ruby_scope->local_tbl, ID, lvtbl->cnt+1);
d3871 1
a3871 1
    if (ruby_dyna_vars)
d3887 1
a3887 1
	    if (i == 0 || ruby_scope->flag == SCOPE_ALLOCA) {
d3889 4
a3892 4
		if (ruby_scope->local_vars) {
		    *vars++ = ruby_scope->local_vars[-1];
		    MEMCPY(vars, ruby_scope->local_vars, VALUE, i);
		    rb_mem_clear(vars+i, len-i);
d3896 1
a3896 1
		    rb_mem_clear(vars, len);
d3898 2
a3899 2
		ruby_scope->local_vars = vars;
		ruby_scope->flag |= SCOPE_MALLOC;
d3902 1
a3902 1
		VALUE *vars = ruby_scope->local_vars-1;
d3904 2
a3905 2
		ruby_scope->local_vars = vars+1;
		rb_mem_clear(ruby_scope->local_vars+i, len-i);
d3907 2
a3908 2
	    if (ruby_scope->local_tbl && ruby_scope->local_vars[-1] == 0) {
		free(ruby_scope->local_tbl);
d3910 2
a3911 2
	    ruby_scope->local_vars[-1] = 0;
	    ruby_scope->local_tbl = local_tbl();
d3921 1
a3921 1
    return ruby_dyna_vars;
d3929 1
a3929 1
    ruby_dyna_vars = vars;
d3939 1
a3939 1
crerb_f_pop()
d3945 1
a3945 1
rb_parser_append_print()
d3947 2
a3948 2
    ruby_eval_tree =
	block_append(ruby_eval_tree,
d3954 1
a3954 1
rb_parser_while_loop(chop, split)
d3958 1
a3958 1
	ruby_eval_tree =
d3962 1
a3962 1
				   ruby_eval_tree);
d3965 1
a3965 1
	ruby_eval_tree =
d3967 1
a3967 1
				  rb_intern("chop!"), 0), ruby_eval_tree);
d3969 1
a3969 1
    ruby_eval_tree = NEW_OPT_N(ruby_eval_tree);
d3972 1
a3972 4
static struct {
    ID token;
    char *name;
} op_tbl[] = {
d4018 3
a4020 2
static st_table *sym_tbl;
static st_table *sym_rev_tbl;
d4025 1
a4025 2
    sym_tbl = st_init_strtable_with_size(900);
    sym_rev_tbl = st_init_numtable_with_size(900);
d4056 4
a4059 4
	    for (i=0; op_tbl[i].token; i++) {
		if (*op_tbl[i].name == *name &&
		    strcmp(op_tbl[i].name, name) == 0) {
		    id = op_tbl[i].token;
d4064 2
a4065 2
		rb_raise(rb_eNameError, "Unknown operator `%s'", name);
	    }	
d4088 1
a4088 3
    name = strdup(name);
    st_add_direct(sym_tbl, name, id);
    st_add_direct(sym_rev_tbl, id, name);
d4092 18
d4114 1
a4114 1
    char *name;
d4119 3
a4121 3
	for (i=0; op_tbl[i].token; i++) {
	    if (op_tbl[i].token == id)
		return op_tbl[i].name;
d4125 4
a4128 4
    if (st_lookup(sym_rev_tbl, id, &name))
	return name;

    if (is_attrset_id(id)) {
d4136 1
a4136 1
	    char *buf = ALLOCA_N(char, strlen(res)+2);
d4144 1
a4144 1
    return 0;
d4151 2
a4152 2
    if (is_const_id(id)) return Qtrue;
    return Qfalse;
d4159 19
a4177 2
    if (is_instance_id(id)) return Qtrue;
    return Qfalse;
d4190 1
a4190 1
    ruby_scope->local_vars[cnt] = val;
d4194 1
a4194 1
rb_backref_get()
d4196 2
a4197 2
    if (ruby_scope->local_vars) {
	return ruby_scope->local_vars[1];
d4203 1
a4203 1
rb_backref_set(val)
d4206 2
a4207 2
    if (ruby_scope->local_vars) {
	ruby_scope->local_vars[1] = val;
d4215 1
a4215 1
rb_lastline_get()
d4217 2
a4218 2
    if (ruby_scope->local_vars) {
	return ruby_scope->local_vars[0];
d4224 1
a4224 1
rb_lastline_set(val)
d4227 2
a4228 2
    if (ruby_scope->local_vars) {
	ruby_scope->local_vars[0] = val;
@


1.1.1.2.2.50.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/10/06 02:44:59 $
d100 2
a101 2
#define cref_push() NEW_CREF()
static void cref_pop();
d173 1
a173 1
%type <node> array assoc_list assocs assoc undef_list backref
d175 1
a175 1
%type <node> mlhs mlhs_head mlhs_tail mlhs_basic mlhs_entry mlhs_item lhs
d375 1
a375 1
			$$ = NEW_RETURN($2);
d429 1
a429 1
		| tLPAREN mlhs_entry ')'
d434 2
a435 2
mlhs_entry	: mlhs_basic
		| tLPAREN mlhs_entry ')'
d461 2
a462 2
mlhs_item	: lhs
		| tLPAREN mlhs_entry ')'
d467 1
a467 1
mlhs_head	: mlhs_item ','
d469 1
a469 1
			$$ = $1;
d471 1
a471 2

mlhs_tail	: mlhs_item
d473 1
a473 1
			$$ = NEW_LIST($1);
d475 1
a475 1
		| mlhs_tail ',' mlhs_item
d959 1
a959 1
			$$ = NEW_RETURN($3);
d965 1
a965 1
			$$ = NEW_RETURN(0);
d971 1
a971 1
			$$ = NEW_RETURN(0);
d1085 1
a1085 1
			cref_push();
d1094 1
a1094 1
			cref_pop();
d1100 1
a1100 1
			cref_push();
d1109 1
a1109 1
			cref_pop();
d1117 1
a1117 1
			cref_push();
d1126 1
a1126 1
			cref_pop();
d3007 1
a3007 1
    if ((c == '!' || c == '?') && is_identchar(tok()[0])) {
d3041 17
a3064 17
		if (lex_state == EXPR_FNAME) {
		    lex_state = EXPR_END;
		    if ((c = nextc()) == '=') {
			tokadd(c);
		    }
		    else {
			pushback(c);
		    }
		}
	    }
	    if (lex_state == EXPR_BEG ||
		lex_state == EXPR_DOT ||
		lex_state == EXPR_ARG){
		lex_state = EXPR_ARG;
	    }
	    else {
		lex_state = EXPR_END;
d3547 4
a3550 1
    return NEW_CALL(recv, rb_id_attrset(id), NEW_LIST(val));
d3559 1
a3559 1
	rb_compile_error("Can't set variable $%d", node->nd_nth);
d3562 1
a3562 1
	rb_compile_error("Can't set variable $%c", node->nd_nth);
d3724 1
a3724 1
    return rb_node_newnode(type, cond(left), cond(right), 0);
d3928 1
a3928 1
cref_pop()
d4033 2
a4034 1
    id = 0;
d4047 1
d4052 1
a4052 1
		    goto id_regist;
d4055 4
d4068 3
a4070 2
	    id = rb_id_attrset(rb_intern(buf));
	    goto id_regist;
d4073 1
a4073 1
	    id = ID_CONST;
d4076 1
a4076 1
	    id = ID_LOCAL;
a4079 2
    id |= ++last_id << ID_SCOPE_SHIFT;
  id_regist:
@


1.1.1.2.2.50.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/11/17 09:12:36 $
a91 1
static int  local_append();
d169 1
a169 1
%type <node> opt_call_args call_args ret_args args when_args
d564 1
a564 1
arg		: variable '=' {$$ = assignable($1, 0);} arg
d566 2
a567 3
			$$ = $<node>3;
			$$->nd_value = $4;
		        fixpos($$, $4);
a578 5
		| primary '.' tCONSTANT '=' arg
		    {
			$$ = attrset($1, $3, $5);
		        fixpos($$, $5);
		    }
d585 1
a585 1
		| variable tOP_ASGN {$$ = assignable($1, 0);} arg
d587 8
d596 2
a597 2
			    $<node>3->nd_value = $4;
			    $$ = NEW_OP_ASGN_OR(gettable($1), $<node>3);
d600 2
a601 2
			    $<node>3->nd_value = $4;
			    $$ = NEW_OP_ASGN_AND(gettable($1), $<node>3);
d604 1
a604 2
			    $$ = $<node>3;
			    $$->nd_value = call_op(gettable($1), $2, 1, $4);
d606 1
a606 1
			fixpos($$, $4);
d834 1
a834 1
			$$ = arg_blk_pass(NEW_RESTARGS($2), $3);
d874 1
a874 2
		            $1->nd_next == 0)
			{
a1063 1
		  opt_else
d1067 1
a1067 1
			if (!$3 && !$4 && !$5)
d1070 2
a1071 6
			    if ($3) $2 = NEW_RESCUE($2, $3, $4);
			    else if ($4) {
				rb_warn("else without rescue is useless");
				$2 = block_append($2, $4);
			    }
			    if ($5) $2 = NEW_ENSURE($2, $5);
d1186 1
d1303 1
a1303 1
case_body	: kWHEN when_args then
a1309 12
when_args	: args
		| args ',' tSTAR arg
		    {
			value_expr($4);
			$$ = list_append($1, NEW_WHEN($4, 0, 0));
		    }
		| tSTAR arg
		    {
			value_expr($2);
			$$ = NEW_LIST(NEW_WHEN($2, 0, 0));
		    }

a1578 1
static VALUE (*lex_gets)();	/* gets function */
d1641 1
a1641 1
    ruby_sourcefile = f;
a1649 21
static int lex_gets_ptr;

static VALUE
lex_get_str(s)
    VALUE s;
{
    char *beg, *end, *pend;

    beg = RSTRING(s)->ptr;
    if (lex_gets_ptr) {
	beg += lex_gets_ptr;
    }
    pend = RSTRING(s)->ptr + RSTRING(s)->len;
    end = beg;
    while (end < pend) {
	if (*end++ == '\n') break;
    }
    lex_gets_ptr = end - RSTRING(s)->ptr;
    return rb_str_new(beg, end - beg);
}

d1651 3
a1653 3
rb_compile_string(f, s)
    char *f;
    VALUE s;
d1655 3
a1657 4
    lex_gets = lex_get_str;
    lex_gets_ptr = 0;
    lex_input = s;
    lex_pbeg = lex_p = lex_pend = 0;
a1664 8
rb_compile_cstr(f, s, len)
    char *f, *s;
    int len;
{
    return rb_compile_string(f, rb_str_new(s, len));
}

NODE*
a1669 1
    lex_gets = rb_io_gets;
d1674 1
a1674 1
    return yycompile(strdup(f));
d1684 1
a1684 1
	    VALUE v = (*lex_gets)(lex_input);
d1694 1
a1694 1
		VALUE v2 = (*lex_gets)(lex_input);
a1890 3
	  case '\n':
	    ruby_sourceline++;
	    break;
a2028 6
    if (func == 0) {		/* read 1 line for heredoc */
	ruby_sourceline++;
				/* -1 for chomp */
	yylval.val = rb_str_new(lex_pbeg, lex_pend - lex_pbeg - 1);
	return tSTRING;
    }
d2066 1
a2066 4
	if (c == term) {
	    nest--;
	    if (nest == 0) break;
	}
d2137 1
a2137 4
	if (c == term) {
	    nest--;
	    if (nest == 0) break;
	}
a2177 1
	if (term == '\'') term = 0;
d2184 2
a2185 2
	    rb_warn("Use of bare << to mean <<\"\" is deprecated");
	    break;
d2203 1
a2203 1
	line = (*lex_gets)(lex_input);
d2206 1
a2206 2
	    ruby_sourceline = linesave;
	    rb_compile_error("can't find string \"%s\" anywhere before EOF", eos);
a2255 1
      case '\0':
d2423 3
d2476 1
d2485 1
d3511 1
a3511 1
    return NEW_ARGSCAT(node1, node2);
a3670 1
	node->nd_cnt = local_append(0);
d3805 1
a3805 1
local_append(id)
d3808 8
a3833 14
local_cnt(id)
    ID id;
{
    int cnt, max;

    if (id == 0) return lvtbl->cnt;

    for (cnt=1, max=lvtbl->cnt+1; cnt<max ;cnt++) {
	if (lvtbl->tbl[cnt] == id) return cnt-1;
    }
    return local_append(id);
}

static int
d4014 2
a4015 2
    sym_tbl = st_init_strtable_with_size(200);
    sym_rev_tbl = st_init_numtable_with_size(200);
d4060 2
a4061 6
	    id = rb_intern(buf);
	    if (id > LAST_TOKEN) {
		id = rb_id_attrset(id);
		goto id_regist;
	    }
	    id |= ID_ATTRSET;
@


1.1.1.2.2.50.2.4
log
@first public release of 1.1d (pre1.2) series
@
text
@d6 1
a6 1
  $Date: 1998/11/26 08:25:45 $
d1153 1
a1153 1
		| kDEF singleton dot_or_colon {lex_state = EXPR_FNAME;} fname
a1286 1
		        fixpos($$, $1);
a1559 3
dot_or_colon	: '.'
		| tCOLON2

a1725 14

static void
normalize_newline(line)
    VALUE line;
{
    if (RSTRING(line)->len >= 2 &&
	RSTRING(line)->ptr[RSTRING(line)->len-1] == '\n' &&
	RSTRING(line)->ptr[RSTRING(line)->len-2] == '\r')
    {
	RSTRING(line)->ptr[RSTRING(line)->len-2] = '\n';
	RSTRING(line)->len--;
    }
}

a1739 1
	    normalize_newline(v);
a1745 1
		    normalize_newline(v2);
d1751 2
a1752 1
	    if (strncmp(lex_pbeg, "__END__", 7) == 0 && lex_pbeg[7] == '\n') {
d2223 1
a2223 1
here_document(term, indent)
a2224 1
    int indent;
d2227 1
a2227 1
    char *eos, *p;
a2275 1
        normalize_newline(line);
d2277 3
a2279 7
	p = RSTRING(line)->ptr;
	if (indent) {
	    while (*p && (*p == ' ' || *p == '\t')) {
		p++;
	    }
	}
	if (strncmp(eos, p, len) == 0 && p[len] == '\n') {
a2488 5
	    int indent = 0;
	    if (c2 == '-') {
		indent = 1;
		c2 = nextc();
	    }
d2490 1
a2490 1
		return here_document(c2, indent);
@


1.1.1.2.2.50.2.5
log
@1.1d1
@
text
@d6 1
a6 1
  $Date: 1998/12/16 07:30:32 $
a1681 1
	if (RSTRING(s)->len == lex_gets_ptr) return Qnil;
d2249 1
a2249 2
    VALUE str;
    volatile VALUE line;
a2309 7
#if 0
	if (indent) {
	    while (*lex_p && *lex_p == '\t') {
		lex_p++;
	    }
	}
#endif
@
