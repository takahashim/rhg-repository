head	1.10;
access;
symbols
	v1_6_4:1.8.2.1
	v1_7_1:1.9
	v1_6_4_preview4:1.8.2.1
	v1_6_4_preview3:1.8.2.1
	v1_6_4_preview2:1.8
	v1_6_4_preview1:1.8
	v1_6_3:1.8
	ruby_m17n:1.8.0.4
	ruby_1_6:1.8.0.2
	v1_6_2:1.8
	v1_6_1:1.7
	v1_6_0:1.7
	v1_4_6:1.4
	v1_4_5:1.4
	v1_4_4:1.4
	ruby_1_4_3:1.4
	ruby1_4_3:1.4
	v1_4_3:1.4
	v1_5_0:1.4
	ruby_1_4_3_pre1:1.4
	ruby_1_4:1.4.0.2
	v1_4_2:1.2
	v1_4_1:1.2
	v1_4_0:1.2
	v1_3_7:1.1.1.1.2.7
	v1_3_6_repack:1.1.1.1.2.7
	v1_3_6:1.1.1.1.2.7
	v1_3_5:1.1.1.1.2.6
	v1_2_6repack:1.1.2.7
	v1_3_4_990625:1.1.1.1.2.6
	v1_3_4_990624:1.1.1.1.2.6
	v1_2_6:1.1.2.7
	v1_3_4_990611:1.1.1.1.2.6
	v1_3_4_990531:1.1.1.1.2.6
	v1_3_3_990518:1.1.1.1.2.6
	v1_3_3_990513:1.1.1.1.2.6
	v1_3_3_990507:1.1.1.1.2.6
	v1_2_5:1.1.2.7
	v1_2_4:1.1.2.7
	v1_3_1_990225:1.1.1.1.2.4
	v1_3_1_990224:1.1.1.1.2.4
	v1_3_1_990215:1.1.1.1.2.3
	v1_3_1_990212:1.1.1.1.2.3
	v1_3_1_990210:1.1.1.1.2.3
	v1_3_1_:1.1.1.1.2.3
	v1_3_1_990209:1.1.1.1.2.2
	v1_3_1_990205:1.1.1.1.2.2
	v1_3_1_990203:1.1.1.1.2.2
	v1_3_1_990201:1.1.1.1.2.2
	v1_3_1"_990201:1.1.1.1.2.2
	v1_3_1_990128:1.1.1.1.2.1
	v1_3_1_990127:1.1.1.1.2.1
	v1_3_1_990126:1.1.1.1.2.1
	ruby_1_3:1.1.1.1.0.2
	v1_2_2:1.1.2.7
	RUBY_1_3:1.1.1.1
	RUBY:1.1.1
	v1_2_2_pr1:1.1.2.7
	v1_2_1repack:1.1.2.7
	v1_2_1:1.1.2.7
	v1_2_stable:1.1.2.7
	v1_1d1:1.1.2.7.2.2
	v1_1d0:1.1.2.7.2.2
	v1_1c9_1:1.1.2.7
	v1_1c9:1.1.2.7
	v1_1c8:1.1.2.7
	v1_1c7:1.1.2.7
	v1_1c6:1.1.2.7
	v1_1d-start:1.1.2.7.2.1
	v1_1c5:1.1.2.7
	v1_1dev:1.1.2.7.0.2
	v1_1c4:1.1.2.7
	v1_1c3:1.1.2.7
	v1_1c2:1.1.2.7
	v1_1c1:1.1.2.7
	v1_1c0:1.1.2.7
	v1_1b9_31:1.1.2.7
	v1_1b9_30:1.1.2.7
	v1_1b9_28:1.1.2.7
	v1_1b9_27:1.1.2.7
	v1_1b9_26:1.1.2.7
	r1_1b9_25:1.1.2.7
	r1_1b9_24:1.1.2.6
	v1_1b9_23:1.1.2.6
	v1_1b9_22:1.1.2.6
	v1_1b9_20:1.1.2.6
	v1_1b9_18:1.1.2.5
	v1_1b9_16:1.1.2.4
	v1_1b9_15:1.1.2.3
	v1_1b9_13:1.1.2.3
	v1_1b9_12:1.1.2.3
	v1_1b9_11:1.1.2.3
	v1_1b9_08:1.1.2.3
	v1_1b9_07:1.1.2.3
	r1_1b9:1.1.2.3
	v1_1b8:1.1.2.3
	v1_1b7:1.1.2.2
	v1_1b6:1.1.2.1
	v1_1r:1.1.0.2;
locks; strict;
comment	@# @;


1.10
date	2001.07.19.05.42.06;	author knu;	state dead;
branches;
next	1.9;

1.9
date	2001.05.10.18.34.20;	author knu;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.05.09.57.00;	author matz;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.07.10.04.49.10;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.07.03.20.51;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.06.04.15.29;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.10.12.04.53.32;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.10.04.04.51.04;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.01;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.13.00.21;	author matz;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	99.01.20.04.59.21;	author matz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	99.01.26.10.08.08;	author matz;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	99.02.01.07.34.53;	author matz;	state Exp;
branches;
next	1.1.1.1.2.3;

1.1.1.1.2.3
date	99.02.10.08.44.23;	author matz;	state Exp;
branches;
next	1.1.1.1.2.4;

1.1.1.1.2.4
date	99.02.24.04.31.16;	author matz;	state Exp;
branches;
next	1.1.1.1.2.5;

1.1.1.1.2.5
date	99.03.24.08.52.23;	author matz;	state Exp;
branches;
next	1.1.1.1.2.6;

1.1.1.1.2.6
date	99.04.09.17.57.35;	author matz;	state Exp;
branches;
next	1.1.1.1.2.7;

1.1.1.1.2.7
date	99.07.28.09.26.26;	author matz;	state Exp;
branches;
next	;

1.1.2.1
date	98.01.16.13.00.21;	author matz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	98.02.02.04.49.12;	author matz;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	98.02.20.08.28.44;	author matz;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	98.04.28.06.16.06;	author matz;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	98.05.12.08.36.44;	author matz;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	98.05.14.04.10.19;	author matz;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	98.06.11.10.02.53;	author matz;	state Exp;
branches
	1.1.2.7.2.1;
next	;

1.1.2.7.2.1
date	98.09.08.07.08.27;	author matz;	state Exp;
branches;
next	1.1.2.7.2.2;

1.1.2.7.2.2
date	98.12.16.07.30.28;	author matz;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.10.18.37.52;	author knu;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.19.05.44.25;	author knu;	state dead;
branches;
next	;


desc
@@


1.10
log
@Rename *.jp to *.ja, since jp is a region code and ja is a language
code.
@
text
@.\" README.EXT -  -*- Text -*- created at: Mon Aug  7 16:45:54 JST 1995

Rubyの拡張ライブラリの作り方を説明します．

1．基礎知識

Cの変数には型があり，データには型がありません．ですから，た
とえばポインタをintの変数に代入すると，その値は整数として取
り扱われます．逆にRubyの変数には型がなく，データに型がありま
す．この違いのため，CとRubyは相互に変換しなければ，お互いの
データをアクセスできません．

RubyのデータはVALUEというCの型で表現されます．VALUE型のデー
タはそのデータタイプを自分で知っています．このデータタイプと
いうのはデータ(オブジェクト)の実際の構造を意味していて，Ruby
のクラスとはまた違ったものです．

VALUEからCにとって意味のあるデータを取り出すためには

 (1) VALUEのデータタイプを知る
 (2) VALUEをCのデータに変換する

の両方が必要です．(1)を忘れると間違ったデータの変換が行われ
て，最悪プログラムがcore dumpします．

1.1 データタイプ

Rubyにはユーザが使う可能性のある以下のタイプがあります．

	T_NIL		nil
	T_OBJECT	通常のオブジェクト
	T_CLASS		クラス
	T_MODULE	モジュール
	T_FLOAT		浮動小数点数
	T_STRING	文字列
	T_REGEXP	正規表現
	T_ARRAY		配列
	T_FIXNUM	Fixnum(31bit長整数)
	T_HASH		連想配列
	T_STRUCT	(Rubyの)構造体
	T_BIGNUM	多倍長整数
	T_FILE		入出力
	T_TRUE		真
	T_FALSE		偽
	T_DATA		データ
	T_SYMBOL	シンボル

その他に内部で利用されている以下のタイプがあります．

	T_ICLASS
	T_MATCH
	T_UNDEF
	T_VARMAP
	T_SCOPE
	T_NODE

ほとんどのタイプはCの構造体で実装されています．

1.2 VALUEのデータタイプをチェックする

ruby.hではTYPE()というマクロが定義されていて，VALUEのデータ
タイプを知ることが出来ます．TYPE()マクロは上で紹介したT_XXXX
の形式の定数を返します．VALUEのデータタイプに応じて処理する
場合には，TYPE()の値で分岐することになります．

  switch (TYPE(obj)) {
    case T_FIXNUM:
      /* FIXNUMの処理 */
      break;
    case T_STRING:
      /* 文字列の処理 */
      break;
    case T_ARRAY:
      /* 配列の処理 */
      break;
    default:
      /* 例外を発生させる */
      rb_raise(rb_eTypeError, "not valid value");
      break;
  }

それとデータタイプをチェックして，正しくなければ例外を発生す
る関数が用意されています．

  void Check_Type(VALUE value, int type)

この関数はvalueがtypeで無ければ，例外を発生させます．引数と
して与えられたVALUEのデータタイプが正しいかどうかチェックす
るためには，この関数を使います．

FIXNUMとNILに関してはより高速な判別マクロが用意されています．

  FIXNUM_P(obj)
  NIL_P(obj)

1.3 VALUEをCのデータに変換する

データタイプがT_NIL, T_FALSE, T_TRUEである時，データはそれぞ
れnil, false, trueです．このデータタイプのオブジェクトはひと
つずつしか存在しません．

データタイプがT_FIXNUMの時，これは31bitのサイズを持つ整数で
す．FIXNUMをCの整数に変換するためにはマクロ「FIX2INT()」を使
います．それから，FIXNUMに限らずRubyのデータを整数に変換する
「NUM2INT()」というマクロがあります．このマクロはデータタイ
プのチェック無しで使えます(整数に変換できない場合には例外が
発生する)．

同様にチェック無しで使える変換マクロはdoubleを取り出す
「NUM2DBL()」とchar*を取り出す「STR2CSTR()」があります．

それ以外のデータタイプは対応するCの構造体があります．対応す
る構造体のあるVALUEはそのままキャスト(型変換)すれば構造体の
ポインタに変換できます．

構造体は「struct RXxxxx」という名前でruby.hで定義されていま
す．例えば文字列は「struct RString」です．実際に使う可能性が
あるのは文字列と配列くらいだと思います．

ruby.hでは構造体へキャストするマクロも「RXXXXX()」(全部大文
字にしたもの)という名前で提供されています(例: RSTRING())．

例えば，文字列strの長さを得るためには「RSTRING(str)->len」と
し，文字列strをchar*として得るためには「RSTRING(str)->ptr」
とします．配列の場合には，それぞれ「RARRAY(ary)->len」，
「RARRAY(ary)->ptr」となります．

Rubyの構造体を直接アクセスする時に気をつけなければならないこ
とは，配列や文字列の構造体の中身は参照するだけで，直接変更し
ないことです．直接変更した場合，オブジェクトの内容の整合性が
とれなくなって，思わぬバグの原因になります．

1.4 CのデータをVALUEに変換する

VALUEの実際の構造は

  * FIXNUMの場合

    1bit左シフトして，LSBを立てる．

  * その他のポインタの場合

    そのままVALUEにキャストする．

となっています．よって，LSBをチェックすればVALUEがFIXNUMかど
うかわかるわけです(ポインタのLSBが立っていないことを仮定して
いる)．

ですから，FIXNUM以外のRubyのオブジェクトの構造体は単にVALUE
にキャストするだけでVALUEに変換出来ます．ただし，任意の構造
体がVALUEにキャスト出来るわけではありません．キャストするの
はRubyの知っている構造体(ruby.hで定義されているstruct RXxxx
のもの)だけです．

FIXNUMに関しては変換マクロを経由する必要があります．Cの整数
からVALUEに変換するマクロは以下のものがあります．必要に応じ
て使い分けてください．

  INT2FIX()	もとの整数が31bit以内に収まる自信がある時
  INT2NUM()	任意の整数からVALUEへ

INT2NUM()は整数がFIXNUMの範囲に収まらない場合，Bignumに変換
してくれます(が，少し遅い)．

1.5 Rubyのデータを操作する

先程も述べた通り，Rubyの構造体をアクセスする時に内容の更新を
行うことは勧められません．で，Rubyのデータを操作する時には
Rubyが用意している関数を用いてください．

ここではもっとも使われるであろう文字列と配列の生成/操作を行
い関数をあげます(全部ではないです)．

 文字列に対する関数

  rb_str_new(const char *ptr, long len)

    新しいRubyの文字列を生成する．

  rb_str_new2(const char *ptr)

    Cの文字列からRubyの文字列を生成する．この関数の機能は
    rb_str_new(ptr, strlen(ptr))と同等である．

  rb_tainted_str_new(const char *ptr, long len)

    汚染マークが付加された新しいRubyの文字列を生成する．外部
    からのデータに基づく文字列には汚染マークが付加されるべき
    である．

  rb_tainted_str_new2(const char *ptr)

    Cの文字列から汚染マークが付加されたRubyの文字列を生成する．

  rb_str_cat(VALUE str, const char *ptr, long len)

    Rubyの文字列strにlenバイトの文字列ptrを追加する．

 配列に対する関数

  rb_ary_new()

    要素が0の配列を生成する．

  rb_ary_new2(long len)

    要素が0の配列を生成する．len要素分の領域をあらかじめ割り
    当てておく．

  rb_ary_new3(long n, ...)

    引数で指定したn要素を含む配列を生成する．

  rb_ary_new4(long n, VALUE *elts)

    配列で与えたn要素の配列を生成する．

  rb_ary_push(VALUE ary, VALUE val)
  rb_ary_pop(VALUE ary)
  rb_ary_shift(VALUE ary)
  rb_ary_unshift(VALUE ary, VALUE val)

    Arrayの同名のメソッドと同じ働きをする関数．第1引数は必ず
    配列でなければならない．

2．Rubyの機能を使う

原理的にRubyで書けることはCでも書けます．RubyそのものがCで記
述されているんですから，当然といえば当然なんですけど．ここで
はRubyの拡張に使うことが多いだろうと予測される機能を中心に紹
介します．

2.1 Rubyに機能を追加する

Rubyで提供されている関数を使えばRubyインタプリタに新しい機能
を追加することができます．Rubyでは以下の機能を追加する関数が
提供されています．

 * クラス，モジュール
 * メソッド，特異メソッドなど
 * 定数

では順に紹介します．

2.1.1 クラス/モジュール定義

クラスやモジュールを定義するためには，以下の関数を使います．

  VALUE rb_define_class(const char *name, VALUE super)
  VALUE rb_define_module(const char *name)

これらの関数は新しく定義されたクラスやモジュールを返します．
メソッドや定数の定義にこれらの値が必要なので，ほとんどの場合
は戻り値を変数に格納しておく必要があるでしょう．

クラスやモジュールを他のクラスの内部にネストして定義する時に
は以下の関数を使います．

  VALUE rb_define_class_under(VALUE outer, const char *name, VALUE super)
  VALUE rb_define_module_under(VALUE outer, const char *name)

2.1.2 メソッド/特異メソッド定義

メソッドや特異メソッドを定義するには以下の関数を使います．

  void rb_define_method(VALUE klass, const char *name, 
		        VALUE (*func)(), int argc)

  void rb_define_singleton_method(VALUE object, const char *name, 
			          VALUE (*func)(), int argc)


念のため説明すると「特異メソッド」とは，その特定のオブジェク
トに対してだけ有効なメソッドです．RubyではよくSmalltalkにお
けるクラスメソッドとして，クラスに対する特異メソッドが使われ
ます．

これらの関数の argcという引数はCの関数へ渡される引数の数(と
形式)を決めます．argcが0以上の時は関数に引き渡す引数の数を意
味します．16個以上の引数は使えません(が，要りませんよね，そ
んなに)．実際の関数には先頭の引数としてselfが与えられますの
で，指定した数より1多い引数を持つことになります．

argcが負の時は引数の数ではなく，形式を指定したことになります．
argcが-1の時は引数を配列に入れて渡されます．argcが-2の時は引
数はRubyの配列として渡されます．

メソッドを定義する関数はもう二つあります．ひとつはprivateメ
ソッドを定義する関数で，引数はrb_define_method()と同じです．

  void rb_define_private_method(VALUE klass, const char *name, 
				VALUE (*func)(), int argc)

privateメソッドとは関数形式でしか呼び出すことの出来ないメソッ
ドです．

もうひとつはモジュール関数を定義するものです．モジュール関数
とはモジュールの特異メソッドであり，同時にprivateメソッドで
もあるものです．例をあげるとMathモジュールのsqrt()などがあげ
られます．このメソッドは

  Math.sqrt(4)

という形式でも

  include Math
  sqrt(4)

という形式でも使えます．モジュール関数を定義する関数は以下の
通りです．

  void rb_define_module_function(VALUE module, const char *name, 
		                 VALUE (*func)(), int argc)

関数的メソッド(Kernelモジュールのprivate method)を定義するた
めの関数は以下の通りです．

  void rb_define_global_function(const char *name, VALUE (*func)(), int argc)


メソッドの別名を定義するための関数は以下の通りです。

  void rb_define_alias(VALUE module, const char* new, const char* old);

2.1.3 定数定義

拡張ライブラリが必要な定数はあらかじめ定義しておいた方が良い
でしょう．定数を定義する関数は二つあります．

  void rb_define_const(VALUE klass, const char *name, VALUE val)
  void rb_define_global_const(const char *name, VALUE val)

前者は特定のクラス/モジュールに属する定数を定義するもの，後
者はグローバルな定数を定義するものです．

2.2 Rubyの機能をCから呼び出す

既に『1.5 Rubyのデータを操作する』で一部紹介したような関数を
使えば，Rubyの機能を実現している関数を直接呼び出すことが出来
ます．

# このような関数の一覧表はいまのところありません．ソースを見
# るしかないですね．

それ以外にもRubyの機能を呼び出す方法はいくつかあります．

2.2.1 Rubyのプログラムをevalする

CからRubyの機能を呼び出すもっとも簡単な方法として，文字列で
与えられたRubyのプログラムを評価する以下の関数があります．

  VALUE rb_eval_string(const char *str)

この評価は現在の環境で行われます．つまり，現在のローカル変数
などを受け継ぎます．

2.2.2 IDまたはシンボル

Cから文字列を経由せずにRubyのメソッドを呼び出すこともできま
す．その前に，Rubyインタプリタ内でメソッドや変数名を指定する
時に使われているIDについて説明しておきましょう．

IDとは変数名，メソッド名を表す整数です．Rubyの中では

 :識別子

でアクセスできます．Cからこの整数を得るためには関数

  rb_intern(const char *name)

を使います．Rubyから引数として与えられたシンボル(または文字
列)をIDに変換するには以下の関数を使います．

  rb_to_id(VALUE symbol)

2.2.3 CからRubyのメソッドを呼び出す

Cから文字列を経由せずにRubyのメソッドを呼び出すためには以下
の関数を使います．

  VALUE rb_funcall(VALUE recv, ID mid, int argc, ...)

この関数はオブジェクトrecvのmidで指定されるメソッドを呼び出
します．その他に引数の指定の仕方が違う以下の関数もあります．

  VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv)
  VALUE rb_apply(VALUE recv, ID mid, VALUE args)

applyには引数としてRubyの配列を与えます．

2.2.4 変数/定数を参照/更新する

Cから関数を使って参照・更新できるのは，定数，インスタンス変
数です．大域変数は一部のものはCの大域変数としてアクセスでき
ます．ローカル変数を参照する方法は公開していません．

オブジェクトのインスタンス変数を参照・更新する関数は以下の通
りです．

  VALUE rb_ivar_get(VALUE obj, ID id)
  VALUE rb_ivar_set(VALUE obj, ID id, VALUE val)

idはrb_intern()で得られるものを使ってください．

定数を参照するには以下の関数を使ってください．

  VALUE rb_const_get(VALUE obj, ID id)

定数を新しく定義するためには『2.1.3 定数定義』で紹介さ
れている関数を使ってください．

3．RubyとCとの情報共有

C言語とRubyの間で情報を共有する方法について解説します．

3.1 Cから参照できるRubyの定数

以下のRubyの定数はCのレベルから参照できます．

  Qtrue
  Qfalse

    真偽値．QfalseはC言語でも偽とみなされます(つまり0)．

  Qnil

    C言語から見た「nil」．

3.2 CとRubyで共有される大域変数

CとRubyで大域変数を使って情報を共有できます．共有できる大域
変数にはいくつかの種類があります．そのなかでもっとも良く使わ
れると思われるのはrb_define_variable()です．

  void rb_define_variable(const char *name, VALUE *var)

この関数はRubyとCとで共有する大域変数を定義します．変数名が
`$'で始まらない時には自動的に追加されます．この変数の値を変
更すると自動的にRubyの対応する変数の値も変わります．

またRuby側からは更新できない変数もあります．このread onlyの
変数は以下の関数で定義します．

  void rb_define_readonly_variable(const char *name, VALUE *var)

これら変数の他にhookをつけた大域変数を定義できます．hook付き
の大域変数は以下の関数を用いて定義します．hook付き大域変数の
値の参照や設定はhookで行う必要があります．

  void rb_define_hooked_variable(const char *name, VALUE *var,
				 VALUE (*getter)(), void (*setter)())

この関数はCの関数によってhookのつけられた大域変数を定義しま
す．変数が参照された時には関数getterが，変数に値がセットされ
た時には関数setterが呼ばれる．hookを指定しない場合はgetterや
setterに0を指定します．

# getterもsetterも0ならばrb_define_variable()と同じになる．

それから，Cの関数によって実現されるRubyの大域変数を定義する
関数があります．

  void rb_define_virtual_variable(const char *name,
				  VALUE (*getter)(), void (*setter)())

この関数によって定義されたRubyの大域変数が参照された時には
getterが，変数に値がセットされた時にはsetterが呼ばれます．

getterとsetterの仕様は以下の通りです．

  (*getter)(ID id, void *data, struct global_entry* entry);
  (*setter)(VALUE val, ID id, void *data, struct global_entry* entry);

3.3 CのデータをRubyオブジェクトにする

Cの世界で定義されたデータ(構造体)をRubyのオブジェクトとして
取り扱いたい場合がありえます．このような場合には，Dataという
RubyオブジェクトにCの構造体(へのポインタ)をくるむことでRuby
オブジェクトとして取り扱えるようになります．

Dataオブジェクトを生成して構造体をRubyオブジェクトにカプセル
化するためには，以下のマクロを使います．

  Data_Wrap_Struct(klass, mark, free, ptr)

このマクロの戻り値は生成されたDataオブジェクトです．

klassはこのDataオブジェクトのクラスです．ptrはカプセル化する
Cの構造体へのポインタです．markはこの構造体がRubyのオブジェ
クトへの参照がある時に使う関数です．そのような参照を含まない
時には0を指定します．

# そのような参照は勧められません．

freeはこの構造体がもう不要になった時に呼ばれる関数です．この
関数がガーベージコレクタから呼ばれます．

Cの構造体の割当とDataオブジェクトの生成を同時に行うマクロと
して以下のものが提供されています．

  Data_Make_Struct(klass, type, mark, free, sval)

このマクロの戻り値は生成されたDataオブジェクトです．

klass, mark, freeはData_Wrap_Structと同じ働きをします．type
は割り当てるC構造体の型です．割り当てられた構造体は変数sval
に代入されます．この変数の型は (type*) である必要があります．

Dataオブジェクトからポインタを取り出すのは以下のマクロを用い
ます．

  Data_Get_Struct(obj, type, sval)

Cの構造体へのポインタは変数svalに代入されます．

これらのDataの使い方はちょっと分かりにくいので，後で説明する
例題を参照してください．

4．例題 - dbmパッケージを作る

ここまでの説明でとりあえず拡張ライブラリは作れるはずです．
Rubyのextディレクトリにすでに含まれているdbmライブラリを例に
して段階的に説明します．

(1) ディレクトリを作る

  % mkdir ext/dbm

Ruby 1.1からは任意のディレクトリでダイナミックライブラリを作
ることができるようになりました．Rubyに静的にリンクする場合に
はRubyを展開したディレクトリの下，extディレクトリの中に拡張
ライブラリ用のディレクトリを作る必要があります．名前は適当に
選んで構いません．

(2) MANIFESTファイルを作る

  % cd ext/dbm
  % touch MANIFEST

拡張ライブラリのディレクトリの下にはMANIFESTというファイルが
必要なので，とりあえず空のファイルを作っておきます．後でこの
ファイルには必要なファイル一覧が入ることになります．

MANIFESTというファイルは，静的リンクのmakeの時にディレクトリ
が拡張ライブラリを含んでいるかどうか判定するために使われれて
います．ダイナミックライブラリを作る場合には必ずしも必要では
ありません．

(3) 設計する

まあ，当然なんですけど，どういう機能を実現するかどうかまず設
計する必要があります．どんなクラスをつくるか，そのクラスには
どんなメソッドがあるか，クラスが提供する定数などについて設計
します．

(4) Cコードを書く

拡張ライブラリ本体となるC言語のソースを書きます．C言語のソー
スがひとつの時には「ライブラリ名.c」を選ぶと良いでしょう．C
言語のソースが複数の場合には逆に「ライブラリ名.c」というファ
イル名は避ける必要があります．オブジェクトファイルとモジュー
ル生成時に中間的に生成される「ライブラリ名.o」というファイル
とが衝突するからです．

Rubyは拡張ライブラリをロードする時に「Init_ライブラリ名」と
いう関数を自動的に実行します．dbmライブラリの場合「Init_dbm」
です．この関数の中でクラス，モジュール，メソッド，定数などの
定義を行います．dbm.cから一部引用します．

--
Init_dbm()
{
    /* DBMクラスを定義する */
    cDBM = rb_define_class("DBM", rb_cObject);
    /* DBMはEnumerateモジュールをインクルードする */
    rb_include_module(cDBM, rb_mEnumerable);

    /* DBMクラスのクラスメソッドopen(): 引数はCの配列で受ける */
    rb_define_singleton_method(cDBM, "open", fdbm_s_open, -1);

    /* DBMクラスのメソッドclose(): 引数はなし */
    rb_define_method(cDBM, "close", fdbm_close, 0);
    /* DBMクラスのメソッド[]: 引数は1個 */
    rb_define_method(cDBM, "[]", fdbm_fetch, 1);
		:

    /* DBMデータを格納するインスタンス変数名のためのID */
    id_dbm = rb_intern("dbm");
}
--

DBMライブラリはdbmのデータと対応するオブジェクトになるはずで
すから，Cの世界のdbmをRubyの世界に取り込む必要があります．


dbm.cではData_Make_Structを以下のように使っています．

--
struct dbmdata {
    int  di_size;
    DBM *di_dbm;
};


obj = Data_Make_Struct(klass, struct dbmdata, 0, free_dbm, dbmp);
--

ここではdbmstruct構造体へのポインタをDataにカプセル化してい
ます．DBM*を直接カプセル化しないのはclose()した時の処理を考
えてのことです．

Dataオブジェクトからdbmstruct構造体のポインタを取り出すため
に以下のマクロを使っています．

--
#define GetDBM(obj, dbmp) {\
    Data_Get_Struct(obj, struct dbmdata, dbmp);\
    if (dbmp->di_dbm == 0) closed_dbm();\
}
--

ちょっと複雑なマクロですが，要するにdbmdata構造体のポインタ
の取り出しと，closeされているかどうかのチェックをまとめてい
るだけです．

DBMクラスにはたくさんメソッドがありますが，分類すると3種類の
引数の受け方があります．ひとつは引数の数が固定のもので，例と
してはdeleteメソッドがあります．deleteメソッドを実装している
fdbm_delete()はこのようになっています．

--
static VALUE
fdbm_delete(obj, keystr)
    VALUE obj, keystr;
{
	:
}
--

引数の数が固定のタイプは第1引数がself，第2引数以降がメソッド
の引数となります．

引数の数が不定のものはCの配列で受けるものとRubyの配列で受け
るものとがあります．dbmライブラリの中で，Cの配列で受けるもの
はDBMのクラスメソッドであるopen()です．これを実装している関
数fdbm_s_open()はこうなっています．

--
static VALUE
fdbm_s_open(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
	:
    if (rb_scan_args(argc, argv, "11", &file, &vmode) == 1) {
	mode = 0666;		/* default value */
    }
	:
}
--

このタイプの関数は第1引数が与えられた引数の数，第2引数が与え
られた引数の入っている配列になります．selfは第3引数として与
えられます．

この配列で与えられた引数を解析するための関数がopen()でも使わ
れているrb_scan_args()です．第3引数に指定したフォーマットに
従い，第4変数以降に指定した変数に値を代入してくれます．この
フォーマットは，第1文字目が省略できない引数の数，第2文字目が
省略できる引数の数，第3文字目が対応する相手が無いあまりの引
数があるかどうかを示す"*"です．2文字目と3文字目は省略できま
す．dbm.cの例では，フォーマットは"11"ですから，引数は最低1つ
で，2つまで許されるという意味になります．省略されている時の
変数の値はnil(C言語のレベルではQnil)になります．

Rubyの配列で引数を受け取るものはindexesがあります．実装はこ
うです．

--
static VALUE
fdbm_indexes(obj, args)
    VALUE obj, args;
{
	:
}
--

第1引数はself，第2引数はRubyの配列です．

** 注意事項

Rubyと共有はしないがRubyのオブジェクトを格納する可能性のある
Cの大域変数は以下の関数を使ってRubyインタプリタに変数の存在
を教えてあげてください．でないとGCでトラブルを起こします．

  void rb_global_variable(VALUE *var)

(5) extconf.rbを用意する

Makefileを作る場合の雛型になるextconf.rbというファイルを作り
ます．extconf.rbはライブラリのコンパイルに必要な条件のチェッ
クなどを行うことが目的です．まず，

  require 'mkmf'

をextconf.rbの先頭に置きます．extconf.rbの中では以下のRuby関
数を使うことが出来ます．

  have_library(lib, func): ライブラリの存在チェック
  have_func(func, header): 関数の存在チェック
  have_header(header): ヘッダファイルの存在チェック
  create_makefile(target): Makefileの生成

以下の変数を使うことができます．

  $CFLAGS: コンパイル時に追加的に指定するフラグ(-Iなど)
  $LDFLAGS: リンク時に追加的に指定するフラグ(-Lなど)

ライブラリをコンパイルする条件が揃わず，そのライブラリをコン
パイルしない時にはcreate_makefileを呼ばなければMakefileは生
成されず，コンパイルも行われません．

(6) dependを用意する

もし，ディレクトリにdependというファイルが存在すれば，
Makefileが依存関係をチェックしてくれます．

  % gcc -MM *.c > depend

などで作ることが出来ます．あって損は無いでしょう．

(7) MANIFESTファイルにファイル名を入れる

  % find * -type f -print > MANIFEST
  % vi MANIFEST

*.o, *~など不必要なファイル以外はMANIFESTに追加しておきます．
make時にはMANIFESTの内容は参照しませんので，空のままでも問題
は起きませんが，パッケージングの時に参照することがあるのと，
必要なファイルを区別できるので，用意しておいた方が良いでしょ
う．

(8) Makefileを生成する

Makefileを実際に生成するためには

  ruby extconf.rb

とします．extconf.rbに require 'mkmf' の行がない場合にはエラー
になりますので，引数を追加して

  ruby -r mkmf extconf.rb

としてください．

ディレクトリをext以下に用意した場合にはRuby全体のmakeの時に
自動的にMakefileが生成されますので，このステップは不要です．

(9) makeする

動的リンクライブラリを生成する場合にはその場でmakeしてくださ
い．必要であれば make install でインストールされます．

ext以下にディレクトリを用意した場合は，Rubyのディレクトリで
makeを実行するとMakefileを生成からmake，必要によってはそのモ
ジュールのRubyへのリンクまで自動的に実行してくれます．
extconf.rbを書き換えるなどしてMakefileの再生成が必要な時はま
たRubyディレクトリでmakeしてください．

拡張ライブラリはmake installでRubyライブラリのディレクトリの
下にコピーされます．もし拡張ライブラリと協調して使うRubyで記
述されたプログラムがあり，Rubyライブラリに置きたい場合には，
拡張ライブラリ用のディレクトリの下に lib というディレクトリ
を作り，そこに 拡張子 .rb のファイルを置いておけば同時にイン
ストールされます．

(10) デバッグ

まあ，デバッグしないと動かないでしょうね．ext/Setupにディレ
クトリ名を書くと静的にリンクするのでデバッガが使えるようにな
ります．その分コンパイルが遅くなりますけど．

(11) できあがり

後はこっそり使うなり，広く公開するなり，売るなり，ご自由にお
使いください．Rubyの作者は拡張ライブラリに関して一切の権利を
主張しません．

Appendix A. Rubyのソースコードの分類

Rubyのソースはいくつかに分類することが出来ます．このうちクラ
スライブラリの部分は基本的に拡張ライブラリと同じ作り方になっ
ています．これらのソースは今までの説明でほとんど理解できると
思います．

Ruby言語のコア

  class.c
  error.c
  eval.c
  gc.c
  object.c
  parse.y
  variable.c

ユーティリティ関数

  dln.c
  regex.c
  st.c
  util.c

Rubyコマンドの実装

  dmyext.c
  inits.c
  main.c
  ruby.c
  version.c

クラスライブラリ

  array.c
  bignum.c
  compar.c
  dir.c
  enum.c
  file.c
  hash.c
  io.c
  marshal.c
  math.c
  numeric.c
  pack.c
  prec.c
  process.c
  random.c
  range.c
  re.c
  signal.c
  sprintf.c
  string.c
  struct.c
  time.c

Appendix B. 拡張用関数リファレンス

C言語からRubyの機能を利用するAPIは以下の通りである．

** 型

VALUE

  Rubyオブジェクトを表現する型．必要に応じてキャストして用いる．
  組み込み型を表現するCの型はruby.hに記述してあるRで始まる構造
  体である．VALUE型をこれらにキャストするためにRで始まる構造体
  名を全て大文字にした名前のマクロが用意されている．

** 変数・定数

Qnil

  定数: nilオブジェクト

Qtrue

  定数: trueオブジェクト(真のデフォルト値)

Qfalse

  定数: falseオブジェクト

** Cデータのカプセル化

Data_Wrap_Struct(VALUE klass, void (*mark)(), void (*free)(), void *sval)

  Cの任意のポインタをカプセル化したRubyオブジェクトを返す．こ
  のポインタがRubyからアクセスされなくなった時，freeで指定した
  関数が呼ばれる．また，このポインタの指すデータが他のRubyオブ
  ジェクトを指している場合，markに指定する関数でマークする必要
  がある．

Data_Make_Struct(klass, type, mark, free, sval)

  type型のメモリをmallocし，変数svalに代入した後，それをカプセ
  ル化したデータを返すマクロ．

Data_Get_Struct(data, type, sval)

  dataからtype型のポインタを取り出し変数svalに代入するマクロ．

** 型チェック

TYPE(value)
FIXNUM_P(value)
NIL_P(value)
void Check_Type(VALUE value, int type)
void Check_SafeStr(VALUE value)

** 型変換

FIX2INT(value)
INT2FIX(i)
NUM2INT(value)
INT2NUM(i)
NUM2DBL(value)
rb_float_new(f)
STR2CSTR(value)
rb_str_new2(s)

** クラス/モジュール定義

VALUE rb_define_class(const char *name, VALUE super)

  superのサブクラスとして新しいRubyクラスを定義する．

VALUE rb_define_class_under(VALUE module, const char *name, VALUE super)

  superのサブクラスとして新しいRubyクラスを定義し，moduleの
  定数として定義する．

VALUE rb_define_module(const char *name)

  新しいRubyモジュールを定義する．

VALUE rb_define_module_under(VALUE module, const char *name, VALUE super)

  新しいRubyモジュールを定義し，moduleの定数として定義する．

void rb_include_module(VALUE klass, VALUE module)

  モジュールをインクルードする．classがすでにmoduleをインク
  ルードしている時には何もしない(多重インクルードの禁止)．

void rb_extend_object(VALUE object, VALUE module)

  オブジェクトをモジュール(で定義されているメソッド)で拡張する．

** 大域変数定義

void rb_define_variable(const char *name, VALUE *var)

  RubyとCとで共有するグローバル変数を定義する．変数名が`$'で
  始まらない時には自動的に追加される．nameとしてRubyの識別子
  として許されない文字(例えば` ')を含む場合にはRubyプログラ
  ムからは見えなくなる．

void rb_define_readonly_variable(const char *name, VALUE *var)

  RubyとCとで共有するread onlyのグローバル変数を定義する．
  read onlyであること以外はrb_define_variable()と同じ．

void rb_define_virtual_variable(const char *name,
				VALUE (*getter)(), void (*setter)())

  関数によって実現されるRuby変数を定義する．変数が参照された
  時にはgetterが，変数に値がセットされた時にはsetterが呼ばれ
  る．

void rb_define_hooked_variable(const char *name, VALUE *var,
			       VALUE (*getter)(), void (*setter)())

  関数によってhookのつけられたグローバル変数を定義する．変数
  が参照された時にはgetterが，関数に値がセットされた時には
  setterが呼ばれる．getterやsetterに0を指定した時にはhookを
  指定しないのと同じ事になる．

void rb_global_variable(VALUE *var)

  GCのため，Rubyプログラムからはアクセスされないが, Rubyオブ
  ジェクトを含む大域変数をマークする．

** 定数

void rb_define_const(VALUE klass, const char *name, VALUE val)

  定数を定義する．

void rb_define_global_const(const char *name, VALUE val)

  大域定数を定義する．

     rb_define_const(rb_cObject, name, val)

  と同じ意味．

** メソッド定義

rb_define_method(VALUE klass, const char *name, VALUE (*func)(), int argc)

  メソッドを定義する．argcはselfを除く引数の数．argcが-1の時, 
  関数には引数の数(selfを含まない)を第1引数, 引数の配列を第2
  引数とする形式で与えられる(第3引数はself)．argcが-2の時, 
  第1引数がself, 第2引数がargs(argsは引数を含むRubyの配列)と
  いう形式で与えられる．
 
rb_define_private_method(VALUE klass, const char *name, VALUE (*func)(), int argc)

  privateメソッドを定義する．引数はrb_define_method()と同じ．

rb_define_singleton_method(VALUE klass, const char *name, VALUE (*func)(), int argc)

  特異メソッドを定義する．引数はrb_define_method()と同じ．

rb_scan_args(int argc, VALUE *argv, const char *fmt, ...)

  argc, argv形式で与えられた引数を分解する．fmtは必須引数の数, 
  付加引数の数, 残りの引数があるかを指定する文字列で, "数字
  数字*"という形式である． 2 番目の数字と"*"はそれぞれ省略可
  能である．必須引数が一つもない場合は0を指定する．第3引数以
  降は変数へのポインタで, 該当する要素がその変数に格納される．
  付加引数に対応する引数が与えられていない場合は変数にQnilが
  代入される．

** Rubyメソッド呼び出し

VALUE rb_funcall(VALUE recv, ID mid, int narg, ...)

  メソッド呼び出し．文字列からmidを得るためにはrb_intern()を
  使う．

VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv)

  メソッド呼び出し．引数をargc, argv形式で渡す．

VALUE rb_eval_string(const char *str)

  文字列をRubyスクリプトとしてコンパイル・実行する．

ID rb_intern(const char *name)

  文字列に対応するIDを返す．

char *rb_id2name(ID id)

  IDに対応する文字列を返す(デバッグ用)．

char *rb_class2name(VALUE klass)

  クラスの名前を返す(デバッグ用)．クラスが名前を持たない時には, 
  祖先を遡って名前を持つクラスの名前を返す．

int rb_respond_to(VALUE obj, ID id)

  objがidで示されるメソッドを持つかどうかを返す。

** インスタンス変数

VALUE rb_iv_get(VALUE obj, const char *name)

  objのインスタンス変数の値を得る．`@@'で始まらないインスタン
  ス変数は Rubyプログラムからアクセスできない「隠れた」イン
  スタンス変数になる．定数は大文字の名前を持つクラス(または
  モジュール)のインスタンス変数として実装されている．

VALUE rb_iv_set(VALUE obj, const char *name, VALUE val)

  objのインスタンス変数をvalにセットする．

** 制御構造

VALUE rb_iterate(VALUE (*func1)(), VALUE arg1, VALUE (*func2)(), VALUE arg2)

  func2をブロックとして設定し, func1をイテレータとして呼ぶ． 
  func1には arg1が引数として渡され, func2には第1引数にイテレー
  タから与えられた値, 第2引数にarg2が渡される．
 
VALUE rb_yield(VALUE val)

  valを値としてイテレータブロックを呼び出す．

VALUE rb_rescue(VALUE (*func1)(), VALUE arg1, VALUE (*func2)(), VALUE arg2)

  関数func1をarg1を引数に呼び出す．func1の実行中に例外が発生
  した時には func2をarg2を引数として呼ぶ．戻り値は例外が発生
  しなかった時はfunc1の戻り値, 例外が発生した時にはfunc2の戻
  り値である．

VALUE rb_ensure(VALUE (*func1)(), VALUE arg1, void (*func2)(), VALUE arg2)

  関数func1をarg1を引数として実行し, 実行終了後(たとえ例外が
  発生しても) func2をarg2を引数として実行する．戻り値はfunc1
  の戻り値である(例外が発生した時は戻らない)．

** 例外・エラー

void rb_warning(const char *fmt, ...)

  rb_verbose時に標準エラー出力に警告情報を表示する．引数は
  printf()と同じ．

void rb_raise(rb_eRuntimeError, const char *fmt, ...)

  RuntimeError例外を発生させる．引数はprintf()と同じ．

void rb_raise(VALUE exception, const char *fmt, ...)

  exceptionで指定した例外を発生させる．fmt以下の引数は
  printf()と同じ．

void rb_fatal(const char *fmt, ...)

  致命的例外を発生させる．通常の例外処理は行なわれず, インター
  プリタが終了する(ただしensureで指定されたコードは終了前に
  実行される)．

void rb_bug(const char *fmt, ...)

  インタープリタなどプログラムのバグでしか発生するはずのない
  状況の時呼ぶ．インタープリタはコアダンプし直ちに終了する．
  例外処理は一切行なわれない．

** Rubyの初期化・実行

Rubyをアプリケーションに埋め込む場合には以下のインタフェース
を使う．通常の拡張ライブラリには必要ない．

void ruby_init()

  Rubyインタプリタの初期化を行なう．

void ruby_options(int argc, char **argv)

  Rubyインタプリタのコマンドライン引数の処理を行なう．

void ruby_run()

  Rubyインタプリタを実行する．

void ruby_script(char *name)

  Rubyのスクリプト名($0)を設定する．


Appendix B. extconf.rbで使える関数たち

extconf.rbの中では利用可能なコンパイル条件チェックの関数は以
下の通りである．

have_library(lib, func)

  関数funcを定義しているライブラリlibの存在をチェックする．
  ライブラリが存在する時，trueを返す．

find_library(lib, func, path...)

  関数funcを定義しているライブラリlibの存在を -Lpath を追加
  しながらチェックする．ライブラリが見付かった時，trueを返す．

have_func(func, header)

  ヘッダファイルheaderをインクルードして関数funcの存在をチェッ
  クする．funcが標準ではリンクされないライブラリ内のものであ
  る時には先にhave_libraryでそのライブラリをチェックしておく
  事．関数が存在する時trueを返す．

have_header(header)

  ヘッダファイルの存在をチェックする．ヘッダファイルが存在す
  る時trueを返す．

create_makefile(target)

  拡張ライブラリ用のMakefileを生成する．この関数を呼ばなけれ
  ばそのライブラリはコンパイルされない．targetはモジュール名
  を表す．

with_config(withval[, default=nil])

  コマンドライン上の--with-<withval>で指定されたオプション値を得る．

dir_config(target[, default_dir])
dir_config(target[, default_include, default_lib])

  コマンドライン上の--with-<target>-dir, --with-<target>-include,
  --with-<target>-libのいずれかで指定されるディレクトリを
  $CFLAGS や $LDFLAGS に追加する．--with-<target>-dir=/pathは
  --with-<target>-include=/path/include --with-<target>-lib=/path/lib
  と等価である．追加された include ディレクトリと lib ディレクトリの
  配列を返す． ([include_dir, lib_dir])

/*
 * Local variables:
 * fill-column: 60
 * end:
 */
@


1.9
log
@* Remove the description of find_header() because such a function does
not actually exist.

* Update the description of dir_config().
@
text
@@


1.8
log
@matz
@
text
@a1162 5
find_header(header)

  ヘッダファイルの存在を -Ipath を追加しながらチェックする．
  ヘッダファイルが見付かった時trueを返す．

d1171 1
a1171 1
  --with-<withval>で指定されたオプション値を得る．
d1173 2
a1174 1
dir_config(target)
d1176 6
a1181 3
  --with-<target>-dir, --with-<target>-include, --with-<target>-lib
  のいずれかで指定されるディレクトリを $CFLAGS や $LDFLAGS
  に追加する．
@


1.8.2.1
log
@* Remove the description of find_header() because such a function does
not actually exist.

* Update the description of dir_config().
@
text
@d1163 5
d1176 1
a1176 1
  コマンドライン上の--with-<withval>で指定されたオプション値を得る．
d1178 1
a1178 2
dir_config(target[, default_dir])
dir_config(target[, default_include, default_lib])
d1180 3
a1182 6
  コマンドライン上の--with-<target>-dir, --with-<target>-include,
  --with-<target>-libのいずれかで指定されるディレクトリを
  $CFLAGS や $LDFLAGS に追加する．--with-<target>-dir=/pathは
  --with-<target>-include=/path/include --with-<target>-lib=/path/lib
  と等価である．追加された include ディレクトリと lib ディレクトリの
  配列を返す． ([include_dir, lib_dir])
@


1.8.2.2
log
@Rename *.jp to *.ja, since jp is a region code and ja is a language
code.
@
text
@@


1.7
log
@matz
@
text
@d46 1
d52 1
d176 1
a176 1
  rb_str_new(char *ptr, int len)
d180 1
a180 1
  rb_str_new2(char *ptr)
d185 1
a185 1
  rb_tainted_str_new(char *ptr, int len)
d191 1
a191 1
  rb_tainted_str_new2(char *ptr)
d195 1
a195 1
  rb_str_cat(VALUE str, char *ptr, int len)
d205 1
a205 1
  rb_ary_new2(int len)
d210 1
a210 1
  rb_ary_new3(int n, ...)
d214 1
a214 1
  rb_ary_new4(int n, VALUE *elts)
a221 1
  rb_ary_entry(VALUE ary, int idx)
d249 2
a250 2
  VALUE rb_define_class(char *name, VALUE super)
  VALUE rb_define_module(char *name)
d259 2
a260 2
  VALUE rb_define_class_under(VALUE outer, char *name, VALUE super)
  VALUE rb_define_module_under(VALUE outer, char *name)
d266 1
a266 1
  void rb_define_method(VALUE klass, char *name, 
d269 1
a269 1
  void rb_define_singleton_method(VALUE object, char *name, 
d291 1
a291 1
  void rb_define_private_method(VALUE klass, char *name, 
d312 1
a312 1
  void rb_define_module_function(VALUE module, char *name, 
d318 1
a318 1
  void rb_define_global_function(char *name, VALUE (*func)(), int argc)
d330 2
a331 2
  void rb_define_const(VALUE klass, char *name, VALUE val)
  void rb_define_global_const(char *name, VALUE val)
d352 1
a352 1
  VALUE rb_eval_string(char *str)
d369 1
a369 1
  rb_intern(char *name)
d371 2
a372 3
を使います．また一文字の演算子はその文字コードがそのままシン
ボルになっています．Rubyから引数として与えられたシンボル(ま
たは文字列)をIDに変換するには以下の関数を使います．
d435 1
a435 1
  void rb_define_variable(char *name, VALUE *var)
d444 1
a444 1
  void rb_define_readonly_variable(char *name, VALUE *var)
d450 2
a451 2
  void rb_define_hooked_variable(char *name, VALUE *var,
				 VALUE (*getter)(), VALUE (*setter)())
d463 2
a464 2
  void rb_define_virtual_variable(char *name,
				  VALUE (*getter)(), VALUE (*setter)())
d554 1
a554 1
します．dbmクラスについてはext/dbm.docを参照してください．
d914 1
a914 1
VALUE rb_define_class(char *name, VALUE super)
d918 1
a918 1
VALUE rb_define_class_under(VALUE module, char *name, VALUE super)
d923 1
a923 1
VALUE rb_define_module(char *name)
d927 1
a927 1
VALUE rb_define_module_under(VALUE module, char *name, VALUE super)
d942 1
a942 1
void rb_define_variable(char *name, VALUE *var)
d949 1
a949 1
void rb_define_readonly_variable(char *name, VALUE *var)
d954 2
a955 2
void rb_define_virtual_variable(char *name,
				VALUE (*getter)(), VALUE (*setter)())
d961 2
a962 2
void rb_define_hooked_variable(char *name, VALUE *var,
			       VALUE (*getter)(), VALUE (*setter)())
d976 1
a976 1
void rb_define_const(VALUE klass, char *name, VALUE val)
d980 1
a980 1
void rb_define_global_const(char *name, VALUE val)
d984 1
a984 1
     rb_define_const(cKernal, name, val)
d990 1
a990 1
rb_define_method(VALUE klass, char *name, VALUE (*func)(), int argc)
d998 1
a998 1
rb_define_private_method(VALUE klass, char *name, VALUE (*func)(), int argc)
d1002 1
a1002 1
rb_define_singleton_method(VALUE klass, char *name, VALUE (*func)(), int argc)
d1006 1
a1006 1
rb_scan_args(int argc, VALUE *argv, char *fmt, ...)
d1027 1
a1027 1
VALUE rb_eval_string(char *str)
d1031 1
a1031 1
ID rb_intern(char *name)
d1050 1
a1050 1
VALUE rb_iv_get(VALUE obj, char *name)
d1057 1
a1057 1
VALUE rb_iv_set(VALUE obj, char *name, VALUE val)
d1063 1
a1063 1
VALUE rb_iterate(VALUE (*func1)(), void *arg1, VALUE (*func2)(), void *arg2)
d1073 1
a1073 1
VALUE rb_rescue(VALUE (*func1)(), void *arg1, VALUE (*func2)(), void *arg2)
d1080 1
a1080 1
VALUE rb_ensure(VALUE (*func1)(), void *arg1, void (*func2)(), void *arg2)
d1088 1
a1088 1
void rb_warning(char *fmt, ...)
d1093 1
a1093 1
void rb_raise(rb_eRuntimeError, char *fmt, ...)
d1097 1
a1097 1
void rb_raise(VALUE exception, char *fmt, ...)
d1102 1
a1102 1
void rb_fatal(char *fmt, ...)
d1108 1
a1108 1
void rb_bug(char *fmt, ...)
@


1.6
log
@matz
@
text
@d183 10
d319 4
@


1.5
log
@2000-03-06
@
text
@d697 1
a697 1
  have_func(func): 関数の存在チェック
d1137 1
a1137 1
have_func(func)
d1139 4
a1142 3
  関数funcの存在をチェックする．funcが標準ではリンクされない
  ライブラリ内のものである時には先にhave_libraryでそのライブ
  ラリをチェックしておく事．関数が存在する時trueを返す．
@


1.4
log
@19991012
@
text
@d76 1
a76 1
      TypeError("not valid value");
d255 1
a255 1
  void rb_define_method(VALUE class, char *name, 
d280 2
a281 2
  void rb_define_private_method(VALUE class, char *name, 
			        VALUE (*func)(), int argc)
d315 1
a315 1
  void rb_define_const(VALUE class, char *name, VALUE val)
d470 1
a470 1
  Data_Wrap_Struct(class,mark,free,ptr)
d474 1
a474 1
classはこのDataオブジェクトのクラスです．ptrはカプセル化する
d487 1
a487 1
  Data_Make_Struct(class, type, mark, free, sval)
d491 1
a491 1
class, mark, freeはData_Wrap_Structと同じ働きをします．type
d591 1
a591 1
obj = Data_Make_Struct(class,struct dbmdata,0,free_dbm,dbmp);
d636 1
a636 1
fdbm_s_open(argc, argv, class)
d639 1
a639 1
    VALUE class;
d715 1
a715 1
 % gcc -MM *.c > depend
a795 2
  fnmatch.c
  glob.c
d822 1
d862 1
a862 1
Data_Wrap_Struct(VALUE class, void (*mark)(), void (*free)(), void *sval)
d870 1
a870 1
Data_Make_Struct(class, type, mark, free, sval)
d917 1
a917 1
void rb_include_module(VALUE class, VALUE module)
d976 1
a976 1
rb_define_method(VALUE class, char *name, VALUE (*func)(), int argc)
d984 1
a984 1
rb_define_private_method(VALUE class, char *name, VALUE (*func)(), int argc)
d988 1
a988 1
rb_define_singleton_method(VALUE class, char *name, VALUE (*func)(), int argc)
d994 1
a994 1
  argc,argv形式で与えられた引数を分解する．fmtは必須引数の数, 
d1011 1
a1011 1
  メソッド呼び出し．引数をargc,argv形式で渡す．
d1025 1
a1025 1
char *rb_class2name(VALUE class)
d1027 1
a1027 1
  classの名前を返す(デバッグ用)．classが名前を持たない時には, 
a1135 1
  結果をキャッシュしない．
d1151 1
a1151 2
  ヘッダファイルが見付かった時trueを返す．結果をキャッシュし
  ない．
@


1.3
log
@19991004
@
text
@d1016 1
a1016 1
  文字列をRubyとスクリプトしてコンパイル・実行する．
d1030 4
@


1.2
log
@1.4.0
@
text
@d248 2
a249 2
  VALUE rb_define_class(VALUE outer, char *name, VALUE super)
  VALUE rb_define_module(VALUE outer, char *name)
d1102 1
a1102 1
void ruby_init(int argc, char **argv, char **envp)
d1105 4
@


1.1
log
@file README.EXT.jp was initially added on branch v1_1r.
@
text
@d1 1168
@


1.1.1.1
log
@ruby 1.3 cycle
@
text
@a0 1147
.\" README.EXT -  -*- Text -*- created at: Mon Aug  7 16:45:54 JST 1995

Rubyの拡張ライブラリの作り方を説明します．

1．基礎知識

Cの変数には型があり，データには型がありません．ですから，た
とえばポインタをintの変数に代入すると，その値は整数として取
り扱われます．逆にRubyの変数には型がなく，データに型がありま
す．この違いのため，CとRubyは相互に変換しなければ，お互いの
データをアクセスできません．

RubyのデータはVALUEというCの型で表現されます．VALUE型のデー
タはそのデータタイプを自分で知っています．このデータタイプと
いうのはデータ(オブジェクト)の実際の構造を意味していて，Ruby
のクラスとはまた違ったものです．

VALUEからCにとって意味のあるデータを取り出すためには

 (1) VALUEのデータタイプを知る
 (2) VALUEをCのデータに変換する

の両方が必要です．(1)を忘れると間違ったデータの変換が行われ
て，最悪プログラムがcore dumpします．

1.1 データタイプ

Rubyにはユーザが使う可能性のある以下のタイプがあります．

	T_NIL		nil
	T_OBJECT	通常のオブジェクト
	T_CLASS		クラス
	T_MODULE	モジュール
	T_FLOAT		浮動小数点数
	T_STRING	文字列
	T_REGEXP	正規表現
	T_ARRAY		配列
	T_FIXNUM	Fixnum(31bit長整数)
	T_HASH		連想配列
	T_STRUCT	(Rubyの)構造体
	T_BIGNUM	多倍長整数
	T_FILE		入出力
	T_TRUE		真
	T_FALSE		偽
	T_DATA		データ

その他に内部で利用されている以下のタイプがあります．

	T_ICLASS
	T_MATCH
	T_VARMAP
	T_SCOPE
	T_NODE

ほとんどのタイプはCの構造体で実装されています．

1.2 VALUEのデータタイプをチェックする

ruby.hではTYPE()というマクロが定義されていて，VALUEのデータ
タイプを知ることが出来ます．TYPE()マクロは上で紹介したT_XXXX
の形式の定数を返します．VALUEのデータタイプに応じて処理する
場合には，TYPE()の値で分岐することになります．

  switch (TYPE(obj)) {
    case T_FIXNUM:
      /* FIXNUMの処理 */
      break;
    case T_STRING:
      /* 文字列の処理 */
      break;
    case T_ARRAY:
      /* 配列の処理 */
      break;
    default:
      /* 例外を発生させる */
      TypeError("not valid value");
      break;
  }

それとデータタイプをチェックして，正しくなければ例外を発生す
る関数が用意されています．

  void Check_Type(VALUE value, int type)

この関数はvalueがtypeで無ければ，例外を発生させます．引数と
して与えられたVALUEのデータタイプが正しいかどうかチェックす
るためには，この関数を使います．

FIXNUMとNILに関してはより高速な判別マクロが用意されています．

  FIXNUM_P(obj)
  NIL_P(obj)

1.3 VALUEをCのデータに変換する

データタイプがT_NIL, T_FALSE, T_TRUEである時，データはそれぞ
れnil, false, trueです．このデータタイプのオブジェクトはひと
つずつしか存在しません．

データタイプがT_FIXNUMの時，これは31bitのサイズを持つ整数で
す．FIXNUMをCの整数に変換するためにはマクロ「FIX2INT()」を使
います．それから，FIXNUMに限らずRubyのデータを整数に変換する
「NUM2INT()」というマクロがあります．このマクロはデータタイ
プのチェック無しで使えます(整数に変換できない場合には例外が
発生する)．

同様にチェック無しで使える変換マクロはdoubleを取り出す
「NUM2DBL()」とchar*を取り出す「STR2CSTR()」があります．

それ以外のデータタイプは対応するCの構造体があります．対応す
る構造体のあるVALUEはそのままキャスト(型変換)すれば構造体の
ポインタに変換できます．

構造体は「struct RXxxxx」という名前でruby.hで定義されていま
す．例えば文字列は「struct RString」です．実際に使う可能性が
あるのは文字列と配列くらいだと思います．

ruby.hでは構造体へキャストするマクロも「RXXXXX()」(全部大文
字にしたもの)という名前で提供されています(例: RSTRING())．

例えば，文字列strの長さを得るためには「RSTRING(str)->len」と
し，文字列strをchar*として得るためには「RSTRING(str)->ptr」
とします．配列の場合には，それぞれ「RARRAY(ary)->len」，
「RARRAY(ary)->ptr」となります．

Rubyの構造体を直接アクセスする時に気をつけなければならないこ
とは，配列や文字列の構造体の中身は参照するだけで，直接変更し
ないことです．直接変更した場合，オブジェクトの内容の整合性が
とれなくなって，思わぬバグの原因になります．

1.4 CのデータをVALUEに変換する

VALUEの実際の構造は

  * FIXNUMの場合

    1bit右シフトして，LSBを立てる．

  * その他のポインタの場合

    そのままVALUEにキャストする．

となっています．よって，LSBをチェックすればVALUEがFIXNUMかど
うかわかるわけです(ポインタのLSBが立っていないことを仮定して
いる)．

ですから，FIXNUM以外のRubyのオブジェクトの構造体は単にVALUE
にキャストするだけでVALUEに変換出来ます．ただし，任意の構造
体がVALUEにキャスト出来るわけではありません．キャストするの
はRubyの知っている構造体(ruby.hで定義されているstruct RXxxx
のもの)だけです．

FIXNUMに関しては変換マクロを経由する必要があります．Cの整数
からVALUEに変換するマクロは以下のものがあります．必要に応じ
て使い分けてください．

  INT2FIX()	もとの整数が31bit以内に収まる自信がある時
  INT2NUM()	任意の整数からVALUEへ

INT2NUM()は整数がFIXNUMの範囲に収まらない場合，Bignumに変換
してくれます(が，少し遅い)．

1.5 Rubyのデータを操作する

先程も述べた通り，Rubyの構造体をアクセスする時に内容の更新を
行うことは勧められません．で，Rubyのデータを操作する時には
Rubyが用意している関数を用いてください．

ここではもっとも使われるであろう文字列と配列の生成/操作を行
い関数をあげます(全部ではないです)．

 文字列に対する関数

  rb_str_new(char *ptr, int len)

    新しいRubyの文字列を生成する．

  rb_str_new2(char *ptr)

    Cの文字列からRubyの文字列を生成する．この関数の機能は
    rb_str_new(ptr, strlen(ptr))と同等である．

  rb_str_cat(VALUE str, char *ptr, int len)

    Rubyの文字列strにlenバイトの文字列ptrを追加する．

 配列に対する関数

  rb_ary_new()

    要素が0の配列を生成する．

  rb_ary_new2(int len)

    要素が0の配列を生成する．len要素分の領域をあらかじめ割り
    当てておく．

  rb_ary_new3(int n, ...)

    引数で指定したn要素を含む配列を生成する．

  rb_ary_new4(int n, VALUE *elts)

    配列で与えたn要素の配列を生成する．

  rb_ary_push(VALUE ary, VALUE val)
  rb_ary_pop(VALUE ary)
  rb_ary_shift(VALUE ary)
  rb_ary_unshift(VALUE ary, VALUE val)
  rb_ary_entry(VALUE ary, int idx)

    Arrayの同名のメソッドと同じ働きをする関数．第1引数は必ず
    配列でなければならない．

2．Rubyの機能を使う

原理的にRubyで書けることはCでも書けます．RubyそのものがCで記
述されているんですから，当然といえば当然なんですけど．ここで
はRubyの拡張に使うことが多いだろうと予測される機能を中心に紹
介します．

2.1 Rubyに機能を追加する

Rubyで提供されている関数を使えばRubyインタプリタに新しい機能
を追加することができます．Rubyでは以下の機能を追加する関数が
提供されています．

 * クラス，モジュール
 * メソッド，特異メソッドなど
 * 定数

では順に紹介します．

2.1.1 クラス/モジュール定義

クラスやモジュールを定義するためには，以下の関数を使います．

  VALUE rb_define_class(char *name, VALUE super)
  VALUE rb_define_module(char *name)

これらの関数は新しく定義されたクラスやモジュールを返します．
メソッドや定数の定義にこれらの値が必要なので，ほとんどの場合
は戻り値を変数に格納しておく必要があるでしょう．

クラスやモジュールを他のクラスの内部にネストして定義する時に
は以下の関数を使います．

  VALUE rb_define_class(VALUE outer, char *name, VALUE super)
  VALUE rb_define_module(VALUE outer, char *name)

2.1.2 メソッド/特異メソッド定義

メソッドや特異メソッドを定義するには以下の関数を使います．

  void rb_define_method(VALUE class, char *name, 
		        VALUE (*func)(), int argc)

  void rb_define_singleton_method(VALUE object, char *name, 
			          VALUE (*func)(), int argc)


念のため説明すると「特異メソッド」とは，その特定のオブジェク
トに対してだけ有効なメソッドです．RubyではよくSmalltalkにお
けるクラスメソッドとして，クラスに対する特異メソッドが使われ
ます．

これらの関数の argcという引数はCの関数へ渡される引数の数(と
形式)を決めます．argcが正の時は関数に引き渡す引数の数を意味
します．16個以上の引数は使えません(が，要りませんよね，そん
なに)．実際の関数には先頭の引数としてselfが与えられますので，
指定した数より1多い引数を持つことになります．

argcが負の時は引数の数ではなく，形式を指定したことになります．
argcが-1の時は引数を配列に入れて渡されます．argcが-2の時は引
数はRubyの配列として渡されます．

メソッドを定義する関数はもう二つあります．ひとつはprivateメ
ソッドを定義する関数で，引数はrb_define_method()と同じです．

  void rb_define_private_method(VALUE class, char *name, 
			        VALUE (*func)(), int argc)

privateメソッドとは関数形式でしか呼び出すことの出来ないメソッ
ドです．

もうひとつはモジュール関数を定義するものです．モジュール関数
とはモジュールの特異メソッドであり，同時にprivateメソッドで
もあるものです．例をあげるとMathモジュールのsqrt()などがあげ
られます．このメソッドは

  Math.sqrt(4)

という形式でも

  include Math
  sqrt(4)

という形式でも使えます．モジュール関数を定義する関数は以下の
通りです．

  void rb_define_module_function(VALUE module, char *name, 
		                 VALUE (*func)(), int argc)

関数的メソッド(Kernelモジュールのprivate method)を定義するた
めの関数は以下の通りです．

  void rb_define_global_function(char *name, VALUE (*func)(), int argc)


2.1.3 定数定義

拡張ライブラリが必要な定数はあらかじめ定義しておいた方が良い
でしょう．定数を定義する関数は二つあります．

  void rb_define_const(VALUE class, char *name, VALUE val)
  void rb_define_global_const(char *name, VALUE val)

前者は特定のクラス/モジュールに属する定数を定義するもの，後
者はグローバルな定数を定義するものです．

2.2 Rubyの機能をCから呼び出す

既に『1.5 Rubyのデータを操作する』で一部紹介したような関数を
使えば，Rubyの機能を実現している関数を直接呼び出すことが出来
ます．

# このような関数の一覧表はいまのところありません．ソースを見
# るしかないですね．

それ以外にもRubyの機能を呼び出す方法はいくつかあります．

2.2.1 Rubyのプログラムをevalする

CからRubyの機能を呼び出すもっとも簡単な方法として，文字列で
与えられたRubyのプログラムを評価する関数があります．

  VALUE rb_eval_string(char *str)

この評価は現在の環境で行われます．つまり，現在のローカル変数
などを受け継ぎます．

2.2.2 IDまたはシンボル

Cから文字列を経由せずにRubyのメソッドを呼び出すこともできま
す．その前に，Rubyインタプリタ内でメソッドや変数名を指定する
時に使われているIDについて説明しておきましょう．

IDとは変数名，メソッド名を表す整数です．Rubyの中では

 :識別子

でアクセスできます．Cからこの整数を得るためには関数

  rb_intern(char *name)

を使います．また一文字の演算子はその文字コードがそのままシン
ボルになっています．Rubyから引数として与えられたシンボル(ま
たは文字列)をIDに変換するには以下の関数を使います．

  rb_to_id(VALUE symbol)

2.2.3 CからRubyのメソッドを呼び出す

Cから文字列を経由せずにRubyのメソッドを呼び出すためには以下
の関数を使います．

  VALUE rb_funcall(VALUE recv, ID mid, int argc, ...)

この関数はオブジェクトrecvのmidで指定されるメソッドを呼び出
します．その他に引数の指定の仕方が違う以下の関数もあります．

  VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv)
  VALUE rb_apply(VALUE recv, ID mid, VALUE args)

applyには引数としてRubyの配列を与えます．

2.2.4 変数/定数を参照/更新する

Cから関数を使って参照・更新できるのは，定数，インスタンス変
数です．大域変数は一部のものはCの大域変数としてアクセスでき
ます．ローカル変数を参照する方法は公開していません．

オブジェクトのインスタンス変数を参照・更新する関数は以下の通
りです．

  VALUE rb_ivar_get(VALUE obj, ID id)
  VALUE rb_ivar_set(VALUE obj, ID id, VALUE val)

idはrb_intern()で得られるものを使ってください．

定数を参照するには以下の関数を使ってください．

  VALUE rb_const_get(VALUE obj, ID id)

定数を新しく定義するためには『2.1.3 定数定義』で紹介さ
れている関数を使ってください．

3．RubyとCとの情報共有

C言語とRubyの間で情報を共有する方法について解説します．

3.1 Cから参照できるRubyの定数

以下のRubyの定数はCのレベルから参照できる．

  Qtrue
  Qfalse

真偽値．QfalseはC言語でも偽とみなされる(つまり0)．

  Qnil

C言語から見た「nil」．

3.2 CとRubyで共有される大域変数

CとRubyで大域変数を使って情報を共有できます．共有できる大域
変数にはいくつかの種類があります．そのなかでもっとも良く使わ
れると思われるのはrb_define_variable()です．

  void rb_define_variable(char *name, VALUE *var)

この関数はRubyとCとで共有する大域変数を定義します．変数名が
`$'で始まらない時には自動的に追加されます．この変数の値を変
更すると自動的にRubyの対応する変数の値も変わります．

またRuby側からは更新できない変数もあります．このread onlyの
変数は以下の関数で定義します．

  void rb_define_readonly_variable(char *name, VALUE *var)

これら変数の他にhookをつけた大域変数を定義できます．hook付き
の大域変数は以下の関数を用いて定義します．hook付き大域変数の
値の参照や設定はhookで行う必要があります．

  void rb_define_hooked_variable(char *name, VALUE *var,
				 VALUE (*getter)(), VALUE (*setter)())

この関数はCの関数によってhookのつけられた大域変数を定義しま
す．変数が参照された時には関数getterが，変数に値がセットされ
た時には関数setterが呼ばれる．hookを指定しない場合はgetterや
setterに0を指定します．

# getterもsetterも0ならばrb_define_variable()と同じになる．

それから，Cの関数によって実現されるRubyの大域変数を定義する
関数があります．

  void rb_define_virtual_variable(char *name,
				  VALUE (*getter)(), VALUE (*setter)())

この関数によって定義されたRubyの大域変数が参照された時には
getterが，変数に値がセットされた時にはsetterが呼ばれます．

getterとsetterの仕様は以下の通りです．

  (*getter)(ID id, void *data, struct global_entry* entry);
  (*setter)(VALUE val, ID id, void *data, struct global_entry* entry);

3.3 CのデータをRubyオブジェクトにする

Cの世界で定義されたデータ(構造体)をRubyのオブジェクトとして
取り扱いたい場合がありえます．このような場合には，Dataという
RubyオブジェクトにCの構造体(へのポインタ)をくるむことでRuby
オブジェクトとして取り扱えるようになります．

Dataオブジェクトを生成して構造体をRubyオブジェクトにカプセル
化するためには，以下のマクロを使います．

  Data_Wrap_Struct(class,mark,free,ptr)

このマクロの戻り値は生成されたDataオブジェクトです．

classはこのDataオブジェクトのクラスです．ptrはカプセル化する
Cの構造体へのポインタです．markはこの構造体がRubyのオブジェ
クトへの参照がある時に使う関数です．そのような参照を含まない
時には0を指定します．

# そのような参照は勧められません．

freeはこの構造体がもう不要になった時に呼ばれる関数です．この
関数がガーベージコレクタから呼ばれます．

Cの構造体の割当とDataオブジェクトの生成を同時に行うマクロと
して以下のものが提供されています．

  Data_Make_Struct(class, type, mark, free, sval)

このマクロの戻り値は生成されたDataオブジェクトです．

class, mark, freeはData_Wrap_Structと同じ働きをします．type
は割り当てるC構造体の型です．割り当てられた構造体は変数sval
に代入されます．この変数の型は (type*) である必要があります．

Dataオブジェクトからポインタを取り出すのは以下のマクロを用い
ます．

  Data_Get_Struct(obj, type, sval)

Cの構造体へのポインタは変数svalに代入されます．

これらのDataの使い方はちょっと分かりにくいので，後で説明する
例題を参照してください．

4．例題 - dbmパッケージを作る

ここまでの説明でとりあえず拡張ライブラリは作れるはずです．
Rubyのextディレクトリにすでに含まれているdbmモジュールを例に
して段階的に説明します．

(1) ディレクトリを作る

  % mkdir ext/dbm

Ruby 1.1からは任意のディレクトリでダイナミックライブラリを作
ることができるようになりました．Rubyに静的にリンクする場合に
はRubyを展開したディレクトリの下，extディレクトリの中に拡張
モジュール用のディレクトリを作る必要があります．名前は適当に
選んで構いません．

(2) MANIFESTファイルを作る

  % cd ext/dbm
  % touch MANIFEST

拡張ライブラリのディレクトリの下にはMANIFESTというファイルが
必要なので，とりあえず空のファイルを作っておきます．後でこの
ファイルには必要なファイル一覧が入ることになります．

MANIFESTというファイルは，静的リンクのmakeの時にディレクトリ
が拡張ライブラリを含んでいるかどうか判定するために使われれて
います．ダイナミックライブラリを作る場合には必ずしも必要では
ありません．

(3) 設計する

まあ，当然なんですけど，どういう機能を実現するかどうかまず設
計する必要があります．どんなクラスをつくるか，そのクラスには
どんなメソッドがあるか，クラスが提供する定数などについて設計
します．dbmクラスについてはext/dbm.docを参照してください．

(4) Cコードを書く

拡張ライブラリ本体となるC言語のソースを書きます．C言語のソー
スがひとつの時には「モジュール名.c」を選ぶと良いでしょう．C
言語のソースが複数の場合には逆に「モジュール名.c」というファ
イル名は避ける必要があります．オブジェクトファイルとモジュー
ル生成時に中間的に生成される「モジュール名.o」というファイル
とが衝突するからです．

Rubyは拡張ライブラリをロードする時に「Init_モジュール名」と
いう関数を自動的に実行します．dbmモジュールの場合「Init_dbm」
です．この関数の中でクラス，モジュール，メソッド，定数などの
定義を行います．dbm.cから一部引用します．

--
Init_dbm()
{
    /* DBMクラスを定義する */
    cDBM = rb_define_class("DBM", rb_cObject);
    /* DBMはEnumerateモジュールをインクルードする */
    rb_include_module(cDBM, rb_mEnumerable);

    /* DBMクラスのクラスメソッドopen(): 引数はCの配列で受ける */
    rb_define_singleton_method(cDBM, "open", fdbm_s_open, -1);

    /* DBMクラスのメソッドclose(): 引数はなし */
    rb_define_method(cDBM, "close", fdbm_close, 0);
    /* DBMクラスのメソッド[]: 引数は1個 */
    rb_define_method(cDBM, "[]", fdbm_fetch, 1);
		:

    /* DBMデータを格納するインスタンス変数名のためのID */
    id_dbm = rb_intern("dbm");
}
--

DBMモジュールはdbmのデータと対応するオブジェクトになるはずで
すから，Cの世界のdbmをRubyの世界に取り込む必要があります．


dbm.cではData_Make_Structを以下のように使っています．

--
struct dbmdata {
    int  di_size;
    DBM *di_dbm;
};


obj = Data_Make_Struct(class,struct dbmdata,0,free_dbm,dbmp);
--

ここではdbmstruct構造体へのポインタをDataにカプセル化してい
ます．DBM*を直接カプセル化しないのはclose()した時の処理を考
えてのことです．

Dataオブジェクトからdbmstruct構造体のポインタを取り出すため
に以下のマクロを使っています．

--
#define GetDBM(obj, dbmp) {\
    Data_Get_Struct(obj, struct dbmdata, dbmp);\
    if (dbmp->di_dbm == 0) closed_dbm();\
}
--

ちょっと複雑なマクロですが，要するにdbmdata構造体のポインタ
の取り出しと，closeされているかどうかのチェックをまとめてい
るだけです．

DBMクラスにはたくさんメソッドがありますが，分類すると3種類の
引数の受け方があります．ひとつは引数の数が固定のもので，例と
してはdeleteメソッドがあります．deleteメソッドを実装している
fdbm_delete()はこのようになっています．

--
static VALUE
fdbm_delete(obj, keystr)
    VALUE obj, keystr;
{
	:
}
--

引数の数が固定のタイプは第1引数がself，第2引数以降がメソッド
の引数となります．

引数の数が不定のものはCの配列で受けるものとRubyの配列で受け
るものとがあります．dbmモジュールの中で，Cの配列で受けるもの
はDBMのクラスメソッドであるopen()です．これを実装している関
数fdbm_s_open()はこうなっています．

--
static VALUE
fdbm_s_open(argc, argv, class)
    int argc;
    VALUE *argv;
    VALUE class;
{
	:
    if (rb_scan_args(argc, argv, "11", &file, &vmode) == 1) {
	mode = 0666;		/* default value */
    }
	:
}
--

このタイプの関数は第1引数が与えられた引数の数，第2引数が与え
られた引数の入っている配列になります．selfは第3引数として与
えられます．

この配列で与えられた引数を解析するための関数がopen()でも使わ
れているrb_scan_args()です．第3引数に指定したフォーマットに
従い，第4変数以降に指定した変数に値を代入してくれます．この
フォーマットは，第1文字目が省略できない引数の数，第2文字目が
省略できる引数の数，第3文字目が対応する相手が無いあまりの引
数があるかどうかを示す"*"です．2文字目と3文字目は省略できま
す．dbm.cの例では，フォーマットは"11"ですから，引数は最低1つ
で，2つまで許されるという意味になります．省略されている時の
変数の値はnil(C言語のレベルではQnil)になります．

Rubyの配列で引数を受け取るものはindexesがあります．実装はこ
うです．

--
static VALUE
fdbm_indexes(obj, args)
    VALUE obj;
    struct RArray *args;
{
	:
}
--

第1引数はself，第2引数はRubyの配列です．ここではキャストを減
らすため struct RArray* で受けていますが，VALUEでも同じこと
です．

** 注意事項

Rubyと共有はしないがRubyのオブジェクトを格納する可能性のある
Cの大域変数は以下の関数を使ってRubyインタプリタに変数の存在
を教えてあげてください．でないとGCでトラブルを起こします．

  void rb_global_variable(VALUE *var)

(5) extconf.rbを用意する

Makefileを作る場合の雛型になるextconf.rbというファイルを作り
ます．extconf.rbはモジュールのコンパイルに必要な条件のチェッ
クなどを行うことが目的です．extconf.rbの中では以下のRuby関数
を使うことが出来ます．

  have_library(lib, func): ライブラリの存在チェック
  have_func(func): 関数の存在チェック
  have_header(header): ヘッダファイルの存在チェック
  create_makefile(target): Makefileの生成

以下の変数を使うことができます．

  $CFLAGS: コンパイル時に追加的に指定するフラグ(-Iなど)
  $LDFLAGS: リンク時に追加的に指定するフラグ(-Lなど)

モジュールをコンパイルする条件が揃わなず，そのモジュールはコ
ンパイルしない時にはcreate_makefileを呼ばなければMakefileは
生成されず，コンパイルも行われません．

モジュールがRuby 1.1専用である場合には 

  require 'mkmf'

をextconf.rbの先頭に置くと便利でしょう．

(6) dependを用意する

もし，ディレクトリにdependというファイルが存在すれば，
Makefileが依存関係をチェックしてくれます．

 % gcc -MM *.c > depend

などで作ることが出来ます．あって損は無いでしょう．

(7) MANIFESTファイルにファイル名を入れる

  % ls > MANIFEST
  % vi MANIFEST

*.o, *~など不必要なファイル以外はMANIFESTに追加しておきます．
make時にはMANIFESTの内容は参照しませんので，空のままでも問題
は起きませんが，パッケージングの時に参照することがあるのと，
必要なファイルを区別できるので，用意しておいた方が良いでしょ
う．

(8) Makefileを生成する

Makefileを実際に生成するためには

  ruby extconf.rb

とします．extconf.rbに require 'mkmf' の行がない場合にはエラー
になりますので，引数を追加して

  ruby -r mkmf extconf.rb

としてください．

ディレクトリをext以下に用意した場合にはRuby全体のmakeの時に
自動的にMakefileが生成されますので，このステップは不要です．

(9) makeする

動的リンクライブラリを生成する場合にはその場でmakeしてくださ
い．必要であれば make install でインストールされます．

ext以下にディレクトリを用意した場合は，Rubyのディレクトリで
makeを実行するとMakefileを生成からmake，必要によってはそのモ
ジュールのRubyへのリンクまで自動的に実行してくれます．
extconf.rbを書き換えるなどしてMakefileの再生成が必要な時はま
たRubyディレクトリでmakeしてください．

動的リンクライブラリはmake installでRubyライブラリのディレク
トリの下にコピーされます．もしモジュールと協調して使うRubyで
記述されたプログラムがあり，Rubyライブラリに置きたい場合には，
拡張ライブラリ用のディレクトリの下に lib というディレクトリ
を作り，そこに 拡張子 .rb のファイルを置いておけば同時にイン
ストールされます．

(10) デバッグ

まあ，デバッグしないと動かないでしょうね．ext/Setupにディレ
クトリ名を書くと静的にリンクするのでデバッガが使えるようにな
ります．その分コンパイルが遅くなりますけど．

(11) できあがり

後はこっそり使うなり，広く公開するなり，売るなり，ご自由にお
使いください．Rubyの作者は拡張ライブラリに関して一切の権利を
主張しません．

Appendix A. Rubyのソースコードの分類

Rubyのソースはいくつかに分類することが出来ます．このうちクラ
スライブラリの部分は基本的に拡張ライブラリと同じ作り方になっ
ています．これらのソースは今までの説明でほとんど理解できると
思います．

Ruby言語のコア

  class.c
  error.c
  eval.c
  gc.c
  object.c
  parse.y
  variable.c

ユーティリティ関数

  dln.c
  fnmatch.c
  glob.c
  regex.c
  st.c
  util.c

Rubyコマンドの実装

  dmyext.c
  inits.c
  main.c
  ruby.c
  version.c

クラスライブラリ

  array.c
  bignum.c
  compar.c
  dir.c
  enum.c
  file.c
  hash.c
  io.c
  marshal.c
  math.c
  numeric.c
  pack.c
  process.c
  random.c
  range.c
  re.c
  signal.c
  sprintf.c
  string.c
  struct.c
  time.c

Appendix B. 拡張用関数リファレンス

C言語からRubyの機能を利用するAPIは以下の通りである．

** 型

 VALUE

Rubyオブジェクトを表現する型．必要に応じてキャストして用いる．
組み込み型を表現するCの型はruby.hに記述してあるRで始まる構造
体である．VALUE型をこれらにキャストするためにRで始まる構造体
名を全て大文字にした名前のマクロが用意されている．

** 変数・定数

 Qnil

定数: nilオブジェクト

 Qtrue

定数: trueオブジェクト(真のデフォルト値)

 Qfalse

定数: falseオブジェクト

** Cデータのカプセル化

 Data_Wrap_Struct(VALUE class, void (*mark)(), void (*free)(), void *sval)

Cの任意のポインタをカプセル化したRubyオブジェクトを返す．こ
のポインタがRubyからアクセスされなくなった時，freeで指定した
関数が呼ばれる．また，このポインタの指すデータが他のRubyオブ
ジェクトを指している場合，markに指定する関数でマークする必要
がある．

 Data_Make_Struct(class, type, mark, free, sval)

type型のメモリをmallocし，変数svalに代入した後，それをカプセ
ル化したデータを返すマクロ．

 Data_Get_Struct(data, type, sval)

dataからtype型のポインタを取り出し変数svalに代入するマクロ．

** 型チェック

 TYPE(value)
 FIXNUM_P(value)
 NIL_P(value)
 void Check_Type(VALUE value, int type)
 void Check_SafeStr(VALUE value)

** 型変換

 FIX2INT(value)
 INT2FIX(i)
 NUM2INT(value)
 INT2NUM(i)
 NUM2DBL(value)
 rb_float_new(f)
 STR2CSTR(value)
 rb_str_new2(s)

** クラス/モジュール定義

 VALUE rb_define_class(char *name, VALUE super)

superのサブクラスとして新しいRubyクラスを定義する．

 VALUE rb_define_class_under(VALUE module, char *name, VALUE super)

superのサブクラスとして新しいRubyクラスを定義し，moduleの定
数として定義する．

 VALUE rb_define_module(char *name)

新しいRubyモジュールを定義する．

 VALUE rb_define_module_under(VALUE module, char *name, VALUE super)

新しいRubyモジュールを定義し，moduleの定数として定義する．

 void rb_include_module(VALUE class, VALUE module)

モジュールをインクルードする．classがすでにmoduleをインクルー
ドしている時には何もしない(多重インクルードの禁止)．

 void rb_extend_object(VALUE object, VALUE module)

オブジェクトをモジュール(で定義されているメソッド)で拡張する．

** 大域変数定義

 void rb_define_variable(char *name, VALUE *var)

RubyとCとで共有するグローバル変数を定義する．変数名が`$'で始
まらない時には自動的に追加される．nameとしてRubyの識別子とし
て許されない文字(例えば` ')を含む場合にはRubyプログラムから
は見えなくなる．

 void rb_define_readonly_variable(char *name, VALUE *var)

RubyとCとで共有するread onlyのグローバル変数を定義する．read
onlyであること以外はrb_define_variable()と同じ．

 void rb_define_virtual_variable(char *name,
				VALUE (*getter)(), VALUE (*setter)())

関数によって実現されるRuby変数を定義する．変数が参照された時
にはgetterが，変数に値がセットされた時にはsetterが呼ばれる．

 void rb_define_hooked_variable(char *name, VALUE *var,
				VALUE (*getter)(), VALUE (*setter)())

関数によってhookのつけられたグローバル変数を定義する．変数が
参照された時にはgetterが，関数に値がセットされた時にはsetter
が呼ばれる．getterやsetterに0を指定した時にはhookを指定しな
いのと同じ事になる．

 void rb_global_variable(VALUE *var)

GCのため，Rubyプログラムからはアクセスされないが, Rubyオブジェ
クトを含む大域変数をマークする．

** 定数

 void rb_define_const(VALUE klass, char *name, VALUE val)

定数を定義する．

 void rb_define_global_const(char *name, VALUE val)

大域定数を定義する．

     rb_define_const(cKernal, name, val)

と同じ意味．

** メソッド定義

 rb_define_method(VALUE class, char *name, VALUE (*func)(), int argc)

メソッドを定義する．argcはselfを除く引数の数．argcが-1の時, 
関数には引数の数(selfを含まない)を第1引数, 引数の配列を第2引
数とする形式で与えられる(第3引数はself)．argcが-2の時, 第1引
数がself, 第2引数がargs(argsは引数を含むRubyの配列)という形
式で与えられる．

 rb_define_private_method(VALUE class, char *name, VALUE (*func)(), int argc)

privateメソッドを定義する．引数はrb_define_method()と同じ．

 rb_define_singleton_method(VALUE class, char *name, VALUE (*func)(), int argc)

特異メソッドを定義する．引数はrb_define_method()と同じ．

 rb_scan_args(int atgc, VALUE *argv, char *fmt, ...)

argc,argv形式で与えられた引数を分解する．fmtは必須引数の数, 
付加引数の数, 残りの引数があるかを指定する文字列で, "数字数
字*"という形式である． 2 番目の数字と"*"はそれぞれ省略可能で
ある．必須引数が一つもない場合は0を指定する．第3引数以降は変
数へのポインタで, 該当する要素がその変数に格納される．付加引
数に対応する引数が与えられていない場合は変数にQnilが代入され
る．

** Rubyメソッド呼び出し

 VALUE rb_funcall(VALUE recv, ID mid, int narg, ...)

メソッド呼び出し．文字列からmidを得るためにはrb_intern()を使う．

 VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv)

メソッド呼び出し．引数をargc,argv形式で渡す．

 VALUE rb_eval_string(char *str)

文字列をRubyとスクリプトしてコンパイル・実行する．

 ID rb_intern(char *name)

文字列に対応するIDを返す．

 char *rb_id2name(ID id)

IDに対応する文字列を返す(デバッグ用)．

 char *rb_class2name(VALUE class)

classの名前を返す(デバッグ用)．classが名前を持たない時には, 
祖先を遡って名前を持つクラスの名前を返す．

** インスタンス変数

 VALUE rb_iv_get(VALUE obj, char *name)

objのインスタンス変数の値を得る．`@@'で始まらないインスタンス
変数は Rubyプログラムからアクセスできない「隠れた」インスタ
ンス変数になる．定数は大文字の名前を持つクラス(またはモジュー
ル)のインスタンス変数として実装されている．

 VALUE rb_iv_set(VALUE obj, char *name, VALUE val)

objのインスタンス変数をvalにセットする．

** 制御構造

 VALUE rb_iterate(VALUE (*func1)(), void *arg1, VALUE (*func2)(), void *arg2)

func2をブロックとして設定し, func1をイテレータとして呼ぶ． 
func1には arg1が引数として渡され, func2には第1引数にイテレー
タから与えられた値, 第2引数にarg2が渡される．
 
 VALUE rb_yield(VALUE val)

valを値としてイテレータブロックを呼び出す．

 VALUE rb_rescue(VALUE (*func1)(), void *arg1, VALUE (*func2)(), void *arg2)

関数func1をarg1を引数に呼び出す．func1の実行中に例外が発生し
た時には func2をarg2を引数として呼ぶ．戻り値は例外が発生しな
かった時はfunc1の戻り値, 例外が発生した時にはfunc2の戻り値で
ある．

 VALUE rb_ensure(VALUE (*func1)(), void *arg1, void (*func2)(), void *arg2)

関数func1をarg1を引数として実行し, 実行終了後(たとえ例外が発
生しても) func2をarg2を引数として実行する．戻り値はfunc1の戻
り値である(例外が発生した時は戻らない)．

** 例外・エラー

 void rb_warning(char *fmt, ...)

rb_verbose時に標準エラー出力に警告情報を表示する．引数はprintf()と同じ．

 void rb_raise(rb_eRuntimeError, char *fmt, ...)

RuntimeError例外を発生させる．引数はprintf()と同じ．

 void rb_raise(VALUE exception, char *fmt, ...)

exceptionで指定した例外を発生させる．fmt以下の引数はprintf()と同じ．

 void rb_fatal(char *fmt, ...)

致命的例外を発生させる．通常の例外処理は行なわれず, インター
プリタが終了する(ただしensureで指定されたコードは終了前に実
行される)．

 void rb_bug(char *fmt, ...)

インタープリタなどプログラムのバグでしか発生するはずのない状
況の時呼ぶ．インタープリタはコアダンプし直ちに終了する．例外
処理は一切行なわれない．

** Rubyの初期化・実行

Rubyをアプリケーションに埋め込む場合には以下のインタフェース
を使う．通常の拡張ライブラリには必要ない．

 void ruby_init(int argc, char **argv, char **envp)

Rubyインタプリタの初期化を行なう．

 void ruby_run()

Rubyインタプリタを実行する．

 void ruby_script(char *name)

Rubyのスクリプト名($0)を設定する．


Appendix B. extconf.rbで使える関数たち

extconf.rbの中では利用可能なコンパイル条件チェックの関数は以
下の通りである．

 have_library(lib, func)

関数funcを定義しているライブラリlibの存在をチェックする．ラ
イブラリが存在する時，trueを返す．

 have_func(func)

関数funcの存在をチェックする．funcが標準ではリンクされないラ
イブラリ内のものである時には先にhave_libraryでそのライブラリ
をチェックしておく事．関数が存在する時TRUEを返す．

 have_header(header)

ヘッダファイルの存在をチェックする．ヘッダファイルが存在する
時trueを返す．

 create_makefile(target)

拡張ライブラリ用のMakefileを生成する．この関数を呼ばなければ
そのモジュールはコンパイルされない．targetはモジュール名を表
す．

/*
 * Local variables:
 * fill-column: 60
 * end:
 */
@


1.1.1.1.2.1
log
@990126
@
text
@d726 1
a726 1
  % find * -type f -print > MANIFEST
@


1.1.1.1.2.2
log
@990201
@
text
@d669 2
a670 1
    VALUE obj, args;
d676 3
a678 1
第1引数はself，第2引数はRubyの配列です．
@


1.1.1.1.2.3
log
@*** empty log message ***
@
text
@d137 1
a137 1
    1bit左シフトして，LSBを立てる．
@


1.1.1.1.2.4
log
@990224
@
text
@d268 4
a271 4
形式)を決めます．argcが0以上の時は関数に引き渡す引数の数を意
味します．16個以上の引数は使えません(が，要りませんよね，そ
んなに)．実際の関数には先頭の引数としてselfが与えられますの
で，指定した数より1多い引数を持つことになります．
@


1.1.1.1.2.5
log
@990324
@
text
@d508 1
a508 1
Rubyのextディレクトリにすでに含まれているdbmライブラリを例に
d518 1
a518 1
ライブラリ用のディレクトリを作る必要があります．名前は適当に
d545 2
a546 2
スがひとつの時には「ライブラリ名.c」を選ぶと良いでしょう．C
言語のソースが複数の場合には逆に「ライブラリ名.c」というファ
d548 1
a548 1
ル生成時に中間的に生成される「ライブラリ名.o」というファイル
d551 2
a552 2
Rubyは拡張ライブラリをロードする時に「Init_ライブラリ名」と
いう関数を自動的に実行します．dbmライブラリの場合「Init_dbm」
d578 1
a578 1
DBMライブラリはdbmのデータと対応するオブジェクトになるはずで
d630 1
a630 1
るものとがあります．dbmライブラリの中で，Cの配列で受けるもの
d688 3
a690 7
ます．extconf.rbはライブラリのコンパイルに必要な条件のチェッ
クなどを行うことが目的です．まず，

  require 'mkmf'

をextconf.rbの先頭に置きます．extconf.rbの中では以下のRuby関
数を使うことが出来ます．
d702 9
a710 3
ライブラリをコンパイルする条件が揃わず，そのライブラリをコン
パイルしない時にはcreate_makefileを呼ばなければMakefileは生
成されず，コンパイルも行われません．
d759 3
a761 3
拡張ライブラリはmake installでRubyライブラリのディレクトリの
下にコピーされます．もし拡張ライブラリと協調して使うRubyで記
述されたプログラムがあり，Rubyライブラリに置きたい場合には，
d1137 1
a1137 1
そのライブラリはコンパイルされない．targetはモジュール名を表
@


1.1.1.1.2.6
log
@*** empty log message ***
@
text
@d992 1
a992 1
 rb_scan_args(int argc, VALUE *argv, char *fmt, ...)
@


1.1.1.1.2.7
log
@990728
@
text
@d335 1
a335 1
与えられたRubyのプログラムを評価する以下の関数があります．
d404 1
a404 1
以下のRubyの定数はCのレベルから参照できます．
d409 1
a409 1
    真偽値．QfalseはC言語でも偽とみなされます(つまり0)．
d413 1
a413 1
    C言語から見た「nil」．
d840 1
a840 1
VALUE
d842 4
a845 4
  Rubyオブジェクトを表現する型．必要に応じてキャストして用いる．
  組み込み型を表現するCの型はruby.hに記述してあるRで始まる構造
  体である．VALUE型をこれらにキャストするためにRで始まる構造体
  名を全て大文字にした名前のマクロが用意されている．
d849 1
a849 1
Qnil
d851 1
a851 1
  定数: nilオブジェクト
d853 1
a853 1
Qtrue
d855 1
a855 1
  定数: trueオブジェクト(真のデフォルト値)
d857 1
a857 1
Qfalse
d859 1
a859 1
  定数: falseオブジェクト
d863 1
a863 1
Data_Wrap_Struct(VALUE class, void (*mark)(), void (*free)(), void *sval)
d865 5
a869 5
  Cの任意のポインタをカプセル化したRubyオブジェクトを返す．こ
  のポインタがRubyからアクセスされなくなった時，freeで指定した
  関数が呼ばれる．また，このポインタの指すデータが他のRubyオブ
  ジェクトを指している場合，markに指定する関数でマークする必要
  がある．
d871 1
a871 1
Data_Make_Struct(class, type, mark, free, sval)
d873 2
a874 2
  type型のメモリをmallocし，変数svalに代入した後，それをカプセ
  ル化したデータを返すマクロ．
d876 1
a876 1
Data_Get_Struct(data, type, sval)
d878 1
a878 1
  dataからtype型のポインタを取り出し変数svalに代入するマクロ．
d882 5
a886 5
TYPE(value)
FIXNUM_P(value)
NIL_P(value)
void Check_Type(VALUE value, int type)
void Check_SafeStr(VALUE value)
d890 8
a897 8
FIX2INT(value)
INT2FIX(i)
NUM2INT(value)
INT2NUM(i)
NUM2DBL(value)
rb_float_new(f)
STR2CSTR(value)
rb_str_new2(s)
d901 1
a901 1
VALUE rb_define_class(char *name, VALUE super)
d903 1
a903 1
  superのサブクラスとして新しいRubyクラスを定義する．
d905 1
a905 1
VALUE rb_define_class_under(VALUE module, char *name, VALUE super)
d907 2
a908 2
  superのサブクラスとして新しいRubyクラスを定義し，moduleの
  定数として定義する．
d910 1
a910 1
VALUE rb_define_module(char *name)
d912 1
a912 1
  新しいRubyモジュールを定義する．
d914 1
a914 1
VALUE rb_define_module_under(VALUE module, char *name, VALUE super)
d916 1
a916 1
  新しいRubyモジュールを定義し，moduleの定数として定義する．
d918 1
a918 1
void rb_include_module(VALUE class, VALUE module)
d920 2
a921 2
  モジュールをインクルードする．classがすでにmoduleをインク
  ルードしている時には何もしない(多重インクルードの禁止)．
d923 1
a923 1
void rb_extend_object(VALUE object, VALUE module)
d925 1
a925 1
  オブジェクトをモジュール(で定義されているメソッド)で拡張する．
d929 1
a929 1
void rb_define_variable(char *name, VALUE *var)
d931 4
a934 4
  RubyとCとで共有するグローバル変数を定義する．変数名が`$'で
  始まらない時には自動的に追加される．nameとしてRubyの識別子
  として許されない文字(例えば` ')を含む場合にはRubyプログラ
  ムからは見えなくなる．
d936 1
a936 1
void rb_define_readonly_variable(char *name, VALUE *var)
d938 2
a939 2
  RubyとCとで共有するread onlyのグローバル変数を定義する．
  read onlyであること以外はrb_define_variable()と同じ．
d941 1
a941 1
void rb_define_virtual_variable(char *name,
d944 2
a945 11
  関数によって実現されるRuby変数を定義する．変数が参照された
  時にはgetterが，変数に値がセットされた時にはsetterが呼ばれ
  る．

void rb_define_hooked_variable(char *name, VALUE *var,
			       VALUE (*getter)(), VALUE (*setter)())

  関数によってhookのつけられたグローバル変数を定義する．変数
  が参照された時にはgetterが，関数に値がセットされた時には
  setterが呼ばれる．getterやsetterに0を指定した時にはhookを
  指定しないのと同じ事になる．
d947 7
a953 1
void rb_global_variable(VALUE *var)
d955 4
a958 2
  GCのため，Rubyプログラムからはアクセスされないが, Rubyオブ
  ジェクトを含む大域変数をマークする．
d962 1
a962 1
void rb_define_const(VALUE klass, char *name, VALUE val)
d964 1
a964 1
  定数を定義する．
d966 1
a966 1
void rb_define_global_const(char *name, VALUE val)
d968 1
a968 1
  大域定数を定義する．
d972 1
a972 1
  と同じ意味．
d976 7
a982 1
rb_define_method(VALUE class, char *name, VALUE (*func)(), int argc)
d984 1
a984 7
  メソッドを定義する．argcはselfを除く引数の数．argcが-1の時, 
  関数には引数の数(selfを含まない)を第1引数, 引数の配列を第2
  引数とする形式で与えられる(第3引数はself)．argcが-2の時, 
  第1引数がself, 第2引数がargs(argsは引数を含むRubyの配列)と
  いう形式で与えられる．
 
rb_define_private_method(VALUE class, char *name, VALUE (*func)(), int argc)
d986 1
a986 1
  privateメソッドを定義する．引数はrb_define_method()と同じ．
d988 1
a988 1
rb_define_singleton_method(VALUE class, char *name, VALUE (*func)(), int argc)
d990 1
a990 1
  特異メソッドを定義する．引数はrb_define_method()と同じ．
d992 1
a992 1
rb_scan_args(int argc, VALUE *argv, char *fmt, ...)
d994 7
a1000 7
  argc,argv形式で与えられた引数を分解する．fmtは必須引数の数, 
  付加引数の数, 残りの引数があるかを指定する文字列で, "数字
  数字*"という形式である． 2 番目の数字と"*"はそれぞれ省略可
  能である．必須引数が一つもない場合は0を指定する．第3引数以
  降は変数へのポインタで, 該当する要素がその変数に格納される．
  付加引数に対応する引数が与えられていない場合は変数にQnilが
  代入される．
d1004 1
a1004 1
VALUE rb_funcall(VALUE recv, ID mid, int narg, ...)
d1006 1
a1006 2
  メソッド呼び出し．文字列からmidを得るためにはrb_intern()を
  使う．
d1008 1
a1008 1
VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv)
d1010 1
a1010 1
  メソッド呼び出し．引数をargc,argv形式で渡す．
d1012 1
a1012 1
VALUE rb_eval_string(char *str)
d1014 1
a1014 1
  文字列をRubyとスクリプトしてコンパイル・実行する．
d1016 1
a1016 1
ID rb_intern(char *name)
d1018 1
a1018 1
  文字列に対応するIDを返す．
d1020 1
a1020 1
char *rb_id2name(ID id)
d1022 1
a1022 1
  IDに対応する文字列を返す(デバッグ用)．
d1024 1
a1024 1
char *rb_class2name(VALUE class)
d1026 2
a1027 2
  classの名前を返す(デバッグ用)．classが名前を持たない時には, 
  祖先を遡って名前を持つクラスの名前を返す．
d1031 1
a1031 1
VALUE rb_iv_get(VALUE obj, char *name)
d1033 4
a1036 4
  objのインスタンス変数の値を得る．`@@'で始まらないインスタン
  ス変数は Rubyプログラムからアクセスできない「隠れた」イン
  スタンス変数になる．定数は大文字の名前を持つクラス(または
  モジュール)のインスタンス変数として実装されている．
d1038 1
a1038 1
VALUE rb_iv_set(VALUE obj, char *name, VALUE val)
d1040 1
a1040 1
  objのインスタンス変数をvalにセットする．
d1044 1
a1044 1
VALUE rb_iterate(VALUE (*func1)(), void *arg1, VALUE (*func2)(), void *arg2)
d1046 3
a1048 3
  func2をブロックとして設定し, func1をイテレータとして呼ぶ． 
  func1には arg1が引数として渡され, func2には第1引数にイテレー
  タから与えられた値, 第2引数にarg2が渡される．
d1050 1
a1050 1
VALUE rb_yield(VALUE val)
d1052 1
a1052 1
  valを値としてイテレータブロックを呼び出す．
d1054 1
a1054 1
VALUE rb_rescue(VALUE (*func1)(), void *arg1, VALUE (*func2)(), void *arg2)
d1056 4
a1059 4
  関数func1をarg1を引数に呼び出す．func1の実行中に例外が発生
  した時には func2をarg2を引数として呼ぶ．戻り値は例外が発生
  しなかった時はfunc1の戻り値, 例外が発生した時にはfunc2の戻
  り値である．
d1061 1
a1061 1
VALUE rb_ensure(VALUE (*func1)(), void *arg1, void (*func2)(), void *arg2)
d1063 3
a1065 3
  関数func1をarg1を引数として実行し, 実行終了後(たとえ例外が
  発生しても) func2をarg2を引数として実行する．戻り値はfunc1
  の戻り値である(例外が発生した時は戻らない)．
d1069 1
a1069 1
void rb_warning(char *fmt, ...)
d1071 1
a1071 2
  rb_verbose時に標準エラー出力に警告情報を表示する．引数は
  printf()と同じ．
d1073 1
a1073 1
void rb_raise(rb_eRuntimeError, char *fmt, ...)
d1075 1
a1075 1
  RuntimeError例外を発生させる．引数はprintf()と同じ．
d1077 1
a1077 1
void rb_raise(VALUE exception, char *fmt, ...)
d1079 1
a1079 2
  exceptionで指定した例外を発生させる．fmt以下の引数は
  printf()と同じ．
d1081 1
a1081 1
void rb_fatal(char *fmt, ...)
d1083 3
a1085 3
  致命的例外を発生させる．通常の例外処理は行なわれず, インター
  プリタが終了する(ただしensureで指定されたコードは終了前に
  実行される)．
d1087 1
a1087 1
void rb_bug(char *fmt, ...)
d1089 3
a1091 3
  インタープリタなどプログラムのバグでしか発生するはずのない
  状況の時呼ぶ．インタープリタはコアダンプし直ちに終了する．
  例外処理は一切行なわれない．
d1098 1
a1098 1
void ruby_init(int argc, char **argv, char **envp)
d1100 1
a1100 1
  Rubyインタプリタの初期化を行なう．
d1102 1
a1102 1
void ruby_run()
d1104 1
a1104 1
  Rubyインタプリタを実行する．
d1106 1
a1106 1
void ruby_script(char *name)
d1108 1
a1108 1
  Rubyのスクリプト名($0)を設定する．
d1116 1
a1116 23
have_library(lib, func)

  関数funcを定義しているライブラリlibの存在をチェックする．
  ライブラリが存在する時，trueを返す．

find_library(lib, func, path...)

  関数funcを定義しているライブラリlibの存在を -Lpath を追加
  しながらチェックする．ライブラリが見付かった時，trueを返す．
  結果をキャッシュしない．

have_func(func)

  関数funcの存在をチェックする．funcが標準ではリンクされない
  ライブラリ内のものである時には先にhave_libraryでそのライブ
  ラリをチェックしておく事．関数が存在する時trueを返す．

have_header(header)

  ヘッダファイルの存在をチェックする．ヘッダファイルが存在す
  る時trueを返す．

find_header(header)
d1118 2
a1119 3
  ヘッダファイルの存在を -Ipath を追加しながらチェックする．
  ヘッダファイルが見付かった時trueを返す．結果をキャッシュし
  ない．
d1121 1
a1121 1
create_makefile(target)
d1123 3
a1125 3
  拡張ライブラリ用のMakefileを生成する．この関数を呼ばなけれ
  ばそのライブラリはコンパイルされない．targetはモジュール名
  を表す．
d1127 1
a1127 1
with_config(withval[, default=nil])
d1129 2
a1130 1
  --with-<withval>で指定されたオプション値を得る．
d1132 1
a1132 1
dir_config(target)
d1134 3
a1136 3
  --with-<target>-dir, --with-<target>-include, --with-<target>-lib
  のいずれかで指定されるディレクトリを $CFLAGS や $LDFLAGS
  に追加する．
@


1.1.2.1
log
@*** empty log message ***
@
text
@a0 1072
.\" README.EXT -  -*- Text -*- created at: Mon Aug  7 16:45:54 JST 1995

rubyの拡張モジュールの作り方を説明します．

1．基礎知識

Cの変数には型があり，データには型がありません．ですから，た
とえばポインタをintの変数に代入すると，その値は整数として取
り扱われます．逆にrubyの変数には型がなく，データに型がありま
す．この違いのため，Cとrubyは相互に変換しなければ，お互いの
データをアクセスできません．

rubyのデータはVALUEというCの型で表現されます．VALUE型のデー
タはそのデータタイプを自分で知っています．このデータタイプと
いうのはデータ(オブジェクト)の実際の構造を意味していて，ruby
のクラスとはまた違ったものです．

VALUEからCにとって意味のあるデータを取り出すためには

 (1) VALUEのデータタイプを知る
 (2) VALUEをCのデータに変換する

の両方が必要です．(1)を忘れると間違ったデータの変換が行われ
て，最悪プログラムがcore dumpします．

1.1 データタイプ

rubyにはユーザが使う可能性のある以下のタイプがあります．

	T_NIL		nil
	T_OBJECT	通常のオブジェクト
	T_CLASS		クラス
	T_MODULE	モジュール
	T_FLOAT		浮動小数点数
	T_STRING	文字列
	T_REGEXP	正規表現
	T_ARRAY		配列
	T_FIXNUM	Fixnum(31bit長整数)
	T_HASH		連想配列
	T_STRUCT	(rubyの)構造体
	T_BIGNUM	多倍長整数
	T_TRUE		真
	T_FALSE		偽
	T_DATA		データ

その他に内部で利用されている以下のタイプがあります．

	T_ICLASS
	T_MATCH
	T_VARMAP
	T_SCOPE
	T_NODE

いくつかのタイプはCの構造体で実装されています．

1.2 VALUEのデータタイプをチェックする

ruby.hではTYPE()というマクロが定義されていて，VALUEのデータ
タイプを知ることが出来ます．TYPE()マクロは上で紹介したT_XXXX
の形式の定数を返します．VALUEのデータタイプに応じて処理する
場合には，TYPE()の値で分岐することになります．

  switch (TYPE(obj)) {
    case T_FIXNUM:
      /* FIXNUMの処理 */
      break;
    case T_STRING:
      /* 文字列の処理 */
      break;
    case T_ARRAY:
      /* 配列の処理 */
      break;
    default:
      /* 例外を発生させる */
      Fail("not valid value");
      break;
  }

それとデータタイプをチェックして，正しくなければ例外を発生す
る関数が用意されています．

  void Check_Type(VALUE value, int type)

この関数はvalueがtypeで無ければ，例外を発生させます．引数と
して与えられたVALUEのデータタイプが正しいかどうかチェックす
るためには，この関数を使います．

FIXNUMとNILに関してはより高速な判別マクロが用意されています．

  FIXNUM_P(obj)
  NIL_P(obj)

1.3 VALUEをCのデータに変換する

データタイプがT_NIL, T_FALSE, T_TRUEである時，データはそれぞ
れnil, FALSE, TRUEです．このデータタイプのオブジェクトはひと
つずつしか存在しません．

データタイプがT_FIXNUMの時，これは31bitのサイズを持つ整数で
す．FIXNUMをCの整数に変換するためにはマクロ「FIX2INT()」を使
います．それから，FIXNUMに限らずrubyのデータを整数に変換する
「NUM2INT()」というマクロがあります．このマクロはデータタイ
プのチェック無しで使えます(整数に変換できない場合には例外が
発生する)．

それ以外のデータタイプは対応するCの構造体があります．対応す
る構造体のあるVALUEはそのままキャスト(型変換)すれば構造体の
ポインタに変換できます．

構造体は「struct RXxxxx」という名前でruby.hで定義されていま
す．例えば文字列は「struct RString」です．実際に使う可能性が
あるのは文字列と配列くらいだと思います．

ruby.hでは構造体へキャストするマクロも「RXXXXX()」(全部大文
字にしたもの)という名前で提供されています(例: RSTRING())．

例えば，文字列strの長さを得るためには「RSTRING(str)->len」と
し，文字列strをchar*として得るためには「RSTRING(str)->ptr」
とします．配列の場合には，それぞれ「RARRAT(str)->len」，
「RARRAT(str)->ptr」となります．

rubyの構造体を直接アクセスする時に気をつけなければならないこ
とは，配列や文字列の構造体の中身は参照するだけで，直接変更し
ないことです．直接変更した場合，オブジェクトの内容の整合性が
とれなくなって，思わぬバグの原因になります．

1.4 CのデータをVALUEに変換する

VALUEの実際の構造は

  * FIXNUMの場合

    1bit右シフトして，LSBを立てる．

  * その他のポインタの場合

    そのままVALUEにキャストする．

となっています．よって，LSBをチェックすればVALUEがFIXNUMかど
うかわかるわけです(ポインタのLSBが立っていないことを仮定して
いる)．

ですから，FIXNUM以外のrubyのオブジェクトの構造体は単にVALUE
にキャストするだけでVALUEに変換出来ます．ただし，任意の構造
体がVALUEにキャスト出来るわけではありません．キャストするの
はrubyの知っている構造体(ruby.hで定義されているstruct RXxxx
のもの)だけにしておいてください．

FIXNUMに関しては変換マクロを経由する必要があります．Cの整数
からVALUEに変換するマクロは以下のものがあります．必要に応じ
て使い分けてください．

  INT2FIX()	もとの整数が31bit以内に収まる時
  INT2NUM()	任意の整数からVALUEへ

INT2NUM()は整数がFIXNUMの範囲に収まらない場合，Bignumに変換
してくれます(が，少し遅い)．

1.5 rubyのデータを操作する

先程も述べた通り，rubyの構造体をアクセスする時に内容の更新を
行うことは勧められません．で，rubyのデータを操作する時には
rubyが用意している関数を用いてください．

ここではもっとも使われるであろう文字列と配列の生成/操作を行
い関数をあげます(全部ではないです)．

 文字列に対する関数

  str_new(char *ptr, int len)

    新しいrubyの文字列を生成する．

  str_new2(char *ptr)

    Cの文字列からrubyの文字列を生成する．この関数の機能は
    str_new(ptr, strlen(ptr))と同等である．

  str_cat(VALUE str, char *ptr, int len)

    rubyの文字列strにlenバイトの文字列ptrを追加する．

 配列に対する関数

  ary_new()

    要素が0の配列を生成する．

  ary_new2(int len)

    要素が0の配列を生成する．len要素分の領域をあらかじめ割り
    当てておく．

  ary_new3(int n, ...)

    引数で指定したn要素を含む配列を生成する．

  ary_new4(int n, VALUE *elts)

    配列で与えたn要素の配列を生成する．

  ary_push(VALUE ary)
  ary_pop(VALUE ary, VALUE val)
  ary_shift(VALUE ary)
  ary_unshift(VALUE ary, VALUE val)
  ary_entry(VALUE ary, int idx)

    Arrayの同名のメソッドと同じ働きをする関数．第1引数は必ず
    配列でなければならない．

2．rubyの機能を使う

原理的にrubyで書けることはCでも書けます．rubyそのものがCで記
述されているんですから，当然といえば当然なんですけど．ここで
はrubyの拡張に使うことが多いだろうと予測される機能を中心に紹
介します．

2.1 rubyに機能を追加する

rubyで提供されている関数を使えばrubyインタプリタに新しい機能
を追加することができます．rubyでは以下の機能を追加する関数が
提供されています．

 * クラス，モジュール
 * メソッド，特異メソッドなど
 * 定数

では順に紹介します．

2.1.1 クラス/モジュール定義

クラスやモジュールを定義するためには，以下の関数を使います．

  VALUE rb_define_class(char *name, VALUE super)
  VALUE rb_define_module(char *name)

これらの関数は新しく定義されたクラスやモジュールを返します．
メソッドや定数の定義にこれらの値が必要なので，ほとんどの場合
は戻り値を変数に格納しておく必要があるでしょう．

2.1.2 メソッド/特異メソッド定義

メソッドや特異メソッドを定義するには以下の関数を使います．

  void rb_define_method(VALUE class, char *name, 
		        VALUE (*func)(), int argc)

  void rb_define_singleton_method(VALUE object, char *name, 
			          VALUE (*func)(), int argc)


念のため説明すると「特異メソッド」とは，その特定のオブジェク
トに対してだけ有効なメソッドです．rubyではよくSmalltalkにお
けるクラスメソッドとして，クラスに対する特異メソッドが使われ
ます．

これらの関数の argcという引数はCの関数へ渡される引数の数(と
形式)を決めます．argcが正の時は関数に引き渡す引数の数を意味
します．16個以上の引数は使えません(が，要りませんよね，そん
なに)．

argcが負の時は引数の数ではなく，形式を指定したことになります．
argcが-1の時は引数を配列に入れて渡されます．argcが-2の時は引
数はrubyの配列として渡されます．

メソッドを定義する関数はもう二つあります．ひとつはprivateメ
ソッドを定義する関数で，引数はrb_define_method()と同じです．

  void rb_define_private_method(VALUE class, char *name, 
			        VALUE (*func)(), int argc)

privateメソッドとは関数形式でしか呼び出すことの出来ないメソッ
ドです．

もうひとつはモジュール関数を定義するものです．モジュール関数
とはモジュールの特異メソッドであり，同時にprivateメソッドで
もあるものです．例をあげるとMathモジュールのsqrt()などがあげ
られます．このメソッドは

  Math.sqrt(4)

という形式でも

  include Math
  sqrt(4)

という形式でも使えます．モジュール関数を定義する関数は以下の
通りです．

  void rb_define_module_function(VALUE module, char *name, 
		                 VALUE (*func)(), int argc)

関数的メソッド(Kernelモジュールのprivaet method)を定義するた
めの関数は以下の通りです．

  void rb_define_global_function(char *name, VALUE (*func)(), int argc)


2.1.3 定数定義

拡張モジュールが必要な定数はあらかじめ定義しておいた方が良い
でしょう．定数を定義する関数は二つあります．

  void rb_define_const(VALUE class, char *name, VALUE val)
  void rb_define_global_const(char *name, VALUE val)

前者は特定のクラス/モジュールに属する定数を定義するもの，後
者はグローバルな定数を定義するものです．

2.2 rubyの機能をCから呼び出す

既に『1.5 rubyのデータを操作する』で一部紹介したような関数を
使えば，rubyの機能を実現している関数を直接呼び出すことが出来
ます．

# このような関数の一覧表はいまのところありません．ソースを見
# るしかないですね．

それ以外にもrubyの機能を呼び出す方法はいくつかあります．

2.2.1 rubyのプログラムをevalする

Cからrubyの機能を呼び出すもっとも簡単な方法として，文字列で
与えられたrubyのプログラムを評価する関数があります．

  VALUE rb_eval_string(char *str)

この評価は現在の環境で行われます．つまり，現在のローカル変数
などを受け継ぎます．

2.2.2 IDまたはシンボル

Cから文字列を経由せずにrubyのメソッドを呼び出すこともできま
す．その前に，rubyインタプリタ内でメソッドや変数名を指定する
時に使われているIDについて説明しておきましょう．

IDとは変数名，メソッド名を表す整数です．rubyの中では

 :識別子

でアクセスできます．Cからこの整数を得るためには関数

  rb_intern(char *name)

を使います．また一文字の演算子はその文字コードがそのままシン
ボルになっています．

2.2.3 Cからrubyのメソッドを呼び出す

Cから文字列を経由せずにrubyのメソッドを呼び出すためには以下
の関数を使います．

  VALUE rb_funcall(VALUE recv, ID mid, int argc, ...)

この関数はオブジェクトrecvのmidで指定されるメソッドを呼び出
します．

2.2.4 変数/定数を参照/更新する

Cから関数を使って参照・更新できるのは，クラス定数，インスタ
ンス変数です．大域変数は一部のものはCの大域変数としてアクセ
スできます．ローカル変数を参照する方法は公開していません．

オブジェクトのインスタンス変数を参照・更新する関数は以下の通
りです．

  VALUE rb_ivar_get(VALUE obj, ID id)
  VALUE rb_ivar_set(VALUE obj, ID id, VALUE val)

idはrb_intern()で得られるものを使ってください．

クラス定数を参照するには以下の関数を使ってください．

  VALUE rb_const_get(VALUE obj, ID id)

クラス定数を新しく定義するためには『2.1.3 定数定義』で紹介さ
れている関数を使ってください．

3．rubyとCとの情報共有

C言語とrubyの間で情報を共有する方法について解説します．

3.1 Cから参照できるrubyの定数

以下のrubyの定数はCのレベルから参照できる．

  TRUE
  FALSE

真偽値．FALSEはC言語でも偽とみなされる(つまり0)．

  Qnil

C言語から見た「nil」．

3.2 Cとrubyで共有される大域変数

Cとrubyで大域変数を使って情報を共有できます．共有できる大域
変数にはいくつかの種類があります．そのなかでもっとも良く使わ
れると思われるのはrb_define_variable()です．

  void rb_define_variable(char *name, VALUE *var)

この関数はrubyとCとで共有する大域変数を定義します．変数名が
`$'で始まらない時には自動的に追加されます．この変数の値を変
更すると自動的にrubyの対応する変数の値も変わります．

またruby側からは更新できない変数もあります．このread onlyの
変数は以下の関数で定義します．

  void rb_define_readonly_variable(char *name, VALUE *var)

これら変数の他にhookをつけた大域変数を定義できます．hook付き
の大域変数は以下の関数を用いて定義します．hook付き大域変数の
値の参照や設定はhookで行う必要があります．

  void rb_define_hooked_variable(char *name, VALUE *var,
				 VALUE (*getter)(), VALUE (*setter)())

この関数はCの関数によってhookのつけられた大域変数を定義しま
す．変数が参照された時には関数getterが，変数に値がセットされ
た時には関数setterが呼ばれる．hookを指定しない場合はgetterや
setterに0を指定します．

# getterもsetterも0ならばrb_define_variable()と同じになる．

それから，Cの関数によって実現されるrubyの大域変数を定義する
関数があります．

  void rb_define_virtual_variable(char *name,
				  VALUE (*getter)(), VALUE (*setter)())

この関数によって定義されたrubyの大域変数が参照された時には
getterが，変数に値がセットされた時にはsetterが呼ばれます．

getterとsetterの仕様は以下の通りです．

  (*getter)(ID id, void *data, struct global_entry* entry);
  (*setter)(VALUE val, ID id, void *data, struct global_entry* entry);

3.3 Cのデータをrubyオブジェクトにする

Cの世界で定義されたデータ(構造体)をrubyのオブジェクトとして
取り扱いたい場合がありえます．このような場合には，Dataという
rubyオブジェクトにCの構造体(へのポインタ)をくるむことでruby
オブジェクトとして取り扱えるようになります．

Dataオブジェクトを生成して構造体をrubyオブジェクトにカプセル
化するためには，以下のマクロを使います．

  Data_Wrap_Struct(class,mark,free,ptr)

このマクロの戻り値は生成されたDataオブジェクトです．

classはこのDataオブジェクトのクラスです．ptrはカプセル化する
Cの構造体へのポインタです．markはこの構造体がrubyのオブジェ
クトへの参照がある時に使う関数です．そのような参照を含まない
時には0を指定します．

# そのような参照は勧められません．

freeはこの構造体がもう不要になった時に呼ばれる関数です．この
関数がガーベージコレクタから呼ばれます．

Cの構造体の割当とDataオブジェクトの生成を同時に行うマクロと
して以下のものが提供されています．

  Data_Make_Struct(class, type, mark, free, sval)

このマクロの戻り値は生成されたDataオブジェクトです．

class, mark, freeはData_Wrap_Structと同じ働きをします．type
は割り当てるC構造体の型です．割り当てられた構造体は変数sval
に代入されます．この変数の型は (type*) である必要があります．

Dataオブジェクトからポインタを取り出すのは以下のマクロを用い
ます．

  Data_Get_Struct(obj, type, sval)

Cの構造体へのポインタは変数svalに代入されます．

これらのDataの使い方はちょっと分かりにくいので，後で説明する
例題を参照してください．

4．例題 - dbmパッケージを作る

ここまでの説明でとりあえず拡張モジュールは作れるはずです．
rubyのextディレクトリにすでに含まれているdbmモジュールを例に
して段階的に説明します．

(1) ディレクトリを作る

  % mkdir ext/dbm

rubyを展開したディレクトリの下，extディレクトリの中に拡張モ
ジュール用のディレクトリを作ります．名前は適当に選んで構いま
せん．

(2) MANIFESTファイルを作る

  % cd ext/dbm
  % touch MANIFEST

拡張モジュールのディレクトリの下にはMANIFESTというファイルが
必要なので，とりあえず空のファイルを作っておきます．後でこの
ファイルには必要なファイル一覧が入ることになります．

MANIFESTというファイルは，makeの時にディレクトリが拡張モジュー
ルを含んでいるかどうか判定するために使われれています．

(3) 設計する

まあ，当然なんですけど，どういう機能を実現するかどうかまず設
計する必要があります．どんなクラスをつくるか，そのクラスには
どんなメソッドがあるか，クラスが提供する定数などについて設計
します．dbmクラスについてはext/dbm.docを参照してください．

(4) Cコードを書く

拡張モジュール本体となるC言語のソースを書きます．C言語のソー
スがひとつの時には「モジュール名.c」を選ぶと良いでしょう．C
言語のソースが複数の場合には逆に「モジュール名.c」というファ
イル名は避ける必要があります．オブジェクトファイルとモジュー
ル生成時に中間的に生成される「モジュール名.o」というファイル
とが衝突するからです．

rubyは拡張モジュールをロードする時に「Init_モジュール名」と
いう関数を自動的に実行します．dbmモジュールの場合「Init_dbm」
です．この関数の中でクラス，モジュール，メソッド，定数などの
定義を行います．dbm.cから一部引用します．

--
Init_dbm()
{
    /* DBMクラスを定義する */
    cDBM = rb_define_class("DBM", cObject);
    /* DBMはEnumerateモジュールをインクルードする */
    rb_include_module(cDBM, mEnumerable);

    /* DBMクラスのクラスメソッドopen(): 引数はCの配列で受ける */
    rb_define_singleton_method(cDBM, "open", fdbm_s_open, -1);

    /* DBMクラスのメソッドclose(): 引数はなし */
    rb_define_method(cDBM, "close", fdbm_close, 0);
    /* DBMクラスのメソッド[]: 引数は1個 */
    rb_define_method(cDBM, "[]", fdbm_fetch, 1);
		:

    /* DBMデータを格納するインスタンス変数名のためのID */
    id_dbm = rb_intern("dbm");
}
--

DBMモジュールはdbmのデータと対応するオブジェクトになるはずで
すから，Cの世界のdbmをrubyの世界に取り込む必要があります．


dbm.cではData_Make_Structを以下のように使っています．

--
struct dbmdata {
    int  di_size;
    DBM *di_dbm;
};


obj = Data_Make_Struct(class,struct dbmdata,0,free_dbm,dbmp);
--

ここではdbmstruct構造体へのポインタをDataにカプセル化してい
ます．DBM*を直接カプセル化しないのはclose()した時の処理を考
えてのことです．

Dataオブジェクトからdbmstruct構造体のポインタを取り出すため
に以下のマクロを使っています．

--
#define GetDBM(obj, dbmp) {\
    Data_Get_Struct(obj, struct dbmdata, dbmp);\
    if (dbmp->di_dbm == 0) closed_dbm();\
}
--

ちょっと複雑なマクロですが，要するにdbmdata構造体のポインタ
の取り出しと，closeされているかどうかのチェックをまとめてい
るだけです．

DBMクラスにはたくさんメソッドがありますが，分類すると3種類の
引数の受け方があります．ひとつは引数の数が固定のもので，例と
してはdeleteメソッドがあります．deleteメソッドを実装している
fdbm_delete()はこのようになっています．

--
static VALUE
fdbm_delete(obj, keystr)
    VALUE obj, keystr;
{
	:
}
--

引数の数が固定のタイプは第1引数がself，第2引数以降がメソッド
の引数となります．

引数の数が不定のものはCの配列で受けるものとrubyの配列で受け
るものとがあります．dbmモジュールの中で，Cの配列で受けるもの
はDBMのクラスメソッドであるopen()です．これを実装している関
数fdbm_s_open()はこうなっています．

--
static VALUE
fdbm_s_open(argc, argv, class)
    int argc;
    VALUE *argv;
    VALUE class;
{
	:
    if (rb_scan_args(argc, argv, "11", &file, &vmode) == 1) {
	mode = 0666;		/* default value */
    }
	:
}
--

このタイプの関数は第1引数が与えられた引数の数，第2引数が与え
られた引数の入っている配列になります．selfは第3引数として与
えられます．

この配列で与えられた引数を解析するための関数がopen()でも使わ
れているrb_scan_args()です．第3引数に指定したフォーマットに
従い，第4変数以降に指定した変数に値を代入してくれます．この
フォーマットは，第1文字目が省略できない引数の数，第2文字目が
省略できる引数の数，第3文字目が対応する相手が無いあまりの引
数があるかどうかを示す"*"です．2文字目と3文字目は省略できま
す．dbm.cの例では，フォーマットは"11"ですから，引数は最低1つ
で，2つまで許されるという意味になります．省略されている時の
変数の値はnil(C言語のレベルではQnil)になります．

rubyの配列で引数を受け取るものはindexesがあります．実装はこ
うです．

--
static VALUE
fdbm_indexes(obj, args)
    VALUE obj;
    struct RArray *args;
{
	:
}
--

第1引数はself，第2引数はrubyの配列です．ここではキャストを減
らすため struct RArray* で受けていますが，VALUEでも同じこと
です．

** 注意事項

rubyと共有はしないがrubyのオブジェクトを格納する可能性のある
Cの大域変数は以下の関数を使ってrubyインタプリタに変数の存在
を教えてあげてください．でないとGCでトラブルを起こします．

  void rb_global_variable(VALUE *var)

(5) extconf.rbを用意する

もしディレクトリに「extconf.rb」というファイルが存在すれば，
make時に実行されます．なければ適当にMakefileが生成されます．

extconf.rbはモジュールのコンパイルに必要な条件のチェックなど
を行うことが目的です．extconf.rbの中では以下のruby関数を使う
ことが出来ます．

  have_library(lib, func): ライブラリの存在チェック
  have_func(func): 関数の存在チェック
  have_header(header): ヘッダファイルの存在チェック
  create_makefile(target): Makefileの生成

以下の変数を使うことができます．

  $CFLAGS: コンパイル時に追加的に指定するフラグ(-Iなど)
  $LDFLAGS: リンク時に追加的に指定するフラグ(-Lなど)

モジュールをコンパイルする条件が揃わなず，そのモジュールはコ
ンパイルしない時にはcreate_makefileを呼ばなければMakefileは
生成されず，コンパイルも行われません．

(6) dependを用意する

もし，ディレクトリにdependというファイルが存在すれば，
Makefileが依存関係をチェックしてくれます．

 % gcc -MM *.c > depend

などで作ることが出来ます．あって損は無いでしょう．

(7) MANIFESTファイルにファイル名を入れる

  % ls > MANIFEST
  % vi MANIFEST

*.o, *~など不必要なファイル以外はMANIFESTに追加しておきます．
make時にはMANIFESTの内容は参照しませんので，空のままでも問題
は起きませんが，パッケージングの時に参照することがあるのと，
必要なファイルを区別できるので，用意しておいた方が良いでしょ
う．

(8) makeする

rubyのディレクトリでmakeを実行するとMakefileを生成からmake，
必要によってはそのモジュールのrubyへのリンクまで自動的に実行
してくれます．extconf.rbを書き換えるなどしてMakefileの再生成
が必要な時はまたrubyディレクトリでmakeしてください．

(9) デバッグ

まあ，デバッグしないと動かないでしょうね．ext/Setupにディレ
クトリ名を書くと静的にリンクするのでデバッガが使えるようにな
ります．その分コンパイルが遅くなりますけど．

(10) できあがり

後はこっそり使うなり，広く公開するなり，売るなり，ご自由にお
使いください．rubyの作者は拡張モジュールに関して一切の権利を
主張しません．

Appendix A. rubyのソースコードの分類

rubyのソースはいくつかに分類することが出来ます．このうちクラ
スライブラリの部分は基本的に拡張モジュールと同じ作り方になっ
ています．これらのソースは今までの説明でほとんど理解できると
思います．

ruby言語のコア

  class.c
  error.c
  eval.c
  gc.c
  object.c
  parse.y
  variable.c

ユーティリティ関数

  dln.c
  fnmatch.c
  glob.c
  regex.c
  st.c
  util.c

rubyコマンドの実装

  dmyext.c
  inits.c
  main.c
  ruby.c
  version.c

クラスライブラリ

  array.c
  bignum.c
  compar.c
  dir.c
  enum.c
  file.c
  hash.c
  io.c
  math.c
  numeric.c
  pack.c
  process.c
  random.c
  range.c
  re.c
  signal.c
  sprintf.c
  string.c
  struct.c
  time.c

Appendix B. 拡張用関数リファレンス

C言語からrubyの機能を利用するAPIは以下の通りである．

** 型

 VALUE

rubyオブジェクトを表現する型．必要に応じてキャストして用いる．
組み込み型を表現するCの型はruby.hに記述してあるRで始まる構造
体である．VALUE型をこれらにキャストするためにRで始まる構造体
名を全て大文字にした名前のマクロが用意されている．

** 変数・定数

 Qnil

定数: nilオブジェクト

 TRUE

定数: TRUEオブジェクト(真のデフォルト値)

 FALSE

定数: FALSEオブジェクト

** Cデータのカプセル化

 Wrap_Data_Ptr(VALUE class, void (*mark)(), void (*free)(), void *sval)

Cの任意のポインタをカプセル化したrubyオブジェクトを返す．こ
のポインタがrubyからアクセスされなくなった時，freeで指定した
関数が呼ばれる．また，このポインタの指すデータが他のrubyオブ
ジェクトを指している場合，markに指定する関数でマークする必要
がある．

 Make_Data_Struct(class, type, mark, free, sval)

type型のメモリをmallocし，変数svalに代入した後，それをカプセ
ル化したデータを返すマクロ．

 Data_Get_Struct(data, type, sval)

dataからtype型のポインタを取り出し変数svalに代入するマクロ．

** クラス/モジュール定義

 VALUE rb_define_class(char *name, VALUE super)

superのサブクラスとして新しいrubyクラスを定義する．

 VALUE rb_define_class_under(VALUE module, char *name, VALUE super)

superのサブクラスとして新しいrubyクラスを定義し，moduleの定
数として定義する．

 VALUE rb_define_module(char *name)

新しいrubyモジュールを定義する．

 VALUE rb_define_module_under(VALUE module, char *name, VALUE super)

新しいrubyモジュールを定義し，moduleの定数として定義する．

 void rb_include_module(VALUE class, VALUE module)

モジュールをインクルードする．classがすでにmoduleをインクルー
ドしている時には何もしない(多重インクルードの禁止)．

 void rb_extend_object(VALUE object, VALUE module)

オブジェクトをモジュール(で定義されているメソッド)で拡張する．

** 大域変数定義

 void rb_define_variable(char *name, VALUE *var)

rubyとCとで共有するグローバル変数を定義する．変数名が`$'で始
まらない時には自動的に追加される．nameとしてrubyの識別子とし
て許されない文字(例えば` ')を含む場合にはrubyプログラムから
は見えなくなる．

 void rb_define_readonly_variable(char *name, VALUE *var)

rubyとCとで共有するread onlyのグローバル変数を定義する．read
onlyであること以外はrb_define_variable()と同じ．

 void rb_define_virtual_variable(char *name,
				VALUE (*getter)(), VALUE (*setter)())

関数によって実現されるruby変数を定義する．変数が参照された時
にはgetterが，変数に値がセットされた時にはsetterが呼ばれる．

 void rb_define_hooked_variable(char *name, VALUE *var,
				VALUE (*getter)(), VALUE (*setter)())

関数によってhookのつけられたグローバル変数を定義する．変数が
参照された時にはgetterが，関数に値がセットされた時にはsetter
が呼ばれる．getterやsetterに0を指定した時にはhookを指定しな
いのと同じ事になる．

 void rb_global_variable(VALUE *var)

GCのため，rubyプログラムからはアクセスされないが, rubyオブジェ
クトを含む大域変数をマークする．

** クラス定数

 void rb_define_const(VALUE class, char *name, VALUE val)

クラス定数を定義する．

 void rb_define_global_const(char *name, VALUE val)

大域定数を定義する．

     rb_define_const(cKernal, name, val)

と同じ意味．

** メソッド定義

 rb_define_method(VALUE class, char *name, VALUE (*func)(), int argc)

メソッドを定義する．argcはselfを除く引数の数．argcが-1の時, 
関数には引数の数(selfを含まない)を第1引数, 引数の配列を第2引
数とする形式で与えられる(第3引数はself)．argcが-2の時, 第1引
数がself, 第2引数がargs(argsは引数を含むrubyの配列)という形
式で与えられる．

 rb_define_private_method(VALUE class, char *name, VALUE (*func)(), int argc)

privateメソッドを定義する．引数はrb_define_method()と同じ．

 rb_define_singleton_method(VALUE class, char *name, VALUE (*func)(), int argc)

特異メソッドを定義する．引数はrb_define_method()と同じ．

 rb_scan_args(int atgc, VALUE *argv, char *fmt, ...)

argc,argv形式で与えられた引数を分解する．fmtは必須引数の数, 
付加引数の数, 残りの引数があるかを指定する文字列で, "数字数
字*"という形式である． 2 番目の数字と"*"はそれぞれ省略可能で
ある．必須引数が一つもない場合は0を指定する．第3引数以降は変
数へのポインタで, 該当する要素がその変数に格納される．付加引
数に対応する引数が与えられていない場合は変数にQnilが代入され
る．

** rubyメソッド呼び出し

 VALUE rb_funcall(VALUE recv, ID mid, int narg, ...)

メソッド呼び出し．文字列からmidを得るためにはrb_intern()を使う．

 VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv)

メソッド呼び出し．引数をargc,argv形式で渡す．

 VALUE rb_eval_string(char *str)

文字列をrubyとスクリプトしてコンパイル・実行する．

 ID rb_intern(char *name)

文字列に対応するIDを返す．

 char *rb_id2name(ID id)

IDに対応する文字列を返す(デバッグ用)．

 char *rb_class2name(VALUE class)

classの名前を返す(デバッグ用)．classが名前を持たない時には, 
祖先を遡って名前を持つクラスの名前を返す．

** インスタンス変数

 VALUE rb_iv_get(VALUE obj, char *name)

objのインスタンス変数の値を得る．`@@'で始まらないインスタンス
変数は rubyプログラムからアクセスできない「隠れた」インスタ
ンス変数になる．

 VALUE rb_iv_set(VALUE obj, char *name, VALUE val)

objのインスタンス変数をvalにセットする．

** 制御構造

 VALUE rb_iterate(VALUE (*func1)(), void *arg1, VALUE (*func2)(), void *arg2)

func2をブロックとして設定し, func1をイテレータとして呼ぶ． 
func1には arg1が引数として渡され, func2には第1引数にイテレー
タから与えられた値, 第2引数にarg2が渡される．
 
 VALUE rb_yield(VALUE val)

valを値としてイテレータブロックを呼び出す．

 VALUE rb_rescue(VALUE (*func1)(), void *arg1, VALUE (*func2)(), void *arg2)

関数func1をarg1を引数に呼び出す．func1の実行中に例外が発生し
た時には func2をarg2を引数として呼ぶ．戻り値は例外が発生しな
かった時はfunc1の戻り値, 例外が発生した時にはfunc2の戻り値で
ある．

 VALUE rb_ensure(VALUE (*func1)(), void *arg1, void (*func2)(), void *arg2)

関数func1をarg1を引数として実行し, 実行終了後(たとえ例外が発
生しても) func2をarg2を引数として実行する．戻り値はfunc1の戻
り値である(例外が発生した時は戻らない)．

** 例外・エラー

 void Warning(char *fmt, ...)

verbose時に標準エラー出力に警告情報を表示する．引数はprintf()と同じ．

 void Fail(char *fmt, ...)

RuntimeError例外を発生させる．引数はprintf()と同じ．

 void Raise(VALUE exception, char *fmt, ...)

exceptionで指定した例外を発生させる．引数はprintf()と同じ．

 void Fatal(char *fmt, ...)

致命的例外を発生させる．通常の例外処理は行なわれず, インター
プリタが終了する(ただしensureで指定されたコードは終了前に実
行される)．

 void Bug(char *fmt, ...)

インタープリタなどプログラムのバグでしか発生するはずのない状
況の時呼ぶ．インタープリタはコアダンプし直ちに終了する．例外
処理は一切行なわれない．

** rubyの初期化・実行

rubyをアプリケーションに埋め込む場合には以下のインタフェース
を使う．通常の拡張モジュールには必要ない．

 void ruby_init(int argc, char **argv, char **envp)

rubyインタプリタの初期化を行なう．

 void ruby_run()

rubyインタプリタを実行する．

 void ruby_script(char *name)

rubyのスクリプト名($0)を設定する．


Appendix B. extconf.rbで使える関数たち

extconf.rbの中では利用可能なコンパイル条件チェックの関数は以
下の通りである．

 have_library(lib, func)

関数funcを定義しているライブラリlibの存在をチェックする．ラ
イブラリが存在する時，TRUEを返す．

 have_func(func)

関数funcの存在をチェックする．funcが標準ではリンクされないラ
イブラリ内のものである時には先にhave_libraryでそのライブラリ
をチェックしておく事．関数が存在する時TRUEを返す．

 have_header(header)

ヘッダファイルの存在をチェックする．ヘッダファイルが存在する
時TRUEを返す．

 create_makefile(target)

拡張モジュール用のMakefileを生成する．この関数を呼ばなければ
そのモジュールはコンパイルされない．targetはモジュール名を表
す．

/*
 * Local variables:
 * fill-column: 60
 * end:
 */
@


1.1.2.2
log
@__FILE__,__LINE__
@
text
@a714 7
動的リンクライブラリはmake installでrubyライブラリのディレク
トリの下にコピーされます．もしモジュールと協調して使うrubyで
記述されたプログラムがあり，rubyライブラリに置きたい場合には，
拡張モジュール用のディレクトリの下に lib というディレクトリ
を作り，そこに 拡張子 .rb のファイルを置いておけば同時にイン
ストールされます．

@


1.1.2.3
log
@1.1b8pre2
@
text
@a41 1
	T_FILE		入出力
d54 1
a54 1
ほとんどのタイプはCの構造体で実装されています．
d75 1
a75 1
      TypeError("not valid value");
d96 1
a96 1
れnil, false, trueです．このデータタイプのオブジェクトはひと
a105 3
同様にチェック無しで使える変換マクロはdoubleを取り出す
「NUM2DBL()」とchar*を取り出す「STR2CSTR()」があります．

d147 1
a147 1
のもの)だけです．
d153 1
a153 1
  INT2FIX()	もとの整数が31bit以内に収まる自信がある時
a240 6
クラスやモジュールを他のクラスの内部にネストして定義する時に
は以下の関数を使います．

  VALUE rb_define_class(VALUE outer, char *name, VALUE super)
  VALUE rb_define_module(VALUE outer, char *name)

d260 1
a260 2
なに)．実際の関数には先頭の引数としてselfが与えられますので，
指定した数より1多い引数を持つことになります．
d293 1
a293 1
関数的メソッド(Kernelモジュールのprivate method)を定義するた
d346 1
a346 4
ボルになっています．rubyから引数として与えられたシンボル(ま
たは文字列)をIDに変換するには以下の関数を使います．

  rb_to_id(VALUE symbol)
d356 1
a356 6
します．その他に引数の指定の仕方が違う以下の関数もあります．

  VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv)
  VALUE rb_apply(VALUE recv, ID mid, VALUE args)

applyには引数としてrubyの配列を与えます．
d496 3
a498 5
ruby 1.1からは任意のディレクトリでダイナミックライブラリを作
ることができるようになりました．rubyに静的にリンクする場合に
はrubyを展開したディレクトリの下，extディレクトリの中に拡張
モジュール用のディレクトリを作る必要があります．名前は適当に
選んで構いません．
d509 2
a510 4
MANIFESTというファイルは，静的リンクのmakeの時にディレクトリ
が拡張モジュールを含んでいるかどうか判定するために使われれて
います．ダイナミックライブラリを作る場合には必ずしも必要では
ありません．
d667 6
a672 4
Makefileを作る場合の雛型になるextconf.rbというファイルを作り
ます．extconf.rbはモジュールのコンパイルに必要な条件のチェッ
クなどを行うことが目的です．extconf.rbの中では以下のruby関数
を使うことが出来ます．
a687 6
モジュールがruby 1.1専用である場合には 

  require 'mkmf'

をextconf.rbの先頭に置くと便利でしょう．

d708 1
a708 1
(8) Makefileを生成する
d710 4
a713 24
Makefileを実際に生成するためには

  ruby extconf.rb

とします．extconf.rbに require 'mkmf' の行がない場合にはエラー
になりますので，引数を追加して

  ruby -r mkmf extconf.rb

としてください．

ディレクトリをext以下に用意した場合にはruby全体のmakeの時に
自動的にMakefileが生成されますので，このステップは不要です．

(9) makeする

動的リンクライブラリを生成する場合にはその場でmakeしてくださ
い．必要であれば make install でインストールされます．

ext以下にディレクトリを用意した場合は，rubyのディレクトリで
makeを実行するとMakefileを生成からmake，必要によってはそのモ
ジュールのrubyへのリンクまで自動的に実行してくれます．
extconf.rbを書き換えるなどしてMakefileの再生成が必要な時はま
たrubyディレクトリでmakeしてください．
d722 1
a722 1
(10) デバッグ
d728 1
a728 1
(11) できあがり
a777 1
  marshal.c
d812 1
a812 1
定数: trueオブジェクト(真のデフォルト値)
d816 1
a816 1
定数: falseオブジェクト
d820 1
a820 1
 Data_Wrap_Struct(VALUE class, void (*mark)(), void (*free)(), void *sval)
d828 1
a828 1
 Data_Make_Struct(class, type, mark, free, sval)
a835 19

** 型チェック

 TYPE(value)
 FIXNUM_P(value)
 NIL_P(value)
 void Check_Type(VALUE value, int type)
 void Check_SafeStr(VALUE value)

** 型変換

 FIX2INT(value)
 INT2FIX(i)
 NUM2INT(value)
 INT2NUM(i)
 NUM2DBL(value)
 float_new(f)
 STR2CSTR(value)
 str_new2(s)
@


1.1.2.4
log
@1.1b9_16 pre
@
text
@d1040 1
a1040 2
ンス変数になる．定数は大文字の名前を持つクラス(またはモジュー
ル)のインスタンス変数として実装されている．
d1083 1
a1083 1
exceptionで指定した例外を発生させる．fmt以下の引数はprintf()と同じ．
@


1.1.2.5
log
@README.EXT.jp
@
text
@d123 2
a124 2
とします．配列の場合には，それぞれ「RARRAY(str)->len」，
「RARRAY(str)->ptr」となります．
@


1.1.2.6
log
@prototypes
@
text
@d3 1
a3 1
Rubyの拡張モジュールの作り方を説明します．
d9 2
a10 2
り扱われます．逆にRubyの変数には型がなく，データに型がありま
す．この違いのため，CとRubyは相互に変換しなければ，お互いの
d13 1
a13 1
RubyのデータはVALUEというCの型で表現されます．VALUE型のデー
d15 1
a15 1
いうのはデータ(オブジェクト)の実際の構造を意味していて，Ruby
d28 1
a28 1
Rubyにはユーザが使う可能性のある以下のタイプがあります．
d40 1
a40 1
	T_STRUCT	(Rubyの)構造体
d102 1
a102 1
います．それから，FIXNUMに限らずRubyのデータを整数に変換する
d126 1
a126 1
Rubyの構造体を直接アクセスする時に気をつけなければならないこ
d147 1
a147 1
ですから，FIXNUM以外のRubyのオブジェクトの構造体は単にVALUE
d150 1
a150 1
はRubyの知っている構造体(ruby.hで定義されているstruct RXxxx
d163 1
a163 1
1.5 Rubyのデータを操作する
d165 3
a167 3
先程も述べた通り，Rubyの構造体をアクセスする時に内容の更新を
行うことは勧められません．で，Rubyのデータを操作する時には
Rubyが用意している関数を用いてください．
d176 1
a176 1
    新しいRubyの文字列を生成する．
d180 1
a180 1
    Cの文字列からRubyの文字列を生成する．この関数の機能は
d185 1
a185 1
    Rubyの文字列strにlenバイトの文字列ptrを追加する．
d215 1
a215 1
2．Rubyの機能を使う
d217 1
a217 1
原理的にRubyで書けることはCでも書けます．RubyそのものがCで記
d219 1
a219 1
はRubyの拡張に使うことが多いだろうと予測される機能を中心に紹
d222 1
a222 1
2.1 Rubyに機能を追加する
d224 2
a225 2
Rubyで提供されている関数を使えばRubyインタプリタに新しい機能
を追加することができます．Rubyでは以下の機能を追加する関数が
d263 1
a263 1
トに対してだけ有効なメソッドです．RubyではよくSmalltalkにお
d275 1
a275 1
数はRubyの配列として渡されます．
d321 1
a321 1
2.2 Rubyの機能をCから呼び出す
d323 2
a324 2
既に『1.5 Rubyのデータを操作する』で一部紹介したような関数を
使えば，Rubyの機能を実現している関数を直接呼び出すことが出来
d330 1
a330 1
それ以外にもRubyの機能を呼び出す方法はいくつかあります．
d332 1
a332 1
2.2.1 Rubyのプログラムをevalする
d334 2
a335 2
CからRubyの機能を呼び出すもっとも簡単な方法として，文字列で
与えられたRubyのプログラムを評価する関数があります．
d344 2
a345 2
Cから文字列を経由せずにRubyのメソッドを呼び出すこともできま
す．その前に，Rubyインタプリタ内でメソッドや変数名を指定する
d348 1
a348 1
IDとは変数名，メソッド名を表す整数です．Rubyの中では
d357 1
a357 1
ボルになっています．Rubyから引数として与えられたシンボル(ま
d362 1
a362 1
2.2.3 CからRubyのメソッドを呼び出す
d364 1
a364 1
Cから文字列を経由せずにRubyのメソッドを呼び出すためには以下
d375 1
a375 1
applyには引数としてRubyの配列を与えます．
d398 1
a398 1
3．RubyとCとの情報共有
d400 1
a400 1
C言語とRubyの間で情報を共有する方法について解説します．
d402 1
a402 1
3.1 Cから参照できるRubyの定数
d404 1
a404 1
以下のRubyの定数はCのレベルから参照できる．
d415 1
a415 1
3.2 CとRubyで共有される大域変数
d417 1
a417 1
CとRubyで大域変数を使って情報を共有できます．共有できる大域
d423 1
a423 1
この関数はRubyとCとで共有する大域変数を定義します．変数名が
d425 1
a425 1
更すると自動的にRubyの対応する変数の値も変わります．
d427 1
a427 1
またRuby側からは更新できない変数もあります．このread onlyの
d446 1
a446 1
それから，Cの関数によって実現されるRubyの大域変数を定義する
d452 1
a452 1
この関数によって定義されたRubyの大域変数が参照された時には
d460 1
a460 1
3.3 CのデータをRubyオブジェクトにする
d462 1
a462 1
Cの世界で定義されたデータ(構造体)をRubyのオブジェクトとして
d464 1
a464 1
RubyオブジェクトにCの構造体(へのポインタ)をくるむことでRuby
d467 1
a467 1
Dataオブジェクトを生成して構造体をRubyオブジェクトにカプセル
d475 1
a475 1
Cの構造体へのポインタです．markはこの構造体がRubyのオブジェ
d508 1
a508 1
Rubyのextディレクトリにすでに含まれているdbmモジュールを例に
d515 3
a517 3
Ruby 1.1からは任意のディレクトリでダイナミックライブラリを作
ることができるようになりました．Rubyに静的にリンクする場合に
はRubyを展開したディレクトリの下，extディレクトリの中に拡張
d551 1
a551 1
Rubyは拡張モジュールをロードする時に「Init_モジュール名」と
d579 1
a579 1
すから，Cの世界のdbmをRubyの世界に取り込む必要があります．
d629 1
a629 1
引数の数が不定のものはCの配列で受けるものとRubyの配列で受け
d663 1
a663 1
Rubyの配列で引数を受け取るものはindexesがあります．実装はこ
d676 1
a676 1
第1引数はself，第2引数はRubyの配列です．ここではキャストを減
d682 2
a683 2
Rubyと共有はしないがRubyのオブジェクトを格納する可能性のある
Cの大域変数は以下の関数を使ってRubyインタプリタに変数の存在
d692 1
a692 1
クなどを行うことが目的です．extconf.rbの中では以下のRuby関数
d709 1
a709 1
モジュールがRuby 1.1専用である場合には 
d748 1
a748 1
ディレクトリをext以下に用意した場合にはRuby全体のmakeの時に
d756 1
a756 1
ext以下にディレクトリを用意した場合は，Rubyのディレクトリで
d758 1
a758 1
ジュールのRubyへのリンクまで自動的に実行してくれます．
d760 1
a760 1
たRubyディレクトリでmakeしてください．
d762 3
a764 3
動的リンクライブラリはmake installでRubyライブラリのディレク
トリの下にコピーされます．もしモジュールと協調して使うRubyで
記述されたプログラムがあり，Rubyライブラリに置きたい場合には，
d778 1
a778 1
使いください．Rubyの作者は拡張モジュールに関して一切の権利を
d781 1
a781 1
Appendix A. Rubyのソースコードの分類
d783 1
a783 1
Rubyのソースはいくつかに分類することが出来ます．このうちクラ
d788 1
a788 1
Ruby言語のコア
d807 1
a807 1
Rubyコマンドの実装
d841 1
a841 1
C言語からRubyの機能を利用するAPIは以下の通りである．
d847 1
a847 1
Rubyオブジェクトを表現する型．必要に応じてキャストして用いる．
d870 3
a872 3
Cの任意のポインタをカプセル化したRubyオブジェクトを返す．こ
のポインタがRubyからアクセスされなくなった時，freeで指定した
関数が呼ばれる．また，このポインタの指すデータが他のRubyオブ
d908 1
a908 1
superのサブクラスとして新しいRubyクラスを定義する．
d912 1
a912 1
superのサブクラスとして新しいRubyクラスを定義し，moduleの定
d917 1
a917 1
新しいRubyモジュールを定義する．
d921 1
a921 1
新しいRubyモジュールを定義し，moduleの定数として定義する．
d936 3
a938 3
RubyとCとで共有するグローバル変数を定義する．変数名が`$'で始
まらない時には自動的に追加される．nameとしてRubyの識別子とし
て許されない文字(例えば` ')を含む場合にはRubyプログラムから
d943 1
a943 1
RubyとCとで共有するread onlyのグローバル変数を定義する．read
d949 1
a949 1
関数によって実現されるRuby変数を定義する．変数が参照された時
d962 1
a962 1
GCのため，Rubyプログラムからはアクセスされないが, Rubyオブジェ
d986 1
a986 1
数がself, 第2引数がargs(argsは引数を含むRubyの配列)という形
d1007 1
a1007 1
** Rubyメソッド呼び出し
d1019 1
a1019 1
文字列をRubyとスクリプトしてコンパイル・実行する．
d1039 1
a1039 1
変数は Rubyプログラムからアクセスできない「隠れた」インスタ
d1098 1
a1098 1
** Rubyの初期化・実行
d1100 1
a1100 1
Rubyをアプリケーションに埋め込む場合には以下のインタフェース
d1105 1
a1105 1
Rubyインタプリタの初期化を行なう．
d1109 1
a1109 1
Rubyインタプリタを実行する．
d1113 1
a1113 1
Rubyのスクリプト名($0)を設定する．
@


1.1.2.7
log
@1.1b9_25
@
text
@d206 2
a207 2
  ary_push(VALUE ary, VALUE val)
  ary_pop(VALUE ary)
@


1.1.2.7.2.1
log
@1.1d series
@
text
@d174 1
a174 1
  rb_str_new(char *ptr, int len)
d178 1
a178 1
  rb_str_new2(char *ptr)
d181 1
a181 1
    rb_str_new(ptr, strlen(ptr))と同等である．
d183 1
a183 1
  rb_str_cat(VALUE str, char *ptr, int len)
d189 1
a189 1
  rb_ary_new()
d193 1
a193 1
  rb_ary_new2(int len)
d198 1
a198 1
  rb_ary_new3(int n, ...)
d202 1
a202 1
  rb_ary_new4(int n, VALUE *elts)
d206 5
a210 5
  rb_ary_push(VALUE ary, VALUE val)
  rb_ary_pop(VALUE ary)
  rb_ary_shift(VALUE ary)
  rb_ary_unshift(VALUE ary, VALUE val)
  rb_ary_entry(VALUE ary, int idx)
d406 2
a407 2
  Qtrue
  Qfalse
d409 1
a409 1
真偽値．QfalseはC言語でも偽とみなされる(つまり0)．
d560 1
a560 1
    cDBM = rb_define_class("DBM", rb_cObject);
d562 1
a562 1
    rb_include_module(cDBM, rb_mEnumerable);
d858 1
a858 1
 Qtrue
d862 1
a862 1
 Qfalse
d900 1
a900 1
 rb_float_new(f)
d902 1
a902 1
 rb_str_new2(s)
d1074 1
a1074 1
 void rb_warning(char *fmt, ...)
d1076 1
a1076 1
rb_verbose時に標準エラー出力に警告情報を表示する．引数はprintf()と同じ．
d1078 1
a1078 1
 void rb_raise(rb_eRuntimeError, char *fmt, ...)
d1082 1
a1082 1
 void rb_raise(VALUE exception, char *fmt, ...)
d1086 1
a1086 1
 void rb_fatal(char *fmt, ...)
d1092 1
a1092 1
 void rb_bug(char *fmt, ...)
d1124 1
a1124 1
イブラリが存在する時，Qtrueを返す．
@


1.1.2.7.2.2
log
@first public release of 1.1d (pre1.2) series
@
text
@d3 1
a3 1
Rubyの拡張ライブラリの作り方を説明します．
d123 2
a124 2
とします．配列の場合には，それぞれ「RARRAY(ary)->len」，
「RARRAY(ary)->ptr」となります．
d312 1
a312 1
拡張ライブラリが必要な定数はあらかじめ定義しておいた方が良い
d379 3
a381 3
Cから関数を使って参照・更新できるのは，定数，インスタンス変
数です．大域変数は一部のものはCの大域変数としてアクセスでき
ます．ローカル変数を参照する方法は公開していません．
d391 1
a391 1
定数を参照するには以下の関数を使ってください．
d395 1
a395 1
定数を新しく定義するためには『2.1.3 定数定義』で紹介さ
d507 1
a507 1
ここまでの説明でとりあえず拡張ライブラリは作れるはずです．
d526 1
a526 1
拡張ライブラリのディレクトリの下にはMANIFESTというファイルが
d531 1
a531 1
が拡張ライブラリを含んでいるかどうか判定するために使われれて
d544 1
a544 1
拡張ライブラリ本体となるC言語のソースを書きます．C言語のソー
d551 1
a551 1
Rubyは拡張ライブラリをロードする時に「Init_モジュール名」と
d765 1
a765 1
拡張ライブラリ用のディレクトリの下に lib というディレクトリ
d778 1
a778 1
使いください．Rubyの作者は拡張ライブラリに関して一切の権利を
d784 1
a784 1
スライブラリの部分は基本的に拡張ライブラリと同じ作り方になっ
d965 1
a965 1
** 定数
d967 1
a967 1
 void rb_define_const(VALUE klass, char *name, VALUE val)
d969 1
a969 1
定数を定義する．
d1101 1
a1101 1
を使う．通常の拡張ライブラリには必要ない．
d1124 1
a1124 1
イブラリが存在する時，trueを返す．
d1135 1
a1135 1
時trueを返す．
d1139 1
a1139 1
拡張ライブラリ用のMakefileを生成する．この関数を呼ばなければ
@


