head	1.347;
access;
symbols
	v1_6_7:1.137.2.104
	v1_6_6:1.137.2.85
	v1_6_5:1.137.2.63
	v1_6_4:1.137.2.40
	v1_7_1:1.181
	v1_6_4_preview4:1.137.2.39
	v1_6_4_preview3:1.137.2.38
	v1_6_4_preview2:1.137.2.27
	v1_6_4_preview1:1.137.2.23
	v1_6_3:1.137.2.16
	ruby_m17n:1.139.0.2
	ruby_1_6:1.137.0.2
	v1_6_2:1.137
	v1_6_1:1.114
	v1_6_0:1.96
	v1_4_6:1.10.2.28
	v1_4_5:1.10.2.25
	v1_4_4:1.10.2.14
	ruby_1_4_3:1.10.2.6
	ruby1_4_3:1.10.2.5
	v1_4_3:1.10.2.5
	v1_5_0:1.22
	ruby_1_4_3_pre1:1.10.2.2
	ruby_1_4:1.10.0.2
	v1_4_2:1.6
	v1_4_1:1.5
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.31
	v1_3_6_repack:1.1.1.3.2.30
	v1_3_6:1.1.1.3.2.30
	v1_3_5:1.1.1.3.2.27
	v1_2_6repack:1.1.1.2.2.91
	v1_3_4_990625:1.1.1.3.2.26
	v1_3_4_990624:1.1.1.3.2.25
	v1_2_6:1.1.1.2.2.91
	v1_3_4_990611:1.1.1.3.2.24
	v1_3_4_990531:1.1.1.3.2.21
	v1_3_3_990518:1.1.1.3.2.19
	v1_3_3_990513:1.1.1.3.2.16
	v1_3_3_990507:1.1.1.3.2.15
	v1_2_5:1.1.1.2.2.90
	v1_2_4:1.1.1.2.2.88
	v1_3_1_990225:1.1.1.3.2.8
	v1_3_1_990224:1.1.1.3.2.7
	v1_3_1_990215:1.1.1.3.2.6
	v1_3_1_990212:1.1.1.3.2.5
	v1_3_1_990210:1.1.1.3.2.4
	v1_3_1_:1.1.1.3.2.4
	v1_3_1_990209:1.1.1.3.2.4
	v1_3_1_990205:1.1.1.3.2.3
	v1_3_1_990203:1.1.1.3.2.3
	v1_3_1_990201:1.1.1.3.2.3
	v1_3_1"_990201:1.1.1.3.2.3
	v1_3_1_990128:1.1.1.3.2.2
	v1_3_1_990127:1.1.1.3.2.2
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.86
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.86
	v1_2_1repack:1.1.1.2.2.85
	v1_2_1:1.1.1.2.2.85
	v1_2_stable:1.1.1.2.2.84
	v1_1d1:1.1.1.2.2.79.2.5
	v1_1d0:1.1.1.2.2.79.2.4
	v1_1c9_1:1.1.1.2.2.83
	v1_1c9:1.1.1.2.2.82
	v1_1c8:1.1.1.2.2.82
	v1_1c7:1.1.1.2.2.81
	v1_1c6:1.1.1.2.2.80
	v1_1d-start:1.1.1.2.2.79.2.1
	v1_1c5:1.1.1.2.2.80
	v1_1dev:1.1.1.2.2.79.0.2
	v1_1c4:1.1.1.2.2.79
	v1_1c3:1.1.1.2.2.78
	v1_1c2:1.1.1.2.2.76
	v1_1c1:1.1.1.2.2.75
	v1_1c0:1.1.1.2.2.73
	v1_1b9_31:1.1.1.2.2.72
	v1_1b9_30:1.1.1.2.2.70
	v1_1b9_28:1.1.1.2.2.67
	v1_1b9_27:1.1.1.2.2.65
	v1_1b9_26:1.1.1.2.2.64
	r1_1b9_25:1.1.1.2.2.61
	r1_1b9_24:1.1.1.2.2.60
	v1_1b9_23:1.1.1.2.2.59
	v1_1b9_22:1.1.1.2.2.58
	v1_1b9_20:1.1.1.2.2.55
	v1_1b9_18:1.1.1.2.2.52
	v1_1b9_16:1.1.1.2.2.48
	v1_1b9_15:1.1.1.2.2.46
	v1_1b9_13:1.1.1.2.2.45
	v1_1b9_12:1.1.1.2.2.45
	v1_1b9_11:1.1.1.2.2.44
	v1_1b9_08:1.1.1.2.2.37
	v1_1b9_07:1.1.1.2.2.36
	r1_1b9:1.1.1.2.2.15
	v1_1b8:1.1.1.2.2.12
	v1_1b7:1.1.1.2.2.10
	v1_1b6:1.1.1.2.2.7
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.347
date	2002.10.30.08.04.31;	author matz;	state Exp;
branches;
next	1.346;

1.346
date	2002.10.29.21.35.27;	author knu;	state Exp;
branches;
next	1.345;

1.345
date	2002.10.29.19.11.17;	author nobu;	state Exp;
branches;
next	1.344;

1.344
date	2002.10.25.18.39.29;	author knu;	state Exp;
branches;
next	1.343;

1.343
date	2002.10.23.10.17.29;	author nobu;	state Exp;
branches;
next	1.342;

1.342
date	2002.10.17.16.13.44;	author knu;	state Exp;
branches;
next	1.341;

1.341
date	2002.10.05.15.46.24;	author aamine;	state Exp;
branches;
next	1.340;

1.340
date	2002.10.04.11.32.16;	author nobu;	state Exp;
branches;
next	1.339;

1.339
date	2002.10.03.11.20.29;	author nobu;	state Exp;
branches;
next	1.338;

1.338
date	2002.09.27.09.42.24;	author nobu;	state Exp;
branches;
next	1.337;

1.337
date	2002.09.27.04.26.21;	author matz;	state Exp;
branches;
next	1.336;

1.336
date	2002.09.26.00.48.33;	author matz;	state Exp;
branches;
next	1.335;

1.335
date	2002.09.25.07.03.01;	author matz;	state Exp;
branches;
next	1.334;

1.334
date	2002.09.23.15.48.42;	author nobu;	state Exp;
branches;
next	1.333;

1.333
date	2002.09.22.12.52.18;	author nobu;	state Exp;
branches;
next	1.332;

1.332
date	2002.09.21.13.30.00;	author nobu;	state Exp;
branches;
next	1.331;

1.331
date	2002.09.17.13.52.45;	author michal;	state Exp;
branches;
next	1.330;

1.330
date	2002.09.17.12.07.36;	author nobu;	state Exp;
branches;
next	1.329;

1.329
date	2002.09.17.09.36.05;	author matz;	state Exp;
branches;
next	1.328;

1.328
date	2002.09.13.09.36.28;	author nobu;	state Exp;
branches;
next	1.327;

1.327
date	2002.09.11.15.13.10;	author nobu;	state Exp;
branches;
next	1.326;

1.326
date	2002.09.11.09.58.02;	author nobu;	state Exp;
branches;
next	1.325;

1.325
date	2002.09.10.15.44.36;	author nobu;	state Exp;
branches;
next	1.324;

1.324
date	2002.09.05.04.15.50;	author nobu;	state Exp;
branches;
next	1.323;

1.323
date	2002.08.29.09.08.15;	author matz;	state Exp;
branches;
next	1.322;

1.322
date	2002.08.28.08.05.23;	author michal;	state Exp;
branches;
next	1.321;

1.321
date	2002.08.27.08.31.05;	author matz;	state Exp;
branches;
next	1.320;

1.320
date	2002.08.24.06.32.40;	author nobu;	state Exp;
branches;
next	1.319;

1.319
date	2002.08.23.15.01.13;	author nobu;	state Exp;
branches;
next	1.318;

1.318
date	2002.08.21.15.47.54;	author michal;	state Exp;
branches;
next	1.317;

1.317
date	2002.08.21.08.30.05;	author matz;	state Exp;
branches;
next	1.316;

1.316
date	2002.08.19.03.41.00;	author nobu;	state Exp;
branches;
next	1.315;

1.315
date	2002.08.19.03.17.58;	author eban;	state Exp;
branches;
next	1.314;

1.314
date	2002.08.19.00.37.04;	author nobu;	state Exp;
branches;
next	1.313;

1.313
date	2002.08.15.22.58.45;	author nobu;	state Exp;
branches;
next	1.312;

1.312
date	2002.08.15.11.49.39;	author nobu;	state Exp;
branches;
next	1.311;

1.311
date	2002.08.12.07.39.07;	author matz;	state Exp;
branches;
next	1.310;

1.310
date	2002.08.11.00.36.38;	author nobu;	state Exp;
branches;
next	1.309;

1.309
date	2002.08.03.12.27.33;	author nobu;	state Exp;
branches;
next	1.308;

1.308
date	2002.07.31.05.18.43;	author matz;	state Exp;
branches;
next	1.307;

1.307
date	2002.07.30.00.13.56;	author aamine;	state Exp;
branches;
next	1.306;

1.306
date	2002.07.29.23.34.43;	author aamine;	state Exp;
branches;
next	1.305;

1.305
date	2002.07.26.14.12.26;	author nobu;	state Exp;
branches;
next	1.304;

1.304
date	2002.07.26.06.12.38;	author matz;	state Exp;
branches;
next	1.303;

1.303
date	2002.06.24.07.20.42;	author nobu;	state Exp;
branches;
next	1.302;

1.302
date	2002.06.13.03.55.44;	author matz;	state Exp;
branches;
next	1.301;

1.301
date	2002.06.11.07.01.13;	author matz;	state Exp;
branches;
next	1.300;

1.300
date	2002.06.04.07.34.14;	author matz;	state Exp;
branches;
next	1.299;

1.299
date	2002.05.30.06.12.27;	author matz;	state Exp;
branches;
next	1.298;

1.298
date	2002.05.29.05.20.32;	author matz;	state Exp;
branches;
next	1.297;

1.297
date	2002.05.28.18.11.07;	author michal;	state Exp;
branches;
next	1.296;

1.296
date	2002.05.28.03.20.04;	author nobu;	state Exp;
branches;
next	1.295;

1.295
date	2002.05.21.05.39.18;	author matz;	state Exp;
branches;
next	1.294;

1.294
date	2002.05.16.05.53.14;	author nobu;	state Exp;
branches;
next	1.293;

1.293
date	2002.05.14.06.22.25;	author matz;	state Exp;
branches;
next	1.292;

1.292
date	2002.05.09.17.01.38;	author nobu;	state Exp;
branches;
next	1.291;

1.291
date	2002.05.07.06.28.06;	author aamine;	state Exp;
branches;
next	1.290;

1.290
date	2002.05.07.00.17.48;	author aamine;	state Exp;
branches;
next	1.289;

1.289
date	2002.05.01.09.41.49;	author matz;	state Exp;
branches;
next	1.288;

1.288
date	2002.04.26.00.38.44;	author nobu;	state Exp;
branches;
next	1.287;

1.287
date	2002.04.25.13.55.58;	author matz;	state Exp;
branches;
next	1.286;

1.286
date	2002.04.24.05.58.34;	author nobu;	state Exp;
branches;
next	1.285;

1.285
date	2002.04.24.04.54.13;	author matz;	state Exp;
branches;
next	1.284;

1.284
date	2002.04.19.04.14.07;	author matz;	state Exp;
branches;
next	1.283;

1.283
date	2002.04.18.08.46.17;	author matz;	state Exp;
branches;
next	1.282;

1.282
date	2002.04.16.00.02.49;	author nobu;	state Exp;
branches;
next	1.281;

1.281
date	2002.04.15.07.48.45;	author matz;	state Exp;
branches;
next	1.280;

1.280
date	2002.04.11.10.02.59;	author matz;	state Exp;
branches;
next	1.279;

1.279
date	2002.04.08.07.09.45;	author nobu;	state Exp;
branches;
next	1.278;

1.278
date	2002.03.26.06.18.49;	author matz;	state Exp;
branches;
next	1.277;

1.277
date	2002.03.25.06.18.04;	author matz;	state Exp;
branches;
next	1.276;

1.276
date	2002.03.22.07.26.35;	author matz;	state Exp;
branches;
next	1.275;

1.275
date	2002.03.20.09.43.15;	author matz;	state Exp;
branches;
next	1.274;

1.274
date	2002.03.19.09.03.07;	author matz;	state Exp;
branches;
next	1.273;

1.273
date	2002.03.18.08.21.40;	author nobu;	state Exp;
branches;
next	1.272;

1.272
date	2002.03.14.06.23.43;	author matz;	state Exp;
branches;
next	1.271;

1.271
date	2002.03.11.08.02.02;	author matz;	state Exp;
branches;
next	1.270;

1.270
date	2002.03.08.07.03.03;	author matz;	state Exp;
branches;
next	1.269;

1.269
date	2002.03.07.11.19.37;	author nobu;	state Exp;
branches;
next	1.268;

1.268
date	2002.02.28.06.53.29;	author matz;	state Exp;
branches;
next	1.267;

1.267
date	2002.02.27.04.52.15;	author matz;	state Exp;
branches;
next	1.266;

1.266
date	2002.02.26.06.48.58;	author matz;	state Exp;
branches;
next	1.265;

1.265
date	2002.02.25.09.16.25;	author matz;	state Exp;
branches;
next	1.264;

1.264
date	2002.02.21.07.15.03;	author matz;	state Exp;
branches;
next	1.263;

1.263
date	2002.02.20.04.31.50;	author matz;	state Exp;
branches;
next	1.262;

1.262
date	2002.02.19.04.49.24;	author matz;	state Exp;
branches;
next	1.261;

1.261
date	2002.02.18.09.52.45;	author matz;	state Exp;
branches;
next	1.260;

1.260
date	2002.02.15.06.14.25;	author matz;	state Exp;
branches;
next	1.259;

1.259
date	2002.02.13.09.01.09;	author matz;	state Exp;
branches;
next	1.258;

1.258
date	2002.02.09.14.44.20;	author matz;	state Exp;
branches;
next	1.257;

1.257
date	2002.02.08.05.19.47;	author matz;	state Exp;
branches;
next	1.256;

1.256
date	2002.02.06.07.30.13;	author matz;	state Exp;
branches;
next	1.255;

1.255
date	2002.02.05.07.56.29;	author matz;	state Exp;
branches;
next	1.254;

1.254
date	2002.02.04.08.07.01;	author matz;	state Exp;
branches;
next	1.253;

1.253
date	2002.01.28.08.44.37;	author matz;	state Exp;
branches;
next	1.252;

1.252
date	2002.01.25.08.22.04;	author matz;	state Exp;
branches;
next	1.251;

1.251
date	2002.01.23.07.30.39;	author matz;	state Exp;
branches;
next	1.250;

1.250
date	2002.01.23.07.21.50;	author nobu;	state Exp;
branches;
next	1.249;

1.249
date	2002.01.21.07.44.05;	author matz;	state Exp;
branches;
next	1.248;

1.248
date	2002.01.19.14.21.44;	author matz;	state Exp;
branches;
next	1.247;

1.247
date	2002.01.18.14.23.06;	author matz;	state Exp;
branches;
next	1.246;

1.246
date	2002.01.17.08.04.57;	author matz;	state Exp;
branches;
next	1.245;

1.245
date	2002.01.16.09.32.51;	author matz;	state Exp;
branches;
next	1.244;

1.244
date	2002.01.16.09.27.54;	author matz;	state Exp;
branches;
next	1.243;

1.243
date	2002.01.16.09.25.54;	author matz;	state Exp;
branches;
next	1.242;

1.242
date	2002.01.11.09.18.49;	author matz;	state Exp;
branches;
next	1.241;

1.241
date	2002.01.10.20.18.39;	author nobu;	state Exp;
branches;
next	1.240;

1.240
date	2002.01.10.13.28.58;	author nobu;	state Exp;
branches;
next	1.239;

1.239
date	2002.01.08.07.02.26;	author nobu;	state Exp;
branches;
next	1.238;

1.238
date	2002.01.04.14.14.34;	author matz;	state Exp;
branches;
next	1.237;

1.237
date	2001.12.20.18.19.42;	author nobu;	state Exp;
branches;
next	1.236;

1.236
date	2001.12.19.07.48.30;	author matz;	state Exp;
branches;
next	1.235;

1.235
date	2001.12.18.08.46.56;	author matz;	state Exp;
branches;
next	1.234;

1.234
date	2001.12.17.07.52.34;	author nobu;	state Exp;
branches;
next	1.233;

1.233
date	2001.11.29.15.57.25;	author matz;	state Exp;
branches;
next	1.232;

1.232
date	2001.11.28.14.55.55;	author matz;	state Exp;
branches;
next	1.231;

1.231
date	2001.11.27.10.00.30;	author matz;	state Exp;
branches;
next	1.230;

1.230
date	2001.11.21.15.41.26;	author matz;	state Exp;
branches;
next	1.229;

1.229
date	2001.11.19.14.42.44;	author matz;	state Exp;
branches;
next	1.228;

1.228
date	2001.11.19.05.03.03;	author matz;	state Exp;
branches;
next	1.227;

1.227
date	2001.11.13.08.19.51;	author matz;	state Exp;
branches;
next	1.226;

1.226
date	2001.11.09.00.10.10;	author matz;	state Exp;
branches;
next	1.225;

1.225
date	2001.11.08.12.40.44;	author nobu;	state Exp;
branches;
next	1.224;

1.224
date	2001.11.08.09.39.45;	author matz;	state Exp;
branches;
next	1.223;

1.223
date	2001.11.08.09.21.59;	author matz;	state Exp;
branches;
next	1.222;

1.222
date	2001.11.08.06.43.08;	author matz;	state Exp;
branches;
next	1.221;

1.221
date	2001.10.31.08.00.18;	author matz;	state Exp;
branches;
next	1.220;

1.220
date	2001.10.31.06.53.22;	author matz;	state Exp;
branches;
next	1.219;

1.219
date	2001.10.30.08.43.25;	author matz;	state Exp;
branches;
next	1.218;

1.218
date	2001.10.29.06.16.00;	author usa;	state Exp;
branches;
next	1.217;

1.217
date	2001.10.29.05.07.17;	author matz;	state Exp;
branches;
next	1.216;

1.216
date	2001.10.22.16.28.51;	author nobu;	state Exp;
branches;
next	1.215;

1.215
date	2001.10.22.06.48.14;	author matz;	state Exp;
branches;
next	1.214;

1.214
date	2001.10.16.15.14.37;	author nobu;	state Exp;
branches;
next	1.213;

1.213
date	2001.10.10.08.21.12;	author matz;	state Exp;
branches;
next	1.212;

1.212
date	2001.10.09.14.56.15;	author matz;	state Exp;
branches;
next	1.211;

1.211
date	2001.10.09.09.46.42;	author matz;	state Exp;
branches;
next	1.210;

1.210
date	2001.10.09.08.15.56;	author nobu;	state Exp;
branches;
next	1.209;

1.209
date	2001.10.05.05.49.02;	author nobu;	state Exp;
branches;
next	1.208;

1.208
date	2001.10.03.07.19.10;	author matz;	state Exp;
branches;
next	1.207;

1.207
date	2001.10.02.04.31.18;	author matz;	state Exp;
branches;
next	1.206;

1.206
date	2001.09.20.12.51.58;	author nobu;	state Exp;
branches;
next	1.205;

1.205
date	2001.09.20.06.23.49;	author nobu;	state Exp;
branches;
next	1.204;

1.204
date	2001.09.19.06.54.10;	author matz;	state Exp;
branches;
next	1.203;

1.203
date	2001.09.08.14.17.09;	author matz;	state Exp;
branches;
next	1.202;

1.202
date	2001.09.03.05.37.42;	author matz;	state Exp;
branches;
next	1.201;

1.201
date	2001.08.29.06.28.44;	author matz;	state Exp;
branches;
next	1.200;

1.200
date	2001.08.23.06.02.14;	author matz;	state Exp;
branches;
next	1.199;

1.199
date	2001.08.14.08.13.26;	author matz;	state Exp;
branches;
next	1.198;

1.198
date	2001.08.06.03.05.12;	author matz;	state Exp;
branches;
next	1.197;

1.197
date	2001.08.01.06.45.13;	author usa;	state Exp;
branches;
next	1.196;

1.196
date	2001.07.27.09.12.12;	author matz;	state Exp;
branches;
next	1.195;

1.195
date	2001.07.24.09.07.33;	author matz;	state Exp;
branches;
next	1.194;

1.194
date	2001.07.18.05.55.20;	author matz;	state Exp;
branches;
next	1.193;

1.193
date	2001.07.14.15.17.18;	author matz;	state Exp;
branches;
next	1.192;

1.192
date	2001.07.03.09.37.08;	author matz;	state Exp;
branches;
next	1.191;

1.191
date	2001.07.03.05.57.16;	author shugo;	state Exp;
branches;
next	1.190;

1.190
date	2001.07.02.08.46.21;	author matz;	state Exp;
branches;
next	1.189;

1.189
date	2001.06.23.15.14.14;	author matz;	state Exp;
branches;
next	1.188;

1.188
date	2001.06.22.09.12.19;	author matz;	state Exp;
branches;
next	1.187;

1.187
date	2001.06.19.07.33.08;	author matz;	state Exp;
branches;
next	1.186;

1.186
date	2001.06.19.04.35.13;	author matz;	state Exp;
branches;
next	1.185;

1.185
date	2001.06.12.05.31.46;	author matz;	state Exp;
branches;
next	1.184;

1.184
date	2001.06.08.14.20.19;	author matz;	state Exp;
branches;
next	1.183;

1.183
date	2001.06.06.07.40.31;	author matz;	state Exp;
branches;
next	1.182;

1.182
date	2001.06.05.07.19.38;	author matz;	state Exp;
branches;
next	1.181;

1.181
date	2001.05.30.09.12.33;	author matz;	state Exp;
branches;
next	1.180;

1.180
date	2001.05.24.06.10.32;	author matz;	state Exp;
branches;
next	1.179;

1.179
date	2001.05.22.08.28.11;	author matz;	state Exp;
branches;
next	1.178;

1.178
date	2001.05.17.08.49.44;	author matz;	state Exp;
branches;
next	1.177;

1.177
date	2001.05.16.09.05.49;	author matz;	state Exp;
branches;
next	1.176;

1.176
date	2001.05.11.05.24.54;	author matz;	state Exp;
branches;
next	1.175;

1.175
date	2001.05.07.09.26.23;	author matz;	state Exp;
branches;
next	1.174;

1.174
date	2001.05.06.15.01.58;	author matz;	state Exp;
branches;
next	1.173;

1.173
date	2001.05.02.04.22.10;	author matz;	state Exp;
branches;
next	1.172;

1.172
date	2001.03.28.08.43.24;	author matz;	state Exp;
branches;
next	1.171;

1.171
date	2001.03.27.07.09.23;	author matz;	state Exp;
branches;
next	1.170;

1.170
date	2001.03.26.08.57.09;	author matz;	state Exp;
branches;
next	1.169;

1.169
date	2001.03.22.09.19.57;	author matz;	state Exp;
branches;
next	1.168;

1.168
date	2001.03.21.03.41.41;	author matz;	state Exp;
branches;
next	1.167;

1.167
date	2001.03.19.03.20.20;	author matz;	state Exp;
branches;
next	1.166;

1.166
date	2001.03.16.08.30.09;	author matz;	state Exp;
branches;
next	1.165;

1.165
date	2001.03.14.08.38.49;	author matz;	state Exp;
branches;
next	1.164;

1.164
date	2001.03.14.04.44.47;	author matz;	state Exp;
branches;
next	1.163;

1.163
date	2001.03.13.09.00.01;	author matz;	state Exp;
branches;
next	1.162;

1.162
date	2001.03.13.05.45.08;	author matz;	state Exp;
branches;
next	1.161;

1.161
date	2001.03.06.08.17.16;	author matz;	state Exp;
branches;
next	1.160;

1.160
date	2001.03.05.08.33.16;	author matz;	state Exp;
branches;
next	1.159;

1.159
date	2001.02.28.06.30.03;	author matz;	state Exp;
branches;
next	1.158;

1.158
date	2001.02.27.07.52.11;	author matz;	state Exp;
branches;
next	1.157;

1.157
date	2001.02.26.05.29.00;	author matz;	state Exp;
branches;
next	1.156;

1.156
date	2001.02.19.07.03.06;	author matz;	state Exp;
branches;
next	1.155;

1.155
date	2001.02.14.05.51.57;	author matz;	state Exp;
branches;
next	1.154;

1.154
date	2001.02.13.05.08.59;	author matz;	state Exp;
branches;
next	1.153;

1.153
date	2001.02.11.07.12.02;	author eban;	state Exp;
branches;
next	1.152;

1.152
date	2001.02.08.09.19.16;	author matz;	state Exp;
branches;
next	1.151;

1.151
date	2001.02.02.11.38.10;	author matz;	state Exp;
branches;
next	1.150;

1.150
date	2001.01.29.06.12.56;	author matz;	state Exp;
branches;
next	1.149;

1.149
date	2001.01.29.05.10.41;	author matz;	state Exp;
branches;
next	1.148;

1.148
date	2001.01.24.06.32.10;	author matz;	state Exp;
branches;
next	1.147;

1.147
date	2001.01.23.08.08.59;	author matz;	state Exp;
branches;
next	1.146;

1.146
date	2001.01.18.08.43.07;	author matz;	state Exp;
branches;
next	1.145;

1.145
date	2001.01.15.07.00.53;	author matz;	state Exp;
branches;
next	1.144;

1.144
date	2001.01.10.07.52.45;	author matz;	state Exp;
branches;
next	1.143;

1.143
date	2001.01.10.07.30.18;	author eban;	state Exp;
branches;
next	1.142;

1.142
date	2001.01.09.07.26.16;	author matz;	state Exp;
branches;
next	1.141;

1.141
date	2000.12.29.18.23.22;	author matz;	state Exp;
branches;
next	1.140;

1.140
date	2000.12.29.02.46.09;	author matz;	state Exp;
branches;
next	1.139;

1.139
date	2000.12.27.05.59.03;	author matz;	state Exp;
branches
	1.139.2.1;
next	1.138;

1.138
date	2000.12.26.08.08.50;	author matz;	state Exp;
branches;
next	1.137;

1.137
date	2000.12.25.06.28.56;	author matz;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2000.12.22.03.21.54;	author matz;	state Exp;
branches;
next	1.135;

1.135
date	2000.12.18.09.45.58;	author matz;	state Exp;
branches;
next	1.134;

1.134
date	2000.12.12.07.42.21;	author matz;	state Exp;
branches;
next	1.133;

1.133
date	2000.12.08.07.10.16;	author matz;	state Exp;
branches;
next	1.132;

1.132
date	2000.12.07.08.38.39;	author shugo;	state Exp;
branches;
next	1.131;

1.131
date	2000.12.06.09.10.07;	author eban;	state Exp;
branches;
next	1.130;

1.130
date	2000.12.05.09.36.24;	author matz;	state Exp;
branches;
next	1.129;

1.129
date	2000.11.27.09.23.17;	author matz;	state Exp;
branches;
next	1.128;

1.128
date	2000.11.21.14.26.19;	author matz;	state Exp;
branches;
next	1.127;

1.127
date	2000.11.20.07.31.38;	author matz;	state Exp;
branches;
next	1.126;

1.126
date	2000.11.17.04.41.09;	author matz;	state Exp;
branches;
next	1.125;

1.125
date	2000.11.16.07.24.10;	author matz;	state Exp;
branches;
next	1.124;

1.124
date	2000.11.08.05.29.21;	author matz;	state Exp;
branches;
next	1.123;

1.123
date	2000.10.20.16.36.49;	author matz;	state Exp;
branches;
next	1.122;

1.122
date	2000.10.17.18.13.54;	author matz;	state Exp;
branches;
next	1.121;

1.121
date	2000.10.16.09.13.15;	author matz;	state Exp;
branches;
next	1.120;

1.120
date	2000.10.14.14.44.52;	author matz;	state Exp;
branches;
next	1.119;

1.119
date	2000.10.13.09.01.53;	author matz;	state Exp;
branches;
next	1.118;

1.118
date	2000.10.11.06.29.06;	author matz;	state Exp;
branches;
next	1.117;

1.117
date	2000.10.10.07.03.15;	author matz;	state Exp;
branches;
next	1.116;

1.116
date	2000.10.05.09.57.00;	author matz;	state Exp;
branches;
next	1.115;

1.115
date	2000.10.03.08.56.46;	author matz;	state Exp;
branches;
next	1.114;

1.114
date	2000.09.27.03.43.12;	author matz;	state Exp;
branches;
next	1.113;

1.113
date	2000.09.25.17.59.13;	author matz;	state Exp;
branches;
next	1.112;

1.112
date	2000.09.25.17.51.21;	author matz;	state Exp;
branches;
next	1.111;

1.111
date	2000.09.25.10.21.58;	author eban;	state Exp;
branches;
next	1.110;

1.110
date	2000.09.25.09.14.58;	author matz;	state Exp;
branches;
next	1.109;

1.109
date	2000.09.22.18.15.41;	author matz;	state Exp;
branches;
next	1.108;

1.108
date	2000.09.21.06.37.14;	author matz;	state Exp;
branches;
next	1.107;

1.107
date	2000.09.20.09.16.26;	author matz;	state Exp;
branches;
next	1.106;

1.106
date	2000.09.18.16.28.34;	author matz;	state Exp;
branches;
next	1.105;

1.105
date	2000.09.18.08.47.05;	author matz;	state Exp;
branches;
next	1.104;

1.104
date	2000.09.15.06.00.23;	author matz;	state Exp;
branches;
next	1.103;

1.103
date	2000.09.12.06.41.23;	author matz;	state Exp;
branches;
next	1.102;

1.102
date	2000.09.12.05.37.20;	author matz;	state Exp;
branches;
next	1.101;

1.101
date	2000.09.01.08.10.49;	author matz;	state Exp;
branches;
next	1.100;

1.100
date	2000.09.01.07.25.20;	author matz;	state Exp;
branches;
next	1.99;

1.99
date	2000.09.01.03.30.57;	author matz;	state Exp;
branches;
next	1.98;

1.98
date	2000.08.31.09.08.12;	author matz;	state Exp;
branches;
next	1.97;

1.97
date	2000.08.31.08.08.39;	author matz;	state Exp;
branches;
next	1.96;

1.96
date	2000.08.31.05.29.35;	author matz;	state Exp;
branches;
next	1.95;

1.95
date	2000.08.29.07.29.44;	author matz;	state Exp;
branches;
next	1.94;

1.94
date	2000.08.29.02.52.29;	author matz;	state Exp;
branches;
next	1.93;

1.93
date	2000.08.28.09.53.25;	author matz;	state Exp;
branches;
next	1.92;

1.92
date	2000.08.25.08.25.58;	author matz;	state Exp;
branches;
next	1.91;

1.91
date	2000.08.24.06.21.28;	author matz;	state Exp;
branches;
next	1.90;

1.90
date	2000.08.15.09.04.27;	author matz;	state Exp;
branches;
next	1.89;

1.89
date	2000.08.15.06.22.38;	author matz;	state Exp;
branches;
next	1.88;

1.88
date	2000.08.10.14.23.10;	author matz;	state Exp;
branches;
next	1.87;

1.87
date	2000.08.09.11.17.25;	author matz;	state Exp;
branches;
next	1.86;

1.86
date	2000.08.09.07.34.59;	author matz;	state Exp;
branches;
next	1.85;

1.85
date	2000.08.07.05.01.47;	author matz;	state Exp;
branches;
next	1.84;

1.84
date	2000.08.03.09.50.32;	author matz;	state Exp;
branches;
next	1.83;

1.83
date	2000.08.02.09.50.36;	author matz;	state Exp;
branches;
next	1.82;

1.82
date	2000.08.02.09.22.22;	author matz;	state Exp;
branches;
next	1.81;

1.81
date	2000.08.02.04.54.10;	author matz;	state Exp;
branches;
next	1.80;

1.80
date	2000.07.27.09.49.15;	author matz;	state Exp;
branches;
next	1.79;

1.79
date	2000.07.19.08.04.46;	author matz;	state Exp;
branches;
next	1.78;

1.78
date	2000.07.18.06.00.35;	author matz;	state Exp;
branches;
next	1.77;

1.77
date	2000.07.17.09.37.55;	author matz;	state Exp;
branches;
next	1.76;

1.76
date	2000.07.15.13.36.56;	author matz;	state Exp;
branches;
next	1.75;

1.75
date	2000.07.15.00.33.11;	author matz;	state Exp;
branches;
next	1.74;

1.74
date	2000.07.14.04.34.35;	author matz;	state Exp;
branches;
next	1.73;

1.73
date	2000.07.12.06.06.45;	author matz;	state Exp;
branches;
next	1.72;

1.72
date	2000.07.10.04.49.10;	author matz;	state Exp;
branches;
next	1.71;

1.71
date	2000.07.06.07.21.06;	author matz;	state Exp;
branches;
next	1.70;

1.70
date	2000.07.04.07.04.31;	author matz;	state Exp;
branches;
next	1.69;

1.69
date	2000.07.04.04.17.08;	author matz;	state Exp;
branches;
next	1.68;

1.68
date	2000.07.03.05.46.33;	author matz;	state Exp;
branches;
next	1.67;

1.67
date	2000.07.01.06.46.33;	author matz;	state Exp;
branches;
next	1.66;

1.66
date	2000.06.26.07.27.37;	author matz;	state Exp;
branches;
next	1.65;

1.65
date	2000.06.23.07.01.23;	author matz;	state Exp;
branches;
next	1.64;

1.64
date	2000.06.22.08.29.41;	author matz;	state Exp;
branches;
next	1.63;

1.63
date	2000.06.22.04.39.07;	author eban;	state Exp;
branches;
next	1.62;

1.62
date	2000.06.19.08.38.04;	author matz;	state Exp;
branches;
next	1.61;

1.61
date	2000.06.16.12.41.06;	author eban;	state Exp;
branches;
next	1.60;

1.60
date	2000.06.16.07.44.01;	author matz;	state Exp;
branches;
next	1.59;

1.59
date	2000.06.14.08.08.47;	author matz;	state Exp;
branches;
next	1.58;

1.58
date	2000.06.09.07.55.12;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2000.06.05.08.46.48;	author matz;	state Exp;
branches;
next	1.56;

1.56
date	2000.06.04.15.32.18;	author eban;	state Exp;
branches;
next	1.55;

1.55
date	2000.05.31.16.40.04;	author matz;	state Exp;
branches;
next	1.54;

1.54
date	2000.05.31.03.10.00;	author matz;	state Exp;
branches;
next	1.53;

1.53
date	2000.05.30.04.23.54;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2000.05.29.02.10.17;	author eban;	state Exp;
branches;
next	1.51;

1.51
date	2000.05.25.05.54.59;	author matz;	state Exp;
branches;
next	1.50;

1.50
date	2000.05.24.07.42.34;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2000.05.24.04.33.55;	author matz;	state Exp;
branches;
next	1.48;

1.48
date	2000.05.18.04.32.02;	author matz;	state Exp;
branches;
next	1.47;

1.47
date	2000.05.17.06.33.45;	author matz;	state Exp;
branches;
next	1.46;

1.46
date	2000.05.17.04.38.09;	author matz;	state Exp;
branches;
next	1.45;

1.45
date	2000.05.16.02.46.51;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2000.05.12.09.07.34;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2000.05.10.02.58.33;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2000.05.09.04.52.53;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2000.05.01.09.41.14;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2000.04.17.15.39.37;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2000.04.10.05.44.06;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2000.03.23.08.37.24;	author matz;	state Exp;
branches;
next	1.37;

1.37
date	2000.03.17.08.58.10;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2000.03.15.09.05.36;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2000.03.13.07.18.33;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2000.03.08.06.23.13;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2000.03.07.08.37.29;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2000.03.06.04.15.29;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2000.02.25.03.51.17;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.23.05.23.04;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.18.06.59.28;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.17.07.11.07;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.08.08.48.45;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.02.01.03.12.00;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.17.08.37.39;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.01.05.04.36.59;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	99.12.14.06.49.40;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	99.12.07.09.23.23;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	99.12.06.09.03.50;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	99.12.02.06.58.47;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	99.11.29.06.32.57;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	99.11.26.09.07.22;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	99.11.17.07.30.29;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	99.11.10.06.47.07;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	99.11.08.03.57.00;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	99.11.04.08.39.36;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	99.10.16.10.33.05;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	99.10.15.08.52.15;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	99.10.13.09.31.56;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	99.10.12.04.53.32;	author matz;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.10.04.04.51.04;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.09.22.04.30.09;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.09.18.04.48.49;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.09.16.16.11.24;	author matz;	state Exp;
branches;
next	1.5;

1.5
date	99.09.16.09.40.31;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.09.01.09.48.00;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.08.24.08.21.52;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.04;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.09;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.23;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.10;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.01.27.08.08.35;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.01.07.34.53;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.02.09.06.08.19;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.02.12.11.17.01;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.02.15.07.31.49;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.02.24.04.31.18;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.02.25.06.39.05;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.03.24.08.52.25;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.04.09.17.57.37;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.04.12.09.59.27;	author matz;	state Exp;
branches;
next	1.1.1.3.2.12;

1.1.1.3.2.12
date	99.04.16.06.03.29;	author matz;	state Exp;
branches;
next	1.1.1.3.2.13;

1.1.1.3.2.13
date	99.04.16.07.04.45;	author matz;	state Exp;
branches;
next	1.1.1.3.2.14;

1.1.1.3.2.14
date	99.04.20.08.21.35;	author matz;	state Exp;
branches;
next	1.1.1.3.2.15;

1.1.1.3.2.15
date	99.04.22.07.28.45;	author matz;	state Exp;
branches;
next	1.1.1.3.2.16;

1.1.1.3.2.16
date	99.05.13.10.00.59;	author matz;	state Exp;
branches;
next	1.1.1.3.2.17;

1.1.1.3.2.17
date	99.05.14.08.56.03;	author matz;	state Exp;
branches;
next	1.1.1.3.2.18;

1.1.1.3.2.18
date	99.05.17.09.53.57;	author matz;	state Exp;
branches;
next	1.1.1.3.2.19;

1.1.1.3.2.19
date	99.05.18.00.34.35;	author matz;	state Exp;
branches;
next	1.1.1.3.2.20;

1.1.1.3.2.20
date	99.05.25.08.25.52;	author matz;	state Exp;
branches;
next	1.1.1.3.2.21;

1.1.1.3.2.21
date	99.05.31.09.13.04;	author matz;	state Exp;
branches;
next	1.1.1.3.2.22;

1.1.1.3.2.22
date	99.06.01.06.58.59;	author matz;	state Exp;
branches;
next	1.1.1.3.2.23;

1.1.1.3.2.23
date	99.06.09.09.21.06;	author matz;	state Exp;
branches;
next	1.1.1.3.2.24;

1.1.1.3.2.24
date	99.06.11.06.29.46;	author matz;	state Exp;
branches;
next	1.1.1.3.2.25;

1.1.1.3.2.25
date	99.06.24.04.23.47;	author matz;	state Exp;
branches;
next	1.1.1.3.2.26;

1.1.1.3.2.26
date	99.06.25.09.02.34;	author matz;	state Exp;
branches;
next	1.1.1.3.2.27;

1.1.1.3.2.27
date	99.07.15.07.59.38;	author matz;	state Exp;
branches;
next	1.1.1.3.2.28;

1.1.1.3.2.28
date	99.07.22.10.37.09;	author matz;	state Exp;
branches;
next	1.1.1.3.2.29;

1.1.1.3.2.29
date	99.07.22.10.58.07;	author matz;	state Exp;
branches;
next	1.1.1.3.2.30;

1.1.1.3.2.30
date	99.07.28.09.26.32;	author matz;	state Exp;
branches;
next	1.1.1.3.2.31;

1.1.1.3.2.31
date	99.08.06.06.48.10;	author matz;	state Exp;
branches;
next	1.1.1.3.2.32;

1.1.1.3.2.32
date	99.08.11.07.23.55;	author matz;	state Exp;
branches;
next	1.1.1.3.2.33;

1.1.1.3.2.33
date	99.08.12.08.33.04;	author matz;	state Exp;
branches;
next	1.1.1.3.2.34;

1.1.1.3.2.34
date	99.08.13.05.17.32;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.16.12.35.44;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.01.19.05.08.20;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.01.22.03.34.26;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.01.22.08.12.08;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.01.22.08.22.26;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.01.22.08.32.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.01.23.04.38.31;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.01.27.05.23.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.02.03.10.02.55;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.02.09.10.56.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.02.16.06.05.45;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.02.18.01.56.34;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.02.23.05.36.36;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.02.25.06.52.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.02.26.08.27.08;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.03.03.02.39.32;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.03.03.10.16.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.03.05.06.37.43;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.03.06.10.07.52;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.03.09.07.56.54;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.03.11.07.32.54;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.03.12.01.15.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.03.13.09.04.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.03.16.06.37.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	98.03.23.09.48.00;	author matz;	state Exp;
branches;
next	1.1.1.2.2.26;

1.1.1.2.2.26
date	98.03.24.06.21.54;	author matz;	state Exp;
branches;
next	1.1.1.2.2.27;

1.1.1.2.2.27
date	98.03.25.09.36.57;	author matz;	state Exp;
branches;
next	1.1.1.2.2.28;

1.1.1.2.2.28
date	98.03.26.09.07.26;	author matz;	state Exp;
branches;
next	1.1.1.2.2.29;

1.1.1.2.2.29
date	98.03.26.09.09.37;	author matz;	state Exp;
branches;
next	1.1.1.2.2.30;

1.1.1.2.2.30
date	98.03.26.10.22.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.31;

1.1.1.2.2.31
date	98.03.27.06.09.17;	author matz;	state Exp;
branches;
next	1.1.1.2.2.32;

1.1.1.2.2.32
date	98.03.28.10.57.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.33;

1.1.1.2.2.33
date	98.03.30.09.41.13;	author matz;	state Exp;
branches;
next	1.1.1.2.2.34;

1.1.1.2.2.34
date	98.03.31.04.52.08;	author matz;	state Exp;
branches;
next	1.1.1.2.2.35;

1.1.1.2.2.35
date	98.04.02.10.03.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.36;

1.1.1.2.2.36
date	98.04.07.08.34.07;	author matz;	state Exp;
branches;
next	1.1.1.2.2.37;

1.1.1.2.2.37
date	98.04.07.08.41.23;	author matz;	state Exp;
branches;
next	1.1.1.2.2.38;

1.1.1.2.2.38
date	98.04.08.08.12.35;	author matz;	state Exp;
branches;
next	1.1.1.2.2.39;

1.1.1.2.2.39
date	98.04.09.09.30.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.40;

1.1.1.2.2.40
date	98.04.13.06.06.11;	author matz;	state Exp;
branches;
next	1.1.1.2.2.41;

1.1.1.2.2.41
date	98.04.14.04.55.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.42;

1.1.1.2.2.42
date	98.04.16.07.42.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.43;

1.1.1.2.2.43
date	98.04.16.10.20.17;	author matz;	state Exp;
branches;
next	1.1.1.2.2.44;

1.1.1.2.2.44
date	98.04.16.10.39.20;	author matz;	state Exp;
branches;
next	1.1.1.2.2.45;

1.1.1.2.2.45
date	98.04.20.05.55.35;	author matz;	state Exp;
branches;
next	1.1.1.2.2.46;

1.1.1.2.2.46
date	98.04.24.09.33.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.47;

1.1.1.2.2.47
date	98.04.27.10.03.50;	author matz;	state Exp;
branches;
next	1.1.1.2.2.48;

1.1.1.2.2.48
date	98.04.28.06.16.08;	author matz;	state Exp;
branches;
next	1.1.1.2.2.49;

1.1.1.2.2.49
date	98.04.30.07.41.09;	author matz;	state Exp;
branches;
next	1.1.1.2.2.50;

1.1.1.2.2.50
date	98.05.01.08.56.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.51;

1.1.1.2.2.51
date	98.05.06.03.08.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.52;

1.1.1.2.2.52
date	98.05.12.08.38.37;	author matz;	state Exp;
branches;
next	1.1.1.2.2.53;

1.1.1.2.2.53
date	98.05.13.05.57.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.54;

1.1.1.2.2.54
date	98.05.13.07.26.11;	author matz;	state Exp;
branches;
next	1.1.1.2.2.55;

1.1.1.2.2.55
date	98.05.14.04.10.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.56;

1.1.1.2.2.56
date	98.05.18.04.55.59;	author matz;	state Exp;
branches;
next	1.1.1.2.2.57;

1.1.1.2.2.57
date	98.05.18.05.57.38;	author matz;	state Exp;
branches;
next	1.1.1.2.2.58;

1.1.1.2.2.58
date	98.05.19.07.39.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.59;

1.1.1.2.2.59
date	98.05.25.04.57.33;	author matz;	state Exp;
branches;
next	1.1.1.2.2.60;

1.1.1.2.2.60
date	98.06.02.10.05.18;	author matz;	state Exp;
branches;
next	1.1.1.2.2.61;

1.1.1.2.2.61
date	98.06.11.10.02.57;	author matz;	state Exp;
branches;
next	1.1.1.2.2.62;

1.1.1.2.2.62
date	98.06.12.09.35.00;	author matz;	state Exp;
branches;
next	1.1.1.2.2.63;

1.1.1.2.2.63
date	98.06.16.04.23.26;	author matz;	state Exp;
branches;
next	1.1.1.2.2.64;

1.1.1.2.2.64
date	98.06.18.07.46.44;	author matz;	state Exp;
branches;
next	1.1.1.2.2.65;

1.1.1.2.2.65
date	98.06.19.09.32.02;	author matz;	state Exp;
branches;
next	1.1.1.2.2.66;

1.1.1.2.2.66
date	98.06.24.04.37.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.67;

1.1.1.2.2.67
date	98.06.26.09.44.15;	author matz;	state Exp;
branches;
next	1.1.1.2.2.68;

1.1.1.2.2.68
date	98.06.30.01.40.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.69;

1.1.1.2.2.69
date	98.07.03.07.06.24;	author matz;	state Exp;
branches;
next	1.1.1.2.2.70;

1.1.1.2.2.70
date	98.07.09.08.40.12;	author matz;	state Exp;
branches;
next	1.1.1.2.2.71;

1.1.1.2.2.71
date	98.07.13.04.37.27;	author matz;	state Exp;
branches;
next	1.1.1.2.2.72;

1.1.1.2.2.72
date	98.07.15.06.12.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.73;

1.1.1.2.2.73
date	98.07.17.05.12.36;	author matz;	state Exp;
branches;
next	1.1.1.2.2.74;

1.1.1.2.2.74
date	98.07.22.03.00.38;	author matz;	state Exp;
branches;
next	1.1.1.2.2.75;

1.1.1.2.2.75
date	98.07.24.04.41.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.76;

1.1.1.2.2.76
date	98.08.10.05.41.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.77;

1.1.1.2.2.77
date	98.08.14.03.56.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.78;

1.1.1.2.2.78
date	98.08.27.03.55.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.79;

1.1.1.2.2.79
date	98.09.03.07.43.28;	author matz;	state Exp;
branches
	1.1.1.2.2.79.2.1;
next	1.1.1.2.2.80;

1.1.1.2.2.80
date	98.09.08.09.17.32;	author matz;	state Exp;
branches;
next	1.1.1.2.2.81;

1.1.1.2.2.81
date	98.11.09.09.11.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.82;

1.1.1.2.2.82
date	98.11.17.09.12.30;	author matz;	state Exp;
branches;
next	1.1.1.2.2.83;

1.1.1.2.2.83
date	98.12.14.09.00.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.84;

1.1.1.2.2.84
date	98.12.25.04.35.38;	author matz;	state Exp;
branches;
next	1.1.1.2.2.85;

1.1.1.2.2.85
date	99.01.11.07.55.25;	author matz;	state Exp;
branches;
next	1.1.1.2.2.86;

1.1.1.2.2.86
date	99.01.18.09.08.49;	author matz;	state Exp;
branches;
next	1.1.1.2.2.87;

1.1.1.2.2.87
date	99.02.09.03.29.21;	author matz;	state Exp;
branches;
next	1.1.1.2.2.88;

1.1.1.2.2.88
date	99.04.08.10.14.31;	author matz;	state Exp;
branches;
next	1.1.1.2.2.89;

1.1.1.2.2.89
date	99.04.09.18.04.05;	author matz;	state Exp;
branches;
next	1.1.1.2.2.90;

1.1.1.2.2.90
date	99.04.13.05.54.22;	author matz;	state Exp;
branches;
next	1.1.1.2.2.91;

1.1.1.2.2.91
date	99.06.21.06.30.58;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.79.2.1
date	98.09.08.07.08.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.79.2.2;

1.1.1.2.2.79.2.2
date	98.10.06.03.28.06;	author matz;	state Exp;
branches;
next	1.1.1.2.2.79.2.3;

1.1.1.2.2.79.2.3
date	98.11.25.03.31.10;	author matz;	state Exp;
branches;
next	1.1.1.2.2.79.2.4;

1.1.1.2.2.79.2.4
date	98.12.16.07.30.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.79.2.5;

1.1.1.2.2.79.2.5
date	98.12.22.09.01.48;	author matz;	state Exp;
branches;
next	;

1.10.2.1
date	99.10.13.09.32.03;	author matz;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	99.11.09.03.57.26;	author matz;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	99.11.29.06.30.59;	author matz;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	99.12.02.07.49.25;	author matz;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	99.12.06.09.03.27;	author matz;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	99.12.07.16.47.15;	author matz;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2000.01.05.04.41.01;	author matz;	state Exp;
branches;
next	1.10.2.8;

1.10.2.8
date	2000.01.17.08.23.54;	author matz;	state Exp;
branches;
next	1.10.2.9;

1.10.2.9
date	2000.01.24.03.46.06;	author matz;	state Exp;
branches;
next	1.10.2.10;

1.10.2.10
date	2000.02.08.08.53.48;	author matz;	state Exp;
branches;
next	1.10.2.11;

1.10.2.11
date	2000.02.17.08.28.52;	author matz;	state Exp;
branches;
next	1.10.2.12;

1.10.2.12
date	2000.03.02.03.51.38;	author matz;	state Exp;
branches;
next	1.10.2.13;

1.10.2.13
date	2000.03.08.06.25.07;	author matz;	state Exp;
branches;
next	1.10.2.14;

1.10.2.14
date	2000.03.13.09.15.36;	author matz;	state Exp;
branches;
next	1.10.2.15;

1.10.2.15
date	2000.03.23.04.14.12;	author matz;	state Exp;
branches;
next	1.10.2.16;

1.10.2.16
date	2000.04.10.05.48.28;	author matz;	state Exp;
branches;
next	1.10.2.17;

1.10.2.17
date	2000.05.01.09.42.22;	author matz;	state Exp;
branches;
next	1.10.2.18;

1.10.2.18
date	2000.05.08.03.21.21;	author matz;	state Exp;
branches;
next	1.10.2.19;

1.10.2.19
date	2000.05.09.04.50.07;	author matz;	state Exp;
branches;
next	1.10.2.20;

1.10.2.20
date	2000.05.12.09.06.06;	author matz;	state Exp;
branches;
next	1.10.2.21;

1.10.2.21
date	2000.05.30.04.21.00;	author matz;	state Exp;
branches;
next	1.10.2.22;

1.10.2.22
date	2000.05.31.08.09.59;	author matz;	state Exp;
branches;
next	1.10.2.23;

1.10.2.23
date	2000.05.31.16.40.59;	author matz;	state Exp;
branches;
next	1.10.2.24;

1.10.2.24
date	2000.06.20.06.08.33;	author matz;	state Exp;
branches;
next	1.10.2.25;

1.10.2.25
date	2000.06.23.07.05.49;	author matz;	state Exp;
branches;
next	1.10.2.26;

1.10.2.26
date	2000.07.10.08.01.26;	author matz;	state Exp;
branches;
next	1.10.2.27;

1.10.2.27
date	2000.07.14.04.33.18;	author matz;	state Exp;
branches;
next	1.10.2.28;

1.10.2.28
date	2000.07.24.07.15.59;	author matz;	state Exp;
branches;
next	1.10.2.29;

1.10.2.29
date	2000.07.26.09.41.07;	author matz;	state Exp;
branches;
next	1.10.2.30;

1.10.2.30
date	2000.08.07.05.04.46;	author matz;	state Exp;
branches;
next	1.10.2.31;

1.10.2.31
date	2000.08.15.08.57.42;	author matz;	state Exp;
branches;
next	1.10.2.32;

1.10.2.32
date	2000.08.24.06.49.07;	author matz;	state Exp;
branches;
next	1.10.2.33;

1.10.2.33
date	2000.09.12.05.32.57;	author matz;	state Exp;
branches;
next	;

1.137.2.1
date	2000.12.29.03.48.35;	author matz;	state Exp;
branches;
next	1.137.2.2;

1.137.2.2
date	2001.01.09.07.29.03;	author matz;	state Exp;
branches;
next	1.137.2.3;

1.137.2.3
date	2001.02.02.11.39.51;	author matz;	state Exp;
branches;
next	1.137.2.4;

1.137.2.4
date	2001.02.08.09.17.57;	author matz;	state Exp;
branches;
next	1.137.2.5;

1.137.2.5
date	2001.02.11.07.11.47;	author eban;	state Exp;
branches;
next	1.137.2.6;

1.137.2.6
date	2001.02.19.07.41.24;	author matz;	state Exp;
branches;
next	1.137.2.7;

1.137.2.7
date	2001.02.26.04.07.48;	author matz;	state Exp;
branches;
next	1.137.2.8;

1.137.2.8
date	2001.02.27.08.04.23;	author matz;	state Exp;
branches;
next	1.137.2.9;

1.137.2.9
date	2001.02.28.06.31.20;	author matz;	state Exp;
branches;
next	1.137.2.10;

1.137.2.10
date	2001.03.06.08.17.54;	author matz;	state Exp;
branches;
next	1.137.2.11;

1.137.2.11
date	2001.03.13.05.48.32;	author matz;	state Exp;
branches;
next	1.137.2.12;

1.137.2.12
date	2001.03.14.04.45.44;	author matz;	state Exp;
branches;
next	1.137.2.13;

1.137.2.13
date	2001.03.14.08.39.13;	author matz;	state Exp;
branches;
next	1.137.2.14;

1.137.2.14
date	2001.03.16.08.28.12;	author matz;	state Exp;
branches;
next	1.137.2.15;

1.137.2.15
date	2001.03.19.07.56.47;	author matz;	state Exp;
branches;
next	1.137.2.16;

1.137.2.16
date	2001.03.19.09.00.30;	author matz;	state Exp;
branches;
next	1.137.2.17;

1.137.2.17
date	2001.03.26.08.56.03;	author matz;	state Exp;
branches;
next	1.137.2.18;

1.137.2.18
date	2001.03.27.07.10.56;	author matz;	state Exp;
branches;
next	1.137.2.19;

1.137.2.19
date	2001.03.28.08.44.36;	author matz;	state Exp;
branches;
next	1.137.2.20;

1.137.2.20
date	2001.04.03.05.43.49;	author matz;	state Exp;
branches;
next	1.137.2.21;

1.137.2.21
date	2001.04.06.05.42.39;	author matz;	state Exp;
branches;
next	1.137.2.22;

1.137.2.22
date	2001.04.09.04.56.38;	author matz;	state Exp;
branches;
next	1.137.2.23;

1.137.2.23
date	2001.04.10.06.09.00;	author matz;	state Exp;
branches;
next	1.137.2.24;

1.137.2.24
date	2001.04.16.06.54.36;	author matz;	state Exp;
branches;
next	1.137.2.25;

1.137.2.25
date	2001.04.16.08.38.58;	author matz;	state Exp;
branches;
next	1.137.2.26;

1.137.2.26
date	2001.04.17.08.26.13;	author matz;	state Exp;
branches;
next	1.137.2.27;

1.137.2.27
date	2001.04.17.15.35.04;	author matz;	state Exp;
branches;
next	1.137.2.28;

1.137.2.28
date	2001.04.19.09.16.06;	author matz;	state Exp;
branches;
next	1.137.2.29;

1.137.2.29
date	2001.04.24.06.44.12;	author matz;	state Exp;
branches;
next	1.137.2.30;

1.137.2.30
date	2001.05.01.08.45.10;	author matz;	state Exp;
branches;
next	1.137.2.31;

1.137.2.31
date	2001.05.02.04.16.27;	author matz;	state Exp;
branches;
next	1.137.2.32;

1.137.2.32
date	2001.05.07.06.18.44;	author matz;	state Exp;
branches;
next	1.137.2.33;

1.137.2.33
date	2001.05.07.08.39.26;	author matz;	state Exp;
branches;
next	1.137.2.34;

1.137.2.34
date	2001.05.07.09.24.34;	author matz;	state Exp;
branches;
next	1.137.2.35;

1.137.2.35
date	2001.05.08.08.29.51;	author matz;	state Exp;
branches;
next	1.137.2.36;

1.137.2.36
date	2001.05.15.08.49.21;	author matz;	state Exp;
branches;
next	1.137.2.37;

1.137.2.37
date	2001.05.17.08.49.00;	author matz;	state Exp;
branches;
next	1.137.2.38;

1.137.2.38
date	2001.05.24.05.26.20;	author matz;	state Exp;
branches;
next	1.137.2.39;

1.137.2.39
date	2001.05.25.15.01.06;	author matz;	state Exp;
branches;
next	1.137.2.40;

1.137.2.40
date	2001.05.29.08.59.36;	author matz;	state Exp;
branches;
next	1.137.2.41;

1.137.2.41
date	2001.06.05.06.40.49;	author matz;	state Exp;
branches;
next	1.137.2.42;

1.137.2.42
date	2001.06.06.07.39.38;	author matz;	state Exp;
branches;
next	1.137.2.43;

1.137.2.43
date	2001.06.11.06.26.16;	author matz;	state Exp;
branches;
next	1.137.2.44;

1.137.2.44
date	2001.06.19.04.36.34;	author matz;	state Exp;
branches;
next	1.137.2.45;

1.137.2.45
date	2001.06.29.08.32.51;	author matz;	state Exp;
branches;
next	1.137.2.46;

1.137.2.46
date	2001.07.02.08.43.26;	author matz;	state Exp;
branches;
next	1.137.2.47;

1.137.2.47
date	2001.07.06.06.36.58;	author matz;	state Exp;
branches;
next	1.137.2.48;

1.137.2.48
date	2001.07.06.08.54.18;	author matz;	state Exp;
branches;
next	1.137.2.49;

1.137.2.49
date	2001.07.13.05.50.03;	author matz;	state Exp;
branches;
next	1.137.2.50;

1.137.2.50
date	2001.07.16.04.01.42;	author matz;	state Exp;
branches;
next	1.137.2.51;

1.137.2.51
date	2001.07.19.07.59.47;	author matz;	state Exp;
branches;
next	1.137.2.52;

1.137.2.52
date	2001.07.19.08.27.53;	author matz;	state Exp;
branches;
next	1.137.2.53;

1.137.2.53
date	2001.07.24.09.02.48;	author matz;	state Exp;
branches;
next	1.137.2.54;

1.137.2.54
date	2001.07.27.08.54.48;	author matz;	state Exp;
branches;
next	1.137.2.55;

1.137.2.55
date	2001.07.27.09.08.54;	author matz;	state Exp;
branches;
next	1.137.2.56;

1.137.2.56
date	2001.08.06.03.10.23;	author matz;	state Exp;
branches;
next	1.137.2.57;

1.137.2.57
date	2001.08.06.08.03.30;	author matz;	state Exp;
branches;
next	1.137.2.58;

1.137.2.58
date	2001.08.23.06.00.30;	author matz;	state Exp;
branches;
next	1.137.2.59;

1.137.2.59
date	2001.09.03.05.29.17;	author matz;	state Exp;
branches;
next	1.137.2.60;

1.137.2.60
date	2001.09.03.05.40.56;	author eban;	state Exp;
branches;
next	1.137.2.61;

1.137.2.61
date	2001.09.06.07.47.46;	author matz;	state Exp;
branches;
next	1.137.2.62;

1.137.2.62
date	2001.09.08.14.05.50;	author matz;	state Exp;
branches;
next	1.137.2.63;

1.137.2.63
date	2001.09.18.03.47.02;	author matz;	state Exp;
branches;
next	1.137.2.64;

1.137.2.64
date	2001.10.02.04.25.51;	author matz;	state Exp;
branches;
next	1.137.2.65;

1.137.2.65
date	2001.10.02.09.36.23;	author matz;	state Exp;
branches;
next	1.137.2.66;

1.137.2.66
date	2001.10.09.08.19.46;	author nobu;	state Exp;
branches;
next	1.137.2.67;

1.137.2.67
date	2001.10.09.15.03.19;	author matz;	state Exp;
branches;
next	1.137.2.68;

1.137.2.68
date	2001.10.16.15.17.09;	author nobu;	state Exp;
branches;
next	1.137.2.69;

1.137.2.69
date	2001.10.29.05.04.40;	author matz;	state Exp;
branches;
next	1.137.2.70;

1.137.2.70
date	2001.10.30.08.42.20;	author matz;	state Exp;
branches;
next	1.137.2.71;

1.137.2.71
date	2001.10.31.06.52.24;	author matz;	state Exp;
branches;
next	1.137.2.72;

1.137.2.72
date	2001.10.31.07.59.54;	author matz;	state Exp;
branches;
next	1.137.2.73;

1.137.2.73
date	2001.11.07.09.01.30;	author matz;	state Exp;
branches;
next	1.137.2.74;

1.137.2.74
date	2001.11.08.12.42.39;	author nobu;	state Exp;
branches;
next	1.137.2.75;

1.137.2.75
date	2001.11.13.08.22.26;	author matz;	state Exp;
branches;
next	1.137.2.76;

1.137.2.76
date	2001.11.19.04.58.03;	author matz;	state Exp;
branches;
next	1.137.2.77;

1.137.2.77
date	2001.11.19.07.48.23;	author eban;	state Exp;
branches;
next	1.137.2.78;

1.137.2.78
date	2001.11.19.08.15.25;	author eban;	state Exp;
branches;
next	1.137.2.79;

1.137.2.79
date	2001.11.21.15.35.57;	author matz;	state Exp;
branches;
next	1.137.2.80;

1.137.2.80
date	2001.11.28.14.52.57;	author matz;	state Exp;
branches;
next	1.137.2.81;

1.137.2.81
date	2001.12.03.10.06.38;	author matz;	state Exp;
branches;
next	1.137.2.82;

1.137.2.82
date	2001.12.17.08.13.16;	author nobu;	state Exp;
branches;
next	1.137.2.83;

1.137.2.83
date	2001.12.18.08.40.30;	author matz;	state Exp;
branches;
next	1.137.2.84;

1.137.2.84
date	2001.12.19.07.45.28;	author matz;	state Exp;
branches;
next	1.137.2.85;

1.137.2.85
date	2001.12.20.18.18.19;	author nobu;	state Exp;
branches;
next	1.137.2.86;

1.137.2.86
date	2002.01.08.06.59.52;	author nobu;	state Exp;
branches;
next	1.137.2.87;

1.137.2.87
date	2002.01.10.13.30.17;	author nobu;	state Exp;
branches;
next	1.137.2.88;

1.137.2.88
date	2002.01.10.23.38.56;	author nobu;	state Exp;
branches;
next	1.137.2.89;

1.137.2.89
date	2002.01.16.09.22.38;	author matz;	state Exp;
branches;
next	1.137.2.90;

1.137.2.90
date	2002.01.21.07.43.39;	author matz;	state Exp;
branches;
next	1.137.2.91;

1.137.2.91
date	2002.01.23.07.24.26;	author nobu;	state Exp;
branches;
next	1.137.2.92;

1.137.2.92
date	2002.01.25.08.23.31;	author matz;	state Exp;
branches;
next	1.137.2.93;

1.137.2.93
date	2002.01.28.08.42.35;	author matz;	state Exp;
branches;
next	1.137.2.94;

1.137.2.94
date	2002.01.28.09.20.22;	author eban;	state Exp;
branches;
next	1.137.2.95;

1.137.2.95
date	2002.02.01.06.01.49;	author matz;	state Exp;
branches;
next	1.137.2.96;

1.137.2.96
date	2002.02.08.05.20.32;	author matz;	state Exp;
branches;
next	1.137.2.97;

1.137.2.97
date	2002.02.09.14.47.51;	author matz;	state Exp;
branches;
next	1.137.2.98;

1.137.2.98
date	2002.02.13.09.02.14;	author matz;	state Exp;
branches;
next	1.137.2.99;

1.137.2.99
date	2002.02.14.08.14.25;	author matz;	state Exp;
branches;
next	1.137.2.100;

1.137.2.100
date	2002.02.18.09.53.25;	author matz;	state Exp;
branches;
next	1.137.2.101;

1.137.2.101
date	2002.02.19.04.48.04;	author matz;	state Exp;
branches;
next	1.137.2.102;

1.137.2.102
date	2002.02.20.04.28.50;	author matz;	state Exp;
branches;
next	1.137.2.103;

1.137.2.103
date	2002.02.21.07.14.11;	author matz;	state Exp;
branches;
next	1.137.2.104;

1.137.2.104
date	2002.02.27.04.50.29;	author matz;	state Exp;
branches;
next	1.137.2.105;

1.137.2.105
date	2002.03.07.11.19.27;	author nobu;	state Exp;
branches;
next	1.137.2.106;

1.137.2.106
date	2002.03.08.06.59.51;	author matz;	state Exp;
branches;
next	1.137.2.107;

1.137.2.107
date	2002.03.12.09.27.25;	author matz;	state Exp;
branches;
next	1.137.2.108;

1.137.2.108
date	2002.03.20.09.42.29;	author matz;	state Exp;
branches;
next	1.137.2.109;

1.137.2.109
date	2002.03.20.13.10.03;	author nobu;	state Exp;
branches;
next	1.137.2.110;

1.137.2.110
date	2002.03.25.06.15.59;	author matz;	state Exp;
branches;
next	1.137.2.111;

1.137.2.111
date	2002.05.01.09.37.57;	author matz;	state Exp;
branches;
next	1.137.2.112;

1.137.2.112
date	2002.05.04.12.04.51;	author knu;	state Exp;
branches;
next	1.137.2.113;

1.137.2.113
date	2002.05.07.00.20.49;	author aamine;	state Exp;
branches;
next	1.137.2.114;

1.137.2.114
date	2002.05.07.06.24.52;	author aamine;	state Exp;
branches;
next	1.137.2.115;

1.137.2.115
date	2002.05.14.06.08.43;	author matz;	state Exp;
branches;
next	1.137.2.116;

1.137.2.116
date	2002.05.16.07.15.15;	author nobu;	state Exp;
branches;
next	1.137.2.117;

1.137.2.117
date	2002.05.21.05.41.00;	author matz;	state Exp;
branches;
next	1.137.2.118;

1.137.2.118
date	2002.05.28.03.19.54;	author nobu;	state Exp;
branches;
next	1.137.2.119;

1.137.2.119
date	2002.05.29.05.22.01;	author matz;	state Exp;
branches;
next	1.137.2.120;

1.137.2.120
date	2002.06.11.06.58.36;	author matz;	state Exp;
branches;
next	1.137.2.121;

1.137.2.121
date	2002.07.11.15.51.49;	author nobu;	state Exp;
branches;
next	1.137.2.122;

1.137.2.122
date	2002.07.31.05.17.27;	author matz;	state Exp;
branches;
next	1.137.2.123;

1.137.2.123
date	2002.08.12.07.40.31;	author matz;	state Exp;
branches;
next	1.137.2.124;

1.137.2.124
date	2002.08.19.00.37.16;	author nobu;	state Exp;
branches;
next	1.137.2.125;

1.137.2.125
date	2002.08.19.03.18.33;	author eban;	state Exp;
branches;
next	1.137.2.126;

1.137.2.126
date	2002.08.19.03.40.50;	author nobu;	state Exp;
branches;
next	1.137.2.127;

1.137.2.127
date	2002.08.21.08.31.24;	author matz;	state Exp;
branches;
next	1.137.2.128;

1.137.2.128
date	2002.09.05.04.12.39;	author nobu;	state Exp;
branches;
next	1.137.2.129;

1.137.2.129
date	2002.09.11.15.25.34;	author nobu;	state Exp;
branches;
next	1.137.2.130;

1.137.2.130
date	2002.09.25.07.07.36;	author matz;	state Exp;
branches;
next	1.137.2.131;

1.137.2.131
date	2002.10.05.21.07.24;	author aamine;	state Exp;
branches;
next	1.137.2.132;

1.137.2.132
date	2002.10.10.07.01.10;	author nobu;	state Exp;
branches;
next	1.137.2.133;

1.137.2.133
date	2002.10.17.07.25.36;	author matz;	state Exp;
branches;
next	1.137.2.134;

1.137.2.134
date	2002.10.17.16.27.15;	author knu;	state Exp;
branches;
next	1.137.2.135;

1.137.2.135
date	2002.10.23.08.19.23;	author matz;	state Exp;
branches;
next	1.137.2.136;

1.137.2.136
date	2002.10.25.19.37.48;	author knu;	state Exp;
branches;
next	1.137.2.137;

1.137.2.137
date	2002.10.26.15.57.21;	author knu;	state Exp;
branches;
next	;

1.139.2.1
date	2001.01.12.04.35.59;	author matz;	state Exp;
branches;
next	1.139.2.2;

1.139.2.2
date	2002.07.09.05.26.48;	author matz;	state Exp;
branches;
next	;


desc
@@


1.347
log
@* eval.c (rb_mod_public_method_defined, etc.): new methods:
  public_method_defined?, private_method_defined?,
  protected_method_defined?

* object.c (rb_obj_public_methods): new method
  Object#public_methods.

* class.c (ins_methods_i): Object#methods should list both public
  and protected methods.

* class.c (rb_class_public_instance_methods): new method
  Module#public_instance_methods.
@
text
@/**********************************************************************

  eval.c -

  $Author: knu $
  $Date: 2002/10/29 21:35:27 $
  created at: Thu Jun 10 14:22:17 JST 1993

  Copyright (C) 1993-2002 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#include "ruby.h"
#include "node.h"
#include "env.h"
#include "util.h"
#include "rubysig.h"

#include <stdio.h>
#include <setjmp.h>
#include "st.h"
#include "dln.h"

#ifdef __APPLE__
#include <crt_externs.h>
#endif

/* Make alloca work the best possible way.  */
#ifdef __GNUC__
# ifndef atarist
#  ifndef alloca
#   define alloca __builtin_alloca
#  endif
# endif /* atarist */
#else
# ifdef HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifdef _AIX
 #pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
void *alloca ();
#   endif
#  endif /* AIX */
# endif /* HAVE_ALLOCA_H */
#endif /* __GNUC__ */

#ifdef HAVE_STDARG_PROTOTYPES
#include <stdarg.h>
#define va_init_list(a,b) va_start(a,b)
#else
#include <varargs.h>
#define va_init_list(a,b) va_start(a)
#endif

#ifndef HAVE_STRING_H
char *strrchr _((const char*,const char));
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef __BEOS__
#include <net/socket.h>
#endif

#ifdef __MACOS__
#include "macruby_private.h"
#endif

#ifndef setjmp
#ifdef HAVE__SETJMP
#define setjmp(env) _setjmp(env)
#define longjmp(env,val) _longjmp(env,val)
#endif
#endif

#include <sys/types.h>
#include <signal.h>
#include <errno.h>

#if defined(__VMS)
#pragma nostandard
#endif

#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif

#include <sys/stat.h>

VALUE rb_cProc;
static VALUE rb_cBinding;
static VALUE proc_invoke _((VALUE,VALUE,int,VALUE));
static VALUE rb_f_binding _((VALUE));
static void rb_f_END _((void));
static VALUE rb_f_block_given_p _((void));
static VALUE block_pass _((VALUE,NODE*));
static VALUE rb_cMethod;
static VALUE method_call _((int, VALUE*, VALUE));
static VALUE rb_cUnboundMethod;
static VALUE umethod_bind _((VALUE, VALUE));
static VALUE rb_mod_define_method _((int, VALUE*, VALUE));

static int scope_vmode;
#define SCOPE_PUBLIC    0
#define SCOPE_PRIVATE   1
#define SCOPE_PROTECTED 2
#define SCOPE_MODFUNC   5
#define SCOPE_MASK      7
#define SCOPE_SET(f)  (scope_vmode=(f))
#define SCOPE_TEST(f) (scope_vmode&(f))

static NODE* ruby_last_node;
NODE* ruby_current_node;
int ruby_safe_level = 0;
/* safe-level:
   0 - strings from streams/environment/ARGV are tainted (default)
   1 - no dangerous operation by tainted value
   2 - process/file operations prohibited
   3 - all genetated objects are tainted
   4 - no global (non-tainted) variable modification/no direct output
*/

static VALUE safe_getter _((void));
static void safe_setter _((VALUE val));

void
rb_secure(level)
    int level;
{
    if (level <= ruby_safe_level) {
	rb_raise(rb_eSecurityError, "Insecure operation `%s' at level %d",
		 rb_id2name(ruby_frame->last_func), ruby_safe_level);
    }
}

void
rb_check_safe_str(x)
    VALUE x;
{
    if (ruby_safe_level > 0 && OBJ_TAINTED(x)){
	if (ruby_frame->last_func) {
	    rb_raise(rb_eSecurityError, "Insecure operation - %s",
		     rb_id2name(ruby_frame->last_func));
	}
	else {
	    rb_raise(rb_eSecurityError, "Insecure operation: -r");
	}
    }
    rb_secure(4);
    if (TYPE(x)!= T_STRING) {
	rb_raise(rb_eTypeError, "wrong argument type %s (expected String)",
		 rb_class2name(CLASS_OF(x)));
    }
}

NORETURN(static void print_undef _((VALUE, ID)));
static void
print_undef(klass, id)
    VALUE klass;
    ID id;
{
    rb_name_error(id, "undefined method `%s' for %s `%s'",
		  rb_id2name(id), 
		  (TYPE(klass) == T_MODULE) ? "module" : "class",
		  rb_class2name(klass));
}

static ID removed, singleton_removed, undefined, singleton_undefined;

#define CACHE_SIZE 0x800
#define CACHE_MASK 0x7ff
#define EXPR1(c,m) ((((c)>>3)^(m))&CACHE_MASK)

struct cache_entry {		/* method hash table. */
    ID mid;			/* method's id */
    ID mid0;			/* method's original id */
    VALUE klass;		/* receiver's class */
    VALUE origin;		/* where method defined  */
    NODE *method;
    int noex;
};

static struct cache_entry cache[CACHE_SIZE];

void
rb_clear_cache()
{
   struct cache_entry *ent, *end;

    ent = cache; end = ent + CACHE_SIZE;
    while (ent < end) {
	ent->mid = 0;
	ent++;
    }
}

static void
rb_clear_cache_by_id(id)
    ID id;
{
    struct cache_entry *ent, *end;

    ent = cache; end = ent + CACHE_SIZE;
    while (ent < end) {
	if (ent->mid == id) {
	    ent->mid = 0;
	}
	ent++;
    }
}

static void
rb_clear_cache_by_class(klass)
    VALUE klass;
{
    struct cache_entry *ent, *end;

    ent = cache; end = ent + CACHE_SIZE;
    while (ent < end) {
	if (ent->origin == klass) {
	    ent->mid = 0;
	}
	ent++;
    }
}

void
rb_add_method(klass, mid, node, noex)
    VALUE klass;
    ID mid;
    NODE *node;
    int noex;
{
    NODE *body;

    if (NIL_P(klass)) klass = rb_cObject;
    if (ruby_safe_level >= 4 && (klass == rb_cObject || !OBJ_TAINTED(klass))) {
	rb_raise(rb_eSecurityError, "Insecure: can't define method");
    }
    if (OBJ_FROZEN(klass)) rb_error_frozen("class/module");
    rb_clear_cache_by_id(mid);
    body = NEW_METHOD(node, noex);
    st_insert(RCLASS(klass)->m_tbl, mid, body);
}

static NODE*
search_method(klass, id, origin)
    VALUE klass, *origin;
    ID id;
{
    NODE *body;

    if (!klass) return 0;
    while (!st_lookup(RCLASS(klass)->m_tbl, id, &body)) {
	klass = RCLASS(klass)->super;
	if (!klass) return 0;
    }

    if (origin) *origin = klass;
    return body;
}

static NODE*
rb_get_method_body(klassp, idp, noexp)
    VALUE *klassp;
    ID *idp;
    int *noexp;
{
    ID id = *idp;
    VALUE klass = *klassp;
    VALUE origin;
    NODE * volatile body;
    struct cache_entry *ent;

    if ((body = search_method(klass, id, &origin)) == 0 || !body->nd_body) {
	/* store empty info in cache */
	ent = cache + EXPR1(klass, id);
	ent->klass  = klass;
	ent->origin = klass;
	ent->mid = ent->mid0 = id;
	ent->noex   = 0;
	ent->method = 0;
	
	return 0;
    }

    /* store in cache */
    ent = cache + EXPR1(klass, id);
    ent->klass  = klass;
    ent->noex   = body->nd_noex;
    body = body->nd_body;
    if (nd_type(body) == NODE_FBODY) {
	ent->mid = id;
	*klassp = body->nd_orig;
	ent->origin = body->nd_orig;
	*idp = ent->mid0 = body->nd_mid;
	body = ent->method = body->nd_head;
    }
    else {
	*klassp = origin;
	ent->origin = origin;
	ent->mid = ent->mid0 = id;
	ent->method = body;
    }

    if (noexp) *noexp = ent->noex;
    return body;
}

static ID init, alloc, eqq, each, aref, aset, match, missing;
static ID added, singleton_added;
static ID __id__, __send__;

static void
remove_method(klass, mid)
    VALUE klass;
    ID mid;
{
    NODE *body;

    if (klass == rb_cObject) {
	rb_secure(4);
    }
    if (ruby_safe_level >= 4 && !OBJ_TAINTED(klass)) {
	rb_raise(rb_eSecurityError, "Insecure: can't remove method");
    }
    if (OBJ_FROZEN(klass)) rb_error_frozen("class/module");
    if (mid == __id__ || mid == __send__ || mid == init) {
	rb_warn("removing `%s' may cause serious problem", rb_id2name(mid));
    }
    if (mid == alloc) {
	if (klass == rb_cClass ||
	    (FL_TEST(klass, FL_SINGLETON) &&
	     rb_obj_is_kind_of(rb_iv_get(klass, "__attached__"), rb_cClass))) {
	    rb_name_error(mid, "removing `%s'", rb_id2name(mid));
	}
    }
    if (!st_delete(RCLASS(klass)->m_tbl, &mid, &body) || !body->nd_body) {
	rb_name_error(mid, "method `%s' not defined in %s",
		      rb_id2name(mid), rb_class2name(klass));
    }
    rb_clear_cache_by_id(mid);
    if (FL_TEST(klass, FL_SINGLETON)) {
	rb_funcall(rb_iv_get(klass, "__attached__"), singleton_removed, 1, ID2SYM(mid));
    }
    else {
	rb_funcall(klass, removed, 1, ID2SYM(mid));
    }
}

void
rb_remove_method(klass, name)
    VALUE klass;
    const char *name;
{
    remove_method(klass, rb_intern(name));
}

static VALUE
rb_mod_remove_method(mod, name)
    VALUE mod, name;
{
    remove_method(mod, rb_to_id(name));
    return mod;
}

void
rb_disable_super(klass, name)
    VALUE klass;
    const char *name;
{
    VALUE origin;
    NODE *body;
    ID mid = rb_intern(name);

    body = search_method(klass, mid, &origin);
    if (!body || !body->nd_body) {
	print_undef(klass, mid);
    }
    if (origin == klass) {
	body->nd_noex |= NOEX_UNDEF;
    }
    else {
	rb_add_method(klass, mid, 0, NOEX_UNDEF);
    }
}

void
rb_enable_super(klass, name)
    VALUE klass;
    const char *name;
{
    VALUE origin;
    NODE *body;
    ID mid = rb_intern(name);

    body = search_method(klass, mid, &origin);
    if (!body) {
	print_undef(klass, mid);
    }
    if (!body->nd_body) {
	remove_method(klass, mid);
    }
    else {
	body->nd_noex &= ~NOEX_UNDEF;
    }
}

static void
rb_export_method(klass, name, noex)
    VALUE klass;
    ID name;
    ID noex;
{
    NODE *body;
    VALUE origin;

    if (klass == rb_cObject) {
	rb_secure(4);
    }
    body = search_method(klass, name, &origin);
    if (!body && TYPE(klass) == T_MODULE) {
	body = search_method(rb_cObject, name, &origin);
    }
    if (!body) {
	print_undef(klass, name);
    }
    if (body->nd_noex != noex) {
	if (klass == origin) {
	    body->nd_noex = noex;
	}
	else {
	    rb_add_method(klass, name, NEW_ZSUPER(), noex);
	}
    }
}

int
rb_method_boundp(klass, id, ex)
    VALUE klass;
    ID id;
    int ex;
{
    struct cache_entry *ent;
    int noex;

    /* is it in the method cache? */
    ent = cache + EXPR1(klass, id);
    if (ent->mid == id && ent->klass == klass) {
	if (ex && (ent->noex & NOEX_PRIVATE))
	    return Qfalse;
	if (!ent->method) return Qfalse;
	return Qtrue;
    }
    if (rb_get_method_body(&klass, &id, &noex)) {
	if (ex && (noex & NOEX_PRIVATE))
	    return Qfalse;
	return Qtrue;
    }
    return Qfalse;
}

void
rb_attr(klass, id, read, write, ex)
    VALUE klass;
    ID id;
    int read, write, ex;
{
    const char *name;
    char *buf;
    ID attriv;
    int noex;

    if (!ex) noex = NOEX_PUBLIC;
    else {
	if (SCOPE_TEST(SCOPE_PRIVATE)) {
	    noex = NOEX_PRIVATE;
	    rb_warning((scope_vmode == SCOPE_MODFUNC) ?
		       "attribute accessor as module_function" :
		       "private attribute?");
	}
	else if (SCOPE_TEST(SCOPE_PROTECTED)) {
	    noex = NOEX_PROTECTED;
	}
	else {
	    noex = NOEX_PUBLIC;
	}
    }

    name = rb_id2name(id);
    if (!name) {
	rb_raise(rb_eArgError, "argument needs to be symbol or string");
    }
    buf = ALLOCA_N(char,strlen(name)+2);
    sprintf(buf, "@@%s", name);
    attriv = rb_intern(buf);
    if (read) {
	rb_add_method(klass, id, NEW_IVAR(attriv), noex);
	rb_funcall(klass, added, 1, ID2SYM(id));
    }
    if (write) {
	sprintf(buf, "%s=", name);
	id = rb_intern(buf);
	rb_add_method(klass, id, NEW_ATTRSET(attriv), noex);
	rb_funcall(klass, added, 1, ID2SYM(id));
    }
}

extern int ruby_in_compile;

VALUE ruby_errinfo = Qnil;
extern NODE *ruby_eval_tree_begin;
extern NODE *ruby_eval_tree;
extern int ruby_nerrs;

static VALUE rb_eLocalJumpError;
static VALUE rb_eSysStackError;

extern VALUE ruby_top_self;

struct FRAME *ruby_frame;
struct SCOPE *ruby_scope;
static struct FRAME *top_frame;
static struct SCOPE *top_scope;

#define PUSH_FRAME() do {		\
    struct FRAME _frame;		\
    _frame.prev = ruby_frame;		\
    _frame.tmp  = 0;			\
    _frame.node = ruby_current_node;	\
    _frame.iter = ruby_iter->iter;	\
    _frame.cbase = ruby_frame->cbase;	\
    _frame.argc = 0;			\
    _frame.argv = 0;			\
    _frame.flags = FRAME_ALLOCA;	\
    ruby_frame = &_frame

#define POP_FRAME()  			\
    ruby_current_node = _frame.node;	\
    ruby_frame = _frame.prev;		\
} while (0)

struct BLOCKTAG {
    struct RBasic super;
    long dst;
    long flags;
};

struct BLOCK {
    NODE *var;
    NODE *body;
    VALUE self;
    struct FRAME frame;
    struct SCOPE *scope;
    struct BLOCKTAG *tag;
    VALUE klass;
    int iter;
    int vmode;
    int flags;
    struct RVarmap *dyna_vars;
    VALUE orig_thread;
    VALUE wrapper;
    struct BLOCK *prev;
};

#define BLOCK_D_SCOPE 1
#define BLOCK_DYNAMIC 2
#define BLOCK_ORPHAN  4

static struct BLOCK *ruby_block;

static struct BLOCKTAG*
new_blktag()
{
    NEWOBJ(blktag, struct BLOCKTAG);
    OBJSETUP(blktag, 0, T_BLKTAG);
    blktag->dst = 0;
    blktag->flags = 0;
    return blktag;
}

#define PUSH_BLOCK(v,b) do {		\
    struct BLOCK _block;		\
    _block.tag = new_blktag();		\
    _block.var = v;			\
    _block.body = b;			\
    _block.self = self;			\
    _block.frame = *ruby_frame;		\
    _block.klass = ruby_class;		\
    _block.frame.node = ruby_current_node;\
    _block.scope = ruby_scope;		\
    _block.prev = ruby_block;		\
    _block.iter = ruby_iter->iter;	\
    _block.vmode = scope_vmode;		\
    _block.flags = BLOCK_D_SCOPE;	\
    _block.dyna_vars = ruby_dyna_vars;	\
    _block.wrapper = ruby_wrapper;	\
    ruby_block = &_block

#define POP_BLOCK() 			\
   if (_block.tag->flags & (BLOCK_DYNAMIC)) \
       _block.tag->flags |= BLOCK_ORPHAN; \
   else	if (!(_block.scope->flags & SCOPE_DONT_RECYCLE)) \
       rb_gc_force_recycle((VALUE)_block.tag); \
   ruby_block = _block.prev; 		\
} while (0)

struct RVarmap *ruby_dyna_vars;
#define PUSH_VARS() do { \
    struct RVarmap * volatile _old; \
    _old = ruby_dyna_vars; \
    ruby_dyna_vars = 0

#define POP_VARS() \
   if (_old && (ruby_scope->flags & SCOPE_DONT_RECYCLE)) {\
       if (RBASIC(_old)->flags) /* unless it's already recycled */ \
           FL_SET(_old, DVAR_DONT_RECYCLE); \
    }\
    ruby_dyna_vars = _old; \
} while (0)

#define DVAR_DONT_RECYCLE FL_USER2

static struct RVarmap*
new_dvar(id, value, prev)
    ID id;
    VALUE value;
    struct RVarmap *prev;
{
    NEWOBJ(vars, struct RVarmap);
    OBJSETUP(vars, 0, T_VARMAP);
    vars->id = id;
    vars->val = value;
    vars->next = prev;

    return vars;
}

VALUE
rb_dvar_defined(id)
    ID id;
{
    struct RVarmap *vars = ruby_dyna_vars;

    while (vars) {
	if (vars->id == id) return Qtrue;
	vars = vars->next;
    }
    return Qfalse;
}

VALUE
rb_dvar_curr(id)
    ID id;
{
    struct RVarmap *vars = ruby_dyna_vars;

    while (vars) {
	if (vars->id == 0) break;
	if (vars->id == id) return Qtrue;
	vars = vars->next;
    }
    return Qfalse;
}

VALUE
rb_dvar_ref(id)
    ID id;
{
    struct RVarmap *vars = ruby_dyna_vars;

    while (vars) {
	if (vars->id == id) {
	    return vars->val;
	}
	vars = vars->next;
    }
    return Qnil;
}

void
rb_dvar_push(id, value)
    ID id;
    VALUE value;
{
    ruby_dyna_vars = new_dvar(id, value, ruby_dyna_vars);
}

static void
dvar_asgn_internal(id, value, curr)
    ID id;
    VALUE value;
    int curr;
{
    int n = 0;
    struct RVarmap *vars = ruby_dyna_vars;

    while (vars) {
	if (curr && vars->id == 0) {
	    /* first null is a dvar header */
	    n++;
	    if (n == 2) break;
	}
	if (vars->id == id) {
	    vars->val = value;
	    return;
	}
	vars = vars->next;
    }
    if (!ruby_dyna_vars) {
	ruby_dyna_vars = new_dvar(id, value, 0);
    }
    else {
	vars = new_dvar(id, value, ruby_dyna_vars->next);
	ruby_dyna_vars->next = vars;
    }
}

static inline void
dvar_asgn(id, value)
    ID id;
    VALUE value;
{
    dvar_asgn_internal(id, value, 0);
}

static inline void
dvar_asgn_curr(id, value)
    ID id;
    VALUE value;
{
    dvar_asgn_internal(id, value, 1);
}

VALUE *
rb_svar(cnt)
    int cnt;
{
    struct RVarmap *vars = ruby_dyna_vars;
    ID id;

    if (!ruby_scope->local_tbl) return NULL;
    if (cnt >= ruby_scope->local_tbl[0]) return NULL;
    id = ruby_scope->local_tbl[cnt+1];
    while (vars) {
	if (vars->id == id) return &vars->val;
	vars = vars->next;
    }
    if (ruby_scope->local_vars == 0) return NULL;
    return &ruby_scope->local_vars[cnt];
}

struct iter {
    int iter;
    struct iter *prev;
};
static struct iter *ruby_iter;

#define ITER_NOT 0
#define ITER_PRE 1
#define ITER_CUR 2

#define PUSH_ITER(i) do {		\
    struct iter _iter;			\
    _iter.prev = ruby_iter;		\
    _iter.iter = (i);			\
    ruby_iter = &_iter

#define POP_ITER()			\
    ruby_iter = _iter.prev;		\
} while (0)

struct tag {
    jmp_buf buf;
    struct FRAME *frame;
    struct iter *iter;
    ID tag;
    VALUE retval;
    struct SCOPE *scope;
    int dst;
    struct tag *prev;
};
static struct tag *prot_tag;

#define PUSH_TAG(ptag) do {		\
    struct tag _tag;			\
    _tag.retval = Qnil;			\
    _tag.frame = ruby_frame;		\
    _tag.iter = ruby_iter;		\
    _tag.prev = prot_tag;		\
    _tag.scope = ruby_scope;		\
    _tag.tag = ptag;			\
    _tag.dst = 0;			\
    prot_tag = &_tag

#define PROT_NONE   0
#define PROT_FUNC   -1
#define PROT_THREAD -2

#define EXEC_TAG()    setjmp(prot_tag->buf)

#define JUMP_TAG(st) do {		\
    ruby_frame = prot_tag->frame;	\
    ruby_iter = prot_tag->iter;		\
    longjmp(prot_tag->buf,(st));	\
} while (0)

#define POP_TAG()			\
    if (_tag.prev)			\
        _tag.prev->retval = _tag.retval;\
    prot_tag = _tag.prev;		\
} while (0)

#define POP_TMPTAG()			\
    prot_tag = _tag.prev;		\
} while (0)

#define TAG_RETURN	0x1
#define TAG_BREAK	0x2
#define TAG_NEXT	0x3
#define TAG_RETRY	0x4
#define TAG_REDO	0x5
#define TAG_RAISE	0x6
#define TAG_THROW	0x7
#define TAG_FATAL	0x8
#define TAG_MASK	0xf

VALUE ruby_class;
static VALUE ruby_wrapper;	/* security wrapper */

#define PUSH_CLASS() do {		\
    VALUE _class = ruby_class

#define POP_CLASS() ruby_class = _class; \
} while (0)

static NODE *ruby_cref = 0;
static NODE *top_cref;
#define PUSH_CREF(c) ruby_cref = rb_node_newnode(NODE_CREF,(c),0,ruby_cref)
#define POP_CREF() ruby_cref = ruby_cref->nd_next

#define PUSH_SCOPE() do {		\
    volatile int _vmode = scope_vmode;	\
    struct SCOPE * volatile _old;	\
    NEWOBJ(_scope, struct SCOPE);	\
    OBJSETUP(_scope, 0, T_SCOPE);	\
    _scope->local_tbl = 0;		\
    _scope->local_vars = 0;		\
    _scope->flags = 0;			\
    _old = ruby_scope;			\
    ruby_scope = _scope;		\
    scope_vmode = SCOPE_PUBLIC

typedef struct thread * rb_thread_t;
static rb_thread_t curr_thread = 0;
static rb_thread_t main_thread;
static void scope_dup _((struct SCOPE *));

#define POP_SCOPE() 			\
    if (ruby_scope->flags & SCOPE_DONT_RECYCLE) {\
       if (_old) scope_dup(_old);	\
    }					\
    if (!(ruby_scope->flags & SCOPE_MALLOC)) {\
	ruby_scope->local_vars = 0;	\
	ruby_scope->local_tbl  = 0;	\
	if (!(ruby_scope->flags & SCOPE_DONT_RECYCLE) && \
            ruby_scope != top_scope) {	\
	    rb_gc_force_recycle((VALUE)ruby_scope);\
        }				\
    }					\
    ruby_scope->flags |= SCOPE_NOSTACK;	\
    ruby_scope = _old;			\
    scope_vmode = _vmode;		\
} while (0)

static VALUE rb_eval _((VALUE,NODE*));
static VALUE eval _((VALUE,VALUE,VALUE,char*,int));
static NODE *compile _((VALUE, char*, int));

static VALUE rb_yield_0 _((VALUE, VALUE, VALUE, int));
static VALUE rb_call _((VALUE,VALUE,ID,int,const VALUE*,int));
static VALUE module_setup _((VALUE,NODE*));

static VALUE massign _((VALUE,NODE*,VALUE,int));
static void assign _((VALUE,NODE*,VALUE,int));

static VALUE trace_func = 0;
static int tracing = 0;
static void call_trace_func _((char*,NODE*,VALUE,ID,VALUE));
#define ENABLE_TRACE() (tracing &= ~2)
#define DISABLE_TRACE() (tracing |= 2)

#define SET_CURRENT_SOURCE() (ruby_sourcefile = ruby_current_node->nd_file, \
			      ruby_sourceline = nd_line(ruby_current_node))

void
ruby_set_current_source()
{
    if (ruby_current_node) {
	SET_CURRENT_SOURCE();
    }
}

static void
error_pos()
{
    ruby_set_current_source();
    if (ruby_sourcefile) {
	if (ruby_frame->last_func) {
	    fprintf(stderr, "%s:%d:in `%s'", ruby_sourcefile, ruby_sourceline,
		    rb_id2name(ruby_frame->last_func));
	}
	else if (ruby_sourceline == 0) {
	    fprintf(stderr, "%s", ruby_sourcefile);
	}
	else {
	    fprintf(stderr, "%s:%d", ruby_sourcefile, ruby_sourceline);
	}
    }
}

static VALUE
get_backtrace(info)
    VALUE info;
{
    if (NIL_P(info)) return Qnil;
    return rb_funcall(info, rb_intern("backtrace"), 0);
}

static void
set_backtrace(info, bt)
    VALUE info, bt;
{
    rb_funcall(info, rb_intern("set_backtrace"), 1, bt);
}

static void
error_print()
{
    VALUE errat = Qnil;		/* OK */
    volatile VALUE eclass;
    char *einfo;
    long elen;

    if (NIL_P(ruby_errinfo)) return;

    PUSH_TAG(PROT_NONE);
    if (EXEC_TAG() == 0) {
	errat = get_backtrace(ruby_errinfo);
    }
    else {
	errat = Qnil;
    }
    POP_TAG();
    if (NIL_P(errat)){
	ruby_set_current_source();
	if (ruby_sourcefile)
	    fprintf(stderr, "%s:%d", ruby_sourcefile, ruby_sourceline);
	else
	    fprintf(stderr, "%d", ruby_sourceline);
    }
    else if (RARRAY(errat)->len == 0) {
	error_pos();
    }
    else {
	VALUE mesg = RARRAY(errat)->ptr[0];

	if (NIL_P(mesg)) error_pos();
	else {
	    fwrite(RSTRING(mesg)->ptr, 1, RSTRING(mesg)->len, stderr);
	}
    }

    eclass = CLASS_OF(ruby_errinfo);
    PUSH_TAG(PROT_NONE);
    if (EXEC_TAG() == 0) {
	VALUE e = rb_obj_as_string(ruby_errinfo);
	einfo = RSTRING(e)->ptr;
	elen = RSTRING(e)->len;
    }
    else {
	einfo = "";
	elen = 0;
    }
    POP_TAG();
    if (eclass == rb_eRuntimeError && elen == 0) {
	fprintf(stderr, ": unhandled exception\n");
    }
    else {
	VALUE epath;

	epath = rb_class_path(eclass);
	if (elen == 0) {
	    fprintf(stderr, ": ");
	    fwrite(RSTRING(epath)->ptr, 1, RSTRING(epath)->len, stderr);
	    putc('\n', stderr);
	}
	else {
	    char *tail  = 0;
	    long len = elen;

	    if (RSTRING(epath)->ptr[0] == '#') epath = 0;
	    if (tail = strchr(einfo, '\n')) {
		len = tail - einfo;
		tail++;		/* skip newline */
	    }
	    fprintf(stderr, ": ");
	    fwrite(einfo, 1, len, stderr);
	    if (epath) {
		fprintf(stderr, " (");
		fwrite(RSTRING(epath)->ptr, 1, RSTRING(epath)->len, stderr);
		fprintf(stderr, ")\n");
	    }
	    if (tail) {
		fwrite(tail, 1, elen-len-1, stderr);
		putc('\n', stderr);
	    }
	}
    }

    if (!NIL_P(errat)) {
	long i;
	struct RArray *ep = RARRAY(errat);

#define TRACE_MAX (TRACE_HEAD+TRACE_TAIL+5)
#define TRACE_HEAD 8
#define TRACE_TAIL 5

	ep = RARRAY(errat);
	for (i=1; i<ep->len; i++) {
	    if (TYPE(ep->ptr[i]) == T_STRING) {
		fprintf(stderr, "\tfrom %s\n", RSTRING(ep->ptr[i])->ptr);
	    }
	    if (i == TRACE_HEAD && ep->len > TRACE_MAX) {
		fprintf(stderr, "\t ... %ld levels...\n",
			ep->len - TRACE_HEAD - TRACE_TAIL);
		i = ep->len - TRACE_TAIL;
	    }
	}
    }
    fflush(stderr);
}

#if defined(__APPLE__)
#define environ (*_NSGetEnviron())
#elif !defined(NT) && !defined(__MACOS__)
extern char **environ;
#endif
char **rb_origenviron;

void rb_call_inits _((void));
void Init_stack _((void*));
void Init_heap _((void));
void Init_ext _((void));

void
ruby_init()
{
    static int initialized = 0;
    static struct FRAME frame;
    static struct iter iter;
    int state;

    if (initialized)
	return;
    initialized = 1;

    ruby_frame = top_frame = &frame;
    ruby_iter = &iter;

#ifdef __MACOS__
    rb_origenviron = 0;
#else
    rb_origenviron = environ;
#endif

    Init_stack((void*)&state);
    Init_heap();
    PUSH_SCOPE();
    ruby_scope->local_vars = 0;
    ruby_scope->local_tbl  = 0;
    top_scope = ruby_scope;
    /* default visibility is private at toplevel */
    SCOPE_SET(SCOPE_PRIVATE);

    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	rb_call_inits();
	ruby_class = rb_cObject;
	ruby_frame->self = ruby_top_self;
	top_cref = rb_node_newnode(NODE_CREF,rb_cObject,0,0);
	ruby_cref = top_cref;
	ruby_frame->cbase = (VALUE)ruby_cref;
	rb_define_global_const("TOPLEVEL_BINDING", rb_f_binding(ruby_top_self));
#ifdef __MACOS__
	_macruby_init();
#endif
	ruby_prog_init();
    }
    POP_TAG();
    if (state) error_print();
    POP_SCOPE();
    ruby_scope = top_scope;
}

static VALUE
eval_node(self, node)
    VALUE self;
    NODE *node;
{
    NODE *beg_tree = ruby_eval_tree_begin;

    ruby_eval_tree_begin = 0;
    if (beg_tree) {
	rb_eval(self, beg_tree);
    }

    if (!node) return Qnil;
    return rb_eval(self, node);
}

int ruby_in_eval;

static void rb_thread_cleanup _((void));
static void rb_thread_wait_other_threads _((void));

static int
error_handle(ex)
    int ex;
{
    switch (ex & TAG_MASK) {
      case 0:
	ex = 0;
	break;

      case TAG_RETURN:
	error_pos();
	fprintf(stderr, ": unexpected return\n");
	ex = 1;
	break;
      case TAG_NEXT:
	error_pos();
	fprintf(stderr, ": unexpected next\n");
	ex = 1;
	break;
      case TAG_BREAK:
	error_pos();
	fprintf(stderr, ": unexpected break\n");
	ex = 1;
	break;
      case TAG_REDO:
	error_pos();
	fprintf(stderr, ": unexpected redo\n");
	ex = 1;
	break;
      case TAG_RETRY:
	error_pos();
	fprintf(stderr, ": retry outside of rescue clause\n");
	ex = 1;
	break;
      case TAG_THROW:
	if (prot_tag && prot_tag->frame && prot_tag->frame->node) {
	    NODE *tag = prot_tag->frame->node;
	    fprintf(stderr, "%s:%d: uncaught throw\n",
		    tag->nd_file, nd_line(tag));
	}
	else {
	    error_pos();
	    fprintf(stderr, ": unexpected throw\n");
	}
	ex = 1;
	break;
      case TAG_RAISE:
      case TAG_FATAL:
	if (rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
	    VALUE st = rb_iv_get(ruby_errinfo, "status");
	    ex = NIL_P(st) ? 1 : NUM2INT(st);
	}
	else {
	    error_print();
	    ex = 1;
	}
	break;
      default:
	rb_bug("Unknown longjmp status %d", ex);
	break;
    }
    return ex;
}

void
ruby_options(argc, argv)
    int argc;
    char **argv;
{
    int state;

    Init_stack((void*)&state);
    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	ruby_process_options(argc, argv);
    }
    if (state) {
	trace_func = 0;
	tracing = 0;
	exit(error_handle(state));
    }
    POP_TAG();
}

void rb_exec_end_proc _((void));

void
ruby_finalize()
{
    int state;

    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	rb_trap_exit();
	rb_exec_end_proc();
	rb_gc_call_finalizer_at_exit();
    }
    POP_TAG();
}

int
ruby_cleanup(ex)
    int ex;
{
    int state;

    PUSH_TAG(PROT_NONE);
    PUSH_ITER(ITER_NOT);
    if ((state = EXEC_TAG()) == 0) {
	rb_thread_cleanup();
	rb_thread_wait_other_threads();
    }
    else if (ex == 0) {
	ex = state;
    }   
    POP_ITER();

    trace_func = 0;
    tracing = 0;
    ex = error_handle(ex);
    POP_TAG();
    ruby_finalize();
    return ex;
}

int
ruby_exec()
{
    int state;
    volatile NODE *tmp;

    Init_stack((void*)&tmp);
    PUSH_TAG(PROT_NONE);
    PUSH_ITER(ITER_NOT);
    /* default visibility is private at toplevel */
    SCOPE_SET(SCOPE_PRIVATE);
    if ((state = EXEC_TAG()) == 0) {
	eval_node(ruby_top_self, ruby_eval_tree);
    }
    POP_ITER();
    POP_TAG();
    return state;
}

void
ruby_stop(ex)
    int ex;
{
    exit(ruby_cleanup(ex));
}

void
ruby_run()
{
    int state;
    static int ex;
    if (ruby_nerrs > 0) exit(ruby_nerrs);
    state = ruby_exec();
    if (state && !ex) ex = state;
    ruby_stop(ex);
}

static void
compile_error(at)
    const char *at;
{
    VALUE str;

    ruby_nerrs = 0;
    str = rb_str_buf_new2("compile error");
    if (at) {
	rb_str_buf_cat2(str, " in ");
	rb_str_buf_cat2(str, at);
    }
    rb_str_buf_cat(str, "\n", 1);
    if (!NIL_P(ruby_errinfo)) {
	rb_str_append(str, ruby_errinfo);
    }
    rb_exc_raise(rb_exc_new3(rb_eSyntaxError, str));
}

VALUE
rb_eval_string(str)
    const char *str;
{
    VALUE v;
    NODE *oldsrc = ruby_current_node;

    ruby_current_node = 0;
    ruby_sourcefile = rb_source_filename("(eval)");
    v = eval(ruby_top_self, rb_str_new2(str), Qnil, 0, 0);
    ruby_current_node = oldsrc;

    return v;
}

VALUE
rb_eval_string_protect(str, state)
    const char *str;
    int *state;
{
    VALUE result;		/* OK */
    int status;

    PUSH_TAG(PROT_NONE);
    if ((status = EXEC_TAG()) == 0) {
	result = rb_eval_string(str);
    }
    POP_TAG();
    if (state) {
	*state = status;
    }
    if (status != 0) {
	return Qnil;
    }

    return result;
}

VALUE
rb_eval_string_wrap(str, state)
    const char *str;
    int *state;
{
    int status;
    VALUE self = ruby_top_self;
    VALUE wrapper = ruby_wrapper;
    VALUE val;

    PUSH_CLASS();
    ruby_class = ruby_wrapper = rb_module_new();
    ruby_top_self = rb_obj_clone(ruby_top_self);
    rb_extend_object(ruby_top_self, ruby_wrapper);
    PUSH_FRAME();
    ruby_frame->last_func = 0;
    ruby_frame->orig_func = 0;
    ruby_frame->last_class = 0;
    ruby_frame->self = self;
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,ruby_wrapper,0,0);
    PUSH_SCOPE();

    val = rb_eval_string_protect(str, &status);
    ruby_top_self = self;

    POP_SCOPE();
    POP_FRAME();
    POP_CLASS();
    ruby_wrapper = wrapper;
    if (state) {
	*state = status;
    }
    else if (status) {
	JUMP_TAG(status);
    }
    return val;
}

static void
localjump_error(mesg, status)
    const char *mesg;
    VALUE status;
{
    VALUE exc = rb_exc_new2(rb_eLocalJumpError, mesg);
    rb_iv_set(exc, "@@status", status);
    rb_exc_raise(exc);
}

static VALUE
localjump_exitstatus(exc)
    VALUE exc;
{
    return rb_iv_get(exc, "@@status");
}

static void
jump_tag_but_local_jump(state)
    int state;
{
    VALUE val;

    if (prot_tag) val = prot_tag->retval;
    else          val = Qnil;
    switch (state) {
      case 0:
	break;
      case TAG_RETURN:
	localjump_error("unexpected return", val);
	break;
      case TAG_NEXT:
	localjump_error("unexpected next", val);
	break;
      case TAG_BREAK:
	localjump_error("unexpected break", val);
	break;
      case TAG_REDO:
	localjump_error("unexpected redo", Qnil);
	break;
      case TAG_RETRY:
	localjump_error("retry outside of rescue clause", Qnil);
	break;
      default:
	JUMP_TAG(state);
	break;
    }
}

VALUE
rb_eval_cmd(cmd, arg, tcheck)
    VALUE cmd, arg;
    int tcheck;
{
    int state;
    VALUE val;			/* OK */
    struct SCOPE *saved_scope;
    volatile int safe = ruby_safe_level;

    if (TYPE(cmd) != T_STRING) {
	PUSH_ITER(ITER_NOT);
	val = rb_funcall2(cmd, rb_intern("call"), RARRAY(arg)->len, RARRAY(arg)->ptr);
	POP_ITER();
	return val;
    }

    saved_scope = ruby_scope;
    ruby_scope = top_scope;
    PUSH_FRAME();
    ruby_frame->last_func = 0;
    ruby_frame->orig_func = 0;
    ruby_frame->last_class = 0;
    ruby_frame->self = ruby_top_self;
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,0,0,0);
    RNODE(ruby_frame->cbase)->nd_clss = ruby_wrapper ? ruby_wrapper : rb_cObject;

    if (tcheck && OBJ_TAINTED(cmd)) {
	ruby_safe_level = 4;
    }

    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	val = eval(ruby_top_self, cmd, Qnil, 0, 0);
    }
    if (ruby_scope->flags & SCOPE_DONT_RECYCLE)
       scope_dup(saved_scope);
    ruby_scope = saved_scope;
    ruby_safe_level = safe;
    POP_TAG();
    POP_FRAME();

    jump_tag_but_local_jump(state);
    return val;
}

static VALUE
superclass(self, node)
    VALUE self;
    NODE *node;
{
    VALUE val;			/* OK */
    int state;

    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	val = rb_eval(self, node);
    }
    POP_TAG();
    if (state) {
	switch (nd_type(node)) {
	  case NODE_COLON2:
	    rb_raise(rb_eTypeError, "undefined superclass `%s'",
		     rb_id2name(node->nd_mid));
	  case NODE_CONST:
	    rb_raise(rb_eTypeError, "undefined superclass `%s'",
		     rb_id2name(node->nd_vid));
	  default:
	    break;
	}
	JUMP_TAG(state);
    }
    if (TYPE(val) != T_CLASS) {
	rb_raise(rb_eTypeError, "superclass must be a Class (%s given)",
		 rb_class2name(CLASS_OF(val)));
    }
    if (FL_TEST(val, FL_SINGLETON)) {
	rb_raise(rb_eTypeError, "can't make subclass of virtual class");
    }

    return val;
}

#define ruby_cbase (RNODE(ruby_frame->cbase)->nd_clss)

static VALUE
ev_const_defined(cref, id, self)
    NODE *cref;
    ID id;
    VALUE self;
{
    NODE *cbase = cref;

    while (cbase && cbase->nd_next) {
	struct RClass *klass = RCLASS(cbase->nd_clss);

	if (NIL_P(klass)) return rb_const_defined(CLASS_OF(self), id);
	if (klass->iv_tbl && st_lookup(klass->iv_tbl, id, 0)) {
	    return Qtrue;
	}
	cbase = cbase->nd_next;
    }
    return rb_const_defined(cref->nd_clss, id);
}

static VALUE
ev_const_get(cref, id, self)
    NODE *cref;
    ID id;
    VALUE self;
{
    NODE *cbase = cref;
    VALUE result;

    while (cbase && cbase->nd_next) {
	VALUE klass = cbase->nd_clss;

	if (NIL_P(klass)) return rb_const_get(CLASS_OF(self), id);
	if (RCLASS(klass)->iv_tbl && st_lookup(RCLASS(klass)->iv_tbl, id, &result)) {
	    return result;
	}
	cbase = cbase->nd_next;
    }
    return rb_const_get(cref->nd_clss, id);
}

static VALUE
cvar_cbase()
{
    NODE *cref = RNODE(ruby_frame->cbase);

    while (cref && cref->nd_next && FL_TEST(cref->nd_clss, FL_SINGLETON)) {
	cref = cref->nd_next;
	if (!cref->nd_next) {
	    rb_warn("class variable access from toplevel singleton method");
	}
    }
    return cref->nd_clss;
}

static VALUE
rb_mod_nesting()
{
    NODE *cbase = RNODE(ruby_frame->cbase);
    VALUE ary = rb_ary_new();

    while (cbase && cbase->nd_next) {
	if (!NIL_P(cbase->nd_clss)) rb_ary_push(ary, cbase->nd_clss);
	cbase = cbase->nd_next;
    }
    if (ruby_wrapper && RARRAY(ary)->len == 0) {
	rb_ary_push(ary, ruby_wrapper);
    }
    return ary;
}

static VALUE
rb_mod_s_constants()
{
    NODE *cbase = RNODE(ruby_frame->cbase);
    void *data = 0;

    while (cbase) {
	if (!NIL_P(cbase->nd_clss)) {
	    data = rb_mod_const_at(cbase->nd_clss, data);
	}
	cbase = cbase->nd_next;
    }

    if (!NIL_P(ruby_cbase)) {
	data = rb_mod_const_of(ruby_cbase, data);
    }
    return rb_const_list(data);
}

void
rb_frozen_class_p(klass)
    VALUE klass;
{
    char *desc = "something(?!)";

    if (OBJ_FROZEN(klass)) {
	if (FL_TEST(klass, FL_SINGLETON))
	    desc = "object";
	else {
	    switch (TYPE(klass)) {
	      case T_MODULE:
	      case T_ICLASS:
		desc = "module"; break;
	      case T_CLASS:
		desc = "class"; break;
	    }
	}
	rb_error_frozen(desc);
    }
}

void
rb_undef(klass, id)
    VALUE klass;
    ID id;
{
    VALUE origin;
    NODE *body;

    if (ruby_class == rb_cObject && klass == ruby_class) {
	rb_secure(4);
    }
    if (ruby_safe_level >= 4 && !OBJ_TAINTED(klass)) {
	rb_raise(rb_eSecurityError, "Insecure: can't undef `%s'", rb_id2name(id));
    }
    rb_frozen_class_p(klass);
    if (id == __id__ || id == __send__ || id == init || id == alloc) {
	rb_warn("undefining `%s' may cause serious problem", rb_id2name(id));
    }
    body = search_method(klass, id, &origin);
    if (!body || !body->nd_body) {
	char *s0 = " class";
	VALUE c = klass;

	if (FL_TEST(c, FL_SINGLETON)) {
	    VALUE obj = rb_iv_get(klass, "__attached__");

	    switch (TYPE(obj)) {
	      case T_MODULE:
	      case T_CLASS:
		c = obj;
		s0 = "";
	    }
	}
	else if (TYPE(c) == T_MODULE) {
	    s0 = " module";
	}
	rb_name_error(id, "undefined method `%s' for%s `%s'",
		      rb_id2name(id),s0,rb_class2name(c));
    }
    rb_add_method(klass, id, 0, NOEX_PUBLIC);
    if (FL_TEST(klass, FL_SINGLETON)) {
	rb_funcall(rb_iv_get(klass, "__attached__"),
		   singleton_undefined, 1, ID2SYM(id));
    }
    else {
	rb_funcall(klass, undefined, 1, ID2SYM(id));
    }
}

static VALUE
rb_mod_undef_method(mod, name)
    VALUE mod, name;
{
    rb_undef(mod, rb_to_id(name));
    return mod;
}

void
rb_alias(klass, name, def)
    VALUE klass;
    ID name, def;
{
    VALUE origin;
    NODE *orig, *body;
    VALUE singleton = 0;

    rb_frozen_class_p(klass);
    if (name == def) return;
    if (klass == rb_cObject) {
	rb_secure(4);
    }
    orig = search_method(klass, def, &origin);
    if (!orig || !orig->nd_body) {
	if (TYPE(klass) == T_MODULE) {
	    orig = search_method(rb_cObject, def, &origin);
	}
    }
    if (!orig || !orig->nd_body) {
	print_undef(klass, def);
    }
    if (FL_TEST(klass, FL_SINGLETON)) {
	singleton = rb_iv_get(klass, "__attached__");
	if (name == alloc && TYPE(singleton) == T_CLASS) {
	    rb_raise(rb_eNameError, "cannot make alias named `allocate'");
	}
    }
    body = orig->nd_body;
    orig->nd_cnt++;
    if (nd_type(body) == NODE_FBODY) { /* was alias */
	def = body->nd_mid;
	origin = body->nd_orig;
	body = body->nd_head;
    }

    rb_clear_cache_by_id(name);
    st_insert(RCLASS(klass)->m_tbl, name,
	      NEW_METHOD(NEW_FBODY(body, def, origin), orig->nd_noex));
    if (singleton) {
	rb_funcall(singleton, singleton_added, 1, ID2SYM(name));
    }
    else {
	rb_funcall(klass, added, 1, ID2SYM(name));
    }
}

static VALUE
rb_mod_alias_method(mod, newname, oldname)
    VALUE mod, newname, oldname;
{
    rb_alias(mod, rb_to_id(newname), rb_to_id(oldname));
    return mod;
}

static NODE*
copy_node_scope(node, rval)
    NODE *node;
    VALUE rval;
{
    NODE *copy = rb_node_newnode(NODE_SCOPE,0,rval,node->nd_next);

    if (node->nd_tbl) {
	copy->nd_tbl = ALLOC_N(ID, node->nd_tbl[0]+1);
	MEMCPY(copy->nd_tbl, node->nd_tbl, ID, node->nd_tbl[0]+1);
    }
    else {
	copy->nd_tbl = 0;
    }
    return copy;
}

#ifdef C_ALLOCA
# define TMP_PROTECT NODE * volatile tmp__protect_tmp=0
# define TMP_ALLOC(n)							\
    (tmp__protect_tmp = rb_node_newnode(NODE_ALLOCA,			\
			     ALLOC_N(VALUE,n),tmp__protect_tmp,n),	\
     (void*)tmp__protect_tmp->nd_head)
#else
# define TMP_PROTECT typedef int foobazzz
# define TMP_ALLOC(n) ALLOCA_N(VALUE,n)
#endif

#define SETUP_ARGS(anode) do {\
    NODE *n = anode;\
    if (!n) {\
	argc = 0;\
	argv = 0;\
    }\
    else if (nd_type(n) == NODE_ARRAY) {\
	argc=n->nd_alen;\
        if (argc > 0) {\
            int i;\
	    n = anode;\
	    argv = TMP_ALLOC(argc);\
	    for (i=0;i<argc;i++) {\
		argv[i] = rb_eval(self,n->nd_head);\
		n=n->nd_next;\
	    }\
        }\
        else {\
	    argc = 0;\
	    argv = 0;\
        }\
    }\
    else {\
        VALUE args = rb_eval(self,n);\
	if (TYPE(args) != T_ARRAY)\
	    args = rb_ary_to_ary(args);\
        argc = RARRAY(args)->len;\
	argv = ALLOCA_N(VALUE, argc);\
	MEMCPY(argv, RARRAY(args)->ptr, VALUE, argc);\
    }\
} while (0)

#define BEGIN_CALLARGS do {\
    struct BLOCK *tmp_block = ruby_block;\
    if (ruby_iter->iter == ITER_PRE) {\
	ruby_block = ruby_block->prev;\
    }\
    PUSH_ITER(ITER_NOT)

#define END_CALLARGS \
    ruby_block = tmp_block;\
    POP_ITER();\
} while (0)

#define MATCH_DATA *rb_svar(node->nd_cnt)

static char* is_defined _((VALUE, NODE*, char*));

static char*
arg_defined(self, node, buf, type)
    VALUE self;
    NODE *node;
    char *buf;
    char *type;
{
    int argc;
    int i;

    if (!node) return type;	/* no args */
    if (nd_type(node) == NODE_ARRAY) {
	argc=node->nd_alen;
        if (argc > 0) {
	    for (i=0;i<argc;i++) {
		if (!is_defined(self, node->nd_head, buf))
		    return 0;
		node = node->nd_next;
	    }
        }
    }
    else if (!is_defined(self, node, buf)) {
	return 0;
    }
    return type;
}
    
static char*
is_defined(self, node, buf)
    VALUE self;
    NODE *node;			/* OK */
    char *buf;
{
    VALUE val;			/* OK */
    int state;

  again:
    if (!node) return "expression";
    switch (nd_type(node)) {
      case NODE_SUPER:
      case NODE_ZSUPER:
	if (ruby_frame->orig_func == 0) return 0;
	else if (ruby_frame->last_class == 0) return 0;
	else if (rb_method_boundp(RCLASS(ruby_frame->last_class)->super,
				  ruby_frame->orig_func, 0)) {
	    if (nd_type(node) == NODE_SUPER) {
		return arg_defined(self, node->nd_args, buf, "super");
	    }
	    return "super";
	}
	break;

      case NODE_VCALL:
      case NODE_FCALL:
	val = self;
	goto check_bound;

      case NODE_CALL:
	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    val = rb_eval(self, node->nd_recv);
	}
	POP_TAG();
	if (state) {
	    ruby_errinfo = Qnil;
	    return 0;
	}
      check_bound:
	{
	    int call = nd_type(node)==NODE_CALL;

	    val = CLASS_OF(val);
	    if (call) {
		int noex;
		ID id = node->nd_mid;

		if (!rb_get_method_body(&val, &id, &noex))
		    break;
		if ((noex & NOEX_PRIVATE))
		    break;
		if ((noex & NOEX_PROTECTED) &&
		    !rb_obj_is_kind_of(self, rb_class_real(val)))
		    break;
	    }
	    else if (!rb_method_boundp(val, node->nd_mid, call))
		break;
	    return arg_defined(self, node->nd_args, buf, "method");
	}
	break;

      case NODE_MATCH2:
      case NODE_MATCH3:
	return "method";

      case NODE_YIELD:
	if (rb_block_given_p()) {
	    return "yield";
	}
	break;

      case NODE_SELF:
	return "self";

      case NODE_NIL:
	return "nil";

      case NODE_TRUE:
	return "true";

      case NODE_FALSE:
	return "false";

      case NODE_ATTRSET:
      case NODE_OP_ASGN1:
      case NODE_OP_ASGN2:
      case NODE_MASGN:
      case NODE_LASGN:
      case NODE_DASGN:
      case NODE_DASGN_CURR:
      case NODE_GASGN:
      case NODE_CDECL:
      case NODE_CVDECL:
      case NODE_CVASGN:
	return "assignment";

      case NODE_LVAR:
	return "local-variable";
      case NODE_DVAR:
	return "local-variable(in-block)";

      case NODE_GVAR:
	if (rb_gvar_defined(node->nd_entry)) {
	    return "global-variable";
	}
	break;

      case NODE_IVAR:
	if (rb_ivar_defined(self, node->nd_vid)) {
	    return "instance-variable";
	}
	break;

      case NODE_CONST:
	if (ev_const_defined(RNODE(ruby_frame->cbase), node->nd_vid, self)) {
	    return "constant";
	}
	break;

      case NODE_CVAR:
	if (rb_cvar_defined(cvar_cbase(), node->nd_vid)) {
	    return "class variable";
	}
	break;

      case NODE_COLON2:
	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    val = rb_eval(self, node->nd_head);
	}
	POP_TAG();
	if (state) {
	    ruby_errinfo = Qnil;
	    return 0;
	}
	else {
	    switch (TYPE(val)) {
	      case T_CLASS:
	      case T_MODULE:
		if (rb_const_defined_at(val, node->nd_mid))
		    return "constant";
		break;
	      default:
		if (rb_method_boundp(CLASS_OF(val), node->nd_mid, 1)) {
		    return "method";
		}
	    }
	}
	break;

      case NODE_NTH_REF:
	if (RTEST(rb_reg_nth_defined(node->nd_nth, MATCH_DATA))) {
	    sprintf(buf, "$%d", node->nd_nth);
	    return buf;
	}
	break;

      case NODE_BACK_REF:
	if (RTEST(rb_reg_nth_defined(0, MATCH_DATA))) {
	    sprintf(buf, "$%c", node->nd_nth);
	    return buf;
	}
	break;

      case NODE_NEWLINE:
	node = node->nd_next;
	goto again;

      default:
	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    rb_eval(self, node);
	}
	POP_TAG();
	if (!state) {
	    return "expression";
	}
	ruby_errinfo = Qnil;
	break;
    }
    return 0;
}

static int handle_rescue _((VALUE,NODE*));

static void blk_free();

static VALUE
rb_obj_is_block(block)
    VALUE block;
{
    if (TYPE(block) == T_DATA && RDATA(block)->dfree == (RUBY_DATA_FUNC)blk_free) {
	return Qtrue;
    }
    return Qfalse;
}

static VALUE
rb_obj_is_proc(proc)
    VALUE proc;
{
    if (rb_obj_is_block(proc) && rb_obj_is_kind_of(proc, rb_cProc)) {
	return Qtrue;
    }
    return Qfalse;
}

static VALUE
set_trace_func(obj, trace)
    VALUE obj, trace;
{
    if (NIL_P(trace)) {
	trace_func = 0;
	return Qnil;
    }
    if (!rb_obj_is_proc(trace)) {
	rb_raise(rb_eTypeError, "trace_func needs to be Proc");
    }
    return trace_func = trace;
}

static void
call_trace_func(event, node, self, id, klass)
    char *event;
    NODE *node;
    VALUE self;
    ID id;
    VALUE klass;		/* OK */
{
    int state;
    struct FRAME *prev;
    NODE *node_save[2];
    VALUE srcfile;

    if (!trace_func) return;
    if (tracing) return;
    if (ruby_in_compile) return;

    node_save[0] = ruby_last_node;
    if (!(node_save[1] = ruby_current_node)) {
	node_save[1] = NEW_NEWLINE(0);
    }
    tracing = 1;
    prev = ruby_frame;
    PUSH_FRAME();
    *ruby_frame = *prev;
    ruby_frame->prev = prev;
    ruby_frame->iter = 0;	/* blocks not available anyway */

    if (node) {
	ruby_current_node = node;
	ruby_sourcefile = node->nd_file;
	ruby_sourceline = nd_line(node);
    }
    if (klass) {
	if (TYPE(klass) == T_ICLASS) {
	    klass = RBASIC(klass)->klass;
	}
	else if (FL_TEST(klass, FL_SINGLETON)) {
	    klass = self;
	}
    }
    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	srcfile = rb_str_new2(ruby_sourcefile?ruby_sourcefile:"(ruby)");
	proc_invoke(trace_func, rb_ary_new3(6, rb_str_new2(event),
					    srcfile,
					    INT2FIX(ruby_sourceline),
					    id?ID2SYM(id):Qnil,
					    self?rb_f_binding(self):Qnil,
					    klass),
		    Qtrue, Qundef);
    }
    POP_TMPTAG();		/* do not propagate retval */
    POP_FRAME();

    tracing = 0;
    ruby_last_node = node_save[0];
    ruby_current_node = node_save[1];
    SET_CURRENT_SOURCE();
    if (state) JUMP_TAG(state);
}

static VALUE
svalue_to_avalue(v)
    VALUE v;
{
    if (NIL_P(v)) return rb_ary_new2(0);
    if (v == Qundef) return rb_ary_new2(0);
    if (TYPE(v) == T_ARRAY) {
	if (RARRAY(v)->len > 1) return v;
	return rb_ary_new3(1, v);
    }
    else {
	v = rb_ary_to_ary(v);
    }
    return v;
}

static VALUE
avalue_to_svalue(v)
    VALUE v;
{
    if (TYPE(v) != T_ARRAY) {
	v = rb_ary_to_ary(v);
    }
    if (RARRAY(v)->len == 0) {
	return Qnil;
    }
    if (RARRAY(v)->len == 1) {
	return RARRAY(v)->ptr[0];
    }
    return v;
}

static VALUE
avalue_to_yvalue(v)
    VALUE v;
{
    if (TYPE(v) != T_ARRAY) {
	v = rb_ary_to_ary(v);
    }
    if (RARRAY(v)->len == 0) {
	return Qundef;
    }
    if (RARRAY(v)->len == 1) {
	return RARRAY(v)->ptr[0];
    }
    return v;
}

static VALUE
svalue_to_mvalue(v)
    VALUE v;
{
    if (v == Qnil || v == Qundef)
	return rb_ary_new2(0);
    if (TYPE(v) == T_ARRAY) {
	return v;
    }
    else {
	v = rb_ary_to_ary(v);
    }
    return v;
}

static VALUE
mvalue_to_svalue(v)
    VALUE v;
{
    if (TYPE(v) != T_ARRAY) {
	v = rb_ary_to_ary(v);
    }
    if (RARRAY(v)->len == 0) {
	return Qnil;
    }
    if (RARRAY(v)->len == 1 && TYPE(RARRAY(v)->ptr[0]) != T_ARRAY) {
	return RARRAY(v)->ptr[0];
    }
    return v;
}

static void return_check _((void));
#define return_value(v) prot_tag->retval = (v)

static VALUE
rb_eval(self, n)
    VALUE self;
    NODE *n;
{
    NODE *nodesave = ruby_current_node;
    NODE * volatile node = n;
    int state;
    volatile VALUE result = Qnil;

#define RETURN(v) do { \
    result = (v); \
    goto finish; \
} while (0)

  again:
    if (!node) RETURN(Qnil);

    ruby_last_node = ruby_current_node = node;
    switch (nd_type(node)) {
      case NODE_BLOCK:
	while (node->nd_next) {
	    rb_eval(self, node->nd_head);
	    node = node->nd_next;
	}
	node = node->nd_head;
	goto again;

      case NODE_POSTEXE:
	rb_f_END();
	nd_set_type(node, NODE_NIL); /* exec just once */
	result = Qnil;
	break;

	/* begin .. end without clauses */
      case NODE_BEGIN:
	node = node->nd_body;
	goto again;

	/* nodes for speed-up(default match) */
      case NODE_MATCH:
	result = rb_reg_match2(node->nd_lit);
	break;

	/* nodes for speed-up(literal match) */
      case NODE_MATCH2:
	result = rb_reg_match(rb_eval(self,node->nd_recv),
			      rb_eval(self,node->nd_value));
	break;

	/* nodes for speed-up(literal match) */
      case NODE_MATCH3:
        {
	    VALUE r = rb_eval(self,node->nd_recv);
	    VALUE l = rb_eval(self,node->nd_value);
	    if (TYPE(l) == T_STRING) {
		result = rb_reg_match(r, l);
	    }
	    else {
		result = rb_funcall(l, match, 1, r);
	    }
	}
	break;

	/* node for speed-up(top-level loop for -n/-p) */
      case NODE_OPT_N:
	PUSH_TAG(PROT_NONE);
	switch (state = EXEC_TAG()) {
	  case 0:
	  opt_n_next:
	    while (!NIL_P(rb_gets())) {
	      opt_n_redo:
		rb_eval(self, node->nd_body);
	    }
	    break;

	  case TAG_REDO:
	    state = 0;
	    goto opt_n_redo;
	  case TAG_NEXT:
	    state = 0;
	    goto opt_n_next;
	  case TAG_BREAK:
	    state = 0;
	  default:
	    break;
	}
	POP_TAG();
	if (state) JUMP_TAG(state);
	RETURN(Qnil);

      case NODE_SELF:
	RETURN(self);

      case NODE_NIL:
	RETURN(Qnil);

      case NODE_TRUE:
	RETURN(Qtrue);

      case NODE_FALSE:
	RETURN(Qfalse);

      case NODE_IF:
	if (trace_func) {
	    call_trace_func("line", node, self,
			    ruby_frame->last_func,
			    ruby_frame->last_class);	
	}
	if (RTEST(rb_eval(self, node->nd_cond))) {
	    node = node->nd_body;
	}
	else {
	    node = node->nd_else;
	}
	goto again;

      case NODE_WHEN:
	while (node) {
	    NODE *tag;

	    if (nd_type(node) != NODE_WHEN) goto again;
	    tag = node->nd_head;
	    while (tag) {
		if (trace_func) {
		    call_trace_func("line", tag, self,
				    ruby_frame->last_func,
				    ruby_frame->last_class);	
		}
		if (nd_type(tag->nd_head) == NODE_WHEN) {
		    VALUE v = rb_eval(self, tag->nd_head->nd_head);
		    long i;

		    if (TYPE(v) != T_ARRAY) v = rb_ary_to_ary(v);
		    for (i=0; i<RARRAY(v)->len; i++) {
			if (RTEST(RARRAY(v)->ptr[i])) {
			    node = node->nd_body;
			    goto again;
			}
		    }
		    tag = tag->nd_next;
		    continue;
		}
		if (RTEST(rb_eval(self, tag->nd_head))) {
		    node = node->nd_body;
		    goto again;
		}
		tag = tag->nd_next;
	    }
	    node = node->nd_next;
	}
	RETURN(Qnil);

      case NODE_CASE:
	{
	    VALUE val;

	    val = rb_eval(self, node->nd_head);
	    node = node->nd_body;
	    while (node) {
		NODE *tag;

		if (nd_type(node) != NODE_WHEN) {
		    goto again;
		}
		tag = node->nd_head;
		while (tag) {
		    if (trace_func) {
			call_trace_func("line", tag, self,
					ruby_frame->last_func,
					ruby_frame->last_class);	
		    }
		    if (nd_type(tag->nd_head) == NODE_WHEN) {
			VALUE v = rb_eval(self, tag->nd_head->nd_head);
			long i;

			if (TYPE(v) != T_ARRAY) v = rb_ary_to_ary(v);
			for (i=0; i<RARRAY(v)->len; i++) {
			    if (RTEST(rb_funcall2(RARRAY(v)->ptr[i], eqq, 1, &val))){
				node = node->nd_body;
				goto again;
			    }
			}
			tag = tag->nd_next;
			continue;
		    }
		    if (RTEST(rb_funcall2(rb_eval(self, tag->nd_head), eqq, 1, &val))) {
			node = node->nd_body;
			goto again;
		    }
		    tag = tag->nd_next;
		}
		node = node->nd_next;
	    }
	}
	RETURN(Qnil);

      case NODE_WHILE:
	PUSH_TAG(PROT_NONE);
	result = Qnil;
	switch (state = EXEC_TAG()) {
	  case 0:
	    if (node->nd_state && !RTEST(rb_eval(self, node->nd_cond)))
		goto while_out;
	    do {
	      while_redo:
		rb_eval(self, node->nd_body);
	      while_next:
		;
	    } while (RTEST(rb_eval(self, node->nd_cond)));
	    break;

	  case TAG_REDO:
	    state = 0;
	    goto while_redo;
	  case TAG_NEXT:
	    state = 0;
	    goto while_next;
	  case TAG_BREAK:
	    state = 0;
	    result = prot_tag->retval;
	  default:
	    break;
	}
      while_out:
	POP_TAG();
	if (state) JUMP_TAG(state);
	RETURN(result);

      case NODE_UNTIL:
	PUSH_TAG(PROT_NONE);
	result = Qnil;
	switch (state = EXEC_TAG()) {
	  case 0:
	    if (node->nd_state && RTEST(rb_eval(self, node->nd_cond)))
		goto until_out;
	    do {
	      until_redo:
		rb_eval(self, node->nd_body);
	      until_next:
		;
	    } while (!RTEST(rb_eval(self, node->nd_cond)));
	    break;

	  case TAG_REDO:
	    state = 0;
	    goto until_redo;
	  case TAG_NEXT:
	    state = 0;
	    goto until_next;
	  case TAG_BREAK:
	    state = 0;
	    result = prot_tag->retval;
	  default:
	    break;
	}
      until_out:
	POP_TAG();
	if (state) JUMP_TAG(state);
	RETURN(result);

      case NODE_BLOCK_PASS:
	result = block_pass(self, node);
	break;

      case NODE_ITER:
      case NODE_FOR:
	{
	  iter_retry:
	    PUSH_TAG(PROT_FUNC);
	    PUSH_BLOCK(node->nd_var, node->nd_body);

	    state = EXEC_TAG();
	    if (state == 0) {
		PUSH_ITER(ITER_PRE);
		if (nd_type(node) == NODE_ITER) {
		    result = rb_eval(self, node->nd_iter);
		}
		else {
		    VALUE recv;

		    _block.flags &= ~BLOCK_D_SCOPE;
		    BEGIN_CALLARGS;
		    recv = rb_eval(self, node->nd_iter);
		    END_CALLARGS;
		    ruby_current_node = node;
		    SET_CURRENT_SOURCE();
		    result = rb_call(CLASS_OF(recv),recv,each,0,0,0);
		}
		POP_ITER();
	    }
	    else if (_block.tag->dst == state) {
		state &= TAG_MASK;
		if (state == TAG_RETURN || state == TAG_BREAK) {
		    result = prot_tag->retval;
		}
	    }
	    POP_BLOCK();
	    POP_TAG();
	    switch (state) {
	      case 0:
		break;

	      case TAG_RETRY:
		goto iter_retry;

	      case TAG_BREAK:
		break;

	      case TAG_RETURN:
		return_value(result);
		/* fall through */
	      default:
		JUMP_TAG(state);
	    }
	}
	break;

      case NODE_BREAK:
	if (node->nd_stts) {
 	    return_value(avalue_to_svalue(rb_eval(self, node->nd_stts)));
 	}
	else {
	    return_value(Qnil);
	}
	JUMP_TAG(TAG_BREAK);
	break;

      case NODE_NEXT:
	CHECK_INTS;
	if (node->nd_stts) {
 	    return_value(avalue_to_svalue(rb_eval(self, node->nd_stts)));
 	}
	else {
	    return_value(Qnil);
	}
	JUMP_TAG(TAG_NEXT);
	break;

      case NODE_REDO:
	CHECK_INTS;
	JUMP_TAG(TAG_REDO);
	break;

      case NODE_RETRY:
	CHECK_INTS;
	JUMP_TAG(TAG_RETRY);
	break;

      case NODE_RESTARGS:
      case NODE_RESTARY:
	result = rb_ary_to_ary(rb_eval(self, node->nd_head));
	break;

      case NODE_REXPAND:
	result = avalue_to_svalue(rb_eval(self, node->nd_head));
	break;

      case NODE_YIELD:
	if (node->nd_stts) {
	    result = avalue_to_yvalue(rb_eval(self, node->nd_stts));
	}
	else {
	    result = Qundef;	/* no arg */
	}
	SET_CURRENT_SOURCE();
	result = rb_yield_0(result, 0, 0, 0);
	break;

      case NODE_RESCUE:
      retry_entry:
        {
	    volatile VALUE e_info = ruby_errinfo;

	    PUSH_TAG(PROT_NONE);
	    if ((state = EXEC_TAG()) == 0) {
		result = rb_eval(self, node->nd_head);
	    }
	    POP_TAG();
	    if (state == TAG_RAISE) {
		NODE * volatile resq = node->nd_resq;

		while (resq) {
		    ruby_current_node = resq;
		    if (handle_rescue(self, resq)) {
			state = 0;
			PUSH_TAG(PROT_NONE);
			if ((state = EXEC_TAG()) == 0) {
			    result = rb_eval(self, resq->nd_body);
			}
			POP_TAG();
			if (state == TAG_RETRY) {
			    state = 0;
			    ruby_errinfo = Qnil;
			    goto retry_entry;
			}
			if (state != TAG_RAISE) {
			    ruby_errinfo = e_info;
			}
			break;
		    }
		    resq = resq->nd_head; /* next rescue */
		}
	    }
	    else if (node->nd_else) { /* else clause given */
		if (!state) {	/* no exception raised */
		    result = rb_eval(self, node->nd_else);
		}
	    }
	    if (state) JUMP_TAG(state);
	}
        break;

      case NODE_ENSURE:
	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    result = rb_eval(self, node->nd_head);
	}
	POP_TAG();
	if (node->nd_ensr) {
	    VALUE retval = prot_tag->retval; /* save retval */
	    VALUE errinfo = ruby_errinfo;

	    rb_eval(self, node->nd_ensr);
	    return_value(retval);
	    ruby_errinfo = errinfo;
	}
	if (state) JUMP_TAG(state);
	break;

      case NODE_AND:
	result = rb_eval(self, node->nd_1st);
	if (!RTEST(result)) break;
	node = node->nd_2nd;
	goto again;

      case NODE_OR:
	result = rb_eval(self, node->nd_1st);
	if (RTEST(result)) break;
	node = node->nd_2nd;
	goto again;

      case NODE_NOT:
	if (RTEST(rb_eval(self, node->nd_body))) result = Qfalse;
	else result = Qtrue;
	break;

      case NODE_DOT2:
      case NODE_DOT3:
	result = rb_range_new(rb_eval(self, node->nd_beg),
			      rb_eval(self, node->nd_end),
			      nd_type(node) == NODE_DOT3);
	if (node->nd_state) break;
	if (nd_type(node->nd_beg) == NODE_LIT && FIXNUM_P(node->nd_beg->nd_lit) &&
	    nd_type(node->nd_end) == NODE_LIT && FIXNUM_P(node->nd_end->nd_lit))
	{
	    nd_set_type(node, NODE_LIT);
	    node->nd_lit = result;
	}
	else {
	    node->nd_state = 1;
	}
	break;

      case NODE_FLIP2:		/* like AWK */
	{
	    VALUE *flip = rb_svar(node->nd_cnt);
	    if (!flip) rb_bug("unexpected local variable");
	    if (!RTEST(*flip)) {
		if (RTEST(rb_eval(self, node->nd_beg))) {
		    *flip = RTEST(rb_eval(self, node->nd_end))?Qfalse:Qtrue;
		    result = Qtrue;
		}
		else {
		    result = Qfalse;
		}
	    }
	    else {
		if (RTEST(rb_eval(self, node->nd_end))) {
		    *flip = Qfalse;
		}
		result = Qtrue;
	    }
	}
	break;

      case NODE_FLIP3:		/* like SED */
	{
	    VALUE *flip = rb_svar(node->nd_cnt);
	    if (!flip) rb_bug("unexpected local variable");
	    if (!RTEST(*flip)) {
		result = RTEST(rb_eval(self, node->nd_beg)) ? Qtrue : Qfalse;
		*flip = result;
	    }
	    else {
		if (RTEST(rb_eval(self, node->nd_end))) {
		    *flip = Qfalse;
		}
		result = Qtrue;
	    }
	}
	break;

      case NODE_RETURN:
	if (node->nd_stts) {
 	    return_value(avalue_to_svalue(rb_eval(self, node->nd_stts)));
 	}
	else {
	    return_value(Qnil);
	}
	return_check();
	JUMP_TAG(TAG_RETURN);
	break;

      case NODE_ARGSCAT:
	result = rb_ary_concat(rb_eval(self, node->nd_head),
			       rb_eval(self, node->nd_body));
	break;

      case NODE_ARGSPUSH:
	result = rb_ary_push(rb_ary_dup(rb_eval(self, node->nd_head)),
			     rb_eval(self, node->nd_body));
	break;

      case NODE_CALL:
	{
	    VALUE recv;
	    int argc; VALUE *argv; /* used in SETUP_ARGS */
	    TMP_PROTECT;

	    BEGIN_CALLARGS;
	    recv = rb_eval(self, node->nd_recv);
	    SETUP_ARGS(node->nd_args);
	    END_CALLARGS;

	    SET_CURRENT_SOURCE();
	    result = rb_call(CLASS_OF(recv),recv,node->nd_mid,argc,argv,0);
	}
	break;

      case NODE_FCALL:
	{
	    int argc; VALUE *argv; /* used in SETUP_ARGS */
	    TMP_PROTECT;

	    BEGIN_CALLARGS;
	    SETUP_ARGS(node->nd_args);
	    END_CALLARGS;

	    SET_CURRENT_SOURCE();
	    result = rb_call(CLASS_OF(self),self,node->nd_mid,argc,argv,1);
	}
	break;

      case NODE_VCALL:
	SET_CURRENT_SOURCE();
	result = rb_call(CLASS_OF(self),self,node->nd_mid,0,0,2);
	break;

      case NODE_SUPER:
      case NODE_ZSUPER:
	{
	    int argc; VALUE *argv; /* used in SETUP_ARGS */
	    TMP_PROTECT;

	    if (ruby_frame->last_class == 0) {	
		if (ruby_frame->orig_func) {
		    rb_name_error(ruby_frame->last_func,
				  "superclass method `%s' disabled",
				  rb_id2name(ruby_frame->orig_func));
		}
		else {
		    rb_raise(rb_eNoMethodError, "super called outside of method");
		}
	    }
	    if (nd_type(node) == NODE_ZSUPER) {
		argc = ruby_frame->argc;
		argv = ruby_frame->argv;
	    }
	    else {
		BEGIN_CALLARGS;
		SETUP_ARGS(node->nd_args);
		END_CALLARGS;
	    }

	    PUSH_ITER(ruby_iter->iter?ITER_PRE:ITER_NOT);
	    SET_CURRENT_SOURCE();
	    result = rb_call(RCLASS(ruby_frame->last_class)->super,
			     ruby_frame->self, ruby_frame->orig_func,
			     argc, argv, 3);
	    POP_ITER();
	}
	break;

      case NODE_SCOPE:
	{
	    struct FRAME frame;
	    NODE *saved_cref = 0;

	    frame = *ruby_frame;
	    frame.tmp = ruby_frame;
	    ruby_frame = &frame;

	    PUSH_SCOPE();
	    PUSH_TAG(PROT_NONE);
	    if (node->nd_rval) {
		saved_cref = ruby_cref;
		ruby_cref = (NODE*)node->nd_rval;
		ruby_frame->cbase = node->nd_rval;
	    }
	    if (node->nd_tbl) {
		VALUE *vars = ALLOCA_N(VALUE, node->nd_tbl[0]+1);
		*vars++ = (VALUE)node;
		ruby_scope->local_vars = vars;
		rb_mem_clear(ruby_scope->local_vars, node->nd_tbl[0]);
		ruby_scope->local_tbl = node->nd_tbl;
	    }
	    else {
		ruby_scope->local_vars = 0;
		ruby_scope->local_tbl  = 0;
	    }
	    if ((state = EXEC_TAG()) == 0) {
		result = rb_eval(self, node->nd_next);
	    }
	    POP_TAG();
	    POP_SCOPE();
	    ruby_frame = frame.tmp;
	    if (saved_cref)
		ruby_cref = saved_cref;
	    if (state) JUMP_TAG(state);
	}
	break;

      case NODE_OP_ASGN1:
	{
	    int argc; VALUE *argv; /* used in SETUP_ARGS */
	    VALUE recv, val;
	    NODE *rval;
	    TMP_PROTECT;

	    recv = rb_eval(self, node->nd_recv);
	    rval = node->nd_args->nd_head;
	    SETUP_ARGS(node->nd_args->nd_next);
	    val = rb_funcall2(recv, aref, argc-1, argv);
	    switch (node->nd_mid) {
	    case 0: /* OR */
		if (RTEST(val)) RETURN(val);
		val = rb_eval(self, rval);
		break;
	    case 1: /* AND */
		if (!RTEST(val)) RETURN(val);
		val = rb_eval(self, rval);
		break;
	    default:
		val = rb_funcall(val, node->nd_mid, 1, rb_eval(self, rval));
	    }
	    argv[argc-1] = val;
	    rb_funcall2(recv, aset, argc, argv);
	    result = val;
	}
	break;

      case NODE_OP_ASGN2:
	{
	    ID id = node->nd_next->nd_vid;
	    VALUE recv, val;

	    recv = rb_eval(self, node->nd_recv);
	    val = rb_funcall(recv, id, 0);
	    switch (node->nd_next->nd_mid) {
	    case 0: /* OR */
		if (RTEST(val)) RETURN(val);
		val = rb_eval(self, node->nd_value);
		break;
	    case 1: /* AND */
		if (!RTEST(val)) RETURN(val);
		val = rb_eval(self, node->nd_value);
		break;
	    default:
		val = rb_funcall(val, node->nd_next->nd_mid, 1,
				 rb_eval(self, node->nd_value));
	    }

	    rb_funcall2(recv, node->nd_next->nd_aid, 1, &val);
	    result = val;
	}
	break;

      case NODE_OP_ASGN_AND:
	result = rb_eval(self, node->nd_head);
	if (!RTEST(result)) break;
	node = node->nd_value;
	goto again;

      case NODE_OP_ASGN_OR:
	if ((node->nd_aid && !is_defined(self, node->nd_head, 0)) ||
	    !RTEST(result = rb_eval(self, node->nd_head))) {
	    node = node->nd_value;
	    goto again;
	}
	break;

      case NODE_MASGN:
	result = massign(self, node, rb_eval(self, node->nd_value),0);
	break;

      case NODE_LASGN:
	if (ruby_scope->local_vars == 0)
	    rb_bug("unexpected local variable assignment");
	result = rb_eval(self, node->nd_value);
	ruby_scope->local_vars[node->nd_cnt] = result;
	break;

      case NODE_DASGN:
	result = rb_eval(self, node->nd_value);
	dvar_asgn(node->nd_vid, result);
	break;

      case NODE_DASGN_CURR:
	result = rb_eval(self, node->nd_value);
	dvar_asgn_curr(node->nd_vid, result);
	break;

      case NODE_GASGN:
	result = rb_eval(self, node->nd_value);
	rb_gvar_set(node->nd_entry, result);
	break;

      case NODE_IASGN:
	result = rb_eval(self, node->nd_value);
	rb_ivar_set(self, node->nd_vid, result);
	break;

      case NODE_CDECL:
	if (NIL_P(ruby_cbase)) {
	    rb_raise(rb_eTypeError, "no class/module to define constant");
	}
	result = rb_eval(self, node->nd_value);
	rb_const_set(ruby_cbase, node->nd_vid, result);
	break;

      case NODE_CVDECL:
	if (NIL_P(ruby_cbase)) {
	    rb_raise(rb_eTypeError, "no class/module to define class variable");
	}
	result = rb_eval(self, node->nd_value);
	rb_cvar_set(cvar_cbase(), node->nd_vid, result, Qtrue);
	break;

      case NODE_CVASGN:
	result = rb_eval(self, node->nd_value);
	rb_cvar_set(cvar_cbase(), node->nd_vid, result, Qfalse);
	break;

      case NODE_LVAR:
	if (ruby_scope->local_vars == 0) {
	    rb_bug("unexpected local variable");
	}
	result = ruby_scope->local_vars[node->nd_cnt];
	break;

      case NODE_DVAR:
	result = rb_dvar_ref(node->nd_vid);
	break;

      case NODE_GVAR:
	result = rb_gvar_get(node->nd_entry);
	break;

      case NODE_IVAR:
	result = rb_ivar_get(self, node->nd_vid);
	break;

      case NODE_CONST:
	result = ev_const_get(RNODE(ruby_frame->cbase), node->nd_vid, self);
	break;

      case NODE_CVAR:
	result = rb_cvar_get(cvar_cbase(), node->nd_vid);
	break;

      case NODE_BLOCK_ARG:
	if (ruby_scope->local_vars == 0)
	    rb_bug("unexpected block argument");
	if (rb_block_given_p()) {
	    result = rb_f_lambda();
	    ruby_scope->local_vars[node->nd_cnt] = result;
	}
	else {
	    result = Qnil;
	}
	break;

      case NODE_COLON2:
	{
	    VALUE klass;

	    klass = rb_eval(self, node->nd_head);
	    switch (TYPE(klass)) {
	      case T_CLASS:
	      case T_MODULE:
		result = rb_const_get(klass, node->nd_mid);
		break;
	      default:
		result = rb_funcall(klass, node->nd_mid, 0, 0);
		break;
	    }
	}
	break;

      case NODE_COLON3:
	result = rb_const_get_at(rb_cObject, node->nd_mid);
	break;

      case NODE_NTH_REF:
	result = rb_reg_nth_match(node->nd_nth, MATCH_DATA);
	break;

      case NODE_BACK_REF:
	switch (node->nd_nth) {
	  case '&':
	    result = rb_reg_last_match(MATCH_DATA);
	    break;
	  case '`':
	    result = rb_reg_match_pre(MATCH_DATA);
	    break;
	  case '\'':
	    result = rb_reg_match_post(MATCH_DATA);
	    break;
	  case '+':
	    result = rb_reg_match_last(MATCH_DATA);
	    break;
	  default:
	    rb_bug("unexpected back-ref");
	}
	break;

      case NODE_HASH:
	{
	    NODE *list;
	    VALUE hash = rb_hash_new();
	    VALUE key, val;

	    list = node->nd_head;
	    while (list) {
		key = rb_eval(self, list->nd_head);
		list = list->nd_next;
		if (list == 0)
		    rb_bug("odd number list for Hash");
		val = rb_eval(self, list->nd_head);
		list = list->nd_next;
		rb_hash_aset(hash, key, val);
	    }
	    result = hash;
	}
	break;

      case NODE_ZARRAY:		/* zero length list */
	result = rb_ary_new();
	break;

      case NODE_ARRAY:
	{
	    VALUE ary;
	    long i;

	    i = node->nd_alen;
	    ary = rb_ary_new2(i);
	    for (i=0;node;node=node->nd_next) {
		RARRAY(ary)->ptr[i++] = rb_eval(self, node->nd_head);
		RARRAY(ary)->len = i;
	    }

	    result = ary;
	}
	break;

      case NODE_STR:
	result = rb_str_new3(node->nd_lit);
	break;

      case NODE_EVSTR:
	result = rb_obj_as_string(rb_eval(self, node->nd_body));
	break;

      case NODE_DSTR:
      case NODE_DXSTR:
      case NODE_DREGX:
      case NODE_DREGX_ONCE:
      case NODE_DSYM:
	{
	    VALUE str, str2;
	    NODE *list = node->nd_next;

	    str = rb_str_new3(node->nd_lit);
	    while (list) {
		if (list->nd_head) {
		    switch (nd_type(list->nd_head)) {
		      case NODE_STR:
			str2 = list->nd_head->nd_lit;
			break;
		      default:
			str2 = rb_eval(self, list->nd_head);
			break;
		    }
		    rb_str_append(str, str2);
		    OBJ_INFECT(str, str2);
		}
		list = list->nd_next;
	    }
	    switch (nd_type(node)) {
	      case NODE_DREGX:
		result = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
				 node->nd_cflag);
		break;
	      case NODE_DREGX_ONCE:	/* regexp expand once */
		result = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
				 node->nd_cflag);
		nd_set_type(node, NODE_LIT);
		node->nd_lit = result;
		break;
	      case NODE_DXSTR:
		result = rb_funcall(self, '`', 1, str);
		break;
	      case NODE_DSYM:
		result = rb_str_intern(str);
		break;
	      default:
		result = str;
		break;
	    }
	}
	break;

      case NODE_XSTR:
	result = rb_funcall(self, '`', 1, node->nd_lit);
	break;

      case NODE_LIT:
	result = node->nd_lit;
	break;

      case NODE_ATTRSET:
	if (ruby_frame->argc != 1)
	    rb_raise(rb_eArgError, "wrong number of arguments(%d for 1)",
		     ruby_frame->argc);
	result = rb_ivar_set(self, node->nd_vid, ruby_frame->argv[0]);
	break;

      case NODE_DEFN:
	if (node->nd_defn) {
	    NODE *body,  *defn;
	    VALUE origin;
	    int noex;

	    if (NIL_P(ruby_class)) {
		rb_raise(rb_eTypeError, "no class/module to add method");
	    }
	    if (ruby_class == rb_cClass && node->nd_mid == alloc) {
		rb_raise(rb_eNameError, "redefining Class#allocate will cause infinite loop");
	    }
	    if (ruby_class == rb_cObject && node->nd_mid == init) {
		rb_warn("redefining Object#initialize may cause infinite loop");
	    }
	    if (node->nd_mid == __id__ || node->nd_mid == __send__) {
		rb_warn("redefining `%s' may cause serious problem",
			rb_id2name(node->nd_mid));
	    }
	    rb_frozen_class_p(ruby_class);
	    body = search_method(ruby_class, node->nd_mid, &origin);
	    if (body){
		if (RTEST(ruby_verbose) && ruby_class == origin && body->nd_cnt == 0) {
		    rb_warning("method redefined; discarding old %s", rb_id2name(node->nd_mid));
		}
	    }

	    if (node->nd_noex == NOEX_PUBLIC) {
		noex = NOEX_PUBLIC; 	/* means is is an attrset */
	    }
	    else if (SCOPE_TEST(SCOPE_PRIVATE) || node->nd_mid == init) {
		noex = NOEX_PRIVATE;
	    }
	    else if (SCOPE_TEST(SCOPE_PROTECTED)) {
		noex = NOEX_PROTECTED;
	    }
	    else {
		noex = NOEX_PUBLIC;
	    }
	    if (body && origin == ruby_class && body->nd_noex & NOEX_UNDEF) {
		noex |= NOEX_UNDEF;
	    }

	    defn = copy_node_scope(node->nd_defn, ruby_cref);
	    rb_add_method(ruby_class, node->nd_mid, defn, noex);
	    if (scope_vmode == SCOPE_MODFUNC) {
		rb_add_method(rb_singleton_class(ruby_class),
			      node->nd_mid, defn, NOEX_PUBLIC);
		rb_funcall(ruby_class, singleton_added, 1, ID2SYM(node->nd_mid));
	    }
	    if (FL_TEST(ruby_class, FL_SINGLETON)) {
		rb_funcall(rb_iv_get(ruby_class, "__attached__"),
			   singleton_added, 1, ID2SYM(node->nd_mid));
	    }
	    else {
		rb_funcall(ruby_class, added, 1, ID2SYM(node->nd_mid));
	    }
	    result = Qnil;
	}
	break;

      case NODE_DEFS:
	if (node->nd_defn) {
	    VALUE recv = rb_eval(self, node->nd_recv);
	    VALUE klass;
	    NODE *body = 0, *defn;

	    if (ruby_safe_level >= 4 && !OBJ_TAINTED(recv)) {
		rb_raise(rb_eSecurityError, "Insecure: can't define singleton method");
	    }
	    if (FIXNUM_P(recv) || SYMBOL_P(recv)) {
		rb_raise(rb_eTypeError,
			 "can't define singleton method \"%s\" for %s",
			 rb_id2name(node->nd_mid),
			 rb_class2name(CLASS_OF(recv)));
	    }

	    if (OBJ_FROZEN(recv)) rb_error_frozen("object");
	    klass = rb_singleton_class(recv);
	    if (st_lookup(RCLASS(klass)->m_tbl, node->nd_mid, &body)) {
		if (ruby_safe_level >= 4) {
		    rb_raise(rb_eSecurityError, "redefining method prohibited");
		}
		if (RTEST(ruby_verbose)) {
		    rb_warning("redefine %s", rb_id2name(node->nd_mid));
		}
	    }
	    defn = copy_node_scope(node->nd_defn, ruby_cref);
	    defn->nd_rval = (VALUE)ruby_cref;
	    rb_add_method(klass, node->nd_mid, defn, 
			  NOEX_PUBLIC|(body?body->nd_noex&NOEX_UNDEF:0));
	    rb_funcall(recv, singleton_added, 1, ID2SYM(node->nd_mid));
	    result = Qnil;
	}
	break;

      case NODE_UNDEF:
	if (NIL_P(ruby_class)) {
	    rb_raise(rb_eTypeError, "no class to undef method");
	}
	rb_undef(ruby_class, node->nd_mid);
	result = Qnil;
	break;

      case NODE_ALIAS:
	if (NIL_P(ruby_class)) {
	    rb_raise(rb_eTypeError, "no class to make alias");
	}
	rb_alias(ruby_class, node->nd_new, node->nd_old);
	result = Qnil;
	break;

      case NODE_VALIAS:
	rb_alias_variable(node->nd_new, node->nd_old);
	result = Qnil;
	break;

      case NODE_CLASS:
	{
	    VALUE super, klass, tmp;

	    if (NIL_P(ruby_cbase)) {
		rb_raise(rb_eTypeError, "no outer class/module");
	    }
	    if (node->nd_super) {
		super = superclass(self, node->nd_super);
	    }
	    else {
		super = 0;
	    }

	    if ((ruby_cbase == rb_cObject) && rb_autoload_defined(node->nd_cname)) {
		rb_autoload_load(node->nd_cname);
	    }
	    if (rb_const_defined_at(ruby_cbase, node->nd_cname)) {
		klass = rb_const_get(ruby_cbase, node->nd_cname);
		if (TYPE(klass) != T_CLASS) {
		    rb_raise(rb_eTypeError, "%s is not a class",
			     rb_id2name(node->nd_cname));
		}
		if (super) {
		    tmp = rb_class_real(RCLASS(klass)->super);
		    if (tmp != super) {
			goto override_class;
		    }
		    super = 0;
		}
		if (ruby_safe_level >= 4) {
		    rb_raise(rb_eSecurityError, "extending class prohibited");
		}
	    }
	    else {
	      override_class:
		if (!super) super = rb_cObject;
		klass = rb_define_class_id(node->nd_cname, super);
		rb_set_class_path(klass,ruby_cbase,rb_id2name(node->nd_cname));
		rb_const_set(ruby_cbase, node->nd_cname, klass);
	    }
	    if (ruby_wrapper) {
		rb_extend_object(klass, ruby_wrapper);
		rb_include_module(klass, ruby_wrapper);
	    }

	    result = module_setup(klass, node->nd_body);
	    if (super) rb_class_inherited(super, klass);
	}
	break;

      case NODE_MODULE:
	{
	    VALUE module;

	    if (NIL_P(ruby_cbase)) {
		rb_raise(rb_eTypeError, "no outer class/module");
	    }
	    if ((ruby_cbase == rb_cObject) && rb_autoload_defined(node->nd_cname)) {
		rb_autoload_load(node->nd_cname);
	    }
	    if (rb_const_defined_at(ruby_cbase, node->nd_cname)) {
		module = rb_const_get(ruby_cbase, node->nd_cname);
		if (TYPE(module) != T_MODULE) {
		    rb_raise(rb_eTypeError, "%s is not a module",
			     rb_id2name(node->nd_cname));
		}
		if (ruby_safe_level >= 4) {
		    rb_raise(rb_eSecurityError, "extending module prohibited");
		}
	    }
	    else {
		module = rb_define_module_id(node->nd_cname);
		rb_set_class_path(module,ruby_cbase,rb_id2name(node->nd_cname));
		rb_const_set(ruby_cbase, node->nd_cname, module);
	    }
	    if (ruby_wrapper) {
		rb_extend_object(module, ruby_wrapper);
		rb_include_module(module, ruby_wrapper);
	    }

	    result = module_setup(module, node->nd_body);
	}
	break;

      case NODE_SCLASS:
	{
	    VALUE klass;

	    result = rb_eval(self, node->nd_recv);
	    if (FIXNUM_P(result) || SYMBOL_P(result)) {
		rb_raise(rb_eTypeError, "no virtual class for %s",
			 rb_class2name(CLASS_OF(result)));
	    }
	    if (ruby_safe_level >= 4 && !OBJ_TAINTED(result))
		rb_raise(rb_eSecurityError, "Insecure: can't extend object");
	    klass = rb_singleton_class(result);
	    
	    if (ruby_wrapper) {
		rb_extend_object(klass, ruby_wrapper);
		rb_include_module(klass, ruby_wrapper);
	    }
	    
	    result = module_setup(klass, node->nd_body);
	}
	break;

      case NODE_DEFINED:
	{
	    char buf[20];
	    char *desc = is_defined(self, node->nd_head, buf);

	    if (desc) result = rb_str_new2(desc);
	    else result = Qnil;
	}
	break;

      case NODE_NEWLINE:
	ruby_sourcefile = node->nd_file;
	ruby_sourceline = node->nd_nth;
	if (trace_func) {
	    call_trace_func("line", node, self,
			    ruby_frame->last_func,
			    ruby_frame->last_class);	
	}
	node = node->nd_next;
	goto again;

      default:
	rb_bug("unknown node type %d", nd_type(node));
    }
  finish:
    CHECK_INTS;
    ruby_current_node = nodesave;
    return result;
}

static VALUE
module_setup(module, n)
    VALUE module;
    NODE *n;
{
    NODE * volatile node = n;
    int state;
    struct FRAME frame;
    VALUE result;		/* OK */
    TMP_PROTECT;

    frame = *ruby_frame;
    frame.tmp = ruby_frame;
    ruby_frame = &frame;

    PUSH_CLASS();
    ruby_class = module;
    PUSH_SCOPE();
    PUSH_VARS();

    if (node->nd_tbl) {
	VALUE *vars = TMP_ALLOC(node->nd_tbl[0]+1);
	*vars++ = (VALUE)node;
	ruby_scope->local_vars = vars;
	rb_mem_clear(ruby_scope->local_vars, node->nd_tbl[0]);
	ruby_scope->local_tbl = node->nd_tbl;
    }
    else {
	ruby_scope->local_vars = 0;
	ruby_scope->local_tbl  = 0;
    }

    PUSH_CREF(module);
    ruby_frame->cbase = (VALUE)ruby_cref;
    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	if (trace_func) {
	    call_trace_func("class", ruby_current_node, ruby_cbase,
			    ruby_frame->last_func,
			    ruby_frame->last_class);
	}
	result = rb_eval(ruby_cbase, node->nd_next);
    }
    POP_TAG();
    POP_CREF();
    POP_VARS();
    POP_SCOPE();
    POP_CLASS();

    ruby_frame = frame.tmp;
    if (trace_func) {
	call_trace_func("end", ruby_last_node, 0,
			ruby_frame->last_func, ruby_frame->last_class);
    }
    if (state) JUMP_TAG(state);

    return result;
}

int
rb_respond_to(obj, id)
    VALUE obj;
    ID id;
{
    if (rb_method_boundp(CLASS_OF(obj), id, 0)) {
	return Qtrue;
    }
    return Qfalse;
}

static VALUE
rb_obj_respond_to(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE mid, priv;
    ID id;

    rb_scan_args(argc, argv, "11", &mid, &priv);
    id = rb_to_id(mid);
    if (rb_method_boundp(CLASS_OF(obj), id, !RTEST(priv))) {
	return Qtrue;
    }
    return Qfalse;
}

static VALUE
rb_mod_method_defined(mod, mid)
    VALUE mod, mid;
{
    return rb_method_boundp(mod, rb_to_id(mid), 1);
}

#define VISI_CHECK(x,f) (((x)&NOEX_MASK) == (f))

static VALUE
rb_mod_public_method_defined(mod, mid)
    VALUE mod, mid;
{
    VALUE klass;
    ID id = rb_to_id(mid);
    int noex;

    if (rb_get_method_body(&mod, &id, &noex)) {
	if (VISI_CHECK(noex, NOEX_PUBLIC))
	    return Qtrue;
    }
    return Qfalse;
}

static VALUE
rb_mod_private_method_defined(mod, mid)
    VALUE mod, mid;
{
    VALUE klass;
    ID id = rb_to_id(mid);
    int noex;

    if (rb_get_method_body(&mod, &id, &noex)) {
	if (VISI_CHECK(noex, NOEX_PRIVATE))
	    return Qtrue;
    }
    return Qfalse;
}

static VALUE
rb_mod_protected_method_defined(mod, mid)
    VALUE mod, mid;
{
    VALUE klass;
    ID id = rb_to_id(mid);
    int noex;

    if (rb_get_method_body(&mod, &id, &noex)) {
	if (VISI_CHECK(noex, NOEX_PROTECTED))
	    return Qtrue;
    }
    return Qfalse;
}

NORETURN(static void terminate_process _((int, const char*, long)));
static void
terminate_process(status, mesg, mlen)
    int status;
    const char *mesg;
    long mlen;
{
    VALUE exit = rb_exc_new(rb_eSystemExit, mesg, mlen);

    rb_iv_set(exit, "status", INT2NUM(status));
    rb_exc_raise(exit);
}

void
rb_exit(status)
    int status;
{
    if (prot_tag) {
	terminate_process(status, "exit", 4);
    }
    ruby_finalize();
    exit(status);
}

static VALUE
rb_f_exit(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE status;
    int istatus;

    rb_secure(4);
    if (rb_scan_args(argc, argv, "01", &status) == 1) {
	istatus = NUM2INT(status);
    }
    else {
	istatus = 0;
    }
    rb_exit(istatus);
    return Qnil;		/* not reached */
}

static VALUE
rb_f_abort(argc, argv)
    int argc;
    VALUE *argv;
{
    rb_secure(4);
    if (argc == 0) {
	if (!NIL_P(ruby_errinfo)) {
	    error_print();
	}
	rb_exit(1);
    }
    else {
	VALUE mesg;

	rb_scan_args(argc, argv, "1", &mesg);
	StringValue(argv[0]);
	rb_io_puts(argc, argv, rb_stderr);
	terminate_process(1, RSTRING(argv[0])->ptr, RSTRING(argv[0])->len);
    }
    return Qnil;		/* not reached */
}

void
rb_iter_break()
{
    JUMP_TAG(TAG_BREAK);
}

NORETURN(static void rb_longjmp _((int, VALUE)));
static VALUE make_backtrace _((void));

static void
rb_longjmp(tag, mesg)
    int tag;
    VALUE mesg;
{
    VALUE at;

    if (NIL_P(mesg)) mesg = ruby_errinfo;
    if (NIL_P(mesg)) {
	mesg = rb_exc_new(rb_eRuntimeError, 0, 0);
    }

    ruby_set_current_source();
    if (ruby_sourcefile && !NIL_P(mesg)) {
	at = get_backtrace(mesg);
	if (NIL_P(at)) {
	    at = make_backtrace();
	    set_backtrace(mesg, at);
	}
    }
    if (!NIL_P(mesg)) {
	ruby_errinfo = mesg;
    }

    if (RTEST(ruby_debug) && !NIL_P(ruby_errinfo)
	&& !rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
	VALUE e = ruby_errinfo;

	StringValue(e);
	fprintf(stderr, "Exception `%s' at %s:%d - %s\n",
		rb_class2name(CLASS_OF(ruby_errinfo)),
		ruby_sourcefile, ruby_sourceline,
		RSTRING(e)->ptr);
	fflush(stderr);
    }

    rb_trap_restore_mask();
    if (trace_func && tag != TAG_FATAL) {
	call_trace_func("raise", ruby_current_node,
			ruby_frame->self,
			ruby_frame->last_func,
			ruby_frame->last_class);
    }
    if (!prot_tag) {
	error_print();
    }
    JUMP_TAG(tag);
}

void
rb_exc_raise(mesg)
    VALUE mesg;
{
    rb_longjmp(TAG_RAISE, mesg);
}

void
rb_exc_fatal(mesg)
    VALUE mesg;
{
    rb_longjmp(TAG_FATAL, mesg);
}

void
rb_interrupt()
{
    rb_raise(rb_eInterrupt, "");
}

static VALUE
rb_f_raise(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE mesg;
    ID exception;
    int n;

    mesg = Qnil;
    switch (argc) {
      case 0:
	mesg = Qnil;
	break;
      case 1:
	if (NIL_P(argv[0])) break;
	if (TYPE(argv[0]) == T_STRING) {
	    mesg = rb_exc_new3(rb_eRuntimeError, argv[0]);
	    break;
	}
	n = 0;
	goto exception_call;

      case 2:
      case 3:
	n = 1;
      exception_call:
	exception = rb_intern("exception");
	if (!rb_respond_to(argv[0], exception)) {
	    rb_raise(rb_eTypeError, "exception class/object expected");
	}
	mesg = rb_funcall(argv[0], exception, n, argv[1]);
	break;
      default:
	rb_raise(rb_eArgError, "wrong number of arguments");
	break;
    }
    if (argc > 0) {
	if (!rb_obj_is_kind_of(mesg, rb_eException))
	    rb_raise(rb_eTypeError, "exception object expected");
	set_backtrace(mesg, (argc>2)?argv[2]:Qnil);
    }

    if (ruby_frame != top_frame) {
	PUSH_FRAME();		/* fake frame */
	*ruby_frame = *_frame.prev->prev;
	rb_longjmp(TAG_RAISE, mesg);
	POP_FRAME();
    }
    rb_longjmp(TAG_RAISE, mesg);

    return Qnil;		/* not reached */
}

void
rb_jump_tag(tag)
    int tag;
{
    JUMP_TAG(tag);
}

int
rb_block_given_p()
{
    if (ruby_frame->iter && ruby_block)
	return Qtrue;
    return Qfalse;
}

int
rb_iterator_p()
{
    return rb_block_given_p();
}

static VALUE
rb_f_block_given_p()
{
    if (ruby_frame->prev && ruby_frame->prev->iter && ruby_block)
	return Qtrue;
    return Qfalse;
}

static VALUE
rb_yield_0(val, self, klass, pcall)
    VALUE val, self, klass;	/* OK */
    int pcall;
{
    NODE *node;
    volatile VALUE result = Qnil;
    volatile VALUE old_cref;
    volatile VALUE old_wrapper;
    struct BLOCK * volatile block;
    struct SCOPE * volatile old_scope;
    struct FRAME frame;
    NODE *cnode = ruby_current_node;
    int state;
    static unsigned serial = 1;

    if (!rb_block_given_p()) {
	localjump_error("no block given", Qnil);
    }

    PUSH_VARS();
    PUSH_CLASS();
    block = ruby_block;
    frame = block->frame;
    frame.prev = ruby_frame;
    ruby_frame = &(frame);
    old_cref = (VALUE)ruby_cref;
    ruby_cref = (NODE*)ruby_frame->cbase;
    old_wrapper = ruby_wrapper;
    ruby_wrapper = block->wrapper;
    old_scope = ruby_scope;
    ruby_scope = block->scope;
    ruby_block = block->prev;
    if (block->flags & BLOCK_D_SCOPE) {
	/* put place holder for dynamic (in-block) local variables */
	ruby_dyna_vars = new_dvar(0, 0, block->dyna_vars);
    }
    else {
	/* FOR does not introduce new scope */
	ruby_dyna_vars = block->dyna_vars;
    }
    ruby_class = klass?klass:block->klass;
    if (!klass) self = block->self;
    node = block->body;

    if (block->var) {
	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    if (block->var == (NODE*)1) {
		if (pcall && RARRAY(val)->len != 0) {
		    rb_raise(rb_eArgError, "wrong number of arguments (%ld for 0)",
			     RARRAY(val)->len);
		}
	    }
	    else if (block->var == (NODE*)2) {
		if (TYPE(val) == T_ARRAY && RARRAY(val)->len != 0) {
		    rb_raise(rb_eArgError, "wrong number of arguments (%ld for 0)",
			     RARRAY(val)->len);
		}
	    }
	    else if (nd_type(block->var) == NODE_MASGN) {
		massign(self, block->var, val, pcall);
	    }
	    else {
		if (pcall) {
		    val = avalue_to_yvalue(val);
		}
		assign(self, block->var, val, pcall);
	    }
	}
	POP_TAG();
	if (state) goto pop_state;
    }
    else if (pcall) {
	val = avalue_to_yvalue(val);
    }

    PUSH_ITER(block->iter);
    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
      redo:
	if (!node) {
	    result = Qnil;
	}
	else if (nd_type(node) == NODE_CFUNC || nd_type(node) == NODE_IFUNC) {
	    result = (*node->nd_cfnc)(val, node->nd_tval, self);
	}
	else {
	    result = rb_eval(self, node);
	}
    }
    else {
	switch (state) {
	  case TAG_REDO:
	    state = 0;
	    CHECK_INTS;
	    goto redo;
	  case TAG_NEXT:
	    state = 0;
	    result = prot_tag->retval;
	    break;
	  case TAG_BREAK:
	  case TAG_RETURN:
	    state |= (serial++ << 8);
	    state |= 0x10;
	    block->tag->dst = state;
	    break;
	  default:
	    break;
	}
    }
    POP_TAG();
    POP_ITER();
  pop_state:
    POP_CLASS();
    if (ruby_dyna_vars && (block->flags & BLOCK_D_SCOPE) &&
	!FL_TEST(ruby_dyna_vars, DVAR_DONT_RECYCLE)) {
	struct RVarmap *vars = ruby_dyna_vars;

	if (ruby_dyna_vars->id == 0) {
	    vars = ruby_dyna_vars->next;
	    rb_gc_force_recycle((VALUE)ruby_dyna_vars);
	    while (vars && vars->id != 0 && vars != block->dyna_vars) {
		struct RVarmap *tmp = vars->next;
		rb_gc_force_recycle((VALUE)vars);
		vars = tmp;
	    }
	}
    }
    POP_VARS();
    ruby_block = block;
    ruby_frame = ruby_frame->prev;
    ruby_cref = (NODE*)old_cref;
    ruby_wrapper = old_wrapper;
    if (ruby_scope->flags & SCOPE_DONT_RECYCLE)
       scope_dup(old_scope);
    ruby_scope = old_scope;
    ruby_current_node = cnode;
    if (state) {
	if (!block->tag) {
	    switch (state & TAG_MASK) {
	      case TAG_BREAK:
	      case TAG_RETURN:
		jump_tag_but_local_jump(state & TAG_MASK);
		break;
	    }
	}
	JUMP_TAG(state);
    }
    return result;
}

VALUE
rb_yield(val)
    VALUE val;
{
    return rb_yield_0(val, 0, 0, 0);
}

static VALUE
rb_f_loop()
{
    for (;;) {
	rb_yield_0(Qundef, 0, 0, 0);
	CHECK_INTS;
    }
    return Qnil;		/* dummy */
}

static VALUE
massign(self, node, val, pcall)
    VALUE self;
    NODE *node;
    VALUE val;
    int pcall;
{
    NODE *list;
    long i = 0, len;

    if (!pcall) {
	val = svalue_to_mvalue(val);
    }
    len = RARRAY(val)->len;
    list = node->nd_head;
    for (i=0; list && i<len; i++) {
	assign(self, list->nd_head, RARRAY(val)->ptr[i], pcall);
	list = list->nd_next;
    }
    if (pcall && list) goto arg_error;
    if (node->nd_args) {
	if (node->nd_args == (NODE*)-1) {
	    /* no check for mere `*' */
	}
	else if (!list && i<len) {
	    assign(self, node->nd_args, rb_ary_new4(len-i, RARRAY(val)->ptr+i), pcall);
	}
	else {
	    assign(self, node->nd_args, rb_ary_new2(0), pcall);
	}
    }
    else if (pcall && i < len) {
	goto arg_error;
    }

    while (list) {
	i++;
	assign(self, list->nd_head, Qnil, pcall);
	list = list->nd_next;
    }
    return val;

  arg_error:
    while (list) {
	i++;
	list = list->nd_next;
    }
    rb_raise(rb_eArgError, "wrong number of arguments (%ld for %ld)", len, i);
}

static void
assign(self, lhs, val, pcall)
    VALUE self;
    NODE *lhs;
    VALUE val;
    int pcall;
{
    ruby_current_node = lhs;
    if (val == Qundef) {
	rb_warning("assigning void value");
	val = Qnil;
    }
    switch (nd_type(lhs)) {
      case NODE_GASGN:
	rb_gvar_set(lhs->nd_entry, val);
	break;

      case NODE_IASGN:
	rb_ivar_set(self, lhs->nd_vid, val);
	break;

      case NODE_LASGN:
	if (ruby_scope->local_vars == 0)
	    rb_bug("unexpected local variable assignment");
	ruby_scope->local_vars[lhs->nd_cnt] = val;
	break;

      case NODE_DASGN:
	dvar_asgn(lhs->nd_vid, val);
	break;

      case NODE_DASGN_CURR:
	dvar_asgn_curr(lhs->nd_vid, val);
	break;

      case NODE_CDECL:
	rb_const_set(ruby_cbase, lhs->nd_vid, val);
	break;

      case NODE_CVDECL:
	if (RTEST(ruby_verbose) && FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    rb_warn("declaring singleton class variable");
	}
	rb_cvar_set(cvar_cbase(), lhs->nd_vid, val, Qtrue);
	break;

      case NODE_CVASGN:
	rb_cvar_set(cvar_cbase(), lhs->nd_vid, val, Qfalse);
	break;

      case NODE_MASGN:
	massign(self, lhs, svalue_to_mvalue(val), pcall);
	break;

      case NODE_CALL:
	{
	    VALUE recv;
	    recv = rb_eval(self, lhs->nd_recv);
	    if (!lhs->nd_args) {
		/* attr set */
		ruby_current_node = lhs;
		SET_CURRENT_SOURCE();
		rb_call(CLASS_OF(recv), recv, lhs->nd_mid, 1, &val, 0);
	    }
	    else {
		/* array set */
		VALUE args;

		args = rb_eval(self, lhs->nd_args);
		rb_ary_push(args, val);
		ruby_current_node = lhs;
		SET_CURRENT_SOURCE();
		rb_call(CLASS_OF(recv), recv, lhs->nd_mid,
			RARRAY(args)->len, RARRAY(args)->ptr, 0);
	    }
	}
	break;

      default:
	rb_bug("bug in variable assignment");
	break;
    }
}

VALUE
rb_iterate(it_proc, data1, bl_proc, data2)
    VALUE (*it_proc) _((VALUE)), (*bl_proc)(ANYARGS);
    VALUE data1, data2;
{
    int state;
    volatile VALUE retval = Qnil;
    NODE *node = NEW_IFUNC(bl_proc, data2);
    VALUE self = ruby_top_self;

  iter_retry:
    PUSH_ITER(ITER_PRE);
    PUSH_BLOCK(0, node);
    PUSH_TAG(PROT_NONE);

    state = EXEC_TAG();
    if (state == 0) {
	retval = (*it_proc)(data1);
    }
    if (ruby_block->tag->dst == state) {
	state &= TAG_MASK;
	if (state == TAG_RETURN || state == TAG_BREAK) {
	    retval = prot_tag->retval;
	}
    }
    POP_TAG();
    POP_BLOCK();
    POP_ITER();

    switch (state) {
      case 0:
	break;

      case TAG_RETRY:
	goto iter_retry;

      case TAG_BREAK:
	break;

      case TAG_RETURN:
	return_value(retval);
	/* fall through */
      default:
	JUMP_TAG(state);
    }
    return retval;
}

static int
handle_rescue(self, node)
    VALUE self;
    NODE *node;
{
    int argc; VALUE *argv; /* used in SETUP_ARGS */
    TMP_PROTECT;

    if (!node->nd_args) {
	return rb_obj_is_kind_of(ruby_errinfo, rb_eStandardError);
    }

    BEGIN_CALLARGS;
    SETUP_ARGS(node->nd_args);
    END_CALLARGS;

    while (argc--) {
	if (!rb_obj_is_kind_of(argv[0], rb_cModule)) {
	    rb_raise(rb_eTypeError, "class or module required for rescue clause");
	}
	if (RTEST(rb_funcall(*argv, eqq, 1, ruby_errinfo))) return 1;
	argv++;
    }
    return 0;
}

VALUE
#ifdef HAVE_STDARG_PROTOTYPES
rb_rescue2(VALUE (*b_proc)(ANYARGS), VALUE data1, VALUE (*r_proc)(ANYARGS), VALUE data2, ...)
#else
rb_rescue2(b_proc, data1, r_proc, data2, va_alist)
    VALUE (*b_proc)(ANYARGS), (*r_proc)(ANYARGS);
    VALUE data1, data2;
    va_dcl
#endif
{
    int state;
    volatile VALUE result;
    volatile VALUE e_info = ruby_errinfo;
    va_list args;

    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
      retry_entry:
	result = (*b_proc)(data1);
    }
    else if (state == TAG_RAISE) {
	int handle = Qfalse;
	VALUE eclass;

	va_init_list(args, data2);
	while (eclass = va_arg(args, VALUE)) {
	    if (rb_obj_is_kind_of(ruby_errinfo, eclass)) {
		handle = Qtrue;
		break;
	    }
	}
	va_end(args);

	if (handle) {
	    if (r_proc) {
		PUSH_TAG(PROT_NONE);
		if ((state = EXEC_TAG()) == 0) {
		    result = (*r_proc)(data2, ruby_errinfo);
		}
		POP_TAG();
		if (state == TAG_RETRY) {
		    state = 0;
		    ruby_errinfo = Qnil;
		    goto retry_entry;
		}
	    }
	    else {
		result = Qnil;
		state = 0;
	    }
	    if (state == 0) {
		ruby_errinfo = e_info;
	    }
	}
    }
    POP_TAG();
    if (state) JUMP_TAG(state);

    return result;
}

VALUE
rb_rescue(b_proc, data1, r_proc, data2)
    VALUE (*b_proc)(), (*r_proc)();
    VALUE data1, data2;
{
    return rb_rescue2(b_proc, data1, r_proc, data2, rb_eStandardError, 0);
}

VALUE
rb_protect(proc, data, state)
    VALUE (*proc) _((VALUE));
    VALUE data;
    int *state;
{
    VALUE result;		/* OK */
    int status;

    PUSH_TAG(PROT_NONE);
    if ((status = EXEC_TAG()) == 0) {
	result = (*proc)(data);
    }
    POP_TAG();
    if (state) {
	*state = status;
    }
    if (status != 0) {
	return Qnil;
    }

    return result;
}

VALUE
rb_ensure(b_proc, data1, e_proc, data2)
    VALUE (*b_proc)();
    VALUE data1;
    VALUE (*e_proc)();
    VALUE data2;
{
    int state;
    volatile VALUE result = Qnil;
    VALUE retval;

    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	result = (*b_proc)(data1);
    }
    POP_TAG();
    retval = prot_tag ? prot_tag->retval : Qnil;	/* save retval */
    (*e_proc)(data2);
    if (prot_tag) return_value(retval);

    if (state) JUMP_TAG(state);
    return result;
}

VALUE
rb_with_disable_interrupt(proc, data)
    VALUE (*proc)();
    VALUE data;
{
    VALUE result;		/* OK */
    int status;

    DEFER_INTS;
    PUSH_TAG(PROT_NONE);
    if ((status = EXEC_TAG()) == 0) {
	result = (*proc)(data);
    }
    POP_TAG();
    ALLOW_INTS;
    if (status) JUMP_TAG(status);

    return result;
}

static void
stack_check()
{
    static int overflowing = 0;

    if (!overflowing && ruby_stack_check()) {
	int state;
	overflowing = 1;
	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    rb_raise(rb_eSysStackError, "stack level too deep");
	}
	POP_TAG();
	overflowing = 0;
	JUMP_TAG(state);
    }
}

static int last_call_status;

#define CSTAT_PRIV  1
#define CSTAT_PROT  2
#define CSTAT_VCALL 4

static VALUE
rb_f_missing(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    ID id;
    VALUE exc = rb_eNoMethodError;
    volatile VALUE d = 0;
    char *format = 0;
    char *desc = "";
    NODE *cnode = ruby_current_node;

    if (argc == 0 || !SYMBOL_P(argv[0])) {
	rb_raise(rb_eArgError, "no id given");
    }

    stack_check();

    id = SYM2ID(argv[0]);

    switch (TYPE(obj)) {
      case T_NIL:
	desc = "nil";
	break;
      case T_TRUE:
	desc = "true";
	break;
      case T_FALSE:
	desc = "false";
	break;
      case T_OBJECT:
	d = rb_any_to_s(obj);
	break;
      default:
	d = rb_inspect(obj);
	break;
    }
    if (d) {
	if (RSTRING(d)->len > 65) {
	    d = rb_any_to_s(obj);
	}
	desc = RSTRING(d)->ptr;
    }

    if (last_call_status & CSTAT_PRIV) {
	format = "private method `%s' called for %s%s%s";
    }
    if (last_call_status & CSTAT_PROT) {
	format = "protected method `%s' called for %s%s%s";
    }
    else if (last_call_status & CSTAT_VCALL) {
	const char *mname = rb_id2name(id);

	if (('a' <= mname[0] && mname[0] <= 'z') || mname[0] == '_') {
	    format = "undefined local variable or method `%s' for %s%s%s";
	    exc = rb_eNameError;
	}
    }
    if (!format) {
	format = "undefined method `%s' for %s%s%s";
    }

    ruby_current_node = cnode;
    PUSH_FRAME();		/* fake frame */
    *ruby_frame = *_frame.prev->prev;
    {
	char buf[BUFSIZ];
	int noclass = (!d || desc[0]=='#');

	snprintf(buf, BUFSIZ, format, rb_id2name(id),
		 desc, noclass ? "" : ":",
		 noclass ? "" : rb_class2name(CLASS_OF(obj)));
	exc = rb_exc_new2(exc, buf);
	rb_iv_set(exc, "name", argv[0]);
	rb_iv_set(exc, "args", rb_ary_new4(argc-1, argv+1));
	rb_exc_raise(exc);
    }
    POP_FRAME();

    return Qnil;		/* not reached */
}

static VALUE
rb_undefined(obj, id, argc, argv, call_status)
    VALUE obj;
    ID    id;
    int   argc;
    VALUE*argv;
    int   call_status;
{
    VALUE *nargv;

    last_call_status = call_status;

    if (id == missing) {
	PUSH_FRAME();
	rb_f_missing(argc, argv, obj);
	POP_FRAME();
    }

    nargv = ALLOCA_N(VALUE, argc+1);
    nargv[0] = ID2SYM(id);
    MEMCPY(nargv+1, argv, VALUE, argc);

    return rb_funcall2(obj, missing, argc+1, nargv);
}

static VALUE
call_cfunc(func, recv, len, argc, argv)
    VALUE (*func)();
    VALUE recv;
    int len, argc;
    VALUE *argv;
{
    if (len >= 0 && argc != len) {
	rb_raise(rb_eArgError, "wrong number of arguments(%d for %d)",
		 argc, len);
    }

    switch (len) {
      case -2:
	return (*func)(recv, rb_ary_new4(argc, argv));
	break;
      case -1:
	return (*func)(argc, argv, recv);
	break;
      case 0:
	return (*func)(recv);
	break;
      case 1:
	return (*func)(recv, argv[0]);
	break;
      case 2:
	return (*func)(recv, argv[0], argv[1]);
	break;
      case 3:
	return (*func)(recv, argv[0], argv[1], argv[2]);
	break;
      case 4:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3]);
	break;
      case 5:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4]);
	break;
      case 6:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5]);
	break;
      case 7:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6]);
	break;
      case 8:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7]);
	break;
      case 9:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8]);
	break;
      case 10:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9]);
	break;
      case 11:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10]);
	break;
      case 12:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9],
		       argv[10], argv[11]);
	break;
      case 13:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10],
		       argv[11], argv[12]);
	break;
      case 14:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10],
		       argv[11], argv[12], argv[13]);
	break;
      case 15:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10],
		       argv[11], argv[12], argv[13], argv[14]);
	break;
      default:
	rb_raise(rb_eArgError, "too many arguments(%d)", len);
	break;
    }
    return Qnil;		/* not reached */
}

static VALUE
rb_call0(klass, recv, id, oid, argc, argv, body, nosuper)
    VALUE klass, recv;
    ID    id;
    ID    oid;
    int argc;			/* OK */
    VALUE *argv;		/* OK */
    NODE *body;			/* OK */
    int nosuper;
{
    NODE *b2;		/* OK */
    volatile VALUE result = Qnil;
    int itr;
    static int tick;
    TMP_PROTECT;

    switch (ruby_iter->iter) {
      case ITER_PRE:
	itr = ITER_CUR;
	break;
      case ITER_CUR:
      default:
	itr = ITER_NOT;
	break;
    }

    if ((++tick & 0xff) == 0) {
	CHECK_INTS;		/* better than nothing */
	stack_check();
    }
    PUSH_ITER(itr);
    PUSH_FRAME();

    ruby_frame->last_func = id;
    ruby_frame->orig_func = oid;
    ruby_frame->last_class = nosuper?0:klass;
    ruby_frame->self = recv;
    ruby_frame->argc = argc;
    ruby_frame->argv = argv;

    switch (nd_type(body)) {
      case NODE_CFUNC:
	{
	    int len = body->nd_argc;

	    if (len < -2) {
		rb_bug("bad argc(%d) specified for `%s(%s)'",
		       len, rb_class2name(klass), rb_id2name(id));
	    }
	    if (trace_func) {
		int state;
		volatile int old_tracing = tracing;

		call_trace_func("c-call", ruby_current_node, recv, id, klass);
		DISABLE_TRACE();
		PUSH_TAG(PROT_FUNC);
		if ((state = EXEC_TAG()) == 0) {
		    result = call_cfunc(body->nd_cfnc, recv, len, argc, argv);
		}
		POP_TAG();
		tracing = old_tracing;
		ruby_current_node = ruby_frame->node;
		call_trace_func("c-return", ruby_current_node, recv, id, klass);
		if (state) JUMP_TAG(state);
	    }
	    else {
		result = call_cfunc(body->nd_cfnc, recv, len, argc, argv);
	    }
	}
	break;

	/* for attr get/set */
      case NODE_IVAR:
	if (argc != 0) {
	    rb_raise(rb_eArgError, "wrong number of arguments(%d for 0)", argc);
	}
      case NODE_ATTRSET:
	/* for re-scoped/renamed method */
      case NODE_ZSUPER:
	result = rb_eval(recv, body);
	break;

      case NODE_DMETHOD:
	result = method_call(argc, argv, umethod_bind(body->nd_cval, recv));
	break;

      case NODE_BMETHOD:
	result = proc_invoke(body->nd_cval, rb_ary_new4(argc, argv), Qtrue, recv);
	break;

      case NODE_SCOPE:
	{
	    int state;
	    VALUE *local_vars;	/* OK */
	    NODE *saved_cref = 0;

	    PUSH_SCOPE();

	    if (body->nd_rval) {
		saved_cref = ruby_cref;
		ruby_cref = (NODE*)body->nd_rval;
		ruby_frame->cbase = body->nd_rval;
	    }
	    if (body->nd_tbl) {
		local_vars = TMP_ALLOC(body->nd_tbl[0]+1);
		*local_vars++ = (VALUE)body;
		rb_mem_clear(local_vars, body->nd_tbl[0]);
		ruby_scope->local_tbl = body->nd_tbl;
		ruby_scope->local_vars = local_vars;
	    }
	    else {
		local_vars = ruby_scope->local_vars = 0;
		ruby_scope->local_tbl  = 0;
	    }
	    b2 = body = body->nd_next;

	    PUSH_VARS();
	    PUSH_TAG(PROT_FUNC);

	    if ((state = EXEC_TAG()) == 0) {
		NODE *node = 0;
		int i;

		if (nd_type(body) == NODE_ARGS) {
		    node = body;
		    body = 0;
		}
		else if (nd_type(body) == NODE_BLOCK) {
		    node = body->nd_head;
		    body = body->nd_next;
		}
		if (node) {
		    if (nd_type(node) != NODE_ARGS) {
			rb_bug("no argument-node");
		    }

		    i = node->nd_cnt;
		    if (i > argc) {
			rb_raise(rb_eArgError, "wrong number of arguments(%d for %d)",
				 argc, i);
		    }
		    if (node->nd_rest == -1) {
			int opt = i;
			NODE *optnode = node->nd_opt;

			while (optnode) {
			    opt++;
			    optnode = optnode->nd_next;
			}
			if (opt < argc) {
			    rb_raise(rb_eArgError, "wrong number of arguments(%d for %d)",
				     argc, opt);
			}
			ruby_frame->argc = opt;
			ruby_frame->argv = local_vars+2;
		    }

		    if (local_vars) {
			if (i > 0) {
			    /* +2 for $_ and $~ */
			    MEMCPY(local_vars+2, argv, VALUE, i);
			}
			argv += i; argc -= i;
			if (node->nd_opt) {
			    NODE *opt = node->nd_opt;

			    while (opt && argc) {
				assign(recv, opt->nd_head, *argv, 1);
				argv++; argc--;
				opt = opt->nd_next;
			    }
			    if (opt) {
				rb_eval(recv, opt);
			    }
			}
			local_vars = ruby_scope->local_vars;
			if (node->nd_rest >= 0) {
			    VALUE v;

			    if (argc > 0)
				v = rb_ary_new4(argc,argv);
			    else
				v = rb_ary_new2(0);
			    ruby_scope->local_vars[node->nd_rest] = v;
			}
		    }
		}

		if (trace_func) {
		    call_trace_func("call", b2, recv, id, klass);
		}
		ruby_last_node = b2;
		result = rb_eval(recv, body);
	    }
	    else if (state == TAG_RETURN) {
		result = prot_tag->retval;
		state = 0;
	    }
	    POP_TAG();
	    POP_VARS();
	    POP_SCOPE();
	    ruby_cref = saved_cref;
	    if (trace_func) {
		call_trace_func("return", ruby_last_node, recv, id, klass);
	    }
	    switch (state) {
	      case 0:
		break;

	      case TAG_RETRY:
		if (rb_block_given_p()) {
                   JUMP_TAG(state);
		}
		/* fall through */
	      default:
		jump_tag_but_local_jump(state);
		break;
	    }
	}
	break;

      default:
	rb_bug("unknown node type %d", nd_type(body));
	break;
    }
    POP_FRAME();
    POP_ITER();
    return result;
}

static VALUE
rb_call(klass, recv, mid, argc, argv, scope)
    VALUE klass, recv;
    ID    mid;
    int argc;			/* OK */
    const VALUE *argv;		/* OK */
    int scope;
{
    NODE  *body;		/* OK */
    int    noex;
    ID     id = mid;
    struct cache_entry *ent;

    if (!klass) {
	rb_raise(rb_eNotImpError, "method `%s' called on terminated object (0x%lx)",
		 rb_id2name(mid), recv);
    }
    /* is it in the method cache? */
    ent = cache + EXPR1(klass, mid);
    if (ent->mid == mid && ent->klass == klass) {
	if (!ent->method)
	    return rb_undefined(recv, mid, argc, argv, scope==2?CSTAT_VCALL:0);
	klass = ent->origin;
	id    = ent->mid0;
	noex  = ent->noex;
	body  = ent->method;
    }
    else if ((body = rb_get_method_body(&klass, &id, &noex)) == 0) {
	if (scope == 3) {
	    rb_name_error(mid, "super: no superclass method `%s'",
			  rb_id2name(mid));
	}
	return rb_undefined(recv, mid, argc, argv, scope==2?CSTAT_VCALL:0);
    }

    if (mid != missing) {
	/* receiver specified form for private method */
	if ((noex & NOEX_PRIVATE) && scope == 0)
	    return rb_undefined(recv, mid, argc, argv, CSTAT_PRIV);

	/* self must be kind of a specified form for private method */
	if ((noex & NOEX_PROTECTED)) {
	    VALUE defined_class = klass;

	    if (TYPE(defined_class) == T_ICLASS) {
		defined_class = RBASIC(defined_class)->klass;
	    }
	    if (!rb_obj_is_kind_of(ruby_frame->self, rb_class_real(defined_class)))
		return rb_undefined(recv, mid, argc, argv, CSTAT_PROT);
	}
    }

    return rb_call0(klass, recv, mid, id, argc, argv, body, noex & NOEX_UNDEF);
}

VALUE
rb_apply(recv, mid, args)
    VALUE recv;
    ID mid;
    VALUE args;
{
    int argc;
    VALUE *argv;

    argc = RARRAY(args)->len; /* Assigns LONG, but argc is INT */
    argv = ALLOCA_N(VALUE, argc);
    MEMCPY(argv, RARRAY(args)->ptr, VALUE, argc);
    return rb_call(CLASS_OF(recv), recv, mid, argc, argv, 1);
}

static VALUE
rb_f_send(argc, argv, recv)
    int argc;
    VALUE *argv;
    VALUE recv;
{
    VALUE vid;

    if (argc == 0) rb_raise(rb_eArgError, "no method name given");

    vid = *argv++; argc--;
    PUSH_ITER(rb_block_given_p()?ITER_PRE:ITER_NOT);
    vid = rb_call(CLASS_OF(recv), recv, rb_to_id(vid), argc, argv, 1);
    POP_ITER();

    return vid;
}

#ifdef HAVE_STDARG_PROTOTYPES
#include <stdarg.h>
#define va_init_list(a,b) va_start(a,b)
#else
#include <varargs.h>
#define va_init_list(a,b) va_start(a)
#endif

VALUE
#ifdef HAVE_STDARG_PROTOTYPES
rb_funcall(VALUE recv, ID mid, int n, ...)
#else
rb_funcall(recv, mid, n, va_alist)
    VALUE recv;
    ID mid;
    int n;
    va_dcl
#endif
{
    va_list ar;
    VALUE *argv;

    if (n > 0) {
	long i;

	argv = ALLOCA_N(VALUE, n);

	va_init_list(ar, n);
	for (i=0;i<n;i++) {
	    argv[i] = va_arg(ar, VALUE);
	}
	va_end(ar);
    }
    else {
	argv = 0;
    }

    return rb_call(CLASS_OF(recv), recv, mid, n, argv, 1);
}

VALUE
rb_funcall2(recv, mid, argc, argv)
    VALUE recv;
    ID mid;
    int argc;
    const VALUE *argv;
{
    return rb_call(CLASS_OF(recv), recv, mid, argc, argv, 1);
}

VALUE
rb_funcall3(recv, mid, argc, argv)
    VALUE recv;
    ID mid;
    int argc;
    const VALUE *argv;
{
    return rb_call(CLASS_OF(recv), recv, mid, argc, argv, 0);
}

VALUE
rb_call_super(argc, argv)
    int argc;
    const VALUE *argv;
{
    VALUE result;

    if (ruby_frame->last_class == 0) {	
	rb_name_error(ruby_frame->last_func, "superclass method `%s' must be enabled by rb_enable_super()",
		      rb_id2name(ruby_frame->last_func));
    }

    PUSH_ITER(ruby_iter->iter?ITER_PRE:ITER_NOT);
    result = rb_call(RCLASS(ruby_frame->last_class)->super,
		     ruby_frame->self, ruby_frame->last_func,
		     argc, argv, 3);
    POP_ITER();

    return result;
}

static VALUE
backtrace(lev)
    int lev;
{
    struct FRAME *frame = ruby_frame;
    char buf[BUFSIZ];
    VALUE ary;
    NODE *n;

    ary = rb_ary_new();
    if (lev < 0) {
	ruby_set_current_source();
	if (frame->last_func) {
	    snprintf(buf, BUFSIZ, "%s:%d:in `%s'",
		     ruby_sourcefile, ruby_sourceline,
		     rb_id2name(frame->last_func));
	}
	else if (ruby_sourceline == 0) {
	    snprintf(buf, BUFSIZ, "%s", ruby_sourcefile);
	}
	else {
	    snprintf(buf, BUFSIZ, "%s:%d", ruby_sourcefile, ruby_sourceline);
	}
	rb_ary_push(ary, rb_str_new2(buf));
    }
    else {
	while (lev-- > 0) {
	    frame = frame->prev;
	    if (!frame) {
		ary = Qnil;
		break;
	    }
	}
    }
    while (frame && (n = frame->node)) {
	if (frame->prev && frame->prev->last_func) {
	    snprintf(buf, BUFSIZ, "%s:%d:in `%s'",
		     n->nd_file, nd_line(n),
		     rb_id2name(frame->prev->last_func));
	}
	else {
	    snprintf(buf, BUFSIZ, "%s:%d", n->nd_file, nd_line(n));
	}
	rb_ary_push(ary, rb_str_new2(buf));
	frame = frame->prev;
    }

    return ary;
}

static VALUE
rb_f_caller(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE level;
    int lev;

    rb_scan_args(argc, argv, "01", &level);

    if (NIL_P(level)) lev = 1;
    else lev = NUM2INT(level);
    if (lev < 0) rb_raise(rb_eArgError, "negative level(%d)", lev);

    return backtrace(lev);
}

void
rb_backtrace()
{
    long i;
    VALUE ary;

    ary = backtrace(-1);
    for (i=0; i<RARRAY(ary)->len; i++) {
	printf("\tfrom %s\n", RSTRING(RARRAY(ary)->ptr[i])->ptr);
    }
}

static VALUE
make_backtrace()
{
    return backtrace(-1);
}

ID
rb_frame_last_func()
{
    return ruby_frame->last_func;
}

static NODE*
compile(src, file, line)
    VALUE src;
    char *file;
    int line;
{
    NODE *node;

    ruby_nerrs = 0;
    Check_Type(src, T_STRING);
    node = rb_compile_string(file, src, line);

    if (ruby_nerrs == 0) return node;
    return 0;
}

static VALUE
eval(self, src, scope, file, line)
    VALUE self, src, scope;
    char *file;
    int line;
{
    struct BLOCK *data = NULL;
    volatile VALUE result = Qnil;
    struct SCOPE * volatile old_scope;
    struct BLOCK * volatile old_block;
    struct RVarmap * volatile old_dyna_vars;
    VALUE volatile old_cref;
    int volatile old_vmode;
    volatile VALUE old_wrapper;
    struct FRAME frame;
    NODE *nodesave = ruby_current_node;
    volatile int iter = ruby_frame->iter;
    volatile int old_tracing = tracing;
    int state;

    if (!NIL_P(scope)) {
	if (!rb_obj_is_block(scope)) {
	    rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc/Binding)",
		     rb_class2name(CLASS_OF(scope)));
	}

	Data_Get_Struct(scope, struct BLOCK, data);
	/* PUSH BLOCK from data */
	frame = data->frame;
	frame.tmp = ruby_frame;	/* gc protection */
	ruby_frame = &(frame);
	old_scope = ruby_scope;
	ruby_scope = data->scope;
	old_block = ruby_block;
	ruby_block = data->prev;
	old_dyna_vars = ruby_dyna_vars;
	ruby_dyna_vars = data->dyna_vars;
	old_vmode = scope_vmode;
	scope_vmode = data->vmode;
	old_cref = (VALUE)ruby_cref;
	ruby_cref = (NODE*)ruby_frame->cbase;
	old_wrapper = ruby_wrapper;
	ruby_wrapper = data->wrapper;
	if ((file == 0 || (line == 1 && strcmp(file, "(eval)") == 0)) &&
	    data->body && data->body->nd_file) {
	    file = data->body->nd_file;
	    line = nd_line(data->body);
	}

	self = data->self;
	ruby_frame->iter = data->iter;
    }
    else {
	if (ruby_frame->prev) {
	    ruby_frame->iter = ruby_frame->prev->iter;
	}
    }
    if (file == 0) {
	ruby_set_current_source();
	file = ruby_sourcefile;
	line = ruby_sourceline;
    }
    PUSH_CLASS();
    ruby_class = ruby_cbase;

    ruby_in_eval++;
    if (TYPE(ruby_class) == T_ICLASS) {
	ruby_class = RBASIC(ruby_class)->klass;
    }
    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	NODE *node;

	result = ruby_errinfo;
	ruby_errinfo = Qnil;
	node = compile(src, file, line);
	if (ruby_nerrs > 0) {
	    compile_error(0);
	}
	if (!NIL_P(result)) ruby_errinfo = result;
	ENABLE_TRACE();
	result = eval_node(self, node); 
    }
    POP_TAG();
    POP_CLASS();
    ruby_in_eval--;
    if (!NIL_P(scope)) {
	int dont_recycle = ruby_scope->flags & SCOPE_DONT_RECYCLE;

	ruby_wrapper = old_wrapper;
	ruby_cref  = (NODE*)old_cref;
	ruby_frame = frame.tmp;
	ruby_scope = old_scope;
	ruby_block = old_block;
	ruby_dyna_vars = old_dyna_vars;
	data->vmode = scope_vmode; /* write back visibility mode */
	scope_vmode = old_vmode;
	if (dont_recycle) {
	   struct tag *tag;
	   struct RVarmap *vars;

           scope_dup(ruby_scope);
	   for (tag=prot_tag; tag; tag=tag->prev) {
	       scope_dup(tag->scope);
	   }
	   if (ruby_block) {
	       struct BLOCK *block = ruby_block;
	       while (block) {
		   block->tag->flags |= BLOCK_DYNAMIC;
		   block = block->prev;
	       }
	   }
	   for (vars = ruby_dyna_vars; vars; vars = vars->next) {
	       FL_SET(vars, DVAR_DONT_RECYCLE);
	   }
	}
    }
    else {
	ruby_frame->iter = iter;
    }
    ruby_current_node = nodesave;
    ruby_set_current_source();
    tracing = old_tracing;
    if (state) {
	if (state == TAG_RAISE) {
	    VALUE err;
	    VALUE errat;

	    if (strcmp(file, "(eval)") == 0) {
		if (ruby_sourceline > 1) {
		    errat = get_backtrace(ruby_errinfo);
		    err = rb_str_dup(RARRAY(errat)->ptr[0]);
		    rb_str_cat2(err, ": ");
		    rb_str_append(err, ruby_errinfo);
		}
		else {
		    err = rb_str_dup(ruby_errinfo);
		}
		rb_exc_raise(rb_funcall(ruby_errinfo, rb_intern("exception"), 1, err));
	    }
	    rb_exc_raise(ruby_errinfo);
	}
	JUMP_TAG(state);
    }

    return result;
}

static VALUE
rb_f_eval(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE src, scope, vfile, vline;
    char *file = "(eval)";
    int line = 1;

    rb_scan_args(argc, argv, "13", &src, &scope, &vfile, &vline);
    if (ruby_safe_level >= 4) {
	StringValue(src);
	if (!NIL_P(scope) && !OBJ_TAINTED(scope)) {
	    rb_raise(rb_eSecurityError, "Insecure: can't modify trusted binding");
	}
    }
    else {
	SafeStringValue(src);
    }
    if (argc >= 3) {
	file = StringValuePtr(vfile);
    }
    if (argc >= 4) {
	line = NUM2INT(vline);
    }

    if (NIL_P(scope) && ruby_frame->prev) {
	struct FRAME *prev;
	VALUE val;

	prev = ruby_frame;
	PUSH_FRAME();
	*ruby_frame = *prev->prev;
	ruby_frame->prev = prev;
	val = eval(self, src, scope, file, line);
	POP_FRAME();

	return val;
    }
    return eval(self, src, scope, file, line);
}

/* function to call func under the specified class/module context */
static VALUE
exec_under(func, under, cbase, args)
    VALUE (*func)();
    VALUE under, cbase;
    void *args;
{
    VALUE val;			/* OK */
    int state;
    int mode;

    PUSH_CLASS();
    ruby_class = under;
    PUSH_FRAME();
    ruby_frame->self = _frame.prev->self;
    ruby_frame->last_func = _frame.prev->last_func;
    ruby_frame->last_class = _frame.prev->last_class;
    ruby_frame->argc = _frame.prev->argc;
    ruby_frame->argv = _frame.prev->argv;
    if (cbase) {
	if (ruby_cbase != cbase) {
	    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,under,0,ruby_frame->cbase);
	}
	PUSH_CREF(cbase);
    }

    mode = scope_vmode;
    SCOPE_SET(SCOPE_PUBLIC);
    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	val = (*func)(args);
    }
    POP_TAG();
    if (cbase) POP_CREF();
    SCOPE_SET(mode);
    POP_FRAME();
    POP_CLASS();
    if (state) JUMP_TAG(state);

    return val;
}

static VALUE
eval_under_i(args)
    VALUE *args;
{
    return eval(args[0], args[1], Qnil, (char*)args[2], (int)args[3]);
}

/* string eval under the class/module context */
static VALUE
eval_under(under, self, src, file, line)
    VALUE under, self, src;
    const char *file;
    int line;
{
    VALUE args[4];

    if (ruby_safe_level >= 4) {
	StringValue(src);
    }
    else {
	SafeStringValue(src);
    }
    args[0] = self;
    args[1] = src;
    args[2] = (VALUE)file;
    args[3] = (VALUE)line;
    return exec_under(eval_under_i, under, under, args);
}

static VALUE
yield_under_i(self)
    VALUE self;
{
    return rb_yield_0(self, self, ruby_class, 0);
}

/* block eval under the class/module context */
static VALUE
yield_under(under, self)
    VALUE under, self;
{
    return exec_under(yield_under_i, under, 0, self);
}

static VALUE
specific_eval(argc, argv, klass, self)
    int argc;
    VALUE *argv;
    VALUE klass, self;
{
    if (rb_block_given_p()) {
	if (argc > 0) {
	    rb_raise(rb_eArgError, "wrong number of arguments (%d for 0)", argc);
	}
	return yield_under(klass, self);
    }
    else {
	char *file = "(eval)";
	int   line = 1;

	if (argc == 0) {
	    rb_raise(rb_eArgError, "block not supplied");
	}
	else {
	    if (ruby_safe_level >= 4) {
		StringValue(argv[0]);
	    }
	    else {
		SafeStringValue(argv[0]);
	    }
	    if (argc > 3) {
		rb_raise(rb_eArgError, "wrong number of arguments: %s(src) or %s{..}",
			 rb_id2name(ruby_frame->last_func),
			 rb_id2name(ruby_frame->last_func));
	    }
	    if (argc > 1) {
		file = StringValuePtr(argv[1]);
	    }
	    if (argc > 2) line = NUM2INT(argv[2]);
	}
	return eval_under(klass, self, argv[0], file, line);
    }
}

VALUE
rb_obj_instance_eval(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE klass;

    if (rb_special_const_p(self)) {
	klass = Qnil;
    }
    else {
	klass = rb_singleton_class(self);
    }

    return specific_eval(argc, argv, klass, self);
}

VALUE
rb_mod_module_eval(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    return specific_eval(argc, argv, mod, mod);
}

VALUE rb_load_path;

void
rb_load(fname, wrap)
    VALUE fname;
    int wrap;
{
    VALUE tmp;
    int state;
    volatile ID last_func;
    volatile VALUE wrapper = 0;
    volatile VALUE self = ruby_top_self;
    volatile int old_tracing = tracing;
    NODE *saved_cref = ruby_cref;
    TMP_PROTECT;

    if (wrap && ruby_safe_level >= 4) {
	StringValue(fname);
    }
    else {
	SafeStringValue(fname);
    }
    tmp = rb_find_file(fname);
    if (!tmp) {
	rb_raise(rb_eLoadError, "No such file to load -- %s", RSTRING(fname)->ptr);
    }
    fname = tmp;

    ruby_errinfo = Qnil;	/* ensure */
    PUSH_VARS();
    PUSH_CLASS();
    wrapper = ruby_wrapper;
    ruby_cref = top_cref;
    if (!wrap) {
	rb_secure(4);		/* should alter global state */
	ruby_class = rb_cObject;
	ruby_wrapper = 0;
    }
    else {
	/* load in anonymous module as toplevel */
	ruby_class = ruby_wrapper = rb_module_new();
	self = rb_obj_clone(ruby_top_self);
	rb_extend_object(self, ruby_class);
	PUSH_CREF(ruby_wrapper);
    }
    PUSH_ITER(ITER_NOT);
    PUSH_FRAME();
    ruby_frame->last_func = 0;
    ruby_frame->last_class = 0;
    ruby_frame->self = self;
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,ruby_class,0,0);
    PUSH_SCOPE();
    /* default visibility is private at loading toplevel */
    SCOPE_SET(SCOPE_PRIVATE);
    PUSH_TAG(PROT_NONE);
    state = EXEC_TAG();
    last_func = ruby_frame->last_func;
    if (state == 0) {
	NODE *node;

	DEFER_INTS;
	ruby_in_eval++;
	rb_load_file(RSTRING(fname)->ptr);
	ruby_in_eval--;
	node = ruby_eval_tree;
	ALLOW_INTS;
	if (ruby_nerrs == 0) {
	    ENABLE_TRACE();
	    eval_node(self, node);
	}
    }
    ruby_frame->last_func = last_func;
    if (ruby_scope->flags == SCOPE_ALLOCA && ruby_class == rb_cObject) {
	if (ruby_scope->local_tbl) /* toplevel was empty */
	    free(ruby_scope->local_tbl);
    }
    POP_TAG();
    ruby_cref = saved_cref;
    POP_SCOPE();
    POP_FRAME();
    POP_ITER();
    POP_CLASS();
    POP_VARS();
    ruby_wrapper = wrapper;
    tracing = old_tracing;
    if (ruby_nerrs > 0) {
	ruby_nerrs = 0;
	rb_exc_raise(ruby_errinfo);
    }
    if (state) jump_tag_but_local_jump(state);
    if (!NIL_P(ruby_errinfo))	/* exception during load */
	rb_exc_raise(ruby_errinfo);
}

void
rb_load_protect(fname, wrap, state)
    VALUE fname;
    int wrap;
    int *state;
{
    int status;

    PUSH_TAG(PROT_NONE);
    if ((status = EXEC_TAG()) == 0) {
	rb_load(fname, wrap);
    }
    POP_TAG();
    if (state) *state = status;
}

static VALUE
rb_f_load(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE fname, wrap;

    rb_scan_args(argc, argv, "11", &fname, &wrap);
    rb_load(fname, RTEST(wrap));
    return Qtrue;
}

VALUE ruby_dln_librefs;
static VALUE rb_features;
static st_table *loading_tbl;

static int
rb_feature_p(feature, wait)
    const char *feature;
    int wait;
{
    VALUE v;
    char *f;
    long i, len = strlen(feature);

    for (i = 0; i < RARRAY(rb_features)->len; ++i) {
	v = RARRAY(rb_features)->ptr[i];
	f = StringValuePtr(v);
	if (strcmp(f, feature) == 0) {
	    goto load_wait;
	}
	if (strncmp(f, feature, len) == 0) {
	    if (strcmp(f+len, ".so") == 0) {
		return Qtrue;
	    }
	    if (strcmp(f+len, ".rb") == 0) {
		if (wait) goto load_wait;
		return Qtrue;
	    }
	}
    }
    return Qfalse;

  load_wait:
    if (loading_tbl) {
	char *ext = strrchr(f, '.');
	if (ext && strcmp(ext, ".rb") == 0) {
	    rb_thread_t th;

	    while (st_lookup(loading_tbl, f, &th)) {
		if (th == curr_thread) {
		    return Qtrue;
		}
		CHECK_INTS;
		rb_thread_schedule();
	    }
	}
    }
    return Qtrue;
}

static const char *const loadable_ext[] = {
    ".rb", DLEXT,
#ifdef DLEXT2
    DLEXT2,
#endif
    0
};

int
rb_provided(feature)
    const char *feature;
{
    VALUE f = rb_str_new2(feature);

    if (strrchr(feature, '.') == 0) {
	if (rb_find_file_ext(&f, loadable_ext) == 0) {
	    return rb_feature_p(feature, Qfalse);
	}
    }
    return rb_feature_p(RSTRING(f)->ptr, Qfalse);
}

static void
rb_provide_feature(feature)
    VALUE feature;
{
    rb_ary_push(rb_features, feature);
}

void
rb_provide(feature)
    const char *feature;
{
    rb_provide_feature(rb_str_new2(feature));
}

VALUE
rb_f_require(obj, fname)
    VALUE obj, fname;
{
    VALUE feature, tmp;
    char *ext, *ftptr; /* OK */
    int state;
    volatile int safe = ruby_safe_level;

    SafeStringValue(fname);
    ext = strrchr(RSTRING(fname)->ptr, '.');
    if (ext) {
	if (strcmp(".rb", ext) == 0) {
	    feature = rb_str_dup(fname);
	    tmp = rb_find_file(fname);
	    if (tmp) {
		fname = tmp;
		goto load_rb;
	    }
	}
	else if (strcmp(".so", ext) == 0 || strcmp(".o", ext) == 0) {
	    fname = rb_str_new(RSTRING(fname)->ptr, ext-RSTRING(fname)->ptr);
#ifdef DLEXT2
	    tmp = fname;
	    if (rb_find_file_ext(&tmp, loadable_ext+1)) {
		feature = tmp;
		fname = rb_find_file(tmp);
		goto load_dyna;
	    }
#else
	    feature = tmp = rb_str_dup(fname);
	    rb_str_cat2(tmp, DLEXT);
	    tmp = rb_find_file(tmp);
	    if (tmp) {
		fname = tmp;
		goto load_dyna;
	    }
#endif
	}
	else if (strcmp(DLEXT, ext) == 0) {
	    tmp = rb_find_file(fname);
	    if (tmp) {
		feature = fname;
		fname = tmp;
		goto load_dyna;
	    }
	}
#ifdef DLEXT2
	else if (strcmp(DLEXT2, ext) == 0) {
	    tmp = rb_find_file(fname);
	    if (tmp) {
		feature = fname;
		fname = tmp;
		goto load_dyna;
	    }
	}
#endif
    }
    tmp = fname;
    switch (rb_find_file_ext(&tmp, loadable_ext)) {
      case 0:
	break;

      case 1:
	feature = fname = tmp;
	goto load_rb;

      default:
	feature = tmp;
	fname = rb_find_file(tmp);
	goto load_dyna;
    }
    if (rb_feature_p(RSTRING(fname)->ptr, Qfalse))
	return Qfalse;
    rb_raise(rb_eLoadError, "No such file to load -- %s", RSTRING(fname)->ptr);

  load_dyna:
    if (rb_feature_p(RSTRING(feature)->ptr, Qfalse))
	return Qfalse;
    rb_provide_feature(feature);
    {
	int volatile old_vmode = scope_vmode;
	NODE *const volatile old_node = ruby_current_node;
	const volatile ID old_func = ruby_frame->last_func;

	ruby_current_node = 0;
	ruby_sourcefile = rb_source_filename(RSTRING(fname)->ptr);
	ruby_sourceline = 0;
	ruby_frame->last_func = 0;
	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    void *handle;

	    SCOPE_SET(SCOPE_PUBLIC);
	    handle = dln_load(RSTRING(fname)->ptr);
	    rb_ary_push(ruby_dln_librefs, LONG2NUM((long)handle));
	}
	POP_TAG();
	ruby_current_node = old_node;
	ruby_set_current_source();
	ruby_frame->last_func = old_func;
	SCOPE_SET(old_vmode);
    }
    if (state) JUMP_TAG(state);

    return Qtrue;

  load_rb:
    if (rb_feature_p(RSTRING(feature)->ptr, Qtrue))
	return Qfalse;
    ruby_safe_level = 0;
    rb_provide_feature(feature);
    /* loading ruby library should be serialized. */
    if (!loading_tbl) {
	loading_tbl = st_init_strtable();
    }
    /* partial state */
    ftptr = ruby_strdup(RSTRING(feature)->ptr);
    st_insert(loading_tbl, ftptr, curr_thread);

    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	rb_load(fname, 0);
    }
    POP_TAG();
    st_delete(loading_tbl, &ftptr, 0); /* loading done */
    free(ftptr);
    ruby_safe_level = safe;
    if (state) JUMP_TAG(state);

    return Qtrue;
}

VALUE
rb_require(fname)
    const char *fname;
{
    return rb_f_require(Qnil, rb_str_new2(fname));
}

static void
secure_visibility(self)
    VALUE self;
{
    if (ruby_safe_level >= 4 && !OBJ_TAINTED(self)) {
	rb_raise(rb_eSecurityError, "Insecure: can't change method visibility");
    }
}

static void
set_method_visibility(self, argc, argv, ex)
    VALUE self;
    int argc;
    VALUE *argv;
    ID ex;
{
    int i;

    secure_visibility(self);
    for (i=0; i<argc; i++) {
	rb_export_method(self, rb_to_id(argv[i]), ex);
    }
    rb_clear_cache_by_class(self);
}

static VALUE
rb_mod_public(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    secure_visibility(module);
    if (argc == 0) {
	SCOPE_SET(SCOPE_PUBLIC);
    }
    else {
	set_method_visibility(module, argc, argv, NOEX_PUBLIC);
    }
    return module;
}

static VALUE
rb_mod_protected(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    secure_visibility(module);
    if (argc == 0) {
	SCOPE_SET(SCOPE_PROTECTED);
    }
    else {
	set_method_visibility(module, argc, argv, NOEX_PROTECTED);
    }
    return module;
}

static VALUE
rb_mod_private(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    secure_visibility(module);
    if (argc == 0) {
	SCOPE_SET(SCOPE_PRIVATE);
    }
    else {
	set_method_visibility(module, argc, argv, NOEX_PRIVATE);
    }
    return module;
}

static VALUE
rb_mod_public_method(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    set_method_visibility(CLASS_OF(obj), argc, argv, NOEX_PUBLIC);
    return obj;
}

static VALUE
rb_mod_private_method(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    set_method_visibility(CLASS_OF(obj), argc, argv, NOEX_PRIVATE);
    return obj;
}

static VALUE
top_public(argc, argv)
    int argc;
    VALUE *argv;
{
    return rb_mod_public(argc, argv, rb_cObject);
}

static VALUE
top_private(argc, argv)
    int argc;
    VALUE *argv;
{
    return rb_mod_private(argc, argv, rb_cObject);
}

static VALUE
rb_mod_modfunc(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    int i;
    ID id;
    NODE *body;

    if (TYPE(module) != T_MODULE) {
	rb_raise(rb_eTypeError, "module_function must be called for modules");
    }

    secure_visibility(module);
    if (argc == 0) {
	SCOPE_SET(SCOPE_MODFUNC);
	return module;
    }

    set_method_visibility(module, argc, argv, NOEX_PRIVATE);
    for (i=0; i<argc; i++) {
	VALUE m = module;

	id = rb_to_id(argv[i]);
	for (;;) {
	    body = search_method(m, id, &m);
	    if (body == 0 || body->nd_body == 0) {
		rb_bug("undefined method `%s'; can't happen", rb_id2name(id));
	    }
	    if (nd_type(body->nd_body) != NODE_ZSUPER) {
		break;		/* normal case: need not to follow 'super' link */
	    }
	    m = RCLASS(m)->super;
	}
	rb_add_method(rb_singleton_class(module), id, body->nd_body, NOEX_PUBLIC);
	rb_funcall(module, singleton_added, 1, ID2SYM(id));
    }
    return module;
}

static VALUE
rb_mod_append_features(module, include)
    VALUE module, include;
{
    switch (TYPE(include)) {
      case T_CLASS:
      case T_MODULE:
	break;
      default:
	Check_Type(include, T_CLASS);
	break;
    }
    rb_include_module(include, module);

    return module;
}

static VALUE
rb_mod_include(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    while (argc--) {
	VALUE m = argv[argc];

	Check_Type(m, T_MODULE);
	rb_funcall(m, rb_intern("append_features"), 1, module);
	rb_funcall(m, rb_intern("included"), 1, module);
    }
    return module;
}

void
rb_obj_call_init(obj, argc, argv)
    VALUE obj;
    int argc;
    VALUE *argv;
{
    PUSH_ITER(rb_block_given_p()?ITER_PRE:ITER_NOT);
    rb_funcall2(obj, init, argc, argv);
    POP_ITER();
}

static VALUE
top_include(argc, argv)
    int argc;
    VALUE *argv;
{
    rb_secure(4);
    return rb_mod_include(argc, argv, rb_cObject);
}

void
rb_extend_object(obj, module)
    VALUE obj, module;
{
    rb_include_module(rb_singleton_class(obj), module);
}

static VALUE
rb_mod_extend_object(mod, obj)
    VALUE mod, obj;
{
    rb_extend_object(obj, mod);
    return obj;
}

static VALUE
rb_obj_extend(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    int i;

    if (argc == 0) {
	rb_raise(rb_eArgError, "wrong number of arguments(0 for 1)");
    }
    for (i=0; i<argc; i++) Check_Type(argv[i], T_MODULE);
    while (argc--) {
	rb_funcall(argv[argc], rb_intern("extend_object"), 1, obj);
    }
    return obj;
}

VALUE rb_f_trace_var();
VALUE rb_f_untrace_var();

static void
errinfo_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    if (!NIL_P(val) && !rb_obj_is_kind_of(val, rb_eException)) {
	rb_raise(rb_eTypeError, "assigning non-exception to $!");
    }
    *var = val;
}

static VALUE
errat_getter(id)
    ID id;
{
    return get_backtrace(ruby_errinfo);
}

static void
errat_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    if (NIL_P(ruby_errinfo)) {
	rb_raise(rb_eArgError, "$! not set");
    }
    set_backtrace(ruby_errinfo, val);
}

static VALUE
rb_f_local_variables()
{
    ID *tbl;
    int n, i;
    VALUE ary = rb_ary_new();
    struct RVarmap *vars;

    tbl = ruby_scope->local_tbl;
    if (tbl) {
	n = *tbl++;
	for (i=2; i<n; i++) {	/* skip first 2 ($_ and $~) */
	    if (!rb_is_local_id(tbl[i])) continue; /* skip flip states */
	    rb_ary_push(ary, rb_str_new2(rb_id2name(tbl[i])));
	}
    }

    vars = ruby_dyna_vars;
    while (vars) {
	if (vars->id) {
	    rb_ary_push(ary, rb_str_new2(rb_id2name(vars->id)));
	}
	vars = vars->next;
    }

    return ary;
}

static VALUE rb_f_catch _((VALUE,VALUE));
NORETURN(static VALUE rb_f_throw _((int,VALUE*)));

struct end_proc_data {
    void (*func)();
    VALUE data;
    struct end_proc_data *next;
};

static struct end_proc_data *end_procs, *ephemeral_end_procs;

void
rb_set_end_proc(func, data)
    void (*func) _((VALUE));
    VALUE data;
{
    struct end_proc_data *link = ALLOC(struct end_proc_data);
    struct end_proc_data **list;

    if (ruby_wrapper) list = &ephemeral_end_procs;
    else              list = &end_procs;
    link->next = *list;
    link->func = func;
    link->data = data;
    *list = link;
}

void
rb_mark_end_proc()
{
    struct end_proc_data *link;

    link = end_procs;
    while (link) {
	rb_gc_mark(link->data);
	link = link->next;
    }
    link = ephemeral_end_procs;
    while (link) {
	rb_gc_mark(link->data);
	link = link->next;
    }
}

static void call_end_proc _((VALUE data));

static void
call_end_proc(data)
    VALUE data;
{
    PUSH_ITER(ITER_NOT);
    PUSH_FRAME();
    ruby_frame->self = ruby_frame->prev->self;
    ruby_frame->last_func = 0;
    ruby_frame->last_class = 0;
    proc_invoke(data, rb_ary_new2(0), Qfalse, Qundef);
    POP_FRAME();
    POP_ITER();
}

static void
rb_f_END()
{
    PUSH_FRAME();
    ruby_frame->argc = 0;
    rb_set_end_proc(call_end_proc, rb_f_lambda());
    POP_FRAME();
}

static VALUE
rb_f_at_exit()
{
    VALUE proc;

    proc = rb_f_lambda();

    rb_set_end_proc(call_end_proc, proc);
    return proc;
}

void
rb_exec_end_proc()
{
    struct end_proc_data *link, *save;
    int status;

    save = link = end_procs;
    while (link) {
	rb_protect((VALUE(*)_((VALUE)))link->func, link->data, &status);
	if (status) {
	    error_handle(status);
	}
	link = link->next;
    }
    link = end_procs;
    while (link != save) {
	rb_protect((VALUE(*)_((VALUE)))link->func, link->data, &status);
	if (status) {
	    error_handle(status);
	}
	link = link->next;
    }
    while (ephemeral_end_procs) {
	link = ephemeral_end_procs;
	ephemeral_end_procs = link->next;
	rb_protect((VALUE(*)_((VALUE)))link->func, link->data, &status);
	if (status) {
	    error_handle(status);
	}
	free(link);
    }
}

void
Init_eval()
{
    init = rb_intern("initialize");
    alloc = rb_intern("allocate");
    eqq = rb_intern("===");
    each = rb_intern("each");

    aref = rb_intern("[]");
    aset = rb_intern("[]=");
    match = rb_intern("=~");
    missing = rb_intern("method_missing");
    added = rb_intern("method_added");
    singleton_added = rb_intern("singleton_method_added");
    removed = rb_intern("method_removed");
    singleton_removed = rb_intern("singleton_method_removed");
    undefined = rb_intern("method_undefined");
    singleton_undefined = rb_intern("singleton_method_undefined");

    __id__ = rb_intern("__id__");
    __send__ = rb_intern("__send__");

    rb_global_variable((VALUE*)&top_scope);
    rb_global_variable((VALUE*)&ruby_eval_tree_begin);

    rb_global_variable((VALUE*)&ruby_eval_tree);
    rb_global_variable((VALUE*)&ruby_dyna_vars);

    rb_define_virtual_variable("$@@", errat_getter, errat_setter);
    rb_define_hooked_variable("$!", &ruby_errinfo, 0, errinfo_setter);

    rb_define_global_function("eval", rb_f_eval, -1);
    rb_define_global_function("iterator?", rb_f_block_given_p, 0);
    rb_define_global_function("block_given?", rb_f_block_given_p, 0);
    rb_define_global_function("method_missing", rb_f_missing, -1);
    rb_define_global_function("loop", rb_f_loop, 0);

    rb_define_method(rb_mKernel, "respond_to?", rb_obj_respond_to, -1);

    rb_define_global_function("raise", rb_f_raise, -1);
    rb_define_global_function("fail", rb_f_raise, -1);

    rb_define_global_function("caller", rb_f_caller, -1);

    rb_define_global_function("exit", rb_f_exit, -1);
    rb_define_global_function("abort", rb_f_abort, -1);

    rb_define_global_function("at_exit", rb_f_at_exit, 0);

    rb_define_global_function("catch", rb_f_catch, 1);
    rb_define_global_function("throw", rb_f_throw, -1);
    rb_define_global_function("global_variables", rb_f_global_variables, 0);
    rb_define_global_function("local_variables", rb_f_local_variables, 0);

    rb_define_method(rb_mKernel, "send", rb_f_send, -1);
    rb_define_method(rb_mKernel, "__send__", rb_f_send, -1);
    rb_define_method(rb_mKernel, "instance_eval", rb_obj_instance_eval, -1);

    rb_define_private_method(rb_cModule, "append_features", rb_mod_append_features, 1);
    rb_define_private_method(rb_cModule, "extend_object", rb_mod_extend_object, 1);
    rb_define_private_method(rb_cModule, "include", rb_mod_include, -1);
    rb_define_private_method(rb_cModule, "public", rb_mod_public, -1);
    rb_define_private_method(rb_cModule, "protected", rb_mod_protected, -1);
    rb_define_private_method(rb_cModule, "private", rb_mod_private, -1);
    rb_define_private_method(rb_cModule, "module_function", rb_mod_modfunc, -1);
    rb_define_method(rb_cModule, "method_defined?", rb_mod_method_defined, 1);
    rb_define_method(rb_cModule, "public_method_defined?", rb_mod_public_method_defined, 1);
    rb_define_method(rb_cModule, "private_method_defined?", rb_mod_private_method_defined, 1);
    rb_define_method(rb_cModule, "protected_method_defined?", rb_mod_protected_method_defined, 1);
    rb_define_method(rb_cModule, "public_class_method", rb_mod_public_method, -1);
    rb_define_method(rb_cModule, "private_class_method", rb_mod_private_method, -1);
    rb_define_method(rb_cModule, "module_eval", rb_mod_module_eval, -1);
    rb_define_method(rb_cModule, "class_eval", rb_mod_module_eval, -1);

    rb_undef_method(rb_cClass, "module_function");

    rb_define_private_method(rb_cModule, "remove_method", rb_mod_remove_method, 1);
    rb_define_private_method(rb_cModule, "undef_method", rb_mod_undef_method, 1);
    rb_define_private_method(rb_cModule, "alias_method", rb_mod_alias_method, 2);
    rb_define_private_method(rb_cModule, "define_method", rb_mod_define_method, -1);

    rb_define_singleton_method(rb_cModule, "nesting", rb_mod_nesting, 0);
    rb_define_singleton_method(rb_cModule, "constants", rb_mod_s_constants, 0);

    rb_define_singleton_method(ruby_top_self, "include", top_include, -1);
    rb_define_singleton_method(ruby_top_self, "public", top_public, -1);
    rb_define_singleton_method(ruby_top_self, "private", top_private, -1);

    rb_define_method(rb_mKernel, "extend", rb_obj_extend, -1);

    rb_define_global_function("trace_var", rb_f_trace_var, -1);
    rb_define_global_function("untrace_var", rb_f_untrace_var, -1);

    rb_define_global_function("set_trace_func", set_trace_func, 1);
    rb_global_variable(&trace_func);

    rb_define_virtual_variable("$SAFE", safe_getter, safe_setter);
}

VALUE rb_f_autoload();

void
Init_load()
{
    rb_load_path = rb_ary_new();
    rb_define_readonly_variable("$:", &rb_load_path);
    rb_define_readonly_variable("$-I", &rb_load_path);
    rb_define_readonly_variable("$LOAD_PATH", &rb_load_path);

    rb_features = rb_ary_new();
    rb_define_readonly_variable("$\"", &rb_features);

    rb_define_global_function("load", rb_f_load, -1);
    rb_define_global_function("require", rb_f_require, 1);
    rb_define_global_function("autoload", rb_f_autoload, 2);
    rb_global_variable(&ruby_wrapper);

    ruby_dln_librefs = rb_ary_new();
    rb_global_variable(&ruby_dln_librefs);
}

static void
scope_dup(scope)
    struct SCOPE *scope;
{
    ID *tbl;
    VALUE *vars;

    scope->flags |= SCOPE_DONT_RECYCLE;
    if (scope->flags & SCOPE_MALLOC) return;

    if (scope->local_tbl) {
	tbl = scope->local_tbl;
	vars = ALLOC_N(VALUE, tbl[0]+1);
	*vars++ = scope->local_vars[-1];
	MEMCPY(vars, scope->local_vars, VALUE, tbl[0]);
	scope->local_vars = vars;
	scope->flags |= SCOPE_MALLOC;
    }
}

static void
blk_mark(data)
    struct BLOCK *data;
{
    while (data) {
	rb_gc_mark_frame(&data->frame);
	rb_gc_mark((VALUE)data->scope);
	rb_gc_mark((VALUE)data->var);
	rb_gc_mark((VALUE)data->body);
	rb_gc_mark((VALUE)data->self);
	rb_gc_mark((VALUE)data->dyna_vars);
	rb_gc_mark((VALUE)data->klass);
	rb_gc_mark((VALUE)data->tag);
	rb_gc_mark(data->wrapper);
	data = data->prev;
    }
}

static void
blk_free(data)
    struct BLOCK *data;
{
    struct FRAME *frame;
    void *tmp;

    frame = data->frame.prev;
    while (frame) {
	if (frame->argc > 0 && (frame->flags & FRAME_MALLOC))
	    free(frame->argv);
	tmp = frame;
	frame = frame->prev;
	free(tmp);
    }
    while (data) {
	if (data->frame.argc > 0)
	    free(data->frame.argv);
	tmp = data;
	data = data->prev;
	free(tmp);
    }
}

static void
blk_copy_prev(block)
    struct BLOCK *block;
{
    struct BLOCK *tmp;
    struct RVarmap* vars;

    while (block->prev) {
	tmp = ALLOC_N(struct BLOCK, 1);
	MEMCPY(tmp, block->prev, struct BLOCK, 1);
	if (tmp->frame.argc > 0) {
	    tmp->frame.argv = ALLOC_N(VALUE, tmp->frame.argc);
	    MEMCPY(tmp->frame.argv, block->prev->frame.argv, VALUE, tmp->frame.argc);
	    tmp->frame.flags |= FRAME_MALLOC;
	}
	scope_dup(tmp->scope);
	tmp->tag->flags |= BLOCK_DYNAMIC;

	for (vars = tmp->dyna_vars; vars; vars = vars->next) {
	    if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
	    FL_SET(vars, DVAR_DONT_RECYCLE);
	}

	block->prev = tmp;
	block = tmp;
    }
}

static void
frame_dup(frame)
    struct FRAME *frame;
{
    VALUE *argv;
    struct FRAME *tmp;

    for (;;) {
	if (frame->argc > 0) {
	    argv = ALLOC_N(VALUE, frame->argc);
	    MEMCPY(argv, frame->argv, VALUE, frame->argc);
	    frame->argv = argv;
	    frame->flags |= FRAME_MALLOC;
	}
	frame->tmp = 0;		/* should not preserve tmp */
	if (!frame->prev) break;
	tmp = ALLOC(struct FRAME);
	*tmp = *frame->prev;
	frame->prev = tmp;
	frame = tmp;
    }
}

static VALUE
bind_clone(self)
    VALUE self;
{
    struct BLOCK *orig, *data;
    VALUE bind;

    Data_Get_Struct(self, struct BLOCK, orig);
    bind = Data_Make_Struct(rb_cBinding,struct BLOCK,blk_mark,blk_free,data);
    CLONESETUP(bind, self);
    MEMCPY(data, orig, struct BLOCK, 1);
    frame_dup(&data->frame);

    if (data->iter) {
	blk_copy_prev(data);
    }
    else {
	data->prev = 0;
    }

    return bind;
}

static VALUE
rb_f_binding(self)
    VALUE self;
{
    struct BLOCK *data, *p;
    struct RVarmap *vars;
    VALUE bind;

    PUSH_BLOCK(0,0);
    bind = Data_Make_Struct(rb_cBinding,struct BLOCK,blk_mark,blk_free,data);
    *data = *ruby_block;

    data->orig_thread = rb_thread_current();
    data->wrapper = ruby_wrapper;
    data->iter = rb_f_block_given_p();
    frame_dup(&data->frame);
    if (ruby_frame->prev) {
	data->frame.last_func = ruby_frame->prev->last_func;
	data->frame.last_class = ruby_frame->prev->last_class;
    }

    if (data->iter) {
	blk_copy_prev(data);
    }
    else {
	data->prev = 0;
    }
    data->flags |= BLOCK_DYNAMIC;
    data->tag->flags |= BLOCK_DYNAMIC;

    for (p = data; p; p = p->prev) {
	for (vars = p->dyna_vars; vars; vars = vars->next) {
	    if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
	    FL_SET(vars, DVAR_DONT_RECYCLE);
	}
    }
    scope_dup(data->scope);
    POP_BLOCK();

    return bind;
}

#define PROC_T3    FL_USER1
#define PROC_T4    FL_USER2
#define PROC_TMAX  (FL_USER1|FL_USER2)
#define PROC_TMASK (FL_USER1|FL_USER2)

static void
proc_save_safe_level(data)
    VALUE data;
{
    if (OBJ_TAINTED(data)) {
	switch (ruby_safe_level) {
	  case 3:
	    FL_SET(data, PROC_T3);
	    break;
	  case 4:
	    FL_SET(data, PROC_T4);
	    break;
	  default:
	    if (ruby_safe_level > 4) {
		FL_SET(data, PROC_TMAX);
	    }
	    break;
	}
    }
}

static int
proc_get_safe_level(data)
    VALUE data;
{
    if (OBJ_TAINTED(data)) {
	switch (RBASIC(data)->flags & PROC_TMASK) {
	  case PROC_T3:
	    return 3;
	  case PROC_T4:
	    return 4;
	  case PROC_TMAX:
	    return 5;
	}
	return 3;
    }
    return 0;
}

static void
proc_set_safe_level(data)
    VALUE data;
{
    if (OBJ_TAINTED(data)) {
	ruby_safe_level = proc_get_safe_level(data);
    }
}

static VALUE
proc_new(klass)
    VALUE klass;
{
    volatile VALUE proc;
    struct BLOCK *data, *p;
    struct RVarmap *vars;

    if (!rb_block_given_p() && !rb_f_block_given_p()) {
	rb_raise(rb_eArgError, "tried to create Proc object without a block");
    }

    proc = Data_Make_Struct(klass, struct BLOCK, blk_mark, blk_free, data);
    *data = *ruby_block;

    data->orig_thread = rb_thread_current();
    data->wrapper = ruby_wrapper;
    data->iter = data->prev?Qtrue:Qfalse;
    frame_dup(&data->frame);
    if (data->iter) {
	blk_copy_prev(data);
    }
    else {
	data->prev = 0;
    }
    data->flags |= BLOCK_DYNAMIC;
    data->tag->flags |= BLOCK_DYNAMIC;

    for (p = data; p; p = p->prev) {
	for (vars = p->dyna_vars; vars; vars = vars->next) {
	    if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
	    FL_SET(vars, DVAR_DONT_RECYCLE);
	}
    }
    scope_dup(data->scope);
    proc_save_safe_level(proc);

    return proc;
}

static VALUE
proc_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE proc = proc_new(klass);

    rb_obj_call_init(proc, argc, argv);
    return proc;
}

VALUE
rb_f_lambda()
{
    return proc_new(rb_cProc);
}

static int
blk_orphan(data)
    struct BLOCK *data;
{
    if (!(data->scope->flags & SCOPE_NOSTACK)) {
	return 0;
    }
    if ((data->tag->flags & BLOCK_ORPHAN)) {
	return 1;
    }
    if (data->orig_thread != rb_thread_current()) {
	return 1;
    }
    return 0;
}

static VALUE
proc_invoke(proc, args, pcall, self)
    VALUE proc, args;		/* OK */
    int pcall;
    VALUE self;
{
    struct BLOCK * volatile old_block;
    struct BLOCK _block;
    struct BLOCK *data;
    volatile VALUE result = Qnil;
    int state;
    volatile int orphan;
    volatile int safe = ruby_safe_level;
    volatile VALUE old_wrapper = ruby_wrapper;
    struct RVarmap * volatile old_dvars = ruby_dyna_vars;

    if (rb_block_given_p() && ruby_frame->last_func) {
	rb_warning("block for %s#%s is useless",
		   rb_class2name(CLASS_OF(proc)),
		   rb_id2name(ruby_frame->last_func));
    }

    Data_Get_Struct(proc, struct BLOCK, data);
    orphan = blk_orphan(data);

    ruby_wrapper = data->wrapper;
    ruby_dyna_vars = data->dyna_vars;
    /* PUSH BLOCK from data */
    old_block = ruby_block;
    _block = *data;
    ruby_block = &_block;

    PUSH_ITER(ITER_CUR);
    ruby_frame->iter = ITER_CUR;

    if (!pcall) {
	args = avalue_to_yvalue(args);
    }
    PUSH_TAG(PROT_NONE);
    state = EXEC_TAG();
    if (state == 0) {
	proc_set_safe_level(proc);
	result = rb_yield_0(args, self, self!=Qundef?CLASS_OF(self):0, pcall);
    }
    POP_TAG();

    POP_ITER();
    if (ruby_block->tag->dst == state) {
	state &= TAG_MASK;
    }
    ruby_block = old_block;
    ruby_wrapper = old_wrapper;
    ruby_dyna_vars = old_dvars;
    ruby_safe_level = safe;

    switch (state) {
      case 0:
	break;
      case TAG_BREAK:
	if (!pcall && orphan) {
	    localjump_error("break from proc-closure", prot_tag->retval);
	}
	result = prot_tag->retval;
	break;
      case TAG_RETRY:
	localjump_error("retry from proc-closure", Qnil);
	break;
      case TAG_RETURN:
	if (orphan) {	/* orphan procedure */
	    localjump_error("return from proc-closure", prot_tag->retval);
	}
	/* fall through */
      default:
	JUMP_TAG(state);
    }
    return result;
}

static VALUE
proc_call(proc, args)
    VALUE proc, args;		/* OK */
{
    return proc_invoke(proc, args, Qtrue, Qundef);
}

static VALUE
proc_yield(proc, args)
    VALUE proc, args;		/* OK */
{
    return proc_invoke(proc, args, Qfalse, Qundef);
}

static VALUE
proc_arity(proc)
    VALUE proc;
{
    struct BLOCK *data;
    NODE *list;
    int n;

    Data_Get_Struct(proc, struct BLOCK, data);
    if (data->var == 0) return INT2FIX(-1);
    if (data->var == (NODE*)1) return INT2FIX(0);
    if (data->var == (NODE*)2) return INT2FIX(0);
    switch (nd_type(data->var)) {
      default:
	return INT2FIX(-1);
      case NODE_MASGN:
	list = data->var->nd_head;
	n = 0;
	while (list) {
	    n++;
	    list = list->nd_next;
	}
	if (data->var->nd_args) return INT2FIX(-n-1);
	return INT2FIX(n);
    }
}

static VALUE
proc_eq(self, other)
    VALUE self, other;
{
    struct BLOCK *data, *data2;

    if (self == other) return Qtrue;
    if (TYPE(other) != T_DATA) return Qfalse;
    if (RDATA(other)->dmark != (RUBY_DATA_FUNC)blk_mark) return Qfalse;
    if (CLASS_OF(self) != CLASS_OF(other)) return Qfalse;
    Data_Get_Struct(self, struct BLOCK, data);
    Data_Get_Struct(other, struct BLOCK, data2);
    if (data->tag == data2->tag) return Qtrue;
    return Qfalse;
}

static VALUE
proc_to_s(self, other)
    VALUE self, other;
{
    struct BLOCK *data;
    char *cname = rb_class2name(CLASS_OF(self));
    const int w = (SIZEOF_LONG * CHAR_BIT) / 4;
    long len = strlen(cname)+6+w; /* 6:tags 16:addr */
    VALUE str;

    Data_Get_Struct(self, struct BLOCK, data);
    if (data->body) {
	len += strlen(data->body->nd_file) + 2 + (SIZEOF_LONG*CHAR_BIT-NODE_LSHIFT)/3;
	str = rb_str_new(0, len);
	sprintf(RSTRING(str)->ptr, "#<%s:0x%.*lx@@%s:%d>", cname, w, (VALUE)data->tag,
		data->body->nd_file, nd_line(data->body));
    }
    else {
	str = rb_str_new(0, len);
	sprintf(RSTRING(str)->ptr, "#<%s:0x%.*lx>", cname, w, (VALUE)data->tag);
    }
    RSTRING(str)->len = strlen(RSTRING(str)->ptr);
    if (OBJ_TAINTED(self)) OBJ_TAINT(str);

    return str;
}

static VALUE
proc_to_proc(proc)
    VALUE proc;
{
    return proc;
}

static VALUE
proc_binding(proc)
    VALUE proc;
{
    struct BLOCK *orig, *data;
    VALUE bind;

    Data_Get_Struct(proc, struct BLOCK, orig);
    bind = Data_Make_Struct(rb_cBinding,struct BLOCK,blk_mark,blk_free,data);
    MEMCPY(data, orig, struct BLOCK, 1);
    frame_dup(&data->frame);

    if (data->iter) {
	blk_copy_prev(data);
    }
    else {
	data->prev = 0;
    }

    return bind;
}

static VALUE
block_pass(self, node)
    VALUE self;
    NODE *node;
{
    VALUE block = rb_eval(self, node->nd_body);	/* OK */
    VALUE b;
    struct BLOCK * volatile old_block;
    struct BLOCK _block;
    struct BLOCK *data;
    volatile VALUE result = Qnil;
    int state;
    volatile int orphan;
    volatile int safe = ruby_safe_level;

    if (NIL_P(block)) {
	PUSH_ITER(ITER_NOT);
	result = rb_eval(self, node->nd_iter);
	POP_ITER();
	return result;
    }
    if (!rb_obj_is_proc(block)) {
	b = rb_check_convert_type(block, T_DATA, "Proc", "to_proc");
	if (!rb_obj_is_proc(b)) {
	    rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc)",
		     rb_class2name(CLASS_OF(block)));
	}
	block = b;
    }

    if (ruby_safe_level >= 1 && OBJ_TAINTED(block)) {
	if (ruby_safe_level > proc_get_safe_level(block)) {
	    rb_raise(rb_eSecurityError, "Insecure: tainted block value");
	}
    }

    Data_Get_Struct(block, struct BLOCK, data);
    orphan = blk_orphan(data);

  retry:
    /* PUSH BLOCK from data */
    old_block = ruby_block;
    _block = *data;
    ruby_block = &_block;
    PUSH_ITER(ITER_PRE);
    ruby_frame->iter = ITER_PRE;

    PUSH_TAG(PROT_NONE);
    state = EXEC_TAG();
    if (state == 0) {
	proc_set_safe_level(block);
	if (safe > ruby_safe_level)
	    ruby_safe_level = safe;
	result = rb_eval(self, node->nd_iter);
    }
    POP_TAG();
    POP_ITER();
    if (_block.tag->dst == state) {
	if (orphan) {
	    state &= TAG_MASK;
	}
	else {
	    struct BLOCK *ptr = old_block;

	    while (ptr) {
		if (ptr->scope == _block.scope) {
		    ptr->tag->dst = state;
		    break;
		}
		ptr = ptr->prev;
	    }
	    if (!ptr) {
		state &= TAG_MASK;
	    }
	}
    }
    ruby_block = old_block;
    ruby_safe_level = safe;

    switch (state) {/* escape from orphan procedure */
      case 0:
	break;
      case TAG_BREAK:
	result = prot_tag->retval;
	break;
      case TAG_RETRY:
	goto retry;
      case TAG_RETURN:
	if (orphan) {
	    localjump_error("return from proc-closure", prot_tag->retval);
	}
      default:
	JUMP_TAG(state);
    }

    return result;
}

struct METHOD {
    VALUE klass, rklass;
    VALUE recv;
    ID id, oid;
    NODE *body;
};

static void
bm_mark(data)
    struct METHOD *data;
{
    rb_gc_mark(data->rklass);
    rb_gc_mark(data->klass);
    rb_gc_mark(data->recv);
    rb_gc_mark((VALUE)data->body);
}

static VALUE
mnew(klass, obj, id, mklass)
    VALUE klass, obj, mklass;
    ID id;
{
    VALUE method;
    NODE *body;
    int noex;
    struct METHOD *data;
    VALUE rklass = klass;
    ID oid = id;

  again:
    if ((body = rb_get_method_body(&klass, &id, &noex)) == 0) {
	print_undef(rklass, oid);
    }

    if (nd_type(body) == NODE_ZSUPER) {
	klass = RCLASS(klass)->super;
	goto again;
    }

    method = Data_Make_Struct(mklass, struct METHOD, bm_mark, free, data);
    data->klass = klass;
    data->recv = obj;
    data->id = id;
    data->body = body;
    data->rklass = rklass;
    data->oid = oid;
    OBJ_INFECT(method, klass);

    return method;
}

static VALUE
method_eq(method, other)
    VALUE method, other;
{
    struct METHOD *m1, *m2;

    if (TYPE(other) != T_DATA || RDATA(other)->dmark != (RUBY_DATA_FUNC)bm_mark)
	return Qfalse;
    if (CLASS_OF(method) != CLASS_OF(other))
	return Qfalse;

    Data_Get_Struct(method, struct METHOD, m1);
    Data_Get_Struct(other, struct METHOD, m2);

    if (m1->klass != m2->klass || m1->rklass != m2->rklass ||
	m1->recv != m2->recv || m1->body != m2->body)
	return Qfalse;

    return Qtrue;
}

static VALUE
method_unbind(obj)
    VALUE obj;
{
    VALUE method;
    struct METHOD *orig, *data;

    Data_Get_Struct(obj, struct METHOD, orig);
    method = Data_Make_Struct(rb_cUnboundMethod, struct METHOD, bm_mark, free, data);
    data->klass = orig->klass;
    data->recv = Qundef;
    data->id = orig->id;
    data->body = orig->body;
    data->rklass = orig->rklass;
    data->oid = orig->oid;
    OBJ_INFECT(method, obj);

    return method;
}

static VALUE
umethod_unbind(obj)
    VALUE obj;
{
    return obj;
}

static VALUE
rb_obj_method(obj, vid)
    VALUE obj;
    VALUE vid;
{
    return mnew(CLASS_OF(obj), obj, rb_to_id(vid), rb_cMethod);
}

static VALUE
rb_mod_method(mod, vid)
    VALUE mod;
    VALUE vid;
{
    return mnew(mod, Qundef, rb_to_id(vid), rb_cUnboundMethod);
}

static VALUE
method_clone(self)
    VALUE self;
{
    VALUE clone;
    struct METHOD *orig, *data;

    Data_Get_Struct(self, struct METHOD, orig);
    clone = Data_Make_Struct(CLASS_OF(self),struct METHOD, bm_mark, free, data);
    CLONESETUP(clone, self);
    *data = *orig;

    return clone;
}

static VALUE
method_call(argc, argv, method)
    int argc;
    VALUE *argv;
    VALUE method;
{
    VALUE result;
    struct METHOD *data;
    int state;
    volatile int safe = ruby_safe_level;

    Data_Get_Struct(method, struct METHOD, data);
    if (data->recv == Qundef) {
	rb_raise(rb_eTypeError, "you cannot call unbound method; bind first");
    }
    PUSH_ITER(rb_block_given_p()?ITER_PRE:ITER_NOT);
    PUSH_TAG(PROT_NONE);
    if (OBJ_TAINTED(method) && ruby_safe_level < 4) {
	ruby_safe_level = 4;
    }
    if ((state = EXEC_TAG()) == 0) {
	result = rb_call0(data->klass,data->recv,data->id,data->oid,argc,argv,data->body,0);
    }
    POP_TAG();
    POP_ITER();
    ruby_safe_level = safe;
    if (state) JUMP_TAG(state);
    return result;
}

static VALUE
umethod_bind(method, recv)
    VALUE method, recv;
{
    struct METHOD *data, *bound;

    Data_Get_Struct(method, struct METHOD, data);
    if (data->rklass != CLASS_OF(recv)) {
	if (FL_TEST(data->rklass, FL_SINGLETON)) {
	    rb_raise(rb_eTypeError, "singleton method called for a different object");
	}
	if (FL_TEST(CLASS_OF(recv), FL_SINGLETON) &&
	    st_lookup(RCLASS(CLASS_OF(recv))->m_tbl, data->oid, 0)) {
	    rb_raise(rb_eTypeError, "method `%s' overridden", rb_id2name(data->oid));
	}
	if (!((TYPE(data->rklass) == T_MODULE) ?
	      rb_obj_is_kind_of(recv, data->rklass) :
	      rb_obj_is_instance_of(recv, data->rklass))) {
	    rb_raise(rb_eTypeError, "bind argument must be an instance of %s",
		     rb_class2name(data->rklass));
	}
    }

    method = Data_Make_Struct(rb_cMethod,struct METHOD,bm_mark,free,bound);
    *bound = *data;
    bound->recv = recv;
    bound->rklass = CLASS_OF(recv);

    return method;
}

static VALUE
method_arity(method)
    VALUE method;
{
    struct METHOD *data;
    NODE *body;
    int n;

    Data_Get_Struct(method, struct METHOD, data);

    body = data->body;
    switch (nd_type(body)) {
      case NODE_CFUNC:
	if (body->nd_argc < 0) return INT2FIX(-1);
	return INT2FIX(body->nd_argc);
      case NODE_ZSUPER:
	return INT2FIX(-1);
      case NODE_ATTRSET:
	return INT2FIX(1);
      case NODE_IVAR:
	return INT2FIX(0);
      default:
	body = body->nd_next;	/* skip NODE_SCOPE */
	if (nd_type(body) == NODE_BLOCK)
	    body = body->nd_head;
	if (!body) return INT2FIX(0);
	n = body->nd_cnt;
	if (body->nd_opt || body->nd_rest != -1)
	    n = -n-1;
	return INT2FIX(n);
    }
}

static VALUE
method_inspect(method)
    VALUE method;
{
    struct METHOD *data;
    VALUE str;
    const char *s;
    char *sharp = "#";

    Data_Get_Struct(method, struct METHOD, data);
    str = rb_str_buf_new2("#<");
    s = rb_class2name(CLASS_OF(method));
    rb_str_buf_cat2(str, s);
    rb_str_buf_cat2(str, ": ");

    if (FL_TEST(data->klass, FL_SINGLETON)) {
	VALUE v = rb_iv_get(data->klass, "__attached__");

	if (data->recv == Qundef) {
	    rb_str_buf_append(str, rb_inspect(data->klass));
	}
	else if (data->recv == v) {
	    rb_str_buf_append(str, rb_inspect(v));
	    sharp = ".";
	}
	else {
	    rb_str_buf_append(str, rb_inspect(data->recv));
	    rb_str_buf_cat2(str, "(");
	    rb_str_buf_append(str, rb_inspect(v));
	    rb_str_buf_cat2(str, ")");
	    sharp = ".";
	}
    }
    else {
	rb_str_buf_cat2(str, rb_class2name(data->rklass));
	if (data->rklass != data->klass) {
	    rb_str_buf_cat2(str, "(");
	    rb_str_buf_cat2(str, rb_class2name(data->klass));
	    rb_str_buf_cat2(str, ")");
	}
    }
    rb_str_buf_cat2(str, sharp);
    rb_str_buf_cat2(str, rb_id2name(data->oid));
    rb_str_buf_cat2(str, ">");

    return str;
}

static VALUE
mproc()
{
    VALUE proc;

    /* emulate ruby's method call */
    PUSH_ITER(ITER_CUR);
    PUSH_FRAME();
    proc = rb_f_lambda();
    POP_FRAME();
    POP_ITER();

    return proc;
}

static VALUE
bmcall(args, method)
    VALUE args, method;
{
    args = svalue_to_avalue(args);
    return method_call(RARRAY(args)->len, RARRAY(args)->ptr, method);
}

static VALUE
umcall(args, method)
    VALUE args, method;
{
    return method_call(0, 0, method);
}

VALUE
rb_proc_new(func, val)
    VALUE (*func)(ANYARGS);	/* VALUE yieldarg[, VALUE procarg] */
    VALUE val;
{
    return rb_iterate((VALUE(*)_((VALUE)))mproc, 0, func, val);
}

static VALUE
method_proc(method)
    VALUE method;
{
    return rb_iterate((VALUE(*)_((VALUE)))mproc, 0, bmcall, method);
}

static VALUE
umethod_proc(method)
    VALUE method;
{
    return rb_iterate((VALUE(*)_((VALUE)))mproc, 0, umcall, method);
}

static VALUE
rb_mod_define_method(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    ID id;
    VALUE body;
    NODE *node;
    int noex;

    if (argc == 1) {
	id = rb_to_id(argv[0]);
	body = rb_f_lambda();
    }
    else if (argc == 2) {
	id = rb_to_id(argv[0]);
	body = argv[1];
	if (!rb_obj_is_kind_of(body, rb_cMethod) && !rb_obj_is_proc(body)) {
	    rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc/Method)",
		     rb_class2name(CLASS_OF(body)));
	}
    }
    else {
	rb_raise(rb_eArgError, "wrong number of arguments(%d for 1)", argc);
    }
    if (RDATA(body)->dmark == (RUBY_DATA_FUNC)bm_mark) {
	node = NEW_DMETHOD(method_unbind(body));
    }
    else if (RDATA(body)->dmark == (RUBY_DATA_FUNC)blk_mark) {
	struct BLOCK *block;

	body = bind_clone(body);
	Data_Get_Struct(body, struct BLOCK, block);
	block->frame.last_func = id;
	block->frame.orig_func = id;
	block->frame.last_class = mod;
	node = NEW_BMETHOD(body);
    }
    else {
	/* type error */
	rb_raise(rb_eTypeError, "wrong argument type (expected Proc/Method)");
    }

    if (SCOPE_TEST(SCOPE_PRIVATE)) {
	noex = NOEX_PRIVATE;
    }
    else if (SCOPE_TEST(SCOPE_PROTECTED)) {
	noex = NOEX_PROTECTED;
    }
    else {
	noex = NOEX_PUBLIC;
    }
    rb_add_method(mod, id, node, noex);
    if (scope_vmode == SCOPE_MODFUNC) {
	rb_add_method(rb_singleton_class(mod), id, node, NOEX_PUBLIC);
	rb_funcall(mod, singleton_added, 1, ID2SYM(id));
    }
    if (FL_TEST(mod, FL_SINGLETON)) {
	rb_funcall(rb_iv_get(mod, "__attached__"), singleton_added, 1, ID2SYM(id));
    }
    else {
	rb_funcall(mod, added, 1, ID2SYM(id));
    }
    return body;
}

void
Init_Proc()
{
    rb_eLocalJumpError = rb_define_class("LocalJumpError", rb_eStandardError);
    rb_define_method(rb_eLocalJumpError, "exitstatus", localjump_exitstatus, 0);

    rb_eSysStackError = rb_define_class("SystemStackError", rb_eStandardError);

    rb_cProc = rb_define_class("Proc", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cProc), "allocate");
    rb_define_singleton_method(rb_cProc, "new", proc_s_new, -1);

    rb_define_method(rb_cProc, "call", proc_call, -2);
    rb_define_method(rb_cProc, "yield", proc_yield, -2);
    rb_define_method(rb_cProc, "arity", proc_arity, 0);
    rb_define_method(rb_cProc, "[]", proc_call, -2);
    rb_define_method(rb_cProc, "==", proc_eq, 1);
    rb_define_method(rb_cProc, "to_s", proc_to_s, 0);
    rb_define_method(rb_cProc, "to_proc", proc_to_proc, 0);
    rb_define_method(rb_cProc, "binding", proc_binding, 0);
    rb_define_global_function("proc", rb_f_lambda, 0);
    rb_define_global_function("lambda", rb_f_lambda, 0);
    rb_define_global_function("binding", rb_f_binding, 0);
    rb_cBinding = rb_define_class("Binding", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cBinding), "allocate");
    rb_undef_method(CLASS_OF(rb_cBinding), "new");
    rb_define_method(rb_cBinding, "clone", bind_clone, 0);

    rb_cMethod = rb_define_class("Method", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cMethod), "allocate");
    rb_undef_method(CLASS_OF(rb_cMethod), "new");
    rb_define_method(rb_cMethod, "==", method_eq, 1);
    rb_define_method(rb_cMethod, "clone", method_clone, 0);
    rb_define_method(rb_cMethod, "call", method_call, -1);
    rb_define_method(rb_cMethod, "[]", method_call, -1);
    rb_define_method(rb_cMethod, "arity", method_arity, 0);
    rb_define_method(rb_cMethod, "inspect", method_inspect, 0);
    rb_define_method(rb_cMethod, "to_s", method_inspect, 0);
    rb_define_method(rb_cMethod, "to_proc", method_proc, 0);
    rb_define_method(rb_cMethod, "unbind", method_unbind, 0);
    rb_define_method(rb_mKernel, "method", rb_obj_method, 1);

    rb_cUnboundMethod = rb_define_class("UnboundMethod", rb_cMethod);
    rb_define_method(rb_cUnboundMethod, "to_proc", umethod_proc, 0);
    rb_define_method(rb_cUnboundMethod, "bind", umethod_bind, 1);
    rb_define_method(rb_cUnboundMethod, "unbind", umethod_unbind, 0);
    rb_define_method(rb_cModule, "instance_method", rb_mod_method, 1);
}

/* Windows SEH refers data on the stack. */
#undef SAVE_WIN32_EXCEPTION_LIST
#if defined _WIN32 || defined __CYGWIN__
#if defined __CYGWIN__
typedef unsigned long DWORD;
#endif

static inline DWORD
win32_get_exception_list()
{
    DWORD p;
# if defined _MSC_VER
#   ifdef _M_IX86
#   define SAVE_WIN32_EXCEPTION_LIST
    __asm mov eax, fs:[0];
    __asm mov p, eax;
#   endif
# elif defined __GNUC__
#   ifdef __i386__
#   define SAVE_WIN32_EXCEPTION_LIST
    __asm__("movl %%fs:0,%0" : "=r"(p));
#   endif
# elif defined __BORLANDC__
#   define SAVE_WIN32_EXCEPTION_LIST
    __emit__(0x64, 0xA1, 0, 0, 0, 0); /* mov eax, fs:[0] */
    p = _EAX;
# endif
    return p;
}

static inline void
win32_set_exception_list(p)
    DWORD p;
{
# if defined _MSC_VER
#   ifdef _M_IX86
    __asm mov eax, p;
    __asm mov fs:[0], eax;
#   endif
# elif defined __GNUC__
#   ifdef __i386__
    __asm__("movl %0,%%fs:0" :: "r"(p));
#   endif
# elif defined __BORLANDC__
    _EAX = p;
    __emit__(0x64, 0xA3, 0, 0, 0, 0); /* mov fs:[0], eax */
# endif
}

#ifndef SAVE_WIN32_EXCEPTION_LIST
# error unsupported platform
#endif
#endif

static VALUE rb_eThreadError;

int rb_thread_pending = 0;

VALUE rb_cThread;

extern VALUE rb_last_status;

enum thread_status {
    THREAD_TO_KILL,
    THREAD_RUNNABLE,
    THREAD_STOPPED,
    THREAD_KILLED
};

#define WAIT_FD		(1<<0)
#define WAIT_SELECT	(1<<1)
#define WAIT_TIME	(1<<2)
#define WAIT_JOIN	(1<<3)
#define WAIT_PID	(1<<4)

/* +infty, for this purpose */
#define DELAY_INFTY 1E30

/* typedef struct thread * rb_thread_t; */

struct thread {
    struct thread *next, *prev;
    jmp_buf context;
#ifdef SAVE_WIN32_EXCEPTION_LIST
    DWORD win32_exception_list;
#endif

    VALUE result;

    int    stk_len;
    int   stk_max;
    VALUE*stk_ptr;
    VALUE*stk_pos;

    struct FRAME *frame;
    struct SCOPE *scope;
    struct RVarmap *dyna_vars;
    struct BLOCK *block;
    struct iter *iter;
    struct tag *tag;
    VALUE klass;
    VALUE wrapper;
    NODE *cref;

    int flags;		/* misc. states (vmode/rb_trap_immediate/raised) */

    NODE *node;

    int tracing;
    VALUE errinfo;
    VALUE last_status;
    VALUE last_line;
    VALUE last_match;

    int safe;

    enum thread_status status;
    int wait_for;
    int fd;
    fd_set readfds;
    fd_set writefds;
    fd_set exceptfds;
    int select_value;
    double delay;
    rb_thread_t join;

    int abort;
    int priority;
    int gid;

    st_table *locals;

    VALUE thread;
};

#define THREAD_RAISED 0x200	 /* temporary flag */
#define THREAD_TERMINATING 0x400 /* persistent flag */
#define THREAD_FLAGS_MASK  0x400 /* mask for persistent flags */

#define FOREACH_THREAD_FROM(f,x) x = f; do { x = x->next;
#define END_FOREACH_FROM(f,x) } while (x != f)

#define FOREACH_THREAD(x) FOREACH_THREAD_FROM(curr_thread,x)
#define END_FOREACH(x)    END_FOREACH_FROM(curr_thread,x)

struct thread_status_t {
    NODE *node;

    int tracing;
    VALUE errinfo;
    VALUE last_status;
    VALUE last_line;
    VALUE last_match;

    int safe;

    enum thread_status status;
    int wait_for;
    int fd;
    fd_set readfds;
    fd_set writefds;
    fd_set exceptfds;
    int select_value;
    double delay;
    rb_thread_t join;
};

#define THREAD_COPY_STATUS(src, dst) (void)(	\
    (dst)->node = (src)->node,			\
						\
    (dst)->tracing = (src)->tracing,		\
    (dst)->errinfo = (src)->errinfo,		\
    (dst)->last_status = (src)->last_status,	\
    (dst)->last_line = (src)->last_line,	\
    (dst)->last_match = (src)->last_match,	\
						\
    (dst)->safe = (src)->safe,			\
						\
    (dst)->status = (src)->status,		\
    (dst)->wait_for = (src)->wait_for,		\
    (dst)->fd = (src)->fd,			\
    (dst)->readfds = (src)->readfds,		\
    (dst)->writefds = (src)->writefds,		\
    (dst)->exceptfds = (src)->exceptfds,	\
    (dst)->select_value = (src)->select_value,	\
    (dst)->delay = (src)->delay,		\
    (dst)->join = (src)->join,			\
    0)

static void rb_thread_ready _((rb_thread_t));

static VALUE
rb_trap_eval(cmd, sig)
    VALUE cmd;
    int sig;
{
    int state;
    VALUE val;			/* OK */
    volatile struct thread_status_t save;

    THREAD_COPY_STATUS(curr_thread, &save);
    rb_thread_ready(curr_thread);
    PUSH_TAG(PROT_NONE);
    PUSH_ITER(ITER_NOT);
    if ((state = EXEC_TAG()) == 0) {
	val = rb_eval_cmd(cmd, rb_ary_new3(1, INT2FIX(sig)), 0);
    }
    POP_ITER();
    POP_TAG();
    THREAD_COPY_STATUS(&save, curr_thread);

    if (state) {
	rb_trap_immediate = 0;
	JUMP_TAG(state);
    }

    if (curr_thread->status == THREAD_STOPPED) {
	rb_thread_schedule();
    }
    errno = EINTR;

    return val;
}

static const char *
thread_status_name(status)
    enum thread_status status;
{
    switch (status) {
      case THREAD_RUNNABLE:
	return "run";
      case THREAD_STOPPED:
	return "sleep";
      case THREAD_TO_KILL:
	return "aborting";
      case THREAD_KILLED:
	return "dead";
      default:
	return "unknown";
    }
}

/* $SAFE accessor */
void
rb_set_safe_level(level)
    int level;
{
    if (level > ruby_safe_level) {
	ruby_safe_level = level;
	curr_thread->safe = level;
    }
}

static VALUE
safe_getter()
{
    return INT2NUM(ruby_safe_level);
}

static void
safe_setter(val)
    VALUE val;
{
    int level = NUM2INT(val);

    if (level < ruby_safe_level) {
	rb_raise(rb_eSecurityError, "tried to downgrade safe level from %d to %d",
		 ruby_safe_level, level);
    }
    ruby_safe_level = level;
    curr_thread->safe = level;
}

/* Return the current time as a floating-point number */
static double
timeofday()
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (double)tv.tv_sec + (double)tv.tv_usec * 1e-6;
}

#define STACK(addr) (th->stk_pos<(VALUE*)(addr) && (VALUE*)(addr)<th->stk_pos+th->stk_len)
#define ADJ(addr) (void*)(STACK(addr)?(((VALUE*)(addr)-th->stk_pos)+th->stk_ptr):(VALUE*)(addr))

static void
thread_mark(th)
    rb_thread_t th;
{
    struct FRAME *frame;
    struct BLOCK *block;

    rb_gc_mark(th->result);
    rb_gc_mark(th->thread);
    if (th->join) rb_gc_mark(th->join->thread);

    rb_gc_mark(th->klass);
    rb_gc_mark(th->wrapper);
    rb_gc_mark((VALUE)th->cref);

    rb_gc_mark((VALUE)th->scope);
    rb_gc_mark((VALUE)th->dyna_vars);
    rb_gc_mark(th->errinfo);
    rb_gc_mark(th->last_line);
    rb_gc_mark(th->last_match);
    rb_mark_tbl(th->locals);

    /* mark data in copied stack */
    if (th == curr_thread) return;
    if (th->status == THREAD_KILLED) return;
    if (th->stk_len == 0) return;  /* stack not active, no need to mark. */
    if (th->stk_ptr) {
	rb_gc_mark_locations(th->stk_ptr, th->stk_ptr+th->stk_len);
#if defined(THINK_C) || defined(__human68k__)
	rb_gc_mark_locations(th->stk_ptr+2, th->stk_ptr+th->stk_len+2);
#endif
    }
    frame = th->frame;
    while (frame && frame != top_frame) {
	frame = ADJ(frame);
	rb_gc_mark_frame(frame);
	if (frame->tmp) {
	    struct FRAME *tmp = frame->tmp;

	    while (tmp && tmp != top_frame) {
		tmp = ADJ(tmp);
		rb_gc_mark_frame(tmp);
		tmp = tmp->prev;
	    }
	}
	frame = frame->prev;
    }
    block = th->block;
    while (block) {
	block = ADJ(block);
	rb_gc_mark_frame(&block->frame);
	block = block->prev;
    }
}

void
rb_gc_mark_threads()
{
    rb_thread_t th;

    /* static global mark */
    rb_gc_mark((VALUE)ruby_cref);

    if (!curr_thread) return;
    FOREACH_THREAD(th) {
	rb_gc_mark(th->thread);
    } END_FOREACH(th);
}

static void
thread_free(th)
    rb_thread_t th;
{
    if (th->stk_ptr) free(th->stk_ptr);
    th->stk_ptr = 0;
    if (th->locals) st_free_table(th->locals);
    if (th->status != THREAD_KILLED) {
	if (th->prev) th->prev->next = th->next;
	if (th->next) th->next->prev = th->prev;
    }
    if (th != main_thread) free(th);
}

static rb_thread_t
rb_thread_check(data)
    VALUE data;
{
    if (TYPE(data) != T_DATA || RDATA(data)->dmark != (RUBY_DATA_FUNC)thread_mark) {
	rb_raise(rb_eTypeError, "wrong argument type %s (expected Thread)",
		 rb_class2name(CLASS_OF(data)));
    }
    return (rb_thread_t)RDATA(data)->data;
}

static VALUE rb_thread_raise _((int, VALUE*, rb_thread_t));

static int   th_raise_argc;
static VALUE th_raise_argv[2];
static NODE *th_raise_node;
static VALUE th_cmd;
static int   th_sig;
static char *th_signm;

#define RESTORE_NORMAL		1
#define RESTORE_FATAL		2
#define RESTORE_INTERRUPT	3
#define RESTORE_TRAP		4
#define RESTORE_RAISE		5
#define RESTORE_SIGNAL		6

extern VALUE *rb_gc_stack_start;

static void
rb_thread_save_context(th)
    rb_thread_t th;
{
    VALUE *pos;
    int len;
    static VALUE tval;

    len = ruby_stack_length(&pos);
    th->stk_len = 0;
    th->stk_pos = (rb_gc_stack_start<pos)?rb_gc_stack_start
				         :rb_gc_stack_start - len;
    if (len > th->stk_max) {
	REALLOC_N(th->stk_ptr, VALUE, len);
	th->stk_max = len;
    }
    th->stk_len = len;
    FLUSH_REGISTER_WINDOWS; 
    MEMCPY(th->stk_ptr, th->stk_pos, VALUE, th->stk_len);
#ifdef SAVE_WIN32_EXCEPTION_LIST
    th->win32_exception_list = win32_get_exception_list();
#endif

    th->frame = ruby_frame;
    th->scope = ruby_scope;
    th->klass = ruby_class;
    th->wrapper = ruby_wrapper;
    th->cref = ruby_cref;
    th->dyna_vars = ruby_dyna_vars;
    th->block = ruby_block;
    th->flags &= THREAD_FLAGS_MASK;
    th->flags |= (rb_trap_immediate<<8) | scope_vmode;
    th->iter = ruby_iter;
    th->tag = prot_tag;
    th->tracing = tracing;
    th->errinfo = ruby_errinfo;
    th->last_status = rb_last_status;
    tval = rb_lastline_get();
    rb_lastline_set(th->last_line);
    th->last_line = tval;
    tval = rb_backref_get();
    rb_backref_set(th->last_match);
    th->last_match = tval;
    th->safe = ruby_safe_level;

    th->node = ruby_current_node;
}

static int
thread_switch(n)
    int n;
{
    switch (n) {
      case 0:
	return 0;
      case RESTORE_FATAL:
	JUMP_TAG(TAG_FATAL);
	break;
      case RESTORE_INTERRUPT:
	rb_interrupt();
	break;
      case RESTORE_TRAP:
	rb_trap_eval(th_cmd, th_sig);
	break;
      case RESTORE_RAISE:
	ruby_frame->last_func = 0;
	ruby_current_node = th_raise_node;
	rb_f_raise(th_raise_argc, th_raise_argv);
	break;
      case RESTORE_SIGNAL:
	rb_raise(rb_eSignal, "SIG%s", th_signm);
	break;
      case RESTORE_NORMAL:
      default:
	break;
    }
    return 1;
}

#define THREAD_SAVE_CONTEXT(th) \
    (rb_thread_save_context(th),thread_switch(setjmp((th)->context)))

static void rb_thread_restore_context _((rb_thread_t,int));

static void
stack_extend(th, exit)
    rb_thread_t th;
    int exit;
{
    VALUE space[1024];

    memset(space, 0, 1);	/* prevent array from optimization */
    rb_thread_restore_context(th, exit);
}

static void
rb_thread_restore_context(th, exit)
    rb_thread_t th;
    int exit;
{
    VALUE v;
    static rb_thread_t tmp;
    static int ex;
    static VALUE tval;

    if (!th->stk_ptr) rb_bug("unsaved context");

    if (&v < rb_gc_stack_start) {
	/* Stack grows downward */
	if (&v > th->stk_pos) stack_extend(th, exit);
    }
    else {
	/* Stack grows upward */
	if (&v < th->stk_pos + th->stk_len) stack_extend(th, exit);
    }

    ruby_frame = th->frame;
    ruby_scope = th->scope;
    ruby_class = th->klass;
    ruby_wrapper = th->wrapper;
    ruby_cref = th->cref;
    ruby_dyna_vars = th->dyna_vars;
    ruby_block = th->block;
    scope_vmode = th->flags&SCOPE_MASK;
    rb_trap_immediate = (th->flags&0x100)?1:0;
    ruby_iter = th->iter;
    prot_tag = th->tag;
    tracing = th->tracing;
    ruby_errinfo = th->errinfo;
    rb_last_status = th->last_status;
    ruby_safe_level = th->safe;

    ruby_current_node = th->node;

#ifdef SAVE_WIN32_EXCEPTION_LIST
    win32_set_exception_list(th->win32_exception_list);
#endif
    tmp = th;
    ex = exit;
    FLUSH_REGISTER_WINDOWS;
    MEMCPY(tmp->stk_pos, tmp->stk_ptr, VALUE, tmp->stk_len);

    tval = rb_lastline_get();
    rb_lastline_set(tmp->last_line);
    tmp->last_line = tval;
    tval = rb_backref_get();
    rb_backref_set(tmp->last_match);
    tmp->last_match = tval;

    longjmp(tmp->context, ex);
}

static void
rb_thread_ready(th)
    rb_thread_t th;
{
    th->wait_for = 0;
    if (th->status != THREAD_TO_KILL) {
	th->status = THREAD_RUNNABLE;
    }
}

static void
rb_thread_die(th)
    rb_thread_t th;
{
    th->gid = 0;
    th->status = THREAD_KILLED;
    if (th->stk_ptr) free(th->stk_ptr);
    th->stk_ptr = 0;
}

static void
rb_thread_remove(th)
    rb_thread_t th;
{
    if (th->status == THREAD_KILLED) return;

    rb_thread_ready(th);
    rb_thread_die(th);
    th->prev->next = th->next;
    th->next->prev = th->prev;
}

static int
rb_thread_dead(th)
    rb_thread_t th;
{
    return th->status == THREAD_KILLED;
}

void
rb_thread_fd_close(fd)
    int fd;
{
    rb_thread_t th;

    FOREACH_THREAD(th) {
	if ((th->wait_for & WAIT_FD) && fd == th->fd) {
	    VALUE exc = rb_exc_new2(rb_eIOError, "stream closed");
	    rb_thread_raise(1, &exc, th);
	}
    }
    END_FOREACH(th);
}

static void
rb_thread_deadlock()
{
    char msg[21+SIZEOF_LONG*2];
    VALUE e;

    sprintf(msg, "Thread(0x%lx): deadlock", curr_thread->thread);
    e = rb_exc_new2(rb_eFatal, msg);
    if (curr_thread == main_thread) {
	rb_exc_raise(e);
    }
    curr_thread = main_thread;
    th_raise_argc = 1;
    th_raise_argv[0] = e;
    th_raise_node = ruby_current_node;
    rb_thread_restore_context(main_thread, RESTORE_RAISE);
}

static void
copy_fds(dst, src, max)
    fd_set *dst, *src;
    int max;
{
    int n = 0;
    int i;

    for (i=0; i<=max; i++) {
	if (FD_ISSET(i, src)) {
	    n = i;
	    FD_SET(i, dst);
	}
    }
}

static int
match_fds(dst, src, max)
    fd_set *dst, *src;
    int max;
{
    int i;

    for (i=0; i<=max; i++) {
	if (FD_ISSET(i, src) && FD_ISSET(i, dst)) {
	    return Qtrue;
	}
    }
    return Qfalse;
}

static int
intersect_fds(src, dst, max)
    fd_set *src, *dst;
    int max;
{
    int i, n = 0;

    for (i=0; i<=max; i++) {
	if (FD_ISSET(i, dst)) {
	    if (FD_ISSET(i, src)) {
		/* Wake up only one thread per fd. */
		FD_CLR(i, src);
		++n;
	    }
	    else {
		FD_CLR(i, dst);
	    }
	}
    }
    return n;
}

static int
find_bad_fds(dst, src, max)
    fd_set *dst, *src;
    int max;
{
    int i, test = Qfalse;

    for (i=0; i<=max; i++) {
	if (FD_ISSET(i, src) && !FD_ISSET(i, dst)) {
	    FD_CLR(i, src);
	    test = Qtrue;
	}
    }
    return test;
}

void
rb_thread_schedule()
{
    rb_thread_t next;		/* OK */
    rb_thread_t th;
    rb_thread_t curr;
    int found = 0;

    fd_set readfds;
    fd_set writefds;
    fd_set exceptfds;
    struct timeval delay_tv, *delay_ptr;
    double delay, now;	/* OK */
    int n, max;
    int need_select = 0;
    int select_timeout = 0;

    rb_thread_pending = 0;
    if (curr_thread == curr_thread->next
	&& curr_thread->status == THREAD_RUNNABLE)
	return;

    next = 0;
    curr = curr_thread;		/* starting thread */

    while (curr->status == THREAD_KILLED) {
	curr = curr->prev;
    }

  again:
    max = -1;
    FD_ZERO(&readfds);
    FD_ZERO(&writefds);
    FD_ZERO(&exceptfds);
    delay = DELAY_INFTY;
    now = -1.0;

    FOREACH_THREAD_FROM(curr, th) {
	if (!found && th->status <= THREAD_RUNNABLE) {
	    found = 1;
	}
	if (th->status != THREAD_STOPPED) continue;
	if (th->wait_for & WAIT_JOIN) {
	    if (rb_thread_dead(th->join)) {
		th->status = THREAD_RUNNABLE;
		found = 1;
	    }
	}
	if (th->wait_for & WAIT_FD) {
	    FD_SET(th->fd, &readfds);
	    if (max < th->fd) max = th->fd;
	    need_select = 1;
	}
	if (th->wait_for & WAIT_SELECT) {
	    copy_fds(&readfds, &th->readfds, th->fd);
	    copy_fds(&writefds, &th->writefds, th->fd);
	    copy_fds(&exceptfds, &th->exceptfds, th->fd);
	    if (max < th->fd) max = th->fd;
	    need_select = 1;
	    if (th->wait_for & WAIT_TIME) {
		select_timeout = 1;
	    }
	    th->select_value = 0;
	}
	if (th->wait_for & WAIT_TIME) {
	    double th_delay;

	    if (now < 0.0) now = timeofday();
	    th_delay = th->delay - now;
	    if (th_delay <= 0.0) {
		th->status = THREAD_RUNNABLE;
		found = 1;
	    }
	    else if (th_delay < delay) {
		delay = th_delay;
		need_select = 1;
	    }
	    else if (th->delay == DELAY_INFTY) {
		need_select = 1;
	    }
	}
    }
    END_FOREACH_FROM(curr, th);
    
    /* Do the select if needed */
    if (need_select) {
	/* Convert delay to a timeval */
	/* If a thread is runnable, just poll */
	if (found) {
	    delay_tv.tv_sec = 0;
	    delay_tv.tv_usec = 0;
	    delay_ptr = &delay_tv;
	}
	else if (delay == DELAY_INFTY) {
	    delay_ptr = 0;
	}
	else {
	    delay_tv.tv_sec = delay;
	    delay_tv.tv_usec = (delay - (double)delay_tv.tv_sec)*1e6;
	    delay_ptr = &delay_tv;
	}

	n = select(max+1, &readfds, &writefds, &exceptfds, delay_ptr);
	if (n < 0) {
	    int e = errno;

	    if (rb_trap_pending) rb_trap_exec();
	    if (e == EINTR) goto again;
#ifdef ERESTART
	    if (e == ERESTART) goto again;
#endif
	    FOREACH_THREAD_FROM(curr, th) {
		if (th->wait_for & WAIT_SELECT) {
		    int v = 0;

		    v |= find_bad_fds(&readfds, &th->readfds, th->fd);
		    v |= find_bad_fds(&writefds, &th->writefds, th->fd);
		    v |= find_bad_fds(&exceptfds, &th->exceptfds, th->fd);
		    if (v) {
			th->select_value = n;
			n = max;
		    }
		}
	    }
	    END_FOREACH_FROM(curr, th);
	}
 	if (select_timeout && n == 0) {
 	    if (now < 0.0) now = timeofday();
 	    FOREACH_THREAD_FROM(curr, th) {
 		if (((th->wait_for&(WAIT_SELECT|WAIT_TIME)) == (WAIT_SELECT|WAIT_TIME)) &&
		    th->delay <= now) {
 		    th->status = THREAD_RUNNABLE;
 		    th->wait_for = 0;
 		    th->select_value = 0;
 		    found = 1;
                    intersect_fds(&readfds, &th->readfds, max);
                    intersect_fds(&writefds, &th->writefds, max);
                    intersect_fds(&exceptfds, &th->exceptfds, max);
		}
	    }
	    END_FOREACH_FROM(curr, th);
	}
	if (n > 0) {
	    now = -1.0;
	    /* Some descriptors are ready. 
	       Make the corresponding threads runnable. */
	    FOREACH_THREAD_FROM(curr, th) {
		if ((th->wait_for&WAIT_FD) && FD_ISSET(th->fd, &readfds)) {
		    /* Wake up only one thread per fd. */
		    FD_CLR(th->fd, &readfds);
		    th->status = THREAD_RUNNABLE;
		    th->fd = 0;
		    th->wait_for = 0;
		    found = 1;
		}
		if ((th->wait_for&WAIT_SELECT) &&
		    (match_fds(&readfds, &th->readfds, max) ||
		     match_fds(&writefds, &th->writefds, max) ||
		     match_fds(&exceptfds, &th->exceptfds, max))) {
		    /* Wake up only one thread per fd. */
		    th->status = THREAD_RUNNABLE;
		    th->wait_for = 0;
		    n = intersect_fds(&readfds, &th->readfds, max) +
			intersect_fds(&writefds, &th->writefds, max) +
			intersect_fds(&exceptfds, &th->exceptfds, max);
		    th->select_value = n;
		    found = 1;
		}
	    }
	    END_FOREACH_FROM(curr, th);
	}
	/* The delays for some of the threads should have expired.
	   Go through the loop once more, to check the delays. */
	if (!found && delay != DELAY_INFTY)
	    goto again;
    }

    FOREACH_THREAD_FROM(curr, th) {
	if (th->status == THREAD_TO_KILL) {
	    next = th;
	    break;
	}
	if (th->status == THREAD_RUNNABLE && th->stk_ptr) {
	    if (!next || next->priority < th->priority) 
	       next = th;
	}
    }
    END_FOREACH_FROM(curr, th); 

    if (!next) {
	/* raise fatal error to main thread */
	curr_thread->node = ruby_current_node;
	FOREACH_THREAD_FROM(curr, th) {
	    fprintf(stderr, "deadlock 0x%lx: %s:",
		    th->thread, thread_status_name(th->status));
	    if (th->wait_for & WAIT_FD) fprintf(stderr, "F(%d)", th->fd);
	    if (th->wait_for & WAIT_SELECT) fprintf(stderr, "S");
	    if (th->wait_for & WAIT_TIME) fprintf(stderr, "T(%f)", th->delay);
	    if (th->wait_for & WAIT_JOIN)
		fprintf(stderr, "J(0x%lx)", th->join ? th->join->thread : 0);
	    if (th->wait_for & WAIT_PID) fprintf(stderr, "P");
	    if (!th->wait_for) fprintf(stderr, "-");
	    fprintf(stderr, " %s - %s:%d\n",
		    th==main_thread ? "(main)" : "",
		    th->node->nd_file, nd_line(th->node));
	}
	END_FOREACH_FROM(curr, th);
	fflush(stderr);
	next = main_thread;
	rb_thread_ready(next);
	next->status = THREAD_TO_KILL;
	rb_thread_save_context(curr_thread);
	rb_thread_deadlock();
    }
    next->wait_for = 0;
    if (next->status == THREAD_RUNNABLE && next == curr_thread) {
	return;
    }

    /* context switch */
    if (curr == curr_thread) {
	if (THREAD_SAVE_CONTEXT(curr)) {
	    return;
	}
    }

    curr_thread = next;
    if (next->status == THREAD_TO_KILL) {
	if (!(next->flags & THREAD_TERMINATING)) {
	    next->flags |= THREAD_TERMINATING;
	    /* terminate; execute ensure-clause if any */
	    rb_thread_restore_context(next, RESTORE_FATAL);
	}
    }
    rb_thread_restore_context(next, RESTORE_NORMAL);
}

void
rb_thread_wait_fd(fd)
    int fd;
{
    if (rb_thread_critical) return;
    if (curr_thread == curr_thread->next) return;
    if (curr_thread->status == THREAD_TO_KILL) return;

    curr_thread->status = THREAD_STOPPED;
    curr_thread->fd = fd;
    curr_thread->wait_for = WAIT_FD;
    rb_thread_schedule();
}

int
rb_thread_fd_writable(fd)
    int fd;
{
    if (rb_thread_critical) return Qtrue;
    if (curr_thread == curr_thread->next) return Qtrue;
    if (curr_thread->status == THREAD_TO_KILL) return Qtrue;

    curr_thread->status = THREAD_STOPPED;
    FD_ZERO(&curr_thread->readfds);
    FD_ZERO(&curr_thread->writefds);
    FD_SET(fd, &curr_thread->writefds);
    FD_ZERO(&curr_thread->exceptfds);
    curr_thread->fd = fd+1;
    curr_thread->wait_for = WAIT_SELECT;
    rb_thread_schedule();
    return Qfalse;
}

void
rb_thread_wait_for(time)
    struct timeval time;
{
    double date;

    if (rb_thread_critical ||
	curr_thread == curr_thread->next ||
	curr_thread->status == THREAD_TO_KILL) {
	int n;
#ifndef linux
	double d, limit;
	limit = timeofday()+(double)time.tv_sec+(double)time.tv_usec*1e-6;
#endif
	for (;;) {
	    TRAP_BEG;
	    n = select(0, 0, 0, 0, &time);
	    TRAP_END;
	    if (n == 0) return;
	    if (n < 0) {
		switch (errno) {
		  case EINTR:
#ifdef ERESTART
		  case ERESTART:
#endif
		    return;
		  default:
		    rb_sys_fail("sleep");
		}
	    }
#ifndef linux
	    d = limit - timeofday();

	    time.tv_sec = (int)d;
	    time.tv_usec = (int)((d - (int)d)*1e6);
	    if (time.tv_usec < 0) {
		time.tv_usec += (long)1e6;
		time.tv_sec -= 1;
	    }
	    if (time.tv_sec < 0) return;
#endif
	}
    }

    date = timeofday() + (double)time.tv_sec + (double)time.tv_usec*1e-6;
    curr_thread->status = THREAD_STOPPED;
    curr_thread->delay = date;
    curr_thread->wait_for = WAIT_TIME;
    rb_thread_schedule();
}

void rb_thread_sleep_forever _((void));

int
rb_thread_alone()
{
    return curr_thread == curr_thread->next;
}

int
rb_thread_select(max, read, write, except, timeout)
    int max;
    fd_set *read, *write, *except;
    struct timeval *timeout;
{
    double limit;
    int n;

    if (!read && !write && !except) {
	if (!timeout) {
	    rb_thread_sleep_forever();
	    return 0;
	}
	rb_thread_wait_for(*timeout);
	return 0;
    }

    if (timeout) {
	limit = timeofday()+
	    (double)timeout->tv_sec+(double)timeout->tv_usec*1e-6;
    }

    if (rb_thread_critical ||
	curr_thread == curr_thread->next ||
	curr_thread->status == THREAD_TO_KILL) {
#ifndef linux
	struct timeval tv, *tvp = timeout;

	if (timeout) {
	    tv = *timeout;
	    tvp = &tv;
	}
#else
	struct timeval *const tvp = timeout;
#endif
	for (;;) {
	    TRAP_BEG;
	    n = select(max, read, write, except, tvp);
	    TRAP_END;
	    if (n < 0) {
		switch (errno) {
		  case EINTR:
#ifdef ERESTART
		  case ERESTART:
#endif
#ifndef linux
		    if (timeout) {
			double d = limit - timeofday();

			tv.tv_sec = (unsigned int)d;
			tv.tv_usec = (long)((d-(double)tv.tv_sec)*1e6);
			if (tv.tv_sec < 0)  tv.tv_sec = 0;
			if (tv.tv_usec < 0) tv.tv_usec = 0;
		    }
#endif
		    continue;
		  default:
		    break;
		}
	    }
	    return n;
	}
    }

    curr_thread->status = THREAD_STOPPED;
    if (read) curr_thread->readfds = *read;
    else FD_ZERO(&curr_thread->readfds);
    if (write) curr_thread->writefds = *write;
    else FD_ZERO(&curr_thread->writefds);
    if (except) curr_thread->exceptfds = *except;
    else FD_ZERO(&curr_thread->exceptfds);
    curr_thread->fd = max;
    curr_thread->wait_for = WAIT_SELECT;
    if (timeout) {
	curr_thread->delay = timeofday() +
	    (double)timeout->tv_sec + (double)timeout->tv_usec*1e-6;
	curr_thread->wait_for |= WAIT_TIME;
    }
    rb_thread_schedule();
    if (read) *read = curr_thread->readfds;
    if (write) *write = curr_thread->writefds;
    if (except) *except = curr_thread->exceptfds;
    return curr_thread->select_value;
}

static int rb_thread_join _((rb_thread_t, double));

static int
rb_thread_join(th, limit)
    rb_thread_t th;
    double limit;
{
    enum thread_status last_status = THREAD_RUNNABLE;

    if (rb_thread_critical) rb_thread_deadlock();
    if (!rb_thread_dead(th)) {
	if (th == curr_thread)
	    rb_raise(rb_eThreadError, "thread 0x%lx tried to join itself",
		     th->thread);
	if ((th->wait_for & WAIT_JOIN) && th->join == curr_thread)
	    rb_raise(rb_eThreadError, "Thread#join: deadlock 0x%lx - mutual join(0x%lx)",
		     curr_thread->thread, th->thread);
	if (curr_thread->status == THREAD_TO_KILL)
	    last_status = THREAD_TO_KILL;
	if (limit == 0) return Qfalse;
	curr_thread->status = THREAD_STOPPED;
	curr_thread->join = th;
	curr_thread->wait_for = WAIT_JOIN;
	curr_thread->delay = timeofday() + limit;
	if (limit < DELAY_INFTY) curr_thread->wait_for |= WAIT_TIME;
	rb_thread_schedule();
	curr_thread->status = last_status;
	if (!rb_thread_dead(th)) return Qfalse;
    }

    if (!NIL_P(th->errinfo) && (th->flags & THREAD_RAISED)) {
	VALUE oldbt = get_backtrace(th->errinfo);
	VALUE errat = make_backtrace();

	if (TYPE(oldbt) == T_ARRAY && RARRAY(oldbt)->len > 0) {
	    rb_ary_unshift(errat, rb_ary_entry(oldbt, 0));
	}
	set_backtrace(th->errinfo, errat);
	rb_exc_raise(th->errinfo);
    }

    return Qtrue;
}

static VALUE
rb_thread_join_m(argc, argv, thread)
    int argc;
    VALUE *argv;
    VALUE thread;
{
    VALUE limit;
    double delay = DELAY_INFTY;
    rb_thread_t th = rb_thread_check(thread);

    rb_scan_args(argc, argv, "01", &limit);
    if (!NIL_P(limit)) delay = rb_num2dbl(limit);
    if (!rb_thread_join(th, delay))
	return Qnil;
    return thread;
}

VALUE
rb_thread_current()
{
    return curr_thread->thread;
}

VALUE
rb_thread_main()
{
    return main_thread->thread;
}

VALUE
rb_thread_list()
{
    rb_thread_t th;
    VALUE ary = rb_ary_new();

    FOREACH_THREAD(th) {
	switch (th->status) {
	  case THREAD_RUNNABLE:
	  case THREAD_STOPPED:
	  case THREAD_TO_KILL:
	    rb_ary_push(ary, th->thread);
	  default:
	    break;
	}
    }
    END_FOREACH(th);

    return ary;
}

VALUE
rb_thread_wakeup(thread)
    VALUE thread;
{
    rb_thread_t th = rb_thread_check(thread);

    if (th->status == THREAD_KILLED)
	rb_raise(rb_eThreadError, "killed thread");
    rb_thread_ready(th);

    return thread;
}

VALUE
rb_thread_run(thread)
    VALUE thread;
{
    rb_thread_wakeup(thread);
    if (!rb_thread_critical) rb_thread_schedule();

    return thread;
}

static VALUE
rb_thread_kill(thread)
    VALUE thread;
{
    rb_thread_t th = rb_thread_check(thread);

    if (th != curr_thread && th->safe < 4) {
	rb_secure(4);
    }
    if (th->status == THREAD_TO_KILL || th->status == THREAD_KILLED)
	return thread; 
    if (th == th->next || th == main_thread) rb_exit(0);

    rb_thread_ready(th);
    th->gid = 0;
    th->status = THREAD_TO_KILL;
    if (!rb_thread_critical) rb_thread_schedule();
    return thread;
}

static VALUE
rb_thread_s_kill(obj, th)
    VALUE obj, th;
{
    return rb_thread_kill(th);
}

static VALUE
rb_thread_exit()
{
    return rb_thread_kill(curr_thread->thread);
}

static VALUE
rb_thread_pass()
{
    rb_thread_schedule();
    return Qnil;
}

VALUE
rb_thread_stop()
{
    enum thread_status last_status = THREAD_RUNNABLE;

    rb_thread_critical = 0;
    if (curr_thread == curr_thread->next) {
	rb_raise(rb_eThreadError, "stopping only thread\n\tnote: use sleep to stop forever");
    }
    if (curr_thread->status == THREAD_TO_KILL)
	last_status = THREAD_TO_KILL;
    curr_thread->status = THREAD_STOPPED;
    rb_thread_schedule();
    curr_thread->status = last_status;

    return Qnil;
}

struct timeval rb_time_timeval();

void
rb_thread_polling()
{
    if (curr_thread != curr_thread->next) {
	curr_thread->status = THREAD_STOPPED;
	curr_thread->delay = timeofday() + (double)0.06;
	curr_thread->wait_for = WAIT_TIME;
	rb_thread_schedule();
    }
}

void
rb_thread_sleep(sec)
    int sec;
{
    if (curr_thread == curr_thread->next) {
	TRAP_BEG;
	sleep(sec);
	TRAP_END;
	return;
    }
    rb_thread_wait_for(rb_time_timeval(INT2FIX(sec)));
}

#if !defined HAVE_PAUSE
# if defined _WIN32 && !defined __CYGWIN__
#  define pause() Sleep(INFINITE)
# else
#  define pause() sleep(0x7fffffff)
# endif
#endif

void
rb_thread_sleep_forever()
{
    if (curr_thread == curr_thread->next ||
	curr_thread->status == THREAD_TO_KILL) {
	TRAP_BEG;
	pause();
	TRAP_END;
	return;
    }

    curr_thread->delay = DELAY_INFTY;
    curr_thread->wait_for = WAIT_TIME;
    curr_thread->status = THREAD_STOPPED;
    rb_thread_schedule();
}

static VALUE
rb_thread_priority(thread)
    VALUE thread;
{
    return INT2NUM(rb_thread_check(thread)->priority);
}

static VALUE
rb_thread_priority_set(thread, prio)
    VALUE thread, prio;
{
    rb_thread_t th;

    rb_secure(4);
    th = rb_thread_check(thread);

    th->priority = NUM2INT(prio);
    rb_thread_schedule();
    return prio;
}

static VALUE
rb_thread_safe_level(thread)
    VALUE thread;
{
    rb_thread_t th;

    th = rb_thread_check(thread);
    if (th == curr_thread) {
	return INT2NUM(ruby_safe_level);
    }
    return INT2NUM(th->safe);
}

static int thread_abort;

static VALUE
rb_thread_s_abort_exc()
{
    return thread_abort?Qtrue:Qfalse;
}

static VALUE
rb_thread_s_abort_exc_set(self, val)
    VALUE self, val;
{
    rb_secure(4);
    thread_abort = RTEST(val);
    return val;
}

static VALUE
rb_thread_abort_exc(thread)
    VALUE thread;
{
    return rb_thread_check(thread)->abort?Qtrue:Qfalse;
}

static VALUE
rb_thread_abort_exc_set(thread, val)
    VALUE thread, val;
{
    rb_secure(4);
    rb_thread_check(thread)->abort = RTEST(val);
    return val;
}

#define THREAD_ALLOC(th) do {\
    th = ALLOC(struct thread);\
\
    th->next = 0;\
    th->prev = 0;\
\
    th->status = THREAD_RUNNABLE;\
    th->result = 0;\
    th->flags = 0;\
\
    th->stk_ptr = 0;\
    th->stk_len = 0;\
    th->stk_max = 0;\
    th->wait_for = 0;\
    FD_ZERO(&th->readfds);\
    FD_ZERO(&th->writefds);\
    FD_ZERO(&th->exceptfds);\
    th->delay = 0.0;\
    th->join = 0;\
\
    th->frame = 0;\
    th->scope = 0;\
    th->klass = 0;\
    th->wrapper = 0;\
    th->cref = ruby_cref;\
    th->dyna_vars = ruby_dyna_vars;\
    th->block = 0;\
    th->iter = 0;\
    th->tag = 0;\
    th->tracing = 0;\
    th->errinfo = Qnil;\
    th->last_status = 0;\
    th->last_line = 0;\
    th->last_match = Qnil;\
    th->abort = 0;\
    th->priority = 0;\
    th->gid = 1;\
    th->locals = 0;\
} while (0)

static rb_thread_t
rb_thread_alloc(klass)
    VALUE klass;
{
    rb_thread_t th;
    struct RVarmap *vars;

    THREAD_ALLOC(th);
    th->thread = Data_Wrap_Struct(klass, thread_mark, thread_free, th);

    for (vars = th->dyna_vars; vars; vars = vars->next) {
	if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
	FL_SET(vars, DVAR_DONT_RECYCLE);
    }
    return th;
}

#if defined(HAVE_SETITIMER)
static void
catch_timer(sig)
    int sig;
{
#if !defined(POSIX_SIGNAL) && !defined(BSD_SIGNAL)
    signal(sig, catch_timer);
#endif
    if (!rb_thread_critical) {
	if (rb_trap_immediate) {
	    rb_thread_schedule();
	}
	else rb_thread_pending = 1;
    }
}
#else
int rb_thread_tick = THREAD_TICK;
#endif

#if defined(HAVE_SETITIMER)
static int thread_init = 0;

void
rb_thread_start_timer()
{
    struct itimerval tval;

    if (!thread_init) return;
    tval.it_interval.tv_sec = 0;
    tval.it_interval.tv_usec = 10000;
    tval.it_value = tval.it_interval;
    setitimer(ITIMER_VIRTUAL, &tval, NULL);
}

void
rb_thread_stop_timer()
{
    struct itimerval tval;

    if (!thread_init) return;
    tval.it_interval.tv_sec = 0;
    tval.it_interval.tv_usec = 0;
    tval.it_value = tval.it_interval;
    setitimer(ITIMER_VIRTUAL, &tval, NULL);
}
#endif

static VALUE
rb_thread_start_0(fn, arg, th_arg)
    VALUE (*fn)();
    void *arg;
    rb_thread_t th_arg;
{
    volatile rb_thread_t th = th_arg;
    volatile VALUE thread = th->thread;
    struct BLOCK* saved_block = 0;
    enum thread_status status;
    int state;

#if defined(HAVE_SETITIMER)
    if (!thread_init) {
#ifdef POSIX_SIGNAL
	posix_signal(SIGVTALRM, catch_timer);
#else
	signal(SIGVTALRM, catch_timer);
#endif

	thread_init = 1;
	rb_thread_start_timer();
    }
#endif

    if (THREAD_SAVE_CONTEXT(curr_thread)) {
	return thread;
    }

    if (ruby_block) {		/* should nail down higher blocks */
	struct BLOCK dummy;

	dummy.prev = ruby_block;
	blk_copy_prev(&dummy);
	saved_block = ruby_block = dummy.prev;
    }
    scope_dup(ruby_scope);

    if (!th->next) {
	/* merge in thread list */
	th->prev = curr_thread;
	curr_thread->next->prev = th;
	th->next = curr_thread->next;
	curr_thread->next = th;
	th->priority = curr_thread->priority;
	th->gid = curr_thread->gid;
    }

    PUSH_TAG(PROT_THREAD);
    if ((state = EXEC_TAG()) == 0) {
	if (THREAD_SAVE_CONTEXT(th) == 0) {
	    curr_thread = th;
	    th->result = (*fn)(arg, th);
	}
    }
    POP_TAG();
    status = th->status;

    if (th == main_thread) ruby_stop(state);
    rb_thread_remove(th);

    while (saved_block) {
	struct BLOCK *tmp = saved_block;

	if (tmp->frame.argc > 0)
	    free(tmp->frame.argv);
	saved_block = tmp->prev;
	free(tmp);
    }

    if (state && status != THREAD_TO_KILL && !NIL_P(ruby_errinfo)) {
	th->flags |= THREAD_RAISED;
	if (state == TAG_FATAL) { 
	    /* fatal error within this thread, need to stop whole script */
	    main_thread->errinfo = ruby_errinfo;
	    rb_thread_cleanup();
	}
	else if (rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
	    if (th->safe >= 4) {
		char buf[32];

		sprintf(buf, "Insecure exit at level %d", th->safe);
		th->errinfo = rb_exc_new2(rb_eSecurityError, buf);
	    }
	    else {
		/* delegate exception to main_thread */
		rb_thread_raise(1, &ruby_errinfo, main_thread);
	    }
	}
	else if (th->safe < 4 && (thread_abort || th->abort || RTEST(ruby_debug))) {
	    VALUE err = rb_exc_new(rb_eSystemExit, 0, 0);
	    error_print();
	    /* exit on main_thread */
	    rb_thread_raise(1, &err, main_thread);
	}
	else {
	    th->errinfo = ruby_errinfo;
	}
    }
    rb_thread_schedule();
    return 0;			/* not reached */
}

VALUE
rb_thread_create(fn, arg)
    VALUE (*fn)();
    void *arg;
{
    return rb_thread_start_0(fn, arg, rb_thread_alloc(rb_cThread));
}

static VALUE
rb_thread_yield(arg, th) 
    VALUE arg;
    rb_thread_t th;
{
    const ID *tbl;

    scope_dup(ruby_block->scope);

    tbl = ruby_scope->local_tbl;
    if (tbl) {
	int n = *tbl++;
	for (tbl += 2, n -= 2; n > 0; --n) { /* skip first 2 ($_ and $~) */
	    ID id = *tbl++;
	    if (id != 0 && !rb_is_local_id(id))  /* push flip states */
		rb_dvar_push(id, Qfalse);
	}
    }
    rb_dvar_push('_', Qnil);
    rb_dvar_push('~', Qnil);
    ruby_block->dyna_vars = ruby_dyna_vars;

    return rb_yield_0(mvalue_to_svalue(arg), 0, 0, Qtrue);
}

static VALUE
rb_thread_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    rb_thread_t th = rb_thread_alloc(klass);
    volatile VALUE *pos;

    pos = th->stk_pos;
    rb_obj_call_init(th->thread, argc, argv);
    if (th->stk_pos == 0) {
	rb_raise(rb_eThreadError, "uninitialized thread - check `%s#initialize'",
		 rb_class2name(klass));
    }

    return th->thread;
}

static VALUE
rb_thread_initialize(thread, args)
    VALUE thread, args;
{
    if (!rb_block_given_p()) {
	rb_raise(rb_eThreadError, "must be called with a block");
    }
    return rb_thread_start_0(rb_thread_yield, args, rb_thread_check(thread));
}

static VALUE
rb_thread_start(klass, args)
    VALUE klass, args;
{
    if (!rb_block_given_p()) {
	rb_raise(rb_eThreadError, "must be called with a block");
    }
    return rb_thread_start_0(rb_thread_yield, args, rb_thread_alloc(klass));
}

static VALUE
rb_thread_value(thread)
    VALUE thread;
{
    rb_thread_t th = rb_thread_check(thread);

    while (!rb_thread_join(th, DELAY_INFTY));

    return th->result;
}

static VALUE
rb_thread_status(thread)
    VALUE thread;
{
    rb_thread_t th = rb_thread_check(thread);

    if (rb_thread_dead(th)) {
	if (!NIL_P(th->errinfo) && (th->flags & THREAD_RAISED))
	    return Qnil;
	return Qfalse;
    }

    return rb_str_new2(thread_status_name(th->status));
}

static VALUE
rb_thread_alive_p(thread)
    VALUE thread;
{
    rb_thread_t th = rb_thread_check(thread);

    if (rb_thread_dead(th)) return Qfalse;
    return Qtrue;
}

static VALUE
rb_thread_stop_p(thread)
    VALUE thread;
{
    rb_thread_t th = rb_thread_check(thread);

    if (rb_thread_dead(th)) return Qtrue;
    if (th->status == THREAD_STOPPED) return Qtrue;
    return Qfalse;
}

static void
rb_thread_wait_other_threads()
{
    rb_thread_t th;
    int found;

    /* wait other threads to terminate */
    while (curr_thread != curr_thread->next) {
	found = 0;
	FOREACH_THREAD(th) {
	    if (th != curr_thread && th->status != THREAD_STOPPED) {
		found = 1;
		break;
	    }
	}
	END_FOREACH(th);
	if (!found) return;
	rb_thread_schedule();
    }
}

static void
rb_thread_cleanup()
{
    rb_thread_t curr, th;

    curr = curr_thread;
    while (curr->status == THREAD_KILLED) {
	curr = curr->prev;
    }

    FOREACH_THREAD_FROM(curr, th) {
	if (th->status != THREAD_KILLED) {
	    rb_thread_ready(th);
	    th->gid = 0;
	    th->priority = 0;
	    if (th != main_thread) {
		th->status = THREAD_TO_KILL;
		RDATA(th->thread)->dfree = NULL;
	    }
	}
    }
    END_FOREACH_FROM(curr, th);
}

int rb_thread_critical;

static VALUE
rb_thread_critical_get()
{
    return rb_thread_critical?Qtrue:Qfalse;
}

static VALUE
rb_thread_critical_set(obj, val)
    VALUE obj, val;
{
    rb_thread_critical = RTEST(val);
    return val;
}

void
rb_thread_interrupt()
{
    rb_thread_critical = 0;
    rb_thread_ready(main_thread);
    if (curr_thread == main_thread) {
	rb_interrupt();
    }
    if (!rb_thread_dead(curr_thread)) {
	if (THREAD_SAVE_CONTEXT(curr_thread)) {
	    return;
	}
    }
    curr_thread = main_thread;
    rb_thread_restore_context(curr_thread, RESTORE_INTERRUPT);
}

void
rb_thread_signal_raise(sig)
    char *sig;
{
    if (sig == 0) return;	/* should not happen */
    rb_thread_critical = 0;
    if (curr_thread == main_thread) {
	rb_thread_ready(curr_thread);
	rb_raise(rb_eSignal, "SIG%s", sig);
    }
    rb_thread_ready(main_thread);
    if (!rb_thread_dead(curr_thread)) {
	if (THREAD_SAVE_CONTEXT(curr_thread)) {
	    return;
	}
    }
    th_signm = sig;
    curr_thread = main_thread;
    rb_thread_restore_context(curr_thread, RESTORE_SIGNAL);
}

void
rb_thread_trap_eval(cmd, sig)
    VALUE cmd;
    int sig;
{
#if 0
    rb_thread_critical = 0;
    if (!rb_thread_dead(curr_thread)) {
	rb_thread_ready(curr_thread);
	rb_trap_eval(cmd, sig);
	return;
    }
    rb_thread_ready(main_thread);
    if (THREAD_SAVE_CONTEXT(curr_thread)) {
	return;
    }
    th_cmd = cmd;
    th_sig = sig;
    curr_thread = main_thread;
    rb_thread_restore_context(curr_thread, RESTORE_TRAP);
#else
    rb_thread_critical = 0;
    if (!rb_thread_dead(curr_thread)) {
	if (THREAD_SAVE_CONTEXT(curr_thread)) {
	    return;
	}
    }
    th_cmd = cmd;
    th_sig = sig;
    curr_thread = main_thread;
    rb_thread_restore_context(curr_thread, RESTORE_TRAP);
#endif
}

static VALUE
rb_thread_raise(argc, argv, th)
    int argc;
    VALUE *argv;
    rb_thread_t th;
{
    if (rb_thread_dead(th)) return Qnil;
    if (curr_thread == th) {
	rb_f_raise(argc, argv);
    }

    if (!rb_thread_dead(curr_thread)) {
	if (THREAD_SAVE_CONTEXT(curr_thread)) {
	    return th->thread;
	}
    }

    rb_scan_args(argc, argv, "11", &th_raise_argv[0], &th_raise_argv[1]);
    rb_thread_ready(th);
    curr_thread = th;

    th_raise_argc = argc;
    th_raise_node = ruby_current_node;
    rb_thread_restore_context(curr_thread, RESTORE_RAISE);
    return Qnil;		/* not reached */
}

static VALUE
rb_thread_raise_m(argc, argv, thread)
    int argc;
    VALUE *argv;
    VALUE thread;
{
    rb_thread_t th = rb_thread_check(thread);

    if (ruby_safe_level > th->safe) {
	rb_secure(4);
    }
    rb_thread_raise(argc, argv, th);
    return Qnil;		/* not reached */
}

VALUE
rb_thread_local_aref(thread, id)
    VALUE thread;
    ID id;
{
    rb_thread_t th;
    VALUE val;

    th = rb_thread_check(thread);
    if (ruby_safe_level >= 4 && th != curr_thread) {
	rb_raise(rb_eSecurityError, "Insecure: thread locals");
    }
    if (!th->locals) return Qnil;
    if (st_lookup(th->locals, id, &val)) {
	return val;
    }
    return Qnil;
}

static VALUE
rb_thread_aref(thread, id)
    VALUE thread, id;
{
    return rb_thread_local_aref(thread, rb_to_id(id));
}

VALUE
rb_thread_local_aset(thread, id, val)
    VALUE thread;
    ID id;
    VALUE val;
{
    rb_thread_t th = rb_thread_check(thread);

    if (ruby_safe_level >= 4 && th != curr_thread) {
	rb_raise(rb_eSecurityError, "Insecure: can't modify thread locals");
    }
    if (OBJ_FROZEN(thread)) rb_error_frozen("thread locals");

    if (!th->locals) {
	th->locals = st_init_numtable();
    }
    if (NIL_P(val)) {
	st_delete(th->locals, &id, 0);
	return Qnil;
    }
    st_insert(th->locals, id, val);

    return val;
}

static VALUE
rb_thread_aset(thread, id, val)
    VALUE thread, id, val;
{
    return rb_thread_local_aset(thread, rb_to_id(id), val);
}

static VALUE
rb_thread_key_p(thread, id)
    VALUE thread, id;
{
    rb_thread_t th = rb_thread_check(thread);

    if (!th->locals) return Qfalse;
    if (st_lookup(th->locals, rb_to_id(id), 0))
	return Qtrue;
    return Qfalse;
}

static int
thread_keys_i(key, value, ary)
    ID key;
    VALUE value, ary;
{
    rb_ary_push(ary, ID2SYM(key));
    return ST_CONTINUE;
}

static VALUE
rb_thread_keys(thread)
    VALUE thread;
{
    rb_thread_t th = rb_thread_check(thread);
    VALUE ary = rb_ary_new();

    if (th->locals) {
	st_foreach(th->locals, thread_keys_i, ary);
    }
    return ary;
}

static VALUE
rb_thread_inspect(thread)
    VALUE thread;
{
    char *cname = rb_class2name(CLASS_OF(thread));
    rb_thread_t th = rb_thread_check(thread);
    const char *status = thread_status_name(th->status);
    VALUE str;

    str = rb_str_new(0, strlen(cname)+7+16+9+1); /* 7:tags 16:addr 9:status 1:nul */ 
    sprintf(RSTRING(str)->ptr, "#<%s:0x%lx %s>", cname, thread, status);
    RSTRING(str)->len = strlen(RSTRING(str)->ptr);
    OBJ_INFECT(str, thread);

    return str;
}

void
rb_thread_atfork()
{
    rb_thread_t th;

    if (rb_thread_alone()) return;
    FOREACH_THREAD(th) {
	if (th != curr_thread) {
	    rb_thread_die(th);
	}
    }
    END_FOREACH(th);
    main_thread = curr_thread;
    curr_thread->next = curr_thread;
    curr_thread->prev = curr_thread;
}

static VALUE rb_cCont;

static VALUE
rb_callcc(self)
    VALUE self;
{
    volatile VALUE cont;
    rb_thread_t th;
    struct tag *tag;
    struct RVarmap *vars;

    THREAD_ALLOC(th);
    cont = Data_Wrap_Struct(rb_cCont, thread_mark, thread_free, th);

    scope_dup(ruby_scope);
    for (tag=prot_tag; tag; tag=tag->prev) {
	scope_dup(tag->scope);
    }
    if (ruby_block) {
	struct BLOCK *block = ruby_block;

	while (block) {
	    block->tag->flags |= BLOCK_DYNAMIC;
	    block = block->prev;
	}
    }
    th->thread = curr_thread->thread;

    for (vars = th->dyna_vars; vars; vars = vars->next) {
	if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
	FL_SET(vars, DVAR_DONT_RECYCLE);
    }

    if (THREAD_SAVE_CONTEXT(th)) {
	return th->result;
    }
    else {
	return rb_yield(cont);
    }
}

static VALUE
rb_cont_call(argc, argv, cont)
    int argc;
    VALUE *argv;
    VALUE cont;
{
    rb_thread_t th = rb_thread_check(cont);

    if (th->thread != curr_thread->thread) {
	rb_raise(rb_eRuntimeError, "continuation called across threads");
    }
    switch (argc) {
      case 0:
	th->result = Qnil;
	break;
      case 1:
	th->result = *argv;
	break;
      default:
	th->result = rb_ary_new4(argc, argv);
	break;
    }

    rb_thread_restore_context(th, RESTORE_NORMAL);
    return Qnil;
}

struct thgroup {
    int gid;
};

static VALUE
thgroup_s_alloc(klass)
    VALUE klass;
{
    VALUE group;
    struct thgroup *data;
    static int serial = 1;

    group = Data_Make_Struct(klass, struct thgroup, 0, free, data);
    data->gid = serial++;

    return group;
}

static VALUE
thgroup_list(group)
    VALUE group;
{
    struct thgroup *data;
    rb_thread_t th;
    VALUE ary;

    Data_Get_Struct(group, struct thgroup, data);
    ary = rb_ary_new();

    FOREACH_THREAD(th) {
	if (th->gid == data->gid) {
	    rb_ary_push(ary, th->thread);
	}
    }
    END_FOREACH(th);

    return ary;
}

static VALUE
thgroup_add(group, thread)
    VALUE group, thread;
{
    rb_thread_t th;
    struct thgroup *data;

    rb_secure(4);
    th = rb_thread_check(thread);
    Data_Get_Struct(group, struct thgroup, data);

    th->gid = data->gid;
    return group;
}

void
Init_Thread()
{
    VALUE cThGroup;

    rb_eThreadError = rb_define_class("ThreadError", rb_eStandardError);
    rb_cThread = rb_define_class("Thread", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cThread), "allocate");

    rb_define_singleton_method(rb_cThread, "new", rb_thread_s_new, -1);
    rb_define_method(rb_cThread, "initialize", rb_thread_initialize, -2);
    rb_define_singleton_method(rb_cThread, "start", rb_thread_start, -2);
    rb_define_singleton_method(rb_cThread, "fork", rb_thread_start, -2);

    rb_define_singleton_method(rb_cThread, "stop", rb_thread_stop, 0);
    rb_define_singleton_method(rb_cThread, "kill", rb_thread_s_kill, 1);
    rb_define_singleton_method(rb_cThread, "exit", rb_thread_exit, 0);
    rb_define_singleton_method(rb_cThread, "pass", rb_thread_pass, 0);
    rb_define_singleton_method(rb_cThread, "current", rb_thread_current, 0);
    rb_define_singleton_method(rb_cThread, "main", rb_thread_main, 0);
    rb_define_singleton_method(rb_cThread, "list", rb_thread_list, 0);

    rb_define_singleton_method(rb_cThread, "critical", rb_thread_critical_get, 0);
    rb_define_singleton_method(rb_cThread, "critical=", rb_thread_critical_set, 1);

    rb_define_singleton_method(rb_cThread, "abort_on_exception", rb_thread_s_abort_exc, 0);
    rb_define_singleton_method(rb_cThread, "abort_on_exception=", rb_thread_s_abort_exc_set, 1);

    rb_define_method(rb_cThread, "run", rb_thread_run, 0);
    rb_define_method(rb_cThread, "wakeup", rb_thread_wakeup, 0);
    rb_define_method(rb_cThread, "kill", rb_thread_kill, 0);
    rb_define_method(rb_cThread, "exit", rb_thread_kill, 0);
    rb_define_method(rb_cThread, "value", rb_thread_value, 0);
    rb_define_method(rb_cThread, "status", rb_thread_status, 0);
    rb_define_method(rb_cThread, "join", rb_thread_join_m, -1);
    rb_define_method(rb_cThread, "alive?", rb_thread_alive_p, 0);
    rb_define_method(rb_cThread, "stop?", rb_thread_stop_p, 0);
    rb_define_method(rb_cThread, "raise", rb_thread_raise_m, -1);

    rb_define_method(rb_cThread, "abort_on_exception", rb_thread_abort_exc, 0);
    rb_define_method(rb_cThread, "abort_on_exception=", rb_thread_abort_exc_set, 1);

    rb_define_method(rb_cThread, "priority", rb_thread_priority, 0);
    rb_define_method(rb_cThread, "priority=", rb_thread_priority_set, 1);
    rb_define_method(rb_cThread, "safe_level", rb_thread_safe_level, 0);

    rb_define_method(rb_cThread, "[]", rb_thread_aref, 1);
    rb_define_method(rb_cThread, "[]=", rb_thread_aset, 2);
    rb_define_method(rb_cThread, "key?", rb_thread_key_p, 1);
    rb_define_method(rb_cThread, "keys", rb_thread_keys, 0);

    rb_define_method(rb_cThread, "inspect", rb_thread_inspect, 0);

    /* allocate main thread */
    main_thread = rb_thread_alloc(rb_cThread);
    curr_thread = main_thread->prev = main_thread->next = main_thread;

    rb_cCont = rb_define_class("Continuation", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cCont), "allocate");
    rb_undef_method(CLASS_OF(rb_cCont), "new");
    rb_define_method(rb_cCont, "call", rb_cont_call, -1);
    rb_define_global_function("callcc", rb_callcc, 0);

    cThGroup = rb_define_class("ThreadGroup", rb_cObject);
    rb_define_singleton_method(cThGroup, "allocate", thgroup_s_alloc, 0);
    rb_define_method(cThGroup, "list", thgroup_list, 0);
    rb_define_method(cThGroup, "add", thgroup_add, 1);
    rb_define_const(cThGroup, "Default", rb_obj_alloc(cThGroup));
}

static VALUE
rb_f_catch(dmy, tag)
    VALUE dmy, tag;
{
    int state;
    ID t;
    VALUE val;			/* OK */

    t = rb_to_id(tag);
    PUSH_TAG(t);
    if ((state = EXEC_TAG()) == 0) {
	val = rb_yield_0(tag, 0, 0, 0);
    }
    else if (state == TAG_THROW && t == prot_tag->dst) {
	val = prot_tag->retval;
	state = 0;
    }
    POP_TAG();
    if (state) JUMP_TAG(state);

    return val;
}

static VALUE
catch_i(tag)
    ID tag;
{
    return rb_funcall(Qnil, rb_intern("catch"), 1, ID2SYM(tag));
}

VALUE
rb_catch(tag, proc, data)
    const char *tag;
    VALUE (*proc)();
    VALUE data;
{
    return rb_iterate((VALUE(*)_((VALUE)))catch_i, rb_intern(tag), proc, data);
}

static VALUE
rb_f_throw(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE tag, value;
    ID t;
    struct tag *tt = prot_tag;

    rb_scan_args(argc, argv, "11", &tag, &value);
    t = rb_to_id(tag);

    while (tt) {
	if (tt->tag == t) {
	    tt->dst = t;
	    break;
	}
	if (tt->tag == PROT_THREAD) {
	    rb_raise(rb_eThreadError, "uncaught throw `%s' in thread 0x%lx",
		     rb_id2name(t),
		     curr_thread);
	}
	tt = tt->prev;
    }
    if (!tt) {
	rb_name_error(t, "uncaught throw `%s'", rb_id2name(t));
    }
    return_value(value);
    rb_trap_restore_mask();
    JUMP_TAG(TAG_THROW);
}

void
rb_throw(tag, val)
    const char *tag;
    VALUE val;
{
    VALUE argv[2];
    ID t = rb_intern(tag);

    argv[0] = ID2SYM(t);
    argv[1] = val;
    rb_f_throw(2, argv);
}

static void
return_check()
{
    struct tag *tt = prot_tag;

    while (tt) {
	if (tt->tag == PROT_FUNC) {
	    break;
	}
	if (tt->tag == PROT_THREAD) {
	    rb_raise(rb_eThreadError, "return from within thread 0x%lx",
		     curr_thread);
	}
	tt = tt->prev;
    }
}
@


1.346
log
@* eval.c, file.c, gc.c, io.c, object.c, ruby.c, ruby.h, struct.c,
  ext/socket/socket.c: differentiate long and int; use proper
  printf type specifiers and do casts where appropriate.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/10/29 19:11:17 $
d3513 46
a3558 2
    if (rb_method_boundp(mod, rb_to_id(mid), 1)) {
	return Qtrue;
d6199 3
@


1.345
log
@	* eval.c (error_print, rb_longjmp, rb_thread_schedule): flush
	  error message.  [ruby-dev:18582]

	* eval.c (ruby_cleanup): added.  just clean up without exit.
	  [ruby-dev:18582]

	* eval.c (ruby_exec): added.  execute main evaluation tree without
	  exit.  [ruby-dev:18582]

	* intern.h: prototypes; ruby_cleanup, ruby_exec
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2002/10/25 18:39:29 $
d4725 1
a4725 1
	rb_raise(rb_eNotImpError, "method `%s' called on terminated object (0x%x)",
d9515 1
a9515 1
	    rb_raise(rb_eThreadError, "uncaught throw `%s' in thread 0x%x",
d9552 1
a9552 1
	    rb_raise(rb_eThreadError, "return from within thread 0x%x",
@


1.344
log
@* eval.c, gc.c: adopt a common set of alloca() #ifdef's.  This
  fixes the build with Intel C Compiler for Linux.

* eval.c (rb_f_require): declare old_func with a real type, not
  just type modifiers.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/10/23 10:17:29 $
d1047 1
d1233 2
a1234 2
void
ruby_stop(ex)
d1255 1
a1255 1
    exit(ex);
d1258 2
a1259 2
void
ruby_run()
a1261 1
    static int ex;
a1263 2
    if (ruby_nerrs > 0) exit(ruby_nerrs);

d1274 2
d1277 14
d3628 1
d8138 1
@


1.343
log
@* eval.c (rb_eval): added NODE_DSYM, symbol literal with
  interpolation.

* node.h: ditto.

* intern.h: prototypes; rb_is_junk_id, rb_str_dump, rb_str_intern

* object.c (sym_inspect): escape and quote for non-alphanumeric
  symbols.

* parse.y (dsym, tokadd_string, yylex): extended symbol literals.

* parse.y (rb_is_junk_id): added.

* string.c (rb_str_dump, rb_str_intern) : make extern.

* lib/mkmf.rb (create_makefile): deffile should be removed by
  distclean, not clean.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2002/10/17 16:13:44 $
d38 1
a38 1
# if defined(HAVE_ALLOCA_H)
d40 9
a48 3
# elif !defined(alloca)
char *alloca();
# endif
a50 4
#ifdef _AIX
#pragma alloca
#endif

d5606 1
a5606 1
	const volatile old_func = ruby_frame->last_func;
@


1.342
log
@* hash.c, eval.c: Use (*_NSGetEnviron()) instead of environ on
  Darwin for namespace cleanness.  [ruby-core:00537]

* dln.c (dln_load): Fix Darwin support that has been disabled and
  switch to using it on Darwin instead of the system dlopen().
  [ruby-core:00541]
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/10/05 15:46:24 $
d3092 1
d3126 3
@


1.341
log
@* eval.c (rb_load): should not pass block to the loaded file.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/10/04 11:32:16 $
d26 4
d1047 3
a1049 1
#if !defined(NT) && !defined(__MACOS__)
@


1.340
log
@* eval.c (rb_thread_interrupt, rb_thread_signal_raise): no need to
  save dead thread context. (same as [ruby-dev:18322])
  (ruby-bugs-ja:PR#349)
@
text
@d6 1
a6 1
  $Date: 2002/10/03 11:20:29 $
d5349 1
d5384 1
@


1.339
log
@* bcc32/mkexports.rb: to work on cygwin via telnet.
  [ruby-win32:358]

* ext/tcltklib/tcltklib.c (ip_invoke): requires command name
  argument.  [ruby-dev:18438]

* eval.c (ruby_init, ruby_options): Init_stack() with local
  location.  (ruby-bugs-ja:PR#277)

* eval.c (rb_call0): disable trace call.  [ruby-dev:18074]

* eval.c (eval, rb_load): enable trace call.  [ruby-dev:18074]

* eval.c (rb_f_require): set source file name for extension
  libraries.  [ruby-dev:18445]

* ruby.c (translate_char): translate a character in a string;
  DOSISH only.  [ruby-dev:18274]

* ruby.c (ruby_init_loadpath): added argv[0] handling under
  Human68K.  [ruby-dev:18274]

* ruby.c (proc_options): translate directory separator in $0 to
  '/'.  [ruby-dev:18274]
@
text
@d6 1
a6 1
  $Date: 2002/09/27 09:42:24 $
d9004 4
a9007 2
    if (THREAD_SAVE_CONTEXT(curr_thread)) {
	return;
d9024 4
a9027 2
    if (THREAD_SAVE_CONTEXT(curr_thread)) {
	return;
d9079 4
a9082 2
    if (!rb_thread_dead(curr_thread) && THREAD_SAVE_CONTEXT(curr_thread)) {
	return th->thread;
@


1.338
log
@* eval.c (rb_thread_deadlock, rb_thread_schedule, rb_thread_join): more verbose message at deadlock.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/27 04:26:21 $
d890 2
d1074 1
a1074 1
    Init_stack(0);
d1195 1
d1872 1
a1872 1
	    int call = nd_type(node)== NODE_CALL;
d4505 1
d4508 1
d4514 1
d4977 1
d5040 1
d5082 1
d5316 1
d5370 1
d5386 1
d5591 2
d5594 4
d5607 3
@


1.337
log
@* eval.c (rb_eval): Class#inherited should be called after the
  execution of the class body.

* parse.y (primary): remove "return outside of method" check at
  compile time.
@
text
@d6 1
a6 1
  $Date: 2002/09/26 00:48:33 $
d7797 5
d7803 1
a7803 1
	rb_raise(rb_eFatal, "Thread: deadlock");
d7807 1
a7807 1
    th_raise_argv[0] = rb_exc_new2(rb_eFatal, "Thread: deadlock");
d8074 11
a8084 3
	    fprintf(stderr, "deadlock 0x%lx: %d:%d %s - %s:%d\n", 
		    th->thread, th->status,
		    th->wait_for, th==main_thread ? "(main)" : "",
d8307 2
a8308 1
	    rb_raise(rb_eThreadError, "thread tried to join itself");
d8310 2
a8311 1
	    rb_raise(rb_eThreadError, "Thread#join: deadlock - mutual join");
@


1.336
log
@
* regex.c (re_match): p1 may exceed pend limit.
@
text
@d6 1
a6 1
  $Date: 2002/09/25 07:03:01 $
d3284 1
a3294 1
		rb_class_inherited(super, klass);
d3303 1
@


1.335
log
@* io.c (appendline): forget to terminate with nul.

* eval.c (ruby_run): should set toplevel visibility again here.

* eval.c (rb_eval): should not rely on ruby_class == rb_cObject
  check.   Besides allow implicit publicity for attribute set
  methods.

* parse.y (primary): need not to check class_nest, just set
  whether method is an attrset or not.

* string.c (rb_str_each_line): p might be at the top of the
  string.

* class.c (rb_make_metaclass): class of metaclass should be
  metaclass of superclass, unless class itself is a metaclass;
  class of metaclass of metaclass should point back to self.
  eh, confusing, isn't it.

* class.c (rb_singleton_class): check if its class is singleton
  AND attached to self.

* eval.c (rb_eval): should define class/module under ruby_cbase.

* eval.c (rb_eval): should set class/module path based on
  ruby_cbase, not ruby_class.

* eval.c (module_setup): use ruby_cbase instead of ruby_class.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/09/23 15:48:42 $
a3162 5
		}
		if (node->nd_noex) { /* toplevel */
		    /* should upgrade to rb_warn() if no super was called inside? */
		    rb_warning("overriding global function `%s'",
			       rb_id2name(node->nd_mid));
@


1.334
log
@* eval.c (rb_call0): must not clear ruby_current_node, or
  backtrace cannot be genetated.

* intern.h (ruby_yyparse): rather than yyparse().

* parse.y (yylex): nextc() returns -1 at end of input, not 0.

* parse.y (newline_node): reduce deplicated newline node.

* parse.y (literal_concat): get rid of warning.

* parse.y (new_evstr): fixed junk code.
@
text
@d6 1
a6 1
  $Date: 2002/09/22 12:52:18 $
d1258 2
d2928 1
a2928 1
	if (NIL_P(ruby_class)) {
d3171 4
a3174 1
	    if (SCOPE_TEST(SCOPE_PRIVATE) || node->nd_mid == init) {
a3179 3
	    else if (ruby_class == rb_cObject) {
		noex =  node->nd_noex;
	    }
d3265 1
a3265 1
	    if (NIL_P(ruby_class)) {
d3275 1
a3275 1
	    if ((ruby_class == rb_cObject) && rb_autoload_defined(node->nd_cname)) {
d3278 2
a3279 2
	    if (rb_const_defined_at(ruby_class, node->nd_cname)) {
		klass = rb_const_get(ruby_class, node->nd_cname);
d3298 1
a3298 1
		rb_set_class_path(klass,ruby_class,rb_id2name(node->nd_cname));
d3315 1
a3315 1
	    if (NIL_P(ruby_class)) {
d3318 1
a3318 1
	    if ((ruby_class == rb_cObject) && rb_autoload_defined(node->nd_cname)) {
d3321 2
a3322 2
	    if (rb_const_defined_at(ruby_class, node->nd_cname)) {
		module = rb_const_get(ruby_class, node->nd_cname);
d3333 1
a3334 1
		rb_set_class_path(module,ruby_class,rb_id2name(node->nd_cname));
d3434 1
a3434 1
	    call_trace_func("class", ruby_current_node, ruby_class,
d3438 1
a3438 1
	result = rb_eval(ruby_class, node->nd_next);
d7284 1
a7284 1
    int   stk_len;
@


1.333
log
@* eval.c (call_trace_func): should not call trace function while
  compilation.

* eval.c (rb_call0): also inside c-func.

* parse.y (yycompile): ditto.

* ruby.c (require_libraries): preserve source file/line for each
  require.
@
text
@d6 1
a6 1
  $Date: 2002/09/21 13:30:00 $
a4503 1
		NODE *volatile node = ruby_current_node;
a4505 1
		ruby_current_node = 0;
d4511 1
a4511 1
		ruby_current_node = node;
a4515 1
		ruby_current_node = 0;
@


1.332
log
@* eval.c (rb_thread_raise): no need to save dead thread context.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/09/17 13:52:45 $
d898 1
a898 2
	ruby_sourcefile = ruby_current_node->nd_file;
	ruby_sourceline = nd_line(ruby_current_node);
d2063 1
d4504 1
d4507 1
d4513 1
d4518 1
@


1.331
log
@move struct timeval to missing.h
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/09/17 12:07:36 $
d9040 1
a9040 1
    if (THREAD_SAVE_CONTEXT(curr_thread)) {
@


1.330
log
@* eval.c (rb_thread_die): put thread dead state.

* eval.c (rb_thread_atfork): free stack buffer at fork too.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/17 09:36:05 $
a76 10
#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
#else
#ifndef NT
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};
#endif /* NT */
#endif
@


1.329
log
@* eval.c (rb_mod_nesting): load wrapping module should appear in
  Module#nesting list. (ruby-bugs-ja:PR#328)

* eval.c (rb_thread_remove): free stack buffer on remove.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/09/13 09:36:28 $
d7762 10
d7778 1
a7778 2
    th->status = THREAD_KILLED;
    th->gid = 0;
a7780 2
    if (th->stk_ptr) free(th->stk_ptr);
    th->stk_ptr = 0;
d9196 1
a9196 2
	    th->gid = 0;
	    th->status = THREAD_KILLED;
@


1.328
log
@* eval.c (rb_eval): avoid uninitialized global/class variable
  warnings at `||='.  [ruby-dev:18278]

* parse.y (stmt, arg): ditto
@
text
@d6 1
a6 1
  $Date: 2002/09/11 15:13:10 $
d1573 3
d7772 2
@


1.327
log
@* eval.c (rb_trap_eval): preserve thread status and so on.
  [ruby-talk:40337], [ruby-core:00019]
@
text
@d6 1
a6 1
  $Date: 2002/09/11 09:58:02 $
d2894 1
a2894 1
	if ((node->nd_aid && !rb_ivar_defined(self, node->nd_aid)) ||
@


1.326
log
@* eval.c (proc_to_s): refined format.  [ruby-dev:18215]
@
text
@d6 1
a6 1
  $Date: 2002/09/10 15:44:36 $
a1469 22
rb_trap_eval(cmd, sig)
    VALUE cmd;
    int sig;
{
    int state;
    VALUE val;			/* OK */

    PUSH_TAG(PROT_NONE);
    PUSH_ITER(ITER_NOT);
    if ((state = EXEC_TAG()) == 0) {
	val = rb_eval_cmd(cmd, rb_ary_new3(1, INT2FIX(sig)), 0);
    }
    POP_ITER();
    POP_TAG();
    if (state) {
	rb_trap_immediate = 0;
	JUMP_TAG(state);
    }
    return val;
}

static VALUE
d7344 79
a7658 1
	errno = EINTR;
a9019 1
    rb_thread_ready(main_thread);
@


1.325
log
@* eval.c (rb_mod_define_method): initialize orig_func too.
  (ruby-bugs-ja:PR#330)
@
text
@d6 1
a6 1
  $Date: 2002/09/05 04:15:50 $
d6633 2
a6634 1
    long len = strlen(cname)+6+16+1; /* 6:tags 16:addr 1:nul */
d6639 1
a6639 1
	len += strlen(data->body->nd_file)+16;
d6641 1
a6641 1
	sprintf(RSTRING(str)->ptr, "#<%s:0x%p@@%s:%d>", cname, data->tag,
d6646 1
a6646 1
	sprintf(RSTRING(str)->ptr, "#<%s:0x%p>", cname, data->tag);
@


1.324
log
@* eval.c (rb_eval): overriding false constant with class/module
  definition should be error.  (PR#327)
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/29 09:08:15 $
d7139 1
@


1.323
log
@* array.c (rb_ary_become): should not free ptr if it's shared.

* eval.c (rb_alias): prohibit making an alias named "allocate" if
  klass is a metaclass.

* string.c (rb_string_value_ptr): StringValuePtr() should never
  return NULL pointer.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/28 08:05:23 $
a3301 1
	    klass = 0;
a3306 2
	    }
	    if (klass) {
a3344 1
	    module = 0;
a3349 2
	    }
	    if (module) {
@


1.322
log
@Int vs Long cleanup #3 (ruby-core:352)
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/27 08:31:05 $
d1703 1
d1719 6
d1736 2
a1737 3
    if (FL_TEST(klass, FL_SINGLETON)) {
	rb_funcall(rb_iv_get(klass, "__attached__"),
		   singleton_added, 1, ID2SYM(name));
@


1.321
log
@* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.

* class.c (rb_mod_dup): need to preserve metaclass and flags.

* object.c (rb_cstr_to_dbl): had a buffer overrun.

* marshal.c (w_class): integrate singleton check into a funciton
  to follow DRY principle.

* marshal.c (w_uclass): should check singleton method.

* object.c (rb_obj_dup): dmark and dfree functions must be match
  for T_DATA type.

* object.c (rb_obj_dup): class of the duped object must be match
  to the class of the original.

* re.c (rb_reg_quote): do not escape \t, \f, \r, \n, for they are
  not regular expression metacharacters.

* time.c (time_s_alloc): use time_free instead of free (null check,
  also serves for type mark).

* time.c (time_s_at): check dfree function too.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/08/24 06:32:40 $
d1009 1
a1009 1
	    int len = elen;
d3521 1
a3521 1
NORETURN(static void terminate_process _((int, const char*, int)));
d3526 1
a3526 1
    int mlen;
@


1.320
log
@* eval.c (call_trace_func): restore source file/line, as trace
  function installed in required library with -r option can be
  called while parsing.  (ruby-bugs:PR#372)

* eval.c (module_setup): unused variable.  [ruby-core:00358]
@
text
@d6 1
a6 1
  $Date: 2002/08/23 15:01:13 $
d8868 1
a8868 1
	curr = curr_thread->prev;
@


1.319
log
@* eval.c (method_call): check receiver is defined.

* eval.c (umethod_call): removed.
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/08/21 15:47:54 $
d2082 1
a2082 1
    NODE *node_save = ruby_last_node;
d2088 4
d2127 3
a2129 1
    ruby_last_node = node_save;
a3432 1
    NODE * cnode = ruby_current_node; /* NOT IN USE, is it OK? */
@


1.318
log
@*.c: Int vs Long cleanup
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/21 08:30:05 $
d6917 3
a6935 10
umethod_call(argc, argv, method)
    int argc;
    VALUE *argv;
    VALUE method;
{
    rb_raise(rb_eTypeError, "you cannot call unbound method; bind first");
    return Qnil;		/* not reached */
}

static VALUE
d7074 1
a7074 1
    return umethod_call(0, 0, method);
a7207 2
    rb_define_method(rb_cUnboundMethod, "call", umethod_call, -1);
    rb_define_method(rb_cUnboundMethod, "[]", umethod_call, -1);
@


1.317
log
@* eval.c (rb_thread_cleanup): should not modify the global
  variable curr_thread.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/08/19 03:41:00 $
d952 1
a952 1
    int elen;
d1031 1
a1031 1
	int i;
d2340 1
a2340 1
		    int i;
d2383 1
a2383 1
			int i;
d3073 1
a3073 1
	    int i;
d3427 1
a3427 1
    NODE * cnode = ruby_current_node;
d4767 1
a4767 1
    argc = RARRAY(args)->len;
a4790 1

d4814 1
a4814 1
	int i;
d4942 1
a4942 1
    int i;
d5448 1
a5448 1
    int i, len = strlen(feature);
d5611 1
a5611 1
	    rb_ary_push(ruby_dln_librefs, INT2NUM((long)handle));
@


1.316
log
@particular symbol for win32_exception_list.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/08/19 03:17:58 $
d8869 1
a8869 1
    rb_thread_t th;
d8871 3
a8873 2
    while (curr_thread->status == THREAD_KILLED) {
	curr_thread = curr_thread->prev;
d8876 1
a8876 1
    FOREACH_THREAD(th) {
d8887 1
a8887 1
    END_FOREACH(th);
@


1.315
log
@* eval.c (win32_get_exception_list, win32_set_exception_list): Cygwin fix.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/08/19 00:37:04 $
d7225 1
a7226 4
# if !(defined _M_IX86 || defined __i386__)
#   error unsupported processor
# endif

d7237 1
d7243 1
d7247 1
a7249 2
# else
#   error unsupported compiler
d7272 4
d7307 1
a7307 1
#ifdef _WIN32
d7561 1
a7561 1
#ifdef _WIN32
d7677 1
a7677 1
#ifdef _WIN32
@


1.314
log
@* eval.c (rb_thread_save_context, rb_thread_restore_context):
  save/restore SEH chain on MS-Windows at thread switch.
  [ruby-win32:273]

* eval.c (win32_get_exception_frame, win32_set_exception_frame):
  added.
@
text
@d6 1
a6 1
  $Date: 2002/08/15 22:58:45 $
d7225 1
a7225 1
#ifdef _WIN32
d7229 5
d7257 1
a7257 1
win32_set_exception_list()
@


1.313
log
@* eval.c (compile_error): must not clear ruby_sourcefile here.
  (ruby-bugs:PR#364).

* eval.c (rb_longjmp): set ruby_sourcefile before making
  backtrace.
@
text
@d6 1
a6 1
  $Date: 2002/08/15 11:49:39 $
d7224 47
d7300 3
d7554 3
d7670 3
@


1.312
log
@* eval.c (ruby_current_node) : added to set sourceline on demand.

* eval.c (error_pos, error_print, rb_longjmp, assign): set source
  file/line.

* eval.c (rb_eval): store current node instead of file/line, and
  preserve it at return.

* eval.c (module_setup): ditto.

* eval.c (struct thread): store node instead of file/line.

* eval.c (rb_thread_raise): ditto.

* intern.h (ruby_current_node): added.

* intern.h (ruby_set_current_source): added.

* parse.y (stmt, arg): not fix position of assignment.

* parse.y (node_assign): ditto.

* parse.y (yycompile): clear current node.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/12 07:39:07 $
a1284 1
    ruby_sourcefile = 0;
d3604 1
a3620 1
	ruby_set_current_source();
a5037 1
	ruby_current_node = 0;
@


1.311
log
@* bignum.c (rb_big_cmp): use dbl2big() for Floats, instead of
  big2dbl().

* bignum.c (Init_Bignum): rb_big_zero_p() removed.  There may be
  Bignum zero.

* eval.c (rb_call0): new argument added for original method name.
  preserve original method name in frame->orig_func.

* eval.c (is_defined): use frame->orig_func, not last_func.

* eval.c (rb_eval): ditto.

* eval.c (method_call): supply data->oid also to rb_call0().

* object.c (rb_class_allocate_instance): call rb_obj_alloc() when
  called from alias, thus invoke original "allocate".

* eval.c (remove_method): removing allocate from classes should
  cause NameError.

* hash.c (rb_hash_equal): should check default values.

* ext/socket/socket.c (s_recvfrom): update RSTRING len.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/08/11 00:36:38 $
d122 2
d540 1
a540 2
    _frame.file = ruby_sourcefile;	\
    _frame.line = ruby_sourceline;	\
d549 1
a549 2
    ruby_sourcefile = _frame.file;	\
    ruby_sourceline = _frame.line;	\
d600 1
a600 2
    _block.frame.file = ruby_sourcefile;\
    _block.frame.line = ruby_sourceline;\
d899 13
a911 1
static void call_trace_func _((char*,char*,int,VALUE,ID,VALUE));
d916 1
d965 1
d1168 2
a1169 1
	if (prot_tag && prot_tag->frame && prot_tag->frame->file) {
d1171 1
a1171 1
		    prot_tag->frame->file, prot_tag->frame->line);
d1285 1
d1304 1
a1304 1
    char *oldsrc = ruby_sourcefile;
d1306 1
d1309 1
a1309 1
    ruby_sourcefile = oldsrc;
a1783 2
	    char *file = ruby_sourcefile;\
	    int line = ruby_sourceline;\
a1790 2
	    ruby_sourcefile = file;\
	    ruby_sourceline = line;\
a1798 2
	char *file = ruby_sourcefile;\
	int line = ruby_sourceline;\
a1803 2
	ruby_sourcefile = file;\
	ruby_sourceline = line;\
d2074 1
a2074 1
call_trace_func(event, file, line, self, id, klass)
d2076 1
a2076 2
    char *file;
    int line;
d2083 1
a2083 2
    char *file_save = ruby_sourcefile;
    int line_save = ruby_sourceline;
d2096 4
a2099 3
    if (file) {
	ruby_frame->line = ruby_sourceline = line;
	ruby_frame->file = ruby_sourcefile = file;
d2124 1
a2124 2
    ruby_sourceline = line_save;
    ruby_sourcefile = file_save;
d2215 1
d2228 1
a2228 1
    ruby_sourceline = nd_line(node);
d2315 1
a2315 1
	    call_trace_func("line", node->nd_file, ruby_sourceline, self,
d2335 1
a2335 1
		    call_trace_func("line", tag->nd_file, nd_line(tag), self,
a2338 2
		ruby_sourcefile = tag->nd_file;
		ruby_sourceline = nd_line(tag);
d2378 1
a2378 1
			call_trace_func("line", tag->nd_file, nd_line(tag), self,
a2381 2
		    ruby_sourcefile = tag->nd_file;
		    ruby_sourceline = nd_line(tag);
a2489 2
		    char *file = ruby_sourcefile;
		    int line = ruby_sourceline;
d2495 2
a2496 2
		    ruby_sourcefile = file;
		    ruby_sourceline = line;
d2575 1
a2591 1
		ruby_sourceline = nd_line(node);
d2593 1
d2745 1
d2759 1
d2765 1
d2796 1
d3011 1
d3014 2
a3015 1
		return rb_funcall(klass, node->nd_mid, 0, 0);
a3016 1
	    result = rb_const_get(klass, node->nd_mid);
d3399 1
a3399 1
    case NODE_NEWLINE:
d3403 1
a3403 1
	    call_trace_func("line", ruby_sourcefile, ruby_sourceline, self,
d3415 1
d3428 1
a3428 2
    char *file = ruby_sourcefile;
    int line = ruby_sourceline;
d3457 1
a3457 1
	    call_trace_func("class", file, line, ruby_class,
d3471 1
a3471 1
	call_trace_func("end", file, line, 0,
d3621 1
d3630 1
a3630 1
	call_trace_func("raise", ruby_sourcefile, ruby_sourceline,
d3756 1
a3756 2
    char *const file = ruby_sourcefile;
    int line = ruby_sourceline;
d3881 1
a3881 2
    ruby_sourcefile = file;
    ruby_sourceline = line;
d3970 1
d4023 2
d4033 2
d4293 1
a4293 2
    char *file = ruby_sourcefile;
    int   line = ruby_sourceline;
d4345 1
a4345 2
    ruby_sourcefile = file;
    ruby_sourceline = line;
a4528 6
		char *file = ruby_frame->prev->file;
		int line = ruby_frame->prev->line;
		if (!file) {
		    file = ruby_sourcefile;
		    line = ruby_sourceline;
		}
d4530 1
a4530 1
		call_trace_func("c-call", 0, 0, recv, id, klass);
d4536 1
a4536 1
		call_trace_func("c-return", 0, 0, recv, id, klass);
a4645 2
				ruby_sourcefile = opt->nd_file;
				ruby_sourceline = nd_line(opt);
d4663 1
a4663 2
		    call_trace_func("call", b2->nd_file, nd_line(b2),
				    recv, id, klass);
d4665 1
d4677 1
a4677 7
		char *file = ruby_frame->prev->file;
		int line = ruby_frame->prev->line;
		if (!file) {
		    file = ruby_sourcefile;
		    line = ruby_sourceline;
		}
		call_trace_func("return", file, line, recv, id, klass);
d4881 1
d4885 1
d4908 1
a4908 1
    while (frame && frame->file) {
d4911 1
a4911 1
		     frame->file, frame->line,
d4915 1
a4915 1
	    snprintf(buf, BUFSIZ, "%s:%d", frame->file, frame->line);
d4996 1
a4996 2
    char *filesave = ruby_sourcefile;
    int linesave = ruby_sourceline;
d5038 2
d5100 2
a5101 2
    ruby_sourcefile = filesave;
    ruby_sourceline = linesave;
d7275 1
a7275 2
    char *file;
    int   line;
d7473 1
a7473 2
static char *th_raise_file;
static int   th_raise_line;
d7529 1
a7529 2
    th->file = ruby_sourcefile;
    th->line = ruby_sourceline;
d7551 1
a7551 2
	ruby_sourcefile = th_raise_file;
	ruby_sourceline = th_raise_line;
d7617 1
a7617 2
    ruby_sourcefile = th->file;
    ruby_sourceline = th->line;
d7688 1
a7688 2
    th_raise_file = ruby_sourcefile;
    th_raise_line = ruby_sourceline;
d7952 1
a7952 2
	curr_thread->file = ruby_sourcefile;
	curr_thread->line = ruby_sourceline;
d7957 1
a7957 1
		    th->file, th->line);
d8933 1
a8933 2
    th_raise_file = ruby_sourcefile;
    th_raise_line = ruby_sourceline;
@


1.310
log
@* eval.c (rb_eval): set line number from all nodes.

* eval.c (proc_to_s): show source file/line if available.

* marshal.c (r_object): register TYPE_BIGNUM regardless real type.
@
text
@d6 1
a6 1
  $Date: 2002/08/03 12:27:33 $
d318 4
d336 10
a470 4
static ID init, alloc, eqq, each, aref, aset, match, missing;
static ID added, singleton_added;
static ID __id__, __send__;

d1337 1
d1429 1
d1636 1
a1636 4
	rb_raise(rb_eSecurityError, "Insecure: can't undef");
	if (id == __id__ || id == __send__ || id == init) {
	    rb_name_error(id, "undefining `%s' prohibited", rb_id2name(id));
	}
d1639 1
a1639 1
    if (id == __id__ || id == __send__ || id == init) {
d1856 1
a1856 1
	if (ruby_frame->last_func == 0) return 0;
d1859 1
a1859 1
				  ruby_frame->last_func, 0)) {
d2771 1
a2771 1
		if (ruby_frame->last_func) {
d2774 1
a2774 1
				  rb_id2name(ruby_frame->last_func));
d2792 1
a2792 1
			     ruby_frame->self, ruby_frame->last_func,
d4470 1
a4470 1
rb_call0(klass, recv, id, argc, argv, body, nosuper)
d4473 1
d4503 1
d4761 1
a4761 1
    return rb_call0(klass, recv, id, argc, argv, body, noex & NOEX_UNDEF);
d6928 1
a6928 1
	result = rb_call0(data->klass,data->recv,data->id,argc,argv,data->body,0);
@


1.309
log
@* eval.c (rb_eval): set constant in cbase scope.

* eval.c (assign): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/07/31 05:18:43 $
d2212 1
a2297 1
	ruby_sourceline = nd_line(node);
a2399 1
	    ruby_sourceline = nd_line(node);
a2431 1
	    ruby_sourceline = nd_line(node);
a3075 1
	ruby_sourceline = nd_line(node);
d6622 1
d6626 10
a6635 2
    str = rb_str_new(0, strlen(cname)+6+16+1); /* 6:tags 16:addr 1:nul */
    sprintf(RSTRING(str)->ptr, "#<%s:0x%p>", cname, data->tag);
@


1.308
log
@* eval.c (rb_undef): undef should be done for klass, not ruby_class.
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/07/30 00:13:56 $
d2935 1
a2935 1
	rb_const_set(ruby_class, node->nd_vid, result);
d3306 1
a3306 1
		rb_const_set(ruby_class, node->nd_cname, klass);
d3342 1
a3342 1
		rb_const_set(ruby_class, node->nd_cname, module);
d3986 1
a3986 1
	rb_const_set(ruby_class, lhs->nd_vid, val);
@


1.307
log
@* eval.c (rb_thread_join_m): add parameter type declaration.
@
text
@d6 1
a6 1
  $Date: 2002/07/29 23:34:43 $
d1620 1
a1620 1
    if (ruby_class == rb_cObject) {
d1633 1
a1633 1
    body = search_method(ruby_class, id, &origin);
@


1.306
log
@* eval.c (localjump_error): add parameter type declaration.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/07/26 14:12:26 $
d8205 1
@


1.305
log
@* eval.c (rb_eval): no need to convert to string twice.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/07/26 06:12:38 $
d1351 1
@


1.304
log
@* random.c: replace with Mersenne Twister RNG.

* eval.c (jump_tag_but_local_jump): preserve retval in
  LocalJumpError exceptions.

* parse.y (command): no more check for "super outside of method".

* eval.c (rb_mod_define_method): should set last_class and
  last_func in the block->frame.

* eval.c (error_handle): should handle TAG_THROW as well.

* parse.y (yylex): new decimal notation '0d4567'.

* parse.y (yylex): new octal notation '0o777'.

* parse.y (string_content): every string_content node should
  return string only.  use NODE_EVSTR to coercing.

* eval.c (rb_eval): NODE_EVSTR support.

* re.c (rb_reg_quote): avoid unnecessary string allocation.

* string.c (get_pat): quote metachracters before compiling a
  string into a regex.

* string.c (rb_str_split_m): special treatment of strings of size
  1, but AWK emulation.  now uses get_pat().

* string.c (rb_str_match_m): quote metacharacters.

* string.c (rb_str_match2): ditto.

* ext/socket/socket.c (sock_addrinfo): make all 3 versions of
  getaddrinfo happy.  [ruby-core:00184]
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/06/24 07:20:42 $
d3077 1
d3097 1
a3097 2
			ruby_sourceline = nd_line(list->nd_head);
			str2 = rb_obj_as_string(rb_eval(self, list->nd_head));
@


1.303
log
@* eval.c (rb_eval): NODE_EVSTR is no longer used.

* eval.c (eval): not enforce to make assigned variables dynamic.

* parse.y (string): split rules to strings/xstring/regexp to allow
  arbitrary statements inside string interpolation.

* parse.y (here_document): splitted into three phases.

* parse.y (literall_append, literal_concat): added.
  append/concatinate string literals.

* sample/test.rb (valid_syntax): adjust line number for BEGIN.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/06/13 03:55:44 $
d1144 11
d1368 4
d1376 1
a1376 1
	localjump_error("unexpected return", Qnil);
d1379 1
a1379 1
	localjump_error("unexpected next", Qnil);
d1382 1
a1382 1
	localjump_error("unexpected break", Qnil);
a1429 1

d3076 4
d7123 6
@


1.302
log
@* eval.c (svalue_to_avalue): v may be Qundef.  This fix was
  suggested by Guy Decoux.

* hash.c (rb_hash_s_create): use rb_hash_aset() instead of calling
  st_insert() directly, to dup&freeze string keys.

* parse.y (yylex): proper error message for "@@@@0".

* parse.y (yylex): paren to parse_string() must be zero for
  unparenthesized strings.

* parse.y (str_extend): broken string when unterminated "#{".

* enum.c (enum_sort_by): had a bug in 1 element enumeration.
@
text
@d6 1
a6 1
  $Date: 2002/06/11 07:01:13 $
a3070 1
	    if (!ruby_dyna_vars) rb_dvar_push(0, 0);
a3076 15
		      case NODE_EVSTR:
			result = ruby_errinfo;
			ruby_errinfo = Qnil;
			ruby_sourceline = nd_line(node);
			ruby_in_eval++;
			list->nd_head = compile(list->nd_head->nd_lit,
						ruby_sourcefile,
						ruby_sourceline);
			ruby_eval_tree = 0;
			ruby_in_eval--;
			if (ruby_nerrs > 0) {
			    compile_error("string expansion");
			}
			if (!NIL_P(result)) ruby_errinfo = result;
			/* fall through */
d3078 1
a5012 1
	if (!ruby_dyna_vars) rb_dvar_push(0, 0);
@


1.301
log
@* eval.c (rb_eval): ruby_frame->last_func may be null, if it's
  called outside of a method.

* parse.y (arg): use INT2NUM, not INT2FIX for tUMINUS.

* parse.y (arg): unnecessary negative tPOW treatment.

* parse.y (tokadd_escape): wrong backslash escapement.

* parse.y (stmt,arg): too much void value check.

* parse.y (stmt,arg): need to check void value on rules which does
  not use node_assign().

* ext/socket/socket.c (ipaddr): need not to taint hostnames.

* range.c (range_include): should be based on "<=>", whereas
  member? still is based on "each".

* range.c (range_min,range_max): redefine methods based on "<=>".
@
text
@d6 1
a6 1
  $Date: 2002/06/04 07:34:14 $
d2103 1
@


1.300
log
@* string.c (rb_str_aset): should raise error if an indexing string
  is not found in the receiver.

* sprintf.c (rb_f_sprintf): "%d" should convert objects into
  integers using Integer().

* lib/tempfile.rb (Tempfile::size): added.
@
text
@d6 1
a6 1
  $Date: 2002/05/30 06:12:27 $
d2748 8
a2755 3
		rb_name_error(ruby_frame->last_func,
			      "superclass method `%s' disabled",
			      rb_id2name(ruby_frame->last_func));
@


1.299
log
@* range.c (range_step): iteration done using "+" if elements are
  Numeric.  Otherwise using "succ".

* range.c (range_each): iteration done using "succ".  If the
  elements does not respond to "succ", raise TypeError.  As a
  result, all Enumerable methods, e.g. collect, require elements
  to respond to "succ'.

* range.c (range_member): comparison done using "each", if
  elements are non-Numeric or no-"succ" objects.  Otherwise
  compare using "<=>".

* range.c (Init_Range): remove "size" and "length".
@
text
@d6 1
a6 1
  $Date: 2002/05/29 05:20:32 $
a842 1
#define scope_node super.klass
a2785 1
	    ruby_scope->scope_node = (VALUE)node;
d3065 1
a3076 1
			rb_dvar_push(0, 0);
a3079 8
			if (ruby_scope->local_tbl) {
			    NODE *body = (NODE *)ruby_scope->scope_node;
			    if (body && body->nd_tbl != ruby_scope->local_tbl) {
				if (body->nd_tbl) free(body->nd_tbl);
				ruby_scope->local_vars[-1] =
				    (VALUE)(body->nd_tbl = ruby_scope->local_tbl);
			    }
			}
a3416 1
    ruby_scope->scope_node = (VALUE)node;
a4555 1
	    ruby_scope->scope_node = (VALUE)body;
d5022 1
@


1.298
log
@* parse.y: yyparse #defines moved from intern.h

* ruby.c (proc_options): access prefixed "ruby_yydebug".

* applied modifies to pacify some of gcc -Wall warnings.

* parse.y (arg): no more ugly hack for "**", so that "-2**2" to be
  parsed as "(-2)**2", whereas "- 2**2" or "-(2)**2" to be parsed
  as "-(2**2)".

* parse.y (yylex): '-2' to be literal fixnum. [new]

* time.c (time_succ): new method for Range support.

* time.c (time_arg): nil test against v[6] (usec).
@
text
@d5 2
a6 2
  $Author: michal $
  $Date: 2002/05/28 18:11:07 $
d3854 1
a3854 1
	    while (vars && vars->id != 0) {
@


1.297
log
@	* array.c: fixed format string for 'long' args (%d -> %ld).

	* class.c: ditto.

	* eval.c: ditto.

	* numeric.c: ditto.

	* pack.c: ditto.

	* parse.y: ditto.

	* range.c: ditto.

	* string.c: ditto.

	* util.c: ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/05/28 03:20:04 $
d3078 1
d6631 1
a6631 1
    sprintf(RSTRING(str)->ptr, "#<%s:0x%lx>", cname, data->tag);
d6646 22
d7175 1
@


1.296
log
@* eval.c (scope_node): trick to keep the node has a scope.

* eval.c (rb_eval): NODE_EVSTR: write back local_tbl to the node.

* eval.c (rb_eval): NODE_SCOPE: hold the scope node in ruby_scope.

* eval.c (module_setup): ditto.

* eval.c (rb_call0): ditto.

* node.h (NEW_DASGN, NEW_DASGN_CURR): remove surplus semicolons.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/21 05:39:18 $
d3781 1
a3781 1
		    rb_raise(rb_eArgError, "wrong number of arguments (%d for 0)",
d3787 1
a3787 1
		    rb_raise(rb_eArgError, "wrong number of arguments (%d for 0)",
d3909 1
a3909 1
    int i = 0, len;
d3948 1
a3948 1
    rb_raise(rb_eArgError, "wrong number of arguments (%d for %d)", len, i);
@


1.295
log
@* object.c (Init_Object): should do exact match for Module#==.

* compar.c (cmp_eq): returns 'false' if <=> returns 'nil'.

* compar.c (cmp_gt,cmp_ge,cmp_lt,cmp_le,cmp_between): ditto.

* pack.c (pack_pack): should propagate taintedness.

* pack.c (pack_unpack): ditto.

* eval.c (rb_thread_schedule): need to preserve errno before
  calling rb_trap_exec().

* regex.c (calculate_must_string): a bug in charset/charset_not
  parsing.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/05/16 05:53:14 $
d843 1
d2787 1
d3081 8
d3426 1
d4566 1
@


1.294
log
@* eval.c (rb_thread_select): cleanup conditional compilation.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/14 06:22:25 $
d7816 2
d7819 4
a7822 1
	    if (errno == EINTR) goto again;
@


1.293
log
@* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* numeric.c (flo_to_s): default format precision to be "%.16g".

* util.c (ruby_strtod): use own strtod(3) implementation to avoid
  locale hell.  Due to this change "0xff".to_f no longer returns 255.0

* eval.c (avalue_to_yvalue): new function to distinguish yvalue
  (no-arg == Qundef) from svalue (no-arg == Qnil).

* eval.c (rb_yield_0): use avalue_to_yvalue().

* eval.c (assign): warn if val == Qundef where it means rhs is
  void (e.g. yield without value or call without argument).

* parse.y (value_expr): need not to warn for WHILE and UNTIL,
  since they can have return value (via valued break).
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/05/09 17:01:38 $
d8061 3
d8074 1
d8083 1
a8090 18
#else
	for (;;) {
	    TRAP_BEG;
	    n = select(max, read, write, except, timeout);
	    TRAP_END;
	    if (n < 0) {
		switch (errno) {
		  case EINTR:
#ifdef ERESTART
		  case ERESTART:
#endif
		    continue;
		}
	    }
	    return n;
	}
#endif

@


1.292
log
@* eval.c (rb_thread_join): added an argument to limit time to wait
  the thread.

* eval.c (rb_thread_join_m): new. and added optional argument.
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/05/07 06:28:06 $
d220 15
d2130 16
d2149 2
a2150 1
    if (NIL_P(v)) return rb_ary_new2(0);
d2546 1
a2546 1
	    result = avalue_to_svalue(rb_eval(self, node->nd_stts));
d2549 1
a2549 1
	    result = Qnil;
d3780 3
d3784 2
a3785 6
		if (nd_type(block->var) == NODE_MASGN) {
		    massign(self, block->var, val, pcall);
		}
		else {
		    if (pcall) val = avalue_to_svalue(val);
		    assign(self, block->var, val, pcall);
d3787 1
d3794 1
a3794 1
	val = avalue_to_svalue(val);
d3884 1
a3884 1
	rb_yield_0(Qnil, 0, 0, 0);
d3947 4
a3950 1
    if (val == Qundef) val = Qnil;
d5661 1
d6509 1
a6509 1
	args = avalue_to_svalue(args);
@


1.291
log
@* eval.c (rb_yield_0): The destination of the goto jump was wrong.
@
text
@d6 1
a6 1
  $Date: 2002/05/07 00:17:48 $
d8091 6
a8096 3
static VALUE
rb_thread_join(thread)
    VALUE thread;
a8097 1
    rb_thread_t th = rb_thread_check(thread);
d8108 1
d8112 2
d8116 1
d8130 16
d8666 1
a8666 1
    rb_thread_join(thread);
d9160 1
a9160 1
    rb_define_method(rb_cThread, "join", rb_thread_join, 0);
@


1.290
log
@* eval.c (superclass): undesirable "unexpected return" when the superclass is not a Class.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/01 09:41:49 $
d3800 1
a3801 1
    POP_ITER();
@


1.289
log
@* numeric.c (num_step): better iteration condition for float
  values;  suggested by Masahiro TANAKA <masa@@ir.isas.ac.jp>.

* range.c (range_step): step (for Range#step method) <= 0 makes no
  sence, thus ArgError will be raised.

* range.c (range_each): Range#each method is special case for
  Range#step(1)

* file.c (rb_find_file): load must be done from an abolute path if
  $SAFE >= 4.

* enum.c (enum_partition): new method. [new]

* re.c (rb_reg_s_quote): quote whitespaces for /x cases.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/04/26 00:38:44 $
a1447 1
      superclass_error:
d1460 4
a1463 1
    if (TYPE(val) != T_CLASS) goto superclass_error;
@


1.288
log
@* eval.c (rb_proc_new): make Proc from C function. [new]

* intern.h (rb_proc_new): prototype.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/04/25 13:55:58 $
d230 1
a230 1
    if (rb_safe_level() >= 4 && (klass == rb_cObject || !OBJ_TAINTED(klass))) {
d313 1
a313 1
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(klass)) {
d1591 1
a1591 1
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(klass)) {
d3169 1
a3169 1
	    if (rb_safe_level() >= 4 && !OBJ_TAINTED(recv)) {
d3182 1
a3182 1
		if (rb_safe_level() >= 4) {
d3251 1
a3251 1
		if (rb_safe_level() >= 4) {
d3291 1
a3291 1
		if (rb_safe_level() >= 4) {
d3318 1
a3318 1
	    if (rb_safe_level() >= 4 && !OBJ_TAINTED(result))
d5606 1
a5606 1
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(self)) {
d6318 1
a6318 1
	switch (rb_safe_level()) {
d6326 1
a6326 1
	    if (rb_safe_level() > 4) {
d6624 2
a6625 2
    if (rb_safe_level() >= 1 && OBJ_TAINTED(block)) {
	if (rb_safe_level() > proc_get_safe_level(block)) {
d8319 1
a8319 1
	return INT2NUM(rb_safe_level());
d8862 1
a8862 1
    if (rb_safe_level() >= 4 && th != curr_thread) {
d8887 1
a8887 1
    if (rb_safe_level() >= 4 && th != curr_thread) {
@


1.287
log
@* various files: macro fix-up by Michal Rokos.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/04/24 05:58:34 $
d6999 8
@


1.286
log
@* eval.c (proc_to_proc): return self. [new]

* eval.c (block_pass): no need to convert if block is Proc.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/04/24 04:54:13 $
d119 1
a119 1
#define SCOPE_SET(f)  scope_vmode=(f)
@


1.285
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d6 1
a6 1
  $Date: 2002/04/19 04:14:07 $
d6588 7
d6615 7
a6621 4
    b = rb_check_convert_type(block, T_DATA, "Proc", "to_proc");
    if (!rb_obj_is_proc(b)) {
	rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc)",
		 rb_class2name(CLASS_OF(block)));
a6622 1
    block = b;
d7093 1
@


1.284
log
@* eval.c (rb_thread_cleanup): current thread may be THREAD_STOPPED,
  for example when terminated from signal handler.

* regex.c (re_compile_pattern): remove /p support.

* regex.h: ditto.

* parse.y (parse_regx): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/04/18 08:46:17 $
a107 1
static VALUE method_proc _((VALUE));
d119 1
a119 1
#define SCOPE_SET(f)  do {scope_vmode=(f);} while(0)
d442 1
a442 1
static ID init, alloc, eqq, each, aref, aset, match, to_ary, missing;
d509 1
a509 1
#define PUSH_FRAME() {			\
d526 1
a526 1
}
d567 1
a567 1
#define PUSH_BLOCK(v,b) {		\
d592 1
a592 1
}
d595 1
a595 1
#define PUSH_VARS() { \
d606 1
a606 1
}
d749 1
a749 1
#define PUSH_ITER(i) {			\
d757 1
a757 1
}
d771 1
a771 1
#define PUSH_TAG(ptag) {		\
d798 1
a798 1
}
d802 1
a802 1
}
d817 1
a817 1
#define PUSH_CLASS() {			\
d821 1
a821 1
}
d828 1
a828 1
#define PUSH_SCOPE() {			\
d860 1
a860 1
}
d1758 1
a1758 1
#define BEGIN_CALLARGS {\
d1768 1
a1768 1
}
d2154 4
a2157 1
#define RETURN(v) { result = (v); goto finish; }
d4934 1
a4934 1
    struct BLOCK *data;
a5476 1
    volatile VALUE load;
a6022 1
    to_ary = rb_intern("to_ary");
d6593 1
d6608 2
a6609 4
    if (rb_obj_is_kind_of(block, rb_cMethod)) {
	block = method_proc(block);
    }
    else if (!rb_obj_is_proc(block)) {
d6613 1
d8700 4
a8703 2
	    th->status = THREAD_TO_KILL;
	    RDATA(th->thread)->dfree = NULL;
@


1.283
log
@* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* io.c: complete off_t handling; missing argument for
  fptr_finalize(); polished rb_scan_args call.

* dir.c: wrap multi-statment macro by do { } while (0)

* eval.c, numeric,c, sprintf.c, util.c: ditto.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/04/16 00:02:49 $
d8696 1
a8696 1
	if (th != curr_thread && th->status != THREAD_KILLED) {
@


1.282
log
@* eval.c (assign): convert mrhs to mvalue.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/04/15 07:48:45 $
d521 1
a521 1
    ruby_frame = &_frame;		\
d526 2
a527 1
    ruby_frame = _frame.prev; }
d585 1
a585 1
    ruby_block = &_block;
d599 1
a599 1
    ruby_dyna_vars = 0;
d754 1
a754 1
    ruby_iter = &_iter;			\
d781 1
a781 1
    prot_tag = &_tag;
d789 1
a789 1
#define JUMP_TAG(st) {			\
d793 1
a793 1
}
d819 1
a819 1
    VALUE _class = ruby_class;		\
d821 2
a822 1
#define POP_CLASS() ruby_class = _class; }
d839 1
a839 1
    scope_vmode = SCOPE_PUBLIC;
d868 1
a868 1
static VALUE rb_call _((VALUE,VALUE,ID,int,VALUE*,int));
d1155 1
a1155 1
    PUSH_TAG(PROT_NONE)
d1719 1
a1719 1
#define SETUP_ARGS(anode) {\
d1757 1
a1757 1
}
d1764 1
a1764 1
    PUSH_ITER(ITER_NOT);
d4656 1
a4656 1
    VALUE *argv;		/* OK */
d4785 1
a4785 1
    VALUE *argv;
d4795 1
a4795 1
    VALUE *argv;
d4803 1
a4803 1
    VALUE *argv;
d8377 1
a8377 1
} while(0)
@


1.281
log
@* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* error.c (exc_initialize): should clear backtrace information.

* io.c (rb_io_fptr_cleanup): should close IO created by IO.new(fd).

* rubyio.h: remove FMODE_FDOPEN
@
text
@d6 1
a6 1
  $Date: 2002/04/11 10:02:59 $
d3949 1
a3949 1
	massign(self, lhs, val, pcall);
@


1.280
log
@* eval.c (assign): ruby_verbose should be surrounded by RTEST().

* object.c (rb_str2cstr): ditto.

* parse.y (void_expr): ditto.

* parse.y (void_stmts): ditto.

* variable.c (rb_ivar_get): ditto.

* variable.c (rb_cvar_set): ditto.

* variable.c (rb_cvar_get): ditto.

* dir.c (glob_helper): should have proceed link when link->path
  was non existing symbolic link.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/04/08 07:09:45 $
d5052 1
a5052 1
		    err = RARRAY(errat)->ptr[0];
a5058 1
		errat = Qnil;
@


1.279
log
@* eval.c (error_handle): default to 1 unless status is set.

* eval.c (ruby_options): guard error_handle() with PROT_NONE.

* eval.c (ruby_stop): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/26 06:18:49 $
d3938 1
a3938 1
	if (ruby_verbose && FL_TEST(ruby_cbase, FL_SINGLETON)) {
@


1.278
log
@* parse.y (primary): while/until statement modifiers to "begin"
  statement now work as "do .. while" even when begin statement
  has "rescue" or "ensure" [new].

* parse.y (bodystmt): rescue/ensure is allowed at every bodies,
  i.e. method bodies, begin bodies, class bodies[new], and module
  bodies[new].

* ext/socket/socket.c (sock_addrinfo): should specify ai_socktype
  for getaddrinfo hints.

* eval.c (rb_f_abort): embed aborting message into exception
  object [new].

* eval.c (terminate_process): utility function for exit and abort.
@
text
@d6 1
a6 1
  $Date: 2002/03/25 06:18:04 $
d1132 1
a1132 1
	    ex = NUM2INT(st);
a1156 1
    POP_TAG();
d1162 1
a1196 1
    POP_TAG();
d1201 1
@


1.277
log
@* ext/socket/socket.c (bsock_do_not_rev_lookup_set): should not be
  allowed when $SAFE > 3.

* eval.c (rb_thread_ready): THREAD_TO_KILL threads should not turn
  into THREAD_RUNNABLE on wakeup.

* eval.c (rb_thread_list): THREAD_TO_KILL threads should be in the
  list.

* eval.c (thgroup_list): ditto; by moving gid clearance from
  rb_thread_cleanup().

* dir.c (fnmatch): "*/bar" (with FNM_PATHNAME flag) does not
  match "foo/bar".

* io.c (read_all): files on /proc filesystem with zero stat size,
  may have contents.

* ext/socket/socket.c (tcp_s_gethostbyname): refactored.

* ext/socket/socket.c (sock_s_gethostbyname): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/22 07:26:35 $
a1093 2
static int exit_status;

d1131 2
a1132 1
	    ex = exit_status;
d3455 13
d3473 1
a3473 6
	VALUE exit;

	exit_status = status;
	exit = rb_exc_new2(rb_eSystemExit, "exit");
	rb_iv_set(exit, "status", INT2NUM(status));
	rb_exc_raise(exit);
a3498 9
static void
rb_abort()
{
    if (!NIL_P(ruby_errinfo)) {
	error_print();
    }
    rb_exit(1);
}

d3506 4
a3509 1
	rb_abort();
d3514 2
a3515 1
	rb_scan_args(argc, argv, "01", &mesg);
d3517 1
a3517 1
	rb_exit(1);
@


1.276
log
@* the VMS support patch submitted by Akiyoshi, Masamichi
  <Masamichi.Akiyoshi@@jp.compaq.com> is merged.

* eval.c (exec_under): changing ruby_class is OK, but should not
  alter cbase.

* eval.c (yield_under_i): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/20 09:43:15 $
d7530 3
a7532 1
    th->status = THREAD_RUNNABLE;
d7543 1
a7848 1
	next->gid = 0;
d8126 1
a8941 1
#if 1				/* enable on 1.7 */
d8947 1
a8954 1
#endif
@


1.275
log
@* eval.c (is_defined): should check receiver only once.

* eval.c (is_defined): should handle NODE_NEWLINE.

* file.c (rb_file_s_expand_path): memory leak fixed.
@
text
@d6 1
a6 1
  $Date: 2002/03/19 09:03:07 $
d90 4
d3117 1
a3117 1
		    rb_warning("discarding old %s", rb_id2name(node->nd_mid));
d5113 1
a5113 1
exec_under(func, under, args)
d5115 1
a5115 1
    VALUE under;
d5130 5
a5134 2
    if (ruby_cbase != under) {
	ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,under,0,ruby_frame->cbase);
a5135 1
    PUSH_CREF(under);
d5144 1
a5144 1
    POP_CREF();
d5179 1
a5179 1
    return exec_under(eval_under_i, under, args);
a5185 26
    if (ruby_block->flags & BLOCK_DYNAMIC) {
	struct BLOCK * volatile old_block = ruby_block;
	struct BLOCK block;

	/* cbase should be pointed from volatile local variable */
	/* to be protected from GC. 				*/
	VALUE result;
	int state;

	/* copy the block to avoid modifying global data. */
	block = *ruby_block;
	block.frame.cbase = ruby_frame->cbase;
	ruby_block = &block;

	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    result = rb_yield_0(self, self, ruby_class, 0);
	}
	POP_TAG();
	ruby_block = old_block;
	if (state) JUMP_TAG(state);

	return result;
    }
    /* static block, no need to restore */
    ruby_block->frame.cbase = ruby_frame->cbase;
d5194 1
a5194 1
    return exec_under(yield_under_i, under, self);
@


1.274
log
@* re.c (rb_reg_search): should clear last_match if pos is out of
  string range.

* string.c (rb_str_index_m): ditto.

* string.c (rb_str_rindex): ditto.

* class.c (rb_define_class): should handle autoload.

* class.c (rb_define_module): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/18 08:21:40 $
d1806 1
a1827 1
	if (!is_defined(self, node->nd_recv, buf)) return 0;
d1962 4
@


1.273
log
@* eval.c (rb_f_abort): should not bypass cleanup.

* ext/stringio/stringio.c (check_modifiable): void function.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/14 06:23:43 $
d701 1
a701 1
static void
d709 1
a709 1
static void
@


1.272
log
@* re.c (rb_reg_match): should clear $~ if operand is nil.

* re.c (rb_reg_match2): ditto.

* configure: merge Jonathan Baker's large file support patch
  [ruby-talk:35316], with read_all patch in [ruby-talk:35470].

* eval.c (rb_f_abort): optional message argument that be printed
  on termination. [new]
@
text
@d6 1
a6 1
  $Date: 2002/03/11 08:02:02 $
d3507 1
a3507 1
	exit(1);
@


1.271
log
@* marshal.c (w_object): module inclusion using extend() should
  also be detected.

* eval.c (rb_eval_cmd): cbase should not be NULL; it should be
  either ruby_wrapper or Object.

* enum.c (enum_each_with_index): should return self.

* process.c (proc_setpgrp): should return value for non-void function.

* process.c (proc_getpgid): should raise exception if getpgid() return -1.

* string.c (rb_str_ljust): should return a duplicated string.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/03/08 07:03:03 $
d3494 3
a3496 1
rb_f_abort()
d3499 10
a3508 1
    rb_abort();
d6070 1
a6070 1
    rb_define_global_function("abort", rb_f_abort, 0);
@


1.270
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.

* class.c (rb_mod_clone): should not call rb_obj_clone(), since
  Module does not provide "allocate".

* class.c (rb_singleton_class): should crate new singleton class
  if obj is a class or module and attached object is different,
  which means metaclass of singleton class is sought.

* time.c (time_s_alloc): now follows allocation framework.

* eval.c (rb_eval): should initialize outer class variables from
  methods in singleton class definitions.

* eval.c (assign): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/07 11:19:37 $
d1385 2
a1386 1
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,ruby_wrapper,0,0);
@


1.269
log
@* gc.c (rb_source_filename): added. holds unique strings for file
  names with GC space.

* gc.c (rb_gc_mark): mark source file name.

* gc.c (gc_sweep): ditto.

* gc.c (Init_GC): initialize source file name table.

* intern.h (rb_source_filename): added.

* eval.c (rb_eval_string): use rb_source_filename().

* parse.y (yycompile): ditto.

* ruby.c (proc_options): ditto.

* ruby.c (load_file): ditto.

* ruby.c (ruby_script): ditto.

* ruby.c (ruby_prog_init): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/28 06:53:29 $
d1496 1
a1496 1
	struct RClass *klass = RCLASS(cbase->nd_clss);
d1499 1
a1499 1
	if (klass->iv_tbl && st_lookup(klass->iv_tbl, id, &result)) {
d1508 14
d1918 1
a1918 13
	if (NIL_P(ruby_cbase)) {
	    if (rb_cvar_defined(CLASS_OF(self), node->nd_vid)) {
		return "class variable";
	    }
	    break;
	}
	if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    if (rb_cvar_defined(ruby_cbase, node->nd_vid)) {
		return "class variable";
	    }
	    break;
	}
	if (rb_cvar_defined(rb_iv_get(ruby_cbase, "__attached__"), node->nd_vid)) {
d2876 1
a2876 4
	if (ruby_verbose && FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    rb_warn("declaring singleton class variable");
	}
	rb_cvar_set(ruby_cbase, node->nd_vid, result, Qtrue);
d2881 1
a2881 1
	rb_cvar_set(ruby_cbase, node->nd_vid, result, Qfalse);
d2908 1
a2908 9
	if (NIL_P(ruby_cbase)) {
	    result = rb_cvar_get(CLASS_OF(self), node->nd_vid);
	    break;
	}
	if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    result = rb_cvar_get(ruby_cbase, node->nd_vid);
	    break;
	}
	result = rb_cvar_get(rb_iv_get(ruby_cbase, "__attached__"), node->nd_vid);
d3158 1
a3158 1
		rb_raise(rb_eSecurityError, "Insecure; can't define singleton method");
d3302 7
a3308 18
	    if (result == Qtrue) {
		klass = rb_cTrueClass;
	    }
	    else if (result == Qfalse) {
		klass = rb_cTrueClass;
	    }
	    else if (result == Qnil) {
		klass = rb_cNilClass;
	    }
	    else {
		if (rb_special_const_p(result)) {
		    rb_raise(rb_eTypeError, "no virtual class for %s",
			     rb_class2name(CLASS_OF(result)));
		}
		if (rb_safe_level() >= 4 && !OBJ_TAINTED(result))
		    rb_raise(rb_eSecurityError, "Insecure: can't extend object");
		klass = rb_singleton_class(result);
	    }
d3919 1
a3919 1
	rb_cvar_set(ruby_cbase, lhs->nd_vid, val, Qtrue);
d3923 1
a3923 1
	rb_cvar_set(ruby_cbase, lhs->nd_vid, val, Qfalse);
d5831 2
a5832 2
    for (i=0; i<argc; i++) {
	rb_funcall(argv[i], rb_intern("extend_object"), 1, obj);
@


1.268
log
@* eval.c (rb_mod_include): load modules in argument order.

* st.c (st_init_table_with_size): num_bins should be prime numbers
  (no decrement).

* st.c (rehash): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/02/27 04:52:15 $
d1251 1
a1251 1
    ruby_sourcefile = "(eval)";
@


1.267
log
@* ext/dbm/dbm.c (fdbm_select): 1.7 behavior.

* ext/gdbm/gdbm.c (fgdbm_select): ditto.

* ext/sdbm/sdbm.c (fsdbm_select): ditto.

* ext/dbm/dbm.c (fdbm_delete): adopt Hash#delete behavior.

* ext/sdbm/sdbm.c (fsdbm_delete): ditto.

* ext/gdbm/gdbm.c: need not to dup key to the block.

* ext/sdbm/sdbm.c : replace RuntimeError with SDBMError.

* eval.c (rb_f_missing): NoMethod error messages for true, false,
  nil must respond visibility like for other objects.
@
text
@d6 1
a6 1
  $Date: 2002/02/26 06:48:58 $
d5794 2
a5795 1
    int i;
d5797 3
a5799 4
    for (i=0; i<argc; i++) {
	Check_Type(argv[i], T_MODULE);
	rb_funcall(argv[i], rb_intern("append_features"), 1, module);
	rb_funcall(argv[i], rb_intern("included"), 1, module);
@


1.266
log
@* eval.c (rb_eval): call trace_func for if/while conditions.

* marshal.c (r_object): separate r_regist from proc calling.
@
text
@d6 1
a6 1
  $Date: 2002/02/25 09:16:25 $
d4235 1
a4235 1
	format = "undefined method `%s' for nil";
d4238 1
a4238 1
	format = "undefined method `%s' for true";
d4241 1
a4241 1
	format = "undefined method `%s' for false";
a4250 17
	if (last_call_status & CSTAT_PRIV) {
	    format = "private method `%s' called for %s%s%s";
	}
	if (last_call_status & CSTAT_PROT) {
	    format = "protected method `%s' called for %s%s%s";
	}
	else if (last_call_status & CSTAT_VCALL) {
	    const char *mname = rb_id2name(id);

	    if (('a' <= mname[0] && mname[0] <= 'z') || mname[0] == '_') {
		format = "undefined local variable or method `%s' for %s%s%s";
		exc = rb_eNameError;
	    }
	}
	if (!format) {
	    format = "undefined method `%s' for %s%s%s";
	}
d4257 18
a4278 1

d4281 1
d4284 2
a4285 2
		 desc, desc[0]=='#' ? "" : ":",
		 desc[0]=='#' ? "" : rb_class2name(CLASS_OF(obj)));
@


1.265
log
@* eval.c (method_inspect): should not dump core for unbound
  singleton methods.

* object.c (rb_mod_to_s): better description.

* hash.c (env_select): should path the assoc list.

* process.c (rb_syswait): thread kludge; should be fixed to
  support native thread.
@
text
@d6 1
a6 1
  $Date: 2002/02/21 07:15:03 $
d2234 5
d2369 1
@


1.264
log
@* pack.c (pack_pack): wrong # comment treatment.

* pack.c (pack_unpack): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/02/20 04:31:50 $
d6944 1
a6944 1
	VALUE v;
d6946 4
a6949 4
	rb_str_buf_append(str, rb_inspect(data->recv));
	v = rb_iv_get(data->klass, "__attached__");
	if (data->recv != v) {
	    rb_str_buf_cat2(str, "(");
d6951 1
a6951 1
	    rb_str_buf_cat2(str, ").");
d6954 5
a6958 1
	    rb_str_buf_cat2(str, ".");
d6963 5
a6967 4
	rb_str_buf_cat2(str, "(");
	s = rb_class2name(data->klass);
	rb_str_buf_cat2(str, s);
	rb_str_buf_cat2(str, ")#");
d6969 2
a6970 2
    s = rb_id2name(data->oid);
    rb_str_buf_cat2(str, s);
@


1.263
log
@* hash.c (rb_any_cmp): should handle Qundef in keys.

* eval.c (remove_method): should not remove a empty method to
  implement "undef".

* eval.c (rb_eval): should allow singleton class def for
  true/false/nil.

* parse.y (str_extend): backslash escape was done wrong.
@
text
@d6 1
a6 1
  $Date: 2002/02/19 04:49:24 $
d3317 1
a3317 1
			     rb_class2name(CLASS_OF(klass)));
@


1.262
log
@* eval.c (rb_eval_string_wrap): should hide the toplevel local
  variable bindings by PUSH_SCOPE().
@
text
@d6 1
a6 1
  $Date: 2002/02/18 09:52:45 $
d314 1
a314 1
    if (!st_delete(RCLASS(klass)->m_tbl, &mid, &body)) {
d3304 19
a3322 8
	    klass = rb_eval(self, node->nd_recv);
	    if (rb_special_const_p(klass)) {
		rb_raise(rb_eTypeError, "no virtual class for %s",
			 rb_class2name(CLASS_OF(klass)));
	    }
	    if (rb_safe_level() >= 4 && !OBJ_TAINTED(klass))
		rb_raise(rb_eSecurityError, "Insecure: can't extend object");
	    klass = rb_singleton_class(klass);
@


1.261
log
@* parse.y (expr_value, arg_value, primary_value): value_expr()
  check in place.

* eval.c (block_pass): "&nil" should clear block given.

* dir.c (push_braces): remove MAXPATHLEN dependency.

* dir.c (dir_s_globd): ditto.

* dln.c (init_funcname): ditto.

* dln.c (load_1): ditto.

* dln.c (dln_load): ditto.

* configure.in: add GNU/Hurd switches.

* pack.c (pack_pack): allows comment in template strings.

* pack.c (pack_unpack): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/02/15 06:14:25 $
d1300 1
d1305 1
@


1.260
log
@* eval.c (rb_eval): replace rb_cvar_declare() by rb_cvar_set().

* eval.c (assign): ditto.

* variable.c (rb_cvar_set): 4th argument (warn) added; define new
  class variable if it's not defined yet.

* variable.c (rb_cvar_declare): removed.
@
text
@d6 1
a6 1
  $Date: 2002/02/13 09:01:09 $
d2326 1
d2330 1
a2330 1
	    if (node->nd_state && !RTEST(result = rb_eval(self, node->nd_cond)))
d2337 1
a2337 1
	    } while (RTEST(result = rb_eval(self, node->nd_cond)));
d2359 1
d2362 1
a2362 1
	    if (node->nd_state && RTEST(result = rb_eval(self, node->nd_cond)))
d2369 1
a2369 1
	    } while (!RTEST(result = rb_eval(self, node->nd_cond)));
d6603 4
a6606 1
	return rb_eval(self, node->nd_iter);
@


1.259
log
@* parse.y (stmt): local variable declaration order was changed
  since 1.6

* parse.y (arg): ditto.

* pack.c (pack_pack): add templates 'q' and 'Q'.

* pack.c (pack_unpack): ditto.

* bignum.c (rb_quad_pack): new utility function.

* bignum.c (rb_quad_unpack): ditto.

* parse.y (assignable): should emit CVASGN within the method
  body.

* dir.c (dir_s_glob): should not warn even if no match found.

* eval.c (rb_eval): clean up class variable behavior.

* eval.c (assign): ditto.

* eval.c (is_defined): ditto.

* variable.c (rb_mod_class_variables): need not to call rb_cvar_singleton().

* variable.c (rb_cvar_singleton): removed.
@
text
@d6 1
a6 1
  $Date: 2002/02/09 14:44:20 $
d2867 1
a2867 1
	rb_cvar_declare(ruby_cbase, node->nd_vid, result);
d2872 1
a2872 1
	rb_cvar_set(ruby_cbase, node->nd_vid, result);
d3918 1
a3918 1
	rb_cvar_declare(ruby_cbase, lhs->nd_vid, val);
d3922 1
a3922 1
	rb_cvar_set(ruby_cbase, lhs->nd_vid, val);
@


1.258
log
@* eval.c (rb_eval): singleton chech should be moved from yycompile
  to here.

* eval.c (is_defined): check should be added here too.
@
text
@d6 1
a6 1
  $Date: 2002/02/08 05:19:47 $
d439 1
a439 1
static ID init, eqq, each, aref, aset, match, to_ary, missing;
d1902 3
a1904 7
	if (!ruby_frame || !ruby_frame->last_class ||
	    !FL_TEST(ruby_frame->last_class, FL_SINGLETON)) {
	    if (NIL_P(ruby_cbase)) {
		if (rb_cvar_defined(CLASS_OF(self), node->nd_vid)) {
		    return "class variable";
		}
		break;
d1906 5
a1910 5
	    if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
		if (rb_cvar_defined(ruby_cbase, node->nd_vid)) {
		    return "class variable";
		}
		break;
d1912 1
d1914 1
a1914 3
	/* fall through */
      case NODE_CVAR2:
	if (rb_cvar_defined(rb_cvar_singleton(self), node->nd_vid)) {
d2864 2
a2865 4
	if (FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    rb_cvar_declare(rb_cvar_singleton(rb_iv_get(ruby_cbase, "__attached__")),
			    node->nd_vid, result);
	    break;
d2872 1
a2872 1
	rb_cvar_set(rb_cvar_singleton(self), node->nd_vid, result);
d2898 8
a2905 12
      case NODE_CVAR:		/* normal method */
	if (!ruby_frame || !ruby_frame->last_class ||
	    !FL_TEST(ruby_frame->last_class, FL_SINGLETON)) {
	    /* non singleton method */
	    if (NIL_P(ruby_cbase)) {
		result = rb_cvar_get(CLASS_OF(self), node->nd_vid);
		break;
	    }
	    if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
		result = rb_cvar_get(ruby_cbase, node->nd_vid);
		break;
	    }
d2907 1
a2907 3
	/* fall through */
      case NODE_CVAR2:		/* singleton method */
	result = rb_cvar_get(rb_cvar_singleton(self), node->nd_vid);
d3093 3
d3915 2
a3916 3
	if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    rb_cvar_declare(ruby_cbase, lhs->nd_vid, val);
	    break;
d3918 3
a3920 2
	self = rb_iv_get(ruby_cbase, "__attached__");
	/* fall through */
d3922 1
a3922 1
	rb_cvar_set(rb_cvar_singleton(self), lhs->nd_vid, val);
d6014 1
@


1.257
log
@* parse.y (yycompile): should inherit "in_single" if eval happened
  in a singleton method.

* eval.c (rb_eval): class variables from singleton methods defined
  within singleton class statement should work like ones defined
  by sington def statements.
@
text
@d6 1
a6 1
  $Date: 2002/02/06 07:30:13 $
d1902 7
a1908 3
	if (NIL_P(ruby_cbase)) {
	    if (rb_cvar_defined(CLASS_OF(self), node->nd_vid)) {
		return "class variable";
d1910 5
a1914 5
	    break;
	}
	if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    if (rb_cvar_defined(ruby_cbase, node->nd_vid)) {
		return "class variable";
a1915 1
	    break;
a1916 1
	self = rb_iv_get(ruby_cbase, "__attached__");
d2906 11
a2916 7
	if (NIL_P(ruby_cbase)) {
	    result = rb_cvar_get(CLASS_OF(self), node->nd_vid);
	    break;
	}
	if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    result = rb_cvar_get(ruby_cbase, node->nd_vid);
	    break;
@


1.256
log
@* io.c (rb_io_readlines): avoid calling GetOpenFile() repeatedly.

* io.c (rb_io_each_line): ditto.

* io.c (argf_getline): ditto.

* process.c: should include <time.h> to get proper CLK_TCK.
@
text
@d6 1
a6 1
  $Date: 2002/02/05 07:56:29 $
a2911 1
	self = rb_iv_get(ruby_cbase, "__attached__");
@


1.255
log
@* io.c (fptr_finalize): should raise error when fclose fails.

* eval.c (method_inspect): proper output format to distinguish
  methods and singleton methods.
@
text
@d6 1
a6 1
  $Date: 2002/02/04 08:07:01 $
d4672 4
a4675 2
	    if (TYPE(klass) == T_ICLASS) {
		klass = RBASIC(klass)->klass;
d4677 1
a4677 1
	    if (!rb_obj_is_kind_of(ruby_frame->self, rb_class_real(klass)))
@


1.254
log
@* object.c (rb_class_real): should not follow ICLASS link

* variable.c (classname): should follow ICLASS link explicitly.
@
text
@d6 1
a6 1
  $Date: 2002/01/28 08:44:37 $
d4672 3
d6763 1
a6763 1
    data->recv = 0;
d6793 1
a6793 1
    return mnew(mod, 0, rb_to_id(vid), rb_cUnboundMethod);
d6919 1
d6926 22
a6947 6
    s = rb_class2name(data->rklass);
    rb_str_buf_cat2(str, s);
    rb_str_buf_cat2(str, "(");
    s = rb_class2name(data->klass);
    rb_str_buf_cat2(str, s);
    rb_str_buf_cat2(str, ")#");
@


1.253
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.

* object.c (Init_Object): remove dup and clone from TrueClass,
  FalseClass, and NilClass.

* array.c (rb_ary_fill): Array#fill takes block to get the value to
  fill.

* string.c (rb_str_to_i): to_i(0) auto-detects base radix.

* array.c (rb_ary_initialize): fill by the block evaluation value
  if block is given.
@
text
@d6 1
a6 1
  $Date: 2002/01/25 08:22:04 $
d1806 1
a1806 1
	val = CLASS_OF(self);
a1813 1
	    val = CLASS_OF(val);
d1823 2
@


1.252
log
@* class.c (rb_include_module): detect cyclic module inclusion.

* eval.c (rb_thread_cleanup): need not to free thread stacks at
  process termination.

* array.c (rb_ary_fetch): use the block to get the default value
  if the block is given.

* eval.c (rb_thread_schedule): should check time only if BOTH
  WAIT_SELECT and WAIT_TIME.

* eval.c (umethod_bind): should update rklass field.

* hash.c (rb_hash_update): if a block is given, yields [key,
  value1, value2] to the block to resolve conflict.

* string.c (rb_str_split_m): no need to consider KANJI
characters, if the length of separator is 1 (byte).
@
text
@d6 1
a6 1
  $Date: 2002/01/23 07:30:39 $
d1937 1
d1939 1
a1939 1
		if (rb_method_boundp(val, node->nd_mid, 1)) {
d2941 1
a2941 1
	    result = rb_const_get_at(klass, node->nd_mid);
@


1.251
log
@* array.c (Init_Array): remove Array#filter.

* object.c (rb_mod_initialize): should accept zero argument.

* object.c (rb_mod_cmp): should raise ArgumentError if
  inheritance/inclusion relation between two classes/modules is
  not defined. [new]

* io.c (rb_io_fsync): new method. [new]
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/01/23 07:21:50 $
d169 1
a169 1
		  (TYPE(klass) == T_MODULE)?"module":"class",
d4265 2
a4266 2
		 desc, desc[0]=='#'?"":":",
		 desc[0]=='#'?"":rb_class2name(CLASS_OF(obj)));
d6869 1
d7323 1
a7323 1
    if (TYPE(data) != T_DATA || RDATA(data)->dfree != (RUBY_DATA_FUNC)thread_free) {
d7748 2
a7749 1
 		if ((th->wait_for & (WAIT_SELECT|WAIT_TIME)) && th->delay <= now) {
d7815 1
a7815 1
		    th->wait_for, th==main_thread?"(main)":"",
d8669 1
@


1.250
log
@* eval.c (rb_yield_0): restore source file/line after yield.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/21 07:44:05 $
d2940 1
a2940 1
	    result = rb_const_get(klass, node->nd_mid);
@


1.249
log
@* eval.c (ruby_stop): should not trace error handler.

* signal.c (install_sighandler): do not install sighandler unless
  the old value is SIG_DFL.

* io.c (io_write): should not raise exception on O_NONBLOCK io.

* dir.c (dir_set_pos): seek should return dir, pos= should not.
@
text
@d6 1
a6 1
  $Date: 2002/01/19 14:21:44 $
d3673 2
d3799 2
@


1.248
log
@* eval.c (rb_eval): need not to clar method cache for NODE_CLASS,
  NODE_SCLASS.

* gc.c (obj_free): need not to clear method cache on class/module
  finalization.
@
text
@d6 1
a6 1
  $Date: 2002/01/18 14:23:06 $
d1196 2
@


1.247
log
@* io.c (rb_io_s_new): block check moved from initialize to this
  method.

* io.c (rb_io_s_open): open should call initialize too. IO#for_fd
  also calls initialize. [new]

* error.c (rb_sys_fail): replace INT2FIX() by INT2NUM() since
  errno value may not fit in Fixnum size on Hurd.

* error.c (set_syserr): ditto.

* dir.c (dir_s_glob): returns nil if block given.

* io.c (rb_io_each_byte): should return self.

* io.c (rb_io_close_m): close check added.

* dir.c (dir_seek): should return pos.

* parse.y (fixpos): orig may be (NODE*)1, which should not be
  dereferenced.
@
text
@d6 1
a6 1
  $Date: 2002/01/17 08:04:57 $
d193 1
a193 1
    struct cache_entry *ent, *end;
a3241 1
		rb_clear_cache();
a3307 3
	    if (FL_TEST(CLASS_OF(klass), FL_SINGLETON)) {
		rb_clear_cache();
	    }
@


1.246
log
@* eval.c (block_pass): allow "retry" from within argument passed
  block. [new]

* eval.c (localjump_error): should preserve exit status in the
  exception object. [new]

* eval.c (proc_invoke): should raise exception for "break" if it's
  yielding, not calling. [new]

* eval.c (block_pass): should NOT raise exception for "break". [new]

* eval.c (block_pass): should allow block argument relay even in
  the tainted mode.

* ext/socket/socket.c: support subclassing by proper "initialize"
  calling convention. [new]
@
text
@d6 1
a6 1
  $Date: 2002/01/16 09:32:51 $
d6675 1
a6675 1
    VALUE klass, oklass;
d6685 1
a6685 1
    rb_gc_mark(data->oklass);
d6700 1
a6700 1
    VALUE oklass = klass;
d6705 1
a6705 1
	print_undef(oklass, oid);
d6718 1
a6718 1
    data->oklass = oklass;
d6739 1
a6739 1
    if (m1->klass != m2->klass || m1->oklass != m2->oklass ||
d6759 1
a6759 1
    data->oklass = orig->oklass;
d6848 2
a6849 2
    if (data->oklass != CLASS_OF(recv)) {
	if (FL_TEST(data->oklass, FL_SINGLETON)) {
d6856 3
a6858 3
	if (!((TYPE(data->oklass) == T_MODULE) ?
	      rb_obj_is_kind_of(recv, data->oklass) :
	      rb_obj_is_instance_of(recv, data->oklass))) {
d6860 1
a6860 1
		     rb_class2name(data->oklass));
d6917 1
a6917 1
    s = rb_class2name(data->oklass);
@


1.245
log
@* eval.c: bugus commit fixed (again, sorry).
@
text
@d6 1
a6 1
  $Date: 2002/01/16 09:27:54 $
d1315 16
d1338 1
a1338 1
	rb_raise(rb_eLocalJumpError, "unexpected return");
d1341 1
a1341 1
	rb_raise(rb_eLocalJumpError, "unexpected next");
d1344 1
a1344 1
	rb_raise(rb_eLocalJumpError, "unexpected break");
d1347 1
a1347 1
	rb_raise(rb_eLocalJumpError, "unexpected redo");
d1350 1
a1350 1
	rb_raise(rb_eLocalJumpError, "retry outside of rescue clause");
d3679 1
a3679 1
	rb_raise(rb_eLocalJumpError, "no block given");
d6328 2
a6329 2
static void
proc_set_safe_level(data)
d6335 1
a6335 2
	    ruby_safe_level = 3;
	    break;
d6337 1
a6337 2
	    ruby_safe_level = 4;
	    break;
d6339 1
a6339 2
	    ruby_safe_level = 5;
	    break;
d6341 11
d6488 3
d6494 1
a6494 1
	rb_raise(rb_eLocalJumpError, "retry from proc-closure");
d6498 1
a6498 1
	    rb_raise(rb_eLocalJumpError, "return from proc-closure");
d6607 3
a6609 1
	rb_raise(rb_eSecurityError, "Insecure: tainted block value");
d6615 1
d6659 1
a6659 3
	if (orphan) {
	    rb_raise(rb_eLocalJumpError, "break from proc-closure");
	}
d6662 1
a6662 2
	rb_raise(rb_eLocalJumpError, "retry from proc-closure");
	break;
d6665 1
a6665 1
	    rb_raise(rb_eLocalJumpError, "return from proc-closure");
d7038 2
@


1.244
log
@* eval.c: bugus commit fixed.
@
text
@d6 1
a6 1
  $Date: 2002/01/16 09:25:54 $
d1818 2
@


1.243
log
@* st.c: primes should be primes.

* eval.c (is_defined): method defined? check should honor
  protected too.

* eval.c (block_pass): should not pass tainted block, if $SAFE > 0.

* variable.c (rb_mod_remove_cvar): should pass the char*.
@
text
@d6 1
a6 1
  $Date: 2002/01/11 09:18:49 $
a1816 1
		}
a1817 2
	    else if (!rb_method_boundp(val, node->nd_mid, call))
		break;
@


1.242
log
@* re.c (match_select): should propagate taintness.

* hash.c (rb_hash_set_default): Hash#default= should return the
  new value.

* string.c (rb_str_to_i): accepts optional base argument. [new]

* numeric.c (rb_fix2str): should not handle negative fixnum values
  int32 via calling sprintf() directly.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/01/10 20:18:39 $
d1804 17
a1820 1
	if (rb_method_boundp(val, node->nd_mid, nd_type(node)== NODE_CALL)) {
d4653 1
a4653 4
	    VALUE defined_class = klass;
	    while (TYPE(defined_class) == T_ICLASS)
		defined_class = RBASIC(defined_class)->klass;
	    if (!rb_obj_is_kind_of(ruby_frame->self, defined_class))
d6578 4
@


1.241
log
@* class.c (rb_make_metaclass): [new]

* class.c (rb_define_class_id): use rb_make_metaclass(), don't
  call Class#inherited hook.

* class.c (rb_class_inherited): [new]

* class.c (rb_define_class): call Class#inherited hook here.

* class.c (rb_define_class_under): ditto after class path is set.

* class.c (rb_singleton_class): use rb_make_metaclass().

* eval.c (rb_eval): same as rb_define_class_under().

* intern.h: prototypes of rb_make_metaclass() and
  rb_class_inherited().

* object.c (rb_class_s_new): use rb_make_metaclass() and
  rb_class_inherited().

* object.c (Init_Object): use rb_make_metaclass().

* struct.c (make_struct): use rb_class_inherited().
@
text
@d6 1
a6 1
  $Date: 2002/01/10 13:28:58 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
d320 1
a320 2
	rb_funcall(rb_iv_get(klass, "__attached__"),
		   singleton_removed, 1, ID2SYM(mid));
d682 1
@


1.240
log
@* eval.c (rb_add_method): should clear cache by id always.

* eval.c (rb_disable_super): no longer need to clear cache before
  rb_add_method().

* eval.c (rb_export_method): ditto.

* eval.c (rb_attr): ditto.

* eval.c (rb_undef): ditto.

* eval.c (rb_eval): ditto.

* eval.c (rb_mod_modfunc): ditto.

* eval.c (rb_mod_define_method): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/01/08 07:02:26 $
d3217 2
a3219 1
		rb_set_class_path(klass,ruby_class,rb_id2name(node->nd_cname));
@


1.239
log
@* eval.c (rb_add_method): clear replaced method from the cache.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/04 14:14:34 $
d231 1
d233 1
a233 2
    if (st_insert(RCLASS(klass)->m_tbl, mid, body))
	rb_clear_cache_by_id(mid);
a360 1
	rb_clear_cache_by_id(mid);
a409 1
	    rb_clear_cache_by_id(name);
a478 1
	rb_clear_cache_by_id(id);
a484 1
	rb_clear_cache_by_id(id);
a1582 1
    rb_clear_cache_by_id(id);
a3102 1
	    rb_clear_cache_by_id(node->nd_mid);
a3147 1
	    rb_clear_cache_by_id(node->nd_mid);
a5709 1
	rb_clear_cache_by_id(id);
a6975 1
    rb_clear_cache_by_id(id);
@


1.238
log
@* process.c (rb_f_system): abandon vfork.

* io.c (pipe_open): ditto.

* defines.h: sparc linux needs different FLUSH_REGISTER_WINDOWS

* regex.c (re_search): abandon stclass optimization.

* bignum.c (rb_cstr2inum): deny "0_".

* bignum.c (rb_cstr2inum): allow "0\n" and so on.

* error.c (rb_invalid_str): utility function to show inspect()'ed
  string.

* bignum.c (rb_cstr2inum): prints invalid strings in inspect()'ed
  format.

* object.c (rb_Float): ditto.

* object.c (rb_convert_type): no longer use rb_rescue().

* re.c (rb_reg_search): initialize taint status of match object.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/12/20 18:19:42 $
d232 2
a233 1
    st_insert(RCLASS(klass)->m_tbl, mid, body);
@


1.237
log
@* eval.c (rb_mod_define_method): must not convert Method to Proc.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/12/19 07:48:30 $
d8458 1
a8458 2
	else if (th->safe < 4 &&
		 (thread_abort || th->abort || RTEST(ruby_debug))) {
@


1.236
log
@* eval.c (rb_mod_define_method): define_method should follow
  default method visibility.

* eval.c (rb_attr): should warn if the default method visibility
  is "module_function" (can be error).

* eval.c (rb_mod_define_method): should define class/module method
  also if the visibility is "module_function".

* eval.c (rb_mod_define_method): should call hook method
  "method_added", and "singleton_method_added".

* string.c: use RESIZE_CAPA for capacity change.

* ext/socket/socket.c (Init_socket): add listen method to
  TCPServer and UNIXServer.

* ext/socket/socket.c (bsock_send): should raise EWOULDBLOCK
  exception.

* ext/socket/socket.c (s_recvfrom): ditto.

* ext/socket/socket.c (s_accept): ditto.

* ext/socket/socket.c (udp_send): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/12/18 08:46:56 $
d6955 2
a6956 5
	if (rb_obj_is_kind_of(body, rb_cMethod)) {
	    body = method_proc(body);
	}
	else if (!rb_obj_is_proc(body)) {
	    rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc)",
d6971 1
a6971 1
	rb_raise(rb_eTypeError, "wrong argument type (expected Proc)");
@


1.235
log
@* string.c (rb_str_replace): swap arguments of OBJ_INFECT.

* eval.c (rb_thread_schedule): should not select a thread which is
  not yet initialized.

* time.c (time_plus): wrong boundary check.

* time.c (time_minus): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/12/17 07:52:34 $
d360 1
a361 1
	rb_clear_cache_by_id(mid);
d410 1
a411 1
	    rb_clear_cache_by_id(name);
d460 3
a462 1
	    rb_warning("private attribute?");
d480 1
a481 1
	rb_clear_cache_by_id(id);
d487 1
a488 1
	rb_clear_cache_by_id(id);
d1586 1
a1587 1
    rb_clear_cache_by_id(id);
d1635 1
a1637 1
    rb_clear_cache_by_id(name);
d3107 1
a3108 1
	    rb_clear_cache_by_id(node->nd_mid);
d3153 1
a3155 1
	    rb_clear_cache_by_id(node->nd_mid);
d5716 1
a5717 1
	rb_clear_cache_by_id(id);
d6945 2
d6955 7
a6965 4
    if (TYPE(body) != T_DATA) {
	/* type error */
	rb_raise(rb_eTypeError, "wrong argument type (expected Proc)");
    }
d6967 1
a6967 1
	rb_add_method(mod, id, NEW_DMETHOD(method_unbind(body)), NOEX_PUBLIC);
d6970 1
a6970 1
	rb_add_method(mod, id, NEW_BMETHOD(body), NOEX_PUBLIC);
d6977 9
d6987 11
@


1.234
log
@* intern.h: add prototypes.
  rb_gc_enable(), rb_gc_disable(), rb_gc_start(), rb_str_new5()
  rb_str_buf_append(), rb_str_buf_cat(), rb_str_buf_cat2(),
  rb_str_dup_frozen()

* ruby.h: added declaration.
  rb_defout, rb_stdin, rb_stdout, rb_stderr, ruby_errinfo

* rubyio.h: changed double include guard macro to RUBYIO_H.

* array.c (inspect_call): make static.

* eval.c (dvar_asgn): ditto.

* io.c (rb_io_close_read): ditto.

* lex.c (rb_reserved_word): ditto.

* ruby.c: (req_list_head, req_list_last): ditto.

* ruby.c (require_libraries): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/11/29 15:57:25 $
d7735 1
a7735 1
	if (th->status == THREAD_RUNNABLE) {
@


1.233
log
@* string.c (rb_str_equal): object with to_str must be treated as a
  string.
@
text
@d6 1
a6 1
  $Date: 2001/11/28 14:55:55 $
d702 1
a702 1
void
@


1.232
log
@* eval.c (rb_thread_select): should subtract timeofday() from
  limit, not reverse.

* util.c (scan_hex): x is not a hexadecimal digit.

* eval.c (rb_thread_schedule): should treat the case that
  select(2) returns 0, if a thread is under both WAIT_SELECT and
  WAIT_TIME.  Jakub Travnik <J.Travnik@@sh.cvut.cz> actually fixed
  this bug.
@
text
@d6 1
a6 1
  $Date: 2001/11/27 10:00:30 $
d7683 1
a7683 1
 		if ((th->wait_for & (WAIT_SELECT|WAIT_TIME)) && th->delay < now) {
@


1.231
log
@* marshal.c (w_float): must distinguish -0.0 from 0.0.

* gc.c (gc_mark_all): tweak mark order for little bit better scan.

* gc.c (rb_gc_mark): ditto.

* gc.c (rb_gc): ditto.

* enum.c (sort_by_i): slight performance boost.

* gc.c (gc_mark_rest): should call gc_mark_children(), not gc_mark().

* gc.c (rb_gc_mark): may cause infinite looop.
@
text
@d6 1
a6 1
  $Date: 2001/11/21 15:41:26 $
d7574 1
d7619 1
a7619 1
		need_select = 2;
d7680 11
a7690 8
	if (n == 0 && need_select == 2) {
	    if (now < 0.0) now = timeofday();
	    FOREACH_THREAD_FROM(curr, th) {
		if ((th->wait_for & (WAIT_SELECT|WAIT_TIME)) && th->delay < now) {
		    th->status = THREAD_RUNNABLE;
		    th->wait_for = 0;
		    th->select_value = 0;
		    found = 1;
d7919 1
a7919 1
			double d = timeofday() - limit;
@


1.230
log
@* parse.y (str_extend): should check nesting parentheses in #{}.

* process.c (pst_wstopsig): returns nil unless WIFSTOPPED() is
  non-zero.

* process.c (pst_wtermsig): returns nil unless WIFSIGNALED() is
  non-zero.

* process.c (pst_wexitstatus): returns nil unless WIFEXITED() is
  non-zero.

* eval.c (rb_thread_select): tv_sec and tv_usec should not be
  negative.

* signal.c (posix_signal): do not set SA_RESTART for SIGVTALRM.

* parse.y (call_args2): block_arg may follow the first argument in
  call_args2.

* eval.c (stack_check): should avoid stack length check during
  raising SystemStackError exception.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 14:42:44 $
d7617 3
d7675 12
@


1.229
log
@* eval.c (rb_mod_modfunc): should follow NODE_ZSUPER link; based
  on Guy Decoux's patch in [ruby-talk:25478].

* string.c (rb_str_succ): there was buffer overrun.

* parse.y (str_extend): term can be any character.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 05:03:03 $
d499 1
d4139 18
d4181 1
a4181 1
    ruby_stack_check();
d4387 1
a4387 1
	ruby_stack_check();
d6978 1
d7904 2
@


1.228
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* massages: replace "wrong #" by "wrong number".

* marshal.c (w_float): output Infinity and NaN explicitly.

* marshal.c (r_object): support new explicit float format.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.

* array.c (rb_ary_join): dumped core if sep is not T_STRING nor T_NIL.

* array.c (rb_ary_join): buffer size calculattion was wrong.

* array.c (rb_ary_to_s): if rb_output_fs is nil, insert newlines
  between array elements (use rb_default_rs as newline litral)
  [experimental].

* gc.c (init_mark_stack): no need to clear mark_stack.

* gc.c (gc_mark_all): need to handle finalizer mark.

* gc.c (gc_mark_rest): use MEMCPY instead of memcpy.

* gc.c (rb_gc_mark): earlier const check to avoid pusing special
  constants into mark stack.

* numeric.c (fix_to_s): 'to_s' now takes optional argument to
  specify radix. [new]

* bignum.c (rb_big_to_s): ditto. [new]
@
text
@d6 1
a6 1
  $Date: 2001/11/13 08:19:51 $
d5682 2
d5685 9
a5693 3
	body = search_method(module, id, 0);
	if (body == 0 || body->nd_body == 0) {
	    rb_bug("undefined method `%s'; can't happen", rb_id2name(id));
@


1.227
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* eval.c (rb_eval_cmd): should not upgrade safe level unless
  explicitly specified by argument newly added.

* signal.c (sig_trap): should not allow tainted trap closure.

* variable.c (rb_f_trace_var): should not allow trace_var on safe
  level higher than 3.

* variable.c (rb_f_trace_var): should not allow tainted trace
  closure.

* gc.c: do not use static stack until system stack overflows.

* eval.c (eval): should call Exception#exception instead of
  calling rb_exc_new3() directly.

* error.c (exc_exception): set "mesg" directly to the clone.  it
  might be better to set mesg via some method for flexibility.

* variable.c (cvar_override_check): should print original module
  name, if 'a' is T_ICLASS.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/11/09 00:10:10 $
a93 4
#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#endif

a498 1
static VALUE rb_eSysStackError;
d3053 1
a3053 1
	    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",
d3585 1
a3585 1
	rb_raise(rb_eArgError, "wrong # of arguments");
d3683 1
a3683 1
		    rb_raise(rb_eArgError, "wrong # of arguments (%d for 0)",
d3689 1
a3689 1
		    rb_raise(rb_eArgError, "wrong # of arguments (%d for 0)",
d3848 1
a3848 1
    rb_raise(rb_eArgError, "wrong # of arguments (%d for %d)", len, i);
d4162 1
a4162 1
    rb_stack_check();
a4252 51
#ifdef DJGPP
static unsigned int STACK_LEVEL_MAX = 65535;
#else
#ifdef __human68k__
extern unsigned int _stacksize;
# define STACK_LEVEL_MAX (_stacksize - 4096)
# undef HAVE_GETRLIMIT
#else
#ifdef HAVE_GETRLIMIT
static unsigned int STACK_LEVEL_MAX = 655300;
#else
# define STACK_LEVEL_MAX 655300
#endif
#endif
#endif

extern VALUE *rb_gc_stack_start;
static int
stack_length(p)
    VALUE **p;
{
#ifdef C_ALLOCA
    VALUE stack_end;
    alloca(0);
# define STACK_END (&stack_end)
#else
# if defined(__GNUC__) && defined(USE_BUILTIN_FRAME_ADDRESS)
    VALUE *stack_end = __builtin_frame_address(0);
# else
    VALUE *stack_end = alloca(1);
# endif
# define STACK_END (stack_end)
#endif
    if (p) *p = STACK_END;

#ifdef __sparc__
    return rb_gc_stack_start - STACK_END + 0x80;
#else
    return (STACK_END < rb_gc_stack_start) ? rb_gc_stack_start - STACK_END
	                                   : STACK_END - rb_gc_stack_start;
#endif
}

void
rb_stack_check()
{
    if (stack_length(0) > STACK_LEVEL_MAX) {
	rb_raise(rb_eSysStackError, "stack level too deep");
    }
}

d4261 1
a4261 1
	rb_raise(rb_eArgError, "wrong # of arguments(%d for %d)",
d4368 1
a4368 1
	rb_stack_check();
d4415 1
a4415 1
	    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)", argc);
d4479 1
a4479 1
			rb_raise(rb_eArgError, "wrong # of arguments(%d for %d)",
d4491 1
a4491 1
			    rb_raise(rb_eArgError, "wrong # of arguments(%d for %d)",
d5159 1
a5159 1
	    rb_raise(rb_eArgError, "wrong # of arguments (%d for 0)", argc);
d5178 1
a5178 1
		rb_raise(rb_eArgError, "wrong # of arguments: %s(src) or %s{..}",
d5771 1
a5771 1
	rb_raise(rb_eArgError, "wrong # of arguments(0 for 1)");
a6048 13

#ifdef HAVE_GETRLIMIT
    {
	struct rlimit rlim;

	if (getrlimit(RLIMIT_STACK, &rlim) == 0) {
	    double space = (double)rlim.rlim_cur*0.2;

	    if (space > 1024*1024) space = 1024*1024;
	    STACK_LEVEL_MAX = (rlim.rlim_cur - space) / sizeof(VALUE);
	}
    }
#endif
d6926 1
a6926 1
	rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)", argc);
a6950 1
    rb_eSysStackError = rb_define_class("SystemStackError", rb_eStandardError);
d7254 2
d7264 1
a7264 1
    len = stack_length(&pos);
d7791 3
d7865 8
a7872 3
	    if (n < 0 && errno == EINTR) {
		if (timeout) {
		    double d = timeofday() - limit;
d7874 6
a7879 2
		    tv.tv_sec = (unsigned int)d;
		    tv.tv_usec = (long)((d-(double)tv.tv_sec)*1e6);
a7880 1
		continue;
d7889 8
a7896 2
	    if (n < 0 && errno == EINTR) {
		continue;
@


1.226
log
@too much backout
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/11/08 12:40:44 $
d927 1
a927 1
    if (NIL_P(errat)) {
d933 3
d1348 1
a1348 1
rb_eval_cmd(cmd, arg)
d1350 1
d1372 1
a1372 1
    if (OBJ_TAINTED(cmd)) {
d1403 1
a1403 1
	val = rb_eval_cmd(cmd, rb_ary_new3(1, INT2FIX(sig)));
d1437 1
a1437 1
	    rb_raise(rb_eTypeError, "superclass undefined");
d4264 1
a4264 1
#undef HAVE_GETRLIMIT
d5044 1
a5044 1
		rb_exc_raise(rb_exc_new3(CLASS_OF(ruby_errinfo), err));
@


1.225
log
@* eval.c (rb_trap_eval): avoid annoying warning with signal.
  [ruby-talk:23225]

* eval.c (rb_call0): adjust caller source file/line while
  evaluating optional arguments.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/11/08 09:39:45 $
d3650 2
a3651 2
    if (!(rb_block_given_p() || rb_f_block_given_p())) {
	rb_raise(rb_eLocalJumpError, "yield called out of block");
@


1.224
log
@eval.c fix
@
text
@d6 1
a6 1
  $Date: 2001/11/08 09:21:59 $
d1397 1
d1401 1
d4564 5
a4568 1
			    rb_eval(recv, opt);
@


1.223
log
@* file.c (path_check_1): forgot to initialize 'p'.

* mkconfig.rb: use String#dump to generate Ruby string literal.

* range.c (range_eql): should override 'eql?'

* array.c (rb_ary_hash): should override 'hash' too.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/10/22 16:28:51 $
d597 3
a599 3
#define PUSH_VARS() {			\
    struct RVarmap * volatile _old;	\
    _old = ruby_dyna_vars;		\
d602 6
a607 4
#define POP_VARS()			\
   if (_old && (ruby_scope->flags & SCOPE_DONT_RECYCLE)) \
       FL_SET(_old, DVAR_DONT_RECYCLE); \
    ruby_dyna_vars = _old;		\
d1354 4
a1357 2
	return rb_funcall2(cmd, rb_intern("call"),
			   RARRAY(arg)->len, RARRAY(arg)->ptr);
d2743 1
a2743 1
	    val = rb_funcall2(recv, aset, argc, argv);
d3928 1
a3928 1
    VALUE (*it_proc)(), (*bl_proc)();
d4002 1
a4002 1
rb_rescue2(VALUE (*b_proc)(), VALUE data1, VALUE (*r_proc)(), VALUE data2, ...)
d4005 1
a4005 1
    VALUE (*b_proc)(), (*r_proc)();
d4096 1
d4098 1
a4098 1
    VALUE data1, data2;
d5057 3
d5101 1
d5197 1
a5197 1
VALUE
d5971 1
a5971 1
    struct end_proc_data *link;
d5974 8
d5983 1
a5983 1
    while (link) {
d6957 1
a6957 1
    return rb_iterate(mproc, 0, bmcall, method);
d6964 1
a6964 1
    return rb_iterate(mproc, 0, umcall, method);
d9083 1
a9083 1
    return rb_iterate(catch_i, rb_intern(tag), proc, data);
@


1.222
log
@* process.c (security): always give warning for insecure PATH.

* dir.c (my_getcwd): do not rely on MAXPATHLEN.

* file.c (rb_file_s_readlink): ditto.

* file.c (path_check_1): ditto.

* eval.c (rb_yield_0): should not call rb_f_block_given_p().

* string.c (rb_str_chomp_bang): should terminate string by NUL.

* eval.c (rb_yield_0): better error message.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/31 08:00:18 $
d597 3
a599 3
#define PUSH_VARS() { \
    struct RVarmap * volatile _old; \
    _old = ruby_dyna_vars; \
d602 4
a605 6
#define POP_VARS() \
   if (_old && (ruby_scope->flags & SCOPE_DONT_RECYCLE)) {\
       if (RBASIC(_old)->flags) /* unless it's already recycled */ \
           FL_SET(_old, DVAR_DONT_RECYCLE); \
    }\
    ruby_dyna_vars = _old; \
d1352 2
a1353 4
	PUSH_ITER(ITER_NOT);
	val = rb_funcall2(cmd, rb_intern("call"), RARRAY(arg)->len, RARRAY(arg)->ptr);
	POP_ITER();
	return val;
d2739 1
a2739 1
	    rb_funcall2(recv, aset, argc, argv);
d3644 2
a3645 2
    if (!rb_block_given_p()) {
	rb_raise(rb_eLocalJumpError, "no block given");
d3924 1
a3924 1
    VALUE (*it_proc) _((VALUE)), (*bl_proc)(ANYARGS);
d3998 1
a3998 1
rb_rescue2(VALUE (*b_proc)(ANYARGS), VALUE data1, VALUE (*r_proc)(ANYARGS), VALUE data2, ...)
d4001 1
a4001 1
    VALUE (*b_proc)(ANYARGS), (*r_proc)(ANYARGS);
a4091 1
    VALUE data1;
d4093 1
a4093 1
    VALUE data2;
a5051 3
	if (!NIL_P(scope) && !OBJ_TAINTED(scope)) {
	    rb_raise(rb_eSecurityError, "Insecure: can't modify trusted binding");
	}
a5092 1
    ruby_frame->self = _frame.prev->self;
d5188 1
a5188 1
static VALUE
d5962 1
a5962 1
    struct end_proc_data *link, *save;
d5965 1
a5965 1
    save = link = end_procs;
a5972 8
    link = end_procs;
    while (link != save) {
	rb_protect((VALUE(*)_((VALUE)))link->func, link->data, &status);
	if (status) {
	    error_handle(status);
	}
	link = link->next;
    }
d6940 1
a6940 1
    return rb_iterate((VALUE(*)_((VALUE)))mproc, 0, bmcall, method);
d6947 1
a6947 1
    return rb_iterate((VALUE(*)_((VALUE)))mproc, 0, umcall, method);
d9066 1
a9066 1
    return rb_iterate((VALUE(*)_((VALUE)))catch_i, rb_intern(tag), proc, data);
@


1.221
log
@* eval.c (exec_under): should initialize ruby_frame->self;
@
text
@d6 1
a6 1
  $Date: 2001/10/31 06:53:22 $
d3648 2
a3649 2
    if (!(rb_block_given_p() || rb_f_block_given_p())) {
	rb_raise(rb_eLocalJumpError, "yield called out of block");
@


1.220
log
@* eval.c (POP_VARS): should not set DVAR_DONT_RECYCLE if _old
  ruby_vars is already force_recycled.

* gc.c (rb_gc): handles mark stack overflow.

* gc.c (PUSH_MARK): use static mark stack, no more recursion.
@
text
@d6 1
a6 1
  $Date: 2001/10/30 08:43:25 $
d5101 1
@


1.219
log
@* string.c (rb_str_chomp_bang): do smart chomp if $/ == '\n'.

* io.c (rb_io_puts): don't treat Array specially.

* bignum.c (rb_big_cmp): should convert bignum to float.

* eval.c (rb_f_eval): can't modify untainted binding.

* regex.c (re_compile_pattern): should preverve p0 value.
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/10/29 06:16:00 $
d597 3
a599 3
#define PUSH_VARS() {			\
    struct RVarmap * volatile _old;	\
    _old = ruby_dyna_vars;		\
d602 6
a607 4
#define POP_VARS()			\
   if (_old && (ruby_scope->flags & SCOPE_DONT_RECYCLE)) \
       FL_SET(_old, DVAR_DONT_RECYCLE); \
    ruby_dyna_vars = _old;		\
@


1.218
log
@	* intern.h (rb_protect_inspect): follow the change of array.c.

	* eval.c (rb_exec_end_proc): follow the change of rb_protect().

	* eval.c (method_proc, umethod_proc, rb_catch): cast the first
	  parameter of rb_iterate() to avoid VC++ warning.

	* range.c (range_step): ditto.

	* ext/sdbm/init.c (fsdbm_update, fsdbm_replace): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/29 05:07:17 $
d5055 3
@


1.217
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* variable.c (rb_cvar_set): empty iv_tbl may cause infinite loop.

* variable.c (rb_cvar_get): ditto.

* variable.c (cvar_override_check): ditto.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.

* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/10/22 16:28:51 $
d5970 1
a5970 1
	rb_protect((VALUE(*)())link->func, link->data, &status);
d5978 1
a5978 1
	rb_protect((VALUE(*)())link->func, link->data, &status);
d6951 1
a6951 1
    return rb_iterate(mproc, 0, bmcall, method);
d6958 1
a6958 1
    return rb_iterate(mproc, 0, umcall, method);
d9077 1
a9077 1
    return rb_iterate(catch_i, rb_intern(tag), proc, data);
@


1.216
log
@* eval.c (proc_invoke): fix self switching in Proc#call
  (ruby-bugs-ja#PR108) and GC failure.  use Qundef instead of 0
  to direct not switching self.

* eval.c (call_trace_func): ditto.

* eval.c (call_end_proc): ditto.

* eval.c (proc_call): ditto.

* eval.c (proc_yield): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/22 06:48:14 $
d1352 4
a1355 2
	return rb_funcall2(cmd, rb_intern("call"),
			   RARRAY(arg)->len, RARRAY(arg)->ptr);
d2741 1
a2741 1
	    val = rb_funcall2(recv, aset, argc, argv);
d3926 1
a3926 1
    VALUE (*it_proc)(), (*bl_proc)();
d4000 1
a4000 1
rb_rescue2(VALUE (*b_proc)(), VALUE data1, VALUE (*r_proc)(), VALUE data2, ...)
d4003 1
a4003 1
    VALUE (*b_proc)(), (*r_proc)();
d4094 1
d4096 1
a4096 1
    VALUE data1, data2;
d5965 1
a5965 1
    struct end_proc_data *link;
d5968 8
d5977 2
a5978 2
    while (link) {
	rb_protect((VALUE(*)_((VALUE)))link->func, link->data, &status);
@


1.215
log
@* class.c (rb_mod_clone): should not copy class name, since clone
  should remain anonymous.

* eval.c (rb_call0): self in a block given to define_method now be
  switched to the receiver of the method.

* eval.c (proc_invoke): added new parameter to allow self
  switching.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/10/16 15:14:37 $
d2021 1
a2021 1
		    Qtrue, 0);
d5934 1
a5934 1
    proc_invoke(data, rb_ary_new2(0), Qfalse, 0);
d6454 1
a6454 1
	result = rb_yield_0(args, self, self?self:ruby_block->self, pcall);
d6491 1
a6491 1
    return proc_invoke(proc, args, Qtrue, 0);
d6498 1
a6498 1
    return proc_invoke(proc, args, Qfalse, 0);
@


1.214
log
@* eval.c (rb_f_missing): check stack level with rb_stack_check().

* eval.c (rb_call0): ditto.

* eval.c, intern.h (rb_stack_check): added. [new]
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/10 08:21:12 $
d102 1
a102 1
static VALUE proc_call _((VALUE,VALUE));
d1549 3
d1554 2
a1555 3
    if (id == __id__ || id == __send__) {
	rb_warn("undefining `%s' may cause serious problem",
		rb_id2name(id));
d2015 7
a2021 6
	proc_call(trace_func, rb_ary_new3(6, rb_str_new2(event),
					  srcfile,
					  INT2FIX(ruby_sourceline),
					  id?ID2SYM(id):Qnil,
					  self?rb_f_binding(self):Qnil,
					  klass));
d4473 1
a4473 1
	result = proc_call(body->nd_cval, rb_ary_new4(argc, argv));
d5934 1
a5934 1
    proc_call(data, rb_ary_new2(0));
d6413 1
a6413 1
proc_invoke(proc, args, pcall)
d6416 1
d6454 1
a6454 1
	result = rb_yield_0(args, 0, 0, pcall);
d6491 1
a6491 1
    return proc_invoke(proc, args, Qtrue);
d6498 1
a6498 1
    return proc_invoke(proc, args, Qfalse);
@


1.213
log
@* file.c (rb_stat_clone): should copy internal data too.

* numeric.c (num_clone): Numeric should not be copied by clone.

* object.c (rb_obj_clone): should check immediate values.

* parse.y (command): `yield' should take command_args.

* parse.y (parse_quotedwords): %w(...) is not a string.
@
text
@d6 1
a6 1
  $Date: 2001/10/09 14:56:15 $
d4153 2
d4287 8
d4410 1
a4410 3
	if (stack_length(0) > STACK_LEVEL_MAX) {
	    rb_raise(rb_eSysStackError, "stack level too deep");
	}
@


1.212
log
@eval.c backout.
@
text
@d6 1
a6 1
  $Date: 2001/10/09 09:46:42 $
d5235 1
a5235 1
static VALUE
@


1.211
log
@* eval.c (rb_eval): NODE_MATCH3 was confusing left and right. sigh.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/10/09 08:15:56 $
d8029 2
a8030 2
thread_kill(thread, result)
    VALUE thread, result;
a8043 1
    th->result = result;
a8048 7
rb_thread_kill(th)
    VALUE th;
{
    return thread_kill(th, Qfalse);
}

static VALUE
d8056 1
a8056 15
rb_thread_exit(argc, argv, th)
    int argc;
    VALUE *argv;
    VALUE th;
{
    VALUE result = Qfalse;

    rb_scan_args(argc, argv, "01", &result);
    return rb_thread_kill(th, result);
}

static VALUE
rb_thread_s_exit(argc, argv)
    int argc;
    VALUE *argv;
d8058 1
a8058 1
    return rb_thread_exit(argc, argv, curr_thread->thread);
d8964 1
a8964 1
    rb_define_singleton_method(rb_cThread, "exit", rb_thread_s_exit, -1);
d8979 1
a8979 1
    rb_define_method(rb_cThread, "exit", rb_thread_exit, -1);
@


1.210
log
@* eval.c (thread_status_name): separated from
  rb_thread_inspect(). return string expression for thread status.

* eval.c (rb_thread_status, rb_thread_inspect): use
  thread_status_name().

* eval.c (rb_thread_priority_set): return the priority not but
  self.
@
text
@d6 1
a6 1
  $Date: 2001/10/05 05:49:02 $
d2143 2
a2144 2
	    if (TYPE(r) == T_STRING) {
		result = rb_reg_match(l, r);
d2147 1
a2147 1
		result = rb_funcall(r, match, 1, l);
d8029 2
a8030 2
rb_thread_kill(thread)
    VALUE thread;
d8044 1
d8050 7
d8064 15
a8078 1
rb_thread_exit()
d8080 1
a8080 1
    return rb_thread_kill(curr_thread->thread);
d8986 1
a8986 1
    rb_define_singleton_method(rb_cThread, "exit", rb_thread_exit, 0);
d9001 1
a9001 1
    rb_define_method(rb_cThread, "exit", rb_thread_kill, 0);
@


1.209
log
@* eval.c (proc_s_new): revived.

* eval.c (Init_Proc): define Proc.new instead of Proc.allocate to
  inhibit from creating uninitialized Proc.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/03 07:19:10 $
d7113 18
d8155 1
a8155 1
    return thread;
d8507 1
a8507 3
    if (th->status == THREAD_STOPPED)
	return rb_str_new2("sleep");
    return rb_str_new2("run");
d8796 1
a8796 1
    char *status;
a8798 12
    switch (th->status) {
      case THREAD_RUNNABLE:
	status = "run"; break;
      case THREAD_STOPPED:
	status = "sleep"; break;
      case THREAD_TO_KILL:
	status = "aborting"; break;
      case THREAD_KILLED:
	status = "dead"; break;
      default:
	status = "unknown"; break;
    }
@


1.208
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/10/02 04:31:18 $
d6367 12
d6984 2
a6985 1
    rb_define_singleton_method(rb_cProc, "allocate", proc_new, 0);
@


1.207
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* string.c (rb_str_subpat_set): support function for new argument
  pattern String#[re,offset] = val. [new]

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_aref_m): new argument pattern
  String#[re,offset]. [new]

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* array.c (rb_ary_initialize): Array.new([1,2,3]) => [1,2,3]. [new]

* string.c (rb_str_reverse): should return an instance of
  receiver's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.

* eval.c (eval): retrieves file, line information from binding.

* eval.c (intersect_fds): counts intersecting fds.

* eval.c (rb_thread_schedule): only fds requested by
  each thread count as select_value.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/09/20 12:51:58 $
d3198 1
a3198 7
		    tmp = RCLASS(klass)->super;
		    if (FL_TEST(tmp, FL_SINGLETON)) {
			tmp = RCLASS(tmp)->super;
		    }
		    while (TYPE(tmp) == T_ICLASS) {
			tmp = RCLASS(tmp)->super;
		    }
a3199 1
			super = tmp;
a5763 17
VALUE
rb_class_new_instance(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE obj;

    if (FL_TEST(klass, FL_SINGLETON)) {
	rb_raise(rb_eTypeError, "can't create instance of virtual class");
    }
    obj = rb_obj_alloc(klass);
    rb_obj_call_init(obj, argc, argv);

    return obj;
}

a6366 12
static VALUE
proc_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE proc = proc_new(klass);

    rb_obj_call_init(proc, argc, argv);
    return proc;
}

d6972 1
a6972 1
    rb_define_singleton_method(rb_cProc, "new", proc_s_new, -1);
d6984 1
d6989 1
d8882 1
a8882 3
thgroup_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
a8891 1
    rb_obj_call_init(group, argc, argv);
d8938 1
d8989 1
d8995 1
a8995 1
    rb_define_singleton_method(cThGroup, "new", thgroup_s_new, -1);
d8998 1
a8998 1
    rb_define_const(cThGroup, "Default", thgroup_s_new(0, 0, cThGroup));
@


1.206
log
@forgotten MATCH_DATA...
@
text
@d6 1
a6 1
  $Date: 2001/09/20 06:23:49 $
a587 7
#define POP_BLOCK_TAG(tag) do {		\
   if ((tag)->flags & BLOCK_DYNAMIC)	\
       (tag)->flags |= BLOCK_ORPHAN;	\
   else					\
       rb_gc_force_recycle((VALUE)tag); \
} while (0)

d589 4
a592 1
   POP_BLOCK_TAG(_block.tag);		\
d4630 2
a4631 1
	rb_raise(rb_eNotImpError, "method call on terminated object");
a4908 4
    if (file == 0) {
	file = ruby_sourcefile;
	line = ruby_sourceline;
    }
d4932 5
d4946 4
d7525 1
a7525 1
static void
d7530 1
a7530 1
    int i;
d7537 1
d7544 1
d7700 3
a7702 3
		    intersect_fds(&readfds, &th->readfds, max);
		    intersect_fds(&writefds, &th->writefds, max);
		    intersect_fds(&exceptfds, &th->exceptfds, max);
@


1.205
log
@* eval.c, intern.h (rb_svar): return reference to special variable
  from local variable index. [new]

* eval.c (rb_eval): use rb_svar() for NODE_FLIP{2,3}.

* parse.y (rb_(backref|lastline)_(get|set)): access via rb_svar().

* eval.c (proc_invoke): push dynamic variables.

* eval.c (rb_thread_yield): push special variables as dynamic
  variables($_, $~ and FLIP states).


* intern.h, parse.y (rb_is_local_id): return true if the ID is
  local symbol. [new]

* parse.y (internal_id): make new ID for internal use. [new]

* parse.y (cond0): allocate internal ID for NODE_FLIP{2,3}.

* eval.c (rb_f_local_variables): use rb_is_local_id() to select
  visible local variables.


* eval.c (rb_thread_start_0): SCOPE_SHARED is removed.

* eval.c, intern.h (rb_thread_scope_shared_p): removed. special
  variables are no longer shared by threads.

* re.c (rb_reg_search): MATCHDATA is no longer shared by threads.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/09/19 06:54:10 $
d1729 1
a1729 1
#define MATCH_DATA ruby_scope->local_vars[node->nd_cnt]
@


1.204
log
@* string.c (rb_str_init): String.new() => ""

* dir.c (dir_path): new method.

* dir.c (dir_initialize): wrap DIR into struct, along with path
  information.
@
text
@d6 1
a6 1
  $Date: 2001/09/08 14:17:09 $
d724 18
d2557 11
a2567 8
	if (ruby_scope->local_vars == 0) {
	    rb_bug("unexpected local variable");
	}
	if (!RTEST(ruby_scope->local_vars[node->nd_cnt])) {
	    if (RTEST(rb_eval(self, node->nd_beg))) {
		ruby_scope->local_vars[node->nd_cnt] = 
		    RTEST(rb_eval(self, node->nd_end))?Qfalse:Qtrue;
		result = Qtrue;
d2570 4
a2573 1
		result = Qfalse;
a2575 6
	else {
	    if (RTEST(rb_eval(self, node->nd_end))) {
		ruby_scope->local_vars[node->nd_cnt] = Qfalse;
	    }
	    result = Qtrue;
	}
d2579 12
a2590 10
	if (ruby_scope->local_vars == 0) {
	    rb_bug("unexpected local variable");
	}
	if (!RTEST(ruby_scope->local_vars[node->nd_cnt])) {
	    result = RTEST(rb_eval(self, node->nd_beg)) ? Qtrue : Qfalse;
	    ruby_scope->local_vars[node->nd_cnt] = result;
	}
	else {
	    if (RTEST(rb_eval(self, node->nd_end))) {
		ruby_scope->local_vars[node->nd_cnt] = Qfalse;
a2591 1
	    result = Qtrue;
d5874 1
a5874 1
	    if (tbl[i] == 0) continue;  /* skip flip states */
d6436 1
d6448 1
d6474 1
a8278 2
#define SCOPE_SHARED  FL_USER1

a8343 1
    FL_SET(ruby_scope, SCOPE_SHARED);
a8418 6
int
rb_thread_scope_shared_p()
{
    return FL_TEST(ruby_scope, SCOPE_SHARED);
}

d8424 2
d8427 14
@


1.203
log
@* eval.c (rb_thread_restore_context): save current value of
  lastline and lastmatch in the thread struct for later restore.

* eval.c (rb_thread_save_context): restore lastline and lastmatch.

* numeric.c (flo_to_s): should handle negative float value.

* class.c (rb_include_module): should check whole ancestors to
  avoid duplicate module inclusion.

* string.c (trnext): should check backslash before updating "now"
  position.
@
text
@d6 1
a6 1
  $Date: 2001/09/03 05:37:42 $
d8214 1
a8214 1
    th->last_match = 0;\
@


1.202
log
@* ruby.c (proc_options): should not alter origargv[].

* ruby.c (set_arg0): long strings for $0 dumped core.

* ruby.c (set_arg0): use setprogtitle() if it's available.

* io.c (rb_io_popen): accept integer flags as mode.

* file.c (rb_find_file_ext): extension table can be supplied from
  outside.  renamed.

* eval.c (rb_f_require): replace rb_find_file_noext by
  rb_find_file_ext.

* eval.c (rb_provided): should also check feature without
  extension.

* numeric.c (flo_to_s): do not rely on decimal point to be '.'
@
text
@d6 1
a6 1
  $Date: 2001/08/29 06:28:44 $
d7270 1
d7298 6
a7303 2
    th->last_line = rb_lastline_get();
    th->last_match = rb_backref_get();
d7367 1
d7404 1
d7406 2
d7409 1
@


1.201
log
@* parse.y (yylex): ternary ? can be followed by newline.

* eval.c (rb_f_require): should check static linked libraries
  before raising exception.

* array.c (rb_ary_equal): check identiry equality first.

* string.c (rb_str_equal): ditto.

* struct.c (rb_struct_equal): ditto.

* numeric.c (Init_Numeric): undef Integer::new.

* eval.c (rb_eval): NODE_WHILE should update result for each
  conditional evaluation.

* eval.c (rb_eval): NODE_UNTIL should return last evaluated value
  (or value given to break).
@
text
@d6 1
a6 1
  $Date: 2001/08/23 06:02:14 $
d5396 8
d5411 2
a5412 2
	if (rb_find_file_noext(&f) == 0) {
	    return Qfalse;
d5455 5
a5459 5
	    feature = tmp = rb_str_dup(fname);
	    rb_str_cat2(tmp, DLEXT);
	    tmp = rb_find_file(tmp);
	    if (tmp) {
		fname = tmp;
d5462 1
a5462 1
#ifdef DLEXT2
d5492 1
a5492 1
    switch (rb_find_file_noext(&tmp)) {
@


1.200
log
@* eval.c (is_defined): should not dump core for "defined?(())".

* eval.c (umethod_bind): recv can be an instance of descender of
  oklass if oklass is a Module.

* hash.c (rb_hash_equal): check identiry equality first.

* file.c (group_member): should check real gid only.

* file.c (eaccess): do not cache euid, since effective euid may be
  changed via Process.euid=().

* file.c (eaccess): return -1 unless every specified access mode
  is permitted.

* eval.c (rb_eval): while/until returns the value which is given
  to break.

* parse.y (value_expr): using while/until/class/def as an
  expression is now gives a warning, not an error.

* range.c (range_eqq): should compare strings based on magical
  increment (using String#upto), not dictionary order.

* enum.c (enum_sort_by): new method for Schewartzian transformed
  stable sort.

* variable.c (mod_av_set): detect constant overriding for built-in
  classes/modules.
@
text
@d6 1
a6 1
  $Date: 2001/08/14 08:13:26 $
d2283 1
a2283 1
	    } while (RTEST(rb_eval(self, node->nd_cond)));
d2314 1
a2314 1
	    } while (!RTEST(rb_eval(self, node->nd_cond)));
d2332 1
a2332 1
	RETURN(Qnil);
d3979 1
a3979 1
	if (rb_funcall(*argv, eqq, 1, ruby_errinfo)) return 1;
d5497 2
a8333 3
	if (curr_thread == main_thread) {
	    printf("free(%p)\n", saved_block);
	}
@


1.199
log
@* range.c (range_step): new method.

* string.c (rb_str_cmp): remove needless conditional.

* string.c (rb_str_lstrip_bang) `return Qnil' was missing.
@
text
@d6 1
a6 1
  $Date: 2001/08/06 03:05:12 $
d1751 1
d2276 1
a2276 1
	    if (node->nd_state && !RTEST(rb_eval(self, node->nd_cond)))
d2294 1
d2301 1
a2301 1
	RETURN(Qnil);
d2307 1
a2307 1
	    if (node->nd_state && RTEST(rb_eval(self, node->nd_cond)))
d2325 1
d6810 3
a6812 1
	if (!rb_obj_is_instance_of(recv, data->oklass)) {
@


1.198
log
@* string.c (rb_str_lstrip_bang): new method.

* string.c (rb_str_rstrip_bang): new method.

* string.c (rb_str_associate): should consider STR_ASSOC too.

* eval.c (rb_undefined): do not recurse if method_missing is
  undefined.

* process.c (proc_waitpid): now all arguments are optional.

* process.c (Init_process): waitpid is now alias to wait.

* process.c (Init_process): waitpid2 is now alias to wait2.

* process.c (rb_waitpid): made public.

* ext/pty/pty.c (pty_getpty): avoid disturbing SIGCHLD using
  thread and rb_waitpid.

* process.c (proc_getpgrp): now takes no argument on all
  platforms.

* process.c (proc_setpgrp): ditto.

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::pack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::pack_sockaddr_un(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_in): added
  Socket::unpack_sockaddr_in(). [new]

* ext/socket/socket.c (sock_s_pack_sockaddr_un): added
  Socket::unpack_sockaddr_un(). [new]
@
text
@d5 2
a6 2
  $Author: usa $
  $Date: 2001/08/01 06:45:13 $
d7197 3
@


1.197
log
@* eval.c (ruby_run): avoid VC++ warning.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/07/27 09:12:12 $
d4216 8
a4226 2

    last_call_status = call_status;
@


1.196
log
@* eval.c (rb_provided): extension should be guessed using
  rb_find_file_noext().

* eval.c (rb_f_require): should call rb_feature_p() after
  extension completion.

* eval.c (rb_eval): add CHECK_INTS before next, redo, retry to
  avoid potential uninterruptable infinite loop.

* file.c (rb_file_s_expand_path): use CharNext() to expand.
@
text
@d6 1
a6 1
  $Date: 2001/07/24 09:07:33 $
d1196 1
a1196 1
    Init_stack(&tmp);
@


1.195
log
@* eval.c (rb_provide_feature): should not tweak extension used for
  loading.

* io.c (io_fread): use fread(3) if PENDING_COUND is available.

* class.c (rb_mod_include_p): Module#include? added. [new]

* re.c (ignorecase_setter): give warning on modifying $=.

* string.c (rb_str_casecmp): new method. [new]

* string.c (rb_str_eql): separated from rb_str_equal(), make it
  always be case sensitive. [new]

* string.c (rb_str_hash): made it always be case sensitive.

* eval.c (rb_f_require): should not include path in $" value

* file.c (rb_find_file): should return 0 explicitly on failure.
@
text
@d6 1
a6 1
  $Date: 2001/07/18 05:55:20 $
d2401 1
d2412 1
d2417 1
d5391 8
a5398 1
    return rb_feature_p(feature, Qfalse);
a5425 2
    if (rb_feature_p(RSTRING(fname)->ptr, Qtrue))
	return Qfalse;
d5491 2
d5513 2
@


1.194
log
@* regex.c (NUM_FAILURE_ITEMS): was confusing NUM_REG_ITEMS and
  NUM_NONREG_ITEMS, which have happened to be same value.

* class.c (rb_class_new): subclass check moved to this function.

* class.c (rb_class_boot): check less version of rb_class_new().

* eval.c (proc_invoke): should preserve iter status for embedded
  frame in the block.

* file.c (rb_file_s_expand_path): may overrun buffer on stack.

* string.c (rb_str_insert): forgot to call rb_str_modify().
@
text
@d6 1
a6 1
  $Date: 2001/07/14 15:17:18 $
a5394 13
    char *ext;
    char *f = RSTRING(feature)->ptr;

    ext = strrchr(f, '.');
    if (ext && (strcmp(DLEXT, ext) == 0
#ifdef DLEXT2
	     || strcmp(DLEXT2, ext) == 0
#endif
	)) {
	feature = rb_str_new(RSTRING(feature)->ptr, ext-RSTRING(feature)->ptr);
	rb_str_cat2(feature, ".so");
    }
    if (rb_feature_p(RSTRING(feature)->ptr, Qtrue)) return;
d5430 1
a5430 1
	    tmp = rb_str_dup(fname);
d5434 1
a5434 1
		feature = fname = tmp;
d5438 1
a5438 1
	    tmp = rb_str_dup(fname);
d5442 1
a5442 1
		feature = fname = tmp;
d5450 2
a5451 1
		feature = fname = tmp;
d5459 2
a5460 1
		feature = fname = tmp;
d5472 1
a5472 2
	feature = fname;
	fname = tmp;
d5476 1
a5476 1
	feature = fname;
d5480 1
a5480 2
    rb_raise(rb_eLoadError, "No such file to load -- %s",
	     RSTRING(fname)->ptr);
@


1.193
log
@* regex.c (re_search): should consider reverse search.

* dir.c (dir_s_chdir): warn only when invoked from multiple
  threads or block is not given.

* object.c (rb_convert_type): should use rb_rescue(), not rb_rescue2().

* range.c (range_init): ditto.

* object.c (rb_obj_dup): should free generic_ivar if original owns
  them.

* string.c (rb_str_each_line): should propagate taint mark.

* ext/nkf/nkf.c (rb_nkf_kconv): ditto.

* eval.c (rb_f_require): revamp for simpler implementation.

* file.c (rb_find_file_noext): use String object, instead of
  passing char* around.

* file.c (rb_find_file): ditto.

* dln.c (dln_load): should use NSLINKMODULE_OPTION_BINDNOW.

* ruby.c (load_file): local variables 'c' remain uninitialized on
  xflag.

* regex.c (re_match): prefetched escaped character too early.

* eval.c (rb_call0): add argument check for attr_readers.
@
text
@d6 1
a6 1
  $Date: 2001/07/03 09:37:08 $
d3593 2
a3594 1
    if (ruby_frame->iter) return Qtrue;
d3607 2
a3608 1
    if (ruby_frame->prev && ruby_frame->prev->iter) return Qtrue;
d3627 1
a3627 1
    if (!(rb_block_given_p() || rb_f_block_given_p()) || !ruby_block) {
a6413 1
    ruby_block->frame.iter = ITER_NOT;
@


1.192
log
@* eval.c (rb_eval_string_wrap): should push frame (and adjust
  cbase) before wrapped eval.

* eval.c (rb_eval_cmd): ditto.

* eval.c (eval): should update ruby_class always after all.
@
text
@d5 2
a6 2
  $Author: shugo $
  $Date: 2001/07/03 05:57:16 $
d2587 1
a2587 1
	result = rb_ary_push(rb_obj_dup(rb_eval(self, node->nd_head)),
d4424 6
a4431 3
	/* for attr get/set */
      case NODE_ATTRSET:
      case NODE_IVAR:
d5223 1
a5224 1
    char *file;
d5237 2
a5238 2
    file = rb_find_file(RSTRING(fname)->ptr);
    if (!file) {
d5241 1
d5276 1
a5276 1
	rb_load_file(file);
d5389 3
a5391 3
void
rb_provide(feature)
    const char *feature;
d5393 2
a5394 1
    char *buf, *ext;
d5396 1
a5396 1
    ext = strrchr(feature, '.');
d5402 2
a5403 5
	buf = ALLOCA_N(char, strlen(feature)+4);
	strcpy(buf, feature);
	ext = strrchr(buf, '.');
	strcpy(ext, ".so");
	feature = buf;
d5405 9
a5413 2
    if (rb_feature_p(feature, Qtrue)) return;
    rb_ary_push(rb_features, rb_str_new2(feature));
d5420 2
a5421 1
    char *ext, *file, *feature, *buf; /* OK */
a5430 1
	feature = file = RSTRING(fname)->ptr;
d5432 6
a5437 2
	    file = rb_find_file(file);
	    if (file) goto load_rb;
d5440 7
a5446 6
	    if (strcmp(ext, DLEXT) != 0) {
		buf = ALLOCA_N(char, strlen(file)+sizeof(DLEXT)+4);
		strcpy(buf, feature);
		ext = strrchr(buf, '.');
		strcpy(ext, DLEXT);
		file = feature = buf;
a5447 2
	    file = rb_find_file(file);
	    if (file) goto load_dyna;
d5449 6
a5454 7
	    file = feature = RSTRING(fname)->ptr;
	    if (strcmp(ext, DLEXT2) != 0) {
		buf = ALLOCA_N(char, strlen(file)+sizeof(DLEXT2)+4);
		strcpy(buf, feature);
		ext = strrchr(buf, '.');
		strcpy(ext, DLEXT2);
		file = feature = buf;
a5455 2
	    file = rb_find_file(file);
	    if (file) goto load_dyna;
d5459 5
a5463 3
	    feature = RSTRING(fname)->ptr;
	    file = rb_find_file(feature);
	    if (file) goto load_dyna;
d5467 5
a5471 3
	    feature = RSTRING(fname)->ptr;
	    file = rb_find_file(feature);
	    if (file) goto load_dyna;
d5475 2
a5476 3
    buf = ALLOCA_N(char, strlen(RSTRING(fname)->ptr) + 5);
    strcpy(buf, RSTRING(fname)->ptr);
    switch (rb_find_file_noext(buf)) {
d5481 2
a5482 2
	fname = rb_str_new2(buf);
	file = feature = buf;
d5486 2
a5487 2
	feature = buf;
	file = rb_find_file(buf);
d5494 1
a5494 1
    rb_provide(feature);
d5503 1
a5503 3
	    load = rb_str_new2(file);
	    file = RSTRING(load)->ptr;
	    handle = dln_load(file);
d5515 1
a5515 1
    rb_provide(feature);
d5521 2
a5522 1
    st_insert(loading_tbl, strdup(feature), curr_thread);
d5529 2
a5530 2
    st_delete(loading_tbl, &feature, 0); /* loading done */
    free(feature);
@


1.191
log
@* eval.c (block_pass): do not change wrapper information.
* eval.c (rb_yield_0):  preserve wrapper information.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/07/02 08:46:21 $
d1278 6
a1283 1
    rb_extend_object(ruby_top_self, ruby_class);
d1288 1
a1341 2
    PUSH_CLASS();
    PUSH_TAG(PROT_NONE);
d1344 5
a1349 1
    ruby_class = ruby_wrapper ? ruby_wrapper : rb_cObject;
d1354 1
d1364 1
a1364 1
    POP_CLASS();
a4879 1
    PUSH_CLASS();
a4905 1
	ruby_class = ruby_cbase;
d4912 2
@


1.190
log
@* error.c (exc_exception): clone the receiver exception instead of
  creating brand new exception object of the receiver.

* eval.c (rb_eval_string_wrap): extend new ruby_top_self, not
  original self.

* eval.c (rb_eval_cmd): respect ruby_wrapper if set.

* eval.c (eval): do not update ruby_class unless scope is not
  provided.

* eval.c (eval): preserve wrapper information.

* eval.c (proc_invoke): ditto.

* eval.c (block_pass): ditto.

* parse.y (void_expr): too much warnings for void context
  (e.g. foo[1] that can be mere Proc call).

* error.c (rb_name_error): new function to raise NameError with
  name attribute set.

* eval.c (rb_f_missing): set name and args in the exception
  object. [new]

* error.c (name_name): NameError#name - new method.

* error.c (nometh_args): NoMethodError#args - new method.

* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.

* dir.c (isdelim): space, tab, and newline are no longer
  delimiters for glob patterns.

* eval.c (svalue_to_avalue): new conversion scheme between single
  value and array values.

* eval.c (avalue_to_svalue): ditto.

* eval.c (rb_eval): REXPAND now uses avalue_to_svalue(), return
  and yield too.

* eval.c (rb_yield_0): use avalue_to_svalue().

* eval.c (proc_invoke): Proc#call gives avaules, whereas
  Proc#yield gives mvalues.

* eval.c (bmcall): convert given value (svalue) to avalue.
@
text
@d6 1
a6 1
  $Date: 2001/06/23 15:14:14 $
d585 1
d3609 1
d3628 2
d3733 1
a6522 1
    volatile VALUE old_wrapper = ruby_wrapper;
a6537 2
    ruby_wrapper = data->wrapper;

a6574 1
    ruby_wrapper = old_wrapper;
@


1.189
log
@* eval.c (svalue_to_avalue): new conversion scheme between single
  value and array values.

* eval.c (avalue_to_svalue): ditto.

* eval.c (rb_eval): REXPAND now uses avalue_to_svalue(), return
  and yield too.

* eval.c (rb_yield_0): use avalue_to_svalue().

* eval.c (proc_invoke): Proc#call gives avaules, whereas
  Proc#yield gives mvalues.

* eval.c (bmcall): convert given value (svalue) to avalue.
@
text
@d6 1
a6 1
  $Date: 2001/06/22 09:12:19 $
d171 4
a174 4
    rb_raise(rb_eNameError, "undefined method `%s' for %s `%s'",
	     rb_id2name(id), 
	     (TYPE(klass) == T_MODULE)?"module":"class",
	     rb_class2name(klass));
d318 2
a319 2
	rb_raise(rb_eNameError, "method `%s' not defined in %s",
		 rb_id2name(mid), rb_class2name(klass));
d549 1
d1277 1
a1277 1
    rb_extend_object(self, ruby_class);
d1340 1
a1340 1
    ruby_class = rb_cObject;
d1549 2
a1550 2
	rb_raise(rb_eNameError, "undefined method `%s' for%s `%s'",
		 rb_id2name(id),s0,rb_class2name(c));
d2382 1
a2382 1
 	    return_value(rb_eval(self, node->nd_stts));
d2392 1
a2392 1
 	    return_value(rb_eval(self, node->nd_stts));
d2620 3
a2622 2
		rb_raise(rb_eNameError, "superclass method `%s' disabled",
			 rb_id2name(ruby_frame->last_func));
a4123 1
    argc--; argv++;
d4171 11
a4181 3
    rb_raise(exc, format, rb_id2name(id),
	     desc, desc[0]=='#'?"":":",
	     desc[0]=='#'?"":rb_class2name(CLASS_OF(obj)));
d4207 1
a4207 1
static int STACK_LEVEL_MAX = 65535;
d4210 1
a4210 1
extern int _stacksize;
d4215 1
a4215 1
static int STACK_LEVEL_MAX = 655300;
d4598 2
a4599 2
	    rb_raise(rb_eNameError, "super: no superclass method `%s'",
		     rb_id2name(mid));
d4724 2
a4725 2
	rb_raise(rb_eNameError, "superclass method `%s' must be enabled by rb_enable_super()",
		 rb_id2name(ruby_frame->last_func));
d4855 1
d4866 1
d4888 2
d4893 1
a4899 2
    PUSH_CLASS();
    ruby_class = ruby_cbase;
d4924 1
d6095 1
d6211 1
d6301 1
d6371 1
d6382 1
d6408 1
d6518 1
d6534 2
d6573 1
d9015 1
a9015 1
	rb_raise(rb_eNameError, "uncaught throw `%s'", rb_id2name(t));
@


1.188
log
@* eval.c (rb_yield_0): no mvalue_to_svalue conversion here.

* eval.c (massign): takes svalue, convert it to mvalue inside.

* eval.c (rb_eval): parameters for yield/return are always
  svalues now.

* eval.c (svalue_to_mvalue): more strict conversion.

* eval.c (mvalue_to_svalue): ditto.

* st.c (new_size): prime hash size enabled.

* ext/socket/socket.c (Init_socket): SO_* constants added.
@
text
@d6 1
a6 1
  $Date: 2001/06/19 07:33:08 $
d2004 1
a2004 1
svalue_to_mvalue(v)
d2019 30
d2058 1
a2058 1
    if (RARRAY(v)->len == 1) {
d2412 2
a2413 6
      case NODE_SVALUE:
	result = mvalue_to_svalue(rb_eval(self, node->nd_head));
	break;

      case NODE_MVALUE:
	result = svalue_to_mvalue(rb_eval(self, node->nd_head));
d2418 1
a2418 1
	    result = mvalue_to_svalue(rb_eval(self, node->nd_stts));
d2561 1
a2561 1
 	    return_value(mvalue_to_svalue(rb_eval(self, node->nd_stts)));
d3659 1
d3667 3
d3771 3
a3773 1
    val = svalue_to_mvalue(val);
d6374 3
a6376 1
    args = mvalue_to_svalue(args);
d6848 1
a6848 1
    args = svalue_to_mvalue(args);
@


1.187
log
@* eval.c (svalue_to_mvalue): new function to convert from svalue
  to mvalue. [experimental]

* eval.c (mvalue_to_svalue): new function to convert from mvalue
  to svalue.

* eval.c (rb_eval): use mvalue_to_svalue().

* eval.c (rb_yield_0): use mvalue_to_svalue().

* eval.c (proc_invoke): proper mvalue handling.
@
text
@d6 1
a6 1
  $Date: 2001/06/19 04:35:13 $
d2008 5
a2012 1
    if (TYPE(v) != T_ARRAY) {
d2028 1
a2028 3
    if (RARRAY(v)->len == 1 &&
	!NIL_P(RARRAY(v)->ptr[0]) &&
	TYPE(RARRAY(v)->ptr[0]) != T_ARRAY) {
d2379 1
a2379 1
	result = svalue_to_mvalue(rb_eval(self, node->nd_head));
d2382 1
a2382 1
      case NODE_REXPAND:
d2386 4
d2392 1
a2392 1
	    result = rb_eval(self, node->nd_stts);
d2535 1
a2535 1
 	    return_value(rb_eval(self, node->nd_stts));
d2546 1
a2546 1
			       svalue_to_mvalue(rb_eval(self, node->nd_body)));
d3629 1
a3629 1
		if (nd_type(block->var) == NODE_MASGN)
d3631 1
a3632 9
		    /* argument adjust for proc_call etc. */
		    if (pcall) {
			if (RARRAY(val)->len == 1) {
			    val = RARRAY(val)->ptr[0];
			}
			else {
			    val = mvalue_to_svalue(val);
			}
		    }
a3639 4
    else if (pcall) {
	/* argument adjust for proc_call etc. */
	val = mvalue_to_svalue(val);
    }
d3741 1
a3741 3
    if (!pcall) {
	val = svalue_to_mvalue(val);
    }
d6342 1
a6342 3
    if (!pcall) {
	args = mvalue_to_svalue(args);
    }
d6814 2
a6815 4
    if (TYPE(args) == T_ARRAY) {
	return method_call(RARRAY(args)->len, RARRAY(args)->ptr, method);
    }
    return method_call(1, &args, method);
d6822 1
a6822 4
    if (TYPE(args) == T_ARRAY) {
	return umethod_call(RARRAY(args)->len, RARRAY(args)->ptr, method);
    }
    return umethod_call(1, &args, method);
@


1.186
log
@* eval.c (rb_f_require): searches ".rb" and ".so" at the same
  time.  previous behavior (search ".rb", then ".so") has a
  security risk (ruby-bugs#PR140).

* array.c (rb_ary_to_ary): new function to replace internal
  rb_Array(), which never calls to_a, but to_ary (rb_Array() might
  call both). [new]

* regex.c (PUSH_FAILURE_POINT): push option status again.

* regex.c (re_compile_pattern): avoid pushing unnecessary
  option_set.

* eval.c (rb_load): tainted string is OK if wrapped *and*
  $SAFE >= 4.

* eval.c (rb_thread_start_0): should not nail down higher blocks
  before preserving original context (i.e. should not alter
  original context).

* eval.c (proc_yield): new method equivalent to Proc#call but no
  check for number of arguments. [new]
@
text
@d6 1
a6 1
  $Date: 2001/06/12 05:31:46 $
d2003 29
d2377 1
a2377 4
	result = rb_eval(self, node->nd_head);
	if (TYPE(result) != T_ARRAY) {
	    result = rb_ary_to_ary(result);
	}
d2381 1
a2381 10
	result = rb_eval(self, node->nd_head);
	if (TYPE(result) != T_ARRAY) {
	    result = rb_ary_to_ary(result);
	}
	if (RARRAY(result)->len == 0) {
	    result = Qnil;
	}
	else if (RARRAY(result)->len == 1) {
	    result = RARRAY(result)->ptr[0];
	}
d2540 1
a2540 1
			       rb_ary_to_ary(rb_eval(self, node->nd_body)));
a3565 4
#define PC_NONE   0x0
#define PC_ACHECK 0x1
#define PC_PCALL  0x2

d3611 1
a3611 2
		if ((pcall&PC_ACHECK) && val != Qundef &&
		    TYPE(val) == T_ARRAY && RARRAY(val)->len != 0) {
d3617 1
a3617 1
		if (val != Qundef && TYPE(val) == T_ARRAY && RARRAY(val)->len != 0) {
d3624 1
a3624 1
		    massign(self, block->var, val, (pcall&PC_ACHECK));
d3627 7
a3633 3
		    if (pcall && val != Qundef && 
			TYPE(val) == T_ARRAY && RARRAY(val)->len == 1) {
			val = RARRAY(val)->ptr[0];
d3635 1
a3635 1
		    assign(self, block->var, val, (pcall&PC_ACHECK));
d3642 1
a3642 1
    else {
d3644 1
a3644 4
	if (pcall && val != Qundef &&
	    TYPE(val) == T_ARRAY && RARRAY(val)->len == 1) {
	    val = RARRAY(val)->ptr[0];
	}
a3654 1
	    if (val == Qundef) val = rb_ary_new2(0);
d3738 1
a3738 1
massign(self, node, val, check)
d3742 1
a3742 1
    int check;
d3747 2
a3748 15
    if (val == Qundef || val == Qnil) {
	val = rb_ary_new2(0);
    }
    else if (TYPE(val) != T_ARRAY) {
	if (rb_respond_to(val, to_ary)) {
	    VALUE ary = rb_funcall(val, to_ary, 0);
	    if (TYPE(ary) != T_ARRAY) {
		rb_raise(rb_eTypeError, "%s#to_ary should return Array",
			 rb_class2name(CLASS_OF(val)));
	    }
	    val = ary;
	}
	else {
	    val = rb_ary_new3(1, val);
	}
d3753 1
a3753 1
	assign(self, list->nd_head, RARRAY(val)->ptr[i], check);
d3756 1
a3756 1
    if (check && list) goto arg_error;
d3762 1
a3762 1
	    assign(self, node->nd_args, rb_ary_new4(len-i, RARRAY(val)->ptr+i), check);
d3765 1
a3765 1
	    assign(self, node->nd_args, rb_ary_new2(0), check);
d3768 1
a3768 1
    else if (check && i < len) {
d3774 1
a3774 1
	assign(self, list->nd_head, Qnil, check);
d3788 1
a3788 1
assign(self, lhs, val, check)
d3792 1
a3792 1
    int check;
d3834 1
a3834 1
	massign(self, lhs, val, check);
d5844 1
a5844 1
    proc_call(data, Qundef);
a6319 13
callargs(args)
    VALUE args;
{
    switch (RARRAY(args)->len) {
      case 0:
	return Qundef;
	break;
      default:
	return args;
    }
}

static VALUE
a6331 7
    if (pcall) {
	pcall = PC_ACHECK|PC_PCALL;
    }
    else {
	pcall = PC_PCALL;
    }

d6350 2
a6351 2
    if (args != Qundef && TYPE(args) == T_ARRAY) {
	args = callargs(args);
a6352 1

d8318 1
a8318 1
    return rb_yield_0(callargs(arg), 0, 0, Qtrue);
@


1.185
log
@* eval.c (method_eq): new method Method#==. [new]

* gc.c (STR_NO_ORIG): STR_NO_ORIG value was different between
  string.c and gc.c

* eval.c (rb_eval): should convert *non-array at the end of
  arguments by using Array().

* hash.c (ruby_setenv): readline library leaves their environment
  strings uncopied.  "free" check revised.
@
text
@d6 1
a6 1
  $Date: 2001/06/08 14:20:19 $
d1679 1
a1679 1
	    args = rb_Array(args);\
d2132 1
a2132 1
		    if (TYPE(v) != T_ARRAY) v = rb_Array(v);
d2177 1
a2177 1
			if (TYPE(v) != T_ARRAY) v = rb_Array(v);
d2350 1
a2350 1
	    result = rb_Array(result);
d2357 1
a2357 1
	    result = rb_Array(result);
d2523 1
a2523 1
			       rb_Array(rb_eval(self, node->nd_body)));
d3549 4
d3554 1
a3554 1
rb_yield_0(val, self, klass, acheck)
d3556 1
a3556 1
    int acheck;
d3561 2
a3562 2
    struct BLOCK *block;
    struct SCOPE *old_scope;
d3598 1
a3598 1
		if (acheck && val != Qundef &&
d3612 1
a3612 1
		    massign(self, block->var, val, acheck);
d3615 1
a3615 1
		    if (acheck && val != Qundef && 
d3619 1
a3619 1
		    assign(self, block->var, val, acheck);
d3628 1
a3628 1
	if (acheck && val != Qundef &&
d5178 6
a5183 1
    SafeStringValue(fname);
d5414 5
a5418 2
    strcat(buf, ".rb");
    if (rb_find_file(buf)) {
d5420 1
a5420 1
	feature = buf;
d5422 2
a5423 5
    }
    strcpy(buf, RSTRING(fname)->ptr);
    strcat(buf, DLEXT);
    file = rb_find_file(buf);
    if (file) {
d5425 1
a5427 9
#ifdef DLEXT2
    strcpy(buf, RSTRING(fname)->ptr);
    strcat(buf, DLEXT2);
    file = rb_find_file(buf);
    if (file) {
	feature = buf;
	goto load_dyna;
    }
#endif
d6334 1
a6334 1
proc_call(proc, args)
d6336 1
d6346 7
d6379 1
a6379 1
	result = rb_yield_0(args, 0, 0, Qtrue);
d6411 14
d6925 1
d8237 5
a8241 1
    if (ruby_block) {		/* should nail down higher scopes */
a8249 3
    if (THREAD_SAVE_CONTEXT(curr_thread)) {
	return thread;
    }
d8271 3
d8277 3
a8285 2
    if (th == main_thread) ruby_stop(state);
    rb_thread_remove(th);
@


1.184
log
@* gc.c (Init_stack): avoid __builtin_frame_address(2) to retrieve
  stack bottom line.

* st.c (numhash): should shuffle bits by dividing by prime number.

* eval.c (rb_eval): multiple assignment behavior fixed, which
  results "*a = nil" makes "a == []" now.

* eval.c (rb_f_require): should set SCOPE_PUBLIC before calling
  dln_load().
@
text
@d6 1
a6 1
  $Date: 2001/06/06 07:40:31 $
d2523 1
a2523 1
			       rb_eval(self, node->nd_body));
d6602 21
d6632 1
a6632 1
    data->recv = obj;
d6673 1
a6673 1
    clone = Data_Make_Struct(CLASS_OF(self),struct METHOD,bm_mark,free,data);
d6733 1
a6733 1
	    rb_raise(rb_eTypeError, "first argument must be an instance of %s",
d6915 1
@


1.183
log
@* eval.c (rb_load): should check if tainted even when wrap is
  specified.

* regex.c (re_compile_pattern): too much optimization for the
  cases like /(.|a)b/.
@
text
@d6 1
a6 1
  $Date: 2001/06/05 07:19:38 $
d2347 1
d2359 4
a2362 1
	if (RARRAY(result)->len == 1) {
d3731 1
a3731 1
    if (val == Qundef) {
d5432 2
d5435 3
a5437 3
    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	void *handle;
d5439 8
a5446 4
	load = rb_str_new2(file);
	file = RSTRING(load)->ptr;
	handle = dln_load(file);
	rb_ary_push(ruby_dln_librefs, INT2NUM((long)handle));
a5447 1
    POP_TAG();
@


1.182
log
@* variable.c (rb_mod_const_at): use hash table as internal
  data. [new]

* variable.c (rb_mod_const_of): ditto.

* variable.c (rb_const_list): new function to convert internal
  data (hash table) to array of strings.

* eval.c (rb_mod_s_constants): data handling scheme has changed.

* eval.c (rb_add_method): should not call rb_secure(), for
  last_func may not be set.

* io.c (rb_io_ctl): ioctl should accept any integer within C long
  range.

* marshal.c (r_object): wrong type check for modules.

* marshal.c (w_object): should not dump anonymous classes/modules.

* io.c (rb_open_file): use rb_file_sysopen_internal() if the 3rd
  argument (permission flags) is given. [new, should be backported?]

* io.c (rb_io_mode_binmode): mode string (e.g. "r+") to flags to
  open(2).

* eval.c (rb_eval): NODE_REXPAND expand an array of 1 element as
  the element itself. [new, should be backported?]

* parse.y (ret_args): should treat "*[a]" in rhs expression as
  "a", not "[a]".

* regex.c (re_compile_pattern): should push option modifier at the
  right place.
@
text
@d6 1
a6 1
  $Date: 2001/05/30 09:12:33 $
d5170 1
a5170 6
    if (wrap) {
	StringValue(fname);
    }
    else {
	SafeStringValue(fname);
    }
@


1.181
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d6 1
a6 1
  $Date: 2001/05/24 06:10:32 $
d231 1
a231 4
    if (klass == rb_cObject) {
	rb_secure(4);
    }
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(klass)) {
d1474 1
a1474 1
    VALUE ary = rb_ary_new();
d1477 3
a1479 1
	if (!NIL_P(cbase->nd_clss)) rb_mod_const_at(cbase->nd_clss, ary);
d1483 4
a1486 2
    if (!NIL_P(ruby_cbase)) rb_mod_const_of(ruby_cbase, ary);
    return ary;
d2353 10
a2365 3
	    if (nd_type(node->nd_stts) == NODE_RESTARGS && RARRAY(result)->len == 1) {
		result = RARRAY(result)->ptr[0];
	    }
d8613 22
d8856 1
@


1.180
log
@* eval.c (rb_yield_0): need argument adjustment for C defined
  blocks too.
@
text
@d6 1
a6 1
  $Date: 2001/05/22 08:28:11 $
d18 1
d1217 1
a1217 1
    str = rb_str_new2("compile error");
d1219 2
a1220 2
	rb_str_cat2(str, " in ");
	rb_str_cat2(str, at);
d1222 1
a1222 1
    rb_str_cat(str, "\n", 1);
d1224 1
a1224 1
	rb_str_concat(str, ruby_errinfo);
d2355 1
a2355 3
	    if (nd_type(node->nd_stts) == NODE_RESTARGS &&
		RARRAY(result)->len == 1)
	    {
d6754 1
a6754 1
    str = rb_str_new2("#<");
d6756 2
a6757 2
    rb_str_cat2(str, s);
    rb_str_cat2(str, ": ");
d6759 2
a6760 2
    rb_str_cat2(str, s);
    rb_str_cat2(str, "(");
d6762 2
a6763 2
    rb_str_cat2(str, s);
    rb_str_cat2(str, ")#");
d6765 2
a6766 2
    rb_str_cat2(str, s);
    rb_str_cat2(str, ">");
@


1.179
log
@* variable.c (rb_alias_variable): should not allow variable
  aliasing if $SAFE >= 4.

* parse.y (expr): "break" and "next" to take optional expression,
  which is used as a value for termination. [new, experimental]

* eval.c (rb_eval): "break" can give value to terminating method.

* eval.c (rb_eval): "break" and "next" to take optional expression.

* eval.c (rb_yield_0): "next" can give value to terminating "yield".

* eval.c (rb_iterate): "break" can give value to terminating method.

* eval.c (proc_call): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/05/17 08:49:44 $
d3610 7
@


1.178
log
@* eval.c (rb_call0): address of local_vars might change during eval.
@
text
@d6 1
a6 1
  $Date: 2001/05/16 09:05:49 $
d2291 1
a2291 1
		if (state == TAG_RETURN) {
a2304 1
		result = Qnil;
d2306 1
d2317 6
d2327 6
d3589 6
d3635 1
a3635 1
	    result = Qnil;
d3863 1
a3863 1
	if (state == TAG_RETURN) {
a3878 1
	retval = Qnil;
d6363 12
a6374 14
    if (state) {
	switch (state) {
	  case TAG_BREAK:
	    break;
	  case TAG_RETRY:
	    rb_raise(rb_eLocalJumpError, "retry from proc-closure");
	    break;
	  case TAG_RETURN:
	    if (orphan) {	/* orphan procedure */
		rb_raise(rb_eLocalJumpError, "return from proc-closure");
	    }
	    /* fall through */
	  default:
	    JUMP_TAG(state);
d6376 3
d6394 1
@


1.177
log
@* array.c (rb_ary_and): should not push frozen key string.

* array.c (rb_ary_or): ditto.

* eval.c (rb_thread_schedule): should save context before raising
  deadlock, saved context for current thread might be obsolete.

* time.c (make_time_t): non DST timezone shift supported (hopefully).

* time.c (make_time_t): strict range detection for negative time_t.

* signal.c: SIGINFO added.

* eval.c (rb_ensure): should not SEGV when prot_tag is NULL.
@
text
@d6 1
a6 1
  $Date: 2001/05/11 05:24:54 $
d4438 1
d4440 2
d4443 1
a4443 1
				local_vars[node->nd_rest]=rb_ary_new4(argc,argv);
d4445 2
a4446 1
				local_vars[node->nd_rest]=rb_ary_new2(0);
@


1.176
log
@* bignum.c (bigdivrem): access boundary bug.

* marshal.c (w_object): prohibit dumping out singleton classes.

* object.c (rb_mod_to_s): distinguish singleton classes.

* variable.c (rb_class2name): it's ok to reveal NilClass,
  TrueClass, FalseClass.

* eval.c (rb_yield_0): preserve and restore ruby_cref as well.

* eval.c (is_defined): core dumped during instance_eval for
  special constants.

* eval.c (rb_eval): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/05/07 09:26:23 $
d4007 1
a4007 1
    retval = prot_tag->retval;	/* save retval */
d4009 1
a4009 1
    return_value(retval);
d7554 1
d8342 3
d8347 9
@


1.175
log
@* parse.y (arg): "||=" should not warn for uninitialized instance
  variables.

* eval.c (rb_eval): ditto.

* eval.c (eval): preserve and restore ruby_cref as well.
@
text
@d6 1
a6 1
  $Date: 2001/05/06 15:01:58 $
d176 2
d324 7
d447 2
a448 2
static ID init, eqq, each, aref, aset, match, to_ary;
static ID missing, added, singleton_added;
d1551 7
d1601 7
d1834 6
d2757 4
a3057 1
	rb_funcall(ruby_class, added, 1, ID2SYM(node->nd_mid));
d3533 1
d3550 2
d3650 1
d4915 6
a4927 6
    if (ruby_safe_level >= 4) {
	StringValue(src);
    }
    else {
	SafeStringValue(src);
    }
d5245 1
a5245 1
    VALUE *p, *pend;
d5247 1
a5247 1
    int len;
d5249 2
a5250 4
    p = RARRAY(rb_features)->ptr;
    pend = p + RARRAY(rb_features)->len;
    while (p < pend) {
	VALUE v = *p;
a5254 1
	len = strlen(feature);
a5263 1
	p++;
a5585 7
rb_mod_included(module, include)
    VALUE module, include;
{
    return Qnil;
}

static VALUE
d5869 4
a5915 1
    rb_define_private_method(rb_cModule, "included", rb_mod_included, 1);
d6412 1
a6412 1
    str = rb_str_new(0, strlen(cname)+6+16+1); /* 6:tags 16:addr 1:eos */
@


1.174
log
@forgot some checkins.
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:22:10 $
d1850 1
a1850 1
	if (rb_reg_nth_defined(node->nd_nth, MATCH_DATA)) {
d1857 1
a1857 1
	if (rb_reg_nth_defined(0, MATCH_DATA)) {
d2640 6
a2645 4
	result = rb_eval(self, node->nd_head);
	if (RTEST(result)) break;
	node = node->nd_value;
	goto again;
d4742 1
d4773 2
d4810 1
a5031 1
	VALUE src = argv[0];
d5038 1
a5038 1
		StringValue(src);
d5041 1
a5041 1
		SafeStringValue(src);
d5049 1
a5049 2
		src = argv[1];
		file = StringValuePtr(src);
@


1.173
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d6 1
a6 1
  $Date: 2001/03/28 08:43:24 $
d3932 1
a3932 1
    VALUE (*proc)();
d5734 1
a5734 1
    void (*func)();
d5765 2
d5809 1
a5809 1
	rb_protect((VALUE(*)())link->func, link->data, &status);
d5818 1
a5818 1
	rb_protect((VALUE(*)())link->func, link->data, &status);
@


1.172
log
@* object.c (rb_str2cstr): warn if string contains \0 and length
  value is ignored.

* class.c (rb_singleton_class_clone): should copy class constant
  table as well.

* class.c (rb_include_module): sometimes cache was mistakenly left
  uncleared - based on the patch by K.Kosako.

* ruby.h: all Check_SafeStr()'s are replaced by SafeStr() to
  ensure 'to_str' be always effective.
@
text
@d6 1
a6 1
  $Date: 2001/03/27 07:09:23 $
d131 2
a132 27
void
rb_set_safe_level(level)
    int level;
{
    if (level > ruby_safe_level) {
	ruby_safe_level = level;
    }
}

static VALUE
safe_getter()
{
    return INT2FIX(ruby_safe_level);
}

static void
safe_setter(val)
    VALUE val;
{
    int level = NUM2INT(val);

    if (level < ruby_safe_level) {
	rb_raise(rb_eSecurityError, "tried to downgrade safe level from %d to %d",
		 ruby_safe_level, level);
    }
    ruby_safe_level = level;
}
a478 2
    sprintf(buf, "%s=", name);
    id = rb_intern(buf);
d480 2
d798 5
d920 3
a922 1
	einfo = str2cstr(rb_obj_as_string(ruby_errinfo), &elen);
d1031 3
a1033 1
	ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,rb_cObject,0,0);
d1263 1
d1275 1
d1457 1
a1457 1
	rb_ary_push(ary, cbase->nd_clss);
d1470 1
a1470 1
	rb_mod_const_at(cbase->nd_clss, ary);
d1474 1
a1474 1
    rb_mod_const_of(ruby_cbase, ary);
d1595 17
d2377 1
d2381 1
d2542 1
d2550 5
a2554 1
	    if (node->nd_rval) ruby_frame->cbase = node->nd_rval;
d2572 2
d2912 1
a2912 1
	    NODE *body;
a2925 5
	    if (node->nd_defn->nd_rval &&
		((NODE*)node->nd_defn->nd_rval)->nd_clss != ruby_class) {
		node->nd_defn->nd_rval =
		    (VALUE)rb_node_newnode(NODE_CREF,ruby_class,0, node->nd_defn->nd_rval);
	    }
d2954 3
a2956 1
	    rb_add_method(ruby_class, node->nd_mid, node->nd_defn, noex);
d2960 1
a2960 1
			      node->nd_mid, node->nd_defn, NOEX_PUBLIC);
d2978 1
a2978 1
	    NODE *body = 0;
a2989 5
	    if (node->nd_defn->nd_rval &&
		((NODE*)node->nd_defn->nd_rval)->nd_clss != ruby_class) {
		node->nd_defn->nd_rval =
		    (VALUE)rb_node_newnode(NODE_CREF,ruby_class,0, node->nd_defn->nd_rval);
	    }
d3000 3
a3002 1
	    rb_add_method(klass, node->nd_mid, node->nd_defn, 
a3199 4
    /* fill c-ref */
    node->nd_clss = module;
    node = node->nd_body;

a3204 1
    if (node->nd_rval) ruby_frame->cbase = node->nd_rval;
d3217 2
d3229 1
d3369 3
d3375 1
a3375 1
		STR2CSTR(ruby_errinfo));
d3855 1
a3855 1
	if (rb_obj_is_kind_of(ruby_errinfo, argv[0])) return 1;
d4009 2
a4010 1
    ID    id;
d4053 1
d4070 1
a4070 1
    rb_raise(rb_eNameError, format, rb_id2name(id),
d4317 1
a4317 1
      default:
d4321 1
d4325 5
a4329 1
	    if (body->nd_rval) ruby_frame->cbase = body->nd_rval;
d4422 1
d4438 1
a4438 1
		    break;
d4446 5
d4874 1
a4874 1
	file = STR2CSTR(vfile);
d4881 1
a4881 1
	src = rb_str_to_str(src);
d4884 1
a4884 1
	SafeStr(src);
d4923 1
d4932 1
d4958 1
a4958 1
	src = rb_str_to_str(src);
d4961 1
a4961 1
	SafeStr(src);
a5007 2
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(self))
	rb_raise(rb_eSecurityError, "Insecure: can't eval");
d5033 1
a5033 1
		src = rb_str_to_str(src);
d5036 1
a5036 1
		SafeStr(src);
d5043 4
a5046 1
	    if (argc > 1) file = STR2CSTR(argv[1]);
d5092 1
d5096 1
a5096 1
	fname = rb_str_to_str(fname);
d5099 1
a5099 1
	SafeStr(fname);
d5110 1
d5121 1
a5128 10
    if (ruby_class == rb_cObject && top_scope->local_tbl) {
	int len = top_scope->local_tbl[0]+1;
	ID *tbl = ALLOC_N(ID, len);
	VALUE *vars = TMP_ALLOC(len);
	*vars++ = 0;
	MEMCPY(tbl, top_scope->local_tbl, ID, len);
	MEMCPY(vars, top_scope->local_vars, VALUE, len-1);
	ruby_scope->local_tbl = tbl;   /* copy toplevel scope */
	ruby_scope->local_vars = vars; /* will not alter toplevel variables */
    }
a5130 1

d5153 1
d5196 1
d5212 2
a5213 1
	f = STR2CSTR(*p);
d5287 1
a5287 1
    SafeStr(fname);
d5365 2
d5369 2
a5370 1
	dln_load(file);
d5550 7
d5584 1
d5881 1
d5947 3
d6018 1
d6030 6
d6359 1
d6361 2
a6362 1
    if (RDATA(other)->dmark != (RUBY_DATA_FUNC)blk_mark) Qfalse;
d6425 2
d6598 2
a6599 2
    if (OBJ_TAINTED(method)) {
	if (ruby_safe_level < 4) ruby_safe_level = 4;
d6883 1
d6927 31
d6983 1
d7101 1
d7192 1
d7409 2
a7410 1
	    } else if (th_delay < delay) {
d7414 3
d7597 8
a7604 1

d8008 1
d8098 1
d8116 5
a8120 1
	blk_copy_prev(ruby_block);
d8147 10
d8168 8
a8175 2
		rb_raise(rb_eSecurityError, "Insecure exit at level %d",
			 ruby_safe_level);
a8176 2
	    /* delegate exception to main_thread */
	    rb_thread_raise(1, &ruby_errinfo, main_thread);
@


1.171
log
@* eval.c (rb_mod_define_method): should have clear method cache.

* eval.c (rb_mod_define_method): should have raised exception for
  type error.

* ruby.h: changed "extern INLINE" to "static inline".
@
text
@d6 1
a6 1
  $Date: 2001/03/26 08:57:09 $
d4094 1
d4861 1
a4861 1
	Check_Type(src, T_STRING);
d4864 1
a4864 1
	Check_SafeStr(src);
d4936 1
a4936 1
	Check_Type(src, T_STRING);
d4939 1
a4939 1
	Check_SafeStr(src);
d5006 1
d5013 1
a5013 1
		Check_Type(argv[0], T_STRING);
d5016 1
a5016 1
		Check_SafeStr(argv[0]);
d5072 1
a5072 1
	Check_Type(fname, T_STRING);
d5075 1
a5075 1
	Check_SafeStr(fname);
d5269 1
a5269 1
    Check_SafeStr(fname);
@


1.170
log
@* eval.c: remove TMP_PROTECT_END to prevent C_ALLOCA crash.

* file.c (rb_file_flock): do not trap EINTR.

* missing/flock.c (flock): returns the value from lockf(2)
  directly.

* eval.c (ev_const_defined): should ignore toplevel cbase (Object).

* eval.c (ev_const_get): ditto.

* ext/md5/md5.h: replace by independent md5 implementation
  contributed by L. Peter Deutsch (thanks).

* ext/md5/md5init.c: adopted to Deutsch's md5 implementation.

* pack.c (pack_unpack): string from P/p should be tainted.

* ext/curses/curses.c: curses on Mac OS X public beta does not
  have _maxx etc.

* marshal.c (w_object): should truncate trailing zero short for
  bignums.

* object.c (sym_intern): new method.
@
text
@d6 1
a6 1
  $Date: 2001/03/22 09:19:57 $
d6733 1
d6743 1
d6746 1
@


1.169
log
@* eval.c (rb_mod_nesting): should not include Object at the
  toplevel.
@
text
@d6 1
a6 1
  $Date: 2001/03/21 03:41:41 $
d1431 1
a1431 1
    while (cbase) {
d1452 1
a1452 1
    while (cbase) {
a1614 6
# define TMP_PROTECT_END do {\
    if (tmp__protect_tmp) {\
	rb_gc_force_recycle((VALUE)tmp__protect_tmp);\
	alloca(0);\
    }\
} while (0)
a1617 1
# define TMP_PROTECT_END
a2485 1
	    TMP_PROTECT_END;
a2498 1
	    TMP_PROTECT_END;
a2530 1
	    TMP_PROTECT_END;
a2591 1
	    TMP_PROTECT_END;
a3234 1
    TMP_PROTECT_END;
a3850 1
    TMP_PROTECT_END;
a4432 1
    TMP_PROTECT_END;
d4853 1
a4853 2
	Check_Type(vfile, T_STRING);
	file = RSTRING(vfile)->ptr;
a5144 1
    TMP_PROTECT_END;
@


1.168
log
@* gc.c (id2ref): sometimes confused symbol and reference.

* dir.c (glob_helper): breaks loop after calling recusive
  glob_helper; all wild cards should be consumed; no need for
  further match.

* dir.c (dir_s_glob): gives warning if no match found.

* object.c (sym_inspect): did allocate extra byte space.

* marshal.c (shortlen): shortlen should return number of bytes
  written.

* eval.c (ev_const_defined): need not to check if cbase->nd_class
  is rb_cObject.

* eval.c (ev_const_get): ditto.

* time.c (time_zone): return "UTC" for UTC time objects.

* eval.c (THREAD_ALLOC): flags should be initialized.

* signal.c (rb_f_kill): should use FIX2INT, not FIX2UINT.
@
text
@d6 1
a6 1
  $Date: 2001/03/19 03:20:20 $
d1470 1
a1470 1
    while (cbase) {
@


1.167
log
@* dir.c (glob_helper): replace lstat() by stat() to follow symlink
  in the case like 'symlink/*'.

* dir.c (glob_helper): gave warning too much.
@
text
@d6 1
a6 1
  $Date: 2001/03/16 08:30:09 $
d1431 1
a1431 1
    while (cbase && cbase->nd_clss != rb_cObject) {
d1452 1
a1452 1
    while (cbase && cbase->nd_clss != rb_cObject) {
d1470 1
a1470 1
    while (cbase && cbase->nd_clss != rb_cObject) {
d1483 1
a1483 1
    while (cbase && cbase->nd_clss != rb_cObject) {
@


1.166
log
@* dir.c (dir_s_chdir): block form of Dir.chdir. (RCR#U016).
@
text
@d6 1
a6 1
  $Date: 2001/03/14 08:38:49 $
d5959 7
a5965 7
	rb_gc_mark(data->scope);
	rb_gc_mark(data->var);
	rb_gc_mark(data->body);
	rb_gc_mark(data->self);
	rb_gc_mark(data->dyna_vars);
	rb_gc_mark(data->klass);
	rb_gc_mark(data->tag);
d6459 1
a6459 1
    rb_gc_mark(data->body);
d6919 2
a6920 2
    rb_gc_mark(th->scope);
    rb_gc_mark(th->dyna_vars);
d7913 1
@


1.165
log
@* eval.c (rb_thread_schedule): raise FATAL just once to
  THREAD_TO_KILL.
@
text
@d6 1
a6 1
  $Date: 2001/03/14 04:44:47 $
a777 1
    _tag.retval = Qnil;			\
d6334 1
a6334 1
    if (RDATA(other)->dmark != blk_mark) Qfalse;
@


1.164
log
@* eval.c (rb_yield_0): 0 (= Qfalse) is a valid value, so that
  default self should be checked by klass == 0.

* bignum.c (rb_cstr2inum): should disallow '++1', '+-1', etc.
@
text
@d6 1
a6 1
  $Date: 2001/03/13 09:00:01 $
d6884 3
a6886 1
#define THREAD_RAISED 0x200
d7038 2
a7039 1
    th->flags = scope_vmode | (rb_trap_immediate<<8);
d7465 5
a7469 2
	/* execute ensure-clause if any */
	rb_thread_restore_context(next, RESTORE_FATAL);
@


1.163
log
@* eval.c (ev_const_defined): add new parameter self for special
  const fallback.

* eval.c (ev_const_get): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/03/13 05:45:08 $
d3533 1
a3533 1
    if (!self) self = block->self;
@


1.162
log
@* io.c (argf_seek_m): wrong calling sequence of rb_io_seek().

* parse.y (cond0): no special treatment of string literal in
  condition.

* math.c: add acos, asin, atan, conh, sinh, tanh and hypot to Math.

* configure.in: check hypot availablility.

* missing/hypot.c: public domain rewrite of hypot.

* parse.y (warn_unless_e_option): warning condition was wrong.

* parse.y (warning_unless_e_option): ditto.

* enum.c (enum_all): new method 'all?', which returns true if
  block returns true for all elements.

* enum.c (enum_any): new method 'any?', which returns true if
  block retruns true for any of elements.

* marshal.c (marshal_load): do not give warning unless explicitly
  set to verbose.

* eval.c (rb_exit): give string value "exit" to SystemExit.

* ruby.c (proc_options): -v should not print version if
  proc_options called via moreswitches().

* parse.y (stmt): while/until modifier must work for empty body.
@
text
@d6 1
a6 1
  $Date: 2001/03/06 08:17:16 $
d1425 1
a1425 1
ev_const_defined(cref, id)
d1428 1
d1435 1
a1435 1
	if (NIL_P(klass)) return rb_const_defined(rb_cObject, id);
d1445 1
a1445 1
ev_const_get(cref, id)
d1448 1
d1456 1
a1456 1
	if (NIL_P(klass)) return rb_const_get(rb_cObject, id);
a1465 21
ev_const_set(cref, id, val)
    NODE *cref;
    ID id;
    VALUE val;
{
    NODE *cbase = cref;

    while (cbase && cbase->nd_clss != rb_cObject) {
	struct RClass *klass = RCLASS(cbase->nd_clss);

	if (klass->iv_tbl && st_lookup(klass->iv_tbl, id, 0)) {
	    st_insert(klass->iv_tbl, id, val);
	    return val;
	}
	cbase = cbase->nd_next;
    }
    rb_const_assign(cbase->nd_clss, id, val);
    return val;
}

static VALUE
d1810 1
a1810 1
	if (ev_const_defined(RNODE(ruby_frame->cbase), node->nd_vid)) {
d2722 1
a2722 1
	result = ev_const_get(RNODE(ruby_frame->cbase), node->nd_vid);
@


1.161
log
@* parse.y (primary): rescue and ensure clauses should be allowed
  to appear in singleton method body.
@
text
@d6 1
a6 1
  $Date: 2001/03/05 08:33:16 $
d3318 1
a3318 1
	exit = rb_exc_new(rb_eSystemExit, 0, 0);
d4155 1
a4155 1
#ifdef sparc
d6448 1
a6448 1
	    rb_raise(rb_eLocalJumpError, "retry from proc-closure");
@


1.160
log
@* eval.c (proc_eq): compare Procs using blocktag equality.
@
text
@d6 1
a6 1
  $Date: 2001/02/28 06:30:03 $
a1459 3
#if 1
    return rb_const_get(ruby_class, id);
#else
a1460 1
#endif
d1463 43
a1505 43
 static VALUE
 ev_const_set(cref, id, val)
     NODE *cref;
     ID id;
     VALUE val;
 {
     NODE *cbase = cref;

     while (cbase && cbase->nd_clss != rb_cObject) {
	 struct RClass *klass = RCLASS(cbase->nd_clss);

	 if (klass->iv_tbl && st_lookup(klass->iv_tbl, id, 0)) {
	     st_insert(klass->iv_tbl, id, val);
	     return val;
	 }
	 cbase = cbase->nd_next;
     }
     rb_const_assign(cbase->nd_clss, id, val);
     return val;
 }

 static VALUE
 rb_mod_nesting()
 {
     NODE *cbase = RNODE(ruby_frame->cbase);
     VALUE ary = rb_ary_new();

     while (cbase && cbase->nd_clss != rb_cObject) {
	 rb_ary_push(ary, cbase->nd_clss);
	 cbase = cbase->nd_next;
     }
     return ary;
 }

 static VALUE
 rb_mod_s_constants()
 {
     NODE *cbase = RNODE(ruby_frame->cbase);
     VALUE ary = rb_ary_new();

     while (cbase && cbase->nd_clss != rb_cObject) {
	 rb_mod_const_at(cbase->nd_clss, ary);
		cbase = cbase->nd_next;
d6362 17
d6796 1
d7198 1
a7198 1
    rb_thread_t th, curr = curr_thread;
d7200 1
a7200 1
    FOREACH_THREAD_FROM(curr, th) {
d7206 1
a7206 1
    END_FOREACH_FROM(curr, th);
@


1.159
log
@* string.c (rb_str_delete_bang): delete! should take at least 1
  argument.

* ruby.c (load_file): add rb_gc() after loading to avoid
  extraordinary memory growth.

* dir.c (rb_glob_helper): "./foo" should match "foo", not "./foo".

* eval.c (ev_const_get): retrieve Object's constant if no current
  class is available (e.g. defining singleton class for Fixnums).

* eval.c (ev_const_defined): check Object's constant if no current
  class is available (e.g. defining singleton class for Fixnums).

* time.c (time_timeval): negative time interval shoule not be
  allowed.

* eval.c (proc_call): ignore block to `call' always, despite of
  being orphan or not.

* eval.c (rb_yield_0): should check based on rb_block_given_p()
  and rb_f_block_given_p().

* configure.in (frame-address): --enable-frame-address to allow
  __builtin_frame_address() to be used.

* eval.c (stack_length): use __builtin_frame_address() based on
  the macro USE_BUILTIN_FRAME_ADDRESS.

* gc.c (rb_gc): ditto.

* gc.c (Init_stack): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/02/27 07:52:11 $
d1460 3
d1464 1
d1467 43
a1509 43
static VALUE
ev_const_set(cref, id, val)
    NODE *cref;
    ID id;
    VALUE val;
{
    NODE *cbase = cref;

    while (cbase && cbase->nd_clss != rb_cObject) {
	struct RClass *klass = RCLASS(cbase->nd_clss);

	if (klass->iv_tbl && st_lookup(klass->iv_tbl, id, 0)) {
	    st_insert(klass->iv_tbl, id, val);
	    return val;
	}
	cbase = cbase->nd_next;
    }
    rb_const_assign(cbase->nd_clss, id, val);
    return val;
}

static VALUE
rb_mod_nesting()
{
    NODE *cbase = RNODE(ruby_frame->cbase);
    VALUE ary = rb_ary_new();

    while (cbase && cbase->nd_clss != rb_cObject) {
	rb_ary_push(ary, cbase->nd_clss);
	cbase = cbase->nd_next;
    }
    return ary;
}

static VALUE
rb_mod_s_constants()
{
    NODE *cbase = RNODE(ruby_frame->cbase);
    VALUE ary = rb_ary_new();

    while (cbase && cbase->nd_clss != rb_cObject) {
	rb_mod_const_at(cbase->nd_clss, ary);
	cbase = cbase->nd_next;
d2949 5
d3016 5
d4999 1
a5000 1
	/* copy the block to avoid modifying global data. */
d6352 14
d6782 1
@


1.158
log
@* time.c (time_timeval): negative time interval shoule not be
  allowed.

* eval.c (proc_call): ignore block to `call' always, despite of
  being orphan or not.
@
text
@d6 1
a6 1
  $Date: 2001/02/26 05:29:00 $
d1434 2
a1435 2
	if (klass->iv_tbl &&
	    st_lookup(klass->iv_tbl, id, 0)) {
d1454 1
d2936 1
a2936 1
		rb_raise(rb_eTypeError, "no class to add method");
d3520 1
a3520 1
    if (!ruby_frame->iter || !ruby_block) {
d4136 1
a4136 1
# if defined(__GNUC__) && defined(__i386__)
@


1.157
log
@* eval.c (proc_call): should not modify ruby_block->frame.iter
  based on ruby_frame->iter altered by PUSH_ITER().

* eval.c (rb_thread_fd_close): should save current context before
  raising exception.

* io.c (set_stdin): preserve original stdin.

* io.c (set_outfile): preserve original stdout/stderr.
@
text
@d6 1
a6 1
  $Date: 2001/02/19 07:03:06 $
a200 1

a6262 9
    if (orphan) {/* orphan procedure */
	if (rb_block_given_p()) {
	    ruby_block->frame.iter = ITER_CUR;
	}
	else {
	    ruby_block->frame.iter = ITER_NOT;
	}
    }

d6267 1
@


1.156
log
@* eval.c (secure_visibility): visibility check for untainted modules.

* signal.c (sigpipe): sighandler which does nothing.

* signal.c (trap): set sigpipe function for SIGPIPE.

* signal.c (Init_signal): default SIGPIPE handler should be
  sigpipe function.

* array.c (rb_ary_subseq): wrong boundary check.

* parse.y (cond0): integer literal in condition should not be
  compared to lineno ($.).
@
text
@d6 1
a6 1
  $Date: 2001/02/14 05:51:57 $
a3610 18
#if 0
    if (ruby_dyna_vars && (block->flags & BLOCK_D_SCOPE) &&
	(!(ruby_scope->flags & SCOPE_DONT_RECYCLE) ||
	 !(block->tag->flags & BLOCK_DYNAMIC) ||
	 !FL_TEST(ruby_dyna_vars, DVAR_DONT_RECYCLE))) {
	struct RVarmap *vars, *tmp;

	if (ruby_dyna_vars->id == 0) {
	    vars = ruby_dyna_vars->next;
	    rb_gc_force_recycle((VALUE)ruby_dyna_vars);
	    while (vars && vars->id != 0) {
		tmp = vars->next;
		rb_gc_force_recycle((VALUE)vars);
		vars = tmp;
	    }
	}
    }
#else
a3624 1
#endif
d6166 1
a6166 1
	rb_raise(rb_eArgError, "tried to create Procedure-Object without a block");
d6264 9
d6277 1
a6284 9
    if (orphan) {/* orphan procedure */
	if (rb_block_given_p()) {
	    ruby_block->frame.iter = ITER_CUR;
	}
	else {
	    ruby_block->frame.iter = ITER_NOT;
	}
    }

d6978 2
d7163 1
a7163 1
    rb_thread_t th;
d7165 1
a7165 1
    FOREACH_THREAD(th) {
d7167 2
a7168 7
	    th_raise_argc = 1;
	    th_raise_argv[0] = rb_exc_new2(rb_eIOError, "stream closed");
	    th_raise_file = ruby_sourcefile;
	    th_raise_line = ruby_sourceline;
	    curr_thread = th;
	    rb_thread_ready(th);
	    rb_thread_restore_context(curr_thread, RESTORE_RAISE);
d7171 1
a7171 1
    END_FOREACH(th);
a7957 2
static VALUE rb_thread_raise _((int, VALUE*, rb_thread_t));

d8440 1
a8440 1
#if 0				/* enable on 1.7 */
@


1.155
log
@* dir.c (dir_s_glob): supprt backslash escape of metacharacters
  and delimiters.

* dir.c (remove_backslases): remove backslashes from path before
  calling stat(2).

* dir.c (dir_s_glob): call rb_yield directly (via push_pattern) if
  block is given to the method.

* dir.c (push_pattern): do not call rb_ary_push; yield directly.

* eval.c (blk_copy_prev): reduced ALLOC_N too much.

* eval.c (frame_dup): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/02/13 05:08:59 $
d5430 9
d5447 1
d5459 1
d5475 1
d5491 1
d5551 1
@


1.154
log
@* io.c (rb_io_ctl): do not call ioctl/fcntl for f2, if f and f2
  have same fileno.

* eval.c (rb_load): raise LocaJumpError if unexpected local jumps
  appear during load.

* ext/socket/socket.c (bsock_close_read): don't call rb_thread_fd_close();
  it's supposed to be called by io_io_close().

* ext/socket/socket.c (bsock_close_read): do not modify f and f2.

* ext/socket/socket.c (bsock_close_write): ditto.

* ext/socket/socket.c (sock_new): avoid dup(2) on sockets.

* parse.y (primary): preserve and clear in_single and in_def using
  stack to prevent nested method errors in singleton class bodies.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/02/11 07:12:02 $
d6018 1
a6018 1
	if (tmp->frame.argc > 0 && !(tmp->frame.flags & FRAME_MALLOC)) {
d6038 1
a6038 1
	if (frame->argc > 0 && !(frame->flags & FRAME_MALLOC)) {
d6042 1
a6042 1
	    frame->flags = FRAME_MALLOC;
@


1.153
log
@* eval.c (stack_length): use __builtin_frame_address() only if
  GCC and i386 CPU.
* gc.c (rb_gc, Init_stack): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/02/08 09:19:16 $
d1301 28
d1364 1
a1364 22
    switch (state) {
      case 0:
	break;
      case TAG_RETURN:
	rb_raise(rb_eLocalJumpError, "unexpected return");
	break;
      case TAG_NEXT:
	rb_raise(rb_eLocalJumpError, "unexpected next");
	break;
      case TAG_BREAK:
	rb_raise(rb_eLocalJumpError, "unexpected break");
	break;
      case TAG_REDO:
	rb_raise(rb_eLocalJumpError, "unexpected redo");
	break;
      case TAG_RETRY:
	rb_raise(rb_eLocalJumpError, "retry outside of rescue clause");
	break;
      default:
	JUMP_TAG(state);
	break;
    }
a3653 2
		rb_raise(rb_eLocalJumpError, "unexpected break");
		break;
d3655 1
a3655 1
		rb_raise(rb_eLocalJumpError, "unexpected return");
a4461 9
	      case TAG_NEXT:
		rb_raise(rb_eLocalJumpError, "unexpected next");
		break;
	      case TAG_BREAK:
		rb_raise(rb_eLocalJumpError, "unexpected break");
		break;
	      case TAG_REDO:
		rb_raise(rb_eLocalJumpError, "unexpected redo");
		break;
d4463 2
a4464 2
		if (!rb_block_given_p()) {
		    rb_raise(rb_eLocalJumpError, "retry outside of rescue clause");
d4466 1
d4468 2
a4469 1
		JUMP_TAG(state);
d5190 1
a5190 1
    if (state) JUMP_TAG(state);
@


1.152
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_options): new method to give an option values.

* parse.y (cond0): disable special treating of integer literal in
  conditional unless option -e is supplied.  changes current
  behavior.  experimental.

* parse.y (cond0): give warning for string/integer literals and
  dot operators in conditionals unless option -e is supplied.

* re.c (rb_reg_equal): all option flags should be same to be equal.

* error.c (Init_Exception): make Interrupt a subclass of
  SignalException.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:38:10 $
d25 19
d4150 1
a4150 1
# if defined(__GNUC__) && !defined(__alpha__) && !defined(__APPLE__)
@


1.151
log
@* array.c (rb_ary_sort_bang): returns self, even if its length is
  less than 2.

* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2001/01/29 06:12:56 $
d4476 1
a4476 1
	rb_raise(rb_eNotImpError, "method call on terminated obejct");
d6001 1
a6001 1
	if (tmp->frame.argc > 0) {
d6004 1
d6021 1
a6021 1
	if (frame->argc > 0) {
@


1.150
log
@* eval.c (block_pass): return from block jumps directory to
  block invoker.
@
text
@d6 1
a6 1
  $Date: 2001/01/29 05:10:41 $
d605 2
d813 1
a813 1
    _scope->flag = 0;			\
d824 1
a824 1
    if (ruby_scope->flag & SCOPE_DONT_RECYCLE) {\
d827 1
a827 1
    if (!(ruby_scope->flag & SCOPE_MALLOC)) {\
d830 1
a830 1
	if (!(ruby_scope->flag & SCOPE_DONT_RECYCLE) && \
d835 1
a835 1
    ruby_scope->flag |= SCOPE_NOSTACK;	\
d1310 1
a1310 1
    if (ruby_scope->flag & SCOPE_DONT_RECYCLE)
d2239 1
a2240 1
		    PUSH_ITER(ITER_PRE);
a2241 1
		    POP_ITER();
d2249 1
d2251 1
a2251 1
		    PUSH_ITER(ITER_PRE);
a2254 1
		    POP_ITER();
d2256 1
d3585 1
d3587 3
a3589 1
	!FL_TEST(ruby_dyna_vars, DVAR_DONT_RECYCLE)) {
d3602 16
d3621 1
a3621 1
    if (ruby_scope->flag & SCOPE_DONT_RECYCLE)
a4762 1

d4808 2
a4810 2
	if (ruby_scope->flag & SCOPE_DONT_RECYCLE)
           scope_dup(old_scope);
d4816 19
d5158 1
a5158 1
    if (ruby_scope->flag == SCOPE_ALLOCA && ruby_class == rb_cObject) {
d5938 2
a5939 2
    scope->flag |= SCOPE_DONT_RECYCLE;
    if (scope->flag & SCOPE_MALLOC) return;
d5947 1
a5947 1
	scope->flag |= SCOPE_MALLOC;
d6205 1
a6205 1
    if (!(data->scope->flag & SCOPE_NOSTACK)) {
@


1.149
log
@* string.c (str_independent): should not clear str->orig here.
  it's too early.
@
text
@d6 1
a6 1
  $Date: 2001/01/24 06:32:10 $
d6336 17
a6352 1
	state &= TAG_MASK;
@


1.148
log
@* eval.c (POP_BLOCK_TAG): call rb_gc_force_recycle() if block has
  not been objectified.

* eval.c (rb_callcc): should nail down block->tag history to avoid
  rb_gc_force_recycle().
@
text
@d6 1
a6 1
  $Date: 2001/01/23 08:08:59 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
d5208 1
a5208 1
		    rb_raise(rb_eLoadError, "infinite load loop -- %s", f);
@


1.147
log
@* gc.c (os_live_obj): do not list terminated object.

* gc.c (os_obj_of): ditto.

* gc.c (rb_gc_mark): support new T_BLKTAG tag.

* gc.c (obj_free): ditto.

* eval.c (new_blktag): creation of new block tag, which holds
  destination of global jump and orphan status.

* eval.c (block_pass): break from orphan Proc object will raise a
  LocalJumpError exception.

* eval.c (block_pass): behavior consistency with proc_call(). do
  not propagate `break'.
@
text
@d6 1
a6 1
  $Date: 2001/01/18 08:43:07 $
d586 7
d594 1
a594 1
   _block.tag->flags |= BLOCK_ORPHAN;	\
a597 10
#define PUSH_BLOCK2(b) {		\
    struct BLOCK * volatile _old;	\
    _old = ruby_block;			\
    ruby_block = b;

#define POP_BLOCK2() 			\
   _block.tag->flags |= BLOCK_ORPHAN;	\
   ruby_block = _old;	 		\
}

d5924 1
d5967 1
d6045 2
d6130 1
d8409 8
@


1.146
log
@* io.c (rb_io_s_read): new method to call IO#read from
  pathname.  In addition, it accepts third optional argument to
  specify starting point.
@
text
@d6 1
a6 1
  $Date: 2001/01/15 07:00:53 $
d530 6
d542 1
a543 1
    struct tag *tag;
d554 1
d558 10
d570 1
a570 1
    _block.tag = prot_tag;		\
d587 1
d597 1
d1073 1
a1073 1
    switch (ex & 0xf) {
d2235 1
a2236 1
	    PUSH_TAG(PROT_FUNC);
d2265 1
a2266 1
	    POP_BLOCK();
d3576 1
a3576 1
	    block->tag->dst = state; 
d3606 13
a3618 1
    if (state) JUMP_TAG(state);
a6120 1
    data->tag = 0;		/* should not point into stack */
d6164 4
a6167 2
    if (data->scope && data->scope != top_scope &&
	(data->scope->flag & SCOPE_NOSTACK)) {
a6230 1
    _block.tag = prot_tag;
a6325 1
    _block.tag = prot_tag;
d6334 1
a6334 14
	if (orphan) {
	    state &= TAG_MASK;
	}
	else {
	    struct BLOCK *ptr = old_block;

	    while (ptr) {
		if (ptr->scope == _block.scope) {
		    ptr->tag->dst = state;
		    break;
		}
		ptr = ptr->prev;
	    }
	}
d6339 5
a6343 6
    if (state) {
	switch (state) {/* escape from orphan procedure */
	  case TAG_BREAK:
	    rb_raise(rb_eLocalJumpError, "break from proc-closure");
	    break;
	  case TAG_RETRY:
d6345 7
a6351 2
	    break;
	  case TAG_RETURN:
a6352 1
	    break;
d6354 1
d6357 1
@


1.145
log
@Mon Jan 15 16:00:07 2001  Yukihiro Matsumoto  <matz@@ruby-lang.org>

	* pack.c (pack_unpack): should check associated pointer packed by
	  pack("P").  restriction added.

Sun Jan 14 21:49:28 2001  Koji Arai  <JCA02266@@nifty.ne.jp>

	* sprintf.c (rb_f_sprintf): simple typo.  binary base should be 2,
	  not '2'.

	* re.c (rb_reg_s_last_match): should explicitly return nth match.
@
text
@d6 1
a6 1
  $Date: 2001/01/10 07:52:45 $
a6302 1
    printf("state: %d(%d)\n", state, _block.tag->dst);
@


1.144
log
@* m17n baseline.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/01/10 07:30:18 $
d6303 1
@


1.143
log
@setres[ug]id, NORETURN
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/01/09 07:26:16 $
d6628 1
a6628 1
    VALUE name, body;
a8039 2
    rb_thread_t th;

@


1.142
log
@* enum.c (enum_inject): new method.

* gc.c (rb_gc_call_finalizer_at_exit): clear klass member of
  terminating object.

* eval.c (rb_call): raise exception for terminated object.

* bignum.c (bigdivrem): t2 might be too big for signed long; do
  not use rb_int2big(), but rb_uint2big().

* error.c (rb_load_fail): new func to report LoadError.

* ruby.c (load_file): use rb_load_fail.

* eval.c (ruby_finalize): should enclosed by PUSH_TAG/POP_TAG.

* gc.c (rb_gc_mark): link 2 of NODE_IFUNC should not be explicitly
  marked.  it may contain non object pointer.

* re.c (reg_s_last_match): Regexp::last_match(nth) returns nth
  substring of the match  (alternative for $& and $<digit>).

* eval.c (rb_mod_define_method): wrong comparison for blocks.

* gc.c (id2ref): should handle Symbol too.

* gc.c (id2ref): should print original ptr value

* eval.c (rb_iterate): NODE_CFUNC does not protect its data
  (nd_tval), so create new node NODE_IFUNC for iteration C
  function.

* eval.c (rb_yield_0): use NODE_IFUNC.

* gc.c (rb_gc_mark): support NODE_IFUNC.

* gc.c (mem_error): prohibit recursive mem_error().
  (ruby-bugs-ja:PR#36)

* eval.c (rb_thread_fd_writable): should not switch context if
  rb_thread_critical is set.

* eval.c (rb_thread_wait_fd): ditto.

* eval.c (rb_thread_wait_for): ditto.

* eval.c (rb_thread_select): ditto.

* eval.c (rb_thread_join): join during critical section causes
  deadlock.
@
text
@d6 1
a6 1
  $Date: 2000/12/29 18:23:22 $
d170 1
a170 1
static void print_undef _((VALUE, ID)) NORETURN;
d3315 1
a3315 1
static void rb_longjmp _((int, VALUE)) NORETURN;
d5638 1
a5638 1
static VALUE rb_f_throw _((int,VALUE*)) NORETURN;
@


1.141
log
@* eval.c (rb_iterate): NODE_CFUNC does not protect its data
  (nd_tval), so create new node NODE_IFUNC for iteration C
  function.

* eval.c (rb_yield_0): use NODE_IFUNC.

* gc.c (rb_gc_mark): support NODE_IFUNC.
@
text
@d6 1
a6 1
  $Date: 2000/12/29 02:46:09 $
d1125 9
a1133 3
    rb_trap_exit();
    rb_exec_end_proc();
    rb_gc_call_finalizer_at_exit();
d3535 1
a3535 1
	else if (nd_type(node) == NODE_IFUNC) {
d4426 3
d6647 1
a6647 1
    else if (RDATA(body)->dmark != (RUBY_DATA_FUNC)blk_mark) {
@


1.140
log
@thread_critical bug reported by Dave - matz
@
text
@d6 1
a6 1
  $Date: 2000/12/27 05:59:03 $
d3529 1
a3529 1
	else if (nd_type(node) == NODE_CFUNC) {
d3748 1
a3748 1
    NODE *node = NEW_CFUNC(bl_proc, data2);
@


1.139
log
@matz
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2000/12/26 08:08:50 $
d7357 1
d7371 1
d7392 2
a7393 1
    if (curr_thread == curr_thread->next ||
d7458 2
a7459 1
    if (curr_thread == curr_thread->next ||
d7525 1
d7625 2
a7626 2
    rb_thread_schedule();
    return Qnil;		/* not reached */
@


1.139.2.1
log
@m17n fix
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/01/10 07:52:45 $
d170 1
a170 1
NORETURN(static void print_undef _((VALUE, ID)));
d1125 3
a1127 9
    int state;

    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	rb_trap_exit();
	rb_exec_end_proc();
	rb_gc_call_finalizer_at_exit();
    }
    POP_TAG();
d1825 1
a1825 1
	    sprintf(buf, "$%d", (int)node->nd_nth);
d1832 1
a1832 1
	    sprintf(buf, "$%c", (int)node->nd_nth);
d3309 1
a3309 1
NORETURN(static void rb_longjmp _((int, VALUE)));
d3529 1
a3529 1
	else if (nd_type(node) == NODE_CFUNC || nd_type(node) == NODE_IFUNC) {
d3748 1
a3748 1
    NODE *node = NEW_IFUNC(bl_proc, data2);
a4419 3
    if (!klass) {
	rb_raise(rb_eNotImpError, "method call on terminated obejct");
    }
d5629 1
a5629 1
NORETURN(static VALUE rb_f_throw _((int,VALUE*)));
d6619 1
a6619 1
    VALUE body;
d6638 1
a6638 1
    else if (RDATA(body)->dmark == (RUBY_DATA_FUNC)blk_mark) {
a7356 1
    if (rb_thread_critical) return;
a7369 1
    if (rb_thread_critical) return Qtrue;
d7390 1
a7390 2
    if (rb_thread_critical ||
	curr_thread == curr_thread->next ||
d7455 1
a7455 2
    if (rb_thread_critical ||
	curr_thread == curr_thread->next ||
a7520 1
    if (rb_thread_critical) rb_thread_deadlock();
d7620 2
a7621 2
    if (!rb_thread_critical) rb_thread_schedule();
    return thread;
d8026 2
@


1.139.2.2
log
@several minor fixes.
@
text
@d6 1
a6 1
  $Date: 2001/01/12 04:35:59 $
d1417 21
@


1.138
log
@matz
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/12/25 06:28:56 $
d1985 1
a1985 1
	result = rb_reg_match2(node->nd_head->nd_lit);
d3561 1
a3561 1
    if ((block->flags & BLOCK_D_SCOPE) &&
d3563 1
a3563 1
	struct RVarmap *vars = ruby_dyna_vars;
d3565 2
a3566 6
	while (vars && vars->id != 0) {
	    struct RVarmap *tmp = vars->next;
	    rb_gc_force_recycle((VALUE)vars);
	    vars = tmp;
	}
	if (ruby_dyna_vars && ruby_dyna_vars->id == 0) {
d3568 5
@


1.137
log
@001225
@
text
@d6 1
a6 1
  $Date: 2000/12/22 03:21:54 $
d5983 1
a5983 1
    struct BLOCK *data;
d6006 5
a6010 3
    for (vars = data->dyna_vars; vars; vars = vars->next) {
	if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
	FL_SET(vars, DVAR_DONT_RECYCLE);
d6068 1
a6068 1
    struct BLOCK *data;
d6090 5
a6094 3
    for (vars = data->dyna_vars; vars; vars = vars->next) {
	if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
	FL_SET(vars, DVAR_DONT_RECYCLE);
@


1.137.2.1
log
@* gc.c (mem_error): prohibit recursive mem_error().
  (ruby-bugs-ja:PR#36)

* eval.c (rb_thread_fd_writable): should not switch context if
  rb_thread_critical is set.

* eval.c (rb_thread_wait_fd): ditto.

* eval.c (rb_thread_wait_for): ditto.

* eval.c (rb_thread_select): ditto.

* eval.c (rb_thread_join): join during critical section causes
  deadlock.
@
text
@d6 1
a6 1
  $Date: 2000/12/25 06:28:56 $
a7351 1
    if (rb_thread_critical) return;
a7364 1
    if (rb_thread_critical) return Qtrue;
d7385 1
a7385 2
    if (rb_thread_critical ||
	curr_thread == curr_thread->next ||
d7450 1
a7450 2
    if (rb_thread_critical ||
	curr_thread == curr_thread->next ||
a7515 1
    if (rb_thread_critical) rb_thread_deadlock();
d7615 2
a7616 2
    if (!rb_thread_critical) rb_thread_schedule();
    return thread;
@


1.137.2.2
log
@* pack.c (pack_pack): template "m2" or "u2" caused inifinite loop.

* eval.c (ruby_finalize): should enclosed by PUSH_TAG/POP_TAG.

* eval.c (rb_mod_define_method): wrong comparison for blocks.

* gc.c (id2ref): should handle Symbol too.

* gc.c (id2ref): should print original ptr value

* eval.c (rb_iterate): NODE_CFUNC does not protect its data
  (nd_tval), so create new node NODE_IFUNC for iteration C
  function.

* eval.c (rb_yield_0): use NODE_IFUNC.

* gc.c (rb_gc_mark): support NODE_IFUNC.
@
text
@d6 1
a6 1
  $Date: 2000/12/29 03:48:35 $
d1125 3
a1127 7
    PUSH_TAG(PROT_NONE);
    if (EXEC_TAG() == 0) {
	rb_trap_exit();
	rb_exec_end_proc();
	rb_gc_call_finalizer_at_exit();
    }
    POP_TAG();
d3529 1
a3529 1
	else if (nd_type(node) == NODE_CFUNC || nd_type(node) == NODE_IFUNC) {
d3747 1
a3747 1
    NODE *node = NEW_IFUNC(bl_proc, data2);
d5983 1
a5983 1
    struct BLOCK *data, *p;
d6006 3
a6008 5
    for (p = data; p; p = p->prev) {
	for (vars = p->dyna_vars; vars; vars = vars->next) {
	    if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
	    FL_SET(vars, DVAR_DONT_RECYCLE);
	}
d6066 1
a6066 1
    struct BLOCK *data, *p;
d6088 3
a6090 5
    for (p = data; p; p = p->prev) {
	for (vars = p->dyna_vars; vars; vars = vars->next) {
	    if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
	    FL_SET(vars, DVAR_DONT_RECYCLE);
	}
d6633 1
a6633 1
    else if (RDATA(body)->dmark == (RUBY_DATA_FUNC)blk_mark) {
@


1.137.2.3
log
@* eval.c (POP_VARS): propagate DVAR_DONT_RECYCLE, if
  SCOPE_DONT_RECYCLE of ruby_scope is set.
@
text
@d6 1
a6 1
  $Date: 2001/01/09 07:29:03 $
a529 6
struct BLOCKTAG {
    struct RBasic super;
    long dst;
    long flags;
};

a535 1
    struct BLOCKTAG *tag;
d537 1
a547 1
#define BLOCK_ORPHAN  4
a550 10
static struct BLOCKTAG*
new_blktag()
{
    NEWOBJ(blktag, struct BLOCKTAG);
    OBJSETUP(blktag, 0, T_BLKTAG);
    blktag->dst = 0;
    blktag->flags = 0;
    return blktag;
}

d553 1
a553 1
    _block.tag = new_blktag();		\
a568 7
#define POP_BLOCK_TAG(tag) do {		\
   if ((tag)->flags & BLOCK_DYNAMIC)	\
       (tag)->flags |= BLOCK_ORPHAN;	\
   else					\
       rb_gc_force_recycle((VALUE)tag); \
} while (0)

a569 1
   POP_BLOCK_TAG(_block.tag);		\
d573 9
a588 2
   if (_old && (ruby_scope->flag & SCOPE_DONT_RECYCLE)) \
       FL_SET(_old, DVAR_DONT_RECYCLE); \
d1054 1
a1054 1
    switch (ex & TAG_MASK) {
d2214 1
a2215 1
	    PUSH_BLOCK(node->nd_var, node->nd_body);
a2218 1
		PUSH_ITER(ITER_PRE);
d2220 1
d2222 1
a2229 1
		    BEGIN_CALLARGS;
d2231 1
a2231 1
		    END_CALLARGS;
d2235 1
a2236 1
		POP_ITER();
d2244 1
a2245 1
	    POP_TAG();
d3555 1
a3555 1
	    block->tag->dst = state;
d3565 1
a3565 19
#if 0
    if (ruby_dyna_vars && (block->flags & BLOCK_D_SCOPE) &&
	(!(ruby_scope->flags & SCOPE_DONT_RECYCLE) ||
	 !(block->tag->flags & BLOCK_DYNAMIC) ||
	 !FL_TEST(ruby_dyna_vars, DVAR_DONT_RECYCLE))) {
	struct RVarmap *vars, *tmp;

	if (ruby_dyna_vars->id == 0) {
	    vars = ruby_dyna_vars->next;
	    rb_gc_force_recycle((VALUE)ruby_dyna_vars);
	    while (vars && vars->id != 0) {
		tmp = vars->next;
		rb_gc_force_recycle((VALUE)vars);
		vars = tmp;
	    }
	}
    }
#else
    if (ruby_dyna_vars && (block->flags & BLOCK_D_SCOPE) &&
d3569 6
a3574 2
	if (ruby_dyna_vars->id == 0) {
	    vars = ruby_dyna_vars->next;
a3575 5
	    while (vars && vars->id != 0) {
		struct RVarmap *tmp = vars->next;
		rb_gc_force_recycle((VALUE)vars);
		vars = tmp;
	    }
a3577 1
#endif
d3584 1
a3584 13
    if (state) {
	if (!block->tag) {
	    switch (state & TAG_MASK) {
	      case TAG_BREAK:
		rb_raise(rb_eLocalJumpError, "unexpected break");
		break;
	      case TAG_RETURN:
		rb_raise(rb_eLocalJumpError, "unexpected return");
		break;
	    }
	}
	JUMP_TAG(state);
    }
a4422 3
    if (!klass) {
	rb_raise(rb_eNotImpError, "method call on terminated obejct");
    }
d4708 1
a4753 2
	int dont_recycle = ruby_scope->flag & SCOPE_DONT_RECYCLE;

d4755 2
a4761 19
	if (dont_recycle) {
	   struct tag *tag;
	   struct RVarmap *vars;

           scope_dup(ruby_scope);
	   for (tag=prot_tag; tag; tag=tag->prev) {
	       scope_dup(tag->scope);
	   }
	   if (ruby_block) {
	       struct BLOCK *block = ruby_block;
	       while (block) {
		   block->tag->flags |= BLOCK_DYNAMIC;
		   block = block->prev;
	       }
	   }
	   for (vars = ruby_dyna_vars; vars; vars = vars->next) {
	       FL_SET(vars, DVAR_DONT_RECYCLE);
	   }
	}
d5174 1
a5174 1
		    return Qtrue;
a5889 1
	rb_gc_mark(data->tag);
a5931 1
	tmp->tag->flags |= BLOCK_DYNAMIC;
a6008 2
    data->flags |= BLOCK_DYNAMIC;
    data->tag->flags |= BLOCK_DYNAMIC;
d6084 1
a6092 1
    data->tag->flags |= BLOCK_DYNAMIC;
d6193 1
d6289 1
a6310 3
	    if (!ptr) {
		state &= TAG_MASK;
	    }
d6316 6
a6321 5
    switch (state) {/* escape from orphan procedure */
      case 0:
	break;
      case TAG_BREAK:
	if (orphan) {
d6323 2
a6324 7
	}
	break;
      case TAG_RETRY:
	rb_raise(rb_eLocalJumpError, "retry from proc-closure");
	break;
      case TAG_RETURN:
	if (orphan) {
d6326 1
a6327 1
      default:
a6329 1

d6622 1
a6622 1
    VALUE body;
d8034 2
a8380 8
    }
    if (ruby_block) {
	struct BLOCK *block = ruby_block;

	while (block) {
	    block->tag->flags |= BLOCK_DYNAMIC;
	    block = block->prev;
	}
@


1.137.2.4
log
@* parse.y (parse_quotedwords): %w should allow parenthesis escape.

* parse.y (parse_qstring): %q should allow terminator escape.

* re.c (rb_reg_equal): all option flags should be same to be equal.
@
text
@d6 1
a6 1
  $Date: 2001/02/02 11:39:51 $
d4474 1
a4474 1
	rb_raise(rb_eNotImpError, "method call on terminated object");
@


1.137.2.5
log
@* eval.c (stack_length): use __builtin_frame_address() only if
  GCC and i386 CPU.
* gc.c (rb_gc, Init_stack): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/02/08 09:17:57 $
a24 19
/* Make alloca work the best possible way.  */
#ifdef __GNUC__
# ifndef atarist
#  ifndef alloca
#   define alloca __builtin_alloca
#  endif
# endif /* atarist */
#else
# if defined(HAVE_ALLOCA_H)
#  include <alloca.h>
# elif !defined(alloca)
char *alloca();
# endif
#endif /* __GNUC__ */

#ifdef _AIX
#pragma alloca
#endif

d4129 1
a4129 1
# if defined(__GNUC__) && defined(__i386__)
@


1.137.2.6
log
@commit miss; sorry
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/02/11 07:11:47 $
a1298 28
static void
jump_tag_but_local_jump(state)
    int state;
{
    switch (state) {
      case 0:
	break;
      case TAG_RETURN:
	rb_raise(rb_eLocalJumpError, "unexpected return");
	break;
      case TAG_NEXT:
	rb_raise(rb_eLocalJumpError, "unexpected next");
	break;
      case TAG_BREAK:
	rb_raise(rb_eLocalJumpError, "unexpected break");
	break;
      case TAG_REDO:
	rb_raise(rb_eLocalJumpError, "unexpected redo");
	break;
      case TAG_RETRY:
	rb_raise(rb_eLocalJumpError, "retry outside of rescue clause");
	break;
      default:
	JUMP_TAG(state);
	break;
    }
}

d1334 22
a1355 1
    jump_tag_but_local_jump(state);
d3645 2
d3648 1
a3648 1
		jump_tag_but_local_jump(state & TAG_MASK);
d4455 9
d4465 2
a4466 2
		if (rb_block_given_p()) {
		    break;
a4467 1
		/* fall through */
d4469 1
a4469 2
		jump_tag_but_local_jump(state);
		break;
d5190 1
a5190 1
    if (state) jump_tag_but_local_jump(state);
a5429 9
secure_visibility(self)
    VALUE self;
{
    if (rb_safe_level() >= 4 && !OBJ_TAINTED(self)) {
	rb_raise(rb_eSecurityError, "Insecure: can't change method visibility");
    }
}

static void
a5437 1
    secure_visibility(self);
a5448 1
    secure_visibility(module);
a5463 1
    secure_visibility(module);
a5478 1
    secure_visibility(module);
a5537 1
    secure_visibility(module);
@


1.137.2.7
log
@* eval.c (proc_call): should not modify ruby_block->frame.iter
  based on ruby_frame->iter altered by PUSH_ITER().

* eval.c (rb_thread_fd_close): should save current context before
  raising exception.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/02/19 07:41:24 $
a6277 9
    if (orphan) {/* orphan procedure */
	if (rb_block_given_p()) {
	    ruby_block->frame.iter = ITER_CUR;
	}
	else {
	    ruby_block->frame.iter = ITER_NOT;
	}
    }

d6289 9
a6990 2
static VALUE rb_thread_raise _((int, VALUE*, rb_thread_t));

d7178 7
a7184 2
	    VALUE exc = rb_exc_new2(rb_eIOError, "stream closed");
	    rb_thread_raise(1, &exc, th);
d7973 2
@


1.137.2.8
log
@* eval.c (ev_const_get): retrieve Object's constant if no current
  class is available (e.g. defining singleton class for Fixnums).

* eval.c (proc_call): ignore block to `call' always, despite of
  being orphan or not.
@
text
@d6 1
a6 1
  $Date: 2001/02/26 04:07:48 $
a1452 1
	if (NIL_P(klass)) return rb_const_get(rb_cObject, id);
d6278 9
a6290 2
    ruby_block->frame.iter = ITER_NOT;

@


1.137.2.9
log
@* string.c (rb_str_delete_bang): delete! should take at least 1
  argument.

* eval.c (ev_const_defined): check Object's constant if no current
  class is available (e.g. defining singleton class for Fixnums).

* eval.c (rb_yield_0): should check based on rb_block_given_p()
  and rb_f_block_given_p().
@
text
@d6 1
a6 1
  $Date: 2001/02/27 08:04:23 $
d1433 2
a1434 2
	if (NIL_P(klass)) return rb_const_defined(rb_cObject, id);
	if (klass->iv_tbl && st_lookup(klass->iv_tbl, id, 0)) {
d3519 1
a3519 1
    if (!(rb_block_given_p() || rb_f_block_given_p()) || !ruby_block) {
@


1.137.2.10
log
@* parse.y (primary): rescue and ensure clauses should be allowed
  to appear in singleton method body.
@
text
@d6 1
a6 1
  $Date: 2001/03/05 08:33:16 $
d9 1
a9 1
  Copyright (C) 1993-2001 Yukihiro Matsumoto
d6183 1
a6183 1
	rb_raise(rb_eArgError, "tried to create Proc object without a block");
a6352 31
proc_eq(self, other)
    VALUE self, other;
{
    struct BLOCK *data, *data2;

    if (TYPE(other) != T_DATA) return Qfalse;
    if (RDATA(other)->dmark != blk_mark) Qfalse;
    Data_Get_Struct(self, struct BLOCK, data);
    Data_Get_Struct(other, struct BLOCK, data2);
    if (data->tag == data2->tag) return Qtrue;
    return Qfalse;
}

static VALUE
proc_to_s(self, other)
    VALUE self, other;
{
    struct BLOCK *data;
    char *cname = rb_class2name(CLASS_OF(self));
    VALUE str;

    Data_Get_Struct(self, struct BLOCK, data);
    str = rb_str_new(0, strlen(cname)+6+16+1); /* 6:tags 16:addr 1:eos */
    sprintf(RSTRING(str)->ptr, "#<%s:0x%lx>", cname, data->tag);
    RSTRING(str)->len = strlen(RSTRING(str)->ptr);
    if (OBJ_TAINTED(self)) OBJ_TAINT(str);

    return str;
}

static VALUE
a6768 2
    rb_define_method(rb_cProc, "==", proc_eq, 1);
    rb_define_method(rb_cProc, "to_s", proc_to_s, 0);
@


1.137.2.11
log
@* io.c (argf_seek): wrong calling sequence of rb_io_seek().

* parse.y (stmt): while/until modifier must work for empty body.

* ruby.c (ruby_set_argv): clear ARGV contents before adding args.
@
text
@d6 1
a6 1
  $Date: 2001/03/06 08:17:54 $
d4163 1
a4163 1
#ifdef __sparc__
d6453 1
a6453 1
	    rb_raise(rb_eLocalJumpError, "break from proc-closure");
@


1.137.2.12
log
@* eval.c (rb_yield_0): 0 (= Qfalse) is a valid value, so that
  default self should be checked by klass == 0.

* bignum.c (rb_cstr2inum): should disallow '++1', '+-1', etc.
@
text
@d6 1
a6 1
  $Date: 2001/03/13 05:48:32 $
d1424 1
a1424 1
ev_const_defined(cref, id, self)
a1426 1
    VALUE self;
d1433 1
a1433 1
	if (NIL_P(klass)) return rb_const_defined(CLASS_OF(self), id);
d1443 1
a1443 1
ev_const_get(cref, id, self)
a1445 1
    VALUE self;
d1453 1
a1453 1
	if (NIL_P(klass)) return rb_const_get(CLASS_OF(self), id);
d1463 21
d1828 1
a1828 1
	if (ev_const_defined(RNODE(ruby_frame->cbase), node->nd_vid, self)) {
d2740 1
a2740 1
	result = ev_const_get(RNODE(ruby_frame->cbase), node->nd_vid, self);
d3541 1
a3541 1
    if (!klass) self = block->self;
@


1.137.2.13
log
@* eval.c (rb_thread_schedule): raise FATAL just once to
  THREAD_TO_KILL.
@
text
@d6 1
a6 1
  $Date: 2001/03/14 04:45:44 $
d6889 1
a6889 3
#define THREAD_RAISED 0x200	 /* temporary flag */
#define THREAD_TERMINATING 0x400 /* persistent flag */
#define THREAD_FLAGS_MASK  0x400 /* mask for persistent flags */
d7041 1
a7041 2
    th->flags &= THREAD_FLAGS_MASK;
    th->flags |= (rb_trap_immediate<<8) | scope_vmode;
d7467 2
a7468 5
	if (!(next->flags & THREAD_TERMINATING)) {
	    next->flags |= THREAD_TERMINATING;
	    /* terminate; execute ensure-clause if any */
	    rb_thread_restore_context(next, RESTORE_FATAL);
	}
@


1.137.2.14
log
@remove duplicated initialize in PUSH_TAG.
@
text
@d6 1
a6 1
  $Date: 2001/03/14 08:39:13 $
d779 1
d6340 1
a6340 1
    if (RDATA(other)->dmark != (RUBY_DATA_FUNC)blk_mark) Qfalse;
@


1.137.2.15
log
@* eval.c (THREAD_ALLOC): flags should be initialized.
@
text
@d6 1
a6 1
  $Date: 2001/03/16 08:28:12 $
a7917 1
    th->flags = 0;\
@


1.137.2.16
log
@* eval.c (ev_const_defined): need not to check if cbase->nd_class
  is rb_cObject.

* eval.c (ev_const_get): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/03/19 07:56:47 $
d1430 1
a1430 1
    while (cbase) {
d1451 1
a1451 1
    while (cbase) {
@


1.137.2.17
log
@* eval.c: remove TMP_PROTECT_END to prevent C_ALLOCA crash.

* eval.c (ev_const_defined): should ignore toplevel cbase (Object).

* eval.c (ev_const_get): ditto.

* ext/curses/curses.c: curses on Mac OS X public beta does not
  have _maxx etc.

* marshal.c (w_object): should truncate trailing zero short for
  bignums.
@
text
@d6 1
a6 1
  $Date: 2001/03/19 09:00:30 $
d1430 1
a1430 1
    while (cbase && cbase->nd_next) {
d1451 1
a1451 1
    while (cbase && cbase->nd_next) {
d1469 1
a1469 1
    while (cbase && cbase->nd_next) {
d1482 1
a1482 1
    while (cbase) {
d1614 6
d1623 1
d2492 1
d2506 1
d2539 1
d2601 1
d3235 1
d3871 1
d4454 1
d5168 1
@


1.137.2.18
log
@* eval.c (rb_mod_define_method): should have clear method cache.

* eval.c (rb_mod_define_method): should have raised exception for
  type error.

* ruby.h: changed "extern INLINE" to "static inline".
@
text
@d6 1
a6 1
  $Date: 2001/03/26 08:56:03 $
a6738 1
	rb_raise(rb_eTypeError, "wrong argument type (expected Proc)");
a6747 1
	rb_raise(rb_eTypeError, "wrong argument type (expected Proc)");
a6749 1
    rb_clear_cache_by_id(id);
@


1.137.2.19
log
@* object.c (rb_str2cstr): warn if string contains \0 and length
  value is ignored.

* class.c (rb_singleton_class_clone): should copy class constant
  table as well.

* class.c (rb_include_module): sometimes cache was mistakenly left
  uncleared - based on the patch by K.Kosako.
@
text
@d6 1
a6 1
  $Date: 2001/03/27 07:10:56 $
a4101 1
#undef HAVE_GETRLIMIT
@


1.137.2.20
log
@* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* class.c (rb_include_module): module inclusion should be check
  taints.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d6 1
a6 1
  $Date: 2001/03/28 08:44:36 $
d505 2
a507 2
	sprintf(buf, "%s=", name);
	id = rb_intern(buf);
@


1.137.2.21
log
@* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE SUMMER TIME!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.
@
text
@d6 1
a6 1
  $Date: 2001/04/03 05:43:49 $
d131 27
a157 2
static VALUE safe_getter _((void));
static void safe_setter _((VALUE val));
a823 5
static NODE *ruby_cref = 0;
static NODE *top_cref;
#define PUSH_CREF(c) ruby_cref = rb_node_newnode(NODE_CREF,(c),0,ruby_cref)
#define POP_CREF() ruby_cref = ruby_cref->nd_next

d1050 1
a1050 3
	top_cref = rb_node_newnode(NODE_CREF,rb_cObject,0,0);
	ruby_cref = top_cref;
	ruby_frame->cbase = (VALUE)ruby_cref;
a1607 17
static NODE*
copy_node_scope(node, rval)
    NODE *node;
    VALUE rval;
{
    NODE *copy = rb_node_newnode(NODE_SCOPE,0,rval,node->nd_next);

    if (node->nd_tbl) {
	copy->nd_tbl = ALLOC_N(ID, node->nd_tbl[0]+1);
	MEMCPY(copy->nd_tbl, node->nd_tbl, ID, node->nd_tbl[0]+1);
    }
    else {
	copy->nd_tbl = 0;
    }
    return copy;
}

a2535 1
	    NODE *saved_cref = 0;
d2543 1
a2543 5
	    if (node->nd_rval) {
		saved_cref = ruby_cref;
		ruby_cref = (NODE*)node->nd_rval;
		ruby_frame->cbase = node->nd_rval;
	    }
a2560 2
	    if (saved_cref)
		ruby_cref = saved_cref;
d2899 1
a2899 1
	    NODE *body,  *defn;
d2941 1
a2941 3

	    defn = copy_node_scope(node->nd_defn, ruby_cref);
	    rb_add_method(ruby_class, node->nd_mid, defn, noex);
d2945 1
a2945 1
			      node->nd_mid, defn, NOEX_PUBLIC);
d2963 1
a2963 1
	    NODE *body = 0, *defn;
d2985 1
a2985 3
	    defn = copy_node_scope(node->nd_defn, ruby_cref);
	    defn->nd_rval = (VALUE)ruby_cref;
	    rb_add_method(klass, node->nd_mid, defn, 
d3183 4
d3192 1
a3204 2
    PUSH_CREF(module);
    ruby_frame->cbase = (VALUE)ruby_cref;
a3214 1
    POP_CREF();
d4316 1
a4316 1
      case NODE_SCOPE:
a4319 1
	    NODE *saved_cref = 0;
d4323 1
a4323 5
	    if (body->nd_rval) {
		saved_cref = ruby_cref;
		ruby_cref = (NODE*)body->nd_rval;
		ruby_frame->cbase = body->nd_rval;
	    }
a4415 1
	    ruby_cref = saved_cref;
a4438 5
	break;

      default:
	rb_bug("unknown node type %d", nd_type(body));
	break;
a5076 1
    NODE *saved_cref = ruby_cref;
a5093 1
    ruby_cref = top_cref;
a5103 1
	PUSH_CREF(ruby_wrapper);
a5145 1
    ruby_cref = saved_cref;
a6323 1
    if (self == other) return Qtrue;
d6325 1
a6325 2
    if (RDATA(other)->dmark != (RUBY_DATA_FUNC)blk_mark) return Qfalse;
    if (CLASS_OF(self) != CLASS_OF(other)) return Qfalse;
d6559 2
a6560 2
    if (OBJ_TAINTED(method) && ruby_safe_level < 4) {
	ruby_safe_level = 4;
a6843 1
    NODE *cref;
a6886 31
/* $SAFE accessor */
void
rb_set_safe_level(level)
    int level;
{
    if (level > ruby_safe_level) {
	ruby_safe_level = level;
	curr_thread->safe = level;
    }
}

static VALUE
safe_getter()
{
    return INT2FIX(ruby_safe_level);
}

static void
safe_setter(val)
    VALUE val;
{
    int level = NUM2INT(val);

    if (level < ruby_safe_level) {
	rb_raise(rb_eSecurityError, "tried to downgrade safe level from %d to %d",
		 ruby_safe_level, level);
    }
    ruby_safe_level = level;
    curr_thread->safe = level;
}

a7028 1
    th->cref = ruby_cref;
a7118 1
    ruby_cref = th->cref;
d7519 1
a7519 8
	    if (n < 0) {
		switch (errno) {
		  case EINTR:
		    return;
		  default:
		    rb_sys_fail("sleep");
		}
	    }
a7922 1
    th->cref = ruby_cref;\
@


1.137.2.22
log
@* file.c (Init_File): should redifine "new" class method.
@
text
@d6 1
a6 1
  $Date: 2001/04/06 05:42:39 $
a6968 1
    rb_gc_mark(th->cref);
@


1.137.2.23
log
@* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.
@
text
@d6 1
a6 1
  $Date: 2001/04/09 04:56:38 $
a4930 1
    PUSH_CREF(under);
a4938 1
    POP_CREF();
@


1.137.2.24
log
@* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).
@
text
@d6 1
a6 1
  $Date: 2001/04/10 06:09:00 $
d1452 1
a1452 1
	if (!NIL_P(cbase->nd_clss)) rb_ary_push(ary, cbase->nd_clss);
d1465 1
a1465 1
	if (!NIL_P(cbase->nd_clss)) rb_mod_const_at(cbase->nd_clss, ary);
d1469 1
a1469 1
    if (!NIL_P(ruby_cbase)) rb_mod_const_of(ruby_cbase, ary);
a6017 1
    struct RVarmap* vars;
a6027 6

	for (vars = tmp->dyna_vars; vars; vars = vars->next) {
	    if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
	    FL_SET(vars, DVAR_DONT_RECYCLE);
	}

a6871 1
    NODE *cref;
a6938 1
    rb_gc_mark((VALUE)th->cref);
a7055 1
    th->cref = ruby_cref;
a7145 1
    ruby_cref = th->cref;
d7550 1
a7550 8
	    if (n < 0) {
		switch (errno) {
		  case EINTR:
		    return;
		  default:
		    rb_sys_fail("sleep");
		}
	    }
a7953 1
    th->cref = ruby_cref;\
a8081 1
    struct BLOCK* saved_block = 0;
d8099 1
a8099 5
	struct BLOCK dummy;

	dummy.prev = ruby_block;
	blk_copy_prev(&dummy);
	saved_block = ruby_block = dummy.prev;
a8125 10

    while (saved_block) {
	struct BLOCK *tmp = saved_block;

	if (tmp->frame.argc > 0)
	    free(tmp->frame.argv);
	saved_block = tmp->prev;
	free(tmp);
    }

@


1.137.2.25
log
@eval.c: malformed patch applied.
@
text
@d6 1
a6 1
  $Date: 2001/04/16 06:54:36 $
d6879 1
d6947 1
d7065 1
d7156 1
d7561 8
d7972 1
@


1.137.2.26
log
@	* eval.c (safe_getter): should use INT2NUM().

	* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.
@
text
@d6 1
a6 1
  $Date: 2001/04/16 08:38:58 $
d6936 1
a6936 1
    return INT2NUM(ruby_safe_level);
@


1.137.2.27
log
@preview2
@
text
@d6 1
a6 1
  $Date: 2001/04/17 08:26:13 $
a5212 1
VALUE ruby_dln_librefs;
a5379 2
	void *handle;

d5382 1
a5382 2
	handle = dln_load(file);
	rb_ary_push(ruby_dln_librefs, INT2NUM((long)handle));
a5949 3

    ruby_dln_librefs = rb_ary_new();
    rb_global_variable(&ruby_dln_librefs);
@


1.137.2.28
log
@m68m frame_pointer patch
@
text
@d6 1
a6 1
  $Date: 2001/04/17 15:35:04 $
d4130 1
a4130 1
# if defined(__GNUC__) && (defined(__i386__) || defined(__m68k__))
@


1.137.2.29
log
@* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.
@
text
@d6 1
a6 1
  $Date: 2001/04/19 09:16:06 $
a1259 1
    VALUE wrapper = ruby_wrapper;
a1270 1
    ruby_wrapper = wrapper;
d4445 1
a4445 1
                   JUMP_TAG(state);
@


1.137.2.30
log
@* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): inifinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe leve 4.
@
text
@d6 1
a6 1
  $Date: 2001/04/24 06:44:12 $
a2373 1
	    VALUE errinfo = ruby_errinfo;
a2376 1
	    ruby_errinfo = errinfo;
d5018 2
a7414 3
		need_select = 1;
	    }
	    if (th->delay == DELAY_INFTY) {
@


1.137.2.31
log
@* eval.c (block_pass): should not downgrade safe level.
@
text
@d6 1
a6 1
  $Date: 2001/05/01 08:45:10 $
a6430 2
	if (safe > ruby_safe_level)
	    ruby_safe_level = safe;
@


1.137.2.32
log
@checkin leftovers
@
text
@d6 1
a6 1
  $Date: 2001/05/02 04:16:27 $
d1847 1
a1847 1
	if (RTEST(rb_reg_nth_defined(node->nd_nth, MATCH_DATA))) {
d1854 1
a1854 1
	if (RTEST(rb_reg_nth_defined(0, MATCH_DATA))) {
@


1.137.2.33
log
@* eval.c (eval): preserve and restore ruby_cref as well.
@
text
@d6 1
a6 1
  $Date: 2001/05/07 06:18:44 $
a4750 1
    VALUE volatile old_cref;
a4780 2
	old_cref = (VALUE)ruby_cref;
	ruby_cref = (NODE*)ruby_frame->cbase;
a4815 1
	ruby_cref  = (NODE*)old_cref;
@


1.137.2.34
log
@* parse.y (arg): "||=" should not warn for uninitialized instance
  variables.

* eval.c (rb_eval): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/05/07 08:39:26 $
d2637 4
a2640 6
	if ((node->nd_aid && !rb_ivar_defined(self, node->nd_aid)) ||
	    !RTEST(result = rb_eval(self, node->nd_head))) {
	    node = node->nd_value;
	    goto again;
	}
	break;
@


1.137.2.35
log
@* eval.c (is_defined): core dumped during instance_eval for
  special constants.

* eval.c (rb_eval): ditto
@
text
@d6 1
a6 1
  $Date: 2001/05/07 09:24:34 $
a1807 6
	if (NIL_P(ruby_cbase)) {
	    if (rb_cvar_defined(CLASS_OF(self), node->nd_vid)) {
		return "class variable";
	    }
	    break;
	}
a2724 4
	if (NIL_P(ruby_cbase)) {
	    result = rb_cvar_get(CLASS_OF(self), node->nd_vid);
	    break;
	}
@


1.137.2.36
log
@* array.c (rb_ary_and): should not push frozen key string.

* array.c (rb_ary_or): ditto.

* eval.c (rb_thread_schedule): should save context before raising
  deadlock, saved context for current thread might be obsolete.

* time.c (make_time_t): non DST timezone shift supported (hopefully).

* signal.c: SIGINFO added.

* eval.c (rb_ensure): should not SEGV when prot_tag is NULL.
@
text
@d6 1
a6 1
  $Date: 2001/05/08 08:29:51 $
d3994 1
a3994 1
    retval = prot_tag ? prot_tag->retval : Qnil;	/* save retval */
d3996 1
a3996 1
    if (prot_tag) return_value(retval);
a7540 1
	rb_thread_save_context(curr_thread);
@


1.137.2.37
log
@* eval.c (rb_call0): address of local_vars might change during eval.
@
text
@d6 1
a6 1
  $Date: 2001/05/15 08:49:21 $
a4423 2
			    VALUE v;

d4425 1
a4425 1
				v = rb_ary_new4(argc,argv);
d4427 1
a4427 2
				v = rb_ary_new2(0);
			    local_vars[node->nd_rest] = v;
@


1.137.2.38
log
@* eval.c (rb_yield_0): need argument adjustment for C defined
  blocks too.
@
text
@d6 1
a6 1
  $Date: 2001/05/17 08:49:00 $
a3560 7
    }
    else {
	/* argument adjust for proc_call etc. */
	if (acheck && val != Qundef &&
	    TYPE(val) == T_ARRAY && RARRAY(val)->len == 1) {
	    val = RARRAY(val)->ptr[0];
	}
@


1.137.2.39
log
@* string.c (rb_str_replace): add taint status infection
  (OBJ_INFECT()).

* string.c (rb_str_crypt): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/05/24 05:26:20 $
a17 1
#include "util.h"
@


1.137.2.40
log
@* regex.c (re_compile_pattern): no back reference to a
  subexpression if inside of it.

* eval.c (rb_yield_0): preserve and restore ruby_cref as well.
@
text
@d6 1
a6 1
  $Date: 2001/05/25 15:01:06 $
a3505 1
    volatile VALUE old_cref;
a3521 2
    old_cref = (VALUE)ruby_cref;
    ruby_cref = (NODE*)ruby_frame->cbase;
a3645 1
    ruby_cref = (NODE*)old_cref;
@


1.137.2.41
log
@* eval.c (rb_add_method): should not call rb_secure(), for
  last_func may not be set.

* io.c (rb_io_ctl): ioctl should accept any integer within C long
  range.
@
text
@d6 1
a6 1
  $Date: 2001/05/29 08:59:36 $
d230 4
a233 1
    if (rb_safe_level() >= 4 && (klass == rb_cObject || !OBJ_TAINTED(klass))) {
@


1.137.2.42
log
@* eval.c (rb_load): should check if tainted even when wrap is
  specified.

* regex.c (re_compile_pattern): too much optimization for the
  cases like /(.|a)b/.

* variable.c (fc_i): removed vast string allocation.
@
text
@d6 1
a6 1
  $Date: 2001/06/05 06:40:49 $
d5131 6
a5136 1
    Check_SafeStr(fname);
@


1.137.2.43
log
@* hash.c (ruby_setenv): readline library leaves their environment
  strings uncopied.  "free" check revised.

* st.c (numhash): should shuffle bits by dividing by prime number.
@
text
@d6 1
a6 1
  $Date: 2001/06/06 07:39:38 $
a5402 2
    {
	int old_vmode = scope_vmode;
d5404 3
a5406 3
	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    void *handle;
d5408 4
a5411 8
	    SCOPE_SET(SCOPE_PUBLIC);
	    load = rb_str_new2(file);
	    file = RSTRING(load)->ptr;
	    handle = dln_load(file);
	    rb_ary_push(ruby_dln_librefs, INT2NUM((long)handle));
	}
	POP_TAG();
	SCOPE_SET(old_vmode);
d5413 1
@


1.137.2.44
log
@* eval.c (rb_f_require): searches ".rb" and ".so" at the same
  time.  previous behavior (search ".rb", then ".so") has a
  security risk (ruby-bugs#PR140).

* regex.c (re_compile_pattern): avoid pushing unnecessary
  option_set.

* eval.c (rb_load): tainted string is OK if wrapped *and*
  $SAFE >= 4.

* eval.c (rb_thread_start_0): should not nail down higher blocks
  before preserving original context (i.e. should not alter
  original context).
@
text
@d6 1
a6 1
  $Date: 2001/06/11 06:26:16 $
d5131 1
a5131 6
    if (wrap && ruby_safe_level >= 4) {
	Check_Type(fname, T_STRING);
    }
    else {
	Check_SafeStr(fname);
    }
d5376 2
a5377 5
    switch (rb_find_file_noext(buf)) {
      case 0:
	break;

      case 1:
d5379 1
a5379 1
	file = feature = buf;
d5381 13
a5393 2

      default:
a5394 1
	file = rb_find_file(buf);
d5397 1
a8147 5
    FL_SET(ruby_scope, SCOPE_SHARED);
    if (THREAD_SAVE_CONTEXT(curr_thread)) {
	return thread;
    }

d8156 4
@


1.137.2.45
log
@* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.
@
text
@d6 1
a6 1
  $Date: 2001/06/19 04:36:34 $
d4130 1
a4130 1
static unsigned int STACK_LEVEL_MAX = 65535;
d4133 1
a4133 1
extern unsigned int _stacksize;
d4138 1
a4138 1
static unsigned int STACK_LEVEL_MAX = 655300;
@


1.137.2.46
log
@* eval.c (rb_eval_string_wrap): extend new ruby_top_self, not
  original self.

* eval.c (rb_eval_cmd): respect ruby_wrapper if set.

* eval.c (eval): do not update ruby_class unless scope is not
  provided.

* eval.c (eval): preserve wrapper information.

* eval.c (proc_invoke): ditto.

* eval.c (block_pass): ditto.

* parse.y (void_expr): too much warnings for void context
  (e.g. foo[1] that can be mere Proc call).
@
text
@d6 1
a6 1
  $Date: 2001/06/29 08:32:51 $
a540 1
    VALUE wrapper;
d1264 1
a1264 1
    rb_extend_object(ruby_top_self, ruby_class);
d1327 1
a1327 1
    ruby_class = ruby_wrapper ? ruby_wrapper : rb_cObject;
a4776 1
    volatile VALUE old_wrapper;
a4786 1
    PUSH_CLASS();
a4807 2
	old_wrapper = ruby_wrapper;
	ruby_wrapper = data->wrapper;
a4810 1
	ruby_class = ruby_cbase;
d4817 2
a4842 1
	ruby_wrapper = old_wrapper;
a6018 1
	rb_gc_mark(data->wrapper);
a6132 1
    data->wrapper = ruby_wrapper;
a6221 1
    data->wrapper = ruby_wrapper;
a6300 1
    volatile VALUE old_wrapper = ruby_wrapper;
a6310 2
    ruby_wrapper = data->wrapper;

a6336 1
    ruby_wrapper = old_wrapper;
a6429 1
    volatile VALUE old_wrapper = ruby_wrapper;
a6444 2
    ruby_wrapper = data->wrapper;

a6481 1
    ruby_wrapper = old_wrapper;
@


1.137.2.47
log
@* eval.c (rb_f_require): move rb_file_s_expand_path from
  rb_find_file_noext().

* file.c (rb_find_file_noext): move rb_file_s_expand_path to
  rb_f_require().

* string.c (rb_str_each_line): should propagate taint mark.

* ext/nkf/nkf.c (rb_nkf_kconv): ditto.

* ruby.c (load_file): local variables 'c' remain uninitialized on
  xflag.

* regex.c (re_match): prefetched escaped character too early.

* eval.c (rb_call0): add argument check for attr_readers.
@
text
@d6 1
a6 1
  $Date: 2001/07/02 08:43:26 $
d1265 1
a1265 6
    rb_extend_object(ruby_top_self, ruby_wrapper);
    PUSH_FRAME();
    ruby_frame->last_func = 0;
    ruby_frame->last_class = 0;
    ruby_frame->self = self;
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,ruby_wrapper,0,0);
a1269 1
    POP_FRAME();
d1323 2
a1326 5
    PUSH_FRAME();
    ruby_frame->last_func = 0;
    ruby_frame->last_class = 0;
    ruby_frame->self = ruby_top_self;
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,ruby_wrapper,0,0);
d1328 1
a1332 1
    PUSH_TAG(PROT_NONE);
d1342 1
a1342 1
    POP_FRAME();
d4334 2
d4337 1
a4338 6
	if (argc != 0) {
	    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)", argc);
	}
      case NODE_ATTRSET:
	/* for re-scoped/renamed method */
      case NODE_ZSUPER:
d4789 1
d4816 1
a4822 2
    PUSH_CLASS();
    ruby_class = ruby_cbase;
d5384 1
a5384 6
    obj = fname;
    if (RSTRING(fname)->ptr[0] == '~') {
	obj = rb_file_s_expand_path(1, &fname);
	StringValue(obj);
    }
    buf = ALLOCA_N(char, strlen(RSTRING(obj)->ptr) + 5);
@


1.137.2.48
log
@* remove StringValue (1.7 feature) from eval.c
@
text
@d6 1
a6 1
  $Date: 2001/07/06 06:36:58 $
d5399 1
@


1.137.2.49
log
@* eval.c: wrapper modifies updated to 1.7 changes.

* object.c (rb_obj_dup): should free generic_ivar if original owns
  them.
@
text
@d6 1
a6 1
  $Date: 2001/07/06 08:54:18 $
a576 1
    _block.wrapper = ruby_wrapper;	\
d3514 2
a3515 3
    volatile VALUE old_wrapper;
    struct BLOCK * volatile block;
    struct SCOPE * volatile old_scope;
a3531 2
    old_wrapper = ruby_wrapper;
    ruby_wrapper = block->wrapper;
a3656 1
    ruby_wrapper = old_wrapper;
d6337 1
d6458 1
d6474 2
d6513 1
@


1.137.2.50
log
@* eval.c (proc_invoke): should preserve iter status for embedded
  frame in the block.

* file.c (rb_file_s_expand_path): may overrun buffer on stack.

* regex.c (re_search): should consider reverse search.
@
text
@d6 1
a6 1
  $Date: 2001/07/13 05:50:03 $
d6346 1
@


1.137.2.51
log
@back port from 1.7
@
text
@d6 1
a6 1
  $Date: 2001/07/16 04:01:42 $
a5144 1
    VALUE tmp;
d5146 1
d5159 2
a5160 2
    tmp = rb_find_file(fname);
    if (!tmp) {
a5162 1
    fname = tmp;
d5187 10
d5199 1
d5208 1
a5208 1
	rb_load_file(RSTRING(fname)->ptr);
d5274 1
a5274 1
    VALUE v;
d5276 1
a5276 1
    int i, len = strlen(feature);
d5278 4
a5281 3
    for (i = 0; i < RARRAY(rb_features)->len; ++i) {
	v = RARRAY(rb_features)->ptr[i];
	f = STR2CSTR(v);
d5285 1
d5295 1
d5324 3
a5326 3
static void
rb_provide_feature(feature)
    VALUE feature;
d5328 1
a5328 2
    char *ext;
    char *f = RSTRING(feature)->ptr;
d5330 1
a5330 1
    ext = strrchr(f, '.');
d5336 5
a5340 2
	feature = rb_str_new(RSTRING(feature)->ptr, ext-RSTRING(feature)->ptr);
	rb_str_cat2(feature, ".so");
d5342 2
a5343 9
    if (rb_feature_p(RSTRING(feature)->ptr, Qtrue)) return;
    rb_ary_push(rb_features, feature);
}

void
rb_provide(feature)
    const char *feature;
{
    rb_provide_feature(rb_str_new2(feature));
d5350 1
a5350 2
    VALUE feature, tmp;
    char *ext, *ftptr; /* OK */
d5360 1
d5362 2
a5363 6
	    feature = rb_str_dup(fname);
	    tmp = rb_find_file(fname);
	    if (tmp) {
		fname = tmp;
		goto load_rb;
	    }
d5366 6
a5371 7
	    fname = rb_str_new(RSTRING(fname)->ptr, ext-RSTRING(fname)->ptr);
	    tmp = rb_str_dup(fname);
	    rb_str_cat2(tmp, DLEXT);
	    tmp = rb_find_file(tmp);
	    if (tmp) {
		feature = fname = tmp;
		goto load_dyna;
d5373 2
d5376 7
a5382 6
	    tmp = rb_str_dup(fname);
	    rb_str_cat2(tmp, DLEXT);
	    tmp = rb_find_file(tmp);
	    if (tmp) {
		feature = fname = tmp;
		goto load_dyna;
d5384 2
d5389 3
a5391 5
	    tmp = rb_find_file(fname);
	    if (tmp) {
		feature = fname = tmp;
		goto load_dyna;
	    }
d5395 3
a5397 5
	    tmp = rb_find_file(fname);
	    if (tmp) {
		feature = fname = tmp;
		goto load_dyna;
	    }
d5401 7
a5407 2
    tmp = fname;
    switch (rb_find_file_noext(&tmp)) {
d5412 2
a5413 2
	feature = fname;
	fname = tmp;
d5417 2
a5418 2
	feature = fname;
	fname = rb_find_file(tmp);
d5425 1
a5425 1
    rb_provide_feature(feature);
d5427 1
a5427 1
	int volatile old_vmode = scope_vmode;
d5434 3
a5436 1
	    handle = dln_load(RSTRING(fname)->ptr);
d5448 1
a5448 1
    rb_provide_feature(feature);
d5454 1
a5454 2
    ftptr = ruby_strdup(RSTRING(feature)->ptr);
    st_insert(loading_tbl, ftptr, curr_thread);
d5461 2
a5462 2
    st_delete(loading_tbl, &ftptr, 0); /* loading done */
    free(ftptr);
a5645 1
	rb_funcall(argv[i], rb_intern("included"), 1, module);
@


1.137.2.52
log
@too much backport from 1.7 canceled.
@
text
@d6 1
a6 1
  $Date: 2001/07/19 07:59:47 $
d5636 1
@


1.137.2.53
log
@* eval.c (rb_provide_feature): should not tweak extension used for
  loading.

* eval.c (rb_f_require): should not include path in $" value

* file.c (rb_find_file): should return 0 explicitly on failure.
@
text
@d6 1
a6 1
  $Date: 2001/07/19 08:27:53 $
d5315 13
d5363 1
a5363 1
	    feature = tmp = rb_str_dup(fname);
d5367 1
a5367 1
		fname = tmp;
d5371 1
a5371 1
	    feature = tmp = rb_str_dup(fname);
d5375 1
a5375 1
		fname = tmp;
d5383 1
a5383 2
		feature = fname;
		fname = tmp;
d5391 1
a5391 2
		feature = fname;
		fname = tmp;
d5403 2
a5404 1
	feature = fname = tmp;
d5408 1
a5408 1
	feature = tmp;
@


1.137.2.54
log
@* eval.c (rb_eval): add CHECK_INTS before next, redo, retry to
  avoid potential uninterruptable infinite loop.

* file.c (rb_file_s_expand_path): should not expand "." and ".."
  not following dirsep.

* eval.c (rb_provide_feature): should not tweak extension used for
  loading.
@
text
@d6 1
a6 1
  $Date: 2001/07/24 09:02:48 $
a2303 1
	CHECK_INTS;
a2307 1
	CHECK_INTS;
a2311 1
	CHECK_INTS;
@


1.137.2.55
log
@* eval.c (rb_provided): extension should be guessed using
  rb_find_file_noext().

* eval.c (rb_f_require): should call rb_feature_p() after
  extension completion.
@
text
@d6 1
a6 1
  $Date: 2001/07/27 08:54:48 $
d5311 1
a5311 8
    VALUE f = rb_str_new2(feature);

    if (strrchr(feature, '.') == 0) {
	if (rb_find_file_noext(&f) == 0) {
	    return Qfalse;
	}
    }
    return rb_feature_p(RSTRING(f)->ptr, Qfalse);
d5339 2
a5406 2
    if (rb_feature_p(RSTRING(feature)->ptr, Qfalse))
	return Qfalse;
a5426 2
    if (rb_feature_p(RSTRING(feature)->ptr, Qtrue))
	return Qfalse;
@


1.137.2.56
log
@* struct.c (rb_struct_modify): should check frozen and taint
  status.

* eval.c (rb_undefined): do not recurse if method_missing is
  undefined.
@
text
@d6 1
a6 1
  $Date: 2001/07/27 09:08:54 $
a4137 8
    last_call_status = call_status;

    if (id == missing) {
	PUSH_FRAME();
	rb_f_missing(argc, argv, obj);
	POP_FRAME();
    }

d4141 2
@


1.137.2.57
log
@* eval.c (rb_mark_end_proc): should mark ruby_cref, maybe should
  not be here, but it's simplest way for a kludge.
@
text
@d6 1
a6 1
  $Date: 2001/08/06 03:10:23 $
a5819 2
    /* static global mark */
    rb_gc_mark((VALUE)ruby_cref);
@


1.137.2.58
log
@* eval.c (is_defined): should not dump core for "defined?(())".

* eval.c (umethod_bind): recv can be an instance of descender of
  oklass if oklass is a Module.

* hash.c (rb_hash_equal): check identiry equality first.

* variable.c (mod_av_set): detect constant overriding for built-in
  classes/modules.

* marshal.c (w_object): should retrieve __member__ data from
  non-singleton class.
@
text
@d6 1
a6 1
  $Date: 2001/08/06 08:03:30 $
a1720 1
    if (!node) return "expression";
d6696 2
a6697 4
	if (!((TYPE(data->oklass) == T_MODULE) ?
	      rb_obj_is_kind_of(recv, data->oklass) :
	      rb_obj_is_instance_of(recv, data->oklass))) {
	    rb_raise(rb_eTypeError, "bind argument must be an instance of %s",
@


1.137.2.59
log
@* io.c (rb_io_popen): accept integer flags as mode.

* file.c (rb_find_file_ext): extension table can be supplied from
  outside.  renamed.

* eval.c (rb_f_require): replace rb_find_file_noext by
  rb_find_file_ext.

* eval.c (rb_provided): should also check feature without
  extension.

* numeric.c (flo_to_s): do not rely on decimal point to be '.'

* parse.y (yylex): ternary ? can be followed by newline.
@
text
@d6 1
a6 1
  $Date: 2001/08/23 06:00:30 $
a5313 8
static const char *const loadable_ext[] = {
    ".rb", DLEXT,
#ifdef DLEXT2
    DLEXT2,
#endif
    0
};

d5321 2
a5322 2
	if (rb_find_file_ext(&f, loadable_ext) == 0) {
	    return rb_feature_p(feature, Qfalse);
d5365 5
a5369 5
#ifdef DLEXT2
	    tmp = fname;
	    if (rb_find_file_ext(&tmp, loadable_ext+1)) {
		feature = tmp;
		fname = rb_find_file(tmp);
d5372 1
a5372 1
#else
d5402 1
a5402 1
    switch (rb_find_file_ext(&tmp, loadable_ext)) {
@


1.137.2.60
log
@* eval.c (rb_f_require): should check static linked libraries\
  before raising exception(from 1.7).
@
text
@d6 1
a6 1
  $Date: 2001/09/03 05:29:17 $
a5422 2
    if (rb_feature_p(RSTRING(fname)->ptr, Qfalse))
	return Qfalse;
@


1.137.2.61
log
@* class.c (rb_include_module): should check whole ancestors to
  avoid duplicate module inclusion.

* string.c (trnext): should check backslash before updating "now"
  position.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/09/03 05:40:56 $
d5314 1
a5314 1
static const char * const loadable_ext[] = {
@


1.137.2.62
log
@* eval.c (rb_thread_restore_context): save current value of
  lastline and lastmatch in the thread struct for later restore.

* eval.c (rb_thread_save_context): restore lastline and lastmatch.

* numeric.c (flo_to_s): should handle negative float value.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/09/06 07:47:46 $
a7156 1
    static VALUE tval;
d7184 2
a7185 6
    tval = rb_lastline_get();
    rb_lastline_set(th->last_line);
    th->last_line = tval;
    tval = rb_backref_get();
    rb_backref_set(th->last_match);
    th->last_match = tval;
a7248 1
    static VALUE tval;
a7284 1
    tval = rb_lastline_get();
a7285 2
    tmp->last_line = tval;
    tval = rb_backref_get();
a7286 1
    tmp->last_match = tval;
@


1.137.2.63
log
@small last minute changes (eval.c, file.c)
@
text
@d6 1
a6 1
  $Date: 2001/09/08 14:05:50 $
d8099 1
a8099 1
    th->last_match = Qnil;\
@


1.137.2.64
log
@* ext/socket/socket.c (unix_addr): getsockname(2) may result len = 0.

* ext/socket/socket.c (unix_peeraddr): getpeername(2) may result
  len = 0.

* eval.c (POP_BLOCK): rb_gc_force_recycle() was called too much.
  Should not be called if SCOPE_DONT_RECYCLE is set.

* string.c (rb_str_substr): should return an instance of
  receiver's class.

* string.c (rb_str_succ): ditto.

* array.c (rb_ary_subseq): ditto.

* string.c (rb_str_reverse): should return an instance of
  reciever's class.

* string.c (rb_str_times): ditto.

* array.c (rb_ary_times): ditto

* string.c (str_gsub): ditto.

* string.c (rb_str_ljust): ditto.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/09/18 03:47:02 $
d580 7
d588 1
a588 4
   if (_block.tag->flags & (BLOCK_DYNAMIC)) \
       _block.tag->flags |= BLOCK_ORPHAN; \
   else	if (!(_block.scope->flag & SCOPE_DONT_RECYCLE)) \
       rb_gc_force_recycle((VALUE)_block.tag); \
d4812 4
a4838 5
	if ((file == 0 || (line == 1 && strcmp(file, "(eval)") == 0)) &&
	    data->body && data->body->nd_file) {
	    file = data->body->nd_file;
	    line = nd_line(data->body);
	}
a4846 4
    }
    if (file == 0) {
	file = ruby_sourcefile;
	line = ruby_sourceline;
@


1.137.2.65
log
@* eval.c (rb_eval): should override existing class.
@
text
@d6 1
a6 1
  $Date: 2001/10/02 04:25:51 $
d3085 1
@


1.137.2.66
log
@* eval.c (thread_status_name): separated from
  rb_thread_inspect(). return string expression for thread status.

* eval.c (rb_thread_status, rb_thread_inspect): use
  thread_status_name().

* eval.c (rb_thread_priority_set): return the priority not but
  self.
@
text
@d6 1
a6 1
  $Date: 2001/10/02 09:36:23 $
a6999 18
static const char *
thread_status_name(status)
    enum thread_status status;
{
    switch (status) {
      case THREAD_RUNNABLE:
	return "run";
      case THREAD_STOPPED:
	return "sleep";
      case THREAD_TO_KILL:
	return "aborting";
      case THREAD_KILLED:
	return "dead";
      default:
	return "unknown";
    }
}

d8017 1
a8017 1
    return prio;
d8357 3
a8359 1
    return rb_str_new2(thread_status_name(th->status));
d8614 1
a8614 1
    const char *status = thread_status_name(th->status);
d8617 12
@


1.137.2.67
log
@eval.c commit.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/10/09 08:19:46 $
d2034 2
a2035 2
	    if (TYPE(l) == T_STRING) {
		result = rb_reg_match(r, l);
d2038 1
a2038 1
		result = rb_funcall(l, match, 1, r);
@


1.137.2.68
log
@* eval.c (rb_f_missing): check stack level with rb_stack_check().

* eval.c (rb_call0): ditto.

* eval.c, intern.h (rb_stack_check): added. [new]
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/09 15:03:19 $
a4067 2
    rb_stack_check();

a4191 8
void
rb_stack_check()
{
    if (stack_length(0) > STACK_LEVEL_MAX) {
	rb_raise(rb_eSysStackError, "stack level too deep");
    }
}

d4307 3
a4309 1
	rb_stack_check();
@


1.137.2.69
log
@* parse.y (str_extend): shuould allow interpolation of $-x.

* bignum.c (rb_big_eq): convert Bignum to Float, instead of
  reverse.

* time.c (time_localtime): getting tm should not be prohibited for
  frozen time objects.

* time.c (time_gmtime): ditto.

* version.c (Init_version): freeze RUBY_VERSION,
  RUBY_RELEASE_DATE, and RUBY_PLATFORM.

* file.c (Init_File): freeze File::SEPARATOR, ALT_SEPARATOR and
  PATH_SEPARATOR.

* file.c (rb_stat_cmp): should check operand type before calling
  get_stat().

* eval.c (rb_eval_cmd): should not invoke "call" with a block on
  any occasion.

* numeric.c (fix_aref): idx may be a Bignum.

* numeric.c (num_remainder): a bug in Numeric#remainder.

* eval.c (rb_exec_end_proc): END might be called within END
  block.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/10/16 15:17:09 $
d1322 2
a1323 4
	PUSH_ITER(ITER_NOT);
	val = rb_funcall2(cmd, rb_intern("call"), RARRAY(arg)->len, RARRAY(arg)->ptr);
	POP_ITER();
	return val;
d5880 1
a5880 1
    struct end_proc_data *link, *save;
d5883 1
a5883 1
    save = link = end_procs;
a5884 8
	rb_protect((VALUE(*)())link->func, link->data, &status);
	if (status) {
	    error_handle(status);
	}
	link = link->next;
    }
    link = end_procs;
    while (link != save) {
@


1.137.2.70
log
@* eval.c (rb_f_eval): can't modify untainted binding.

* regex.c (re_compile_pattern): should preverve p0 value.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/10/29 05:04:40 $
a4963 3
	if (!NIL_P(scope) && !OBJ_TAINTED(scope)) {
	    rb_raise(rb_eSecurityError, "Insecure: can't modify trusted binding");
	}
@


1.137.2.71
log
@* eval.c (POP_VARS): should not set DVAR_DONT_RECYCLE if _old
  ruby_vars is already force_recycled.
@
text
@d6 1
a6 1
  $Date: 2001/10/30 08:42:20 $
d596 1
a596 2
       if (RBASIC(_old)->flags) /* unless it's already recycled */ \
           FL_SET(_old, DVAR_DONT_RECYCLE); \
@


1.137.2.72
log
@* eval.c (exec_under): should initialize ruby_frame->self;
@
text
@d6 1
a6 1
  $Date: 2001/10/31 06:52:24 $
a5001 1
    ruby_frame->self = _frame.prev->self;
@


1.137.2.73
log
@* dir.c (my_getcwd): do not rely on MAXPATHLEN.

* eval.c (rb_yield_0): should not call rb_f_block_given_p().
@
text
@d6 1
a6 1
  $Date: 2001/10/31 07:59:54 $
d3505 1
a3505 2
    if (ruby_frame->prev && ruby_frame->prev->iter && ruby_block)
	return Qtrue;
d3524 2
a3525 2
    if (!rb_block_given_p()) {
	rb_raise(rb_eLocalJumpError, "no block given");
d4473 1
a4473 1
			    ruby_scope->local_vars[node->nd_rest] = v;
@


1.137.2.74
log
@* eval.c (rb_trap_eval): avoid annoying warning with signal.
  [ruby-talk:23225]

* eval.c (rb_call0): adjust caller source file/line while
  evaluating optional arguments.
@
text
@d6 1
a6 1
  $Date: 2001/11/07 09:01:30 $
a1365 1
    PUSH_ITER(ITER_NOT);
a1368 1
    POP_ITER();
d4465 1
a4465 5
			    if (opt) {
				ruby_sourcefile = opt->nd_file;
				ruby_sourceline = nd_line(opt);
				rb_eval(recv, opt);
			    }
@


1.137.2.75
log
@* signal.c (sighandle): should not re-register sighandler if
  POSIX_SIGNAL is defined.

* eval.c (error_print): errat array may be empty.

* parse.y (yylex): float '1_.0' should not be allowed.

* variable.c (var_getter): should care about var as Qfalse
  (ruby-bugs#PR199).

* array.c (cmpint): <=> or block for {min,max} may return bignum.

* array.c (sort_1): use rb_compint.

* array.c (sort_2): ditto.

* enum.c (min_ii): ditto.

* enum.c (min_ii): ditto.

* enum.c (max_i): ditto.

* enum.c (max_ii): ditto.

* mkconfig.rb: use String#dump to generate Ruby string literal.

* range.c (range_eql): should override 'eql?'
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/11/08 12:42:39 $
a904 3
    }
    else if (RARRAY(errat)->len == 0) {
	error_pos();
@


1.137.2.76
log
@* parse.y (parse_regx): should raise error on untermitated
  expression interpolation.

* pack.c (pack_unpack): should give length to utf8_to_uv().

* pack.c (utf8_to_uv): add length check.

* eval.c (rb_thread_wait_for): select may cause ERESTART on
  Solaris.

* eval.c (rb_thread_select): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/11/13 08:22:26 $
a7575 3
#ifdef ERESTART
	    if (erestart == ERESTART) goto again;
#endif
a7732 3
#ifdef ERESTART
		  case ERESTART:
#endif
d7804 3
a7806 7
		switch (errno) {
		  case EINTR:
#ifdef ERESTART
		  case ERESTART:
#endif
		    if (timeout) {
			double d = timeofday() - limit;
d7808 2
a7809 6
			tv.tv_sec = (unsigned int)d;
			tv.tv_usec = (long)((d-(double)tv.tv_sec)*1e6);
		    }
		    continue;
		  default:
		    break;
d7811 1
d7820 2
a7821 8
	    if (n < 0) {
		switch (errno) {
		  case EINTR:
#ifdef ERESTART
		  case ERESTART:
#endif
		    continue;
		}
@


1.137.2.77
log
@* eval.c : fix typo. erestart -> errno. rb_thread_wait_for().
@
text
@d6 1
a6 1
  $Date: 2001/11/19 04:58:03 $
d7577 1
a7577 1
	    if (errno == ERESTART) goto again;
d7810 2
a7811 2
	    switch (errno) {
	      case EINTR:
d7813 1
a7813 1
	      case ERESTART:
d7815 2
a7816 2
		if (timeout) {
		    double d = timeofday() - limit;
d7818 6
a7823 2
		    tv.tv_sec = (unsigned int)d;
		    tv.tv_usec = (long)((d-(double)tv.tv_sec)*1e6);
a7824 3
		continue;
	      default:
		break;
@


1.137.2.78
log
@* eval.c : oops.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2001/11/19 07:48:23 $
d7810 2
a7811 3
	    if (n < 0) {
		switch (errno) {
		  case EINTR:
d7813 1
a7813 1
		  case ERESTART:
d7815 2
a7816 2
		    if (timeout) {
			double d = timeofday() - limit;
d7818 2
a7819 6
			tv.tv_sec = (unsigned int)d;
			tv.tv_usec = (long)((d-(double)tv.tv_sec)*1e6);
		    }
		    continue;
		  default:
		    break;
d7821 3
@


1.137.2.79
log
@* parse.y (str_extend): should check nesting parentheses in #{}.

* eval.c (rb_thread_select): tv_sec and tv_usec should not be
  negative.

* signal.c (posix_signal): do not set SA_RESTART for SIGVTALRM.
@
text
@d6 1
a6 1
  $Date: 2001/11/19 08:15:25 $
a7820 2
			if (tv.tv_sec < 0)  tv.tv_sec = 0;
			if (tv.tv_usec < 0) tv.tv_usec = 0;
@


1.137.2.80
log
@* eval.c (rb_thread_select): should subtract timeofday() from
  limit, not reverse.

* util.c (scan_hex): x is not a hexadecimal digit.

* eval.c (rb_thread_schedule): should treat the case that
  select(2) returns 0, if a thread is under both WAIT_SELECT and
  WAIT_TIME.  Jakub Travnik <J.Travnik@@sh.cvut.cz> actually fixed
  this bug.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/11/21 15:35:57 $
a7489 1
    int select_timeout = 0;
a7532 3
	    if (th->wait_for & WAIT_TIME) {
		select_timeout = 1;
	    }
a7593 15
 	if (select_timeout && n == 0) {
 	    if (now < 0.0) now = timeofday();
 	    FOREACH_THREAD_FROM(curr, th) {
 		if ((th->wait_for & (WAIT_SELECT|WAIT_TIME)) && th->delay < now) {
 		    th->status = THREAD_RUNNABLE;
 		    th->wait_for = 0;
 		    th->select_value = 0;
 		    found = 1;
                    intersect_fds(&readfds, &th->readfds, max);
                    intersect_fds(&writefds, &th->writefds, max);
                    intersect_fds(&exceptfds, &th->exceptfds, max);
		}
	    }
	    END_FOREACH_FROM(curr, th);
	}
d7817 1
a7817 1
                       double d = limit - timeofday();
@


1.137.2.81
log
@* time.c (time_new_internal): round usec overflow and underflow
  here.

* time.c (time_plus): remove overflow/underflow check.

* time.c (time_minus): ditto.

* time.c (time_cmp): should consider tv_usec too.

* time.c (time_gmtime): time_modify() should be called even if tm
  struct is not calculated yet.

* string.c (rb_str_equal): object with to_str must be treated as a
  string.
@
text
@d6 1
a6 1
  $Date: 2001/11/28 14:52:57 $
d7601 1
a7601 1
 		if ((th->wait_for & (WAIT_SELECT|WAIT_TIME)) && th->delay <= now) {
@


1.137.2.82
log
@* intern.h: add prototypes.
  rb_str_dup_frozen()

* ruby.h: added declaration.
  rb_defout, rb_stdin, rb_stdout, rb_stderr, ruby_errinfo

* rubyio.h: changed double include guard macro to RUBYIO_H.

* array.c (inspect_call): make static.

* eval.c (dvar_asgn): ditto.

* io.c (rb_io_close_read): ditto.

* lex.c (rb_reserved_word): ditto.

* ruby.c: (req_list_head, req_list_last): ditto.

* ruby.c (require_libraries): ditto.
@
text
@d6 1
a6 1
  $Date: 2001/12/03 10:06:38 $
d697 1
a697 1
static void
@


1.137.2.83
log
@* eval.c (rb_thread_schedule): should not select a thread which is
  not yet initialized.

* variable.c (find_class_path): should initialize iv_tbl if it's
  NULL.

* class.c (rb_define_class): should return the existing class if
  the class is already defined and its superclass is ideintical to
  the specified superclass.

* class.c (rb_define_class_under): ditto.

* class.c (rb_define_module): should return the existing module if
  the module is already defined.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/12/17 08:13:16 $
d3085 7
a3091 1
		    tmp = rb_class_real(RCLASS(klass)->super);
d7653 1
a7653 1
	if (th->status == THREAD_RUNNABLE && th->stk_ptr) {
@


1.137.2.84
log
@* eval.c (rb_mod_define_method): define_method should follow
  default method visibility.

* eval.c (rb_attr): should warn if the default method visibility
  is "module_function" (can be error).

* eval.c (rb_mod_define_method): should define class/module method
  also if the visibility is "module_function".

* eval.c (rb_mod_define_method): should call hook method
  "method_added", and "singleton_method_added".

* ext/socket/socket.c (bsock_send): should raise EWOULDBLOCK
  exception.

* ext/socket/socket.c (s_recvfrom): ditto.

* ext/socket/socket.c (s_accept): ditto.

* ext/socket/socket.c (udp_send): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2001/12/18 08:40:30 $
d356 1
a357 1
	rb_add_method(klass, mid, 0, NOEX_UNDEF);
d406 1
a407 1
	    rb_add_method(klass, name, NEW_ZSUPER(), noex);
d456 1
a456 3
	    rb_warning((scope_vmode == SCOPE_MODFUNC) ?
		       "attribute accessor as module_function" :
		       "private attribute?");
d474 1
a475 1
	rb_add_method(klass, id, NEW_IVAR(attriv), noex);
d481 1
a482 1
	rb_add_method(klass, id, NEW_ATTRSET(attriv), noex);
d1550 1
a1551 1
    rb_add_method(klass, id, 0, NOEX_PUBLIC);
a1591 1
    rb_clear_cache_by_id(name);
d1594 1
d2982 1
a2983 1
	    rb_add_method(ruby_class, node->nd_mid, defn, noex);
a3027 1
	    rb_clear_cache_by_id(node->nd_mid);
d3030 1
d5637 1
a5638 1
	rb_add_method(rb_singleton_class(module), id, body->nd_body, NOEX_PUBLIC);
a6864 2
    NODE *node;
    int noex;
a6872 7
	if (rb_obj_is_kind_of(body, rb_cMethod)) {
	    body = method_proc(body);
	}
	else if (!rb_obj_is_proc(body)) {
	    rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc)",
		     rb_class2name(CLASS_OF(body)));
	}
d6877 4
d6882 1
a6882 1
	node = NEW_DMETHOD(method_unbind(body));
d6885 1
a6885 1
	node = NEW_BMETHOD(body);
a6891 9
    if (SCOPE_TEST(SCOPE_PRIVATE)) {
	noex = NOEX_PRIVATE;
    }
    else if (SCOPE_TEST(SCOPE_PROTECTED)) {
	noex = NOEX_PROTECTED;
    }
    else {
	noex = NOEX_PUBLIC;
    }
a6892 11
    rb_add_method(mod, id, node, noex);
    if (scope_vmode == SCOPE_MODFUNC) {
	rb_add_method(rb_singleton_class(mod), id, node, NOEX_PUBLIC);
	rb_funcall(mod, singleton_added, 1, ID2SYM(id));
    }
    if (FL_TEST(mod, FL_SINGLETON)) {
	rb_funcall(rb_iv_get(mod, "__attached__"), singleton_added, 1, ID2SYM(id));
    }
    else {
	rb_funcall(mod, added, 1, ID2SYM(id));
    }
@


1.137.2.85
log
@* eval.c (rb_mod_define_method): must not convert Method to Proc.
@
text
@d6 1
a6 1
  $Date: 2001/12/19 07:45:28 $
d6877 5
a6881 2
	if (!rb_obj_is_kind_of(body, rb_cMethod) && !rb_obj_is_proc(body)) {
	    rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc/Method)",
d6896 1
a6896 1
	rb_raise(rb_eTypeError, "wrong argument type (expected Proc/Method)");
@


1.137.2.86
log
@* eval.c (rb_add_method): clear replaced method from the cache.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2001/12/20 18:18:19 $
d235 1
a235 2
    if (st_insert(RCLASS(klass)->m_tbl, mid, body))
	rb_clear_cache_by_id(mid);
d4202 2
a4203 11
    static int overflowing = 0;
    if (!overflowing && stack_length(0) > STACK_LEVEL_MAX) {
	int state;
	overflowing = 1;
	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    rb_raise(rb_eSysStackError, "stack level too deep");
	}
	POP_TAG();
	overflowing = 0;
	JUMP_TAG(state);
@


1.137.2.87
log
@* eval.c (rb_add_method): should clear cache by id always.

* eval.c (rb_disable_super): no longer need to clear cache before
  rb_add_method().

* eval.c (rb_export_method): ditto.

* eval.c (rb_attr): ditto.

* eval.c (rb_undef): ditto.

* eval.c (rb_eval): ditto.

* eval.c (rb_mod_modfunc): ditto.

* eval.c (rb_mod_define_method): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/01/08 06:59:52 $
a233 1
    rb_clear_cache_by_id(mid);
d235 2
a236 1
    st_insert(RCLASS(klass)->m_tbl, mid, body);
d357 1
d407 1
d477 1
d484 1
d1553 1
d2985 1
d3031 1
d5649 1
d6915 1
@


1.137.2.88
log
@* class.c (rb_make_metaclass): [new]

* class.c (rb_define_class_id): use rb_make_metaclass(), don't
  call Class#inherited hook.

* class.c (rb_class_inherited): [new]

* class.c (rb_define_class): call Class#inherited hook here.

* class.c (rb_define_class_under): ditto after class path is set.

* class.c (rb_singleton_class): use rb_make_metaclass().

* eval.c (rb_eval): same as rb_define_class_under().

* intern.h: prototypes of rb_make_metaclass() and
  rb_class_inherited().

* object.c (rb_class_s_new): use rb_make_metaclass() and
  rb_class_inherited().

* object.c (Init_Object): use rb_make_metaclass().

* struct.c (make_struct): use rb_class_inherited().
@
text
@d6 1
a6 1
  $Date: 2002/01/10 13:30:17 $
d3095 1
a3096 2
		rb_class_inherited(super, klass);
		rb_const_set(ruby_class, node->nd_cname, klass);
@


1.137.2.89
log
@* eval.c (block_pass): should not pass tainted block, if $SAFE > 0.

* variable.c (rb_mod_remove_cvar): should pass the char*.
@
text
@d6 1
a6 1
  $Date: 2002/01/10 23:38:56 $
d1756 1
a1756 17
	{
	    int call = nd_type(node)== NODE_CALL;
	    if (call) {
		int noex;
		ID id = node->nd_mid;

		if (!rb_get_method_body(&val, &id, &noex))
		    break;
		if ((noex & NOEX_PRIVATE))
		    break;
		if ((noex & NOEX_PROTECTED)) {
		    if (!rb_obj_is_kind_of(self, rb_class_real(val)))
			break;
		}
	    }
	    else if (!rb_method_boundp(val, node->nd_mid, call))
		break;
a6511 4
    }

    if (rb_safe_level() >= 1 && OBJ_TAINTED(block)) {
	rb_raise(rb_eSecurityError, "Insecure: tainted block value");
@


1.137.2.90
log
@* eval.c (ruby_stop): should not trace error handler.

* io.c (io_write): should not raise exception on O_NONBLOCK io.

* dir.c (dir_set_pos): seek should return dir, pos= should not.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/16 09:22:38 $
a1168 2
    trace_func = 0;
    tracing = 0;
d6272 2
a6273 2
static int
proc_get_safe_level(data)
d6279 2
a6280 1
	    return 3;
d6282 2
a6283 1
	    return 4;
d6285 2
a6286 1
	    return 5;
a6287 11
	return 3;
    }
    return 0;
}

static void
proc_set_safe_level(data)
    VALUE data;
{
    if (OBJ_TAINTED(data)) {
	ruby_safe_level = proc_get_safe_level(data);
d6531 1
a6531 3
	if (rb_safe_level() > proc_get_safe_level(block)) {
	    rb_raise(rb_eSecurityError, "Insecure: tainted block value");
	}
@


1.137.2.91
log
@* eval.c (rb_yield_0): restore source file/line after yield.
@
text
@d6 1
a6 1
  $Date: 2002/01/21 07:43:39 $
a3535 2
    char *const file = ruby_sourcefile;
    int line = ruby_sourceline;
a3681 2
    ruby_sourcefile = file;
    ruby_sourceline = line;
@


1.137.2.92
log
@* class.c (rb_include_module): detect cyclic module inclusion.

* eval.c (rb_thread_schedule): should check time only if BOTH
  WAIT_SELECT and WAIT_TIME.

* string.c (rb_str_split_m): no need to consider KANJI
characters, if the length of separator is 1 (byte).
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/01/23 07:24:26 $
d7657 1
a7657 2
 		if (((th->wait_for&(WAIT_SELECT|WAIT_TIME)) == (WAIT_SELECT|WAIT_TIME)) &&
		    th->delay <= now) {
@


1.137.2.93
log
@* eval.c (is_defined): defined?(Foo::Baz) should check constants
  only, no methods.

* eval.c (is_defined): should not dump core on defined?(a::b)
  where a is not a class nor a module.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/01/25 08:23:31 $
a1873 1
		break;
d1875 1
a1875 1
		if (rb_method_boundp(CLASS_OF(val), node->nd_mid, 1)) {
a6785 1
    bound->rklass = CLASS_OF(recv);
@


1.137.2.94
log
@* eval.c (umethod_bind): typo fix(rklass -> klass).
@
text
@d6 1
a6 1
  $Date: 2002/01/28 08:42:35 $
d6787 1
a6787 1
    bound->klass = CLASS_OF(recv);
@


1.137.2.95
log
@* re.c (rb_reg_search): should set regs.allocated.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/01/28 09:20:22 $
d6787 1
a6787 1
    bound->oklass = CLASS_OF(recv);
@


1.137.2.96
log
@* parse.y (yycompile): should inherit "in_single" if eval happened
  in a singleton method.

* eval.c (rb_eval): class variables from singleton methods defined
  within singleton class statement should work like ones defined
  by sington def statements.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/02/01 06:01:49 $
d1850 1
d4601 1
a4601 1
	    if (TYPE(defined_class) == T_ICLASS)
@


1.137.2.97
log
@* eval.c (rb_eval): singleton chech should be moved from yycompile
  to here.

* eval.c (is_defined): check should be added here too.
@
text
@d6 1
a6 1
  $Date: 2002/02/08 05:20:32 $
d1838 3
a1840 7
	if (!ruby_frame || !ruby_frame->last_class ||
	    !FL_TEST(ruby_frame->last_class, FL_SINGLETON)) {
	    if (NIL_P(ruby_cbase)) {
		if (rb_cvar_defined(CLASS_OF(self), node->nd_vid)) {
		    return "class variable";
		}
		break;
d1842 5
a1846 5
	    if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
		if (rb_cvar_defined(ruby_cbase, node->nd_vid)) {
		    return "class variable";
		}
		break;
d1848 1
d2764 7
a2770 10
	if (!ruby_frame || !ruby_frame->last_class ||
	    !FL_TEST(ruby_frame->last_class, FL_SINGLETON)) {
	    if (NIL_P(ruby_cbase)) {
		result = rb_cvar_get(CLASS_OF(self), node->nd_vid);
		break;
	    }
	    if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
		result = rb_cvar_get(ruby_cbase, node->nd_vid);
		break;
	    }
d2772 1
@


1.137.2.98
log
@* parse.y (assignable): should emit CVASGN within the method
  body.
@
text
@d6 1
a6 1
  $Date: 2002/02/09 14:47:51 $
d1838 7
a1844 3
	if (NIL_P(ruby_cbase)) {
	    if (rb_cvar_defined(CLASS_OF(self), node->nd_vid)) {
		return "class variable";
d1846 5
a1850 5
	    break;
	}
	if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    if (rb_cvar_defined(ruby_cbase, node->nd_vid)) {
		return "class variable";
a1851 1
	    break;
d1853 3
a1855 1
	if (rb_cvar_defined(rb_iv_get(ruby_cbase, "__attached__"), node->nd_vid)) {
d2730 4
a2733 3
	result = rb_eval(self, node->nd_value);
	if (ruby_verbose && FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    rb_warn("declaring singleton class variable");
d2740 1
a2740 1
	rb_cvar_set(ruby_cbase, node->nd_vid, result);
d2766 11
a2776 8
      case NODE_CVAR:
	if (NIL_P(ruby_cbase)) {
	    result = rb_cvar_get(CLASS_OF(self), node->nd_vid);
	    break;
	}
	if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    result = rb_cvar_get(ruby_cbase, node->nd_vid);
	    break;
d2778 3
a2780 1
	result = rb_cvar_get(rb_iv_get(ruby_cbase, "__attached__"), node->nd_vid);
d3821 3
a3823 2
	if (ruby_verbose && FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    rb_warn("declaring singleton class variable");
d3825 2
a3826 3
	rb_cvar_declare(ruby_cbase, lhs->nd_vid, val);
	break;

d3828 1
a3828 1
	rb_cvar_set(ruby_cbase, lhs->nd_vid, val);
@


1.137.2.99
log
@eval.c: remove duplicate lines.
@
text
@d6 1
a6 1
  $Date: 2002/02/13 09:02:14 $
d2724 1
@


1.137.2.100
log
@* eval.c (block_pass): "&nil" should clear block given.
@
text
@d6 1
a6 1
  $Date: 2002/02/14 08:14:25 $
d6527 1
a6527 4
	PUSH_ITER(ITER_NOT);
	result = rb_eval(self, node->nd_iter);
	POP_ITER();
	return result;
@


1.137.2.101
log
@* variable.c (rb_cvar_set): define new class variable if it's not
  defined yet.

* eval.c (rb_eval_string_wrap): should hide the toplevel local
  variable bindings by PUSH_SCOPE().
@
text
@d6 1
a6 1
  $Date: 2002/02/18 09:53:25 $
a1272 1
    PUSH_SCOPE();
a1276 1
    POP_SCOPE();
@


1.137.2.102
log
@* hash.c (rb_any_cmp): should handle Qundef in keys.

* eval.c (remove_method): should not remove a empty method to
  implement "undef".

* eval.c (rb_eval): should allow singleton class def for
  true/false/nil.

* parse.y (str_extend): backslash escape was done wrong.

* class.c (rb_include_module): should preserve ancestor order in
  the included class/module.
@
text
@d6 1
a6 1
  $Date: 2002/02/19 04:48:04 $
d317 1
a317 1
    if (!st_delete(RCLASS(klass)->m_tbl, &mid, &body) || !body->nd_body) {
d3162 9
a3170 21
	    result = rb_eval(self, node->nd_recv);
	    if (result == Qtrue) {
		klass = rb_cTrueClass;
	    }
	    else if (result == Qfalse) {
		klass = rb_cTrueClass;
	    }
	    else if (result == Qnil) {
		klass = rb_cNilClass;
	    }
	    else {
		if (rb_special_const_p(result)) {
		    rb_raise(rb_eTypeError, "no virtual class for %s",
			     rb_class2name(CLASS_OF(klass)));
		}
		if (rb_safe_level() >= 4 && !OBJ_TAINTED(result))
		    rb_raise(rb_eSecurityError, "Insecure: can't extend object");
		if (FL_TEST(CLASS_OF(result), FL_SINGLETON)) {
		    rb_clear_cache();
		}
		klass = rb_singleton_class(result);
d3172 1
@


1.137.2.103
log
@* eval.c: typo fixed.
@
text
@d6 1
a6 1
  $Date: 2002/02/20 04:28:50 $
d3175 1
a3175 1
			     rb_class2name(CLASS_OF(result)));
@


1.137.2.104
log
@* eval.c (rb_f_missing): NoMethod error messages for true, false,
  nil must respond visibility like for other objects.
@
text
@d6 1
a6 1
  $Date: 2002/02/21 07:14:11 $
d4085 1
a4085 1
    ID id, noclass;
d4099 1
d4103 1
a4103 1
	desc = "nil";
d4106 1
a4106 1
	desc = "true";
d4109 1
a4109 1
	desc = "false";
d4119 16
a4140 17
    if (last_call_status & CSTAT_PRIV) {
	format = "private method `%s' called for %s%s%s";
    }
    if (last_call_status & CSTAT_PROT) {
	format = "protected method `%s' called for %s%s%s";
    }
    else if (last_call_status & CSTAT_VCALL) {
	const char *mname = rb_id2name(id);

	if (('a' <= mname[0] && mname[0] <= 'z') || mname[0] == '_') {
	    format = "undefined local variable or method `%s' for %s%s%s";
	}
    }
    if (!format) {
	format = "undefined method `%s' for %s%s%s";
    }

a4145 1
    noclass = (!d || desc[0]=='#');
d4147 2
a4148 2
	     desc, noclass ? "" : ":",
	     noclass ? "" : rb_class2name(CLASS_OF(obj)));
@


1.137.2.105
log
@* gc.c (rb_source_filename): added. holds unique strings for file
  names with GC space.

* gc.c (rb_gc_mark): mark source file name.

* gc.c (gc_sweep): ditto.

* gc.c (Init_GC): initialize source file name table.

* intern.h (rb_source_filename): added.

* eval.c (rb_eval_string): use rb_source_filename().

* parse.y (yycompile): ditto.

* ruby.c (proc_options): ditto.

* ruby.c (load_file): ditto.

* ruby.c (ruby_script): ditto.

* ruby.c (ruby_prog_init): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/02/27 04:50:29 $
d1224 1
a1224 1
    ruby_sourcefile = rb_source_filename("(eval)");
@


1.137.2.106
log
@* eval.c (cvar_cbase): utility function to find innermost non
  singleton cbase.

* eval.c (is_defined): adopt new cvar behavior.

* eval.c (rb_eval): ditto.

* eval.c (assign): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/07 11:19:27 $
a1463 14
cvar_cbase()
{
    NODE *cref = RNODE(ruby_frame->cbase);

    while (cref && cref->nd_next && FL_TEST(cref->nd_clss, FL_SINGLETON)) {
	cref = cref->nd_next;
	if (!cref->nd_next) {
	    rb_warn("class variable access from toplevel singleton method");
	}
    }
    return cref->nd_clss;
}

static VALUE
d1840 13
a1852 1
	if (rb_cvar_defined(cvar_cbase(), node->nd_vid)) {
d2727 4
a2730 1
	rb_cvar_declare(cvar_cbase(), node->nd_vid, result);
d2735 1
a2735 1
	rb_cvar_set(cvar_cbase(), node->nd_vid, result);
d2762 9
a2770 1
	result = rb_cvar_get(cvar_cbase(), node->nd_vid);
d3017 1
a3017 1
		rb_raise(rb_eSecurityError, "Insecure: can't define singleton method");
d3825 1
a3825 1
	rb_cvar_declare(cvar_cbase(), lhs->nd_vid, val);
d3829 1
a3829 1
	rb_cvar_set(cvar_cbase(), lhs->nd_vid, val);
@


1.137.2.107
log
@* regex.c (re_compile_pattern): '\0111' should be '\011' plus '1',
  since octal literals are formed by three digits at most.

* eval.c (rb_eval_cmd): cbase should not be NULL; it should be
  either ruby_wrapper or Object.

* enum.c (enum_each_with_index): should return self.

* process.c (proc_setpgrp): should return value for non-void function.

* process.c (proc_getpgid): should raise exception if getpgid() return -1.

* string.c (rb_str_ljust): should return a duplicated string.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/08 06:59:51 $
d1341 1
a1341 2
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,0,0,0);
    RNODE(ruby_frame->cbase)->nd_clss = ruby_wrapper ? ruby_wrapper : rb_cObject;
@


1.137.2.108
log
@* eval.c (is_defined): should check receiver only once.

* eval.c (is_defined): should handle NODE_NEWLINE.

* file.c (rb_file_s_expand_path): memory leak fixed.
@
text
@d6 1
a6 1
  $Date: 2002/03/12 09:27:25 $
d1763 1
a1897 4

      case NODE_NEWLINE:
	node = node->nd_next;
	goto again;
@


1.137.2.109
log
@* eval.c (is_defined): label forgotten.
@
text
@d6 1
a6 1
  $Date: 2002/03/20 09:42:29 $
a1741 1
  again:
@


1.137.2.110
log
@* ext/socket/socket.c (bsock_do_not_rev_lookup_set): should not be
  allowed when $SAFE > 3.

* dir.c (fnmatch): "*/bar" (with FNM_PATHNAME flag) does not
  match "foo/bar".

* io.c (read_all): files on /proc filesystem with zero stat size,
  may have contents.

* eval.c (exec_under): changing ruby_class is OK, but should not
  alter cbase.

* eval.c (yield_under_i): ditto.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/03/20 13:10:03 $
a89 4
#if defined(__VMS)
#pragma nostandard
#endif

d2963 1
a2963 1
		    rb_warning("method redefined; discarding old %s", rb_id2name(node->nd_mid));
d5025 1
a5025 1
exec_under(func, under, cbase, args)
d5027 1
a5027 1
    VALUE under, cbase;
d5042 2
a5043 5
    if (cbase) {
	if (ruby_cbase != cbase) {
	    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,under,0,ruby_frame->cbase);
	}
	PUSH_CREF(cbase);
d5045 1
d5054 1
a5054 1
    if (cbase) POP_CREF();
d5089 1
a5089 1
    return exec_under(eval_under_i, under, under, args);
d5096 26
d5130 1
a5130 1
    return exec_under(yield_under_i, under, 0, self);
@


1.137.2.111
log
@* file.c (rb_find_file): load must be done from an abolute path if
  $SAFE >= 4.

* re.c (rb_reg_s_quote): quote whitespaces for /x cases.

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* eval.c (rb_thread_cleanup): current thread may be THREAD_STOPPED,
  for example when terminated from signal handler.

* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.

* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* marshal.c (w_uclass): should check based on rb_obj_class(), not
  CLASS_OF().

* io.c (io_write): check error if written data is less than
  specified size to detect EPIPE.

* eval.c (assign): ruby_verbose should be surrounded by RTEST().

* object.c (rb_str2cstr): ditto.

* parse.y (void_expr): ditto.

* parse.y (void_stmts): ditto.

* variable.c (rb_ivar_get): ditto.

* variable.c (rb_cvar_set): ditto.

* variable.c (rb_cvar_get): ditto.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/03/25 06:15:59 $
d3822 1
a3822 1
	if (RTEST(ruby_verbose) && FL_TEST(ruby_cbase, FL_SINGLETON)) {
d8536 1
a8536 1
	if (th->status != THREAD_KILLED) {
d8540 1
a8540 3
	    if (th != main_thread) {
		th->status = THREAD_TO_KILL;
	    }
@


1.137.2.112
log
@* eval.c, gc.c, intern.h, variable.c: declare rb_gc_mark{,maybe}()
  canonically in order not to confuse C++ compilers. (backported
  from 1.7, problem noted by ttate)
@
text
@d6 1
a6 1
  $Date: 2002/05/01 09:37:57 $
d5852 1
a5852 1
	rb_gc_mark((VALUE)link->data);
d5857 1
a5857 1
	rb_gc_mark((VALUE)link->data);
d6084 8
a6091 8
	rb_gc_mark((VALUE)data->scope);
	rb_gc_mark((VALUE)data->var);
	rb_gc_mark((VALUE)data->body);
	rb_gc_mark((VALUE)data->self);
	rb_gc_mark((VALUE)data->dyna_vars);
	rb_gc_mark((VALUE)data->klass);
	rb_gc_mark((VALUE)data->tag);
	rb_gc_mark((VALUE)data->wrapper);
d6614 1
a6614 1
    rb_gc_mark((VALUE)data->body);
d7150 1
a7150 1
    rb_gc_mark((VALUE)th->cref);
d7152 2
a7153 2
    rb_gc_mark((VALUE)th->scope);
    rb_gc_mark((VALUE)th->dyna_vars);
@


1.137.2.113
log
@* eval.c (superclass): undesirable "unexpected return" when the superclass is not a Class.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2002/05/04 12:04:51 $
d1404 1
d1417 1
a1417 4
    if (TYPE(val) != T_CLASS) {
	rb_raise(rb_eTypeError, "superclass must be a Class (%s given)",
		 rb_class2name(CLASS_OF(val)));
    }
@


1.137.2.114
log
@* eval.c (rb_yield_0): The destination of the goto jump was wrong.
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/05/07 00:20:49 $
d3648 1
a3649 1
  pop_state:
@


1.137.2.115
log
@* eval.c (blk_orphan): the wrong condition; backported from 1.7

* eval.c (rb_clear_cache_by_class): new function.

* eval.c (set_method_visibility): should have clear cache forq
  updated visibility.

* re.c (rb_reg_s_quote): # also should be quoted.
@
text
@d6 1
a6 1
  $Date: 2002/05/07 06:24:52 $
a223 15
static void
rb_clear_cache_by_class(klass)
    VALUE klass;
{
    struct cache_entry *ent, *end;

    ent = cache; end = ent + CACHE_SIZE;
    while (ent < end) {
	if (ent->origin == klass) {
	    ent->mid = 0;
	}
	ent++;
    }
}

a5536 1
    rb_clear_cache_by_class(self);
d6352 2
a6353 4
    if (!(data->scope->flag & SCOPE_NOSTACK)) {
	return 0;
    }
    if ((data->tag->flags & BLOCK_ORPHAN)) {
@


1.137.2.116
log
@* eval.c (rb_thread_select): cleanup conditional compilation.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/14 06:08:43 $
a7888 3
#else
	struct timeval *const tvp = timeout;
#endif
a7898 1
#ifndef linux
d7900 1
a7900 1
			double d = limit - timeofday();
a7906 1
#endif
d7914 18
@


1.137.2.117
log
@* eval.c (rb_thread_schedule): need to preserve errno before
  calling rb_trap_exec().

* regex.c (calculate_must_string): a bug in charset/charset_not
  parsing.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/05/16 07:15:15 $
a7640 2
	    int e = errno;

d7642 1
a7642 1
	    if (e == EINTR) goto again;
d7644 1
a7644 1
	    if (e == ERESTART) goto again;
@


1.137.2.118
log
@* eval.c (scope_node): trick to keep the node has a scope.

* eval.c (rb_eval): NODE_EVSTR: write back local_tbl to the node.

* eval.c (rb_eval): NODE_SCOPE: hold the scope node in ruby_scope.

* eval.c (module_setup): ditto.

* eval.c (rb_call0): ditto.

* node.h (NEW_DASGN, NEW_DASGN_CURR): remove surplus semicolons.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/21 05:41:00 $
a818 1
#define scope_node super.klass
a2618 1
	    ruby_scope->scope_node = (VALUE)node;
a2911 8
			if (ruby_scope->local_tbl) {
			    NODE *body = (NODE *)ruby_scope->scope_node;
			    if (body && body->nd_tbl != ruby_scope->local_tbl) {
				if (body->nd_tbl) free(body->nd_tbl);
				ruby_scope->local_vars[-1] =
				    (VALUE)(body->nd_tbl = ruby_scope->local_tbl);
			    }
			}
a3261 1
    ruby_scope->scope_node = (VALUE)node;
a4447 1
	    ruby_scope->scope_node = (VALUE)body;
@


1.137.2.119
log
@* time.c (time_arg): nil test against v[6] (usec).
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/05/28 03:19:54 $
a2910 1
			rb_dvar_push(0, 0);
@


1.137.2.120
log
@* eval.c (rb_eval): ruby_frame->last_func may be null, if it's
  called outside of a method.

* parse.y (arg): use INT2NUM, not INT2FIX for tUMINUS.

* parse.y (arg): $1 may be null for tPOW.

* parse.y (stmt,arg): too much void value check.

* parse.y (arg): need to check void value on rules which does not
  use node_assign().

* ext/socket/socket.c (ipaddr): need not to taint hostnames.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/05/29 05:22:01 $
d2583 2
a2584 7
		if (ruby_frame->last_func) {
		    rb_raise(rb_eNameError, "superclass method `%s' disabled",
			     rb_id2name(ruby_frame->last_func));
		}
		else {
		    rb_raise(rb_eRuntimeError, "super called outside of method");
		}
@


1.137.2.121
log
@* eval.c (rb_eval): fixed line number in string interpolation.

* parse.y (str_extend): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/06/11 06:58:36 $
d2914 1
a2914 1
			ruby_sourceline = nd_line(list->nd_head);
@


1.137.2.122
log
@* eval.c (rb_undef): undef should be done for klass, not ruby_class.

* eval.c (error_handle): should handle TAG_THROW as well.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/07/11 15:51:49 $
a1120 11
      case TAG_THROW:
	if (prot_tag && prot_tag->frame && prot_tag->frame->file) {
	    fprintf(stderr, "%s:%d: uncaught throw\n",
		    prot_tag->frame->file, prot_tag->frame->line);
	}
	else {
	    error_pos();
	    fprintf(stderr, ": unexpected throw\n");
	}
	ex = 1;
	break;
d1569 1
a1569 1
    body = search_method(klass, id, &origin);
@


1.137.2.123
log
@* hash.c (rb_hash_equal): should check default values.

* ext/socket/socket.c (s_recvfrom): update RSTRING len.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/07/31 05:17:27 $
d1569 1
a1569 1
    if (klass == rb_cObject) {
@


1.137.2.124
log
@* eval.c (rb_thread_save_context, rb_thread_restore_context):
  save/restore SEH chain on MS-Windows at thread switch.
  [ruby-win32:273]

* eval.c (win32_get_exception_frame, win32_set_exception_frame):
  added.
@
text
@d6 1
a6 1
  $Date: 2002/08/12 07:40:31 $
a7035 47
/* Windows SEH refers data on the stack. */
#ifdef _WIN32
# if !(defined _M_IX86 || defined __i386__)
#   error unsupported processor
# endif
static inline DWORD
win32_get_exception_list()
{
    DWORD p;
# if defined _MSC_VER
#   ifdef _M_IX86
    __asm mov eax, fs:[0];
    __asm mov p, eax;
#   endif
# elif defined __GNUC__
#   ifdef __i386__
    __asm__("movl %%fs:0,%0" : "=r"(p));
#   endif
# elif defined __BORLANDC__
    __emit__(0x64, 0xA1, 0, 0, 0, 0); /* mov eax, fs:[0] */
    p = _EAX;
# else
#   error unsupported compiler
# endif
    return p;
}

static inline void
win32_set_exception_list()
    DWORD p;
{
# if defined _MSC_VER
#   ifdef _M_IX86
    __asm mov eax, p;
    __asm mov fs:[0], eax;
#   endif
# elif defined __GNUC__
#   ifdef __i386__
    __asm__("movl %0,%%fs:0" :: "r"(p));
#   endif
# elif defined __BORLANDC__
    _EAX = p;
    __emit__(0x64, 0xA3, 0, 0, 0, 0); /* mov fs:[0], eax */
# endif
}
#endif

a7064 3
#ifdef _WIN32
    DWORD win32_exception_list;
#endif
a7312 3
#ifdef _WIN32
    th->win32_exception_list = win32_get_exception_list();
#endif
a7428 3
#ifdef _WIN32
    win32_set_exception_list(th->win32_exception_list);
#endif
@


1.137.2.125
log
@* eval.c (win32_get_exception_list, win32_set_exception_list): Cygwin fix.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/08/19 00:37:16 $
d7037 1
a7037 1
#if defined _WIN32 || defined __CYGWIN__
a7040 5

#if defined __CYGWIN__
typedef unsigned long DWORD;
#endif

d7064 1
a7064 1
win32_set_exception_list(p)
d7112 1
a7112 1
#if defined _WIN32 || defined __CYGWIN__
@


1.137.2.126
log
@particular symbol for win32_exception_list.
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2002/08/19 03:18:33 $
a7036 1
#undef SAVE_WIN32_EXCEPTION_LIST
d7038 4
a7051 1
#   define SAVE_WIN32_EXCEPTION_LIST
a7056 1
#   define SAVE_WIN32_EXCEPTION_LIST
a7059 1
#   define SAVE_WIN32_EXCEPTION_LIST
d7062 2
a7085 4

#ifndef SAVE_WIN32_EXCEPTION_LIST
# error unsupported platform
#endif
d7117 1
a7117 1
#ifdef SAVE_WIN32_EXCEPTION_LIST
d7368 1
a7368 1
#ifdef SAVE_WIN32_EXCEPTION_LIST
d7487 1
a7487 1
#ifdef SAVE_WIN32_EXCEPTION_LIST
@


1.137.2.127
log
@* eval.c (rb_thread_cleanup): should not modify the global
  variable curr_thread.

* re.c (rb_reg_initialize_m): frozen check should be moved here
  from rb_reg_initialize().
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/08/19 03:40:50 $
d8630 1
a8630 1
    rb_thread_t curr, th;
d8632 2
a8633 3
    curr = curr_thread;
    while (curr->status == THREAD_KILLED) {
	curr = curr_thread->prev;
d8636 1
a8636 1
    FOREACH_THREAD_FROM(curr, th) {
d8646 1
a8646 1
    END_FOREACH_FROM(curr, th);
@


1.137.2.128
log
@* eval.c (rb_eval): overriding false constant with class/module
  definition should be error.  (PR#327)

* eval.c (rb_call0): preset source file/line to pass correct ones
  to trace_func at end of empty method.  [ruby-dev:18035]

* ruby.c (require_libraries): not clear source file.
  [ruby-dev:18074]
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/08/21 08:31:24 $
d3125 1
d3131 2
d3172 1
d3178 2
d4564 2
a4565 5
		    char *file = b2->nd_file;
		    int line = nd_line(b2);
		    call_trace_func("call", file, line, recv, id, klass);
		    ruby_sourcefile = file;
		    ruby_sourceline = line;
@


1.137.2.129
log
@* eval.c (rb_trap_eval): preserve thread status and so on.
  [ruby-talk:40337], [ruby-core:00019]
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/09/05 04:12:39 $
d1396 22
a7178 80
struct thread_status_t {
    char *file;
    int   line;

    int tracing;
    VALUE errinfo;
    VALUE last_status;
    VALUE last_line;
    VALUE last_match;

    int safe;

    enum thread_status status;
    int wait_for;
    int fd;
    fd_set readfds;
    fd_set writefds;
    fd_set exceptfds;
    int select_value;
    double delay;
    rb_thread_t join;
};

#define THREAD_COPY_STATUS(src, dst) (void)(	\
    (dst)->file = (src)->file,			\
    (dst)->line = (src)->line,			\
						\
    (dst)->tracing = (src)->tracing,		\
    (dst)->errinfo = (src)->errinfo,		\
    (dst)->last_status = (src)->last_status,	\
    (dst)->last_line = (src)->last_line,	\
    (dst)->last_match = (src)->last_match,	\
						\
    (dst)->safe = (src)->safe,			\
						\
    (dst)->status = (src)->status,		\
    (dst)->wait_for = (src)->wait_for,		\
    (dst)->fd = (src)->fd,			\
    (dst)->readfds = (src)->readfds,		\
    (dst)->writefds = (src)->writefds,		\
    (dst)->exceptfds = (src)->exceptfds,	\
    (dst)->select_value = (src)->select_value,	\
    (dst)->delay = (src)->delay,		\
    (dst)->join = (src)->join			\
)

static void rb_thread_ready _((rb_thread_t));

static VALUE
rb_trap_eval(cmd, sig)
    VALUE cmd;
    int sig;
{
    int state;
    VALUE val;			/* OK */
    struct thread_status_t save;

    THREAD_COPY_STATUS(curr_thread, &save);
    rb_thread_ready(curr_thread);
    PUSH_TAG(PROT_NONE);
    PUSH_ITER(ITER_NOT);
    if ((state = EXEC_TAG()) == 0) {
	val = rb_eval_cmd(cmd, rb_ary_new3(1, INT2FIX(sig)));
    }
    POP_ITER();
    POP_TAG();
    THREAD_COPY_STATUS(&save, curr_thread);

    if (state) {
	rb_trap_immediate = 0;
	JUMP_TAG(state);
    }

    if (curr_thread->status == THREAD_STOPPED) {
	rb_thread_schedule();
    }

    return val;
}

d7412 1
d8724 1
@


1.137.2.130
log
@* eval.c (ruby_run): should set toplevel visibility again here.

* eval.c (rb_eval): should not rely on ruby_class == rb_cObject
  check.   Besides allow implicit publicity for attribute set
  methods.

* parse.y (primary): need not to check class_nest, just set
  whether method is an attrset or not.

* string.c (rb_str_each_line): p might be at the top of the
  string.

* variable.c (rb_path2class): should not use rb_eval_string().

* parse.y (str_extend): expression substitution can contain string
  terminator again.

* parse.y (yylex): the warning message "invalid
  character syntax" was never issued.

* file.c (rb_find_file): $LOAD_PATH must not be empty.

* file.c (rb_find_file_ext): ditto.

* range.c (range_eq): class check should be based on range.class,
  instead of Range to work with Range.dup.

* range.c (range_eql): ditto.
@
text
@d6 1
a6 1
  $Date: 2002/09/11 15:25:34 $
a1218 2
    /* default visibility is private at toplevel */
    SCOPE_SET(SCOPE_PRIVATE);
d2998 1
a2998 4
	    if (node->nd_noex == NOEX_PUBLIC) {
		noex = NOEX_PUBLIC; 	/* means is is an attrset */
	    }
	    else if (SCOPE_TEST(SCOPE_PRIVATE) || node->nd_mid == init) {
d3004 3
d3162 1
a3163 1
		rb_const_set(ruby_class, node->nd_cname, module);
d7949 1
a7949 1
    double limit;
d7989 1
a7989 1
    limit = timeofday() + (double)time.tv_sec + (double)time.tv_usec*1e-6;
d7991 1
a7991 1
    curr_thread->delay = limit;
@


1.137.2.131
log
@* eval.c (rb_load): should not pass block to the loaded file.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/09/25 07:07:36 $
a5244 1
    PUSH_ITER(ITER_NOT);
a5277 1
    POP_ITER();
@


1.137.2.132
log
@* eval.c (ruby_init): Init_stack() with local location.
  (ruby-bugs-ja:PR#277)

* gc.c (Init_stack): prefer address of argument rather than local
  variable to initialize rb_gc_stack_start.

* lib/weakref.rb (WeakRef::@@@@final): use Hash#delete.

* lib/weakref.rb (WeakRef::__getobj__): examin if alive or not by
  ID_REV_MAP to deal with recycled object.  [ruby-dev:18472]

* lib/weakref.rb (WeakRef::weakref_alive?): ditto.
@
text
@d5 2
a6 2
  $Author: aamine $
  $Date: 2002/10/05 21:07:24 $
d1035 1
a1035 1
    Init_stack(&state);
@


1.137.2.133
log
@* eval.c (rb_eval): need to push empty varmap node only when
  ruby_dyna_var is NULL.
@
text
@d5 2
a6 2
  $Author: nobu $
  $Date: 2002/10/10 07:01:10 $
d2907 1
a2907 1
			if (!ruby_dyna_vars) rb_dvar_push(0, 0);
@


1.137.2.134
log
@* hash.c, eval.c: Use (*_NSGetEnviron()) instead of environ on
  Darwin for namespace cleanness.  [ruby-core:00537]

* dln.c (dln_load): Fix Darwin support that has been disabled and
  switch to using it on Darwin instead of the system dlopen().
  [ruby-core:00541]
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/10/17 07:25:36 $
a25 4
#ifdef __APPLE__
#include <crt_externs.h>
#endif

d1004 1
a1004 3
#if defined(__APPLE__)
#define environ (*_NSGetEnviron())
#elif !defined(NT) && !defined(__MACOS__)
@


1.137.2.135
log
@* eval.c (rb_eval): local_vars[-1] should protect body, not a
  local_tbl.

* marshal.c (w_object): check if klass is really a class.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2002/10/17 16:27:15 $
d2921 2
a2922 2
                               ruby_scope->local_vars[-1] = (VALUE)body;
                               body->nd_tbl = ruby_scope->local_tbl;
@


1.137.2.136
log
@* eval.c, gc.c: use a common set of alloca() #ifdef's.  This fixes
  the build with Intel C Compiler for Linux.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2002/10/23 08:19:23 $
d38 1
a38 1
# ifdef HAVE_ALLOCA_H
d40 3
a42 9
# else
#  ifdef _AIX
 #pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
void *alloca ();
#   endif
#  endif /* AIX */
# endif /* HAVE_ALLOCA_H */
d44 4
@


1.137.2.137
log
@* array.c, class.c, eval.c, file.c, gc.c, node.h, numeric.c,
  object.c, parse.y, range.c, re.c, string.c, struct.c, util.c,
  ext/socket/socket.c: merge from 1.7: treat long values as long
  instead of int.
@
text
@d5 2
a6 2
  $Author: knu $
  $Date: 2002/10/25 19:37:48 $
d1908 1
a1908 1
	    sprintf(buf, "$%d", (int)node->nd_nth);
d1915 1
a1915 1
	    sprintf(buf, "$%c", (int)node->nd_nth);
d3609 1
a3609 1
		    rb_raise(rb_eArgError, "wrong # of arguments (%ld for 0)",
d6531 1
a6531 1
    sprintf(RSTRING(str)->ptr, "#<%s:0x%lx>", cname, (unsigned long)data->tag);
d7890 1
a7890 1
		    (unsigned long)th->thread, th->status,
d9196 1
a9196 1
	    rb_raise(rb_eThreadError, "uncaught throw `%s' in thread 0x%lx",
d9198 1
a9198 1
		     (unsigned long)curr_thread);
d9233 2
a9234 2
	    rb_raise(rb_eThreadError, "return from within thread 0x%lx",
		     (unsigned long)curr_thread);
@


1.136
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/18 09:45:58 $
d5165 1
a5165 1
	if (strcmp(ext, ".rb") == 0) {
d7180 1
a7180 1
    max = 0;
d8335 1
d8348 1
@


1.135
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/12 07:42:21 $
d4946 9
a4954 3
    char *file = "(eval)";
    int   line = 1;
    int   iter = rb_block_given_p();
d4956 2
a4957 3
    if (argc > 0) {
	if (ruby_safe_level >= 4) {
	    Check_Type(argv[0], T_STRING);
d4960 13
a4972 1
	    Check_SafeStr(argv[0]);
a4973 16
	if (argc > 3) {
	    rb_raise(rb_eArgError, "wrong # of arguments: %s(src) or %s{..}",
		     rb_id2name(ruby_frame->last_func),
		     rb_id2name(ruby_frame->last_func));
	}
	if (argc > 1) file = STR2CSTR(argv[1]);
	if (argc > 2) line = NUM2INT(argv[2]);
    }
    else if (!iter) {
	rb_raise(rb_eArgError, "block not supplied");
    }

    if (iter) {
	return yield_under(klass, self);
    }
    else {
d5555 3
@


1.134
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/12/08 07:10:16 $
d1462 2
a1463 2
static void
frozen_class_p(klass)
d1498 1
a1498 1
    frozen_class_p(klass);
d1544 1
a1544 1
    frozen_class_p(klass);
d2057 38
d2099 1
a2099 6
	    if (node->nd_head) {
		val = rb_eval(self, node->nd_head);
	    }
	    else {
		val = Qtrue;
	    }
d2323 1
d2895 1
a2895 1
	    frozen_class_p(ruby_class);
d3858 1
@


1.133
log
@matz
@
text
@d5 2
a6 2
  $Author: shugo $
  $Date: 2000/12/07 08:38:39 $
d5638 3
@


1.132
log
@shugo
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/12/06 09:10:07 $
d4040 1
a4040 1
# if defined(__GNUC__) && !defined(__alpha__)
@


1.131
log
@eban
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/12/05 09:36:24 $
d4040 1
a4040 1
# if defined(__GNUC__)
@


1.130
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/27 09:23:17 $
d6588 1
a6588 1
    if (RDATA(body)->dmark == bm_mark) {
d6591 1
a6591 1
    else if (RDATA(body)->dmark != blk_mark) {
@


1.129
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/21 14:26:19 $
d89 1
d91 2
d1120 1
a1120 1
static void rb_exec_end_proc _((void));
d3464 7
a3470 2
	    if (nd_type(block->var) == NODE_MASGN)
		massign(self, block->var, val, acheck);
d3472 9
a3480 3
		if (acheck && val != Qundef &&
		    TYPE(val) == T_ARRAY && RARRAY(val)->len == 1) {
		    val = RARRAY(val)->ptr[0];
a3481 1
		assign(self, block->var, val, acheck);
d4226 8
d5663 1
a5663 1
static void
d5669 2
a5670 3
    while (end_procs) {
	link = end_procs;
	end_procs = link->next;
d5675 1
a5675 1
	free(link);
d5760 1
d6187 1
d6565 36
d7670 1
a7670 6
    rb_thread_t th = rb_thread_check(thread);;

    if (rb_safe_level() >= 4 && th != curr_thread) {
	rb_raise(rb_eSecurityError, "Insecure: can't get priority");
    }
    return INT2NUM(th->priority);
@


1.128
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/20 07:31:38 $
d1117 33
d1169 1
a1169 17
    PUSH_TAG(PROT_NONE);
    PUSH_ITER(ITER_NOT);
    if ((state = EXEC_TAG()) == 0) {
	rb_trap_exit();
	rb_thread_cleanup();
	rb_thread_wait_other_threads();
    }
    else {
	ex = state;
    }
    POP_ITER();
    POP_TAG();

    ex = error_handle(ex);
    rb_exec_end_proc();
    rb_gc_call_finalizer_at_exit();
    exit(ex);
d2975 1
a2975 2
	    if ((ruby_class == rb_cObject || ruby_class == ruby_wrapper) &&
		rb_autoload_defined(node->nd_cname)) {
a2980 4
	    if (!klass && ruby_class == ruby_wrapper &&
		rb_const_defined_at(rb_cObject, node->nd_cname)) {
		klass = rb_const_get(rb_cObject, node->nd_cname);
	    }
d3028 1
a3028 2
	    if ((ruby_class == rb_cObject || ruby_class == ruby_wrapper) &&
		rb_autoload_defined(node->nd_cname)) {
a3033 4
	    if (!module && ruby_class == ruby_wrapper &&
		rb_const_defined_at(rb_cObject, node->nd_cname)) {
		module = rb_const_get(rb_cObject, node->nd_cname);
	    }
d3218 2
d3221 3
a3223 1
	rb_exc_raise(rb_exc_new(rb_eSystemExit, 0, 0));
d3225 1
a3225 2
    rb_exec_end_proc();
    rb_gc_call_finalizer_at_exit();
d5615 2
d5618 2
d5642 1
a5642 1
void
d5648 3
a5650 2
    link = end_procs;
    while (link) {
d5655 1
a5655 1
	link = link->next;
d5661 3
d6936 1
d7838 1
d8235 17
@


1.127
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/17 04:41:09 $
d1738 1
a1738 1
      case NODE_CVASGN2:
d1771 1
d1774 1
a1774 1
	if (rb_cvar_defined_singleton(self, node->nd_vid)) {
d2259 1
d2603 4
a2606 3
	if (!FL_TEST(ruby_cbase, FL_SINGLETON)) {
	    result = rb_eval(self, node->nd_value);
	    rb_cvar_declare(ruby_cbase, node->nd_vid, result);
d2609 4
a2612 2
	/* fall through */
      case NODE_CVASGN2:
d2614 1
a2614 1
	rb_cvar_set_singleton(self, node->nd_vid, result);
d2640 1
a2640 1
      case NODE_CVAR:
d2645 1
d2647 2
a2648 2
      case NODE_CVAR2:
	result = rb_cvar_get_singleton(self, node->nd_vid);
d3643 8
a3650 5
	rb_cvar_declare(ruby_cbase, lhs->nd_vid, val);
	break;

      case NODE_CVASGN2:
	rb_cvar_set(CLASS_OF(self), lhs->nd_vid, val);
@


1.126
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/16 07:24:10 $
a2596 5
      case NODE_CVASGN2:
	result = rb_eval(self, node->nd_value);
	rb_cvar_set_singleton(self, node->nd_vid, result);
	break;

d2601 7
d2609 1
a2609 1
	rb_cvar_declare(ruby_cbase, node->nd_vid, result);
@


1.125
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/11/08 05:29:21 $
d1765 5
a1769 2
	if (rb_cvar_defined(ruby_cbase, node->nd_vid)) {
	    return "class variable";
d1771 1
a1771 2
	break;

d2634 5
a2638 3
	result = rb_cvar_get(ruby_cbase, node->nd_vid);
	break;

d7223 1
a7223 3
#if 0
    if (ruby_in_compile) return;
#endif
d7236 1
d7255 2
a7256 1
    if (curr_thread == curr_thread->next) {
d7320 2
a7321 1
    if (curr_thread == curr_thread->next) { /* no other thread */
d7384 1
d7391 2
d7397 1
d7512 2
d7518 2
d7522 1
d7564 2
a7565 1
    if (curr_thread == curr_thread->next) {
@


1.124
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/20 16:36:49 $
d480 1
a481 1
	rb_clear_cache_by_id(id);
d487 1
a488 1
	rb_clear_cache_by_id(id);
d2858 1
a2863 1
	    rb_clear_cache_by_id(node->nd_mid);
d2903 1
a2904 1
	    rb_clear_cache_by_id(node->nd_mid);
d3567 1
a3567 3
	    if (check) {
		goto arg_error;
	    }
d5375 1
a5376 1
	rb_clear_cache_by_id(id);
d6429 1
a6429 1
	if (body->nd_opt || body->nd_rest >= 0)
d6981 3
a6983 3
static int
intersect_fds(dst, src, max)
    fd_set *dst, *src;
d6989 2
a6990 2
	if (FD_ISSET(i, src)) {
	    if (FD_ISSET(i, dst)) {
d6992 1
a6992 1
		FD_CLR(i, dst);
d6995 1
a6995 1
		FD_CLR(i, src);
a6996 1
	    return Qtrue;
a6998 1
    return Qfalse;
@


1.123
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/17 18:13:54 $
d4950 1
d5017 2
@


1.122
log
@1.6.2 (to be)
@
text
@d6 1
a6 1
  $Date: 2000/10/16 09:13:15 $
d2389 1
a2389 1
	result = rb_ary_push(rb_eval(self, node->nd_head),
@


1.121
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/14 14:44:52 $
d885 4
a888 1
	fprintf(stderr, "%s:%d", ruby_sourcefile, ruby_sourceline);
d3230 1
a3230 1
    if (ruby_errinfo) {
d7116 1
a7116 1
	    FOREACH_THREAD(th) {
d7129 1
a7129 1
	    END_FOREACH(th);
a7643 1
    th->errinfo = Qnil;\
d7664 1
a7664 1
    th->errinfo = 0;\
a8209 1
    th->prev = th->next = 0;
@


1.120
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/13 09:01:53 $
a639 1
	if (TYPE(vars) != T_VARMAP) abort();
a729 1
    int line;
a742 1
    _tag.line = __LINE__;		\
d804 1
a804 2
       if (_old)\
           scope_dup(_old);\
d3494 1
d3496 1
a3496 1
	    vars = vars->next;
d7621 1
a7621 3
    rb_thread_t th = rb_thread_check(thread);

    return th->abort?Qtrue:Qfalse;
a7627 2
    rb_thread_t th = rb_thread_check(thread);

d7629 1
a7629 1
    th->abort = RTEST(val);
a7681 12
    if (curr_thread) {
	th->prev = curr_thread;
	curr_thread->next->prev = th;
	th->next = curr_thread->next;
	curr_thread->next = th;
	th->priority = curr_thread->priority;
	th->gid = curr_thread->gid;
    }
    else {
	curr_thread = th->prev = th->next = th;
    }

d7773 10
d7785 1
a7785 1
	if ((status = THREAD_SAVE_CONTEXT(th)) == 0) {
d7801 1
a7801 1
	    if (ruby_safe_level >= 4) {
d7808 2
a7809 1
	else if (thread_abort || th->abort || RTEST(ruby_debug)) {
d7828 1
a7828 2
    rb_thread_t th = rb_thread_alloc(rb_cThread);
    return rb_thread_start_0(fn, arg, th);
a7854 1
    THREAD_SAVE_CONTEXT(th);
d7857 1
a7857 1
    if (th->stk_pos == pos) {
a7868 3
    rb_thread_t th;

    th = rb_thread_check(thread);
a7869 1
	rb_thread_remove(th);
d7872 1
a7872 1
    return rb_thread_start_0(rb_thread_yield, args, th);
a7879 1
    VALUE t;
d7884 1
a7884 1
    return rb_thread_start_0(rb_thread_yield, args, rb_thread_alloc(rb_cThread));
d8182 1
a8182 1
    str = rb_str_new(0, strlen(cname)+6+16+9+1); /* 6:tags 16:addr 9:status 1:nul */ 
a8201 1
    th->status = THREAD_RUNNABLE;
d8361 1
@


1.119
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/11 06:29:06 $
a666 1
	if (TYPE(vars) != T_VARMAP) abort();
d731 1
d745 1
d802 1
d873 2
a874 2
    VALUE errat = Qnil;
    VALUE eclass;
d3279 1
a3279 1
	fprintf(stderr, "Exception `%s' at %s:%d\n",
d3281 2
a3282 1
		ruby_sourcefile, ruby_sourceline);
d4843 1
a4843 1
	
d4936 1
a4936 1
    VALUE self = ruby_top_self;
d6152 1
a6152 1
    VALUE block = rb_eval(self, node->nd_body);
a6628 3
static rb_thread_t main_thread;
/*static rb_thread_t curr_thread = 0;*/

a6756 1

a7006 1
    struct stat s;
a7300 1
    struct timeval zero;
d7643 3
a7698 1
	th->status = THREAD_RUNNABLE;
d7760 1
a7760 1
rb_thread_start_0(fn, arg, th)
d7763 1
a7763 1
    rb_thread_t th;
d7765 1
d7794 1
a7794 1
	if (THREAD_SAVE_CONTEXT(th) == 0) {
d7836 2
a7837 1
    return rb_thread_start_0(fn, arg, rb_thread_alloc(rb_cThread));
d7868 1
a7868 1
	rb_raise(rb_eThreadError, "uninitialized thread - check `initialize' of %s",
d7879 3
d7883 1
d7886 1
a7886 1
    return rb_thread_start_0(rb_thread_yield, args, rb_thread_check(thread));
d7893 3
d7899 1
a7899 1
    return rb_thread_start_0(rb_thread_yield, args, rb_thread_alloc(klass));
d8103 1
d8182 1
a8182 1
    char *s, *status;
d8217 2
a8218 2
    cont = Data_Wrap_Struct(rb_cCont, thread_mark,
					 thread_free, th);
a8489 1

@


1.118
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/10 07:03:15 $
d142 1
a142 1
	rb_raise(rb_eSecurityError, "Insecure operation `%s' for level %d",
d538 1
a538 1
    struct RVarmap *d_vars;
d563 1
a563 1
    _block.d_vars = ruby_dyna_vars;	\
d640 1
d667 1
d3424 1
a3424 1
	ruby_dyna_vars = new_dvar(0, 0, block->d_vars);
d3428 1
a3428 1
	ruby_dyna_vars = block->d_vars;
d4603 1
a4603 1
    struct RVarmap * volatile old_d_vars;
d4631 2
a4632 2
	old_d_vars = ruby_dyna_vars;
	ruby_dyna_vars = data->d_vars;
d4673 1
a4673 1
	ruby_dyna_vars = old_d_vars;
d5784 1
a5784 1
	rb_gc_mark(data->d_vars);
d5906 1
a5906 1
    for (vars = data->d_vars; vars; vars = vars->next) {
d5988 1
a5988 1
    for (vars = data->d_vars; vars; vars = vars->next) {
d7810 4
d8190 1
@


1.117
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/05 09:57:00 $
d7726 1
a7726 1
static VALUE rb_thread_raise _((int, VALUE*, VALUE));
d7809 1
a7809 1
	    rb_thread_raise(1, &ruby_errinfo, main_thread->thread);
d7815 1
a7815 1
	    rb_thread_raise(1, &err, main_thread->thread);
d7951 1
a7951 1
    if (curr_thread != curr_thread->next->prev) {
d8052 1
a8052 1
rb_thread_raise(argc, argv, thread)
d8055 1
a8055 1
    VALUE thread;
a8056 2
    rb_thread_t th = rb_thread_check(thread);

a8060 3
    if (ruby_safe_level > th->safe) {
	rb_secure(4);
    }
d8063 1
a8063 1
	return thread;
d8077 14
d8344 1
a8344 1
    rb_define_method(rb_cThread, "raise", rb_thread_raise, -1);
@


1.116
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/10/03 08:56:46 $
d799 1
d803 2
a804 1
	if (_old) _old->flag |= SCOPE_DONT_RECYCLE;\
d1264 1
a1264 1
	saved_scope->flag |= SCOPE_DONT_RECYCLE;
d3504 1
a3504 1
	old_scope->flag |= SCOPE_DONT_RECYCLE;
d3999 3
d4003 1
d4668 1
a4668 1
	    old_scope->flag |= SCOPE_DONT_RECYCLE;
d8173 2
a8174 3
    s = ALLOCA_N(char, strlen(cname)+6+16+9+1); /* 6:tags 16:addr 9:status 1:nul */
    sprintf(s, "#<%s:0x%lx %s>", cname, thread, status);
    str = rb_str_new2(s);
d8195 1
a8195 1
    ruby_scope->flag |= SCOPE_DONT_RECYCLE;
@


1.115
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/27 03:43:12 $
d3989 2
a3990 1
stack_length()
d3992 9
a4000 1
    VALUE pos;
d4003 1
a4003 1
    return rb_gc_stack_start - &pos + 0x80;
d4005 2
a4006 2
    return (&pos < rb_gc_stack_start) ? rb_gc_stack_start - &pos
	                              : &pos - rb_gc_stack_start;
d4125 1
a4125 1
	if (stack_length() > STACK_LEVEL_MAX) {
d6123 1
a6123 1
	return INT2FIX(-2);
d6748 1
a6748 1
    VALUE v;
d6752 1
a6752 1
    len = stack_length();
d6754 3
a6756 3
    th->stk_pos = (rb_gc_stack_start<(VALUE*)&v)?rb_gc_stack_start
				                :rb_gc_stack_start - len;
    if (len > th->stk_max)  {	
@


1.114
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/25 17:59:13 $
d7369 1
a7369 1
	    rb_raise(rb_eThreadError, "recursive join");
@


1.113
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/25 17:51:21 $
d7152 5
a7156 1
	if (th->status <= THREAD_RUNNABLE) {
@


1.112
log
@matz
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/09/25 10:21:58 $
d5036 1
@


1.111
log
@eban
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/09/25 09:14:58 $
a240 1
    rb_clear_cache_by_id(mid);
d362 1
d412 1
d481 1
d488 1
d1500 1
d2858 1
d2899 1
d5044 3
a5046 3
	if (strncmp(f, feature, strlen(feature)) == 0) {
	    char *ext = strrchr(f, '.');
	    if (strcmp(ext, ".so") == 0) {
d5049 1
a5049 1
	    if (strcmp(ext, ".rb") == 0) {
d5354 1
@


1.110
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/22 18:15:41 $
a5029 1
    int len;
a5037 1
	len = strlen(f);
d5039 2
a5040 1
	    if (strcmp(f+len, ".so") == 0) {
d5043 1
a5043 1
	    if (strcmp(f+len, ".rb") == 0) {
@


1.109
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/21 06:37:14 $
d241 1
a361 1
	rb_clear_cache_by_id(mid);
a410 1
	    rb_clear_cache_by_id(name);
a1496 1
    rb_clear_cache_by_id(id);
a2825 1
		rb_clear_cache_by_id(node->nd_mid);
a2890 1
	    rb_clear_cache_by_id(node->nd_mid);
d5039 2
a5040 2
	len = strlen(feature);
	if (strncmp(f, feature, len) == 0) {
a5346 1
	rb_clear_cache_by_id(id);
@


1.108
log
@matz - net library bug (by me)
@
text
@d6 1
a6 1
  $Date: 2000/09/20 09:16:26 $
d5028 1
a5028 1
rb_provided(feature)
d5030 1
d5049 2
a5050 1
		goto load_wait;
d5075 7
d5100 1
a5100 1
    if (rb_provided(feature)) return;
d5114 2
a5115 1
    if (rb_provided(RSTRING(fname)->ptr)) return Qfalse;
@


1.107
log
@matz - disappointing fixes
@
text
@d6 1
a6 1
  $Date: 2000/09/18 16:28:34 $
d1883 1
d6026 1
a6026 1
    if (rb_block_given_p()) {
@


1.106
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/18 08:47:05 $
d3486 1
a3486 1
	
d5046 3
a5048 1
	    goto load_wait;
d5058 6
a5063 1
	    while (st_lookup(loading_tbl, f, 0)) {
d5196 2
a5197 1
    st_insert(loading_tbl, strdup(feature), 0);	/* partial state */
d5877 1
d5959 1
d7630 1
a7630 1
    th->dyna_vars = 0;\
d7650 1
d7668 4
d8158 1
d8170 6
@


1.105
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/15 06:00:23 $
d865 1
a865 1
    VALUE errat;
d880 4
a883 1
    if (!NIL_P(errat)) {
d5024 1
d5038 3
a5040 1
	if (strcmp(f, feature) == 0) return Qtrue;
d5042 5
a5046 3
	if (strncmp(f, feature, len) == 0
	    && (strcmp(f+len, ".rb") == 0 ||strcmp(f+len, ".so") == 0)) {
	    return Qtrue;
d5051 12
a5064 3
static int rb_thread_loading _((const char*));
static void rb_thread_loading_done _((const char*));

d5071 11
a5081 10
    if (!rb_provided(feature)) {
	ext = strrchr(feature, '.');
	if (ext && strcmp(DLEXT, ext) == 0) {
	    buf = ALLOCA_N(char, strlen(feature)+4);
	    strcpy(buf, feature);
	    ext = strrchr(buf, '.');
	    strcpy(ext, ".so");
	    feature = buf;
	}
	rb_ary_push(rb_features, rb_str_new2(feature));
d5083 2
d5097 1
d5100 1
a5101 1
	    feature = file = RSTRING(fname)->ptr;
a5105 1
	    file = feature = RSTRING(fname)->ptr;
a5109 2
		strcpy(ext, ".so");
		if (rb_provided(buf)) return Qfalse;
a5120 2
		strcpy(ext, ".so");
		if (rb_provided(buf)) return Qfalse;
a5168 1
    if (rb_thread_loading(feature)) return Qfalse;
a5177 1
    rb_thread_loading_done(feature);
a5183 1
    if (rb_thread_loading(feature)) return Qfalse;
d5185 5
d5196 2
a5197 1
    rb_thread_loading_done(feature);
a8032 29
}

static st_table *loading_tbl;

static int
rb_thread_loading(feature)
    const char *feature;
{
    if (!loading_tbl) {
	loading_tbl = st_init_strtable();
    }
    if (!rb_provided(feature)) {
	st_insert(loading_tbl, feature, 0);
	return Qfalse; /* need to load */
    }
    while (st_lookup(loading_tbl, feature, 0)) {
	CHECK_INTS;
	rb_thread_schedule();
    }
    return Qtrue;
}

static void
rb_thread_loading_done(feature)
    const char *feature;
{
    if (loading_tbl) {
	st_delete(loading_tbl, &feature, 0);
    }
@


1.104
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/12 06:41:23 $
a5076 2
    if (rb_provided(RSTRING(fname)->ptr)) return Qfalse;

@


1.103
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/12 05:37:20 $
d818 1
a819 1

d2229 1
a2229 1
	result = rb_yield_0(result, 0, 0, Qfalse);
d3506 1
a3506 1
    return rb_yield_0(val, 0, 0, Qfalse);
d3513 1
a3513 1
	rb_yield_0(Qnil, 0, 0, Qfalse);
d4812 1
a4812 1
	    result = rb_yield_0(self, self, ruby_class, Qfalse);
d4822 1
a4822 1
    return rb_yield_0(self, self, ruby_class, Qfalse);
a5454 3
VALUE rb_f_global_variables();
VALUE f_instance_variables();

d7781 1
a7781 1
    return rb_yield_0(callargs(arg), 0, 0, Qfalse);
d8335 1
a8335 1
	val = rb_yield_0(tag, 0, 0, Qfalse);
@


1.102
log
@matz: 1.6.0 final (hopufully)
@
text
@d6 1
a6 1
  $Date: 2000/09/01 08:10:49 $
d3430 1
a3430 1
		if (val != Qundef &&
@


1.101
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/01 07:25:20 $
d442 2
a443 1
static ID init, eqq, each, aref, aset, match, missing, added, singleton_added;
d3429 5
a3433 1
	    else
d3435 1
d3533 11
a3543 1
	val = rb_ary_new3(1, val);
d3565 3
d5589 1
a5983 2
      case 1:
	return RARRAY(args)->ptr[0];
@


1.100
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/09/01 03:30:57 $
d804 2
a805 1
	if (ruby_scope != top_scope) {	\
@


1.99
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/31 09:08:12 $
d5655 2
a5656 2
	    if (space > 256*1024) space = 256*1024;
	    STACK_LEVEL_MAX = (rlim.rlim_cur - space) / 4;
d6028 8
a6035 9
	if (orphan) {/* orphan procedure */
	    switch (state) {
	      case TAG_BREAK:
		rb_raise(rb_eLocalJumpError, "break from proc-closure");
		break;
	      case TAG_RETRY:
		rb_raise(rb_eLocalJumpError, "retry from proc-closure");
		break;
	      case TAG_RETURN:
a6036 1
		break;
d6038 3
a6041 1
	JUMP_TAG(state);
@


1.98
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/31 08:08:39 $
d801 6
a806 7
    else {				\
	if (ruby_scope->flag == SCOPE_ALLOCA) {\
	    ruby_scope->local_vars = 0;	\
	    ruby_scope->local_tbl  = 0;	\
	    if (ruby_scope != top_scope)\
		rb_gc_force_recycle((VALUE)ruby_scope);\
	}				\
d3453 1
d5688 10
a5697 9
    if (!(scope->flag & SCOPE_MALLOC)) {
	if (scope->local_tbl) {
	    tbl = scope->local_tbl;
	    vars = ALLOC_N(VALUE, tbl[0]+1);
	    *vars++ = scope->local_vars[-1];
	    MEMCPY(vars, scope->local_vars, VALUE, tbl[0]);
	    scope->local_vars = vars;
	    scope->flag = SCOPE_MALLOC;
	}
a5698 1
    scope->flag |= SCOPE_DONT_RECYCLE;
@


1.97
log
@000831
@
text
@d6 1
a6 1
  $Date: 2000/08/31 05:29:35 $
a807 3
	else {				\
	    ruby_scope->flag |= SCOPE_NOSTACK;\
	}				\
d809 1
d5688 10
a5698 10
    if (scope->flag & SCOPE_MALLOC) return;

    if (scope->local_tbl) {
	tbl = scope->local_tbl;
	vars = ALLOC_N(VALUE, tbl[0]+1);
	*vars++ = scope->local_vars[-1];
	MEMCPY(vars, scope->local_vars, VALUE, tbl[0]);
	scope->local_vars = vars;
	scope->flag = SCOPE_MALLOC;
    }
@


1.96
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/29 07:29:44 $
a796 1
#define SCOPE_DONT_RECYCLE FL_USER2
d798 2
a799 2
    if (FL_TEST(ruby_scope, SCOPE_DONT_RECYCLE)) {\
	FL_SET(_old, SCOPE_DONT_RECYCLE);\
d1257 2
a1258 2
    if (FL_TEST(ruby_scope, SCOPE_DONT_RECYCLE))
	FL_SET(saved_scope, SCOPE_DONT_RECYCLE);
d3490 2
a3491 2
    if (FL_TEST(ruby_scope, SCOPE_DONT_RECYCLE))
	FL_SET(old_scope, SCOPE_DONT_RECYCLE);
d4628 2
a4629 2
	if (FL_TEST(ruby_scope, SCOPE_DONT_RECYCLE))
	    FL_SET(old_scope, SCOPE_DONT_RECYCLE);
d5690 1
a5700 3
    else {
        scope->flag = SCOPE_NOSTACK;
    }
d8146 1
a8146 1
    FL_SET(ruby_scope, SCOPE_DONT_RECYCLE);
@


1.95
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/29 02:52:29 $
d25 8
d3717 4
a3720 1
rb_rescue2(b_proc, data1, eclass, r_proc, data2)
d3722 3
a3724 1
    VALUE data1, eclass, data2;
d3729 1
d3736 24
a3759 5
    else if (state == TAG_RAISE && rb_obj_is_kind_of(ruby_errinfo, eclass)) {
	if (r_proc) {
	    PUSH_TAG(PROT_NONE);
	    if ((state = EXEC_TAG()) == 0) {
		result = (*r_proc)(data2, ruby_errinfo);
d3761 2
a3762 2
	    POP_TAG();
	    if (state == TAG_RETRY) {
a3763 1
		goto retry_entry;
d3765 3
a3767 7
	}
	else {
	    result = Qnil;
	    state = 0;
	}
	if (state == 0) {
	    ruby_errinfo = e_info;
d3781 1
a3781 1
    return rb_rescue2(b_proc, data1, rb_eStandardError, r_proc, data2);
@


1.94
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/28 09:53:25 $
a1722 1
      case NODE_CVASGN3:
a1754 6
	if (rb_cvar_defined(CLASS_OF(self), node->nd_vid)) {
	    return "class variable";
	}
	break;

      case NODE_CVAR3:
a2579 5
	rb_cvar_set(CLASS_OF(self), node->nd_vid, result);
	break;

      case NODE_CVASGN3:
	result = rb_eval(self, node->nd_value);
a2618 4
	result = rb_cvar_get(CLASS_OF(self), node->nd_vid);
	break;

      case NODE_CVAR3:
@


1.93
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/25 08:25:58 $
a1721 1
      case NODE_CVASGN:
a2584 8
      case NODE_CVASGN:
	if (NIL_P(ruby_cbase)) {
	    rb_raise(rb_eTypeError, "no class/module to define class variable");
	}
	result = rb_eval(self, node->nd_value);
	rb_cvar_set(ruby_cbase, node->nd_vid, result);
	break;

a3613 4
      case NODE_CVASGN:
	rb_cvar_set(ruby_cbase, lhs->nd_vid, val);
	break;

d5048 1
a5048 1
    if (rb_thread_loading(RSTRING(fname)->ptr)) return Qfalse;
@


1.92
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/24 06:21:28 $
d1720 5
a1724 2
      case NODE_IASGN:
      case NODE_CASGN:
d1750 18
a2577 8
      case NODE_CASGN:
	if (NIL_P(ruby_cbase)) {
	    rb_raise(rb_eTypeError, "no class/module to define constant");
	}
	result = rb_eval(self, node->nd_value);
	ev_const_set(RNODE(ruby_frame->cbase), node->nd_vid, result);
	break;

d2594 10
d2639 8
a3614 4
      case NODE_CASGN:
	ev_const_set(RNODE(ruby_frame->cbase), lhs->nd_vid, val);
	break;

d3627 4
d5061 1
a5061 2
    if (rb_provided(RSTRING(fname)->ptr))
	return Qfalse;
d5140 1
a5141 1
    rb_provide(feature);
@


1.91
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/15 09:04:27 $
d3593 3
@


1.90
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/15 06:22:38 $
a1143 2
    char *mesg;
    int len;
a1144 1
    mesg = rb_str2cstr(ruby_errinfo, &len);
d1148 2
a1149 2
	rb_str_cat(str, " in ", 4);
	rb_str_cat(str, at, strlen(at));
d1152 3
a1154 1
    rb_str_cat(str, mesg, len);
d1680 4
a1683 1
	if (state) return 0;
d1753 4
a1756 1
	if (state) return 0;
d1794 1
d2731 2
d2743 1
d2746 1
a2746 2
			str2 = rb_eval(self, list->nd_head);
			str2 = rb_obj_as_string(str2);
d4580 5
a4584 1
	NODE *node = compile(src, file, line);
d4588 1
@


1.89
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/10 14:23:10 $
d508 1
d5686 1
a5686 1
	if (frame->argc > 0)
d5732 1
d7786 1
a7786 1
	if (NIL_P(th->errinfo) && (th->flags & THREAD_RAISED))
@


1.88
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/09 11:17:25 $
d1463 4
d2791 1
a2791 1
		rb_warn("re-defining Object#initialize may cause infinite loop");
d2863 1
a2863 1
		    rb_raise(rb_eSecurityError, "re-defining method prohibited");
d7785 2
a7786 2
	    return Qfalse;
	return Qnil;
@


1.87
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/09 07:34:59 $
d8108 1
a8108 1
	return rb_yield(th->thread);
@


1.86
log
@matz(ruby-bugs PR#51)
@
text
@d6 1
a6 1
  $Date: 2000/08/07 05:01:47 $
d8095 1
a8095 2
    th->status = THREAD_KILLED;
    th->thread = cont = Data_Wrap_Struct(rb_cCont, thread_mark,
d8102 2
a8103 2
    th->prev = 0;
    th->next = curr_thread;
d8120 1
a8120 1
    if (th->next != curr_thread) {
@


1.85
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/03 09:50:32 $
d8095 1
@


1.84
log
@matz - nakada win32 patch
@
text
@d6 1
a6 1
  $Date: 2000/08/02 09:50:36 $
d1519 1
d1797 1
a1797 1
    if (TYPE(block) == T_DATA && RDATA(block)->dfree == blk_free) {
d2796 1
a2796 1
		if (RTEST(ruby_verbose) && ruby_class == origin) {
d5936 6
d6611 1
a6611 1
    if (TYPE(data) != T_DATA || RDATA(data)->dfree != thread_free) {
d7099 1
d7101 1
d7113 1
a7113 1
    if (curr_thread == curr_thread->next) return;
d7123 1
@


1.83
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/02 09:22:22 $
d8114 1
a8114 1
    case 0:
d8117 1
a8117 1
    case 1:
d8120 1
a8120 1
    default:
@


1.82
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/02 04:54:10 $
d481 2
a6896 1
    extern int ruby_in_compile;
a6909 5
    if (ruby_in_compile) {
	printf("switch during compilation.\n");
	abort();
    }

d7092 1
@


1.81
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/27 09:49:15 $
d8113 3
@


1.80
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/19 08:04:46 $
d6771 2
a6772 1
rb_thread_remove()
d6774 5
a6778 4
    rb_thread_ready(curr_thread);
    curr_thread->status = THREAD_KILLED;
    curr_thread->prev->next = curr_thread->next;
    curr_thread->next->prev = curr_thread->prev;
d7666 1
a7666 1
    rb_thread_remove();
d8095 2
a8096 1
    th->prev = th->next = 0;
@


1.79
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/18 06:00:35 $
d1006 1
a1006 1
eval_node(self)
d1008 1
d1010 1
a1010 1
    NODE *beg_tree, *tree;
d1012 1
a1012 2
    beg_tree = ruby_eval_tree_begin;
    tree = ruby_eval_tree;
a1013 1
	ruby_eval_tree_begin = 0;
d1017 2
a1018 4
    if (!tree) return Qnil;
    ruby_eval_tree = 0;

    return rb_eval(self, tree);
d1111 1
a1111 1
	eval_node(ruby_top_self);
d4496 1
d4564 1
a4564 1
	compile(src, file, line);
d4568 1
a4568 1
	result = eval_node(self);
d4890 3
d4896 2
d4899 1
a4899 1
	    eval_node(self);
d6318 4
a6321 1
    rb_str_cat2(str, "#");
d6893 1
d6906 5
@


1.78
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/17 09:37:55 $
d95 1
a95 1
   1 - no dangerous operation by tainted string
d97 1
a97 1
   3 - all genetated strings are tainted
d5225 4
@


1.77
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/15 13:36:56 $
a1004 20
void
ruby_options(argc, argv)
    int argc;
    char **argv;
{
    int state;

    PUSH_TAG(PROT_NONE)
    if ((state = EXEC_TAG()) == 0) {
	ruby_process_options(argc, argv);
    }
    POP_TAG();
    if (state) {
	trace_func = 0;
	tracing = 0;
	error_print();
	exit(1);
    }
}

d1080 19
@


1.76
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/15 00:33:11 $
d435 1
d2790 4
d2802 1
a2802 1
		    /* should be upgrade to rb_warn() if no super was called? */
d5517 3
d6142 1
a6142 1
method_unbound(obj)
d6151 1
a6151 1
    data->recv = 0;
d6156 1
a6156 1
    OBJ_INFECT(method, orig->klass);
d6162 1
a6162 1
umethod_unbound(obj)
d6200 1
a6200 1
mcall(argc, argv, method, recv)
d6203 1
a6203 1
    VALUE method, recv;
d6217 1
a6217 1
	result = rb_call0(data->klass,recv,data->id,argc,argv,data->body,0);
d6227 1
a6227 1
method_call(argc, argv, method)
d6232 2
a6233 4
    struct METHOD *data;

    Data_Get_Struct(method, struct METHOD, data);
    return mcall(argc, argv, method, data->recv);
d6237 2
a6238 4
umethod_call(argc, argv, method)
    int argc;
    VALUE *argv;
    VALUE method;
d6240 1
a6240 2
    struct METHOD *data;
    VALUE recv;
a6241 5
    if (argc < 1) {
	rb_raise(rb_eArgError, "wrong # of arguments");
    }

    recv = argv[0];
d6256 6
a6261 1
    return mcall(argc-1, argv+1, method, recv);
d6397 1
a6397 1
    rb_define_method(rb_cMethod, "unbound", method_unbound, 0);
d6404 2
a6406 1
    rb_define_method(rb_cMethod, "unbound", umethod_unbound, 0);
@


1.75
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/14 04:34:35 $
a5560 1
    rb_undef_method(rb_cClass, "include");
d6128 21
a6148 3
    if (OBJ_TAINTED(obj) || OBJ_TAINTED(klass)) {
	OBJ_TAINT(method);
    }
d6154 7
d6205 1
a6205 2
    if (OBJ_TAINTED(recv) || OBJ_TAINTED(method)) {
	OBJ_TAINT(method);
d6209 1
a6209 2
	result = rb_call0(data->klass, recv, data->id,
			  argc, argv, data->body, 0);
d6237 1
d6242 2
a6243 1
    
d6245 12
a6256 7
    if (FL_TEST(CLASS_OF(argv[0]), FL_SINGLETON) &&
	st_lookup(RCLASS(CLASS_OF(argv[0]))->m_tbl, data->oid, 0)) {
	rb_raise(rb_eTypeError, "method `%s' overridden", rb_id2name(data->oid));
    }
    if (!rb_obj_is_instance_of(argv[0], data->oklass)) {
	rb_raise(rb_eTypeError, "first argument must be instance of %s",
		 rb_class2name(data->oklass));
d6258 1
a6258 1
    return mcall(argc-1, argv+1, method, argv[0]);
d6394 1
d6402 1
@


1.74
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/12 06:06:45 $
d81 1
d5561 3
d6101 3
a6103 3
rb_obj_method(obj, vid)
    VALUE obj;
    VALUE vid;
a6105 2
    VALUE klass = CLASS_OF(obj);
    ID id;
d6109 2
a6110 2

    id = rb_to_id(vid);
d6114 1
a6114 1
	return rb_undefined(obj, rb_to_id(vid), 0, 0, 0);
d6122 1
a6122 1
    method = Data_Make_Struct(rb_cMethod, struct METHOD, bm_mark, free, data);
d6127 3
a6129 3
    data->oklass = CLASS_OF(obj);
    data->oid = rb_to_id(vid);
    if (OBJ_TAINTED(obj)) {
d6137 16
d6160 1
a6160 1
    clone = Data_Make_Struct(rb_cMethod,struct METHOD,bm_mark,free,data);
d6168 1
a6168 1
method_call(argc, argv, method)
d6171 1
a6171 1
    VALUE method;
d6181 1
a6181 1
    if (OBJ_TAINTED(data->recv) || OBJ_TAINTED(method)) {
d6186 1
a6186 1
	result = rb_call0(data->klass, data->recv, data->id,
d6197 36
d6304 1
a6304 1
mcall(args, method)
d6314 10
d6327 8
a6334 1
    return rb_iterate(mproc, 0, mcall, method);
d6366 6
@


1.73
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/10 04:49:10 $
d2222 1
a2222 4
			if (state == 0) {
			    ruby_errinfo = e_info;
			}
			else if (state == TAG_RETRY) {
d2225 3
@


1.72
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/06 07:21:06 $
d2633 1
a2633 1
	result = rb_const_get(rb_cObject, node->nd_mid);
@


1.71
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/04 07:04:31 $
d781 3
d6321 1
a6321 1
typedef struct thread * rb_thread_t;
d6378 1
a6378 1
static rb_thread_t curr_thread = 0;
d7519 3
@


1.70
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/04 04:17:08 $
d2793 1
@


1.69
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/03 05:46:33 $
d5922 1
a5922 1
    if (TYPE(args) == T_ARRAY) {
@


1.68
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/01 06:46:33 $
d3682 1
a3682 1
rb_rescue(b_proc, data1, r_proc, data2)
d3684 1
a3684 1
    VALUE data1, data2;
d3695 1
a3695 1
    else if (state == TAG_RAISE && rb_obj_is_kind_of(ruby_errinfo, rb_eStandardError)) {
d3719 8
@


1.67
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/26 07:27:37 $
d1542 4
a1545 2
    rb_gc_force_recycle((VALUE)tmp__protect_tmp);\
    alloca(0);\
@


1.66
log
@select() scheduling bug
@
text
@d6 1
a6 1
  $Date: 2000/06/23 07:01:23 $
d2314 1
a2314 1
	    result = RTEST(rb_eval(self, node->nd_beg));
@


1.65
log
@2000-06-23
@
text
@d6 1
a6 1
  $Date: 2000/06/22 08:29:41 $
d6792 2
a6793 3
	if (!found) {
	    if (th->status <= THREAD_RUNNABLE)
		found = 1;
a6797 1
		th->wait_for = 0;
a6820 1
		th->wait_for = 0;
d6905 1
a6905 1
	    if (!next || next->priority < th->priority)
d6928 1
@


1.64
log
@2000-06-22
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/06/22 04:39:07 $
d4853 1
a4853 1
    ruby_frame->self = ruby_top_self;
@


1.63
log
@2000-06-22
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/06/19 08:38:04 $
d1423 22
d1459 1
a1459 1
    if (OBJ_FROZEN(klass)) rb_error_frozen("class/module");
d1501 1
d2783 1
a3001 1
	    if (OBJ_FROZEN(klass)) rb_error_frozen("object");
@


1.62
log
@2000-06-19
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/06/16 12:41:06 $
a71 8
#if !defined HAVE_PAUSE
# if defined _WIN32 && !defined __CYGWIN__
#  define pause() Sleep(INFINITE)
# else
#  define pause() sleep(0x7fffffff)
# endif
#endif

d7249 8
a7261 1
#ifdef HAVE_PAUSE
a7262 3
#else
	sleep((32767<<16)+32767);
#endif
@


1.61
log
@2000-06-16
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/06/16 07:44:01 $
a4560 1
	    errat = get_backtrace(ruby_errinfo);
d4563 1
d6292 1
a6292 1
typedef struct thread * thread_t;
d6335 1
a6335 1
    thread_t join;
d6348 2
a6349 2
static thread_t main_thread;
static thread_t curr_thread = 0;
d6371 1
a6371 1
    thread_t th;
d6426 1
a6426 1
    thread_t th;
d6436 1
a6436 1
    thread_t th;
d6448 1
a6448 1
static thread_t
d6456 1
a6456 1
    return (thread_t)RDATA(data)->data;
d6476 1
a6476 1
    thread_t th;
d6550 1
a6550 1
static void rb_thread_restore_context _((thread_t,int));
d6554 1
a6554 1
    thread_t th;
d6565 1
a6565 1
    thread_t th;
d6569 1
a6569 1
    static thread_t tmp;
d6614 1
a6614 1
    thread_t th;
d6631 1
a6631 1
    thread_t th;
d6640 1
a6640 1
    thread_t th;
d6743 3
a6745 3
    thread_t next;		/* OK */
    thread_t th;
    thread_t curr;
d7096 1
a7096 1
    thread_t th = rb_thread_check(thread);
d7138 1
a7138 1
    thread_t th;
d7159 1
a7159 1
    thread_t th = rb_thread_check(thread);
d7182 1
a7182 1
    thread_t th = rb_thread_check(thread);
d7262 1
d7264 3
d7281 1
a7281 1
    thread_t th = rb_thread_check(thread);;
d7293 1
a7293 1
    thread_t th;
d7307 1
a7307 1
    thread_t th;
d7337 1
a7337 1
    thread_t th = rb_thread_check(thread);
d7346 1
a7346 1
    thread_t th = rb_thread_check(thread);
d7389 1
a7389 1
static thread_t
d7393 1
a7393 1
    thread_t th;
d7469 1
a7469 1
    thread_t th;
d7546 1
a7546 1
    thread_t th;
d7558 1
a7558 1
    thread_t th = rb_thread_alloc(klass);
d7596 1
a7596 1
    thread_t th = rb_thread_check(thread);
d7607 1
a7607 1
    thread_t th = rb_thread_check(thread);
d7624 1
a7624 1
    thread_t th = rb_thread_check(thread);
d7634 1
a7634 1
    thread_t th = rb_thread_check(thread);
d7653 1
a7653 1
    thread_t th;
d7761 1
a7761 1
    thread_t th = rb_thread_check(thread);
d7820 1
a7820 1
    thread_t th;
d7847 1
a7847 1
    thread_t th = rb_thread_check(thread);
d7877 1
a7877 1
    thread_t th = rb_thread_check(thread);
d7890 1
a7890 1
    thread_t th = rb_thread_check(thread);
d7921 1
a7921 1
    thread_t th;
d7947 1
a7947 1
    thread_t th = rb_thread_check(cont);
d7991 1
a7991 1
    thread_t th;
d8011 1
a8011 1
    thread_t th;
@


1.60
log
@2000-06-16
@
text
@d6 1
a6 1
  $Date: 2000/06/14 08:08:47 $
d71 8
@


1.59
log
@2000-06-14-2
@
text
@d6 1
a6 1
  $Date: 2000/06/09 07:55:12 $
d7254 1
a7254 1
	sleep((32767L<<16)+32767);
@


1.58
log
@Thread#safe_level
@
text
@d6 1
a6 1
  $Date: 2000/06/05 08:46:48 $
d6168 2
a6169 1
	if (body->nd_rest >= 0) n = -n-1;
@


1.57
log
@2000-06-05
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/06/04 15:32:18 $
d7297 3
@


1.56
log
@see ChangeLog
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/05/31 16:40:04 $
d6883 1
a6883 1
	if (!next && (th->status <= THREAD_RUNNABLE)) {
d7286 1
d7647 1
@


1.55
log
@2000-06-01
@
text
@d6 1
a6 1
  $Date: 2000/05/31 03:10:00 $
d6831 1
a6831 1
	    if (errno = EINTR) goto again;
@


1.54
log
@2000-05-31
@
text
@d6 1
a6 1
  $Date: 2000/05/30 04:23:54 $
d1046 3
a1048 2
void
ruby_run()
a1049 29
    int state;
    static int ex;
    volatile NODE *tmp;

    if (ruby_nerrs > 0) exit(ruby_nerrs);

    Init_stack(&tmp);
    PUSH_TAG(PROT_NONE);
    PUSH_ITER(ITER_NOT);
    if ((state = EXEC_TAG()) == 0) {
	eval_node(ruby_top_self);
    }
    POP_ITER();
    POP_TAG();

    if (state && !ex) ex = state;
    PUSH_TAG(PROT_NONE);
    PUSH_ITER(ITER_NOT);
    if ((state = EXEC_TAG()) == 0) {
	rb_trap_exit();
	rb_thread_cleanup();
	rb_thread_wait_other_threads();
    }
    else {
	ex = state;
    }
    POP_ITER();
    POP_TAG();

d1094 36
d3364 1
d3376 1
d3385 1
d3464 4
a3467 9
    list = node->nd_head;

    if (TYPE(val) != T_ARRAY) {
#if 0
	if (!check && NIL_P(val))
	    val = rb_ary_new2(0);
	else
	    val = rb_ary_new3(1, val);
#else
a3468 1
#endif
d3471 1
d3479 3
a3481 1
	    /* ignore rest args */
d3513 1
d5415 1
a5415 1
    proc_call(data, Qnil);
d5447 3
d5858 1
a5858 1
	return Qnil;
@


1.53
log
@2000-05-30
@
text
@d5 2
a6 2
  $Author: eban $
  $Date: 2000/05/29 02:10:17 $
d6638 3
d6883 1
a6883 1
	    fprintf(stderr, "deadlock 0x%lx: %d:%d %s - %s:%d:\n", 
a6888 1
	rb_thread_deadlock();
d6890 1
a6891 1
	next->gid = 0;
d6893 1
@


1.52
log
@see ChangeLog.
@
text
@d5 2
a6 2
  $Author: matz $
  $Date: 2000/05/25 05:54:59 $
d6796 1
a6796 1
    if (need_select || !found) {
d7324 1
a7324 1
    th->status = 0;\
@


1.51
log
@2000-05-25
@
text
@d6 1
a6 1
  $Date: 2000/05/24 07:42:34 $
d4973 2
d4976 2
a4977 1
	    else if (strcmp(ext, DLEXT2) != 0) {
a4985 1
#endif
d4988 1
d4995 7
@


1.50
log
@emparassing thread bug
@
text
@d6 1
a6 1
  $Date: 2000/05/24 04:33:55 $
d3333 1
a3333 1
	rb_raise(rb_eLocalJumpError, "yield called out of iterator");
d3516 1
a3516 1
	    rb_bug("unexpected iterator variable assignment");
d5771 1
a5771 1
	rb_raise(rb_eArgError, "tried to create Procedure-Object out of iterator");
d6246 1
a6248 1
    THREAD_TO_KILL,
a6721 1
  select_err:
d6734 1
d6743 3
a6745 2
	if (!next && (th->status == THREAD_RUNNABLE || th->status == THREAD_TO_KILL)) {
	    found = 1;
d6747 7
a6753 5
	if ((th->wait_for & WAIT_JOIN) && rb_thread_dead(th->join)) {
	    th->join = 0;
	    th->wait_for = 0;
	    th->status = THREAD_RUNNABLE;
	    found = 1;
d6786 31
a6816 33
    if (need_select) {
	do {
	    /* Convert delay to a timeval */
	    /* If a thread is runnable, just poll */
	    if (found) {
		delay_tv.tv_sec = 0;
		delay_tv.tv_usec = 0;
		delay_ptr = &delay_tv;
	    }
	    else if (delay == DELAY_INFTY) {
		delay_ptr = 0;
	    }
	    else {
		delay_tv.tv_sec = delay;
		delay_tv.tv_usec = (delay - (double)delay_tv.tv_sec)*1e6;
		delay_ptr = &delay_tv;
	    }

	    n = select(max+1, &readfds, &writefds, &exceptfds, delay_ptr);
	    if (n < 0) {
		if (rb_trap_pending) rb_trap_exec();
		if (errno = EINTR) goto select_err;
		FOREACH_THREAD(th) {
		    if (th->wait_for & WAIT_SELECT) {
			int v = 0;

			v |= find_bad_fds(&readfds, &th->readfds, th->fd);
			v |= find_bad_fds(&writefds, &th->writefds, th->fd);
			v |= find_bad_fds(&exceptfds, &th->exceptfds, th->fd);
			if (v) {
			    th->select_value = n;
			    n = max;
			}
a6818 1
		END_FOREACH(th);
d6820 27
a6846 34
	    if (n >= 0) {
		now = -1.0;
		/* Some descriptors are ready. 
		   Make the corresponding threads runnable. */
		FOREACH_THREAD_FROM(curr, th) {
		    if ((th->wait_for&WAIT_FD) && FD_ISSET(th->fd, &readfds)) {
			/* Wake up only one thread per fd. */
			FD_CLR(th->fd, &readfds);
			th->status = THREAD_RUNNABLE;
			th->fd = 0;
			th->wait_for = 0;
			found = 1;
		    }
		    if ((th->wait_for&WAIT_SELECT) &&
			(match_fds(&readfds, &th->readfds, max) ||
			 match_fds(&writefds, &th->writefds, max) ||
			 match_fds(&exceptfds, &th->exceptfds, max))) {
			/* Wake up only one thread per fd. */
			th->status = THREAD_RUNNABLE;
			th->wait_for = 0;
			intersect_fds(&readfds, &th->readfds, max);
			intersect_fds(&writefds, &th->writefds, max);
			intersect_fds(&exceptfds, &th->exceptfds, max);
			th->select_value = n;
			found = 1;
		    }
		    if (th->wait_for & WAIT_TIME) {
			if (now < 0.0) now = timeofday();
			if (th->delay <= now) {
			    th->wait_for = 0;
			    th->status = THREAD_RUNNABLE;
			    found = 1;
			}
		    }
a6847 1
		END_FOREACH_FROM(curr, th);
d6849 2
a6850 1
	} while (!found && delay != DELAY_INFTY);
d6853 2
d6858 1
a6858 1
	if (th->status == THREAD_RUNNABLE || th->status == THREAD_TO_KILL) {
@


1.49
log
@2000-05-24
@
text
@d6 1
a6 1
  $Date: 2000/05/18 04:32:02 $
d6740 1
a6740 1
    now = timeofday();
d6766 5
a6770 2
	    if (th->delay <= now) {
		th->delay = 0.0;
d6774 2
a6775 2
	    } else if (th->delay < delay) {
		delay = th->delay;
d6796 2
a6797 3
		delay -= now;
		delay_tv.tv_sec = (unsigned int)delay;
		delay_tv.tv_usec = (long)((delay-(double)delay_tv.tv_sec)*1e6);
d6820 2
a6821 1
	    if (n > 0) {
d6845 8
@


1.48
log
@2000-05-18
@
text
@d6 1
a6 1
  $Date: 2000/05/17 06:33:45 $
d77 1
a77 1
static VALUE rb_f_iterator_p _((void));
d129 10
d143 7
a149 2
	rb_raise(rb_eSecurityError, "Insecure operation - %s",
		 rb_id2name(ruby_frame->last_func));
d151 1
a157 10
void
rb_secure(level)
    int level;
{
    if (level <= ruby_safe_level) {
	rb_raise(rb_eSecurityError, "Insecure operation `%s' for level %d",
		 rb_id2name(ruby_frame->last_func), ruby_safe_level);
    }
}

d1651 1
a1651 1
	if (rb_iterator_p()) {
d2571 1
a2571 1
	if (rb_iterator_p()) {
d3300 1
a3300 1
rb_iterator_p()
d3306 6
d3313 1
a3313 1
rb_f_iterator_p()
d4173 1
a4173 1
		if (!rb_iterator_p()) {
d4262 1
a4262 1
    PUSH_ITER(rb_iterator_p()?ITER_PRE:ITER_NOT);
d4723 1
a4723 1
    int   iter = rb_iterator_p();
d5222 1
a5222 1
    PUSH_ITER(rb_iterator_p()?ITER_PRE:ITER_NOT);
d5462 2
a5463 1
    rb_define_global_function("iterator?", rb_f_iterator_p, 0);
d5694 1
a5694 1
    data->iter = rb_f_iterator_p();
d5770 1
a5770 1
    if (!rb_iterator_p() && !rb_f_iterator_p()) {
d5872 1
a5872 1
	if (rb_iterator_p()) {
d6102 1
a6102 1
    PUSH_ITER(rb_iterator_p()?ITER_PRE:ITER_NOT);
a6627 1
#if 1
a6633 10
#else
    static int invoked = 0;

    if (invoked) return;
    invoked = 1;
    rb_prohibit_interrupt = 1;
    ruby_errinfo = rb_exc_new2(rb_eFatal, "Thread: deadlock");
    set_backtrace(ruby_errinfo, make_backtrace());
    rb_abort();
#endif
d6746 1
a6746 1
	if ((th->wait_for&WAIT_JOIN) && rb_thread_dead(th->join)) {
d6780 1
a6780 1
    if (need_select || !found) {
d6860 1
a6869 1
	/* raise fatal error to main thread */
d7183 1
a7183 1
	rb_raise(rb_eThreadError, "stopping only thread");
d7528 2
a7529 2
    if (!rb_iterator_p()) {
	rb_raise(rb_eThreadError, "must be called as iterator");
d7538 2
a7539 2
    if (!rb_iterator_p()) {
	rb_raise(rb_eThreadError, "must be called as iterator");
@


1.47
log
@thread problems
@
text
@d6 1
a6 1
  $Date: 2000/05/17 04:38:09 $
d70 2
d6289 1
d6687 17
d6761 1
a6761 1
	    th->fd = 0;
d6800 13
a6812 8
		switch (errno) {
		  case EBADF:
		    /* xxx */
		  case ENOMEM:
		    n = 0;
		    break;
		  default:
		    goto select_err;
d6814 1
d6838 1
a6838 1
			th->fd = n;
d7047 1
a7047 1
    return curr_thread->fd;
@


1.46
log
@2000-05-17
@
text
@d6 1
a6 1
  $Date: 2000/05/16 02:46:51 $
a6738 1
	    th->fd = 0;
d6741 1
d6888 1
d6890 1
a6890 1
    FD_SET(fd, &curr_thread->writefds);
d7015 1
a7015 1
	curr_thread->wait_for = WAIT_TIME;
@


1.45
log
@remove configure from repositry
@
text
@d6 1
a6 1
  $Date: 2000/05/12 09:07:34 $
d6692 7
a6698 2
    int waiting_on_fd = 0;
    int waiting_on_timer = 0;
d6713 7
d6721 1
a6721 1
	if (!found && (th->status == THREAD_RUNNABLE || th->status == THREAD_TO_KILL)) {
d6730 24
a6753 2
	if (th->wait_for&(WAIT_FD|WAIT_SELECT)) waiting_on_fd = 1;
	if (th->wait_for&WAIT_TIME) waiting_on_timer = 1;
d6756 3
a6758 10

    if (waiting_on_fd || waiting_on_timer) {
	fd_set readfds;
	fd_set writefds;
	fd_set exceptfds;
	struct timeval delay_tv, *delay_ptr;
	double delay, now;	/* OK */
	int n, max;

	
d6760 15
a6774 18
	    max = 0;
	    FD_ZERO(&readfds);
	    FD_ZERO(&writefds);
	    FD_ZERO(&exceptfds);
	    if (waiting_on_fd) {
		FOREACH_THREAD_FROM(curr, th) {
		    if (max < th->fd) max = th->fd;
		    if (th->wait_for & WAIT_FD) {
			FD_SET(th->fd, &readfds);
		    }
		    if (th->wait_for & WAIT_SELECT) {
			copy_fds(&readfds, &th->readfds, th->fd);
			copy_fds(&writefds, &th->writefds, th->fd);
			copy_fds(&exceptfds, &th->exceptfds, th->fd);
			th->fd = 0;
		    }
		}
		END_FOREACH_FROM(curr, th);
d6777 11
a6787 14
	    delay = DELAY_INFTY;
	    if (waiting_on_timer) {
		now = timeofday();
		FOREACH_THREAD_FROM(curr, th) {
		    if (th->wait_for & WAIT_TIME) {
			if (th->delay <= now) {
			    th->delay = 0.0;
			    th->wait_for = 0;
			    th->status = THREAD_RUNNABLE;
			    found = 1;
			} else if (th->delay < delay) {
			    delay = th->delay;
			}
		    }
a6788 1
		END_FOREACH_FROM(curr, th);
d6790 11
a6800 30
	    /* Do the select if needed */
	    if (waiting_on_fd || !found) {
		/* Convert delay to a timeval */
		/* If a thread is runnable, just poll */
		if (found) {
		    delay_tv.tv_sec = 0;
		    delay_tv.tv_usec = 0;
		    delay_ptr = &delay_tv;
		}
		else if (delay == DELAY_INFTY) {
		    delay_ptr = 0;
		}
		else {
		    delay -= now;
		    delay_tv.tv_sec = (unsigned int)delay;
		    delay_tv.tv_usec = (long)((delay-(double)delay_tv.tv_sec)*1e6);
		    delay_ptr = &delay_tv;
		}

		n = select(max+1, &readfds, &writefds, &exceptfds, delay_ptr);
		if (n < 0) {
		    if (rb_trap_pending) rb_trap_exec();
		    switch (errno) {
		      case EBADF:
			/* xxx */
		      case ENOMEM:
			n = 0;
			break;
		      default:
			goto select_err;
d6802 12
a6813 26
		}
		if (n > 0) {
		    /* Some descriptors are ready. 
		       Make the corresponding threads runnable. */
		    FOREACH_THREAD_FROM(curr, th) {
			if ((th->wait_for&WAIT_FD) && FD_ISSET(th->fd, &readfds)) {
			    /* Wake up only one thread per fd. */
			    FD_CLR(th->fd, &readfds);
			    th->status = THREAD_RUNNABLE;
			    th->fd = 0;
			    th->wait_for = 0;
			    found = 1;
			}
			if ((th->wait_for&WAIT_SELECT) &&
			    (match_fds(&readfds, &th->readfds, max) ||
			     match_fds(&writefds, &th->writefds, max) ||
			     match_fds(&exceptfds, &th->exceptfds, max))) {
			    /* Wake up only one thread per fd. */
			    th->status = THREAD_RUNNABLE;
			    th->wait_for = 0;
			    intersect_fds(&readfds, &th->readfds, max);
			    intersect_fds(&writefds, &th->writefds, max);
			    intersect_fds(&exceptfds, &th->exceptfds, max);
			    th->fd = n;
			    found = 1;
			}
a6814 1
		    END_FOREACH_FROM(curr, th);
d6816 1
a6817 2
	    /* The delays for some of the threads should have expired.
	       Go through the loop once more, to check the delays. */
d6819 2
d6824 2
a6825 2
       if (th->status == THREAD_RUNNABLE || th->status == THREAD_TO_KILL) {
	   if (!next || next->priority < th->priority)
d6827 1
a6827 1
       }
d6874 2
a6875 2
    FD_SET(fd, &curr_thread->readfds);
    curr_thread->wait_for |= WAIT_FD;
d6890 1
a6890 1
    curr_thread->wait_for |= WAIT_SELECT;
d6929 1
a6929 1
    curr_thread->wait_for |= WAIT_TIME;
d7003 6
a7008 3
    curr_thread->readfds = *read;
    curr_thread->writefds = *write;
    curr_thread->exceptfds = *except;
d7014 1
a7014 1
	curr_thread->wait_for |= WAIT_TIME;
d7017 3
a7019 3
    *read = curr_thread->readfds;
    *write = curr_thread->writefds;
    *except = curr_thread->exceptfds;
d7036 1
a7036 1
	curr_thread->wait_for |= WAIT_JOIN;
d7165 11
d7199 1
a7199 1
    curr_thread->wait_for |= WAIT_TIME;
@


1.44
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/10 02:58:33 $
d6238 4
a6241 2
#define WAIT_TIME	(1<<1)
#define WAIT_JOIN	(1<<2)
d6284 3
a6303 4
static int num_waiting_on_fd = 0;
static int num_waiting_on_timer = 0;
static int num_waiting_on_join = 0;

a6568 10
    /* The thread is no longer waiting on anything */
    if (th->wait_for & WAIT_FD) {
	num_waiting_on_fd--;
    }
    if (th->wait_for & WAIT_TIME) {
	num_waiting_on_timer--;
    }
    if (th->wait_for & WAIT_JOIN) {
	num_waiting_on_join--;
    }
d6596 1
a6596 1
	if ((th->wait_for & WAIT_FD) && th->fd == fd) {
d6631 53
d6692 3
d6709 8
a6716 16
       if (th->status == THREAD_RUNNABLE || th->status == THREAD_TO_KILL) {
	   found = 1;
	   break;
       }
    }
    END_FOREACH_FROM(curr, th); 

    if (num_waiting_on_join) {
	FOREACH_THREAD_FROM(curr, th) {
	    if ((th->wait_for&WAIT_JOIN) && rb_thread_dead(th->join)) {
		th->join = 0;
		th->wait_for &= ~WAIT_JOIN;
		th->status = THREAD_RUNNABLE;
		num_waiting_on_join--;
		found = 1;
	    }
d6718 2
a6719 1
	END_FOREACH_FROM(curr, th);
d6721 1
d6723 1
a6723 1
    if (num_waiting_on_fd > 0 || num_waiting_on_timer > 0) {
d6725 2
d6731 1
d6735 3
a6737 1
	    if (num_waiting_on_fd > 0) {
d6739 1
d6742 6
a6747 1
			if (th->fd > max) max = th->fd;
d6754 1
a6754 1
	    if (num_waiting_on_timer > 0) {
d6760 1
a6760 1
			    th->wait_for &= ~WAIT_TIME;
a6761 1
			    num_waiting_on_timer--;
d6771 1
a6771 1
	    if (num_waiting_on_fd > 0 || !found) {
d6789 1
a6789 1
		n = select(max+1, &readfds, 0, 0, delay_ptr);
d6794 1
d6806 1
a6806 2
			if ((th->wait_for&WAIT_FD)
			    && FD_ISSET(th->fd, &readfds)) {
d6811 14
a6824 2
			    th->wait_for &= ~WAIT_FD;
			    num_waiting_on_fd--;
d6887 1
a6887 2
    curr_thread->fd = fd;
    num_waiting_on_fd++;
d6896 1
a6896 2
    struct timeval zero;
    fd_set fds;
d6898 7
a6904 9
    if (curr_thread == curr_thread->next) return 1;

    zero.tv_sec = zero.tv_usec = 0;
    for (;;) {
	FD_ZERO(&fds);
	FD_SET(fd, &fds);
	if (select(fd+1, 0, &fds, 0, &zero) == 1) return 0;
	rb_thread_schedule();
    }
a6941 1
    num_waiting_on_timer++;
a6961 1
    fd_set r, *rp, w, *wp, x, *xp;
d7015 10
a7024 23
    for (;;) {
	zero.tv_sec = zero.tv_usec = 0;
	if (read) {rp = &r; r = *read;} else {rp = 0;}
	if (write) {wp = &w; w = *write;} else {wp = 0;}
	if (except) {xp = &x; x = *except;} else {xp = 0;}
	n = select(max, rp, wp, xp, &zero);
	if (n > 0) {
	    /* write back fds */
	    if (read) {*read = r;}
	    if (write) {*write = w;}
	    if (except) {*except = x;}
	    return n;
	}
	if (n < 0 && errno != EINTR) {
	    return n;
	}
	if (timeout) {
	    if (timeout->tv_sec == 0 && timeout->tv_usec == 0) return 0;
	    if (limit <= timeofday()) return 0;
	}

        rb_thread_schedule();
	CHECK_INTS;
d7026 5
a7045 1
	num_waiting_on_join++;
a7196 1
    num_waiting_on_timer++;
d7286 3
a7288 1
    th->fd = 0;\
@


1.43
log
@2000-05-10
@
text
@d6 1
a6 1
  $Date: 2000/05/09 04:52:53 $
a1364 1
    VALUE tmp;
d2762 3
d2766 1
a2766 1
		noex =  node->nd_noex;
d4557 1
a4557 1
    VALUE src, scope, vfile, vline, val;
d4665 1
a4665 1
	volatile VALUE cbase = ruby_block->frame.cbase;
d4982 2
a4983 3
    file = rb_find_file(buf);
    if (file) {
	fname = rb_str_new2(file);
d6494 1
a6494 1
	return 1;
d6496 1
@


1.42
log
@2000-05-09
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:41:14 $
d3440 1
d3445 3
d4643 6
a4648 1
    Check_SafeStr(src);
d6644 1
d6659 8
d6674 1
d6684 1
a6684 1
	int n, max, found;
a6786 3
	    if (th->status == THREAD_STOPPED) {
		next = th;
	    }
d6791 1
@


1.41
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/17 15:39:37 $
d11 1
a11 1
  Copyright (C) 2000  Information-technology Promotion Agancy, Japan
d3440 1
a3440 1
	if (NIL_P(val))
d4940 1
a4940 1
		buf = ALLOCA_N(char, strlen(file)+sizeof(DLEXT)+1);
d4943 2
a4946 1
		if (rb_provided(feature)) return Qfalse;
d4948 11
d4984 9
d6383 3
a6385 3
    if (th->status != THREAD_KILLED && th->prev) {
	th->prev->next = th->next;
	th->next->prev = th->prev;
a6648 8
    FOREACH_THREAD_FROM(curr, th) {
       if (th->status == THREAD_RUNNABLE || th->status == THREAD_TO_KILL) {
	   if (!next || next->priority < th->priority)
	       next = th;
       }
    }
    END_FOREACH_FROM(curr, th); 

a6655 2
		if (!next || next->priority < th->priority)
		    next = th;
d6665 1
a6665 1
	int n, max;
d6690 1
a6690 2
			    if (!next || next->priority < th->priority)
				next = th;
d6699 1
a6699 1
	    if (num_waiting_on_fd > 0 || !next) {
d6702 1
a6702 1
		if (next) {
d6741 1
a6741 2
			    if (!next || next->priority < th->priority)
				next = th; /* Found one. */
d6749 8
a6756 1
	} while (!next && delay != DELAY_INFTY);
d6758 1
d7785 1
@


1.40
log
@2000-04-18
@
text
@d1 1
a1 1
/************************************************
d6 1
a6 1
  $Date: 2000/04/10 05:44:06 $
d10 2
d13 1
a13 1
************************************************/
d1842 1
a1842 1
rb_eval(self, node)
d1844 1
a1844 1
    NODE * volatile node;
d1846 1
d2751 4
d2764 1
a2764 1
		noex = NOEX_PUBLIC;
d2792 4
a2795 1
	    if (rb_special_const_p(recv)) {
d2797 1
a2797 1
			 "can't define method \"%s\" for %s",
a2801 3
	    if (rb_safe_level() >= 4 && !OBJ_TAINTED(recv)) {
		rb_raise(rb_eSecurityError, "can't define singleton method");
	    }
d3005 1
a3005 1
module_setup(module, node)
d3007 1
a3007 1
    NODE * volatile node;
d3009 1
d3439 15
a3453 6
    if (val) {
	if (TYPE(val) != T_ARRAY) {
	    if (NIL_P(val))
		val = rb_ary_new2(0);
	    else
		val = rb_ary_new3(1, val);
d3455 2
a3456 4
	len = RARRAY(val)->len;
	for (i=0; list && i<len; i++) {
	    assign(self, list->nd_head, RARRAY(val)->ptr[i], check);
	    list = list->nd_next;
d3458 2
a3459 11
	if (check && list) goto arg_error;
	if (node->nd_args) {
	    if (node->nd_args == (NODE*)-1) {
		/* ignore rest args */
	    }
	    else if (!list && i<len) {
		assign(self, node->nd_args, rb_ary_new4(len-i, RARRAY(val)->ptr+i), check);
	    }
	    else {
		assign(self, node->nd_args, rb_ary_new2(0), check);
	    }
a3460 4
	else if (check && i<len) goto arg_error;
    }
    else if (node->nd_args && node->nd_args != (NODE*)-1) {
	assign(self, node->nd_args, Qnil, check);
a3462 1
    if (check && list) goto arg_error;
d6203 1
a6203 1
    THREAD_KILLED,
d6265 1
d6267 1
a6286 2
static thread_t main_thread;

d6362 3
a6364 5
    if (th->status != THREAD_KILLED) {
	if (th->prev)
	    th->prev->next = th->next;
	if (th->next)
	    th->next->prev = th->prev;
a7991 1
    /* not reached */
@


1.39
log
@2000-04-10
@
text
@d6 1
a6 1
  $Date: 2000/03/23 08:37:24 $
d6362 4
a6365 2
	th->prev->next = th->next;
	th->next->prev = th->prev;
@


1.38
log
@2000-03-23
@
text
@d6 1
a6 1
  $Date: 2000/03/17 08:58:10 $
d2689 2
a2690 2
		    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
		    if (OBJ_TAINTED(str2)) OBJ_TAINT(str);
d4527 2
a4528 2
		    rb_str_cat(err, ": ", 2);
		    rb_str_concat(err, ruby_errinfo);
d4563 1
a4563 1
    if (ruby_safe_level >= 3) {
d4700 6
a4705 1
	Check_SafeStr(argv[0]);
d5716 1
a5716 1
proc_s_new(klass)
d5751 12
d5766 1
a5766 1
    return proc_s_new(rb_cProc);
d5784 15
d5821 1
a5821 8
	switch (RARRAY(args)->len) {
	  case 0:
	    args = Qnil;
	    break;
	  case 1:
	    args = RARRAY(args)->ptr[0];
	    break;
	}
d6115 2
a6116 2
    rb_str_cat(str, s, strlen(s));
    rb_str_cat(str, ": ", 2);
d6118 2
a6119 2
    rb_str_cat(str, s, strlen(s));
    rb_str_cat(str, "#", 1);
d6121 2
a6122 2
    rb_str_cat(str, s, strlen(s));
    rb_str_cat(str, ">", 1);
d6166 1
a6166 1
    rb_define_singleton_method(rb_cProc, "new", proc_s_new, 0);
d6361 4
d7302 1
a7302 1
rb_thread_create_0(fn, arg, klass)
d7305 1
a7305 1
    VALUE klass;
a7306 1
    thread_t th = rb_thread_alloc(klass);
d7370 1
a7370 1
    return rb_thread_create_0(fn, arg, rb_cThread);
d7385 31
a7415 1
    return rb_yield_0(arg, 0, 0, Qfalse);
d7425 1
a7425 1
    return rb_thread_create_0(rb_thread_yield, args, klass);
d7804 3
a7806 1
thgroup_s_new(klass)
d7816 1
d7864 2
a7865 1
    rb_define_singleton_method(rb_cThread, "new", rb_thread_start, -2);
d7916 1
a7916 1
    rb_define_singleton_method(cThGroup, "new", thgroup_s_new, 0);
d7919 1
a7919 1
    rb_define_const(cThGroup, "Default", thgroup_s_new(cThGroup));
d7949 1
a7949 1
    return rb_funcall(Qnil, rb_intern("catch"), 0, INT2FIX(tag));
d8002 1
a8002 1
    argv[0] = INT2FIX(t);
@


1.37
log
@2000-03-17
@
text
@d6 1
a6 1
  $Date: 2000/03/15 09:05:36 $
d423 2
d459 1
d465 1
a468 1
static ID init, eqq, each, aref, aset, match, missing;
d1300 1
a1300 1
	  case NODE_CVAR:
d1316 1
a1316 1
#define ruby_cbase (((NODE*)ruby_frame->cbase)->nd_clss)
d1381 1
a1381 1
    NODE *cbase = (NODE*)ruby_frame->cbase;
d1394 1
a1394 1
    NODE *cbase = (NODE*)ruby_frame->cbase;
d1688 2
a1689 2
      case NODE_CVAR:
	if (ev_const_defined((NODE*)ruby_frame->cbase, node->nd_vid)) {
d2500 1
a2500 1
	if (NIL_P(ruby_class)) {
d2504 1
a2504 1
	ev_const_set((NODE*)ruby_frame->cbase, node->nd_vid, result);
d2515 3
a2517 3
      case NODE_SHASGN:
	if (NIL_P(ruby_class)) {
	    rb_raise(rb_eTypeError, "no class/module to define shared variable");
d2520 1
a2520 1
	rb_shared_variable_set(ruby_cbase, node->nd_vid, result);
d2523 3
a2525 3
      case NODE_SHDECL:
	if (NIL_P(ruby_class)) {
	    rb_raise(rb_eTypeError, "no class/module to define shared variable");
d2528 1
a2528 1
	rb_shared_variable_declare(ruby_class, node->nd_vid, result);
d2550 2
a2551 2
      case NODE_CVAR:
	result = ev_const_get((NODE*)ruby_frame->cbase, node->nd_vid);
d2554 2
a2555 2
      case NODE_SHVAR:
	result = rb_shared_variable_get(ruby_cbase, node->nd_vid);
d2766 1
a2766 2
		rb_funcall(ruby_class, rb_intern("singleton_method_added"),
			   1, INT2FIX(node->nd_mid));
d2770 1
a2770 2
			   rb_intern("singleton_method_added"),
			   1, INT2FIX(node->nd_mid));
d2773 1
a2773 2
		rb_funcall(ruby_class, rb_intern("method_added"),
			   1, INT2FIX(node->nd_mid));
d2808 1
a2808 2
	    rb_funcall(recv, rb_intern("singleton_method_added"),
		       1, INT2FIX(node->nd_mid));
d2826 1
a2826 2
	rb_funcall(ruby_class, rb_intern("method_added"),
		   1, INT2FIX(node->nd_mid));
d3508 1
a3508 1
	ev_const_set((NODE*)ruby_frame->cbase, lhs->nd_vid, val);
d3515 3
a3517 3
      case NODE_SHDECL:
      case NODE_SHASGN:
	rb_shared_variable_set(ruby_cbase, lhs->nd_vid, val);
d4398 1
a4398 1
    int i, lev;
a4400 1
    lev = INT2FIX(0);
a4409 3
    VALUE lev;

    lev = INT2FIX(0);
a4594 1
    VALUE cbase = ruby_frame->cbase;
d4603 4
a4606 1
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,under,0,cbase);
d5128 1
d5398 2
@


1.36
log
@2000-03-15
@
text
@d6 1
a6 1
  $Date: 2000/03/13 07:18:33 $
d1807 4
a1810 1
	if (TYPE(klass) == T_ICLASS || FL_TEST(klass, FL_SINGLETON)) {
d1820 1
a1820 1
					  INT2FIX(id),
d4008 1
a4008 1
		call_trace_func("c-call", 0, 0, 0, id, klass);
d4569 6
a4574 1
    Check_SafeStr(src);
@


1.35
log
@2000-03-13
@
text
@d6 1
a6 1
  $Date: 2000/03/08 06:23:13 $
a6942 9
static VALUE
rb_thread_s_join(dmy, thread)	/* will be removed in 1.4 */
    VALUE dmy;
    VALUE thread;
{
    rb_warn("Thread::join is obsolete; use Thread#join instead");
    return rb_thread_join(thread);
}

a7803 1
    rb_define_singleton_method(rb_cThread, "join", rb_thread_s_join, 1);
@


1.34
log
@2000-03-08
@
text
@d6 1
a6 1
  $Date: 2000/03/07 08:37:29 $
d3225 2
d3239 4
a3242 2
	mesg = rb_funcall(argv[0], rb_intern("exception"), 0, 0);
	break;
d3244 7
a3250 2
      case 2:
	mesg = rb_funcall(argv[0], rb_intern("exception"), 1, argv[1]);
d3256 1
a3256 1
    if (!NIL_P(mesg)) {
d3751 3
a3753 1
    if (argc == 0) rb_raise(rb_eArgError, "no id given");
d3755 1
a3755 1
    id = NUM2INT(argv[0]);
d5906 14
a5919 2
	state &= TAG_MASK;
	orphan = 2;
d5925 10
a5934 12
	if (orphan == 2) {/* escape from orphan procedure */
	    switch (state) {
	      case TAG_BREAK:
		rb_raise(rb_eLocalJumpError, "break from proc-closure");
		break;
	      case TAG_RETRY:
		rb_raise(rb_eLocalJumpError, "retry from proc-closure");
		break;
	      case TAG_RETURN:
		rb_raise(rb_eLocalJumpError, "return from proc-closure");
		break;
	    }
@


1.33
log
@2000-03-07
@
text
@d6 1
a6 1
  $Date: 2000/03/06 04:15:29 $
d343 1
a343 1
	rb_add_method(ruby_class, mid, 0, NOEX_UNDEF);
d4305 1
a4305 1
	rb_raise(rb_eNameError, "superclass method `%s' disabled",
@


1.32
log
@2000-03-06
@
text
@d6 1
a6 1
  $Date: 2000/02/25 03:51:17 $
a34 6
#ifdef USE_CWGUSI
#include <sys/stat.h>
#include <sys/errno.h>
#include <compat.h>
#endif

d3811 1
a3811 1
    nargv[0] = INT2FIX(id);
@


1.31
log
@2000-02-25
@
text
@d6 1
a6 1
  $Date: 2000/02/23 05:23:04 $
d4301 21
@


1.30
log
@2000-02-23
@
text
@d6 1
a6 1
  $Date: 2000/02/18 06:59:28 $
d6606 2
a6607 1
			    next = th;
d7220 1
a7220 1
    tval.it_interval.tv_usec = 50000;
@


1.29
log
@2000-02-18
@
text
@d6 1
a6 1
  $Date: 2000/02/17 07:11:07 $
d5961 15
d6112 1
@


1.28
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:48:45 $
d1319 2
d1405 1
a1405 1
    rb_mod_const_of(((NODE*)ruby_frame->cbase)->nd_clss, ary);
d2515 16
d2554 4
d3511 5
d4463 1
a4463 1
    ruby_class = ((NODE*)ruby_frame->cbase)->nd_clss;
@


1.27
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/02/01 03:12:00 $
d3362 1
a3362 1
	if (ruby_dyna_vars->id == 0) {
d3723 1
a3723 1
    id = FIX2INT(argv[0]);
d5792 1
a5792 1
    if (data->var == 0) return FIX2INT(-1);
d5989 1
a5989 1
	if (body->nd_rest) n = -n-1;
d6264 15
d6285 3
a6287 1
    int len = stack_length();
d6319 35
a6366 15
static int   th_raise_argc;
static VALUE th_raise_argv[2];
static char *th_raise_file;
static int   th_raise_line;
static VALUE th_cmd;
static int   th_sig;
static char *th_signm;

#define RESTORE_NORMAL		0 
#define RESTORE_FATAL		1
#define RESTORE_INTERRUPT	2
#define RESTORE_TRAP		3
#define RESTORE_RAISE		4
#define RESTORE_SIGNAL		5

d6413 1
a6413 29
    switch (ex) {
      case RESTORE_FATAL:
	JUMP_TAG(TAG_FATAL);
	break;

      case RESTORE_INTERRUPT:
	rb_interrupt();
	break;

      case RESTORE_TRAP:
	rb_trap_eval(th_cmd, th_sig);
	errno = EINTR;
	break;

      case RESTORE_SIGNAL:
	rb_raise(rb_eSignal, "SIG%s", th_signm);
	break;

      case RESTORE_RAISE:
	ruby_frame->last_func = 0;
	ruby_sourcefile = th_raise_file;
	ruby_sourceline = th_raise_line;
	rb_f_raise(th_raise_argc, th_raise_argv);
	break;

      case RESTORE_NORMAL:
      default:
	longjmp(tmp->context, 1);
    }
d6651 1
a6651 2
	rb_thread_save_context(curr);
	if (setjmp(curr->context)) {
d7220 1
a7220 2
    rb_thread_save_context(curr_thread);
    if (setjmp(curr_thread->context)) {
d7226 1
a7226 2
	rb_thread_save_context(th);
	if (setjmp(th->context) == 0) {
d7393 1
a7393 2
    rb_thread_save_context(curr_thread);
    if (setjmp(curr_thread->context)) {
d7411 1
a7411 2
    rb_thread_save_context(curr_thread);
    if (setjmp(curr_thread->context)) {
d7424 1
d7432 1
a7432 2
    rb_thread_save_context(curr_thread);
    if (setjmp(curr_thread->context)) {
d7439 13
d7462 1
a7462 1
    if (rb_thread_dead(th)) return thread;
d7466 1
a7466 1
    if (th->safe < 4) {
d7470 1
a7470 3
    if (curr_thread->status != THREAD_KILLED)
	rb_thread_save_context(curr_thread);
    if (setjmp(curr_thread->context)) {
d7631 1
a7631 2
    rb_thread_save_context(th);
    if (setjmp(th->context)) {
d7810 1
a7810 1
    return rb_funcall(Qnil, rb_intern("catch"), 0, FIX2INT(tag));
d7863 1
a7863 1
    argv[0] = FIX2INT(t);
@


1.26
log
@2000-02-01
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:37:39 $
d7269 1
a7269 1
    int arg;
d7273 1
a7273 1
    return rb_yield_0(th->thread, 0, 0, Qfalse);
d7277 2
a7278 2
rb_thread_start(klass)
    VALUE klass;
d7283 1
a7283 1
    return rb_thread_create_0(rb_thread_yield, 0, klass);
d7711 3
a7713 3
    rb_define_singleton_method(rb_cThread, "new", rb_thread_start, 0);
    rb_define_singleton_method(rb_cThread, "start", rb_thread_start, 0);
    rb_define_singleton_method(rb_cThread, "fork", rb_thread_start, 0);
@


1.25
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:36:59 $
d93 1
a93 1
static int safe_level = 0;
a101 6
int
rb_safe_level()
{
    return safe_level;
}

d106 2
a107 2
    if (level > safe_level) {
	safe_level = level;
d114 1
a114 1
    return INT2FIX(safe_level);
d123 1
a123 1
    if (level < safe_level) {
d125 1
a125 1
		 safe_level, level);
d127 1
a127 1
    safe_level = level;
d134 1
a134 1
    if (safe_level > 0 && OBJ_TAINTED(x)){
d148 1
a148 1
    if (level <= safe_level) {
d150 1
a150 1
		 rb_id2name(ruby_frame->last_func), safe_level);
d222 1
a222 1
    if (safe_level >= 4 && !OBJ_TAINTED(klass)) {
d225 1
d304 1
a304 1
    if (safe_level >= 4 && !OBJ_TAINTED(klass)) {
d307 1
d566 1
a566 1
#define DVAR_DONT_RECYCLE FL_USER0
d597 14
d634 1
a634 1
dvar_asgn(id, value, push)
d637 1
a637 1
    int push;
d639 1
d643 4
a646 1
	if (push && vars->id == 0) break;
d653 7
a659 1
    rb_dvar_push(id, value);
d663 1
a663 1
rb_dvar_asgn(id, value)
d667 1
a667 1
    dvar_asgn(id, value, 0);
d671 1
a671 1
dvar_asgn_push(id, value)
d675 1
a675 11
    struct RVarmap* vars = 0;

    if (ruby_dyna_vars && ruby_dyna_vars->id == 0) {
	vars = ruby_dyna_vars;
	ruby_dyna_vars = ruby_dyna_vars->next;
    }
    dvar_asgn(id, value, 1);
    if (vars) {
	vars->next = ruby_dyna_vars;
	ruby_dyna_vars = vars;
    }
d1211 1
a1211 1
    volatile int safe = safe_level;
d1225 1
a1225 1
	safe_level = 4;
d1235 1
a1235 1
    safe_level = safe;
d1418 1
a1418 1
    if (safe_level >= 4 && !OBJ_TAINTED(klass)) {
d1421 1
a1442 1
    rb_clear_cache_by_id(id);
d1666 1
a1666 1
      case NODE_DASGN_PUSH:
d2479 1
a2479 1
	rb_dvar_asgn(node->nd_vid, result);
d2482 1
a2482 1
      case NODE_DASGN_PUSH:
d2484 1
a2484 1
	dvar_asgn_push(node->nd_vid, result);
d2722 1
a2722 1
		if (RTEST(ruby_verbose)) {
d2773 1
a2773 1
	    if (safe_level >= 4 && !OBJ_TAINTED(recv)) {
d2776 1
d2779 1
a2779 1
		if (safe_level >= 4) {
d2858 2
a2859 2
			rb_raise(rb_eTypeError, "superclass mismatch for %s",
				 rb_id2name(node->nd_cname));
d2862 1
a2862 1
		if (safe_level >= 4) {
d2868 1
d2907 1
a2907 1
		if (safe_level >= 4) {
d2934 1
a2934 1
	    if (safe_level >= 4 && !OBJ_TAINTED(klass))
d2936 1
d3237 6
a3242 2
    PUSH_FRAME();		/* fake frame */
    *ruby_frame = *_frame.prev->prev;
a3243 1
    POP_FRAME();
d3474 1
a3474 1
	rb_dvar_asgn(lhs->nd_vid, val);
d3477 2
a3478 2
      case NODE_DASGN_PUSH:
	dvar_asgn_push(lhs->nd_vid, val);
d3799 1
a3799 1
# define STACK_LEVEL_MAX 65535
d4627 1
a4627 1
    if (safe_level >= 4 && !OBJ_TAINTED(self))
d4861 1
a4861 1
    volatile int safe = safe_level;
d4929 1
a4929 1
    safe_level = 0;
d4939 1
a4939 1
    safe_level = safe;
d5607 1
a5607 1
#define PROC_T5    (FL_USER1|FL_USER2)
d5615 1
a5615 1
	switch (safe_level) {
d5622 4
a5625 2
	  case 5:
	    FL_SET(data, PROC_T5);
d5638 1
a5638 1
	    safe_level = 3;
d5641 1
a5641 1
	    safe_level = 4;
d5643 2
a5644 2
	  case PROC_T5:
	    safe_level = 5;
d5716 1
a5716 1
    volatile int safe = safe_level;
d5762 1
a5762 1
    safe_level = safe;
d5820 1
a5820 1
    volatile int safe = safe_level;
d5857 1
a5857 1
    safe_level = safe;
d5942 1
a5942 1
    volatile int safe = safe_level;
d5949 1
a5949 1
	if (safe_level < 4) safe_level = 4;
d5957 1
a5957 1
    safe_level = safe;
d6144 1
d6296 1
a6296 1
    th->safe = safe_level;
d6363 1
a6363 1
    safe_level = th->safe;
d6621 4
a6624 3
	    fprintf(stderr, "%s:%d:deadlock 0x%lx: %d:%d %s\n", 
		    th->file, th->line, th->thread, th->status,
		    th->wait_for, th==main_thread?"(main)":"");
d6633 1
d6925 3
d6933 1
d7010 1
a7010 1
    if (safe_level >= 4 && th != curr_thread) {
d7106 1
d7125 1
d7135 1
a7135 1
#if defined(HAVE_SETITIMER) && !defined(__BOW__)
d7158 1
a7158 1
#if defined(HAVE_SETITIMER) && !defined(__BOW__)
d7197 1
a7197 1
#if defined(HAVE_SETITIMER) && !defined(__BOW__)
d7210 1
d7356 1
d7449 3
d7508 1
a7508 1
    if (safe_level >= 4 && th != curr_thread) {
d7533 1
a7533 1
    if (safe_level >= 4 && th != curr_thread) {
d7536 1
d7649 54
d7706 2
d7761 6
@


1.24
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/14 06:49:40 $
d242 1
d2288 5
d3342 1
a3342 1
	do {
d3345 4
a3348 1
	} while (vars && vars->id != 0);
d3391 4
a3394 1
	    val = rb_Array(val);
@


1.23
log
@19991214
@
text
@d6 1
a6 1
  $Date: 1999/12/07 09:23:23 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
d569 2
d795 1
d996 1
d1117 1
a1117 1
    mesg = str2cstr(ruby_errinfo, &len);
d1404 3
d1491 4
d1498 1
a1780 1
    volatile VALUE trace;
d1787 1
d1789 1
a1789 4
    trace = trace_func;
    trace_func = 0;
    rb_thread_critical++;

d1807 6
a1812 6
	proc_call(trace, rb_ary_new3(6, rb_str_new2(event),
				     srcfile,
				     INT2FIX(ruby_sourceline),
				     INT2FIX(id),
				     self?rb_f_binding(self):Qnil,
				     klass));
d1817 1
a1817 2
    rb_thread_critical--;
    if (!trace_func) trace_func = trace;
d2299 1
d2313 1
d2346 1
d2408 1
a2781 3
	if (ruby_class == rb_cObject) {
	    rb_secure(4);
	}
d3018 1
d3332 9
d3361 4
a3364 1
    for (;;) { rb_yield_0(Qnil, 0, 0, Qfalse); }
d3563 1
d4101 1
a4664 78
static int
is_absolute_path(path)
    const char *path;
{
    if (path[0] == '/') return 1;
# if defined(MSDOS) || defined(NT) || defined(__human68k__) || defined(__EMX__)
    if (path[0] == '\\') return 1;
    if (strlen(path) > 2 && path[1] == ':') return 1;
# endif
    return 0;
}

#ifdef __MACOS__
static int
is_macos_native_path(path)
    const char *path;
{
    if (strchr(path, ':')) return 1;
    return 0;
}
#endif

static char*
find_file(file)
    char *file;
{
    volatile VALUE vpath;
    char *path;

#ifdef __MACOS__
    if (is_macos_native_path(file)) {
	FILE *f = fopen(file, "r");

	if (f == NULL) return 0;
	fclose(f);
	return file;
    }
#endif

    if (is_absolute_path(file)) {
	FILE *f = fopen(file, "r");

	if (f == NULL) return 0;
	fclose(f);
	return file;
    }

    if (file[0] == '~') {
	VALUE argv[1];
	argv[0] = rb_str_new2(file);
	file = STR2CSTR(rb_file_s_expand_path(1, argv));
    }

    if (rb_load_path) {
	int i;

	Check_Type(rb_load_path, T_ARRAY);
	vpath = rb_ary_new();
	for (i=0;i<RARRAY(rb_load_path)->len;i++) {
	    VALUE str = RARRAY(rb_load_path)->ptr[i];
	    Check_SafeStr(str);
	    if (RSTRING(str)->len > 0) {
		rb_ary_push(vpath, str);
	    }
	}
	vpath = rb_ary_join(vpath, rb_str_new2(PATH_SEP));
	path = STR2CSTR(vpath);
	if (safe_level >= 2 && !rb_path_check(path)) {
	    rb_raise(rb_eSecurityError, "loading from unsafe path %s", path);
	}
    }
    else {
	path = 0;
    }

    return dln_find_file(file, path);
}

d4683 1
a4683 1
    file = find_file(RSTRING(fname)->ptr);
d4704 1
d4747 1
d4843 1
a4843 1
	    file = find_file(file);
d4856 1
a4856 1
	    file = find_file(file);
d4861 1
a4861 1
	    file = find_file(feature);
d4868 1
a4868 1
    file = find_file(buf);
d4876 1
a4876 1
    file = find_file(buf);
d5527 1
a5527 1
    CLONESETUP(bind,self);
d5546 1
d5568 3
d5626 1
d5647 3
a6092 1
    VALUE trace;
d6098 1
a6165 1
    rb_gc_mark(th->trace);
d6244 1
a6244 1
REALLOC_N(th->stk_ptr, VALUE, len);
d6260 1
a6266 1
    th->trace = trace_func;
d6329 1
a6333 1
    trace_func = th->trace;
d6473 1
a6473 1
       if (th->status != THREAD_STOPPED && th->status != THREAD_KILLED) {
d6844 20
d6992 10
d7062 1
d7269 12
d7524 30
a7553 1
static VALUE rb_cContinuation;
d7564 1
a7564 1
    th->thread = cont = Data_Wrap_Struct(rb_cContinuation, thread_mark,
d7581 1
a7581 1
rb_continuation_call(argc, argv, cont)
d7599 1
d7621 1
d7631 1
d7636 1
a7636 1
    rb_define_method(rb_cThread, "alive?", rb_thread_status, 0);
d7645 1
d7651 2
d7656 3
a7658 3
    rb_cContinuation = rb_define_class("Continuation", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cContinuation), "new");
    rb_define_method(rb_cContinuation, "call", rb_continuation_call, -1);
d7689 1
a7689 1
    return rb_f_catch(0, FIX2INT(tag));
@


1.22
log
@991207
@
text
@d6 1
a6 1
  $Date: 1999/12/06 09:03:50 $
d93 67
d228 3
a297 32
void
rb_alias(klass, name, def)
    VALUE klass;
    ID name, def;
{
    VALUE origin;
    NODE *orig, *body;

    if (name == def) return;
    if (klass == rb_cObject) {
	rb_secure(4);
    }
    orig = search_method(klass, def, &origin);
    if (!orig || !orig->nd_body) {
	if (TYPE(klass) == T_MODULE) {
	    orig = search_method(rb_cObject, def, &origin);
	}
    }
    if (!orig || !orig->nd_body) {
	print_undef(klass, def);
    }
    body = orig->nd_body;
    if (nd_type(body) == NODE_FBODY) { /* was alias */
	def = body->nd_mid;
	origin = body->nd_orig;
	body = body->nd_head;
    }

    st_insert(RCLASS(klass)->m_tbl, name,
	      NEW_METHOD(NEW_FBODY(body, def, origin), orig->nd_noex));
}

d308 3
d326 8
a791 69
static int safe_level = 0;
/* safe-level:
   0 - strings from streams/environment/ARGV are tainted (default)
   1 - no dangerous operation by tainted string
   2 - process/file operations prohibited
   3 - all genetated strings are tainted
   4 - no global (non-tainted) variable modification/no direct output
*/

int
rb_safe_level()
{
    return safe_level;
}

void
rb_set_safe_level(level)
    int level;
{
    if (level > safe_level) {
	safe_level = level;
    }
}

static VALUE
safe_getter()
{
    return INT2FIX(safe_level);
}

static void
safe_setter(val)
    VALUE val;
{
    int level = NUM2INT(val);

    if (level < safe_level) {
	rb_raise(rb_eSecurityError, "tried to downgrade safe level from %d to %d",
		 safe_level, level);
    }
    safe_level = level;
}

void
rb_check_safe_str(x)
    VALUE x;
{
    if (TYPE(x)!= T_STRING) {
	rb_raise(rb_eTypeError, "wrong argument type %s (expected String)",
		 rb_class2name(CLASS_OF(x)));
    }
    if (OBJ_TAINTED(x)) {
	if (safe_level > 0){
	    rb_raise(rb_eSecurityError, "Insecure operation - %s",
		     rb_id2name(ruby_frame->last_func));
	}
    }
}

void
rb_secure(level)
    int level;
{
    if (level <= safe_level) {
	rb_raise(rb_eSecurityError, "Insecure operation `%s' for level %d",
		 rb_id2name(ruby_frame->last_func), safe_level);
    }
}

d1305 1
a1305 1
ev_shvar_defined(cref, id)
d1320 1
a1320 1
    return rb_shvar_defined(cref->nd_clss, id);
d1324 1
a1324 1
ev_shvar_get(cref, id)
d1339 1
a1339 1
    return rb_shvar_get(cref->nd_clss, id);
d1343 1
a1343 1
ev_shvar_set(cref, id, val)
d1360 1
a1360 1
    rb_shvar_assign(cbase->nd_clss, id, val);
d1378 1
a1378 1
rb_mod_s_shvars()
d1384 1
a1384 1
	rb_mod_shvar_at(cbase->nd_clss, ary);
d1388 1
a1388 1
    rb_mod_shvar_of(((NODE*)ruby_frame->cbase)->nd_clss, ary);
d1392 37
d1430 1
a1430 1
rb_mod_remove_method(mod, name)
d1433 1
a1433 1
    remove_method(mod, rb_to_id(name));
d1437 4
a1440 3
static VALUE
rb_mod_undef_method(mod, name)
    VALUE mod, name;
d1442 2
a1443 1
    ID id = rb_to_id(name);
d1445 23
a1467 3
    rb_add_method(mod, id, 0, NOEX_PUBLIC);
    rb_clear_cache_by_id(id);
    return mod;
d1474 1
a1474 4
    ID id = rb_to_id(newname);

    rb_alias(mod, id, rb_to_id(oldname));
    rb_clear_cache_by_id(id);
d1667 1
a1667 1
	if (ev_shvar_defined((NODE*)ruby_frame->cbase, node->nd_vid)) {
d1683 1
a1683 1
		if (rb_shvar_defined_at(val, node->nd_mid))
d2474 1
a2474 1
	ev_shvar_set((NODE*)ruby_frame->cbase, node->nd_vid, result);
d2482 1
a2482 1
	rb_shvar_set(ruby_class, node->nd_vid, result);
d2505 1
a2505 1
	result = ev_shvar_get((NODE*)ruby_frame->cbase, node->nd_vid);
d2532 1
a2532 1
	    result = rb_shvar_get(klass, node->nd_mid);
d2537 1
a2537 1
	result = rb_shvar_get(rb_cObject, node->nd_mid);
d2693 3
a2695 8
	    if (body) {
		if (origin == ruby_class) {
		    if (safe_level >= 4) {
			rb_raise(rb_eSecurityError, "re-defining method prohibited");
		    }
		    if (RTEST(ruby_verbose)) {
			rb_warning("discarding old %s", rb_id2name(node->nd_mid));
		    }
d2745 1
a2745 1
	    if (rb_safe_level() >= 4 && !FL_TEST(recv, FL_TAINT)) {
d2767 5
a2771 33
	{
	    VALUE origin;
	    NODE *body;

	    if (NIL_P(ruby_class)) {
		rb_raise(rb_eTypeError, "no class to undef method");
	    }
	    if (ruby_class == rb_cObject) {
		rb_secure(4);
	    }
	    body = search_method(ruby_class, node->nd_mid, &origin);
	    if (!body || !body->nd_body) {
		char *s0 = " class";
		VALUE klass = ruby_class;

		if (FL_TEST(ruby_class, FL_SINGLETON)) {
		    VALUE obj = rb_iv_get(ruby_class, "__attached__");
		    switch (TYPE(obj)) {
		      case T_MODULE:
		      case T_CLASS:
			klass = obj;
			s0 = "";
		    }
		}
		else if (TYPE(klass) == T_MODULE) {
		    s0 = " module";
		}
		rb_raise(rb_eNameError, "undefined method `%s' for%s `%s'",
			 rb_id2name(node->nd_mid),s0,rb_class2name(klass));
	    }
	    rb_clear_cache_by_id(node->nd_mid);
	    rb_add_method(ruby_class, node->nd_mid, 0, NOEX_PUBLIC);
	    result = Qnil;
d2773 2
d2807 10
a2816 6
	    if (rb_shvar_defined_at(ruby_class, node->nd_cname) &&
		(ruby_class != rb_cObject || !rb_autoload_defined(node->nd_cname))) {
		klass = rb_shvar_get(ruby_class, node->nd_cname);
	    }
	    if (ruby_wrapper && rb_shvar_defined_at(rb_cObject, node->nd_cname)) {
		klass = rb_shvar_get(rb_cObject, node->nd_cname);
d2844 1
a2844 1
		rb_shvar_set(ruby_class, node->nd_cname, klass);
d2864 10
a2873 7
	    if (rb_shvar_defined_at(ruby_class, node->nd_cname) &&
		(ruby_class != rb_cObject ||
		 !rb_autoload_defined(node->nd_cname))) {
		module = rb_shvar_get(ruby_class, node->nd_cname);
	    }
	    if (ruby_wrapper && rb_shvar_defined_at(rb_cObject, node->nd_cname)) {
		module = rb_shvar_get(rb_cObject, node->nd_cname);
d2886 1
a2886 1
		rb_shvar_set(ruby_class, node->nd_cname, module);
d2907 2
d2913 1
d3432 1
a3432 1
	ev_shvar_set((NODE*)ruby_frame->cbase, lhs->nd_vid, val);
d3436 1
a3436 1
	rb_shvar_set(ruby_class, lhs->nd_vid, val);
d4575 1
a4575 1
    if (rb_safe_level() >= 4 && !FL_TEST(self, FL_TAINT))
a4666 1
    extern VALUE rb_load_path;
d4709 1
a4709 1
	    rb_raise(rb_eSecurityError, "loading from unsefe path %s", path);
d4885 1
a4886 1
    rb_secure(4);
d4953 1
d4963 1
d5418 1
a5418 3
    rb_define_singleton_method(rb_cModule, "shared_variables", rb_mod_s_shvars, 0);
    /* to be removed at 1.6 */
    rb_define_singleton_method(rb_cModule, "constants", rb_mod_s_shvars, 0);
d5634 1
a5634 1
    if (FL_TEST(data, FL_TAINT)) {
d5653 1
a5653 1
    if (FL_TEST(data, FL_TAINT)) {
d5940 2
a5941 2
    if (FL_TEST(obj, FL_TAINT)) {
	FL_SET(method, FL_TAINT);
d5961 2
a5962 2
    if (FL_TEST(data->recv, FL_TAINT) || FL_TEST(method, FL_TAINT)) {
	FL_SET(method, FL_TAINT);
d6157 1
d6288 2
a6289 2
    if (len > th->stk_max)  {
	REALLOC_N(th->stk_ptr, VALUE, len);
d6519 2
a6520 2
           next = th;
           break;
d6532 2
a6533 1
		if (!next) next = th;
d6619 2
a6620 1
			    if (!next) next = th; /* Found one. */
d6992 25
d7029 1
d7049 1
d7082 1
d7100 1
d7327 1
a7327 1
rb_thread_get_critical()
d7333 1
a7333 1
rb_thread_set_critical(obj, val)
d7466 3
d7491 3
a7493 2
    if (safe_level >= 4 && !FL_TEST(thread, FL_TAINT))
	rb_raise(rb_eSecurityError, "Insecure: can't modify thread values");
d7594 2
a7595 2
    rb_define_singleton_method(rb_cThread, "critical", rb_thread_get_critical, 0);
    rb_define_singleton_method(rb_cThread, "critical=", rb_thread_set_critical, 1);
d7612 3
@


1.21
log
@19991206
@
text
@d6 1
a6 1
  $Date: 1999/12/02 06:58:47 $
d52 22
d3739 3
d3745 2
d3874 1
a3874 1
    if ((++tick & 0x3ff) == 0) {
d5419 13
a6083 18

#include <sys/types.h>
#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
#else
#ifndef NT
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};
#endif /* NT */
#endif
#include <signal.h>
#include <errno.h>

#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
@


1.20
log
@19991292
@
text
@d6 1
a6 1
  $Date: 1999/11/29 06:32:57 $
d3306 1
d4865 1
d6025 1
a6025 1
    rb_undef_method(CLASS_OF(rb_cMethod), "new");
a7365 1
    if (!rb_provided(feature)) return Qfalse; /* need to load */
d7368 4
@


1.19
log
@19991129
@
text
@d6 1
a6 1
  $Date: 1999/11/26 09:07:22 $
d7380 1
a7380 1
	st_delete(loading_tbl, feature, 0);
@


1.18
log
@mark_end_proc
@
text
@d6 1
a6 1
  $Date: 1999/11/17 07:30:29 $
d4685 1
d4702 1
d4706 1
d4753 1
a4753 1
    ruby_wrapper = 0;
d5226 2
a5227 1
static struct end_proc_data *end_proc_data;
d5235 1
d5237 3
a5239 1
    link->next = end_proc_data;
d5242 1
a5242 1
    end_proc_data = link;
d5248 1
a5248 1
    struct end_proc_data *link = end_proc_data;
d5250 6
d5295 8
a5302 3
    while (end_proc_data) {
	link = end_proc_data;
	end_proc_data = link->next;
@


1.17
log
@19991117
@
text
@d6 1
a6 1
  $Date: 1999/11/10 06:47:07 $
a5234 1
    rb_global_variable(&link->data);
d5238 11
d5279 1
a5279 2
    struct end_proc_data *link = end_proc_data;
    struct end_proc_data *tmp;
d5282 3
a5284 1
    while (link) {
a5285 1
	tmp = link->next;
a5286 1
	link = tmp;
a5287 1
    end_proc_data = 0;
@


1.16
log
@19991110
@
text
@d6 1
a6 1
  $Date: 1999/11/08 03:57:00 $
d1303 1
a1303 1
ev_const_defined(cref, id)
d1318 1
a1318 1
    return rb_const_defined(cref->nd_clss, id);
d1322 1
a1322 1
ev_const_get(cref, id)
d1332 1
a1332 2
	if (klass->iv_tbl &&
	    st_lookup(klass->iv_tbl, id, &result)) {
d1337 23
a1359 1
    return rb_const_get(cref->nd_clss, id);
d1376 1
a1376 1
rb_mod_s_constants()
d1382 1
a1382 1
	rb_mod_const_at(cbase->nd_clss, ary);
d1386 1
a1386 1
    rb_mod_const_of(((NODE*)ruby_frame->cbase)->nd_clss, ary);
d1609 1
a1609 1
	if (ev_const_defined((NODE*)ruby_frame->cbase, node->nd_vid)) {
d1625 1
a1625 1
		if (rb_const_defined_at(val, node->nd_mid))
d2416 6
a2421 5
	/* check for static scope constants */
	if (RTEST(ruby_verbose) &&
	    ev_const_defined((NODE*)ruby_frame->cbase, node->nd_vid)) {
	    rb_warn("already initialized constant %s",
		       rb_id2name(node->nd_vid));
d2423 2
a2424 1
	rb_const_set(ruby_class, node->nd_vid, result);
d2447 1
a2447 1
	result = ev_const_get((NODE*)ruby_frame->cbase, node->nd_vid);
d2474 1
a2474 1
	    result = rb_const_get_at(klass, node->nd_mid);
d2479 1
a2479 1
	result = rb_const_get_at(rb_cObject, node->nd_mid);
d2780 1
a2780 1
	    if (rb_const_defined_at(ruby_class, node->nd_cname) &&
d2782 1
a2782 1
		klass = rb_const_get_at(ruby_class, node->nd_cname);
d2784 2
a2785 2
	    if (ruby_wrapper && rb_const_defined_at(rb_cObject, node->nd_cname)) {
		klass = rb_const_get_at(rb_cObject, node->nd_cname);
d2813 1
a2813 1
		rb_const_set(ruby_class, node->nd_cname, klass);
d2833 1
a2833 1
	    if (rb_const_defined_at(ruby_class, node->nd_cname) &&
d2836 1
a2836 1
		module = rb_const_get_at(ruby_class, node->nd_cname);
d2838 2
a2839 2
	    if (ruby_wrapper && rb_const_defined_at(rb_cObject, node->nd_cname)) {
		module = rb_const_get_at(rb_cObject, node->nd_cname);
d2852 1
a2852 1
		rb_const_set(ruby_class, node->nd_cname, module);
d3394 5
a3398 1
	rb_const_set(ruby_class, lhs->nd_vid, val);
d5347 3
a5349 1
    rb_define_singleton_method(rb_cModule, "constants", rb_mod_s_constants, 0);
@


1.15
log
@19991108
@
text
@d6 1
a6 1
  $Date: 1999/11/04 08:39:36 $
d295 1
a295 1
    if (!body || !body->nd_body || origin != klass) {
d298 6
a303 1
    body->nd_noex &= ~NOEX_UNDEF;
d1704 1
a1704 1
    *ruby_frame = *_frame.prev;
d1866 3
a1868 2
			call_trace_func("line", tag->nd_file, nd_line(tag),
					self, ruby_frame->last_func, 0);	
d2877 3
a2879 2
	    call_trace_func("line", ruby_sourcefile, ruby_sourceline,
			    self, ruby_frame->last_func, 0);	
d2933 3
a2935 2
	    call_trace_func("class", file, line,
			    ruby_class, ruby_frame->last_func, 0);
d2946 2
a2947 1
	call_trace_func("end", file, line, 0, ruby_frame->last_func, 0);
d3084 3
a3086 1
			ruby_frame->self, ruby_frame->last_func, 0);
d3852 1
a3852 1
		call_trace_func("c-call", 0, 0, 0, id, 0);
d3964 1
a3964 1
				    recv, ruby_frame->last_func, 0);
d3982 1
a3982 2
		call_trace_func("return", file, line, recv,
				ruby_frame->last_func, klass);
d4378 1
a4378 1
    VALUE src, scope, vfile, vline;
d4392 13
d5498 1
@


1.14
log
@19991104
@
text
@d6 1
a6 1
  $Date: 1999/10/16 10:33:05 $
d1501 1
d5309 1
d6092 1
@


1.13
log
@ruby -v
@
text
@d6 1
a6 1
  $Date: 1999/10/15 08:52:15 $
d1774 1
a1774 1
			   rb_eval(self,node->nd_value));
d1844 6
a1849 1
	    val = rb_eval(self, node->nd_head);
d2342 3
a2344 4
	if (RTEST(result)) {
	    result = rb_eval(self, node->nd_value);
	}
	break;
d2348 3
a2350 4
	if (!RTEST(result)) {
	    result = rb_eval(self, node->nd_value);
	}
	break;
@


1.12
log
@-r debug, -s, etc.
@
text
@d6 1
a6 1
  $Date: 1999/10/13 09:31:56 $
d796 3
d4154 3
@


1.11
log
@block->tag pointing out of stack
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:32 $
a968 2
static int ext_init = 0;

a978 1
	ext_init = 1;	/* Init_ext() called in ruby_process_options */
a1013 12
static void
call_required_libraries()
{
    NODE *save;

    ruby_sourcefile = 0;
    if (!ext_init) Init_ext();
    save = ruby_eval_tree;
    ruby_require_libraries();
    ruby_eval_tree = save;
}

a1026 1
	call_required_libraries();
d1685 1
d1709 1
d1711 1
a1711 1
				     rb_str_new2(ruby_sourcefile),
@


1.10
log
@19991012
@
text
@d6 1
a6 1
  $Date: 1999/10/04 04:51:04 $
d5552 1
d5593 1
d5605 2
a5606 1
    ruby_block = data;
d5631 1
d5697 1
d5720 2
a5721 1
    ruby_block = data;
d5726 1
d5734 1
a5734 1
    if (ruby_block->tag->dst == state) {
@


1.10.2.1
log
@block->tag pointing out of stack
@
text
@d6 1
a6 1
  $Date: 1999/10/12 04:53:32 $
a5551 1
    data->tag = 0;		/* should not point into stack */
a5591 1
    struct BLOCK _block;
d5603 1
a5603 2
    _block = *data;
    ruby_block = &_block;
a5627 1
    _block.tag = prot_tag;
a5692 1
    struct BLOCK _block;
d5715 1
a5715 2
    _block = *data;
    ruby_block = &_block;
a5719 1
    _block.tag = prot_tag;
d5727 1
a5727 1
    if (_block.tag->dst == state) {
@


1.10.2.2
log
@19991109
@
text
@d6 1
a6 1
  $Date: 1999/10/13 09:32:03 $
d295 1
a295 1
    if (!body) {
d298 1
a298 6
    if (!body->nd_body) {
	remove_method(klass, mid);
    }
    else {
	body->nd_noex &= ~NOEX_UNDEF;
    }
a1513 1
	else if (ruby_frame->last_class == 0) return 0;
d1710 1
a1710 1
    *ruby_frame = *prev;
d4372 1
a4372 1
    VALUE src, scope, vfile, vline, val;
a4385 13
    if (NIL_P(scope) && ruby_frame->prev) {
	struct FRAME *prev;
	VALUE val;

	prev = ruby_frame;
	PUSH_FRAME();
	*ruby_frame = *prev->prev;
	ruby_frame->prev = prev;
	val = eval(self, src, scope, file, line);
	POP_FRAME();

	return val;
    }
a5312 1
    rb_global_variable(&trace_func);
a5477 1
	data->frame.last_class = ruby_frame->prev->last_class;
a6094 1
    rb_gc_mark(th->trace);
@


1.10.2.3
log
@19991129
@
text
@d6 1
a6 1
  $Date: 1999/11/09 03:57:26 $
a4657 1
    volatile VALUE wrapper = 0;
a4673 1
    wrapper = ruby_wrapper;
a4676 1
	ruby_wrapper = 0;
d4723 1
a4723 1
    ruby_wrapper = wrapper;
d5196 1
a5196 2

static struct end_proc_data *end_procs, *ephemeral_end_procs;
a5203 1
    struct end_proc_data **list;
d5205 1
a5205 3
    if (ruby_wrapper) list = &ephemeral_end_procs;
    else              list = &end_procs;
    link->next = *list;
d5208 2
a5209 18
    *list = link;
}

void
rb_mark_end_proc()
{
    struct end_proc_data *link;

    link = end_procs;
    while (link) {
	rb_gc_mark(link->data);
	link = link->next;
    }
    link = ephemeral_end_procs;
    while (link) {
	rb_gc_mark(link->data);
	link = link->next;
    }
d5242 2
a5243 1
    struct end_proc_data *link;
a5245 1
    link = end_procs;
d5248 1
a5248 6
	link = link->next;
    }
    while (ephemeral_end_procs) {
	link = ephemeral_end_procs;
	ephemeral_end_procs = link->next;
	rb_protect((VALUE(*)())link->func, link->data, &status);
d5250 1
d5252 1
@


1.10.2.4
log
@19991202
@
text
@d6 1
a6 1
  $Date: 1999/11/29 06:30:59 $
d7351 1
a7351 1
	st_delete(loading_tbl, &feature, 0);
@


1.10.2.5
log
@19991206
@
text
@d6 1
a6 1
  $Date: 1999/12/02 07:49:25 $
a4836 1
		if (rb_provided(feature)) return Qfalse;
d5994 1
a5994 1
    rb_undef_method(CLASS_OF(rb_cBinding), "new");
d7335 3
a7337 6
    if (!rb_provided(feature)) {
	if (!loading_tbl) {
	    loading_tbl = st_init_strtable();
	}
	st_insert(loading_tbl, feature, 0);
	return Qfalse; /* need to load */
@


1.10.2.6
log
@19991208
@
text
@d6 1
a6 1
  $Date: 1999/12/06 09:03:27 $
a7335 3
    if (!loading_tbl) {
	loading_tbl = st_init_strtable();
    }
d7337 3
@


1.10.2.7
log
@20000105
@
text
@d6 1
a6 1
  $Date: 1999/12/07 16:47:15 $
a4688 1
    ruby_frame->last_class = 0;
d6071 1
d6143 1
d6244 1
d6311 1
d7551 1
a7551 1
    return rb_funcall(Qnil, rb_intern("catch"), 0, FIX2INT(tag));
@


1.10.2.8
log
@2000-01-17
@
text
@d6 1
a6 1
  $Date: 2000/01/05 04:41:01 $
d9 1
a9 1
  Copyright (C) 1993-2000 Yukihiro Matsumoto
a149 1
    if (!klass) return 0;
a1706 1
    VALUE srcfile;
a1729 1
	srcfile = rb_str_new2(ruby_sourcefile?ruby_sourcefile:"(ruby)");
d1731 1
a1731 1
				     srcfile,
@


1.10.2.9
log
@2000-01-24
@
text
@d6 1
a6 1
  $Date: 2000/01/17 08:23:54 $
d559 1
a559 4
	if (push && vars->id == 0) {
	    rb_dvar_push(id, value);
	    return;
	}
a565 6

    vars = 0;
    if (ruby_dyna_vars && ruby_dyna_vars->id == 0) {
	vars = ruby_dyna_vars;
	ruby_dyna_vars = ruby_dyna_vars->next;
    }
a566 4
    if (vars) {
	vars->next = ruby_dyna_vars;
	ruby_dyna_vars = vars;
    }
@


1.10.2.10
log
@2000-02-08
@
text
@d6 1
a6 1
  $Date: 2000/01/24 03:46:06 $
d4656 1
a4656 1
	    rb_raise(rb_eSecurityError, "loading from unsafe path %s", path);
@


1.10.2.11
log
@2000-02-17
@
text
@d6 1
a6 1
  $Date: 2000/02/08 08:53:48 $
d3625 1
a3625 1
    id = NUM2INT(argv[0]);
d5739 1
a5739 1
    if (data->var == 0) return INT2FIX(-1);
d5936 1
a5936 1
	if (body->nd_rest >= 0) n = -n-1;
a6225 15
static int   th_raise_argc;
static VALUE th_raise_argv[2];
static char *th_raise_file;
static int   th_raise_line;
static VALUE th_cmd;
static int   th_sig;
static char *th_signm;

#define RESTORE_NORMAL		1
#define RESTORE_FATAL		2
#define RESTORE_INTERRUPT	3
#define RESTORE_TRAP		4
#define RESTORE_RAISE		5
#define RESTORE_SIGNAL		6

a6262 35
static int
thread_switch(n)
    int n;
{
    switch (n) {
      case 0:
	return 0;
      case RESTORE_FATAL:
	JUMP_TAG(TAG_FATAL);
	break;
      case RESTORE_INTERRUPT:
	rb_interrupt();
	break;
      case RESTORE_TRAP:
	rb_trap_eval(th_cmd, th_sig);
	errno = EINTR;
	break;
      case RESTORE_RAISE:
	ruby_frame->last_func = 0;
	ruby_sourcefile = th_raise_file;
	ruby_sourceline = th_raise_line;
	rb_f_raise(th_raise_argc, th_raise_argv);
	break;
      case RESTORE_SIGNAL:
	rb_raise(rb_eSignal, "SIG%s", th_signm);
	break;
      case RESTORE_NORMAL:
      default:
	return 1;
    }
}

#define THREAD_SAVE_CONTEXT(th) \
    (rb_thread_save_context(th),thread_switch(setjmp((th)->context)))

d6276 15
d6336 29
a6364 1
    longjmp(tmp->context, ex);
d6598 2
a6599 1
	if (THREAD_SAVE_CONTEXT(curr)) {
d7101 2
a7102 1
    if (THREAD_SAVE_CONTEXT(curr_thread)) {
d7108 2
a7109 1
	if (THREAD_SAVE_CONTEXT(th) == 0) {
d7263 2
a7264 1
    if (THREAD_SAVE_CONTEXT(curr_thread)) {
d7282 2
a7283 1
    if (THREAD_SAVE_CONTEXT(curr_thread)) {
d7303 2
a7304 1
    if (THREAD_SAVE_CONTEXT(curr_thread)) {
d7326 1
a7326 1
    if (!curr_thread->status != THREAD_KILLED)
d7328 1
a7328 1
    if (thread_switch(setjmp(curr_thread->context))) {
d7455 2
a7456 1
    if (THREAD_SAVE_CONTEXT(th)) {
d7564 1
a7564 1
    return rb_funcall(Qnil, rb_intern("catch"), 0, INT2FIX(tag));
d7617 1
a7617 1
    argv[0] = INT2FIX(t);
@


1.10.2.12
log
@2000-03-02
@
text
@d6 1
a6 1
  $Date: 2000/02/17 08:28:52 $
d6520 1
a6520 1
			    if (!next) next = th;
@


1.10.2.13
log
@2000-03-08
@
text
@d6 1
a6 1
  $Date: 2000/03/02 03:51:38 $
a4170 21
}

VALUE
rb_call_super(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE result;

    if (ruby_frame->last_class == 0) {	
	rb_raise(rb_eNameError, "superclass method `%s' must be enabled by rb_enable_super()",
		 rb_id2name(ruby_frame->last_func));
    }

    PUSH_ITER(ruby_iter->iter?ITER_PRE:ITER_NOT);
    result = rb_call(RCLASS(ruby_frame->last_class)->super,
		     ruby_frame->self, ruby_frame->last_func,
		     argc, argv, 3);
    POP_ITER();

    return result;
@


1.10.2.14
log
@2000-03-13
@
text
@d6 1
a6 1
  $Date: 2000/03/08 06:25:07 $
a3137 2
    ID exception;
    int n;
d3150 3
a3152 3
	n = 0;
	goto exception_call;

d3154 1
a3154 8
      case 3:
	n = 1;
      exception_call:
	exception = rb_intern("exception");
	if (!rb_respond_to(argv[0], exception)) {
	    rb_raise(rb_eTypeError, "exception class/object expected");
	}
	mesg = rb_funcall(argv[0], exception, n, argv[1]);
d3160 1
a3160 1
    if (argc > 0) {
a3619 1
    const char *mname;
d3623 3
a3625 3
    if (argc == 0 || (id = NUM2INT(argv[0]),  mname = rb_id2name(id)) == 0) {
	rb_raise(rb_eArgError, "no id given");
    }
d3653 2
d3673 1
a3673 1
    rb_raise(rb_eNameError, format, mname,
d5821 2
a5822 14
	if (orphan) {
	    state &= TAG_MASK;
	}
	else {
	    struct BLOCK *ptr = old_block;

	    while (ptr) {
		if (ptr->scope == _block.scope) {
		    ptr->tag->dst = state;
		    break;
		}
		ptr = ptr->prev;
	    }
	}
d5828 12
a5839 10
	switch (state) {
	  case TAG_BREAK:
	    rb_raise(rb_eLocalJumpError, "break from proc-closure");
	    break;
	  case TAG_RETRY:
	    rb_raise(rb_eLocalJumpError, "retry from proc-closure");
	    break;
	  case TAG_RETURN:
	    rb_raise(rb_eLocalJumpError, "return from proc-closure");
	    break;
@


1.10.2.15
log
@2000-03-23
@
text
@d6 1
a6 1
  $Date: 2000/03/13 09:15:36 $
d1739 1
a1739 4
	if (TYPE(klass) == T_ICLASS) {
	    klass = RBASIC(klass)->klass;
	}
	else if (FL_TEST(klass, FL_SINGLETON)) {
d3878 1
a3878 1
		call_trace_func("c-call", 0, 0, recv, id, klass);
d4472 1
a4472 3
    if (RNODE(ruby_frame->cbase)->nd_clss != under) {
	ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,under,0,ruby_frame->cbase);
    }
@


1.10.2.16
log
@2000-04-10
@
text
@d6 1
a6 1
  $Date: 2000/03/23 04:14:12 $
a395 1
	rb_funcall(klass, rb_intern("method_added"), 1, INT2FIX(id));
a400 1
	rb_funcall(klass, rb_intern("method_added"), 1, INT2FIX(id));
a5074 1
	rb_funcall(module, rb_intern("singleton_method_added"), 1, INT2FIX(id));
a6255 4
    if (th->status != THREAD_KILLED) {
	th->prev->next = th->next;
	th->next->prev = th->prev;
    }
d7608 1
a7608 1
    return rb_funcall(Qnil, rb_intern("catch"), 1, INT2FIX(tag));
@


1.10.2.17
log
@2000-05-01
@
text
@d6 1
a6 1
  $Date: 2000/04/10 05:48:28 $
d3329 8
a3336 12
    if (TYPE(val) != T_ARRAY) {
	val = rb_Array(val);
    }
    len = RARRAY(val)->len;
    for (i=0; list && i<len; i++) {
	assign(self, list->nd_head, RARRAY(val)->ptr[i], check);
	list = list->nd_next;
    }
    if (check && list) goto arg_error;
    if (node->nd_args) {
	if (node->nd_args == (NODE*)-1) {
	    /* ignore rest args */
d3338 11
a3348 5
	else if (!list && i<len) {
	    assign(self, node->nd_args, rb_ary_new4(len-i, RARRAY(val)->ptr+i), check);
	}
	else {
	    assign(self, node->nd_args, rb_ary_new2(0), check);
d3350 4
d3356 1
a6161 1
static thread_t main_thread;
a6162 1

d6182 2
a6649 1
    printf("<0x%x>\n", next);
d7378 1
a7378 1
    if (curr_thread->status != THREAD_KILLED)
@


1.10.2.18
log
@eval.c remove debug printf
@
text
@d6 1
a6 1
  $Date: 2000/05/01 09:42:22 $
d6643 1
@


1.10.2.19
log
@2000-05-09
@
text
@d6 1
a6 1
  $Date: 2000/05/08 03:21:21 $
a4880 2
		strcpy(ext, ".so");
		if (rb_provided(buf)) return Qfalse;
d6253 2
a6254 2
	if (th->prev) th->prev->next = th->next;
	if (th->next) th->next->prev = th->prev;
a7499 1
    th->prev = th->next = 0;
@


1.10.2.20
log
@2000-05-12
@
text
@d6 1
a6 1
  $Date: 2000/05/09 04:50:07 $
d4899 3
a4901 2
    if (find_file(buf)) {
	fname = rb_str_new2(buf);
@


1.10.2.21
log
@2000-05-30
@
text
@d6 1
a6 1
  $Date: 2000/05/12 09:06:06 $
a4690 3
    file = dln_find_file(file, path);
    if (file) {
	FILE *f = fopen(file, "r");
d4692 1
a4692 5
	if (f == NULL) return 0;
	fclose(f);
	return file;
    }
    return 0;
@


1.10.2.22
log
@2000-05-31
@
text
@d6 1
a6 1
  $Date: 2000/05/30 04:21:00 $
d4621 1
a4621 1
# if defined DOSISH
@


1.10.2.23
log
@2000-06-01
@
text
@d6 1
a6 1
  $Date: 2000/05/31 08:09:59 $
a6030 3
    if (NIL_P(args)) {
	return method_call(0, 0, method);
    }
@


1.10.2.24
log
@2000-06-20
@
text
@d6 1
a6 1
  $Date: 2000/05/31 16:40:59 $
d5984 1
a5984 2
	if (body->nd_opt || body->nd_rest >= 0)
	    n = -n-1;
d6117 1
a6117 1
typedef struct thread * rb_thread_t;
d6155 1
a6155 1
    rb_thread_t join;
d6166 2
a6167 2
static rb_thread_t main_thread;
static rb_thread_t curr_thread = 0;
d6193 1
a6193 1
    rb_thread_t th;
d6248 1
a6248 1
    rb_thread_t th;
d6258 1
a6258 1
    rb_thread_t th;
d6270 1
a6270 1
static rb_thread_t
d6278 1
a6278 1
    return (rb_thread_t)RDATA(data)->data;
d6298 1
a6298 1
    rb_thread_t th;
d6368 1
a6368 1
static void rb_thread_restore_context _((rb_thread_t,int));
d6372 1
a6372 1
    rb_thread_t th;
d6383 1
a6383 1
    rb_thread_t th;
d6387 1
a6387 1
    static rb_thread_t tmp;
d6431 1
a6431 1
    rb_thread_t th;
d6458 1
a6458 1
    rb_thread_t th;
d6467 1
a6467 1
    rb_thread_t th;
d6508 3
a6510 3
    rb_thread_t next;		/* OK */
    rb_thread_t th;
    rb_thread_t curr;
d6844 1
a6844 1
    rb_thread_t th = rb_thread_check(thread);
d6897 1
a6897 1
    rb_thread_t th = rb_thread_check(thread);
d6920 1
a6920 1
    rb_thread_t th = rb_thread_check(thread);
d7017 1
a7017 1
    rb_thread_t th = rb_thread_check(thread);
d7026 1
a7026 1
    rb_thread_t th = rb_thread_check(thread);
d7063 1
a7063 1
static rb_thread_t
d7067 1
a7067 1
    rb_thread_t th;
d7143 1
a7143 1
    rb_thread_t th = rb_thread_alloc(klass);
d7218 1
a7218 1
    rb_thread_t th;
d7238 1
a7238 1
    rb_thread_t th = rb_thread_check(thread);
d7249 1
a7249 1
    rb_thread_t th = rb_thread_check(thread);
d7264 1
a7264 1
    rb_thread_t th = rb_thread_check(thread);
d7283 1
a7283 1
    rb_thread_t th;
d7375 1
a7375 1
    rb_thread_t th = rb_thread_check(thread);
d7433 1
a7433 1
    rb_thread_t th;
d7457 1
a7457 1
    rb_thread_t th = rb_thread_check(thread);
d7485 1
a7485 1
    rb_thread_t th = rb_thread_check(thread);
d7500 1
a7500 1
    rb_thread_t th;
d7526 1
a7526 1
    rb_thread_t th = rb_thread_check(cont);
@


1.10.2.25
log
@2000-06-23
@
text
@d6 1
a6 1
  $Date: 2000/06/20 06:08:33 $
d4742 1
a4742 1
    ruby_frame->self = self;
@


1.10.2.26
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/06/23 07:05:49 $
a7161 3
    if (ruby_block) {
	blk_copy_prev(ruby_block);
    }
@


1.10.2.27
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/10 08:01:26 $
d2102 4
a2105 1
			if (state == TAG_RETRY) {
a2107 3
			}
			if (state != TAG_RAISE) {
			    ruby_errinfo = e_info;
@


1.10.2.28
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/14 04:33:18 $
a5395 3

    rb_undef_method(rb_cClass, "include");
    rb_undef_method(rb_cClass, "module_function");
@


1.10.2.29
log
@1.4.6 preview2
@
text
@d6 1
a6 1
  $Date: 2000/07/24 07:15:59 $
a4364 1
	DEFER_INTS;
a4369 1
	ALLOW_INTS;
a4761 1
	DEFER_INTS;
a4767 1
	ALLOW_INTS;
d5397 1
@


1.10.2.30
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/07/26 09:41:07 $
d7521 1
a7521 2
    th->prev = 0;
    th->next = curr_thread;
a7537 3
    if (th->next != curr_thread) {
	rb_raise(rb_eRuntimeError, "continuation called across threads");
    }
@


1.10.2.31
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/07 05:04:46 $
a431 1
    _frame.flags = FRAME_ALLOCA;	\
d5491 1
a5491 1
	if (frame->argc > 0 && (frame->flags & FRAME_MALLOC))
a5536 1
	    frame->flags = FRAME_MALLOC;
d7262 3
a7264 3
	if (!NIL_P(th->errinfo) && (th->flags & THREAD_RAISED))
	    return Qnil;
	return Qfalse;
@


1.10.2.32
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/15 08:57:42 $
d1559 1
a1559 4
	if (state) {
	    ruby_errinfo = Qnil;
	    return 0;
	}
d1629 1
a1629 4
	if (state) {
	    ruby_errinfo = Qnil;
	    return 0;
	}
a1666 1
	ruby_errinfo = Qnil;
@


1.10.2.33
log
@matz
@
text
@d6 1
a6 1
  $Date: 2000/08/24 06:49:07 $
a3355 3
    }
    else if (check && i < len) {
	goto arg_error;
@


1.9
log
@19991004
@
text
@d6 1
a6 1
  $Date: 1999/09/22 04:30:09 $
d2087 5
a2092 3
	    if (node->nd_else) { /* no exception raised, else clause given */
		result = rb_eval(self, node->nd_else);
	    }
@


1.8
log
@19990922
@
text
@d6 1
a6 1
  $Date: 1999/09/18 04:48:49 $
d1188 3
a1190 3
	if (status) {
	    JUMP_TAG(status);
	}
a6416 1

@


1.7
log
@990918-repack
@
text
@d6 1
a6 1
  $Date: 1999/09/16 16:11:24 $
d651 4
d1731 1
a1731 1
    POP_TAG();
d4495 1
a4495 1
    char *file = 0;
@


1.6
log
@990917
@
text
@d6 1
a6 1
  $Date: 1999/09/16 09:40:31 $
d3594 2
@


1.5
log
@1.4.1
@
text
@d6 1
a6 1
  $Date: 1999/09/01 09:48:00 $
a2183 1
	return_value(rb_eval(self, node->nd_stts));
@


1.4
log
@regexp literal (e.g. \202) match, etc.
@
text
@d6 1
a6 1
  $Date: 1999/08/24 08:21:52 $
d172 1
a172 1
	/* store in cache */
d1798 1
a1798 1
	/* nodes for speed-up(top-level loop for -n/-p) */
d1800 20
a1819 2
	while (!NIL_P(rb_gets())) {
	    rb_eval(self, node->nd_body);
d1821 2
d2394 2
a2395 4
	    if (RTEST(ruby_verbose)) {
		rb_warning("already initialized constant %s",
			   rb_id2name(node->nd_vid));
	    }
@


1.3
log
@1.4.1 to be
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:45:04 $
d171 9
a179 1
    if ((body = search_method(klass, id, &origin)) == 0) {
a181 1
    if (!body->nd_body) return 0;
d337 1
d340 8
d2159 4
a2162 1
	    return_value(rb_eval(self, node->nd_stts));
d2164 1
d3999 2
@


1.2
log
@1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/13 05:17:32 $
d5362 1
a5362 1
	    MEMCPY(tmp->frame.argv, block->frame.argv, VALUE, tmp->frame.argc);
d6019 2
a6020 2
#define ADJ(addr) (void*)(((VALUE*)(addr)-th->stk_pos)+th->stk_ptr)
#define STACK(addr) (th->stk_pos<(addr) && (addr)<th->stk_pos+th->stk_len)
d6044 1
d6058 1
a6058 1
	    struct FRAME *tmp = ADJ(frame->tmp);
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
  $Date: 1996/12/25 08:54:45 $
d9 1
a9 1
  Copyright (C) 1993-1997 Yukihiro Matsumoto
d16 1
a16 1
#include "sig.h"
d23 20
a42 4
#ifdef HAVE_STRING_H
# include <string.h>
#else
char *strrchr();
d52 35
a86 8
extern VALUE cData;
VALUE cProc;
static VALUE proc_call();
static VALUE f_binding();

#define CACHE_SIZE 0x200
#define CACHE_MASK 0x1ff
#define EXPR1(c,m) ((((int)(c)>>3)^(m))&CACHE_MASK)
d91 2
a92 2
    struct RClass *class;	/* receiver's class */
    struct RClass *origin;	/* where method defined  */
d111 15
d127 2
a128 2
rb_add_method(class, mid, node, noex)
    struct RClass *class;
d135 4
a138 1
    if (NIL_P(class)) class = (struct RClass*)cObject;
d140 1
a140 1
    st_insert(class->m_tbl, mid, body);
d144 2
a145 2
search_method(class, id, origin)
    struct RClass *class, **origin;
d150 3
a152 3
    while (!st_lookup(class->m_tbl, id, &body)) {
	class = class->super;
	if (!class) return 0;
d155 1
a155 1
    if (origin) *origin = class;
d160 2
a161 2
rb_get_method_body(classp, idp, noexp)
    struct RClass **classp;
d166 3
a168 3
    struct RClass *class = *classp;
    NODE *body;
    struct RClass *origin;
d171 1
a171 1
    if ((body = search_method(class, id, &origin)) == 0) {
d177 2
a178 2
    ent = cache + EXPR1(class, id);
    ent->class  = class;
d183 2
a184 1
	*classp = ent->origin = (struct RClass*)body->nd_orig;
d189 2
a190 1
	*classp = ent->origin = origin;
d200 2
a201 2
rb_alias(class, name, def)
    struct RClass *class;
d204 1
a204 1
    struct RClass *origin;
d208 4
a211 1
    orig = search_method(class, def, &origin);
d213 2
a214 2
	if (TYPE(class) == T_MODULE) {
	    orig = search_method(cObject, def, &origin);
d218 1
a218 2
	NameError("undefined method `%s' for `%s'",
		  rb_id2name(def), rb_class2name((VALUE)class));
d222 2
a224 2
	def = body->nd_mid;
	origin = (struct RClass*)body->nd_orig;
d227 1
a227 1
    st_insert(class->m_tbl, name,
d232 65
a296 2
rb_export_method(class, name, noex)
    struct RClass *class;
d298 1
a298 1
    int noex;
d301 1
a301 1
    struct RClass *origin;
d303 6
a308 3
    body = search_method(class, name, &origin);
    if (!body && TYPE(class) == T_MODULE) {
	body = search_method(cObject, name, &origin);
d311 1
a311 2
	NameError("undefined method `%s' for `%s'",
		  rb_id2name(name), rb_class2name((VALUE)class));
d314 1
a314 1
	if (class == origin) {
d318 2
a319 2
	    rb_clear_cache();
	    rb_add_method(class, name, NEW_ZSUPER(), noex);
d324 3
a326 3
static VALUE
method_boundp(class, id, ex)
    struct RClass *class;
d332 4
a335 4
    if (rb_get_method_body(&class, &id, &noex)) {
	if (ex && noex == NOEX_PRIVATE)
	    return FALSE;
	return TRUE;
d337 1
a337 1
    return FALSE;
d340 3
a342 3
int
rb_method_boundp(class, id, priv)
    VALUE class;
d344 1
a344 1
    int priv;
d346 41
a386 22
    if (method_boundp(class, id, priv?NOEX_PRIVATE:NOEX_PUBLIC))
	return TRUE;
    return FALSE;
}

static ID init, eqq, each, aref, aset;
VALUE errinfo = Qnil, errat = Qnil;
extern NODE *eval_tree;
extern int nerrs;

extern VALUE mKernel;
extern VALUE cModule;
extern VALUE cClass;
extern VALUE eFatal;
extern VALUE eGlobalExit;
extern VALUE eInterrupt;
extern VALUE eSystemExit;
extern VALUE eException;
extern VALUE eRuntimeError;
extern VALUE eSyntaxError;
static VALUE eLocalJumpError;
extern VALUE eSecurityError;
d388 2
a389 1
extern VALUE TopSelf;
d391 4
a394 2
struct FRAME *the_frame;
struct SCOPE *the_scope;
d400 14
a413 8
    _frame.prev = the_frame;		\
    _frame.file = sourcefile;		\
    _frame.line = sourceline;		\
    _frame.iter = the_iter->iter;	\
    _frame.cbase = the_frame->cbase;	\
    the_frame = &_frame;		\

#define POP_FRAME()  the_frame = _frame.prev; }
d421 2
a422 2
    struct RClass *class;
    int level;
d424 2
a426 1
#ifdef THREAD
a427 1
#endif
d429 6
a434 1
} *the_block;
d438 1
a438 1
    _block.level = (int)prot_tag;	\
d442 15
a456 9
    _block.frame = *the_frame;		\
    _block.class = the_class;		\
    _block.frame.file = sourcefile;	\
    _block.frame.line = sourceline;	\
    _block.scope = the_scope;		\
    _block.d_vars = the_dyna_vars;	\
    _block.prev = the_block;		\
    _block.iter = the_iter->iter;	\
    the_block = &_block;		\
d459 3
a461 4
    struct BLOCK _block;		\
    _block = *b;			\
    _block.prev = the_block;		\
    the_block = &_block;
d463 2
a464 2
#define POP_BLOCK() 			\
   the_block = the_block->prev; 	\
d467 1
a467 1
struct RVarmap *the_dyna_vars;
d469 3
a471 3
    struct RVarmap *_old;		\
    _old = the_dyna_vars;		\
    the_dyna_vars = 0;
d474 16
a489 1
    the_dyna_vars = _old;		\
d493 1
a493 1
dyna_var_defined(id)
d496 1
a496 1
    struct RVarmap *vars = the_dyna_vars;
d499 1
a499 1
	if (vars->id == id) return TRUE;
d502 1
a502 1
    return FALSE;
d506 1
a506 1
dyna_var_ref(id)
d509 1
a509 1
    struct RVarmap *vars = the_dyna_vars;
d520 10
a529 2
VALUE
dyna_var_asgn(id, value)
d532 1
d534 1
a534 1
    struct RVarmap *vars = the_dyna_vars;
d537 1
d540 1
a540 1
	    return value;
d544 26
a569 7
    {
	NEWOBJ(_vars, struct RVarmap);
	OBJSETUP(_vars, 0, T_VARMAP);
	_vars->id = id;
	_vars->val = value;
	_vars->next = the_dyna_vars;
	the_dyna_vars = _vars;
a570 1
    return value;
d573 1
a573 1
static struct iter {
d576 2
a577 1
} *the_iter;
d585 1
a585 1
    _iter.prev = the_iter;		\
d587 1
a587 1
    the_iter = &_iter;			\
d590 1
a590 1
    the_iter = _iter.prev;		\
d593 1
a593 1
static struct tag {
d597 4
d602 2
a603 1
} *prot_tag;
d605 1
a605 1
#define PUSH_TAG() {			\
d607 3
a609 2
    _tag.frame = the_frame;		\
    _tag.iter = the_iter;		\
d611 4
d617 5
a621 1
#define EXEC_TAG()    ((NODE*)setjmp(prot_tag->buf))
d624 3
a626 3
    the_frame = prot_tag->frame;	\
    the_iter = prot_tag->iter;		\
    longjmp(prot_tag->buf,(int)(st));	\
a628 5
#define JUMP_TAG3(val,data1,data2) \
    JUMP_TAG(node_newnode(NODE_TAG,(val),(data1),(data2)))

#define JUMP_TAG2(val,data) JUMP_TAG3((val),(data),0)

d630 2
d643 1
d645 2
a646 3
#define IN_BLOCK       0x10

struct RClass *the_class;
d649 1
a649 1
    struct RClass *_class = the_class;	\
d651 1
a651 1
#define POP_CLASS() the_class = _class; }
d654 2
a655 1
    struct SCOPE *_old;			\
d661 28
a688 23
    _old = the_scope;			\
    the_scope = _scope;			\

#define POP_SCOPE() \
    if (the_scope->flag == SCOPE_ALLOCA) {\
	the_scope->local_vars = 0;\
	the_scope->local_tbl  = 0;\
	if (the_scope != top_scope)\
            gc_force_recycle(the_scope);\
    }\
    else {\
        the_scope->flag |= SCOPE_NOSTACK;\
    }\
    the_scope = _old;\
}

static VALUE rb_eval();
static VALUE eval();
static NODE *compile();

static VALUE rb_call();
VALUE rb_apply();
VALUE rb_funcall2();
d690 2
a691 1
static VALUE module_setup();
d693 2
a694 2
static VALUE massign();
static void assign();
d700 1
a700 1
   2 - some process operations prohibited
d702 1
a702 2
   4 - no global variable value modification/no direct output
   5 - no instance variable value modification
d733 2
a734 2
	Raise(eSecurityError, "tried to downgrade safe level from %d to %d",
	      safe_level, level);
d744 2
a745 2
	TypeError("wrong argument type %s (expected String)",
		  rb_class2name(CLASS_OF(x)));
d747 5
a751 3
    if (rb_safe_level() > 0 && str_tainted(x)) {
	Raise(eSecurityError, "Insecure operation - %s",
	      rb_id2name(the_frame->last_func));
d760 2
a761 2
	Raise(eSecurityError, "Insecure operation `%s' for level %d",
	      rb_id2name(the_frame->last_func), level);
a764 3
extern int   sourceline;
extern char *sourcefile;

d766 1
a766 1
static void call_trace_func();
d771 4
a774 4
    if (sourcefile) {
	if (the_frame->last_func) {
	    fprintf(stderr, "%s:%d:in `%s'", sourcefile, sourceline,
		    rb_id2name(the_frame->last_func));
d777 1
a777 1
	    fprintf(stderr, "%s:%d", sourcefile, sourceline);
d782 15
d800 1
d802 2
d805 1
a805 1
    if (NIL_P(errinfo)) return;
d807 8
d816 1
a816 1
	VALUE mesg = Qnil;
a817 9
	switch (TYPE(errat)) {
	  case T_STRING:
	    mesg = errat;
	    errat = Qnil;
	    break;
	  case T_ARRAY:
	    mesg = RARRAY(errat)->ptr[0];
	    break;
	}
d824 11
a834 2
    eclass = CLASS_OF(errinfo);
    if (eclass == eRuntimeError && RSTRING(errinfo)->len == 0) {
d838 7
a844 7
	PUSH_TAG();
	if (EXEC_TAG() == 0) {
	    VALUE epath = rb_class_path(eclass);
	    if (RSTRING(epath)->ptr[0] != '#') {
		fprintf(stderr, ": ");
		fwrite(RSTRING(epath)->ptr, 1, RSTRING(epath)->len, stderr);
	    }
d846 3
a848 1
	POP_TAG();
d850 5
a854 1
	if (RSTRING(errinfo)->len > 0) {
d856 10
a865 4
	    fwrite(RSTRING(errinfo)->ptr, 1, RSTRING(errinfo)->len, stderr);
	}
	if (RSTRING(errinfo)->ptr[RSTRING(errinfo)->len - 1] != '\n') {
	    putc('\n', stderr);
d877 1
d879 3
a881 1
	    fprintf(stderr, "\tfrom %s\n", RSTRING(ep->ptr[i])->ptr);
d883 1
a883 1
		fprintf(stderr, "\t ... %d levels...\n",
d891 1
a891 1
#ifndef NT
d894 6
a899 1
char **origenviron;
d904 1
d907 5
a911 1
    NODE *state;
d913 2
a914 2
    the_frame = top_frame = &frame;
    the_iter = &iter;
d916 5
a920 1
    origenviron = environ;
d922 2
a923 1
    init_heap();
d925 5
a929 3
    the_scope->local_vars = 0;
    the_scope->local_tbl  = 0;
    top_scope = the_scope;
d931 1
a931 1
    PUSH_TAG()
d934 7
a940 3
	the_class = (struct RClass*)cObject;
	the_frame->cbase = (VALUE)node_newnode(NODE_CREF,cObject,0,0);
	rb_define_global_const("TOPLEVEL_BINDING", f_binding(TopSelf));
d946 1
a946 1
    the_scope = top_scope;
d956 1
a956 1
    NODE *state;
d958 1
a958 1
    PUSH_TAG()
a959 4
	NODE *save;

	Init_ext();
	ext_init = 1;
d961 1
a961 3
	save = eval_tree;
	rb_require_modules();
	eval_tree = save;
d965 1
d975 1
a975 2
    VALUE result = Qnil;
    NODE *tree;
d977 6
a982 1
    if (!eval_tree) return Qnil;
d984 2
a985 2
    tree = eval_tree;
    eval_tree = 0;
d987 1
a987 2
    result = rb_eval(self, tree);
    return result;
d990 1
a990 1
int rb_in_eval;
d992 2
a993 5
#ifdef THREAD
static void thread_cleanup();
static void thread_wait_other_threads();
static VALUE thread_current();
#endif
d997 12
d1012 3
a1014 4
    NODE *state;
    static NODE *ex;

    if (nerrs > 0) exit(nerrs);
d1016 1
a1016 2
    init_stack();
    errat = Qnil;		/* clear for execution */
d1018 2
a1019 1
    PUSH_TAG();
d1022 2
a1023 2
	if (!ext_init) Init_ext();
	eval_node(TopSelf);
d1029 1
a1029 1
    PUSH_TAG();
d1033 2
a1034 4
#ifdef THREAD
	thread_cleanup();
	thread_wait_other_threads();
#endif
d1042 4
a1045 3
    if (!ex) {
	exit(0);
    }
a1046 2
    switch (ex->nd_tag) {
      case IN_BLOCK|TAG_RETURN:
d1049 2
a1050 2
	fprintf(stderr, "unexpected return\n");
	exit(1);
d1054 2
a1055 2
	fprintf(stderr, "unexpected next\n");
	exit(1);
a1056 1
      case IN_BLOCK|TAG_BREAK:
d1059 2
a1060 2
	fprintf(stderr, "unexpected break\n");
	exit(1);
d1064 2
a1065 2
	fprintf(stderr, "unexpected redo\n");
	exit(1);
d1069 2
a1070 2
	fprintf(stderr, "retry outside of rescue clause\n");
	exit(1);
d1074 6
a1079 2
	if (obj_is_kind_of(errinfo, eSystemExit)) {
	    exit(exit_status);
a1080 7
	error_print();
	exit(1);
	break;
      case TAG_THROW:
	error_pos();
	fprintf(stderr, "uncaught throw `%s'\n", rb_id2name(ex->nd_tlev));
	exit(1);
d1083 1
a1083 1
	Bug("Unknown longjmp status %d", ex->nd_tag);
d1086 3
d1093 1
a1093 1
    char *at;
d1095 3
a1097 1
    VALUE mesg;
d1099 10
a1108 7
    mesg = errinfo;
    nerrs = 0;
    errinfo = exc_new2(eSyntaxError, "compile error in ");
    str_cat(errinfo, at, strlen(at));
    str_cat(errinfo, ":\n", 2);
    str_cat(errinfo, RSTRING(mesg)->ptr, RSTRING(mesg)->len);
    rb_raise(errinfo);
d1113 1
a1113 1
    char *str;
d1116 1
a1116 1
    char *oldsrc = sourcefile;
d1118 3
a1120 3
    sourcefile = "(eval)";
    v = eval(TopSelf, str_new2(str), Qnil);
    sourcefile = oldsrc;
d1125 51
a1175 1
void
d1179 2
a1180 1
    NODE *state;
d1182 1
a1182 1
    volatile int safe = rb_safe_level();
d1185 2
a1186 4
	if (obj_is_kind_of(cmd, cProc)) {
	    proc_call(cmd, arg);
	    return;
	}
d1190 7
a1196 7
    PUSH_TAG();
    saved_scope = the_scope;
    the_scope = top_scope;

    the_class = (struct RClass*)cObject;
    if (str_tainted(cmd)) {
	safe_level = 5;
d1200 1
a1200 1
	eval(TopSelf, cmd, Qnil);
d1203 3
a1205 1
    the_scope = saved_scope;
d1210 3
a1212 2
    if (state == 0) return;
    switch (state->nd_tag) {
d1214 1
a1214 1
	Raise(eLocalJumpError, "unexpected return");
d1217 1
a1217 1
	Raise(eLocalJumpError, "unexpected next");
d1220 1
a1220 1
	Raise(eLocalJumpError, "unexpected break");
d1223 1
a1223 1
	Raise(eLocalJumpError, "unexpected redo");
d1226 1
a1226 1
	Raise(eLocalJumpError, "retry outside of rescue clause");
d1232 1
d1235 1
a1235 1
void
d1240 2
a1241 1
    NODE *state;
d1243 1
a1243 1
    PUSH_TAG();
d1245 1
a1245 1
	rb_eval_cmd(cmd, ary_new3(1, INT2FIX(sig)));
d1249 1
a1249 1
	trap_immediate = 0;
d1252 1
d1260 2
a1261 2
    VALUE val = 0;
    NODE *state;
d1263 1
a1263 1
    PUSH_TAG();
d1269 11
a1279 11
	if (state->nd_tag == TAG_RAISE) {
	  superclass_error:
	    switch (nd_type(node)) {
	      case NODE_COLON2:
		TypeError("undefined superclass `%s'", rb_id2name(node->nd_mid));
	      case NODE_CVAR:
		TypeError("undefined superclass `%s'", rb_id2name(node->nd_vid));
	      default:
		TypeError("superclass undefined");
	    }
	}
d1284 1
a1284 1
	TypeError("can't make subclass of virtual class");
d1297 2
a1298 2
    while (cbase && cbase->nd_clss != cObject) {
	struct RClass *class = RCLASS(cbase->nd_clss);
d1300 3
a1302 3
	if (class->iv_tbl &&
	    st_lookup(class->iv_tbl, id, 0)) {
	    return TRUE;
d1317 2
a1318 2
    while (cbase && cbase->nd_clss != cObject) {
	struct RClass *class = RCLASS(cbase->nd_clss);
d1320 2
a1321 2
	if (class->iv_tbl &&
	    st_lookup(class->iv_tbl, id, &result)) {
d1329 69
d1407 2
a1409 1
	    int line = sourceline;\
d1411 1
a1411 1
	    argv = ALLOCA_N(VALUE,argc);\
d1416 2
a1417 2
	    sourcefile = anode->file;\
	    sourceline = line;\
d1426 2
a1427 1
	int line = sourceline;\
d1429 1
a1429 1
	    args = rb_to_a(args);\
d1433 2
a1434 2
	sourcefile = anode->file;\
	sourceline = line;\
d1438 10
a1447 5
int
rb_test_false_or_nil(v)
    VALUE v;
{
    return (v != Qnil) && (v != FALSE);
d1450 13
a1462 1
#define MATCH_DATA the_scope->local_vars[node->nd_cnt]
d1464 17
d1488 1
a1488 3
    NODE *state;

    node = node->nd_head;
d1493 6
a1498 3
	if (the_frame->last_func == 0) return 0;
	else if (method_boundp(the_frame->last_class->super,
			       the_frame->last_func, 1)) {
d1503 1
a1504 1
      case NODE_VCALL:
d1509 2
a1510 1
	PUSH_TAG();
d1516 1
a1516 3
	if (state) {
	    return 0;
	}
d1518 2
a1519 3
	if (method_boundp(val, node->nd_mid,
			  nd_type(node)== NODE_CALL)) {
	    return "method";
d1523 4
d1528 1
a1528 1
	if (iterator_p()) {
d1539 6
d1551 1
d1558 1
d1560 1
a1560 1
	return "local-variable";
d1575 1
a1575 1
	if (ev_const_defined(the_frame->cbase, node->nd_vid)) {
d1581 1
a1581 1
	PUSH_TAG();
d1586 1
a1586 3
	if (state) {
	    return 0;
	}
d1593 4
d1602 1
a1602 1
	if (reg_nth_defined(node->nd_nth, MATCH_DATA)) {
d1609 1
a1609 1
	if (reg_nth_defined(0, MATCH_DATA)) {
d1616 1
a1616 1
	PUSH_TAG();
d1629 1
a1629 2
static int handle_rescue();
VALUE rb_yield_0();
d1634 20
d1655 1
a1655 2
    VALUE obj;
    struct RData *trace;
d1661 2
a1662 2
    if (TYPE(trace) != T_DATA || trace->dfree != blk_free) {
	TypeError("trace_func needs to be Proc");
d1664 1
a1664 1
    return trace_func = (VALUE)trace;
d1668 1
a1668 1
call_trace_func(event, file, line, self, id)
d1674 1
d1676 1
a1676 1
    NODE *state;
d1679 2
d1686 1
a1686 3
#ifdef THREAD
    thread_critical++;
#endif
d1688 1
a1688 1
    prev = the_frame;
d1690 2
a1691 2
    *the_frame = *_frame.prev;
    the_frame->prev = prev;
d1693 10
a1702 3
    the_frame->line = sourceline = line;
    the_frame->file = sourcefile = file;
    PUSH_TAG();
d1704 6
a1709 5
	proc_call(trace, ary_new3(5, str_new2(event),
				  str_new2(sourcefile),
				  INT2FIX(sourceline),
				  INT2FIX(id),
				  self?f_binding(self):Qnil));
d1714 1
a1714 3
#ifdef THREAD
    thread_critical--;
#endif
d1716 2
d1721 3
d1729 1
a1729 1
    NODE *state;
a1736 4
#if 0
    sourceline = nd_line(node);
    sourcefile = node->file;
#endif
d1739 2
a1740 2
	while (node) {
	    result = rb_eval(self, node->nd_head);
d1743 7
d1759 21
a1779 1
	result = reg_match2(node->nd_head->nd_lit);
d1784 1
a1784 1
	while (!NIL_P(f_gets())) {
d1795 6
d1802 1
d1826 18
a1843 2
			call_trace_func("line", tag->file, nd_line(tag),
					self, the_frame->last_func);	
d1845 1
a1845 1
		    if (RTEST(rb_funcall2(rb_eval(self, tag->nd_head),eqq,1,&val))){
d1857 4
a1860 2
	PUSH_TAG();
	if ((state = EXEC_TAG()) == 0) {
d1869 12
a1880 14
	}
	else {
	    switch  (state->nd_tag) {
	      case TAG_REDO:
		state = 0;
		goto while_redo;
	      case TAG_NEXT:
		state = 0;
		goto while_next;
	      case TAG_BREAK:
		state = 0;
	      default:
		break;
	    }
d1884 1
a1884 3
	if (state) {
	    JUMP_TAG(state);
	}
d1888 3
a1890 2
	PUSH_TAG();
	if ((state = EXEC_TAG()) == 0) {
d1899 12
a1910 14
	}
	else {
	    switch  (state->nd_tag) {
	      case TAG_REDO:
		state = 0;
		goto until_redo;
	      case TAG_NEXT:
		state = 0;
		goto until_next;
	      case TAG_BREAK:
		state = 0;
	      default:
		break;
	    }
d1914 1
a1914 3
	if (state) {
	    JUMP_TAG(state);
	}
d1917 4
a1923 2
	    int tag_level;

d1926 1
a1926 1
	    PUSH_TAG();
d1937 2
a1938 1
		    int line = sourceline;
d1940 1
d1943 2
a1944 2
		    sourcefile = node->file;
		    sourceline = line;
d1949 6
a1955 1
	    tag_level = the_block->level;
d1957 4
a1960 2
	    if (state == 0) break;
	    switch (state->nd_tag) {
d1964 1
a1964 4
	      case IN_BLOCK|TAG_BREAK:
		if (state->nd_tlev != tag_level) {
		    JUMP_TAG(state);
		}
d1967 2
a1968 4
	      case IN_BLOCK|TAG_RETURN:
		if (state->nd_tlev == tag_level) {
		    state->nd_tag &= ~IN_BLOCK;
		}
d1976 23
d2000 12
a2011 1
	result = rb_yield_0(rb_eval(self, node->nd_stts), 0);
d2017 1
a2017 1
	    volatile VALUE e_info = errinfo, e_at = errat;
d2019 1
a2019 1
	    PUSH_TAG();
d2024 15
a2038 5
	    if (state) {
		if (state->nd_tag == TAG_RAISE) {
		    NODE * volatile resq = node->nd_resq;
		    while (resq) {
			if (handle_rescue(self, resq)) {
d2040 1
a2040 14
			    PUSH_TAG();
			    if ((state = EXEC_TAG()) == 0) {
				result = rb_eval(self, resq->nd_body);
			    }
			    POP_TAG();
			    if (state == 0) {
				errinfo = e_info;
				errat = e_at;
			    }
			    else if (state->nd_tag == TAG_RETRY) {
				state = 0;
				goto retry_entry;
			    }
			    break;
d2042 1
a2042 1
			resq = resq->nd_head; /* next rescue */
d2044 1
d2046 4
a2049 3
		if (state) {
		    JUMP_TAG(state);
		}
d2055 1
a2055 1
	PUSH_TAG();
d2060 5
a2064 3
	rb_eval(self, node->nd_ensr);
	if (state) {
	    JUMP_TAG(state);
d2066 1
d2082 2
a2083 2
	if (RTEST(rb_eval(self, node->nd_body))) result = FALSE;
	else result = TRUE;
d2088 14
a2101 1
	RETURN(range_new(rb_eval(self, node->nd_beg), rb_eval(self, node->nd_end)));
d2104 4
a2107 1
	if (node->nd_state == 0) {
d2109 3
a2111 2
		node->nd_state = rb_eval(self, node->nd_end)?0:1;
		result = TRUE;
d2114 1
a2114 1
		result = FALSE;
d2119 1
a2119 1
		node->nd_state = 0;
d2121 1
a2121 1
	    result = TRUE;
d2126 6
a2131 6
	if (node->nd_state == 0) {
	    if (RTEST(rb_eval(self, node->nd_beg))) {
		node->nd_state = 1;
		result = TRUE;
	    }
	    result = FALSE;
d2135 1
a2135 1
		node->nd_state = 0;
d2137 1
a2137 1
	    result = TRUE;
d2142 10
a2151 1
	JUMP_TAG2(TAG_RETURN,(node->nd_stts)?rb_eval(self, node->nd_stts):Qnil);
d2158 1
d2160 1
a2160 1
	    PUSH_ITER(ITER_NOT);
d2163 2
a2164 1
	    POP_ITER();
d2172 1
d2174 1
a2174 1
	    PUSH_ITER(ITER_NOT);
d2176 2
a2177 1
	    POP_ITER();
d2190 1
d2192 4
d2197 2
a2198 2
		argc = the_frame->argc;
		argv = the_frame->argv;
d2201 1
a2201 1
		PUSH_ITER(ITER_NOT);
d2203 1
a2203 1
		POP_ITER();
d2206 4
a2209 3
	    PUSH_ITER(the_iter->iter?ITER_PRE:ITER_NOT);
	    result = rb_call(the_frame->last_class->super, self,
			     the_frame->last_func, argc, argv, 1);
d2216 5
a2220 1
	    VALUE save = the_frame->cbase;
d2223 2
a2224 2
	    PUSH_TAG();
	    if (node->nd_rval) the_frame->cbase = (VALUE)node->nd_rval;
d2228 3
a2230 3
		the_scope->local_vars = vars;
		memclear(the_scope->local_vars, node->nd_tbl[0]);
		the_scope->local_tbl = node->nd_tbl;
d2233 2
a2234 2
		the_scope->local_vars = 0;
		the_scope->local_tbl  = 0;
d2237 1
a2237 1
		result = rb_eval(self, node->nd_body);
d2241 1
a2241 1
	    the_frame->cbase = save;
d2251 1
d2257 12
a2268 1
	    val = rb_funcall(val, node->nd_mid, 1, rb_eval(self, rval));
d2282 13
d2296 11
a2306 2
	    val = rb_funcall(val, node->nd_next->nd_mid, 1,
			     rb_eval(self, node->nd_value));
d2308 4
a2311 2
	    rb_funcall2(recv, id_attrset(id), 1, &val);
	    result = val;
d2316 1
a2316 1
	result = massign(self, node, rb_eval(self, node->nd_value));
d2320 4
a2323 4
	if (the_scope->local_vars == 0)
	    Bug("unexpected local variable assignment");
	the_scope->local_vars[node->nd_cnt] = rb_eval(self, node->nd_value);
	result = the_scope->local_vars[node->nd_cnt];
d2327 7
a2333 1
	result = dyna_var_asgn(node->nd_vid, rb_eval(self, node->nd_value));
d2337 2
a2338 7
	{
	    VALUE val;

	    val = rb_eval(self, node->nd_value);
	    rb_gvar_set(node->nd_entry, val);
	    result = val;
	}
d2342 2
a2343 7
	{
	    VALUE val;

	    val = rb_eval(self, node->nd_value);
	    rb_ivar_set(self, node->nd_vid, val);
	    result = val;
	}
d2347 10
a2356 8
	{
	    VALUE val;

	    val = rb_eval(self, node->nd_value);
	    /* check for static scope constants */
	    if (verbose && ev_const_defined(the_frame->cbase, node->nd_vid)) {
		Warning("already initialized constant %s",
			rb_id2name(node->nd_vid));
a2357 2
	    rb_const_set(the_class, node->nd_vid, val);
	    result = val;
d2359 1
d2363 2
a2364 2
	if (the_scope->local_vars == 0) {
	    Bug("unexpected local variable");
d2366 1
a2366 1
	result = the_scope->local_vars[node->nd_cnt];
d2370 1
a2370 1
	result = dyna_var_ref(node->nd_vid);
d2382 13
a2394 1
	result = ev_const_get(the_frame->cbase, node->nd_vid);
d2399 1
a2399 1
	    VALUE cls;
d2401 2
a2402 2
	    cls = rb_eval(self, node->nd_head);
	    switch (TYPE(cls)) {
d2407 1
a2407 2
		Check_Type(cls, T_CLASS);
		break;
d2409 1
a2409 1
	    result = rb_const_get_at(cls, node->nd_mid);
d2413 6
a2418 2
      case NODE_NTH_REF:
	result = reg_nth_match(node->nd_nth, MATCH_DATA);
d2424 1
a2424 1
	    result = reg_last_match(MATCH_DATA);
d2427 1
a2427 1
	    result = reg_match_pre(MATCH_DATA);
d2430 1
a2430 1
	    result = reg_match_post(MATCH_DATA);
d2433 1
a2433 1
	    result = reg_match_last(MATCH_DATA);
d2436 1
a2436 1
	    Bug("unexpected back-ref");
d2443 1
a2443 1
	    VALUE hash = hash_new();
d2451 1
a2451 1
		    Bug("odd number list for Hash");
d2454 1
a2454 1
		hash_aset(hash, key, val);
d2461 1
a2461 1
	result = ary_new();
d2470 1
a2470 1
	    ary = ary_new2(i);
d2481 1
a2481 1
	result = str_new3(node->nd_lit);
d2492 1
a2492 1
	    str = str_new3(node->nd_lit);
d2494 15
a2508 10
		if (nd_type(list->nd_head) == NODE_STR) {
		    str2 = list->nd_head->nd_lit;
		}
		else {
		    if (nd_type(list->nd_head) == NODE_EVSTR) {
			rb_in_eval++;
			list->nd_head = compile(list->nd_head->nd_lit);
			rb_in_eval--;
			if (nerrs > 0) {
			    compile_error("string expand");
d2510 5
d2516 2
a2517 5
		    str2 = rb_eval(self, list->nd_head);
		    str2 = obj_as_string(str2);
		}
		if (str2) {
		    str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d2523 1
a2523 1
		result = reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
d2527 1
a2527 1
		result = reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
d2551 4
a2554 3
	if (the_frame->argc != 1)
	    ArgError("Wrong # of arguments(%d for 1)", the_frame->argc);
	result = rb_ivar_set(self, node->nd_vid, the_frame->argv[0]);
d2563 7
a2569 1
	    body = search_method(the_class, node->nd_mid, &origin);
d2571 7
a2577 2
		if (origin == (VALUE)the_class) {
		    Warning("redefine %s", rb_id2name(node->nd_mid));
d2579 1
a2579 1
		rb_clear_cache();
d2582 28
a2609 4
	    if (body) noex = body->nd_noex;
	    else      noex = node->nd_noex; /* default(1 for toplevel) */

	    rb_add_method(the_class, node->nd_mid, node->nd_defn, noex);
d2617 2
a2618 2
	    VALUE class;
	    NODE *body;
a2619 8
	    if (FIXNUM_P(recv)) {
		TypeError("Can't define method \"%s\" for Fixnum",
			  rb_id2name(node->nd_mid));
	    }
	    if (NIL_P(recv)) {
		TypeError("Can't define method \"%s\" for nil",
			  rb_id2name(node->nd_mid));
	    }
d2621 4
a2624 2
		TypeError("Can't define method \"%s\" for special constants",
			  rb_id2name(node->nd_mid));
d2627 11
a2637 3
	    class = rb_singleton_class(recv);
	    if (st_lookup(RCLASS(class)->m_tbl, node->nd_mid, &body)) {
		Warning("redefine %s", rb_id2name(node->nd_mid));
d2639 3
a2641 1
	    rb_clear_cache();
a2643 1
	    rb_add_method(class, node->nd_mid, node->nd_defn, NOEX_PUBLIC);
d2650 1
a2650 1
	    struct RClass *origin;
d2653 7
a2659 1
	    body = search_method(the_class, node->nd_mid, &origin);
d2661 17
a2677 2
		NameError("undefined method `%s' for class `%s'",
			  rb_id2name(node->nd_mid), rb_class2name((VALUE)the_class));
d2679 2
a2680 2
	    rb_clear_cache();
	    rb_add_method(the_class, node->nd_mid, 0, NOEX_PUBLIC);
d2686 6
a2691 1
	rb_alias(the_class, node->nd_new, node->nd_old);
d2702 1
a2702 2
	    VALUE super, class;
	    struct RClass *tmp;
d2704 3
d2714 12
a2725 7
	    if (rb_const_defined_at(the_class, node->nd_cname) &&
		((VALUE)the_class != cObject ||
		 !rb_autoload_defined(node->nd_cname))) {

		class = rb_const_get_at(the_class, node->nd_cname);
		if (TYPE(class) != T_CLASS) {
		    TypeError("%s is not a class", rb_id2name(node->nd_cname));
d2728 1
a2728 1
		    tmp = RCLASS(class)->super;
d2735 3
a2737 3
		    if (tmp != RCLASS(super)) {
			TypeError("superclass mismatch for %s",
				  rb_id2name(node->nd_cname));
d2741 1
a2741 1
		    Raise(eSecurityError, "extending class prohibited");
a2743 1
		Warning("extending class %s", rb_id2name(node->nd_cname));
d2746 8
a2753 4
		if (!super) super = cObject;
		class = rb_define_class_id(node->nd_cname, super);
		rb_const_set(the_class, node->nd_cname, class);
		rb_set_class_path(class,the_class,rb_id2name(node->nd_cname));
d2756 1
a2756 1
	    result = module_setup(class, node->nd_body);
d2764 6
a2769 2
	    if (rb_const_defined_at(the_class, node->nd_cname) &&
		((VALUE)the_class != cObject ||
d2771 6
a2776 2

		module = rb_const_get_at(the_class, node->nd_cname);
d2778 2
a2779 1
		    TypeError("%s is not a module", rb_id2name(node->nd_cname));
d2782 1
a2782 1
		    Raise(eSecurityError, "extending module prohibited");
a2783 1
		Warning("extending module %s", rb_id2name(node->nd_cname));
d2787 6
a2792 2
		rb_const_set(the_class, node->nd_cname, module);
		rb_set_class_path(module,the_class,rb_id2name(node->nd_cname));
d2801 1
a2801 1
	    VALUE class;
d2803 4
a2806 3
	    class = rb_eval(self, node->nd_recv);
	    if (FIXNUM_P(class)) {
		TypeError("No virtual class for Fixnums");
d2808 2
a2809 2
	    if (NIL_P(class)) {
		TypeError("No virtual class for nil");
d2811 4
a2814 2
	    if (rb_special_const_p(class)) {
		TypeError("No virtual class for special constants");
d2816 2
a2817 6
	    if (FL_TEST(CLASS_OF(class), FL_SINGLETON)) {
		rb_clear_cache();
	    }
	    class = rb_singleton_class(class);

	    result = module_setup(class, node->nd_body);
d2824 1
a2824 1
	    char *desc = is_defined(self, node, buf);
d2826 2
a2827 2
	    if (desc) result = str_new2(desc);
	    else result = FALSE;
d2832 2
a2833 2
	sourcefile = node->file;
	sourceline = node->nd_nth;
d2835 2
a2836 2
	    call_trace_func("line", sourcefile, sourceline,
			    self, the_frame->last_func);	
d2842 1
a2842 1
	Bug("unknown node type %d", nd_type(node));
d2854 2
a2855 2
    NODE *state;
    VALUE save = the_frame->cbase;
d2857 7
d2870 1
a2870 1
    the_class = (struct RClass*)module;
d2872 1
d2874 1
a2874 1
    if (node->nd_rval) the_frame->cbase = node->nd_rval;
d2876 1
a2876 1
	VALUE *vars = ALLOCA_N(VALUE, node->nd_tbl[0]+1);
d2878 3
a2880 3
	the_scope->local_vars = vars;
	memclear(the_scope->local_vars, node->nd_tbl[0]);
	the_scope->local_tbl = node->nd_tbl;
d2883 2
a2884 2
	the_scope->local_vars = 0;
	the_scope->local_tbl  = 0;
d2887 1
a2887 1
    PUSH_TAG();
d2890 2
a2891 2
	    call_trace_func("class", node->file, nd_line(node),
			    the_class, the_frame->last_func);
d2893 1
a2893 1
	result = rb_eval((VALUE)the_class, node->nd_body);
d2896 1
d2899 2
a2900 1
    the_frame->cbase = save;
d2902 1
a2902 2
	call_trace_func("end", node->file, nd_line(node), 0,
			the_frame->last_func);
d2915 1
a2915 1
	return TRUE;
d2917 1
a2917 1
    return FALSE;
d2921 1
a2921 1
obj_respond_to(argc, argv, obj)
d2932 1
a2932 1
	return TRUE;
d2934 1
a2934 1
    return FALSE;
d2938 1
a2938 1
mod_method_defined(mod, mid)
d2942 1
a2942 1
	return TRUE;
d2944 1
a2944 1
    return FALSE;
d2953 1
a2953 1
	rb_raise(exc_new(eSystemExit, 0, 0));
d2955 2
d2961 1
a2961 1
f_exit(argc, argv, obj)
d2967 1
d2969 1
a2969 1
    rb_secure(2);
d2971 1
a2971 1
	status = NUM2INT(status);
d2974 1
a2974 1
	status = 0;
d2976 2
a2977 2
    rb_exit(status);
    /* not reached */
d2980 2
a2981 2
static VALUE
f_abort()
d2983 1
a2983 2
    rb_secure(2);
    if (errinfo) {
a2986 7
    /* not reached */
}

void
rb_break()
{
    JUMP_TAG2(TAG_BREAK, 0);
d2990 1
a2990 1
f_break()
d2992 3
a2994 1
    JUMP_TAG2(TAG_BREAK, 0);
d2997 2
a2998 14
static VALUE
f_next()
{
    JUMP_TAG2(TAG_NEXT, 0);
}

static VALUE
f_redo()
{
    JUMP_TAG2(TAG_REDO, 0);
}

static VALUE
f_retry()
d3000 1
a3000 1
    JUMP_TAG2(TAG_RETRY, 0);
d3003 2
a3004 5
#ifdef __GNUC__
static volatile voidfn rb_longjmp;
#endif

static VALUE make_backtrace();
d3011 5
a3015 2
    if (NIL_P(errinfo) && NIL_P(mesg)) {
	errinfo = exc_new(eRuntimeError, 0, 0);
d3018 9
a3026 2
    if (sourcefile && (NIL_P(errat) || !NIL_P(mesg))) {
	errat = make_backtrace();
d3029 5
a3033 8
    if (!NIL_P(mesg)) {
	if (obj_is_kind_of(mesg, eGlobalExit)) {
	    errinfo = mesg;
	}
	else {
	    errinfo = exc_new3(eRuntimeError, mesg);
	}
	str_freeze(errinfo);
d3036 9
a3044 1
    JUMP_TAG2(tag, 0);
d3048 1
a3048 1
rb_raise(mesg)
d3055 1
a3055 1
rb_fatal(mesg)
d3064 1
a3064 1
    Raise(eInterrupt, "");
d3068 1
a3068 1
f_raise(argc, argv)
d3072 1
a3072 3
    VALUE arg1, arg2;
    VALUE etype, mesg;
    int n;
a3073 1
    etype = eRuntimeError;
d3075 4
a3078 1
    switch (n = rb_scan_args(argc, argv, "02", &arg1, &arg2)) {
d3080 6
a3085 1
	mesg = arg1;
d3087 1
d3089 4
a3092 8
	etype = arg1;
	if (obj_is_kind_of(etype, eGlobalExit)) {
	    etype = CLASS_OF(etype);
	}
	else {
	    Check_Type(etype, T_CLASS);
	}
	mesg  = arg2;
a3094 1

d3096 3
a3098 4
	Check_Type(mesg, T_STRING);
	if (n == 2 || !obj_is_kind_of(mesg, eException)) {
	    mesg = exc_new3(etype, mesg);
	}
d3102 2
a3103 2
    *the_frame = *_frame.prev->prev;
    rb_raise(mesg);
d3105 9
d3117 1
a3117 1
iterator_p()
d3119 2
a3120 2
    if (the_frame->iter) return TRUE;
    return FALSE;
d3124 1
a3124 1
f_iterator_p()
d3126 2
a3127 2
    if (the_frame->prev && the_frame->prev->iter) return TRUE;
    return FALSE;
d3130 4
a3133 4
VALUE
rb_yield_0(val, self)
    VALUE val;
    volatile VALUE self;
a3135 1
    NODE *state;
d3140 2
d3143 2
a3144 2
    if (!iterator_p()) {
	Raise(eLocalJumpError, "yield called out of iterator");
d3149 1
a3149 1
    block = the_block;
d3151 14
a3164 7
    frame.prev = the_frame;
    the_frame = &(frame);
    old_scope = the_scope;
    the_scope = block->scope;
    the_block = block->prev;
    the_dyna_vars = block->d_vars;
    the_class = block->class;
d3168 9
a3176 4
	if (nd_type(block->var) == NODE_MASGN)
	    massign(self, block->var, val);
	else
	    assign(self, block->var, val);
d3179 1
a3179 1
    PUSH_TAG();
d3186 1
a3186 1
	    result = (*node->nd_cfnc)(val, node->nd_argc, self);
d3193 1
a3193 1
	switch (state->nd_tag) {
d3203 3
a3205 2
	    state->nd_tlev = block->level;
	    state->nd_tag = IN_BLOCK|state->nd_tag;
d3212 1
d3216 5
a3220 3
    the_block = block;
    the_frame = the_frame->prev;
    the_scope = old_scope;
d3229 1
a3229 1
    return rb_yield_0(val, 0);
d3233 1
a3233 1
f_loop()
d3235 1
a3235 1
    for (;;) { rb_yield(Qnil); }
d3239 1
a3239 1
massign(self, node, val)
d3243 1
d3246 1
a3246 1
    int i, len;
d3252 1
a3252 1
	    val = rb_to_a(val);
d3256 1
a3256 1
	    assign(self, list->nd_head, RARRAY(val)->ptr[i]);
d3259 1
d3261 5
a3265 2
	    if (!list && i<len) {
		assign(self, node->nd_args, ary_new4(len-i, RARRAY(val)->ptr+i));
d3268 1
a3268 1
		assign(self, node->nd_args, ary_new2(0));
d3271 1
d3273 2
a3274 2
    else if (node->nd_args) {
	assign(self, node->nd_args, Qnil);
d3276 2
d3279 2
a3280 1
	assign(self, list->nd_head, Qnil);
d3284 7
d3294 1
a3294 1
assign(self, lhs, val)
d3298 1
d3310 3
a3312 3
	if (the_scope->local_vars == 0)
	    Bug("unexpected iterator variable assignment");
	the_scope->local_vars[lhs->nd_cnt] = val;
d3316 5
a3320 1
	dyna_var_asgn(lhs->nd_vid, val);
d3324 5
a3328 1
	rb_const_set(the_class, lhs->nd_vid, val);
d3335 1
a3335 1
	    if (!lhs->nd_args->nd_head) {
d3337 1
a3337 1
		rb_funcall2(recv, lhs->nd_mid, 1, &val);
d3344 3
a3346 2
		RARRAY(args)->ptr[RARRAY(args)->len-1] = val;
		rb_apply(recv, lhs->nd_mid, args);
d3352 1
a3352 1
	Bug("bug in variable assignment");
d3360 1
a3360 1
    void *data1, *data2;
d3362 1
a3362 1
    NODE *state;
d3365 1
a3365 2
    VALUE self = TopSelf;
    int tag_level;
d3370 1
a3370 1
    PUSH_TAG();
d3376 6
a3382 2

    tag_level = the_block->level;
d3386 6
a3391 4
    if (state) {
	switch (state->nd_tag) {
	  case TAG_RETRY:
	    goto iter_retry;
d3393 3
a3395 6
	  case IN_BLOCK|TAG_BREAK:
	    if (state->nd_tlev != tag_level) {
		JUMP_TAG(state);
	    }
	    retval = Qnil;
	    break;
d3397 5
a3401 8
	  case IN_BLOCK|TAG_RETURN:
	    if (state->nd_tlev == tag_level) {
		state->nd_tag &= ~IN_BLOCK;
	    }
	    /* fall through */
	  default:
	    JUMP_TAG(state);
	}
d3412 1
d3415 1
a3415 1
	return obj_is_kind_of(errinfo, eException);
d3418 1
a3418 1
    PUSH_ITER(ITER_NOT);
d3420 2
a3421 1
    POP_ITER();
d3423 2
a3424 2
	if (!obj_is_kind_of(argv[0], cModule)) {
	    TypeError("class or module required for rescue clause");
d3426 1
a3426 1
	if (obj_is_kind_of(errinfo, argv[0])) return 1;
d3435 1
a3435 1
    void *data1, *data2;
d3437 1
a3437 1
    NODE *state;
d3439 1
d3441 1
a3441 1
    PUSH_TAG();
d3446 5
a3450 12
    else {
	if (state->nd_tag == TAG_RAISE) { 
	    if (r_proc) {
		PUSH_TAG();
		if ((state = EXEC_TAG()) == 0) {
		    result = (*r_proc)(data2, errinfo);
		}
		POP_TAG();
		if (state && state->nd_tag == TAG_RETRY) {
		    state = 0;
		    goto retry_entry;
		}
d3452 2
a3453 2
	    else {
		result = Qnil;
d3455 1
d3457 7
a3463 3
	    if (state == 0) {
		errat = Qnil;
	    }
d3473 24
d3498 3
a3500 2
    VALUE (*b_proc)(), (*e_proc)();
    void *data1, *data2;
d3502 1
a3502 1
    NODE *state;
d3504 1
d3506 1
a3506 1
    PUSH_TAG();
d3511 15
d3527 4
a3530 3
    (*e_proc)(data2);
    if (state) {
	JUMP_TAG(state);
d3532 4
d3540 4
a3543 2
#define CSTAT_NOEX  1
#define CSTAT_VCALL 2
d3546 1
a3546 1
f_missing(argc, argv, obj)
a3550 1
    VALUE desc = 0;
d3552 1
d3554 3
a3556 2
    char *file = sourcefile;
    int   line = sourceline;
d3566 1
a3566 1
	format = "undefined method `%s' for TRUE";
d3569 1
a3569 1
	format = "undefined method `%s' for FALSE";
d3572 1
a3572 1
	desc = obj_as_string(obj);
d3575 1
a3575 1
	desc = rb_inspect(obj);
d3578 3
a3580 3
    if (desc) {
	if (last_call_status & CSTAT_NOEX) {
	    format = "private method `%s' called for %s(%s)";
d3582 2
a3583 2
	else if (iterator_p()) {
	    format = "undefined iterator `%s' for %s(%s)";
d3586 1
a3586 1
	    char *mname = rb_id2name(id);
d3589 1
a3589 1
		format = "undefined local variable or method `%s' for %s(%s)";
d3593 1
a3593 1
	    format = "undefined method `%s' for %s(%s)";
d3595 2
a3596 2
	if (RSTRING(desc)->len > 65) {
	    desc = any_to_s(obj);
d3598 1
d3601 2
a3602 2
    sourcefile = file;
    sourceline = line;
d3604 1
a3604 1
    *the_frame = *_frame.prev->prev;
d3606 3
a3608 4
    NameError(format,
	      rb_id2name(id),
	      desc?(char*)RSTRING(desc)->ptr:"",
	      desc?rb_class2name(CLASS_OF(obj)):"");
d3630 1
a3630 1
    return rb_funcall2(obj, rb_intern("method_missing"), argc+1, nargv);
d3640 1
a3640 1
# define STACK_LEVEL_MAX 655350
d3643 1
a3643 1
extern VALUE *gc_stack_start;
d3650 1
a3650 1
    return gc_stack_start - &pos + 0x80;
d3652 2
a3653 2
    return (&pos < gc_stack_start) ? gc_stack_start - &pos
	                           : &pos - gc_stack_start;
d3658 2
a3659 2
rb_call(class, recv, mid, argc, argv, scope)
    struct RClass *class;
d3661 88
a3748 1
    ID    mid;
d3751 2
a3752 1
    int scope;
d3754 1
a3754 4
    NODE *body, *b2;		/* OK */
    int    noex;
    ID     id = mid;
    struct cache_entry *ent;
a3756 1
    enum node_type type;
d3758 1
d3760 1
a3760 18
  again:
    /* is it in the method cache? */
    ent = cache + EXPR1(class, mid);
    if (ent->mid == mid && ent->class == class) {
	class = ent->origin;
	id   = ent->mid0;
	noex  = ent->noex;
	body  = ent->method;
    }
    else if ((body = rb_get_method_body(&class, &id, &noex)) == 0) {
	return rb_undefined(recv, mid, argc, argv, scope==2?CSTAT_VCALL:0);
    }

    /* receiver specified form for private method */
    if (noex == NOEX_PRIVATE && scope == 0)
	return rb_undefined(recv, mid, argc, argv, CSTAT_NOEX);

    switch (the_iter->iter) {
d3770 4
a3773 15
    type = nd_type(body);
    if (type == NODE_ZSUPER) {
	/* for re-scoped/renamed method */
	mid = id;
	if (scope == 0) scope = 1;
	if (class->super == 0) {
	    /* origin is the Module, so need to scan superclass hierarchy. */
	    struct RClass *cl = class;

	    class = (struct RClass*)RBASIC(recv)->class;
	    while (class) {
		if (class->m_tbl == cl->m_tbl)
		    break;
		class = class->super;
	    }
a3774 4
	else {
	    class = class->super;
	}
	goto again;
a3775 4

    if ((++tick & 0xfff) == 0 && stack_length() > STACK_LEVEL_MAX)
	Fatal("stack level too deep");

a3777 4
    the_frame->last_func = id;
    the_frame->last_class = class;
    the_frame->argc = argc;
    the_frame->argv = argv;
d3779 7
a3785 1
    switch (type) {
d3790 24
a3813 2
	    if (len >= 0 && argc != len) {
		ArgError("Wrong # of arguments(%d for %d)", argc, len);
d3815 2
d3818 2
a3819 104
	    switch (len) {
	      case -2:
		result = (*body->nd_cfnc)(recv, ary_new4(argc, argv));
		break;
	      case -1:
		result = (*body->nd_cfnc)(argc, argv, recv);
		break;
	      case 0:
		result = (*body->nd_cfnc)(recv);
		break;
	      case 1:
		result = (*body->nd_cfnc)(recv, argv[0]);
		break;
	      case 2:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1]);
		break;
	      case 3:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2]);
		break;
	      case 4:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3]);
		break;
	      case 5:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3], argv[4]);
		break;
	      case 6:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3], argv[4], argv[5]);
		break;
	      case 7:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3], argv[4], argv[5],
					  argv[6]);
		break;
	      case 8:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3], argv[4], argv[5],
					  argv[6], argv[7]);
		break;
	      case 9:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3], argv[4], argv[5],
					  argv[6], argv[7], argv[8]);
		break;
	      case 10:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3], argv[4], argv[5],
					  argv[6], argv[7], argv[8],
					  argv[6], argv[7], argv[8],
					  argv[9]);
		break;
	      case 11:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3], argv[4], argv[5],
					  argv[6], argv[7], argv[8],
					  argv[6], argv[7], argv[8],
					  argv[9], argv[10]);
		break;
	      case 12:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3], argv[4], argv[5],
					  argv[6], argv[7], argv[8],
					  argv[6], argv[7], argv[8],
					  argv[9], argv[10], argv[11]);
		break;
	      case 13:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3], argv[4], argv[5],
					  argv[6], argv[7], argv[8],
					  argv[6], argv[7], argv[8],
					  argv[9], argv[10], argv[11],
					  argv[12]);
		break;
	      case 14:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3], argv[4], argv[5],
					  argv[6], argv[7], argv[8],
					  argv[6], argv[7], argv[8],
					  argv[9], argv[10], argv[11],
					  argv[12], argv[13]);
		break;
	      case 15:
		result = (*body->nd_cfnc)(recv, argv[0], argv[1], argv[2],
					  argv[3], argv[4], argv[5],
					  argv[6], argv[7], argv[8],
					  argv[6], argv[7], argv[8],
					  argv[9], argv[10], argv[11],
					  argv[12], argv[13], argv[14]);
		break;
	      default:
		if (len < 0) {
		    Bug("bad argc(%d) specified for `%s(%s)'",
			len, rb_class2name((VALUE)class), rb_id2name(mid));
		}
		else {
		    ArgError("too many arguments(%d)", len);
		}
		break;
	    }
	}
	break;

d3828 2
a3829 2
	    NODE  *state;
	    VALUE *local_vars;
d3833 1
a3833 1
	    if (body->nd_rval) the_frame->cbase = body->nd_rval;
d3835 1
a3835 1
		local_vars = ALLOCA_N(VALUE, body->nd_tbl[0]+1);
d3837 3
a3839 3
		memclear(local_vars, body->nd_tbl[0]);
		the_scope->local_tbl = body->nd_tbl;
		the_scope->local_vars = local_vars;
d3842 2
a3843 2
		local_vars = the_scope->local_vars = 0;
		the_scope->local_tbl  = 0;
d3845 1
a3845 1
	    b2 = body = body->nd_body;
a3846 1
	    PUSH_TAG();
d3848 1
d3851 2
a3852 3
		if (nd_type(body) == NODE_BLOCK) {
		    NODE *node = body->nd_head;
		    int i;
d3854 9
d3864 1
a3864 1
			Bug("no argument-node");
a3866 1
		    body = body->nd_next;
d3869 2
a3870 1
			ArgError("Wrong # of arguments(%d for %d)", argc, i);
d3873 1
a3873 1
			int opt = argc - i;
d3877 1
a3877 1
			    opt--;
d3880 3
a3882 3
			if (opt > 0) {
			    ArgError("Wrong # of arguments(%d for %d)",
				     argc, argc-opt);
d3884 2
d3890 2
a3891 1
			    MEMCPY(local_vars, argv, VALUE, i);
d3898 1
a3898 1
				assign(recv, opt->nd_head, *argv);
d3906 1
a3906 1
				local_vars[node->nd_rest]=ary_new4(argc,argv);
d3908 1
a3908 1
				local_vars[node->nd_rest]=ary_new2(0);
d3912 1
a3912 3
		else if (nd_type(body) == NODE_ARGS) {
		    body = 0;
		}
d3914 2
a3915 2
		    call_trace_func("call", b2->file, nd_line(b2),
				    recv, the_frame->last_func);
d3919 5
a3924 1
	    POP_TAG();
d3927 2
a3928 2
		char *file = the_frame->prev->file;
		int line = the_frame->prev->line;
d3930 2
a3931 2
		    file = sourcefile;
		    line = sourceline;
d3933 2
a3934 1
		call_trace_func("return", file, line, 0, the_frame->last_func);
d3936 16
a3951 20
	    if (state) {
		switch (state->nd_tag) {
		  case TAG_NEXT:
		    Raise(eLocalJumpError, "unexpected next");
		    break;
		  case TAG_BREAK:
		    Raise(eLocalJumpError, "unexpected break");
		    break;
		  case TAG_REDO:
		    Raise(eLocalJumpError, "unexpected redo");
		    break;
		  case TAG_RETURN:
		    result = state->nd_tval;
		    break;
		  case TAG_RETRY:
		    if (!iterator_p()) {
			Raise(eLocalJumpError, "retry outside of rescue clause");
		    }
		  default:
		    JUMP_TAG(state);
d3953 2
d3963 47
a4012 1
    struct RArray *args;
d4014 1
d4026 1
a4026 1
f_send(argc, argv, recv)
a4031 1
    ID mid;
d4033 1
a4033 1
    if (argc == 0) ArgError("no method name given");
d4035 3
a4037 9
    vid = argv[0]; argc--; argv++;
    if (TYPE(vid) == T_STRING) {
	mid = rb_intern(RSTRING(vid)->ptr);
    }
    else {
	mid = NUM2INT(vid);
    }
    PUSH_ITER(iterator_p()?ITER_PRE:ITER_NOT);
    vid = rb_call(CLASS_OF(recv), recv, mid, argc, argv, 1);
d4043 5
d4049 2
d4053 3
d4061 1
d4071 1
a4071 1
	va_start(ar);
d4094 10
d4108 1
a4108 1
    struct FRAME *frame = the_frame;
a4110 1
    int slev = safe_level;
d4112 1
a4112 2
    safe_level = 0;
    ary = ary_new();
d4115 3
a4117 2
	    sprintf(buf, "%s:%d:in `%s'", sourcefile, sourceline,
		    rb_id2name(frame->last_func));
d4120 1
a4120 1
	    sprintf(buf, "%s:%d", sourcefile, sourceline);
d4122 1
a4122 1
	ary_push(ary, str_new2(buf));
d4127 4
a4130 1
	    if (!frame) return Qnil;
d4135 3
a4137 3
	    sprintf(buf, "%s:%d:in `%s'",
		    frame->file, frame->line,
		    rb_id2name(frame->prev->last_func));
d4140 1
a4140 1
	    sprintf(buf, "%s:%d", frame->file, frame->line);
d4142 1
a4142 1
	ary_push(ary, str_new2(buf));
d4145 1
a4145 1
    safe_level = slev;
d4150 1
a4150 1
f_caller(argc, argv)
d4161 1
a4161 1
    if (lev < 0) ArgError("negative level(%d)", lev);
d4191 1
a4191 1
    return the_frame->last_func;
d4195 4
a4198 2
compile(src)
    struct RString *src;
d4203 1
d4205 1
a4205 3
    node = compile_string(sourcefile, src->ptr, src->len);

    if (nerrs == 0) return node;
d4210 4
a4213 4
eval(self, src, scope)
    VALUE self;
    struct RString *src;
    struct RData *scope;
d4217 4
a4220 4
    NODE *state;
    volatile VALUE old_block;
    volatile VALUE old_scope;
    volatile VALUE old_d_vars;
d4222 9
a4230 4
    char *file = sourcefile;
    int line = sourceline;
    volatile int iter = the_frame->iter;

d4232 3
a4234 3
	if (TYPE(scope) != T_DATA || scope->dfree != blk_free) {
	    TypeError("wrong argument type %s (expected Proc/Binding)",
		      rb_class2name(CLASS_OF(scope)));
d4241 10
a4250 8
	frame.prev = the_frame;
	the_frame = &(frame);
	old_scope = (VALUE)the_scope;
	the_scope = data->scope;
	old_block = (VALUE)the_block;
	the_block = data->prev;
	old_d_vars = (VALUE)the_dyna_vars;
	the_dyna_vars = data->d_vars;
d4253 1
a4253 1
	the_frame->iter = data->iter;
d4256 2
a4257 2
	if (the_frame->prev) {
	    the_frame->iter = the_frame->prev->iter;
d4261 1
a4261 1
    the_class = (struct RClass*)((NODE*)the_frame->cbase)->nd_clss;
d4263 3
a4265 3
    rb_in_eval++;
    if (TYPE(the_class) == T_ICLASS) {
	the_class = (struct RClass*)RBASIC(the_class)->class;
d4267 1
a4267 1
    PUSH_TAG();
d4269 3
a4271 3
	compile(src);
	if (nerrs > 0) {
	    compile_error("eval()");
d4277 1
a4277 1
    rb_in_eval--;
d4279 8
a4286 4
	the_frame = the_frame->prev;
	the_scope = (struct SCOPE*)old_scope;
	the_block = (struct BLOCK*)old_block;
	the_dyna_vars = (struct RVarmap*)old_d_vars;
d4289 1
a4289 1
	the_frame->iter = iter;
d4291 2
d4294 7
a4300 9
	VALUE err ;

	switch (state->nd_tag) {
	  case TAG_RAISE:
	    sourcefile = file;
	    sourceline = line;
	    if (strcmp(sourcefile, "(eval)") == 0) {
		err = errinfo;
		if (sourceline > 1) {
d4302 5
a4306 2
		    str_cat(err, ": ", 2);
		    str_cat(err, RSTRING(errinfo)->ptr, RSTRING(errinfo)->len);
d4309 1
a4309 1
		rb_raise(exc_new3(CLASS_OF(errinfo), err));
d4311 1
a4311 1
	    rb_raise(Qnil);
d4320 1
a4320 1
f_eval(argc, argv, self)
d4325 58
a4382 1
    VALUE src, scope;
d4384 8
a4391 1
    rb_scan_args(argc, argv, "11", &src, &scope);
d4394 107
a4500 1
    return eval(self, src, scope);
d4505 21
a4525 1
char *dln_find_file();
d4532 1
a4532 1
    VALUE vpath;
d4535 8
a4542 4
    if (file[0] == '/') return file;
#if defined(MSDOS) || defined(NT) || defined(__human68k__)
    if (file[0] == '\\') return file;
    if (file[1] == ':') return file;
d4545 14
d4563 1
d4565 10
a4574 1
	    Check_SafeStr(RARRAY(rb_load_path)->ptr[i]);
a4575 7
#if !defined(MSDOS) && !defined(NT) && !defined(__human68k__)
	vpath = ary_join(rb_load_path, str_new2(":"));
#else
	vpath = ary_join(rb_load_path, str_new2(";"));
#endif
	Check_SafeStr(vpath);
	path = RSTRING(vpath)->ptr;
d4584 4
a4587 4
VALUE
f_load(obj, fname)
    VALUE obj;
    struct RString *fname;
d4589 1
a4589 1
    NODE *state;
d4592 2
d4595 9
a4603 3
    Check_SafeStr(fname);
    if (fname->ptr[0] == '~') {
	fname = (struct RString*)file_s_expand_path(0, fname);
a4604 2
    file = find_file(fname->ptr);
    if (!file) LoadError("No such file to load -- %s", fname->ptr);
d4606 1
a4606 1
    PUSH_TAG();
d4608 14
a4621 1
    the_class = (struct RClass*)cObject;
d4623 1
a4623 1
    if (top_scope->local_tbl) {
d4626 1
a4626 1
	VALUE *vars = ALLOCA_N(VALUE, len);
d4629 3
a4631 3
	MEMCPY(vars, top_scope->local_vars, ID, len-1);
	the_scope->local_tbl = tbl;
	the_scope->local_vars = vars;
d4633 2
d4636 1
d4638 1
a4638 2
    last_func = the_frame->last_func;
    the_frame->last_func = 0;
d4640 1
a4640 1
	rb_in_eval++;
d4642 3
a4644 3
	rb_in_eval--;
	if (nerrs == 0) {
	    eval_node(TopSelf);
d4647 4
a4650 3
    the_frame->last_func = last_func;
    if (the_scope->flag == SCOPE_ALLOCA && the_scope->local_tbl) {
	free(the_scope->local_tbl);
d4652 1
d4654 1
d4656 5
a4660 3
    POP_TAG();
    if (nerrs > 0) {
	rb_raise(errinfo);
d4663 24
d4688 3
a4690 1
    return TRUE;
d4697 1
a4697 1
    char *feature;
a4698 1
    struct RArray *features = RARRAY(rb_features);
d4703 2
a4704 2
    p = features->ptr;
    pend = p + features->len;
d4706 2
a4707 3
	Check_Type(*p, T_STRING);
	f = RSTRING(*p)->ptr;
	if (strcmp(f, feature) == 0) return TRUE;
d4710 2
a4711 2
	    && (strcmp(f+len, ".rb") == 0 ||strcmp(f+len, ".o") == 0)) {
	    return TRUE;
d4715 1
a4715 1
    return FALSE;
d4718 2
a4719 4
#ifdef THREAD
static int thread_loading();
static void thread_loading_done();
#endif
d4723 1
a4723 1
    char *feature;
d4729 2
a4730 2
	if (strcmp(DLEXT, ext) == 0) {
	    buf = ALLOCA_N(char, strlen(feature)+1);
d4733 1
a4733 1
	    strcpy(ext, ".o");
d4736 1
a4736 1
	ary_push(rb_features, str_new2(feature));
d4741 2
a4742 3
f_require(obj, fname)
    VALUE obj;
    struct RString *fname;
d4744 1
a4744 1
    char *ext, *file, *feature, *buf;
d4746 1
d4748 1
d4750 2
a4751 2
    if (rb_provided(fname->ptr))
	return FALSE;
d4753 1
a4753 1
    ext = strrchr(fname->ptr, '.');
d4756 1
a4756 1
	    feature = file = fname->ptr;
d4758 1
a4758 1
	    if (file) goto rb_load;
d4760 4
a4763 4
	else if (strcmp(".o", ext) == 0) {
	    file = feature = fname->ptr;
	    if (strcmp(".o", DLEXT) != 0) {
		buf = ALLOCA_N(char, strlen(fname->ptr)+sizeof(DLEXT)+1);
d4767 1
a4767 1
		file = find_file(buf);
d4769 2
a4770 1
	    if (file) goto dyna_load;
d4773 1
a4773 1
	    feature = fname->ptr;
d4775 1
a4775 1
	    if (file) goto dyna_load;
d4778 3
a4780 2
    buf = ALLOCA_N(char, strlen(fname->ptr) + 5);
    sprintf(buf, "%s.rb", fname->ptr);
d4783 1
a4783 1
	fname = (struct RString*)str_new2(file);
d4785 1
a4785 1
	goto rb_load;
d4787 2
a4788 1
    sprintf(buf, "%s%s", fname->ptr, DLEXT);
d4792 1
a4792 1
	goto dyna_load;
d4794 2
a4795 1
    LoadError("No such file to load -- %s", fname->ptr);
d4797 9
a4805 17
  dyna_load:
#ifdef THREAD
    if (thread_loading(feature)) return FALSE;
    else {
	NODE *state;
	PUSH_TAG();
	if ((state = EXEC_TAG()) == 0) {
#endif
	    load = str_new2(file);
	    file = RSTRING(load)->ptr;
	    dln_load(file);
	    rb_provide(feature);
#ifdef THREAD
	}
	POP_TAG();
	thread_loading_done();
	if (state) JUMP_TAG(state);
d4807 9
a4815 2
#endif
    return TRUE;
d4817 3
a4819 15
  rb_load:
#ifdef THREAD
    if (thread_loading(feature)) return FALSE;
    else {
	NODE *state;
	PUSH_TAG();
	if ((state = EXEC_TAG()) == 0) {
#endif
	    f_load(obj, fname);
	    rb_provide(feature);
#ifdef THREAD
	}
	POP_TAG();
	thread_loading_done();
	if (state) JUMP_TAG(state);
d4821 12
a4832 2
#endif
    return TRUE;
d4840 1
a4840 1
    int ex;
d4850 16
a4865 1
mod_public(argc, argv, module)
d4870 6
a4875 1
    set_method_visibility(module, argc, argv, NOEX_PUBLIC);
d4880 1
a4880 1
mod_private(argc, argv, module)
d4885 6
a4890 1
    set_method_visibility(module, argc, argv, NOEX_PRIVATE);
d4895 1
a4895 1
mod_public_method(argc, argv, obj)
d4905 1
a4905 1
mod_private_method(argc, argv, obj)
d4915 17
a4931 1
mod_modfunc(argc, argv, module)
d4940 5
a4944 1
    rb_clear_cache();
d4950 1
a4950 2
	    NameError("undefined method `%s' for module `%s'",
		      rb_id2name(id), rb_class2name(module));
d4952 1
d4959 18
a4976 1
mod_include(argc, argv, module)
d4985 1
a4985 1
	rb_include_module(module, argv[i]);
d4990 3
a4992 2
VALUE
class_s_new(argc, argv, class)
a4994 1
    VALUE class;
d4996 1
a4996 7
    VALUE obj = obj_alloc(class);

    if (FL_TEST(class, FL_SINGLETON)) {
	TypeError("can't create instance of virtual class");
    }
    obj = obj_alloc(class);
    PUSH_ITER(iterator_p()?ITER_PRE:ITER_NOT);
a4998 1
    return obj;
a5000 1

d5002 1
a5002 1
class_new_instance(argc, argv, class)
d5005 1
a5005 1
    VALUE class;
d5009 2
a5010 2
    if (FL_TEST(class, FL_SINGLETON)) {
	TypeError("can't create instance of virtual class");
d5012 3
a5014 4
    obj = obj_alloc(class);
    PUSH_ITER(iterator_p()?ITER_PRE:ITER_NOT);
    rb_funcall2(obj, init, argc, argv);
    POP_ITER();
d5024 1
a5024 1
    return mod_include(argc, argv, cObject);
d5035 1
a5035 1
mod_extend_object(mod, obj)
d5043 1
a5043 1
obj_extend(argc, argv, obj)
d5057 14
a5070 2
VALUE f_trace_var();
VALUE f_untrace_var();
d5072 6
a5077 1
extern void rb_str_setter();
d5085 2
a5086 12
    int i;
    static char *err = "value of $@@ must be Array of String";

    if (!NIL_P(val)) {
	if (TYPE(val) != T_ARRAY) {
	    TypeError(err);
	}
	for (i=0;i<RARRAY(val)->len;i++) {
	    if (TYPE(RARRAY(val)->ptr[i]) != T_STRING) {
		TypeError(err);
	    }
	}
d5088 1
a5088 1
    *var = val;
d5091 3
d5095 1
a5095 2
f_catch(dmy, tag)
    VALUE dmy, tag;
d5097 4
a5100 3
    NODE *state;
    ID t;
    VALUE val;
d5102 7
a5108 4
    t = rb_to_id(tag);
    PUSH_TAG();
    if ((state = EXEC_TAG()) == 0) {
	val = rb_yield(tag);
d5110 5
a5114 4
    POP_TAG();
    if (state) {
	if (state->nd_tag == TAG_THROW && state->nd_tlev == t) {
	    return state->nd_tval;
d5116 1
a5116 1
	JUMP_TAG(state);
d5118 42
a5159 1
    return val;
d5163 12
a5174 3
f_throw(argc, argv)
    int argc;
    VALUE *argv;
d5176 3
a5178 2
    VALUE tag, value;
    ID t;
d5180 7
a5186 4
    rb_scan_args(argc, argv, "11", &tag, &value);
    t = rb_to_id(tag);
    JUMP_TAG3(TAG_THROW, value, t);
    /* not reached */
d5198 37
d5236 12
a5247 44
    rb_global_variable(&top_scope);
    rb_global_variable(&eval_tree);
    rb_global_variable(&the_dyna_vars);

    rb_define_hooked_variable("$@@", &errat, 0, errat_setter);
    rb_define_hooked_variable("$!", &errinfo, 0, rb_str_setter);

    rb_define_global_function("eval", f_eval, -1);
    rb_define_global_function("iterator?", f_iterator_p, 0);
    rb_define_global_function("method_missing", f_missing, -1);
    rb_define_global_function("loop", f_loop, 0);

    rb_define_method(mKernel, "respond_to?", obj_respond_to, -1);

    rb_define_global_function("break", f_break, 0);
    rb_define_alias(mKernel,  "break!", "break");
    rb_define_global_function("next", f_next, 0);
    rb_define_alias(mKernel,  "next!", "next");
    rb_define_alias(mKernel,  "continue", "next");
    rb_define_global_function("redo", f_redo, 0);
    rb_define_alias(mKernel,  "redo!", "redo");
    rb_define_global_function("retry", f_retry, 0);
    rb_define_alias(mKernel,  "retry!", "retry");
    rb_define_global_function("raise", f_raise, -1);
    rb_define_alias(mKernel,  "fail", "raise");

    rb_define_global_function("caller", f_caller, -1);

    rb_define_global_function("exit", f_exit, -1);
    rb_define_global_function("abort", f_abort, 0);

    rb_define_global_function("catch", f_catch, 1);
    rb_define_global_function("throw", f_throw, -1);

    rb_define_method(mKernel, "send", f_send, -1);

    rb_define_private_method(cModule, "include", mod_include, -1);
    rb_define_private_method(cModule, "public", mod_public, -1);
    rb_define_private_method(cModule, "private", mod_private, -1);
    rb_define_private_method(cModule, "module_function", mod_modfunc, -1);
    rb_define_method(cModule, "method_defined?", mod_method_defined, 1);
    rb_define_method(cModule, "extend_object", mod_extend_object, 1);
    rb_define_method(cModule, "public_class_method", mod_public_method, -1);
    rb_define_method(cModule, "private_class_method", mod_private_method, -1);
d5249 3
a5251 2
    rb_define_method(CLASS_OF(TopSelf), "include", top_include, -1);
    rb_define_method(mKernel, "extend", obj_extend, -1);
d5253 11
a5263 2
    rb_define_global_function("trace_var", f_trace_var, -1);
    rb_define_global_function("untrace_var", f_untrace_var, -1);
d5270 1
a5270 1
VALUE f_autoload();
d5275 1
a5275 1
    rb_load_path = ary_new();
d5280 1
a5280 1
    rb_features = ary_new();
d5283 4
a5286 3
    rb_define_global_function("load", f_load, 1);
    rb_define_global_function("require", f_require, 1);
    rb_define_global_function("autoload", f_autoload, 2);
d5315 10
a5324 6
    gc_mark_frame(&data->frame);
    gc_mark(data->scope);
    gc_mark(data->var);
    gc_mark(data->body);
    gc_mark(data->self);
    gc_mark(data->d_vars);
d5331 82
a5412 1
    free(data->frame.argv);
d5416 1
a5416 1
f_binding(self)
d5423 2
a5424 2
    bind = Data_Make_Struct(cData, struct BLOCK, blk_mark, blk_free, data);
    MEMCPY(data, the_block, struct BLOCK, 1);
d5426 13
a5438 4
    data->iter = f_iterator_p();
    data->frame.last_func = 0;
    data->frame.argv = ALLOC_N(VALUE, data->frame.argc);
    MEMCPY(data->frame.argv, the_block->frame.argv, VALUE, data->frame.argc);
a5445 1
#define PROC_TAINT FL_USER0
d5451 3
a5453 3
static VALUE
proc_s_new(class)
    VALUE class;
d5455 1
a5455 20
    VALUE proc;
    struct BLOCK *data;

    if (!iterator_p() && !f_iterator_p()) {
	ArgError("tryed to create Procedure-Object out of iterator");
    }

    proc = Data_Make_Struct(class, struct BLOCK, blk_mark, blk_free, data);
    *data = *the_block;

#ifdef THREAD
    data->orig_thread = thread_current();
#endif
    data->iter = f_iterator_p();
    data->frame.argv = ALLOC_N(VALUE, data->frame.argc);
    MEMCPY(data->frame.argv, the_block->frame.argv, VALUE, data->frame.argc);

    scope_dup(data->scope);
    if (safe_level >= 3) {
	FL_SET(proc, PROC_TAINT);
d5458 1
a5458 1
	    FL_SET(proc, PROC_T3);
d5461 1
a5461 1
	    FL_SET(proc, PROC_T4);
d5464 20
a5483 1
	    FL_SET(proc, PROC_T5);
d5487 29
d5521 1
a5521 1
f_lambda()
d5523 15
a5537 1
    return proc_s_new(cProc);
d5542 1
a5542 1
    VALUE proc, args;
d5544 1
d5547 1
a5547 2
    NODE *state;
    int tag_level;
d5551 9
d5563 1
a5563 1
	    args = 0;
d5571 16
a5586 1
    Data_Get_Struct(proc, struct BLOCK, data);
d5588 3
a5590 2
    if (data->scope && (data->scope->flag & SCOPE_NOSTACK)) {
	orphan = 1;
d5592 16
a5607 4
    else {
#ifdef THREAD
	if (data->orig_thread != thread_current()) {
	    orphan = 1;
d5609 1
a5609 3
	else
#endif
	orphan = 0;
d5611 22
a5632 6
    if (orphan) {/* orphan procedure */
	if (iterator_p()) {
	    data->frame.iter = ITER_CUR;
	}
	else {
	    data->frame.iter = ITER_NOT;
d5634 27
d5663 3
d5667 4
a5670 16
    PUSH_BLOCK2(data);
    PUSH_ITER(ITER_CUR);
    the_frame->iter = ITER_CUR;
    if (FL_TEST(proc, PROC_TAINT)) {
	switch (RBASIC(proc)->flags & PROC_TMASK) {
	  case PROC_T3:
	    safe_level = 3;
	    break;
	  case PROC_T4:
	    safe_level = 4;
	    break;
	  case PROC_T5:
	    safe_level = 5;
	    break;
	}
    }
d5672 1
a5672 1
    PUSH_TAG();
d5675 2
a5676 1
	result = rb_yield(args);
a5678 1

d5680 5
a5684 2
    tag_level = the_block->level;
    POP_BLOCK();
d5688 4
a5691 6
	if (orphan) {/* orphan procedure */
	    switch (state->nd_tag) {
	      case TAG_BREAK:	/* never happen */
	      case IN_BLOCK|TAG_BREAK:
		if (state->nd_tlev == tag_level)
		    Raise(eLocalJumpError, "break from proc-closure");
d5694 1
a5694 1
		Raise(eLocalJumpError, "retry from proc-closure");
d5696 2
a5697 4
	      case TAG_RETURN:	/* never happen */
	      case IN_BLOCK|TAG_RETURN:
		if (state->nd_tlev == tag_level)
		    Raise(eLocalJumpError, "return from proc-closure");
a5700 3
	else if (state->nd_tlev == tag_level) {
	    state->nd_tag &= ~IN_BLOCK;
	}
d5706 171
d5880 2
a5881 1
    eLocalJumpError = rb_define_class("LocalJumpError", eException);
d5883 2
a5884 2
    cProc = rb_define_class("Proc", cObject);
    rb_define_singleton_method(cProc, "new", proc_s_new, 0);
d5886 19
a5904 4
    rb_define_method(cProc, "call", proc_call, -2);
    rb_define_global_function("proc", f_lambda, 0);
    rb_define_global_function("lambda", f_lambda, 0);
    rb_define_global_function("binding", f_binding, 0);
d5907 1
a5907 3
#ifdef THREAD

static VALUE eThreadError;
d5909 1
a5909 1
int thread_pending = 0;
d5911 1
a5911 1
static VALUE cThread;
d5931 1
a5931 1
extern VALUE last_status;
a5961 1
    struct RClass *class;
d5966 2
d5970 1
d5975 1
a5975 1
    VALUE errat, errinfo;
d5982 1
a5982 1
    enum  thread_status status;
d5990 2
d5995 6
a6000 4
static thread_t curr_thread;
static int num_waiting_on_fd;
static int num_waiting_on_timer;
static int num_waiting_on_join;
d6029 17
a6045 1
    gc_mark(th->result);
d6047 1
a6047 1
	gc_mark_locations(th->stk_ptr, th->stk_ptr+th->stk_len);
d6049 1
a6049 1
	gc_mark_locations(th->stk_ptr+2, th->stk_ptr+th->stk_len+2);
a6051 11
    gc_mark(th->thread);
    if (th->join) gc_mark(th->join->thread);

    gc_mark(th->scope);
    gc_mark(th->dyna_vars);
    gc_mark(th->errat);
    gc_mark(th->errinfo);
    gc_mark(th->last_line);
    gc_mark(th->last_match);

    /* mark data in copied stack */
d6055 9
a6063 2
	if (frame->argv && !STACK(frame->argv)) {
	    gc_mark_frame(frame);
d6070 1
a6070 3
	if (block->frame.argv && !STACK(block->frame.argv)) {
	    gc_mark_frame(&block->frame);
	}
d6076 1
a6076 1
gc_mark_threads()
d6080 1
d6082 1
a6082 1
	thread_mark(th);
d6092 2
d6097 2
a6098 2
thread_check(data)
    struct RData *data;
d6100 3
a6102 3
    if (TYPE(data) != T_DATA || data->dfree != thread_free) {
	TypeError("wrong argument type %s (expected Thread)",
		  rb_class2name(CLASS_OF(data)));
d6104 1
a6104 1
    return (thread_t)data->data;
a6106 5
VALUE lastline_get();
void lastline_set();
VALUE backref_get();
void backref_set();

d6108 1
a6108 1
thread_save_context(th)
d6113 7
a6119 6
    th->stk_len = stack_length();
    th->stk_pos = (gc_stack_start<(VALUE*)&v)?gc_stack_start
				             :gc_stack_start - th->stk_len;
    if (th->stk_len > th->stk_max)  {
	th->stk_max = th->stk_len;
	REALLOC_N(th->stk_ptr, VALUE, th->stk_max);
d6121 2
a6122 1
    FLUSH_REGISTER_WINDOWS;
d6125 8
a6132 6
    th->frame = the_frame;
    th->scope = the_scope;
    th->class = the_class;
    th->dyna_vars = the_dyna_vars;
    th->block = the_block;
    th->iter = the_iter;
d6134 4
a6137 5
    th->errat = errat;
    th->errinfo = errinfo;
    th->last_status = last_status;
    th->last_line = lastline_get();
    th->last_match = backref_get();
d6141 2
a6142 2
    th->file = sourcefile;
    th->line = sourceline;
d6145 1
a6145 1
static void thread_restore_context();
d6155 1
a6155 1
    thread_restore_context(th, exit);
d6162 10
d6174 1
a6174 1
thread_restore_context(th, exit)
d6182 1
a6182 1
    if (!th->stk_ptr) Bug("unsaved context");
d6184 1
a6184 1
    if (&v < gc_stack_start) {
d6193 9
a6201 6
    the_frame = th->frame;
    the_scope = th->scope;
    the_class = th->class;
    the_dyna_vars = th->dyna_vars;
    the_block = th->block;
    the_iter = th->iter;
d6203 2
a6204 4
    the_class = th->class;
    errat = th->errat;
    errinfo = th->errinfo;
    last_status = th->last_status;
d6208 2
a6209 2
    sourcefile = th->file;
    sourceline = th->line;
d6216 2
a6217 2
    lastline_set(tmp->last_line);
    backref_set(tmp->last_match);
d6220 2
a6221 2
      case 1:
	JUMP_TAG2(TAG_FATAL, INT2FIX(0));
d6224 1
a6224 1
      case 2:
d6228 14
a6241 5
      case 3:
	the_frame->last_func = 0;
	sourcefile = th_raise_file;
	sourceline = th_raise_line;
	f_raise(th_raise_argc, th_raise_argv);
d6244 1
d6251 1
a6251 1
thread_ready(th)
d6269 1
a6269 1
thread_remove()
d6271 1
a6271 1
    thread_ready(curr_thread);
a6274 1
    thread_schedule();
d6278 1
a6278 1
thread_dead(th)
d6284 20
d6305 1
a6305 1
thread_deadlock()
d6307 1
d6310 14
a6323 4
    th_raise_argv[0] = exc_new2(eFatal, "Thread: deadlock");
    th_raise_file = sourcefile;
    th_raise_line = sourceline;
    f_abort();
d6327 1
a6327 1
thread_schedule()
d6329 1
a6329 1
    thread_t next;
d6334 4
a6337 2
    thread_pending = 0;
    if (curr_thread == curr_thread->next) return;
d6346 1
a6346 1
    FOREACH_THREAD_FROM(curr,th) {
d6352 1
a6352 1
    END_FOREACH_FROM(curr,th); 
d6355 2
a6356 4
	curr_thread->file = sourcefile;	
	curr_thread->line = sourceline;	
	FOREACH_THREAD_FROM(curr,th) {
	    if ((th->wait_for & WAIT_JOIN) && thread_dead(th->join)) {
d6364 1
a6364 1
	END_FOREACH_FROM(curr,th);
d6370 1
a6370 1
	double delay, now;
d6378 1
a6378 1
		FOREACH_THREAD_FROM(curr,th) {
d6384 1
a6384 1
		END_FOREACH_FROM(curr,th);
d6390 1
a6390 1
		FOREACH_THREAD_FROM(curr,th) {
d6403 1
a6403 1
		END_FOREACH_FROM(curr,th);
d6420 1
a6420 1
		    delay_tv.tv_usec = (delay - (double)delay_tv.tv_sec) * 1e6;
d6426 9
a6434 2
		    if (trap_pending) rb_trap_exec();
		    goto select_err;
d6439 1
a6439 1
		    FOREACH_THREAD_FROM(curr,th) {
d6451 1
a6451 1
		    END_FOREACH_FROM(curr,th);
d6460 4
a6463 2
	FOREACH_THREAD_FROM(curr,th) {
	    fprintf(stderr, "%s:%d:deadlock 0x%x: %d:%d %s\n", 
d6466 3
d6470 1
a6470 1
	END_FOREACH_FROM(curr,th);
d6472 3
a6474 1
	thread_deadlock();
d6476 1
a6476 1
    if (next == curr_thread) {
d6482 1
a6482 1
	thread_save_context(curr);
d6491 1
a6491 1
	thread_restore_context(next, 1);
d6493 1
a6493 1
    thread_restore_context(next, 0);
d6497 1
a6497 1
thread_wait_fd(fd)
d6506 1
a6506 1
    thread_schedule();
d6509 2
a6510 2
void
thread_fd_writable(fd)
d6516 1
a6516 1
    if (curr_thread == curr_thread->next) return;
d6522 2
a6523 2
	if (select(fd+1, 0, &fds, 0, &zero) == 1) break;
	thread_schedule();
d6528 1
a6528 1
thread_wait_for(time)
d6551 1
a6551 1
		time.tv_usec += 1e6;
d6564 1
a6564 1
    thread_schedule();
d6567 1
a6567 1
void thread_sleep_forever();
d6570 1
a6570 1
thread_alone()
d6576 1
a6576 1
thread_select(max, read, write, except, timeout)
d6588 1
a6588 1
	    thread_sleep_forever();
d6591 1
a6591 1
	thread_wait_for(*timeout);
d6617 1
a6617 1
		    tv.tv_usec = (d - (double)tv.tv_sec) * 1e6;
d6658 1
a6658 1
        thread_schedule();
d6664 1
a6664 2
thread_join(dmy, thread)
    VALUE dmy;
d6667 1
a6667 1
    thread_t th = thread_check(thread);
d6669 22
a6690 8
    if (thread_dead(th)) return thread;
    if ((th->wait_for & WAIT_JOIN) && th->join == curr_thread)
	Raise(eThreadError, "Thread.join: deadlock");
    curr_thread->status = THREAD_STOPPED;
    curr_thread->join = th;
    num_waiting_on_join++;
    curr_thread->wait_for |= WAIT_JOIN;
    thread_schedule();
d6696 10
a6705 1
thread_current()
d6710 2
a6711 2
static VALUE
thread_main()
d6716 2
a6717 2
static VALUE
thread_wakeup(thread)
d6720 1
a6720 1
    thread_t th = thread_check(thread);
d6722 3
a6724 2
    if (th->status == THREAD_KILLED) Raise(eThreadError, "killed thread");
    thread_ready(th);
d6729 2
a6730 2
static VALUE
thread_run(thread)
d6733 2
a6734 2
    thread_wakeup(thread);
    if (!thread_critical) thread_schedule();
d6740 1
a6740 1
thread_kill(thread)
d6743 1
a6743 1
    thread_t th = thread_check(thread);
d6749 1
a6749 1
    thread_ready(th);
d6751 1
a6751 1
    thread_schedule();
d6756 1
a6756 1
thread_s_kill(obj, th)
d6759 1
a6759 1
    return thread_kill(th);
d6763 1
a6763 1
thread_exit()
d6765 1
a6765 1
    return thread_kill(curr_thread->thread);
d6769 1
a6769 1
thread_pass()
d6771 1
a6771 1
    thread_schedule();
d6775 2
a6776 3
static VALUE
thread_stop_method(thread)
    VALUE thread;
d6778 6
a6783 1
    thread_t th = thread_check(thread);
d6785 1
a6785 5
    thread_critical = 0;
    th->status = THREAD_STOPPED;
    thread_schedule();

    return thread;
d6788 1
a6788 6
static VALUE
thread_stop()
{
    thread_stop_method(curr_thread->thread);
    return Qnil;
}
d6791 1
a6791 1
thread_sleep(sec)
d6800 1
a6800 1
    thread_wait_for(time_timeval(INT2FIX(sec)));
d6804 1
a6804 1
thread_sleep_forever()
d6808 1
a6808 1
	sleep((32767<<16)+32767);
d6817 1
a6817 1
    thread_schedule();
d6823 1
a6823 1
thread_s_abort_exc()
d6825 1
a6825 1
    return thread_abort?TRUE:FALSE;
d6829 1
a6829 1
thread_s_abort_exc_set(self, val)
d6837 1
a6837 1
thread_abort_exc(thread)
d6840 1
a6840 1
    thread_t th = thread_check(thread);
d6842 1
a6842 1
    return th->abort?TRUE:FALSE;
d6846 1
a6846 1
thread_abort_exc_set(thread, val)
d6849 1
a6849 1
    thread_t th = thread_check(thread);
d6855 31
d6887 2
a6888 1
thread_alloc()
d6892 2
a6893 31
    th = ALLOC(struct thread);
    th->status = THREAD_RUNNABLE;

    th->status = 0;
    th->result = 0;
    th->errinfo = Qnil;
    th->errat = Qnil;

    th->stk_ptr = 0;
    th->stk_len = 0;
    th->stk_max = 0;
    th->wait_for = 0;
    th->fd = 0;
    th->delay = 0.0;
    th->join = 0;

    th->frame = 0;
    th->scope = 0;
    th->class = 0;
    th->dyna_vars = 0;
    th->block = 0;
    th->iter = 0;
    th->tag = 0;
    th->errat = 0;
    th->errinfo = 0;
    th->last_status = 0;
    th->last_line = 0;
    th->last_match = 0;
    th->abort = 0;

    th->thread = data_object_alloc(cThread, th, 0, thread_free);
d6917 3
a6919 4
    if (!thread_critical) {
	if (trap_immediate) {
	    trap_immediate = 0;
	    thread_schedule();
d6921 1
a6921 1
	else thread_pending = 1;
d6925 33
a6957 1
int thread_tick = THREAD_TICK;
d6960 2
a6961 2
VALUE
thread_create(fn, arg)
d6964 1
d6966 4
a6969 2
    thread_t th = thread_alloc();
    NODE *state;
d6972 1
a6972 5
    static init = 0;

    if (!init) {
	struct itimerval tval;

d6979 2
a6980 6
	tval.it_interval.tv_sec = 0;
	tval.it_interval.tv_usec = 100000;
	tval.it_value = tval.it_interval;
	setitimer(ITIMER_VIRTUAL, &tval, NULL);

	init = 1;
d6984 2
a6985 1
    thread_save_context(curr_thread);
d6987 1
a6987 1
	return th->thread;
d6990 1
a6990 1
    PUSH_TAG();
d6992 1
a6992 1
	thread_save_context(th);
d6999 21
a7019 28
    if (state) {
	if (state->nd_tag == TAG_THROW) {
	    char *mesg;
	    char *tag = rb_id2name(state->nd_tlev);

	    mesg = ALLOCA_N(char, strlen(tag) + 64);

	    sprintf(mesg, "uncaught throw `%s' in thread 0x%x\n",
		    tag, th->thread);
	    curr_thread->errinfo = exc_new2(eThreadError, mesg);
	    curr_thread->errat = make_backtrace();
	}
	else if (th->status != THREAD_TO_KILL && !NIL_P(errinfo)) {
	    if (state->nd_tag == TAG_FATAL ||
		obj_is_kind_of(errinfo, eSystemExit)) {
		/* fatal error or global exit within this thread */
		/* need to stop whole script */
		main_thread->errat = errat;
		main_thread->errinfo = errinfo;
		thread_cleanup();
	    }
	    else if (thread_abort || curr_thread->abort) {
		f_abort();
	    }
	    else {
		curr_thread->errat = errat;
		curr_thread->errinfo = errinfo;
	    }
d7022 16
a7037 2
    thread_remove();
    return 0;
d7040 2
a7041 2
static void
thread_yield(arg, th) 
d7045 2
a7046 2
    scope_dup(the_block->scope);
    rb_yield(th->thread);
d7050 2
a7051 1
thread_start()
d7053 2
a7054 2
    if (!iterator_p()) {
	Raise(eThreadError, "must be called as iterator");
d7056 1
a7056 1
    return thread_create(thread_yield, 0);
d7060 1
a7060 1
thread_value(thread)
d7063 1
a7063 1
    thread_t th = thread_check(thread);
d7065 1
a7065 7
    thread_join(0, thread);
    if (!NIL_P(th->errinfo)) {
	errat = make_backtrace();
	ary_unshift(errat, ary_entry(th->errat, 0));
	sourcefile = 0;		/* kludge to print errat */
	rb_raise(th->errinfo);
    }
d7071 1
a7071 1
thread_status(thread)
d7074 1
a7074 1
    thread_t th = thread_check(thread);
d7076 3
a7078 2
    if (thread_dead(th)) {
	if (NIL_P(th->errinfo)) return FALSE;
d7082 1
a7082 1
    return TRUE;
d7086 1
a7086 1
thread_stopped(thread)
d7089 1
a7089 1
    thread_t th = thread_check(thread);
d7091 3
a7093 3
    if (thread_dead(th)) return TRUE;
    if (th->status == THREAD_STOPPED) return TRUE;
    return FALSE;
d7097 1
a7097 1
thread_wait_other_threads()
d7101 1
a7101 1
	thread_schedule();
d7106 1
a7106 1
thread_cleanup()
d7116 1
a7117 1
	    th->wait_for = 0;
d7123 1
a7123 1
int thread_critical;
d7126 1
a7126 1
thread_get_critical()
d7128 1
a7128 1
    return thread_critical?TRUE:FALSE;
d7132 1
a7132 1
thread_set_critical(obj, val)
d7135 1
a7135 1
    thread_critical = RTEST(val);
d7140 1
a7140 1
thread_interrupt()
d7142 2
a7143 2
    thread_critical = 0;
    thread_ready(main_thread);
d7147 41
a7187 1
    thread_save_context(curr_thread);
d7191 2
d7194 1
a7194 1
    thread_restore_context(curr_thread, 2);
d7198 1
a7198 1
thread_raise(argc, argv, thread)
d7203 1
a7203 1
    thread_t th = thread_check(thread);
d7205 1
a7205 1
    if (thread_dead(th)) return thread;
d7207 1
a7207 1
	f_raise(argc, argv);
d7210 2
a7211 1
    thread_save_context(curr_thread);
d7217 1
a7217 1
    thread_ready(th);
d7221 3
a7223 3
    th_raise_file = sourcefile;
    th_raise_line = sourceline;
    thread_restore_context(curr_thread, 3);
d7227 1
a7227 2
static thread_t loading_thread;
static int loading_nest;
d7230 51
a7280 2
thread_loading(feature)
    char *feature;
d7282 11
a7292 6
    if (curr_thread != curr_thread->next && loading_thread) {
	while (loading_thread != curr_thread) {
	    thread_schedule();
	    CHECK_INTS;
	}
	if (rb_provided(feature)) return TRUE; /* no need to load */
d7294 23
d7318 9
a7326 2
    loading_thread = curr_thread;
    loading_nest++;
d7328 15
a7342 1
    return FALSE;
d7345 5
a7349 2
static void
thread_loading_done()
d7351 12
a7362 2
    if (--loading_nest == 0) {
	loading_thread = 0;
d7364 2
d7371 126
a7496 2
    eThreadError = rb_define_class("ThreadError", eException);
    cThread = rb_define_class("Thread", cObject);
d7498 4
a7501 27
    rb_define_singleton_method(cThread, "new", thread_start, 0);
    rb_define_singleton_method(cThread, "start", thread_start, 0);
    rb_define_singleton_method(cThread, "fork", thread_start, 0);

    rb_define_singleton_method(cThread, "stop", thread_stop, 0);
    rb_define_singleton_method(cThread, "kill", thread_s_kill, 1);
    rb_define_singleton_method(cThread, "exit", thread_exit, 0);
    rb_define_singleton_method(cThread, "pass", thread_pass, 0);
    rb_define_singleton_method(cThread, "join", thread_join, 1);
    rb_define_singleton_method(cThread, "current", thread_current, 0);
    rb_define_singleton_method(cThread, "main", thread_main, 0);

    rb_define_singleton_method(cThread, "critical", thread_get_critical, 0);
    rb_define_singleton_method(cThread, "critical=", thread_set_critical, 1);

    rb_define_singleton_method(cThread, "abort_on_exception", thread_s_abort_exc, 0);
    rb_define_singleton_method(cThread, "abort_on_exception=", thread_s_abort_exc_set, 1);

    rb_define_method(cThread, "run", thread_run, 0);
    rb_define_method(cThread, "wakeup", thread_wakeup, 0);
    rb_define_method(cThread, "stop", thread_stop_method, 0);
    rb_define_method(cThread, "exit", thread_kill, 0);
    rb_define_method(cThread, "value", thread_value, 0);
    rb_define_method(cThread, "status", thread_status, 0);
    rb_define_method(cThread, "alive?", thread_status, 0);
    rb_define_method(cThread, "stop?", thread_stopped, 0);
    rb_define_method(cThread, "raise", thread_raise, -1);
d7503 4
a7506 2
    rb_define_method(cThread, "abort_on_exception", thread_abort_exc, 0);
    rb_define_method(cThread, "abort_on_exception=", thread_abort_exc_set, 1);
d7508 10
a7517 2
    /* allocate main thread */
    main_thread = thread_alloc();
d7519 1
a7519 1
#endif
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d23 3
a25 1
#ifndef HAVE_STRING_H
a28 4
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

a36 1

d38 2
a39 5
static VALUE proc_call _((VALUE,VALUE));
static VALUE f_binding _((VALUE));
static void f_END _((void));

#define SCOPE_PRIVATE  FL_USER4
d48 2
a49 2
    VALUE class;		/* receiver's class */
    VALUE origin;		/* where method defined  */
a67 15
static void
rb_clear_cache_by_id(id)
    ID id;
{
    struct cache_entry *ent, *end;

    ent = cache; end = ent + CACHE_SIZE;
    while (ent < end) {
	if (ent->mid == id) {
	    ent->mid = 0;
	}
	ent++;
    }
}

d70 1
a70 1
    VALUE class;
d77 1
a77 1
    if (NIL_P(class)) class = cObject;
d79 1
a79 15
    st_insert(RCLASS(class)->m_tbl, mid, body);
}

void
rb_remove_method(class, mid)
    VALUE class;
    ID mid;
{
    NODE *body;

    if (!st_delete(RCLASS(class)->m_tbl, &mid, &body)) {
	NameError("method `%s' not defined in %s",
		  rb_id2name(mid), rb_class2name(class));
    }
    rb_clear_cache_by_id(mid);
d84 1
a84 1
    VALUE class, *origin;
d89 2
a90 2
    while (!st_lookup(RCLASS(class)->m_tbl, id, &body)) {
	class = (VALUE)RCLASS(class)->super;
d100 1
a100 1
    VALUE *classp;
d105 1
a105 2
    VALUE class = *classp;
    VALUE origin;
d107 1
d122 1
a122 2
	*classp = body->nd_orig;
	ent->origin = body->nd_orig;
d127 1
a127 2
	*classp = (VALUE)origin;
	ent->origin = origin;
d138 1
a138 1
    VALUE class;
d141 1
a141 1
    VALUE origin;
d159 1
a159 1
	origin = body->nd_orig;
d162 1
a162 1
    st_insert(RCLASS(class)->m_tbl, name,
d168 1
a168 1
    VALUE class;
d181 1
a181 1
		  rb_id2name(name), rb_class2name(class));
d184 1
a184 1
	if (class == (VALUE)origin) {
d188 1
a188 1
	    rb_clear_cache_by_id(name);
d196 1
a196 1
    VALUE class;
d211 1
a211 1
rb_method_boundp(class, id, ex)
d214 1
a214 1
    int ex;
d216 1
a216 1
    if (method_boundp(class, id, ex))
d221 1
a221 1
static ID init, eqq, each, aref, aset, match;
a222 1
extern NODE *eval_tree0;
d247 7
a253 7
    struct FRAME *_frame = ALLOCA_N(struct FRAME,1);\
    _frame->prev = the_frame;		\
    _frame->file = sourcefile;		\
    _frame->line = sourceline;		\
    _frame->iter = the_iter->iter;	\
    _frame->cbase = the_frame->cbase;	\
    the_frame = _frame;		\
d255 1
a255 1
#define POP_FRAME()  the_frame = _frame->prev; }
d263 2
a264 2
    VALUE class;
    struct tag *tag;
d274 14
a287 14
    struct BLOCK *_block = ALLOCA_N(struct BLOCK,1);\
    _block->tag = prot_tag;		\
    _block->var = v;			\
    _block->body = b;			\
    _block->self = self;		\
    _block->frame = *the_frame;		\
    _block->class = the_class;		\
    _block->frame.file = sourcefile;	\
    _block->frame.line = sourceline;	\
    _block->scope = the_scope;		\
    _block->d_vars = the_dyna_vars;	\
    _block->prev = the_block;		\
    _block->iter = the_iter->iter;	\
    the_block = _block;
d290 4
a293 4
    struct BLOCK *_block = ALLOCA_N(struct BLOCK,1);\
    *_block = *b;			\
    _block->prev = the_block;		\
    the_block = _block;
a380 12
#ifdef C_ALLOCA
/* need to protect retval in struct tag from GC. */
#define tag_retval_dcl VALUE *dd_retval
#define tag_retval_init VALUE _tag_retval = Qnil;\
    _tag->dd_retval = &_tag_retval;
#define tag_retval dd_retval[0]
#else
#define tag_retval_dcl VALUE retval
#define tag_retval_init _tag->retval = Qnil
#define tag_retval retval
#endif

a384 3
    ID tag;
    tag_retval_dcl;
    ID dst;
d388 6
a393 14
#define PUSH_TAG(ptag) {		\
    struct tag *_tag = ALLOCA_N(struct tag,1);\
    tag_retval_init;			\
    _tag->frame = the_frame;		\
    _tag->iter = the_iter;		\
    _tag->prev = prot_tag;		\
    _tag->tag_retval = Qnil;		\
    _tag->tag = ptag;			\
    _tag->dst = 0;			\
    prot_tag = _tag;

#define PROT_NONE   0
#define PROT_FUNC   -1
#define PROT_THREAD -2
d395 1
a395 1
#define EXEC_TAG()    setjmp(prot_tag->buf)
d400 1
a400 1
    longjmp(prot_tag->buf,(st));	\
d403 5
d409 1
a409 1
    prot_tag = _tag->prev;		\
a419 1
#define TAG_MASK	0xf
d421 3
a423 1
VALUE the_class;
d425 2
a426 2
#define PUSH_CLASS() {		\
    VALUE _class = the_class;	\
d584 9
a592 1
	VALUE epath;
d594 1
a594 2
	epath = rb_class_path(eclass);
	if (RSTRING(errinfo)->len == 0) {
d596 3
a598 1
	    fwrite(RSTRING(epath)->ptr, 1, RSTRING(epath)->len, stderr);
a600 21
	else {
	    unsigned char *tail  = 0;
	    int len = RSTRING(errinfo)->len;

	    if (RSTRING(epath)->ptr[0] == '#') epath = 0;
	    if (tail = strchr(RSTRING(errinfo)->ptr, '\n')) {
		len = tail - RSTRING(errinfo)->ptr;
		tail++;		/* skip newline */
	    }
	    fprintf(stderr, ": ");
	    fwrite(RSTRING(errinfo)->ptr, 1, len, stderr);
	    if (epath) {
		fprintf(stderr, " (");
		fwrite(RSTRING(epath)->ptr, 1, RSTRING(epath)->len, stderr);
		fprintf(stderr, ")\n");
	    }
	    if (tail) {
		fwrite(tail, 1, RSTRING(errinfo)->len-len-1, stderr);
		putc('\n', stderr);
	    }
	}
a610 1
	ep = RARRAY(errat);
a626 6
void rb_call_inits _((void));
void init_stack _((void));
void init_heap _((void));
void Init_ext _((void));
void gc_call_finalizer_at_exit _((void));

d632 1
a632 1
    int state;
a643 2
    /* default visibility is private at toplevel */
    FL_SET(top_scope, SCOPE_PRIVATE);
d645 1
a645 1
    PUSH_TAG(PROT_NONE)
d648 1
a648 1
	the_class = cObject;
d666 1
a666 1
    int state;
d668 1
a668 1
    PUSH_TAG(PROT_NONE)
d672 2
a675 3
	eval_tree = 0;
	Init_ext();
	ext_init = 1;
a692 6
    if (eval_tree0) {
	tree = eval_tree0;
	eval_tree0 = 0;
	rb_eval(self, tree);
    }

a711 2
static void exec_end_proc();

d715 2
a716 2
    int state;
    static int ex;
d723 1
a723 1
    PUSH_TAG(PROT_NONE);
d733 1
a733 1
    PUSH_TAG(PROT_NONE);
a740 2
	exec_end_proc();
	gc_call_finalizer_at_exit();
d748 1
a748 2
    switch (ex & 0xf) {
      case 0:
d750 1
d752 2
d764 1
d788 5
d794 1
a794 1
	Bug("Unknown longjmp status %d", ex);
d807 3
a809 6
    errinfo = exc_new2(eSyntaxError, "compile error");
    if (at) {
	str_cat(errinfo, " in ", 4);
	str_cat(errinfo, at, strlen(at));
    }
    str_cat(errinfo, "\n", 1);
d832 1
a832 1
    int state;
d837 4
a840 4
	Check_Type(arg, T_ARRAY);
	rb_funcall2(cmd, rb_intern("call"),
		    RARRAY(arg)->len, RARRAY(arg)->ptr);
	return;
d844 1
a844 1
    PUSH_TAG(PROT_NONE);
d848 1
a848 1
    the_class = cObject;
d862 2
a863 3
    switch (state) {
      case 0:
	break;
d890 1
a890 1
    int state;
d892 1
a892 1
    PUSH_TAG(PROT_NONE);
d908 2
a909 2
    VALUE val = 0;		/* OK */
    int state;
d911 1
a911 1
    PUSH_TAG(PROT_NONE);
d916 11
a926 9
    if (state == TAG_RAISE) {
      superclass_error:
	switch (nd_type(node)) {
	  case NODE_COLON2:
	    TypeError("undefined superclass `%s'", rb_id2name(node->nd_mid));
	  case NODE_CVAR:
	    TypeError("undefined superclass `%s'", rb_id2name(node->nd_vid));
	  default:
	    TypeError("superclass undefined");
a976 58
static VALUE
mod_nesting()
{
    NODE *cbase = (NODE*)the_frame->cbase;
    VALUE ary = ary_new();

    while (cbase && cbase->nd_clss != cObject) {
	ary_push(ary, cbase->nd_clss);
	cbase = cbase->nd_next;
    }
    return ary;
}

static VALUE
mod_s_constants()
{
    NODE *cbase = (NODE*)the_frame->cbase;
    VALUE ary = ary_new();

    while (cbase && cbase->nd_clss != cObject) {
	mod_const_at(cbase->nd_clss, ary);
	cbase = cbase->nd_next;
    }

    mod_const_of(((NODE*)the_frame->cbase)->nd_clss, ary);
    return ary;
}

static VALUE
mod_remove_method(mod, name)
    VALUE mod, name;
{
    rb_remove_method(mod, rb_to_id(name));
    return mod;
}

static VALUE
mod_undef_method(mod, name)
    VALUE mod, name;
{
    ID id = rb_to_id(name);

    rb_add_method(mod, id, 0, NOEX_PUBLIC);
    rb_clear_cache_by_id(id);
    return mod;
}

static VALUE
mod_alias_method(mod, new, old)
    VALUE mod, new, old;
{
    ID id = rb_to_id(new);

    rb_alias(mod, id, rb_to_id(old));
    rb_clear_cache_by_id(id);
    return mod;
}

d986 1
a986 1
	    char *file = sourcefile;\
a987 1
            int i;\
d994 1
a994 1
	    sourcefile = file;\
a1003 1
	char *file = sourcefile;\
d1006 1
a1006 1
	    args = rb_Array(args);\
d1010 1
a1010 1
	sourcefile = file;\
d1015 7
a1023 29
static char* is_defined _((VALUE, NODE*, char*));

static char*
arg_defined(self, node, buf, type)
    VALUE self;
    NODE *node;
    char *buf;
    char *type;
{
    int argc;
    int i;

    if (!node) return type;	/* no args */
    if (nd_type(node) == NODE_ARRAY) {
	argc=node->nd_alen;
        if (argc > 0) {
	    for (i=0;i<argc;i++) {
		if (!is_defined(self, node->nd_head, buf))
		    return 0;
		node = node->nd_next;
	    }
        }
    }
    else if (!is_defined(self, node, buf)) {
	return 0;
    }
    return type;
}
    
d1031 3
a1033 1
    int state;
d1039 1
a1039 1
	else if (method_boundp(RCLASS(the_frame->last_class)->super,
a1040 3
	    if (nd_type(node) == NODE_SUPER) {
		return arg_defined(self, node->nd_args, buf, "super");
	    }
d1051 1
a1051 2
	if (!is_defined(self, node->nd_recv, buf)) return 0;
	PUSH_TAG(PROT_NONE);
d1061 3
a1063 2
	if (method_boundp(val, node->nd_mid, nd_type(node)== NODE_CALL)) {
	    return arg_defined(self, node->nd_args, buf, "method");
a1066 4
      case NODE_MATCH2:
      case NODE_MATCH3:
	return "method";

a1078 6
      case NODE_TRUE:
	return "true";

      case NODE_FALSE:
	return "false";

d1113 1
a1113 1
	PUSH_TAG(PROT_NONE);
d1146 1
a1146 1
	PUSH_TAG(PROT_NONE);
d1166 2
a1167 1
    VALUE obj, trace;
d1173 1
a1173 1
    if (TYPE(trace) != T_DATA || RDATA(trace)->dfree != blk_free) {
d1176 1
a1176 1
    return trace_func = trace;
d1187 1
a1187 1
    int state;
d1201 1
a1201 1
    *the_frame = *_frame->prev;
d1206 1
a1206 1
    PUSH_TAG(PROT_NONE);
a1223 1
static void return_value _((VALUE val));
d1229 1
a1229 1
    int state;
d1237 4
a1248 6
      case NODE_POSTEXE:
	f_END();
	nd_set_type(node, NODE_NIL); /* exec just once */
	result = Qnil;
	break;

a1258 20
	/* nodes for speed-up(literal match) */
      case NODE_MATCH2:
	result = reg_match(rb_eval(self,node->nd_recv),
			   rb_eval(self,node->nd_value));
	break;

	/* nodes for speed-up(literal match) */
      case NODE_MATCH3:
        {
	    VALUE r = rb_eval(self,node->nd_recv);
	    VALUE l = rb_eval(self,node->nd_value);
	    if (TYPE(r) == T_STRING) {
		result = reg_match(l, r);
	    }
	    else {
		result = rb_funcall(r, match, 1, l);
	    }
	}
	break;

a1271 6
      case NODE_TRUE:
	RETURN(TRUE);

      case NODE_FALSE:
	RETURN(FALSE);

a1272 1
	sourceline = nd_line(node);
d1296 1
a1296 1
			call_trace_func("line", tag->nd_file, nd_line(tag),
a1298 1
		    sourceline = nd_line(tag);
d1311 2
a1312 4
	PUSH_TAG(PROT_NONE);
	switch (state = EXEC_TAG()) {
	  case 0:
	    sourceline = nd_line(node);
d1321 14
a1334 12
	    break;

	  case TAG_REDO:
	    state = 0;
	    goto while_redo;
	  case TAG_NEXT:
	    state = 0;
	    goto while_next;
	  case TAG_BREAK:
	    state = 0;
	  default:
	    break;
d1344 2
a1345 3
	PUSH_TAG(PROT_NONE);
	switch (state = EXEC_TAG()) {
	  case 0:
d1354 14
a1367 12
	    break;

	  case TAG_REDO:
	    state = 0;
	    goto until_redo;
	  case TAG_NEXT:
	    state = 0;
	    goto until_next;
	  case TAG_BREAK:
	    state = 0;
	  default:
	    break;
d1379 2
d1383 1
a1383 1
	    PUSH_TAG(PROT_FUNC);
a1393 1
		    char *file = sourcefile;
d1398 1
a1398 1
		    sourcefile = file;
a1403 6
	    else if (the_block->tag->dst == state) {
		state &= TAG_MASK;
		if (state == TAG_RETURN) {
		    result = prot_tag->tag_retval;
		}
	    }
d1405 1
d1407 2
a1408 4
	    switch (state) {
	      case 0:
		break;

d1412 4
a1415 1
	      case TAG_BREAK:
d1418 4
a1421 2
	      case TAG_RETURN:
		return_value(result);
a1428 16
      case NODE_BREAK:
	JUMP_TAG(TAG_BREAK);
	break;

      case NODE_NEXT:
	JUMP_TAG(TAG_NEXT);
	break;

      case NODE_REDO:
	JUMP_TAG(TAG_REDO);
	break;

      case NODE_RETRY:
	JUMP_TAG(TAG_RETRY);
	break;

d1438 1
a1438 1
	    PUSH_TAG(PROT_NONE);
d1443 5
a1447 15
	    if (state == TAG_RAISE) {
		NODE * volatile resq = node->nd_resq;
		while (resq) {
		    if (handle_rescue(self, resq)) {
			state = 0;
			PUSH_TAG(PROT_NONE);
			if ((state = EXEC_TAG()) == 0) {
			    result = rb_eval(self, resq->nd_body);
			}
			POP_TAG();
			if (state == 0) {
			    errinfo = e_info;
			    errat = e_at;
			}
			else if (state == TAG_RETRY) {
d1449 14
a1462 1
			    goto retry_entry;
d1464 1
a1464 1
			break;
d1466 3
a1468 1
		    resq = resq->nd_head; /* next rescue */
a1470 3
	    if (state) {
		JUMP_TAG(state);
	    }
d1475 1
a1475 1
	PUSH_TAG(PROT_NONE);
d1542 1
a1542 4
	if (node->nd_stts) {
	    return_value(rb_eval(self, node->nd_stts));
	}
	JUMP_TAG(TAG_RETURN);
d1589 1
a1589 1
	    result = rb_call(RCLASS(the_frame->last_class)->super, self,
d1600 1
a1600 1
	    PUSH_TAG(PROT_NONE);
d1697 1
a1697 2
	    if (RTEST(verbose) &&
		ev_const_defined(the_frame->cbase, node->nd_vid)) {
a1828 1
			eval_tree = 0;
d1887 1
a1887 1
		    Warning("discarding old %s", rb_id2name(node->nd_mid));
d1889 1
a1889 1
		rb_clear_cache_by_id(node->nd_mid);
d1892 3
a1894 6
	    if (FL_TEST(the_scope,SCOPE_PRIVATE)) {
		noex = NOEX_PRIVATE;
	    }
	    else {
		noex = NOEX_PUBLIC;
	    }
a1895 9
	    if (FL_TEST(the_class, FL_SINGLETON)) {
		VALUE recv = rb_iv_get(the_class, "__attached__");
		rb_funcall(recv, rb_intern("singleton_method_added"),
			   1, INT2FIX(node->nd_mid));
	    }
	    else {
		rb_funcall(the_class, rb_intern("method_added"),
			   1, INT2FIX(node->nd_mid));
	    }
d1923 1
a1923 2
	    rb_clear_cache_by_id(node->nd_mid);
	    rb_add_method(class, node->nd_mid, node->nd_defn, NOEX_PUBLIC);
d1926 1
d1933 1
a1933 1
	    VALUE origin;
d1941 1
a1941 1
	    rb_clear_cache_by_id(node->nd_mid);
a1948 2
	rb_funcall(the_class, rb_intern("method_added"),
		   1, INT2FIX(node->nd_mid));
d1959 2
a1960 1
	    VALUE super, class, tmp;
d1985 1
a1985 1
		    if (tmp != super) {
d1994 1
d2003 1
a2003 1
	    return module_setup(class, node->nd_body);
d2022 1
a2049 1
		class = rb_singleton_class(class);
d2051 1
d2060 1
a2060 1
	    char *desc = is_defined(self, node->nd_head, buf);
d2068 1
a2068 1
	sourcefile = node->nd_file;
d2090 1
a2090 1
    int state;
a2092 2
    char *file = sourcefile;
    int line = sourceline;
d2099 1
a2099 1
    the_class = module;
d2115 1
a2115 1
    PUSH_TAG(PROT_NONE);
d2118 1
a2118 1
	    call_trace_func("class", file, line,
a2125 1

d2128 2
a2129 1
	call_trace_func("end", file, line, 0, the_frame->last_func);
d2216 1
a2216 1
rb_iter_break()
d2218 1
a2218 1
    JUMP_TAG(TAG_BREAK);
d2221 11
a2231 3
#ifdef __GNUC__
static volatile voidfn rb_longjmp;
#endif
d2233 5
a2237 1
static VALUE make_backtrace();
d2240 1
a2240 2
check_errat(val)
    VALUE val;
d2242 2
a2243 2
    int i;
    static char *err = "value of $@@ must be Array of String";
d2245 3
a2247 2
    if (!NIL_P(val)) {
	int t = TYPE(val);
d2249 1
a2249 12
	if (t == T_STRING) return ary_new3(1, val);
	if (t != T_ARRAY) {
	    TypeError(err);
	}
	for (i=0;i<RARRAY(val)->len;i++) {
	    if (TYPE(RARRAY(val)->ptr[i]) != T_STRING) {
		TypeError(err);
	    }
	}
    }
    return val;
}
d2252 1
a2252 1
rb_longjmp(tag, mesg, at)
d2254 1
a2254 1
    VALUE mesg, at;
d2260 1
a2260 4
    if (!NIL_P(at)) {
	errat = check_errat(at);
    }
    else if (sourcefile && (NIL_P(errat) || !NIL_P(mesg))) {
d2274 1
a2274 1
    JUMP_TAG(tag);
d2281 1
a2281 1
    rb_longjmp(TAG_RAISE, mesg, Qnil);
d2288 1
a2288 1
    rb_longjmp(TAG_FATAL, mesg, Qnil);
d2302 1
a2302 1
    VALUE arg1, arg2, arg3;
d2308 1
a2308 1
    switch (n = rb_scan_args(argc, argv, "03", &arg1, &arg2, &arg3)) {
a2312 1
      case 3:
d2320 1
a2320 1
	mesg = arg2;
d2332 2
a2333 2
    *the_frame = *_frame->prev->prev;
    rb_longjmp(TAG_RAISE, mesg, arg3);
d2357 1
a2361 2
    int state;
    static USHORT serial = 1;
d2387 1
a2387 1
    PUSH_TAG(PROT_NONE);
d2394 1
a2394 1
	    result = (*node->nd_cfnc)(val, node->nd_tval, self);
d2401 1
a2401 1
	switch (state) {
d2411 2
a2412 3
	    state |= (serial++ << 8);
	    state |= 0x10;
	    block->tag->dst = state; 
d2455 1
a2455 1
	    val = rb_Array(val);
d2538 1
a2538 1
    VALUE data1, data2;
d2540 1
a2540 1
    int state;
d2544 1
d2549 1
a2549 1
    PUSH_TAG(PROT_NONE);
a2554 6
    if (the_block->tag->dst == state) {
	state &= TAG_MASK;
	if (state == TAG_RETURN) {
	    retval = prot_tag->tag_retval;
	}
    }
d2556 2
d2561 4
a2564 3
    switch (state) {
      case 0:
	break;
d2566 6
a2571 2
      case TAG_RETRY:
	goto iter_retry;
d2573 8
a2580 9
      case TAG_BREAK:
	retval = Qnil;
	break;

      case TAG_RETURN:
	return_value(retval);
	/* fall through */
      default:
	JUMP_TAG(state);
d2612 1
a2612 1
    VALUE data1, data2;
d2614 1
a2614 1
    int state;
d2617 1
a2617 1
    PUSH_TAG(PROT_NONE);
d2622 12
a2633 5
    else if (state == TAG_RAISE && obj_is_kind_of(errinfo, eException)) {
	if (r_proc) {
	    PUSH_TAG(PROT_NONE);
	    if ((state = EXEC_TAG()) == 0) {
		result = (*r_proc)(data2, errinfo);
d2635 2
a2636 2
	    POP_TAG();
	    if (state == TAG_RETRY) {
a2637 1
		goto retry_entry;
d2639 3
a2641 7
	}
	else {
	    result = Qnil;
	    state = 0;
	}
	if (state == 0) {
	    errat = Qnil;
d2652 2
a2653 3
    VALUE (*b_proc)();
    void (*e_proc)();
    VALUE data1, data2;
d2655 1
a2655 1
    int state;
d2658 1
a2658 1
    PUSH_TAG(PROT_NONE);
d2709 1
a2709 1
	    format = "private method `%s' called for %s";
d2712 1
a2712 1
	    format = "undefined iterator `%s' for %s";
d2718 1
a2718 1
		format = "undefined local variable or method `%s' for %s";
d2722 1
a2722 1
	    format = "undefined method `%s' for %s";
d2732 1
a2732 1
    *the_frame = *_frame->prev->prev;
d2736 2
a2737 1
	      desc?(char*)RSTRING(desc)->ptr:"");
d2788 2
a2789 1
    VALUE class, recv;
d2809 1
a2809 1
	id    = ent->mid0;
d2836 1
a2836 1
	if (RCLASS(class)->super == 0) {
d2838 1
a2838 1
	    struct RClass *cl = RCLASS(class);
d2840 1
a2840 1
	    class = RBASIC(recv)->class;
d2842 1
a2842 1
		if (RCLASS(class)->m_tbl == cl->m_tbl)
d2844 1
a2844 1
		class = RCLASS(class)->super;
d2848 1
a2848 1
	    class = RCLASS(class)->super;
d2984 2
a2985 2
	    int state;
	    VALUE *local_vars;	/* OK */
d3003 1
a3003 1
	    PUSH_TAG(PROT_FUNC);
d3061 1
a3061 1
		    call_trace_func("call", b2->nd_file, nd_line(b2),
a3065 4
	    else if (state == TAG_RETURN) {
		result = prot_tag->tag_retval;
		state = 0;
	    }
d3078 20
a3097 16
	    switch (state) {
	      case 0:
		break;

	      case TAG_NEXT:
		Raise(eLocalJumpError, "unexpected next");
		break;
	      case TAG_BREAK:
		Raise(eLocalJumpError, "unexpected break");
		break;
	      case TAG_REDO:
		Raise(eLocalJumpError, "unexpected redo");
		break;
	      case TAG_RETRY:
		if (!iterator_p()) {
		    Raise(eLocalJumpError, "retry outside of rescue clause");
a3098 2
	      default:
		JUMP_TAG(state);
d3110 1
a3111 1
    VALUE args;
d3277 1
a3277 1
    VALUE src;
d3283 1
a3283 1
    node = compile_string(sourcefile, RSTRING(src)->ptr, RSTRING(src)->len);
d3291 3
a3293 1
    VALUE self, src, scope;
d3297 4
a3300 3
    struct SCOPE * volatile old_scope;
    struct BLOCK * volatile old_block;
    struct RVarmap * volatile old_d_vars;
a3304 1
    int state;
d3307 1
a3307 1
	if (TYPE(scope) != T_DATA || RDATA(scope)->dfree != blk_free) {
d3318 1
a3318 1
	old_scope = the_scope;
d3320 1
a3320 1
	old_block = the_block;
d3322 1
a3322 1
	old_d_vars = the_dyna_vars;
d3334 1
a3334 1
    the_class = ((NODE*)the_frame->cbase)->nd_clss;
d3338 1
a3338 1
	the_class = RBASIC(the_class)->class;
d3340 1
a3340 1
    PUSH_TAG(PROT_NONE);
a3341 1
	eval_tree = 0;
d3344 1
a3344 1
	    compile_error(0);
d3353 3
a3355 3
	the_scope = old_scope;
	the_block = old_block;
	the_dyna_vars = old_d_vars;
d3361 1
a3361 1
	VALUE err;
d3363 2
a3364 1
	if (state == TAG_RAISE) {
d3368 1
a3368 1
		err = str_dup(errinfo);
a3398 42
static VALUE
eval_under(under, self, src)
    VALUE under, self, src;
{
    VALUE val;			/* OK */
    int state;
    VALUE cbase = the_frame->cbase;

    PUSH_CLASS();
    the_class = under;
    PUSH_FRAME();
    the_frame->last_func = _frame->last_func;
    the_frame->last_class = _frame->last_class;
    the_frame->argc = 1;
    the_frame->argv = &src;
    the_frame->cbase = (VALUE)node_newnode(NODE_CREF,under,0,cbase);
    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	val = eval(self, src, Qnil);
    }
    POP_TAG();
    POP_FRAME();
    POP_CLASS();
    if (state) JUMP_TAG(state);

    return val;
}

static VALUE
obj_instance_eval(self, src)
    VALUE self, src;
{
    return eval_under(CLASS_OF(self), self, src);
}

static VALUE
mod_module_eval(mod, src)
    VALUE mod, src;
{
    return eval_under(mod, mod, src);
}

d3441 2
a3442 1
    VALUE obj, fname;
d3444 1
a3444 1
    int state;
d3449 2
a3450 2
    if (RSTRING(fname)->ptr[0] == '~') {
	fname = file_s_expand_path(0, fname);
d3452 2
a3453 2
    file = find_file(RSTRING(fname)->ptr);
    if (!file) LoadError("No such file to load -- %s", RSTRING(fname)->ptr);
d3455 1
a3455 1
    PUSH_TAG(PROT_NONE);
d3457 1
a3457 1
    the_class = cObject;
a3468 2
    /* default visibility is private at loading toplevel */
    FL_SET(the_scope, SCOPE_PRIVATE);
d3549 2
a3550 1
    VALUE obj, fname;
d3552 2
a3553 2
    char *ext, *file, *feature, *buf; /* OK */
    VALUE load;
d3556 1
a3556 1
    if (rb_provided(RSTRING(fname)->ptr))
d3559 1
a3559 1
    ext = strrchr(RSTRING(fname)->ptr, '.');
d3562 1
a3562 1
	    feature = file = RSTRING(fname)->ptr;
d3567 1
a3567 1
	    file = feature = RSTRING(fname)->ptr;
d3569 1
a3569 1
		buf = ALLOCA_N(char, strlen(file)+sizeof(DLEXT)+1);
d3578 1
a3578 1
	    feature = RSTRING(fname)->ptr;
d3583 2
a3584 2
    buf = ALLOCA_N(char, strlen(RSTRING(fname)->ptr) + 5);
    sprintf(buf, "%s.rb", RSTRING(fname)->ptr);
d3587 1
a3587 1
	fname = str_new2(file);
d3591 1
a3591 1
    sprintf(buf, "%s%s", RSTRING(fname)->ptr, DLEXT);
d3597 1
a3597 1
    LoadError("No such file to load -- %s", RSTRING(fname)->ptr);
d3603 2
a3604 2
	int state;
	PUSH_TAG(PROT_NONE);
d3624 2
a3625 2
	int state;
	PUSH_TAG(PROT_NONE);
d3660 1
a3660 6
    if (argc == 0) {
	FL_UNSET(the_scope, SCOPE_PRIVATE);
    }
    else {
	set_method_visibility(module, argc, argv, NOEX_PUBLIC);
    }
d3670 1
a3670 6
    if (argc == 0) {
	FL_SET(the_scope, SCOPE_PRIVATE);
    }
    else {
	set_method_visibility(module, argc, argv, NOEX_PRIVATE);
    }
a3694 16
top_public(argc, argv)
    int argc;
    VALUE *argv;
{
    return mod_public(argc, argv, cObject);
}

static VALUE
top_private(argc, argv)
    int argc;
    VALUE *argv;
{
    return mod_private(argc, argv, cObject);
}

static VALUE
a3718 17
mod_append_features(module, include)
    VALUE module, include;
{
    switch (TYPE(include)) {
      case T_CLASS:
      case T_MODULE:
	break;
      default:
	Check_Type(include, T_CLASS);
	break;
    }
    rb_include_module(include, module);

    return module;
}

static VALUE
d3728 1
a3728 1
	rb_funcall(argv[i], rb_intern("append_features"), 1, module);
d3734 19
d3820 2
a3821 2
    *var = check_errat(val);
}
d3823 11
a3833 22
VALUE f_global_variables();
static VALUE f_catch();
static VALUE f_throw();

struct end_proc_data {
    void (*func)();
    VALUE data;
    struct end_proc_data *next;
} *end_proc_data;

void
rb_set_end_proc(func, data)
    void (*func)();
    VALUE data;
{
    struct end_proc_data *link = ALLOC(struct end_proc_data);

    link->next = end_proc_data;
    link->func = func;
    link->data = data;
    rb_global_variable(&link->data);
    end_proc_data = link;
d3836 3
a3838 3
static void
call_end_proc(data)
    VALUE data;
d3840 3
a3842 2
    proc_call(data, Qnil);
}
d3844 13
a3856 6
static void
f_END()
{
    PUSH_FRAME();
    rb_set_end_proc(call_end_proc, f_lambda());
    POP_FRAME();
d3860 3
a3862 1
f_at_exit()
d3864 2
a3865 1
    VALUE proc;
d3867 4
a3870 15
    proc = f_lambda();

    rb_set_end_proc(call_end_proc, proc);
    return proc;
}

static void
exec_end_proc()
{
    struct end_proc_data *link = end_proc_data;

    while (link) {
	(*link->func)(link->data);
	link = link->next;
    }
a3881 1
    match = rb_intern("=~");
d3883 3
a3885 4
    rb_global_variable((VALUE*)&top_scope);
    rb_global_variable((VALUE*)&eval_tree0);
    rb_global_variable((VALUE*)&eval_tree);
    rb_global_variable((VALUE*)&the_dyna_vars);
d3897 9
a3913 2
    rb_define_global_function("at_exit", f_at_exit, 0);

a3915 1
    rb_define_global_function("global_variables", f_global_variables, 0);
a3917 1
    rb_define_method(mKernel, "instance_eval", obj_instance_eval, 1);
a3918 2
    rb_define_private_method(cModule, "append_features", mod_append_features, 1);
    rb_define_private_method(cModule, "extend_object", mod_extend_object, 1);
d3924 1
a3926 12
    rb_define_method(cModule, "module_eval", mod_module_eval, 1);

    rb_define_method(cModule, "remove_method", mod_remove_method, -1);
    rb_define_method(cModule, "undef_method", mod_undef_method, 1);
    rb_define_method(cModule, "alias_method", mod_alias_method, 2);

    rb_define_singleton_method(cModule, "nesting", mod_nesting, 0);
    rb_define_singleton_method(cModule, "constants", mod_s_constants, 0);

    rb_define_singleton_method(TopSelf, "include", top_include, -1);
    rb_define_singleton_method(TopSelf, "public", top_public, -1);
    rb_define_singleton_method(TopSelf, "private", top_private, -1);
d3928 1
d4030 1
a4030 1
    volatile VALUE proc;
d4074 1
a4074 1
    VALUE proc, args;		/* OK */
d4078 2
a4079 1
    int state;
d4086 1
a4086 1
	    args = Qnil;
d4135 1
a4135 1
    PUSH_TAG(PROT_NONE);
d4143 1
a4143 3
    if (the_block->tag->dst == state) {
	state &= TAG_MASK;
    }
d4149 5
a4153 3
	    switch (state) {
	      case TAG_BREAK:
		Raise(eLocalJumpError, "break from proc-closure");
d4158 4
a4161 2
	      case TAG_RETURN:
		Raise(eLocalJumpError, "return from proc-closure");
d4165 3
d4244 1
a4248 1
    VALUE class;
d4361 1
a4361 1
    VALUE data;
d4363 1
a4363 1
    if (TYPE(data) != T_DATA || RDATA(data)->dfree != thread_free) {
d4367 1
a4367 1
    return (thread_t)RDATA(data)->data;
d4475 1
a4475 1
	JUMP_TAG(TAG_FATAL);
d4543 1
a4543 1
    thread_t next;		/* OK */
d4567 2
d4584 1
a4584 1
	double delay, now;	/* OK */
a4666 2
	curr_thread->file = sourcefile;
	curr_thread->line = sourceline;
a4971 2
struct timeval time_timeval();

d5114 1
a5114 1
    int state;
d5142 1
a5142 1
    PUSH_TAG(PROT_THREAD);
d5151 28
a5178 14
    if (state && th->status != THREAD_TO_KILL && !NIL_P(errinfo)) {
	if (state == TAG_FATAL || obj_is_kind_of(errinfo, eSystemExit)) {
	    /* fatal error or global exit within this thread */
	    /* need to stop whole script */
	    main_thread->errat = errat;
	    main_thread->errinfo = errinfo;
	    thread_cleanup();
	}
	else if (thread_abort || curr_thread->abort || RTEST(debug)) {
	    f_abort();
	}
	else {
	    curr_thread->errat = errat;
	    curr_thread->errinfo = errinfo;
d5185 1
a5185 1
static VALUE
a5191 1
    return th->thread;
a5402 80

static VALUE
f_catch(dmy, tag)
    VALUE dmy, tag;
{
    int state;
    ID t;
    VALUE val;			/* OK */

    t = rb_to_id(tag);
    PUSH_TAG(t);
    if ((state = EXEC_TAG()) == 0) {
	val = rb_yield(tag);
    }
    else if (state == TAG_THROW && prot_tag->tag == prot_tag->dst) {
	val = prot_tag->tag_retval;
	state = 0;
    }
    POP_TAG();
    if (state) JUMP_TAG(state);

    return val;
}

static VALUE
f_throw(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE tag, value;
    ID t;
    struct tag *tt = prot_tag;

    rb_scan_args(argc, argv, "11", &tag, &value);
    t = rb_to_id(tag);

    while (tt) {
	if (tt->tag == t) {
	    tt->dst = t;
	    tt->tag_retval = value;
	    break;
	}
#ifdef THREAD
	if (tt->tag == PROT_THREAD) {
	    Raise(eThreadError, "uncaught throw `%s' in thread 0x%x\n",
		  rb_id2name(t),
		  curr_thread);
	}
#endif
	tt = tt->prev;
    }

    if (!tt) {
	NameError("uncaught throw `%s'\n", rb_id2name(t));
    }
    JUMP_TAG(TAG_THROW);
    /* not reached */
}

static void
return_value(val)
    VALUE val;
{
    struct tag *tt = prot_tag;
	    
    while (tt) {
	if (tt->tag == PROT_FUNC) {
	    tt->tag_retval = val;
	    break;
	}
#ifdef THREAD
	if (tt->tag == PROT_THREAD) {
	    Raise(eThreadError, "return from within thread 0x%x\n",
		  curr_thread);
	}
#endif
	tt = tt->prev;
    }
}

@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d6 1
a6 1
  $Date: 1998/12/22 09:01:48 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
d16 1
a16 1
#include "rubysig.h"
d24 1
a24 1
char *strrchr _((char*,char));
a30 10
#ifdef __BEOS__
#include <net/socket.h>
#endif

#ifdef USE_CWGUSI
#include <sys/stat.h>
#include <sys/errno.h>
#include <compat.h>
#endif

d38 3
a40 2
VALUE rb_cProc;
static VALUE rb_cBinding;
d42 8
a49 19
static VALUE rb_f_binding _((VALUE));
static void rb_f_END _((void));
static VALUE rb_f_iterator_p _((void));
static VALUE block_pass _((VALUE,NODE*));
static VALUE rb_cMethod;
static VALUE method_proc _((VALUE));

static int scope_vmode;
#define SCOPE_PUBLIC    0
#define SCOPE_PRIVATE   1
#define SCOPE_PROTECTED 2
#define SCOPE_MODFUNC   5
#define SCOPE_MASK      7
#define SCOPE_SET(f)  do {scope_vmode=(f);} while(0)
#define SCOPE_TEST(f) (scope_vmode&(f))

#define CACHE_SIZE 0x800
#define CACHE_MASK 0x7ff
#define EXPR1(c,m) ((((c)>>3)^(m))&CACHE_MASK)
d54 1
a54 1
    VALUE klass;		/* receiver's class */
d90 2
a91 2
rb_add_method(klass, mid, node, noex)
    VALUE klass;
d98 15
a112 3
    if (NIL_P(klass)) klass = rb_cObject;
    if (klass == rb_cObject) {
	rb_secure(4);
d114 1
a114 2
    body = NEW_METHOD(node, noex);
    st_insert(RCLASS(klass)->m_tbl, mid, body);
d118 2
a119 2
search_method(klass, id, origin)
    VALUE klass, *origin;
d124 3
a126 3
    while (!st_lookup(RCLASS(klass)->m_tbl, id, &body)) {
	klass = RCLASS(klass)->super;
	if (!klass) return 0;
d129 1
a129 1
    if (origin) *origin = klass;
d134 2
a135 2
rb_get_method_body(klassp, idp, noexp)
    VALUE *klassp;
d140 1
a140 1
    VALUE klass = *klassp;
d142 1
a142 1
    NODE * volatile body;
d145 1
a145 1
    if ((body = search_method(klass, id, &origin)) == 0) {
d151 2
a152 2
    ent = cache + EXPR1(klass, id);
    ent->klass  = klass;
d157 1
a157 1
	*klassp = body->nd_orig;
d163 1
a163 1
	*klassp = origin;
d174 2
a175 2
rb_alias(klass, name, def)
    VALUE klass;
d182 1
a182 4
    if (klass == rb_cObject) {
	rb_secure(4);
    }
    orig = search_method(klass, def, &origin);
d184 2
a185 2
	if (TYPE(klass) == T_MODULE) {
	    orig = search_method(rb_cObject, def, &origin);
d189 2
a190 2
	rb_raise(rb_eNameError, "undefined method `%s' for `%s'",
		 rb_id2name(def), rb_class2name(klass));
d199 1
a199 1
    st_insert(RCLASS(klass)->m_tbl, name,
d204 2
a205 67
remove_method(klass, mid)
    VALUE klass;
    ID mid;
{
    NODE *body;

    if (klass == rb_cObject) {
	rb_secure(4);
    }
    if (!st_delete(RCLASS(klass)->m_tbl, &mid, &body)) {
	rb_raise(rb_eNameError, "method `%s' not defined in %s",
		 rb_id2name(mid), rb_class2name(klass));
    }
    rb_clear_cache_by_id(mid);
}

void
rb_remove_method(klass, name)
    VALUE klass;
    char *name;
{
    remove_method(klass, rb_intern(name));
}

void
rb_disable_super(klass, name)
    VALUE klass;
    char *name;
{
    VALUE origin;
    NODE *body;
    ID mid = rb_intern(name);

    body = search_method(klass, mid, &origin);
    if (!body || !body->nd_body) {
	rb_raise(rb_eNameError, "undefined method `%s' for `%s'",
		 rb_id2name(mid), rb_class2name(klass));
    }
    if (origin == klass) {
	body->nd_noex |= NOEX_UNDEF;
    }
    else {
	rb_clear_cache_by_id(mid);
	rb_add_method(ruby_class, mid, 0, NOEX_UNDEF);
    }
}

void
rb_enable_super(klass, name)
    VALUE klass;
    char *name;
{
    VALUE origin;
    NODE *body;
    ID mid = rb_intern(name);

    body = search_method(klass, mid, &origin);
    if (!body || !body->nd_body || origin != klass) {
	rb_raise(rb_eNameError, "undefined method `%s' for `%s'",
		 rb_id2name(mid), rb_class2name(klass));
    }
    body->nd_noex &= ~NOEX_UNDEF;
}

static void
rb_export_method(klass, name, noex)
    VALUE klass;
d207 1
a207 1
    ID noex;
d210 1
a210 1
    VALUE origin;
d212 3
a214 6
    if (klass == rb_cObject) {
	rb_secure(4);
    }
    body = search_method(klass, name, &origin);
    if (!body && TYPE(klass) == T_MODULE) {
	body = search_method(rb_cObject, name, &origin);
d217 2
a218 2
	rb_raise(rb_eNameError, "undefined method `%s' for `%s'",
		 rb_id2name(name), rb_class2name(klass));
d221 1
a221 1
	if (klass == origin) {
d226 1
a226 1
	    rb_add_method(klass, name, NEW_ZSUPER(), noex);
d231 3
a233 3
int
rb_method_boundp(klass, id, ex)
    VALUE klass;
d239 4
a242 4
    if (rb_get_method_body(&klass, &id, &noex)) {
	if (ex && noex & NOEX_PRIVATE)
	    return Qfalse;
	return Qtrue;
d244 1
a244 1
    return Qfalse;
d247 3
a249 3
void
rb_attr(klass, id, read, write, ex)
    VALUE klass;
d251 1
a251 1
    int read, write, ex;
d253 3
a255 34
    char *name;
    char *buf;
    ID attriv;
    int noex;

    if (!ex) noex = NOEX_PUBLIC;
    else {
	if (SCOPE_TEST(SCOPE_PRIVATE)) {
	    noex = NOEX_PRIVATE;
	    rb_warning("private attribute?");
	}
	else if (SCOPE_TEST(SCOPE_PROTECTED)) {
	    noex = NOEX_PROTECTED;
	}
	else {
	    noex = NOEX_PUBLIC;
	}
    }

    name = rb_id2name(id);
    if (!name) {
	rb_raise(rb_eArgError, "argument needs to be symbol or string");
    }
    buf = ALLOCA_N(char,strlen(name)+2);
    sprintf(buf, "@@%s", name);
    attriv = rb_intern(buf);
    if (read) {
	rb_add_method(klass, id, NEW_IVAR(attriv), noex);
    }
    sprintf(buf, "%s=", name);
    id = rb_intern(buf);
    if (write) {
	rb_add_method(klass, id, NEW_ATTRSET(attriv), noex);
    }
d259 17
a275 7
VALUE rb_errinfo = Qnil;
extern NODE *ruby_eval_tree_begin;
extern NODE *ruby_eval_tree;
extern int ruby_nerrs;

static VALUE rb_eLocalJumpError;
static VALUE rb_eSysStackError;
d277 1
a277 1
extern VALUE ruby_top_self;
d279 2
a280 2
struct FRAME *ruby_frame;
struct SCOPE *ruby_scope;
d285 9
a293 13
    struct FRAME _frame;		\
    _frame.prev = ruby_frame;		\
    _frame.file = ruby_sourcefile;	\
    _frame.line = ruby_sourceline;	\
    _frame.iter = ruby_iter->iter;	\
    _frame.cbase = ruby_frame->cbase;	\
    _frame.argc = 0;			\
    ruby_frame = &_frame;		\

#define POP_FRAME()  			\
    ruby_sourcefile = _frame.file;	\
    ruby_sourceline = _frame.line;	\
    ruby_frame = _frame.prev; }
d301 1
a301 1
    VALUE klass;
a303 1
    int vmode;
d305 1
a305 1
#ifdef USE_THREAD
d309 1
a309 3
};
static struct BLOCK *ruby_block;
static struct BLOCK *ruby_calling_block;
d312 20
a331 15
    struct BLOCK _block;		\
    _block.tag = prot_tag;		\
    _block.var = v;			\
    _block.body = b;			\
    _block.self = self;			\
    _block.frame = *ruby_frame;		\
    _block.klass = ruby_class;		\
    _block.frame.file = ruby_sourcefile;\
    _block.frame.line = ruby_sourceline;\
    _block.scope = ruby_scope;		\
    _block.d_vars = ruby_dyna_vars;	\
    _block.prev = ruby_block;		\
    _block.iter = ruby_iter->iter;	\
    _block.vmode = scope_vmode;		\
    ruby_block = &_block;
d334 1
a334 14
   ruby_block = _block.prev; 		\
}

#define PUSH_BLOCK2(b) {		\
    struct BLOCK * volatile _old;	\
    struct BLOCK * volatile _old_call;	\
    _old = ruby_block;			\
    _old_call = ruby_calling_block;	\
    ruby_calling_block = b;		\
    ruby_block = b;

#define POP_BLOCK2() 			\
   ruby_calling_block = _old_call;	\
   ruby_block = _old;	 		\
d337 1
a337 1
struct RVarmap *ruby_dyna_vars;
d339 3
a341 3
    struct RVarmap * volatile _oldvmap;	\
    _oldvmap = ruby_dyna_vars;		\
    ruby_dyna_vars = 0;
d344 1
a344 15
    ruby_dyna_vars = _oldvmap;		\
}

static struct RVarmap*
new_dvar(id, value)
    ID id;
    VALUE value;
{
    NEWOBJ(vars, struct RVarmap);
    OBJSETUP(vars, 0, T_VARMAP);
    vars->id = id;
    vars->val = value;
    vars->next = ruby_dyna_vars;

    return vars;
d348 1
a348 1
rb_dvar_defined(id)
d351 1
a351 1
    struct RVarmap *vars = ruby_dyna_vars;
d354 1
a354 1
	if (vars->id == id) return Qtrue;
d357 1
a357 1
    return Qfalse;
d361 1
a361 1
rb_dvar_ref(id)
d364 1
a364 1
    struct RVarmap *vars = ruby_dyna_vars;
d375 2
a376 10
void
rb_dvar_push(id, value)
    ID id;
    VALUE value;
{
    ruby_dyna_vars = new_dvar(id, value);
}

void
rb_dvar_asgn(id, value)
d380 1
a380 1
    struct RVarmap *vars = ruby_dyna_vars;
d385 1
a385 1
	    return;
d389 7
a395 12
    rb_dvar_push(id, value);
    return;
}

static void
dvar_asgn_push(id, value)
    ID id;
    VALUE value;
{
    rb_dvar_asgn(id, value);
    if (ruby_calling_block) {
	ruby_calling_block->d_vars = ruby_dyna_vars;
d397 1
d400 1
a400 1
struct iter {
d403 1
a403 2
};
static struct iter *ruby_iter;
d411 1
a411 1
    _iter.prev = ruby_iter;		\
d413 1
a413 1
    ruby_iter = &_iter;			\
d416 1
a416 1
    ruby_iter = _iter.prev;		\
d419 13
a431 1
struct tag {
d436 2
a437 2
    VALUE retval;
    int dst;
d439 1
a439 2
};
static struct tag *prot_tag;
d442 9
a450 9
    struct tag _tag;			\
    _tag.retval = Qnil;			\
    _tag.frame = ruby_frame;		\
    _tag.iter = ruby_iter;		\
    _tag.prev = prot_tag;		\
    _tag.retval = Qnil;			\
    _tag.tag = ptag;			\
    _tag.dst = 0;			\
    prot_tag = &_tag;
d459 2
a460 2
    ruby_frame = prot_tag->frame;	\
    ruby_iter = prot_tag->iter;		\
d465 1
a465 3
    if (_tag.prev)			\
        _tag.prev->retval = _tag.retval;\
    prot_tag = _tag.prev;		\
d478 1
a478 2
VALUE ruby_class;
static VALUE ruby_wrapper;	/* security wrapper */
d481 1
a481 1
    VALUE _class = ruby_class;	\
d483 1
a483 1
#define POP_CLASS() ruby_class = _class; }
d486 1
a486 2
    volatile int _vmode = scope_vmode;	\
    struct SCOPE * volatile _old;	\
d492 2
a493 7
    _old = ruby_scope;			\
    ruby_scope = _scope;		\
    scope_vmode = SCOPE_PUBLIC;

#define SCOPE_DONT_RECYCLE FL_USER2

static void scope_dup(struct SCOPE *);
d496 5
a500 11
    if (ruby_scope->flag == SCOPE_ALLOCA) {\
	if (FL_TEST(ruby_scope, SCOPE_DONT_RECYCLE)) {\
	    scope_dup(ruby_scope);\
	    FL_SET(_old, SCOPE_DONT_RECYCLE);\
	}\
	else {\
	    ruby_scope->local_vars = 0;\
	    ruby_scope->local_tbl  = 0;\
	    if (ruby_scope != top_scope)\
		rb_gc_force_recycle((VALUE)ruby_scope);\
	}\
d503 1
a503 1
	ruby_scope->flag |= SCOPE_NOSTACK;\
d505 1
a505 2
    ruby_scope = _old;\
    scope_vmode = _vmode;\
d508 3
a510 4
static VALUE rb_eval _((VALUE,NODE*));
static VALUE eval _((VALUE,VALUE,VALUE,char*,int));
static NODE *compile _((VALUE,char*));
static VALUE rb_yield_0 _((VALUE, VALUE, VALUE));
d512 3
a514 2
static VALUE rb_call _((VALUE,VALUE,ID,int,VALUE*,int));
static VALUE module_setup _((VALUE,NODE*));
d516 4
a519 2
static VALUE massign _((VALUE,NODE*,VALUE));
static void assign _((VALUE,NODE*,VALUE));
d525 1
a525 1
   2 - process/file operations prohibited
d527 2
a528 1
   4 - no global (non-tainted) variable modification/no direct output
d559 2
a560 2
	rb_raise(rb_eSecurityError, "tried to downgrade safe level from %d to %d",
		 safe_level, level);
d570 2
a571 2
	rb_raise(rb_eTypeError, "wrong argument type %s (expected String)",
		 rb_class2name(CLASS_OF(x)));
d573 3
a575 5
    if (OBJ_TAINTED(x)) {
	if (safe_level > 0){
	    rb_raise(rb_eSecurityError, "Insecure operation - %s",
		     rb_id2name(ruby_frame->last_func));
	}
d584 2
a585 2
	rb_raise(rb_eSecurityError, "Insecure operation `%s' for level %d",
		 rb_id2name(ruby_frame->last_func), safe_level);
d589 3
d593 1
a593 1
static void call_trace_func _((char*,char*,int,VALUE,ID,VALUE));
d598 4
a601 4
    if (ruby_sourcefile) {
	if (ruby_frame->last_func) {
	    fprintf(stderr, "%s:%d:in `%s'", ruby_sourcefile, ruby_sourceline,
		    rb_id2name(ruby_frame->last_func));
d604 1
a604 1
	    fprintf(stderr, "%s:%d", ruby_sourcefile, ruby_sourceline);
a608 15
static VALUE
get_backtrace(info)
    VALUE info;
{
    if (NIL_P(info)) return Qnil;
    return rb_funcall(info, rb_intern("backtrace"), 0);
}

static void
set_backtrace(info, bt)
    VALUE info, bt;
{
    rb_funcall(info, rb_intern("set_backtrace"), 1, bt);
}

a611 1
    VALUE errat;
a612 2
    VALUE einfo;
    volatile int safe = safe_level;
d614 1
a614 1
    if (NIL_P(rb_errinfo)) return;
a615 1
    errat = get_backtrace(rb_errinfo);
d617 1
a617 1
	VALUE mesg = RARRAY(errat)->ptr[0];
d619 9
d634 2
a635 3
    eclass = CLASS_OF(rb_errinfo);
    einfo = rb_obj_as_string(rb_errinfo);
    if (eclass == rb_eRuntimeError && RSTRING(einfo)->len == 0) {
d642 1
a642 1
	if (RSTRING(einfo)->len == 0) {
d648 2
a649 2
	    char *tail  = 0;
	    int len = RSTRING(einfo)->len;
d652 2
a653 2
	    if (tail = strchr(RSTRING(einfo)->ptr, '\n')) {
		len = tail - RSTRING(einfo)->ptr;
d657 1
a657 1
	    fwrite(RSTRING(einfo)->ptr, 1, len, stderr);
d664 1
a664 1
		fwrite(tail, 1, RSTRING(einfo)->len-len-1, stderr);
d680 1
a680 3
	    if (TYPE(ep->ptr[i]) == T_STRING) {
		fprintf(stderr, "\tfrom %s\n", RSTRING(ep->ptr[i])->ptr);
	    }
a687 1
    safe_level = safe;
d690 1
a690 1
#if !defined(NT) && !defined(__MACOS__)
d693 1
a693 1
char **rb_origenviron;
d696 2
a697 2
void Init_stack _((void));
void Init_heap _((void));
d699 1
d708 2
a709 2
    ruby_frame = top_frame = &frame;
    ruby_iter = &iter;
d711 1
a711 5
#ifdef __MACOS__
    rb_origenviron = 0;
#else
    rb_origenviron = environ;
#endif
d713 1
a713 1
    Init_heap();
d715 3
a717 3
    ruby_scope->local_vars = 0;
    ruby_scope->local_tbl  = 0;
    top_scope = ruby_scope;
d719 1
a719 1
    SCOPE_SET(SCOPE_PRIVATE);
d724 3
a726 4
	ruby_class = rb_cObject;
	ruby_frame->self = ruby_top_self;
	ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,rb_cObject,0,0);
	rb_define_global_const("TOPLEVEL_BINDING", rb_f_binding(ruby_top_self));
d732 1
a732 1
    ruby_scope = top_scope;
d749 6
a754 4
	ext_init = 1;	/* Init_ext() called in ruby_process_options */
	save = ruby_eval_tree;
	ruby_require_modules();
	ruby_eval_tree = save;
a757 1
	trace_func = 0;
d770 3
a772 3
    if (ruby_eval_tree_begin) {
	tree = ruby_eval_tree_begin;
	ruby_eval_tree_begin = 0;
d776 1
a776 1
    if (!ruby_eval_tree) return Qnil;
d778 2
a779 2
    tree = ruby_eval_tree;
    ruby_eval_tree = 0;
d787 4
a790 3
#ifdef USE_THREAD
static void rb_thread_cleanup _((void));
static void rb_thread_wait_other_threads _((void));
d795 1
a795 1
static void exec_end_proc _((void));
d803 1
a803 1
    if (ruby_nerrs > 0) exit(ruby_nerrs);
d805 2
a806 1
    Init_stack();
d812 1
a812 1
	eval_node(ruby_top_self);
d822 3
a824 3
#ifdef USE_THREAD
	rb_thread_cleanup();
	rb_thread_wait_other_threads();
d826 2
d837 1
a837 2
	ex = 0;
	break;
d841 2
a842 2
	fprintf(stderr, ": unexpected return\n");
	ex = 1;
d846 2
a847 2
	fprintf(stderr, ": unexpected next\n");
	ex = 1;
d851 2
a852 2
	fprintf(stderr, ": unexpected break\n");
	ex = 1;
d856 2
a857 2
	fprintf(stderr, ": unexpected redo\n");
	ex = 1;
d861 2
a862 2
	fprintf(stderr, ": retry outside of rescue clause\n");
	ex = 1;
d866 1
a866 1
	if (rb_obj_is_kind_of(rb_errinfo, rb_eSystemExit)) {
d870 1
a870 1
	ex = 1;
d873 1
a873 1
	rb_bug("Unknown longjmp status %d", ex);
a875 3
    exec_end_proc();
    rb_gc_call_finalizer_at_exit();
    exit(ex);
d882 1
a882 3
    VALUE str;
    char *mesg;
    int len;
d884 3
a886 3
    mesg = str2cstr(rb_errinfo, &len);
    ruby_nerrs = 0;
    str = rb_str_new2("compile error");
d888 2
a889 2
	rb_str_cat(str, " in ", 4);
	rb_str_cat(str, at, strlen(at));
d891 3
a893 3
    rb_str_cat(str, "\n", 1);
    rb_str_cat(str, mesg, len);
    rb_exc_raise(rb_exc_new3(rb_eSyntaxError, str));
d901 1
a901 1
    char *oldsrc = ruby_sourcefile;
d903 3
a905 3
    ruby_sourcefile = "(eval)";
    v = eval(ruby_top_self, rb_str_new2(str), Qnil, 0, 0);
    ruby_sourcefile = oldsrc;
d910 1
a910 24
VALUE
rb_eval_string_protect(str, state)
    char *str;
    int *state;
{
    VALUE result;		/* OK */
    int status;

    PUSH_TAG(PROT_NONE);
    if ((status = EXEC_TAG()) == 0) {
	result = rb_eval_string(str);
    }
    POP_TAG();
    if (state) {
	*state = status;
    }
    if (status != 0) {
	return Qnil;
    }

    return result;
}

VALUE
a914 1
    VALUE val;			/* OK */
d916 1
a916 1
    volatile int safe = safe_level;
d919 4
a922 2
	return rb_funcall2(cmd, rb_intern("call"),
			   RARRAY(arg)->len, RARRAY(arg)->ptr);
d927 2
a928 2
    saved_scope = ruby_scope;
    ruby_scope = top_scope;
d930 3
a932 3
    ruby_class = rb_cObject;
    if (OBJ_TAINTED(cmd)) {
	safe_level = 4;
d936 1
a936 1
	val = eval(ruby_top_self, cmd, Qnil, 0, 0);
d939 1
a939 1
    ruby_scope = saved_scope;
d948 1
a948 1
	rb_raise(rb_eLocalJumpError, "unexpected return");
d951 1
a951 1
	rb_raise(rb_eLocalJumpError, "unexpected next");
d954 1
a954 1
	rb_raise(rb_eLocalJumpError, "unexpected break");
d957 1
a957 1
	rb_raise(rb_eLocalJumpError, "unexpected redo");
d960 1
a960 1
	rb_raise(rb_eLocalJumpError, "retry outside of rescue clause");
a965 1
    return val;
d968 1
a968 1
VALUE
a973 1
    VALUE val;			/* OK */
d977 1
a977 1
	val = rb_eval_cmd(cmd, rb_ary_new3(1, INT2FIX(sig)));
d981 1
a981 1
	rb_trap_immediate = 0;
a983 1
    return val;
d991 1
a991 1
    VALUE val;			/* OK */
d999 1
a999 1
    if (state) {
d1003 1
a1003 2
	    rb_raise(rb_eTypeError, "undefined superclass `%s'",
		     rb_id2name(node->nd_mid));
d1005 1
a1005 2
	    rb_raise(rb_eTypeError, "undefined superclass `%s'",
		     rb_id2name(node->nd_vid));
d1007 1
a1007 1
	    rb_raise(rb_eTypeError, "superclass undefined");
d1013 1
a1013 1
	rb_raise(rb_eTypeError, "can't make subclass of virtual class");
d1026 2
a1027 2
    while (cbase && cbase->nd_clss != rb_cObject) {
	struct RClass *klass = RCLASS(cbase->nd_clss);
d1029 3
a1031 3
	if (klass->iv_tbl &&
	    st_lookup(klass->iv_tbl, id, 0)) {
	    return Qtrue;
d1046 2
a1047 2
    while (cbase && cbase->nd_clss != rb_cObject) {
	struct RClass *klass = RCLASS(cbase->nd_clss);
d1049 2
a1050 2
	if (klass->iv_tbl &&
	    st_lookup(klass->iv_tbl, id, &result)) {
d1059 1
a1059 1
rb_mod_nesting()
d1061 2
a1062 2
    NODE *cbase = (NODE*)ruby_frame->cbase;
    VALUE ary = rb_ary_new();
d1064 2
a1065 2
    while (cbase && cbase->nd_clss != rb_cObject) {
	rb_ary_push(ary, cbase->nd_clss);
d1072 1
a1072 1
rb_mod_s_constants()
d1074 2
a1075 2
    NODE *cbase = (NODE*)ruby_frame->cbase;
    VALUE ary = rb_ary_new();
d1077 2
a1078 2
    while (cbase && cbase->nd_clss != rb_cObject) {
	rb_mod_const_at(cbase->nd_clss, ary);
d1082 1
a1082 1
    rb_mod_const_of(((NODE*)ruby_frame->cbase)->nd_clss, ary);
d1087 1
a1087 1
rb_mod_remove_method(mod, name)
d1090 1
a1090 1
    remove_method(mod, rb_to_id(name));
d1095 1
a1095 1
rb_mod_undef_method(mod, name)
d1106 2
a1107 2
rb_mod_alias_method(mod, newname, oldname)
    VALUE mod, newname, oldname;
d1109 1
a1109 1
    ID id = rb_to_id(newname);
d1111 1
a1111 1
    rb_alias(mod, id, rb_to_id(oldname));
a1115 11
#ifdef C_ALLOCA
# define TMP_PROTECT NODE * volatile __protect_tmp=0
# define TMP_ALLOC(n)						\
    (__protect_tmp = rb_node_newnode(NODE_ALLOCA,		\
			     ALLOC_N(VALUE,n),__protect_tmp,n),	\
     (void*)__protect_tmp->nd_head)
#else
# define TMP_PROTECT typedef int foobazzz
# define TMP_ALLOC(n) ALLOCA_N(VALUE,n)
#endif

d1125 2
a1126 2
	    char *file = ruby_sourcefile;\
	    int line = ruby_sourceline;\
d1129 1
a1129 1
	    argv = TMP_ALLOC(argc);\
d1134 2
a1135 2
	    ruby_sourcefile = file;\
	    ruby_sourceline = line;\
d1144 2
a1145 2
	char *file = ruby_sourcefile;\
	int line = ruby_sourceline;\
d1151 2
a1152 9
	ruby_sourcefile = file;\
	ruby_sourceline = line;\
    }\
}

#define BEGIN_CALLARGS {\
    struct BLOCK *tmp_block = ruby_block;\
    if (ruby_iter->iter == ITER_PRE) {\
	ruby_block = ruby_block->prev;\
a1153 5
    PUSH_ITER(ITER_NOT);

#define END_CALLARGS \
    ruby_block = tmp_block;\
    POP_ITER();\
d1156 1
a1156 1
#define MATCH_DATA ruby_scope->local_vars[node->nd_cnt]
d1199 3
a1201 3
	if (ruby_frame->last_func == 0) return 0;
	else if (rb_method_boundp(RCLASS(ruby_frame->last_class)->super,
				  ruby_frame->last_func, 1)) {
d1209 1
a1210 1
      case NODE_FCALL:
d1222 3
a1224 1
	if (state) return 0;
d1226 1
a1226 1
	if (rb_method_boundp(val, node->nd_mid, nd_type(node)== NODE_CALL)) {
d1236 1
a1236 1
	if (rb_iterator_p()) {
a1258 1
      case NODE_DASGN_PUSH:
d1265 1
a1266 2
      case NODE_DVAR:
	return "local-variable(in-block)";
d1281 1
a1281 1
	if (ev_const_defined((NODE*)ruby_frame->cbase, node->nd_vid)) {
d1292 3
a1294 1
	if (state) return 0;
a1300 4
	      default:
		if (rb_method_boundp(val, node->nd_mid, 1)) {
		    return "method";
		}
d1306 1
a1306 1
	if (rb_reg_nth_defined(node->nd_nth, MATCH_DATA)) {
d1313 1
a1313 1
	if (rb_reg_nth_defined(0, MATCH_DATA)) {
d1333 2
a1334 1
static int handle_rescue _((VALUE,NODE*));
a1338 20
rb_obj_is_block(block)
    VALUE block;
{
    if (TYPE(block) == T_DATA && RDATA(block)->dfree == blk_free) {
	return Qtrue;
    }
    return Qfalse;
}

static VALUE
rb_obj_is_proc(proc)
    VALUE proc;
{
    if (rb_obj_is_block(proc) && rb_obj_is_kind_of(proc, rb_cProc)) {
	return Qtrue;
    }
    return Qfalse;
}

static VALUE
d1346 2
a1347 2
    if (!rb_obj_is_proc(trace)) {
	rb_raise(rb_eTypeError, "trace_func needs to be Proc");
d1353 1
a1353 1
call_trace_func(event, file, line, self, id, klass)
a1358 1
    VALUE klass;		/* OK */
a1362 2
    char *file_save = ruby_sourcefile;
    int line_save = ruby_sourceline;
d1368 2
a1369 2
#ifdef USE_THREAD
    rb_thread_critical++;
d1372 1
a1372 1
    prev = ruby_frame;
d1374 2
a1375 2
    *ruby_frame = *_frame.prev;
    ruby_frame->prev = prev;
d1377 2
a1378 9
    if (file) {
	ruby_frame->line = ruby_sourceline = line;
	ruby_frame->file = ruby_sourcefile = file;
    }
    if (klass) {
	if (TYPE(klass) == T_ICLASS || FL_TEST(klass, FL_SINGLETON)) {
	    klass = self;
	}
    }
d1381 5
a1385 6
	proc_call(trace, rb_ary_new3(6, rb_str_new2(event),
				     rb_str_new2(ruby_sourcefile),
				     INT2FIX(ruby_sourceline),
				     INT2FIX(id),
				     self?rb_f_binding(self):Qnil,
				     klass));
d1390 2
a1391 2
#ifdef USE_THREAD
    rb_thread_critical--;
a1393 2
    ruby_sourceline = line_save;
    ruby_sourcefile = file_save;
d1397 1
a1397 3
static void return_check _((void));
#define return_value(v) prot_tag->retval = (v)

a1404 4
#ifdef NOBLOCK_RECUR
    NODE * volatile next = 0;
    NODE * volatile nstack = 0;
#endif
a1412 5
#ifndef NOBLOCK_RECUR
	if (!node->nd_next) {
	    node = node->nd_head;
	    goto again;
	}
d1418 1
a1418 8
#else
	if (next) {
	    nstack = rb_node_newnode(NODE_CREF,next,0,nstack);
	}
	next = node->nd_next;
	node = node->nd_head;
	goto again;
#endif
d1420 1
a1420 1
	rb_f_END();
d1432 1
a1432 1
	result = rb_reg_match2(node->nd_head->nd_lit);
d1437 1
a1437 1
	result = rb_reg_match(rb_eval(self,node->nd_recv),
d1447 1
a1447 1
		result = rb_reg_match(l, r);
d1457 1
a1457 1
	while (!NIL_P(rb_gets())) {
d1469 1
a1469 1
	RETURN(Qtrue);
d1472 1
a1472 1
	RETURN(Qfalse);
d1475 1
a1475 4
	ruby_sourceline = nd_line(node);
#ifdef NOBLOCK_RECUR
	if (RTEST(result)){
#else
a1476 1
#endif
a1487 3
#ifdef NOBLOCK_RECUR
	    val = result;
#else
a1488 1
#endif
d1500 1
a1500 17
					self, ruby_frame->last_func, 0);	
		    }
		    ruby_sourcefile = tag->nd_file;
		    ruby_sourceline = nd_line(tag);
		    if (nd_type(tag->nd_head) == NODE_WHEN) {
			VALUE v = rb_eval(self, tag->nd_head->nd_head);
			int i;

			if (TYPE(v) != T_ARRAY) v = rb_Array(v);
			for (i=0; i<RARRAY(v)->len; i++) {
			    if (RTEST(rb_funcall2(RARRAY(v)->ptr[i], eqq, 1, &val))){
				node = node->nd_body;
				goto again;
			    }
			}
			tag = tag->nd_next;
			continue;
d1502 2
a1503 1
		    if (RTEST(rb_funcall2(rb_eval(self, tag->nd_head), eqq, 1, &val))) {
d1518 1
a1518 1
	    ruby_sourceline = nd_line(node);
d1542 3
a1544 1
	if (state) JUMP_TAG(state);
d1574 3
a1576 1
	if (state) JUMP_TAG(state);
a1578 4
      case NODE_BLOCK_PASS:
	result = block_pass(self, node);
	break;

d1595 2
a1596 2
		    char *file = ruby_sourcefile;
		    int line = ruby_sourceline;
d1600 2
a1601 2
		    ruby_sourcefile = file;
		    ruby_sourceline = line;
d1606 1
a1606 1
	    else if (_block.tag->dst == state) {
d1609 1
a1609 1
		    result = prot_tag->retval;
a1648 7
      case NODE_RESTARGS:
	result = rb_eval(self, node->nd_head);
	if (TYPE(result) != T_ARRAY) {
	    result = rb_Array(result);
	}
	break;

d1650 1
a1650 12
	if (node->nd_stts) {
	    result = rb_eval(self, node->nd_stts);
	    if (nd_type(node->nd_stts) == NODE_RESTARGS &&
		RARRAY(result)->len == 1)
	    {
		result = RARRAY(result)->ptr[0];
	    }
	}
	else {
	    result = Qnil;
	}
	result = rb_yield_0(result, 0, 0);
d1656 1
a1656 1
	    volatile VALUE e_info = rb_errinfo;
a1664 1

d1674 2
a1675 1
			    rb_errinfo = e_info;
d1686 2
a1687 3
	    if (state) JUMP_TAG(state);
	    if (node->nd_else) { /* no exception raised, else clause given */
		result = rb_eval(self, node->nd_else);
d1698 3
a1700 5
	if (node->nd_ensr) {
	    VALUE retval = prot_tag->retval; /* save retval */

	    rb_eval(self, node->nd_ensr);
	    return_value(retval);
a1701 1
	if (state) JUMP_TAG(state);
d1717 2
a1718 2
	if (RTEST(rb_eval(self, node->nd_body))) result = Qfalse;
	else result = Qtrue;
d1723 1
a1723 17
	result = rb_range_new(rb_eval(self, node->nd_beg), rb_eval(self, node->nd_end));
#if 0
	break;
#else
	result = rb_range_new(rb_eval(self, node->nd_beg), rb_eval(self, node->nd_end));
	if (node->nd_state) break;
	if (nd_type(node->nd_beg) == NODE_LIT && FIXNUM_P(node->nd_beg->nd_lit) &&
	    nd_type(node->nd_end) == NODE_LIT && FIXNUM_P(node->nd_end->nd_lit))
	{
	    nd_set_type(node, NODE_LIT);
	    node->nd_lit = result;
	}
	else {
	    node->nd_state = 1;
	}
#endif
	break;
d1726 1
a1726 4
	if (ruby_scope->local_vars == 0) {
	    rb_bug("unexpected local variable");
	}
	if (!RTEST(ruby_scope->local_vars[node->nd_cnt])) {
d1728 2
a1729 3
		ruby_scope->local_vars[node->nd_cnt] = 
		    RTEST(rb_eval(self, node->nd_end))?Qfalse:Qtrue;
		result = Qtrue;
d1732 1
a1732 1
		result = Qfalse;
d1737 1
a1737 1
		ruby_scope->local_vars[node->nd_cnt] = Qfalse;
d1739 1
a1739 1
	    result = Qtrue;
d1744 6
a1749 6
	if (ruby_scope->local_vars == 0) {
	    rb_bug("unexpected local variable");
	}
	if (!RTEST(ruby_scope->local_vars[node->nd_cnt])) {
	    result = RTEST(rb_eval(self, node->nd_beg));
	    ruby_scope->local_vars[node->nd_cnt] = result;
d1753 1
a1753 1
		ruby_scope->local_vars[node->nd_cnt] = Qfalse;
d1755 1
a1755 1
	    result = Qtrue;
a1762 1
	return_check();
a1765 5
      case NODE_ARGSCAT:
	result = rb_ary_concat(rb_eval(self, node->nd_head),
			       rb_eval(self, node->nd_body));
	break;

a1769 1
	    TMP_PROTECT;
d1771 1
a1771 6
	    BEGIN_CALLARGS;
#ifdef NOBLOCK_RECUR_incomplete
	    printf("mid %s recv: ", rb_id2name(node->nd_mid));
	    rb_p(result);
	    recv = result;
#else
a1772 1
#endif
d1774 1
a1774 2
	    END_CALLARGS;

a1781 1
	    TMP_PROTECT;
d1783 1
a1783 1
	    BEGIN_CALLARGS;
d1785 1
a1785 2
	    END_CALLARGS;

a1797 1
	    TMP_PROTECT;
a1798 4
	    if (ruby_frame->last_class == 0) {	
		rb_raise(rb_eNameError, "superclass method `%s' disabled",
			 rb_id2name(ruby_frame->last_func));
	    }
d1800 2
a1801 2
		argc = ruby_frame->argc;
		argv = ruby_frame->argv;
d1804 1
a1804 1
		BEGIN_CALLARGS;
d1806 1
a1806 1
		END_CALLARGS;
d1809 3
a1811 4
	    PUSH_ITER(ruby_iter->iter?ITER_PRE:ITER_NOT);
	    result = rb_call(RCLASS(ruby_frame->last_class)->super,
			     ruby_frame->self, ruby_frame->last_func,
			     argc, argv, 3);
d1818 1
a1818 1
	    VALUE save = ruby_frame->cbase;
d1822 1
a1822 1
	    if (node->nd_rval) ruby_frame->cbase = node->nd_rval;
d1826 3
a1828 3
		ruby_scope->local_vars = vars;
		rb_mem_clear(ruby_scope->local_vars, node->nd_tbl[0]);
		ruby_scope->local_tbl = node->nd_tbl;
d1831 2
a1832 2
		ruby_scope->local_vars = 0;
		ruby_scope->local_tbl  = 0;
d1835 1
a1835 1
		result = rb_eval(self, node->nd_next);
d1839 1
a1839 1
	    ruby_frame->cbase = save;
a1848 1
	    TMP_PROTECT;
d1854 1
a1854 11
	    if (node->nd_mid == 0) {      /* OR */
		if (RTEST(val)) break;
		val = rb_eval(self, rval);
	    }
	    else if (node->nd_mid == 1) { /* AND */
		if (!RTEST(val)) break;
		val = rb_eval(self, rval);
	    }
	    else {
		val = rb_funcall(val, node->nd_mid, 1, rb_eval(self, rval));
	    }
a1867 12
	    if (node->nd_next->nd_mid == 0) {      /* OR */
		if (RTEST(val)) break;
		val = rb_eval(self, node->nd_value);
	    }
	    else if (node->nd_next->nd_mid == 1) { /* AND */
		if (!RTEST(val)) break;
		val = rb_eval(self, node->nd_value);
	    }
	    else {
		val = rb_funcall(val, node->nd_next->nd_mid, 1,
				 rb_eval(self, node->nd_value));
	    }
d1869 4
a1872 1
	    rb_funcall2(recv, node->nd_next->nd_aid, 1, &val);
a1876 14
      case NODE_OP_ASGN_AND:
	result = rb_eval(self, node->nd_head);
	if (RTEST(result)) {
	    result = rb_eval(self, node->nd_value);
	}
	break;

      case NODE_OP_ASGN_OR:
	result = rb_eval(self, node->nd_head);
	if (!RTEST(result)) {
	    result = rb_eval(self, node->nd_value);
	}
	break;

d1882 4
a1885 4
	if (ruby_scope->local_vars == 0)
	    rb_bug("unexpected local variable assignment");
	result = rb_eval(self, node->nd_value);
	ruby_scope->local_vars[node->nd_cnt] = result;
d1889 1
a1889 2
	result = rb_eval(self, node->nd_value);
	rb_dvar_asgn(node->nd_vid, result);
d1892 3
a1894 4
      case NODE_DASGN_PUSH:
	result = rb_eval(self, node->nd_value);
	dvar_asgn_push(node->nd_vid, result);
	break;
d1896 4
a1899 3
      case NODE_GASGN:
	result = rb_eval(self, node->nd_value);
	rb_gvar_set(node->nd_entry, result);
d1903 7
a1909 2
	result = rb_eval(self, node->nd_value);
	rb_ivar_set(self, node->nd_vid, result);
d1913 9
a1921 10
	if (NIL_P(ruby_class)) {
	    rb_raise(rb_eTypeError, "no class/module to define constant");
	}
	result = rb_eval(self, node->nd_value);
	/* check for static scope constants */
	if (RTEST(rb_verbose) &&
	    ev_const_defined((NODE*)ruby_frame->cbase, node->nd_vid)) {
	    if (RTEST(rb_verbose)) {
		rb_warning("already initialized constant %s",
			   rb_id2name(node->nd_vid));
d1923 2
a1925 1
	rb_const_set(ruby_class, node->nd_vid, result);
d1929 2
a1930 2
	if (ruby_scope->local_vars == 0) {
	    rb_bug("unexpected local variable");
d1932 1
a1932 1
	result = ruby_scope->local_vars[node->nd_cnt];
d1936 1
a1936 1
	result = rb_dvar_ref(node->nd_vid);
d1948 1
a1948 13
	result = ev_const_get((NODE*)ruby_frame->cbase, node->nd_vid);
	break;

      case NODE_BLOCK_ARG:
	if (ruby_scope->local_vars == 0)
	    rb_bug("unexpected block argument");
	if (rb_iterator_p()) {
	    result = rb_f_lambda();
	    ruby_scope->local_vars[node->nd_cnt] = result;
	}
	else {
	    result = Qnil;
	}
d1953 1
a1953 1
	    VALUE klass;
d1955 2
a1956 2
	    klass = rb_eval(self, node->nd_head);
	    switch (TYPE(klass)) {
d1961 2
a1962 1
		return rb_funcall(klass, node->nd_mid, 0, 0);
d1964 1
a1964 1
	    result = rb_const_get_at(klass, node->nd_mid);
a1967 4
      case NODE_COLON3:
	result = rb_const_get_at(rb_cObject, node->nd_mid);
	break;

d1969 1
a1969 1
	result = rb_reg_nth_match(node->nd_nth, MATCH_DATA);
d1975 1
a1975 1
	    result = rb_reg_last_match(MATCH_DATA);
d1978 1
a1978 1
	    result = rb_reg_match_pre(MATCH_DATA);
d1981 1
a1981 1
	    result = rb_reg_match_post(MATCH_DATA);
d1984 1
a1984 1
	    result = rb_reg_match_last(MATCH_DATA);
d1987 1
a1987 1
	    rb_bug("unexpected back-ref");
d1994 1
a1994 1
	    VALUE hash = rb_hash_new();
d2002 1
a2002 1
		    rb_bug("odd number list for Hash");
d2005 1
a2005 1
		rb_hash_aset(hash, key, val);
d2012 1
a2012 1
	result = rb_ary_new();
d2021 1
a2021 1
	    ary = rb_ary_new2(i);
d2032 1
a2032 1
	result = rb_str_new3(node->nd_lit);
d2043 1
a2043 1
	    str = rb_str_new3(node->nd_lit);
d2045 5
a2049 6
		if (list->nd_head) {
		    switch (nd_type(list->nd_head)) {
		      case NODE_STR:
			str2 = list->nd_head->nd_lit;
			break;
		      case NODE_EVSTR:
d2051 2
a2052 2
			list->nd_head = compile(list->nd_head->nd_lit,0);
			ruby_eval_tree = 0;
d2054 2
a2055 2
			if (ruby_nerrs > 0) {
			    compile_error("string expansion");
a2056 5
			/* fall through */
		      default:
			str2 = rb_eval(self, list->nd_head);
			str2 = rb_obj_as_string(str2);
			break;
d2058 5
a2062 2
		    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
		    if (OBJ_TAINTED(str2)) OBJ_TAINT(str);
d2068 1
a2068 1
		result = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
d2072 1
a2072 1
		result = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
d2096 3
a2098 4
	if (ruby_frame->argc != 1)
	    rb_raise(rb_eArgError, "Wrong # of arguments(%d for 1)",
		     ruby_frame->argc);
	result = rb_ivar_set(self, node->nd_vid, ruby_frame->argv[0]);
d2107 1
a2107 7
	    if (NIL_P(ruby_class)) {
		rb_raise(rb_eTypeError, "no class to add method");
	    }
	    if (ruby_class == rb_cObject && node->nd_mid == init) {
		rb_warn("re-defining Object#initialize may cause infinite loop");
	    }
	    body = search_method(ruby_class, node->nd_mid, &origin);
d2109 2
a2110 7
		if (origin == ruby_class) {
		    if (safe_level >= 3) {
			rb_raise(rb_eSecurityError, "re-defining method prohibited");
		    }
		    if (RTEST(rb_verbose)) {
			rb_warning("discarding old %s", rb_id2name(node->nd_mid));
		    }
d2115 1
a2115 1
	    if (SCOPE_TEST(SCOPE_PRIVATE) || node->nd_mid == init) {
a2117 3
	    else if (SCOPE_TEST(SCOPE_PROTECTED)) {
		noex = NOEX_PROTECTED;
	    }
d2121 4
a2124 13
	    if (body && origin == ruby_class && body->nd_noex & NOEX_UNDEF) {
		noex |= NOEX_UNDEF;
	    }
	    rb_add_method(ruby_class, node->nd_mid, node->nd_defn, noex);
	    if (scope_vmode == SCOPE_MODFUNC) {
		rb_add_method(rb_singleton_class(ruby_class),
			      node->nd_mid, node->nd_defn, NOEX_PUBLIC);
		rb_funcall(ruby_class, rb_intern("singleton_method_added"),
			   1, INT2FIX(node->nd_mid));
	    }
	    if (FL_TEST(ruby_class, FL_SINGLETON)) {
		rb_funcall(rb_iv_get(ruby_class, "__attached__"),
			   rb_intern("singleton_method_added"),
d2128 1
a2128 1
		rb_funcall(ruby_class, rb_intern("method_added"),
d2138 2
a2139 2
	    VALUE klass;
	    NODE *body = 0;
d2142 2
a2143 2
		rb_raise(rb_eTypeError, "Can't define method \"%s\" for Fixnum",
			 rb_id2name(node->nd_mid));
d2146 2
a2147 2
		rb_raise(rb_eTypeError, "Can't define method \"%s\" for nil",
			 rb_id2name(node->nd_mid));
d2150 2
a2151 3
		rb_raise(rb_eTypeError,
			 "Can't define method \"%s\" for special constants",
			 rb_id2name(node->nd_mid));
d2154 3
a2156 11
	    if (rb_safe_level() >= 4 && !FL_TEST(recv, FL_TAINT)) {
		rb_raise(rb_eSecurityError, "can't define singleton method");
	    }
	    klass = rb_singleton_class(recv);
	    if (st_lookup(RCLASS(klass)->m_tbl, node->nd_mid, &body)) {
		if (safe_level >= 3) {
		    rb_raise(rb_eSecurityError, "re-defining method prohibited");
		}
		if (RTEST(rb_verbose)) {
		    rb_warning("redefine %s", rb_id2name(node->nd_mid));
		}
d2159 1
a2159 2
	    rb_add_method(klass, node->nd_mid, node->nd_defn, 
			  NOEX_PUBLIC|(body?body->nd_noex&NOEX_UNDEF:0));
d2171 1
a2171 7
	    if (NIL_P(ruby_class)) {
		rb_raise(rb_eTypeError, "no class to undef method");
	    }
	    if (ruby_class == rb_cObject) {
		rb_secure(4);
	    }
	    body = search_method(ruby_class, node->nd_mid, &origin);
d2173 2
a2174 14
		char *s0 = " class";
		VALUE klass = ruby_class;

		if (FL_TEST(ruby_class, FL_SINGLETON)) {
		    VALUE obj = rb_iv_get(ruby_class, "__attached__");
		    switch (TYPE(obj)) {
		      case T_MODULE:
		      case T_CLASS:
			klass = obj;
			s0 = "";
		    }
		}
		rb_raise(rb_eNameError, "undefined method `%s' for%s `%s'",
			 rb_id2name(node->nd_mid),s0,rb_class2name(klass));
d2177 1
a2177 1
	    rb_add_method(ruby_class, node->nd_mid, 0, NOEX_PUBLIC);
d2183 2
a2184 5
	if (NIL_P(ruby_class)) {
	    rb_raise(rb_eTypeError, "no class to make alias");
	}
	rb_alias(ruby_class, node->nd_new, node->nd_old);
	rb_funcall(ruby_class, rb_intern("method_added"),
d2196 1
a2196 1
	    VALUE super, klass, tmp;
a2197 3
	    if (NIL_P(ruby_class)) {
		rb_raise(rb_eTypeError, "no outer class/module");
	    }
d2205 7
a2211 12
	    klass = 0;
	    if (rb_const_defined_at(ruby_class, node->nd_cname) &&
		(ruby_class != rb_cObject || !rb_autoload_defined(node->nd_cname))) {
		klass = rb_const_get_at(ruby_class, node->nd_cname);
	    }
	    if (ruby_wrapper && rb_const_defined_at(rb_cObject, node->nd_cname)) {
		klass = rb_const_get_at(rb_cObject, node->nd_cname);
	    }
	    if (klass) {
		if (TYPE(klass) != T_CLASS) {
		    rb_raise(rb_eTypeError, "%s is not a class",
			     rb_id2name(node->nd_cname));
d2214 1
a2214 1
		    tmp = RCLASS(klass)->super;
d2222 2
a2223 2
			rb_raise(rb_eTypeError, "superclass mismatch for %s",
				 rb_id2name(node->nd_cname));
d2226 2
a2227 2
		if (safe_level >= 3) {
		    rb_raise(rb_eSecurityError, "extending class prohibited");
d2232 4
a2235 9
		if (!super) super = rb_cObject;
		klass = rb_define_class_id(node->nd_cname, super);
		rb_const_set(ruby_class, node->nd_cname, klass);
		rb_set_class_path(klass,ruby_class,rb_id2name(node->nd_cname));
		rb_obj_call_init(klass);
	    }
	    if (ruby_wrapper) {
		rb_extend_object(klass, ruby_wrapper);
		rb_include_module(klass, ruby_wrapper);
d2238 1
a2238 1
	    result = module_setup(klass, node->nd_body);
d2246 2
a2247 6
	    if (NIL_P(ruby_class)) {
		rb_raise(rb_eTypeError, "no outer class/module");
	    }
	    module = 0;
	    if (rb_const_defined_at(ruby_class, node->nd_cname) &&
		(ruby_class != rb_cObject ||
d2249 2
a2250 6
		module = rb_const_get_at(ruby_class, node->nd_cname);
	    }
	    if (ruby_wrapper && rb_const_defined_at(rb_cObject, node->nd_cname)) {
		module = rb_const_get_at(rb_cObject, node->nd_cname);
	    }
	    if (module) {
d2252 1
a2252 2
		    rb_raise(rb_eTypeError, "%s is not a module",
			     rb_id2name(node->nd_cname));
d2254 2
a2255 2
		if (safe_level >= 3) {
		    rb_raise(rb_eSecurityError, "extending module prohibited");
d2260 2
a2261 7
		rb_const_set(ruby_class, node->nd_cname, module);
		rb_set_class_path(module,ruby_class,rb_id2name(node->nd_cname));
		rb_obj_call_init(module);
	    }
	    if (ruby_wrapper) {
		rb_extend_object(module, ruby_wrapper);
		rb_include_module(module, ruby_wrapper);
d2270 1
a2270 1
	    VALUE klass;
d2272 3
a2274 3
	    klass = rb_eval(self, node->nd_recv);
	    if (FIXNUM_P(klass)) {
		rb_raise(rb_eTypeError, "No virtual class for Fixnums");
d2276 2
a2277 2
	    if (NIL_P(klass)) {
		rb_raise(rb_eTypeError, "No virtual class for nil");
d2279 2
a2280 2
	    if (rb_special_const_p(klass)) {
		rb_raise(rb_eTypeError, "No virtual class for special constants");
d2282 1
a2282 1
	    if (FL_TEST(CLASS_OF(klass), FL_SINGLETON)) {
d2284 1
d2286 2
a2287 7
	    klass = rb_singleton_class(klass);
	    if (ruby_wrapper) {
		rb_extend_object(klass, ruby_wrapper);
		rb_include_module(klass, ruby_wrapper);
	    }
	    
	    result = module_setup(klass, node->nd_body);
d2296 2
a2297 2
	    if (desc) result = rb_str_new2(desc);
	    else result = Qfalse;
d2302 2
a2303 2
	ruby_sourcefile = node->nd_file;
	ruby_sourceline = node->nd_nth;
d2305 2
a2306 2
	    call_trace_func("line", ruby_sourcefile, ruby_sourceline,
			    self, ruby_frame->last_func, 0);	
d2312 1
a2312 1
	rb_bug("unknown node type %d", nd_type(node));
a2315 12
#ifdef NOBLOCK_RECUR
    if (next) {
	node = next;
	next = 0;
	goto again;
    }
    if (nstack) {
	node = nstack->nd_head;
	nstack = nstack->nd_next;
	goto again;
    }
#endif
d2325 1
a2325 1
    VALUE save = ruby_frame->cbase;
d2327 2
a2328 3
    char *file = ruby_sourcefile;
    int line = ruby_sourceline;
    TMP_PROTECT;
d2335 1
a2335 1
    ruby_class = module;
d2338 1
a2338 1
    if (node->nd_rval) ruby_frame->cbase = node->nd_rval;
d2340 1
a2340 1
	VALUE *vars = TMP_ALLOC(node->nd_tbl[0]+1);
d2342 3
a2344 3
	ruby_scope->local_vars = vars;
	rb_mem_clear(ruby_scope->local_vars, node->nd_tbl[0]);
	ruby_scope->local_tbl = node->nd_tbl;
d2347 2
a2348 2
	ruby_scope->local_vars = 0;
	ruby_scope->local_tbl  = 0;
d2355 1
a2355 1
			    ruby_class, ruby_frame->last_func, 0);
d2357 1
a2357 1
	result = rb_eval(ruby_class, node->nd_next);
d2363 1
a2363 1
    ruby_frame->cbase = save;
d2365 1
a2365 1
	call_trace_func("end", file, line, 0, ruby_frame->last_func, 0);
d2378 1
a2378 1
	return Qtrue;
d2380 1
a2380 1
    return Qfalse;
d2384 1
a2384 1
rb_obj_respond_to(argc, argv, obj)
d2395 1
a2395 1
	return Qtrue;
d2397 1
a2397 1
    return Qfalse;
d2401 1
a2401 1
rb_mod_method_defined(mod, mid)
d2405 1
a2405 1
	return Qtrue;
d2407 1
a2407 1
    return Qfalse;
d2416 1
a2416 1
	rb_exc_raise(rb_exc_new(rb_eSystemExit, 0, 0));
d2422 1
a2422 1
rb_f_exit(argc, argv, obj)
d2429 1
a2429 1
    rb_secure(4);
d2437 1
a2437 1
    return Qnil;		/* not reached */
d2440 2
a2441 2
static void
rb_abort()
d2443 2
a2444 1
    if (rb_errinfo) {
d2448 1
a2448 8
}

static VALUE
rb_f_abort()
{
    rb_secure(4);
    rb_abort();
    return Qnil;		/* not reached */
d2457 28
a2484 2
static void rb_longjmp _((int, VALUE)) NORETURN;
static VALUE make_backtrace _((void));
d2487 1
a2487 1
rb_longjmp(tag, mesg)
d2489 1
a2489 1
    VALUE mesg;
d2491 2
a2492 5
    VALUE at;

    if (NIL_P(mesg)) mesg = rb_errinfo;
    if (NIL_P(mesg)) {
	mesg = rb_exc_new(rb_eRuntimeError, 0, 0);
d2495 2
a2496 6
    if (ruby_sourcefile && !NIL_P(mesg)) {
	at = get_backtrace(mesg);
	if (NIL_P(at)) {
	    at = make_backtrace();
	    set_backtrace(mesg, at);
	}
d2498 2
a2499 2
    if (!NIL_P(mesg)) {
	rb_errinfo = mesg;
d2502 8
a2509 5
    if (RTEST(rb_debug) && !NIL_P(rb_errinfo)
	&& !rb_obj_is_kind_of(rb_errinfo, rb_eSystemExit)) {
	fprintf(stderr, "Exception `%s' at %s:%d\n",
		rb_class2name(CLASS_OF(rb_errinfo)),
		ruby_sourcefile, ruby_sourceline);
a2511 8
    rb_trap_restore_mask();
    if (trace_func && tag != TAG_FATAL) {
	call_trace_func("raise", ruby_sourcefile, ruby_sourceline,
			ruby_frame->self, ruby_frame->last_func, 0);
    }
    if (!prot_tag) {
	error_print();
    }
d2516 1
a2516 1
rb_exc_raise(mesg)
d2519 1
a2519 1
    rb_longjmp(TAG_RAISE, mesg);
d2523 1
a2523 1
rb_exc_fatal(mesg)
d2526 1
a2526 1
    rb_longjmp(TAG_FATAL, mesg);
d2532 1
a2532 1
    rb_raise(rb_eInterrupt, "");
d2536 1
a2536 1
rb_f_raise(argc, argv)
d2541 1
a2541 1
    VALUE mesg;
d2544 1
d2550 1
d2552 7
a2558 1
      case 2:
d2564 3
a2566 5
	if (n == 1 && TYPE(mesg) == T_STRING) {
	    mesg = rb_exc_new3(rb_eRuntimeError, mesg);
	}
	else {
	    mesg = rb_funcall(arg1, rb_intern("new"), 1, mesg);
a2567 4
	if (!rb_obj_is_kind_of(mesg, rb_eException)) {
	    rb_raise(rb_eTypeError, "exception object expected");
	}
	set_backtrace(mesg, arg3);
d2571 2
a2572 2
    *ruby_frame = *_frame.prev->prev;
    rb_longjmp(TAG_RAISE, mesg);
a2573 9

    return Qnil;		/* not reached */
}

void
rb_jump_tag(tag)
    int tag;
{
    JUMP_TAG(tag);
d2577 1
a2577 1
rb_iterator_p()
d2579 2
a2580 2
    if (ruby_frame->iter) return Qtrue;
    return Qfalse;
d2584 1
a2584 1
rb_f_iterator_p()
d2586 2
a2587 2
    if (ruby_frame->prev && ruby_frame->prev->iter) return Qtrue;
    return Qfalse;
d2590 4
a2593 3
static VALUE
rb_yield_0(val, self, klass)
    VALUE val, self, klass;	/* OK */
d2601 1
a2601 1
    static unsigned serial = 1;
d2603 2
a2604 2
    if (!ruby_frame->iter || !ruby_block) {
	rb_raise(rb_eLocalJumpError, "yield called out of iterator");
d2609 1
a2609 1
    block = ruby_block;
d2611 7
a2617 7
    frame.prev = ruby_frame;
    ruby_frame = &(frame);
    old_scope = ruby_scope;
    ruby_scope = block->scope;
    ruby_block = block->prev;
    ruby_dyna_vars = block->d_vars;
    ruby_class = klass?klass:block->klass;
d2663 3
a2665 5
    ruby_block = block;
    ruby_frame = ruby_frame->prev;
    if (FL_TEST(ruby_scope, SCOPE_DONT_RECYCLE))
	FL_SET(old_scope, SCOPE_DONT_RECYCLE);
    ruby_scope = old_scope;
d2674 1
a2674 1
    return rb_yield_0(val, 0, 0);
d2678 1
a2678 1
rb_f_loop()
d2680 1
a2680 1
    for (;;) { rb_yield_0(Qnil, 0, 0); }
d2705 1
a2705 1
		assign(self, node->nd_args, rb_ary_new4(len-i, RARRAY(val)->ptr+i));
d2708 1
a2708 1
		assign(self, node->nd_args, rb_ary_new2(0));
d2738 3
a2740 3
	if (ruby_scope->local_vars == 0)
	    rb_bug("unexpected iterator variable assignment");
	ruby_scope->local_vars[lhs->nd_cnt] = val;
d2744 1
a2744 5
	rb_dvar_asgn(lhs->nd_vid, val);
	break;

      case NODE_DASGN_PUSH:
	dvar_asgn_push(lhs->nd_vid, val);
d2748 1
a2748 5
	rb_const_set(ruby_class, lhs->nd_vid, val);
	break;

      case NODE_MASGN:
	massign(self, lhs, val);
d2757 1
a2757 1
		rb_call(CLASS_OF(recv), recv, lhs->nd_mid, 1, &val, 0);
d2765 1
a2765 2
		rb_call(CLASS_OF(recv), recv, lhs->nd_mid,
			RARRAY(args)->len, RARRAY(args)->ptr, 0);
d2771 1
a2771 1
	rb_bug("bug in variable assignment");
d2784 1
a2784 1
    VALUE self = ruby_top_self;
d2795 1
a2795 1
    if (ruby_block->tag->dst == state) {
d2798 1
a2798 1
	    retval = prot_tag->retval;
a2830 1
    TMP_PROTECT;
d2833 1
a2833 1
	return rb_obj_is_kind_of(rb_errinfo, rb_eStandardError);
d2836 1
a2836 1
    BEGIN_CALLARGS;
d2838 1
a2838 2
    END_CALLARGS;

d2840 2
a2841 2
	if (!rb_obj_is_kind_of(argv[0], rb_cModule)) {
	    rb_raise(rb_eTypeError, "class or module required for rescue clause");
d2843 1
a2843 1
	if (rb_obj_is_kind_of(rb_errinfo, argv[0])) return 1;
a2855 1
    volatile VALUE e_info = rb_errinfo;
d2862 1
a2862 1
    else if (state == TAG_RAISE && rb_obj_is_kind_of(rb_errinfo, rb_eStandardError)) {
d2866 1
a2866 1
		result = (*r_proc)(data2, rb_errinfo);
d2879 1
a2879 1
	    rb_errinfo = e_info;
a2888 24
rb_protect(proc, data, state)
    VALUE (*proc)();
    VALUE data;
    int *state;
{
    VALUE result;		/* OK */
    int status;

    PUSH_TAG(PROT_NONE);
    if ((status = EXEC_TAG()) == 0) {
	result = (*proc)(data);
    }
    POP_TAG();
    if (state) {
	*state = status;
    }
    if (status != 0) {
	return Qnil;
    }

    return result;
}

VALUE
d2891 1
a2891 1
    VALUE (*e_proc)();
a2895 1
    VALUE retval;
d2902 1
a2902 1
    retval = prot_tag->retval;	/* save retval */
d2904 3
a2906 3
    return_value(retval);

    if (state) JUMP_TAG(state);
d2911 2
a2912 4

#define CSTAT_PRIV  1
#define CSTAT_PROT  2
#define CSTAT_VCALL 4
d2915 1
a2915 1
rb_f_missing(argc, argv, obj)
d2920 1
a2921 1
    VALUE desc = 0;
d2923 2
a2924 2
    char *file = ruby_sourcefile;
    int   line = ruby_sourceline;
d2934 1
a2934 1
	format = "undefined method `%s' for Qtrue";
d2937 1
a2937 1
	format = "undefined method `%s' for Qfalse";
d2940 1
a2940 1
	desc = rb_any_to_s(obj);
d2947 1
a2947 1
	if (last_call_status & CSTAT_PRIV) {
d2950 1
a2950 4
	if (last_call_status & CSTAT_PROT) {
	    format = "protected method `%s' called for %s";
	}
	else if (rb_iterator_p()) {
d2964 1
a2964 1
	    desc = rb_any_to_s(obj);
d2968 2
a2969 2
    ruby_sourcefile = file;
    ruby_sourceline = line;
d2971 1
a2971 1
    *ruby_frame = *_frame.prev->prev;
d2973 3
a2975 3
    rb_raise(rb_eNameError, format,
	     rb_id2name(id),
	     desc?(char*)RSTRING(desc)->ptr:"");
d3007 1
a3007 1
# define STACK_LEVEL_MAX 655300
d3010 1
a3010 1
extern VALUE *rb_gc_stack_start;
d3017 1
a3017 1
    return rb_gc_stack_start - &pos + 0x80;
d3019 2
a3020 2
    return (&pos < rb_gc_stack_start) ? rb_gc_stack_start - &pos
	                              : &pos - rb_gc_stack_start;
d3025 3
a3027 91
call_cfunc(func, recv, len, argc, argv)
    VALUE (*func)();
    VALUE recv;
    int len, argc;
    VALUE *argv;
{
    if (len >= 0 && argc != len) {
	rb_raise(rb_eArgError, "Wrong # of arguments(%d for %d)",
		 argc, len);
    }

    switch (len) {
      case -2:
	return (*func)(recv, rb_ary_new4(argc, argv));
	break;
      case -1:
	return (*func)(argc, argv, recv);
	break;
      case 0:
	return (*func)(recv);
	break;
      case 1:
	return (*func)(recv, argv[0]);
	break;
      case 2:
	return (*func)(recv, argv[0], argv[1]);
	break;
      case 3:
	return (*func)(recv, argv[0], argv[1], argv[2]);
	break;
      case 4:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3]);
	break;
      case 5:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4]);
	break;
      case 6:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5]);
	break;
      case 7:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6]);
	break;
      case 8:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7]);
	break;
      case 9:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8]);
	break;
      case 10:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9]);
	break;
      case 11:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10]);
	break;
      case 12:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9],
		       argv[10], argv[11]);
	break;
      case 13:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10],
		       argv[11], argv[12]);
	break;
      case 14:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10],
		       argv[11], argv[12], argv[13]);
	break;
      case 15:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10],
		       argv[11], argv[12], argv[13], argv[14]);
	break;
      default:
	rb_raise(rb_eArgError, "too many arguments(%d)", len);
	break;
    }
    return Qnil;		/* not reached */
}

static VALUE
rb_call0(klass, recv, id, argc, argv, body, nosuper)
    VALUE klass, recv;
    ID    id;
d3030 1
a3030 2
    NODE *body;			/* OK */
    int nosuper;
d3032 4
a3035 1
    NODE *b2;		/* OK */
d3038 1
a3039 1
    TMP_PROTECT;
d3041 18
a3058 1
    switch (ruby_iter->iter) {
d3068 18
a3085 4
    if ((++tick & 0x3ff) == 0) {
	CHECK_INTS;		/* better than nothing */
	if (stack_length() > STACK_LEVEL_MAX) {
	    rb_raise(rb_eSysStackError, "stack level too deep");
d3087 1
d3090 3
d3095 4
d3100 1
a3100 7
    ruby_frame->last_func = id;
    ruby_frame->last_class = nosuper?0:klass;
    ruby_frame->self = recv;
    ruby_frame->argc = argc;
    ruby_frame->argv = argv;

    switch (nd_type(body)) {
d3105 2
a3106 3
	    if (len < -2) {
		rb_bug("bad argc(%d) specified for `%s(%s)'",
		       len, rb_class2name(klass), rb_id2name(id));
d3108 96
a3203 7
	    if (trace_func) {
		int state;
		char *file = ruby_frame->prev->file;
		int line = ruby_frame->prev->line;
		if (!file) {
		    file = ruby_sourcefile;
		    line = ruby_sourceline;
d3205 2
a3206 5

		call_trace_func("c-call", 0, 0, 0, id, 0);
		PUSH_TAG(PROT_FUNC);
		if ((state = EXEC_TAG()) == 0) {
		    result = call_cfunc(body->nd_cfnc, recv, len, argc, argv);
d3208 1
a3208 6
		POP_TAG();
		call_trace_func("c-return", 0, 0, recv, id, klass);
		if (state) JUMP_TAG(state);
	    }
	    else {
		result = call_cfunc(body->nd_cfnc, recv, len, argc, argv);
a3212 2
	/* for re-scoped/renamed method */
      case NODE_ZSUPER:
d3226 1
a3226 1
	    if (body->nd_rval) ruby_frame->cbase = body->nd_rval;
d3228 1
a3228 1
		local_vars = TMP_ALLOC(body->nd_tbl[0]+1);
d3230 3
a3232 3
		rb_mem_clear(local_vars, body->nd_tbl[0]);
		ruby_scope->local_tbl = body->nd_tbl;
		ruby_scope->local_vars = local_vars;
d3235 2
a3236 2
		local_vars = ruby_scope->local_vars = 0;
		ruby_scope->local_tbl  = 0;
d3238 1
a3238 1
	    b2 = body = body->nd_next;
d3240 1
a3241 1
	    PUSH_TAG(PROT_FUNC);
d3244 3
a3246 2
		NODE *node = 0;
		int i;
a3247 9
		if (nd_type(body) == NODE_ARGS) {
		    node = body;
		    body = 0;
		}
		else if (nd_type(body) == NODE_BLOCK) {
		    node = body->nd_head;
		    body = body->nd_next;
		}
		if (node) {
d3249 1
a3249 1
			rb_bug("no argument-node");
d3252 1
d3255 1
a3255 2
			rb_raise(rb_eArgError, "Wrong # of arguments(%d for %d)",
				 argc, i);
d3266 1
a3266 1
			    rb_raise(rb_eArgError, "Wrong # of arguments(%d for %d)",
d3273 1
a3273 2
			    /* +2 for $_ and $~ */
			    MEMCPY(local_vars+2, argv, VALUE, i);
d3288 1
a3288 1
				local_vars[node->nd_rest]=rb_ary_new4(argc,argv);
d3290 1
a3290 1
				local_vars[node->nd_rest]=rb_ary_new2(0);
d3294 3
a3296 1

d3299 1
a3299 1
				    recv, ruby_frame->last_func, 0);
d3304 1
a3304 1
		result = prot_tag->retval;
d3307 1
a3308 1
	    POP_VARS();
d3311 2
a3312 2
		char *file = ruby_frame->prev->file;
		int line = ruby_frame->prev->line;
d3314 2
a3315 2
		    file = ruby_sourcefile;
		    line = ruby_sourceline;
d3317 1
a3317 2
		call_trace_func("return", file, line, recv,
				ruby_frame->last_func, klass);
d3324 1
a3324 1
		rb_raise(rb_eLocalJumpError, "unexpected next");
d3327 1
a3327 1
		rb_raise(rb_eLocalJumpError, "unexpected break");
d3330 1
a3330 1
		rb_raise(rb_eLocalJumpError, "unexpected redo");
d3333 2
a3334 2
		if (!rb_iterator_p()) {
		    rb_raise(rb_eLocalJumpError, "retry outside of rescue clause");
a3345 40
static VALUE
rb_call(klass, recv, mid, argc, argv, scope)
    VALUE klass, recv;
    ID    mid;
    int argc;			/* OK */
    VALUE *argv;		/* OK */
    int scope;
{
    NODE  *body;		/* OK */
    int    noex;
    ID     id = mid;
    struct cache_entry *ent;

    /* is it in the method cache? */
    ent = cache + EXPR1(klass, mid);
    if (ent->mid == mid && ent->klass == klass) {
	klass = ent->origin;
	id    = ent->mid0;
	noex  = ent->noex;
	body  = ent->method;
    }
    else if ((body = rb_get_method_body(&klass, &id, &noex)) == 0) {
	if (scope == 3) {
	    rb_raise(rb_eNameError, "super: no superclass method `%s'",
		     rb_id2name(mid));
	}
	return rb_undefined(recv, mid, argc, argv, scope==2?CSTAT_VCALL:0);
    }

    /* receiver specified form for private method */
    if ((noex & NOEX_PRIVATE) && scope == 0)
	return rb_undefined(recv, mid, argc, argv, CSTAT_PRIV);

    /* self must be kind of a specified form for private method */
    if ((noex & NOEX_PROTECTED) && !rb_obj_is_kind_of(ruby_frame->self, klass))
	return rb_undefined(recv, mid, argc, argv, CSTAT_PROT);

    return rb_call0(klass, recv, id, argc, argv, body, noex & NOEX_UNDEF);
}

d3362 1
a3362 1
rb_f_send(argc, argv, recv)
d3368 1
d3370 1
a3370 1
    if (argc == 0) rb_raise(rb_eArgError, "no method name given");
d3372 9
a3380 3
    vid = *argv++; argc--;
    PUSH_ITER(rb_iterator_p()?ITER_PRE:ITER_NOT);
    vid = rb_call(CLASS_OF(recv), recv, rb_to_id(vid), argc, argv, 1);
a3385 5

#ifdef HAVE_STDARG_PROTOTYPES
#include <stdarg.h>
#define va_init_list(a,b) va_start(a,b)
#else
a3386 2
#define va_init_list(a,b) va_start(a)
#endif
a3388 3
#ifdef HAVE_STDARG_PROTOTYPES
rb_funcall(VALUE recv, ID mid, int n, ...)
#else
a3393 1
#endif
d3403 1
a3403 1
	va_init_list(ar, n);
d3430 1
a3430 1
    struct FRAME *frame = ruby_frame;
d3436 1
a3436 1
    ary = rb_ary_new();
d3439 2
a3440 3
	    snprintf(buf, BUFSIZ, "%s:%d:in `%s'",
		     ruby_sourcefile, ruby_sourceline,
		     rb_id2name(frame->last_func));
d3443 1
a3443 1
	    snprintf(buf, BUFSIZ, "%s:%d", ruby_sourcefile, ruby_sourceline);
d3445 1
a3445 1
	rb_ary_push(ary, rb_str_new2(buf));
d3455 3
a3457 3
	    snprintf(buf, BUFSIZ, "%s:%d:in `%s'",
		     frame->file, frame->line,
		     rb_id2name(frame->prev->last_func));
d3460 1
a3460 1
	    snprintf(buf, BUFSIZ, "%s:%d", frame->file, frame->line);
d3462 1
a3462 1
	rb_ary_push(ary, rb_str_new2(buf));
d3470 1
a3470 1
rb_f_caller(argc, argv)
d3481 1
a3481 1
    if (lev < 0) rb_raise(rb_eArgError, "negative level(%d)", lev);
d3511 1
a3511 1
    return ruby_frame->last_func;
d3515 1
a3515 1
compile(src, place)
a3516 1
    char *place;
a3520 2
    if (place == 0) place = ruby_sourcefile;
    node = rb_compile_string(place, src);
d3522 3
a3524 1
    if (ruby_nerrs == 0) return node;
d3529 1
a3529 1
eval(self, src, scope, file, line)
a3530 2
    char *file;
    int line;
a3535 1
    struct BLOCK * volatile old_call_block;
a3536 1
    int volatile old_vmode;
d3538 3
a3540 3
    char *filesave = ruby_sourcefile;
    int linesave = ruby_sourceline;
    volatile int iter = ruby_frame->iter;
a3542 4
    if (file == 0) {
	file = ruby_sourcefile;
	line = ruby_sourceline;
    }
d3544 3
a3546 3
	if (!rb_obj_is_block(scope)) {
	    rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc/Binding)",
		     rb_class2name(CLASS_OF(scope)));
d3553 8
a3560 12
	frame.prev = ruby_frame;
	ruby_frame = &(frame);
	old_scope = ruby_scope;
	ruby_scope = data->scope;
	old_call_block = ruby_calling_block;
	ruby_calling_block = data;
	old_block = ruby_block;
	ruby_block = data->prev;
	old_d_vars = ruby_dyna_vars;
	ruby_dyna_vars = data->d_vars;
	old_vmode = scope_vmode;
	scope_vmode = data->vmode;
d3563 1
a3563 1
	ruby_frame->iter = data->iter;
d3566 2
a3567 2
	if (ruby_frame->prev) {
	    ruby_frame->iter = ruby_frame->prev->iter;
d3571 1
a3571 1
    ruby_class = ((NODE*)ruby_frame->cbase)->nd_clss;
d3574 2
a3575 2
    if (TYPE(ruby_class) == T_ICLASS) {
	ruby_class = RBASIC(ruby_class)->klass;
d3579 3
a3581 4
	ruby_sourcefile = file;
	ruby_sourceline = line;
	compile(src, file);
	if (ruby_nerrs > 0) {
d3590 4
a3593 10
	ruby_frame = ruby_frame->prev;
	if (FL_TEST(ruby_scope, SCOPE_DONT_RECYCLE))
	    FL_SET(old_scope, SCOPE_DONT_RECYCLE);
	ruby_scope = old_scope;
	ruby_block = old_block;
	ruby_calling_block = old_call_block;
	data->d_vars = ruby_dyna_vars;
	ruby_dyna_vars = old_d_vars;
	data->vmode = scope_vmode; /* write back visibility mode */
	scope_vmode = old_vmode;
d3596 1
a3596 1
	ruby_frame->iter = iter;
a3597 2
    ruby_sourcefile = filesave;
    ruby_sourceline = linesave;
d3599 2
d3602 5
a3606 6
	    VALUE err;
	    VALUE errat;

	    errat = get_backtrace(rb_errinfo);
	    if (strcmp(file, "(eval)") == 0) {
		if (ruby_sourceline > 1) {
d3608 2
a3609 5
		    rb_str_cat(err, ": ", 2);
		    rb_str_concat(err, rb_errinfo);
		}
		else {
		    err = rb_str_dup(rb_errinfo);
d3612 1
a3612 1
		rb_exc_raise(rb_exc_new3(CLASS_OF(rb_errinfo), err));
d3614 1
a3614 1
	    rb_exc_raise(rb_errinfo);
d3623 1
a3623 1
rb_f_eval(argc, argv, self)
d3628 3
a3630 12
    VALUE src, scope, vfile, vline;
    char *file = "(eval)";
    int line = 0;

    rb_scan_args(argc, argv, "13", &src, &scope, &vfile, &vline);
    if (argc >= 3) {
	Check_Type(vfile, T_STRING);
	file = RSTRING(vfile)->ptr;
    }
    if (argc >= 4) {
	line = NUM2INT(vline);
    }
d3633 1
a3633 1
    return eval(self, src, scope, file, line);
d3637 2
a3638 4
exec_under(func, under, args)
    VALUE (*func)();
    VALUE under;
    void *args;
d3642 1
a3642 2
    int mode;
    VALUE cbase = ruby_frame->cbase;
d3645 1
a3645 1
    ruby_class = under;
d3647 5
a3651 7
    ruby_frame->last_func = _frame.prev->last_func;
    ruby_frame->last_class = _frame.prev->last_class;
    ruby_frame->argc = _frame.prev->argc;
    ruby_frame->argv = _frame.prev->argv;
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,under,0,cbase);
    mode = scope_vmode;
    SCOPE_SET(SCOPE_PUBLIC);
d3654 1
a3654 1
	val = (*func)(args);
a3656 1
    SCOPE_SET(mode);
d3665 2
a3666 2
eval_under_i(args)
    VALUE *args;
d3668 1
a3668 1
    return eval(args[0], args[1], Qnil, (char*)args[2], (int)args[3]);
d3672 2
a3673 4
eval_under(under, self, src, file, line)
    VALUE under, self, src;
    char *file;
    int line;
d3675 1
a3675 96
    VALUE args[4];

    Check_SafeStr(src);
    args[0] = self;
    args[1] = src;
    args[2] = (VALUE)file;
    args[3] = (VALUE)line;
    return exec_under(eval_under_i, under, args);
}

static VALUE
yield_under_i(self)
    VALUE self;
{
    return rb_yield_0(self, self, ruby_class);
}

static VALUE
yield_under(under, self)
    VALUE under, self;
{
    rb_secure(4);
    return exec_under(yield_under_i, under, self);
}

VALUE
rb_obj_instance_eval(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    char *file = 0;
    int   line = 0;
    VALUE klass;

    if (argc == 0) {
	if (!rb_iterator_p()) {
	    rb_raise(rb_eArgError, "block not supplied");
	}
    }
    else if (argc < 4) {
	Check_SafeStr(argv[0]);
	if (argc > 1) file = STR2CSTR(argv[1]);
	if (argc > 2) line = NUM2INT(argv[2]);
    }
    else {
	rb_raise(rb_eArgError, "Wrong # of arguments: %s(src) or %s{..}",
		 rb_id2name(ruby_frame->last_func),
		 rb_id2name(ruby_frame->last_func));
    }

    if (rb_special_const_p(self)) {
	klass = Qnil;
    }
    else {
	klass = rb_singleton_class(self);
    }
    if (argc == 0) {
	return yield_under(klass, self);
    }
    else {
	return eval_under(klass, self, argv[0], file, line);
    }
}

static VALUE
rb_mod_module_eval(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    char *file = 0;
    int   line = 0;

    if (argc == 0) {
	if (!rb_iterator_p()) {
	    rb_raise(rb_eArgError, "block not supplied");
	}
    }
    else if (argc < 4) {
	Check_SafeStr(argv[0]);
	if (argc > 1) file = STR2CSTR(argv[1]);
	if (argc > 2) line = NUM2INT(argv[2]);
    }
    else {
	rb_raise(rb_eArgError, "Wrong # of arguments: %s(src) or %s{..}",
		 rb_id2name(ruby_frame->last_func),
		 rb_id2name(ruby_frame->last_func));
    }

    if (argc == 0) {
	return yield_under(mod, mod);
    }
    else {
	return eval_under(mod, mod, argv[0], file, line);
    }
d3680 1
a3680 11
static int
is_absolute_path(path)
    char *path;
{
    if (path[0] == '/') return 1;
# if defined(MSDOS) || defined(NT) || defined(__human68k__)
    if (path[0] == '\\') return 1;
    if (strlen(path) > 2 && path[1] == ':') return 1;
# endif
    return 0;
}
d3687 1
a3687 1
    volatile VALUE vpath;
d3690 5
a3694 7
    if (is_absolute_path(file)) {
	FILE *f = fopen(file, "r");

	if (f == NULL) return 0;
	fclose(f);
	return file;
    }
d3703 7
a3709 5
	vpath = rb_ary_join(rb_load_path, rb_str_new2(RUBY_PATH_SEP));
	path = STR2CSTR(vpath);
	if (safe_level >= 2 && !rb_path_check(path)) {
	    rb_raise(rb_eSecurityError, "loading from unsefe path %s", path);
	}
d3718 3
a3720 4
void
rb_load(fname, wrap)
    VALUE fname;
    int wrap;
a3724 2
    VALUE self = ruby_top_self;
    TMP_PROTECT;
d3726 1
a3726 7
    if (wrap) {
	Check_Type(fname, T_STRING);
    }
    else {
	Check_SafeStr(fname);
    }
#ifndef __MACOS__
d3728 1
a3728 1
	fname = rb_file_s_expand_path(1, &fname);
a3729 1
#endif
d3731 1
a3731 3
    if (!file) {
	rb_raise(rb_eLoadError, "No such file to load -- %s", RSTRING(fname)->ptr);
    }
a3732 1
    PUSH_VARS();
d3735 1
a3735 14
    if (!wrap) {
	rb_secure(4);		/* should alter global state */
	ruby_class = rb_cObject;
    }
    else {
	/* load in anonymous module as toplevel */
	ruby_class = ruby_wrapper = rb_module_new();
	self = rb_obj_clone(ruby_top_self);
	rb_extend_object(self, ruby_class);
    }
    PUSH_FRAME();
    ruby_frame->last_func = 0;
    ruby_frame->self = ruby_top_self;
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,ruby_class,0,0);
d3737 1
a3737 1
    if (ruby_class == rb_cObject && top_scope->local_tbl) {
d3740 1
a3740 1
	VALUE *vars = TMP_ALLOC(len);
d3744 2
a3745 2
	ruby_scope->local_tbl = tbl;   /* copy toplevel scope */
	ruby_scope->local_vars = vars; /* will not alter toplevel variables */
d3748 1
a3748 1
    SCOPE_SET(SCOPE_PRIVATE);
d3751 2
a3752 1
    last_func = ruby_frame->last_func;
d3757 2
a3758 2
	if (ruby_nerrs == 0) {
	    eval_node(self);
d3761 3
a3763 4
    ruby_frame->last_func = last_func;
    if (ruby_scope->flag == SCOPE_ALLOCA && ruby_class == rb_cObject) {
	if (ruby_scope->local_tbl) /* toplevel was empty */
	    free(ruby_scope->local_tbl);
a3765 1
    POP_FRAME();
d3768 2
a3769 4
    POP_VARS();
    ruby_wrapper = 0;
    if (ruby_nerrs > 0) {
	rb_exc_raise(rb_errinfo);
a3771 9
}

void
rb_load_protect(fname, wrap, state)
    VALUE fname;
    int wrap;
    int *state;
{
    int status;
d3773 1
a3773 18
    PUSH_TAG(PROT_NONE);
    if ((status = EXEC_TAG()) == 0) {
	rb_load(fname, wrap);
    }
    POP_TAG();
    if (state) *state = status;
}

static VALUE
rb_f_load(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE fname, wrap;

    rb_scan_args(argc, argv, "11", &fname, &wrap);
    rb_load(fname, RTEST(wrap));
    return Qtrue;
d3782 1
d3787 2
a3788 2
    p = RARRAY(rb_features)->ptr;
    pend = p + RARRAY(rb_features)->len;
d3790 3
a3792 2
	f = STR2CSTR(*p);
	if (strcmp(f, feature) == 0) return Qtrue;
d3795 2
a3796 2
	    && (strcmp(f+len, ".rb") == 0 ||strcmp(f+len, ".so") == 0)) {
	    return Qtrue;
d3800 1
a3800 1
    return Qfalse;
d3803 3
a3805 3
#ifdef USE_THREAD
static int rb_thread_loading _((char*));
static void rb_thread_loading_done _((void));
d3816 2
a3817 2
	if (ext && strcmp(DLEXT, ext) == 0) {
	    buf = ALLOCA_N(char, strlen(feature)+4);
d3820 1
a3820 1
	    strcpy(ext, ".so");
d3823 1
a3823 1
	rb_ary_push(rb_features, rb_str_new2(feature));
d3828 1
a3828 1
rb_f_require(obj, fname)
d3832 1
a3832 1
    volatile VALUE load;
a3833 1
    rb_secure(4);
d3836 1
a3836 1
	return Qfalse;
d3845 1
a3845 1
	else if (strcmp(".so", ext) == 0 || strcmp(".o", ext) == 0) {
d3847 1
a3847 1
	    if (strcmp(ext, DLEXT) != 0) {
d3852 1
a3852 1
		file = feature = buf;
a3853 1
	    file = find_file(file);
d3863 1
a3863 2
    strcpy(buf, RSTRING(fname)->ptr);
    strcat(buf, ".rb");
d3866 1
a3866 1
	fname = rb_str_new2(file);
d3870 1
a3870 2
    strcpy(buf, RSTRING(fname)->ptr);
    strcat(buf, DLEXT);
d3876 1
a3876 2
    rb_raise(rb_eLoadError, "No such file to load -- %s",
	     RSTRING(fname)->ptr);
d3879 2
a3880 2
#ifdef USE_THREAD
    if (rb_thread_loading(feature)) return Qfalse;
d3886 1
a3886 1
	    load = rb_str_new2(file);
d3890 1
a3890 1
#ifdef USE_THREAD
d3893 1
a3893 1
	rb_thread_loading_done();
d3897 1
a3897 1
    return Qtrue;
d3900 2
a3901 2
#ifdef USE_THREAD
    if (rb_thread_loading(feature)) return Qfalse;
d3907 1
a3907 1
	    rb_load(fname, 0);
d3909 1
a3909 1
#ifdef USE_THREAD
d3912 1
a3912 1
	rb_thread_loading_done();
d3916 1
a3916 1
    return Qtrue;
d3924 1
a3924 1
    ID ex;
d3934 1
a3934 1
rb_mod_public(argc, argv, module)
d3940 1
a3940 1
	SCOPE_SET(SCOPE_PUBLIC);
d3949 1
a3949 16
rb_mod_protected(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    if (argc == 0) {
	SCOPE_SET(SCOPE_PROTECTED);
    }
    else {
	set_method_visibility(module, argc, argv, NOEX_PROTECTED);
    }
    return module;
}

static VALUE
rb_mod_private(argc, argv, module)
d3955 1
a3955 1
	SCOPE_SET(SCOPE_PRIVATE);
d3964 1
a3964 1
rb_mod_public_method(argc, argv, obj)
d3974 1
a3974 1
rb_mod_private_method(argc, argv, obj)
d3988 1
a3988 1
    return rb_mod_public(argc, argv, rb_cObject);
d3996 1
a3996 1
    return rb_mod_private(argc, argv, rb_cObject);
d4000 1
a4000 1
rb_mod_modfunc(argc, argv, module)
d4009 1
a4009 5
    if (argc == 0) {
	SCOPE_SET(SCOPE_MODFUNC);
	return module;
    }

d4015 2
a4016 2
	    rb_raise(rb_eNameError, "undefined method `%s' for module `%s'",
		     rb_id2name(id), rb_class2name(module));
a4017 1
	rb_clear_cache_by_id(id);
d4024 1
a4024 1
rb_mod_append_features(module, include)
d4041 1
a4041 1
rb_mod_include(argc, argv, module)
a4054 9
void
rb_obj_call_init(obj)
    VALUE obj;
{
    PUSH_ITER(rb_iterator_p()?ITER_PRE:ITER_NOT);
    rb_funcall2(obj, init, ruby_frame->argc, ruby_frame->argv);
    POP_ITER();
}

d4056 1
a4056 1
rb_class_new_instance(argc, argv, klass)
d4059 1
a4059 1
    VALUE klass;
d4063 2
a4064 2
    if (FL_TEST(klass, FL_SINGLETON)) {
	rb_raise(rb_eTypeError, "can't create instance of virtual class");
d4066 4
a4069 3
    obj = rb_obj_alloc(klass);
    rb_obj_call_init(obj);

d4079 1
a4079 1
    return rb_mod_include(argc, argv, rb_cObject);
d4090 1
a4090 1
rb_mod_extend_object(mod, obj)
d4098 1
a4098 1
rb_obj_extend(argc, argv, obj)
d4112 2
a4113 14
VALUE rb_f_trace_var();
VALUE rb_f_untrace_var();

static void
errinfo_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    if (!rb_obj_is_kind_of(val, rb_eException)) {
	rb_raise(rb_eTypeError, "assigning non-exception to $!");
    }
    *var = val;
}
d4115 1
a4115 6
static VALUE
errat_getter(id)
    ID id;
{
    return get_backtrace(rb_errinfo);
}
d4123 1
a4123 4
    if (NIL_P(rb_errinfo)) {
	rb_raise(rb_eArgError, "$! not set");
    }
    set_backtrace(rb_errinfo, val);
d4126 3
a4128 33
VALUE rb_f_global_variables();
VALUE f_instance_variables();

static VALUE
rb_f_local_variables()
{
    ID *tbl;
    int n, i;
    VALUE ary = rb_ary_new();
    struct RVarmap *vars;

    tbl = ruby_scope->local_tbl;
    if (tbl) {
	n = *tbl++;
	for (i=2; i<n; i++) {	/* skip first 2 ($_ and $~) */
	    if (tbl[i] == 0) continue;  /* skip flip states */
	    rb_ary_push(ary, rb_str_new2(rb_id2name(tbl[i])));
	}
    }

    vars = ruby_dyna_vars;
    while (vars) {
	if (vars->id) {
	    rb_ary_push(ary, rb_str_new2(rb_id2name(vars->id)));
	}
	vars = vars->next;
    }

    return ary;
}

static VALUE rb_f_catch _((VALUE,VALUE));
static VALUE rb_f_throw _((int,VALUE*)) NORETURN;
d4134 1
a4134 2
};
static struct end_proc_data *end_proc_data;
d4158 1
a4158 1
rb_f_END()
d4161 1
a4161 2
    ruby_frame->argc = 0;
    rb_set_end_proc(call_end_proc, rb_f_lambda());
d4166 1
a4166 1
rb_f_at_exit()
d4170 1
a4170 1
    proc = rb_f_lambda();
d4199 3
a4201 4
    rb_global_variable((VALUE*)&ruby_eval_tree_begin);

    rb_global_variable((VALUE*)&ruby_eval_tree);
    rb_global_variable((VALUE*)&ruby_dyna_vars);
d4203 2
a4204 2
    rb_define_virtual_variable("$@@", errat_getter, errat_setter);
    rb_define_hooked_variable("$!", &rb_errinfo, 0, errinfo_setter);
d4206 4
a4209 4
    rb_define_global_function("eval", rb_f_eval, -1);
    rb_define_global_function("iterator?", rb_f_iterator_p, 0);
    rb_define_global_function("method_missing", rb_f_missing, -1);
    rb_define_global_function("loop", rb_f_loop, 0);
d4211 1
a4211 1
    rb_define_method(rb_mKernel, "respond_to?", rb_obj_respond_to, -1);
d4213 2
a4214 2
    rb_define_global_function("raise", rb_f_raise, -1);
    rb_define_global_function("fail", rb_f_raise, -1);
d4216 1
a4216 1
    rb_define_global_function("caller", rb_f_caller, -1);
d4218 2
a4219 2
    rb_define_global_function("exit", rb_f_exit, -1);
    rb_define_global_function("abort", rb_f_abort, 0);
d4221 1
a4221 1
    rb_define_global_function("at_exit", rb_f_at_exit, 0);
d4223 3
a4225 4
    rb_define_global_function("catch", rb_f_catch, 1);
    rb_define_global_function("throw", rb_f_throw, -1);
    rb_define_global_function("global_variables", rb_f_global_variables, 0);
    rb_define_global_function("local_variables", rb_f_local_variables, 0);
d4227 2
a4228 3
    rb_define_method(rb_mKernel, "send", rb_f_send, -1);
    rb_define_method(rb_mKernel, "__send__", rb_f_send, -1);
    rb_define_method(rb_mKernel, "instance_eval", rb_obj_instance_eval, -1);
d4230 10
a4239 12
    rb_define_private_method(rb_cModule, "append_features", rb_mod_append_features, 1);
    rb_define_private_method(rb_cModule, "extend_object", rb_mod_extend_object, 1);
    rb_define_private_method(rb_cModule, "include", rb_mod_include, -1);
    rb_define_private_method(rb_cModule, "public", rb_mod_public, -1);
    rb_define_private_method(rb_cModule, "protected", rb_mod_protected, -1);
    rb_define_private_method(rb_cModule, "private", rb_mod_private, -1);
    rb_define_private_method(rb_cModule, "module_function", rb_mod_modfunc, -1);
    rb_define_method(rb_cModule, "method_defined?", rb_mod_method_defined, 1);
    rb_define_method(rb_cModule, "public_class_method", rb_mod_public_method, -1);
    rb_define_method(rb_cModule, "private_class_method", rb_mod_private_method, -1);
    rb_define_method(rb_cModule, "module_eval", rb_mod_module_eval, -1);
    rb_define_method(rb_cModule, "class_eval", rb_mod_module_eval, -1);
d4241 3
a4243 3
    rb_define_private_method(rb_cModule, "remove_method", rb_mod_remove_method, 1);
    rb_define_private_method(rb_cModule, "undef_method", rb_mod_undef_method, 1);
    rb_define_private_method(rb_cModule, "alias_method", rb_mod_alias_method, 2);
d4245 2
a4246 2
    rb_define_singleton_method(rb_cModule, "nesting", rb_mod_nesting, 0);
    rb_define_singleton_method(rb_cModule, "constants", rb_mod_s_constants, 0);
d4248 3
a4250 3
    rb_define_singleton_method(ruby_top_self, "include", top_include, -1);
    rb_define_singleton_method(ruby_top_self, "public", top_public, -1);
    rb_define_singleton_method(ruby_top_self, "private", top_private, -1);
d4252 1
a4252 1
    rb_define_method(rb_mKernel, "extend", rb_obj_extend, -1);
d4254 2
a4255 2
    rb_define_global_function("trace_var", rb_f_trace_var, -1);
    rb_define_global_function("untrace_var", rb_f_untrace_var, -1);
d4262 1
a4262 1
VALUE rb_f_autoload();
d4267 1
a4267 1
    rb_load_path = rb_ary_new();
d4272 1
a4272 1
    rb_features = rb_ary_new();
d4275 3
a4277 4
    rb_define_global_function("load", rb_f_load, -1);
    rb_define_global_function("require", rb_f_require, 1);
    rb_define_global_function("autoload", rb_f_autoload, 2);
    rb_global_variable(&ruby_wrapper);
d4306 6
a4311 10
    while (data) {
	rb_gc_mark_frame(&data->frame);
	rb_gc_mark(data->scope);
	rb_gc_mark(data->var);
	rb_gc_mark(data->body);
	rb_gc_mark(data->self);
	rb_gc_mark(data->d_vars);
	rb_gc_mark(data->klass);
	data = data->prev;
    }
d4318 1
a4318 8
    struct BLOCK *tmp;

    while (data) {
	free(data->frame.argv);
	tmp = data;
	data = data->prev;
	free(tmp);
    }
a4320 17
static void
blk_copy_prev(block)
    struct BLOCK *block;
{
    struct BLOCK *tmp;

    while (block->prev) {
	tmp = ALLOC_N(struct BLOCK, 1);
	MEMCPY(tmp, block->prev, struct BLOCK, 1);
	tmp->frame.argv = ALLOC_N(VALUE, tmp->frame.argc);
	MEMCPY(tmp->frame.argv, block->frame.argv, VALUE, tmp->frame.argc);
	block->prev = tmp;
	block = tmp;
    }
}


d4322 1
a4322 24
bind_clone(self)
    VALUE self;
{
    struct BLOCK *orig, *data;
    VALUE bind;

    Data_Get_Struct(self, struct BLOCK, orig);
    bind = Data_Make_Struct(self,struct BLOCK,blk_mark,blk_free,data);
    MEMCPY(data, orig, struct BLOCK, 1);
    data->frame.argv = ALLOC_N(VALUE, orig->frame.argc);
    MEMCPY(data->frame.argv, orig->frame.argv, VALUE, orig->frame.argc);

    if (data->iter) {
	blk_copy_prev(data);
    }
    else {
	data->prev = 0;
    }

    return bind;
}

static VALUE
rb_f_binding(self)
d4329 2
a4330 2
    bind = Data_Make_Struct(rb_cBinding,struct BLOCK,blk_mark,blk_free,data);
    *data = *ruby_block;
d4332 2
a4333 7
#ifdef USE_THREAD
    data->orig_thread = rb_thread_current();
#endif
    data->iter = rb_f_iterator_p();
    if (ruby_frame->prev) {
	data->frame.last_func = ruby_frame->prev->last_func;
    }
d4335 1
a4335 8
    MEMCPY(data->frame.argv, ruby_block->frame.argv, VALUE, data->frame.argc);

    if (data->iter) {
	blk_copy_prev(data);
    }
    else {
	data->prev = 0;
    }
d4343 1
a4348 38
static void
proc_save_safe_level(data)
    VALUE data;
{
    if (FL_TEST(data, FL_TAINT)) {
	switch (safe_level) {
	  case 3:
	    FL_SET(data, PROC_T3);
	    break;
	  case 4:
	    FL_SET(data, PROC_T4);
	    break;
	  case 5:
	    FL_SET(data, PROC_T5);
	    break;
	}
    }
}

static void
proc_set_safe_level(data)
    VALUE data;
{
    if (FL_TEST(data, FL_TAINT)) {
	switch (RBASIC(data)->flags & PROC_TMASK) {
	  case PROC_T3:
	    safe_level = 3;
	    break;
	  case PROC_T4:
	    safe_level = 4;
	    break;
	  case PROC_T5:
	    safe_level = 5;
	    break;
	}
    }
}

d4350 2
a4351 2
proc_s_new(klass)
    VALUE klass;
d4356 2
a4357 2
    if (!rb_iterator_p() && !rb_f_iterator_p()) {
	rb_raise(rb_eArgError, "tried to create Procedure-Object out of iterator");
d4360 2
a4361 2
    proc = Data_Make_Struct(klass, struct BLOCK, blk_mark, blk_free, data);
    *data = *ruby_block;
d4363 2
a4364 2
#ifdef USE_THREAD
    data->orig_thread = rb_thread_current();
d4366 1
a4366 1
    data->iter = data->prev?Qtrue:Qfalse;
d4368 1
a4368 7
    MEMCPY(data->frame.argv, ruby_block->frame.argv, VALUE, data->frame.argc);
    if (data->iter) {
	blk_copy_prev(data);
    }
    else {
	data->prev = 0;
    }
d4371 14
a4384 2
    proc_save_safe_level(proc);
    rb_obj_call_init(proc);
d4390 1
a4390 8
rb_f_lambda()
{
    return proc_s_new(rb_cProc);
}

static int
blk_orphan(data)
    struct BLOCK *data;
d4392 1
a4392 10
    if (data->scope && data->scope != top_scope &&
	(data->scope->flag & SCOPE_NOSTACK)) {
	return 1;
    }
#ifdef USE_THREAD
    if (data->orig_thread != rb_thread_current()) {
	return 1;
    }
#endif
    return 0;
a4398 1
    struct BLOCK * volatile old_block;
a4416 7
    orphan = blk_orphan(data);

    /* PUSH BLOCK from data */
    old_block = ruby_block;
    ruby_block = data;
    PUSH_ITER(ITER_CUR);
    ruby_frame->iter = ITER_CUR;
d4418 12
d4431 2
a4432 2
	if (rb_iterator_p()) {
	    ruby_block->frame.iter = ITER_CUR;
d4435 1
a4435 1
	    ruby_block->frame.iter = ITER_NOT;
d4439 16
a4454 151
    PUSH_TAG(PROT_NONE);
    state = EXEC_TAG();
    if (state == 0) {
	proc_set_safe_level(proc);
	result = rb_yield_0(args, 0, 0);
    }
    POP_TAG();

    POP_ITER();
    if (ruby_block->tag->dst == state) {
	state &= TAG_MASK;
    }
    ruby_block = old_block;
    safe_level = safe;

    if (state) {
	if (orphan) {/* orphan procedure */
	    switch (state) {
	      case TAG_BREAK:
		rb_raise(rb_eLocalJumpError, "break from proc-closure");
		break;
	      case TAG_RETRY:
		rb_raise(rb_eLocalJumpError, "retry from proc-closure");
		break;
	      case TAG_RETURN:
		rb_raise(rb_eLocalJumpError, "return from proc-closure");
		break;
	    }
	}
	JUMP_TAG(state);
    }
    return result;
}

static VALUE
block_pass(self, node)
    VALUE self;
    NODE *node;
{
    VALUE block = rb_eval(self, node->nd_body);
    struct BLOCK * volatile old_block;
    struct BLOCK *data;
    volatile VALUE result = Qnil;
    int state;
    volatile int orphan;
    volatile int safe = safe_level;

    if (NIL_P(block)) {
	return rb_eval(self, node->nd_iter);
    }
    if (rb_obj_is_kind_of(block, rb_cMethod)) {
	block = method_proc(block);
    }
    else if (!rb_obj_is_proc(block)) {
	rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc)",
		 rb_class2name(CLASS_OF(block)));
    }

    Data_Get_Struct(block, struct BLOCK, data);
    orphan = blk_orphan(data);

    /* PUSH BLOCK from data */
    old_block = ruby_block;
    ruby_block = data;
    PUSH_ITER(ITER_PRE);
    ruby_frame->iter = ITER_PRE;

    PUSH_TAG(PROT_NONE);
    state = EXEC_TAG();
    if (state == 0) {
	proc_set_safe_level(block);
	result = rb_eval(self, node->nd_iter);
    }
    POP_TAG();
    POP_ITER();
    if (ruby_block->tag->dst == state) {
	state &= TAG_MASK;
	orphan = 2;
    }
    ruby_block = old_block;
    safe_level = safe;

    if (state) {
	if (orphan == 2) {/* escape from orphan procedure */
	    switch (state) {
	      case TAG_BREAK:
		rb_raise(rb_eLocalJumpError, "break from proc-closure");
		break;
	      case TAG_RETRY:
		rb_raise(rb_eLocalJumpError, "retry from proc-closure");
		break;
	      case TAG_RETURN:
		rb_raise(rb_eLocalJumpError, "return from proc-closure");
		break;
	    }
	}
	JUMP_TAG(state);
    }
    return result;
}

struct METHOD {
    VALUE klass, oklass;
    VALUE recv;
    ID id, oid;
    NODE *body;
};

static void
bm_mark(data)
    struct METHOD *data;
{
    rb_gc_mark(data->oklass);
    rb_gc_mark(data->klass);
    rb_gc_mark(data->recv);
    rb_gc_mark(data->body);
}

static VALUE
rb_obj_method(obj, vid)
    VALUE obj;
    VALUE vid;
{
    VALUE method;
    VALUE klass = CLASS_OF(obj);
    ID id;
    NODE *body;
    int noex;
    struct METHOD *data;

    id = rb_to_id(vid);

  again:
    if ((body = rb_get_method_body(&klass, &id, &noex)) == 0) {
	return rb_undefined(obj, rb_to_id(vid), 0, 0, 0);
    }

    if (nd_type(body) == NODE_ZSUPER) {
	klass = RCLASS(klass)->super;
	goto again;
    }

    method = Data_Make_Struct(rb_cMethod, struct METHOD, bm_mark, free, data);
    data->klass = klass;
    data->recv = obj;
    data->id = id;
    data->body = body;
    data->oklass = CLASS_OF(obj);
    data->oid = rb_to_id(vid);
    if (FL_TEST(obj, FL_TAINT)) {
	FL_SET(method, FL_TAINT);
a4456 16
    return method;
}

static VALUE
method_call(argc, argv, method)
    int argc;
    VALUE *argv;
    VALUE method;
{
    VALUE result;
    struct METHOD *data;
    int state;
    volatile int safe = safe_level;

    Data_Get_Struct(method, struct METHOD, data);
    PUSH_ITER(rb_iterator_p()?ITER_PRE:ITER_NOT);
d4458 3
a4460 7
    if (FL_TEST(data->recv, FL_TAINT) || FL_TEST(method, FL_TAINT)) {
	FL_SET(method, FL_TAINT);
	if (safe_level < 4) safe_level = 4;
    }
    if ((state = EXEC_TAG()) == 0) {
	result = rb_call0(data->klass, data->recv, data->id,
			  argc, argv, data->body, 0);
d4463 1
d4465 4
a4469 3
    if (state) JUMP_TAG(state);
    return result;
}
d4471 15
a4485 44
static VALUE
method_inspect(method)
    VALUE method;
{
    struct METHOD *data;
    VALUE str;
    char *s;

    Data_Get_Struct(method, struct METHOD, data);
    str = rb_str_new2("#<");
    s = rb_class2name(CLASS_OF(method));
    rb_str_cat(str, s, strlen(s));
    rb_str_cat(str, ": ", 2);
    s = rb_class2name(data->oklass);
    rb_str_cat(str, s, strlen(s));
    rb_str_cat(str, "#", 1);
    s = rb_id2name(data->oid);
    rb_str_cat(str, s, strlen(s));
    rb_str_cat(str, ">", 1);

    return str;
}

static VALUE
mproc()
{
    VALUE proc;

    /* emulate ruby's method call */
    PUSH_ITER(ITER_CUR);
    PUSH_FRAME();
    proc = rb_f_lambda();
    POP_FRAME();
    POP_ITER();

    return proc;
}

static VALUE
mcall(args, method)
    VALUE args, method;
{
    if (TYPE(args) == T_ARRAY) {
	return method_call(RARRAY(args)->len, RARRAY(args)->ptr, method);
d4487 1
a4487 8
    return method_call(1, &args, method);
}

static VALUE
method_proc(method)
    VALUE method;
{
    return rb_iterate(mproc, 0, mcall, method);
d4493 1
a4493 2
    rb_eLocalJumpError = rb_define_class("LocalJumpError", rb_eStandardError);
    rb_eSysStackError = rb_define_class("SystemStackError", rb_eStandardError);
d4495 2
a4496 2
    rb_cProc = rb_define_class("Proc", rb_cObject);
    rb_define_singleton_method(rb_cProc, "new", proc_s_new, 0);
d4498 4
a4501 17
    rb_define_method(rb_cProc, "call", proc_call, -2);
    rb_define_method(rb_cProc, "[]", proc_call, -2);
    rb_define_global_function("proc", rb_f_lambda, 0);
    rb_define_global_function("lambda", rb_f_lambda, 0);
    rb_define_global_function("binding", rb_f_binding, 0);
    rb_cBinding = rb_define_class("Binding", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cMethod), "new");
    rb_define_method(rb_cBinding, "clone", bind_clone, 0);

    rb_cMethod = rb_define_class("Method", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cMethod), "new");
    rb_define_method(rb_cMethod, "call", method_call, -1);
    rb_define_method(rb_cMethod, "[]", method_call, -1);
    rb_define_method(rb_cMethod, "inspect", method_inspect, 0);
    rb_define_method(rb_cMethod, "to_s", method_inspect, 0);
    rb_define_method(rb_cMethod, "to_proc", method_proc, 0);
    rb_define_method(rb_mKernel, "method", rb_obj_method, 1);
d4504 1
a4504 1
#ifdef USE_THREAD
d4506 1
a4506 1
static VALUE rb_eThreadError;
d4508 1
a4508 1
int rb_thread_pending = 0;
d4510 1
a4510 1
VALUE rb_cThread;
d4530 1
a4530 1
extern VALUE rb_last_status;
a4562 1
    struct BLOCK *cblock;
d4565 1
a4565 2
    VALUE klass;
    VALUE wrapper;
a4567 1
    int misc;			/* misc. states (vmode/rb_trap_immediate) */
d4572 1
a4572 1
    VALUE rb_errinfo;
d4579 1
a4579 1
    enum thread_status status;
a4586 2
    st_table *locals;

d4622 1
a4622 16
    rb_gc_mark(th->result);
    rb_gc_mark(th->thread);
    if (th->join) rb_gc_mark(th->join->thread);

    rb_gc_mark(th->klass);
    rb_gc_mark(th->wrapper);

    rb_gc_mark(th->scope);
    rb_gc_mark(th->dyna_vars);
    rb_gc_mark(th->rb_errinfo);
    rb_gc_mark(th->last_line);
    rb_gc_mark(th->last_match);

    /* mark data in copied stack */
    if (th->status == THREAD_KILLED) return;
    if (th->stk_len == 0) return;  /* stack not active, no need to mark. */
d4624 1
a4624 1
	rb_gc_mark_locations(th->stk_ptr, th->stk_ptr+th->stk_len);
d4626 1
a4626 1
	rb_gc_mark_locations(th->stk_ptr+2, th->stk_ptr+th->stk_len+2);
d4629 11
d4644 1
a4644 1
	    rb_gc_mark_frame(frame);
d4652 1
a4652 1
	    rb_gc_mark_frame(&block->frame);
a4655 1
    rb_mark_tbl(th->locals);
d4659 1
a4659 1
rb_gc_mark_threads()
a4662 1
    if (!curr_thread) return;
d4664 1
a4664 1
	rb_gc_mark(th->thread);
a4673 2
    if (th->locals) st_free_table(th->locals);
    if (th != main_thread) free(th);
d4677 1
a4677 1
rb_thread_check(data)
d4681 2
a4682 2
	rb_raise(rb_eTypeError, "wrong argument type %s (expected Thread)",
		 rb_class2name(CLASS_OF(data)));
d4687 5
d4693 1
a4693 1
rb_thread_save_context(th)
d4698 6
a4703 7
    int len = stack_length();
    th->stk_len = 0;
    th->stk_pos = (rb_gc_stack_start<(VALUE*)&v)?rb_gc_stack_start
				                :rb_gc_stack_start - len;
    if (len > th->stk_max)  {
	REALLOC_N(th->stk_ptr, VALUE, len);
	th->stk_max = len;
d4705 1
a4705 2
    th->stk_len = len;
    FLUSH_REGISTER_WINDOWS; 
d4708 6
a4713 9
    th->frame = ruby_frame;
    th->scope = ruby_scope;
    th->klass = ruby_class;
    th->wrapper = ruby_wrapper;
    th->dyna_vars = ruby_dyna_vars;
    th->block = ruby_block;
    th->cblock = ruby_calling_block;
    th->misc = scope_vmode | (rb_trap_immediate<<8);
    th->iter = ruby_iter;
d4715 5
a4719 4
    th->rb_errinfo = rb_errinfo;
    th->last_status = rb_last_status;
    th->last_line = rb_lastline_get();
    th->last_match = rb_backref_get();
d4723 2
a4724 4
    th->file = ruby_sourcefile;
    th->line = ruby_sourceline;

    th->locals = 0;
d4727 1
a4727 1
static void rb_thread_restore_context _((thread_t,int));
d4737 1
a4737 1
    rb_thread_restore_context(th, exit);
a4743 2
static VALUE th_cmd;
static int   th_sig;
d4746 1
a4746 1
rb_thread_restore_context(th, exit)
d4754 1
a4754 1
    if (!th->stk_ptr) rb_bug("unsaved context");
d4756 1
a4756 1
    if (&v < rb_gc_stack_start) {
d4765 6
a4770 10
    ruby_frame = th->frame;
    ruby_scope = th->scope;
    ruby_class = th->klass;
    ruby_wrapper = th->wrapper;
    ruby_dyna_vars = th->dyna_vars;
    ruby_block = th->block;
    ruby_calling_block = th->cblock;
    scope_vmode = th->misc&SCOPE_MASK;
    rb_trap_immediate = th->misc>>8;
    ruby_iter = th->iter;
d4772 4
a4775 2
    rb_errinfo = th->rb_errinfo;
    rb_last_status = th->last_status;
d4779 2
a4780 2
    ruby_sourcefile = th->file;
    ruby_sourceline = th->line;
d4787 2
a4788 2
    rb_lastline_set(tmp->last_line);
    rb_backref_set(tmp->last_match);
d4800 4
a4803 9
	rb_trap_eval(th_cmd, th_sig);
	errno = EINTR;
	break;

      case 4:
	ruby_frame->last_func = 0;
	ruby_sourcefile = th_raise_file;
	ruby_sourceline = th_raise_line;
	rb_f_raise(th_raise_argc, th_raise_argv);
d4812 1
a4812 1
rb_thread_ready(th)
d4830 1
a4830 1
rb_thread_remove()
d4832 1
a4832 1
    rb_thread_ready(curr_thread);
d4836 1
d4840 1
a4840 1
rb_thread_dead(th)
d4847 1
a4847 1
rb_thread_deadlock()
d4851 4
a4854 4
    th_raise_argv[0] = rb_exc_new2(rb_eFatal, "Thread: deadlock");
    th_raise_file = ruby_sourcefile;
    th_raise_line = ruby_sourceline;
    rb_abort();
d4858 1
a4858 1
rb_thread_schedule()
d4865 1
a4865 1
    rb_thread_pending = 0;
d4875 1
a4875 1
    FOREACH_THREAD_FROM(curr, th) {
d4881 1
a4881 1
    END_FOREACH_FROM(curr, th); 
d4884 2
a4885 2
	FOREACH_THREAD_FROM(curr, th) {
	    if ((th->wait_for&WAIT_JOIN) && rb_thread_dead(th->join)) {
d4893 1
a4893 1
	END_FOREACH_FROM(curr, th);
d4907 1
a4907 1
		FOREACH_THREAD_FROM(curr, th) {
d4913 1
a4913 1
		END_FOREACH_FROM(curr, th);
d4919 1
a4919 1
		FOREACH_THREAD_FROM(curr, th) {
d4932 1
a4932 1
		END_FOREACH_FROM(curr, th);
d4949 1
a4949 1
		    delay_tv.tv_usec = (long)((delay-(double)delay_tv.tv_sec)*1e6);
d4955 1
a4955 1
		    if (rb_trap_pending) rb_trap_exec();
d4961 1
a4961 1
		    FOREACH_THREAD_FROM(curr, th) {
d4973 1
a4973 1
		    END_FOREACH_FROM(curr, th);
d4982 3
a4984 3
	curr_thread->file = ruby_sourcefile;
	curr_thread->line = ruby_sourceline;
	FOREACH_THREAD_FROM(curr, th) {
d4989 1
a4989 1
	END_FOREACH_FROM(curr, th);
d4991 1
a4991 1
	rb_thread_deadlock();
d4993 1
a4993 1
    if (next->status == THREAD_RUNNABLE && next == curr_thread) {
d4999 1
a4999 1
	rb_thread_save_context(curr);
d5008 1
a5008 1
	rb_thread_restore_context(next, 1);
d5010 1
a5010 1
    rb_thread_restore_context(next, 0);
d5014 1
a5014 1
rb_thread_wait_fd(fd)
d5023 1
a5023 1
    rb_thread_schedule();
d5027 1
a5027 1
rb_thread_fd_writable(fd)
d5040 1
a5040 1
	rb_thread_schedule();
d5045 1
a5045 1
rb_thread_wait_for(time)
d5068 1
a5068 1
		time.tv_usec += (long)1e6;
d5081 1
a5081 1
    rb_thread_schedule();
d5084 1
a5084 1
void rb_thread_sleep_forever _((void));
d5087 1
a5087 1
rb_thread_alone()
d5093 1
a5093 1
rb_thread_select(max, read, write, except, timeout)
d5105 1
a5105 1
	    rb_thread_sleep_forever();
d5108 1
a5108 1
	rb_thread_wait_for(*timeout);
d5134 1
a5134 1
		    tv.tv_usec = (long)((d-(double)tv.tv_sec)*1e6);
d5175 1
a5175 1
        rb_thread_schedule();
d5181 2
a5182 1
rb_thread_join(thread)
d5185 1
a5185 1
    thread_t th = rb_thread_check(thread);
d5187 1
a5187 1
    if (rb_thread_dead(th)) return thread;
d5189 1
a5189 1
	rb_raise(rb_eThreadError, "Thread#join: deadlock");
d5194 1
a5194 1
    rb_thread_schedule();
d5200 1
a5200 10
rb_thread_s_join(dmy, thread)	/* will be removed in 1.4 */
    VALUE dmy;
    VALUE thread;
{
    rb_warn("Thread::join is obsolete; use Thread#join instead");
    return rb_thread_join(thread);
}

VALUE
rb_thread_current()
d5205 2
a5206 2
VALUE
rb_thread_main()
d5212 1
a5212 1
rb_thread_wakeup(thread)
d5215 1
a5215 1
    thread_t th = rb_thread_check(thread);
d5217 2
a5218 3
    if (th->status == THREAD_KILLED)
	rb_raise(rb_eThreadError, "killed thread");
    rb_thread_ready(th);
d5224 1
a5224 1
rb_thread_run(thread)
d5227 2
a5228 2
    rb_thread_wakeup(thread);
    if (!rb_thread_critical) rb_thread_schedule();
d5234 1
a5234 1
rb_thread_kill(thread)
d5237 1
a5237 1
    thread_t th = rb_thread_check(thread);
d5243 1
a5243 1
    rb_thread_ready(th);
d5245 1
a5245 1
    rb_thread_schedule();
d5250 1
a5250 1
rb_thread_s_kill(obj, th)
d5253 1
a5253 1
    return rb_thread_kill(th);
d5257 1
a5257 1
rb_thread_exit()
d5259 1
a5259 1
    return rb_thread_kill(curr_thread->thread);
d5263 1
a5263 1
rb_thread_pass()
d5265 1
a5265 1
    rb_thread_schedule();
d5270 2
a5271 1
rb_thread_stop()
d5273 8
a5280 6
    rb_thread_critical = 0;
    curr_thread->status = THREAD_STOPPED;
    if (curr_thread == curr_thread->next) {
	rb_raise(rb_eThreadError, "stopping only thread");
    }
    rb_thread_schedule();
d5282 4
d5289 1
a5289 1
struct timeval rb_time_timeval();
d5292 1
a5292 1
rb_thread_sleep(sec)
d5301 1
a5301 1
    rb_thread_wait_for(rb_time_timeval(INT2FIX(sec)));
d5305 1
a5305 1
rb_thread_sleep_forever()
d5309 1
a5309 1
	sleep((32767L<<16)+32767);
d5318 1
a5318 1
    rb_thread_schedule();
d5321 1
a5321 1
static int rb_thread_abort;
d5324 1
a5324 1
rb_thread_s_abort_exc()
d5326 1
a5326 1
    return rb_thread_abort?Qtrue:Qfalse;
d5330 1
a5330 1
rb_thread_s_abort_exc_set(self, val)
d5333 1
a5333 1
    rb_thread_abort = RTEST(val);
d5338 1
a5338 1
rb_thread_abort_exc(thread)
d5341 1
a5341 1
    thread_t th = rb_thread_check(thread);
d5343 1
a5343 1
    return th->abort?Qtrue:Qfalse;
d5347 1
a5347 1
rb_thread_abort_exc_set(thread, val)
d5350 1
a5350 1
    thread_t th = rb_thread_check(thread);
d5357 1
a5357 2
rb_thread_alloc(klass)
    VALUE klass;
d5366 2
a5367 1
    th->rb_errinfo = Qnil;
d5379 1
a5379 2
    th->klass = 0;
    th->wrapper = 0;
d5384 2
a5385 1
    th->rb_errinfo = 0;
d5391 1
a5391 1
    th->thread = Data_Wrap_Struct(klass, thread_mark, thread_free, th);
d5415 4
a5418 3
    if (!rb_thread_critical) {
	if (rb_trap_immediate) {
	    rb_thread_schedule();
d5420 1
a5420 1
	else rb_thread_pending = 1;
d5424 1
a5424 1
int rb_thread_tick = THREAD_TICK;
d5427 2
a5428 34
static VALUE rb_thread_raise _((int, VALUE*, VALUE));

#define SCOPE_SHARED  FL_USER1

#if defined(HAVE_SETITIMER) && !defined(__BOW__)
static int thread_init = 0;

void
rb_thread_start_timer()
{
    struct itimerval tval;

    if (!thread_init) return;
    tval.it_interval.tv_sec = 0;
    tval.it_interval.tv_usec = 50000;
    tval.it_value = tval.it_interval;
    setitimer(ITIMER_VIRTUAL, &tval, NULL);
}

void
rb_thread_stop_timer()
{
    struct itimerval tval;

    if (!thread_init) return;
    tval.it_interval.tv_sec = 0;
    tval.it_interval.tv_usec = 0;
    tval.it_value = tval.it_interval;
    setitimer(ITIMER_VIRTUAL, &tval, NULL);
}
#endif

static VALUE
rb_thread_create_0(fn, arg, klass)
a5430 1
    VALUE klass;
d5432 1
a5432 2
    thread_t th = rb_thread_alloc(klass);
    enum thread_status status;
d5436 5
a5440 1
    if (!thread_init) {
d5447 6
a5452 2
	thread_init = 1;
	rb_thread_start_timer();
d5456 1
a5456 2
    FL_SET(ruby_scope, SCOPE_SHARED);
    rb_thread_save_context(curr_thread);
d5463 1
a5463 1
	rb_thread_save_context(th);
d5470 10
a5479 17
    status = th->status;
    rb_thread_remove();
    if (state && status != THREAD_TO_KILL && !NIL_P(rb_errinfo)) {
	if (state == TAG_FATAL) { 
	    /* fatal error within this thread, need to stop whole script */
	    main_thread->rb_errinfo = rb_errinfo;
	    rb_thread_cleanup();
	}
	else if (rb_obj_is_kind_of(rb_errinfo, rb_eSystemExit)) {
	    /* delegate exception to main_thread */
	    rb_thread_raise(1, &rb_errinfo, main_thread->thread);
	}
	else if (rb_thread_abort || curr_thread->abort || RTEST(rb_debug)) {
	    VALUE err = rb_exc_new(rb_eSystemExit, 0, 0);
	    error_print();
	    /* exit on main_thread */
	    rb_thread_raise(1, &err, main_thread->thread);
d5482 2
a5483 1
	    curr_thread->rb_errinfo = rb_errinfo;
d5486 2
a5487 16
    rb_thread_schedule();
    return 0;			/* not reached */
}

VALUE
rb_thread_create(fn, arg)
    VALUE (*fn)();
    void *arg;
{
    return rb_thread_create_0(fn, arg, rb_cThread);
}

int
rb_thread_scope_shared_p()
{
    return FL_TEST(ruby_scope, SCOPE_SHARED);
d5491 1
a5491 1
rb_thread_yield(arg, th) 
d5495 3
a5497 2
    scope_dup(ruby_block->scope);
    return rb_yield_0(th->thread, 0, 0);
d5501 1
a5501 2
rb_thread_start(klass)
    VALUE klass;
d5503 2
a5504 2
    if (!rb_iterator_p()) {
	rb_raise(rb_eThreadError, "must be called as iterator");
d5506 1
a5506 1
    return rb_thread_create_0(rb_thread_yield, 0, klass);
d5510 1
a5510 1
rb_thread_value(thread)
d5513 1
a5513 1
    thread_t th = rb_thread_check(thread);
d5515 6
a5520 8
    rb_thread_join(thread);
    if (!NIL_P(th->rb_errinfo)) {
	VALUE oldbt = get_backtrace(th->rb_errinfo);
	VALUE errat = make_backtrace();

	rb_ary_unshift(errat, rb_ary_entry(oldbt, 0));
	set_backtrace(th->rb_errinfo, errat);
	rb_exc_raise(th->rb_errinfo);
d5527 1
a5527 1
rb_thread_status(thread)
d5530 1
a5530 1
    thread_t th = rb_thread_check(thread);
d5532 2
a5533 2
    if (rb_thread_dead(th)) {
	if (NIL_P(th->rb_errinfo)) return Qfalse;
d5537 1
a5537 1
    return Qtrue;
d5541 1
a5541 1
rb_thread_stop_p(thread)
d5544 1
a5544 1
    thread_t th = rb_thread_check(thread);
d5546 3
a5548 3
    if (rb_thread_dead(th)) return Qtrue;
    if (th->status == THREAD_STOPPED) return Qtrue;
    return Qfalse;
d5552 1
a5552 1
rb_thread_wait_other_threads()
d5556 1
a5556 1
	rb_thread_schedule();
d5561 1
a5561 1
rb_thread_cleanup()
d5578 1
a5578 1
int rb_thread_critical;
d5581 1
a5581 1
rb_thread_get_critical()
d5583 1
a5583 1
    return rb_thread_critical?Qtrue:Qfalse;
d5587 1
a5587 1
rb_thread_set_critical(obj, val)
d5590 1
a5590 1
    rb_thread_critical = RTEST(val);
d5595 1
a5595 1
rb_thread_interrupt()
d5597 2
a5598 2
    rb_thread_critical = 0;
    rb_thread_ready(main_thread);
d5602 1
a5602 21
    rb_thread_save_context(curr_thread);
    if (setjmp(curr_thread->context)) {
	return;
    }
    curr_thread = main_thread;
    rb_thread_restore_context(curr_thread, 2);
}

void
rb_thread_trap_eval(cmd, sig)
    VALUE cmd;
    int sig;
{
    rb_thread_critical = 0;
    if (!rb_thread_dead(curr_thread)) {
	rb_thread_ready(curr_thread);
	rb_trap_eval(cmd, sig);
	return;
    }
    rb_thread_ready(main_thread);
    rb_thread_save_context(curr_thread);
a5605 2
    th_cmd = cmd;
    th_sig = sig;
d5607 1
a5607 1
    rb_thread_restore_context(curr_thread, 3);
d5611 1
a5611 1
rb_thread_raise(argc, argv, thread)
d5616 1
a5616 1
    thread_t th = rb_thread_check(thread);
d5618 1
a5618 1
    if (rb_thread_dead(th)) return thread;
d5620 1
a5620 1
	rb_f_raise(argc, argv);
d5623 1
a5623 2
    if (curr_thread->status != THREAD_KILLED)
	rb_thread_save_context(curr_thread);
d5629 1
a5629 1
    rb_thread_ready(th);
d5633 3
a5635 3
    th_raise_file = ruby_sourcefile;
    th_raise_line = ruby_sourceline;
    rb_thread_restore_context(curr_thread, 4);
d5643 1
a5643 1
rb_thread_loading(feature)
d5648 1
a5648 1
	    rb_thread_schedule();
d5651 1
a5651 1
	if (rb_provided(feature)) return Qtrue; /* no need to load */
d5657 1
a5657 1
    return Qfalse;
d5661 1
a5661 1
rb_thread_loading_done()
a5667 139
VALUE
rb_thread_local_aref(thread, id)
    VALUE thread;
    ID id;
{
    thread_t th;
    VALUE val;

    th = rb_thread_check(thread);
    if (!th->locals) return Qnil;
    if (st_lookup(th->locals, id, &val)) {
	return val;
    }
    return Qnil;
}

static VALUE
rb_thread_aref(thread, id)
    VALUE thread, id;
{
    return rb_thread_local_aref(thread, rb_to_id(id));
}

VALUE
rb_thread_local_aset(thread, id, val)
    VALUE thread;
    ID id;
    VALUE val;
{
    thread_t th;


    if (safe_level >= 4 && !FL_TEST(thread, FL_TAINT))
	rb_raise(rb_eSecurityError, "Insecure: can't modify thread values");

    th = rb_thread_check(thread);
    if (!th->locals) {
	th->locals = st_init_numtable();
    }
    if (NIL_P(val)) {
	st_delete(th->locals, &id, 0);
	return Qnil;
    }
    st_insert(th->locals, id, val);

    return val;
}

static VALUE
rb_thread_aset(thread, id, val)
    VALUE thread, id, val;
{
    return rb_thread_local_aset(thread, rb_to_id(id), val);
}

static VALUE
rb_thread_key_p(thread, id)
    VALUE thread, id;
{
    thread_t th = rb_thread_check(thread);

    if (!th->locals) return Qfalse;
    if (st_lookup(th->locals, rb_to_id(id), 0))
	return Qtrue;
    return Qfalse;
}

static VALUE rb_cContinuation;

static VALUE
rb_callcc(self)
    VALUE self;
{
    volatile VALUE cont;
    thread_t th = ALLOC(struct thread);

    th->status = THREAD_RUNNABLE;

    th->status = 0;
    th->result = 0;
    th->rb_errinfo = Qnil;

    th->stk_ptr = 0;
    th->stk_len = 0;
    th->stk_max = 0;
    th->wait_for = 0;
    th->fd = 0;
    th->delay = 0.0;
    th->join = 0;

    th->frame = 0;
    th->scope = 0;
    th->klass = 0;
    th->dyna_vars = 0;
    th->block = 0;
    th->iter = 0;
    th->tag = 0;
    th->rb_errinfo = 0;
    th->last_status = 0;
    th->last_line = 0;
    th->last_match = 0;
    th->abort = 0;

    th->thread = cont = Data_Wrap_Struct(rb_cContinuation, thread_mark,
					 thread_free, th);

    FL_SET(ruby_scope, SCOPE_DONT_RECYCLE);
    rb_thread_save_context(th);
    if (setjmp(th->context)) {
	return th->result;
    }
    else {
	return rb_yield(th->thread);
    }
}

static VALUE
rb_continuation_call(argc, argv, cont)
    int argc;
    VALUE *argv;
    VALUE cont;
{
    thread_t th = rb_thread_check(cont);

    switch (argc) {
    case 0:
	th->result = Qnil;
	break;
    case 1:
	th->result = *argv;
	break;
    default:
	th->result = rb_ary_new4(argc, argv);
	break;
    }
    rb_thread_restore_context(th, 0);
    return Qnil;
}

d5671 2
a5672 2
    rb_eThreadError = rb_define_class("ThreadError", rb_eStandardError);
    rb_cThread = rb_define_class("Thread", rb_cObject);
d5674 30
a5703 34
    rb_define_singleton_method(rb_cThread, "new", rb_thread_start, 0);
    rb_define_singleton_method(rb_cThread, "start", rb_thread_start, 0);
    rb_define_singleton_method(rb_cThread, "fork", rb_thread_start, 0);

    rb_define_singleton_method(rb_cThread, "stop", rb_thread_stop, 0);
    rb_define_singleton_method(rb_cThread, "kill", rb_thread_s_kill, 1);
    rb_define_singleton_method(rb_cThread, "exit", rb_thread_exit, 0);
    rb_define_singleton_method(rb_cThread, "pass", rb_thread_pass, 0);
    rb_define_singleton_method(rb_cThread, "join", rb_thread_s_join, 1);
    rb_define_singleton_method(rb_cThread, "current", rb_thread_current, 0);
    rb_define_singleton_method(rb_cThread, "main", rb_thread_main, 0);

    rb_define_singleton_method(rb_cThread, "critical", rb_thread_get_critical, 0);
    rb_define_singleton_method(rb_cThread, "critical=", rb_thread_set_critical, 1);

    rb_define_singleton_method(rb_cThread, "abort_on_exception", rb_thread_s_abort_exc, 0);
    rb_define_singleton_method(rb_cThread, "abort_on_exception=", rb_thread_s_abort_exc_set, 1);

    rb_define_method(rb_cThread, "run", rb_thread_run, 0);
    rb_define_method(rb_cThread, "wakeup", rb_thread_wakeup, 0);
    rb_define_method(rb_cThread, "exit", rb_thread_kill, 0);
    rb_define_method(rb_cThread, "value", rb_thread_value, 0);
    rb_define_method(rb_cThread, "status", rb_thread_status, 0);
    rb_define_method(rb_cThread, "join", rb_thread_join, 0);
    rb_define_method(rb_cThread, "alive?", rb_thread_status, 0);
    rb_define_method(rb_cThread, "stop?", rb_thread_stop_p, 0);
    rb_define_method(rb_cThread, "raise", rb_thread_raise, -1);

    rb_define_method(rb_cThread, "abort_on_exception", rb_thread_abort_exc, 0);
    rb_define_method(rb_cThread, "abort_on_exception=", rb_thread_abort_exc_set, 1);

    rb_define_method(rb_cThread, "[]", rb_thread_aref, 1);
    rb_define_method(rb_cThread, "[]=", rb_thread_aset, 2);
    rb_define_method(rb_cThread, "key?", rb_thread_key_p, 1);
d5706 1
a5706 6
    main_thread = rb_thread_alloc(rb_cThread);

    rb_cContinuation = rb_define_class("Continuation", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cContinuation), "new");
    rb_define_method(rb_cContinuation, "call", rb_continuation_call, -1);
    rb_define_method(rb_mKernel, "callcc", rb_callcc, 0);
d5711 1
a5711 1
rb_f_catch(dmy, tag)
d5721 1
a5721 1
	val = rb_yield_0(tag, 0, 0);
d5723 2
a5724 2
    else if (state == TAG_THROW && t == prot_tag->dst) {
	val = prot_tag->retval;
d5734 1
a5734 17
catch_i(tag)
    ID tag;
{
    return rb_f_catch(0, FIX2INT(tag));
}

VALUE
rb_catch(tag, proc, data)
    char *tag;
    VALUE (*proc)();
    VALUE data;
{
    return rb_iterate(catch_i, rb_intern(tag), proc, data);
}

static VALUE
rb_f_throw(argc, argv)
d5748 1
d5751 1
a5751 1
#ifdef USE_THREAD
d5753 3
a5755 3
	    rb_raise(rb_eThreadError, "uncaught throw `%s' in thread 0x%x",
		     rb_id2name(t),
		     curr_thread);
d5760 1
d5762 1
a5762 1
	rb_raise(rb_eNameError, "uncaught throw `%s'", rb_id2name(t));
a5763 2
    return_value(value);
    rb_trap_restore_mask();
d5768 2
a5769 3
void
rb_throw(tag, val)
    char *tag;
a5771 12
    VALUE argv[2];
    ID t = rb_intern(tag);

    argv[0] = FIX2INT(t);
    argv[1] = val;
    rb_f_throw(2, argv);
}

static void
return_check()
{
#ifdef USE_THREAD
d5773 1
a5773 1

d5776 1
d5779 1
d5781 2
a5782 2
	    rb_raise(rb_eThreadError, "return from within thread 0x%x",
		     curr_thread);
d5784 1
a5786 1
#endif
@


1.1.1.3.2.1
log
@990126
@
text
@d6 1
a6 1
  $Date: 1999/01/20 04:59:23 $
d9 1
a9 1
  Copyright (C) 1993-1999 Yukihiro Matsumoto
a40 4
#ifdef __MACOS__
#include "macruby_private.h"
#endif

a888 3
#ifdef __MACOS__
	_macruby_init();
#endif
d3031 1
d3036 1
a3036 4
    switch (argc) {
      case 0:
	mesg = Qnil;
	break;
d3038 1
a3038 6
	if (NIL_P(argv[0])) break;
	if (TYPE(argv[0]) == T_STRING) {
	    mesg = rb_exc_new3(rb_eRuntimeError, argv[0]);
	    break;
	}
	mesg = rb_funcall(argv[0], rb_intern("exception"), 0, 0);
d3042 1
a3042 4
	mesg = rb_funcall(argv[0], rb_intern("exception"), 1, argv[1]);
	break;
      default:
	rb_raise(rb_eArgError, "wrong # of arguments");
d3045 1
d3047 7
a3053 1
	if (!rb_obj_is_kind_of(mesg, rb_eException))
d3055 2
a3056 1
	set_backtrace(mesg, (argc>2)?argv[2]:Qnil);
a3677 1
#if 0
d3684 1
a3684 1
#endif
a4396 10
#ifdef __MACOS__
static int
is_macos_native_path(path)
    char *path;
{
    if (strchr(path, ':')) return 1;
    return 0;
}
#endif

a4404 10
#ifdef __MACOS__
    if (is_macos_native_path(file)) {
	FILE *f = fopen(file, "r");

	if (f == NULL) return 0;
	fclose(f);
	return file;
    }
#endif

d4450 1
d4454 1
d4612 1
a4612 1
	    if (file) goto load_rb;
d4624 1
a4624 1
	    if (file) goto load_dyna;
d4629 1
a4629 1
	    if (file) goto load_dyna;
d4639 1
a4639 1
	goto load_rb;
d4646 1
a4646 1
	goto load_dyna;
d4651 1
a4651 1
  load_dyna:
d4672 1
a4672 1
  load_rb:
@


1.1.1.3.2.2
log
@990127
@
text
@d6 1
a6 1
  $Date: 1999/01/26 10:08:10 $
d210 1
a212 1
	body = body->nd_head;
a635 1
#ifdef USE_THREAD
d637 3
d641 6
a646 5
    if (FL_TEST(ruby_scope, SCOPE_DONT_RECYCLE)) {\
	FL_SET(_old, SCOPE_DONT_RECYCLE);\
    }\
    else {\
	if (ruby_scope->flag == SCOPE_ALLOCA) {\
a651 14
	else {\
	    ruby_scope->flag |= SCOPE_NOSTACK;\
	}\
    }\
    ruby_scope = _old;\
    scope_vmode = _vmode;\
}
#else /* not USE_THREAD */
#define POP_SCOPE() \
    if (ruby_scope->flag == SCOPE_ALLOCA) {\
	ruby_scope->local_vars = 0;\
	ruby_scope->local_tbl  = 0;\
	if (ruby_scope != top_scope)\
	    rb_gc_force_recycle((VALUE)ruby_scope);\
a658 1
#endif /* USE_THREAD */
a1130 4
#ifdef USE_THREAD
    if (FL_TEST(ruby_scope, SCOPE_DONT_RECYCLE))
	FL_SET(saved_scope, SCOPE_DONT_RECYCLE);
#endif
a3170 1
#ifdef USE_THREAD
a3172 1
#endif
d3687 1
d3694 1
a4183 1
#ifdef USE_THREAD
a4185 1
#endif
d4316 1
a4316 2
    if (rb_safe_level() >= 4 && !FL_TEST(self, FL_TAINT))
	rb_raise(rb_eSecurityError, "Insecure: can't eval");
a6575 29
#define THREAD_ALLOC(th) {\
    th = ALLOC(struct thread);\
\
    th->status = 0;\
    th->result = 0;\
    th->rb_errinfo = Qnil;\
\
    th->stk_ptr = 0;\
    th->stk_len = 0;\
    th->stk_max = 0;\
    th->wait_for = 0;\
    th->fd = 0;\
    th->delay = 0.0;\
    th->join = 0;\
\
    th->frame = 0;\
    th->scope = 0;\
    th->klass = 0;\
    th->dyna_vars = 0;\
    th->block = 0;\
    th->iter = 0;\
    th->tag = 0;\
    th->rb_errinfo = 0;\
    th->last_status = 0;\
    th->last_line = 0;\
    th->last_match = 0;\
    th->abort = 0;\
}

d6582 29
a6610 1
    THREAD_ALLOC(th);
d7033 28
a7060 1
    thread_t th;
a7061 1
    THREAD_ALLOC(th);
@


1.1.1.3.2.3
log
@990201
@
text
@d6 1
a6 1
  $Date: 1999/01/27 08:08:35 $
d374 1
a374 1
VALUE ruby_errinfo = Qnil;
d792 1
a792 1
    if (NIL_P(ruby_errinfo)) return;
d794 1
a794 1
    errat = get_backtrace(ruby_errinfo);
d804 2
a805 2
    eclass = CLASS_OF(ruby_errinfo);
    einfo = rb_obj_as_string(ruby_errinfo);
d965 1
a965 1
int ruby_in_eval;
d1043 1
a1043 1
	if (rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
d1066 1
a1066 1
    mesg = str2cstr(ruby_errinfo, &len);
d1985 1
a1985 1
	    volatile VALUE e_info = ruby_errinfo;
d2004 1
a2004 1
			    ruby_errinfo = e_info;
d2323 1
a2323 1
	if (RTEST(ruby_verbose) &&
d2325 1
a2325 1
	    if (RTEST(ruby_verbose)) {
d2471 1
a2471 1
			ruby_in_eval++;
d2474 1
a2474 1
			ruby_in_eval--;
d2543 1
a2543 1
		    if (RTEST(ruby_verbose)) {
d2610 1
a2610 1
		if (RTEST(ruby_verbose)) {
d2965 1
a2965 1
    if (ruby_errinfo) {
d2995 1
a2995 1
    if (NIL_P(mesg)) mesg = ruby_errinfo;
d3008 1
a3008 1
	ruby_errinfo = mesg;
d3011 2
a3012 2
    if (RTEST(ruby_debug) && !NIL_P(ruby_errinfo)
	&& !rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
d3014 1
a3014 1
		rb_class2name(CLASS_OF(ruby_errinfo)),
d3369 1
a3369 1
	return rb_obj_is_kind_of(ruby_errinfo, rb_eStandardError);
d3380 1
a3380 1
	if (rb_obj_is_kind_of(ruby_errinfo, argv[0])) return 1;
d3393 1
a3393 1
    volatile VALUE e_info = ruby_errinfo;
d3400 1
a3400 1
    else if (state == TAG_RAISE && rb_obj_is_kind_of(ruby_errinfo, rb_eStandardError)) {
d3404 1
a3404 1
		result = (*r_proc)(data2, ruby_errinfo);
d3417 1
a3417 1
	    ruby_errinfo = e_info;
d4027 1
d4029 1
d4045 1
a4045 4
	    if (!frame) {
		ary = Qnil;
		break;
	    }
d4060 1
a4060 1

d4181 1
a4181 1
    ruby_in_eval++;
d4197 1
a4197 1
    ruby_in_eval--;
d4222 1
a4222 1
	    errat = get_backtrace(ruby_errinfo);
d4227 1
a4227 1
		    rb_str_concat(err, ruby_errinfo);
d4230 1
a4230 1
		    err = rb_str_dup(ruby_errinfo);
d4233 1
a4233 1
		rb_exc_raise(rb_exc_new3(CLASS_OF(ruby_errinfo), err));
d4235 1
a4235 1
	    rb_exc_raise(ruby_errinfo);
d4541 1
a4541 1
	ruby_in_eval++;
d4543 1
a4543 1
	ruby_in_eval--;
d4560 1
a4560 1
	rb_exc_raise(ruby_errinfo);
d4979 1
a4979 1
    return get_backtrace(ruby_errinfo);
d4988 1
a4988 1
    if (NIL_P(ruby_errinfo)) {
d4991 1
a4991 1
    set_backtrace(ruby_errinfo, val);
d5105 1
a5105 1
    rb_define_hooked_variable("$!", &ruby_errinfo, 0, errinfo_setter);
d5790 1
a5790 1
    VALUE errinfo;
d5851 1
a5851 1
    rb_gc_mark(th->errinfo);
d5943 1
a5943 1
    th->errinfo = ruby_errinfo;
d6007 1
a6007 1
    ruby_errinfo = th->errinfo;
d6595 1
a6595 1
#define THREAD_ALLOC(th) do {\
d6600 1
a6600 1
    th->errinfo = Qnil;\
a6612 1
    th->wrapper = 0;\
d6617 1
a6617 1
    th->errinfo = 0;\
d6622 1
a6622 2
    th->locals = 0;\
} while(0)
d6738 1
a6738 1
    if (state && status != THREAD_TO_KILL && !NIL_P(ruby_errinfo)) {
d6741 1
a6741 1
	    main_thread->errinfo = ruby_errinfo;
d6744 1
a6744 1
	else if (rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
d6746 1
a6746 1
	    rb_thread_raise(1, &ruby_errinfo, main_thread->thread);
d6748 1
a6748 1
	else if (rb_thread_abort || curr_thread->abort || RTEST(ruby_debug)) {
d6755 1
a6755 1
	    curr_thread->errinfo = ruby_errinfo;
d6802 2
a6803 2
    if (!NIL_P(th->errinfo)) {
	VALUE oldbt = get_backtrace(th->errinfo);
d6807 2
a6808 2
	set_backtrace(th->errinfo, errat);
	rb_exc_raise(th->errinfo);
d6821 1
a6821 1
	if (NIL_P(th->errinfo)) return Qfalse;
@


1.1.1.3.2.4
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/02/01 07:34:53 $
d2540 1
a2540 1
		    if (safe_level >= 4) {
d2607 1
a2607 1
		if (safe_level >= 4) {
d2712 1
a2712 1
		if (safe_level >= 4) {
d2754 1
a2754 1
		if (safe_level >= 4) {
a5854 1
    rb_mark_tbl(th->locals);
d5881 1
d7011 2
a7012 1
    thread_t th = rb_thread_check(thread);
d7017 1
@


1.1.1.3.2.5
log
@990212
@
text
@d6 1
a6 1
  $Date: 1999/02/09 06:08:19 $
d2057 3
d2071 1
a5976 6
#define RESTORE_NORMAL		0 
#define RESTORE_FATAL		1
#define RESTORE_INTERRUPT	2
#define RESTORE_TRAP		3
#define RESTORE_RAISE		4 

d6025 1
a6025 1
      case RESTORE_FATAL:
d6029 1
a6029 1
      case RESTORE_INTERRUPT:
d6033 1
a6033 1
      case RESTORE_TRAP:
d6038 1
a6038 1
      case RESTORE_RAISE:
a6044 1
      case RESTORE_NORMAL:
a6083 43
void
rb_thread_fd_close(fd)
    int fd;
{
    thread_t th;

    FOREACH_THREAD(th) {
	if ((th->wait_for & WAIT_FD) && th->fd == fd) {
	    th_raise_argc = 1;
	    th_raise_argv[0] = rb_exc_new2(rb_eIOError, "stream closed");
	    th_raise_file = ruby_sourcefile;
	    th_raise_line = ruby_sourceline;
	    curr_thread = th;
	    rb_thread_restore_context(main_thread, RESTORE_RAISE);
	}
    }
    END_FOREACH(th);
}

static void
rb_thread_badf()
{
    thread_t th;
    int max;
    struct timeval delay_tv;
    fd_set readfds;

    delay_tv.tv_sec = 0;
    delay_tv.tv_usec = 0;
    FOREACH_THREAD(th) {
	if (th->wait_for & WAIT_FD) {
	    FD_ZERO(&readfds);
	    FD_SET(th->fd, &readfds);
	    if (select(th->fd+1, &readfds, 0, 0, &delay_tv) < 0 &&
		errno == EBADF) {
		rb_thread_ready(th);
		th->status = THREAD_TO_KILL;
	    }
	}
    }
    END_FOREACH(th);
}

a6086 4
    static int invoked = 0;

    if (invoked) return;
    invoked = 1;
a6087 1
#if 0
a6091 5
    rb_thread_restore_context(main_thread, RESTORE_RAISE);
#else
    rb_prohibit_interrupt = 1;
    ruby_errinfo = rb_exc_new2(rb_eFatal, "Thread: deadlock");
    set_backtrace(ruby_errinfo, make_backtrace());
a6092 1
#endif
d6194 1
a6194 9
		    switch (errno) {
		      case EBADF:
			rb_thread_badf();
		      case ENOMEM:
			n = 0;
			break;
		      default:
			goto select_err;
		    }
a6225 3
	    if (th->status == THREAD_STOPPED) {
		next = th;
	    }
a6229 2
	rb_thread_ready(next);
	next->status = THREAD_TO_KILL;
d6246 1
a6246 1
	rb_thread_restore_context(next, RESTORE_FATAL);
d6248 1
a6248 1
    rb_thread_restore_context(next, RESTORE_NORMAL);
d6264 1
a6264 1
int
d6271 1
a6271 1
    if (curr_thread == curr_thread->next) return 1;
d6277 1
a6277 1
	if (select(fd+1, 0, &fds, 0, &zero) == 1) return 0;
d6898 1
a6898 1
    rb_thread_restore_context(curr_thread, RESTORE_INTERRUPT);
d6920 1
a6920 1
    rb_thread_restore_context(curr_thread, RESTORE_TRAP);
d6949 1
a6949 1
    rb_thread_restore_context(curr_thread, RESTORE_RAISE);
d7089 1
a7089 1
    rb_thread_restore_context(th, RESTORE_NORMAL);
@


1.1.1.3.2.6
log
@990215
@
text
@d6 1
a6 1
  $Date: 1999/02/12 11:17:01 $
d6107 24
d6133 4
a6136 1
#if 1
d6138 1
a6144 4
    static int invoked = 0;

    if (invoked) return;
    invoked = 1;
d6253 1
a6777 1
    volatile VALUE thread = th->thread;
d6797 1
a6797 1
	return thread;
@


1.1.1.3.2.7
log
@990224
@
text
@d6 1
a6 1
  $Date: 1999/02/15 07:31:49 $
d789 2
a790 2
    char *einfo;
    int elen;
d794 1
a794 8
    PUSH_TAG(PROT_NONE);
    if (EXEC_TAG() == 0) {
	errat = get_backtrace(ruby_errinfo);
    }
    else {
	errat = Qnil;
    }
    POP_TAG();
d805 2
a806 10
    PUSH_TAG(PROT_NONE);
    if (EXEC_TAG() == 0) {
	einfo = str2cstr(rb_obj_as_string(ruby_errinfo), &elen);
    }
    else {
	einfo = "";
	elen = 0;
    }
    POP_TAG();
    if (eclass == rb_eRuntimeError && elen == 0) {
d813 1
a813 1
	if (elen == 0) {
d820 1
a820 1
	    int len = elen;
d823 2
a824 2
	    if (tail = strchr(einfo, '\n')) {
		len = tail - einfo;
d828 1
a828 1
	    fwrite(einfo, 1, elen, stderr);
d835 1
a835 1
		fwrite(tail, 1, elen-len-1, stderr);
d861 1
d898 1
a898 1
    PUSH_TAG(PROT_NONE);
d3482 1
a3482 1
    volatile VALUE d = 0;
a3483 1
    char *desc = "";
d3495 1
a3495 1
	format = "undefined method `%s' for true";
d3498 1
a3498 1
	format = "undefined method `%s' for false";
d3501 1
a3501 1
	d = rb_any_to_s(obj);
d3504 1
a3504 1
	d = rb_inspect(obj);
d3507 1
a3507 1
    if (d) {
d3527 2
a3528 2
	if (RSTRING(d)->len > 65) {
	    d = rb_any_to_s(obj);
a3529 1
	desc = RSTRING(d)->ptr;
d3537 3
a3539 1
    rb_raise(rb_eNameError, format, rb_id2name(id), desc);
a4458 6
    if (file[0] == '~') {
	VALUE argv[1];
	argv[0] = rb_str_new2(file);
	file = STR2CSTR(rb_file_s_expand_path(1, argv));
    }

d4496 3
a4735 14
static VALUE
require_method(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    int i;

    for (i=0; i<argc; i++) {
	rb_f_require(self, argv[i]);
    }
    return Qnil;
}

a4900 11
void
rb_obj_call_init2(obj, argc, argv)
    VALUE obj;
    int argc;
    VALUE *argv;
{
    PUSH_ITER(rb_iterator_p()?ITER_PRE:ITER_NOT);
    rb_funcall2(obj, init, argc, argv);
    POP_ITER();
}

d4966 1
a4966 1
    if (!NIL_P(val) && !rb_obj_is_kind_of(val, rb_eException)) {
d5178 1
a5178 1
    rb_define_global_function("require", require_method, -1);
@


1.1.1.3.2.8
log
@990225
@
text
@d6 1
a6 1
  $Date: 1999/02/24 04:31:18 $
d2530 1
a2530 1
	    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",
d2598 8
d2608 2
a2609 3
			 "can't define method \"%s\" for %s",
			 rb_id2name(node->nd_mid),
			 rb_class2name(CLASS_OF(recv)));
d2732 1
a2732 1
		rb_obj_call_init(klass, 0, 0);
d2772 1
a2772 1
		rb_obj_call_init(module, 0, 0);
d2788 6
d2795 1
a2795 2
		rb_raise(rb_eTypeError, "no virtual class for %s",
			 rb_class2name(CLASS_OF(klass)));
d3610 1
a3610 1
	rb_raise(rb_eArgError, "wrong # of arguments(%d for %d)",
d3814 1
a3814 1
			rb_raise(rb_eArgError, "wrong # of arguments(%d for %d)",
d3826 1
a3826 1
			    rb_raise(rb_eArgError, "wrong # of arguments(%d for %d)",
d3940 2
a3941 7
    if ((noex & NOEX_PROTECTED)) {
	VALUE defined_class = klass;
	while (TYPE(defined_class) == T_ICLASS)
	    defined_class = RBASIC(defined_class)->klass;
	if (!rb_obj_is_kind_of(ruby_frame->self, defined_class))
	    return rb_undefined(recv, mid, argc, argv, CSTAT_PROT);
    }
d4371 1
a4371 1
	rb_raise(rb_eArgError, "wrong # of arguments: %s(src) or %s{..}",
d4410 1
a4410 1
	rb_raise(rb_eArgError, "wrong # of arguments: %s(src) or %s{..}",
d4924 10
a4933 1
rb_obj_call_init(obj, argc, argv)
d4955 1
a4955 1
    rb_obj_call_init(obj, argc, argv);
d5423 1
a5423 1
    rb_obj_call_init(proc, 0, 0);
@


1.1.1.3.2.9
log
@990324
@
text
@d6 1
a6 1
  $Date: 1999/02/25 06:39:05 $
d24 1
a24 1
char *strrchr _((const char*,const char));
d239 1
a239 1
    const char *name;
d247 1
a247 1
    const char *name;
d270 1
a270 1
    const char *name;
d337 1
a337 1
    const char *name;
d415 1
d417 1
d636 1
d656 15
d674 1
a674 1
static NODE *compile _((VALUE));
d843 1
a843 1
	    fwrite(einfo, 1, len, stderr);
d981 1
d984 1
d1014 1
d1017 1
a1057 1
	    exec_end_proc();
d1074 1
a1074 1
    const char *at;
d1094 1
a1094 1
    const char *str;
d1108 1
a1108 1
    const char *str;
d1157 1
d1160 1
d1191 1
a1191 1
static VALUE
d1344 5
a1348 5
# define TMP_PROTECT NODE * volatile tmp__protect_tmp=0
# define TMP_ALLOC(n)							\
    (tmp__protect_tmp = rb_node_newnode(NODE_ALLOCA,			\
			     ALLOC_N(VALUE,n),tmp__protect_tmp,n),	\
     (void*)tmp__protect_tmp->nd_head)
d1642 1
d1644 1
d1672 1
d1674 1
d2070 2
a2071 3
	result = rb_range_new(rb_eval(self, node->nd_beg),
			      rb_eval(self, node->nd_end),
			      nd_type(node) == NODE_DOT3);
a2480 1
			ruby_sourceline = nd_line(node);
d2482 1
a2482 1
			list->nd_head = compile(list->nd_head->nd_lit);
d2804 1
a2804 1
	    else result = Qnil;
a2937 1
    exec_end_proc();
d3185 1
d3188 1
d3521 1
a3521 1
	    const char *mname = rb_id2name(id);
d3806 1
a3806 1
			int opt = i;
d3810 1
a3810 1
			    opt++;
d3813 1
a3813 1
			if (opt < argc) {
d3815 1
a3815 1
				     argc, opt);
a3816 4
#if 1
			ruby_frame->argc = opt;
			ruby_frame->argv = local_vars+2;
#endif
d4114 1
a4114 1
compile(src)
d4116 1
d4121 2
a4122 1
    node = rb_compile_string(ruby_sourcefile, src);
d4193 1
a4193 1
	compile(src);
d4204 1
d4207 1
d4255 1
a4255 1
    int line = 1;
d4314 1
a4314 1
    const char *file;
d4343 2
a4344 2
static VALUE
specific_eval(argc, argv, klass, self)
d4347 1
a4347 1
    VALUE klass, self;
d4350 2
a4351 2
    int   line = 1;
    int   iter = rb_iterator_p();
d4353 6
a4358 1
    if (argc > 0) {
a4359 5
	if (argc > 3) {
	    rb_raise(rb_eArgError, "wrong # of arguments: %s(src) or %s{..}",
		     rb_id2name(ruby_frame->last_func),
		     rb_id2name(ruby_frame->last_func));
	}
d4363 4
a4366 2
    else if (!iter) {
	rb_raise(rb_eArgError, "block not supplied");
d4369 7
a4375 1
    if (iter) {
d4383 2
a4384 2
VALUE
rb_obj_instance_eval(argc, argv, self)
d4387 1
a4387 1
    VALUE self;
d4389 2
a4390 1
    VALUE klass;
d4392 9
a4400 2
    if (rb_special_const_p(self)) {
	klass = Qnil;
d4403 3
a4405 1
	klass = rb_singleton_class(self);
d4408 6
a4413 10
    return specific_eval(argc, argv, klass, self);
}

static VALUE
rb_mod_module_eval(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
{
    return specific_eval(argc, argv, mod, mod);
d4420 1
a4420 1
    const char *path;
d4433 1
a4433 1
    const char *path;
d4604 1
a4604 1
    const char *feature;
d4625 2
a4626 1
static int rb_thread_loading _((const char*));
d4628 1
d4632 1
a4632 1
    const char *feature;
d4706 1
d4712 1
d4717 1
d4723 1
d4727 1
d4733 1
d4736 1
d4742 1
a5270 1
	scope_dup(tmp->scope);
d5312 1
d5314 1
d5392 1
d5394 1
d5426 1
d5430 1
d5665 1
a5665 1
    const char *s;
d5742 2
a5997 1
static char *th_signm;
d6003 1
a6003 2
#define RESTORE_RAISE		4
#define RESTORE_SIGNAL		5
a6065 4
      case RESTORE_SIGNAL:
	rb_raise(rb_eSignal, "SIG%s", th_signm);
	break;

d6163 1
a6163 3
    if (curr_thread == curr_thread->next
	&& curr_thread->status == THREAD_RUNNABLE)
	return;
a6495 2
    if (th == curr_thread)
	rb_raise(rb_eThreadError, "recursive join");
a6503 9
    if (!NIL_P(th->errinfo)) {
	VALUE oldbt = get_backtrace(th->errinfo);
	VALUE errat = make_backtrace();

	rb_ary_unshift(errat, rb_ary_entry(oldbt, 0));
	set_backtrace(th->errinfo, errat);
	rb_exc_raise(th->errinfo);
    }

d6591 1
a6594 1
    curr_thread->status = THREAD_STOPPED;
d6877 8
a6973 20
rb_thread_signal_raise(sig)
    char *sig;
{
    if (sig == 0) return;	/* should not happen */
    rb_thread_critical = 0;
    if (curr_thread == main_thread) {
	rb_thread_ready(curr_thread);
	rb_raise(rb_eSignal, "SIG%s", sig);
    }
    rb_thread_ready(main_thread);
    rb_thread_save_context(curr_thread);
    if (setjmp(curr_thread->context)) {
	return;
    }
    th_signm = sig;
    curr_thread = main_thread;
    rb_thread_restore_context(curr_thread, RESTORE_SIGNAL);
}

void
d7030 1
a7030 1
    const char *feature;
d7214 1
d7248 1
a7248 1
    const char *tag;
d7272 1
d7278 1
d7292 1
a7292 1
    const char *tag;
d7306 1
d7319 1
@


1.1.1.3.2.10
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/03/24 08:52:25 $
d943 2
a944 1
    NODE *beg_tree, *tree;
d946 2
a947 3
    beg_tree = ruby_eval_tree_begin;
    tree = ruby_eval_tree;
    if (beg_tree) {
d949 1
a949 1
	rb_eval(self, beg_tree);
d952 3
a954 1
    if (!tree) return Qnil;
d957 2
a958 1
    return rb_eval(self, tree);
d3261 1
a3261 1
	    if (!lhs->nd_args) {
d3270 1
a3270 1
		rb_ary_push(args, val);
d4098 1
a4098 1
    node = rb_compile_string("(eval)", src);
d4168 1
a4168 1
	ruby_sourceline = line - 1;
d4383 1
a4383 1
# if defined(MSDOS) || defined(NT) || defined(__human68k__) || defined(__EMX__)
@


1.1.1.3.2.11
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/04/09 17:57:37 $
d419 1
d446 2
d451 1
a478 8
static void
mark_dvar(vars)
    struct RVarmap *vars;
{
    ruby_dyna_vars = new_dvar(0, 0);
    ruby_dyna_vars->next = vars;
}

d515 2
a516 2
static void
dvar_asgn(id, value, push)
a518 1
    int push;
a522 1
	if (push && vars->id == 0) break;
d530 1
a530 8
}

void
rb_dvar_asgn(id, value)
    ID id;
    VALUE value;
{
    dvar_asgn(id, value, 0);
d538 3
a540 10
    struct RVarmap* vars = 0;

    if (ruby_dyna_vars && ruby_dyna_vars->id == 0) {
	vars = ruby_dyna_vars;
	ruby_dyna_vars = ruby_dyna_vars->next;
    }
    dvar_asgn(id, value, 1);
    if (vars) {
	vars->next = ruby_dyna_vars;
	ruby_dyna_vars = vars;
d656 1
a656 1
static NODE *compile _((VALUE, char*, int));
d2454 1
a2454 3
			list->nd_head = compile(list->nd_head->nd_lit,
						ruby_sourcefile,
						ruby_sourceline);
d3109 1
a3109 1
    mark_dvar(block->d_vars);
d4089 1
a4089 1
compile(src, file, line)
a4090 2
    char *file;
    int line;
d4095 1
a4095 1
    node = rb_compile_string(file, src, line);
d4138 2
d4164 3
a4166 1
	compile(src, file, line);
d4181 3
d4238 1
a4238 1
    return eval(self, src, scope, file, line-1);
d5741 1
d5902 1
d5973 1
@


1.1.1.3.2.12
log
@prepare to alpha
@
text
@d6 1
a6 1
  $Date: 1999/04/12 09:59:27 $
d4255 1
a4255 1
    return eval(self, src, scope, file, line);
@


1.1.1.3.2.13
log
@alpha bug
@
text
@d6 1
a6 1
  $Date: 1999/04/16 06:03:29 $
d4512 1
a4512 1
	MEMCPY(vars, top_scope->local_vars, VALUE, len-1);
@


1.1.1.3.2.14
log
@to open CVS
@
text
@d6 1
a6 1
  $Date: 1999/04/16 07:04:45 $
d453 2
a454 2
    struct RVarmap * volatile _old;	\
    _old = ruby_dyna_vars;		\
d458 1
a458 1
    ruby_dyna_vars = _old;		\
a4200 1
	ruby_dyna_vars = old_d_vars;
@


1.1.1.3.2.15
log
@call/cc
@
text
@d6 1
a6 1
  $Date: 1999/04/20 08:21:35 $
a589 1
    struct SCOPE *scope;
a601 1
    _tag.scope = ruby_scope;		\
d637 2
a638 2
#define PUSH_CLASS() {			\
    VALUE _class = ruby_class;		\
d4490 1
a4519 1
    PUSH_TAG(PROT_NONE);
a4534 1
    POP_TAG();
d4538 1
a7112 1
    struct tag *tag;
a7118 3
    for (tag=prot_tag; tag; tag=tag->prev) {
	scope_dup(tag->scope);
    }
@


1.1.1.3.2.16
log
@990513
@
text
@d6 1
a6 1
  $Date: 1999/04/22 07:28:45 $
a1124 27
}

VALUE
rb_eval_string_wrap(str, state)
    const char *str;
    int *state;
{
    int status;
    VALUE self = ruby_top_self;
    VALUE val;

    PUSH_CLASS();
    ruby_class = ruby_wrapper = rb_module_new();
    ruby_top_self = rb_obj_clone(ruby_top_self);
    rb_extend_object(self, ruby_class);

    val = rb_eval_string_protect(str, &status);
    ruby_top_self = self;

    POP_CLASS();
    if (state) {
	if (status == 0) {
	    JUMP_TAG(state);
	}
	*state = status;
    }
    return val;
@


1.1.1.3.2.17
log
@moving
@
text
@d6 1
a6 1
  $Date: 1999/05/13 10:00:59 $
a1145 1
	*state = status;
d1147 1
a1147 1
	    JUMP_TAG(status);
d1149 1
@


1.1.1.3.2.18
log
@arity/strict yield
@
text
@d6 1
a6 1
  $Date: 1999/05/14 08:56:03 $
d684 2
a685 2
static VALUE massign _((VALUE,NODE*,VALUE,int));
static void assign _((VALUE,NODE*,VALUE,int));
d2317 1
a2317 1
	result = massign(self, node, rb_eval(self, node->nd_value),0);
d3165 4
a3168 9
	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    if (nd_type(block->var) == NODE_MASGN)
		massign(self, block->var, val, 1);
	    else
		assign(self, block->var, val, 1);
	}
	POP_TAG();
	if (state) goto pop_state;
a3203 1
  pop_state:
d3230 1
a3230 1
massign(self, node, val, check)
a3233 1
    int check;
d3236 1
a3236 1
    int i = 0, len;
d3246 1
a3246 1
	    assign(self, list->nd_head, RARRAY(val)->ptr[i], check);
a3248 1
	if (check && list) goto arg_error;
d3251 1
a3251 1
		assign(self, node->nd_args, rb_ary_new4(len-i, RARRAY(val)->ptr+i), check);
d3254 1
a3254 1
		assign(self, node->nd_args, rb_ary_new2(0), check);
a3256 1
	else if (check && i<len) goto arg_error;
d3259 1
a3259 1
	assign(self, node->nd_args, Qnil, check);
a3260 2

    if (check && list) goto arg_error;
d3262 1
a3262 2
	i++;
	assign(self, list->nd_head, Qnil, check);
a3265 7

  arg_error:
    while (list) {
	i++;
	list = list->nd_next;
    }
    rb_raise(rb_eArgError, "wrong # of arguments (%d for %d)", len, i);
d3269 1
a3269 1
assign(self, lhs, val, check)
a3272 1
    int check;
d3302 1
a3302 1
	massign(self, lhs, val, check);
d3855 1
a3855 1
				assign(recv, opt->nd_head, *argv, 1);
d5430 1
a5430 1
    int state, n;
a5433 9
    Data_Get_Struct(proc, struct BLOCK, data);
    orphan = blk_orphan(data);

    /* PUSH BLOCK from data */
    old_block = ruby_block;
    ruby_block = data;
    PUSH_ITER(ITER_CUR);
    ruby_frame->iter = ITER_CUR;

d5445 9
a5497 25
proc_arity(proc)
    VALUE proc;
{
    struct BLOCK *data;
    NODE *list;
    int n;

    Data_Get_Struct(proc, struct BLOCK, data);
    if (data->var == 0) return 0;
    switch (nd_type(data->var)) {
      default:
	return INT2FIX(-1);
      case NODE_MASGN:
	list = data->var->nd_head;
	n = 0;
	while (list) {
	    n++;
	    list = list->nd_next;
	}
	if (data->var->nd_args) return INT2FIX(-n);
	return INT2FIX(n);
    }
}

static VALUE
a5648 32
method_arity(method)
    VALUE method;
{
    struct METHOD *data;
    NODE *body;
    int n;

    Data_Get_Struct(method, struct METHOD, data);

    body = data->body;
    switch (nd_type(body)) {
      case NODE_CFUNC:
	if (body->nd_argc < 0) return INT2FIX(-1);
	return INT2FIX(body->nd_argc);
      case NODE_ZSUPER:
	return INT2FIX(-1);
      case NODE_ATTRSET:
	return INT2FIX(1);
      case NODE_IVAR:
	return INT2FIX(0);
      default:
	body = body->nd_next;	/* skip NODE_SCOPE */
	if (nd_type(body) == NODE_BLOCK)
	    body = body->nd_head;
	if (!body) return INT2FIX(0);
	n = body->nd_cnt;
	if (body->nd_rest) n = -n;
	return INT2FIX(n);
    }
}

static VALUE
a5712 1
    rb_define_method(rb_cProc, "arity", proc_arity, 0);
a5724 1
    rb_define_method(rb_cMethod, "arity", method_arity, 0);
@


1.1.1.3.2.19
log
@arity bug
@
text
@d6 1
a6 1
  $Date: 1999/05/17 09:53:57 $
d5526 1
a5526 1
    if (data->var == 0) return FIX2INT(-1);
d5529 1
a5529 1
	return INT2FIX(-2);
d5537 1
a5537 1
	if (data->var->nd_args) return INT2FIX(-n-1);
d5720 1
a5720 1
	if (body->nd_rest) n = -n-1;
@


1.1.1.3.2.20
log
@regexp null pattern
@
text
@d6 1
a6 1
  $Date: 1999/05/18 00:34:35 $
d874 1
a874 1
		fprintf(stderr, "\t ... %ld levels...\n",
d1055 2
a1056 5
	    ex = exit_status;
	}
	else {
	    error_print();
	    ex = 1;
d1058 2
d3077 1
d3258 1
a3258 4
	    if (node->nd_args == (NODE*)-1) {
		/* ignore rest args */
	    }
	    else if (!list && i<len) {
d3267 1
a3267 1
    else if (node->nd_args && node->nd_args != (NODE*)-1) {
d4184 1
a5116 1
    int status;
d5119 1
a5119 1
	rb_protect((VALUE(*)())link->func, link->data, &status);
d5450 1
a5450 1
    int state;
d6360 1
a6360 1
	    fprintf(stderr, "%s:%d:deadlock 0x%lx: %d:%d %s\n", 
@


1.1.1.3.2.21
log
@990531
@
text
@d6 1
a6 1
  $Date: 1999/05/25 08:25:52 $
a413 1
    int d_scope;
d431 1
a434 2
    _block.d_scope = Qtrue;		\
    _block.d_vars = ruby_dyna_vars;	\
d443 1
d462 1
a462 1
new_dvar(id, value, prev)
a464 1
    struct RVarmap *prev;
d470 1
a470 1
    vars->next = prev;
d475 8
d516 1
a516 1
    ruby_dyna_vars = new_dvar(id, value, ruby_dyna_vars);
d945 2
d949 3
a1001 2
	NODE *save;

a1002 3
	save = ruby_eval_tree;
	ruby_require_libraries();
	ruby_eval_tree = save;
a1942 1
		    _block.d_scope = Qfalse;
d3160 1
a3160 8
    if (block->d_scope) {
	/* put place holder for dynamic (in-block) local variables */
	ruby_dyna_vars = new_dvar(0, 0, block->d_vars);
    }
    else {
	/* FOR does not introduce new scope */
	ruby_dyna_vars = block->d_vars;
    }
d6198 1
a6198 2
	    rb_thread_ready(th);
	    rb_thread_restore_context(curr_thread, RESTORE_RAISE);
d6268 1
a6268 1
	fd_set readfds, writefds, exceptfds;
a7010 1
	    rb_thread_ready(th);
d7012 1
@


1.1.1.3.2.22
log
@rb_exec_end_proc, etc.
@
text
@d6 1
a6 1
  $Date: 1999/05/31 09:13:04 $
d976 2
d1060 1
a1060 1
    rb_exec_end_proc();
d2957 1
a2957 2
    rb_exec_end_proc();
    rb_gc_call_finalizer_at_exit();
d5117 2
a5118 2
void
rb_exec_end_proc()
a5120 1
    struct end_proc_data *tmp;
d5125 1
a5125 3
	tmp = link->next;
	free(link);
	link = tmp;
a5126 1
    end_proc_data = 0;
@


1.1.1.3.2.23
log
@thread bugs
@
text
@d6 1
a6 1
  $Date: 1999/06/01 06:58:59 $
d651 1
a651 1
#define POP_SCOPE() 			\
d654 2
a655 2
    }					\
    else {				\
d657 2
a658 2
	    ruby_scope->local_vars = 0;	\
	    ruby_scope->local_tbl  = 0;	\
d661 2
a662 2
	}				\
	else {				\
d664 4
a667 4
	}				\
    }					\
    ruby_scope = _old;			\
    scope_vmode = _vmode;		\
a2873 1
    PUSH_VARS();
a2896 1
    POP_VARS();
d4653 1
a4653 1
static void rb_thread_loading_done _((const char*));
a4679 1
    int state;
d4732 12
a4743 7

    rb_provide(feature);
    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	load = rb_str_new2(file);
	file = RSTRING(load)->ptr;
	dln_load(file);
a4744 4
    POP_TAG();
    rb_thread_loading_done(feature);
    if (state) JUMP_TAG(state);

d4749 10
a4758 5
    rb_provide(feature);

    PUSH_TAG(PROT_NONE);
    if ((state = EXEC_TAG()) == 0) {
	rb_load(fname, 0);
a4759 4
    POP_TAG();
    rb_thread_loading_done(feature);
    if (state) JUMP_TAG(state);

d5309 1
a5309 2
    bind = Data_Make_Struct(rb_cBinding,struct BLOCK,blk_mark,blk_free,data);
    CLONESETUP(bind,self);
d6619 1
a6619 1
VALUE
d6632 1
a6632 1
VALUE
d6678 1
a6678 1
VALUE
d7128 2
a7129 1
static st_table *loading_tbl;
d7135 6
a7140 3
    if (!rb_provided(feature)) return Qfalse; /* need to load */
    if (!loading_tbl) {
	loading_tbl = st_init_strtable();
d7142 5
a7146 5
    while (st_lookup(loading_tbl, feature, 0)) {
	CHECK_INTS;
	rb_thread_schedule();
    }
    return Qtrue;
d7150 1
a7150 2
rb_thread_loading_done(feature)
    const char *feature;
d7152 2
a7153 2
    if (loading_tbl) {
	st_delete(loading_tbl, feature, 0);
@


1.1.1.3.2.24
log
@990611
@
text
@d6 1
a6 1
  $Date: 1999/06/09 09:21:06 $
d324 1
a324 1
	if (ex && (noex & NOEX_PRIVATE))
d882 1
a882 1
void Init_stack _((void*));
a901 1
    Init_stack(0);
a980 1
    NODE *save;
d984 2
a985 1
    Init_stack(&save);
d989 2
d1467 1
a1467 1
				  ruby_frame->last_func, 0)) {
d2742 1
d2782 1
d5428 1
@


1.1.1.3.2.25
log
@990624
@
text
@d6 1
a6 1
  $Date: 1999/06/11 06:29:46 $
a976 12
static void
call_required_libraries()
{
    NODE *save;

    ruby_sourcefile = 0;
    if (!ext_init) Init_ext();
    save = ruby_eval_tree;
    ruby_require_libraries();
    ruby_eval_tree = save;
}

d982 1
a982 1
    volatile NODE *tmp;
d986 1
a986 1
    Init_stack(&tmp);
d990 4
a993 1
	call_required_libraries();
d2253 2
a2254 3
	    switch (node->nd_mid) {
	    case 0: /* OR */
		if (RTEST(val)) RETURN(val);
d2256 3
a2258 3
		break;
	    case 1: /* AND */
		if (!RTEST(val)) RETURN(val);
d2260 2
a2261 2
		break;
	    default:
d2277 2
a2278 3
	    switch (node->nd_next->nd_mid) {
	    case 0: /* OR */
		if (RTEST(val)) RETURN(val);
d2280 3
a2282 3
		break;
	    case 1: /* AND */
		if (!RTEST(val)) RETURN(val);
d2284 2
a2285 2
		break;
	    default:
d6045 2
@


1.1.1.3.2.26
log
@990625
@
text
@d6 1
a6 1
  $Date: 1999/06/24 04:23:47 $
d1711 4
d1723 1
d1733 8
d1798 3
d1802 1
d1814 3
d1818 1
d2164 5
d2170 1
d2848 12
@


1.1.1.3.2.27
log
@990715
@
text
@d6 1
a6 1
  $Date: 1999/06/25 09:02:34 $
a70 13
static void print_undef _((VALUE, ID)) NORETURN;
static void
print_undef(klass, id)
    VALUE klass;
    ID id;
{
    rb_raise(rb_eNameError, "undefined method `%s' for %s `%s'",
	     rb_id2name(id), 
	     (TYPE(klass) == T_MODULE)?"module":"class",
	     rb_class2name(klass));
}


d205 2
a206 1
	print_undef(klass, def);
d255 2
a256 1
	print_undef(klass, mid);
d278 2
a279 1
	print_undef(klass, mid);
d301 2
a302 1
	print_undef(klass, name);
d373 1
a373 1
static ID init, eqq, each, aref, aset, match, missing;
a888 1
    static int initialized = 0;
a892 4
    if (initialized)
	return;
    initialized = 1;

a2650 3
		else if (TYPE(klass) == T_MODULE) {
		    s0 = " module";
		}
a2937 1
    int istatus;
d2941 1
a2941 1
	istatus = NUM2INT(status);
d2944 1
a2944 1
	istatus = 0;
d2946 1
a2946 1
    rb_exit(istatus);
d3529 1
a3529 1
	    format = "private method `%s' called for %s%s%s";
d3532 4
a3535 1
	    format = "protected method `%s' called for %s%s%s";
d3541 1
a3541 1
		format = "undefined local variable or method `%s' for %s%s%s";
d3545 1
a3545 1
	    format = "undefined method `%s' for %s%s%s";
d3558 1
a3558 3
    rb_raise(rb_eNameError, format, rb_id2name(id),
	     desc, desc[0]=='#'?"":":",
	     desc[0]=='#'?"":rb_class2name(CLASS_OF(obj)));
d3580 1
a3580 1
    return rb_funcall2(obj, missing, argc+1, nargv);
d3944 11
a3954 13
    if (mid != missing) {
	/* receiver specified form for private method */
	if ((noex & NOEX_PRIVATE) && scope == 0)
	    return rb_undefined(recv, mid, argc, argv, CSTAT_PRIV);

	/* self must be kind of a specified form for private method */
	if ((noex & NOEX_PROTECTED)) {
	    VALUE defined_class = klass;
	    while (TYPE(defined_class) == T_ICLASS)
		defined_class = RBASIC(defined_class)->klass;
	    if (!rb_obj_is_kind_of(ruby_frame->self, defined_class))
		return rb_undefined(recv, mid, argc, argv, CSTAT_PROT);
	}
d4862 2
a4863 1
	    rb_bug("undefined method `%s'; can't happen", rb_id2name(id));
a5111 1
    missing = rb_intern("method_missing");
d5876 4
a5879 4
static thread_t curr_thread = 0;
static int num_waiting_on_fd = 0;
static int num_waiting_on_timer = 0;
static int num_waiting_on_join = 0;
d7284 1
a7284 1
    rb_define_global_function("callcc", rb_callcc, 0);
@


1.1.1.3.2.28
log
@backtrace may be Qnil
@
text
@d6 1
a6 1
  $Date: 1999/07/15 07:59:38 $
a4492 1
	vpath = rb_ary_new();
d4494 1
a4494 5
	    VALUE str = RARRAY(rb_load_path)->ptr[i];
	    Check_SafeStr(str);
	    if (RSTRING(str)->len > 0) {
		rb_ary_push(vpath, str);
	    }
d4496 1
a4496 1
	vpath = rb_ary_join(vpath, rb_str_new2(RUBY_PATH_SEP));
d6261 1
a6261 1
	fd_set readfds;
d6577 1
a6577 3
	if (TYPE(oldbt) == T_ARRAY) {
	    rb_ary_unshift(errat, rb_ary_entry(oldbt, 0));
	}
d6710 1
a6710 1
static int thread_abort;
d6715 1
a6715 1
    return thread_abort?Qtrue:Qfalse;
d6722 1
a6722 1
    thread_abort = RTEST(val);
d6901 1
a6901 1
	else if (thread_abort || curr_thread->abort || RTEST(ruby_debug)) {
@


1.1.1.3.2.29
log
@clean toplevel local variables
@
text
@d6 1
a6 1
  $Date: 1999/07/22 10:37:09 $
a5122 3
    if (top_scope && top_scope->local_tbl) {
	rb_mem_clear(top_scope->local_vars, top_scope->local_tbl[0]);
    }
@


1.1.1.3.2.30
log
@990728
@
text
@d6 1
a6 1
  $Date: 1999/07/22 10:58:07 $
d1733 6
a1738 2
	while (node->nd_next) {
	    rb_eval(self, node->nd_head);
d1741 1
a1741 3
	node = node->nd_head;
	goto again;

a4588 1
	ruby_nerrs = 0;
d5123 3
d6585 1
a6585 1
	if (TYPE(oldbt) == T_ARRAY && RARRAY(oldbt)->len > 0) {
@


1.1.1.3.2.31
log
@990806
@
text
@d6 1
a6 1
  $Date: 1999/07/28 09:26:32 $
a400 1
    _frame.tmp  = 0;			\
d423 1
a423 1
    int flags;
a427 4

#define BLOCK_D_SCOPE 1
#define BLOCK_DYNAMIC 2

d444 1
a444 1
    _block.flags = BLOCK_D_SCOPE;	\
d682 1
a682 1
static VALUE rb_yield_0 _((VALUE, VALUE, VALUE, int));
d1162 1
a1162 1
	if (status) {
d1934 1
a1934 1
		    _block.flags &= ~BLOCK_D_SCOPE;
d2005 1
a2005 1
	result = rb_yield_0(result, 0, 0, Qfalse);
d3117 1
a3117 1
rb_yield_0(val, self, klass, acheck)
a3118 1
    int acheck;
d3141 1
a3141 1
    if (block->flags & BLOCK_D_SCOPE) {
d3156 1
a3156 1
		massign(self, block->var, val, acheck);
d3158 1
a3158 1
		assign(self, block->var, val, acheck);
d3214 1
a3214 1
    return rb_yield_0(val, 0, 0, Qfalse);
d3220 1
a3220 1
    for (;;) { rb_yield_0(Qnil, 0, 0, Qfalse); }
a3503 20
VALUE
rb_with_disable_interrupt(proc, data)
    VALUE (*proc)();
    VALUE data;
{
    VALUE result;		/* OK */
    int status;

    DEFER_INTS;
    PUSH_TAG(PROT_NONE);
    if ((status = EXEC_TAG()) == 0) {
	result = (*proc)(data);
    }
    POP_TAG();
    ALLOW_INTS;
    if (status) JUMP_TAG(status);

    return result;
}

d3849 1
d3852 1
a4177 1
    struct FRAME * volatile old_frame;
d4198 1
a4198 2
	frame.tmp = ruby_frame;	/* gc protection */
	old_frame = ruby_frame;
d4236 1
a4236 1
	ruby_frame = old_frame;
a4298 1
/* function to call func under the specified class/module context */
a4339 1
/* string eval under the class/module context */
d4360 1
a4360 26
    if (ruby_block->flags & BLOCK_DYNAMIC) {
	struct BLOCK * volatile old_block = ruby_block;
	struct BLOCK block = *ruby_block;
	volatile VALUE cbase = ruby_block->frame.cbase;
	/* cbase should be pointed from volatile local variable */
	/* to be protected from GC. 				*/
	VALUE result;
	int state;

	/* copy the block to avoid modifying global data. */
	block.frame.cbase = ruby_frame->cbase;
	ruby_block = &block;

	PUSH_TAG(PROT_NONE);
	if ((state = EXEC_TAG()) == 0) {
	    result = rb_yield_0(self, self, ruby_class, Qfalse);
	}
	POP_TAG();
	ruby_block = old_block;
	if (state) JUMP_TAG(state);
	
	return result;
    }
    /* static block, no need to restore */
    ruby_block->frame.cbase = ruby_frame->cbase;
    return rb_yield_0(self, self, ruby_class, Qfalse);
a4362 1
/* block eval under the class/module context */
d4499 1
a4499 1
	vpath = rb_ary_join(vpath, rb_str_new2(PATH_SEP));
a4755 7
VALUE
rb_require(fname)
    const char *fname;
{
    return rb_f_require(Qnil, rb_str_new2(fname));
}

a5416 1
    data->flags |= BLOCK_DYNAMIC;
d5488 1
a5488 1
	result = rb_yield_0(args, 0, 0, Qtrue);
d5874 1
a5874 1
    int flags;		/* misc. states (vmode/rb_trap_immediate/raised) */
a5898 2
#define THREAD_RAISED 0x200

d5957 2
a5958 9
	rb_gc_mark_frame(frame);
	if (frame->tmp) {
	    struct FRAME *tmp = ADJ(frame->tmp);

	    while (tmp && tmp != top_frame) {
		tmp = ADJ(tmp);
		rb_gc_mark_frame(tmp);
		tmp = tmp->prev;
	    }
d5965 3
a5967 1
	rb_gc_mark_frame(&block->frame);
d6028 1
a6028 1
    th->flags = scope_vmode | (rb_trap_immediate<<8);
d6096 2
a6097 2
    scope_vmode = th->flags&SCOPE_MASK;
    rb_trap_immediate = (th->flags&0x100)?1:0;
d6566 10
a6575 11
    if (!rb_thread_dead(th)) {
	if (th == curr_thread)
	    rb_raise(rb_eThreadError, "recursive join");
	if ((th->wait_for & WAIT_JOIN) && th->join == curr_thread)
	    rb_raise(rb_eThreadError, "Thread#join: deadlock - mutual join");
	curr_thread->status = THREAD_STOPPED;
	curr_thread->join = th;
	num_waiting_on_join++;
	curr_thread->wait_for |= WAIT_JOIN;
	rb_thread_schedule();
    }
d6577 1
a6577 1
    if (!NIL_P(th->errinfo) && (th->flags & THREAD_RAISED)) {
a6897 1
	th->flags |= THREAD_RAISED;
d6907 1
a6907 1
	else if (thread_abort || th->abort || RTEST(ruby_debug)) {
d6914 1
a6914 1
	    th->errinfo = ruby_errinfo;
d6941 1
a6941 1
    return rb_yield_0(th->thread, 0, 0, Qfalse);
d6972 1
a6972 2
	if (NIL_P(th->errinfo) && (th->flags & THREAD_RAISED))
	    return Qfalse;
d7323 1
a7323 1
	val = rb_yield_0(tag, 0, 0, Qfalse);
@


1.1.1.3.2.32
log
@1.3.8 to be, final beta (hopefully)
@
text
@d6 1
a6 1
  $Date: 1999/08/06 06:48:10 $
a406 1
    _frame.argv = 0;			\
d2215 1
a2215 4
	    struct FRAME frame = *ruby_frame;

	    frame.tmp = ruby_frame;
	    ruby_frame = &frame;
d2236 1
a2236 1
	    ruby_frame = frame.tmp;
d2850 1
a2850 1
    struct FRAME frame = *ruby_frame;
a2855 3
    frame.tmp = ruby_frame;
    ruby_frame = &frame;

d2891 1
a2891 1
    ruby_frame = frame.tmp;
d4202 1
d4224 1
d4262 1
a4262 1
	ruby_frame = frame.tmp;
d5327 1
a5327 2
    struct FRAME *frame;
    void *tmp;
a5328 8
    frame = data->frame.prev;
    while (frame) {
	if (frame->argc > 0)
	    free(frame->argv);
	tmp = frame;
	frame = frame->prev;
	free(tmp);
    }
d5330 1
a5330 2
	if (data->frame.argc > 0)
	    free(data->frame.argv);
d5346 1
a5346 4
	if (tmp->frame.argc > 0) {
	    tmp->frame.argv = ALLOC_N(VALUE, tmp->frame.argc);
	    MEMCPY(tmp->frame.argv, block->frame.argv, VALUE, tmp->frame.argc);
	}
d5348 1
a5353 20
static void
frame_dup(frame)
    struct FRAME *frame;
{
    VALUE *argv;
    struct FRAME *tmp;

    for (;;) {
	if (frame->argc > 0) {
	    argv = ALLOC_N(VALUE, frame->argc);
	    MEMCPY(argv, frame->argv, VALUE, frame->argc);
	    frame->argv = argv;
	}
	if (!frame->prev) break;
	tmp = ALLOC(struct FRAME);
	*tmp = *frame->prev;
	frame->prev = tmp;
	frame = tmp;
    }
}
d5366 2
a5367 1
    frame_dup(&data->frame);
a5391 1
    frame_dup(&data->frame);
d5395 2
d5470 2
a5471 1
    frame_dup(&data->frame);
@


1.1.1.3.2.33
log
@1.3.8 to be/1999-08-12
@
text
@d6 1
a6 1
  $Date: 1999/08/11 07:23:55 $
d2216 1
a2216 1
	    struct FRAME frame;
a2217 1
	    frame = *ruby_frame;
d2854 1
a2854 1
    struct FRAME frame;
a2859 1
    frame = *ruby_frame;
d4395 1
a4395 1
	struct BLOCK block;
a4401 1
	block = *ruby_block;
d4822 14
d5285 1
a5285 1
    rb_define_global_function("require", rb_f_require, 1);
a5383 1
	frame->tmp = 0;		/* should not preserve tmp */
@


1.1.1.3.2.34
log
@pre 1.4.0
@
text
@d6 1
a6 1
  $Date: 1999/08/12 08:33:04 $
a4091 10
}

VALUE
rb_funcall3(recv, mid, argc, argv)
    VALUE recv;
    ID mid;
    int argc;
    VALUE *argv;
{
    return rb_call(CLASS_OF(recv), recv, mid, argc, argv, 0);
@


1.1.1.2.2.1
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/16 05:13:15 $
d9 1
a9 1
  Copyright (C) 1993-1998 Yukihiro Matsumoto
@


1.1.1.2.2.2
log
@Mon Jan 19 14:06:13 JST 1998
@
text
@d6 1
a6 1
  $Date: 1998/01/16 12:35:44 $
a45 1
#define SCOPE_MODFUNC  FL_USER5
a719 1
    FL_UNSET(top_scope, SCOPE_MODFUNC);
a2121 9
	    if (FL_TEST(the_scope,SCOPE_MODFUNC)) {
		rb_add_method(rb_singleton_class(the_class),
			      node->nd_mid, node->nd_defn, NOEX_PUBLIC);
	    }

	    if (FL_TEST(the_scope, SCOPE_MODFUNC)) {
		rb_funcall(the_class, rb_intern("singleton_method_added"),
			   1, INT2FIX(node->nd_mid));
	    }
a3748 1
    FL_UNSET(top_scope, SCOPE_MODFUNC);
a3940 1
	FL_UNSET(top_scope, SCOPE_MODFUNC);
a3955 1
	FL_UNSET(top_scope, SCOPE_MODFUNC);
d4009 1
a4009 6
    if (argc == 0) {
	FL_SET(the_scope, SCOPE_PRIVATE);
	FL_SET(the_scope, SCOPE_MODFUNC);
	return module;
    }

a4017 1
	rb_clear_cache_by_id(id);
@


1.1.1.2.2.3
log
@tkmenubar
@
text
@d6 1
a6 1
  $Date: 1998/01/19 05:08:20 $
d286 7
a292 7
    struct FRAME _frame;		\
    _frame.prev = the_frame;		\
    _frame.file = sourcefile;		\
    _frame.line = sourceline;		\
    _frame.iter = the_iter->iter;	\
    _frame.cbase = the_frame->cbase;	\
    the_frame = &_frame;		\
d294 1
a294 1
#define POP_FRAME()  the_frame = _frame.prev; }
d313 14
a326 14
    struct BLOCK _block;		\
    _block.tag = prot_tag;		\
    _block.var = v;			\
    _block.body = b;			\
    _block.self = self;			\
    _block.frame = *the_frame;		\
    _block.class = the_class;		\
    _block.frame.file = sourcefile;	\
    _block.frame.line = sourceline;	\
    _block.scope = the_scope;		\
    _block.d_vars = the_dyna_vars;	\
    _block.prev = the_block;		\
    _block.iter = the_iter->iter;	\
    the_block = &_block;
d329 4
a332 4
    struct BLOCK _block;		\
    _block = *b;			\
    _block.prev = the_block;		\
    the_block = &_block;
d335 1
a335 1
   the_block = _block.prev; 		\
d420 12
d437 1
a437 1
    VALUE retval;
d443 9
a451 9
    struct tag _tag;			\
    _tag.retval = Qnil;			\
    _tag.frame = the_frame;		\
    _tag.iter = the_iter;		\
    _tag.prev = prot_tag;		\
    _tag.retval = Qnil;			\
    _tag.tag = ptag;			\
    _tag.dst = 0;			\
    prot_tag = &_tag;
d466 1
a466 1
    prot_tag = _tag.prev;		\
d1376 1
a1376 1
    *the_frame = *_frame.prev;
d1611 1
a1611 1
		    result = prot_tag->retval;
d2582 1
a2582 1
    *the_frame = *_frame.prev->prev;
d2809 1
a2809 1
	    retval = prot_tag->retval;
d2982 1
a2982 1
    *the_frame = *_frame.prev->prev;
d3315 1
a3315 1
		result = prot_tag->retval;
d3658 2
a3659 2
    the_frame->last_func = _frame.last_func;
    the_frame->last_class = _frame.last_class;
d5744 1
a5744 1
	val = prot_tag->retval;
d5768 1
a5768 1
	    tt->retval = value;
d5796 1
a5796 1
	    tt->retval = val;
@


1.1.1.2.2.4
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/22 03:34:26 $
a1105 11
#if defined(C_ALLOCA) && defined(THREAD)
# define TMP_PROTECT NODE *__protect_tmp=0
# define ALLOCTMP(type,n)						   \
    (__protect_tmp = node_newnode(NODE_ALLOCA,				   \
			     str_new(0,sizeof(type)*(n)),0,__protect_tmp), \
     (void*)RSTRING(__protect_tmp->nd_head)->ptr)
#else
# define TMP_PROTECT typedef int foobazzz
# define ALLOCTMP(type,n) ALLOCA_N(type,n)
#endif

d1119 1
a1119 1
	    argv = ALLOCTMP(VALUE,argc);\
a1759 1
	    TMP_PROTECT;
a1771 1
	    TMP_PROTECT;
a1787 1
	    TMP_PROTECT;
a1838 1
	    TMP_PROTECT;
a2327 1
    TMP_PROTECT;
d2339 1
a2339 1
	VALUE *vars = ALLOCTMP(VALUE, node->nd_tbl[0]+1);
a2829 1
    TMP_PROTECT;
a3038 1
    TMP_PROTECT;
d3227 1
a3227 1
		local_vars = ALLOCTMP(VALUE, body->nd_tbl[0]+1);
a3723 1
    TMP_PROTECT;
d3739 1
a3739 1
	VALUE *vars = ALLOCTMP(VALUE, len);
@


1.1.1.2.2.5
log
@singleton class def causes SEGV
@
text
@d6 1
a6 1
  $Date: 1998/01/22 08:12:08 $
a2298 3
	    }
	    else {
		class = CLASS_OF(class);
@


1.1.1.2.2.6
log
@initialize made private
@
text
@d6 1
a6 1
  $Date: 1998/01/22 08:22:26 $
d2120 1
a2120 1
	    if (FL_TEST(the_scope,SCOPE_PRIVATE) || node->nd_mid == init) {
d2130 3
@


1.1.1.2.2.7
log
@singleton class
@
text
@d6 1
a6 1
  $Date: 1998/01/22 08:32:47 $
d2295 1
d2297 4
a2300 2
	    class = rb_singleton_class(class);
	    
@


1.1.1.2.2.8
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/23 04:38:31 $
d1108 1
a1108 1
# define TMP_ALLOC(type,n)						   \
d1114 1
a1114 1
# define TMP_ALLOC(type,n) ALLOCA_N(type,n)
d1130 1
a1130 1
	    argv = TMP_ALLOC(VALUE,argc);\
d2352 1
a2352 1
	VALUE *vars = TMP_ALLOC(VALUE, node->nd_tbl[0]+1);
d3242 1
a3242 1
		local_vars = TMP_ALLOC(VALUE, body->nd_tbl[0]+1);
d3755 1
a3755 1
	VALUE *vars = TMP_ALLOC(VALUE, len);
@


1.1.1.2.2.9
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/01/27 05:23:41 $
d736 1
d739 2
d743 2
a744 3
	ruby_require_modules();
	eval_tree = 0;
	ruby_load_script();
@


1.1.1.2.2.10
log
@1.1b7 pre
@
text
@d6 1
a6 1
  $Date: 1998/02/03 10:02:55 $
d55 1
a55 1
    VALUE klass;		/* receiver's class */
d91 2
a92 2
rb_add_method(klass, mid, node, noex)
    VALUE klass;
d99 1
a99 1
    if (NIL_P(klass)) klass = cObject;
d101 1
a101 1
    st_insert(RCLASS(klass)->m_tbl, mid, body);
d105 2
a106 2
rb_remove_method(klass, mid)
    VALUE klass;
d111 1
a111 1
    if (!st_delete(RCLASS(klass)->m_tbl, &mid, &body)) {
d113 1
a113 1
		  rb_id2name(mid), rb_class2name(klass));
d119 2
a120 2
search_method(klass, id, origin)
    VALUE klass, *origin;
d125 3
a127 3
    while (!st_lookup(RCLASS(klass)->m_tbl, id, &body)) {
	klass = RCLASS(klass)->super;
	if (!klass) return 0;
d130 1
a130 1
    if (origin) *origin = klass;
d135 2
a136 2
rb_get_method_body(klassp, idp, noexp)
    VALUE *klassp;
d141 1
a141 1
    VALUE klass = *klassp;
d146 1
a146 1
    if ((body = search_method(klass, id, &origin)) == 0) {
d152 2
a153 2
    ent = cache + EXPR1(klass, id);
    ent->klass  = klass;
d158 1
a158 1
	*klassp = body->nd_orig;
d164 1
a164 1
	*klassp = origin;
d175 2
a176 2
rb_alias(klass, name, def)
    VALUE klass;
d183 1
a183 1
    orig = search_method(klass, def, &origin);
d185 1
a185 1
	if (TYPE(klass) == T_MODULE) {
d191 1
a191 1
		  rb_id2name(def), rb_class2name(klass));
d200 1
a200 1
    st_insert(RCLASS(klass)->m_tbl, name,
d205 2
a206 2
rb_export_method(klass, name, noex)
    VALUE klass;
d211 1
a211 1
    VALUE origin;
d213 2
a214 2
    body = search_method(klass, name, &origin);
    if (!body && TYPE(klass) == T_MODULE) {
d219 1
a219 1
		  rb_id2name(name), rb_class2name(klass));
d222 1
a222 1
	if (klass == origin) {
d227 1
a227 1
	    rb_add_method(klass, name, NEW_ZSUPER(), noex);
d233 2
a234 2
method_boundp(klass, id, ex)
    VALUE klass;
d240 1
a240 1
    if (rb_get_method_body(&klass, &id, &noex)) {
d249 2
a250 2
rb_method_boundp(klass, id, ex)
    VALUE klass;
d254 1
a254 1
    if (method_boundp(klass, id, ex))
d302 1
a302 1
    VALUE klass;
d319 1
a319 1
    _block.klass = the_class;		\
a735 1
	NODE *save;
d738 3
a740 2
	ext_init = 1;	/* Init_ext() called in ruby_process_options */
	save = eval_tree;
d742 1
a742 2
	ruby_require_modules();
	eval_tree = save;
d1015 1
a1015 1
	struct RClass *klass = RCLASS(cbase->nd_clss);
d1017 2
a1018 2
	if (klass->iv_tbl &&
	    st_lookup(klass->iv_tbl, id, 0)) {
d1035 1
a1035 1
	struct RClass *klass = RCLASS(cbase->nd_clss);
d1037 2
a1038 2
	if (klass->iv_tbl &&
	    st_lookup(klass->iv_tbl, id, &result)) {
d1094 2
a1095 2
mod_alias_method(mod, newname, oldname)
    VALUE mod, newname, oldname;
d1097 1
a1097 1
    ID id = rb_to_id(newname);
d1099 1
a1099 1
    rb_alias(mod, id, rb_to_id(oldname));
d1824 1
a1824 1
	    if (node->nd_rval) the_frame->cbase = node->nd_rval;
d1956 1
a1956 1
	    VALUE klass;
d1958 2
a1959 2
	    klass = rb_eval(self, node->nd_head);
	    switch (TYPE(klass)) {
d1964 1
a1964 1
		Check_Type(klass, T_CLASS);
d1967 1
a1967 1
	    result = rb_const_get_at(klass, node->nd_mid);
d2112 1
a2112 1
		if (origin == the_class) {
d2147 1
a2147 1
	    VALUE klass;
d2163 2
a2164 2
	    klass = rb_singleton_class(recv);
	    if (st_lookup(RCLASS(klass)->m_tbl, node->nd_mid, &body)) {
d2168 1
a2168 1
	    rb_add_method(klass, node->nd_mid, node->nd_defn, NOEX_PUBLIC);
d2183 1
a2183 1
			  rb_id2name(node->nd_mid), rb_class2name(the_class));
d2205 1
a2205 1
	    VALUE super, klass, tmp;
d2215 1
a2215 1
		(the_class != cObject ||
d2218 2
a2219 2
		klass = rb_const_get_at(the_class, node->nd_cname);
		if (TYPE(klass) != T_CLASS) {
d2223 1
a2223 1
		    tmp = RCLASS(klass)->super;
d2242 3
a2244 3
		klass = rb_define_class_id(node->nd_cname, super);
		rb_const_set(the_class, node->nd_cname, klass);
		rb_set_class_path(klass,the_class,rb_id2name(node->nd_cname));
d2247 1
a2247 1
	    return module_setup(klass, node->nd_body);
d2256 1
a2256 1
		(the_class != cObject ||
d2279 1
a2279 1
	    VALUE klass;
d2281 2
a2282 2
	    klass = rb_eval(self, node->nd_recv);
	    if (FIXNUM_P(klass)) {
d2285 1
a2285 1
	    if (NIL_P(klass)) {
d2288 1
a2288 1
	    if (rb_special_const_p(klass)) {
d2291 1
a2291 1
	    if (FL_TEST(CLASS_OF(klass), FL_SINGLETON)) {
d2294 1
a2294 1
	    klass = rb_singleton_class(klass);
d2296 1
a2296 1
	    result = module_setup(klass, node->nd_body);
d2367 1
a2367 1
	result = rb_eval(the_class, node->nd_body);
d2627 1
a2627 1
    the_class = block->klass;
d3036 2
a3037 2
rb_call(klass, recv, mid, argc, argv, scope)
    VALUE klass, recv;
d3055 3
a3057 3
    ent = cache + EXPR1(klass, mid);
    if (ent->mid == mid && ent->klass == klass) {
	klass = ent->origin;
d3062 1
a3062 1
    else if ((body = rb_get_method_body(&klass, &id, &noex)) == 0) {
d3085 1
a3085 1
	if (RCLASS(klass)->super == 0) {
d3087 1
a3087 1
	    struct RClass *cl = RCLASS(klass);
d3089 3
a3091 3
	    klass = RBASIC(recv)->klass;
	    while (klass) {
		if (RCLASS(klass)->m_tbl == cl->m_tbl)
d3093 1
a3093 1
		klass = RCLASS(klass)->super;
d3097 1
a3097 1
	    klass = RCLASS(klass)->super;
d3108 1
a3108 1
    the_frame->last_class = klass;
d3215 1
a3215 1
			len, rb_class2name(klass), rb_id2name(mid));
d3587 1
a3587 1
	the_class = RBASIC(the_class)->klass;
d4078 1
a4078 1
class_new_instance(argc, argv, klass)
d4081 1
a4081 1
    VALUE klass;
d4085 1
a4085 1
    if (FL_TEST(klass, FL_SINGLETON)) {
d4088 1
a4088 1
    obj = obj_alloc(klass);
d4372 2
a4373 2
proc_s_new(klass)
    VALUE klass;
d4382 1
a4382 1
    proc = Data_Make_Struct(klass, struct BLOCK, blk_mark, blk_free, data);
a4416 16
static int
blk_orphan(data)
    struct BLOCK *data;
{
    if (data->scope && data->scope != top_scope &&
	(data->scope->flag & SCOPE_NOSTACK)) {
	return 1;
    }
#ifdef THREAD
    if (data->orig_thread != thread_current()) {
	return 1;
    }
#endif
    return 0;
}

a4438 6
    orphan = blk_orphan(data);

    /* PUSH BLOCK from data */
    PUSH_BLOCK2(data);
    PUSH_ITER(ITER_CUR);
    the_frame->iter = ITER_CUR;
d4440 12
d4454 1
a4454 1
	    the_block->frame.iter = ITER_CUR;
d4457 1
a4457 1
	    the_block->frame.iter = ITER_NOT;
d4461 4
a4511 70
static VALUE
proc_iterate(proc)
    VALUE proc;
{
    VALUE lambda = f_lambda();
    struct BLOCK *data;
    volatile VALUE result = Qnil;
    int state;
    volatile int orphan;
    volatile int safe = safe_level;

    Data_Get_Struct(lambda, struct BLOCK, data);
    data->frame.iter = ITER_PRE;
    data->iter = ITER_PRE;

    Data_Get_Struct(proc, struct BLOCK, data);
    orphan = blk_orphan(data);

    /* PUSH BLOCK from data */
    PUSH_BLOCK2(data);
    PUSH_ITER(ITER_PRE);
    the_frame->iter = ITER_PRE;
    if (FL_TEST(proc, PROC_TAINT)) {
	switch (RBASIC(proc)->flags & PROC_TMASK) {
	  case PROC_T3:
	    safe_level = 3;
	    break;
	  case PROC_T4:
	    safe_level = 4;
	    break;
	  case PROC_T5:
	    safe_level = 5;
	    break;
	}
    }

    PUSH_TAG(PROT_NONE);
    state = EXEC_TAG();
    if (state == 0) {
	result = proc_call(lambda, Qnil);
    }
    POP_TAG();

    POP_ITER();
    if (the_block->tag->dst == state) {
	state &= TAG_MASK;
	orphan = 2;
    }
    POP_BLOCK();
    safe_level = safe;

    if (state) {
	if (orphan == 2) {/* escape from orphan procedure */
	    switch (state) {
	      case TAG_BREAK:
		Raise(eLocalJumpError, "break from proc-closure");
		break;
	      case TAG_RETRY:
		Raise(eLocalJumpError, "retry from proc-closure");
		break;
	      case TAG_RETURN:
		Raise(eLocalJumpError, "return from proc-closure");
		break;
	    }
	}
	JUMP_TAG(state);
    }
    return result;
}

a4520 1
    rb_define_method(cProc, "iterate", proc_iterate, 0);
d4587 1
a4587 1
    VALUE klass;
d4732 1
a4732 1
    th->klass = the_class;
d4789 1
a4789 1
    the_class = th->klass;
d4794 1
d5401 1
a5401 1
    th->klass = 0;
@


1.1.1.2.2.11
log
@pass_block, etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/09 10:56:19 $
a3398 22
static VALUE
f_pass_block(argc, argv, recv)
    int argc;
    VALUE *argv;
    VALUE recv;
{
    VALUE vid;

    if (argc == 0) ArgError("no iterator name given");
    if (iterator_p())
	ArgError("iterator block given to pass_block");
    if (!f_iterator_p())
	ArgError("pass_block called out of iterator");

    vid = argv[0]; argc--; argv++;
    PUSH_ITER(ITER_PRE);
    vid = rb_call(CLASS_OF(recv), recv, rb_to_id(vid), argc, argv, 1);
    POP_ITER();

    return vid;
}

a4250 1
    rb_define_method(mKernel, "pass_block", f_pass_block, -1);
@


1.1.1.2.2.12
log
@1.1b8pre1
@
text
@d6 1
a6 1
  $Date: 1998/02/16 06:05:45 $
a1971 4
      case NODE_COLON3:
	result = rb_const_get_at(cObject, node->nd_mid);
	break;

d3381 1
d3385 7
a3391 1
    vid = *argv++; argc--;
d3393 1
a3393 1
    vid = rb_call(CLASS_OF(recv), recv, rb_to_id(vid), argc, argv, 1);
d3413 1
a3413 1
    vid = *argv++; argc--;
d4352 6
a4357 9
    while (data) {
	gc_mark_frame(&data->frame);
	gc_mark(data->scope);
	gc_mark(data->var);
	gc_mark(data->body);
	gc_mark(data->self);
	gc_mark(data->d_vars);
	data = data->prev;
    }
d4364 1
a4364 24
    struct BLOCK *tmp;

    while (data) {
	free(data->frame.argv);
	tmp = data;
	data = data->prev;
	free(tmp);
    }
}

static void
blk_copy_prev(block)
    struct BLOCK *block;
{
    struct BLOCK *tmp;

    while (block->prev) {
	tmp = ALLOC_N(struct BLOCK, 1);
	MEMCPY(tmp, block->prev, struct BLOCK, 1);
	tmp->frame.argv = ALLOC_N(VALUE, tmp->frame.argc);
	MEMCPY(tmp->frame.argv, block->frame.argv, VALUE, tmp->frame.argc);
	block->prev = tmp;
	block = tmp;
    }
a4377 3
#ifdef THREAD
    data->orig_thread = thread_current();
#endif
a4382 7
    if (data->iter) {
	blk_copy_prev(data);
    }
    else {
	data->prev = 0;
    }

a4414 6
    if (data->iter) {
	blk_copy_prev(data);
    }
    else {
	data->prev = 0;
    }
a4796 1
    free(th);
@


1.1.1.2.2.13
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/02/18 01:56:34 $
d4445 1
a4445 1
    data->iter = data->prev?TRUE:FALSE;
@


1.1.1.2.2.14
log
@reserved words & etc.
@
text
@d6 1
a6 1
  $Date: 1998/02/23 05:36:36 $
a453 2
    if (_tag.prev)			\
        _tag.prev->retval = _tag.retval;\
d1397 1
a1397 3
static void return_check _((void));
#define return_value(v) prot_tag->retval = (v)

d1698 1
a1698 6
	if (node->nd_ensr) {
	    VALUE retval = prot_tag->retval; /* save retval */

	    rb_eval(self, node->nd_ensr);
	    return_value(retval);
	}
a1762 1
	return_check();
a3702 18
mod_eval(arg)
    VALUE *arg;
{
    return eval_under(arg[0], arg[0], arg[1]);
}

static void
mod_eval_ensure(a)
    int *a;
{
    if (a[0]) {
	FL_TEST(the_scope, SCOPE_PRIVATE);
    }
    if (a[1]) {
	FL_TEST(the_scope, SCOPE_MODFUNC);
    }
}

d3707 1
a3707 11
    int f[2];
    VALUE arg[2];

    f[0] = FL_TEST(the_scope, SCOPE_PRIVATE);
    f[1] = FL_TEST(the_scope, SCOPE_MODFUNC);

    FL_UNSET(the_scope, SCOPE_PRIVATE);
    FL_UNSET(the_scope, SCOPE_MODFUNC);

    arg[0] = mod; arg[1] = src;
    return rb_ensure(mod_eval, arg, mod_eval_ensure, f);
d5915 1
a5915 1
	    Raise(eThreadError, "uncaught throw `%s' in thread 0x%x",
d5924 1
a5924 1
	NameError("uncaught throw `%s'", rb_id2name(t));
d5931 2
a5932 1
return_check()
d5935 1
a5935 1

d5938 1
d5943 1
a5943 1
	    Raise(eThreadError, "return from within thread 0x%x",
d5950 1
@


1.1.1.2.2.15
log
@1.1b8_00?
@
text
@d6 1
a6 1
  $Date: 1998/02/25 06:52:42 $
a2921 1
    VALUE retval;
d2928 1
a2928 1
    retval = prot_tag->retval;	/* save retval */
a2929 2
    return_value(retval);

d3713 18
d3735 5
a3739 3
    int state;
    int private, modfunc;
    VALUE result = Qnil;
a3740 2
    private = FL_TEST(the_scope, SCOPE_PRIVATE);
    modfunc = FL_TEST(the_scope, SCOPE_MODFUNC);
a3742 12
    PUSH_TAG(PROT_NONE)
    if ((state = EXEC_TAG()) == 0) {
	result = eval_under(mod, mod, src);
    }
    POP_TAG();
    if (private) {
	FL_TEST(the_scope, SCOPE_PRIVATE);
    }
    if (modfunc) {
	FL_TEST(the_scope, SCOPE_MODFUNC);
    }
    if (state) JUMP_TAG(state);
d3744 2
a3745 1
    return result;
a5970 1
#ifdef THREAD
d5977 1
d5982 1
a5984 1
#endif
@


1.1.1.2.2.16
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/02/26 08:27:08 $
d5466 2
a5467 1
thread_stop()
d5469 2
d5472 1
a5472 4
    curr_thread->status = THREAD_STOPPED;
    if (curr_thread == curr_thread->next) {
	Raise(eThreadError, "stopping only thread");
    }
d5475 7
d5890 1
@


1.1.1.2.2.17
log
@shugo's method etc.
@
text
@d6 1
a6 1
  $Date: 1998/03/03 02:39:32 $
d3054 1
a3054 1
rb_call0(klass, recv, mid, id, argc, argv, scope, body, type)
d3056 1
a3056 1
    ID    mid, id;
a3059 2
    NODE *body;
    enum node_type type;
d3061 4
a3064 1
    NODE *b2;		/* OK */
d3067 1
d3069 18
d3098 22
d3274 3
a3276 2
		NODE *node = 0;
		int i;
a3277 9
		if (nd_type(body) == NODE_ARGS) {
		    node = body;
		    body = 0;
		}
		else if (nd_type(body) == NODE_BLOCK) {
		    node = body->nd_head;
		    body = body->nd_next;
		}
		if (node) {
d3282 1
d3324 3
a3326 1

a3375 55
static VALUE
rb_call(klass, recv, mid, argc, argv, scope)
    VALUE klass, recv;
    ID    mid;
    int argc;			/* OK */
    VALUE *argv;		/* OK */
    int scope;
{
    NODE *body;			/* OK */
    int    noex;
    ID     id = mid;
    struct cache_entry *ent;
    enum node_type type;
    TMP_PROTECT;

  again:
    /* is it in the method cache? */
    ent = cache + EXPR1(klass, mid);
    if (ent->mid == mid && ent->klass == klass) {
	klass = ent->origin;
	id    = ent->mid0;
	noex  = ent->noex;
	body  = ent->method;
    }
    else if ((body = rb_get_method_body(&klass, &id, &noex)) == 0) {
	return rb_undefined(recv, mid, argc, argv, scope==2?CSTAT_VCALL:0);
    }

    /* receiver specified form for private method */
    if (noex == NOEX_PRIVATE && scope == 0)
	return rb_undefined(recv, mid, argc, argv, CSTAT_NOEX);

    type = nd_type(body);
    if (type == NODE_ZSUPER) {
	/* for re-scoped/renamed method */
	mid = id;
	if (scope == 0) scope = 1;
	if (BUILTIN_TYPE(klass) == T_MODULE) {
	    /* origin is the Module, so need to scan superclass hierarchy. */
	    struct RClass *cl = RCLASS(klass);

	    klass = RBASIC(recv)->klass;
	    while (klass) {
		if (RCLASS(klass)->m_tbl == cl->m_tbl)
		    break;
		klass = RCLASS(klass)->super;
	    }
	}
	klass = RCLASS(klass)->super;
	goto again;
    }

    return rb_call0(klass, recv, mid, id, argc, argv, scope, body, type);
}

a4684 107
static VALUE cMethod;
struct METHOD {
    VALUE klass;
    VALUE recv;
    ID id;
    NODE *body;
};

static void
bm_mark(struct METHOD *data)
{
    gc_mark(data->klass);
    gc_mark(data->recv);
    gc_mark(data->body);
}

static VALUE
obj_method(obj, vid)
    VALUE obj;
    VALUE vid;
{
    VALUE method;
    VALUE klass = CLASS_OF(obj);
    ID mid, id;
    NODE *body;
    int noex;
    enum node_type type;
    struct METHOD *data;

    mid = id = rb_to_id(vid);

  again:
    if ((body = rb_get_method_body(&klass, &id, &noex)) == 0) {
	return rb_undefined(obj, mid, 0, 0, 0);
    }

    type = nd_type(body);
    if (type == NODE_ZSUPER) {
	/* for re-scoped/renamed method */
	mid = id;
	if (BUILTIN_TYPE(klass) == T_MODULE) {
	    /* origin is the Module, so need to scan superclass hierarchy. */
	    struct RClass *cl = RCLASS(klass);

	    klass = RBASIC(obj)->klass;
	    while (klass) {
		if (RCLASS(klass)->m_tbl == cl->m_tbl)
		    break;
		klass = RCLASS(klass)->super;
	    }
	}
	klass = RCLASS(klass)->super;
	goto again;
    }
    if (BUILTIN_TYPE(klass) == T_ICLASS) {
	klass = RBASIC(klass)->klass;
    }

    method = Data_Make_Struct(cMethod, struct METHOD, bm_mark, free, data);
    data->klass = klass;
    data->recv = obj;
    data->id = id;
    data->body = body;

    return method;
}

static VALUE
method_call(argc, argv, method)
    int argc;
    VALUE *argv;
    VALUE method;
{
    VALUE result;
    struct METHOD *data;

    Data_Get_Struct(method, struct METHOD, data);
    PUSH_ITER(iterator_p()?ITER_PRE:ITER_NOT);
    result = rb_call0(data->klass, data->recv, data->id, data->id,
		      argc, argv, 1, data->body, nd_type(data->body));
    POP_ITER();
    return result;
}

static VALUE
method_inspect(method)
    VALUE method;
{
    struct METHOD *data;
    VALUE str;
    char *s;

    Data_Get_Struct(method, struct METHOD, data);
    str = str_new2("#<");
    s = rb_class2name(CLASS_OF(method));
    str_cat(str, s, strlen(s));
    str_cat(str, ": ", 2);
    s = rb_class2name(data->klass);
    str_cat(str, s, strlen(s));
    str_cat(str, "#", 1);
    s = rb_id2name(data->id);
    str_cat(str, s, strlen(s));
    str_cat(str, ">", 1);

    return str;
}

a4697 6

    cMethod = rb_define_class("Method", cObject);
    rb_undef_method(CLASS_OF(cMethod), "new");
    rb_define_method(cMethod, "call", method_call, -1);
    rb_define_method(cMethod, "inspect", method_inspect, 0);
    rb_define_method(mKernel, "method", obj_method, 1);
@


1.1.1.2.2.18
log
@block arg etc.
@
text
@d6 1
a6 1
  $Date: 1998/03/03 10:16:13 $
a40 1
static VALUE cBinding;
a43 2
static VALUE f_iterator_p _((void));
static VALUE block_pass _((VALUE,NODE*));
a1582 4
      case NODE_BLOCK_PASS:
	result = block_pass(self, node);
	break;

d1898 2
a1899 2
	result = rb_eval(self, node->nd_value);
	the_scope->local_vars[node->nd_cnt] = result;
a1964 12
      case NODE_BLOCK_ARG:
	if (the_scope->local_vars == 0)
	    Bug("unexpected block argument");
	if (iterator_p()) {
	    result = f_lambda();
	    the_scope->local_vars[node->nd_cnt] = result;
	}
	else {
	    result = Qnil;
	}
	break;

d2949 1
a2950 1
    VALUE desc = 0;
d2969 1
a2969 1
	desc = any_to_s(obj);
d3054 1
a3054 1
rb_call0(klass, recv, id, argc, argv, scope, body)
d3056 1
a3056 1
    ID    id;
d3061 1
a3066 1
    TMP_PROTECT;
d3088 1
a3088 1
    switch (nd_type(body)) {
d3191 1
a3191 1
			len, rb_class2name(klass), rb_id2name(id));
a3200 2
	/* for re-scoped/renamed method */
      case NODE_ZSUPER:
d3351 2
d3354 1
d3371 21
a3391 1
    return rb_call0(klass, recv, id, argc, argv, scope, body);
d3427 21
d4322 1
d4450 1
a4450 1
    bind = Data_Make_Struct(cBinding, struct BLOCK, blk_mark,blk_free,data);
d4634 2
a4635 3
block_pass(self, node)
    VALUE self;
    NODE *node;
d4637 1
a4637 1
    VALUE block = rb_eval(self, node->nd_body);
d4644 3
a4646 6
    if (TYPE(block) != T_DATA
	|| RDATA(block)->dfree != blk_free
	|| !obj_is_kind_of(block, cProc)) {
	TypeError("wrong argument type %s (expected Proc)",
		  rb_class2name(CLASS_OF(block)));
    }
d4648 1
a4648 1
    Data_Get_Struct(block, struct BLOCK, data);
d4655 2
a4656 2
    if (FL_TEST(block, PROC_TAINT)) {
	switch (RBASIC(block)->flags & PROC_TMASK) {
d4672 1
a4672 1
	result = rb_eval(self, node->nd_iter);
a4703 1

d4705 1
a4705 1
    VALUE klass, oklass;
d4707 1
a4707 1
    ID id, oid;
a4713 1
    gc_mark(data->oklass);
d4732 1
a4732 1
    id = rb_to_id(vid);
d4736 1
a4736 1
	return rb_undefined(obj, rb_to_id(vid), 0, 0, 0);
d4739 15
a4753 1
    if (nd_type(body) == NODE_ZSUPER) {
d4757 3
a4765 2
    data->oklass = CLASS_OF(obj);
    data->oid = rb_to_id(vid);
d4781 2
a4782 2
    result = rb_call0(data->klass, data->recv, data->id,
		      argc, argv, 1, data->body);
d4800 1
a4800 1
    s = rb_class2name(data->oklass);
d4803 1
a4803 1
    s = rb_id2name(data->oid);
d4819 1
a4822 1
    cBinding = rb_define_class("Binding", cData);
a4827 1
    rb_define_method(cMethod, "to_s", method_inspect, 0);
d5861 1
a5861 1
thread_stop_p(thread)
d6018 1
a6018 1
    rb_define_method(cThread, "stop?", thread_stop_p, 0);
@


1.1.1.2.2.19
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/03/05 06:37:43 $
a46 2
static VALUE cMethod;
static VALUE method_proc _((VALUE));
d4621 1
a4621 4
    if (obj_is_kind_of(block, cMethod)) {
	block = method_proc(block);
    }
    else if (TYPE(block) != T_DATA
d4683 2
a4776 32
static VALUE
mproc()
{
    VALUE proc;

    /* emulate ruby's method call */
    PUSH_ITER(ITER_CUR);
    PUSH_FRAME();
    proc = f_lambda();
    POP_FRAME();
    POP_ITER();

    return proc;
}

static VALUE
mcall(args, method)
    VALUE args, method;
{
    if (TYPE(args) == T_ARRAY) {
	return method_call(RARRAY(args)->len, RARRAY(args)->ptr, method);
    }
    return method_call(1, &args, method);
}

static VALUE
method_proc(method)
    VALUE method;
{
    return rb_iterate(mproc, 0, mcall, method);
}

a4795 1
    rb_define_method(cMethod, "to_proc", method_proc, 0);
@


1.1.1.2.2.20
log
@1.1b9_00
@
text
@d6 1
a6 1
  $Date: 1998/03/06 10:07:52 $
d2168 2
a2169 2
		rb_funcall(rb_iv_get(the_class, "__attached__"),
			   rb_intern("singleton_method_added"),
d2218 2
a2219 14
		char *s0 = " class";
		VALUE klass = the_class;

		if (FL_TEST(the_class, FL_SINGLETON)) {
		    VALUE obj = rb_iv_get(the_class, "__attached__");
		    switch (TYPE(obj)) {
		      case T_MODULE:
		      case T_CLASS:
			klass = obj;
			s0 = "";
		    }
		}
		NameError("undefined method `%s' for%s `%s'",
			  rb_id2name(node->nd_mid),s0,rb_class2name(klass));
@


1.1.1.2.2.21
log
@gets speed up patch
@
text
@d6 1
a6 1
  $Date: 1998/03/09 07:56:54 $
d38 2
d109 14
a209 62
remove_method(klass, mid)
    VALUE klass;
    ID mid;
{
    NODE *body;

    if (!st_delete(RCLASS(klass)->m_tbl, &mid, &body)) {
	NameError("method `%s' not defined in %s",
		  rb_id2name(mid), rb_class2name(klass));
    }
    rb_clear_cache_by_id(mid);
}

void
rb_remove_method(klass, name)
    VALUE klass;
    char *name;
{
    remove_method(klass, rb_intern(name));
}

void
rb_disable_super(klass, name)
    VALUE klass;
    char *name;
{
    VALUE origin;
    NODE *body;
    ID mid = rb_intern(name);

    body = search_method(klass, mid, &origin);
    if (!body || !body->nd_body) {
	NameError("undefined method `%s' for `%s'",
		  rb_id2name(mid), rb_class2name(klass));
    }
    if (origin == klass) {
	body->nd_noex |= NOEX_UNDEF;
    }
    else {
	rb_clear_cache_by_id(mid);
	rb_add_method(the_class, mid, 0, NOEX_UNDEF);
    }
}

void
rb_enable_super(klass, name)
    VALUE klass;
    char *name;
{
    VALUE origin;
    NODE *body;
    ID mid = rb_intern(name);

    body = search_method(klass, mid, &origin);
    if (!body || !body->nd_body || origin != klass) {
	NameError("undefined method `%s' for `%s'",
		  rb_id2name(mid), rb_class2name(klass));
    }
    body->nd_noex &= ~NOEX_UNDEF;
}

static void
d246 1
a246 1
	if (ex && noex & NOEX_PRIVATE)
d1086 1
a1086 1
    remove_method(mod, rb_to_id(name));
a1820 4
	    if (the_frame->last_class == 0) {	
		NameError("superclass method `%s' disabled",
			  rb_id2name(the_frame->last_func));
	    }
d1833 1
a1833 1
			     the_frame->last_func, argc, argv, 3);
a2159 3
	    if (body && origin == the_class && body->nd_noex & NOEX_UNDEF) {
		noex |= NOEX_UNDEF;
	    }
d2204 1
a2204 2
	    rb_add_method(klass, node->nd_mid, node->nd_defn, 
			  NOEX_PUBLIC|(body?body->nd_noex&NOEX_UNDEF:0));
d3087 1
a3087 1
rb_call0(klass, recv, id, argc, argv, body, nosuper)
d3092 1
a3093 1
    int nosuper;
d3117 1
a3117 1
    the_frame->last_class = nosuper?0:klass;
a3395 3
	if (scope == 3) {
	    NameError("super: no superclass method `%s'", rb_id2name(mid));
	}
d3400 1
a3400 1
    if (noex & NOEX_PRIVATE && scope == 0)
d3403 1
a3403 1
    return rb_call0(klass, recv, id, argc, argv, body, noex & NOEX_UNDEF);
d4326 1
a4326 1
    rb_define_method(cModule, "remove_method", mod_remove_method, 1);
d4764 1
a4764 1
		      argc, argv, data->body, 0);
d4836 1
a4836 1
    cBinding = rb_define_class("Binding", cObject);
@


1.1.1.2.2.22
log
@speed up patch 4
@
text
@d6 1
a6 1
  $Date: 1998/03/11 07:32:54 $
d3357 1
a3357 2
			    /* +2 for $_ and $~ */
			    MEMCPY(local_vars+2, argv, VALUE, i);
@


1.1.1.2.2.23
log
@1.1b9_02
@
text
@d6 1
a6 1
  $Date: 1998/03/12 01:15:14 $
d1882 2
a1883 3
	    result = rb_call(RCLASS(the_frame->last_class)->super,
			     the_frame->self, the_frame->last_func,
			     argc, argv, 3);
d2237 1
a2237 1
	    NODE *body = 0;
a3171 1
    the_frame->self = recv;
@


1.1.1.2.2.24
log
@1.1b9_03 pre2
@
text
@d6 1
a6 1
  $Date: 1998/03/13 09:04:29 $
a2624 1
    trap_restore_mask();
a6158 1
    trap_restore_mask();
@


1.1.1.2.2.25
log
@thread_free
@
text
@d6 1
a6 1
  $Date: 1998/03/16 06:37:10 $
d5078 1
a5078 1
    if (th != main_thread) free(th);
@


1.1.1.2.2.26
log
@$: changed
@
text
@d6 1
a6 1
  $Date: 1998/03/23 09:48:00 $
a4373 1
    rb_define_method(mKernel, "__send__", f_send, -1);
@


1.1.1.2.2.27
log
@heredoc etc.
@
text
@d6 1
a6 1
  $Date: 1998/03/24 06:21:54 $
d24 1
a24 1
char *strrchr _((char*,char));
d550 7
a556 3
static VALUE rb_eval _((VALUE,NODE*));
static VALUE eval _((VALUE,VALUE,VALUE,char*,int));
static NODE *compile _((VALUE,char*));
d558 1
a558 2
static VALUE rb_call _((VALUE,VALUE,ID,int,VALUE*,int));
static VALUE module_setup _((VALUE,NODE*));
d560 2
a561 2
static VALUE massign _((VALUE,NODE*,VALUE));
static void assign _((VALUE,NODE*,VALUE));
d946 1
a946 1
    v = eval(TopSelf, str_new2(str), Qnil, 0, 0);
d978 1
a978 1
	eval(TopSelf, cmd, Qnil, 0, 0);
d2142 1
a2142 1
			list->nd_head = compile(list->nd_head->nd_lit,0);
d3630 1
a3630 1
compile(src, place)
a3631 1
    char *place;
d3636 2
a3637 2
    if (place == 0) place = sourcefile;
    node = compile_string(place, RSTRING(src)->ptr, RSTRING(src)->len);
d3644 1
a3644 1
eval(self, src, scope, file, line)
a3645 2
    char *file;
    int line;
d3653 2
a3654 2
    char *filesave = sourcefile;
    int linesave = sourceline;
a3657 7
    if (file == 0) {
	file = sourcefile;
	line = sourceline;
    }
    else if (line > 0) {
	sourceline = line;
    }
d3695 1
a3695 1
	compile(src, file);
a3712 2
    sourcefile = filesave;
    sourceline = linesave;
d3717 4
a3720 1
	    if (strcmp(file, "(eval)") == 0) {
a3725 3
		else {
		    err = str_dup(errinfo);
		}
d3743 1
a3743 2
    VALUE src, scope, vfile, line;
    char *file = "(eval)";
d3745 1
a3745 5
    rb_scan_args(argc, argv, "13", &src, &scope, &vfile, &line);
    if (!NIL_P(vfile)) {
	Check_Type(vfile, T_STRING);
	file = RSTRING(vfile)->ptr;
    }
d3748 1
a3748 1
    return eval(self, src, scope, file, NUM2INT(line));
d3769 1
a3769 1
	val = eval(self, src, Qnil, 0, 0);
@


1.1.1.2.2.28
log
@String#dump
@
text
@d6 1
a6 1
  $Date: 1998/03/25 09:36:57 $
a4710 3
    if (NIL_P(block)) {
	return rb_eval(self, node->nd_iter);
    }
@


1.1.1.2.2.29
log
@1.1b9_05_pre1
@
text
@d6 1
a6 1
  $Date: 1998/03/26 09:07:26 $
d4787 1
a4787 2
bm_mark(data)
    struct METHOD *data;
@


1.1.1.2.2.30
log
@protected methods
@
text
@d6 1
a6 1
  $Date: 1998/03/26 09:09:37 $
d48 2
a49 6
#define SCOPE_PUBLIC    0
#define SCOPE_PRIVATE   FL_USER4
#define SCOPE_PROTECTED FL_USER5
#define SCOPE_MODFUNC   (FL_USER4|FL_USER4)
#define SCOPE_MASK      (FL_USER4|FL_USER4)
#define SCOPE_SET(x,f)  do {FL_UNSET(x,SCOPE_MASK);FL_SET(x,(f))} while(0)
d758 2
a759 1
    SCOPE_SET(top_scope, SCOPE_PRIVATE);
a764 1
	the_frame->self = TopSelf;
d2202 1
a2202 1
	    if (FL_TEST(the_scope, SCOPE_PRIVATE) || node->nd_mid == init) {
a2204 3
	    else if (FL_TEST(the_scope, SCOPE_PROTECTED)) {
		noex = NOEX_PROTECTED;
	    }
d2212 1
a2212 1
	    if (FL_TEST(the_scope,SCOPE_MODFUNC) == SCOPE_MODFUNC) {
d3026 2
a3027 4

#define CSTAT_PRIV  1
#define CSTAT_PROT  2
#define CSTAT_VCALL 4
d3062 1
a3062 1
	if (last_call_status & CSTAT_PRIV) {
a3064 3
	if (last_call_status & CSTAT_PROT) {
	    format = "protected method `%s' called for %s";
	}
d3458 2
a3459 6
    if ((noex & NOEX_PRIVATE) && scope == 0)
	return rb_undefined(recv, mid, argc, argv, CSTAT_PRIV);

    /* self must be kind of a specified form for private method */
    if ((noex & NOEX_PROTECTED) && !obj_is_kind_of(the_frame->self, klass))
	return rb_undefined(recv, mid, argc, argv, CSTAT_PROT);
d3805 1
a3805 1
    int mode;
d3808 4
a3811 1
    mode = FL_TEST(the_scope, SCOPE_MASK);
d3817 6
a3822 1
    SCOPE_SET(the_scope, mode);
d3899 2
a3900 1
    SCOPE_SET(the_scope, SCOPE_PRIVATE);
d4092 2
a4093 1
	SCOPE_SET(the_scope, SCOPE_PUBLIC);
a4101 15
mod_protected(argc, argv, module)
    int argc;
    VALUE *argv;
    VALUE module;
{
    if (argc == 0) {
	SCOPE_SET(the_scope, SCOPE_PROTECTED);
    }
    else {
	set_method_visibility(module, argc, argv, NOEX_PROTECTED);
    }
    return module;
}

static VALUE
d4108 2
a4109 1
	SCOPE_SET(the_scope, SCOPE_PRIVATE);
a4145 8
top_protected(argc, argv)
    int argc;
    VALUE *argv;
{
    return mod_protected(argc, argv, cObject);
}

static VALUE
d4164 2
a4165 1
	SCOPE_SET(the_scope, SCOPE_MODFUNC);
a4394 1
    rb_define_private_method(cModule, "protected", mod_protected, -1);
a4410 1
    rb_define_singleton_method(TopSelf, "protected", top_protected, -1);
@


1.1.1.2.2.31
log
@$:, remove top_protected
@
text
@d6 1
a6 1
  $Date: 1998/03/26 10:22:13 $
d4166 8
d4439 1
@


1.1.1.2.2.32
log
@1.1b9_05 bug fix
@
text
@d6 1
a6 1
  $Date: 1998/03/27 06:09:17 $
d51 2
a52 2
#define SCOPE_MODFUNC   (FL_USER4|FL_USER5)
#define SCOPE_MASK      (FL_USER4|FL_USER5)
a313 40
void
rb_attr(klass, id, read, write, ex)
    VALUE klass;
    ID id;
    int read, write, ex;
{
    char *name;
    char *buf;
    ID attr, attreq, attriv;
    int noex;

    if (!ex) noex = NOEX_PUBLIC;
    else {
	if (FL_TEST(the_scope, SCOPE_PRIVATE)) {
	    noex = NOEX_PRIVATE;
	    Warning("private attribute?");
	}
	else if (FL_TEST(the_scope, SCOPE_PROTECTED)) {
	    noex = NOEX_PROTECTED;
	}
	else {
	    noex = NOEX_PUBLIC;
	}
    }

    name = rb_id2name(id);
    attr = rb_intern(name);
    buf = ALLOCA_N(char,strlen(name)+2);
    sprintf(buf, "%s=", name);
    attreq = rb_intern(buf);
    sprintf(buf, "@@%s", name);
    attriv = rb_intern(buf);
    if (read) {
	rb_add_method(klass, attr, NEW_IVAR(attriv), noex);
    }
    if (write) {
	rb_add_method(klass, attreq, NEW_ATTRSET(attriv), noex);
    }
}

d636 1
a636 1
static void call_trace_func _((char*,char*,int,VALUE,ID));
d831 3
a833 3
static void thread_cleanup _((void));
static void thread_wait_other_threads _((void));
static VALUE thread_current _((void));
d838 1
a838 1
static void exec_end_proc _((void));
d1387 2
a1388 1
static int handle_rescue _((VALUE,NODE*));
d2578 1
a2578 1
static VALUE make_backtrace _((void));
d3838 2
a4305 27
VALUE f_instance_variables();

VALUE
f_local_variables()
{
    ID *tbl;
    int n, i;
    VALUE ary = ary_new();
    struct RVarmap *vars;

    tbl = the_scope->local_tbl;
    if (tbl) {
	n = *tbl++;
	for (i=2; i<n; i++) {	/* skip first 2 ($_ and $~) */
	    ary_push(ary, str_new2(rb_id2name(tbl[i])));
	}
    }

    vars = the_dyna_vars;
    while (vars) {
	ary_push(ary, str_new2(rb_id2name(vars->id)));
	vars = vars->next;
    }

    return ary;
}

a4404 1
    rb_define_global_function("local_variables", f_local_variables, 0);
@


1.1.1.2.2.33
log
@instance_eva/module_eval
@
text
@d6 1
a6 1
  $Date: 1998/03/28 10:57:40 $
d362 1
d3821 2
a3822 4
exec_under(func, under, args)
    VALUE (*func)();
    VALUE under;
    void *args;
d3831 4
a3834 4
    the_frame->last_func = _frame.prev->last_func;
    the_frame->last_class = _frame.prev->last_class;
    the_frame->argc = _frame.prev->argc;
    the_frame->argv = _frame.prev->argv;
d3838 1
a3838 1
	val = (*func)(args);
d3849 2
a3850 36
eval_under_i(args)
    VALUE *args;
{
    return eval(args[0], args[1], Qnil, 0, 0);
}

static VALUE
eval_under(under, self, src)
    VALUE under, self, src;
{
    VALUE args[2];

    args[0] = self;
    args[1] = src;
    return exec_under(eval_under_i, under, args);
}

static VALUE
yield_under_i(self)
    VALUE self;
{
    return rb_yield_0(self, self);
}

static VALUE
yield_under(under, self)
    VALUE under, self;
{
    return exec_under(yield_under_i, under, self);
}

static VALUE
obj_instance_eval(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
d3852 1
a3852 18
    VALUE src;

    if (argc == 0) {
	if (!iterator_p()) {
	    ArgError("block not supplied");
	}
	return yield_under(CLASS_OF(self), self);
    }
    if (argc == 1) {
	Check_SafeStr(argv[0]);
    }
    else {
	ArgError("Wrong # of arguments: %s(src) or %s{..}",
		 rb_id2name(the_frame->last_func),
		 rb_id2name(the_frame->last_func));
    }

    return eval_under(CLASS_OF(self), self, argv[0]);
d3856 2
a3857 4
mod_module_eval(argc, argv, mod)
    int argc;
    VALUE *argv;
    VALUE mod;
a3862 14
    if (argc == 0) {
	if (!iterator_p()) {
	    ArgError("block not supplied");
	}
    }
    else if (argc == 1) {
	Check_SafeStr(argv[0]);
    }
    else {
	ArgError("Wrong # of arguments: %s(src) or %s{..}",
		 rb_id2name(the_frame->last_func),
		 rb_id2name(the_frame->last_func));
    }

d3864 1
a3864 2
    SCOPE_SET(the_scope, SCOPE_PUBLIC);
    PUSH_TAG(PROT_NONE);
d3866 1
a3866 6
	if (argc == 0) {
	    result = yield_under(mod, mod);
	}
	else {
	    result = eval_under(mod, mod, argv[0]);
	}
d3871 1
d4473 1
a4473 1
    rb_define_method(mKernel, "instance_eval", obj_instance_eval, -1);
d4485 1
a4485 2
    rb_define_method(cModule, "module_eval", mod_module_eval, -1);
    rb_define_method(cModule, "class_eval", mod_module_eval, -1);
d6223 1
a6223 1
    else if (state == TAG_THROW && t == prot_tag->dst) {
d6248 1
d6260 1
a6263 1
    return_value(value);
@


1.1.1.2.2.34
log
@eval(..,file,line);String#center
@
text
@d6 1
a6 1
  $Date: 1998/03/30 09:41:13 $
d3716 2
a3717 5
    else {
	sourcefile = file;
	if (line > 0) {
	    sourceline = line;
	}
@


1.1.1.2.2.35
log
@call initialize
@
text
@d6 1
a6 1
  $Date: 1998/03/31 04:52:08 $
a4346 9
void
obj_call_init(obj)
    VALUE obj;
{
    PUSH_ITER(iterator_p()?ITER_PRE:ITER_NOT);
    rb_funcall2(obj, init, the_frame->argc, the_frame->argv);
    POP_ITER();
}

d4359 3
a4361 2
    obj_call_init(obj);

a4669 24

static VALUE
bind_clone(self)
    VALUE self;
{
    struct BLOCK *orig, *data;
    VALUE bind;

    Data_Get_Struct(self, struct BLOCK, orig);
    bind = Data_Make_Struct(self, struct BLOCK, blk_mark,blk_free,data);
    MEMCPY(data, orig, struct BLOCK, 1);
    data->frame.argv = ALLOC_N(VALUE, orig->frame.argc);
    MEMCPY(data->frame.argv, orig->frame.argv, VALUE, orig->frame.argc);

    if (data->iter) {
	blk_copy_prev(data);
    }
    else {
	data->prev = 0;
    }

    return bind;
}

a5078 2
    rb_undef_method(CLASS_OF(cMethod), "new");
    rb_define_method(cBinding, "clone", bind_clone, 0);
@


1.1.1.2.2.36
log
@dynamic (nested) local variables
@
text
@d6 1
a6 1
  $Date: 1998/04/02 10:03:48 $
a47 1
static int scope_vmode;
d49 5
a53 6
#define SCOPE_PRIVATE   1
#define SCOPE_PROTECTED 2
#define SCOPE_MODFUNC   5
#define SCOPE_MASK      7
#define SCOPE_SET(f)  do {scope_vmode=(f);} while(0)
#define SCOPE_TEST(f) (scope_vmode&(f))
d327 1
a327 1
	if (SCOPE_TEST(SCOPE_PRIVATE)) {
d331 1
a331 1
	else if (SCOPE_TEST(SCOPE_PROTECTED)) {
a398 1
    int vmode;
a419 1
    _block.vmode = scope_vmode;		\
d434 1
a434 1
    struct RVarmap * volatile _old;	\
a441 24
static struct RVarmap*
new_dvar(id, value)
    ID id;
    VALUE value;
{
    NEWOBJ(vars, struct RVarmap);
    OBJSETUP(vars, 0, T_VARMAP);
    vars->id = id;
    vars->val = value;
    if (id == 0) {
	vars->next = the_dyna_vars;
    }
    else if (the_dyna_vars) {
	vars->next = the_dyna_vars->next;
	the_dyna_vars->next = vars;
    }
    else {			/* complie time dyna_var check */
	vars->next = the_dyna_vars;
	the_dyna_vars = vars;
    }

    return vars;
}

d484 8
a491 1
    new_dvar(id, value);
d571 1
a571 2
    int volatile _vmode = scope_vmode;	\
    struct SCOPE * volatile _old;	\
a578 1
    scope_vmode = SCOPE_PUBLIC;
d801 1
a801 1
    SCOPE_SET(SCOPE_PRIVATE);
d1358 1
a1359 2
      case NODE_DVAR:
	return "local-variable(nested)";
a1681 1
	    _block.d_vars = new_dvar(0,0);
d2244 1
a2244 1
	    if (SCOPE_TEST(SCOPE_PRIVATE) || node->nd_mid == init) {
d2247 1
a2247 1
	    else if (SCOPE_TEST(SCOPE_PROTECTED)) {
d2257 1
a2257 1
	    if (scope_vmode == SCOPE_MODFUNC) {
a2944 1
    _block.d_vars = new_dvar(0,0);
a3705 1
    int volatile old_vmode;
d3716 6
a3739 2
	old_vmode = scope_vmode;
	scope_vmode = data->vmode;
a3772 2
	data->vmode = scope_vmode; /* write back visibility mode */
	scope_vmode = old_vmode;
a3829 1
    int mode;
a3839 2
    mode = scope_vmode;
    SCOPE_SET(SCOPE_PUBLIC);
a3844 1
    SCOPE_SET(mode);
d3890 2
d3896 1
d3898 1
a3898 1
    else if (argc == 1) {
d3907 1
a3907 6
    if (argc == 0) {
	return yield_under(rb_singleton_class(self), self);
    }
    else {
	return eval_under(rb_singleton_class(self), self, argv[0]);
    }
d3916 4
d3934 10
a3943 5
    if (argc == 0) {
	return yield_under(mod, mod);
    }
    else {
	return eval_under(mod, mod, argv[0]);
d3945 4
d4020 1
a4020 1
    SCOPE_SET(SCOPE_PRIVATE);
d4212 1
a4212 1
	SCOPE_SET(SCOPE_PUBLIC);
d4227 1
a4227 1
	SCOPE_SET(SCOPE_PROTECTED);
d4242 1
a4242 1
	SCOPE_SET(SCOPE_PRIVATE);
d4297 1
a4297 1
	SCOPE_SET(SCOPE_MODFUNC);
d4717 1
a5179 1
    int vmode;
a5332 1
    th->vmode = scope_vmode;
a5389 1
    scope_vmode = th->vmode;
d6108 2
a6109 1
    return rb_yield(th->thread);
@


1.1.1.2.2.37
log
@1.1b9_07
@
text
@d6 1
a6 1
  $Date: 1998/04/07 08:34:07 $
d5632 1
a5632 1
    if (next->status == THREAD_RUNNABLE && next == curr_thread) {
@


1.1.1.2.2.38
log
@local_variables/defined?(TOPLEVEL_CONST) in modules
@
text
@d6 1
a6 1
  $Date: 1998/04/07 08:41:23 $
d4465 1
a4465 3
	if (vars->id) {
	    ary_push(ary, str_new2(rb_id2name(vars->id)));
	}
@


1.1.1.2.2.39
log
@1.1b9_09 pre
@
text
@d6 1
a6 1
  $Date: 1998/04/08 08:12:35 $
d3834 1
a3834 1
    VALUE src, scope, vfile, vline;
a3835 1
    int line = 0;
d3837 1
a3837 1
    rb_scan_args(argc, argv, "13", &src, &scope, &vfile, &vline);
a3841 3
    if (!NIL_P(vline)) {
	line = NUM2INT(vline);
    }
d3844 1
a3844 1
    return eval(self, src, scope, file, line);
@


1.1.1.2.2.40
log
@signal to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/09 09:30:19 $
a5388 2
static VALUE th_cmd;
static int   th_sig;
a5444 4
	rb_trap_eval(th_cmd, th_sig);
	break;

      case 4:
a6246 20
void
thread_trap_eval(cmd, sig)
    VALUE cmd;
    int sig;
{
    thread_critical = 0;
    thread_ready(main_thread);
    if (curr_thread == main_thread) {
	rb_trap_eval(cmd, sig);
    }
    thread_save_context(curr_thread);
    if (setjmp(curr_thread->context)) {
	return;
    }
    th_cmd = cmd;
    th_sig = sig;
    curr_thread = main_thread;
    thread_restore_context(curr_thread, 3);
}

d6272 1
a6272 1
    thread_restore_context(curr_thread, 4);
@


1.1.1.2.2.41
log
@signal delivered to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/13 06:06:11 $
a371 1
static VALUE eSysStackError;
d407 1
a407 2
};
static struct BLOCK  *the_block;
d516 1
a516 1
struct iter {
d519 1
a519 2
};
static struct iter *the_iter;
d535 1
a535 1
struct tag {
d543 1
a543 2
};
static struct tag *prot_tag;
d678 3
a680 7
    if (str_tainted(x)) {
	if (safe_level > 0){
	    Raise(eSecurityError, "Insecure operation - %s",
		  rb_id2name(the_frame->last_func));
	}
	Warning("Insecure operation - %s",
		rb_id2name(the_frame->last_func));
d2405 1
a2405 1
		if (safe_level >= 3) {
a2414 1
		obj_call_init(klass);
d2433 1
a2433 1
		if (safe_level >= 3) {
a2440 1
		obj_call_init(module);
d3241 1
a3241 1
	Raise(eSysStackError, "stack level too deep");
a4740 3
    if (the_frame->prev) {
	data->frame.last_func = the_frame->prev->last_func;
    }
a4804 1
    obj_call_init(proc);
a5124 1
    eSysStackError = rb_define_class("SystemStackError", eException);
d5203 1
a5210 1
    int misc;			/* misc. states (vmode/trap_immediate) */
d5357 1
a5357 1
    th->misc = scope_vmode | (trap_immediate<<8);
d5417 1
a5417 2
    scope_vmode = th->misc&SCOPE_MASK;
    trap_immediate = th->misc>>8;
a5447 1
	errno = EINTR;
d6061 1
a6261 1
	return;
@


1.1.1.2.2.42
log
@flock,flatten,signal to main_thread
@
text
@d6 1
a6 1
  $Date: 1998/04/14 04:55:47 $
d730 1
a730 1
	VALUE mesg = RARRAY(errat)->ptr[0];
d732 9
d2684 1
a2684 7
#if 1
    if (debug) {
	fprintf(stderr, "Exception `%s' occurred at %s:%d\n",
		rb_class2name(CLASS_OF(errinfo)),
		sourcefile, sourceline);
    }
#endif
a2700 5
#if 0
    if (debug) {
	error_print();
    }
#endif
d5543 1
a5543 1
    FOREACH_THREAD_FROM(curr, th) {
d5549 1
a5549 1
    END_FOREACH_FROM(curr, th); 
d5552 2
a5553 2
	FOREACH_THREAD_FROM(curr, th) {
	    if ((th->wait_for&WAIT_JOIN) && thread_dead(th->join)) {
d5561 1
a5561 1
	END_FOREACH_FROM(curr, th);
d5575 1
a5575 1
		FOREACH_THREAD_FROM(curr, th) {
d5581 1
a5581 1
		END_FOREACH_FROM(curr, th);
d5587 1
a5587 1
		FOREACH_THREAD_FROM(curr, th) {
d5600 1
a5600 1
		END_FOREACH_FROM(curr, th);
d5629 1
a5629 1
		    FOREACH_THREAD_FROM(curr, th) {
d5641 1
a5641 1
		    END_FOREACH_FROM(curr, th);
d5652 1
a5652 1
	FOREACH_THREAD_FROM(curr, th) {
d5657 1
a5657 1
	END_FOREACH_FROM(curr, th);
d6275 2
a6276 2
    if (!thread_dead(curr_thread)) {
	thread_ready(curr_thread);
a6279 1
    thread_ready(main_thread);
@


1.1.1.2.2.43
log
@exception name on -d
@
text
@d6 1
a6 1
  $Date: 1998/04/16 07:42:42 $
d2675 3
a2677 3

    if (debug && !NIL_P(errinfo)) {
	fprintf(stderr, "Exception `%s' at %s:%d\n",
d2681 1
d2698 5
a2704 4
    if (trace_func && tag != TAG_FATAL) {
	call_trace_func("raise", sourcefile, sourceline,
			the_frame->self, the_frame->last_func);
    }
@


1.1.1.2.2.44
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/04/16 10:20:17 $
d3523 1
a3523 1
    NODE  *body;		/* OK */
@


1.1.1.2.2.45
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/04/16 10:39:20 $
a3984 12
static int
is_absolute_path(path)
    char *path;
{
    if (path[0] == '/') return 1;
#if defined(MSDOS) || defined(NT) || defined(__human68k__)
    if (path[0] == '\\') return 1;
    if (strlen(path) > 2 && path[1] == ':') return 1;
#endif
    return 0;
}

d3993 5
a3997 7
    if (is_absolute_path(file)) {
	FILE *f = fopen(file, "r");

	if (f == NULL) return 0;
	fclose(f);
	return file;
    }
d4606 3
a4608 3
    rb_define_private_method(cModule, "remove_method", mod_remove_method, 1);
    rb_define_private_method(cModule, "undef_method", mod_undef_method, 1);
    rb_define_private_method(cModule, "alias_method", mod_alias_method, 2);
@


1.1.1.2.2.46
log
@gtk/nested local variables
@
text
@d6 1
a6 1
  $Date: 1998/04/20 05:55:35 $
d455 1
a457 1
	vars->id = (ID)value;
a458 1
	the_dyna_vars = vars;
a460 1
	vars->id = id;
d464 4
d1705 1
d2807 1
a2807 2
    the_dyna_vars = new_dvar(0, 0);
    the_dyna_vars->next = block->d_vars;
@


1.1.1.2.2.47
log
@tcltklib/gtk
@
text
@d6 1
a6 1
  $Date: 1998/04/24 09:33:14 $
d455 1
a457 1
	vars->val = 0;
a462 1
	vars->val = value;
d1725 1
a1725 1
	    else if (_block.tag->dst == state) {
@


1.1.1.2.2.48
log
@1.1b9_16 pre
@
text
@d6 1
a6 1
  $Date: 1998/04/27 10:03:50 $
d1381 1
a1381 1
	return "local-variable(ephemeral)";
a1452 20
obj_is_block(block)
    VALUE block;
{
    if (TYPE(block) == T_DATA && RDATA(block)->dfree == blk_free) {
	return TRUE;
    }
    return FALSE;
}

static VALUE
obj_is_proc(proc)
    VALUE proc;
{
    if (obj_is_block(proc) && obj_is_kind_of(proc, cProc)) {
	return TRUE;
    }
    return FALSE;
}

static VALUE
d1460 1
a1460 1
    if (!obj_is_proc(trace)) {
d3753 1
a3753 1
	if (!obj_is_block(scope)) {
d4734 1
a4734 1
    bind = Data_Make_Struct(self,struct BLOCK,blk_mark,blk_free,data);
d4757 1
a4757 1
    bind = Data_Make_Struct(cBinding,struct BLOCK,blk_mark,blk_free,data);
d4961 3
a4963 1
    else if (!obj_is_proc(block)) {
d5180 1
a5180 1
VALUE cThread;
@


1.1.1.2.2.49
log
@new exception model
@
text
@d6 1
a6 1
  $Date: 1998/04/28 06:16:08 $
d365 1
a365 2
extern VALUE eThrowable;
extern VALUE eExceptional;
a724 1
    VALUE einfo;
d738 1
a738 2
    einfo = obj_as_string(errinfo);
    if (eclass == eRuntimeError && RSTRING(einfo)->len == 0) {
d745 1
a745 1
	if (RSTRING(einfo)->len == 0) {
d751 2
a752 2
	    UCHAR *tail  = 0;
	    int len = RSTRING(einfo)->len;
d755 2
a756 2
	    if (tail = strchr(RSTRING(einfo)->ptr, '\n')) {
		len = tail - RSTRING(einfo)->ptr;
d760 1
a760 1
	    fwrite(RSTRING(einfo)->ptr, 1, len, stderr);
d767 1
a767 1
		fwrite(tail, 1, RSTRING(einfo)->len-len-1, stderr);
d985 1
a985 2
    char *mesg;
    int len;
d987 1
a987 1
    mesg = str2cstr(errinfo, &len);
d995 1
a995 1
    str_cat(errinfo, mesg, len);
d1381 1
a1381 1
	return "local-variable(in-block)";
d2707 1
a2707 1
	if (obj_is_kind_of(mesg, eThrowable)) {
d2713 1
a2713 3
	if (TYPE(errinfo) == T_STRING) {
	    str_freeze(errinfo);
	}
d2762 1
a2762 1
	if (obj_is_kind_of(etype, eThrowable)) {
d2773 3
a2775 6
	if (n >= 2 || !obj_is_kind_of(mesg, eThrowable)) {
	    mesg = rb_funcall(etype, rb_intern("new"), 1, mesg);
	}
	if (!obj_is_kind_of(mesg, eThrowable)) {
	    TypeError("should be Throwable, %s given",
		      rb_class2name(CLASS_OF(mesg)));
d3045 1
a3045 1
	return obj_is_kind_of(errinfo, eExceptional);
d3074 1
a3074 1
    else if (state == TAG_RAISE && obj_is_kind_of(errinfo, eExceptional)) {
d3841 1
a3841 1
		    str_concat(err, errinfo);
a4490 13
static void
errinfo_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    if (!obj_is_kind_of(val, eThrowable)) {
	TypeError("$! should be Throwable, %s given",
		  rb_class2name(CLASS_OF(val)));
    }
    *var = val;
}

d4598 1
a4598 1
    rb_define_hooked_variable("$!", &errinfo, 0, errinfo_setter);
@


1.1.1.2.2.50
log
@exception model changed
@
text
@d6 1
a6 1
  $Date: 1998/04/30 07:41:09 $
d365 2
a366 2
extern VALUE eDefaultRescue;
extern VALUE eStandardError;
a1808 1

d2711 9
a2719 1
	errinfo = mesg;
d2768 6
d2779 1
a2779 1
	if (n >= 2) {
d2782 3
a2784 2
	else if (TYPE(mesg) == T_STRING) {
	    mesg = exc_new3(eRuntimeError, mesg);
d3054 1
a3054 1
	return obj_is_kind_of(errinfo, eDefaultRescue);
d3083 1
a3083 1
    else if (state == TAG_RAISE && obj_is_kind_of(errinfo, eDefaultRescue)) {
d4500 13
d4620 1
a4620 1
    rb_define_variable("$!", &errinfo);
d5191 2
a5192 2
    eLocalJumpError = rb_define_class("LocalJumpError", eStandardError);
    eSysStackError = rb_define_class("SystemStackError", eStandardError);
d6405 1
a6405 1
    eThreadError = rb_define_class("ThreadError", eStandardError);
@


1.1.1.2.2.51
log
@new exception model
@
text
@d6 1
a6 1
  $Date: 1998/05/01 08:56:29 $
d357 1
a357 1
VALUE errinfo = Qnil;
d365 1
a455 3
    vars->id = id;
    vars->val = value;
    vars->next = the_dyna_vars;
d459 1
d463 2
d507 4
a510 7
    if (id) {
	while (vars) {
	    if (vars->id == id) {
		vars->val = value;
		return value;
	    }
	    vars = vars->next;
d512 1
a721 15
static VALUE
get_backtrace(info)
    VALUE info;
{
    if (NIL_P(info)) return Qnil;
    return rb_funcall(info, rb_intern("backtrace"), 0);
}

static void
set_backtrace(info, bt)
    VALUE info, bt;
{
    rb_funcall(info, rb_intern("set_backtrace"), 1, bt);
}

a724 1
    VALUE errat;
a729 1
    errat = get_backtrace(errinfo);
d912 1
a987 1
    VALUE str;
d993 1
a993 1
    str = str_new2("compile error");
d995 2
a996 2
	str_cat(str, " in ", 4);
	str_cat(str, at, strlen(at));
d998 3
a1000 3
    str_cat(str, "\n", 1);
    str_cat(str, mesg, len);
    rb_raise(exc_new3(eSyntaxError, str));
d1800 1
a1800 1
	    volatile VALUE e_info = errinfo;
d1820 1
d2667 3
a2669 4
static void
rb_longjmp(tag, mesg)
    int tag;
    VALUE mesg;
d2671 2
a2672 1
    VALUE at;
d2674 12
a2685 3
    if (NIL_P(mesg)) mesg = errinfo;
    if (NIL_P(mesg)) {
	mesg = exc_new(eRuntimeError, 0, 0);
d2687 2
d2690 7
a2696 7
    at = get_backtrace(mesg);
    if (NIL_P(at) && sourcefile && !NIL_P(mesg)) {
	at = make_backtrace();
	set_backtrace(mesg, at);
    }
    if (!NIL_P(mesg)) {
	errinfo = mesg;
d2704 10
d2727 1
a2727 1
    rb_longjmp(TAG_RAISE, mesg);
d2734 1
a2734 1
    rb_longjmp(TAG_FATAL, mesg);
d2758 1
a2759 1
      case 2:
a2771 4
	if (!obj_is_kind_of(mesg, eException)) {
	    TypeError("casting non-exception");
	}
	set_backtrace(mesg, arg3);
d2776 1
a2776 1
    rb_longjmp(TAG_RAISE, mesg);
d3040 1
a3040 1
	return obj_is_kind_of(errinfo, eStandardError);
a3062 1
    volatile VALUE e_info = errinfo;
d3069 1
a3069 1
    else if (state == TAG_RAISE && obj_is_kind_of(errinfo, eStandardError)) {
d3086 1
a3086 1
	    errinfo = e_info;
d3829 2
a3831 4
	    VALUE err;
	    VALUE errat;

	    errat = get_backtrace(errinfo);
d3844 1
a3844 1
	    rb_raise(errinfo);
a4064 1
    PUSH_VARS();
a4099 1
    POP_VARS();
d4475 1
a4475 18
static void
errinfo_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    if (!obj_is_kind_of(val, eException)) {
	TypeError("assigning non-exception to $!");
    }
    *var = val;
}

static VALUE
errat_getter(id)
    ID id;
{
    return get_backtrace(errinfo);
}
d4483 1
a4483 4
    if (NIL_P(errinfo)) {
	ArgError("$! not set");
    }
    set_backtrace(errinfo, val);
d4592 2
a4593 2
    rb_define_virtual_variable("$@@", errat_getter, errat_setter);
    rb_define_hooked_variable("$!", &errinfo, 0, errinfo_setter);
d5256 1
a5256 1
    VALUE errinfo;
d5318 1
d5401 1
d5462 1
d6054 1
d6071 1
d6160 1
d6168 1
d6202 3
a6204 5
	VALUE oldbt = get_backtrace(th->errinfo);
	VALUE errat = make_backtrace();

	ary_unshift(errat, ary_entry(oldbt, 0));
	set_backtrace(th->errinfo, errat);
@


1.1.1.2.2.52
log
@1.1b9_18
@
text
@d6 1
a6 1
  $Date: 1998/05/06 03:08:51 $
d289 2
a290 2
int
rb_method_boundp(klass, id, ex)
d305 11
d1336 2
a1337 2
	else if (rb_method_boundp(RCLASS(the_frame->last_class)->super,
				  the_frame->last_func, 1)) {
d1362 1
a1362 1
	if (rb_method_boundp(val, node->nd_mid, nd_type(node)== NODE_CALL)) {
@


1.1.1.2.2.53
log
@no INT,UINT
@
text
@d6 1
a6 1
  $Date: 1998/05/12 08:38:37 $
d761 1
a761 1
	    char *tail  = 0;
d2794 1
a2794 1
    static unsigned serial = 1;
@


1.1.1.2.2.54
log
@1.1b9_19
@
text
@d6 1
a6 1
  $Date: 1998/05/13 05:57:53 $
a30 10
#ifdef __BEOS__
#include <net/socket.h>
#endif

#ifdef USE_CWGUSI
#include <sys/stat.h>
#include <sys/errno.h>
#include <compat.h>
#endif

a37 6
#if defined(MSDOS) || defined(NT) || defined(__human68k__) || defined(__MACOS__)
#define RUBY_LIB_SEP ";"
#else
#define RUBY_LIB_SEP ":"
#endif

d803 1
a803 1
#if !defined(NT) && !defined(__MACOS__)
a823 3
#ifdef __MACOS__
    origenviron = 0;
#else
a824 1
#endif
d2667 4
d3088 1
a3088 1
    VALUE (*e_proc)();
a3591 4
#ifdef __STDC__
#include <stdarg.h>
#define va_init_list(a,b) va_start(a,b)
#else
a3592 2
#define va_init_list(a,b) va_start(a)
#endif
a3594 3
#ifdef __STDC__
rb_funcall(VALUE recv, ID mid, int n, ...)
#else
a3599 1
#endif
d3609 1
a3609 1
	va_init_list(ar, n);
d3996 1
a3996 1
# if defined(MSDOS) || defined(NT) || defined(__human68k__)
d3999 1
a3999 1
# endif
d4026 5
a4030 1
	vpath = ary_join(rb_load_path, str_new2(RUBY_LIB_SEP));
a4050 1
#ifndef __MACOS__
a4053 1
#endif
a6500 1

@


1.1.1.2.2.55
log
@prototypes
@
text
@d6 1
a6 1
  $Date: 1998/05/13 07:26:11 $
a2686 1
static void rb_longjmp _((int, VALUE)) NORETURN;
d3617 1
a3617 1
#ifdef HAVE_STDARG_PROTOTYPES
@


1.1.1.2.2.56
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/14 04:10:28 $
d4155 2
a4156 2
static int thread_loading _((char*));
static void thread_loading_done _((void));
d5410 5
d5450 1
a5450 1
static void thread_restore_context _((thread_t,int));
d5814 1
a5814 1
void thread_sleep_forever _((void));
@


1.1.1.2.2.57
log
@1.1b9_21
@
text
@d6 1
a6 1
  $Date: 1998/05/18 04:55:59 $
d511 7
a517 4
    while (vars) {
	if (vars->id == id) {
	    vars->val = value;
	    return value;
a518 1
	vars = vars->next;
d4076 1
a4076 1
	fname = file_s_expand_path(1, &fname);
@


1.1.1.2.2.58
log
@1.1b9_22
@
text
@d6 1
a6 1
  $Date: 1998/05/18 05:57:38 $
d463 6
a468 1
    if (the_dyna_vars) {
a471 5
    else {
	vars->id = id;
	vars->val = 0;
	the_dyna_vars = vars;
    }
d2255 1
a2255 1
			    compile_error("string expansion");
a3820 2
	sourcefile = file;
	sourceline = line;
d3930 1
a3930 1
    return eval(args[0], args[1], Qnil, (char*)args[2], (int)args[3]);
d3934 1
a3934 1
eval_under(under, self, src, file, line)
a3935 2
    char *file;
    int line;
d3937 1
a3937 1
    VALUE args[4];
a3940 2
    args[2] = (VALUE)file;
    args[3] = (VALUE)line;
a3963 3
    char *file = 0;
    int   line = 0;

d3969 1
a3969 1
    else if (argc < 4) {
a3970 2
	if (argc > 1) file = STR2CSTR(argv[1]);
	if (argc > 2) line = NUM2INT(argv[2]);
d3982 1
a3982 1
	return eval_under(rb_singleton_class(self), self, argv[0], file, line);
a3991 3
    char *file = 0;
    int   line = 0;

d3997 1
a3997 1
    else if (argc < 4) {
a3998 2
	if (argc > 1) file = STR2CSTR(argv[1]);
	if (argc > 2) line = NUM2INT(argv[2]);
d4010 1
a4010 1
	return eval_under(mod, mod, argv[0], file, line);
@


1.1.1.2.2.59
log
@remove unused variables
@
text
@d6 1
a6 1
  $Date: 1998/05/19 07:39:49 $
a621 1
    scope_vmode = _vmode;\
d5113 1
a5113 1
    ID id;
d5116 1
@


1.1.1.2.2.60
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/05/25 04:57:33 $
d367 9
d378 1
@


1.1.1.2.2.61
log
@1.1b9_25
@
text
@d6 1
a6 1
  $Date: 1998/06/02 10:05:18 $
a452 11

    return vars;
}

static struct RVarmap*
push_dvar(id, value)
    ID id;
    VALUE value;
{
    struct RVarmap* vars = new_dvar(id, value);

d494 2
a495 2
static void
dvar_add_compiling(id)
d497 1
a501 1
	if (vars->id == 0) break;
d503 2
a504 1
	    return;
d508 1
a508 23
    the_dyna_vars = new_dvar(id, 0);
}

VALUE
dyna_var_asgn(id, value)
    ID id;
    VALUE value;
{
    if (id == 0) {
	dvar_add_compiling((ID)value);
    }
    else {
	struct RVarmap *vars = the_dyna_vars;

	while (vars) {
	    if (vars->id == id) {
		vars->val = value;
		return value;
	    }
	    vars = vars->next;
	}
	push_dvar(id, value);
    }
a6161 1
	posix_signal(SIGALRM, catch_timer);
a6163 1
	posix_signal(SIGALRM, catch_timer);
a6169 5

	tval.it_interval.tv_sec =  2; /* unblock system calls */
	tval.it_interval.tv_usec = 0;
	tval.it_value = tval.it_interval;
	setitimer(ITIMER_REAL, &tval, NULL);
@


1.1.1.2.2.62
log
@nested local variables
@
text
@d6 1
a6 1
  $Date: 1998/06/11 10:02:57 $
d457 1
a457 1
static void
d462 1
a462 2
    the_dyna_vars = new_dvar(id, value);
}
d464 2
a465 6
static void
mark_dvar(vars)
    struct RVarmap* vars;
{
    if (!vars) {
	the_dyna_vars = new_dvar(0, 0);
d469 2
d473 2
d505 2
a506 2
VALUE
dyna_var_asgn(id, value)
a507 1
    VALUE value;
d512 1
d514 1
a514 2
	    vars->val = value;
	    return value;
d518 23
a540 1
    push_dvar(id, value);
d2847 2
a2848 1
    mark_dvar(block->d_vars);
d3021 1
d3822 1
a3822 1
	mark_dvar(data->d_vars);
a3858 1
	data->d_vars = the_dyna_vars;
@


1.1.1.2.2.63
log
@baseline
@
text
@d6 1
a6 1
  $Date: 1998/06/12 09:35:00 $
d16 1
a16 1
#include "rubysig.h"
d363 1
a363 1
extern NODE *eval_tree_begin;
d886 1
d904 3
a906 3
    if (eval_tree_begin) {
	tree = eval_tree_begin;
	eval_tree_begin = 0;
d2254 1
a2255 1
			eval_tree = 0;
d3821 1
d4643 1
a4643 2
    rb_global_variable((VALUE*)&eval_tree_begin);

d6176 1
a6176 1
	signal(SIGALRM, catch_timer);
@


1.1.1.2.2.64
log
@1.1b9_26
@
text
@d6 1
a6 1
  $Date: 1998/06/16 04:23:26 $
d1044 1
a1044 1
VALUE
a1048 1
    VALUE val;
d1054 3
a1056 2
	return rb_funcall2(cmd, rb_intern("call"),
			   RARRAY(arg)->len, RARRAY(arg)->ptr);
d1070 1
a1070 1
	val = eval(TopSelf, cmd, Qnil, 0, 0);
a1099 1
    return val;
d1102 1
a1102 1
VALUE
a1107 1
    VALUE val;			/* OK */
d1111 1
a1111 1
	val = rb_eval_cmd(cmd, ary_new3(1, INT2FIX(sig)));
a1117 1
    return val;
d1125 1
a1125 1
    VALUE val;			/* OK */
d1133 1
a1133 1
    if (state) {
d1354 1
a1355 1
      case NODE_FCALL:
a1403 1
      case NODE_DASGN_PUSH:
a2077 13
      case NODE_DASGN_PUSH:
	result = rb_eval(self, node->nd_value);
	if (the_dyna_vars && the_dyna_vars->id == 0) {
	    struct RVarmap* vars = new_dvar(node->nd_vid, result);

	    vars->next = the_dyna_vars->next;
	    the_dyna_vars->next = vars;
	}
	else {
	    push_dvar(node->nd_vid, result);
	}
	break;

a2956 4
      case NODE_DASGN_PUSH:
	push_dvar(lhs->nd_vid, val);
	break;

d3607 1
a3607 1
#ifdef HAVE_STDARG_PROTOTYPES
a4845 4
    if (data->d_vars && data->d_vars->id) {
	push_dvar(0, 0);
	data->d_vars = the_dyna_vars;
    }
a4898 4
    }
    if (data->d_vars && data->d_vars->id) {
	push_dvar(0, 0);
	data->d_vars = the_dyna_vars;
@


1.1.1.2.2.65
log
@1.1b9_27
@
text
@d6 1
a6 1
  $Date: 1998/06/18 07:46:44 $
d458 8
d467 1
a467 1
    struct RVarmap *vars;
d469 7
a475 2
    the_dyna_vars = new_dvar(0, 0);
    the_dyna_vars->next = vars;
a505 8
void
dyna_var_push(id, value)
    ID id;
    VALUE value;
{
    the_dyna_vars = new_dvar(id, value);
}

d520 1
a520 1
    dyna_var_push(id, value);
a523 16
static void
dvar_asgn_push(id, value)
    ID id;
    VALUE value;
{
    if (the_dyna_vars && the_dyna_vars->id == 0) {
	struct RVarmap* vars = new_dvar(id, value);

	vars->next = the_dyna_vars->next;
	the_dyna_vars->next = vars;
    }
    else {
	dyna_var_push(id, value);
    }
}

d2084 9
a2092 1
	dvar_asgn_push(node->nd_vid, result);
d2975 1
a2975 1
	dvar_asgn_push(lhs->nd_vid, val);
a2981 4
      case NODE_MASGN:
	massign(self, lhs, val);
	break;

d3820 1
a3820 1
	the_dyna_vars = data->d_vars;
d4867 4
d4924 4
@


1.1.1.2.2.66
log
@thread->thred
@
text
@d6 1
a6 1
  $Date: 1998/06/19 09:32:02 $
d932 3
a934 3
static void thred_cleanup _((void));
static void thred_wait_other_threads _((void));
static VALUE thred_current _((void));
d966 2
a967 2
	thred_cleanup();
	thred_wait_other_threads();
d1549 1
a1549 1
    thred_critical++;
d1571 1
a1571 1
    thred_critical--;
d4197 2
a4198 2
static int thred_loading _((char*));
static void thred_loading_done _((void));
d4273 1
a4273 1
    if (thred_loading(feature)) return FALSE;
d4286 1
a4286 1
	thred_loading_done();
d4294 1
a4294 1
    if (thred_loading(feature)) return FALSE;
d4305 1
a4305 1
	thred_loading_done();
d4858 1
a4858 1
    data->orig_thread = thred_current();
d4901 1
a4901 1
    data->orig_thread = thred_current();
d4948 1
a4948 1
    if (data->orig_thread != thred_current()) {
d5272 1
a5272 1
int thred_pending = 0;
d5381 1
a5381 1
thred_mark(th)
d5428 1
a5428 1
	thred_mark(th);
d5433 1
a5433 1
thred_free(th)
d5442 1
a5442 1
thred_check(data)
d5445 1
a5445 1
    if (TYPE(data) != T_DATA || RDATA(data)->dfree != thred_free) {
d5453 1
a5453 1
thred_save_context(th)
d5487 1
a5487 1
static void thred_restore_context _((thread_t,int));
d5497 1
a5497 1
    thred_restore_context(th, exit);
d5508 1
a5508 1
thred_restore_context(th, exit)
d5579 1
a5579 1
thred_ready(th)
d5597 1
a5597 1
thred_remove()
d5599 1
a5599 1
    thred_ready(curr_thread);
d5603 1
a5603 1
    thred_schedule();
d5607 1
a5607 1
thred_dead(th)
d5614 1
a5614 1
thred_deadlock()
d5625 1
a5625 1
thred_schedule()
d5632 1
a5632 1
    thred_pending = 0;
d5652 1
a5652 1
	    if ((th->wait_for&WAIT_JOIN) && thred_dead(th->join)) {
d5758 1
a5758 1
	thred_deadlock();
d5766 1
a5766 1
	thred_save_context(curr);
d5775 1
a5775 1
	thred_restore_context(next, 1);
d5777 1
a5777 1
    thred_restore_context(next, 0);
d5781 1
a5781 1
thred_wait_fd(fd)
d5790 1
a5790 1
    thred_schedule();
d5794 1
a5794 1
thred_fd_writable(fd)
d5807 1
a5807 1
	thred_schedule();
d5812 1
a5812 1
thred_wait_for(time)
d5848 1
a5848 1
    thred_schedule();
d5851 1
a5851 1
void thred_sleep_forever _((void));
d5854 1
a5854 1
thred_alone()
d5860 1
a5860 1
thred_select(max, read, write, except, timeout)
d5872 1
a5872 1
	    thred_sleep_forever();
d5875 1
a5875 1
	thred_wait_for(*timeout);
d5942 1
a5942 1
        thred_schedule();
d5948 1
a5948 1
thred_join(dmy, thread)
d5952 1
a5952 1
    thread_t th = thred_check(thread);
d5954 1
a5954 1
    if (thred_dead(th)) return thread;
d5961 1
a5961 1
    thred_schedule();
d5967 1
a5967 1
thred_current()
d5973 1
a5973 1
thred_main()
d5979 1
a5979 1
thred_wakeup(thread)
d5982 1
a5982 1
    thread_t th = thred_check(thread);
d5985 1
a5985 1
    thred_ready(th);
d5991 1
a5991 1
thred_run(thread)
d5994 2
a5995 2
    thred_wakeup(thread);
    if (!thred_critical) thred_schedule();
d6001 1
a6001 1
thred_kill(thread)
d6004 1
a6004 1
    thread_t th = thred_check(thread);
d6010 1
a6010 1
    thred_ready(th);
d6012 1
a6012 1
    thred_schedule();
d6017 1
a6017 1
thred_s_kill(obj, th)
d6020 1
a6020 1
    return thred_kill(th);
d6024 1
a6024 1
thred_exit()
d6026 1
a6026 1
    return thred_kill(curr_thread->thread);
d6030 1
a6030 1
thred_pass()
d6032 1
a6032 1
    thred_schedule();
d6037 1
a6037 1
thred_stop()
d6039 1
a6039 1
    thred_critical = 0;
d6044 1
a6044 1
    thred_schedule();
d6052 1
a6052 1
thred_sleep(sec)
d6061 1
a6061 1
    thred_wait_for(time_timeval(INT2FIX(sec)));
d6065 1
a6065 1
thred_sleep_forever()
d6078 1
a6078 1
    thred_schedule();
d6081 1
a6081 1
static int thred_abort;
d6084 1
a6084 1
thred_s_abort_exc()
d6086 1
a6086 1
    return thred_abort?TRUE:FALSE;
d6090 1
a6090 1
thred_s_abort_exc_set(self, val)
d6093 1
a6093 1
    thred_abort = RTEST(val);
d6098 1
a6098 1
thred_abort_exc(thread)
d6101 1
a6101 1
    thread_t th = thred_check(thread);
d6107 1
a6107 1
thred_abort_exc_set(thread, val)
d6110 1
a6110 1
    thread_t th = thred_check(thread);
d6117 1
a6117 1
thred_alloc()
d6149 1
a6149 1
    th->thread = data_object_alloc(cThread, th, 0, thred_free);
d6173 1
a6173 1
    if (!thred_critical) {
d6175 1
a6175 1
	    thred_schedule();
d6177 1
a6177 1
	else thred_pending = 1;
d6181 1
a6181 1
int thred_tick = THREAD_TICK;
d6185 1
a6185 1
thred_create(fn, arg)
d6189 1
a6189 1
    thread_t th = thred_alloc();
d6220 1
a6220 1
    thred_save_context(curr_thread);
d6227 1
a6227 1
	thred_save_context(th);
d6239 1
a6239 1
	    thred_cleanup();
d6241 1
a6241 1
	else if (thred_abort || curr_thread->abort || RTEST(debug)) {
d6248 1
a6248 1
    thred_remove();
d6253 1
a6253 1
thred_yield(arg, th) 
d6262 1
a6262 1
thred_start()
d6267 1
a6267 1
    return thred_create(thred_yield, 0);
d6271 1
a6271 1
thred_value(thread)
d6274 1
a6274 1
    thread_t th = thred_check(thread);
d6276 1
a6276 1
    thred_join(0, thread);
d6290 1
a6290 1
thred_status(thread)
d6293 1
a6293 1
    thread_t th = thred_check(thread);
d6295 1
a6295 1
    if (thred_dead(th)) {
d6304 1
a6304 1
thred_stop_p(thread)
d6307 1
a6307 1
    thread_t th = thred_check(thread);
d6309 1
a6309 1
    if (thred_dead(th)) return TRUE;
d6315 1
a6315 1
thred_wait_other_threads()
d6319 1
a6319 1
	thred_schedule();
d6324 1
a6324 1
thred_cleanup()
d6341 1
a6341 1
int thred_critical;
d6344 1
a6344 1
thred_get_critical()
d6346 1
a6346 1
    return thred_critical?TRUE:FALSE;
d6350 1
a6350 1
thred_set_critical(obj, val)
d6353 1
a6353 1
    thred_critical = RTEST(val);
d6358 1
a6358 1
thred_interrupt()
d6360 2
a6361 2
    thred_critical = 0;
    thred_ready(main_thread);
d6365 1
a6365 1
    thred_save_context(curr_thread);
d6370 1
a6370 1
    thred_restore_context(curr_thread, 2);
d6374 1
a6374 1
thred_trap_eval(cmd, sig)
d6378 3
a6380 3
    thred_critical = 0;
    if (!thred_dead(curr_thread)) {
	thred_ready(curr_thread);
d6384 2
a6385 2
    thred_ready(main_thread);
    thred_save_context(curr_thread);
d6392 1
a6392 1
    thred_restore_context(curr_thread, 3);
d6396 1
a6396 1
thred_raise(argc, argv, thread)
d6401 1
a6401 1
    thread_t th = thred_check(thread);
d6403 1
a6403 1
    if (thred_dead(th)) return thread;
d6408 1
a6408 1
    thred_save_context(curr_thread);
d6414 1
a6414 1
    thred_ready(th);
d6420 1
a6420 1
    thred_restore_context(curr_thread, 4);
d6428 1
a6428 1
thred_loading(feature)
d6433 1
a6433 1
	    thred_schedule();
d6446 1
a6446 1
thred_loading_done()
d6459 26
a6484 26
    rb_define_singleton_method(cThread, "new", thred_start, 0);
    rb_define_singleton_method(cThread, "start", thred_start, 0);
    rb_define_singleton_method(cThread, "fork", thred_start, 0);

    rb_define_singleton_method(cThread, "stop", thred_stop, 0);
    rb_define_singleton_method(cThread, "kill", thred_s_kill, 1);
    rb_define_singleton_method(cThread, "exit", thred_exit, 0);
    rb_define_singleton_method(cThread, "pass", thred_pass, 0);
    rb_define_singleton_method(cThread, "join", thred_join, 1);
    rb_define_singleton_method(cThread, "current", thred_current, 0);
    rb_define_singleton_method(cThread, "main", thred_main, 0);

    rb_define_singleton_method(cThread, "critical", thred_get_critical, 0);
    rb_define_singleton_method(cThread, "critical=", thred_set_critical, 1);

    rb_define_singleton_method(cThread, "abort_on_exception", thred_s_abort_exc, 0);
    rb_define_singleton_method(cThread, "abort_on_exception=", thred_s_abort_exc_set, 1);

    rb_define_method(cThread, "run", thred_run, 0);
    rb_define_method(cThread, "wakeup", thred_wakeup, 0);
    rb_define_method(cThread, "exit", thred_kill, 0);
    rb_define_method(cThread, "value", thred_value, 0);
    rb_define_method(cThread, "status", thred_status, 0);
    rb_define_method(cThread, "alive?", thred_status, 0);
    rb_define_method(cThread, "stop?", thred_stop_p, 0);
    rb_define_method(cThread, "raise", thred_raise, -1);
d6486 2
a6487 2
    rb_define_method(cThread, "abort_on_exception", thred_abort_exc, 0);
    rb_define_method(cThread, "abort_on_exception=", thred_abort_exc_set, 1);
d6490 1
a6490 1
    main_thread = thred_alloc();
@


1.1.1.2.2.67
log
@980626
@
text
@d6 1
a6 1
  $Date: 1998/06/24 04:37:53 $
d932 3
a934 3
static void thread_cleanup _((void));
static void thread_wait_other_threads _((void));
static VALUE thread_current _((void));
d966 2
a967 2
	thread_cleanup();
	thread_wait_other_threads();
d1549 1
a1549 1
    thread_critical++;
d1571 1
a1571 1
    thread_critical--;
d4175 1
d4180 2
a4181 2
    p = RARRAY(rb_features)->ptr;
    pend = p + RARRAY(rb_features)->len;
d4183 2
a4184 1
	f = STR2CSTR(*p);
d4197 2
a4198 2
static int thread_loading _((char*));
static void thread_loading_done _((void));
d4273 1
a4273 1
    if (thread_loading(feature)) return FALSE;
d4286 1
a4286 1
	thread_loading_done();
d4294 1
a4294 1
    if (thread_loading(feature)) return FALSE;
d4305 1
a4305 1
	thread_loading_done();
d4858 1
a4858 1
    data->orig_thread = thread_current();
d4901 1
a4901 1
    data->orig_thread = thread_current();
d4948 1
a4948 1
    if (data->orig_thread != thread_current()) {
d5272 1
a5272 1
int thread_pending = 0;
d5381 1
a5381 1
thread_mark(th)
d5428 1
a5428 1
	thread_mark(th);
d5433 1
a5433 1
thread_free(th)
d5442 1
a5442 1
thread_check(data)
d5445 1
a5445 1
    if (TYPE(data) != T_DATA || RDATA(data)->dfree != thread_free) {
d5453 1
a5453 1
thread_save_context(th)
d5487 1
a5487 1
static void thread_restore_context _((thread_t,int));
d5497 1
a5497 1
    thread_restore_context(th, exit);
d5508 1
a5508 1
thread_restore_context(th, exit)
d5579 1
a5579 1
thread_ready(th)
d5597 1
a5597 1
thread_remove()
d5599 1
a5599 1
    thread_ready(curr_thread);
d5603 1
a5603 1
    thread_schedule();
d5607 1
a5607 1
thread_dead(th)
d5614 1
a5614 1
thread_deadlock()
d5625 1
a5625 1
thread_schedule()
d5632 1
a5632 1
    thread_pending = 0;
d5652 1
a5652 1
	    if ((th->wait_for&WAIT_JOIN) && thread_dead(th->join)) {
d5758 1
a5758 1
	thread_deadlock();
d5766 1
a5766 1
	thread_save_context(curr);
d5775 1
a5775 1
	thread_restore_context(next, 1);
d5777 1
a5777 1
    thread_restore_context(next, 0);
d5781 1
a5781 1
thread_wait_fd(fd)
d5790 1
a5790 1
    thread_schedule();
d5794 1
a5794 1
thread_fd_writable(fd)
d5807 1
a5807 1
	thread_schedule();
d5812 1
a5812 1
thread_wait_for(time)
d5848 1
a5848 1
    thread_schedule();
d5851 1
a5851 1
void thread_sleep_forever _((void));
d5854 1
a5854 1
thread_alone()
d5860 1
a5860 1
thread_select(max, read, write, except, timeout)
d5872 1
a5872 1
	    thread_sleep_forever();
d5875 1
a5875 1
	thread_wait_for(*timeout);
d5942 1
a5942 1
        thread_schedule();
d5948 1
a5948 1
thread_join(dmy, thread)
d5952 1
a5952 1
    thread_t th = thread_check(thread);
d5954 1
a5954 1
    if (thread_dead(th)) return thread;
d5961 1
a5961 1
    thread_schedule();
d5967 1
a5967 1
thread_current()
d5973 1
a5973 1
thread_main()
d5979 1
a5979 1
thread_wakeup(thread)
d5982 1
a5982 1
    thread_t th = thread_check(thread);
d5985 1
a5985 1
    thread_ready(th);
d5991 1
a5991 1
thread_run(thread)
d5994 2
a5995 2
    thread_wakeup(thread);
    if (!thread_critical) thread_schedule();
d6001 1
a6001 1
thread_kill(thread)
d6004 1
a6004 1
    thread_t th = thread_check(thread);
d6010 1
a6010 1
    thread_ready(th);
d6012 1
a6012 1
    thread_schedule();
d6017 1
a6017 1
thread_s_kill(obj, th)
d6020 1
a6020 1
    return thread_kill(th);
d6024 1
a6024 1
thread_exit()
d6026 1
a6026 1
    return thread_kill(curr_thread->thread);
d6030 1
a6030 1
thread_pass()
d6032 1
a6032 1
    thread_schedule();
d6037 1
a6037 1
thread_stop()
d6039 1
a6039 1
    thread_critical = 0;
d6044 1
a6044 1
    thread_schedule();
d6052 1
a6052 1
thread_sleep(sec)
d6061 1
a6061 1
    thread_wait_for(time_timeval(INT2FIX(sec)));
d6065 1
a6065 1
thread_sleep_forever()
d6078 1
a6078 1
    thread_schedule();
d6081 1
a6081 1
static int thread_abort;
d6084 1
a6084 1
thread_s_abort_exc()
d6086 1
a6086 1
    return thread_abort?TRUE:FALSE;
d6090 1
a6090 1
thread_s_abort_exc_set(self, val)
d6093 1
a6093 1
    thread_abort = RTEST(val);
d6098 1
a6098 1
thread_abort_exc(thread)
d6101 1
a6101 1
    thread_t th = thread_check(thread);
d6107 1
a6107 1
thread_abort_exc_set(thread, val)
d6110 1
a6110 1
    thread_t th = thread_check(thread);
d6117 1
a6117 1
thread_alloc()
d6149 1
a6149 1
    th->thread = data_object_alloc(cThread, th, 0, thread_free);
d6173 1
a6173 1
    if (!thread_critical) {
d6175 1
a6175 1
	    thread_schedule();
d6177 1
a6177 1
	else thread_pending = 1;
d6181 1
a6181 1
int thread_tick = THREAD_TICK;
d6185 1
a6185 1
thread_create(fn, arg)
d6189 1
a6189 1
    thread_t th = thread_alloc();
d6220 1
a6220 1
    thread_save_context(curr_thread);
d6227 1
a6227 1
	thread_save_context(th);
d6239 1
a6239 1
	    thread_cleanup();
d6241 1
a6241 1
	else if (thread_abort || curr_thread->abort || RTEST(debug)) {
d6248 1
a6248 1
    thread_remove();
d6253 1
a6253 1
thread_yield(arg, th) 
d6262 1
a6262 1
thread_start()
d6267 1
a6267 1
    return thread_create(thread_yield, 0);
d6271 1
a6271 1
thread_value(thread)
d6274 1
a6274 1
    thread_t th = thread_check(thread);
d6276 1
a6276 1
    thread_join(0, thread);
d6290 1
a6290 1
thread_status(thread)
d6293 1
a6293 1
    thread_t th = thread_check(thread);
d6295 1
a6295 1
    if (thread_dead(th)) {
d6304 1
a6304 1
thread_stop_p(thread)
d6307 1
a6307 1
    thread_t th = thread_check(thread);
d6309 1
a6309 1
    if (thread_dead(th)) return TRUE;
d6315 1
a6315 1
thread_wait_other_threads()
d6319 1
a6319 1
	thread_schedule();
d6324 1
a6324 1
thread_cleanup()
d6341 1
a6341 1
int thread_critical;
d6344 1
a6344 1
thread_get_critical()
d6346 1
a6346 1
    return thread_critical?TRUE:FALSE;
d6350 1
a6350 1
thread_set_critical(obj, val)
d6353 1
a6353 1
    thread_critical = RTEST(val);
d6358 1
a6358 1
thread_interrupt()
d6360 2
a6361 2
    thread_critical = 0;
    thread_ready(main_thread);
d6365 1
a6365 1
    thread_save_context(curr_thread);
d6370 1
a6370 1
    thread_restore_context(curr_thread, 2);
d6374 1
a6374 1
thread_trap_eval(cmd, sig)
d6378 3
a6380 3
    thread_critical = 0;
    if (!thread_dead(curr_thread)) {
	thread_ready(curr_thread);
d6384 2
a6385 2
    thread_ready(main_thread);
    thread_save_context(curr_thread);
d6392 1
a6392 1
    thread_restore_context(curr_thread, 3);
d6396 1
a6396 1
thread_raise(argc, argv, thread)
d6401 1
a6401 1
    thread_t th = thread_check(thread);
d6403 1
a6403 1
    if (thread_dead(th)) return thread;
d6408 1
a6408 1
    thread_save_context(curr_thread);
d6414 1
a6414 1
    thread_ready(th);
d6420 1
a6420 1
    thread_restore_context(curr_thread, 4);
d6428 1
a6428 1
thread_loading(feature)
d6433 1
a6433 1
	    thread_schedule();
d6446 1
a6446 1
thread_loading_done()
d6459 26
a6484 26
    rb_define_singleton_method(cThread, "new", thread_start, 0);
    rb_define_singleton_method(cThread, "start", thread_start, 0);
    rb_define_singleton_method(cThread, "fork", thread_start, 0);

    rb_define_singleton_method(cThread, "stop", thread_stop, 0);
    rb_define_singleton_method(cThread, "kill", thread_s_kill, 1);
    rb_define_singleton_method(cThread, "exit", thread_exit, 0);
    rb_define_singleton_method(cThread, "pass", thread_pass, 0);
    rb_define_singleton_method(cThread, "join", thread_join, 1);
    rb_define_singleton_method(cThread, "current", thread_current, 0);
    rb_define_singleton_method(cThread, "main", thread_main, 0);

    rb_define_singleton_method(cThread, "critical", thread_get_critical, 0);
    rb_define_singleton_method(cThread, "critical=", thread_set_critical, 1);

    rb_define_singleton_method(cThread, "abort_on_exception", thread_s_abort_exc, 0);
    rb_define_singleton_method(cThread, "abort_on_exception=", thread_s_abort_exc_set, 1);

    rb_define_method(cThread, "run", thread_run, 0);
    rb_define_method(cThread, "wakeup", thread_wakeup, 0);
    rb_define_method(cThread, "exit", thread_kill, 0);
    rb_define_method(cThread, "value", thread_value, 0);
    rb_define_method(cThread, "status", thread_status, 0);
    rb_define_method(cThread, "alive?", thread_status, 0);
    rb_define_method(cThread, "stop?", thread_stop_p, 0);
    rb_define_method(cThread, "raise", thread_raise, -1);
d6486 2
a6487 2
    rb_define_method(cThread, "abort_on_exception", thread_abort_exc, 0);
    rb_define_method(cThread, "abort_on_exception=", thread_abort_exc_set, 1);
d6490 1
a6490 1
    main_thread = thread_alloc();
@


1.1.1.2.2.68
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/06/26 09:44:15 $
d404 1
a404 1
static struct BLOCK *the_block;
a1314 12
#define BEGIN_CALLARGS {\
    struct BLOCK *tmp_block = the_block;\
    if (the_iter->iter == ITER_PRE) {\
	the_block = the_block->prev;\
    }\
    PUSH_ITER(ITER_NOT);

#define END_CALLARGS \
    the_block = tmp_block;\
    POP_ITER();\
}

d1964 1
a1964 1
	    BEGIN_CALLARGS;
d1967 1
a1967 2
	    END_CALLARGS;

d1977 1
a1977 1
	    BEGIN_CALLARGS;
d1979 1
a1979 2
	    END_CALLARGS;

d2003 1
a2003 1
		BEGIN_CALLARGS;
d2005 1
a2005 1
		END_CALLARGS;
d3075 1
a3075 1
    BEGIN_CALLARGS;
d3077 1
a3077 2
    END_CALLARGS;

@


1.1.1.2.2.69
log
@1.1b9_29
@
text
@d6 1
a6 1
  $Date: 1998/06/30 01:40:42 $
d984 1
a984 1
	fprintf(stderr, ": unexpected return\n");
d989 1
a989 1
	fprintf(stderr, ": unexpected next\n");
d994 1
a994 1
	fprintf(stderr, ": unexpected break\n");
d999 1
a999 1
	fprintf(stderr, ": unexpected redo\n");
d1004 1
a1004 1
	fprintf(stderr, ": retry outside of rescue clause\n");
a2342 3
	    if (the_class == cObject && node->nd_mid == init) {
		Warn("re-defining Object#initialize may cause infinite loop");
	    }
d2847 1
a2847 1
    if (!iterator_p() || !the_block) {
d6223 1
a6223 1
#if 1
d6228 1
a6228 1
#endif
@


1.1.1.2.2.70
log
@1.1b9_30
@
text
@d6 1
a6 1
  $Date: 1998/07/03 07:06:24 $
d2069 1
a2069 11
	    if (node->nd_mid == 0) {      /* OR */
		if (RTEST(val)) break;
		val = rb_eval(self, rval);
	    }
	    else if (node->nd_mid == 1) { /* AND */
		if (!RTEST(val)) break;
		val = rb_eval(self, rval);
	    }
	    else {
		val = rb_funcall(val, node->nd_mid, 1, rb_eval(self, rval));
	    }
a2082 12
	    if (node->nd_next->nd_mid == 0) {      /* OR */
		if (RTEST(val)) break;
		val = rb_eval(self, node->nd_value);
	    }
	    else if (node->nd_next->nd_mid == 1) { /* AND */
		if (!RTEST(val)) break;
		val = rb_eval(self, node->nd_value);
	    }
	    else {
		val = rb_funcall(val, node->nd_next->nd_mid, 1,
				 rb_eval(self, node->nd_value));
	    }
d2084 4
a2087 1
	    rb_funcall2(recv, node->nd_next->nd_aid, 1, &val);
a2091 14
      case NODE_OP_ASGN_AND:
	result = rb_eval(self, node->nd_head);
	if (RTEST(result)) {
	    result = rb_eval(self, node->nd_value);
	}
	break;

      case NODE_OP_ASGN_OR:
	result = rb_eval(self, node->nd_head);
	if (!RTEST(result)) {
	    result = rb_eval(self, node->nd_value);
	}
	break;

d6226 6
d6251 1
a6251 2
	if (state == TAG_FATAL || obj_is_kind_of(errinfo, eSystemExit) ||
	    thread_abort || curr_thread->abort || RTEST(debug)) {
a6256 1
#if 0
d6258 1
a6258 12
	    thread_critical = 0;
	    thread_ready(main_thread);
	    main_thread->errinfo = errinfo;
	    if (curr_thread == main_thread) {
		rb_raise(errinfo);
	    }
	    curr_thread = main_thread;
	    th_raise_argc = 1;
	    th_raise_argv[0] = errinfo;
	    th_raise_file = sourcefile;
	    th_raise_line = sourceline;
	    thread_restore_context(curr_thread, 4);
a6259 1
#endif
a6533 19
catch_i(tag)
    ID tag;
{
    return f_catch(0, FIX2INT(tag));
}

VALUE
rb_catch(tag, proc, data)
    char *tag;
    VALUE (*proc)();
    VALUE data;
{
    return rb_iterate(catch_i, rb_intern(tag), proc, data);
}


static VALUE f_throw _((int,VALUE*)) NORETURN;

static VALUE
a6565 13
}

void
rb_throw(tag, val)
    char *tag;
    VALUE val;
{
    VALUE argv[2];
    ID t = rb_intern(tag);

    argv[0] = FIX2INT(t);
    argv[1] = val;
    f_throw(2, argv);
@


1.1.1.2.2.71
log
@str2cstr
@
text
@d6 1
a6 1
  $Date: 1998/07/09 08:40:12 $
d3961 1
a3961 1
    if (argc >= 3) {
d3965 1
a3965 1
    if (argc >= 4) {
@


1.1.1.2.2.72
log
@1.1b9_31
@
text
@d6 1
a6 1
  $Date: 1998/07/13 04:37:27 $
d5652 1
a6232 2
static VALUE thread_raise _((int, VALUE*, VALUE));

a6276 1
    thread_remove();
d6278 4
a6281 2
	if (state == TAG_FATAL) { 
	    /* fatal error within this thread, need to stop whole script */
d6285 1
a6285 4
	else if (obj_is_kind_of(errinfo, eSystemExit)) {
	    /* delegate exception to main_thread */
	    thread_raise(1, &errinfo, main_thread->thread);
	}
d6287 12
a6298 4
	    VALUE err = exc_new(eSystemExit, 0, 0);
	    error_print();
	    /* exit on main_thread */
	    thread_raise(1, &err, main_thread->thread);
d6300 1
d6305 2
a6306 2
    thread_schedule();
    return 0;			/* not reached */
@


1.1.1.2.2.73
log
@1.1c0
@
text
@d6 1
a6 1
  $Date: 1998/07/15 06:12:46 $
d5437 6
a5452 7
    if (th->stk_len == 0) return;  /* stack not active, no need to mark. */
    if (th->stk_ptr) {
	gc_mark_locations(th->stk_ptr, th->stk_ptr+th->stk_len);
#if defined(THINK_C) || defined(__human68k__)
	gc_mark_locations(th->stk_ptr+2, th->stk_ptr+th->stk_len+2);
#endif
    }
d5507 1
a5507 2
    int len = stack_length();
    th->stk_len = 0;
d5509 4
a5512 4
				             :gc_stack_start - len;
    if (len > th->stk_max)  {
	REALLOC_N(th->stk_ptr, VALUE, len);
	th->stk_max = len;
d5514 1
a5514 2
    th->stk_len = len;
    FLUSH_REGISTER_WINDOWS; 
@


1.1.1.2.2.74
log
@rehash
@
text
@d6 1
a6 1
  $Date: 1998/07/17 05:12:36 $
a5476 1
    if (!curr_thread) return;
@


1.1.1.2.2.75
log
@1.1c1
@
text
@d6 1
a6 1
  $Date: 1998/07/22 03:00:38 $
d329 1
a329 1
    ID attr, attriv;
d347 1
a347 3
    if (!name) {
	ArgError("argument needs to be symbol or string");
    }
d349 2
d354 1
a354 1
	rb_add_method(klass, id, NEW_IVAR(attriv), noex);
a355 2
    sprintf(buf, "%s=", name);
    id = rb_intern(buf);
d357 1
a357 1
	rb_add_method(klass, id, NEW_ATTRSET(attriv), noex);
@


1.1.1.2.2.76
log
@1.1c2
@
text
@d6 1
a6 1
  $Date: 1998/07/24 04:41:53 $
d3751 1
a3751 1
	    snprintf(buf, BUFSIZ, "%s:%d:in `%s'", sourcefile, sourceline,
d3755 1
a3755 1
	    snprintf(buf, BUFSIZ, "%s:%d", sourcefile, sourceline);
d3767 1
a3767 1
	    snprintf(buf, BUFSIZ, "%s:%d:in `%s'",
d3772 1
a3772 1
	    snprintf(buf, BUFSIZ, "%s:%d", frame->file, frame->line);
@


1.1.1.2.2.77
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/08/10 05:41:14 $
a1556 2
    char *file_save = sourcefile;
    int line_save = sourceline;
a1587 2
    sourceline = line_save;
    sourcefile = file_save;
d2783 1
a2783 1
    if (debug && !NIL_P(errinfo) && !obj_is_kind_of(errinfo, eSystemExit)) {
@


1.1.1.2.2.78
log
@1.1c3
@
text
@d6 1
a6 1
  $Date: 1998/08/14 03:56:19 $
d1456 1
a1456 1
	if (ev_const_defined((NODE*)the_frame->cbase, node->nd_vid)) {
d2178 1
a2178 1
		ev_const_defined((NODE*)the_frame->cbase, node->nd_vid)) {
d2207 1
a2207 1
	result = ev_const_get((NODE*)the_frame->cbase, node->nd_vid);
@


1.1.1.2.2.79
log
@1.1c4
@
text
@d6 1
a6 1
  $Date: 1998/08/27 03:55:05 $
d707 2
a708 4
	if (verbose) {
	    Warning("Insecure operation - %s",
		    rb_id2name(the_frame->last_func));
	}
d6127 1
a6127 1
	sleep((32767L<<16)+32767);
d6469 1
a6469 2
    if (curr_thread->status != THREAD_KILLED)
	thread_save_context(curr_thread);
@


1.1.1.2.2.80
log
@1.1c5
@
text
@d6 1
a6 1
  $Date: 1998/09/03 07:43:28 $
a4687 1
    the_frame->argc = 0;
@


1.1.1.2.2.81
log
@1.1c7
@
text
@d6 1
a6 1
  $Date: 1998/09/08 09:17:32 $
d425 6
d533 1
a533 1
	dyna_var_asgn(id, value);
d707 4
d1614 1
a1614 5
      case NODE_BLOCK:	
	if (!node->nd_next) {
	    node = node->nd_head;
	    goto again;
	}
a2339 1
		    if (str_tainted(str2)) str_taint(str);
d3053 1
a3053 1
		rb_call(CLASS_OF(recv), recv, lhs->nd_mid, 1, &val, 0);
d3061 1
a3061 2
		rb_call(CLASS_OF(recv), recv, lhs->nd_mid,
			RARRAY(args)->len, RARRAY(args)->ptr, 0);
d3356 1
a3356 1
    if ((++tick & 0x3ff) == 0 && stack_length() > STACK_LEVEL_MAX)
a5016 1
    struct BLOCK * volatile old_block;
d5038 1
a5038 2
    old_block = the_block;
    the_block = data;
d5076 1
a5076 1
    the_block = old_block;
a5103 1
    struct BLOCK * volatile old_block;
d5125 1
a5125 2
    old_block = the_block;
    the_block = data;
d5154 1
a5154 1
    the_block = old_block;
a6253 1
    enum thread_status status;
a6290 1
    status = th->status;
d6292 1
a6292 1
    if (state &&  status != THREAD_TO_KILL && !NIL_P(errinfo)) {
@


1.1.1.2.2.82
log
@1.1c8
@
text
@d6 1
a6 1
  $Date: 1998/11/09 09:11:48 $
a4841 1
	gc_mark(data->klass);
d5014 1
a5014 1
    struct BLOCK *data, data_body;
a5035 1
#if 0
a5036 4
#else
    data_body = *data;
    the_block = &data_body;
#endif
d5103 1
a5103 1
    struct BLOCK *data, data_body;
a5124 1
#if 0
a5125 4
#else
    data_body = *data;
    the_block = &data_body;
#endif
a5455 1
    if (th->status == THREAD_KILLED) return;
d5488 1
a5488 1
	gc_mark(th->thread);
d6210 1
a6210 1
    th->thread = data_object_alloc(cThread, th, thread_mark, thread_free);
a6252 1
    volatile VALUE thread = th->thread;
@


1.1.1.2.2.83
log
@1.1c final (hopefully)
@
text
@d6 1
a6 1
  $Date: 1998/11/17 09:12:30 $
d388 1
a388 4
#define POP_FRAME()  			\
    sourcefile = _frame.file;		\
    sourceline = _frame.line;		\
    the_frame = _frame.prev; }
a6258 28
#if defined(HAVE_SETITIMER) && !defined(__BOW__)
static int thread_init = 0;

void
thread_start_timer()
{
    struct itimerval tval;

    if (!thread_init) return;
    tval.it_interval.tv_sec = 0;
    tval.it_interval.tv_usec = 100000;
    tval.it_value = tval.it_interval;
    setitimer(ITIMER_VIRTUAL, &tval, NULL);
}

void
thread_stop_timer()
{
    struct itimerval tval;

    if (!thread_init) return;
    tval.it_interval.tv_sec = 0;
    tval.it_interval.tv_usec = 0;
    tval.it_value = tval.it_interval;
    setitimer(ITIMER_VIRTUAL, &tval, NULL);
}
#endif

d6270 5
a6274 1
    if (!thread_init) {
d6283 5
a6287 2
	thread_init = 1;
	thread_start_timer();
@


1.1.1.2.2.84
log
@1.2 stable
@
text
@d6 1
a6 1
  $Date: 1998/12/14 09:00:05 $
d1261 6
a1266 6
#if defined(C_ALLOCA)
# define TMP_PROTECT NODE * volatile __protect_tmp=0
# define TMP_ALLOC(n)						\
    (__protect_tmp = node_newnode(NODE_ALLOCA,			\
			     ALLOCA_N(VALUE,n),__protect_tmp,n),\
     (void*)__protect_tmp->nd_head)
d1269 1
a1269 1
# define TMP_ALLOC(n) ALLOCA_N(VALUE,n)
d1285 1
a1285 1
	    argv = TMP_ALLOC(argc);\
d2646 1
a2646 1
	VALUE *vars = TMP_ALLOC(node->nd_tbl[0]+1);
d3496 1
a3496 1
		local_vars = TMP_ALLOC(body->nd_tbl[0]+1);
d4190 1
a4190 1
	VALUE *vars = TMP_ALLOC(len);
@


1.1.1.2.2.85
log
@1.2.1 stable
@
text
@d6 1
a6 1
  $Date: 1998/12/25 04:35:38 $
d1265 1
a1265 1
			     ALLOC_N(VALUE,n),__protect_tmp,n),\
d2319 5
a2323 6
		if (list->nd_head) {
		    switch (nd_type(list->nd_head)) {
		      case NODE_STR:
			str2 = list->nd_head->nd_lit;
			break;
		      case NODE_EVSTR:
a2330 5
			/* fall through */
		      default:
			str2 = rb_eval(self, list->nd_head);
			str2 = obj_as_string(str2);
			break;
d2332 4
@


1.1.1.2.2.86
log
@1.2.2 PR1
@
text
@d6 1
a6 1
  $Date: 1999/01/11 07:55:25 $
d3481 5
a3485 7
	
      case NODE_IVAR:		/* for attr get */
	if (argc != 0) {
	    ArgError("Wrong # of arguments(%d for 0)", argc);
	}
      case NODE_ATTRSET:	/* for attr set */
      case NODE_ZSUPER:		/* for re-scoped/renamed method */
d4283 1
a4283 1
    volatile VALUE load;
@


1.1.1.2.2.87
log
@990209
@
text
@d6 1
a6 1
  $Date: 1999/01/18 09:08:49 $
d206 1
a208 1
	body = body->nd_head;
@


1.1.1.2.2.88
log
@1.2.4
@
text
@d6 1
a6 1
  $Date: 1999/02/09 03:29:21 $
d757 1
a757 2
    char *einfo;
    int elen;
d761 1
a761 9
    PUSH_TAG(PROT_NONE);
    if (EXEC_TAG() == 0) {
	errat = get_backtrace(errinfo);
    }
    else {
	errat = Qnil;
    }
    POP_TAG();
    
d772 2
a773 10
    PUSH_TAG(PROT_NONE);
    if (EXEC_TAG() == 0) {
	einfo = str2cstr(obj_as_string(errinfo), &elen);
    }
    else {
	einfo = "";
	elen = 0;
    }
    POP_TAG();
    if (eclass == eRuntimeError && elen == 0) {
d780 1
a780 1
	if (elen == 0) {
d787 1
a787 1
	    int len = elen;
d790 2
a791 2
	    if (tail = strchr(einfo, '\n')) {
		len = tail - einfo;
d795 1
a795 1
	    fwrite(einfo, 1, elen, stderr);
d802 1
a802 1
		fwrite(tail, 1, elen-len-1, stderr);
a1018 1
	    exec_end_proc();
d1082 1
d1853 1
a1853 1
	result = rb_yield_0(rb_eval(self, node->nd_stts), 0, 0);
a2324 1
			sourceline = nd_line(node);
a2725 1
    exec_end_proc();
d2879 1
a2879 1
rb_yield_0(val, self, klass)
d2881 1
a2881 1
    volatile VALUE self, klass;
d2905 1
a2905 1
    the_class = klass?klass:block->klass;
d2962 1
a2962 1
    return rb_yield_0(val, 0, 0);
d4044 1
a4044 1
    return rb_yield_0(self, self, the_class);
@


1.1.1.2.2.89
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1999/04/08 10:14:31 $
d925 2
a926 1
    NODE *beg_tree, *tree;
d928 2
a929 3
    beg_tree = eval_tree_begin;
    tree = eval_tree;
    if (beg_tree) {
d931 1
a931 1
	rb_eval(self, beg_tree);
d934 3
a936 1
    if (!tree) return Qnil;
d939 2
a940 1
    return rb_eval(self, tree);
d1953 1
a1953 1
		node->nd_state = RTEST(rb_eval(self, node->nd_end))?0:1;
d1974 1
a1974 3
	    else {
		result = FALSE;
	    }
a4896 1
	scope_dup(tmp->scope);
@


1.1.1.2.2.90
log
@1.2.5 pre
@
text
@d6 1
a6 1
  $Date: 1999/04/09 18:04:05 $
d500 2
a501 2
static VALUE
dvar_asgn(id, value, push)
a503 1
    int push;
a507 1
	if (push && vars->id == 0) break;
a517 8
VALUE
dyna_var_asgn(id, value)
    ID id;
    VALUE value;
{
    return dvar_asgn(id, value, 0);
}

d523 2
a524 1
    struct RVarmap* vars = 0;
d526 2
a527 3
    if (the_dyna_vars && the_dyna_vars->id == 0) {
	vars = the_dyna_vars;
	the_dyna_vars = the_dyna_vars->next;
d529 2
a530 4
    dvar_asgn(id, value, 1);
    if (vars) {
	vars->next = the_dyna_vars;
	the_dyna_vars = vars;
d639 1
a639 1
static NODE *compile _((VALUE));
d2343 1
a2343 1
			list->nd_head = compile(list->nd_head->nd_lit);
d3854 1
a3854 1
compile(src)
d3856 1
d3861 2
a3862 1
    node = compile_string(sourcefile, RSTRING(src)->ptr, RSTRING(src)->len);
d3930 1
a3930 1
	compile(src);
d3987 1
a3987 1
    int line = 1;
@


1.1.1.2.2.91
log
@1.2.6
@
text
@d6 1
a6 1
  $Date: 1999/04/13 05:54:22 $
d1395 1
a1395 1
				  the_frame->last_func, 0)) {
a2673 1
    PUSH_VARS();
a2696 1
    POP_VARS();
d4922 1
a4922 2
    bind = Data_Make_Struct(cBinding,struct BLOCK,blk_mark,blk_free,data);
    CLONESETUP(bind, self);
@


1.1.1.2.2.79.2.1
log
@1.1d series
@
text
@d6 1
a6 1
  $Date: 1998/09/03 07:43:28 $
d54 2
a55 2
VALUE rb_cProc;
static VALUE rb_cBinding;
d57 3
a59 3
static VALUE rb_f_binding _((VALUE));
static void rb_f_END _((void));
static VALUE rb_f_iterator_p _((void));
d61 1
a61 1
static VALUE rb_cMethod;
d124 1
a124 1
    if (NIL_P(klass)) klass = rb_cObject;
d197 1
a197 1
	    orig = search_method(rb_cObject, def, &origin);
d201 2
a202 2
	rb_raise(rb_eNameError, "undefined method `%s' for `%s'",
		 rb_id2name(def), rb_class2name(klass));
d223 2
a224 2
	rb_raise(rb_eNameError, "method `%s' not defined in %s",
		 rb_id2name(mid), rb_class2name(klass));
d248 2
a249 2
	rb_raise(rb_eNameError, "undefined method `%s' for `%s'",
		 rb_id2name(mid), rb_class2name(klass));
d256 1
a256 1
	rb_add_method(ruby_class, mid, 0, NOEX_UNDEF);
d271 2
a272 2
	rb_raise(rb_eNameError, "undefined method `%s' for `%s'",
		 rb_id2name(mid), rb_class2name(klass));
d288 1
a288 1
	body = search_method(rb_cObject, name, &origin);
d291 2
a292 2
	rb_raise(rb_eNameError, "undefined method `%s' for `%s'",
		 rb_id2name(name), rb_class2name(klass));
d315 2
a316 2
	    return Qfalse;
	return Qtrue;
d318 1
a318 1
    return Qfalse;
d336 1
a336 1
	    rb_warning("private attribute?");
d348 1
a348 1
	rb_raise(rb_eArgError, "argument needs to be symbol or string");
d364 4
a367 4
VALUE rb_errinfo = Qnil;
extern NODE *ruby_eval_tree_begin;
extern NODE *ruby_eval_tree;
extern int ruby_nerrs;
d369 2
a370 2
static VALUE rb_eLocalJumpError;
static VALUE rb_eSysStackError;
d372 1
a372 1
extern VALUE rb_top_self;
d374 2
a375 2
struct FRAME *ruby_frame;
struct SCOPE *ruby_scope;
d381 6
a386 6
    _frame.prev = ruby_frame;		\
    _frame.file = ruby_sourcefile;		\
    _frame.line = ruby_sourceline;		\
    _frame.iter = ruby_iter->iter;	\
    _frame.cbase = ruby_frame->cbase;	\
    ruby_frame = &_frame;		\
d388 1
a388 1
#define POP_FRAME()  ruby_frame = _frame.prev; }
d406 1
a406 2
static struct BLOCK *ruby_block;
static struct BLOCK *ruby_calling_block;
d414 8
a421 8
    _block.frame = *ruby_frame;		\
    _block.klass = ruby_class;		\
    _block.frame.file = ruby_sourcefile;	\
    _block.frame.line = ruby_sourceline;	\
    _block.scope = ruby_scope;		\
    _block.d_vars = ruby_dyna_vars;	\
    _block.prev = ruby_block;		\
    _block.iter = ruby_iter->iter;	\
d423 7
a429 1
    ruby_block = &_block;
d432 1
a432 14
   ruby_block = _block.prev; 		\
}

#define PUSH_BLOCK2(b) {		\
    struct BLOCK * volatile _old;	\
    struct BLOCK * volatile _old_call;	\
    _old = ruby_block;			\
    _old_call = ruby_calling_block;	\
    ruby_calling_block = b;		\
    ruby_block = b;

#define POP_BLOCK2() 			\
   ruby_calling_block = _old_call;	\
   ruby_block = _old;	 		\
d435 1
a435 1
struct RVarmap *ruby_dyna_vars;
d438 2
a439 2
    _old = ruby_dyna_vars;		\
    ruby_dyna_vars = 0;
d442 1
a442 1
    ruby_dyna_vars = _old;		\
d454 1
a454 1
    vars->next = ruby_dyna_vars;
d459 8
d468 1
a468 1
rb_dvar_defined(id)
d471 1
a471 1
    struct RVarmap *vars = ruby_dyna_vars;
d474 1
a474 1
	if (vars->id == id) return Qtrue;
d477 1
a477 1
    return Qfalse;
d481 1
a481 1
rb_dvar_ref(id)
d484 1
a484 1
    struct RVarmap *vars = ruby_dyna_vars;
d496 1
a496 1
rb_dvar_push(id, value)
d500 1
a500 1
    ruby_dyna_vars = new_dvar(id, value);
d503 2
a504 2
void
rb_dvar_asgn(id, value)
d508 1
a508 1
    struct RVarmap *vars = ruby_dyna_vars;
d513 1
a513 1
	    return;
d517 2
a518 2
    rb_dvar_push(id, value);
    return;
d526 8
a533 3
    rb_dvar_push(id, value);
    if (ruby_calling_block) {
	ruby_calling_block->d_vars = ruby_dyna_vars;
d541 1
a541 1
static struct iter *ruby_iter;
d549 1
a549 1
    _iter.prev = ruby_iter;		\
d551 1
a551 1
    ruby_iter = &_iter;			\
d554 1
a554 1
    ruby_iter = _iter.prev;		\
d571 2
a572 2
    _tag.frame = ruby_frame;		\
    _tag.iter = ruby_iter;		\
d586 2
a587 2
    ruby_frame = prot_tag->frame;	\
    ruby_iter = prot_tag->iter;		\
d607 1
a607 1
VALUE ruby_class;
d610 1
a610 1
    VALUE _class = ruby_class;	\
d612 1
a612 1
#define POP_CLASS() ruby_class = _class; }
d622 2
a623 2
    _old = ruby_scope;			\
    ruby_scope = _scope;		\
d627 5
a631 5
    if (ruby_scope->flag == SCOPE_ALLOCA) {\
	ruby_scope->local_vars = 0;\
	ruby_scope->local_tbl  = 0;\
	if (ruby_scope != top_scope)\
            rb_gc_force_recycle(ruby_scope);\
d634 1
a634 1
        ruby_scope->flag |= SCOPE_NOSTACK;\
d636 1
a636 1
    ruby_scope = _old;\
a642 1
static VALUE rb_yield_0 _((VALUE, VALUE, VALUE));
d645 1
a645 1
static VALUE rb_module_setup _((VALUE,NODE*));
d688 2
a689 2
	rb_raise(rb_eSecurityError, "tried to downgrade safe level from %d to %d",
		 safe_level, level);
d699 2
a700 2
	rb_raise(rb_eTypeError, "wrong argument type %s (expected String)",
		 rb_class2name(CLASS_OF(x)));
d702 1
a702 1
    if (rb_str_tainted(x)) {
d704 2
a705 2
	    rb_raise(rb_eSecurityError, "Insecure operation - %s",
		     rb_id2name(ruby_frame->last_func));
d707 3
a709 3
	if (rb_verbose) {
	    rb_warning("Insecure operation - %s",
		       rb_id2name(ruby_frame->last_func));
d719 2
a720 2
	rb_raise(rb_eSecurityError, "Insecure operation `%s' for level %d",
		 rb_id2name(ruby_frame->last_func), level);
d724 3
d728 1
a728 1
static void call_trace_func _((char*,char*,int,VALUE,ID,VALUE));
d733 4
a736 4
    if (ruby_sourcefile) {
	if (ruby_frame->last_func) {
	    fprintf(stderr, "%s:%d:in `%s'", ruby_sourcefile, ruby_sourceline,
		    rb_id2name(ruby_frame->last_func));
d739 1
a739 1
	    fprintf(stderr, "%s:%d", ruby_sourcefile, ruby_sourceline);
d766 1
a766 1
    if (NIL_P(rb_errinfo)) return;
d768 1
a768 1
    errat = get_backtrace(rb_errinfo);
d778 3
a780 3
    eclass = CLASS_OF(rb_errinfo);
    einfo = rb_obj_as_string(rb_errinfo);
    if (eclass == rb_eRuntimeError && RSTRING(einfo)->len == 0) {
d838 1
d841 2
a842 2
void Init_stack _((void));
void Init_heap _((void));
d844 1
d853 8
a860 2
    ruby_frame = top_frame = &frame;
    ruby_iter = &iter;
d862 1
a862 1
    Init_heap();
d864 3
a866 3
    ruby_scope->local_vars = 0;
    ruby_scope->local_tbl  = 0;
    top_scope = ruby_scope;
d873 4
a876 4
	ruby_class = rb_cObject;
	ruby_frame->self = rb_top_self;
	ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,rb_cObject,0,0);
	rb_define_global_const("TOPLEVEL_BINDING", rb_f_binding(rb_top_self));
d882 1
a882 1
    ruby_scope = top_scope;
d900 1
a900 1
	save = ruby_eval_tree;
d902 1
a902 1
	ruby_eval_tree = save;
a905 1
	trace_func = 0;
d918 3
a920 3
    if (ruby_eval_tree_begin) {
	tree = ruby_eval_tree_begin;
	ruby_eval_tree_begin = 0;
d924 1
a924 1
    if (!ruby_eval_tree) return Qnil;
d926 2
a927 2
    tree = ruby_eval_tree;
    ruby_eval_tree = 0;
d936 3
a938 3
static void rb_thread_cleanup _((void));
static void rb_thread_wait_other_threads _((void));
static VALUE rb_thread_current _((void));
d951 1
a951 1
    if (ruby_nerrs > 0) exit(ruby_nerrs);
d953 1
a953 1
    Init_stack();
d959 1
a959 1
	eval_node(rb_top_self);
d970 2
a971 2
	rb_thread_cleanup();
	rb_thread_wait_other_threads();
d974 1
a974 1
	rb_gc_call_finalizer_at_exit();
d1013 1
a1013 1
	if (rb_obj_is_kind_of(rb_errinfo, rb_eSystemExit)) {
d1020 1
a1020 1
	rb_bug("Unknown longjmp status %d", ex);
d1033 3
a1035 3
    mesg = str2cstr(rb_errinfo, &len);
    ruby_nerrs = 0;
    str = rb_str_new2("compile error");
d1037 2
a1038 2
	rb_str_cat(str, " in ", 4);
	rb_str_cat(str, at, strlen(at));
d1040 3
a1042 3
    rb_str_cat(str, "\n", 1);
    rb_str_cat(str, mesg, len);
    rb_exc_raise(rb_exc_new3(rb_eSyntaxError, str));
d1050 1
a1050 1
    char *oldsrc = ruby_sourcefile;
d1052 3
a1054 3
    ruby_sourcefile = "(eval)";
    v = eval(rb_top_self, rb_str_new2(str), Qnil, 0, 0);
    ruby_sourcefile = oldsrc;
d1076 2
a1077 2
    saved_scope = ruby_scope;
    ruby_scope = top_scope;
d1079 2
a1080 2
    ruby_class = rb_cObject;
    if (rb_str_tainted(cmd)) {
d1085 1
a1085 1
	val = eval(rb_top_self, cmd, Qnil, 0, 0);
d1088 1
a1088 1
    ruby_scope = saved_scope;
d1097 1
a1097 1
	rb_raise(rb_eLocalJumpError, "unexpected return");
d1100 1
a1100 1
	rb_raise(rb_eLocalJumpError, "unexpected next");
d1103 1
a1103 1
	rb_raise(rb_eLocalJumpError, "unexpected break");
d1106 1
a1106 1
	rb_raise(rb_eLocalJumpError, "unexpected redo");
d1109 1
a1109 1
	rb_raise(rb_eLocalJumpError, "retry outside of rescue clause");
d1128 1
a1128 1
	val = rb_eval_cmd(cmd, rb_ary_new3(1, INT2FIX(sig)));
d1132 1
a1132 1
	rb_trap_immediate = 0;
d1155 1
a1155 2
	    rb_raise(rb_eTypeError, "undefined superclass `%s'",
		     rb_id2name(node->nd_mid));
d1157 1
a1157 2
	    rb_raise(rb_eTypeError, "undefined superclass `%s'",
		     rb_id2name(node->nd_vid));
d1159 1
a1159 1
	    rb_raise(rb_eTypeError, "superclass undefined");
d1165 1
a1165 1
	rb_raise(rb_eTypeError, "can't make subclass of virtual class");
d1178 1
a1178 1
    while (cbase && cbase->nd_clss != rb_cObject) {
d1183 1
a1183 1
	    return Qtrue;
d1198 1
a1198 1
    while (cbase && cbase->nd_clss != rb_cObject) {
d1211 1
a1211 1
rb_mod_nesting()
d1213 2
a1214 2
    NODE *cbase = (NODE*)ruby_frame->cbase;
    VALUE ary = rb_ary_new();
d1216 2
a1217 2
    while (cbase && cbase->nd_clss != rb_cObject) {
	rb_ary_push(ary, cbase->nd_clss);
d1224 1
a1224 1
rb_mod_s_constants()
d1226 2
a1227 2
    NODE *cbase = (NODE*)ruby_frame->cbase;
    VALUE ary = rb_ary_new();
d1229 2
a1230 2
    while (cbase && cbase->nd_clss != rb_cObject) {
	rb_mod_const_at(cbase->nd_clss, ary);
d1234 1
a1234 1
    rb_mod_const_of(((NODE*)ruby_frame->cbase)->nd_clss, ary);
d1239 1
a1239 1
rb_mod_remove_method(mod, name)
d1247 1
a1247 1
rb_mod_undef_method(mod, name)
d1258 1
a1258 1
rb_mod_alias_method(mod, newname, oldname)
d1271 2
a1272 2
    (__protect_tmp = rb_node_newnode(NODE_ALLOCA,				   \
			     rb_str_new(0,sizeof(type)*(n)),0,__protect_tmp), \
d1288 2
a1289 2
	    char *file = ruby_sourcefile;\
	    int line = ruby_sourceline;\
d1297 2
a1298 2
	    ruby_sourcefile = file;\
	    ruby_sourceline = line;\
d1307 2
a1308 2
	char *file = ruby_sourcefile;\
	int line = ruby_sourceline;\
d1314 2
a1315 2
	ruby_sourcefile = file;\
	ruby_sourceline = line;\
d1320 3
a1322 3
    struct BLOCK *tmp_block = ruby_block;\
    if (ruby_iter->iter == ITER_PRE) {\
	ruby_block = ruby_block->prev;\
d1327 1
a1327 1
    ruby_block = tmp_block;\
d1331 1
a1331 1
#define MATCH_DATA ruby_scope->local_vars[node->nd_cnt]
d1374 3
a1376 3
	if (ruby_frame->last_func == 0) return 0;
	else if (rb_method_boundp(RCLASS(ruby_frame->last_class)->super,
				  ruby_frame->last_func, 1)) {
d1397 3
a1399 1
	if (state) return 0;
d1411 1
a1411 1
	if (rb_iterator_p()) {
d1458 1
a1458 1
	if (ev_const_defined((NODE*)ruby_frame->cbase, node->nd_vid)) {
d1469 3
a1471 1
	if (state) return 0;
d1483 1
a1483 1
	if (rb_reg_nth_defined(node->nd_nth, MATCH_DATA)) {
d1490 1
a1490 1
	if (rb_reg_nth_defined(0, MATCH_DATA)) {
d1515 1
a1515 1
rb_obj_is_block(block)
d1519 1
a1519 1
	return Qtrue;
d1521 1
a1521 1
    return Qfalse;
d1525 1
a1525 1
rb_obj_is_proc(proc)
d1528 2
a1529 2
    if (rb_obj_is_block(proc) && rb_obj_is_kind_of(proc, rb_cProc)) {
	return Qtrue;
d1531 1
a1531 1
    return Qfalse;
d1542 2
a1543 2
    if (!rb_obj_is_proc(trace)) {
	rb_raise(rb_eTypeError, "trace_func needs to be Proc");
d1549 1
a1549 1
call_trace_func(event, file, line, self, id, klass)
a1554 1
    VALUE klass;
d1559 2
a1560 2
    char *file_save = ruby_sourcefile;
    int line_save = ruby_sourceline;
d1567 1
a1567 1
    rb_thread_critical++;
d1570 1
a1570 1
    prev = ruby_frame;
d1572 2
a1573 2
    *ruby_frame = *_frame.prev;
    ruby_frame->prev = prev;
d1575 2
a1576 9
    if (file) {
	ruby_frame->line = ruby_sourceline = line;
	ruby_frame->file = ruby_sourcefile = file;
    }
    if (klass) {
	if (TYPE(klass) == T_ICLASS || FL_TEST(klass, FL_SINGLETON)) {
	    klass = self;
	}
    }
d1579 5
a1583 6
	proc_call(trace, rb_ary_new3(6, rb_str_new2(event),
				     rb_str_new2(ruby_sourcefile),
				     INT2FIX(ruby_sourceline),
				     INT2FIX(id),
				     self?rb_f_binding(self):Qnil,
				     klass));
d1589 1
a1589 1
    rb_thread_critical--;
d1592 2
a1593 2
    ruby_sourceline = line_save;
    ruby_sourcefile = file_save;
d1622 1
a1622 1
	rb_f_END();
d1634 1
a1634 1
	result = rb_reg_match2(node->nd_head->nd_lit);
d1639 1
a1639 1
	result = rb_reg_match(rb_eval(self,node->nd_recv),
d1649 1
a1649 1
		result = rb_reg_match(l, r);
d1659 1
a1659 1
	while (!NIL_P(rb_f_gets())) {
d1671 1
a1671 1
	RETURN(Qtrue);
d1674 1
a1674 1
	RETURN(Qfalse);
d1677 1
a1677 1
	ruby_sourceline = nd_line(node);
d1702 1
a1702 1
					self, ruby_frame->last_func, 0);	
d1704 1
a1704 2
		    ruby_sourcefile = tag->nd_file;
		    ruby_sourceline = nd_line(tag);
d1720 1
a1720 1
	    ruby_sourceline = nd_line(node);
d1744 3
a1746 1
	if (state) JUMP_TAG(state);
d1776 3
a1778 1
	if (state) JUMP_TAG(state);
d1801 2
a1802 2
		    char *file = ruby_sourcefile;
		    int line = ruby_sourceline;
d1806 2
a1807 2
		    ruby_sourcefile = file;
		    ruby_sourceline = line;
d1856 1
a1856 1
	result = rb_yield_0(rb_eval(self, node->nd_stts), 0, 0);
d1862 1
a1862 1
	    volatile VALUE e_info = rb_errinfo;
d1881 1
a1881 1
			    rb_errinfo = e_info;
d1892 3
a1894 1
	    if (state) JUMP_TAG(state);
d1910 3
a1912 1
	if (state) JUMP_TAG(state);
d1928 2
a1929 2
	if (RTEST(rb_eval(self, node->nd_body))) result = Qfalse;
	else result = Qtrue;
d1934 1
a1934 1
	RETURN(rb_range_new(rb_eval(self, node->nd_beg), rb_eval(self, node->nd_end)));
d1940 1
a1940 1
		result = Qtrue;
d1943 1
a1943 1
		result = Qfalse;
d1950 1
a1950 1
	    result = Qtrue;
d1958 1
a1958 1
		result = Qtrue;
d1960 1
a1960 1
	    result = Qfalse;
d1966 1
a1966 1
	    result = Qtrue;
d2016 3
a2018 3
	    if (ruby_frame->last_class == 0) {	
		rb_raise(rb_eNameError, "superclass method `%s' disabled",
			 rb_id2name(ruby_frame->last_func));
d2021 2
a2022 2
		argc = ruby_frame->argc;
		argv = ruby_frame->argv;
d2030 3
a2032 3
	    PUSH_ITER(ruby_iter->iter?ITER_PRE:ITER_NOT);
	    result = rb_call(RCLASS(ruby_frame->last_class)->super,
			     ruby_frame->self, ruby_frame->last_func,
d2040 1
a2040 1
	    VALUE save = ruby_frame->cbase;
d2044 1
a2044 1
	    if (node->nd_rval) ruby_frame->cbase = node->nd_rval;
d2048 3
a2050 3
		ruby_scope->local_vars = vars;
		rb_mem_clear(ruby_scope->local_vars, node->nd_tbl[0]);
		ruby_scope->local_tbl = node->nd_tbl;
d2053 2
a2054 2
		ruby_scope->local_vars = 0;
		ruby_scope->local_tbl  = 0;
d2061 1
a2061 1
	    ruby_frame->cbase = save;
d2138 2
a2139 2
	if (ruby_scope->local_vars == 0)
	    rb_bug("unexpected local variable assignment");
d2141 1
a2141 1
	ruby_scope->local_vars[node->nd_cnt] = result;
d2145 1
a2145 2
	result = rb_eval(self, node->nd_value);
	rb_dvar_asgn(node->nd_vid, result);
a2176 3
	    if (NIL_P(ruby_class)) {
		rb_raise(rb_eTypeError, "no class/module to define constant");
	    }
d2179 4
a2182 6
	    if (RTEST(rb_verbose) &&
		ev_const_defined((NODE*)ruby_frame->cbase, node->nd_vid)) {
		if (rb_verbose) {
		    rb_warning("already initialized constant %s",
			       rb_id2name(node->nd_vid));
		}
d2184 1
a2184 1
	    rb_const_set(ruby_class, node->nd_vid, val);
d2190 2
a2191 2
	if (ruby_scope->local_vars == 0) {
	    rb_bug("unexpected local variable");
d2193 1
a2193 1
	result = ruby_scope->local_vars[node->nd_cnt];
d2197 1
a2197 1
	result = rb_dvar_ref(node->nd_vid);
d2209 1
a2209 1
	result = ev_const_get((NODE*)ruby_frame->cbase, node->nd_vid);
d2213 5
a2217 5
	if (ruby_scope->local_vars == 0)
	    rb_bug("unexpected block argument");
	if (rb_iterator_p()) {
	    result = rb_f_lambda();
	    ruby_scope->local_vars[node->nd_cnt] = result;
d2242 1
a2242 1
	result = rb_const_get_at(rb_cObject, node->nd_mid);
d2246 1
a2246 1
	result = rb_reg_nth_match(node->nd_nth, MATCH_DATA);
d2252 1
a2252 1
	    result = rb_reg_last_match(MATCH_DATA);
d2255 1
a2255 1
	    result = rb_reg_match_pre(MATCH_DATA);
d2258 1
a2258 1
	    result = rb_reg_match_post(MATCH_DATA);
d2261 1
a2261 1
	    result = rb_reg_match_last(MATCH_DATA);
d2264 1
a2264 1
	    rb_bug("unexpected back-ref");
d2271 1
a2271 1
	    VALUE hash = rb_hash_new();
d2279 1
a2279 1
		    rb_bug("odd number list for Hash");
d2282 1
a2282 1
		rb_hash_aset(hash, key, val);
d2289 1
a2289 1
	result = rb_ary_new();
d2298 1
a2298 1
	    ary = rb_ary_new2(i);
d2309 1
a2309 1
	result = rb_str_new3(node->nd_lit);
d2320 1
a2320 1
	    str = rb_str_new3(node->nd_lit);
d2329 1
a2329 1
			ruby_eval_tree = 0;
d2331 1
a2331 1
			if (ruby_nerrs > 0) {
d2336 1
a2336 1
		    str2 = rb_obj_as_string(str2);
d2339 1
a2339 1
		    rb_str_cat(str, RSTRING(str2)->ptr, RSTRING(str2)->len);
d2345 1
a2345 1
		result = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
d2349 1
a2349 1
		result = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
d2373 3
a2375 4
	if (ruby_frame->argc != 1)
	    rb_raise(rb_eArgError, "Wrong # of arguments(%d for 1)",
		     ruby_frame->argc);
	result = rb_ivar_set(self, node->nd_vid, ruby_frame->argv[0]);
d2384 2
a2385 5
	    if (NIL_P(ruby_class)) {
		rb_raise(rb_eTypeError, "no class to add method");
	    }
	    if (ruby_class == rb_cObject && node->nd_mid == init) {
		rb_warn("re-defining Object#initialize may cause infinite loop");
d2387 1
a2387 1
	    body = search_method(ruby_class, node->nd_mid, &origin);
d2389 2
a2390 2
		if (origin == ruby_class && rb_verbose) {
		    rb_warning("discarding old %s", rb_id2name(node->nd_mid));
d2404 1
a2404 1
	    if (body && origin == ruby_class && body->nd_noex & NOEX_UNDEF) {
d2407 1
a2407 1
	    rb_add_method(ruby_class, node->nd_mid, node->nd_defn, noex);
d2409 1
a2409 1
		rb_add_method(rb_singleton_class(ruby_class),
d2411 1
a2411 1
		rb_funcall(ruby_class, rb_intern("singleton_method_added"),
d2414 2
a2415 2
	    if (FL_TEST(ruby_class, FL_SINGLETON)) {
		rb_funcall(rb_iv_get(ruby_class, "__attached__"),
d2420 1
a2420 1
		rb_funcall(ruby_class, rb_intern("method_added"),
d2434 2
a2435 2
		rb_raise(rb_eTypeError, "Can't define method \"%s\" for Fixnum",
			 rb_id2name(node->nd_mid));
d2438 2
a2439 2
		rb_raise(rb_eTypeError, "Can't define method \"%s\" for nil",
			 rb_id2name(node->nd_mid));
d2442 2
a2443 3
		rb_raise(rb_eTypeError,
			 "Can't define method \"%s\" for special constants",
			 rb_id2name(node->nd_mid));
d2447 2
a2448 3
	    if (st_lookup(RCLASS(klass)->m_tbl, node->nd_mid, &body)
		&& rb_verbose) {
		rb_warning("redefine %s", rb_id2name(node->nd_mid));
d2464 1
a2464 4
	    if (NIL_P(ruby_class)) {
		rb_raise(rb_eTypeError, "no class to undef method");
	    }
	    body = search_method(ruby_class, node->nd_mid, &origin);
d2467 1
a2467 1
		VALUE klass = ruby_class;
d2469 2
a2470 2
		if (FL_TEST(ruby_class, FL_SINGLETON)) {
		    VALUE obj = rb_iv_get(ruby_class, "__attached__");
d2478 2
a2479 2
		rb_raise(rb_eNameError, "undefined method `%s' for%s `%s'",
			 rb_id2name(node->nd_mid),s0,rb_class2name(klass));
d2482 1
a2482 1
	    rb_add_method(ruby_class, node->nd_mid, 0, NOEX_PUBLIC);
d2488 2
a2489 5
	if (NIL_P(ruby_class)) {
	    rb_raise(rb_eTypeError, "no class to make alias");
	}
	rb_alias(ruby_class, node->nd_new, node->nd_old);
	rb_funcall(ruby_class, rb_intern("method_added"),
a2502 3
	    if (NIL_P(ruby_class)) {
		rb_raise(rb_eTypeError, "no outer class/module");
	    }
d2510 2
a2511 2
	    if (rb_const_defined_at(ruby_class,node->nd_cname) &&
		(ruby_class != rb_cObject ||
d2514 1
a2514 1
		klass = rb_const_get_at(ruby_class, node->nd_cname);
d2516 1
a2516 2
		    rb_raise(rb_eTypeError, "%s is not a class",
			     rb_id2name(node->nd_cname));
d2527 2
a2528 2
			rb_raise(rb_eTypeError, "superclass mismatch for %s",
				 rb_id2name(node->nd_cname));
d2532 1
a2532 1
		    rb_raise(rb_eSecurityError, "extending class prohibited");
d2537 1
a2537 1
		if (!super) super = rb_cObject;
d2539 3
a2541 3
		rb_const_set(ruby_class, node->nd_cname, klass);
		rb_set_class_path(klass,ruby_class,rb_id2name(node->nd_cname));
		rb_obj_call_init(klass);
d2544 1
a2544 1
	    return rb_module_setup(klass, node->nd_body);
d2552 2
a2553 5
	    if (NIL_P(ruby_class)) {
		rb_raise(rb_eTypeError, "no outer class/module");
	    }
	    if (rb_const_defined_at(ruby_class, node->nd_cname) &&
		(ruby_class != rb_cObject ||
d2556 1
a2556 1
		module = rb_const_get_at(ruby_class, node->nd_cname);
d2558 1
a2558 2
		    rb_raise(rb_eTypeError, "%s is not a module",
			     rb_id2name(node->nd_cname));
d2561 1
a2561 1
		    rb_raise(rb_eSecurityError, "extending module prohibited");
d2566 3
a2568 3
		rb_const_set(ruby_class, node->nd_cname, module);
		rb_set_class_path(module,ruby_class,rb_id2name(node->nd_cname));
		rb_obj_call_init(module);
d2571 1
a2571 1
	    result = rb_module_setup(module, node->nd_body);
d2581 1
a2581 1
		rb_raise(rb_eTypeError, "No virtual class for Fixnums");
d2584 1
a2584 1
		rb_raise(rb_eTypeError, "No virtual class for nil");
d2587 1
a2587 1
		rb_raise(rb_eTypeError, "No virtual class for special constants");
d2594 1
a2594 1
	    result = rb_module_setup(klass, node->nd_body);
d2603 2
a2604 2
	    if (desc) result = rb_str_new2(desc);
	    else result = Qfalse;
d2609 2
a2610 2
	ruby_sourcefile = node->nd_file;
	ruby_sourceline = node->nd_nth;
d2612 2
a2613 2
	    call_trace_func("line", ruby_sourcefile, ruby_sourceline,
			    self, ruby_frame->last_func, 0);	
d2619 1
a2619 1
	rb_bug("unknown node type %d", nd_type(node));
d2627 1
a2627 1
rb_module_setup(module, node)
d2632 1
a2632 1
    VALUE save = ruby_frame->cbase;
d2634 2
a2635 2
    char *file = ruby_sourcefile;
    int line = ruby_sourceline;
d2643 1
a2643 1
    ruby_class = module;
d2646 1
a2646 1
    if (node->nd_rval) ruby_frame->cbase = node->nd_rval;
d2650 3
a2652 3
	ruby_scope->local_vars = vars;
	rb_mem_clear(ruby_scope->local_vars, node->nd_tbl[0]);
	ruby_scope->local_tbl = node->nd_tbl;
d2655 2
a2656 2
	ruby_scope->local_vars = 0;
	ruby_scope->local_tbl  = 0;
d2663 1
a2663 1
			    ruby_class, ruby_frame->last_func, 0);
d2665 1
a2665 1
	result = rb_eval(ruby_class, node->nd_body);
d2671 1
a2671 1
    ruby_frame->cbase = save;
d2673 1
a2673 1
	call_trace_func("end", file, line, 0, ruby_frame->last_func, 0);
d2686 1
a2686 1
	return Qtrue;
d2688 1
a2688 1
    return Qfalse;
d2692 1
a2692 1
rb_obj_respond_to(argc, argv, obj)
d2703 1
a2703 1
	return Qtrue;
d2705 1
a2705 1
    return Qfalse;
d2709 1
a2709 1
rb_mod_method_defined(mod, mid)
d2713 1
a2713 1
	return Qtrue;
d2715 1
a2715 1
    return Qfalse;
d2724 1
a2724 1
	rb_exc_raise(rb_exc_new(rb_eSystemExit, 0, 0));
d2730 1
a2730 1
rb_f_exit(argc, argv, obj)
d2749 1
a2749 1
rb_f_abort()
d2752 1
a2752 1
    if (rb_errinfo) {
d2775 1
a2775 1
    if (NIL_P(mesg)) mesg = rb_errinfo;
d2777 1
a2777 1
	mesg = rb_exc_new(rb_eRuntimeError, 0, 0);
d2781 1
a2781 1
    if (NIL_P(at) && ruby_sourcefile && !NIL_P(mesg)) {
d2786 1
a2786 1
	rb_errinfo = mesg;
d2789 1
a2789 2
    if (rb_debug && !NIL_P(rb_errinfo)
	&& !rb_obj_is_kind_of(rb_errinfo, rb_eSystemExit)) {
d2791 2
a2792 2
		rb_class2name(CLASS_OF(rb_errinfo)),
		ruby_sourcefile, ruby_sourceline);
d2795 1
a2795 1
    rb_trap_restore_mask();
d2797 2
a2798 2
	call_trace_func("raise", ruby_sourcefile, ruby_sourceline,
			ruby_frame->self, ruby_frame->last_func, 0);
d2804 1
a2804 1
rb_exc_raise(mesg)
d2811 1
a2811 1
rb_exc_fatal(mesg)
d2820 1
a2820 1
    rb_raise(rb_eInterrupt, "");
d2824 1
a2824 1
rb_f_raise(argc, argv)
d2832 1
a2832 1
    etype = rb_eRuntimeError;
d2850 1
a2850 1
	    mesg = rb_exc_new3(rb_eRuntimeError, mesg);
d2852 2
a2853 2
	if (!rb_obj_is_kind_of(mesg, rb_eException)) {
	    rb_raise(rb_eTypeError, "exception object expected");
d2859 1
a2859 1
    *ruby_frame = *_frame.prev->prev;
d2865 1
a2865 1
rb_iterator_p()
d2867 2
a2868 2
    if (ruby_frame->iter) return Qtrue;
    return Qfalse;
d2872 1
a2872 1
rb_f_iterator_p()
d2874 2
a2875 2
    if (ruby_frame->prev && ruby_frame->prev->iter) return Qtrue;
    return Qfalse;
d2878 4
a2881 3
static VALUE
rb_yield_0(val, self, klass)
    VALUE val, self, klass;
d2891 2
a2892 2
    if (!rb_iterator_p() || !ruby_block) {
	rb_raise(rb_eLocalJumpError, "yield called out of iterator");
d2897 1
a2897 1
    block = ruby_block;
d2899 7
a2905 7
    frame.prev = ruby_frame;
    ruby_frame = &(frame);
    old_scope = ruby_scope;
    ruby_scope = block->scope;
    ruby_block = block->prev;
    ruby_dyna_vars = block->d_vars;
    ruby_class = klass?klass:block->klass;
d2951 3
a2953 3
    ruby_block = block;
    ruby_frame = ruby_frame->prev;
    ruby_scope = old_scope;
d2962 1
a2962 1
    return rb_yield_0(val, 0, 0);
d2966 1
a2966 1
rb_f_loop()
d2968 1
a2968 1
    for (;;) { rb_yield_0(Qnil, 0, 0); }
d2993 1
a2993 1
		assign(self, node->nd_args, rb_ary_new4(len-i, RARRAY(val)->ptr+i));
d2996 1
a2996 1
		assign(self, node->nd_args, rb_ary_new2(0));
d3026 3
a3028 3
	if (ruby_scope->local_vars == 0)
	    rb_bug("unexpected iterator variable assignment");
	ruby_scope->local_vars[lhs->nd_cnt] = val;
d3032 1
a3032 1
	rb_dvar_asgn(lhs->nd_vid, val);
d3040 1
a3040 1
	rb_const_set(ruby_class, lhs->nd_vid, val);
d3067 1
a3067 1
	rb_bug("bug in variable assignment");
d3080 1
a3080 1
    VALUE self = rb_top_self;
d3091 1
a3091 1
    if (ruby_block->tag->dst == state) {
d3130 1
a3130 1
	return rb_obj_is_kind_of(rb_errinfo, rb_eStandardError);
d3138 2
a3139 2
	if (!rb_obj_is_kind_of(argv[0], rb_cModule)) {
	    rb_raise(rb_eTypeError, "class or module required for rescue clause");
d3141 1
a3141 1
	if (rb_obj_is_kind_of(rb_errinfo, argv[0])) return 1;
d3154 1
a3154 1
    volatile VALUE e_info = rb_errinfo;
d3161 1
a3161 1
    else if (state == TAG_RAISE && rb_obj_is_kind_of(rb_errinfo, rb_eStandardError)) {
d3165 1
a3165 1
		result = (*r_proc)(data2, rb_errinfo);
d3178 1
a3178 1
	    rb_errinfo = e_info;
d3206 3
a3208 1
    if (state) JUMP_TAG(state);
d3219 1
a3219 1
rb_f_missing(argc, argv, obj)
d3227 2
a3228 2
    char *file = ruby_sourcefile;
    int   line = ruby_sourceline;
d3238 1
a3238 1
	format = "undefined method `%s' for Qtrue";
d3241 1
a3241 1
	format = "undefined method `%s' for Qfalse";
d3244 1
a3244 1
	desc = rb_any_to_s(obj);
d3257 1
a3257 1
	else if (rb_iterator_p()) {
d3271 1
a3271 1
	    desc = rb_any_to_s(obj);
d3275 2
a3276 2
    ruby_sourcefile = file;
    ruby_sourceline = line;
d3278 1
a3278 1
    *ruby_frame = *_frame.prev->prev;
d3280 3
a3282 3
    rb_raise(rb_eNameError, format,
	     rb_id2name(id),
	     desc?(char*)RSTRING(desc)->ptr:"");
d3314 1
a3314 1
# define STACK_LEVEL_MAX 655300
d3317 1
a3317 1
extern VALUE *rb_gc_stack_start;
d3324 1
a3324 1
    return rb_gc_stack_start - &pos + 0x80;
d3326 2
a3327 2
    return (&pos < rb_gc_stack_start) ? rb_gc_stack_start - &pos
	                              : &pos - rb_gc_stack_start;
a3331 87
call_cfunc(func, recv, len, argc, argv)
    VALUE (*func)();
    VALUE recv;
    int len, argc;
    VALUE *argv;
{
    if (len >= 0 && argc != len) {
	rb_raise(rb_eArgError, "Wrong # of arguments(%d for %d)",
		 argc, len);
    }

    switch (len) {
      case -2:
	return (*func)(recv, rb_ary_new4(argc, argv));
	break;
      case -1:
	return (*func)(argc, argv, recv);
	break;
      case 0:
	return (*func)(recv);
	break;
      case 1:
	return (*func)(recv, argv[0]);
	break;
      case 2:
	return (*func)(recv, argv[0], argv[1]);
	break;
      case 3:
	return (*func)(recv, argv[0], argv[1], argv[2]);
	break;
      case 4:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3]);
	break;
      case 5:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4]);
	break;
      case 6:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5]);
	break;
      case 7:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6]);
	break;
      case 8:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7]);
	break;
      case 9:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8]);
	break;
      case 10:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9]);
	break;
      case 11:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10]);
	break;
      case 12:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9],
		       argv[10], argv[11]);
	break;
      case 13:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10],
		       argv[11], argv[12]);
	break;
      case 14:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10],
		       argv[11], argv[12], argv[13]);
	break;
      case 15:
	return (*func)(recv, argv[0], argv[1], argv[2], argv[3], argv[4],
		       argv[5], argv[6], argv[7], argv[8], argv[9], argv[10],
		       argv[11], argv[12], argv[13], argv[14]);
	break;
      default:
	rb_raise(rb_eArgError, "too many arguments(%d)", len);
	break;
    }
}

static VALUE
d3346 1
a3346 1
    switch (ruby_iter->iter) {
d3357 1
a3357 1
	rb_raise(rb_eSysStackError, "stack level too deep");
d3361 5
a3365 6

    ruby_frame->last_func = id;
    ruby_frame->last_class = nosuper?0:klass;
    ruby_frame->self = recv;
    ruby_frame->argc = argc;
    ruby_frame->argv = argv;
d3372 2
a3373 3
	    if (len < -2) {
		rb_bug("bad argc(%d) specified for `%s(%s)'",
		       len, rb_class2name(klass), rb_id2name(id));
d3375 96
a3470 7
	    if (trace_func) {
		int state;
		char *file = ruby_frame->prev->file;
		int line = ruby_frame->prev->line;
		if (!file) {
		    file = ruby_sourcefile;
		    line = ruby_sourceline;
d3472 2
a3473 5

		call_trace_func("c-call", 0, 0, 0, id, 0);
		PUSH_TAG(PROT_FUNC);
		if ((state = EXEC_TAG()) == 0) {
		    result = call_cfunc(body->nd_cfnc, recv, len, argc, argv);
d3475 1
a3475 6
		POP_TAG();
		call_trace_func("c-return", 0, 0, recv, id, klass);
		if (state) JUMP_TAG(state);
	    }
	    else {
		result = call_cfunc(body->nd_cfnc, recv, len, argc, argv);
d3495 1
a3495 1
	    if (body->nd_rval) ruby_frame->cbase = body->nd_rval;
d3499 3
a3501 3
		rb_mem_clear(local_vars, body->nd_tbl[0]);
		ruby_scope->local_tbl = body->nd_tbl;
		ruby_scope->local_vars = local_vars;
d3504 2
a3505 2
		local_vars = ruby_scope->local_vars = 0;
		ruby_scope->local_tbl  = 0;
d3526 1
a3526 1
			rb_bug("no argument-node");
d3531 1
a3531 2
			rb_raise(rb_eArgError, "Wrong # of arguments(%d for %d)",
				 argc, i);
d3542 1
a3542 1
			    rb_raise(rb_eArgError, "Wrong # of arguments(%d for %d)",
d3565 1
a3565 1
				local_vars[node->nd_rest]=rb_ary_new4(argc,argv);
d3567 1
a3567 1
				local_vars[node->nd_rest]=rb_ary_new2(0);
d3574 1
a3574 1
				    recv, ruby_frame->last_func, 0);
d3586 2
a3587 2
		char *file = ruby_frame->prev->file;
		int line = ruby_frame->prev->line;
d3589 2
a3590 2
		    file = ruby_sourcefile;
		    line = ruby_sourceline;
d3592 1
a3592 2
		call_trace_func("return", file, line, recv,
				ruby_frame->last_func, klass);
d3599 1
a3599 1
		rb_raise(rb_eLocalJumpError, "unexpected next");
d3602 1
a3602 1
		rb_raise(rb_eLocalJumpError, "unexpected break");
d3605 1
a3605 1
		rb_raise(rb_eLocalJumpError, "unexpected redo");
d3608 2
a3609 2
		if (!rb_iterator_p()) {
		    rb_raise(rb_eLocalJumpError, "retry outside of rescue clause");
d3644 1
a3644 2
	    rb_raise(rb_eNameError, "super: no superclass method `%s'",
		     rb_id2name(mid));
d3654 1
a3654 1
    if ((noex & NOEX_PROTECTED) && !rb_obj_is_kind_of(ruby_frame->self, klass))
d3676 1
a3676 1
rb_f_send(argc, argv, recv)
d3683 1
a3683 1
    if (argc == 0) rb_raise(rb_eArgError, "no method name given");
d3686 1
a3686 1
    PUSH_ITER(rb_iterator_p()?ITER_PRE:ITER_NOT);
d3748 1
a3748 1
    struct FRAME *frame = ruby_frame;
d3754 1
a3754 1
    ary = rb_ary_new();
d3757 2
a3758 3
	    snprintf(buf, BUFSIZ, "%s:%d:in `%s'",
		     ruby_sourcefile, ruby_sourceline,
		     rb_id2name(frame->last_func));
d3761 1
a3761 1
	    snprintf(buf, BUFSIZ, "%s:%d", ruby_sourcefile, ruby_sourceline);
d3763 1
a3763 1
	rb_ary_push(ary, rb_str_new2(buf));
d3774 2
a3775 2
		     frame->file, frame->line,
		     rb_id2name(frame->prev->last_func));
d3780 1
a3780 1
	rb_ary_push(ary, rb_str_new2(buf));
d3788 1
a3788 1
rb_f_caller(argc, argv)
d3799 1
a3799 1
    if (lev < 0) rb_raise(rb_eArgError, "negative level(%d)", lev);
d3829 1
a3829 1
    return ruby_frame->last_func;
d3840 2
a3841 2
    if (place == 0) place = ruby_sourcefile;
    node = rb_compile_string(place, RSTRING(src)->ptr, RSTRING(src)->len);
d3843 1
a3843 1
    if (ruby_nerrs == 0) return node;
a3856 1
    struct BLOCK * volatile old_call_block;
d3860 3
a3862 3
    char *filesave = ruby_sourcefile;
    int linesave = ruby_sourceline;
    volatile int iter = ruby_frame->iter;
d3866 2
a3867 2
	file = ruby_sourcefile;
	line = ruby_sourceline;
d3870 3
a3872 3
	if (!rb_obj_is_block(scope)) {
	    rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc/Binding)",
		     rb_class2name(CLASS_OF(scope)));
d3879 8
a3886 10
	frame.prev = ruby_frame;
	ruby_frame = &(frame);
	old_scope = ruby_scope;
	ruby_scope = data->scope;
	old_call_block = ruby_calling_block;
	ruby_calling_block = data;
	old_block = ruby_block;
	ruby_block = data->prev;
	old_d_vars = ruby_dyna_vars;
	ruby_dyna_vars = data->d_vars;
d3891 1
a3891 1
	ruby_frame->iter = data->iter;
d3894 2
a3895 2
	if (ruby_frame->prev) {
	    ruby_frame->iter = ruby_frame->prev->iter;
d3899 1
a3899 1
    ruby_class = ((NODE*)ruby_frame->cbase)->nd_clss;
d3902 2
a3903 2
    if (TYPE(ruby_class) == T_ICLASS) {
	ruby_class = RBASIC(ruby_class)->klass;
d3907 2
a3908 2
	ruby_sourcefile = file;
	ruby_sourceline = line;
d3910 1
a3910 1
	if (ruby_nerrs > 0) {
d3919 5
a3923 6
	ruby_frame = ruby_frame->prev;
	ruby_scope = old_scope;
	ruby_block = old_block;
	ruby_calling_block = old_call_block;
	data->d_vars = ruby_dyna_vars;
	ruby_dyna_vars = old_d_vars;
d3928 1
a3928 1
	ruby_frame->iter = iter;
d3930 2
a3931 2
    ruby_sourcefile = filesave;
    ruby_sourceline = linesave;
d3937 1
a3937 1
	    errat = get_backtrace(rb_errinfo);
d3939 1
a3939 1
		if (ruby_sourceline > 1) {
d3941 2
a3942 2
		    rb_str_cat(err, ": ", 2);
		    rb_str_concat(err, rb_errinfo);
d3945 1
a3945 1
		    err = rb_str_dup(rb_errinfo);
d3948 1
a3948 1
		rb_exc_raise(rb_exc_new3(CLASS_OF(rb_errinfo), err));
d3950 1
a3950 1
	    rb_exc_raise(rb_errinfo);
d3959 1
a3959 1
rb_f_eval(argc, argv, self)
d3990 1
a3990 1
    VALUE cbase = ruby_frame->cbase;
d3993 1
a3993 1
    ruby_class = under;
d3995 5
a3999 5
    ruby_frame->last_func = _frame.prev->last_func;
    ruby_frame->last_class = _frame.prev->last_class;
    ruby_frame->argc = _frame.prev->argc;
    ruby_frame->argv = _frame.prev->argv;
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,under,0,cbase);
d4041 1
a4041 1
    return rb_yield_0(self, self, ruby_class);
d4052 1
a4052 1
rb_obj_instance_eval(argc, argv, self)
a4058 1
    VALUE klass;
d4061 2
a4062 2
	if (!rb_iterator_p()) {
	    rb_raise(rb_eArgError, "block not supplied");
d4071 3
a4073 3
	rb_raise(rb_eArgError, "Wrong # of arguments: %s(src) or %s{..}",
		 rb_id2name(ruby_frame->last_func),
		 rb_id2name(ruby_frame->last_func));
a4075 6
    if (rb_special_const_p(self)) {
	klass = Qnil;
    }
    else {
	klass = rb_singleton_class(self);
    }
d4077 1
a4077 1
	return yield_under(klass, self);
d4080 1
a4080 1
	return eval_under(klass, self, argv[0], file, line);
d4085 1
a4085 1
rb_mod_module_eval(argc, argv, mod)
d4094 2
a4095 2
	if (!rb_iterator_p()) {
	    rb_raise(rb_eArgError, "block not supplied");
d4104 3
a4106 3
	rb_raise(rb_eArgError, "Wrong # of arguments: %s(src) or %s{..}",
		 rb_id2name(ruby_frame->last_func),
		 rb_id2name(ruby_frame->last_func));
d4154 1
a4154 1
	vpath = rb_ary_join(rb_load_path, rb_str_new2(RUBY_LIB_SEP));
d4166 1
a4166 1
rb_f_load(obj, fname)
d4177 1
a4177 1
	fname = rb_file_s_expand_path(1, &fname);
d4181 1
a4181 4
    if (!file) {
	rb_raise(rb_eLoadError, "No such file to load -- %s",
		 RSTRING(fname)->ptr);
    }
d4186 1
a4186 1
    ruby_class = rb_cObject;
d4195 2
a4196 2
	ruby_scope->local_tbl = tbl;
	ruby_scope->local_vars = vars;
d4202 2
a4203 2
    last_func = ruby_frame->last_func;
    ruby_frame->last_func = 0;
d4208 2
a4209 2
	if (ruby_nerrs == 0) {
	    eval_node(rb_top_self);
d4212 3
a4214 3
    ruby_frame->last_func = last_func;
    if (ruby_scope->flag == SCOPE_ALLOCA && ruby_scope->local_tbl) {
	free(ruby_scope->local_tbl);
d4220 2
a4221 2
    if (ruby_nerrs > 0) {
	rb_exc_raise(rb_errinfo);
d4225 1
a4225 1
    return Qtrue;
d4242 1
a4242 1
	if (strcmp(f, feature) == 0) return Qtrue;
d4246 1
a4246 1
	    return Qtrue;
d4250 1
a4250 1
    return Qfalse;
d4254 2
a4255 2
static int rb_thread_loading _((char*));
static void rb_thread_loading_done _((void));
d4273 1
a4273 1
	rb_ary_push(rb_features, rb_str_new2(feature));
d4278 1
a4278 1
rb_f_require(obj, fname)
d4286 1
a4286 1
	return Qfalse;
d4313 1
a4313 2
    strcpy(buf, RSTRING(fname)->ptr);
    strcat(buf, ".rb");
d4316 1
a4316 1
	fname = rb_str_new2(file);
d4320 1
a4320 2
    strcpy(buf, RSTRING(fname)->ptr);
    strcat(buf, DLEXT);
d4326 1
a4326 2
    rb_raise(rb_eLoadError, "No such file to load -- %s",
	     RSTRING(fname)->ptr);
d4330 1
a4330 1
    if (rb_thread_loading(feature)) return Qfalse;
d4336 1
a4336 1
	    load = rb_str_new2(file);
d4343 1
a4343 1
	rb_thread_loading_done();
d4347 1
a4347 1
    return Qtrue;
d4351 1
a4351 1
    if (rb_thread_loading(feature)) return Qfalse;
d4357 1
a4357 1
	    rb_f_load(obj, fname);
d4362 1
a4362 1
	rb_thread_loading_done();
d4366 1
a4366 1
    return Qtrue;
d4384 1
a4384 1
rb_mod_public(argc, argv, module)
d4399 1
a4399 1
rb_mod_protected(argc, argv, module)
d4414 1
a4414 1
rb_mod_private(argc, argv, module)
d4429 1
a4429 1
rb_mod_public_method(argc, argv, obj)
d4439 1
a4439 1
rb_mod_private_method(argc, argv, obj)
d4453 1
a4453 1
    return rb_mod_public(argc, argv, rb_cObject);
d4461 1
a4461 1
    return rb_mod_private(argc, argv, rb_cObject);
d4465 1
a4465 1
rb_mod_modfunc(argc, argv, module)
d4484 2
a4485 2
	    rb_raise(rb_eNameError, "undefined method `%s' for module `%s'",
		     rb_id2name(id), rb_class2name(module));
d4494 1
a4494 1
rb_mod_append_features(module, include)
d4511 1
a4511 1
rb_mod_include(argc, argv, module)
d4526 1
a4526 1
rb_obj_call_init(obj)
d4529 2
a4530 2
    PUSH_ITER(rb_iterator_p()?ITER_PRE:ITER_NOT);
    rb_funcall2(obj, init, ruby_frame->argc, ruby_frame->argv);
d4535 1
a4535 1
rb_class_new_instance(argc, argv, klass)
d4543 1
a4543 1
	rb_raise(rb_eTypeError, "can't create instance of virtual class");
d4545 2
a4546 2
    obj = rb_obj_alloc(klass);
    rb_obj_call_init(obj);
d4557 1
a4557 1
    return rb_mod_include(argc, argv, rb_cObject);
d4568 1
a4568 1
rb_mod_extend_object(mod, obj)
d4576 1
a4576 1
rb_obj_extend(argc, argv, obj)
d4590 2
a4591 2
VALUE rb_f_trace_var();
VALUE rb_f_untrace_var();
d4599 2
a4600 2
    if (!rb_obj_is_kind_of(val, rb_eException)) {
	rb_raise(rb_eTypeError, "assigning non-exception to $!");
d4609 1
a4609 1
    return get_backtrace(rb_errinfo);
d4618 2
a4619 2
    if (NIL_P(rb_errinfo)) {
	rb_raise(rb_eArgError, "$! not set");
d4621 1
a4621 1
    set_backtrace(rb_errinfo, val);
d4624 1
a4624 1
VALUE rb_f_global_variables();
d4627 2
a4628 2
static VALUE
rb_f_local_variables()
d4632 1
a4632 1
    VALUE ary = rb_ary_new();
d4635 1
a4635 1
    tbl = ruby_scope->local_tbl;
d4639 1
a4639 1
	    rb_ary_push(ary, rb_str_new2(rb_id2name(tbl[i])));
d4643 1
a4643 1
    vars = ruby_dyna_vars;
d4646 1
a4646 1
	    rb_ary_push(ary, rb_str_new2(rb_id2name(vars->id)));
d4654 2
a4655 2
static VALUE rb_f_catch _((VALUE,VALUE));
static VALUE rb_f_throw _((int,VALUE*)) NORETURN;
d4661 1
a4661 2
};
static struct end_proc_data *end_proc_data;
d4685 1
a4685 1
rb_f_END()
d4688 1
a4688 2
    ruby_frame->argc = 0;
    rb_set_end_proc(call_end_proc, rb_f_lambda());
d4693 1
a4693 1
rb_f_at_exit()
d4697 1
a4697 1
    proc = rb_f_lambda();
d4726 1
a4726 1
    rb_global_variable((VALUE*)&ruby_eval_tree_begin);
d4728 2
a4729 2
    rb_global_variable((VALUE*)&ruby_eval_tree);
    rb_global_variable((VALUE*)&ruby_dyna_vars);
d4732 1
a4732 1
    rb_define_hooked_variable("$!", &rb_errinfo, 0, errinfo_setter);
d4734 49
a4782 49
    rb_define_global_function("eval", rb_f_eval, -1);
    rb_define_global_function("iterator?", rb_f_iterator_p, 0);
    rb_define_global_function("method_missing", rb_f_missing, -1);
    rb_define_global_function("loop", rb_f_loop, 0);

    rb_define_method(rb_mKernel, "respond_to?", rb_obj_respond_to, -1);

    rb_define_global_function("raise", rb_f_raise, -1);
    rb_define_alias(rb_mKernel,  "fail", "raise");

    rb_define_global_function("caller", rb_f_caller, -1);

    rb_define_global_function("exit", rb_f_exit, -1);
    rb_define_global_function("abort", rb_f_abort, 0);

    rb_define_global_function("at_exit", rb_f_at_exit, 0);

    rb_define_global_function("catch", rb_f_catch, 1);
    rb_define_global_function("throw", rb_f_throw, -1);
    rb_define_global_function("global_variables", rb_f_global_variables, 0);
    rb_define_global_function("local_variables", rb_f_local_variables, 0);

    rb_define_method(rb_mKernel, "send", rb_f_send, -1);
    rb_define_method(rb_mKernel, "__send__", rb_f_send, -1);
    rb_define_method(rb_mKernel, "instance_eval", rb_obj_instance_eval, -1);

    rb_define_private_method(rb_cModule, "append_features", rb_mod_append_features, 1);
    rb_define_private_method(rb_cModule, "extend_object", rb_mod_extend_object, 1);
    rb_define_private_method(rb_cModule, "include", rb_mod_include, -1);
    rb_define_private_method(rb_cModule, "public", rb_mod_public, -1);
    rb_define_private_method(rb_cModule, "protected", rb_mod_protected, -1);
    rb_define_private_method(rb_cModule, "private", rb_mod_private, -1);
    rb_define_private_method(rb_cModule, "module_function", rb_mod_modfunc, -1);
    rb_define_method(rb_cModule, "method_defined?", rb_mod_method_defined, 1);
    rb_define_method(rb_cModule, "public_class_method", rb_mod_public_method, -1);
    rb_define_method(rb_cModule, "private_class_method", rb_mod_private_method, -1);
    rb_define_method(rb_cModule, "module_eval", rb_mod_module_eval, -1);
    rb_define_method(rb_cModule, "class_eval", rb_mod_module_eval, -1);

    rb_define_private_method(rb_cModule, "remove_method", rb_mod_remove_method, 1);
    rb_define_private_method(rb_cModule, "undef_method", rb_mod_undef_method, 1);
    rb_define_private_method(rb_cModule, "alias_method", rb_mod_alias_method, 2);

    rb_define_singleton_method(rb_cModule, "nesting", rb_mod_nesting, 0);
    rb_define_singleton_method(rb_cModule, "constants", rb_mod_s_constants, 0);

    rb_define_singleton_method(rb_top_self, "include", top_include, -1);
    rb_define_singleton_method(rb_top_self, "public", top_public, -1);
    rb_define_singleton_method(rb_top_self, "private", top_private, -1);
d4784 1
a4784 1
    rb_define_method(rb_mKernel, "extend", rb_obj_extend, -1);
d4786 2
a4787 2
    rb_define_global_function("trace_var", rb_f_trace_var, -1);
    rb_define_global_function("untrace_var", rb_f_untrace_var, -1);
d4794 1
a4794 1
VALUE rb_f_autoload();
d4799 1
a4799 1
    rb_load_path = rb_ary_new();
d4804 1
a4804 1
    rb_features = rb_ary_new();
d4807 3
a4809 3
    rb_define_global_function("load", rb_f_load, 1);
    rb_define_global_function("require", rb_f_require, 1);
    rb_define_global_function("autoload", rb_f_autoload, 2);
d4839 6
a4844 6
	rb_gc_mark_frame(&data->frame);
	rb_gc_mark(data->scope);
	rb_gc_mark(data->var);
	rb_gc_mark(data->body);
	rb_gc_mark(data->self);
	rb_gc_mark(data->d_vars);
d4904 1
a4904 1
rb_f_binding(self)
d4911 2
a4912 2
    bind = Data_Make_Struct(rb_cBinding,struct BLOCK,blk_mark,blk_free,data);
    *data = *ruby_block;
d4915 1
a4915 1
    data->orig_thread = rb_thread_current();
d4917 3
a4919 3
    data->iter = rb_f_iterator_p();
    if (ruby_frame->prev) {
	data->frame.last_func = ruby_frame->prev->last_func;
d4922 1
a4922 1
    MEMCPY(data->frame.argv, ruby_block->frame.argv, VALUE, data->frame.argc);
d4950 2
a4951 2
    if (!rb_iterator_p() && !rb_f_iterator_p()) {
	rb_raise(rb_eArgError, "tryed to create Procedure-Object out of iterator");
d4955 1
a4955 1
    *data = *ruby_block;
d4958 1
a4958 1
    data->orig_thread = rb_thread_current();
d4960 1
a4960 1
    data->iter = data->prev?Qtrue:Qfalse;
d4962 1
a4962 1
    MEMCPY(data->frame.argv, ruby_block->frame.argv, VALUE, data->frame.argc);
d4985 1
a4985 1
    rb_obj_call_init(proc);
d4991 1
a4991 1
rb_f_lambda()
d4993 1
a4993 1
    return proc_s_new(rb_cProc);
d5005 1
a5005 1
    if (data->orig_thread != rb_thread_current()) {
d5039 1
a5039 1
    ruby_frame->iter = ITER_CUR;
d5042 2
a5043 2
	if (rb_iterator_p()) {
	    ruby_block->frame.iter = ITER_CUR;
d5046 1
a5046 1
	    ruby_block->frame.iter = ITER_NOT;
d5067 1
a5067 1
	result = rb_yield_0(args, 0, 0);
d5072 1
a5072 1
    if (ruby_block->tag->dst == state) {
d5075 1
a5075 1
    POP_BLOCK2();
d5082 1
a5082 1
		rb_raise(rb_eLocalJumpError, "break from proc-closure");
d5085 1
a5085 1
		rb_raise(rb_eLocalJumpError, "retry from proc-closure");
d5088 1
a5088 1
		rb_raise(rb_eLocalJumpError, "return from proc-closure");
d5112 1
a5112 1
    if (rb_obj_is_kind_of(block, rb_cMethod)) {
d5115 3
a5117 3
    else if (!rb_obj_is_proc(block)) {
	rb_raise(rb_eTypeError, "wrong argument type %s (expected Proc)",
		 rb_class2name(CLASS_OF(block)));
d5126 1
a5126 1
    ruby_frame->iter = ITER_PRE;
d5149 1
a5149 1
    if (ruby_block->tag->dst == state) {
d5153 1
a5153 1
    POP_BLOCK2();
d5160 1
a5160 1
		rb_raise(rb_eLocalJumpError, "break from proc-closure");
d5163 1
a5163 1
		rb_raise(rb_eLocalJumpError, "retry from proc-closure");
d5166 1
a5166 1
		rb_raise(rb_eLocalJumpError, "return from proc-closure");
d5186 4
a5189 4
    rb_gc_mark(data->oklass);
    rb_gc_mark(data->klass);
    rb_gc_mark(data->recv);
    rb_gc_mark(data->body);
d5193 1
a5193 1
rb_obj_method(obj, vid)
d5216 1
a5216 1
    method = Data_Make_Struct(rb_cMethod, struct METHOD, bm_mark, free, data);
d5237 1
a5237 1
    PUSH_ITER(rb_iterator_p()?ITER_PRE:ITER_NOT);
d5253 1
a5253 1
    str = rb_str_new2("#<");
d5255 2
a5256 2
    rb_str_cat(str, s, strlen(s));
    rb_str_cat(str, ": ", 2);
d5258 2
a5259 2
    rb_str_cat(str, s, strlen(s));
    rb_str_cat(str, "#", 1);
d5261 2
a5262 2
    rb_str_cat(str, s, strlen(s));
    rb_str_cat(str, ">", 1);
d5275 1
a5275 1
    proc = rb_f_lambda();
d5302 2
a5303 2
    rb_eLocalJumpError = rb_define_class("LocalJumpError", rb_eStandardError);
    rb_eSysStackError = rb_define_class("SystemStackError", rb_eStandardError);
d5305 2
a5306 2
    rb_cProc = rb_define_class("Proc", rb_cObject);
    rb_define_singleton_method(rb_cProc, "new", proc_s_new, 0);
d5308 15
a5322 15
    rb_define_method(rb_cProc, "call", proc_call, -2);
    rb_define_global_function("proc", rb_f_lambda, 0);
    rb_define_global_function("lambda", rb_f_lambda, 0);
    rb_define_global_function("binding", rb_f_binding, 0);
    rb_cBinding = rb_define_class("Binding", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cMethod), "new");
    rb_define_method(rb_cBinding, "clone", bind_clone, 0);

    rb_cMethod = rb_define_class("Method", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cMethod), "new");
    rb_define_method(rb_cMethod, "call", method_call, -1);
    rb_define_method(rb_cMethod, "inspect", method_inspect, 0);
    rb_define_method(rb_cMethod, "to_s", method_inspect, 0);
    rb_define_method(rb_cMethod, "to_proc", method_proc, 0);
    rb_define_method(rb_mKernel, "method", rb_obj_method, 1);
d5327 1
a5327 1
static VALUE rb_eThreadError;
d5329 1
a5329 1
int rb_thread_pending = 0;
d5331 1
a5331 1
VALUE rb_cThread;
d5351 1
a5351 1
extern VALUE rb_last_status;
a5383 1
    struct BLOCK *cblock;
d5389 1
a5389 1
    int misc;			/* misc. states (vmode/rb_trap_immediate) */
d5394 1
a5394 1
    VALUE rb_errinfo;
d5438 1
a5438 1
rb_thread_mark(th)
d5444 9
a5452 9
    rb_gc_mark(th->result);
    rb_gc_mark(th->thread);
    if (th->join) rb_gc_mark(th->join->thread);

    rb_gc_mark(th->scope);
    rb_gc_mark(th->dyna_vars);
    rb_gc_mark(th->rb_errinfo);
    rb_gc_mark(th->last_line);
    rb_gc_mark(th->last_match);
d5457 1
a5457 1
	rb_gc_mark_locations(th->stk_ptr, th->stk_ptr+th->stk_len);
d5459 1
a5459 1
	rb_gc_mark_locations(th->stk_ptr+2, th->stk_ptr+th->stk_len+2);
d5466 1
a5466 1
	    rb_gc_mark_frame(frame);
d5474 1
a5474 1
	    rb_gc_mark_frame(&block->frame);
d5481 1
a5481 1
rb_gc_mark_threads()
d5487 1
a5487 1
	rb_thread_mark(th);
d5492 1
a5492 1
rb_thread_free(th)
d5501 1
a5501 1
rb_thread_check(data)
d5504 3
a5506 3
    if (TYPE(data) != T_DATA || RDATA(data)->dfree != rb_thread_free) {
	rb_raise(rb_eTypeError, "wrong argument type %s (expected Thread)",
		 rb_class2name(CLASS_OF(data)));
d5512 1
a5512 1
rb_thread_save_context(th)
d5519 2
a5520 2
    th->stk_pos = (rb_gc_stack_start<(VALUE*)&v)?rb_gc_stack_start
				                :rb_gc_stack_start - len;
d5529 7
a5535 8
    th->frame = ruby_frame;
    th->scope = ruby_scope;
    th->klass = ruby_class;
    th->dyna_vars = ruby_dyna_vars;
    th->block = ruby_block;
    th->cblock = ruby_calling_block;
    th->misc = scope_vmode | (rb_trap_immediate<<8);
    th->iter = ruby_iter;
d5537 4
a5540 4
    th->rb_errinfo = rb_errinfo;
    th->last_status = rb_last_status;
    th->last_line = rb_lastline_get();
    th->last_match = rb_backref_get();
d5544 2
a5545 2
    th->file = ruby_sourcefile;
    th->line = ruby_sourceline;
d5548 1
a5548 1
static void rb_thread_restore_context _((thread_t,int));
d5558 1
a5558 1
    rb_thread_restore_context(th, exit);
d5569 1
a5569 1
rb_thread_restore_context(th, exit)
d5577 1
a5577 1
    if (!th->stk_ptr) rb_bug("unsaved context");
d5579 1
a5579 1
    if (&v < rb_gc_stack_start) {
d5588 5
a5592 6
    ruby_frame = th->frame;
    ruby_scope = th->scope;
    ruby_class = th->klass;
    ruby_dyna_vars = th->dyna_vars;
    ruby_block = th->block;
    ruby_calling_block = th->cblock;
d5594 2
a5595 2
    rb_trap_immediate = th->misc>>8;
    ruby_iter = th->iter;
d5597 2
a5598 2
    rb_errinfo = th->rb_errinfo;
    rb_last_status = th->last_status;
d5602 2
a5603 2
    ruby_sourcefile = th->file;
    ruby_sourceline = th->line;
d5610 2
a5611 2
    rb_lastline_set(tmp->last_line);
    rb_backref_set(tmp->last_match);
d5628 4
a5631 4
	ruby_frame->last_func = 0;
	ruby_sourcefile = th_raise_file;
	ruby_sourceline = th_raise_line;
	rb_f_raise(th_raise_argc, th_raise_argv);
d5640 1
a5640 1
rb_thread_ready(th)
d5658 1
a5658 1
rb_thread_remove()
d5660 1
a5660 1
    rb_thread_ready(curr_thread);
d5667 1
a5667 1
rb_thread_dead(th)
d5674 1
a5674 1
rb_thread_deadlock()
d5678 4
a5681 4
    th_raise_argv[0] = rb_exc_new2(rb_eFatal, "Thread: deadlock");
    th_raise_file = ruby_sourcefile;
    th_raise_line = ruby_sourceline;
    rb_f_abort();
d5685 1
a5685 1
rb_thread_schedule()
d5692 1
a5692 1
    rb_thread_pending = 0;
d5712 1
a5712 1
	    if ((th->wait_for&WAIT_JOIN) && rb_thread_dead(th->join)) {
d5782 1
a5782 1
		    if (rb_trap_pending) rb_trap_exec();
d5809 2
a5810 2
	curr_thread->file = ruby_sourcefile;
	curr_thread->line = ruby_sourceline;
d5818 1
a5818 1
	rb_thread_deadlock();
d5826 1
a5826 1
	rb_thread_save_context(curr);
d5835 1
a5835 1
	rb_thread_restore_context(next, 1);
d5837 1
a5837 1
    rb_thread_restore_context(next, 0);
d5841 1
a5841 1
rb_thread_wait_fd(fd)
d5850 1
a5850 1
    rb_thread_schedule();
d5854 1
a5854 1
rb_thread_fd_writable(fd)
d5867 1
a5867 1
	rb_thread_schedule();
d5872 1
a5872 1
rb_thread_wait_for(time)
d5908 1
a5908 1
    rb_thread_schedule();
d5911 1
a5911 1
void rb_thread_sleep_forever _((void));
d5914 1
a5914 1
rb_thread_alone()
d5920 1
a5920 1
rb_thread_select(max, read, write, except, timeout)
d5932 1
a5932 1
	    rb_thread_sleep_forever();
d5935 1
a5935 1
	rb_thread_wait_for(*timeout);
d6002 1
a6002 1
        rb_thread_schedule();
d6008 1
a6008 1
rb_thread_join(dmy, thread)
d6012 1
a6012 1
    thread_t th = rb_thread_check(thread);
d6014 1
a6014 1
    if (rb_thread_dead(th)) return thread;
d6016 1
a6016 1
	rb_raise(rb_eThreadError, "Thread.join: deadlock");
d6021 1
a6021 1
    rb_thread_schedule();
d6027 1
a6027 1
rb_thread_current()
d6033 1
a6033 1
rb_thread_main()
d6039 1
a6039 1
rb_thread_wakeup(thread)
d6042 1
a6042 1
    thread_t th = rb_thread_check(thread);
d6044 2
a6045 3
    if (th->status == THREAD_KILLED)
	rb_raise(rb_eThreadError, "killed thread");
    rb_thread_ready(th);
d6051 1
a6051 1
rb_thread_run(thread)
d6054 2
a6055 2
    rb_thread_wakeup(thread);
    if (!rb_thread_critical) rb_thread_schedule();
d6061 1
a6061 1
rb_thread_kill(thread)
d6064 1
a6064 1
    thread_t th = rb_thread_check(thread);
d6070 1
a6070 1
    rb_thread_ready(th);
d6072 1
a6072 1
    rb_thread_schedule();
d6077 1
a6077 1
rb_thread_s_kill(obj, th)
d6080 1
a6080 1
    return rb_thread_kill(th);
d6084 1
a6084 1
rb_thread_exit()
d6086 1
a6086 1
    return rb_thread_kill(curr_thread->thread);
d6090 1
a6090 1
rb_thread_pass()
d6092 1
a6092 1
    rb_thread_schedule();
d6097 1
a6097 1
rb_thread_stop()
d6099 1
a6099 1
    rb_thread_critical = 0;
d6102 1
a6102 1
	rb_raise(rb_eThreadError, "stopping only thread");
d6104 1
a6104 1
    rb_thread_schedule();
d6109 1
a6109 1
struct timeval rb_time_timeval();
d6112 1
a6112 1
rb_thread_sleep(sec)
d6121 1
a6121 1
    rb_thread_wait_for(rb_time_timeval(INT2FIX(sec)));
d6125 1
a6125 1
rb_thread_sleep_forever()
d6138 1
a6138 1
    rb_thread_schedule();
d6141 1
a6141 1
static int rb_thread_abort;
d6144 1
a6144 1
rb_thread_s_abort_exc()
d6146 1
a6146 1
    return rb_thread_abort?Qtrue:Qfalse;
d6150 1
a6150 1
rb_thread_s_abort_exc_set(self, val)
d6153 1
a6153 1
    rb_thread_abort = RTEST(val);
d6158 1
a6158 1
rb_thread_abort_exc(thread)
d6161 1
a6161 1
    thread_t th = rb_thread_check(thread);
d6163 1
a6163 1
    return th->abort?Qtrue:Qfalse;
d6167 1
a6167 1
rb_thread_abort_exc_set(thread, val)
d6170 1
a6170 1
    thread_t th = rb_thread_check(thread);
d6177 1
a6177 1
rb_thread_alloc()
d6186 1
a6186 1
    th->rb_errinfo = Qnil;
d6203 1
a6203 1
    th->rb_errinfo = 0;
d6209 1
a6209 1
    th->thread = Data_Wrap_Struct(rb_cThread, 0, rb_thread_free, th);
d6233 3
a6235 3
    if (!rb_thread_critical) {
	if (rb_trap_immediate) {
	    rb_thread_schedule();
d6237 1
a6237 1
	else rb_thread_pending = 1;
d6241 1
a6241 1
int thread_tick = rb_THREAD_TICK;
d6244 1
a6244 3
static VALUE rb_thread_raise _((int, VALUE*, VALUE));

#define SCOPE_SHARED  FL_USER1
d6247 1
a6247 1
rb_thread_create(fn, arg)
d6251 1
a6251 1
    thread_t th = rb_thread_alloc();
d6276 1
a6276 2
    FL_SET(ruby_scope, SCOPE_SHARED);
    rb_thread_save_context(curr_thread);
d6283 1
a6283 1
	rb_thread_save_context(th);
d6290 2
a6291 2
    rb_thread_remove();
    if (state && th->status != THREAD_TO_KILL && !NIL_P(rb_errinfo)) {
d6294 2
a6295 2
	    main_thread->rb_errinfo = rb_errinfo;
	    rb_thread_cleanup();
d6297 1
a6297 1
	else if (rb_obj_is_kind_of(rb_errinfo, rb_eSystemExit)) {
d6299 1
a6299 1
	    rb_thread_raise(1, &rb_errinfo, main_thread->thread);
d6301 2
a6302 2
	else if (rb_thread_abort || curr_thread->abort || RTEST(rb_debug)) {
	    VALUE err = rb_exc_new(rb_eSystemExit, 0, 0);
d6305 1
a6305 1
	    rb_thread_raise(1, &err, main_thread->thread);
d6308 1
a6308 1
	    curr_thread->rb_errinfo = rb_errinfo;
d6311 1
a6311 1
    rb_thread_schedule();
a6314 6
int
rb_thread_scope_shared_p()
{
    return FL_TEST(ruby_scope, SCOPE_SHARED);
}

d6316 1
a6316 1
rb_thread_yield(arg, th) 
d6320 2
a6321 2
    scope_dup(ruby_block->scope);
    return rb_yield_0(th->thread, 0, 0);
d6325 1
a6325 1
rb_thread_start()
d6327 2
a6328 2
    if (!rb_iterator_p()) {
	rb_raise(rb_eThreadError, "must be called as iterator");
d6330 1
a6330 1
    return rb_thread_create(rb_thread_yield, 0);
d6334 1
a6334 1
rb_thread_value(thread)
d6337 1
a6337 1
    thread_t th = rb_thread_check(thread);
d6339 3
a6341 3
    rb_thread_join(0, thread);
    if (!NIL_P(th->rb_errinfo)) {
	VALUE oldbt = get_backtrace(th->rb_errinfo);
d6344 3
a6346 3
	rb_ary_unshift(errat, rb_ary_entry(oldbt, 0));
	set_backtrace(th->rb_errinfo, errat);
	rb_exc_raise(th->rb_errinfo);
d6353 1
a6353 1
rb_thread_status(thread)
d6356 1
a6356 1
    thread_t th = rb_thread_check(thread);
d6358 2
a6359 2
    if (rb_thread_dead(th)) {
	if (NIL_P(th->rb_errinfo)) return Qfalse;
d6363 1
a6363 1
    return Qtrue;
d6367 1
a6367 1
rb_thread_stop_p(thread)
d6370 1
a6370 1
    thread_t th = rb_thread_check(thread);
d6372 3
a6374 3
    if (rb_thread_dead(th)) return Qtrue;
    if (th->status == THREAD_STOPPED) return Qtrue;
    return Qfalse;
d6378 1
a6378 1
rb_thread_wait_other_threads()
d6382 1
a6382 1
	rb_thread_schedule();
d6387 1
a6387 1
rb_thread_cleanup()
d6404 1
a6404 1
int rb_thread_critical;
d6407 1
a6407 1
rb_thread_get_critical()
d6409 1
a6409 1
    return rb_thread_critical?Qtrue:Qfalse;
d6413 1
a6413 1
rb_thread_set_critical(obj, val)
d6416 1
a6416 1
    rb_thread_critical = RTEST(val);
d6421 1
a6421 1
rb_thread_interrupt()
d6423 2
a6424 2
    rb_thread_critical = 0;
    rb_thread_ready(main_thread);
d6428 1
a6428 1
    rb_thread_save_context(curr_thread);
d6433 1
a6433 1
    rb_thread_restore_context(curr_thread, 2);
d6437 1
a6437 1
rb_thread_trap_eval(cmd, sig)
d6441 3
a6443 3
    rb_thread_critical = 0;
    if (!rb_thread_dead(curr_thread)) {
	rb_thread_ready(curr_thread);
d6447 2
a6448 2
    rb_thread_ready(main_thread);
    rb_thread_save_context(curr_thread);
d6455 1
a6455 1
    rb_thread_restore_context(curr_thread, 3);
d6459 1
a6459 1
rb_thread_raise(argc, argv, thread)
d6464 1
a6464 1
    thread_t th = rb_thread_check(thread);
d6466 1
a6466 1
    if (rb_thread_dead(th)) return thread;
d6468 1
a6468 1
	rb_f_raise(argc, argv);
d6472 1
a6472 1
	rb_thread_save_context(curr_thread);
d6478 1
a6478 1
    rb_thread_ready(th);
d6482 3
a6484 3
    th_raise_file = ruby_sourcefile;
    th_raise_line = ruby_sourceline;
    rb_thread_restore_context(curr_thread, 4);
d6492 1
a6492 1
rb_thread_loading(feature)
d6497 1
a6497 1
	    rb_thread_schedule();
d6500 1
a6500 1
	if (rb_provided(feature)) return Qtrue; /* no need to load */
d6506 1
a6506 1
    return Qfalse;
d6510 1
a6510 1
rb_thread_loading_done()
d6520 2
a6521 2
    rb_eThreadError = rb_define_class("ThreadError", rb_eStandardError);
    rb_cThread = rb_define_class("Thread", rb_cObject);
d6523 26
a6548 26
    rb_define_singleton_method(rb_cThread, "new", rb_thread_start, 0);
    rb_define_singleton_method(rb_cThread, "start", rb_thread_start, 0);
    rb_define_singleton_method(rb_cThread, "fork", rb_thread_start, 0);

    rb_define_singleton_method(rb_cThread, "stop", rb_thread_stop, 0);
    rb_define_singleton_method(rb_cThread, "kill", rb_thread_s_kill, 1);
    rb_define_singleton_method(rb_cThread, "exit", rb_thread_exit, 0);
    rb_define_singleton_method(rb_cThread, "pass", rb_thread_pass, 0);
    rb_define_singleton_method(rb_cThread, "join", rb_thread_join, 1);
    rb_define_singleton_method(rb_cThread, "current", rb_thread_current, 0);
    rb_define_singleton_method(rb_cThread, "main", rb_thread_main, 0);

    rb_define_singleton_method(rb_cThread, "critical", rb_thread_get_critical, 0);
    rb_define_singleton_method(rb_cThread, "critical=", rb_thread_set_critical, 1);

    rb_define_singleton_method(rb_cThread, "abort_on_exception", rb_thread_s_abort_exc, 0);
    rb_define_singleton_method(rb_cThread, "abort_on_exception=", rb_thread_s_abort_exc_set, 1);

    rb_define_method(rb_cThread, "run", rb_thread_run, 0);
    rb_define_method(rb_cThread, "wakeup", rb_thread_wakeup, 0);
    rb_define_method(rb_cThread, "exit", rb_thread_kill, 0);
    rb_define_method(rb_cThread, "value", rb_thread_value, 0);
    rb_define_method(rb_cThread, "status", rb_thread_status, 0);
    rb_define_method(rb_cThread, "alive?", rb_thread_status, 0);
    rb_define_method(rb_cThread, "stop?", rb_thread_stop_p, 0);
    rb_define_method(rb_cThread, "raise", rb_thread_raise, -1);
d6550 2
a6551 2
    rb_define_method(rb_cThread, "abort_on_exception", rb_thread_abort_exc, 0);
    rb_define_method(rb_cThread, "abort_on_exception=", rb_thread_abort_exc_set, 1);
d6554 1
a6554 1
    main_thread = rb_thread_alloc();
d6559 1
a6559 1
rb_f_catch(dmy, tag)
d6569 1
a6569 1
	val = rb_yield_0(tag, 0, 0);
d6585 1
a6585 1
    return rb_f_catch(0, FIX2INT(tag));
d6597 3
d6601 1
a6601 1
rb_f_throw(argc, argv)
d6619 3
a6621 3
	    rb_raise(rb_eThreadError, "uncaught throw `%s' in thread 0x%x",
		     rb_id2name(t),
		     curr_thread);
d6627 1
a6627 1
	rb_raise(rb_eNameError, "uncaught throw `%s'", rb_id2name(t));
d6630 1
a6630 1
    rb_trap_restore_mask();
d6645 1
a6645 1
    rb_f_throw(2, argv);
d6659 2
a6660 2
	    rb_raise(rb_eThreadError, "return from within thread 0x%x",
		     curr_thread);
@


1.1.1.2.2.79.2.2
log
@join 1.1c6
@
text
@d6 1
a6 1
  $Date: 1998/09/08 09:17:32 $
d73 3
a75 3
#define CACHE_SIZE 0x800
#define CACHE_MASK 0x7ff
#define EXPR1(c,m) ((((long)(c)>>4)^(m))&CACHE_MASK)
a99 16
static int cache_conflict;

static int
count_cent()
{
    struct cache_entry *ent, *end;
    int n = 0;

    ent = cache; end = ent + CACHE_SIZE;
    while (ent < end) {
	if (ent->mid != 0) n++;
	ent++;
    }
    return n;
}

a124 3
    if (klass == rb_cObject) {
	rb_secure(4);
    }
a193 3
    if (klass == rb_cObject) {
	rb_secure(4);
    }
a221 3
    if (klass == rb_cObject) {
	rb_secure(4);
    }
a285 3
    if (klass == rb_cObject) {
	rb_secure(4);
    }
d382 2
a383 2
    _frame.file = ruby_sourcefile;	\
    _frame.line = ruby_sourceline;	\
a385 1
    _frame.argc = 0;			\
d401 1
a401 1
#ifdef USE_THREAD
d626 1
a626 1
            rb_gc_force_recycle((VALUE)ruby_scope);\
d650 1
a650 1
   2 - process/file operations prohibited
d652 2
a653 1
   4 - no global variable modification/no direct output
d716 1
a716 1
		 rb_id2name(ruby_frame->last_func), safe_level);
d921 1
a921 1
#ifdef USE_THREAD
d955 1
a955 1
#ifdef USE_THREAD
a960 1
	fprintf(stderr, "%d/%d(%d)\n", count_cent(), CACHE_SIZE, cache_conflict);
d1256 1
a1256 1
#if defined(C_ALLOCA) && defined(USE_THREAD)
d1551 1
a1551 1
#ifdef USE_THREAD
d1581 1
a1581 1
#ifdef USE_THREAD
d1652 1
a1652 1
	while (!NIL_P(rb_gets())) {
d2385 2
a2386 7
		if (origin == ruby_class) {
		    if (safe_level >= 3) {
			rb_raise(rb_eSecurityError, "re-defining method prohibited");
		    }
		    if (rb_verbose) {
			rb_warning("discarding old %s", rb_id2name(node->nd_mid));
		    }
d2444 3
a2446 7
	    if (st_lookup(RCLASS(klass)->m_tbl, node->nd_mid, &body)) {
		if (safe_level >= 3) {
		    rb_raise(rb_eSecurityError, "re-defining method prohibited");
		}
		if (rb_verbose) {
		    rb_warning("redefine %s", rb_id2name(node->nd_mid));
		}
a2464 3
	    if (ruby_class == rb_cObject) {
		rb_secure(4);
	    }
d2760 2
a2761 2
static void
rb_abort()
d2763 1
a2770 7
static VALUE
rb_f_abort()
{
    rb_secure(2);
    rb_abort();
}

a2812 3
    if (!prot_tag) {
	error_print();
    }
d3527 1
a3528 1
	    PUSH_TAG(PROT_FUNC);
d3601 1
a3602 1
	    POP_VARS();
d3662 1
a3662 2
    else { if (ent->mid) cache_conflict++;
    if ((body = rb_get_method_body(&klass, &id, &noex)) == 0) {
d3668 1
a3668 1
    }}
a4055 1
    Check_SafeStr(src);
a4073 1
    rb_secure(3);
a4189 3
	if (safe_level >= 2) {
	    rb_path_check(path);
	}
d4198 3
a4200 3
void
rb_load(fname, priv)
    VALUE fname, priv;
d4222 1
a4222 21
    if (priv == 0 || NIL_P(priv)) {
	rb_secure(4);		/* should alter global state */
	ruby_class = rb_cObject;
    }
    else {
	switch (TYPE(priv)) {
	  case T_MODULE:
	  case T_CLASS:
	    break;
	    rb_secure(4);	/* should alter global state */
	    ruby_class = priv;
	  default:
	    /* load in anonymous module as toplevel */
	    ruby_class = rb_module_new();
	    break;
	}
    }
    PUSH_FRAME();
    ruby_frame->last_func = 0;
    ruby_frame->self = rb_top_self;
    ruby_frame->cbase = (VALUE)rb_node_newnode(NODE_CREF,ruby_class,0,0);
d4224 1
a4224 1
    if (ruby_class == rb_cObject && top_scope->local_tbl) {
d4231 2
a4232 2
	ruby_scope->local_tbl = tbl;   /* copy toplevel scope */
	ruby_scope->local_vars = vars; /* will not alter toplevel variables */
d4239 1
d4249 2
a4250 3
    if (ruby_scope->flag == SCOPE_ALLOCA && ruby_class == rb_cObject) {
	if (ruby_scope->local_tbl) /* toplevel was empty */
	    free(ruby_scope->local_tbl);
a4252 1
    POP_FRAME();
a4259 1
}
a4260 9
static VALUE
rb_f_load(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE fname, priv;

    rb_scan_args(argc, argv, "11", &fname, &priv);
    rb_load(fname, priv);
d4289 1
a4289 1
#ifdef USE_THREAD
a4319 1
    rb_secure(4);
d4368 1
a4368 2
    rb_secure(2);
#ifdef USE_THREAD
d4379 1
a4379 1
#ifdef USE_THREAD
d4389 1
a4389 1
#ifdef USE_THREAD
d4396 1
a4396 1
	    rb_load(fname, 0);
d4398 1
a4398 1
#ifdef USE_THREAD
d4848 1
a4848 1
    rb_define_global_function("load", rb_f_load, -1);
d4955 1
a4955 1
#ifdef USE_THREAD
d4998 1
a4998 1
#ifdef USE_THREAD
d5045 1
a5045 1
#ifdef USE_THREAD
d5366 1
a5366 1
#ifdef USE_THREAD
d5443 1
a5443 1
    enum thread_status status;
d5725 1
a5725 1
    rb_abort();
d6052 2
a6053 1
rb_thread_join(thread)
a6070 9
rb_thread_s_join(dmy, thread)	/* will be removed in 1.2 */
    VALUE dmy;
    VALUE thread;
{
    rb_warn("Thread.join is obsolete; use Thread#join instead");
    return rb_thread_join(thread);
}

static VALUE
d6222 1
a6222 2
rb_thread_alloc(klass)
    VALUE klass;
d6254 1
a6254 1
    th->thread = Data_Wrap_Struct(klass, 0, rb_thread_free, th);
d6293 2
a6294 2
static VALUE
rb_thread_create_0(fn, arg, klass)
a6296 1
    VALUE klass;
d6298 1
a6298 2
    thread_t th = rb_thread_alloc(klass);
    enum thread_status status;
a6337 1
    status = th->status;
d6339 1
a6339 1
    if (state && status != THREAD_TO_KILL && !NIL_P(rb_errinfo)) {
a6362 8
VALUE
rb_thread_create(fn, arg)
    VALUE (*fn)();
    void *arg;
{
    return rb_thread_create_0(fn, arg, rb_cThread);
}

d6379 1
a6379 2
rb_thread_start(klass)
    VALUE klass;
d6384 1
a6384 1
    return rb_thread_create_0(rb_thread_yield, 0, klass);
d6393 1
a6393 1
    rb_thread_join(thread);
d6585 1
a6585 1
    rb_define_singleton_method(rb_cThread, "join", rb_thread_s_join, 1);
a6599 1
    rb_define_method(rb_cThread, "join", rb_thread_join, 0);
d6608 1
a6608 1
    main_thread = rb_thread_alloc(rb_cThread);
d6668 1
a6668 1
#ifdef USE_THREAD
d6702 1
a6702 1
#ifdef USE_THREAD
@


1.1.1.2.2.79.2.3
log
@*** empty log message ***
@
text
@d6 1
a6 1
  $Date: 1998/11/17 09:12:30 $
d75 1
a75 1
#define EXPR1(c,m) ((((c)>>3)^(m))&CACHE_MASK)
a100 1
static int eval_called;
d106 1
a106 2
    int n = 0, n2 = 0;
    int p = 0;
a107 1
    fprintf(stderr, "\n|");
d110 1
a110 16
	fprintf(stderr, (ent->klass != 0)?"*":" ");
	p++;
	if (p % 80 == 0) {
	    break;
	}
	ent++;
    }
    fprintf(stderr, "|\n|");
    p = 0; ent = cache; 
    while (ent < end) {
	if (ent->klass != 0) {n++; n2++;}
	p++;
	if (p % 24 == 0) {
	    fprintf(stderr, "%c", n2?(n2+'0'):' ');
	    n2 = 0;
	}
a112 1
    fprintf(stderr, "|\n");
a428 1
    int used;
d446 2
a447 2
    _block.frame.file = ruby_sourcefile;\
    _block.frame.line = ruby_sourceline;\
a452 1
    _block.used = 0;			\
a508 13
static int
dvar_len()
{
    struct RVarmap *vars = ruby_dyna_vars;
    int n = 0;

    while (vars) {
	n++;
	vars = vars->next;
    }
    return n;
}

d555 1
a555 1
    rb_dvar_asgn(id, value);
d681 1
a681 1
   4 - no global (non-tainted) variable modification/no direct output
d726 1
a726 1
    if (rb_obj_tainted(x)) {
d731 4
a988 1
#if 1
a989 3
#else
	fprintf(stderr, "rb_eval() called %d times\n", eval_called);
#endif
d1084 1
d1095 2
a1096 2
    if (rb_obj_tainted(cmd)) {
	safe_level = 4;
a1628 4
#ifdef NOBLOCK_RECUR
    NODE * volatile next = 0;
    NODE * volatile nstack = 0;
#endif
a1631 2
    eval_called++;

a1636 5
#ifndef NOBLOCK_RECUR
	if (!node->nd_next) {
	    node = node->nd_head;
	    goto again;
	}
d1642 1
a1642 8
#else
	if (next) {
	    nstack = rb_node_newnode(NODE_CREF,next,0,nstack);
	}
	next = node->nd_next;
	node = node->nd_head;
	goto again;
#endif
a1699 3
#ifdef NOBLOCK_RECUR
	if (RTEST(result)){
#else
a1700 1
#endif
a1711 3
#ifdef NOBLOCK_RECUR
	    val = result;
#else
a1712 1
#endif
d1728 1
a1728 15
		    if (nd_type(tag->nd_head) == NODE_WHEN) {
			VALUE v = rb_eval(self, tag->nd_head->nd_head);
			int i;

			if (TYPE(v) != T_ARRAY) v = rb_Array(v);
			for (i=0; i<RARRAY(v)->len; i++) {
			    if (RTEST(rb_funcall2(RARRAY(v)->ptr[i], eqq, 1, &val))){
				node = node->nd_body;
				goto again;
			    }
			}
			tag = tag->nd_next;
			continue;
		    }
		    if (RTEST(rb_funcall2(rb_eval(self, tag->nd_head), eqq, 1, &val))) {
a1837 5
	    if (rb_verbose && !ruby_block->used) {
		ruby_sourcefile = node->nd_file;
		ruby_sourceline = nd_line(node);
		rb_warn("unused block");
	    }
a1873 7
      case NODE_RESTARGS:
	result = rb_eval(self, node->nd_head);
	if (TYPE(result) != T_ARRAY) {
	    result = rb_Array(result);
	}
	break;

d1875 1
a1875 5
	result = rb_eval(self, node->nd_stts);
	if (nd_type(node->nd_stts) == NODE_RESTARGS && RARRAY(result)->len == 1) {
	    result = RARRAY(result)->ptr[0];
	}
	result = rb_yield_0(result, 0, 0);
a1911 3
	    if (node->nd_else) { /* no exception raised, else clause given */
		result = rb_eval(self, node->nd_else);
	    }
d1949 1
a1949 17
	result = rb_range_new(rb_eval(self, node->nd_beg), rb_eval(self, node->nd_end));
#if 0
	break;
#else
	result = rb_range_new(rb_eval(self, node->nd_beg), rb_eval(self, node->nd_end));
	if (node->nd_state) break;
	if (nd_type(node->nd_beg) == NODE_LIT && FIXNUM_P(node->nd_beg->nd_lit) &&
	    nd_type(node->nd_end) == NODE_LIT && FIXNUM_P(node->nd_end->nd_lit))
	{
	    nd_set_type(node, NODE_LIT);
	    node->nd_lit = result;
	}
	else {
	    node->nd_state = 1;
	}
#endif
	break;
d1952 1
a1952 4
	if (ruby_scope->local_vars == 0) {
	    rb_bug("unexpected local variable");
	}
	if (!RTEST(ruby_scope->local_vars[node->nd_cnt])) {
d1954 1
a1954 2
		ruby_scope->local_vars[node->nd_cnt] = 
		    RTEST(rb_eval(self, node->nd_end))?Qfalse:Qtrue;
d1963 1
a1963 1
		ruby_scope->local_vars[node->nd_cnt] = Qfalse;
d1970 6
a1975 6
	if (ruby_scope->local_vars == 0) {
	    rb_bug("unexpected local variable");
	}
	if (!RTEST(ruby_scope->local_vars[node->nd_cnt])) {
	    result = RTEST(rb_eval(self, node->nd_beg));
	    ruby_scope->local_vars[node->nd_cnt] = result;
d1979 1
a1979 1
		ruby_scope->local_vars[node->nd_cnt] = Qfalse;
a1992 5
      case NODE_ARGSCAT:
	result = rb_ary_concat(rb_eval(self, node->nd_head),
			       rb_eval(self, node->nd_body));
	break;

a1999 5
#ifdef NOBLOCK_RECUR_incomplete
	    printf("mid %s recv: ", rb_id2name(node->nd_mid));
	    rb_p(result);
	    recv = result;
#else
a2000 1
#endif
d2072 1
a2072 1
		result = rb_eval(self, node->nd_next);
d2170 7
a2176 2
	result = rb_eval(self, node->nd_value);
	rb_gvar_set(node->nd_entry, result);
d2180 7
a2186 2
	result = rb_eval(self, node->nd_value);
	rb_ivar_set(self, node->nd_vid, result);
d2190 14
a2203 10
	if (NIL_P(ruby_class)) {
	    rb_raise(rb_eTypeError, "no class/module to define constant");
	}
	result = rb_eval(self, node->nd_value);
	/* check for static scope constants */
	if (RTEST(rb_verbose) &&
	    ev_const_defined((NODE*)ruby_frame->cbase, node->nd_vid)) {
	    if (rb_verbose) {
		rb_warning("already initialized constant %s",
			   rb_id2name(node->nd_vid));
d2205 2
a2207 1
	rb_const_set(ruby_class, node->nd_vid, result);
a2360 1
		    if (rb_obj_tainted(str2)) rb_obj_taint(str);
a2476 3
	    if (rb_safe_level() >= 4 && !FL_TEST(recv, FL_TAINT)) {
		rb_raise(rb_eSecurityError, "can't define singleton method");
	    }
d2593 1
a2593 1
	    result = rb_module_setup(klass, node->nd_body);
a2675 12
#ifdef NOBLOCK_RECUR
    if (next) {
	node = next;
	next = 0;
	goto again;
    }
    if (nstack) {
	node = nstack->nd_head;
	nstack = nstack->nd_next;
	goto again;
    }
#endif
d2718 1
a2718 1
	result = rb_eval(ruby_class, node->nd_next);
d2790 1
a2790 1
    rb_secure(4);
d2814 1
a2814 1
    rb_secure(4);
d2953 1
a2953 1
    if (!ruby_frame->iter || !ruby_block) {
a2956 1
    ruby_block->used = 1;
d3115 1
a3115 1
		rb_call(CLASS_OF(recv), recv, lhs->nd_mid, 1, &val, 0);
d3123 1
a3123 2
		rb_call(CLASS_OF(recv), recv, lhs->nd_mid,
			RARRAY(args)->len, RARRAY(args)->ptr, 0);
d3503 1
a3503 1
    if ((++tick & 0x3ff) == 0 && stack_length() > STACK_LEVEL_MAX)
d3575 1
a3575 1
	    b2 = body = body->nd_next;
d3712 1
a3712 8
    else {
    if (ent->mid) {
	fprintf(stderr, "%s#%s -> %s#%s (%d)\n", rb_class2name(ent->klass),
		                                 rb_id2name(ent->mid),
		                                 rb_class2name(klass),
		                                 rb_id2name(id), ent-cache);
	cache_conflict++;
    }
d3719 1
a3719 2
    }
    }
d3914 1
a3914 1
    node = rb_compile_string(place, src);
d4126 1
a4126 1
    rb_secure(4);
a4262 1
    rb_secure(4);
d4456 1
a4766 1
	    if (tbl[i] == 0) continue;  /* skip flip states */
d4872 1
a4872 1
    rb_define_global_function("fail", rb_f_raise, -1);
a4974 1
	rb_gc_mark(data->klass);
d5067 1
a5072 38
static void
proc_save_safe_level(data)
    VALUE data;
{
    if (FL_TEST(data, FL_TAINT)) {
	switch (safe_level) {
	  case 3:
	    FL_SET(data, PROC_T3);
	    break;
	  case 4:
	    FL_SET(data, PROC_T4);
	    break;
	  case 5:
	    FL_SET(data, PROC_T5);
	    break;
	}
    }
}

static void
proc_set_safe_level(data)
    VALUE data;
{
    if (FL_TEST(data, FL_TAINT)) {
	switch (RBASIC(data)->flags & PROC_TMASK) {
	  case PROC_T3:
	    safe_level = 3;
	    break;
	  case PROC_T4:
	    safe_level = 4;
	    break;
	  case PROC_T5:
	    safe_level = 5;
	    break;
	}
    }
}

d5081 1
a5081 1
	rb_raise(rb_eArgError, "tried to create Procedure-Object out of iterator");
a5083 1
    ruby_block->used = 1;
d5101 14
a5114 1
    proc_save_safe_level(proc);
a5145 1
    struct BLOCK * volatile old_block;
d5167 1
a5167 2
    old_block = ruby_block;
    ruby_block = data;
d5180 14
a5196 1
	proc_set_safe_level(proc);
d5205 1
a5205 1
    ruby_block = old_block;
a5232 1
    struct BLOCK * volatile old_block;
d5254 1
a5254 2
    old_block = ruby_block;
    ruby_block = data;
d5257 13
a5273 1
	proc_set_safe_level(block);
d5277 1
d5283 1
a5283 1
    ruby_block = old_block;
a5352 3
    if (FL_TEST(obj, FL_TAINT)) {
	FL_SET(method, FL_TAINT);
    }
a5364 2
    int state;
    volatile int safe = safe_level;
d5368 2
a5369 10
    PUSH_TAG(PROT_NONE);
    if (FL_TEST(data->recv, FL_TAINT)) {
	FL_SET(method, FL_TAINT);
	if (safe_level < 4) safe_level = 4;
    }
    if ((state = EXEC_TAG()) == 0) {
	result = rb_call0(data->klass, data->recv, data->id,
			  argc, argv, data->body, 0);
    }
    POP_TAG();
a5370 2
    safe_level = safe;
    if (state) JUMP_TAG(state);
d5569 1
a5569 1
thread_mark(th)
a5585 1
    if (th->status == THREAD_KILLED) return;
d5618 1
a5618 1
	rb_gc_mark(th->thread);
d5623 1
a5623 1
thread_free(th)
d5635 1
a5635 1
    if (TYPE(data) != T_DATA || RDATA(data)->dfree != thread_free) {
d6352 1
a6352 1
    th->thread = Data_Wrap_Struct(klass, thread_mark, thread_free, th);
@


1.1.1.2.2.79.2.4
log
@first public release of 1.1d (pre1.2) series
@
text
@d6 1
a6 1
  $Date: 1998/12/14 09:00:05 $
d100 35
d436 1
a436 4
#define POP_FRAME()  			\
    ruby_sourcefile = _frame.file;	\
    ruby_sourceline = _frame.line;	\
    ruby_frame = _frame.prev; }
d876 1
a876 3
	    if (TYPE(ep->ptr[i]) == T_STRING) {
		fprintf(stderr, "\tfrom %s\n", RSTRING(ep->ptr[i])->ptr);
	    }
d1019 5
d1669 2
d3033 4
a3036 1
	if (n == 1 && TYPE(mesg) == T_STRING) {
a3038 3
	else if (n == 1 || n == 2) {
	    mesg = rb_funcall(etype, rb_intern("new"), n-1, mesg);
	}
d3838 9
a3846 1
    else if ((body = rb_get_method_body(&klass, &id, &noex)) == 0) {
d3853 1
d4540 1
a4540 1
    volatile VALUE load;
d5513 1
a5513 1
    if (FL_TEST(data->recv, FL_TAINT) || FL_TEST(method, FL_TAINT)) {
a6545 28
#if defined(HAVE_SETITIMER) && !defined(__BOW__)
static int thread_init = 0;

void
thread_start_timer()
{
    struct itimerval tval;

    if (!thread_init) return;
    tval.it_interval.tv_sec = 0;
    tval.it_interval.tv_usec = 100000;
    tval.it_value = tval.it_interval;
    setitimer(ITIMER_VIRTUAL, &tval, NULL);
}

void
thread_stop_timer()
{
    struct itimerval tval;

    if (!thread_init) return;
    tval.it_interval.tv_sec = 0;
    tval.it_interval.tv_usec = 0;
    tval.it_value = tval.it_interval;
    setitimer(ITIMER_VIRTUAL, &tval, NULL);
}
#endif

d6557 5
a6561 1
    if (!thread_init) {
d6570 5
a6574 2
	thread_init = 1;
	thread_start_timer();
@


1.1.1.2.2.79.2.5
log
@1.1d1
@
text
@d6 1
a6 1
  $Date: 1998/12/16 07:30:29 $
d48 6
a858 1
char **rb_origenviron;
a874 6
#ifdef __MACOS__
    rb_origenviron = 0;
#else
    rb_origenviron = environ;
#endif

d1284 4
a1287 4
# define TMP_PROTECT NODE * volatile __protect_tmp=0
# define TMP_ALLOC(type,n) \
    (__protect_tmp = rb_node_newnode(NODE_ALLOCA,\
			     rb_str_new(0,sizeof(type)*(n)),0,__protect_tmp),\
d1923 3
a1925 10
	if (node->nd_stts) {
	    result = rb_eval(self, node->nd_stts);
	    if (nd_type(node->nd_stts) == NODE_RESTARGS &&
		RARRAY(result)->len == 1)
	    {
		result = RARRAY(result)->ptr[0];
	    }
	}
	else {
	    result = Qnil;
d4218 1
a4218 1
VALUE
d4310 1
a4321 1
	volatile VALUE vpath;
d4331 2
a4332 2
	if (safe_level >= 2 && !rb_path_check(path)) {
	    rb_raise(rb_eSecurityError, "loading from unsefe path %s", vpath);
d4457 1
a4457 1
	    && (strcmp(f+len, ".rb") == 0 ||strcmp(f+len, ".so") == 0)) {
d4478 2
a4479 2
	if (ext && strcmp(DLEXT, ext) == 0) {
	    buf = ALLOCA_N(char, strlen(feature)+4);
d4482 1
a4482 1
	    strcpy(ext, ".so");
d4508 1
a4508 1
	else if (strcmp(".so", ext) == 0 || strcmp(".o", ext) == 0) {
d4510 1
a4510 1
	    if (strcmp(ext, DLEXT) != 0) {
d4515 1
a4515 1
		file = buf;
a4516 1
	    file = find_file(file);
d6493 1
a6493 1
int rb_thread_tick = THREAD_TICK;
@
