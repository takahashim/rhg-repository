head	1.74;
access;
symbols
	v1_6_7:1.38.2.24
	v1_6_6:1.38.2.20
	v1_6_5:1.38.2.17
	v1_6_4:1.38.2.7
	v1_7_1:1.41
	v1_6_4_preview4:1.38.2.4
	v1_6_4_preview3:1.38.2.4
	v1_6_4_preview2:1.38.2.3
	v1_6_4_preview1:1.38.2.1
	v1_6_3:1.38.2.1
	ruby_m17n:1.38.0.4
	ruby_1_6:1.38.0.2
	v1_6_2:1.38
	v1_6_1:1.35
	v1_6_0:1.29
	v1_4_6:1.6.2.8
	v1_4_5:1.6.2.8
	v1_4_4:1.6.2.5
	ruby_1_4_3:1.6.2.2
	ruby1_4_3:1.6.2.2
	v1_4_3:1.6.2.2
	v1_5_0:1.10
	ruby_1_4_3_pre1:1.6.2.2
	ruby_1_4:1.6.0.2
	v1_4_2:1.3
	v1_4_1:1.3
	v1_4_0:1.2
	v1_3_7:1.1.1.3.2.29
	v1_3_6_repack:1.1.1.3.2.29
	v1_3_6:1.1.1.3.2.29
	v1_3_5:1.1.1.3.2.27
	v1_2_6repack:1.1.1.2.2.46
	v1_3_4_990625:1.1.1.3.2.26
	v1_3_4_990624:1.1.1.3.2.25
	v1_2_6:1.1.1.2.2.46
	v1_3_4_990611:1.1.1.3.2.24
	v1_3_4_990531:1.1.1.3.2.23
	v1_3_3_990518:1.1.1.3.2.21
	v1_3_3_990513:1.1.1.3.2.18
	v1_3_3_990507:1.1.1.3.2.15
	v1_2_5:1.1.1.2.2.43
	v1_2_4:1.1.1.2.2.42
	v1_3_1_990225:1.1.1.3.2.9
	v1_3_1_990224:1.1.1.3.2.8
	v1_3_1_990215:1.1.1.3.2.7
	v1_3_1_990212:1.1.1.3.2.7
	v1_3_1_990210:1.1.1.3.2.6
	v1_3_1_:1.1.1.3.2.6
	v1_3_1_990209:1.1.1.3.2.5
	v1_3_1_990205:1.1.1.3.2.5
	v1_3_1_990203:1.1.1.3.2.4
	v1_3_1_990201:1.1.1.3.2.3
	v1_3_1"_990201:1.1.1.3.2.2
	v1_3_1_990128:1.1.1.3.2.1
	v1_3_1_990127:1.1.1.3.2.1
	v1_3_1_990126:1.1.1.3.2.1
	ruby_1_3:1.1.1.3.0.2
	v1_2_2:1.1.1.2.2.40
	RUBY_1_3:1.1.1.3
	v1_2_2_pr1:1.1.1.2.2.40
	v1_2_1repack:1.1.1.2.2.40
	v1_2_1:1.1.1.2.2.40
	v1_2_stable:1.1.1.2.2.39
	v1_1d1:1.1.1.2.2.35.2.5
	v1_1d0:1.1.1.2.2.35.2.4
	v1_1c9_1:1.1.1.2.2.38
	v1_1c9:1.1.1.2.2.38
	v1_1c8:1.1.1.2.2.38
	v1_1c7:1.1.1.2.2.38
	v1_1c6:1.1.1.2.2.37
	v1_1d-start:1.1.1.2.2.35.2.1
	v1_1c5:1.1.1.2.2.36
	v1_1dev:1.1.1.2.2.35.0.2
	v1_1c4:1.1.1.2.2.34
	v1_1c3:1.1.1.2.2.30
	v1_1c2:1.1.1.2.2.29
	v1_1c1:1.1.1.2.2.28
	v1_1c0:1.1.1.2.2.27
	v1_1b9_31:1.1.1.2.2.27
	v1_1b9_30:1.1.1.2.2.27
	v1_1b9_28:1.1.1.2.2.26
	v1_1b9_27:1.1.1.2.2.23
	v1_1b9_26:1.1.1.2.2.23
	r1_1b9_25:1.1.1.2.2.22
	r1_1b9_24:1.1.1.2.2.21
	v1_1b9_23:1.1.1.2.2.15
	v1_1b9_22:1.1.1.2.2.12
	v1_1b9_20:1.1.1.2.2.10
	v1_1b9_18:1.1.1.2.2.7
	v1_1b9_16:1.1.1.2.2.7
	v1_1b9_15:1.1.1.2.2.7
	v1_1b9_13:1.1.1.2.2.7
	v1_1b9_12:1.1.1.2.2.7
	v1_1b9_11:1.1.1.2.2.7
	v1_1b9_08:1.1.1.2.2.7
	v1_1b9_07:1.1.1.2.2.7
	r1_1b9:1.1.1.2.2.4
	v1_1b8:1.1.1.2.2.3
	v1_1b7:1.1.1.2.2.1
	v1_1b6:1.1.1.2.2.1
	v1_1r:1.1.1.2.0.2
	v1_1:1.1.1.2
	v1_0r:1.1.1.1.0.2
	v1_0:1.1.1.1
	RUBY:1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2002.09.26.00.48.33;	author matz;	state Exp;
branches;
next	1.73;

1.73
date	2002.09.25.14.52.37;	author nobu;	state Exp;
branches;
next	1.72;

1.72
date	2002.06.14.06.27.18;	author nobu;	state Exp;
branches;
next	1.71;

1.71
date	2002.05.21.05.39.19;	author matz;	state Exp;
branches;
next	1.70;

1.70
date	2002.04.25.13.55.58;	author matz;	state Exp;
branches;
next	1.69;

1.69
date	2002.04.24.04.54.14;	author matz;	state Exp;
branches;
next	1.68;

1.68
date	2002.04.19.04.14.07;	author matz;	state Exp;
branches;
next	1.67;

1.67
date	2002.03.25.09.08.15;	author nobu;	state Exp;
branches;
next	1.66;

1.66
date	2002.03.25.01.08.45;	author nobu;	state Exp;
branches;
next	1.65;

1.65
date	2002.03.12.09.28.48;	author matz;	state Exp;
branches;
next	1.64;

1.64
date	2002.02.19.04.49.25;	author matz;	state Exp;
branches;
next	1.63;

1.63
date	2002.02.19.04.25.39;	author eban;	state Exp;
branches;
next	1.62;

1.62
date	2002.02.16.00.58.51;	author nobu;	state Exp;
branches;
next	1.61;

1.61
date	2002.02.01.08.49.02;	author nobu;	state Exp;
branches;
next	1.60;

1.60
date	2002.01.30.07.00.58;	author nobu;	state Exp;
branches;
next	1.59;

1.59
date	2002.01.29.19.33.11;	author nobu;	state Exp;
branches;
next	1.58;

1.58
date	2002.01.23.07.30.39;	author matz;	state Exp;
branches;
next	1.57;

1.57
date	2002.01.07.05.27.01;	author matz;	state Exp;
branches;
next	1.56;

1.56
date	2002.01.04.14.14.35;	author matz;	state Exp;
branches;
next	1.55;

1.55
date	2001.12.10.07.18.12;	author matz;	state Exp;
branches;
next	1.54;

1.54
date	2001.10.30.08.43.25;	author matz;	state Exp;
branches;
next	1.53;

1.53
date	2001.10.03.07.19.10;	author matz;	state Exp;
branches;
next	1.52;

1.52
date	2001.09.19.06.54.11;	author matz;	state Exp;
branches;
next	1.51;

1.51
date	2001.09.03.05.37.42;	author matz;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.20.04.29.56;	author matz;	state Exp;
branches;
next	1.49;

1.49
date	2001.07.19.02.46.28;	author usa;	state Exp;
branches;
next	1.48;

1.48
date	2001.07.18.05.55.20;	author matz;	state Exp;
branches;
next	1.47;

1.47
date	2001.07.14.15.17.19;	author matz;	state Exp;
branches;
next	1.46;

1.46
date	2001.07.11.19.20.54;	author knu;	state Exp;
branches;
next	1.45;

1.45
date	2001.07.02.08.46.22;	author matz;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.19.04.35.13;	author matz;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.06.07.40.31;	author matz;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.05.07.19.38;	author matz;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.30.09.12.34;	author matz;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.02.04.22.11;	author matz;	state Exp;
branches;
next	1.39;

1.39
date	2001.02.13.05.09.00;	author matz;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.10.08.52.23;	author matz;	state Exp;
branches
	1.38.2.1
	1.38.4.1;
next	1.37;

1.37
date	2000.11.10.07.16.51;	author matz;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.02.07.48.32;	author matz;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.27.03.43.15;	author matz;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.26.07.07.13;	author matz;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.25.17.51.24;	author matz;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.25.09.15.02;	author matz;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.22.05.37.52;	author matz;	state Exp;
branches;
next	1.30;

1.30
date	2000.09.07.06.59.36;	author matz;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.28.09.53.29;	author matz;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.25.08.26.03;	author matz;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.24.06.21.32;	author matz;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.07.05.01.56;	author matz;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.24.04.34.07;	author matz;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.22.07.09.55;	author matz;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.19.03.25.00;	author matz;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.18.04.32.06;	author matz;	state Exp;
branches;
next	1.21;

1.21
date	2000.05.17.06.33.49;	author matz;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.16.02.46.55;	author matz;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.12.09.07.43;	author matz;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.09.04.53.03;	author matz;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.01.09.41.28;	author matz;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.09.08.59.56;	author matz;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.08.06.23.17;	author matz;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.23.05.23.08;	author matz;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.17.07.11.16;	author matz;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.08.08.48.54;	author matz;	state Exp;
branches;
next	1.11;

1.11
date	99.12.14.06.49.51;	author matz;	state Exp;
branches;
next	1.10;

1.10
date	99.12.06.09.03.56;	author matz;	state Exp;
branches;
next	1.9;

1.9
date	99.11.11.04.08.26;	author matz;	state Exp;
branches;
next	1.8;

1.8
date	99.11.08.03.57.01;	author matz;	state Exp;
branches;
next	1.7;

1.7
date	99.11.04.08.39.37;	author matz;	state Exp;
branches;
next	1.6;

1.6
date	99.10.04.04.51.06;	author matz;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.22.04.30.10;	author matz;	state Exp;
branches;
next	1.4;

1.4
date	99.09.18.04.48.50;	author matz;	state Exp;
branches;
next	1.3;

1.3
date	99.09.01.09.48.02;	author matz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.05.45.13;	author matz;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.01.16.12.13.06;	author matz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.01.16.12.19.12;	author matz;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	99.01.20.04.59.25;	author matz;	state Exp;
branches
	1.1.1.3.2.1;
next	;

1.1.1.3.2.1
date	99.01.26.10.08.14;	author matz;	state Exp;
branches;
next	1.1.1.3.2.2;

1.1.1.3.2.2
date	99.02.01.07.34.57;	author matz;	state Exp;
branches;
next	1.1.1.3.2.3;

1.1.1.3.2.3
date	99.02.01.07.48.23;	author matz;	state Exp;
branches;
next	1.1.1.3.2.4;

1.1.1.3.2.4
date	99.02.03.09.48.00;	author matz;	state Exp;
branches;
next	1.1.1.3.2.5;

1.1.1.3.2.5
date	99.02.05.10.27.32;	author matz;	state Exp;
branches;
next	1.1.1.3.2.6;

1.1.1.3.2.6
date	99.02.10.08.44.27;	author matz;	state Exp;
branches;
next	1.1.1.3.2.7;

1.1.1.3.2.7
date	99.02.12.11.17.05;	author matz;	state Exp;
branches;
next	1.1.1.3.2.8;

1.1.1.3.2.8
date	99.02.24.04.31.24;	author matz;	state Exp;
branches;
next	1.1.1.3.2.9;

1.1.1.3.2.9
date	99.02.25.06.39.10;	author matz;	state Exp;
branches;
next	1.1.1.3.2.10;

1.1.1.3.2.10
date	99.03.24.08.52.31;	author matz;	state Exp;
branches;
next	1.1.1.3.2.11;

1.1.1.3.2.11
date	99.04.09.17.57.42;	author matz;	state Exp;
branches;
next	1.1.1.3.2.12;

1.1.1.3.2.12
date	99.04.12.09.59.32;	author matz;	state Exp;
branches;
next	1.1.1.3.2.13;

1.1.1.3.2.13
date	99.04.16.06.03.33;	author matz;	state Exp;
branches;
next	1.1.1.3.2.14;

1.1.1.3.2.14
date	99.04.20.08.21.40;	author matz;	state Exp;
branches;
next	1.1.1.3.2.15;

1.1.1.3.2.15
date	99.05.06.08.31.43;	author matz;	state Exp;
branches;
next	1.1.1.3.2.16;

1.1.1.3.2.16
date	99.05.10.08.22.45;	author matz;	state Exp;
branches;
next	1.1.1.3.2.17;

1.1.1.3.2.17
date	99.05.11.01.34.30;	author matz;	state Exp;
branches;
next	1.1.1.3.2.18;

1.1.1.3.2.18
date	99.05.13.10.01.05;	author matz;	state Exp;
branches;
next	1.1.1.3.2.19;

1.1.1.3.2.19
date	99.05.14.08.56.09;	author matz;	state Exp;
branches;
next	1.1.1.3.2.20;

1.1.1.3.2.20
date	99.05.17.09.54.15;	author matz;	state Exp;
branches;
next	1.1.1.3.2.21;

1.1.1.3.2.21
date	99.05.18.06.06.14;	author matz;	state Exp;
branches;
next	1.1.1.3.2.22;

1.1.1.3.2.22
date	99.05.25.08.26.13;	author matz;	state Exp;
branches;
next	1.1.1.3.2.23;

1.1.1.3.2.23
date	99.05.31.09.13.25;	author matz;	state Exp;
branches;
next	1.1.1.3.2.24;

1.1.1.3.2.24
date	99.06.09.09.21.29;	author matz;	state Exp;
branches;
next	1.1.1.3.2.25;

1.1.1.3.2.25
date	99.06.24.04.24.00;	author matz;	state Exp;
branches;
next	1.1.1.3.2.26;

1.1.1.3.2.26
date	99.06.25.09.02.46;	author matz;	state Exp;
branches;
next	1.1.1.3.2.27;

1.1.1.3.2.27
date	99.07.15.07.59.52;	author matz;	state Exp;
branches;
next	1.1.1.3.2.28;

1.1.1.3.2.28
date	99.07.22.10.37.18;	author matz;	state Exp;
branches;
next	1.1.1.3.2.29;

1.1.1.3.2.29
date	99.07.28.09.26.46;	author matz;	state Exp;
branches;
next	1.1.1.3.2.30;

1.1.1.3.2.30
date	99.08.11.07.24.06;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	98.01.21.08.07.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.2;

1.1.1.2.2.2
date	98.02.18.01.56.41;	author matz;	state Exp;
branches;
next	1.1.1.2.2.3;

1.1.1.2.2.3
date	98.02.20.02.10.31;	author matz;	state Exp;
branches;
next	1.1.1.2.2.4;

1.1.1.2.2.4
date	98.02.24.03.55.01;	author matz;	state Exp;
branches;
next	1.1.1.2.2.5;

1.1.1.2.2.5
date	98.03.09.07.56.57;	author matz;	state Exp;
branches;
next	1.1.1.2.2.6;

1.1.1.2.2.6
date	98.03.11.07.33.00;	author matz;	state Exp;
branches;
next	1.1.1.2.2.7;

1.1.1.2.2.7
date	98.03.18.08.47.48;	author matz;	state Exp;
branches;
next	1.1.1.2.2.8;

1.1.1.2.2.8
date	98.05.13.07.26.29;	author matz;	state Exp;
branches;
next	1.1.1.2.2.9;

1.1.1.2.2.9
date	98.05.14.04.10.32;	author matz;	state Exp;
branches;
next	1.1.1.2.2.10;

1.1.1.2.2.10
date	98.05.15.05.43.24;	author matz;	state Exp;
branches;
next	1.1.1.2.2.11;

1.1.1.2.2.11
date	98.05.18.04.56.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.12;

1.1.1.2.2.12
date	98.05.18.06.03.37;	author matz;	state Exp;
branches;
next	1.1.1.2.2.13;

1.1.1.2.2.13
date	98.05.25.09.42.33;	author matz;	state Exp;
branches;
next	1.1.1.2.2.14;

1.1.1.2.2.14
date	98.05.26.03.24.59;	author matz;	state Exp;
branches;
next	1.1.1.2.2.15;

1.1.1.2.2.15
date	98.05.26.08.24.47;	author matz;	state Exp;
branches;
next	1.1.1.2.2.16;

1.1.1.2.2.16
date	98.05.27.04.47.27;	author matz;	state Exp;
branches;
next	1.1.1.2.2.17;

1.1.1.2.2.17
date	98.05.27.09.31.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.18;

1.1.1.2.2.18
date	98.05.29.09.32.11;	author matz;	state Exp;
branches;
next	1.1.1.2.2.19;

1.1.1.2.2.19
date	98.06.01.04.23.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.20;

1.1.1.2.2.20
date	98.06.05.09.54.22;	author matz;	state Exp;
branches;
next	1.1.1.2.2.21;

1.1.1.2.2.21
date	98.06.08.01.40.02;	author matz;	state Exp;
branches;
next	1.1.1.2.2.22;

1.1.1.2.2.22
date	98.06.11.10.03.08;	author matz;	state Exp;
branches;
next	1.1.1.2.2.23;

1.1.1.2.2.23
date	98.06.18.07.46.56;	author matz;	state Exp;
branches;
next	1.1.1.2.2.24;

1.1.1.2.2.24
date	98.06.23.10.30.12;	author matz;	state Exp;
branches;
next	1.1.1.2.2.25;

1.1.1.2.2.25
date	98.06.25.09.15.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.26;

1.1.1.2.2.26
date	98.06.26.07.19.02;	author matz;	state Exp;
branches;
next	1.1.1.2.2.27;

1.1.1.2.2.27
date	98.07.09.08.40.23;	author matz;	state Exp;
branches;
next	1.1.1.2.2.28;

1.1.1.2.2.28
date	98.07.24.04.41.59;	author matz;	state Exp;
branches;
next	1.1.1.2.2.29;

1.1.1.2.2.29
date	98.07.29.09.50.31;	author matz;	state Exp;
branches;
next	1.1.1.2.2.30;

1.1.1.2.2.30
date	98.08.27.03.55.28;	author matz;	state Exp;
branches;
next	1.1.1.2.2.31;

1.1.1.2.2.31
date	98.08.31.09.27.51;	author matz;	state Exp;
branches;
next	1.1.1.2.2.32;

1.1.1.2.2.32
date	98.08.31.09.52.20;	author matz;	state Exp;
branches;
next	1.1.1.2.2.33;

1.1.1.2.2.33
date	98.09.01.02.53.53;	author matz;	state Exp;
branches;
next	1.1.1.2.2.34;

1.1.1.2.2.34
date	98.09.03.07.43.38;	author matz;	state Exp;
branches;
next	1.1.1.2.2.35;

1.1.1.2.2.35
date	98.09.04.02.36.58;	author matz;	state Exp;
branches
	1.1.1.2.2.35.2.1;
next	1.1.1.2.2.36;

1.1.1.2.2.36
date	98.09.08.09.17.40;	author matz;	state Exp;
branches;
next	1.1.1.2.2.37;

1.1.1.2.2.37
date	98.10.06.02.45.01;	author matz;	state Exp;
branches;
next	1.1.1.2.2.38;

1.1.1.2.2.38
date	98.11.09.09.11.50;	author matz;	state Exp;
branches;
next	1.1.1.2.2.39;

1.1.1.2.2.39
date	98.12.25.04.35.42;	author matz;	state Exp;
branches;
next	1.1.1.2.2.40;

1.1.1.2.2.40
date	99.01.11.07.55.26;	author matz;	state Exp;
branches;
next	1.1.1.2.2.41;

1.1.1.2.2.41
date	99.02.16.03.42.19;	author matz;	state Exp;
branches;
next	1.1.1.2.2.42;

1.1.1.2.2.42
date	99.04.08.10.14.34;	author matz;	state Exp;
branches;
next	1.1.1.2.2.43;

1.1.1.2.2.43
date	99.04.13.05.54.25;	author matz;	state Exp;
branches;
next	1.1.1.2.2.44;

1.1.1.2.2.44
date	99.04.20.08.20.55;	author matz;	state Exp;
branches;
next	1.1.1.2.2.45;

1.1.1.2.2.45
date	99.05.14.08.56.46;	author matz;	state Exp;
branches;
next	1.1.1.2.2.46;

1.1.1.2.2.46
date	99.06.21.06.31.08;	author matz;	state Exp;
branches;
next	;

1.1.1.2.2.35.2.1
date	98.09.08.07.09.07;	author matz;	state Exp;
branches;
next	1.1.1.2.2.35.2.2;

1.1.1.2.2.35.2.2
date	98.10.06.03.28.14;	author matz;	state Exp;
branches;
next	1.1.1.2.2.35.2.3;

1.1.1.2.2.35.2.3
date	98.11.25.03.31.16;	author matz;	state Exp;
branches;
next	1.1.1.2.2.35.2.4;

1.1.1.2.2.35.2.4
date	98.12.16.07.30.33;	author matz;	state Exp;
branches;
next	1.1.1.2.2.35.2.5;

1.1.1.2.2.35.2.5
date	98.12.22.09.01.53;	author matz;	state Exp;
branches;
next	;

1.6.2.1
date	99.11.04.08.39.55;	author matz;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	99.11.11.04.07.30;	author matz;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2000.03.02.03.51.44;	author matz;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2000.03.08.06.25.14;	author matz;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2000.03.09.09.04.34;	author matz;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2000.05.09.04.50.16;	author matz;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2000.05.12.09.06.14;	author matz;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2000.05.30.04.21.16;	author matz;	state Exp;
branches;
next	1.6.2.9;

1.6.2.9
date	2000.08.07.05.04.51;	author matz;	state Exp;
branches;
next	1.6.2.10;

1.6.2.10
date	2000.09.12.05.33.07;	author matz;	state Exp;
branches;
next	;

1.38.2.1
date	2001.02.13.05.10.43;	author matz;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2001.04.16.06.54.36;	author matz;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2001.04.17.15.35.04;	author matz;	state Exp;
branches;
next	1.38.2.4;

1.38.2.4
date	2001.04.19.09.16.07;	author matz;	state Exp;
branches;
next	1.38.2.5;

1.38.2.5
date	2001.05.29.08.59.36;	author matz;	state Exp;
branches;
next	1.38.2.6;

1.38.2.6
date	2001.05.29.09.47.36;	author matz;	state Exp;
branches;
next	1.38.2.7;

1.38.2.7
date	2001.06.04.09.01.10;	author matz;	state Exp;
branches;
next	1.38.2.8;

1.38.2.8
date	2001.06.06.07.39.39;	author matz;	state Exp;
branches;
next	1.38.2.9;

1.38.2.9
date	2001.06.19.04.36.34;	author matz;	state Exp;
branches;
next	1.38.2.10;

1.38.2.10
date	2001.06.29.08.32.52;	author matz;	state Exp;
branches;
next	1.38.2.11;

1.38.2.11
date	2001.07.06.06.36.59;	author matz;	state Exp;
branches;
next	1.38.2.12;

1.38.2.12
date	2001.07.11.19.25.52;	author knu;	state Exp;
branches;
next	1.38.2.13;

1.38.2.13
date	2001.07.16.04.01.42;	author matz;	state Exp;
branches;
next	1.38.2.14;

1.38.2.14
date	2001.07.19.05.45.23;	author matz;	state Exp;
branches;
next	1.38.2.15;

1.38.2.15
date	2001.07.19.07.59.48;	author matz;	state Exp;
branches;
next	1.38.2.16;

1.38.2.16
date	2001.08.23.06.00.31;	author matz;	state Exp;
branches;
next	1.38.2.17;

1.38.2.17
date	2001.09.03.05.29.18;	author matz;	state Exp;
branches;
next	1.38.2.18;

1.38.2.18
date	2001.10.02.09.36.23;	author matz;	state Exp;
branches;
next	1.38.2.19;

1.38.2.19
date	2001.10.30.08.42.21;	author matz;	state Exp;
branches;
next	1.38.2.20;

1.38.2.20
date	2001.12.10.07.22.50;	author matz;	state Exp;
branches;
next	1.38.2.21;

1.38.2.21
date	2002.01.04.14.19.48;	author matz;	state Exp;
branches;
next	1.38.2.22;

1.38.2.22
date	2002.01.07.05.24.03;	author matz;	state Exp;
branches;
next	1.38.2.23;

1.38.2.23
date	2002.01.25.08.23.31;	author matz;	state Exp;
branches;
next	1.38.2.24;

1.38.2.24
date	2002.02.16.00.58.44;	author nobu;	state Exp;
branches;
next	1.38.2.25;

1.38.2.25
date	2002.03.12.09.27.26;	author matz;	state Exp;
branches;
next	1.38.2.26;

1.38.2.26
date	2002.05.01.09.37.59;	author matz;	state Exp;
branches;
next	1.38.2.27;

1.38.2.27
date	2002.05.21.05.41.01;	author matz;	state Exp;
branches;
next	1.38.2.28;

1.38.2.28
date	2002.06.14.06.26.59;	author nobu;	state Exp;
branches;
next	1.38.2.29;

1.38.2.29
date	2002.10.01.08.15.24;	author matz;	state Exp;
branches;
next	;

1.38.4.1
date	2001.01.12.04.36.00;	author matz;	state Exp;
branches;
next	1.38.4.2;

1.38.4.2
date	2002.07.09.05.26.49;	author matz;	state Exp;
branches;
next	;


desc
@@


1.74
log
@
* regex.c (re_match): p1 may exceed pend limit.
@
text
@/* Extended regular expression matching and search library.
   Copyright (C) 1993, 94, 95, 96, 97, 98 Free Software Foundation, Inc.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with the GNU C Library; see the file LGPL.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
/* Multi-byte extension added May, 1993 by t^2 (Takahiro Tanimoto)
   Last change: May 21, 1993 by t^2  */
/* removed gapped buffer support, multiple syntax support by matz <matz@@nts.co.jp> */
/* Perl5 extension added by matz <matz@@caelum.co.jp> */
/* UTF-8 extension added Jan 16 1999 by Yoshida Masato  <yoshidam@@tau.bekkoame.ne.jp> */

#include "config.h"

#ifdef HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

/* We write fatal error messages on standard error.  */
#include <stdio.h>

/* isalpha(3) etc. are used for the character classes.  */
#include <ctype.h>
#include <sys/types.h>

#ifndef PARAMS
# if defined __GNUC__ || (defined __STDC__ && __STDC__)
#  define PARAMS(args) args
# else
#  define PARAMS(args) ()
# endif  /* GCC.  */
#endif  /* Not PARAMS.  */

#if defined(STDC_HEADERS)
# include <stddef.h>
#else
/* We need this for `regex.h', and perhaps for the Emacs include files.  */
# include <sys/types.h>
#endif

#if !defined(__STDC__) && !defined(_MSC_VER)
# define volatile
#endif

#ifdef HAVE_PROTOTYPES
# define _(args) args
#else
# define _(args) ()
#endif

#ifdef RUBY_PLATFORM
#include "defines.h"

# define RUBY
extern int rb_prohibit_interrupt;
extern int rb_trap_pending;
void rb_trap_exec _((void));

# define CHECK_INTS do {\
    if (!rb_prohibit_interrupt) {\
	if (rb_trap_pending) rb_trap_exec();\
    }\
} while (0)
#endif

/* Make alloca work the best possible way.  */
#ifdef __GNUC__
# ifndef atarist
#  ifndef alloca
#   define alloca __builtin_alloca
#  endif
# endif /* atarist */
#else
# if defined(HAVE_ALLOCA_H)
#  include <alloca.h>
# elif !defined(alloca)
char *alloca();
# endif
#endif /* __GNUC__ */

#ifdef _AIX
#pragma alloca
#endif

#ifdef HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#ifdef C_ALLOCA
#define FREE_VARIABLES() alloca(0)
#else
#define FREE_VARIABLES()
#endif

#define FREE_AND_RETURN_VOID(stackb)   do {				\
  FREE_VARIABLES();							\
  if (stackb != stacka) xfree(stackb);					\
  return;								\
} while(0)

#define FREE_AND_RETURN(stackb,val)    do {				\
  FREE_VARIABLES();							\
  if (stackb != stacka) xfree(stackb);					\
  return(val);								\
} while(0)

#define DOUBLE_STACK(type) do {						\
  type *stackx;								\
  unsigned int xlen = stacke - stackb; 					\
  if (stackb == stacka) {						\
    stackx = (type*)xmalloc(2 * xlen * sizeof(type));			\
    memcpy(stackx, stackb, xlen * sizeof (type));			\
  }									\
  else {								\
    stackx = (type*)xrealloc(stackb, 2 * xlen * sizeof(type));		\
  }									\
  /* Rearrange the pointers. */						\
  stackp = stackx + (stackp - stackb);					\
  stackb = stackx;							\
  stacke = stackb + 2 * xlen;						\
} while (0)

#define RE_TALLOC(n,t)  ((t*)alloca((n)*sizeof(t)))
#define TMALLOC(n,t)    ((t*)xmalloc((n)*sizeof(t)))
#define TREALLOC(s,n,t) (s=((t*)xrealloc(s,(n)*sizeof(t))))

#define EXPAND_FAIL_STACK() DOUBLE_STACK(unsigned char*)
#define ENSURE_FAIL_STACK(n)						\
  do {									\
    if (stacke - stackp <= (n)) {					\
	/* if (len > re_max_failures * MAX_NUM_FAILURE_ITEMS)		\
	   {								\
	   FREE_AND_RETURN(stackb,(-2));				\
	   }*/								\
									\
        /* Roughly double the size of the stack.  */			\
        EXPAND_FAIL_STACK();						\
      }									\
  } while (0)

/* Get the interface, including the syntax bits.  */
#include "regex.h"

/* Subroutines for re_compile_pattern.  */
static void store_jump _((char*, int, char*));
static void insert_jump _((int, char*, char*, char*));
static void store_jump_n _((char*, int, char*, unsigned));
static void insert_jump_n _((int, char*, char*, char*, unsigned));
static void insert_op _((int, char*, char*));
static void insert_op_2 _((int, char*, char*, int, int));
static int memcmp_translate _((unsigned char*, unsigned char*, int));

/* Define the syntax stuff, so we can do the \<, \>, etc.  */

/* This must be nonzero for the wordchar and notwordchar pattern
   commands in re_match.  */
#define Sword  1
#define Sword2 2

#define SYNTAX(c) re_syntax_table[c]

static char re_syntax_table[256];
static void init_syntax_once _((void));
static const unsigned char *translate = 0;
static void init_regs _((struct re_registers*, unsigned int));
static void bm_init_skip _((int *, unsigned char*, int, const unsigned char*));
static int current_mbctype = MBCTYPE_ASCII;

#undef P

#ifdef RUBY
#include "util.h"
#endif

static void
init_syntax_once()
{
   register int c;
   static int done = 0;

   if (done)
     return;

   memset(re_syntax_table, 0, sizeof re_syntax_table);

   for (c=0; c<=0x7f; c++)
     if (isalnum(c)) 
       re_syntax_table[c] = Sword;
   re_syntax_table['_'] = Sword;

   for (c=0x80; c<=0xff; c++)
     if (isalnum(c)) 
       re_syntax_table[c] = Sword2;
   done = 1;
}

void
re_set_casetable(table)
     const char *table;
{
  translate = (const unsigned char*)table;
}

/* Jim Meyering writes:

   "... Some ctype macros are valid only for character codes that
   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
   using /bin/cc or gcc but without giving an ansi option).  So, all
   ctype uses should be through macros like ISPRINT...  If
   STDC_HEADERS is defined, then autoconf has verified that the ctype
   macros don't need to be guarded with references to isascii. ...
   Defining isascii to 1 should let any compiler worth its salt
   eliminate the && through constant folding."
   Solaris defines some of these symbols so we must undefine them first.  */

#undef ISASCII
#if defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
# define ISASCII(c) 1
#else
# define ISASCII(c) isascii(c)
#endif

#ifdef isblank
# define ISBLANK(c) (ISASCII(c) && isblank(c))
#else
# define ISBLANK(c) ((c) == ' ' || (c) == '\t')
#endif
#ifdef isgraph
# define ISGRAPH(c) (ISASCII(c) && isgraph(c))
#else
# define ISGRAPH(c) (ISASCII(c) && isprint(c) && !isspace(c))
#endif

#undef ISPRINT
#define ISPRINT(c) (ISASCII(c) && isprint(c))
#define ISDIGIT(c) (ISASCII(c) && isdigit(c))
#define ISALNUM(c) (ISASCII(c) && isalnum(c))
#define ISALPHA(c) (ISASCII(c) && isalpha(c))
#define ISCNTRL(c) (ISASCII(c) && iscntrl(c))
#define ISLOWER(c) (ISASCII(c) && islower(c))
#define ISPUNCT(c) (ISASCII(c) && ispunct(c))
#define ISSPACE(c) (ISASCII(c) && isspace(c))
#define ISUPPER(c) (ISASCII(c) && isupper(c))
#define ISXDIGIT(c) (ISASCII(c) && isxdigit(c))

#ifndef NULL
# define NULL (void *)0
#endif

/* We remove any previous definition of `SIGN_EXTEND_CHAR',
   since ours (we hope) works properly with all combinations of
   machines, compilers, `char' and `unsigned char' argument types.
   (Per Bothner suggested the basic approach.)  */
#undef SIGN_EXTEND_CHAR
#if __STDC__
# define SIGN_EXTEND_CHAR(c) ((signed char)(c))
#else  /* not __STDC__ */
/* As in Harbison and Steele.  */
# define SIGN_EXTEND_CHAR(c) ((((unsigned char)(c)) ^ 128) - 128)
#endif

/* These are the command codes that appear in compiled regular
   expressions, one per byte.  Some command codes are followed by
   argument bytes.  A command code can specify any interpretation
   whatsoever for its arguments.  Zero-bytes may appear in the compiled
   regular expression.

   The value of `exactn' is needed in search.c (search_buffer) in emacs.
   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
   `exactn' we use here must also be 1.  */

enum regexpcode
  {
    unused=0,
    exactn=1, /* Followed by one byte giving n, then by n literal bytes.  */
    begline,  /* Fail unless at beginning of line.  */
    endline,  /* Fail unless at end of line.  */
    begbuf,   /* Succeeds if at beginning of buffer (if emacs) or at beginning
                 of string to be matched (if not).  */
    endbuf,   /* Analogously, for end of buffer/string.  */
    endbuf2,  /* End of buffer/string, or newline just before it.  */
    begpos,   /* Matches where last scan//gsub left off.  */
    jump,     /* Followed by two bytes giving relative address to jump to.  */
    jump_past_alt,/* Same as jump, but marks the end of an alternative.  */
    on_failure_jump,	 /* Followed by two bytes giving relative address of 
			    place to resume at in case of failure.  */
    finalize_jump,	 /* Throw away latest failure point and then jump to 
			    address.  */
    maybe_finalize_jump, /* Like jump but finalize if safe to do so.
			    This is used to jump back to the beginning
			    of a repeat.  If the command that follows
			    this jump is clearly incompatible with the
			    one at the beginning of the repeat, such that
			    we can be sure that there is no use backtracking
			    out of repetitions already completed,
			    then we finalize.  */
    dummy_failure_jump,  /* Jump, and push a dummy failure point. This 
			    failure point will be thrown away if an attempt 
                            is made to use it for a failure. A + construct 
                            makes this before the first repeat.  Also
                            use it as an intermediary kind of jump when
                            compiling an or construct.  */
    push_dummy_failure, /* Push a dummy failure point and continue.  Used at the end of
			   alternatives.  */
    succeed_n,	 /* Used like on_failure_jump except has to succeed n times;
		    then gets turned into an on_failure_jump. The relative
                    address following it is useless until then.  The
                    address is followed by two bytes containing n.  */
    jump_n,	 /* Similar to jump, but jump n times only; also the relative
		    address following is in turn followed by yet two more bytes
                    containing n.  */
    try_next,    /* Jump to next pattern for the first time,
		    leaving this pattern on the failure stack. */
    finalize_push,	/* Finalize stack and push the beginning of the pattern
			   on the stack to retry (used for non-greedy match) */
    finalize_push_n,	/* Similar to finalize_push, buf finalize n time only */
    set_number_at,	/* Set the following relative location to the
			   subsequent number.  */
    anychar,	 /* Matches any (more or less) one character excluding newlines.  */
    anychar_repeat,	 /* Matches sequence of characters excluding newlines.  */
    charset,     /* Matches any one char belonging to specified set.
		    First following byte is number of bitmap bytes.
		    Then come bytes for a bitmap saying which chars are in.
		    Bits in each byte are ordered low-bit-first.
		    A character is in the set if its bit is 1.
		    A character too large to have a bit in the map
		    is automatically not in the set.  */
    charset_not, /* Same parameters as charset, but match any character
                    that is not one of those specified.  */
    start_memory, /* Start remembering the text that is matched, for
		    storing in a memory register.  Followed by one
                    byte containing the register number.  Register numbers
                    must be in the range 0 through RE_NREGS.  */
    stop_memory, /* Stop remembering the text that is matched
		    and store it in a memory register.  Followed by
                    one byte containing the register number. Register
                    numbers must be in the range 0 through RE_NREGS.  */
    start_paren,    /* Place holder at the start of (?:..). */
    stop_paren,    /* Place holder at the end of (?:..). */
    casefold_on,   /* Turn on casefold flag. */
    casefold_off,  /* Turn off casefold flag. */
    option_set,	   /* Turn on multi line match (match with newlines). */
    start_nowidth, /* Save string point to the stack. */
    stop_nowidth,  /* Restore string place at the point start_nowidth. */
    pop_and_fail,  /* Fail after popping nowidth entry from stack. */
    stop_backtrack,  /* Restore backtrack stack at the point start_nowidth. */
    duplicate,   /* Match a duplicate of something remembered.
		    Followed by one byte containing the index of the memory 
                    register.  */
    wordchar,    /* Matches any word-constituent character.  */
    notwordchar, /* Matches any char that is not a word-constituent.  */
    wordbeg,	 /* Succeeds if at word beginning.  */
    wordend,	 /* Succeeds if at word end.  */
    wordbound,   /* Succeeds if at a word boundary.  */
    notwordbound /* Succeeds if not at a word boundary.  */
  };


/* Number of failure points to allocate space for initially,
   when matching.  If this number is exceeded, more space is allocated,
   so it is not a hard limit.  */

#ifndef NFAILURES
#define NFAILURES 160
#endif

/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
#define STORE_NUMBER(destination, number)				\
  do { (destination)[0] = (number) & 0377;				\
    (destination)[1] = (number) >> 8; } while (0)

/* Same as STORE_NUMBER, except increment the destination pointer to
   the byte after where the number is stored.  Watch out that values for
   DESTINATION such as p + 1 won't work, whereas p will.  */
#define STORE_NUMBER_AND_INCR(destination, number)			\
  do { STORE_NUMBER(destination, number);				\
    (destination) += 2; } while (0)


/* Put into DESTINATION a number stored in two contingous bytes starting
   at SOURCE.  */
#define EXTRACT_NUMBER(destination, source)				\
  do { (destination) = *(source) & 0377;				\
    (destination) += SIGN_EXTEND_CHAR(*(char*)((source) + 1)) << 8; } while (0)

/* Same as EXTRACT_NUMBER, except increment the pointer for source to
   point to second byte of SOURCE.  Note that SOURCE has to be a value
   such as p, not, e.g., p + 1. */
#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
  do { EXTRACT_NUMBER(destination, source);				\
       (source) += 2; } while (0)


/* Specify the precise syntax of regexps for compilation.  This provides
   for compatibility for various utilities which historically have
   different, incompatible syntaxes.

   The argument SYNTAX is a bit-mask comprised of the various bits
   defined in regex.h.  */

long
re_set_syntax(syntax)
  long syntax;
{
    /* obsolete */
    return 0;
}

/* Macros for re_compile_pattern, which is found below these definitions.  */

#define TRANSLATE_P() ((options&RE_OPTION_IGNORECASE) && translate)
#define MAY_TRANSLATE() ((bufp->options&(RE_OPTION_IGNORECASE|RE_MAY_IGNORECASE)) && translate)
/* Fetch the next character in the uncompiled pattern---translating it 
   if necessary.  Also cast from a signed character in the constant
   string passed to us by the user to an unsigned char that we can use
   as an array index (in, e.g., `translate').  */
#define PATFETCH(c)							\
  do {if (p == pend) goto end_of_pattern;				\
    c = (unsigned char) *p++; 						\
    if (TRANSLATE_P()) c = (unsigned char)translate[c];	\
  } while (0)

/* Fetch the next character in the uncompiled pattern, with no
   translation.  */
#define PATFETCH_RAW(c)							\
  do {if (p == pend) goto end_of_pattern;				\
    c = (unsigned char)*p++; 						\
  } while (0)

/* Go backwards one character in the pattern.  */
#define PATUNFETCH p--

#define MBC2WC(c, p)							\
  do {									\
    if (current_mbctype == MBCTYPE_UTF8) {				\
      int n = mbclen(c) - 1;						\
      c &= (1<<(BYTEWIDTH-2-n)) - 1;					\
      while (n--) {							\
	c = c << 6 | (*p++ & ((1<<6)-1));				\
      }									\
    }									\
    else {								\
      c <<= 8;								\
      c |= (unsigned char)*(p)++;					\
    }									\
  } while (0)

#define PATFETCH_MBC(c)							\
  do {									\
    if (p + mbclen(c) - 1 >= pend) goto end_of_pattern;			\
    MBC2WC(c, p);							\
  } while(0)

#define WC2MBC1ST(c)							\
 ((current_mbctype != MBCTYPE_UTF8) ? ((c<0x100) ? (c) : (((c)>>8)&0xff)) : utf8_firstbyte(c))

typedef unsigned int (*mbc_startpos_func_t) _((const char *string, unsigned int pos));

static unsigned int asc_startpos _((const char *string, unsigned int pos));
static unsigned int euc_startpos _((const char *string, unsigned int pos));
static unsigned int sjis_startpos _((const char *string, unsigned int pos));
static unsigned int utf8_startpos _((const char *string, unsigned int pos));

static const mbc_startpos_func_t mbc_startpos_func[4] = {
  asc_startpos, euc_startpos, sjis_startpos, utf8_startpos
};

#define mbc_startpos(start, pos) (*mbc_startpos_func[current_mbctype])((start), (pos))

static unsigned int
utf8_firstbyte(c)
     unsigned long c;
{
  if (c < 0x80) return c;
  if (c <= 0x7ff) return ((c>>6)&0xff)|0xc0;
  if (c <= 0xffff) return ((c>>12)&0xff)|0xe0;
  if (c <= 0x1fffff) return ((c>>18)&0xff)|0xf0;
  if (c <= 0x3ffffff) return ((c>>24)&0xff)|0xf8;
  if (c <= 0x7fffffff) return ((c>>30)&0xff)|0xfc;
#if SIZEOF_INT > 4
  if (c <= 0xfffffffff) return 0xfe;
#else
  return 0xfe;
#endif
}

static void
print_mbc(c)
     unsigned int c;
{
  if (current_mbctype == MBCTYPE_UTF8) {
    if (c < 0x80)
      printf("%c", (int)c);
    else if (c <= 0x7ff)
      printf("%c%c", (int)utf8_firstbyte(c), (int)(c & 0x3f));
    else if (c <= 0xffff)
      printf("%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 6) & 0x3f),
	     (int)(c & 0x3f));
    else if (c <= 0x1fffff) 
      printf("%c%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 12) & 0x3f),
	     (int)((c >> 6) & 0x3f), (int)(c & 0x3f));
    else if (c <= 0x3ffffff)
      printf("%c%c%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 18) & 0x3f),
	     (int)((c >> 12) & 0x3f), (int)((c >> 6) & 0x3f), (int)(c & 0x3f));
    else if (c <= 0x7fffffff)
      printf("%c%c%c%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 24) & 0x3f),
	     (int)((c >> 18) & 0x3f), (int)((c >> 12) & 0x3f),
	     (int)((c >> 6) & 0x3f), (int)(c & 0x3f));
  }
  else if (c < 0xff) {
    printf("\\%o", (int)c);
  }
  else {
    printf("%c%c", (int)(c >> BYTEWIDTH), (int)(c &0xff));
  }
}

/* If the buffer isn't allocated when it comes in, use this.  */
#define INIT_BUF_SIZE  28

/* Make sure we have at least N more bytes of space in buffer.  */
#define GET_BUFFER_SPACE(n)						\
  do {								        \
    while (b - bufp->buffer + (n) >= bufp->allocated)			\
      EXTEND_BUFFER;							\
  } while (0)

/* Make sure we have one more byte of buffer space and then add CH to it.  */
#define BUFPUSH(ch)							\
  do {									\
    GET_BUFFER_SPACE(1);						\
    *b++ = (char)(ch);							\
  } while (0)

/* Extend the buffer by twice its current size via reallociation and
   reset the pointers that pointed into the old allocation to point to
   the correct places in the new allocation.  If extending the buffer
   results in it being larger than 1 << 16, then flag memory exhausted.  */
#define EXTEND_BUFFER						\
  do { char *old_buffer = bufp->buffer;					\
    if (bufp->allocated == (1L<<16)) goto too_big;			\
    bufp->allocated *= 2;						\
    if (bufp->allocated > (1L<<16)) bufp->allocated = (1L<<16);		\
    bufp->buffer = (char*)xrealloc(bufp->buffer, bufp->allocated);	\
    if (bufp->buffer == 0)						\
      goto memory_exhausted;						\
    b = (b - old_buffer) + bufp->buffer;				\
    if (fixup_alt_jump)							\
      fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;	\
    if (laststart)							\
      laststart = (laststart - old_buffer) + bufp->buffer;		\
    begalt = (begalt - old_buffer) + bufp->buffer;			\
    if (pending_exact)							\
      pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
  } while (0)


/* Set the bit for character C in a character set list.  */
#define SET_LIST_BIT(c)							\
  (b[(unsigned char)(c) / BYTEWIDTH]					\
   |= 1 << ((unsigned char)(c) % BYTEWIDTH))

/* Get the next unsigned number in the uncompiled pattern.  */
#define GET_UNSIGNED_NUMBER(num) 					\
  do { if (p != pend) { 						\
        PATFETCH(c); 							\
	while (ISDIGIT(c)) { 						\
	  if (num < 0) 							\
	     num = 0; 							\
	  num = num * 10 + c - '0'; 					\
	  if (p == pend) 						\
	     break; 							\
	  PATFETCH(c); 							\
	} 								\
     } 									\
  } while (0)

#define STREQ(s1, s2) ((strcmp(s1, s2) == 0))

#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */

#define IS_CHAR_CLASS(string)						\
   (STREQ(string, "alpha") || STREQ(string, "upper")			\
    || STREQ(string, "lower") || STREQ(string, "digit")			\
    || STREQ(string, "alnum") || STREQ(string, "xdigit")		\
    || STREQ(string, "space") || STREQ(string, "print")			\
    || STREQ(string, "punct") || STREQ(string, "graph")			\
    || STREQ(string, "cntrl") || STREQ(string, "blank"))

#define STORE_MBC(p, c)							\
  do {									\
    (p)[0] = (unsigned char)(((c) >>24) & 0xff);			\
    (p)[1] = (unsigned char)(((c) >>16) & 0xff);			\
    (p)[2] = (unsigned char)(((c) >> 8) & 0xff);			\
    (p)[3] = (unsigned char)(((c) >> 0) & 0xff);			\
  } while (0)

#define STORE_MBC_AND_INCR(p, c) 					\
  do {									\
    *(p)++ = (unsigned char)(((c) >>24) & 0xff);			\
    *(p)++ = (unsigned char)(((c) >>16) & 0xff);			\
    *(p)++ = (unsigned char)(((c) >> 8) & 0xff);			\
    *(p)++ = (unsigned char)(((c) >> 0) & 0xff);			\
  } while (0)

#define EXTRACT_MBC(p) 							\
  ((unsigned int)((unsigned char)(p)[0] << 24 |				\
		    (unsigned char)(p)[1] << 16 |			\
                    (unsigned char)(p)[2] <<  8 |			\
		    (unsigned char)(p)[3]))

#define EXTRACT_MBC_AND_INCR(p) 					\
  ((unsigned int)((p) += 4, 						\
		    (unsigned char)(p)[-4] << 24 |			\
		    (unsigned char)(p)[-3] << 16 |			\
                    (unsigned char)(p)[-2] <<  8 |			\
		    (unsigned char)(p)[-1]))

#define EXTRACT_UNSIGNED(p) \
  ((unsigned char)(p)[0] | (unsigned char)(p)[1] << 8)
#define EXTRACT_UNSIGNED_AND_INCR(p) \
  ((p) += 2, (unsigned char)(p)[-2] | (unsigned char)(p)[-1] << 8)

/* Handle (mb)?charset(_not)?.

   Structure of mbcharset(_not)? in compiled pattern.

     struct {
       unsinged char id;		mbcharset(_not)?
       unsigned char sbc_size;
       unsigned char sbc_map[sbc_size];	same as charset(_not)? up to here.
       unsigned short mbc_size;		number of intervals.
       struct {
	 unsigned long beg;		beginning of interval.
	 unsigned long end;		end of interval.
       } intervals[mbc_size];
     }; */

static void
set_list_bits(c1, c2, b)
    unsigned long c1, c2;
    unsigned char *b;
{
  unsigned char sbc_size = b[-1];
  unsigned short mbc_size = EXTRACT_UNSIGNED(&b[sbc_size]);
  unsigned short beg, end, upb;

  if (c1 > c2)
    return;
  b = &b[sbc_size + 2];

  for (beg = 0, upb = mbc_size; beg < upb; ) {
    unsigned short mid = (unsigned short)(beg + upb) >> 1;

    if ((int)c1 - 1 > (int)EXTRACT_MBC(&b[mid*8+4]))
      beg = mid + 1;
    else
      upb = mid;
  }

  for (end = beg, upb = mbc_size; end < upb; ) {
    unsigned short mid = (unsigned short)(end + upb) >> 1;

    if ((int)c2 >= (int)EXTRACT_MBC(&b[mid*8]) - 1)
      end = mid + 1;
    else
      upb = mid;
  }

  if (beg != end) {
    if (c1 > EXTRACT_MBC(&b[beg*8]))
      c1 = EXTRACT_MBC(&b[beg*8]);
    if (c2 < EXTRACT_MBC(&b[(end - 1)*8+4]))
      c2 = EXTRACT_MBC(&b[(end - 1)*8+4]);
  }
  if (end < mbc_size && end != beg + 1)
    /* NOTE: memcpy() would not work here.  */
    memmove(&b[(beg + 1)*8], &b[end*8], (mbc_size - end)*8);
  STORE_MBC(&b[beg*8 + 0], c1);
  STORE_MBC(&b[beg*8 + 4], c2);
  mbc_size += beg - end + 1;
  STORE_NUMBER(&b[-2], mbc_size);
}

static int
is_in_list(c, b)
    unsigned long c;
    const unsigned char *b;
{
  unsigned short size;
  unsigned short i, j;

  size = *b++;
  if ((int)c / BYTEWIDTH < (int)size && b[c / BYTEWIDTH] & 1 << c % BYTEWIDTH) {
    return 1;
  }
  b += size + 2;
  size = EXTRACT_UNSIGNED(&b[-2]);
  if (size == 0) return 0;

  for (i = 0, j = size; i < j; ) {
    unsigned short k = (unsigned short)(i + j) >> 1;

    if (c > EXTRACT_MBC(&b[k*8+4]))
      i = k + 1;
    else
      j = k;
  }
  if (i < size && EXTRACT_MBC(&b[i*8]) <= c)
    return 1;

  return 0;
}

static void
print_partial_compiled_pattern(start, end)
    unsigned char *start;
    unsigned char *end;
{
  int mcnt, mcnt2;
  unsigned char *p = start;
  unsigned char *pend = end;

  if (start == NULL) {
    printf("(null)\n");
    return;
  }

  /* Loop over pattern commands.  */
  while (p < pend) {
    switch ((enum regexpcode)*p++) {
    case unused:
      printf("/unused");
      break;

    case exactn:
      mcnt = *p++;
      printf("/exactn/%d", mcnt);
      do {
	putchar('/');
	printf("%c", *p++);
      }
      while (--mcnt);
      break;

    case start_memory:
      mcnt = *p++;
      printf("/start_memory/%d/%d", mcnt, *p++);
      break;

    case stop_memory:
      mcnt = *p++;
      printf("/stop_memory/%d/%d", mcnt, *p++);
      break;

    case start_paren:
      printf("/start_paren");
      break;

    case stop_paren:
      printf("/stop_paren");
      break;

    case casefold_on:
      printf("/casefold_on");
      break;

    case casefold_off:
      printf("/casefold_off");
      break;

    case option_set:
      printf("/option_set/%d", *p++);
      break;

    case start_nowidth:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      printf("/start_nowidth//%d", mcnt);
      break;

    case stop_nowidth:
      printf("/stop_nowidth//");
      p += 2;
      break;

    case pop_and_fail:
      printf("/pop_and_fail");
      break;

    case stop_backtrack:
      printf("/stop_backtrack//");
      p += 2;
      break;

    case duplicate:
      printf("/duplicate/%d", *p++);
      break;

    case anychar:
      printf("/anychar");
      break;

    case anychar_repeat:
      printf("/anychar_repeat");
      break;

    case charset:
    case charset_not:
      {
	register int c;

	printf("/charset%s",
	       (enum regexpcode)*(p - 1) == charset_not ? "_not" : "");

	mcnt = *p++;
	printf("/%d", mcnt);
	for (c = 0; c < mcnt; c++) {
	  unsigned bit;
	  unsigned char map_byte = p[c];

	  putchar('/');

	  for (bit = 0; bit < BYTEWIDTH; bit++)
	    if (map_byte & (1 << bit))
	      printf("%c", c * BYTEWIDTH + bit);
	}
	p += mcnt;
	mcnt = EXTRACT_UNSIGNED_AND_INCR(p);
	putchar('/');
	while (mcnt--) {
	  print_mbc(EXTRACT_MBC_AND_INCR(p));
	  putchar('-');
	  print_mbc(EXTRACT_MBC_AND_INCR(p));
	}
	break;
      }

    case begline:
      printf("/begline");
      break;

    case endline:
      printf("/endline");
      break;

    case on_failure_jump:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      printf("/on_failure_jump//%d", mcnt);
      break;

    case dummy_failure_jump:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      printf("/dummy_failure_jump//%d", mcnt);
      break;

    case push_dummy_failure:
      printf("/push_dummy_failure");
      break;

    case finalize_jump:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      printf("/finalize_jump//%d", mcnt);
      break;

    case maybe_finalize_jump:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      printf("/maybe_finalize_jump//%d", mcnt);
      break;

    case jump_past_alt:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      printf("/jump_past_alt//%d", mcnt);
      break;

    case jump:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      printf("/jump//%d", mcnt);
      break;

    case succeed_n: 
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      EXTRACT_NUMBER_AND_INCR(mcnt2, p);
      printf("/succeed_n//%d//%d", mcnt, mcnt2);
      break;

    case jump_n: 
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      EXTRACT_NUMBER_AND_INCR(mcnt2, p);
      printf("/jump_n//%d//%d", mcnt, mcnt2);
      break;

    case set_number_at: 
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      EXTRACT_NUMBER_AND_INCR(mcnt2, p);
      printf("/set_number_at//%d//%d", mcnt, mcnt2);
      break;

    case try_next:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      printf("/try_next//%d", mcnt);
      break;

    case finalize_push:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      printf("/finalize_push//%d", mcnt);
      break;

    case finalize_push_n:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      EXTRACT_NUMBER_AND_INCR(mcnt2, p);
      printf("/finalize_push_n//%d//%d", mcnt, mcnt2);
      break;

    case wordbound:
      printf("/wordbound");
      break;

    case notwordbound:
      printf("/notwordbound");
      break;

    case wordbeg:
      printf("/wordbeg");
      break;

    case wordend:
      printf("/wordend");

    case wordchar:
      printf("/wordchar");
      break;
	  
    case notwordchar:
      printf("/notwordchar");
      break;

    case begbuf:
      printf("/begbuf");
      break;

    case endbuf:
      printf("/endbuf");
      break;

    case endbuf2:
      printf("/endbuf2");
      break;

    case begpos:
      printf("/begpos");
      break;

    default:
      printf("?%d", *(p-1));
    }
  }
  printf("/\n");
}


static void
print_compiled_pattern(bufp)
     struct re_pattern_buffer *bufp;
{
  unsigned char *buffer = (unsigned char*)bufp->buffer;

  print_partial_compiled_pattern(buffer, buffer + bufp->used);
}

static char*
calculate_must_string(start, end)
     char *start;
     char *end;
{
  int mcnt;
  int max = 0;
  char *p = start;
  char *pend = end;
  char *must = 0;

  if (start == NULL) return 0;

  /* Loop over pattern commands.  */
  while (p < pend) {
    switch ((enum regexpcode)*p++) {
    case unused:
      break;

    case exactn:
      mcnt = *p;
      if (mcnt > max) {
	must = p;
	max = mcnt;
      }
      p += mcnt+1;
      break;

    case start_memory:
    case stop_memory:
      p += 2;
      break;

    case duplicate:
      p++;
      break;

    case casefold_on:
    case casefold_off:
      return 0;		/* should not check must_string */

    case pop_and_fail:
    case anychar:
    case anychar_repeat:
    case begline:
    case endline:
    case wordbound:
    case notwordbound:
    case wordbeg:
    case wordend:
    case wordchar:
    case notwordchar:
    case begbuf:
    case endbuf:
    case endbuf2:
    case begpos:
    case push_dummy_failure:
    case start_paren:
    case stop_paren:
    case option_set:
      break;

    case charset:
    case charset_not:
      mcnt = *p++;
      p += mcnt;
      mcnt = EXTRACT_UNSIGNED_AND_INCR(p);
      while (mcnt--) {
	p += 8;
      }
      break;

    case on_failure_jump:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      if (mcnt > 0) p += mcnt;
      if ((enum regexpcode)p[-3] == jump) {
	p -= 2;
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	if (mcnt > 0) p += mcnt;
      }
      break;

    case dummy_failure_jump:
    case succeed_n: 
    case try_next:
    case jump:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      if (mcnt > 0) p += mcnt;
      break;

    case start_nowidth:
    case stop_nowidth:
    case stop_backtrack:
    case finalize_jump:
    case maybe_finalize_jump:
    case finalize_push:
      p += 2;
      break;

    case jump_n: 
    case set_number_at: 
    case finalize_push_n:
      p += 4;
      break;

    default:
      break;
    }
  }
  return must;
}

static unsigned int
read_backslash(c)
     int c;
{
  switch (c) {
  case 'n':
    return '\n';

  case 't':
    return '\t';

  case 'r':
    return '\r';

  case 'f':
    return '\f';

  case 'v':
    return '\v';

  case 'a':
    return '\007';

  case 'b':
    return '\010';

  case 'e':
    return '\033';
  }
  return c;
}

static unsigned int
read_special(p, pend, pp)
     const char *p, *pend, **pp;
{
  int c;

  PATFETCH_RAW(c);
  switch (c) {
  case 'M':
    PATFETCH_RAW(c);
    if (c != '-') return -1;
    PATFETCH_RAW(c);
    *pp = p;
    if (c == '\\') {
      return read_special(p, pend, pp) | 0x80;
    }
    else if (c == -1) return ~0;
    else {
      return ((c & 0xff) | 0x80);
    }

  case 'C':
    PATFETCH_RAW(c);
    if (c != '-') return ~0;
  case 'c':
    PATFETCH_RAW(c);
    *pp = p;
    if (c == '\\') {
      c = read_special(p, pend, pp);
    }
    else if (c == '?') return 0177;
    else if (c == -1) return ~0;
    return c & 0x9f;
  default:
    return read_backslash(c);
  }

 end_of_pattern:
  return ~0;
}

/* re_compile_pattern takes a regular-expression string
   and converts it into a buffer full of byte commands for matching.

   PATTERN   is the address of the pattern string
   SIZE      is the length of it.
   BUFP	    is a  struct re_pattern_buffer *  which points to the info
	     on where to store the byte commands.
	     This structure contains a  char *  which points to the
	     actual space, which should have been obtained with malloc.
	     re_compile_pattern may use realloc to grow the buffer space.

   The number of bytes of commands can be found out by looking in
   the `struct re_pattern_buffer' that bufp pointed to, after
   re_compile_pattern returns. */

char *
re_compile_pattern(pattern, size, bufp)
     const char *pattern;
     int size;
     struct re_pattern_buffer *bufp;
{
  register char *b = bufp->buffer;
  register const char *p = pattern;
  const char *nextp;
  const char *pend = pattern + size;
  register unsigned int c, c1 = 0;
  const char *p0;
  int numlen;
#define ERROR_MSG_MAX_SIZE 200
  static char error_msg[ERROR_MSG_MAX_SIZE+1];

  /* Address of the count-byte of the most recently inserted `exactn'
     command.  This makes it possible to tell whether a new exact-match
     character can be added to that command or requires a new `exactn'
     command.  */

  char *pending_exact = 0;

  /* Address of the place where a forward-jump should go to the end of
     the containing expression.  Each alternative of an `or', except the
     last, ends with a forward-jump of this sort.  */

  char *fixup_alt_jump = 0;

  /* Address of start of the most recently finished expression.
     This tells postfix * where to find the start of its operand.  */

  char *laststart = 0;

  /* In processing a repeat, 1 means zero matches is allowed.  */

  char zero_times_ok;

  /* In processing a repeat, 1 means many matches is allowed.  */

  char many_times_ok;

  /* In processing a repeat, 1 means non-greedy matches.  */

  char greedy;

  /* Address of beginning of regexp, or inside of last (.  */

  char *begalt = b;

  /* Place in the uncompiled pattern (i.e., the {) to
     which to go back if the interval is invalid.  */
  const char *beg_interval;

  /* In processing an interval, at least this many matches must be made.  */
  int lower_bound;

  /* In processing an interval, at most this many matches can be made.  */
  int upper_bound;

  /* Stack of information saved by ( and restored by ).
     Five stack elements are pushed by each (:
     First, the value of b.
     Second, the value of fixup_alt_jump.
     Third, the value of begalt.
     Fourth, the value of regnum.
     Fifth, the type of the paren. */

  int stacka[40];
  int *stackb = stacka;
  int *stackp = stackb;
  int *stacke = stackb + 40;

  /* Counts ('s as they are encountered.  Remembered for the matching ),
     where it becomes the register number to put in the stop_memory
     command.  */

  int regnum = 1;

  int range = 0;
  int had_mbchar = 0;
  int had_num_literal = 0;
  int had_char_class = 0;

  int options = bufp->options;

  bufp->fastmap_accurate = 0;
  bufp->must = 0;
  bufp->must_skip = 0;

  /* Initialize the syntax table.  */
  init_syntax_once();

  if (bufp->allocated == 0) {
    bufp->allocated = INIT_BUF_SIZE;
    /* EXTEND_BUFFER loses when bufp->allocated is 0.  */
    bufp->buffer = (char*)xrealloc(bufp->buffer, INIT_BUF_SIZE);
    if (!bufp->buffer) goto memory_exhausted; /* this not happen */
    begalt = b = bufp->buffer;
  }

  while (p != pend) {
    PATFETCH(c);

    switch (c) {
    case '$':
      if (bufp->options & RE_OPTION_SINGLELINE) {
	BUFPUSH(endbuf);
      }
      else {
	p0 = p;
	/* When testing what follows the $,
	   look past the \-constructs that don't consume anything.  */

	while (p0 != pend) {
	  if (*p0 == '\\' && p0 + 1 != pend
	      && (p0[1] == 'b' || p0[1] == 'B'))
	    p0 += 2;
	  else
	    break;
	}
	BUFPUSH(endline);
      }
      break;

    case '^':
      if (bufp->options & RE_OPTION_SINGLELINE)
	BUFPUSH(begbuf);
      else
	BUFPUSH(begline);
      break;

    case '+':
    case '?':
    case '*':
      /* If there is no previous pattern, char not special. */
      if (!laststart) {
	snprintf(error_msg, ERROR_MSG_MAX_SIZE, 
		 "invalid regular expression; there's no previous pattern, to which '%c' would define cardinality at %d", 
		 c, p-pattern);
	FREE_AND_RETURN(stackb, error_msg);
      }
      /* If there is a sequence of repetition chars,
	 collapse it down to just one.  */
      zero_times_ok = c != '+';
      many_times_ok = c != '?';
      greedy = 1;
      if (p != pend) {
	PATFETCH(c);
	switch (c) {
	case '?':
	  greedy = 0;
	  break;
	case '*':
	case '+':
	  goto nested_meta;
	default:
	  PATUNFETCH;
	  break;
	}
      }

    repeat:
      /* Star, etc. applied to an empty pattern is equivalent
	 to an empty pattern.  */
      if (!laststart)  
	break;

      if (greedy && many_times_ok && *laststart == anychar && b - laststart <= 2) {
	if (b[-1] == stop_paren)
	  b--;
	if (zero_times_ok)
	  *laststart = anychar_repeat;
	else {
	  BUFPUSH(anychar_repeat);
	}
	break;
      }
      /* Now we know whether or not zero matches is allowed
	 and also whether or not two or more matches is allowed.  */
      if (many_times_ok) {
	/* If more than one repetition is allowed, put in at the
	   end a backward relative jump from b to before the next
	   jump we're going to put in below (which jumps from
	   laststart to after this jump).  */
	GET_BUFFER_SPACE(3);
	store_jump(b,greedy?maybe_finalize_jump:finalize_push,laststart-3);
	b += 3;  	/* Because store_jump put stuff here.  */
      }

      /* On failure, jump from laststart to next pattern, which will be the
	 end of the buffer after this jump is inserted.  */
      GET_BUFFER_SPACE(3);
      insert_jump(on_failure_jump, laststart, b + 3, b);
      b += 3;

      if (zero_times_ok) {
	if (greedy == 0) {
	  GET_BUFFER_SPACE(3);
	  insert_jump(try_next, laststart, b + 3, b);
	  b += 3;
	}
      }
      else {
	/* At least one repetition is required, so insert a
	   `dummy_failure_jump' before the initial
	   `on_failure_jump' instruction of the loop. This
	   effects a skip over that instruction the first time
	   we hit that loop.  */
	GET_BUFFER_SPACE(3);
	insert_jump(dummy_failure_jump, laststart, laststart + 6, b);
	b += 3;
      }
      break;

    case '.':
      laststart = b;
      BUFPUSH(anychar);
      break;

    case '[':
      if (p == pend)
	FREE_AND_RETURN(stackb, "invalid regular expression; '[' can't be the last character ie. can't start range at the end of pattern");
      while ((b - bufp->buffer + 9 + (1 << BYTEWIDTH) / BYTEWIDTH)
	     > bufp->allocated)
	EXTEND_BUFFER;

      laststart = b;
      if (*p == '^') {
	BUFPUSH(charset_not); 
	p++;
      }
      else
	BUFPUSH(charset);
      p0 = p;

      BUFPUSH((1 << BYTEWIDTH) / BYTEWIDTH);
      /* Clear the whole map */
      memset(b, 0, (1 << BYTEWIDTH) / BYTEWIDTH + 2);

      had_mbchar = 0;
      had_num_literal = 0;
      had_char_class = 0;

      /* Read in characters and ranges, setting map bits.  */
      for (;;) {
	int size;
	unsigned last = (unsigned)-1;

	if ((size = EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH]))
	    || current_mbctype) {
	  /* Ensure the space is enough to hold another interval
	     of multi-byte chars in charset(_not)?.  */
	  size = (1 << BYTEWIDTH) / BYTEWIDTH + 2 + size*8 + 8;
	  while (b + size + 1 > bufp->buffer + bufp->allocated)
	    EXTEND_BUFFER;
	}
      range_retry:
	if (range && had_char_class) {
	  FREE_AND_RETURN(stackb, "invalid regular expression; can't use character class as an end value of range");
	}
	PATFETCH(c);

	if (c == ']') {
	  if (p == p0 + 1) {
	    if (p == pend)
	      FREE_AND_RETURN(stackb, "invalid regular expression; empty character class");
	  }
	  else 
	    /* Stop if this isn't merely a ] inside a bracket
	       expression, but rather the end of a bracket
	       expression.  */
	    break;
	}
	/* Look ahead to see if it's a range when the last thing
	   was a character class.  */
	if (had_char_class && c == '-' && *p != ']')
	  FREE_AND_RETURN(stackb, "invalid regular expression; can't use character class as a start value of range");
	if (ismbchar(c)) {
	  PATFETCH_MBC(c);
	  had_mbchar++;
	}
	had_char_class = 0;

	/* \ escapes characters when inside [...].  */
	if (c == '\\') {
	  PATFETCH_RAW(c);
	  switch (c) {
	  case 'w':
	    for (c = 0; c < (1 << BYTEWIDTH); c++) {
	      if (SYNTAX(c) == Sword ||
		  (!current_mbctype && SYNTAX(c) == Sword2))
		SET_LIST_BIT(c);
	    }
	    if (current_mbctype) {
	      set_list_bits(0x80, 0xffffffff, b);
	    }
	    had_char_class = 1;
	    last = -1;
	    continue;

	  case 'W':
	    for (c = 0; c < (1 << BYTEWIDTH); c++) {
	      if (SYNTAX(c) != Sword &&
		  ((current_mbctype && !re_mbctab[c]) ||
		  (!current_mbctype && SYNTAX(c) != Sword2)))
		SET_LIST_BIT(c);
	    }
	    had_char_class = 1;
	    last = -1;
	    continue;

	  case 's':
	    for (c = 0; c < 256; c++)
	      if (ISSPACE(c))
		SET_LIST_BIT(c);
	    had_char_class = 1;
	    last = -1;
	    continue;

	  case 'S':
	    for (c = 0; c < 256; c++)
	      if (!ISSPACE(c))
		SET_LIST_BIT(c);
	    if (current_mbctype)
	      set_list_bits(0x80, 0xffffffff, b);
	    had_char_class = 1;
	    last = -1;
	    continue;

	  case 'd':
	    for (c = '0'; c <= '9'; c++)
	      SET_LIST_BIT(c);
	    had_char_class = 1;
	    last = -1;
	    continue;

	  case 'D':
	    for (c = 0; c < 256; c++)
	      if (!ISDIGIT(c))
		SET_LIST_BIT(c);
	    if (current_mbctype)
	      set_list_bits(0x80, 0xffffffff, b);
	    had_char_class = 1;
	    last = -1;
	    continue;

	  case 'x':
	    c = scan_hex(p, 2, &numlen);
	    if (numlen == 0) goto invalid_escape;
	    p += numlen;
	    had_num_literal = 1;
	    break;

	  case '0': case '1': case '2': case '3': case '4':
	  case '5': case '6': case '7': case '8': case '9':
	    PATUNFETCH;
	    c = scan_oct(p, 3, &numlen);
	    p += numlen;
	    had_num_literal = 1;
	    break;

	  case 'M':
	  case 'C':
	  case 'c':
	    {
	      char *pp;

	      --p;
	      c = read_special(p, pend, &pp);
	      if (c > 255) goto invalid_escape;
	      p = pp;
	      had_num_literal = 1;
	    }
	    break;

	  default:
	    c = read_backslash(c);
	    if (ismbchar(c)) {
	      PATFETCH_MBC(c);
	      had_mbchar++;
	    }
	    break;
	  }
	}

	/* Get a range.  */
	if (range) {
	  if (last > c)
	    goto invalid_pattern;

	  range = 0;
	  if (had_mbchar == 0) {
	    for (;last<=c;last++)
	      SET_LIST_BIT(last);
	  }
	  else if (had_mbchar == 2) {
	    set_list_bits(last, c, b);
	  }
	  else {
	    /* restriction: range between sbc and mbc */
	    goto invalid_pattern;
	  }
	}
	else if (p[0] == '-' && p[1] != ']') {
	  last = c;
	  PATFETCH(c1);
	  range = 1;
	  goto range_retry;
	}
	else if (c == '[' && *p == ':') {
	  /* Leave room for the null.  */
	  char str[CHAR_CLASS_MAX_LENGTH + 1];

	  PATFETCH_RAW(c);
	  c1 = 0;

	  /* If pattern is `[[:'.  */
	  if (p == pend) 
	    FREE_AND_RETURN(stackb, "invalid regular expression; re can't end '[[:'");

	  for (;;) {
	    PATFETCH (c);
	    if (c == ':' || c == ']' || p == pend
		|| c1 == CHAR_CLASS_MAX_LENGTH)
	      break;
	    str[c1++] = c;
	  }
	  str[c1] = '\0';

	  /* If isn't a word bracketed by `[:' and:`]':
	     undo the ending character, the letters, and leave 
	     the leading `:' and `[' (but set bits for them).  */
	  if (c == ':' && *p == ']') {
	    int ch;
	    char is_alnum = STREQ(str, "alnum");
	    char is_alpha = STREQ(str, "alpha");
	    char is_blank = STREQ(str, "blank");
	    char is_cntrl = STREQ(str, "cntrl");
	    char is_digit = STREQ(str, "digit");
	    char is_graph = STREQ(str, "graph");
	    char is_lower = STREQ(str, "lower");
	    char is_print = STREQ(str, "print");
	    char is_punct = STREQ(str, "punct");
	    char is_space = STREQ(str, "space");
	    char is_upper = STREQ(str, "upper");
	    char is_xdigit = STREQ(str, "xdigit");

	    if (!IS_CHAR_CLASS(str)){
	      snprintf(error_msg, ERROR_MSG_MAX_SIZE, 
		       "invalid regular expression; [:%s:] is not a character class", str);
	      FREE_AND_RETURN(stackb, error_msg);
	    }

	    /* Throw away the ] at the end of the character class.  */
	    PATFETCH(c);

	    if (p == pend) 
	      FREE_AND_RETURN(stackb, "invalid regular expression; range doesn't have ending ']' after a character class");

	    for (ch = 0; ch < 1 << BYTEWIDTH; ch++) {
	      if (   (is_alnum  && ISALNUM(ch))
		  || (is_alpha  && ISALPHA(ch))
		  || (is_blank  && ISBLANK(ch))
		  || (is_cntrl  && ISCNTRL(ch))
		  || (is_digit  && ISDIGIT(ch))
		  || (is_graph  && ISGRAPH(ch))
		  || (is_lower  && ISLOWER(ch))
		  || (is_print  && ISPRINT(ch))
		  || (is_punct  && ISPUNCT(ch))
		  || (is_space  && ISSPACE(ch))
		  || (is_upper  && ISUPPER(ch))
		  || (is_xdigit && ISXDIGIT(ch)))
		SET_LIST_BIT(ch);
	    }
	    had_char_class = 1;
	  }
	  else {
	    c1++;
	    while (c1--)    
	      PATUNFETCH;
	    SET_LIST_BIT(TRANSLATE_P()?translate['[']:'[');
	    SET_LIST_BIT(TRANSLATE_P()?translate[':']:':');
	    had_char_class = 0;
	    last = ':';
	  }
	}
	else if (had_mbchar == 0 && (!current_mbctype || !had_num_literal)) {
	  SET_LIST_BIT(c);
	  had_num_literal = 0;
	}
	else
	  set_list_bits(c, c, b);
	had_mbchar = 0;
      }

      /* Discard any character set/class bitmap bytes that are all
	 0 at the end of the map. Decrement the map-length byte too.  */
      while ((int)b[-1] > 0 && b[b[-1] - 1] == 0) 
	b[-1]--; 
      if (b[-1] != (1 << BYTEWIDTH) / BYTEWIDTH)
	memmove(&b[(unsigned char)b[-1]], &b[(1 << BYTEWIDTH) / BYTEWIDTH],
		2 + EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH])*8);
      b += b[-1] + 2 + EXTRACT_UNSIGNED(&b[(unsigned char)b[-1]])*8;
      break;

    case '(':
      {
	int old_options = options;
	int push_option = 0;
	int casefold = 0;

	PATFETCH(c);
	if (c == '?') {
	  int negative = 0;

	  PATFETCH_RAW(c);
	  switch (c) {
	  case 'x': case 'm': case 'i': case '-':
	    for (;;) {
	      switch (c) {
	      case '-':
		negative = 1;
		break;

	      case ':':
	      case ')':
		break;

	      case 'x':
		if (negative)
		  options &= ~RE_OPTION_EXTENDED;
		else
		  options |= RE_OPTION_EXTENDED;
		break;

	      case 'm':
		if (negative) {
		  if (options&RE_OPTION_MULTILINE) {
		    options &= ~RE_OPTION_MULTILINE;
		  }
		}
		else if (!(options&RE_OPTION_MULTILINE)) {
		  options |= RE_OPTION_MULTILINE;
		}
		push_option = 1;
		break;

	      case 'i':
		if (negative) {
		  if (options&RE_OPTION_IGNORECASE) {
		    options &= ~RE_OPTION_IGNORECASE;
		  }
		}
		else if (!(options&RE_OPTION_IGNORECASE)) {
		  options |= RE_OPTION_IGNORECASE;
		}
		casefold = 1;
		break;

	      default:
		FREE_AND_RETURN(stackb, "undefined (?...) inline option");
	      }
	      if (c == ')') {
		c = '#';	/* read whole in-line options */
		break;
	      }
	      if (c == ':') break;
	      PATFETCH_RAW(c);
	    }
	    break;

	  case '#':
	    for (;;) {
	      PATFETCH(c);
	      if (c == ')') break;
	    }
	    c = '#';
	    break;

	  case ':':
	  case '=':
	  case '!':
	  case '>':
	    break;

	  default:
	    FREE_AND_RETURN(stackb, "undefined (?...) sequence");
	  }
	}
	else {
	  PATUNFETCH;
	  c = '(';
	}
	if (c == '#') {
	  if (push_option) {
	    BUFPUSH(option_set);
	    BUFPUSH(options);
	  }
	  if (casefold) {
	    if (options & RE_OPTION_IGNORECASE)
	      BUFPUSH(casefold_on);
	    else
	      BUFPUSH(casefold_off);
	  }
	  break;
	}
	if (stackp+8 >= stacke) {
	  DOUBLE_STACK(int);
	}

	/* Laststart should point to the start_memory that we are about
	   to push (unless the pattern has RE_NREGS or more ('s).  */
	/* obsolete: now RE_NREGS is just a default register size. */
	*stackp++ = b - bufp->buffer;    
	*stackp++ = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
	*stackp++ = begalt - bufp->buffer;
	switch (c) {
	case '(':
	  BUFPUSH(start_memory);
	  BUFPUSH(regnum);
	  *stackp++ = regnum++;
	  *stackp++ = b - bufp->buffer;
	  BUFPUSH(0);
	  /* too many ()'s to fit in a byte. (max 254) */
	  if (regnum >= RE_REG_MAX) goto too_big;
	  break;

	case '=':
	case '!':
	case '>':
	  BUFPUSH(start_nowidth);
	  *stackp++ = b - bufp->buffer;
	  BUFPUSH(0);	/* temporary value */
	  BUFPUSH(0);
	  if (c != '!') break;

	  BUFPUSH(on_failure_jump);
	  *stackp++ = b - bufp->buffer;
	  BUFPUSH(0);	/* temporary value */
	  BUFPUSH(0);
	  break;

	case ':':
	  BUFPUSH(start_paren);
	  pending_exact = 0;
	default:
	  break;
	}
	if (push_option) {
	  BUFPUSH(option_set);
	  BUFPUSH(options);
	}
	if (casefold) {
	  if (options & RE_OPTION_IGNORECASE)
	    BUFPUSH(casefold_on);
	  else
	    BUFPUSH(casefold_off);
	}
	*stackp++ = c;
	*stackp++ = old_options;
	fixup_alt_jump = 0;
	laststart = 0;
	begalt = b;
      }
      break;

    case ')':
      if (stackp == stackb) 
	FREE_AND_RETURN(stackb, "unmatched )");

      pending_exact = 0;
      if (fixup_alt_jump) {
	/* Push a dummy failure point at the end of the
	   alternative for a possible future
	   `finalize_jump' to pop.  See comments at
	   `push_dummy_failure' in `re_match'.  */
	BUFPUSH(push_dummy_failure);

	/* We allocated space for this jump when we assigned
	   to `fixup_alt_jump', in the `handle_alt' case below.  */
	store_jump(fixup_alt_jump, jump, b);
      }
      if (options != stackp[-1]) {
	if ((options ^ stackp[-1]) & RE_OPTION_IGNORECASE) {
	  BUFPUSH((options&RE_OPTION_IGNORECASE)?casefold_off:casefold_on);
	}
	if ((options ^ stackp[-1]) != RE_OPTION_IGNORECASE) {
	  BUFPUSH(option_set);
	  BUFPUSH(stackp[-1]);
	}
      }
      p0 = b;
      options = *--stackp;
      switch (c = *--stackp) {
      case '(':
	{
	  char *loc = bufp->buffer + *--stackp;
	  *loc = regnum - stackp[-1];
	  BUFPUSH(stop_memory);
	  BUFPUSH(stackp[-1]);
	  BUFPUSH(regnum - stackp[-1]);
	  stackp--;
	}
	break;

      case '!':
	BUFPUSH(pop_and_fail);
	/* back patch */
	STORE_NUMBER(bufp->buffer+stackp[-1], b - bufp->buffer - stackp[-1] - 2);
	stackp--;
	/* fall through */
      case '=':
	BUFPUSH(stop_nowidth);
	/* tell stack-pos place to start_nowidth */
	STORE_NUMBER(bufp->buffer+stackp[-1], b - bufp->buffer - stackp[-1] - 2);
	BUFPUSH(0);	/* space to hold stack pos */
	BUFPUSH(0);
	stackp--;
	break;

      case '>':
	BUFPUSH(stop_backtrack);
	/* tell stack-pos place to start_nowidth */
	STORE_NUMBER(bufp->buffer+stackp[-1], b - bufp->buffer - stackp[-1] - 2);
	BUFPUSH(0);	/* space to hold stack pos */
	BUFPUSH(0);
	stackp--;
	break;

      case ':':
	BUFPUSH(stop_paren);
	break;

      default:
	break;
      }
      begalt = *--stackp + bufp->buffer;
      stackp--;
      fixup_alt_jump = *stackp ? *stackp + bufp->buffer - 1 : 0;
      laststart = *--stackp + bufp->buffer;
      if (c == '!' || c == '=') laststart = b;
      break;

    case '|':
      /* Insert before the previous alternative a jump which
	 jumps to this alternative if the former fails.  */
      GET_BUFFER_SPACE(3);
      insert_jump(on_failure_jump, begalt, b + 6, b);
      pending_exact = 0;
      b += 3;
      /* The alternative before this one has a jump after it
	 which gets executed if it gets matched.  Adjust that
	 jump so it will jump to this alternative's analogous
	 jump (put in below, which in turn will jump to the next
	 (if any) alternative's such jump, etc.).  The last such
	 jump jumps to the correct final destination.  A picture:
	 _____ _____ 
	 |   | |   |   
	 |   v |   v 
	 a | b   | c   

	 If we are at `b', then fixup_alt_jump right now points to a
	 three-byte space after `a'.  We'll put in the jump, set
	 fixup_alt_jump to right after `b', and leave behind three
	 bytes which we'll fill in when we get to after `c'.  */

      if (fixup_alt_jump)
	store_jump(fixup_alt_jump, jump_past_alt, b);

      /* Mark and leave space for a jump after this alternative,
	 to be filled in later either by next alternative or
	 when know we're at the end of a series of alternatives.  */
      fixup_alt_jump = b;
      GET_BUFFER_SPACE(3);
      b += 3;

      laststart = 0;
      begalt = b;
      break;

    case '{':
      /* If there is no previous pattern, this is an invalid pattern.  */
      if (!laststart) {
	snprintf(error_msg, ERROR_MSG_MAX_SIZE, 
		 "invalid regular expression; there's no previous pattern, to which '{' would define cardinality at %d", 
		 p-pattern);
	FREE_AND_RETURN(stackb, error_msg);
      }
      if( p == pend)
	FREE_AND_RETURN(stackb, "invalid regular expression; '{' can't be last character" );

      beg_interval = p - 1;

      lower_bound = -1;			/* So can see if are set.  */
      upper_bound = -1;
      GET_UNSIGNED_NUMBER(lower_bound);
      if (c == ',') {
	GET_UNSIGNED_NUMBER(upper_bound);
      }
      else
	/* Interval such as `{1}' => match exactly once. */
	upper_bound = lower_bound;

      if (lower_bound < 0 || c != '}')
	goto unfetch_interval;

      if (lower_bound >= RE_DUP_MAX || upper_bound >= RE_DUP_MAX)
	FREE_AND_RETURN(stackb, "too big quantifier in {,}");
      if (upper_bound < 0) upper_bound = RE_DUP_MAX;
      if (lower_bound > upper_bound)
	FREE_AND_RETURN(stackb, "can't do {n,m} with n > m");

      beg_interval = 0;
      pending_exact = 0;

      greedy = 1;
      if (p != pend) {
	PATFETCH(c);
	if (c == '?') greedy = 0;
	else PATUNFETCH;
      }

      if (lower_bound == 0) {
	zero_times_ok = 1;
	if (upper_bound == RE_DUP_MAX) {
	  many_times_ok = 1;
	  goto repeat;
	}
	if (upper_bound == 1) {
	  many_times_ok = 0;
	  goto repeat;
	}
      }
      if (lower_bound == 1) {
	if (upper_bound == 1) {
	  /* No need to repeat */
	  break;
	}
	if (upper_bound == RE_DUP_MAX) {
	  many_times_ok = 1;
	  zero_times_ok = 0;
	  goto repeat;
	}
      }

      /* If upper_bound is zero, don't want to succeed at all; 
	 jump from laststart to b + 3, which will be the end of
	 the buffer after this jump is inserted.  */

      if (upper_bound == 0) {
	GET_BUFFER_SPACE(3);
	insert_jump(jump, laststart, b + 3, b);
	b += 3;
	break;
      }

      /* If lower_bound == upper_bound, repeat count can be removed */
      if (lower_bound == upper_bound) {
	int mcnt;
	int skip_stop_paren = 0;

	if (b[-1] == stop_paren) {
	  skip_stop_paren = 1;
	  b--;
	}

	if (*laststart == exactn && laststart[1]+2 == b - laststart
	    && laststart[1]*lower_bound < 256) {
	  mcnt = laststart[1];
	  GET_BUFFER_SPACE((lower_bound-1)*mcnt);
	  laststart[1] = lower_bound*mcnt;
	  while (--lower_bound) {
	    memcpy(b, laststart+2, mcnt);
	    b += mcnt;
	  }
	  if (skip_stop_paren) BUFPUSH(stop_paren);
	  break;
	}

	if (lower_bound < 5 && b - laststart < 10) {
	  /* 5 and 10 are the magic numbers */

	  mcnt = b - laststart;
	  GET_BUFFER_SPACE((lower_bound-1)*mcnt);
	  while (--lower_bound) {
	    memcpy(b, laststart, mcnt);
	    b += mcnt;
	  }
	  if (skip_stop_paren) BUFPUSH(stop_paren);
	  break;
	}
	if (skip_stop_paren) b++; /* push back stop_paren */
      }

      /* Otherwise, we have a nontrivial interval.  When
	 we're all done, the pattern will look like:
	 set_number_at <jump count> <upper bound>
	 set_number_at <succeed_n count> <lower bound>
	 succeed_n <after jump addr> <succed_n count>
	 <body of loop>
	 jump_n <succeed_n addr> <jump count>
	 (The upper bound and `jump_n' are omitted if
	 `upper_bound' is 1, though.)  */
      { /* If the upper bound is > 1, we need to insert
	   more at the end of the loop.  */
	unsigned nbytes = upper_bound == 1 ? 10 : 20;

	GET_BUFFER_SPACE(nbytes);
	/* Initialize lower bound of the `succeed_n', even
	   though it will be set during matching by its
	   attendant `set_number_at' (inserted next),
	   because `re_compile_fastmap' needs to know.
	   Jump to the `jump_n' we might insert below.  */
	insert_jump_n(succeed_n, laststart, b + (nbytes/2), 
		      b, lower_bound);
	b += 5; 	/* Just increment for the succeed_n here.  */

	/* Code to initialize the lower bound.  Insert 
	   before the `succeed_n'.  The `5' is the last two
	   bytes of this `set_number_at', plus 3 bytes of
	   the following `succeed_n'.  */
	insert_op_2(set_number_at, laststart, b, 5, lower_bound);
	b += 5;

	if (upper_bound > 1) {
	  /* More than one repetition is allowed, so
	     append a backward jump to the `succeed_n'
	     that starts this interval.

	     When we've reached this during matching,
	     we'll have matched the interval once, so
	     jump back only `upper_bound - 1' times.  */
	  GET_BUFFER_SPACE(5);
	  store_jump_n(b, greedy?jump_n:finalize_push_n, laststart + 5,
		       upper_bound - 1);
	  b += 5;

	  /* The location we want to set is the second
	     parameter of the `jump_n'; that is `b-2' as
	     an absolute address.  `laststart' will be
	     the `set_number_at' we're about to insert;
	     `laststart+3' the number to set, the source
	     for the relative address.  But we are
	     inserting into the middle of the pattern --
	     so everything is getting moved up by 5.
	     Conclusion: (b - 2) - (laststart + 3) + 5,
	     i.e., b - laststart.

	     We insert this at the beginning of the loop
	     so that if we fail during matching, we'll
	     reinitialize the bounds.  */
	  insert_op_2(set_number_at, laststart, b, b - laststart,
		      upper_bound - 1);
	  b += 5;
	}
      }
      break;

    unfetch_interval:
      /* If an invalid interval, match the characters as literals.  */
      p = beg_interval;
      beg_interval = 0;

      /* normal_char and normal_backslash need `c'.  */
      PATFETCH(c);	
      goto normal_char;

    case '\\':
      if (p == pend)
	FREE_AND_RETURN(stackb, "invalid regular expression; '\\' can't be last character");
      /* Do not translate the character after the \, so that we can
	 distinguish, e.g., \B from \b, even if we normally would
	 translate, e.g., B to b.  */
      PATFETCH_RAW(c);
      switch (c) {
      case 's':
      case 'S':
      case 'd':
      case 'D':
	while (b - bufp->buffer + 9 + (1 << BYTEWIDTH) / BYTEWIDTH
	       > bufp->allocated)
	  EXTEND_BUFFER;

	laststart = b;
	if (c == 's' || c == 'd') {
	  BUFPUSH(charset);
	}
	else {
	  BUFPUSH(charset_not);
	}

	BUFPUSH((1 << BYTEWIDTH) / BYTEWIDTH);
	memset(b, 0, (1 << BYTEWIDTH) / BYTEWIDTH + 2);
	if (c == 's' || c == 'S') {
	  SET_LIST_BIT(' ');
	  SET_LIST_BIT('\t');
	  SET_LIST_BIT('\n');
	  SET_LIST_BIT('\r');
	  SET_LIST_BIT('\f');
	}
	else {
	  char cc;

	  for (cc = '0'; cc <= '9'; cc++) {
	    SET_LIST_BIT(cc);
	  }
	}

	while ((int)b[-1] > 0 && b[b[-1] - 1] == 0) 
	  b[-1]--; 
	if (b[-1] != (1 << BYTEWIDTH) / BYTEWIDTH)
	  memmove(&b[(unsigned char)b[-1]], &b[(1 << BYTEWIDTH) / BYTEWIDTH],
		  2 + EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH])*8);
	b += b[-1] + 2 + EXTRACT_UNSIGNED(&b[(unsigned char)b[-1]])*8;
	break;

      case 'w':
	laststart = b;
	BUFPUSH(wordchar);
	break;

      case 'W':
	laststart = b;
	BUFPUSH(notwordchar);
	break;

#ifndef RUBY
      case '<':
	BUFPUSH(wordbeg);
	break;

      case '>':
	BUFPUSH(wordend);
	break;
#endif

      case 'b':
	BUFPUSH(wordbound);
	break;

      case 'B':
	BUFPUSH(notwordbound);
	break;

      case 'A':
	BUFPUSH(begbuf);
	break;

      case 'Z':
	if ((bufp->options & RE_OPTION_SINGLELINE) == 0) {
	  BUFPUSH(endbuf2);
	  break;
	}
	/* fall through */
      case 'z':
	BUFPUSH(endbuf);
	break;

      case 'G':
	BUFPUSH(begpos);
	break;

	/* hex */
      case 'x':
	had_mbchar = 0;
	c = scan_hex(p, 2, &numlen);
	if (numlen == 0) goto invalid_escape;
	p += numlen;
	had_num_literal = 1;
	goto numeric_char;

	/* octal */
      case '0':
	had_mbchar = 0;
	c = scan_oct(p, 2, &numlen);
	p += numlen;
	had_num_literal = 1;
	goto numeric_char;

	/* back-ref or octal */
      case '1': case '2': case '3':
      case '4': case '5': case '6':
      case '7': case '8': case '9':
	PATUNFETCH;
	p0 = p;

	had_mbchar = 0;
	c1 = 0;
	GET_UNSIGNED_NUMBER(c1);
	if (!ISDIGIT(c)) PATUNFETCH;

	if (9 < c1 && c1 >= regnum) {
	  /* need to get octal */
	  c = scan_oct(p0, 3, &numlen) & 0xff;
	  p = p0 + numlen;
	  c1 = 0;
	  had_num_literal = 1;
	  goto numeric_char;
	}

	laststart = b;
	BUFPUSH(duplicate);
	BUFPUSH(c1);
	break;

      case 'M':
      case 'C':
      case 'c':
	p0 = --p;
	c = read_special(p, pend, &p0);
	if (c > 255) goto invalid_escape;
	p = p0;
	had_num_literal = 1;
	goto numeric_char;

      default:
	c = read_backslash(c);
	goto normal_char;
      }
      break;

    case '#':
      if (options & RE_OPTION_EXTENDED) {
	while (p != pend) {
	  PATFETCH(c);
	  if (c == '\n') break;
	}
	break;
      }
      goto normal_char;

    case ' ':
    case '\t':
    case '\f':
    case '\r':
    case '\n':
      if (options & RE_OPTION_EXTENDED)
	break;

    default:
    normal_char:		/* Expects the character in `c'.  */
      had_mbchar = 0;
      if (ismbchar(c)) {
	had_mbchar = 1;
	c1 = p - pattern;
      }
    numeric_char:
      nextp = p + mbclen(c) - 1;
      if (!pending_exact || pending_exact + *pending_exact + 1 != b
	  || *pending_exact >= (c1 ? 0176 : 0177)
	  || *nextp == '+' || *nextp == '?'
	  || *nextp == '*' || *nextp == '^'
	  || *nextp == '{') {
	laststart = b;
	BUFPUSH(exactn);
	pending_exact = b;
	BUFPUSH(0);
      }
      if (had_num_literal || c == 0xff) {
	BUFPUSH(0xff);
	(*pending_exact)++;
	had_num_literal = 0;
      }
      BUFPUSH(c);
      (*pending_exact)++;
      if (had_mbchar) {
	int len = mbclen(c) - 1;
	while (len--) {
	  PATFETCH_RAW(c);
	  BUFPUSH(c);
	  (*pending_exact)++;
	}
      }
    }
  }

  if (fixup_alt_jump)
    store_jump(fixup_alt_jump, jump, b);

  if (stackp != stackb)
    FREE_AND_RETURN(stackb, "unmatched (");

  /* set optimize flags */
  laststart = bufp->buffer;
  if (laststart != b) {
    if (*laststart == start_memory) laststart += 3;
    if (*laststart == dummy_failure_jump) laststart += 3;
    else if (*laststart == try_next) laststart += 3;
    if (*laststart == anychar_repeat) {
      bufp->options |= RE_OPTIMIZE_ANCHOR;
    }
  }

  bufp->used = b - bufp->buffer;
  bufp->re_nsub = regnum;
  laststart = bufp->buffer;
  if (laststart != b) {
    if (*laststart == start_memory) laststart += 3;
    if (*laststart == exactn) {
      bufp->options |= RE_OPTIMIZE_EXACTN;
      bufp->must = laststart+1;
    }
  }
  if (!bufp->must) {
    bufp->must = calculate_must_string(bufp->buffer, b);
  }
  if (current_mbctype == MBCTYPE_SJIS) bufp->options |= RE_OPTIMIZE_NO_BM;
  else if (bufp->must) {
    int i;
    int len = (unsigned char)bufp->must[0];

    for (i=1; i<len; i++) {
      if ((unsigned char)bufp->must[i] == 0xff ||
	  (current_mbctype && ismbchar(bufp->must[i]))) {
	bufp->options |= RE_OPTIMIZE_NO_BM;
	break;
      }
    }
    if (!(bufp->options & RE_OPTIMIZE_NO_BM)) {
      bufp->must_skip = (int *) xmalloc((1 << BYTEWIDTH)*sizeof(int));
      bm_init_skip(bufp->must_skip, (unsigned char*)bufp->must+1,
		   (unsigned char)bufp->must[0],
		   (unsigned char*)(MAY_TRANSLATE()?translate:0));
    }
  }

  bufp->regstart = TMALLOC(regnum, unsigned char*);
  bufp->regend = TMALLOC(regnum, unsigned char*);
  bufp->old_regstart = TMALLOC(regnum, unsigned char*);
  bufp->old_regend = TMALLOC(regnum, unsigned char*);
  bufp->reg_info = TMALLOC(regnum, register_info_type);
  bufp->best_regstart = TMALLOC(regnum, unsigned char*);
  bufp->best_regend = TMALLOC(regnum, unsigned char*);
  FREE_AND_RETURN(stackb, 0);

 invalid_pattern:
  FREE_AND_RETURN(stackb, "invalid regular expression");

 end_of_pattern:
  FREE_AND_RETURN(stackb, "premature end of regular expression");

 too_big:
  FREE_AND_RETURN(stackb, "regular expression too big");

 memory_exhausted:
  FREE_AND_RETURN(stackb, "memory exhausted");

 nested_meta:
  FREE_AND_RETURN(stackb, "nested *?+ in regexp");

 invalid_escape:
  FREE_AND_RETURN(stackb, "Invalid escape character syntax");
}

void
re_free_pattern(bufp)
     struct re_pattern_buffer *bufp;
{
  xfree(bufp->buffer);
  xfree(bufp->fastmap);
  if (bufp->must_skip) xfree(bufp->must_skip);

  xfree(bufp->regstart);
  xfree(bufp->regend);
  xfree(bufp->old_regstart);
  xfree(bufp->old_regend);
  xfree(bufp->best_regstart);
  xfree(bufp->best_regend);
  xfree(bufp->reg_info);
  xfree(bufp);
}

/* Store a jump of the form <OPCODE> <relative address>.
   Store in the location FROM a jump operation to jump to relative
   address FROM - TO.  OPCODE is the opcode to store.  */

static void
store_jump(from, opcode, to)
     char *from, *to;
     int opcode;
{
  from[0] = (char)opcode;
  STORE_NUMBER(from + 1, to - (from + 3));
}


/* Open up space before char FROM, and insert there a jump to TO.
   CURRENT_END gives the end of the storage not in use, so we know 
   how much data to copy up. OP is the opcode of the jump to insert.

   If you call this function, you must zero out pending_exact.  */

static void
insert_jump(op, from, to, current_end)
     int op;
     char *from, *to, *current_end;
{
  register char *pfrom = current_end;		/* Copy from here...  */
  register char *pto = current_end + 3;		/* ...to here.  */

  while (pfrom != from)			       
    *--pto = *--pfrom;
  store_jump(from, op, to);
}


/* Store a jump of the form <opcode> <relative address> <n> .

   Store in the location FROM a jump operation to jump to relative
   address FROM - TO.  OPCODE is the opcode to store, N is a number the
   jump uses, say, to decide how many times to jump.

   If you call this function, you must zero out pending_exact.  */

static void
store_jump_n(from, opcode, to, n)
     char *from, *to;
     int opcode;
     unsigned n;
{
  from[0] = (char)opcode;
  STORE_NUMBER(from + 1, to - (from + 3));
  STORE_NUMBER(from + 3, n);
}


/* Similar to insert_jump, but handles a jump which needs an extra
   number to handle minimum and maximum cases.  Open up space at
   location FROM, and insert there a jump to TO.  CURRENT_END gives the
   end of the storage in use, so we know how much data to copy up. OP is
   the opcode of the jump to insert.

   If you call this function, you must zero out pending_exact.  */

static void
insert_jump_n(op, from, to, current_end, n)
     int op;
     char *from, *to, *current_end;
     unsigned n;
{
  register char *pfrom = current_end;		/* Copy from here...  */
  register char *pto = current_end + 5;		/* ...to here.  */

  while (pfrom != from)			       
    *--pto = *--pfrom;
  store_jump_n(from, op, to, n);
}


/* Open up space at location THERE, and insert operation OP.
   CURRENT_END gives the end of the storage in use, so
   we know how much data to copy up.

   If you call this function, you must zero out pending_exact.  */

static void
insert_op(op, there, current_end)
     int op;
     char *there, *current_end;
{
  register char *pfrom = current_end;		/* Copy from here...  */
  register char *pto = current_end + 1;		/* ...to here.  */

  while (pfrom != there)			       
    *--pto = *--pfrom;

  there[0] = (char)op;
}


/* Open up space at location THERE, and insert operation OP followed by
   NUM_1 and NUM_2.  CURRENT_END gives the end of the storage in use, so
   we know how much data to copy up.

   If you call this function, you must zero out pending_exact.  */

static void
insert_op_2(op, there, current_end, num_1, num_2)
     int op;
     char *there, *current_end;
     int num_1, num_2;
{
  register char *pfrom = current_end;		/* Copy from here...  */
  register char *pto = current_end + 5;		/* ...to here.  */

  while (pfrom != there)			       
    *--pto = *--pfrom;

  there[0] = (char)op;
  STORE_NUMBER(there + 1, num_1);
  STORE_NUMBER(there + 3, num_2);
}


#define trans_eq(c1, c2, translate) (translate?(translate[c1]==translate[c2]):((c1)==(c2)))
static int
slow_match(little, lend, big, bend, translate)
     unsigned char *little, *lend;
     unsigned char *big, *bend;
     unsigned char *translate;
{
  int c;

  while (little < lend && big < bend) {
    c = *little++;
    if (c == 0xff)
      c = *little++;
    if (!trans_eq(*big++, c, translate)) break;
  }
  if (little == lend) return 1;
  return 0;
}

static int
slow_search(little, llen, big, blen, translate)
     unsigned char *little;
     int llen;
     unsigned char *big;
     int blen;
     char *translate;
{
  unsigned char *bsave = big;
  unsigned char *bend = big + blen;
  register int c;
  int fescape = 0;

  c = *little;
  if (c == 0xff) {
    c = little[1];
    fescape = 1;
  }
  else if (translate && !ismbchar(c)) {
    c = translate[c];
  }

  while (big < bend) {
    /* look for first character */
    if (fescape) {
      while (big < bend) {
	if (*big == c) break;
	big++;
      }
    }
    else if (translate && !ismbchar(c)) {
      while (big < bend) {
	if (ismbchar(*big)) big+=mbclen(*big)-1;
	else if (translate[*big] == c) break;
	big++;
      }
    }
    else {
      while (big < bend) {
	if (*big == c) break;
	if (ismbchar(*big)) big+=mbclen(*big)-1;
	big++;
      }
    }

    if (slow_match(little, little+llen, big, bend, translate))
      return big - bsave;

    big+=mbclen(*big);
  }
  return -1;
}

static void
bm_init_skip(skip, pat, m, translate)
     int *skip;
     unsigned char *pat;
     int m;
     const unsigned char *translate;
{
  int j, c;

  for (c=0; c<256; c++) {
    skip[c] = m;
  }
  if (translate) {
    for (j=0; j<m-1; j++) {
      skip[translate[pat[j]]] = m-1-j;
    }
  }
  else {
    for (j=0; j<m-1; j++) {
      skip[pat[j]] = m-1-j;
    }
  }
}

static int
bm_search(little, llen, big, blen, skip, translate)
     unsigned char *little;
     int llen;
     unsigned char *big;
     int blen;
     int *skip;
     unsigned char *translate;
{
  int i, j, k;

  i = llen-1;
  if (translate) {
    while (i < blen) {
      k = i;
      j = llen-1;
      while (j >= 0 && translate[big[k]] == translate[little[j]]) {
	k--;
	j--;
      }
      if (j < 0) return k+1;

      i += skip[translate[big[i]]];
    }
    return -1;
  }
  while (i < blen) {
    k = i;
    j = llen-1;
    while (j >= 0 && big[k] == little[j]) {
      k--;
      j--;
    }
    if (j < 0) return k+1;

    i += skip[big[i]];
  }
  return -1;
}

/* Given a pattern, compute a fastmap from it.  The fastmap records
   which of the (1 << BYTEWIDTH) possible characters can start a string
   that matches the pattern.  This fastmap is used by re_search to skip
   quickly over totally implausible text.

   The caller must supply the address of a (1 << BYTEWIDTH)-byte data 
   area as bufp->fastmap.
   The other components of bufp describe the pattern to be used.  */
void
re_compile_fastmap(bufp)
     struct re_pattern_buffer *bufp;
{
  unsigned char *pattern = (unsigned char*)bufp->buffer;
  int size = bufp->used;
  register char *fastmap = bufp->fastmap;
  register unsigned char *p = pattern;
  register unsigned char *pend = pattern + size;
  register int j, k;
  unsigned is_a_succeed_n;

  
  unsigned char *stacka[NFAILURES];
  unsigned char **stackb = stacka;
  unsigned char **stackp = stackb;
  unsigned char **stacke = stackb + NFAILURES;
  int options = bufp->options;

  memset(fastmap, 0, (1 << BYTEWIDTH));
  bufp->fastmap_accurate = 1;
  bufp->can_be_null = 0;

  while (p) {
    is_a_succeed_n = 0;
    if (p == pend) {
      bufp->can_be_null = 1;
      break;
    }
#ifdef SWITCH_ENUM_BUG
    switch ((int)((enum regexpcode)*p++))
#else
    switch ((enum regexpcode)*p++)
#endif
      {
      case exactn:
	if (p[1] == 0xff) {
	  if (TRANSLATE_P())
	    fastmap[translate[p[2]]] = 2;
	  else
	    fastmap[p[2]] = 2;
	  bufp->options |= RE_OPTIMIZE_BMATCH;
	}
	else if (TRANSLATE_P())
	  fastmap[translate[p[1]]] = 1;
	else
	  fastmap[p[1]] = 1;
	break;

      case begline:
      case begbuf:
      case begpos:
      case endbuf:
      case endbuf2:
      case wordbound:
      case notwordbound:
      case wordbeg:
      case wordend:
      case pop_and_fail:
      case push_dummy_failure:
      case start_paren:
      case stop_paren:
	continue;

      case casefold_on:
	bufp->options |= RE_MAY_IGNORECASE;
      case casefold_off:
	options ^= RE_OPTION_IGNORECASE;
	continue;

      case option_set:
	options = *p++;
	continue;

      case endline:
	if (TRANSLATE_P())
	  fastmap[translate['\n']] = 1;
	else
	  fastmap['\n'] = 1;
	if ((options & RE_OPTION_SINGLELINE) == 0 && bufp->can_be_null == 0)
	  bufp->can_be_null = 2;
	break;

      case jump_n:
      case finalize_jump:
      case maybe_finalize_jump:
      case jump:
      case jump_past_alt:
      case dummy_failure_jump:
      case finalize_push:
      case finalize_push_n:
	EXTRACT_NUMBER_AND_INCR(j, p);
	p += j;	
	if (j > 0)
	  continue;
	/* Jump backward reached implies we just went through
	   the body of a loop and matched nothing.
	   Opcode jumped to should be an on_failure_jump.
	   Just treat it like an ordinary jump.
	   For a * loop, it has pushed its failure point already;
	   If so, discard that as redundant.  */

	if ((enum regexpcode)*p != on_failure_jump
	    && (enum regexpcode)*p != try_next
	    && (enum regexpcode)*p != succeed_n)
	  continue;
	p++;
	EXTRACT_NUMBER_AND_INCR(j, p);
	p += j;	
	if (stackp != stackb && *stackp == p)
	  stackp--;		/* pop */
	continue;

      case try_next:
      case start_nowidth:
      case stop_nowidth:
      case stop_backtrack:
	p += 2;
	continue;

      case succeed_n:
	is_a_succeed_n = 1;
	/* Get to the number of times to succeed.  */
	EXTRACT_NUMBER(k, p + 2);
	/* Increment p past the n for when k != 0.  */
	if (k != 0) {
	  p += 4;
	  continue;
	}
	/* fall through */

      case on_failure_jump:
      EXTRACT_NUMBER_AND_INCR(j, p);
      if (p + j < pend) {
	if (stackp == stacke) {
	  EXPAND_FAIL_STACK();
	}
	*++stackp = p + j;	/* push */
      }
      else {
	bufp->can_be_null = 1;
      }
      if (is_a_succeed_n)
	EXTRACT_NUMBER_AND_INCR(k, p);	/* Skip the n.  */
      continue;

      case set_number_at:
	p += 4;
	continue;

      case start_memory:
      case stop_memory:
	p += 2;
	continue;

      case duplicate:
	bufp->can_be_null = 1;
	if (*p >= bufp->re_nsub) break;
	fastmap['\n'] = 1;
      case anychar_repeat:
      case anychar:
	for (j = 0; j < (1 << BYTEWIDTH); j++) {
	  if (j != '\n' || (options & RE_OPTION_MULTILINE))
	    fastmap[j] = 1;
	}
	if (bufp->can_be_null) {
	  FREE_AND_RETURN_VOID(stackb);
	}
	/* Don't return; check the alternative paths
	   so we can set can_be_null if appropriate.  */
	if ((enum regexpcode)p[-1] == anychar_repeat) {
	    continue;
	}
	break;

      case wordchar:
	for (j = 0; j < 0x80; j++) {
	  if (SYNTAX(j) == Sword)
	    fastmap[j] = 1;
	}
	switch (current_mbctype) {
	case MBCTYPE_ASCII:
	  for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	    if (SYNTAX(j) == Sword2)
	      fastmap[j] = 1;
	  }
	  break;
	case MBCTYPE_EUC:
	case MBCTYPE_SJIS:
	case MBCTYPE_UTF8:
	  for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	    if (re_mbctab[j])
	      fastmap[j] = 1;
	  }
	  break;
	}
	break;

      case notwordchar:
	for (j = 0; j < 0x80; j++)
	  if (SYNTAX(j) != Sword)
	    fastmap[j] = 1;
	switch (current_mbctype) {
	case MBCTYPE_ASCII:
	  for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	    if (SYNTAX(j) != Sword2)
	      fastmap[j] = 1;
	  }
	  break;
	case MBCTYPE_EUC:
	case MBCTYPE_SJIS:
	case MBCTYPE_UTF8:
	  for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	    if (!re_mbctab[j])
	      fastmap[j] = 1;
	  }
	  break;
	}
	break;

      case charset:
	/* NOTE: Charset for single-byte chars never contain
	   multi-byte char.  See set_list_bits().  */
	for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	  if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))) {
	    int tmp = TRANSLATE_P()?translate[j]:j;
	    fastmap[tmp] = 1;
	  }
	{
	  unsigned short size;
	  unsigned long c, beg, end;

	  p += p[-1] + 2;
	  size = EXTRACT_UNSIGNED(&p[-2]);
	  for (j = 0; j < (int)size; j++) {
	    c = EXTRACT_MBC(&p[j*8]);
	    beg = WC2MBC1ST(c);
	    c = EXTRACT_MBC(&p[j*8+4]);
	    end = WC2MBC1ST(c);
	    /* set bits for 1st bytes of multi-byte chars.  */
	    while (beg <= end) {
	      /* NOTE: Charset for multi-byte chars might contain
		 single-byte chars.  We must reject them. */
	      if (c < 0x100) {
		fastmap[beg] = 2;
		bufp->options |= RE_OPTIMIZE_BMATCH;
	      }
	      else if (ismbchar(beg))
		fastmap[beg] = 1;
	      beg++;
	    }
	  }
	}
	break;

      case charset_not:
	/* S: set of all single-byte chars.
	   M: set of all first bytes that can start multi-byte chars.
	   s: any set of single-byte chars.
	   m: any set of first bytes that can start multi-byte chars.

	   We assume S+M = U.
	   ___      _   _
	   s+m = (S*s+M*m).  */
	/* Chars beyond end of map must be allowed */
	/* NOTE: Charset_not for single-byte chars might contain
	   multi-byte chars.  See set_list_bits(). */
	for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
	  if (!ismbchar(j))
	    fastmap[j] = 1;

	for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	  if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))) {
	    if (!ismbchar(j))
	      fastmap[j] = 1;
	  }
	{
	  unsigned short size;
	  unsigned long c, beg;
	  int num_literal = 0;

	  p += p[-1] + 2;
	  size = EXTRACT_UNSIGNED(&p[-2]);
	  if (size == 0) {
	    for (j = 0x80; j < (1 << BYTEWIDTH); j++)
	      if (ismbchar(j))
		fastmap[j] = 1;
	    break;
	  }
	  for (j = 0,c = 0;j < (int)size; j++) {
	    unsigned int cc = EXTRACT_MBC(&p[j*8]);
	    beg = WC2MBC1ST(cc);
	    while (c <= beg) {
	      if (ismbchar(c))
		fastmap[c] = 1;
	      c++;
	    }

	    cc = EXTRACT_MBC(&p[j*8+4]);
	    if (cc < 0xff) {
	      num_literal = 1;
	      while (c <= cc) {
		if (ismbchar(c))
		  fastmap[c] = 1;
		c++;
	      }
	    }
	    c = WC2MBC1ST(cc);
	  }

	  for (j = c; j < (1 << BYTEWIDTH); j++) {
	    if (num_literal)
	      fastmap[j] = 1;
	    if (ismbchar(j))
	      fastmap[j] = 1;
	  }
	}
	break;

      case unused:	/* pacify gcc -Wall */
	break;
      }

    /* Get here means we have successfully found the possible starting
       characters of one path of the pattern.  We need not follow this
       path any farther.  Instead, look at the next alternative
       remembered in the stack.  */
    if (stackp != stackb)
      p = *stackp--;		/* pop */
    else
      break;
  }
  FREE_AND_RETURN_VOID(stackb);
}

/* adjust startpos value to the position between characters. */
int
re_adjust_startpos(bufp, string, size, startpos, range)
     struct re_pattern_buffer *bufp;
     const char *string;
     int size, startpos, range;
{
  /* Update the fastmap now if not correct already.  */
  if (!bufp->fastmap_accurate) {
    re_compile_fastmap(bufp);
  }

  /* Adjust startpos for mbc string */
  if (current_mbctype && startpos>0 && !(bufp->options&RE_OPTIMIZE_BMATCH)) {
    int i = mbc_startpos(string, startpos);

    if (i < startpos) {
      if (range > 0) {
	startpos = i + mbclen(string[i]);
      }
      else {
	int len = mbclen(string[i]);
	if (i + len <= startpos)
	  startpos = i + len;
	else
	  startpos = i;
      }
    }
  }
  return startpos;
}


/* Using the compiled pattern in BUFP->buffer, first tries to match
   STRING, starting first at index STARTPOS, then at STARTPOS + 1, and
   so on.  RANGE is the number of places to try before giving up.  If
   RANGE is negative, it searches backwards, i.e., the starting
   positions tried are STARTPOS, STARTPOS - 1, etc.  STRING is of SIZE.
   In REGS, return the indices of STRING that matched the entire
   BUFP->buffer and its contained subexpressions.

   The value returned is the position in the strings at which the match
   was found, or -1 if no match was found, or -2 if error (such as
   failure stack overflow).  */

int
re_search(bufp, string, size, startpos, range, regs)
     struct re_pattern_buffer *bufp;
     const char *string;
     int size, startpos, range;
     struct re_registers *regs;
{
  register char *fastmap = bufp->fastmap;
  int val, anchor = 0;

  /* Check for out-of-range starting position.  */
  if (startpos < 0  ||  startpos > size)
    return -1;

  /* Update the fastmap now if not correct already.  */
  if (fastmap && !bufp->fastmap_accurate) {
    re_compile_fastmap(bufp);
  }


  /* If the search isn't to be a backwards one, don't waste time in a
     search for a pattern that must be anchored.  */
  if (bufp->used > 0) {
    switch ((enum regexpcode)bufp->buffer[0]) {
    case begbuf:
    begbuf_match:
      if (range > 0) {
	if (startpos > 0) return -1;
	else {
	  val = re_match(bufp, string, size, 0, regs);
	  if (val >= 0) return 0;
	  return val;
	}
      }
      break;

    case begline:
      anchor = 1;
      break;

    case begpos:
      val = re_match(bufp, string, size, startpos, regs);
      if (val >= 0) return startpos;
      return val;

    default:
      break;
    }
  }
  if (bufp->options & RE_OPTIMIZE_ANCHOR) {
    if (bufp->options&RE_OPTION_SINGLELINE) {
      goto begbuf_match;
    }
    anchor = 1;
  }

  if (bufp->must) {
    int len = ((unsigned char*)bufp->must)[0];
    int pos, pbeg, pend;

    pbeg = startpos;
    pend = startpos + range;
    if (pbeg > pend) {		/* swap pbeg,pend */
      pos = pend; pend = pbeg; pbeg = pos;
    }
    pend = size;
    if (bufp->options & RE_OPTIMIZE_NO_BM) {
      pos = slow_search(bufp->must+1, len,
			string+pbeg, pend-pbeg,
			MAY_TRANSLATE()?translate:0);
    }
    else {
      pos = bm_search(bufp->must+1, len,
		      string+pbeg, pend-pbeg,
		      bufp->must_skip,
		      MAY_TRANSLATE()?translate:0);
    }
    if (pos == -1) return -1;
    if (range > 0 && (bufp->options & RE_OPTIMIZE_EXACTN)) {
      startpos += pos;
      range -= pos;
      if (range < 0) return -1;
    }
  }

  for (;;) {
    /* If a fastmap is supplied, skip quickly over characters that
       cannot possibly be the start of a match.  Note, however, that
       if the pattern can possibly match the null string, we must
       test it at each starting point so that we take the first null
       string we get.  */

    if (fastmap && startpos < size
	&& bufp->can_be_null != 1 && !(anchor && startpos == 0)) {
      if (range > 0) {	/* Searching forwards.  */
	register unsigned char *p, c;
	int irange = range;

	p = (unsigned char*)string+startpos;

	while (range > 0) {
	  c = *p++;
	  if (ismbchar(c)) {
	    int len;

	    if (fastmap[c])
	      break;
	    len = mbclen(c) - 1;
	    while (len--) {
	      c = *p++;
	      range--;
	      if (fastmap[c] == 2)
		goto startpos_adjust;
	    }
	  }
	  else {
	    if (fastmap[MAY_TRANSLATE() ? translate[c] : c])
	      break;
	  }
	  range--;
	}
      startpos_adjust:
	startpos += irange - range;
      }
      else {			/* Searching backwards.  */
	register unsigned char c;

	c = string[startpos];
	c &= 0xff;
	if (MAY_TRANSLATE() ? !fastmap[translate[c]] : !fastmap[c])
	  goto advance;
      }
    }

    if (startpos > size) return -1;
    if ((anchor || !bufp->can_be_null) && range > 0 && size > 0 && startpos == size)
      return -1;
    val = re_match(bufp, string, size, startpos, regs);
    if (val >= 0) return startpos;
    if (val == -2) return -2;

#ifndef NO_ALLOCA
#ifdef C_ALLOCA
    alloca(0);
#endif /* C_ALLOCA */
#endif /* NO_ALLOCA */

    if (range > 0) {
      if (anchor && startpos < size &&
	  (startpos < 1 || string[startpos-1] != '\n')) {
	while (range > 0 && string[startpos] != '\n') {
	  range--;
	  startpos++;
	}
      }
    }

  advance:
    if (!range) 
      break;
    else if (range > 0) {
      const char *d = string + startpos;

      if (ismbchar(*d)) {
	int len = mbclen(*d) - 1;
	range-=len, startpos+=len;
	if (!range)
	  break;
      }
      range--, startpos++;
    }
    else {
      range++, startpos--;
      {
	const char *s, *d, *p;

	s = string; d = string + startpos;
	for (p = d; p-- > s && ismbchar(*p); )
	  /* --p >= s would not work on 80[12]?86. 
	     (when the offset of s equals 0 other than huge model.)  */
	  ;
	if (!((d - p) & 1)) {
	  if (!range)
	    break;
	  range++, startpos--;
	}
      }
    }
  }
  return -1;
}




/* The following are used for re_match, defined below:  */

/* Accessing macros used in re_match: */

#define IS_ACTIVE(R)  ((R).bits.is_active)
#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)


/* Macros used by re_match:  */

/* I.e., regstart, regend, and reg_info.  */
#define NUM_REG_ITEMS  3

/* I.e., ptr and count.  */
#define NUM_COUNT_ITEMS 2

/* Individual items aside from the registers.  */
#define NUM_NONREG_ITEMS 4

/* We push at most this many things on the stack whenever we
   fail.  The `+ 2' refers to PATTERN_PLACE and STRING_PLACE, which are
   arguments to the PUSH_FAILURE_POINT macro.  */
#define MAX_NUM_FAILURE_ITEMS   (num_regs * NUM_REG_ITEMS + NUM_NONREG_ITEMS)

/* We push this many things on the stack whenever we fail.  */
#define NUM_FAILURE_ITEMS  (last_used_reg * NUM_REG_ITEMS + NUM_NONREG_ITEMS + 1)

/* This pushes counter information for succeed_n and jump_n */
#define PUSH_FAILURE_COUNT(ptr)						\
  do {									\
    int c;								\
    EXTRACT_NUMBER(c, ptr);						\
    ENSURE_FAIL_STACK(NUM_COUNT_ITEMS);					\
    *stackp++ = (unsigned char*)(long)c;				\
    *stackp++ = (ptr);							\
    num_failure_counts++;						\
  } while (0)

/* This pushes most of the information about the current state we will want
   if we ever fail back to it.  */

#define PUSH_FAILURE_POINT(pattern_place, string_place)			\
  do {									\
    long last_used_reg, this_reg;					\
									\
    /* Find out how many registers are active or have been matched.	\
       (Aside from register zero, which is only set at the end.) */	\
    for (last_used_reg = num_regs-1; last_used_reg > 0; last_used_reg--)\
      if (!REG_UNSET(regstart[last_used_reg]))				\
        break;								\
									\
    ENSURE_FAIL_STACK(NUM_FAILURE_ITEMS);				\
    *stackp++ = (unsigned char*)(long)num_failure_counts;		\
    num_failure_counts = 0;						\
									\
    /* Now push the info for each of those registers.  */		\
    for (this_reg = 1; this_reg <= last_used_reg; this_reg++) {		\
      *stackp++ = regstart[this_reg];					\
      *stackp++ = regend[this_reg];					\
      *stackp++ = reg_info[this_reg].word;				\
    }									\
									\
    /* Push how many registers we saved.  */				\
    *stackp++ = (unsigned char*)last_used_reg;				\
									\
    *stackp++ = pattern_place;                                          \
    *stackp++ = string_place;                                           \
    *stackp++ = (unsigned char*)(long)options; /* current option status */	\
    *stackp++ = (unsigned char*)0; /* non-greedy flag */		\
  } while(0)

#define NON_GREEDY ((unsigned char*)1)

#define POP_FAILURE_COUNT()						\
  do {									\
    unsigned char *ptr = *--stackp;					\
    int count = (long)*--stackp;					\
    STORE_NUMBER(ptr, count);						\
  } while (0)

/* This pops what PUSH_FAILURE_POINT pushes.  */

#define POP_FAILURE_POINT()						\
  do {									\
    long temp;								\
    stackp -= NUM_NONREG_ITEMS;	/* Remove failure points (and flag). */	\
    temp = (long)*--stackp;	/* How many regs pushed.  */	        \
    temp *= NUM_REG_ITEMS;	/* How much to take off the stack.  */	\
    stackp -= temp; 		/* Remove the register info.  */	\
    temp = (long)*--stackp;	/* How many counters pushed.  */	\
    while (temp--) {							\
      POP_FAILURE_COUNT();      /* Remove the counter info.  */		\
    }									\
    num_failure_counts = 0;	/* Reset num_failure_counts.  */	\
  } while(0)

     /* Registers are set to a sentinel when they haven't yet matched.  */
#define REG_UNSET_VALUE ((unsigned char*)-1)
#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)

#define PREFETCH if (d == dend) goto fail

     /* Call this when have matched something; it sets `matched' flags for the
   registers corresponding to the subexpressions of which we currently
   are inside.  */
#define SET_REGS_MATCHED 						\
  do { unsigned this_reg;						\
    for (this_reg = 0; this_reg < num_regs; this_reg++) { 		\
        if (IS_ACTIVE(reg_info[this_reg]))				\
          MATCHED_SOMETHING(reg_info[this_reg]) = 1;			\
        else								\
          MATCHED_SOMETHING(reg_info[this_reg]) = 0;			\
      } 								\
  } while(0)

#define AT_STRINGS_BEG(d)  ((d) == string)
#define AT_STRINGS_END(d)  ((d) == dend)

#define IS_A_LETTER(d) (SYNTAX(*(d)) == Sword ||			\
			(current_mbctype ?				\
			 (re_mbctab[*(d)] && ((d)+mbclen(*(d)))<=dend):	\
			 SYNTAX(*(d)) == Sword2))

#define PREV_IS_A_LETTER(d) ((current_mbctype == MBCTYPE_SJIS)?		\
			     IS_A_LETTER((d)-(!AT_STRINGS_BEG((d)-1)&&	\
					      ismbchar((d)[-2])?2:1)):	\
                             ((current_mbctype && ((d)[-1] >= 0x80)) ||	\
			      IS_A_LETTER((d)-1)))

static void
init_regs(regs, num_regs)
     struct re_registers *regs;
     unsigned int num_regs;
{
  int i;

  regs->num_regs = num_regs;
  if (num_regs < RE_NREGS)
    num_regs = RE_NREGS;

  if (regs->allocated == 0) {
    regs->beg = TMALLOC(num_regs, int);
    regs->end = TMALLOC(num_regs, int);
    regs->allocated = num_regs;
  }
  else if (regs->allocated < num_regs) {
    TREALLOC(regs->beg, num_regs, int);
    TREALLOC(regs->end, num_regs, int);
    regs->allocated = num_regs;
  }
  for (i=0; i<num_regs; i++) {
    regs->beg[i] = regs->end[i] = -1;
  }
}

/* Match the pattern described by BUFP against STRING, which is of
   SIZE.  Start the match at index POS in STRING.  In REGS, return the
   indices of STRING that matched the entire BUFP->buffer and its
   contained subexpressions.

   If bufp->fastmap is nonzero, then it had better be up to date.

   The reason that the data to match are specified as two components
   which are to be regarded as concatenated is so this function can be
   used directly on the contents of an Emacs buffer.

   -1 is returned if there is no match.  -2 is returned if there is an
   error (such as match stack overflow).  Otherwise the value is the
   length of the substring which was matched.  */

int
re_match(bufp, string_arg, size, pos, regs)
     struct re_pattern_buffer *bufp;
     const char *string_arg;
     int size, pos;
     struct re_registers *regs;
{
  register unsigned char *p = (unsigned char*)bufp->buffer;
  unsigned char *p1;

  /* Pointer to beyond end of buffer.  */
  register unsigned char *pend = p + bufp->used;

  unsigned num_regs = bufp->re_nsub;

  unsigned char *string = (unsigned char*)string_arg;

  register unsigned char *d, *dend;
  register int mcnt;			/* Multipurpose.  */
  int options = bufp->options;

  /* Failure point stack.  Each place that can handle a failure further
     down the line pushes a failure point on this stack.  It consists of
     restart, regend, and reg_info for all registers corresponding to the
     subexpressions we're currently inside, plus the number of such
     registers, and, finally, two char *'s.  The first char * is where to
     resume scanning the pattern; the second one is where to resume
     scanning the strings.  If the latter is zero, the failure point is a
     ``dummy''; if a failure happens and the failure point is a dummy, it
     gets discarded and the next next one is tried.  */

  unsigned char **stacka;
  unsigned char **stackb;
  unsigned char **stackp;
  unsigned char **stacke;

  /* Information on the contents of registers. These are pointers into
     the input strings; they record just what was matched (on this
     attempt) by a subexpression part of the pattern, that is, the
     regnum-th regstart pointer points to where in the pattern we began
     matching and the regnum-th regend points to right after where we
     stopped matching the regnum-th subexpression.  (The zeroth register
     keeps track of what the whole pattern matches.)  */

  unsigned char **regstart = bufp->regstart;
  unsigned char **regend = bufp->regend;

  /* If a group that's operated upon by a repetition operator fails to
     match anything, then the register for its start will need to be
     restored because it will have been set to wherever in the string we
     are when we last see its open-group operator.  Similarly for a
     register's end.  */
  unsigned char **old_regstart = bufp->old_regstart;
  unsigned char **old_regend = bufp->old_regend;

  /* The is_active field of reg_info helps us keep track of which (possibly
     nested) subexpressions we are currently in. The matched_something
     field of reg_info[reg_num] helps us tell whether or not we have
     matched any of the pattern so far this time through the reg_num-th
     subexpression.  These two fields get reset each time through any
     loop their register is in.  */

  register_info_type *reg_info = bufp->reg_info;

  /* The following record the register info as found in the above
     variables when we find a match better than any we've seen before. 
     This happens as we backtrack through the failure points, which in
     turn happens only if we have not yet matched the entire string.  */

  unsigned best_regs_set = 0;
  unsigned char **best_regstart = bufp->best_regstart;
  unsigned char **best_regend = bufp->best_regend;

  int num_failure_counts = 0;

  if (regs) {
    init_regs(regs, num_regs);
  }

  /* Initialize the stack. */
  stacka = RE_TALLOC(MAX_NUM_FAILURE_ITEMS * NFAILURES, unsigned char*);
  stackb = stacka;
  stackp = stackb;
  stacke = &stackb[MAX_NUM_FAILURE_ITEMS * NFAILURES];

#ifdef DEBUG_REGEX
  fprintf(stderr, "Entering re_match(%s)\n", string_arg);
#endif

  /* Initialize subexpression text positions to -1 to mark ones that no
     ( or ( and ) or ) has been seen for. Also set all registers to
     inactive and mark them as not having matched anything or ever
     failed. */
  for (mcnt = 0; mcnt < num_regs; mcnt++) {
    regstart[mcnt] = regend[mcnt]
      = old_regstart[mcnt] = old_regend[mcnt]
      = best_regstart[mcnt] = best_regend[mcnt] = REG_UNSET_VALUE;
#ifdef __CHECKER__
    reg_info[mcnt].word = 0;
#endif
    IS_ACTIVE (reg_info[mcnt]) = 0;
    MATCHED_SOMETHING (reg_info[mcnt]) = 0;
  }

  /* Set up pointers to ends of strings.
     Don't allow the second string to be empty unless both are empty.  */


  /* `p' scans through the pattern as `d' scans through the data. `dend'
     is the end of the input string that `d' points within. `d' is
     advanced into the following input string whenever necessary, but
     this happens before fetching; therefore, at the beginning of the
     loop, `d' can be pointing at the end of a string, but it cannot
     equal string2.  */

  d = string + pos, dend = string + size;

  /* This loops over pattern commands.  It exits by returning from the
     function if match is complete, or it drops through if match fails
     at this starting point in the input data.  */

  for (;;) {
#ifdef DEBUG_REGEX
    fprintf(stderr,
	    "regex loop(%d):  matching 0x%02d\n",
	    p - (unsigned char*)bufp->buffer,
	    *p);
#endif
    /* End of pattern means we might have succeeded.  */
    if (p == pend) {
      /* If not end of string, try backtracking.  Otherwise done.  */
      if ((bufp->options & RE_OPTION_LONGEST) && d != dend) {
	if (best_regs_set) /* non-greedy, no need to backtrack */
	  goto restore_best_regs;
	while (stackp != stackb && stackp[-1] == NON_GREEDY) {
	  if (best_regs_set) /* non-greedy, no need to backtrack */
	    goto restore_best_regs;
	  POP_FAILURE_POINT();
	}
	if (stackp != stackb) {
	  /* More failure points to try.  */

	  /* If exceeds best match so far, save it.  */
	  if (! best_regs_set || (d > best_regend[0])) {
	    best_regs_set = 1;
	    best_regend[0] = d;	/* Never use regstart[0].  */

	    for (mcnt = 1; mcnt < num_regs; mcnt++) {
	      best_regstart[mcnt] = regstart[mcnt];
	      best_regend[mcnt] = regend[mcnt];
	    }
	  }
	  goto fail;	       
	}
	/* If no failure points, don't restore garbage.  */
	else if (best_regs_set) {
	restore_best_regs:
	  /* Restore best match.  */
	  d = best_regend[0];

	  for (mcnt = 0; mcnt < num_regs; mcnt++) {
	    regstart[mcnt] = best_regstart[mcnt];
	    regend[mcnt] = best_regend[mcnt];
	  }
	}
      }

      /* If caller wants register contents data back, convert it 
	 to indices.  */
      if (regs) {
	regs->beg[0] = pos;
	regs->end[0] = d - string;
	for (mcnt = 1; mcnt < num_regs; mcnt++) {
	  if (REG_UNSET(regend[mcnt])) {
	    regs->beg[mcnt] = -1;
	    regs->end[mcnt] = -1;
	    continue;
	  }
	  regs->beg[mcnt] = regstart[mcnt] - string;
	  regs->end[mcnt] = regend[mcnt] - string;
	}
      }
      FREE_AND_RETURN(stackb, (d - pos - string));
    }

    /* Otherwise match next pattern command.  */
#ifdef SWITCH_ENUM_BUG
    switch ((int)((enum regexpcode)*p++))
#else
    switch ((enum regexpcode)*p++)
#endif
      {
	/* ( [or `(', as appropriate] is represented by start_memory,
	   ) by stop_memory.  Both of those commands are followed by
	   a register number in the next byte.  The text matched
	   within the ( and ) is recorded under that number.  */
      case start_memory:
	old_regstart[*p] = regstart[*p];
	regstart[*p] = d;
	IS_ACTIVE(reg_info[*p]) = 1;
	MATCHED_SOMETHING(reg_info[*p]) = 0;
	p += 2;
	continue;

      case stop_memory:
	old_regend[*p] = regend[*p];
	regend[*p] = d;
	IS_ACTIVE(reg_info[*p]) = 0;
	p += 2;
	continue;

      case start_paren:
      case stop_paren:
	break;

	/* \<digit> has been turned into a `duplicate' command which is
	   followed by the numeric value of <digit> as the register number.  */
      case duplicate:
	{
	  int regno = *p++;   /* Get which register to match against */
	  register unsigned char *d2, *dend2;

	  /* Check if there's corresponding group */
	  if (regno >= num_regs) goto fail;
	  /* Check if corresponding group is still open */
	  if (IS_ACTIVE(reg_info[regno])) goto fail;

	  /* Where in input to try to start matching.  */
	  d2 = regstart[regno];
	  if (REG_UNSET(d2)) goto fail;

	  /* Where to stop matching; if both the place to start and
	     the place to stop matching are in the same string, then
	     set to the place to stop, otherwise, for now have to use
	     the end of the first string.  */

	  dend2 = regend[regno];
	  if (REG_UNSET(dend2)) goto fail;
	  for (;;) {
	    /* At end of register contents => success */
	    if (d2 == dend2) break;

	    /* If necessary, advance to next segment in data.  */
	    PREFETCH;

	    /* How many characters left in this segment to match.  */
	    mcnt = dend - d;

	    /* Want how many consecutive characters we can match in
	       one shot, so, if necessary, adjust the count.  */
	    if (mcnt > dend2 - d2)
	      mcnt = dend2 - d2;

	    /* Compare that many; failure if mismatch, else move
	       past them.  */
	    if ((options & RE_OPTION_IGNORECASE) 
		? memcmp_translate(d, d2, mcnt) 
		: memcmp((char*)d, (char*)d2, mcnt))
	      goto fail;
	    d += mcnt, d2 += mcnt;
	  }
	}
	break;

      case start_nowidth:
	PUSH_FAILURE_POINT(0, d);
	if (stackp - stackb > RE_DUP_MAX) {
	   FREE_AND_RETURN(stackb,(-2));
	}
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	STORE_NUMBER(p+mcnt, stackp - stackb);
	continue;

      case stop_nowidth:
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	stackp = stackb + mcnt;
	d = stackp[-3];
	POP_FAILURE_POINT();
	continue;

      case stop_backtrack:
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	stackp = stackb + mcnt;
	POP_FAILURE_POINT();
	continue;

      case pop_and_fail:
	EXTRACT_NUMBER(mcnt, p+1);
	stackp = stackb + mcnt;
	POP_FAILURE_POINT();
	goto fail;

      case anychar:
	PREFETCH;
	if (ismbchar(*d)) {
	  if (d + mbclen(*d) > dend)
	    goto fail;
	  SET_REGS_MATCHED;
	  d += mbclen(*d);
	  break;
	}
	if (!(options&RE_OPTION_MULTILINE)
	    && (TRANSLATE_P() ? translate[*d] : *d) == '\n')
	  goto fail;
	SET_REGS_MATCHED;
	d++;
	break;

      case anychar_repeat:
	for (;;) {
	  PUSH_FAILURE_POINT(p, d);
	  PREFETCH;
	  if (ismbchar(*d)) {
	    if (d + mbclen(*d) > dend)
	      goto fail;
	    SET_REGS_MATCHED;
	    d += mbclen(*d);
	    continue;
	  }
	  if (!(options&RE_OPTION_MULTILINE) &&
	      (TRANSLATE_P() ? translate[*d] : *d) == '\n')
	    goto fail;
	  SET_REGS_MATCHED;
	  d++;
	}
	break;

      case charset:
      case charset_not:
	{
	  int not;	    /* Nonzero for charset_not.  */
	  int part = 0;	    /* true if matched part of mbc */
	  unsigned char *dsave = d + 1;
	  int cc, c;

	  PREFETCH;
	  cc = c = (unsigned char)*d++;
	  if (ismbchar(c)) {
	    if (d + mbclen(c) - 1 <= dend) {
	      MBC2WC(c, d);
	    }
	  }
	  else if (TRANSLATE_P())
	    cc = c = (unsigned char)translate[c];

	  not = is_in_list(c, p);
	  if (!not && cc != c) {
	      part = not = is_in_list(cc, p);
	  }
	  if (*(p - 1) == (unsigned char)charset_not) {
	    not = !not;
	  }
	  if (!not) goto fail;

	  p += 1 + *p + 2 + EXTRACT_UNSIGNED(&p[1 + *p])*8;
	  SET_REGS_MATCHED;

	  if (part) d = dsave;
	  break;
	}

      case begline:
	if (size == 0 || AT_STRINGS_BEG(d))
	  break;
	if (d[-1] == '\n' && !AT_STRINGS_END(d))
	  break;
	goto fail;

      case endline:
	if (AT_STRINGS_END(d)) {
	  if (size == 0 || d[-1] != '\n')
	    break;
	}
	else if (*d == '\n')
	  break;
	goto fail;

	/* Match at the very beginning of the string. */
      case begbuf:
	if (AT_STRINGS_BEG(d))
	  break;
	goto fail;

	/* Match at the very end of the data. */
      case endbuf:
	if (AT_STRINGS_END(d))
	  break;
	goto fail;

	/* Match at the very end of the data. */
      case endbuf2:
	if (AT_STRINGS_END(d)) {
	  if (size == 0 || d[-1] != '\n')
	    break;
	}
	/* .. or newline just before the end of the data. */
	if (*d == '\n' && AT_STRINGS_END(d+1))
	  break;
	goto fail;

	/* `or' constructs are handled by starting each alternative with
	   an on_failure_jump that points to the start of the next
	   alternative.  Each alternative except the last ends with a
	   jump to the joining point.  (Actually, each jump except for
	   the last one really jumps to the following jump, because
	   tensioning the jumps is a hassle.)  */

	/* The start of a stupid repeat has an on_failure_jump that points
	   past the end of the repeat text. This makes a failure point so 
	   that on failure to match a repetition, matching restarts past
	   as many repetitions have been found with no way to fail and
	   look for another one.  */

	/* A smart repeat is similar but loops back to the on_failure_jump
	   so that each repetition makes another failure point.  */

	/* Match at the starting position. */
      case begpos:
	if (d - string == pos)
	  break;
	goto fail;

      case on_failure_jump:
      on_failure:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      PUSH_FAILURE_POINT(p + mcnt, d);
      continue;

      /* The end of a smart repeat has a maybe_finalize_jump back.
	 Change it either to a finalize_jump or an ordinary jump.  */
      case maybe_finalize_jump:
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	p1 = p;

	/* Compare the beginning of the repeat with what in the
	   pattern follows its end. If we can establish that there
	   is nothing that they would both match, i.e., that we
	   would have to backtrack because of (as in, e.g., `a*a')
	   then we can change to finalize_jump, because we'll
	   never have to backtrack.

	   This is not true in the case of alternatives: in
	   `(a|ab)*' we do need to backtrack to the `ab' alternative
	   (e.g., if the string was `ab').  But instead of trying to
	   detect that here, the alternative has put on a dummy
	   failure point which is what we will end up popping.  */

	/* Skip over open/close-group commands.  */
	while (p1 + 2 < pend) {
	  if ((enum regexpcode)*p1 == stop_memory ||
	      (enum regexpcode)*p1 == start_memory)
	    p1 += 3;	/* Skip over args, too.  */
	  else if (/*(enum regexpcode)*p1 == start_paren ||*/
		   (enum regexpcode)*p1 == stop_paren)
	      p1 += 1;
	  else
	    break;
	}

	if (p1 == pend)
	  p[-3] = (unsigned char)finalize_jump;
	else if (*p1 == (unsigned char)exactn ||
		 *p1 == (unsigned char)endline) {
	  register int c = *p1 == (unsigned char)endline ? '\n' : p1[2];
	  register unsigned char *p2 = p + mcnt;
	    /* p2[0] ... p2[2] are an on_failure_jump.
	       Examine what follows that.  */
	  if (p2[3] == (unsigned char)exactn && p2[5] != c)
	    p[-3] = (unsigned char)finalize_jump;
	  else if (p2[3] == (unsigned char)charset ||
		   p2[3] == (unsigned char)charset_not) {
	    int not;
	    if (ismbchar(c)) {
	      unsigned char *pp = p1+3;
	      MBC2WC(c, pp);
	    }
	    /* `is_in_list()' is TRUE if c would match */
	    /* That means it is not safe to finalize.  */
	    not = is_in_list(c, p2 + 4);
	    if (p2[3] == (unsigned char)charset_not)
	      not = !not;
	    if (!not)
	      p[-3] = (unsigned char)finalize_jump;
	  }
	}
	p -= 2;		/* Point at relative address again.  */
	if (p[-1] != (unsigned char)finalize_jump) {
	  p[-1] = (unsigned char)jump;	
	  goto nofinalize;
	}
	/* Note fall through.  */

	/* The end of a stupid repeat has a finalize_jump back to the
	   start, where another failure point will be made which will
	   point to after all the repetitions found so far.  */

	/* Take off failure points put on by matching on_failure_jump 
	   because didn't fail.  Also remove the register information
	   put on by the on_failure_jump.  */
      case finalize_jump:
	if (stackp > stackb && stackp[-3] == d) {
	  p = stackp[-4];
	  POP_FAILURE_POINT();
	  continue;
	}
	POP_FAILURE_POINT(); 
	/* Note fall through.  */

      /* We need this opcode so we can detect where alternatives end
	 in `group_match_null_string_p' et al.  */
      case jump_past_alt:
	/* fall through */

	/* Jump without taking off any failure points.  */
      case jump:
      nofinalize:
        EXTRACT_NUMBER_AND_INCR(mcnt, p);
        if (mcnt < 0 && stackp > stackb && stackp[-3] == d) /* avoid infinite loop */
	   goto fail;
        p += mcnt;
        continue;

      case dummy_failure_jump:
	/* Normally, the on_failure_jump pushes a failure point, which
	   then gets popped at finalize_jump.  We will end up at
	   finalize_jump, also, and with a pattern of, say, `a+', we
	   are skipping over the on_failure_jump, so we have to push
	   something meaningless for finalize_jump to pop.  */
	PUSH_FAILURE_POINT(0, 0);
	goto nofinalize;

	/* At the end of an alternative, we need to push a dummy failure
	   point in case we are followed by a `finalize_jump', because
	   we don't want the failure point for the alternative to be
	   popped.  For example, matching `(a|ab)*' against `aab'
	   requires that we match the `ab' alternative.  */
      case push_dummy_failure:
	/* See comments just above at `dummy_failure_jump' about the
	   two zeroes.  */
	p1 = p;
	/* Skip over open/close-group commands.  */
	while (p1 + 2 < pend) {
	  if ((enum regexpcode)*p1 == stop_memory ||
	      (enum regexpcode)*p1 == start_memory)
	    p1 += 3;	/* Skip over args, too.  */
	  else if (/*(enum regexpcode)*p1 == start_paren ||*/
		   (enum regexpcode)*p1 == stop_paren)
	      p1 += 1;
	  else
	    break;
	}
	if (p1 < pend && (enum regexpcode)*p1 == jump)
	  p[-1] = unused;
	else
	  PUSH_FAILURE_POINT(0, 0);
	break;

	/* Have to succeed matching what follows at least n times.  Then
	   just handle like an on_failure_jump.  */
      case succeed_n: 
	EXTRACT_NUMBER(mcnt, p + 2);
	/* Originally, this is how many times we HAVE to succeed.  */
	if (mcnt != 0) {
	  mcnt--;
	  p += 2;
	  PUSH_FAILURE_COUNT(p);
	  STORE_NUMBER_AND_INCR(p, mcnt);
	  PUSH_FAILURE_POINT(0, 0);
	}
	else  {
	  goto on_failure;
	}
	continue;

      case jump_n:
	EXTRACT_NUMBER(mcnt, p + 2);
	/* Originally, this is how many times we CAN jump.  */
	if (mcnt) {
	  mcnt--;
	  PUSH_FAILURE_COUNT(p + 2);
	  STORE_NUMBER(p + 2, mcnt);
	  goto nofinalize;	     /* Do the jump without taking off
					any failure points.  */
	}
	/* If don't have to jump any more, skip over the rest of command.  */
	else      
	  p += 4;		     
	continue;

      case set_number_at:
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	p1 = p + mcnt;
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	STORE_NUMBER(p1, mcnt);
	continue;

      case try_next:
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	if (p + mcnt < pend) {
	  PUSH_FAILURE_POINT(p, d);
	  stackp[-1] = NON_GREEDY;
	}
	p += mcnt;
	continue;

      case finalize_push:
	POP_FAILURE_POINT();
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
        if (mcnt < 0 && stackp > stackb  && stackp[-3] == d) /* avoid infinite loop */
	   goto fail;
	PUSH_FAILURE_POINT(p + mcnt, d);
	stackp[-1] = NON_GREEDY;
	continue;

      case finalize_push_n:
	EXTRACT_NUMBER(mcnt, p + 2); 
	/* Originally, this is how many times we CAN jump.  */
	if (mcnt) {
	  int pos, i;

	  mcnt--;
	  STORE_NUMBER(p + 2, mcnt);
	  EXTRACT_NUMBER(pos, p);
	  EXTRACT_NUMBER(i, p+pos+5);
	  if (i > 0) goto nofinalize;
	  POP_FAILURE_POINT();
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
	  PUSH_FAILURE_POINT(p + mcnt, d);
	  stackp[-1] = NON_GREEDY;
	  p += 2;		/* skip n */
	}
	/* If don't have to push any more, skip over the rest of command.  */
	else 
	  p += 4;   
	continue;

	/* Ignore these.  Used to ignore the n of succeed_n's which
	   currently have n == 0.  */
      case unused:
	continue;

      case casefold_on:
	options |= RE_OPTION_IGNORECASE;
	continue;

      case casefold_off:
	options &= ~RE_OPTION_IGNORECASE;
	continue;

      case option_set:
	options = *p++;
	continue;

      case wordbound:
	if (AT_STRINGS_BEG(d)) {
	  if (IS_A_LETTER(d)) break;
	  else goto fail;
	}
	if (AT_STRINGS_END(d)) {
	  if (PREV_IS_A_LETTER(d)) break;
	  else goto fail;
	}
	if (PREV_IS_A_LETTER(d) != IS_A_LETTER(d))
	  break;
	goto fail;

      case notwordbound:
	if (AT_STRINGS_BEG(d)) {
	  if (IS_A_LETTER(d)) goto fail;
	  else break;
	}
	if (AT_STRINGS_END(d)) {
	  if (PREV_IS_A_LETTER(d)) goto fail;
	  else break;
	}
	if (PREV_IS_A_LETTER(d) != IS_A_LETTER(d))
	  goto fail;
	break;

      case wordbeg:
	if (IS_A_LETTER(d) && (AT_STRINGS_BEG(d) || !PREV_IS_A_LETTER(d)))
	  break;
	goto fail;

      case wordend:
	if (!AT_STRINGS_BEG(d) && PREV_IS_A_LETTER(d)
	    && (!IS_A_LETTER(d) || AT_STRINGS_END(d)))
	  break;
	goto fail;

      case wordchar:
	PREFETCH;
	if (!IS_A_LETTER(d))
	  goto fail;
	if (ismbchar(*d) && d + mbclen(*d) - 1 < dend)
	  d += mbclen(*d) - 1;
	d++;
	SET_REGS_MATCHED;
	break;

      case notwordchar:
	PREFETCH;
	if (IS_A_LETTER(d))
	  goto fail;
	if (ismbchar(*d) && d + mbclen(*d) - 1 < dend)
	  d += mbclen(*d) - 1;
	d++;
	SET_REGS_MATCHED;
	break;

      case exactn:
	/* Match the next few pattern characters exactly.
	   mcnt is how many characters to match.  */
	mcnt = *p++;
	/* This is written out as an if-else so we don't waste time
	   testing `translate' inside the loop.  */
	if (TRANSLATE_P()) {
	  do {
	    unsigned char c;

	    PREFETCH;
	    if (*p == 0xff) {
	      p++;  
	      if (!--mcnt
		  || AT_STRINGS_END(d)
		  || (unsigned char)*d++ != (unsigned char)*p++)
		goto fail;
	      continue;
	    }
	    c = *d++;
	    if (ismbchar(c)) {
	      int n;

	      if (c != (unsigned char)*p++)
		goto fail;
	      for (n = mbclen(c) - 1; n > 0; n--)
		if (!--mcnt	/* redundant check if pattern was
				   compiled properly. */
		    || AT_STRINGS_END(d)
		    || (unsigned char)*d++ != (unsigned char)*p++)
		  goto fail;
	      continue;
	    }
	    /* compiled code translation needed for ruby */
	    if ((unsigned char)translate[c] != (unsigned char)translate[*p++])
	      goto fail;
	  }
	  while (--mcnt);
	}
	else {
	  do {
	    PREFETCH;
	    if (*p == 0xff) {p++; mcnt--;}
	    if (*d++ != *p++) goto fail;
	  }
	  while (--mcnt);
	}
	SET_REGS_MATCHED;
	break;
      }
#ifdef RUBY
    CHECK_INTS;
#endif
    continue;  /* Successfully executed one pattern command; keep going.  */

    /* Jump here if any matching operation fails. */
  fail:
    if (stackp != stackb) {
      /* A restart point is known.  Restart there and pop it. */
      short last_used_reg, this_reg;

      /* If this failure point is from a dummy_failure_point, just
	 skip it.  */
      if (stackp[-4] == 0 || (best_regs_set && stackp[-1] == NON_GREEDY)) {
	POP_FAILURE_POINT();
	goto fail;
      }
      stackp--;		/* discard greedy flag */
      options = (long)*--stackp;
      d = *--stackp;
      p = *--stackp;
      /* Restore register info.  */
      last_used_reg = (long)*--stackp;

      /* Make the ones that weren't saved -1 or 0 again. */
      for (this_reg = num_regs - 1; this_reg > last_used_reg; this_reg--) {
	regend[this_reg] = REG_UNSET_VALUE;
	regstart[this_reg] = REG_UNSET_VALUE;
	IS_ACTIVE(reg_info[this_reg]) = 0;
	MATCHED_SOMETHING(reg_info[this_reg]) = 0;
      }

      /* And restore the rest from the stack.  */
      for ( ; this_reg > 0; this_reg--) {
	reg_info[this_reg].word = *--stackp;
	regend[this_reg] = *--stackp;
	regstart[this_reg] = *--stackp;
      }
      mcnt = (long)*--stackp;
      while (mcnt--) {
	POP_FAILURE_COUNT();
      }
      if (p < pend) {
	int is_a_jump_n = 0;
	int failed_paren = 0;

	p1 = p;
	/* If failed to a backwards jump that's part of a repetition
	   loop, need to pop this failure point and use the next one.  */
	switch ((enum regexpcode)*p1) {
	case jump_n:
	case finalize_push_n:
	  is_a_jump_n = 1;
	case maybe_finalize_jump:
	case finalize_jump:
	case finalize_push:
	case jump:
	  p1++;
	  EXTRACT_NUMBER_AND_INCR(mcnt, p1);

	  if (mcnt >= 0) break;	/* should be backward jump */
	  p1 += mcnt;

	  if (( is_a_jump_n && (enum regexpcode)*p1 == succeed_n) ||
	      (!is_a_jump_n && (enum regexpcode)*p1 == on_failure_jump)) {
	    if (failed_paren) {
	      p1++;
	      EXTRACT_NUMBER_AND_INCR(mcnt, p1);
	      PUSH_FAILURE_POINT(p1 + mcnt, d);
	    }
	    goto fail;
	  }
	  break;
	default:
	  /* do nothing */;
	}
      }
    }
    else
      break;   /* Matching at this starting point really fails.  */
  }

  if (best_regs_set)
    goto restore_best_regs;

  FREE_AND_RETURN(stackb,(-1)); 	/* Failure to match.  */
}


static int
memcmp_translate(s1, s2, len)
     unsigned char *s1, *s2;
     register int len;
{
  register unsigned char *p1 = s1, *p2 = s2, c;
  while (len) {
    c = *p1++;
    if (ismbchar(c)) {
      int n;

      if (c != *p2++) return 1;
      for (n = mbclen(c) - 1; n > 0; n--)
	if (!--len || *p1++ != *p2++)
	  return 1;
    }
    else
      if (translate[c] != translate[*p2++])
	return 1;
    len--;
  }
  return 0;
}

void
re_copy_registers(regs1, regs2)
     struct re_registers *regs1, *regs2;
{
  int i;

  if (regs1 == regs2) return;
  if (regs1->allocated == 0) {
    regs1->beg = TMALLOC(regs2->num_regs, int);
    regs1->end = TMALLOC(regs2->num_regs, int);
    regs1->allocated = regs2->num_regs;
  }
  else if (regs1->allocated < regs2->num_regs) {
    TREALLOC(regs1->beg, regs2->num_regs, int);
    TREALLOC(regs1->end, regs2->num_regs, int);
    regs1->allocated = regs2->num_regs;
  }
  for (i=0; i<regs2->num_regs; i++) {
    regs1->beg[i] = regs2->beg[i];
    regs1->end[i] = regs2->end[i];
  }
  regs1->num_regs = regs2->num_regs;
}

void
re_free_registers(regs)
     struct re_registers *regs;
{
  if (regs->allocated == 0) return;
  if (regs->beg) xfree(regs->beg);
  if (regs->end) xfree(regs->end);
}

/* Functions for multi-byte support.
   Created for grep multi-byte extension Jul., 1993 by t^2 (Takahiro Tanimoto)
   Last change: Jul. 9, 1993 by t^2  */
static const unsigned char mbctab_ascii[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

static const unsigned char mbctab_euc[] = { /* 0xA1-0xFE */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
};

static const unsigned char mbctab_sjis[] = { /* 0x80-0x9f,0xE0-0xFC */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0
};

static const unsigned char mbctab_sjis_trail[] = { /* 0x40-0x7E,0x80-0xFC */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0
};

static const unsigned char mbctab_utf8[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 0, 0,
};

const unsigned char *re_mbctab = mbctab_ascii;

void
re_mbcinit(mbctype)
     int mbctype;
{
  switch (mbctype) {
  case MBCTYPE_ASCII:
    re_mbctab = mbctab_ascii;
    current_mbctype = MBCTYPE_ASCII;
    break;
  case MBCTYPE_EUC:
    re_mbctab = mbctab_euc;
    current_mbctype = MBCTYPE_EUC;
    break;
  case MBCTYPE_SJIS:
    re_mbctab = mbctab_sjis;
    current_mbctype = MBCTYPE_SJIS;
    break;
  case MBCTYPE_UTF8:
    re_mbctab = mbctab_utf8;
    current_mbctype = MBCTYPE_UTF8;
    break;
  }
}

#define mbc_isfirst(t, c) (t)[(unsigned char)(c)]
#define mbc_len(t, c)     ((t)[(unsigned char)(c)]+1)

static unsigned int
asc_startpos(string, pos)
     const char *string;
     unsigned int pos;
{
  return pos;
}

#define euc_islead(c)  ((unsigned char)((c) - 0xa1) > 0xfe - 0xa1)
#define euc_mbclen(c)  mbc_len(mbctab_euc, (c))
static unsigned int
euc_startpos(string, pos)
     const char *string;
     unsigned int pos;
{
  unsigned int i = pos, w;

  while (i > 0 && !euc_islead(string[i])) {
    --i;
  }
  if (i == pos || i + (w = euc_mbclen(string[i])) > pos) {
    return i;
  }
  i += w;
  return i + ((pos - i) & ~1);
}

#define sjis_isfirst(c) mbc_isfirst(mbctab_sjis, (c))
#define sjis_istrail(c) mbctab_sjis_trail[(unsigned char)(c)]
#define sjis_mbclen(c)  mbc_len(mbctab_sjis, (c))
static unsigned int
sjis_startpos(string, pos)
     const char *string;
     unsigned int pos;
{
  unsigned int i = pos, w;

  if (i > 0 && sjis_istrail(string[i])) {
    do {
      if (!sjis_isfirst(string[--i])) {
	++i;
	break;
      }
    } while (i > 0);
  }
  if (i == pos || i + (w = sjis_mbclen(string[i])) > pos) {
    return i;
  }
  i += w;
  return i + ((pos - i) & ~1);
}

#define utf8_islead(c)  ((unsigned char)((c) & 0xc0) != 0x80)
#define utf8_mbclen(c)  mbc_len(mbctab_utf8, (c))
static unsigned int
utf8_startpos(string, pos)
     const char *string;
     unsigned int pos;
{
  unsigned int i = pos, w;

  while (i > 0 && !utf8_islead(string[i])) {
    --i;
  }
  if (i == pos || i + (w = utf8_mbclen(string[i])) > pos) {
    return i;
  }
  return i + w;
}

/*
  vi: sw=2 ts=8
  Local variables:
  mode		 : C
  c-file-style	 : "gnu"
  tab-width	 : 8
  End		 :
*/
@


1.73
log
@* dir.c (glob_helper): must not closedir() when exception raised
  while globbing "**".

* marshal.c (w_uclass): unused variable.

* re.c (match_clone): unused.

* regex.c (re_compile_pattern): get rid of implicit promotion from
  plain char to int.
@
text
@d4020 1
a4020 1
	if ((enum regexpcode)*p1 == jump)
@


1.72
log
@* parse.y (read_escape): deny zero-width hexadecimal character.
  (ruby-bugs-ja:PR#260)

* parse.y (tokadd_escape): ditto.

* regex.c (re_compile_pattern): ditto.
@
text
@d1686 1
a1686 1
	memmove(&b[b[-1]], &b[(1 << BYTEWIDTH) / BYTEWIDTH],
d1688 1
a1688 1
      b += b[-1] + 2 + EXTRACT_UNSIGNED(&b[b[-1]])*8;
d2197 1
a2197 1
	  memmove(&b[b[-1]], &b[(1 << BYTEWIDTH) / BYTEWIDTH],
d2199 1
a2199 1
	b += b[-1] + 2 + EXTRACT_UNSIGNED(&b[b[-1]])*8;
@


1.71
log
@* object.c (Init_Object): should do exact match for Module#==.

* compar.c (cmp_eq): returns 'false' if <=> returns 'nil'.

* compar.c (cmp_gt,cmp_ge,cmp_lt,cmp_le,cmp_between): ditto.

* pack.c (pack_pack): should propagate taintedness.

* pack.c (pack_unpack): ditto.

* eval.c (rb_thread_schedule): need to preserve errno before
  calling rb_trap_exec().

* regex.c (calculate_must_string): a bug in charset/charset_not
  parsing.
@
text
@d1534 1
d2252 1
@


1.70
log
@* various files: macro fix-up by Michal Rokos.
@
text
@d1053 1
a1053 1
	p += 4;
@


1.69
log
@* io.c (rb_io_mode_flags): both 'r+b' and 'rb+' should be allowed.

* io.c (rb_io_mode_modenum): ditto.

* gc.c (rb_memerror): rename from mem_error, and exported.

* gc.c (Init_GC): pre-allocate NoMemoryError instance.

* object.c (convert_type): error message changed from "failed to
  convert" to "cannot convert", since it does not try to convert
  if an object does not respond to the converting method.

* eval.c (block_pass): convert Method to Proc using
  rb_check_convert_type().

* object.c (rb_check_convert_type): always convert T_DATA

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* marshal.c (w_object): T_DATA process patch from Joel VanderWerf
  <vjoel@@PATH.Berkeley.EDU>.  This is temporary hack; it remains
  undocumented, and it will be removed when marshaling is
  re-designed.

* marshal.c (r_object): ditto.

* numeric.c (num_step): Integer#step is moved to Numeric#step;
  Fixnum#step is merged into this method.

* numeric.c (int_dotimes): Fixnum#times is merged.

* numeric.c (int_upto): Fixnum#upto is merged.

* numeric.c (int_downto): Fixnum#downto is merged.
@
text
@d72 5
a76 3
# define CHECK_INTS if (!rb_prohibit_interrupt) {\
    if (rb_trap_pending) rb_trap_exec();\
}
a423 1

@


1.68
log
@* eval.c (rb_thread_cleanup): current thread may be THREAD_STOPPED,
  for example when terminated from signal handler.

* regex.c (re_compile_pattern): remove /p support.

* regex.h: ditto.

* parse.y (parse_regx): ditto.
@
text
@d723 1
a723 2
  if (i < size && EXTRACT_MBC(&b[i*8]) <= c
      && ((unsigned char)c != '\n' && (unsigned char)c != '\0'))
d725 1
d835 1
a835 1
	  putchar ('/');
d843 1
a843 1
	printf("/");
d846 1
a846 1
	  printf("-");
@


1.67
log
@* regex.c (mbc_startpos_func): VC6 seems to be unable to
  understand forward declaration for static variables.
@
text
@d1701 1
a1701 1
	  case 'x': case 'p': case 'm': case 'i': case '-':
a1716 12
		break;

	      case 'p':
		if (negative) {
		  if ((options&RE_OPTION_POSIXLINE) == RE_OPTION_POSIXLINE) {
		    options &= ~RE_OPTION_POSIXLINE;
		  }
		}
		else if ((options&RE_OPTION_POSIXLINE) != RE_OPTION_POSIXLINE) {
		  options |= RE_OPTION_POSIXLINE;
		}
		push_option = 1;
@


1.66
log
@* regex.c (mbc_startpos_func): shoud be static.
@
text
@d472 10
a481 1
static const mbc_startpos_func_t mbc_startpos_func[];
a4510 1
static unsigned int asc_startpos _((const char *string, unsigned int pos));
a4520 1
static unsigned int euc_startpos _((const char *string, unsigned int pos));
a4540 1
static unsigned int sjis_startpos _((const char *string, unsigned int pos));
a4564 1
static unsigned int utf8_startpos _((const char *string, unsigned int pos));
a4579 4

static const mbc_startpos_func_t mbc_startpos_func[4] = {
  asc_startpos, euc_startpos, sjis_startpos, utf8_startpos
};
@


1.65
log
@* regex.c (re_compile_pattern): '\0111' should be '\011' plus '1',
  since octal literals are formed by three digits at most.

* marshal.c (w_object): module inclusion using extend() should
  also be detected.

* eval.c (rb_eval_cmd): cbase should not be NULL; it should be
  either ruby_wrapper or Object.

* enum.c (enum_each_with_index): should return self.

* process.c (proc_setpgrp): should return value for non-void function.

* process.c (proc_getpgid): should raise exception if getpgid() return -1.

* string.c (rb_str_ljust): should return a duplicated string.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d472 1
a472 1
const mbc_startpos_func_t mbc_startpos_func[];
d4576 1
a4576 1
const mbc_startpos_func_t mbc_startpos_func[4] = {
@


1.64
log
@* eval.c (rb_eval_string_wrap): should hide the toplevel local
  variable bindings by PUSH_SCOPE().
@
text
@d2260 1
a2260 1
	c = scan_oct(p, 3, &numlen);
@


1.63
log
@* regex.c: fix prototypes of xmalloc(), xcalloc() and xrealloc().
@
text
@a74 10

#define xmalloc ruby_xmalloc
#define xcalloc ruby_xcalloc
#define xrealloc ruby_xrealloc
#define xfree ruby_xfree

void *xmalloc _((long));
void *xcalloc _((long,long));
void *xrealloc _((void*,long));
void xfree _((void*));
@


1.62
log
@* regex.c (re_compile_fastmap): skip begpos.
@
text
@d81 3
a83 3
void *xmalloc _((size_t));
void *xcalloc _((size_t,size_t));
void *xrealloc _((void*,size_t));
@


1.61
log
@* regex.c (mbc_startpos): become macro.

* regex.c (euc_startpos): added for improvement.

* regex.c (sjis_startpos): ditto.

* regex.c (utf8_startpos): ditto.
@
text
@d2785 1
a3052 1
      case begpos:
@


1.60
log
@* regex.c (re_adjust_startpos): fix for SJIS.

* regex.c (mbc_startpos): ditto.
@
text
@d481 3
a483 1
int mbc_startpos _((const char *start, int pos));
a4388 1
  /* forward scan */
a4404 18

  /* reverse scan */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
a4407 1
  /* forward scan */
a4423 18

  /* reverse scan */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0
d4426 1
a4426 2
static const unsigned char mbctab_sjis[] = { /* 0x80-0x9f,0xE0-0xFF */
  /* forward scan */
d4442 2
a4443 1
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,
d4445 1
a4445 1
  /* reverse scan */
a4464 1
  /* forward scan */
a4480 18

  /* reverse scan */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
d4509 17
a4525 2
int
mbc_startpos(string, pos)
d4527 1
a4527 1
     int pos;
d4529 1
a4529 1
  int i = pos, w;
d4531 1
a4531 1
  while (i > 0 && re_mbctab[(unsigned char)string[i]+256]) {
d4534 3
a4536 1
  if (i == pos || i + (w = mbclen(string[i])) > pos) return i;
d4538 2
d4541 10
a4550 3
  switch (current_mbctype) {
  case MBCTYPE_EUC:
    return i + ((pos - i) & ~1);
d4552 9
a4560 4
  case MBCTYPE_SJIS:
    while (i + (w = mbclen(string[i])) < pos) {
      i += w;
    }
d4562 4
d4567 14
a4580 1
  case MBCTYPE_UTF8:
a4581 2
  default:
    return pos;
d4583 1
d4585 4
@


1.59
log
@* regex.c (re_adjust_startpos): search start of multibyte
  backward.

* regex.c (mbc_startpos): ditto.
@
text
@d3083 11
a3093 5
    if (i < startpos && range > 0) {
      startpos = i + mbclen(string[i]);
    }
    else {
      startpos = i;
d4579 2
d4582 5
a4586 2
    /* double byte char only */
    return i + ((pos - i) & ~1);
d4588 1
@


1.58
log
@* array.c (Init_Array): remove Array#filter.

* object.c (rb_mod_initialize): should accept zero argument.

* object.c (rb_mod_cmp): should raise ArgumentError if
  inheritance/inclusion relation between two classes/modules is
  not defined. [new]

* io.c (rb_io_fsync): new method. [new]
@
text
@d481 2
d3081 1
a3081 1
    int i = 0;
d3083 2
a3084 8
    if (range > 0) {
      while (i<size) {
	i += mbclen(string[i]);
	if (startpos <= i) {
	  startpos = i;
	  break;
	}
      }
d3087 1
a3087 10
      int w;

      while (i<size) {
	w = mbclen(string[i]);
	if (startpos < i + w) {
	  startpos = i;
	  break;
	}
	i += w;
      }
d4381 19
d4419 20
a4446 1
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
d4457 1
d4473 19
a4491 1
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
d4495 1
d4511 19
a4529 1
  3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 0, 0
d4557 33
@


1.57
log
@* string.c (rb_str_new2): NULL pointer check added.

* class.c (rb_define_module_under): should locate predefined
  module using rb_const_defined_at().
@
text
@a372 1
    fail,        /* always fails. */
d378 1
a378 1
    notwordbound,/* Succeeds if not at a word boundary.  */
d463 1
a463 1
	c = c << 6 | *p++ & ((1<<6)-1);					\
d504 1
a504 1
      printf("%c", c);
d506 1
a506 1
      printf("%c%c", utf8_firstbyte(c), c&0x3f);
d508 2
a509 1
      printf("%c%c%c", utf8_firstbyte(c), (c>>6)&0x3f, c&0x3f);
d511 2
a512 1
      printf("%c%c%c%c", utf8_firstbyte(c), (c>>12)&0x3f, (c>>6)&0x3f, c&0x3f);
d514 2
a515 1
      printf("%c%c%c%c%c", utf8_firstbyte(c), (c>>18)&0x3f, (c>>12)&0x3f, (c>>6)&0x3f, c&0x3f);
d517 3
a519 1
      printf("%c%c%c%c%c%c", utf8_firstbyte(c), (c>>24)&0x3f, (c>>18)&0x3f, (c>>12)&0x3f, (c>>6)&0x3f, c&0x3f);
d522 1
a522 1
    printf("\\%o", c);
d525 1
a525 1
    printf("%c%c", c>>BYTEWIDTH, c&0xff);
d1191 1
a1191 1
  register unsigned int c, c1;
a1252 1
  int *stackt;
d1485 2
a1486 2
		  (current_mbctype && !re_mbctab[c] ||
		  !current_mbctype && SYNTAX(c) != Sword2))
@


1.56
log
@* process.c (rb_f_system): abandon vfork.

* io.c (pipe_open): ditto.

* defines.h: sparc linux needs different FLUSH_REGISTER_WINDOWS

* regex.c (re_search): abandon stclass optimization.

* bignum.c (rb_cstr2inum): deny "0_".

* bignum.c (rb_cstr2inum): allow "0\n" and so on.

* error.c (rb_invalid_str): utility function to show inspect()'ed
  string.

* bignum.c (rb_cstr2inum): prints invalid strings in inspect()'ed
  format.

* object.c (rb_Float): ditto.

* object.c (rb_convert_type): no longer use rb_rescue().

* re.c (rb_reg_search): initialize taint status of match object.
@
text
@a2379 13
    else if (*laststart == on_failure_jump) {
      int mcnt;

      laststart++;
      EXTRACT_NUMBER_AND_INCR(mcnt, laststart);
      if (*laststart == charset || *laststart == charset_not) {
	p0 = laststart;
	mcnt = *++p0;
	p0 += mcnt+1;
	mcnt = EXTRACT_UNSIGNED_AND_INCR(p0);
	p0 += 8*mcnt;
      }
    }
@


1.55
log
@* array.c (rb_ary_modify): should copy the internal buffer if the
  modifying buffer is shared.

* array.c (ary_make_shared): make an internal buffer of an array
  to be shared.

* array.c (rb_ary_shift): avoid sliding an internal buffer by
  using shared buffer.

* array.c (rb_ary_subseq): avoid copying the buffer.

* parse.y (gettable): should freeze __LINE__ string.

* io.c (rb_io_puts): old behavoir restored.  rationale: a) if you
  want to call to_s for arrays, you can just call print a, "\n".
  b) to_s wastes memory if array (and sum of its contents) is
  huge.  c) now any object that has to_ary is treated as an array,
  using rb_check_convert_type().

* hash.c (rb_hash_initialize): now accepts a block to calculate
  the default value. [new]

* hash.c (rb_hash_aref): call "default" method to get the value
  corrensponding to the non existing key.

* hash.c (rb_hash_default): get the default value based on the
  block given to 'new'.  Now it takes an optinal "key" argument.
  "default" became the method to get the value for non existing
  key.  Users may override "default" method to change the hash
  behavior.

* hash.c (rb_hash_set_default): clear the flag if a block is given
  to 'new'

* object.c (Init_Object): undef Data.allocate, left Data.new.

* ext/curses/curses.c (window_scrollok): use RTEST().

* ext/curses/curses.c (window_idlok): ditto.

* ext/curses/curses.c (window_keypad): ditto.

* ext/curses/curses.c (window_idlok): idlok() may return void on
  some platforms; so don't use return value.

* ext/curses/curses.c (window_scrollok): ditto for consistency.

* ext/curses/curses.c: replace FIX2INT() by typechecking NUM2INT().

* parse.y (str_extend): should not process immature #$x and
  #@@x interpolation, e.g #@@#@@ etc.

* enum.c (enum_sort_by): sort_by does not have to be stable always.

* enum.c (enum_sort_by): call qsort directly to gain performance.

* util.c (ruby_qsort): ruby_qsort(qs6) is now native thread safe.

* error.c (rb_sys_fail): it must be a bug if it's called when
  errno == 0.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@a1266 1
  bufp->stclass = 0;
a2390 3
	if (*p0 == maybe_finalize_jump) {
	  bufp->stclass = laststart;
	}
a3282 24
      }
      else if (fastmap && (bufp->stclass)) {
	register unsigned char *p;
	unsigned long c;
	int irange = range;

	p = (unsigned char*)string+startpos;
	while (range > 0) {
	  c = *p++;
	  if (ismbchar(c) && fastmap[c] != 2) {
	    MBC2WC(c, p);
	  }
	  else if (MAY_TRANSLATE())
	    c = translate[c];
	  if (*bufp->stclass == charset) {
	    if (!is_in_list(c, bufp->stclass+1)) break;
	  }
	  else {
	    if (is_in_list(c, bufp->stclass+1)) break;
	  }
	  range--;
	  if (c > 256) range--;
	}
	startpos += irange - range;
@


1.54
log
@* string.c (rb_str_chomp_bang): do smart chomp if $/ == '\n'.

* io.c (rb_io_puts): don't treat Array specially.

* bignum.c (rb_big_cmp): should convert bignum to float.

* eval.c (rb_f_eval): can't modify untainted binding.

* regex.c (re_compile_pattern): should preverve p0 value.
@
text
@d480 1
a480 1
 ((c<0x100)?(c):((current_mbctype != MBCTYPE_UTF8)?(((c)>>8)&0xff):utf8_firstbyte(c)))
@


1.53
log
@* marshal.c (r_object): better allocation type check for
  TYPE_UCLASS. usage of allocation framework is disabled for now.

* variable.c (rb_class_path): Module may have subclass.

* string.c (rb_str_update): should maintain original negative
  offset.

* string.c (rb_str_subpat_set): ditto

* string.c (rb_str_aset): ditto.

* re.c (rb_reg_nth_match): should check negative nth.

* re.c (rb_reg_nth_defined): ditto.
@
text
@d1543 9
a1551 5
	    p0 = --p;
	    c = read_special(p, pend, &p0);
	    if (c > 255) goto invalid_escape;
	    p = p0;
	    had_num_literal = 1;
@


1.52
log
@* string.c (rb_str_init): String.new() => ""

* dir.c (dir_path): new method.

* dir.c (dir_initialize): wrap DIR into struct, along with path
  information.
@
text
@d3415 1
a3415 1
    *stackp++ = (unsigned char*)options; /* current option status */	\
d4296 1
a4296 1
      options = (int)*--stackp;
@


1.51
log
@* ruby.c (proc_options): should not alter origargv[].

* ruby.c (set_arg0): long strings for $0 dumped core.

* ruby.c (set_arg0): use setprogtitle() if it's available.

* io.c (rb_io_popen): accept integer flags as mode.

* file.c (rb_find_file_ext): extension table can be supplied from
  outside.  renamed.

* eval.c (rb_f_require): replace rb_find_file_noext by
  rb_find_file_ext.

* eval.c (rb_provided): should also check feature without
  extension.

* numeric.c (flo_to_s): do not rely on decimal point to be '.'
@
text
@d1274 3
a1276 7
    if (bufp->buffer)
      /* EXTEND_BUFFER loses when bufp->allocated is 0.  */
      bufp->buffer = (char*)xrealloc(bufp->buffer, INIT_BUF_SIZE);
    else
      /* Caller did not allocate a buffer.  Do it for them.  */
      bufp->buffer = (char*)xmalloc(INIT_BUF_SIZE);
    if (!bufp->buffer) goto memory_exhausted;
@


1.50
log
@* range.c (range_step): 'iter' here should be an array.

* marshal.c (w_object): should retrieve __member__ data from
  non-singleton class.

* variable.c (rb_cvar_get): class variable override check added.

* variable.c (rb_cvar_set): ditto

* variable.c (rb_cvar_declare): ditto.

* parse.y (parse_regx): handle backslash escaping of delimiter here.
@
text
@d4180 1
a4180 1
	if (AT_STRINGS_BEG(d)) {
@


1.49
log
@* ruby.h: enable volatile directive with VC++.

* regex.c: ditto.
@
text
@d2900 1
d3744 2
@


1.48
log
@* regex.c (NUM_FAILURE_ITEMS): was confusing NUM_REG_ITEMS and
  NUM_NONREG_ITEMS, which have happened to be same value.

* class.c (rb_class_new): subclass check moved to this function.

* class.c (rb_class_boot): check less version of rb_class_new().

* eval.c (proc_invoke): should preserve iter status for embedded
  frame in the block.

* file.c (rb_file_s_expand_path): may overrun buffer on stack.

* string.c (rb_str_insert): forgot to call rb_str_modify().
@
text
@d54 1
a54 1
#ifndef __STDC__
@


1.47
log
@* regex.c (re_search): should consider reverse search.

* dir.c (dir_s_chdir): warn only when invoked from multiple
  threads or block is not given.

* object.c (rb_convert_type): should use rb_rescue(), not rb_rescue2().

* range.c (range_init): ditto.

* object.c (rb_obj_dup): should free generic_ivar if original owns
  them.

* string.c (rb_str_each_line): should propagate taint mark.

* ext/nkf/nkf.c (rb_nkf_kconv): ditto.

* eval.c (rb_f_require): revamp for simpler implementation.

* file.c (rb_find_file_noext): use String object, instead of
  passing char* around.

* file.c (rb_find_file): ditto.

* dln.c (dln_load): should use NSLINKMODULE_OPTION_BINDNOW.

* ruby.c (load_file): local variables 'c' remain uninitialized on
  xflag.

* regex.c (re_match): prefetched escaped character too early.

* eval.c (rb_call0): add argument check for attr_readers.
@
text
@d3376 1
a3376 1
#define NUM_FAILURE_ITEMS  (last_used_reg * NUM_REG_ITEMS + NUM_REG_ITEMS + 1)
@


1.46
log
@* It is confusing to put the GPL license terms in the file COPYING;
  Rename the files COPYING and COPYING.LIB to GPL and LGPL, respectively.

* While I am here, update the LGPL with the "Lesser" one.

* Move the "copying" sections of the files README and README.jp to
  COPYING and COPYING.jp, respectively.
@
text
@d3267 1
a3267 1
    if ((anchor || !bufp->can_be_null) && size > 0 && startpos == size)
a4239 1
	    c = *d++;
d4248 1
@


1.45
log
@* error.c (exc_exception): clone the receiver exception instead of
  creating brand new exception object of the receiver.

* eval.c (rb_eval_string_wrap): extend new ruby_top_self, not
  original self.

* eval.c (rb_eval_cmd): respect ruby_wrapper if set.

* eval.c (eval): do not update ruby_class unless scope is not
  provided.

* eval.c (eval): preserve wrapper information.

* eval.c (proc_invoke): ditto.

* eval.c (block_pass): ditto.

* parse.y (void_expr): too much warnings for void context
  (e.g. foo[1] that can be mere Proc call).

* error.c (rb_name_error): new function to raise NameError with
  name attribute set.

* eval.c (rb_f_missing): set name and args in the exception
  object. [new]

* error.c (name_name): NameError#name - new method.

* error.c (nometh_args): NoMethodError#args - new method.

* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.

* dir.c (isdelim): space, tab, and newline are no longer
  delimiters for glob patterns.

* eval.c (svalue_to_avalue): new conversion scheme between single
  value and array values.

* eval.c (avalue_to_svalue): ditto.

* eval.c (rb_eval): REXPAND now uses avalue_to_svalue(), return
  and yield too.

* eval.c (rb_yield_0): use avalue_to_svalue().

* eval.c (proc_invoke): Proc#call gives avaules, whereas
  Proc#yield gives mvalues.

* eval.c (bmcall): convert given value (svalue) to avalue.
@
text
@d15 1
a15 1
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
@


1.44
log
@* eval.c (rb_f_require): searches ".rb" and ".so" at the same
  time.  previous behavior (search ".rb", then ".so") has a
  security risk (ruby-bugs#PR140).

* array.c (rb_ary_to_ary): new function to replace internal
  rb_Array(), which never calls to_a, but to_ary (rb_Array() might
  call both). [new]

* regex.c (PUSH_FAILURE_POINT): push option status again.

* regex.c (re_compile_pattern): avoid pushing unnecessary
  option_set.

* eval.c (rb_load): tainted string is OK if wrapped *and*
  $SAFE >= 4.

* eval.c (rb_thread_start_0): should not nail down higher blocks
  before preserving original context (i.e. should not alter
  original context).

* eval.c (proc_yield): new method equivalent to Proc#call but no
  check for number of arguments. [new]
@
text
@d3499 1
@


1.43
log
@* eval.c (rb_load): should check if tainted even when wrap is
  specified.

* regex.c (re_compile_pattern): too much optimization for the
  cases like /(.|a)b/.
@
text
@d1877 4
a1880 2
	BUFPUSH(option_set);
	BUFPUSH(stackp[-1]);
d3267 2
a3268 1
    if (anchor && size > 0 && startpos == size) return -1;
d3368 1
a3368 1
#define NUM_NONREG_ITEMS 3
d3418 1
a3741 1
#if 0
a3746 3
#else
          d2 = IS_ACTIVE(reg_info[regno])?old_regstart[regno]:regstart[regno];
#endif
d3794 1
a3794 1
	d = stackp[-2];
d4018 2
a4019 2
	if (stackp > stackb && stackp[-2] == d) {
	  p = stackp[-3];
d4035 1
a4035 1
        if (mcnt < 0 && stackp > stackb && stackp[-2] == d) /* avoid infinite loop */
d4126 1
a4126 1
        if (mcnt < 0 && stackp > stackb  && stackp[-2] == d) /* avoid infinite loop */
d4291 1
a4291 1
      if (stackp[-3] == 0 || (best_regs_set && stackp[-1] == NON_GREEDY)) {
d4295 2
a4296 1
      stackp--;		/* discard flag */
@


1.42
log
@* variable.c (rb_mod_const_at): use hash table as internal
  data. [new]

* variable.c (rb_mod_const_of): ditto.

* variable.c (rb_const_list): new function to convert internal
  data (hash table) to array of strings.

* eval.c (rb_mod_s_constants): data handling scheme has changed.

* eval.c (rb_add_method): should not call rb_secure(), for
  last_func may not be set.

* io.c (rb_io_ctl): ioctl should accept any integer within C long
  range.

* marshal.c (r_object): wrong type check for modules.

* marshal.c (w_object): should not dump anonymous classes/modules.

* io.c (rb_open_file): use rb_file_sysopen_internal() if the 3rd
  argument (permission flags) is given. [new, should be backported?]

* io.c (rb_io_mode_binmode): mode string (e.g. "r+") to flags to
  open(2).

* eval.c (rb_eval): NODE_REXPAND expand an array of 1 element as
  the element itself. [new, should be backported?]

* parse.y (ret_args): should treat "*[a]" in rhs expression as
  "a", not "[a]".

* regex.c (re_compile_pattern): should push option modifier at the
  right place.
@
text
@d2384 1
a2384 15
      if (mcnt == 4 && *laststart == anychar) {
	switch ((enum regexpcode)laststart[1]) {
	case jump_n:
	case finalize_jump:
	case maybe_finalize_jump:
	case jump:
	case jump_past_alt:
	case dummy_failure_jump:
	  bufp->options |= RE_OPTIMIZE_ANCHOR;
	  break;
	default:
	  break;
	}
      }
      else if (*laststart == charset || *laststart == charset_not) {
@


1.41
log
@* ruby.c (proc_options): unexpected SecurityError happens when -T4.

* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.

* string.c (rb_str_cat): use rb_str_buf_cat() if possible. [new]

* string.c (rb_str_append): ditto.

* string.c (rb_str_buf_cat): remove unnecessary check (type,
  taint, modify) to gain performance.

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_new): buffering string function. [new]

* string.c (rb_str_buf_append): ditto.

* string.c (rb_str_buf_cat): ditto.

* time.c (make_time_t): local time adjustment revised.
@
text
@d546 1
a546 1
#define EXTEND_BUFFER							\
a1262 1
  int old_options = 0;
d1685 2
a1686 4
      old_options = options;
      PATFETCH(c);
      if (c == '?') {
	int negative = 0;
d1688 1
a1688 8
	PATFETCH_RAW(c);
	switch (c) {
	case 'x': case 'p': case 'm': case 'i': case '-':
	  for (;;) {
	    switch (c) {
	    case '-':
	      negative = 1;
	      break;
d1690 3
a1692 3
	    case ':':
	    case ')':
	      break;
d1694 31
a1724 6
	    case 'x':
	      if (negative)
		options &= ~RE_OPTION_EXTENDED;
	      else
		options |= RE_OPTION_EXTENDED;
	      break;
d1726 8
a1733 4
	    case 'p':
	      if (negative) {
		if ((options&RE_OPTION_POSIXLINE) == RE_OPTION_POSIXLINE) {
		  options &= ~RE_OPTION_POSIXLINE;
d1735 2
a1736 6
	      }
	      else if ((options&RE_OPTION_POSIXLINE) != RE_OPTION_POSIXLINE) {
		options |= RE_OPTION_POSIXLINE;
	      }
	      push_option = 1;
	      break;
d1738 8
a1745 4
	    case 'm':
	      if (negative) {
		if (options&RE_OPTION_MULTILINE) {
		  options &= ~RE_OPTION_MULTILINE;
d1747 2
a1748 6
	      }
	      else if (!(options&RE_OPTION_MULTILINE)) {
		options |= RE_OPTION_MULTILINE;
	      }
	      push_option = 1;
	      break;
d1750 2
a1751 6
	    case 'i':
	      if (negative) {
		if (options&RE_OPTION_IGNORECASE) {
		  options &= ~RE_OPTION_IGNORECASE;
		  BUFPUSH(casefold_off);
		}
d1753 3
a1755 3
	      else if (!(options&RE_OPTION_IGNORECASE)) {
		options |= RE_OPTION_IGNORECASE;
		BUFPUSH(casefold_on);
d1757 4
a1760 1
	      break;
d1762 4
a1765 2
	    default:
	      FREE_AND_RETURN(stackb, "undefined (?...) inline option");
d1767 27
a1793 6
	    if (c == ')') {
	      c = '#';	/* read whole in-line options */
	      break;
	    }
	    if (c == ':') break;
	    PATFETCH_RAW(c);
d1796 4
d1801 15
a1815 6
	case '#':
	  for (;;) {
	    PATFETCH(c);
	    if (c == ')') break;
	  }
	  c = '#';
a1817 1
	case ':':
d1821 10
d1833 3
d1837 1
a1837 1
	  FREE_AND_RETURN(stackb, "undefined (?...) sequence");
d1843 11
a1854 52
      else {
	PATUNFETCH;
	c = '(';
      }
      if (c == '#') break;
      if (stackp+8 >= stacke) {
	DOUBLE_STACK(int);
      }

      /* Laststart should point to the start_memory that we are about
	 to push (unless the pattern has RE_NREGS or more ('s).  */
      /* obsolete: now RE_NREGS is just a default register size. */
      *stackp++ = b - bufp->buffer;    
      *stackp++ = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
      *stackp++ = begalt - bufp->buffer;
      switch (c) {
      case '(':
	BUFPUSH(start_memory);
	BUFPUSH(regnum);
	*stackp++ = regnum++;
	*stackp++ = b - bufp->buffer;
	BUFPUSH(0);
	/* too many ()'s to fit in a byte. (max 254) */
	if (regnum >= RE_REG_MAX) goto too_big;
	break;

      case '=':
      case '!':
      case '>':
	BUFPUSH(start_nowidth);
	*stackp++ = b - bufp->buffer;
	BUFPUSH(0);	/* temporary value */
	BUFPUSH(0);
	if (c != '!') break;

	BUFPUSH(on_failure_jump);
	*stackp++ = b - bufp->buffer;
	BUFPUSH(0);	/* temporary value */
	BUFPUSH(0);
	break;

      case ':':
	BUFPUSH(start_paren);
	pending_exact = 0;
      default:
	break;
      }
      *stackp++ = c;
      *stackp++ = old_options;
      fixup_alt_jump = 0;
      laststart = 0;
      begalt = b;
a1860 7
      if (options != stackp[-1]) {
	if ((options ^ stackp[-1]) & RE_OPTION_IGNORECASE) {
	  BUFPUSH((options&RE_OPTION_IGNORECASE)?casefold_off:casefold_on);
	}
	BUFPUSH(option_set);
	BUFPUSH(stackp[-1]);
      }
d1872 7
@


1.40
log
@* eval.c (block_pass): should not downgrade safe level.

* ext/dbm/extconf.rb: allow specifying dbm-type explicitly.

* ext/dbm/extconf.rb: avoid gdbm if possible, because it leaks
  memory, whereas gdbm.so doesn't.  potential incompatibility.

* string.c (rb_str_insert): new method.

* parse.y (yylex): lex_state after RESCUE_MOD should be EXPR_BEG.

* array.c (rb_ary_insert): new method.

* array.c (rb_ary_update): new utility function.

* io.c (set_outfile): should check if closed before assignment.

* eval.c (rb_eval): should preserve value of ruby_errinfo.

* eval.c (rb_thread_schedule): infinite sleep should not cause
  dead lock.

* array.c (rb_ary_flatten_bang): proper recursive detection.

* eval.c (yield_under): need not to prohibit at safe level 4.

* pack.c (pack_pack): p/P packs nil into NULL.

* pack.c (pack_unpack): p/P unpacks NULL into nil.

* pack.c (pack_pack): size check for P template.

* ruby.c (set_arg0): wrong predicate when new $0 value is bigger
  than original space.

* gc.c (id2ref): should use NUM2ULONG()

* object.c (rb_mod_const_get): check whether name is a class
  variable name.

* object.c (rb_mod_const_set): ditto.

* object.c (rb_mod_const_defined): ditto.

* marshal.c (w_float): precision changed to "%.16g"

* eval.c (rb_call0): wrong retry behavior.

* numeric.c (fix_aref): a bug on long>int architecture.

* eval.c (rb_eval_string_wrap): should restore ruby_wrapper.

* regex.c (re_compile_pattern): char class at either edge of range
  should be invalid.

* eval.c (handle_rescue): use === to compare exception match.

* error.c (syserr_eqq): comparison between SytemCallErrors should
  based on their error numbers.

* eval.c (safe_getter): should use INT2NUM().

* bignum.c (rb_big2long): 2**31 cannot fit in 31 bit long.

* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).

* class.c (rb_singleton_class_attached): should modify iv_tbl by
  itself, no longer use rb_iv_set() to avoid freeze check error.

* variable.c (rb_const_get): error message "uninitialized constant
  Foo at Bar::Baz" instead of "uninitialized constantBar::Baz::Foo".

* eval.c (rb_mod_included): new hook called from rb_mod_include().

* io.c (opt_i_set): should strdup() inplace_edit string.

* eval.c (exec_under): need to push cref too.

* eval.c (rb_f_missing): raise NameError for "undefined local
  variable or method".

* error.c (Init_Exception): new exception NoMethodError.
  NameError moved under ScriptError again.

* eval.c (rb_f_missing): use NoMethodError instead of NameError.

* file.c (Init_File): should redifine "new" class method.

* eval.c (PUSH_CREF): sharing cref node was problematic.  maintain
  runtime cref list instead.

* eval.c (rb_eval): copy defn node before registering.

* eval.c (rb_load): clear ruby_cref before loading.

* variable.c (rb_const_get): no recursion to show full class path
  for modules.

* eval.c (rb_set_safe_level): should set safe level in curr_thread
  as well.

* eval.c (safe_setter): ditto.

* object.c (rb_obj_is_instance_of): nil belongs to false, not true.

* time.c (make_time_t): proper (I hope) daylight saving time
  handling for both US and Europe.  I HATE DST!

* eval.c (rb_thread_wait_for): non blocked signal interrupt should
  stop the interval.

* eval.c (proc_eq): class check aded.

* eval.c (proc_eq): typo fixed ("return" was ommitted).

* error.c (Init_Exception): move NameError under StandardError.

* class.c (rb_mod_clone): should copy method bodies too.

* bignum.c (bigdivrem): should trim trailing zero bdigits of
  remainder, even if dd == 0.

* file.c (check3rdbyte): safe string check moved here.

* time.c (make_time_t): remove HAVE_TM_ZONE code since it
  sometimes reports wrong time.

* time.c (make_time_t): remove unnecessary range check for
  platforms where negative time_t is available.

* process.c (proc_waitall): should push Process::Status instead of
  Finuxm status.

* process.c (waitall_each): should add all entries in pid_tbl.
  these changes are inspired by Koji Arai.  Thanks.

* process.c (proc_wait): should not iterate if pid_tbl is 0.

* process.c (proc_waitall): ditto.

* numeric.c (flodivmod): a bug in no fmod case.

* process.c (pst_wifsignaled): should apply WIFSIGNALED for status
  (int), not st (VALUE).

* io.c (Init_IO): value of $/ and $\ are no longer restricted to
  strings.  type checks are done on demand.

* class.c (rb_include_module): module inclusion should be check
  taints.

* ruby.h (STR2CSTR): replace to StringType() and StringTypePtr().

* ruby.h (rb_str2cstr): ditto.

* eval.c (rb_load): should not copy topleve local variables.  It
  cause variable/method ambiguity.  Thanks to L. Peter Deutsch.

* class.c (rb_include_module): freeze check at first.

* eval.c (rb_attr): sprintf() and rb_intern() moved into
  conditional body.
@
text
@d373 1
d2250 2
a2251 2
	{
	  const char *p_save;
d2253 9
a2261 4
	  PATUNFETCH;
	  p_save = p;

	  had_mbchar = 0;
d2263 2
a2264 12
	  GET_UNSIGNED_NUMBER(c1);
	  if (!ISDIGIT(c)) PATUNFETCH;

	  if (c1 >= regnum) {
	    /* need to get octal */
	    p = p_save;
	    c = scan_oct(p_save, 3, &numlen) & 0xff;
	    p = p_save + numlen;
	    c1 = 0;
	    had_num_literal = 1;
	    goto numeric_char;
	  }
a2266 4
	/* Can't back reference to a subexpression if inside of it.  */
	for (stackt = stackp - 2;  stackt > stackb;  stackt -= 5)
	  if (*stackt == c1)
	    goto normal_char;
d3731 3
a3733 1
	  if (IS_ACTIVE(reg_info[regno])) break;
d3737 4
a3740 1
	  if (REG_UNSET(d2)) break;
d3748 1
a3748 1
	  if (REG_UNSET(dend2)) break;
@


1.39
log
@* io.c (rb_io_ctl): do not call ioctl/fcntl for f2, if f and f2
  have same fileno.

* eval.c (rb_load): raise LocaJumpError if unexpected local jumps
  appear during load.

* ext/socket/socket.c (bsock_close_read): don't call rb_thread_fd_close();
  it's supposed to be called by io_io_close().

* ext/socket/socket.c (bsock_close_read): do not modify f and f2.

* ext/socket/socket.c (bsock_close_write): ditto.

* ext/socket/socket.c (sock_new): avoid dup(2) on sockets.

* parse.y (primary): preserve and clear in_single and in_def using
  stack to prevent nested method errors in singleton class bodies.
@
text
@d1052 1
a1052 1
	p -= 3;
d1441 3
d1465 1
d1480 1
d1491 1
d1499 1
d1509 1
d1516 1
d1526 1
@


1.38
log
@matz
@
text
@d3464 2
a3465 1
			     ((d)[-1] >= 0x80 || IS_A_LETTER((d)-1)))
@


1.38.2.1
log
@* parse.y (primary): preserve and clear in_single and in_def using
  stack to prevent nested method errors in singleton class bodies.
@
text
@d3464 1
a3464 2
                             ((current_mbctype && ((d)[-1] >= 0x80)) ||	\
			      IS_A_LETTER((d)-1)))
@


1.38.2.2
log
@* regex.c (calculate_must_string): wrong length calculation.

* eval.c (rb_thread_start_0): fixed memory leak.

* parse.y (none): should clear cmdarg_stack too.

* io.c (rb_fopen): use setvbuf() to avoid recursive malloc() on
  some platforms.

* file.c (rb_stat_dev): device functions should honor stat field
  types (except long long such as dev_t).

* eval.c (rb_mod_nesting): should not push nil for nesting array.

* eval.c (rb_mod_s_constants): should not search array by
  rb_mod_const_at() for nil (happens for singleton class).
@
text
@d1052 1
a1052 1
       p -= 2;
@


1.38.2.3
log
@preview2
@
text
@a1440 4
	if (range && had_char_class) {
	  FREE_AND_RETURN(stackb, "invalid regular expression; can't use character class as a end value of range");
	  goto invalid_pattern;
	}
a1475 1
	    had_char_class = 1;
a1485 1
	    had_char_class = 1;
a1492 1
	    had_char_class = 1;
a1501 1
	    had_char_class = 1;
a1507 1
	    had_char_class = 1;
a1516 1
	    had_char_class = 1;
@


1.38.2.4
log
@m68m frame_pointer patch
@
text
@d1442 2
a1443 1
	  FREE_AND_RETURN(stackb, "invalid regular expression; can't use character class as an end value of range");
a1465 1
	had_char_class = 0;
@


1.38.2.5
log
@* regex.c (re_compile_pattern): no back reference to a
  subexpression if inside of it.

* eval.c (rb_yield_0): preserve and restore ruby_cref as well.
@
text
@a2260 1
         need_to_get_octal:
d2272 3
a2274 18
       for (stackt = stackp - 2;  stackt > stackb;  ) {
           switch (*stackt) {
           case '(':
               if (stackt[-2] == c1)
                   goto need_to_get_octal;
               stackt -= 5;
               break;
           case '!':
               stackt--;
           case '=':
           case '>':
               stackt -= 4;
               break;
           default:
               stackt -= 3;
               break;
           }
       }
@


1.38.2.6
log
@* regex.c (re_compile_pattern): * \1 .. \9 should be
  backreferences always.

* regex.c (re_match): backreferences corresponding to
  unclosed/unmatched parentheses should fail always.
@
text
@a372 1
    fail,        /* always fails. */
d2249 3
d2253 1
a2253 1
	p0 = p;
d2260 2
a2261 1
	if (9 < c1 && c1 >= regnum) {
d2263 3
a2265 2
	  c = scan_oct(p0, 3, &numlen) & 0xff;
	  p = p0 + numlen;
d2270 1
d2272 19
d3755 1
a3755 2
	  /* Check if corresponding group is still open */
	  if (IS_ACTIVE(reg_info[regno])) goto fail;
d3759 1
a3759 1
	  if (REG_UNSET(d2)) goto fail;
d3767 1
a3767 1
	  if (REG_UNSET(dend2)) goto fail;
@


1.38.2.7
log
@* regex.c (re_compile_pattern): should push option modifier at the
  right place.
@
text
@d3358 1
a3358 1
#define NUM_NONREG_ITEMS 4
a3407 1
    *stackp++ = (unsigned char*)options; /* current option status */	\
d3783 1
a3783 1
	d = stackp[-3];
d4007 2
a4008 2
	if (stackp > stackb && stackp[-3] == d) {
	  p = stackp[-4];
d4024 1
a4024 1
        if (mcnt < 0 && stackp > stackb && stackp[-3] == d) /* avoid infinite loop */
d4115 1
a4115 1
        if (mcnt < 0 && stackp > stackb  && stackp[-3] == d) /* avoid infinite loop */
d4280 1
a4280 1
      if (stackp[-4] == 0 || (best_regs_set && stackp[-1] == NON_GREEDY)) {
d4284 1
a4284 2
      stackp--;		/* discard greedy flag */
      options = (int)*--stackp;
@


1.38.2.8
log
@* eval.c (rb_load): should check if tainted even when wrap is
  specified.

* regex.c (re_compile_pattern): too much optimization for the
  cases like /(.|a)b/.

* variable.c (fc_i): removed vast string allocation.
@
text
@d2363 15
a2377 1
      if (*laststart == charset || *laststart == charset_not) {
@


1.38.2.9
log
@* eval.c (rb_f_require): searches ".rb" and ".so" at the same
  time.  previous behavior (search ".rb", then ".so") has a
  security risk (ruby-bugs#PR140).

* regex.c (re_compile_pattern): avoid pushing unnecessary
  option_set.

* eval.c (rb_load): tainted string is OK if wrapped *and*
  $SAFE >= 4.

* eval.c (rb_thread_start_0): should not nail down higher blocks
  before preserving original context (i.e. should not alter
  original context).
@
text
@d1263 1
d1686 1
a1686 5
      {
	int old_options = options;
	int push_option = 0;
	int casefold = 0;

d1690 1
a1690 1

d1739 1
d1744 1
a1745 1
		casefold = 1;
a1776 6
	}
	else {
	  PATUNFETCH;
	  c = '(';
	}
	if (c == '#') {
a1780 5
	  if (casefold) {
	    if (options & RE_OPTION_IGNORECASE)
	      BUFPUSH(casefold_on);
	    else
	      BUFPUSH(casefold_off);
d1782 3
a1784 1
	  break;
d1786 1
a1828 10
	if (push_option) {
	  BUFPUSH(option_set);
	  BUFPUSH(options);
	}
	if (casefold) {
	  if (options & RE_OPTION_IGNORECASE)
	    BUFPUSH(casefold_on);
	  else
	    BUFPUSH(casefold_off);
	}
a1833 1
      }
d1840 7
a1858 9
      if (options != stackp[-1]) {
	if ((options ^ stackp[-1]) & RE_OPTION_IGNORECASE) {
	  BUFPUSH((options&RE_OPTION_IGNORECASE)?casefold_off:casefold_on);
	}
	if ((options ^ stackp[-1]) != RE_OPTION_IGNORECASE) {
	  BUFPUSH(option_set);
	  BUFPUSH(stackp[-1]);
	}
      }
d3244 1
a3244 2
    if ((anchor || !bufp->can_be_null) && size > 0 && startpos == size)
      return -1;
@


1.38.2.10
log
@* lex.c (rb_reserved_word): lex_state after tRESCUE should be
  EXPR_MID.

* gc.c (add_heap): allocation size of the heap unit is doubled for
  each allocation.
@
text
@a3498 1
    regs->allocated = num_regs;
@


1.38.2.11
log
@* eval.c (rb_f_require): move rb_file_s_expand_path from
  rb_find_file_noext().

* file.c (rb_find_file_noext): move rb_file_s_expand_path to
  rb_f_require().

* string.c (rb_str_each_line): should propagate taint mark.

* ext/nkf/nkf.c (rb_nkf_kconv): ditto.

* ruby.c (load_file): local variables 'c' remain uninitialized on
  xflag.

* regex.c (re_match): prefetched escaped character too early.

* eval.c (rb_call0): add argument check for attr_readers.
@
text
@d4240 1
a4248 1
	    c = *d++;
@


1.38.2.12
log
@* It is confusing to put the GPL license terms in the file COPYING;
  Rename the files COPYING and COPYING.LIB to GPL and LGPL, respectively.

* While I am here, update the LGPL with the "Lesser" one.

* Move the "copying" sections of the files README and README.jp to
  COPYING and COPYING.jp, respectively.
@
text
@d15 1
a15 1
   License along with the GNU C Library; see the file LGPL.  If not,
@


1.38.2.13
log
@* eval.c (proc_invoke): should preserve iter status for embedded
  frame in the block.

* file.c (rb_file_s_expand_path): may overrun buffer on stack.

* regex.c (re_search): should consider reverse search.
@
text
@d15 1
a15 1
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
d3267 1
a3267 1
    if ((anchor || !bufp->can_be_null) && range > 0 && size > 0 && startpos == size)
@


1.38.2.14
log
@regex.c updated
@
text
@d3376 1
a3376 1
#define NUM_FAILURE_ITEMS  (last_used_reg * NUM_REG_ITEMS + NUM_NOREG_ITEMS + 1)
@


1.38.2.15
log
@back port from 1.7
@
text
@d3376 1
a3376 1
#define NUM_FAILURE_ITEMS  (last_used_reg * NUM_REG_ITEMS + NUM_NONREG_ITEMS + 1)
@


1.38.2.16
log
@* eval.c (is_defined): should not dump core for "defined?(())".

* eval.c (umethod_bind): recv can be an instance of descender of
  oklass if oklass is a Module.

* hash.c (rb_hash_equal): check identiry equality first.

* variable.c (mod_av_set): detect constant overriding for built-in
  classes/modules.

* marshal.c (w_object): should retrieve __member__ data from
  non-singleton class.
@
text
@a3742 2
	  /* Check if there's corresponding group */
	  if (regno >= num_regs) goto fail;
@


1.38.2.17
log
@* io.c (rb_io_popen): accept integer flags as mode.

* file.c (rb_find_file_ext): extension table can be supplied from
  outside.  renamed.

* eval.c (rb_f_require): replace rb_find_file_noext by
  rb_find_file_ext.

* eval.c (rb_provided): should also check feature without
  extension.

* numeric.c (flo_to_s): do not rely on decimal point to be '.'

* parse.y (yylex): ternary ? can be followed by newline.
@
text
@d4179 1
a4179 1
	if (AT_STRINGS_END(d)) {
@


1.38.2.18
log
@* eval.c (rb_eval): should override existing class.
@
text
@d3418 1
a3418 1
    *stackp++ = (unsigned char*)(long)options; /* current option status */	\
d4299 1
a4299 1
      options = (long)*--stackp;
@


1.38.2.19
log
@* eval.c (rb_f_eval): can't modify untainted binding.

* regex.c (re_compile_pattern): should preverve p0 value.
@
text
@d1547 5
a1551 9
	    {
	      char *pp;

	      --p;
	      c = read_special(p, pend, &pp);
	      if (c > 255) goto invalid_escape;
	      p = pp;
	      had_num_literal = 1;
	    }
@


1.38.2.20
log
@* parse.y (gettable): should freeze __LINE__ string.

* parse.y (str_extend): should not process immature #$x and
  #@@x interportation, e.g #@@#@@ etc.

* regex.c (WC2MBC1ST): should not pass through > 0x80 number in UTF-8.
@
text
@d480 1
a480 1
 ((current_mbctype != MBCTYPE_UTF8) ? ((c<0x100) ? (c) : (((c)>>8)&0xff)) : utf8_firstbyte(c))
@


1.38.2.21
log
@forgot to commit everything bug ChangeLog
@
text
@d1267 1
d2396 3
d3290 24
@


1.38.2.22
log
@* string.c (rb_str_new2): NULL pointer check added.

* class.c (rb_define_module_under): should locate predefined
  module using rb_const_defined_at().
@
text
@d2384 13
@


1.38.2.23
log
@* class.c (rb_include_module): detect cyclic module inclusion.

* eval.c (rb_thread_schedule): should check time only if BOTH
  WAIT_SELECT and WAIT_TIME.

* string.c (rb_str_split_m): no need to consider KANJI
characters, if the length of separator is 1 (byte).
@
text
@d373 1
d379 1
a379 1
    notwordbound /* Succeeds if not at a word boundary.  */
d464 1
a464 1
	c = c << 6 | (*p++ & ((1<<6)-1));				\
d505 1
a505 1
      printf("%c", (int)c);
d507 1
a507 1
      printf("%c%c", (int)utf8_firstbyte(c), (int)(c & 0x3f));
d509 1
a509 2
      printf("%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 6) & 0x3f),
	     (int)(c & 0x3f));
d511 1
a511 2
      printf("%c%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 12) & 0x3f),
	     (int)((c >> 6) & 0x3f), (int)(c & 0x3f));
d513 1
a513 2
      printf("%c%c%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 18) & 0x3f),
	     (int)((c >> 12) & 0x3f), (int)((c >> 6) & 0x3f), (int)(c & 0x3f));
d515 1
a515 3
      printf("%c%c%c%c%c%c", (int)utf8_firstbyte(c), (int)((c >> 24) & 0x3f),
	     (int)((c >> 18) & 0x3f), (int)((c >> 12) & 0x3f),
	     (int)((c >> 6) & 0x3f), (int)(c & 0x3f));
d518 1
a518 1
    printf("\\%o", (int)c);
d521 1
a521 1
    printf("%c%c", (int)(c >> BYTEWIDTH), (int)(c &0xff));
d1187 1
a1187 1
  register unsigned int c, c1 = 0;
d1249 1
d1486 2
a1487 2
		  ((current_mbctype && !re_mbctab[c]) ||
		  (!current_mbctype && SYNTAX(c) != Sword2)))
@


1.38.2.24
log
@* regex.c (re_compile_fastmap): skip begpos.
@
text
@a2784 1
      case begpos:
d3051 1
@


1.38.2.25
log
@* regex.c (re_compile_pattern): '\0111' should be '\011' plus '1',
  since octal literals are formed by three digits at most.

* eval.c (rb_eval_cmd): cbase should not be NULL; it should be
  either ruby_wrapper or Object.

* enum.c (enum_each_with_index): should return self.

* process.c (proc_setpgrp): should return value for non-void function.

* process.c (proc_getpgid): should raise exception if getpgid() return -1.

* string.c (rb_str_ljust): should return a duplicated string.

* string.c (rb_str_rjust): ditto.

* string.c (rb_str_center): ditto.
@
text
@d2270 1
a2270 1
	c = scan_oct(p, 2, &numlen);
@


1.38.2.26
log
@* file.c (rb_find_file): load must be done from an abolute path if
  $SAFE >= 4.

* re.c (rb_reg_s_quote): quote whitespaces for /x cases.

* eval.c (rb_thread_cleanup): should not terminate main_thread by
  Fatal error.

* regex.c (is_in_list): need to not exclude NUL and NEWLINE.

* re.c (rb_reg_expr_str): wrong backslash escapement.

* re.c (rb_reg_expr_str): do not escape embedded space
  characters.

* eval.c (rb_thread_cleanup): current thread may be THREAD_STOPPED,
  for example when terminated from signal handler.

* re.c (rb_reg_expr_str): should treat backslash specially in
  escaping.

* bignum.c (rb_big_eq): check `y == x' if y is neither Fixnum,
  Bignum, nor Float.

* pack.c (pack_unpack): should treat 'U' in character unit, not in
  byte unit.

* marshal.c (w_uclass): should check based on rb_obj_class(), not
  CLASS_OF().

* io.c (io_write): check error if written data is less than
  specified size to detect EPIPE.

* eval.c (assign): ruby_verbose should be surrounded by RTEST().

* object.c (rb_str2cstr): ditto.

* parse.y (void_expr): ditto.

* parse.y (void_stmts): ditto.

* variable.c (rb_ivar_get): ditto.

* variable.c (rb_cvar_set): ditto.

* variable.c (rb_cvar_get): ditto.
@
text
@d720 2
a721 1
  if (i < size && EXTRACT_MBC(&b[i*8]) <= c)
@


1.38.2.27
log
@* eval.c (rb_thread_schedule): need to preserve errno before
  calling rb_trap_exec().

* regex.c (calculate_must_string): a bug in charset/charset_not
  parsing.
@
text
@d1048 1
a1048 1
	p += 8;
@


1.38.2.28
log
@* parse.y (read_escape): deny zero-width hexadecimal character.
  (ruby-bugs-ja:PR#260)

* parse.y (tokadd_escape): ditto.

* regex.c (re_compile_pattern): ditto.
@
text
@a1532 1
	    if (numlen == 0) goto invalid_escape;
a2261 1
	if (numlen == 0) goto invalid_escape;
@


1.38.2.29
log
@* regex.c (re_match): p1 may exceed pend limit.
@
text
@d4039 1
a4039 1
	if (p1 < pend && (enum regexpcode)*p1 == jump)
@


1.38.4.1
log
@m17n fix
@
text
@a22 2
/* modified for Ruby by matz@@netlab.co.jp */
/* M17n modify by matz@@zetabits.com */
d35 4
a166 2
#define enc bufp->encoding

d174 10
d185 3
d189 2
a190 2
static void bm_init_skip _((int*, unsigned char*, int, m17n_encoding*));
static m17n_encoding *default_encoding = 0;
d198 70
a267 11
#define ISGRAPH(c) (m17n_isprint(enc,(c)) && !m17n_isspace(enc,(c)))
#define ISPRINT(c) m17n_isprint(enc,(c))
#define ISDIGIT(c) m17n_isdigit(enc,(c))
#define ISALNUM(c) m17n_isalnum(enc,(c))
#define ISALPHA(c) m17n_isalpha(enc,(c))
#define ISCNTRL(c) m17n_iscntrl(enc,(c))
#define ISLOWER(c) m17n_islower(enc,(c))
#define ISPUNCT(c) m17n_ispunct(enc,(c))
#define ISSPACE(c) m17n_isspace(enc,(c))
#define ISUPPER(c) m17n_isupper(enc,(c))
#define ISXDIGIT(c) m17n_isxdigit(enc,(c))
d417 15
d435 2
a436 2
#define TRANSLATE_P() ((options&RE_OPTION_IGNORECASE) && enc)
#define MAY_TRANSLATE() ((bufp->options&(RE_OPTION_IGNORECASE|RE_MAY_IGNORECASE)) && enc)
d444 1
a444 1
    if (TRANSLATE_P()) c = (unsigned char)m17n_toupper(enc, (c));	\
d457 14
a470 1
#define MBC2WC(c,p,e) (c) = m17n_codepoint(enc, (p), (e))
d475 1
a475 1
    MBC2WC(c, p, pend);					\
d478 19
a496 1
#define WC2MBC1ST(c) m17n_firstbyte(enc, (c))
d499 1
a499 1
print_mbc(c, encode)
a500 1
     m17n_encoding *encode;
d502 15
a516 1
  if (c < 0xff) {
d520 1
a520 5
    char buf[16];

    memset(buf, 0, sizeof buf);
    m17n_mbcput(encode, c, buf);
    printf("%s", buf);
d566 2
a567 1
  (b[(unsigned char)(c) / BYTEWIDTH] |= 1 << ((unsigned char)(c) % BYTEWIDTH))
d722 1
a722 1
print_partial_compiled_pattern(start, end, encode)
a724 1
    m17n_encoding *encode;
d837 1
a837 1
	  print_mbc(EXTRACT_MBC_AND_INCR(p), encode);
d839 1
a839 1
	  print_mbc(EXTRACT_MBC_AND_INCR(p), encode);
d973 1
a973 1
  print_partial_compiled_pattern(buffer, buffer + bufp->used, bufp->encoding);
d1269 2
a1270 6
  if (!bufp->encoding) {
      if (!default_encoding) {
	  return "encoding is not set";
      }
      bufp->encoding = default_encoding;
  }
d1433 1
a1433 1
	    || m17n_mbmaxlen(enc) > 1) {
d1469 2
a1470 1
	      if (m17n_isalnum(enc, c))
d1473 1
a1473 1
	    if (m17n_mbmaxlen(enc) > 1) {
d1481 3
a1483 1
	      if (m17n_codelen(enc, c) == 1 && !m17n_isalnum(enc, c))
d1500 1
a1500 1
	    if (m17n_mbmaxlen(enc) > 1)
d1515 1
a1515 1
	    if (m17n_mbmaxlen(enc) > 1)
d1631 1
d1649 2
a1650 2
	    SET_LIST_BIT(TRANSLATE_P()?m17n_toupper(enc, '['):'[');
	    SET_LIST_BIT(TRANSLATE_P()?m17n_toupper(enc, ':'):':');
d1655 1
a1655 1
	else if (had_mbchar == 0 && (m17n_mbmaxlen(enc) == 1 || !had_num_literal)) {
d2401 10
a2410 13
  if (bufp->must) {
    if (!m17n_islead(enc, bufp->must[1])) {
      bufp->options |= RE_OPTIMIZE_NO_BM;
    }
    else {
      int i;
      int len = (unsigned char)bufp->must[0];

      for (i=1; i<len; i++) {
	if ((unsigned char)bufp->must[i] == 0xff) {
	  bufp->options |= RE_OPTIMIZE_NO_BM;
	  break;
	}
d2417 1
a2417 1
		   (MAY_TRANSLATE()?enc:0));
d2589 1
a2589 1
#define trans_eq(c1, c2, encode) (encode?(m17n_toupper(encode, (c1))==m17n_toupper(encode, (c2))):((c1)==(c2)))
d2591 1
a2591 1
slow_match(little, lend, big, bend, encode)
d2594 1
a2594 1
     m17n_encoding *encode;
d2602 1
a2602 1
    if (!trans_eq(*big++, c, encode)) break;
d2609 1
a2609 1
slow_search(little, llen, big, blen, encode, translate)
d2614 1
a2614 2
     m17n_encoding *encode;
     int translate;
d2626 2
a2627 2
  else if (translate && m17n_mbclen(encode, c) == 1) {
    c = m17n_toupper(encode, c);
d2638 1
a2638 1
    else if (translate && m17n_mbclen(encode, c) == 1) {
d2640 2
a2641 4
	int n = m17n_mbclen(encode, *big);
	if (n > 1)
	  big+=n-1;
	else if (m17n_toupper(encode, *big) == c) break;
a2646 2
	int n;

d2648 1
a2648 3
	n = m17n_mbclen(encode, *big);
	if (n > 1)
	  big += n-1;
d2653 1
a2653 1
    if (slow_match(little, little+llen, big, bend, encode))
d2656 1
a2656 1
    big+=m17n_mbclen(encode, *big);
d2662 1
a2662 1
bm_init_skip(skip, pat, m, encode)
d2666 1
a2666 1
     m17n_encoding *encode;
d2673 1
a2673 1
  if (encode) {
d2675 1
a2675 1
      skip[m17n_toupper(encode, pat[j])] = m-1-j;
d2686 1
a2686 1
bm_search(little, llen, big, blen, skip, encode, translate)
d2692 1
a2692 2
     m17n_encoding *encode;
     int translate;
d2701 1
a2701 1
      while (j >= 0 && m17n_toupper(encode, big[k]) == m17n_toupper(encode, little[j])) {
d2707 1
a2707 1
      i += skip[m17n_toupper(encode,big[i])];
d2771 1
a2771 1
	    fastmap[m17n_toupper(enc, p[2])] = 2;
d2777 1
a2777 1
	  fastmap[m17n_toupper(enc, p[1])] = 1;
d2808 1
a2808 1
	  fastmap[m17n_toupper(enc, '\n')] = 1;
d2908 1
a2908 1
	  if (m17n_isalnum(enc, j))
d2911 13
a2923 3
	for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	  if (m17n_mbclen(enc, j) == 1 && m17n_isalnum(enc, j)) {
	    fastmap[j] = 1;
d2925 1
d2931 1
a2931 4
	  if (!m17n_isalnum(enc, j))
	    fastmap[j] = 1;
	for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	  if (m17n_mbclen(enc, j) == 1 && !m17n_isalnum(enc, j)) {
d2933 13
d2947 1
d2956 1
a2956 1
	    int tmp = TRANSLATE_P()?m17n_toupper(enc, j):j;
d3080 1
a3080 1
  if (enc->index != 0 && startpos>0 && !(bufp->options&RE_OPTIMIZE_BMATCH)) {
d3189 2
a3190 2
			string+pbeg, pend-pbeg, enc,
			MAY_TRANSLATE());
d3195 2
a3196 2
		      bufp->must_skip, enc, 
		      MAY_TRANSLATE());
d3237 1
a3237 1
	    if (fastmap[MAY_TRANSLATE() ? m17n_toupper(enc, c) : c])
d3250 1
a3250 1
	if (MAY_TRANSLATE() ? !fastmap[m17n_toupper(enc, c)] : !fastmap[c])
d3284 1
a3284 1
	    MBC2WC(c, p, string+size);
d3287 1
a3287 1
	    c = m17n_toupper(enc, c);
d3456 6
a3461 2
#define IS_A_LETTER(d) (m17n_mbclen(enc, *d) == 1 ? m17n_iswchar(enc, *d) : 1)
#define PREV_IS_A_LETTER(d) ((enc->index == 3)?	/* SJIS hack */		\
d3759 2
a3760 2
		? m17n_memcmp(d, d2, mcnt, enc) 
		: memcmp(d, d2, mcnt))
d3805 1
a3805 1
	    && (TRANSLATE_P() ? m17n_toupper(enc, *d) : *d) == '\n')
d3823 1
a3823 1
	      (TRANSLATE_P() ? m17n_toupper(enc, *d) : *d) == '\n')
d3842 1
a3842 1
	      MBC2WC(c, d, pend);
d3846 1
a3846 1
	    cc = c = (unsigned char)m17n_toupper(enc, c);
d3977 1
a3977 1
	      MBC2WC(c, pp, pend);
d4247 1
a4247 1
	    if ((unsigned char)m17n_toupper(enc, c) != (unsigned char)m17n_toupper(enc, *p++))
d4350 25
d4408 81
d4490 2
a4491 2
re_set_default_encoding(encode)
    m17n_encoding *encode;
d4493 18
a4510 1
    default_encoding = encode;
@


1.38.4.2
log
@several minor fixes.
@
text
@d24 1
a24 1
/* M17n modify by matz@@netlab.jp */
d374 2
a375 2
    if (m17n_mbcspan(enc, p, pend) == 0) goto end_of_pattern;		\
    MBC2WC(c, p, pend);							\
d1479 1
d2275 6
a2280 2
    int i;
    int len = (unsigned char)bufp->must[0];
d2282 5
a2286 5
    for (i=1; i<len; i++) {
      if ((unsigned char)bufp->must[i] == 0xff) {
	bufp->options |= RE_OPTIMIZE_NO_BM;
	bufp->options &= ~RE_OPTIMIZE_EXACTN;
	break;
a2288 3
    if (!m17n_islead(enc, bufp->must[1])) {
      bufp->options &= ~RE_OPTIMIZE_EXACTN;
    }
d2654 5
a2658 1
	  fastmap[p[2]] = 2;
d2838 1
d2942 1
a2942 1
  if (m17n_mbmaxlen(enc) > 1 && startpos > 0) {
d3318 1
a3318 1
#define IS_A_LETTER(d) m17n_iswchar(enc, m17n_codepoint(enc, d, dend))
d3617 1
a3617 1
		? m17n_casecmp(d, d2, mcnt, enc) 
@


1.37
log
@matz
@
text
@a3768 1
	printf("%d > %d\n", stackp - stackb, RE_DUP_MAX);
@


1.36
log
@matz
@
text
@d3769 1
@


1.35
log
@matz
@
text
@d2398 1
a2398 1
  else {
@


1.34
log
@matz
@
text
@d97 1
a97 1
# else
@


1.33
log
@matz
@
text
@a86 2
#define	NO_ALLOCA	/* try it out for now */
#ifndef NO_ALLOCA
a111 1
#define RE_ALLOCATE alloca
a117 12
#define FREE_AND_RETURN_VOID(stackb)	return
#define FREE_AND_RETURN(stackb,val)	return(val)
#define DOUBLE_STACK(stackx,stackb,len,type)				\
        (stackx = (type*)alloca(2 * len * sizeof(type)),		\
	/* Only copy what is in use.  */				\
        (type*)memcpy(stackx, stackb, len * sizeof (type)))
#else  /* NO_ALLOCA defined */

#define RE_ALLOCATE xmalloc

#define FREE_VARIABLES()

d119 1
d125 1
d130 3
a132 1
#define DOUBLE_STACK(stackx,stackb,len,type) do {			\
d134 2
a135 1
    stackx = (type*)xmalloc(2*len*sizeof(type));			\
d138 1
a138 1
    stackx = (type*)xrealloc(stackb, 2 * len * sizeof(type));		\
d140 4
d146 1
a146 3
#endif /* NO_ALLOCA */

#define RE_TALLOC(n,t)  ((t*)RE_ALLOCATE((n)*sizeof(t)))
d150 1
a150 10
#define EXPAND_FAIL_STACK(stackx,stackb,len) 				\
    do {								\
        /* Roughly double the size of the stack.  */			\
        DOUBLE_STACK(stackx,stackb,len,unsigned char*);			\
	/* Rearrange the pointers. */					\
	stackp = stackx + (stackp - stackb);				\
	stackb = stackx;						\
	stacke = stackb + 2 * len;					\
    } while (0)

a153 2
	unsigned char **stackx;						\
	unsigned int len = stacke - stackb;				\
a155 1
	   FREE_VARIABLES();						\
d160 1
a160 1
        EXPAND_FAIL_STACK(stackx, stackb, len);				\
d1777 1
a1777 8
	int *stackx;
	unsigned int len = stacke - stackb;

	DOUBLE_STACK(stackx,stackb,len,int);
	/* Rearrange the pointers. */
	stackp = stackx + (stackp - stackb);
	stackb = stackx;
	stacke = stackb + 2 * len;
d2867 1
a2867 4
	  unsigned char **stackx;
	  unsigned int len = stacke - stackb;

	  EXPAND_FAIL_STACK(stackx, stackb, len);
d3537 1
a3537 1
  unsigned char *stacka[MAX_NUM_FAILURE_ITEMS * NFAILURES];
d3586 1
a3687 1
      FREE_VARIABLES();
a3769 1
	   FREE_VARIABLES();
a4346 1
  FREE_VARIABLES();
@


1.32
log
@matz
@
text
@d65 2
d133 10
a142 2
#define FREE_AND_RETURN_VOID(stackb)   do { xfree(stackb); return; } while(0)
#define FREE_AND_RETURN(stackb,val)    do { xfree(stackb); return(val); } while(0)
d144 6
a149 1
        stackx = (type*)xrealloc(stackb, 2 * len * sizeof(type));	\
d151 1
d1264 2
a1265 1
  int *stackb = RE_TALLOC(40, int);
d2772 3
a2774 1
  unsigned char **stackb = RE_TALLOC(NFAILURES, unsigned char*);
d3567 1
a3571 1

d3616 1
a3616 1
  stackb = RE_TALLOC(MAX_NUM_FAILURE_ITEMS * NFAILURES, unsigned char*);
@


1.31
log
@matz
@
text
@d1193 2
d1323 4
a1326 1
	goto invalid_pattern;
d1408 1
a1408 1
	goto invalid_pattern;
d1449 1
a1449 1
	      goto invalid_pattern;
d1460 1
a1460 1
	  goto invalid_pattern;
d1590 1
a1590 1
	    goto invalid_pattern;
d1619 5
a1623 2
	    if (!IS_CHAR_CLASS(str))
	      goto invalid_pattern;
d1629 1
a1629 1
	      goto invalid_pattern;
d1949 5
a1953 2
      if (!laststart || p == pend) {
	goto invalid_pattern;
d1955 2
d2135 2
a2136 1
      if (p == pend) goto invalid_pattern;
@


1.30
log
@matz
@
text
@d3369 1
a3369 1
    *stackp++ = (unsigned char*)c;					\
d3388 1
a3388 1
    *stackp++ = (unsigned char*)num_failure_counts;			\
@


1.29
log
@matz
@
text
@d3140 1
a3140 1
  if (bufp->used>0) {
d3199 1
@


1.28
log
@matz
@
text
@d152 16
d2088 1
a2088 1
		       upper_bound/* - 1*/);
d2106 1
a2106 1
		      upper_bound/* - 1*/);
d3348 3
d3360 1
a3360 1
#define NUM_FAILURE_ITEMS  (last_used_reg * NUM_REG_ITEMS + NUM_REG_ITEMS)
d3362 10
d3386 3
a3388 12
    if (stacke - stackp <= NUM_FAILURE_ITEMS) {				\
	unsigned char **stackx;						\
	unsigned int len = stacke - stackb;				\
	/* if (len > re_max_failures * MAX_NUM_FAILURE_ITEMS)		\
	   {								\
	   FREE_VARIABLES();						\
	   FREE_AND_RETURN(stackb,(-2));				\
	   }*/								\
									\
        /* Roughly double the size of the stack.  */			\
        EXPAND_FAIL_STACK(stackx, stackb, len);				\
      }									\
d3407 8
a3414 1
     /* This pops what PUSH_FAILURE_POINT pushes.  */
d3423 5
d3575 2
d3938 1
a3938 1
	   then we can change to pop_failure_jump, because we'll
d4062 1
a4062 1
	if (mcnt > 0) {
d4065 1
d4069 1
a4069 3
	else if (mcnt == 0) {
	  p[2] = unused;
	  p[3] = unused;
d4079 1
d4296 4
@


1.27
log
@matz
@
text
@d3553 1
a3553 1
  fprintf(stderr, "Entering re_match(%s%s)\n", string1_arg, string2_arg);
@


1.26
log
@matz
@
text
@d1994 1
a1994 1
      /* If lower_bound == upper_bound, repeat cound can be removed */
d2072 1
a2072 1
		       upper_bound - 1);
d2090 1
a2090 1
		      upper_bound - 1);
d3411 1
a3411 2
          MATCHED_SOMETHING(reg_info[this_reg])				\
            = 1;							\
@


1.25
log
@2000-05-24
@
text
@d3967 1
a3967 1
	if (stackp[-2] == d) {
d3984 1
a3984 1
        if (mcnt < 0 && stackp > stackb && stackp[-2] == d) /* avoid infinit loop */
d4075 1
a4075 1
        if (mcnt < 0 && stackp[-2] == d) /* avoid infinit loop */
@


1.24
log
@/p is back for transit
@
text
@d235 1
a235 1
# define ISBLANK(c) (ISASCII (c) && isblank (c))
d240 1
a240 1
# define ISGRAPH(c) (ISASCII (c) && isgraph (c))
d242 1
a242 1
# define ISGRAPH(c) (ISASCII (c) && isprint (c) && !isspace (c))
d246 10
a255 10
#define ISPRINT(c) (ISASCII (c) && isprint (c))
#define ISDIGIT(c) (ISASCII (c) && isdigit (c))
#define ISALNUM(c) (ISASCII (c) && isalnum (c))
#define ISALPHA(c) (ISASCII (c) && isalpha (c))
#define ISCNTRL(c) (ISASCII (c) && iscntrl (c))
#define ISLOWER(c) (ISASCII (c) && islower (c))
#define ISPUNCT(c) (ISASCII (c) && ispunct (c))
#define ISSPACE(c) (ISASCII (c) && isspace (c))
#define ISUPPER(c) (ISASCII (c) && isupper (c))
#define ISXDIGIT(c) (ISASCII (c) && isxdigit (c))
d267 1
a267 1
# define SIGN_EXTEND_CHAR(c) ((signed char) (c))
d270 1
a270 1
# define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
d353 1
a353 4
    mline_on,      /* Turn on multi line match (match with newlines). */
    mline_off,     /* Turn off multi line match. */
    posix_on,      /* Turn on POSIXified line match (match with newlines). */
    posix_off,     /* Turn off POSIXified line match. */
d395 1
a395 1
    (destination) += SIGN_EXTEND_CHAR (*(char*)((source) + 1)) << 8; } while (0)
d538 1
a538 1
    bufp->buffer = (char*)xrealloc (bufp->buffer, bufp->allocated);	\
d572 1
a572 1
#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
d766 2
a767 2
    case mline_on:
      printf("/mline_on");
a769 10
    case mline_off:
      printf("/mline_off");
      break;

    case posix_on:
      printf("/posix_on");

    case posix_off:
      printf("/posix_off");

d771 1
a771 1
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
d841 1
a841 1
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
d846 1
a846 1
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
d855 1
a855 1
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
d860 1
a860 1
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
d865 1
a865 1
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
d870 1
a870 1
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
d875 2
a876 2
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      EXTRACT_NUMBER_AND_INCR (mcnt2, p);
d881 2
a882 2
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      EXTRACT_NUMBER_AND_INCR (mcnt2, p);
d887 2
a888 2
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      EXTRACT_NUMBER_AND_INCR (mcnt2, p);
d893 1
a893 1
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
d898 1
a898 1
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
d903 2
a904 2
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      EXTRACT_NUMBER_AND_INCR (mcnt2, p);
d961 1
a961 1
  print_partial_compiled_pattern (buffer, buffer + bufp->used);
d1023 1
a1023 4
    case mline_on:
    case mline_off:
    case posix_on:
    case posix_off:
d1037 1
a1037 1
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
d1041 1
a1041 1
	EXTRACT_NUMBER_AND_INCR (mcnt, p);
d1050 1
a1050 1
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
d1247 1
d1261 1
a1261 1
      bufp->buffer = (char*)xrealloc (bufp->buffer, INIT_BUF_SIZE);
d1274 1
a1274 1
      if (bufp->options & RE_OPTION_POSIXLINE) {
d1294 1
a1294 1
      if (bufp->options & RE_OPTION_POSIXLINE)
d1564 1
a1564 1
	  PATFETCH_RAW (c);
d1598 1
a1598 1
	    if (!IS_CHAR_CLASS (str))
d1602 1
a1602 1
	    PATFETCH (c);
d1620 1
a1620 1
		SET_LIST_BIT (ch);
d1649 2
a1650 2
		2 + EXTRACT_UNSIGNED (&b[(1 << BYTEWIDTH) / BYTEWIDTH])*8);
      b += b[-1] + 2 + EXTRACT_UNSIGNED (&b[b[-1]])*8;
d1654 1
d1658 1
d1681 1
a1681 1
		if (options&RE_OPTION_POSIXLINE) {
a1682 1
		  BUFPUSH(posix_off);
d1685 1
a1685 1
	      else if (!(options&RE_OPTION_POSIXLINE)) {
a1686 1
		BUFPUSH(posix_on);
d1688 1
a1694 1
		  BUFPUSH(mline_off);
a1698 1
		BUFPUSH(mline_on);
d1700 1
d1745 4
d1805 1
a1805 1
      *stackp++ = options;
d1814 7
a1820 8
      if ((options ^ stackp[-1]) & RE_OPTION_IGNORECASE) {
	BUFPUSH((options&RE_OPTION_IGNORECASE)?casefold_off:casefold_on);
      }
      if ((options ^ stackp[-1]) & RE_OPTION_POSIXLINE) {
	BUFPUSH((options&RE_OPTION_MULTILINE)?posix_off:posix_on);
      }
      if ((options ^ stackp[-1]) & RE_OPTION_MULTILINE) {
	BUFPUSH((options&RE_OPTION_MULTILINE)?mline_off:mline_on);
d2102 1
a2102 1
      PATFETCH (c);	
d2186 1
a2186 1
	if ((bufp->options & RE_OPTION_POSIXLINE) == 0) {
d2780 2
a2781 8
      case mline_on:
      case mline_off:
	options ^= RE_OPTION_MULTILINE;
	continue;

      case posix_on:
      case posix_off:
	options ^= RE_OPTION_POSIXLINE;
d2789 1
a2789 1
	if ((options & RE_OPTION_POSIXLINE) == 0 && bufp->can_be_null == 0)
d2874 1
a2874 1
	  if (j != '\n' || (options & RE_OPTION_POSIXLINE))
d3152 1
a3152 1
    if (bufp->options&RE_OPTION_POSIXLINE) {
d3768 2
a3769 3
	if (!(options&RE_OPTION_MULTILINE) &&
	    !(options&RE_OPTION_POSIXLINE) &&
	    (TRANSLATE_P() ? translate[*d] : *d) == '\n')
d4116 2
a4117 14
      case mline_on:
	options |= RE_OPTION_MULTILINE;
	continue;

      case mline_off:
	options &= ~RE_OPTION_MULTILINE;
	continue;

      case posix_on:
	options |= RE_OPTION_POSIXLINE;
	continue;

      case posix_off:
	options &= ~RE_OPTION_POSIXLINE;
d4280 1
a4280 1
	  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
@


1.23
log
@regex fixed for (?m)
@
text
@d355 2
d777 6
d1038 2
d1289 16
a1304 10
      p0 = p;
      /* When testing what follows the $,
	 look past the \-constructs that don't consume anything.  */

      while (p0 != pend) {
	if (*p0 == '\\' && p0 + 1 != pend
	    && (p0[1] == 'b' || p0[1] == 'B'))
	  p0 += 2;
	else
	  break;
a1305 1
      BUFPUSH(endline);
d1307 1
d1309 4
a1312 1
      BUFPUSH(begline);
d1693 10
a1702 1
	      FREE_AND_RETURN(stackb, "(?p) is deprecated");
d1717 1
d1828 3
d2198 5
a2202 3
	BUFPUSH(endbuf2);
	break;

d2797 5
d2807 1
a2807 1
	if (bufp->can_be_null == 0)
d2892 1
a2892 1
	  if (j != '\n')
d3170 3
d3787 1
d4141 8
@


1.22
log
@2000-05-18
@
text
@d1655 1
a1655 1
	case 'x': case 'p': case 'i': case '-':
@


1.21
log
@thread problems
@
text
@a352 2
    posix_on,      /* Turn on POSIXified line match (match with newlines). */
    posix_off,     /* Turn off POSIXified line match. */
a766 8
    case posix_on:
      printf("/posix_on");
      break;

    case posix_off:
      printf("/posix_off");
      break;

a1027 2
    case posix_on:
    case posix_off:
d1279 10
a1288 16
      if (bufp->options & RE_OPTION_POSIXLINE) {
	BUFPUSH(endbuf);
      }
      else {
	p0 = p;
	/* When testing what follows the $,
	   look past the \-constructs that don't consume anything.  */

	while (p0 != pend) {
	  if (*p0 == '\\' && p0 + 1 != pend
	      && (p0[1] == 'b' || p0[1] == 'B'))
	    p0 += 2;
	  else
	    break;
	}
	BUFPUSH(endline);
d1290 1
d1293 1
a1293 4
      if (bufp->options & RE_OPTION_POSIXLINE)
	  BUFPUSH(begbuf);
      else
	  BUFPUSH(begline);
d1672 1
d1674 1
a1674 10
	      if (negative) {
		if (options&RE_OPTION_POSIXLINE) {
		  options &= ~RE_OPTION_POSIXLINE;
		  BUFPUSH(posix_off);
		}
	      }
	      else if (!(options&RE_OPTION_POSIXLINE)) {
		options |= RE_OPTION_POSIXLINE;
		BUFPUSH(posix_on);
	      }
d1676 1
a1798 3
      if ((options ^ stackp[-1]) & RE_OPTION_POSIXLINE) {
	BUFPUSH((options&RE_OPTION_POSIXLINE)?posix_off:posix_on);
      }
d1800 1
a1800 1
	BUFPUSH((options&RE_OPTION_POSIXLINE)?mline_off:mline_on);
d2166 3
a2168 5
	if ((bufp->options & RE_OPTION_POSIXLINE) == 0) {
	  BUFPUSH(endbuf2);
	  break;
	}
	/* fall through */
a2757 5
      case posix_on:
      case posix_off:
	options ^= RE_OPTION_POSIXLINE;
	continue;

d2768 1
a2768 1
	if ((options & RE_OPTION_POSIXLINE) == 0 && bufp->can_be_null == 0)
d2853 1
a2853 1
	  if (j != '\n' || (options & RE_OPTION_POSIXLINE))
a3130 3
    if (bufp->options&RE_OPTION_POSIXLINE) {
      goto begbuf_match;
    }
d3744 1
a3744 1
	if (!(options&RE_OPTION_POSIXLINE) &&
d3762 1
a3762 1
	  if (!(options&RE_OPTION_POSIXLINE) &&
a4089 8
	continue;

      case posix_on:
	options |= RE_OPTION_POSIXLINE;
	continue;

      case posix_off:
	options &= ~RE_OPTION_POSIXLINE;
@


1.20
log
@remove configure from repositry
@
text
@d355 2
d777 8
d1040 2
d1704 12
d1829 3
d2795 5
d4138 8
@


1.19
log
@2000-05-12
@
text
@a72 1
#endif
d74 5
a78 1
#ifndef xmalloc
d82 1
a82 1
void free _((void*));
d131 2
a132 2
#define FREE_AND_RETURN_VOID(stackb)   do { free(stackb); return; } while(0)
#define FREE_AND_RETURN(stackb,val)    do { free(stackb); return(val); } while(0)
d2416 12
a2427 12
  free(bufp->buffer);
  free(bufp->fastmap);
  if (bufp->must_skip) free(bufp->must_skip);

  free(bufp->regstart);
  free(bufp->regend);
  free(bufp->old_regstart);
  free(bufp->old_regend);
  free(bufp->best_regstart);
  free(bufp->best_regend);
  free(bufp->reg_info);
  free(bufp);
d4353 2
a4354 2
  if (regs->beg) free(regs->beg);
  if (regs->end) free(regs->end);
@


1.18
log
@2000-05-09
@
text
@d25 5
a29 7
#ifdef RUBY_PLATFORM
# define RUBY
extern int rb_prohibit_interrupt;
extern int rb_trap_pending;
# define CHECK_INTS if (!rb_prohibit_interrupt) {\
    if (rb_trap_pending) rb_trap_exec();\
}
d64 11
d82 1
a82 1
#define	NO_ALLOCA /*	/* try it out for now */
d486 1
a486 1
     unsigned long c;
d599 1
a599 1
  ((unsigned long)((unsigned char)(p)[0] << 24 |			\
d605 1
a605 1
  ((unsigned long)((p) += 4, 						\
a1409 6
      /* charset_not matches newline according to a syntax bit.  */
      if ((enum regexpcode)b[-2] == charset_not) {
	if (bufp->options & RE_OPTION_POSIXLINE)
	  SET_LIST_BIT ('\n');
      }

d2331 2
d3012 1
a4255 1
      pop_loop:
@


1.17
log
@2000-05-01
@
text
@d2980 1
a2980 1
	    while (c < beg) {
a2986 1
	    beg = WC2MBC1ST(cc);
d2989 1
a2989 1
	      while (c <= beg) {
d2995 1
a2995 1
	    c = beg + 1;
@


1.16
log
@2000-03-09
@
text
@d73 1
a73 1
#define	NO_ALLOCA */	/* try it out for now */
d165 1
a165 1
static void bm_init_skip _((int *, unsigned char*, int, const char*));
d2621 1
a2621 1
     const char *translate;
@


1.15
log
@2000-03-08
@
text
@d2999 1
a2999 1
	  for (j = c; j < (1 << BYTEWIDTH); j++)
d3004 1
@


1.14
log
@2000-02-23
@
text
@d1070 1
a1070 1
static int
d1102 41
d1514 10
d2227 10
d2399 3
@


1.13
log
@2000-02-17
@
text
@d4197 2
a4200 1
	  if (p1 >= pend) break;
@


1.12
log
@2000-02-08
@
text
@d3724 3
a3728 3
	  }
	  else if (!not && cc != c) {
	      part = not = is_in_list(cc, p);
@


1.11
log
@19991214
@
text
@d27 5
d67 3
a69 3
void *xmalloc _((unsigned long));
void *xcalloc _((unsigned long,unsigned long));
void *xrealloc _((void*,unsigned long));
d73 1
a73 1
/* #define	NO_ALLOCA */	/* try it out for now */
a116 1
#define FREE_VAR(var) do { if (var) free(var); var = NULL; } while(0)
d121 3
a123 2
#define DOUBLE_STACK(stackx,stackb,len,type) \
        (type*)xrealloc(stackb, 2 * len * sizeof(type))
d133 1
a133 1
        stackx = DOUBLE_STACK(stackx,stackb,len,unsigned char*);	\
d281 1
d346 1
d364 1
a364 1
#define NFAILURES 80
d777 5
d936 4
d1012 1
d1050 1
d1671 1
d1687 1
a1687 1
	stackx = DOUBLE_STACK(stackx,stackb,len,int);
d1713 1
d1718 1
a1718 1
	if (c == '=') break;
d1789 9
d2121 4
d2738 1
d3040 6
a3045 5
	if (startpos > 0)
	  return -1;
	else if (re_match(bufp, string, size, 0, regs) >= 0)
	    return 0;
	return -1;
d3053 5
d3149 2
a3150 4
    if (val >= 0)
      return startpos;
    if (val == -2)
      return -2;
d3658 6
d3794 6
d4142 3
@


1.10
log
@19991206
@
text
@d2925 1
a2925 13

/* Using the compiled pattern in BUFP->buffer, first tries to match
   STRING, starting first at index STARTPOS, then at STARTPOS + 1, and
   so on.  RANGE is the number of places to try before giving up.  If
   RANGE is negative, it searches backwards, i.e., the starting
   positions tried are STARTPOS, STARTPOS - 1, etc.  STRING is of SIZE.
   In REGS, return the indices of STRING that matched the entire
   BUFP->buffer and its contained subexpressions.

   The value returned is the position in the strings at which the match
   was found, or -1 if no match was found, or -2 if error (such as
   failure stack overflow).  */

d2927 1
a2927 1
re_search(bufp, string, size, startpos, range, regs)
a2930 1
     struct re_registers *regs;
a2931 7
  register char *fastmap = bufp->fastmap;
  int val, anchor = 0;

  /* Check for out-of-range starting position.  */
  if (startpos < 0  ||  startpos > size)
    return -1;

d2933 1
a2933 1
  if (fastmap && !bufp->fastmap_accurate) {
d2963 35
@


1.9
log
@19991111
@
text
@d399 1
d2276 1
a2276 1
      bm_init_skip(bufp->must_skip, bufp->must+1,
d2278 1
a2278 1
		   MAY_TRANSLATE()?translate:0);
d2630 1
d2833 1
a2833 1
	      if (c < 0x100)
d2835 2
d2955 27
@


1.8
log
@19991108
@
text
@a50 7
#if defined(STDC_HEADERS)
# include <stddef.h>
#else
/* We need this for `regex.h', and perhaps for the Emacs include files.  */
# include <sys/types.h>
#endif

@


1.7
log
@19991104
@
text
@d2066 1
d2074 1
@


1.6
log
@19991004
@
text
@d1409 2
a1410 1
		  (current_mbctype || SYNTAX(c) != Sword2))
@


1.6.2.1
log
@19991104
@
text
@d1409 1
a1409 2
		  (current_mbctype && !re_mbctab[c] ||
		  !current_mbctype && SYNTAX(c) != Sword2))
@


1.6.2.2
log
@19991111
@
text
@d51 7
@


1.6.2.3
log
@2000-03-02
@
text
@a4095 2

	  if (mcnt >= 0) break;	/* should be backward jump */
d4098 1
@


1.6.2.4
log
@2000-03-08
@
text
@d1051 1
a1051 1
static unsigned int
a1082 41
static unsigned int
read_special(p, pend, pp)
     const char *p, *pend, **pp;
{
  int c;

  PATFETCH_RAW(c);
  switch (c) {
  case 'M':
    PATFETCH_RAW(c);
    if (c != '-') return -1;
    PATFETCH_RAW(c);
    *pp = p;
    if (c == '\\') {
      return read_special(p, pend, pp) | 0x80;
    }
    else if (c == -1) return ~0;
    else {
      return ((c & 0xff) | 0x80);
    }

  case 'C':
    PATFETCH_RAW(c);
    if (c != '-') return ~0;
  case 'c':
    PATFETCH_RAW(c);
    *pp = p;
    if (c == '\\') {
      c = read_special(p, pend, pp);
    }
    else if (c == '?') return 0177;
    else if (c == -1) return ~0;
    return c & 0x9f;
  default:
    return read_backslash(c);
  }

 end_of_pattern:
  return ~0;
}

a1453 10
	  case 'M':
	  case 'C':
	  case 'c':
	    p0 = --p;
	    c = read_special(p, pend, &p0);
	    if (c > 255) goto invalid_escape;
	    p = p0;
	    had_num_literal = 1;
	    break;

a2139 10
      case 'M':
      case 'C':
      case 'c':
	p0 = --p;
	c = read_special(p, pend, &p0);
	if (c > 255) goto invalid_escape;
	p = p0;
	had_num_literal = 1;
	goto numeric_char;

a2301 3

 invalid_escape:
  FREE_AND_RETURN(stackb, "Invalid escape character syntax");
@


1.6.2.5
log
@2000-03-09
@
text
@d2959 1
a2959 1
	  for (j = c; j < (1 << BYTEWIDTH); j++) {
a2963 1
	  }
@


1.6.2.6
log
@2000-05-09
@
text
@d2940 1
a2940 1
	    while (c <= beg) {
d2947 1
d2950 1
a2950 1
	      while (c <= cc) {
d2956 1
a2956 1
	    c = WC2MBC1ST(cc);
@


1.6.2.7
log
@2000-05-12
@
text
@d1382 6
@


1.6.2.8
log
@2000-05-30
@
text
@a1221 1
  int old_options = 0;
a1626 1
      old_options = options;
d1757 1
a1757 1
      *stackp++ = old_options;
@


1.6.2.9
log
@matz
@
text
@d3840 1
a3840 1
	if (stackp > stackb && stackp[-2] == d) {
d3948 1
a3948 1
        if (mcnt < 0 && stackp > stackb && stackp[-2] == d) /* avoid infinit loop */
@


1.6.2.10
log
@matz
@
text
@a3065 1
      if (range < 0) return -1;
@


1.5
log
@19990922
@
text
@d2880 1
a2880 1
	    int cc = EXTRACT_MBC(&p[j*8]);
@


1.4
log
@990918-repack
@
text
@d1115 1
a1115 1
  register unsigned c, c1;
d2835 1
a2835 1
	      if (beg < 0x100)
@


1.3
log
@regexp literal (e.g. \202) match, etc.
@
text
@d2189 1
a2189 1
      if (had_num_literal && current_mbctype) {
@


1.2
log
@1.4.0
@
text
@d119 1
a119 1
#define FREE_VAR(var) if (var) free(var); var = NULL
d122 2
a123 2
#define FREE_AND_RETURN_VOID(stackb)   free(stackb);return
#define FREE_AND_RETURN(stackb,val)    free(stackb);return(val)
d455 1
a455 1
 ((current_mbctype != MBCTYPE_UTF8)?(((c)>>8)&0xff):utf8_firstbyte(c))
d492 3
d1184 1
d1345 1
d1449 1
d1457 1
d1568 1
a1568 1
	else if (had_mbchar == 0)
d1570 2
d2100 1
d2108 1
d2132 1
d2189 1
a2189 1
      if (!had_mbchar && c > 0x7f) {
d2192 1
d2606 1
a2606 1
  unsigned char **stackb = TMALLOC(NFAILURES, unsigned char*);
d2818 1
a2818 1
	    fastmap[tmp] = (tmp>0x7f)?2:1;
d2835 3
a2837 1
	      if (ismbchar(beg))
a2865 5
	if (current_mbctype) {
	  for (j = 0x80; j < (1 << BYTEWIDTH); j++)
	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
	      fastmap[j] = 2;
	}
d2869 1
d2879 1
a2879 1
	  for (j = 0,c = 0x80;j < (int)size; j++) {
d2889 10
a2898 1
	    c = WC2MBC1ST(cc) + 1;
d2902 2
a3637 3
	  if (!not && cc != c) {
	      part = not = is_in_list(cc, p);
	  }
d3640 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1985, 1989-90 Free Software Foundation, Inc.
d4 4
a7 4
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.
d9 1
a9 1
   This program is distributed in the hope that it will be useful,
d11 2
a12 2
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d14 4
a17 3
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
d20 3
d24 4
a27 7

/* To test, compile with -Dtest.  This Dtestable feature turns this into
   a self-contained program which reads a pattern, describes how it
   compiles, then reads a string and searches for it.

   On the other hand, if you compile with both -Dtest and -Dcanned you
   can run some tests we've already thought of.  */
d36 25
a60 2
#include "config.h"
#include "defines.h"
d62 2
a63 3
#ifdef __STDC__
#define P(s)    s
#define MALLOC_ARG_T size_t
d65 8
a72 4
#define P(s)    ()
#define MALLOC_ARG_T unsigned
#define volatile
#define const
d75 1
a75 1
/* #define	NO_ALLOCA	/* try it out for now */
d79 5
a83 8
#ifndef atarist
#ifndef alloca
#define alloca __builtin_alloca
#endif
#endif /* atarist */
#else
#if defined(HAVE_ALLOCA_H) && !defined(__GNUC__)
#include <alloca.h>
d85 3
d89 1
a89 1
#endif
d96 6
d103 1
d105 3
d111 2
a112 3
#define DOUBLE_STACK(stackx,stackb,len) \
        (stackx = (unsigned char **) alloca(2 * len			\
                                            * sizeof(unsigned char *)),\
d114 1
a114 1
        (unsigned char **) memcpy(stackx, stackb, len * sizeof (char *)))
d117 1
a117 1
#define RE_ALLOCATE malloc
d120 1
a120 8
#define FREE_VARIABLES()						\
  do {									\
    FREE_VAR(regstart);							\
    FREE_VAR(regend);							\
    FREE_VAR(best_regstart);						\
    FREE_VAR(best_regend);						\
    FREE_VAR(reg_info);							\
  } while (0)
d124 2
a125 2
#define DOUBLE_STACK(stackx,stackb,len) \
        (unsigned char **)xrealloc(stackb, 2 * len * sizeof(unsigned char *))
d132 10
d145 8
a152 7
static void store_jump P((char *, int, char *));
static void insert_jump P((int, char *, char *, char *));
static void store_jump_n P((char *, int, char *, unsigned));
static void insert_jump_n P((int, char *, char *, char *, unsigned));
static void insert_op_2 P((int, char *, char *, int, int ));
static int memcmp_translate P((unsigned char *, unsigned char *,
			       int, unsigned char *));
d157 3
a159 4
   commands in re_match_2.  */
#ifndef Sword 
#define Sword 1
#endif
d164 5
a168 1
static void init_syntax_once P((void));
d172 1
d174 1
d187 17
a203 2
   for (c = 'a'; c <= 'z'; c++)
     re_syntax_table[c] = Sword;
d205 1
a205 2
   for (c = 'A'; c <= 'Z'; c++)
     re_syntax_table[c] = Sword;
d207 16
a222 2
   for (c = '0'; c <= '9'; c++)
     re_syntax_table[c] = Sword;
d224 10
a233 1
   re_syntax_table['_'] = Sword;
d235 11
a245 5
   /* Add specific syntax for ISO Latin-1.  */
   for (c = 0300; c <= 0377; c++)
     re_syntax_table[c] = Sword;
   re_syntax_table[0327] = 0;
   re_syntax_table[0367] = 0;
d247 3
a249 2
   done = 1;
}
d251 10
a260 3
/* Sequents are missing isgraph.  */
#ifndef isgraph
#define isgraph(c) (isprint((c)) && !isspace((c)))
d279 4
d284 1
d303 2
d312 5
d319 2
a320 1
    anychar,	 /* Matches any (more or less) one character.  */
d338 9
d352 2
a366 8
#if defined(CHAR_UNSIGNED) || defined(__CHAR_UNSIGNED__)
#define SIGN_EXTEND_CHAR(c) ((c)>(char)127?(c)-256:(c)) /* for IBM RT */
#endif
#ifndef SIGN_EXTEND_CHAR
#define SIGN_EXTEND_CHAR(x) (x)
#endif


d369 2
a370 2
  { (destination)[0] = (number) & 0377;					\
    (destination)[1] = (number) >> 8; }
d376 2
a377 2
  { STORE_NUMBER(destination, number);					\
    (destination) += 2; }
d383 2
a384 2
  { (destination) = *(source) & 0377;					\
    (destination) += SIGN_EXTEND_CHAR (*(char *)((source) + 1)) << 8; }
d390 2
a391 2
  { EXTRACT_NUMBER(destination, source);				\
    (source) += 2; }
d405 1
a405 5
  long ret;

  ret = re_syntax_options;
  re_syntax_options = syntax;
  return ret;
a407 3
/* Set by re_set_syntax to the current regexp syntax to recognize.  */
long re_syntax_options = DEFAULT_MBCTYPE;

d411 2
d420 1
a420 1
    if (translate) c = (unsigned char)translate[c];			\
d427 1
a427 1
    c = (unsigned char) *p++; 						\
d433 63
d502 1
a502 1
  {								        \
d505 1
a505 1
  }
d509 1
a509 1
  {									\
d512 1
a512 1
  }
d519 1
a519 1
  { char *old_buffer = bufp->buffer;					\
d523 1
a523 1
    bufp->buffer = (char *) xrealloc (bufp->buffer, bufp->allocated);	\
d527 2
a528 2
    if (fixup_jump)							\
      fixup_jump = (fixup_jump - old_buffer) + bufp->buffer;		\
d534 1
a534 1
  }
d544 1
a544 2
  { if (p != pend) 							\
      { 								\
d546 14
a559 11
	while (isdigit(c)) 						\
	  { 								\
	    if (num < 0) 						\
	       num = 0; 						\
            num = num * 10 + c - '0'; 					\
	    if (p == pend) 						\
	       break; 							\
	    PATFETCH(c); 						\
	  } 								\
        } 								\
  }
d561 7
a567 3
/* Subroutines for re_compile_pattern.  */
/* static void store_jump(), insert_jump(), store_jump_n(),
	    insert_jump_n(), insert_op_2(); */
d569 28
a596 9
#define STORE_MBC(p, c) \
  ((p)[0] = (unsigned char)(c >> 8), (p)[1] = (unsigned char)(c))
#define STORE_MBC_AND_INCR(p, c) \
  (*(p)++ = (unsigned char)(c >> 8), *(p)++ = (unsigned char)(c))

#define EXTRACT_MBC(p) \
  ((unsigned short)((unsigned char)(p)[0] << 8 | (unsigned char)(p)[1]))
#define EXTRACT_MBC_AND_INCR(p) \
  ((unsigned short)((p) += 2, (unsigned char)(p)[-2] << 8 | (unsigned char)(p)[-1]))
d613 2
a614 2
	 unsigned short beg;		beginning of interval.
	 unsigned short end;		end of interval.
d620 1
a620 1
    unsigned short c1, c2;
a628 18
  if ((int)c1 < 1 << BYTEWIDTH) {
    upb = c2;
    if (1 << BYTEWIDTH <= (int)upb)
      upb = (1 << BYTEWIDTH) - 1;	/* The last single-byte char */
    if (sbc_size <= (unsigned short)(upb / BYTEWIDTH)) {
      /* Allocate maximum size so it never happens again.  */
      /* NOTE: memcpy() would not work here.  */
      memmove(&b[(1 << BYTEWIDTH) / BYTEWIDTH], &b[sbc_size], 2 + mbc_size*4);
      memset(&b[sbc_size], 0, (1 << BYTEWIDTH) / BYTEWIDTH - sbc_size);
      b[-1] = sbc_size = (1 << BYTEWIDTH) / BYTEWIDTH;
    }
    for (; c1 <= upb; c1++)
	if (!ismbchar(c1))
	    SET_LIST_BIT(c1);
    if ((int)c2 < 1 << BYTEWIDTH)
      return;
    c1 = 0x8000;			/* The first wide char */
  }
d634 1
a634 1
    if ((int)c1 - 1 > (int)EXTRACT_MBC(&b[mid*4 + 2]))
d643 1
a643 1
    if ((int)c2 >= (int)EXTRACT_MBC(&b[mid*4]) - 1)
d650 4
a653 4
    if (c1 > EXTRACT_MBC(&b[beg*4]))
      c1 = EXTRACT_MBC(&b[beg*4]);
    if (c2 < EXTRACT_MBC(&b[(end - 1)*4]))
      c2 = EXTRACT_MBC(&b[(end - 1)*4]);
d657 3
a659 3
    memmove(&b[(beg + 1)*4], &b[end*4], (mbc_size - end)*4);
  STORE_MBC(&b[beg*4 + 0], c1);
  STORE_MBC(&b[beg*4 + 2], c2);
d666 1
a666 1
    unsigned short c;
d669 143
a811 25
    unsigned short size;
    unsigned short i, j;
    int result = 0;

    size = *b++;
    if ((int)c < 1<<BYTEWIDTH) {
	if ((int)c / BYTEWIDTH < (int)size && b[c / BYTEWIDTH] & 1 << c % BYTEWIDTH) {
	    return 1;
	}
    }
    b += size + 2;
    size = EXTRACT_UNSIGNED(&b[-2]);
    if (size == 0) return 0;

    if (b[(size-1)*4] == 0xff) {
	i = c;
	if ((int)c >= 1<<BYTEWIDTH) {
	    i = i>>BYTEWIDTH;
	}
	while (size>0 && b[size*4-2] == 0xff) {
	    size--;
	    if (b[size*4+1] <= i && i <= b[size*4+3]) {
		result = 2;
		break;
	    }
d813 116
d930 41
a970 2
    for (i = 0, j = size; i < j; ) {
	unsigned short k = (unsigned short)(i + j) >> 1;
d972 78
a1049 4
	if (c > EXTRACT_MBC(&b[k*4+2]))
	    i = k + 1;
	else
	    j = k;
d1051 34
a1084 4
    if (i < size && EXTRACT_MBC(&b[i*4]) <= c
	&& ((unsigned char)c != '\n' && (unsigned char)c != '\0'))
	return 1;
    return result;
d1104 2
a1105 2
     char *pattern;
     size_t size;
d1108 7
a1114 6
    register char *b = bufp->buffer;
    register char *p = pattern;
    char *pend = pattern + size;
    register unsigned c, c1;
    char *p0;
    int numlen;
d1116 4
a1119 4
    /* Address of the count-byte of the most recently inserted `exactn'
       command.  This makes it possible to tell whether a new exact-match
       character can be added to that command or requires a new `exactn'
       command.  */
d1121 1
a1121 1
    char *pending_exact = 0;
d1123 3
a1125 3
    /* Address of the place where a forward-jump should go to the end of
       the containing expression.  Each alternative of an `or', except the
       last, ends with a forward-jump of this sort.  */
d1127 1
a1127 1
    char *fixup_jump = 0;
d1129 2
a1130 2
    /* Address of start of the most recently finished expression.
       This tells postfix * where to find the start of its operand.  */
d1132 1
a1132 1
    char *laststart = 0;
d1134 1
a1134 1
    /* In processing a repeat, 1 means zero matches is allowed.  */
d1136 1
a1136 1
    char zero_times_ok;
d1138 1
a1138 1
    /* In processing a repeat, 1 means many matches is allowed.  */
d1140 1
a1140 1
    char many_times_ok;
d1142 1
a1142 1
    /* Address of beginning of regexp, or inside of last \(.  */
d1144 1
a1144 1
    char *begalt = b;
d1146 1
a1146 2
    /* In processing an interval, at least this many matches must be made.  */
    int lower_bound;
d1148 1
a1148 2
    /* In processing an interval, at most this many matches can be made.  */
    int upper_bound;
d1150 3
a1152 3
    /* Place in pattern (i.e., the {) to which to go back if the interval
       is invalid.  */
    char *beg_interval = 0;
d1154 2
a1155 6
    /* Stack of information saved by \( and restored by \).
       Four stack elements are pushed by each \(:
       First, the value of b.
       Second, the value of fixup_jump.
       Third, the value of regnum.
       Fourth, the value of begalt.  */
d1157 2
a1158 4
    int stackb[40];
    int *stackp = stackb;
    int *stacke = stackb + 40;
    int *stackt;
d1160 7
a1166 3
    /* Counts \('s as they are encountered.  Remembered for the matching \),
       where it becomes the register number to put in the stop_memory
       command.  */
d1168 4
a1171 2
    int regnum = 1;
    int range = 0;
d1173 3
a1175 2
    /* How to translate the characters in the pattern.  */
    char *translate = bufp->translate;
d1177 1
a1177 1
    bufp->fastmap_accurate = 0;
d1179 3
a1181 2
    /* Initialize the syntax table.  */
    init_syntax_once();
d1183 9
a1191 12
    if (bufp->allocated == 0)
	{
	    bufp->allocated = INIT_BUF_SIZE;
	    if (bufp->buffer)
		/* EXTEND_BUFFER loses when bufp->allocated is 0.  */
		bufp->buffer = (char *) xrealloc (bufp->buffer, INIT_BUF_SIZE);
	    else
		/* Caller did not allocate a buffer.  Do it for them.  */
	bufp->buffer = (char *) xmalloc(INIT_BUF_SIZE);
      if (!bufp->buffer) goto memory_exhausted;
      begalt = b = bufp->buffer;
    }
d1193 11
a1203 3
  while (p != pend)
    {
      PATFETCH(c);
d1205 2
a1206 29
      switch (c)
	{
	case '$':
	  {
	    char *p1 = p;
	    /* When testing what follows the $,
	       look past the \-constructs that don't consume anything.  */
	    if (! (re_syntax_options & RE_CONTEXT_INDEP_OPS))
	      while (p1 != pend)
		{
		  if (*p1 == '\\' && p1 + 1 != pend
		      && (p1[1] == 'b' || p1[1] == 'B'))
		    p1 += 2;
		  else
		    break;
		}
            if (re_syntax_options & RE_TIGHT_VBAR)
	      {
		if (! (re_syntax_options & RE_CONTEXT_INDEP_OPS) && p1 != pend)
		  goto normal_char;
		/* Make operand of last vbar end before this `$'.  */
		if (fixup_jump)
		  store_jump(fixup_jump, jump, b);
		fixup_jump = 0;
		BUFPUSH(endline);
		break;
	      }
	    /* $ means succeed if at end of line, but only in special contexts.
	      If validly in the middle of a pattern, it is a normal character. */
d1208 14
a1221 36
#if 0
	    /* not needed for perl4 compatible */
            if ((re_syntax_options & RE_CONTEXTUAL_INVALID_OPS) && p1 != pend)
	      goto invalid_pattern;
#endif
	    if (p1 == pend || *p1 == '\n'
		|| (re_syntax_options & RE_CONTEXT_INDEP_OPS)
		|| (re_syntax_options & RE_NO_BK_PARENS
		    ? *p1 == ')'
		    : *p1 == '\\' && p1[1] == ')')
		|| (re_syntax_options & RE_NO_BK_VBAR
		    ? *p1 == '|'
		    : *p1 == '\\' && p1[1] == '|'))
	      {
		BUFPUSH(endline);
		break;
	      }
	    goto normal_char;
          }
	case '^':
	  /* ^ means succeed if at beg of line, but only if no preceding 
             pattern.  */

          if ((re_syntax_options & RE_CONTEXTUAL_INVALID_OPS) && laststart)
            goto invalid_pattern;
          if (laststart && p - 2 >= pattern && p[-2] != '\n'
	       && !(re_syntax_options & RE_CONTEXT_INDEP_OPS))
	    goto normal_char;
	  if (re_syntax_options & RE_TIGHT_VBAR)
	    {
	      if (p != pattern + 1
		  && ! (re_syntax_options & RE_CONTEXT_INDEP_OPS))
		goto normal_char;
	      BUFPUSH(begline);
	      begalt = b;
	    }
d1223 11
a1233 4
	    {
	      BUFPUSH(begline);
	    }
	  break;
d1235 15
a1249 1
	case '+':
d1251 2
a1252 4
	  if ((re_syntax_options & RE_BK_PLUS_QM)
	      || (re_syntax_options & RE_LIMITED_OPS))
	    goto normal_char;
	handle_plus:
d1254 13
a1266 43
	  /* If there is no previous pattern, char not special. */
	  if (!laststart)
            {
              if (re_syntax_options & RE_CONTEXTUAL_INVALID_OPS)
                goto invalid_pattern;
              else if (! (re_syntax_options & RE_CONTEXT_INDEP_OPS))
		goto normal_char;
            }
	  /* If there is a sequence of repetition chars,
	     collapse it down to just one.  */
	  zero_times_ok = 0;
	  many_times_ok = 0;
	  while (1)
	    {
	      zero_times_ok |= c != '+';
	      many_times_ok |= c != '?';
	      if (p == pend)
		break;
	      PATFETCH(c);
	      if (c == '*')
		;
	      else if (!(re_syntax_options & RE_BK_PLUS_QM)
		       && (c == '+' || c == '?'))
		;
	      else if ((re_syntax_options & RE_BK_PLUS_QM)
		       && c == '\\')
		{
		  /* int c1; */
		  PATFETCH(c1);
		  if (!(c1 == '+' || c1 == '?'))
		    {
		      PATUNFETCH;
		      PATUNFETCH;
		      break;
		    }
		  c = c1;
		}
	      else
		{
		  PATUNFETCH;
		  break;
		}
	    }
d1268 21
a1288 4
	  /* Star, etc. applied to an empty pattern is equivalent
	     to an empty pattern.  */
	  if (!laststart)  
	    break;
d1290 10
a1299 17
	  /* Now we know whether or not zero matches is allowed
	     and also whether or not two or more matches is allowed.  */
	  if (many_times_ok)
	    {
	      /* If more than one repetition is allowed, put in at the
                 end a backward relative jump from b to before the next
                 jump we're going to put in below (which jumps from
                 laststart to after this jump).  */
              GET_BUFFER_SPACE(3);
	      store_jump(b, maybe_finalize_jump, laststart - 3);
	      b += 3;  	/* Because store_jump put stuff here.  */
	    }
          /* On failure, jump from laststart to b + 3, which will be the
             end of the buffer after this jump is inserted.  */
          GET_BUFFER_SPACE(3);
	  insert_jump(on_failure_jump, laststart, b + 3, b);
	  pending_exact = 0;
d1301 34
a1334 11
	  if (!zero_times_ok)
	    {
	      /* At least one repetition is required, so insert a
                 dummy-failure before the initial on-failure-jump
                 instruction of the loop. This effects a skip over that
                 instruction the first time we hit that loop.  */
              GET_BUFFER_SPACE(6);
              insert_jump(dummy_failure_jump, laststart, laststart + 6, b);
	      b += 3;
	    }
	  break;
d1336 12
a1347 4
	case '.':
	  laststart = b;
	  BUFPUSH(anychar);
	  break;
d1349 11
a1359 5
        case '[':
          if (p == pend)
            goto invalid_pattern;
	  while (b - bufp->buffer
		 > bufp->allocated - 9 - (1 << BYTEWIDTH) / BYTEWIDTH)
d1361 3
d1365 19
a1383 9
	  laststart = b;
	  if (*p == '^')
	    {
              BUFPUSH(charset_not); 
              p++;
            }
	  else
	    BUFPUSH(charset);
	  p0 = p;
d1385 15
a1399 23
	  BUFPUSH((1 << BYTEWIDTH) / BYTEWIDTH);
	  /* Clear the whole map */
	  memset(b, 0, (1 << BYTEWIDTH) / BYTEWIDTH + 2);

	  if ((re_syntax_options & RE_HAT_NOT_NEWLINE) && b[-2] == charset_not)
            SET_LIST_BIT('\n');


	  /* Read in characters and ranges, setting map bits.  */
	  while (1)
	    {
	      int size;
	      unsigned last = (unsigned)-1;

	      if ((size = EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH]))) {
		/* Ensure the space is enough to hold another interval
		   of multi-byte chars in charset(_not)?.  */
		size = (1 << BYTEWIDTH) / BYTEWIDTH + 2 + size*4 + 4;
		while (b + size + 1 > bufp->buffer + bufp->allocated)
		  EXTEND_BUFFER;
	      }
	    range_retry:
	      PATFETCH(c);
d1401 8
a1408 17
              if (c == ']') {
                  if (p == p0 + 1) {
		      /* If this is an empty bracket expression.  */
                      if ((re_syntax_options & RE_NO_EMPTY_BRACKETS) 
                          && p == pend)
			  goto invalid_pattern;
		  }
                  else 
		    /* Stop if this isn't merely a ] inside a bracket
                       expression, but rather the end of a bracket
                       expression.  */
		      break;
	      }
	      if (ismbchar(c)) {
		PATFETCH(c1);
		c = c << BYTEWIDTH | c1;
	      }
d1410 6
a1415 78
	      /* \ escapes characters when inside [...].  */
	      if (c == '\\') {
	          PATFETCH(c);
		  switch (c) {
		    case 'w':
		      for (c = 0; c < (1 << BYTEWIDTH); c++)
		          if (SYNTAX(c) == Sword)
			      SET_LIST_BIT(c);
		      last = -1;
		      continue;

		    case 'W':
		      for (c = 0; c < (1 << BYTEWIDTH); c++)
		          if (SYNTAX(c) != Sword)
			      SET_LIST_BIT(c);
		      if (re_syntax_options & RE_MBCTYPE_MASK) {
			  set_list_bits(0x8000, 0xffff, (unsigned char*)b);
		      }
		      last = -1;
		      continue;

		    case 's':
		      for (c = 0; c < 256; c++)
			  if (isspace(c))
			      SET_LIST_BIT(c);
		      last = -1;
		      continue;

		    case 'S':
		      for (c = 0; c < 256; c++)
			  if (!isspace(c))
			      SET_LIST_BIT(c);
		      if (re_syntax_options & RE_MBCTYPE_MASK) {
			  set_list_bits(0x8000, 0xffff, (unsigned char*)b);
		      }
		      last = -1;
		      continue;

		    case 'd':
		      for (c = '0'; c <= '9'; c++)
			  SET_LIST_BIT(c);
		      last = -1;
		      continue;

		    case 'D':
		      for (c = 0; c < 256; c++)
			  if (!isdigit(c))
			      SET_LIST_BIT(c);
		      if (re_syntax_options & RE_MBCTYPE_MASK) {
			  set_list_bits(0x8000, 0xffff, (unsigned char*)b);
		      }
		      last = -1;
		      continue;

		    case 'x':
		      c = scan_hex(p, 2, &numlen);
		      if ((re_syntax_options & RE_MBCTYPE_MASK) && c > 0x7f)
			  c = 0xff00 | c;
		      p += numlen;
		      break;

		    case '0': case '1': case '2': case '3': case '4':
		    case '5': case '6': case '7': case '8': case '9':
		      PATUNFETCH;
		      c = scan_oct(p, 3, &numlen);
		      if ((re_syntax_options & RE_MBCTYPE_MASK) && ismbchar(c))
			  c = 0xff00 | c;
		      p += numlen;
		      break;

		    default:
		      if (ismbchar(c)) {
			  PATFETCH(c1);
			  c = c << 8 | c1;
		      }
		      break;
		  }
	      }
d1417 3
a1419 25
              /* Get a range.  */
	      if (range) {
		  if (last > c)
                    goto invalid_pattern;

		  if ((re_syntax_options & RE_NO_HYPHEN_RANGE_END) 
                      && c == '-' && *p != ']')
                    goto invalid_pattern;

		  range = 0;
		  if (last < 1 << BYTEWIDTH && c < 1 << BYTEWIDTH) {
		      for (;last<=c;last++)
			  SET_LIST_BIT(last);
		  }
		  else {
		      set_list_bits(last, c, (unsigned char*)b);
		  }
	      }
              else if (p[0] == '-' && p[1] != ']') {
		  last = c;
		  PATFETCH(c1);
		  range = 1;
		  goto range_retry;
	      }
              else if (c < 1 << BYTEWIDTH)
d1421 10
a1430 3
	      else
		set_list_bits(c, c, (unsigned char*)b);
	    }
d1432 8
a1439 9
          /* Discard any character set/class bitmap bytes that are all
             0 at the end of the map. Decrement the map-length byte too.  */
          while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
            b[-1]--; 
	  if (b[-1] != (1 << BYTEWIDTH) / BYTEWIDTH)
	    memmove(&b[b[-1]], &b[(1 << BYTEWIDTH) / BYTEWIDTH],
		    2 + EXTRACT_UNSIGNED (&b[(1 << BYTEWIDTH) / BYTEWIDTH])*4);
	  b += b[-1] + 2 + EXTRACT_UNSIGNED (&b[b[-1]])*4;
          break;
d1441 4
a1444 5
	case '(':
	  if (! (re_syntax_options & RE_NO_BK_PARENS))
	    goto normal_char;
	  else
	    goto handle_open;
d1446 6
a1451 5
	case ')':
	  if (! (re_syntax_options & RE_NO_BK_PARENS))
	    goto normal_char;
	  else
	    goto handle_close;
d1453 9
a1461 5
        case '\n':
	  if (! (re_syntax_options & RE_NEWLINE_OR))
	    goto normal_char;
	  else
	    goto handle_bar;
d1463 3
a1465 5
	case '|':
#if 0
	  /* not needed for perl4 compatible */
	  if ((re_syntax_options & RE_CONTEXTUAL_INVALID_OPS)
              && (! laststart  ||  p == pend))
a1466 6
	  else 
          if (! (re_syntax_options & RE_NO_BK_VBAR))
	    goto normal_char;
	  else
#endif
	  goto handle_bar;
d1468 22
a1489 36
	case '{':
           if (! ((re_syntax_options & RE_NO_BK_CURLY_BRACES)
                  && (re_syntax_options & RE_INTERVALS)))
             goto normal_char;
           else
             goto handle_interval;

        case '\\':
	  if (p == pend) goto invalid_pattern;
          /* Do not translate the character after the \, so that we can
             distinguish, e.g., \B from \b, even if we normally would
             translate, e.g., B to b.  */
	  PATFETCH_RAW(c);
	  switch (c)
	    {
	    case '(':
	      if (re_syntax_options & RE_NO_BK_PARENS)
		goto normal_backsl;
	    handle_open:
	      if (stackp == stacke) goto nesting_too_deep;

              /* Laststart should point to the start_memory that we are about
                 to push (unless the pattern has RE_NREGS or more ('s).  */
	      /* obsolete: now RE_NREGS is just a default register size. */
              *stackp++ = b - bufp->buffer;    
	      BUFPUSH(start_memory);
	      BUFPUSH(regnum);
	      *stackp++ = fixup_jump ? fixup_jump - bufp->buffer + 1 : 0;
	      *stackp++ = regnum++;
	      *stackp++ = begalt - bufp->buffer;
	      fixup_jump = 0;
	      laststart = 0;
	      begalt = b;
	      /* too many ()'s to fit in a byte.  */
	      if (regnum >= (1<<BYTEWIDTH)) goto too_big;
	      break;
d1491 2
a1492 14
	    case ')':
	      if (re_syntax_options & RE_NO_BK_PARENS)
		goto normal_backsl;
	    handle_close:
	      if (stackp == stackb) goto unmatched_close;
	      begalt = *--stackp + bufp->buffer;
	      if (fixup_jump)
		store_jump(fixup_jump, jump, b);
	      BUFPUSH(stop_memory);
	      BUFPUSH(stackp[-1]);
	      stackp -= 2;
              fixup_jump = *stackp ? *stackp + bufp->buffer - 1 : 0;
              laststart = *--stackp + bufp->buffer;
	      break;
d1494 3
a1496 27
	    case '|':
              if ((re_syntax_options & RE_LIMITED_OPS)
	          || (re_syntax_options & RE_NO_BK_VBAR))
		goto normal_backsl;
	    handle_bar:
              if (re_syntax_options & RE_LIMITED_OPS)
                goto normal_char;
	      /* Insert before the previous alternative a jump which
                 jumps to this alternative if the former fails.  */
              GET_BUFFER_SPACE(6);
              insert_jump(on_failure_jump, begalt, b + 6, b);
	      pending_exact = 0;
	      b += 3;
	      /* The alternative before the previous alternative has a
                 jump after it which gets executed if it gets matched.
                 Adjust that jump so it will jump to the previous
                 alternative's analogous jump (put in below, which in
                 turn will jump to the next (if any) alternative's such
                 jump, etc.).  The last such jump jumps to the correct
                 final destination.  */
              if (fixup_jump)
		store_jump(fixup_jump, jump, b);

	      /* Leave space for a jump after previous alternative---to be 
                 filled in later.  */
              fixup_jump = b;
              b += 3;
d1498 4
a1501 2
              laststart = 0;
	      begalt = b;
d1503 3
d1507 17
a1523 41
            case '{': 
              if (! (re_syntax_options & RE_INTERVALS)
		  /* Let \{ be a literal.  */
                  || ((re_syntax_options & RE_INTERVALS)
                      && (re_syntax_options & RE_NO_BK_CURLY_BRACES))
		  /* If it's the string "\{".  */
		  || (p - 2 == pattern  &&  p == pend))
                goto normal_backsl;
            handle_interval:
	      beg_interval = p - 1;		/* The {.  */
              /* If there is no previous pattern, this isn't an interval.  */
	      if (!laststart)
	        {
                  if (re_syntax_options & RE_CONTEXTUAL_INVALID_OPS)
		    goto invalid_pattern;
                  else
                    goto normal_backsl;
                }
              /* It also isn't an interval if not preceded by an re
                 matching a single character or subexpression, or if
                 the current type of intervals can't handle back
                 references and the previous thing is a back reference.  */
              if (! (*laststart == anychar
		     || *laststart == charset
		     || *laststart == charset_not
		     || *laststart == wordchar
		     || *laststart == notwordchar
		     || *laststart == start_memory
		     || (*laststart == exactn
			 && (laststart[1] == 1
			     || laststart[1] == 2 && ismbchar(laststart[2])))
		     || (! (re_syntax_options & RE_NO_BK_REFS)
                         && *laststart == duplicate)))
                {
                  if (re_syntax_options & RE_NO_BK_CURLY_BRACES)
                    goto normal_char;

		  /* Posix extended syntax is handled in previous
                     statement; this is for Posix basic syntax.  */
                  if (re_syntax_options & RE_INTERVALS)
                    goto invalid_pattern;
d1525 2
a1526 29
                  goto normal_backsl;
		}
              lower_bound = -1;			/* So can see if are set.  */
	      upper_bound = -1;
              GET_UNSIGNED_NUMBER(lower_bound);
	      if (c == ',')
		{
		  GET_UNSIGNED_NUMBER(upper_bound);
		  if (upper_bound < 0)
		    upper_bound = RE_DUP_MAX;
		}
	      if (upper_bound < 0)
		upper_bound = lower_bound;
              if (! (re_syntax_options & RE_NO_BK_CURLY_BRACES)) 
                {
                  if (c != '\\')
                    goto invalid_pattern;
                  PATFETCH(c);
                }
	      if (c != '}' || lower_bound < 0 || upper_bound > RE_DUP_MAX
		  || lower_bound > upper_bound 
                  || ((re_syntax_options & RE_NO_BK_CURLY_BRACES) 
		      && p != pend  && *p == '{')) 
	        {
		  if (re_syntax_options & RE_NO_BK_CURLY_BRACES)
                    goto unfetch_interval;
                  else
                    goto invalid_pattern;
		}
d1528 2
a1529 95
	      /* If upper_bound is zero, don't want to succeed at all; 
 		 jump from laststart to b + 3, which will be the end of
                 the buffer after this jump is inserted.  */

               if (upper_bound == 0)
                 {
                   GET_BUFFER_SPACE(3);
                   insert_jump(jump, laststart, b + 3, b);
                   b += 3;
                 }

               /* Otherwise, after lower_bound number of succeeds, jump
                  to after the jump_n which will be inserted at the end
                  of the buffer, and insert that jump_n.  */
               else 
		 { /* Set to 5 if only one repetition is allowed and
	              hence no jump_n is inserted at the current end of
                      the buffer; then only space for the succeed_n is
                      needed.  Otherwise, need space for both the
                      succeed_n and the jump_n.  */

                   unsigned slots_needed = upper_bound == 1 ? 5 : 10;

                   GET_BUFFER_SPACE(slots_needed);
                   /* Initialize the succeed_n to n, even though it will
                      be set by its attendant set_number_at, because
                      re_compile_fastmap will need to know it.  Jump to
                      what the end of buffer will be after inserting
                      this succeed_n and possibly appending a jump_n.  */
                   insert_jump_n(succeed_n, laststart, b + slots_needed, 
		                  b, lower_bound);
                   b += 5; 	/* Just increment for the succeed_n here.  */

		   /* When hit this when matching, set the succeed_n's n.  */
                   GET_BUFFER_SPACE(5);
		   insert_op_2(set_number_at, laststart, b, 5, lower_bound);
                   b += 5;

		  /* More than one repetition is allowed, so put in at
		     the end of the buffer a backward jump from b to the
                     succeed_n we put in above.  By the time we've gotten
                     to this jump when matching, we'll have matched once
                     already, so jump back only upper_bound - 1 times.  */

                   if (upper_bound > 1)
                     {
		       GET_BUFFER_SPACE(15);
                       store_jump_n(b, jump_n, laststart+5, upper_bound - 1);
                       b += 5;
                       /* When hit this when matching, reset the
                          preceding jump_n's n to upper_bound - 1.  */
		       insert_op_2(set_number_at, laststart, b, b - laststart, upper_bound - 1);
		       b += 5;

                       BUFPUSH(set_number_at);
                       STORE_NUMBER_AND_INCR(b, -5);
                       STORE_NUMBER_AND_INCR(b, upper_bound - 1);
                     }
                 }
              pending_exact = 0;
	      beg_interval = 0;
              break;


            unfetch_interval:
	      /* If an invalid interval, match the characters as literals.  */
	       if (beg_interval)
                 p = beg_interval;
  	       else
                 {
                   fprintf(stderr, 
		      "regex: no interval beginning to which to backtrack.\n");
		   exit (1);
                 }

               beg_interval = 0;
               PATFETCH(c);		/* normal_char expects char in `c'.  */
	       goto normal_char;
	       break;

	    case 's':
	    case 'S':
	    case 'd':
	    case 'D':
	      while (b - bufp->buffer
		     > bufp->allocated - 9 - (1 << BYTEWIDTH) / BYTEWIDTH)
		  EXTEND_BUFFER;

	      laststart = b;
	      if (c == 's' || c == 'd') {
		  BUFPUSH(charset);
	      }
	      else {
		  BUFPUSH(charset_not);
	      }
d1531 2
a1532 11
	      BUFPUSH((1 << BYTEWIDTH) / BYTEWIDTH);
	      memset(b, 0, (1 << BYTEWIDTH) / BYTEWIDTH + 2);
	      if (c == 's' || c == 'S') {
		  SET_LIST_BIT(' ');
		  SET_LIST_BIT('\t');
		  SET_LIST_BIT('\n');
		  SET_LIST_BIT('\r');
		  SET_LIST_BIT('\f');
	      }
	      else {
		  char cc;
d1534 33
a1566 4
		  for (cc = '0'; cc <= '9'; cc++) {
		      SET_LIST_BIT(cc);
		  }
	      }
d1568 9
a1576 7
	      while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
		  b[-1]--; 
	      if (b[-1] != (1 << BYTEWIDTH) / BYTEWIDTH)
		  memmove(&b[b[-1]], &b[(1 << BYTEWIDTH) / BYTEWIDTH],
		    2 + EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH])*4);
	      b += b[-1] + 2 + EXTRACT_UNSIGNED(&b[b[-1]])*4;
	      break;
d1578 11
a1588 3
	    case 'w':
	      laststart = b;
	      BUFPUSH(wordchar);
d1591 2
a1592 3
	    case 'W':
	      laststart = b;
	      BUFPUSH(notwordchar);
d1595 5
a1599 2
	    case 'b':
	      BUFPUSH(wordbound);
d1601 11
a1611 3

	    case 'B':
	      BUFPUSH(notwordbound);
d1613 10
a1622 43

	      /* hex */
	    case 'x':
	      c1 = 0;
	      c = scan_hex(p, 2, &numlen);
	      p += numlen;
	      if ((re_syntax_options & RE_MBCTYPE_MASK) && c > 0x7f)
		  c1 = 0xff;
	      goto numeric_char;

	      /* octal */
	    case '0':
	      c1 = 0;
	      c = scan_oct(p, 3, &numlen);
	      p += numlen;
	      if ((re_syntax_options & RE_MBCTYPE_MASK) && c > 0x7f)
		  c1 = 0xff;
	      goto numeric_char;

	      /* back-ref or octal */
	    case '1': case '2': case '3':
	    case '4': case '5': case '6':
	    case '7': case '8': case '9':
	      {
		  char *p_save;

		  PATUNFETCH;
		  p_save = p;

		  c1 = 0;
		  GET_UNSIGNED_NUMBER(c1);
		  if (p < pend) PATUNFETCH;

		  if (c1 >= regnum) {
		      /* need to get octal */
		      p = p_save;
		      c = scan_oct(p_save, 3, &numlen);
		      p = p_save + numlen;
		      c1 = 0;
		      if ((re_syntax_options & RE_MBCTYPE_MASK) && c > 0x7f)
			  c1 = 0xff;
		      goto numeric_char;
		  }
d1624 1
d1626 5
a1630 7
              /* Can't back reference to a subexpression if inside of it.  */
              for (stackt = stackp - 2;  stackt > stackb;  stackt -= 4)
 		if (*stackt == c1)
		  goto normal_char;
	      laststart = b;
	      BUFPUSH(duplicate);
	      BUFPUSH(c1);
d1632 5
d1638 7
a1644 7
	    case '+':
	    case '?':
	      if (re_syntax_options & RE_BK_PLUS_QM)
		goto handle_plus;
	      else
                goto normal_backsl;
              break;
d1646 3
a1648 4
            default:
	    normal_backsl:
	      goto normal_char;
	    }
d1652 253
a1904 5
	normal_char:		/* Expects the character in `c'.  */
	  c1 = 0;
	  if (ismbchar(c)) {
	    c1 = c;
	    PATFETCH(c);
d1906 12
a1917 2
	  else if (c > 0x7f) {
	      c1 = 0xff;
d1919 203
a2121 20
	numeric_char:
	  if (!pending_exact || pending_exact + *pending_exact + 1 != b
	      || *pending_exact >= (c1 ? 0176 : 0177)
	      || *p == '*' || *p == '^'
	      || ((re_syntax_options & RE_BK_PLUS_QM)
		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
		  : (*p == '+' || *p == '?'))
	      || ((re_syntax_options & RE_INTERVALS) 
                  && ((re_syntax_options & RE_NO_BK_CURLY_BRACES)
		      ? *p == '{'
                      : (p[0] == '\\' && p[1] == '{'))))
	    {
	      laststart = b;
	      BUFPUSH(exactn);
	      pending_exact = b;
	      BUFPUSH(0);
	    }
	  if (c1) {
	    BUFPUSH(c1);
	    (*pending_exact)++;
d2123 64
d2190 1
d2192 1
d2194 2
a2195 2
  if (fixup_jump)
    store_jump(fixup_jump, jump, b);
d2197 41
a2237 1
  if (stackp != stackb) goto unmatched_open;
d2241 30
a2270 1
  return 0;
d2272 8
a2279 2
 invalid_char:
  return "Invalid character in regular expression";
d2282 1
a2282 7
  return "Invalid regular expression";

 unmatched_open:
  return "Unmatched (";

 unmatched_close:
  return "Unmatched )";
d2285 1
a2285 4
  return "Premature end of regular expression";

 nesting_too_deep:
  return "Nesting too deep";
d2288 1
a2288 1
  return "Regular expression too big";
d2291 4
a2294 1
  return "Memory exhausted";
d2297 17
d2392 21
d2436 118
d2555 17
a2580 1

d2585 1
a2585 1
  unsigned char *pattern = (unsigned char *) bufp->buffer;
a2590 1
  unsigned char *translate = (unsigned char *)bufp->translate;
d2593 4
a2596 4
  unsigned char **stackb;
  unsigned char **stackp;
  stackb = RE_TALLOC(NFAILURES, unsigned char*);
  stackp = stackb;
d2602 6
a2607 8
  while (p)
    {
      is_a_succeed_n = 0;
      if (p == pend)
	{
	  bufp->can_be_null = 1;
	  break;
	}
d2609 1
a2609 1
      switch ((int) ((enum regexpcode)*p++))
d2611 1
a2611 1
      switch ((enum regexpcode)*p++)
d2613 5
a2617 10
	{
	case exactn:
	  if (p[1] == 0xff) {
	      if (translate)
		fastmap[translate[p[2]]] = 2;
	      else
		fastmap[p[2]] = 2;
	  }
	  else if (translate)
	    fastmap[translate[p[1]]] = 1;
d2619 7
a2625 2
	    fastmap[p[1]] = 1;
	  break;
d2627 33
a2659 4
        case begline:
	case wordbound:
	case notwordbound:
          continue;
d2661 46
a2706 5
	case endline:
	  if (translate)
	    fastmap[translate['\n']] = 1;
	  else
	    fastmap['\n'] = 1;
d2708 6
a2713 3
	  if (bufp->can_be_null == 0)
	    bufp->can_be_null = 2;
	  break;
d2715 35
a2749 8
	case jump_n:
        case finalize_jump:
	case maybe_finalize_jump:
	case jump:
	case dummy_failure_jump:
          EXTRACT_NUMBER_AND_INCR(j, p);
	  p += j;	
	  if (j > 0)
d2751 2
a2752 6
          /* Jump backward reached implies we just went through
	     the body of a loop and matched nothing.
	     Opcode jumped to should be an on_failure_jump.
	     Just treat it like an ordinary jump.
	     For a * loop, it has pushed its failure point already;
	     If so, discard that as redundant.  */
d2754 9
a2762 46
          if ((enum regexpcode) *p != on_failure_jump
	      && (enum regexpcode) *p != succeed_n)
	    continue;
          p++;
          EXTRACT_NUMBER_AND_INCR(j, p);
          p += j;	
          if (stackp != stackb && *stackp == p)
            stackp--;
          continue;

        case on_failure_jump:
	handle_on_failure_jump:
          EXTRACT_NUMBER_AND_INCR(j, p);
          *++stackp = p + j;
	  if (is_a_succeed_n)
            EXTRACT_NUMBER_AND_INCR(k, p);	/* Skip the n.  */
	  continue;

	case succeed_n:
	  is_a_succeed_n = 1;
          /* Get to the number of times to succeed.  */
          p += 2;		
	  /* Increment p past the n for when k != 0.  */
          EXTRACT_NUMBER_AND_INCR(k, p);
          if (k == 0)
	    {
              p -= 4;
              goto handle_on_failure_jump;
            }
          continue;

	case set_number_at:
          p += 4;
          continue;

        case start_memory:
	case stop_memory:
	  p++;
	  continue;

	case duplicate:
	  bufp->can_be_null = 1;
	  fastmap['\n'] = 1;
	case anychar:
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	    if (j != '\n')
d2764 1
a2764 6
	  if (bufp->can_be_null)
	    {
	      FREE_AND_RETURN_VOID(stackb);
	    }
	  /* Don't return; check the alternative paths
	     so we can set can_be_null if appropriate.  */
d2766 5
a2770 4

	case wordchar:
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	    if (SYNTAX(j) == Sword)
d2772 1
d2774 2
d2777 8
a2784 3
	case notwordchar:
	  for (j = 0; j < 0x80; j++)
	    if (SYNTAX(j) != Sword)
d2786 7
a2792 1
	  for (j = 0x80; j < (1 << BYTEWIDTH); j++)
d2794 1
d2796 2
d2799 26
a2824 36
	case charset:
	  /* NOTE: Charset for single-byte chars never contain
		   multi-byte char.  See set_list_bits().  */
	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
	      {
		if (translate)
		  fastmap[translate[j]] = 1;
		else
		  fastmap[j] = 1;
	      }
	  {
	    unsigned short size;
	    unsigned c, end;

	    p += p[-1] + 2;
	    size = EXTRACT_UNSIGNED(&p[-2]);
	    for (j = 0; j < (int)size; j++) {
	      if ((unsigned char)p[j*4] == 0xff) {
		for (c = (unsigned char)p[j*4+1],
		    end = (unsigned char)p[j*4+3];
		     c <= end; c++) {
		  fastmap[c] = 2;
		}
	      }
	      else {
		/* set bits for 1st bytes of multi-byte chars.  */
		for (c = (unsigned char)p[j*4],
		     end = (unsigned char)p[j*4 + 2];
		     c <= end; c++) {
		  /* NOTE: Charset for multi-byte chars might contain
		     single-byte chars.  We must reject them. */
		  if (ismbchar(c))
		    fastmap[c] = 1;
		}
	      }
d2827 18
a2844 1
	  break;
d2846 2
a2847 13
	case charset_not:
	  /* S: set of all single-byte chars.
	     M: set of all first bytes that can start multi-byte chars.
	     s: any set of single-byte chars.
	     m: any set of first bytes that can start multi-byte chars.

	     We assume S+M = U.
	       ___      _   _
	       s+m = (S*s+M*m).  */
	  /* Chars beyond end of map must be allowed */
	  /* NOTE: Charset_not for single-byte chars might contain
		   multi-byte chars.  See set_list_bits(). */
	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
d2850 9
d2860 15
a2874 29
	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
	      {
		if (!ismbchar(j))
		  fastmap[j] = 1;
	      }
	  {
	    unsigned short size;
	    unsigned char c, beg;

	    p += p[-1] + 2;
	    size = EXTRACT_UNSIGNED(&p[-2]);
	    if (size == 0) {
		for (j = 0x80; j < (1 << BYTEWIDTH); j++)
		    if (ismbchar(j))
			fastmap[j] = 1;
	    }
	    for (j = 0,c = 0x80;j < (int)size; j++) {
	      if ((unsigned char)p[j*4] == 0xff) {
	        for (beg = (unsigned char)p[j*4+1]; c < beg; c++)
		  fastmap[c] = 2;
	        c = (unsigned char)p[j*4+3] + 1;
	      }
	      else {
	        for (beg = (unsigned char)p[j*4 + 0]; c < beg; c++)
		  if (ismbchar(c))
		    fastmap[c] = 1;
	        c = (unsigned char)p[j*4 + 2] + 1;
	      }
d2876 3
a2879 1
	  break;
d2881 3
a2883 2
	case unused:	/* pacify gcc -Wall */
	  break;
d2885 1
d2887 1
a2887 7
      /* Get here means we have successfully found the possible starting
         characters of one path of the pattern.  We need not follow this
         path any farther.  Instead, look at the next alternative
         remembered in the stack.  */
      if (stackp != stackb)
	p = *stackp--;
      else
d2889 12
a2900 2
    }
   FREE_AND_RETURN_VOID(stackb);
a2901 2


d2919 1
a2919 1
     char *string;
a2923 1
  register unsigned char *translate = (unsigned char *) bufp->translate;
d2927 37
a2963 2
  if (startpos < 0  ||  startpos > size)
    return -1;
d2965 26
a2990 3
  /* Update the fastmap now if not correct already.  */
  if (fastmap && !bufp->fastmap_accurate) {
      re_compile_fastmap (bufp);
d2993 14
a3006 2
  if (bufp->used > 0 && (enum regexpcode)bufp->buffer[0] == begline)
      anchor = 1;
d3008 4
a3011 7
  for (;;)
    {
      /* If a fastmap is supplied, skip quickly over characters that
         cannot possibly be the start of a match.  Note, however, that
         if the pattern can possibly match the null string, we must
         test it at each starting point so that we take the first null
         string we get.  */
d3013 8
a3020 37
      if (fastmap && startpos < size
	  && bufp->can_be_null != 1 && !(anchor && startpos == 0))
	{
	  if (range > 0)	/* Searching forwards.  */
	    {
	      register int lim = 0;
	      register unsigned char *p, c;
	      int irange = range;

	      lim = range - (size - startpos);
	      p = (unsigned char *)&(string[startpos]);

	      while (range > lim) {
		c = *p++;
		if (ismbchar(c)) {
		  if (fastmap[c])
		    break;
		  c = *p++;
		  range--;
		  if (fastmap[c] == 2)
		    break;
		}
		else 
		  if (fastmap[translate ? translate[c] : c])
		    break;
		range--;
	      }
	      startpos += irange - range;
	    }
	  else			/* Searching backwards.  */
	    {
	      register unsigned char c;

	      c = string[startpos];
              c &= 0xff;
	      if (translate ? !fastmap[translate[c]] : !fastmap[c])
		goto advance;
d3022 6
d3029 5
d3035 6
a3040 8
      if (anchor && startpos > 0 && startpos < size
	  && string[startpos-1] != '\n') goto advance;

      if (fastmap && startpos == size && range >= 0
	  && (bufp->can_be_null == 0 ||
	      (bufp->can_be_null == 2 && size > 0
	       && string[startpos-1] == '\n')))
	return -1;
d3042 7
a3048 5
      val = re_match(bufp, string, size, startpos, regs);
      if (val >= 0)
	return startpos;
      if (val == -2)
	return -2;
d3051 3
a3053 4
#ifdef cALLOCA
      alloca(0);
#endif /* cALLOCA */

a3054 5
    advance:
      if (!range) 
        break;
      else if (range > 0) {
	const char *d = string + startpos;
d3056 29
a3084 4
	if (ismbchar(*d)) {
	  range--, startpos++;
	  if (!range)
	    break;
d3086 1
a3086 1
	range--, startpos++;
d3088 1
a3088 4
      else {
	range++, startpos--;
	{
	  const char *s, *d, *p;
d3090 28
a3117 10
	  s = string; d = string + startpos;
	  for (p = d; p-- > s && ismbchar(*p); )
	    /* --p >= s would not work on 80[12]?86. 
	      (when the offset of s equals 0 other than huge model.)  */
	    ;
	  if (!((d - p) & 1)) {
	    if (!range)
	      break;
	    range++, startpos--;
	  }
d3121 1
d3130 1
a3130 10
/* Roughly the maximum number of failure points on the stack.  Would be
   exactly that if always pushed MAX_NUM_FAILURE_ITEMS each time we failed.  */

int re_max_failures = 2000;

/* Routine used by re_match.  */
/* static int memcmp_translate(); *//* already declared */


/* Structure and accessing macros used in re_match:  */
d3132 2
a3133 8
struct register_info
{
  unsigned is_active : 1;
  unsigned matched_something : 1;
};

#define IS_ACTIVE(R)  ((R).is_active)
#define MATCHED_SOMETHING(R)  ((R).matched_something)
d3139 1
d3141 2
a3142 1
#define NUM_REG_ITEMS  3
d3147 1
a3147 3

#define MAX_NUM_FAILURE_ITEMS   (num_regs * NUM_REG_ITEMS + 2)

d3150 1
a3150 2

#define NUM_FAILURE_ITEMS  (last_used_reg * NUM_REG_ITEMS + 2)
d3157 1
a3157 1
  {									\
d3162 2
a3163 2
    for (last_used_reg = num_regs - 1; last_used_reg > 0; last_used_reg--)\
      if (regstart[last_used_reg] != (unsigned char *)(-1L))		\
d3166 1
a3166 2
    if (stacke - stackp <= NUM_FAILURE_ITEMS)				\
      {									\
d3169 5
a3173 5
	if (len > re_max_failures * MAX_NUM_FAILURE_ITEMS)		\
	  {								\
	    FREE_VARIABLES();						\
	    FREE_AND_RETURN(stackb,(-2));				\
	  }								\
d3176 1
a3176 5
        stackx = DOUBLE_STACK(stackx,stackb,len);			\
	/* Rearrange the pointers. */					\
	stackp = stackx + (stackp - stackb);				\
	stackb = stackx;						\
	stacke = stackb + 2 * len;					\
d3180 5
a3184 6
    for (this_reg = 1; this_reg <= last_used_reg; this_reg++)		\
      {									\
        *stackp++ = regstart[this_reg];					\
        *stackp++ = regend[this_reg];					\
        *stackp++ = (unsigned char *)&reg_info[this_reg];		\
      }									\
d3187 1
a3187 1
    *stackp++ = (unsigned char *)last_used_reg;				\
d3191 2
a3192 1
  }
d3194 1
d3196 1
a3196 1
/* This pops what PUSH_FAILURE_POINT pushes.  */
d3199 4
a3202 4
  {									\
    int temp;								\
    stackp -= 2;		/* Remove failure points.  */		\
    temp = (int) *--stackp;	/* How many regs pushed.  */	        \
d3205 5
a3209 1
  }
d3213 1
a3213 1
/* Call this when have matched something; it sets `matched' flags for the
d3217 2
a3218 3
  { unsigned this_reg;							\
    for (this_reg = 0; this_reg < num_regs; this_reg++) 		\
      { 								\
d3220 2
a3221 1
          MATCHED_SOMETHING(reg_info[this_reg]) = 1;			\
d3225 1
a3225 4
  }

#define AT_STRINGS_BEG  (d == string)
#define AT_STRINGS_END  (d == dend)	
d3227 2
a3228 2
#define AT_WORD_BOUNDARY						\
  (AT_STRINGS_BEG || AT_STRINGS_END || IS_A_LETTER (d - 1) != IS_A_LETTER (d))
d3230 9
a3238 7
/* We have two special cases to check for: 
     1) if we're past the end of string1, we have to look at the first
        character in string2;
     2) if we're before the beginning of string2, we have to look at the
        last character in string1; we assume there is a string1, so use
        this in conjunction with AT_STRINGS_BEG.  */
#define IS_A_LETTER(d) (SYNTAX(*(d)) == Sword)
d3242 2
a3243 2
    struct re_registers *regs;
    unsigned num_regs;
d3245 1
a3245 1
    int i;
d3247 16
a3262 16
    regs->num_regs = num_regs;
    if (num_regs < RE_NREGS)
	num_regs = RE_NREGS;

    if (regs->allocated == 0) {
	regs->beg = TMALLOC(num_regs, int);
	regs->end = TMALLOC(num_regs, int);
	regs->allocated = num_regs;
    }
    else if (regs->allocated < num_regs) {
	TREALLOC(regs->beg, num_regs, int);
	TREALLOC(regs->end, num_regs, int);
    }
    for (i=0; i<num_regs; i++) {
	regs->beg[i] = regs->end[i] = -1;
    }
d3283 1
a3283 1
     char *string_arg;
d3287 2
a3288 1
  register unsigned char *p = (unsigned char *) bufp->buffer;
d3295 1
a3295 1
  unsigned char *string = (unsigned char *) string_arg;
d3299 1
a3299 2
  unsigned char *translate = (unsigned char *) bufp->translate;
  unsigned is_a_jump_n = 0;
d3301 9
a3309 9
 /* Failure point stack.  Each place that can handle a failure further
    down the line pushes a failure point on this stack.  It consists of
    restart, regend, and reg_info for all registers corresponding to the
    subexpressions we're currently inside, plus the number of such
    registers, and, finally, two char *'s.  The first char * is where to
    resume scanning the pattern; the second one is where to resume
    scanning the strings.  If the latter is zero, the failure point is a
    ``dummy''; if a failure happens and the failure point is a dummy, it
    gets discarded and the next next one is tried.  */
d3324 10
a3333 2
  unsigned char **regstart = RE_TALLOC(num_regs, unsigned char*);
  unsigned char **regend = RE_TALLOC(num_regs, unsigned char*);
d3342 1
a3342 1
  struct register_info *reg_info = RE_TALLOC(num_regs, struct register_info);
d3350 2
a3351 2
  unsigned char **best_regstart = RE_TALLOC(num_regs, unsigned char*);
  unsigned char **best_regend = RE_TALLOC(num_regs, unsigned char*);
d3354 1
a3354 1
      init_regs(regs, num_regs);
a3356 1

d3363 1
a3363 1
  fprintf (stderr, "Entering re_match(%s%s)\n", string1_arg, string2_arg);
d3367 1
a3367 1
     \( or ( and \) or ) has been seen for. Also set all registers to
d3371 8
a3378 3
      regstart[mcnt] = regend[mcnt] = (unsigned char *) (-1L);
      IS_ACTIVE(reg_info[mcnt]) = 0;
      MATCHED_SOMETHING(reg_info[mcnt]) = 0;
a3393 1

d3398 1
a3398 2
  while (1)
    {
d3400 4
a3403 4
      fprintf(stderr,
	      "regex loop(%d):  matching 0x%02d\n",
	      p - (unsigned char *) bufp->buffer,
	      *p);
d3405 22
a3426 57
      is_a_jump_n = 0;
      /* End of pattern means we might have succeeded.  */
      if (p == pend)
	{
	  /* If not end of string, try backtracking.  Otherwise done.  */
          if (d != dend)
	    {
              if (stackp != stackb)
                {
                  /* More failure points to try.  */

                  /* If exceeds best match so far, save it.  */
                  if (! best_regs_set || (d > best_regend[0]))
                    {
                      best_regs_set = 1;
                      best_regend[0] = d;	/* Never use regstart[0].  */

                      for (mcnt = 1; mcnt < num_regs; mcnt++)
                        {
                          best_regstart[mcnt] = regstart[mcnt];
                          best_regend[mcnt] = regend[mcnt];
                        }
                    }
                  goto fail;	       
                }
              /* If no failure points, don't restore garbage.  */
              else if (best_regs_set)   
                {
	      restore_best_regs:
                  /* Restore best match.  */
                  d = best_regend[0];

		  for (mcnt = 0; mcnt < num_regs; mcnt++)
		    {
		      regstart[mcnt] = best_regstart[mcnt];
		      regend[mcnt] = best_regend[mcnt];
		    }
                }
            }

	  /* If caller wants register contents data back, convert it 
	     to indices.  */
	  if (regs)
	    {
	      regs->beg[0] = pos;
	      regs->end[0] = d - string;
	      for (mcnt = 1; mcnt < num_regs; mcnt++)
		{
		  if (regend[mcnt] == (unsigned char *)(-1L))
		    {
		      regs->beg[mcnt] = -1;
		      regs->end[mcnt] = -1;
		      continue;
		    }
		  regs->beg[mcnt] = regstart[mcnt] - string;
		  regs->end[mcnt] = regend[mcnt] - string;
		}
d3428 34
a3461 3
	  FREE_VARIABLES();
	  FREE_AND_RETURN(stackb, (d - pos - string));
        }
d3463 1
a3463 1
      /* Otherwise match next pattern command.  */
d3465 1
a3465 1
      switch ((int)((enum regexpcode)*p++))
d3467 1
a3467 1
      switch ((enum regexpcode)*p++)
d3469 27
d3497 4
d3502 14
a3515 51
	/* \( [or `(', as appropriate] is represented by start_memory,
           \) by stop_memory.  Both of those commands are followed by
           a register number in the next byte.  The text matched
           within the \( and \) is recorded under that number.  */
	case start_memory:
          regstart[*p] = d;
          IS_ACTIVE(reg_info[*p]) = 1;
          MATCHED_SOMETHING(reg_info[*p]) = 0;
          p++;
          break;

	case stop_memory:
          regend[*p] = d;
          IS_ACTIVE(reg_info[*p]) = 0;

          /* If just failed to match something this time around with a sub-
	     expression that's in a loop, try to force exit from the loop.  */
          if ((! MATCHED_SOMETHING(reg_info[*p])
	       || (enum regexpcode) p[-3] == start_memory)
	      && (p + 1) != pend)              
            {
	      register unsigned char *p2 = p + 1;
              mcnt = 0;
              switch (*p2++)
                {
                  case jump_n:
		    is_a_jump_n = 1;
                  case finalize_jump:
		  case maybe_finalize_jump:
		  case jump:
		  case dummy_failure_jump:
                    EXTRACT_NUMBER_AND_INCR(mcnt, p2);
		    if (is_a_jump_n)
		      p2 += 2;
                    break;
                }
	      p2 += mcnt;

              /* If the next operation is a jump backwards in the pattern
	         to an on_failure_jump, exit from the loop by forcing a
                 failure after pushing on the stack the on_failure_jump's 
                 jump in the pattern, and d.  */
	      if (mcnt < 0 && (enum regexpcode) *p2++ == on_failure_jump)
		{
                  EXTRACT_NUMBER_AND_INCR(mcnt, p2);
                  PUSH_FAILURE_POINT(p2 + mcnt, d);
                  goto fail;
                }
            }
          p++;
          break;
d3517 18
a3534 40
	/* \<digit> has been turned into a `duplicate' command which is
           followed by the numeric value of <digit> as the register number.  */
        case duplicate:
	  {
	    int regno = *p++;   /* Get which register to match against */
	    register unsigned char *d2, *dend2;

	    /* Where in input to try to start matching.  */
            d2 = regstart[regno];

            /* Where to stop matching; if both the place to start and
               the place to stop matching are in the same string, then
               set to the place to stop, otherwise, for now have to use
               the end of the first string.  */

            dend2 = regend[regno];
	    while (1)
	      {
		/* At end of register contents => success */
		if (d2 == dend2) break;

		/* If necessary, advance to next segment in data.  */
		PREFETCH;

		/* How many characters left in this segment to match.  */
		mcnt = dend - d;

		/* Want how many consecutive characters we can match in
                   one shot, so, if necessary, adjust the count.  */
                if (mcnt > dend2 - d2)
		  mcnt = dend2 - d2;

		/* Compare that many; failure if mismatch, else move
                   past them.  */
		if (translate 
                    ? memcmp_translate(d, d2, mcnt, translate) 
                    : memcmp((char *)d, (char *)d2, mcnt))
		  goto fail;
		d += mcnt, d2 += mcnt;
	      }
d3536 33
d3570 7
d3578 3
a3580 1
	case anychar:
a3581 1
	  /* Match anything but a newline, maybe even a null.  */
d3583 1
a3583 1
	    if (d + 1 == dend || d[1] == '\n' || d[1] == '\0')
d3586 2
a3587 2
	    d += 2;
	    break;
d3589 2
a3590 3
	  if ((translate ? translate[*d] : *d) == '\n'
              || ((re_syntax_options & RE_DOT_NOT_NULL) 
                  && (translate ? translate[*d] : *d) == '\000'))
d3593 3
a3595 2
          d++;
	  break;
d3597 7
a3603 6
	case charset:
	case charset_not:
	  {
	    int not;	    /* Nonzero for charset_not.  */
	    int half;	    /* 2 if need to match latter half of mbc */
	    int c;
d3605 5
a3609 7
	    PREFETCH;
	    c = (unsigned char)*d;
	    if (ismbchar(c)) {
	      if (d + 1 != dend) {
	        c <<= 8;
		c |= (unsigned char)d[1];
	      }
d3611 12
a3622 2
	    else if (translate)
	      c = (unsigned char)translate[c];
d3624 2
a3625 4
	    half = not = is_in_list(c, p);
	    if (*(p - 1) == (unsigned char)charset_not) {
		not = !not;
	    }
d3627 3
a3629 1
	    p += 1 + *p + 2 + EXTRACT_UNSIGNED(&p[1 + *p])*4;
d3631 6
a3636 2
	    if (!not) goto fail;
	    SET_REGS_MATCHED;
d3638 3
a3640 3
            d++;
	    if (half != 2 && d != dend && c >= 1 << BYTEWIDTH)
		d++;
d3642 10
a3651 1
	  }
d3653 5
a3657 7
	case begline:
          if (size == 0
	      || d == string
              || (d && d[-1] == '\n'))
            break;
          else
            goto fail;
d3659 4
a3662 2
	case endline:
	  if (d == dend || *d == '\n')
d3664 5
a3668 1
	  goto fail;
d3671 5
a3675 5
           an on_failure_jump that points to the start of the next
           alternative.  Each alternative except the last ends with a
           jump to the joining point.  (Actually, each jump except for
           the last one really jumps to the following jump, because
           tensioning the jumps is a hassle.)  */
d3679 3
a3681 3
           that on failure to match a repetition, matching restarts past
           as many repetitions have been found with no way to fail and
           look for another one.  */
d3686 36
a3721 5
	case on_failure_jump:
        on_failure:
          EXTRACT_NUMBER_AND_INCR(mcnt, p);
          PUSH_FAILURE_POINT(p + mcnt, d);
          break;
d3723 23
a3745 14
	/* The end of a smart repeat has a maybe_finalize_jump back.
	   Change it either to a finalize_jump or an ordinary jump.  */
	case maybe_finalize_jump:
          EXTRACT_NUMBER_AND_INCR(mcnt, p);
	  {
	    register unsigned char *p2 = p;
	    /* Compare what follows with the beginning of the repeat.
	       If we can establish that there is nothing that they would
	       both match, we can change to finalize_jump.  */
	    while (p2 + 1 != pend
		   && (*p2 == (unsigned char)stop_memory
		       || *p2 == (unsigned char)start_memory))
	      p2 += 2;				/* Skip over reg number.  */
	    if (p2 == pend)
a3746 23
	    else if (*p2 == (unsigned char)exactn
		     || *p2 == (unsigned char)endline)
	      {
		register int c = *p2 == (unsigned char)endline ? '\n' : p2[2];
		register unsigned char *p1 = p + mcnt;
		/* p1[0] ... p1[2] are an on_failure_jump.
		   Examine what follows that.  */
		if (p1[3] == (unsigned char)exactn && p1[5] != c)
		  p[-3] = (unsigned char)finalize_jump;
		else if (p1[3] == (unsigned char)charset
			 || p1[3] == (unsigned char)charset_not) {
		    int not;
		    if (ismbchar(c))
		      c = c << 8 | p2[3];
		    /* `is_in_list()' is TRUE if c would match */
		    /* That means it is not safe to finalize.  */
		    not = is_in_list(c, p1 + 4);
		    if (p1[3] == (unsigned char)charset_not)
			not = !not;
		    if (!not)
			p[-3] = (unsigned char)finalize_jump;
		  }
	      }
d3748 7
a3754 7
	  p -= 2;		/* Point at relative address again.  */
	  if (p[-1] != (unsigned char)finalize_jump)
	    {
	      p[-1] = (unsigned char)jump;	
	      goto nofinalize;
	    }
        /* Note fall through.  */
d3757 2
a3758 2
           start, where another failure point will be made which will
           point to after all the repetitions found so far.  */
d3760 16
a3775 6
        /* Take off failure points put on by matching on_failure_jump 
           because didn't fail.  Also remove the register information
           put on by the on_failure_jump.  */
        case finalize_jump:
          POP_FAILURE_POINT();
        /* Note fall through.  */
d3778 112
a3889 2
        case jump:
	nofinalize:
d3891 40
a3930 1
	  p += mcnt;
d3932 1
d3934 10
a3943 68
        case dummy_failure_jump:
          /* Normally, the on_failure_jump pushes a failure point, which
             then gets popped at finalize_jump.  We will end up at
             finalize_jump, also, and with a pattern of, say, `a+', we
             are skipping over the on_failure_jump, so we have to push
             something meaningless for finalize_jump to pop.  */
          PUSH_FAILURE_POINT(0, 0);
          goto nofinalize;


        /* Have to succeed matching what follows at least n times.  Then
          just handle like an on_failure_jump.  */
        case succeed_n: 
          EXTRACT_NUMBER(mcnt, p + 2);
          /* Originally, this is how many times we HAVE to succeed.  */
          if (mcnt)
            {
               mcnt--;
	       p += 2;
               STORE_NUMBER_AND_INCR(p, mcnt);
            }
	  else if (mcnt == 0)
            {
	      p[2] = unused;
              p[3] = unused;
              goto on_failure;
            }
          else
	    { 
              fprintf(stderr, "regex: the succeed_n's n is not set.\n");
              exit(1);
	    }
          break;

        case jump_n: 
          EXTRACT_NUMBER(mcnt, p + 2);
          /* Originally, this is how many times we CAN jump.  */
          if (mcnt)
            {
               mcnt--;
               STORE_NUMBER(p + 2, mcnt);
	       goto nofinalize;	     /* Do the jump without taking off
			                any failure points.  */
            }
          /* If don't have to jump any more, skip over the rest of command.  */
	  else      
	    p += 4;		     
          break;

	case set_number_at:
	  {
  	    register unsigned char *p1;

            EXTRACT_NUMBER_AND_INCR(mcnt, p);
            p1 = p + mcnt;
            EXTRACT_NUMBER_AND_INCR(mcnt, p);
	    STORE_NUMBER(p1, mcnt);
            break;
          }

        /* Ignore these.  Used to ignore the n of succeed_n's which
           currently have n == 0.  */
        case unused:
          break;

        case wordbound:
	  if (AT_WORD_BOUNDARY)
	    break;
d3945 1
d3947 2
a3948 3
	case notwordbound:
	  if (AT_WORD_BOUNDARY)
	    goto fail;
d3950 1
d3952 3
a3954 6
	case wordchar:
	  PREFETCH;
          if (!IS_A_LETTER(d))
            goto fail;
	  d++;
	  SET_REGS_MATCHED;
d3956 11
d3968 19
a3986 9
	case notwordchar:
	  PREFETCH;
	  if (IS_A_LETTER(d))
            goto fail;
	  if (ismbchar(*d) && d + 1 != dend)
	    d++;
	  d++;
          SET_REGS_MATCHED;
	  break;
d3988 9
a3996 37
	case exactn:
	  /* Match the next few pattern characters exactly.
	     mcnt is how many characters to match.  */
	  mcnt = *p++;
	  /* This is written out as an if-else so we don't waste time
             testing `translate' inside the loop.  */
          if (translate)
	    {
	      do
		{
		  unsigned char c;

		  PREFETCH;
		  c = *d++;
		  if (*p == 0xff) {
		    p++;  
		    if (!--mcnt
			|| d == dend
			|| (unsigned char)*d++ != (unsigned char)*p++)
		      goto fail;
		    continue;
		  }
		  else if (ismbchar(c)) {
		    if (c != (unsigned char)*p++
			|| !--mcnt	/* redundant check if pattern was
					   compiled properly. */
			|| d == dend
			|| (unsigned char)*d++ != (unsigned char)*p++)
		      goto fail;
		    continue;
		  }
		  /* compiled code translation needed for ruby */
		  if ((unsigned char)translate[c]
		      != (unsigned char)translate[*p++])
		    goto fail;
		}
	      while (--mcnt);
d3998 12
a4009 9
	  else
	    {
	      do
		{
		  PREFETCH;
		  if (*p == 0xff) {p++; mcnt--;}
		  if (*d++ != *p++) goto fail;
		}
	      while (--mcnt);
d4011 13
a4023 2
	  SET_REGS_MATCHED;
          break;
d4025 4
a4028 1
      continue;  /* Successfully executed one pattern command; keep going.  */
d4031 24
a4054 5
    fail:
      if (stackp != stackb)
	/* A restart point is known.  Restart there and pop it. */
	{
          short last_used_reg, this_reg;
d4056 39
a4094 29
          /* If this failure point is from a dummy_failure_point, just
             skip it.  */
	  if (!stackp[-2])
            {
              POP_FAILURE_POINT();
              goto fail;
            }

          d = *--stackp;
	  p = *--stackp;
          /* Restore register info.  */
          last_used_reg = (long) *--stackp;

          /* Make the ones that weren't saved -1 or 0 again. */
          for (this_reg = num_regs - 1; this_reg > last_used_reg; this_reg--)
            {
              regend[this_reg] = (unsigned char *)(-1L);
              regstart[this_reg] = (unsigned char *)(-1L);
              IS_ACTIVE(reg_info[this_reg]) = 0;
              MATCHED_SOMETHING(reg_info[this_reg]) = 0;
            }

          /* And restore the rest from the stack.  */
          for ( ; this_reg > 0; this_reg--)
            {
              reg_info[this_reg] = *(struct register_info *) *--stackp;
              regend[this_reg] = *--stackp;
              regstart[this_reg] = *--stackp;
            }
d4096 1
a4096 2
      else
        break;   /* Matching at this starting point really fails.  */
d4098 3
d4105 1
d4111 1
a4111 1
memcmp_translate(s1, s2, len, translate)
a4113 1
     unsigned char *translate;
d4116 8
a4123 9
  while (len)
    {
      c = *p1++;
      if (ismbchar(c)) {
	if (c != *p2++ || !--len || *p1++ != *p2++)
	  return 1;
      }
      else
	if (translate[c] != translate[*p2++])
a4124 1
      len--;
d4126 5
d4138 1
a4138 1
    int i;
d4140 16
a4155 16
    if (regs1 == regs2) return;
    if (regs1->allocated == 0) {
	regs1->beg = TMALLOC(regs2->num_regs, int);
	regs1->end = TMALLOC(regs2->num_regs, int);
	regs1->allocated = regs2->num_regs;
    }
    else if (regs1->allocated < regs2->num_regs) {
	TREALLOC(regs1->beg, regs2->num_regs, int);
	TREALLOC(regs1->end, regs2->num_regs, int);
	regs1->allocated = regs2->num_regs;
    }
    for (i=0; i<regs2->num_regs; i++) {
	regs1->beg[i] = regs2->beg[i];
	regs1->end[i] = regs2->end[i];
    }
    regs1->num_regs = regs2->num_regs;
d4162 108
a4269 3
    if (regs->allocated == 0) return;
    if (regs->beg) free(regs->beg);
    if (regs->end) free(regs->end);
@


1.1.1.1
log
@
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@a68 6
#ifdef HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

d74 3
a76 2
#define DOUBLE_STACK(stackx,stackb,len,type) \
        (stackx = (type*) alloca(2 * len * sizeof(type)),		\
d78 1
a78 1
        (type*) memcpy(stackx, stackb, len * sizeof (type)))
d95 2
a96 2
#define DOUBLE_STACK(stackx,stackb,len,type) \
        (type*)xrealloc(stackb, 2 * len * sizeof(type))
a102 10
#define EXPAND_FAIL_STACK(stackx,stackb,len) \
    do {\
        /* Roughly double the size of the stack.  */			\
        stackx = DOUBLE_STACK(stackx,stackb,len,unsigned char*);	\
	/* Rearrange the pointers. */					\
	stackp = stackx + (stackp - stackb);				\
	stackb = stackx;						\
	stacke = stackb + 2 * len;					\
    } while (0);									\

a105 1
/* Subroutines for re_compile_pattern.  */
d110 1
a110 2
static void insert_op P((int, char *, char *));
static void insert_op_2 P((int, char *, char *, int, int));
a182 3
    begbuf,   /* Succeeds if at beginning of buffer (if emacs) or at beginning
                 of string to be matched (if not).  */
    endbuf,   /* Analogously, for end of buffer/string.  */
a208 5
    try_next,    /* Jump to next pattern for the first time,
		    leaving this pattern on the failure stack. */
    finalize_push,	/* Finalize stack and push the beginning of the pattern
			   on the stack to retry (used for non-greedy match) */
    finalize_push_n,	/* Similar to finalize_push, buf finalize n time only */
a228 3
    start_nowidth, /* Save string point to the stack. */
    stop_nowidth,  /* Restore string place at the point start_nowidth. */
    pop_and_fail,  /* Fail after popping nowidth entry from stack. */
a233 2
    wordbeg,	 /* Succeeds if at word beginning.  */
    wordend,	 /* Succeeds if at word end.  */
d389 3
a532 314
static void
print_partial_compiled_pattern(start, end)
    unsigned char *start;
    unsigned char *end;
{
  int mcnt, mcnt2;
  unsigned char *p = start;
  unsigned char *pend = end;

  if (start == NULL)
    {
      printf ("(null)\n");
      return;
    }
    
  /* Loop over pattern commands.  */
  while (p < pend)
    {
      switch ((enum regexpcode) *p++)
	{
	case unused:
	  printf ("/unused");
	  break;

	case exactn:
	  mcnt = *p++;
          printf ("/exactn/%d", mcnt);
          do
	    {
              putchar('/');
	      printf("%c", *p++);
            }
          while (--mcnt);
          break;

	case start_memory:
          mcnt = *p++;
          printf ("/start_memory/%d", mcnt);
          break;

	case stop_memory:
          mcnt = *p++;
	  printf ("/stop_memory/%d", mcnt);
          break;

	case start_nowidth:
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
	  printf ("/start_nowidth//%d", mcnt);
	  break;

	case stop_nowidth:
	  printf ("/stop_nowidth//");
	  p += 2;
	  break;

	case pop_and_fail:
	  printf ("/pop_and_fail");
	  break;

	case duplicate:
	  printf ("/duplicate/%d", *p++);
	  break;

	case anychar:
	  printf ("/anychar");
	  break;

	case charset:
        case charset_not:
          {
            register int c;

            printf ("/charset%s",
	            (enum regexpcode) *(p - 1) == charset_not ? "_not" : "");

            mcnt = *p;
	    printf("/%d", mcnt);
            for (c = 0; c < mcnt; c++)
              {
                unsigned bit;
                unsigned char map_byte = p[1 + c];

		putchar ('/');
                
		for (bit = 0; bit < BYTEWIDTH; bit++)
                  if (map_byte & (1 << bit))
		    printf("%c", c * BYTEWIDTH + bit);
              }
	    p += mcnt + 1;
	    mcnt = EXTRACT_UNSIGNED(p);
	    p += 2;
	    while (mcnt--) {
		int beg = *p++;
		int end = *p++;
		printf("/%c%c-%c%c", beg>>BYTEWIDTH, beg&0xff, end>>BYTEWIDTH, end&0xff);
	    }
	    break;
	  }

	case begline:
	  printf ("/begline");
          break;

	case endline:
          printf ("/endline");
          break;

	case on_failure_jump:
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
  	  printf ("/on_failure_jump//%d", mcnt);
          break;

	case dummy_failure_jump:
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
  	  printf ("/dummy_failure_jump//%d", mcnt);
          break;

        case finalize_jump:
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
  	  printf ("/finalize_jump//%d", mcnt);
	  break;

        case maybe_finalize_jump:
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
  	  printf ("/maybe_finalize_jump//%d", mcnt);
	  break;

        case jump:
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);
  	  printf ("/jump//%d", mcnt);
	  break;

        case succeed_n: 
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
          EXTRACT_NUMBER_AND_INCR (mcnt2, p);
 	  printf ("/succeed_n//%d//%d", mcnt, mcnt2);
          break;
        
        case jump_n: 
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
          EXTRACT_NUMBER_AND_INCR (mcnt2, p);
 	  printf ("/jump_n//%d//%d", mcnt, mcnt2);
          break;
        
        case set_number_at: 
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
          EXTRACT_NUMBER_AND_INCR (mcnt2, p);
 	  printf ("/set_number_at//%d//%d", mcnt, mcnt2);
          break;
        
	case try_next:
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);
  	  printf ("/try_next//%d", mcnt);
          break;

	case finalize_push:
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);
  	  printf ("/finalize_push//%d", mcnt);
          break;

	case finalize_push_n:
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
          EXTRACT_NUMBER_AND_INCR (mcnt2, p);
 	  printf ("/finalize_push_n//%d//%d", mcnt, mcnt2);
          break;

        case wordbound:
	  printf ("/wordbound");
	  break;

	case notwordbound:
	  printf ("/notwordbound");
          break;

	case wordbeg:
	  printf ("/wordbeg");
	  break;
          
	case wordend:
	  printf ("/wordend");
          
	case wordchar:
	  printf ("/wordchar");
          break;
	  
	case notwordchar:
	  printf ("/notwordchar");
          break;

	case begbuf:
	  printf ("/begbuf");
          break;

	case endbuf:
	  printf ("/endbuf");
          break;

        default:
          printf ("?%d", *(p-1));
	}
    }
  printf ("/\n");
}


static void
print_compiled_pattern(bufp)
    struct re_pattern_buffer *bufp;
{
  unsigned char *buffer = bufp->buffer;

  print_partial_compiled_pattern (buffer, buffer + bufp->used);
}

static char*
calculate_must_string(start, end)
    unsigned char *start;
    unsigned char *end;
{
  int mcnt, mcnt2;
  int max = 0;
  unsigned char *p = start;
  unsigned char *pend = end;
  unsigned char *must = 0;

  if (start == NULL) return 0;
    
  /* Loop over pattern commands.  */
  while (p < pend)
    {
      switch ((enum regexpcode) *p++)
	{
	case unused:
	  break;

	case exactn:
	  mcnt = *p;
	  if (mcnt > max) {
	    must = p;
	  }
	  p += mcnt+1;
          break;

	case start_memory:
	case stop_memory:
	case duplicate:
          p++;
          break;

	case start_nowidth:
	case stop_nowidth:
	case pop_and_fail:
	case anychar:
	case begline:
	case endline:
        case wordbound:
	case notwordbound:
	case wordbeg:
	case wordend:
	case wordchar:
	case notwordchar:
	case begbuf:
	case endbuf:
	  break;

	case charset:
        case charset_not:
	  mcnt = *p++;
	  p += mcnt;
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);
	  while (mcnt--) {
	    EXTRACT_NUMBER_AND_INCR (mcnt2, p);
	    EXTRACT_NUMBER_AND_INCR (mcnt2, p);
	  }
	  break;

	case on_failure_jump:
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
	  if (mcnt > 0) p += mcnt;
	  if ((enum regexpcode)p[-3] == jump) {
	    p -= 3;
	    EXTRACT_NUMBER_AND_INCR (mcnt, p);
	    if (mcnt > 0) p += mcnt;
	  }
          break;

	case dummy_failure_jump:
        case succeed_n: 
	case try_next:
	case jump:
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
	  if (mcnt > 0) p += mcnt;
          break;

        case finalize_jump:
        case maybe_finalize_jump:
	case finalize_push:
	  p += 2;
	  break;

        case jump_n: 
        case set_number_at: 
	case finalize_push_n:
	  p += 4;
          break;

        default:
	  break;
	}
    }
  return must;
}


a586 4
    /* In processing a repeat, 1 means non-greedy matches.  */

    char greedy;

d597 4
d602 1
a602 1
       Five stack elements are pushed by each \(:
d605 2
a606 3
       Third, the value of begalt.
       Fourth, the value of regnum.
       Fifth, the type of the paren. */
d608 1
a608 1
    int *stackb = RE_TALLOC(40, int);
d675 5
d719 2
a720 1
	  if (re_syntax_options & RE_LIMITED_OPS)
d722 1
d725 7
a731 6
	  if (!laststart) {
	    if (re_syntax_options & RE_CONTEXTUAL_INVALID_OPS)
	      goto invalid_pattern;
	    else if (! (re_syntax_options & RE_CONTEXT_INDEP_OPS))
	      goto normal_char;
	  }
d734 7
a740 14
	  zero_times_ok = c != '+';
	  many_times_ok = c != '?';
	  greedy = 1;
	  if (p != pend) {
	    PATFETCH(c);
	    switch (c) {
	      case '?':
		greedy = 0;
		break;
	      case '*':
	      case '+':
		goto nested_meta;
	      default:
		PATUNFETCH;
d742 24
a766 1
	  }
a767 1
	repeat:
d775 13
a787 13
	  if (many_times_ok) {
	    /* If more than one repetition is allowed, put in at the
	       end a backward relative jump from b to before the next
	       jump we're going to put in below (which jumps from
	       laststart to after this jump).  */
	    GET_BUFFER_SPACE(3);
	    store_jump(b,greedy?maybe_finalize_jump:finalize_push,laststart-3);
	    b += 3;  	/* Because store_jump put stuff here.  */
	  }

	  /* On failure, jump from laststart to next pattern, which will be the
	     end of the buffer after this jump is inserted.  */
	  GET_BUFFER_SPACE(3);
d789 1
d791 8
a798 5

	  if (zero_times_ok) {
	    if (greedy == 0) {
	      GET_BUFFER_SPACE(3);
	      insert_jump(try_next, laststart, b + 3, b);
a800 11
	  }
	  else {
	    /* At least one repetition is required, so insert a
	       `dummy_failure_jump' before the initial
	       `on_failure_jump' instruction of the loop. This
	       effects a skip over that instruction the first time
	       we hit that loop.  */
	    GET_BUFFER_SPACE(3);
	    insert_jump(dummy_failure_jump, laststart, laststart + 6, b);
	    b += 3;
	  }
d834 1
a834 1
	  for (;;)
d987 16
a1002 15
	  PATFETCH(c);
	  if (c == '?') {
	      PATFETCH(c);
	      switch (c) {
		case '#':
		case 'i':
		case 'm':
		case 's':
		case 'x':
		  for (;;) {
		      PATFETCH(c);
		      if (c == ')') break;
		  }
		  c = '#';
		  break;
d1004 12
a1015 4
		case ':':
		case '=':
		case '!':
		  break;
d1017 6
a1022 19
		default:
		  FREE_AND_RETURN(stackb, "undefined (?...) sequence");
	      }
	  }
	  else {
	    PATUNFETCH;
	    c = '(';
	  }
	  if (c == '#') break;
	  if (stackp+6 >= stacke) {
	    int *stackx;
	    unsigned int len = stacke - stackb;

	    stackx = DOUBLE_STACK(stackx,stackb,len,int);
	    /* Rearrange the pointers. */
	    stackp = stackx + (stackp - stackb);
	    stackb = stackx;
	    stacke = stackb + 2 * len;
	  }
d1024 8
a1031 7
	  /* Laststart should point to the start_memory that we are about
	     to push (unless the pattern has RE_NREGS or more ('s).  */
	  /* obsolete: now RE_NREGS is just a default register size. */
	  *stackp++ = b - bufp->buffer;    
	  *stackp++ = fixup_jump ? fixup_jump - bufp->buffer + 1 : 0;
	  *stackp++ = begalt - bufp->buffer;
	  switch (c) {
d1033 9
d1044 1
d1046 6
a1051 2
	      /* too many ()'s to fit in a byte. (max 254) */
	      if (regnum >= RE_REG_MAX) goto too_big;
d1054 6
a1059 28
	    case '=':
	    case '!':
	      BUFPUSH(start_nowidth);
	      *stackp++ = b - bufp->buffer;
	      BUFPUSH(0);	/* temporary value */
	      BUFPUSH(0);
	      if (c == '=') break;

	      BUFPUSH(on_failure_jump);
	      *stackp++ = b - bufp->buffer;
	      BUFPUSH(0);	/* temporary value */
	      BUFPUSH(0);
	      break;

	    case ':':
	    default:
	      break;
	  }
	  *stackp++ = c;
	  fixup_jump = 0;
	  laststart = 0;
	  begalt = b;
	  break;

	case ')':
	  if (stackp == stackb) goto unmatched_close;
	  switch (c = *--stackp) {
	    case '(':
d1064 3
d1069 27
a1095 13
	    case '!':
	      BUFPUSH(pop_and_fail);
	      /* back patch */
	      STORE_NUMBER(bufp->buffer+stackp[-1], b - bufp->buffer - stackp[-1] - 2);
	      stackp--;
	      /* fall through */
	    case '=':
	      BUFPUSH(stop_nowidth);
	      /* tell stack-pos place to start_nowidth */
	      STORE_NUMBER(bufp->buffer+stackp[-1], b - bufp->buffer - stackp[-1] - 2);
	      BUFPUSH(0);	/* space to hold stack pos */
	      BUFPUSH(0);
	      break;
d1097 2
a1098 2
	    case ':':
	    default:
a1099 8
	  }
	  stackp--;
	  begalt = *--stackp + bufp->buffer;
	  stackp--;
	  fixup_jump = *stackp ? *stackp + bufp->buffer - 1 : 0;
	  laststart = *--stackp + bufp->buffer;
	  if (c == '!' || c == '=') laststart = b;
	  break;
d1101 36
a1136 21
	case '|':
	  /* Insert before the previous alternative a jump which
	     jumps to this alternative if the former fails.  */
	  GET_BUFFER_SPACE(6);
	  insert_jump(on_failure_jump, begalt, b + 6, b);
	  pending_exact = 0;
	  b += 3;
	  /* The alternative before the previous alternative has a
	     jump after it which gets executed if it gets matched.
	     Adjust that jump so it will jump to the previous
	     alternative's analogous jump (put in below, which in
	     turn will jump to the next (if any) alternative's such
	     jump, etc.).  The last such jump jumps to the correct
	     final destination.  */
	  if (fixup_jump)
	    store_jump(fixup_jump, jump, b);

	  /* Leave space for a jump after previous alternative---to be 
	     filled in later.  */
	  fixup_jump = b;
	  b += 3;
d1138 4
a1141 3
	  laststart = 0;
	  begalt = b;
	  break;
d1143 29
a1171 53
	case '{':
	  /* If there is no previous pattern, this isn't an interval.  */
	  if (!laststart)
	    {
	      if (re_syntax_options & RE_CONTEXTUAL_INVALID_OPS)
		goto invalid_pattern;
	      else
		goto normal_backsl;
	    }
	  /* It also isn't an interval if not preceded by an re
	     matching a single character or subexpression, or if
	     the current type of intervals can't handle back
	     references and the previous thing is a back reference.  */
	  if (! (*laststart == anychar
		 || *laststart == charset
		 || *laststart == charset_not
		 || *laststart == wordchar
		 || *laststart == notwordchar
		 || *laststart == start_memory
		 || (*laststart == exactn
		     && (laststart[1] == 1
			 || laststart[1] == 2 && ismbchar(laststart[2])))
		 || (! (re_syntax_options & RE_NO_BK_REFS)
		     && *laststart == duplicate)))
	    {
	      /* Posix extended syntax is handled in previous
		 statement; this is for Posix basic syntax.  */
	      if (re_syntax_options & RE_INTERVALS)
		goto invalid_pattern;

	      goto normal_backsl;
	    }
	  lower_bound = -1;			/* So can see if are set.  */
	  upper_bound = -1;
	  GET_UNSIGNED_NUMBER(lower_bound);
	  if (c == ',') {
	    GET_UNSIGNED_NUMBER(upper_bound);
	    if (upper_bound < 0)
	      upper_bound = RE_DUP_MAX;
	  }
	  if (upper_bound < 0)
	    upper_bound = lower_bound;
	  if (c != '}' || lower_bound < 0 || upper_bound > RE_DUP_MAX
	      || lower_bound > upper_bound 
	      || (p != pend  && *p == '{')) {
	    goto invalid_pattern;
	  }
	  greedy = 1;
	  if (p != pend) {
	    PATFETCH(c);
	    if (c == '?') greedy = 0;
	    else PATUNFETCH;
	  }
d1173 79
a1251 10
	  /* If upper_bound is zero, don't want to succeed at all; 
	     jump from laststart to b + 3, which will be the end of
	     the buffer after this jump is inserted.  */

	  if (upper_bound == 0) {
	    GET_BUFFER_SPACE(3);
	    insert_jump(jump, laststart, b + 3, b);
	    b += 3;
	    break;
	  }
a1252 91
	  if (lower_bound == 0) {
	    zero_times_ok = 1;
	    if (upper_bound == RE_DUP_MAX) {
	      many_times_ok = 1;
	      goto repeat;
	    }
	    if (upper_bound == 1) {
	      many_times_ok = 0;
	      goto repeat;
	    }
	  }
	  if (lower_bound == 1 && upper_bound == RE_DUP_MAX) {
	    many_times_ok = 1;
	    zero_times_ok = 0;
	    goto repeat;
	  }

	  /* Star, etc. applied to an empty pattern is equivalent
	     to an empty pattern.  */
	  if (!laststart)  
	    break;

	  { /* If the upper bound is > 1, we need to insert
	       more at the end of the loop.  */
	    unsigned slots_needed = upper_bound == 1 ? 5 : 10;

	    GET_BUFFER_SPACE(5);
	    /* Initialize lower bound of the `succeed_n', even
	       though it will be set during matching by its
	       attendant `set_number_at' (inserted next),
	       because `re_compile_fastmap' needs to know.
	       Jump to the `jump_n' we might insert below.  */
	    insert_jump_n(succeed_n, laststart, b + slots_needed, 
			  b, lower_bound);
	    b += 5; 	/* Just increment for the succeed_n here.  */

	    /* Code to initialize the lower bound.  Insert 
	       before the `succeed_n'.  The `5' is the last two
	       bytes of this `set_number_at', plus 3 bytes of
	       the following `succeed_n'.  */
	    GET_BUFFER_SPACE(5);
	    insert_op_2(set_number_at, laststart, b, 5, lower_bound);
	    b += 5;

	    if (upper_bound > 1)
	      { /* More than one repetition is allowed, so
		   append a backward jump to the `succeed_n'
		   that starts this interval.

		   When we've reached this during matching,
		   we'll have matched the interval once, so
		   jump back only `upper_bound - 1' times.  */
		GET_BUFFER_SPACE(5);
		store_jump_n(b, greedy?jump_n:finalize_push_n, laststart + 5, upper_bound - 1);
		b += 5;

		/* The location we want to set is the second
		   parameter of the `jump_n'; that is `b-2' as
		   an absolute address.  `laststart' will be
		   the `set_number_at' we're about to insert;
		   `laststart+3' the number to set, the source
		   for the relative address.  But we are
		   inserting into the middle of the pattern --
		   so everything is getting moved up by 5.
		   Conclusion: (b - 2) - (laststart + 3) + 5,
		   i.e., b - laststart.

		   We insert this at the beginning of the loop
		   so that if we fail during matching, we'll
		   reinitialize the bounds.  */
		GET_BUFFER_SPACE(5);
		insert_op_2(set_number_at, laststart, b, b - laststart, upper_bound - 1);
		b += 5;

		GET_BUFFER_SPACE(5);
		BUFPUSH(set_number_at);
		STORE_NUMBER_AND_INCR(b, -5);
		STORE_NUMBER_AND_INCR(b, upper_bound - 1);
	      }
	    pending_exact = 0;
	  }
	  break;

        case '\\':
	  if (p == pend) goto invalid_pattern;
          /* Do not translate the character after the \, so that we can
             distinguish, e.g., \B from \b, even if we normally would
             translate, e.g., B to b.  */
	  PATFETCH_RAW(c);
	  switch (c)
	    {
d1259 1
a1259 1
		EXTEND_BUFFER;
d1263 1
a1263 1
		BUFPUSH(charset);
d1266 1
a1266 1
		BUFPUSH(charset_not);
d1272 5
a1276 5
		SET_LIST_BIT(' ');
		SET_LIST_BIT('\t');
		SET_LIST_BIT('\n');
		SET_LIST_BIT('\r');
		SET_LIST_BIT('\f');
d1279 1
a1279 1
		char cc;
d1281 3
a1283 3
		for (cc = '0'; cc <= '9'; cc++) {
		  SET_LIST_BIT(cc);
		}
d1287 1
a1287 1
		b[-1]--; 
d1289 2
a1290 2
		memmove(&b[b[-1]], &b[(1 << BYTEWIDTH) / BYTEWIDTH],
		  2 + EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH])*4);
a1303 8
	    case '<':
	      BUFPUSH(wordbeg);
	      break;

	    case '>':
	      BUFPUSH(wordend);
	      break;

a1311 8
	    case 'A':
	      BUFPUSH(begbuf);
	      break;

	    case 'Z':
	      BUFPUSH(endbuf);
	      break;

d1357 1
a1357 1
              for (stackt = stackp - 2;  stackt > stackb;  stackt -= 5)
d1365 8
d1387 1
a1387 1
	    c1 = 0xff;
a1391 1
	      || *p == '+' || *p == '?'
d1393 7
a1399 1
	      || *p == '{')
d1422 1
a1422 2
  bufp->must = calculate_must_string(bufp->buffer, b);
  FREE_AND_RETURN(stackb, 0);
d1425 1
a1425 1
  FREE_AND_RETURN(stackb, "invalid character in regular expression");
d1428 1
a1428 1
  FREE_AND_RETURN(stackb, "invalid regular expression");
d1431 1
a1431 1
  FREE_AND_RETURN(stackb, "unmatched (");
d1434 1
a1434 1
  FREE_AND_RETURN(stackb, "unmatched )");
d1437 4
a1440 1
  FREE_AND_RETURN(stackb, "premature end of regular expression");
d1443 1
a1443 1
  FREE_AND_RETURN(stackb, "regular expression too big");
d1446 1
a1446 4
  FREE_AND_RETURN(stackb, "memory exhausted");

 nested_meta:
  FREE_AND_RETURN(stackb, "nested *?+ in regexp");
a1526 21
/* Open up space at location THERE, and insert operation OP.
   CURRENT_END gives the end of the storage in use, so
   we know how much data to copy up.

   If you call this function, you must zero out pending_exact.  */

static void
insert_op(op, there, current_end)
     int op;
     char *there, *current_end;
{
  register char *pfrom = current_end;		/* Copy from here...  */
  register char *pto = current_end + 1;		/* ...to here.  */

  while (pfrom != there)			       
    *--pto = *--pfrom;

  there[0] = (char)op;
}


a1549 77

#define trans_eq(c1, c2, translate) (translate?(translate[c1]==translate[c2]):((c1)==(c2)))
static int
must_match(little, lend, big, bend, translate)
     unsigned char *little, *lend;
     unsigned char *big, *bend;
     unsigned char *translate;
{
  int c;

  while (little < lend && big < bend) {
    c = *little++;
    if (c == 0xff) {
      if (!trans_eq(*big++, *little++, translate)) break;
      continue;
    }
    if (!trans_eq(*big++, c, translate)) break;
  }
  if (little == lend) return 1;
  return 0;
}

static int
must_instr(little, llen, big, blen, translate)
     unsigned char *little;
     int llen;
     unsigned char *big;
     int blen;
     char *translate;
{
  unsigned char *bend = big + blen;
  register int c;
  int fescape = 0;

  if (blen < llen)
    return 0;

  c = *little;
  if (c == 0xff) {
    c = *++little;
    fescape = 1;
  }
  else if (translate && !ismbchar(c)) {
    c = translate[c];
  }

  while (big < bend) {
    /* look for first character */
    if (fescape) {
      while (big < bend) {
	if (*big == c) break;
	big++;
      }
    }
    else if (translate && !ismbchar(c)) {
      while (big < bend) {
	if (ismbchar(*big)) big++;
	else if (translate[*big] == c) break;
	big++;
      }
    }
    else {
      while (big < bend) {
	if (*big == c) break;
	if (ismbchar(*big)) big++;
	big++;
      }
    }

    if (must_match(little, little+llen, big, bend, translate))
      return 1;

    if (ismbchar(*big)) big++;
    big++;
  }
  return 0;
}
d1560 1
d1574 4
a1577 3
  unsigned char **stackb = RE_TALLOC(NFAILURES, unsigned char*);
  unsigned char **stackp = stackb;
  unsigned char **stacke = stackb + NFAILURES;
a1610 2
	case begbuf:
	case endbuf:
d1613 1
a1613 4
	case wordbeg:
	case wordend:
	case pop_and_fail:
	  continue;
d1642 1
a1642 3
	      && (enum regexpcode) *p != try_next
	      && (enum regexpcode) *p != finalize_push
	      && (enum regexpcode) *p != finalize_push_n)
d1648 1
a1648 1
            stackp--;		/* pop */
a1650 11
        case start_nowidth:
	case stop_nowidth:
        case finalize_push:
	  p += 2;
	  continue;

        case finalize_push_n:
	  p += 4;
	  continue;

	case try_next:
d1654 1
a1654 12
          if (p + j < pend) {
	    if (stackp == stacke) {
	      unsigned char **stackx;
	      unsigned int len = stacke - stackb;

	      EXPAND_FAIL_STACK(stackx, stackb, len);
	    }
	    *++stackp = p + j;	/* push */
	  }
	  else {
            bufp->can_be_null = 1;
	  }
d1662 1
a1662 1
          EXTRACT_NUMBER(k, p + 2);
d1664 6
a1669 6
          if (k == 0) {
	    p += 4;
	  }
	  else {
	    goto handle_on_failure_jump;
	  }
d1808 1
a1808 1
	p = *stackp--;		/* pop */
d1814 2
a1844 34
  /* If the search isn't to be a backwards one, don't waste time in a
     search for a pattern that must be anchored.  */
  if (bufp->used>0) {
    switch ((enum regexpcode)bufp->buffer[0]) {
    case begbuf:
      if (range > 0) {
	if (startpos > 0)
	  return -1;
	else 
	  return re_match(bufp, string, size, 0, regs);
      }
      break;

    case begline:
      if (startpos == 0) {
        val = re_match(bufp, string, size, 0, regs);
        if (val >= 0) return 0;
      }
      anchor = 1;
      break;

    default:
      break;
    }
  }
#if 1
  if (range > 0
      && bufp->must
      && !must_instr(bufp->must+1, bufp->must[0],
		     string+startpos, size-startpos,
		     translate)) {
    return -1;
  }
#endif
d1847 1
a1847 1
      re_compile_fastmap(bufp);
d1850 3
d1866 1
d1870 2
a1871 1
	      p = (unsigned char *)string+startpos;
d1873 1
a1873 1
	      while (range > 0) {
d1920 1
a1921 1

d2024 5
a2028 1
        EXPAND_FAIL_STACK(stackx, stackb, len);				\
a2043 1
    *stackp++ = (unsigned char *)0; /* non-greedy flag */		\
d2052 1
a2052 1
    stackp -= 3;		/* Remove failure points (and flag). */	\
d2074 2
a2075 2
#define AT_STRINGS_BEG(d)  (d == string)
#define AT_STRINGS_END(d)  (d == dend)	
d2077 2
a2078 2
#define AT_WORD_BOUNDARY(d)						\
  (AT_STRINGS_BEG(d) || AT_STRINGS_END(d) || IS_A_LETTER(d - 1) != IS_A_LETTER(d))
d2194 1
a2194 1
    init_regs(regs, num_regs);
d2197 1
d2235 1
a2235 1
  for (;;)
d2322 1
a2322 1
	  continue;
d2363 1
a2363 1
	  continue;
d2381 1
a2381 1
	    for (;;)
a2407 19
	case start_nowidth:
          PUSH_FAILURE_POINT(0, d);
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
	  STORE_NUMBER(p+mcnt, stackp - stackb);
	  continue;

	case stop_nowidth:
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
	  stackp = stackb + mcnt;
	  d = stackp[-2];
	  POP_FAILURE_POINT();
	  continue;

	case pop_and_fail:
	  EXTRACT_NUMBER(mcnt, p+1);
	  stackp = stackb + mcnt;
	  POP_FAILURE_POINT();
	  goto fail;

a2472 12
	/* Match at the very beginning of the string.  */
	case begbuf:
          if (AT_STRINGS_BEG(d))
            break;
          goto fail;

	/* Match at the very end of the data.  */
        case endbuf:
	  if (AT_STRINGS_END(d))
	    break;
          goto fail;

d2493 1
a2493 1
          continue;
d2558 1
a2558 1
	  continue;
d2569 1
d2575 1
a2575 1
          if (mcnt > 0)
a2579 1
	       PUSH_FAILURE_POINT(0, 0);
d2587 6
a2592 1
	  continue;
d2594 1
a2594 1
        case jump_n:
d2607 1
a2607 1
	  continue;
d2617 1
a2617 1
            continue;
a2619 33
	case try_next:
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
	  if (p + mcnt < pend) {
	    PUSH_FAILURE_POINT(p, d);
	    stackp[-1] = (unsigned char*)1;
	  }
	  p += mcnt;
	  continue;

	case finalize_push:
          POP_FAILURE_POINT();
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
          PUSH_FAILURE_POINT(p + mcnt, d);
	  stackp[-1] = (unsigned char*)1;
	  continue;

	case finalize_push_n:
          EXTRACT_NUMBER(mcnt, p + 2);
          /* Originally, this is how many times we CAN jump.  */
          if (mcnt) {
	    mcnt--;
	    STORE_NUMBER(p + 2, mcnt);
	    POP_FAILURE_POINT();
	    EXTRACT_NUMBER_AND_INCR(mcnt, p);
	    PUSH_FAILURE_POINT(p + mcnt, d);
	    stackp[-1] = (unsigned char*)1;
	    p += 7;		/* skip n and set_number_at after destination */
	  }
          /* If don't have to push any more, skip over the rest of command.  */
	  else 
	    p += 4;   
	  continue;

d2623 1
a2623 1
	  continue;
d2626 1
a2626 1
	  if (AT_WORD_BOUNDARY(d))
d2631 1
a2631 1
	  if (AT_WORD_BOUNDARY(d))
a2634 11
	case wordbeg:
	  if (IS_A_LETTER(d) && (AT_STRINGS_BEG(d) || !IS_A_LETTER(d - 1)))
	    break;
          goto fail;

	case wordend:
	  if (!AT_STRINGS_BEG(d) && IS_A_LETTER(d - 1)
              && (!IS_A_LETTER(d) || AT_STRINGS_END(d)))
	    break;
          goto fail;

d2675 1
a2675 1
		  if (ismbchar(c)) {
a2703 2
      if (stackp != stackb && (int)stackp[-1] == 1)
	  POP_FAILURE_POINT();
d2715 6
a2720 5
	  if (stackp[-3] == 0) {
	    POP_FAILURE_POINT();
	    goto fail;
	  }
	  stackp--;		/* discard flag */
@


1.1.1.3
log
@ruby 1.3 cycle
@
text
@d35 3
a47 7
#include "config.h"

void *xmalloc P((unsigned long));
void *xcalloc P((unsigned long,unsigned long));
void *xrealloc P((void*,unsigned long));
void free P((void*));

d52 8
a59 5
# ifndef atarist
#  ifndef alloca
#   define alloca __builtin_alloca
#  endif
# endif /* atarist */
a60 3
# if defined(HAVE_ALLOCA_H)
#  include <alloca.h>
# else
d62 1
a62 1
# endif
a75 1
#ifdef C_ALLOCA
a76 3
#else
#define FREE_VARIABLES()
#endif
d81 1
a81 1
        (stackx = (type*)alloca(2 * len * sizeof(type)),		\
d83 1
a83 1
        (type*)memcpy(stackx, stackb, len * sizeof (type)))
d86 1
a86 1
#define RE_ALLOCATE xmalloc
a92 2
    FREE_VAR(old_regstart)						\
    FREE_VAR(old_regend);						\
d116 1
a116 1
    } while (0)
d122 8
a129 10
static void store_jump P((char*, int, char*));
static void insert_jump P((int, char*, char*, char*));
static void store_jump_n P((char*, int, char*, unsigned));
static void insert_jump_n P((int, char*, char*, char*, unsigned));
static void insert_op P((int, char*, char*));
static void insert_op_2 P((int, char*, char*, int, int));
static int memcmp_translate P((unsigned char*, unsigned char*, int));
static int alt_match_null_string_p ();
static int common_op_match_null_string_p ();
static int group_match_null_string_p ();
d134 4
a137 3
   commands in re_match.  */
#define Sword  1
#define Sword2 2
a142 4
static unsigned char *translate = 0;
static void init_regs P((struct re_registers*, unsigned int));
static void bm_init_skip P((int *, unsigned char*, int, char*));
static int current_mbctype = MBCTYPE_ASCII;
d159 9
a167 3
   for (c=0; c<0x7f; c++)
     if (isalnum(c)) 
       re_syntax_table[c] = Sword;
d170 6
a175 3
   for (c=0x80; c<=0xff; c++)
     if (isalnum(c)) 
       re_syntax_table[c] = Sword2;
d179 3
a181 26
void
re_set_casetable(table)
     char *table;
{
  translate = (unsigned char*)table;
}

/* Jim Meyering writes:

   "... Some ctype macros are valid only for character codes that
   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
   using /bin/cc or gcc but without giving an ansi option).  So, all
   ctype uses should be through macros like ISPRINT...  If
   STDC_HEADERS is defined, then autoconf has verified that the ctype
   macros don't need to be guarded with references to isascii. ...
   Defining isascii to 1 should let any compiler worth its salt
   eliminate the && through constant folding."  */
#ifdef isblank
#define ISBLANK(c) isblank ((unsigned char)c)
#else
#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
#endif
#ifdef isgraph
#define ISGRAPH(c) isgraph ((unsigned char)c)
#else
#define ISGRAPH(c) (isprint ((unsigned char)c) && !isspace ((unsigned char)c))
a183 11
#define ISPRINT(c) isprint ((unsigned char)c)
#define ISDIGIT(c) isdigit ((unsigned char)c)
#define ISALNUM(c) isalnum ((unsigned char)c)
#define ISALPHA(c) isalpha ((unsigned char)c)
#define ISCNTRL(c) iscntrl ((unsigned char)c)
#define ISLOWER(c) islower ((unsigned char)c)
#define ISPUNCT(c) ispunct ((unsigned char)c)
#define ISSPACE(c) isspace ((unsigned char)c)
#define ISUPPER(c) isupper ((unsigned char)c)
#define ISXDIGIT(c) isxdigit ((unsigned char)c)

a202 1
    endbuf2,  /* End of buffer/string, or newline just before it.  */
a203 1
    jump_past_alt,/* Same as jump, but marks the end of an alternative.  */
a221 2
    push_dummy_failure, /* Push a dummy failure point and continue.  Used at the end of
			   alternatives.  */
a253 3
    stop_paren,    /* Place holder at the end of (?:..). */
    casefold_on,   /* Turn on casefold flag. */
    casefold_off,  /* Turn off casefold flag. */
d287 2
a288 2
  do { (destination)[0] = (number) & 0377;				\
    (destination)[1] = (number) >> 8; } while (0)
d294 2
a295 2
  do { STORE_NUMBER(destination, number);				\
    (destination) += 2; } while (0)
d301 2
a302 2
  do { (destination) = *(source) & 0377;				\
    (destination) += SIGN_EXTEND_CHAR (*(char*)((source) + 1)) << 8; } while (0)
d308 2
a309 2
  do { EXTRACT_NUMBER(destination, source);				\
    (source) += 2; } while (0)
d323 5
a327 1
    /* obsolete */
d330 3
a335 2
#define TRANSLATE_P() ((options&RE_OPTION_IGNORECASE) && translate)
#define MAY_TRANSLATE() ((bufp->options&(RE_OPTION_IGNORECASE|RE_MAY_IGNORECASE)) && translate)
d343 1
a343 1
    if (TRANSLATE_P()) c = (unsigned char)translate[c];	\
d350 1
a350 1
    c = (unsigned char)*p++; 						\
a355 59
#define MBC2WC(c, p)\
  do {\
    if (current_mbctype == MBCTYPE_UTF8) {\
      int n = ismbchar(c);\
      int c1;\
      c &= 1<<(BYTEWIDTH-2-n);\
      while (n--) {\
	c = c << 6 | *p++;\
      }\
    }\
    else {\
      c <<= 8;\
      c |= (unsigned char)*(p)++;\
    }\
  } while (0)

#define PATFETCH_MBC(c) \
  do {\
    if (p + ismbchar(c) == pend) goto end_of_pattern;\
    MBC2WC(c, p);\
  } while(0)

#define WC2MBC1ST(c) \
 ((current_mbctype != MBCTYPE_UTF8)?(((c)>>8)&0xff):utf8_firstbyte(c))

static unsigned int
utf8_firstbyte(c)
     unsigned int c;
{
  if (c < 0x80) return c;
  if (c < 0x7ff) return ((c>>6)&0xff)|0xc0;
  if (c < 0xffff) return ((c>>12)&0xff)|0xe0;
  if (c < 0x1fffff) return ((c>>18)&0xff)|0xf0;
  if (c < 0x3ffffff) return ((c>>24)&0xff)|0xf8;
  if (c < 0x7fffffff) return ((c>>30)&0xff)|0xfc;
}

static void
print_mbc(c)
     unsigned int c;
{
  if (current_mbctype == MBCTYPE_UTF8) {
    if (c < 0x80)
      printf("%c", c);
    else if (c < 0x7ff)
      printf("%c%c", utf8_firstbyte(c), c&0x3f);
    else if (c < 0xffff)
      printf("%c%c%c", utf8_firstbyte(c), (c>>6)&0x3f, c&0x3f);
    else if (c < 0x1fffff) 
      printf("%c%c%c%c", utf8_firstbyte(c), (c>>12)&0x3f, (c>>6)&0x3f, c&0x3f);
    else if (c < 0x3ffffff)
      printf("%c%c%c%c%c", utf8_firstbyte(c), (c>>18)&0x3f, (c>>12)&0x3f, (c>>6)&0x3f, c&0x3f);
    else if (c < 0x7fffffff)
      printf("%c%c%c%c%c", utf8_firstbyte(c), (c>>24)&0x3f, (c>>18)&0x3f, (c>>12)&0x3f, (c>>6)&0x3f, c&0x3f);
  }
  else {
    printf("%c%c", c>>BYTEWIDTH, c&0xff);
  }
}
d362 1
a362 1
  do {								        \
d365 1
a365 1
  } while (0)
d369 1
a369 1
  do {									\
d372 1
a372 1
  } while (0)
d379 1
a379 1
  do { char *old_buffer = bufp->buffer;					\
d383 1
a383 1
    bufp->buffer = (char*)xrealloc (bufp->buffer, bufp->allocated);	\
d387 2
a388 2
    if (fixup_alt_jump)							\
      fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;	\
d394 1
a394 1
  } while (0)
d404 1
a404 1
  do { if (p != pend) 							\
d407 1
a407 1
	while (ISDIGIT(c)) 						\
d417 1
a417 5
  } while (0)

#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))

#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
a418 7
#define IS_CHAR_CLASS(string)						\
   (STREQ(string, "alpha") || STREQ(string, "upper")			\
    || STREQ(string, "lower") || STREQ(string, "digit")			\
    || STREQ(string, "alnum") || STREQ(string, "xdigit")		\
    || STREQ(string, "space") || STREQ(string, "print")			\
    || STREQ(string, "punct") || STREQ(string, "graph")			\
    || STREQ(string, "cntrl") || STREQ(string, "blank"))
d420 9
a428 28
#define STORE_MBC(p, c)							\
  do {									\
    (p)[0] = (unsigned char)(((c) >>24) & 0xff);			\
    (p)[1] = (unsigned char)(((c) >>16) & 0xff);			\
    (p)[2] = (unsigned char)(((c) >> 8) & 0xff);			\
    (p)[3] = (unsigned char)(((c) >> 0) & 0xff);			\
  } while (0)

#define STORE_MBC_AND_INCR(p, c) 					\
  do {									\
    *(p)++ = (unsigned char)(((c) >>24) & 0xff);			\
    *(p)++ = (unsigned char)(((c) >>16) & 0xff);			\
    *(p)++ = (unsigned char)(((c) >> 8) & 0xff);			\
    *(p)++ = (unsigned char)(((c) >> 0) & 0xff);			\
  } while (0)

#define EXTRACT_MBC(p) 							\
  ((unsigned short)((unsigned char)(p)[0] << 24 |			\
		    (unsigned char)(p)[1] << 16 |			\
                    (unsigned char)(p)[2] <<  8 |			\
		    (unsigned char)(p)[3]))

#define EXTRACT_MBC_AND_INCR(p) 					\
  ((unsigned short)((p) += 4, 						\
		    (unsigned char)(p)[-4] << 24 |			\
		    (unsigned char)(p)[-3] << 16 |			\
                    (unsigned char)(p)[-2] <<  8 |			\
		    (unsigned char)(p)[-1]))
d445 2
a446 2
	 unsigned int beg;		beginning of interval.
	 unsigned int end;		end of interval.
d452 1
a452 1
    unsigned int c1, c2;
d461 18
d484 1
a484 1
    if ((int)c1 - 1 > (int)EXTRACT_MBC(&b[mid*8+4]))
d493 1
a493 1
    if ((int)c2 >= (int)EXTRACT_MBC(&b[mid*8]) - 1)
d500 4
a503 4
    if (c1 > EXTRACT_MBC(&b[beg*8]))
      c1 = EXTRACT_MBC(&b[beg*8]);
    if (c2 < EXTRACT_MBC(&b[(end - 1)*8+4]))
      c2 = EXTRACT_MBC(&b[(end - 1)*8+4]);
d507 3
a509 3
    memmove(&b[(beg + 1)*8], &b[end*8], (mbc_size - end)*8);
  STORE_MBC(&b[beg*8 + 0], c1);
  STORE_MBC(&b[beg*8 + 4], c2);
d516 1
a516 1
    unsigned int c;
d524 4
a527 2
    if ((int)c / BYTEWIDTH < (int)size && b[c / BYTEWIDTH] & 1 << c % BYTEWIDTH) {
	return 2;
d533 13
d547 1
a547 1
      unsigned short k = (unsigned short)(i + j) >> 1;
d549 4
a552 4
      if (c > EXTRACT_MBC(&b[k*8+4]))
	i = k + 1;
      else
	j = k;
d554 1
a554 1
    if (i < size && EXTRACT_MBC(&b[i*8]) <= c
d556 1
a556 1
      return 1;
d578 1
a578 1
      switch ((enum regexpcode)*p++)
d597 1
a597 1
          printf ("/start_memory/%d/%d", mcnt, *p++);
d602 1
a602 1
	  printf ("/stop_memory/%d/%d", mcnt, *p++);
a604 12
	case stop_paren:
	  printf ("/stop_paren");
	  break;

	case casefold_on:
	  printf ("/casefold_on");
	  break;

	case casefold_off:
	  printf ("/casefold_off");
	  break;

d633 1
a633 1
	            (enum regexpcode)*(p - 1) == charset_not ? "_not" : "");
d635 1
a635 1
            mcnt = *p++;
d640 1
a640 1
                unsigned char map_byte = p[c];
d648 3
a650 3
	    p += mcnt;
	    mcnt = EXTRACT_UNSIGNED_AND_INCR(p);
	    printf("/");
d652 3
a654 3
		print_mbc(EXTRACT_MBC_AND_INCR(p));
		printf("-");
		print_mbc(EXTRACT_MBC_AND_INCR(p));
a676 4
	case push_dummy_failure:
          printf ("/push_dummy_failure");
          break;
          
a686 5
        case jump_past_alt:
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);
  	  printf ("/jump_past_alt//%d", mcnt);
	  break;

a756 4
	case endbuf2:
	  printf ("/endbuf2");
          break;

d769 1
a769 1
  unsigned char *buffer = (unsigned char*)bufp->buffer;
d776 2
a777 2
    char *start;
    char *end;
d779 1
a779 1
  int mcnt;
d781 3
a783 3
  char *p = start;
  char *pend = end;
  char *must = 0;
d790 1
a790 1
      switch ((enum regexpcode)*p++)
a798 1
	    max = mcnt;
a804 3
	  p += 2;
	  break;

d809 2
a810 4
	case casefold_on:
	case casefold_off:
	  return 0;		/* should not check must_string */

a822 3
	case endbuf2:
        case push_dummy_failure:
	case stop_paren:
d829 1
a829 1
	  mcnt = EXTRACT_UNSIGNED_AND_INCR(p);
d831 2
a832 1
	    p += 4;
a853 2
	case start_nowidth:
	case stop_nowidth:
d913 1
a913 1
    char *fixup_alt_jump = 0;
d932 1
a932 1
    /* Address of beginning of regexp, or inside of last (.  */
a935 4
    /* Place in the uncompiled pattern (i.e., the {) to
       which to go back if the interval is invalid.  */
    char *beg_interval;

d942 2
a943 2
    /* Stack of information saved by ( and restored by ).
       Five stack elements are pushed by each (:
d945 1
a945 1
       Second, the value of fixup_alt_jump.
d950 4
a953 4
    size_t *stackb = RE_TALLOC(40, size_t);
    size_t *stackp = stackb;
    size_t *stacke = stackb + 40;
    size_t *stackt;
d955 1
a955 1
    /* Counts ('s as they are encountered.  Remembered for the matching ),
a959 1

a960 2
    int had_mbchar = 0;
    int had_char_class = 0;
d962 2
a963 1
    int options = bufp->options;
a965 3
    bufp->must = 0;
    bufp->must_skip = 0;
    bufp->stclass = 0;
d970 9
a978 8
    if (bufp->allocated == 0) {
      bufp->allocated = INIT_BUF_SIZE;
      if (bufp->buffer)
	/* EXTEND_BUFFER loses when bufp->allocated is 0.  */
	bufp->buffer = (char*)xrealloc (bufp->buffer, INIT_BUF_SIZE);
      else
	/* Caller did not allocate a buffer.  Do it for them.  */
	bufp->buffer = (char*)xmalloc(INIT_BUF_SIZE);
d983 2
a984 1
    while (p != pend) {
d991 1
a991 1
	    p0 = p;
d994 10
a1003 2

	    while (p0 != pend)
d1005 8
a1012 5
		if (*p0 == '\\' && p0 + 1 != pend
		    && (p0[1] == 'b' || p0[1] == 'B'))
		  p0 += 2;
		else
		  break;
d1017 8
a1024 3
	    if (p0 == pend || *p0 == '\n'
		|| *p0 == ')'
		|| *p0 == '|')
d1035 1
a1035 1
          if (laststart)
d1037 2
a1038 1
          if (laststart && p - 2 >= pattern && p[-2] != '\n')
d1040 12
a1051 1
	  BUFPUSH(begline);
d1056 2
d1061 4
a1064 1
	    goto invalid_pattern;
d1137 2
a1138 2
	  while ((b - bufp->buffer + 9 + (1 << BYTEWIDTH) / BYTEWIDTH)
		 > bufp->allocated)
d1155 4
a1158 2
	  had_mbchar = 0;
	  had_char_class = 0;
d1168 1
a1168 1
		size = (1 << BYTEWIDTH) / BYTEWIDTH + 2 + size*8 + 8;
d1176 11
a1186 9
		if (p == p0 + 1) {
		  if (p == pend)
		    goto invalid_pattern;
		}
		else 
		  /* Stop if this isn't merely a ] inside a bracket
		     expression, but rather the end of a bracket
		     expression.  */
		  break;
a1187 4
	      /* Look ahead to see if it's a range when the last thing
		 was a character class.  */
	      if (had_char_class && c == '-' && *p != ']')
		  goto invalid_pattern;
d1189 2
a1190 2
		PATFETCH_MBC(c);
		had_mbchar++;
d1195 8
a1202 10
		PATFETCH(c);
		switch (c) {
		case 'w':
		  for (c = 0; c < (1 << BYTEWIDTH); c++) {
		    if (SYNTAX(c) == Sword ||
			(!current_mbctype && SYNTAX(c) == Sword2))
		      SET_LIST_BIT(c);
		  }
		  last = -1;
		  continue;
d1204 9
a1212 11
		case 'W':
		  for (c = 0; c < (1 << BYTEWIDTH); c++) {
		    if (SYNTAX(c) != Sword &&
			(current_mbctype || SYNTAX(c) != Sword2))
		      SET_LIST_BIT(c);
		  }
		  if (current_mbctype) {
		    set_list_bits(0x0, 0xffffffff, b);
		  }
		  last = -1;
		  continue;
d1214 6
a1219 16
		case 's':
		  for (c = 0; c < 256; c++)
		    if (ISSPACE(c))
		      SET_LIST_BIT(c);
		  last = -1;
		  continue;

		case 'S':
		  for (c = 0; c < 256; c++)
		    if (!ISSPACE(c))
		      SET_LIST_BIT(c);
		  if (current_mbctype) {
		    set_list_bits(0, 0xffffffff, b);
		  }
		  last = -1;
		  continue;
d1221 9
a1229 15
		case 'd':
		  for (c = '0'; c <= '9'; c++)
		    SET_LIST_BIT(c);
		  last = -1;
		  continue;

		case 'D':
		  for (c = 0; c < 256; c++)
		    if (!ISDIGIT(c))
		      SET_LIST_BIT(c);
		  if (current_mbctype) {
		    set_list_bits(0, 0xffffffff, b);
		  }
		  last = -1;
		  continue;
d1231 5
a1235 4
		case 'x':
		  c = scan_hex(p, 2, &numlen);
		  p += numlen;
		  break;
d1237 9
a1245 6
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
		  PATUNFETCH;
		  c = scan_oct(p, 3, &numlen);
		  p += numlen;
		  break;
d1247 22
a1268 4
		default:
		  if (ismbchar(c)) {
		    PATFETCH_MBC(c);
		    had_mbchar++;
a1269 2
		  break;
		}
d1274 2
a1275 2
		if (last > c)
		  goto invalid_pattern;
d1277 12
a1288 12
		range = 0;
		if (had_mbchar == 0) {
		  for (;last<=c;last++)
		    SET_LIST_BIT(last);
		}
		else if (had_mbchar == 2) {
		  set_list_bits(last, c, b);
		}
		else {
		  /* restriction: range between sbc and mbc */
		  goto invalid_pattern;
		}
d1291 4
a1294 78
		last = c;
		PATFETCH(c1);
		range = 1;
		goto range_retry;
	      }
	      else if (c == '[' && *p == ':') {
		/* Leave room for the null.  */
		char str[CHAR_CLASS_MAX_LENGTH + 1];

		PATFETCH_RAW (c);
		c1 = 0;

		/* If pattern is `[[:'.  */
		if (p == pend) 
		  goto invalid_pattern;

		for (;;) {
		  PATFETCH (c);
		  if (c == ':' || c == ']' || p == pend
		      || c1 == CHAR_CLASS_MAX_LENGTH)
		    break;
		  str[c1++] = c;
		}
		str[c1] = '\0';

		/* If isn't a word bracketed by `[:' and:`]':
		   undo the ending character, the letters, and leave 
		   the leading `:' and `[' (but set bits for them).  */
		if (c == ':' && *p == ']') {
		  int ch;
		  char is_alnum = STREQ(str, "alnum");
		  char is_alpha = STREQ(str, "alpha");
		  char is_blank = STREQ(str, "blank");
		  char is_cntrl = STREQ(str, "cntrl");
		  char is_digit = STREQ(str, "digit");
		  char is_graph = STREQ(str, "graph");
		  char is_lower = STREQ(str, "lower");
		  char is_print = STREQ(str, "print");
		  char is_punct = STREQ(str, "punct");
		  char is_space = STREQ(str, "space");
		  char is_upper = STREQ(str, "upper");
		  char is_xdigit = STREQ(str, "xdigit");

		  if (!IS_CHAR_CLASS (str))
		    goto invalid_pattern;

		  /* Throw away the ] at the end of the character class.  */
		  PATFETCH (c);

		  if (p == pend) 
		    goto invalid_pattern;

		  for (ch = 0; ch < 1 << BYTEWIDTH; ch++) {
		    if (   (is_alnum  && ISALNUM(ch))
			|| (is_alpha  && ISALPHA(ch))
			|| (is_blank  && ISBLANK(ch))
			|| (is_cntrl  && ISCNTRL(ch))
			|| (is_digit  && ISDIGIT(ch))
			|| (is_graph  && ISGRAPH(ch))
			|| (is_lower  && ISLOWER(ch))
			|| (is_print  && ISPRINT(ch))
			|| (is_punct  && ISPUNCT(ch))
			|| (is_space  && ISSPACE(ch))
			|| (is_upper  && ISUPPER(ch))
			|| (is_xdigit && ISXDIGIT(ch)))
		      SET_LIST_BIT (ch);
		  }
		  had_char_class = 1;
		}
		else {
		  c1++;
		  while (c1--)    
		    PATUNFETCH;
		  SET_LIST_BIT(translate?translate['[']:'[');
		  SET_LIST_BIT(translate?translate[':']:':');
		  had_char_class = 0;
		  last = ':';
		}
d1296 1
a1296 1
	      else if (had_mbchar == 0)
d1299 1
a1299 2
		set_list_bits(c, c, b);
	      had_mbchar = 0;
d1304 1
a1304 1
          while ((int)b[-1] > 0 && b[b[-1] - 1] == 0) 
d1308 2
a1309 2
		    2 + EXTRACT_UNSIGNED (&b[(1 << BYTEWIDTH) / BYTEWIDTH])*8);
	  b += b[-1] + 2 + EXTRACT_UNSIGNED (&b[b[-1]])*8;
d1315 10
a1324 35
	    int negative = 0;
	    PATFETCH_RAW(c);
	    switch (c) {
	      case 'x': case 'i': case '-':
		for (;;) {
		  switch (c) {
		  case '-':
		    negative = 1;
		    break;

		  case ':':
		  case ')':
		    break;

		  case 'x':
		    if (negative)
		      options &= ~RE_OPTION_EXTENDED;
		    else
		      options |= RE_OPTION_EXTENDED;
		    break;
		  case 'i':
		    if (negative) {
		      if (options&RE_OPTION_IGNORECASE) {
			options &= ~RE_OPTION_IGNORECASE;
			BUFPUSH(casefold_off);
		      }
		    }
		    else if (!(options&RE_OPTION_IGNORECASE)) {
		      options |= RE_OPTION_IGNORECASE;
		      BUFPUSH(casefold_on);
		    }
		    break;

		  default:
		    FREE_AND_RETURN(stackb, "undefined (?...) inline option");
d1326 2
a1327 8
		  if (c == ')') {
		    c = '#';	/* read whole in-line options */
		    break;
		  }
		  if (c == ':') break;
		  PATFETCH_RAW(c);
		}
		break;
d1329 4
a1332 7
	      case '#':
		for (;;) {
		  PATFETCH(c);
		  if (c == ')') break;
		}
		c = '#';
		break;
d1334 3
a1336 8
	      case ':':
	      case '=':
	      case '!':
		break;

	      default:
		FREE_AND_RETURN(stackb, "undefined (?...) sequence");
	    }
d1343 1
a1343 1
	  if (stackp+8 >= stacke) {
d1358 1
a1358 1
	  *stackp++ = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
a1364 2
	      *stackp++ = b - bufp->buffer;
	      BUFPUSH(0);
a1383 1
	      pending_exact = 0;
d1388 1
a1388 2
	  *stackp++ = options;
	  fixup_alt_jump = 0;
d1394 7
a1400 28
	  if (stackp == stackb) 
	    FREE_AND_RETURN(stackb, "unmatched )");
	  if ((options ^ stackp[-1]) & RE_OPTION_IGNORECASE) {
	    BUFPUSH((options&RE_OPTION_IGNORECASE)?casefold_off:casefold_on);
	  }
	  pending_exact = 0;
	  if (fixup_alt_jump)
	  { /* Push a dummy failure point at the end of the
	       alternative for a possible future
	       `finalize_jump' to pop.  See comments at
	       `push_dummy_failure' in `re_match'.  */
	      BUFPUSH(push_dummy_failure);
                  
	      /* We allocated space for this jump when we assigned
		 to `fixup_alt_jump', in the `handle_alt' case below.  */
	      store_jump(fixup_alt_jump, jump, b);
	  }
          options = *--stackp;
          switch (c = *--stackp) {
            case '(':
              {
		char *loc = bufp->buffer + *--stackp;
		*loc = regnum - stackp[-1];
		BUFPUSH(stop_memory);
		BUFPUSH(stackp[-1]);
		BUFPUSH(regnum - stackp[-1]);
		stackp--;
	      }
a1414 1
	      stackp--;
a1417 3
	      BUFPUSH(stop_paren);
	      break;

d1421 1
d1424 1
a1424 1
	  fixup_alt_jump = *stackp ? *stackp + bufp->buffer - 1 : 0;
d1432 1
a1432 1
	  GET_BUFFER_SPACE(3);
d1436 13
a1448 24
	  /* The alternative before this one has a jump after it
	     which gets executed if it gets matched.  Adjust that
	     jump so it will jump to this alternative's analogous
	     jump (put in below, which in turn will jump to the next
	     (if any) alternative's such jump, etc.).  The last such
	     jump jumps to the correct final destination.  A picture:
	     	_____ _____ 
	     	|   | |   |   
	     	|   v |   v 
	     	a | b   | c   

	     If we are at `b', then fixup_alt_jump right now points to a
	     three-byte space after `a'.  We'll put in the jump, set
	     fixup_alt_jump to right after `b', and leave behind three
	     bytes which we'll fill in when we get to after `c'.  */

	  if (fixup_alt_jump)
	    store_jump(fixup_alt_jump, jump_past_alt, b);

	  /* Mark and leave space for a jump after this alternative,
	     to be filled in later either by next alternative or
	     when know we're at the end of a series of alternatives.  */
	  fixup_alt_jump = b;
	  GET_BUFFER_SPACE(3);
d1457 1
a1457 1
	  if (!laststart || p == pend)
d1459 4
a1462 1
		goto normal_char;
d1464 20
d1485 2
a1486 2
	  beg_interval = p - 1;

d1492 2
d1495 1
a1495 2
	  else
	    /* Interval such as `{1}' => match exactly once. */
d1497 5
a1501 13

	  if (lower_bound < 0 || c != '}')
	    goto unfetch_interval;

	  if (lower_bound >= RE_DUP_MAX || upper_bound >= RE_DUP_MAX)
	    FREE_AND_RETURN(stackb, "too big quantifier in {,}");
	  if (upper_bound < 0) upper_bound = RE_DUP_MAX;
	  if (lower_bound > upper_bound)
	    FREE_AND_RETURN(stackb, "can't do {n,m} with n > m");

	  beg_interval = 0;
	  pending_exact = 0;

d1509 11
d1531 4
a1534 10
	  if (lower_bound == 1) {
	    if (upper_bound == 1) {
	      /* No need to repeat */
	      break;
	    }
	    if (upper_bound == RE_DUP_MAX) {
	      many_times_ok = 1;
	      zero_times_ok = 0;
	      goto repeat;
	    }
d1537 3
a1539 8
	  /* If upper_bound is zero, don't want to succeed at all; 
	     jump from laststart to b + 3, which will be the end of
	     the buffer after this jump is inserted.  */

	  if (upper_bound == 0) {
	    GET_BUFFER_SPACE(3);
	    insert_jump(jump, laststart, b + 3, b);
	    b += 3;
a1540 1
	  }
a1541 9
	  /* Otherwise, we have a nontrivial interval.  When
	     we're all done, the pattern will look like:
	     set_number_at <jump count> <upper bound>
	     set_number_at <succeed_n count> <lower bound>
	     succeed_n <after jump addr> <succed_n count>
	     <body of loop>
	     jump_n <succeed_n addr> <jump count>
	     (The upper bound and `jump_n' are omitted if
	     `upper_bound' is 1, though.)  */
d1544 1
a1544 1
	    unsigned nbytes = upper_bound == 1 ? 10 : 20;
d1546 1
a1546 1
	    GET_BUFFER_SPACE(nbytes);
d1552 1
a1552 1
	    insert_jump_n(succeed_n, laststart, b + (nbytes/2), 
d1560 1
d1573 1
a1573 2
		store_jump_n(b, greedy?jump_n:finalize_push_n, laststart + 5,
			     upper_bound - 1);
d1590 2
a1591 2
		insert_op_2(set_number_at, laststart, b, b - laststart,
			    upper_bound - 1);
d1593 5
d1599 1
a1602 9
	unfetch_interval:
	  /* If an invalid interval, match the characters as literals.  */
	  p = beg_interval;
	  beg_interval = 0;

	  /* normal_char and normal_backslash need `c'.  */
	  PATFETCH (c);	
	  goto normal_char;

d1615 2
a1616 2
	      while (b - bufp->buffer + 9 + (1 << BYTEWIDTH) / BYTEWIDTH
		     > bufp->allocated)
d1644 1
a1644 1
	      while ((int)b[-1] > 0 && b[b[-1] - 1] == 0) 
d1648 2
a1649 2
		  2 + EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH])*8);
	      b += b[-1] + 2 + EXTRACT_UNSIGNED(&b[b[-1]])*8;
a1682 4
	      BUFPUSH(endbuf2);
	      break;

	    case 'z':
d1688 1
a1688 1
	      had_mbchar = 0;
d1691 2
d1697 1
a1697 1
	      had_mbchar = 0;
d1700 2
d1714 1
a1714 1
		  had_mbchar = 0;
d1716 1
a1716 1
		  if (!ISDIGIT(c)) PATUNFETCH;
d1721 1
a1721 1
		      c = scan_oct(p_save, 3, &numlen) & 0xff;
d1724 2
d1740 1
d1745 1
a1745 20
	case '#':
	  if (options & RE_OPTION_EXTENDED)
	    {
	      while (p != pend) {
		PATFETCH(c);
		if (c == '\n') break;
	      }
	      break;
	    }
	  goto normal_char;

	case ' ':
	case '\t':
	case '\f':
	case '\r':
	case '\n':
	  if (options & RE_OPTION_EXTENDED)
	    break;

	default:
d1747 1
a1747 1
	  had_mbchar = 0;
d1749 5
a1753 2
	    had_mbchar = 0;
	    c1 = p - pattern;
d1760 9
a1768 8
	      || *p == '{') {
	    laststart = b;
	    BUFPUSH(exactn);
	    pending_exact = b;
	    BUFPUSH(0);
	  }
	  if (!had_mbchar && c > 0x7f) {
	    BUFPUSH(0xff);
a1772 8
	  if (had_mbchar) {
	    int len = ismbchar(c);
	    while (len--) {
	      PATFETCH_RAW(c);
	      BUFPUSH(c);
	      (*pending_exact)++;
	    }
	  }
d1776 2
a1777 2
  if (fixup_alt_jump)
    store_jump(fixup_alt_jump, jump, b);
d1779 1
a1779 29
  if (stackp != stackb)
    FREE_AND_RETURN(stackb, "unmatched (");

  /* set optimize flags */
  laststart = bufp->buffer;
  if (laststart != b) {
    if (*laststart == start_memory) laststart += 3;
    if (*laststart == dummy_failure_jump) laststart += 3;
    else if (*laststart == try_next) laststart += 3;
    if (*laststart == on_failure_jump) {
      int mcnt;

      laststart++;
      EXTRACT_NUMBER_AND_INCR(mcnt, laststart);
      if (mcnt == 4 && *laststart == anychar) {
	bufp->options |= RE_OPTIMIZE_ANCHOR;
      }
      else if (*laststart == charset || *laststart == charset_not) {
	p0 = laststart;
	mcnt = *++p0 ;
	p0 += mcnt+1;
	mcnt = EXTRACT_UNSIGNED_AND_INCR(p0);
	p0 += 8*mcnt;
	if (*p0 == maybe_finalize_jump) {
	  bufp->stclass = laststart;
	}
      }
    }
  }
d1783 2
a1784 15
  laststart = bufp->buffer;
  if (laststart != b) {
    if (*laststart == start_memory) laststart += 3;
    if (*laststart == exactn) {
      bufp->options |= RE_OPTIMIZE_EXACTN;
      bufp->must = laststart+1;
    }
  }
  else {
    bufp->must = calculate_must_string(bufp->buffer, b);
  }
  if (current_mbctype == MBCTYPE_SJIS) bufp->options |= RE_OPTIMIZE_NO_BM;
  else if (bufp->must) {
    int i;
    int len = (unsigned char)bufp->must[0];
d1786 2
a1787 16
    for (i=1; i<len; i++) {
      if ((unsigned char)bufp->must[i] == 0xff ||
	  (current_mbctype && ismbchar(bufp->must[i]))) {
	bufp->options |= RE_OPTIMIZE_NO_BM;
	break;
      }
    }
    if (!(bufp->options & RE_OPTIMIZE_NO_BM)) {
      bufp->must_skip = (int *) xmalloc((1 << BYTEWIDTH)*sizeof(int));
      bm_init_skip(bufp->must_skip, bufp->must+1,
		   (unsigned char)bufp->must[0],
		   MAY_TRANSLATE()?translate:0);
    }
  }

  FREE_AND_RETURN(stackb, 0);
d1792 6
a1810 9
void
re_free_pattern(bufp)
    struct re_pattern_buffer *bufp;
{
    free(bufp->buffer);
    free(bufp->fastmap);
    if (bufp->must_skip) free(bufp->must_skip);
    free(bufp);
}
d1936 1
a1936 1
slow_match(little, lend, big, bend, translate)
d1945 4
a1948 2
    if (c == 0xff)
      c = *little++;
d1956 1
a1956 1
slow_search(little, llen, big, blen, translate)
a1962 1
  unsigned char *bsave = big;
d1967 3
d1972 1
a1972 1
    c = little[1];
d1989 1
a1989 1
	if (ismbchar(*big)) big+=ismbchar(*big);
d1997 1
a1997 1
	if (ismbchar(*big)) big+=ismbchar(*big);
d2002 2
a2003 2
    if (slow_match(little, little+llen, big, bend, translate))
      return big - bsave;
d2005 1
a2005 1
    if (ismbchar(*big)) big+=ismbchar(*big);
d2008 1
a2008 25
  return -1;
}

static void
bm_init_skip(skip, pat, m, translate)
    int *skip;
    unsigned char *pat;
    int m;
    char *translate;
{
    int j, c;

    for (c=0; c<256; c++) {
	skip[c] = m;
    }
    if (translate) {
      for (j=0; j<m-1; j++) {
	skip[translate[pat[j]]] = m-1-j;
      }
    }
    else {
      for (j=0; j<m-1; j++) {
	skip[pat[j]] = m-1-j;
      }
    }
a2010 39
static int
bm_search(little, llen, big, blen, skip, translate)
     unsigned char *little;
     int llen;
     unsigned char *big;
     int blen;
     int *skip;
     unsigned char *translate;
{
  int i, j, k;

  i = llen-1;
  if (translate) {
    while (i < blen) {
      k = i;
      j = llen-1;
      while (j >= 0 && translate[big[k]] == translate[little[j]]) {
	k--;
	j--;
      }
      if (j < 0) return k+1;

      i += skip[translate[big[i]]];
    }
    return -1;
  }
  while (i < blen) {
    k = i;
    j = llen-1;
    while (j >= 0 && big[k] == little[j]) {
      k--;
      j--;
    }
    if (j < 0) return k+1;

    i += skip[big[i]];
  }
  return -1;
}
d2024 1
a2024 1
  unsigned char *pattern = (unsigned char*)bufp->buffer;
d2030 1
a2035 1
  int options = bufp->options;
d2050 1
a2050 1
      switch ((int)((enum regexpcode)*p++))
d2057 4
a2060 4
	    if (TRANSLATE_P())
	      fastmap[translate[p[2]]] = 2;
	    else
	      fastmap[p[2]] = 2;
d2062 1
a2062 1
	  else if (TRANSLATE_P())
a2070 1
	case endbuf2:
a2075 8
        case push_dummy_failure:
	case stop_paren:
	  continue;

	case casefold_on:
	  bufp->options |= RE_MAY_IGNORECASE;
	case casefold_off:
	  options ^= RE_OPTION_IGNORECASE;
d2079 1
a2079 1
	  if (TRANSLATE_P())
a2091 1
        case jump_past_alt:
d2104 4
a2107 5
          if ((enum regexpcode)*p != on_failure_jump
	      && (enum regexpcode)*p != try_next
	      && (enum regexpcode)*p != succeed_n
	      && (enum regexpcode)*p != finalize_push
	      && (enum regexpcode)*p != finalize_push_n)
d2165 1
a2165 1
	  p += 2;
d2184 1
a2184 1
	  for (j = 0; j < 0x80; j++) {
a2186 17
	  }
	  switch (current_mbctype) {
	  case MBCTYPE_ASCII:
	    for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	      if (SYNTAX(j) == Sword2)
		fastmap[j] = 1;
	    }
	    break;
	  case MBCTYPE_EUC:
	  case MBCTYPE_SJIS:
	  case MBCTYPE_UTF8:
	    for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	      if (re_mbctab[j])
		fastmap[j] = 1;
	    }
	    break;
	  }
d2193 2
a2194 16
	  switch (current_mbctype) {
	  case MBCTYPE_ASCII:
	    for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	      if (SYNTAX(j) != Sword2)
		fastmap[j] = 1;
	    }
	    break;
	  case MBCTYPE_EUC:
	  case MBCTYPE_SJIS:
	  case MBCTYPE_UTF8:
	    for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	      if (!re_mbctab[j])
		fastmap[j] = 1;
	    }
	    break;
	  }
d2203 4
a2206 3
		if (TRANSLATE_P())
		  j = translate[j];
		fastmap[j] = (j>0x7f?2:1);
d2210 1
a2210 1
	    unsigned int c, beg, end;
d2215 17
a2231 11
	      c = EXTRACT_MBC(&p[j*8]);
	      beg = WC2MBC1ST(c);
	      c = EXTRACT_MBC(&p[j*8+4]);
	      end = WC2MBC1ST(c);
	      /* set bits for 1st bytes of multi-byte chars.  */
	      while (beg <= end) {
		/* NOTE: Charset for multi-byte chars might contain
		   single-byte chars.  We must reject them. */
		if (ismbchar(beg))
		  fastmap[beg] = 1;
		beg++;
a2258 5
	  if (current_mbctype) {
	    for (j = 0x80; j < (1 << BYTEWIDTH); j++)
	      if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
		fastmap[j] = 2;
	  }
d2261 1
a2261 1
	    unsigned int c, beg, end;
d2266 3
a2268 4
	      for (j = 0x80; j < (1 << BYTEWIDTH); j++)
		if (ismbchar(j))
		  fastmap[j] = 1;
	      break;
d2271 10
a2280 6
	      int cc = EXTRACT_MBC(&p[j*8]);
	      beg = WC2MBC1ST(cc);
	      while (c < beg) {
		if (ismbchar(c))
		  fastmap[c] = 1;
		c++;
a2281 3

	      cc = EXTRACT_MBC(&p[j*8+4]);
	      c = WC2MBC1ST(cc) + 1;
a2282 4

	    for (j = c; j < (1 << BYTEWIDTH); j++)
	      if (ismbchar(j))
		fastmap[j] = 1;
d2319 1
a2319 1
     size_t size, startpos, range;
d2323 1
a2329 5
  /* Update the fastmap now if not correct already.  */
  if (fastmap && !bufp->fastmap_accurate) {
      re_compile_fastmap(bufp);
  }

d2338 2
a2339 3
	else if (re_match(bufp, string, size, 0, regs) >= 0)
	  return 0;
	return -1;
d2344 4
d2355 7
a2361 2
  if (bufp->options & RE_OPTIMIZE_ANCHOR) {
    anchor = 1;
d2363 4
a2366 27

  if (bufp->must) {
    int len = ((unsigned char*)bufp->must)[0];
    int pos, pbeg, pend;

    pbeg = startpos;
    pend = startpos + range;
    if (pbeg > pend) {		/* swap pbeg,pend */
      pos = pend; pend = pbeg; pbeg = pos;
    }
    if (pend > size) pend = size;
    if (bufp->options & RE_OPTIMIZE_NO_BM) {
      pos = slow_search(bufp->must+1, len,
			string+pbeg, pend-pbeg,
			MAY_TRANSLATE()?translate:0);
    }
    else {
      pos = bm_search(bufp->must+1, len,
		      string+pbeg, pend-pbeg,
		      bufp->must_skip,
		      MAY_TRANSLATE()?translate:0);
    }
    if (pos == -1) return -1;
    if (range > 0 && (bufp->options & RE_OPTIMIZE_EXACTN)) {
      startpos += pos;
      range -= pos;
    }
d2385 1
a2385 1
	      p = (unsigned char*)string+startpos;
d2398 1
a2398 1
		  if (fastmap[MAY_TRANSLATE() ? translate[c] : c])
d2410 1
a2410 1
	      if (MAY_TRANSLATE() ? !fastmap[translate[c]] : !fastmap[c])
d2415 3
a2417 2
      if (startpos > size) return -1;
      if (anchor && size > 0 && startpos == size) return -1;
d2420 1
a2420 1
	      (bufp->can_be_null && size > 0
d2431 1
a2431 1
#ifdef C_ALLOCA
d2433 1
a2433 1
#endif /* C_ALLOCA */
a2435 33
      if (range > 0) {
	if (anchor && startpos < size && startpos > 0 && string[startpos-1] != '\n') {
	  while (range > 0 && string[startpos] != '\n') {
	    range--;
	    startpos++;
	  }
	}
	else if (fastmap && (bufp->stclass)) {
	  register unsigned char *p;
	  unsigned int c;
	  int irange = range;

	  p = (unsigned char*)string+startpos;
	  while (range > 0) {
	    c = *p++;
	    if (ismbchar(c) && fastmap[c] != 2) {
	      MBC2WC(c, p);
	    }
	    else if (MAY_TRANSLATE())
	      c = translate[c];
	    if (*bufp->stclass == charset) {
	      if (!is_in_list(c, bufp->stclass+1)) break;
	    }
	    else {
	      if (is_in_list(c, bufp->stclass+1)) break;
	    }
	    range--;
	    if (c > 256) range--;
	  }
	  startpos += irange - range;
	}
      }

d2443 1
a2443 1
	  range-=ismbchar(*d), startpos+=ismbchar(*d);
d2486 1
a2486 1
typedef union
d2488 6
a2493 17
  unsigned char *word;
  struct
  {
      /* This field is one if this group can match the empty string,
         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
#define MATCH_NULL_UNSET_VALUE 3
    unsigned match_null_string_p : 2;
    unsigned is_active : 1;
    unsigned matched_something : 1;
    unsigned ever_matched_something : 1;
  } bits;
} register_info_type;

#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
#define IS_ACTIVE(R)  ((R).bits.is_active)
#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
d2499 1
a2501 3
/* Individual items aside from the registers.  */
#define NUM_NONREG_ITEMS 3

d2505 3
a2507 1
#define MAX_NUM_FAILURE_ITEMS   (num_regs * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
d2510 2
a2511 1
#define NUM_FAILURE_ITEMS  (last_used_reg * NUM_REG_ITEMS + NUM_REG_ITEMS)
d2518 1
a2518 1
  do {									\
d2524 1
a2524 1
      if (!REG_UNSET(regstart[last_used_reg]))				\
d2531 1
a2531 1
	/* if (len > re_max_failures * MAX_NUM_FAILURE_ITEMS)		\
d2535 1
a2535 1
	  }*/								\
d2546 1
a2546 1
        *stackp++ = reg_info[this_reg].word;				\
d2550 1
a2550 1
    *stackp++ = (unsigned char*)last_used_reg;				\
d2554 2
a2555 2
    *stackp++ = (unsigned char*)0; /* non-greedy flag */		\
  } while(0)
d2561 1
a2561 1
  do {									\
d2563 2
a2564 2
    stackp -= NUM_NONREG_ITEMS;	/* Remove failure points (and flag). */	\
    temp = (int)*--stackp;	/* How many regs pushed.  */	        \
d2567 1
a2567 5
  } while(0)

/* Registers are set to a sentinel when they haven't yet matched.  */
#define REG_UNSET_VALUE ((unsigned char*)-1)
#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
d2575 1
a2575 1
  do { unsigned this_reg;						\
d2579 1
a2579 3
          MATCHED_SOMETHING(reg_info[this_reg])				\
            = EVER_MATCHED_SOMETHING (reg_info[this_reg])		\
            = 1;							\
d2583 1
a2583 1
  } while(0)
d2586 4
a2589 1
#define AT_STRINGS_END(d)  (d == dend)
d2597 1
a2597 4
#define IS_A_LETTER(d) (SYNTAX(*(d)) == Sword ||			\
			(current_mbctype ?				\
			 re_mbctab[*(d)] == 1 :				\
			 SYNTAX(*(d)) == Sword2))
d2602 1
a2602 1
    unsigned int num_regs;
d2643 1
a2643 1
     size_t size, pos;
d2646 1
a2646 2
  register unsigned char *p = (unsigned char*)bufp->buffer;
  unsigned char *p1;
d2653 1
a2653 1
  unsigned char *string = (unsigned char*)string_arg;
d2657 2
a2658 1
  int options = bufp->options;
a2685 8
  /* If a group that's operated upon by a repetition operator fails to
     match anything, then the register for its start will need to be
     restored because it will have been set to wherever in the string we
     are when we last see its open-group operator.  Similarly for a
     register's end.  */
  unsigned char **old_regstart = RE_TALLOC(num_regs, unsigned char*);
  unsigned char **old_regend = RE_TALLOC(num_regs, unsigned char*);

d2693 1
a2693 1
  register_info_type *reg_info = RE_TALLOC(num_regs, register_info_type);
d2718 1
a2718 1
     ( or ( and ) or ) has been seen for. Also set all registers to
d2722 3
a2724 10
    regstart[mcnt] = regend[mcnt]
      = old_regstart[mcnt] = old_regend[mcnt]
      = best_regstart[mcnt] = best_regend[mcnt] = REG_UNSET_VALUE;
#ifdef __CHECKER__
    reg_info[mcnt].word = 0;
#endif
    REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
    IS_ACTIVE (reg_info[mcnt]) = 0;
    MATCHED_SOMETHING (reg_info[mcnt]) = 0;
    EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
d2750 1
a2750 1
	      p - (unsigned char*)bufp->buffer,
d2753 1
a2759 2
	      while (stackp != stackb && (int)stackp[-1] == 1)
		POP_FAILURE_POINT();
d2762 1
a2762 1
		  /* More failure points to try.  */
d2801 1
a2801 1
		  if (REG_UNSET(regend[mcnt]))
d2823 2
a2824 2
	/* ( [or `(', as appropriate] is represented by start_memory,
           ) by stop_memory.  Both of those commands are followed by
d2826 1
a2826 1
           within the ( and ) is recorded under that number.  */
a2827 14
          /* Find out if this group can match the empty string.  */
	  p1 = p;		/* To send to group_match_null_string_p.  */
          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
            REG_MATCH_NULL_STRING_P (reg_info[*p]) 
              = group_match_null_string_p (&p1, pend, reg_info);

          /* Save the position in the string where we were the last time
             we were at this open-group operator in case the group is
             operated upon by a repetition operator, e.g., with `(a*)*b'
             against `ab'; then we want to ignore where we are now in
             the string in case this attempt to match fails.  */
          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
                             : regstart[*p];
d2831 1
a2831 1
          p += 2;
a2834 9
          /* We need to save the string position the last time we were at
             this close-group operator in case the group is operated
             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
             against `aba'; then we want to ignore where we are now in
             the string in case this attempt to match fails.  */
          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
			   : regend[*p];

d2840 3
a2842 3
          if ((p + 1) != pend &&
	      (! MATCHED_SOMETHING(reg_info[*p])
	       || (enum regexpcode)p[-3] == start_memory))
d2844 1
a2844 1
	      p1 = p + 2;
d2846 1
a2846 1
              switch (*p1++)
d2849 1
a2849 1
		  case finalize_push_n:
d2854 3
a2856 1
                    EXTRACT_NUMBER_AND_INCR(mcnt, p1);
d2859 1
a2859 1
	      p1 += mcnt;
d2865 1
a2865 2
	      if (mcnt < 0 && (enum regexpcode)*p1 == on_failure_jump
                  && (enum regexpcode)p1[3] == start_memory && p1[4] == *p)
d2867 2
a2868 29
                  /* If this group ever matched anything, then restore
                     what its registers were before trying this last
                     failed match, e.g., with `(a*)*b' against `ab' for
                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
                     against `aba' for regend[3].
                     
                     Also restore the registers for inner groups for,
                     e.g., `((a*)(b*))*' against `aba' (register 3 would
                     otherwise get trashed).  */
                     
                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
		    {
		      unsigned r; 
        
                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
                      
		      /* Restore this and inner groups' (if any) registers.  */
                      for (r = *p; r < *p + *(p + 1); r++)
                        {
                          regstart[r] = old_regstart[r];

                          /* xx why this test?  */
                          if ((int)old_regend[r] >= (int)regstart[r])
                            regend[r] = old_regend[r];
                        }     
                    }
		  p1++;
                  EXTRACT_NUMBER_AND_INCR(mcnt, p1);
                  PUSH_FAILURE_POINT(p1 + mcnt, d);
d2872 1
a2872 1
          p += 2;
a2874 3
	case stop_paren:
	  break;

a2881 2
	    if (IS_ACTIVE(reg_info[regno])) break;

a2883 1
	    if (REG_UNSET(d2)) break;
a2890 1
	    if (REG_UNSET(dend2)) break;
d2909 3
a2911 3
		if ((options & RE_OPTION_IGNORECASE) 
                    ? memcmp_translate(d, d2, mcnt) 
                    : memcmp((char*)d, (char*)d2, mcnt))
d2941 1
a2941 1
	    if (d + mbclen(*d) > dend || d[1] == '\n' || d[1] == '\0')
d2944 1
a2944 1
	    d += mbclen(*d);
d2947 3
a2949 1
	  if (((TRANSLATE_P()) ? translate[*d] : *d) == '\n')
d2959 2
a2960 3
	    int part;	    /* 2 if matched part of mbc */
	    unsigned char *dsave = d + 1;
	    int cc, c;
d2963 1
a2963 1
	    cc = c = (unsigned char)*d++;
d2965 3
a2967 2
	      if (d + ismbchar(c) < dend) {
		MBC2WC(c, d);
d2970 2
a2971 2
	    else if (TRANSLATE_P())
	      cc = c = (unsigned char)translate[c];
d2973 1
a2973 1
	    part = not = is_in_list(c, p);
d2977 3
a2980 2

	    p += 1 + *p + 2 + EXTRACT_UNSIGNED(&p[1 + *p])*8;
d2983 3
a2985 1
	    if (part == 2) d = dsave;
d2991 1
a2991 1
	      || AT_STRINGS_BEG(d)
d2998 1
a2998 1
	  if (AT_STRINGS_END(d) || *d == '\n')
d3002 1
a3002 1
	/* Match at the very beginning of the string. */
d3008 1
a3008 1
	/* Match at the very end of the data. */
a3013 9
	/* Match at the very end of the data. */
        case endbuf2:
	  if (AT_STRINGS_END(d))
	    break;
	  /* .. or newline just before the end of the data. */
	  if (*d == '\n' && AT_STRINGS_END(d+1))
	    break;
          goto fail;

d3042 7
a3048 25

            /* Compare the beginning of the repeat with what in the
               pattern follows its end. If we can establish that there
               is nothing that they would both match, i.e., that we
               would have to backtrack because of (as in, e.g., `a*a')
               then we can change to pop_failure_jump, because we'll
               never have to backtrack.
               
               This is not true in the case of alternatives: in
               `(a|ab)*' we do need to backtrack to the `ab' alternative
               (e.g., if the string was `ab').  But instead of trying to
               detect that here, the alternative has put on a dummy
               failure point which is what we will end up popping.  */

	    /* Skip over open/close-group commands.  */
	    while (p2 + 2 < pend) {
	      if ((enum regexpcode)*p2 == stop_memory ||
		  (enum regexpcode)*p2 == start_memory)
		p2 += 3;	/* Skip over args, too.  */
	      else if ((enum regexpcode)*p2 == stop_paren)
		p2 += 1;
	      else
		break;
	    }

d3063 2
a3064 4
		    if (ismbchar(c)) {
		      unsigned char *pp = p2+3;
		      MBC2WC(c, pp);
		    }
a3100 5
        /* We need this opcode so we can detect where alternatives end
           in `group_match_null_string_p' et al.  */
        case jump_past_alt:
          goto nofinalize;

a3109 11
        /* At the end of an alternative, we need to push a dummy failure
           point in case we are followed by a `finalize_jump', because
           we don't want the failure point for the alternative to be
           popped.  For example, matching `(a|ab)*' against `aab'
           requires that we match the `ab' alternative.  */
        case push_dummy_failure:
          /* See comments just above at `dummy_failure_jump' about the
             two zeroes.  */
          PUSH_FAILURE_POINT(0, 0);
          break;

d3146 9
a3154 5
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
	  p1 = p + mcnt;
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
	  STORE_NUMBER(p1, mcnt);
	  continue;
d3173 2
a3174 2
          EXTRACT_NUMBER(mcnt, p + 2); 
         /* Originally, this is how many times we CAN jump.  */
a3175 2
	    int pos, i;

a3177 3
	    EXTRACT_NUMBER(pos, p);
	    EXTRACT_NUMBER(i, p+pos+5);
	    if (i > 0) goto nofinalize;
d3182 1
a3182 1
	    p += 2;		/* skip n */
a3193 8
        case casefold_on:
	  options |= RE_OPTION_IGNORECASE;
	  continue;

        case casefold_off:
	  options &= ~RE_OPTION_IGNORECASE;
	  continue;

d3195 1
a3195 9
	  if (AT_STRINGS_BEG(d)) {
	    if (IS_A_LETTER(d)) break;
	    else goto fail;
	  }
	  if (AT_STRINGS_BEG(d)) {
	    if (IS_A_LETTER(d-1)) break;
	    else goto fail;
	  }
	  if (IS_A_LETTER(d - 1) != IS_A_LETTER(d))
d3200 1
a3200 9
	  if (AT_STRINGS_BEG(d)) {
	    if (IS_A_LETTER(d)) goto fail;
	    else break;
	  }
	  if (AT_STRINGS_END(d)) {
	    if (IS_A_LETTER(d-1)) goto fail;
	    else break;
	  }
	  if (IS_A_LETTER(d - 1) != IS_A_LETTER(d))
d3227 2
a3228 2
	  if (ismbchar(*d) && d + ismbchar(*d) < dend)
	    d += ismbchar(*d);
d3239 1
a3239 1
          if (TRANSLATE_P())
d3250 1
a3250 1
			|| AT_STRINGS_END(d)
d3259 1
a3259 1
			|| AT_STRINGS_END(d)
d3284 2
a3285 2
      while (stackp != stackb && (int)stackp[-1] == 1)
	POP_FAILURE_POINT();
d3305 1
a3305 1
          last_used_reg = (long)*--stackp;
d3310 2
a3311 2
              regend[this_reg] = REG_UNSET_VALUE;
              regstart[this_reg] = REG_UNSET_VALUE;
d3319 1
a3319 1
              reg_info[this_reg].word = *--stackp;
d3323 1
a3323 42
          if (p < pend)
            {
              int is_a_jump_n = 0;
	      int failed_paren = 0;

	      p1 = p;
              /* If failed to a backwards jump that's part of a repetition
                 loop, need to pop this failure point and use the next one.  */
	    pop_loop:
              switch ((enum regexpcode)*p1) {
	      case stop_paren:
		failed_paren = 1;
		p1++;
		goto pop_loop;

	      case jump_n:
	      case finalize_push_n:
		is_a_jump_n = 1;
	      case maybe_finalize_jump:
	      case finalize_jump:
	      case finalize_push:
	      case jump:
		p1++;
		EXTRACT_NUMBER_AND_INCR (mcnt, p1);
		p1 += mcnt;

		if (p1 >= pend) break;
		if (( is_a_jump_n && (enum regexpcode)*p1 == succeed_n) ||
		    (!is_a_jump_n && (enum regexpcode)*p1 == on_failure_jump)) {
		  if (failed_paren) {
		    p1++;
		    EXTRACT_NUMBER_AND_INCR(mcnt, p1);
		    PUSH_FAILURE_POINT(p1 + mcnt, d);
		  }
		  goto fail;
		}
		break;
	      default:
                  /* do nothing */ ;
	      }
            }
        }
a3334 10
/* We are passed P pointing to a register number after a start_memory.
   
   Return true if the pattern up to the corresponding stop_memory can
   match the empty string, and false otherwise.
   
   If we find the matching stop_memory, sets P to point to one past its number.
   Otherwise, sets P to an undefined byte less than or equal to END.

   We don't handle duplicates properly (yet).  */

d3336 1
a3336 231
group_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  /* Point to after the args to the start_memory.  */
  unsigned char *p1 = *p + 2;
  
  while (p1 < end)
    {
      /* Skip over opcodes that can match nothing, and return true or
	 false, as appropriate, when we get to one that can't, or to the
         matching stop_memory.  */
      
      switch ((enum regexpcode)*p1)
        {
        /* Could be either a loop or a series of alternatives.  */
        case on_failure_jump:
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          
          /* If the next operation is not a jump backwards in the
	     pattern.  */

	  if (mcnt >= 0)
	    {
              /* Go through the on_failure_jumps of the alternatives,
                 seeing if any of the alternatives cannot match nothing.
                 The last alternative starts with only a jump,
                 whereas the rest start with on_failure_jump and end
                 with a jump, e.g., here is the pattern for `a|b|c':

                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
                 /exactn/1/c						

                 So, we have to first go through the first (n-1)
                 alternatives and then deal with the last one separately.  */


              /* Deal with the first (n-1) alternatives, which start
                 with an on_failure_jump (see above) that jumps to right
                 past a jump_past_alt.  */

              while ((enum regexpcode)p1[mcnt-3] == jump_past_alt)
                {
                  /* `mcnt' holds how many bytes long the alternative
                     is, including the ending `jump_past_alt' and
                     its number.  */

                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
				                      reg_info))
                    return 0;

                  /* Move to right after this alternative, including the
		     jump_past_alt.  */
                  p1 += mcnt;	

                  /* Break if it's the beginning of an n-th alternative
                     that doesn't begin with an on_failure_jump.  */
                  if ((enum regexpcode)*p1 != on_failure_jump)
                    break;
		
		  /* Still have to check that it's not an n-th
		     alternative that starts with an on_failure_jump.  */
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  if ((enum regexpcode)p1[mcnt-3] != jump_past_alt)
                    {
		      /* Get to the beginning of the n-th alternative.  */
                      p1 -= 3;
                      break;
                    }
                }

              /* Deal with the last alternative: go back and get number
                 of the `jump_past_alt' just before it.  `mcnt' contains
                 the length of the alternative.  */
              EXTRACT_NUMBER (mcnt, p1 - 2);
#if 0
              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
                return 0;
#endif
              p1 += mcnt;	/* Get past the n-th alternative.  */
            } /* if mcnt > 0 */
          break;

          
        case stop_memory:
          *p = p1 + 2;
          return 1;

        
        default: 
          if (!common_op_match_null_string_p (&p1, end, reg_info))
            return 0;
        }
    } /* while p1 < end */

  return 0;
} /* group_match_null_string_p */


/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
   It expects P to be the first byte of a single alternative and END one
   byte past the last. The alternative can contain groups.  */
   
static int
alt_match_null_string_p (p, end, reg_info)
    unsigned char *p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  unsigned char *p1 = p;
  
  while (p1 < end)
    {
      /* Skip over opcodes that can match nothing, and break when we get 
         to one that can't.  */
      
      switch ((enum regexpcode)*p1)
        {
	/* It's a loop.  */
        case on_failure_jump:
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
          break;
          
	default: 
          if (!common_op_match_null_string_p (&p1, end, reg_info))
            return 0;
        }
    }  /* while p1 < end */

  return 1;
} /* alt_match_null_string_p */


/* Deals with the ops common to group_match_null_string_p and
   alt_match_null_string_p.  
   
   Sets P to one after the op and its arguments, if any.  */

static int
common_op_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  int ret;
  int reg_no;
  unsigned char *p1 = *p;

  switch ((enum regexpcode)*p1++)
    {
    case unused:
    case begline:
    case endline:
    case begbuf:
    case endbuf:
    case endbuf2:
    case wordbeg:
    case wordend:
    case wordbound:
    case notwordbound:
#ifdef emacs
    case before_dot:
    case at_dot:
    case after_dot:
#endif
      break;

    case start_memory:
      reg_no = *p1;
      ret = group_match_null_string_p (&p1, end, reg_info);
      
      /* Have to set this here in case we're checking a group which
         contains a group and a back reference to it.  */

      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;

      if (!ret)
        return 0;
      break;
          
    /* If this is an optimized succeed_n for zero times, make the jump.  */
    case jump:
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
      if (mcnt >= 0)
        p1 += mcnt;
      else
        return 0;
      break;

    case succeed_n:
      /* Get to the number of times to succeed.  */
      p1 += 2;		
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);

      if (mcnt == 0)
        {
          p1 -= 4;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
        }
      else
        return 0;
      break;

    case duplicate: 
      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
        return 0;
      break;

    case set_number_at:
      p1 += 4;

    default:
      /* All other opcodes mean we cannot match the empty string.  */
      return 0;
  }

  *p = p1;
  return 1;
} /* common_op_match_null_string_p */


static int
memcmp_translate(s1, s2, len)
d3339 1
d3346 2
a3347 2
	if (c != *p2++) return 1;
	if (memcmp(p1, p2, ismbchar(c))) return 1;
a3387 105
}

/* Functions for multi-byte support.
   Created for grep multi-byte extension Jul., 1993 by t^2 (Takahiro Tanimoto)
   Last change: Jul. 9, 1993 by t^2  */
static const unsigned char mbctab_ascii[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

static const unsigned char mbctab_euc[] = { /* 0xA1-0xFE */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0
};

static const unsigned char mbctab_sjis[] = { /* 0x80-0x9f,0xE0-0xFF */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};

static const unsigned char mbctab_utf8[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 0, 0
};

const unsigned char *re_mbctab = mbctab_ascii;

void
re_mbcinit(mbctype)
     int mbctype;
{
  switch (mbctype) {
  case MBCTYPE_ASCII:
    re_mbctab = mbctab_ascii;
    current_mbctype = MBCTYPE_ASCII;
    break;
  case MBCTYPE_EUC:
    re_mbctab = mbctab_euc;
    current_mbctype = MBCTYPE_EUC;
    break;
  case MBCTYPE_SJIS:
    re_mbctab = mbctab_sjis;
    current_mbctype = MBCTYPE_SJIS;
    break;
  case MBCTYPE_UTF8:
    re_mbctab = mbctab_utf8;
    current_mbctype = MBCTYPE_UTF8;
    break;
  }
@


1.1.1.3.2.1
log
@990126
@
text
@d1025 1
a1025 1
     int size;
d1087 4
a1090 4
    int *stackb = RE_TALLOC(40, int);
    int *stackp = stackb;
    int *stacke = stackb + 40;
    int *stackt;
d2757 1
a2757 1
     int size, startpos, range;
d3148 1
a3148 1
     int size, pos;
@


1.1.1.3.2.2
log
@990201
@
text
@a1309 3
		  if (current_mbctype) {
		    set_list_bits(0x0, 0xffffffff, b);
		  }
d1319 3
d3090 2
a3091 2
#define AT_STRINGS_BEG(d)  ((d) == string)
#define AT_STRINGS_END(d)  ((d) == dend)
d3093 6
a3103 5
#define PREV_IS_A_LETTER(d) ((current_mbctype == MBCTYPE_SJIS)?		\
			     IS_A_LETTER((d)-(!AT_STRINGS_BEG((d)-1)&&	\
					      ismbchar((d)[-2])?2:1)):	\
			     ((d)[-1] >= 0x80 || IS_A_LETTER((d)-1)))

d3826 1
a3826 1
	    if (PREV_IS_A_LETTER(d)) break;
d3829 1
a3829 1
	  if (PREV_IS_A_LETTER(d) != IS_A_LETTER(d))
d3839 1
a3839 1
	    if (PREV_IS_A_LETTER(d)) goto fail;
d3842 1
a3842 1
	  if (PREV_IS_A_LETTER(d) != IS_A_LETTER(d))
d3847 1
a3847 1
	  if (IS_A_LETTER(d) && (AT_STRINGS_BEG(d) || !PREV_IS_A_LETTER(d)))
d3852 1
a3852 1
	  if (!AT_STRINGS_BEG(d) && PREV_IS_A_LETTER(d)
a3860 2
	  if (ismbchar(*d) && d + ismbchar(*d) < dend)
	    d += ismbchar(*d);
@


1.1.1.3.2.3
log
@990201
@
text
@d1311 1
a1311 1
		    set_list_bits(0x80, 0xffffffff, b);
d1337 1
a1337 1
		    set_list_bits(0x80, 0xffffffff, b);
d1353 1
a1353 1
		    set_list_bits(0x80, 0xffffffff, b);
@


1.1.1.3.2.4
log
@990203
@
text
@d403 1
a403 1
      c &= (1<<(BYTEWIDTH-2-n)) - 1;\
d405 1
a405 1
	c = c << 6 | *p++ & ((1<<6)-1);\
d505 2
a506 1
  do { if (p != pend) { 						\
d508 10
a517 9
	while (ISDIGIT(c)) { 						\
	  if (num < 0) 							\
	     num = 0; 							\
	  num = num * 10 + c - '0'; 					\
	  if (p == pend) 						\
	     break; 							\
	  PATFETCH(c); 							\
	} 								\
     } 									\
a1971 1
		  c1 = 0;
a2846 1
		  int len = ismbchar(c);
d2850 1
a2850 1
		  range -= len;
d3095 1
a3095 1
			 re_mbctab[*(d)] :				\
d3540 1
a3540 1
	      if (d + ismbchar(c) <= dend) {
@


1.1.1.3.2.5
log
@990205
@
text
@a1027 1
    char *nextp;
d2021 1
a2021 1
	    had_mbchar = 1;
a2024 1
	  nextp = p + ismbchar(c);
d2027 3
a2029 3
	      || *nextp == '+' || *nextp == '?'
	      || *nextp == '*' || *nextp == '^'
	      || *nextp == '{') {
d2640 1
a2640 1
		fastmap[j] = (j>0x7f?(ismbchar(j)?0:2):1);
d2849 2
a2850 3
		  p += len;
		  range -= len + 1;
		  c = *p;
d2854 1
a2854 1
		else {
d2857 1
a2857 2
		  range--;
		}
@


1.1.1.3.2.6
log
@*** empty log message ***
@
text
@d2072 1
a2072 10
	switch ((enum regexpcode)laststart[4]) {
	  case jump_n:
	  case finalize_jump:
	  case maybe_finalize_jump:
	  case jump:
	  case jump_past_alt:
	  case dummy_failure_jump:
	    bufp->options |= RE_OPTIMIZE_ANCHOR;
	    break;
	}
d3695 2
a3696 7
	  if (stackp[-2] == d) {
	    p = stackp[-3];
	    POP_FAILURE_POINT();
	    continue;
	  }
          POP_FAILURE_POINT(); 
	  /* Note fall through.  */
@


1.1.1.3.2.7
log
@990212
@
text
@a45 3
#ifdef RUBY_PLATFORM
# define RUBY
#endif
@


1.1.1.3.2.8
log
@990224
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 98 Free Software Foundation, Inc.
d4 4
a7 4
   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.
d9 1
a9 1
   The GNU C Library is distributed in the hope that it will be useful,
d11 2
a12 2
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.
d14 3
a16 4
   You should have received a copy of the GNU Library General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d20 7
a26 4
#include "config.h"
#ifdef RUBY_PLATFORM
# define RUBY
#endif
d35 3
a37 10
#ifndef PARAMS
# if defined __GNUC__ || (defined __STDC__ && __STDC__)
#  define PARAMS(args) args
# else
#  define PARAMS(args) ()
# endif  /* GCC.  */
#endif  /* Not PARAMS.  */

#if defined(STDC_HEADERS)
# include <stddef.h>
d39 4
a42 2
/* We need this for `regex.h', and perhaps for the Emacs include files.  */
# include <sys/types.h>
d45 3
a47 5
#if defined(STDC_HEADERS)
# include <stddef.h>
#else
/* We need this for `regex.h', and perhaps for the Emacs include files.  */
# include <sys/types.h>
d50 4
a53 19
#ifndef __STDC__
# define volatile
# ifdef __GNUC__
#  define const __const__
# else
#  define const
# endif
#endif

#ifdef HAVE_PROTOTYPES
# define _(args) args
#else
# define _(args) ()
#endif

void *xmalloc _((unsigned long));
void *xcalloc _((unsigned long,unsigned long));
void *xrealloc _((void*,unsigned long));
void free _((void*));
d135 10
a144 10
static void store_jump _((char*, int, char*));
static void insert_jump _((int, char*, char*, char*));
static void store_jump_n _((char*, int, char*, unsigned));
static void insert_jump_n _((int, char*, char*, char*, unsigned));
static void insert_op _((int, char*, char*));
static void insert_op_2 _((int, char*, char*, int, int));
static int memcmp_translate _((unsigned char*, unsigned char*, int));
static int alt_match_null_string_p();
static int common_op_match_null_string_p();
static int group_match_null_string_p();
d156 1
a156 1
static void init_syntax_once _((void));
d158 2
a159 2
static void init_regs _((struct re_registers*, unsigned int));
static void bm_init_skip _((int *, unsigned char*, int, char*));
a163 1
#ifdef RUBY
a164 1
#endif
d204 1
a204 10
   eliminate the && through constant folding."
   Solaris defines some of these symbols so we must undefine them first.  */

#undef ISASCII
#if defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
# define ISASCII(c) 1
#else
# define ISASCII(c) isascii(c)
#endif

d206 1
a206 1
# define ISBLANK(c) (ISASCII (c) && isblank (c))
d208 1
a208 1
# define ISBLANK(c) ((c) == ' ' || (c) == '\t')
d211 1
a211 1
# define ISGRAPH(c) (ISASCII (c) && isgraph (c))
d213 1
a213 17
# define ISGRAPH(c) (ISASCII (c) && isprint (c) && !isspace (c))
#endif

#undef ISPRINT
#define ISPRINT(c) (ISASCII (c) && isprint (c))
#define ISDIGIT(c) (ISASCII (c) && isdigit (c))
#define ISALNUM(c) (ISASCII (c) && isalnum (c))
#define ISALPHA(c) (ISASCII (c) && isalpha (c))
#define ISCNTRL(c) (ISASCII (c) && iscntrl (c))
#define ISLOWER(c) (ISASCII (c) && islower (c))
#define ISPUNCT(c) (ISASCII (c) && ispunct (c))
#define ISSPACE(c) (ISASCII (c) && isspace (c))
#define ISUPPER(c) (ISASCII (c) && isupper (c))
#define ISXDIGIT(c) (ISASCII (c) && isxdigit (c))

#ifndef NULL
# define NULL (void *)0
d216 10
a225 11
/* We remove any previous definition of `SIGN_EXTEND_CHAR',
   since ours (we hope) works properly with all combinations of
   machines, compilers, `char' and `unsigned char' argument types.
   (Per Bothner suggested the basic approach.)  */
#undef SIGN_EXTEND_CHAR
#if __STDC__
# define SIGN_EXTEND_CHAR(c) ((signed char) (c))
#else  /* not __STDC__ */
/* As in Harbison and Steele.  */
# define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
#endif
d327 8
d404 1
a404 1
      int n = mbclen(c) - 1;\
d419 1
a419 1
    if (p + mbclen(c) - 1 >= pend) goto end_of_pattern;\
d670 1
a670 1
      printf("(null)\n");
d680 1
a680 1
	  printf("/unused");
d685 1
a685 1
          printf("/exactn/%d", mcnt);
d696 1
a696 1
          printf("/start_memory/%d/%d", mcnt, *p++);
d701 1
a701 1
	  printf("/stop_memory/%d/%d", mcnt, *p++);
d705 1
a705 1
	  printf("/stop_paren");
d709 1
a709 1
	  printf("/casefold_on");
d713 1
a713 1
	  printf("/casefold_off");
d718 1
a718 1
	  printf("/start_nowidth//%d", mcnt);
d722 1
a722 1
	  printf("/stop_nowidth//");
d727 1
a727 1
	  printf("/pop_and_fail");
d731 1
a731 1
	  printf("/duplicate/%d", *p++);
d735 1
a735 1
	  printf("/anychar");
d743 2
a744 2
            printf("/charset%s",
		   (enum regexpcode)*(p - 1) == charset_not ? "_not" : "");
d771 1
a771 1
	  printf("/begline");
d775 1
a775 1
          printf("/endline");
d780 1
a780 1
  	  printf("/on_failure_jump//%d", mcnt);
d785 1
a785 1
  	  printf("/dummy_failure_jump//%d", mcnt);
d789 1
a789 1
          printf("/push_dummy_failure");
d794 1
a794 1
  	  printf("/finalize_jump//%d", mcnt);
d799 1
a799 1
  	  printf("/maybe_finalize_jump//%d", mcnt);
d804 1
a804 1
  	  printf("/jump_past_alt//%d", mcnt);
d809 1
a809 1
  	  printf("/jump//%d", mcnt);
d815 1
a815 1
 	  printf("/succeed_n//%d//%d", mcnt, mcnt2);
d821 1
a821 1
 	  printf("/jump_n//%d//%d", mcnt, mcnt2);
d827 1
a827 1
 	  printf("/set_number_at//%d//%d", mcnt, mcnt2);
d832 1
a832 1
  	  printf("/try_next//%d", mcnt);
d837 1
a837 1
  	  printf("/finalize_push//%d", mcnt);
d843 1
a843 1
 	  printf("/finalize_push_n//%d//%d", mcnt, mcnt2);
d847 1
a847 1
	  printf("/wordbound");
d851 1
a851 1
	  printf("/notwordbound");
d855 1
a855 1
	  printf("/wordbeg");
d859 1
a859 1
	  printf("/wordend");
d862 1
a862 1
	  printf("/wordchar");
d866 1
a866 1
	  printf("/notwordchar");
d870 1
a870 1
	  printf("/begbuf");
d874 1
a874 1
	  printf("/endbuf");
d878 1
a878 1
	  printf("/endbuf2");
d882 1
a882 1
          printf("?%d", *(p-1));
d885 1
a885 1
  printf("/\n");
d1272 1
a1272 2
	      if ((size = EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH]))
		  || current_mbctype) {
d2029 1
a2029 1
	  nextp = p + mbclen(c) - 1;
d2047 1
a2047 1
	    int len = mbclen(c) - 1;
d2333 1
a2333 1
	if (ismbchar(*big)) big+=mbclen(*big)-1;
d2341 1
a2341 1
	if (ismbchar(*big)) big+=mbclen(*big)-1;
d2349 1
a2349 1
    if (ismbchar(*big)) big+=mbclen(*big);
d2860 1
a2860 1
		  int len = mbclen(c) - 1;
d2948 1
a2948 2
	  int len = mbclen(*d) - 1;
	  range-=len, startpos+=len;
d2980 5
d2986 2
d3242 1
a3242 1
  fprintf(stderr, "Entering re_match(%s%s)\n", string1_arg, string2_arg);
d3556 1
a3556 1
	      if (d + mbclen(c) - 1 <= dend) {
d3881 2
a3882 2
	  if (ismbchar(*d) && d + mbclen(*d) - 1 < dend)
	    d += mbclen(*d) - 1;
d3891 2
a3892 2
	  if (ismbchar(*d) && d + mbclen(*d) - 1 < dend)
	    d += mbclen(*d) - 1;
d3920 5
a3924 3
		    int n;

		    if (c != (unsigned char)*p++)
a3925 6
		    for (n = mbclen(c) - 1; n > 0; n--)
		      if (!--mcnt	/* redundant check if pattern was
					   compiled properly. */
			  || AT_STRINGS_END(d)
			  || (unsigned char)*d++ != (unsigned char)*p++)
			goto fail;
a3947 1
#if 0
a3949 1
#endif
a4289 2
	int n;

d4291 1
a4291 3
	for (n = mbclen(c) - 1; n > 0; n--)
	  if (!--len || *p1++ != *p2++)
	    return 1;
@


1.1.1.3.2.9
log
@990225
@
text
@a19 3
/* removed gapped buffer support, multiple syntax support by matz <matz@@nts.co.jp> */
/* Perl5 extension added by matz <matz@@caelum.co.jp> */
/* UTF-8 extension added Jan 16 1999 by Yoshida Masato  <yoshidam@@tau.bekkoame.ne.jp> */
@


1.1.1.3.2.10
log
@990324
@
text
@d180 1
a180 1
static const unsigned char *translate = 0;
d182 1
a182 1
static void bm_init_skip _((int *, unsigned char*, int, const char*));
d215 1
a215 1
     const char *table;
d217 1
a217 1
  translate = (const unsigned char*)table;
d334 1
a334 1
    anychar,	 /* Matches any (more or less) one character excluding newlines.  */
a354 2
    posix_on,      /* Turn on POSIXified match (match with newlines). */
    posix_off,     /* Turn off POSIXified match. */
d676 11
a686 11
  unsigned short size;
  unsigned short i, j;
  int result = 0;

  size = *b++;
  if ((int)c / BYTEWIDTH < (int)size && b[c / BYTEWIDTH] & 1 << c % BYTEWIDTH) {
    return 2;
  }
  b += size + 2;
  size = EXTRACT_UNSIGNED(&b[-2]);
  if (size == 0) return 0;
d688 2
a689 2
  for (i = 0, j = size; i < j; ) {
    unsigned short k = (unsigned short)(i + j) >> 1;
d691 9
a699 9
    if (c > EXTRACT_MBC(&b[k*8+4]))
      i = k + 1;
    else
      j = k;
  }
  if (i < size && EXTRACT_MBC(&b[i*8]) <= c
      && ((unsigned char)c != '\n' && (unsigned char)c != '\0'))
    return 1;
  return result;
d711 6
a716 5
  if (start == NULL) {
    printf("(null)\n");
    return;
  }

d718 7
a724 5
  while (p < pend) {
    switch ((enum regexpcode)*p++) {
    case unused:
      printf("/unused");
      break;
d726 10
a735 9
    case exactn:
      mcnt = *p++;
      printf("/exactn/%d", mcnt);
      do {
	putchar('/');
	printf("%c", *p++);
      }
      while (--mcnt);
      break;
d737 4
a740 4
    case start_memory:
      mcnt = *p++;
      printf("/start_memory/%d/%d", mcnt, *p++);
      break;
d742 4
a745 4
    case stop_memory:
      mcnt = *p++;
      printf("/stop_memory/%d/%d", mcnt, *p++);
      break;
d747 3
a749 3
    case stop_paren:
      printf("/stop_paren");
      break;
d751 3
a753 3
    case casefold_on:
      printf("/casefold_on");
      break;
d755 3
a757 3
    case casefold_off:
      printf("/casefold_off");
      break;
d759 4
a762 3
    case posix_on:
      printf("/posix_on");
      break;
d764 4
a767 3
    case posix_off:
      printf("/posix_off");
      break;
d769 3
a771 4
    case start_nowidth:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      printf("/start_nowidth//%d", mcnt);
      break;
d773 3
a775 4
    case stop_nowidth:
      printf("/stop_nowidth//");
      p += 2;
      break;
d777 3
a779 3
    case pop_and_fail:
      printf("/pop_and_fail");
      break;
d781 31
a811 3
    case duplicate:
      printf("/duplicate/%d", *p++);
      break;
d813 3
a815 3
    case anychar:
      printf("/anychar");
      break;
d817 3
a819 30
    case charset:
    case charset_not:
      {
	register int c;

	printf("/charset%s",
	       (enum regexpcode)*(p - 1) == charset_not ? "_not" : "");

	mcnt = *p++;
	printf("/%d", mcnt);
	for (c = 0; c < mcnt; c++) {
	  unsigned bit;
	  unsigned char map_byte = p[c];

	  putchar ('/');

	  for (bit = 0; bit < BYTEWIDTH; bit++)
	    if (map_byte & (1 << bit))
	      printf("%c", c * BYTEWIDTH + bit);
	}
	p += mcnt;
	mcnt = EXTRACT_UNSIGNED_AND_INCR(p);
	printf("/");
	while (mcnt--) {
	  print_mbc(EXTRACT_MBC_AND_INCR(p));
	  printf("-");
	  print_mbc(EXTRACT_MBC_AND_INCR(p));
	}
	break;
      }
d821 4
a824 3
    case begline:
      printf("/begline");
      break;
d826 4
a829 3
    case endline:
      printf("/endline");
      break;
d831 8
a838 4
    case on_failure_jump:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      printf("/on_failure_jump//%d", mcnt);
      break;
d840 4
a843 4
    case dummy_failure_jump:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      printf("/dummy_failure_jump//%d", mcnt);
      break;
d845 4
a848 3
    case push_dummy_failure:
      printf("/push_dummy_failure");
      break;
d850 4
a853 4
    case finalize_jump:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      printf("/finalize_jump//%d", mcnt);
      break;
d855 22
a876 4
    case maybe_finalize_jump:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      printf("/maybe_finalize_jump//%d", mcnt);
      break;
d878 4
a881 4
    case jump_past_alt:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      printf("/jump_past_alt//%d", mcnt);
      break;
d883 5
a887 4
    case jump:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      printf("/jump//%d", mcnt);
      break;
d889 3
a891 5
    case succeed_n: 
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      EXTRACT_NUMBER_AND_INCR (mcnt2, p);
      printf("/succeed_n//%d//%d", mcnt, mcnt2);
      break;
d893 3
a895 5
    case jump_n: 
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      EXTRACT_NUMBER_AND_INCR (mcnt2, p);
      printf("/jump_n//%d//%d", mcnt, mcnt2);
      break;
d897 10
a906 40
    case set_number_at: 
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      EXTRACT_NUMBER_AND_INCR (mcnt2, p);
      printf("/set_number_at//%d//%d", mcnt, mcnt2);
      break;

    case try_next:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      printf("/try_next//%d", mcnt);
      break;

    case finalize_push:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      printf("/finalize_push//%d", mcnt);
      break;

    case finalize_push_n:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      EXTRACT_NUMBER_AND_INCR (mcnt2, p);
      printf("/finalize_push_n//%d//%d", mcnt, mcnt2);
      break;

    case wordbound:
      printf("/wordbound");
      break;

    case notwordbound:
      printf("/notwordbound");
      break;

    case wordbeg:
      printf("/wordbeg");
      break;

    case wordend:
      printf("/wordend");

    case wordchar:
      printf("/wordchar");
      break;
d908 3
a910 3
    case notwordchar:
      printf("/notwordchar");
      break;
d912 3
a914 3
    case begbuf:
      printf("/begbuf");
      break;
d916 3
a918 3
    case endbuf:
      printf("/endbuf");
      break;
d920 3
a922 3
    case endbuf2:
      printf("/endbuf2");
      break;
d924 3
a926 2
    default:
      printf("?%d", *(p-1));
a927 1
  }
d934 1
a934 1
     struct re_pattern_buffer *bufp;
d943 2
a944 2
     char *start;
     char *end;
d953 1
a953 1

d955 6
a960 4
  while (p < pend) {
    switch ((enum regexpcode)*p++) {
    case unused:
      break;
d962 8
a969 8
    case exactn:
      mcnt = *p;
      if (mcnt > max) {
	must = p;
	max = mcnt;
      }
      p += mcnt+1;
      break;
d971 4
a974 4
    case start_memory:
    case stop_memory:
      p += 2;
      break;
d976 3
a978 3
    case duplicate:
      p++;
      break;
d980 3
a982 5
    case casefold_on:
    case casefold_off:
    case posix_on:
    case posix_off:
      return 0;		/* should not check must_string */
d984 16
a999 16
    case pop_and_fail:
    case anychar:
    case begline:
    case endline:
    case wordbound:
    case notwordbound:
    case wordbeg:
    case wordend:
    case wordchar:
    case notwordchar:
    case begbuf:
    case endbuf:
    case endbuf2:
    case push_dummy_failure:
    case stop_paren:
      break;
d1001 9
a1009 9
    case charset:
    case charset_not:
      mcnt = *p++;
      p += mcnt;
      mcnt = EXTRACT_UNSIGNED_AND_INCR(p);
      while (mcnt--) {
	p += 4;
      }
      break;
d1011 9
a1019 9
    case on_failure_jump:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      if (mcnt > 0) p += mcnt;
      if ((enum regexpcode)p[-3] == jump) {
	p -= 3;
	EXTRACT_NUMBER_AND_INCR (mcnt, p);
	if (mcnt > 0) p += mcnt;
      }
      break;
d1021 7
a1027 7
    case dummy_failure_jump:
    case succeed_n: 
    case try_next:
    case jump:
      EXTRACT_NUMBER_AND_INCR (mcnt, p);
      if (mcnt > 0) p += mcnt;
      break;
d1029 7
a1035 7
    case start_nowidth:
    case stop_nowidth:
    case finalize_jump:
    case maybe_finalize_jump:
    case finalize_push:
      p += 2;
      break;
d1037 5
a1041 5
    case jump_n: 
    case set_number_at: 
    case finalize_push_n:
      p += 4;
      break;
d1043 3
a1045 2
    default:
      break;
a1046 1
  }
d1068 1
a1068 1
     const char *pattern;
d1072 7
a1078 7
  register char *b = bufp->buffer;
  register const char *p = pattern;
  const char *nextp;
  const char *pend = pattern + size;
  register unsigned c, c1;
  const char *p0;
  int numlen;
d1080 4
a1083 4
  /* Address of the count-byte of the most recently inserted `exactn'
     command.  This makes it possible to tell whether a new exact-match
     character can be added to that command or requires a new `exactn'
     command.  */
d1085 1
a1085 1
  char *pending_exact = 0;
d1087 3
a1089 3
  /* Address of the place where a forward-jump should go to the end of
     the containing expression.  Each alternative of an `or', except the
     last, ends with a forward-jump of this sort.  */
d1091 1
a1091 1
  char *fixup_alt_jump = 0;
d1093 2
a1094 2
  /* Address of start of the most recently finished expression.
     This tells postfix * where to find the start of its operand.  */
d1096 1
a1096 1
  char *laststart = 0;
d1098 1
a1098 1
  /* In processing a repeat, 1 means zero matches is allowed.  */
d1100 1
a1100 1
  char zero_times_ok;
d1102 1
a1102 1
  /* In processing a repeat, 1 means many matches is allowed.  */
d1104 1
a1104 1
  char many_times_ok;
d1106 1
a1106 1
  /* In processing a repeat, 1 means non-greedy matches.  */
d1108 1
a1108 1
  char greedy;
d1110 1
a1110 1
  /* Address of beginning of regexp, or inside of last (.  */
d1112 1
a1112 1
  char *begalt = b;
d1114 3
a1116 3
  /* Place in the uncompiled pattern (i.e., the {) to
     which to go back if the interval is invalid.  */
  const char *beg_interval;
d1118 2
a1119 2
  /* In processing an interval, at least this many matches must be made.  */
  int lower_bound;
d1121 2
a1122 2
  /* In processing an interval, at most this many matches can be made.  */
  int upper_bound;
d1124 7
a1130 7
  /* Stack of information saved by ( and restored by ).
     Five stack elements are pushed by each (:
     First, the value of b.
     Second, the value of fixup_alt_jump.
     Third, the value of begalt.
     Fourth, the value of regnum.
     Fifth, the type of the paren. */
d1132 4
a1135 4
  int *stackb = RE_TALLOC(40, int);
  int *stackp = stackb;
  int *stacke = stackb + 40;
  int *stackt;
d1137 3
a1139 3
  /* Counts ('s as they are encountered.  Remembered for the matching ),
     where it becomes the register number to put in the stop_memory
     command.  */
d1141 1
a1141 1
  int regnum = 1;
d1143 3
a1145 3
  int range = 0;
  int had_mbchar = 0;
  int had_char_class = 0;
d1147 1
a1147 1
  int options = bufp->options;
d1149 4
a1152 19
  bufp->fastmap_accurate = 0;
  bufp->must = 0;
  bufp->must_skip = 0;
  bufp->stclass = 0;

  /* Initialize the syntax table.  */
  init_syntax_once();

  if (bufp->allocated == 0) {
    bufp->allocated = INIT_BUF_SIZE;
    if (bufp->buffer)
      /* EXTEND_BUFFER loses when bufp->allocated is 0.  */
      bufp->buffer = (char*)xrealloc (bufp->buffer, INIT_BUF_SIZE);
    else
      /* Caller did not allocate a buffer.  Do it for them.  */
      bufp->buffer = (char*)xmalloc(INIT_BUF_SIZE);
    if (!bufp->buffer) goto memory_exhausted;
    begalt = b = bufp->buffer;
  }
d1154 2
a1155 2
  while (p != pend) {
    PATFETCH(c);
d1157 11
a1167 6
    switch (c) {
    case '$':
      {
	p0 = p;
	/* When testing what follows the $,
	   look past the \-constructs that don't consume anything.  */
d1169 6
a1174 1
	while (p0 != pend)
d1176 34
a1209 12
	    if (*p0 == '\\' && p0 + 1 != pend
		&& (p0[1] == 'b' || p0[1] == 'B'))
	      p0 += 2;
	    else
	      break;
	  }
	BUFPUSH(endline);
	break;
      }
    case '^':
      BUFPUSH(begline);
      break;
d1211 1
a1211 15
    case '+':
    case '?':
    case '*':
      /* If there is no previous pattern, char not special. */
      if (!laststart) {
	goto invalid_pattern;
      }
      /* If there is a sequence of repetition chars,
	 collapse it down to just one.  */
      zero_times_ok = c != '+';
      many_times_ok = c != '?';
      greedy = 1;
      if (p != pend) {
	PATFETCH(c);
	switch (c) {
a1212 2
	  greedy = 0;
	  break;
d1214 23
a1236 7
	case '+':
	  goto nested_meta;
	default:
	  PATUNFETCH;
	  break;
	}
      }
d1238 5
a1242 5
    repeat:
      /* Star, etc. applied to an empty pattern is equivalent
	 to an empty pattern.  */
      if (!laststart)  
	break;
d1244 11
a1254 17
      /* Now we know whether or not zero matches is allowed
	 and also whether or not two or more matches is allowed.  */
      if (many_times_ok) {
	/* If more than one repetition is allowed, put in at the
	   end a backward relative jump from b to before the next
	   jump we're going to put in below (which jumps from
	   laststart to after this jump).  */
	GET_BUFFER_SPACE(3);
	store_jump(b,greedy?maybe_finalize_jump:finalize_push,laststart-3);
	b += 3;  	/* Because store_jump put stuff here.  */
      }

      /* On failure, jump from laststart to next pattern, which will be the
	 end of the buffer after this jump is inserted.  */
      GET_BUFFER_SPACE(3);
      insert_jump(on_failure_jump, laststart, b + 3, b);
      b += 3;
d1256 2
a1257 2
      if (zero_times_ok) {
	if (greedy == 0) {
d1259 1
a1259 1
	  insert_jump(try_next, laststart, b + 3, b);
a1260 13
	}
      }
      else {
	/* At least one repetition is required, so insert a
	   `dummy_failure_jump' before the initial
	   `on_failure_jump' instruction of the loop. This
	   effects a skip over that instruction the first time
	   we hit that loop.  */
	GET_BUFFER_SPACE(3);
	insert_jump(dummy_failure_jump, laststart, laststart + 6, b);
	b += 3;
      }
      break;
d1262 18
a1279 4
    case '.':
      laststart = b;
      BUFPUSH(anychar);
      break;
d1281 4
a1284 6
    case '[':
      if (p == pend)
	goto invalid_pattern;
      while ((b - bufp->buffer + 9 + (1 << BYTEWIDTH) / BYTEWIDTH)
	     > bufp->allocated)
	EXTEND_BUFFER;
d1286 6
a1291 9
      laststart = b;
      if (*p == '^')
	{
	  BUFPUSH(charset_not); 
	  p++;
	}
      else
	BUFPUSH(charset);
      p0 = p;
d1293 9
a1301 14
      BUFPUSH((1 << BYTEWIDTH) / BYTEWIDTH);
      /* Clear the whole map */
      memset(b, 0, (1 << BYTEWIDTH) / BYTEWIDTH + 2);

      had_mbchar = 0;
      had_char_class = 0;

      /* charset_not matches newline according to a syntax bit.  */
      if ((enum regexpcode)b[-2] == charset_not) {
	if (bufp->options & RE_OPTION_POSIX)
	  SET_LIST_BIT ('\n');
	else
	  SET_LIST_BIT ('\0');
      }
d1303 3
a1305 5
      /* Read in characters and ranges, setting map bits.  */
      for (;;)
	{
	  int size;
	  unsigned last = (unsigned)-1;
d1307 7
a1313 10
	  if ((size = EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH]))
	      || current_mbctype) {
	    /* Ensure the space is enough to hold another interval
	       of multi-byte chars in charset(_not)?.  */
	    size = (1 << BYTEWIDTH) / BYTEWIDTH + 2 + size*8 + 8;
	    while (b + size + 1 > bufp->buffer + bufp->allocated)
	      EXTEND_BUFFER;
	  }
	range_retry:
	  PATFETCH(c);
d1315 10
a1324 19
	  if (c == ']') {
	    if (p == p0 + 1) {
	      if (p == pend)
		goto invalid_pattern;
	    }
	    else 
	      /* Stop if this isn't merely a ] inside a bracket
		 expression, but rather the end of a bracket
		 expression.  */
	      break;
	  }
	  /* Look ahead to see if it's a range when the last thing
	     was a character class.  */
	  if (had_char_class && c == '-' && *p != ']')
	    goto invalid_pattern;
	  if (ismbchar(c)) {
	    PATFETCH_MBC(c);
	    had_mbchar++;
	  }
d1326 10
a1335 9
	  /* \ escapes characters when inside [...].  */
	  if (c == '\\') {
	    PATFETCH(c);
	    switch (c) {
	    case 'w':
	      for (c = 0; c < (1 << BYTEWIDTH); c++) {
		if (SYNTAX(c) == Sword ||
		    (!current_mbctype && SYNTAX(c) == Sword2))
		  SET_LIST_BIT(c);
d1337 7
a1343 2
	      if (current_mbctype) {
		set_list_bits(0x80, 0xffffffff, b);
a1344 2
	      last = -1;
	      continue;
d1346 77
a1422 5
	    case 'W':
	      for (c = 0; c < (1 << BYTEWIDTH); c++) {
		if (SYNTAX(c) != Sword &&
		    (current_mbctype || SYNTAX(c) != Sword2))
		  SET_LIST_BIT(c);
a1423 2
	      last = -1;
	      continue;
d1425 43
a1467 6
	    case 's':
	      for (c = 0; c < 256; c++)
		if (ISSPACE(c))
		  SET_LIST_BIT(c);
	      last = -1;
	      continue;
d1469 53
a1521 6
	    case 'S':
	      for (c = 0; c < 256; c++)
		if (!ISSPACE(c))
		  SET_LIST_BIT(c);
	      if (current_mbctype) {
		set_list_bits(0x80, 0xffffffff, b);
d1523 1
a1523 5
	      last = -1;
	      continue;

	    case 'd':
	      for (c = '0'; c <= '9'; c++)
d1525 4
a1528 2
	      last = -1;
	      continue;
d1530 9
a1538 9
	    case 'D':
	      for (c = 0; c < 256; c++)
		if (!ISDIGIT(c))
		  SET_LIST_BIT(c);
	      if (current_mbctype) {
		set_list_bits(0x80, 0xffffffff, b);
	      }
	      last = -1;
	      continue;
d1540 35
a1574 4
	    case 'x':
	      c = scan_hex(p, 2, &numlen);
	      p += numlen;
	      break;
d1576 11
a1586 6
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
	      PATUNFETCH;
	      c = scan_oct(p, 3, &numlen);
	      p += numlen;
	      break;
d1588 7
a1594 8
	    default:
	      if (ismbchar(c)) {
		PATFETCH_MBC(c);
		had_mbchar++;
	      }
	      break;
	    }
	  }
d1596 3
a1598 39
	  /* Get a range.  */
	  if (range) {
	    if (last > c)
	      goto invalid_pattern;

	    range = 0;
	    if (had_mbchar == 0) {
	      for (;last<=c;last++)
		SET_LIST_BIT(last);
	    }
	    else if (had_mbchar == 2) {
	      set_list_bits(last, c, b);
	    }
	    else {
	      /* restriction: range between sbc and mbc */
	      goto invalid_pattern;
	    }
	  }
	  else if (p[0] == '-' && p[1] != ']') {
	    last = c;
	    PATFETCH(c1);
	    range = 1;
	    goto range_retry;
	  }
	  else if (c == '[' && *p == ':') {
	    /* Leave room for the null.  */
	    char str[CHAR_CLASS_MAX_LENGTH + 1];

	    PATFETCH_RAW (c);
	    c1 = 0;

	    /* If pattern is `[[:'.  */
	    if (p == pend) 
	      goto invalid_pattern;

	    for (;;) {
	      PATFETCH (c);
	      if (c == ':' || c == ']' || p == pend
		  || c1 == CHAR_CLASS_MAX_LENGTH)
a1599 3
	      str[c1++] = c;
	    }
	    str[c1] = '\0';
d1601 2
a1602 52
	    /* If isn't a word bracketed by `[:' and:`]':
	       undo the ending character, the letters, and leave 
	       the leading `:' and `[' (but set bits for them).  */
	    if (c == ':' && *p == ']') {
	      int ch;
	      char is_alnum = STREQ(str, "alnum");
	      char is_alpha = STREQ(str, "alpha");
	      char is_blank = STREQ(str, "blank");
	      char is_cntrl = STREQ(str, "cntrl");
	      char is_digit = STREQ(str, "digit");
	      char is_graph = STREQ(str, "graph");
	      char is_lower = STREQ(str, "lower");
	      char is_print = STREQ(str, "print");
	      char is_punct = STREQ(str, "punct");
	      char is_space = STREQ(str, "space");
	      char is_upper = STREQ(str, "upper");
	      char is_xdigit = STREQ(str, "xdigit");

	      if (!IS_CHAR_CLASS (str))
		goto invalid_pattern;

	      /* Throw away the ] at the end of the character class.  */
	      PATFETCH (c);

	      if (p == pend) 
		goto invalid_pattern;

	      for (ch = 0; ch < 1 << BYTEWIDTH; ch++) {
		if (   (is_alnum  && ISALNUM(ch))
		       || (is_alpha  && ISALPHA(ch))
		       || (is_blank  && ISBLANK(ch))
		       || (is_cntrl  && ISCNTRL(ch))
		       || (is_digit  && ISDIGIT(ch))
		       || (is_graph  && ISGRAPH(ch))
		       || (is_lower  && ISLOWER(ch))
		       || (is_print  && ISPRINT(ch))
		       || (is_punct  && ISPUNCT(ch))
		       || (is_space  && ISSPACE(ch))
		       || (is_upper  && ISUPPER(ch))
		       || (is_xdigit && ISXDIGIT(ch)))
		  SET_LIST_BIT (ch);
	      }
	      had_char_class = 1;
	    }
	    else {
	      c1++;
	      while (c1--)    
		PATUNFETCH;
	      SET_LIST_BIT(translate?translate['[']:'[');
	      SET_LIST_BIT(translate?translate[':']:':');
	      had_char_class = 0;
	      last = ':';
d1605 8
a1612 6
	  else if (had_mbchar == 0)
	    SET_LIST_BIT(c);
	  else
	    set_list_bits(c, c, b);
	  had_mbchar = 0;
	}
d1614 23
a1636 9
      /* Discard any character set/class bitmap bytes that are all
	 0 at the end of the map. Decrement the map-length byte too.  */
      while ((int)b[-1] > 0 && b[b[-1] - 1] == 0) 
	b[-1]--; 
      if (b[-1] != (1 << BYTEWIDTH) / BYTEWIDTH)
	memmove(&b[b[-1]], &b[(1 << BYTEWIDTH) / BYTEWIDTH],
		2 + EXTRACT_UNSIGNED (&b[(1 << BYTEWIDTH) / BYTEWIDTH])*8);
      b += b[-1] + 2 + EXTRACT_UNSIGNED (&b[b[-1]])*8;
      break;
d1638 12
a1649 11
    case '(':
      PATFETCH(c);
      if (c == '?') {
	int negative = 0;
	PATFETCH_RAW(c);
	switch (c) {
	case 'x': case 'p': case 'i': case '-':
	  for (;;) {
	    switch (c) {
	    case '-':
	      negative = 1;
d1653 2
a1654 1
	    case ')':
d1656 7
d1664 29
a1692 5
	    case 'x':
	      if (negative)
		options &= ~RE_OPTION_EXTENDED;
	      else
		options |= RE_OPTION_EXTENDED;
d1694 14
a1707 11
	    case 'p':
	      if (negative) {
		if (options&RE_OPTION_POSIX) {
		  options &= ~RE_OPTION_POSIX;
		  BUFPUSH(posix_off);
		}
	      }
	      else if (!(options&RE_OPTION_POSIX)) {
		options |= RE_OPTION_POSIX;
		BUFPUSH(posix_on);
	      }
d1709 3
a1711 11
	    case 'i':
	      if (negative) {
		if (options&RE_OPTION_IGNORECASE) {
		  options &= ~RE_OPTION_IGNORECASE;
		  BUFPUSH(casefold_off);
		}
	      }
	      else if (!(options&RE_OPTION_IGNORECASE)) {
		options |= RE_OPTION_IGNORECASE;
		BUFPUSH(casefold_on);
	      }
a1714 4
	      FREE_AND_RETURN(stackb, "undefined (?...) inline option");
	    }
	    if (c == ')') {
	      c = '#';	/* read whole in-line options */
a1715 3
	    }
	    if (c == ':') break;
	    PATFETCH_RAW(c);
d1717 5
d1724 32
a1755 7
	case '#':
	  for (;;) {
	    PATFETCH(c);
	    if (c == ')') break;
	  }
	  c = '#';
	  break;
d1757 2
a1758 3
	case ':':
	case '=':
	case '!':
d1761 6
a1766 19
	default:
	  FREE_AND_RETURN(stackb, "undefined (?...) sequence");
	}
      }
      else {
	PATUNFETCH;
	c = '(';
      }
      if (c == '#') break;
      if (stackp+8 >= stacke) {
	int *stackx;
	unsigned int len = stacke - stackb;

	stackx = DOUBLE_STACK(stackx,stackb,len,int);
	/* Rearrange the pointers. */
	stackp = stackx + (stackp - stackb);
	stackb = stackx;
	stacke = stackb + 2 * len;
      }
d1768 1
a1768 16
      /* Laststart should point to the start_memory that we are about
	 to push (unless the pattern has RE_NREGS or more ('s).  */
      /* obsolete: now RE_NREGS is just a default register size. */
      *stackp++ = b - bufp->buffer;    
      *stackp++ = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
      *stackp++ = begalt - bufp->buffer;
      switch (c) {
      case '(':
	BUFPUSH(start_memory);
	BUFPUSH(regnum);
	*stackp++ = regnum++;
	*stackp++ = b - bufp->buffer;
	BUFPUSH(0);
	/* too many ()'s to fit in a byte. (max 254) */
	if (regnum >= RE_REG_MAX) goto too_big;
	break;
d1770 9
a1778 13
      case '=':
      case '!':
	BUFPUSH(start_nowidth);
	*stackp++ = b - bufp->buffer;
	BUFPUSH(0);	/* temporary value */
	BUFPUSH(0);
	if (c == '=') break;

	BUFPUSH(on_failure_jump);
	*stackp++ = b - bufp->buffer;
	BUFPUSH(0);	/* temporary value */
	BUFPUSH(0);
	break;
d1780 2
a1781 11
      case ':':
	pending_exact = 0;
      default:
	break;
      }
      *stackp++ = c;
      *stackp++ = options;
      fixup_alt_jump = 0;
      laststart = 0;
      begalt = b;
      break;
d1783 5
a1787 33
    case ')':
      if (stackp == stackb) 
	FREE_AND_RETURN(stackb, "unmatched )");
      if ((options ^ stackp[-1]) & RE_OPTION_IGNORECASE) {
	BUFPUSH((options&RE_OPTION_IGNORECASE)?casefold_off:casefold_on);
      }
      if ((options ^ stackp[-1]) & RE_OPTION_POSIX) {
	BUFPUSH((options&RE_OPTION_POSIX)?posix_off:posix_on);
      }
      pending_exact = 0;
      if (fixup_alt_jump)
	{ /* Push a dummy failure point at the end of the
	     alternative for a possible future
	     `finalize_jump' to pop.  See comments at
	     `push_dummy_failure' in `re_match'.  */
	  BUFPUSH(push_dummy_failure);

	  /* We allocated space for this jump when we assigned
	     to `fixup_alt_jump', in the `handle_alt' case below.  */
	  store_jump(fixup_alt_jump, jump, b);
	}
      options = *--stackp;
      switch (c = *--stackp) {
      case '(':
	{
	  char *loc = bufp->buffer + *--stackp;
	  *loc = regnum - stackp[-1];
	  BUFPUSH(stop_memory);
	  BUFPUSH(stackp[-1]);
	  BUFPUSH(regnum - stackp[-1]);
	  stackp--;
	}
	break;
d1789 2
a1790 14
      case '!':
	BUFPUSH(pop_and_fail);
	/* back patch */
	STORE_NUMBER(bufp->buffer+stackp[-1], b - bufp->buffer - stackp[-1] - 2);
	stackp--;
	/* fall through */
      case '=':
	BUFPUSH(stop_nowidth);
	/* tell stack-pos place to start_nowidth */
	STORE_NUMBER(bufp->buffer+stackp[-1], b - bufp->buffer - stackp[-1] - 2);
	BUFPUSH(0);	/* space to hold stack pos */
	BUFPUSH(0);
	stackp--;
	break;
d1792 6
a1797 3
      case ':':
	BUFPUSH(stop_paren);
	break;
d1799 22
a1820 9
      default:
	break;
      }
      begalt = *--stackp + bufp->buffer;
      stackp--;
      fixup_alt_jump = *stackp ? *stackp + bufp->buffer - 1 : 0;
      laststart = *--stackp + bufp->buffer;
      if (c == '!' || c == '=') laststart = b;
      break;
d1822 10
a1831 32
    case '|':
      /* Insert before the previous alternative a jump which
	 jumps to this alternative if the former fails.  */
      GET_BUFFER_SPACE(3);
      insert_jump(on_failure_jump, begalt, b + 6, b);
      pending_exact = 0;
      b += 3;
      /* The alternative before this one has a jump after it
	 which gets executed if it gets matched.  Adjust that
	 jump so it will jump to this alternative's analogous
	 jump (put in below, which in turn will jump to the next
	 (if any) alternative's such jump, etc.).  The last such
	 jump jumps to the correct final destination.  A picture:
	 _____ _____ 
	 |   | |   |   
	 |   v |   v 
	 a | b   | c   

	 If we are at `b', then fixup_alt_jump right now points to a
	 three-byte space after `a'.  We'll put in the jump, set
	 fixup_alt_jump to right after `b', and leave behind three
	 bytes which we'll fill in when we get to after `c'.  */

      if (fixup_alt_jump)
	store_jump(fixup_alt_jump, jump_past_alt, b);

      /* Mark and leave space for a jump after this alternative,
	 to be filled in later either by next alternative or
	 when know we're at the end of a series of alternatives.  */
      fixup_alt_jump = b;
      GET_BUFFER_SPACE(3);
      b += 3;
d1833 29
a1861 3
      laststart = 0;
      begalt = b;
      break;
d1863 33
a1895 6
    case '{':
      /* If there is no previous pattern, this isn't an interval.  */
      if (!laststart || p == pend)
	{
	  goto normal_char;
	}
d1897 4
a1900 1
      beg_interval = p - 1;
d1902 3
a1904 9
      lower_bound = -1;			/* So can see if are set.  */
      upper_bound = -1;
      GET_UNSIGNED_NUMBER(lower_bound);
      if (c == ',') {
	GET_UNSIGNED_NUMBER(upper_bound);
      }
      else
	/* Interval such as `{1}' => match exactly once. */
	upper_bound = lower_bound;
d1906 23
a1928 2
      if (lower_bound < 0 || c != '}')
	goto unfetch_interval;
d1930 11
a1940 15
      if (lower_bound >= RE_DUP_MAX || upper_bound >= RE_DUP_MAX)
	FREE_AND_RETURN(stackb, "too big quantifier in {,}");
      if (upper_bound < 0) upper_bound = RE_DUP_MAX;
      if (lower_bound > upper_bound)
	FREE_AND_RETURN(stackb, "can't do {n,m} with n > m");

      beg_interval = 0;
      pending_exact = 0;

      greedy = 1;
      if (p != pend) {
	PATFETCH(c);
	if (c == '?') greedy = 0;
	else PATUNFETCH;
      }
d1942 4
a1945 22
      if (lower_bound == 0) {
	zero_times_ok = 1;
	if (upper_bound == RE_DUP_MAX) {
	  many_times_ok = 1;
	  goto repeat;
	}
	if (upper_bound == 1) {
	  many_times_ok = 0;
	  goto repeat;
	}
      }
      if (lower_bound == 1) {
	if (upper_bound == 1) {
	  /* No need to repeat */
	  break;
	}
	if (upper_bound == RE_DUP_MAX) {
	  many_times_ok = 1;
	  zero_times_ok = 0;
	  goto repeat;
	}
      }
d1947 7
a1953 10
      /* If upper_bound is zero, don't want to succeed at all; 
	 jump from laststart to b + 3, which will be the end of
	 the buffer after this jump is inserted.  */

      if (upper_bound == 0) {
	GET_BUFFER_SPACE(3);
	insert_jump(jump, laststart, b + 3, b);
	b += 3;
	break;
      }
d1955 4
a1958 42
      /* Otherwise, we have a nontrivial interval.  When
	 we're all done, the pattern will look like:
	 set_number_at <jump count> <upper bound>
	 set_number_at <succeed_n count> <lower bound>
	 succeed_n <after jump addr> <succed_n count>
	 <body of loop>
	 jump_n <succeed_n addr> <jump count>
	 (The upper bound and `jump_n' are omitted if
	 `upper_bound' is 1, though.)  */
      { /* If the upper bound is > 1, we need to insert
	   more at the end of the loop.  */
	unsigned nbytes = upper_bound == 1 ? 10 : 20;

	GET_BUFFER_SPACE(nbytes);
	/* Initialize lower bound of the `succeed_n', even
	   though it will be set during matching by its
	   attendant `set_number_at' (inserted next),
	   because `re_compile_fastmap' needs to know.
	   Jump to the `jump_n' we might insert below.  */
	insert_jump_n(succeed_n, laststart, b + (nbytes/2), 
		      b, lower_bound);
	b += 5; 	/* Just increment for the succeed_n here.  */

	/* Code to initialize the lower bound.  Insert 
	   before the `succeed_n'.  The `5' is the last two
	   bytes of this `set_number_at', plus 3 bytes of
	   the following `succeed_n'.  */
	insert_op_2(set_number_at, laststart, b, 5, lower_bound);
	b += 5;

	if (upper_bound > 1)
	  { /* More than one repetition is allowed, so
	       append a backward jump to the `succeed_n'
	       that starts this interval.

	       When we've reached this during matching,
	       we'll have matched the interval once, so
	       jump back only `upper_bound - 1' times.  */
	    GET_BUFFER_SPACE(5);
	    store_jump_n(b, greedy?jump_n:finalize_push_n, laststart + 5,
			 upper_bound - 1);
	    b += 5;
d1960 4
a1963 20
	    /* The location we want to set is the second
	       parameter of the `jump_n'; that is `b-2' as
	       an absolute address.  `laststart' will be
	       the `set_number_at' we're about to insert;
	       `laststart+3' the number to set, the source
	       for the relative address.  But we are
	       inserting into the middle of the pattern --
	       so everything is getting moved up by 5.
	       Conclusion: (b - 2) - (laststart + 3) + 5,
	       i.e., b - laststart.

	       We insert this at the beginning of the loop
	       so that if we fail during matching, we'll
	       reinitialize the bounds.  */
	    insert_op_2(set_number_at, laststart, b, b - laststart,
			upper_bound - 1);
	    b += 5;
	  }
      }
      break;
d1965 3
a1967 24
    unfetch_interval:
      /* If an invalid interval, match the characters as literals.  */
      p = beg_interval;
      beg_interval = 0;

      /* normal_char and normal_backslash need `c'.  */
      PATFETCH (c);	
      goto normal_char;

    case '\\':
      if (p == pend) goto invalid_pattern;
      /* Do not translate the character after the \, so that we can
	 distinguish, e.g., \B from \b, even if we normally would
	 translate, e.g., B to b.  */
      PATFETCH_RAW(c);
      switch (c)
	{
	case 's':
	case 'S':
	case 'd':
	case 'D':
	  while (b - bufp->buffer + 9 + (1 << BYTEWIDTH) / BYTEWIDTH
		 > bufp->allocated)
	    EXTEND_BUFFER;
d1969 3
a1971 7
	  laststart = b;
	  if (c == 's' || c == 'd') {
	    BUFPUSH(charset);
	  }
	  else {
	    BUFPUSH(charset_not);
	  }
d1973 3
a1975 11
	  BUFPUSH((1 << BYTEWIDTH) / BYTEWIDTH);
	  memset(b, 0, (1 << BYTEWIDTH) / BYTEWIDTH + 2);
	  if (c == 's' || c == 'S') {
	    SET_LIST_BIT(' ');
	    SET_LIST_BIT('\t');
	    SET_LIST_BIT('\n');
	    SET_LIST_BIT('\r');
	    SET_LIST_BIT('\f');
	  }
	  else {
	    char cc;
d1977 3
a1979 4
	    for (cc = '0'; cc <= '9'; cc++) {
	      SET_LIST_BIT(cc);
	    }
	  }
d1981 3
a1983 7
	  while ((int)b[-1] > 0 && b[b[-1] - 1] == 0) 
	    b[-1]--; 
	  if (b[-1] != (1 << BYTEWIDTH) / BYTEWIDTH)
	    memmove(&b[b[-1]], &b[(1 << BYTEWIDTH) / BYTEWIDTH],
		    2 + EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH])*8);
	  b += b[-1] + 2 + EXTRACT_UNSIGNED(&b[b[-1]])*8;
	  break;
d1985 3
a1987 4
	case 'w':
	  laststart = b;
	  BUFPUSH(wordchar);
	  break;
d1989 3
a1991 4
	case 'W':
	  laststart = b;
	  BUFPUSH(notwordchar);
	  break;
d1993 6
a1998 3
	case '<':
	  BUFPUSH(wordbeg);
	  break;
d2000 6
a2005 3
	case '>':
	  BUFPUSH(wordend);
	  break;
d2007 6
a2012 3
	case 'b':
	  BUFPUSH(wordbound);
	  break;
d2014 2
a2015 3
	case 'B':
	  BUFPUSH(notwordbound);
	  break;
d2017 14
a2030 3
	case 'A':
	  BUFPUSH(begbuf);
	  break;
d2032 8
a2039 3
	case 'Z':
	  BUFPUSH(endbuf2);
	  break;
d2041 3
a2043 2
	case 'z':
	  BUFPUSH(endbuf);
d2046 8
a2053 36
	  /* hex */
	case 'x':
	  had_mbchar = 0;
	  c = scan_hex(p, 2, &numlen);
	  p += numlen;
	  goto numeric_char;

	  /* octal */
	case '0':
	  had_mbchar = 0;
	  c = scan_oct(p, 3, &numlen);
	  p += numlen;
	  goto numeric_char;

	  /* back-ref or octal */
	case '1': case '2': case '3':
	case '4': case '5': case '6':
	case '7': case '8': case '9':
	  {
	    const char *p_save;

	    PATUNFETCH;
	    p_save = p;

	    had_mbchar = 0;
	    c1 = 0;
	    GET_UNSIGNED_NUMBER(c1);
	    if (!ISDIGIT(c)) PATUNFETCH;

	    if (c1 >= regnum) {
	      /* need to get octal */
	      p = p_save;
	      c = scan_oct(p_save, 3, &numlen) & 0xff;
	      p = p_save + numlen;
	      c1 = 0;
	      goto numeric_char;
d2055 1
a2055 1
	  }
d2057 7
a2063 8
	  /* Can't back reference to a subexpression if inside of it.  */
	  for (stackt = stackp - 2;  stackt > stackb;  stackt -= 5)
	    if (*stackt == c1)
	      goto normal_char;
	  laststart = b;
	  BUFPUSH(duplicate);
	  BUFPUSH(c1);
	  break;
d2066 21
a2086 10
	  goto normal_char;
	}
      break;

    case '#':
      if (options & RE_OPTION_EXTENDED)
	{
	  while (p != pend) {
	    PATFETCH(c);
	    if (c == '\n') break;
a2087 41
	  break;
	}
      goto normal_char;

    case ' ':
    case '\t':
    case '\f':
    case '\r':
    case '\n':
      if (options & RE_OPTION_EXTENDED)
	break;

    default:
    normal_char:		/* Expects the character in `c'.  */
      had_mbchar = 0;
      if (ismbchar(c)) {
	had_mbchar = 1;
	c1 = p - pattern;
      }
    numeric_char:
      nextp = p + mbclen(c) - 1;
      if (!pending_exact || pending_exact + *pending_exact + 1 != b
	  || *pending_exact >= (c1 ? 0176 : 0177)
	  || *nextp == '+' || *nextp == '?'
	  || *nextp == '*' || *nextp == '^'
	  || *nextp == '{') {
	laststart = b;
	BUFPUSH(exactn);
	pending_exact = b;
	BUFPUSH(0);
      }
      if (!had_mbchar && c > 0x7f) {
	BUFPUSH(0xff);
	(*pending_exact)++;
      }
      BUFPUSH(c);
      (*pending_exact)++;
      if (had_mbchar) {
	int len = mbclen(c) - 1;
	while (len--) {
	  PATFETCH_RAW(c);
d2090 8
a2098 1
      }
a2099 1
  }
d2120 8
a2127 8
	case jump_n:
	case finalize_jump:
	case maybe_finalize_jump:
	case jump:
	case jump_past_alt:
	case dummy_failure_jump:
	  bufp->options |= RE_OPTIMIZE_ANCHOR;
	  break;
d2196 1
a2196 1
     struct re_pattern_buffer *bufp;
d2198 4
a2201 4
  free(bufp->buffer);
  free(bufp->fastmap);
  if (bufp->must_skip) free(bufp->must_skip);
  free(bufp);
d2401 4
a2404 4
     int *skip;
     unsigned char *pat;
     int m;
     const char *translate;
d2406 1
a2406 1
  int j, c;
d2408 7
a2414 6
  for (c=0; c<256; c++) {
    skip[c] = m;
  }
  if (translate) {
    for (j=0; j<m-1; j++) {
      skip[translate[pat[j]]] = m-1-j;
d2416 4
a2419 4
  }
  else {
    for (j=0; j<m-1; j++) {
      skip[pat[j]] = m-1-j;
a2420 1
  }
d2492 8
a2499 7
  while (p) {
    is_a_succeed_n = 0;
    if (p == pend)
      {
	bufp->can_be_null = 1;
	break;
      }
d2501 1
a2501 1
    switch ((int)((enum regexpcode)*p++))
d2519 1
a2519 1
	case begline:
d2528 1
a2528 1
	case push_dummy_failure:
a2537 5
	case posix_on:
	case posix_off:
	  options ^= RE_OPTION_POSIX;
	  continue;

d2549 1
a2549 1
	case finalize_jump:
d2552 1
a2552 1
	case jump_past_alt:
d2554 1
a2554 1
	  EXTRACT_NUMBER_AND_INCR(j, p);
d2558 1
a2558 1
	  /* Jump backward reached implies we just went through
d2565 1
a2565 1
	  if ((enum regexpcode)*p != on_failure_jump
d2571 6
a2576 6
	  p++;
	  EXTRACT_NUMBER_AND_INCR(j, p);
	  p += j;	
	  if (stackp != stackb && *stackp == p)
	    stackp--;		/* pop */
	  continue;
d2578 1
a2578 1
	case start_nowidth:
d2580 1
a2580 1
	case finalize_push:
d2584 1
a2584 1
	case finalize_push_n:
d2589 1
a2589 1
	case on_failure_jump:
d2591 5
a2595 5
	EXTRACT_NUMBER_AND_INCR(j, p);
	if (p + j < pend) {
	  if (stackp == stacke) {
	    unsigned char **stackx;
	    unsigned int len = stacke - stackb;
d2597 6
a2602 1
	    EXPAND_FAIL_STACK(stackx, stackb, len);
d2604 3
a2606 8
	  *++stackp = p + j;	/* push */
	}
	else {
	  bufp->can_be_null = 1;
	}
	if (is_a_succeed_n)
	  EXTRACT_NUMBER_AND_INCR(k, p);	/* Skip the n.  */
	continue;
d2610 2
a2611 2
	  /* Get to the number of times to succeed.  */
	  EXTRACT_NUMBER(k, p + 2);
d2613 1
a2613 1
	  if (k == 0) {
d2619 1
a2619 1
	  continue;
d2622 2
a2623 2
	  p += 4;
	  continue;
d2625 1
a2625 1
	case start_memory:
d2634 5
a2638 7
	  {
	    char ex = (options & RE_OPTION_POSIX)?'\0':'\n';

	    for (j = 0; j < (1 << BYTEWIDTH); j++) {
	      if (j != ex) fastmap[j] = 1;
	    }
	    if (bufp->can_be_null) {
a2640 1
	  }
d2692 1
a2692 1
	     multi-byte char.  See set_list_bits().  */
d2730 2
a2731 2
	     ___      _   _
	     s+m = (S*s+M*m).  */
d2734 1
a2734 1
	     multi-byte chars.  See set_list_bits(). */
d2785 10
a2794 10
    /* Get here means we have successfully found the possible starting
       characters of one path of the pattern.  We need not follow this
       path any farther.  Instead, look at the next alternative
       remembered in the stack.  */
    if (stackp != stackb)
      p = *stackp--;		/* pop */
    else
      break;
  }
  FREE_AND_RETURN_VOID(stackb);
d2813 1
a2813 1
     const char *string;
d2826 1
a2826 1
    re_compile_fastmap(bufp);
d2883 15
a2897 14
  for (;;) {
    /* If a fastmap is supplied, skip quickly over characters that
       cannot possibly be the start of a match.  Note, however, that
       if the pattern can possibly match the null string, we must
       test it at each starting point so that we take the first null
       string we get.  */

    if (fastmap && startpos < size
	&& bufp->can_be_null != 1 && !(anchor && startpos == 0))
      {
	if (range > 0)	/* Searching forwards.  */
	  {
	    register unsigned char *p, c;
	    int irange = range;
d2899 1
a2899 1
	    p = (unsigned char*)string+startpos;
d2901 17
a2917 16
	    while (range > 0) {
	      c = *p++;
	      if (ismbchar(c)) {
		int len = mbclen(c) - 1;
		if (fastmap[c])
		  break;
		p += len;
		range -= len + 1;
		c = *p;
		if (fastmap[c] == 2)
		  break;
	      }
	      else {
		if (fastmap[MAY_TRANSLATE() ? translate[c] : c])
		  break;
		range--;
d2919 10
d2930 1
a2930 5
	    startpos += irange - range;
	  }
	else			/* Searching backwards.  */
	  {
	    register unsigned char c;
d2932 7
a2938 6
	    c = string[startpos];
	    c &= 0xff;
	    if (MAY_TRANSLATE() ? !fastmap[translate[c]] : !fastmap[c])
	      goto advance;
	  }
      }
d2940 5
a2944 7
    if (startpos > size) return -1;
    if (anchor && size > 0 && startpos == size) return -1;
    val = re_match(bufp, string, size, startpos, regs);
    if (val >= 0)
      return startpos;
    if (val == -2)
      return -2;
d2948 1
a2948 1
    alloca(0);
d2952 6
a2957 5
    if (range > 0) {
      if (anchor && startpos < size && startpos > 0 && string[startpos-1] != '\n') {
	while (range > 0 && string[startpos] != '\n') {
	  range--;
	  startpos++;
d2959 21
a2979 16
      }
      else if (fastmap && (bufp->stclass)) {
	register unsigned char *p;
	unsigned int c;
	int irange = range;

	p = (unsigned char*)string+startpos;
	while (range > 0) {
	  c = *p++;
	  if (ismbchar(c) && fastmap[c] != 2) {
	    MBC2WC(c, p);
	  }
	  else if (MAY_TRANSLATE())
	    c = translate[c];
	  if (*bufp->stclass == charset) {
	    if (!is_in_list(c, bufp->stclass+1)) break;
d2981 1
a2981 5
	  else {
	    if (is_in_list(c, bufp->stclass+1)) break;
	  }
	  range--;
	  if (c > 256) range--;
a2982 1
	startpos += irange - range;
a2983 7
    }

  advance:
    if (!range) 
      break;
    else if (range > 0) {
      const char *d = string + startpos;
d2985 9
a2993 19
      if (ismbchar(*d)) {
	int len = mbclen(*d) - 1;
	range-=len, startpos+=len;
	if (!range)
	  break;
      }
      range--, startpos++;
    }
    else {
      range++, startpos--;
      {
	const char *s, *d, *p;

	s = string; d = string + startpos;
	for (p = d; p-- > s && ismbchar(*p); )
	  /* --p >= s would not work on 80[12]?86. 
	     (when the offset of s equals 0 other than huge model.)  */
	  ;
	if (!((d - p) & 1)) {
d2996 18
a3013 1
	  range++, startpos--;
a3016 1
  }
d3032 4
a3035 3
  struct {
    /* This field is one if this group can match the empty string,
       zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
d3080 2
a3081 1
    if (stacke - stackp <= NUM_FAILURE_ITEMS) {				\
d3085 4
a3088 4
	   {								\
	   FREE_VARIABLES();						\
	   FREE_AND_RETURN(stackb,(-2));				\
	   }*/								\
d3095 6
a3100 5
    for (this_reg = 1; this_reg <= last_used_reg; this_reg++) {		\
      *stackp++ = regstart[this_reg];					\
      *stackp++ = regend[this_reg];					\
      *stackp++ = reg_info[this_reg].word;				\
    }									\
d3111 1
a3111 1
     /* This pops what PUSH_FAILURE_POINT pushes.  */
d3122 1
a3122 1
     /* Registers are set to a sentinel when they haven't yet matched.  */
d3128 1
a3128 1
     /* Call this when have matched something; it sets `matched' flags for the
d3133 2
a3134 1
    for (this_reg = 0; this_reg < num_regs; this_reg++) { 		\
d3159 2
a3160 2
     struct re_registers *regs;
     unsigned int num_regs;
d3162 1
a3162 1
  int i;
d3164 16
a3179 16
  regs->num_regs = num_regs;
  if (num_regs < RE_NREGS)
    num_regs = RE_NREGS;

  if (regs->allocated == 0) {
    regs->beg = TMALLOC(num_regs, int);
    regs->end = TMALLOC(num_regs, int);
    regs->allocated = num_regs;
  }
  else if (regs->allocated < num_regs) {
    TREALLOC(regs->beg, num_regs, int);
    TREALLOC(regs->end, num_regs, int);
  }
  for (i=0; i<num_regs; i++) {
    regs->beg[i] = regs->end[i] = -1;
  }
d3200 1
a3200 1
     const char *string_arg;
d3218 9
a3226 9
  /* Failure point stack.  Each place that can handle a failure further
     down the line pushes a failure point on this stack.  It consists of
     restart, regend, and reg_info for all registers corresponding to the
     subexpressions we're currently inside, plus the number of such
     registers, and, finally, two char *'s.  The first char * is where to
     resume scanning the pattern; the second one is where to resume
     scanning the strings.  If the latter is zero, the failure point is a
     ``dummy''; if a failure happens and the failure point is a dummy, it
     gets discarded and the next next one is tried.  */
d3318 2
a3319 1
  for (;;) {
d3321 4
a3324 4
    fprintf(stderr,
	    "regex loop(%d):  matching 0x%02d\n",
	    p - (unsigned char*)bufp->buffer,
	    *p);
d3326 32
a3357 13
    /* End of pattern means we might have succeeded.  */
    if (p == pend)
      {
	/* If not end of string, try backtracking.  Otherwise done.  */
	if (d != dend)
	  {
	    while (stackp != stackb && (int)stackp[-1] == 1) {
	      if (best_regs_set) /* non-greedy, no need to backtrack */
		goto restore_best_regs;
	      POP_FAILURE_POINT();
	    }
	    if (stackp != stackb) {
	      /* More failure points to try.  */
d3359 7
a3365 17
	      /* If exceeds best match so far, save it.  */
	      if (! best_regs_set || (d > best_regend[0])) {
		best_regs_set = 1;
		best_regend[0] = d;	/* Never use regstart[0].  */

		for (mcnt = 1; mcnt < num_regs; mcnt++) {
		  best_regstart[mcnt] = regstart[mcnt];
		  best_regend[mcnt] = regend[mcnt];
		}
	      }
	      goto fail;	       
	    }
	    /* If no failure points, don't restore garbage.  */
	    else if (best_regs_set) {
	    restore_best_regs:
	      /* Restore best match.  */
	      d = best_regend[0];
d3367 7
a3373 1
	      for (mcnt = 0; mcnt < num_regs; mcnt++)
d3375 8
a3382 2
		  regstart[mcnt] = best_regstart[mcnt];
		  regend[mcnt] = best_regend[mcnt];
d3385 3
a3387 23
	  }

	/* If caller wants register contents data back, convert it 
	   to indices.  */
	if (regs)
	  {
	    regs->beg[0] = pos;
	    regs->end[0] = d - string;
	    for (mcnt = 1; mcnt < num_regs; mcnt++)
	      {
		if (REG_UNSET(regend[mcnt]))
		  {
		    regs->beg[mcnt] = -1;
		    regs->end[mcnt] = -1;
		    continue;
		  }
		regs->beg[mcnt] = regstart[mcnt] - string;
		regs->end[mcnt] = regend[mcnt] - string;
	      }
	  }
	FREE_VARIABLES();
	FREE_AND_RETURN(stackb, (d - pos - string));
      }
d3389 1
a3389 1
    /* Otherwise match next pattern command.  */
d3391 1
a3391 1
    switch ((int)((enum regexpcode)*p++))
d3397 4
a3400 4
	  /* ( [or `(', as appropriate] is represented by start_memory,
	     ) by stop_memory.  Both of those commands are followed by
	     a register number in the next byte.  The text matched
	     within the ( and ) is recorded under that number.  */
d3402 1
a3402 1
	  /* Find out if this group can match the empty string.  */
d3404 16
a3419 16
	  if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
	    REG_MATCH_NULL_STRING_P (reg_info[*p]) 
	      = group_match_null_string_p (&p1, pend, reg_info);

	  /* Save the position in the string where we were the last time
	     we were at this open-group operator in case the group is
	     operated upon by a repetition operator, e.g., with `(a*)*b'
	     against `ab'; then we want to ignore where we are now in
	     the string in case this attempt to match fails.  */
	  old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
	    ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
	    : regstart[*p];
	  regstart[*p] = d;
	  IS_ACTIVE(reg_info[*p]) = 1;
	  MATCHED_SOMETHING(reg_info[*p]) = 0;
	  p += 2;
d3423 8
a3430 8
	  /* We need to save the string position the last time we were at
	     this close-group operator in case the group is operated
	     upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
	     against `aba'; then we want to ignore where we are now in
	     the string in case this attempt to match fails.  */
	  old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
	    ? REG_UNSET (regend[*p]) ? d : regend[*p]
	    : regend[*p];
d3432 2
a3433 2
	  regend[*p] = d;
	  IS_ACTIVE(reg_info[*p]) = 0;
d3435 1
a3435 1
	  /* If just failed to match something this time around with a sub-
d3437 1
a3437 1
	  if ((p + 1) != pend &&
d3440 1
a3440 1
	    {
d3442 12
a3453 12
	      mcnt = 0;
	      switch (*p1++)
		{
		case jump_n:
		case finalize_push_n:
		case finalize_jump:
		case maybe_finalize_jump:
		case jump:
		case dummy_failure_jump:
		  EXTRACT_NUMBER_AND_INCR(mcnt, p1);
		  break;
		}
d3456 4
a3459 4
	      /* If the next operation is a jump backwards in the pattern
		 to an on_failure_jump, exit from the loop by forcing a
		 failure after pushing on the stack the on_failure_jump's 
		 jump in the pattern, and d.  */
d3461 1
a3461 1
		  && (enum regexpcode)p1[3] == start_memory && p1[4] == *p)
d3463 11
a3473 11
		  /* If this group ever matched anything, then restore
		     what its registers were before trying this last
		     failed match, e.g., with `(a*)*b' against `ab' for
		     regstart[1], and, e.g., with `((a*)*(b*)*)*'
		     against `aba' for regend[3].

		     Also restore the registers for inner groups for,
		     e.g., `((a*)(b*))*' against `aba' (register 3 would
		     otherwise get trashed).  */

		  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
d3476 3
a3478 3

		      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;

d3480 9
a3488 9
		      for (r = *p; r < *p + *(p + 1); r++)
			{
			  regstart[r] = old_regstart[r];

			  /* xx why this test?  */
			  if ((int)old_regend[r] >= (int)regstart[r])
			    regend[r] = old_regend[r];
			}     
		    }
d3490 6
a3495 6
		  EXTRACT_NUMBER_AND_INCR(mcnt, p1);
		  PUSH_FAILURE_POINT(p1 + mcnt, d);
		  goto fail;
		}
	    }
	  p += 2;
d3501 3
a3503 3
	  /* \<digit> has been turned into a `duplicate' command which is
	     followed by the numeric value of <digit> as the register number.  */
	case duplicate:
d3511 1
a3511 1
	    d2 = regstart[regno];
d3514 4
a3517 4
	    /* Where to stop matching; if both the place to start and
	       the place to stop matching are in the same string, then
	       set to the place to stop, otherwise, for now have to use
	       the end of the first string.  */
d3519 1
a3519 1
	    dend2 = regend[regno];
d3533 2
a3534 2
		   one shot, so, if necessary, adjust the count.  */
		if (mcnt > dend2 - d2)
d3538 1
a3538 1
		   past them.  */
d3540 2
a3541 2
		    ? memcmp_translate(d, d2, mcnt) 
		    : memcmp((char*)d, (char*)d2, mcnt))
d3549 1
a3549 1
	  PUSH_FAILURE_POINT(0, d);
d3569 1
d3571 1
a3571 1
	    if (d + mbclen(*d) > dend)
d3577 1
a3577 2
	  if (((TRANSLATE_P()) ? translate[*d] : *d) ==
	      ((options&RE_OPTION_POSIX) ? '\0' : '\n'))
d3580 1
a3580 1
	  d++;
d3603 1
a3603 1
	      not = !not;
d3615 6
a3620 5
	  if (size == 0 || AT_STRINGS_BEG(d))
	    break;
	  if (d[-1] == '\n' && !AT_STRINGS_END(d))
	    break;
	  goto fail;
d3623 1
a3623 5
	  if (AT_STRINGS_END(d)) {
	    if (size == 0 || d[-1] != '\n')
	      break;
	  }
	  else if (*d == '\n')
d3627 1
a3627 1
	  /* Match at the very beginning of the string. */
d3629 3
a3631 3
	  if (AT_STRINGS_BEG(d))
	    break;
	  goto fail;
d3633 2
a3634 2
	  /* Match at the very end of the data. */
	case endbuf:
d3637 1
a3637 1
	  goto fail;
d3639 2
a3640 2
	  /* Match at the very end of the data. */
	case endbuf2:
d3646 1
a3646 1
	  goto fail;
d3648 12
a3659 12
	  /* `or' constructs are handled by starting each alternative with
	     an on_failure_jump that points to the start of the next
	     alternative.  Each alternative except the last ends with a
	     jump to the joining point.  (Actually, each jump except for
	     the last one really jumps to the following jump, because
	     tensioning the jumps is a hassle.)  */

	  /* The start of a stupid repeat has an on_failure_jump that points
	     past the end of the repeat text. This makes a failure point so 
	     that on failure to match a repetition, matching restarts past
	     as many repetitions have been found with no way to fail and
	     look for another one.  */
d3661 2
a3662 2
	  /* A smart repeat is similar but loops back to the on_failure_jump
	     so that each repetition makes another failure point.  */
d3665 4
a3668 4
	on_failure:
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	PUSH_FAILURE_POINT(p + mcnt, d);
	continue;
d3673 1
a3673 1
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
d3677 12
a3688 12
	    /* Compare the beginning of the repeat with what in the
	       pattern follows its end. If we can establish that there
	       is nothing that they would both match, i.e., that we
	       would have to backtrack because of (as in, e.g., `a*a')
	       then we can change to pop_failure_jump, because we'll
	       never have to backtrack.

	       This is not true in the case of alternatives: in
	       `(a|ab)*' we do need to backtrack to the `ab' alternative
	       (e.g., if the string was `ab').  But instead of trying to
	       detect that here, the alternative has put on a dummy
	       failure point which is what we will end up popping.  */
d3714 12
a3725 4
		  int not;
		  if (ismbchar(c)) {
		    unsigned char *pp = p2+3;
		    MBC2WC(c, pp);
a3726 8
		  /* `is_in_list()' is TRUE if c would match */
		  /* That means it is not safe to finalize.  */
		  not = is_in_list(c, p1 + 4);
		  if (p1[3] == (unsigned char)charset_not)
		    not = !not;
		  if (!not)
		    p[-3] = (unsigned char)finalize_jump;
		}
d3735 1
a3735 1
	  /* Note fall through.  */
d3737 8
a3744 8
	  /* The end of a stupid repeat has a finalize_jump back to the
	     start, where another failure point will be made which will
	     point to after all the repetitions found so far.  */

	  /* Take off failure points put on by matching on_failure_jump 
	     because didn't fail.  Also remove the register information
	     put on by the on_failure_jump.  */
	case finalize_jump:
d3750 1
a3750 1
	  POP_FAILURE_POINT(); 
d3753 2
a3754 2
	  /* Jump without taking off any failure points.  */
	case jump:
d3756 3
a3758 28
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	p += mcnt;
	continue;

	/* We need this opcode so we can detect where alternatives end
	   in `group_match_null_string_p' et al.  */
	case jump_past_alt:
	  goto nofinalize;

	case dummy_failure_jump:
	  /* Normally, the on_failure_jump pushes a failure point, which
	     then gets popped at finalize_jump.  We will end up at
	     finalize_jump, also, and with a pattern of, say, `a+', we
	     are skipping over the on_failure_jump, so we have to push
	     something meaningless for finalize_jump to pop.  */
	  PUSH_FAILURE_POINT(0, 0);
	  goto nofinalize;

	  /* At the end of an alternative, we need to push a dummy failure
	     point in case we are followed by a `finalize_jump', because
	     we don't want the failure point for the alternative to be
	     popped.  For example, matching `(a|ab)*' against `aab'
	     requires that we match the `ab' alternative.  */
	case push_dummy_failure:
	  /* See comments just above at `dummy_failure_jump' about the
	     two zeroes.  */
	  PUSH_FAILURE_POINT(0, 0);
	  break;
d3760 37
a3796 12
	  /* Have to succeed matching what follows at least n times.  Then
	     just handle like an on_failure_jump.  */
	case succeed_n: 
	  EXTRACT_NUMBER(mcnt, p + 2);
	  /* Originally, this is how many times we HAVE to succeed.  */
	  if (mcnt > 0)
	    {
	      mcnt--;
	      p += 2;
	      STORE_NUMBER_AND_INCR(p, mcnt);
	      PUSH_FAILURE_POINT(0, 0);
	    }
d3798 1
a3798 1
	    {
d3800 3
a3802 3
	      p[3] = unused;
	      goto on_failure;
	    }
d3805 11
a3815 11
	case jump_n:
	  EXTRACT_NUMBER(mcnt, p + 2);
	  /* Originally, this is how many times we CAN jump.  */
	  if (mcnt)
	    {
	      mcnt--;
	      STORE_NUMBER(p + 2, mcnt);
	      goto nofinalize;	     /* Do the jump without taking off
					any failure points.  */
	    }
	  /* If don't have to jump any more, skip over the rest of command.  */
d3837 1
a3837 1
	  POP_FAILURE_POINT();
d3839 1
a3839 1
	  PUSH_FAILURE_POINT(p + mcnt, d);
d3844 3
a3846 3
	  EXTRACT_NUMBER(mcnt, p + 2); 
	  /* Originally, this is how many times we CAN jump.  */
	  if (mcnt) {
d3860 1
a3860 1
	  /* If don't have to push any more, skip over the rest of command.  */
d3865 3
a3867 3
	  /* Ignore these.  Used to ignore the n of succeed_n's which
	     currently have n == 0.  */
	case unused:
d3870 1
a3870 1
	case casefold_on:
d3874 1
a3874 1
	case casefold_off:
d3878 1
a3878 9
	case posix_on:
	  options |= RE_OPTION_POSIX;
	  continue;

	case posix_off:
	  options &= ~RE_OPTION_POSIX;
	  continue;

	case wordbound:
d3907 1
a3907 1
	  goto fail;
d3911 1
a3911 1
	      && (!IS_A_LETTER(d) || AT_STRINGS_END(d)))
d3913 1
a3913 1
	  goto fail;
d3917 2
a3918 2
	  if (!IS_A_LETTER(d))
	    goto fail;
d3928 1
a3928 1
	    goto fail;
d3932 1
a3932 1
	  SET_REGS_MATCHED;
d3940 2
a3941 2
	     testing `translate' inside the loop.  */
	  if (TRANSLATE_P())
d3988 1
a3988 1
	  break;
d3991 2
a3992 2
    while (stackp != stackb && (int)stackp[-1] == 1)
      POP_FAILURE_POINT();
d3994 1
a3994 1
    continue;  /* Successfully executed one pattern command; keep going.  */
d3997 5
a4001 25
  fail:
    if (stackp != stackb)
      /* A restart point is known.  Restart there and pop it. */
      {
	short last_used_reg, this_reg;

	/* If this failure point is from a dummy_failure_point, just
	   skip it.  */
	if (stackp[-3] == 0) {
	  POP_FAILURE_POINT();
	  goto fail;
	}
	stackp--;		/* discard flag */
	d = *--stackp;
	p = *--stackp;
	/* Restore register info.  */
	last_used_reg = (long)*--stackp;

	/* Make the ones that weren't saved -1 or 0 again. */
	for (this_reg = num_regs - 1; this_reg > last_used_reg; this_reg--) {
	  regend[this_reg] = REG_UNSET_VALUE;
	  regstart[this_reg] = REG_UNSET_VALUE;
	  IS_ACTIVE(reg_info[this_reg]) = 0;
	  MATCHED_SOMETHING(reg_info[this_reg]) = 0;
	}
d4003 42
a4044 19
	/* And restore the rest from the stack.  */
	for ( ; this_reg > 0; this_reg--) {
	  reg_info[this_reg].word = *--stackp;
	  regend[this_reg] = *--stackp;
	  regstart[this_reg] = *--stackp;
	}
	if (p < pend) {
	  int is_a_jump_n = 0;
	  int failed_paren = 0;

	  p1 = p;
	  /* If failed to a backwards jump that's part of a repetition
	     loop, need to pop this failure point and use the next one.  */
	pop_loop:
	  switch ((enum regexpcode)*p1) {
	  case stop_paren:
	    failed_paren = 1;
	    p1++;
	    goto pop_loop;
d4046 7
a4052 15
	  case jump_n:
	  case finalize_push_n:
	    is_a_jump_n = 1;
	  case maybe_finalize_jump:
	  case finalize_jump:
	  case finalize_push:
	  case jump:
	    p1++;
	    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
	    p1 += mcnt;

	    if (p1 >= pend) break;
	    if (( is_a_jump_n && (enum regexpcode)*p1 == succeed_n) ||
		(!is_a_jump_n && (enum regexpcode)*p1 == on_failure_jump)) {
	      if (failed_paren) {
d4054 16
a4069 2
		EXTRACT_NUMBER_AND_INCR(mcnt, p1);
		PUSH_FAILURE_POINT(p1 + mcnt, d);
d4071 5
a4075 11
	      goto fail;
	    }
	    break;
	  default:
	    /* do nothing */ ;
	  }
	}
      }
    else
      break;   /* Matching at this starting point really fails.  */
  }
d4085 1
a4085 1

d4088 1
a4088 1

d4096 2
a4097 2
     unsigned char **p, *end;
     register_info_type *reg_info;
d4102 16
d4119 38
a4156 51
  while (p1 < end) {
    /* Skip over opcodes that can match nothing, and return true or
       false, as appropriate, when we get to one that can't, or to the
       matching stop_memory.  */

    switch ((enum regexpcode)*p1) {
      /* Could be either a loop or a series of alternatives.  */
    case on_failure_jump:
      p1++;
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);

      /* If the next operation is not a jump backwards in the
	 pattern.  */

      if (mcnt >= 0)
	{
	  /* Go through the on_failure_jumps of the alternatives,
	     seeing if any of the alternatives cannot match nothing.
	     The last alternative starts with only a jump,
	     whereas the rest start with on_failure_jump and end
	     with a jump, e.g., here is the pattern for `a|b|c':

	     /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
	     /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
	     /exactn/1/c						

	     So, we have to first go through the first (n-1)
	     alternatives and then deal with the last one separately.  */


	  /* Deal with the first (n-1) alternatives, which start
	     with an on_failure_jump (see above) that jumps to right
	     past a jump_past_alt.  */

	  while ((enum regexpcode)p1[mcnt-3] == jump_past_alt) {
	    /* `mcnt' holds how many bytes long the alternative
	       is, including the ending `jump_past_alt' and
	       its number.  */

	    if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
					  reg_info))
	      return 0;

	    /* Move to right after this alternative, including the
	       jump_past_alt.  */
	    p1 += mcnt;	

	    /* Break if it's the beginning of an n-th alternative
	       that doesn't begin with an on_failure_jump.  */
	    if ((enum regexpcode)*p1 != on_failure_jump)
	      break;
d4158 16
a4173 15
	    /* Still have to check that it's not an n-th
	       alternative that starts with an on_failure_jump.  */
	    p1++;
	    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
	    if ((enum regexpcode)p1[mcnt-3] != jump_past_alt) {
	      /* Get to the beginning of the n-th alternative.  */
	      p1 -= 3;
	      break;
	    }
	  }

	  /* Deal with the last alternative: go back and get number
	     of the `jump_past_alt' just before it.  `mcnt' contains
	     the length of the alternative.  */
	  EXTRACT_NUMBER (mcnt, p1 - 2);
d4175 2
a4176 2
	  if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
	    return 0;
d4178 15
a4192 15
	  p1 += mcnt;	/* Get past the n-th alternative.  */
	} /* if mcnt > 0 */
      break;


    case stop_memory:
      *p = p1 + 2;
      return 1;


    default: 
      if (!common_op_match_null_string_p (&p1, end, reg_info))
	return 0;
    }
  } /* while p1 < end */
d4201 1
a4201 1

d4204 2
a4205 2
     unsigned char *p, *end;
     register_info_type *reg_info;
d4209 20
a4228 18

  while (p1 < end) {
    /* Skip over opcodes that can match nothing, and break when we get 
       to one that can't.  */

    switch ((enum regexpcode)*p1) {
      /* It's a loop.  */
    case on_failure_jump:
      p1++;
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
      p1 += mcnt;
      break;

    default: 
      if (!common_op_match_null_string_p (&p1, end, reg_info))
	return 0;
    }
  }  /* while p1 < end */
d4236 1
a4236 1

d4241 2
a4242 2
     unsigned char **p, *end;
     register_info_type *reg_info;
d4249 12
a4260 11
  switch ((enum regexpcode)*p1++) {
  case unused:
  case begline:
  case endline:
  case begbuf:
  case endbuf:
  case endbuf2:
  case wordbeg:
  case wordend:
  case wordbound:
  case notwordbound:
d4262 3
a4264 3
  case before_dot:
  case at_dot:
  case after_dot:
d4266 1
a4266 1
    break;
d4268 6
a4273 3
  case start_memory:
    reg_no = *p1;
    ret = group_match_null_string_p (&p1, end, reg_info);
d4275 2
a4276 2
    /* Have to set this here in case we're checking a group which
       contains a group and a back reference to it.  */
d4278 12
a4289 2
    if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
      REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
d4291 4
a4294 3
    if (!ret)
      return 0;
    break;
d4296 9
a4304 8
    /* If this is an optimized succeed_n for zero times, make the jump.  */
  case jump:
    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    if (mcnt >= 0)
      p1 += mcnt;
    else
      return 0;
    break;
d4306 4
a4309 4
  case succeed_n:
    /* Get to the number of times to succeed.  */
    p1 += 2;		
    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
d4311 2
a4312 8
    if (mcnt == 0) {
      p1 -= 4;
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
      p1 += mcnt;
    }
    else
      return 0;
    break;
d4314 2
a4315 2
  case duplicate: 
    if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
a4316 8
    break;

  case set_number_at:
    p1 += 4;

  default:
    /* All other opcodes mean we cannot match the empty string.  */
    return 0;
d4330 13
a4342 8
  while (len) {
    c = *p1++;
    if (ismbchar(c)) {
      int n;

      if (c != *p2++) return 1;
      for (n = mbclen(c) - 1; n > 0; n--)
	if (!--len || *p1++ != *p2++)
d4344 1
a4345 5
    else
      if (translate[c] != translate[*p2++])
	return 1;
    len--;
  }
d4353 1
a4353 1
  int i;
d4355 16
a4370 16
  if (regs1 == regs2) return;
  if (regs1->allocated == 0) {
    regs1->beg = TMALLOC(regs2->num_regs, int);
    regs1->end = TMALLOC(regs2->num_regs, int);
    regs1->allocated = regs2->num_regs;
  }
  else if (regs1->allocated < regs2->num_regs) {
    TREALLOC(regs1->beg, regs2->num_regs, int);
    TREALLOC(regs1->end, regs2->num_regs, int);
    regs1->allocated = regs2->num_regs;
  }
  for (i=0; i<regs2->num_regs; i++) {
    regs1->beg[i] = regs2->beg[i];
    regs1->end[i] = regs2->end[i];
  }
  regs1->num_regs = regs2->num_regs;
d4377 3
a4379 3
  if (regs->allocated == 0) return;
  if (regs->beg) free(regs->beg);
  if (regs->end) free(regs->end);
@


1.1.1.3.2.11
log
@*** empty log message ***
@
text
@d3399 1
a3399 1
    switch ((enum regexpcode)*p++)
d4022 1
a4022 1
	if (stackp[-3] == 0 || (best_regs_set && stackp[-1] == 1)) {
@


1.1.1.3.2.12
log
@*** empty log message ***
@
text
@d144 2
a145 2
#define EXPAND_FAIL_STACK(stackx,stackb,len) 				\
    do {								\
d404 1
a404 1
       (source) += 2; } while (0)
d446 14
a459 14
#define MBC2WC(c, p)							\
  do {									\
    if (current_mbctype == MBCTYPE_UTF8) {				\
      int n = mbclen(c) - 1;						\
      int c1;								\
      c &= (1<<(BYTEWIDTH-2-n)) - 1;					\
      while (n--) {							\
	c = c << 6 | *p++ & ((1<<6)-1);					\
      }									\
    }									\
    else {								\
      c <<= 8;								\
      c |= (unsigned char)*(p)++;					\
    }									\
d462 4
a465 4
#define PATFETCH_MBC(c)							\
  do {									\
    if (p + mbclen(c) - 1 >= pend) goto end_of_pattern;			\
    MBC2WC(c, p);							\
d468 1
a468 1
#define WC2MBC1ST(c)							\
d1184 8
a1191 7
	while (p0 != pend) {
	  if (*p0 == '\\' && p0 + 1 != pend
	      && (p0[1] == 'b' || p0[1] == 'B'))
	    p0 += 2;
	  else
	    break;
	}
d1282 5
a1286 4
      if (*p == '^') {
	BUFPUSH(charset_not); 
	p++;
      }
d1307 4
a1310 14
      for (;;) {
	int size;
	unsigned last = (unsigned)-1;

	if ((size = EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH]))
	    || current_mbctype) {
	  /* Ensure the space is enough to hold another interval
	     of multi-byte chars in charset(_not)?.  */
	  size = (1 << BYTEWIDTH) / BYTEWIDTH + 2 + size*8 + 8;
	  while (b + size + 1 > bufp->buffer + bufp->allocated)
	    EXTEND_BUFFER;
	}
      range_retry:
	PATFETCH(c);
d1312 7
a1318 4
	if (c == ']') {
	  if (p == p0 + 1) {
	    if (p == pend)
	      goto invalid_pattern;
d1320 2
a1321 14
	  else 
	    /* Stop if this isn't merely a ] inside a bracket
	       expression, but rather the end of a bracket
	       expression.  */
	    break;
	}
	/* Look ahead to see if it's a range when the last thing
	   was a character class.  */
	if (had_char_class && c == '-' && *p != ']')
	  goto invalid_pattern;
	if (ismbchar(c)) {
	  PATFETCH_MBC(c);
	  had_mbchar++;
	}
d1323 4
a1326 9
	/* \ escapes characters when inside [...].  */
	if (c == '\\') {
	  PATFETCH(c);
	  switch (c) {
	  case 'w':
	    for (c = 0; c < (1 << BYTEWIDTH); c++) {
	      if (SYNTAX(c) == Sword ||
		  (!current_mbctype && SYNTAX(c) == Sword2))
		SET_LIST_BIT(c);
d1328 14
a1341 5
	    if (current_mbctype) {
	      set_list_bits(0x80, 0xffffffff, b);
	    }
	    last = -1;
	    continue;
d1343 15
a1357 8
	  case 'W':
	    for (c = 0; c < (1 << BYTEWIDTH); c++) {
	      if (SYNTAX(c) != Sword &&
		  (current_mbctype || SYNTAX(c) != Sword2))
		SET_LIST_BIT(c);
	    }
	    last = -1;
	    continue;
d1359 8
a1366 6
	  case 's':
	    for (c = 0; c < 256; c++)
	      if (ISSPACE(c))
		SET_LIST_BIT(c);
	    last = -1;
	    continue;
d1368 6
a1373 8
	  case 'S':
	    for (c = 0; c < 256; c++)
	      if (!ISSPACE(c))
		SET_LIST_BIT(c);
	    if (current_mbctype)
	      set_list_bits(0x80, 0xffffffff, b);
	    last = -1;
	    continue;
d1375 9
a1383 5
	  case 'd':
	    for (c = '0'; c <= '9'; c++)
	      SET_LIST_BIT(c);
	    last = -1;
	    continue;
d1385 2
a1386 3
	  case 'D':
	    for (c = 0; c < 256; c++)
	      if (!ISDIGIT(c))
d1388 2
a1389 4
	    if (current_mbctype)
	      set_list_bits(0x80, 0xffffffff, b);
	    last = -1;
	    continue;
d1391 9
a1399 4
	  case 'x':
	    c = scan_hex(p, 2, &numlen);
	    p += numlen;
	    break;
d1401 4
a1404 6
	  case '0': case '1': case '2': case '3': case '4':
	  case '5': case '6': case '7': case '8': case '9':
	    PATUNFETCH;
	    c = scan_oct(p, 3, &numlen);
	    p += numlen;
	    break;
d1406 6
a1411 8
	  default:
	    if (ismbchar(c)) {
	      PATFETCH_MBC(c);
	      had_mbchar++;
	    }
	    break;
	  }
	}
d1413 5
a1417 39
	/* Get a range.  */
	if (range) {
	  if (last > c)
	    goto invalid_pattern;

	  range = 0;
	  if (had_mbchar == 0) {
	    for (;last<=c;last++)
	      SET_LIST_BIT(last);
	  }
	  else if (had_mbchar == 2) {
	    set_list_bits(last, c, b);
	  }
	  else {
	    /* restriction: range between sbc and mbc */
	    goto invalid_pattern;
	  }
	}
	else if (p[0] == '-' && p[1] != ']') {
	  last = c;
	  PATFETCH(c1);
	  range = 1;
	  goto range_retry;
	}
	else if (c == '[' && *p == ':') {
	  /* Leave room for the null.  */
	  char str[CHAR_CLASS_MAX_LENGTH + 1];

	  PATFETCH_RAW (c);
	  c1 = 0;

	  /* If pattern is `[[:'.  */
	  if (p == pend) 
	    goto invalid_pattern;

	  for (;;) {
	    PATFETCH (c);
	    if (c == ':' || c == ']' || p == pend
		|| c1 == CHAR_CLASS_MAX_LENGTH)
d1419 1
a1419 1
	    str[c1++] = c;
a1420 1
	  str[c1] = '\0';
d1422 4
a1425 17
	  /* If isn't a word bracketed by `[:' and:`]':
	     undo the ending character, the letters, and leave 
	     the leading `:' and `[' (but set bits for them).  */
	  if (c == ':' && *p == ']') {
	    int ch;
	    char is_alnum = STREQ(str, "alnum");
	    char is_alpha = STREQ(str, "alpha");
	    char is_blank = STREQ(str, "blank");
	    char is_cntrl = STREQ(str, "cntrl");
	    char is_digit = STREQ(str, "digit");
	    char is_graph = STREQ(str, "graph");
	    char is_lower = STREQ(str, "lower");
	    char is_print = STREQ(str, "print");
	    char is_punct = STREQ(str, "punct");
	    char is_space = STREQ(str, "space");
	    char is_upper = STREQ(str, "upper");
	    char is_xdigit = STREQ(str, "xdigit");
d1427 10
a1436 1
	    if (!IS_CHAR_CLASS (str))
d1438 11
d1450 2
a1451 2
	    /* Throw away the ] at the end of the character class.  */
	    PATFETCH (c);
d1453 1
d1457 61
a1517 14
	    for (ch = 0; ch < 1 << BYTEWIDTH; ch++) {
	      if (   (is_alnum  && ISALNUM(ch))
		  || (is_alpha  && ISALPHA(ch))
		  || (is_blank  && ISBLANK(ch))
		  || (is_cntrl  && ISCNTRL(ch))
		  || (is_digit  && ISDIGIT(ch))
		  || (is_graph  && ISGRAPH(ch))
		  || (is_lower  && ISLOWER(ch))
		  || (is_print  && ISPRINT(ch))
		  || (is_punct  && ISPUNCT(ch))
		  || (is_space  && ISSPACE(ch))
		  || (is_upper  && ISUPPER(ch))
		  || (is_xdigit && ISXDIGIT(ch)))
		SET_LIST_BIT (ch);
a1518 10
	    had_char_class = 1;
	  }
	  else {
	    c1++;
	    while (c1--)    
	      PATUNFETCH;
	    SET_LIST_BIT(TRANSLATE_P()?translate['[']:'[');
	    SET_LIST_BIT(TRANSLATE_P()?translate[':']:':');
	    had_char_class = 0;
	    last = ':';
d1520 5
a1525 6
	else if (had_mbchar == 0)
	  SET_LIST_BIT(c);
	else
	  set_list_bits(c, c, b);
	had_mbchar = 0;
      }
d1683 11
a1693 11
      if (fixup_alt_jump) {
	/* Push a dummy failure point at the end of the
	   alternative for a possible future
	   `finalize_jump' to pop.  See comments at
	   `push_dummy_failure' in `re_match'.  */
	BUFPUSH(push_dummy_failure);

	/* We allocated space for this jump when we assigned
	   to `fixup_alt_jump', in the `handle_alt' case below.  */
	store_jump(fixup_alt_jump, jump, b);
      }
d1775 4
a1778 3
      if (!laststart || p == pend) {
	goto normal_char;
      }
d1875 31
a1905 31
	if (upper_bound > 1) {
	  /* More than one repetition is allowed, so
	     append a backward jump to the `succeed_n'
	     that starts this interval.

	     When we've reached this during matching,
	     we'll have matched the interval once, so
	     jump back only `upper_bound - 1' times.  */
	  GET_BUFFER_SPACE(5);
	  store_jump_n(b, greedy?jump_n:finalize_push_n, laststart + 5,
		       upper_bound - 1);
	  b += 5;

	  /* The location we want to set is the second
	     parameter of the `jump_n'; that is `b-2' as
	     an absolute address.  `laststart' will be
	     the `set_number_at' we're about to insert;
	     `laststart+3' the number to set, the source
	     for the relative address.  But we are
	     inserting into the middle of the pattern --
	     so everything is getting moved up by 5.
	     Conclusion: (b - 2) - (laststart + 3) + 5,
	     i.e., b - laststart.

	     We insert this at the beginning of the loop
	     so that if we fail during matching, we'll
	     reinitialize the bounds.  */
	  insert_op_2(set_number_at, laststart, b, b - laststart,
		      upper_bound - 1);
	  b += 5;
	}
d1924 9
a1932 8
      switch (c) {
      case 's':
      case 'S':
      case 'd':
      case 'D':
	while (b - bufp->buffer + 9 + (1 << BYTEWIDTH) / BYTEWIDTH
	       > bufp->allocated)
	  EXTEND_BUFFER;
d1934 7
a1940 7
	laststart = b;
	if (c == 's' || c == 'd') {
	  BUFPUSH(charset);
	}
	else {
	  BUFPUSH(charset_not);
	}
d1942 11
a1952 11
	BUFPUSH((1 << BYTEWIDTH) / BYTEWIDTH);
	memset(b, 0, (1 << BYTEWIDTH) / BYTEWIDTH + 2);
	if (c == 's' || c == 'S') {
	  SET_LIST_BIT(' ');
	  SET_LIST_BIT('\t');
	  SET_LIST_BIT('\n');
	  SET_LIST_BIT('\r');
	  SET_LIST_BIT('\f');
	}
	else {
	  char cc;
d1954 3
a1956 2
	  for (cc = '0'; cc <= '9'; cc++) {
	    SET_LIST_BIT(cc);
a1957 1
	}
d1959 12
a1970 7
	while ((int)b[-1] > 0 && b[b[-1] - 1] == 0) 
	  b[-1]--; 
	if (b[-1] != (1 << BYTEWIDTH) / BYTEWIDTH)
	  memmove(&b[b[-1]], &b[(1 << BYTEWIDTH) / BYTEWIDTH],
		  2 + EXTRACT_UNSIGNED(&b[(1 << BYTEWIDTH) / BYTEWIDTH])*8);
	b += b[-1] + 2 + EXTRACT_UNSIGNED(&b[b[-1]])*8;
	break;
d1972 4
a1975 4
      case 'w':
	laststart = b;
	BUFPUSH(wordchar);
	break;
d1977 3
a1979 4
      case 'W':
	laststart = b;
	BUFPUSH(notwordchar);
	break;
d1981 3
a1983 3
      case '<':
	BUFPUSH(wordbeg);
	break;
d1985 3
a1987 3
      case '>':
	BUFPUSH(wordend);
	break;
d1989 3
a1991 3
      case 'b':
	BUFPUSH(wordbound);
	break;
d1993 3
a1995 3
      case 'B':
	BUFPUSH(notwordbound);
	break;
d1997 3
a1999 3
      case 'A':
	BUFPUSH(begbuf);
	break;
d2001 3
a2003 3
      case 'Z':
	BUFPUSH(endbuf2);
	break;
d2005 6
a2010 3
      case 'z':
	BUFPUSH(endbuf);
	break;
d2012 13
a2024 20
	/* hex */
      case 'x':
	had_mbchar = 0;
	c = scan_hex(p, 2, &numlen);
	p += numlen;
	goto numeric_char;

	/* octal */
      case '0':
	had_mbchar = 0;
	c = scan_oct(p, 3, &numlen);
	p += numlen;
	goto numeric_char;

	/* back-ref or octal */
      case '1': case '2': case '3':
      case '4': case '5': case '6':
      case '7': case '8': case '9':
	{
	  const char *p_save;
d2026 2
a2027 2
	  PATUNFETCH;
	  p_save = p;
d2029 1
a2029 10
	  had_mbchar = 0;
	  c1 = 0;
	  GET_UNSIGNED_NUMBER(c1);
	  if (!ISDIGIT(c)) PATUNFETCH;

	  if (c1 >= regnum) {
	    /* need to get octal */
	    p = p_save;
	    c = scan_oct(p_save, 3, &numlen) & 0xff;
	    p = p_save + numlen;
d2031 11
a2041 1
	    goto numeric_char;
a2042 1
	}
d2044 8
a2051 8
	/* Can't back reference to a subexpression if inside of it.  */
	for (stackt = stackp - 2;  stackt > stackb;  stackt -= 5)
	  if (*stackt == c1)
	    goto normal_char;
	laststart = b;
	BUFPUSH(duplicate);
	BUFPUSH(c1);
	break;
d2053 3
a2055 3
      default:
	goto normal_char;
      }
d2059 7
a2065 4
      if (options & RE_OPTION_EXTENDED) {
	while (p != pend) {
	  PATFETCH(c);
	  if (c == '\n') break;
a2066 2
	break;
      }
d2506 5
a2510 4
    if (p == pend) {
      bufp->can_be_null = 1;
      break;
    }
d2514 1
a2514 1
    switch ((enum regexpcode)*p++)
d2516 10
a2525 5
      {
      case exactn:
	if (p[1] == 0xff) {
	  if (TRANSLATE_P())
	    fastmap[translate[p[2]]] = 2;
d2527 2
a2528 7
	    fastmap[p[2]] = 2;
	}
	else if (TRANSLATE_P())
	  fastmap[translate[p[1]]] = 1;
	else
	  fastmap[p[1]] = 1;
	break;
d2530 12
a2541 12
      case begline:
      case begbuf:
      case endbuf:
      case endbuf2:
      case wordbound:
      case notwordbound:
      case wordbeg:
      case wordend:
      case pop_and_fail:
      case push_dummy_failure:
      case stop_paren:
	continue;
d2543 5
a2547 5
      case casefold_on:
	bufp->options |= RE_MAY_IGNORECASE;
      case casefold_off:
	options ^= RE_OPTION_IGNORECASE;
	continue;
d2549 4
a2552 4
      case posix_on:
      case posix_off:
	options ^= RE_OPTION_POSIX;
	continue;
d2554 5
a2558 5
      case endline:
	if (TRANSLATE_P())
	  fastmap[translate['\n']] = 1;
	else
	  fastmap['\n'] = 1;
d2560 3
a2562 3
	if (bufp->can_be_null == 0)
	  bufp->can_be_null = 2;
	break;
d2564 28
a2591 9
      case jump_n:
      case finalize_jump:
      case maybe_finalize_jump:
      case jump:
      case jump_past_alt:
      case dummy_failure_jump:
	EXTRACT_NUMBER_AND_INCR(j, p);
	p += j;	
	if (j > 0)
d2593 5
a2597 12
	/* Jump backward reached implies we just went through
	   the body of a loop and matched nothing.
	   Opcode jumped to should be an on_failure_jump.
	   Just treat it like an ordinary jump.
	   For a * loop, it has pushed its failure point already;
	   If so, discard that as redundant.  */

	if ((enum regexpcode)*p != on_failure_jump
	    && (enum regexpcode)*p != try_next
	    && (enum regexpcode)*p != succeed_n
	    && (enum regexpcode)*p != finalize_push
	    && (enum regexpcode)*p != finalize_push_n)
a2598 6
	p++;
	EXTRACT_NUMBER_AND_INCR(j, p);
	p += j;	
	if (stackp != stackb && *stackp == p)
	  stackp--;		/* pop */
	continue;
d2600 3
a2602 5
      case start_nowidth:
      case stop_nowidth:
      case finalize_push:
	p += 2;
	continue;
d2604 8
a2611 3
      case finalize_push_n:
	p += 4;
	continue;
d2613 3
a2615 27
      case try_next:
      case on_failure_jump:
      handle_on_failure_jump:
      EXTRACT_NUMBER_AND_INCR(j, p);
      if (p + j < pend) {
	if (stackp == stacke) {
	  unsigned char **stackx;
	  unsigned int len = stacke - stackb;

	  EXPAND_FAIL_STACK(stackx, stackb, len);
	}
	*++stackp = p + j;	/* push */
      }
      else {
	bufp->can_be_null = 1;
      }
      if (is_a_succeed_n)
	EXTRACT_NUMBER_AND_INCR(k, p);	/* Skip the n.  */
      continue;

      case succeed_n:
	is_a_succeed_n = 1;
	/* Get to the number of times to succeed.  */
	EXTRACT_NUMBER(k, p + 2);
	/* Increment p past the n for when k != 0.  */
	if (k == 0) {
	  p += 4;
d2618 1
a2618 1
	  goto handle_on_failure_jump;
d2620 2
d2624 12
a2635 3
      case set_number_at:
	p += 4;
	continue;
d2637 3
a2639 4
      case start_memory:
      case stop_memory:
	p += 2;
	continue;
d2641 4
a2644 6
      case duplicate:
	bufp->can_be_null = 1;
	fastmap['\n'] = 1;
      case anychar:
	{
	  char ex = (options & RE_OPTION_POSIX)?'\0':'\n';
d2646 6
a2651 10
	  for (j = 0; j < (1 << BYTEWIDTH); j++) {
	    if (j != ex) fastmap[j] = 1;
	  }
	  if (bufp->can_be_null) {
	    FREE_AND_RETURN_VOID(stackb);
	  }
	}
	/* Don't return; check the alternative paths
	   so we can set can_be_null if appropriate.  */
	break;
d2653 6
a2658 10
      case wordchar:
	for (j = 0; j < 0x80; j++) {
	  if (SYNTAX(j) == Sword)
	    fastmap[j] = 1;
	}
	switch (current_mbctype) {
	case MBCTYPE_ASCII:
	  for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	    if (SYNTAX(j) == Sword2)
	      fastmap[j] = 1;
d2660 2
d2663 4
a2666 5
	case MBCTYPE_EUC:
	case MBCTYPE_SJIS:
	case MBCTYPE_UTF8:
	  for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	    if (re_mbctab[j])
d2669 16
a2685 2
	}
	break;
d2687 3
a2689 16
      case notwordchar:
	for (j = 0; j < 0x80; j++)
	  if (SYNTAX(j) != Sword)
	    fastmap[j] = 1;
	switch (current_mbctype) {
	case MBCTYPE_ASCII:
	  for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	    if (SYNTAX(j) != Sword2)
	      fastmap[j] = 1;
	  }
	  break;
	case MBCTYPE_EUC:
	case MBCTYPE_SJIS:
	case MBCTYPE_UTF8:
	  for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	    if (!re_mbctab[j])
d2691 15
a2707 2
	}
	break;
d2709 29
a2737 27
      case charset:
	/* NOTE: Charset for single-byte chars never contain
	   multi-byte char.  See set_list_bits().  */
	for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	  if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))) {
	    if (TRANSLATE_P())
	      j = translate[j];
	    fastmap[j] = (j>0x7f?(ismbchar(j)?0:2):1);
	  }
	{
	  unsigned short size;
	  unsigned int c, beg, end;

	  p += p[-1] + 2;
	  size = EXTRACT_UNSIGNED(&p[-2]);
	  for (j = 0; j < (int)size; j++) {
	    c = EXTRACT_MBC(&p[j*8]);
	    beg = WC2MBC1ST(c);
	    c = EXTRACT_MBC(&p[j*8+4]);
	    end = WC2MBC1ST(c);
	    /* set bits for 1st bytes of multi-byte chars.  */
	    while (beg <= end) {
	      /* NOTE: Charset for multi-byte chars might contain
		 single-byte chars.  We must reject them. */
	      if (ismbchar(beg))
		fastmap[beg] = 1;
	      beg++;
d2740 1
a2740 18
	}
	break;

      case charset_not:
	/* S: set of all single-byte chars.
	   M: set of all first bytes that can start multi-byte chars.
	   s: any set of single-byte chars.
	   m: any set of first bytes that can start multi-byte chars.

	   We assume S+M = U.
	   ___      _   _
	   s+m = (S*s+M*m).  */
	/* Chars beyond end of map must be allowed */
	/* NOTE: Charset_not for single-byte chars might contain
	   multi-byte chars.  See set_list_bits(). */
	for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
	  if (!ismbchar(j))
	    fastmap[j] = 1;
d2742 13
a2754 2
	for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	  if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))) {
d2757 2
a2758 3
	  }
	if (current_mbctype) {
	  for (j = 0x80; j < (1 << BYTEWIDTH); j++)
d2760 5
a2764 9
	      fastmap[j] = 2;
	}
	{
	  unsigned short size;
	  unsigned int c, beg, end;

	  p += p[-1] + 2;
	  size = EXTRACT_UNSIGNED(&p[-2]);
	  if (size == 0) {
d2766 2
a2767 3
	      if (ismbchar(j))
		fastmap[j] = 1;
	    break;
d2769 11
a2779 7
	  for (j = 0,c = 0x80;j < (int)size; j++) {
	    int cc = EXTRACT_MBC(&p[j*8]);
	    beg = WC2MBC1ST(cc);
	    while (c < beg) {
	      if (ismbchar(c))
		fastmap[c] = 1;
	      c++;
d2781 8
d2790 7
a2796 2
	    cc = EXTRACT_MBC(&p[j*8+4]);
	    c = WC2MBC1ST(cc) + 1;
d2798 1
d2800 2
a2801 3
	  for (j = c; j < (1 << BYTEWIDTH); j++)
	    if (ismbchar(j))
	      fastmap[j] = 1;
a2802 5
	break;

      case unused:	/* pacify gcc -Wall */
	break;
      }
d2910 6
a2915 4
	&& bufp->can_be_null != 1 && !(anchor && startpos == 0)) {
      if (range > 0) {	/* Searching forwards.  */
	register unsigned char *p, c;
	int irange = range;
d2917 1
a2917 1
	p = (unsigned char*)string+startpos;
d2919 19
a2937 11
	while (range > 0) {
	  c = *p++;
	  if (ismbchar(c)) {
	    int len = mbclen(c) - 1;
	    if (fastmap[c])
	      break;
	    p += len;
	    range -= len + 1;
	    c = *p;
	    if (fastmap[c] == 2)
	      break;
d2939 8
a2946 4
	  else {
	    if (fastmap[MAY_TRANSLATE() ? translate[c] : c])
	      break;
	    range--;
a2947 2
	}
	startpos += irange - range;
a2948 9
      else {			/* Searching backwards.  */
	register unsigned char c;

	c = string[startpos];
	c &= 0xff;
	if (MAY_TRANSLATE() ? !fastmap[translate[c]] : !fastmap[c])
	  goto advance;
      }
    }
d3334 12
a3345 10
    if (p == pend) {
      /* If not end of string, try backtracking.  Otherwise done.  */
      if (d != dend) {
	while (stackp != stackb && (int)stackp[-1] == 1) {
	  if (best_regs_set) /* non-greedy, no need to backtrack */
	    goto restore_best_regs;
	  POP_FAILURE_POINT();
	}
	if (stackp != stackb) {
	  /* More failure points to try.  */
d3347 23
a3369 8
	  /* If exceeds best match so far, save it.  */
	  if (! best_regs_set || (d > best_regend[0])) {
	    best_regs_set = 1;
	    best_regend[0] = d;	/* Never use regstart[0].  */

	    for (mcnt = 1; mcnt < num_regs; mcnt++) {
	      best_regstart[mcnt] = regstart[mcnt];
	      best_regend[mcnt] = regend[mcnt];
a3371 7
	  goto fail;	       
	}
	/* If no failure points, don't restore garbage.  */
	else if (best_regs_set) {
	restore_best_regs:
	  /* Restore best match.  */
	  d = best_regend[0];
d3373 17
a3389 3
	  for (mcnt = 0; mcnt < num_regs; mcnt++) {
	    regstart[mcnt] = best_regstart[mcnt];
	    regend[mcnt] = best_regend[mcnt];
d3391 2
a3392 1
	}
a3394 19
      /* If caller wants register contents data back, convert it 
	 to indices.  */
      if (regs) {
	regs->beg[0] = pos;
	regs->end[0] = d - string;
	for (mcnt = 1; mcnt < num_regs; mcnt++) {
	  if (REG_UNSET(regend[mcnt])) {
	    regs->beg[mcnt] = -1;
	    regs->end[mcnt] = -1;
	    continue;
	  }
	  regs->beg[mcnt] = regstart[mcnt] - string;
	  regs->end[mcnt] = regend[mcnt] - string;
	}
      }
      FREE_VARIABLES();
      FREE_AND_RETURN(stackb, (d - pos - string));
    }

d3401 26
a3426 25
      {
	/* ( [or `(', as appropriate] is represented by start_memory,
	   ) by stop_memory.  Both of those commands are followed by
	   a register number in the next byte.  The text matched
	   within the ( and ) is recorded under that number.  */
      case start_memory:
	/* Find out if this group can match the empty string.  */
	p1 = p;		/* To send to group_match_null_string_p.  */
	if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
	  REG_MATCH_NULL_STRING_P (reg_info[*p]) 
	    = group_match_null_string_p (&p1, pend, reg_info);

	/* Save the position in the string where we were the last time
	   we were at this open-group operator in case the group is
	   operated upon by a repetition operator, e.g., with `(a*)*b'
	   against `ab'; then we want to ignore where we are now in
	   the string in case this attempt to match fails.  */
	old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
	  ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
	  : regstart[*p];
	regstart[*p] = d;
	IS_ACTIVE(reg_info[*p]) = 1;
	MATCHED_SOMETHING(reg_info[*p]) = 0;
	p += 2;
	continue;
d3428 33
a3460 31
      case stop_memory:
	/* We need to save the string position the last time we were at
	   this close-group operator in case the group is operated
	   upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
	   against `aba'; then we want to ignore where we are now in
	   the string in case this attempt to match fails.  */
	old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
	  ? REG_UNSET (regend[*p]) ? d : regend[*p]
	  : regend[*p];

	regend[*p] = d;
	IS_ACTIVE(reg_info[*p]) = 0;

	/* If just failed to match something this time around with a sub-
	   expression that's in a loop, try to force exit from the loop.  */
	if ((p + 1) != pend &&
	    (! MATCHED_SOMETHING(reg_info[*p])
	     || (enum regexpcode)p[-3] == start_memory)) {
	  p1 = p + 2;
	  mcnt = 0;
	  switch (*p1++) {
	  case jump_n:
	  case finalize_push_n:
	  case finalize_jump:
	  case maybe_finalize_jump:
	  case jump:
	  case dummy_failure_jump:
	    EXTRACT_NUMBER_AND_INCR(mcnt, p1);
	    break;
	  }
	  p1 += mcnt;
d3462 38
a3499 29
	  /* If the next operation is a jump backwards in the pattern
	     to an on_failure_jump, exit from the loop by forcing a
	     failure after pushing on the stack the on_failure_jump's 
	     jump in the pattern, and d.  */
	  if (mcnt < 0 && (enum regexpcode)*p1 == on_failure_jump
	      && (enum regexpcode)p1[3] == start_memory && p1[4] == *p) {
	    /* If this group ever matched anything, then restore
	       what its registers were before trying this last
	       failed match, e.g., with `(a*)*b' against `ab' for
	       regstart[1], and, e.g., with `((a*)*(b*)*)*'
	       against `aba' for regend[3].

	       Also restore the registers for inner groups for,
	       e.g., `((a*)(b*))*' against `aba' (register 3 would
	       otherwise get trashed).  */

	    if (EVER_MATCHED_SOMETHING (reg_info[*p])) {
	      unsigned r; 

	      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;

	      /* Restore this and inner groups' (if any) registers.  */
	      for (r = *p; r < *p + *(p + 1); r++) {
		regstart[r] = old_regstart[r];

		/* xx why this test?  */
		if ((int)old_regend[r] >= (int)regstart[r])
		  regend[r] = old_regend[r];
	      }     
d3501 2
a3502 8
	    p1++;
	    EXTRACT_NUMBER_AND_INCR(mcnt, p1);
	    PUSH_FAILURE_POINT(p1 + mcnt, d);
	    goto fail;
	  }
	}
	p += 2;
	continue;
d3504 2
a3505 2
      case stop_paren:
	break;
d3507 46
a3552 6
	/* \<digit> has been turned into a `duplicate' command which is
	   followed by the numeric value of <digit> as the register number.  */
      case duplicate:
	{
	  int regno = *p++;   /* Get which register to match against */
	  register unsigned char *d2, *dend2;
d3554 5
a3558 1
	  if (IS_ACTIVE(reg_info[regno])) break;
d3560 6
a3565 8
	  /* Where in input to try to start matching.  */
	  d2 = regstart[regno];
	  if (REG_UNSET(d2)) break;

	  /* Where to stop matching; if both the place to start and
	     the place to stop matching are in the same string, then
	     set to the place to stop, otherwise, for now have to use
	     the end of the first string.  */
d3567 5
a3571 5
	  dend2 = regend[regno];
	  if (REG_UNSET(dend2)) break;
	  for (;;) {
	    /* At end of register contents => success */
	    if (d2 == dend2) break;
d3573 4
a3576 16
	    /* If necessary, advance to next segment in data.  */
	    PREFETCH;

	    /* How many characters left in this segment to match.  */
	    mcnt = dend - d;

	    /* Want how many consecutive characters we can match in
	       one shot, so, if necessary, adjust the count.  */
	    if (mcnt > dend2 - d2)
	      mcnt = dend2 - d2;

	    /* Compare that many; failure if mismatch, else move
	       past them.  */
	    if ((options & RE_OPTION_IGNORECASE) 
		? memcmp_translate(d, d2, mcnt) 
		: memcmp((char*)d, (char*)d2, mcnt))
d3578 3
a3580 1
	    d += mcnt, d2 += mcnt;
d3582 2
a3583 26
	}
	break;

      case start_nowidth:
	PUSH_FAILURE_POINT(0, d);
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	STORE_NUMBER(p+mcnt, stackp - stackb);
	continue;

      case stop_nowidth:
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	stackp = stackb + mcnt;
	d = stackp[-2];
	POP_FAILURE_POINT();
	continue;

      case pop_and_fail:
	EXTRACT_NUMBER(mcnt, p+1);
	stackp = stackb + mcnt;
	POP_FAILURE_POINT();
	goto fail;

      case anychar:
	PREFETCH;
	if (ismbchar(*d)) {
	  if (d + mbclen(*d) > dend)
d3586 1
a3586 1
	  d += mbclen(*d);
a3587 7
	}
	if (((TRANSLATE_P()) ? translate[*d] : *d) ==
	    ((options&RE_OPTION_POSIX) ? '\0' : '\n'))
	  goto fail;
	SET_REGS_MATCHED;
	d++;
	break;
d3589 7
a3595 7
      case charset:
      case charset_not:
	{
	  int not;	    /* Nonzero for charset_not.  */
	  int part;	    /* 2 if matched part of mbc */
	  unsigned char *dsave = d + 1;
	  int cc, c;
d3597 6
a3602 5
	  PREFETCH;
	  cc = c = (unsigned char)*d++;
	  if (ismbchar(c)) {
	    if (d + mbclen(c) - 1 <= dend) {
	      MBC2WC(c, d);
d3604 2
a3605 3
	  }
	  else if (TRANSLATE_P())
	    cc = c = (unsigned char)translate[c];
d3607 5
a3611 5
	  part = not = is_in_list(c, p);
	  if (*(p - 1) == (unsigned char)charset_not) {
	    not = !not;
	  }
	  if (!not) goto fail;
d3613 2
a3614 2
	  p += 1 + *p + 2 + EXTRACT_UNSIGNED(&p[1 + *p])*8;
	  SET_REGS_MATCHED;
d3616 3
a3618 3
	  if (part == 2) d = dsave;
	  break;
	}
d3620 6
a3625 6
      case begline:
	if (size == 0 || AT_STRINGS_BEG(d))
	  break;
	if (d[-1] == '\n' && !AT_STRINGS_END(d))
	  break;
	goto fail;
d3627 6
a3632 3
      case endline:
	if (AT_STRINGS_END(d)) {
	  if (size == 0 || d[-1] != '\n')
d3634 1
a3634 4
	}
	else if (*d == '\n')
	  break;
	goto fail;
d3636 5
a3640 5
	/* Match at the very beginning of the string. */
      case begbuf:
	if (AT_STRINGS_BEG(d))
	  break;
	goto fail;
d3642 5
a3646 5
	/* Match at the very end of the data. */
      case endbuf:
	if (AT_STRINGS_END(d))
	  break;
	goto fail;
d3648 8
a3655 8
	/* Match at the very end of the data. */
      case endbuf2:
	if (AT_STRINGS_END(d))
	  break;
	/* .. or newline just before the end of the data. */
	if (*d == '\n' && AT_STRINGS_END(d+1))
	  break;
	goto fail;
d3657 12
a3668 6
	/* `or' constructs are handled by starting each alternative with
	   an on_failure_jump that points to the start of the next
	   alternative.  Each alternative except the last ends with a
	   jump to the joining point.  (Actually, each jump except for
	   the last one really jumps to the following jump, because
	   tensioning the jumps is a hassle.)  */
d3670 2
a3671 5
	/* The start of a stupid repeat has an on_failure_jump that points
	   past the end of the repeat text. This makes a failure point so 
	   that on failure to match a repetition, matching restarts past
	   as many repetitions have been found with no way to fail and
	   look for another one.  */
d3673 5
a3677 2
	/* A smart repeat is similar but loops back to the on_failure_jump
	   so that each repetition makes another failure point.  */
d3679 6
a3684 5
      case on_failure_jump:
      on_failure:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      PUSH_FAILURE_POINT(p + mcnt, d);
      continue;
d3686 23
a3708 6
      /* The end of a smart repeat has a maybe_finalize_jump back.
	 Change it either to a finalize_jump or an ordinary jump.  */
      case maybe_finalize_jump:
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	{
	  register unsigned char *p2 = p;
d3710 1
a3710 33
	  /* Compare the beginning of the repeat with what in the
	     pattern follows its end. If we can establish that there
	     is nothing that they would both match, i.e., that we
	     would have to backtrack because of (as in, e.g., `a*a')
	     then we can change to pop_failure_jump, because we'll
	     never have to backtrack.

	     This is not true in the case of alternatives: in
	     `(a|ab)*' we do need to backtrack to the `ab' alternative
	     (e.g., if the string was `ab').  But instead of trying to
	     detect that here, the alternative has put on a dummy
	     failure point which is what we will end up popping.  */

	  /* Skip over open/close-group commands.  */
	  while (p2 + 2 < pend) {
	    if ((enum regexpcode)*p2 == stop_memory ||
		(enum regexpcode)*p2 == start_memory)
	      p2 += 3;	/* Skip over args, too.  */
	    else if ((enum regexpcode)*p2 == stop_paren)
	      p2 += 1;
	    else
	      break;
	  }

	  if (p2 == pend)
	    p[-3] = (unsigned char)finalize_jump;
	  else if (*p2 == (unsigned char)exactn
		   || *p2 == (unsigned char)endline) {
	    register int c = *p2 == (unsigned char)endline ? '\n' : p2[2];
	    register unsigned char *p1 = p + mcnt;
	    /* p1[0] ... p1[2] are an on_failure_jump.
	       Examine what follows that.  */
	    if (p1[3] == (unsigned char)exactn && p1[5] != c)
d3712 24
a3735 6
	    else if (p1[3] == (unsigned char)charset
		     || p1[3] == (unsigned char)charset_not) {
	      int not;
	      if (ismbchar(c)) {
		unsigned char *pp = p2+3;
		MBC2WC(c, pp);
d3737 6
a3742 7
	      /* `is_in_list()' is TRUE if c would match */
	      /* That means it is not safe to finalize.  */
	      not = is_in_list(c, p1 + 4);
	      if (p1[3] == (unsigned char)charset_not)
		not = !not;
	      if (!not)
		p[-3] = (unsigned char)finalize_jump;
d3744 14
d3759 2
a3760 7
	}
	p -= 2;		/* Point at relative address again.  */
	if (p[-1] != (unsigned char)finalize_jump) {
	  p[-1] = (unsigned char)jump;	
	  goto nofinalize;
	}
	/* Note fall through.  */
d3762 6
a3767 15
	/* The end of a stupid repeat has a finalize_jump back to the
	   start, where another failure point will be made which will
	   point to after all the repetitions found so far.  */

	/* Take off failure points put on by matching on_failure_jump 
	   because didn't fail.  Also remove the register information
	   put on by the on_failure_jump.  */
      case finalize_jump:
	if (stackp[-2] == d) {
	  p = stackp[-3];
	  POP_FAILURE_POINT();
	  continue;
	}
	POP_FAILURE_POINT(); 
	/* Note fall through.  */
d3769 4
a3772 6
	/* Jump without taking off any failure points.  */
      case jump:
      nofinalize:
      EXTRACT_NUMBER_AND_INCR(mcnt, p);
      p += mcnt;
      continue;
d3774 8
a3781 24
      /* We need this opcode so we can detect where alternatives end
	 in `group_match_null_string_p' et al.  */
      case jump_past_alt:
	goto nofinalize;

      case dummy_failure_jump:
	/* Normally, the on_failure_jump pushes a failure point, which
	   then gets popped at finalize_jump.  We will end up at
	   finalize_jump, also, and with a pattern of, say, `a+', we
	   are skipping over the on_failure_jump, so we have to push
	   something meaningless for finalize_jump to pop.  */
	PUSH_FAILURE_POINT(0, 0);
	goto nofinalize;

	/* At the end of an alternative, we need to push a dummy failure
	   point in case we are followed by a `finalize_jump', because
	   we don't want the failure point for the alternative to be
	   popped.  For example, matching `(a|ab)*' against `aab'
	   requires that we match the `ab' alternative.  */
      case push_dummy_failure:
	/* See comments just above at `dummy_failure_jump' about the
	   two zeroes.  */
	PUSH_FAILURE_POINT(0, 0);
	break;
d3783 8
a3790 9
	/* Have to succeed matching what follows at least n times.  Then
	   just handle like an on_failure_jump.  */
      case succeed_n: 
	EXTRACT_NUMBER(mcnt, p + 2);
	/* Originally, this is how many times we HAVE to succeed.  */
	if (mcnt > 0) {
	  mcnt--;
	  p += 2;
	  STORE_NUMBER_AND_INCR(p, mcnt);
d3792 21
a3812 7
	}
	else if (mcnt == 0) {
	  p[2] = unused;
	  p[3] = unused;
	  goto on_failure;
	}
	continue;
d3814 8
a3821 7
      case jump_n:
	EXTRACT_NUMBER(mcnt, p + 2);
	/* Originally, this is how many times we CAN jump.  */
	if (mcnt) {
	  mcnt--;
	  STORE_NUMBER(p + 2, mcnt);
	  goto nofinalize;	     /* Do the jump without taking off
d3823 5
a3827 5
	}
	/* If don't have to jump any more, skip over the rest of command.  */
	else      
	  p += 4;		     
	continue;
d3829 6
a3834 6
      case set_number_at:
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	p1 = p + mcnt;
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	STORE_NUMBER(p1, mcnt);
	continue;
d3836 8
a3843 8
      case try_next:
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	if (p + mcnt < pend) {
	  PUSH_FAILURE_POINT(p, d);
	  stackp[-1] = (unsigned char*)1;
	}
	p += mcnt;
	continue;
d3845 1
a3845 18
      case finalize_push:
	POP_FAILURE_POINT();
	EXTRACT_NUMBER_AND_INCR(mcnt, p);
	PUSH_FAILURE_POINT(p + mcnt, d);
	stackp[-1] = (unsigned char*)1;
	continue;

      case finalize_push_n:
	EXTRACT_NUMBER(mcnt, p + 2); 
	/* Originally, this is how many times we CAN jump.  */
	if (mcnt) {
	  int pos, i;

	  mcnt--;
	  STORE_NUMBER(p + 2, mcnt);
	  EXTRACT_NUMBER(pos, p);
	  EXTRACT_NUMBER(i, p+pos+5);
	  if (i > 0) goto nofinalize;
d3850 1
a3850 6
	  p += 2;		/* skip n */
	}
	/* If don't have to push any more, skip over the rest of command.  */
	else 
	  p += 4;   
	continue;
d3852 21
a3872 4
	/* Ignore these.  Used to ignore the n of succeed_n's which
	   currently have n == 0.  */
      case unused:
	continue;
d3874 4
a3877 3
      case casefold_on:
	options |= RE_OPTION_IGNORECASE;
	continue;
d3879 3
a3881 3
      case casefold_off:
	options &= ~RE_OPTION_IGNORECASE;
	continue;
d3883 3
a3885 3
      case posix_on:
	options |= RE_OPTION_POSIX;
	continue;
d3887 3
a3889 3
      case posix_off:
	options &= ~RE_OPTION_POSIX;
	continue;
d3891 3
a3893 12
      case wordbound:
	if (AT_STRINGS_BEG(d)) {
	  if (IS_A_LETTER(d)) break;
	  else goto fail;
	}
	if (AT_STRINGS_BEG(d)) {
	  if (PREV_IS_A_LETTER(d)) break;
	  else goto fail;
	}
	if (PREV_IS_A_LETTER(d) != IS_A_LETTER(d))
	  break;
	goto fail;
d3895 11
a3905 10
      case notwordbound:
	if (AT_STRINGS_BEG(d)) {
	  if (IS_A_LETTER(d)) goto fail;
	  else break;
	}
	if (AT_STRINGS_END(d)) {
	  if (PREV_IS_A_LETTER(d)) goto fail;
	  else break;
	}
	if (PREV_IS_A_LETTER(d) != IS_A_LETTER(d))
a3906 1
	break;
d3908 11
a3918 2
      case wordbeg:
	if (IS_A_LETTER(d) && (AT_STRINGS_BEG(d) || !PREV_IS_A_LETTER(d)))
a3919 1
	goto fail;
d3921 4
a3924 5
      case wordend:
	if (!AT_STRINGS_BEG(d) && PREV_IS_A_LETTER(d)
	    && (!IS_A_LETTER(d) || AT_STRINGS_END(d)))
	  break;
	goto fail;
d3926 4
a3929 3
      case wordchar:
	PREFETCH;
	if (!IS_A_LETTER(d))
a3930 5
	if (ismbchar(*d) && d + mbclen(*d) - 1 < dend)
	  d += mbclen(*d) - 1;
	d++;
	SET_REGS_MATCHED;
	break;
d3932 9
a3940 9
      case notwordchar:
	PREFETCH;
	if (IS_A_LETTER(d))
	  goto fail;
	if (ismbchar(*d) && d + mbclen(*d) - 1 < dend)
	  d += mbclen(*d) - 1;
	d++;
	SET_REGS_MATCHED;
	break;
d3942 9
a3950 9
      case exactn:
	/* Match the next few pattern characters exactly.
	   mcnt is how many characters to match.  */
	mcnt = *p++;
	/* This is written out as an if-else so we don't waste time
	   testing `translate' inside the loop.  */
	if (TRANSLATE_P()) {
	  do {
	    unsigned char c;
d3952 41
a3992 9
	    PREFETCH;
	    c = *d++;
	    if (*p == 0xff) {
	      p++;  
	      if (!--mcnt
		  || AT_STRINGS_END(d)
		  || (unsigned char)*d++ != (unsigned char)*p++)
		goto fail;
	      continue;
d3994 9
a4002 12
	    if (ismbchar(c)) {
	      int n;

	      if (c != (unsigned char)*p++)
		goto fail;
	      for (n = mbclen(c) - 1; n > 0; n--)
		if (!--mcnt	/* redundant check if pattern was
				   compiled properly. */
		    || AT_STRINGS_END(d)
		    || (unsigned char)*d++ != (unsigned char)*p++)
		  goto fail;
	      continue;
d4004 2
a4005 13
	    /* compiled code translation needed for ruby */
	    if ((unsigned char)translate[c] != (unsigned char)translate[*p++])
	      goto fail;
	  }
	  while (--mcnt);
	}
	else {
	  do {
	    PREFETCH;
	    if (*p == 0xff) {p++; mcnt--;}
	    if (*d++ != *p++) goto fail;
	  }
	  while (--mcnt);
a4006 3
	SET_REGS_MATCHED;
	break;
      }
d4015 1
a4015 1
    if (stackp != stackb) {
d4017 2
a4018 1
      short last_used_reg, this_reg;
d4020 50
a4069 39
      /* If this failure point is from a dummy_failure_point, just
	 skip it.  */
      if (stackp[-3] == 0 || (best_regs_set && (int)stackp[-1] == 1)) {
	POP_FAILURE_POINT();
	goto fail;
      }
      stackp--;		/* discard flag */
      d = *--stackp;
      p = *--stackp;
      /* Restore register info.  */
      last_used_reg = (long)*--stackp;

      /* Make the ones that weren't saved -1 or 0 again. */
      for (this_reg = num_regs - 1; this_reg > last_used_reg; this_reg--) {
	regend[this_reg] = REG_UNSET_VALUE;
	regstart[this_reg] = REG_UNSET_VALUE;
	IS_ACTIVE(reg_info[this_reg]) = 0;
	MATCHED_SOMETHING(reg_info[this_reg]) = 0;
      }

      /* And restore the rest from the stack.  */
      for ( ; this_reg > 0; this_reg--) {
	reg_info[this_reg].word = *--stackp;
	regend[this_reg] = *--stackp;
	regstart[this_reg] = *--stackp;
      }
      if (p < pend) {
	int is_a_jump_n = 0;
	int failed_paren = 0;

	p1 = p;
	/* If failed to a backwards jump that's part of a repetition
	   loop, need to pop this failure point and use the next one.  */
      pop_loop:
	switch ((enum regexpcode)*p1) {
	case stop_paren:
	  failed_paren = 1;
	  p1++;
	  goto pop_loop;
d4071 9
a4079 18
	case jump_n:
	case finalize_push_n:
	  is_a_jump_n = 1;
	case maybe_finalize_jump:
	case finalize_jump:
	case finalize_push:
	case jump:
	  p1++;
	  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
	  p1 += mcnt;

	  if (p1 >= pend) break;
	  if (( is_a_jump_n && (enum regexpcode)*p1 == succeed_n) ||
	      (!is_a_jump_n && (enum regexpcode)*p1 == on_failure_jump)) {
	    if (failed_paren) {
	      p1++;
	      EXTRACT_NUMBER_AND_INCR(mcnt, p1);
	      PUSH_FAILURE_POINT(p1 + mcnt, d);
d4081 3
a4083 1
	    goto fail;
a4084 3
	  break;
	default:
	  /* do nothing */ ;
a4086 1
    }
d4131 47
a4177 45
      if (mcnt >= 0) {
	/* Go through the on_failure_jumps of the alternatives,
	   seeing if any of the alternatives cannot match nothing.
	   The last alternative starts with only a jump,
	   whereas the rest start with on_failure_jump and end
	   with a jump, e.g., here is the pattern for `a|b|c':

	   /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
	   /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
	   /exactn/1/c						

	   So, we have to first go through the first (n-1)
	   alternatives and then deal with the last one separately.  */


	/* Deal with the first (n-1) alternatives, which start
	   with an on_failure_jump (see above) that jumps to right
	   past a jump_past_alt.  */

	while ((enum regexpcode)p1[mcnt-3] == jump_past_alt) {
	  /* `mcnt' holds how many bytes long the alternative
	     is, including the ending `jump_past_alt' and
	     its number.  */

	  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
					reg_info))
	    return 0;

	  /* Move to right after this alternative, including the
	     jump_past_alt.  */
	  p1 += mcnt;	

	  /* Break if it's the beginning of an n-th alternative
	     that doesn't begin with an on_failure_jump.  */
	  if ((enum regexpcode)*p1 != on_failure_jump)
	    break;

	  /* Still have to check that it's not an n-th
	     alternative that starts with an on_failure_jump.  */
	  p1++;
	  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
	  if ((enum regexpcode)p1[mcnt-3] != jump_past_alt) {
	    /* Get to the beginning of the n-th alternative.  */
	    p1 -= 3;
	    break;
a4178 1
	}
d4180 4
a4183 4
	/* Deal with the last alternative: go back and get number
	   of the `jump_past_alt' just before it.  `mcnt' contains
	   the length of the alternative.  */
	EXTRACT_NUMBER (mcnt, p1 - 2);
d4185 2
a4186 2
	if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
	  return 0;
d4188 2
a4189 2
	p1 += mcnt;	/* Get past the n-th alternative.  */
      } /* if mcnt > 0 */
@


1.1.1.3.2.13
log
@prepare to alpha
@
text
@a3104 1
#define NON_GREEDY ((unsigned char*)1)
d3110 1
a3110 1
    long temp;								\
d3112 1
a3112 1
    temp = (long)*--stackp;	/* How many regs pushed.  */	        \
d3323 1
a3323 1
	while (stackp != stackb && stackp[-1] == NON_GREEDY) {
d3465 1
a3465 1
		if ((long)old_regend[r] >= (long)regstart[r])
d3808 1
a3808 1
	  stackp[-1] = NON_GREEDY;
d3817 1
a3817 1
	stackp[-1] = NON_GREEDY;
d3834 1
a3834 1
	  stackp[-1] = NON_GREEDY;
d3970 4
d3984 1
a3984 1
      if (stackp[-3] == 0 || (best_regs_set && stackp[-1] == NON_GREEDY)) {
@


1.1.1.3.2.14
log
@to open CVS
@
text
@d2641 9
a2649 6
	for (j = 0; j < (1 << BYTEWIDTH); j++) {
	  if (j != '\n' || (options & RE_OPTION_POSIX))
	    fastmap[j] = 1;
	}
	if (bufp->can_be_null) {
	  FREE_AND_RETURN_VOID(stackb);
d3144 1
a3144 1
			 (re_mbctab[*(d)] && ((d)+mbclen(*(d)))<=dend):	\
d3308 1
d3556 2
a3557 2
	if (!(options&RE_OPTION_POSIX) &&
	    (TRANSLATE_P() ? translate[*d] : *d) == '\n')
@


1.1.1.3.2.15
log
@small fixes
@
text
@d355 2
a356 2
    posix_on,      /* Turn on POSIXified line match (match with newlines). */
    posix_off,     /* Turn off POSIXified line match. */
d1298 1
a1298 1
	if (bufp->options & RE_OPTION_POSIXLINE)
d1557 2
a1558 2
		if (options&RE_OPTION_POSIXLINE) {
		  options &= ~RE_OPTION_POSIXLINE;
d1562 2
a1563 2
	      else if (!(options&RE_OPTION_POSIXLINE)) {
		options |= RE_OPTION_POSIXLINE;
d1674 2
a1675 2
      if ((options ^ stackp[-1]) & RE_OPTION_POSIXLINE) {
	BUFPUSH((options&RE_OPTION_POSIXLINE)?posix_off:posix_on);
d1769 1
a1769 1
      /* If there is no previous pattern, this is an invalid pattern.  */
d1771 1
a1771 1
	goto invalid_pattern;
a1838 38
      /* If lower_bound == upper_bound, repeat cound can be removed */
      if (lower_bound == upper_bound) {
	int mcnt;
	int skip_stop_paren = 0;

	if (b[-1] == stop_paren) {
	  skip_stop_paren = 1;
	  b--;
	}

	if (*laststart == exactn && laststart[1]+2 == b - laststart
	    && laststart[1]*lower_bound < 256) {
	  mcnt = laststart[1];
	  GET_BUFFER_SPACE((lower_bound-1)*mcnt);
	  laststart[1] = lower_bound*mcnt;
	  while (--lower_bound) {
	    memcpy(b, laststart+2, mcnt);
	    b += mcnt;
	  }
	  if (skip_stop_paren) BUFPUSH(stop_paren);
	  break;
	}

	if (lower_bound < 5 && b - laststart < 10) {
	  /* 5 and 10 are the magic numbers */

	  mcnt = b - laststart;
	  GET_BUFFER_SPACE((lower_bound-1)*mcnt);
	  while (--lower_bound) {
	    memcpy(b, laststart, mcnt);
	    b += mcnt;
	  }
	  if (skip_stop_paren) BUFPUSH(stop_paren);
	  break;
	}
	if (skip_stop_paren) b++; /* push back stop_paren */
      }

d2123 1
a2123 1
	switch ((enum regexpcode)laststart[1]) {
d2542 1
a2542 1
	options ^= RE_OPTION_POSIXLINE;
d2642 1
a2642 1
	  if (j != '\n' || (options & RE_OPTION_POSIXLINE))
a2838 1
    begbuf_match:
a2856 3
    if (bufp->options&RE_OPTION_POSIXLINE) {
      goto begbuf_match;
    }
d2948 1
a2948 2
      if (anchor && startpos < size &&
	  (startpos < 1 || string[startpos-1] != '\n')) {
d3552 1
a3552 1
	if (!(options&RE_OPTION_POSIXLINE) &&
d3853 1
a3853 1
	options |= RE_OPTION_POSIXLINE;
d3857 1
a3857 1
	options &= ~RE_OPTION_POSIXLINE;
@


1.1.1.3.2.16
log
@regexp,range,squeeze
@
text
@a334 1
    anychar_repeat,	 /* Matches sequence of characters excluding newlines.  */
a786 4
    case anychar_repeat:
      printf("/anychar_repeat");
      break;

d985 2
a990 1
    case anychar_repeat:
a1003 2
    case posix_on:
    case posix_off:
a1230 6
      if (greedy && *laststart == anychar && b - laststart < 2) {
	if (b[-1] == stop_paren)
	  b--;
	*laststart = anychar_repeat;
	break;
      }
d2155 1
a2155 4
    if (*laststart == anychar_repeat) {
      bufp->options |= RE_OPTIMIZE_ANCHOR;
    }
    else if (*laststart == on_failure_jump) {
a2677 1
      case anychar_repeat:
d3362 1
a3362 3
      if ((bufp->options & RE_OPTION_POSIXMATCH) && d != dend) {
	if (best_regs_set) /* non-greedy, no need to backtrack */
	  goto restore_best_regs;
a3599 19
	break;

      case anychar_repeat:
	for (;;) {
	  PUSH_FAILURE_POINT(p, d);
	  PREFETCH;
	  if (ismbchar(*d)) {
	    if (d + mbclen(*d) > dend)
	      goto fail;
	    SET_REGS_MATCHED;
	    d += mbclen(*d);
	    break;
	  }
	  if (!(options&RE_OPTION_POSIXLINE) &&
	      (TRANSLATE_P() ? translate[*d] : *d) == '\n')
	    goto fail;
	  SET_REGS_MATCHED;
	  d++;
	}
@


1.1.1.3.2.17
log
@.*/.+/.?
@
text
@d1237 1
a1237 1
      if (greedy && many_times_ok && *laststart == anychar && b - laststart <= 2) {
d1240 1
a1240 5
	if (zero_times_ok)
	  *laststart = anychar_repeat;
	else {
	  BUFPUSH(anychar_repeat);
	}
d3378 1
a3378 1
      if ((bufp->options & RE_OPTION_LONGEST) && d != dend) {
d3813 3
a3815 3
        EXTRACT_NUMBER_AND_INCR(mcnt, p);
        p += mcnt;
        continue;
@


1.1.1.3.2.18
log
@990513
@
text
@d1185 1
a1185 4
      if (bufp->options & RE_OPTION_POSIXLINE) {
	BUFPUSH(endbuf2);
      }
      else {
d1198 1
a1199 1
      break;
d1201 1
a1201 4
      if (bufp->options & RE_OPTION_POSIXLINE)
	  BUFPUSH(begbuf);
      else
	  BUFPUSH(begline);
d1316 2
d2045 3
a2047 5
	if ((bufp->options & RE_OPTION_POSIXLINE) == 0) {
	  BUFPUSH(endbuf2);
	  break;
	}
	/* fall through */
@


1.1.1.3.2.19
log
@moving
@
text
@d3639 1
a3639 1
	    continue;
@


1.1.1.3.2.20
log
@arity/strict yield
@
text
@d78 1
a78 1
/* #define	NO_ALLOCA */	/* try it out for now */
d681 1
d685 1
a685 1
    return 1;
d702 1
a702 1
  return 0;
d1186 1
a1186 1
	BUFPUSH(endbuf);
d1362 1
a1362 1
	  PATFETCH_RAW(c);
d2613 2
a2614 1
	if ((options & RE_OPTION_POSIXLINE) == 0 && bufp->can_be_null == 0)
d2683 1
a2683 1
	if (k != 0) {
d2766 3
a2768 2
	    int tmp = TRANSLATE_P()?translate[j]:j;
	    fastmap[tmp] = (tmp>0x7f)?2:1;
d2977 5
a2981 6
	    while (len--) {
	      c = *p++;
	      range--;
	      if (fastmap[c] == 2)
		goto startpos_adjust;
	    }
a2988 1
      startpos_adjust:
d3667 1
a3667 4
	  not = is_in_list(c, p);
	  if (!not) {
	      not = is_in_list(cc, p);
	  }
d3710 2
a3711 4
	if (AT_STRINGS_END(d)) {
	  if (size == 0 || d[-1] != '\n')
	    break;
	}
@


1.1.1.3.2.21
log
@mbc bug in regex
@
text
@d2971 1
a2971 2
	    int len;

a2973 1
	    len = mbclen(c) - 1;
d2984 1
a2985 1
	  range--;
@


1.1.1.3.2.22
log
@regexp null pattern
@
text
@d165 3
d500 1
a500 1
      printf("%c%c%c%c%c%c", utf8_firstbyte(c), (c>>24)&0x3f, (c>>18)&0x3f, (c>>12)&0x3f, (c>>6)&0x3f, c&0x3f);
a1059 28
static int
read_backslash(c)
     int c;
{
  switch (c) {
  case 'n':
    return '\n';

  case 't':
    return '\t';

  case 'r':
    return '\r';

  case 'f':
    return '\f';

  case 'v':
    return '\v';

  case 'a':
    return '\007';

  case 'e':
    return '\033';
  }
  return c;
}
a1427 1
	    c = read_backslash(c);
a1707 1
      p0 = b;
a2105 1
	c = read_backslash(c);
a2621 2
      case finalize_push:
      case finalize_push_n:
d2635 3
a2637 1
	    && (enum regexpcode)*p != succeed_n)
a2645 1
      case try_next:
d2648 1
d2652 3
a2654 10
      case succeed_n:
	is_a_succeed_n = 1;
	/* Get to the number of times to succeed.  */
	EXTRACT_NUMBER(k, p + 2);
	/* Increment p past the n for when k != 0.  */
	if (k != 0) {
	  p += 4;
	  continue;
	}
	/* fall through */
d2656 1
d2658 1
d2676 13
d3098 4
d3104 1
d3108 1
d3111 1
d3199 1
d3356 1
d3359 1
d3456 14
a3469 1
	old_regstart[*p] = regstart[*p];
d3477 9
a3485 1
	old_regend[*p] = regend[*p];
d3488 56
d3654 1
a3654 1
	  int part = 0;	    /* true if matched part of mbc */
d3669 1
a3669 2
	  if (!not && cc != c) {
	      part = 1;
d3680 1
a3680 1
	  if (part) d = dsave;
d3749 2
a3750 1
	p1 = p;
d3752 23
a3774 23
	/* Compare the beginning of the repeat with what in the
	   pattern follows its end. If we can establish that there
	   is nothing that they would both match, i.e., that we
	   would have to backtrack because of (as in, e.g., `a*a')
	   then we can change to pop_failure_jump, because we'll
	   never have to backtrack.

	   This is not true in the case of alternatives: in
	   `(a|ab)*' we do need to backtrack to the `ab' alternative
	   (e.g., if the string was `ab').  But instead of trying to
	   detect that here, the alternative has put on a dummy
	   failure point which is what we will end up popping.  */

	/* Skip over open/close-group commands.  */
	while (p1 + 2 < pend) {
	  if ((enum regexpcode)*p1 == stop_memory ||
	      (enum regexpcode)*p1 == start_memory)
	    p1 += 3;	/* Skip over args, too.  */
	  else if ((enum regexpcode)*p1 == stop_paren)
	      p1 += 1;
	  else
	    break;
	}
d3776 7
a3782 7
	if (p1 == pend)
	  p[-3] = (unsigned char)finalize_jump;
	else if (*p1 == (unsigned char)exactn ||
		 *p1 == (unsigned char)endline) {
	  register int c = *p1 == (unsigned char)endline ? '\n' : p1[2];
	  register unsigned char *p2 = p + mcnt;
	    /* p2[0] ... p2[2] are an on_failure_jump.
d3784 16
a3799 8
	  if (p2[3] == (unsigned char)exactn && p2[5] != c)
	    p[-3] = (unsigned char)finalize_jump;
	  else if (p2[3] == (unsigned char)charset ||
		   p2[3] == (unsigned char)charset_not) {
	    int not;
	    if (ismbchar(c)) {
	      unsigned char *pp = p1+3;
	      MBC2WC(c, pp);
a3800 7
	    /* `is_in_list()' is TRUE if c would match */
	    /* That means it is not safe to finalize.  */
	    not = is_in_list(c, p2 + 4);
	    if (p2[3] == (unsigned char)charset_not)
	      not = !not;
	    if (!not)
	      p[-3] = (unsigned char)finalize_jump;
a3825 5
      /* We need this opcode so we can detect where alternatives end
	 in `group_match_null_string_p' et al.  */
      case jump_past_alt:
	/* fall through */

a3829 2
        if (mcnt < 0 && stackp[-2] == d) /* avoid infinit loop */
	   goto fail;
d3833 5
d3855 1
a3855 15
	p1 = p;
	/* Skip over open/close-group commands.  */
	while (p1 + 2 < pend) {
	  if ((enum regexpcode)*p1 == stop_memory ||
	      (enum regexpcode)*p1 == start_memory)
	    p1 += 3;	/* Skip over args, too.  */
	  else if ((enum regexpcode)*p1 == stop_paren)
	      p1 += 1;
	  else
	    break;
	}
	if ((enum regexpcode)*p1 == jump)
	  p[-1] = unused;
	else
	  PUSH_FAILURE_POINT(0, 0);
a3908 2
        if (mcnt < 0 && stackp[-2] == d) /* avoid infinit loop */
	   goto fail;
d4147 231
@


1.1.1.3.2.23
log
@990531
@
text
@d60 5
a72 1
#ifndef xmalloc
a76 1
#endif
d3767 1
a3767 1
        if (mcnt < 0 && stackp > stackb && stackp[-2] == d) /* avoid infinit loop */
@


1.1.1.3.2.24
log
@thread bugs
@
text
@d445 1
a1076 3
  case 'b':
    return '\010';

d3600 2
a3601 1
	      part = not = is_in_list(cc, p);
@


1.1.1.3.2.25
log
@990624
@
text
@d196 1
a196 1
   for (c=0; c<=0x7f; c++)
d470 5
a474 6
  if (c <= 0x7ff) return ((c>>6)&0xff)|0xc0;
  if (c <= 0xffff) return ((c>>12)&0xff)|0xe0;
  if (c <= 0x1fffff) return ((c>>18)&0xff)|0xf0;
  if (c <= 0x3ffffff) return ((c>>24)&0xff)|0xf8;
  if (c <= 0x7fffffff) return ((c>>30)&0xff)|0xfc;
  if (c <= 0xfffffffff) return 0xfe;
d484 1
a484 1
    else if (c <= 0x7ff)
d486 1
a486 1
    else if (c <= 0xffff)
d488 1
a488 1
    else if (c <= 0x1fffff) 
d490 1
a490 1
    else if (c <= 0x3ffffff)
d492 1
a492 1
    else if (c <= 0x7fffffff)
d2486 2
a2487 1
    big+=mbclen(*big);
@


1.1.1.3.2.26
log
@990625
@
text
@a346 1
    start_paren,    /* Place holder at the start of (?:..). */
d467 1
a467 1
     unsigned long c;
a474 1
#if SIZEOF_INT > 4
a475 3
#else
  return 0xfe;
#endif
d480 1
a480 1
     unsigned long c;
d590 1
a590 1
  ((unsigned long)((unsigned char)(p)[0] << 24 |			\
d596 1
a596 1
  ((unsigned long)((p) += 4, 						\
d617 2
a618 2
	 unsigned long beg;		beginning of interval.
	 unsigned long end;		end of interval.
d624 1
a624 1
    unsigned long c1, c2;
d670 1
a670 1
    unsigned long c;
a738 4
    case start_paren:
      printf("/start_paren");
      break;

a999 1
    case start_paren:
a1701 1
	BUFPUSH(start_paren);
a2619 1
      case start_paren:
d2788 1
a2788 1
	  unsigned long c, beg, end;
d2837 1
a2837 1
	  unsigned long c, beg, end;
d3045 1
a3045 1
	unsigned long c;
a3478 1
      case start_paren:
d3701 1
a3701 2
	  else if (/*(enum regexpcode)*p1 == start_paren ||*/
		   (enum regexpcode)*p1 == stop_paren)
d3793 1
a3793 2
	  else if (/*(enum regexpcode)*p1 == start_paren ||*/
		   (enum regexpcode)*p1 == stop_paren)
a4054 1
#if 0
d4058 1
a4058 1
#endif
@


1.1.1.3.2.27
log
@990715
@
text
@d111 1
a111 1
#define DOUBLE_STACK(stackx,stackb,len,type)				\
d120 10
a129 1
#define FREE_VARIABLES()
a2280 7
  bufp->regstart = TMALLOC(regnum, unsigned char*);
  bufp->regend = TMALLOC(regnum, unsigned char*);
  bufp->old_regstart = TMALLOC(regnum, unsigned char*);
  bufp->old_regend = TMALLOC(regnum, unsigned char*);
  bufp->reg_info = TMALLOC(regnum, register_info_type);
  bufp->best_regstart = TMALLOC(regnum, unsigned char*);
  bufp->best_regend = TMALLOC(regnum, unsigned char*);
a2305 8

  free(bufp->regstart);
  free(bufp->regend);
  free(bufp->old_regstart);
  free(bufp->old_regend);
  free(bufp->best_regstart);
  free(bufp->best_regend);
  free(bufp->reg_info);
d2587 1
a2587 1
  unsigned char **stackb = TMALLOC(NFAILURES, unsigned char*);
d2935 3
a2937 1
	return re_match(bufp, string, size, 0, regs);
d2965 1
a2965 1
    pend = size;
d3121 12
a3132 1
/* Accessing macros used in re_match: */
d3164 1
a3164 1
    for (last_used_reg = num_regs-1; last_used_reg > 0; last_used_reg--)\
d3326 2
a3327 2
  unsigned char **regstart = bufp->regstart;
  unsigned char **regend = bufp->regend;
d3334 2
a3335 2
  unsigned char **old_regstart = bufp->old_regstart;
  unsigned char **old_regend = bufp->old_regend;
d3344 1
a3344 1
  register_info_type *reg_info = bufp->reg_info;
d3352 2
a3353 2
  unsigned char **best_regstart = bufp->best_regstart;
  unsigned char **best_regend = bufp->best_regend;
a3542 4
	if (stackp - stackb > RE_DUP_MAX) {
	   FREE_VARIABLES();
	   FREE_AND_RETURN(stackb,(-2));
	}
a3544 1
	printf("%d\n", stackp - stackb);
a4108 1
  FREE_VARIABLES();
@


1.1.1.3.2.28
log
@backtrace may be Qnil
@
text
@a2748 3
	if ((enum regexpcode)p[-1] == anychar_repeat) {
	    continue;
	}
d2855 1
a2855 1
	  unsigned long c, beg;
d3542 1
@


1.1.1.3.2.29
log
@990728
@
text
@d2228 1
a2228 1
	mcnt = *++p0;
d4098 1
a4098 1
	  /* do nothing */;
@


1.1.1.3.2.30
log
@1.3.8 to be, final beta (hopefully)
@
text
@d2944 1
a2944 3
	else if (re_match(bufp, string, size, 0, regs) >= 0)
	    return 0;
	return -1;
d4069 6
@


1.1.1.2.2.1
log
@regexp (?:xxx) bug.  too manu pops
@
text
@a1400 1
	      stackp--;
a1414 1
	      stackp--;
d1421 1
@


1.1.1.2.2.2
log
@1.1b8pre1
@
text
@d1751 1
a1751 1
	    PATFETCH_RAW(c);
d2421 1
a2421 1
	      (bufp->can_be_null && size > 0
d3003 1
a3003 1
	/* Match at the very beginning of the string. */
d3009 1
a3009 1
	/* Match at the very end of the data. */
a3011 3
	    break;
	  /* .. or newline just before the end of the data. */
	  if (*d == '\n' && AT_STRINGS_END(d+1))
@


1.1.1.2.2.3
log
@*** empty log message ***
@
text
@a1383 1
	      pending_exact = 0;
a1419 2
	      if (fixup_jump)
		store_jump(fixup_jump, jump, b);
@


1.1.1.2.2.4
log
@dyna_var,regex,line cotinuation
@
text
@a1422 1
	      pending_exact = 0;
@


1.1.1.2.2.5
log
@1.1b9_00
@
text
@a75 1
#ifdef C_ALLOCA
a76 3
#else
#define FREE_VARIABLES() 0
#endif
d116 1
a116 1
    } while (0)
d179 3
a181 24
/* Jim Meyering writes:

   "... Some ctype macros are valid only for character codes that
   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
   using /bin/cc or gcc but without giving an ansi option).  So, all
   ctype uses should be through macros like ISPRINT...  If
   STDC_HEADERS is defined, then autoconf has verified that the ctype
   macros don't need to be guarded with references to isascii. ...
   Defining isascii to 1 should let any compiler worth its salt
   eliminate the && through constant folding."  */
#if ! defined (isascii) || defined (STDC_HEADERS)
#undef isascii
#define isascii(c) 1
#endif

#ifdef isblank
#define ISBLANK(c) (isascii (c) && isblank (c))
#else
#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
#endif
#ifdef isgraph
#define ISGRAPH(c) (isascii (c) && isgraph (c))
#else
#define ISGRAPH(c) (isascii (c) && isprint (c) && !isspace (c))
a183 11
#define ISPRINT(c) (isascii (c) && isprint (c))
#define ISDIGIT(c) (isascii (c) && isdigit (c))
#define ISALNUM(c) (isascii (c) && isalnum (c))
#define ISALPHA(c) (isascii (c) && isalpha (c))
#define ISCNTRL(c) (isascii (c) && iscntrl (c))
#define ISLOWER(c) (isascii (c) && islower (c))
#define ISPUNCT(c) (isascii (c) && ispunct (c))
#define ISSPACE(c) (isascii (c) && isspace (c))
#define ISUPPER(c) (isascii (c) && isupper (c))
#define ISXDIGIT(c) (isascii (c) && isxdigit (c))

d331 1
a331 1
long re_syntax_options = 0;
d407 1
a407 1
	while (ISDIGIT(c)) 						\
d1208 1
a1208 1
		      if (current_mbctype) {
d1216 1
a1216 1
			  if (ISSPACE(c))
d1223 1
a1223 1
			  if (!ISSPACE(c))
d1225 1
a1225 1
		      if (current_mbctype) {
d1239 1
a1239 1
			  if (!ISDIGIT(c))
d1241 1
a1241 1
		      if (current_mbctype) {
d1249 1
a1249 1
		      if (current_mbctype && c > 0x7f)
d1258 2
a1259 2
		      if (ismbchar(c))
			  c |= 0xff00;
d1696 1
a1696 1
	      if (current_mbctype && c > 0x7f)
d1705 1
a1705 1
	      if (current_mbctype && c > 0x7f)
d1729 1
a1729 1
		      if (current_mbctype && c > 0x7f)
a3395 97
}

/* Functions for multi-byte support.
   Created for grep multi-byte extension Jul., 1993 by t^2 (Takahiro Tanimoto)
   Last change: Jul. 9, 1993 by t^2  */
static const unsigned char mbctab_ascii[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

static const unsigned char mbctab_euc[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};

static const unsigned char mbctab_sjis[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};

#ifdef EUC
const unsigned char *mbctab = mbctab_euc;
int current_mbctype = MBCTYPE_EUC;
#else
#ifdef SJIS
const unsigned char *mbctab = mbctab_sjis;
int current_mbctype = MBCTYPE_SJIS;
#else
const unsigned char *mbctab = mbctab_ascii;
int current_mbctype = MBCTYPE_ASCII;
#endif
#endif

void
#ifdef __STDC__
mbcinit(int mbctype)
#else
mbcinit(mbctype)
     int mbctype;
#endif
{
  switch (mbctype) {
  case MBCTYPE_ASCII:
    mbctab = mbctab_ascii;
    current_mbctype = MBCTYPE_ASCII;
    break;
  case MBCTYPE_EUC:
    mbctab = mbctab_euc;
    current_mbctype = MBCTYPE_EUC;
    break;
  case MBCTYPE_SJIS:
    mbctab = mbctab_sjis;
    current_mbctype = MBCTYPE_SJIS;
    break;
  }
@


1.1.1.2.2.6
log
@gets speed up patch
@
text
@a454 11
#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))

#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */

#define IS_CHAR_CLASS(string)						\
   (STREQ (string, "alpha") || STREQ (string, "upper")			\
    || STREQ (string, "lower") || STREQ (string, "digit")		\
    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
    || STREQ (string, "space") || STREQ (string, "print")		\
    || STREQ (string, "punct") || STREQ (string, "graph")		\
    || STREQ (string, "cntrl") || STREQ (string, "blank"))
a995 1

a996 1
    int had_char_class = 0;
d1194 1
a1194 1
	  had_char_class = 0;
a1223 4
	      /* Look ahead to see if it's a range when the last thing
		 was a character class.  */
	      if (had_char_class && c == '-' && *p != ']')
		  goto invalid_pattern;
d1332 1
a1332 78
	      else if ((re_syntax_options & RE_CHAR_CLASSES)
		       && c == '[' && *p == ':') {
		  /* Leave room for the null.  */
		  char str[CHAR_CLASS_MAX_LENGTH + 1];

		  PATFETCH_RAW (c);
		  c1 = 0;

		  /* If pattern is `[[:'.  */
		  if (p == pend) 
		      goto invalid_pattern;

		  for (;;) {
		      PATFETCH (c);
		      if (c == ':' || c == ']' || p == pend
			  || c1 == CHAR_CLASS_MAX_LENGTH)
                          break;
		      str[c1++] = c;
		  }
		  str[c1] = '\0';

		  /* If isn't a word bracketed by `[:' and:`]':
		     undo the ending character, the letters, and leave 
		     the leading `:' and `[' (but set bits for them).  */
		  if (c == ':' && *p == ']') {
		      int ch;
		      char is_alnum = STREQ (str, "alnum");
		      char is_alpha = STREQ (str, "alpha");
		      char is_blank = STREQ (str, "blank");
		      char is_cntrl = STREQ (str, "cntrl");
		      char is_digit = STREQ (str, "digit");
		      char is_graph = STREQ (str, "graph");
		      char is_lower = STREQ (str, "lower");
		      char is_print = STREQ (str, "print");
		      char is_punct = STREQ (str, "punct");
		      char is_space = STREQ (str, "space");
		      char is_upper = STREQ (str, "upper");
		      char is_xdigit = STREQ (str, "xdigit");

		      if (!IS_CHAR_CLASS (str))
			  goto invalid_pattern;

		      /* Throw away the ] at the end of the character
			 class.  */
		      PATFETCH (c);					

		      if (p == pend) 
			  goto invalid_pattern;


		      for (ch = 0; ch < 1 << BYTEWIDTH; ch++) {
			  if (   (is_alnum  && ISALNUM (ch))
			      || (is_alpha  && ISALPHA (ch))
			      || (is_blank  && ISBLANK (ch))
			      || (is_cntrl  && ISCNTRL (ch))
			      || (is_digit  && ISDIGIT (ch))
			      || (is_graph  && ISGRAPH (ch))
			      || (is_lower  && ISLOWER (ch))
			      || (is_print  && ISPRINT (ch))
			      || (is_punct  && ISPUNCT (ch))
			      || (is_space  && ISSPACE (ch))
			      || (is_upper  && ISUPPER (ch))
			      || (is_xdigit && ISXDIGIT (ch)))
			      SET_LIST_BIT (ch);
		      }
		      had_char_class = 1;
		  }
		  else {
		      c1++;
		      while (c1--)    
                          PATUNFETCH;
		      SET_LIST_BIT(translate?translate['[']:'[');
		      SET_LIST_BIT(translate?translate[':']:':');
		      had_char_class = 0;
		      last = ':';
                  }
	      }
	      else if (c < 1 << BYTEWIDTH)
@


1.1.1.2.2.7
log
@extended regexp bug fix
@
text
@d1851 1
a1851 1
		  if (!ISDIGIT(c)) PATUNFETCH;
a2894 2
	      while (stackp != stackb && (int)stackp[-1] == 1)
		POP_FAILURE_POINT();
d2897 1
a2897 1
		  /* More failure points to try.  */
d3422 2
@


1.1.1.2.2.8
log
@1.1b9_19
@
text
@a34 4
#ifdef __MWERKS__
#include "ruby.h"
#endif

@


1.1.1.2.2.9
log
@prototypes
@
text
@d3606 3
d3611 1
@


1.1.1.2.2.10
log
@ruby 1.1b9_20
@
text
@d35 7
a51 14
#ifdef __MWERKS__
#include "ruby.h"
#else

#include "config.h"
#include "defines.h"

void *xmalloc P((unsigned long));
void *xcalloc P((unsigned long,unsigned long));
void *xrealloc P((void*,unsigned long));
void free P((void*));

#endif

d83 1
a83 1
#define FREE_VARIABLES()
d94 1
a94 1
#define RE_ALLOCATE xmalloc
d827 2
a828 2
    char *start;
    char *end;
d832 3
a834 3
  char *p = start;
  char *pend = end;
  char *must = 0;
d1023 8
a1030 7
    if (bufp->allocated == 0) {
      bufp->allocated = INIT_BUF_SIZE;
      if (bufp->buffer)
	/* EXTEND_BUFFER loses when bufp->allocated is 0.  */
	bufp->buffer = (char *) xrealloc (bufp->buffer, INIT_BUF_SIZE);
      else
	/* Caller did not allocate a buffer.  Do it for them.  */
d1036 2
a1037 1
    while (p != pend) {
@


1.1.1.2.2.11
log
@*** empty log message ***
@
text
@d45 4
d56 2
@


1.1.1.2.2.12
log
@isascii() removed
@
text
@d198 5
d204 1
a204 1
#define ISBLANK(c) isblank ((unsigned char)c)
d209 1
a209 1
#define ISGRAPH(c) isgraph ((unsigned char)c)
d211 1
a211 1
#define ISGRAPH(c) (isprint ((unsigned char)c) && !isspace ((unsigned char)c))
d214 10
a223 10
#define ISPRINT(c) isprint ((unsigned char)c)
#define ISDIGIT(c) isdigit ((unsigned char)c)
#define ISALNUM(c) isalnum ((unsigned char)c)
#define ISALPHA(c) isalpha ((unsigned char)c)
#define ISCNTRL(c) iscntrl ((unsigned char)c)
#define ISLOWER(c) islower ((unsigned char)c)
#define ISPUNCT(c) ispunct ((unsigned char)c)
#define ISSPACE(c) isspace ((unsigned char)c)
#define ISUPPER(c) isupper ((unsigned char)c)
#define ISXDIGIT(c) isxdigit ((unsigned char)c)
@


1.1.1.2.2.13
log
@*** empty log message ***
@
text
@d137 2
a138 1
static int memcmp_translate P((unsigned char *, unsigned char *, int));
a151 1
static char *translate = 0;
a187 7
void
re_set_casetable(table)
     char *table;
{
  translate = table;
}

a289 3
    start_paren,   /* Just a mark for starting(?:). */
    start_casefold, /* Start casefold region. */
    stop_casefold,  /* End casefold region. */
a371 1
#define TRANSLATE_P() ((options&RE_OPTION_IGNORECASE) && translate)
d379 1
a379 1
    if (TRANSLATE_P()) c = (unsigned char)translate[c];	\
a651 12
	case start_paren:
	  printf ("/start_paren");
	  break;

	case start_casefold:
	  printf ("/start_casefold");
	  break;

	case stop_casefold:
	  printf ("/stop_casefold");
	  break;

a855 3
	case start_casefold:
	case stop_casefold:
	case start_paren:
d1011 2
a1012 1
    int options = bufp->options;
d1041 10
a1050 2

	    while (p1 != pend)
d1052 8
a1059 5
		if (*p1 == '\\' && p1 + 1 != pend
		    && (p1[1] == 'b' || p1[1] == 'B'))
		  p1 += 2;
		else
		  break;
d1065 7
a1071 2
		|| *p1 == ')'
		|| *p1 == '|')
d1082 1
a1082 1
          if (laststart)
d1084 2
a1085 1
          if (laststart && p - 2 >= pattern && p[-2] != '\n')
d1087 12
a1098 1
	  BUFPUSH(begline);
d1103 2
d1108 4
a1111 1
	    goto invalid_pattern;
d1224 3
a1226 1
                      if (p == pend)
d1328 4
d1445 4
a1449 24
		case 'i':
		  for (;;) {
		    switch (c) {
		    case ')':
		      break;

		    case 'x':
		      options |= RE_OPTION_EXTENDED;
		      break;
		    case 'i':
		      options |= RE_OPTION_IGNORECASE;
		      BUFPUSH(start_casefold);
		      break;

		    default:
		      FREE_AND_RETURN(stackb, "undefined (?...) inline option");
		    }
		    if (c == ')') break;
		    PATFETCH(c);
		  }
		  c = '#';	/* read whole in-line options */
		  break;

		case '#':
d1471 1
a1471 1
	  if (stackp+7 >= stacke) {
a1511 2
	      if (b > bufp->buffer && b[-1] != start_paren)
		BUFPUSH(start_paren);
a1516 1
	  *stackp++ = options;
a1523 4
	  if ((options ^ stackp[-1]) & RE_OPTION_IGNORECASE) {
	    BUFPUSH(stop_casefold);
	  }
	  options = *--stackp;
d1592 3
a1600 1

a1606 1
		 || *laststart == start_paren
d1610 2
a1611 1
		 || *laststart == duplicate))
d1615 3
a1877 17
	case '#':
	  if (options & RE_OPTION_EXTENDED)
	    {
	      while (p != pend) {
		PATFETCH(c);
		if (c == '\n') break;
	      }
	      break;
	    }
	  goto normal_char;

	case ' ':
	case '\t':
	case '\n':
	  if (options & RE_OPTION_EXTENDED)
	    break;

d2163 1
a2168 1
  int options = bufp->options;
d2190 1
a2190 1
	      if (TRANSLATE_P())
d2195 1
a2195 1
	  else if (TRANSLATE_P())
a2208 3
	case start_paren:
	case start_casefold:
	case stop_casefold:
d2212 1
a2212 1
	  if (TRANSLATE_P())
d2336 1
a2336 1
		if (TRANSLATE_P())
d2456 1
a2457 1
  int options = bufp->options;
d2493 1
a2493 1
		     (TRANSLATE_P())?translate:0)) {
d2531 1
a2531 1
		  if (fastmap[(TRANSLATE_P()) ? translate[c] : c])
d2543 1
a2543 1
	      if ((TRANSLATE_P()) ? !fastmap[translate[c]] : !fastmap[c])
d2790 1
a2790 1
  int options = bufp->options;
d3044 2
a3045 2
		if ((options & RE_OPTION_IGNORECASE) 
                    ? memcmp_translate(d, d2, mcnt) 
d3082 3
a3084 1
	  if (((TRANSLATE_P()) ? translate[*d] : *d) == '\n')
d3105 1
a3105 1
	    else if (TRANSLATE_P())
d3311 2
a3312 2
          EXTRACT_NUMBER(mcnt, p + 2); 
         /* Originally, this is how many times we CAN jump.  */
a3313 2
	    int pos, i;

a3315 3
	    EXTRACT_NUMBER(pos, p);
	    EXTRACT_NUMBER(i, p+pos+5);
	    if (i > 0) goto nofinalize;
a3331 11
        case start_paren:
	  continue;

        case start_casefold:
	  options |= RE_OPTION_IGNORECASE;
	  continue;

        case stop_casefold:
	  options &= ~RE_OPTION_IGNORECASE;
	  continue;

d3377 1
a3377 1
          if (TRANSLATE_P())
d3472 1
a3472 1
memcmp_translate(s1, s2, len)
d3475 1
@


1.1.1.2.2.14
log
@regexp (?XI)
@
text
@d298 2
a299 2
    casefold_on,   /* Turn on casefold flag. */
    casefold_off,  /* Turn off casefold flag. */
d667 2
a668 2
	case casefold_on:
	  printf ("/casefold_on");
d671 2
a672 2
	case casefold_off:
	  printf ("/casefold_off");
d879 2
a880 2
	case casefold_on:
	case casefold_off:
d1429 1
a1429 1
	      PATFETCH_RAW(c);
d1431 2
a1432 2
		case 'x': case 'X':
		case 'i': case 'I':
a1440 3
		    case 'X':
		      options &= ~RE_OPTION_EXTENDED;
		      break;
d1442 2
a1443 10
		      if (!(options&RE_OPTION_IGNORECASE)) {
			options |= RE_OPTION_IGNORECASE;
			BUFPUSH(casefold_on);
		      }
		      break;
		    case 'I':
		      if (options&RE_OPTION_IGNORECASE) {
			options &= ~RE_OPTION_IGNORECASE;
			BUFPUSH(casefold_off);
		      }
d1450 1
a1450 1
		    PATFETCH_RAW(c);
d1534 1
a1534 1
	    BUFPUSH((options&RE_OPTION_IGNORECASE)?casefold_off:casefold_on);
a1898 2
	case '\f':
	case '\r':
d2235 2
a2236 2
	case casefold_on:
	case casefold_off:
d3366 1
a3366 1
        case casefold_on:
d3370 1
a3370 1
        case casefold_off:
@


1.1.1.2.2.15
log
@1.1b9_23
@
text
@a868 1
	    max = mcnt;
a880 2
	  return 0;		/* should not check must_string */

d2228 4
a2231 6
	    if (TRANSLATE_P()) {
	      fastmap[translate[p[2]]] = 2;
	      bufp->options |= RE_MAY_IGNORECASE;
	    }
	    else
	      fastmap[p[2]] = 2;
d2233 1
a2233 1
	  else if (TRANSLATE_P()) {
a2234 2
	    bufp->options |= RE_MAY_IGNORECASE;
	  }
a2247 2
	  continue;

a2249 1
	  options ^= RE_OPTION_IGNORECASE;
d2253 1
a2253 1
	  if (TRANSLATE_P()) {
a2254 2
	    bufp->options |= RE_MAY_IGNORECASE;
	  }
d2377 1
a2377 1
		if (TRANSLATE_P()) {
a2378 2
		  bufp->options |= RE_MAY_IGNORECASE;
		}
d2529 1
a2529 1

d2534 1
a2534 2
		     (bufp->options&(RE_OPTION_IGNORECASE|RE_MAY_IGNORECASE))?
		     translate:0)) {
d2537 1
a2537 1

d2572 1
a2572 2
		  if (fastmap[(bufp->options&(RE_OPTION_IGNORECASE|RE_MAY_IGNORECASE))?
			     translate[c] : c])
d2584 1
a2584 2
	      if ((bufp->options&(RE_OPTION_IGNORECASE|RE_MAY_IGNORECASE)) ?
		  !fastmap[translate[c]] : !fastmap[c])
@


1.1.1.2.2.16
log
@*** empty log message ***
@
text
@a382 1
#define TRY_TRANSLATE() ((bufp->options&(RE_OPTION_IGNORECASE|RE_MAY_IGNORECASE)) && translate)
d2231 1
a2231 1
	    if (TRANSLATE_P())
d2233 2
d2238 1
a2238 1
	  else if (TRANSLATE_P())
d2240 2
d2263 1
a2263 1
	  if (TRANSLATE_P())
d2265 2
d2389 1
a2389 1
		if (TRANSLATE_P())
d2391 2
d2548 2
a2549 1
		     TRY_TRANSLATE()?translate:0)) {
d2587 2
a2588 1
		  if (fastmap[TRY_TRANSLATE() ? translate[c] : c])
d2600 2
a2601 1
	      if (TRY_TRANSLATE() ? !fastmap[translate[c]] : !fastmap[c])
a3396 1
	  bufp->options |= RE_MAY_IGNORECASE;
@


1.1.1.2.2.17
log
@*** empty log message ***
@
text
@d1636 1
a1636 1
			 || (laststart[1] == 2 && ismbchar(laststart[2]))))
d1961 3
d2505 1
@


1.1.1.2.2.18
log
@*** empty log message ***
@
text
@d1067 1
a1067 1
	    p0 = p;
d1071 1
a1071 1
	    while (p0 != pend)
d1073 3
a1075 3
		if (*p0 == '\\' && p0 + 1 != pend
		    && (p0[1] == 'b' || p0[1] == 'B'))
		  p0 += 2;
d1082 3
a1084 3
	    if (p0 == pend || *p0 == '\n'
		|| *p0 == ')'
		|| *p0 == '|')
d1547 1
a1547 2
	  if (stackp == stackb) 
	    FREE_AND_RETURN(stackb, "unmatched )");
d1752 1
a1752 6
		STORE_NUMBER_AND_INCR(b, laststart - b + 11);
		STORE_NUMBER_AND_INCR(b, lower_bound);

		GET_BUFFER_SPACE(5);
		BUFPUSH(set_number_at);
		STORE_NUMBER_AND_INCR(b, -10);
d1954 1
a1954 2
  if (stackp != stackb)
    FREE_AND_RETURN(stackb, "unmatched (");
d1964 6
a2251 1
	  bufp->options |= RE_MAY_IGNORECASE;
a2532 5
  /* Update the fastmap now if not correct already.  */
  if (fastmap && !bufp->fastmap_accurate) {
      re_compile_fastmap(bufp);
  }

d2541 5
d2663 1
a2663 1
typedef union
d2665 6
a2670 17
  unsigned char *word;
  struct
  {
      /* This field is one if this group can match the empty string,
         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
#define MATCH_NULL_UNSET_VALUE 3
    unsigned match_null_string_p : 2;
    unsigned is_active : 1;
    unsigned matched_something : 1;
    unsigned ever_matched_something : 1;
  } bits;
} register_info_type;

#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
#define IS_ACTIVE(R)  ((R).bits.is_active)
#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
d2701 1
a2701 1
      if (!REG_UNSET(regstart[last_used_reg]))				\
d2723 1
a2723 1
        *stackp++ = reg_info[this_reg].word;				\
a2745 4
/* Registers are set to a sentinel when they haven't yet matched.  */
#define REG_UNSET_VALUE ((unsigned char *) -1)
#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)

d2870 1
a2870 1
  register_info_type *reg_info = RE_TALLOC(num_regs, register_info_type);
d2899 3
a2901 5
      regstart[mcnt] = regend[mcnt] 
        = best_regstart[mcnt] = best_regend[mcnt] = REG_UNSET_VALUE;
      reg_info[mcnt].word = 0;
      IS_ACTIVE (reg_info[mcnt]) = 0;
      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
d2980 1
a2980 1
		  if (REG_UNSET(regend[mcnt]))
a3060 2
	    if (IS_ACTIVE(reg_info[regno])) break;

a3062 1
	    if (REG_UNSET(d2)) break;
a3069 1
	    if (REG_UNSET(dend2)) break;
d3383 1
d3514 1
a3514 1
              reg_info[this_reg].word = *--stackp;
@


1.1.1.2.2.19
log
@regex.c
@
text
@d297 1
d664 4
d885 1
a1012 4
    /* Place in the uncompiled pattern (i.e., the {) to
       which to go back if the interval is invalid.  */
    char *beg_interval;

d1533 2
d1619 1
a1619 1
	  if (!laststart || p == pend)
d1623 21
a1643 3

	  beg_interval = p - 1;

d1649 2
a1650 1
	    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
d1652 1
a1652 2
	  else
	    /* Interval such as `{1}' => match exactly once. */
d1654 5
a1658 12

	  if (lower_bound < 0 || c != '}')
	    goto unfetch_interval;

	  if (lower_bound > RE_DUP_MAX || upper_bound > RE_DUP_MAX)
	    FREE_AND_RETURN(stackb, "too big quantifier in {,}");
	  if (lower_bound > upper_bound)
	    FREE_AND_RETURN(stackb, "can't do {n,m} with n > m");

	  beg_interval = 0;
	  pending_exact = 0;

d1666 11
d1688 4
a1691 10
	  if (lower_bound == 1) {
	    if (upper_bound == 1) {
	      /* No need to repeat */
	      break;
	    }
	    if (upper_bound == RE_DUP_MAX) {
	      many_times_ok = 1;
	      zero_times_ok = 0;
	      goto repeat;
	    }
d1694 3
a1696 8
	  /* If upper_bound is zero, don't want to succeed at all; 
	     jump from laststart to b + 3, which will be the end of
	     the buffer after this jump is inserted.  */

	  if (upper_bound == 0) {
	    GET_BUFFER_SPACE(3);
	    insert_jump(jump, laststart, b + 3, b);
	    b += 3;
a1697 1
	  }
a1698 9
	  /* Otherwise, we have a nontrivial interval.  When
	     we're all done, the pattern will look like:
	     set_number_at <jump count> <upper bound>
	     set_number_at <succeed_n count> <lower bound>
	     succeed_n <after jump addr> <succed_n count>
	     <body of loop>
	     jump_n <succeed_n addr> <jump count>
	     (The upper bound and `jump_n' are omitted if
	     `upper_bound' is 1, though.)  */
d1701 1
a1701 1
	    unsigned nbytes = upper_bound == 1 ? 10 : 20;
d1703 1
a1703 1
	    GET_BUFFER_SPACE(nbytes);
d1709 1
a1709 1
	    insert_jump_n(succeed_n, laststart, b + (nbytes/2), 
d1717 1
d1730 1
a1730 2
		store_jump_n(b, greedy?jump_n:finalize_push_n, laststart + 5,
			     upper_bound - 1);
d1747 2
a1748 2
		insert_op_2(set_number_at, laststart, b, b - laststart,
			    upper_bound - 1);
d1750 10
d1761 1
a1764 9
	unfetch_interval:
	  /* If an invalid interval, match the characters as literals.  */
	  p = beg_interval;
	  beg_interval = 0;

	  /* normal_char and normal_backslash need `c'.  */
	  PATFETCH (c);	
	  goto normal_char;

d2249 1
a2285 1
	      && (enum regexpcode) *p != succeed_n
d2721 1
a2721 1
	/* if (len > re_max_failures * MAX_NUM_FAILURE_ITEMS)		\
d2725 1
a2725 1
	  }*/								\
d3390 1
a3390 1
	    p += 2;		/* skip n */
d3400 3
@


1.1.1.2.2.20
log
@regex
@
text
@a101 2
    FREE_VAR(old_regstart)						\
    FREE_VAR(old_regend);						\
a137 3
static int alt_match_null_string_p ();
static int common_op_match_null_string_p ();
static int group_match_null_string_p ();
a246 1
    jump_past_alt,/* Same as jump, but marks the end of an alternative.  */
a264 2
    push_dummy_failure, /* Push a dummy failure point and continue.  Used at the end of
			   alternatives.  */
d434 2
a435 2
    if (fixup_alt_jump)							\
      fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;	\
d655 1
a655 1
          printf ("/start_memory/%d/%d", mcnt, *p++);
d660 1
a660 1
	  printf ("/stop_memory/%d/%d", mcnt, *p++);
a742 4
	case push_dummy_failure:
          printf ("/push_dummy_failure");
          break;
          
a752 5
        case jump_past_alt:
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);
  	  printf ("/jump_past_alt//%d", mcnt);
	  break;

a871 3
	  p += 2;
	  break;

a893 1
        case push_dummy_failure:
d984 1
a984 1
    char *fixup_alt_jump = 0;
d1020 1
a1020 1
       Second, the value of fixup_alt_jump.
d1490 1
a1490 1
	  if (stackp+8 >= stacke) {
d1505 1
a1505 1
	  *stackp++ = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
a1511 2
	      *stackp++ = b - bufp->buffer;
	      BUFPUSH(0);
d1537 1
a1537 1
	  fixup_alt_jump = 0;
d1551 5
a1555 21
	    case ':':
	      pending_exact = 0;
	      if (fixup_alt_jump)
		{ /* Push a dummy failure point at the end of the
		     alternative for a possible future
		     `finalize_jump' to pop.  See comments at
		     `push_dummy_failure' in `re_match_2'.  */
		  BUFPUSH(push_dummy_failure);
                  
		  /* We allocated space for this jump when we assigned
		     to `fixup_alt_jump', in the `handle_alt' case below.  */
		  store_jump(fixup_alt_jump, jump, b);
		}
	      if (c == '(') {
		char *loc = bufp->buffer + *--stackp;
		*loc = regnum - stackp[-1];
		BUFPUSH(stop_memory);
		BUFPUSH(stackp[-1]);
		BUFPUSH(regnum - stackp[-1]);
		stackp--;
	      }
d1573 4
d1582 1
a1582 1
	  fixup_alt_jump = *stackp ? *stackp + bufp->buffer - 1 : 0;
d1594 9
a1602 18
	  /* The alternative before this one has a jump after it
	     which gets executed if it gets matched.  Adjust that
	     jump so it will jump to this alternative's analogous
	     jump (put in below, which in turn will jump to the next
	     (if any) alternative's such jump, etc.).  The last such
	     jump jumps to the correct final destination.  A picture:
	     	_____ _____ 
	     	|   | |   |   
	     	|   v |   v 
	     	a | b   | c   

	     If we are at `b', then fixup_alt_jump right now points to a
	     three-byte space after `a'.  We'll put in the jump, set
	     fixup_alt_jump to right after `b', and leave behind three
	     bytes which we'll fill in when we get to after `c'.  */

	  if (fixup_alt_jump)
	    store_jump(fixup_alt_jump, jump_past_alt, b);
d1606 1
a1606 1
	  fixup_alt_jump = b;
d1950 2
a1951 2
  if (fixup_alt_jump)
    store_jump(fixup_alt_jump, jump, b);
a2241 1
        case push_dummy_failure:
a2263 1
        case jump_past_alt:
d2338 1
a2338 1
	  p += 2;
d2766 1
a2766 3
          MATCHED_SOMETHING(reg_info[this_reg])				\
            = EVER_MATCHED_SOMETHING (reg_info[this_reg])		\
            = 1;							\
a2833 1
  unsigned char *p1;
a2872 8
  /* If a group that's operated upon by a repetition operator fails to
     match anything, then the register for its start will need to be
     restored because it will have been set to wherever in the string we
     are when we last see its open-group operator.  Similarly for a
     register's end.  */
  unsigned char **old_regstart = RE_TALLOC(num_regs, unsigned char*);
  unsigned char **old_regend = RE_TALLOC(num_regs, unsigned char*);

d2909 5
a2913 7
    regstart[mcnt] = regend[mcnt]
      = old_regstart[mcnt] = old_regend[mcnt]
      = best_regstart[mcnt] = best_regend[mcnt] = REG_UNSET_VALUE;
    REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
    IS_ACTIVE (reg_info[mcnt]) = 0;
    MATCHED_SOMETHING (reg_info[mcnt]) = 0;
    EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
a3018 14
          /* Find out if this group can match the empty string.  */
	  p1 = p;		/* To send to group_match_null_string_p.  */
          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
            REG_MATCH_NULL_STRING_P (reg_info[*p]) 
              = group_match_null_string_p (&p1, pend, reg_info);

          /* Save the position in the string where we were the last time
             we were at this open-group operator in case the group is
             operated upon by a repetition operator, e.g., with `(a*)*b'
             against `ab'; then we want to ignore where we are now in
             the string in case this attempt to match fails.  */
          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
                             : regstart[*p];
d3022 1
a3022 1
          p += 2;
a3025 9
          /* We need to save the string position the last time we were at
             this close-group operator in case the group is operated
             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
             against `aba'; then we want to ignore where we are now in
             the string in case this attempt to match fails.  */
          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
			   : regend[*p];

a3039 1
		  case finalize_push_n:
d3056 1
a3056 2
	      if (mcnt < 0 && (enum regexpcode) *p2++ == on_failure_jump
                  && (enum regexpcode) p1[3] == start_memory && p1[4] == *p)
a3057 27
                  /* If this group ever matched anything, then restore
                     what its registers were before trying this last
                     failed match, e.g., with `(a*)*b' against `ab' for
                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
                     against `aba' for regend[3].
                     
                     Also restore the registers for inner groups for,
                     e.g., `((a*)(b*))*' against `aba' (register 3 would
                     otherwise get trashed).  */
                     
                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
		    {
		      unsigned r; 
        
                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
                      
		      /* Restore this and inner groups' (if any) registers.  */
                      for (r = *p; r < *p + *(p + 1); r++)
                        {
                          regstart[r] = old_regstart[r];

                          /* xx why this test?  */
                          if ((int) old_regend[r] >= (int) regstart[r])
                            regend[r] = old_regend[r];
                        }     
                    }
		  p2++;
d3063 1
a3063 1
          p += 2;
d3238 7
a3244 20

            /* Compare the beginning of the repeat with what in the
               pattern follows its end. If we can establish that there
               is nothing that they would both match, i.e., that we
               would have to backtrack because of (as in, e.g., `a*a')
               then we can change to pop_failure_jump, because we'll
               never have to backtrack.
               
               This is not true in the case of alternatives: in
               `(a|ab)*' we do need to backtrack to the `ab' alternative
               (e.g., if the string was `ab').  But instead of trying to
               detect that here, the alternative has put on a dummy
               failure point which is what we will end up popping.  */

	    /* Skip over open/close-group commands.  */
	    while (p2 + 2 < pend
		   && ((enum regexpcode) *p2 == stop_memory
		       || (enum regexpcode) *p2 == start_memory))
	      p2 += 3;			/* Skip over args, too.  */

a3296 5
        /* We need this opcode so we can detect where alternatives end
           in `group_match_null_string_p' et al.  */
        case jump_past_alt:
          goto nofinalize;

a3305 11
        /* At the end of an alternative, we need to push a dummy failure
           point in case we are followed by a `finalize_jump', because
           we don't want the failure point for the alternative to be
           popped.  For example, matching `(a|ab)*' against `aab'
           requires that we match the `ab' alternative.  */
        case push_dummy_failure:
          /* See comments just above at `dummy_failure_jump' about the
             two zeroes.  */
          PUSH_FAILURE_POINT(0, 0);
          break;

d3530 1
a3530 31

          if (p < pend)
            {
              int is_a_jump_n = 0;
	      unsigned char *p1 = p;
              
              /* If failed to a backwards jump that's part of a repetition
                 loop, need to pop this failure point and use the next one.  */
              switch ((enum regexpcode) *p1)
                {
                case jump_n:
                case finalize_push_n:
                  is_a_jump_n = 1;
                case maybe_finalize_jump:
                case finalize_jump:
                case finalize_push:
                case jump:
                  p1 = p + 1;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  p1 += mcnt;

                  if ((is_a_jump_n && (enum regexpcode) *p1 == succeed_n)
                      || (!is_a_jump_n
                          && (enum regexpcode) *p1 == on_failure_jump))
                    goto fail;
                  break;
                default:
                  /* do nothing */ ;
                }
            }
        }
a3539 239


/* We are passed P pointing to a register number after a start_memory.
   
   Return true if the pattern up to the corresponding stop_memory can
   match the empty string, and false otherwise.
   
   If we find the matching stop_memory, sets P to point to one past its number.
   Otherwise, sets P to an undefined byte less than or equal to END.

   We don't handle duplicates properly (yet).  */

static int
group_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  /* Point to after the args to the start_memory.  */
  unsigned char *p1 = *p + 2;
  
  while (p1 < end)
    {
      /* Skip over opcodes that can match nothing, and return true or
	 false, as appropriate, when we get to one that can't, or to the
         matching stop_memory.  */
      
      switch ((enum regexpcode) *p1)
        {
        /* Could be either a loop or a series of alternatives.  */
        case on_failure_jump:
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          
          /* If the next operation is not a jump backwards in the
	     pattern.  */

	  if (mcnt >= 0)
	    {
              /* Go through the on_failure_jumps of the alternatives,
                 seeing if any of the alternatives cannot match nothing.
                 The last alternative starts with only a jump,
                 whereas the rest start with on_failure_jump and end
                 with a jump, e.g., here is the pattern for `a|b|c':

                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
                 /exactn/1/c						

                 So, we have to first go through the first (n-1)
                 alternatives and then deal with the last one separately.  */


              /* Deal with the first (n-1) alternatives, which start
                 with an on_failure_jump (see above) that jumps to right
                 past a jump_past_alt.  */

              while ((enum regexpcode) p1[mcnt-3] == jump_past_alt)
                {
                  /* `mcnt' holds how many bytes long the alternative
                     is, including the ending `jump_past_alt' and
                     its number.  */

                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
				                      reg_info))
                    return 0;

                  /* Move to right after this alternative, including the
		     jump_past_alt.  */
                  p1 += mcnt;	

                  /* Break if it's the beginning of an n-th alternative
                     that doesn't begin with an on_failure_jump.  */
                  if ((enum regexpcode) *p1 != on_failure_jump)
                    break;
		
		  /* Still have to check that it's not an n-th
		     alternative that starts with an on_failure_jump.  */
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  if ((enum regexpcode) p1[mcnt-3] != jump_past_alt)
                    {
		      /* Get to the beginning of the n-th alternative.  */
                      p1 -= 3;
                      break;
                    }
                }

              /* Deal with the last alternative: go back and get number
                 of the `jump_past_alt' just before it.  `mcnt' contains
                 the length of the alternative.  */
              EXTRACT_NUMBER (mcnt, p1 - 2);

              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
                return 0;

              p1 += mcnt;	/* Get past the n-th alternative.  */
            } /* if mcnt > 0 */
          break;

          
        case stop_memory:
          *p = p1 + 2;
          return 1;

        
        default: 
          if (!common_op_match_null_string_p (&p1, end, reg_info))
            return 0;
        }
    } /* while p1 < end */

  return 0;
} /* group_match_null_string_p */


/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
   It expects P to be the first byte of a single alternative and END one
   byte past the last. The alternative can contain groups.  */
   
static int
alt_match_null_string_p (p, end, reg_info)
    unsigned char *p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  unsigned char *p1 = p;
  
  while (p1 < end)
    {
      /* Skip over opcodes that can match nothing, and break when we get 
         to one that can't.  */
      
      switch ((enum regexpcode) *p1)
        {
	/* It's a loop.  */
        case on_failure_jump:
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
          break;
          
	default: 
          if (!common_op_match_null_string_p (&p1, end, reg_info))
            return 0;
        }
    }  /* while p1 < end */

  return 1;
} /* alt_match_null_string_p */


/* Deals with the ops common to group_match_null_string_p and
   alt_match_null_string_p.  
   
   Sets P to one after the op and its arguments, if any.  */

static int
common_op_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  int ret;
  int reg_no;
  unsigned char *p1 = *p;

  switch ((enum regexpcode) *p1++)
    {
    case unused:
    case begline:
    case endline:
    case begbuf:
    case endbuf:
    case wordbeg:
    case wordend:
    case wordbound:
    case notwordbound:
#ifdef emacs
    case before_dot:
    case at_dot:
    case after_dot:
#endif
      break;

    case start_memory:
      reg_no = *p1;
      ret = group_match_null_string_p (&p1, end, reg_info);
      
      /* Have to set this here in case we're checking a group which
         contains a group and a back reference to it.  */

      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;

      if (!ret)
        return 0;
      break;
          
    /* If this is an optimized succeed_n for zero times, make the jump.  */
    case jump:
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
      if (mcnt >= 0)
        p1 += mcnt;
      else
        return 0;
      break;

    case succeed_n:
      /* Get to the number of times to succeed.  */
      p1 += 2;		
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);

      if (mcnt == 0)
        {
          p1 -= 4;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
        }
      else
        return 0;
      break;

    case duplicate: 
      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
        return 0;
      break;

    case set_number_at:
      p1 += 4;

    default:
      /* All other opcodes mean we cannot match the empty string.  */
      return 0;
  }

  *p = p1;
  return 1;
} /* common_op_match_null_string_p */
@


1.1.1.2.2.21
log
@regex.c
@
text
@d900 2
a945 2
	case start_nowidth:
	case stop_nowidth:
d1625 1
a1625 1
	  GET_BUFFER_SPACE(3);
d1648 2
a1649 3
	  /* Mark and leave space for a jump after this alternative,
	     to be filled in later either by next alternative or
	     when know we're at the end of a series of alternatives.  */
a1650 1
	  GET_BUFFER_SPACE(3);
d2633 2
a2634 7
      if (anchor && startpos < size && string[startpos-1] != '\n') {
	while (range > 0 && string[startpos] != '\n') {
	  range--;
	  startpos++;
	}
	goto advance;
      }
d2728 1
a2730 3
/* Individual items aside from the registers.  */
#define NUM_NONREG_ITEMS 3

d2734 3
a2736 1
#define MAX_NUM_FAILURE_ITEMS   (num_regs * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
d2739 2
a2740 1
#define NUM_FAILURE_ITEMS  (last_used_reg * NUM_REG_ITEMS + NUM_REG_ITEMS)
d2747 1
a2747 1
  do {									\
d2784 1
a2784 1
  } while(0)
d2790 1
a2790 1
  do {									\
d2792 1
a2792 1
    stackp -= NUM_NONREG_ITEMS;	/* Remove failure points (and flag). */	\
d2796 1
a2796 1
  } while(0)
d2808 1
a2808 1
  do { unsigned this_reg;						\
d2818 1
a2818 1
  } while(0)
d2894 1
d3001 1
d3117 1
a3117 2
	      int is_a_jump_n = 0;
	      register unsigned char *p2 = p + 2;
d3139 2
a3140 2
	      if (mcnt < 0 && (enum regexpcode) *p2 == on_failure_jump
                  && (enum regexpcode) p2[3] == start_memory && p2[4] == *p)
d3657 2
a3658 2
              regend[this_reg] = REG_UNSET_VALUE;
              regstart[this_reg] = REG_UNSET_VALUE;
d3670 1
d3687 1
a3687 1
                  p1++;
d3802 1
a3802 1
#if 0
d3805 1
a3805 1
#endif
@


1.1.1.2.2.22
log
@1.1b9_25
@
text
@d1673 1
d1682 1
a1682 1
	  if (lower_bound >= RE_DUP_MAX || upper_bound >= RE_DUP_MAX)
a1683 1
	  if (upper_bound < 0) upper_bound = RE_DUP_MAX;
@


1.1.1.2.2.23
log
@1.1b9_26
@
text
@a2973 3
#ifdef __CHECKER__
    reg_info[mcnt].word = 0;
#endif
@


1.1.1.2.2.24
log
@*** empty log message ***
@
text
@d2827 1
a2827 1
#define AT_STRINGS_END(d)  (d == dend)
d3303 1
a3303 1
	      || AT_STRINGS_BEG(d)
d3310 1
a3310 1
	  if (AT_STRINGS_END(d) || *d == '\n')
d3607 1
a3607 1
			|| AT_STRINGS_END(d)
d3616 1
a3616 1
			|| AT_STRINGS_END(d)
@


1.1.1.2.2.25
log
@regex
@
text
@d723 2
a724 1
	    mcnt = EXTRACT_UNSIGNED_AND_INCR(p);
d726 2
a727 3
		int beg, end;
		beg = EXTRACT_MBC_AND_INCR(p);
		end = EXTRACT_MBC_AND_INCR(p);
d918 2
a919 2
	  p += mcnt+1;
	  mcnt = EXTRACT_UNSIGNED_AND_INCR(p);
d921 2
a922 2
	    EXTRACT_MBC_AND_INCR(p);
	    EXTRACT_MBC_AND_INCR(p);
a2001 24
  /* set optimize flags */
  laststart = bufp->buffer;
  if (*laststart == start_memory) laststart += 3;
  if (*laststart == dummy_failure_jump) laststart += 3;
  else if (*laststart == try_next) laststart += 3;
  if (*laststart == on_failure_jump) {
    int mcnt;

    laststart++;
    EXTRACT_NUMBER_AND_INCR(mcnt, laststart);
    if (mcnt == 4 && *laststart == anychar) {
      bufp->options |= RE_OPTIMIZE_ANCHOR;
    }
    else if (*laststart == charset || *laststart == charset_not) {
      mcnt = *++laststart;
      laststart += mcnt+1;
      mcnt = EXTRACT_UNSIGNED_AND_INCR(laststart);
      laststart += 4*mcnt;
      if (*laststart == maybe_finalize_jump) {
	bufp->options |= RE_OPTIMIZE_CCLASS;
      }
    }
  }

a2549 5
  /* Update the fastmap now if not correct already.  */
  if (fastmap && !bufp->fastmap_accurate) {
      re_compile_fastmap(bufp);
  }

d2564 4
d2575 4
a2578 2
  if (bufp->options & RE_OPTIMIZE_ANCHOR) {
    anchor = 1;
d2581 6
a2586 13
  if (bufp->must) {
    if (range > 0) {
      if (!must_instr(bufp->must+1, bufp->must[0],
		      string+startpos, size-startpos,
		      TRY_TRANSLATE()?translate:0))
	return -1;
    }
    else {
      if (!must_instr(bufp->must+1, bufp->must[0],
		      string+startpos+range, size-startpos-range,
		      TRY_TRANSLATE()?translate:0))
	return -1;
    }
d2635 8
a2659 29

      if (range > 0) {
	if (anchor && startpos < size && string[startpos-1] != '\n') {
	  while (range > 0 && string[startpos] != '\n') {
	    range--;
	    startpos++;
	  }
	}
	else if (fastmap && (bufp->options & RE_OPTIMIZE_CCLASS)) {
	  register unsigned char *p, c;
	  int irange = range;

	  p = (unsigned char *)string+startpos;
	  while (range > 0) {
	    c = *p++;
	    if (ismbchar(c)) {
	      if (!fastmap[c]) break;
	      c = *p++;
	      range--;
	      if (fastmap[c] != 2) break;
	    }
	    else 
	      if (!fastmap[TRY_TRANSLATE() ? translate[c] : c])
		break;
	    range--;
	  }
	  startpos += irange - range;
	}
      }
@


1.1.1.2.2.26
log
@*** empty log message ***
@
text
@d46 1
d57 8
a64 5
# ifndef atarist
#  ifndef alloca
#   define alloca __builtin_alloca
#  endif
# endif /* atarist */
a65 3
# if defined(HAVE_ALLOCA_H)
#  include <alloca.h>
# else
d67 1
a67 1
# endif
d4123 8
d4133 2
@


1.1.1.2.2.27
log
@1.1b9_30
@
text
@d155 1
a155 1
static unsigned char *translate = 0;
@


1.1.1.2.2.28
log
@1.1c1
@
text
@d196 1
a196 1
  translate = (unsigned char*)table;
d708 1
a708 1
            mcnt = *p++;
d713 1
a713 1
                unsigned char map_byte = p[c];
d721 1
a721 1
	    p += mcnt;
d851 1
a851 1
  unsigned char *buffer = (unsigned char*)bufp->buffer;
d917 1
a917 1
	  p += mcnt;
@


1.1.1.2.2.29
log
@sync ev
@
text
@d4084 1
a4084 1
static const unsigned char mbctab_euc[] = { /* 0xA1-0xFE */
a4092 2
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
d4097 4
a4100 1
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0
d4103 1
a4103 1
static const unsigned char mbctab_sjis[] = { /* 0x80-0x9f,0xE0-0xFF */
@


1.1.1.2.2.30
log
@1.1c3
@
text
@a3690 2
      while (stackp != stackb && (int)stackp[-1] == 1)
	POP_FAILURE_POINT();
@


1.1.1.2.2.31
log
@bm_search
@
text
@d1891 1
a1891 1
	      if (c > 0x7f)
d1900 1
a1900 1
	      if (c > 0x7f)
d1921 1
a1921 1
		      c = scan_oct(p_save, 3, &numlen) & 0xff;
d1924 1
a1924 1
		      if (c > 0x7f)
a2002 1
  if (*laststart == exactn) bufp->options |= RE_OPTIMIZE_EXACTN;
a2027 13
  if (current_mbctype) bufp->options |= RE_OPTIMIZE_NO_BM;
  else if (bufp->must) {
      int i;
      int len = ((unsigned char)bufp->must[0]);

      for (i=1; i<len; i++) {
	  if ((unsigned char)bufp->must[i] == 0xff) {
	      bufp->options |= RE_OPTIMIZE_NO_BM;
	      break;
	  }
      }
  }

a2197 1
  unsigned char *bsave = big;
d2202 3
a2207 1
    llen--;
d2238 1
a2238 1
      return big - bsave;
d2243 1
a2243 42
  return -1;
}

static void
bm_init_skip(skip, pat, m)
    int *skip;
    unsigned char *pat;
    int m;
{
    int j, c;

    for (c=0; c<256; c++) {
	skip[c] = m;
    }
    for (j=0; j<m-1; j++) {
	skip[pat[j]] = m-1-j;
    }
}

static void
bm_init_next(next, pat, m)
    int *next;
    unsigned char *pat;
    int m;
{
    int s, j;

    for (s=m-1; s>=0; s--) {
	j = m;
	while (j >= 0 && pat[j-s] == pat[j]) {
	    j--;
	}
	if (j > s) {
	    next[j] = m-j+s;
	}
	else {
	    while (j > 0) {
		next[j] = m-j+s;
		j--;
	    }
	}
    }
a2245 39
static int
bm_search(little, llen, big, blen, translate)
     unsigned char *little;
     int llen;
     unsigned char *big;
     int blen;
     char *translate;
{
    int skip[256], next[256];
    int i, j;

    bm_init_skip(skip, little, llen);
    bm_init_next(next, little, llen);
    i = llen-1;
    if (translate) {
	while (i < blen) {
	    j = llen-1;
	    while (j >= 0 && translate[big[i]] == translate[little[j]]) {
		i--;
		j--;
	    }
	    if (j < 0) return i+1;
	    
	    i += skip[big[i]] > next[j] ? skip[big[i]] : next[j];
	}
	return -1;
    }
    while (i < blen) {
	j = llen-1;
	while (j >= 0 && big[i] == little[j]) {
	    i--;
	    j--;
	}
	if (j < 0) return i+1;

	i += skip[big[i]] > next[j] ? skip[big[i]] : next[j];
    }
    return -1;
}
d2604 5
a2608 11
    int r = range;
    int len = ((unsigned char*)bufp->must)[0];
    int pos;

    if (range >= 0) {
      r = 0;
    }
    if (bufp->options & RE_OPTIMIZE_NO_BM) {
      pos = must_instr(bufp->must+1, len,
		       string+startpos, size-startpos-r,
		       TRY_TRANSLATE()?translate:0);
d2611 5
a2615 7
      pos = bm_search(bufp->must+1, len,
		      string+startpos, size-startpos-r,
		      TRY_TRANSLATE()?translate:0);
    }
    if (pos == -1) return -1;
    if (bufp->options & RE_OPTIMIZE_EXACTN)
      startpos += pos;
@


1.1.1.2.2.32
log
@bm_search
@
text
@d2003 1
d2028 2
a2029 8
  if (*bufp->buffer == exactn) {
    bufp->options |= RE_OPTIMIZE_EXACTN;
    bufp->must = bufp->buffer+1;
  }
  else {
    bufp->must = calculate_must_string(bufp->buffer, b);
  }
  if (current_mbctype == MBCTYPE_SJIS) bufp->options |= RE_OPTIMIZE_NO_BM;
d2031 2
a2032 2
    int i;
    int len = (unsigned char)bufp->must[0];
d2034 5
a2038 5
    for (i=1; i<len; i++) {
      if ((unsigned char)bufp->must[i] == 0xff ||
	  (current_mbctype == MBCTYPE_EUC && ismbchar(bufp->must[i]))) {
	bufp->options |= RE_OPTIMIZE_NO_BM;
	break;
a2039 1
    }
@


1.1.1.2.2.33
log
@euc-kana
@
text
@a1061 1
    bufp->must = 0;
d2225 2
a2226 1
    c = little[1];
d4202 1
a4202 1
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
@


1.1.1.2.2.34
log
@1.1c4
@
text
@d146 1
a146 1
   commands in re_match.  */
a155 2
static void init_regs P((struct re_registers*, unsigned int));
static void bm_init_skip P((int *, unsigned char*, int, char *));
a249 1
    endbuf2,  /* End of buffer/string, or newline just before it.  */
d389 1
a389 1
#define MAY_TRANSLATE() ((bufp->options&(RE_OPTION_IGNORECASE|RE_MAY_IGNORECASE)) && translate)
a838 4
	case endbuf2:
	  printf ("/endbuf2");
          break;

a910 1
	case endbuf2:
a1062 1
    bufp->must_skip = 0;
a1451 1
	      int negative = 0;
d1454 2
a1455 1
		case 'x': case 'i': case '-':
a1457 4
		    case '-':
		      negative = 1;
		      break;

a1458 1
		    case ':':
d1462 4
a1465 4
		      if (negative)
			options &= ~RE_OPTION_EXTENDED;
		      else
			options |= RE_OPTION_EXTENDED;
d1468 1
a1468 7
		      if (negative) {
			if (options&RE_OPTION_IGNORECASE) {
			  options &= ~RE_OPTION_IGNORECASE;
			  BUFPUSH(casefold_off);
			}
		      }
		      else if (!(options&RE_OPTION_IGNORECASE)) {
d1473 6
d1483 1
a1483 5
		    if (c == ')') {
		      c = '#';	/* read whole in-line options */
		      break;
		    }
		    if (c == ':') break;
d1486 1
d1580 1
a1580 1
		     `push_dummy_failure' in `re_match'.  */
a1883 4
	      BUFPUSH(endbuf2);
	      break;

	    case 'z':
d2028 1
a2028 3
  laststart = bufp->buffer;
  if (*laststart == start_memory) laststart += 3;
  if (*laststart == exactn) {
d2030 1
a2030 1
    bufp->must = laststart+1;
a2046 6
    if (!(bufp->options & RE_OPTIMIZE_NO_BM)) {
      bufp->must_skip = (int *) xmalloc((1 << BYTEWIDTH)*sizeof(int));
      bm_init_skip(bufp->must_skip, bufp->must+1,
		   (unsigned char)bufp->must[0],
		   MAY_TRANSLATE()?translate:0);
    }
a2066 9
void
re_free_pattern(bufp)
    struct re_pattern_buffer *bufp;
{
    free(bufp->buffer);
    free(bufp->fastmap);
    if (bufp->must_skip) free(bufp->must_skip);
    free(bufp);
}
d2192 1
a2192 1
slow_match(little, lend, big, bend, translate)
d2201 4
a2204 2
    if (c == 0xff)
      c = *little++;
d2212 1
a2212 1
slow_search(little, llen, big, blen, translate)
d2256 1
a2256 1
    if (slow_match(little, little+llen, big, bend, translate))
d2266 1
a2266 1
bm_init_skip(skip, pat, m, translate)
a2269 1
    char *translate;
d2276 2
a2277 4
    if (translate) {
      for (j=0; j<m-1; j++) {
	skip[translate[pat[j]]] = m-1-j;
      }
d2279 24
a2302 4
    else {
      for (j=0; j<m-1; j++) {
	skip[pat[j]] = m-1-j;
      }
d2307 1
a2307 1
bm_search(little, llen, big, blen, skip, translate)
a2311 1
     int *skip;
d2314 2
a2315 3
  int next[256];
  int i, j, k;
  unsigned char c;
d2317 16
a2332 2
  i = llen-1;
  if (translate) {
d2334 6
a2339 7
      k = i;
      j = llen-1;
      while (j >= 0 && translate[big[k]] == translate[little[j]]) {
	k--;
	j--;
      }
      if (j < 0) return k+1;
d2341 1
a2341 1
      i += skip[translate[big[i]]];
a2343 13
  }
  while (i < blen) {
    k = i;
    j = llen-1;
    while (j >= 0 && big[k] == little[j]) {
      k--;
      j--;
    }
    if (j < 0) return k+1;

    i += skip[big[i]];
  }
  return -1;
a2404 1
	case endbuf2:
a2604 1
	    int byte_match = 0;
d2609 3
a2611 3
	      for (j = 0x80; j < (1 << BYTEWIDTH); j++)
		if (ismbchar(j))
		  fastmap[j] = 1;
a2614 1
		byte_match = 1;
d2616 1
a2616 1
		  fastmap[c] = 1;
a2625 12
	    if (byte_match) {
	      for (j = c; j < (1 << BYTEWIDTH); j++)
		fastmap[j] = 1;
	      for (j = 0; j < (1 << BYTEWIDTH); j++)
		if (fastmap[j])
		  fastmap[j] = 2;
	    }
	    else {
	      for (j = c; j < (1 << BYTEWIDTH); j++)
		if (ismbchar(j))
		  fastmap[j] = 1;
	    }
d2711 3
a2713 3
      pos = slow_search(bufp->must+1, len,
			string+startpos, size-startpos-r,
			MAY_TRANSLATE()?translate:0);
d2718 1
a2718 2
		      bufp->must_skip,
		      MAY_TRANSLATE()?translate:0);
d2721 1
a2721 1
    if (bufp->options & RE_OPTIMIZE_EXACTN) {
a2722 1
    }
d2754 1
a2754 1
		  if (fastmap[MAY_TRANSLATE() ? translate[c] : c])
d2766 1
a2766 1
	      if (MAY_TRANSLATE() ? !fastmap[translate[c]] : !fastmap[c])
d2784 1
a2784 1
#ifdef C_ALLOCA
d2786 1
a2786 1
#endif /* C_ALLOCA */
d2810 1
a2810 1
	      if (!fastmap[MAY_TRANSLATE() ? translate[c] : c])
d3000 1
a3000 1
    unsigned int num_regs;
a3480 6
          goto fail;

	/* Match at the very end of the data. */
        case endbuf2:
	  if (AT_STRINGS_END(d))
	    break;
a4049 1
    case endbuf2:
a4202 1
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
d4234 1
a4234 1
re_mbcinit(mbctype)
@


1.1.1.2.2.35
log
@wrong \A
@
text
@d2721 2
a2722 3
	else if (re_match(bufp, string, size, 0, regs) >= 0)
	  return 0;
	return -1;
@


1.1.1.2.2.36
log
@1.1c5
@
text
@d2332 1
a2332 1
     unsigned char *translate;
@


1.1.1.2.2.37
log
@1.1c6
@
text
@d868 1
a868 1
  int mcnt;
d928 2
a929 1
	    p += 4;
a1071 1
    bufp->stclass = 0;
d1588 11
a1598 7
	  pending_exact = 0;
	  if (fixup_alt_jump)
	  { /* Push a dummy failure point at the end of the
	       alternative for a possible future
	       `finalize_jump' to pop.  See comments at
	       `push_dummy_failure' in `re_match'.  */
	      BUFPUSH(push_dummy_failure);
d1600 5
a1604 8
	      /* We allocated space for this jump when we assigned
		 to `fixup_alt_jump', in the `handle_alt' case below.  */
	      store_jump(fixup_alt_jump, jump, b);
	  }
          options = *--stackp;
          switch (c = *--stackp) {
            case '(':
              {
d2037 6
a2042 7
      p0 = laststart;
      mcnt = *++p0 ;
      p0 += mcnt+1;
      mcnt = EXTRACT_UNSIGNED_AND_INCR(p0);
      p0 += 4*mcnt;
      if (*p0 == maybe_finalize_jump) {
	bufp->stclass = laststart;
d2334 1
d2336 1
d2740 1
d2742 1
a2742 1
    int pos, pbeg, pend;
d2744 2
a2745 4
    pbeg = startpos;
    pend = startpos + range;
    if (pbeg > pend) {		/* swap pbeg,pend */
      pos = pend; pend = pbeg; pbeg = pos;
a2746 1
    if (pend > size) pend = size;
d2749 1
a2749 1
			string+pbeg, pend-pbeg,
d2754 1
a2754 1
		      string+pbeg, pend-pbeg,
d2759 1
a2759 1
    if (range > 0 && (bufp->options & RE_OPTIMIZE_EXACTN)) {
a2760 1
      range -= pos;
d2829 1
a2829 1
	if (anchor && startpos < size && startpos > 0 && string[startpos-1] != '\n') {
d2835 2
a2836 3
	else if (fastmap && (bufp->stclass)) {
	  register unsigned char *p;
	  register unsigned short c;
d2842 5
a2846 10
	    if (ismbchar(c) && fastmap[c] != 2) {
	      c = c << 8 | *p++;
	    }
	    else if (MAY_TRANSLATE())
	      c = translate[c];
	    if (*bufp->stclass == charset) {
	      if (!is_in_list(c, bufp->stclass+1)) break;
	    }
	    else {
	      if (is_in_list(c, bufp->stclass+1)) break;
d2848 3
a2851 1
	    if (c > 256) range--;
d3025 3
d3754 1
a3754 9
	  if (AT_STRINGS_BEG(d)) {
	    if (IS_A_LETTER(d)) break;
	    else goto fail;
	  }
	  if (AT_STRINGS_BEG(d)) {
	    if (IS_A_LETTER(d-1)) break;
	    else goto fail;
	  }
	  if (IS_A_LETTER(d - 1) != IS_A_LETTER(d))
d3759 1
a3759 9
	  if (AT_STRINGS_BEG(d)) {
	    if (IS_A_LETTER(d)) goto fail;
	    else break;
	  }
	  if (AT_STRINGS_END(d)) {
	    if (IS_A_LETTER(d-1)) goto fail;
	    else break;
	  }
	  if (IS_A_LETTER(d - 1) != IS_A_LETTER(d))
@


1.1.1.2.2.38
log
@1.1c7
@
text
@d570 2
a571 2
    if (c2 < EXTRACT_MBC(&b[(end - 1)*4+2]))
      c2 = EXTRACT_MBC(&b[(end - 1)*4+2]);
d2024 19
a2042 21
  if (laststart != b) {
    if (*laststart == start_memory) laststart += 3;
    if (*laststart == dummy_failure_jump) laststart += 3;
    else if (*laststart == try_next) laststart += 3;
    if (*laststart == on_failure_jump) {
      int mcnt;

      laststart++;
      EXTRACT_NUMBER_AND_INCR(mcnt, laststart);
      if (mcnt == 4 && *laststart == anychar) {
	bufp->options |= RE_OPTIMIZE_ANCHOR;
      }
      else if (*laststart == charset || *laststart == charset_not) {
	p0 = laststart;
	mcnt = *++p0 ;
	p0 += mcnt+1;
	mcnt = EXTRACT_UNSIGNED_AND_INCR(p0);
	p0 += 4*mcnt;
	if (*p0 == maybe_finalize_jump) {
	  bufp->stclass = laststart;
	}
d2050 4
a2053 6
  if (laststart != b) {
    if (*laststart == start_memory) laststart += 3;
    if (*laststart == exactn) {
      bufp->options |= RE_OPTIMIZE_EXACTN;
      bufp->must = laststart+1;
    }
a3919 1
		  if (p1 >= pend) break;
@


1.1.1.2.2.39
log
@1.2 stable
@
text
@d89 1
a89 1
        (stackx = (type*)alloca(2 * len * sizeof(type)),		\
d91 1
a91 1
        (type*)memcpy(stackx, stackb, len * sizeof (type)))
d132 7
a138 7
static void store_jump P((char*, int, char*));
static void insert_jump P((int, char*, char*, char*));
static void store_jump_n P((char*, int, char*, unsigned));
static void insert_jump_n P((int, char*, char*, char*, unsigned));
static void insert_op P((int, char*, char*));
static void insert_op_2 P((int, char*, char*, int, int));
static int memcmp_translate P((unsigned char*, unsigned char*, int));
d157 1
a157 1
static void bm_init_skip P((int *, unsigned char*, int, char*));
a306 1
    stop_paren,    /* Place holder at the end of (?:..). */
d357 1
a357 1
    (destination) += SIGN_EXTEND_CHAR (*(char*)((source) + 1)) << 8; }
d407 1
a407 1
    c = (unsigned char)*p++; 						\
d440 1
a440 1
    bufp->buffer = (char*)xrealloc (bufp->buffer, bufp->allocated);	\
d646 1
a646 1
      switch ((enum regexpcode)*p++)
a672 4
	case stop_paren:
	  printf ("/stop_paren");
	  break;

d709 1
a709 1
	            (enum regexpcode)*(p - 1) == charset_not ? "_not" : "");
d879 1
a879 1
      switch ((enum regexpcode)*p++)
a919 1
	case stop_paren:
d1030 1
a1030 1
    /* Address of beginning of regexp, or inside of last (.  */
d1044 2
a1045 2
    /* Stack of information saved by ( and restored by ).
       Five stack elements are pushed by each (:
d1057 1
a1057 1
    /* Counts ('s as they are encountered.  Remembered for the matching ),
d1080 1
a1080 1
	bufp->buffer = (char*)xrealloc (bufp->buffer, INIT_BUF_SIZE);
d1083 1
a1083 1
	bufp->buffer = (char*)xmalloc(INIT_BUF_SIZE);
d1450 1
a1450 1
          while ((int)b[-1] > 0 && b[b[-1] - 1] == 0) 
d1471 1
a1472 1
		    case ')':
a1627 4
	    case ':':
	      BUFPUSH(stop_paren);
	      break;

d1861 1
a1861 1
	      while ((int)b[-1] > 0 && b[b[-1] - 1] == 0) 
d2381 1
a2381 1
  unsigned char *pattern = (unsigned char*)bufp->buffer;
d2407 1
a2407 1
      switch ((int)((enum regexpcode)*p++))
a2434 1
	case stop_paren:
d2470 5
a2474 5
          if ((enum regexpcode)*p != on_failure_jump
	      && (enum regexpcode)*p != try_next
	      && (enum regexpcode)*p != succeed_n
	      && (enum regexpcode)*p != finalize_push
	      && (enum regexpcode)*p != finalize_push_n)
d2785 1
a2785 1
	      p = (unsigned char*)string+startpos;
a2814 2
      if (startpos > size) return -1;
      if (anchor && size > 0 && startpos == size) return -1;
d2845 1
a2845 1
	  p = (unsigned char*)string+startpos;
d2990 1
a2990 1
    *stackp++ = (unsigned char*)last_used_reg;				\
d2994 1
a2994 1
    *stackp++ = (unsigned char*)0; /* non-greedy flag */		\
d3004 1
a3004 1
    temp = (int)*--stackp;	/* How many regs pushed.  */	        \
d3010 1
a3010 1
#define REG_UNSET_VALUE ((unsigned char*)-1)
d3089 1
a3089 1
  register unsigned char *p = (unsigned char*)bufp->buffer;
d3097 1
a3097 1
  unsigned char *string = (unsigned char*)string_arg;
d3169 1
a3169 1
     ( or ( and ) or ) has been seen for. Also set all registers to
d3208 1
a3208 1
	      p - (unsigned char*)bufp->buffer,
d3282 2
a3283 2
	/* ( [or `(', as appropriate] is represented by start_memory,
           ) by stop_memory.  Both of those commands are followed by
d3285 1
a3285 1
           within the ( and ) is recorded under that number.  */
d3322 3
a3324 3
          if ((p + 1) != pend &&
	      (! MATCHED_SOMETHING(reg_info[*p])
	       || (enum regexpcode)p[-3] == start_memory))
d3326 2
a3327 1
	      p1 = p + 2;
d3329 1
a3329 1
              switch (*p1++)
d3333 1
d3338 3
a3340 1
                    EXTRACT_NUMBER_AND_INCR(mcnt, p1);
d3343 1
a3343 1
	      p1 += mcnt;
d3349 2
a3350 2
	      if (mcnt < 0 && (enum regexpcode)*p1 == on_failure_jump
                  && (enum regexpcode)p1[3] == start_memory && p1[4] == *p)
d3374 1
a3374 1
                          if ((int)old_regend[r] >= (int)regstart[r])
d3378 3
a3380 3
		  p1++;
                  EXTRACT_NUMBER_AND_INCR(mcnt, p1);
                  PUSH_FAILURE_POINT(p1 + mcnt, d);
a3386 3
	case stop_paren:
	  break;

d3427 1
a3427 1
                    : memcmp((char*)d, (char*)d2, mcnt))
d3580 4
a3583 9
	    while (p2 + 2 < pend) {
	      if ((enum regexpcode)*p2 == stop_memory ||
		  (enum regexpcode)*p2 == start_memory)
		p2 += 3;	/* Skip over args, too.  */
	      else if ((enum regexpcode)*p2 == stop_paren)
		p2 += 1;
	      else
		break;
	    }
d3698 9
a3706 5
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
	  p1 = p + mcnt;
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
	  STORE_NUMBER(p1, mcnt);
	  continue;
d3886 1
a3886 1
          last_used_reg = (long)*--stackp;
d3907 2
a3908 3
	      int failed_paren = 0;

	      p1 = p;
d3911 20
a3930 30
	    pop_loop:
              switch ((enum regexpcode)*p1) {
	      case stop_paren:
		failed_paren = 1;
		p1++;
		goto pop_loop;

	      case jump_n:
	      case finalize_push_n:
		is_a_jump_n = 1;
	      case maybe_finalize_jump:
	      case finalize_jump:
	      case finalize_push:
	      case jump:
		p1++;
		EXTRACT_NUMBER_AND_INCR (mcnt, p1);
		p1 += mcnt;

		if (p1 >= pend) break;
		if (( is_a_jump_n && (enum regexpcode)*p1 == succeed_n) ||
		    (!is_a_jump_n && (enum regexpcode)*p1 == on_failure_jump)) {
		  if (failed_paren) {
		    p1++;
		    EXTRACT_NUMBER_AND_INCR(mcnt, p1);
		    PUSH_FAILURE_POINT(p1 + mcnt, d);
		  }
		  goto fail;
		}
		break;
	      default:
d3932 1
a3932 1
	      }
d3971 1
a3971 1
      switch ((enum regexpcode)*p1)
d4001 1
a4001 1
              while ((enum regexpcode)p1[mcnt-3] == jump_past_alt)
d4017 1
a4017 1
                  if ((enum regexpcode)*p1 != on_failure_jump)
d4024 1
a4024 1
                  if ((enum regexpcode)p1[mcnt-3] != jump_past_alt)
d4077 1
a4077 1
      switch ((enum regexpcode)*p1)
d4111 1
a4111 1
  switch ((enum regexpcode)*p1++)
@


1.1.1.2.2.40
log
@1.2.1 stable
@
text
@d147 3
a149 2
#define Sword  1
#define Sword2 2
d174 9
a182 3
   for (c=0; c<0x7f; c++)
     if (isalnum(c)) 
       re_syntax_table[c] = Sword;
d185 6
a190 3
   for (c=0x80; c<=0xff; c++)
     if (isalnum(c)) 
       re_syntax_table[c] = Sword2;
d1277 3
a1279 5
		      for (c = 0; c < (1 << BYTEWIDTH); c++) {
			if (SYNTAX(c) == Sword ||
			    (!current_mbctype && SYNTAX(c) == Sword2))
			  SET_LIST_BIT(c);
		      }
d1284 3
a1286 5
		      for (c = 0; c < (1 << BYTEWIDTH); c++) {
			if (SYNTAX(c) != Sword &&
			    (current_mbctype || SYNTAX(c) != Sword2))
			  SET_LIST_BIT(c);
		      }
d2562 1
a2562 1
	  for (j = 0; j < 0x80; j++) {
a2564 16
	  }
	  switch (current_mbctype) {
	  case MBCTYPE_ASCII:
	    for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	      if (SYNTAX(j) == Sword2)
		fastmap[j] = 1;
	    }
	    break;
	  case MBCTYPE_EUC:
	  case MBCTYPE_SJIS:
	    for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	      if (mbctab[j])
		fastmap[j] = 1;
	    }
	    break;
	  }
d2571 2
a2572 15
	  switch (current_mbctype) {
	  case MBCTYPE_ASCII:
	    for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	      if (SYNTAX(j) != Sword2)
		fastmap[j] = 1;
	    }
	    break;
	  case MBCTYPE_EUC:
	  case MBCTYPE_SJIS:
	    for (j = 0x80; j < (1 << BYTEWIDTH); j++) {
	      if (!mbctab[j])
		fastmap[j] = 1;
	    }
	    break;
	  }
d3053 1
a3053 4
#define IS_A_LETTER(d) (SYNTAX(*(d)) == Sword ||			\
			(current_mbctype ?				\
			 mbctab[*(d)] == 1 :				\
			 SYNTAX(*(d)) == Sword2))
@


1.1.1.2.2.41
log
@1.2.3
@
text
@d2038 1
a2038 10
	switch ((enum regexpcode)laststart[4]) {
	  case jump_n:
	  case finalize_jump:
	  case maybe_finalize_jump:
	  case jump:
	  case jump_past_alt:
	  case dummy_failure_jump:
	    bufp->options |= RE_OPTIMIZE_ANCHOR;
	    break;
	}
d3670 2
a3671 7
	  if (stackp[-2] == d) {
	    p = stackp[-3];
	    POP_FAILURE_POINT();
	    continue;
	  }
          POP_FAILURE_POINT(); 
	  /* Note fall through.  */
@


1.1.1.2.2.42
log
@1.2.4
@
text
@d1103 11
a1113 2
	    BUFPUSH(endline);
	    break;
d1116 7
d2860 6
d3265 1
a3265 3
	      while (stackp != stackb && (int)stackp[-1] == 1) {
		if (best_regs_set)
		    goto restore_best_regs;
a3266 1
	      }
d3551 6
a3556 5
          if (size == 0 || AT_STRINGS_BEG(d))
	    break;
	  if (d[-1] == '\n' && !AT_STRINGS_END(d))
	    break;
	  goto fail;
d3559 1
a3559 5
	  if (AT_STRINGS_END(d)) {
	    if (size == 0 || d[-1] != '\n')
	      break;
	  }
	  else if (*d == '\n')
@


1.1.1.2.2.43
log
@1.2.5 pre
@
text
@a3901 1
#if 0
a3903 1
#endif
d3915 1
a3915 1
	  if (stackp[-3] == 0 || (best_regs_set && (int)stackp[-1] == 1)) {
@


1.1.1.2.2.44
log
@to open CVS
@
text
@d3065 1
a3065 1
			 (mbctab[*(d)] == 1 && (d)+1<dend):		\
@


1.1.1.2.2.45
log
@moving
@
text
@d2857 1
a2857 2
	if (anchor && startpos < size &&
	    (startpos < 1 || string[startpos-1] != '\n')) {
@


1.1.1.2.2.46
log
@1.2.6
@
text
@d52 1
a52 1
/* #define	NO_ALLOCA */	/* try it out for now */
d1248 1
a1248 1
	          PATFETCH_RAW(c);
@


1.1.1.2.2.35.2.1
log
@1.1d series
@
text
@a2241 1
    little++;
@


1.1.1.2.2.35.2.2
log
@join 1.1c6
@
text
@d868 1
a868 1
  int mcnt;
d928 2
a929 1
	    p += 4;
a1071 1
    bufp->stclass = 0;
d1588 11
a1598 7
	  pending_exact = 0;
	  if (fixup_alt_jump)
	  { /* Push a dummy failure point at the end of the
	       alternative for a possible future
	       `finalize_jump' to pop.  See comments at
	       `push_dummy_failure' in `re_match'.  */
	      BUFPUSH(push_dummy_failure);
d1600 5
a1604 8
	      /* We allocated space for this jump when we assigned
		 to `fixup_alt_jump', in the `handle_alt' case below.  */
	      store_jump(fixup_alt_jump, jump, b);
	  }
          options = *--stackp;
          switch (c = *--stackp) {
            case '(':
              {
d2037 6
a2042 7
      p0 = laststart;
      mcnt = *++p0 ;
      p0 += mcnt+1;
      mcnt = EXTRACT_UNSIGNED_AND_INCR(p0);
      p0 += 4*mcnt;
      if (*p0 == maybe_finalize_jump) {
	bufp->stclass = laststart;
d2242 1
d2333 1
a2333 1
     unsigned char *translate;
d2335 1
d2337 1
d2741 1
d2743 1
a2743 1
    int pos, pbeg, pend;
d2745 2
a2746 4
    pbeg = startpos;
    pend = startpos + range;
    if (pbeg > pend) {		/* swap pbeg,pend */
      pos = pend; pend = pbeg; pbeg = pos;
a2747 1
    if (pend > size) pend = size;
d2750 1
a2750 1
			string+pbeg, pend-pbeg,
d2755 1
a2755 1
		      string+pbeg, pend-pbeg,
d2760 1
a2760 1
    if (range > 0 && (bufp->options & RE_OPTIMIZE_EXACTN)) {
a2761 1
      range -= pos;
d2830 1
a2830 1
	if (anchor && startpos < size && startpos > 0 && string[startpos-1] != '\n') {
d2836 2
a2837 3
	else if (fastmap && (bufp->stclass)) {
	  register unsigned char *p;
	  register unsigned short c;
d2843 5
a2847 10
	    if (ismbchar(c) && fastmap[c] != 2) {
	      c = c << 8 | *p++;
	    }
	    else if (MAY_TRANSLATE())
	      c = translate[c];
	    if (*bufp->stclass == charset) {
	      if (!is_in_list(c, bufp->stclass+1)) break;
	    }
	    else {
	      if (is_in_list(c, bufp->stclass+1)) break;
d2849 3
a2852 1
	    if (c > 256) range--;
d3026 3
d3755 1
a3755 9
	  if (AT_STRINGS_BEG(d)) {
	    if (IS_A_LETTER(d)) break;
	    else goto fail;
	  }
	  if (AT_STRINGS_BEG(d)) {
	    if (IS_A_LETTER(d-1)) break;
	    else goto fail;
	  }
	  if (IS_A_LETTER(d - 1) != IS_A_LETTER(d))
d3760 1
a3760 9
	  if (AT_STRINGS_BEG(d)) {
	    if (IS_A_LETTER(d)) goto fail;
	    else break;
	  }
	  if (AT_STRINGS_END(d)) {
	    if (IS_A_LETTER(d-1)) goto fail;
	    else break;
	  }
	  if (IS_A_LETTER(d - 1) != IS_A_LETTER(d))
@


1.1.1.2.2.35.2.3
log
@*** empty log message ***
@
text
@d570 2
a571 2
    if (c2 < EXTRACT_MBC(&b[(end - 1)*4+2]))
      c2 = EXTRACT_MBC(&b[(end - 1)*4+2]);
d2024 19
a2042 21
  if (laststart != b) {
    if (*laststart == start_memory) laststart += 3;
    if (*laststart == dummy_failure_jump) laststart += 3;
    else if (*laststart == try_next) laststart += 3;
    if (*laststart == on_failure_jump) {
      int mcnt;

      laststart++;
      EXTRACT_NUMBER_AND_INCR(mcnt, laststart);
      if (mcnt == 4 && *laststart == anychar) {
	bufp->options |= RE_OPTIMIZE_ANCHOR;
      }
      else if (*laststart == charset || *laststart == charset_not) {
	p0 = laststart;
	mcnt = *++p0 ;
	p0 += mcnt+1;
	mcnt = EXTRACT_UNSIGNED_AND_INCR(p0);
	p0 += 4*mcnt;
	if (*p0 == maybe_finalize_jump) {
	  bufp->stclass = laststart;
	}
d2050 4
a2053 6
  if (laststart != b) {
    if (*laststart == start_memory) laststart += 3;
    if (*laststart == exactn) {
      bufp->options |= RE_OPTIMIZE_EXACTN;
      bufp->must = laststart+1;
    }
a3919 1
		  if (p1 >= pend) break;
@


1.1.1.2.2.35.2.4
log
@first public release of 1.1d (pre1.2) series
@
text
@a2814 1
      if (startpos > size) return -1;
@


1.1.1.2.2.35.2.5
log
@1.1d1
@
text
@d89 1
a89 1
        (stackx = (type*)alloca(2 * len * sizeof(type)),		\
d91 1
a91 1
        (type*)memcpy(stackx, stackb, len * sizeof (type)))
d132 7
a138 7
static void store_jump P((char*, int, char*));
static void insert_jump P((int, char*, char*, char*));
static void store_jump_n P((char*, int, char*, unsigned));
static void insert_jump_n P((int, char*, char*, char*, unsigned));
static void insert_op P((int, char*, char*));
static void insert_op_2 P((int, char*, char*, int, int));
static int memcmp_translate P((unsigned char*, unsigned char*, int));
d157 1
a157 1
static void bm_init_skip P((int *, unsigned char*, int, char*));
d357 1
a357 1
    (destination) += SIGN_EXTEND_CHAR (*(char*)((source) + 1)) << 8; }
d407 1
a407 1
    c = (unsigned char)*p++; 						\
d440 1
a440 1
    bufp->buffer = (char*)xrealloc (bufp->buffer, bufp->allocated);	\
d646 1
a646 1
      switch ((enum regexpcode)*p++)
d709 1
a709 1
	            (enum regexpcode)*(p - 1) == charset_not ? "_not" : "");
d879 1
a879 1
      switch ((enum regexpcode)*p++)
d1030 1
a1030 1
    /* Address of beginning of regexp, or inside of last (.  */
d1044 2
a1045 2
    /* Stack of information saved by ( and restored by ).
       Five stack elements are pushed by each (:
d1057 1
a1057 1
    /* Counts ('s as they are encountered.  Remembered for the matching ),
d1080 1
a1080 1
	bufp->buffer = (char*)xrealloc (bufp->buffer, INIT_BUF_SIZE);
d1083 1
a1083 1
	bufp->buffer = (char*)xmalloc(INIT_BUF_SIZE);
d1450 1
a1450 1
          while ((int)b[-1] > 0 && b[b[-1] - 1] == 0) 
d1471 1
a1472 1
		    case ')':
a1627 1
	    case ':':
d1861 1
a1861 1
	      while ((int)b[-1] > 0 && b[b[-1] - 1] == 0) 
d2381 1
a2381 1
  unsigned char *pattern = (unsigned char*)bufp->buffer;
d2407 1
a2407 1
      switch ((int)((enum regexpcode)*p++))
d2470 5
a2474 5
          if ((enum regexpcode)*p != on_failure_jump
	      && (enum regexpcode)*p != try_next
	      && (enum regexpcode)*p != succeed_n
	      && (enum regexpcode)*p != finalize_push
	      && (enum regexpcode)*p != finalize_push_n)
d2785 1
a2785 1
	      p = (unsigned char*)string+startpos;
a2815 1
      if (anchor && size > 0 && startpos == size) return -1;
d2846 1
a2846 1
	  p = (unsigned char*)string+startpos;
d2991 1
a2991 1
    *stackp++ = (unsigned char*)last_used_reg;				\
d2995 1
a2995 1
    *stackp++ = (unsigned char*)0; /* non-greedy flag */		\
d3005 1
a3005 1
    temp = (int)*--stackp;	/* How many regs pushed.  */	        \
d3011 1
a3011 1
#define REG_UNSET_VALUE ((unsigned char*)-1)
d3090 1
a3090 1
  register unsigned char *p = (unsigned char*)bufp->buffer;
d3098 1
a3098 1
  unsigned char *string = (unsigned char*)string_arg;
d3170 1
a3170 1
     ( or ( and ) or ) has been seen for. Also set all registers to
d3209 1
a3209 1
	      p - (unsigned char*)bufp->buffer,
d3283 2
a3284 2
	/* ( [or `(', as appropriate] is represented by start_memory,
           ) by stop_memory.  Both of those commands are followed by
d3286 1
a3286 1
           within the ( and ) is recorded under that number.  */
d3323 3
a3325 3
          if ((p + 1) != pend &&
	      (! MATCHED_SOMETHING(reg_info[*p])
	       || (enum regexpcode)p[-3] == start_memory))
d3327 2
a3328 1
	      p1 = p + 2;
d3330 1
a3330 1
              switch (*p1++)
d3334 1
d3339 3
a3341 1
                    EXTRACT_NUMBER_AND_INCR(mcnt, p1);
d3344 1
a3344 1
	      p1 += mcnt;
d3350 2
a3351 2
	      if (mcnt < 0 && (enum regexpcode)*p1 == on_failure_jump
                  && (enum regexpcode)p1[3] == start_memory && p1[4] == *p)
d3375 1
a3375 1
                          if ((int)old_regend[r] >= (int)regstart[r])
d3379 3
a3381 3
		  p1++;
                  EXTRACT_NUMBER_AND_INCR(mcnt, p1);
                  PUSH_FAILURE_POINT(p1 + mcnt, d);
d3428 1
a3428 1
                    : memcmp((char*)d, (char*)d2, mcnt))
d3581 4
a3584 7
	    while (p2 + 2 < pend) {
	      if ((enum regexpcode)*p2 == stop_memory
		  || (enum regexpcode)*p2 == start_memory)
		p2 += 3;	/* Skip over args, too.  */
	      else
		break;
	    }
d3699 9
a3707 5
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
	  p1 = p + mcnt;
	  EXTRACT_NUMBER_AND_INCR(mcnt, p);
	  STORE_NUMBER(p1, mcnt);
	  continue;
d3887 1
a3887 1
          last_used_reg = (long)*--stackp;
d3908 2
a3909 2

	      p1 = p;
d3912 1
a3912 1
              switch ((enum regexpcode)*p1)
d3926 1
a3926 1
                  if ((is_a_jump_n && (enum regexpcode)*p1 == succeed_n)
d3928 1
a3928 1
                          && (enum regexpcode)*p1 == on_failure_jump))
d3972 1
a3972 1
      switch ((enum regexpcode)*p1)
d4002 1
a4002 1
              while ((enum regexpcode)p1[mcnt-3] == jump_past_alt)
d4018 1
a4018 1
                  if ((enum regexpcode)*p1 != on_failure_jump)
d4025 1
a4025 1
                  if ((enum regexpcode)p1[mcnt-3] != jump_past_alt)
d4078 1
a4078 1
      switch ((enum regexpcode)*p1)
d4112 1
a4112 1
  switch ((enum regexpcode)*p1++)
@
