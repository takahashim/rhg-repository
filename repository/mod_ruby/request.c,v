head	1.30;
access;
symbols
	release_1_0_1:1.28.2.2
	version_1_0-branch:1.28.0.2
	root-of-version_1_0:1.28
	release_1_0_0:1.28
	release_0_9_9:1.28
	release_0_9_8:1.25
	release_0_9_7:1.22
	release_0_9_6:1.22
	release_0_9_5:1.21
	autoconfiscation-branch:1.21.0.2
	root-of-autoconfiscation:1.21
	release_0_9_4:1.21
	release_0_9_3:1.16
	release_0_9_2:1.15
	release_0_9_1:1.15
	release_0_9_0:1.13
	release_0_8_6:1.13
	release_0_8_5:1.10
	release_0_8_4:1.6
	release_0_8_3:1.4
	release_0_8_2:1.3
	release_0_8_1:1.1;
locks; strict;
comment	@ * @;


1.30
date	2002.10.25.03.31.58;	author shugo;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.05.04.34.25;	author shugo;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.21.04.38.57;	author shugo;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2002.05.07.04.50.57;	author shugo;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.30.05.51.05;	author shugo;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.27.05.17.20;	author shugo;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.05.05.57.35;	author shugo;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.15.06.06.16;	author shugo;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.30.08.42.34;	author shugo;	state Exp;
branches;
next	1.21;

1.21
date	2001.10.15.03.27.46;	author shugo;	state Exp;
branches;
next	1.20;

1.20
date	2001.10.12.08.53.35;	author shugo;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.10.03.16.20;	author shugo;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.04.09.19.38;	author shugo;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.30.09.29.53;	author shugo;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.24.02.23.39;	author shugo;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.06.05.39.37;	author shugo;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.23.02.18.16;	author shugo;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.02.06.27.04;	author shugo;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.02.03.47.49;	author shugo;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.29.07.09.14;	author shugo;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.28.06.46.50;	author shugo;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.27.03.49.56;	author shugo;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.22.03.18.26;	author shugo;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.21.07.50.33;	author shugo;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.11.02.14.15;	author shugo;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.10.03.11.47;	author shugo;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.06.08.54.33;	author shugo;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.04.03.07.20;	author shugo;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.02.08.45.26;	author shugo;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.27.04.51.59;	author shugo;	state Exp;
branches;
next	;

1.28.2.1
date	2002.09.05.04.30.27;	author shugo;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2002.10.25.03.29.26;	author shugo;	state Exp;
branches;
next	;


desc
@@


1.30
log
@* request.c (request_set_args): new method.
@
text
@/*
 * $Id: request.c,v 1.29 2002/09/05 04:34:25 shugo Exp $
 * Copyright (C) 2000  ZetaBITS, Inc.
 * Copyright (C) 2000  Information-technology Promotion Agency, Japan
 * Copyright (C) 2001  Shugo Maeda <shugo@@modruby.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

/* for core_module */
#define CORE_PRIVATE

#include "mod_ruby.h"
#include "apachelib.h"

static VALUE rb_eApachePrematureChunkEndError;
VALUE rb_cApacheRequest;

typedef struct request_data {
    request_rec *request;
    VALUE outbuf;
    VALUE connection;
    VALUE server;
    VALUE headers_in;
    VALUE headers_out;
    VALUE err_headers_out;
    VALUE subprocess_env;
    VALUE notes;
    VALUE finfo;
    VALUE error_message;
    VALUE exception;
} request_data;

#define REQ_SYNC_HEADER     FL_USER1
#define REQ_SYNC_OUTPUT     FL_USER2
#define REQ_HEADER_PENDING  FL_USER3
#define REQ_SENT_HEADER     FL_USER4

#define REQUEST_STRING_ATTR_READER(fname, member) \
	DEFINE_STRING_ATTR_READER(fname, request_data, request->member)

#define REQUEST_STRING_ATTR_WRITER(fname, member) \
static VALUE fname(VALUE self, VALUE val) \
{ \
    request_data *data; \
    Check_Type(val, T_STRING); \
    data = get_request_data(self); \
    data->request->member = \
	ap_pstrndup(data->request->pool, \
		    RSTRING(val)->ptr, RSTRING(val)->len); \
    return val; \
}

#define REQUEST_INT_ATTR_READER(fname, member) \
	DEFINE_INT_ATTR_READER(fname, request_data, request->member)
#define REQUEST_INT_ATTR_WRITER(fname, member) \
	DEFINE_INT_ATTR_WRITER(fname, request_data, request->member)

static void request_mark(request_data *data)
{
    if (data == NULL) return;
    rb_gc_mark(data->outbuf);
    rb_gc_mark(data->connection);
    rb_gc_mark(data->server);
    rb_gc_mark(data->headers_in);
    rb_gc_mark(data->headers_out);
    rb_gc_mark(data->err_headers_out);
    rb_gc_mark(data->subprocess_env);
    rb_gc_mark(data->notes);
    rb_gc_mark(data->finfo);
    rb_gc_mark(data->error_message);
    rb_gc_mark(data->exception);
}

static APR_CLEANUP_RETURN_TYPE cleanup_request_object(void *data)
{
    request_rec *r = (request_rec *) data;
    VALUE reqobj;

    reqobj = (VALUE) ap_get_module_config(r->request_config, &ruby_module);
    if (reqobj == 0) APR_CLEANUP_RETURN_SUCCESS();
    if (TYPE(reqobj) == T_DATA) {
	free(RDATA(reqobj)->data);
	RDATA(reqobj)->data = NULL;
    }
    ap_set_module_config(r->request_config, &ruby_module, 0);
    rb_apache_unregister_object(reqobj);
    APR_CLEANUP_RETURN_SUCCESS();
}

static VALUE apache_request_new(request_rec *r)
{
    ruby_dir_config *dconf = get_dir_config(r);
    request_data *data;
    VALUE obj;

    obj = Data_Make_Struct(rb_cApacheRequest, request_data,
			   request_mark, free, data);
    data->request = r;
    data->outbuf = rb_tainted_str_new("", 0);
    data->connection = Qnil;
    data->server = Qnil;
    data->headers_in = Qnil;
    data->headers_out = Qnil;
    data->err_headers_out = Qnil;
    data->subprocess_env = Qnil;
    data->notes = Qnil;
    data->finfo = Qnil;
    data->error_message = Qnil;
    data->exception = Qnil;
    rb_apache_register_object(obj);
    ap_set_module_config(r->request_config, &ruby_module, (void *) obj);
    ap_register_cleanup(r->pool, (void *) r,
			cleanup_request_object, ap_null_cleanup);
    switch (dconf->output_mode) {
    case MR_OUTPUT_SYNC_HEADER:
	FL_SET(obj, REQ_SYNC_HEADER);
	break;
    case MR_OUTPUT_SYNC:
	FL_SET(obj, REQ_SYNC_HEADER);
	FL_SET(obj, REQ_SYNC_OUTPUT);
	break;
    case MR_OUTPUT_NOSYNC:
    default:
	break;
    }
    return obj;
}

VALUE rb_get_request_object(request_rec *r)
{
    VALUE reqobj;

    if (r == NULL) return Qnil;
    reqobj = (VALUE) ap_get_module_config(r->request_config, &ruby_module);
    if (reqobj) {
	return reqobj;
    }
    else {
	return apache_request_new(r);
    }
}

static request_data *get_request_data(VALUE obj)
{
    request_data *data;

    Check_Type(obj, T_DATA);
    data = (request_data *) RDATA(obj)->data;
    if (data == NULL)
	rb_raise(rb_eArgError, "destroyed request");
    return data;
}

long rb_apache_request_length(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return RSTRING(data->outbuf)->len;
}

static VALUE request_output_buffer(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return data->outbuf;
}

static VALUE request_replace(int argc, VALUE *argv, VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return rb_funcall2(data->outbuf, rb_intern("replace"), argc, argv);
}

static VALUE request_cancel(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    RSTRING(data->outbuf)->len = 0;
    RSTRING(data->outbuf)->ptr[0] = '\0';
    return Qnil;
}

static VALUE request_get_sync_header(VALUE self)
{
    return FL_TEST(self, REQ_SYNC_HEADER) ? Qtrue : Qfalse;
}

static VALUE request_set_sync_header(VALUE self, VALUE val)
{
    if (RTEST(val)) {
	FL_SET(self, REQ_SYNC_HEADER);
    }
    else {
	FL_UNSET(self, REQ_SYNC_HEADER);
    }
    return val;
}

static VALUE request_get_sync_output(VALUE self)
{
    return FL_TEST(self, REQ_SYNC_OUTPUT) ? Qtrue : Qfalse;
}

static VALUE request_set_sync_output(VALUE self, VALUE val)
{
    if (RTEST(val)) {
	FL_SET(self, REQ_SYNC_OUTPUT);
    }
    else {
	FL_UNSET(self, REQ_SYNC_OUTPUT);
    }
    return val;
}

static VALUE request_set_sync(VALUE self, VALUE val)
{
    if (RTEST(val)) {
	FL_SET(self, REQ_SYNC_HEADER);
	FL_SET(self, REQ_SYNC_OUTPUT);
    }
    else {
	FL_UNSET(self, REQ_SYNC_HEADER);
	FL_UNSET(self, REQ_SYNC_OUTPUT);
    }
    return val;
}

static VALUE request_write(VALUE self, VALUE str)
{
    request_data *data;
    int len;

    data = get_request_data(self);
    str = rb_obj_as_string(str);
    if (FL_TEST(self, REQ_SYNC_OUTPUT)) {
	if (data->request->header_only &&
	    FL_TEST(self, REQ_SENT_HEADER))
	    return INT2NUM(0);
	len = ap_rwrite(RSTRING(str)->ptr, RSTRING(str)->len, data->request);
	ap_rflush(data->request);
    }
    else {
	rb_str_cat(data->outbuf, RSTRING(str)->ptr, RSTRING(str)->len);
	len = RSTRING(str)->len;
    }
    return INT2NUM(len);
}

static VALUE request_putc(VALUE self, VALUE c)
{
    char ch = NUM2CHR(c);
    request_data *data;

    data = get_request_data(self);
    if (FL_TEST(self, REQ_SYNC_OUTPUT)) {
	int ret;

	if (data->request->header_only &&
	    FL_TEST(self, REQ_SENT_HEADER))
	    return INT2NUM(EOF);
	ret = ap_rputc(NUM2INT(c), data->request);
	return INT2NUM(ret);
    }
    else {
	rb_str_cat(data->outbuf, &ch, 1);
	return c;
    }
}

static VALUE request_print(int argc, VALUE *argv, VALUE out)
{
    int i;
    VALUE line;

    /* if no argument given, print `$_' */
    if (argc == 0) {
	argc = 1;
	line = rb_lastline_get();
	argv = &line;
    }
    for (i=0; i<argc; i++) {
	if (!NIL_P(rb_output_fs) && i>0) {
	    request_write(out, rb_output_fs);
	}
	switch (TYPE(argv[i])) {
	  case T_NIL:
	    request_write(out, STRING_LITERAL("nil"));
	    break;
	  default:
	    request_write(out, argv[i]);
	    break;
	}
    }
    if (!NIL_P(rb_output_rs)) {
	request_write(out, rb_output_rs);
    }

    return Qnil;
}

static VALUE request_printf(int argc, VALUE *argv, VALUE out)
{
    request_write(out, rb_f_sprintf(argc, argv));
    return Qnil;
}

static VALUE request_puts _((int, VALUE*, VALUE));

static VALUE request_puts_ary(VALUE ary, VALUE out)
{
    VALUE tmp;
    int i;

    for (i=0; i<RARRAY(ary)->len; i++) {
	tmp = RARRAY(ary)->ptr[i];
	if (rb_inspecting_p(tmp)) {
	    tmp = STRING_LITERAL("[...]");
	}
	request_puts(1, &tmp, out);
    }
    return Qnil;
}

static VALUE request_puts(int argc, VALUE *argv, VALUE out)
{
    int i;
    VALUE line;

    /* if no argument given, print newline. */
    if (argc == 0) {
	request_write(out, rb_default_rs);
	return Qnil;
    }
    for (i=0; i<argc; i++) {
	switch (TYPE(argv[i])) {
	  case T_NIL:
	    line = STRING_LITERAL("nil");
	    break;
	  case T_ARRAY:
	    rb_protect_inspect(request_puts_ary, argv[i], out);
	    continue;
	  default:
	    line = argv[i];
	    break;
	}
	line = rb_obj_as_string(line);
	request_write(out, line);
	if (RSTRING(line)->ptr[RSTRING(line)->len-1] != '\n') {
	    request_write(out, rb_default_rs);
	}
    }

    return Qnil;
}

static VALUE request_addstr(VALUE out, VALUE str)
{
    request_write(out, str);
    return out;
}

VALUE rb_apache_request_send_http_header(VALUE self)
{
    request_data *data;

    if (FL_TEST(self, REQ_SYNC_HEADER)) {
	data = get_request_data(self);
	ap_send_http_header(data->request);
	FL_SET(self, REQ_SENT_HEADER);
	FL_UNSET(self, REQ_HEADER_PENDING);
    }
    else {
	FL_SET(self, REQ_HEADER_PENDING);
    }
    return Qnil;
}

static VALUE request_sent_http_header(VALUE self)
{
    if (FL_TEST(self, REQ_SENT_HEADER) ||
	FL_TEST(self, REQ_HEADER_PENDING)) {
	return Qtrue;
    }
    else {
	return Qfalse;
    }
}

void rb_apache_request_flush(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    if (FL_TEST(self, REQ_HEADER_PENDING)) {
	ap_send_http_header(data->request);
	FL_SET(self, REQ_SENT_HEADER);
	FL_UNSET(self, REQ_HEADER_PENDING);
    }
    if (data->request->header_only &&
	FL_TEST(self, REQ_SENT_HEADER)) {
	RSTRING(data->outbuf)->len = 0;
	return;
    }
    if (RSTRING(data->outbuf)->len > 0) {
	ap_rwrite(RSTRING(data->outbuf)->ptr, RSTRING(data->outbuf)->len,
		  data->request);
	ap_rflush(data->request);
	RSTRING(data->outbuf)->len = 0;
    }
}


static VALUE request_connection(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    if (NIL_P(data->connection)) {
	data->connection = rb_apache_connection_new(data->request->connection);
    }
    return data->connection;
}

static VALUE request_server(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    if (NIL_P(data->server)) {
	data->server = rb_apache_server_new(data->request->server);
    }
    return data->server;
}

static VALUE request_next(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return rb_get_request_object(data->request->next);
}

static VALUE request_prev(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return rb_get_request_object(data->request->prev);
}

static VALUE request_last(VALUE self)
{
    request_data *data;
    request_rec *last;

    data = get_request_data(self);

    for (last = data->request; last->next; last = last->next)
        continue;

    return rb_get_request_object(last);
}

static VALUE request_main(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return rb_get_request_object(data->request->main);
}

REQUEST_STRING_ATTR_READER(request_protocol, protocol);
REQUEST_STRING_ATTR_READER(request_hostname, hostname);
REQUEST_STRING_ATTR_READER(request_unparsed_uri, unparsed_uri);
REQUEST_STRING_ATTR_READER(request_get_uri, uri);
REQUEST_STRING_ATTR_WRITER(request_set_uri, uri);
REQUEST_STRING_ATTR_READER(request_get_filename, filename);
REQUEST_STRING_ATTR_WRITER(request_set_filename, filename);
REQUEST_STRING_ATTR_READER(request_get_path_info, path_info);
REQUEST_STRING_ATTR_WRITER(request_set_path_info, path_info);
REQUEST_INT_ATTR_READER(request_get_status, status);
REQUEST_INT_ATTR_WRITER(request_set_status, status);
REQUEST_STRING_ATTR_READER(request_get_status_line, status_line);
REQUEST_STRING_ATTR_WRITER(request_set_status_line, status_line);
REQUEST_STRING_ATTR_READER(request_the_request, the_request);
REQUEST_STRING_ATTR_READER(request_request_method, method);
REQUEST_INT_ATTR_READER(request_method_number, method_number);
REQUEST_INT_ATTR_READER(request_get_allowed, allowed);
REQUEST_INT_ATTR_WRITER(request_set_allowed, allowed);
REQUEST_STRING_ATTR_READER(request_get_args, args);
REQUEST_STRING_ATTR_WRITER(request_set_args, args);
REQUEST_STRING_ATTR_READER(request_get_content_type, content_type);
REQUEST_STRING_ATTR_READER(request_get_content_encoding, content_encoding);
REQUEST_STRING_ATTR_READER(request_get_dispatch_handler, handler);
REQUEST_STRING_ATTR_WRITER(request_set_dispatch_handler, handler);

static VALUE request_request_time(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
#ifdef APACHE2
    return rb_time_new(apr_time_sec(data->request->request_time), 0);
#else
    return rb_time_new(data->request->request_time, 0);
#endif
}

static VALUE request_header_only(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return data->request->header_only ? Qtrue : Qfalse;
}

static VALUE request_content_length(VALUE self)
{
    request_data *data;
    const char *s;

    rb_warn("content_length is obsolete; use headers_in[\"Content-Length\"] instead");
    data = get_request_data(self);
    s = ap_table_get(data->request->headers_in, "Content-Length");
    return s ? rb_cstr2inum(s, 10) : Qnil;
}

static VALUE request_set_content_type(VALUE self, VALUE str)
{
    request_data *data;

    data = get_request_data(self);
    if (NIL_P(str)) {
	data->request->content_type = NULL;
    }
    else {
	Check_Type(str, T_STRING);
	str = rb_funcall(str, rb_intern("downcase"), 0);
	data->request->content_type =
	    ap_pstrndup(data->request->pool,
			RSTRING(str)->ptr, RSTRING(str)->len);
    }
    return str;
}

static VALUE request_set_content_encoding(VALUE self, VALUE str)
{
    request_data *data;

    data = get_request_data(self);
    if (NIL_P(str)) {
	data->request->content_encoding = NULL;
    }
    else {
	Check_Type(str, T_STRING);
	str = rb_funcall(str, rb_intern("downcase"), 0);
	data->request->content_encoding =
	    ap_pstrndup(data->request->pool,
			RSTRING(str)->ptr,
			RSTRING(str)->len);
    }
    return str;
}
 
static VALUE request_get_content_languages(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    if (data->request->content_languages) {
#if 0
	VALUE ary = rb_ary_new();
	int i, len =  data->request->content_languages->nelts;
	char **langs = (char **) data->request->content_languages->elts;
	for (i = 0; i < len; i++) {
	    rb_ary_push(ary, rb_str_new2(langs[i]));
	}
	rb_ary_freeze(ary);
	return ary;
#else
	return rb_apache_array_new(data->request->content_languages);
#endif	
    }
    else {
	return Qnil;
    }
}

static VALUE request_set_content_languages(VALUE self, VALUE ary)
{
    request_data *data;
    int i;

    data = get_request_data(self);
    if (NIL_P(ary)) {
	data->request->content_languages = NULL;
    }
    else {
	Check_Type(ary, T_ARRAY);
	for (i = 0; i < RARRAY(ary)->len; i++) {
	    Check_Type(RARRAY(ary)->ptr[i], T_STRING);
	}
	data->request->content_languages =
	    ap_make_array(data->request->pool, RARRAY(ary)->len, sizeof(char *));
	for (i = 0; i < RARRAY(ary)->len; i++) {
	    VALUE str = RARRAY(ary)->ptr[i];
	    str = rb_funcall(str, rb_intern("downcase"), 0);
	    *(char **) ap_push_array(data->request->content_languages) =
		ap_pstrndup(data->request->pool,
			    RSTRING(str)->ptr,
			    RSTRING(str)->len);
	}
    }
    return ary;
}

static VALUE request_headers_in(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    if (NIL_P(data->headers_in)) {
#if 0
	if (ap_table_get(data->request->notes, "ruby_in_authen_handler")) {
#endif
	    data->headers_in = rb_apache_table_new(rb_cApacheTable,
						   data->request->headers_in);
#if 0
	}
	else {
	    data->headers_in = rb_apache_table_new(rb_cApacheRestrictedTable,
						   data->request->headers_in);
	}
#endif
    }
    return data->headers_in;
}

static VALUE request_headers_out(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    if (NIL_P(data->headers_out)) {
	data->headers_out = rb_apache_table_new(rb_cApacheTable,
						data->request->headers_out);
    }
    return data->headers_out;
}

static VALUE request_err_headers_out(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    if (NIL_P(data->err_headers_out)) {
	data->err_headers_out =
	    rb_apache_table_new(rb_cApacheTable, data->request->err_headers_out);
    }
    return data->err_headers_out;
}

static VALUE request_subprocess_env(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    if (NIL_P(data->subprocess_env)) {
	data->subprocess_env =
	    rb_apache_table_new(rb_cApacheTable,
				data->request->subprocess_env);
    }
    return data->subprocess_env;
}

static VALUE request_notes(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    if (NIL_P(data->notes)) {
	data->notes =
	    rb_apache_table_new(rb_cApacheTable,
				data->request->notes);
    }
    return data->notes;
}

static VALUE request_finfo(VALUE self)
{
    VALUE cStat;
    request_data *data;
    struct stat *st;

    data = get_request_data(self);
    if (NIL_P(data->finfo)) {
	cStat = rb_const_get(rb_cFile, rb_intern("Stat"));
	data->finfo = Data_Make_Struct(cStat, struct stat, NULL, free, st);
#ifdef APACHE2
	memset(st, 0, sizeof(struct stat));
	if (data->request->finfo.filetype != 0) {
	    st->st_dev = data->request->finfo.device;
	    st->st_ino = data->request->finfo.inode;
	    st->st_nlink = data->request->finfo.nlink;
	    st->st_mode = data->request->finfo.protection;
	    st->st_uid = data->request->finfo.user;
	    st->st_gid = data->request->finfo.group;
	    st->st_size = data->request->finfo.size;
	    st->st_atime = apr_time_sec(data->request->finfo.atime);
	    st->st_mtime = apr_time_sec(data->request->finfo.mtime);
	    st->st_ctime = apr_time_sec(data->request->finfo.ctime);
	}
#else /* Apache 1.x */
	*st = data->request->finfo;
#endif
    }
    return data->finfo;
}

static VALUE request_aref(VALUE self, VALUE vkey)
{
    request_data *data;
    char *key = STR2CSTR(vkey);
    const char *val;

    rb_warn("self[] is obsolete; use headers_in instead");
    if (strcasecmp(key, "authorization") == 0 ||
	strcasecmp(key, "proxy-authorization") == 0)
	return Qnil;
    data = get_request_data(self);
    val = ap_table_get(data->request->headers_in, key);
    return val ? rb_str_new2(val) : Qnil;
}

static VALUE request_aset(VALUE self, VALUE key, VALUE val)
{
    request_data *data;
    char *s;

    rb_warn("self[]= is obsolete; use headers_out instead");
    s = STR2CSTR(key);
    if (strcasecmp(s, "content-type") == 0) {
	return request_set_content_type(self, val);
    }
    else if (strcasecmp(s, "content-encoding") == 0) {
	return request_set_content_encoding(self, val);
    }
    else {
	data = get_request_data(self);
	ap_table_set(data->request->headers_out, s, STR2CSTR(val));
	return val;
    }
}

static VALUE request_each_header(VALUE self)
{
    request_data *data;
    const array_header *hdrs_arr;
    table_entry *hdrs;
    int i;
    VALUE assoc;

    rb_warn("each_header is obsolete; use headers_in instead");
    data = get_request_data(self);
    hdrs_arr = ap_table_elts(data->request->headers_in);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	if (strcasecmp(hdrs[i].key, "authorization") == 0 ||
	    strcasecmp(hdrs[i].key, "proxy-authorization") == 0)
	    continue;
	assoc = rb_assoc_new(rb_str_new2(hdrs[i].key),
			     hdrs[i].val ? rb_str_new2(hdrs[i].val) : Qnil);
	rb_yield(assoc);
    }
    return Qnil;
}

static VALUE request_each_key(VALUE self)
{
    request_data *data;
    const array_header *hdrs_arr;
    table_entry *hdrs;
    int i;

    rb_warn("each_key is obsolete; use headers_in instead");
    data = get_request_data(self);
    hdrs_arr = ap_table_elts(data->request->headers_in);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	if (strcasecmp(hdrs[i].key, "authorization") == 0 ||
	    strcasecmp(hdrs[i].key, "proxy-authorization") == 0)
	    continue;
	rb_yield(rb_str_new2(hdrs[i].key));
    }
    return Qnil;
}

static VALUE request_each_value(VALUE self)
{
    request_data *data;
    const array_header *hdrs_arr;
    table_entry *hdrs;
    int i;

    rb_warn("each_value is obsolete; use headers_in instead");
    data = get_request_data(self);
    hdrs_arr = ap_table_elts(data->request->headers_in);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	if (strcasecmp(hdrs[i].key, "authorization") == 0 ||
	    strcasecmp(hdrs[i].key, "proxy-authorization") == 0)
	    continue;
	rb_yield(hdrs[i].val ? rb_str_new2(hdrs[i].val) : Qnil);
    }
    return Qnil;
}

static VALUE request_setup_client_block(int argc, VALUE *argv, VALUE self)
{
    request_data *data;
    VALUE policy;
    int read_policy = REQUEST_CHUNKED_ERROR;

    data = get_request_data(self);
    if (rb_scan_args(argc, argv, "01", &policy) == 1) {
	read_policy = NUM2INT(policy);
    }
    return INT2NUM(ap_setup_client_block(data->request, read_policy));
}

static VALUE request_should_client_block(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return INT2BOOL(ap_should_client_block(data->request));
}

static VALUE request_get_client_block(VALUE self, VALUE length)
{
    request_data *data;
    char *buf;
    int len;

    data = get_request_data(self);
    len = NUM2INT(length);
    buf = (char *) ap_palloc(data->request->pool, len);
    len = ap_get_client_block(data->request, buf, len);
    return rb_tainted_str_new(buf, len);
}

static VALUE read_client_block(request_rec *r, int len)
{
    char *buf;
    int rc;
    int nrd = 0;
    int old_read_length;
    VALUE result;

    if (r->read_length == 0) {
        if ((rc = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR)) != OK) {
	    rb_apache_exit(rc);
        }
    }
    old_read_length = r->read_length;
    r->read_length = 0;
    if (ap_should_client_block(r)) {
	if (len < 0)
	    len = r->remaining;
	buf = (char *) ap_palloc(r->pool, len);
	result = rb_tainted_str_new("", 0);
	while (len > 0) {
	    nrd = ap_get_client_block(r, buf, len);
	    if (nrd == 0) {
		break;
	    }
	    if (nrd == -1) {
		r->read_length += old_read_length;
		rb_raise(rb_eApachePrematureChunkEndError, "premature chunk end");
	    }
	    rb_str_cat(result, buf, nrd);
	    len -= nrd;
	}
    }
    else {
	result = Qnil;
    }
    r->read_length += old_read_length;
    return result;
}

static VALUE request_read(int argc, VALUE *argv, VALUE self)
{
    request_data *data;
    VALUE length;
    int len;

    data = get_request_data(self);
    rb_scan_args(argc, argv, "01", &length);
    if (NIL_P(length)) {
	return read_client_block(data->request, -1);
    }
    len = NUM2INT(length);
    if (len < 0) {
	rb_raise(rb_eArgError, "negative length %d given", len);
    }
    return read_client_block(data->request, len);
}

static VALUE request_getc(VALUE self)
{
    request_data *data;
    VALUE str;

    data = get_request_data(self);
    str = read_client_block(data->request, 1);
    if (NIL_P(str) || RSTRING(str)->len == 0)
	return Qnil;
    return INT2FIX(RSTRING(str)->ptr[0]);
}

static VALUE request_eof(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return INT2BOOL(data->request->remaining == 0);
}

static VALUE request_binmode(VALUE self)
{
    return Qnil;
}

static VALUE request_allow_options(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return INT2NUM(ap_allow_options(data->request));
}

static VALUE request_allow_overrides(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return INT2NUM(ap_allow_overrides(data->request));
}

static VALUE request_default_type(VALUE self)
{
    request_data *data;
    const char *type;

    data = get_request_data(self);
    type = ap_default_type(data->request);
    return type ? rb_str_new2(type) : Qnil;
}

static VALUE request_remote_host(int argc, VALUE *argv, VALUE self)
{
    request_data *data;
    const char *host;
    VALUE lookup_type;
    int lookup_val = REMOTE_HOST;

    if (argc == 1) {
      rb_scan_args(argc, argv, "01", &lookup_type);
      switch (NUM2INT(lookup_type)) {
      case REMOTE_HOST:
	lookup_val = REMOTE_HOST;
	break;
      case REMOTE_NAME:
	lookup_val = REMOTE_NAME;
	break;
      case REMOTE_NOLOOKUP:
	lookup_val = REMOTE_NOLOOKUP;
	break;
      case REMOTE_DOUBLE_REV:
	lookup_val = REMOTE_DOUBLE_REV;
	break;
      default:
	lookup_val = REMOTE_HOST;
      }
    }

    data = get_request_data(self);
#ifdef APACHE2
    host = ap_get_remote_host(data->request->connection,
			      data->request->per_dir_config,
			      lookup_val, NULL);
#else /* Apache 1.x */
    host = ap_get_remote_host(data->request->connection,
			      data->request->per_dir_config,
			      lookup_val);
#endif
    return host ? rb_str_new2(host) : Qnil;
}

static VALUE request_remote_logname(VALUE self)
{
    request_data *data;
    const char *logname;

    data = get_request_data(self);
    logname = ap_get_remote_logname(data->request);
    return logname ? rb_str_new2(logname) : Qnil;
}

static VALUE request_construct_url(VALUE self, VALUE uri)
{
    request_data *data;
    char *url;

    data = get_request_data(self);
    url = ap_construct_url(data->request->pool, STR2CSTR(uri), data->request);
    return rb_str_new2(url);
}

static VALUE request_server_name(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return rb_str_new2(ap_get_server_name(data->request));
}

static VALUE request_server_port(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return INT2NUM(ap_get_server_port(data->request));
}

#if 0

static VALUE request_auth_type(VALUE self)
{
    request_data *data;
    const char *auth_type;

    data = get_request_data(self);
    auth_type = ap_auth_type(data->request);
    return auth_type ? rb_str_new2(auth_type) : Qnil;
}

static VALUE request_auth_name(VALUE self)
{
    request_data *data;
    const char *auth_name;

    data = get_request_data(self);
    auth_name = ap_auth_name(data->request);
    return auth_name ? rb_str_new2(auth_name) : Qnil;
}

#endif

static VALUE request_satisfies(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return INT2NUM(ap_satisfies(data->request));
}

static VALUE request_requires(VALUE self)
{
    VALUE result, req;
    request_data *data;
    const array_header *reqs_arr;
    require_line *reqs;
    int i;

    data = get_request_data(self);
    reqs_arr = ap_requires(data->request);
    if (reqs_arr == NULL)
	return Qnil;
    reqs = (require_line *) reqs_arr->elts;
    result = rb_ary_new2(reqs_arr->nelts);
    for (i = 0; i < reqs_arr->nelts; i++) {
	req = rb_assoc_new(INT2NUM(reqs[i].method_mask),
			   rb_str_new2(reqs[i].requirement));
	rb_ary_push(result, req);
    }
    return result;
}

static VALUE request_escape_html(VALUE self, VALUE str)
{
    request_data *data;
    char *tmp;
    VALUE result;

    data = get_request_data(self);
    tmp = ap_escape_html(data->request->pool, STR2CSTR(str));
    result = rb_str_new2(tmp);
    OBJ_INFECT(result, str);
    return result;
}

static VALUE request_signature(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return rb_str_new2(ap_psignature("", data->request));
}

static VALUE request_reset_timeout(VALUE self)
{
#ifdef APACHE2
    rb_notimplement();
#else /* Apache 1.x */
    request_data *data;

    data = get_request_data(self);
    ap_reset_timeout(data->request);
#endif
    return Qnil;
}

static VALUE request_hard_timeout(VALUE self, VALUE name)
{
#ifdef APACHE2
    rb_notimplement();
#else /* Apache 1.x */
    request_data *data;
    char *s;

    Check_Type(name, T_STRING);
    data = get_request_data(self);
    s = ap_pstrndup(data->request->pool, RSTRING(name)->ptr, RSTRING(name)->len);
    ap_hard_timeout(s, data->request);
#endif
    return Qnil;
}

static VALUE request_soft_timeout(VALUE self, VALUE name)
{
    request_data *data;
    char *s;

    Check_Type(name, T_STRING);
    data = get_request_data(self);
    s = ap_pstrndup(data->request->pool, RSTRING(name)->ptr, RSTRING(name)->len);
    ap_soft_timeout(s, data->request);
    return Qnil;
}

static VALUE request_kill_timeout(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    ap_kill_timeout(data->request);
    return Qnil;
}

static VALUE request_note_auth_failure(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    ap_note_auth_failure(data->request);
    return Qnil;
}

static VALUE request_note_basic_auth_failure(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    ap_note_basic_auth_failure(data->request);
    return Qnil;
}

static VALUE request_note_digest_auth_failure(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    ap_note_digest_auth_failure(data->request);
    return Qnil;
}

static VALUE request_get_basic_auth_pw(VALUE self)
{
    request_data *data;
    const char *pw;
    int res;

    data = get_request_data(self);
#if 0
    if (ap_table_get(data->request->notes, "ruby_in_authen_handler") == NULL) {
	rb_raise(rb_eSecurityError, "Only RubyAuthenHandler can get password");
    }
#endif
    if ((res = ap_get_basic_auth_pw(data->request, &pw)) != OK) {
	rb_apache_exit(res);
    }
    return rb_str_new2(pw);
}

static VALUE request_add_common_vars(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    ap_add_common_vars(data->request);
    return Qnil;
}

static VALUE request_add_cgi_vars(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    ap_add_cgi_vars(data->request);
    return Qnil;
}

static VALUE request_setup_cgi_env(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    rb_setup_cgi_env(data->request);
    return Qnil;
}

static VALUE request_log_reason(VALUE self, VALUE msg, VALUE file)
{
    request_data *data;
    const char *host;

    Check_Type(msg, T_STRING);
    Check_Type(file, T_STRING);
    data = get_request_data(self);
#ifdef APACHE2
    host = ap_get_remote_host(data->request->connection,
			      data->request->per_dir_config,
			      REMOTE_HOST, NULL);
#else /* Apache 1.x */
    host = ap_get_remote_host(data->request->connection,
			      data->request->per_dir_config,
			      REMOTE_HOST);
#endif
    ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO,
		 APLOG_STATUS(0) data->request->server,
		 "access to %s failed for %s, reason: %s",
		 STR2CSTR(file),
		 host,
		 STR2CSTR(msg));
    return Qnil;
}

void rb_apache_request_set_error(VALUE request, VALUE errmsg, VALUE exception)
{
    request_data *data;

    Data_Get_Struct(request, request_data, data);
    data->error_message = errmsg;
    data->exception = exception;
}

static VALUE request_error_message(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return data->error_message;
}

static VALUE request_exception(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    return data->exception;
}

#ifdef APACHE2
REQUEST_STRING_ATTR_READER(request_user, user);

static VALUE request_set_user(VALUE self, VALUE val)
{
    request_data *data;

    Check_Type(val, T_STRING);
    data = get_request_data(self);
    data->request->user = ap_pstrndup(data->request->pool,
				      RSTRING(val)->ptr,
				      RSTRING(val)->len);
    return val;
}
#else /* Apache 1.x */
static VALUE request_user(VALUE self)
{
    VALUE conn;

    conn = request_connection(self);
    return rb_funcall(conn, rb_intern("user"), 0);
}

static VALUE request_set_user(VALUE self, VALUE val)
{
    VALUE conn;

    conn = request_connection(self);
    return rb_funcall(conn, rb_intern("user="), 1, val);
}
#endif

/* Should only be called from inside of response handlers */
static VALUE request_internal_redirect(VALUE self, VALUE uri)
{
    request_data *data;

    Check_Type(uri, T_STRING);
    data = get_request_data(self);
    ap_internal_redirect(STR2CSTR(uri), data->request);
    return Qnil;
}

static VALUE request_custom_response(VALUE self, VALUE status, VALUE string)
{
    request_data *data;

    Check_Type(status, T_FIXNUM);
    Check_Type(string, T_STRING);
    data = get_request_data(self);
    ap_custom_response(data->request, NUM2INT(status), STR2CSTR(string));
    return Qnil;
}

static VALUE request_is_initial(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    if (ap_is_initial_req(data->request)) {
        return Qtrue;
    } else {
        return Qfalse;
    }
}

static VALUE request_is_main(VALUE self)
{
    request_data *data;

    data = get_request_data(self);
    if (data->request->main) {
        return Qfalse;
    } else {
        return Qtrue;
    }
}

static VALUE request_auth_type(VALUE self)
{
    request_data *data;
    core_dir_config *conf;

    data = get_request_data(self);
    conf = (core_dir_config *)
	ap_get_module_config(data->request->per_dir_config, &core_module);
    if (conf->ap_auth_type) {
	return rb_tainted_str_new2(conf->ap_auth_type);
    }
    else {
	return Qnil;
    }
}

static VALUE request_set_auth_type(VALUE self, VALUE val)
{
    request_data *data;
    core_dir_config *conf;

    Check_Type(val, T_STRING);
    data = get_request_data(self);
    conf = (core_dir_config *)
	ap_get_module_config(data->request->per_dir_config, &core_module);
    conf->ap_auth_type = ap_pstrndup(data->request->pool,
				     RSTRING(val)->ptr,
				     RSTRING(val)->len);
    ap_set_module_config(data->request->per_dir_config, &core_module, conf);
    return val;
}

static VALUE request_auth_name(VALUE self)
{
    request_data *data;
    core_dir_config *conf;

    data = get_request_data(self);
    conf = (core_dir_config *)
	ap_get_module_config(data->request->per_dir_config, &core_module);
    if (conf->ap_auth_name) {
	return rb_tainted_str_new2(conf->ap_auth_name);
    }
    else {
	return Qnil;
    }
}

static VALUE request_set_auth_name(VALUE self, VALUE val)
{
    request_data *data;
    core_dir_config *conf;

    Check_Type(val, T_STRING);
    data = get_request_data(self);
    conf = (core_dir_config *)
	ap_get_module_config(data->request->per_dir_config, &core_module);
    conf->ap_auth_name = ap_pstrndup(data->request->pool,
				     RSTRING(val)->ptr,
				     RSTRING(val)->len);
    ap_set_module_config(data->request->per_dir_config, &core_module, conf);
    return val;
}

static VALUE request_bytes_sent(VALUE self)
{
    request_data *data;
    request_rec *last;

    data = get_request_data(self);

    for (last = data->request; last->next; last = data->request->next)
        continue;

#ifndef APACHE2
    if (last->sent_bodyct && !last->bytes_sent)
        ap_bgetopt(last->connection->client, BO_BYTECT, &last->bytes_sent);
#endif

    return INT2NUM(last->bytes_sent);
}

static VALUE request_send_fd(VALUE self, VALUE io)
{
    OpenFile *fptr;
#ifdef APACHE2
    apr_size_t bytes_sent;
#else
    long bytes_sent;
#endif
    request_data *data;

    request_set_sync(self, Qtrue);
    rb_apache_request_flush(self);    
    data = get_request_data(self);

    GetOpenFile(io, fptr);

#ifdef APACHE2
    ap_send_fd((apr_file_t *)fptr->f, data->request, 0, -1, &bytes_sent);
#else
    bytes_sent = ap_send_fd_length(fptr->f, data->request, -1);
#endif

    return INT2NUM(bytes_sent);
}

static VALUE request_proxy_q(VALUE self)
{
    request_data *data = get_request_data(self);

    switch (data->request->proxyreq) {
#ifdef APACHE2
    case PROXYREQ_NONE:
	return Qfalse;
    case PROXYREQ_PROXY:
    case PROXYREQ_REVERSE:
	return Qtrue;
#else
    case NOT_PROXY:
	return Qfalse;
    case STD_PROXY:
    case PROXY_PASS:
	return Qtrue;
#endif
    default:
      rb_raise(rb_eArgError, "Unknown Proxy Type");
    }
}

static VALUE request_proxy_pass_q(VALUE self)
{
    request_data *data = get_request_data(self);

#ifdef APACHE2
    if (data->request->proxyreq == PROXYREQ_REVERSE)
#else
    if (data->request->proxyreq == PROXY_PASS)
#endif
      return Qtrue;
    else
      return Qfalse;
}

static VALUE request_get_cache_resp(VALUE self)
{
    request_data *data;
    table *tbl;
    table_entry *hdrs;
    const array_header *hdrs_arr;
    int i;

    data = get_request_data(self);

    if (NIL_P(data->headers_out))
        data->headers_out = rb_apache_table_new(rb_cApacheTable,
					       data->request->headers_out);

    Data_Get_Struct(data->headers_out, table, tbl);
    hdrs_arr = ap_table_elts(tbl);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
        if (hdrs[i].key == NULL)
	    continue;
	if (strcasecmp(hdrs[i].key, "Pragma") ||
	    strcasecmp(hdrs[i].key, "Cache-control")) {
	    return Qtrue;
	}
    }
    return Qfalse;
}

static VALUE request_set_cache_resp(VALUE self, VALUE arg)
{
    request_data *data;
    table *tbl;

    data = get_request_data(self);

    if (NIL_P(data->headers_out))
        data->headers_out = rb_apache_table_new(rb_cApacheTable,
					       data->request->headers_out);

    Data_Get_Struct(data->headers_out, table, tbl);
    if (arg == Qtrue) {
        ap_table_setn(tbl, "Pragma", "no-cache");
	ap_table_setn(tbl, "Cache-control", "no-cache");
	return Qtrue;
    } else {
        ap_table_unset(tbl, "Pragma");
	ap_table_unset(tbl, "Cache-control");
	return Qfalse;
    }
}

static VALUE request_lookup_uri(VALUE self, VALUE uri)
{
    request_data *data;
    request_rec *new_rec;

    Check_Type(uri, T_STRING);
    data = get_request_data(self);
#ifdef APACHE2
    new_rec = ap_sub_req_lookup_uri(STR2CSTR(uri), data->request, NULL);
#else
    new_rec = ap_sub_req_lookup_uri(STR2CSTR(uri), data->request);
#endif
    return apache_request_new(new_rec);
}

static VALUE request_lookup_file(VALUE self, VALUE file)
{
    request_data *data;
    request_rec *new_rec;

    Check_Type(file, T_STRING);
    data = get_request_data(self);
#ifdef APACHE2
    new_rec = ap_sub_req_lookup_file(STR2CSTR(file), data->request, NULL);
#else
    new_rec = ap_sub_req_lookup_file(STR2CSTR(file), data->request);
#endif
    return apache_request_new(new_rec);
}

void rb_init_apache_request()
{
    rb_eApachePrematureChunkEndError =
	rb_define_class_under(rb_mApache, "PrematureChunkEndError",
			      rb_eStandardError);

    rb_cApacheRequest = rb_define_class_under(rb_mApache, "Request", rb_cObject);
    rb_include_module(rb_cApacheRequest, rb_mEnumerable);
    rb_undef_method(CLASS_OF(rb_cApacheRequest), "new");
    rb_define_method(rb_cApacheRequest, "inspect", rb_any_to_s, 0);
    rb_define_method(rb_cApacheRequest, "to_s", request_output_buffer, 0);
    rb_define_method(rb_cApacheRequest, "output_buffer",
		     request_output_buffer, 0);
    rb_define_method(rb_cApacheRequest, "replace", request_replace, -1);
    rb_define_method(rb_cApacheRequest, "cancel", request_cancel, 0);
    rb_define_method(rb_cApacheRequest, "sync_header",
		     request_get_sync_header, 0);
    rb_define_method(rb_cApacheRequest, "sync_header=",
		     request_set_sync_header, 1);
    rb_define_method(rb_cApacheRequest, "sync_output",
		     request_get_sync_output, 0);
    rb_define_method(rb_cApacheRequest, "sync_output=",
		     request_set_sync_output, 1);
    rb_define_method(rb_cApacheRequest, "sync=",
		     request_set_sync, 1);
    rb_define_method(rb_cApacheRequest, "write", request_write, 1);
    rb_define_method(rb_cApacheRequest, "putc", request_putc, 1);
    rb_define_method(rb_cApacheRequest, "print", request_print, -1);
    rb_define_method(rb_cApacheRequest, "printf", request_printf, -1);
    rb_define_method(rb_cApacheRequest, "puts", request_puts, -1);
    rb_define_method(rb_cApacheRequest, "<<", request_addstr, 1);
    rb_define_method(rb_cApacheRequest, "send_http_header",
		     rb_apache_request_send_http_header, 0);
    rb_define_method(rb_cApacheRequest, "sent_http_header?",
		     request_sent_http_header, 0);
    rb_define_method(rb_cApacheRequest, "connection", request_connection, 0);
    rb_define_method(rb_cApacheRequest, "server", request_server, 0);
    rb_define_method(rb_cApacheRequest, "next", request_next, 0);
    rb_define_method(rb_cApacheRequest, "prev", request_prev, 0);
    rb_define_method(rb_cApacheRequest, "last", request_last, 0);
    rb_define_method(rb_cApacheRequest, "main", request_main, 0);
    rb_define_method(rb_cApacheRequest, "protocol", request_protocol, 0);
    rb_define_method(rb_cApacheRequest, "hostname", request_hostname, 0);
    rb_define_method(rb_cApacheRequest, "unparsed_uri",
		     request_unparsed_uri, 0);
    rb_define_method(rb_cApacheRequest, "uri", request_get_uri, 0);
    rb_define_method(rb_cApacheRequest, "uri=", request_set_uri, 1);
    rb_define_method(rb_cApacheRequest, "filename", request_get_filename, 0);
    rb_define_method(rb_cApacheRequest, "filename=", request_set_filename, 1);
    rb_define_method(rb_cApacheRequest, "path_info", request_get_path_info, 0);
    rb_define_method(rb_cApacheRequest, "path_info=", request_set_path_info, 1);
    rb_define_method(rb_cApacheRequest, "request_time",
		     request_request_time, 0);
    rb_define_method(rb_cApacheRequest, "status", request_get_status, 0);
    rb_define_method(rb_cApacheRequest, "status=", request_set_status, 1);
    rb_define_method(rb_cApacheRequest, "status_line", request_get_status_line, 0);
    rb_define_method(rb_cApacheRequest, "status_line=",
		     request_set_status_line, 1);
    rb_define_method(rb_cApacheRequest, "request_method",
		     request_request_method, 0);
    rb_define_method(rb_cApacheRequest, "method_number",
		     request_method_number, 0);
    rb_define_method(rb_cApacheRequest, "allowed", request_get_allowed, 0);
    rb_define_method(rb_cApacheRequest, "allowed=", request_set_allowed, 1);
    rb_define_method(rb_cApacheRequest, "the_request",
		     request_the_request, 0);
    rb_define_method(rb_cApacheRequest, "header_only?", request_header_only, 0);
    rb_define_method(rb_cApacheRequest, "args", request_get_args, 0);
    rb_define_method(rb_cApacheRequest, "args=", request_set_args, 1);
    rb_define_method(rb_cApacheRequest, "content_length",
		     request_content_length, 0);
    rb_define_method(rb_cApacheRequest, "content_type",
		     request_get_content_type, 0);
    rb_define_method(rb_cApacheRequest, "content_type=",
		     request_set_content_type, 1);
    rb_define_method(rb_cApacheRequest, "content_encoding",
		     request_get_content_encoding, 0);
    rb_define_method(rb_cApacheRequest, "content_encoding=",
		     request_set_content_encoding, 1);
    rb_define_method(rb_cApacheRequest, "content_languages",
		     request_get_content_languages, 0);
    rb_define_method(rb_cApacheRequest, "content_languages=",
		     request_set_content_languages, 1);
    rb_define_method(rb_cApacheRequest, "headers_in", request_headers_in, 0);
    rb_define_method(rb_cApacheRequest, "headers_out", request_headers_out, 0);
    rb_define_method(rb_cApacheRequest, "err_headers_out",
		     request_err_headers_out, 0);
    rb_define_method(rb_cApacheRequest, "subprocess_env",
		     request_subprocess_env, 0);
    rb_define_method(rb_cApacheRequest, "notes", request_notes, 0);
    rb_define_method(rb_cApacheRequest, "finfo", request_finfo, 0);
    rb_define_method(rb_cApacheRequest, "[]", request_aref, 1);
    rb_define_method(rb_cApacheRequest, "[]=", request_aset, 2);
    rb_define_method(rb_cApacheRequest, "each_header", request_each_header, 0);
    rb_define_method(rb_cApacheRequest, "each_key", request_each_key, 0);
    rb_define_method(rb_cApacheRequest, "each_value", request_each_value, 0);
    rb_define_method(rb_cApacheRequest, "setup_client_block",
		     request_setup_client_block, -1);
    rb_define_method(rb_cApacheRequest, "should_client_block",
		     request_should_client_block, 0);
    rb_define_method(rb_cApacheRequest, "should_client_block?",
		     request_should_client_block, 0);
    rb_define_method(rb_cApacheRequest, "get_client_block",
		     request_get_client_block, 1);
    rb_define_method(rb_cApacheRequest, "read", request_read, -1);
    rb_define_method(rb_cApacheRequest, "getc", request_getc, 0);
    rb_define_method(rb_cApacheRequest, "eof", request_eof, 0);
    rb_define_method(rb_cApacheRequest, "eof?", request_eof, 0);
    rb_define_method(rb_cApacheRequest, "binmode", request_binmode, 0);
    rb_define_method(rb_cApacheRequest, "allow_options",
		     request_allow_options, 0);
    rb_define_method(rb_cApacheRequest, "allow_overrides",
		     request_allow_overrides, 0);
    rb_define_method(rb_cApacheRequest, "default_type",
		     request_default_type, 0);
    rb_define_method(rb_cApacheRequest, "remote_host",
		     request_remote_host, -1);
    rb_define_method(rb_cApacheRequest, "remote_logname",
		     request_remote_logname, 0);
    rb_define_method(rb_cApacheRequest, "construct_url",
		     request_construct_url, 1);
    rb_define_method(rb_cApacheRequest, "server_name", request_server_name, 0);
    rb_define_method(rb_cApacheRequest, "server_port", request_server_port, 0);
    rb_define_method(rb_cApacheRequest, "satisfies", request_satisfies, 0);
    rb_define_method(rb_cApacheRequest, "requires", request_requires, 0);
    rb_define_method(rb_cApacheRequest, "escape_html", request_escape_html, 1);
    rb_define_method(rb_cApacheRequest, "signature", request_signature, 0);
    rb_define_method(rb_cApacheRequest, "reset_timeout",
		     request_reset_timeout, 0);
    rb_define_method(rb_cApacheRequest, "hard_timeout",
		     request_hard_timeout, 1);
    rb_define_method(rb_cApacheRequest, "soft_timeout",
		     request_soft_timeout, 1);
    rb_define_method(rb_cApacheRequest, "kill_timeout",
		     request_kill_timeout, 0);
    rb_define_method(rb_cApacheRequest, "internal_redirect",
		     request_internal_redirect, 1);
    rb_define_method(rb_cApacheRequest, "custom_response",
		     request_custom_response, 2);
    rb_define_method(rb_cApacheRequest, "main?",
		     request_is_main, 0);
    rb_define_method(rb_cApacheRequest, "initial?",
		     request_is_initial, 0);
    rb_define_method(rb_cApacheRequest, "note_auth_failure",
		     request_note_auth_failure, 0);
    rb_define_method(rb_cApacheRequest, "note_basic_auth_failure",
		     request_note_basic_auth_failure, 0);
    rb_define_method(rb_cApacheRequest, "note_digest_auth_failure",
		     request_note_digest_auth_failure, 0);
    rb_define_method(rb_cApacheRequest, "get_basic_auth_pw",
		     request_get_basic_auth_pw, 0);
    rb_define_method(rb_cApacheRequest, "add_common_vars",
		     request_add_common_vars, 0);
    rb_define_method(rb_cApacheRequest, "add_cgi_vars",
		     request_add_cgi_vars, 0);
    rb_define_method(rb_cApacheRequest, "setup_cgi_env",
		     request_setup_cgi_env, 0);
    rb_define_method(rb_cApacheRequest, "log_reason",
		     request_log_reason, 2);
    rb_define_method(rb_cApacheRequest, "error_message",
		     request_error_message, 0);
    rb_define_method(rb_cApacheRequest, "exception",
		     request_exception, 0);
    rb_define_method(rb_cApacheRequest, "user",
		     request_user, 0);
    rb_define_method(rb_cApacheRequest, "user=",
		     request_set_user, 1);
    rb_define_method(rb_cApacheRequest, "auth_type", request_auth_type, 0);
    rb_define_method(rb_cApacheRequest, "auth_type=", request_set_auth_type, 1);
    rb_define_method(rb_cApacheRequest, "auth_name", request_auth_name, 0);
    rb_define_method(rb_cApacheRequest, "auth_name=", request_set_auth_name, 1);
    rb_define_method(rb_cApacheRequest, "bytes_sent", request_bytes_sent, 0);
    rb_define_method(rb_cApacheRequest, "send_fd", request_send_fd, 1);
    rb_define_method(rb_cApacheRequest, "proxy?",
		     request_proxy_q, 0);
    rb_define_method(rb_cApacheRequest, "proxy_pass?",
		     request_proxy_pass_q, 0);
    rb_define_method(rb_cApacheRequest, "dispatch_handler",
		     request_get_dispatch_handler, 0);
    rb_define_method(rb_cApacheRequest, "dispatch_handler=",
		     request_set_dispatch_handler, 1);
    rb_define_method(rb_cApacheRequest, "cache_resp",
		     request_get_cache_resp, 0);
    rb_define_method(rb_cApacheRequest, "cache_resp=",
		     request_set_cache_resp, 1);
    rb_define_method(rb_cApacheRequest, "lookup_uri", request_lookup_uri, 1);
    rb_define_method(rb_cApacheRequest, "lookup_file", request_lookup_file, 1);
}
@


1.29
log
@* merged from version_1_0-branch.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.28.2.1 2002/09/05 04:30:27 shugo Exp $
d519 2
a520 1
REQUEST_STRING_ATTR_READER(request_args, args);
d1690 2
a1691 1
    rb_define_method(rb_cApacheRequest, "args", request_args, 0);
@


1.28
log
@* apachelib.c (apache_server_root): moved from
request.c:request_server_root().
* request.c (request_proxy_q): fix for Apache2.
* request.c (request_proxy_pass_q): ditto.
* request.c (request_lookup_uri): ditto.
* request.c (request_lookup_file): ditto.
* request.c (request_server_root): new method.
* request.c (request_get_dispatch_handler): ditto.
* request.c (request_set_dispatch_handler): ditto.
* request.c (request_proxy_q): ditto.
* request.c (request_proxy_pass_q): ditto.
* request.c (request_get_cache_resp): ditto.
* request.c (request_set_cache_resp): ditto.
* request.c (request_get_cache_resp): ditto.
* request.c (request_lookup_uri): ditto.
* request.c (request_lookup_file): ditto.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.27 2002/05/07 04:50:57 shugo Exp $
d530 3
d534 1
d737 3
a739 3
	    st->st_atime = data->request->finfo.atime;
	    st->st_mtime = data->request->finfo.mtime;
	    st->st_ctime = data->request->finfo.ctime;
@


1.28.2.1
log
@* request.c: handle apr_time_t correctly.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.28 2002/05/21 04:38:57 shugo Exp $
a529 3
#ifdef APACHE2
    return rb_time_new(apr_time_sec(data->request->request_time), 0);
#else
a530 1
#endif
d733 3
a735 3
	    st->st_atime = apr_time_sec(data->request->finfo.atime);
	    st->st_mtime = apr_time_sec(data->request->finfo.mtime);
	    st->st_ctime = apr_time_sec(data->request->finfo.ctime);
@


1.28.2.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.28.2.1 2002/09/05 04:30:27 shugo Exp $
d519 1
a519 2
REQUEST_STRING_ATTR_READER(request_get_args, args);
REQUEST_STRING_ATTR_WRITER(request_set_args, args);
d1689 1
a1689 2
    rb_define_method(rb_cApacheRequest, "args", request_get_args, 0);
    rb_define_method(rb_cApacheRequest, "args=", request_set_args, 1);
@


1.27
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.26 2002/04/30 05:51:05 shugo Exp $
d522 2
d1478 3
d1482 1
d1497 119
a1615 1
    return INT2NUM((int)bytes_sent);
d1790 14
@


1.26
log
@	* mod_ruby.h: Moved several define's from mod_ruby.c.

	* mod_ruby.c (per_request_cleanup): fixed SEGV for internal
	subrequest clean up.

	* request.c (request_last) new method.

	* request.c (request_internal_redirect) ditto.

	* request.c (request_custom_response) ditto.

	* request.c (request_is_main) ditto.

	* request.c (request_is_initial) ditto.

	* request.c (request_bytes_sent) ditto.

	* request.c (request_send_fd) ditto.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.25 2002/03/27 05:17:20 shugo Exp $
d989 1
a989 1
static VALUE request_remote_host(VALUE self)
d993 22
d1020 1
a1020 1
			      REMOTE_HOST, NULL);
d1024 1
a1024 1
			      REMOTE_HOST);
d1608 2
a1609 1
    rb_define_method(rb_cApacheRequest, "remote_host", request_remote_host, 0);
@


1.25
log
@* request.c (request_set_user): new method.

* request.c (request_set_auth_type): ditto.

* request.c (request_set_auth_name): ditto.

* connection.c (connection_set_user): ditto.

* connection.c (connection_set_auth_type): ditto.

* connection.c (connection_remote_port): fix for Apache2.

* connection.c (connection_local_port): ditto.

* connection.c (connection_remote_port): new method.

* connection.c (connection_local_port): ditto.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.24 2002/03/05 05:57:35 shugo Exp $
d480 13
d1323 46
d1433 39
d1511 1
d1605 8
d1641 2
@


1.24
log
@* supports Apache 2.0.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.23 2002/02/15 06:06:16 shugo Exp $
d33 3
d69 1
d72 2
a73 1
	ap_pstrdup(data->request->pool, STR2CSTR(val)); \
d549 2
a550 1
	    ap_pstrdup(data->request->pool, RSTRING(str)->ptr);
d567 3
a569 1
	    ap_pstrdup(data->request->pool, RSTRING(str)->ptr);
d618 3
a620 1
		ap_pstrdup(data->request->pool, STR2CSTR(str));
d708 1
a708 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
d982 1
a982 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
d1030 2
d1052 2
d1107 1
a1107 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
d1120 1
a1120 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
d1124 1
d1126 1
d1128 2
a1129 2
    ap_hard_timeout(ap_pstrdup(data->request->pool, STR2CSTR(name)),
		    data->request);
d1137 1
d1139 1
d1141 2
a1142 2
    ap_soft_timeout(ap_pstrdup(data->request->pool, STR2CSTR(name)),
		    data->request);
d1235 1
a1235 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
d1278 1
a1278 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
d1280 12
d1300 8
d1310 64
a1493 2
    rb_define_method(rb_cApacheRequest, "auth_type", request_auth_type, 0);
    rb_define_method(rb_cApacheRequest, "auth_name", request_auth_name, 0);
d1528 6
@


1.23
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.22 2002/01/30 08:42:34 shugo Exp $
d30 2
a31 11
#include "httpd.h"
#include "http_config.h"
#include "http_core.h"
#include "http_log.h"
#include "http_main.h"
#include "http_protocol.h"
#include "util_script.h"
#include "multithread.h"

#include "ruby.h"
#include "version.h"
d93 1
a93 1
static void cleanup_request_object(void *data)
d99 1
a99 1
    if (reqobj == 0) return;
d106 1
d698 15
d714 1
d757 1
a757 1
    array_header *hdrs_arr;
d782 1
a782 1
    array_header *hdrs_arr;
d804 1
a804 1
    array_header *hdrs_arr;
d972 5
d980 1
d1093 3
d1100 1
d1106 3
d1114 1
d1212 1
d1217 9
d1227 1
a1227 1
		 data->request->server,
d1230 1
a1230 3
		 ap_get_remote_host(data->request->connection,
				    data->request->per_dir_config,
				    REMOTE_NAME),
d1260 12
d1426 2
@


1.22
log
@* version 0.9.6 released.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.21 2001/10/15 03:27:46 shugo Exp $
d507 2
d1291 2
@


1.21
log
@* mod_ruby.c (ruby_startup): call Init_stack().
* request.c (cleanup_request_object): free RDATA(reqobj)->data.
* request.c (request_headers_in): allow non-auth handlers to
access Authorization header fields.
* request.c (request_get_basic_auth_pw): allow non-auth handlers.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.20 2001/10/12 08:53:35 shugo Exp $
d57 1
d96 1
d133 1
d681 13
d1313 1
@


1.20
log
@* apachelib.h (DEFINE_ATTR_READER): raise exception if data == NULL.
* apachelib.h (DEFINE_ATTR_WRITER): ditto.
* mod_ruby.c (per_request_cleanup): set r->main to rb_request if r
is a sub_request.
* request.c (request_mark): return immediately if data == NULL.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.19 2001/10/10 03:16:20 shugo Exp $
d5 1
a5 1
 * Copyright (C) 2000  Shugo Maeda <shugo@@modruby.net>
d107 2
a108 1
    if (TYPE(reqobj) == T_DATA)
d110 1
d625 1
d627 1
d630 1
d636 1
d1131 1
d1135 1
@


1.19
log
@* ruby_config.c (ruby_cmd_output_mode): new directive RubyOutputMode.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.18 2001/10/04 09:19:38 shugo Exp $
d87 1
@


1.18
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.17 2001/08/30 09:29:53 shugo Exp $
d114 1
d135 12
@


1.17
log
@* request.c(rb_apache_request_flush): call ap_rflush().
* request.c: allow the path_info for the request to be changed.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.16 2001/08/24 02:23:39 shugo Exp $
d58 2
a59 2
    int send_http_header;
    long pos;
d62 5
d74 1
a74 1
    Data_Get_Struct(self, request_data, data); \
d95 15
d112 1
a112 1
VALUE rb_apache_request_new(request_rec *r)
d115 4
a118 4
    VALUE result;
    
    result = Data_Make_Struct(rb_cApacheRequest, request_data,
			      request_mark, free, data);
d128 22
a149 2
    data->send_http_header = 0;
    data->pos = 0;
d151 9
a159 1
    return result;
d166 1
a166 1
    Data_Get_Struct(self, request_data, data);
d174 1
a174 1
    Data_Get_Struct(self, request_data, data);
d182 2
a183 2
    Data_Get_Struct(self, request_data, data);
    return rb_funcall2(data->outbuf, rb_frame_last_func(), argc, argv);
d190 1
a190 1
    Data_Get_Struct(self, request_data, data);
d196 45
d246 1
a246 1
    Data_Get_Struct(self, request_data, data);
d248 11
a258 2
    rb_str_cat(data->outbuf, RSTRING(str)->ptr, RSTRING(str)->len);
    len = RSTRING(str)->len;
d267 14
a280 3
    Data_Get_Struct(self, request_data, data);
    rb_str_cat(data->outbuf, &ch, 1);
    return c;
d379 9
a387 2
    Data_Get_Struct(self, request_data, data);
    data->send_http_header = 1;
d393 7
a399 4
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return data->send_http_header ? Qtrue : Qfalse;
d406 2
a407 2
    Data_Get_Struct(self, request_data, data);
    if (data->send_http_header) {
d409 7
a415 5
	data->send_http_header = 0;
	if (data->request->header_only) {
	    RSTRING(data->outbuf)->len = 0;
	    return;
	}
d418 3
a420 3
	ap_rwrite(RSTRING(data->outbuf)->ptr,
		  RSTRING(data->outbuf)->len, data->request);
       ap_rflush(data->request);
d430 1
a430 1
    Data_Get_Struct(self, request_data, data);
d441 1
a441 1
    Data_Get_Struct(self, request_data, data);
d448 24
d496 1
a496 1
    Data_Get_Struct(self, request_data, data);
d504 1
a504 1
    Data_Get_Struct(self, request_data, data);
d514 1
a514 1
    Data_Get_Struct(self, request_data, data);
d523 1
a523 1
    Data_Get_Struct(self, request_data, data);
d540 1
a540 1
    Data_Get_Struct(self, request_data, data);
d557 1
a557 1
    Data_Get_Struct(self, request_data, data);
d582 1
a582 1
    Data_Get_Struct(self, request_data, data);
d607 1
a607 1
    Data_Get_Struct(self, request_data, data);
d625 1
a625 1
    Data_Get_Struct(self, request_data, data);
d637 1
a637 1
    Data_Get_Struct(self, request_data, data);
d649 1
a649 1
    Data_Get_Struct(self, request_data, data);
d664 1
a664 1
    Data_Get_Struct(self, request_data, data);
d683 1
a683 1
    Data_Get_Struct(self, request_data, data);
d702 1
a702 1
	Data_Get_Struct(self, request_data, data);
d717 1
a717 1
    Data_Get_Struct(self, request_data, data);
d741 1
a741 1
    Data_Get_Struct(self, request_data, data);
d763 1
a763 1
    Data_Get_Struct(self, request_data, data);
d783 1
a783 1
    Data_Get_Struct(self, request_data, data);
d794 1
a794 1
    Data_Get_Struct(self, request_data, data);
d804 1
a804 1
    Data_Get_Struct(self, request_data, data);
d857 1
a857 1
    Data_Get_Struct(self, request_data, data);
d874 1
a874 1
    Data_Get_Struct(self, request_data, data);
d885 1
a885 1
    Data_Get_Struct(self, request_data, data);
d898 1
a898 1
    Data_Get_Struct(self, request_data, data);
d906 1
a906 1
    Data_Get_Struct(self, request_data, data);
d915 1
a915 1
    Data_Get_Struct(self, request_data, data);
d925 1
a925 1
    Data_Get_Struct(self, request_data, data);
d937 1
a937 1
    Data_Get_Struct(self, request_data, data);
d947 1
a947 1
    Data_Get_Struct(self, request_data, data);
d956 1
a956 1
    Data_Get_Struct(self, request_data, data);
d964 1
a964 1
    Data_Get_Struct(self, request_data, data);
d973 1
a973 1
    Data_Get_Struct(self, request_data, data);
d983 1
a983 1
    Data_Get_Struct(self, request_data, data);
d992 1
a992 1
    Data_Get_Struct(self, request_data, data);
d1004 1
a1004 1
    Data_Get_Struct(self, request_data, data);
d1024 1
a1024 1
    Data_Get_Struct(self, request_data, data);
d1035 1
a1035 1
    Data_Get_Struct(self, request_data, data);
d1043 1
a1043 1
    Data_Get_Struct(self, request_data, data);
d1052 1
a1052 1
    Data_Get_Struct(self, request_data, data);
d1062 1
a1062 1
    Data_Get_Struct(self, request_data, data);
d1072 1
a1072 1
    Data_Get_Struct(self, request_data, data);
d1081 1
a1081 1
    Data_Get_Struct(self, request_data, data);
d1090 1
a1090 1
    Data_Get_Struct(self, request_data, data);
d1099 1
a1099 1
    Data_Get_Struct(self, request_data, data);
d1110 1
a1110 1
    Data_Get_Struct(self, request_data, data);
d1124 1
a1124 1
    Data_Get_Struct(self, request_data, data);
d1133 1
a1133 1
    Data_Get_Struct(self, request_data, data);
d1142 1
a1142 1
    Data_Get_Struct(self, request_data, data);
d1153 1
a1153 1
    Data_Get_Struct(self, request_data, data);
d1165 25
d1205 10
d1227 3
d1337 4
@


1.16
log
@* lib/apache/eruby-run.rb (postrun): do not overwrite r.content_type.
* mod_ruby.c (ruby_require): handle SystemExit correctly.
* request.c (request_method_number): new method.
* apachelib.c: new constants M_GET, M_PUT, ....
* configure.rb: rebuild with autoconf.rb 0.2.3 for Solaris.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.15 2001/08/06 05:39:37 shugo Exp $
d295 1
d330 2
a331 1
REQUEST_STRING_ATTR_READER(request_path_info, path_info);
d1051 2
a1052 1
    rb_define_method(rb_cApacheRequest, "path_info", request_path_info, 0);
@


1.15
log
@* version 0.9.1 released.
@
text
@d2 1
a2 1
 * $Id$
d336 1
d1059 2
@


1.14
log
@* request.c (request_the_request): new method.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.13 2001/07/02 06:27:04 shugo Exp $
d6 1
d8 8
a15 1
 * Author: Shugo Maeda <shugo@@modruby.net>
d17 11
a27 16
 * This file is part of mod_ruby.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA.
@


1.13
log
@* request.c (request_sent_http_header): new method.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.12 2001/07/02 03:47:49 shugo Exp $
d331 1
d1055 2
@


1.12
log
@* request.c (request_set_content_type): accept nil.
* request.c (request_set_content_encoding): ditto.
* request.c (request_set_content_languages): ditto.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.11 2001/06/29 07:09:14 shugo Exp $
d268 8
d1032 2
@


1.11
log
@* mod_ruby.c (per_request_init): set rb_stdin, rb_stdout,
rb_defout to rb_request.
* mod_ruby.c (per_request_cleanup): flush rb_request.
* request.c (request_output_buffer): new method.
* lib/apache/cgi-support.rb: removed.
* lib/apache/eruby-run.rb: use tempfile.
* lib/apache/erb-run.rb: ditto.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.10 2001/06/28 06:46:50 shugo Exp $
d360 9
a368 3
    str = rb_funcall(str, rb_intern("downcase"), 0);
    data->request->content_type =
	ap_pstrdup(data->request->pool, STR2CSTR(str));
d377 9
a385 3
    str = rb_funcall(str, rb_intern("downcase"), 0);
    data->request->content_encoding =
	ap_pstrdup(data->request->pool, STR2CSTR(str));
d388 1
a388 1

d418 3
a420 3
    Check_Type(ary, T_ARRAY);
    for (i = 0; i < RARRAY(ary)->len; i++) {
	Check_Type(RARRAY(ary)->ptr[i], T_STRING);
d422 13
a434 8
    Data_Get_Struct(self, request_data, data);
    data->request->content_languages =
	ap_make_array(data->request->pool, RARRAY(ary)->len, sizeof(char *));
    for (i = 0; i < RARRAY(ary)->len; i++) {
	VALUE str = RARRAY(ary)->ptr[i];
	str = rb_funcall(str, rb_intern("downcase"), 0);
        *(char **) ap_push_array(data->request->content_languages) =
	    ap_pstrdup(data->request->pool, STR2CSTR(str));
@


1.10
log
@* request.c (read_client_block): read all data.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.9 2001/06/27 03:49:56 shugo Exp $
d119 8
d993 4
@


1.9
log
@* mod_ruby.c (per_request_init): recycle rb_request.
* request.c: removed notes from struct request_data.
* request.c (rb_apache_request_flush): flush only once.
* request.c (request_to_s): removed.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.8 2001/06/22 03:18:26 shugo Exp $
d42 1
d641 13
a653 2
        nrd = ap_get_client_block(r, buf, len);
	result = rb_tainted_str_new(buf, len);
d978 4
@


1.8
log
@* mod_ruby.c (load_eruby_script): don't use print_error().
* mod_ruby.c (ruby_handler): multi-handler support.
* ruby_config.c (ruby_cmd_post_read_request_handler): new handler.
* ruby_config.c (ruby_cmd_init_handler): ditto.
* ruby_config.c (ruby_cmd_cleanup_handler): ditto.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.7 2001/06/21 07:50:33 shugo Exp $
a52 1
    VALUE notes;
a84 1
    rb_gc_mark(data->notes);
a102 1
    data->notes = Qnil;
a117 8
static VALUE request_to_s(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return data->outbuf;
}

d266 3
a268 1
	if (data->request->header_only)
d270 1
d275 1
a968 1
    rb_define_method(rb_cApacheRequest, "to_s", request_to_s, 0);
@


1.7
log
@* mod_ruby.c (ruby_startup): removed Ruby version from version
	component.
* mod_ruby.c (ruby_startup): log error if ruby_require() fails.
* mod_ruby.c (ruby_handler): don't call rb_apache_request_flush()
on error.
* request.c (rb_apache_request_new): should initialize data->server.
* lib/apache/ruby-run.rb (handler): require ExecCGI and exec
permission.
* lib/apache/eruby-run.rb (handler): require ExecCGI.
* lib/apache/cgi-support.rb: new file.
* lib/apache/erb-run.rb: new file, supports ERb.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.6 2001/06/11 02:14:15 shugo Exp $
d426 1
a426 1
	if (ap_table_get(data->request->notes, "In-RubyAuthenHandler")) {
d917 1
a917 1
    if (ap_table_get(data->request->notes, "In-RubyAuthenHandler") == NULL) {
@


1.6
log
@* mod_ruby.c (ruby_handler_0): handle SystemExit correctly.
* array_header.c (array_length): new method.
* table.c: renamed ApacheInTable to ApacheRestrictedTable.
* request.c (rb_apache_request_new): don't set content_type.
* request.c (request_headers_in): return non-restricted table for
RubyAuthenHandler.
* request.c (request_notes): removed.
* request.c (request_allow_options): new method.
* request.c (request_allow_overrides): ditto.
* request.c (request_default_type): ditto.
* request.c (request_construct_url): ditto.
* request.c (request_auth_type): ditto.
* request.c (request_auth_name): ditto.
* request.c (request_satisfies): ditto.
* request.c (request_requires): ditto.
* request.c (request_note_auth_failure): ditto.
* request.c (request_note_basic_auth_failure): ditto.
* request.c (request_note_digest_auth_failure): ditto.
* request.c (request_basic_auth_pw): ditto.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.5 2001/06/10 03:11:47 shugo Exp $
d100 1
d953 18
d1089 2
@


1.5
log
@* mod_ruby.c (ruby_translate_handler): new handler.
* mod_ruby.c (ruby_authen_handler): ditto.
* mod_ruby.c (ruby_authen_handler): ditto.
* mod_ruby.c (ruby_authz_handler): ditto.
* mod_ruby.c (ruby_access_handler): ditto.
* mod_ruby.c (ruby_type_handler): ditto.
* mod_ruby.c (ruby_fixup_handler): ditto.
* mod_ruby.c (ruby_log_handler): ditto.
* mod_ruby.c (ruby_header_parser_handler): ditto.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.4 2001/06/06 08:54:33 shugo Exp $
a94 1
    r->content_type = "text/html";
d425 8
a432 2
	data->headers_in = rb_apache_table_new(rb_cApacheInTable,
					       data->request->headers_in);
a473 12
static VALUE request_notes(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (NIL_P(data->notes)) {
	data->notes = rb_apache_table_new(rb_cApacheTable,
					  data->request->notes);
    }
    return data->notes;
}

d699 26
d747 10
d773 50
d882 43
a1009 1
    rb_define_method(rb_cApacheRequest, "notes", request_notes, 0);
d1029 6
d1038 2
d1042 4
d1056 8
@


1.4
log
@* request.c (request_escape_html): add taint status infection.
* mod_ruby.c (ruby_object_handler): call rb_exec_end_proc().
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.3 2001/06/04 03:07:20 shugo Exp $
d312 2
a313 1
REQUEST_STRING_ATTR_READER(request_uri, uri);
d852 2
a853 1
    rb_define_method(rb_cApacheRequest, "uri", request_uri, 0);
@


1.3
log
@* lib/auto-reload: new file.
* lib/apache/ruby-run.rb: renamed from ruby/apache/ruby.rb.
* lib/apache/eruby-run.rb: renamed from ruby/apache/eruby.rb.
* lib/apache/rd2html.rb: renamed from ruby/apache/rd2html.rb.
* lib/apache/eruby-run.rb (handler): specify filename for backtrace.
* changed license from GPL to LGPL.
* COPYING: new file.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.2 2001/05/02 08:45:26 shugo Exp $
d747 1
d751 3
a753 1
    return rb_str_new2(tmp);
@


1.2
log
@* fixed copyright notice.
* array_header.c: new file for Apache::ArrayHeader.
* server.c: added some methods.
@
text
@d2 1
a2 1
 * $Id: request.c,v 1.1 2001/04/27 04:51:59 shugo Exp $
d11 4
a14 4
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
d18 2
a19 2
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
d21 4
a24 4
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA
@


1.1
log
@* ruby/apache/ruby.rb (emulate_cgi): new method.
* ruby/apache/eruby.rb: inherit Apache::Ruby.
* table.c: new file for Apache::Table.
* connection.c: new file for Apache::Connection.
* server.c: new file for Apache::Server.
* request.c: new file for Apache::Request.
* request.c (request_setup_cgi_env): new method.
* mod_ruby.c (script_handler): resotre original $stdin, $stdout
and $>.
@
text
@d2 1
a2 1
 * $Id$
d5 1
a26 2
#include <string.h>

d380 1
d389 3
@
