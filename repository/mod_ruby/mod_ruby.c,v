head	1.74;
access;
symbols
	release_1_0_1:1.73.2.1
	version_1_0-branch:1.73.0.2
	root-of-version_1_0:1.73
	release_1_0_0:1.73
	release_0_9_9:1.72
	release_0_9_8:1.66
	release_0_9_7:1.63
	release_0_9_6:1.63
	release_0_9_5:1.62
	autoconfiscation-branch:1.61.0.2
	root-of-autoconfiscation:1.61
	release_0_9_4:1.61
	release_0_9_3:1.57
	release_0_9_2:1.56
	release_0_9_1:1.55
	release_0_9_0:1.52
	release_0_8_6:1.52
	release_0_8_5:1.48
	release_0_8_4:1.44
	release_0_8_3:1.40
	release_0_8_2:1.39
	release_0_8_1:1.34
	release_0_8_0:1.31
	release_0_2_0:1.20;
locks; strict;
comment	@ * @;


1.74
date	2002.08.23.03.07.53;	author shugo;	state Exp;
branches;
next	1.73;

1.73
date	2002.06.28.05.02.09;	author shugo;	state Exp;
branches
	1.73.2.1;
next	1.72;

1.72
date	2002.05.24.06.41.00;	author shugo;	state Exp;
branches;
next	1.71;

1.71
date	2002.05.21.05.58.35;	author shugo;	state Exp;
branches;
next	1.70;

1.70
date	2002.05.21.05.16.35;	author shugo;	state Exp;
branches;
next	1.69;

1.69
date	2002.05.21.04.59.21;	author shugo;	state Exp;
branches;
next	1.68;

1.68
date	2002.05.16.05.16.39;	author shugo;	state Exp;
branches;
next	1.67;

1.67
date	2002.04.30.05.51.05;	author shugo;	state Exp;
branches;
next	1.66;

1.66
date	2002.03.27.05.17.20;	author shugo;	state Exp;
branches;
next	1.65;

1.65
date	2002.03.05.05.57.35;	author shugo;	state Exp;
branches;
next	1.64;

1.64
date	2002.02.28.06.41.17;	author shugo;	state Exp;
branches;
next	1.63;

1.63
date	2002.01.30.08.42.34;	author shugo;	state Exp;
branches;
next	1.62;

1.62
date	2001.12.17.07.31.43;	author shugo;	state Exp;
branches;
next	1.61;

1.61
date	2001.10.15.03.27.46;	author shugo;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2001.10.12.08.53.35;	author shugo;	state Exp;
branches;
next	1.59;

1.59
date	2001.10.10.03.16.20;	author shugo;	state Exp;
branches;
next	1.58;

1.58
date	2001.10.04.09.19.38;	author shugo;	state Exp;
branches;
next	1.57;

1.57
date	2001.08.24.02.23.39;	author shugo;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.13.02.27.17;	author shugo;	state Exp;
branches;
next	1.55;

1.55
date	2001.08.06.05.39.37;	author shugo;	state Exp;
branches;
next	1.54;

1.54
date	2001.08.06.05.14.57;	author shugo;	state Exp;
branches;
next	1.53;

1.53
date	2001.07.27.04.46.40;	author shugo;	state Exp;
branches;
next	1.52;

1.52
date	2001.07.02.03.47.49;	author shugo;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.29.07.09.14;	author shugo;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.29.03.44.40;	author shugo;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.28.08.57.29;	author shugo;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.27.03.49.56;	author shugo;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.22.03.18.26;	author shugo;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.21.09.34.49;	author shugo;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.21.07.50.33;	author shugo;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.11.02.14.15;	author shugo;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.10.03.11.47;	author shugo;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.09.09.50.28;	author shugo;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.08.09.57.00;	author shugo;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.06.08.54.33;	author shugo;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.04.03.07.20;	author shugo;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.29.01.15.20;	author shugo;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.28.08.35.27;	author shugo;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.28.02.36.09;	author shugo;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.02.08.45.26;	author shugo;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.27.04.51.59;	author shugo;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.20.04.08.56;	author shugo;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.19.06.13.25;	author shugo;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.13.04.19.40;	author shugo;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.12.09.08.34;	author shugo;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.10.09.12.22;	author shugo;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.10.08.03.55;	author shugo;	state Exp;
branches;
next	1.27;

1.27
date	2000.12.12.05.41.07;	author shugo;	state Exp;
branches;
next	1.26;

1.26
date	2000.12.06.05.37.08;	author shugo;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.23.09.25.06;	author shugo;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.16.05.41.34;	author shugo;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.14.14.55.41;	author shugo;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.14.04.27.56;	author shugo;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.04.15.38.46;	author shugo;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.11.06.56.34;	author shugo;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.06.10.03.38;	author shugo;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.31.02.50.47;	author shugo;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.03.07.29.41;	author shugo;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.02.07.01.45;	author shugo;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.02.06.12.33;	author shugo;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.02.05.14.55;	author shugo;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.01.00.56.57;	author shugo;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.13.03.31.05;	author shugo;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.11.04.37.37;	author shugo;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.26.01.19.37;	author shugo;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.24.04.59.00;	author shugo;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.18.08.09.42;	author shugo;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.30.07.35.33;	author shugo;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.28.05.41.57;	author shugo;	state Exp;
branches;
next	1.5;

1.5
date	99.07.26.01.31.18;	author shugo;	state Exp;
branches;
next	1.4;

1.4
date	99.07.15.06.06.09;	author shugo;	state Exp;
branches;
next	1.3;

1.3
date	99.07.06.09.36.53;	author shugo;	state Exp;
branches;
next	1.2;

1.2
date	99.06.21.07.19.15;	author shugo;	state Exp;
branches;
next	1.1;

1.1
date	99.06.21.07.14.11;	author shugo;	state Exp;
branches;
next	;

1.61.2.1
date	2001.10.22.05.02.43;	author shugo;	state Exp;
branches;
next	;

1.73.2.1
date	2002.08.23.03.12.57;	author shugo;	state Exp;
branches;
next	;


desc
@@


1.74
log
@* mod_ruby.c: RubyTransHandler and RubyPostReadRequestHandler
are allowed only globally or in <VirtualHost> now.
Thanks, Eugene Scripnik <Eugene.Scripnik@@itgrp.net>.
* lib/auto-reload.rb (require): fix for the behaviour of nil on
ruby-1.7.2.
@
text
@/*
 * $Id: mod_ruby.c,v 1.73 2002/06/28 05:02:09 shugo Exp $
 * Copyright (C) 2000  ZetaBITS, Inc.
 * Copyright (C) 2000  Information-technology Promotion Agency, Japan
 * Copyright (C) 2001  Shugo Maeda <shugo@@modruby.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdarg.h>
#include <signal.h>

#include "mod_ruby.h"
#include "ruby_config.h"
#include "apachelib.h"

#if defined(HAVE_DLOPEN) && !defined(USE_DLN_A_OUT) && !defined(_AIX)
/* dynamic load with dlopen() */
# define USE_DLN_DLOPEN
#endif

#ifdef USE_DLN_DLOPEN
# ifdef __NetBSD__
#  include <nlist.h>
#  include <link.h>
# else
#  include <dlfcn.h>
# endif
#endif

#ifdef __hpux
#include <errno.h>
#include "dl.h"
#endif

#ifdef NeXT
#if NS_TARGET_MAJOR < 4
#include <mach-o/rld.h>
#else
#include <mach-o/dyld.h>
#endif
#endif
#ifdef __APPLE__
#include <mach-o/dyld.h>
#endif

#ifndef WIN32
extern char **environ;
static char **origenviron;
#endif /* WIN32 */

EXTERN VALUE ruby_errinfo;
EXTERN VALUE rb_stdin;
EXTERN VALUE rb_stdout;
EXTERN VALUE rb_defout;

static VALUE orig_stdin;
static VALUE orig_stdout;
static VALUE orig_defout;

EXTERN VALUE rb_load_path;
static VALUE default_load_path;

static const char *default_kcode;

#ifdef MULTITHREAD
#error mod_ruby does not support multi-thread yet.
#endif
static int ruby_is_running = 0;
array_header *ruby_required_libraries = NULL;

static int ruby_object_handler(request_rec *r);
static int ruby_trans_handler(request_rec *r);
static int ruby_authen_handler(request_rec *r);
static int ruby_authz_handler(request_rec *r);
static int ruby_access_handler(request_rec *r);
static int ruby_type_handler(request_rec *r);
static int ruby_fixup_handler(request_rec *r);
static int ruby_log_handler(request_rec *r);
#ifndef APACHE2 /* Apache 1.x */
static int ruby_header_parser_handler(request_rec *r);
#endif
static int ruby_post_read_request_handler(request_rec *r);

static const command_rec ruby_cmds[] =
{
    {"RubyKanjiCode", ruby_cmd_kanji_code, NULL, OR_ALL, TAKE1,
     "set $KCODE"},
    {"RubyAddPath", ruby_cmd_add_path, NULL, OR_ALL, ITERATE,
     "add path to $:"},
    {"RubyRequire", ruby_cmd_require, NULL, OR_ALL, ITERATE,
     "ruby script name, pulled in via require"},
    {"RubyPassEnv", ruby_cmd_pass_env, NULL, RSRC_CONF, ITERATE,
     "pass environment variables to ENV"},
    {"RubySetEnv", ruby_cmd_set_env, NULL, OR_ALL, TAKE2,
     "Ruby ENV key and value" },
    {"RubyTimeOut", ruby_cmd_timeout, NULL, RSRC_CONF, TAKE1,
     "time to wait execution of ruby script"},
    {"RubySafeLevel", ruby_cmd_safe_level, NULL, OR_ALL, TAKE1,
     "set default $SAFE"},
    {"RubyOutputMode", ruby_cmd_output_mode, NULL, OR_ALL, TAKE1,
     "set output mode (nosync|sync|syncheader)"},
    {"RubyHandler", ruby_cmd_handler, NULL, OR_ALL, TAKE1,
     "set ruby handler object"},
    {"RubyTransHandler", ruby_cmd_trans_handler, NULL, RSRC_CONF, TAKE1,
     "set translation handler object"},
    {"RubyAuthenHandler", ruby_cmd_authen_handler, NULL, OR_ALL, TAKE1,
     "set authentication handler object"},
    {"RubyAuthzHandler", ruby_cmd_authz_handler, NULL, OR_ALL, TAKE1,
     "set authorization handler object"},
    {"RubyAccessHandler", ruby_cmd_access_handler, NULL, OR_ALL, TAKE1,
     "set access checker object"},
    {"RubyTypeHandler", ruby_cmd_type_handler, NULL, OR_ALL, TAKE1,
     "set type checker object"},
    {"RubyFixupHandler", ruby_cmd_fixup_handler, NULL, OR_ALL, TAKE1,
     "set fixup handler object"},
    {"RubyLogHandler", ruby_cmd_log_handler, NULL, OR_ALL, TAKE1,
     "set log handler object"},
    {"RubyHeaderParserHandler", ruby_cmd_header_parser_handler,
     NULL, OR_ALL, TAKE1,
     "set header parser object"},
    {"RubyPostReadRequestHandler", ruby_cmd_post_read_request_handler,
     NULL, RSRC_CONF, TAKE1,
     "set post-read-request handler object"},
    {"RubyInitHandler", ruby_cmd_init_handler,
     NULL, OR_ALL, TAKE1,
     "set init handler object"},
    {"RubyCleanupHandler", ruby_cmd_cleanup_handler,
     NULL, OR_ALL, TAKE1,
     "set cleanup handler object"},
    {NULL}
};

#ifdef APACHE2

static int ruby_startup(pool*, pool*, pool*, server_rec*);
static void ruby_child_init(pool*, server_rec*);

static void ruby_register_hooks(pool *p)
{
    ap_hook_post_config(ruby_startup, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_handler(ruby_object_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_translate_name(ruby_trans_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_check_user_id(ruby_authen_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_auth_checker(ruby_authz_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_access_checker(ruby_access_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_type_checker(ruby_type_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_fixups(ruby_fixup_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_log_transaction(ruby_log_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_child_init(ruby_child_init, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_post_read_request(ruby_post_read_request_handler,
			      NULL, NULL, APR_HOOK_MIDDLE);
}

module AP_MODULE_DECLARE_DATA ruby_module =
{
    STANDARD20_MODULE_STUFF,
    ruby_create_dir_config,	/* dir config creater */
    ruby_merge_dir_config,	/* dir merger --- default is to override */
    ruby_create_server_config,	/* create per-server config structure */
    ruby_merge_server_config,	/* merge server config */
    ruby_cmds,			/* command apr_table_t */
    ruby_register_hooks		/* register hooks */
};

#else /* Apache 1.x */

static void ruby_startup(server_rec*, pool*);
static void ruby_child_init(server_rec*, pool*);

static const handler_rec ruby_handlers[] =
{
    {"ruby-object", ruby_object_handler},
    {NULL}
};

MODULE_VAR_EXPORT module ruby_module =
{
    STANDARD_MODULE_STUFF,
    ruby_startup,		/* initializer */
    ruby_create_dir_config,	/* dir config creater */
    ruby_merge_dir_config,	/* dir merger --- default is to override */
    ruby_create_server_config,	/* create per-server config structure */
    ruby_merge_server_config,	/* merge server config */
    ruby_cmds,			/* command table */
    ruby_handlers,		/* handlers */
    ruby_trans_handler,		/* filename translation */
    ruby_authen_handler,	/* check_user_id */
    ruby_authz_handler,		/* check auth */
    ruby_access_handler,	/* check access */
    ruby_type_handler,		/* type_checker */
    ruby_fixup_handler,		/* fixups */
    ruby_log_handler,		/* logger */
    ruby_header_parser_handler,	/* header parser */
    ruby_child_init,		/* child_init */
    NULL,			/* child_exit */
    ruby_post_read_request_handler,	/* post read-request */
#ifdef EAPI
    NULL,			/* add_module */
    NULL,			/* remove_module */
    NULL,			/* rewrite_command */
    NULL,			/* new_connection */
    NULL			/* close_connection */
#endif /* EAPI */
};
#endif

#define STRING_LITERAL(s) rb_str_new(s, sizeof(s) - 1)
#define STR_CAT_LITERAL(str, s) rb_str_cat(str, s, sizeof(s) - 1)

typedef struct protect_call_arg {
    VALUE recv;
    ID mid;
    int argc;
    VALUE *argv;
} protect_call_arg_t;

static VALUE protect_funcall0(VALUE arg)
{
    return rb_funcall2(((protect_call_arg_t *) arg)->recv,
		       ((protect_call_arg_t *) arg)->mid,
		       ((protect_call_arg_t *) arg)->argc,
		       ((protect_call_arg_t *) arg)->argv);
}

VALUE rb_protect_funcall(VALUE recv, ID mid, int *state, int argc, ...)
{
    va_list ap;
    VALUE *argv;
    struct protect_call_arg arg;

    if (argc > 0) {
	int i;

	argv = ALLOCA_N(VALUE, argc);

	va_start(ap, argc);
	for (i = 0; i < argc; i++) {
	    argv[i] = va_arg(ap, VALUE);
	}
	va_end(ap);
    }
    else {
	argv = 0;
    }
    arg.recv = recv;
    arg.mid = mid;
    arg.argc = argc;
    arg.argv = argv;
    return rb_protect(protect_funcall0, (VALUE) &arg, state);
}

static void get_error_pos(VALUE str)
{
    char buff[BUFSIZ];
    ID last_func = rb_frame_last_func();

    if (ruby_sourcefile) {
	if (last_func) {
	    snprintf(buff, BUFSIZ, "%s:%d:in `%s'", ruby_sourcefile, ruby_sourceline,
		     rb_id2name(last_func));
	}
	else {
	    snprintf(buff, BUFSIZ, "%s:%d", ruby_sourcefile, ruby_sourceline);
	}
	rb_str_cat(str, buff, strlen(buff));
    }
}

static void get_exception_info(VALUE str)
{
    VALUE errat;
    VALUE eclass;
    VALUE estr;
    char *einfo;
    int elen;
    int state;

    if (NIL_P(ruby_errinfo)) return;

    errat = rb_funcall(ruby_errinfo, rb_intern("backtrace"), 0);
    if (!NIL_P(errat)) {
	VALUE mesg = RARRAY(errat)->ptr[0];

	if (NIL_P(mesg)) {
	    get_error_pos(str);
	}
	else {
	    rb_str_cat(str, RSTRING(mesg)->ptr, RSTRING(mesg)->len);
	}
    }

    eclass = CLASS_OF(ruby_errinfo);
    estr = rb_protect(rb_obj_as_string, ruby_errinfo, &state);
    if (state) {
	einfo = "";
	elen = 0;
    }
    else {
	einfo = RSTRING(estr)->ptr;
	elen = RSTRING(estr)->len;
    }
    if (eclass == rb_eRuntimeError && elen == 0) {
	STR_CAT_LITERAL(str, ": unhandled exception\n");
    }
    else {
	VALUE epath;

	epath = rb_class_path(eclass);
	if (elen == 0) {
	    STR_CAT_LITERAL(str, ": ");
	    rb_str_cat(str, RSTRING(epath)->ptr, RSTRING(epath)->len);
	    STR_CAT_LITERAL(str, "\n");
	}
	else {
	    char *tail  = 0;
	    int len = elen;

	    if (RSTRING(epath)->ptr[0] == '#') epath = 0;
	    if ((tail = strchr(einfo, '\n')) != NULL) {
		len = tail - einfo;
		tail++;		/* skip newline */
	    }
	    STR_CAT_LITERAL(str, ": ");
	    rb_str_cat(str, einfo, len);
	    if (epath) {
		STR_CAT_LITERAL(str, " (");
		rb_str_cat(str, RSTRING(epath)->ptr, RSTRING(epath)->len);
		STR_CAT_LITERAL(str, ")\n");
	    }
	    if (tail) {
		rb_str_cat(str, tail, elen - len - 1);
		STR_CAT_LITERAL(str, "\n");
	    }
	}
    }

    if (!NIL_P(errat)) {
	long i, len;
	struct RArray *ep;

#define TRACE_MAX (TRACE_HEAD+TRACE_TAIL+5)
#define TRACE_HEAD 8
#define TRACE_TAIL 5

	ep = RARRAY(errat);
	len = ep->len;
	for (i=1; i<len; i++) {
	    if (TYPE(ep->ptr[i]) == T_STRING) {
		STR_CAT_LITERAL(str, "\tfrom ");
		rb_str_cat(str, RSTRING(ep->ptr[i])->ptr, RSTRING(ep->ptr[i])->len);
		STR_CAT_LITERAL(str, "\n");
	    }
	    if (i == TRACE_HEAD && len > TRACE_MAX) {
		char buff[BUFSIZ];
		snprintf(buff, BUFSIZ, "\t ... %ld levels...\n",
			 len - TRACE_HEAD - TRACE_TAIL);
		rb_str_cat(str, buff, strlen(buff));
		i = len - TRACE_TAIL;
	    }
	}
    }
    /* ruby_errinfo = Qnil; */
}

VALUE ruby_get_error_info(int state)
{
    char buff[BUFSIZ];
    VALUE errmsg;

    errmsg = STRING_LITERAL("");
    switch (state) {
    case TAG_RETURN:
	get_error_pos(errmsg);
	STR_CAT_LITERAL(errmsg, ": unexpected return\n");
	break;
    case TAG_NEXT:
	get_error_pos(errmsg);
	STR_CAT_LITERAL(errmsg, ": unexpected next\n");
	break;
    case TAG_BREAK:
	get_error_pos(errmsg);
	STR_CAT_LITERAL(errmsg, ": unexpected break\n");
	break;
    case TAG_REDO:
	get_error_pos(errmsg);
	STR_CAT_LITERAL(errmsg, ": unexpected redo\n");
	break;
    case TAG_RETRY:
	get_error_pos(errmsg);
	STR_CAT_LITERAL(errmsg, ": retry outside of rescue clause\n");
	break;
    case TAG_RAISE:
    case TAG_FATAL:
	get_exception_info(errmsg);
	break;
    default:
	get_error_pos(errmsg);
	snprintf(buff, BUFSIZ, ": unknown longjmp status %d", state);
	rb_str_cat(errmsg, buff, strlen(buff));
	break;
    }
    return errmsg;
}

void ruby_log_error(server_rec *s, VALUE errmsg)
{
    VALUE logmsg;

    logmsg = STRING_LITERAL("mod_ruby: error in ruby\n");
    rb_str_concat(logmsg, errmsg);
    ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, APLOG_STATUS(0) s,
		 "%s", STR2CSTR(logmsg));
}

static void handle_error(request_rec *r, int state)
{
    VALUE errmsg, reqobj;

    errmsg = ruby_get_error_info(state);
    reqobj = (VALUE) ap_get_module_config(r->request_config, &ruby_module);
    if (reqobj)
	rb_apache_request_set_error(reqobj, errmsg, ruby_errinfo);
    ruby_log_error(r->server, errmsg);
}

int ruby_running()
{
    return ruby_is_running;
}

static void setup_loadpath(ruby_server_config *sconf,
			   ruby_dir_config *dconf)
{
    int i, n;
    char **paths;

    rb_load_path = rb_ary_new();
    for (i = 0; i < RARRAY(default_load_path)->len; i++) {
	rb_ary_push(rb_load_path, rb_str_dup(RARRAY(default_load_path)->ptr[i]));
    }
    if (sconf && sconf->load_path) {
	paths = (char **) sconf->load_path->elts;
	n = sconf->load_path->nelts;
	for (i = 0; i < n; i++) {
	    rb_ary_push(rb_load_path, rb_str_new2(paths[i]));
	}
    }
    if (dconf && dconf->load_path) {
	paths = (char **) dconf->load_path->elts;
	n = dconf->load_path->nelts;
	for (i = 0; i < n; i++) {
	    rb_ary_push(rb_load_path, rb_str_new2(paths[i]));
	}
    }
}

int ruby_require(char *filename,
		 ruby_server_config *sconf,
		 ruby_dir_config *dconf)
{
    VALUE fname, exit_status;
    int state;

    setup_loadpath(sconf, dconf);
    fname = rb_str_new2(filename);
    rb_protect_funcall(Qnil, rb_intern("require"), &state, 1, fname);
    if (state == TAG_RAISE &&
	rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
	exit_status = rb_iv_get(ruby_errinfo, "status");
	exit(NUM2INT(exit_status));
    }
    return state;
}

void ruby_add_path(const char *path)
{
    rb_ary_push(default_load_path, rb_str_new2(path));
}

static void dso_unload(void *handle)
{
#if defined(HPUX) || defined(HPUX10) || defined(HPUX11)
    shl_unload((shl_t) handle);
#elif defined(HAVE_DYLD)
    NSUnLinkModule(handle, FALSE);
#else
    dlclose(handle);
#endif
}

#if MODULE_MAGIC_NUMBER >= MMN_130 && RUBY_VERSION_CODE >= 164
static APR_CLEANUP_RETURN_TYPE ruby_cleanup(void *data)
{
    EXTERN VALUE ruby_dln_librefs;
    int i;

    ruby_finalize();
    for (i = 0; i < RARRAY(ruby_dln_librefs)->len; i++) {
	dso_unload((void *) NUM2LONG(RARRAY(ruby_dln_librefs)->ptr[i]));
    }
    APR_CLEANUP_RETURN_SUCCESS();
}
#endif

#ifdef POSIX_SIGNAL
#define ruby_signal(sig,handle) posix_signal((sig),(handle))
#else
#define ruby_signal(sig,handle) signal((sig),(handle))
#endif

#ifdef APACHE2
static int ruby_startup(pool *p, pool *plog, pool *ptemp, server_rec *s)
#else /* Apache 1.x */
static void ruby_startup(server_rec *s, pool *p)
#endif
{
    VALUE stack_start;
    ruby_server_config *conf = get_server_config(s);
    ruby_library_context *libraries;
    char **list;
    int i, n;
    int state;
#ifdef SIGHUP
    RETSIGTYPE (*sighup_handler)_((int));
#endif
#ifdef SIGQUIT
    RETSIGTYPE (*sigquit_handler)_((int));
#endif
#ifdef SIGTERM
    RETSIGTYPE (*sigterm_handler)_((int));
#endif
    void Init_stack _((VALUE*));

    if (!ruby_running()) {
#ifdef SIGHUP
	sighup_handler = signal(SIGHUP, SIG_DFL);
#endif
#ifdef SIGQUIT
	sigquit_handler = signal(SIGQUIT, SIG_DFL);
#endif
#ifdef SIGTERM
	sigterm_handler = signal(SIGTERM, SIG_DFL);
#endif
	ruby_init();
#ifdef SIGHUP
	if (sighup_handler != SIG_ERR)
	    ruby_signal(SIGHUP, sighup_handler);
#endif
#ifdef SIGQUIT
	if (sigquit_handler != SIG_ERR)
	    ruby_signal(SIGQUIT, sigquit_handler);
#endif
#ifdef SIGTERM
	if (sigterm_handler != SIG_ERR)
	    ruby_signal(SIGTERM, sigterm_handler);
#endif

	Init_stack(&stack_start);
	rb_init_apache();

	rb_define_global_const("MOD_RUBY",
			       STRING_LITERAL(MOD_RUBY_STRING_VERSION));

#ifndef WIN32
	origenviron = environ;
#endif /* WIN32 */

	orig_stdin = rb_stdin;
	orig_stdout = rb_stdout;
	orig_defout = rb_defout;

	ruby_init_loadpath();
	default_load_path = rb_load_path;
	rb_global_variable(&default_load_path);
	list = (char **) conf->load_path->elts;
	n = conf->load_path->nelts;
	for (i = 0; i < n; i++) {
	    ruby_add_path(list[i]);
	}
	conf->load_path = NULL;

	default_kcode = rb_get_kcode();

	if (ruby_required_libraries) {
	    libraries = (ruby_library_context *) ruby_required_libraries->elts;
	    n = ruby_required_libraries->nelts;
	    for (i = 0; i < n; i++) {
		if ((state = ruby_require(libraries[i].filename,
					  libraries[i].server_config,
					  libraries[i].dir_config))) {
		    ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO,
				 APLOG_STATUS(0) s,
				 "mod_ruby: failed to require %s",
				 libraries[i].filename);
		    ruby_log_error(s, ruby_get_error_info(state));
		}
	    }
	}

	ruby_is_running = 1;
    }

#if MODULE_MAGIC_NUMBER >= 19980507
    {
	static char buf[BUFSIZ];
	VALUE v;

	v = rb_const_get(rb_cObject, rb_intern("RUBY_VERSION"));
	snprintf(buf, BUFSIZ, "Ruby/%s", STR2CSTR(v));
#ifdef APACHE2
	ap_add_version_component(p, MOD_RUBY_STRING_VERSION);
	ap_add_version_component(p, buf);
#else /* Apache 1.x */
	ap_add_version_component(MOD_RUBY_STRING_VERSION);
	ap_add_version_component(buf);
#endif
    }
#endif

#if MODULE_MAGIC_NUMBER >= MMN_130 && RUBY_VERSION_CODE >= 164
    if (ruby_module.dynamic_load_handle) 
	ap_register_cleanup(p, NULL, ruby_cleanup, ap_null_cleanup);
#endif
#ifdef APACHE2
    return OK;
#endif
}

static APR_CLEANUP_RETURN_TYPE ruby_child_cleanup(void *data)
{
    ruby_finalize();
    APR_CLEANUP_RETURN_SUCCESS();
}

#ifdef APACHE2
static void ruby_child_init(pool *p, server_rec *s)
#else /* Apache 1.x */
static void ruby_child_init(server_rec *s, pool *p)
#endif
{
    ap_register_cleanup(p, NULL, ruby_child_cleanup, ap_null_cleanup);
}

static void mod_ruby_clearenv()
{
#ifdef WIN32
    char *orgp, *p;

    orgp = p = GetEnvironmentStrings();

    if (p == NULL)
	return;

    while (*p) {
	char buf[1024];
	char *q;

	strncpy(buf, p, sizeof buf);
	q = strchr(buf, '=');
	if (q)
	    *(q+1) = '\0';

	putenv(buf);
	p += strlen(p) + 1;
    }

    FreeEnvironmentStrings(orgp);
#else
#ifndef __CYGWIN__
    if (environ == origenviron) {
	environ = ALLOC_N(char*, 1);
    }
    else {
	char **p;

	for (p = environ; *p; p++) {
	    if (*p) free(*p);
	}
	REALLOC_N(environ, char*, 1);
    }
    *environ = NULL;
#endif
#endif
}

static void mod_ruby_setenv(const char *name, const char *value)
{
    if (!name) return;
    if (value && *value)
	ruby_setenv(name, value);
    else
	ruby_unsetenv(name);
}

static void setenv_from_table(table *tbl)
{
    const array_header *env_arr;
    table_entry *env;
    int i;

    env_arr = ap_table_elts(tbl);
    env = (table_entry *) env_arr->elts;
    for (i = 0; i < env_arr->nelts; i++) {
	if (env[i].key == NULL)
	    continue;
	mod_ruby_setenv(env[i].key, env[i].val);
    }
}

void rb_setup_cgi_env(request_rec *r)
{
    ruby_server_config *sconf = get_server_config(r->server);
    ruby_dir_config *dconf = get_dir_config(r);

    mod_ruby_clearenv();
    ap_add_common_vars(r);
    ap_add_cgi_vars(r);
    setenv_from_table(r->subprocess_env);
    setenv_from_table(sconf->env);
    setenv_from_table(dconf->env);
    mod_ruby_setenv("MOD_RUBY", MOD_RUBY_STRING_VERSION);
    mod_ruby_setenv("GATEWAY_INTERFACE", RUBY_GATEWAY_INTERFACE);
}

static VALUE kill_threads(VALUE arg)
{
    extern VALUE rb_thread_list();
    VALUE threads = rb_thread_list();
    VALUE main_thread = rb_thread_main();
    VALUE th;
    int i;

    for (i = 0; i < RARRAY(threads)->len; i++) {
	th = RARRAY(threads)->ptr[i];
	if (th != main_thread)
	    rb_protect_funcall(th, rb_intern("kill"), NULL, 0);
    }
    return Qnil;
}

typedef struct timeout_arg {
    VALUE thread;
    int timeout;
} timeout_arg_t;

static VALUE do_timeout(struct timeout_arg *arg)
{
    char buff[BUFSIZ];
    VALUE err;

    rb_thread_sleep(arg->timeout);
    snprintf(buff, BUFSIZ, "timeout (%d sec)", arg->timeout);
    err = rb_exc_new2(rb_eApacheTimeoutError, buff);
    rb_funcall(arg->thread, rb_intern("raise"), 1, err);
    return Qnil;
}

typedef struct run_safely_arg {
    int safe_level;
    int timeout;
    VALUE (*func)(void*);
    void *arg;
} run_safely_arg_t;

static VALUE run_safely_0(void *arg)
{
    run_safely_arg_t *rsarg = (run_safely_arg_t *) arg;
    struct timeout_arg targ;
    VALUE timeout_thread;
    VALUE result;

    rb_set_safe_level(rsarg->safe_level);
    targ.thread = rb_thread_current();
    targ.timeout = rsarg->timeout;
    timeout_thread = rb_thread_create(do_timeout, (void *) &targ);
    result = (*rsarg->func)(rsarg->arg);
    rb_protect_funcall(timeout_thread, rb_intern("kill"), NULL, 0);
    return result;
}

static int run_safely(int safe_level, int timeout,
		      VALUE (*func)(void*), void *arg, VALUE *retval)
{
    VALUE thread, ret;
    run_safely_arg_t rsarg;
    int state;

    rsarg.safe_level = safe_level;
    rsarg.timeout = timeout;
    rsarg.func = func;
    rsarg.arg = arg;
#if defined(HAVE_SETITIMER)
    rb_thread_start_timer();
#endif
    thread = rb_thread_create(run_safely_0, &rsarg);
    ret = rb_protect_funcall(thread, rb_intern("value"), &state, 0);
    rb_protect(kill_threads, Qnil, NULL);
#if defined(HAVE_SETITIMER)
    rb_thread_stop_timer();
#endif
    if (retval)
	*retval = ret;
    return state;
}

static void per_request_init(request_rec *r)
{
    ruby_server_config *sconf;
    ruby_dir_config *dconf;

    dconf = get_dir_config(r);
    sconf = get_server_config(r->server);
    setup_loadpath(sconf, dconf);
    ruby_debug = Qfalse;
    ruby_verbose = Qfalse;
    if (dconf->kcode)
	rb_set_kcode(dconf->kcode);
    rb_request = rb_get_request_object(r);
    rb_stdin = rb_stdout = rb_defout = rb_request;
}

static VALUE exec_end_proc(VALUE arg)
{
    rb_exec_end_proc();
    return Qnil;
}

static void per_request_cleanup(request_rec *r, int flush)
{
    VALUE reqobj;

    while (r->next)
      r = r->next;

    rb_protect(exec_end_proc, Qnil, NULL);
    if (flush) {
	reqobj = rb_get_request_object(r);
	if (reqobj != Qnil)
	    rb_apache_request_flush(reqobj);
    }
    if (r->main) {
	rb_request = rb_get_request_object(r->main);
	rb_stdin = rb_stdout = rb_defout = rb_request;
    } else {
	rb_request = Qnil;
	rb_stdin = orig_stdin;
	rb_stdout = orig_stdout;
	rb_defout = orig_defout;
    }
    rb_set_kcode(default_kcode);
}

typedef struct handler_arg {
    request_rec *r;
    char *handler;
    ID mid;
} handler_arg_t;

static VALUE ruby_handler_0(void *arg)
{
    handler_arg_t *ha = (handler_arg_t *) arg;
    request_rec *r = ha->r;
    char *handler = ha->handler;
    ID mid = ha->mid;
    VALUE ret;
    int state;

    ret = rb_protect_funcall(rb_eval_string(handler), mid, &state,
			     1, rb_request);
    if (state) {
	if (state == TAG_RAISE &&
	    rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
	    ret = rb_iv_get(ruby_errinfo, "status");
	}
	else {
	    handle_error(r, state);
	    return INT2NUM(HTTP_INTERNAL_SERVER_ERROR);
	}
    }
    if (FIXNUM_P(ret)) {
	return ret;
    }
    else {
	ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO,
		     APLOG_STATUS(0) r->server,
		     "mod_ruby: %s.%s: handler should return Integer",
		     handler, rb_id2name(mid));
	return INT2NUM(HTTP_INTERNAL_SERVER_ERROR);
    }
}

static int ruby_handler(request_rec *r,
			array_header *handlers_arr, ID mid,
			int run_all, int flush)
{
    ruby_server_config *sconf;
    ruby_dir_config *dconf;
    int safe_level;
    int retval;
    int state;
    VALUE ret;
    handler_arg_t arg;
    int i, handlers_len;
    char **handlers;

    if (handlers_arr == NULL)
	return DECLINED;

    sconf = get_server_config(r->server);
    dconf = get_dir_config(r);
    safe_level = dconf->safe_level;
    handlers = (char **) handlers_arr->elts;
    handlers_len = handlers_arr->nelts;
    retval = DECLINED;

    per_request_init(r);
    for (i = 0; i < handlers_len; i++) {
	arg.r = r;
	arg.handler = handlers[i];
	arg.mid = mid;
	ap_soft_timeout("call ruby handler", r);
	if ((state = run_safely(safe_level, sconf->timeout,
				ruby_handler_0, &arg, &ret)) == 0) {
	    retval = NUM2INT(ret);
	}
	else {
	    handle_error(r, state);
	    retval = HTTP_INTERNAL_SERVER_ERROR;
	}
	ap_kill_timeout(r);
	if (retval != DECLINED && (!run_all || retval != OK))
	    break;
    }
    per_request_cleanup(r, flush && retval == OK);
    return retval;
}

static int ruby_object_handler(request_rec *r)
{
    ruby_dir_config *dconf = get_dir_config(r);
    
    return ruby_handler(r, dconf->ruby_handler, rb_intern("handler"), 0, 1);
}

static int ruby_trans_handler(request_rec *r)
{
    ruby_dir_config *dconf = get_dir_config(r);

    return ruby_handler(r, dconf->ruby_trans_handler,
			rb_intern("translate_uri"), 0, 0);
}

static int ruby_authen_handler(request_rec *r)
{
    ruby_dir_config *dconf = get_dir_config(r);
    int retval;

    if (dconf->ruby_authen_handler == NULL) return DECLINED;
#if 0
    ap_table_set(r->notes, "ruby_in_authen_handler", "true");
#endif
    retval = ruby_handler(r, dconf->ruby_authen_handler,
			  rb_intern("authenticate"), 0, 0);
#if 0
    ap_table_unset(r->notes, "ruby_in_authen_handler");
#endif
    return retval;
}

static int ruby_authz_handler(request_rec *r)
{
    ruby_dir_config *dconf = get_dir_config(r);

    return ruby_handler(r, dconf->ruby_authz_handler,
			rb_intern("authorize"), 0, 0);
}

static int ruby_access_handler(request_rec *r)
{
    ruby_dir_config *dconf = get_dir_config(r);

    return ruby_handler(r, dconf->ruby_access_handler,
			rb_intern("check_access"), 1, 0);
}

static int ruby_type_handler(request_rec *r)
{
    ruby_dir_config *dconf = get_dir_config(r);

    if (dconf->ruby_type_handler == NULL) return DECLINED;
    return ruby_handler(r, dconf->ruby_type_handler,
			rb_intern("find_types"), 0, 0);
}

static int ruby_fixup_handler(request_rec *r)
{
    ruby_dir_config *dconf = get_dir_config(r);

    if (dconf->ruby_fixup_handler == NULL) return DECLINED;
    return ruby_handler(r, dconf->ruby_fixup_handler,
			rb_intern("fixup"), 1, 0);
}

static int ruby_log_handler(request_rec *r)
{
    ruby_dir_config *dconf = get_dir_config(r);

    if (dconf->ruby_log_handler == NULL) return DECLINED;
    return ruby_handler(r, dconf->ruby_log_handler,
			rb_intern("log_transaction"), 1, 0);
}

#ifndef APACHE2 /* Apache 1.x */
static int ruby_header_parser_handler(request_rec *r)
{
    ruby_dir_config *dconf = get_dir_config(r);
    int retval;

    if (dconf->ruby_init_handler &&
	ap_table_get(r->notes, "ruby_init_ran") == NULL) {
	retval = ruby_handler(r, dconf->ruby_init_handler,
			      rb_intern("init"), 1, 0);
	if (retval != OK && retval != DECLINED)
	    return retval;
    }
    if (dconf->ruby_header_parser_handler == NULL) return DECLINED;
    return ruby_handler(r, dconf->ruby_header_parser_handler,
			rb_intern("header_parse"), 1, 0);
}
#endif

static APR_CLEANUP_RETURN_TYPE ruby_cleanup_handler(void *data)
{
    request_rec *r = (request_rec *) data;
    ruby_dir_config *dconf = get_dir_config(r);

    ruby_handler(r, dconf->ruby_cleanup_handler,
		 rb_intern("cleanup"), 1, 0);
    APR_CLEANUP_RETURN_SUCCESS();
}

static int ruby_post_read_request_handler(request_rec *r)
{
    ruby_dir_config *dconf = get_dir_config(r);
    int retval;

    ap_register_cleanup(r->pool, (void *) r, ruby_cleanup_handler, 
			ap_null_cleanup);

    if (dconf->ruby_init_handler) {
	retval = ruby_handler(r, dconf->ruby_init_handler,
			      rb_intern("init"), 1, 0);
	ap_table_set(r->notes, "ruby_init_ran", "true");
	if (retval != OK && retval != DECLINED)
	    return retval;
    }
    return ruby_handler(r, dconf->ruby_post_read_request_handler,
			rb_intern("post_read_request"), 1, 0);
}

/*
 * Local variables:
 * mode: C
 * tab-width: 8
 * End:
 */
@


1.73
log
@* mod_ruby.c (ruby_require): do not require doubly.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.72 2002/05/24 06:41:00 shugo Exp $
d125 1
a125 1
    {"RubyTransHandler", ruby_cmd_trans_handler, NULL, OR_ALL, TAKE1,
d143 1
a143 1
     NULL, OR_ALL, TAKE1,
@


1.73.2.1
log
@* merged from HEAD.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.74 2002/08/23 03:07:53 shugo Exp $
d125 1
a125 1
    {"RubyTransHandler", ruby_cmd_trans_handler, NULL, RSRC_CONF, TAKE1,
d143 1
a143 1
     NULL, RSRC_CONF, TAKE1,
@


1.72
log
@* mod_ruby.c (ruby_startup): remove already require libraries from
conf->load_path.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.71 2002/05/21 05:58:35 shugo Exp $
a485 1
    rb_protect((VALUE (*)(VALUE)) rb_require, (VALUE) filename, &state);
@


1.71
log
@* ruby_config.c (ruby_cmd_require): fixed the third argument of
ap_make_array().
* ruby_config.c (ruby_merge_server_config): new function.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.70 2002/05/21 05:16:35 shugo Exp $
d602 1
@


1.70
log
@* ruby_config.c (ruby_cmd_require): push ruby_server_config* and
ruby_dir_config* to ruby_required_libraries.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.69 2002/05/21 04:59:21 shugo Exp $
d181 1
a181 1
    NULL,			/* merge server config */
d204 1
a204 1
    NULL,			/* merge server config */
@


1.69
log
@* apachelib.c (apache_server_root): moved from
request.c:request_server_root().
* request.c (request_proxy_q): fix for Apache2.
* request.c (request_proxy_pass_q): ditto.
* request.c (request_lookup_uri): ditto.
* request.c (request_lookup_file): ditto.
* request.c (request_server_root): new method.
* request.c (request_get_dispatch_handler): ditto.
* request.c (request_set_dispatch_handler): ditto.
* request.c (request_proxy_q): ditto.
* request.c (request_proxy_pass_q): ditto.
* request.c (request_get_cache_resp): ditto.
* request.c (request_set_cache_resp): ditto.
* request.c (request_get_cache_resp): ditto.
* request.c (request_lookup_uri): ditto.
* request.c (request_lookup_file): ditto.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.68 2002/05/16 05:16:39 shugo Exp $
d541 1
d606 1
a606 1
	    list = (char **) ruby_required_libraries->elts;
d609 3
a611 1
		if ((state = ruby_require(list[i], NULL, NULL))) {
d614 2
a615 1
				 "mod_ruby: failed to require %s", list[i]);
@


1.68
log
@* mod_ruby.c (per_request_init): use sconf->load_path.
* mod_ruby.c (ruby_require): call require method.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.67 2002/04/30 05:51:05 shugo Exp $
d452 2
a453 1
static void init_loadpath()
d455 2
a456 1
    int i;
d462 14
d478 3
a480 1
int ruby_require(char *filename)
d485 1
a485 1
    init_loadpath();
d608 1
a608 1
		if ((state = ruby_require(list[i]))) {
a826 2
    char **paths;
    int i, n;
d830 1
a830 18
    rb_load_path = rb_ary_new();
    for (i = 0; i < RARRAY(default_load_path)->len; i++) {
	rb_ary_push(rb_load_path, rb_str_dup(RARRAY(default_load_path)->ptr[i]));
    }
    if (dconf->load_path) {
	paths = (char **) dconf->load_path->elts;
	n = dconf->load_path->nelts;
	for (i = 0; i < n; i++) {
	    rb_ary_push(rb_load_path, rb_str_new2(paths[i]));
	}
    }
    if (sconf->load_path) {
	paths = (char **) sconf->load_path->elts;
	n = sconf->load_path->nelts;
	for (i = 0; i < n; i++) {
	    rb_ary_push(rb_load_path, rb_str_new2(paths[i]));
	}
    }
@


1.67
log
@	* mod_ruby.h: Moved several define's from mod_ruby.c.

	* mod_ruby.c (per_request_cleanup): fixed SEGV for internal
	subrequest clean up.

	* request.c (request_last) new method.

	* request.c (request_internal_redirect) ditto.

	* request.c (request_custom_response) ditto.

	* request.c (request_is_main) ditto.

	* request.c (request_is_initial) ditto.

	* request.c (request_bytes_sent) ditto.

	* request.c (request_send_fd) ditto.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.66 2002/03/27 05:17:20 shugo Exp $
d464 1
a464 1
    VALUE exit_status;
d469 2
d807 2
a808 1
    ruby_dir_config *dconf = get_dir_config(r);
d812 2
d821 7
@


1.66
log
@* request.c (request_set_user): new method.

* request.c (request_set_auth_type): ditto.

* request.c (request_set_auth_name): ditto.

* connection.c (connection_set_user): ditto.

* connection.c (connection_set_auth_type): ditto.

* connection.c (connection_remote_port): fix for Apache2.

* connection.c (connection_local_port): ditto.

* connection.c (connection_remote_port): new method.

* connection.c (connection_local_port): ditto.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.65 2002/03/05 05:57:35 shugo Exp $
a227 11
/* copied from eval.c */
#define TAG_RETURN	0x1
#define TAG_BREAK	0x2
#define TAG_NEXT	0x3
#define TAG_RETRY	0x4
#define TAG_REDO	0x5
#define TAG_RAISE	0x6
#define TAG_THROW	0x7
#define TAG_FATAL	0x8
#define TAG_MASK	0xf

d838 3
d845 1
a845 1
	    rb_apache_request_flush(rb_request);
d850 1
a850 2
    }
    else {
@


1.65
log
@* supports Apache 2.0.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.64 2002/02/28 06:41:17 shugo Exp $
d100 1
a100 1
#ifndef STANDARD20_MODULE_STUFF /* Apache 1.x */
d154 2
a155 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
a156 4
#else /* Apache 1.x */
static void ruby_startup(server_rec*, pool*);
#endif
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
a157 5
#else /* Apache 1.x */
static void ruby_child_init(server_rec*, pool*);
#endif

#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
d188 3
d524 1
a524 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
a615 5
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
	ap_add_version_component(p, MOD_RUBY_STRING_VERSION);
#else /* Apache 1.x */
	ap_add_version_component(MOD_RUBY_STRING_VERSION);
#endif
d618 2
a619 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
d622 1
d632 1
a632 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
d643 1
a643 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
d1028 1
a1028 1
#ifndef STANDARD20_MODULE_STUFF /* Apache 1.x */
@


1.64
log
@* ruby_config.c (ruby_cmd_add_path): allow to use RubyAddPath in
.htaccess.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.63 2002/01/30 08:42:34 shugo Exp $
a31 22
#ifdef WIN32
#include <windows.h>
#endif

#include "httpd.h"
#include "http_config.h"
#include "http_core.h"
#include "http_log.h"
#include "http_main.h"
#include "http_protocol.h"
#include "http_request.h"
#include "util_script.h"
#include "multithread.h"

#include "ruby.h"
#include "rubyio.h"
#define regoff_t ruby_regoff_t
#define regex_t ruby_regex_t
#define regmatch_t ruby_regmatch_t
#include "re.h"
#include "util.h"
#include "version.h"
d36 29
a64 2
#ifdef USE_ERUBY
#include "eruby.h"
d100 1
d102 1
a104 5
static int ruby_script_handler(request_rec *r);
#ifdef USE_ERUBY
static int eruby_script_handler(request_rec *r);
#endif

d154 42
a198 4
    {"ruby-script", ruby_script_handler},
#ifdef USE_ERUBY
    {ERUBY_MIME_TYPE, eruby_script_handler},
#endif
a201 3
static void ruby_startup(server_rec*, pool*);
static void ruby_child_init(server_rec*, pool*);

d231 1
a441 24
static void ruby_print_error(request_rec *r, int state)
{
    VALUE errmsg, logmsg;

    r->content_type = "text/html";
    ap_send_http_header(r);
    ap_rputs("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\">\n", r);
    ap_rputs("<html>\n", r);
    ap_rputs("<head><title>Error</title></head>\n", r);
    ap_rputs("<body>\n", r);
    ap_rputs("<pre>\n", r);

    errmsg = ruby_get_error_info(state);
    ap_rputs(ap_escape_html(r->pool, STR2CSTR(errmsg)), r);
    logmsg = STRING_LITERAL("mod_ruby: error in ruby\n");
    rb_str_concat(logmsg, errmsg);
    ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, r->server,
		 "%s", STR2CSTR(logmsg));

    ap_rputs("</pre>\n", r);
    ap_rputs("</body>\n", r);
    ap_rputs("</html>\n", r);
}

d448 1
a448 1
    ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, s,
d498 11
d510 1
a510 1
static void ruby_cleanup(void *data)
d517 1
a517 1
	ap_os_dso_unload((void *) NUM2LONG(RARRAY(ruby_dln_librefs)->ptr[i]));
d519 1
d529 3
d533 1
a576 3
#ifdef USE_ERUBY
	eruby_init();
#endif
d605 2
a606 1
		    ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, s,
d621 3
d625 1
d628 3
d632 1
d640 3
d645 1
a645 1
static void ruby_child_cleanup(void *data)
d648 1
d651 3
d655 1
d713 1
a713 1
    array_header *env_arr;
d900 1
a900 1
	    return INT2NUM(SERVER_ERROR);
d907 2
a908 1
	ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, r->server,
d911 1
a911 1
	return INT2NUM(SERVER_ERROR);
d951 1
a951 1
	    retval = SERVER_ERROR;
d1036 1
d1053 1
d1055 1
a1055 1
static void ruby_cleanup_handler(void *data)
d1062 1
a1082 113

static int script_handler(VALUE (*func)(void*), request_rec *r)
{
    ruby_server_config *sconf = get_server_config(r->server);
    ruby_dir_config *dconf = get_dir_config(r);
    int safe_level = dconf->safe_level;
    VALUE ret;
    int retval;

    if (r->finfo.st_mode == 0)
	return NOT_FOUND;
    if (S_ISDIR(r->finfo.st_mode))
	return FORBIDDEN;

    per_request_init(r);
    rb_setup_cgi_env(r);
    if (r->filename)
	ap_chdir_file(r->filename);

    ap_soft_timeout("load ruby script", r);
    if (run_safely(safe_level, sconf->timeout, func, r, &ret) == 0) {
	retval = NUM2INT(ret);
    }
    else {
	retval = SERVER_ERROR;
    }
    ap_kill_timeout(r);

    per_request_cleanup(r, retval == OK);

    return retval;
}

static VALUE load_ruby_script(void *arg)
{
    request_rec *r = (request_rec *) arg;
    int state;
    VALUE ret;

    rb_load_protect(rb_str_new2(r->filename), 1, &state);
    rb_exec_end_proc();
    if (state) {
	if (state == TAG_RAISE &&
	    rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
	    ret = rb_iv_get(ruby_errinfo, "status");
	}
	else {
	    ruby_print_error(r, state);
	    return INT2NUM(OK);
	}
    }
    else {
	ret = INT2NUM(OK);
    }
    return ret;
}

static int ruby_script_handler(request_rec *r)
{
    return script_handler(load_ruby_script, r);
}

#ifdef USE_ERUBY
static VALUE load_eruby_script(void *arg)
{
    request_rec *r = (request_rec *) arg;
    int state;
    VALUE ret;

    eruby_noheader = 0;
    eruby_charset = eruby_default_charset;
#if defined(ERUBY_VERSION_CODE) && ERUBY_VERSION_CODE >= 90
    eruby_load(r->filename, 0, &state);
#else
    {
	VALUE script;
	script = eruby_load(r->filename, 0, &state);
	if (!NIL_P(script)) unlink(STR2CSTR(script));
    }
#endif
    rb_exec_end_proc();
    if (state) {
	if (state == TAG_RAISE &&
	    rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
	    ret = rb_iv_get(ruby_errinfo, "status");
	}
	else {
	    ruby_print_error(r, state);
	    return INT2NUM(OK);
	}
    }
    else {
	ret = INT2NUM(OK);
    }
    if (!eruby_noheader) {
	long len = rb_apache_request_length(rb_request);
	
	if (strcmp(r->content_type, "text/html") == 0) {
	    r->content_type = ap_psprintf(r->pool,
					  "text/html; charset=%s",
					  ERUBY_CHARSET);
	}
	ap_set_content_length(r, len);
	rb_apache_request_send_http_header(rb_request);
    }
    return ret;
}

static int eruby_script_handler(request_rec *r)
{
    return script_handler(load_eruby_script, r);
}
#endif
@


1.63
log
@* version 0.9.6 released.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.62 2001/12/17 07:31:43 shugo Exp $
d107 1
a107 1
    {"RubyAddPath", ruby_cmd_add_path, NULL, RSRC_CONF, ITERATE,
d781 2
a782 1
    int i;
d787 7
@


1.62
log
@* mod_ruby.c (ruby_startup): save Apache's signal handlers.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.61 2001/10/15 03:27:46 shugo Exp $
d163 1
d183 1
a183 1
    NULL,			/* child_init */
d364 1
a364 1
static VALUE get_error_info(int state)
d416 1
a416 1
    errmsg = get_error_info(state);
d442 1
a442 1
    errmsg = get_error_info(state);
d490 1
d580 1
a580 1
		    ruby_log_error(s, get_error_info(state));
d606 10
d929 1
d931 1
d934 1
d936 1
@


1.61
log
@* mod_ruby.c (ruby_startup): call Init_stack().
* request.c (cleanup_request_object): free RDATA(reqobj)->data.
* request.c (request_headers_in): allow non-auth handlers to
access Authorization header fields.
* request.c (request_get_basic_auth_pw): allow non-auth handlers.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.60 2001/10/12 08:53:35 shugo Exp $
d31 1
d495 6
d508 9
d520 9
d530 13
@


1.61.2.1
log
@* mod_ruby.c: use config.h for VERSION.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.61 2001/10/15 03:27:46 shugo Exp $
a59 3
#include "config.h"

#define VERSION_COMPONENT PACKAGE "/" VERSION
d512 1
a512 1
			       STRING_LITERAL(VERSION_COMPONENT));
d553 1
a553 1
	ap_add_version_component(VERSION_COMPONENT);
d643 1
a643 1
    mod_ruby_setenv("MOD_RUBY", VERSION_COMPONENT);
@


1.60
log
@* apachelib.h (DEFINE_ATTR_READER): raise exception if data == NULL.
* apachelib.h (DEFINE_ATTR_WRITER): ditto.
* mod_ruby.c (per_request_cleanup): set r->main to rb_request if r
is a sub_request.
* request.c (request_mark): return immediately if data == NULL.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.59 2001/10/10 03:16:20 shugo Exp $
d5 1
a5 1
 * Copyright (C) 2000  Shugo Maeda <shugo@@modruby.net>
d496 1
d501 1
d505 1
@


1.59
log
@* ruby_config.c (ruby_cmd_output_mode): new directive RubyOutputMode.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.58 2001/10/04 09:19:38 shugo Exp $
d748 1
a748 1
static void per_request_cleanup(int flush)
d750 2
d753 15
a767 6
    if (flush)
	rb_apache_request_flush(rb_request);
    rb_request = Qnil;
    rb_stdin = orig_stdin;
    rb_stdout = orig_stdout;
    rb_defout = orig_defout;
d851 1
a851 1
    per_request_cleanup(flush && retval == OK);
d998 1
a998 1
    per_request_cleanup(retval == OK);
@


1.58
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.57 2001/08/24 02:23:39 shugo Exp $
d118 2
@


1.57
log
@* lib/apache/eruby-run.rb (postrun): do not overwrite r.content_type.
* mod_ruby.c (ruby_require): handle SystemExit correctly.
* request.c (request_method_number): new method.
* apachelib.c: new constants M_GET, M_PUT, ....
* configure.rb: rebuild with autoconf.rb 0.2.3 for Solaris.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.56 2001/08/13 02:27:17 shugo Exp $
d220 1
a220 1
static VALUE protect_funcall(VALUE recv, ID mid, int *state, int argc, ...)
d357 1
a357 1
    ruby_errinfo = Qnil;
d424 1
a424 1
void ruby_log_error(server_rec *s, int state)
d426 1
a426 1
    VALUE errmsg, logmsg;
a427 1
    errmsg = get_error_info(state);
d434 11
d535 1
a535 1
		    ruby_log_error(s, state);
d653 1
a653 1
	    protect_funcall(th, rb_intern("kill"), NULL, 0);
d694 1
a694 1
    protect_funcall(timeout_thread, rb_intern("kill"), NULL, 0);
d713 1
a713 1
    ret = protect_funcall(thread, rb_intern("value"), &state, 0);
a731 1
    ruby_errinfo = Qnil;
d736 2
a737 4
    if (NIL_P(rb_request)) {
	rb_request = rb_apache_request_new(r);
	rb_stdin = rb_stdout = rb_defout = rb_request;
    }
d751 4
a754 2

    ruby_errinfo = Qnil;
d773 2
a774 2
    ret = protect_funcall(rb_eval_string(handler), mid, &state,
			  1, rb_request);
d781 1
a781 1
	    ruby_log_error(r->server, state);
d831 1
a831 1
	    ruby_log_error(r->server, state);
a936 4
    rb_request = Qnil;
    rb_stdin = orig_stdin;
    rb_stdout = orig_stdout;
    rb_defout = orig_defout;
@


1.56
log
@* version 0.9.2 released.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.55 2001/08/06 05:39:37 shugo Exp $
d452 1
d457 5
@


1.55
log
@* version 0.9.1 released.
@
text
@d2 1
a2 1
 * $Id$
d440 10
d454 1
@


1.54
log
@* mod_ruby.c (ruby_handler): flush rb_request only in RubyHandler.
* server.c (server_document_root): new method.
Thanks to Sean Chittenden.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.53 2001/07/27 04:46:40 shugo Exp $
d6 1
d8 8
a15 1
 * Author: Shugo Maeda <shugo@@modruby.net>
d17 11
a27 16
 * This file is part of mod_ruby.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA.
@


1.53
log
@* mod_ruby.c (per_request_cleanup): do not restore rb_stdout.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.52 2001/07/02 03:47:49 shugo Exp $
d768 2
a769 1
			array_header *handlers_arr, ID mid, int run_all)
d809 1
a809 1
    per_request_cleanup(retval == OK);
d817 1
a817 1
    return ruby_handler(r, dconf->ruby_handler, rb_intern("handler"), 0);
d825 1
a825 1
			rb_intern("translate_uri2file"), 0);
d836 1
a836 1
			  rb_intern("authenticate"), 0);
d846 1
a846 1
			rb_intern("authorize"), 0);
d854 1
a854 1
			rb_intern("check_access"), 1);
d863 1
a863 1
			rb_intern("find_types"), 0);
d872 1
a872 1
			rb_intern("fixup"), 1);
d881 1
a881 1
			rb_intern("log_transaction"), 1);
d892 1
a892 1
			      rb_intern("init"), 1);
d898 1
a898 1
			rb_intern("header_parse"), 1);
d907 1
a907 1
		 rb_intern("cleanup"), 1);
d924 1
a924 1
			      rb_intern("init"), 1);
d930 1
a930 1
			rb_intern("post_read_request"), 1);
@


1.52
log
@* request.c (request_set_content_type): accept nil.
* request.c (request_set_content_encoding): ditto.
* request.c (request_set_content_languages): ditto.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.51 2001/06/29 07:09:14 shugo Exp $
d707 1
a707 1
    if (NIL_P(rb_request))
d709 2
a710 1
    rb_stdin = rb_stdout = rb_defout = rb_request;
a725 3
    rb_stdin = orig_stdin;
    rb_stdout = orig_stdout;
    rb_defout = orig_defout;
d908 3
@


1.51
log
@* mod_ruby.c (per_request_init): set rb_stdin, rb_stdout,
rb_defout to rb_request.
* mod_ruby.c (per_request_cleanup): flush rb_request.
* request.c (request_output_buffer): new method.
* lib/apache/cgi-support.rb: removed.
* lib/apache/eruby-run.rb: use tempfile.
* lib/apache/erb-run.rb: ditto.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.50 2001/06/29 03:44:40 shugo Exp $
d451 1
a451 1
static void mod_ruby_dso_unload(void *data)
d527 1
a527 1
	ap_register_cleanup(p, NULL, mod_ruby_dso_unload, ap_null_cleanup);
@


1.50
log
@* mod_ruby.c: cancel modification.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.48 2001/06/27 03:49:56 shugo Exp $
a63 1
EXTERN VALUE rb_defout;
d66 5
d483 4
d709 1
d718 1
a718 1
static void per_request_cleanup()
d721 7
a742 1
    int retval;
d758 4
a761 2
    if (TYPE(ret) != T_FIXNUM &&
	TYPE(ret) != T_BIGNUM) {
a766 3
    rb_apache_request_flush(rb_request);
    retval = NUM2INT(ret);
    return INT2NUM(retval);
d810 1
a810 1
    per_request_cleanup();
a936 1
    VALUE orig_stdin, orig_stdout, orig_defout;
a945 6
    orig_stdin = rb_stdin;
    orig_stdout = rb_stdout;
    orig_defout = rb_defout;
    rb_stdin = rb_request;
    rb_stdout = rb_request;
    rb_defout = rb_request;
d958 1
a958 4
    rb_stdin = orig_stdin;
    rb_stdout = orig_stdout;
    rb_defout = orig_defout;
    per_request_cleanup();
a983 1
    rb_apache_request_flush(rb_request);
a1034 1
    rb_apache_request_flush(rb_request);
@


1.49
log
@* mod_ruby.c (ruby_cleanup_handler): call rb_exec_end_proc().
(It was called in per_request_cleanup() before.)
@
text
@d703 6
d711 1
a887 6
static VALUE exec_end_proc(VALUE arg)
{
    rb_exec_end_proc();
    return Qnil;
}

a894 1
    rb_protect(exec_end_proc, Qnil, NULL);
@


1.48
log
@* mod_ruby.c (per_request_init): recycle rb_request.
* request.c: removed notes from struct request_data.
* request.c (rb_apache_request_flush): flush only once.
* request.c (request_to_s): removed.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.47 2001/06/22 03:18:26 shugo Exp $
a702 6
static VALUE exec_end_proc(VALUE arg)
{
    rb_exec_end_proc();
    return Qnil;
}

a704 1
    rb_protect(exec_end_proc, Qnil, NULL);
d881 6
d894 1
@


1.47
log
@* mod_ruby.c (load_eruby_script): don't use print_error().
* mod_ruby.c (ruby_handler): multi-handler support.
* ruby_config.c (ruby_cmd_post_read_request_handler): new handler.
* ruby_config.c (ruby_cmd_init_handler): ditto.
* ruby_config.c (ruby_cmd_cleanup_handler): ditto.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.46 2001/06/21 09:34:49 shugo Exp $
d699 2
a700 1
    rb_request = rb_apache_request_new(r);
a711 1
    rb_request = Qnil;
d895 1
@


1.46
log
@* ruby_config.c (ruby_cmd_require): use ruby_required_libraries
for virtual hosts.
* lib/apache/erb-run.rb: no need to inherit Apache::RubyRun.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.45 2001/06/21 07:50:33 shugo Exp $
d74 1
a74 1
static mutex *mod_ruby_mutex = NULL;
d79 16
d127 2
a128 1
    {"RubyHeaderParserHandler", ruby_cmd_header_parser_handler, NULL, OR_ALL, TAKE1,
d130 9
a141 14
static int ruby_script_handler(request_rec*);
#ifdef USE_ERUBY
static int eruby_script_handler(request_rec*);
#endif
static int ruby_object_handler(request_rec*);
static int ruby_trans_handler(request_rec*);
static int ruby_authen_handler(request_rec*);
static int ruby_authz_handler(request_rec*);
static int ruby_access_handler(request_rec*);
static int ruby_type_handler(request_rec*);
static int ruby_fixup_handler(request_rec*);
static int ruby_log_handler(request_rec*);
static int ruby_header_parser_handler(request_rec*);

d164 1
a164 1
    ruby_trans_handler,	/* filename translation */
d174 1
a174 1
    NULL,			/* post read-request */
a464 4
#ifdef MULTITHREAD
    mod_ruby_mutex = ap_create_mutex("mod_ruby_mutex");
#endif

d702 6
d710 1
a714 6
static VALUE exec_end_proc(VALUE arg)
{
    rb_exec_end_proc();
    return Qnil;
}

d755 2
a756 1
static int ruby_handler(request_rec *r, char *handler, ID mid)
d758 3
a760 3
    ruby_server_config *sconf = get_server_config(r->server);
    ruby_dir_config *dconf = get_dir_config(r);
    int safe_level = dconf->safe_level;
d765 12
a777 1
    (void) ap_acquire_mutex(mod_ruby_mutex);
d779 16
a794 7
    ap_soft_timeout("call ruby handler", r);
    arg.r = r;
    arg.handler = handler;
    arg.mid = mid;
    if ((state = run_safely(safe_level, sconf->timeout,
			    ruby_handler_0, &arg, &ret)) == 0) {
	retval = NUM2INT(ret);
a795 6
    else {
	ruby_log_error(r->server, state);
	retval = SERVER_ERROR;
    }
    rb_protect(exec_end_proc, Qnil, NULL);
    ap_kill_timeout(r);
a796 1
    (void) ap_release_mutex(mod_ruby_mutex);
d803 2
a804 4

    if (dconf->ruby_handler == NULL) return DECLINED;
    return ruby_handler(r, dconf->ruby_handler,
			rb_intern("handler"));
a810 1
    if (dconf->ruby_trans_handler == NULL) return DECLINED;
d812 1
a812 1
			rb_intern("translate_name"));
d821 1
a821 1
    ap_table_set(r->notes, "In-RubyAuthenHandler", "true");
d823 2
a824 2
			  rb_intern("check_user_id"));
    ap_table_unset(r->notes, "In-RubyAuthenHandler");
a831 1
    if (dconf->ruby_authz_handler == NULL) return DECLINED;
d833 1
a833 1
			rb_intern("check_auth"));
a839 1
    if (dconf->ruby_access_handler == NULL) return DECLINED;
d841 1
a841 1
			rb_intern("check_access"));
d850 1
a850 1
			rb_intern("find_types"));
d859 1
a859 1
			rb_intern("fixup"));
d868 1
a868 1
			rb_intern("log_transaction"));
d874 1
d876 7
d885 29
a913 1
			rb_intern("header_parse"));
a929 2
    (void) ap_acquire_mutex(mod_ruby_mutex);

a954 1
    (void) ap_release_mutex(mod_ruby_mutex);
d1013 1
a1013 1
	    print_error(r, state);
@


1.45
log
@* mod_ruby.c (ruby_startup): removed Ruby version from version
	component.
* mod_ruby.c (ruby_startup): log error if ruby_require() fails.
* mod_ruby.c (ruby_handler): don't call rb_apache_request_flush()
on error.
* request.c (rb_apache_request_new): should initialize data->server.
* lib/apache/ruby-run.rb (handler): require ExecCGI and exec
permission.
* lib/apache/eruby-run.rb (handler): require ExecCGI.
* lib/apache/cgi-support.rb: new file.
* lib/apache/erb-run.rb: new file, supports ERb.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.44 2001/06/11 02:14:15 shugo Exp $
d77 1
a77 1
/* static int exit_status; */
d405 1
a405 1
static void ruby_log_error(server_rec *s, int state)
d482 9
a490 8
	list = (char **) conf->required_files->elts;
	n = conf->required_files->nelts;
	for (i = 0; i < n; i++) {
	    if ((state = ruby_require(list[i]))) {
		ruby_log_error(s, state);
		fprintf(stderr, "Require of Ruby file `%s' failed, exiting...\n", 
			list[i]);
		exit(1);
d498 9
a506 1
    ap_add_version_component(MOD_RUBY_STRING_VERSION);
@


1.44
log
@* mod_ruby.c (ruby_handler_0): handle SystemExit correctly.
* array_header.c (array_length): new method.
* table.c: renamed ApacheInTable to ApacheRestrictedTable.
* request.c (rb_apache_request_new): don't set content_type.
* request.c (request_headers_in): return non-restricted table for
RubyAuthenHandler.
* request.c (request_notes): removed.
* request.c (request_allow_options): new method.
* request.c (request_allow_overrides): ditto.
* request.c (request_default_type): ditto.
* request.c (request_construct_url): ditto.
* request.c (request_auth_type): ditto.
* request.c (request_auth_name): ditto.
* request.c (request_satisfies): ditto.
* request.c (request_requires): ditto.
* request.c (request_note_auth_failure): ditto.
* request.c (request_note_basic_auth_failure): ditto.
* request.c (request_note_digest_auth_failure): ditto.
* request.c (request_basic_auth_pw): ditto.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.43 2001/06/10 03:11:47 shugo Exp $
a227 182
int ruby_running()
{
    return ruby_is_running;
}

int ruby_require(char *filename)
{
    int state;

    rb_protect((VALUE (*)(VALUE)) rb_require, (VALUE) filename, &state);
    return state;
}

void ruby_add_path(const char *path)
{
    rb_ary_push(default_load_path, rb_str_new2(path));
}

#if MODULE_MAGIC_NUMBER >= MMN_130 && RUBY_VERSION_CODE >= 164
static void mod_ruby_dso_unload(void *data)
{
    EXTERN VALUE ruby_dln_librefs;
    int i;

    for (i = 0; i < RARRAY(ruby_dln_librefs)->len; i++) {
	ap_os_dso_unload((void *) NUM2LONG(RARRAY(ruby_dln_librefs)->ptr[i]));
    }
}
#endif

static void ruby_startup(server_rec *s, pool *p)
{
    ruby_server_config *conf = get_server_config(s);
    char **list;
    int i, n;

#ifdef MULTITHREAD
    mod_ruby_mutex = ap_create_mutex("mod_ruby_mutex");
#endif

    if (!ruby_running()) {
	ruby_init();
	rb_init_apache();
#ifdef USE_ERUBY
	eruby_init();
#endif

	rb_define_global_const("MOD_RUBY",
			       STRING_LITERAL(MOD_RUBY_STRING_VERSION));

#ifndef WIN32
	origenviron = environ;
#endif /* WIN32 */

	ruby_init_loadpath();
	default_load_path = rb_load_path;
	rb_global_variable(&default_load_path);
	list = (char **) conf->load_path->elts;
	n = conf->load_path->nelts;
	for (i = 0; i < n; i++) {
	    ruby_add_path(list[i]);
	}

	default_kcode = rb_get_kcode();

	list = (char **) conf->required_files->elts;
	n = conf->required_files->nelts;
	for (i = 0; i < n; i++) {
	    if (ruby_require(list[i])) {
		fprintf(stderr, "Require of Ruby file `%s' failed, exiting...\n", 
			list[i]);
		exit(1);
	    }
	}

	ruby_is_running = 1;
    }

#if MODULE_MAGIC_NUMBER >= 19980507
    {
	static char buf[BUFSIZ];
	VALUE v, d;

	ap_add_version_component(MOD_RUBY_STRING_VERSION);
	v = rb_const_get(rb_cObject, rb_intern("RUBY_VERSION"));
	d = rb_const_get(rb_cObject, rb_intern("RUBY_RELEASE_DATE"));
	snprintf(buf, BUFSIZ, "Ruby/%s(%s)", STR2CSTR(v), STR2CSTR(d));
	ap_add_version_component(buf);
#ifdef USE_ERUBY
	snprintf(buf, BUFSIZ, "eRuby/%s", eruby_version());
	ap_add_version_component(buf);
#endif
    }
#endif

#if MODULE_MAGIC_NUMBER >= MMN_130 && RUBY_VERSION_CODE >= 164
    if (ruby_module.dynamic_load_handle) 
	ap_register_cleanup(p, NULL, mod_ruby_dso_unload, ap_null_cleanup);
#endif
}

static void mod_ruby_clearenv()
{
#ifdef WIN32
    char *orgp, *p;

    orgp = p = GetEnvironmentStrings();

    if (p == NULL)
	return;

    while (*p) {
	char buf[1024];
	char *q;

	strncpy(buf, p, sizeof buf);
	q = strchr(buf, '=');
	if (q)
	    *(q+1) = '\0';

	putenv(buf);
	p += strlen(p) + 1;
    }

    FreeEnvironmentStrings(orgp);
#else
#ifndef __CYGWIN__
    if (environ == origenviron) {
	environ = ALLOC_N(char*, 1);
    }
    else {
	char **p;

	for (p = environ; *p; p++) {
	    if (*p) free(*p);
	}
	REALLOC_N(environ, char*, 1);
    }
    *environ = NULL;
#endif
#endif
}

static void mod_ruby_setenv(const char *name, const char *value)
{
    if (!name) return;
    if (value && *value)
	ruby_setenv(name, value);
    else
	ruby_unsetenv(name);
}

static void setenv_from_table(table *tbl)
{
    array_header *env_arr;
    table_entry *env;
    int i;

    env_arr = ap_table_elts(tbl);
    env = (table_entry *) env_arr->elts;
    for (i = 0; i < env_arr->nelts; i++) {
	if (env[i].key == NULL)
	    continue;
	mod_ruby_setenv(env[i].key, env[i].val);
    }
}

void rb_setup_cgi_env(request_rec *r)
{
    ruby_server_config *sconf = get_server_config(r->server);
    ruby_dir_config *dconf = get_dir_config(r);

    mod_ruby_clearenv();
    ap_add_common_vars(r);
    ap_add_cgi_vars(r);
    setenv_from_table(r->subprocess_env);
    setenv_from_table(sconf->env);
    setenv_from_table(dconf->env);
    mod_ruby_setenv("MOD_RUBY", MOD_RUBY_STRING_VERSION);
    mod_ruby_setenv("GATEWAY_INTERFACE", RUBY_GATEWAY_INTERFACE);
}

d341 1
a341 1
static VALUE get_error_info(request_rec *r, int state)
d381 1
a381 1
static void print_error(request_rec *r, int state)
d393 1
a393 1
    errmsg = get_error_info(r, state);
d395 1
a395 1
    logmsg = STRING_LITERAL("mod_ruby:\n");
d405 1
a405 1
static void log_error(request_rec *r, int state)
d409 2
a410 3
    errmsg = get_error_info(r, state);
    ap_rputs(ap_escape_html(r->pool, STR2CSTR(errmsg)), r);
    logmsg = STRING_LITERAL("mod_ruby: error in ruby program\n");
d412 1
a412 1
    ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, r->server,
d416 171
d721 1
a721 1
	    log_error(r, state);
d732 1
a754 1
	rb_apache_request_flush(rb_request);
d758 1
a758 1
	log_error(r, state);
d912 1
a912 1
	    print_error(r, state);
@


1.43
log
@* mod_ruby.c (ruby_translate_handler): new handler.
* mod_ruby.c (ruby_authen_handler): ditto.
* mod_ruby.c (ruby_authen_handler): ditto.
* mod_ruby.c (ruby_authz_handler): ditto.
* mod_ruby.c (ruby_access_handler): ditto.
* mod_ruby.c (ruby_type_handler): ditto.
* mod_ruby.c (ruby_fixup_handler): ditto.
* mod_ruby.c (ruby_log_handler): ditto.
* mod_ruby.c (ruby_header_parser_handler): ditto.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.42 2001/06/09 09:50:28 shugo Exp $
d121 1
a121 1
static int ruby_translate_handler(request_rec*);
d152 1
a152 1
    ruby_translate_handler,	/* filename translation */
a185 7
#define get_server_config(s) \
	((ruby_server_config *) ap_get_module_config(s->module_config, \
						     &ruby_module))
#define get_dir_config(r) \
	((ruby_dir_config *) ap_get_module_config(r->per_dir_config, \
						  &ruby_module))

d715 1
a715 1
static VALUE ruby_request_handler_0(void *arg)
d728 8
a735 2
	log_error(r, state);
	return INT2NUM(SERVER_ERROR);
d748 1
a748 1
static int ruby_request_handler(request_rec *r, char *handler, ID mid)
d765 1
a765 1
			    ruby_request_handler_0, &arg, &ret)) == 0) {
d785 2
a786 2
    return ruby_request_handler(r, dconf->ruby_handler,
				rb_intern("handler"));
d789 1
a789 1
static int ruby_translate_handler(request_rec *r)
d794 2
a795 2
    return ruby_request_handler(r, dconf->ruby_trans_handler,
				rb_intern("translate_name"));
d801 1
d804 5
a808 2
    return ruby_request_handler(r, dconf->ruby_authen_handler,
				rb_intern("check_user_id"));
d816 2
a817 2
    return ruby_request_handler(r, dconf->ruby_authz_handler,
				rb_intern("check_auth"));
d825 2
a826 2
    return ruby_request_handler(r, dconf->ruby_access_handler,
				rb_intern("check_access"));
d834 2
a835 2
    return ruby_request_handler(r, dconf->ruby_type_handler,
				rb_intern("find_types"));
d843 2
a844 2
    return ruby_request_handler(r, dconf->ruby_fixup_handler,
				rb_intern("fixup"));
d852 2
a853 2
    return ruby_request_handler(r, dconf->ruby_log_handler,
				rb_intern("log_transaction"));
d861 2
a862 2
    return ruby_request_handler(r, dconf->ruby_header_parser_handler,
				rb_intern("header_parse"));
@


1.42
log
@* configure.rb.in: check for gcc.
* mod_ruby.c (ruby_object_handler_0): call log_error().
* lib/apache/eruby-run.rb (handler): set @@compiler.sourcefile.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.41 2001/06/08 09:57:00 shugo Exp $
a70 2
static ID id_handler;

d97 16
d121 8
d152 8
a159 8
    NULL,			/* filename translation */
    NULL,			/* check_user_id */
    NULL,			/* check auth */
    NULL,			/* check access */
    NULL,			/* type_checker */
    NULL,			/* fixups */
    NULL,			/* logger */
    NULL,			/* header parser */
d186 8
a193 1
typedef struct pcall_arg {
d198 1
a198 1
} pcall_arg_t;
d202 4
a205 4
    return rb_funcall2(((pcall_arg_t *) arg)->recv,
		       ((pcall_arg_t *) arg)->mid,
		       ((pcall_arg_t *) arg)->argc,
		       ((pcall_arg_t *) arg)->argv);
d212 1
a212 1
    struct pcall_arg arg;
d267 1
a267 3
    ruby_server_config *conf =
	(ruby_server_config *) ap_get_module_config(s->module_config,
						    &ruby_module);
a281 2
	id_handler = rb_intern("handler");

d404 2
a405 4
    ruby_server_config *sconf =
	(ruby_server_config *) ap_get_module_config(r->server->module_config,
						       &ruby_module);
    ruby_dir_config *dconf;
d412 1
a412 5
    if (r->per_dir_config) {
	dconf = (ruby_dir_config *) ap_get_module_config(r->per_dir_config,
							 &ruby_module);
	setenv_from_table(dconf->env);
    }
d689 1
a689 1
    ruby_dir_config *dconf = NULL;
d699 2
a700 6
    if (r->per_dir_config) {
	dconf = (ruby_dir_config *) ap_get_module_config(r->per_dir_config,
							 &ruby_module);
	if (dconf->kcode)
	    rb_set_kcode(dconf->kcode);
    }
d716 7
a722 1
static VALUE ruby_object_handler_0(void *arg)
d724 4
a727 2
    request_rec *r = (request_rec *) arg;
    ruby_dir_config *dconf = NULL;
a729 2
    char **list;
    int n, i;
d732 12
a743 17
    if (r->per_dir_config == NULL)
	return INT2NUM(DECLINED);
    dconf = (ruby_dir_config *) ap_get_module_config(r->per_dir_config,
						     &ruby_module);
    list = (char **) dconf->ruby_handlers->elts;
    n = dconf->ruby_handlers->nelts;
    retval = DECLINED;
    for (i = 0; i < n; i++) {
	ret = protect_funcall(rb_eval_string(list[i]), id_handler, &state,
			      1, rb_request);
	if (state) {
	    log_error(r, state);
	    return INT2NUM(SERVER_ERROR);
	}
	retval = NUM2INT(ret);
	if (retval != DECLINED)
	    break;
d745 1
d749 1
a749 1
static int ruby_object_handler(request_rec *r)
d751 3
a753 5
    ruby_server_config *sconf =
	(ruby_server_config *) ap_get_module_config(r->server->module_config,
						    &ruby_module);
    ruby_dir_config *dconf = NULL;
    int safe_level = 0;
d757 1
a757 6

    if (r->per_dir_config) {
	dconf = (ruby_dir_config *) ap_get_module_config(r->per_dir_config,
							 &ruby_module);
	safe_level = dconf->safe_level;
    }
d762 3
d766 1
a766 1
			    ruby_object_handler_0, r, &ret)) == 0) {
d781 81
d864 3
a866 4
    ruby_server_config *sconf =
	(ruby_server_config *) ap_get_module_config(r->server->module_config,
						    &ruby_module);
    ruby_dir_config *dconf = NULL;
a869 1
    int safe_level = 0;
a874 6

    if (r->per_dir_config) {
	dconf = (ruby_dir_config *) ap_get_module_config(r->per_dir_config,
							 &ruby_module);
	safe_level = dconf->safe_level;
    }
@


1.41
log
@* Makefile.in: libruby.a support.
* configure.rb.in: ditto.
* configure.rb: generated by autoconf.rb version 0.2.
* mod_ruby.c (get_exception_info): don't use str2cstr macro for
Ruby 1.7.
* mod_ruby.c (protect_funcall0): changed type of argument to
VALUE.
* mod_ruby.c (ruby_require): cast rb_require() to VALUE (*)(VALUE).
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.40 2001/06/06 08:54:33 shugo Exp $
d484 2
a485 2
	int i;
	struct RArray *ep = RARRAY(errat);
a490 1
	rb_ary_pop(errat);
d492 2
a493 1
	for (i=1; i<ep->len; i++) {
d499 1
a499 1
	    if (i == TRACE_HEAD && ep->len > TRACE_MAX) {
d502 1
a502 1
			 ep->len - TRACE_HEAD - TRACE_TAIL);
d504 1
a504 1
		i = ep->len - TRACE_TAIL;
d581 1
a581 1
    logmsg = STRING_LITERAL("mod_ruby:\n");
d709 1
d715 2
a716 2
    list = (char **) dconf->handlers->elts;
    n = dconf->handlers->nelts;
d719 6
a724 1
	ret = rb_funcall(rb_eval_string(list[i]), id_handler, 1, rb_request);
@


1.40
log
@* request.c (request_escape_html): add taint status infection.
* mod_ruby.c (ruby_object_handler): call rb_exec_end_proc().
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.39 2001/06/04 03:07:20 shugo Exp $
d164 1
a164 1
struct pcall_arg {
d169 1
a169 1
};
d171 1
a171 1
static VALUE protect_funcall0(struct pcall_arg *arg)
d173 4
a176 1
    return rb_funcall2(arg->recv, arg->mid, arg->argc, arg->argv);
d215 1
a215 1
    rb_protect(rb_require, (VALUE) filename, &state);
d445 2
a446 1
	einfo = str2cstr(estr, &elen);
@


1.39
log
@* lib/auto-reload: new file.
* lib/apache/ruby-run.rb: renamed from ruby/apache/ruby.rb.
* lib/apache/eruby-run.rb: renamed from ruby/apache/eruby.rb.
* lib/apache/rd2html.rb: renamed from ruby/apache/rd2html.rb.
* lib/apache/eruby-run.rb (handler): specify filename for backtrace.
* changed license from GPL to LGPL.
* COPYING: new file.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.38 2001/05/29 01:15:20 shugo Exp $
d691 6
d751 1
@


1.38
log
@* mod_ruby.c: don't include config.h.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.37 2001/05/28 08:35:27 shugo Exp $
d11 4
a14 4
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
d18 2
a19 2
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
d21 4
a24 4
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA
d844 1
a844 1
    eruby_load(r->filename, 1, &state);
d848 1
a848 1
	script = eruby_load(r->filename, 1, &state);
@


1.37
log
@* mod_ruby.c: hack for cygwin.
* configure.rb.in: ditto.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.36 2001/05/28 02:36:09 shugo Exp $
a56 1
#include "config.h"
d650 1
a650 1
#if defined(HAVE_SETITIMER) && !defined(__CYGWIN__)
d656 1
a656 1
#if defined(HAVE_SETITIMER) && !defined(__CYGWIN__)
@


1.36
log
@* mod_ruby.c (ruby_startup): don't initialize ruby if
ruby_running(). (for static Apache module)
* mod_ruby.c: use EXTERN.
* libruby.module.in: use MODULE_LIBS to expand LIBRUBYARG.
* configure.rb.in: set $ERUBY_INCLUDES instead of modify $CFLAGS.
* Makefile.in: RUBY_SO_NAME for cygwin.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.35 2001/05/02 08:45:26 shugo Exp $
d334 1
d348 1
d651 1
a651 1
#if defined(HAVE_SETITIMER)
d657 1
a657 1
#if defined(HAVE_SETITIMER)
@


1.35
log
@* fixed copyright notice.
* array_header.c: new file for Apache::ArrayHeader.
* server.c: added some methods.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.34 2001/04/27 04:51:59 shugo Exp $
d59 1
d62 1
d64 4
a67 4
extern VALUE ruby_errinfo;
extern VALUE rb_defout;
extern VALUE rb_stdin;
extern VALUE rb_stdout;
d69 1
a69 1
extern VALUE rb_load_path;
d225 1
a225 1
    extern VALUE ruby_dln_librefs;
d246 3
a248 2
    ruby_init();
    rb_init_apache();
d250 1
a250 1
    eruby_init();
d253 32
a284 1
    id_handler = rb_intern("handler");
a301 28

    rb_define_global_const("MOD_RUBY",
			   STRING_LITERAL(MOD_RUBY_STRING_VERSION));

    origenviron = environ;

    ruby_init_loadpath();
    default_load_path = rb_load_path;
    rb_global_variable(&default_load_path);
    list = (char **) conf->load_path->elts;
    n = conf->load_path->nelts;
    for (i = 0; i < n; i++) {
	ruby_add_path(list[i]);
    }

    default_kcode = rb_get_kcode();

    list = (char **) conf->required_files->elts;
    n = conf->required_files->nelts;
    for (i = 0; i < n; i++) {
	if (ruby_require(list[i])) {
	    fprintf(stderr, "Require of Ruby file `%s' failed, exiting...\n", 
		    list[i]);
	    exit(1);
	}
    }

    ruby_is_running = 1;
@


1.34
log
@* ruby/apache/ruby.rb (emulate_cgi): new method.
* ruby/apache/eruby.rb: inherit Apache::Ruby.
* table.c: new file for Apache::Table.
* connection.c: new file for Apache::Connection.
* server.c: new file for Apache::Server.
* request.c: new file for Apache::Request.
* request.c (request_setup_cgi_env): new method.
* mod_ruby.c (script_handler): resotre original $stdin, $stdout
and $>.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.33 2001/04/20 04:08:56 shugo Exp $
d5 1
@


1.33
log
@* apachelib.c (request_finfo): new method Apache::Request#finfo.
* mod_ruby.c (load_eruby_script): supports eruby-0.9.0.
* ruby/apache/eruby.rb: new handler Apache::ERuby.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.32 2001/04/19 06:13:25 shugo Exp $
d64 1
d244 1
a244 1
    ruby_init_apachelib();
d366 1
a366 1
static void setup_env(request_rec *r, ruby_dir_config *dconf)
d370 2
a371 1
						    &ruby_module);
d378 5
a382 1
    if (dconf) setenv_from_table(dconf->env);
d674 1
a674 6
    rb_defout = ruby_request_new(r);
    rb_gv_set("$stdin", rb_defout);
    rb_gv_set("$stdout", rb_defout);
    setup_env(r, dconf);
    if (r->filename)
	ap_chdir_file(r->filename);
d679 1
d700 1
a700 1
	ret = rb_funcall(rb_eval_string(list[i]), id_handler, 1, rb_defout);
d730 1
a730 1
	rb_request_flush(rb_defout);
d750 1
d766 1
d768 10
d786 4
d791 1
d817 1
a817 1
    rb_request_flush(rb_defout);
d859 1
a859 1
	long len = ruby_request_outbuf_length(rb_defout);
d867 1
a867 1
	rb_request_send_http_header(rb_defout);
d869 1
a869 1
    rb_request_flush(rb_defout);
@


1.32
log
@* ruby/apache/ruby.rb: new handler Apache::Ruby.
* ruby/apache/rd2html.rb: renamed from mod_rd2html.rb.
* apachelib.c (request_read): do not use buffer.
* apachelib.c (ruby_init_apachelib): remove methods from
Apache::request. (gets, readline, readlines, each, getc,
readchar, ungetc, tell, seek, rewind, pos, pos=)
* apachelib.c (ruby_init_apachelib): new class Apache::Server.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.31 2001/04/13 04:19:40 shugo Exp $
d218 1
a218 1
#if RUBY_VERSION_CODE >= 164
a810 1
    VALUE script;
d816 9
a824 2
    script = eruby_load(r->filename, 1, &state);
    if (!NIL_P(script)) unlink(STR2CSTR(script));
@


1.31
log
@* version 0.8.0 released.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.30 2001/04/12 09:08:34 shugo Exp $
d6 1
a6 1
 * Author: Shugo Maeda <shugo@@ruby-lang.org>
d68 2
d76 1
a76 1
static int exit_status;
d218 2
a219 1
static VALUE f_p(int argc, VALUE *argv, VALUE self)
d221 1
d224 2
a225 3
    for (i = 0; i < argc; i++) {
	rb_io_write(rb_defout, rb_inspect(argv[i]));
	rb_io_write(rb_defout, rb_default_rs);
a226 18
    return Qnil;
}

static VALUE f_exit(int argc, VALUE *argv, VALUE obj)
{
    VALUE status;

    rb_secure(4);
    if (rb_scan_args(argc, argv, "01", &status) == 1) {
	exit_status = NUM2INT(status);
	if (exit_status < 0)
	    rb_raise(rb_eArgError, "negative status code %d", exit_status);
    }
    else {
	exit_status = OK;
    }
    rb_exc_raise(rb_exc_new(rb_eSystemExit, 0, 0));
    return Qnil;		/* not reached */
d228 1
a242 2
    rb_define_global_function("p", f_p, -1);
    rb_define_global_function("exit", f_exit, -1);
d248 2
d294 5
a568 19
static int get_client_block(request_rec *r, VALUE *str)
{
    int retval;
    char buff[BUFSIZ];
    int len;

    if ((retval = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR)))
	return retval;
    *str = rb_tainted_str_new("", 0);
    ap_hard_timeout("get_client_block", r);
    if (ap_should_client_block(r)) {
	while ((len = ap_get_client_block(r, buff, BUFSIZ)) > 0) {
	    rb_str_cat(*str, buff, len);
	}
    }
    ap_kill_timeout(r);
    return 0;
}

d603 3
a605 2
    request_rec *req;
    VALUE (*func)(request_rec*, void*);
d609 1
a609 1
static VALUE run_safely_0(run_safely_arg_t *arg)
d611 1
a611 4
    ruby_server_config *sconf =
	(ruby_server_config *) ap_get_module_config(arg->req->server->module_config,
						    &ruby_module);
    ruby_dir_config *dconf;
d616 1
a616 5
    if (arg->req->per_dir_config) {
	dconf = (ruby_dir_config *) ap_get_module_config(arg->req->per_dir_config,
							 &ruby_module);
	rb_set_safe_level(dconf->safe_level);
    }
d618 1
a618 1
    targ.timeout = sconf->timeout;
d620 1
a620 1
    result = (*arg->func)(arg->req, arg->arg);
d625 2
a626 1
static int run_safely(request_rec *r, VALUE (*func)(), void *arg, VALUE *retval)
d632 2
a633 1
    rsarg.req = r;
a646 2
    if (state)
	log_error(r, state);
d652 1
d663 2
a664 3
	ruby_dir_config *dconf =
	    (ruby_dir_config *) ap_get_module_config(r->per_dir_config,
						     &ruby_module);
d668 6
d681 1
a681 1
static VALUE ruby_object_handler_0(request_rec *r, void *arg)
d683 1
a686 1
    ID id_handler = rb_intern("handler");
a691 1
    per_request_init(r);
d694 2
a695 2
    list = (char **) dconf->handler_objects->elts;
    n = dconf->handler_objects->nelts;
a702 1
    per_request_cleanup();
d708 5
d714 2
a715 1
    VALUE input, ret;
d717 5
a721 5
    if ((retval = get_client_block(r, &input)))
	return retval;
    rb_defout = ruby_create_request(r, input);
    rb_gv_set("$stdin", rb_defout);
    rb_gv_set("$stdout", rb_defout);
d724 1
d726 2
a727 1
    if (run_safely(r, ruby_object_handler_0, NULL, &ret) == 0) {
d732 1
d736 1
d741 1
a741 1
static int script_handler(VALUE (*func)(request_rec*, void*), request_rec *r)
d743 3
d747 1
a747 1
    VALUE input;
d749 1
d756 5
a760 9
    if ((retval = get_client_block(r, &input)))
	return retval;
    rb_defout = ruby_create_request(r, input);
    rb_gv_set("$stdin", rb_defout);
    rb_gv_set("$stdout", rb_defout);

    setup_env(r, dconf);
    exit_status = -1;
    ap_chdir_file(r->filename);
d763 1
d765 2
a766 7
    if (run_safely(r, func, NULL, NULL) == 0) {
	if (exit_status < 0) {
	    retval = OK;
	}
	else {
	    retval = exit_status;
	}
d772 1
d777 1
a777 1
static VALUE load_ruby_script(request_rec *r, void *arg)
d779 1
d781 1
d785 9
a793 2
    if (state && !rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
	print_error(r, state);
d796 1
a796 1
	rb_request_flush(rb_defout);
d798 2
a799 1
    return Qnil;
d808 1
a808 1
static VALUE load_eruby_script(request_rec *r, void *arg)
d810 1
d813 1
d820 9
a828 2
    if (state && !rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
	print_error(r, state);
d831 9
a839 10
	if (!eruby_noheader) {
	    long len = ruby_request_outbuf_length(rb_defout);

	    if (strcmp(r->content_type, "text/html") == 0) {
		r->content_type = ap_psprintf(r->pool,
					      "text/html; charset=%s",
					      ERUBY_CHARSET);
	    }
	    ap_set_content_length(r, len);
	    rb_request_send_http_header(rb_defout);
d841 2
a842 1
	rb_request_flush(rb_defout);
d844 2
a845 1
    return Qnil;
@


1.30
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.29 2001/04/10 09:12:22 shugo Exp $
d836 1
a836 1
	    int len = ruby_request_outbuf_length(rb_defout);
d843 1
a843 2
	    ap_table_set(r->headers_out, "Content-Length",
			 ap_psprintf(r->pool, "%d", len));
@


1.29
log
@* mod_ruby.c (run_safely_0): call ruby_log_error() on error.
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.28 2001/04/10 08:03:55 shugo Exp $
d90 1
a90 1
    {"RubySafeLevel", ruby_cmd_safe_level, NULL, RSRC_CONF, TAKE1,
d97 1
a97 1
static int ruby_handler(request_rec*);
d99 1
a99 1
static int eruby_handler(request_rec*);
d105 2
a106 1
    {"ruby-script", ruby_handler},
d108 1
a108 1
    {ERUBY_MIME_TYPE, eruby_handler},
a109 1
    {"ruby-object", ruby_object_handler},
d310 1
a310 1
static void mr_clearenv()
d350 1
a350 1
static void mr_setenv(const char *name, const char *value)
d370 1
a370 1
	mr_setenv(env[i].key, env[i].val);
d380 1
a380 1
    mr_clearenv();
d386 2
a387 2
    mr_setenv("MOD_RUBY", MOD_RUBY_STRING_VERSION);
    mr_setenv("GATEWAY_INTERFACE", RUBY_GATEWAY_INTERFACE);
d542 1
a542 1
static void ruby_error_print(request_rec *r, int state)
d566 1
a566 1
static void ruby_log_error(request_rec *r, int state)
a612 60
static VALUE load_ruby_script(request_rec *r)
{
    ruby_server_config *sconf =
	(ruby_server_config *) ap_get_module_config(r->server->module_config,
						    &ruby_module);
    int state;
    request_data *data;

    rb_set_safe_level(sconf->safe);
    rb_load_protect(rb_str_new2(r->filename), 1, &state);
    rb_exec_end_proc();
    if (state && !rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
	Data_Get_Struct(rb_defout, request_data, data);
	ruby_error_print(r, state);
    }
    else {
	rb_request_flush(rb_defout);
    }
    return Qnil;
}

#ifdef USE_ERUBY
static VALUE load_eruby_script(request_rec *r)
{
    ruby_server_config *sconf =
	(ruby_server_config *) ap_get_module_config(r->server->module_config,
						    &ruby_module);
    VALUE script;
    int state;
    request_data *data;

    rb_set_safe_level(sconf->safe);
    eruby_noheader = 0;
    eruby_charset = eruby_default_charset;
    script = eruby_load(r->filename, 1, &state);
    if (!NIL_P(script)) unlink(STR2CSTR(script));
    rb_exec_end_proc();
    if (state && !rb_obj_is_kind_of(ruby_errinfo, rb_eSystemExit)) {
	Data_Get_Struct(rb_defout, request_data, data);
	ruby_error_print(r, state);
    }
    else {
	if (!eruby_noheader) {
	    int len = ruby_request_outbuf_length(rb_defout);

	    if (strcmp(r->content_type, "text/html") == 0) {
		r->content_type = ap_psprintf(r->pool,
					      "text/html; charset=%s",
					      ERUBY_CHARSET);
	    }
	    ap_table_set(r->headers_out, "Content-Length",
			 ap_psprintf(r->pool, "%d", len));
	    rb_request_send_http_header(rb_defout);
	}
	rb_request_flush(rb_defout);
    }
    return Qnil;
}
#endif

a629 82
static int ruby_handler0(VALUE (*load)(request_rec*), request_rec *r)
{
    ruby_server_config *sconf =
	(ruby_server_config *) ap_get_module_config(r->server->module_config,
						    &ruby_module);
    ruby_dir_config *dconf = NULL;
    VALUE input;
    VALUE load_thread, timeout_thread;
    struct timeout_arg arg;
    int retval;
    const char *kcode_orig = NULL;
    long i;

    (void) ap_acquire_mutex(mod_ruby_mutex);

    if (r->finfo.st_mode == 0)
	return NOT_FOUND;
    if (S_ISDIR(r->finfo.st_mode))
	return FORBIDDEN;

    if (r->per_dir_config) {
	dconf = (ruby_dir_config *) ap_get_module_config(r->per_dir_config,
							 &ruby_module);
	if (dconf->kcode) {
	    kcode_orig = rb_get_kcode();
	    rb_set_kcode(dconf->kcode);
	}
    }

    if ((retval = get_client_block(r, &input)))
	return retval;

    ap_chdir_file(r->filename);
    setup_env(r, dconf);
    rb_load_path = rb_ary_new();
    for (i = 0; i < RARRAY(default_load_path)->len; i++) {
	rb_ary_push(rb_load_path, rb_str_dup(RARRAY(default_load_path)->ptr[i]));
    }
    exit_status = -1;

    rb_defout = ruby_create_request(r, input);
    rb_gv_set("$stdin", rb_defout);
    rb_gv_set("$stdout", rb_defout);
    ruby_errinfo = Qnil;
    ruby_debug = Qfalse;
    ruby_verbose = Qfalse;

    ap_soft_timeout("load ruby script", r);
    load_thread = rb_thread_create(load, r);
    arg.thread = load_thread;
    arg.timeout = sconf->timeout;
    timeout_thread = rb_thread_create(do_timeout, (void *) &arg);
    protect_funcall(load_thread, rb_intern("join"), NULL, 0);
    rb_protect(kill_threads, Qnil, NULL);
    ap_kill_timeout(r);

    if (kcode_orig) rb_set_kcode(kcode_orig);
    (void) ap_release_mutex(mod_ruby_mutex);

    load_thread = Qnil;
    rb_gc();

    if (exit_status < 0) {
	return OK;
    }
    else {
	return exit_status;
    }
}

static int ruby_handler(request_rec *r)
{
    return ruby_handler0(load_ruby_script, r);
}

#ifdef USE_ERUBY
static int eruby_handler(request_rec *r)
{
    return ruby_handler0(load_eruby_script, r);
}
#endif

d641 1
d646 5
a650 1
    rb_set_safe_level(sconf->safe);
d668 3
d673 4
d680 1
a680 1
	ruby_log_error(r, state);
d684 1
a684 1
static void initialize_ruby_env(request_rec *r)
d704 1
a704 1
static void finalize_ruby_env()
d720 1
a720 1
    initialize_ruby_env(r);
d732 1
a732 1
    finalize_ruby_env();
d738 8
a745 2
    int result;
    VALUE input, retval;
d748 24
d778 5
d784 7
a790 3
    if (run_safely(r, ruby_object_handler_0, NULL, &retval) == 0) {
	rb_request_flush(rb_defout);
	return NUM2INT(retval);
d793 1
a793 1
	result = SERVER_ERROR;
d797 58
a854 1
    return result;
d856 1
@


1.28
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.27 2000/12/12 05:41:07 shugo Exp $
d502 1
a502 1
static void ruby_error_print(request_rec *r, int state)
d505 1
a505 9
    VALUE errmsg, logmsg;

    r->content_type = "text/html";
    ap_send_http_header(r);
    ap_rputs("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\">\n", r);
    ap_rputs("<html>\n", r);
    ap_rputs("<head><title>Error</title></head>\n", r);
    ap_rputs("<body>\n", r);
    ap_rputs("<pre>\n", r);
d539 16
d556 1
a556 1
    logmsg = STRING_LITERAL("ruby script error\n");
d566 12
d809 2
d868 1
a868 1
    int state;
d879 3
a881 5
    state = run_safely(r, ruby_object_handler_0, NULL, &retval);
    ap_kill_timeout(r);
    (void) ap_release_mutex(mod_ruby_mutex);
    if (state) {
	return SERVER_ERROR;
d884 1
a884 2
	rb_request_flush(rb_defout);
	return NUM2INT(retval);
d886 3
@


1.27
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.26 2000/12/06 05:37:08 shugo Exp $
d66 3
a68 1
static VALUE orig_load_path;
d80 2
d92 2
d101 1
d109 1
d211 5
d287 9
a295 2
    orig_load_path = rb_load_path;
    rb_global_variable(&orig_load_path);
d558 19
d653 1
a653 1
struct timeout_arg {
d656 1
a656 1
};
d676 1
d690 1
a690 1
    if(r->per_dir_config) {
d699 1
a699 1
    if ((retval = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR)))
d705 2
a706 2
    for (i = 0; i < RARRAY(orig_load_path)->len; i++) {
	rb_ary_push(rb_load_path, rb_str_dup(RARRAY(orig_load_path)->ptr[i]));
d710 1
a710 1
    rb_defout = ruby_create_request(r);
d751 117
@


1.26
log
@shugo

* intern.h: added prototype of rb_exec_end_proc()
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.25 2000/11/23 09:25:06 shugo Exp $
d237 1
a237 1
    int i;
d278 2
a279 1
    for (i = 0; i < conf->required_files->nelts; i++) {
@


1.25
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.24 2000/10/16 05:41:34 shugo Exp $
a235 1
    static char ruby_version[BUFSIZ];
a238 6
#if MODULE_MAGIC_NUMBER >= 19980507
    ap_add_version_component(MOD_RUBY_STRING_VERSION);
    snprintf(ruby_version, BUFSIZ, "Ruby/%s(%s)", RUBY_VERSION, RUBY_RELEASE_DATE);
    ap_add_version_component(ruby_version);
#endif

d251 17
a272 1
#if RUBY_VERSION_CODE >= 160
a273 5
#else
#if RUBY_VERSION_CODE >= 145
    rb_ary_push(rb_load_path, rb_str_new2("."));
#endif
#endif
a493 10
#if 0
    {
	int pid;
	pid = getpid();
	ap_rprintf(r, "pid: %d\n", pid);
	ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, r->server,
		     "pid: %d\n", pid);
    }
#endif

a562 1
#if defined(RUBY_RELEASE_CODE) && RUBY_RELEASE_CODE >= 19990601
a563 1
#endif
a588 1
#if defined(RUBY_RELEASE_CODE) && RUBY_RELEASE_CODE >= 19990601
a589 1
#endif
@


1.24
log
@shugo
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.23 2000/10/14 14:55:41 shugo Exp $
d86 2
a262 9
    list = (char **) conf->required_files->elts;
    for (i = 0; i < conf->required_files->nelts; i++) {
	if (ruby_require(list[i])) {
	    fprintf(stderr, "Require of Ruby file `%s' failed, exiting...\n", 
		    list[i]);
	    exit(1);
	}
    }

d273 8
a280 1
    rb_set_safe_level(1);
d561 3
d567 1
d585 3
d592 1
@


1.23
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.22 2000/10/14 04:27:56 shugo Exp $
d489 10
@


1.22
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.21 2000/10/04 15:38:46 shugo Exp $
d26 1
d149 13
a161 1
int ruby_running()
d163 23
a185 1
    return ruby_is_running;
d188 1
a188 1
static VALUE ruby_require0(VALUE fname)
d190 1
a190 2
    rb_f_require(Qnil, fname);
    return Qnil;
a194 1
    VALUE fname = rb_str_new2(filename);
d197 1
a197 1
    rb_protect(ruby_require0, fname, &state);
d443 1
a443 1
		rb_str_cat(str, tail, RSTRING(einfo)->len - len - 1);
a532 11
static VALUE thread_kill(VALUE thread)
{
    rb_funcall(thread, rb_intern("exit"), 0);
    return Qnil;
}

static VALUE thread_join(VALUE thread)
{
    return rb_funcall(thread, rb_intern("join"), 0);
}

d537 1
a537 1
    VALUE current = rb_thread_current();
d543 2
a544 2
	if (th != current)
	    rb_protect(thread_kill, th, NULL);
d673 1
a673 1
    rb_protect(thread_join, load_thread, NULL);
@


1.21
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.20 2000/09/11 06:56:34 shugo Exp $
a203 2
    long j;
    int state;
d353 4
a356 1
    VALUE einfo;
d373 9
a381 2
    einfo = rb_obj_as_string(ruby_errinfo);
    if (eclass == rb_eRuntimeError && RSTRING(einfo)->len == 0) {
d388 1
a388 1
	if (RSTRING(einfo)->len == 0) {
d395 1
a395 1
	    int len = RSTRING(einfo)->len;
d398 2
a399 2
	    if ((tail = strchr(RSTRING(einfo)->ptr, '\n')) != NULL) {
		len = tail - RSTRING(einfo)->ptr;
d403 1
a403 1
	    rb_str_cat(str, RSTRING(einfo)->ptr, len);
d489 1
a489 1
    ap_rputs(ap_escape_html(r->pool, RSTRING(errmsg)->ptr), r);
d493 1
a493 1
		 "%s", RSTRING(logmsg)->ptr);
a499 91
static VALUE stdin_reopen(VALUE io)
{
    rb_funcall(rb_stdin, rb_intern("reopen"), 1, io);
    return rb_stdin;
}

struct wcb_arg {
    request_rec *r;
    FILE *fp;
};

static VALUE write_client_block0(struct wcb_arg *arg)
{
    request_rec *r = arg->r;
    FILE *fp = arg->fp;
#define BUFF_LEN 256
    char buff[BUFF_LEN];
    int len;
#ifdef SIGPIPE
    void (*handler) (int);
#endif

    ap_hard_timeout("write script args", arg->r);
#ifdef SIGPIPE
    handler = signal(SIGPIPE, SIG_IGN);
#endif
    while ((len = ap_get_client_block(r, buff, BUFF_LEN)) > 0) {
	ap_reset_timeout(r);
	rb_thread_fd_writable(fileno(fp));
	if (fwrite(buff, 1, len, fp) == EOF)
	    break;
    }
#ifdef SIGPIPE
    signal(SIGPIPE, handler);
#endif
    ap_kill_timeout(r);
    fclose(fp);
    return Qnil;
}

static int write_client_block(request_rec *r, VALUE *thread)
{
    struct wcb_arg arg;
    int state;
    int pipes[2];
    FILE *file;
    OpenFile *fp;
    NEWOBJ(io, struct RFile);
    OBJSETUP(io, rb_cIO, T_FILE);

#ifdef NT
    if (_pipe(pipes, 1024, O_BINARY) == -1)
#else
    if (pipe(pipes) == -1)
#endif
	return -1;
    if ((file = fdopen(pipes[1], "w")) == NULL)
	return -1;
    MakeOpenFile(io, fp);
    if ((fp->f = fdopen(pipes[0], "r")) == NULL)
	return -1;
    fp->mode = FMODE_READABLE;
    rb_protect(stdin_reopen, (VALUE) io, &state);
    if (state) {
	fclose(file);
	rb_protect(rb_io_close, (VALUE) io, &state);
	return -1;
    }
    arg.r = r;
    arg.fp = file;
    *thread = rb_thread_create(write_client_block0, &arg);
    return 0;
}

struct to_arg {
    VALUE thread;
    int timeout;
};

static VALUE do_timeout(struct to_arg *arg)
{
    char buff[BUFSIZ];
    VALUE err;

    rb_thread_sleep(arg->timeout);
    snprintf(buff, BUFSIZ, "timeout (%d sec)", arg->timeout);
    err = rb_exc_new2(rb_eApacheTimeoutError, buff);
    rb_funcall(arg->thread, rb_intern("raise"), 1, err);
    return Qnil;
}

d513 1
a528 5
    ruby_server_config *sconf =
	(ruby_server_config *) ap_get_module_config(r->server->module_config,
						    &ruby_module);
    VALUE orig_defout = rb_defout;
    VALUE timeout_thread;
a530 1
    struct to_arg arg;
a531 5
    rb_defout = ruby_create_request(r);
    arg.thread = rb_thread_current();
    arg.timeout = sconf->timeout;
    timeout_thread = rb_thread_create(do_timeout, (void *) &arg);
    ruby_errinfo = Qnil;
a532 1
    rb_protect(thread_kill, timeout_thread, NULL);
a542 1
    rb_defout = orig_defout;
a548 5
    ruby_server_config *sconf =
	(ruby_server_config *) ap_get_module_config(r->server->module_config,
						    &ruby_module);
    VALUE orig_defout = rb_defout;
    VALUE timeout_thread;
a551 1
    struct to_arg arg;
a552 1
    rb_defout = ruby_create_request(r);
a554 4
    arg.thread = rb_thread_current();
    arg.timeout = sconf->timeout;
    timeout_thread = rb_thread_create(do_timeout, (void *) &arg);
    ruby_errinfo = Qnil;
d556 1
a556 2
    if (!NIL_P(script)) unlink(RSTRING(script)->ptr);
    rb_protect(thread_kill, timeout_thread, NULL);
d566 1
a566 1
	    int len = ruby_request_buffer_length(rb_defout);
a578 1
    rb_defout = orig_defout;
d583 6
a588 1
static VALUE open_null(VALUE arg)
d590 8
a597 1
    return rb_funcall(rb_cFile, rb_intern("open"), 1, rb_str_new2("/dev/null"));
d602 3
a604 2
    VALUE wcb_thread = Qnil;
    VALUE load_thread;
d606 2
a610 1
    int state;
a630 11
    if (ap_should_client_block(r)) {
	if (write_client_block(r, &wcb_thread) == -1)
	    return SERVER_ERROR;
    }
    else {
	VALUE file = rb_protect(open_null, Qnil, &state);
	rb_protect(stdin_reopen, (VALUE) file, &state);
	if (state)
	    return SERVER_ERROR;
    }

d639 7
d648 3
@


1.20
log
@*** empty log message ***
@
text
@d2 5
a6 2
 * $Id: mod_ruby.c,v 1.19 2000/09/06 10:03:38 shugo Exp $
 * Copyright (C) 1998-1999  Network Applied Communication Laboratory, Inc.
d594 15
d747 1
a747 2
    if (wcb_thread != Qnil)
	rb_protect(thread_kill, wcb_thread, NULL);
@


1.19
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.18 2000/08/31 02:50:47 shugo Exp $
a214 1
    rb_set_safe_level(1);
d236 3
d242 1
d245 2
@


1.18
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.17 2000/08/03 07:29:41 shugo Exp $
d633 1
a633 1
    eruby_charset = rb_str_new2(ERUBY_DEFAULT_CHARSET);
@


1.17
log
@q
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.16 2000/08/02 07:01:45 shugo Exp $
d49 1
d51 1
d86 1
d88 1
d93 1
d95 1
d219 1
d221 1
d618 1
d666 1
d747 1
d752 1
@


1.16
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.15 2000/08/02 06:12:33 shugo Exp $
d643 1
a643 1
	    if (r->content_type == NULL) {
@


1.15
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.14 2000/08/02 05:14:55 shugo Exp $
d229 1
d231 1
@


1.14
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.13 2000/08/01 00:56:57 shugo Exp $
d59 3
a193 1
    char *rubylib;
d195 1
a218 2
    if ((rubylib = getenv("RUBYLIB")) != NULL)
	ap_table_set(conf->env, "RUBYLIB", rubylib);
d229 4
d668 1
d703 4
@


1.13
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.12 2000/07/13 03:31:05 shugo Exp $
a64 2
static VALUE wcb_thread;

a227 2
    rb_global_variable(&wcb_thread);

d658 1
a683 1
    wcb_thread = Qnil;
@


1.12
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.11 2000/07/11 04:37:37 shugo Exp $
d65 2
d230 2
d640 5
a644 3
	    r->content_type = ap_psprintf(r->pool,
					  "text/html; charset=%s",
					  ERUBY_CHARSET);
a661 1
    VALUE wcb_thread = Qnil;
d687 1
@


1.11
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.10 2000/06/26 01:19:37 shugo Exp $
a57 1
static VALUE rb_origstdin;
a183 5
static VALUE io_clone(VALUE io)
{
    return rb_funcall(io, rb_intern("clone"), 0);
}

a227 6
    rb_origstdin = rb_protect(io_clone, (VALUE) rb_stdin, &state);
    if (state) {
	fprintf(stderr, "Can't close $stdin, exiting...\n");
	exit(1);
    }

d649 5
d687 2
a688 1
	rb_protect(stdin_reopen, (VALUE) rb_origstdin, &state);
@


1.10
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.9 2000/05/24 04:59:00 shugo Exp $
d663 1
a663 1
    volatile VALUE wcb_thread = Qnil;
@


1.9
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.8 2000/05/18 08:09:42 shugo Exp $
d58 1
d185 5
d199 1
d234 6
d663 1
a663 1
    VALUE wcb_thread = Qnil;
d668 1
d691 5
@


1.8
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.7 2000/03/30 07:35:33 shugo Exp $
d412 1
a412 1
static void ruby_error_print(request_rec *r, int state, int sync)
d417 6
a422 8
    if (!sync) {
	r->content_type = "text/html";
	ap_send_http_header(r);
	ap_rputs("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\">\n", r);
	ap_rputs("<html>\n", r);
	ap_rputs("<head><title>Error</title></head>\n", r);
	ap_rputs("<body>\n", r);
    }
d464 2
a465 4
    if (!sync) {
	ap_rputs("</body>\n", r);
	ap_rputs("</html>\n", r);
    }
d581 1
a581 1
    rb_defout = ruby_create_request(r, 1);
d593 1
a593 1
	ruby_error_print(r, state, data->sync);
d614 2
a615 1
    rb_defout = ruby_create_request(r, 0);
d629 1
a629 1
	ruby_error_print(r, state, data->sync);
d640 1
a640 1
	    ap_send_http_header(r);
@


1.7
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.6 2000/03/28 05:41:57 shugo Exp $
d50 1
a605 15
static char *get_charset()
{
    switch (rb_kcode()) {
    case MBCTYPE_EUC:
	return "EUC-JP";
    case MBCTYPE_SJIS:
	return "SHIFT_JIS";
    case MBCTYPE_UTF8:
	return "UTF-8";
    case MBCTYPE_ASCII:
    default:
	return "US-ASCII";
    }
}

d619 1
a619 1
    r->content_type = ap_psprintf(r->pool, "text/html; charset=%s", get_charset());
d638 3
@


1.6
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.5 1999/07/26 01:31:18 shugo Exp $
d190 1
d214 2
a215 2
    ap_table_set(conf->env, "PATH", getenv("PATH"));
    ap_table_set(conf->env, "RUBYLIB", getenv("RUBYLIB"));
a297 1
    char server_port[BUFSIZ];
d300 3
a306 69
    mr_setenv("HTTP_USER_AGENT", ap_table_get(r->headers_in, "User-Agent"));
    mr_setenv("HTTP_REFERER", ap_table_get(r->headers_in, "Referer"));
    mr_setenv("HTTP_COOKIE", ap_table_get(r->headers_in, "Cookie"));
    mr_setenv("HTTP_FORWARDED", ap_table_get(r->headers_in, "Forwarded"));
    mr_setenv("HTTP_HOST", ap_table_get(r->headers_in, "Host"));
    mr_setenv("HTTP_CONNECTION", ap_table_get(r->headers_in, "Connection"));
    mr_setenv("HTTP_PROXY_CONNECTION",
	      ap_table_get(r->headers_in, "Proxy-Connection"));
    mr_setenv("HTTP_ACCEPT", ap_table_get(r->headers_in, "Accept"));
    mr_setenv("CONTENT_TYPE", ap_table_get(r->headers_in, "Content-Type"));
    mr_setenv("CONTENT_LENGTH", ap_table_get(r->headers_in, "Content-Length"));
    mr_setenv("REMOTE_ADDR", r->connection->remote_ip);
    mr_setenv("REMOTE_HOST",
	      ap_get_remote_host(r->connection, r->per_dir_config, REMOTE_NAME));
    mr_setenv("REMOTE_USER", r->connection->user);
    mr_setenv("REMOTE_IDENT", ap_get_remote_logname(r));
    mr_setenv("REQUEST_METHOD", r->method);
    mr_setenv("SCRIPT_FILENAME", r->filename);
    mr_setenv("REQUEST_FILENAME", r->filename);
    mr_setenv("REQUEST_URI", r->uri);
    if (!strcmp(r->protocol, "INCLUDED")) {
	mr_setenv("SCRIPT_NAME", r->uri);
	mr_setenv("PATH_INFO", r->path_info);
    }
    else if (!r->path_info || !*r->path_info) {
	mr_setenv("SCRIPT_NAME", r->uri);
	ruby_unsetenv("PATH_INFO");
    }
    else {
	int path_info_start = ap_find_path_info(r->uri, r->path_info);

	mr_setenv("SCRIPT_NAME", ap_pstrndup(r->pool, r->uri, path_info_start));
	mr_setenv("PATH_INFO", r->path_info);
    }
    if (r->path_info && *r->path_info) {
#ifdef ap_escape_uri
	request_rec *pa_req =
	    ap_sub_req_lookup_uri(ap_escape_uri(r->pool, r->path_info), r);
#else
	request_rec *pa_req =
	    ap_sub_req_lookup_uri(escape_uri(r->pool, r->path_info), r);
#endif	

	if (pa_req->filename) {
	    char *pt = ap_pstrcat(r->pool, pa_req->filename, pa_req->path_info,
				  NULL);
#ifdef WIN32
	    char buffer[HUGE_STRING_LEN];
	    /* We need to make this a real Windows path name */
	    GetFullPathName(pt, HUGE_STRING_LEN, buffer, NULL);
	    mr_setenv("PATH_TRANSLATED", ap_pstrdup(r->pool, buffer));
#else
	    mr_setenv("PATH_TRANSLATED", pt);
#endif
	}
	ap_destroy_sub_req(pa_req);
    }
    else {
	ruby_unsetenv("PATH_TRANSLATED");
    }
    mr_setenv("QUERY_STRING", r->args);
    mr_setenv("AUTH_TYPE", r->connection->ap_auth_type);
    mr_setenv("DOCUMENT_ROOT", ap_document_root(r));
    mr_setenv("SERVER_ADMIN", r->server->server_admin);
    mr_setenv("SERVER_NAME", ap_get_server_name(r));
    snprintf(server_port, BUFSIZ, "%u", ap_get_server_port(r));
    mr_setenv("SERVER_PORT", server_port);
    mr_setenv("SERVER_PROTOCOL", r->protocol);
    mr_setenv("SERVER_SOFTWARE", ap_get_server_version());
d613 1
a613 1
	return "UTF8";
@


1.5
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.4 1999/07/15 06:06:09 shugo Exp $
d111 8
a118 1
    NULL			/* post read-request */
d207 1
d209 2
a210 1
    rb_define_global_const("MOD_RUBY", STRING_LITERAL(MOD_RUBY_STRING_VERSION));
d650 1
a650 1
    rb_defout = ruby_create_request(r);
d657 3
d698 2
a699 1
    rb_defout = ruby_create_request(r);
a703 3
    r->content_type = ap_psprintf(r->pool, "text/html; charset=%s", get_charset());
    r->content_encoding = "7bit";
    ap_send_http_header(r);
d707 3
d715 7
a774 3
#if defined(RUBY_RELEASE_CODE) && RUBY_RELEASE_CODE >= 19990601
    rb_exec_end_proc();
#endif
@


1.4
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.3 1999/07/06 09:36:53 shugo Exp $
a45 4
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

d458 1
a458 1
		snprintf(buff, BUFSIZ, "\t ... %d levels...\n",
d518 2
a519 1
    ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, r->server, RSTRING(logmsg)->ptr);
d754 1
@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.2 1999/06/21 07:19:15 shugo Exp $
d206 1
d571 1
a571 1
static int write_client_block(request_rec *r)
d601 1
a601 1
    rb_thread_create(write_client_block0, &arg);
d622 11
d650 1
a650 1
    rb_funcall(timeout_thread, rb_intern("exit"), 0);
d699 1
a699 1
    rb_funcall(timeout_thread, rb_intern("exit"), 0);
a710 5
static VALUE thread_join(VALUE thread)
{
    return rb_funcall(thread, rb_intern("join"), 0);
}

d713 2
a714 1
    VALUE thread;
d716 1
a716 1
    int retval, state;
d739 1
a739 1
	if (write_client_block(r) == -1)
d748 4
a751 2
    thread = rb_thread_create(load, r);
    rb_protect(thread_join, thread, &state);
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: mod_ruby.c,v 1.1 1999/06/21 07:14:11 shugo Exp $
d543 4
a546 1
    char buff[HUGE_STRING_LEN];
d556 4
a559 3
    while ((len = ap_get_client_block(arg->r, buff, HUGE_STRING_LEN)) > 0) {
	ap_reset_timeout(arg->r);
	if (fwrite(buff, 1, len, arg->fp) == EOF)
d565 2
a566 2
    ap_kill_timeout(arg->r);
    fclose(arg->fp);
@


1.1
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id$
a49 2
#include "eruby.h"

d53 1
@
