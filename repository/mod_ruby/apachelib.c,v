head	1.35;
access;
symbols
	release_1_0_1:1.35
	version_1_0-branch:1.35.0.2
	root-of-version_1_0:1.35
	release_1_0_0:1.35
	release_0_9_9:1.35
	release_0_9_8:1.33
	release_0_9_7:1.31
	release_0_9_6:1.31
	release_0_9_5:1.31
	autoconfiscation-branch:1.31.0.2
	root-of-autoconfiscation:1.31
	release_0_9_4:1.31
	release_0_9_3:1.29
	release_0_9_2:1.28
	release_0_9_1:1.28
	release_0_9_0:1.27
	release_0_8_6:1.27
	release_0_8_5:1.27
	release_0_8_4:1.27
	release_0_8_3:1.26
	release_0_8_2:1.26
	release_0_8_1:1.24
	release_0_8_0:1.21
	release_0_2_0:1.9
	start:1.1.1.1
	NaCl:1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2002.05.21.04.38.57;	author shugo;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.07.04.50.57;	author shugo;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.27.05.17.20;	author shugo;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.05.05.57.35;	author shugo;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.15.03.27.46;	author shugo;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.04.09.19.38;	author shugo;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.24.02.23.39;	author shugo;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.06.05.39.37;	author shugo;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.11.02.14.15;	author shugo;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.04.03.07.20;	author shugo;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.02.08.45.26;	author shugo;	state Exp;
branches;
next	1.24;

1.24
date	2001.04.27.04.51.59;	author shugo;	state Exp;
branches;
next	1.23;

1.23
date	2001.04.20.04.08.56;	author shugo;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.19.06.13.25;	author shugo;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.13.04.19.40;	author shugo;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.12.09.08.34;	author shugo;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.10.08.03.55;	author shugo;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.09.03.55.26;	author shugo;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.05.02.06.35;	author shugo;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.24.07.54.37;	author shugo;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.12.05.41.07;	author shugo;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.06.05.37.07;	author shugo;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.23.09.25.06;	author shugo;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.14.14.55.40;	author shugo;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.14.04.27.56;	author shugo;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.04.15.38.45;	author shugo;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.03.07.29.41;	author shugo;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.14.03.27.33;	author shugo;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.24.04.59.00;	author shugo;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.18.08.47.41;	author shugo;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.30.08.08.11;	author shugo;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.28.05.41.57;	author shugo;	state Exp;
branches;
next	1.3;

1.3
date	99.07.06.09.36.53;	author shugo;	state Exp;
branches;
next	1.2;

1.2
date	99.05.19.00.45.56;	author shugo;	state Exp;
branches;
next	1.1;

1.1
date	99.04.20.08.41.05;	author shugo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.20.08.41.05;	author shugo;	state Exp;
branches;
next	;


desc
@@


1.35
log
@* apachelib.c (apache_server_root): moved from
request.c:request_server_root().
* request.c (request_proxy_q): fix for Apache2.
* request.c (request_proxy_pass_q): ditto.
* request.c (request_lookup_uri): ditto.
* request.c (request_lookup_file): ditto.
* request.c (request_server_root): new method.
* request.c (request_get_dispatch_handler): ditto.
* request.c (request_set_dispatch_handler): ditto.
* request.c (request_proxy_q): ditto.
* request.c (request_proxy_pass_q): ditto.
* request.c (request_get_cache_resp): ditto.
* request.c (request_set_cache_resp): ditto.
* request.c (request_get_cache_resp): ditto.
* request.c (request_lookup_uri): ditto.
* request.c (request_lookup_file): ditto.
@
text
@/*
 * $Id: apachelib.c,v 1.34 2002/05/07 04:50:57 shugo Exp $
 * Copyright (C) 2000  ZetaBITS, Inc.
 * Copyright (C) 2000  Information-technology Promotion Agency, Japan
 * Copyright (C) 2001  Shugo Maeda <shugo@@modruby.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <unistd.h>

#include "mod_ruby.h"
#include "apachelib.h"

VALUE rb_mApache;
VALUE rb_eApacheTimeoutError;

VALUE rb_request;
VALUE rb_apache_objrefs;

void rb_apache_exit(int status)
{
    VALUE exit;

    exit = rb_exc_new(rb_eSystemExit, 0, 0);
    rb_iv_set(exit, "status", INT2NUM(status));
    rb_exc_raise(exit);
}

void rb_apache_register_object(VALUE obj)
{
    rb_hash_aset(rb_apache_objrefs, rb_obj_id(obj), obj);
}

void rb_apache_unregister_object(VALUE obj)
{
    rb_protect_funcall(rb_apache_objrefs,
		       rb_intern("delete"), NULL, 1, rb_obj_id(obj));
}

static VALUE f_exit(int argc, VALUE *argv, VALUE obj)
{
    VALUE status;
    int status_code;

    rb_secure(4);
    if (rb_scan_args(argc, argv, "01", &status) == 1) {
	status_code = NUM2INT(status);
	if (status_code < 0)
	    rb_raise(rb_eArgError, "negative status code %d", status_code);
    }
    else {
	status_code = OK;
    }
    rb_apache_exit(status_code);
    return Qnil;		/* not reached */
}

static VALUE f_eval_string_wrap(VALUE self, VALUE str)
{
    if (rb_safe_level() >= 4) {
	Check_Type(str, T_STRING);
    }
    else {
	Check_SafeStr(str);
    }
    return rb_eval_string_wrap(STR2CSTR(str), NULL);
}

static VALUE apache_server_version(VALUE self)
{
    return rb_str_new2(ap_get_server_version());
}

#ifdef APACHE2 /* Apache 2.x */
static VALUE apache_add_version_component(VALUE self, VALUE component)
{
    rb_notimplement();
    return Qnil;
}
#else /* Apache 1.x */
static VALUE apache_add_version_component(VALUE self, VALUE component)
{
    ap_add_version_component(STR2CSTR(component));
    return Qnil;
}
#endif

static VALUE apache_server_built(VALUE self)
{
    return rb_str_new2(ap_get_server_built());
}

static VALUE apache_request(VALUE self)
{
    return rb_request;
}

static VALUE apache_unescape_url(VALUE self, VALUE url)
{
    char *buf;

    Check_Type(url, T_STRING);
    buf = ALLOCA_N(char, RSTRING(url)->len + 1);
    memcpy(buf, RSTRING(url)->ptr, RSTRING(url)->len);
    buf[RSTRING(url)->len] = '\0';
    ap_unescape_url(buf);
    return rb_str_new2(buf);
}

#ifdef APACHE2 /* Apache 2.x */
static void ap_chdir_file(const char *file)
{
    const char *x;
    char buf[HUGE_STRING_LEN];

    x = strrchr(file, '/');
    if (x == NULL) {
	chdir(file);
    }
    else if (x - file < sizeof(buf) - 1) {
	memcpy(buf, file, x - file);
	buf[x - file] = '\0';
	chdir(buf);
    }
}
#endif

static VALUE apache_chdir_file(VALUE self, VALUE file)
{
    ap_chdir_file(STR2CSTR(file));
    return Qnil;
}

static VALUE apache_server_root(VALUE self)
{
    return rb_str_new2(ap_server_root);
}

void rb_init_apache()
{
    rb_request = Qnil;
    rb_global_variable(&rb_request);
    rb_apache_objrefs = rb_hash_new();
    rb_global_variable(&rb_apache_objrefs);

    rb_define_global_function("exit", f_exit, -1);
    rb_define_global_function("eval_string_wrap", f_eval_string_wrap, 1);

    rb_mApache = rb_define_module("Apache");
    rb_define_module_function(rb_mApache, "server_version", apache_server_version, 0);
    rb_define_module_function(rb_mApache, "add_version_component",
			      apache_add_version_component, 1);
    rb_define_module_function(rb_mApache, "server_built", apache_server_built, 0);
    rb_define_module_function(rb_mApache, "request", apache_request, 0);
    rb_define_module_function(rb_mApache, "unescape_url", apache_unescape_url, 1);
    rb_define_module_function(rb_mApache, "chdir_file", apache_chdir_file, 1);
    rb_define_module_function(rb_mApache, "server_root", apache_server_root, 0);

    rb_eApacheTimeoutError =
	rb_define_class_under(rb_mApache, "TimeoutError", rb_eException);

    rb_define_const(rb_mApache, "DECLINED", INT2NUM(DECLINED));
    rb_define_const(rb_mApache, "DONE", INT2NUM(DONE));
    rb_define_const(rb_mApache, "OK", INT2NUM(OK));

    /* HTTP status codes */
    rb_define_const(rb_mApache, "HTTP_CONTINUE",
		    INT2NUM(HTTP_CONTINUE));
    rb_define_const(rb_mApache, "HTTP_SWITCHING_PROTOCOLS",
		    INT2NUM(HTTP_SWITCHING_PROTOCOLS));
    rb_define_const(rb_mApache, "HTTP_PROCESSING",
		    INT2NUM(HTTP_PROCESSING));
    rb_define_const(rb_mApache, "HTTP_OK",
		    INT2NUM(HTTP_OK));
    rb_define_const(rb_mApache, "HTTP_CREATED",
		    INT2NUM(HTTP_CREATED));
    rb_define_const(rb_mApache, "HTTP_ACCEPTED",
		    INT2NUM(HTTP_ACCEPTED));
    rb_define_const(rb_mApache, "HTTP_NON_AUTHORITATIVE",
		    INT2NUM(HTTP_NON_AUTHORITATIVE));
    rb_define_const(rb_mApache, "HTTP_NO_CONTENT",
		    INT2NUM(HTTP_NO_CONTENT));
    rb_define_const(rb_mApache, "HTTP_RESET_CONTENT",
		    INT2NUM(HTTP_RESET_CONTENT));
    rb_define_const(rb_mApache, "HTTP_PARTIAL_CONTENT",
		    INT2NUM(HTTP_PARTIAL_CONTENT));
    rb_define_const(rb_mApache, "HTTP_MULTI_STATUS",
		    INT2NUM(HTTP_MULTI_STATUS));
    rb_define_const(rb_mApache, "HTTP_MULTIPLE_CHOICES",
		    INT2NUM(HTTP_MULTIPLE_CHOICES));
    rb_define_const(rb_mApache, "HTTP_MOVED_PERMANENTLY",
		    INT2NUM(HTTP_MOVED_PERMANENTLY));
    rb_define_const(rb_mApache, "HTTP_MOVED_TEMPORARILY",
		    INT2NUM(HTTP_MOVED_TEMPORARILY));
    rb_define_const(rb_mApache, "HTTP_SEE_OTHER",
		    INT2NUM(HTTP_SEE_OTHER));
    rb_define_const(rb_mApache, "HTTP_NOT_MODIFIED",
		    INT2NUM(HTTP_NOT_MODIFIED));
    rb_define_const(rb_mApache, "HTTP_USE_PROXY",
		    INT2NUM(HTTP_USE_PROXY));
    rb_define_const(rb_mApache, "HTTP_TEMPORARY_REDIRECT",
		    INT2NUM(HTTP_TEMPORARY_REDIRECT));
    rb_define_const(rb_mApache, "HTTP_BAD_REQUEST",
		    INT2NUM(HTTP_BAD_REQUEST));
    rb_define_const(rb_mApache, "HTTP_UNAUTHORIZED",
		    INT2NUM(HTTP_UNAUTHORIZED));
    rb_define_const(rb_mApache, "HTTP_PAYMENT_REQUIRED",
		    INT2NUM(HTTP_PAYMENT_REQUIRED));
    rb_define_const(rb_mApache, "HTTP_FORBIDDEN",
		    INT2NUM(HTTP_FORBIDDEN));
    rb_define_const(rb_mApache, "HTTP_NOT_FOUND",
		    INT2NUM(HTTP_NOT_FOUND));
    rb_define_const(rb_mApache, "HTTP_METHOD_NOT_ALLOWED",
		    INT2NUM(HTTP_METHOD_NOT_ALLOWED));
    rb_define_const(rb_mApache, "HTTP_NOT_ACCEPTABLE",
		    INT2NUM(HTTP_NOT_ACCEPTABLE));
    rb_define_const(rb_mApache, "HTTP_PROXY_AUTHENTICATION_REQUIRED",
		    INT2NUM(HTTP_PROXY_AUTHENTICATION_REQUIRED));
    rb_define_const(rb_mApache, "HTTP_REQUEST_TIME_OUT",
		    INT2NUM(HTTP_REQUEST_TIME_OUT));
    rb_define_const(rb_mApache, "HTTP_CONFLICT",
		    INT2NUM(HTTP_CONFLICT));
    rb_define_const(rb_mApache, "HTTP_GONE",
		    INT2NUM(HTTP_GONE));
    rb_define_const(rb_mApache, "HTTP_LENGTH_REQUIRED",
		    INT2NUM(HTTP_LENGTH_REQUIRED));
    rb_define_const(rb_mApache, "HTTP_PRECONDITION_FAILED",
		    INT2NUM(HTTP_PRECONDITION_FAILED));
    rb_define_const(rb_mApache, "HTTP_REQUEST_ENTITY_TOO_LARGE",
		    INT2NUM(HTTP_REQUEST_ENTITY_TOO_LARGE));
    rb_define_const(rb_mApache, "HTTP_REQUEST_URI_TOO_LARGE",
		    INT2NUM(HTTP_REQUEST_URI_TOO_LARGE));
    rb_define_const(rb_mApache, "HTTP_UNSUPPORTED_MEDIA_TYPE",
		    INT2NUM(HTTP_UNSUPPORTED_MEDIA_TYPE));
    rb_define_const(rb_mApache, "HTTP_RANGE_NOT_SATISFIABLE",
		    INT2NUM(HTTP_RANGE_NOT_SATISFIABLE));
    rb_define_const(rb_mApache, "HTTP_EXPECTATION_FAILED",
		    INT2NUM(HTTP_EXPECTATION_FAILED));
    rb_define_const(rb_mApache, "HTTP_UNPROCESSABLE_ENTITY",
		    INT2NUM(HTTP_UNPROCESSABLE_ENTITY));
    rb_define_const(rb_mApache, "HTTP_LOCKED",
		    INT2NUM(HTTP_LOCKED));
#ifdef HTTP_FAILED_DEPENDENCY
    rb_define_const(rb_mApache, "HTTP_FAILED_DEPENDENCY",
			      INT2NUM(HTTP_FAILED_DEPENDENCY));
#endif
    rb_define_const(rb_mApache, "HTTP_INTERNAL_SERVER_ERROR",
		    INT2NUM(HTTP_INTERNAL_SERVER_ERROR));
    rb_define_const(rb_mApache, "HTTP_NOT_IMPLEMENTED",
		    INT2NUM(HTTP_NOT_IMPLEMENTED));
    rb_define_const(rb_mApache, "HTTP_BAD_GATEWAY",
		    INT2NUM(HTTP_BAD_GATEWAY));
    rb_define_const(rb_mApache, "HTTP_SERVICE_UNAVAILABLE",
		    INT2NUM(HTTP_SERVICE_UNAVAILABLE));
    rb_define_const(rb_mApache, "HTTP_GATEWAY_TIME_OUT",
		    INT2NUM(HTTP_GATEWAY_TIME_OUT));
    rb_define_const(rb_mApache, "HTTP_VERSION_NOT_SUPPORTED",
		    INT2NUM(HTTP_VERSION_NOT_SUPPORTED));
    rb_define_const(rb_mApache, "HTTP_VARIANT_ALSO_VARIES",
		    INT2NUM(HTTP_VARIANT_ALSO_VARIES));
#ifdef HTTP_INSUFFICIENT_STORAGE
    rb_define_const(rb_mApache, "HTTP_INSUFFICIENT_STORAGE",
			      INT2NUM(HTTP_INSUFFICIENT_STORAGE));
#endif
    rb_define_const(rb_mApache, "HTTP_NOT_EXTENDED",
		    INT2NUM(HTTP_NOT_EXTENDED));

    rb_define_const(rb_mApache, "DOCUMENT_FOLLOWS",
		    INT2NUM(HTTP_OK));
    rb_define_const(rb_mApache, "PARTIAL_CONTENT",
		    INT2NUM(HTTP_PARTIAL_CONTENT));
    rb_define_const(rb_mApache, "MULTIPLE_CHOICES",
		    INT2NUM(HTTP_MULTIPLE_CHOICES));
    rb_define_const(rb_mApache, "MOVED",
		    INT2NUM(HTTP_MOVED_PERMANENTLY));
    rb_define_const(rb_mApache, "REDIRECT",
		    INT2NUM(HTTP_MOVED_TEMPORARILY));
    rb_define_const(rb_mApache, "USE_LOCAL_COPY",
		    INT2NUM(HTTP_NOT_MODIFIED));
    rb_define_const(rb_mApache, "BAD_REQUEST",
		    INT2NUM(HTTP_BAD_REQUEST));
    rb_define_const(rb_mApache, "AUTH_REQUIRED",
		    INT2NUM(HTTP_UNAUTHORIZED));
    rb_define_const(rb_mApache, "FORBIDDEN",
		    INT2NUM(HTTP_FORBIDDEN));
    rb_define_const(rb_mApache, "NOT_FOUND",
		    INT2NUM(HTTP_NOT_FOUND));
    rb_define_const(rb_mApache, "METHOD_NOT_ALLOWED",
		    INT2NUM(HTTP_METHOD_NOT_ALLOWED));
    rb_define_const(rb_mApache, "NOT_ACCEPTABLE",
		    INT2NUM(HTTP_NOT_ACCEPTABLE));
    rb_define_const(rb_mApache, "LENGTH_REQUIRED",
		    INT2NUM(HTTP_LENGTH_REQUIRED));
    rb_define_const(rb_mApache, "PRECONDITION_FAILED",
		    INT2NUM(HTTP_PRECONDITION_FAILED));
    rb_define_const(rb_mApache, "SERVER_ERROR",
		    INT2NUM(HTTP_INTERNAL_SERVER_ERROR));
    rb_define_const(rb_mApache, "NOT_IMPLEMENTED",
		    INT2NUM(HTTP_NOT_IMPLEMENTED));
    rb_define_const(rb_mApache, "BAD_GATEWAY",
		    INT2NUM(HTTP_BAD_GATEWAY));
    rb_define_const(rb_mApache, "VARIANT_ALSO_VARIES",
		    INT2NUM(HTTP_VARIANT_ALSO_VARIES));

    rb_define_const(rb_mApache, "M_GET", INT2NUM(M_GET));
    rb_define_const(rb_mApache, "M_PUT", INT2NUM(M_PUT));
    rb_define_const(rb_mApache, "M_POST", INT2NUM(M_POST));
    rb_define_const(rb_mApache, "M_DELETE", INT2NUM(M_DELETE));
    rb_define_const(rb_mApache, "M_CONNECT", INT2NUM(M_CONNECT));
    rb_define_const(rb_mApache, "M_OPTIONS", INT2NUM(M_OPTIONS));
    rb_define_const(rb_mApache, "M_TRACE", INT2NUM(M_TRACE));
    rb_define_const(rb_mApache, "M_PATCH", INT2NUM(M_PATCH));
    rb_define_const(rb_mApache, "M_PROPFIND", INT2NUM(M_PROPFIND));
    rb_define_const(rb_mApache, "M_PROPPATCH", INT2NUM(M_PROPPATCH));
    rb_define_const(rb_mApache, "M_MKCOL", INT2NUM(M_MKCOL));
    rb_define_const(rb_mApache, "M_COPY", INT2NUM(M_COPY));
    rb_define_const(rb_mApache, "M_MOVE", INT2NUM(M_MOVE));
    rb_define_const(rb_mApache, "M_LOCK", INT2NUM(M_LOCK));
    rb_define_const(rb_mApache, "M_UNLOCK", INT2NUM(M_UNLOCK));
    rb_define_const(rb_mApache, "M_INVALID", INT2NUM(M_INVALID));
    rb_define_const(rb_mApache, "METHODS", INT2NUM(METHODS));

    rb_define_const(rb_mApache, "OPT_NONE", INT2NUM(OPT_NONE));
    rb_define_const(rb_mApache, "OPT_INDEXES", INT2NUM(OPT_INDEXES));
    rb_define_const(rb_mApache, "OPT_INCLUDES", INT2NUM(OPT_INCLUDES));
    rb_define_const(rb_mApache, "OPT_SYM_LINKS", INT2NUM(OPT_SYM_LINKS));
    rb_define_const(rb_mApache, "OPT_EXECCGI", INT2NUM(OPT_EXECCGI));
    rb_define_const(rb_mApache, "OPT_UNSET", INT2NUM(OPT_UNSET));
    rb_define_const(rb_mApache, "OPT_INCNOEXEC", INT2NUM(OPT_INCNOEXEC));
    rb_define_const(rb_mApache, "OPT_SYM_OWNER", INT2NUM(OPT_SYM_OWNER));
    rb_define_const(rb_mApache, "OPT_MULTI", INT2NUM(OPT_MULTI));
    rb_define_const(rb_mApache, "OPT_ALL", INT2NUM(OPT_ALL));

    rb_define_const(rb_mApache, "SATISFY_ALL", INT2NUM(SATISFY_ALL));
    rb_define_const(rb_mApache, "SATISFY_ANY", INT2NUM(SATISFY_ANY));
    rb_define_const(rb_mApache, "SATISFY_NOSPEC", INT2NUM(SATISFY_NOSPEC));

    rb_define_const(rb_mApache, "REMOTE_HOST",
		    INT2NUM(REMOTE_HOST));
    rb_define_const(rb_mApache, "REMOTE_NAME",
		    INT2NUM(REMOTE_NAME));
    rb_define_const(rb_mApache, "REMOTE_NOLOOKUP",
		    INT2NUM(REMOTE_NOLOOKUP));
    rb_define_const(rb_mApache, "REMOTE_DOUBLE_REV",
		    INT2NUM(REMOTE_DOUBLE_REV));

    rb_init_apache_array();
    rb_init_apache_table();
    rb_init_apache_connection();
    rb_init_apache_server();
    rb_init_apache_request();
}

/*
 * Local variables:
 * mode: C
 * tab-width: 8
 * End:
 */
@


1.34
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.33 2002/03/27 05:17:20 shugo Exp $
d155 5
d178 1
@


1.33
log
@* request.c (request_set_user): new method.

* request.c (request_set_auth_type): ditto.

* request.c (request_set_auth_name): ditto.

* connection.c (connection_set_user): ditto.

* connection.c (connection_set_auth_type): ditto.

* connection.c (connection_remote_port): fix for Apache2.

* connection.c (connection_local_port): ditto.

* connection.c (connection_remote_port): new method.

* connection.c (connection_local_port): ditto.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.32 2002/03/05 05:57:35 shugo Exp $
d352 9
@


1.32
log
@* supports Apache 2.0.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.31 2001/10/15 03:27:46 shugo Exp $
d95 1
a95 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
d131 1
a131 1
#ifdef STANDARD20_MODULE_STUFF /* Apache 2.x */
@


1.31
log
@* mod_ruby.c (ruby_startup): call Init_stack().
* request.c (cleanup_request_object): free RDATA(reqobj)->data.
* request.c (request_headers_in): allow non-auth handlers to
access Authorization header fields.
* request.c (request_get_basic_auth_pw): allow non-auth handlers.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.30 2001/10/04 09:19:38 shugo Exp $
d30 1
a30 11
#include "httpd.h"
#include "http_config.h"
#include "http_core.h"
#include "http_log.h"
#include "http_main.h"
#include "http_protocol.h"
#include "util_script.h"
#include "multithread.h"

#include "ruby.h"
#include "version.h"
d95 7
d107 1
d131 18
d284 1
a284 1
		    INT2NUM(DOCUMENT_FOLLOWS));
d286 1
a286 1
		    INT2NUM(PARTIAL_CONTENT));
d288 1
a288 1
		    INT2NUM(MULTIPLE_CHOICES));
d290 1
a290 1
		    INT2NUM(MOVED));
d292 1
a292 1
		    INT2NUM(REDIRECT));
d294 1
a294 1
		    INT2NUM(USE_LOCAL_COPY));
d296 1
a296 1
		    INT2NUM(BAD_REQUEST));
d298 1
a298 1
		    INT2NUM(AUTH_REQUIRED));
d300 1
a300 1
		    INT2NUM(FORBIDDEN));
d302 1
a302 1
		    INT2NUM(NOT_FOUND));
d304 1
a304 1
		    INT2NUM(METHOD_NOT_ALLOWED));
d306 1
a306 1
		    INT2NUM(NOT_ACCEPTABLE));
d308 1
a308 1
		    INT2NUM(LENGTH_REQUIRED));
d310 1
a310 1
		    INT2NUM(PRECONDITION_FAILED));
d312 1
a312 1
		    INT2NUM(SERVER_ERROR));
d314 1
a314 1
		    INT2NUM(NOT_IMPLEMENTED));
d316 1
a316 1
		    INT2NUM(BAD_GATEWAY));
d318 1
a318 1
		    INT2NUM(VARIANT_ALSO_VARIES));
@


1.30
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.29 2001/08/24 02:23:39 shugo Exp $
d5 1
a5 1
 * Copyright (C) 2000  Shugo Maeda <shugo@@modruby.net>
@


1.29
log
@* lib/apache/eruby-run.rb (postrun): do not overwrite r.content_type.
* mod_ruby.c (ruby_require): handle SystemExit correctly.
* request.c (request_method_number): new method.
* apachelib.c: new constants M_GET, M_PUT, ....
* configure.rb: rebuild with autoconf.rb 0.2.3 for Solaris.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.28 2001/08/06 05:39:37 shugo Exp $
d42 1
d49 1
d60 11
d143 2
@


1.28
log
@* version 0.9.1 released.
@
text
@d2 1
a2 1
 * $Id$
d288 18
@


1.27
log
@* mod_ruby.c (ruby_handler_0): handle SystemExit correctly.
* array_header.c (array_length): new method.
* table.c: renamed ApacheInTable to ApacheRestrictedTable.
* request.c (rb_apache_request_new): don't set content_type.
* request.c (request_headers_in): return non-restricted table for
RubyAuthenHandler.
* request.c (request_notes): removed.
* request.c (request_allow_options): new method.
* request.c (request_allow_overrides): ditto.
* request.c (request_default_type): ditto.
* request.c (request_construct_url): ditto.
* request.c (request_auth_type): ditto.
* request.c (request_auth_name): ditto.
* request.c (request_satisfies): ditto.
* request.c (request_requires): ditto.
* request.c (request_note_auth_failure): ditto.
* request.c (request_note_basic_auth_failure): ditto.
* request.c (request_note_digest_auth_failure): ditto.
* request.c (request_basic_auth_pw): ditto.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.26 2001/06/04 03:07:20 shugo Exp $
d6 1
d8 8
a15 1
 * Author: Shugo Maeda <shugo@@modruby.net>
d17 11
a27 16
 * This file is part of mod_ruby.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA.
@


1.26
log
@* lib/auto-reload: new file.
* lib/apache/ruby-run.rb: renamed from ruby/apache/ruby.rb.
* lib/apache/eruby-run.rb: renamed from ruby/apache/eruby.rb.
* lib/apache/rd2html.rb: renamed from ruby/apache/rd2html.rb.
* lib/apache/eruby-run.rb (handler): specify filename for backtrace.
* changed license from GPL to LGPL.
* COPYING: new file.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.25 2001/05/02 08:45:26 shugo Exp $
d285 15
@


1.25
log
@* fixed copyright notice.
* array_header.c: new file for Apache::ArrayHeader.
* server.c: added some methods.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.24 2001/04/27 04:51:59 shugo Exp $
d11 4
a14 4
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
d18 2
a19 2
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
d21 4
a24 4
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA
d73 11
d129 1
@


1.24
log
@* ruby/apache/ruby.rb (emulate_cgi): new method.
* ruby/apache/eruby.rb: inherit Apache::Ruby.
* table.c: new file for Apache::Table.
* connection.c: new file for Apache::Connection.
* server.c: new file for Apache::Server.
* request.c: new file for Apache::Request.
* request.c (request_setup_cgi_env): new method.
* mod_ruby.c (script_handler): resotre original $stdin, $stdout
and $>.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.23 2001/04/20 04:08:56 shugo Exp $
d5 1
d274 1
@


1.23
log
@* apachelib.c (request_finfo): new method Apache::Request#finfo.
* mod_ruby.c (load_eruby_script): supports eruby-0.9.0.
* ruby/apache/eruby.rb: new handler Apache::ERuby.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.22 2001/04/19 06:13:25 shugo Exp $
a25 2
#include <string.h>

d37 1
a39 3
extern VALUE rb_defout;
extern VALUE rb_stdin;

a40 5
VALUE rb_cApacheTable;
VALUE rb_cApacheInTable;
VALUE rb_cApacheConnection;
VALUE rb_cApacheServer;
VALUE rb_cApacheRequest;
d43 1
a43 48
#define STRING_LITERAL(s) rb_str_new(s, sizeof(s) - 1)
#define CSTR2OBJ(s) ((s) ? rb_str_new2(s) : Qnil)
#define INT2BOOL(n) ((n) ? Qtrue : Qfalse)

#define DEFINE_ATTR_READER(fname, type, member, convert) \
static VALUE fname(VALUE self) \
{ \
    type *data; \
    Data_Get_Struct(self, type, data); \
    return convert(data->member); \
}

#define DEFINE_ATTR_WRITER(fname, type, member, convert) \
static VALUE fname(VALUE self, VALUE val) \
{ \
    type *data; \
    Data_Get_Struct(self, type, data); \
    data->member = convert(val); \
    return val; \
}

#define DEFINE_STRING_ATTR_READER(fname, type, member) \
	DEFINE_ATTR_READER(fname, type, member, CSTR2OBJ)

#define DEFINE_INT_ATTR_READER(fname, type, member) \
	DEFINE_ATTR_READER(fname, type, member, INT2NUM)
#define DEFINE_INT_ATTR_WRITER(fname, type, member) \
	DEFINE_ATTR_WRITER(fname, type, member, NUM2INT)

#define DEFINE_UINT_ATTR_READER(fname, type, member) \
	DEFINE_ATTR_READER(fname, type, member, UINT2NUM)
#define DEFINE_UINT_ATTR_WRITER(fname, type, member) \
	DEFINE_ATTR_WRITER(fname, type, member, NUM2UINT)

#define DEFINE_LONG_ATTR_READER(fname, type, member) \
	DEFINE_ATTR_READER(fname, type, member, INT2NUM)
#define DEFINE_LONG_ATTR_WRITER(fname, type, member) \
	DEFINE_ATTR_WRITER(fname, type, member, NUM2LONG)

#define DEFINE_ULONG_ATTR_READER(fname, type, member) \
	DEFINE_ATTR_READER(fname, type, member, UINT2NUM)
#define DEFINE_ULONG_ATTR_WRITER(fname, type, member) \
	DEFINE_ATTR_WRITER(fname, type, member, NUM2ULONG)

#define DEFINE_BOOL_ATTR_READER(fname, type, member) \
	DEFINE_ATTR_READER(fname, type, member, INT2BOOL)
#define DEFINE_BOOL_ATTR_WRITER(fname, type, member) \
	DEFINE_ATTR_WRITER(fname, type, member, RTEST)
d45 1
a45 12
static VALUE f_p(int argc, VALUE *argv, VALUE self)
{
    int i;

    for (i = 0; i < argc; i++) {
	rb_io_write(rb_defout, rb_inspect(argv[i]));
	rb_io_write(rb_defout, rb_default_rs);
    }
    return Qnil;
}

static void mod_ruby_exit(int status)
d68 1
a68 1
    mod_ruby_exit(status_code);
d90 1
a90 1
    return rb_defout;
d111 1
a111 766
static VALUE table_new(VALUE klass, table *tbl)
{
    return Data_Wrap_Struct(klass, NULL, NULL, tbl);
}

static VALUE table_clear(VALUE self)
{
    table *tbl;

    Data_Get_Struct(self, table, tbl);
    ap_clear_table(tbl);
    return Qnil;
}

static VALUE table_get(VALUE self, VALUE name)
{
    table *tbl;
    const char *key, *res;

    key = STR2CSTR(name);
    Data_Get_Struct(self, table, tbl);
    res = ap_table_get(tbl, key);
    if (res)
	return rb_str_new2(res);
    else
	return Qnil;
}

static VALUE table_set(VALUE self, VALUE name, VALUE val)
{
    table *tbl;

    Data_Get_Struct(self, table, tbl);
    ap_table_set(tbl, STR2CSTR(name), STR2CSTR(val));
    return val;
}

static VALUE table_setn(VALUE self, VALUE name, VALUE val)
{
    table *tbl;

    Data_Get_Struct(self, table, tbl);
    ap_table_setn(tbl, STR2CSTR(name), STR2CSTR(val));
    return val;
}

static VALUE table_merge(VALUE self, VALUE name, VALUE val)
{
    table *tbl;

    Data_Get_Struct(self, table, tbl);
    ap_table_merge(tbl, STR2CSTR(name), STR2CSTR(val));
    return val;
}

static VALUE table_mergen(VALUE self, VALUE name, VALUE val)
{
    table *tbl;

    Data_Get_Struct(self, table, tbl);
    ap_table_mergen(tbl, STR2CSTR(name), STR2CSTR(val));
    return val;
}

static VALUE table_unset(VALUE self, VALUE name)
{
    table *tbl;

    Data_Get_Struct(self, table, tbl);
    ap_table_unset(tbl, STR2CSTR(name));
    return Qnil;
}

static VALUE table_add(VALUE self, VALUE name, VALUE val)
{
    table *tbl;

    Data_Get_Struct(self, table, tbl);
    ap_table_add(tbl, STR2CSTR(name), STR2CSTR(val));
    return val;
}

static VALUE table_addn(VALUE self, VALUE name, VALUE val)
{
    table *tbl;

    Data_Get_Struct(self, table, tbl);
    ap_table_addn(tbl, STR2CSTR(name), STR2CSTR(val));
    return val;
}

static VALUE table_each(VALUE self)
{
    VALUE assoc;
    table *tbl;
    array_header *hdrs_arr;
    table_entry *hdrs;
    int i;

    Data_Get_Struct(self, table, tbl);
    hdrs_arr = ap_table_elts(tbl);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	assoc = rb_assoc_new(rb_str_new2(hdrs[i].key),
			     hdrs[i].val ? rb_str_new2(hdrs[i].val) : Qnil);
	rb_yield(assoc);
    }
    return Qnil;
}

static VALUE table_each_key(VALUE self)
{
    table *tbl;
    array_header *hdrs_arr;
    table_entry *hdrs;
    int i;

    Data_Get_Struct(self, table, tbl);
    hdrs_arr = ap_table_elts(tbl);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	rb_yield(rb_str_new2(hdrs[i].key));
    }
    return Qnil;
}

static VALUE table_each_value(VALUE self)
{
    table *tbl;
    array_header *hdrs_arr;
    table_entry *hdrs;
    int i;

    Data_Get_Struct(self, table, tbl);
    hdrs_arr = ap_table_elts(tbl);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	rb_yield(hdrs[i].val ? rb_str_new2(hdrs[i].val) : Qnil);
    }
    return Qnil;
}

static VALUE in_table_get(VALUE self, VALUE name)
{
    table *tbl;
    const char *key, *res;

    key = STR2CSTR(name);
    if (strcasecmp(key, "authorization") == 0 ||
	strcasecmp(key, "proxy-authorization") == 0)
	return Qnil;
    Data_Get_Struct(self, table, tbl);
    res = ap_table_get(tbl, key);
    if (res)
	return rb_str_new2(res);
    else
	return Qnil;
}

static VALUE in_table_each(VALUE self)
{
    VALUE assoc;
    table *tbl;
    array_header *hdrs_arr;
    table_entry *hdrs;
    int i;

    Data_Get_Struct(self, table, tbl);
    hdrs_arr = ap_table_elts(tbl);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	if (strcasecmp(hdrs[i].key, "authorization") == 0 ||
	    strcasecmp(hdrs[i].key, "proxy-authorization") == 0)
	    continue;
	assoc = rb_assoc_new(rb_str_new2(hdrs[i].key),
			     hdrs[i].val ? rb_str_new2(hdrs[i].val) : Qnil);
	rb_yield(assoc);
    }
    return Qnil;
}

static VALUE in_table_each_key(VALUE self)
{
    table *tbl;
    array_header *hdrs_arr;
    table_entry *hdrs;
    int i;

    Data_Get_Struct(self, table, tbl);
    hdrs_arr = ap_table_elts(tbl);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	if (strcasecmp(hdrs[i].key, "authorization") == 0 ||
	    strcasecmp(hdrs[i].key, "proxy-authorization") == 0)
	    continue;
	rb_yield(rb_str_new2(hdrs[i].key));
    }
    return Qnil;
}

static VALUE in_table_each_value(VALUE self)
{
    table *tbl;
    array_header *hdrs_arr;
    table_entry *hdrs;
    int i;

    Data_Get_Struct(self, table, tbl);
    hdrs_arr = ap_table_elts(tbl);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	if (strcasecmp(hdrs[i].key, "authorization") == 0 ||
	    strcasecmp(hdrs[i].key, "proxy-authorization") == 0)
	    continue;
	rb_yield(hdrs[i].val ? rb_str_new2(hdrs[i].val) : Qnil);
    }
    return Qnil;
}

static VALUE connection_new(conn_rec *conn)
{
    return Data_Wrap_Struct(rb_cApacheConnection, NULL, NULL, conn);
}

DEFINE_STRING_ATTR_READER(connection_remote_ip, conn_rec, remote_ip);
DEFINE_STRING_ATTR_READER(connection_remote_host, conn_rec, remote_host);
DEFINE_STRING_ATTR_READER(connection_remote_logname, conn_rec, remote_logname);
DEFINE_STRING_ATTR_READER(connection_user, conn_rec, user);
DEFINE_STRING_ATTR_READER(connection_auth_type, conn_rec, ap_auth_type);
DEFINE_STRING_ATTR_READER(connection_local_ip, conn_rec, local_ip);
DEFINE_STRING_ATTR_READER(connection_local_host, conn_rec, local_host);

static VALUE server_new(server_rec *server)
{
    return Data_Wrap_Struct(rb_cApacheServer, NULL, NULL, server);
}

DEFINE_STRING_ATTR_READER(server_defn_name, server_rec, defn_name);
DEFINE_UINT_ATTR_READER(server_defn_line_number, server_rec, defn_line_number);
DEFINE_STRING_ATTR_READER(server_srm_confname, server_rec, srm_confname);
DEFINE_STRING_ATTR_READER(server_access_confname, server_rec, access_confname);
DEFINE_STRING_ATTR_READER(server_admin, server_rec, server_admin);
DEFINE_STRING_ATTR_READER(server_hostname, server_rec, server_hostname);
DEFINE_UINT_ATTR_READER(server_port, server_rec, port);
DEFINE_STRING_ATTR_READER(server_error_fname, server_rec, error_fname);
DEFINE_INT_ATTR_READER(server_loglevel, server_rec, loglevel);
DEFINE_BOOL_ATTR_READER(server_is_virtual, server_rec, is_virtual);

typedef struct request_data {
    request_rec *request;
    VALUE outbuf;
    VALUE connection;
    VALUE server;
    VALUE headers_in;
    VALUE headers_out;
    VALUE err_headers_out;
    VALUE subprocess_env;
    VALUE notes;
    VALUE finfo;
    int send_http_header;
    long pos;
} request_data;

#define REQUEST_STRING_ATTR_READER(fname, member) \
	DEFINE_STRING_ATTR_READER(fname, request_data, request->member)

#define REQUEST_STRING_ATTR_WRITER(fname, member) \
static VALUE fname(VALUE self, VALUE val) \
{ \
    request_data *data; \
    Data_Get_Struct(self, request_data, data); \
    data->request->member = \
	ap_pstrdup(data->request->pool, STR2CSTR(val)); \
    return val; \
}

#define REQUEST_INT_ATTR_READER(fname, member) \
	DEFINE_INT_ATTR_READER(fname, request_data, request->member)
#define REQUEST_INT_ATTR_WRITER(fname, member) \
	DEFINE_INT_ATTR_WRITER(fname, request_data, request->member)

static void request_mark(request_data *data)
{
    rb_gc_mark(data->outbuf);
    rb_gc_mark(data->connection);
    rb_gc_mark(data->server);
    rb_gc_mark(data->headers_in);
    rb_gc_mark(data->headers_out);
    rb_gc_mark(data->err_headers_out);
    rb_gc_mark(data->subprocess_env);
    rb_gc_mark(data->notes);
    rb_gc_mark(data->finfo);
}

VALUE ruby_request_new(request_rec *r)
{
    request_data *data;
    VALUE result;
    
    r->content_type = "text/html";
    result = Data_Make_Struct(rb_cApacheRequest, request_data,
			      request_mark, free, data);
    data->request = r;
    data->outbuf = rb_tainted_str_new("", 0);
    data->connection = Qnil;
    data->headers_in = Qnil;
    data->headers_out = Qnil;
    data->err_headers_out = Qnil;
    data->subprocess_env = Qnil;
    data->notes = Qnil;
    data->finfo = Qnil;
    data->send_http_header = 0;
    data->pos = 0;

    return result;
}

long ruby_request_outbuf_length(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return RSTRING(data->outbuf)->len;
}

static VALUE request_to_s(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return data->outbuf;
}

static VALUE request_replace(int argc, VALUE *argv, VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return rb_funcall2(data->outbuf, rb_frame_last_func(), argc, argv);
}

static VALUE request_cancel(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    RSTRING(data->outbuf)->len = 0;
    RSTRING(data->outbuf)->ptr[0] = '\0';
    return Qnil;
}

static VALUE request_write(VALUE self, VALUE str)
{
    request_data *data;
    int len;

    Data_Get_Struct(self, request_data, data);
    str = rb_obj_as_string(str);
    rb_str_cat(data->outbuf, RSTRING(str)->ptr, RSTRING(str)->len);
    len = RSTRING(str)->len;
    return INT2NUM(len);
}

static VALUE request_putc(VALUE self, VALUE c)
{
    char ch = NUM2CHR(c);
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    rb_str_cat(data->outbuf, &ch, 1);
    return c;
}

static VALUE request_print(int argc, VALUE *argv, VALUE out)
{
    int i;
    VALUE line;

    /* if no argument given, print `$_' */
    if (argc == 0) {
	argc = 1;
	line = rb_lastline_get();
	argv = &line;
    }
    for (i=0; i<argc; i++) {
	if (!NIL_P(rb_output_fs) && i>0) {
	    request_write(out, rb_output_fs);
	}
	switch (TYPE(argv[i])) {
	  case T_NIL:
	    request_write(out, STRING_LITERAL("nil"));
	    break;
	  default:
	    request_write(out, argv[i]);
	    break;
	}
    }
    if (!NIL_P(rb_output_rs)) {
	request_write(out, rb_output_rs);
    }

    return Qnil;
}

static VALUE request_printf(int argc, VALUE *argv, VALUE out)
{
    request_write(out, rb_f_sprintf(argc, argv));
    return Qnil;
}

static VALUE request_puts _((int, VALUE*, VALUE));

static VALUE request_puts_ary(VALUE ary, VALUE out)
{
    VALUE tmp;
    int i;

    for (i=0; i<RARRAY(ary)->len; i++) {
	tmp = RARRAY(ary)->ptr[i];
	if (rb_inspecting_p(tmp)) {
	    tmp = STRING_LITERAL("[...]");
	}
	request_puts(1, &tmp, out);
    }
    return Qnil;
}

static VALUE request_puts(int argc, VALUE *argv, VALUE out)
{
    int i;
    VALUE line;

    /* if no argument given, print newline. */
    if (argc == 0) {
	request_write(out, rb_default_rs);
	return Qnil;
    }
    for (i=0; i<argc; i++) {
	switch (TYPE(argv[i])) {
	  case T_NIL:
	    line = STRING_LITERAL("nil");
	    break;
	  case T_ARRAY:
	    rb_protect_inspect(request_puts_ary, argv[i], out);
	    continue;
	  default:
	    line = argv[i];
	    break;
	}
	line = rb_obj_as_string(line);
	request_write(out, line);
	if (RSTRING(line)->ptr[RSTRING(line)->len-1] != '\n') {
	    request_write(out, rb_default_rs);
	}
    }

    return Qnil;
}

static VALUE request_addstr(VALUE out, VALUE str)
{
    request_write(out, str);
    return out;
}

VALUE rb_request_send_http_header(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    data->send_http_header = 1;
    return Qnil;
}

void rb_request_flush(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (data->send_http_header) {
	ap_send_http_header(data->request);
	if (data->request->header_only)
	    return;
    }
    if (RSTRING(data->outbuf)->len > 0) {
	ap_rwrite(RSTRING(data->outbuf)->ptr,
		  RSTRING(data->outbuf)->len, data->request);
    }
}


static VALUE request_connection(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (NIL_P(data->connection)) {
	data->connection = connection_new(data->request->connection);
    }
    return data->connection;
}

static VALUE request_server(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (NIL_P(data->server)) {
	data->server = server_new(data->request->server);
    }
    return data->server;
}

REQUEST_STRING_ATTR_READER(request_protocol, protocol);
REQUEST_STRING_ATTR_READER(request_hostname, hostname);
REQUEST_STRING_ATTR_READER(request_unparsed_uri, unparsed_uri);
REQUEST_STRING_ATTR_READER(request_uri, uri);
REQUEST_STRING_ATTR_READER(request_get_filename, filename);
REQUEST_STRING_ATTR_WRITER(request_set_filename, filename);
REQUEST_STRING_ATTR_READER(request_path_info, path_info);
REQUEST_INT_ATTR_READER(request_get_status, status);
REQUEST_INT_ATTR_WRITER(request_set_status, status);
REQUEST_STRING_ATTR_READER(request_get_status_line, status_line);
REQUEST_STRING_ATTR_WRITER(request_set_status_line, status_line);
REQUEST_STRING_ATTR_READER(request_request_method, method);
REQUEST_STRING_ATTR_READER(request_args, args);
REQUEST_STRING_ATTR_READER(request_get_content_type, content_type);
REQUEST_STRING_ATTR_READER(request_get_content_encoding, content_encoding);

static VALUE request_request_time(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return rb_time_new(data->request->request_time, 0);
}

static VALUE request_header_only(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return data->request->header_only ? Qtrue : Qfalse;
}

static VALUE request_content_length(VALUE self)
{
    request_data *data;
    const char *s;

    rb_warn("content_length is obsolete; use headers_in[\"Content-Length\"] instead");
    Data_Get_Struct(self, request_data, data);
    s = ap_table_get(data->request->headers_in, "Content-Length");
    return s ? rb_cstr2inum(s, 10) : Qnil;
}

static VALUE request_set_content_type(VALUE self, VALUE str)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    str = rb_funcall(str, rb_intern("downcase"), 0);
    data->request->content_type =
	ap_pstrdup(data->request->pool, STR2CSTR(str));
    return str;
}

static VALUE request_set_content_encoding(VALUE self, VALUE str)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    str = rb_funcall(str, rb_intern("downcase"), 0);
    data->request->content_encoding =
	ap_pstrdup(data->request->pool, STR2CSTR(str));
    return str;
}

static VALUE request_get_content_languages(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (data->request->content_languages) {
	VALUE ary = rb_ary_new();
	int i, len =  data->request->content_languages->nelts;
	char **langs = (char **) data->request->content_languages->elts;
	for (i = 0; i < len; i++) {
	    rb_ary_push(ary, rb_str_new2(langs[i]));
	}
	rb_ary_freeze(ary);
	return ary;
    }
    else {
	return Qnil;
    }
}

static VALUE request_set_content_languages(VALUE self, VALUE ary)
{
    request_data *data;
    int i;

    Check_Type(ary, T_ARRAY);
    for (i = 0; i < RARRAY(ary)->len; i++) {
	Check_Type(RARRAY(ary)->ptr[i], T_STRING);
    }
    Data_Get_Struct(self, request_data, data);
    data->request->content_languages =
	ap_make_array(data->request->pool, RARRAY(ary)->len, sizeof(char *));
    for (i = 0; i < RARRAY(ary)->len; i++) {
	VALUE str = RARRAY(ary)->ptr[i];
	str = rb_funcall(str, rb_intern("downcase"), 0);
        *(char **) ap_push_array(data->request->content_languages) =
	    ap_pstrdup(data->request->pool, STR2CSTR(str));
    }
    return ary;
}

static VALUE request_headers_in(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (NIL_P(data->headers_in)) {
	data->headers_in = table_new(rb_cApacheInTable,
				     data->request->headers_in);
    }
    return data->headers_in;
}

static VALUE request_headers_out(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (NIL_P(data->headers_out)) {
	data->headers_out = table_new(rb_cApacheTable,
				      data->request->headers_out);
    }
    return data->headers_out;
}

static VALUE request_err_headers_out(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (NIL_P(data->err_headers_out)) {
	data->err_headers_out =
	    table_new(rb_cApacheTable, data->request->err_headers_out);
    }
    return data->err_headers_out;
}

static VALUE request_subprocess_env(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (NIL_P(data->subprocess_env)) {
	data->subprocess_env = table_new(rb_cApacheTable,
					 data->request->subprocess_env);
    }
    return data->subprocess_env;
}

static VALUE request_notes(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (NIL_P(data->notes)) {
	data->notes = table_new(rb_cApacheTable, data->request->notes);
    }
    return data->notes;
}

static VALUE request_finfo(VALUE self)
{
    VALUE cStat, obj;
    request_data *data;
    struct stat *st;

    Data_Get_Struct(self, request_data, data);
    if (NIL_P(data->finfo)) {
	cStat = rb_const_get(rb_cFile, rb_intern("Stat"));
	data->finfo = Data_Make_Struct(cStat, struct stat, NULL, free, st);
	*st = data->request->finfo;
    }
    return data->finfo;
}

static VALUE request_aref(VALUE self, VALUE vkey)
{
    request_data *data;
    char *key = STR2CSTR(vkey);
    const char *val;

    rb_warn("self[] is obsolete; use headers_in instead");
    if (strcasecmp(key, "authorization") == 0 ||
	strcasecmp(key, "proxy-authorization") == 0)
	return Qnil;
    Data_Get_Struct(self, request_data, data);
    val = ap_table_get(data->request->headers_in, key);
    return val ? rb_str_new2(val) : Qnil;
}

static VALUE request_aset(VALUE self, VALUE key, VALUE val)
{
    request_data *data;
    char *s;

    rb_warn("self[]= is obsolete; use headers_out instead");
    s = STR2CSTR(key);
    if (strcasecmp(s, "content-type") == 0) {
	return request_set_content_type(self, val);
    }
    else if (strcasecmp(s, "content-encoding") == 0) {
	return request_set_content_encoding(self, val);
    }
    else {
	Data_Get_Struct(self, request_data, data);
	ap_table_set(data->request->headers_out, s, STR2CSTR(val));
	return val;
    }
}

static VALUE request_each_header(VALUE self)
{
    request_data *data;
    array_header *hdrs_arr;
    table_entry *hdrs;
    int i;
    VALUE assoc;

    rb_warn("each_header is obsolete; use headers_in instead");
    Data_Get_Struct(self, request_data, data);
    hdrs_arr = ap_table_elts(data->request->headers_in);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	if (strcasecmp(hdrs[i].key, "authorization") == 0 ||
	    strcasecmp(hdrs[i].key, "proxy-authorization") == 0)
	    continue;
	assoc = rb_assoc_new(rb_str_new2(hdrs[i].key),
			     hdrs[i].val ? rb_str_new2(hdrs[i].val) : Qnil);
	rb_yield(assoc);
    }
    return Qnil;
}

static VALUE request_each_key(VALUE self)
d113 2
a114 54
    request_data *data;
    array_header *hdrs_arr;
    table_entry *hdrs;
    int i;

    rb_warn("each_key is obsolete; use headers_in instead");
    Data_Get_Struct(self, request_data, data);
    hdrs_arr = ap_table_elts(data->request->headers_in);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	if (strcasecmp(hdrs[i].key, "authorization") == 0 ||
	    strcasecmp(hdrs[i].key, "proxy-authorization") == 0)
	    continue;
	rb_yield(rb_str_new2(hdrs[i].key));
    }
    return Qnil;
}

static VALUE request_each_value(VALUE self)
{
    request_data *data;
    array_header *hdrs_arr;
    table_entry *hdrs;
    int i;

    rb_warn("each_value is obsolete; use headers_in instead");
    Data_Get_Struct(self, request_data, data);
    hdrs_arr = ap_table_elts(data->request->headers_in);
    hdrs = (table_entry *) hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++) {
	if (hdrs[i].key == NULL)
	    continue;
	if (strcasecmp(hdrs[i].key, "authorization") == 0 ||
	    strcasecmp(hdrs[i].key, "proxy-authorization") == 0)
	    continue;
	rb_yield(hdrs[i].val ? rb_str_new2(hdrs[i].val) : Qnil);
    }
    return Qnil;
}

static VALUE request_setup_client_block(int argc, VALUE *argv, VALUE self)
{
    request_data *data;
    VALUE policy;
    int read_policy = REQUEST_CHUNKED_ERROR;

    Data_Get_Struct(self, request_data, data);
    if (rb_scan_args(argc, argv, "01", &policy) == 1) {
	read_policy = NUM2INT(policy);
    }
    return INT2NUM(ap_setup_client_block(data->request, read_policy));
}
a115 208
static VALUE request_should_client_block(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return INT2BOOL(ap_should_client_block(data->request));
}

static VALUE request_get_client_block(VALUE self, VALUE length)
{
    request_data *data;
    char *buf;
    int len;

    Data_Get_Struct(self, request_data, data);
    len = NUM2INT(length);
    buf = (char *) ap_palloc(data->request->pool, len);
    len = ap_get_client_block(data->request, buf, len);
    return rb_tainted_str_new(buf, len);
}

static VALUE read_client_block(request_rec *r, int len)
{
    char *buf;
    int rc;
    int nrd = 0;
    int old_read_length;
    VALUE result;

    if (r->read_length == 0) {
        if ((rc = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR)) != OK) {
	    mod_ruby_exit(rc);
        }
    }
    old_read_length = r->read_length;
    r->read_length = 0;
    if (ap_should_client_block(r)) {
	if (len < 0)
	    len = r->remaining;
	buf = (char *) ap_palloc(r->pool, len);
        nrd = ap_get_client_block(r, buf, len);
	result = rb_tainted_str_new(buf, len);
    }
    else {
	result = Qnil;
    }
    r->read_length += old_read_length;
    return result;
}

static VALUE request_read(int argc, VALUE *argv, VALUE self)
{
    request_data *data;
    VALUE length;
    int len;

    Data_Get_Struct(self, request_data, data);
    rb_scan_args(argc, argv, "01", &length);
    if (NIL_P(length)) {
	return read_client_block(data->request, -1);
    }
    len = NUM2INT(length);
    if (len < 0) {
	rb_raise(rb_eArgError, "negative length %d given", len);
    }
    return read_client_block(data->request, len);
}

static VALUE request_getc(VALUE self)
{
    request_data *data;
    VALUE str;

    Data_Get_Struct(self, request_data, data);
    str = read_client_block(data->request, 1);
    if (NIL_P(str) || RSTRING(str)->len == 0)
	return Qnil;
    return INT2FIX(RSTRING(str)->ptr[0]);
}

static VALUE request_eof(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return INT2BOOL(data->request->remaining == 0);
}

static VALUE request_binmode(VALUE self)
{
    return Qnil;
}

static VALUE request_remote_host(VALUE self)
{
    request_data *data;
    const char *host;

    Data_Get_Struct(self, request_data, data);
    host = ap_get_remote_host(data->request->connection,
			      data->request->per_dir_config,
			      REMOTE_HOST);
    return host ? rb_str_new2(host) : Qnil;
}

static VALUE request_remote_logname(VALUE self)
{
    request_data *data;
    const char *logname;

    Data_Get_Struct(self, request_data, data);
    logname = ap_get_remote_logname(data->request);
    return logname ? rb_str_new2(logname) : Qnil;
}

static VALUE request_server_name(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return rb_str_new2(ap_get_server_name(data->request));
}

static VALUE request_server_port(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return INT2NUM(ap_get_server_port(data->request));
}

static VALUE request_escape_html(VALUE self, VALUE str)
{
    request_data *data;
    char *tmp;

    Data_Get_Struct(self, request_data, data);
    tmp = ap_escape_html(data->request->pool, STR2CSTR(str));
    return rb_str_new2(tmp);
}

static VALUE request_signature(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return rb_str_new2(ap_psignature("", data->request));
}

static VALUE request_reset_timeout(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    ap_reset_timeout(data->request);
    return Qnil;
}

static VALUE request_hard_timeout(VALUE self, VALUE name)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    ap_hard_timeout(ap_pstrdup(data->request->pool, STR2CSTR(name)),
		    data->request);
    return Qnil;
}

static VALUE request_soft_timeout(VALUE self, VALUE name)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    ap_soft_timeout(ap_pstrdup(data->request->pool, STR2CSTR(name)),
		    data->request);
    return Qnil;
}

static VALUE request_kill_timeout(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    ap_kill_timeout(data->request);
    return Qnil;
}

static VALUE request_add_common_vars(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    ap_add_common_vars(data->request);
    return Qnil;
}

static VALUE request_add_cgi_vars(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    ap_add_cgi_vars(data->request);
    return Qnil;
}

void ruby_init_apachelib()
{
    rb_define_global_function("p", f_p, -1);
a126 151
    rb_cApacheTable = rb_define_class_under(rb_mApache, "Table", rb_cObject);
    rb_include_module(rb_cApacheTable, rb_mEnumerable);
    rb_undef_method(CLASS_OF(rb_cApacheTable), "new");
    rb_define_method(rb_cApacheTable, "clear", table_clear, 0);
    rb_define_method(rb_cApacheTable, "get", table_get, 1);
    rb_define_method(rb_cApacheTable, "[]", table_get, 1);
    rb_define_method(rb_cApacheTable, "set", table_set, 2);
    rb_define_method(rb_cApacheTable, "[]=", table_set, 2);
    rb_define_method(rb_cApacheTable, "setn", table_setn, 2);
    rb_define_method(rb_cApacheTable, "merge", table_merge, 2);
    rb_define_method(rb_cApacheTable, "mergen", table_mergen, 2);
    rb_define_method(rb_cApacheTable, "unset", table_unset, 1);
    rb_define_method(rb_cApacheTable, "add", table_add, 2);
    rb_define_method(rb_cApacheTable, "addn", table_addn, 2);
    rb_define_method(rb_cApacheTable, "each", table_each, 0);
    rb_define_method(rb_cApacheTable, "each_key", table_each_key, 0);
    rb_define_method(rb_cApacheTable, "each_value", table_each_value, 0);
    rb_cApacheInTable = rb_define_class_under(rb_mApache, "InTable",
					      rb_cApacheTable);
    rb_define_method(rb_cApacheInTable, "get", in_table_get, 1);
    rb_define_method(rb_cApacheInTable, "[]", in_table_get, 1);
    rb_define_method(rb_cApacheInTable, "each", in_table_each, 0);
    rb_define_method(rb_cApacheInTable, "each_key", in_table_each_key, 0);
    rb_define_method(rb_cApacheInTable, "each_value", in_table_each_value, 0);

    rb_cApacheConnection = rb_define_class_under(rb_mApache, "Connection", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cApacheConnection), "new");
    rb_define_method(rb_cApacheConnection, "remote_ip",
		     connection_remote_ip, 0);
    rb_define_method(rb_cApacheConnection, "remote_host",
		     connection_remote_host, 0);
    rb_define_method(rb_cApacheConnection, "remote_logname",
		     connection_remote_logname, 0);
    rb_define_method(rb_cApacheConnection, "user", connection_user, 0);
    rb_define_method(rb_cApacheConnection, "auth_type",
		     connection_auth_type, 0);
    rb_define_method(rb_cApacheConnection, "local_ip",
		     connection_local_ip, 0);
    rb_define_method(rb_cApacheConnection, "local_host",
		     connection_local_host, 0);

    rb_cApacheServer = rb_define_class_under(rb_mApache, "Server", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cApacheConnection), "new");
    rb_define_method(rb_cApacheServer, "defn_name", server_defn_name, 0);
    rb_define_method(rb_cApacheServer, "defn_line_number",
		     server_defn_line_number, 0);
    rb_define_method(rb_cApacheServer, "srm_confname", server_srm_confname, 0);
    rb_define_method(rb_cApacheServer, "access_confname", server_access_confname, 0);
    rb_define_method(rb_cApacheServer, "admin", server_admin, 0);
    rb_define_method(rb_cApacheServer, "hostname", server_hostname, 0);
    rb_define_method(rb_cApacheServer, "port", server_port, 0);
    rb_define_method(rb_cApacheServer, "error_fname", server_error_fname, 0);
    rb_define_method(rb_cApacheServer, "loglevel", server_loglevel, 0);
    rb_define_method(rb_cApacheServer, "is_virtual", server_is_virtual, 0);
    rb_define_method(rb_cApacheServer, "virtual?", server_is_virtual, 0);

    rb_cApacheRequest = rb_define_class_under(rb_mApache, "Request", rb_cObject);
    rb_include_module(rb_cApacheRequest, rb_mEnumerable);
    rb_undef_method(CLASS_OF(rb_cApacheRequest), "new");
    rb_define_method(rb_cApacheRequest, "to_s", request_to_s, 0);
    rb_define_method(rb_cApacheRequest, "replace", request_replace, -1);
    rb_define_method(rb_cApacheRequest, "cancel", request_cancel, 0);
    rb_define_method(rb_cApacheRequest, "write", request_write, 1);
    rb_define_method(rb_cApacheRequest, "putc", request_putc, 1);
    rb_define_method(rb_cApacheRequest, "print", request_print, -1);
    rb_define_method(rb_cApacheRequest, "printf", request_printf, -1);
    rb_define_method(rb_cApacheRequest, "puts", request_puts, -1);
    rb_define_method(rb_cApacheRequest, "<<", request_addstr, 1);
    rb_define_method(rb_cApacheRequest, "send_http_header",
		     rb_request_send_http_header, 0);
    rb_define_method(rb_cApacheRequest, "connection", request_connection, 0);
    rb_define_method(rb_cApacheRequest, "server", request_server, 0);
    rb_define_method(rb_cApacheRequest, "protocol", request_protocol, 0);
    rb_define_method(rb_cApacheRequest, "hostname", request_hostname, 0);
    rb_define_method(rb_cApacheRequest, "unparsed_uri",
		     request_unparsed_uri, 0);
    rb_define_method(rb_cApacheRequest, "uri", request_uri, 0);
    rb_define_method(rb_cApacheRequest, "filename", request_get_filename, 0);
    rb_define_method(rb_cApacheRequest, "filename=", request_set_filename, 1);
    rb_define_method(rb_cApacheRequest, "path_info", request_path_info, 0);
    rb_define_method(rb_cApacheRequest, "request_time",
		     request_request_time, 0);
    rb_define_method(rb_cApacheRequest, "status", request_get_status, 0);
    rb_define_method(rb_cApacheRequest, "status=", request_set_status, 1);
    rb_define_method(rb_cApacheRequest, "status_line", request_get_status_line, 0);
    rb_define_method(rb_cApacheRequest, "status_line=",
		     request_set_status_line, 1);
    rb_define_method(rb_cApacheRequest, "request_method",
		     request_request_method, 0);
    rb_define_method(rb_cApacheRequest, "header_only?", request_header_only, 0);
    rb_define_method(rb_cApacheRequest, "args", request_args, 0);
    rb_define_method(rb_cApacheRequest, "content_length",
		     request_content_length, 0);
    rb_define_method(rb_cApacheRequest, "content_type",
		     request_get_content_type, 0);
    rb_define_method(rb_cApacheRequest, "content_type=",
		     request_set_content_type, 1);
    rb_define_method(rb_cApacheRequest, "content_encoding",
		     request_get_content_encoding, 0);
    rb_define_method(rb_cApacheRequest, "content_encoding=",
		     request_set_content_encoding, 1);
    rb_define_method(rb_cApacheRequest, "content_languages",
		     request_get_content_languages, 0);
    rb_define_method(rb_cApacheRequest, "content_languages=",
		     request_set_content_languages, 1);
    rb_define_method(rb_cApacheRequest, "headers_in", request_headers_in, 0);
    rb_define_method(rb_cApacheRequest, "headers_out", request_headers_out, 0);
    rb_define_method(rb_cApacheRequest, "err_headers_out",
		     request_err_headers_out, 0);
    rb_define_method(rb_cApacheRequest, "subprocess_env",
		     request_subprocess_env, 0);
    rb_define_method(rb_cApacheRequest, "notes", request_notes, 0);
    rb_define_method(rb_cApacheRequest, "finfo", request_finfo, 0);
    rb_define_method(rb_cApacheRequest, "[]", request_aref, 1);
    rb_define_method(rb_cApacheRequest, "[]=", request_aset, 2);
    rb_define_method(rb_cApacheRequest, "each_header", request_each_header, 0);
    rb_define_method(rb_cApacheRequest, "each_key", request_each_key, 0);
    rb_define_method(rb_cApacheRequest, "each_value", request_each_value, 0);
    rb_define_method(rb_cApacheRequest, "setup_client_block",
		     request_setup_client_block, -1);
    rb_define_method(rb_cApacheRequest, "should_client_block",
		     request_should_client_block, 0);
    rb_define_method(rb_cApacheRequest, "should_client_block?",
		     request_should_client_block, 0);
    rb_define_method(rb_cApacheRequest, "get_client_block",
		     request_get_client_block, 1);
    rb_define_method(rb_cApacheRequest, "read", request_read, -1);
    rb_define_method(rb_cApacheRequest, "getc", request_getc, 0);
    rb_define_method(rb_cApacheRequest, "eof", request_eof, 0);
    rb_define_method(rb_cApacheRequest, "eof?", request_eof, 0);
    rb_define_method(rb_cApacheRequest, "binmode", request_binmode, 0);
    rb_define_method(rb_cApacheRequest, "remote_host", request_remote_host, 0);
    rb_define_method(rb_cApacheRequest, "remote_logname",
		     request_remote_logname, 0);
    rb_define_method(rb_cApacheRequest, "server_name", request_server_name, 0);
    rb_define_method(rb_cApacheRequest, "server_port", request_server_port, 0);
    rb_define_method(rb_cApacheRequest, "escape_html", request_escape_html, 1);
    rb_define_method(rb_cApacheRequest, "signature", request_signature, 0);
    rb_define_method(rb_cApacheRequest, "reset_timeout",
		     request_reset_timeout, 0);
    rb_define_method(rb_cApacheRequest, "hard_timeout",
		     request_hard_timeout, 1);
    rb_define_method(rb_cApacheRequest, "soft_timeout",
		     request_soft_timeout, 1);
    rb_define_method(rb_cApacheRequest, "kill_timeout",
		     request_kill_timeout, 0);
    rb_define_method(rb_cApacheRequest, "add_common_vars",
		     request_add_common_vars, 0);
    rb_define_method(rb_cApacheRequest, "add_cgi_vars",
		     request_add_cgi_vars, 0);

d272 5
@


1.22
log
@* ruby/apache/ruby.rb: new handler Apache::Ruby.
* ruby/apache/rd2html.rb: renamed from mod_rd2html.rb.
* apachelib.c (request_read): do not use buffer.
* apachelib.c (ruby_init_apachelib): remove methods from
Apache::request. (gets, readline, readlines, each, getc,
readchar, ungetc, tell, seek, rewind, pos, pos=)
* apachelib.c (ruby_init_apachelib): new class Apache::Server.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.21 2001/04/13 04:19:40 shugo Exp $
d448 1
d481 1
d500 1
d868 15
d1331 1
@


1.21
log
@* version 0.8.0 released.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.20 2001/04/12 09:08:34 shugo Exp $
d6 1
a6 1
 * Author: Shugo Maeda <shugo@@ruby-lang.org>
a44 1
VALUE rb_cApacheConnection;
d47 2
d53 2
d56 1
a56 1
#define define_string_attr_reader(fname, type, member) \
d61 76
a136 1
    return data->member ? rb_str_new2(data->member) : Qnil; \
d162 1
a162 1
    char *buff;
d165 5
a169 5
    buff = ALLOCA_N(char, RSTRING(url)->len + 1);
    memcpy(buff, RSTRING(url)->ptr, RSTRING(url)->len);
    buff[RSTRING(url)->len] = '\0';
    ap_unescape_url(buff);
    return rb_str_new2(buff);
d172 1
a172 1
static VALUE ruby_create_connection(conn_rec *conn)
d174 2
a175 1
    return Data_Wrap_Struct(rb_cApacheConnection, NULL, NULL, conn);
d178 1
a178 9
define_string_attr_reader(connection_remote_ip, conn_rec, remote_ip);
define_string_attr_reader(connection_remote_host, conn_rec, remote_host);
define_string_attr_reader(connection_remote_logname, conn_rec, remote_logname);
define_string_attr_reader(connection_user, conn_rec, user);
define_string_attr_reader(connection_auth_type, conn_rec, ap_auth_type);
define_string_attr_reader(connection_local_ip, conn_rec, local_ip);
define_string_attr_reader(connection_local_host, conn_rec, local_host);

static VALUE ruby_create_table(VALUE klass, table *tbl)
d409 29
a439 1
    VALUE inbuf;
d442 1
d445 1
d447 1
d452 5
a456 4
#define request_string_attr_reader(fname, member) \
	define_string_attr_reader(fname, request_data, request->member)
#define request_string_attr_writer(fname, member) \
static VALUE fname(VALUE self, VALUE str) \
d461 2
a462 2
	ap_pstrdup(data->request->pool, STR2CSTR(str)); \
    return str; \
d465 5
a471 1
    rb_gc_mark(data->inbuf);
d474 1
d477 1
d479 1
d482 1
a482 1
VALUE ruby_create_request(request_rec *r, VALUE input)
a490 1
    data->inbuf = input;
d495 1
d497 1
d684 1
a684 1
	data->connection = ruby_create_connection(data->request->connection);
d689 1
a689 15
request_string_attr_reader(request_protocol, protocol);
request_string_attr_reader(request_hostname, hostname);
request_string_attr_reader(request_unparsed_uri, unparsed_uri);
request_string_attr_reader(request_uri, uri);
request_string_attr_reader(request_filename, filename);
request_string_attr_reader(request_set_filename, filename);
request_string_attr_reader(request_path_info, path_info);
request_string_attr_reader(request_status_line, status_line);
request_string_attr_writer(request_set_status_line, status_line);
request_string_attr_reader(request_request_method, method);
request_string_attr_reader(request_args, args);
request_string_attr_reader(request_get_content_type, content_type);
request_string_attr_reader(request_get_content_encoding, content_encoding);

static VALUE request_request_time(VALUE self)
d694 4
a697 1
    return rb_time_new(data->request->request_time, 0);
d700 15
a714 3
static VALUE request_status(VALUE self)
{
    request_data *data;
d716 1
a716 5
    Data_Get_Struct(self, request_data, data);
    return INT2NUM(data->request->status);
}

static VALUE request_set_status(VALUE self, VALUE status)
d721 1
a721 2
    data->request->status = NUM2INT(status);
    return status;
d812 2
a813 2
	data->headers_in = ruby_create_table(rb_cApacheInTable,
					     data->request->headers_in);
d824 2
a825 2
	data->headers_out = ruby_create_table(rb_cApacheTable,
					      data->request->headers_out);
d830 12
d848 2
a849 2
	data->subprocess_env = ruby_create_table(rb_cApacheTable,
						 data->request->subprocess_env);
d854 11
d969 1
a969 1
static VALUE request_read_all(VALUE self)
d972 2
a973 1
    VALUE str;
d976 4
a979 7
    if (data->pos >= RSTRING(data->inbuf)->len)
	return Qnil;
    str = rb_str_substr(data->inbuf, data->pos,
			RSTRING(data->inbuf)->len - data->pos);
    data->pos = RSTRING(data->inbuf)->len;
    OBJ_TAINT(str);
    return str;
d982 1
a982 1
static VALUE request_read(int argc, VALUE *argv, VALUE self)
a984 2
    VALUE length, str;
    long len, rest;
d987 1
a987 22
    rb_scan_args(argc, argv, "01", &length);
    if (NIL_P(length)) {
	return request_read_all(self);
    }

    len = NUM2LONG(length);
    if (len < 0) {
	rb_raise(rb_eArgError, "negative length %d given", len);
    }

    if (data->pos >= RSTRING(data->inbuf)->len)
	return Qnil;
    if (len == 0)
	return rb_str_new("", 0);

    rest = RSTRING(data->inbuf)->len - data->pos;
    if (len > rest) len = rest;

    str = rb_str_substr(data->inbuf, data->pos, len);
    data->pos += len;
    OBJ_TAINT(str);
    return str;
d990 1
a990 16
static long memsearch(char *s, size_t slen, char *t, size_t tlen)
{
    long i, j, k;

    if (tlen == 0)
	return -1;
    for (i = 0; i < slen; i++) {
	for (j = i, k = 0; s[j] == t[k]; j++, k++) {
	    if (k == tlen - 1)
		return i;
	}
    }
    return -1;
}

static VALUE request_gets(int argc, VALUE *argv, VALUE self)
d993 2
a994 3
    VALUE rs, str;
    char *rsptr;
    long rslen, len, i;
d997 5
a1001 6
    if (rb_scan_args(argc, argv, "01", &rs) == 0) {
	rs = rb_rs;
    }
    else {
	if (!NIL_P(rs)) Check_Type(rs, T_STRING);
    }
d1003 7
a1009 2
    if (data->pos >= RSTRING(data->inbuf)->len)
	return Qnil;
d1011 13
a1023 6
    if (NIL_P(rs)) {
	str = request_read_all(self);
	if (!NIL_P(str)) {
	    rb_lastline_set(str);
	}
	return str;
d1026 1
a1026 2
	rsptr = RSTRING(rs)->ptr;
	rslen = RSTRING(rs)->len;
d1028 2
a1029 15
    i = memsearch(RSTRING(data->inbuf)->ptr + data->pos,
		  RSTRING(data->inbuf)->len - data->pos,
		  rsptr, rslen);
    if (i == -1) {
	len = RSTRING(data->inbuf)->len - data->pos;
    }
    else {
	len = i + rslen;
    }
    str = rb_str_substr(data->inbuf, data->pos, len);
    data->pos += len;

    OBJ_TAINT(str);
    rb_lastline_set(str);
    return str;
d1032 1
a1032 32
static VALUE request_readline(int argc, VALUE *argv, VALUE self)
{
    VALUE line = request_gets(argc, argv, self);

    if (NIL_P(line)) {
	rb_raise(rb_eEOFError, "End of file reached");
    }
    return line;
}

static VALUE request_readlines(int argc, VALUE *argv, VALUE self)
{
    VALUE line, ary;

    ary = rb_ary_new();
    while (!NIL_P(line = request_gets(argc, argv, self))) {
	rb_ary_push(ary, line);
    }
    return ary;
}

static VALUE request_each_line(int argc, VALUE *argv, VALUE self)
{
    VALUE line;

    while (!NIL_P(line = request_gets(argc, argv, self))) {
	rb_yield(line);
    }
    return self;
}

static VALUE request_each_byte(int argc, VALUE *argv, VALUE self)
d1035 2
a1036 1
    unsigned char c;
d1039 3
a1041 4
    while (data->pos < RSTRING(data->inbuf)->len) {
	c = RSTRING(data->inbuf)->ptr[data->pos];
	rb_yield(INT2FIX(c));
	data->pos++;
d1043 5
a1047 1
    return self;
d1053 1
a1053 24
    unsigned char c;

    Data_Get_Struct(self, request_data, data);
    if (data->pos >= RSTRING(data->inbuf)->len)
	return Qnil;
    c = RSTRING(data->inbuf)->ptr[data->pos];
    data->pos++;
    return INT2FIX(c);
}

static VALUE request_readchar(VALUE self)
{
    VALUE c = request_getc(self);

    if (NIL_P(c)) {
	rb_raise(rb_eEOFError, "End of file reached");
    }
    return c;
}

static VALUE request_ungetc(VALUE self, VALUE c)
{
    request_data *data;
    int cc = NUM2INT(c);
d1056 2
a1057 1
    if (data->pos == 0)
d1059 1
a1059 66
    data->pos--;
    RSTRING(data->inbuf)->ptr[data->pos] = cc;
    return Qnil;
}

static VALUE request_tell(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return INT2NUM(data->pos);
}

static VALUE request_seek(int argc, VALUE *argv, VALUE self)
{
    request_data *data;
    VALUE offset, ptrname;
    int whence;

    Data_Get_Struct(self, request_data, data);
    rb_scan_args(argc, argv, "11", &offset, &ptrname);
    if (argc == 1) whence = SEEK_SET;
    else whence = NUM2INT(ptrname);

    switch (whence) {
    case SEEK_SET:
	data->pos = NUM2LONG(offset);
	break;
    case SEEK_CUR:
	data->pos = data->pos + NUM2LONG(offset);
	break;
    case SEEK_END:
	data->pos = RSTRING(data->inbuf)->len + NUM2LONG(offset);
	break;
    default:
	rb_raise(rb_eArgError, "invalid whence: %d", whence);
	break;
    }
    if (data->pos < 0)
	data->pos = 0;
    if (data->pos > RSTRING(data->inbuf)->len)
	data->pos = RSTRING(data->inbuf)->len;

    return INT2FIX(0);
}

static VALUE request_rewind(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    data->pos = 0;
    return INT2FIX(0);
}

static VALUE request_set_pos(VALUE self, VALUE pos)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    data->pos = NUM2LONG(pos);
    if (data->pos < 0)
	data->pos = 0;
    if (data->pos > RSTRING(data->inbuf)->len)
	data->pos = RSTRING(data->inbuf)->len;
    return INT2NUM(pos);
d1067 1
a1067 1
    return data->pos >= RSTRING(data->inbuf)->len ? Qtrue : Qfalse;
d1189 3
d1199 1
a1199 16

    rb_cApacheConnection = rb_define_class_under(rb_mApache, "Connection", rb_cObject);
    rb_undef_method(CLASS_OF(rb_cApacheConnection), "new");
    rb_define_method(rb_cApacheConnection, "remote_ip",
		     connection_remote_ip, 0);
    rb_define_method(rb_cApacheConnection, "remote_host",
		     connection_remote_host, 0);
    rb_define_method(rb_cApacheConnection, "remote_logname",
		     connection_remote_logname, 0);
    rb_define_method(rb_cApacheConnection, "user", connection_user, 0);
    rb_define_method(rb_cApacheConnection, "auth_type",
		     connection_auth_type, 0);
    rb_define_method(rb_cApacheConnection, "local_ip",
		     connection_local_ip, 0);
    rb_define_method(rb_cApacheConnection, "local_host",
		     connection_local_host, 0);
d1226 31
d1272 1
d1278 1
a1278 1
    rb_define_method(rb_cApacheRequest, "filename", request_filename, 0);
d1283 1
a1283 1
    rb_define_method(rb_cApacheRequest, "status", request_status, 0);
d1285 1
a1285 1
    rb_define_method(rb_cApacheRequest, "status_line", request_status_line, 0);
d1308 2
d1312 1
d1318 8
a1326 6
    rb_define_method(rb_cApacheRequest, "gets", request_gets, -1);
    rb_define_method(rb_cApacheRequest, "readline", request_readline, -1);
    rb_define_method(rb_cApacheRequest, "readlines", request_readlines, -1);
    rb_define_method(rb_cApacheRequest, "each", request_each_line, -1);
    rb_define_method(rb_cApacheRequest, "each_line", request_each_line, -1);
    rb_define_method(rb_cApacheRequest, "each_byte", request_each_byte, 0);
a1327 7
    rb_define_method(rb_cApacheRequest, "readchar", request_readchar, 0);
    rb_define_method(rb_cApacheRequest, "ungetc", request_ungetc, 1);
    rb_define_method(rb_cApacheRequest, "tell", request_tell, 0);
    rb_define_method(rb_cApacheRequest, "seek", request_seek, -1);
    rb_define_method(rb_cApacheRequest, "rewind", request_rewind, 0);
    rb_define_method(rb_cApacheRequest, "pos", request_tell, 0);
    rb_define_method(rb_cApacheRequest, "pos=", request_set_pos, 1);
@


1.20
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.19 2001/04/10 08:03:55 shugo Exp $
d66 6
d103 1
d345 1
d369 1
d386 1
d393 1
a393 1
int ruby_request_outbuf_length(VALUE self)
d578 1
d718 1
a718 1
					     data->request->headers_out);
d723 12
a838 10
static VALUE request_escape_html(VALUE self, VALUE str)
{
    request_data *data;
    char *tmp;

    Data_Get_Struct(self, request_data, data);
    tmp = ap_escape_html(data->request->pool, STR2CSTR(str));
    return rb_str_new2(tmp);
}

d1103 112
d1219 2
d1234 2
d1281 1
d1283 2
a1284 1
    rb_define_method(rb_cApacheRequest, "unparsed_uri", request_unparsed_uri, 0);
d1289 2
a1290 1
    rb_define_method(rb_cApacheRequest, "request_time", request_request_time, 0);
d1294 4
a1297 2
    rb_define_method(rb_cApacheRequest, "status_line=", request_set_status_line, 1);
    rb_define_method(rb_cApacheRequest, "request_method", request_request_method, 0);
d1300 2
a1301 1
    rb_define_method(rb_cApacheRequest, "content_length", request_content_length, 0);
d1316 2
a1322 1
    rb_define_method(rb_cApacheRequest, "escape_html", request_escape_html, 1);
d1341 19
@


1.19
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.18 2001/04/09 03:55:26 shugo Exp $
d45 1
d53 8
d88 1
a88 1
static void free_table(table *tbl)
d90 1
a90 1
    /* do nothing */
d93 7
d102 1
a102 1
    return Data_Wrap_Struct(klass, 0, free_table, tbl);
d122 3
a124 1
    if (res == NULL)
a125 2
    else
	return rb_str_new2(res);
d259 3
a261 1
    if (res == NULL)
a262 2
    else
	return rb_str_new2(res);
d331 23
d358 1
d374 3
a376 2
    data->headers_in = ruby_create_table(rb_cApacheInTable, r->headers_in);
    data->headers_out = ruby_create_table(rb_cApacheTable, r->headers_out);
a555 3
static VALUE request_hostname(VALUE self)
{
    request_data *data;
d557 1
a557 5
    Data_Get_Struct(self, request_data, data);
    return rb_str_new2(data->request->hostname);
}

static VALUE request_unparsed_uri(VALUE self)
d562 4
a565 9
    return rb_str_new2(data->request->unparsed_uri);
}

static VALUE request_uri(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return rb_str_new2(data->request->uri);
d568 12
a579 18
static VALUE request_filename(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return rb_str_new2(data->request->filename);
}

static VALUE request_path_info(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (data->request->path_info)
	return rb_str_new2(data->request->path_info);
    else
	return Qnil;
}
a605 29
static VALUE request_status_line(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (data->request->status_line)
	return rb_str_new2(data->request->status_line);
    else
	return Qnil;
}

static VALUE request_set_status_line(VALUE self, VALUE str)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    data->request->status_line =
	ap_pstrdup(data->request->pool, STR2CSTR(str));
    return str;
}

static VALUE request_request_method(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return rb_str_new2(data->request->method);
}

a613 11
static VALUE request_args(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (data->request->args)
	return rb_str_new2(data->request->args);
    else
	return Qnil;
}

a624 11
static VALUE request_get_content_type(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (data->request->content_type)
	return rb_str_new2(data->request->content_type);
    else
	return Qnil;
}

a635 11
static VALUE request_get_content_encoding(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    if (data->request->content_encoding)
	return rb_str_new2(data->request->content_encoding);
    else
	return Qnil;
}

d693 4
d705 4
d1098 14
d1151 1
d1156 1
@


1.18
log
@* lib/net/imap.rb: fix typo.
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.17 2001/03/05 02:06:35 shugo Exp $
d323 1
a323 1
VALUE ruby_create_request(request_rec *r)
a326 2
    char buff[BUFSIZ];
    int len;
d332 1
a332 1
    data->inbuf = rb_tainted_str_new("", 0);
a338 8
    ap_hard_timeout("get_client_block", r);
    if (ap_should_client_block(r)) {
	while ((len = ap_get_client_block(r, buff, BUFSIZ)) > 0) {
	    rb_str_cat(data->inbuf, buff, len);
	}
    }
    ap_kill_timeout(r);

d1224 4
d1329 37
@


1.17
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.16 2001/01/24 07:54:37 shugo Exp $
d332 1
a332 1
			      (void (*) _((void*))) request_mark, free, data);
@


1.16
log
@fixed Apache::InTable#[].
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.15 2000/12/12 05:41:07 shugo Exp $
d576 17
d1184 2
@


1.15
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.14 2000/12/06 05:37:07 shugo Exp $
d1127 1
a1127 1
    rb_define_alias(rb_cApacheTable, "[]", "get");
d1129 1
a1129 1
    rb_define_alias(rb_cApacheTable, "[]=", "set");
d1142 1
@


1.14
log
@shugo

* intern.h: added prototype of rb_exec_end_proc()
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.13 2000/11/23 09:25:06 shugo Exp $
d629 1
d742 1
d756 1
d779 1
d803 1
d825 1
@


1.13
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.12 2000/10/14 14:55:40 shugo Exp $
a630 1
#if defined(RUBY_VERSION_CODE) && RUBY_VERSION_CODE >= 150
a631 3
#else
    return s ? rb_str2inum(s, 10) : Qnil;
#endif
@


1.12
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.11 2000/10/14 04:27:56 shugo Exp $
d334 2
a335 2
    data->inbuf = rb_str_new("", 0);
    data->outbuf = rb_str_new("", 0);
@


1.11
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.10 2000/10/04 15:38:45 shugo Exp $
d576 21
d1107 5
d1164 2
d1207 1
@


1.10
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.9 2000/08/03 07:29:41 shugo Exp $
d73 2
a74 1
    strcpy(buff, RSTRING(url)->ptr);
d103 1
a103 2
    Check_Type(name, T_STRING);
    key = RSTRING(name)->ptr;
a115 2
    Check_Type(name, T_STRING);
    Check_Type(val, T_STRING);
d117 1
a117 1
    ap_table_set(tbl, RSTRING(name)->ptr, RSTRING(val)->ptr);
a124 2
    Check_Type(name, T_STRING);
    Check_Type(val, T_STRING);
d126 1
a126 1
    ap_table_setn(tbl, RSTRING(name)->ptr, RSTRING(val)->ptr);
a133 2
    Check_Type(name, T_STRING);
    Check_Type(val, T_STRING);
d135 1
a135 1
    ap_table_merge(tbl, RSTRING(name)->ptr, RSTRING(val)->ptr);
a142 2
    Check_Type(name, T_STRING);
    Check_Type(val, T_STRING);
d144 1
a144 1
    ap_table_mergen(tbl, RSTRING(name)->ptr, RSTRING(val)->ptr);
a151 1
    Check_Type(name, T_STRING);
d153 1
a153 1
    ap_table_unset(tbl, RSTRING(name)->ptr);
a160 2
    Check_Type(name, T_STRING);
    Check_Type(val, T_STRING);
d162 1
a162 1
    ap_table_add(tbl, RSTRING(name)->ptr, RSTRING(val)->ptr);
a169 2
    Check_Type(name, T_STRING);
    Check_Type(val, T_STRING);
d171 1
a171 1
    ap_table_addn(tbl, RSTRING(name)->ptr, RSTRING(val)->ptr);
d237 1
a237 2
    Check_Type(name, T_STRING);
    key = RSTRING(name)->ptr;
d317 2
a318 1
    rb_gc_mark(data->buff);
d327 2
d334 2
a335 1
    data->buff = rb_str_new("", 0);
d339 10
d352 1
a352 1
int ruby_request_buffer_length(VALUE self)
d357 1
a357 1
    return RSTRING(data->buff)->len;
d365 1
a365 1
    return data->buff;
d373 1
a373 1
    return rb_funcall2(data->buff, rb_frame_last_func(), argc, argv);
d381 2
a382 2
    RSTRING(data->buff)->len = 0;
    RSTRING(data->buff)->ptr[0] = '\0';
d393 1
a393 1
    rb_str_cat(data->buff, RSTRING(str)->ptr, RSTRING(str)->len);
d404 1
a404 1
    rb_str_cat(data->buff, &ch, 1);
d519 3
a521 3
    if (RSTRING(data->buff)->len > 0) {
	ap_rwrite(RSTRING(data->buff)->ptr,
		  RSTRING(data->buff)->len, data->request);
a632 1
    Check_Type(str, T_STRING);
d635 1
a635 1
	ap_pstrdup(data->request->pool, RSTRING(str)->ptr);
a654 1
    Check_Type(str, T_STRING);
d657 1
a657 1
	ap_pstrdup(data->request->pool, RSTRING(str)->ptr);
d697 1
a697 1
	    ap_pstrdup(data->request->pool, RSTRING(str)->ptr);
d734 1
a735 1
    request_data *data;
a752 1
    VALUE assoc;
d757 1
d819 1
a820 1
    request_data *data;
d827 108
a934 1
static VALUE send_to_stdin(int argc, VALUE *argv, VALUE self)
d936 148
a1083 1
    return rb_funcall2(rb_stdin, rb_frame_last_func(), argc, argv);
a1158 1
    rb_define_alias(rb_cApacheRequest, "each", "each_header");
d1162 17
a1178 8
    rb_define_method(rb_cApacheRequest, "read", send_to_stdin, -1);
    rb_define_method(rb_cApacheRequest, "gets", send_to_stdin, -1);
    rb_define_method(rb_cApacheRequest, "readline", send_to_stdin, -1);
    rb_define_method(rb_cApacheRequest, "getc", send_to_stdin, -1);
    rb_define_method(rb_cApacheRequest, "readchar", send_to_stdin, -1);
    rb_define_method(rb_cApacheRequest, "ungetc", send_to_stdin, -1);
    rb_define_method(rb_cApacheRequest, "tell", send_to_stdin, -1);
    rb_define_method(rb_cApacheRequest, "seek", send_to_stdin, -1);
@


1.9
log
@q
@
text
@d2 5
a6 2
 * $Id: apachelib.c,v 1.8 2000/06/14 03:27:33 shugo Exp $
 * Copyright (C) 1998-1999  Network Applied Communication Laboratory, Inc.
@


1.8
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.7 2000/05/24 04:59:00 shugo Exp $
d42 2
a43 1
VALUE rb_mApacheWritable;
d75 251
d329 2
d337 1
a337 1

d343 2
d701 16
d839 24
d899 2
@


1.7
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.6 2000/05/18 08:47:41 shugo Exp $
d455 1
a455 1
    val = ap_table_get(data->request->headers_in, STR2CSTR(key));
@


1.6
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.5 2000/03/30 08:08:11 shugo Exp $
d79 1
a79 1
VALUE ruby_create_request(request_rec *r, int sync)
a89 1
    data->sync = sync;
a103 1
    int len;
a111 1
    int len;
d134 2
a135 7
    if (data->sync) {
	len = ap_rwrite(RSTRING(str)->ptr, RSTRING(str)->len, data->request);
    }
    else {
	rb_str_cat(data->buff, RSTRING(str)->ptr, RSTRING(str)->len);
	len = RSTRING(str)->len;
    }
d145 1
a145 6
    if (data->sync) {
	ap_rputc(ch, data->request);
    }
    else {
	rb_str_cat(data->buff, &ch, 1);
    }
d241 1
a241 1
static VALUE request_send_http_header(VALUE self)
d246 1
a246 6
    if (data->sync) {
	ap_send_http_header(data->request);
    }
    else {
	data->send_http_header = 1;
    }
d250 1
a250 1
VALUE rb_request_flush(VALUE self)
d257 2
a258 1
	data->send_http_header = 0;
a263 19

    return self;
}

static VALUE request_get_sync(VALUE self)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    return data->sync ? Qtrue : Qfalse;
}

static VALUE request_set_sync(VALUE self, VALUE mode)
{
    request_data *data;

    Data_Get_Struct(self, request_data, data);
    data->sync = RTEST(mode);
    return mode;
d325 8
d579 2
a580 4
    rb_define_method(rb_cApacheRequest, "flush", rb_request_flush, 0);
    rb_define_method(rb_cApacheRequest, "sync", request_get_sync, 0);
    rb_define_method(rb_cApacheRequest, "sync=", request_set_sync, 1);
    rb_define_method(rb_cApacheRequest, "send_http_header", request_send_http_header, 0);
d588 1
@


1.5
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.4 2000/03/28 05:41:57 shugo Exp $
d86 1
a86 1
			      request_mark, free, data);
d379 3
d383 1
@


1.4
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.3 1999/07/06 09:36:53 shugo Exp $
d469 1
a469 1
static VALUE request_aref(VALUE self, VALUE key)
d472 1
d475 3
d516 3
d539 3
d559 3
@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.2 1999/05/19 00:45:56 shugo Exp $
d35 1
a35 1

d79 1
a79 1
VALUE ruby_create_request(request_rec *r)
d90 1
a90 1
    data->sync = 1;
d94 36
d581 3
d713 1
a713 1
		    INT2NUM(HTTP_FAILED_DEPENDENCY));
d731 1
a731 1
		    INT2NUM(HTTP_INSUFFICIENT_STORAGE));
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.1.1.1 1999/04/20 08:41:05 shugo Exp $
d317 1
a317 1
static VALUE request_method(VALUE self)
d561 1
a561 1
    rb_define_method(rb_cApacheRequest, "method", request_method, 0);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id: apachelib.c,v 1.1.1.1 1999/04/20 07:13:15 shugo Exp $
d46 2
d143 1
a143 1
	    request_write(out, rb_str_new2("nil"));
d173 1
a173 1
	    tmp = rb_str_new2("[...]");
d193 1
a193 1
	    line = rb_str_new2("nil");
@


1.1.1.1
log
@
@
text
@@
