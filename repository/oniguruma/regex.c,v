head	1.1;
branch	1.1.1;
access;
symbols
	onigd20020424:1.1.1.8
	onigd20020416:1.1.1.7
	onigd20020401:1.1.1.6
	onigd20020325:1.1.1.5
	onigd20020313:1.1.1.4
	onigd20020306:1.1.1.3
	onigd20020304:1.1.1.2
	onigd20020225:1.1.1.1
	KOSAKO:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2002.03.04.03.14.06;	author knu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.03.04.03.14.06;	author knu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.03.04.03.20.52;	author knu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.03.06.04.40.25;	author knu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.03.13.08.57.48;	author knu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.03.25.05.22.51;	author knu;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.04.02.05.34.16;	author knu;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.04.16.07.14.22;	author knu;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2002.04.24.07.50.39;	author knu;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/**********************************************************************

  regex.c -  Oni Guruma (regular expression library)

  Copyright (C) 2002  K.Kosako (kosako@@sofnec.co.jp)

**********************************************************************/

/* for debug */
/* #define REG_DEBUG_COMPILE */
/* #define REG_DEBUG_SEARCH */
/* #define REG_DEBUG_MATCH */
/* #define REG_DONT_OPTIMIZE */
/* #define REG_DEBUG */

/* for get byte-code statistical data. */
/* #define REG_DEBUG_STATISTICS */

#if defined(REG_DEBUG_MATCH) || defined(REG_DEBUG_COMPILE) || \
    defined(REG_DEBUG_STATISTICS)
#ifndef REG_DEBUG
#define REG_DEBUG
#endif
#endif

/* config */
#define RECYCLE_NODE
#define USE_ERROR_MESSAGE_STRING
#define INIT_MATCH_STACK_SIZE                    160
#define APPLY_POSITION_SEARCH_THRESHOLD_LENGTH     7
/* byte code convert [push, exact...] --> [push_or_jump_exact, exact...] */
#define USE_OP_PUSH_OR_JUMP_EXACT


/* include headers */
#include "config.h"

/* interface to external system */
#if defined(RUBY_PLATFORM) || defined(RUBY)
#include "ruby.h"
#include "rubysig.h"      /* for DEFER_INTS, ENABLE_INTS */
#define THREAD_ATOMIC_START     DEFER_INTS
#define THREAD_ATOMIC_END       ENABLE_INTS
#else
#define THREAD_ATOMIC_START
#define THREAD_ATOMIC_END
#define xmalloc     malloc
#define xrealloc    realloc
#define xfree       free

/* non ruby platform config */
#define VALID_WORD_BEGIN_END          /* "\<": word-begin, "\>": word-end */
#define DEFAULT_TRANSTABLE_EXIST    1
#endif /* else RUBY_PLATFORM */

#define xmemset     memset
#define xmemcpy     memcpy
#define xmemmove    memmove
#define xalloca     alloca

#if defined(HAVE_ALLOCA_H) && !defined(__GNUC__)
#include <alloca.h>
#endif

#ifdef HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include <ctype.h>
#include <sys/types.h>

#ifdef REG_DEBUG
# include <stdio.h>
#endif

#include "regex.h"

extern char* RegexErrorCodeToStr(int code)
{
  char *p;

  if (code >= 0) return NULL;

  switch (code) {
#ifdef USE_ERROR_MESSAGE_STRING
  case REG_MISMATCH:
    p = "mismatch"; break;
  case REGERR_MEMORY:
    p = "fail to memory allocation"; break;
  case REGERR_TYPE_BUG:
    p = "undefined type (bug)"; break;
  case REGERR_STACK_BUG:
    p = "stack error (bug)"; break;
  case REGERR_UNDEFINED_BYTECODE:
    p = "undefined bytecode (bug)"; break;
  case REGERR_UNEXPECTED_BYTECODE:
    p = "unexpected bytecode (bug)"; break;
  case REGERR_TABLE_FOR_IGNORE_CASE_IS_NOT_SETTED:
    p = "table for ignore-case is not setted"; break;
  case REGERR_DEFAULT_ENCODING_IS_NOT_SETTED:
    p = "default multibyte-encoding is not setted"; break;
  case REGERR_SPECIFIED_ENCODING_CANT_CONVERT_TO_WIDE_CHAR:
    p = "can't convert to wide-char on specified multibyte-encoding"; break;
  case REGERR_END_PATTERN_AT_LEFT_BRACE:
    p = "end pattern at left brace"; break;
  case REGERR_END_PATTERN_AT_LEFT_BRACKET:
    p = "end pattern at left bracket"; break;
  case REGERR_EMPTY_CHAR_CLASS:
    p = "empty char-class"; break;
  case REGERR_PREMATURE_END_OF_CHAR_CLASS:
    p = "premature end of char-class"; break;
  case REGERR_END_PATTERN_AT_BACKSLASH:
    p = "end pattern at backslash"; break;
  case REGERR_END_PATTERN_AT_META:
    p = "end pattern at meta"; break;
  case REGERR_END_PATTERN_AT_CONTROL:
    p = "end pattern at control"; break;
  case REGERR_END_PATTERN_AFTER_BACKSLASH:
    p = "end pattern after backslash"; break;
  case REGERR_META_CODE_SYNTAX:
    p = "illegal meta-code syntax"; break;
  case REGERR_CONTROL_CODE_SYNTAX:
    p = "illegal control-code syntax"; break;
  case REGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE:
    p = "char-class value at end of range"; break;
  case REGERR_CHAR_CLASS_VALUE_AT_START_OF_RANGE:
    p = "char-class value at start of range"; break;
  case REGERR_TARGET_OF_REPEAT_QUALIFIER_NOT_FOUND:
    p = "target of repeat-qualifier not found"; break;
  case REGERR_NESTED_REPEAT_OPERATOR:
    p = "nested repeat operator"; break;
  case REGERR_UNMATCHED_RIGHT_PARENTHESIS:
    p = "unmatched right parenthesis"; break;
  case REGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS:
    p = "end pattern with unmatched parenthesis"; break;
  case REGERR_END_PATTERN_AT_GROUP_OPTION:
    p = "end pattern at group option"; break;
  case REGERR_UNDEFINED_GROUP_OPTION:
    p = "undefined group option"; break;
  case REGERR_END_PATTERN_AT_GROUP_COMMENT:
    p = "end pattern at group comment"; break;
  case REGERR_INVALID_POSIX_CHAR_CLASS:
    p = "invalid posix char-class"; break;
  case REGERR_TOO_BIG_NUMBER:
    p = "too big number"; break;
  case REGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE:
    p = "too big number for repeat range"; break;
  case REGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE:
    p = "upper is smaller than lower in repeat range"; break;
  case REGERR_RIGHT_SMALLER_THAN_LEFT_IN_CLASS_RANGE:
    p = "right is smaller than left in char-class range"; break;
  case REGERR_TOO_MANY_MULTI_BYTE_RANGES:
    p = "too many multibyte code ranges specified"; break;
  case REGERR_TOO_SHORT_MULTI_BYTE_STRING:
    p = "too short multibyte code string"; break;
  case REGERR_TOO_BIG_BACKREF_NUMBER:
    p = "too big backref-number"; break;

  default:
    p = "undefined error code"; break;
#else
  default:
    p = "error message is not supported"; break;
#endif
  }

  return p;
}

/* optimize flags */
#define REG_OPTIMIZE_NONE         0
#define REG_OPTIMIZE_EXACT        1     /* Slow Search */
#define REG_OPTIMIZE_EXACT_BM     2     /* Boyer Moore Search */
#define REG_OPTIMIZE_EXACT_IC     3     /* Slow Search (ignore case) */
#define REG_OPTIMIZE_MAP          5     /* char map */

/* mem stats */
#define MEM_STAT_BITS_NUM      (SIZEOF_INT * 8)
#define MEM_STATS_ON_AT(stats,n) do {\
  if ((n) < MEM_STAT_BITS_NUM)\
    (stats) |= (1 << (n));\
  else\
    (stats) |= 1;\
} while (0)

#define GET_MEM_STATS_AT(stats,n) \
  ((n) < MEM_STAT_BITS_NUM ?  ((stats) & (1 << n)) : ((stats) & 1))


#define INT_MAX_LIMIT           ((1UL << (SIZEOF_INT * 8 - 1)) - 1)

typedef unsigned int   WCInt;
#define SIZE_WCINT     sizeof(WCInt)

#define INFINITE_DISTANCE  ~((RegDistance )0)

#define DISTANCE_INC(d,inc)  do {\
  if ((d) <= INFINITE_DISTANCE - (inc)) (d) += (inc);\
  else (d) = INFINITE_DISTANCE;\
} while (0)

static RegDistance DistanceMultiply(RegDistance d, int m)
{
  if (d < INFINITE_DISTANCE / m)
    return d * m;
  else
    return INFINITE_DISTANCE;
}

static RegDistance DistanceDistance(RegDistance d1, RegDistance d2)
{
  if (d1 == INFINITE_DISTANCE || d2 == INFINITE_DISTANCE)
    return INFINITE_DISTANCE;

  if (d1 > d2) return d1 - d2;
  else         return d2 - d1;
}


RegCharCodeType RegDefaultCharCode = REGCODE_DEFAULT;
static UChar*   DefaultTransTable = (UChar* )0;
static UChar    AmbiguityTable[REG_CHAR_TABLE_SIZE];

#define IS_AMBIGUITY_CHAR(trans, c) \
  (((trans) == DefaultTransTable) ? (AmbiguityTable[(c)] >= 2) : \
                                    (trans)[(c)+256] >= 2)

#ifdef DEFAULT_TRANSTABLE_EXIST

static UChar DTT[] = {
  '\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
  '\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
  '\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
  '\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
  '\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
  '\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
  '\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
  '\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
  '\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
  '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
  '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
  '\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
  '\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
  '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
  '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
  '\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
  '\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
  '\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
  '\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
  '\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
  '\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
  '\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
  '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
  '\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
  '\300', '\301', '\302', '\303', '\304', '\305', '\306', '\307',
  '\310', '\311', '\312', '\313', '\314', '\315', '\316', '\317',
  '\320', '\321', '\322', '\323', '\324', '\325', '\326', '\327',
  '\330', '\331', '\332', '\333', '\334', '\335', '\336', '\337',
  '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
  '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
  '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
  '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
};
#endif


#if defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
# define IS_ASCII(c) 1
#else
# define IS_ASCII(c) isascii(c)
#endif

#ifdef isblank
# define IS_BLANK(c) (IS_ASCII(c) && isblank(c))
#else
# define IS_BLANK(c) ((c) == ' ' || (c) == '\t')
#endif
#ifdef isgraph
# define IS_GRAPH(c) (IS_ASCII(c) && isgraph(c))
#else
# define IS_GRAPH(c) (IS_ASCII(c) && isprint(c) && !isspace(c))
#endif

#define IS_PRINT(c)  (isprint(c)  && IS_ASCII(c))
#define IS_ALNUM(c)  (isalnum(c)  && IS_ASCII(c))
#define IS_ALPHA(c)  (isalpha(c)  && IS_ASCII(c))
#define IS_LOWER(c)  (islower(c)  && IS_ASCII(c))
#define IS_UPPER(c)  (isupper(c)  && IS_ASCII(c))
#define IS_CNTRL(c)  (iscntrl(c)  && IS_ASCII(c))
#define IS_PUNCT(c)  (ispunct(c)  && IS_ASCII(c))
#define IS_SPACE(c)  (isspace(c)  && IS_ASCII(c))
#define IS_DIGIT(c)  (isdigit(c)  && IS_ASCII(c))
#define IS_XDIGIT(c) (isxdigit(c) && IS_ASCII(c))
#define IS_ODIGIT(c) (IS_DIGIT(c) && (c) < '8')

#define DIGITVAL(c)    ((c) - '0')
#define ODIGITVAL(c)   DIGITVAL(c)
#define XDIGITVAL(c) \
  (IS_DIGIT(c) ? DIGITVAL(c) : (IS_UPPER(c) ? (c) - 'A' + 10 : (c) - 'a' + 10))

#define IS_SINGLELINE(option)    ((option) & REG_OPTION_SINGLELINE)
#define IS_MULTILINE(option)     ((option) & REG_OPTION_MULTILINE)
#define IS_IGNORECASE(option)    ((option) & REG_OPTION_IGNORECASE)
#define IS_EXTEND(option)        ((option) & REG_OPTION_EXTEND)
#define IS_FIND_LONGEST(option)  ((option) & REG_OPTION_FIND_LONGEST)
#define IS_POSIXLINE(option)     (IS_SINGLELINE(option) && IS_MULTILINE(option))

#ifdef NEWLINE
#undef NEWLINE
#endif
#define NEWLINE     '\n'
#define IS_NULL(p)                    (((void*)(p)) == (void*)0)
#define IS_NOT_NULL(p)                (((void*)(p)) != (void*)0)
#define IS_NEWLINE(c)                 ((c) == NEWLINE)
#define CHECK_NULL_RETURN(p)          if (IS_NULL(p)) return NULL
#define CHECK_NULL_RETURN_VAL(p,val)  if (IS_NULL(p)) return (val)

/* bitset */
#define BITS_PER_BYTE      8
#define SINGLE_BYTE_SIZE   (1 << BITS_PER_BYTE)
#define BITS_IN_ROOM       (sizeof(Bits) * BITS_PER_BYTE)
#define BITSET_SIZE        (SINGLE_BYTE_SIZE / BITS_IN_ROOM)

typedef unsigned int   Bits;
typedef Bits           BitSet[BITSET_SIZE];
typedef Bits*          BitSetRef;

#define NULL_UCHARP       ((UChar* )0)

#define BITSET_CLEAR(bs) do {\
  int i;\
  for (i = 0; i < BITSET_SIZE; i++) { (bs)[i] = 0; }\
} while (0)

#define _BS_ROOM(bs,pos)           (bs)[pos / BITS_IN_ROOM]
#define _BS_BIT(pos)               (1 << (pos % BITS_IN_ROOM))

#define BITSET_AT(bs, pos)         (_BS_ROOM(bs,pos) & _BS_BIT(pos))
#define BITSET_SET_BIT(bs, pos)    _BS_ROOM(bs,pos) |= _BS_BIT(pos)
#define BITSET_CLEAR_BIT(bs, pos)  _BS_ROOM(bs,pos) &= ~(_BS_BIT(pos))

#define SIZE_BITSET        sizeof(BitSet)

static int BitSetIsEmpty(BitSetRef bs)
{
  int i;
  for (i = 0; i < BITSET_SIZE; i++) {
    if (bs[i] != 0) return 0;
  }
  return 1;
}

static int BitSetOnNum(BitSetRef bs)
{
  int i, n;

  n = 0;
  for (i = 0; i < SINGLE_BYTE_SIZE; i++) {
    if (BITSET_AT(bs, i)) n++;
  }
  return n;
}


/* byte-buffer */
typedef struct _BBuf {
  UChar* p;
  unsigned int used;
  unsigned int alloc;
} BBuf;

static int BBufInit(BBuf* buf, int size)
{
  buf->p = (UChar* )xmalloc(size);
  if (IS_NULL(buf->p)) return(REGERR_MEMORY);

  buf->alloc = size;
  buf->used  = 0;
  return 0;
}

#define BBUF_INIT(buf,size)    BBufInit((BBuf* )(buf), (size))

#define BBUF_SIZE_INC(buf,inc) do{\
  (buf)->alloc += (inc);\
  (buf)->p = (UChar* )xrealloc((buf)->p, (buf)->alloc);\
  if (IS_NULL((buf)->p)) return(REGERR_MEMORY);\
} while (0)

#define BBUF_EXPAND(buf,low) do{\
  do { (buf)->alloc *= 2; } while ((buf)->alloc < low);\
  (buf)->p = (UChar* )xrealloc((buf)->p, (buf)->alloc);\
  if (IS_NULL((buf)->p)) return(REGERR_MEMORY);\
} while (0)

#define BBUF_ENSURE_SIZE(buf,size) do{\
  int new_alloc = (buf)->alloc;\
  while (new_alloc < (size)) { new_alloc *= 2; }\
  if ((buf)->alloc != new_alloc) {\
    (buf)->p = (UChar* )xrealloc((buf)->p, new_alloc);\
    if (IS_NULL((buf)->p)) return(REGERR_MEMORY);\
    (buf)->alloc = new_alloc;\
  }\
} while (0)

#define BBUF_WRITE(buf,pos,bytes,n) do{\
  int used = (pos) + (n);\
  if ((buf)->alloc < used) BBUF_EXPAND((buf),used);\
  xmemcpy((buf)->p + (pos), (bytes), (n));\
  if ((buf)->used < used) (buf)->used = used;\
} while (0)

#define BBUF_WRITE1(buf,pos,byte) do{\
  int used = (pos) + 1;\
  if ((buf)->alloc < used) BBUF_EXPAND((buf),used);\
  (buf)->p[(pos)] = (byte);\
  if ((buf)->used < used) (buf)->used = used;\
} while (0)

#define BBUF_ADD(buf,bytes,n)    BBUF_WRITE((buf),(buf)->used,(bytes),(n))
#define BBUF_ADD1(buf,byte)      BBUF_WRITE1((buf),(buf)->used,(byte))

/* from < to */
#define BBUF_MOVE_RIGHT(buf,from,to,n) do {\
  if ((to) + (n) > (buf)->alloc) BBUF_EXPAND((buf),(to) + (n));\
  xmemmove((buf)->p + (to), (buf)->p + (from), (n));\
  if ((to) + (n) > (buf)->used) (buf)->used = (to) + (n);\
} while (0)

/* from > to */
#define BBUF_MOVE_LEFT(buf,from,to,n) do {\
  xmemmove((buf)->p + (to), (buf)->p + (from), (n));\
} while (0)

/* from > to */
#define BBUF_MOVE_LEFT_REDUCE(buf,from,to) do {\
  xmemmove((buf)->p + (to), (buf)->p + (from), (buf)->used - (from));\
  (buf)->used -= (from - to);\
} while (0)

#define BBUF_INSERT(buf,pos,bytes,n) do {\
  if (pos >= (buf)->used) {\
    BBUF_WRITE(buf,pos,bytes,n);\
  }\
  else {\
    BBUF_MOVE_RIGHT((buf),(pos),(pos) + (n),((buf)->used - (pos)));\
    xmemcpy((buf)->p + (pos), (bytes), (n));\
  }\
} while (0)

#define BBUF_GET_BYTE(buf, pos) (buf)->p[(pos)]


/* node type */
#define N_EMPTY                 0
#define N_LIST                  1
#define N_ALT                   2
#define N_STRING                3
#define N_STRING_RAW            4  /* immediate bytes (backslashed-number) */
#define N_CCLASS                5
#define N_CTYPE                 6
#define N_ANYCHAR               7
#define N_ANCHOR                8
#define N_BACKREF               9
#define N_QUALIFIER            10
#define N_OPTION               11
#define N_EFFECT               12

#define NTYPE(node)            ((node)->type)
#define NCONS(node)            ((node)->u.cons)
#define NSTRING(node)          ((node)->u.str)
#define NCCLASS(node)          ((node)->u.cclass)
#define NCTYPE(node)           ((node)->u.ctype)
#define NQUALIFIER(node)       ((node)->u.qualifier)
#define NANCHOR(node)          ((node)->u.anchor)
#define NBACKREF(node)         ((node)->u.effect)
#define NOPTION(node)          ((node)->u.opt)
#define NEFFECT(node)          ((node)->u.effect)

#define CTYPE_WORD              1
#define CTYPE_NOT_WORD          2
#define CTYPE_WORD_BOUND        3
#define CTYPE_NOT_WORD_BOUND    4
#define CTYPE_WORD_BEGIN        5
#define CTYPE_WORD_END          6

#define ANCHOR_BEGIN_BUF        (1 << 0)
#define ANCHOR_BEGIN_LINE       (1 << 1)
#define ANCHOR_BEGIN_POSITION   (1 << 2)
#define ANCHOR_END_BUF          (1 << 3)
#define ANCHOR_SEMI_END_BUF     (1 << 4)
#define ANCHOR_END_LINE         (1 << 5)
#define ANCHOR_ANYCHAR_STAR     (1 << 6)   /* ".*" optimize info */
#define ANCHOR_ANYCHAR_STAR_PL  (1 << 7)   /* ".*" optimize info (posix-line) */

#define ANCHOR_ANYCHAR_STAR_MASK (ANCHOR_ANYCHAR_STAR | ANCHOR_ANYCHAR_STAR_PL)
#define ANCHOR_END_BUF_MASK      (ANCHOR_END_BUF | ANCHOR_SEMI_END_BUF)

#define EFFECT_MEMORY           1
#define EFFECT_PREC_READ        2
#define EFFECT_PREC_READ_NOT    3
#define EFFECT_STOP_BACKTRACK   4

#define REPEAT_INFINITE         -1
#define IS_REPEAT_INFINITE(n)   ((n) == REPEAT_INFINITE)

#define NODE_STR_MARGIN         16
#define NODE_STR_BUF_SIZE       28

typedef struct {
  UChar* s;
  UChar* end;
  int    capa;    /* (allocated size - 1) or 0: use buf[] */
  UChar  buf[NODE_STR_BUF_SIZE];
} StrNode;

typedef struct {
  int    not;
  BitSet bs;
  BBuf*  mbuf;     /* multi-byte info or NULL */
} CClassNode;

typedef struct {
  struct _Node* target;
  int lower;
  int upper;
  int greedy;
  int target_empty;   /* target can match with empty data */
  struct _Node* head_exact;
} QualifierNode;

typedef struct {
  RegOptionType option;
  struct _Node* target;
} OptionNode;

typedef struct {
  int type;
  int regnum;
  struct _Node* target;
} EffectNode;

typedef struct _Node {
  int type;
  union {
    StrNode       str;
    CClassNode    cclass;
    QualifierNode qualifier;
    OptionNode    opt;
    EffectNode    effect;
    struct {
      struct _Node* left;
      struct _Node* right;
    } cons;
    struct {
      int type;
    } anchor;
    struct {
      int type;
    } ctype;
  } u;
} Node;


/* scan pattern methods */
#define PFETCH(c)   do { (c) = *p++; } while (0)
#define PUNFETCH    p--
#define PPEEK       (PEND ? -1 : *p)
#define PEND        (p < end ? 0 : 1)

#define TTRANS(table,c)        ((table)[c])

/* methods for support multi-byte code, */
#define ismb(code,c)                  (mblen((code),(c)) != 1)
#define MB2WC(p,end,code)             mb2wc((p),(end),(code))


#ifdef REG_RUBY_M17N

#define MB2WC_AVAILABLE(enc)         (mbmaxlen(enc) <= 4 && mbmaxlen(enc) > 0)

#define mbmaxlen(enc)                 m17n_mbmaxlen(enc)
#define mblen(enc,c)                  m17n_mbclen(enc,c)
#define mbmaxlen_dist(enc) \
      (mbmaxlen(enc) > 0 ? mbmaxlen(enc) : INFINITE_DIST)

#define IS_SINGLEBYTE_CODE(enc)    (m17n_mbmaxlen(enc) == 1)
/* #define IS_INDEPENDENT_TRAIL(enc)  m17n_independent_trail(enc) */
#define IS_INDEPENDENT_TRAIL(enc)  IS_SINGLEBYTE_CODE(enc)

#define IS_CODE_ASCII(enc,c)     IS_ASCII(c)
#define IS_CODE_GRAPH(enc,c)     IS_GRAPH(c)
#define IS_CODE_PRINT(enc,c)     m17n_isprint(enc,c)
#define IS_CODE_ALNUM(enc,c)     m17n_isalnum(enc,c)
#define IS_CODE_ALPHA(enc,c)     m17n_isalpha(enc,c)
#define IS_CODE_LOWER(enc,c)     m17n_islower(enc,c)
#define IS_CODE_UPPER(enc,c)     m17n_isupper(enc,c)
#define IS_CODE_CNTRL(enc,c)     m17n_iscntrl(enc,c)
#define IS_CODE_PUNCT(enc,c)     m17n_ispunct(enc,c)
#define IS_CODE_SPACE(enc,c)     m17n_isspace(enc,c)
#define IS_CODE_BLANK(enc,c)     IS_BLANK(c)
#define IS_CODE_DIGIT(enc,c)     m17n_isdigit(enc,c)
#define IS_CODE_XDIGIT(enc,c)    m17n_isxdigit(enc,c)

#define IS_CODE_WORD(enc,c)      m17n_iswchar(enc,c)
#define ISNOT_CODE_WORD(code,c)  (!m17n_iswchar(enc,c))

#define IS_WORD_STR(code,s,end) \
  (ismb((code),*(s)) ? (s + mblen((code),*(s)) <= (end)) : \
                       m17n_iswchar(enc,*(s)))
#define IS_WORD_STR_INC(code,s,end) \
  (ismb((code),*(s)) ? ((s) += mblen((code),*(s)), (s) <= (end)) : \
                       (s++, m17n_iswchar(enc,s[-1])))

#define IS_WORD_HEAD(ence,c) (ismb(enc,c) ? 1 : IS_CODE_WORD(enc,c))

static WCInt mb2wc(UChar* p, UChar* end, RegCharCodeType code)
{
  int c, i, len;
  WCInt n;

  PFETCH(c);
  len = mblen(code,c);
  n = c;
  if (len == 1) return n;

  for (i = 1; i < len; i++) {
    if (PEND) break;
    PFETCH(c);
    n <<= 8;  n += c;
  }

  len = mbmaxlen(code) - i;
  while (len-- > 0) {
    n <<= 8; 
  }
  return n;
}

#else  /* REG_RUBY_M17N */

const char REG_MBLEN_TABLE[][REG_CHAR_TABLE_SIZE] = {
  { /* ascii */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
  },
  { /* utf8 */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 1, 1
  },
  { /* euc-jp */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1
  },
  { /* sjis */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
  }
};

static const char SJIS_FOLLOW_TABLE[SINGLE_BYTE_SIZE] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0
};

static int MbMaxlen(RegCharCodeType code)
{
  /* can't use switch statement, code isn't int type. */
       if (code == REGCODE_ASCII)  return 1;
  else if (code == REGCODE_EUCJP)  return 3;
  else if (code == REGCODE_SJIS)   return 2;
  else return 6; /* REGCODE_UTF8 */
}

#define MB2WC_AVAILABLE(code)       1

#define mbmaxlen_dist(code)         mbmaxlen(code)
#define mbmaxlen(code)              MbMaxlen(code)
#define mblen(code,c)               (code)[(c)]

#define IS_SINGLEBYTE_CODE(code)    ((code) == REGCODE_ASCII)
#define IS_INDEPENDENT_TRAIL(code)  ((code) <= REGCODE_UTF8)

#define IS_CODE_ASCII(code,c)        IS_ASCII(c)
#define IS_CODE_GRAPH(code,c)        IS_GRAPH(c)
#define IS_CODE_PRINT(code,c)        IS_PRINT(c)
#define IS_CODE_ALNUM(code,c)        IS_ALNUM(c)
#define IS_CODE_ALPHA(code,c)        IS_ALPHA(c)
#define IS_CODE_LOWER(code,c)        IS_LOWER(c)
#define IS_CODE_UPPER(code,c)        IS_UPPER(c)
#define IS_CODE_CNTRL(code,c)        IS_CNTRL(c)
#define IS_CODE_PUNCT(code,c)        IS_PUNCT(c)
#define IS_CODE_SPACE(code,c)        IS_SPACE(c)
#define IS_CODE_BLANK(code,c)        IS_BLANK(c)
#define IS_CODE_DIGIT(code,c)        IS_DIGIT(c)
#define IS_CODE_XDIGIT(code,c)       IS_XDIGIT(c)

#define IS_SB_WORD(code,c)  (IS_CODE_ALNUM(code,c) || (c) == '_')

#define IS_CODE_WORD(code,c) \
  (IS_SB_WORD(code,c) && ((c) < 0x80 || (code) == REGCODE_ASCII))
#define ISNOT_CODE_WORD(code,c) \
  ((!IS_SB_WORD(code,c)) && !ismb(code,c))

#define IS_WORD_STR(code,s,end) \
  (ismb((code),*(s)) ? (s + mblen((code),*(s)) <= (end)) : \
                       IS_SB_WORD(code,*(s)))
#define IS_WORD_STR_INC(code,s,end) \
  (ismb((code),*(s)) ? ((s) += mblen((code),*(s)), (s) <= (end)) : \
                       (s++, IS_SB_WORD(code,s[-1])))

#define IS_WORD_HEAD(code,c) (ismb(code,c) ? 1 : IS_SB_WORD(code,c))

static WCInt mb2wc(UChar* p, UChar* end, RegCharCodeType code)
{
  int c, i, len;
  WCInt n;

  if (code == REGCODE_UTF8) {
    PFETCH(c);
    len = mblen(code,c) - 1;
    n = c & ((1 << (6 - len)) - 1);
    while (len--) {
      PFETCH(c);
      n = (n << 6) | (c & ((1 << 6) - 1));
    }
  }
  else {
    PFETCH(c);
    len = mblen(code,c);
    n = c;
    if (len == 1) return n;

    for (i = 1; i < len; i++) {
      if (PEND) break;
      PFETCH(c);
      n <<= 8;  n += c;
    }

    len = mbmaxlen(code) - i;
    while (len-- > 0) {
      n <<= 8; 
    }
  }
  return n;
}

#define eucjp_islead(c)    ((UChar )((c) - 0xa1) > 0xfe - 0xa1)
#define utf8_islead(c)     ((UChar )((c) & 0xc0) != 0x80)
#define sjis_ismbfirst(c)  ismb(REGCODE_SJIS, (c))
#define sjis_ismbtrail(c)  SJIS_FOLLOW_TABLE[(c)]

#endif /* not REG_RUBY_M17N */


static UChar* GetLeftAdjustCharHead(RegCharCodeType code,
				    UChar* start, UChar* s)
{
  UChar *p;
  int len;

  if (s <= start) return s;
  p = s;

#ifdef REG_RUBY_M17N
  while (!m17n_islead(code, *p) && p > start) p--;
  while (p + (len = mblen(code, *p)) < s) {
    p += len;
  }
  if (p + len == s) return s;
  return p;
#else

  if (code == REGCODE_ASCII) {
    return p;
  }
  else if (code ==  REGCODE_EUCJP) {
    while (!eucjp_islead(*p) && p > start) p--;
    len = mblen(code, *p);
    if (p + len > s) return p;
    p += len;
    return p + ((s - p) & ~1);
  }
  else if (code == REGCODE_SJIS) {
    if (sjis_ismbtrail(*p)) {
      while (p > start) {
	if (! sjis_ismbfirst(*--p)) {
	  p++;
	  break;
	}
      } 
    }
    len = mblen(code, *p);
    if (p + len > s) return p;
    p += len;
    return p + ((s - p) & ~1);
  }
  else { /* REGCODE_UTF8 */
    while (!utf8_islead(*p) && p > start) p--;
    return p;
  }
#endif  /* REG_RUBY_M17N */
}

static UChar* GetRightAdjustCharHead(RegCharCodeType code, UChar* start,
				     UChar* s)
{
  UChar* p = GetLeftAdjustCharHead(code, start, s);

  if (p < s) {
    p += mblen(code, *p);
  }
  return p;
}

static UChar* GetRightAdjustCharHeadWithPrev(RegCharCodeType code,
				     UChar* start, UChar* s, UChar** prev)
{
  UChar* p = GetLeftAdjustCharHead(code, start, s);

  if (p < s) {
    if (prev) *prev = p;
    p += mblen(code, *p);
  }
  else {
    if (prev) *prev = (UChar* )NULL; /* Sorry */
  }
  return p;
}

static UChar* GetPrevCharHead(RegCharCodeType code, UChar* start, UChar* s)
{
  if (s <= start)
    return (UChar* )NULL;

  return GetLeftAdjustCharHead(code, start, s - 1);
}


static int Strncmp(UChar* s1, UChar* s2, int n)
{
  int x;

  while (n-- > 0) {
    x = *s2++ - *s1++;
    if (x) return x;
  }

  return 0;
}

static void Strcpy(UChar* dest, UChar* src, UChar* end)
{
  int len = end - src;
  if (len > 0) {
    xmemcpy(dest, src, len);
    dest[len] = (UChar )0;
  }
}

static UChar* Strdup(UChar* s, UChar* end)
{
  int len = end - s;

  if (len > 0) {
    UChar* r = (UChar* )xmalloc(len + 1);
    CHECK_NULL_RETURN(r);
    xmemcpy(r, s, len);
    r[len] = (UChar )0;
    return r;
  }
  else return NULL;
}

static UChar* Strcat(UChar* dest, UChar* dest_end, UChar* src, UChar* src_end)
{
  int src_len = src_end - src;

  if (src_len > 0) {
    int len = dest_end - dest;
    UChar* r = (UChar* )xrealloc(dest, len + src_len + 1);
    CHECK_NULL_RETURN(r);
    xmemcpy(r + len, src, src_len);
    r[len + src_len] = (UChar )0;
    return r;
  }
  else {
    return dest;
  }
}

static UChar* StrcatCapa(UChar* dest, UChar* dest_end,
			 UChar* src, UChar* src_end, int capa)
{
  UChar* r;

  if (dest)
    r = (UChar* )xrealloc(dest, capa + 1);
  else
    r = (UChar* )xmalloc(capa + 1);

  CHECK_NULL_RETURN(r);
  Strcpy(r + (dest_end - dest), src, src_end);
  return r;
}

/* dest on static area */
static UChar* StrcatCapaFromStatic(UChar* dest, UChar* dest_end,
				   UChar* src, UChar* src_end, int capa)
{
  UChar* r;

  r = (UChar* )xmalloc(capa + 1);
  CHECK_NULL_RETURN(r);
  Strcpy(r, dest, dest_end);
  Strcpy(r + (dest_end - dest), src, src_end);
  return r;
}

#ifdef RECYCLE_NODE
typedef struct _FreeNode {
  struct _FreeNode* next;
} FreeNode;

static FreeNode* FreeNodeList = (FreeNode* )NULL;
#endif

static void NodeFree(Node* node)
{
  if (IS_NULL(node)) return ;

  switch (NTYPE(node)) {
  case N_STRING:
  case N_STRING_RAW:
    if (IS_NOT_NULL(NSTRING(node).s) && NSTRING(node).s != NSTRING(node).buf) {
      xfree(NSTRING(node).s);
    }
    break;

  case N_LIST:
  case N_ALT:
    NodeFree(NCONS(node).left);
    NodeFree(NCONS(node).right);
    break;

  case N_CCLASS:
    if (NCCLASS(node).mbuf)
      xfree(NCCLASS(node).mbuf);
    break;

  case N_QUALIFIER:
    if (NQUALIFIER(node).target)
      NodeFree(NQUALIFIER(node).target);
    break;

  case N_OPTION:
    if (NOPTION(node).target)
      NodeFree(NOPTION(node).target);
    break;

  case N_EFFECT:
    if (NEFFECT(node).target)
      NodeFree(NEFFECT(node).target);
    break;
  }

#ifdef RECYCLE_NODE
  {
    FreeNode* n;

    n = (FreeNode* )node;
    n->next = FreeNodeList;
    FreeNodeList = n;
  }
#else
  xfree(node);
#endif
}

static Node* NodeNew()
{
  Node* node;

#ifdef RECYCLE_NODE
  if (IS_NOT_NULL(FreeNodeList)) {
    node = (Node* )FreeNodeList;
    FreeNodeList = FreeNodeList->next;
    return node;
  }
#endif

  node = (Node* )xmalloc(sizeof(Node));
  return node;
}

static Node* NodeNewEmpty()
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);
  node->type = N_EMPTY;
  return node;
}

static Node* NodeNewCClass()
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);
  node->type = N_CCLASS;
  BITSET_CLEAR(NCCLASS(node).bs);
  NCCLASS(node).not  = 0;
  NCCLASS(node).mbuf = NULL;
  return node;
}

static Node* NodeNewCType(int type)
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);
  node->type = N_CTYPE;
  NCTYPE(node).type = type;
  return node;
}

static Node* NodeNewAnyChar()
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);
  node->type = N_ANYCHAR;
  return node;
}

static Node* NodeNewList(Node* left, Node* right)
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);
  node->type = N_LIST;
  NCONS(node).left  = left;
  NCONS(node).right = right;
  return node;
}

static Node* NodeNewAlt(Node* left, Node* right)
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);
  node->type = N_ALT;
  NCONS(node).left  = left;
  NCONS(node).right = right;
  return node;
}

static Node* NodeNewAnchor(int type)
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);
  node->type = N_ANCHOR;
  NANCHOR(node).type = type;
  return node;
}

static Node* NodeNewBackref(int regnum)
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);
  node->type = N_BACKREF;
  NBACKREF(node).regnum = regnum;
  return node;
}

static Node* NodeNewQualifier(int lower, int upper)
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);
  node->type = N_QUALIFIER;
  NQUALIFIER(node).target = NULL;
  NQUALIFIER(node).lower  = lower;
  NQUALIFIER(node).upper  = upper;
  NQUALIFIER(node).greedy = 1;
  NQUALIFIER(node).target_empty = 0;
  NQUALIFIER(node).head_exact   = (Node* )NULL;
  return node;
}

static Node* NodeNewOption(RegOptionType option)
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);
  node->type = N_OPTION;
  NOPTION(node).option = option;
  NOPTION(node).target = NULL;
  return node;
}

static Node* NodeNewEffect(int type)
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);
  node->type = N_EFFECT;
  NEFFECT(node).type   = type;
  NEFFECT(node).regnum = 0;
  NOPTION(node).target = NULL;
  return node;
}

static int NodeStrCat(Node* node, UChar* s, UChar* end)
{
  int addlen = end - s;

  if (addlen > 0) {
    int len  = NSTRING(node).end - NSTRING(node).s;

    if (NSTRING(node).capa > 0 || (len + addlen > NODE_STR_BUF_SIZE - 1)) {
      UChar* p;
      int capa = len + addlen + NODE_STR_MARGIN;

      if (capa <= NSTRING(node).capa) {
	Strcpy(NSTRING(node).s + len, s, end);
      }
      else {
	if (NSTRING(node).s == NSTRING(node).buf)
	  p = StrcatCapaFromStatic(NSTRING(node).s, NSTRING(node).end, s, end, capa);
	else
	  p = StrcatCapa(NSTRING(node).s, NSTRING(node).end, s, end, capa);

	CHECK_NULL_RETURN_VAL(p, 1);
	NSTRING(node).s    = p;
	NSTRING(node).capa = capa;
      }
    }
    else {
      Strcpy(NSTRING(node).s + len, s, end);
    }
    NSTRING(node).end = NSTRING(node).s + len + addlen;
  }

  return 0;
}

static int NodeStrCatChar(Node* node, UChar c)
{
  UChar s[1];

  s[0] = c;
  return NodeStrCat(node, s, s + 1);
}

static Node* NodeNewStr(UChar* s, UChar* end)
{
  Node* node = NodeNew();
  CHECK_NULL_RETURN(node);

  node->type = N_STRING;
  NSTRING(node).capa = 0;
  NSTRING(node).s    = NSTRING(node).buf;
  NSTRING(node).end  = NSTRING(node).buf;
  if (NodeStrCat(node, s, end)) {
    NodeFree(node);
    return NULL;
  }
  return node;
}

static Node* NodeNewStrRaw(UChar* s, UChar* end)
{
  Node* node = NodeNewStr(s, end);
  node->type = N_STRING_RAW;
  return node;
}

static Node* NodeNewStrChar(UChar c)
{
  UChar p[1];

  p[0] = c;
  return NodeNewStr(p, p + 1);
}

static Node* NodeNewStrRawChar(UChar c)
{
  UChar p[1];

  p[0] = c;
  return NodeNewStrRaw(p, p + 1);
}

static Node* StrNodeSplitLastChar(StrNode* sn, int type, RegCharCodeType code)
{
  UChar *p;
  Node* n = (Node* )NULL;

  if (sn->end > sn->s) {
    p = GetPrevCharHead(code, sn->s, sn->end);
    if (p && p > sn->s) { /* can be splitted. */
      if (type == N_STRING_RAW)
	n = NodeNewStrRaw(p, sn->end);
      else
	n = NodeNewStr(p, sn->end);

      sn->end = p;
    }
  }
  return n;
}

typedef struct {
  RegOptionType   option;
  RegCharCodeType code;
  int   regnum;
  Node* last_node;
  int   paren_nest;
} ScanEnv;


static int scanUnsignedNumber(UChar** src, UChar* end)
{
  unsigned int num, val;
  int c;
  UChar* p = *src;

  num = 0;
  while (!PEND) {
    PFETCH(c);
    if (IS_DIGIT(c)) {
      val = (unsigned int )DIGITVAL(c);
      if ((INT_MAX_LIMIT - val) / 10UL < num)
	return -1;  /* overflow */

      num = num * 10 + val;
    }
    else {
      PUNFETCH;
      break;
    }
  }
  *src = p;
  return num;
}

static int scanUnsignedHexadecimalNumber(UChar** src, UChar* end, int maxlen)
{
  int c;
  unsigned int num, val;
  UChar* p = *src;

  num = 0;
  while (!PEND && maxlen-- != 0) {
    PFETCH(c);
    if (IS_XDIGIT(c)) {
      val = (unsigned int )XDIGITVAL(c);
      if ((INT_MAX_LIMIT - val) / 16UL < num)
	return -1;  /* overflow */

      num = (num << 4) + XDIGITVAL(c);
    }
    else {
      PUNFETCH;
      break;
    }
  }
  *src = p;
  return num;
}

static int scanUnsignedOctadecimalNumber(UChar** src, UChar* end, int maxlen)
{
  int c;
  unsigned int num, val;
  UChar* p = *src;

  num = 0;
  while (!PEND && maxlen-- != 0) {
    PFETCH(c);
    if (IS_ODIGIT(c)) {
      val = ODIGITVAL(c);
      if ((INT_MAX_LIMIT - val) / 8UL < num)
	return -1;  /* overflow */

      num = (num << 3) + val;
    }
    else {
      PUNFETCH;
      break;
    }
  }
  *src = p;
  return num;
}

/* data format:
   [n][from-1][to-1][from-2][to-2] ... [from-n][to-n]
   (all data size is WCInt)
 */
#define GET_WCINT(wc,p)   (wc) = *((WCInt* )(p))
#define BBUF_WRITE_WCINT(bbuf,pos,wc) \
    BBUF_WRITE(bbuf, pos, &(wc), SIZE_WCINT)

static int IsInWCRange(UChar* p, WCInt wc)
{
  WCInt n, *data;
  int low, high, x;

  GET_WCINT(n, p);
  data = (WCInt* )p;
  data++;

  for (low = 0, high = n; low < high; ) {
    x = (low + high) >> 1;
    if (wc > data[x * 2 + 1])
      low = x + 1;
    else
      high = x;
  }

  return ((low < n && wc >= data[low * 2]) ? 1 : 0);
}

/* data format:
   [multi-byte-head-BitSet][n][from-1][to-1][from-2][to-2] ... [from-n][to-n]
   (all data size is WCInt)
 */
static int addWCRange(BBuf** pbuf, WCInt from, WCInt to,
		      UChar cfrom, UChar cto)
{
#define INIT_MULTI_BYTE_RANGE_SIZE  (SIZE_WCINT * 5)

  int r, inc_n, pos;
  int low, high, bound, x;
  WCInt n, *data;
  BBuf* bbuf;

  if (from > to) {
    n = from; from = to; to = n;
  }

  if (IS_NULL(*pbuf)) {
    bbuf = *pbuf = (BBuf* )xmalloc(sizeof(BBuf));
    CHECK_NULL_RETURN_VAL(*pbuf, REGERR_MEMORY);
    r = BBufInit(*pbuf, SIZE_BITSET + INIT_MULTI_BYTE_RANGE_SIZE);
    if (r) return r;

    n = 0;
    BBUF_WRITE_WCINT(bbuf, SIZE_BITSET, n);
    BITSET_CLEAR((BitSetRef )bbuf->p);
  }
  else {
    bbuf = *pbuf;
    GET_WCINT(n, bbuf->p + SIZE_BITSET);
    if (n >= 255)
      return REGERR_TOO_MANY_MULTI_BYTE_RANGES;

    data = (WCInt* )(bbuf->p + SIZE_BITSET);
    data++;
  }

  for (low = 0, bound = n; low < bound; ) {
    x = (low + bound) >> 1;
    if (from > data[x*2 + 1] - 1)
      low = x + 1;
    else
      bound = x;
  }

  for (high = low, bound = n; high < bound; ) {
    x = (high + bound) >> 1;
    if (to >= data[x*2] - 1)
      to = x + 1;
    else
      bound = x;
  }

  inc_n = low + 1 - high;

  if (inc_n != 1) {
    if (from > data[low*2])
      from = data[low*2];
    if (to < data[(high - 1)*2 + 1])
      to = data[(high - 1)*2 + 1];
  }

  if (inc_n != 0 && high < n) {
    int from_pos = SIZE_BITSET + SIZE_WCINT * (1 + high * 2);
    int to_pos   = SIZE_BITSET + SIZE_WCINT * (1 + (low + 1) * 2);
    int size = (n - high) * 2 * SIZE_WCINT;

    if (inc_n > 0) {
      BBUF_MOVE_RIGHT(bbuf, from_pos, to_pos, size);
    }
    else {
      BBUF_MOVE_LEFT_REDUCE(bbuf, from_pos, to_pos);
    }
  }

  pos = SIZE_BITSET + SIZE_WCINT * (1 + low * 2);
  BBUF_ENSURE_SIZE(bbuf, pos + SIZE_WCINT * 2);
  BBUF_WRITE_WCINT(bbuf, pos, from);
  BBUF_WRITE_WCINT(bbuf, pos + SIZE_WCINT, to);
  n += inc_n;
  BBUF_WRITE_WCINT(bbuf, SIZE_BITSET, n);

  if (inc_n > 0) {
    int i;
    UChar tmp;

    if (cfrom > cto) {
      tmp = cfrom; cfrom = cto; cto = tmp;
    }

    for (i = cfrom; i <= cto; i++) {
      BITSET_SET_BIT((BitSetRef)bbuf->p, i);      
    }
  }
  return 0;
}

static int addMultiByteRange(BBuf** pbuf, RegCharCodeType code,
		     UChar* from, UChar* from_end, UChar* to, UChar* to_end)
{
  int mb_maxlen;
  WCInt wc_from, wc_to;

  if (! MB2WC_AVAILABLE(code))
    return REGERR_SPECIFIED_ENCODING_CANT_CONVERT_TO_WIDE_CHAR;

  wc_from = MB2WC(from, from_end, code);
  wc_to   = MB2WC(to,   to_end,   code);

  return addWCRange(pbuf, wc_from, wc_to, from[0], to[0]);
}

static int scanBackSlashMultiByteSequence(UChar** src, UChar* end,
					  RegCharCodeType code,
					  UChar* buf, int len)
{
  int c, i, r = 0;
  UChar* p = *src;

  for (i = 0; i < len; i++) {
    if (PEND)
      return REGERR_TOO_SHORT_MULTI_BYTE_STRING;

    PFETCH(c);
    switch (c) {
    case '\\':
      if (PEND) return REGERR_END_PATTERN_AT_BACKSLASH;
      PFETCH(c);
      switch (c) {
      case 'x':
	r = scanUnsignedHexadecimalNumber(&p, end, 2);
	if (r < 0) return REGERR_TOO_BIG_NUMBER;
	if (p == *src) {  /* can't read nothing. */
	  goto end;
	}
	buf[i] = r;
	break;
	
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7':
	PUNFETCH;
	r = scanUnsignedOctadecimalNumber(&p, end, 3);
	if (r < 0) return REGERR_TOO_BIG_NUMBER;
	if (p == *src) {  /* can't read nothing. */
	  goto end;
	}
	buf[i] = r;
	break;

      default:
	buf[i] = c;
      }
      break;

    default:
      PUNFETCH;
      goto end;
      break;
    }
  }

 end:
  *src = p;
  return i;
}

static int scanRangeQualifier(UChar** src, UChar* end, int* lower, int* upper)
{
  int low, up;
  int c;
  UChar* p = *src;

  if (PEND) return REGERR_END_PATTERN_AT_LEFT_BRACE;  /* "....{" syntax error */

  low = scanUnsignedNumber(&p, end);
  if (low < 0) return REGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;
  if (low > REG_MAX_REPEAT_NUM)
    return REGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;

  if (p == *src) return 1;  /* can't read low, 1: not error */

  if (PEND) return 1;
  PFETCH(c);
  if (c == ',') {
    UChar* prev = p;
    up = scanUnsignedNumber(&p, end);
    if (up < 0) return REGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;
    if (up > REG_MAX_REPEAT_NUM)
      return REGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;

    if (p == prev) up = REPEAT_INFINITE;  /* {n,} : {n,infinite} */
  }
  else {
    PUNFETCH;
    up = low;  /* {n} : exact n times */
  }

  if (PEND) return 1;
  PFETCH(c);
  if (c != '}') return 1;

  if (!IS_REPEAT_INFINITE(up) && low > up) {
    return REGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE;
  }

  *lower = low;
  *upper = up;
  *src = p;
  return 0;
}

static int ConvBackSlashValue(int c)
{
  switch (c) {
  case 'n':  return '\n';
  case 't':  return '\t';
  case 'r':  return '\r';
  case 'f':  return '\f';
  case 'v':  return '\v';
  case 'a':  return '\007';
  case 'b':  return '\010';
  case 'e':  return '\033';
  }
  return c;
}


/* \M-, \C-, \c, or \... */
static int scanMetaControlBackslash(UChar** src, UChar* end)
{
  int c;
  UChar* p = *src;

  if (PEND) return REGERR_END_PATTERN_AFTER_BACKSLASH;

  PFETCH(c);
  switch (c) {
  case 'M':
    if (PEND) return REGERR_END_PATTERN_AT_META;
    PFETCH(c);
    if (c != '-') return REGERR_META_CODE_SYNTAX;
    if (PEND) return REGERR_END_PATTERN_AT_META;
    PFETCH(c);
    if (c == '\\') {
      c = scanMetaControlBackslash(&p, end);
      if (c < 0) return c;
    }
    c = ((c & 0xff) | 0x80);
    break;

  case 'C':
    if (PEND) return REGERR_END_PATTERN_AT_CONTROL;
    PFETCH(c);
    if (c != '-') return REGERR_CONTROL_CODE_SYNTAX;

    /* fall through */
  case 'c':
    if (PEND) return REGERR_END_PATTERN_AT_CONTROL;
    PFETCH(c);
    if (c == '\\') {
      c = scanMetaControlBackslash(&p, end);
      if (c < 0) return c;
    }
    else if (c == '?')
      c = 0177;
    else
       c &= 0x9f;
    break;

  default:
    c = ConvBackSlashValue(c);
  }

  *src = p;
  return c;
}

static int scanBackSlash(UChar** src, UChar* end, ScanEnv* env, Node** node)
{
  int c, num;
  UChar* prev;
  UChar* p = *src;

  if (PEND) return REGERR_END_PATTERN_AT_BACKSLASH;

  PFETCH(c);
  switch (c) {
  case 'd': case 'D': case 's': case 'S':
    *node = NodeNewCClass();
    CHECK_NULL_RETURN_VAL(*node, REGERR_MEMORY);
    switch (c) {
    case 'd':
      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
	if (IS_CODE_DIGIT(code,c)) BITSET_SET_BIT(NCCLASS(*node).bs, c);
      }
      break;
    case 'D':
      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
	if (!IS_CODE_DIGIT(code,c)) BITSET_SET_BIT(NCCLASS(*node).bs, c);
      }
      break;
    case 's':
      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
	if (IS_CODE_SPACE(env->code,c)) BITSET_SET_BIT(NCCLASS(*node).bs, c);
      }
      break;
    case 'S':
      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
	if (!IS_CODE_SPACE(env->code,c)) BITSET_SET_BIT(NCCLASS(*node).bs, c);
      }
      break;
    }
    break;

  case 'w':
    *node = NodeNewCType(CTYPE_WORD);
    break;
  case 'W':
    *node = NodeNewCType(CTYPE_NOT_WORD);
    break;

  case 'b':
    *node = NodeNewCType(CTYPE_WORD_BOUND);
    break;
  case 'B':
    *node = NodeNewCType(CTYPE_NOT_WORD_BOUND);
    break;

#ifdef VALID_WORD_BEGIN_END
  case '<':
    *node = NodeNewCType(CTYPE_WORD_BEGIN);
    break;
  case '>':
    *node = NodeNewCType(CTYPE_WORD_END);
    break;
#endif

  case 'A':
    *node = NodeNewAnchor(ANCHOR_BEGIN_BUF);
    break;

  case 'Z':
    if (! IS_SINGLELINE(env->option)) {
      *node = NodeNewAnchor(ANCHOR_SEMI_END_BUF);
      break;
    }
    /* fall through */
  case 'z':
    *node = NodeNewAnchor(ANCHOR_END_BUF);
    break;

  case 'G':
    *node = NodeNewAnchor(ANCHOR_BEGIN_POSITION);
    break;

  case 'x':
    prev = p;
    num = scanUnsignedHexadecimalNumber(&p, end, 2);
    if (num < 0) return REGERR_TOO_BIG_NUMBER;
    if (p == prev) {  /* can't read nothing. */
      num = 0; /* but, it's not error */
    }
    goto string_raw;
    break;

  case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
    PUNFETCH;
    prev = p;
    num = scanUnsignedNumber(&p, end);
    if (num < 0)  return REGERR_TOO_BIG_NUMBER;
    if (num > REG_MAX_BACKREF_NUM) return REGERR_TOO_BIG_BACKREF_NUMBER;

    if (num <= env->regnum || num <= 9) { /* ?? num <= 9, but it's spec. */
      *node = NodeNewBackref(num);
      break;
    }

    if (c == '8' || c == '9') {
      *node = NodeNewStrChar((UChar )c);
      p = prev + 1;
      break;
    }

    p = prev;
    /* fall through */
  case '0':
    prev = p;
    num = scanUnsignedOctadecimalNumber(&p, end, 3);
    if (num < 0) return REGERR_TOO_BIG_NUMBER;
    if (p == prev) {  /* can't read nothing. */
      num = 0; /* but, it's not error */
    }
    goto string_raw;
    break;

  default:
    PUNFETCH;
    num = scanMetaControlBackslash(&p, end);
    if (num < 0) return num;
    goto string_raw;
    break;
  }

 end:
  CHECK_NULL_RETURN_VAL(*node, REGERR_MEMORY);
  *src = p;
  return 0;

 string_raw:
  if (env->last_node && NTYPE(env->last_node) == N_STRING_RAW) {
    NodeStrCatChar(env->last_node, (UChar )num);
    *src = p;
    return 1;  /* string_raw concat */
  }
  else {
    *node = NodeNewStrRawChar(num);
    goto end;
  }
}

#define ADD_ALL_MULTI_BYTE_RANGE(code, mbuf) do {\
  if (! IS_SINGLEBYTE_CODE(code)) {\
    r = addWCRange(&(mbuf), (WCInt )0x80, ~((WCInt )0),\
                   (UChar )0x80, (UChar )0xff);\
    if (r) return r;\
  }\
} while (0)

static int scanBackSlashInCharClass(UChar** src, UChar* end,
				    RegCharCodeType code, Node* node, int* num)
{
  int c, r = 0;
  UChar* p = *src;
  BitSetRef bs;

  bs = NCCLASS(node).bs;

  if (PEND) return REGERR_END_PATTERN_AT_BACKSLASH;

  PFETCH(c);
  switch (c) {
  case 'd':
    for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
      if (IS_CODE_DIGIT(code,c)) BITSET_SET_BIT(bs, c);
    }
    break;
  case 'D':
    for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
      if (!IS_CODE_DIGIT(code,c)) BITSET_SET_BIT(bs, c);
    }
    ADD_ALL_MULTI_BYTE_RANGE(code, NCCLASS(node).mbuf);
    break;

  case 's':
    for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
      if (IS_CODE_SPACE(code,c)) BITSET_SET_BIT(bs, c);
    }
    break;
  case 'S':
    for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
      if (!IS_CODE_SPACE(code,c)) BITSET_SET_BIT(bs, c);
    }
    ADD_ALL_MULTI_BYTE_RANGE(code, NCCLASS(node).mbuf);
    break;

  case 'w':
    for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
      if (IS_CODE_WORD(code,c)) BITSET_SET_BIT(bs, c);
    }
    ADD_ALL_MULTI_BYTE_RANGE(code, NCCLASS(node).mbuf);
    break;
  case 'W':
    for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
      if (ISNOT_CODE_WORD(code,c)) {
	  BITSET_SET_BIT(bs, c);
      }
    }
    break;

  case 'x':
    *num = scanUnsignedHexadecimalNumber(&p, end, 2);
    if (*num < 0) return REGERR_TOO_BIG_NUMBER;
    if (p == *src) {  /* can't read nothing. */
      *num = 0; /* but, it's not error */
    }
    r = 1; /* read number */
    break;

  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7':
    PUNFETCH;
    *num = scanUnsignedOctadecimalNumber(&p, end, 3);
    if (*num < 0) return REGERR_TOO_BIG_NUMBER;
    if (p == *src) {  /* can't read nothing. */
      *num = 0; /* but, it's not error */
    }
    r = 1; /* read number */
    break;

  default:
    r = 1; /* read number */
    PUNFETCH;
    *num = scanMetaControlBackslash(&p, end);
    if (*num < 0) return *num;
  }

  *src = p;
  return r;
}

static int scanPosixBracketCharClass(UChar** src, UChar* end,
				     RegCharCodeType code, Node* node)
{
#define CHECK_POSIX_BRACKET_END \
  if (end - p < 2 || *p != ':' || *(p+1) != ']')\
    return 1

#define BITSET_BY_MACRO(pmacro) do {\
  if (not) {\
    for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\
      if (! pmacro(code,c)) BITSET_SET_BIT(bs, c);\
    }\
  }\
  else {\
    for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\
      if (pmacro(code,c)) BITSET_SET_BIT(bs, c);\
    }\
  }\
} while (0)

  UChar *p = *src;
  int i, c, not = 0;
  BitSetRef bs;

  bs = NCCLASS(node).bs;

  if (PPEEK == '^') {
    not = 1;
    PFETCH(c);
  }

  if (end - p < 7)
    return 1;

  if (Strncmp(p, "alnum", 5) == 0) {
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_ALNUM);
  }
  else if (Strncmp(p, "alpha", 5) == 0) {
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_ALPHA);
  }
  else if (Strncmp(p, "blank", 5) == 0) {
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_BLANK);
  }
  else if (Strncmp(p, "cntrl", 5) == 0) {
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_CNTRL);
  }
  else if (Strncmp(p, "digit", 5) == 0) {
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_DIGIT);
  }
  else if (Strncmp(p, "graph", 5) == 0) {
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_GRAPH);
  }
  else if (Strncmp(p, "lower", 5) == 0) {
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_LOWER);
  }
  else if (Strncmp(p, "print", 5) == 0) {
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_PRINT);
  }
  else if (Strncmp(p, "punct", 5) == 0) {
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_PUNCT);
  }
  else if (Strncmp(p, "space", 5) == 0) {
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_SPACE);
  }
  else if (Strncmp(p, "upper", 5) == 0) {
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_UPPER);
  }
  else if (Strncmp(p, "xdigit", 6) == 0) {
    p += 6;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_XDIGIT);
  }
  else if (Strncmp(p, "ascii", 5) == 0) { /* Perl extension ? */
    p += 5;
    CHECK_POSIX_BRACKET_END;
    BITSET_BY_MACRO(IS_CODE_ASCII);
  }
  else {
    return REGERR_INVALID_POSIX_CHAR_CLASS;
  }

  p += 2;
  *src = p;
  return 0;
}

static int scanCharClass(UChar** src, UChar* end, RegCharCodeType code,
			 Node* node)
{
#define SCC_BUF_LEN  8

  int c, r, isnum, last_val, range_mode;
  int curr_mblen, curr_true_mblen, last_mblen, last_true_mblen;
  int curr_mbs_alloc_len, last_mbs_alloc_len;
  UChar curr_mbs_buf[SCC_BUF_LEN], *curr_mbs;
  UChar last_mbs_buf[SCC_BUF_LEN], *last_mbs;
  UChar* pp;
  UChar* p = *src;

  if (PEND) return REGERR_END_PATTERN_AT_LEFT_BRACKET;  /* "....[" */

  curr_mbs = curr_mbs_buf;
  last_mbs = last_mbs_buf;
  curr_mbs_alloc_len = SCC_BUF_LEN;
  last_mbs_alloc_len = SCC_BUF_LEN;

  PFETCH(c);
  if (c == '^') {
    NCCLASS(node).not = 1;
  }
  else  PUNFETCH;

  range_mode =  0;
  last_val   = -1;
  while (!PEND) {
    isnum = 0;
    curr_mblen = 0;
    PFETCH(c);
    if (c == ']') {
      if ((p == *src + 1) ||
	  (NCCLASS(node).not && p == *src + 2)) { /* empty: [] or [^] */
	if (PEND) {
	  r = REGERR_EMPTY_CHAR_CLASS;
	  goto err_exit;
	}
      }
      else
	break; /* char-class terminate */
    }
    else if (c == '\\') {
      pp = p - 1;
      r = scanBackSlashInCharClass(&p, end, code, node, &c);
      if (r < 0) goto err_exit;
      if (r == 0) { /* char class */
	if (range_mode) {
	  r = REGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;
	  goto err_exit;
	}

	continue;
      }
      else { /* 1: number */
	isnum = 1;
      }
    }
    else if (c == '[' && PPEEK == ':') {
      UChar* psave = p;
      p++; /* skip ":" */
      r = scanPosixBracketCharClass(&p, end, code, node);
      if (r < 0) goto err_exit;
      if (r == 0) { /* char class */
	if (range_mode) {
	  r = REGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;
	  goto err_exit;
	}
	continue;
      }
      else {
	p = psave;
      }
    }

    if (ismb(code, c)) {
      curr_mblen = mblen(code, c);
      if (curr_mblen > curr_mbs_alloc_len) {
	if (curr_mbs == curr_mbs_buf) {
	  curr_mbs = (UChar* )xmalloc(curr_mblen);
	}
	else {
	  curr_mbs = (UChar* )xrealloc(curr_mbs, curr_mblen);
	}
	if (IS_NULL(curr_mbs)) {
	  r = REGERR_MEMORY;
	  goto err_exit;
	}
	curr_mbs_alloc_len = curr_mblen;
      }

      if (isnum) {
	p = pp;
	curr_true_mblen = scanBackSlashMultiByteSequence(&p, end, code,
							 curr_mbs, curr_mblen);
	if (curr_true_mblen < 0) {
	  r = curr_true_mblen;
	  goto err_exit;
	}
      }
      else {
	PUNFETCH;
	curr_true_mblen = ((end - p) > curr_mblen ? curr_mblen : (end - p));
	xmemcpy(curr_mbs, p, curr_true_mblen);
	p += curr_true_mblen;
      }
    }

    if (range_mode) {
      if (curr_mblen) {
	r = addMultiByteRange(&(NCCLASS(node).mbuf), code,
			      last_mbs, last_mbs + last_true_mblen,
			      curr_mbs, curr_mbs + curr_true_mblen);
	if (r < 0) goto err_exit;	
      }
      else {
	if (last_val < 0) {
	  r = REGERR_CHAR_CLASS_VALUE_AT_START_OF_RANGE;
	  goto err_exit;
	}
	if (c < last_val) {
	  r = REGERR_RIGHT_SMALLER_THAN_LEFT_IN_CLASS_RANGE;
	  goto err_exit;
	}

	for (; last_val <= c; last_val++) {
	  BITSET_SET_BIT(NCCLASS(node).bs, last_val);
	}
      }

      range_mode =  0;
      last_val   = -1;
    }
    else {
      last_val = c;
      last_mblen = 0;

      PFETCH(c);
      if (c == '-') {
	if (PPEEK != ']' && last_val != -1) {
	  range_mode = 1;
	}
      }
      else PUNFETCH;

      if (curr_mblen) {
	if (range_mode) {
	  if (curr_mblen > last_mbs_alloc_len) {
	    if (last_mbs == last_mbs_buf)
	      last_mbs = (UChar* )xmalloc(curr_mblen);
	    else
	      last_mbs = (UChar* )xrealloc(last_mbs, curr_mblen);
	    if (IS_NULL(last_mbs)) {
	      r = REGERR_MEMORY;
	      goto err_exit;
	    }
	    last_mbs_alloc_len = curr_mblen;
	  }

	  xmemcpy(last_mbs, curr_mbs, curr_true_mblen);
	  last_mblen      = curr_mblen;
	  last_true_mblen = curr_true_mblen;
	}
	else {
	  r = addMultiByteRange(&(NCCLASS(node).mbuf), code,
				curr_mbs, curr_mbs + curr_true_mblen,
				curr_mbs, curr_mbs + curr_true_mblen);
	  if (r < 0) goto err_exit;
	}
      }
      else {
	if (! range_mode)
	  BITSET_SET_BIT(NCCLASS(node).bs, last_val);
      }
    }
  }

  if (c != ']') {
    r = REGERR_PREMATURE_END_OF_CHAR_CLASS;
    goto err_exit;
  }

  *src = p;
  r = 0;

 err_exit:
  if (curr_mbs && (curr_mbs != curr_mbs_buf))
    xfree(curr_mbs);
  if (last_mbs && (last_mbs != last_mbs_buf))
    xfree(last_mbs);

  return r;
}


/* scan code */
#define SC_END            0   /* end of input */
#define SC_VALUE          1   /* string, anychar, char class, back-ref */
#define SC_QUALIFIER      2   /* ?, +, *, {n,m} */
#define SC_ANCHOR         3   /* position */
#define SC_GROUP_START    4   /* ( */
#define SC_GROUP_END      5   /* ) */
#define SC_ALT            6   /* | */
#define SC_COMMENT        7   /* (# ...) */
#define SC_OPTION_ONLY    8   /* (?options) */

static int ScanMakeNode(UChar** src, UChar* end, ScanEnv* env, Node** rnode)
{
  int c, r;
  int lower, upper, type;
  UChar* p = *src;

  *rnode = NULL;

 start:
  if (PEND) return SC_END;
  PFETCH(c);
  switch (c) {
  case '(':  r = SC_GROUP_START; break;
  case ')':  r = SC_GROUP_END;   break;
  case '|':  r = SC_ALT;         break;

  case '^':
    type = (IS_SINGLELINE(env->option) ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);
    *rnode = NodeNewAnchor(type);
    CHECK_NULL_RETURN_VAL(*rnode, REGERR_MEMORY);
    r = SC_ANCHOR;
    break;

  case '$':
    type = (IS_SINGLELINE(env->option) ? ANCHOR_END_BUF : ANCHOR_END_LINE);
    *rnode = NodeNewAnchor(type);
    CHECK_NULL_RETURN_VAL(*rnode, REGERR_MEMORY);
    r = SC_ANCHOR;
    break;

  case '?':
  case '+':
  case '*':
    lower = (c == '+' ? 1 : 0);
    upper = (c == '?' ? 1 : REPEAT_INFINITE);
    goto repeat_range;
    break;

  case '{':
    r = scanRangeQualifier(&p, end, &lower, &upper);
    if (r) {
      if (r > 0) {
	*src = p - 1;
	goto normal_string_2;
      }
      return r; /* error */
    }

  repeat_range:
    /* double repeat '**', '+*' etc. check */
    if (upper == 1 || IS_REPEAT_INFINITE(upper)) { /* "?+", "{n,infinite}*" */
      c = PPEEK;
      if (c == '+' || c == '*')
	return REGERR_NESTED_REPEAT_OPERATOR;
    }

    *rnode = NodeNewQualifier(lower, upper);
    CHECK_NULL_RETURN_VAL(*rnode, REGERR_MEMORY);
    if (!PEND) {
      PFETCH(c);
      if (c == '?')
	NQUALIFIER(*rnode).greedy = 0;
      else
	PUNFETCH;
    }
    r = SC_QUALIFIER;
    break;

  case '[':
    *rnode = NodeNewCClass();
    CHECK_NULL_RETURN_VAL(*rnode, REGERR_MEMORY);
    r = scanCharClass(&p, end, env->code, *rnode);
    if (r) return r;
    r = SC_VALUE;
    break;

  case '.':
    *rnode = NodeNewAnyChar();
    CHECK_NULL_RETURN_VAL(*rnode, REGERR_MEMORY);
    r = SC_VALUE;
    break;

  case '\\':
    r = scanBackSlash(&p, end, env, rnode);
    if (r) {
      if (r == 1) goto start;
      return r;
    }
    r = SC_VALUE;
    break;

  case '#':
    if (IS_EXTEND(env->option)) {
      while (!PEND) {
	PFETCH(c);
	if (IS_NEWLINE(c))
	  goto start;
      }
      r = SC_END;
      break;
    }
    goto normal_string;

  case ' ': case '\t': case '\n': case '\r': case '\f':
    if (IS_EXTEND(env->option))
      goto start;
    /* fall through */

  default:
  normal_string:
    *src = p - 1;
    while (1) {
      if (IS_EXTEND(env->option)) {
	if (strchr("# \t\n\r\f", c)) {
	  PUNFETCH;
	  break;
	}
      }

      if (strchr("()|^$?+*{[.\\", c)) {
	PUNFETCH;
	break;
      }

      if (ismb(env->code, c)) {
	r = mblen(env->code, c);
	while (--r && !PEND) PFETCH(c);
      }
      if (PEND) break;
      PFETCH(c);
    }

  normal_string_2:
    if (env->last_node && NTYPE(env->last_node) == N_STRING) {
      NodeStrCat(env->last_node, *src, p);
      goto start;
    }
    else {
      *rnode = NodeNewStr(*src, p);
      CHECK_NULL_RETURN_VAL(*rnode, REGERR_MEMORY);
      r = SC_VALUE;
    }
    break;
  }

  *src = p;
  return r;
}

#define ONOFF(v,f,negative) do {\
  (negative) ? ((v) &= ~(f)) : ((v) |= (f));\
} while (0);

static int ScanMakeTree(UChar** src, UChar* end, ScanEnv* env, Node** top);

static int ScanMakeParen(UChar** src, UChar* end, ScanEnv* env, Node** top,
			 int *last_is_group)
{
  Node *curr;
  RegOptionType option;
  int c, type, mem, pnest;
  UChar* p = *src;

  *top = NULL;
  if (PEND) return REGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;

  option = env->option;
  *last_is_group = 0;

  PFETCH(c);
  if (c == '?') {
    if (PEND) return REGERR_END_PATTERN_AT_GROUP_OPTION;
    PFETCH(c);
    switch (c) {
    case '#':   /* (#...) comment */
      while (1) {
	if (PEND) return REGERR_END_PATTERN_AT_GROUP_COMMENT;
	PFETCH(c);
	if (c == ')') break;
      }
      break;

    case ':':            /* (?:...) grouping only */
    case '=': case '!':  /*         preceding read */
    case '>':            /* (?>...) stop backtrack */
      break;

    case '-': case 'i': case 'm': case 'p': case 'x':
      {
	int neg = 0;

	while (1) {
	  switch (c) {
	  case ':':
	  case ')':
	  break;

	  case '-':  neg = 1; break;
	  case 'x':  ONOFF(option, REG_OPTION_EXTEND, neg);     break;
	  case 'i':  ONOFF(option, REG_OPTION_IGNORECASE, neg); break;
	  case 'm':  ONOFF(option, REG_OPTION_MULTILINE, neg);  break;
	  case 'p':
	    ONOFF(option, REG_OPTION_MULTILINE|REG_OPTION_SINGLELINE, neg);
	    break;

	  default:
	    return REGERR_UNDEFINED_GROUP_OPTION;
	  }

	  if (c == ':' || c == ')') break;
	  if (PEND) return REGERR_END_PATTERN_AT_GROUP_OPTION;
	  PFETCH(c);
	}
      }
      break;

    default:
      return REGERR_UNDEFINED_GROUP_OPTION;
    }
  }
  else {
    PUNFETCH;
    c = '(';
    env->regnum++;
    mem = env->regnum;
  }

  if (c == ')') {
    if (option == env->option) {
      *src = p;
      return SC_COMMENT;
    }
    else {
      *top = NodeNewOption(option);
      CHECK_NULL_RETURN_VAL(*top, REGERR_MEMORY);
      *src = p;
      return SC_OPTION_ONLY;
    }
  }

  pnest = env->paren_nest;
  env->paren_nest++;
  if (c == ':') { /* not in memory */
    if (env->option == option) {
      type = ScanMakeTree(&p, end, env, top);
      *src = p;
      if (env->paren_nest != pnest)
	return REGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;

      *last_is_group = 1;
      return type;
    }
    else {
      RegOptionType prev = env->option;
      env->option = option;
      type = ScanMakeTree(&p, end, env, &curr);
      env->option = prev;
      if (type < 0) return type;

      if (env->paren_nest != pnest)
	return REGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;

      *top = NodeNewOption(option);
      CHECK_NULL_RETURN_VAL(*top, REGERR_MEMORY);
      NOPTION(*top).target = curr;
      *src = p;
      return type;
    }
  }

  type = ScanMakeTree(&p, end, env, &curr);
  if (type < 0) return type;
  if (env->paren_nest != pnest)
    return REGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;

  switch (c) {
  case '(':
    *top = NodeNewEffect(EFFECT_MEMORY);
    CHECK_NULL_RETURN_VAL(*top, REGERR_MEMORY);
    NEFFECT(*top).regnum = mem;
    break;

  case '=':
    *top = NodeNewEffect(EFFECT_PREC_READ);
    CHECK_NULL_RETURN_VAL(*top, REGERR_MEMORY);
    break;

  case '!':
    *top = NodeNewEffect(EFFECT_PREC_READ_NOT);
    CHECK_NULL_RETURN_VAL(*top, REGERR_MEMORY);
    break;

  case '>':
    *top = NodeNewEffect(EFFECT_STOP_BACKTRACK);
    CHECK_NULL_RETURN_VAL(*top, REGERR_MEMORY);
    break;
  }
  NEFFECT(*top).target = curr;

  *src = p;
  return type;
}

static int ScanMakeTree(UChar** src, UChar* end, ScanEnv* env, Node** top)
{
  int type;
  int last_is_group = 0;   /* "(:...)" */
  Node *curr, **last, **last_concat;

  *top = curr = NULL;
  last_concat = NULL;
  last = top;
  while (1) {
    env->last_node = curr;
    type = ScanMakeNode(src, end, env, &curr);
    switch (type) {
    case SC_END:
      goto end;
      break;

    case SC_QUALIFIER:  /* ?, +, *, {n,m} */
      if (*last) {
	if (!last_is_group &&
	    (NTYPE(*last) == N_STRING || NTYPE(*last) == N_STRING_RAW)) {
	  Node* n;
	  StrNode* sn = &(NSTRING(*last));

	  n = StrNodeSplitLastChar(sn, NTYPE(*last), env->code);
	  if (IS_NOT_NULL(n)) {
	    NQUALIFIER(curr).target = n;
	    *last = NodeNewList(*last, NodeNewList(curr, NULL));
	    break;
	  }
	}
	NQUALIFIER(curr).target = *last;
	*last = curr;
	last_is_group = 0;
      }
      else
	return REGERR_TARGET_OF_REPEAT_QUALIFIER_NOT_FOUND;
      break;


    case SC_VALUE:    /* string, anychar, char class, back-ref */
    case SC_ANCHOR:
    concat:
    last_is_group = 0;
    concat2:
      {
	if (IS_NULL(last_concat) && IS_NULL(*last)) {
	  *last = curr;
	}
	else {
	  if (IS_NULL(last_concat)) {
	    *last = NodeNewList(*last, NULL);
	    last_concat = &(NCONS(*last).right);
	  }
	  *last_concat = NodeNewList(curr, NULL);
	  last = &(NCONS(*last_concat).left);
	  last_concat = &(NCONS(*last_concat).right);
	}
      }
      break;

    case SC_ALT:
      {
	if (IS_NULL(*top)) {
	  *top = NodeNewEmpty();
	}
	*top = NodeNewAlt(*top, NULL);
	env->last_node = NULL;
	type = ScanMakeTree(src, end, env, &(NCONS(*top).right));
	if (NTYPE(NCONS(*top).right) != N_ALT) {
	  NCONS(*top).right = NodeNewAlt(NCONS(*top).right, NULL);
	}
	return type;
      }
      break;

    case SC_GROUP_START:
      type = ScanMakeParen(src, end, env, &curr, &last_is_group);
      if (type == SC_END) {
	goto concat2;
      }
      else if (type == SC_OPTION_ONLY) {
	RegOptionType prev = env->option;
	env->option = NOPTION(curr).option;
	type = ScanMakeTree(src, end, env, &(NOPTION(curr).target));
	env->option = prev;
	goto concat2;
      }
      else if (type == SC_COMMENT) {
	continue;
      }
      else
	return type;
      break;

    case SC_GROUP_END:
      if (env->paren_nest <= 0) {
	return REGERR_UNMATCHED_RIGHT_PARENTHESIS;
      }
      env->paren_nest--;
      goto end;
      break;

    default: /* erorr code */
      return type;
    }
  }

 end:
  if (IS_NULL(*top))
    *top = NodeNewEmpty();
  return SC_END;
}

static int ParseMakeTree(Node** root, UChar* pattern, UChar* end, regex_t* reg)
{
  int r;
  UChar* p;
  ScanEnv env;

  env.option     = reg->options;
  env.code       = reg->code;
  env.regnum     = 0;
  env.last_node  = NULL;
  env.paren_nest = 0;

  *root = NULL;
  p = pattern;
  r = ScanMakeTree(&p, end, &env, root);
  reg->max_mem = env.regnum;
  return r;
}


/* operation code */
enum OpCode {
  OP_END    = 0,        /* terminator */

  OP_EXACT1 = 1,        /* single byte, N = 1 */
  OP_EXACT2,            /* single byte, N = 2 */
  OP_EXACT3,            /* single byte, N = 3 */
  OP_EXACT4,            /* single byte, N = 4 */
  OP_EXACT5,            /* single byte, N = 5 */
  OP_EXACTN,            /* single byte */
  OP_EXACTMB2N1,        /* mb-length = 2 N = 1 */
  OP_EXACTMB2N2,        /* mb-length = 2 N = 2 */
  OP_EXACTMB2N3,        /* mb-length = 2 N = 3 */
  OP_EXACTMB2N,         /* mb-length = 2 */
  OP_EXACTMB4N,         /* mb length = 4 */
  OP_EXACTMBN,          /* other length */
  OP_EXACT1_RAW,        /* single byte, N = 1 */
  OP_EXACTN_RAW,        /* single byte        */

  OP_CCLASS,
  OP_CCLASS_MB,
  OP_CCLASS_MIX,
  OP_CCLASS_NOT,
  OP_CCLASS_MB_NOT,
  OP_CCLASS_MIX_NOT,

  OP_ANYCHAR,            /* "."  */
  OP_ANYCHAR_STAR,       /* ".*" */

  OP_WORD,
  OP_NOT_WORD,
  OP_WORD_BOUND,
  OP_NOT_WORD_BOUND,
  OP_WORD_BEGIN,
  OP_WORD_END,

  OP_BEGIN_BUF,
  OP_END_BUF,
  OP_BEGIN_LINE,
  OP_END_LINE,
  OP_SEMI_END_BUF,
  OP_BEGIN_POSITION,

  OP_BACKREF1,
  OP_BACKREF2,
  OP_BACKREF3,
  OP_BACKREFN,

  OP_MEMORY_START_PUSH,  /* push stack */
  OP_MEMORY_END_PUSH,    /* push stack */
  OP_MEMORY_END,

  OP_SET_OPTION_PUSH,    /* set option and push for recover option */
  OP_SET_OPTION,         /* set option */

  OP_FAIL,               /* pop stack and move */
  OP_JUMP,
  OP_PUSH,
  OP_PUSH_OR_JUMP_EXACT1, /* if match exact then push, else jump. */
  OP_REPEAT,             /* {n,m} */
  OP_REPEAT_NG,          /* {n,m}? (non greedy) */
  OP_REPEAT_INC,
  OP_REPEAT_INC_NG,      /* non greedy */
  OP_NULL_CHECK_START,   /* null loop checker start */
  OP_NULL_CHECK_END,     /* null loop checker end   */

  OP_PUSH_POS,           /* (?=....) start */
  OP_POP_POS,            /* (?=....) end   */
  OP_PUSH_POS_NOT,       /* (?!...)  start */
  OP_FAIL_POS,           /* (?!...)  end   */
  OP_PUSH_STOP_BT,       /* (?>...)  start */
  OP_POP_STOP_BT         /* (?>...)  end   */
};

/* arguments type */
#define ARG_SPECIAL     -1
#define ARG_NON          0
#define ARG_RELADDR      1
#define ARG_LENGTH       2
#define ARG_MEMNUM       3
#define ARG_OPTION       4


typedef struct _StackType {
  int type;
  union {
    struct {
      UChar *pcode;      /* compiled code position */
      UChar *pstr;       /* target string position */
      UChar *pstr_prev;  /* target string previous position */
    } state;
    struct {
      UChar *pcode;      /* compiled code position (head of repeated target) */
      int lower;         /* for OP_REPEAT_INC, OP_REPEAT_INC_NG */
      int upper;         /* for OP_REPEAT_INC, OP_REPEAT_INC_NG */
      int count;         /* for OP_REPEAT_INC, OP_REPEAT_INC_NG */
    } repeat;
    struct {
      struct _StackType *sp;
    } repeat_inc;
    struct {
      int num;
      UChar *pstr;              /* start/end position */
      /* Following information is setted if this stack type is MEM-START */
      struct _StackType *start; /* prev. info (for backtrack  "(...)*" ) */
      struct _StackType *end;   /* prev. info (for backtrack  "(...)*" ) */
    } mem;
    struct {
      int num;
      UChar *pstr;              /* start position */
    } null_check;
  } u;
} StackType;


typedef short int   RelAddrType;
typedef short int   LengthType;
typedef short int   MemNumType;
typedef int         RepeatNumType;
typedef StackType*  StackPointerType;

#define SIZE_OPCODE        1
#define SIZE_RELADDR       sizeof(RelAddrType)
#define SIZE_LENGTH        sizeof(LengthType)
#define SIZE_MEMNUM        sizeof(MemNumType)
#define SIZE_REPEATNUM     sizeof(RepeatNumType)
#define SIZE_STACKP        sizeof(StackPointerType)
#define SIZE_OPTION        sizeof(RegOptionType)

#define GET_RELADDR_INC(addr,p) do{\
  addr = *((RelAddrType* )(p));\
  (p) += SIZE_RELADDR;\
} while(0)

#define GET_LENGTH_INC(len,p) do{\
  len = *((LengthType* )(p));\
  (p) += SIZE_LENGTH;\
} while(0)

#define GET_MEMNUM_INC(num,p) do{\
  num = *((MemNumType* )(p));\
  (p) += SIZE_MEMNUM;\
} while(0)

#define GET_REPEATNUM_INC(num,p) do{\
  num = *((RepeatNumType* )(p));\
  (p) += SIZE_REPEATNUM;\
} while(0)

#define GET_OPTION_INC(option,p) do{\
  option = *((RegOptionType* )(p));\
  (p) += SIZE_OPTION;\
} while(0)

#define GET_BYTE_INC(byte,p) do{\
  byte = *(p);\
  (p)++;\
} while(0)

#define GET_WCINT_INC(wc,p) do{\
  wc = *((WCInt* )(p));\
  (p) += SIZE_WCINT;\
} while(0)

/* op-code + arg size */
#define SIZE_OP_JUMP                 (SIZE_OPCODE + SIZE_RELADDR)
#define SIZE_OP_PUSH                 (SIZE_OPCODE + SIZE_RELADDR)
#define SIZE_OP_PUSH_OR_JUMP_EXACT1  (SIZE_OPCODE + SIZE_RELADDR + 1)
#define SIZE_OP_REPEAT_INC           (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_REPEAT_INC_NG        (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_PUSH_POS              SIZE_OPCODE
#define SIZE_OP_PUSH_POS_NOT         (SIZE_OPCODE + SIZE_RELADDR)
#define SIZE_OP_POP_POS               SIZE_OPCODE
#define SIZE_OP_FAIL_POS              SIZE_OPCODE
#define SIZE_OP_SET_OPTION           (SIZE_OPCODE + SIZE_OPTION)
#define SIZE_OP_SET_OPTION_PUSH      (SIZE_OPCODE + SIZE_OPTION)
#define SIZE_OP_FAIL                  SIZE_OPCODE
#define SIZE_OP_MEMORY_START_PUSH    (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_MEMORY_END_PUSH      (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_MEMORY_END           (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_PUSH_STOP_BT          SIZE_OPCODE
#define SIZE_OP_POP_STOP_BT           SIZE_OPCODE
#define SIZE_OP_NULL_CHECK_START     (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_NULL_CHECK_END       (SIZE_OPCODE + SIZE_MEMNUM)

#define IS_NEED_STR_LEN_OP_EXACT(op) \
   ((op) == OP_EXACTN    || (op) == OP_EXACTMB2N ||\
    (op) == OP_EXACTMB4N || (op) == OP_EXACTMBN)


static int AddOpCode(regex_t* reg, int opcode)
{
  BBUF_ADD1(reg, opcode);
  return 0;
}

static int AddRelAddr(regex_t* reg, int addr)
{
  RelAddrType ra = (RelAddrType )addr;
  BBUF_ADD(reg, &ra, SIZE_RELADDR);
  return 0;
}

static int AddLength(regex_t* reg, int len)
{
  LengthType l = (LengthType )len;
  BBUF_ADD(reg, &l, SIZE_LENGTH);
  return 0;
}

static int AddMemNum(regex_t* reg, int num)
{
  MemNumType n = (MemNumType )num;
  BBUF_ADD(reg, &n, SIZE_MEMNUM);
  return 0;
}

static int AddRepeatNum(regex_t* reg, int num)
{
  RepeatNumType n = (RepeatNumType )num;
  BBUF_ADD(reg, &n, SIZE_REPEATNUM);
  return 0;
}

static int AddOption(regex_t* reg, RegOptionType option)
{
  BBUF_ADD(reg, &option, SIZE_OPTION);
  return 0;
}

static int AddOpCodeRelAddr(regex_t* reg, int opcode, int addr)
{
  int r;

  r = AddOpCode(reg, opcode);
  if (r) return r;
  r = AddRelAddr(reg, addr);
  return r;
}

static int AddBytes(regex_t* reg, UChar* bytes, int len)
{
  BBUF_ADD(reg, bytes, len);
  return 0;
}

static int AddBitSet(regex_t* reg, BitSetRef bs)
{
  BBUF_ADD(reg, bs, SIZE_BITSET);
  return 0;
}

static int AddOpCodeOption(regex_t* reg, int opcode, RegOptionType option)
{
  int r;

  r = AddOpCode(reg, opcode);
  if (r) return r;
  r = AddOption(reg, option);
  return r;
}

static int compileLengthTree(Node* node, regex_t* reg);

static int selectStrOpCode(int mb_len, int str_len)
{
  int op;

  switch (mb_len) {
  case 1:
    switch (str_len) {
    case 1:  op = OP_EXACT1; break;
    case 2:  op = OP_EXACT2; break;
    case 3:  op = OP_EXACT3; break;
    case 4:  op = OP_EXACT4; break;
    case 5:  op = OP_EXACT5; break;
    default: op = OP_EXACTN; break;
    }
    break;

  case 2:
    switch (str_len) {
    case 1:  op = OP_EXACTMB2N1; break;
    case 2:  op = OP_EXACTMB2N2; break;
    case 3:  op = OP_EXACTMB2N3; break;
    default: op = OP_EXACTMB2N; break;
    }
    break;

  case 4:
    op = OP_EXACTMB4N;
    break;

  default:
    op = OP_EXACTMBN;
    break;
  }
  return op;
}

static int compileTree(Node* node, regex_t* reg);

static int compileTreeEmptyCheck(Node* node, regex_t* reg, int empty)
{
  int r;
  int saved_num_null_check = reg->num_null_check;

  if (empty) {
    r = AddOpCode(reg, OP_NULL_CHECK_START);
    if (r) return r;
    r = AddMemNum(reg, reg->num_null_check); /* NULL CHECK ID */
    if (r) return r;
    reg->num_null_check++;
  }

  r = compileTree(node, reg);
  if (r) return r;

  if (empty) {
    r = AddOpCode(reg, OP_NULL_CHECK_END);
    if (r) return r;
    r = AddMemNum(reg, saved_num_null_check); /* NULL CHECK ID */
  }
  return r;
}

static int compileTreeNtimes(Node* node, int n, regex_t* reg)
{
  int i, r;

  for (i = 0; i < n; i++) {
    r = compileTree(node, reg);
    if (r) return r;
  }
  return 0;
}

static int addCompileStringLength(UChar* s, int mb_len, int str_len, regex_t* reg)
{
  int len;
  int op = selectStrOpCode(mb_len, str_len);

  len = SIZE_OPCODE;
  if (op == OP_EXACTMBN)
    len += SIZE_LENGTH;

  if (IS_NEED_STR_LEN_OP_EXACT(op))
    len += SIZE_LENGTH;

  len += mb_len * str_len;
  return len;
}

static int addCompileString(UChar* s, int mb_len, int str_len, regex_t* reg)
{
  int op = selectStrOpCode(mb_len, str_len);
  AddOpCode(reg, op);

  if (op == OP_EXACTMBN)
    AddLength(reg, mb_len);

  if (IS_NEED_STR_LEN_OP_EXACT(op))
    AddLength(reg, str_len);

  AddBytes(reg, s, mb_len * str_len);
  return 0;
}


static int compileLengthStringNode(StrNode* sn, regex_t* reg)
{
  int rlen, r, len, prev_len, slen;
  RegCharCodeType code = reg->code;
  UChar *p, *prev;

  if (sn->end <= sn->s)
    return 0;

  p = prev = sn->s;
  prev_len = mblen(code, *p);
  p += prev_len;
  slen = 1;
  rlen = 0;

  for (; p < sn->end; ) {
    len = mblen(code, *p);
    if (len == prev_len) {
      slen++;
    }
    else {
      r = addCompileStringLength(prev, prev_len, slen, reg);
      if (r) return r;
      rlen += r;
      prev = p;
      slen = 1;
      prev_len = len;
    }

    p += len;
  }
  r = addCompileStringLength(prev, prev_len, slen, reg);
  if (r) return r;
  rlen += r;
  return rlen;
}

static int compileLengthStringRawNode(StrNode* sn, regex_t* reg)
{
  int len;

  if (sn->end <= sn->s)
    return 0;

  len = sn->end - sn->s;
  if (len == 1)
    return SIZE_OPCODE + 1;
  else
    return SIZE_OPCODE + SIZE_LENGTH + len;
}

static int compileStringNode(StrNode* sn, regex_t* reg)
{
  int r, len, prev_len, slen;
  RegCharCodeType code = reg->code;
  UChar *p, *prev;

  if (sn->end <= sn->s)
    return 0;

  p = prev = sn->s;
  prev_len = mblen(code, *p);
  p += prev_len;
  slen = 1;

  for (; p < sn->end; ) {
    len = mblen(code, *p);
    if (len == prev_len) {
      slen++;
    }
    else {
      r = addCompileString(prev, prev_len, slen, reg);
      if (r) return r;
      prev = p;
      slen = 1;
      prev_len = len;
    }

    p += len;
  }
  return addCompileString(prev, prev_len, slen, reg);
}

static int compileStringRawNode(StrNode* sn, regex_t* reg)
{
  int len;

  if (sn->end <= sn->s)
    return 0;

  len = sn->end - sn->s;
  if (len == 1) {
    AddOpCode(reg, OP_EXACT1_RAW);
    AddBytes(reg, sn->s, 1);
  }
  else {
    AddOpCode(reg, OP_EXACTN_RAW);
    AddLength(reg, len);
    AddBytes(reg, sn->s, len);
  }

  return 0;
}

static int addMultiByteCClassOffset(BBuf* mbuf, regex_t* reg, int offset)
{
  AddLength(reg, mbuf->used - offset);
  return AddBytes(reg, mbuf->p + offset, mbuf->used - offset);
}

static int compileLengthCClassNode(CClassNode* cc, regex_t* reg)
{
  int len;

  if (IS_NULL(cc->mbuf)) {
    len = SIZE_OPCODE + SIZE_BITSET;
  }
  else {
    if (BitSetIsEmpty(cc->bs)) {
      len = SIZE_OPCODE;  /* SIZE_BITSET is included in mbuf->used. */
    }
    else {
      len = SIZE_OPCODE;  /* SIZE_BITSET is included in mbuf->used. */
    }
    len += SIZE_LENGTH + cc->mbuf->used;
  }

  return len;
}

static int compileCClassNode(CClassNode* cc, regex_t* reg)
{
  int r;

  if (IS_NULL(cc->mbuf)) {
    if (cc->not)  AddOpCode(reg, OP_CCLASS_NOT);
    else          AddOpCode(reg, OP_CCLASS);

    r = AddBitSet(reg, cc->bs);
  }
  else {
    if (BitSetIsEmpty(cc->bs)) {
      if (cc->not)  AddOpCode(reg, OP_CCLASS_MB_NOT);
      else          AddOpCode(reg, OP_CCLASS_MB);

      r = AddBitSet(reg, (BitSetRef )cc->mbuf->p);
      if (r) return r;
      r = addMultiByteCClassOffset(cc->mbuf, reg, SIZE_BITSET);
    }
    else {
      if (cc->not)  AddOpCode(reg, OP_CCLASS_MIX_NOT);
      else          AddOpCode(reg, OP_CCLASS_MIX);

      r = AddBitSet(reg, cc->bs);
      if (r) return r;
      r = addMultiByteCClassOffset(cc->mbuf, reg, SIZE_BITSET);
    }
  }

  return r;
}

static int compileRangeRepeat(QualifierNode* qn, int target_len,
			      regex_t* reg)
{
  int r;
  int saved_num_repeat = reg->num_repeat;

  r = AddOpCode(reg, qn->greedy ? OP_REPEAT : OP_REPEAT_NG);
  if (r) return r;
  r = AddMemNum(reg, reg->num_repeat); /* OP_REPEAT ID */
  reg->num_repeat++;
  if (r) return r;
  r = AddRelAddr(reg, target_len + SIZE_OP_REPEAT_INC);
  if (r) return r;
  r = AddRepeatNum(reg, qn->lower);
  if (r) return r;
  r = AddRepeatNum(reg, qn->upper);
  if (r) return r;

  r = compileTreeEmptyCheck(qn->target, reg, qn->target_empty);
  if (r) return r;

  r = AddOpCode(reg, qn->greedy ? OP_REPEAT_INC : OP_REPEAT_INC_NG);
  if (r) return r;
  r = AddMemNum(reg, saved_num_repeat); /* OP_REPEAT ID */
  return r;
}

#define QUALIFIER_EXPAND_LIMIT_SIZE   50

static int compileLengthQualifierNode(QualifierNode* qn, regex_t* reg)
{
  int len, mod_tlen;
  int infinite = IS_REPEAT_INFINITE(qn->upper);
  int tlen = compileLengthTree(qn->target, reg);

  if (tlen < 0) return tlen;

  /* anychar repeat */
  if (NTYPE(qn->target) == N_ANYCHAR) {
    if (qn->greedy && infinite) {
      return SIZE_OPCODE + tlen * qn->lower;
    }
  }

  if (qn->target_empty)
    mod_tlen = tlen + (SIZE_OP_NULL_CHECK_START + SIZE_OP_NULL_CHECK_END);
  else
    mod_tlen = tlen;

  if (infinite &&
      (qn->lower <= 1 || tlen * qn->lower <= QUALIFIER_EXPAND_LIMIT_SIZE)) {
    if (qn->lower == 1 && tlen > QUALIFIER_EXPAND_LIMIT_SIZE) {
      len = SIZE_OP_JUMP;
    }
    else {
      len = tlen * qn->lower;
    }

    if (qn->greedy) {
      if (IS_NOT_NULL(qn->head_exact))
	len += SIZE_OP_PUSH_OR_JUMP_EXACT1 + mod_tlen + SIZE_OP_JUMP;
      else
	len += SIZE_OP_PUSH + mod_tlen + SIZE_OP_JUMP;
    }
    else
      len += SIZE_OP_JUMP + mod_tlen + SIZE_OP_PUSH;
  }
  else if (!infinite && qn->greedy &&
	   (tlen + SIZE_OP_PUSH) * qn->upper <= QUALIFIER_EXPAND_LIMIT_SIZE) {
    len = tlen * qn->lower;
    len += (SIZE_OP_PUSH + tlen) * (qn->upper - qn->lower);
  }
  else {
    len = SIZE_OP_REPEAT_INC + SIZE_REPEATNUM * 2 + SIZE_MEMNUM
        + mod_tlen + SIZE_OPCODE + SIZE_RELADDR;
  }

  return len;
}

static int compileQualifierNode(QualifierNode* qn, regex_t* reg)
{
  int i, r, mod_tlen;
  int infinite = IS_REPEAT_INFINITE(qn->upper);
  int tlen = compileLengthTree(qn->target, reg);

  if (tlen < 0) return tlen;

  /* anychar repeat */
  if (NTYPE(qn->target) == N_ANYCHAR) {
    if (qn->greedy && infinite) {
      r = compileTreeNtimes(qn->target, qn->lower, reg);
      if (r) return r;
      return AddOpCode(reg, OP_ANYCHAR_STAR);
    }
  }

  if (qn->target_empty)
    mod_tlen = tlen + (SIZE_OP_NULL_CHECK_START + SIZE_OP_NULL_CHECK_END);
  else
    mod_tlen = tlen;

  if (infinite &&
      (qn->lower <= 1 || tlen * qn->lower <= QUALIFIER_EXPAND_LIMIT_SIZE)) {
    if (qn->lower == 1 && tlen > QUALIFIER_EXPAND_LIMIT_SIZE) {
      if (qn->greedy) {
	if (IS_NOT_NULL(qn->head_exact))
	  r = AddOpCodeRelAddr(reg, OP_JUMP, SIZE_OP_PUSH_OR_JUMP_EXACT1);
	else
	  r = AddOpCodeRelAddr(reg, OP_JUMP, SIZE_OP_PUSH);
      }
      else {
	r = AddOpCodeRelAddr(reg, OP_JUMP, SIZE_OP_JUMP);
      }
      if (r) return r;
    }
    else {
      r = compileTreeNtimes(qn->target, qn->lower, reg);
      if (r) return r;
    }

    if (qn->greedy) {
      if (IS_NOT_NULL(qn->head_exact)) {
	r = AddOpCodeRelAddr(reg, OP_PUSH_OR_JUMP_EXACT1,
			     mod_tlen + SIZE_OP_JUMP);
	if (r) return r;
	AddBytes(reg, NSTRING(qn->head_exact).s, 1);
	r = compileTreeEmptyCheck(qn->target, reg, qn->target_empty);
	if (r) return r;
	r = AddOpCodeRelAddr(reg, OP_JUMP,
		     -(mod_tlen + SIZE_OP_JUMP + SIZE_OP_PUSH_OR_JUMP_EXACT1));
      }
      else {
	r = AddOpCodeRelAddr(reg, OP_PUSH, mod_tlen + SIZE_OP_JUMP);
	if (r) return r;
	r = compileTreeEmptyCheck(qn->target, reg, qn->target_empty);
	if (r) return r;
	r = AddOpCodeRelAddr(reg, OP_JUMP,
			     -(mod_tlen + SIZE_OP_JUMP + SIZE_OP_PUSH));
      }
    }
    else {
      r = AddOpCodeRelAddr(reg, OP_JUMP, mod_tlen);
      if (r) return r;
      r = compileTreeEmptyCheck(qn->target, reg, qn->target_empty);
      if (r) return r;
      r = AddOpCodeRelAddr(reg, OP_PUSH, -(mod_tlen + SIZE_OP_PUSH));
    }
  }
  else if (!infinite && qn->greedy &&
	   (tlen + SIZE_OP_PUSH) * qn->upper <= QUALIFIER_EXPAND_LIMIT_SIZE) {
    int n = qn->upper - qn->lower;

    r = compileTreeNtimes(qn->target, qn->lower, reg);
    if (r) return r;

    for (i = 0; i < n; i++) {
      r = AddOpCodeRelAddr(reg, OP_PUSH,
			   (n - i) * tlen + (n - i - 1) * SIZE_OP_PUSH);
      if (r) return r;
      r = compileTree(qn->target, reg);
      if (r) return r;
    }
  }
  else {
    r = compileRangeRepeat(qn, mod_tlen, reg);
  }
  return r;
}

static int compileLengthOption(OptionNode* node, regex_t* reg)
{
  int len;
  int tlen = compileLengthTree(node->target, reg);

  if (tlen < 0) return tlen;

  len = SIZE_OP_SET_OPTION_PUSH + SIZE_OP_SET_OPTION + SIZE_OP_FAIL
      + tlen + SIZE_OP_SET_OPTION;

  return len;
}

static int compileOption(OptionNode* node, regex_t* reg)
{
  int r;
  RegOptionType prev = reg->options;

  if (IS_IGNORECASE(node->option) && IS_NULL(reg->transtable))
    return REGERR_TABLE_FOR_IGNORE_CASE_IS_NOT_SETTED;

  r = AddOpCodeOption(reg, OP_SET_OPTION_PUSH, node->option);
  if (r) return r;
  r = AddOpCodeOption(reg, OP_SET_OPTION, prev);
  if (r) return r;
  r = AddOpCode(reg, OP_FAIL);
  if (r) return r;

  reg->options = node->option;
  r = compileTree(node->target, reg);
  reg->options = prev;
  if (r) return r;

  r = AddOpCodeOption(reg, OP_SET_OPTION, prev);
  return r;
}

static int compileLengthEffectNode(EffectNode* node, regex_t* reg)
{
  int len;
  int tlen = compileLengthTree(node->target, reg);

  if (tlen < 0) return tlen;

  switch (node->type) {
  case EFFECT_MEMORY:
    if (GET_MEM_STATS_AT(reg->mem_stats, node->regnum))
      len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_MEMORY_END_PUSH;
    else
      len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_MEMORY_END;
    break;
  case EFFECT_PREC_READ:
    len = SIZE_OP_PUSH_POS + tlen + SIZE_OP_POP_POS;
    break;
  case EFFECT_PREC_READ_NOT:
    len = SIZE_OP_PUSH_POS_NOT + tlen + SIZE_OP_FAIL_POS;
    break;
  case EFFECT_STOP_BACKTRACK:
    len = SIZE_OP_PUSH_STOP_BT + tlen + SIZE_OP_POP_STOP_BT;
    break;
  }

  return len;
}

static int compileEffectNode(EffectNode* node, regex_t* reg)
{
  int r, len;

  switch (node->type) {
  case EFFECT_MEMORY:
    r = AddOpCode(reg, OP_MEMORY_START_PUSH);
    if (r) return r;
    r = AddMemNum(reg, node->regnum);
    if (r) return r;
    r = compileTree(node->target, reg);
    if (r) return r;

    if (GET_MEM_STATS_AT(reg->mem_stats, node->regnum))
      r = AddOpCode(reg, OP_MEMORY_END_PUSH);
    else
      r = AddOpCode(reg, OP_MEMORY_END);

    if (r) return r;
    r = AddMemNum(reg, node->regnum);
    break;

  case EFFECT_PREC_READ:
    len = compileLengthTree(node->target, reg);
    if (len < 0) return len;
    r = AddOpCode(reg, OP_PUSH_POS);
    if (r) return r;
    r = compileTree(node->target, reg);
    if (r) return r;
    r = AddOpCode(reg, OP_POP_POS);
    break;

  case EFFECT_PREC_READ_NOT:
    len = compileLengthTree(node->target, reg);
    if (len < 0) return len;
    r = AddOpCodeRelAddr(reg, OP_PUSH_POS_NOT, len + SIZE_OP_FAIL_POS);
    if (r) return r;
    r = compileTree(node->target, reg);
    if (r) return r;
    r = AddOpCode(reg, OP_FAIL_POS);
    break;

  case EFFECT_STOP_BACKTRACK:
    r = AddOpCode(reg, OP_PUSH_STOP_BT);
    if (r) return r;
    r = compileTree(node->target, reg);
    if (r) return r;
    r = AddOpCode(reg, OP_POP_STOP_BT);
    break;
  }

  return r;
}

static int compileLengthTree(Node* node, regex_t* reg)
{
  int len, type, r;

  type = NTYPE(node);
  switch (type) {
  case N_EMPTY:
    r = 0;
    break;

  case N_LIST:
    len = 0;
    do {
      r = compileLengthTree(NCONS(node).left, reg);
      if (r < 0) return r;
      len += r;
    } while (IS_NOT_NULL(node = NCONS(node).right));
    r = len;
    break;

  case N_ALT:
    {
      int n;

      n = r = 0;
      do {
	r += compileLengthTree(NCONS(node).left, reg);
	n++;
      } while (IS_NOT_NULL(node = NCONS(node).right));
      r += (SIZE_OP_PUSH + SIZE_OP_JUMP) * (n - 1);
    }
    break;

  case N_STRING:
    r = compileLengthStringNode(&(NSTRING(node)), reg);
    break;

  case N_STRING_RAW:
    r = compileLengthStringRawNode(&(NSTRING(node)), reg);
    break;

  case N_CCLASS:
    r = compileLengthCClassNode(&(NCCLASS(node)), reg);
    break;

  case N_CTYPE:
    r = SIZE_OPCODE;
    break;

  case N_ANYCHAR:
    r = SIZE_OPCODE;
    break;

  case N_ANCHOR:
    r = SIZE_OPCODE;
    break;

  case N_BACKREF:
    {
      int n = NBACKREF(node).regnum;
      if (n <= 3)
	r = SIZE_OPCODE;
      else
	r = SIZE_OPCODE + SIZE_MEMNUM;
    }
    break;

  case N_QUALIFIER:
    r = compileLengthQualifierNode(&(NQUALIFIER(node)), reg);
    break;

  case N_OPTION:
    r = compileLengthOption(&(NOPTION(node)), reg);
    break;

  case N_EFFECT:
    r = compileLengthEffectNode(&NEFFECT(node), reg);
    break;
  }

  return r;
}

static int compileTree(Node* node, regex_t* reg)
{
  int n, type, len, op, pos, r = 0;

  type = NTYPE(node);
  switch (type) {
  case N_EMPTY:
    r = 0;
    break;

  case N_LIST:
    do {
      r = compileTree(NCONS(node).left, reg);
    } while (r == 0 && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_ALT:
    {
      Node* x = node;
      len = 0;
      do {
	len += compileLengthTree(NCONS(x).left, reg);
	if (NCONS(x).right != NULL) {
	  len += SIZE_OP_PUSH + SIZE_OP_JUMP;
	}
      } while (IS_NOT_NULL(x = NCONS(x).right));
      pos = reg->used + len;  /* goal position */

      do {
	len = compileLengthTree(NCONS(node).left, reg);
	if (IS_NOT_NULL(NCONS(node).right)) {
	  r = AddOpCodeRelAddr(reg, OP_PUSH, len + SIZE_OP_JUMP);
	  if (r) break;
	}
	r = compileTree(NCONS(node).left, reg);
	if (r) break;
	if (IS_NOT_NULL(NCONS(node).right)) {
	  len = pos - (reg->used + SIZE_OP_JUMP);
	  r = AddOpCodeRelAddr(reg, OP_JUMP, len);
	  if (r) break;
	}
      } while (IS_NOT_NULL(node = NCONS(node).right));
    }
    break;

  case N_STRING:
    r = compileStringNode(&(NSTRING(node)), reg);
    break;

  case N_STRING_RAW:
    r = compileStringRawNode(&(NSTRING(node)), reg);
    break;

  case N_CCLASS:
    r = compileCClassNode(&(NCCLASS(node)), reg);
    break;

  case N_CTYPE:
    switch (NCTYPE(node).type) {
    case CTYPE_WORD:            op = OP_WORD;           break;
    case CTYPE_NOT_WORD:        op = OP_NOT_WORD;       break;
    case CTYPE_WORD_BOUND:      op = OP_WORD_BOUND;     break;
    case CTYPE_NOT_WORD_BOUND:  op = OP_NOT_WORD_BOUND; break;
#ifdef VALID_WORD_BEGIN_END
    case CTYPE_WORD_BEGIN:      op = OP_WORD_BEGIN;     break;
    case CTYPE_WORD_END:        op = OP_WORD_END;       break;
#endif
    }
    r = AddOpCode(reg, op);
    break;

  case N_ANYCHAR:
    r = AddOpCode(reg, OP_ANYCHAR);
    break;

  case N_ANCHOR:
    switch (NANCHOR(node).type) {
    case ANCHOR_BEGIN_BUF:      op = OP_BEGIN_BUF;      break;
    case ANCHOR_END_BUF:        op = OP_END_BUF;        break;
    case ANCHOR_BEGIN_LINE:     op = OP_BEGIN_LINE;     break;
    case ANCHOR_END_LINE:       op = OP_END_LINE;       break;
    case ANCHOR_SEMI_END_BUF:   op = OP_SEMI_END_BUF;   break;
    case ANCHOR_BEGIN_POSITION: op = OP_BEGIN_POSITION; break;
    }
    r = AddOpCode(reg, op);
    break;

  case N_BACKREF:
    n = NBACKREF(node).regnum;
    switch (n) {
    case 1:  r = AddOpCode(reg, OP_BACKREF1); break;
    case 2:  r = AddOpCode(reg, OP_BACKREF2); break;
    case 3:  r = AddOpCode(reg, OP_BACKREF3); break;
    default:
      AddOpCode(reg, OP_BACKREFN);
      r = AddMemNum(reg, n);
      break;
    }
    break;

  case N_QUALIFIER:
    r = compileQualifierNode(&(NQUALIFIER(node)), reg);
    break;

  case N_OPTION:
    r = compileOption(&(NOPTION(node)), reg);
    break;

  case N_EFFECT:
    r = compileEffectNode(&NEFFECT(node), reg);
    break;

  default:
#ifdef REG_DEBUG
    fprintf(stderr, "compileTree: undefined node type %d\n", NTYPE(node));
#endif
  }

  return r;
}

static int getMinMatchLength(Node* node, RegDistance *min)
{
  RegDistance tmin;
  int r = 0;

  *min = 0;
  switch (NTYPE(node)) {
  case N_EMPTY:
  case N_ANCHOR:
  case N_BACKREF:
    break;

  case N_LIST:
    do {
      r = getMinMatchLength(NCONS(node).left, &tmin);
      if (r == 0) *min += tmin;
    } while (r == 0 && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_ALT:
    do {
      r = getMinMatchLength(NCONS(node).left, &tmin);
      if (r == 0 && *min < tmin) *min = tmin;
    } while (r == 0 && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_STRING:
  case N_STRING_RAW:
    {
      StrNode* sn = &(NSTRING(node));
      *min = sn->end - sn->s;
    }
    break;

  case N_CTYPE:
    switch (NCTYPE(node).type) {
    case CTYPE_WORD:     *min = 1; break;
    case CTYPE_NOT_WORD: *min = 1; break;
    default:
      break;
    }
    break;

  case N_CCLASS:
  case N_ANYCHAR:
    *min = 1;
    break;

  case N_QUALIFIER:
    {
      QualifierNode* qn = &(NQUALIFIER(node));

      if (qn->lower == 0) {
	break;
      }
      else {
	r = getMinMatchLength(qn->target, min);
	if (r == 0) {
	  *min *= qn->lower;
	}
      }
    }
    break;

  case N_OPTION:
    r = getMinMatchLength(NOPTION(node).target, min);
    break;

  case N_EFFECT:
    {
      EffectNode* en = &(NEFFECT(node));
      switch (en->type) {
      case EFFECT_MEMORY:
      case EFFECT_STOP_BACKTRACK:
	r = getMinMatchLength(en->target, min);
	break;

      case EFFECT_PREC_READ:
      case EFFECT_PREC_READ_NOT:
	break;
      }
    }
    break;

  default:
    break;
  }

  return r;
}

static Node* getHeadExactNode(Node* node, regex_t* reg)
{
  Node* n = (Node* )NULL;

  switch (NTYPE(node)) {
  case N_EMPTY:
  case N_ANCHOR:
  case N_BACKREF:
  case N_ALT:
  case N_CTYPE:
  case N_CCLASS:
  case N_ANYCHAR:
    break;

  case N_LIST:
    n = getHeadExactNode(NCONS(node).left, reg);
    break;

  case N_STRING:
    if (IS_IGNORECASE(reg->options))
      break;
    /* fall */
  case N_STRING_RAW:
    {
      StrNode* sn = &(NSTRING(node));
      if (sn->end > sn->s)
	n = node;
    }
    break;

  case N_QUALIFIER:
    {
      QualifierNode* qn = &(NQUALIFIER(node));
      if (qn->lower > 0) {
	if (IS_NOT_NULL(qn->head_exact))
	  n = qn->head_exact;
	else
	  n = getHeadExactNode(qn->target, reg);
      }
    }
    break;

  case N_OPTION:
    {
      RegOptionType options = reg->options;

      reg->options = NOPTION(node).option;
      n = getHeadExactNode(NOPTION(node).target, reg);
      reg->options = options;
    }
    break;

  case N_EFFECT:
    {
      EffectNode* en = &(NEFFECT(node));
      switch (en->type) {
      case EFFECT_MEMORY:
      case EFFECT_STOP_BACKTRACK:
      case EFFECT_PREC_READ:
	n = getHeadExactNode(en->target, reg);
	break;

      case EFFECT_PREC_READ_NOT:
	break;
      }
    }
    break;

  default:
    break;
  }

  return n;
}

#define IN_ALT             1
#define IN_PREC_READ_NOT   2

/* check empty loop, process ignore-case in char class */
static int setupTree(Node* node, regex_t* reg, int state)
{
  int type;
  int r = 0;

  type = NTYPE(node);
  switch (type) {
  case N_EMPTY:
    break;

  case N_LIST:
    do {
      r = setupTree(NCONS(node).left, reg, state);
    } while (r == 0 && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_ALT:
    do {
      r = setupTree(NCONS(node).left, reg, (state | IN_ALT));
    } while (r == 0 && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_CCLASS:
    if (IS_IGNORECASE(reg->options)) {
      int c, t;
      BitSetRef bs = NCCLASS(node).bs;
      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
	t = TTRANS(reg->transtable, c);
	if (t != c) {
	  if (BITSET_AT(bs, c)) BITSET_SET_BIT(bs, t);
	  if (BITSET_AT(bs, t)) BITSET_SET_BIT(bs, c);
	}
      }
    }
    break;

  case N_STRING:
  case N_STRING_RAW:
  case N_CTYPE:
  case N_ANYCHAR:
  case N_ANCHOR:
    break;

  case N_BACKREF:
    {
      int num = NBACKREF(node).regnum;

      MEM_STATS_ON_AT(reg->mem_stats, num);
    }
    break;

  case N_QUALIFIER:
    {
      RegDistance min;
      QualifierNode* qn = &(NQUALIFIER(node));

      if (IS_REPEAT_INFINITE(qn->upper) || qn->upper > 1) {
	r = getMinMatchLength(qn->target, &min);
	if (min == 0) {
	  qn->target_empty = 1;
	}
      }
      r = setupTree(qn->target, reg, state);
#ifdef USE_OP_PUSH_OR_JUMP_EXACT
      if (qn->greedy && !qn->target_empty) {
	StrNode* sn;
	qn->head_exact = getHeadExactNode(qn->target, reg);
	if (IS_NOT_NULL(qn->head_exact)) {
	  sn = &(NSTRING(qn->head_exact));
	  if (sn->s + 1 > sn->end)
	    qn->head_exact = (Node* )NULL;
	}
      }
#endif
    }
    break;

  case N_OPTION:
    {
      RegOptionType options = reg->options;

      reg->options = NOPTION(node).option;
      r = setupTree(NOPTION(node).target, reg, state);
      reg->options = options;
    }
    break;

  case N_EFFECT:
    {
      EffectNode* en = &(NEFFECT(node));

      switch (en->type) {
      case EFFECT_MEMORY:
	if ((state & IN_ALT) || (state & IN_PREC_READ_NOT))
	  MEM_STATS_ON_AT(reg->mem_stats, en->regnum);

	/* fall */
      case EFFECT_STOP_BACKTRACK:
      case EFFECT_PREC_READ:
	r = setupTree(en->target, reg, state);
	break;

      case EFFECT_PREC_READ_NOT:
	r = setupTree(en->target, reg, (state | IN_PREC_READ_NOT));
	break;
      }
    }
    break;

  default:
    break;
  }

  return r;
}


/* exact mode */
#define SO_CONTINUE   0
#define SO_END        1

#define MAX_OPT_EXACT_LEN       32
#define MAX_OPT_EXACT_LEN1      33

#define EXACT_BUF_FULL(ebuf)    ((ebuf)->len >= MAX_OPT_EXACT_LEN)
#define EXACT_BUF_VALID(ebuf)   ((ebuf)->len > 0)
#define MAP_BUF_VALID(mbuf)     ((mbuf)->n > 0)

typedef struct {
  RegDistance dmin;        /* min-distance from head */
  RegDistance dmax;        /* max-distance from head */
  int         pos_id;      /* position counter (for same position check) */
  int         anchor;

  RegCharCodeType   code;
  RegOptionType     options;
  RegTransTableType transtable;
  Node             *root;
} OptBuf;

typedef struct {
  RegDistance dmin;    /* min-distance from head */
  RegDistance dmax;    /* max-distance from head */
  int pos_id;          /* position counter (from OptBuf.pos) */
  int start_anchor;
  int end_anchor;
  int len;
  int ignore_case;
  int mode;
  UChar buf[MAX_OPT_EXACT_LEN1];
} ExactBuf;

typedef struct {
  RegDistance dmin;        /* min-distance from head */
  RegDistance dmax;        /* max-distance from head */
  int         pos_id;      /* position counter (from OptBuf.pos) */
  int         start_anchor;
  int         end_anchor;
  int         n;           /* map entry num or 0(invalid) */
  int         value;       /* weighted num value */
  UChar map[REG_CHAR_TABLE_SIZE];
} MapBuf;


static void OptBufInit(OptBuf* obuf, regex_t* reg, Node* root)
{
  obuf->dmin = obuf->dmax = 0;
  obuf->pos_id     = 0;
  obuf->anchor     = 0;
  obuf->code       = reg->code;
  obuf->options    = reg->options;
  obuf->transtable = reg->transtable;
  obuf->root       = root;
}

static void OptBufCopy(OptBuf* obuf, OptBuf* from)
{
  obuf->dmin       = from->dmin;
  obuf->dmax       = from->dmax;
  obuf->pos_id     = from->pos_id;
  obuf->anchor     = from->anchor;
  obuf->code       = from->code;
  obuf->options    = from->options;
  obuf->transtable = from->transtable;
  obuf->root       = from->root;
}

static void OptBufReset(OptBuf* obuf, RegDistance min, RegDistance max)
{
  if ((obuf->anchor & ANCHOR_BEGIN_BUF) == 0) {
    obuf->dmax = max;
    obuf->dmin = min;
  }
}

static void OptBufInc(OptBuf* obuf, RegDistance inc_min, RegDistance inc_max)
{
  DISTANCE_INC(obuf->dmax, inc_max);
  DISTANCE_INC(obuf->dmin, inc_min);

  obuf->pos_id++;
  obuf->anchor = 0;
}

static void OptBufMergeAlt(OptBuf* obuf, OptBuf* from)
{
  if (obuf->dmin > from->dmin)
    obuf->dmin = from->dmin;

  if (obuf->dmax < from->dmax)
    obuf->dmax = from->dmax;

  if (obuf->pos_id < from->pos_id)
    obuf->pos_id = from->pos_id;

  obuf->pos_id++;
  obuf->anchor = 0;
}

#ifdef REG_DEBUG
static void PrintDistanceRange(FILE* f, RegDistance a, RegDistance b)
{
  if (a == INFINITE_DISTANCE)
    fputs("inf", f);
  else
    fprintf(f, "(%u)", a);

  fputs("-", f);

  if (b == INFINITE_DISTANCE)
    fputs("inf", f);
  else
    fprintf(f, "(%u)", b);
}

static void PrintAnchor(FILE* f, int anchor)
{
  int q = 0;

  fprintf(f, "[");

  if (anchor & ANCHOR_BEGIN_BUF) {
    fprintf(f, "begin-buf");
    q = 1;
  }
  if (anchor & ANCHOR_BEGIN_LINE) {
    if (q) fprintf(f, ", ");
    q = 1;
    fprintf(f, "begin-line");
  }
  if (anchor & ANCHOR_BEGIN_POSITION) {
    if (q) fprintf(f, ", ");
    q = 1;
    fprintf(f, "begin-pos");
  }
  if (anchor & ANCHOR_END_BUF) {
    if (q) fprintf(f, ", ");
    q = 1;
    fprintf(f, "end-buf");
  }
  if (anchor & ANCHOR_SEMI_END_BUF) {
    if (q) fprintf(f, ", ");
    q = 1;
    fprintf(f, "semi-end-buf");
  }
  if (anchor & ANCHOR_END_LINE) {
    if (q) fprintf(f, ", ");
    q = 1;
    fprintf(f, "end-line");
  }
  if (anchor & ANCHOR_ANYCHAR_STAR) {
    if (q) fprintf(f, ", ");
    q = 1;
    fprintf(f, "anychar-star");
  }
  if (anchor & ANCHOR_ANYCHAR_STAR_PL) {
    if (q) fprintf(f, ", ");
    fprintf(f, "anychar-star-pl");
  }

  fprintf(f, "]");
}

static void PrintExactBuf(FILE* f, ExactBuf* buf)
{
  fprintf(f, "exact: ");

  PrintDistanceRange(f, buf->dmin, buf->dmax);
  if (EXACT_BUF_VALID(buf))
    fprintf(f, ":%s ", buf->buf);
  else
    fprintf(f, ":!INVALID! ");

  if (buf->ignore_case) fprintf(f, "(ignore-case) ");
  PrintAnchor(f, buf->start_anchor);
  fprintf(f, ", ");
  PrintAnchor(f, buf->end_anchor);

  fprintf(f, "\n");
}
#endif


static void ExactBufInit(ExactBuf* buf, OptBuf* obuf)
{
  buf->dmin   = obuf->dmin;
  buf->dmax   = obuf->dmax;
  buf->pos_id = obuf->pos_id;

  buf->start_anchor = obuf->anchor;
  buf->end_anchor   = 0;
  buf->buf[0]       = (UChar )NULL;
  buf->len          = 0;
  buf->ignore_case  = 0;
  buf->mode         = SO_CONTINUE;
}

static void ExactBufCopy(ExactBuf* buf, ExactBuf* from)
{
  int i;

  buf->dmin         = from->dmin;
  buf->dmax         = from->dmax;
  buf->pos_id       = from->pos_id;
  buf->start_anchor = from->start_anchor;
  buf->end_anchor   = from->end_anchor;

  for (i = 0; i < from->len; i++)
    buf->buf[i] = from->buf[i];

  buf->buf[from->len] = (UChar )NULL;

  buf->len         = from->len;
  buf->ignore_case = from->ignore_case;
  buf->mode        = from->mode;
}

static void ExactBufAddStr(ExactBuf* buf, UChar* s, UChar* end,
			   RegCharCodeType code)
{
  int i, x, len;

  for (x = buf->len; s < end && x < MAX_OPT_EXACT_LEN; ) {
    len = mblen(code, *s);
    if (x + len > MAX_OPT_EXACT_LEN)
      break;

    for (i = 0; i < len; i++)
      buf->buf[x++] = *s++;
  }

  buf->len = x;
  buf->buf[buf->len] = (UChar )NULL;

  if (s < end || buf->len >= MAX_OPT_EXACT_LEN)
    buf->mode = SO_END;

  if (s < end)
    buf->end_anchor = 0;
}

static void ExactBufAdd(ExactBuf* buf, ExactBuf* from, RegCharCodeType code)
{
  ExactBufAddStr(buf, from->buf, &(from->buf[from->len]), code);
}

static void ExactBufIntersect(ExactBuf* to, ExactBuf* from, RegCharCodeType code)
{
  int i, len, min;

  if (to->ignore_case != from->ignore_case) {
    to->start_anchor = 0;
    to->end_anchor   = 0;
    to->buf[0]       = (UChar )NULL;
    to->len          = 0;
    to->ignore_case  = 0;
    to->mode         = SO_CONTINUE;
    return ;
  }

  min = to->len;
  if (from->len < min) min = from->len;

  i = 0;
  while (1) {
    len = mblen(code, from->buf[i]);
    if (i + len > min)
      break;
    if (Strncmp(from->buf + i, to->buf + i, len) != 0)
      break;

    i += len;
  }
  to->buf[i] = (UChar )NULL;
  to->len = i;
  to->start_anchor &= from->start_anchor;
  to->end_anchor   &= from->end_anchor;
}

#define EXACT_UPDATE_DMAX0_LEN_THRESHOLD   3
#define EXACT_IGNORE_CASE_POINT            3

static void ExactBufUpdateBetter(ExactBuf* to, ExactBuf* from)
{
  if (!EXACT_BUF_VALID(from))
    return ;

  if (!EXACT_BUF_VALID(to)) {
    goto update;
  }
  else if (to->dmax == INFINITE_DISTANCE) {
    if (from->dmax < INFINITE_DISTANCE || to->len < from->len)
      goto update;
  }
  else if (from->dmax < INFINITE_DISTANCE) {
    int z, to_len, from_len;
    RegDistance df, dt;

    df = from->dmax - from->dmin;
    dt = to->dmax   - to->dmin;

    if (from->ignore_case != to->ignore_case) {
      from_len = from->len + (from->ignore_case ? 0 : EXACT_IGNORE_CASE_POINT);
      to_len   = to->len   + (to->ignore_case   ? 0 : EXACT_IGNORE_CASE_POINT);
    }

    if (dt == 0) {
      if (to->dmax == 0 && to->len >= EXACT_UPDATE_DMAX0_LEN_THRESHOLD)
	return ;

      if (df == 0) {
	if (to_len < from_len)
	  goto update;
	if (to_len == from_len) {
	  if (to->start_anchor == 0 && from->start_anchor != 0)
	    goto update;
	}
      }

      return ;
    }
    else if (df == 0) {
      goto update;
    }

    df += from->dmax;
    dt += to->dmax;

    z = to_len * df;
    if (z < to_len) { /* overflow */
      if ((from_len / df) > (to_len / dt))
	goto update;
    }
    else {
      if (from_len * dt > z)
	goto update;
    }
  }

  return ;

 update:
  ExactBufCopy(to, from);
}

static void ExactBufRevise(ExactBuf* best, ExactBuf* econt, OptBuf* obuf)
{
  if (econt->mode == SO_END) {
    ExactBufUpdateBetter(best, econt);
    ExactBufInit(econt, obuf);
  }
}


#if 0
#define APPLY_CONTINUE   0
#define APPLY_STOP       1
#define APPLY_END        2
#define APPLY_FIND       3

static int applyTree(Node* node, int (*func)(Node*, void*), void* arg)
{
  int r = APPLY_CONTINUE;

  switch (NTYPE(node)) {
  case N_EMPTY:
    break;

  case N_LIST:
    do {
      r = applyTree(NCONS(node).left, func, arg);
    } while ((r == APPLY_CONTINUE) && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_ALT:
    do {
      r = applyTree(NCONS(node).left, func, arg);
    } while ((r == APPLY_CONTINUE) && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_STRING:
  case N_STRING_RAW:
  case N_CCLASS:
  case N_CTYPE:
  case N_ANYCHAR:
  case N_ANCHOR:
  case N_BACKREF:
    r = func(node, arg);
    break;

  case N_QUALIFIER:
    r = applyTree(NQUALIFIER(node).target, func, arg);
    break;
  case N_OPTION:
    r = applyTree(NOPTION(node).target, func, arg);
    break;
  case N_EFFECT:
    r = applyTree(NEFFECT(node).target, func, arg);
    break;
  default:
    r = REGERR_TYPE_BUG;
    break;
  }

  return r;
}
#endif

static int SetExactInfo(regex_t* reg, Node* node, OptBuf* obuf, 
			ExactBuf* econt, ExactBuf* best);

static int setExactInfoNode(regex_t* reg, OptBuf* obuf,
			    ExactBuf* econt, ExactBuf* best, Node* node)
{
  RegDistance len;
  int i, n, type;
  int r = 0;

  type = NTYPE(node);
  switch (type) {
  case N_EMPTY:
    return 0;
    break;

  case N_LIST:
    do {
      r = setExactInfoNode(reg, obuf, econt, best, NCONS(node).left);
      if (r == 0) ExactBufRevise(best, econt, obuf);
    } while (r == 0 && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_ALT:
    {
      OptBuf zobuf, save;
      ExactBuf zebuf, mix, tbest;
      Node* x = node;

      OptBufCopy(&save, obuf);
      do {
	OptBufCopy(&zobuf,   &save);
	ExactBufCopy(&zebuf, econt);
	ExactBufInit(&tbest, &save);
	r = setExactInfoNode(reg, &zobuf, &zebuf, &tbest, NCONS(x).left);
	if (r == 0) {
	  if (EXACT_BUF_VALID(&tbest)) {
	    if (x == node)
	      ExactBufCopy(&mix, &tbest);
	    else
	      ExactBufIntersect(&mix, &tbest, save.code);
	  }
	  else {
	    if (x == node)
	      ExactBufCopy(&mix, &zebuf);
	    else
	      ExactBufIntersect(&mix, &zebuf, save.code);
	  }
	  OptBufMergeAlt(obuf, &zobuf);
	}
      } while ((r == 0) && IS_NOT_NULL(x = NCONS(x).right));

      if (r == 0) {
	if (mix.mode == SO_CONTINUE)
	  mix.mode = SO_END;

	ExactBufCopy(econt, &mix);
      }
    }
    break;

  case N_STRING:
    {
      UChar *p;
      StrNode* sn = &(NSTRING(node));
      int change_ignore_case = 0;

      if (sn->end <= sn->s)
	break;

      p = sn->end;
      if (econt->len > 0) {
	if (!econt->ignore_case && IS_IGNORECASE(obuf->options)) {
	  for (p = sn->s; p < sn->end; ) {
	    len = mblen(obuf->code, *p);
	    if (len == 1 && IS_AMBIGUITY_CHAR(obuf->transtable, *p)) {
	      change_ignore_case = 1;
	      break;
	    }
	    p += len;
	  }
	}
	else if (econt->ignore_case && !IS_IGNORECASE(obuf->options)) {
	  for (p = sn->s; p < sn->end; ) {
	    len = mblen(obuf->code, *p);
	    if (len == 1 && IS_AMBIGUITY_CHAR(obuf->transtable, *p)) {
	      change_ignore_case = 1;
	      break;
	    }
	    p += len;
	  }
	}
      }

      if (change_ignore_case) {
	if (p > sn->s)
	  ExactBufAddStr(econt, sn->s, p, obuf->code);
	econt->mode = SO_END;
	ExactBufRevise(best, econt, obuf);
	if (p < sn->end) {
	  ExactBufAddStr(econt, p, sn->end, obuf->code);
	  econt->ignore_case = IS_IGNORECASE(obuf->options);
	}
      }
      else {
	if (sn->s < p) {
	  int prev = (econt->len > 0);
	  ExactBufAddStr(econt, sn->s, p, obuf->code);
	  if (!prev)
	    econt->ignore_case = IS_IGNORECASE(obuf->options);
	}

	if (p < sn->end)
	  econt->mode = SO_END;
      }

      len = sn->end - sn->s;
      OptBufInc(obuf, len, len);
    }
    break;

  case N_STRING_RAW:
    {
      UChar *p;
      StrNode* sn = &(NSTRING(node));
      int ambig = 0, mb = 0;

      if (sn->end <= sn->s)
	break;

      for (p = sn->s; p < sn->end; ) {
	len = mblen(obuf->code, *p);
	if (len == 1) {
	  if (IS_IGNORECASE(obuf->options) &&
	      IS_AMBIGUITY_CHAR(obuf->transtable, *p)) {
	    ambig = 1;
	    break;
	  }
	}
	else {
	  mb = 1;
	  break;
	}
	p += len;
      }

      if (mb == 0 && ambig == 0) {
	ExactBufAddStr(econt, sn->s, sn->end, obuf->code);
      }
      else
	econt->mode = SO_END;

      len = sn->end - sn->s;
      OptBufInc(obuf, len, len);
    }
    break;

  case N_CCLASS:
    {
      int ignore_case;
      UChar tmp[1];
      CClassNode* cc = &(NCCLASS(node));

      if (IS_NULL(cc->mbuf) && cc->not == 0 &&
	  (n = BitSetOnNum(cc->bs)) == 1) {
	for (i = 0; i < SINGLE_BYTE_SIZE; i++) {
	  if (BITSET_AT(cc->bs, i)) {
	    ignore_case = IS_IGNORECASE(obuf->options) &&
	                  !ismb(obuf->code, i) &&
	                  IS_AMBIGUITY_CHAR(obuf->transtable, i);
	    if ((ignore_case && econt->ignore_case) ||
		(!ignore_case && !econt->ignore_case)) {
	      tmp[0] = (UChar )i;
	      ExactBufAddStr(econt, tmp, tmp + 1, obuf->code);
	    }
	    else {
	      econt->mode = SO_END;
	    }
	    break;
	  }
	}
      }
      else {
	econt->mode = SO_END;
      }

      if (IS_NULL(cc->mbuf))
	len = 1;
      else
	len = mbmaxlen_dist(obuf->code);

      OptBufInc(obuf, 1, len);
    }
    break;

  case N_CTYPE:
    switch (NCTYPE(node).type) {
    case CTYPE_WORD:
    case CTYPE_NOT_WORD:
      goto anychar;
      break;

    case CTYPE_WORD_BOUND:
    case CTYPE_NOT_WORD_BOUND:
#ifdef VALID_WORD_BEGIN_END
    case CTYPE_WORD_BEGIN:
    case CTYPE_WORD_END:
#endif
      /* Nothing. */
      break;
    }
    break;

  case N_ANYCHAR:
  anychar:
    econt->mode = SO_END;
    len = mbmaxlen_dist(obuf->code);
    OptBufInc(obuf, 1, len);
    break;

  case N_ANCHOR:
    econt->end_anchor |= NANCHOR(node).type;
    econt->mode = SO_END;

    switch (NANCHOR(node).type) {
    case ANCHOR_BEGIN_BUF:
      reg->anchor |= ANCHOR_BEGIN_BUF;
      OptBufReset(obuf, 0, 0);
      break;

    case ANCHOR_BEGIN_POSITION:
      reg->anchor |= ANCHOR_BEGIN_POSITION;
      OptBufReset(obuf, 0, 0);
      break;

    case ANCHOR_BEGIN_LINE:
      OptBufReset(obuf, 0, INFINITE_DISTANCE);
      break;

    case ANCHOR_END_BUF:
      if (obuf->dmax != INFINITE_DISTANCE) {
	reg->anchor |= ANCHOR_END_BUF;
	reg->anchor_dmin = obuf->dmin;
	reg->anchor_dmax = obuf->dmax;
      }
      break;

    case ANCHOR_SEMI_END_BUF:
      if (obuf->dmax != INFINITE_DISTANCE &&
	  ((reg->anchor & ANCHOR_END_BUF) == 0)) {
	reg->anchor |= ANCHOR_SEMI_END_BUF;
	reg->anchor_dmin = obuf->dmin;
	reg->anchor_dmax = obuf->dmax;
      }
      break;

    case ANCHOR_END_LINE:
      break;
    }

    obuf->anchor |= NANCHOR(node).type;
    break;

  case N_BACKREF:
    econt->mode = SO_END;
    OptBufInc(obuf, 0, INFINITE_DISTANCE);
    break;

  case N_QUALIFIER:
    {
      ExactBuf tcont, tbest;
      OptBuf tobuf;
      QualifierNode* qn = &(NQUALIFIER(node));

      if (qn->lower == 0 && IS_REPEAT_INFINITE(qn->upper)) {
	if (obuf->dmax == 0 && NTYPE(qn->target) == N_ANYCHAR && qn->greedy) {
	  if (IS_POSIXLINE(reg->options))
	    reg->anchor |= ANCHOR_ANYCHAR_STAR_PL;
	  else
	    reg->anchor |= ANCHOR_ANYCHAR_STAR;
	}

	econt->mode = SO_END;
	obuf->dmax  = INFINITE_DISTANCE;
      }
      else {
	OptBufCopy(&tobuf, obuf);      
	r = SetExactInfo(reg, qn->target, &tobuf, &tcont, &tbest);
	if (r) break;

	if (EXACT_BUF_VALID(&tcont) && tcont.pos_id == obuf->pos_id) {
	  n = qn->lower;
	  if (n > 1 && tcont.mode == SO_END)
	    n = 1;

	  if (EXACT_BUF_VALID(econt)) {
	    if (econt->ignore_case != tcont.ignore_case) {
	      econt->mode = SO_END;
	      ExactBufRevise(best, econt, obuf);
	    }
	  }
	  else
	    econt->ignore_case = tcont.ignore_case;

	  for (i = 0; i < n; i++) {
	    ExactBufAdd(econt, &tcont, obuf->code);
	    if (EXACT_BUF_FULL(econt)) {
	      econt->mode = SO_END;
	      break;
	    }
	  }

	  if (tcont.mode == SO_END || qn->lower != qn->upper)
	    econt->mode = SO_END;
	}
	else {
	  if (EXACT_BUF_VALID(&tbest) && tbest.pos_id == obuf->pos_id) {
	    n = qn->lower;
	    if (n > 1 && tbest.mode == SO_END)
	      n = 1;

	    if (EXACT_BUF_VALID(econt)) {
	      if (econt->ignore_case != tbest.ignore_case) {
		econt->mode = SO_END;
		ExactBufRevise(best, econt, obuf);
	      }
	    }
	    else
	      econt->ignore_case = tbest.ignore_case;

	    for (i = 0; i < n; i++) {
	      ExactBufAdd(econt, &tbest, obuf->code);
	      if (EXACT_BUF_FULL(econt))
		break;
	    }
	  }
	  econt->mode = SO_END;
	}

	if (tobuf.dmax == INFINITE_DISTANCE) {
	  obuf->dmax = INFINITE_DISTANCE;
	}
	else {
	  if (IS_REPEAT_INFINITE(qn->upper))
	    obuf->dmax = INFINITE_DISTANCE;
	  else {
	    n = tobuf.dmax - obuf->dmax;
	    DISTANCE_INC(obuf->dmax, n * qn->upper);
	  }
	}

	if (tobuf.dmin == INFINITE_DISTANCE) {
	  obuf->dmin = INFINITE_DISTANCE;
	}
	else {
	  n = tobuf.dmin - obuf->dmin;
	  DISTANCE_INC(obuf->dmin, n * qn->lower);
	}
      }

      if (qn->upper > 0 || IS_REPEAT_INFINITE(qn->upper)) {
	OptBufInc(obuf, 0, 0);
      }
    }
    break;

  case N_OPTION:
    {
      RegOptionType option = obuf->options;

      obuf->options = NOPTION(node).option;
      r = setExactInfoNode(reg, obuf, econt, best, NOPTION(node).target);
      obuf->options = option;
    }
    break;

  case N_EFFECT:
    {
      EffectNode* en = &(NEFFECT(node));

      switch (en->type) {
      case EFFECT_MEMORY:
	{
	  int save_anchor = reg->anchor;
	  r = setExactInfoNode(reg, obuf, econt, best, en->target);
	  if ((reg->anchor & ANCHOR_ANYCHAR_STAR_MASK) != 0 &&
	      (save_anchor & ANCHOR_ANYCHAR_STAR_MASK) == 0) {
	    if (GET_MEM_STATS_AT(reg->mem_stats, en->regnum))
	      reg->anchor &= ~ANCHOR_ANYCHAR_STAR_MASK;
	  }
	}
	break;

      case EFFECT_STOP_BACKTRACK:
	r = setExactInfoNode(reg, obuf, econt, best, en->target);
	break;

      case EFFECT_PREC_READ:
	if (NTYPE(en->target) == N_STRING) {
	  OptBuf save;

	  OptBufCopy(&save, obuf);
	  r = setExactInfoNode(reg, &save, econt, best, en->target);
	  econt->mode = SO_END;
	}
	break;

      case EFFECT_PREC_READ_NOT:
	/* Nothing. */
	break;
      }
    }
    break;

  default:
    r = REGERR_TYPE_BUG;
    break;
  }

  if (r == 0)
    ExactBufRevise(best, econt, obuf);
  return r;
}

static int SetExactInfo(regex_t* reg, Node* node, OptBuf* obuf,
			ExactBuf* econt, ExactBuf* best)
{
  int r;

  ExactBufInit(best,  obuf);
  ExactBufInit(econt, obuf);
  r = setExactInfoNode(reg, obuf, econt, best, node);
  if (r == 0 && econt->mode == SO_END) {
    ExactBufUpdateBetter(best, econt);
  }
  return r;
}

#ifdef REG_DEBUG
static void PrintMapBuf(FILE* f, MapBuf* buf)
{
  fprintf(f, "map: ");

  if (MAP_BUF_VALID(buf)) {
    PrintDistanceRange(f, buf->dmin, buf->dmax);
    fprintf(f, ":%d:%d ", buf->n, buf->value);
    PrintAnchor(f, buf->start_anchor);
    fprintf(f, ", ");
    PrintAnchor(f, buf->end_anchor);
  }
  else {
    fprintf(f, "invalid");
  }
  fprintf(f, "\n\n");
}
#endif

static void MapBufInit(MapBuf* buf, OptBuf* obuf)
{
  int i;

  buf->dmin   = obuf->dmin;
  buf->dmax   = obuf->dmax;
  buf->pos_id = obuf->pos_id;
  buf->n      = 0;
  buf->value  = 0;
  buf->start_anchor = obuf->anchor;
  buf->end_anchor   = 0;

  for (i = 0; i < REG_CHAR_TABLE_SIZE; i++)
    buf->map[i] = (UChar )0;
}

static void MapBufCopy(MapBuf* buf, MapBuf* from)
{
  buf->dmin   = from->dmin;
  buf->dmax   = from->dmax;
  buf->pos_id = from->pos_id;
  buf->n      = from->n;
  buf->value  = from->value;
  buf->start_anchor = from->start_anchor;
  buf->end_anchor   = from->end_anchor;

  xmemcpy(buf->map, from->map, sizeof(UChar) * REG_CHAR_TABLE_SIZE);
}

static void mapBufAdd(MapBuf* buf, UChar c)
{
  switch(c) {
  case ' ':  buf->value += 8; break;
  case '\t': buf->value += 4; break;
  case '\n': buf->value += 7; break;
  default:   buf->value += 1; break;
  }

  buf->map[c] = 1;
  buf->n++;
}

static void MapBufAdd(MapBuf* buf, UChar c)
{
  if (buf->map[c] == 0) {
    mapBufAdd(buf, c);
  }
}

static void MapBufReverse(MapBuf* buf)
{
  int i;

  buf->value = buf->n = 0;
  for (i = 0; i < REG_CHAR_TABLE_SIZE; i++) {
    if (buf->map[i])
      buf->map[i] = 0;
    else
      mapBufAdd(buf, i);
  }
}

static void MapBufClear(MapBuf* buf)
{
  buf->n            = 0;
  buf->value        = 0;
  buf->start_anchor = 0;
  buf->end_anchor   = 0;
}

static void MapBufUnion(MapBuf* to, MapBuf* from)
{
  int i;

  if (! MAP_BUF_VALID(to)) return ;
  if (! MAP_BUF_VALID(from)) {
    MapBufClear(to);
    return ;
  }

  if (to->pos_id != from->pos_id) {
    MapBufClear(to);
    return ;
  }

  for (i = 0; i < REG_CHAR_TABLE_SIZE; i++) {
    if (from->map[i]) {
      if (to->map[i] == 0)
	mapBufAdd(to, i);
    }
  }

  to->start_anchor &= from->start_anchor;
  to->end_anchor   &= from->end_anchor;
}

#define MAP_UPDATE_DMAX0_VALUE_THRESHOLD   16
#define MAP_VALUE_BASE                      4

static void MapBufUpdateBetter(MapBuf* to, MapBuf* from)
{
  if (! MAP_BUF_VALID(from)) return ;

  if (! MAP_BUF_VALID(to)) {
    goto update;
  }
  if (to->dmax == INFINITE_DISTANCE) {
    if (from->dmax < INFINITE_DISTANCE || to->value > from->value)
      goto update;
  }
  else if (from->dmax < INFINITE_DISTANCE) {
    RegDistance df, dt;

    df = from->dmax - from->dmin;
    dt = to->dmax   - to->dmin;

    if (dt == 0) {
      if (to->dmax == 0 && to->value < MAP_UPDATE_DMAX0_VALUE_THRESHOLD)
	return ;

      if (df == 0) {
	if (to->value > from->value) goto update;
	if ((to->start_anchor == 0) && (from->start_anchor != 0)) goto update;
	return ;
      }
    }
    else if (df == 0) {
      goto update;
    }

    if (((double )(from->value + MAP_VALUE_BASE) * (double )(df + from->dmax))
      < ((double )(to->value   + MAP_VALUE_BASE) * (double )(dt + to->dmax)))
      goto update;

    if ((to->start_anchor == 0) && (from->start_anchor != 0) &&
	(df <= dt * 2)) goto update;
  }

  return ;

 update:
  MapBufCopy(to, from);
}

static int SetMapInfo(Node* node, OptBuf* obuf,	MapBuf* best);

static int setMapInfoNode(OptBuf* obuf, MapBuf* best, Node* node)
{
  MapBuf curr;
  RegDistance len;
  int i, n, type;
  int r = 0;

  type = NTYPE(node);
  switch (type) {
  case N_EMPTY:
    return 0;
    break;

  case N_LIST:
    do {
      r = setMapInfoNode(obuf, best, NCONS(node).left);
    } while (r == 0 && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_ALT:
    {
      OptBuf zobuf, save;
      MapBuf zbuf;
      Node* x = node;

      OptBufCopy(&save, obuf);
      MapBufInit(&curr, obuf);
      do {
	OptBufCopy(&zobuf, &save);
	if (x == node) {
	  r = setMapInfoNode(&zobuf, &curr, NCONS(x).left);
	}
	else {
	  MapBufInit(&zbuf, &save);
	  r = setMapInfoNode(&zobuf, &zbuf, NCONS(x).left);
	  if (r == 0) {
	    MapBufUnion(&curr, &zbuf);
	  }
	}
	OptBufMergeAlt(obuf, &zobuf);
      } while ((r == 0) && IS_NOT_NULL(x = NCONS(x).right));

      if (r == 0)
	MapBufUpdateBetter(best, &curr);
    }
    break;

  case N_STRING:
    {
      UChar c;
      StrNode* sn = &(NSTRING(node));

      if (sn->end <= sn->s)
	break;

      MapBufInit(&curr, obuf);
      c = *(sn->s);
      if (IS_IGNORECASE(obuf->options) && !ismb(obuf->code, c) &&
	  IS_AMBIGUITY_CHAR(obuf->transtable, c)) {
	  for (i = 0; i < REG_CHAR_TABLE_SIZE; i++) {
	    if (TTRANS(obuf->transtable, i) == c)
	      MapBufAdd(&curr, (UChar )i);
	  }
      }
      else {
	MapBufAdd(&curr, c);
      }

      MapBufUpdateBetter(best, &curr);
      len = sn->end - sn->s;
      OptBufInc(obuf, len, len);
    }
    break;

  case N_STRING_RAW:
    {
      UChar c;
      StrNode* sn = &(NSTRING(node));

      if (sn->end <= sn->s)
	break;

      MapBufInit(&curr, obuf);
      c = *(sn->s);
      MapBufAdd(&curr, c);
      MapBufUpdateBetter(best, &curr);
      len = sn->end - sn->s;
      OptBufInc(obuf, len, len);
    }
    break;

  case N_CCLASS:
    {
      CClassNode* cc = &(NCCLASS(node));

      MapBufInit(&curr, obuf);
      for (i = 0; i < SINGLE_BYTE_SIZE; i++) {
	if (BITSET_AT(cc->bs, i)) {
	  MapBufAdd(&curr, (UChar )i);
	  if (IS_IGNORECASE(obuf->options)) {
	    MapBufAdd(&curr, (UChar )TTRANS(obuf->transtable, i));
	  }
	}
      }

      if (IS_NOT_NULL(cc->mbuf)) {
	for (i = 0; i < SINGLE_BYTE_SIZE; i++) {
	  if (BITSET_AT((BitSetRef )(cc->mbuf->p), i)) {
	    MapBufAdd(&curr, (UChar )i);
	  }
	}
      }

      if (cc->not) MapBufReverse(&curr);
      MapBufUpdateBetter(best, &curr);

      if (IS_NULL(cc->mbuf))
	len = 1;
      else
	len = mbmaxlen_dist(obuf->code);

      OptBufInc(obuf, 1, len);
    }
    break;

  case N_CTYPE:
    switch (NCTYPE(node).type) {
    case CTYPE_WORD:
    case CTYPE_NOT_WORD:
      {
	UChar c;

	MapBufInit(&curr, obuf);
	for (i = 0; i < SINGLE_BYTE_SIZE; i++) {
	  c = (UChar )i;
	  if (IS_WORD_HEAD(obuf->code, c))
	    MapBufAdd(&curr, c);
	}

	if (NCTYPE(node).type == CTYPE_NOT_WORD)
	  MapBufReverse(&curr);

	MapBufUpdateBetter(best, &curr);
      }
      goto anychar;
      break;

    case CTYPE_WORD_BOUND:
    case CTYPE_NOT_WORD_BOUND:
#ifdef VALID_WORD_BEGIN_END
    case CTYPE_WORD_BEGIN:
    case CTYPE_WORD_END:
#endif
      /* Nothing. */
      break;
    }
    break;

  case N_ANYCHAR:
  anychar:
    len = mbmaxlen_dist(obuf->code);
    OptBufInc(obuf, 1, len);
    break;

  case N_ANCHOR:
    if (best->pos_id == obuf->pos_id - 1)
      best->end_anchor |= NANCHOR(node).type;

    switch (NANCHOR(node).type) {
    case ANCHOR_BEGIN_BUF:
      OptBufReset(obuf, 0, 0);
      break;
    case ANCHOR_BEGIN_POSITION:
      OptBufReset(obuf, 0, 0);
      break;
    case ANCHOR_BEGIN_LINE:
      OptBufReset(obuf, 0, INFINITE_DISTANCE);
      break;

    case ANCHOR_END_LINE:
    case ANCHOR_END_BUF:
    case ANCHOR_SEMI_END_BUF:
      break;
    }

    obuf->anchor |= NANCHOR(node).type;
    break;

  case N_BACKREF:
    OptBufInc(obuf, 0, INFINITE_DISTANCE);
    break;

  case N_QUALIFIER:
    {
      OptBuf tobuf;
      QualifierNode* qn = &(NQUALIFIER(node));

      if (IS_REPEAT_INFINITE(qn->upper) || qn->upper > 0) {
	OptBufCopy(&tobuf, obuf);
	if (qn->lower > 0) {
	  r = SetMapInfo(qn->target, &tobuf, best);
	}
	else {
	  MapBuf tbest;
	  /* qn->lower == 0: tbest is not used. */
	  r = SetMapInfo(qn->target, &tobuf, &tbest);
	}
	if (r) break;

	if (tobuf.dmax == INFINITE_DISTANCE) {
	  obuf->dmax = INFINITE_DISTANCE;
	}
	else {
	  if (IS_REPEAT_INFINITE(qn->upper))
	    obuf->dmax = INFINITE_DISTANCE;
	  else {
	    n = tobuf.dmax - obuf->dmax;
	    DISTANCE_INC(obuf->dmax, n * qn->upper);
	  }
	}

	if (tobuf.dmin == INFINITE_DISTANCE) {
	  obuf->dmin = INFINITE_DISTANCE;
	}
	else {
	  n = tobuf.dmin - obuf->dmin;
	  DISTANCE_INC(obuf->dmin, n * qn->lower);
	}

	OptBufInc(obuf, 0, 0);
      }
    }
    break;

  case N_OPTION:
    {
      RegOptionType option = obuf->options;

      obuf->options = NOPTION(node).option;
      r = setMapInfoNode(obuf, best, NOPTION(node).target);
      obuf->options = option;
    }
    break;

  case N_EFFECT:
    {
      EffectNode* en = &(NEFFECT(node));

      switch (en->type) {
      case EFFECT_MEMORY:
      case EFFECT_STOP_BACKTRACK:
	r = setMapInfoNode(obuf, best, en->target);
	break;

      case EFFECT_PREC_READ:
	if (NTYPE(en->target) == N_STRING ||
	    NTYPE(en->target) == N_STRING_RAW) {
	  OptBuf save;

	  OptBufCopy(&save, obuf);
	  r = setMapInfoNode(&save, best, en->target);
	}
	break;

      case EFFECT_PREC_READ_NOT:
	/* Nothing. */
	break;
      }
    }
    break;

  default:
    r = REGERR_TYPE_BUG;
    break;
  }

  return r;
}

static int SetMapInfo(Node* node, OptBuf* obuf, MapBuf* best)
{
  MapBufInit(best, obuf);
  return setMapInfoNode(obuf, best, node);
}

#ifdef REG_DEBUG
static void PrintOptimizeInfo(FILE* f, regex_t* reg)
{
  static char* on[] = { "NONE", "EXACT", "EXACT_BM", "EXACT_IC",
			"EXACT_BM_IC(not used!)", "MAP" };

  fprintf(f, "optimize: %s\n", on[reg->optimize]);
  fprintf(f, "  anchor: "); PrintAnchor(f, reg->anchor);
  if ((reg->anchor & ANCHOR_END_BUF_MASK) != 0)
    PrintDistanceRange(f, reg->anchor_dmin, reg->anchor_dmax);
  fprintf(f, "\n");

  if (reg->optimize) {
    fprintf(f, "  sub anchor: "); PrintAnchor(f, reg->sub_anchor);
    fprintf(f, "\n");
  }
  fprintf(f, "\n");
}
#endif

static void SetOptimizeMap(regex_t* reg, MapBuf* m)
{
  int i;

  for (i = 0; i < REG_CHAR_TABLE_SIZE; i++)
    reg->map[i] = m->map[i];

  reg->optimize   = REG_OPTIMIZE_MAP;
  reg->sub_anchor = m->start_anchor;
  reg->dmin       = m->dmin;
  reg->dmax       = m->dmax;

  if (reg->dmax != INFINITE_DISTANCE) {
    reg->threshold_len = reg->dmax + 1;
    if (reg->threshold_len < APPLY_POSITION_SEARCH_THRESHOLD_LENGTH)
      reg->threshold_len = APPLY_POSITION_SEARCH_THRESHOLD_LENGTH;
  }
}

static int SetBMSkip(UChar* s, UChar* end, UChar* transtable,
		     UChar skip[], int** int_skip);

static int SetOptimizeExact(regex_t* reg, ExactBuf* e)
{
  int r;

  if (EXACT_BUF_VALID(e)) {
    reg->exact = Strdup(e->buf, e->buf + e->len);
    if (IS_NULL(reg->exact)) return REGERR_MEMORY;
 
    reg->exact_end = reg->exact + e->len;
    if (e->ignore_case) {
      UChar *p;
      int len;
      for (p = reg->exact; p < reg->exact_end; ) {
	len = mblen(reg->code, *p);
	if (len == 1) *p = TTRANS(reg->transtable, *p);
	p += len;
      }
    }

    if (!e->ignore_case &&
	(e->len >= 3 || (e->len >= 2 && IS_INDEPENDENT_TRAIL(reg->code)))) {
      r = SetBMSkip(reg->exact, reg->exact_end,
		    (e->ignore_case ? reg->transtable : (UChar* )NULL),
		    reg->map, &(reg->int_map));
      if (r) return r;
      reg->optimize = REG_OPTIMIZE_EXACT_BM;
    }
    else
      reg->optimize = (e->ignore_case ?
		       REG_OPTIMIZE_EXACT_IC : REG_OPTIMIZE_EXACT);

    reg->dmin = e->dmin;
    reg->dmax = e->dmax;
    reg->sub_anchor = e->start_anchor;

    if (reg->dmax != INFINITE_DISTANCE) {
      reg->threshold_len = reg->dmax + (reg->exact_end - reg->exact);
      if (reg->threshold_len < APPLY_POSITION_SEARCH_THRESHOLD_LENGTH)
	reg->threshold_len = APPLY_POSITION_SEARCH_THRESHOLD_LENGTH;
    }
  }

  return 0;
}

static void ClearOptimizeInfo(regex_t* reg)
{
  reg->optimize      = REG_OPTIMIZE_NONE;
  reg->anchor        = 0;
  reg->sub_anchor    = 0;
  reg->exact_end     = (UChar* )NULL;
  reg->threshold_len = 0;
  if (IS_NOT_NULL(reg->exact)) {
    xfree(reg->exact);
    reg->exact = (UChar* )NULL;
  }
}

#define EXACT_LEN_FOR_MAP_EVAL_THRESHOLD    2
#define EXACT_DMAX_FOR_MAP_EVAL_THRESHOLD   4
#define MAP_VALUE_THRESHOLD                 4
#define MAP_VALUE_THRESHOLD2                9

static int SetOptimizeInfoFromTree(Node* node, regex_t* reg)
{
  int r;
  OptBuf   obuf;
  ExactBuf ebest, econt;

  OptBufInit(&obuf, reg, node);
  r = SetExactInfo(reg, node, &obuf, &econt, &ebest);
  if (r) return r;
  if (econt.mode != SO_END) {
    econt.mode = SO_END;
    ExactBufUpdateBetter(&ebest, &econt);
  }

#ifdef REG_DEBUG_COMPILE
  fprintf(stderr, "best "); PrintExactBuf(stderr, &ebest);
#endif

  if (!EXACT_BUF_VALID(&ebest) ||
      (ebest.len < EXACT_LEN_FOR_MAP_EVAL_THRESHOLD && ebest.dmax != 0) ||
      ebest.dmax >= EXACT_DMAX_FOR_MAP_EVAL_THRESHOLD) {
    MapBuf mbest;

    OptBufInit(&obuf, reg, node);
    r = SetMapInfo(node, &obuf, &mbest);
    if (r) return r;

#ifdef REG_DEBUG_COMPILE
    fprintf(stderr, "best "); PrintMapBuf(stderr, &mbest);
#endif

    if (MAP_BUF_VALID(&mbest)) {
      if (!EXACT_BUF_VALID(&ebest) ||
	  (mbest.value < MAP_VALUE_THRESHOLD &&
	   DistanceMultiply(mbest.dmax, 2) < ebest.dmax) ||
	  (mbest.value < MAP_VALUE_THRESHOLD2 &&
	   DistanceMultiply(mbest.dmax, 3) < ebest.dmax)) {
	SetOptimizeMap(reg, &mbest);
      }
    }
  }

  if (reg->optimize == 0 && EXACT_BUF_VALID(&ebest)) {
    r = SetOptimizeExact(reg, &ebest);
    if (r) return r;
  }

  /* only begin-line, end-line used. */
  reg->sub_anchor &= (ANCHOR_BEGIN_LINE | ANCHOR_END_LINE);

#if defined(REG_DEBUG_COMPILE) || defined(REG_DEBUG_MATCH)
  PrintOptimizeInfo(stderr, reg);
#endif

  return r;
}


extern void RegexRegionClear(RegRegion* region)
{
  int i;

  for (i = 0; i < region->num_regs; i++) {
    region->beg[i] = region->end[i] = -1;
  }
}

extern int RegexRegionResize(RegRegion* region, int n)
{
  int i;

  region->num_regs = n;

  if (n < REG_NREGION)
    n = REG_NREGION;

  if (region->allocated == 0) {
    region->beg = (int* )xmalloc(n * sizeof(int));
    region->end = (int* )xmalloc(n * sizeof(int));

    if (region->beg == 0 || region->end == 0)
      return REGERR_MEMORY;

    region->allocated = n;
  }
  else if (region->allocated < n) {
    region->beg = (int* )xrealloc(region->beg, n * sizeof(int));
    region->end = (int* )xrealloc(region->end, n * sizeof(int));

    if (region->beg == 0 || region->end == 0)
      return REGERR_MEMORY;

    region->allocated = n;
  }

  for (i = 0; i < region->num_regs; i++) {
    region->beg[i] = region->end[i] = -1;
  }
  return 0;
}

extern void RegexRegionInit(RegRegion* region)
{
  region->num_regs  = 0;
  region->allocated = 0;
  region->beg       = (int* )0;
  region->end       = (int* )0;
}

extern RegRegion* RegexRegionNew()
{
  RegRegion* r;

  r = (RegRegion* )xmalloc(sizeof(RegRegion));
  RegexRegionInit(r);
  return r;
}

extern void RegexRegionFree(RegRegion* r, int free_self)
{
  if (r) {
    if (r->allocated > 0) {
      if (r->beg) xfree(r->beg);
      if (r->end) xfree(r->end);
      r->allocated = 0;
    }
    if (free_self) xfree(r);
  }
}

extern void re_free_registers(RegRegion* r)
{
  /* 0: don't free self */
  RegexRegionFree(r, 0);
}

extern void RegexRegionCopy(RegRegion* r1, RegRegion* r2)
{
#define RREGC_SIZE   (sizeof(int) * r2->num_regs)
  int i;

  if (r1 == r2) return;

  if (r1->allocated == 0) {
    r1->beg = (int* )xmalloc(RREGC_SIZE);
    r1->end = (int* )xmalloc(RREGC_SIZE);
    r1->allocated = r2->num_regs;
  }
  else if (r1->allocated < r2->num_regs) {
    r1->beg = (int* )xrealloc(r1->beg, RREGC_SIZE);
    r1->end = (int* )xrealloc(r1->end, RREGC_SIZE);
    r1->allocated = r2->num_regs;
  }

  for (i = 0; i < r2->num_regs; i++) {
    r1->beg[i] = r2->beg[i];
    r1->end[i] = r2->end[i];
  }
  r1->num_regs = r2->num_regs;
}



/** stack data **/

/* stack type */
  /* used by normal-POP */
#define STK_ALT               0
#define STK_POS_NOT           1
  /* handled by normal-POP */
#define STK_MEM_START         2
#define STK_MEM_END           3
#define STK_REPEAT_INC        4
  /* avoided by normal-POP */
#define STK_POS               5   /* used when POP-POS */
#define STK_STOP_BT           6   /* mark for stop-backtrack "(?>...)" */
#define STK_REPEAT            7
#define STK_NULL_CHECK_START  8
#define STK_VOID             10   /* for fill a blank */


typedef struct {
  void* p;
  int   n;
} MatchStackAlloc;

#define MATCH_STACK_ALLOC_INIT(msa) do {\
  (msa).p = (void* )0;\
} while (0)

#define MATCH_STACK_ALLOC_FREE(msa)   if ((msa).p) xfree((msa).p)


#define STACK_INIT(alloc_addr, ptr_num, stack_num)  do {\
  if (msa->p) {\
    alloc_addr = (char* )xalloca(sizeof(char*) * (ptr_num));\
    stk_alloc  = (StackType* )(msa->p);\
    stk_base   = stk_alloc;\
    stk        = stk_base;\
    stk_end    = stk_base + msa->n;\
  }\
  else {\
    alloc_addr = (char* )xalloca(sizeof(char*) * (ptr_num)\
		       + sizeof(StackType) * (stack_num));\
    stk_alloc  = (StackType* )(alloc_addr + sizeof(char*) * (ptr_num));\
    stk_base   = stk_alloc;\
    stk        = stk_base;\
    stk_end    = stk_base + (stack_num);\
  }\
} while(0)

#define STACK_SAVE do{\
  if (stk_base != stk_alloc) {\
    msa->p = stk_base;\
    msa->n = stk_end - stk_base;\
  };\
} while(0)

#define STACK_ENSURE(n)	do {\
  if (stk_end - stk <= (n)) {\
    STACK_DOUBLE;\
  }\
} while(0)

#define STACK_DOUBLE do {\
  int n = stk_end - stk_base;\
  StackType* x;\
  if (stk_base == stk_alloc && IS_NULL(msa->p)) {\
    x = (StackType* )xmalloc(sizeof(StackType) * n * 2);\
    if (IS_NULL(x)) {\
      STACK_SAVE;\
      return REGERR_MEMORY;\
    }\
    xmemcpy(x, stk_base, n * sizeof(StackType));\
  }\
  else {\
    x = (StackType* )xrealloc(stk_base, sizeof(StackType) * n * 2);\
    if (IS_NULL(x)) {\
      STACK_SAVE;\
      return REGERR_MEMORY;\
    }\
  }\
  stk      = x + (stk - stk_base);\
  stk_base = x;\
  stk_end  = stk_base + n * 2;\
} while (0)

#define STACK_PUSH(stack_type,pat,s,sprev) do {\
  STACK_ENSURE(1);\
  stk->type = (stack_type);\
  stk->u.state.pcode     = (pat);\
  stk->u.state.pstr      = (s);\
  stk->u.state.pstr_prev = (sprev);\
  stk++;\
} while(0)

#define STACK_PUSH_ALT(pat,s,sprev)     STACK_PUSH(STK_ALT,pat,s,sprev)
#define STACK_PUSH_POS(s,sprev)         STACK_PUSH(STK_POS,NULL_UCHARP,s,sprev)
#define STACK_PUSH_POS_NOT(pat,s,sprev) STACK_PUSH(STK_POS_NOT,pat,s,sprev)
#define STACK_PUSH_STOP_BT  \
        STACK_PUSH(STK_STOP_BT,NULL_UCHARP,NULL_UCHARP,NULL_UCHARP)

#define STACK_PUSH_REPEAT(pat,low,up) do {\
  STACK_ENSURE(1);\
  stk->type = STK_REPEAT;\
  stk->u.repeat.pcode  = (pat);\
  stk->u.repeat.lower  = (low);\
  stk->u.repeat.upper  = (up);\
  stk->u.repeat.count  = 0;\
  stk++;\
} while(0)

#define STACK_PUSH_REPEAT_INC(sp) do {\
  STACK_ENSURE(1);\
  stk->type = STK_REPEAT_INC;\
  stk->u.repeat_inc.sp  = (sp);\
  stk++;\
} while(0)

#define STACK_PUSH_MEM_START(mnum, s) do {\
  STACK_ENSURE(1);\
  stk->type = STK_MEM_START;\
  stk->u.mem.num      = (mnum);\
  stk->u.mem.pstr     = (s);\
  stk->u.mem.start    = mem_start_stk[mnum];\
  stk->u.mem.end      = mem_end_stk[mnum];\
  mem_start_stk[mnum] = stk;\
  mem_end_stk[mnum]   = (StackType* )NULL;\
  stk++;\
} while(0)

#define STACK_PUSH_MEM_END(mnum, s) do {\
  STACK_ENSURE(1);\
  stk->type = STK_MEM_END;\
  stk->u.mem.num    = (mnum);\
  stk->u.mem.pstr   = (s);\
  stk->u.mem.start  = mem_start_stk[mnum];\
  mem_end_stk[mnum] = stk;\
  stk++;\
} while(0)

#define STACK_PUSH_NULL_CHECK_START(cnum, s) do {\
  STACK_ENSURE(1);\
  stk->type = STK_NULL_CHECK_START;\
  stk->u.null_check.num  = (cnum);\
  stk->u.null_check.pstr = (s);\
  stk++;\
} while(0)

#define STACK_POP  do {\
  while (1) {\
    stk--;\
    if (stk < stk_base)  goto finish;\
    if (stk->type <= STK_POS_NOT)  break;\
    else if (stk->type <= STK_MEM_END) {\
      if (stk->type == STK_MEM_END) {\
        mem_end_stk[stk->u.mem.num] = (StackType* )NULL;\
      }\
      else {\
        mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
        mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
        \
      }\
    }\
    else if (stk->type == STK_REPEAT_INC) {\
      (stk->u.repeat_inc.sp)->u.repeat.count--;\
    }\
  }\
} while(0)

#define STACK_POP_TIL_POS_NOT  do {\
  while (1) {\
    stk--;\
    if (stk < stk_base)  goto stack_error;\
    if (stk->type == STK_ALT) continue;\
    if (stk->type == STK_POS_NOT) break;\
    else if (stk->type <= STK_MEM_END) {\
      if (stk->type == STK_MEM_END) {\
        mem_end_stk[stk->u.mem.num] = (StackType* )NULL;\
      }\
      else {\
        mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
        mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
        \
      }\
    }\
    else if (stk->type == STK_REPEAT_INC) {\
      (stk->u.repeat_inc.sp)->u.repeat.count--;\
    }\
  }\
} while(0)

#define STACK_POS_END(k) do {\
  k = stk;\
  while (1) {\
    k--;\
    if (k < stk_base)  goto stack_error;\
    if (k->type <= STK_POS_NOT || k->type == STK_NULL_CHECK_START) {\
      k->type = STK_VOID;\
    }\
    else if (k->type == STK_POS) {\
      k->type = STK_VOID;\
      break;\
    }\
  }\
} while(0)

#define STACK_STOP_BT_END do {\
  StackType *k = stk;\
  while (1) {\
    k--;\
    if (k < stk_base)  goto stack_error;\
    if (k->type <= STK_POS_NOT || k->type == STK_NULL_CHECK_START) {\
      k->type = STK_VOID;\
    }\
    else if (k->type == STK_STOP_BT) {\
      k->type = STK_VOID;\
      break;\
    }\
  }\
} while(0)

#define STACK_NULL_CHECK(isnull,id,s) do {\
  StackType* k = stk;\
  k--;\
  while (k >= stk_base) {\
    if (k->type == STK_NULL_CHECK_START) {\
      (isnull) = (k->u.null_check.num == (id) && k->u.null_check.pstr == (s));\
      break;\
    }\
    k--;\
  }\
} while(0)


#define SBTRANSCMP(a,b)    (TTRANS(transtable,a) == TTRANS(transtable,b))
#define SBTRANS1CMP(a,c)   (TTRANS(transtable,a) == (c))
#define SBCMP(a,b)         (ignore_case ? SBTRANSCMP(a,b)  : (a) == (b))

#define STRING_CMP(a,b,len) do {\
  if (ignore_case) {\
    while (len-- > 0) {\
      if (! SBTRANSCMP(*a, *b)) goto fail;\
	a++; b++;\
    }\
  }\
  else {\
    while (len-- > 0) {\
      if (*a++ != *b++) goto fail;\
    }\
  }\
} while(0)

#define ON_STR_BEGIN(s)  ((s) == str)
#define ON_STR_END(s)    ((s) == end)
#define IS_EMPTY_STR     (str == end)

#define DATA_ENSURE(n) \
  if (s + (n) > end) goto fail

#define DATA_ENSURE_CHECK(n)   (s + (n) <= end)


static void printCompiledByteCode(FILE* f, UChar* bp, UChar** nextp);
static void printCompiledByteCodeList(FILE* f, regex_t* reg);


#ifdef REG_DEBUG_STATISTICS
static void PrintStatistics();
static int OpCounter[256];

#define STATISTICS_INIT do {\
  int i;\
  for (i = 0; i < 256; i++) OpCounter[i] = 0;\
} while(0)

#define STAT_OP_IN(opcode)   OpCounter[opcode]++;
#define STATISTICS_PRINT_RESULT  PrintStatistics()

#ifdef RUBY_PLATFORM
static VALUE regex_stat_print()
{
  PrintStatistics();
}

void Init_REGEX()
{
  rb_define_global_function("regex_stat_print", regex_stat_print, 0);
}
#endif

#else
#define STATISTICS_INIT
#define STAT_OP_IN(opcode)
#define STATISTICS_PRINT_RESULT
#endif

/* match data(str - end) from position (sstart). */
/* if sstart == str then set sprev to NULL. */
static int regexMatch(regex_t* reg, UChar* str, UChar* end, UChar* sstart,
		      UChar* sprev, RegRegion* region, MatchStackAlloc* msa)
{
  int i, n, max_mem, best_len;
  LengthType tlen, tlen2;
  MemNumType mem;
  RelAddrType addr;
  RegOptionType option = reg->options;
  RegCharCodeType encode = reg->code;
  unsigned char* transtable = reg->transtable;
  int ignore_case;
  UChar *s, *q, *sbegin;
  UChar *p = reg->p;
  StackType **mem_start_stk, **mem_end_stk, **repeat_stk;
  StackType *stk_alloc, *stk_base, *stk, *stk_end;
  char *alloca_base;

  ignore_case = IS_IGNORECASE(option);
  max_mem    = reg->max_mem;

  n = reg->num_repeat + max_mem * 2;
  STACK_INIT(alloca_base, n, INIT_MATCH_STACK_SIZE);
  /* fprintf(stderr, "msa: %d, %d\n", msa->p, msa->n); */

  repeat_stk = (StackType** )alloca_base;
  mem_start_stk = repeat_stk + reg->num_repeat;
  mem_end_stk   = mem_start_stk + max_mem;
  mem_start_stk--; /* for set start-index to 1,
		      mem_start_stk[1]..mem_start_stk[max_mem] */
  mem_end_stk--;   /* for set start-index to 1,
		      mem_end_stk[1]..mem_end_stk[max_mem] */
  for (i = 1; i <= max_mem; i++) {
    mem_start_stk[i] = mem_end_stk[i] = (StackType* )NULL;
  }

#ifdef REG_DEBUG_MATCH
  fprintf(stderr, "regexMatch: str: %d, end: %d, start: %d, sprev: %d\n",
	  (int )str, (int )end, (int )sstart, (int )sprev);
  fprintf(stderr, "size: %d, start offset: %d\n",
	  (int )(end - str), (int )(sstart - str));
#endif

  best_len = REG_MISMATCH;
  s = sstart;
  while (1) {
#ifdef REG_DEBUG_MATCH
    {
      UChar *q, *bp, buf[50];
      int len;
      fprintf(stderr, "%4d> \"", (int )(s - str));
      bp = buf;
      for (i = 0, q = s; i < 7 && q < end; i++) {
	len = mblen(encode, *q);
	while (len-- > 0) *bp++ = *q++;
      }
      if (q < end) { xmemcpy(bp, "...\"", 4); bp += 4; }
      else         { xmemcpy(bp, "\"",    1); bp += 1; }
      *bp = 0;
      fputs(buf, stderr);
      for (i = 0; i < 20 - (bp - buf); i++) fputc(' ', stderr);
      printCompiledByteCode(stderr, p, NULL);
      fprintf(stderr, "\n");
    }
#endif

    sbegin = s;
    switch (*p++) {
    case OP_END:  STAT_OP_IN(OP_END);
      n = s - sstart;
      if (n > best_len) {
	best_len = n;
	if (region) {
	  region->beg[0] = sstart - str;
	  region->end[0] = s      - str;
	  for (i = 1; i <= max_mem; i++) {
	    if (mem_end_stk[i]) {
	      if (GET_MEM_STATS_AT(reg->mem_stats, i)) {
		region->beg[i] = mem_start_stk[i]->u.mem.pstr - str;
		region->end[i] = mem_end_stk[i]->u.mem.pstr   - str;
	      }
	      else {
		region->beg[i] = mem_start_stk[i]->u.mem.pstr - str;
		region->end[i] = (UChar* )((void* )mem_end_stk[i])   - str;
	      }
	    }
	    else {
	      region->beg[i] = -1;
	      region->end[i] = -1;
	    }
	  }
	}
      }

      if (s < end && IS_FIND_LONGEST(option)) {
	goto fail; /* for retry */
      }
      else {
	/* default behavior: return first-matching result. */
	goto finish;
      }
      break;

    case OP_EXACT1:  STAT_OP_IN(OP_EXACT1);
      DATA_ENSURE(1);
      if (! SBCMP(*p, *s)) goto fail;
      p++; s++;
      break;

    case OP_EXACT1_RAW:  STAT_OP_IN(OP_EXACT1_RAW);
      DATA_ENSURE(1);
      if (*p != *s) goto fail;
      p++; s++;
      break;

    case OP_EXACT2:  STAT_OP_IN(OP_EXACT2);
      DATA_ENSURE(2);
      if (! SBCMP(*p, *s)) goto fail;
      p++; s++;
      if (! SBCMP(*p, *s)) goto fail;
      sprev = s;
      p++; s++;
      continue;
      break;

    case OP_EXACT3:  STAT_OP_IN(OP_EXACT3);
      DATA_ENSURE(3);
      if (ignore_case) {
	if (! SBTRANSCMP(*p, *s)) goto fail;
	p++; s++;
	if (! SBTRANSCMP(*p, *s)) goto fail;
	p++; s++;
	if (! SBTRANSCMP(*p, *s)) goto fail;
	sprev = s;
	p++; s++;
      }
      else {
	if (*p++ != *s++) goto fail;
	if (*p++ != *s++) goto fail;
	if (*p++ != *s)   goto fail;
	sprev = s;
	s++;
      }
      continue;
      break;

    case OP_EXACT4:  STAT_OP_IN(OP_EXACT4);
      DATA_ENSURE(4);
      if (ignore_case) {
	if (! SBTRANSCMP(*p, *s)) goto fail;
	p++; s++;
	if (! SBTRANSCMP(*p, *s)) goto fail;
	p++; s++;
	if (! SBTRANSCMP(*p, *s)) goto fail;
	p++; s++;
	if (! SBTRANSCMP(*p, *s)) goto fail;
	sprev = s;
	p++; s++;
      }
      else {
	if (*p++ != *s++) goto fail;
	if (*p++ != *s++) goto fail;
	if (*p++ != *s++) goto fail;
	if (*p++ != *s)   goto fail;
	sprev = s;
	s++;
      }
      continue;
      break;

    case OP_EXACT5:  STAT_OP_IN(OP_EXACT5);
      DATA_ENSURE(5);
      if (ignore_case) {
	if (! SBTRANSCMP(*p, *s)) goto fail;
	p++; s++;
	if (! SBTRANSCMP(*p, *s)) goto fail;
	p++; s++;
	if (! SBTRANSCMP(*p, *s)) goto fail;
	p++; s++;
	if (! SBTRANSCMP(*p, *s)) goto fail;
	p++; s++;
	if (! SBTRANSCMP(*p, *s)) goto fail;
	sprev = s;
	p++; s++;
      }
      else {
	if (*p++ != *s++) goto fail;
	if (*p++ != *s++) goto fail;
	if (*p++ != *s++) goto fail;
	if (*p++ != *s++) goto fail;
	if (*p++ != *s)   goto fail;
	sprev = s;
	s++;
      }
      continue;
      break;

    case OP_EXACTN:  STAT_OP_IN(OP_EXACTN);
      GET_LENGTH_INC(tlen, p);
      DATA_ENSURE(tlen);
      STRING_CMP(p, s, tlen);
      sprev = s - 1;
      continue;
      break;

    case OP_EXACTN_RAW:  STAT_OP_IN(OP_EXACTN_RAW);
      GET_LENGTH_INC(tlen, p);
      DATA_ENSURE(tlen);
      while (tlen-- > 0) {
	if (*p++ != *s++) goto fail;
      }
      sprev = s - 1;
      continue;
      break;

    case OP_EXACTMB2N1:  STAT_OP_IN(OP_EXACTMB2N1);
      DATA_ENSURE(2);
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      break;

    case OP_EXACTMB2N2:  STAT_OP_IN(OP_EXACTMB2N2);
      DATA_ENSURE(4);
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      sprev = s;
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      continue;
      break;

    case OP_EXACTMB2N3:  STAT_OP_IN(OP_EXACTMB2N3);
      DATA_ENSURE(6);
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      sprev = s;
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      continue;
      break;

    case OP_EXACTMB2N:  STAT_OP_IN(OP_EXACTMB2N);
      GET_LENGTH_INC(tlen, p);
      DATA_ENSURE(tlen * 2);
      while (tlen-- > 0) {
	if (*p++ != *s++) goto fail;
	if (*p++ != *s++) goto fail;
      }
      sprev = s - 2;
      continue;
      break;

    case OP_EXACTMB4N:  STAT_OP_IN(OP_EXACTMB4N);
      GET_LENGTH_INC(tlen, p);
      DATA_ENSURE(tlen * 4);
      while (tlen-- > 0) {
	if (*p++ != *s++) goto fail;
	if (*p++ != *s++) goto fail;
	if (*p++ != *s++) goto fail;
	if (*p++ != *s++) goto fail;
      }
      sprev = s - 4;
      continue;
      break;

    case OP_EXACTMBN:  STAT_OP_IN(OP_EXACTMBN);
      GET_LENGTH_INC(tlen, p);
      while (tlen-- > 0) {
	if (*p != *s++) goto fail;
	tlen2 = mblen(encode, *p) - 1;
	DATA_ENSURE(tlen2);
	p++;

	if (tlen == 0) sprev = s;

	while (tlen2-- > 0) {
	  if (*p++ != *s++) goto fail;
	}
      }
      continue;
      break;

    case OP_CCLASS:  STAT_OP_IN(OP_CCLASS);
      DATA_ENSURE(1);
      if (BITSET_AT(((BitSetRef )p), *s) == 0) goto fail;
      p += SIZE_BITSET;
      s += mblen(encode, *s);   /* OP_CCLASS can match mb-code. \D, \S */
      break;

    case OP_CCLASS_MB:  STAT_OP_IN(OP_CCLASS_MB);
      if (BITSET_AT((BitSetRef )p, *s) == 0) goto fail;
      p += SIZE_BITSET;

    cclass_mb:
      GET_LENGTH_INC(tlen, p);
      q = p;
      p += tlen;
      {
	WCInt wc;
	UChar *ss;
	int mb_len = mblen(encode, *s);

	DATA_ENSURE(mb_len);
	ss = s;
	s += mb_len;
	wc = MB2WC(ss, s, encode);

	if (! IsInWCRange(q, wc)) goto fail;
      }
      break;

    case OP_CCLASS_MIX:  STAT_OP_IN(OP_CCLASS_MIX);
      DATA_ENSURE(1);
      if (ismb(encode, *s)) {
	p += SIZE_BITSET;
	goto cclass_mb;
      }
      else {
	if (BITSET_AT(((BitSetRef )p), *s) == 0)
	  goto fail;

	p += SIZE_BITSET;
	GET_LENGTH_INC(tlen, p);
	p += tlen;
	s++;
      }
      break;

    case OP_CCLASS_NOT:  STAT_OP_IN(OP_CCLASS_NOT);
      DATA_ENSURE(1);
      if (BITSET_AT(((BitSetRef )p), *s) != 0) goto fail;
      p += SIZE_BITSET;
      s += mblen(encode, *s);
      break;

    case OP_CCLASS_MB_NOT:  STAT_OP_IN(OP_CCLASS_MB_NOT);
      if (BITSET_AT((BitSetRef )p, *s) == 0) goto success;
      p += SIZE_BITSET;

    cclass_mb_not:
      GET_LENGTH_INC(tlen, p);
      q = p;
      p += tlen;
      {
	WCInt wc;
	UChar *ss;
	int mb_len = mblen(encode, *s);

	if (s + mb_len > end) {
	  s = end;
	  goto success;
	}

	ss = s;
	s += mb_len;
	wc = MB2WC(ss, s, encode);

	if (IsInWCRange(q, wc)) goto fail;
      }

    success:
      break;

    case OP_CCLASS_MIX_NOT:  STAT_OP_IN(OP_CCLASS_MIX_NOT);
      DATA_ENSURE(1);
      if (ismb(encode, *s)) {
	p += SIZE_BITSET;
	goto cclass_mb_not;
      }
      else {
	if (BITSET_AT(((BitSetRef )p), *s) != 0)
	  goto fail;

	p += SIZE_BITSET;
	GET_LENGTH_INC(tlen, p);
	p += tlen;
	s++;
      }
      break;

    case OP_ANYCHAR:  STAT_OP_IN(OP_ANYCHAR);
      DATA_ENSURE(1);
      if (ismb(encode, *s)) {
	n = mblen(encode, *s);
	DATA_ENSURE(n);
	s += n;
      }
      else {
	if (! IS_MULTILINE(option)) {
	  if (SBCMP(*s, NEWLINE)) {
	    goto fail;
	  }
	}
	s++;
      }
      break;

    case OP_ANYCHAR_STAR:  STAT_OP_IN(OP_ANYCHAR_STAR);
      while (s < end) {
	STACK_PUSH_ALT(p, s, sprev);
	if (ismb(encode, *s)) {
	  n = mblen(encode, *s);
	  DATA_ENSURE(n);
	  sprev = s;
	  s += n;
	}
	else {
	  if (! IS_MULTILINE(option)) {
	    if (SBCMP(*s, NEWLINE))
	      goto fail;
	  }
	  sprev = s;
	  s++;
	}
      }
      break;

    case OP_WORD:  STAT_OP_IN(OP_WORD);
      DATA_ENSURE(1);
      if (! IS_WORD_STR_INC(encode, s, end))
	goto fail;
      break;

    case OP_NOT_WORD:  STAT_OP_IN(OP_NOT_WORD);
      DATA_ENSURE(1);
      if (IS_WORD_STR_INC(encode, s, end))
	goto fail;
      break;

    case OP_WORD_BOUND:  STAT_OP_IN(OP_WORD_BOUND);
      if (ON_STR_BEGIN(s)) {
	DATA_ENSURE(1);
	if (! IS_WORD_STR(encode, s, end))
	  goto fail;
      }
      else if (ON_STR_END(s)) {
	if (! IS_WORD_STR(encode, sprev, end))
	  goto fail;
      }
      else {
	if (IS_WORD_STR(encode, s, end) == IS_WORD_STR(encode, sprev, end))
	  goto fail;
      }
      continue;
      break;

    case OP_NOT_WORD_BOUND:  STAT_OP_IN(OP_NOT_WORD_BOUND);
      if (ON_STR_BEGIN(s)) {
	if (DATA_ENSURE_CHECK(1) && IS_WORD_STR(encode, s, end))
	  goto fail;
      }
      else if (ON_STR_END(s)) {
	if (IS_WORD_STR(encode, sprev, end))
	  goto fail;
      }
      else {
	if (IS_WORD_STR(encode, s, end) != IS_WORD_STR(encode, sprev, end))
	  goto fail;
      }
      continue;
      break;

#ifdef VALID_WORD_BEGIN_END
    case OP_WORD_BEGIN:  STAT_OP_IN(OP_WORD_BEGIN);
      if (DATA_ENSURE_CHECK(1) && IS_WORD_STR(encode, s, end)) {
	if (ON_STR_BEGIN(s) || !IS_WORD_STR(encode, sprev, end))
	  continue;
      }
      goto fail;
      break;

    case OP_WORD_END:  STAT_OP_IN(OP_WORD_END);
      if (!ON_STR_BEGIN(s) && IS_WORD_STR(encode, sprev, end)) {
	if (ON_STR_END(s) || !IS_WORD_STR(encode, s, end))
	  continue;
      }
      goto fail;
      break;
#endif

    case OP_BEGIN_BUF:  STAT_OP_IN(OP_BEGIN_BUF);
      if (! ON_STR_BEGIN(s)) goto fail;

      continue;
      break;

    case OP_END_BUF:  STAT_OP_IN(OP_END_BUF);
      if (! ON_STR_END(s)) goto fail;

      continue;
      break;

    case OP_BEGIN_LINE:  STAT_OP_IN(OP_BEGIN_LINE);
      if (ON_STR_BEGIN(s))
	continue;
      else if (IS_NEWLINE(*sprev) && !ON_STR_END(s))
	continue;

      goto fail;
      break;

    case OP_END_LINE:  STAT_OP_IN(OP_END_LINE);
      if (ON_STR_END(s)) {
	if (IS_EMPTY_STR || !IS_NEWLINE(*sprev))
	  continue;
      }
      else if (IS_NEWLINE(*s))
	continue;

      goto fail;
      break;

    case OP_SEMI_END_BUF:  STAT_OP_IN(OP_SEMI_END_BUF);
      if (ON_STR_END(s)) {
	if (IS_EMPTY_STR || !IS_NEWLINE(*sprev))
	  continue;
      }
      if (IS_NEWLINE(*s) && ON_STR_END(s+1))
	continue;

      goto fail;
      break;

    case OP_BEGIN_POSITION:  STAT_OP_IN(OP_BEGIN_POSITION);
      if (s != sstart)
	goto fail;

      continue;
      break;

    case OP_MEMORY_START_PUSH:  STAT_OP_IN(OP_MEMORY_START_PUSH);
      GET_MEMNUM_INC(mem, p);
      STACK_PUSH_MEM_START(mem, s);
      continue;
      break;

    case OP_MEMORY_END_PUSH:  STAT_OP_IN(OP_MEMORY_END_PUSH);
      GET_MEMNUM_INC(mem, p);
      STACK_PUSH_MEM_END(mem, s);
      continue;
      break;

    case OP_MEMORY_END:  STAT_OP_IN(OP_MEMORY_END);
      GET_MEMNUM_INC(mem, p);
      mem_end_stk[mem] = (StackType* )((void* )s);
      continue;
      break;

    case OP_BACKREF1:  STAT_OP_IN(OP_BACKREF1);
      mem = 1;
      goto backref;
      break;

    case OP_BACKREF2:  STAT_OP_IN(OP_BACKREF2);
      mem = 2;
      goto backref;
      break;

    case OP_BACKREF3:  STAT_OP_IN(OP_BACKREF3);
      mem = 3;
      goto backref;
      break;

    case OP_BACKREFN:  STAT_OP_IN(OP_BACKREFN);
      GET_MEMNUM_INC(mem, p);
    backref:
      {
	int len;
	UChar *sstart, *send;
	StackType* sp;

	if (mem > max_mem) goto fail;
	sp = mem_end_stk[mem];
	if (sp) {
	  send = sp->u.mem.pstr;
	  sp = sp->u.mem.start;
	  sstart = sp->u.mem.pstr;
	  n = send - sstart;
	  DATA_ENSURE(n);
	  sprev = s;
	  STRING_CMP(sstart, s, n);
	  while (sprev + (len = mblen(encode, *sprev)) < s)
	    sprev += len;
	  continue;
	}
      }
      goto fail;
      break;

    case OP_SET_OPTION_PUSH:  STAT_OP_IN(OP_SET_OPTION_PUSH);
      GET_OPTION_INC(option, p);
      ignore_case = IS_IGNORECASE(option);
      STACK_PUSH_ALT(p, s, sprev);
      p += SIZE_OP_SET_OPTION + SIZE_OP_FAIL;
      continue;
      break;

    case OP_SET_OPTION:  STAT_OP_IN(OP_SET_OPTION);
      GET_OPTION_INC(option, p);
      ignore_case = IS_IGNORECASE(option);
      continue;
      break;

    case OP_NULL_CHECK_START:  STAT_OP_IN(OP_NULL_CHECK_START);
      GET_MEMNUM_INC(mem, p);    /* mem: null check id */
      STACK_PUSH_NULL_CHECK_START(mem, s);
      continue;
      break;

    case OP_NULL_CHECK_END:  STAT_OP_IN(OP_NULL_CHECK_END);
      {
	int isnull;

	GET_MEMNUM_INC(mem, p); /* mem: null check id */
	STACK_NULL_CHECK(isnull, mem, s);
	if (isnull) {
#ifdef REG_DEBUG_MATCH
	  fprintf(stderr, "NULL_CHECK_END: skip  id:%d, s:%d\n",
		  (int )mem, (int )s);
#endif
	  /* empty loop founded, skip next instruction */
	  switch (*p++) {
	  case OP_JUMP:
	  case OP_PUSH:
	    GET_RELADDR_INC(addr, p);
	    break;
	  case OP_REPEAT_INC:
	  case OP_REPEAT_INC_NG:
	    GET_MEMNUM_INC(mem, p);
	    break;
	  default:
	    goto unexpected_bytecode_error;
	    break;
	  }
	}
      }
      continue;
      break;

    case OP_JUMP:  STAT_OP_IN(OP_JUMP);
      GET_RELADDR_INC(addr, p);
      p += addr;
      continue;
      break;

    case OP_PUSH:  STAT_OP_IN(OP_PUSH);
      GET_RELADDR_INC(addr, p);
      STACK_PUSH_ALT(p + addr, s, sprev);
      continue;
      break;

    case OP_PUSH_OR_JUMP_EXACT1:  STAT_OP_IN(OP_PUSH_OR_JUMP_EXACT1);
      GET_RELADDR_INC(addr, p);
      if (*p == *s && DATA_ENSURE_CHECK(1)) {
	p++;
	STACK_PUSH_ALT(p + addr, s, sprev);
	continue;
      }
      p += (addr + 1);
      continue;
      break;

    case OP_REPEAT:  STAT_OP_IN(OP_REPEAT);
      {
	RepeatNumType lower, upper;

	GET_MEMNUM_INC(mem, p);    /* mem: OP_REPEAT ID */
	GET_RELADDR_INC(addr, p);
	GET_REPEATNUM_INC(lower, p);
	GET_REPEATNUM_INC(upper, p);

	STACK_ENSURE(1);
	repeat_stk[mem] = stk;
	STACK_PUSH_REPEAT(p, lower, upper);

	if (lower == 0) {
	  STACK_PUSH_ALT(p + addr, s, sprev);
	}
      }
      continue;
      break;

    case OP_REPEAT_NG:  STAT_OP_IN(OP_REPEAT_NG);
      {
	RepeatNumType lower, upper;

	GET_MEMNUM_INC(mem, p);    /* mem: OP_REPEAT ID */
	GET_RELADDR_INC(addr, p);
	GET_REPEATNUM_INC(lower, p);
	GET_REPEATNUM_INC(upper, p);

	STACK_ENSURE(1);
	repeat_stk[mem] = stk;
	STACK_PUSH_REPEAT(p, lower, upper);

	if (lower == 0) {
	  STACK_PUSH_ALT(p, s, sprev);
	  p += addr;
	}
      }
      continue;
      break;

    case OP_REPEAT_INC:  STAT_OP_IN(OP_REPEAT_INC);
      {
	StackType* sp;

	GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */
	sp = repeat_stk[mem];
	sp->u.repeat.count++;
	if (sp->u.repeat.count == sp->u.repeat.upper) {
	  /* end of repeat. Nothing to do. */
	}
	else if (sp->u.repeat.count >= sp->u.repeat.lower) {
	  STACK_PUSH_ALT(p, s, sprev);
	  p = sp->u.repeat.pcode;
	}
	else {
	  p = sp->u.repeat.pcode;
	}
	STACK_PUSH_REPEAT_INC(sp);
      }
      continue;
      break;

    case OP_REPEAT_INC_NG:  STAT_OP_IN(OP_REPEAT_INC_NG);
      {
	StackType* sp;

	GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */
	sp = repeat_stk[mem];
	sp->u.repeat.count++;
	if (sp->u.repeat.count == sp->u.repeat.upper) {
	  /* end of repeat. Nothing to do. */
	}
	else if (sp->u.repeat.count >= sp->u.repeat.lower) {
	  STACK_PUSH_ALT(sp->u.repeat.pcode, s, sprev);
	}
	else {
	  p = sp->u.repeat.pcode;
	}
	STACK_PUSH_REPEAT_INC(sp);
      }
      continue;
      break;

    case OP_PUSH_POS:  STAT_OP_IN(OP_PUSH_POS);
      STACK_PUSH_POS(s, sprev);
      continue;
      break;

    case OP_POP_POS:  STAT_OP_IN(OP_POP_POS);
      {
	StackType* k;

	STACK_POS_END(k);
	s     = k->u.state.pstr;
	sprev = k->u.state.pstr_prev;
      }
      continue;
      break;

    case OP_PUSH_POS_NOT:  STAT_OP_IN(OP_PUSH_POS_NOT);
      GET_RELADDR_INC(addr, p);
      STACK_PUSH_POS_NOT(p + addr, s, sprev);
      continue;
      break;

    case OP_FAIL_POS:  STAT_OP_IN(OP_FAIL_POS);
      STACK_POP_TIL_POS_NOT;
      goto fail;
      break;

    case OP_PUSH_STOP_BT:  STAT_OP_IN(OP_PUSH_STOP_BT);
      STACK_PUSH_STOP_BT;
      continue;
      break;

    case OP_POP_STOP_BT:  STAT_OP_IN(OP_POP_STOP_BT);
      STACK_STOP_BT_END;
      continue;
      break;

    case OP_FAIL:
    fail:
    STAT_OP_IN(OP_FAIL);
      STACK_POP;  /* if stack is empty, goto end. */
      p     = stk->u.state.pcode;
      s     = stk->u.state.pstr;
      sprev = stk->u.state.pstr_prev;
      continue;
      break;

    default:
      goto bytecode_error;

    } /* end of switch */
    sprev = sbegin;
  } /* end of while(1) */

 finish:
  STACK_SAVE;
  return best_len;

 stack_error:
  STACK_SAVE;
  return REGERR_STACK_BUG;

 bytecode_error:
  STACK_SAVE;
  return REGERR_UNDEFINED_BYTECODE;

 unexpected_bytecode_error:
  STACK_SAVE;
  return REGERR_UNEXPECTED_BYTECODE;
}

extern int re_adjust_startpos(regex_t* reg, const char* string, int size,
			      int startpos, int range)
{
  if (startpos > 0 && mbmaxlen(reg->code) != 1 && startpos < size) {
    UChar *p;
    UChar *s = (UChar* )string + startpos;

    if (range > 0) {
      p = GetRightAdjustCharHead(reg->code, (UChar* )string, s);
    }
    else {
      p = GetLeftAdjustCharHead(reg->code, (UChar* )string, s);
    }
    return p - (UChar* )string;
  }

  return startpos;
}

static UChar* SlowSearch(RegCharCodeType code,
			 UChar* target, UChar* target_end,
			 UChar* text, UChar* text_end, UChar* text_range)
{
  UChar *t, *p, *s, *end;

  end = text_end - (target_end - target) + 1;
  if (end > text_range)
    end = text_range;

  s = text;

  while (s < end) {
    if (*s == *target) {
      p = s + 1;
      t = target + 1;
      while (t < target_end) {
	if (*t != *p++)
	  break;
	t++;
      }
      if (t == target_end)
	return s;
    }
    s += mblen(code, *s);
  }

  return (UChar* )NULL;
}

static int StrTransMatchAfterHeadByte(RegCharCodeType code, UChar* trans,
			      int len, UChar* t, UChar* tend, UChar* p)
{
  while (--len > 0) {
    if (*t != *p) break;
    t++; p++;
  }

  if (len == 0) {
    while (t < tend) {
      len = mblen(code, *p);
      if (len == 1) {
	if (*t != TTRANS(trans, *p))
	  break;
	p++;
	t++;
      }
      else {
	if (*t != *p++)  break;
	t++;
	while (--len > 0) {
	  if (*t != *p) break;
	  t++; p++;
	}
	if (len > 0) break;
      }
    }
    if (t == tend)
      return 1;
  }

  return 0;
}

static UChar* SlowSearchIC(RegCharCodeType code, UChar* transtable,
			   UChar* target, UChar* target_end,
			   UChar* text, UChar* text_end, UChar* text_range)
{
  int len;
  UChar *t, *p, *s, *end;

  end = text_end - (target_end - target) + 1;
  if (end > text_range)
    end = text_range;

  s = text;

  while (s < end) {
    len = mblen(code, *s);
    if (*s == *target || (len == 1 && TTRANS(transtable, *s) == *target)) {
      p = s + 1;
      t = target + 1;
      if (StrTransMatchAfterHeadByte(code, transtable, len, t, target_end, p))
	return s;
    }
    s += len;
  }

  return (UChar* )NULL;
}

static UChar* SlowSearchBackward(RegCharCodeType code,
	 UChar* target, UChar* target_end,
	 UChar* text, UChar* adjust_text, UChar* text_end, UChar* text_start)
{
  UChar *t, *p, *s;

  s = text_end - (target_end - target);
  if (s > text_start)
    s = text_start;
  else
    s = GetLeftAdjustCharHead(code, adjust_text, s);

  while (s >= text) {
    if (*s == *target) {
      p = s + 1;
      t = target + 1;
      while (t < target_end) {
	if (*t != *p++)
	  break;
	t++;
      }
      if (t == target_end)
	return s;
    }
    s = GetPrevCharHead(code, adjust_text, s);
  }

  return (UChar* )NULL;
}

static UChar* SlowSearchBackwardIC(RegCharCodeType code, UChar* transtable,
	 UChar* target, UChar* target_end,
	 UChar* text, UChar* adjust_text, UChar* text_end, UChar* text_start)
{
  int len;
  UChar *t, *p, *s;

  s = text_end - (target_end - target);
  if (s > text_start)
    s = text_start;
  else
    s = GetLeftAdjustCharHead(code, adjust_text, s);

  while (s >= text) {
    len = mblen(code, *s);
    if (*s == *target || (len == 1 && TTRANS(transtable, *s) == *target)) {
      p = s + 1;
      t = target + 1;
      if (StrTransMatchAfterHeadByte(code, transtable, len, t, target_end, p))
	return s;
    }
    s = GetPrevCharHead(code, adjust_text, s);
  }

  return (UChar* )NULL;
}

/* set skip map for Boyer-Moor search */
static int SetBMSkip(UChar* s, UChar* end, UChar* transtable,
		     UChar skip[], int** int_skip)
{
  int i, len;

  len = end - s;
  if (len < REG_CHAR_TABLE_SIZE) {
    for (i = 0; i < REG_CHAR_TABLE_SIZE; i++) skip[i] = len;

    if (transtable) {
      for (i = 0; i < len - 1; i++)
	skip[TTRANS(transtable, s[i])] = len - 1 - i;
    }
    else {
      for (i = 0; i < len - 1; i++)
	skip[s[i]] = len - 1 - i;
    }
  }
  else {
    if (IS_NULL(*int_skip)) {
      *int_skip = (int* )xmalloc(sizeof(int) * REG_CHAR_TABLE_SIZE);
      if (IS_NULL(*int_skip)) return REGERR_MEMORY;
    }
    for (i = 0; i < REG_CHAR_TABLE_SIZE; i++) (*int_skip)[i] = len;

    if (transtable) {
      for (i = 0; i < len - 1; i++)
	(*int_skip)[TTRANS(transtable, s[i])] = len - 1 - i;
    }
    else {
      for (i = 0; i < len - 1; i++)
	(*int_skip)[s[i]] = len - 1 - i;
    }
  }
  return 0;
}

static UChar* BMSearch(regex_t* reg, UChar* target, UChar* target_end,
			      UChar* text, UChar* text_end, UChar* text_range)
{
  UChar *s, *t, *p, *end;
  UChar *tail;
  int skip;

  end = text_range + (target_end - target) - 1;
  if (end > text_end)
    end = text_end;

  tail = target_end - 1;
  if (IS_INDEPENDENT_TRAIL(reg->code)) {
    s = text + (target_end - target) - 1;
    if (IS_NULL(reg->int_map)) {
      while (s < end) {
	p = s;
	t = tail;
	while (t >= target && *p == *t) {
	  p--; t--;
	}
	if (t < target) return p + 1;
	s += reg->map[*s];
      }
    }
    else { /* see int_map[] */
      while (s < end) {
	p = s;
	t = tail;
	while (t >= target && *p == *t) {
	  p--; t--;
	}
	if (t < target) return p + 1;
	s += reg->int_map[*s];
      }
    }
  }
  else {
    s = text;
    while ((s - text) < target_end - target) {
      s += mblen(reg->code, *s);
    }
    s--; /* set to fisrst check text tail position. */

    if (IS_NULL(reg->int_map)) {
      while (s < end) {
	p = s;
	t = tail;
	while (t >= target && *p == *t) {
	  p--; t--;
	}
	if (t < target) return p + 1;

	skip = reg->map[*s];
	p++;
	t = p;
	while ((p - t) < skip) {
	  p += mblen(reg->code, *p);
	}
	s += (p - t);
      }
    }
    else {
      while (s < end) {
	p = s;
	t = tail;
	while (t >= target && *p == *t) {
	  p--; t--;
	}
	if (t < target) return p + 1;

	skip = reg->int_map[*s];
	p++;
	t = p;
	while ((p - t) < skip) {
	  p += mblen(reg->code, *p);
	}
	s += (p - t);
      }
    }
  }

  return (UChar* )NULL;
}

static int SetBMBackwardSkip(UChar* s, UChar* end,
			     UChar* transtable, int** skip)
{
  int i, len;

  if (IS_NULL(*skip)) {
    *skip = (int* )xmalloc(sizeof(int) * REG_CHAR_TABLE_SIZE);
    if (IS_NULL(*skip)) return REGERR_MEMORY;
  }

  len = end - s;
  for (i = 0; i < REG_CHAR_TABLE_SIZE; i++)
    (*skip)[i] = len;

  if (transtable) {
    for (i = len - 1; i > 0; i--)
      (*skip)[TTRANS(transtable, s[i])] = i;
  }
  else {
    for (i = len - 1; i > 0; i--)
      (*skip)[s[i]] = i;
  }
  return 0;
}

static UChar* BMSearchBackward(regex_t* reg, UChar* target, UChar* target_end,
       UChar* text, UChar* adjust_text, UChar* text_end, UChar* text_start)
{
  UChar *s, *t, *p;

  s = text_end - (target_end - target);
  if (text_start < s)
    s = text_start;
  else
    s = GetLeftAdjustCharHead(reg->code, adjust_text, s);

  while (s >= text) {
    p = s;
    t = target;
    while (t < target_end && *p == *t) {
      p++; t++;
    }
    if (t == target_end)
      return s;

    s -= reg->int_map_backward[*s];
    s = GetLeftAdjustCharHead(reg->code, adjust_text, s);
  }

  return (UChar* )NULL;
}

static UChar* MapSearch(RegCharCodeType code, UChar map[],
			UChar* text, UChar* text_range)
{
  UChar *s = text;

  while (s < text_range) {
    if (map[*s]) return s;

    s += mblen(code, *s);
  }
  return (UChar* )NULL;
}

static UChar* MapSearchBackward(RegCharCodeType code, UChar map[],
			UChar* text, UChar* adjust_text, UChar* text_start)
{
  UChar *s = text_start;

  while (s >= text) {
    if (map[*s]) return s;

    s = GetPrevCharHead(code, adjust_text, s);
  }
  return (UChar* )NULL;
}

extern int re_match(regex_t* reg, const char* str, int size, int pos,
		    struct re_registers* regs)
{
  int r;
  UChar *prev;
  MatchStackAlloc msa;

  MATCH_STACK_ALLOC_INIT(msa);

  r = RegexRegionResize(regs, reg->max_mem + 1);
  if (r) goto end;

  prev = GetPrevCharHead(reg->code, (UChar* )str, (UChar* )(str + pos));

  r = regexMatch(reg, (UChar* )str, (UChar* )(str + size),
		 (UChar* )(str + pos), prev, regs, &msa);

 end:
  MATCH_STACK_ALLOC_FREE(msa);
  return r;
}

static int ForwardSearchRange(regex_t* reg, UChar* str, UChar* end, UChar* s,
	      UChar* range, UChar** low, UChar** high, UChar** low_prev)
{
  UChar *p, *pprev = (UChar* )NULL;

#ifdef REG_DEBUG_SEARCH
    fprintf(stderr,
	    "ForwardSearchRange: str: %d, end: %d, s: %d, range: %d\n",
	    (int )str, (int )end, (int )s, (int )range);
#endif

  p = s;
  if (reg->dmin > 0 && IS_SINGLEBYTE_CODE(reg->code))
    p += reg->dmin;

 retry:
  switch (reg->optimize) {
  case REG_OPTIMIZE_EXACT:
    p = SlowSearch(reg->code, reg->exact, reg->exact_end, p, end, range);
    break;
  case REG_OPTIMIZE_EXACT_IC:
    p = SlowSearchIC(reg->code, reg->transtable,
		     reg->exact, reg->exact_end, p, end, range);
    break;

  case REG_OPTIMIZE_EXACT_BM:
    p = BMSearch(reg, reg->exact, reg->exact_end, p, end, range);
    break;

  case REG_OPTIMIZE_MAP:
    p = MapSearch(reg->code, reg->map, p, range);
    break;
  }

  if (p && p < range) {
    if (p - reg->dmin < s) {
    retry_gate:
      pprev = p;
      p += mblen(reg->code, *p);
      goto retry;
    }

    if (reg->sub_anchor) {
      UChar* prev;

      switch (reg->sub_anchor) {
      case ANCHOR_BEGIN_LINE:
	if (!ON_STR_BEGIN(p)) {
	  prev = GetPrevCharHead(reg->code, (pprev ? pprev : str), p);
	  if (!IS_NEWLINE(*prev))
	    goto retry_gate;
	}
	break;

      case ANCHOR_END_LINE:
	prev = GetPrevCharHead(reg->code, (pprev ? pprev : str), p);
	if (!prev || !IS_NEWLINE(*prev))
	  goto retry_gate;
	break;
      }
    }

    if (reg->dmax == 0) {
      *low = p;
      if (low_prev) {
	if (*low > s)
	  *low_prev = GetPrevCharHead(reg->code, s, p);
	else
	  *low_prev = GetPrevCharHead(reg->code, (pprev ? pprev : str), p);
      }
    }
    else {
      *low = p - reg->dmax;
      if (*low > s) {
	*low = GetRightAdjustCharHeadWithPrev(reg->code, s, *low, low_prev);
	if (low_prev && IS_NULL(*low_prev))
	  *low_prev = GetPrevCharHead(reg->code, (pprev ? pprev : s), *low);
      }
      else {
	if (low_prev)
	  *low_prev = GetPrevCharHead(reg->code, (pprev ? pprev : str), *low);
      }
    }
    /* no needs to adjust *high, *high is used as range check only */
    *high = p - reg->dmin;

#ifdef REG_DEBUG_SEARCH
    fprintf(stderr,
    "ForwardSearchRange success: low: %d, high: %d, dmin: %d, dmax: %d\n",
	    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);
#endif
    return 1; /* success */
  }

  return 0; /* fail */
}

static int SetBMBackwardSkip(UChar* s, UChar* end, UChar* transtable,
			     int** skip);

#define BM_BACKWARD_SEARCH_LENGTH_THRESHOLD   100

static int BackwardSearchRange(regex_t* reg, UChar* str, UChar* end, UChar* s,
	      UChar* range, UChar* adjrange, UChar** low, UChar** high)
{
  int r;
  UChar *p;

  range += reg->dmin;
  p = s;

 retry:
  switch (reg->optimize) {
  case REG_OPTIMIZE_EXACT:
  exact_method:
    p = SlowSearchBackward(reg->code, reg->exact, reg->exact_end,
			   range, adjrange, end, p);
    break;

  case REG_OPTIMIZE_EXACT_IC:
    p = SlowSearchBackwardIC(reg->code, reg->transtable,
		     reg->exact, reg->exact_end, range, adjrange, end, p);
    break;

  case REG_OPTIMIZE_EXACT_BM:
    if (IS_NULL(reg->int_map_backward)) {
      if (s - range < BM_BACKWARD_SEARCH_LENGTH_THRESHOLD)
	goto exact_method;

      r = SetBMBackwardSkip(reg->exact, reg->exact_end, (UChar* )NULL,
			    &(reg->int_map_backward));
      if (r) return r;
    }
    p = BMSearchBackward(reg, reg->exact, reg->exact_end, range, adjrange,
			 end, p);
    break;

  case REG_OPTIMIZE_MAP:
    p = MapSearchBackward(reg->code, reg->map, range, adjrange, p);
    break;
  }

  if (p) {
    if (reg->sub_anchor) {
      UChar* prev;

      switch (reg->sub_anchor) {
      case ANCHOR_BEGIN_LINE:
	if (!ON_STR_BEGIN(p)) {
	  prev = GetPrevCharHead(reg->code, adjrange, p);
	  if (!IS_NEWLINE(*prev)) {
	    p = prev;
	    goto retry;
	  }
	}
	break;

      case ANCHOR_END_LINE:
	prev = GetPrevCharHead(reg->code, adjrange, p);
	if (!prev)  goto fail;
	if (!IS_NEWLINE(*prev)) {
	  p = prev;
	  goto retry;
	}
	break;
      }
    }

    /* no needs to adjust *high, *high is used as range check only */
    *low  = p - reg->dmax;
    *high = p - reg->dmin;
    *high = GetRightAdjustCharHead(reg->code, adjrange, *high);

#ifdef REG_DEBUG_SEARCH
    fprintf(stderr, "BackwardSearchRange: low: %d, high: %d\n",
	    (int )(*low - str), (int )(*high - str));
#endif
    return 1; /* success */
  }

 fail:
#ifdef REG_DEBUG_SEARCH
  fprintf(stderr, "BackwardSearchRange: fail.\n");
#endif
  return 0; /* fail */
}


static void regexFreeBody(regex_t* reg)
{
  if (reg->p)       xfree(reg->p);
  if (reg->exact)   xfree(reg->exact);
  if (reg->int_map) xfree(reg->int_map);
  if (reg->int_map_backward)
    xfree(reg->int_map_backward);

  if (reg->chain)
    RegexFree(reg->chain);
}

extern void RegexFree(regex_t* reg)
{
  if (reg) {
    regexFreeBody(reg);
    xfree(reg);
  }
}

#define REGEX_TRANSFER(to,from) do {\
  (to)->state = REG_STATE_MODIFY;\
  regexFreeBody(to);\
  xmemcpy(to, from, sizeof(regex_t));\
  xfree(from);\
} while (0)

static void regexTransfer(regex_t* to, regex_t* from)
{
  THREAD_ATOMIC_START;
  REGEX_TRANSFER(to,from);
  THREAD_ATOMIC_END;
}

#define REGEX_CHAIN_HEAD(reg) do {\
  while (IS_NOT_NULL((reg)->chain)) {\
    (reg) = (reg)->chain;\
  }\
} while (0)

static void regexChainLinkAdd(regex_t* to, regex_t* add)
{
  THREAD_ATOMIC_START;

  REGEX_CHAIN_HEAD(to);
  to->chain = add;

  THREAD_ATOMIC_END;
}

static void regexChainReduce(regex_t* reg)
{
  regex_t *head, *prev;

  THREAD_ATOMIC_START;

  prev = reg;
  head = prev->chain;
  if (IS_NOT_NULL(head)) {
    while (IS_NOT_NULL(head->chain)) {
      prev = head;
      head = head->chain;
    }
    prev->chain = (regex_t* )NULL;
    REGEX_TRANSFER(reg,head);
  }

  THREAD_ATOMIC_END;
}

extern int RegexSearch(regex_t* reg, UChar* str, UChar* end,
		       UChar* start, UChar* range, RegRegion* region)
{
  int r;
  UChar *s, *prev;
  MatchStackAlloc msa;

  MATCH_STACK_ALLOC_INIT(msa);

  if (REG_STATE(reg) == REG_STATE_NORMAL) {
    regexChainReduce(reg);
  }

  reg->state++;  /* increment as search counter */

#ifdef REG_DEBUG_SEARCH
  fprintf(stderr, "RegexSearch (entry point): end: %d, start: %d, range: %d\n",
	  (int )(end - str), (int )(start - str), (int )(range - str));
#endif

  r = RegexRegionResize(region, reg->max_mem + 1);
  if (r) goto finish;

  if (start > end || start < str) goto mismatch;

  /* anchor optimize: resume search range */
  if (reg->anchor != 0 && str < end) {
    UChar* semi_end;

    if (reg->anchor & ANCHOR_BEGIN_POSITION) {
      /* search start-position only */
    begin_position:
      if (range > start)
	range = start + 1;
      else
	range = start;
    }
    else if (reg->anchor & ANCHOR_BEGIN_BUF) {
      /* search str-position only */
      if (range > start) {
	if (start != str) goto mismatch;
	range = str + 1;
      }
      else {
	if (range <= str) {
	  start = str;
	  range = str;
	}
	else
	  goto mismatch;
      }
    }
    else if (reg->anchor & ANCHOR_END_BUF) {
      semi_end = end;

    end_buf:
      if (semi_end - str < reg->anchor_dmin)
	goto mismatch;

      if (range > start) {
	if (semi_end - start > reg->anchor_dmax) {
	  start = semi_end - reg->anchor_dmax;
	  if (start < end)
	    start = GetRightAdjustCharHead(reg->code, str, start);
	  else { /* match with empty at end */
	    start = GetPrevCharHead(reg->code, str, end);
	  }
	}
	if (semi_end - (range - 1) < reg->anchor_dmin) {
	  range = semi_end - reg->anchor_dmin + 1;
	}

	if (start >= range) goto mismatch;
      }
      else {
	if (semi_end - range > reg->anchor_dmax) {
	  range = semi_end - reg->anchor_dmax;
	}
	if (semi_end - start < reg->anchor_dmin) {
	  start = semi_end - reg->anchor_dmin;
	  start = GetLeftAdjustCharHead(reg->code, str, start);
	  if (range > start) goto mismatch;
	}
      }
    }
    else if (reg->anchor & ANCHOR_SEMI_END_BUF) {
      if (IS_NEWLINE(end[-1])) {
	semi_end = end - 1;
	if (semi_end > str && start <= semi_end) {
	  goto end_buf;
	}
      }
      else {
	semi_end = end;
	goto end_buf;
      }
    }
    else if ((reg->anchor & ANCHOR_ANYCHAR_STAR_PL)) {
      goto begin_position;
    }
  }

#ifdef REG_DEBUG_SEARCH
  fprintf(stderr, "RegexSearch(apply anchor): end: %d, start: %d, range: %d\n",
	  (int )(end - str), (int )(start - str), (int )(range - str));
#endif

#define MATCH_AND_RETURN_CHECK \
  r = regexMatch(reg, str, end, s, prev, region, &msa);\
  if (r != REG_MISMATCH) {\
    if (r >= 0) goto match;\
    goto finish; /* error */ \
  }

  s = start;
  if (range > start) {   /* forward search */
    if (s > str)
      prev = GetPrevCharHead(reg->code, str, s);
    else
      prev = (UChar* )NULL;

    if (reg->optimize != REG_OPTIMIZE_NONE) {
      UChar *low, *high, *low_prev;

      if (reg->threshold_len != 0 && (end - start) >= reg->threshold_len) {
	do {
	  if (! ForwardSearchRange(reg, str, end, s, range,
				   &low, &high, &low_prev)) goto mismatch;
	  if (s < low) {
	    s    = low;
	    prev = low_prev;
	  }
	  while (s <= high) {
	    MATCH_AND_RETURN_CHECK;
	    prev = s;
	    s += mblen(reg->code, *s);
	  }
	  if ((reg->anchor & ANCHOR_ANYCHAR_STAR) != 0) {
	    if (IS_NOT_NULL(prev)) {
	      while (!IS_NEWLINE(*prev) && s < range) {
		prev = s;
		s += mblen(reg->code, *s);
	      }
	    }
	  }
	} while (s < range);
	goto mismatch;
      }
      else { /* check only. */
	if ((end - start) <= reg->dmin ||
	    ! ForwardSearchRange(reg, str, end, s, range,
				 &low, &high, (UChar** )NULL)) goto mismatch;
      }
    }

    do {
      MATCH_AND_RETURN_CHECK;
      prev = s;
      s += mblen(reg->code, *s);
    } while (s <= range);   /* exec s == range, because empty match with /$/. */
  }
  else {  /* backward search */
    if (reg->optimize != REG_OPTIMIZE_NONE) {
      UChar *low, *high, *adjrange;

      adjrange = GetLeftAdjustCharHead(reg->code, str, range);
      if (reg->threshold_len != 0 && (end - range) >= reg->threshold_len) {
	do {
	  if (BackwardSearchRange(reg, str, end, s, range, adjrange,
				  &low, &high) <= 0)
	    goto mismatch;

	  if (s > high)
	    s = high;

	  while (s >= low) {
	    prev = GetPrevCharHead(reg->code, str, s);
	    MATCH_AND_RETURN_CHECK;
	    s = prev;
	  }
	} while (s >= range);
	goto mismatch;
      }
      else { /* check only. */
	if ((end - range) <= reg->dmin ||
	    BackwardSearchRange(reg, str, end, s, range, adjrange,
				&low, &high) <= 0)
	  goto mismatch;
      }
    }

    do {
      prev = GetPrevCharHead(reg->code, str, s);
      MATCH_AND_RETURN_CHECK;
      s = prev;
    } while (s >= range);
  }

 mismatch:
  r = REG_MISMATCH;

 finish:
  RegexRegionClear(region);
  reg->state--;  /* decrement as search counter */
  MATCH_STACK_ALLOC_FREE(msa);
  return r;

 match:
  reg->state--;  /* decrement as search counter */
  MATCH_STACK_ALLOC_FREE(msa);
  return s - str;
}

extern int re_search(regex_t* bufp, const char* string,
		     int size, int startpos, int range,
		     struct re_registers* regs)
{
  return RegexSearch(bufp, (UChar* )string, (UChar* )(string + size),
		     (UChar* )(string + startpos),
		     (UChar* )(string + startpos + range), regs);
}


extern int RegexClone(regex_t* to, regex_t* from)
{
  int size;

  regexFreeBody(to);
  xmemcpy(to, from, sizeof(regex_t));
  to->state = REG_STATE_NORMAL;

  if (from->p) {
    to->p = (UChar* )xmalloc(to->alloc);
    if (IS_NULL(to->p)) return REGERR_MEMORY;
    xmemcpy(to->p, from->p, to->alloc);
  }

  if (from->exact) {
    to->exact = (UChar* )xmalloc(from->exact_end - from->exact);
    if (IS_NULL(to->exact)) return REGERR_MEMORY;
    to->exact_end = to->exact + (from->exact_end - from->exact);
  }

  if (from->int_map) {
    size = sizeof(int) * REG_CHAR_TABLE_SIZE;
    to->int_map = (int* )xmalloc(size);
    if (IS_NULL(to->int_map)) return REGERR_MEMORY;
    xmemcpy(to->int_map, from->int_map, size);
  }

  if (from->int_map_backward) {
    size = sizeof(int) * REG_CHAR_TABLE_SIZE;
    to->int_map_backward = (int* )xmalloc(size);
    if (IS_NULL(to->int_map_backward)) return REGERR_MEMORY;
    xmemcpy(to->int_map_backward, from->int_map_backward, size);
  }

  return 0;
}

static int regexCompile(regex_t* reg, UChar* pattern, UChar* pattern_end)
{
#define COMPILE_INIT_SIZE  20

  int r, init_size;
  Node* root;

  reg->state = REG_STATE_COMPILING;
  if (IS_IGNORECASE(reg->options) && IS_NULL(reg->transtable)) {
    r = REGERR_TABLE_FOR_IGNORE_CASE_IS_NOT_SETTED;
    goto end;
  }

  if (reg->alloc == 0) {
    init_size = (pattern_end - pattern) * 2;
    if (init_size <= 0) init_size = COMPILE_INIT_SIZE;
    r = BBUF_INIT(reg, init_size);
    if (r) goto end;
  }
  else
    reg->used = 0;

  reg->max_mem        = 0;
  reg->num_repeat     = 0;
  reg->num_null_check = 0;
  reg->mem_stats      = 0;

  r = ParseMakeTree(&root, pattern, pattern_end, reg);
  if (r) {
    if (root)  NodeFree(root);
    goto end;
  }

  r = setupTree(root, reg, 0);
  if (r == 0) {
    r = compileTree(root, reg);
    if (r == 0) {
      r = AddOpCode(reg, OP_END);
      if (r == 0) {
	ClearOptimizeInfo(reg);
#ifndef REG_DONT_OPTIMIZE
	r = SetOptimizeInfoFromTree(root, reg);
#endif
      }
    }
  }
  NodeFree(root);

#ifdef REG_DEBUG_COMPILE
    printCompiledByteCodeList(stderr, reg);
#endif
 end:
  reg->state = REG_STATE_NORMAL;
  return r;
}

extern int RegexReCompile(regex_t* reg, UChar* pattern, UChar* pattern_end,
	      RegOptionType option, RegCharCodeType code, UChar* transtable)
{
  int r;
  regex_t *new_reg, *head;

  head = reg;
  REGEX_CHAIN_HEAD(head);

  r = RegexNew(&new_reg, pattern, pattern_end, option, code, transtable);
  if (r) return r;
  if (REG_STATE(reg) == REG_STATE_NORMAL) {
    regexTransfer(reg, new_reg);
  }
  else {
    regexChainLinkAdd(reg, new_reg);
  }

  return r;
}

extern char* re_compile_pattern(const char* pattern, int size, regex_t* reg)
{
  int r;

  r = regexCompile(reg, (UChar* )pattern, (UChar* )(pattern + size));
  if (r)
    return RegexErrorCodeToStr(r);

  return NULL;
}

extern char* re_recompile_pattern(const char* pattern, int size, regex_t* reg)
{
  int r;

  r = RegexReCompile(reg, (UChar* )pattern, (UChar* )(pattern + size),
		     reg->options, reg->code, reg->transtable);
  if (r)
    return RegexErrorCodeToStr(r);

  return NULL;
}

extern void re_free_pattern(regex_t* reg)
{
  RegexFree(reg);
}

static int regex_inited = 0;

static int regexAllocInit(regex_t** reg, RegOptionType option,
		  RegCharCodeType code, UChar* transtable)
{
  if (! regex_inited)
    RegexInit();

  *reg = (regex_t* )xmalloc(sizeof(regex_t));
  if (IS_NULL(*reg)) return REGERR_MEMORY;

  (*reg)->state            = REG_STATE_NORMAL;
  (*reg)->code             = code;
  (*reg)->options          = option;
  (*reg)->transtable       = (transtable ? transtable : DefaultTransTable);
  (*reg)->optimize         = 0;
  (*reg)->exact            = (UChar* )NULL;
  (*reg)->int_map          = (int* )NULL;
  (*reg)->int_map_backward = (int* )NULL;
  (*reg)->chain            = (regex_t* )NULL;

  (*reg)->p                = (UChar* )NULL;
  (*reg)->alloc            = 0;
  (*reg)->used             = 0;

  return 0;
}

extern int re_alloc_pattern(regex_t** reg)
{
  int r;

  if (RegDefaultCharCode == REGCODE_UNDEF)
    return REGERR_DEFAULT_ENCODING_IS_NOT_SETTED;

  r = regexAllocInit(reg, REG_OPTION_DEFAULT, RegDefaultCharCode,
		     DefaultTransTable);
  return r;
}

extern int RegexNew(regex_t** reg, UChar* pattern, UChar* pattern_end,
	     RegOptionType option, RegCharCodeType code, UChar* transtable)
{
  int r;

  r = regexAllocInit(reg, option, code, transtable);
  if (r) return r;

  r = regexCompile(*reg, pattern, pattern_end);
  if (r) {
    RegexFree(*reg);
    *reg = NULL;
    return r;
  }
  return 0;
}

static void SetDefaultTransTable(UChar* table)
{
  int i;

  if (table && table != DefaultTransTable) {
    DefaultTransTable = table;

    for (i = 0; i < REG_CHAR_TABLE_SIZE; i++)
      AmbiguityTable[i] = 0;

    for (i = 0; i < REG_CHAR_TABLE_SIZE; i++) {
      AmbiguityTable[table[i]]++;
      if (table[i] != i)
	AmbiguityTable[i] += 2;
    }
  }
}

extern void re_set_casetable(const char* table)
{
  SetDefaultTransTable((UChar* )table);
}

extern void re_mbcinit(int mb_code)
{
  RegDefaultCharCode = REG_MBLEN_TABLE[mb_code];
}

extern int RegexInit()
{
#ifdef DEFAULT_TRANSTABLE_EXIST
  if (! DefaultTransTable)  /* check re_set_casetable() called already. */
    SetDefaultTransTable(DTT);
#endif

  STATISTICS_INIT;
  regex_inited = 1;
  return 0;
}

extern int RegexEnd()
{
#ifdef RECYCLE_NODE
  FreeNode* n;

  while (FreeNodeList) {
    n = FreeNodeList;
    FreeNodeList = FreeNodeList->next;
    xfree(n);
  }
#endif

  regex_inited = 0;
  return 0;
}


#ifdef REG_DEBUG

typedef struct {
  short int opcode;
  char*     name;
  short int arg_type;
} OpInfoType;

static OpInfoType OpInfo[] = {
  { OP_END,             "end",             ARG_NON     },

  { OP_EXACT1,              "exact1",          ARG_SPECIAL },
  { OP_EXACT2,              "exact2",          ARG_SPECIAL },
  { OP_EXACT3,              "exact3",          ARG_SPECIAL },
  { OP_EXACT4,              "exact4",          ARG_SPECIAL },
  { OP_EXACT5,              "exact5",          ARG_SPECIAL },
  { OP_EXACTN,              "exactn",          ARG_SPECIAL },
  { OP_EXACTMB2N1,          "exactmb2-n1",     ARG_SPECIAL },
  { OP_EXACTMB2N2,          "exactmb2-n2",     ARG_SPECIAL },
  { OP_EXACTMB2N3,          "exactmb2-n3",     ARG_SPECIAL },
  { OP_EXACTMB2N,           "exactmb2-n",      ARG_SPECIAL },
  { OP_EXACTMB4N,           "exactmb4n"  ,     ARG_SPECIAL },
  { OP_EXACTMBN,            "exactmbn",        ARG_SPECIAL },
  { OP_EXACT1_RAW,          "exact1-raw",      ARG_SPECIAL },
  { OP_EXACTN_RAW,          "exactn-raw",      ARG_SPECIAL },

  { OP_CCLASS,              "cclass",          ARG_SPECIAL },
  { OP_CCLASS_MB,           "cclass-mb",       ARG_SPECIAL },
  { OP_CCLASS_MIX,          "cclass-mix",      ARG_SPECIAL },
  { OP_CCLASS_NOT,          "cclass-not",      ARG_SPECIAL },
  { OP_CCLASS_MB_NOT,       "cclass-mb-not",   ARG_SPECIAL },
  { OP_CCLASS_MIX_NOT,      "cclass-mix-not",  ARG_SPECIAL },
  { OP_ANYCHAR,             "anychar",         ARG_NON     },
  { OP_ANYCHAR_STAR,        "anychar*",        ARG_NON     },
  { OP_WORD,                "word",            ARG_NON     },
  { OP_NOT_WORD,            "not-word",        ARG_NON     },
  { OP_WORD_BOUND,          "word-bound",      ARG_NON     },
  { OP_NOT_WORD_BOUND,      "not-word-bound",  ARG_NON     },
  { OP_WORD_BEGIN,          "word-begin",      ARG_NON     },
  { OP_WORD_END,            "word-end",        ARG_NON     },
  { OP_BEGIN_BUF,           "begin-buf",       ARG_NON     },
  { OP_END_BUF,             "end-buf",         ARG_NON     },
  { OP_BEGIN_LINE,          "begin-line",      ARG_NON     },
  { OP_END_LINE,            "end-line",        ARG_NON     },
  { OP_SEMI_END_BUF,        "semi-end-buf",    ARG_NON     },
  { OP_BEGIN_POSITION,      "begin-position",  ARG_NON     },
  { OP_BACKREF1,            "backref1",        ARG_NON     },
  { OP_BACKREF2,            "backref2",        ARG_NON     },
  { OP_BACKREF3,            "backref3",        ARG_NON     },
  { OP_BACKREFN,            "backrefn",        ARG_MEMNUM  },
  { OP_MEMORY_START_PUSH,   "mem-start_push",  ARG_MEMNUM  },
  { OP_MEMORY_END_PUSH,     "mem-end_push",    ARG_MEMNUM  },
  { OP_MEMORY_END,          "mem-end",         ARG_MEMNUM  },
  { OP_SET_OPTION_PUSH,     "set-option-push", ARG_OPTION  },
  { OP_SET_OPTION,          "set-option",      ARG_OPTION  },
  { OP_FAIL,                "fail",            ARG_NON     },
  { OP_JUMP,                "jump",            ARG_RELADDR },
  { OP_PUSH,                "push",            ARG_RELADDR },
  { OP_PUSH_OR_JUMP_EXACT1, "push-or-jump-e1", ARG_SPECIAL },
  { OP_REPEAT,              "repeat",          ARG_SPECIAL },
  { OP_REPEAT_NG,           "repeat-ng",       ARG_SPECIAL },
  { OP_REPEAT_INC,          "repeat-inc",      ARG_MEMNUM  },
  { OP_REPEAT_INC_NG,       "repeat-inx-ng",   ARG_MEMNUM  },
  { OP_NULL_CHECK_START,    "null-check-start",ARG_MEMNUM  },
  { OP_NULL_CHECK_END,      "null-check-end",  ARG_MEMNUM  },
  { OP_PUSH_POS,            "push-pos",        ARG_NON     },
  { OP_POP_POS,             "pop-pos",         ARG_NON     },
  { OP_PUSH_POS_NOT,        "push-pos-not",    ARG_RELADDR },
  { OP_FAIL_POS,            "fail-pos",        ARG_NON     },
  { OP_PUSH_STOP_BT,        "push-stop-bt",    ARG_NON     },
  { OP_POP_STOP_BT,         "pop-stop-bt",     ARG_NON     },
  { -1,                     "",                ARG_SPECIAL }
};

static char* Op2Name(int opcode)
{
  int i;

  for (i = 0; OpInfo[i].opcode >= 0; i++) {
    if (opcode == OpInfo[i].opcode)
      return OpInfo[i].name;
  }
  return "";
}

static int Op2ArgType(int opcode)
{
  int i;

  for (i = 0; OpInfo[i].opcode >= 0; i++) {
    if (opcode == OpInfo[i].opcode)
      return OpInfo[i].arg_type;
  }
  return ARG_SPECIAL;
}

static void Indent(FILE* f, int indent)
{
  int i;
  for (i = 0; i < indent; i++) putc(' ', f);
}

static void pOpCode(FILE* f, char* opcode)
{
  fprintf(f, "%s", opcode);
}

static void pString(FILE* f, int len, UChar* s)
{
  fputs(":", f);
  while (len-- > 0) { fputc(*s++, f); }
}

static void pLenString(FILE* f, LengthType len, int mb_len, UChar* s)
{
  int x = len * mb_len;

  fprintf(f, ":%d:", len);
  while (x-- > 0) { fputc(*s++, f); }
}

static void printCompiledByteCode(FILE* f, UChar* bp, UChar** nextp)
{
  int i, n, arg_type;
  RelAddrType addr;
  LengthType len;
  MemNumType mem;

  fprintf(f, "[%s", Op2Name(*bp));
  arg_type = Op2ArgType(*bp);
  if (arg_type != ARG_SPECIAL) {
    bp++;
    switch (arg_type) {
    case ARG_NON:
      break;
    case ARG_RELADDR:
      addr = *((RelAddrType* )bp);
      bp += SIZE_RELADDR;
      fprintf(f, ":(%d)", addr);
      break;
    case ARG_LENGTH:
      GET_LENGTH_INC(len, bp);
      fprintf(f, ":%d", len);
      break;
    case ARG_MEMNUM:
      mem = *((MemNumType* )bp);
      bp += SIZE_MEMNUM;
      fprintf(f, ":%d", mem);
      break;
    case ARG_OPTION:
      {
	RegOptionType option = *((RegOptionType* )bp);
	bp += SIZE_OPTION;
	fprintf(f, ":%d", option);
      }
      break;
    }
  }
  else {
    switch (*bp++) {
    case OP_EXACT1:
      pString(f, 1, bp++);
      break;
    case OP_EXACT2:
      pString(f, 2, bp); bp += 2;
      break;
    case OP_EXACT3:
      pString(f, 3, bp); bp += 3;
      break;
    case OP_EXACT4:
      pString(f, 4, bp); bp += 4;
      break;
    case OP_EXACT5:
      pString(f, 5, bp); bp += 5;
      break;
    case OP_EXACTN:
      GET_LENGTH_INC(len, bp);
      pLenString(f, len, 1, bp);
      bp += len;
      break;
    
    case OP_EXACTMB2N1:
      pString(f, 2, bp); bp += 2;
      break;
    case OP_EXACTMB2N2:
      pString(f, 4, bp); bp += 4;
      break;
    case OP_EXACTMB2N3:
      pString(f, 6, bp); bp += 6;
      break;
    case OP_EXACTMB2N:
      GET_LENGTH_INC(len, bp);
      pLenString(f, len, 2, bp);
      bp += len * 2;
      break;
    case OP_EXACTMB4N:
      GET_LENGTH_INC(len, bp);
      pLenString(f, len, 4, bp);
      bp += len * 4;
      break;
    case OP_EXACTMBN:
      {
	int mb_len;
      
	GET_LENGTH_INC(mb_len, bp);
	GET_LENGTH_INC(len, bp);
	fprintf(f, ":%d:%d:", mb_len, len);
	n = len * mb_len;
	while (n-- > 0) { fputc(*bp++, f); }
      }
      break;

    case OP_EXACT1_RAW:
      pString(f, 1, bp++);
      break;
    case OP_EXACTN_RAW:
      GET_LENGTH_INC(len, bp);
      pLenString(f, len, 1, bp);
      bp += len;
      break;

    case OP_CCLASS:
      n = BitSetOnNum((BitSetRef )bp);
      bp += SIZE_BITSET;
      fprintf(f, ":%d", n);
      break;

    case OP_CCLASS_NOT:
      n = BitSetOnNum((BitSetRef )bp);
      bp += SIZE_BITSET;
      fprintf(f, ":%d", n);
      break;

    case OP_CCLASS_MB:
    case OP_CCLASS_MB_NOT:
      {
	WCInt wc;

	n = BitSetOnNum((BitSetRef )bp);
	bp += SIZE_BITSET;
	GET_LENGTH_INC(len, bp);
	GET_WCINT(wc, bp);
	bp += len;
	fprintf(f, ":%d:%d:%d", n, (int )wc, len);
      }
      break;

    case OP_CCLASS_MIX:
    case OP_CCLASS_MIX_NOT:
      {
	WCInt wc;

	n = BitSetOnNum((BitSetRef )bp);
	bp += SIZE_BITSET;
	GET_LENGTH_INC(len, bp);
	GET_WCINT(wc, bp);
	bp += len;
	fprintf(f, ":%d:%d:%d", n, (int )wc, len);
      }
      break;
  
    case OP_REPEAT:
    case OP_REPEAT_NG:
      {
	RepeatNumType nf, nt;
	MemNumType id;

	id = *((MemNumType* )bp);
	bp += SIZE_MEMNUM;
	addr = *((RelAddrType* )bp);
	bp += SIZE_RELADDR;
	nf = *((RepeatNumType* )bp);
	bp += SIZE_REPEATNUM;
	nt = *((RepeatNumType* )bp);
	bp += SIZE_REPEATNUM;
	fprintf(f, ":%d:%d:%d-", id, addr, nf);
	if (IS_REPEAT_INFINITE(nt))
	  fprintf(f, "*");
	else
	  fprintf(f, "%d", nt);
      }
      break;

    case OP_PUSH_OR_JUMP_EXACT1:
      addr = *((RelAddrType* )bp);
      bp += SIZE_RELADDR;
      fprintf(f, ":(%d)", addr);
      pString(f, 1, bp);
      bp += 1;
      break;

    default:
      fprintf(stderr, "printCompiledByteCode: undefined code %d\n", *--bp);
    }
  }
  fputs("]", f);
  if (nextp) *nextp = bp;
}

static void printCompiledByteCodeList(FILE* f, regex_t* reg)
{
  int ncode;
  UChar* bp = reg->p;
  UChar* end = reg->p + reg->used;

  fprintf(f, "code length: %d\n", reg->used);

  ncode = 0;
  while (bp < end) {
    ncode++;
    if (bp > reg->p) {
      if (ncode % 5 == 0)
	fprintf(f, "\n");
      else
	fputs(" ", f);
    }
    printCompiledByteCode(f, bp, &bp);
  }

  fprintf(f, "\n");
}

static void printIndentTree(FILE* f, Node* node, int indent)
{
  int i, type;
  int add = 3;
  UChar* p;

  Indent(f, indent);
  if (IS_NULL(node)) {
    fprintf(f, "ERROR: null node!!!\n");
    exit (0);
  }

  type = NTYPE(node);
  switch (type) {
  case N_EMPTY:
    fprintf(f, "<empty>");
    break;

  case N_LIST:
  case N_ALT:
    if (NTYPE(node) == N_LIST)
      fprintf(f, "<list>\n");
    else
      fprintf(f, "<alt>\n");

    printIndentTree(f, NCONS(node).left, indent + add);
    while (IS_NOT_NULL(node = NCONS(node).right)) {
      if (NTYPE(node) != type) {
	fprintf(f, "ERROR: list/alt right is not a cons. %d\n", NTYPE(node));
	exit(0);
      }
      printIndentTree(f, NCONS(node).left, indent + add);
    }
    break;

  case N_STRING:
    fprintf(f, "<string>");
    for (p = NSTRING(node).s; p < NSTRING(node).end; p++) fputc(*p, f);
    break;

  case N_STRING_RAW:
    fprintf(f, "<string-raw>");
    for (p = NSTRING(node).s; p < NSTRING(node).end; p++) fputc(*p, f);
    break;

  case N_CCLASS:
    fprintf(f, "<cclass>");
    if (NCCLASS(node).not) fputs(" not", f);
    if (NCCLASS(node).mbuf) {
      BBuf* bbuf = NCCLASS(node).mbuf;
      for (i = 0; i < bbuf->used; i++) {
	if (i > 0) fprintf(f, ",");
	fprintf(f, "%0x", bbuf->p[i]);
      }
    }
    fprintf(f, "\n");
    Indent(f, indent);
    for (i = 0; i < SINGLE_BYTE_SIZE; i++)
      fputc((BITSET_AT(NCCLASS(node).bs, i) ? '1' : '0'), f);
    break;

  case N_CTYPE:
    fprintf(f, "<ctype> ");
    switch (NCTYPE(node).type) {
    case CTYPE_WORD:            fputs("word",           f); break;
    case CTYPE_NOT_WORD:        fputs("not word",       f); break;
    case CTYPE_WORD_BOUND:      fputs("word bound",     f); break;
    case CTYPE_NOT_WORD_BOUND:  fputs("not word bound", f); break;
#ifdef VALID_WORD_BEGIN_END
    case CTYPE_WORD_BEGIN:      fputs("word begin", f);     break;
    case CTYPE_WORD_END:        fputs("word end", f);       break;
#endif
    default:
      fprintf(f, "ERROR: undefined ctype.\n");
      exit(0);
    }
    break;

  case N_ANYCHAR:
    fprintf(f, "<anychar>");
    break;

  case N_ANCHOR:
    fprintf(f, "<anchor> ");
    switch (NANCHOR(node).type) {
    case ANCHOR_BEGIN_BUF:      fputs("begin buf",      f); break;
    case ANCHOR_END_BUF:        fputs("end buf",        f); break;
    case ANCHOR_BEGIN_LINE:     fputs("begin line",     f); break;
    case ANCHOR_END_LINE:       fputs("end line",       f); break;
    case ANCHOR_SEMI_END_BUF:   fputs("semi end buf",   f); break;
    case ANCHOR_BEGIN_POSITION: fputs("begin position", f); break;
    default:
      fprintf(f, "ERROR: undefined anchor type.\n");
      break;
    }
    break;

  case N_BACKREF:
    fprintf(f, "<backref>%d", NBACKREF(node).regnum);
    break;

  case N_QUALIFIER:
    fprintf(f, "<qualifier>{%d,%d}%s\n",
	    NQUALIFIER(node).lower, NQUALIFIER(node).upper,
	    (NQUALIFIER(node).greedy ? "" : "?"));
    printIndentTree(f, NQUALIFIER(node).target, indent + add);
    break;

  case N_OPTION:
    fprintf(f, "<option>%d\n", NOPTION(node).option);
    printIndentTree(f, NOPTION(node).target, indent + add);
    break;

  case N_EFFECT:
    fprintf(f, "<effect> ");
    switch (NEFFECT(node).type) {
    case EFFECT_MEMORY:
      fprintf(f, "memory:%d", NEFFECT(node).regnum);
      break;
    case EFFECT_PREC_READ:      fputs("prec read",      f); break;
    case EFFECT_PREC_READ_NOT:  fputs("prec read not",  f); break;
    case EFFECT_STOP_BACKTRACK: fputs("stop backtrack", f); break;
    default:
      break;
    }
    fprintf(f, "\n");
    printIndentTree(f, NEFFECT(node).target, indent + add);
    break;

  default:
    fprintf(f, "printIndentTree: undefined node type %d\n", NTYPE(node));
    break;
  }

  if (type != N_LIST && type != N_ALT && type != N_QUALIFIER &&
      type != N_OPTION && type != N_EFFECT)
    fprintf(f, "\n");
  fflush(f);
}

static void PrintTree(FILE* f, Node* node)
{
  printIndentTree(f, node, 0);
}

#ifdef REG_DEBUG_STATISTICS
static void PrintStatistics()
{
  int i;
  for (i = 0; OpInfo[i].opcode >= 0; i++) {
    fprintf(stderr, "%8d; %s\n", OpCounter[i], OpInfo[i].name);
  }
}
#endif

#endif /* REG_DEBUG */
@


1.1.1.1
log
@This is the initial import of Oni Guruma, a GNU regex compatible
regular expression library, snapshotted at 2002-02-25.

Copyright (C) 2002  K.Kosako (kosako@@sofnec.co.jp)
@
text
@@


1.1.1.2
log
@Import Oni Guruma 20020304 (version 1.1).
@
text
@a9 1
/* #define REG_DEBUG_PARSE_TREE */
d14 1
d16 1
a16 1
/* for byte-code statistical data. */
d19 2
a20 2
#if defined(REG_DEBUG_PARSE_TREE) || defined(REG_DEBUG_MATCH) || \
    defined(REG_DEBUG_COMPILE) || defined(REG_DEBUG_STATISTICS)
d27 1
a27 1
#define USE_RECYCLE_NODE
d29 3
a31 1
/* convert [push, exact...] --> [push_or_jump_exact, exact...] */
a32 2
#define INIT_MATCH_STACK_SIZE                  160
#define POSITION_SEARCH_MIN_THRESHOLD_LENGTH     7
d51 1
a51 1
/* non Ruby platform default, you can change. */
d54 1
a54 1
#endif
d130 2
a131 4
  case REGERR_TARGET_OF_REPEAT_QUALIFIER_NOT_SPECIFIED:
    p = "target of repeat-qualifier is not specified"; break;
  case REGERR_TARGET_OF_REPEAT_QUALIFIER_IS_EMPTY:
    p = "target of repeat-qualifier is empty"; break;
d144 2
a145 4
  case REGERR_INVALID_POSIX_BRACKET_TYPE:
    p = "invalid POSIX bracket type"; break;
  case REGERR_INVALID_LOOK_BEHIND_PATTERN:
    p = "invalid pattern in look-behind(?<)"; break;
d155 1
a155 1
    p = "too many multibyte code ranges are specified"; break;
d199 4
a202 9
static RegDistance DistanceAdd(RegDistance d1, RegDistance d2)
{
  if (d1 == INFINITE_DISTANCE || d2 == INFINITE_DISTANCE)
    return INFINITE_DISTANCE;
  else {
    if (d1 <= INFINITE_DISTANCE - d2) return d1 + d2;
    else return INFINITE_DISTANCE;
  }
}
d222 1
a222 1
RegCharEncoding RegDefaultCharCode = REGCODE_DEFAULT;
d367 1
a367 1
/* bytes buffer */
d457 40
a496 40
#define N_EMPTY        (1<<  0)
#define N_LIST         (1<<  1)
#define N_ALT          (1<<  2)
#define N_STRING       (1<<  3)
#define N_STRING_RAW   (1<<  4)  /* immediate bytes (backslashed-number) */
#define N_CCLASS       (1<<  5)
#define N_CTYPE        (1<<  6)
#define N_ANYCHAR      (1<<  7)
#define N_ANCHOR       (1<<  8)
#define N_BACKREF      (1<<  9)
#define N_QUALIFIER    (1<< 10)
#define N_OPTION       (1<< 11)
#define N_EFFECT       (1<< 12)

#define NTYPE(node)        ((node)->type)
#define NCONS(node)        ((node)->u.cons)
#define NSTRING(node)      ((node)->u.str)
#define NCCLASS(node)      ((node)->u.cclass)
#define NCTYPE(node)       ((node)->u.ctype)
#define NQUALIFIER(node)   ((node)->u.qualifier)
#define NANCHOR(node)      ((node)->u.anchor)
#define NBACKREF(node)     ((node)->u.effect)
#define NOPTION(node)      ((node)->u.opt)
#define NEFFECT(node)      ((node)->u.effect)

#define CTYPE_WORD              (1<<0)
#define CTYPE_NOT_WORD          (1<<1)
#define CTYPE_WORD_BOUND        (1<<2)
#define CTYPE_NOT_WORD_BOUND    (1<<3)
#define CTYPE_WORD_BEGIN        (1<<4)
#define CTYPE_WORD_END          (1<<5)

#define ANCHOR_BEGIN_BUF        (1<<0)
#define ANCHOR_BEGIN_LINE       (1<<1)
#define ANCHOR_BEGIN_POSITION   (1<<2)
#define ANCHOR_END_BUF          (1<<3)
#define ANCHOR_SEMI_END_BUF     (1<<4)
#define ANCHOR_END_LINE         (1<<5)
#define ANCHOR_ANYCHAR_STAR     (1<<6)   /* ".*" optimize info */
#define ANCHOR_ANYCHAR_STAR_PL  (1<<7)   /* ".*" optimize info (posix-line) */
d501 4
a504 6
#define EFFECT_MEMORY           (1<<0)
#define EFFECT_PREC_READ        (1<<1)
#define EFFECT_PREC_READ_NOT    (1<<2)
#define EFFECT_STOP_BACKTRACK   (1<<3)
#define EFFECT_LOOK_BEHIND      (1<<4)
#define EFFECT_LOOK_BEHIND_NOT  (1<<5)
a567 2
#define PEND_VALUE  -1

d570 2
a571 3
#define PINC        p++
#define PPEEK       (p < end ? *p : PEND_VALUE)
#define PEND        (p < end ?  0 : 1)
d576 3
a578 3
#define ismb(code,c)             (mblen((code),(c)) != 1)
#define MB2WC(p,end,code)        mb2wc((p),(end),(code))
#define MBBACK(code,start,s,n)   StepBackwardChar((code),(start),(s),(n))
d582 2
a583 1
#define MB2WC_AVAILABLE(enc)          1
d619 22
a640 1
#define mb2wc(p,e,enc)        m17n_codepoint((enc),(p),(e))
d738 1
a738 1
static int MbMaxlen(RegCharEncoding code)
d786 1
a786 1
static WCInt mb2wc(UChar* p, UChar* end, RegCharEncoding code)
d828 1
a828 1
static UChar* GetLeftAdjustCharHead(RegCharEncoding code,
d877 1
a877 1
static UChar* GetRightAdjustCharHead(RegCharEncoding code, UChar* start,
d888 1
a888 1
static UChar* GetRightAdjustCharHeadWithPrev(RegCharEncoding code,
d903 1
a903 1
static UChar* GetPrevCharHead(RegCharEncoding code, UChar* start, UChar* s)
a910 39
static UChar* StepBackwardChar(RegCharEncoding code, UChar* start,
			       UChar* s, int n)
{
  while (IS_NOT_NULL(s) && n-- > 0) {
    if (s <= start)
      return (UChar* )NULL;

    s = GetLeftAdjustCharHead(code, start, s - 1);
  }
  return s;
}

/* used as function pointer value */
static int IsCodeAscii(RegCharEncoding code, UChar c)
 { return IS_CODE_ASCII(code, c); }
static int IsCodeGraph(RegCharEncoding code, UChar c)
 { return IS_CODE_GRAPH(code, c); }
static int IsCodePrint(RegCharEncoding code, UChar c)
 { return IS_CODE_PRINT(code, c); }
static int IsCodeAlnum(RegCharEncoding code, UChar c)
 { return IS_CODE_ALNUM(code, c); }
static int IsCodeAlpha(RegCharEncoding code, UChar c)
 { return IS_CODE_ALPHA(code, c); }
static int IsCodeLower(RegCharEncoding code, UChar c)
 { return IS_CODE_LOWER(code, c); }
static int IsCodeUpper(RegCharEncoding code, UChar c)
 { return IS_CODE_UPPER(code, c); }
static int IsCodeCntrl(RegCharEncoding code, UChar c)
 { return IS_CODE_CNTRL(code, c); }
static int IsCodePunct(RegCharEncoding code, UChar c)
 { return IS_CODE_PUNCT(code, c); }
static int IsCodeSpace(RegCharEncoding code, UChar c)
 { return IS_CODE_SPACE(code, c); }
static int IsCodeBlank(RegCharEncoding code, UChar c)
 { return IS_CODE_BLANK(code, c); }
static int IsCodeDigit(RegCharEncoding code, UChar c)
 { return IS_CODE_DIGIT(code, c); }
static int IsCodeXdigit(RegCharEncoding code, UChar c)
 { return IS_CODE_XDIGIT(code, c); }
d920 1
d992 1
a992 1
#ifdef USE_RECYCLE_NODE
d1039 1
a1039 1
#ifdef USE_RECYCLE_NODE
d1056 1
a1056 1
#ifdef USE_RECYCLE_NODE
d1258 1
a1258 1
static Node* StrNodeSplitLastChar(StrNode* sn, int type, RegCharEncoding code)
d1279 1
a1279 1
  RegCharEncoding code;
d1487 1
a1487 1
static int addMultiByteRange(BBuf** pbuf, RegCharEncoding code,
d1503 1
a1503 1
					  RegCharEncoding code,
d1820 1
a1820 1
				    RegCharEncoding code, Node* node, int* num)
a1900 24

static void BitSetByPredFunc(BitSetRef bs, int (*pf)(RegCharEncoding, UChar),
			     RegCharEncoding code, int not)
{
  int c;

  if (not) {
    for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
      if (! pf(code,c)) BITSET_SET_BIT(bs, c);
    }
  }
  else {
    for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
      if (pf(code,c)) BITSET_SET_BIT(bs, c);
    }
  }
}

typedef struct {
  UChar *name;
  int (*pf)(RegCharEncoding, UChar);
  short int len;
} PosixBracketEntryType;

d1902 1
a1902 1
				     RegCharEncoding code, Node* node)
a1903 2
#define POSIX_BRACKET_CHECK_LIMIT_LENGTH  16

d1908 13
d1922 1
a1922 1
  int not = 0;
a1923 1
  PosixBracketEntryType *pbsp;
d1925 1
a1925 16
  static PosixBracketEntryType PBS[] = {
    { "alnum",  IsCodeAlnum,  5 },
    { "alpha",  IsCodeAlpha,  5 },
    { "blank",  IsCodeBlank,  5 },
    { "cntrl",  IsCodeCntrl,  5 },
    { "digit",  IsCodeDigit,  5 },
    { "graph",  IsCodeGraph,  5 },
    { "lower",  IsCodeLower,  5 },
    { "print",  IsCodePrint,  5 },
    { "punct",  IsCodePunct,  5 },
    { "space",  IsCodeSpace,  5 },
    { "upper",  IsCodeUpper,  5 },
    { "xdigit", IsCodeXdigit, 6 },
    { "ascii",  IsCodeAscii,  5 }, /* I don't know origin. Perl? */
    { (UChar* )NULL, IsCodeAlnum, 0 }
  };
a1926 1
  bs = NCCLASS(node).bs;
d1929 1
a1929 1
    PINC;
d1933 1
a1933 1
    goto check_bracket_end;
d1935 64
a1998 7
  for (pbsp = PBS; IS_NOT_NULL(pbsp->name); pbsp++) {
    if (Strncmp(p, pbsp->name, pbsp->len) == 0) {
      p += pbsp->len;
      CHECK_POSIX_BRACKET_END;
      BitSetByPredFunc(bs, pbsp->pf, code, not);
      break;
    }
d2000 2
a2001 14

  if (IS_NULL(pbsp->name)) {
    int i, c;

  check_bracket_end:
    i = 0;
    while ((c = PPEEK) != PEND_VALUE && c != ':' && c != ']') {
      PINC;
      if (++i > POSIX_BRACKET_CHECK_LIMIT_LENGTH) break;
    }
    if (c == ':' && *(p+1) == ']')
      return REGERR_INVALID_POSIX_BRACKET_TYPE;
    else
      return 1;   /* 1: is not POSIX bracket, but no error. */
d2009 1
a2009 1
static int scanCharClass(UChar** src, UChar* end, RegCharEncoding code,
d2147 3
a2149 3
      if (PPEEK == '-') {
	PINC;
	if (PPEEK != ']' && last_val != -1)
d2151 1
a2151 2
	else
	  BITSET_SET_BIT(NCCLASS(node).bs, '-');
d2153 1
d2216 1
a2216 4
#define NOT_TERM         ((UChar )0)

static int ScanMakeNode(UChar** src, UChar* end, UChar term, ScanEnv* env,
			Node** rnode)
d2225 1
a2225 3
  if (PEND) {
    r = SC_END; goto end;
  }
a2226 5
  if (c == term && term != NOT_TERM) {
    PUNFETCH;
    r = SC_END; goto end;
  }

d2265 1
a2265 1
    /* check double repeat '**', '+*' etc. */
a2360 1
 end:
d2365 3
a2367 2
static int ScanMakeTree(UChar** src, UChar* end, UChar term, ScanEnv* env,
			Node** top);
d2369 1
a2369 1
#define ONOFF(v,f,negative)    (negative) ? ((v) &= ~(f)) : ((v) |= (f))
d2371 2
a2372 2
static int ScanMakeParen(UChar** src, UChar* end, UChar term, ScanEnv* env,
			 Node** top, int *last_is_group)
d2376 1
a2376 1
  int c, type, csub, mem, pnest;
a2402 6
    case '<':   /* look behind (?<=...), (?<!...) */
      PFETCH(csub);
      if (csub != '=' && csub != '!')
	return REGERR_UNDEFINED_GROUP_OPTION;
      break;

d2460 1
a2460 1
      type = ScanMakeTree(&p, end, term, env, top);
d2471 1
a2471 1
      type = ScanMakeTree(&p, end, term, env, &curr);
d2486 1
a2486 1
  type = ScanMakeTree(&p, end, term, env, &curr);
a2511 9

  case '<':
    {
      int etype;
      etype = (csub == '=' ? EFFECT_LOOK_BEHIND : EFFECT_LOOK_BEHIND_NOT);
      *top = NodeNewEffect(etype);
      CHECK_NULL_RETURN_VAL(*top, REGERR_MEMORY);
    }
    break;
d2519 1
a2519 2
static int ScanMakeTree(UChar** src, UChar* end, UChar term, ScanEnv* env,
			Node** top)
d2522 1
a2522 1
  int last_is_group = 0;   /* "(?:...)" */
d2530 1
a2530 1
    type = ScanMakeNode(src, end, term, env, &curr);
d2555 1
a2555 1
	return REGERR_TARGET_OF_REPEAT_QUALIFIER_NOT_SPECIFIED;
d2561 1
d2563 1
a2563 1
    concat:
d2587 1
a2587 1
	type = ScanMakeTree(src, end, term, env, &(NCONS(*top).right));
d2596 1
a2596 1
      type = ScanMakeParen(src, end, NOT_TERM, env, &curr, &last_is_group);
d2598 1
a2598 1
	goto concat;
d2603 1
a2603 1
	type = ScanMakeTree(src, end, ')', env, &(NOPTION(curr).target));
d2605 1
a2605 1
	goto concat;
d2647 1
a2647 1
  r = ScanMakeTree(&p, end, NOT_TERM, &env, root);
d2655 1
a2655 2
  OP_FINISH = 0,        /* matching process terminator (no more alternative) */
  OP_END    = 1,        /* pattern code terminator (success end) */
d2657 1
a2657 1
  OP_EXACT1 = 2,        /* single byte, N = 1 */
d2669 2
a2670 3

  OP_EXACT1_IC,         /* single bye, N = 1, ignore case */
  OP_EXACTN_IC,         /* single bye,        ignore case */
d2719 6
a2724 9
  OP_PUSH_POS,             /* (?=...)  start */
  OP_POP_POS,              /* (?=...)  end   */
  OP_PUSH_POS_NOT,         /* (?!...)  start */
  OP_FAIL_POS,             /* (?!...)  end   */
  OP_PUSH_STOP_BT,         /* (?>...)  start */
  OP_POP_STOP_BT,          /* (?>...)  end   */
  OP_LOOK_BEHIND,          /* (?<=...) start (no needs end opcode) */
  OP_PUSH_LOOK_BEHIND_NOT, /* (?<!...) start */
  OP_FAIL_LOOK_BEHIND_NOT  /* (?<!...) end   */
a2735 3
#define INVALID_STACK_INDEX   -1
typedef int  StackIndex;

d2740 1
a2740 1
      UChar *pcode;      /* byte code position */
d2745 1
a2745 1
      UChar *pcode;      /* byte code position (head of repeated target) */
d2751 1
a2751 1
      StackIndex si;     /* index of stack */
d2754 2
a2755 2
      int num;           /* memory num */
      UChar *pstr;       /* start/end position */
d2757 2
a2758 2
      StackIndex start;  /* prev. info (for backtrack  "(...)*" ) */
      StackIndex end;    /* prev. info (for backtrack  "(...)*" ) */
a2836 3
#define SIZE_OP_LOOK_BEHIND          (SIZE_OPCODE + SIZE_LENGTH)
#define SIZE_OP_PUSH_LOOK_BEHIND_NOT (SIZE_OPCODE + SIZE_RELADDR + SIZE_LENGTH)
#define SIZE_OP_FAIL_LOOK_BEHIND_NOT  SIZE_OPCODE
d2840 1
a2840 1
    (op) == OP_EXACTMB4N || (op) == OP_EXACTMBN  || (op) == OP_EXACTN_IC)
d2917 1
a2917 1
static int selectStrOpCode(int mb_len, int str_len, int ignore_case)
d2923 7
a2929 15
    if (ignore_case) {
      switch (str_len) {
      case 1:  op = OP_EXACT1_IC; break;
      default: op = OP_EXACTN_IC; break;
      }
    }
    else {
      switch (str_len) {
      case 1:  op = OP_EXACT1; break;
      case 2:  op = OP_EXACT2; break;
      case 3:  op = OP_EXACT3; break;
      case 4:  op = OP_EXACT4; break;
      case 5:  op = OP_EXACT5; break;
      default: op = OP_EXACTN; break;
      }
d2990 1
a2990 2
static int addCompileStringLength(UChar* s, int mb_len, int str_len,
				  regex_t* reg)
d2993 1
a2993 1
  int op = selectStrOpCode(mb_len, str_len, IS_IGNORECASE(reg->options));
d3008 1
a3008 1
  int op = selectStrOpCode(mb_len, str_len, IS_IGNORECASE(reg->options));
d3025 1
a3025 1
  RegCharEncoding code = reg->code;
d3044 1
d3054 1
a3061 1
  RegOptionType option;
d3066 5
a3070 5
  option = reg->options;
  REG_OPTION_OFF(reg->options, REG_OPTION_IGNORECASE);
  len = addCompileStringLength(sn->s, 1 /* sb */, sn->end - sn->s, reg);
  reg->options = option;
  return len;
d3076 1
a3076 1
  RegCharEncoding code = reg->code;
d3107 1
a3107 2
  int r;
  RegOptionType option;
d3112 12
a3123 5
  option = reg->options;
  REG_OPTION_OFF(reg->options, REG_OPTION_IGNORECASE);
  r = addCompileString(sn->s, 1 /* sb */, sn->end - sn->s, reg);
  reg->options = option;
  return r;
d3356 2
a3357 2
  int tlen;
  RegOptionType prev = reg->options;
d3359 1
a3359 3
  reg->options = node->option;
  tlen = compileLengthTree(node->target, reg);
  reg->options = prev;
d3361 2
a3362 1
  if (tlen < 0) return tlen;
d3364 1
a3364 2
  return SIZE_OP_SET_OPTION_PUSH + SIZE_OP_SET_OPTION + SIZE_OP_FAIL
         + tlen + SIZE_OP_SET_OPTION;
a3413 6
  case EFFECT_LOOK_BEHIND:
    len = SIZE_OP_LOOK_BEHIND + tlen;
    break;
  case EFFECT_LOOK_BEHIND_NOT:
    len = SIZE_OP_PUSH_LOOK_BEHIND_NOT + tlen + SIZE_OP_FAIL_LOOK_BEHIND_NOT;
    break;
a3418 2
static int getCharLengthTree(Node* node, regex_t* reg, RegDistance* len);

d3442 2
a3467 30

  case EFFECT_LOOK_BEHIND:
    {
      RegDistance n;
      r = AddOpCode(reg, OP_LOOK_BEHIND);
      if (r) return r;
      r = getCharLengthTree(node->target, reg, &n);
      if (r) return REGERR_INVALID_LOOK_BEHIND_PATTERN;
      r = AddLength(reg, (int )n);
      if (r) return r;
      r = compileTree(node->target, reg);
    }
    break;

  case EFFECT_LOOK_BEHIND_NOT:
    {
      RegDistance n;
      len = compileLengthTree(node->target, reg);
      r = AddOpCodeRelAddr(reg, OP_PUSH_LOOK_BEHIND_NOT,
			   len + SIZE_OP_FAIL_LOOK_BEHIND_NOT);
      if (r) return r;
      r = getCharLengthTree(node->target, reg, &n);
      if (r) return REGERR_INVALID_LOOK_BEHIND_PATTERN;
      r = AddLength(reg, (int )n);
      if (r) return r;
      r = compileTree(node->target, reg);
      if (r) return r;
      r = AddOpCode(reg, OP_FAIL_LOOK_BEHIND_NOT);
    }
    break;
d3699 1
a3699 1
      if (r == 0 && *min > tmin) *min = tmin;
d3735 1
a3735 1
	  *min = DistanceMultiply(*min, qn->lower);
a3755 102
      case EFFECT_LOOK_BEHIND:
      case EFFECT_LOOK_BEHIND_NOT:
	break;
      }
    }
    break;

  default:
    break;
  }

  return r;
}

static int getMaxMatchLength(Node* node, regex_t* reg, RegDistance *max)
{
  RegDistance tmax;
  int r = 0;

  *max = 0;
  switch (NTYPE(node)) {
  case N_EMPTY:
  case N_ANCHOR:
    break;

  case N_LIST:
    do {
      r = getMaxMatchLength(NCONS(node).left, reg, &tmax);
      if (r == 0)
	*max = DistanceAdd(*max, tmax);
    } while (r == 0 && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_ALT:
    do {
      r = getMaxMatchLength(NCONS(node).left, reg, &tmax);
      if (r == 0 && *max < tmax) *max = tmax;
    } while (r == 0 && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_STRING:
  case N_STRING_RAW:
    {
      StrNode* sn = &(NSTRING(node));
      *max = sn->end - sn->s;
    }
    break;

  case N_CTYPE:
    switch (NCTYPE(node).type) {
    case CTYPE_WORD:
    case CTYPE_NOT_WORD:
      *max = mbmaxlen_dist(reg->code);
      break;

    default:
      break;
    }
    break;

  case N_CCLASS:
  case N_ANYCHAR:
    *max = mbmaxlen_dist(reg->code);
    break;

  case N_BACKREF:
    *max = INFINITE_DISTANCE;
    break;

  case N_QUALIFIER:
    {
      QualifierNode* qn = &(NQUALIFIER(node));

      if (qn->upper != 0) {
	r = getMaxMatchLength(qn->target, reg, max);
	if (r == 0 && *max != 0) {
	  if (! IS_REPEAT_INFINITE(qn->upper))
	    *max = DistanceMultiply(*max, qn->upper);
	  else
	    *max = INFINITE_DISTANCE;
	}
      }
    }
    break;

  case N_OPTION:
    r = getMaxMatchLength(NOPTION(node).target, reg, max);
    break;

  case N_EFFECT:
    {
      EffectNode* en = &(NEFFECT(node));
      switch (en->type) {
      case EFFECT_MEMORY:
      case EFFECT_STOP_BACKTRACK:
	r = getMaxMatchLength(en->target, reg, max);
	break;

      case EFFECT_PREC_READ:
      case EFFECT_PREC_READ_NOT:
      case EFFECT_LOOK_BEHIND:
      case EFFECT_LOOK_BEHIND_NOT:
a3767 76
/* fixed size pattern node only */
static int getCharLengthTree(Node* node, regex_t* reg, RegDistance* len)
{
  RegDistance tlen;
  int r = 0;

  *len = 0;
  switch (NTYPE(node)) {
  case N_EMPTY:
  case N_ANCHOR:
    break;

  case N_LIST:
    do {
      r = getCharLengthTree(NCONS(node).left, reg, &tlen);
      if (r == 0)
	*len = DistanceAdd(*len, tlen);
    } while (r == 0 && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_STRING:
  case N_STRING_RAW:
    {
      StrNode* sn = &(NSTRING(node));
      UChar *s = sn->s;
      while (s < sn->end) {
	s += mblen(reg->code, *s);
	(*len)++;
      }
    }
    break;

  case N_CTYPE:
    switch (NCTYPE(node).type) {
    case CTYPE_WORD:
    case CTYPE_NOT_WORD:
      *len = 1;
      break;
    }
    break;

  case N_CCLASS:
  case N_ANYCHAR:
    *len = 1;
    break;

  case N_OPTION:
    r = getCharLengthTree(NOPTION(node).target, reg, len);
    break;

  case N_EFFECT:
    {
      EffectNode* en = &(NEFFECT(node));
      switch (en->type) {
      case EFFECT_MEMORY:
      case EFFECT_STOP_BACKTRACK:
	r = getCharLengthTree(en->target, reg, len);
	break;

      case EFFECT_PREC_READ:
      case EFFECT_PREC_READ_NOT:
      case EFFECT_LOOK_BEHIND:
      case EFFECT_LOOK_BEHIND_NOT:
	break;
      }
    }
    break;

  default:
    r = -1;
    break;
  }

  return r;
}

d3830 3
a3832 46
      case EFFECT_PREC_READ_NOT:
      case EFFECT_LOOK_BEHIND:
      case EFFECT_LOOK_BEHIND_NOT:
	break;
      }
    }
    break;

  default:
    break;
  }

  return n;
}

static int checkTypeTree(Node* node, int type_mask,
			 int effect_mask, int anchor_mask)
{
  int type, r = 0;

  type = NTYPE(node);
  if ((type & type_mask) == 0)
    return 1;

  switch (type) {
  case N_LIST:
  case N_ALT:
    do {
      r = checkTypeTree(NCONS(node).left, type_mask, effect_mask, anchor_mask);
    } while (r == 0 && IS_NOT_NULL(node = NCONS(node).right));
    break;

  case N_QUALIFIER:
    r = checkTypeTree(NQUALIFIER(node).target, type_mask, effect_mask,
		      anchor_mask);
    break;
  case N_OPTION:
    r = checkTypeTree(NOPTION(node).target, type_mask, effect_mask, anchor_mask);
    break;
  case N_EFFECT:
    {
      EffectNode* en = &(NEFFECT(node));
      if ((en->type & effect_mask) == 0)
	return 1;

      r = checkTypeTree(en->target, type_mask, effect_mask, anchor_mask);
a3835 6
  case N_ANCHOR:
    type = NANCHOR(node).type;
    if ((type & anchor_mask) == 0)
      return 1;
    break;

d3839 2
a3840 1
  return r;
d3843 2
d3846 1
a3846 11

#define IN_ALT   (1<<0)
#define IN_NOT   (1<<1)

/* setupTree settles following tasks.
 1. check empty loop.
 2. expand ignore-case in char class.
 3. set memory status bit flags. (reg->mem_stats)
 4. set qf->head_exact for [push, exact] -> [push_or_jump_exact1, exact].
 5. find invalid patterns in look-behind.
 */
d3900 1
a3900 1
      RegDistance d;
d3904 2
a3905 3
	r = getMinMatchLength(qn->target, &d);
	if (r) break;
	if (d == 0) {
a3909 6
      if (r) break;
      r = getMaxMatchLength(qn->target, reg, &d);
      if (r) break;
      if (d == 0)
	return REGERR_TARGET_OF_REPEAT_QUALIFIER_IS_EMPTY;

d3940 1
a3940 1
	if ((state & IN_ALT) || (state & IN_NOT))
d3948 1
d3950 1
a3950 28
	r = setupTree(en->target, reg, (state | IN_NOT));
	break;

/* allowed node types in look-behind */
#define ALLOWED_TYPE_IN_LB  \
  ( N_EMPTY | N_LIST | N_STRING | N_STRING_RAW | N_CCLASS | N_CTYPE | \
    N_ANYCHAR | N_ANCHOR | N_EFFECT )

#define ALLOWED_EFFECT_IN_LB       ( EFFECT_MEMORY | EFFECT_LOOK_BEHIND_NOT )
#define ALLOWED_EFFECT_IN_LB_NOT   ( EFFECT_MEMORY | EFFECT_LOOK_BEHIND )
#define ALLOWED_ANCHOR_IN_LB       ( ANCHOR_BEGIN_LINE | ANCHOR_END_LINE )
	/* can't allow all anchors, because \G in look-behind throgh Search().
	   ex. /(?<=\G)zz/.match("azz") */

      case EFFECT_LOOK_BEHIND:
	r = checkTypeTree(en->target, ALLOWED_TYPE_IN_LB,
			  ALLOWED_EFFECT_IN_LB, ALLOWED_ANCHOR_IN_LB);
	if (r < 0) return r;
	if (r > 0) return REGERR_INVALID_LOOK_BEHIND_PATTERN;
	r = setupTree(en->target, reg, state);
	break;

      case EFFECT_LOOK_BEHIND_NOT:
	r = checkTypeTree(en->target, ALLOWED_TYPE_IN_LB,
			  ALLOWED_EFFECT_IN_LB_NOT, ALLOWED_ANCHOR_IN_LB);
	if (r < 0) return r;
	if (r > 0) return REGERR_INVALID_LOOK_BEHIND_PATTERN;
	r = setupTree(en->target, reg, (state | IN_NOT));
d3981 1
a3981 1
  RegCharEncoding   code;
d4044 2
a4045 2
  obuf->dmax = DistanceAdd(obuf->dmax, inc_max);
  obuf->dmin = DistanceAdd(obuf->dmin, inc_min);
d4185 1
a4185 1
			   RegCharEncoding code)
d4208 1
a4208 1
static void ExactBufAdd(ExactBuf* buf, ExactBuf* from, RegCharEncoding code)
d4213 1
a4213 1
static void ExactBufIntersect(ExactBuf* to, ExactBuf* from, RegCharEncoding code)
d4285 1
d4320 55
d4722 1
a4722 1
	    obuf->dmax = DistanceAdd(obuf->dmax, (RegDistance)(n * qn->upper));
d4731 1
a4731 1
	  obuf->dmin = DistanceAdd(obuf->dmin, (RegDistance )(n * qn->lower));
a4782 2
      case EFFECT_LOOK_BEHIND: /* Sorry, I can't make use of it. */
      case EFFECT_LOOK_BEHIND_NOT:
d5195 1
a5195 1
	    obuf->dmax = DistanceAdd(obuf->dmax, (RegDistance)(n * qn->upper));
d5204 1
a5204 1
	  obuf->dmin = DistanceAdd(obuf->dmin, (RegDistance)(n * qn->lower));
a5242 2
      case EFFECT_LOOK_BEHIND:
      case EFFECT_LOOK_BEHIND_NOT:
d5297 2
a5298 2
    if (reg->threshold_len < POSITION_SEARCH_MIN_THRESHOLD_LENGTH)
      reg->threshold_len = POSITION_SEARCH_MIN_THRESHOLD_LENGTH;
d5342 2
a5343 2
      if (reg->threshold_len < POSITION_SEARCH_MIN_THRESHOLD_LENGTH)
	reg->threshold_len = POSITION_SEARCH_MIN_THRESHOLD_LENGTH;
d5535 2
a5536 3
#define STK_ALT               1
#define STK_LOOK_BEHIND_NOT   2
#define STK_POS_NOT           3
d5538 3
a5540 3
#define STK_MEM_START         4
#define STK_MEM_END           5
#define STK_REPEAT_INC        6
d5542 5
a5546 5
#define STK_POS               7   /* used when POP-POS */
#define STK_STOP_BT           8   /* mark for stop-backtrack "(?>...)" */
#define STK_REPEAT            9
#define STK_NULL_CHECK_START 10
#define STK_VOID             11   /* for fill a blank */
a5614 3
#define STACK_AT(index)        (stk_base + (index))
#define GET_STACK_INDEX(stk)   ((stk) - stk_base)

d5621 1
a5621 7
  STACK_INC;\
} while(0)

#define STACK_PUSH_TYPE(stack_type) do {\
  STACK_ENSURE(1);\
  stk->type = (stack_type);\
  STACK_INC;\
d5627 2
a5628 3
#define STACK_PUSH_STOP_BT              STACK_PUSH_TYPE(STK_STOP_BT)
#define STACK_PUSH_LOOK_BEHIND_NOT(pat,s,sprev) \
        STACK_PUSH(STK_LOOK_BEHIND_NOT,pat,s,sprev)
d5637 1
a5637 1
  STACK_INC;\
d5640 1
a5640 1
#define STACK_PUSH_REPEAT_INC(sindex) do {\
d5643 2
a5644 2
  stk->u.repeat_inc.si  = (sindex);\
  STACK_INC;\
d5654 3
a5656 3
  mem_start_stk[mnum] = GET_STACK_INDEX(stk);\
  mem_end_stk[mnum]   = INVALID_STACK_INDEX;\
  STACK_INC;\
d5665 2
a5666 2
  mem_end_stk[mnum] = GET_STACK_INDEX(stk);\
  STACK_INC;\
d5674 1
a5674 1
  STACK_INC;\
d5680 1
d5682 9
a5690 6
    else if (stk->type == STK_MEM_START) {\
      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
    }\
    else if (stk->type == STK_MEM_END) {\
      mem_end_stk[stk->u.mem.num] = INVALID_STACK_INDEX;\
d5693 1
a5693 1
      STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\
d5702 1
d5704 9
a5712 6
    else if (stk->type == STK_MEM_END) {\
      mem_end_stk[stk->u.mem.num] = INVALID_STACK_INDEX;\
    }\
    else if (stk->type == STK_MEM_START) {\
      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
d5715 1
a5715 16
      STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\
    }\
  }\
} while(0)

#define STACK_POP_TIL_LOOK_BEHIND_NOT  do {\
  while (1) {\
    stk--;\
    if (stk < stk_base)  goto stack_error;\
    if (stk->type == STK_LOOK_BEHIND_NOT) break;\
    else if (stk->type == STK_MEM_END) {\
      mem_end_stk[stk->u.mem.num] = INVALID_STACK_INDEX;\
    }\
    else if (stk->type == STK_MEM_START) {\
      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
d5724 1
a5724 1
    if (k <= stk_base)  goto stack_error;\
d5739 1
a5739 1
    if (k <= stk_base)  goto stack_error;\
d5790 1
d5796 1
a5796 18

#define USE_TIMEOFDAY

#ifdef USE_TIMEOFDAY
#include <sys/time.h>
#include <unistd.h>
static struct timeval ts, te;
#define GETTIME(t)        gettimeofday(&(t), (struct timezone* )0)
#define TIMEDIFF(te,ts)   (((te).tv_usec - (ts).tv_usec) + \
                           (((te).tv_sec - (ts).tv_sec)*1000000))
#else
#include <sys/times.h>
static struct tms ts, te;
#define GETTIME(t)         times(&(t))
#define TIMEDIFF(te,ts)   ((te).tms_utime - (ts).tms_utime)
#endif

static void PrintStatistics(FILE* f);
a5797 3
static unsigned long OpTime[256];
static int OpCurr;
static int MaxStackDepth = 0;
d5801 1
a5801 4
  for (i = 0; i < 256; i++) {\
    OpCounter[i] = 0; OpTime[i] = 0;\
  }\
  MaxStackDepth = 0;\
d5804 2
a5805 12
#define STATISTICS_PRINT_RESULT  PrintStatistics(stderr)

#define STAT_OP_IN(opcode) do {\
  OpCurr = opcode;\
  OpCounter[opcode]++;\
  GETTIME(ts);\
} while (0)

#define STAT_OP_OUT do {\
  GETTIME(te);\
  OpTime[OpCurr] += TIMEDIFF(te, ts);\
} while (0)
d5808 4
a5811 1
static VALUE regex_stat_print() { STATISTICS_PRINT_RESULT; }
a5812 1
/* You must call Init_REGEX(). (ex. in ruby/inits.c) */
a5818 6
#define STACK_INC do {\
  stk++;\
  if (stk - stk_base > MaxStackDepth) \
    MaxStackDepth = stk - stk_base;\
} while (0)

a5819 2
#define STACK_INC     stk++

a5821 1
#define STAT_OP_OUT
a5829 2
  static UChar FinishCode[] = { OP_FINISH };

d5835 1
a5835 1
  RegCharEncoding encode = reg->code;
d5840 2
a5842 5
  StackType *stk_alloc, *stk_base, *stk, *stk_end;
  StackType *stkp; /* used as any purpose. */
  StackIndex *repeat_stk;
  StackIndex *mem_start_stk, *mem_end_stk;
  n = reg->num_repeat + reg->max_mem * 2;
d5844 4
d5849 1
a5849 3
  ignore_case = IS_IGNORECASE(option);
  max_mem = reg->max_mem;
  repeat_stk = (StackIndex* )alloca_base;
d5851 2
a5852 1
  mem_start_stk = (StackIndex* )(repeat_stk + reg->num_repeat);
d5854 1
a5854 1
  mem_start_stk--; /* for index start from 1,
d5856 1
a5856 1
  mem_end_stk--;   /* for index start from 1,
d5859 1
a5859 1
    mem_start_stk[i] = mem_end_stk[i] = INVALID_STACK_INDEX;
a5868 2
  /* bottom stack: pcode -> OP_FINISH position */
  STACK_PUSH(STK_ALT, FinishCode, NULL_UCHARP, NULL_UCHARP);
d5902 1
a5902 1
	    if (mem_end_stk[i] != INVALID_STACK_INDEX) {
d5904 2
a5905 2
		region->beg[i] = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;
		region->end[i] = STACK_AT(mem_end_stk[i])->u.mem.pstr   - str;
d5908 2
a5909 2
		region->beg[i] = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;
		region->end[i] = (UChar* )((void* )mem_end_stk[i]) - str;
d5913 2
a5914 1
	      region->beg[i] = region->end[i] = -1;
a5918 1
      STAT_OP_OUT;
a5929 1
#if 0
d5931 1
a5931 1
      if (*p != *s) goto fail;
a5932 5
#endif
      if (*p != *s++) goto fail;
      DATA_ENSURE(0);
      p++;
      STAT_OP_OUT;
d5935 1
a5935 2
    case OP_EXACT1_IC:  STAT_OP_IN(OP_EXACT1_IC);
      if (! SBTRANSCMP(*p, *s)) goto fail;
d5937 1
a5938 1
      STAT_OP_OUT;
d5943 3
a5945 2
      if (*p++ != *s++) goto fail;
      if (*p   != *s)   goto fail;
a5947 1
      STAT_OP_OUT;
d5953 16
a5968 6
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      if (*p++ != *s)   goto fail;
      sprev = s;
      s++;
      STAT_OP_OUT;
d5974 19
a5992 7
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      if (*p++ != *s)   goto fail;
      sprev = s;
      s++;
      STAT_OP_OUT;
d5998 22
a6019 8
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      if (*p++ != *s++) goto fail;
      if (*p++ != *s)   goto fail;
      sprev = s;
      s++;
      STAT_OP_OUT;
d6026 1
a6026 3
      while (tlen-- > 0) {
	if (*p++ != *s++) goto fail;
      }
a6027 1
      STAT_OP_OUT;
d6031 1
a6031 1
    case OP_EXACTN_IC:  STAT_OP_IN(OP_EXACTN_IC);
d6035 1
a6035 2
	if (! SBTRANSCMP(*p, *s)) goto fail;
	p++; s++;
a6037 1
      STAT_OP_OUT;
a6044 1
      STAT_OP_OUT;
a6053 1
      STAT_OP_OUT;
a6065 1
      STAT_OP_OUT;
a6076 1
      STAT_OP_OUT;
a6089 1
      STAT_OP_OUT;
a6106 1
      STAT_OP_OUT;
a6114 1
      STAT_OP_OUT;
a6136 1
      STAT_OP_OUT;
a6153 1
      STAT_OP_OUT;
a6160 1
      STAT_OP_OUT;
a6188 1
      STAT_OP_OUT;
a6205 1
      STAT_OP_OUT;
a6222 1
      STAT_OP_OUT;
a6242 1
      STAT_OP_OUT;
a6248 1
      STAT_OP_OUT;
a6254 1
      STAT_OP_OUT;
a6270 1
      STAT_OP_OUT;
a6286 1
      STAT_OP_OUT;
d6293 1
a6293 2
	if (ON_STR_BEGIN(s) || !IS_WORD_STR(encode, sprev, end)) {
	  STAT_OP_OUT;
a6294 1
	}
d6301 1
a6301 2
	if (ON_STR_END(s) || !IS_WORD_STR(encode, s, end)) {
	  STAT_OP_OUT;
a6302 1
	}
a6310 1
      STAT_OP_OUT;
a6316 1
      STAT_OP_OUT;
d6321 1
a6321 2
      if (ON_STR_BEGIN(s)) {
	STAT_OP_OUT;
d6323 1
a6323 3
      }
      else if (IS_NEWLINE(*sprev) && !ON_STR_END(s)) {
	STAT_OP_OUT;
d6325 1
a6325 1
      }
d6331 1
a6331 2
	if (IS_EMPTY_STR || !IS_NEWLINE(*sprev)) {
	  STAT_OP_OUT;
a6332 1
	}
d6334 1
a6334 2
      else if (IS_NEWLINE(*s)) {
	STAT_OP_OUT;
d6336 1
a6336 1
      }
d6342 1
a6342 2
	if (IS_EMPTY_STR || !IS_NEWLINE(*sprev)) {
	  STAT_OP_OUT;
a6343 1
	}
d6345 1
a6345 2
      if (IS_NEWLINE(*s) && ON_STR_END(s+1)) {
	STAT_OP_OUT;
d6347 1
a6347 1
      }
a6354 1
      STAT_OP_OUT;
a6360 1
      STAT_OP_OUT;
a6366 1
      STAT_OP_OUT;
d6372 1
a6372 2
      mem_end_stk[mem] = (StackIndex )((void* )s);
      STAT_OP_OUT;
d6397 1
d6400 5
a6404 7
	if (mem_end_stk[mem] == INVALID_STACK_INDEX) goto fail;

	stkp = STACK_AT(mem_end_stk[mem]);
	if (stkp) {
	  send = stkp->u.mem.pstr;
	  stkp = STACK_AT(stkp->u.mem.start);
	  sstart = stkp->u.mem.pstr;
a6410 2

	  STAT_OP_OUT;
a6421 1
      STAT_OP_OUT;
a6427 1
      STAT_OP_OUT;
a6433 1
      STAT_OP_OUT;
a6463 1
      STAT_OP_OUT;
a6469 1
      STAT_OP_OUT;
a6475 1
      STAT_OP_OUT;
a6483 1
	STAT_OP_OUT;
a6486 1
      STAT_OP_OUT;
d6500 1
a6500 1
	repeat_stk[mem] = GET_STACK_INDEX(stk);
a6506 1
      STAT_OP_OUT;
d6520 1
a6520 1
	repeat_stk[mem] = GET_STACK_INDEX(stk);
a6527 1
      STAT_OP_OUT;
d6533 1
a6533 1
	StackIndex si;
d6536 3
a6538 4
	si = repeat_stk[mem];
	stkp = STACK_AT(si);
	stkp->u.repeat.count++;
	if (stkp->u.repeat.count == stkp->u.repeat.upper) {
d6541 1
a6541 1
	else if (stkp->u.repeat.count >= stkp->u.repeat.lower) {
d6543 1
a6543 1
	  p = stkp->u.repeat.pcode;
d6546 1
a6546 1
	  p = stkp->u.repeat.pcode;
d6548 1
a6548 1
	STACK_PUSH_REPEAT_INC(si);
a6549 1
      STAT_OP_OUT;
d6555 1
a6555 1
	StackIndex si;
d6558 3
a6560 4
	si = repeat_stk[mem];
	stkp = STACK_AT(si);
	stkp->u.repeat.count++;
	if (stkp->u.repeat.count == stkp->u.repeat.upper) {
d6563 2
a6564 2
	else if (stkp->u.repeat.count >= stkp->u.repeat.lower) {
	  STACK_PUSH_ALT(stkp->u.repeat.pcode, s, sprev);
d6567 1
a6567 1
	  p = stkp->u.repeat.pcode;
d6569 1
a6569 1
	STACK_PUSH_REPEAT_INC(si);
a6570 1
      STAT_OP_OUT;
a6575 1
      STAT_OP_OUT;
d6581 5
a6585 3
	STACK_POS_END(stkp);
	s     = stkp->u.state.pstr;
	sprev = stkp->u.state.pstr_prev;
a6586 1
      STAT_OP_OUT;
a6592 1
      STAT_OP_OUT;
a6602 1
      STAT_OP_OUT;
a6607 1
      STAT_OP_OUT;
d6611 1
a6611 37
    case OP_LOOK_BEHIND:  STAT_OP_IN(OP_LOOK_BEHIND);
      GET_LENGTH_INC(tlen, p);
      s = MBBACK(encode, str, s, (int )tlen);
      if (IS_NULL(s)) goto fail;
      sprev = GetPrevCharHead(encode, str, s);
      STAT_OP_OUT;
      continue;
      break;

    case OP_PUSH_LOOK_BEHIND_NOT:  STAT_OP_IN(OP_PUSH_LOOK_BEHIND_NOT);
      GET_RELADDR_INC(addr, p);
      GET_LENGTH_INC(tlen, p);
      q = MBBACK(encode, str, s, (int )tlen);
      if (IS_NULL(q)) {
	/* I decided to too short case -> fail. ex. /(?<!XXX)a/.match("a")
	   If you want to change to success, replace following line. */
	goto fail;
	/* p += addr; */
      }
      else {
	STACK_PUSH_LOOK_BEHIND_NOT(p + addr, s, sprev);
	s = q;
	sprev = GetPrevCharHead(encode, str, s);
      }
      STAT_OP_OUT;
      continue;
      break;

    case OP_FAIL_LOOK_BEHIND_NOT:  STAT_OP_IN(OP_FAIL_LOOK_BEHIND_NOT);
      STACK_POP_TIL_LOOK_BEHIND_NOT;
      goto fail;
      break;

    case OP_FINISH:
      goto finish;
      break;

a6612 2
      STAT_OP_OUT;
    case OP_FAIL:
d6614 1
a6614 2

      STACK_POP;
a6617 1
      STAT_OP_OUT;
d6664 1
a6664 1
static UChar* SlowSearch(RegCharEncoding code,
d6694 1
a6694 1
static int StrTransMatchAfterHeadByte(RegCharEncoding code, UChar* trans,
d6728 1
a6728 1
static UChar* SlowSearchIC(RegCharEncoding code, UChar* transtable,
d6755 1
a6755 1
static UChar* SlowSearchBackward(RegCharEncoding code,
d6785 1
a6785 1
static UChar* SlowSearchBackwardIC(RegCharEncoding code, UChar* transtable,
d6892 1
a6892 1
    s--; /* set to text check tail position. */
d6987 1
a6987 1
static UChar* MapSearch(RegCharEncoding code, UChar map[],
d7000 1
a7000 1
static UChar* MapSearchBackward(RegCharEncoding code, UChar map[],
d7041 3
a7043 2
  fprintf(stderr, "ForwardSearchRange: str: %d, end: %d, s: %d, range: %d\n",
	  (int )str, (int )end, (int )s, (int )range);
d7090 2
a7091 6
	if (ON_STR_END(p)) {
	  prev = GetPrevCharHead(reg->code, (pprev ? pprev : str), p);
	  if (prev && IS_NEWLINE(*prev))
	    goto retry_gate;
	}
	else if (!IS_NEWLINE(*p))
d7193 4
a7196 11
	if (ON_STR_END(p)) {
	  prev = GetPrevCharHead(reg->code, adjrange, p);
	  if (IS_NULL(prev)) goto fail;
	  if (IS_NEWLINE(*prev)) {
	    p = prev;
	    goto retry;
	  }
	}
	else if (!IS_NEWLINE(*p)) {
	  p = GetPrevCharHead(reg->code, adjrange, p);
	  if (IS_NULL(p)) goto fail;
d7266 1
d7269 1
d7305 1
a7552 4
#ifdef REG_DEBUG_PARSE_TREE
static void PrintTree(FILE* f, Node* node);
#endif

a7585 4
#ifdef REG_DEBUG_PARSE_TREE
  PrintTree(stderr, root);
#endif

a7586 6
  if (r) {
    NodeFree(root);
    goto end;
  }

  r = compileTree(root, reg);
d7588 1
a7588 1
    r = AddOpCode(reg, OP_END);
d7590 3
a7592 1
      ClearOptimizeInfo(reg);
d7594 1
a7594 1
      r = SetOptimizeInfoFromTree(root, reg);
d7596 1
d7610 1
a7610 1
	      RegOptionType option, RegCharEncoding code, UChar* transtable)
d7661 1
a7661 1
		  RegCharEncoding code, UChar* transtable)
d7699 1
a7699 1
	     RegOptionType option, RegCharEncoding code, UChar* transtable)
d7757 1
a7757 1
#ifdef USE_RECYCLE_NODE
d7781 49
a7829 48
  { OP_FINISH,            "finish",          ARG_NON },
  { OP_END,               "end",             ARG_NON },
  { OP_EXACT1,            "exact1",          ARG_SPECIAL },
  { OP_EXACT2,            "exact2",          ARG_SPECIAL },
  { OP_EXACT3,            "exact3",          ARG_SPECIAL },
  { OP_EXACT4,            "exact4",          ARG_SPECIAL },
  { OP_EXACT5,            "exact5",          ARG_SPECIAL },
  { OP_EXACTN,            "exactn",          ARG_SPECIAL },
  { OP_EXACTMB2N1,        "exactmb2-n1",     ARG_SPECIAL },
  { OP_EXACTMB2N2,        "exactmb2-n2",     ARG_SPECIAL },
  { OP_EXACTMB2N3,        "exactmb2-n3",     ARG_SPECIAL },
  { OP_EXACTMB2N,         "exactmb2-n",      ARG_SPECIAL },
  { OP_EXACTMB4N,         "exactmb4n"  ,     ARG_SPECIAL },
  { OP_EXACTMBN,          "exactmbn",        ARG_SPECIAL },
  { OP_EXACT1_IC,         "exact1-ic",       ARG_SPECIAL },
  { OP_EXACTN_IC,         "exactn-ic",       ARG_SPECIAL },
  { OP_CCLASS,            "cclass",          ARG_SPECIAL },
  { OP_CCLASS_MB,         "cclass-mb",       ARG_SPECIAL },
  { OP_CCLASS_MIX,        "cclass-mix",      ARG_SPECIAL },
  { OP_CCLASS_NOT,        "cclass-not",      ARG_SPECIAL },
  { OP_CCLASS_MB_NOT,     "cclass-mb-not",   ARG_SPECIAL },
  { OP_CCLASS_MIX_NOT,    "cclass-mix-not",  ARG_SPECIAL },
  { OP_ANYCHAR,           "anychar",         ARG_NON },
  { OP_ANYCHAR_STAR,      "anychar*",        ARG_NON },
  { OP_WORD,              "word",            ARG_NON },
  { OP_NOT_WORD,          "not-word",        ARG_NON },
  { OP_WORD_BOUND,        "word-bound",      ARG_NON },
  { OP_NOT_WORD_BOUND,    "not-word-bound",  ARG_NON },
  { OP_WORD_BEGIN,        "word-begin",      ARG_NON },
  { OP_WORD_END,          "word-end",        ARG_NON },
  { OP_BEGIN_BUF,         "begin-buf",       ARG_NON },
  { OP_END_BUF,           "end-buf",         ARG_NON },
  { OP_BEGIN_LINE,        "begin-line",      ARG_NON },
  { OP_END_LINE,          "end-line",        ARG_NON },
  { OP_SEMI_END_BUF,      "semi-end-buf",    ARG_NON },
  { OP_BEGIN_POSITION,    "begin-position",  ARG_NON },
  { OP_BACKREF1,          "backref1",        ARG_NON },
  { OP_BACKREF2,          "backref2",        ARG_NON },
  { OP_BACKREF3,          "backref3",        ARG_NON },
  { OP_BACKREFN,          "backrefn",        ARG_MEMNUM  },
  { OP_MEMORY_START_PUSH, "mem-start_push",  ARG_MEMNUM  },
  { OP_MEMORY_END_PUSH,   "mem-end_push",    ARG_MEMNUM  },
  { OP_MEMORY_END,        "mem-end",         ARG_MEMNUM  },
  { OP_SET_OPTION_PUSH,   "set-option-push", ARG_OPTION  },
  { OP_SET_OPTION,        "set-option",      ARG_OPTION  },
  { OP_FAIL,              "fail",            ARG_NON },
  { OP_JUMP,              "jump",            ARG_RELADDR },
  { OP_PUSH,              "push",            ARG_RELADDR },
d7831 13
a7843 16
  { OP_REPEAT,            "repeat",          ARG_SPECIAL },
  { OP_REPEAT_NG,         "repeat-ng",       ARG_SPECIAL },
  { OP_REPEAT_INC,        "repeat-inc",      ARG_MEMNUM  },
  { OP_REPEAT_INC_NG,     "repeat-inx-ng",   ARG_MEMNUM  },
  { OP_NULL_CHECK_START,  "null-check-start",ARG_MEMNUM  },
  { OP_NULL_CHECK_END,    "null-check-end",  ARG_MEMNUM  },
  { OP_PUSH_POS,          "push-pos",        ARG_NON },
  { OP_POP_POS,           "pop-pos",         ARG_NON },
  { OP_PUSH_POS_NOT,      "push-pos-not",    ARG_RELADDR },
  { OP_FAIL_POS,          "fail-pos",        ARG_NON },
  { OP_PUSH_STOP_BT,      "push-stop-bt",    ARG_NON },
  { OP_POP_STOP_BT,       "pop-stop-bt",     ARG_NON },
  { OP_LOOK_BEHIND,       "look-behind",     ARG_SPECIAL },
  { OP_PUSH_LOOK_BEHIND_NOT, "push-look-behind-not", ARG_SPECIAL },
  { OP_FAIL_LOOK_BEHIND_NOT, "fail-look-behind-not", ARG_NON }, 
  { -1, "", ARG_NON }
d7984 1
a7984 1
    case OP_EXACT1_IC:
d7987 1
a7987 1
    case OP_EXACTN_IC:
a8062 11
    case OP_LOOK_BEHIND:
      GET_LENGTH_INC(len, bp);
      fprintf(f, ":%d", len);
      break;

    case OP_PUSH_LOOK_BEHIND_NOT:
      GET_RELADDR_INC(addr, bp);
      GET_LENGTH_INC(len, bp);
      fprintf(f, ":%d:(%d)", len, addr);
      break;

d8111 1
d8133 1
a8148 1
#if 0
a8152 1
#endif
d8194 1
d8201 1
d8206 1
d8213 3
a8215 5
    case EFFECT_PREC_READ:       fputs("prec read",      f); break;
    case EFFECT_PREC_READ_NOT:   fputs("prec read not",  f); break;
    case EFFECT_STOP_BACKTRACK:  fputs("stop backtrack", f); break;
    case EFFECT_LOOK_BEHIND:     fputs("look_behind",    f); break;
    case EFFECT_LOOK_BEHIND_NOT: fputs("look_behind_not",f); break;
a8238 2
#endif /* REG_DEBUG */

d8240 1
a8240 1
static void PrintStatistics(FILE* f)
d8244 1
a8244 1
    fprintf(f, "%8d; %10d: %s\n", OpCounter[i], OpTime[i], OpInfo[i].name);
a8245 1
  fprintf(f, "\nmax stack depth: %d\n", MaxStackDepth);
d8248 2
@


1.1.1.3
log
@Import Oni Guruma 20020306.
@
text
@a60 4
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

d80 1
a80 2
extern char*
RegexErrorCodeToStr(int code)
d203 1
a203 2
static RegDistance
DistanceAdd(RegDistance d1, RegDistance d2)
d213 1
a213 2
static RegDistance
DistanceMultiply(RegDistance d, int m)
d221 1
a221 2
static RegDistance
DistanceDistance(RegDistance d1, RegDistance d2)
d346 2
a347 2
#define BS_ROOM(bs,pos)            (bs)[pos / BITS_IN_ROOM]
#define BS_BIT(pos)                (1 << (pos % BITS_IN_ROOM))
d349 3
a351 3
#define BITSET_AT(bs, pos)         (BS_ROOM(bs,pos) & BS_BIT(pos))
#define BITSET_SET_BIT(bs, pos)     BS_ROOM(bs,pos) |= BS_BIT(pos)
#define BITSET_CLEAR_BIT(bs, pos)   BS_ROOM(bs,pos) &= ~(BS_BIT(pos))
d355 1
a355 2
static int
BitSetIsEmpty(BitSetRef bs)
d364 1
a364 2
static int
BitSetOnNum(BitSetRef bs)
d383 1
a383 2
static int
BBufInit(BBuf* buf, int size)
d730 1
a730 2
static int
MbMaxlen(RegCharEncoding code)
d778 1
a778 2
static WCInt
mb2wc(UChar* p, UChar* end, RegCharEncoding code)
d820 2
a821 2
static UChar*
GetLeftAdjustCharHead(RegCharEncoding code, UChar* start, UChar* s)
d869 2
a870 2
static UChar*
GetRightAdjustCharHead(RegCharEncoding code, UChar* start, UChar* s)
d880 2
a881 3
static UChar*
GetRightAdjustCharHeadWithPrev(RegCharEncoding code,
			       UChar* start, UChar* s, UChar** prev)
d895 1
a895 2
static UChar*
GetPrevCharHead(RegCharEncoding code, UChar* start, UChar* s)
d903 2
a904 2
static UChar*
StepBackwardChar(RegCharEncoding code, UChar* start, UChar* s, int n)
d916 26
a941 26
static int
IsCodeAscii(RegCharEncoding code, UChar c) { return IS_CODE_ASCII(code, c); }
static int
IsCodeGraph(RegCharEncoding code, UChar c) { return IS_CODE_GRAPH(code, c); }
static int
IsCodePrint(RegCharEncoding code, UChar c) { return IS_CODE_PRINT(code, c); }
static int
IsCodeAlnum(RegCharEncoding code, UChar c) { return IS_CODE_ALNUM(code, c); }
static int
IsCodeAlpha(RegCharEncoding code, UChar c) { return IS_CODE_ALPHA(code, c); }
static int
IsCodeLower(RegCharEncoding code, UChar c) { return IS_CODE_LOWER(code, c); }
static int
IsCodeUpper(RegCharEncoding code, UChar c) { return IS_CODE_UPPER(code, c); }
static int
IsCodeCntrl(RegCharEncoding code, UChar c) { return IS_CODE_CNTRL(code, c); }
static int
IsCodePunct(RegCharEncoding code, UChar c) { return IS_CODE_PUNCT(code, c); }
static int
IsCodeSpace(RegCharEncoding code, UChar c) { return IS_CODE_SPACE(code, c); }
static int
IsCodeBlank(RegCharEncoding code, UChar c) { return IS_CODE_BLANK(code, c); }
static int
IsCodeDigit(RegCharEncoding code, UChar c) { return IS_CODE_DIGIT(code, c); }
static int
IsCodeXdigit(RegCharEncoding code, UChar c) { return IS_CODE_XDIGIT(code, c); }
d943 1
a943 2
static int
Strncmp(UChar* s1, UChar* s2, int n)
d954 1
a954 2
static void
Strcpy(UChar* dest, UChar* src, UChar* end)
d963 1
a963 2
static UChar*
Strdup(UChar* s, UChar* end)
d977 1
a977 3
#if 0
static UChar*
Strcat(UChar* dest, UChar* dest_end, UChar* src, UChar* src_end)
a992 1
#endif
d994 2
a995 2
static UChar*
StrcatCapa(UChar* dest, UChar* dest_end, UChar* src, UChar* src_end, int capa)
d1010 2
a1011 3
static UChar*
StrcatCapaFromStatic(UChar* dest, UChar* dest_end,
		     UChar* src, UChar* src_end, int capa)
d1030 1
a1030 2
static void
NodeFree(Node* node)
d1082 1
a1082 2
static Node*
NodeNew()
d1098 1
a1098 2
static Node*
NodeNewEmpty()
d1106 1
a1106 2
static Node*
NodeNewCClass()
d1117 1
a1117 2
static Node*
NodeNewCType(int type)
d1126 1
a1126 2
static Node*
NodeNewAnyChar()
d1134 1
a1134 2
static Node*
NodeNewList(Node* left, Node* right)
d1144 1
a1144 2
static Node*
NodeNewAlt(Node* left, Node* right)
d1154 1
a1154 2
static Node*
NodeNewAnchor(int type)
d1163 1
a1163 2
static Node*
NodeNewBackref(int regnum)
d1172 1
a1172 2
static Node*
NodeNewQualifier(int lower, int upper)
d1186 1
a1186 2
static Node*
NodeNewOption(RegOptionType option)
d1196 1
a1196 2
static Node*
NodeNewEffect(int type)
d1207 1
a1207 2
static int
NodeStrCat(Node* node, UChar* s, UChar* end)
d1241 1
a1241 2
static int
NodeStrCatChar(Node* node, UChar c)
d1249 1
a1249 2
static Node*
NodeNewStr(UChar* s, UChar* end)
d1265 1
a1265 2
static Node*
NodeNewStrRaw(UChar* s, UChar* end)
d1272 1
a1272 2
static Node*
NodeNewStrChar(UChar c)
d1280 1
a1280 2
static Node*
NodeNewStrRawChar(UChar c)
d1288 1
a1288 2
static Node*
StrNodeSplitLastChar(StrNode* sn, int type, RegCharEncoding code)
d1316 1
a1316 2
static int
scanUnsignedNumber(UChar** src, UChar* end)
d1341 1
a1341 2
static int
scanUnsignedHexadecimalNumber(UChar** src, UChar* end, int maxlen)
d1366 1
a1366 2
static int
scanUnsignedOctadecimalNumber(UChar** src, UChar* end, int maxlen)
d1399 1
a1399 2
static int
IsInWCRange(UChar* p, WCInt wc)
d1423 2
a1424 2
static int
addWCRange(BBuf** pbuf, WCInt from, WCInt to, UChar cfrom, UChar cto)
d1517 2
a1518 3
static int
addMultiByteRange(BBuf** pbuf, RegCharEncoding code,
		  UChar* from, UChar* from_end, UChar* to, UChar* to_end)
d1532 3
a1534 3
static int
scanBackSlashMultiByteSequence(UChar** src, UChar* end,
			       RegCharEncoding code, UChar* buf, int len)
d1586 1
a1586 2
static int
scanRangeQualifier(UChar** src, UChar* end, int* lower, int* upper)
d1631 1
a1631 2
static int
ConvBackSlashValue(int c)
d1648 1
a1648 2
static int
scanMetaControlBackslash(UChar** src, UChar* end)
d1697 1
a1697 2
static int
scanBackSlash(UChar** src, UChar* end, ScanEnv* env, Node** node)
d1849 2
a1850 3
static int
scanBackSlashInCharClass(UChar** src, UChar* end,
			 RegCharEncoding code, Node* node, int* num)
d1932 2
a1933 3
static void
BitSetByPredFunc(BitSetRef bs, int (*pf)(RegCharEncoding, UChar),
		 RegCharEncoding code, int not)
d1955 2
a1956 3
static int
scanPosixBracketCharClass(UChar** src, UChar* end,
			  RegCharEncoding code, Node* node)
d2024 2
a2025 2
static int
scanCharClass(UChar** src, UChar* end, RegCharEncoding code, Node* node)
d2233 2
a2234 2
static int
ScanMakeNode(UChar** src, UChar* end, UChar term, ScanEnv* env,	Node** rnode)
d2353 2
a2354 8
      if (c) {
	if (IS_EXTEND(env->option)) {
	  if (strchr("# \t\n\r\f", c)) {
	    PUNFETCH;
	    break;
	  }
	}
	if (strchr("()|^$?+*{[.\\", c)) {
d2360 5
d2396 2
a2397 3
static int
ScanMakeParen(UChar** src, UChar* end, UChar term, ScanEnv* env,
	      Node** top, int *last_is_group)
d2559 2
a2560 2
static int
ScanMakeTree(UChar** src, UChar* end, UChar term, ScanEnv* env, Node** top)
d2673 1
a2673 2
static int
ParseMakeTree(Node** root, UChar* pattern, UChar* end, regex_t* reg)
d2894 1
a2894 2
static int
AddOpCode(regex_t* reg, int opcode)
d2900 1
a2900 2
static int
AddRelAddr(regex_t* reg, int addr)
d2907 1
a2907 2
static int
AddLength(regex_t* reg, int len)
d2914 1
a2914 2
static int
AddMemNum(regex_t* reg, int num)
d2921 1
a2921 2
static int
AddRepeatNum(regex_t* reg, int num)
d2928 1
a2928 2
static int
AddOption(regex_t* reg, RegOptionType option)
d2934 1
a2934 2
static int
AddOpCodeRelAddr(regex_t* reg, int opcode, int addr)
d2944 1
a2944 2
static int
AddBytes(regex_t* reg, UChar* bytes, int len)
d2950 1
a2950 2
static int
AddBitSet(regex_t* reg, BitSetRef bs)
d2956 1
a2956 2
static int
AddOpCodeOption(regex_t* reg, int opcode, RegOptionType option)
a2966 1
static int compileTree(Node* node, regex_t* reg);
d2968 1
a2968 2
static int
selectStrOpCode(int mb_len, int str_len, int ignore_case)
d3012 3
a3014 2
static int
compileTreeEmptyCheck(Node* node, regex_t* reg, int empty)
d3038 1
a3038 2
static int
compileTreeNtimes(Node* node, int n, regex_t* reg)
d3049 2
a3050 2
static int
addCompileStringLength(UChar* s, int mb_len, int str_len, regex_t* reg)
d3066 1
a3066 2
static int
addCompileString(UChar* s, int mb_len, int str_len, regex_t* reg)
d3082 1
a3082 2
static int
compileLengthStringNode(StrNode* sn, regex_t* reg)
d3117 1
a3117 2
static int
compileLengthStringRawNode(StrNode* sn, regex_t* reg)
d3132 1
a3132 2
static int
compileStringNode(StrNode* sn, regex_t* reg)
d3164 1
a3164 2
static int
compileStringRawNode(StrNode* sn, regex_t* reg)
d3179 1
a3179 2
static int
addMultiByteCClassOffset(BBuf* mbuf, regex_t* reg, int offset)
d3185 1
a3185 2
static int
compileLengthCClassNode(CClassNode* cc, regex_t* reg)
d3205 1
a3205 2
static int
compileCClassNode(CClassNode* cc, regex_t* reg)
d3237 2
a3238 2
static int
compileRangeRepeat(QualifierNode* qn, int target_len, regex_t* reg)
d3266 1
a3266 2
static int
compileLengthQualifierNode(QualifierNode* qn, regex_t* reg)
d3317 1
a3317 2
static int
compileQualifierNode(QualifierNode* qn, regex_t* reg)
d3407 1
a3407 2
static int
compileLengthOption(OptionNode* node, regex_t* reg)
d3422 1
a3422 2
static int
compileOption(OptionNode* node, regex_t* reg)
d3446 1
a3446 2
static int
compileLengthEffectNode(EffectNode* node, regex_t* reg)
d3482 1
a3482 2
static int
compileEffectNode(EffectNode* node, regex_t* reg)
d3564 1
a3564 2
static int
compileLengthTree(Node* node, regex_t* reg)
d3647 1
a3647 2
static int
compileTree(Node* node, regex_t* reg)
a3762 1
    break;
d3768 1
a3768 2
static int
getMinMatchLength(Node* node, RegDistance *min)
d3861 1
a3861 2
static int
getMaxMatchLength(Node* node, regex_t* reg, RegDistance *max)
d3962 1
a3962 2
static int
getCharLengthTree(Node* node, regex_t* reg, RegDistance* len)
d4037 1
a4037 2
static Node*
getHeadExactNode(Node* node, regex_t* reg)
d4114 2
a4115 2
static int
checkTypeTree(Node* node, int type_mask, int effect_mask, int anchor_mask)
d4172 1
a4172 2
static int
setupTree(Node* node, regex_t* reg, int state)
d4369 1
a4369 2
static void
OptBufInit(OptBuf* obuf, regex_t* reg, Node* root)
d4380 1
a4380 2
static void
OptBufCopy(OptBuf* obuf, OptBuf* from)
d4392 1
a4392 2
static void
OptBufReset(OptBuf* obuf, RegDistance min, RegDistance max)
d4400 1
a4400 2
static void
OptBufInc(OptBuf* obuf, RegDistance inc_min, RegDistance inc_max)
d4409 1
a4409 2
static void
OptBufMergeAlt(OptBuf* obuf, OptBuf* from)
d4425 1
a4425 2
static void
PrintDistanceRange(FILE* f, RegDistance a, RegDistance b)
d4440 1
a4440 2
static void
PrintAnchor(FILE* f, int anchor)
d4488 1
a4488 2
static void
PrintExactBuf(FILE* f, ExactBuf* buf)
d4508 1
a4508 2
static void
ExactBufInit(ExactBuf* buf, OptBuf* obuf)
d4522 1
a4522 2
static void
ExactBufCopy(ExactBuf* buf, ExactBuf* from)
d4542 2
a4543 2
static void
ExactBufAddStr(ExactBuf* buf, UChar* s, UChar* end, RegCharEncoding code)
d4566 1
a4566 2
static void
ExactBufAdd(ExactBuf* buf, ExactBuf* from, RegCharEncoding code)
d4571 1
a4571 2
static void
ExactBufIntersect(ExactBuf* to, ExactBuf* from, RegCharEncoding code)
d4607 1
a4607 2
static void
ExactBufUpdateBetter(ExactBuf* to, ExactBuf* from)
d4669 1
a4669 2
static void
ExactBufRevise(ExactBuf* best, ExactBuf* econt, OptBuf* obuf)
d4680 2
a4681 3
static int
setExactInfoNode(regex_t* reg, OptBuf* obuf,
		 ExactBuf* econt, ExactBuf* best, Node* node)
d5103 2
a5104 3
static int
SetExactInfo(regex_t* reg, Node* node, OptBuf* obuf,
	     ExactBuf* econt, ExactBuf* best)
d5118 1
a5118 2
static void
PrintMapBuf(FILE* f, MapBuf* buf)
d5136 1
a5136 2
static void
MapBufInit(MapBuf* buf, OptBuf* obuf)
d5152 1
a5152 2
static void
MapBufCopy(MapBuf* buf, MapBuf* from)
d5165 1
a5165 2
static void
MapAdd(MapBuf* buf, UChar c)
d5178 1
a5178 2
static void
MapBufAdd(MapBuf* buf, UChar c)
d5181 1
a5181 1
    MapAdd(buf, c);
d5185 1
a5185 2
static void
MapBufReverse(MapBuf* buf)
d5194 1
a5194 1
      MapAdd(buf, i);
d5198 1
a5198 2
static void
MapBufClear(MapBuf* buf)
d5206 1
a5206 2
static void
MapBufUnion(MapBuf* to, MapBuf* from)
d5224 1
a5224 1
	MapAdd(to, i);
d5235 1
a5235 2
static void
MapBufUpdateBetter(MapBuf* to, MapBuf* from)
d5282 1
a5282 2
static int
setMapInfoNode(OptBuf* obuf, MapBuf* best, Node* node)
d5563 1
a5563 2
static int
SetMapInfo(Node* node, OptBuf* obuf, MapBuf* best)
d5570 1
a5570 2
static void
PrintOptimizeInfo(FILE* f, regex_t* reg)
d5589 1
a5589 2
static void
SetOptimizeMap(regex_t* reg, MapBuf* m)
d5611 1
a5611 2
static int
SetOptimizeExact(regex_t* reg, ExactBuf* e)
d5656 1
a5656 2
static void
ClearOptimizeInfo(regex_t* reg)
d5674 1
a5674 2
static int
SetOptimizeInfoFromTree(Node* node, regex_t* reg)
d5732 1
a5732 2
extern void
RegexRegionClear(RegRegion* region)
d5741 1
a5741 2
extern int
RegexRegionResize(RegRegion* region, int n)
d5775 1
a5775 2
extern void
RegexRegionInit(RegRegion* region)
d5792 1
a5792 2
extern void
RegexRegionFree(RegRegion* r, int free_self)
d5804 1
a5804 2
extern void
re_free_registers(RegRegion* r)
d5810 1
a5810 2
extern void
RegexRegionCopy(RegRegion* r1, RegRegion* r2)
d5836 1
a6113 1
#ifdef REG_DEBUG
d6116 1
a6116 1
#endif
a6122 1
#ifdef HAVE_SYS_TIME_H
a6123 2
#endif
#ifdef HAVE_UNISTD_H
a6124 1
#endif
a6129 1
#ifdef HAVE_SYS_TIMES_H
a6130 1
#endif
d6190 2
a6191 3
static int
matchAt(regex_t* reg, UChar* str, UChar* end, UChar* sstart,
	UChar* sprev, RegRegion* region, MatchStackAlloc* msa)
d6228 1
a6228 1
  fprintf(stderr, "matchAt: str: %d, end: %d, start: %d, sprev: %d\n",
d7085 2
a7086 3
extern int
re_adjust_startpos(regex_t* reg, const char* string, int size,
		   int startpos, int range)
d7104 3
a7106 3
static UChar*
SlowSearch(RegCharEncoding code, UChar* target, UChar* target_end,
	   UChar* text, UChar* text_end, UChar* text_range)
d7134 2
a7135 3
static int
StrTransMatchAfterHeadByte(RegCharEncoding code, UChar* trans,
			   int len, UChar* t, UChar* tend, UChar* p)
d7168 3
a7170 3
static UChar*
SlowSearchIC(RegCharEncoding code, UChar* transtable, UChar* target,
	     UChar* target_end, UChar* text, UChar* text_end, UChar* text_range)
d7195 3
a7197 3
static UChar*
SlowSearchBackward(RegCharEncoding code, UChar* target, UChar* target_end,
	   UChar* text, UChar* adjust_text, UChar* text_end, UChar* text_start)
d7225 3
a7227 4
static UChar*
SlowSearchBackwardIC(RegCharEncoding code, UChar* transtable, UChar* target,
		     UChar* target_end, UChar* text, UChar* adjust_text,
		     UChar* text_end, UChar* text_start)
d7253 2
a7254 2
static int
SetBMSkip(UChar* s, UChar* end, UChar* transtable, UChar skip[], int** int_skip)
d7290 2
a7291 3
static UChar*
BMSearch(regex_t* reg, UChar* target, UChar* target_end,
	 UChar* text, UChar* text_end, UChar* text_range)
d7375 2
a7376 2
static int
SetBMBackwardSkip(UChar* s, UChar* end, UChar* transtable, int** skip)
d7400 2
a7401 3
static UChar*
BMSearchBackward(regex_t* reg, UChar* target, UChar* target_end, UChar* text,
		 UChar* adjust_text, UChar* text_end, UChar* text_start)
d7427 2
a7428 2
static UChar*
MapSearch(RegCharEncoding code, UChar map[], UChar* text, UChar* text_range)
d7440 2
a7441 3
static UChar*
MapSearchBackward(RegCharEncoding code, UChar map[],
		  UChar* text, UChar* adjust_text, UChar* text_start)
d7453 2
a7454 2
extern int
RegexMatch(regex_t* reg, UChar* str, UChar* end, UChar* at, RegRegion* region)
d7462 9
a7470 5
  r = RegexRegionResize(region, reg->max_mem + 1);
  if (r == 0) {
    prev = GetPrevCharHead(reg->code, str, at);
    r = matchAt(reg, str, end, at, prev, region, &msa);
  }
d7475 2
a7476 11
extern int
re_match(regex_t* reg, const char* str, int size, int pos,
	 struct re_registers* regs)
{
  return RegexMatch(reg, (UChar* )str, (UChar* )(str + size),
		    (UChar* )(str + pos), regs);
}

static int
ForwardSearchRange(regex_t* reg, UChar* str, UChar* end, UChar* s,
		   UChar* range, UChar** low, UChar** high, UChar** low_prev)
d7575 2
a7576 1
static int SetBMBackwardSkip(UChar* s, UChar* end, UChar* transtbl, int** skip);
d7580 2
a7581 3
static int
BackwardSearchRange(regex_t* reg, UChar* str, UChar* end, UChar* s,
		    UChar* range, UChar* adjrange, UChar** low, UChar** high)
d7673 1
a7673 2
static void
regexFreeBody(regex_t* reg)
d7685 1
a7685 2
extern void
RegexFree(regex_t* reg)
d7700 1
a7700 2
static void
regexTransfer(regex_t* to, regex_t* from)
d7713 1
a7713 2
static void
regexChainLinkAdd(regex_t* to, regex_t* add)
d7721 1
a7721 2
static void
regexChainReduce(regex_t* reg)
d7726 1
d7737 1
d7741 2
a7742 3
extern int
RegexSearch(regex_t* reg, UChar* str, UChar* end,
	    UChar* start, UChar* range, RegRegion* region)
d7848 1
a7848 1
  r = matchAt(reg, str, end, s, prev, region, &msa);\
d7862 1
a7862 1
      UChar *sch_range, *low, *high, *low_prev;
a7863 9
      sch_range = range;
      if (reg->dmax != 0) {
	if (reg->dmax == INFINITE_DISTANCE)
	  sch_range = end;
	else {
	  sch_range += reg->dmax;
	  if (sch_range > end) sch_range = end;
	}
      }
d7866 1
a7866 1
	  if (! ForwardSearchRange(reg, str, end, s, sch_range,
d7890 1
a7890 1
	    ! ForwardSearchRange(reg, str, end, s, sch_range,
d7953 3
a7955 3
extern int
re_search(regex_t* bufp, const char* string, int size, int startpos, int range,
	  struct re_registers* regs)
d7963 1
a7963 2
extern int
RegexClone(regex_t* to, regex_t* from)
d8004 1
a8004 2
static int
regexCompile(regex_t* reg, UChar* pattern, UChar* pattern_end)
d8067 2
a8068 3
extern int
RegexReCompile(regex_t* reg, UChar* pattern, UChar* pattern_end,
	       RegOptionType option, RegCharEncoding code, UChar* transtable)
d8088 1
a8088 2
extern char*
re_compile_pattern(const char* pattern, int size, regex_t* reg)
d8099 1
a8099 2
extern char*
re_recompile_pattern(const char* pattern, int size, regex_t* reg)
d8111 1
a8111 2
extern void
re_free_pattern(regex_t* reg)
d8118 2
a8119 3
static int
regexAllocInit(regex_t** reg, RegOptionType option,
	       RegCharEncoding code, UChar* transtable)
d8144 1
a8144 2
extern int
re_alloc_pattern(regex_t** reg)
d8156 2
a8157 3
extern int
RegexNew(regex_t** reg, UChar* pattern, UChar* pattern_end,
	 RegOptionType option, RegCharEncoding code, UChar* transtable)
d8173 1
a8173 2
static void
SetDefaultTransTable(UChar* table)
d8191 1
a8191 2
extern void
re_set_casetable(const char* table)
d8196 1
a8196 2
extern void
re_mbcinit(int mb_code)
d8201 1
a8201 2
extern int
RegexInit()
d8213 1
a8213 2
extern int
RegexEnd()
d8306 1
a8306 2
static char*
Op2Name(int opcode)
d8317 1
a8317 2
static int
Op2ArgType(int opcode)
d8328 1
a8328 2
static void
Indent(FILE* f, int indent)
d8334 1
a8334 2
static void
pOpCode(FILE* f, char* opcode)
d8339 1
a8339 2
static void
pString(FILE* f, int len, UChar* s)
d8345 1
a8345 2
static void
pLenString(FILE* f, LengthType len, int mb_len, UChar* s)
d8353 1
a8353 2
static void
printCompiledByteCode(FILE* f, UChar* bp, UChar** nextp)
a8358 1
  WCInt wc;
d8393 2
a8394 1
      pString(f, 1, bp++); break;
d8396 2
a8397 1
      pString(f, 2, bp); bp += 2; break;
d8399 2
a8400 1
      pString(f, 3, bp); bp += 3; break;
d8402 2
a8403 1
      pString(f, 4, bp); bp += 4; break;
d8405 2
a8406 1
      pString(f, 5, bp); bp += 5; break;
d8414 2
a8415 1
      pString(f, 2, bp); bp += 2; break;
d8417 2
a8418 1
      pString(f, 4, bp); bp += 4; break;
d8420 2
a8421 1
      pString(f, 6, bp); bp += 6; break;
d8467 10
a8476 6
      n = BitSetOnNum((BitSetRef )bp);
      bp += SIZE_BITSET;
      GET_LENGTH_INC(len, bp);
      GET_WCINT(wc, bp);
      bp += len;
      fprintf(f, ":%d:%d:%d", n, (int )wc, len);
d8481 10
a8490 6
      n = BitSetOnNum((BitSetRef )bp);
      bp += SIZE_BITSET;
      GET_LENGTH_INC(len, bp);
      GET_WCINT(wc, bp);
      bp += len;
      fprintf(f, ":%d:%d:%d", n, (int )wc, len);
d8497 1
d8499 1
a8499 1
	mem = *((MemNumType* )bp);
d8507 1
a8507 1
	fprintf(f, ":%d:%d:%d-", mem, addr, nf);
d8542 1
a8542 2
static void
printCompiledByteCodeList(FILE* f, regex_t* reg)
d8565 1
a8565 2
static void
printIndentTree(FILE* f, Node* node, int indent)
d8704 1
a8704 2
static void
PrintTree(FILE* f, Node* node)
d8712 1
a8712 2
static void
PrintStatistics(FILE* f)
@


1.1.1.4
log
@Import Oni Guruma 20020313.
@
text
@d3 1
a3 1
  regex.c -  OniGuruma (regular expression library)
a30 1
#define USE_QUALIFIER_PEEK_NEXT
d52 1
a52 2
#define USE_ONIGURUMA_EXTENSION
#define USE_WORD_BEGIN_END          /* "\<": word-begin, "\>": word-end */
d85 1
a85 1
regex_error_code_to_str(int code)
d91 1
a92 1
  switch (code) {
a171 1
  }
d173 2
a174 1
  p = "error message is not supported";
d176 1
d209 1
a209 1
distance_add(RegDistance d1, RegDistance d2)
d220 1
a220 1
distance_multiply(RegDistance d, int m)
d229 1
a229 1
distance_distance(RegDistance d1, RegDistance d2)
d239 1
a239 1
RegCharEncoding RegDefaultCharEncoding = REGCODE_DEFAULT;
d364 1
a364 1
bitset_is_empty(BitSetRef bs)
d374 1
a374 1
bitset_on_num(BitSetRef bs)
d394 1
a394 1
bbuf_init(BBuf* buf, int size)
d404 1
a404 1
#define BBUF_INIT(buf,size)    bbuf_init((BBuf* )(buf), (size))
a507 4
#ifdef USE_ONIGURUMA_EXTENSION
#define CTYPE_WORD_SB           (1<<6)
#define CTYPE_WORD_MB           (1<<7)
#endif
a533 3
#define N_STRING_MASK       (N_STRING | N_STRING_RAW)
#define NSTRING_LEN(node)   ((node)->u.str.end - (node)->u.str.s)

a553 1
  struct _Node* next_head_exact;
d603 1
a603 1
#define MBBACK(code,start,s,n)   step_backward_char((code),(start),(s),(n))
a642 3
#define IS_SB_WORD(code,c)  (mblen(code,c) == 1 && IS_CODE_WORD(enc,c))
#define IS_MB_WORD(code,c)  ismb(code,c)

d742 1
a742 1
mb_max_length(RegCharEncoding code)
d754 1
a754 1
#define mbmaxlen(code)              mb_max_length(code)
a774 1
#define IS_MB_WORD(code,c)  ismb(code,c)
d834 1
a834 1
get_left_adjust_char_head(RegCharEncoding code, UChar* start, UChar* s)
d883 1
a883 1
get_right_adjust_char_head(RegCharEncoding code, UChar* start, UChar* s)
d885 1
a885 1
  UChar* p = get_left_adjust_char_head(code, start, s);
d894 2
a895 2
get_right_adjust_char_head_with_prev(RegCharEncoding code,
				     UChar* start, UChar* s, UChar** prev)
d897 1
a897 1
  UChar* p = get_left_adjust_char_head(code, start, s);
d910 1
a910 1
get_prev_char_head(RegCharEncoding code, UChar* start, UChar* s)
d915 1
a915 1
  return get_left_adjust_char_head(code, start, s - 1);
d919 1
a919 1
step_backward_char(RegCharEncoding code, UChar* start, UChar* s, int n)
d925 1
a925 1
    s = get_left_adjust_char_head(code, start, s - 1);
d932 1
a932 1
is_code_ascii(RegCharEncoding code, UChar c) { return IS_CODE_ASCII(code, c); }
d934 1
a934 1
is_code_graph(RegCharEncoding code, UChar c) { return IS_CODE_GRAPH(code, c); }
d936 1
a936 1
is_code_print(RegCharEncoding code, UChar c) { return IS_CODE_PRINT(code, c); }
d938 1
a938 1
is_code_alnum(RegCharEncoding code, UChar c) { return IS_CODE_ALNUM(code, c); }
d940 1
a940 1
is_code_alpha(RegCharEncoding code, UChar c) { return IS_CODE_ALPHA(code, c); }
d942 1
a942 1
is_code_lower(RegCharEncoding code, UChar c) { return IS_CODE_LOWER(code, c); }
d944 1
a944 1
is_code_upper(RegCharEncoding code, UChar c) { return IS_CODE_UPPER(code, c); }
d946 1
a946 1
is_code_cntrl(RegCharEncoding code, UChar c) { return IS_CODE_CNTRL(code, c); }
d948 1
a948 1
is_code_punct(RegCharEncoding code, UChar c) { return IS_CODE_PUNCT(code, c); }
d950 1
a950 1
is_code_space(RegCharEncoding code, UChar c) { return IS_CODE_SPACE(code, c); }
d952 1
a952 1
is_code_blank(RegCharEncoding code, UChar c) { return IS_CODE_BLANK(code, c); }
d954 1
a954 1
is_code_digit(RegCharEncoding code, UChar c) { return IS_CODE_DIGIT(code, c); }
d956 1
a956 1
is_code_xdigit(RegCharEncoding code, UChar c) { return IS_CODE_XDIGIT(code, c); }
d959 1
a959 1
k_strncmp(UChar* s1, UChar* s2, int n)
d971 1
a971 1
k_strcpy(UChar* dest, UChar* src, UChar* end)
d981 1
a981 1
k_strdup(UChar* s, UChar* end)
d995 1
d997 20
a1016 1
k_strcat_capa(UChar* dest, UChar* dest_end, UChar* src, UChar* src_end, int capa)
d1026 1
a1026 1
  k_strcpy(r + (dest_end - dest), src, src_end);
d1032 2
a1033 2
strcat_capa_from_static(UChar* dest, UChar* dest_end,
			UChar* src, UChar* src_end, int capa)
d1039 2
a1040 2
  k_strcpy(r, dest, dest_end);
  k_strcpy(r + (dest_end - dest), src, src_end);
d1053 1
a1053 1
node_free(Node* node)
d1067 2
a1068 2
    node_free(NCONS(node).left);
    node_free(NCONS(node).right);
d1078 1
a1078 1
      node_free(NQUALIFIER(node).target);
d1083 1
a1083 1
      node_free(NOPTION(node).target);
d1088 1
a1088 1
      node_free(NEFFECT(node).target);
d1106 1
a1106 1
node_new()
d1123 1
a1123 1
node_new_empty()
d1125 1
a1125 1
  Node* node = node_new();
d1132 1
a1132 1
node_new_cclass()
d1134 1
a1134 1
  Node* node = node_new();
d1144 1
a1144 1
node_new_ctype(int type)
d1146 1
a1146 1
  Node* node = node_new();
d1154 1
a1154 1
node_new_anychar()
d1156 1
a1156 1
  Node* node = node_new();
d1163 1
a1163 1
node_new_list(Node* left, Node* right)
d1165 1
a1165 1
  Node* node = node_new();
d1174 1
a1174 1
node_new_alt(Node* left, Node* right)
d1176 1
a1176 1
  Node* node = node_new();
d1185 1
a1185 1
node_new_anchor(int type)
d1187 1
a1187 1
  Node* node = node_new();
d1195 1
a1195 1
node_new_backref(int regnum)
d1197 1
a1197 1
  Node* node = node_new();
d1205 1
a1205 1
node_new_qualifier(int lower, int upper)
d1207 1
a1207 1
  Node* node = node_new();
d1215 1
a1215 2
  NQUALIFIER(node).head_exact      = (Node* )NULL;
  NQUALIFIER(node).next_head_exact = (Node* )NULL;
d1220 1
a1220 1
node_new_option(RegOptionType option)
d1222 1
a1222 1
  Node* node = node_new();
d1231 1
a1231 1
node_new_effect(int type)
d1233 1
a1233 1
  Node* node = node_new();
d1243 1
a1243 1
node_str_cat(Node* node, UChar* s, UChar* end)
d1255 1
a1255 1
	k_strcpy(NSTRING(node).s + len, s, end);
d1259 1
a1259 2
	  p = strcat_capa_from_static(NSTRING(node).s, NSTRING(node).end,
				      s, end, capa);
d1261 1
a1261 1
	  p = k_strcat_capa(NSTRING(node).s, NSTRING(node).end, s, end, capa);
d1269 1
a1269 1
      k_strcpy(NSTRING(node).s + len, s, end);
d1278 1
a1278 1
node_str_cat_char(Node* node, UChar c)
d1283 1
a1283 10
  return node_str_cat(node, s, s + 1);
}

static void
node_conv_to_str_node(Node* node, int type)
{
  node->type = type;  /* type: N_STRING / N_STRING_RAW */
  NSTRING(node).capa = 0;
  NSTRING(node).s    = NSTRING(node).buf;
  NSTRING(node).end  = NSTRING(node).buf;
d1287 1
a1287 1
node_new_str(UChar* s, UChar* end)
d1289 1
a1289 1
  Node* node = node_new();
d1296 2
a1297 2
  if (node_str_cat(node, s, end)) {
    node_free(node);
d1304 1
a1304 1
node_new_str_raw(UChar* s, UChar* end)
d1306 1
a1306 1
  Node* node = node_new_str(s, end);
d1312 1
a1312 1
node_new_str_char(UChar c)
d1317 1
a1317 1
  return node_new_str(p, p + 1);
d1321 1
a1321 1
node_new_str_raw_char(UChar c)
d1326 1
a1326 1
  return node_new_str_raw(p, p + 1);
d1330 1
a1330 1
str_node_split_last_char(StrNode* sn, int type, RegCharEncoding code)
d1336 1
a1336 1
    p = get_prev_char_head(code, sn->s, sn->end);
d1339 1
a1339 1
	n = node_new_str_raw(p, sn->end);
d1341 1
a1341 1
	n = node_new_str(p, sn->end);
d1359 1
a1359 1
scan_unsigned_number(UChar** src, UChar* end)
d1385 1
a1385 1
scan_unsigned_hexadecimal_number(UChar** src, UChar* end, int maxlen)
d1411 1
a1411 1
scan_unsigned_octal_number(UChar** src, UChar* end, int maxlen)
d1445 1
a1445 1
is_in_wc_range(UChar* p, WCInt wc)
d1470 1
a1470 1
add_wc_range(BBuf** pbuf, WCInt from, WCInt to, UChar cfrom, UChar cto)
d1486 1
a1486 1
    r = bbuf_init(*pbuf, SIZE_BITSET + INIT_MULTI_BYTE_RANGE_SIZE);
d1564 2
a1565 2
add_multi_byte_range(BBuf** pbuf, RegCharEncoding code,
		     UChar* from, UChar* from_end, UChar* to, UChar* to_end)
d1576 1
a1576 1
  return add_wc_range(pbuf, wc_from, wc_to, from[0], to[0]);
d1580 2
a1581 2
scan_backslash_multi_byte_sequence(UChar** src, UChar* end,
				   RegCharEncoding code, UChar* buf, int len)
d1597 1
a1597 1
	r = scan_unsigned_hexadecimal_number(&p, end, 2);
d1608 1
a1608 1
	r = scan_unsigned_octal_number(&p, end, 3);
d1634 1
a1634 1
scan_range_qualifier(UChar** src, UChar* end, int* lower, int* upper)
d1642 1
a1642 1
  low = scan_unsigned_number(&p, end);
d1653 1
a1653 1
    up = scan_unsigned_number(&p, end);
d1680 1
a1680 1
conv_backslash_value(int c)
d1698 1
a1698 1
scan_meta_control_backslash(UChar** src, UChar* end)
d1714 1
a1714 1
      c = scan_meta_control_backslash(&p, end);
d1730 1
a1730 1
      c = scan_meta_control_backslash(&p, end);
d1740 1
a1740 1
    c = conv_backslash_value(c);
d1748 1
a1748 1
scan_backslash(UChar** src, UChar* end, ScanEnv* env, Node** node)
d1759 1
a1759 1
    *node = node_new_cclass();
d1786 1
a1786 1
    *node = node_new_ctype(CTYPE_WORD);
d1789 1
a1789 1
    *node = node_new_ctype(CTYPE_NOT_WORD);
d1793 1
a1793 1
    *node = node_new_ctype(CTYPE_WORD_BOUND);
d1796 1
a1796 1
    *node = node_new_ctype(CTYPE_NOT_WORD_BOUND);
d1799 1
a1799 1
#ifdef USE_WORD_BEGIN_END
d1801 1
a1801 1
    *node = node_new_ctype(CTYPE_WORD_BEGIN);
d1804 1
a1804 10
    *node = node_new_ctype(CTYPE_WORD_END);
    break;
#endif

#ifdef USE_ONIGURUMA_EXTENSION
  case 'k':
    *node = node_new_ctype(CTYPE_WORD_SB);
    break;
  case 'K':
    *node = node_new_ctype(CTYPE_WORD_MB);
d1809 1
a1809 1
    *node = node_new_anchor(ANCHOR_BEGIN_BUF);
d1814 1
a1814 1
      *node = node_new_anchor(ANCHOR_SEMI_END_BUF);
d1819 1
a1819 1
    *node = node_new_anchor(ANCHOR_END_BUF);
d1823 1
a1823 1
    *node = node_new_anchor(ANCHOR_BEGIN_POSITION);
d1828 1
a1828 1
    num = scan_unsigned_hexadecimal_number(&p, end, 2);
d1840 1
a1840 1
    num = scan_unsigned_number(&p, end);
d1845 1
a1845 1
      *node = node_new_backref(num);
d1850 1
a1850 1
      *node = node_new_str_char((UChar )c);
d1859 1
a1859 1
    num = scan_unsigned_octal_number(&p, end, (c == '0' ? 2 : 3));
d1869 1
a1869 1
    num = scan_meta_control_backslash(&p, end);
d1882 1
a1882 1
    node_str_cat_char(env->last_node, (UChar )num);
d1887 1
a1887 1
    *node = node_new_str_raw_char(num);
d1894 2
a1895 2
    r = add_wc_range(&(mbuf), (WCInt )0x80, ~((WCInt )0),\
                    (UChar )0x80, (UChar )0xff);\
d1901 2
a1902 2
scan_backslash_in_char_class(UChar** src, UChar* end,
			     RegCharEncoding code, Node* node, int* num)
a1951 12
#ifdef USE_ONIGURUMA_EXTENSION
  case 'k':
    for (c = 0; c < SINGLE_BYTE_SIZE; c++) {
      if (IS_SB_WORD(code,c)) BITSET_SET_BIT(bs, c);
    }
    break;

  case 'K':
    ADD_ALL_MULTI_BYTE_RANGE(code, NCCLASS(node).mbuf);
    break;
#endif

d1953 1
a1953 1
    *num = scan_unsigned_hexadecimal_number(&p, end, 2);
d1964 1
a1964 1
    *num = scan_unsigned_octal_number(&p, end, 3);
d1975 1
a1975 1
    *num = scan_meta_control_backslash(&p, end);
d1985 2
a1986 2
bitset_by_pred_func(BitSetRef bs, int (*pf)(RegCharEncoding, UChar),
		    RegCharEncoding code, int not)
d2009 2
a2010 2
scan_posix_bracket_char_class(UChar** src, UChar* end,
			      RegCharEncoding code, Node* node)
d2024 14
a2037 14
    { "alnum",  is_code_alnum,  5 },
    { "alpha",  is_code_alpha,  5 },
    { "blank",  is_code_blank,  5 },
    { "cntrl",  is_code_cntrl,  5 },
    { "digit",  is_code_digit,  5 },
    { "graph",  is_code_graph,  5 },
    { "lower",  is_code_lower,  5 },
    { "print",  is_code_print,  5 },
    { "punct",  is_code_punct,  5 },
    { "space",  is_code_space,  5 },
    { "upper",  is_code_upper,  5 },
    { "xdigit", is_code_xdigit, 6 },
    { "ascii",  is_code_ascii,  5 }, /* I don't know origin. Perl? */
    { (UChar* )NULL, is_code_alnum, 0 }
d2050 1
a2050 1
    if (k_strncmp(p, pbsp->name, pbsp->len) == 0) {
d2053 1
a2053 1
      bitset_by_pred_func(bs, pbsp->pf, code, not);
d2079 1
a2079 1
scan_char_class(UChar** src, UChar* end, RegCharEncoding code, Node* node)
d2123 1
a2123 1
      r = scan_backslash_in_char_class(&p, end, code, node, &c);
d2140 1
a2140 1
      r = scan_posix_bracket_char_class(&p, end, code, node);
d2172 1
a2172 1
	curr_true_mblen = scan_backslash_multi_byte_sequence(&p, end, code,
d2189 1
a2189 1
	r = add_multi_byte_range(&(NCCLASS(node).mbuf), code,
d2243 3
a2245 3
	  r = add_multi_byte_range(&(NCCLASS(node).mbuf), code,
				   curr_mbs, curr_mbs + curr_true_mblen,
				   curr_mbs, curr_mbs + curr_true_mblen);
d2288 1
a2288 1
scan_make_node(UChar** src, UChar* end, UChar term, ScanEnv* env, Node** rnode)
d2313 1
a2313 1
    *rnode = node_new_anchor(type);
d2320 1
a2320 1
    *rnode = node_new_anchor(type);
d2334 1
a2334 1
    r = scan_range_qualifier(&p, end, &lower, &upper);
d2351 1
a2351 1
    *rnode = node_new_qualifier(lower, upper);
d2364 1
a2364 1
    *rnode = node_new_cclass();
d2366 1
a2366 1
    r = scan_char_class(&p, end, env->code, *rnode);
d2372 1
a2372 1
    *rnode = node_new_anychar();
d2378 1
a2378 1
    r = scan_backslash(&p, end, env, rnode);
d2430 1
a2430 1
      node_str_cat(env->last_node, *src, p);
d2434 1
a2434 1
      *rnode = node_new_str(*src, p);
d2446 2
a2447 2
static int scan_make_tree(UChar** src, UChar* end, UChar term, ScanEnv* env,
			  Node** top);
d2452 2
a2453 2
scan_make_paren(UChar** src, UChar* end, UChar term, ScanEnv* env,
		Node** top, int *last_is_group)
d2536 1
a2536 1
      *top = node_new_option(option);
d2547 1
a2547 1
      type = scan_make_tree(&p, end, term, env, top);
d2558 1
a2558 1
      type = scan_make_tree(&p, end, term, env, &curr);
d2565 1
a2565 1
      *top = node_new_option(option);
d2573 1
a2573 1
  type = scan_make_tree(&p, end, term, env, &curr);
d2580 1
a2580 1
    *top = node_new_effect(EFFECT_MEMORY);
d2586 1
a2586 1
    *top = node_new_effect(EFFECT_PREC_READ);
d2591 1
a2591 1
    *top = node_new_effect(EFFECT_PREC_READ_NOT);
d2596 1
a2596 1
    *top = node_new_effect(EFFECT_STOP_BACKTRACK);
d2604 1
a2604 1
      *top = node_new_effect(etype);
d2616 1
a2616 1
scan_make_tree(UChar** src, UChar* end, UChar term, ScanEnv* env, Node** top)
d2627 1
a2627 1
    type = scan_make_node(src, end, term, env, &curr);
d2640 1
a2640 1
	  n = str_node_split_last_char(sn, NTYPE(*last), env->code);
d2643 1
a2643 1
	    *last = node_new_list(*last, node_new_list(curr, NULL));
d2666 1
a2666 1
	    *last = node_new_list(*last, NULL);
d2669 1
a2669 1
	  *last_concat = node_new_list(curr, NULL);
d2679 1
a2679 1
	  *top = node_new_empty();
d2681 1
a2681 1
	*top = node_new_alt(*top, NULL);
d2683 1
a2683 1
	type = scan_make_tree(src, end, term, env, &(NCONS(*top).right));
d2685 1
a2685 1
	  NCONS(*top).right = node_new_alt(NCONS(*top).right, NULL);
d2692 1
a2692 1
      type = scan_make_paren(src, end, NOT_TERM, env, &curr, &last_is_group);
d2699 1
a2699 1
	type = scan_make_tree(src, end, ')', env, &(NOPTION(curr).target));
d2725 1
a2725 1
    *top = node_new_empty();
d2730 1
a2730 1
parse_make_tree(Node** root, UChar* pattern, UChar* end, regex_t* reg)
d2744 1
a2744 1
  r = scan_make_tree(&p, end, NOT_TERM, &env, root);
d2768 2
a2769 2
  OP_EXACT1_IC,         /* single byte, N = 1, ignore case */
  OP_EXACTN_IC,         /* single byte,        ignore case */
d2778 2
a2779 3
  OP_ANYCHAR,                /* "."  */
  OP_ANYCHAR_STAR,           /* ".*" */
  OP_ANYCHAR_STAR_PEEK_NEXT,
a2782 2
  OP_WORD_SB,
  OP_WORD_MB,
d2804 1
a2804 1
  OP_SET_OPTION_PUSH,    /* set option and push recover option */
a2810 1
  OP_PUSH_IF_PEEK_NEXT,   /* if match exact then push, else none. */
d2846 2
a2847 2
      UChar *pstr;       /* string position */
      UChar *pstr_prev;  /* previous char position of pstr */
d2861 1
a2861 1
      /* Following information is setted, if this stack type is MEM-START */
d2923 22
a2944 25
#define SIZE_OP_ANYCHAR_STAR            SIZE_OPCODE
#define SIZE_OP_ANYCHAR_STAR_PEEK_NEXT (SIZE_OPCODE + 1)
#define SIZE_OP_JUMP                   (SIZE_OPCODE + SIZE_RELADDR)
#define SIZE_OP_PUSH                   (SIZE_OPCODE + SIZE_RELADDR)
#define SIZE_OP_PUSH_OR_JUMP_EXACT1    (SIZE_OPCODE + SIZE_RELADDR + 1)
#define SIZE_OP_PUSH_IF_PEEK_NEXT      (SIZE_OPCODE + SIZE_RELADDR + 1)
#define SIZE_OP_REPEAT_INC             (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_REPEAT_INC_NG          (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_PUSH_POS                SIZE_OPCODE
#define SIZE_OP_PUSH_POS_NOT           (SIZE_OPCODE + SIZE_RELADDR)
#define SIZE_OP_POP_POS                 SIZE_OPCODE
#define SIZE_OP_FAIL_POS                SIZE_OPCODE
#define SIZE_OP_SET_OPTION             (SIZE_OPCODE + SIZE_OPTION)
#define SIZE_OP_SET_OPTION_PUSH        (SIZE_OPCODE + SIZE_OPTION)
#define SIZE_OP_FAIL                    SIZE_OPCODE
#define SIZE_OP_MEMORY_START_PUSH      (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_MEMORY_END_PUSH        (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_MEMORY_END             (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_PUSH_STOP_BT            SIZE_OPCODE
#define SIZE_OP_POP_STOP_BT             SIZE_OPCODE
#define SIZE_OP_NULL_CHECK_START       (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_NULL_CHECK_END         (SIZE_OPCODE + SIZE_MEMNUM)
#define SIZE_OP_LOOK_BEHIND            (SIZE_OPCODE + SIZE_LENGTH)
#define SIZE_OP_PUSH_LOOK_BEHIND_NOT   (SIZE_OPCODE + SIZE_RELADDR + SIZE_LENGTH)
#define SIZE_OP_FAIL_LOOK_BEHIND_NOT    SIZE_OPCODE
d2952 1
a2952 1
add_opcode(regex_t* reg, int opcode)
d2959 1
a2959 1
add_rel_addr(regex_t* reg, int addr)
d2967 1
a2967 1
add_length(regex_t* reg, int len)
d2975 1
a2975 1
add_mem_num(regex_t* reg, int num)
d2983 1
a2983 1
add_repeat_num(regex_t* reg, int num)
d2991 1
a2991 1
add_option(regex_t* reg, RegOptionType option)
d2998 1
a2998 1
add_opcode_rel_addr(regex_t* reg, int opcode, int addr)
d3002 1
a3002 1
  r = add_opcode(reg, opcode);
d3004 1
a3004 1
  r = add_rel_addr(reg, addr);
d3009 1
a3009 1
add_bytes(regex_t* reg, UChar* bytes, int len)
d3016 1
a3016 1
add_bitset(regex_t* reg, BitSetRef bs)
d3023 1
a3023 1
add_opcode_option(regex_t* reg, int opcode, RegOptionType option)
d3027 1
a3027 1
  r = add_opcode(reg, opcode);
d3029 1
a3029 1
  r = add_option(reg, option);
d3033 2
a3034 2
static int compile_length_tree(Node* node, regex_t* reg);
static int compile_tree(Node* node, regex_t* reg);
d3037 1
a3037 1
select_str_opcode(int mb_len, int str_len, int ignore_case)
d3082 1
a3082 1
compile_tree_empty_check(Node* node, regex_t* reg, int empty)
d3088 1
a3088 1
    r = add_opcode(reg, OP_NULL_CHECK_START);
d3090 1
a3090 1
    r = add_mem_num(reg, reg->num_null_check); /* NULL CHECK ID */
d3095 1
a3095 1
  r = compile_tree(node, reg);
d3099 1
a3099 1
    r = add_opcode(reg, OP_NULL_CHECK_END);
d3101 1
a3101 1
    r = add_mem_num(reg, saved_num_null_check); /* NULL CHECK ID */
d3107 1
a3107 1
compile_tree_n_times(Node* node, int n, regex_t* reg)
d3112 1
a3112 1
    r = compile_tree(node, reg);
d3119 1
a3119 1
add_compile_string_length(UChar* s, int mb_len, int str_len, regex_t* reg)
d3122 1
a3122 1
  int op = select_str_opcode(mb_len, str_len, IS_IGNORECASE(reg->options));
d3136 1
a3136 1
add_compile_string(UChar* s, int mb_len, int str_len, regex_t* reg)
d3138 2
a3139 2
  int op = select_str_opcode(mb_len, str_len, IS_IGNORECASE(reg->options));
  add_opcode(reg, op);
d3142 1
a3142 1
    add_length(reg, mb_len);
d3145 1
a3145 1
    add_length(reg, str_len);
d3147 1
a3147 1
  add_bytes(reg, s, mb_len * str_len);
d3153 1
a3153 1
compile_length_string_node(StrNode* sn, regex_t* reg)
d3174 1
a3174 1
      r = add_compile_string_length(prev, prev_len, slen, reg);
d3183 1
a3183 1
  r = add_compile_string_length(prev, prev_len, slen, reg);
d3189 1
a3189 1
compile_length_string_raw_node(StrNode* sn, regex_t* reg)
d3199 1
a3199 1
  len = add_compile_string_length(sn->s, 1 /* sb */, sn->end - sn->s, reg);
d3205 1
a3205 1
compile_string_node(StrNode* sn, regex_t* reg)
d3225 1
a3225 1
      r = add_compile_string(prev, prev_len, slen, reg);
d3234 1
a3234 1
  return add_compile_string(prev, prev_len, slen, reg);
d3238 1
a3238 1
compile_string_raw_node(StrNode* sn, regex_t* reg)
d3248 1
a3248 1
  r = add_compile_string(sn->s, 1 /* sb */, sn->end - sn->s, reg);
d3254 1
a3254 1
add_multi_byte_cclass_offset(BBuf* mbuf, regex_t* reg, int offset)
d3256 2
a3257 2
  add_length(reg, mbuf->used - offset);
  return add_bytes(reg, mbuf->p + offset, mbuf->used - offset);
d3261 1
a3261 1
compile_length_cclass_node(CClassNode* cc, regex_t* reg)
d3269 1
a3269 1
    if (bitset_is_empty(cc->bs)) {
d3282 1
a3282 1
compile_cclass_node(CClassNode* cc, regex_t* reg)
d3287 2
a3288 2
    if (cc->not)  add_opcode(reg, OP_CCLASS_NOT);
    else          add_opcode(reg, OP_CCLASS);
d3290 1
a3290 1
    r = add_bitset(reg, cc->bs);
d3293 3
a3295 3
    if (bitset_is_empty(cc->bs)) {
      if (cc->not)  add_opcode(reg, OP_CCLASS_MB_NOT);
      else          add_opcode(reg, OP_CCLASS_MB);
d3297 1
a3297 1
      r = add_bitset(reg, (BitSetRef )cc->mbuf->p);
d3299 1
a3299 1
      r = add_multi_byte_cclass_offset(cc->mbuf, reg, SIZE_BITSET);
d3302 2
a3303 2
      if (cc->not)  add_opcode(reg, OP_CCLASS_MIX_NOT);
      else          add_opcode(reg, OP_CCLASS_MIX);
d3305 1
a3305 1
      r = add_bitset(reg, cc->bs);
d3307 1
a3307 1
      r = add_multi_byte_cclass_offset(cc->mbuf, reg, SIZE_BITSET);
d3315 1
a3315 1
compile_range_repeat_node(QualifierNode* qn, int target_len, regex_t* reg)
d3320 1
a3320 1
  r = add_opcode(reg, qn->greedy ? OP_REPEAT : OP_REPEAT_NG);
d3322 1
a3322 1
  r = add_mem_num(reg, reg->num_repeat); /* OP_REPEAT ID */
d3325 1
a3325 1
  r = add_rel_addr(reg, target_len + SIZE_OP_REPEAT_INC);
d3327 1
a3327 1
  r = add_repeat_num(reg, qn->lower);
d3329 1
a3329 1
  r = add_repeat_num(reg, qn->upper);
d3332 1
a3332 1
  r = compile_tree_empty_check(qn->target, reg, qn->target_empty);
d3335 1
a3335 1
  r = add_opcode(reg, qn->greedy ? OP_REPEAT_INC : OP_REPEAT_INC_NG);
d3337 1
a3337 1
  r = add_mem_num(reg, saved_num_repeat); /* OP_REPEAT ID */
d3344 1
a3344 1
compile_length_qualifier_node(QualifierNode* qn, regex_t* reg)
d3348 1
a3348 1
  int tlen = compile_length_tree(qn->target, reg);
d3355 1
a3355 4
      if (IS_NOT_NULL(qn->next_head_exact))
	return SIZE_OP_ANYCHAR_STAR_PEEK_NEXT + tlen * qn->lower;
      else
	return SIZE_OP_ANYCHAR_STAR + tlen * qn->lower;
a3375 2
      else if (IS_NOT_NULL(qn->next_head_exact))
	len += SIZE_OP_PUSH_IF_PEEK_NEXT + mod_tlen + SIZE_OP_JUMP;
d3396 1
a3396 11
is_anychar_star_qualifier(QualifierNode* qn)
{
  if (qn->greedy && IS_REPEAT_INFINITE(qn->upper) &&
      NTYPE(qn->target) == N_ANYCHAR)
    return 1;
  else
    return 0;
}

static int
compile_qualifier_node(QualifierNode* qn, regex_t* reg)
d3400 1
a3400 1
  int tlen = compile_length_tree(qn->target, reg);
d3404 4
a3407 5
  if (is_anychar_star_qualifier(qn)) {
    r = compile_tree_n_times(qn->target, qn->lower, reg);
    if (r) return r;
    if (IS_NOT_NULL(qn->next_head_exact)) {
      r = add_opcode(reg, OP_ANYCHAR_STAR_PEEK_NEXT);
d3409 1
a3409 1
      return add_bytes(reg, NSTRING(qn->next_head_exact).s, 1);
a3410 2
    else
      return add_opcode(reg, OP_ANYCHAR_STAR);
d3423 1
a3423 3
	  r = add_opcode_rel_addr(reg, OP_JUMP, SIZE_OP_PUSH_OR_JUMP_EXACT1);
	else if (IS_NOT_NULL(qn->next_head_exact))
	  r = add_opcode_rel_addr(reg, OP_JUMP, SIZE_OP_PUSH_IF_PEEK_NEXT);
d3425 1
a3425 1
	  r = add_opcode_rel_addr(reg, OP_JUMP, SIZE_OP_PUSH);
d3428 1
a3428 1
	r = add_opcode_rel_addr(reg, OP_JUMP, SIZE_OP_JUMP);
d3433 1
a3433 1
      r = compile_tree_n_times(qn->target, qn->lower, reg);
d3439 1
a3439 1
	r = add_opcode_rel_addr(reg, OP_PUSH_OR_JUMP_EXACT1,
d3442 2
a3443 2
	add_bytes(reg, NSTRING(qn->head_exact).s, 1);
	r = compile_tree_empty_check(qn->target, reg, qn->target_empty);
d3445 1
a3445 1
	r = add_opcode_rel_addr(reg, OP_JUMP,
a3447 10
      else if (IS_NOT_NULL(qn->next_head_exact)) {
	r = add_opcode_rel_addr(reg, OP_PUSH_IF_PEEK_NEXT,
				mod_tlen + SIZE_OP_JUMP);
	if (r) return r;
	add_bytes(reg, NSTRING(qn->next_head_exact).s, 1);
	r = compile_tree_empty_check(qn->target, reg, qn->target_empty);
	if (r) return r;
	r = add_opcode_rel_addr(reg, OP_JUMP,
		     -(mod_tlen + SIZE_OP_JUMP + SIZE_OP_PUSH_IF_PEEK_NEXT));
      }
d3449 1
a3449 1
	r = add_opcode_rel_addr(reg, OP_PUSH, mod_tlen + SIZE_OP_JUMP);
d3451 1
a3451 1
	r = compile_tree_empty_check(qn->target, reg, qn->target_empty);
d3453 1
a3453 1
	r = add_opcode_rel_addr(reg, OP_JUMP,
d3458 1
a3458 1
      r = add_opcode_rel_addr(reg, OP_JUMP, mod_tlen);
d3460 1
a3460 1
      r = compile_tree_empty_check(qn->target, reg, qn->target_empty);
d3462 1
a3462 1
      r = add_opcode_rel_addr(reg, OP_PUSH, -(mod_tlen + SIZE_OP_PUSH));
d3469 1
a3469 1
    r = compile_tree_n_times(qn->target, qn->lower, reg);
d3473 1
a3473 1
      r = add_opcode_rel_addr(reg, OP_PUSH,
d3476 1
a3476 1
      r = compile_tree(qn->target, reg);
d3481 1
a3481 1
    r = compile_range_repeat_node(qn, mod_tlen, reg);
d3487 1
a3487 1
compile_length_option(OptionNode* node, regex_t* reg)
d3493 1
a3493 1
  tlen = compile_length_tree(node->target, reg);
d3503 1
a3503 1
compile_option(OptionNode* node, regex_t* reg)
d3511 1
a3511 1
  r = add_opcode_option(reg, OP_SET_OPTION_PUSH, node->option);
d3513 1
a3513 1
  r = add_opcode_option(reg, OP_SET_OPTION, prev);
d3515 1
a3515 1
  r = add_opcode(reg, OP_FAIL);
d3519 1
a3519 1
  r = compile_tree(node->target, reg);
d3523 1
a3523 1
  r = add_opcode_option(reg, OP_SET_OPTION, prev);
d3528 1
a3528 1
compile_length_effect_node(EffectNode* node, regex_t* reg)
d3531 1
a3531 1
  int tlen = compile_length_tree(node->target, reg);
d3562 1
a3562 1
static int get_char_length_tree(Node* node, regex_t* reg, RegDistance* len);
d3565 1
a3565 1
compile_effect_node(EffectNode* node, regex_t* reg)
d3571 1
a3571 1
    r = add_opcode(reg, OP_MEMORY_START_PUSH);
d3573 1
a3573 1
    r = add_mem_num(reg, node->regnum);
d3575 1
a3575 1
    r = compile_tree(node->target, reg);
d3579 1
a3579 1
      r = add_opcode(reg, OP_MEMORY_END_PUSH);
d3581 1
a3581 1
      r = add_opcode(reg, OP_MEMORY_END);
d3584 1
a3584 1
    r = add_mem_num(reg, node->regnum);
d3588 1
a3588 1
    r = add_opcode(reg, OP_PUSH_POS);
d3590 1
a3590 1
    r = compile_tree(node->target, reg);
d3592 1
a3592 1
    r = add_opcode(reg, OP_POP_POS);
d3596 1
a3596 1
    len = compile_length_tree(node->target, reg);
d3598 1
a3598 1
    r = add_opcode_rel_addr(reg, OP_PUSH_POS_NOT, len + SIZE_OP_FAIL_POS);
d3600 1
a3600 1
    r = compile_tree(node->target, reg);
d3602 1
a3602 1
    r = add_opcode(reg, OP_FAIL_POS);
d3606 1
a3606 1
    r = add_opcode(reg, OP_PUSH_STOP_BT);
d3608 1
a3608 1
    r = compile_tree(node->target, reg);
d3610 1
a3610 1
    r = add_opcode(reg, OP_POP_STOP_BT);
d3616 1
a3616 1
      r = add_opcode(reg, OP_LOOK_BEHIND);
d3618 1
a3618 1
      r = get_char_length_tree(node->target, reg, &n);
d3620 1
a3620 1
      r = add_length(reg, (int )n);
d3622 1
a3622 1
      r = compile_tree(node->target, reg);
d3629 2
a3630 2
      len = compile_length_tree(node->target, reg);
      r = add_opcode_rel_addr(reg, OP_PUSH_LOOK_BEHIND_NOT,
d3633 1
a3633 1
      r = get_char_length_tree(node->target, reg, &n);
d3635 1
a3635 1
      r = add_length(reg, (int )n);
d3637 1
a3637 1
      r = compile_tree(node->target, reg);
d3639 1
a3639 1
      r = add_opcode(reg, OP_FAIL_LOOK_BEHIND_NOT);
d3648 1
a3648 1
compile_length_tree(Node* node, regex_t* reg)
d3661 1
a3661 1
      r = compile_length_tree(NCONS(node).left, reg);
d3674 1
a3674 1
	r += compile_length_tree(NCONS(node).left, reg);
d3682 1
a3682 1
    r = compile_length_string_node(&(NSTRING(node)), reg);
d3686 1
a3686 1
    r = compile_length_string_raw_node(&(NSTRING(node)), reg);
d3690 1
a3690 1
    r = compile_length_cclass_node(&(NCCLASS(node)), reg);
d3716 1
a3716 1
    r = compile_length_qualifier_node(&(NQUALIFIER(node)), reg);
d3720 1
a3720 1
    r = compile_length_option(&(NOPTION(node)), reg);
d3724 1
a3724 1
    r = compile_length_effect_node(&NEFFECT(node), reg);
d3732 1
a3732 1
compile_tree(Node* node, regex_t* reg)
d3744 1
a3744 1
      r = compile_tree(NCONS(node).left, reg);
d3753 1
a3753 1
	len += compile_length_tree(NCONS(x).left, reg);
d3761 1
a3761 1
	len = compile_length_tree(NCONS(node).left, reg);
d3763 1
a3763 1
	  r = add_opcode_rel_addr(reg, OP_PUSH, len + SIZE_OP_JUMP);
d3766 1
a3766 1
	r = compile_tree(NCONS(node).left, reg);
d3770 1
a3770 1
	  r = add_opcode_rel_addr(reg, OP_JUMP, len);
d3778 1
a3778 1
    r = compile_string_node(&(NSTRING(node)), reg);
d3782 1
a3782 1
    r = compile_string_raw_node(&(NSTRING(node)), reg);
d3786 1
a3786 1
    r = compile_cclass_node(&(NCCLASS(node)), reg);
d3795 1
a3795 1
#ifdef USE_WORD_BEGIN_END
a3798 4
#ifdef USE_ONIGURUMA_EXTENSION
    case CTYPE_WORD_SB:         op = OP_WORD_SB;        break;
    case CTYPE_WORD_MB:         op = OP_WORD_MB;        break;
#endif
d3800 1
a3800 1
    r = add_opcode(reg, op);
d3804 1
a3804 1
    r = add_opcode(reg, OP_ANYCHAR);
d3816 1
a3816 1
    r = add_opcode(reg, op);
d3822 3
a3824 3
    case 1:  r = add_opcode(reg, OP_BACKREF1); break;
    case 2:  r = add_opcode(reg, OP_BACKREF2); break;
    case 3:  r = add_opcode(reg, OP_BACKREF3); break;
d3826 2
a3827 2
      add_opcode(reg, OP_BACKREFN);
      r = add_mem_num(reg, n);
d3833 1
a3833 1
    r = compile_qualifier_node(&(NQUALIFIER(node)), reg);
d3837 1
a3837 1
    r = compile_option(&(NOPTION(node)), reg);
d3841 1
a3841 1
    r = compile_effect_node(&NEFFECT(node), reg);
d3846 1
a3846 1
    fprintf(stderr, "compile_tree: undefined node type %d\n", NTYPE(node));
d3855 1
a3855 1
get_min_match_length(Node* node, RegDistance *min)
d3869 1
a3869 1
      r = get_min_match_length(NCONS(node).left, &tmin);
d3876 1
a3876 1
      r = get_min_match_length(NCONS(node).left, &tmin);
a3892 4
#ifdef USE_ONIGURUMA_EXTENSION
    case CTYPE_WORD_SB:  *min = 1; break;
    case CTYPE_WORD_MB:  *min = 2; break;
#endif
d3911 1
a3911 1
	r = get_min_match_length(qn->target, min);
d3913 1
a3913 1
	  *min = distance_multiply(*min, qn->lower);
d3920 1
a3920 1
    r = get_min_match_length(NOPTION(node).target, min);
d3929 1
a3929 1
	r = get_min_match_length(en->target, min);
d3949 1
a3949 1
get_max_match_length(Node* node, regex_t* reg, RegDistance *max)
d3962 1
a3962 1
      r = get_max_match_length(NCONS(node).left, reg, &tmax);
d3964 1
a3964 1
	*max = distance_add(*max, tmax);
d3970 1
a3970 1
      r = get_max_match_length(NCONS(node).left, reg, &tmax);
a3986 3
#ifdef USE_ONIGURUMA_EXTENSION
    case CTYPE_WORD_MB:
#endif
a3989 6
#ifdef USE_ONIGURUMA_EXTENSION
    case CTYPE_WORD_SB:
      *max = 1;
      break;
#endif

d4009 1
a4009 1
	r = get_max_match_length(qn->target, reg, max);
d4012 1
a4012 1
	    *max = distance_multiply(*max, qn->upper);
d4021 1
a4021 1
    r = get_max_match_length(NOPTION(node).target, reg, max);
d4030 1
a4030 1
	r = get_max_match_length(en->target, reg, max);
d4051 1
a4051 1
get_char_length_tree(Node* node, regex_t* reg, RegDistance* len)
d4064 1
a4064 1
      r = get_char_length_tree(NCONS(node).left, reg, &tlen);
d4066 1
a4066 1
	*len = distance_add(*len, tlen);
a4085 4
#ifdef USE_ONIGURUMA_EXTENSION
    case CTYPE_WORD_SB:
    case CTYPE_WORD_MB:
#endif
d4097 1
a4097 1
    r = get_char_length_tree(NOPTION(node).target, reg, len);
d4106 1
a4106 1
	r = get_char_length_tree(en->target, reg, len);
d4127 1
a4127 1
get_head_exact_node(Node* node, regex_t* reg)
d4142 1
a4142 1
    n = get_head_exact_node(NCONS(node).left, reg);
d4164 1
a4164 1
	  n = get_head_exact_node(qn->target, reg);
d4174 1
a4174 1
      n = get_head_exact_node(NOPTION(node).target, reg);
d4186 1
a4186 1
	n = get_head_exact_node(en->target, reg);
d4205 1
a4205 1
check_type_tree(Node* node, int type_mask, int effect_mask, int anchor_mask)
d4217 1
a4217 1
      r = check_type_tree(NCONS(node).left, type_mask, effect_mask, anchor_mask);
d4222 1
a4222 1
    r = check_type_tree(NQUALIFIER(node).target, type_mask, effect_mask,
d4226 1
a4226 1
    r = check_type_tree(NOPTION(node).target, type_mask, effect_mask, anchor_mask);
d4234 1
a4234 1
      r = check_type_tree(en->target, type_mask, effect_mask, anchor_mask);
a4249 12
static void
next_setup(Node* node, Node* next_node, regex_t* reg)
{
#ifdef USE_QUALIFIER_PEEK_NEXT
  if (NTYPE(node) == N_QUALIFIER) {
    QualifierNode* qn = &(NQUALIFIER(node));
    if (qn->greedy && IS_REPEAT_INFINITE(qn->upper)) {
      qn->next_head_exact = get_head_exact_node(next_node, reg);
    }
  }
#endif
}
d4255 2
a4256 2
/* setup_tree does the following work.
 1. check empty loop. (set qn->target_empty)
d4259 1
a4259 1
 4. set qn->head_exact for [push, exact] -> [push_or_jump_exact1, exact].
a4260 1
 6. expand repeated string.
d4263 1
a4263 1
setup_tree(Node* node, regex_t* reg, int state)
d4275 1
a4275 3
      r = setup_tree(NCONS(node).left, reg, state);
      if (r == 0 && IS_NOT_NULL(NCONS(node).right))
	next_setup(NCONS(node).left, NCONS(NCONS(node).right).left, reg);
d4281 1
a4281 1
      r = setup_tree(NCONS(node).left, reg, (state | IN_ALT));
a4317 1
      Node* target = qn->target;
d4320 1
a4320 1
	r = get_min_match_length(target, &d);
d4322 3
a4324 1
	if (d == 0) qn->target_empty = 1;
d4326 1
a4326 1
      r = setup_tree(target, reg, state);
d4328 1
a4328 1
      r = get_max_match_length(target, reg, &d);
a4332 21
      /* expand string */
#define EXPAND_STRING_MAX_LENGTH  100
      if (NTYPE(target) & N_STRING_MASK) {
	if (!IS_REPEAT_INFINITE(qn->lower) && qn->lower == qn->upper &&
	    qn->lower > 1 && qn->lower <= EXPAND_STRING_MAX_LENGTH) {
	  int len = NSTRING_LEN(target);
	  StrNode* sn = &(NSTRING(target));

	  if (len * qn->lower <= EXPAND_STRING_MAX_LENGTH) {
	    int i, n = qn->lower;
	    node_conv_to_str_node(node, target->type);
	    for (i = 0; i < n; i++) {
	      r = node_str_cat(node, sn->s, sn->end);
	      if (r) break;
	    }
	    node_free(target);
	    break; /* break case N_QUALIFIER: */
	  }
	}
      }

d4336 1
a4336 1
	qn->head_exact = get_head_exact_node(qn->target, reg);
d4352 1
a4352 1
      r = setup_tree(NOPTION(node).target, reg, state);
d4369 1
a4369 1
	r = setup_tree(en->target, reg, state);
d4372 1
a4372 1
	r = setup_tree(en->target, reg, (state | IN_NOT));
d4381 4
a4384 5
#define ALLOWED_EFFECT_IN_LB_NOT   ( EFFECT_LOOK_BEHIND )
#define ALLOWED_ANCHOR_IN_LB       \
( ANCHOR_BEGIN_LINE | ANCHOR_END_LINE | ANCHOR_BEGIN_BUF )
	/* can't allow all anchors, because \G in look-behind through Search().
	   ex. /(?<=\G)zz/.match("azz") => success. */
d4387 2
a4388 2
	r = check_type_tree(en->target, ALLOWED_TYPE_IN_LB,
			    ALLOWED_EFFECT_IN_LB, ALLOWED_ANCHOR_IN_LB);
d4391 1
a4391 1
	r = setup_tree(en->target, reg, state);
d4395 2
a4396 2
	r = check_type_tree(en->target, ALLOWED_TYPE_IN_LB,
			    ALLOWED_EFFECT_IN_LB_NOT, ALLOWED_ANCHOR_IN_LB);
d4399 1
a4399 1
	r = setup_tree(en->target, reg, (state | IN_NOT));
d4461 1
a4461 1
optbuf_init(OptBuf* obuf, regex_t* reg, Node* root)
d4473 1
a4473 1
optbuf_copy(OptBuf* obuf, OptBuf* from)
d4486 1
a4486 1
optbuf_reset(OptBuf* obuf, RegDistance min, RegDistance max)
d4495 1
a4495 1
optbuf_inc(OptBuf* obuf, RegDistance inc_min, RegDistance inc_max)
d4497 2
a4498 2
  obuf->dmax = distance_add(obuf->dmax, inc_max);
  obuf->dmin = distance_add(obuf->dmin, inc_min);
d4505 1
a4505 1
optbuf_merge_alt(OptBuf* obuf, OptBuf* from)
d4522 1
a4522 1
print_distance_range(FILE* f, RegDistance a, RegDistance b)
d4538 1
a4538 1
print_anchor(FILE* f, int anchor)
d4587 1
a4587 1
print_exactbuf(FILE* f, ExactBuf* buf)
d4591 1
a4591 1
  print_distance_range(f, buf->dmin, buf->dmax);
d4598 1
a4598 1
  print_anchor(f, buf->start_anchor);
d4600 1
a4600 1
  print_anchor(f, buf->end_anchor);
d4608 1
a4608 1
exactbuf_init(ExactBuf* buf, OptBuf* obuf)
d4623 1
a4623 1
exactbuf_copy(ExactBuf* buf, ExactBuf* from)
d4644 1
a4644 1
exactbuf_add_str(ExactBuf* buf, UChar* s, UChar* end, RegCharEncoding code)
d4668 1
a4668 1
exactbuf_add(ExactBuf* buf, ExactBuf* from, RegCharEncoding code)
d4670 1
a4670 1
  exactbuf_add_str(buf, from->buf, &(from->buf[from->len]), code);
d4674 1
a4674 1
exactbuf_intersect(ExactBuf* to, ExactBuf* from, RegCharEncoding code)
d4696 1
a4696 1
    if (k_strncmp(from->buf + i, to->buf + i, len) != 0)
d4711 1
a4711 1
exactbuf_update_better(ExactBuf* to, ExactBuf* from)
d4770 1
a4770 1
  exactbuf_copy(to, from);
d4774 1
a4774 1
exactbuf_revise(ExactBuf* best, ExactBuf* econt, OptBuf* obuf)
d4777 2
a4778 2
    exactbuf_update_better(best, econt);
    exactbuf_init(econt, obuf);
d4782 2
a4783 2
static int set_exact_info(regex_t* reg, Node* node, OptBuf* obuf, 
			  ExactBuf* econt, ExactBuf* best);
d4786 2
a4787 2
set_exact_info_node(regex_t* reg, OptBuf* obuf,
		    ExactBuf* econt, ExactBuf* best, Node* node)
d4801 2
a4802 2
      r = set_exact_info_node(reg, obuf, econt, best, NCONS(node).left);
      if (r == 0) exactbuf_revise(best, econt, obuf);
d4812 1
a4812 1
      optbuf_copy(&save, obuf);
d4814 4
a4817 4
	optbuf_copy(&zobuf,   &save);
	exactbuf_copy(&zebuf, econt);
	exactbuf_init(&tbest, &save);
	r = set_exact_info_node(reg, &zobuf, &zebuf, &tbest, NCONS(x).left);
d4821 1
a4821 1
	      exactbuf_copy(&mix, &tbest);
d4823 1
a4823 1
	      exactbuf_intersect(&mix, &tbest, save.code);
d4827 1
a4827 1
	      exactbuf_copy(&mix, &zebuf);
d4829 1
a4829 1
	      exactbuf_intersect(&mix, &zebuf, save.code);
d4831 1
a4831 1
	  optbuf_merge_alt(obuf, &zobuf);
d4839 1
a4839 1
	exactbuf_copy(econt, &mix);
d4879 1
a4879 1
	  exactbuf_add_str(econt, sn->s, p, obuf->code);
d4881 1
a4881 1
	exactbuf_revise(best, econt, obuf);
d4883 1
a4883 1
	  exactbuf_add_str(econt, p, sn->end, obuf->code);
d4890 1
a4890 1
	  exactbuf_add_str(econt, sn->s, p, obuf->code);
d4900 1
a4900 1
      optbuf_inc(obuf, len, len);
d4930 1
a4930 1
	exactbuf_add_str(econt, sn->s, sn->end, obuf->code);
d4936 1
a4936 1
      optbuf_inc(obuf, len, len);
d4947 1
a4947 1
	  (n = bitset_on_num(cc->bs)) == 1) {
d4956 1
a4956 1
	      exactbuf_add_str(econt, tmp, tmp + 1, obuf->code);
d4974 1
a4974 1
      optbuf_inc(obuf, 1, len);
a4981 4
#ifdef USE_ONIGURUMA_EXTENSION
    case CTYPE_WORD_SB:
    case CTYPE_WORD_MB:
#endif
d4987 1
a4987 1
#ifdef USE_WORD_BEGIN_END
d5000 1
a5000 1
    optbuf_inc(obuf, 1, len);
d5010 1
a5010 1
      optbuf_reset(obuf, 0, 0);
d5015 1
a5015 1
      optbuf_reset(obuf, 0, 0);
d5019 1
a5019 1
      optbuf_reset(obuf, 0, INFINITE_DISTANCE);
d5048 1
a5048 1
    optbuf_inc(obuf, 0, INFINITE_DISTANCE);
d5069 2
a5070 2
	optbuf_copy(&tobuf, obuf);      
	r = set_exact_info(reg, qn->target, &tobuf, &tcont, &tbest);
d5081 1
a5081 1
	      exactbuf_revise(best, econt, obuf);
d5088 1
a5088 1
	    exactbuf_add(econt, &tcont, obuf->code);
d5107 1
a5107 1
		exactbuf_revise(best, econt, obuf);
d5114 1
a5114 1
	      exactbuf_add(econt, &tbest, obuf->code);
d5130 1
a5130 1
	    obuf->dmax = distance_add(obuf->dmax, (RegDistance)(n * qn->upper));
d5139 1
a5139 1
	  obuf->dmin = distance_add(obuf->dmin, (RegDistance )(n * qn->lower));
d5144 1
a5144 1
	optbuf_inc(obuf, 0, 0);
d5154 1
a5154 1
      r = set_exact_info_node(reg, obuf, econt, best, NOPTION(node).target);
d5167 1
a5167 1
	  r = set_exact_info_node(reg, obuf, econt, best, en->target);
d5177 1
a5177 1
	r = set_exact_info_node(reg, obuf, econt, best, en->target);
d5184 2
a5185 2
	  optbuf_copy(&save, obuf);
	  r = set_exact_info_node(reg, &save, econt, best, en->target);
d5205 1
a5205 1
    exactbuf_revise(best, econt, obuf);
d5210 2
a5211 2
set_exact_info(regex_t* reg, Node* node, OptBuf* obuf,
	       ExactBuf* econt, ExactBuf* best)
d5215 3
a5217 3
  exactbuf_init(best,  obuf);
  exactbuf_init(econt, obuf);
  r = set_exact_info_node(reg, obuf, econt, best, node);
d5219 1
a5219 1
    exactbuf_update_better(best, econt);
d5226 1
a5226 1
print_mapbuf(FILE* f, MapBuf* buf)
d5231 1
a5231 1
    print_distance_range(f, buf->dmin, buf->dmax);
d5233 1
a5233 1
    print_anchor(f, buf->start_anchor);
d5235 1
a5235 1
    print_anchor(f, buf->end_anchor);
d5245 1
a5245 1
mapbuf_init(MapBuf* buf, OptBuf* obuf)
d5262 1
a5262 1
mapbuf_copy(MapBuf* buf, MapBuf* from)
d5276 1
a5276 1
map_add(MapBuf* buf, UChar c)
d5290 1
a5290 1
mapbuf_add(MapBuf* buf, UChar c)
d5293 1
a5293 1
    map_add(buf, c);
d5298 1
a5298 1
mapbuf_reverse(MapBuf* buf)
d5307 1
a5307 1
      map_add(buf, i);
d5312 1
a5312 1
mapbuf_clear(MapBuf* buf)
d5321 1
a5321 1
mapbuf_union(MapBuf* to, MapBuf* from)
d5327 1
a5327 1
    mapbuf_clear(to);
d5332 1
a5332 1
    mapbuf_clear(to);
d5339 1
a5339 1
	map_add(to, i);
d5351 1
a5351 1
mapbuf_update_better(MapBuf* to, MapBuf* from)
d5393 1
a5393 1
  mapbuf_copy(to, from);
d5396 1
a5396 1
static int set_map_info(Node* node, OptBuf* obuf, MapBuf* best);
d5399 1
a5399 1
set_map_info_node(OptBuf* obuf, MapBuf* best, Node* node)
a5402 1
  UChar c;
d5414 1
a5414 1
      r = set_map_info_node(obuf, best, NCONS(node).left);
d5424 2
a5425 2
      optbuf_copy(&save, obuf);
      mapbuf_init(&curr, obuf);
d5427 1
a5427 1
	optbuf_copy(&zobuf, &save);
d5429 1
a5429 1
	  r = set_map_info_node(&zobuf, &curr, NCONS(x).left);
d5432 2
a5433 2
	  mapbuf_init(&zbuf, &save);
	  r = set_map_info_node(&zobuf, &zbuf, NCONS(x).left);
d5435 1
a5435 1
	    mapbuf_union(&curr, &zbuf);
d5438 1
a5438 1
	optbuf_merge_alt(obuf, &zobuf);
d5442 1
a5442 1
	mapbuf_update_better(best, &curr);
d5454 1
a5454 1
      mapbuf_init(&curr, obuf);
d5460 1
a5460 1
	      mapbuf_add(&curr, (UChar )i);
d5464 1
a5464 1
	mapbuf_add(&curr, c);
d5467 1
a5467 1
      mapbuf_update_better(best, &curr);
d5469 1
a5469 1
      optbuf_inc(obuf, len, len);
d5475 1
d5481 1
a5481 1
      mapbuf_init(&curr, obuf);
d5483 2
a5484 2
      mapbuf_add(&curr, c);
      mapbuf_update_better(best, &curr);
d5486 1
a5486 1
      optbuf_inc(obuf, len, len);
d5494 1
a5494 1
      mapbuf_init(&curr, obuf);
d5497 1
a5497 1
	  mapbuf_add(&curr, (UChar )i);
d5499 1
a5499 1
	    mapbuf_add(&curr, (UChar )TTRANS(obuf->transtable, i));
d5507 1
a5507 1
	    mapbuf_add(&curr, (UChar )i);
d5512 2
a5513 2
      if (cc->not) mapbuf_reverse(&curr);
      mapbuf_update_better(best, &curr);
d5520 1
a5520 1
      optbuf_inc(obuf, 1, len);
d5528 2
a5529 6
      mapbuf_init(&curr, obuf);
      for (i = 0; i < SINGLE_BYTE_SIZE; i++) {
	c = (UChar )i;
	if (IS_WORD_HEAD(obuf->code, c))
	  mapbuf_add(&curr, c);
      }
d5531 6
a5536 2
      if (NCTYPE(node).type == CTYPE_NOT_WORD)
	mapbuf_reverse(&curr);
d5538 2
a5539 3
      mapbuf_update_better(best, &curr);
      goto anychar;
      break;
d5541 1
a5541 7
#ifdef USE_ONIGURUMA_EXTENSION
    case CTYPE_WORD_SB:
      mapbuf_init(&curr, obuf);
      for (i = 0; i < SINGLE_BYTE_SIZE; i++) {
	c = (UChar )i;
	if (IS_SB_WORD(obuf->code, c))
	  mapbuf_add(&curr, c);
d5543 1
a5543 13
      mapbuf_update_better(best, &curr);
      optbuf_inc(obuf, 1, 1);
      break;

    case CTYPE_WORD_MB:
      mapbuf_init(&curr, obuf);
      for (i = 0; i < SINGLE_BYTE_SIZE; i++) {
	c = (UChar )i;
	if (IS_MB_WORD(obuf->code, c))
	  mapbuf_add(&curr, c);
      }
      mapbuf_update_better(best, &curr);
      optbuf_inc(obuf, 1, mbmaxlen_dist(obuf->code));
a5544 1
#endif
d5548 1
a5548 1
#ifdef USE_WORD_BEGIN_END
d5560 1
a5560 1
    optbuf_inc(obuf, 1, len);
d5569 1
a5569 1
      optbuf_reset(obuf, 0, 0);
d5572 1
a5572 1
      optbuf_reset(obuf, 0, 0);
d5575 1
a5575 1
      optbuf_reset(obuf, 0, INFINITE_DISTANCE);
d5588 1
a5588 1
    optbuf_inc(obuf, 0, INFINITE_DISTANCE);
d5597 1
a5597 1
	optbuf_copy(&tobuf, obuf);
d5599 1
a5599 1
	  r = set_map_info(qn->target, &tobuf, best);
d5604 1
a5604 1
	  r = set_map_info(qn->target, &tobuf, &tbest);
d5616 1
a5616 1
	    obuf->dmax = distance_add(obuf->dmax, (RegDistance)(n * qn->upper));
d5625 1
a5625 1
	  obuf->dmin = distance_add(obuf->dmin, (RegDistance)(n * qn->lower));
d5628 1
a5628 1
	optbuf_inc(obuf, 0, 0);
d5638 1
a5638 1
      r = set_map_info_node(obuf, best, NOPTION(node).target);
d5650 1
a5650 1
	r = set_map_info_node(obuf, best, en->target);
d5658 2
a5659 2
	  optbuf_copy(&save, obuf);
	  r = set_map_info_node(&save, best, en->target);
d5681 1
a5681 1
set_map_info(Node* node, OptBuf* obuf, MapBuf* best)
d5683 2
a5684 2
  mapbuf_init(best, obuf);
  return set_map_info_node(obuf, best, node);
d5689 1
a5689 1
print_optimize_info(FILE* f, regex_t* reg)
d5695 1
a5695 1
  fprintf(f, "  anchor: "); print_anchor(f, reg->anchor);
d5697 1
a5697 1
    print_distance_range(f, reg->anchor_dmin, reg->anchor_dmax);
d5701 1
a5701 1
    fprintf(f, "  sub anchor: "); print_anchor(f, reg->sub_anchor);
d5709 1
a5709 1
set_optimize_map(regex_t* reg, MapBuf* m)
d5728 1
a5728 1
static int set_bm_skip(UChar* s, UChar* end, UChar* transtable,
d5732 1
a5732 1
set_optimize_exact(regex_t* reg, ExactBuf* e)
d5737 1
a5737 1
    reg->exact = k_strdup(e->buf, e->buf + e->len);
d5753 3
a5755 3
      r = set_bm_skip(reg->exact, reg->exact_end,
		      (e->ignore_case ? reg->transtable : (UChar* )NULL),
		      reg->map, &(reg->int_map));
d5778 1
a5778 1
clear_optimize_info(regex_t* reg)
d5797 1
a5797 1
set_optimize_info_from_tree(Node* node, regex_t* reg)
d5803 2
a5804 2
  optbuf_init(&obuf, reg, node);
  r = set_exact_info(reg, node, &obuf, &econt, &ebest);
d5808 1
a5808 1
    exactbuf_update_better(&ebest, &econt);
d5812 1
a5812 1
  fprintf(stderr, "best "); print_exactbuf(stderr, &ebest);
d5820 2
a5821 2
    optbuf_init(&obuf, reg, node);
    r = set_map_info(node, &obuf, &mbest);
d5825 1
a5825 1
    fprintf(stderr, "best "); print_mapbuf(stderr, &mbest);
d5831 1
a5831 1
	   distance_multiply(mbest.dmax, 2) < ebest.dmax) ||
d5833 2
a5834 2
	   distance_multiply(mbest.dmax, 3) < ebest.dmax)) {
	set_optimize_map(reg, &mbest);
d5840 1
a5840 1
    r = set_optimize_exact(reg, &ebest);
d5848 1
a5848 1
  print_optimize_info(stderr, reg);
d5850 1
d5856 1
a5856 1
regex_region_clear(RegRegion* region)
d5866 1
a5866 1
regex_region_resize(RegRegion* region, int n)
d5900 2
a5901 2
static void
regex_region_init(RegRegion* region)
d5909 1
a5909 2
extern RegRegion*
regex_region_new()
d5914 1
a5914 1
  regex_region_init(r);
d5919 1
a5919 1
regex_region_free(RegRegion* r, int free_self)
d5935 1
a5935 1
  regex_region_free(r, 0);
d5939 1
a5939 1
regex_region_copy(RegRegion* r1, RegRegion* r2)
d6207 2
a6208 4
      if (k->u.null_check.num == (id)) {\
        (isnull) = (k->u.null_check.pstr == (s));\
        break;\
      }\
d6243 2
a6244 2
static void print_compiled_byte_code(FILE* f, UChar* bp, UChar** nextp);
static void print_compiled_byte_code_list(FILE* f, regex_t* reg);
d6271 1
a6271 1
static void print_statistics(FILE* f);
a6272 1
static int OpPrevCounter[256];
d6274 1
a6274 2
static int OpCurr = OP_FINISH;
static int OpPrevTarget = OP_FAIL;
d6280 1
a6280 1
    OpCounter[i] = OpPrevCounter[i] = 0; OpTime[i] = 0;\
d6285 1
a6285 1
#define STATISTICS_PRINT_RESULT  print_statistics(stderr)
a6287 1
  if (opcode == OpPrevTarget) OpPrevCounter[OpCurr]++;\
d6299 1
a6299 1
static VALUE regex_stat_print() { STATISTICS_PRINT_RESULT; return Qnil; }
d6301 2
a6302 1
void Init_REGEX_STAT()
d6326 2
a6327 2
match_at(regex_t* reg, UChar* str, UChar* end, UChar* sstart,
	 UChar* sprev, RegRegion* region, MatchStackAlloc* msa)
d6364 1
a6364 1
  fprintf(stderr, "match_at: str: %d, end: %d, start: %d, sprev: %d\n",
d6390 1
a6390 1
      print_compiled_byte_code(stderr, p, NULL);
d6578 12
a6589 6
      GET_LENGTH_INC(tlen,  p);  /* mb-len */
      GET_LENGTH_INC(tlen2, p);  /* string len */
      tlen2 *= tlen;
      DATA_ENSURE(tlen2);
      while (tlen2-- > 0) {
	if (*p++ != *s++) goto fail;
a6590 1
      sprev = s - tlen;
d6621 1
a6621 1
	if (! is_in_wc_range(q, wc)) goto fail;
d6674 1
a6674 1
	if (is_in_wc_range(q, wc)) goto fail;
a6737 24
    case OP_ANYCHAR_STAR_PEEK_NEXT:  STAT_OP_IN(OP_ANYCHAR_STAR_PEEK_NEXT);
      while (s < end) {
	if (*p == *s) {
	  STACK_PUSH_ALT(p + 1, s, sprev);
	}
	if (ismb(encode, *s)) {
	  n = mblen(encode, *s);
	  DATA_ENSURE(n);
	  sprev = s;
	  s += n;
	}
	else {
	  if (! IS_MULTILINE(option)) {
	    if (SBCMP(*s, NEWLINE))
	      goto fail;
	  }
	  sprev = s;
	  s++;
	}
      }
      p++;
      STAT_OP_OUT;
      break;

a6751 21
#ifdef USE_ONIGURUMA_EXTENSION
    case OP_WORD_SB:  STAT_OP_IN(OP_WORD_SB);
      DATA_ENSURE(1);
      if (! IS_SB_WORD(encode, *s))
	goto fail;
      s++;
      STAT_OP_OUT;
      break;

    case OP_WORD_MB:  STAT_OP_IN(OP_WORD_MB);
      DATA_ENSURE(1);
      if (! IS_MB_WORD(encode, *s))
	goto fail;

      n = mblen(encode, *s);
      DATA_ENSURE(n);
      s += n;
      STAT_OP_OUT;
      break;
#endif

d6787 1
a6787 1
#ifdef USE_WORD_BEGIN_END
d6912 1
a6912 1
	UChar *pstart, *pend;
d6919 1
a6919 1
	  pend = stkp->u.mem.pstr;
d6921 2
a6922 2
	  pstart = stkp->u.mem.pstr;
	  n = pend - pstart;
d6925 1
a6925 1
	  STRING_CMP(pstart, s, n);
a7016 13
    case OP_PUSH_IF_PEEK_NEXT:  STAT_OP_IN(OP_PUSH_IF_PEEK_NEXT);
      GET_RELADDR_INC(addr, p);
      if (*p == *s) {
	p++;
	STACK_PUSH_ALT(p + addr, s, sprev);
	STAT_OP_OUT;
	continue;
      }
      p++;
      STAT_OP_OUT;
      continue;
      break;

d7151 1
a7151 1
      sprev = get_prev_char_head(encode, str, s);
d7161 4
a7164 4
	/* too short case -> success. ex. /(?<!XXX)a/.match("a")
	   If you want to change to fail, replace following line. */
	p += addr;
	/* goto fail; */
d7169 1
a7169 1
	sprev = get_prev_char_head(encode, str, s);
d7230 1
a7230 1
      p = get_right_adjust_char_head(reg->code, (UChar* )string, s);
d7233 1
a7233 1
      p = get_left_adjust_char_head(reg->code, (UChar* )string, s);
d7242 2
a7243 2
slow_search(RegCharEncoding code, UChar* target, UChar* target_end,
	    UChar* text, UChar* text_end, UChar* text_range)
d7272 2
a7273 2
str_trans_match_after_head_byte(RegCharEncoding code, UChar* trans,
				int len, UChar* t, UChar* tend, UChar* p)
d7307 2
a7308 2
slow_search_ic(RegCharEncoding code, UChar* transtable, UChar* target,
	       UChar* target_end, UChar* text, UChar* text_end, UChar* text_range)
d7324 1
a7324 1
      if (str_trans_match_after_head_byte(code, transtable, len, t, target_end, p))
d7334 2
a7335 2
slow_search_backward(RegCharEncoding code, UChar* target, UChar* target_end,
	     UChar* text, UChar* adjust_text, UChar* text_end, UChar* text_start)
d7343 1
a7343 1
    s = get_left_adjust_char_head(code, adjust_text, s);
d7357 1
a7357 1
    s = get_prev_char_head(code, adjust_text, s);
d7364 3
a7366 3
slow_search_backward_ic(RegCharEncoding code, UChar* transtable, UChar* target,
			UChar* target_end, UChar* text, UChar* adjust_text,
			UChar* text_end, UChar* text_start)
d7375 1
a7375 1
    s = get_left_adjust_char_head(code, adjust_text, s);
d7382 1
a7382 2
      if (str_trans_match_after_head_byte(code, transtable, len,
					  t, target_end, p))
d7385 1
a7385 1
    s = get_prev_char_head(code, adjust_text, s);
d7393 1
a7393 1
set_bm_skip(UChar* s, UChar* end, UChar* transtable, UChar skip[], int** int_skip)
d7430 2
a7431 2
bm_search(regex_t* reg, UChar* target, UChar* target_end,
	  UChar* text, UChar* text_end, UChar* text_range)
d7516 1
a7516 1
set_bm_backward_skip(UChar* s, UChar* end, UChar* transtable, int** skip)
d7541 2
a7542 2
bm_search_backward(regex_t* reg, UChar* target, UChar* target_end, UChar* text,
		   UChar* adjust_text, UChar* text_end, UChar* text_start)
d7550 1
a7550 1
    s = get_left_adjust_char_head(reg->code, adjust_text, s);
d7562 1
a7562 1
    s = get_left_adjust_char_head(reg->code, adjust_text, s);
d7569 1
a7569 1
map_search(RegCharEncoding code, UChar map[], UChar* text, UChar* text_range)
d7582 1
a7582 1
map_search_backward(RegCharEncoding code, UChar map[],
d7590 1
a7590 1
    s = get_prev_char_head(code, adjust_text, s);
d7596 1
a7596 1
regex_match(regex_t* reg, UChar* str, UChar* end, UChar* at, RegRegion* region)
d7604 1
a7604 1
  r = regex_region_resize(region, reg->max_mem + 1);
d7606 2
a7607 2
    prev = get_prev_char_head(reg->code, str, at);
    r = match_at(reg, str, end, at, prev, region, &msa);
d7617 2
a7618 2
  return regex_match(reg, (UChar* )str, (UChar* )(str + size),
		     (UChar* )(str + pos), regs);
d7622 2
a7623 2
forward_search_range(regex_t* reg, UChar* str, UChar* end, UChar* s,
		     UChar* range, UChar** low, UChar** high, UChar** low_prev)
d7628 1
a7628 1
  fprintf(stderr, "forward_search_range: str: %d, end: %d, s: %d, range: %d\n",
d7639 1
a7639 1
    p = slow_search(reg->code, reg->exact, reg->exact_end, p, end, range);
d7642 2
a7643 2
    p = slow_search_ic(reg->code, reg->transtable,
		       reg->exact, reg->exact_end, p, end, range);
d7647 1
a7647 1
    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);
d7651 1
a7651 1
    p = map_search(reg->code, reg->map, p, range);
d7669 1
a7669 1
	  prev = get_prev_char_head(reg->code, (pprev ? pprev : str), p);
d7677 1
a7677 1
	  prev = get_prev_char_head(reg->code, (pprev ? pprev : str), p);
d7691 1
a7691 1
	  *low_prev = get_prev_char_head(reg->code, s, p);
d7693 1
a7693 1
	  *low_prev = get_prev_char_head(reg->code, (pprev ? pprev : str), p);
d7699 1
a7699 1
	*low = get_right_adjust_char_head_with_prev(reg->code, s, *low, low_prev);
d7701 1
a7701 1
	  *low_prev = get_prev_char_head(reg->code, (pprev ? pprev : s), *low);
d7705 1
a7705 1
	  *low_prev = get_prev_char_head(reg->code, (pprev ? pprev : str), *low);
d7713 1
a7713 1
    "forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\n",
d7722 1
a7722 1
static int set_bm_backward_skip(UChar* s, UChar* end, UChar* transtbl, int** skip);
d7727 2
a7728 2
backward_search_range(regex_t* reg, UChar* str, UChar* end, UChar* s,
		      UChar* range, UChar* adjrange, UChar** low, UChar** high)
d7740 2
a7741 2
    p = slow_search_backward(reg->code, reg->exact, reg->exact_end,
			     range, adjrange, end, p);
d7745 2
a7746 2
    p = slow_search_backward_ic(reg->code, reg->transtable, reg->exact,
				reg->exact_end, range, adjrange, end, p);
d7754 2
a7755 2
      r = set_bm_backward_skip(reg->exact, reg->exact_end, (UChar* )NULL,
			       &(reg->int_map_backward));
d7758 2
a7759 2
    p = bm_search_backward(reg, reg->exact, reg->exact_end, range, adjrange,
			   end, p);
d7763 1
a7763 1
    p = map_search_backward(reg->code, reg->map, range, adjrange, p);
d7774 1
a7774 1
	  prev = get_prev_char_head(reg->code, adjrange, p);
d7784 1
a7784 1
	  prev = get_prev_char_head(reg->code, adjrange, p);
d7792 1
a7792 1
	  p = get_prev_char_head(reg->code, adjrange, p);
d7803 1
a7803 1
    *high = get_right_adjust_char_head(reg->code, adjrange, *high);
d7806 1
a7806 1
    fprintf(stderr, "backward_search_range: low: %d, high: %d\n",
d7814 1
a7814 1
  fprintf(stderr, "backward_search_range: fail.\n");
d7821 1
a7821 1
regex_free_body(regex_t* reg)
d7830 1
a7830 1
    regex_free(reg->chain);
d7834 1
a7834 1
regex_free(regex_t* reg)
d7837 1
a7837 1
    regex_free_body(reg);
d7844 1
a7844 1
  regex_free_body(to);\
d7850 1
a7850 1
regex_transfer(regex_t* to, regex_t* from)
d7864 1
a7864 1
regex_chain_link_add(regex_t* to, regex_t* add)
d7873 1
a7873 1
regex_chain_reduce(regex_t* reg)
d7892 2
a7893 2
regex_search(regex_t* reg, UChar* str, UChar* end,
	     UChar* start, UChar* range, RegRegion* region)
d7902 1
a7902 1
    regex_chain_reduce(reg);
d7907 1
a7907 1
  fprintf(stderr, "regex_search (entry point): end: %d, start: %d, range: %d\n",
d7911 1
a7911 1
  r = regex_region_resize(region, reg->max_mem + 1);
d7954 1
a7954 1
	    start = get_right_adjust_char_head(reg->code, str, start);
d7956 1
a7956 1
	    start = get_prev_char_head(reg->code, str, end);
d7971 1
a7971 1
	  start = get_left_adjust_char_head(reg->code, str, start);
d7994 1
a7994 1
  fprintf(stderr, "regex_search(apply anchor): end: %d, start: %d, range: %d\n",
d7999 1
a7999 1
  r = match_at(reg, str, end, s, prev, region, &msa);\
d8008 1
a8008 1
      prev = get_prev_char_head(reg->code, str, s);
d8026 2
a8027 2
	  if (! forward_search_range(reg, str, end, s, sch_range,
				     &low, &high, &low_prev)) goto mismatch;
d8050 2
a8051 2
	    ! forward_search_range(reg, str, end, s, sch_range,
				   &low, &high, (UChar** )NULL)) goto mismatch;
d8063 1
a8063 1
      UChar *low, *high, *adjrange, *sch_start;
d8065 1
a8065 1
      adjrange = get_left_adjust_char_head(reg->code, str, range);
d8068 2
a8069 4
	  sch_start = s + reg->dmax;
	  if (sch_start > end) sch_start = end;
	  if (backward_search_range(reg, str, end, sch_start, range, adjrange,
				    &low, &high) <= 0)
d8076 1
a8076 1
	    prev = get_prev_char_head(reg->code, str, s);
d8084 4
a8087 15
	if ((end - range) <= reg->dmin) goto mismatch;

	sch_start = s;
	if (reg->dmax != 0) {
	  if (reg->dmax == INFINITE_DISTANCE)
	    sch_start = end;
	  else {
	    sch_start += reg->dmax;
	    if (sch_start > end) sch_start = end;
	    else
	      sch_start = get_left_adjust_char_head(reg->code, start, sch_start);
	  }
	}
	if (backward_search_range(reg, str, end, sch_start, range, adjrange,
				  &low, &high) <= 0) goto mismatch;
d8092 1
a8092 1
      prev = get_prev_char_head(reg->code, str, s);
d8102 1
a8102 1
  regex_region_clear(region);
d8117 3
a8119 3
  return regex_search(bufp, (UChar* )string, (UChar* )(string + size),
		      (UChar* )(string + startpos),
		      (UChar* )(string + startpos + range), regs);
d8124 1
a8124 1
regex_clone(regex_t* to, regex_t* from)
d8128 1
a8128 1
  regex_free_body(to);
d8162 1
a8162 1
static void print_tree(FILE* f, Node* node);
d8166 1
a8166 1
regex_compile(regex_t* reg, UChar* pattern, UChar* pattern_end)
d8193 5
a8197 2
  r = parse_make_tree(&root, pattern, pattern_end, reg);
  if (r) goto err;
d8200 1
a8200 1
  print_tree(stderr, root);
d8203 5
a8207 2
  r = setup_tree(root, reg, 0);
  if (r) goto err;
d8209 1
a8209 1
  r = compile_tree(root, reg);
d8211 1
a8211 1
    r = add_opcode(reg, OP_END);
d8213 1
a8213 1
      clear_optimize_info(reg);
d8215 1
a8215 1
      r = set_optimize_info_from_tree(root, reg);
d8219 1
a8219 1
  node_free(root);
d8222 1
a8222 1
    print_compiled_byte_code_list(stderr, reg);
a8223 1

a8226 4

 err:
  if (root) node_free(root);
  return r;
d8230 2
a8231 2
regex_recompile(regex_t* reg, UChar* pattern, UChar* pattern_end,
		RegOptionType option, RegCharEncoding code, UChar* transtable)
d8234 4
a8237 1
  regex_t *new_reg;
d8239 1
a8239 1
  r = regex_new(&new_reg, pattern, pattern_end, option, code, transtable);
d8242 1
a8242 1
    regex_transfer(reg, new_reg);
d8245 1
a8245 1
    regex_chain_link_add(reg, new_reg);
d8247 2
a8248 1
  return 0;
d8256 1
a8256 1
  r = regex_compile(reg, (UChar* )pattern, (UChar* )(pattern + size));
d8258 1
a8258 1
    return regex_error_code_to_str(r);
d8268 2
a8269 2
  r = regex_recompile(reg, (UChar* )pattern, (UChar* )(pattern + size),
		      reg->options, reg->code, reg->transtable);
d8271 1
a8271 1
    return regex_error_code_to_str(r);
d8279 1
a8279 1
  regex_free(reg);
d8285 2
a8286 2
regex_alloc_init(regex_t** reg, RegOptionType option,
		 RegCharEncoding code, UChar* transtable)
d8289 1
a8289 1
    regex_init();
a8293 3
  if (IS_NULL(transtable) || transtable == REG_TRANSTABLE_USE_DEFAULT)
    transtable = DefaultTransTable;

d8297 1
a8297 1
  (*reg)->transtable       = transtable;
d8314 3
a8316 1
  if (RegDefaultCharEncoding == REGCODE_UNDEF)
d8319 3
a8321 2
  return regex_alloc_init(reg, REG_OPTION_DEFAULT, RegDefaultCharEncoding,
			  DefaultTransTable);
d8325 2
a8326 2
regex_new(regex_t** reg, UChar* pattern, UChar* pattern_end,
	  RegOptionType option, RegCharEncoding code, UChar* transtable)
d8330 1
a8330 1
  r = regex_alloc_init(reg, option, code, transtable);
d8333 1
a8333 1
  r = regex_compile(*reg, pattern, pattern_end);
d8335 1
a8335 1
    regex_free(*reg);
d8337 1
d8339 1
a8339 1
  return r;
d8343 1
a8343 1
set_default_trans_table(UChar* table)
d8364 1
a8364 1
  set_default_trans_table((UChar* )table);
d8370 1
a8370 1
  RegDefaultCharEncoding = REG_MBLEN_TABLE[mb_code];
d8374 1
a8374 1
regex_init()
d8378 1
a8378 1
    set_default_trans_table(DTT);
a8380 2
#ifdef REG_DEBUG_STATISTICS
  Init_REGEX_STAT();
a8381 2
#endif

d8387 1
a8387 1
regex_end()
a8436 1
  { OP_ANYCHAR_STAR_PEEK_NEXT, "anychar*-peek-next", ARG_SPECIAL },
a8438 2
  { OP_WORD_SB,           "word-sb",         ARG_NON },
  { OP_WORD_MB,           "word-mb",         ARG_NON },
a8461 1
  { OP_PUSH_IF_PEEK_NEXT, "push-if-peek-next", ARG_SPECIAL },
d8481 1
a8481 1
op2name(int opcode)
d8493 1
a8493 1
op2arg_type(int opcode)
a8510 1
#if 0
a8515 1
#endif
d8518 1
a8518 1
p_string(FILE* f, int len, UChar* s)
d8525 1
a8525 1
p_len_string(FILE* f, LengthType len, int mb_len, UChar* s)
d8534 1
a8534 1
print_compiled_byte_code(FILE* f, UChar* bp, UChar** nextp)
d8542 2
a8543 2
  fprintf(f, "[%s", op2name(*bp));
  arg_type = op2arg_type(*bp);
d8575 1
a8575 2
    case OP_ANYCHAR_STAR_PEEK_NEXT:
      p_string(f, 1, bp++); break;
d8577 1
a8577 1
      p_string(f, 2, bp); bp += 2; break;
d8579 1
a8579 1
      p_string(f, 3, bp); bp += 3; break;
d8581 1
a8581 1
      p_string(f, 4, bp); bp += 4; break;
d8583 1
a8583 1
      p_string(f, 5, bp); bp += 5; break;
d8586 1
a8586 1
      p_len_string(f, len, 1, bp);
d8591 1
a8591 1
      p_string(f, 2, bp); bp += 2; break;
d8593 1
a8593 1
      p_string(f, 4, bp); bp += 4; break;
d8595 1
a8595 1
      p_string(f, 6, bp); bp += 6; break;
d8598 1
a8598 1
      p_len_string(f, len, 2, bp);
d8603 1
a8603 1
      p_len_string(f, len, 4, bp);
d8619 1
a8619 1
      p_string(f, 1, bp++);
d8623 1
a8623 1
      p_len_string(f, len, 1, bp);
d8628 1
a8628 1
      n = bitset_on_num((BitSetRef )bp);
d8634 1
a8634 1
      n = bitset_on_num((BitSetRef )bp);
d8641 1
a8641 1
      n = bitset_on_num((BitSetRef )bp);
d8651 1
a8651 1
      n = bitset_on_num((BitSetRef )bp);
a8680 1
    case OP_PUSH_IF_PEEK_NEXT:
d8684 1
a8684 1
      p_string(f, 1, bp);
d8700 1
a8700 1
      fprintf(stderr, "print_compiled_byte_code: undefined code %d\n", *--bp);
d8708 1
a8708 1
print_compiled_byte_code_list(FILE* f, regex_t* reg)
d8725 1
a8725 1
    print_compiled_byte_code(f, bp, &bp);
d8732 1
a8732 1
print_indent_tree(FILE* f, Node* node, int indent)
d8756 1
a8756 1
    print_indent_tree(f, NCONS(node).left, indent + add);
d8762 1
a8762 1
      print_indent_tree(f, NCONS(node).left, indent + add);
d8800 1
a8800 1
#ifdef USE_WORD_BEGIN_END
a8803 4
#ifdef USE_ONIGURUMA_EXTENSION
    case CTYPE_WORD_SB:         fputs("word-sb",        f); break;
    case CTYPE_WORD_MB:         fputs("word-mb",        f); break;
#endif
d8836 1
a8836 1
    print_indent_tree(f, NQUALIFIER(node).target, indent + add);
d8840 1
a8840 1
    print_indent_tree(f, NOPTION(node).target, indent + add);
d8857 1
a8857 1
    print_indent_tree(f, NEFFECT(node).target, indent + add);
d8861 1
a8861 1
    fprintf(f, "print_indent_tree: undefined node type %d\n", NTYPE(node));
d8872 1
a8872 1
print_tree(FILE* f, Node* node)
d8874 1
a8874 1
  print_indent_tree(f, node, 0);
d8881 1
a8881 1
print_statistics(FILE* f)
a8883 1
  fprintf(f, "count     prev      time\n");
d8885 1
a8885 2
    fprintf(f, "%8d: %8d: %10d: %s\n",
	    OpCounter[i], OpPrevCounter[i], OpTime[i], OpInfo[i].name);
@


1.1.1.5
log
@Import Oni Guruma 20020325.
@
text
@d8 1
a25 6
#if defined(__i386) || defined(__i386__) || defined(_M_IX86) || \
    (defined(__ppc__) && defined(__APPLE__)) || \
    defined(__mc68020__)
#define UNALIGNED_WORD_ACCESS
#endif

a85 6
#if defined(RUBY_PLATFORM) || defined(RUBY)
#ifndef REG_RUBY_M17N
#define USE_COMPATIBILITY_FOR_RUBY_EXTENSION_LIBRARY
#endif
#endif

d137 4
a140 6
  case REGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS:
    p = "unmatched range specifier in char-class"; break;
  case REGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED:
    p = "target of repeat operator is not specified"; break;
  case REGERR_TARGET_OF_REPEAT_OPERATOR_INVALID:
    p = "target of repeat operator is invalid"; break;
a164 2
  case REGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE:
    p = "mismatch multibyte code length in char-class range"; break;
a181 98

#ifndef UNALIGNED_WORD_ACCESS
#define WORD_ALIGNMENT_SIZE       SIZEOF_INT

#define GET_ALIGNMENT_PAD_SIZE(addr,pad_size) do {\
  (pad_size) = WORD_ALIGNMENT_SIZE - ((int )(addr) % WORD_ALIGNMENT_SIZE);\
  if ((pad_size) == WORD_ALIGNMENT_SIZE) (pad_size) = 0;\
} while (0)

#define ALIGNMENT_RIGHT(addr) do {\
  (addr) += (WORD_ALIGNMENT_SIZE - 1);\
  (addr) -= ((int )(addr) % WORD_ALIGNMENT_SIZE);\
} while (0)

static unsigned char PadBuf[WORD_ALIGNMENT_SIZE];

#define B_SHIFT  8
#define B_MASK   0xff

#define SERIALIZE_2BYTE_INT(i,p) do {\
  *(p)     = ((i) >> B_SHIFT) & B_MASK;\
  *((p)+1) = (i) & B_MASK;\
} while (0)

#define SERIALIZE_4BYTE_INT(i,p) do {\
  *(p)     = ((i) >> B_SHIFT*3) & B_MASK;\
  *((p)+1) = ((i) >> B_SHIFT*2) & B_MASK;\
  *((p)+2) = ((i) >> B_SHIFT  ) & B_MASK;\
  *((p)+3) = (i) & B_MASK;\
} while (0)

#define SERIALIZE_8BYTE_INT(i,p) do {\
  *(p)     = ((i) >> B_SHIFT*7) & B_MASK;\
  *((p)+1) = ((i) >> B_SHIFT*6) & B_MASK;\
  *((p)+2) = ((i) >> B_SHIFT*5) & B_MASK;\
  *((p)+3) = ((i) >> B_SHIFT*4) & B_MASK;\
  *((p)+4) = ((i) >> B_SHIFT*3) & B_MASK;\
  *((p)+5) = ((i) >> B_SHIFT*2) & B_MASK;\
  *((p)+6) = ((i) >> B_SHIFT  ) & B_MASK;\
  *((p)+7) = (i) & B_MASK;\
} while (0)

#define GET_2BYTE_INT_INC(type,i,p) do {\
  (i) = (type )(((unsigned int )(*(p)) << B_SHIFT) | (unsigned int )((p)[1]));\
  (p) += 2;\
} while (0)

#define GET_4BYTE_INT_INC(type,i,p) do {\
  (i) = (type )(((unsigned int )((p)[0]) << B_SHIFT*3) | \
		((unsigned int )((p)[1]) << B_SHIFT*2) | \
		((unsigned int )((p)[2]) << B_SHIFT  ) | \
		((unsigned int )((p)[3])             )); \
  (p) += 4;\
} while (0)

#define GET_8BYTE_INT_INC(type,i,p) do {\
  (i) = (type )(((unsigned long )((p)[0]) << B_SHIFT*7) | \
		((unsigned long )((p)[1]) << B_SHIFT*6) | \
		((unsigned long )((p)[2]) << B_SHIFT*5) | \
		((unsigned long )((p)[3]) << B_SHIFT*4) | \
		((unsigned long )((p)[4]) << B_SHIFT*3) | \
		((unsigned long )((p)[5]) << B_SHIFT*2) | \
		((unsigned long )((p)[6]) << B_SHIFT  ) | \
		((unsigned long )((p)[7])             )); \
  (p) += 8;\
} while (0)

#if SIZEOF_SHORT == 2
#define GET_SHORT_INC(i,p)     GET_2BYTE_INT_INC(short,i,p)
#define SERIALIZE_SHORT(i,p)   SERIALIZE_2BYTE_INT(i,p)
#elif SIZEOF_SHORT == 4
#define GET_SHORT_INC(i,p)     GET_4BYTE_INT_INC(short,i,p)
#define SERIALIZE_SHORT(i,p)   SERIALIZE_4BYTE_INT(i,p)
#elif SIZEOF_SHORT == 8
#define GET_SHORT_INC(i,p)     GET_8BYTE_INT_INC(short,i,p)
#define SERIALIZE_SHORT(i,p)   SERIALIZE_8BYTE_INT(i,p)
#endif

#if SIZEOF_INT == 2
#define GET_INT_INC(i,p)       GET_2BYTE_INT_INC(int,i,p)
#define GET_UINT_INC(i,p)      GET_2BYTE_INT_INC(unsigned,i,p)
#define SERIALIZE_INT(i,p)     SERIALIZE_2BYTE_INT(i,p)
#define SERIALIZE_UINT(i,p)    SERIALIZE_2BYTE_INT(i,p)
#elif SIZEOF_INT == 4
#define GET_INT_INC(i,p)       GET_4BYTE_INT_INC(int,i,p)
#define GET_UINT_INC(i,p)      GET_4BYTE_INT_INC(unsigned,i,p)
#define SERIALIZE_INT(i,p)     SERIALIZE_4BYTE_INT(i,p)
#define SERIALIZE_UINT(i,p)    SERIALIZE_4BYTE_INT(i,p)
#elif SIZEOF_INT == 8
#define GET_INT_INC(i,p)       GET_8BYTE_INT_INC(int,i,p)
#define GET_UINT_INC(i,p)      GET_8BYTE_INT_INC(unsigned,i,p)
#define SERIALIZE_INT(i,p)     SERIALIZE_8BYTE_INT(i,p)
#define SERIALIZE_UINT(i,p)    SERIALIZE_8BYTE_INT(i,p)
#endif

#endif /* UNALIGNED_WORD_ACCESS */


a197 2
#define MEM_STATS_ON_ALL(stats)  (stats) = ~((unsigned int)0)

d321 6
a326 9
#define IS_SINGLELINE(option)     ((option) & REG_OPTION_SINGLELINE)
#define IS_MULTILINE(option)      ((option) & REG_OPTION_MULTILINE)
#define IS_IGNORECASE(option)     ((option) & REG_OPTION_IGNORECASE)
#define IS_EXTEND(option)         ((option) & REG_OPTION_EXTEND)
#define IS_FIND_LONGEST(option)   ((option) & REG_OPTION_FIND_LONGEST)
#define IS_FIND_NOT_EMPTY(option) ((option) & REG_OPTION_FIND_NOT_EMPTY)
#define IS_POSIXLINE(option)      (IS_SINGLELINE(option) && IS_MULTILINE(option))
#define IS_FIND_CONDITION(option) ((option) & \
          (REG_OPTION_FIND_LONGEST | REG_OPTION_FIND_NOT_EMPTY))
a343 1
#ifdef UNALIGNED_WORD_ACCESS
a344 3
#else
typedef unsigned char  Bits;
#endif
d443 2
a444 3
#define BBUF_ADD(buf,bytes,n)       BBUF_WRITE((buf),(buf)->used,(bytes),(n))
#define BBUF_ADD1(buf,byte)         BBUF_WRITE1((buf),(buf)->used,(byte))
#define BBUF_GET_ADD_POSITION(buf)  ((buf)->p + (buf)->used)
a559 1
  int by_number;      /* {n,m} */
d620 1
a620 1
      (mbmaxlen(enc) > 0 ? mbmaxlen(enc) : INFINITE_DISTANCE)
d641 1
a641 1
#define ISNOT_CODE_WORD(enc,c)  (!m17n_iswchar(enc,c))
d645 1
a645 1
                       m17n_iswchar(code,*(s)))
d648 1
a648 1
                       (s++, m17n_iswchar(code,s[-1])))
d650 1
a650 1
#define IS_WORD_HEAD(enc,c) (ismb(enc,c) ? 1 : IS_CODE_WORD(enc,c))
d652 1
a652 1
#define IS_SB_WORD(code,c)  (mblen(code,c) == 1 && IS_CODE_WORD(code,c))
d1198 1
a1198 1
node_new_qualifier(int lower, int upper, int by_number)
d1207 1
a1207 2
  NQUALIFIER(node).by_number       = by_number;
  NQUALIFIER(node).target_empty    = 0;
a1360 1
#define NOT_TERM         ((UChar )0)
a1579 3
  if (wc_from > wc_to)
    return REGERR_RIGHT_SMALLER_THAN_LEFT_IN_CLASS_RANGE;

a1643 3
#if 1
  if (PEND) return 1;  /* "....{" : OK! */
#else
a1644 5
  c = PPEEK;
  if (c == ')' || c == '(' || c == '|') {
    return REGERR_END_PATTERN_AT_LEFT_BRACE;
  }
#endif
d1768 1
a1768 1
	if (IS_CODE_DIGIT(env->code,c)) BITSET_SET_BIT(NCCLASS(*node).bs, c);
d1773 1
a1773 1
	if (!IS_CODE_DIGIT(env->code,c)) BITSET_SET_BIT(NCCLASS(*node).bs, c);
a2105 9
#define SCC_ST_START       0
#define SCC_ST_NORMAL      1
#define SCC_ST_RANGE       2

#define SCC_LAST_NONE      0
#define SCC_LAST_VALUE     1
#define SCC_LAST_MBVALUE   2
#define SCC_LAST_CLASS     3

d2108 1
a2108 1
  int c, r, isnum, last_val, state, last;
d2129 3
a2131 8
  state = SCC_ST_START;
  last  = SCC_LAST_NONE;
  while (1) {
    if (PEND) {
      r = REGERR_PREMATURE_END_OF_CHAR_CLASS;
      goto err_exit;
    }

d2133 1
d2151 1
a2151 1
	if (state == SCC_ST_RANGE) {
d2155 1
a2155 2
	last  = SCC_LAST_CLASS;
	state = SCC_ST_NORMAL;
d2168 1
a2168 1
	if (state == SCC_ST_RANGE) {
a2171 2
	last  = SCC_LAST_CLASS;
	state = SCC_ST_NORMAL;
d2210 1
d2212 11
a2222 11
      if (state == SCC_ST_RANGE) {
#ifndef REG_RUBY_M17N
	if (last == SCC_LAST_VALUE && code == REGCODE_UTF8) {
	  /* allow only if utf-8 */
	  int i;
	  for (i = last_val; i <= 0x7f; i++) {
	    BITSET_SET_BIT(NCCLASS(node).bs, i);
	  }
	  last_mbs[0] = (UChar )0x80;
	  last_mbs[1] = (UChar )0;
	  last_true_mblen = 1;
d2224 2
a2225 4
	else
#endif
	if (last != SCC_LAST_MBVALUE) {
	  r = REGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;
d2228 3
a2230 13
	last  = SCC_LAST_NONE;
      }
      else {
	if (curr_mblen > last_mbs_alloc_len) {
	  if (last_mbs == last_mbs_buf)
	    last_mbs = (UChar* )xmalloc(curr_mblen);
	  else
	    last_mbs = (UChar* )xrealloc(last_mbs, curr_mblen);
	  if (IS_NULL(last_mbs)) {
	    r = REGERR_MEMORY;
	    goto err_exit;
	  }
	  last_mbs_alloc_len = curr_mblen;
a2231 27
	xmemcpy(last_mbs, curr_mbs, curr_true_mblen);
	last_mblen      = curr_mblen;
	last_true_mblen = curr_true_mblen;
	last  = SCC_LAST_MBVALUE;  /* It is correct. */
      }
      state = SCC_ST_NORMAL;

      r = add_multi_byte_range(&(NCCLASS(node).mbuf), code,
			       last_mbs, last_mbs + last_true_mblen,
			       curr_mbs, curr_mbs + curr_true_mblen);
      if (r < 0) goto err_exit;
    }
    else if (c == '-' && !isnum) {
      if (state == SCC_ST_START) goto normal_char;
      if (state == SCC_ST_RANGE) {
	r = REGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;
	goto err_exit;
      }
      if (PPEEK == ']')          goto normal_char;

      if (last == SCC_LAST_NONE) {
	r = REGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;
	goto err_exit;
      }
      if (last == SCC_LAST_CLASS) {
	r = REGERR_CHAR_CLASS_VALUE_AT_START_OF_RANGE;
	goto err_exit;
d2233 3
a2235 1
      state = SCC_ST_RANGE;
d2238 23
a2260 9
    normal_char:
      if (state == SCC_ST_RANGE) {
	if (last == SCC_LAST_VALUE) {
	  if (c < last_val) {
	    r = REGERR_RIGHT_SMALLER_THAN_LEFT_IN_CLASS_RANGE;
	    goto err_exit;
	  }
	  for (; last_val <= c; last_val++) {
	    BITSET_SET_BIT(NCCLASS(node).bs, last_val);
d2262 4
d2267 5
a2271 3
	else { /* last: SCC_LAST_MBVALUE */
	  r = REGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;
	  goto err_exit;
a2272 1
	last  = SCC_LAST_NONE;
d2275 2
a2276 3
	BITSET_SET_BIT(NCCLASS(node).bs, c);
	last_val = c;
	last  = SCC_LAST_VALUE;
a2277 1
      state = SCC_ST_NORMAL;
d2281 5
d2310 2
d2369 8
a2376 1
    *rnode = node_new_qualifier(lower, upper, (c == '{' ? 1 : 0));
d2574 2
a2575 3
      if (type == SC_END) {
	if (env->paren_nest != pnest)
	  return REGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;
d2577 1
a2577 2
	*last_is_group = 1;
      }
a2640 55
is_valid_qualifier_target(Node* node)
{
  switch (NTYPE(node)) {
  case N_CTYPE:
    switch (NCTYPE(node).type) {
    case CTYPE_WORD_BOUND:
    case CTYPE_NOT_WORD_BOUND:
#ifdef USE_WORD_BEGIN_END
    case CTYPE_WORD_BEGIN:
    case CTYPE_WORD_END:
#endif
      return 0;
      break;
    }
    break;

  case N_ANCHOR:
    return 0;
    break;

  case N_EFFECT:
    switch (NEFFECT(node).type) {
    case EFFECT_PREC_READ:
    case EFFECT_PREC_READ_NOT:
    case EFFECT_LOOK_BEHIND:
    case EFFECT_LOOK_BEHIND_NOT:
      return 0;
      break;
    }
    break;

  case N_OPTION:
    return is_valid_qualifier_target(NOPTION(node).target);
    break;

  case N_LIST: /* ex. (?:\G\A)* */
    do {
      if (is_valid_qualifier_target(NCONS(node).left)) return 1;
    } while (IS_NOT_NULL(node = NCONS(node).right));
    return 0;
    break;

  case N_ALT:  /* ex. (?:abc|\A)* */
    do {
      if (! is_valid_qualifier_target(NCONS(node).left)) return 0;
    } while (IS_NOT_NULL(node = NCONS(node).right));
    break;

  default:
    break;
  }
  return 1;
}

static int
a2645 1
  QualifierNode* qn;
d2659 3
a2661 14
      if (IS_NULL(*last))
	return REGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;

      qn = &(NQUALIFIER(curr));
      if (qn->lower == 1 && qn->upper == 1) {
	if (! is_valid_qualifier_target(*last))
	  return REGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;
	break;
      }

      switch (NTYPE(*last)) {
      case N_STRING:
      case N_STRING_RAW:
	if (!last_is_group) {
d2668 2
a2669 20
	    last_is_group = 0;
	    goto concat;
	  }
	}
	break;

      case N_QUALIFIER:
	{ /* check double repeat '**', '+*', "?+", "{1,infinite}*" etc. */
	  QualifierNode* qnlast = &(NQUALIFIER(*last));

	  if (qn->by_number == 0 && qnlast->by_number == 0) {
	    if ((qnlast->lower == 0 || qnlast->lower == 1)) {
	      if (IS_REPEAT_INFINITE(qnlast->upper) || /* "*", "+" */
		  qnlast->upper == 1) {                /* "?" */
		if (qn->lower <= 1 && IS_REPEAT_INFINITE(qn->upper))
		  return REGERR_NESTED_REPEAT_OPERATOR;
		if (qn->lower == 0 && qn->upper == 1)
		  return REGERR_NESTED_REPEAT_OPERATOR;
	      }
	    }
d2672 3
a2674 6
	break;

      default:
	if (! is_valid_qualifier_target(*last))
	  return REGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;
	break;
d2676 3
a2679 4
      NQUALIFIER(curr).target = *last;
      *last = curr;
      last_is_group = 0;
      break;
d2709 1
a2709 1
	if (type == SC_END && NTYPE(NCONS(*top).right) != N_ALT) {
a2725 1
	if (type < 0) return type;
d2790 1
a2790 1
  OP_EXACTMB3N,         /* mb length = 3 */
d2906 1
d2913 1
a2915 1
#ifdef UNALIGNED_WORD_ACCESS
a2939 17
#else

#define GET_RELADDR_INC(addr,p)      GET_SHORT_INC(addr,p)
#define GET_LENGTH_INC(len,p)        GET_SHORT_INC(len,p)
#define GET_MEMNUM_INC(num,p)        GET_SHORT_INC(num,p)
#define GET_REPEATNUM_INC(num,p)     GET_INT_INC(num,p)
#define GET_OPTION_INC(option,p)     GET_UINT_INC(option,p)

#define SERIALIZE_RELADDR(addr,p)    SERIALIZE_SHORT(addr,p)
#define SERIALIZE_LENGTH(len,p)      SERIALIZE_SHORT(len,p)
#define SERIALIZE_MEMNUM(num,p)      SERIALIZE_SHORT(num,p)
#define SERIALIZE_REPEATNUM(num,p)   SERIALIZE_INT(num,p)
#define SERIALIZE_OPTION(option,p)   SERIALIZE_UINT(option,p)

#define SERIALIZE_BUFSIZE            SIZEOF_INT

#endif  /* UNALIGNED_WORD_ACCESS */
d2946 4
d2980 1
a2980 1
    (op) == OP_EXACTMB3N || (op) == OP_EXACTMBN  || (op) == OP_EXACTN_IC)
a2993 2

#ifdef UNALIGNED_WORD_ACCESS
a2994 5
#else
  UChar buf[SERIALIZE_BUFSIZE];
  SERIALIZE_RELADDR(ra, buf);
  BBUF_ADD(reg, buf, SIZE_RELADDR);
#endif
a3001 2

#ifdef UNALIGNED_WORD_ACCESS
a3002 5
#else
  UChar buf[SERIALIZE_BUFSIZE];
  SERIALIZE_LENGTH(l, buf);
  BBUF_ADD(reg, buf, SIZE_LENGTH);
#endif
a3009 2

#ifdef UNALIGNED_WORD_ACCESS
a3010 5
#else
  UChar buf[SERIALIZE_BUFSIZE];
  SERIALIZE_MEMNUM(n, buf);
  BBUF_ADD(reg, buf, SIZE_MEMNUM);
#endif
a3017 2

#ifdef UNALIGNED_WORD_ACCESS
a3018 5
#else
  UChar buf[SERIALIZE_BUFSIZE];
  SERIALIZE_REPEATNUM(n, buf);
  BBUF_ADD(reg, buf, SIZE_REPEATNUM);
#endif
a3024 1
#ifdef UNALIGNED_WORD_ACCESS
a3025 5
#else
  UChar buf[SERIALIZE_BUFSIZE];
  SERIALIZE_OPTION(option, buf);
  BBUF_ADD(reg, buf, SIZE_OPTION);
#endif
d3102 2
a3103 2
  case 3:
    op = OP_EXACTMB3N;
a3287 1
#ifdef UNALIGNED_WORD_ACCESS
a3289 14
#else
  int r, pad_size;
  UChar* p = BBUF_GET_ADD_POSITION(reg) + SIZE_LENGTH;

  GET_ALIGNMENT_PAD_SIZE(p, pad_size);
  add_length(reg, mbuf->used - offset + (WORD_ALIGNMENT_SIZE - 1));
  if (pad_size) add_bytes(reg, PadBuf, pad_size);

  r = add_bytes(reg, mbuf->p + offset, mbuf->used - offset);

  pad_size = (WORD_ALIGNMENT_SIZE - 1) - pad_size;
  if (pad_size) add_bytes(reg, PadBuf, pad_size);
  return r;
#endif
a3306 1
#ifdef UNALIGNED_WORD_ACCESS
a3307 3
#else
    len += SIZE_LENGTH + cc->mbuf->used + (WORD_ALIGNMENT_SIZE - 1);
#endif
d4425 4
d6570 2
a6571 8
      if (IS_FIND_CONDITION(option)) {
	if (IS_FIND_NOT_EMPTY(option) && s == sstart) {
	  best_len = REG_MISMATCH;
	  goto fail; /* for retry */
	}
	if (IS_FIND_LONGEST(option) && s < end) {
	  goto fail; /* for retry */
	}
d6710 1
a6710 1
    case OP_EXACTMB3N:  STAT_OP_IN(OP_EXACTMB3N);
d6712 1
a6712 1
      DATA_ENSURE(tlen * 3);
d6717 1
d6719 1
a6719 1
      sprev = s - 3;
d6751 2
a6762 5
#ifdef UNALIGNED_WORD_ACCESS
	if (! is_in_wc_range(p, wc)) goto fail;
#else
	q = p;
	ALIGNMENT_RIGHT(q);
a6763 1
#endif
a6764 1
      p += tlen;
d6795 1
a6795 8
      if (BITSET_AT((BitSetRef )p, *s) == 0) {
	s += mblen(encode, *s);
	if (s > end) s = end;
	p += SIZE_BITSET;
	GET_LENGTH_INC(tlen, p);
	p += tlen;
	goto success;
      }
d6800 2
a6808 1
	  p += tlen;
a6815 5
#ifdef UNALIGNED_WORD_ACCESS
	if (is_in_wc_range(p, wc)) goto fail;
#else
	q = p;
	ALIGNMENT_RIGHT(q);
a6816 1
#endif
a6817 1
      p += tlen;
d7784 1
a7784 1
		    UChar* text, UChar* adjust_text, UChar* text_start)
a8416 9
  clear_optimize_info(reg);
#ifndef REG_DONT_OPTIMIZE
  r = set_optimize_info_from_tree(root, reg);
  if (r) goto err;
#endif

  if (IS_FIND_CONDITION(reg->options))
    MEM_STATS_ON_ALL(reg->mem_stats);

d8420 6
d8430 1
a8430 1
  print_compiled_byte_code_list(stderr, reg);
a8574 80
#ifdef USE_COMPATIBILITY_FOR_RUBY_EXTENSION_LIBRARY
static const unsigned char mbctab_ascii[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

static const unsigned char mbctab_euc[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
};

static const unsigned char mbctab_sjis[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0
};

static const unsigned char mbctab_utf8[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 0, 0,
};

const unsigned char *re_mbctab = mbctab_ascii;
#endif

a8575 3
#ifdef REG_RUBY_M17N
re_mbcinit(RegCharEncoding enc)
#else
a8576 1
#endif
a8577 3
#ifdef REG_RUBY_M17N
  RegDefaultCharEncoding = enc;
#else
a8578 18
#endif

#ifdef USE_COMPATIBILITY_FOR_RUBY_EXTENSION_LIBRARY
  switch (mb_code) {
  case MBCTYPE_ASCII:
    re_mbctab = mbctab_ascii;
    break;
  case MBCTYPE_EUC:
    re_mbctab = mbctab_euc;
    break;
  case MBCTYPE_SJIS:
    re_mbctab = mbctab_sjis;
    break;
  case MBCTYPE_UTF8:
    re_mbctab = mbctab_utf8;
    break;
  }
#endif
d8637 1
a8637 1
  { OP_EXACTMB3N,         "exactmb3n"  ,     ARG_SPECIAL },
d8727 8
a8758 1
  UChar *q;
d8820 1
a8820 1
    case OP_EXACTMB3N:
d8822 2
a8823 2
      p_len_string(f, len, 3, bp);
      bp += len * 3;
d8863 1
a8863 5
      q = bp;
#ifndef UNALIGNED_WORD_ACCESS
      ALIGNMENT_RIGHT(q);
#endif
      GET_WCINT(wc, q);
d8873 1
a8873 5
      q = bp;
#ifndef UNALIGNED_WORD_ACCESS
      ALIGNMENT_RIGHT(q);
#endif
      GET_WCINT(wc, q);
@


1.1.1.6
log
@Import Oni Guruma 20020401 (version 1.3).
@
text
@a49 1
#define USE_WARNING_STRANGE_NESTED_REPEAT_OPERATOR
a185 6
  case REGERR_TOO_BIG_WIDE_CHAR_VALUE:
    p = "too big wide-char value"; break;
  case REGERR_TOO_LONG_WIDE_CHAR_VALUE:
    p = "too long wide-char value"; break;
  case REGERR_INVALID_WIDE_CHAR_VALUE:
    p = "invalid wide-char value"; break;
d740 1
a740 3
#define MB2WC_AVAILABLE(enc)     1
#define WC2MB_FIRST(enc, wc)          m17n_firstbyte((enc),(wc))

a780 16
static int
wc2mb_buf(WCInt wc, UChar **bufs, UChar **bufe, RegCharEncoding enc)
{
  int c, len;

  c = m17n_firstbyte(enc, wc);
  len = mblen(enc, c);
  if (len > (*bufe - *bufs)) {
    *bufs = xmalloc(len);
    CHECK_NULL_RETURN_VAL(*bufs, REGERR_MEMORY);    
  }
  m17n_mbcput(enc, wc, *bufs);
  *bufe = *bufs + len;
  return 0;
}

d802 4
a805 1
  { /* euc-jp */
a813 1
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3,
a814 1
    1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
d817 2
a818 3
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1
d820 1
a820 1
  { /* sjis */
d829 4
a834 4
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
d836 1
a836 1
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
d838 1
a838 1
  { /* utf8 */
d847 2
d854 1
a854 3
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 1, 1
a887 1
#define WC2MB_FIRST(code, wc)       wc2mb_first(code, wc)
d894 1
a894 2
#define IS_INDEPENDENT_TRAIL(code) \
        ((code) == REGCODE_ASCII || (code) == REGCODE_UTF8)
d953 5
d962 10
a971 2
static int
wc2mb_first(RegCharEncoding code, WCInt wc)
d973 15
d989 8
a996 1
    return (wc & 0xff);
d998 8
a1005 17
  else if (code == REGCODE_UTF8) {
    if ((wc & 0xffffff80) == 0)
      return wc;
    else {
      if ((wc & 0xfffff800) == 0)
	return ((wc>>6)& 0x1f) | 0xc0;
      else if ((wc & 0xffff0000) == 0)
	return ((wc>>12) & 0x0f) | 0xe0;
      else if ((wc & 0xffe00000) == 0)
	return ((wc>>18) & 0x07) | 0xf0;
      else if ((wc & 0xfc000000) == 0)
	return ((wc>>24) & 0x03) | 0xf8;
      else if ((wc & 0x80000000) == 0)
	return ((wc>>30) & 0x01) | 0xfc;
      else {
	return REGERR_TOO_BIG_WIDE_CHAR_VALUE;
      }
d1007 4
d1012 11
a1022 2
  else {
    int first;
d1024 2
a1025 16
    if ((wc & 0xff0000) != 0) {
      first = (wc >> 16) & 0xff;
      if (mblen(code, first) != 3)
	return REGERR_INVALID_WIDE_CHAR_VALUE;
    }
    else if ((wc & 0xff00) != 0) {
      first = (wc >> 8) & 0xff;
      if (mblen(code, first) != 2)
	return REGERR_INVALID_WIDE_CHAR_VALUE;
    }
    else {
      if (mblen(code, wc) != 1)
	return REGERR_INVALID_WIDE_CHAR_VALUE;
      return wc;
    }
    return first;
d1027 1
d1030 3
a1032 2
static int
wc2mb(WCInt wc, UChar buf[], RegCharEncoding code)
d1034 1
a1034 2
#define UTF8_TRAILS(wc, shift)   ((((wc) >> (shift)) & 0x3f) | 0x80)
#define UTF8_TRAIL0(wc)          (((wc) & 0x3f) | 0x80)
d1036 3
a1038 36
  UChar *p = buf;

  if (code == REGCODE_UTF8) {
    if ((wc & 0xffffff80) == 0)
      *p++ = wc;
    else {
      if ((wc & 0xfffff800) == 0) {
	*p++ = ((wc>>6)& 0x1f) | 0xc0;
      }
      else if ((wc & 0xffff0000) == 0) {
	*p++ = ((wc>>12) & 0x0f) | 0xe0;
	*p++ = UTF8_TRAILS(wc, 6);
      }
      else if ((wc & 0xffe00000) == 0) {
	*p++ = ((wc>>18) & 0x07) | 0xf0;
	*p++ = UTF8_TRAILS(wc, 12);
	*p++ = UTF8_TRAILS(wc,  6);
      }
      else if ((wc & 0xfc000000) == 0) {
	*p++ = ((wc>>24) & 0x03) | 0xf8;
	*p++ = UTF8_TRAILS(wc, 18);
	*p++ = UTF8_TRAILS(wc, 12);
	*p++ = UTF8_TRAILS(wc,  6);
      }
      else if ((wc & 0x80000000) == 0) {
	*p++ = ((wc>>30) & 0x01) | 0xfc;
	*p++ = UTF8_TRAILS(wc, 24);
	*p++ = UTF8_TRAILS(wc, 18);
	*p++ = UTF8_TRAILS(wc, 12);
	*p++ = UTF8_TRAILS(wc,  6);
      }
      else {
	return REGERR_TOO_BIG_WIDE_CHAR_VALUE;
      }
      *p++ = UTF8_TRAIL0(wc);
    }
d1041 1
a1041 6
    if ((wc & 0xff0000) != 0) *p++ = ((wc >> 16) & 0xff);
    if ((wc &   0xff00) != 0) *p++ = ((wc >>  8) & 0xff);
    *p++ = (wc & 0xff);

    if (mblen(code, buf[0]) != (p - buf))
      return REGERR_INVALID_WIDE_CHAR_VALUE;
d1043 1
a1043 2

  return p - buf;
d1046 2
a1047 2
static int
wc2mb_buf(WCInt wc, UChar **bufs, UChar **bufe, RegCharEncoding code)
d1049 2
a1050 3
  int r;
  r = wc2mb(wc, *bufs, code);
  if (r < 0) return r;
d1052 1
a1052 2
  *bufe = (*bufs) + r;
  return 0;
a1054 7
#define eucjp_islead(c)    ((UChar )((c) - 0xa1) > 0xfe - 0xa1)
#define utf8_islead(c)     ((UChar )((c) & 0xc0) != 0x80)
#define sjis_ismbfirst(c)  ismb(REGCODE_SJIS, (c))
#define sjis_ismbtrail(c)  SJIS_FOLLOW_TABLE[(c)]

#endif /* not REG_RUBY_M17N */

d1056 5
a1060 10
get_left_adjust_char_head(RegCharEncoding code, UChar* start, UChar* s);
static UChar*
get_right_adjust_char_head(RegCharEncoding code, UChar* start, UChar* s);
static UChar*
get_right_adjust_char_head_with_prev(RegCharEncoding code,
				     UChar* start, UChar* s, UChar** prev);
static UChar*
get_prev_char_head(RegCharEncoding code, UChar* start, UChar* s);
static UChar*
step_backward_char(RegCharEncoding code, UChar* start, UChar* s, int n);
d1062 4
a1483 2
  UChar *pattern;
  UChar *pattern_end;
d1566 4
a1569 1

d1574 21
d1600 1
a1600 1
add_wc_range_to_buf(BBuf** pbuf, WCInt from, WCInt to, UChar cfrom, UChar cto)
d1697 1
d1709 1
a1709 16
  return add_wc_range_to_buf(pbuf, wc_from, wc_to, from[0], to[0]);
}

static int
add_wc_range(BBuf** pbuf, RegCharEncoding code, WCInt from, WCInt to)
{
  int cfrom, cto;

  if (from > to)
    return REGERR_RIGHT_SMALLER_THAN_LEFT_IN_CLASS_RANGE;

  cfrom = WC2MB_FIRST(code, from);
  if (cfrom < 0) return cfrom;
  cto = WC2MB_FIRST(code, to);
  if (cto < 0) return cto;
  return add_wc_range_to_buf(pbuf, from, to, (UChar )cfrom, (UChar )cto);
a1890 2
#define SCB_MAXBUF  10

d1892 1
a1892 3
  WCInt wc;
  UChar *bufs, *bufe, buf[SCB_MAXBUF];
  UChar *prev;
a1896 2
  bufs = buf;

d1977 5
a1981 35
    if (!PEND && *p == '{') {
      PINC;
      prev = p;
      num = scan_unsigned_hexadecimal_number(&p, end, 8);
      if (num < 0) return REGERR_TOO_BIG_WIDE_CHAR_VALUE;
      if (!PEND && IS_XDIGIT(*p) && p - prev >= 8)
	return REGERR_TOO_LONG_WIDE_CHAR_VALUE;

      if (p == prev || PEND || *p != '}') {
	/* can't read nothing or invalid format */
	bufs[0] = 'x'; bufs[1] = '{';
	bufe = bufs + 2;
	p = prev;
      }
      else {
	PINC;
	wc = (WCInt )num;
	bufe = bufs + SCB_MAXBUF;
	num = wc2mb_buf(wc, &bufs, &bufe, env->code);
	if (num < 0) return num;
	if ((bufe - bufs) == 1) {
	  num = bufs[0];
	  goto string_raw;
	}
      }
      goto string_concat;
    }
    else {
      prev = p;
      num = scan_unsigned_hexadecimal_number(&p, end, 2);
      if (num < 0) return REGERR_TOO_BIG_NUMBER;
      if (p == prev) {  /* can't read nothing. */
	num = 0; /* but, it's not error */
      }
      goto string_raw;
d1983 1
a2029 13
 string_concat:
  if (env->last_node && NTYPE(env->last_node) == N_STRING) {
    node_str_cat(env->last_node, bufs, bufe);
    *src = p;
    if (bufs != buf) xfree(bufs);
    return 1;  /* string concat */
  }
  else {
    *node = node_new_str(bufs, bufe);
    if (bufs != buf) xfree(bufs);
    goto end;
  }

d2044 2
a2045 2
    r = add_wc_range_to_buf(&(mbuf), (WCInt )0x80, ~((WCInt )0),\
                            (UChar )0x80, (UChar )0xff);\
d2052 1
a2052 1
		     RegCharEncoding code, Node* node, int *num, WCInt *wc)
d2055 1
a2055 2
  UChar *prev;
  UChar *p = *src;
d2115 4
a2118 29
    if (!PEND && *p == '{') {
      PINC;
      prev = p;
      *num = scan_unsigned_hexadecimal_number(&p, end, 8);
      if (*num < 0) return REGERR_TOO_BIG_WIDE_CHAR_VALUE;
      if (!PEND && IS_XDIGIT(*p) && p - prev >= 8)
	return REGERR_TOO_LONG_WIDE_CHAR_VALUE;

      if (p == prev || PEND || *p != '}') {
	/* can't read nothing or invalid format */
	*num = (int )'x';
	p = prev - 1;
	r = 1;
      }
      else {
	*wc = *num;
	*num = 0;
	PINC;
	r = 2; /* read wc number */
      }
    }
    else {
      prev = p;
      *num = scan_unsigned_hexadecimal_number(&p, end, 2);
      if (*num < 0) return REGERR_TOO_BIG_NUMBER;
      if (p == prev) {  /* can't read nothing. */
	*num = 0; /* but, it's not error */
      }
      r = 1; /* read number */
d2120 1
d2250 1
a2250 2
#define SCC_LAST_WCVALUE   3
#define SCC_LAST_CLASS     4
d2254 1
a2254 2
  WCInt wc, last_wc;
  int i, c, r, isnum, last_val, state, last;
d2298 1
a2298 1
      r = scan_backslash_in_char_class(&p, end, code, node, &c, &wc);
d2309 1
a2309 1
      else if (r == 1) { /* 1: number */
a2311 11
      else { /* r == 2: wc number */
	r = WC2MB_FIRST(code, wc);
	if (r < 0) goto err_exit;
	if (mblen(code, r) > 1) {
	  isnum = 2;
	}
	else {
	  isnum = 1;
	  c = r;
	}
      }
d2365 14
a2378 1
	if (last == SCC_LAST_VALUE) {
a2380 26
#if 0
#ifndef REG_RUBY_M17N
	  if (code == REGCODE_UTF8) {
	    /* allow only if utf-8 */
	    int i;
	    for (i = last_val; i <= 0x7f; i++) {
	      BITSET_SET_BIT(NCCLASS(node).bs, i);
	    }
	    last_mbs[0] = (UChar )0x80;
	    last_mbs[1] = (UChar )0;
	    last_true_mblen = 1;
	  }
	  else {
	    r = REGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;
	    goto err_exit;
	  }
#endif
#endif
	}
	else if (last == SCC_LAST_WCVALUE) {
	  wc = MB2WC(curr_mbs, curr_mbs + curr_true_mblen, code);
	  r = add_wc_range(&(NCCLASS(node).mbuf), code, last_wc, wc);
	  if (r < 0) goto err_exit;

	  state = SCC_ST_NORMAL;
	  continue;
d2429 4
a2432 9
	if (isnum == 2) {
	  if (last == SCC_LAST_WCVALUE) {
	    r = add_wc_range(&(NCCLASS(node).mbuf), code, last_wc, wc);
	    if (r < 0) goto err_exit;
	  }
	  else if (last == SCC_LAST_MBVALUE) {
	    last_wc = MB2WC(last_mbs, last_mbs + last_true_mblen, code);
	    r = add_wc_range(&(NCCLASS(node).mbuf), code, last_wc, wc);
	    if (r < 0) goto err_exit;
d2434 2
a2435 18
	  else { /* SCC_LAST_VALUE */
	    r = REGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;
	    goto err_exit;
#if 0
#ifndef REG_RUBY_M17N
	    if (code == REGCODE_UTF8) {
	      for (i = last_val; i <= 0x7f; i++) {
		BITSET_SET_BIT(NCCLASS(node).bs, i);
	      }
	      r = add_wc_range(&(NCCLASS(node).mbuf), code, (WCInt )0x80, wc);
	      if (r < 0) goto err_exit;
	    }
	    else {
	      r = REGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;
	      goto err_exit;
	    }
#endif
#endif
d2438 3
a2440 14
	else {
	  if (last == SCC_LAST_VALUE) {
	    if (c < last_val) {
	      r = REGERR_RIGHT_SMALLER_THAN_LEFT_IN_CLASS_RANGE;
	      goto err_exit;
	    }
	    for (; last_val <= c; last_val++) {
	      BITSET_SET_BIT(NCCLASS(node).bs, last_val);
	    }
	  }
	  else { /* last: SCC_LAST_MBVALUE or WCVALUE */
	    r = REGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;
	    goto err_exit;
	  }
d2445 3
a2447 11
	if (isnum == 2) {
	  last_wc = wc;
	  last = SCC_LAST_WCVALUE;
	  r = add_wc_range(&(NCCLASS(node).mbuf), code, wc, wc);
	  if (r < 0) goto err_exit;
	}
	else {
	  BITSET_SET_BIT(NCCLASS(node).bs, c);
	  last_val = c;
	  last = SCC_LAST_VALUE;
	}
d2518 2
a2519 8
    {
      int cc;
      if (!PEND && ((cc = PPEEK) == '*' || cc == '+'))
	return REGERR_NESTED_REPEAT_OPERATOR;

      lower = (c == '+' ? 1 : 0);
      upper = (c == '?' ? 1 : REPEAT_INFINITE);
    }
a2854 4
#define IS_POPULAR_QUALIFIER(qf) \
 (((qf)->lower == 0 && ((qf)->upper == 1 || IS_REPEAT_INFINITE((qf)->upper))) ||\
  ((qf)->lower == 1 && IS_REPEAT_INFINITE((qf)->upper))) 

d2902 1
a2902 3
#ifdef USE_WARNING_STRANGE_NESTED_REPEAT_OPERATOR
	{ /* check strange double repeat. */
	  /* verbose warn (?:.?)? etc... but not warn (.?)? etc... */
d2905 8
a2912 22
	  if (qn->by_number == 0 && qnlast->by_number == 0 &&
	      IS_POPULAR_QUALIFIER(qnlast)) {
	    if (IS_REPEAT_INFINITE(qn->upper)) {
	      if (qn->lower == 0) { /* '*' */
		goto strange_nest;
	      }
	      else if (qn->lower == 1) { /* '+' */
	      strange_nest:
		{
		  UChar *pat = k_strdup(env->pattern, env->pattern_end);
		  rb_warning("redundant nested repeat operator %s", pat);
		  xfree(pat);
		  goto qualifier_exit;
		}
	      }
	    }
	    else if (qn->upper == 1 && qn->lower == 0) {
	      if (qn->greedy) { /* '?' */
		if (qnlast->lower != 1) goto strange_nest;
	      }
	      else { /* '??' */
		if (!qnlast->greedy || qnlast->upper == 1) goto strange_nest;
a2916 1
#endif
a2924 1
    qualifier_exit:
d3011 5
a3015 7
  env.option      = reg->options;
  env.code        = reg->code;
  env.regnum      = 0;
  env.last_node   = NULL;
  env.paren_nest  = 0;
  env.pattern     = pattern;
  env.pattern_end = end;
a6780 21
static int
is_in_wc_range(UChar* p, WCInt wc)
{
  WCInt n, *data;
  int low, high, x;

  GET_WCINT(n, p);
  data = (WCInt* )p;
  data++;

  for (low = 0, high = n; low < high; ) {
    x = (low + high) >> 1;
    if (wc > data[x * 2 + 1])
      low = x + 1;
    else
      high = x;
  }

  return ((low < n && wc >= data[low * 2]) ? 1 : 0);
}

d6917 2
a6918 3
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
d6927 3
a6929 5
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
d6931 1
a6931 1
      p++; s++;
d6938 4
a6941 7
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
d6943 1
a6943 1
      p++; s++;
d6950 5
a6954 9
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
d6956 1
a6956 1
      p++; s++;
d6986 2
a6987 4
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
d6993 2
a6994 4
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
d6996 2
a6997 4
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
d7004 4
a7007 8
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
d7009 2
a7010 4
      if (*p != *s) goto fail;
      p++; s++;
      if (*p != *s) goto fail;
      p++; s++;
d7019 2
a7020 4
	if (*p != *s) goto fail;
	p++; s++;
	if (*p != *s) goto fail;
	p++; s++;
d7031 3
a7033 6
	if (*p != *s) goto fail;
	p++; s++;
	if (*p != *s) goto fail;
	p++; s++;
	if (*p != *s) goto fail;
	p++; s++;
d7046 1
a7046 2
	if (*p != *s) goto fail;
	p++; s++;
a7754 97
static UChar*
get_left_adjust_char_head(RegCharEncoding code, UChar* start, UChar* s)
{
  UChar *p;
  int len;

  if (s <= start) return s;
  p = s;

#ifdef REG_RUBY_M17N
  while (!m17n_islead(code, *p) && p > start) p--;
  while (p + (len = mblen(code, *p)) < s) {
    p += len;
  }
  if (p + len == s) return s;
  return p;
#else

  if (code == REGCODE_ASCII) {
    return p;
  }
  else if (code == REGCODE_EUCJP) {
    while (!eucjp_islead(*p) && p > start) p--;
    len = mblen(code, *p);
    if (p + len > s) return p;
    p += len;
    return p + ((s - p) & ~1);
  }
  else if (code == REGCODE_SJIS) {
    if (sjis_ismbtrail(*p)) {
      while (p > start) {
	if (! sjis_ismbfirst(*--p)) {
	  p++;
	  break;
	}
      } 
    }
    len = mblen(code, *p);
    if (p + len > s) return p;
    p += len;
    return p + ((s - p) & ~1);
  }
  else { /* REGCODE_UTF8 */
    while (!utf8_islead(*p) && p > start) p--;
    return p;
  }
#endif  /* REG_RUBY_M17N */
}

static UChar*
get_right_adjust_char_head(RegCharEncoding code, UChar* start, UChar* s)
{
  UChar* p = get_left_adjust_char_head(code, start, s);

  if (p < s) {
    p += mblen(code, *p);
  }
  return p;
}

static UChar*
get_right_adjust_char_head_with_prev(RegCharEncoding code,
				     UChar* start, UChar* s, UChar** prev)
{
  UChar* p = get_left_adjust_char_head(code, start, s);

  if (p < s) {
    if (prev) *prev = p;
    p += mblen(code, *p);
  }
  else {
    if (prev) *prev = (UChar* )NULL; /* Sorry */
  }
  return p;
}

static UChar*
get_prev_char_head(RegCharEncoding code, UChar* start, UChar* s)
{
  if (s <= start)
    return (UChar* )NULL;

  return get_left_adjust_char_head(code, start, s - 1);
}

static UChar*
step_backward_char(RegCharEncoding code, UChar* start, UChar* s, int n)
{
  while (IS_NOT_NULL(s) && n-- > 0) {
    if (s <= start)
      return (UChar* )NULL;

    s = get_left_adjust_char_head(code, start, s - 1);
  }
  return s;
}

a8652 4
#ifdef REG_DEBUG
  if (r != REG_MISMATCH)
    fprintf(stderr, "regex_search: error %d", r);
#endif
a8675 2
  THREAD_ATOMIC_START;

a8705 1
  THREAD_ATOMIC_END;
a9025 3
  regex_inited = 1;

  THREAD_ATOMIC_START;
a9034 1
  THREAD_ATOMIC_END;
d9036 1
a9045 1
  THREAD_ATOMIC_START;
a9050 1
  THREAD_ATOMIC_END;
@


1.1.1.7
log
@Import Oni Guruma 20020416.
@
text
@d50 1
a50 1
#define USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR
d3042 3
a3044 88
/* ?:0, *:1, +:2, ??:3, *?:4, +?:5 */
static int popular_qualifier_num(QualifierNode* qf)
{
  if (qf->greedy) {
    if (qf->lower == 0) {
      if (qf->upper == 1) return 0;
      else if (IS_REPEAT_INFINITE(qf->upper)) return 1;
    }
    else if (qf->lower == 1) {
      if (IS_REPEAT_INFINITE(qf->upper)) return 2;
    }
  }
  else {
    if (qf->lower == 0) {
      if (qf->upper == 1) return 3;
      else if (IS_REPEAT_INFINITE(qf->upper)) return 4;
    }
    else if (qf->lower == 1) {
      if (IS_REPEAT_INFINITE(qf->upper)) return 5;
    }
  }
  return -1;
}

static void reduce_nested_qualifier(Node* pnode, Node* cnode)
{
#define NQ_ASIS    0   /* as is     */
#define NQ_DEL     1   /* delete parent */
#define NQ_A       2   /* to '*'    */
#define NQ_AQ      3   /* to '*?'   */
#define NQ_QQ      4   /* to '??'   */
#define NQ_P_QQ    5   /* to '+)??' */
#define NQ_PQ_Q    6   /* to '+?)?' */

  static char reduces[][6] = {
    {NQ_DEL,  NQ_A,    NQ_A,   NQ_QQ,   NQ_AQ,   NQ_ASIS}, /* '?'  */
    {NQ_DEL,  NQ_DEL,  NQ_DEL, NQ_P_QQ, NQ_P_QQ, NQ_DEL},  /* '*'  */
    {NQ_A,    NQ_A,    NQ_DEL, NQ_ASIS, NQ_P_QQ, NQ_DEL},  /* '+'  */
    {NQ_DEL,  NQ_AQ,   NQ_AQ,  NQ_DEL,  NQ_AQ,   NQ_AQ},   /* '??' */
    {NQ_DEL,  NQ_DEL,  NQ_DEL, NQ_DEL,  NQ_DEL,  NQ_DEL},  /* '*?' */
    {NQ_ASIS, NQ_PQ_Q, NQ_DEL, NQ_AQ,   NQ_AQ,   NQ_DEL}   /* '+?' */
  };

  int pnum, cnum;
  QualifierNode *p, *c;

  p = &(NQUALIFIER(pnode));
  c = &(NQUALIFIER(cnode));
  pnum = popular_qualifier_num(p);
  cnum = popular_qualifier_num(c);

  switch(reduces[cnum][pnum]) {
  case NQ_DEL:
    *p = *c;
    break;
  case NQ_A:
    p->target = c->target;
    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 1;
    break;
  case NQ_AQ:
    p->target = c->target;
    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 0;
    break;
  case NQ_QQ:
    p->target = c->target;
    p->lower  = 0;  p->upper = 1;  p->greedy = 0;
    break;
  case NQ_P_QQ:
    p->target = cnode;
    p->lower  = 0;  p->upper = 1;  p->greedy = 0;
    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 1;
    return ;
    break;
  case NQ_PQ_Q:
    p->target = cnode;
    p->lower  = 0;  p->upper = 1;  p->greedy = 1;
    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 0;
    return ;
    break;
  case NQ_ASIS:
    p->target = cnode;
    return ;
    break;
  }

  c->target = (Node* )0;
  node_free(cnode);
}
d3093 2
a3094 1
	{ /* check redundant double repeat. */
d3098 2
a3099 2
#ifdef USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR
	  if (qn->by_number == 0 && qnlast->by_number == 0) {
d3102 3
d3110 1
a3110 1
		  goto qualifier_warn_exit;
a3112 5
	      else if (qn->lower == 1) { /* '+' */
		/* (?:a?)+? only allowed. */
		if (qn->greedy || !(qnlast->upper == 1 && qnlast->greedy))
		  goto strange_nest;
	      }
d3116 1
a3116 2
		if (!(qnlast->lower == 1 && qnlast->greedy == 0)) /* not '+?' */
		  goto strange_nest;
d3119 1
a3119 4
		/* '(?:a+)?? only allowd. (?:a*)?? can be replaced to (?:a+)?? */
		if (!(qnlast->greedy &&
		      qnlast->lower == 1 && IS_REPEAT_INFINITE(qnlast->upper)))
		  goto strange_nest;
d3123 1
a3124 7
	qualifier_warn_exit:
	  if (popular_qualifier_num(qnlast) >= 0 &&
	      popular_qualifier_num(qn)     >= 0) {
	    reduce_nested_qualifier(curr, *last);
	    goto qualifier_exit;
	  }
	}
d3133 1
a3134 1
    qualifier_exit:
a3949 3
  else if (!qn->greedy && qn->upper == 1 && qn->lower == 0) { /* '??' */
    len = SIZE_OP_PUSH + SIZE_OP_JUMP + tlen;
  }
a4067 8
  else if (!qn->greedy && qn->upper == 1 && qn->lower == 0) { /* '??' */
    r = add_opcode_rel_addr(reg, OP_PUSH, SIZE_OP_JUMP);
    if (r) return r;
    r = add_opcode_rel_addr(reg, OP_JUMP, tlen);
    if (r) return r;
    r = compile_tree(qn->target, reg);
    if (r) return r;
  }
a4674 14
  case N_ALT:
    {
      RegDistance tlen2;

      r = get_char_length_tree(NCONS(node).left, reg, &tlen);
      while (r == 0 && IS_NOT_NULL(node = NCONS(node).right)) {
	r = get_char_length_tree(NCONS(node).left, reg, &tlen2);
	if (r == 0 && tlen != tlen2)
	  r = -1;
      }
      if (r == 0) *len = tlen;
    }
    break;

a4686 13
  case N_QUALIFIER:
    {
      QualifierNode* qn = &(NQUALIFIER(node));
      if (qn->lower == qn->upper) {
	r = get_char_length_tree(qn->target, reg, &tlen);
	if (r == 0)
	  *len = distance_multiply(tlen, qn->lower);
      }
      else
	r = -1;
    }
    break;

d4717 5
a4721 1
      default:
d5018 1
a5018 1
    N_ANYCHAR | N_ANCHOR | N_EFFECT | N_QUALIFIER | N_ALT )
d7454 10
a7463 10
      if (! IS_MULTILINE(option)) {
	while (s < end) {
	  STACK_PUSH_ALT(p, s, sprev);
	  if (ismb(encode, *s)) {
	    n = mblen(encode, *s);
	    DATA_ENSURE(n);
	    sprev = s;
	    s += n;
	  }
	  else {
a7465 17
	    sprev = s;
	    s++;
	  }
	}
      }
      else {
	while (s < end) {
	  STACK_PUSH_ALT(p, s, sprev);
	  if (ismb(encode, *s)) {
	    n = mblen(encode, *s);
	    DATA_ENSURE(n);
	    sprev = s;
	    s += n;
	  }
	  else {
	    sprev = s;
	    s++;
d7467 2
d9492 1
a9492 1
  { OP_REPEAT_INC_NG,     "repeat-inc-ng",   ARG_MEMNUM  },
@


1.1.1.8
log
@Import Oni Guruma 20020424.
@
text
@d8 6
d15 10058
a10072 3
#include "regcomp.c"
#include "regexec.c"
#include "reggnu.c"
@
